{"union":
 "theorem is_closed.union : is_closed sâ‚ â†’ is_closed sâ‚‚ â†’ is_closed (sâ‚ âˆª sâ‚‚) := fun hâ‚ hâ‚‚ =>\n  by\n  rw [â† is_open_compl_iff] at *\n  rw [compl_union]\n  exact is_open.inter hâ‚ hâ‚‚\n#align is_closed.union is_closed.union\n\n",
 "topological_space_eq_iff":
 "theorem topological_space_eq_iff {t t' : topological_space Î±} : t = t' â†” âˆ€ s, @is_open Î± t s â†” @is_open Î± t' s :=\n  âŸ¨fun h s => h â–¸ iff.rfl, fun h => by\n    ext\n    exact h _âŸ©\n#align topological_space_eq_iff topological_space_eq_iff\n\n",
 "topological_space_eq":
 "/-\nCopyright (c) 2017 Johannes HÃ¶lzl. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johannes HÃ¶lzl, Mario Carneiro, Jeremy Avigad\n-/\n@[ext]\ntheorem topological_space_eq : âˆ€ {f g : topological_space Î±}, f.is_open = g.is_open â†’ f = g\n  | âŸ¨a, _, _, _âŸ©, âŸ¨b, _, _, _âŸ©, rfl => rfl\n#align topological_space_eq topological_space_eq\n\n",
 "tendsto_pure_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem tendsto_pure_nhds {Î± : Type _} [topological_space Î²] (f : Î± â†’ Î²) (a : Î±) : tendsto f (pure a) ((nhds) (f a)) :=\n  (tendsto_pure_pure f a).mono_right (pure_le_nhds _)\n#align tendsto_pure_nhds tendsto_pure_nhds\n\n",
 "tendsto_nhds_lim":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- If `g` tends to some `ğ“ a` along `f`, then it tends to `ğ“ (lim f g)`. We formulate\nthis lemma with a `[nonempty Î±]` argument of `lim` derived from `h` to make it useful for types\nwithout a `[nonempty Î±]` instance. Because of the built-in proof irrelevance, Lean will unify\nthis instance with any other instance. -/\ntheorem tendsto_nhds_lim {f : filter Î²} {g : Î² â†’ Î±} (h : âˆƒ a, tendsto g f ((nhds) a)) :\n    tendsto g f (nhds <| @lim _ _ _ (nonempty_of_exists h) f g) :=\n  le_nhds_Lim h\n#align tendsto_nhds_lim tendsto_nhds_lim\n\n",
 "tendsto_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\ntheorem tendsto_nhds {f : Î² â†’ Î±} {l : filter Î²} {a : Î±} :\n    tendsto f l ((nhds) a) â†” âˆ€ s, is_open s â†’ a âˆˆ s â†’ Â«expr â»Â¹' Â» f s âˆˆ l :=\n  all_mem_nhds_filter _ _ (fun s t h => preimage_mono h) _\n#align tendsto_nhds tendsto_nhds\n\n",
 "tendsto_inf_principal_nhds_iff_of_forall_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á¶œÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Basic.lean:632:2: warning: expanding binder collection (x Â«expr âˆ‰ Â» s) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŠ“ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- Suppose that `f` sends the complement to `s` to a single point `a`, and `l` is some filter.\nThen `f` tends to `a` along `l` restricted to `s` if and only if it tends to `a` along `l`. -/\ntheorem tendsto_inf_principal_nhds_iff_of_forall_eq {f : Î² â†’ Î±} {l : filter Î²} {s : set Î²} {a : Î±}\n    (h : âˆ€ (x) (_ : x âˆ‰ s), f x = a) :\n    tendsto f (Â«expr âŠ“ Â» l ((filter.principal) s)) ((nhds) a) â†” tendsto f l ((nhds) a) :=\n  by\n  rw [tendsto_iff_comap, tendsto_iff_comap]\n  replace h : (filter.principal) (Â«expr á¶œÂ» s) â‰¤ comap f ((nhds) a)\n  Â· rintro U âŸ¨t, ht, htUâŸ© x hx\n    have : f x âˆˆ t := (h x hx).symm â–¸ mem_of_mem_nhds ht\n    exact htU this\n  refine' âŸ¨fun h' => _, le_trans inf_le_leftâŸ©\n  have := sup_le h' h\n  rw [sup_inf_right, sup_principal, union_compl_self, principal_univ, inf_top_eq, sup_le_iff] at this\n  exact this.1\n#align tendsto_inf_principal_nhds_iff_of_forall_eq tendsto_inf_principal_nhds_iff_of_forall_eq\n\n",
 "tendsto_const_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem tendsto_const_nhds {a : Î±} {f : filter Î²} : tendsto (fun b : Î² => a) f ((nhds) a) :=\n  tendsto_nhds.mpr fun s hs ha => univ_mem' fun _ => ha\n#align tendsto_const_nhds tendsto_const_nhds\n\n",
 "tendsto_at_top_of_eventually_const":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem tendsto_at_top_of_eventually_const {Î¹ : Type _} [SemilatticeSup Î¹] [nonempty Î¹] {x : Î±} {u : Î¹ â†’ Î±} {iâ‚€ : Î¹}\n    (h : âˆ€ i â‰¥ iâ‚€, u i = x) : tendsto u at_top ((nhds) x) :=\n  tendsto.congr' (eventually_eq.symm (eventually_at_top.mpr âŸ¨iâ‚€, hâŸ©)) tendsto_const_nhds\n#align tendsto_at_top_of_eventually_const tendsto_at_top_of_eventually_const\n\n",
 "tendsto_at_top_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\ntheorem order_top.tendsto_at_top_nhds {Î± : Type _} [partial_order Î±] [OrderTop Î±] [topological_space Î²] (f : Î± â†’ Î²) :\n    tendsto f at_top (nhds <| f (Â«exprâŠ¤Â»)) :=\n  (tendsto_at_top_pure f).mono_right (pure_le_nhds _)\n#align order_top.tendsto_at_top_nhds order_top.tendsto_at_top_nhds\n\n",
 "tendsto_at_bot_of_eventually_const":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem tendsto_at_bot_of_eventually_const {Î¹ : Type _} [SemilatticeInf Î¹] [nonempty Î¹] {x : Î±} {u : Î¹ â†’ Î±} {iâ‚€ : Î¹}\n    (h : âˆ€ i â‰¤ iâ‚€, u i = x) : tendsto u at_bot ((nhds) x) :=\n  tendsto.congr' (eventually_eq.symm (eventually_at_bot.mpr âŸ¨iâ‚€, hâŸ©)) tendsto_const_nhds\n#align tendsto_at_bot_of_eventually_const tendsto_at_bot_of_eventually_const\n\n",
 "tendsto'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- A version of `continuous.tendsto` that allows one to specify a simpler form of the limit.\nE.g., one can write `continuous_exp.tendsto' 0 1 exp_zero`. -/\ntheorem continuous.tendsto' {f : Î± â†’ Î²} (hf : continuous f) (x : Î±) (y : Î²) (h : f x = y) :\n    tendsto f ((nhds) x) ((nhds) y) :=\n  h â–¸ hf.tendsto x\n#align continuous.tendsto' continuous.tendsto'\n\n",
 "tendsto":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem continuous.tendsto {f : Î± â†’ Î²} (hf : continuous f) (x) : tendsto f ((nhds) x) ((nhds) (f x)) :=\n  ((nhds_basis_opens x).tendsto_iff <| nhds_basis_opens <| f x).2 fun t âŸ¨hxt, htâŸ© =>\n    âŸ¨Â«expr â»Â¹' Â» f t, âŸ¨hxt, ht.preimage hfâŸ©, Subset.refl _âŸ©\n#align continuous.tendsto continuous.tendsto\n\n",
 "subset_interior_iff_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem subset_interior_iff_nhds {s V : set Î±} : s âŠ† interior V â†” âˆ€ x âˆˆ s, V âˆˆ (nhds) x :=\n  show (âˆ€ x, x âˆˆ s â†’ x âˆˆ _) â†” _ by simp_rw [mem_interior_iff_mem_nhds]\n#align subset_interior_iff_nhds subset_interior_iff_nhds\n\n",
 "subset_interior_iff_is_open":
 "theorem subset_interior_iff_is_open {s : set Î±} : s âŠ† interior s â†” is_open s := by\n  simp only [interior_eq_iff_is_open.symm, subset.antisymm_iff, interior_subset, true_and_iff]\n#align subset_interior_iff_is_open subset_interior_iff_is_open\n\n",
 "subset_interior_iff":
 "theorem subset_interior_iff {s t : set Î±} : t âŠ† interior s â†” âˆƒ U, is_open U âˆ§ t âŠ† U âˆ§ U âŠ† s :=\n  âŸ¨fun h => âŸ¨interior s, is_open_interior, h, interior_subsetâŸ©, fun âŸ¨U, hU, htU, hUsâŸ© =>\n    htU.trans (interior_maximal hUs hU)âŸ©\n#align subset_interior_iff subset_interior_iff\n\n",
 "subset_closure_image_preimage_of_is_open":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/-- If `f` has dense range and `s` is an open set in the codomain of `f`, then the image of the\npreimage of `s` under `f` is dense in `s`. -/\ntheorem dense_range.subset_closure_image_preimage_of_is_open (hf : dense_range f) {s : set Î²} (hs : is_open s) :\n    s âŠ† closure (Â«expr '' Â» f (Â«expr â»Â¹' Â» f s)) :=\n  by\n  rw [image_preimage_eq_inter_range]\n  exact hf.open_subset_closure_inter hs\n#align dense_range.subset_closure_image_preimage_of_is_open dense_range.subset_closure_image_preimage_of_is_open\n\n",
 "subset_closure":
 "theorem subset_closure {s : set Î±} : s âŠ† closure s :=\n  subset_sInter fun t âŸ¨hâ‚, hâ‚‚âŸ© => hâ‚‚\n#align subset_closure subset_closure\n\n",
 "self_of_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- If a predicate is true in a neighborhood of `a`, then it is true for `a`. -/\ntheorem filter.eventually.self_of_nhds {p : Î± â†’ Prop} {a : Î±}\n    (h :\n      Â«exprâˆ€á¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â»\" ((nhds) a)\n        (p y)) :\n    p a :=\n  mem_of_mem_nhds h\n#align filter.eventually.self_of_nhds filter.eventually.self_of_nhds\n\n",
 "self_diff_frontier":
 "@[simp]\ntheorem self_diff_frontier (s : set Î±) : s \\ frontier s = interior s := by\n  rw [frontier, diff_diff_right, diff_eq_empty.2 subset_closure, inter_eq_self_of_subset_right interior_subset,\n    empty_union]\n#align self_diff_frontier self_diff_frontier\n\n",
 "sdiff":
 "theorem is_closed.sdiff {s t : set Î±} (hâ‚ : is_closed s) (hâ‚‚ : is_open t) : is_closed (s \\ t) :=\n  is_closed.inter hâ‚ (is_closed_compl_iff.mpr hâ‚‚)\n#align is_closed.sdiff is_closed.sdiff\n\n",
 "rtendsto_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem rtendsto_nhds {r : Rel Î² Î±} {l : filter Î²} {a : Î±} :\n    rtendsto r l ((nhds) a) â†” âˆ€ s, is_open s â†’ a âˆˆ s â†’ r.core s âˆˆ l :=\n  all_mem_nhds_filter _ _ (fun s t => id) _\n#align rtendsto_nhds rtendsto_nhds\n\n",
 "rtendsto'_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem rtendsto'_nhds {r : Rel Î² Î±} {l : filter Î²} {a : Î±} :\n    rtendsto' r l ((nhds) a) â†” âˆ€ s, is_open s â†’ a âˆˆ s â†’ r.preimage s âˆˆ l :=\n  by\n  rw [rtendsto'_def]\n  apply all_mem_nhds_filter\n  apply Rel.preimage_mono\n#align rtendsto'_nhds rtendsto'_nhds\n\n",
 "range_subset_closure_image_dense":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\ntheorem continuous.range_subset_closure_image_dense {f : Î± â†’ Î²} (hf : continuous f) {s : set Î±} (hs : dense s) :\n    range f âŠ† closure (Â«expr '' Â» f s) := by\n  rw [â† image_univ, â† hs.closure_eq]\n  exact image_closure_subset_closure_image hf\n#align continuous.range_subset_closure_image_dense continuous.range_subset_closure_image_dense\n\n",
 "pure_le_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem pure_le_nhds : pure â‰¤ (nhds : Î± â†’ filter Î±) := fun a s hs => mem_pure.2 <| mem_of_mem_nhds hs\n#align pure_le_nhds pure_le_nhds\n\n",
 "ptendsto_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’. Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem ptendsto_nhds {f : Â«expr â†’. Â» Î² Î±} {l : filter Î²} {a : Î±} :\n    ptendsto f l ((nhds) a) â†” âˆ€ s, is_open s â†’ a âˆˆ s â†’ f.core s âˆˆ l :=\n  rtendsto_nhds\n#align ptendsto_nhds ptendsto_nhds\n\n",
 "ptendsto'_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’. Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem ptendsto'_nhds {f : Â«expr â†’. Â» Î² Î±} {l : filter Î²} {a : Î±} :\n    ptendsto' f l ((nhds) a) â†” âˆ€ s, is_open s â†’ a âˆˆ s â†’ f.preimage s âˆˆ l :=\n  rtendsto'_nhds\n#align ptendsto'_nhds ptendsto'_nhds\n\n",
 "preimage_mem_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem continuous_at.preimage_mem_nhds {f : Î± â†’ Î²} {x : Î±} {t : set Î²} (h : continuous_at f x)\n    (ht : t âˆˆ (nhds) (f x)) : Â«expr â»Â¹' Â» f t âˆˆ (nhds) x :=\n  h ht\n#align continuous_at.preimage_mem_nhds continuous_at.preimage_mem_nhds\n\n",
 "preimage_interior_subset_interior_preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/-- See also `interior_preimage_subset_preimage_interior`. -/\ntheorem preimage_interior_subset_interior_preimage {f : Î± â†’ Î²} {s : set Î²} (hf : continuous f) :\n    Â«expr â»Â¹' Â» f (interior s) âŠ† interior (Â«expr â»Â¹' Â» f s) :=\n  interior_maximal (preimage_mono interior_subset) (is_open_interior.preimage hf)\n#align preimage_interior_subset_interior_preimage preimage_interior_subset_interior_preimage\n\n",
 "preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\ntheorem is_closed.preimage {f : Î± â†’ Î²} (hf : continuous f) {s : set Î²} (h : is_closed s) :\n    is_closed (Â«expr â»Â¹' Â» f s) :=\n  continuous_iff_is_closed.mp hf s h\n#align is_closed.preimage is_closed.preimage\n\n",
 "pcontinuous_iff'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’. Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem pcontinuous_iff' {f : Â«expr â†’. Â» Î± Î²} :\n    pcontinuous f â†” âˆ€ {x y} (h : y âˆˆ f x), ptendsto' f ((nhds) x) ((nhds) y) :=\n  by\n  constructor\n  Â· intro h x y h'\n    simp only [ptendsto'_def, mem_nhds_iff]\n    rintro s âŸ¨t, tsubs, opent, ytâŸ©\n    exact âŸ¨f.preimage t, pfun.preimage_mono _ tsubs, h _ opent, âŸ¨y, yt, h'âŸ©âŸ©\n  intro hf s os\n  rw [is_open_iff_nhds]\n  rintro x âŸ¨y, ys, fxyâŸ© t\n  rw [mem_principal]\n  intro (h : f.preimage s âŠ† t)\n  change t âˆˆ (nhds) x\n  apply mem_of_superset _ h\n  have h' : âˆ€ s âˆˆ (nhds) y, f.preimage s âˆˆ (nhds) x := by\n    intro s hs\n    have : ptendsto' f ((nhds) x) ((nhds) y) := hf fxy\n    rw [ptendsto'_def] at this\n    exact this s hs\n  show f.preimage s âˆˆ (nhds) x\n  apply h'\n  rw [mem_nhds_iff]\n  exact âŸ¨s, Set.Subset.refl _, os, ysâŸ©\n#align pcontinuous_iff' pcontinuous_iff'\n\n",
 "open_subset_closure_inter":
 "theorem dense.open_subset_closure_inter {s t : set Î±} (hs : dense s) (ht : is_open t) : t âŠ† closure (t âˆ© s) :=\n  calc\n    t = t âˆ© closure s := by rw [hs.closure_eq, inter_univ]\n    _ âŠ† closure (t âˆ© s) := ht.inter_closure\n    \n#align dense.open_subset_closure_inter dense.open_subset_closure_inter\n\n",
 "open_dom_of_pcontinuous":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’. Â» -/\ntheorem open_dom_of_pcontinuous {f : Â«expr â†’. Â» Î± Î²} (h : pcontinuous f) : is_open f.dom := by\n  rw [â† pfun.preimage_univ] <;> exact h _ is_open_univ\n#align open_dom_of_pcontinuous open_dom_of_pcontinuous\n\n",
 "of_nhds_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem cluster_pt.of_nhds_le {x : Î±} {f : filter Î±} (H : (nhds) x â‰¤ f) : cluster_pt x f := by\n  simp only [cluster_pt, inf_eq_left.mpr H, nhds_ne_bot]\n#align cluster_pt.of_nhds_le cluster_pt.of_nhds_le\n\n",
 "of_le_nhds'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem cluster_pt.of_le_nhds' {x : Î±} {f : filter Î±} (H : f â‰¤ (nhds) x) (hf : ne_bot f) : cluster_pt x f :=\n  cluster_pt.of_le_nhds H\n#align cluster_pt.of_le_nhds' cluster_pt.of_le_nhds'\n\n",
 "of_le_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem cluster_pt.of_le_nhds {x : Î±} {f : filter Î±} (H : f â‰¤ (nhds) x) [ne_bot f] : cluster_pt x f := by\n  rwa [cluster_pt, inf_eq_right.mpr H]\n#align cluster_pt.of_le_nhds cluster_pt.of_le_nhds\n\n",
 "of_inf_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŠ“ Â» -/\ntheorem cluster_pt.of_inf_right {x : Î±} {f g : filter Î±} (H : cluster_pt x <| Â«expr âŠ“ Â» f g) : cluster_pt x g :=\n  H.mono inf_le_right\n#align cluster_pt.of_inf_right cluster_pt.of_inf_right\n\n",
 "of_inf_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŠ“ Â» -/\ntheorem cluster_pt.of_inf_left {x : Î±} {f g : filter Î±} (H : cluster_pt x <| Â«expr âŠ“ Â» f g) : cluster_pt x f :=\n  H.mono inf_le_left\n#align cluster_pt.of_inf_left cluster_pt.of_inf_left\n\n",
 "not_mem_of_not_mem_closure":
 "theorem not_mem_of_not_mem_closure {s : set Î±} {P : Î±} (hP : P âˆ‰ closure s) : P âˆ‰ s := fun h => hP (subset_closure h)\n#align not_mem_of_not_mem_closure not_mem_of_not_mem_closure\n\n",
 "not_is_open_singleton":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.ne -/\ntheorem not_is_open_singleton (x : Î±) [ne_bot (nhds_within.ne x)] : Â¬is_open ({x} : set Î±) :=\n  dense_compl_singleton_iff_not_open.1 (dense_compl_singleton x)\n#align not_is_open_singleton not_is_open_singleton\n\n",
 "not":
 "theorem is_closed.not : is_closed { a | p a } â†’ is_open { a | Â¬p a } :=\n  is_open_compl_iff.mpr\n#align is_closed.not is_closed.not\n\n",
 "nonempty_iff":
 "theorem dense_range.nonempty_iff (hf : dense_range f) : nonempty Îº â†” nonempty Î² :=\n  range_nonempty_iff_nonempty.symm.trans hf.nonempty_iff\n#align dense_range.nonempty_iff dense_range.nonempty_iff\n\n",
 "nonempty":
 "theorem dense_range.nonempty [h : nonempty Î²] (hf : dense_range f) : nonempty Îº :=\n  hf.nonempty_iff.mpr h\n#align dense_range.nonempty dense_range.nonempty\n\n",
 "nhds_le_of_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- To show a filter is above the neighborhood filter at `a`, it suffices to show that it is above\nthe principal filter of some open set `s` containing `a`. -/\ntheorem nhds_le_of_le {f a} {s : set Î±} (h : a âˆˆ s) (o : is_open s) (sf : (filter.principal) s â‰¤ f) : (nhds) a â‰¤ f := by\n  rw [nhds_def] <;> exact infáµ¢_le_of_le s (infáµ¢_le_of_le âŸ¨h, oâŸ© sf)\n#align nhds_le_of_le nhds_le_of_le\n\n",
 "nhds_def'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ¨… , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨… , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\ntheorem nhds_def' (a : Î±) :\n    (nhds) a =\n      Â«exprâ¨… , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨… , Â»\"\n        ((filter.principal) s) :=\n  by simp only [nhds_def, mem_set_of_eq, and_comm' (a âˆˆ _), infáµ¢_and]\n#align nhds_def' nhds_def'\n\n",
 "nhds_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ¨… , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨… , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\ntheorem nhds_def (a : Î±) :\n    (nhds) a =\n      Â«exprâ¨… , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨… , Â»\"\n        ((filter.principal) s) :=\n  by rw [nhds]\n#align nhds_def nhds_def\n\n",
 "nhds_bind_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n@[simp]\ntheorem nhds_bind_nhds : ((nhds) a).bind (nhds) = (nhds) a :=\n  filter.ext fun s => eventually_eventually_nhds\n#align nhds_bind_nhds nhds_bind_nhds\n\n",
 "nhds_basis_opens'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- The open neighborhoods of `a` are a basis for the neighborhood filter. See `nhds_basis_opens`\nfor a variant using open sets around `a` instead. -/\ntheorem nhds_basis_opens' (a : Î±) : ((nhds) a).has_basis (fun s : set Î± => s âˆˆ (nhds) a âˆ§ is_open s) fun x => x :=\n  by\n  convert nhds_basis_opens a\n  ext s\n  exact and_congr_left_iff.2 is_open.mem_nhds_iff\n#align nhds_basis_opens' nhds_basis_opens'\n\n",
 "nhds_basis_opens":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- The open sets containing `a` are a basis for the neighborhood filter. See `nhds_basis_opens'`\nfor a variant using open neighborhoods instead. -/\ntheorem nhds_basis_opens (a : Î±) : ((nhds) a).has_basis (fun s : set Î± => a âˆˆ s âˆ§ is_open s) fun s => s :=\n  by\n  rw [nhds_def]\n  exact\n    has_basis_binfi_principal\n      (fun s âŸ¨has, hsâŸ© t âŸ¨hat, htâŸ© =>\n        âŸ¨s âˆ© t, âŸ¨âŸ¨has, hatâŸ©, is_open.inter hs htâŸ©, âŸ¨inter_subset_left _ _, inter_subset_right _ _âŸ©âŸ©)\n      âŸ¨univ, âŸ¨mem_univ a, is_open_univâŸ©âŸ©\n#align nhds_basis_opens nhds_basis_opens\n\n",
 "nhds_basis_closeds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem nhds_basis_closeds (a : Î±) : ((nhds) a).has_basis (fun s : set Î± => a âˆ‰ s âˆ§ is_closed s) compl :=\n  âŸ¨fun t =>\n    (nhds_basis_opens a).mem_iff.trans <|\n      compl_surjective.exists.trans <| by simp only [is_open_compl_iff, mem_compl_iff]âŸ©\n#align nhds_basis_closeds nhds_basis_closeds\n\n",
 "ne_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŠ“ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem cluster_pt.ne_bot {x : Î±} {F : filter Î±} (h : cluster_pt x F) : ne_bot (Â«expr âŠ“ Â» ((nhds) x) F) :=\n  h\n#align cluster_pt.ne_bot cluster_pt.ne_bot\n\n",
 "monotone_closure":
 "theorem monotone_closure (Î± : Type _) [topological_space Î±] : monotone (@closure Î± _) := fun _ _ => closure_mono\n#align monotone_closure monotone_closure\n\n",
 "mono":
 "/-- If `x` is an accumulation point of `F` and `F â‰¤ G`, then\n`x` is an accumulation point of `D. -/\ntheorem acc_pt.mono {x : Î±} {F G : filter Î±} (h : acc_pt x F) (hFG : F â‰¤ G) : acc_pt x G :=\n  âŸ¨ne_bot_of_le_ne_bot h.ne (inf_le_inf_left _ hFG)âŸ©\n#align acc_pt.mono acc_pt.mono\n\n",
 "mem_of_tendsto":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\ntheorem is_closed.mem_of_tendsto {f : Î² â†’ Î±} {b : filter Î²} {a : Î±} {s : set Î±} [ne_bot b] (hs : is_closed s)\n    (hf : tendsto f b ((nhds) a))\n    (h :\n      Â«exprâˆ€á¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â»\" b\n        (f x âˆˆ s)) :\n    a âˆˆ s :=\n  hs.mem_of_frequently_of_tendsto h.frequently hf\n#align is_closed.mem_of_tendsto is_closed.mem_of_tendsto\n\n",
 "mem_of_mem_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem mem_of_mem_nhds {a : Î±} {s : set Î±} : s âˆˆ (nhds) a â†’ a âˆˆ s := fun H =>\n  let âŸ¨t, ht, _, hsâŸ© := mem_nhds_iff.1 H\n  ht hs\n#align mem_of_mem_nhds mem_of_mem_nhds\n\n",
 "mem_of_frequently_of_tendsto":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆƒá¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆƒá¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆƒá¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆƒá¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem is_closed.mem_of_frequently_of_tendsto {f : Î² â†’ Î±} {b : filter Î²} {a : Î±} {s : set Î±} (hs : is_closed s)\n    (h :\n      Â«exprâˆƒá¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆƒá¶  in , Â»\" b\n        (f x âˆˆ s))\n    (hf : tendsto f b ((nhds) a)) : a âˆˆ s :=\n  (hf.frequently <|\n        show\n          Â«exprâˆƒá¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆƒá¶  in , Â»\" b\n            ((fun y => y âˆˆ s) (f x))\n          from h).mem_of_closed\n    hs\n#align is_closed.mem_of_frequently_of_tendsto is_closed.mem_of_frequently_of_tendsto\n\n",
 "mem_of_closed":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆƒá¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆƒá¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem filter.frequently.mem_of_closed {a : Î±} {s : set Î±}\n    (h :\n      Â«exprâˆƒá¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆƒá¶  in , Â»\" ((nhds) a)\n        (x âˆˆ s))\n    (hs : is_closed s) : a âˆˆ s :=\n  hs.closure_subset h.mem_closure\n#align filter.frequently.mem_of_closed filter.frequently.mem_of_closed\n\n",
 "mem_nhds_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem is_open.mem_nhds_iff {a : Î±} {s : set Î±} (hs : is_open s) : s âˆˆ (nhds) a â†” a âˆˆ s :=\n  âŸ¨mem_of_mem_nhds, fun ha => mem_nhds_iff.2 âŸ¨s, Subset.refl _, hs, haâŸ©âŸ©\n#align is_open.mem_nhds_iff is_open.mem_nhds_iff\n\n",
 "mem_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem dense_range.mem_nhds {f : Îº â†’ Î²} (h : dense_range f) {b : Î²} {U : set Î²} (U_in : U âˆˆ (nhds) b) : âˆƒ a, f a âˆˆ U :=\n  let âŸ¨a, haâŸ© := h.exists_mem_open is_open_interior âŸ¨b, mem_interior_iff_mem_nhds.2 U_inâŸ©\n  âŸ¨a, interior_subset haâŸ©\n#align dense_range.mem_nhds dense_range.mem_nhds\n\n",
 "mem_interior_iff_mem_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem mem_interior_iff_mem_nhds {s : set Î±} {a : Î±} : a âˆˆ interior s â†” s âˆˆ (nhds) a := by\n  rw [interior_eq_nhds', mem_set_of_eq]\n#align mem_interior_iff_mem_nhds mem_interior_iff_mem_nhds\n\n",
 "mem_interior":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:632:2: warning: expanding binder collection (t Â«expr âŠ† Â» s) -/\ntheorem mem_interior {s : set Î±} {x : Î±} : x âˆˆ interior s â†” âˆƒ (t : _)(_ : t âŠ† s), is_open t âˆ§ x âˆˆ t := by\n  simp only [interior, mem_sUnion, mem_set_of_eq, exists_prop, and_assoc', and_left_comm]\n#align mem_interior mem_interior\n\n",
 "mem_iff_closure_subset":
 "theorem is_closed.mem_iff_closure_subset {s : set Î±} (hs : is_closed s) {x : Î±} : x âˆˆ s â†” closure ({x} : set Î±) âŠ† s :=\n  (hs.closure_subset_iff.trans Set.singleton_subset_iff).symm\n#align is_closed.mem_iff_closure_subset is_closed.mem_iff_closure_subset\n\n",
 "mem_closure_of_tendsto":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\ntheorem mem_closure_of_tendsto {f : Î² â†’ Î±} {b : filter Î²} {a : Î±} {s : set Î±} [ne_bot b] (hf : tendsto f b ((nhds) a))\n    (h :\n      Â«exprâˆ€á¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â»\" b\n        (f x âˆˆ s)) :\n    a âˆˆ closure s :=\n  mem_closure_of_frequently_of_tendsto h.frequently hf\n#align mem_closure_of_tendsto mem_closure_of_tendsto\n\n",
 "mem_closure_of_mem_closure_union":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŠ“ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŠ“ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŠ” Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŠ” Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŠ“ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŠ“ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŠ” Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¥Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŠ“ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŠ“ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á¶œÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem mem_closure_of_mem_closure_union {sâ‚ sâ‚‚ : set Î±} {x : Î±} (h : x âˆˆ closure (sâ‚ âˆª sâ‚‚))\n    (hâ‚ : Â«expr á¶œÂ» sâ‚ âˆˆ (nhds) x) : x âˆˆ closure sâ‚‚ :=\n  by\n  rw [mem_closure_iff_nhds_ne_bot] at *\n  rwa [â†\n    calc\n      Â«expr âŠ“ Â» ((nhds) x) (principal (sâ‚ âˆª sâ‚‚)) = Â«expr âŠ“ Â» ((nhds) x) (Â«expr âŠ” Â» (principal sâ‚) (principal sâ‚‚)) := by\n        rw [sup_principal]\n      _ = Â«expr âŠ” Â» (Â«expr âŠ“ Â» ((nhds) x) (principal sâ‚)) (Â«expr âŠ“ Â» ((nhds) x) (principal sâ‚‚)) := inf_sup_left\n      _ = Â«expr âŠ” Â» (Â«exprâŠ¥Â») (Â«expr âŠ“ Â» ((nhds) x) (principal sâ‚‚)) := by rw [inf_principal_eq_bot.mpr hâ‚]\n      _ = Â«expr âŠ“ Â» ((nhds) x) (principal sâ‚‚) := bot_sup_eq\n      ]\n#align mem_closure_of_mem_closure_union mem_closure_of_mem_closure_union\n\n",
 "mem_closure_of_frequently_of_tendsto":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆƒá¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆƒá¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem mem_closure_of_frequently_of_tendsto {f : Î² â†’ Î±} {b : filter Î²} {a : Î±} {s : set Î±}\n    (h :\n      Â«exprâˆƒá¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆƒá¶  in , Â»\" b\n        (f x âˆˆ s))\n    (hf : tendsto f b ((nhds) a)) : a âˆˆ closure s :=\n  filter.frequently.mem_closure <| hf.frequently h\n#align mem_closure_of_frequently_of_tendsto mem_closure_of_frequently_of_tendsto\n\n",
 "mem_closure_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\ntheorem mem_closure_image {f : Î± â†’ Î²} {x : Î±} {s : set Î±} (hf : continuous_at f x) (hx : x âˆˆ closure s) :\n    f x âˆˆ closure (Â«expr '' Â» f s) :=\n  mem_closure_of_frequently_of_tendsto ((mem_closure_iff_frequently.1 hx).mono fun x => mem_image_of_mem _) hf\n#align mem_closure_image mem_closure_image\n\n",
 "mem_closure_iff_ultrafilter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- `x` belongs to the closure of `s` if and only if some ultrafilter\n  supported on `s` converges to `x`. -/\ntheorem mem_closure_iff_ultrafilter {s : set Î±} {x : Î±} : x âˆˆ closure s â†” âˆƒ u : ultrafilter Î±, s âˆˆ u âˆ§ â†‘u â‰¤ (nhds) x :=\n  by simp [closure_eq_cluster_pts, cluster_pt, â† exists_ultrafilter_iff, and_comm]\n#align mem_closure_iff_ultrafilter mem_closure_iff_ultrafilter\n\n",
 "mem_closure_iff_nhds_within_ne_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\ntheorem mem_closure_iff_nhds_within_ne_bot {s : set Î±} {x : Î±} : x âˆˆ closure s â†” ne_bot (nhds_within s x) :=\n  mem_closure_iff_cluster_pt\n#align mem_closure_iff_nhds_within_ne_bot mem_closure_iff_nhds_within_ne_bot\n\n",
 "mem_closure_iff_nhds_ne_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŠ“ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¥Â» -/\ntheorem mem_closure_iff_nhds_ne_bot {s : set Î±} :\n    a âˆˆ closure s â†” Â«expr âŠ“ Â» ((nhds) a) ((filter.principal) s) â‰  Â«exprâŠ¥Â» :=\n  mem_closure_iff_cluster_pt.trans ne_bot_iff\n#align mem_closure_iff_nhds_ne_bot mem_closure_iff_nhds_ne_bot\n\n",
 "mem_closure_iff_nhds_basis'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem mem_closure_iff_nhds_basis' {a : Î±} {p : Î¹ â†’ Prop} {s : Î¹ â†’ set Î±} (h : ((nhds) a).has_basis p s) {t : set Î±} :\n    a âˆˆ closure t â†” âˆ€ i, p i â†’ (s i âˆ© t).nonempty :=\n  mem_closure_iff_cluster_pt.trans <|\n    (h.cluster_pt_iff (has_basis_principal _)).trans <| by simp only [exists_prop, forall_const]\n#align mem_closure_iff_nhds_basis' mem_closure_iff_nhds_basis'\n\n",
 "mem_closure_iff_nhds_basis":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem mem_closure_iff_nhds_basis {a : Î±} {p : Î¹ â†’ Prop} {s : Î¹ â†’ set Î±} (h : ((nhds) a).has_basis p s) {t : set Î±} :\n    a âˆˆ closure t â†” âˆ€ i, p i â†’ âˆƒ y âˆˆ t, y âˆˆ s i :=\n  (mem_closure_iff_nhds_basis' h).trans <| by simp only [Set.Nonempty, mem_inter_iff, exists_prop, and_comm']\n#align mem_closure_iff_nhds_basis mem_closure_iff_nhds_basis\n\n",
 "mem_closure_iff_nhds'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem mem_closure_iff_nhds' {s : set Î±} {a : Î±} : a âˆˆ closure s â†” âˆ€ t âˆˆ (nhds) a, âˆƒ y : s, â†‘y âˆˆ t := by\n  simp only [mem_closure_iff_nhds, Set.inter_nonempty_iff_exists_right, SetCoe.exists, subtype.coe_mk]\n#align mem_closure_iff_nhds' mem_closure_iff_nhds'\n\n",
 "mem_closure_iff_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem mem_closure_iff_nhds {s : set Î±} {a : Î±} : a âˆˆ closure s â†” âˆ€ t âˆˆ (nhds) a, (t âˆ© s).nonempty :=\n  mem_closure_iff_cluster_pt.trans cluster_pt_principal_iff\n#align mem_closure_iff_nhds mem_closure_iff_nhds\n\n",
 "mem_closure_iff_frequently":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆƒá¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆƒá¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem mem_closure_iff_frequently {s : set Î±} {a : Î±} :\n    a âˆˆ closure s â†”\n      Â«exprâˆƒá¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆƒá¶  in , Â»\" ((nhds) a)\n        (x âˆˆ s) :=\n  by rw [filter.frequently, filter.eventually, â† mem_interior_iff_mem_nhds, closure_eq_compl_interior_compl] <;> rfl\n#align mem_closure_iff_frequently mem_closure_iff_frequently\n\n",
 "mem_closure_iff_comap_ne_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem mem_closure_iff_comap_ne_bot {A : set Î±} {x : Î±} : x âˆˆ closure A â†” ne_bot (comap (coe : A â†’ Î±) ((nhds) x)) := by\n  simp_rw [mem_closure_iff_nhds, comap_ne_bot_iff, Set.inter_nonempty_iff_exists_right, SetCoe.exists, subtype.coe_mk]\n#align mem_closure_iff_comap_ne_bot mem_closure_iff_comap_ne_bot\n\n",
 "mem_closure_iff_cluster_pt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\ntheorem mem_closure_iff_cluster_pt {s : set Î±} {a : Î±} : a âˆˆ closure s â†” cluster_pt a ((filter.principal) s) :=\n  mem_closure_iff_frequently.trans cluster_pt_principal_iff_frequently.symm\n#align mem_closure_iff_cluster_pt mem_closure_iff_cluster_pt\n\n",
 "mem_closure_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á¶œÂ» -/\ntheorem mem_closure_iff {s : set Î±} {a : Î±} : a âˆˆ closure s â†” âˆ€ o, is_open o â†’ a âˆˆ o â†’ (o âˆ© s).nonempty :=\n  âŸ¨fun h o oo ao =>\n    by_contradiction fun os =>\n      have : s âŠ† Â«expr á¶œÂ» o := fun x xs xo => os âŸ¨x, xo, xsâŸ©\n      closure_minimal this (is_closed_compl_iff.2 oo) h ao,\n    fun H c âŸ¨hâ‚, hâ‚‚âŸ© =>\n    by_contradiction fun nc =>\n      let âŸ¨x, hc, hsâŸ© := H _ hâ‚.is_open_compl nc\n      hc (hâ‚‚ hs)âŸ©\n#align mem_closure_iff mem_closure_iff\n\n",
 "map_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ¨… , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨… , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\ntheorem map_nhds {a : Î±} {f : Î± â†’ Î²} :\n    map f ((nhds) a) =\n      Â«exprâ¨… , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨… , Â»\"\n        ((filter.principal) (image f s)) :=\n  ((nhds_basis_opens a).map f).eq_binfi\n#align map_nhds map_nhds\n\n",
 "map_mem_closure":
 "theorem map_mem_closure {s : set Î±} {t : set Î²} {f : Î± â†’ Î²} {a : Î±} (hf : continuous f) (ha : a âˆˆ closure s)\n    (ht : MapsTo f s t) : f a âˆˆ closure t :=\n  ht.closure hf ha\n#align map_mem_closure map_mem_closure\n\n",
 "map_cluster_pt_of_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŠ“ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem map_cluster_pt_of_comp {Î¹ Î´ : Type _} {F : filter Î¹} {Ï† : Î´ â†’ Î¹} {p : filter Î´} {x : Î±} {u : Î¹ â†’ Î±} [ne_bot p]\n    (h : tendsto Ï† p F) (H : tendsto (u âˆ˜ Ï†) p ((nhds) x)) : map_cluster_pt x F u :=\n  by\n  have :=\n    calc\n      map (u âˆ˜ Ï†) p = map u (map Ï† p) := map_map\n      _ â‰¤ map u F := map_mono h\n      \n  have : map (u âˆ˜ Ï†) p â‰¤ Â«expr âŠ“ Â» ((nhds) x) (map u F) := le_inf H this\n  exact ne_bot_of_le this\n#align map_cluster_pt_of_comp map_cluster_pt_of_comp\n\n",
 "map_cluster_pt_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆƒá¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆƒá¶  in , Â» -/\ntheorem map_cluster_pt_iff {Î¹ : Type _} (x : Î±) (F : filter Î¹) (u : Î¹ â†’ Î±) :\n    map_cluster_pt x F u â†”\n      âˆ€ s âˆˆ (nhds) x,\n        Â«exprâˆƒá¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆƒá¶  in , Â»\" F\n          (u a âˆˆ s) :=\n  by\n  simp_rw [map_cluster_pt, cluster_pt, inf_ne_bot_iff_frequently_left, frequently_map]\n  rfl\n#align map_cluster_pt_iff map_cluster_pt_iff\n\n",
 "map":
 "theorem cluster_pt.map {x : Î±} {la : filter Î±} {lb : filter Î²} (H : cluster_pt x la) {f : Î± â†’ Î²}\n    (hfc : continuous_at f x) (hf : tendsto f la lb) : cluster_pt (f x) lb :=\n  âŸ¨ne_bot_of_le_ne_bot ((map_ne_bot_iff f).2 H).ne <| hfc.tendsto.inf hfâŸ©\n#align cluster_pt.map cluster_pt.map\n\n",
 "lift'_closure_eq_self":
 "theorem filter.has_basis.lift'_closure_eq_self {l : filter Î±} {p : Î¹ â†’ Prop} {s : Î¹ â†’ set Î±} (h : l.has_basis p s)\n    (hc : âˆ€ i, p i â†’ is_closed (s i)) : l.lift' closure = l :=\n  le_antisymm (h.ge_iff.2 fun i hi => (hc i hi).closure_eq â–¸ mem_lift' (h.mem_of_mem hi)) l.le_lift'_closure\n#align filter.has_basis.lift'_closure_eq_self filter.has_basis.lift'_closure_eq_self\n\n",
 "lift'_closure_eq_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¥Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¥Â» -/\n@[simp]\ntheorem filter.lift'_closure_eq_bot {l : filter Î±} : l.lift' closure = Â«exprâŠ¥Â» â†” l = Â«exprâŠ¥Â» :=\n  âŸ¨fun h => bot_unique <| h â–¸ l.le_lift'_closure, fun h =>\n    h.symm â–¸ by rw [lift'_bot (monotone_closure _), closure_empty, principal_empty]âŸ©\n#align filter.lift'_closure_eq_bot filter.lift'_closure_eq_bot\n\n",
 "lift'_closure":
 "theorem filter.has_basis.lift'_closure {l : filter Î±} {p : Î¹ â†’ Prop} {s : Î¹ â†’ set Î±} (h : l.has_basis p s) :\n    (l.lift' closure).has_basis p fun i => closure (s i) :=\n  h.lift' (monotone_closure Î±)\n#align filter.has_basis.lift'_closure filter.has_basis.lift'_closure\n\n",
 "le_nhds_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- A filter lies below the neighborhood filter at `a` iff it contains every open set around `a`. -/\ntheorem le_nhds_iff {f a} : f â‰¤ (nhds) a â†” âˆ€ s : set Î±, a âˆˆ s â†’ is_open s â†’ s âˆˆ f := by simp [nhds_def]\n#align le_nhds_iff le_nhds_iff\n\n",
 "le_nhds_Lim":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- If a filter `f` is majorated by some `ğ“ a`, then it is majorated by `ğ“ (Lim f)`. We formulate\nthis lemma with a `[nonempty Î±]` argument of `Lim` derived from `h` to make it useful for types\nwithout a `[nonempty Î±]` instance. Because of the built-in proof irrelevance, Lean will unify\nthis instance with any other instance. -/\ntheorem le_nhds_Lim {f : filter Î±} (h : âˆƒ a, f â‰¤ (nhds) a) : f â‰¤ (nhds) (@Lim _ _ (nonempty_of_exists h) f) :=\n  epsilon_spec h\n#align le_nhds_Lim le_nhds_Lim\n\n",
 "le_lift'_closure":
 "theorem filter.le_lift'_closure (l : filter Î±) : l â‰¤ l.lift' closure :=\n  le_lift'.2 fun s hs => mem_of_superset hs subset_closure\n#align filter.le_lift'_closure filter.le_lift'_closure\n\n",
 "iterate":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr ^[ ]Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr ^[ ]Â» -/\ntheorem continuous_at.iterate {f : Î± â†’ Î±} {x : Î±} (hf : continuous_at f x) (hx : f x = x) (n : â„•) :\n    continuous_at (Â«expr ^[ ]Â» f n) x :=\n  nat.rec_on n continuous_at_id fun n ihn =>\n    show continuous_at (Â«expr ^[ ]Â» f n âˆ˜ f) x from continuous_at.comp (hx.symm â–¸ ihn) hf\n#align continuous_at.iterate continuous_at.iterate\n\n",
 "is_open_univ":
 "@[simp]\ntheorem is_open_univ : is_open (univ : set Î±) :=\n  topological_space.is_open_univ _\n#align is_open_univ is_open_univ\n\n",
 "is_open_singleton_iff_punctured_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.ne -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¥Â» -/\ntheorem is_open_singleton_iff_punctured_nhds {Î± : Type _} [topological_space Î±] (a : Î±) :\n    is_open ({a} : set Î±) â†” nhds_within.ne a = Â«exprâŠ¥Â» := by\n  rw [is_open_singleton_iff_nhds_eq_pure, nhds_within, â† mem_iff_inf_principal_compl, â† le_pure_iff,\n    nhds_ne_bot.le_pure_iff]\n#align is_open_singleton_iff_punctured_nhds is_open_singleton_iff_punctured_nhds\n\n",
 "is_open_singleton_iff_nhds_eq_pure":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem is_open_singleton_iff_nhds_eq_pure (a : Î±) : is_open ({a} : set Î±) â†” (nhds) a = pure a :=\n  by\n  constructor\n  Â· intro h\n    apply le_antisymm _ (pure_le_nhds a)\n    rw [le_pure_iff]\n    exact h.mem_nhds (mem_singleton a)\n  Â· intro h\n    simp [is_open_iff_nhds, h]\n#align is_open_singleton_iff_nhds_eq_pure is_open_singleton_iff_nhds_eq_pure\n\n",
 "is_open_set_of_eventually_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem is_open_set_of_eventually_nhds {p : Î± â†’ Prop} :\n    is_open\n      { x |\n        Â«exprâˆ€á¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â»\"\n          ((nhds) x) (p y) } :=\n  by simp only [â† interior_set_of_eq, is_open_interior]\n#align is_open_set_of_eventually_nhds is_open_set_of_eventually_nhds\n\n",
 "is_open_sUnion":
 "theorem is_open_sUnion {s : set (set Î±)} (h : âˆ€ t âˆˆ s, is_open t) : is_open (â‹ƒâ‚€ s) :=\n  topological_space.is_open_sUnion _ s h\n#align is_open_sUnion is_open_sUnion\n\n",
 "is_open_sInter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹‚â‚€ Â» -/\ntheorem is_open_sInter {s : set (set Î±)} (hs : s.finite) : (âˆ€ t âˆˆ s, is_open t) â†’ is_open (Â«exprâ‹‚â‚€ Â» s) :=\n  finite.induction_on hs (fun _ => by rw [sInter_empty] <;> exact is_open_univ) fun a s has hs ih h => by\n    rw [sInter_insert] <;> exact is_open.inter (h _ <| mem_insert _ _) (ih fun t => h t âˆ˜ mem_insert_of_mem _)\n#align is_open_sInter is_open_sInter\n\n",
 "is_open_interior":
 "@[simp]\ntheorem is_open_interior {s : set Î±} : is_open (interior s) :=\n  is_open_sUnion fun t âŸ¨hâ‚, hâ‚‚âŸ© => hâ‚\n#align is_open_interior is_open_interior\n\n",
 "is_open_iff_ultrafilter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem is_open_iff_ultrafilter {s : set Î±} : is_open s â†” âˆ€ x âˆˆ s, âˆ€ (l : ultrafilter Î±), â†‘l â‰¤ (nhds) x â†’ s âˆˆ l := by\n  simp_rw [is_open_iff_mem_nhds, â† mem_iff_ultrafilter]\n#align is_open_iff_ultrafilter is_open_iff_ultrafilter\n\n",
 "is_open_iff_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\ntheorem is_open_iff_nhds {s : set Î±} : is_open s â†” âˆ€ a âˆˆ s, (nhds) a â‰¤ (filter.principal) s :=\n  calc\n    is_open s â†” s âŠ† interior s := subset_interior_iff_is_open.symm\n    _ â†” âˆ€ a âˆˆ s, (nhds) a â‰¤ (filter.principal) s := by rw [interior_eq_nhds] <;> rfl\n    \n#align is_open_iff_nhds is_open_iff_nhds\n\n",
 "is_open_iff_mem_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem is_open_iff_mem_nhds {s : set Î±} : is_open s â†” âˆ€ a âˆˆ s, s âˆˆ (nhds) a :=\n  is_open_iff_nhds.trans <| forall_congr' fun _ => imp_congr_right fun _ => le_principal_iff\n#align is_open_iff_mem_nhds is_open_iff_mem_nhds\n\n",
 "is_open_iff_forall_mem_open":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:632:2: warning: expanding binder collection (t Â«expr âŠ† Â» s) -/\ntheorem is_open_iff_forall_mem_open : is_open s â†” âˆ€ x âˆˆ s, âˆƒ (t : _)(_ : t âŠ† s), is_open t âˆ§ x âˆˆ t := by\n  rw [â† subset_interior_iff_is_open] <;> simp only [subset_def, mem_interior]\n#align is_open_iff_forall_mem_open is_open_iff_forall_mem_open\n\n",
 "is_open_iff_eventually":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- A set `s` is open iff for every point `x` in `s` and every `y` close to `x`, `y` is in `s`. -/\ntheorem is_open_iff_eventually {s : set Î±} :\n    is_open s â†”\n      âˆ€ x,\n        x âˆˆ s â†’\n          Â«exprâˆ€á¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â»\"\n            ((nhds) x) (y âˆˆ s) :=\n  is_open_iff_mem_nhds\n#align is_open_iff_eventually is_open_iff_eventually\n\n",
 "is_open_fold":
 "theorem is_open_fold {s : set Î±} {t : topological_space Î±} : t.is_open s = @is_open Î± t s :=\n  rfl\n#align is_open_fold is_open_fold\n\n",
 "is_open_empty":
 "@[simp]\ntheorem is_open_empty : is_open (âˆ… : set Î±) := by rw [â† sUnion_empty] <;> exact is_open_sUnion fun a => false.elim\n#align is_open_empty is_open_empty\n\n",
 "is_open_const":
 "theorem is_open_const {p : Prop} : is_open { a : Î± | p } :=\n  by_cases (fun this : p => by simp only [this] <;> exact is_open_univ) fun this : Â¬p => by\n    simp only [this] <;> exact is_open_empty\n#align is_open_const is_open_const\n\n",
 "is_open_compl_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á¶œÂ» -/\n@[simp]\ntheorem is_open_compl_iff {s : set Î±} : is_open (Â«expr á¶œÂ» s) â†” is_closed s :=\n  âŸ¨fun h => âŸ¨hâŸ©, fun h => h.is_open_complâŸ©\n#align is_open_compl_iff is_open_compl_iff\n\n",
 "is_open_bUnion":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â» -/\ntheorem is_open_bUnion {s : set Î²} {f : Î² â†’ set Î±} (h : âˆ€ i âˆˆ s, is_open (f i)) :\n    is_open (Â«exprâ‹ƒ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â»\" (f i)) :=\n  is_open_Union fun i => is_open_Union fun hi => h i hi\n#align is_open_bUnion is_open_bUnion\n\n",
 "is_open_bInter_finset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹‚ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹‚ , Â» -/\ntheorem is_open_bInter_finset {s : Finset Î²} {f : Î² â†’ set Î±} (h : âˆ€ i âˆˆ s, is_open (f i)) :\n    is_open (Â«exprâ‹‚ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹‚ , Â»\" (f i)) :=\n  is_open_bInter (to_finite _) h\n#align is_open_bInter_finset is_open_bInter_finset\n\n",
 "is_open_bInter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹‚ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹‚ , Â» -/\ntheorem is_open_bInter {s : set Î²} {f : Î² â†’ set Î±} (hs : s.finite) :\n    (âˆ€ i âˆˆ s, is_open (f i)) â†’\n      is_open (Â«exprâ‹‚ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹‚ , Â»\" (f i)) :=\n  finite.induction_on hs (fun _ => by rw [bInter_empty] <;> exact is_open_univ) fun a s has hs ih h => by\n    rw [bInter_insert] <;> exact is_open.inter (h a (mem_insert _ _)) (ih fun i hi => h i (mem_insert_of_mem _ hi))\n#align is_open_bInter is_open_bInter\n\n",
 "is_open_Union":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â» -/\ntheorem is_open_Union {f : Î¹ â†’ set Î±} (h : âˆ€ i, is_open (f i)) :\n    is_open (Â«exprâ‹ƒ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â»\" (f i)) :=\n  is_open_sUnion <| by rintro _ âŸ¨i, rflâŸ© <;> exact h i\n#align is_open_Union is_open_Union\n\n",
 "is_open_Inter_prop":
 "theorem is_open_Inter_prop {p : Prop} {s : p â†’ set Î±} (h : âˆ€ h : p, is_open (s h)) : is_open (interáµ¢ s) := by\n  by_cases p <;> simp [*]\n#align is_open_Inter_prop is_open_Inter_prop\n\n",
 "is_open_Inter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹‚ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹‚ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹‚ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹‚ , Â» -/\ntheorem is_open_Inter [Finite Î²] {s : Î² â†’ set Î±} (h : âˆ€ i, is_open (s i)) :\n    is_open (Â«exprâ‹‚ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹‚ , Â»\" (s i)) :=\n  suffices\n    is_open (Â«exprâ‹‚ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹‚ , Â»\" (s i)) by\n    simpa\n  is_open_bInter finite_univ fun i _ => h i\n#align is_open_Inter is_open_Inter\n\n",
 "is_closed_univ":
 "@[simp]\ntheorem is_closed_univ : is_closed (univ : set Î±) :=\n  by\n  rw [â† is_open_compl_iff, compl_univ]\n  exact is_open_empty\n#align is_closed_univ is_closed_univ\n\n",
 "is_closed_set_of_cluster_pt":
 "/-- The set of cluster points of a filter is closed. In particular, the set of limit points\nof a sequence is closed. -/\ntheorem is_closed_set_of_cluster_pt {f : filter Î±} : is_closed { x | cluster_pt x f } :=\n  by\n  simp only [cluster_pt, inf_ne_bot_iff_frequently_left, set_of_forall, imp_iff_not_or]\n  refine' is_closed_Inter fun p => is_closed.union _ _ <;> apply is_closed_compl_iff.2\n  exacts[is_open_set_of_eventually_nhds, is_open_const]\n#align is_closed_set_of_cluster_pt is_closed_set_of_cluster_pt\n\n",
 "is_closed_sInter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹‚â‚€ Â» -/\ntheorem is_closed_sInter {s : set (set Î±)} : (âˆ€ t âˆˆ s, is_closed t) â†’ is_closed (Â«exprâ‹‚â‚€ Â» s) := by\n  simpa only [â† is_open_compl_iff, compl_sInter, sUnion_image] using is_open_bUnion\n#align is_closed_sInter is_closed_sInter\n\n",
 "is_closed_of_closure_subset":
 "theorem is_closed_of_closure_subset {s : set Î±} (h : closure s âŠ† s) : is_closed s := by\n  rw [subset.antisymm subset_closure h] <;> exact is_closed_closure\n#align is_closed_of_closure_subset is_closed_of_closure_subset\n\n",
 "is_closed_imp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á¶œÂ» -/\ntheorem is_closed_imp {p q : Î± â†’ Prop} (hp : is_open { x | p x }) (hq : is_closed { x | q x }) :\n    is_closed { x | p x â†’ q x } :=\n  by\n  have : { x | p x â†’ q x } = Â«expr á¶œÂ» { x | p x } âˆª { x | q x } := Set.ext fun x => imp_iff_not_or\n  rw [this] <;> exact is_closed.union (is_closed_compl_iff.mpr hp) hq\n#align is_closed_imp is_closed_imp\n\n",
 "is_closed_iff_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem is_closed_iff_nhds {s : set Î±} : is_closed s â†” âˆ€ x, (âˆ€ U âˆˆ (nhds) x, (U âˆ© s).nonempty) â†’ x âˆˆ s := by\n  simp_rw [is_closed_iff_cluster_pt, cluster_pt, inf_principal_ne_bot_iff]\n#align is_closed_iff_nhds is_closed_iff_nhds\n\n",
 "is_closed_iff_frequently":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆƒá¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆƒá¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- A set `s` is closed iff for every point `x`, if there is a point `y` close to `x` that belongs\nto `s` then `x` is in `s`. -/\ntheorem is_closed_iff_frequently {s : set Î±} :\n    is_closed s â†”\n      âˆ€ x,\n        Â«exprâˆƒá¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆƒá¶  in , Â»\"\n            ((nhds) x) (y âˆˆ s) â†’\n          x âˆˆ s :=\n  by\n  rw [â† closure_subset_iff_is_closed]\n  apply forall_congr' fun x => _\n  rw [mem_closure_iff_frequently]\n#align is_closed_iff_frequently is_closed_iff_frequently\n\n",
 "is_closed_iff_cluster_pt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\ntheorem is_closed_iff_cluster_pt {s : set Î±} : is_closed s â†” âˆ€ a, cluster_pt a ((filter.principal) s) â†’ a âˆˆ s :=\n  calc\n    is_closed s â†” closure s âŠ† s := closure_subset_iff_is_closed.symm\n    _ â†” âˆ€ a, cluster_pt a ((filter.principal) s) â†’ a âˆˆ s := by simp only [subset_def, mem_closure_iff_cluster_pt]\n    \n#align is_closed_iff_cluster_pt is_closed_iff_cluster_pt\n\n",
 "is_closed_frontier":
 "/-- The frontier of a set is closed. -/\ntheorem is_closed_frontier {s : set Î±} : is_closed (frontier s) := by\n  rw [frontier_eq_closure_inter_closure] <;> exact is_closed.inter is_closed_closure is_closed_closure\n#align is_closed_frontier is_closed_frontier\n\n",
 "is_closed_empty":
 "@[simp]\ntheorem is_closed_empty : is_closed (âˆ… : set Î±) :=\n  by\n  rw [â† is_open_compl_iff, compl_empty]\n  exact is_open_univ\n#align is_closed_empty is_closed_empty\n\n",
 "is_closed_compl_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á¶œÂ» -/\n@[simp]\ntheorem is_closed_compl_iff {s : set Î±} : is_closed (Â«expr á¶œÂ» s) â†” is_open s := by rw [â† is_open_compl_iff, compl_compl]\n#align is_closed_compl_iff is_closed_compl_iff\n\n",
 "is_closed_compl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á¶œÂ» -/\ntheorem is_open.is_closed_compl {s : set Î±} (hs : is_open s) : is_closed (Â«expr á¶œÂ» s) :=\n  is_closed_compl_iff.2 hs\n#align is_open.is_closed_compl is_open.is_closed_compl\n\n",
 "is_closed_closure":
 "@[simp]\ntheorem is_closed_closure {s : set Î±} : is_closed (closure s) :=\n  is_closed_sInter fun t âŸ¨hâ‚, hâ‚‚âŸ© => hâ‚\n#align is_closed_closure is_closed_closure\n\n",
 "is_closed_bUnion":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â» -/\ntheorem is_closed_bUnion {s : set Î²} {f : Î² â†’ set Î±} (hs : s.finite) :\n    (âˆ€ i âˆˆ s, is_closed (f i)) â†’\n      is_closed\n        (Â«exprâ‹ƒ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â»\" (f i)) :=\n  finite.induction_on hs (fun _ => by rw [bUnion_empty] <;> exact is_closed_empty) fun a s has hs ih h => by\n    rw [bUnion_insert] <;> exact is_closed.union (h a (mem_insert _ _)) (ih fun i hi => h i (mem_insert_of_mem _ hi))\n#align is_closed_bUnion is_closed_bUnion\n\n",
 "is_closed_bInter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹‚ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹‚ , Â» -/\ntheorem is_closed_bInter {s : set Î²} {f : Î² â†’ set Î±} (h : âˆ€ i âˆˆ s, is_closed (f i)) :\n    is_closed (Â«exprâ‹‚ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹‚ , Â»\" (f i)) :=\n  is_closed_Inter fun i => is_closed_Inter <| h i\n#align is_closed_bInter is_closed_bInter\n\n",
 "is_closed_Union_prop":
 "theorem is_closed_Union_prop {p : Prop} {s : p â†’ set Î±} (h : âˆ€ h : p, is_closed (s h)) : is_closed (unionáµ¢ s) := by\n  by_cases p <;> simp [*]\n#align is_closed_Union_prop is_closed_Union_prop\n\n",
 "is_closed_Union":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â» -/\ntheorem is_closed_Union [Finite Î²] {s : Î² â†’ set Î±} (h : âˆ€ i, is_closed (s i)) :\n    is_closed (Â«exprâ‹ƒ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â»\" (s i)) :=\n  suffices\n    is_closed (Â«exprâ‹ƒ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â»\" (s i)) by\n    convert this <;> simp [Set.ext_iff]\n  is_closed_bUnion finite_univ fun i _ => h i\n#align is_closed_Union is_closed_Union\n\n",
 "is_closed_Inter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹‚ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹‚ , Â» -/\ntheorem is_closed_Inter {f : Î¹ â†’ set Î±} (h : âˆ€ i, is_closed (f i)) :\n    is_closed (Â«exprâ‹‚ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹‚ , Â»\" (f i)) :=\n  is_closed_sInter fun t âŸ¨i, (HEq : f i = t)âŸ© => HEq â–¸ h i\n#align is_closed_Inter is_closed_Inter\n\n",
 "interior_univ":
 "@[simp]\ntheorem interior_univ : interior (univ : set Î±) = univ :=\n  is_open_univ.interior_eq\n#align interior_univ interior_univ\n\n",
 "interior_union_right":
 "theorem is_closed.interior_union_right {s t : set Î±} (h : is_closed t) : interior (s âˆª t) âŠ† interior s âˆª t := by\n  simpa only [union_comm] using h.interior_union_left\n#align is_closed.interior_union_right is_closed.interior_union_right\n\n",
 "interior_union_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á¶œÂ» -/\ntheorem is_closed.interior_union_left {s t : set Î±} (h : is_closed s) : interior (s âˆª t) âŠ† s âˆª interior t :=\n  fun a âŸ¨u, âŸ¨âŸ¨huâ‚, huâ‚‚âŸ©, haâŸ©âŸ© =>\n  (classical.em (a âˆˆ s)).imp_right fun h =>\n    mem_interior.mpr\n      âŸ¨u âˆ© Â«expr á¶œÂ» s, fun x hx => (huâ‚‚ hx.1).resolve_left hx.2, is_open.inter huâ‚ is_closed.is_open_compl, âŸ¨ha, hâŸ©âŸ©\n#align is_closed.interior_union_left is_closed.interior_union_left\n\n",
 "interior_union_is_closed_of_interior_empty":
 "theorem interior_union_is_closed_of_interior_empty {s t : set Î±} (hâ‚ : is_closed s) (hâ‚‚ : interior t = âˆ…) :\n    interior (s âˆª t) = interior s :=\n  have : interior (s âˆª t) âŠ† s := fun x âŸ¨u, âŸ¨(huâ‚ : is_open u), (huâ‚‚ : u âŠ† s âˆª t)âŸ©, (hxâ‚ : x âˆˆ u)âŸ© =>\n    by_contradiction fun hxâ‚‚ : x âˆ‰ s =>\n      have : u \\ s âŠ† t := fun x âŸ¨hâ‚, hâ‚‚âŸ© => or.resolve_left (huâ‚‚ hâ‚) hâ‚‚\n      have : u \\ s âŠ† interior t := by rwa [(is_open.sdiff huâ‚ hâ‚).subset_interior_iff]\n      have : u \\ s âŠ† âˆ… := by rwa [hâ‚‚] at this\n      this âŸ¨hxâ‚, hxâ‚‚âŸ©\n  Subset.antisymm (interior_maximal this is_open_interior) (interior_mono <| subset_union_left _ _)\n#align interior_union_is_closed_of_interior_empty interior_union_is_closed_of_interior_empty\n\n",
 "interior_subset_closure":
 "theorem interior_subset_closure {s : set Î±} : interior s âŠ† closure s :=\n  Subset.trans interior_subset subset_closure\n#align interior_subset_closure interior_subset_closure\n\n",
 "interior_subset":
 "theorem interior_subset {s : set Î±} : interior s âŠ† s :=\n  sUnion_subset fun t âŸ¨hâ‚, hâ‚‚âŸ© => hâ‚‚\n#align interior_subset interior_subset\n\n",
 "interior_singleton":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.ne -/\n/-- If `x` is not an isolated point of a topological space, then the interior of `{x}` is empty. -/\n@[simp]\ntheorem interior_singleton (x : Î±) [ne_bot (nhds_within.ne x)] : interior {x} = (âˆ… : set Î±) :=\n  interior_eq_empty_iff_dense_compl.2 (dense_compl_singleton x)\n#align interior_singleton interior_singleton\n\n",
 "interior_set_of_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem interior_set_of_eq {p : Î± â†’ Prop} :\n    interior { x | p x } =\n      { x |\n        Â«exprâˆ€á¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â»\"\n          ((nhds) x) (p y) } :=\n  interior_eq_nhds'\n#align interior_set_of_eq interior_set_of_eq\n\n",
 "interior_sInter_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹‚â‚€ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹‚ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹‚ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹‚ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹‚ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹‚â‚€ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹‚ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹‚ , Â» -/\ntheorem interior_sInter_subset (S : set (set Î±)) :\n    interior (Â«exprâ‹‚â‚€ Â» S) âŠ†\n      Â«exprâ‹‚ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹‚ , Â»\" (interior s) :=\n  calc\n    interior (Â«exprâ‹‚â‚€ Â» S) =\n        interior (Â«exprâ‹‚ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹‚ , Â»\" s) :=\n      by rw [sInter_eq_bInter]\n    _ âŠ† Â«exprâ‹‚ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹‚ , Â»\" (interior s) :=\n      interior_Interâ‚‚_subset _ _\n    \n#align interior_sInter_subset interior_sInter_subset\n\n",
 "interior_mono":
 "@[mono]\ntheorem interior_mono {s t : set Î±} (h : s âŠ† t) : interior s âŠ† interior t :=\n  interior_maximal (Subset.trans interior_subset h) is_open_interior\n#align interior_mono interior_mono\n\n",
 "interior_mem_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n@[simp]\ntheorem interior_mem_nhds {s : set Î±} {a : Î±} : interior s âˆˆ (nhds) a â†” s âˆˆ (nhds) a :=\n  âŸ¨fun h => mem_of_superset h interior_subset, fun h =>\n    is_open.mem_nhds is_open_interior (mem_interior_iff_mem_nhds.2 h)âŸ©\n#align interior_mem_nhds interior_mem_nhds\n\n",
 "interior_maximal":
 "theorem interior_maximal {s t : set Î±} (hâ‚ : t âŠ† s) (hâ‚‚ : is_open t) : t âŠ† interior s :=\n  subset_unionâ‚›_of_mem âŸ¨hâ‚‚, hâ‚âŸ©\n#align interior_maximal interior_maximal\n\n",
 "interior_interior":
 "@[simp]\ntheorem interior_interior {s : set Î±} : interior (interior s) = interior s :=\n  is_open_interior.interior_eq\n#align interior_interior interior_interior\n\n",
 "interior_inter":
 "@[simp]\ntheorem interior_inter {s t : set Î±} : interior (s âˆ© t) = interior s âˆ© interior t :=\n  Subset.antisymm (subset_inter (interior_mono <| inter_subset_left s t) (interior_mono <| inter_subset_right s t))\n    (interior_maximal (inter_subset_inter interior_subset interior_subset) <|\n      is_open.inter is_open_interior is_open_interior)\n#align interior_inter interior_inter\n\n",
 "interior_frontier":
 "/-- The frontier of a closed set has no interior point. -/\ntheorem interior_frontier {s : set Î±} (h : is_closed s) : interior (frontier s) = âˆ… :=\n  by\n  have A : frontier s = s \\ interior s := h.frontier_eq\n  have B : interior (frontier s) âŠ† interior s := by rw [A] <;> exact interior_mono (diff_subset _ _)\n  have C : interior (frontier s) âŠ† frontier s := interior_subset\n  have : interior (frontier s) âŠ† interior s âˆ© (s \\ interior s) := subset_inter B (by simpa [A] using C)\n  rwa [inter_diff_self, subset_empty_iff] at this\n#align interior_frontier interior_frontier\n\n",
 "interior_eq_univ":
 "@[simp]\ntheorem interior_eq_univ {s : set Î±} : interior s = univ â†” s = univ :=\n  âŸ¨fun h => univ_subset_iff.mp <| h.symm.trans_le interior_subset, fun h => h.symm â–¸ interior_univâŸ©\n#align interior_eq_univ interior_eq_univ\n\n",
 "interior_eq_nhds'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem interior_eq_nhds' {s : set Î±} : interior s = { a | s âˆˆ (nhds) a } :=\n  Set.ext fun x => by simp only [mem_interior, mem_nhds_iff, mem_set_of_eq]\n#align interior_eq_nhds' interior_eq_nhds'\n\n",
 "interior_eq_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\ntheorem interior_eq_nhds {s : set Î±} : interior s = { a | (nhds) a â‰¤ (filter.principal) s } :=\n  interior_eq_nhds'.trans <| by simp only [le_principal_iff]\n#align interior_eq_nhds interior_eq_nhds\n\n",
 "interior_eq_iff_is_open":
 "theorem interior_eq_iff_is_open {s : set Î±} : interior s = s â†” is_open s :=\n  âŸ¨fun h => h â–¸ is_open_interior, is_open.interior_eqâŸ©\n#align interior_eq_iff_is_open interior_eq_iff_is_open\n\n",
 "interior_eq_empty_iff_dense_compl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á¶œÂ» -/\ntheorem interior_eq_empty_iff_dense_compl {s : set Î±} : interior s = âˆ… â†” dense (Â«expr á¶œÂ» s) := by\n  rw [dense_iff_closure_eq, closure_compl, compl_univ_iff]\n#align interior_eq_empty_iff_dense_compl interior_eq_empty_iff_dense_compl\n\n",
 "interior_eq":
 "theorem is_open.interior_eq {s : set Î±} (h : is_open s) : interior s = s :=\n  Subset.antisymm interior_subset (interior_maximal (Subset.refl s) h)\n#align is_open.interior_eq is_open.interior_eq\n\n",
 "interior_empty":
 "@[simp]\ntheorem interior_empty : interior (âˆ… : set Î±) = âˆ… :=\n  is_open_empty.interior_eq\n#align interior_empty interior_empty\n\n",
 "interior_compl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á¶œÂ» -/\ntheorem dense.interior_compl {s : set Î±} (h : dense s) : interior (Â«expr á¶œÂ» s) = âˆ… :=\n  interior_eq_empty_iff_dense_compl.2 <| by rwa [compl_compl]\n#align dense.interior_compl dense.interior_compl\n\n",
 "interior_Interâ‚‚_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹‚ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹‚ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹‚ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹‚ , Â» -/\ntheorem interior_Interâ‚‚_subset (p : Î¹ â†’ Sort _) (s : âˆ€ i, p i â†’ set Î±) :\n    interior (Â«exprâ‹‚ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹‚ , Â»\" (s i j)) âŠ†\n      Â«exprâ‹‚ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹‚ , Â»\"\n        (interior (s i j)) :=\n  (interior_Inter_subset _).trans <| Inter_mono fun i => interior_Inter_subset _\n#align interior_Interâ‚‚_subset interior_Interâ‚‚_subset\n\n",
 "interior_Inter_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹‚ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹‚ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹‚ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹‚ , Â» -/\ntheorem interior_Inter_subset (s : Î¹ â†’ set Î±) :\n    interior (Â«exprâ‹‚ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹‚ , Â»\" (s i)) âŠ†\n      Â«exprâ‹‚ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹‚ , Â»\"\n        (interior (s i)) :=\n  subset_Inter fun i => interior_mono <| interáµ¢_subset _ _\n#align interior_Inter_subset interior_Inter_subset\n\n",
 "interior_Inter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹‚ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹‚ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹‚ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹‚ , Â» -/\n@[simp]\ntheorem interior_Inter {Î¹ : Type _} [Finite Î¹] (f : Î¹ â†’ set Î±) :\n    interior (Â«exprâ‹‚ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹‚ , Â»\" (f i)) =\n      Â«exprâ‹‚ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹‚ , Â»\"\n        (interior (f i)) :=\n  by\n  cases nonempty_fintype Î¹\n  convert finset.univ.interior_Inter f <;> simp\n#align interior_Inter interior_Inter\n\n",
 "inter_of_open_right":
 "/-- The intersection of a dense set with an open dense set is a dense set. -/\ntheorem dense.inter_of_open_right {s t : set Î±} (hs : dense s) (ht : dense t) (hto : is_open t) : dense (s âˆ© t) :=\n  inter_comm t s â–¸ ht.inter_of_open_left hs hto\n#align dense.inter_of_open_right dense.inter_of_open_right\n\n",
 "inter_of_open_left":
 "/-- The intersection of an open dense set with a dense set is a dense set. -/\ntheorem dense.inter_of_open_left {s t : set Î±} (hs : dense s) (ht : dense t) (hso : is_open s) : dense (s âˆ© t) :=\n  fun x => closure_minimal hso.inter_closure is_closed_closure <| by simp [hs.closure_eq, ht.closure_eq]\n#align dense.inter_of_open_left dense.inter_of_open_left\n\n",
 "inter_nhds_nonempty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem dense.inter_nhds_nonempty {s t : set Î±} (hs : dense s) {x : Î±} (ht : t âˆˆ (nhds) x) : (s âˆ© t).nonempty :=\n  let âŸ¨U, hsub, ho, hxâŸ© := mem_nhds_iff.1 ht\n  (hs.inter_open_nonempty U ho âŸ¨x, hxâŸ©).mono fun y hy => âŸ¨hy.2, hsub hy.1âŸ©\n#align dense.inter_nhds_nonempty dense.inter_nhds_nonempty\n\n",
 "inter_frontier_eq":
 "theorem is_open.inter_frontier_eq {s : set Î±} (hs : is_open s) : s âˆ© frontier s = âˆ… := by\n  rw [hs.frontier_eq, inter_diff_self]\n#align is_open.inter_frontier_eq is_open.inter_frontier_eq\n\n",
 "inter_closure":
 "theorem is_open.inter_closure {s t : set Î±} (h : is_open s) : s âˆ© closure t âŠ† closure (s âˆ© t) :=\n  compl_subset_compl.mp <| by\n    simpa only [â† interior_compl, compl_inter] using is_closed.interior_union_left h.is_closed_compl\n#align is_open.inter_closure is_open.inter_closure\n\n",
 "inter":
 "theorem is_closed.inter (hâ‚ : is_closed sâ‚) (hâ‚‚ : is_closed sâ‚‚) : is_closed (sâ‚ âˆ© sâ‚‚) :=\n  by\n  rw [â† is_open_compl_iff] at *\n  rw [compl_inter]\n  exact is_open.union hâ‚ hâ‚‚\n#align is_closed.inter is_closed.inter\n\n",
 "image_closure_subset_closure_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\ntheorem image_closure_subset_closure_image {f : Î± â†’ Î²} {s : set Î±} (h : continuous f) :\n    Â«expr '' Â» f (closure s) âŠ† closure (Â«expr '' Â» f s) :=\n  ((mapsTo_image f s).closure h).image_subset\n#align image_closure_subset_closure_image image_closure_subset_closure_image\n\n",
 "frontier_univ":
 "@[simp]\ntheorem frontier_univ : frontier (univ : set Î±) = âˆ… := by simp [frontier]\n#align frontier_univ frontier_univ\n\n",
 "frontier_union_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á¶œÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á¶œÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á¶œÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á¶œÂ» -/\ntheorem frontier_union_subset (s t : set Î±) :\n    frontier (s âˆª t) âŠ† frontier s âˆ© closure (Â«expr á¶œÂ» t) âˆª closure (Â«expr á¶œÂ» s) âˆ© frontier t := by\n  simpa only [frontier_compl, â† compl_union] using frontier_inter_subset (Â«expr á¶œÂ» s) (Â«expr á¶œÂ» t)\n#align frontier_union_subset frontier_union_subset\n\n",
 "frontier_subset_closure":
 "theorem frontier_subset_closure {s : set Î±} : frontier s âŠ† closure s :=\n  diff_subset _ _\n#align frontier_subset_closure frontier_subset_closure\n\n",
 "frontier_subset":
 "theorem is_closed.frontier_subset (hs : is_closed s) : frontier s âŠ† s :=\n  frontier_subset_closure.trans hs.closure_eq.subset\n#align is_closed.frontier_subset is_closed.frontier_subset\n\n",
 "frontier_right":
 "theorem disjoint.frontier_right (hs : is_open s) (hd : Disjoint s t) : Disjoint s (frontier t) :=\n  (hd.symm.frontier_left hs).symm\n#align disjoint.frontier_right disjoint.frontier_right\n\n",
 "frontier_preimage_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\ntheorem continuous.frontier_preimage_subset {f : Î± â†’ Î²} (hf : continuous f) (t : set Î²) :\n    frontier (Â«expr â»Â¹' Â» f t) âŠ† Â«expr â»Â¹' Â» f (frontier t) :=\n  diff_subset_diff (hf.closure_preimage_subset t) (preimage_interior_subset_interior_preimage hf)\n#align continuous.frontier_preimage_subset continuous.frontier_preimage_subset\n\n",
 "frontier_left":
 "theorem disjoint.frontier_left (ht : is_open t) (hd : Disjoint s t) : Disjoint (frontier s) t :=\n  subset_compl_iff_disjoint_right.1 <|\n    frontier_subset_closure.trans <| closure_minimal (disjoint_left.1 hd) <| is_closed_compl_iff.2 ht\n#align disjoint.frontier_left disjoint.frontier_left\n\n",
 "frontier_interior_subset":
 "theorem frontier_interior_subset {s : set Î±} : frontier (interior s) âŠ† frontier s :=\n  diff_subset_diff (closure_mono interior_subset) interior_interior.symm.subset\n#align frontier_interior_subset frontier_interior_subset\n\n",
 "frontier_inter_subset":
 "theorem frontier_inter_subset (s t : set Î±) : frontier (s âˆ© t) âŠ† frontier s âˆ© closure t âˆª closure s âˆ© frontier t :=\n  by\n  simp only [frontier_eq_closure_inter_closure, compl_inter, closure_union]\n  convert inter_subset_inter_left _ (closure_inter_subset_inter_closure s t)\n  simp only [inter_distrib_left, inter_distrib_right, inter_assoc]\n  congr 2\n  apply inter_comm\n#align frontier_inter_subset frontier_inter_subset\n\n",
 "frontier_eq_inter_compl_interior":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á¶œÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á¶œÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á¶œÂ» -/\ntheorem frontier_eq_inter_compl_interior {s : set Î±} :\n    frontier s = Â«expr á¶œÂ» (interior s) âˆ© Â«expr á¶œÂ» (interior (Â«expr á¶œÂ» s)) :=\n  by\n  rw [â† frontier_compl, â† closure_compl]\n  rfl\n#align frontier_eq_inter_compl_interior frontier_eq_inter_compl_interior\n\n",
 "frontier_eq_closure_inter_closure":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á¶œÂ» -/\ntheorem frontier_eq_closure_inter_closure {s : set Î±} : frontier s = closure s âˆ© closure (Â«expr á¶œÂ» s) := by\n  rw [closure_compl, frontier, diff_eq]\n#align frontier_eq_closure_inter_closure frontier_eq_closure_inter_closure\n\n",
 "frontier_eq":
 "theorem is_open.frontier_eq {s : set Î±} (hs : is_open s) : frontier s = closure s \\ s := by\n  rw [frontier, hs.interior_eq]\n#align is_open.frontier_eq is_open.frontier_eq\n\n",
 "frontier_empty":
 "@[simp]\ntheorem frontier_empty : frontier (âˆ… : set Î±) = âˆ… := by simp [frontier]\n#align frontier_empty frontier_empty\n\n",
 "frontier_compl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á¶œÂ» -/\n/-- The complement of a set has the same frontier as the original set. -/\n@[simp]\ntheorem frontier_compl (s : set Î±) : frontier (Â«expr á¶œÂ» s) = frontier s := by\n  simp only [frontier_eq_closure_inter_closure, compl_compl, inter_comm]\n#align frontier_compl frontier_compl\n\n",
 "frontier_closure_subset":
 "theorem frontier_closure_subset {s : set Î±} : frontier (closure s) âŠ† frontier s :=\n  diff_subset_diff closure_closure.subset <| interior_mono subset_closure\n#align frontier_closure_subset frontier_closure_subset\n\n",
 "frequently_frequently_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆƒá¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆƒá¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆƒá¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆƒá¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆƒá¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆƒá¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n@[simp]\ntheorem frequently_frequently_nhds {p : Î± â†’ Prop} {a : Î±} :\n    Â«exprâˆƒá¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆƒá¶  in , Â»\" ((nhds) a)\n        (Â«exprâˆƒá¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆƒá¶  in , Â»\"\n          ((nhds) y) (p x)) â†”\n      Â«exprâˆƒá¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆƒá¶  in , Â»\" ((nhds) a)\n        (p x) :=\n  by\n  rw [â† not_iff_not]\n  simp_rw [not_frequently]\n  exact eventually_eventually_nhds\n#align frequently_frequently_nhds frequently_frequently_nhds\n\n",
 "exists_open_set_nhds'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ¨† , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨† , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- If `U` is a neighborhood of each point of a set `s` then it is a neighborhood of s:\nit contains an open set containing `s`. -/\ntheorem exists_open_set_nhds' {s U : set Î±}\n    (h :\n      U âˆˆ Â«exprâ¨† , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨† , Â»\" ((nhds) x)) :\n    âˆƒ V : set Î±, s âŠ† V âˆ§ is_open V âˆ§ V âŠ† U :=\n  exists_open_set_nhds (by simpa using h)\n#align exists_open_set_nhds' exists_open_set_nhds'\n\n",
 "exists_open_set_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- If `U` is a neighborhood of each point of a set `s` then it is a neighborhood of `s`:\nit contains an open set containing `s`. -/\ntheorem exists_open_set_nhds {s U : set Î±} (h : âˆ€ x âˆˆ s, U âˆˆ (nhds) x) : âˆƒ V : set Î±, s âŠ† V âˆ§ is_open V âˆ§ V âŠ† U :=\n  by\n  have := fun x hx => (nhds_basis_opens x).mem_iff.1 (h x hx)\n  choose! Z hZ hZU using this; choose hZmem hZo using hZ\n  exact\n    âŸ¨Â«exprâ‹ƒ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â»\" (Z x), fun x hx =>\n      mem_bUnion hx (hZmem x hx), is_open_bUnion hZo, Unionâ‚‚_subset hZUâŸ©\n#align exists_open_set_nhds exists_open_set_nhds\n\n",
 "exists_mem_open":
 "theorem dense_range.exists_mem_open (hf : dense_range f) {s : set Î²} (ho : is_open s) (hs : s.nonempty) :\n    âˆƒ a, f a âˆˆ s :=\n  exists_range_iff.1 <| hf.exists_mem_open ho hs\n#align dense_range.exists_mem_open dense_range.exists_mem_open\n\n",
 "eventually_nhds_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- A predicate is true in a neighborhood of `a` iff it is true for all the points in an open set\ncontaining `a`. -/\ntheorem eventually_nhds_iff {a : Î±} {p : Î± â†’ Prop} :\n    Â«exprâˆ€á¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â»\" ((nhds) a)\n        (p x) â†”\n      âˆƒ t : set Î±, (âˆ€ x âˆˆ t, p x) âˆ§ is_open t âˆ§ a âˆˆ t :=\n  mem_nhds_iff.trans <| by simp only [subset_def, exists_prop, mem_set_of_eq]\n#align eventually_nhds_iff eventually_nhds_iff\n\n",
 "eventually_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- If a predicate is true in a neighbourhood of `a`, then for `y` sufficiently close\nto `a` this predicate is true in a neighbourhood of `y`. -/\ntheorem filter.eventually.eventually_nhds {p : Î± â†’ Prop} {a : Î±}\n    (h :\n      Â«exprâˆ€á¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â»\" ((nhds) a)\n        (p y)) :\n    Â«exprâˆ€á¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â»\" ((nhds) a)\n      (Â«exprâˆ€á¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â»\"\n        ((nhds) y) (p x)) :=\n  let âŸ¨t, htp, hto, haâŸ© := eventually_nhds_iff.1 h\n  eventually_nhds_iff.2 âŸ¨t, fun x hx => eventually_nhds_iff.2 âŸ¨t, htp, hto, hxâŸ©, hto, haâŸ©\n#align filter.eventually.eventually_nhds filter.eventually.eventually_nhds\n\n",
 "eventually_mem_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n@[simp]\ntheorem eventually_mem_nhds {s : set Î±} {a : Î±} :\n    Â«exprâˆ€á¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â»\" ((nhds) a)\n        (s âˆˆ (nhds) x) â†”\n      s âˆˆ (nhds) a :=\n  eventually_eventually_nhds\n#align eventually_mem_nhds eventually_mem_nhds\n\n",
 "eventually_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem is_open.eventually_mem {a : Î±} {s : set Î±} (hs : is_open s) (ha : a âˆˆ s) :\n    Â«exprâˆ€á¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â»\" ((nhds) a)\n      (x âˆˆ s) :=\n  is_open.mem_nhds hs ha\n#align is_open.eventually_mem is_open.eventually_mem\n\n",
 "eventually_le_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰¤á¶ [ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰¤á¶ [ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- If `f x â‰¤ g x` in a neighbourhood of `a`, then for `y` sufficiently close to `a` we have\n`f x â‰¤ g x` in a neighbourhood of `y`. -/\ntheorem filter.eventually_le.eventually_le_nhds [LE Î²] {f g : Î± â†’ Î²} {a : Î±} (h : Â«expr â‰¤á¶ [ ] Â» f ((nhds) a) g) :\n    Â«exprâˆ€á¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â»\" ((nhds) a)\n      (Â«expr â‰¤á¶ [ ] Â» f ((nhds) y) g) :=\n  h.eventually_nhds\n#align filter.eventually_le.eventually_le_nhds filter.eventually_le.eventually_le_nhds\n\n",
 "eventually_eventually_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n@[simp]\ntheorem eventually_eventually_nhds {p : Î± â†’ Prop} {a : Î±} :\n    Â«exprâˆ€á¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â»\" ((nhds) a)\n        (Â«exprâˆ€á¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â»\"\n          ((nhds) y) (p x)) â†”\n      Â«exprâˆ€á¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â»\" ((nhds) a)\n        (p x) :=\n  âŸ¨fun h => h.self_of_nhds, fun h => h.eventually_nhdsâŸ©\n#align eventually_eventually_nhds eventually_eventually_nhds\n\n",
 "eventually_eventually_le_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰¤á¶ [ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰¤á¶ [ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n@[simp]\ntheorem eventually_eventually_le_nhds [LE Î²] {f g : Î± â†’ Î²} {a : Î±} :\n    Â«exprâˆ€á¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â»\" ((nhds) a)\n        (Â«expr â‰¤á¶ [ ] Â» f ((nhds) y) g) â†”\n      Â«expr â‰¤á¶ [ ] Â» f ((nhds) a) g :=\n  eventually_eventually_nhds\n#align eventually_eventually_le_nhds eventually_eventually_le_nhds\n\n",
 "eventually_eventually_eq_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr =á¶ [ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr =á¶ [ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n@[simp]\ntheorem eventually_eventually_eq_nhds {f g : Î± â†’ Î²} {a : Î±} :\n    Â«exprâˆ€á¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â»\" ((nhds) a)\n        (Â«expr =á¶ [ ] Â» f ((nhds) y) g) â†”\n      Â«expr =á¶ [ ] Â» f ((nhds) a) g :=\n  eventually_eventually_nhds\n#align eventually_eventually_eq_nhds eventually_eventually_eq_nhds\n\n",
 "eventually_eq_zero_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr =á¶ [ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem eventually_eq_zero_nhds {Mâ‚€} [Zero Mâ‚€] {a : Î±} {f : Î± â†’ Mâ‚€} :\n    Â«expr =á¶ [ ] Â» f ((nhds) a) 0 â†” a âˆ‰ closure (function.support f) := by\n  rw [â† mem_compl_iff, â† interior_compl, mem_interior_iff_mem_nhds, function.compl_support] <;> rfl\n#align eventually_eq_zero_nhds eventually_eq_zero_nhds\n\n",
 "eventually_eq_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr =á¶ [ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr =á¶ [ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- If two functions are equal in a neighbourhood of `a`, then for `y` sufficiently close\nto `a` these functions are equal in a neighbourhood of `y`. -/\ntheorem filter.eventually_eq.eventually_eq_nhds {f g : Î± â†’ Î²} {a : Î±} (h : Â«expr =á¶ [ ] Â» f ((nhds) a) g) :\n    Â«exprâˆ€á¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â»\" ((nhds) a)\n      (Â«expr =á¶ [ ] Â» f ((nhds) y) g) :=\n  h.eventually_nhds\n#align filter.eventually_eq.eventually_eq_nhds filter.eventually_eq.eventually_eq_nhds\n\n",
 "eq_of_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr =á¶ [ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem filter.eventually_eq.eq_of_nhds {f g : Î± â†’ Î²} {a : Î±} (h : Â«expr =á¶ [ ] Â» f ((nhds) a) g) : f a = g a :=\n  h.self_of_nhds\n#align filter.eventually_eq.eq_of_nhds filter.eventually_eq.eq_of_nhds\n\n",
 "diff_subset_closure_iff":
 "theorem diff_subset_closure_iff {s t : set Î±} : s \\ t âŠ† closure t â†” s âŠ† closure t := by\n  rw [diff_subset_iff, union_eq_self_of_subset_left subset_closure]\n#align diff_subset_closure_iff diff_subset_closure_iff\n\n",
 "dense_univ":
 "@[simp]\ntheorem dense_univ : dense (univ : set Î±) := fun x => subset_closure trivial\n#align dense_univ dense_univ\n\n",
 "dense_range_iff_closure_range":
 "theorem dense_range_iff_closure_range : dense_range f â†” closure (range f) = univ :=\n  dense_iff_closure_eq\n#align dense_range_iff_closure_range dense_range_iff_closure_range\n\n",
 "dense_range_id":
 "theorem dense_range_id : dense_range (id : Î± â†’ Î±) :=\n  function.surjective.dense_range function.surjective_id\n#align dense_range_id dense_range_id\n\n",
 "dense_range_coe":
 "theorem dense.dense_range_coe {s : set Î±} (h : dense s) : dense_range (coe : s â†’ Î±) := by\n  simpa only [dense_range, Subtype.range_coe_subtype]\n#align dense.dense_range_coe dense.dense_range_coe\n\n",
 "dense_range":
 "/-- A surjective map has dense range. -/\ntheorem function.surjective.dense_range (hf : function.surjective f) : dense_range f := fun x => by simp [hf.range_eq]\n#align function.surjective.dense_range function.surjective.dense_range\n\n",
 "dense_of_maps_to":
 "/-- If a continuous map with dense range maps a dense set to a subset of `t`, then `t` is a dense\nset. -/\ntheorem dense_range.dense_of_maps_to {f : Î± â†’ Î²} (hf' : dense_range f) (hf : continuous f) {s : set Î±} (hs : dense s)\n    {t : set Î²} (ht : MapsTo f s t) : dense t :=\n  (hf'.dense_image hf hs).mono ht.image_subset\n#align dense_range.dense_of_maps_to dense_range.dense_of_maps_to\n\n",
 "dense_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/-- The image of a dense set under a continuous map with dense range is a dense set. -/\ntheorem dense_range.dense_image {f : Î± â†’ Î²} (hf' : dense_range f) (hf : continuous f) {s : set Î±} (hs : dense s) :\n    dense (Â«expr '' Â» f s) :=\n  (hf'.mono <| hf.range_subset_closure_image_dense hs).of_closure\n#align dense_range.dense_image dense_range.dense_image\n\n",
 "dense_iff_inter_open":
 "/-- A set is dense if and only if it has a nonempty intersection with each nonempty open set. -/\ntheorem dense_iff_inter_open {s : set Î±} : dense s â†” âˆ€ U, is_open U â†’ U.nonempty â†’ (U âˆ© s).nonempty :=\n  by\n  constructor <;> intro h\n  Â· rintro U U_op âŸ¨x, x_inâŸ©\n    exact mem_closure_iff.1 (by simp only [h.closure_eq]) U U_op x_in\n  Â· intro x\n    rw [mem_closure_iff]\n    intro U U_op x_in\n    exact h U U_op âŸ¨_, x_inâŸ©\n#align dense_iff_inter_open dense_iff_inter_open\n\n",
 "dense_iff_closure_eq":
 "theorem dense_iff_closure_eq {s : set Î±} : dense s â†” closure s = univ :=\n  eq_univ_iff_forall.symm\n#align dense_iff_closure_eq dense_iff_closure_eq\n\n",
 "dense_compl_singleton_iff_not_open":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á¶œÂ» -/\n/-- Complement to a singleton is dense if and only if the singleton is not an open set. -/\ntheorem dense_compl_singleton_iff_not_open {x : Î±} : dense (Â«expr á¶œÂ» {x} : set Î±) â†” Â¬is_open ({x} : set Î±) :=\n  by\n  fconstructor\n  Â· intro hd ho\n    exact (hd.inter_open_nonempty _ ho (singleton_nonempty _)).ne_empty (inter_compl_self _)\n  Â· refine' fun ho => dense_iff_inter_open.2 fun U hU hne => inter_compl_nonempty_iff.2 fun hUx => _\n    obtain rfl : U = {x}\n    exact eq_singleton_iff_nonempty_unique_mem.2 âŸ¨hne, hUxâŸ©\n    exact ho hU\n#align dense_compl_singleton_iff_not_open dense_compl_singleton_iff_not_open\n\n",
 "dense_compl_singleton":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.ne -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á¶œÂ» -/\n/-- If `x` is not an isolated point of a topological space, then `{x}á¶œ` is dense in the whole\nspace. -/\ntheorem dense_compl_singleton (x : Î±) [ne_bot (nhds_within.ne x)] : dense (Â«expr á¶œÂ» {x} : set Î±) :=\n  by\n  intro y\n  rcases eq_or_ne y x with (rfl | hne)\n  Â· rwa [mem_closure_iff_nhds_within_ne_bot]\n  Â· exact subset_closure hne\n#align dense_compl_singleton dense_compl_singleton\n\n",
 "dense_closure":
 "/-- The closure of a set `s` is dense if and only if `s` is dense. -/\n@[simp]\ntheorem dense_closure {s : set Î±} : dense (closure s) â†” dense s := by rw [dense, dense, closure_closure]\n#align dense_closure dense_closure\n\n",
 "continuous_of_const":
 "theorem continuous_of_const {f : Î± â†’ Î²} (h : âˆ€ x y, f x = f y) : continuous f :=\n  continuous_iff_continuous_at.mpr fun x => filter.eventually_eq.continuous_at <| eventually_of_forall fun y => h y x\n#align continuous_of_const continuous_of_const\n\n",
 "continuous_iff_ultrafilter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem continuous_iff_ultrafilter {f : Î± â†’ Î²} :\n    continuous f â†” âˆ€ (x) (g : ultrafilter Î±), â†‘g â‰¤ (nhds) x â†’ tendsto f g ((nhds) (f x)) := by\n  simp only [continuous_iff_continuous_at, continuous_at_iff_ultrafilter]\n#align continuous_iff_ultrafilter continuous_iff_ultrafilter\n\n",
 "continuous_iff_is_closed":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á¶œÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\ntheorem continuous_iff_is_closed {f : Î± â†’ Î²} : continuous f â†” âˆ€ s, is_closed s â†’ is_closed (Â«expr â»Â¹' Â» f s) :=\n  âŸ¨fun hf s hs => by simpa using (continuous_def.1 hf (Â«expr á¶œÂ» s) hs.is_open_compl).is_closed_compl, fun hf =>\n    continuous_def.2 fun s => by rw [â† is_closed_compl_iff, â† is_closed_compl_iff] <;> exact hf _âŸ©\n#align continuous_iff_is_closed continuous_iff_is_closed\n\n",
 "continuous_iff_continuous_at":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\ntheorem continuous_iff_continuous_at {f : Î± â†’ Î²} : continuous f â†” âˆ€ x, continuous_at f x :=\n  âŸ¨continuous.tendsto, fun hf : âˆ€ x, tendsto f ((nhds) x) ((nhds) (f x)) =>\n    continuous_def.2 fun s => fun hs : is_open s =>\n      have : âˆ€ a, f a âˆˆ s â†’ s âˆˆ (nhds) (f a) := fun a ha => is_open.mem_nhds hs ha\n      show is_open (Â«expr â»Â¹' Â» f s) from is_open_iff_nhds.2 fun a ha => le_principal_iff.2 <| hf _ (this a ha)âŸ©\n#align continuous_iff_continuous_at continuous_iff_continuous_at\n\n",
 "continuous_id":
 "theorem continuous_id : continuous (id : Î± â†’ Î±) :=\n  continuous_def.2 fun s h => h\n#align continuous_id continuous_id\n\n",
 "continuous_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\ntheorem continuous_def {f : Î± â†’ Î²} : continuous f â†” âˆ€ s, is_open s â†’ is_open (Â«expr â»Â¹' Â» f s) :=\n  âŸ¨fun hf s hs => hf.is_open_preimage s hs, fun h => âŸ¨hâŸ©âŸ©\n#align continuous_def continuous_def\n\n",
 "continuous_const":
 "theorem continuous_const {b : Î²} : continuous fun a : Î± => b :=\n  continuous_iff_continuous_at.mpr fun a => continuous_at_const\n#align continuous_const continuous_const\n\n",
 "continuous_at_iff_ultrafilter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem continuous_at_iff_ultrafilter {f : Î± â†’ Î²} {x} :\n    continuous_at f x â†” âˆ€ g : ultrafilter Î±, â†‘g â‰¤ (nhds) x â†’ tendsto f g ((nhds) (f x)) :=\n  tendsto_iff_ultrafilter f ((nhds) x) ((nhds) (f x))\n#align continuous_at_iff_ultrafilter continuous_at_iff_ultrafilter\n\n",
 "continuous_at_id":
 "theorem continuous_at_id {x : Î±} : continuous_at id x :=\n  continuous_id.continuous_at\n#align continuous_at_id continuous_at_id\n\n",
 "continuous_at_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem continuous_at_def {f : Î± â†’ Î²} {x : Î±} : continuous_at f x â†” âˆ€ A âˆˆ (nhds) (f x), Â«expr â»Â¹' Â» f A âˆˆ (nhds) x :=\n  iff.rfl\n#align continuous_at_def continuous_at_def\n\n",
 "continuous_at_const":
 "theorem continuous_at_const {x : Î±} {b : Î²} : continuous_at (fun a : Î± => b) x :=\n  tendsto_const_nhds\n#align continuous_at_const continuous_at_const\n\n",
 "continuous_at_congr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr =á¶ [ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem continuous_at_congr {f g : Î± â†’ Î²} {x : Î±} (h : Â«expr =á¶ [ ] Â» f ((nhds) x) g) :\n    continuous_at f x â†” continuous_at g x := by simp only [continuous_at, tendsto_congr' h, h.eq_of_nhds]\n#align continuous_at_congr continuous_at_congr\n\n",
 "continuous_at":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr =á¶ [ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem filter.eventually_eq.continuous_at {x : Î±} {f : Î± â†’ Î²} {y : Î²} (h : Â«expr =á¶ [ ] Â» f ((nhds) x) fun _ => y) :\n    continuous_at f x :=\n  (continuous_at_congr h).2 tendsto_const_nhds\n#align filter.eventually_eq.continuous_at filter.eventually_eq.continuous_at\n\n",
 "congr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr =á¶ [ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem continuous_at.congr {f g : Î± â†’ Î²} {x : Î±} (hf : continuous_at f x) (h : Â«expr =á¶ [ ] Â» f ((nhds) x) g) :\n    continuous_at g x :=\n  (continuous_at_congr h).1 hf\n#align continuous_at.congr continuous_at.congr\n\n",
 "compl_mem_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á¶œÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem is_closed.compl_mem_nhds {a : Î±} {s : set Î±} (hs : is_closed s) (ha : a âˆ‰ s) : Â«expr á¶œÂ» s âˆˆ (nhds) a :=\n  hs.is_open_compl.mem_nhds (mem_compl ha)\n#align is_closed.compl_mem_nhds is_closed.compl_mem_nhds\n\n",
 "compl_frontier_eq_union_interior":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á¶œÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á¶œÂ» -/\ntheorem compl_frontier_eq_union_interior {s : set Î±} : Â«expr á¶œÂ» (frontier s) = interior s âˆª interior (Â«expr á¶œÂ» s) :=\n  by\n  rw [frontier_eq_inter_compl_interior]\n  simp only [compl_inter, compl_compl]\n#align compl_frontier_eq_union_interior compl_frontier_eq_union_interior\n\n",
 "comp":
 "/-- Composition of a continuous map with dense range and a function with dense range has dense\nrange. -/\ntheorem dense_range.comp {g : Î² â†’ Î³} {f : Îº â†’ Î²} (hg : dense_range g) (hf : dense_range f) (cg : continuous g) :\n    dense_range (g âˆ˜ f) := by\n  rw [dense_range, range_comp]\n  exact hg.dense_image cg hf\n#align dense_range.comp dense_range.comp\n\n",
 "cluster_pt_principal_iff_frequently":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆƒá¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆƒá¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem cluster_pt_principal_iff_frequently {x : Î±} {s : set Î±} :\n    cluster_pt x ((filter.principal) s) â†”\n      Â«exprâˆƒá¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆƒá¶  in , Â»\" ((nhds) x)\n        (y âˆˆ s) :=\n  by simp only [cluster_pt_principal_iff, frequently_iff, Set.Nonempty, exists_prop, mem_inter_iff]\n#align cluster_pt_principal_iff_frequently cluster_pt_principal_iff_frequently\n\n",
 "cluster_pt_principal_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- `x` is a cluster point of a set `s` if every neighbourhood of `x` meets `s` on a nonempty\nset. See also `mem_closure_iff_cluster_pt`. -/\ntheorem cluster_pt_principal_iff {x : Î±} {s : set Î±} :\n    cluster_pt x ((filter.principal) s) â†” âˆ€ U âˆˆ (nhds) x, (U âˆ© s).nonempty :=\n  inf_principal_ne_bot_iff\n#align cluster_pt_principal_iff cluster_pt_principal_iff\n\n",
 "cluster_pt_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem ultrafilter.cluster_pt_iff {x : Î±} {f : ultrafilter Î±} : cluster_pt x f â†” â†‘f â‰¤ (nhds) x :=\n  âŸ¨f.le_of_inf_ne_bot', fun h => cluster_pt.of_le_nhds hâŸ©\n#align ultrafilter.cluster_pt_iff ultrafilter.cluster_pt_iff\n\n",
 "closure_univ":
 "@[simp]\ntheorem closure_univ : closure (univ : set Î±) = univ :=\n  is_closed_univ.closure_eq\n#align closure_univ closure_univ\n\n",
 "closure_union":
 "@[simp]\ntheorem closure_union {s t : set Î±} : closure (s âˆª t) = closure s âˆª closure t :=\n  Subset.antisymm\n    (closure_minimal (union_subset_union subset_closure subset_closure) <|\n      is_closed.union is_closed_closure is_closed_closure)\n    ((monotone_closure Î±).le_map_sup s t)\n#align closure_union closure_union\n\n",
 "closure_subset_preimage_closure_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\ntheorem closure_subset_preimage_closure_image {f : Î± â†’ Î²} {s : set Î±} (h : continuous f) :\n    closure s âŠ† Â«expr â»Â¹' Â» f (closure (Â«expr '' Â» f s)) :=\n  by\n  rw [â† Set.image_subset_iff]\n  exact image_closure_subset_closure_image h\n#align closure_subset_preimage_closure_image closure_subset_preimage_closure_image\n\n",
 "closure_subset_iff_is_closed":
 "theorem closure_subset_iff_is_closed {s : set Î±} : closure s âŠ† s â†” is_closed s :=\n  âŸ¨is_closed_of_closure_subset, is_closed.closure_subsetâŸ©\n#align closure_subset_iff_is_closed closure_subset_iff_is_closed\n\n",
 "closure_subset_iff":
 "theorem is_closed.closure_subset_iff {s t : set Î±} (hâ‚ : is_closed t) : closure s âŠ† t â†” s âŠ† t :=\n  âŸ¨Subset.trans subset_closure, fun h => closure_minimal h hâ‚âŸ©\n#align is_closed.closure_subset_iff is_closed.closure_subset_iff\n\n",
 "closure_subset":
 "theorem is_closed.closure_subset {s : set Î±} (hs : is_closed s) : closure s âŠ† s :=\n  closure_minimal (Subset.refl _) hs\n#align is_closed.closure_subset is_closed.closure_subset\n\n",
 "closure_right":
 "theorem disjoint.closure_right {s t : set Î±} (hd : Disjoint s t) (hs : is_open s) : Disjoint s (closure t) :=\n  (hd.symm.closure_left hs).symm\n#align disjoint.closure_right disjoint.closure_right\n\n",
 "closure_range":
 "theorem dense_range.closure_range (h : dense_range f) : closure (range f) = univ :=\n  h.closure_eq\n#align dense_range.closure_range dense_range.closure_range\n\n",
 "closure_preimage_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\ntheorem continuous.closure_preimage_subset {f : Î± â†’ Î²} (hf : continuous f) (t : set Î²) :\n    closure (Â«expr â»Â¹' Â» f t) âŠ† Â«expr â»Â¹' Â» f (closure t) :=\n  by\n  rw [â† (is_closed_closure.preimage hf).closure_eq]\n  exact closure_mono (preimage_mono subset_closure)\n#align continuous.closure_preimage_subset continuous.closure_preimage_subset\n\n",
 "closure_nonempty_iff":
 "@[simp]\ntheorem closure_nonempty_iff {s : set Î±} : (closure s).nonempty â†” s.nonempty := by\n  simp only [nonempty_iff_ne_empty, ne.def, closure_empty_iff]\n#align closure_nonempty_iff closure_nonempty_iff\n\n",
 "closure_mono":
 "@[mono]\ntheorem closure_mono {s t : set Î±} (h : s âŠ† t) : closure s âŠ† closure t :=\n  closure_minimal (Subset.trans h subset_closure) is_closed_closure\n#align closure_mono closure_mono\n\n",
 "closure_minimal":
 "theorem closure_minimal {s t : set Î±} (hâ‚ : s âŠ† t) (hâ‚‚ : is_closed t) : closure s âŠ† t :=\n  interâ‚›_subset_of_mem âŸ¨hâ‚‚, hâ‚âŸ©\n#align closure_minimal closure_minimal\n\n",
 "closure_left":
 "/-- If a continuous map `f` maps `s` to a closed set `t`, then it maps `closure s` to `t`. -/\ntheorem set.maps_to.closure_left {s : set Î±} {t : set Î²} {f : Î± â†’ Î²} (h : MapsTo f s t) (hc : continuous f)\n    (ht : is_closed t) : MapsTo f (closure s) t :=\n  ht.closure_eq â–¸ h.closure hc\n#align set.maps_to.closure_left set.maps_to.closure_left\n\n",
 "closure_inter_subset_inter_closure":
 "theorem closure_inter_subset_inter_closure (s t : set Î±) : closure (s âˆ© t) âŠ† closure s âˆ© closure t :=\n  (monotone_closure Î±).map_inf_le s t\n#align closure_inter_subset_inter_closure closure_inter_subset_inter_closure\n\n",
 "closure_inter_open_nonempty_iff":
 "theorem closure_inter_open_nonempty_iff {s t : set Î±} (h : is_open t) : (closure s âˆ© t).nonempty â†” (s âˆ© t).nonempty :=\n  âŸ¨fun âŸ¨x, hxcs, hxtâŸ© => inter_comm t s â–¸ mem_closure_iff.1 hxcs t h hxt, fun h =>\n    h.mono <| inf_le_inf_right t subset_closureâŸ©\n#align closure_inter_open_nonempty_iff closure_inter_open_nonempty_iff\n\n",
 "closure_inter":
 "theorem is_open.closure_inter {s t : set Î±} (h : is_open t) : closure s âˆ© t âŠ† closure (s âˆ© t) := by\n  simpa only [inter_comm] using h.inter_closure\n#align is_open.closure_inter is_open.closure_inter\n\n",
 "closure_eq_self_union_frontier":
 "theorem closure_eq_self_union_frontier (s : set Î±) : closure s = s âˆª frontier s :=\n  (union_diff_cancel' interior_subset subset_closure).symm\n#align closure_eq_self_union_frontier closure_eq_self_union_frontier\n\n",
 "closure_eq_interior_union_frontier":
 "theorem closure_eq_interior_union_frontier (s : set Î±) : closure s = interior s âˆª frontier s :=\n  (union_diff_cancel interior_subset_closure).symm\n#align closure_eq_interior_union_frontier closure_eq_interior_union_frontier\n\n",
 "closure_eq_iff_is_closed":
 "theorem closure_eq_iff_is_closed {s : set Î±} : closure s = s â†” is_closed s :=\n  âŸ¨fun h => h â–¸ is_closed_closure, is_closed.closure_eqâŸ©\n#align closure_eq_iff_is_closed closure_eq_iff_is_closed\n\n",
 "closure_eq_compl_interior_compl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á¶œÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á¶œÂ» -/\ntheorem closure_eq_compl_interior_compl {s : set Î±} : closure s = Â«expr á¶œÂ» (interior (Â«expr á¶œÂ» s)) :=\n  by\n  rw [interior, closure, compl_sUnion, compl_image_set_of]\n  simp only [compl_subset_compl, is_open_compl_iff]\n#align closure_eq_compl_interior_compl closure_eq_compl_interior_compl\n\n",
 "closure_eq_cluster_pts":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\ntheorem closure_eq_cluster_pts {s : set Î±} : closure s = { a | cluster_pt a ((filter.principal) s) } :=\n  Set.ext fun x => mem_closure_iff_cluster_pt\n#align closure_eq_cluster_pts closure_eq_cluster_pts\n\n",
 "closure_eq":
 "theorem dense.closure_eq {s : set Î±} (h : dense s) : closure s = univ :=\n  dense_iff_closure_eq.mp h\n#align dense.closure_eq dense.closure_eq\n\n",
 "closure_empty_iff":
 "@[simp]\ntheorem closure_empty_iff (s : set Î±) : closure s = âˆ… â†” s = âˆ… :=\n  âŸ¨subset_eq_empty subset_closure, fun h => h.symm â–¸ closure_emptyâŸ©\n#align closure_empty_iff closure_empty_iff\n\n",
 "closure_empty":
 "@[simp]\ntheorem closure_empty : closure (âˆ… : set Î±) = âˆ… :=\n  is_closed_empty.closure_eq\n#align closure_empty closure_empty\n\n",
 "closure_diff_interior":
 "@[simp]\ntheorem closure_diff_interior (s : set Î±) : closure s \\ interior s = frontier s :=\n  rfl\n#align closure_diff_interior closure_diff_interior\n\n",
 "closure_diff_frontier":
 "@[simp]\ntheorem closure_diff_frontier (s : set Î±) : closure s \\ frontier s = interior s := by\n  rw [frontier, diff_diff_right_self, inter_eq_self_of_subset_right interior_subset_closure]\n#align closure_diff_frontier closure_diff_frontier\n\n",
 "closure_diff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á¶œÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á¶œÂ» -/\ntheorem closure_diff {s t : set Î±} : closure s \\ closure t âŠ† closure (s \\ t) :=\n  calc\n    closure s \\ closure t = Â«expr á¶œÂ» (closure t) âˆ© closure s := by simp only [diff_eq, inter_comm]\n    _ âŠ† closure (Â«expr á¶œÂ» (closure t) âˆ© s) := (is_open_compl_iff.mpr <| is_closed_closure).inter_closure\n    _ = closure (s \\ closure t) := by simp only [diff_eq, inter_comm]\n    _ âŠ† closure (s \\ t) := closure_mono <| diff_subset_diff (Subset.refl s) subset_closure\n    \n#align closure_diff closure_diff\n\n",
 "closure_compl_singleton":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.ne -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á¶œÂ» -/\n/-- If `x` is not an isolated point of a topological space, then the closure of `{x}á¶œ` is the whole\nspace. -/\n@[simp]\ntheorem closure_compl_singleton (x : Î±) [ne_bot (nhds_within.ne x)] : closure (Â«expr á¶œÂ» {x}) = (univ : set Î±) :=\n  (dense_compl_singleton x).closure_eq\n#align closure_compl_singleton closure_compl_singleton\n\n",
 "closure_compl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á¶œÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á¶œÂ» -/\n@[simp]\ntheorem closure_compl {s : set Î±} : closure (Â«expr á¶œÂ» s) = Â«expr á¶œÂ» (interior s) := by\n  simp [closure_eq_compl_interior_compl]\n#align closure_compl closure_compl\n\n",
 "closure_closure":
 "@[simp]\ntheorem closure_closure {s : set Î±} : closure (closure s) = closure s :=\n  is_closed_closure.closure_eq\n#align closure_closure closure_closure\n\n",
 "closure_bUnion":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â» -/\n@[simp]\ntheorem finset.closure_bUnion {Î¹ : Type _} (s : Finset Î¹) (f : Î¹ â†’ set Î±) :\n    closure (Â«exprâ‹ƒ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â»\" (f i)) =\n      Â«exprâ‹ƒ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â»\" (closure (f i)) :=\n  by\n  classical\n    refine' s.induction_on (by simp) _\n    intro i s hâ‚ hâ‚‚\n    simp [hâ‚‚]\n#align finset.closure_bUnion finset.closure_bUnion\n\n",
 "closure_Union":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â» -/\n@[simp]\ntheorem closure_Union {Î¹ : Type _} [Finite Î¹] (f : Î¹ â†’ set Î±) :\n    closure (Â«exprâ‹ƒ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â»\" (f i)) =\n      Â«exprâ‹ƒ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â»\" (closure (f i)) :=\n  by\n  cases nonempty_fintype Î¹\n  convert finset.univ.closure_bUnion f <;> simp\n#align closure_Union closure_Union\n\n",
 "closure":
 "/-- If a continuous map `f` maps `s` to `t`, then it maps `closure s` to `closure t`. -/\ntheorem set.maps_to.closure {s : set Î±} {t : set Î²} {f : Î± â†’ Î²} (h : MapsTo f s t) (hc : continuous f) :\n    MapsTo f (closure s) (closure t) :=\n  by\n  simp only [maps_to, mem_closure_iff_cluster_pt]\n  exact fun x hx => hx.map hc.continuous_at (tendsto_principal_principal.2 h)\n#align set.maps_to.closure set.maps_to.closure\n\n",
 "and":
 "theorem is_open.and : is_open { a | pâ‚ a } â†’ is_open { a | pâ‚‚ a } â†’ is_open { a | pâ‚ a âˆ§ pâ‚‚ a } :=\n  is_open.inter\n#align is_open.and is_open.and\n\n",
 "all_mem_nhds_filter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem all_mem_nhds_filter (x : Î±) (f : set Î± â†’ set Î²) (hf : âˆ€ s t, s âŠ† t â†’ f s âŠ† f t) (l : filter Î²) :\n    (âˆ€ s âˆˆ (nhds) x, f s âˆˆ l) â†” âˆ€ s, is_open s â†’ x âˆˆ s â†’ f s âˆˆ l :=\n  all_mem_nhds _ _ fun s t ssubt h => mem_of_superset h (hf s t ssubt)\n#align all_mem_nhds_filter all_mem_nhds_filter\n\n",
 "all_mem_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem all_mem_nhds (x : Î±) (P : set Î± â†’ Prop) (hP : âˆ€ s t, s âŠ† t â†’ P s â†’ P t) :\n    (âˆ€ s âˆˆ (nhds) x, P s) â†” âˆ€ s, is_open s â†’ x âˆˆ s â†’ P s :=\n  ((nhds_basis_opens x).forall_iff hP).trans <| by simp only [and_comm' (x âˆˆ _), and_imp]\n#align all_mem_nhds all_mem_nhds\n\n",
 "acc_pt_iff_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- `x` is an accumulation point of a set `C` iff every neighborhood\nof `x` contains a point of `C` other than `x`. -/\ntheorem acc_pt_iff_nhds (x : Î±) (C : set Î±) : acc_pt x ((filter.principal) C) â†” âˆ€ U âˆˆ (nhds) x, âˆƒ y âˆˆ U âˆ© C, y â‰  x := by\n  simp [acc_principal_iff_cluster, cluster_pt_principal_iff, Set.Nonempty, exists_prop, and_assoc', and_comm' Â¬_ = x]\n#align acc_pt_iff_nhds acc_pt_iff_nhds\n\n",
 "acc_pt_iff_frequently":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆƒá¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆƒá¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- `x` is an accumulation point of a set `C` iff\nthere are points near `x` in `C` and different from `x`.-/\ntheorem acc_pt_iff_frequently (x : Î±) (C : set Î±) :\n    acc_pt x ((filter.principal) C) â†”\n      Â«exprâˆƒá¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆƒá¶  in , Â»\" ((nhds) x)\n        (y â‰  x âˆ§ y âˆˆ C) :=\n  by simp [acc_principal_iff_cluster, cluster_pt_principal_iff_frequently, and_comm']\n#align acc_pt_iff_frequently acc_pt_iff_frequently\n\n",
 "acc_principal_iff_cluster":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/-- `x` is an accumulation point of a set `C` iff it is a cluster point of `C âˆ– {x}`.-/\ntheorem acc_principal_iff_cluster (x : Î±) (C : set Î±) :\n    acc_pt x ((filter.principal) C) â†” cluster_pt x ((filter.principal) (C \\ {x})) := by\n  rw [acc_iff_cluster, inf_principal, inter_comm] <;> rfl\n#align acc_principal_iff_cluster acc_principal_iff_cluster\n\n",
 "acc_iff_cluster":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŠ“ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á¶œÂ» -/\ntheorem acc_iff_cluster (x : Î±) (F : filter Î±) :\n    acc_pt x F â†” cluster_pt x (Â«expr âŠ“ Â» ((filter.principal) (Â«expr á¶œÂ» {x})) F) := by\n  rw [acc_pt, nhds_within, cluster_pt, inf_assoc]\n#align acc_iff_cluster acc_iff_cluster\n\n"}