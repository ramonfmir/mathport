{"union":
 "#print IsPathConnected.union /-\ntheorem IsPathConnected.union {U V : Set X} (hU : IsPathConnected U) (hV : IsPathConnected V) (hUV : (U ∩ V).nonempty) :\n    IsPathConnected (U ∪ V) := by\n  rcases hUV with ⟨x, xU, xV⟩\n  use x, or.inl xU\n  rintro y (yU | yV)\n  · exact (hU.joined_in x xU y yU).mono (subset_union_left U V)\n  · exact (hV.joined_in x xV y yV).mono (subset_union_right U V)\n#align is_path_connected.union IsPathConnected.union\n-/\n\n",
 "truncate_zero_zero":
 "@[simp]\ntheorem truncate_zero_zero {X : Type _} [TopologicalSpace X] {a b : X} (γ : Path a b) :\n    γ.truncate 0 0 = (Path.refl a).cast (by rw [min_self, γ.extend_zero]) γ.extend_zero := by\n  convert γ.truncate_self 0 <;> exact γ.extend_zero.symm\n#align truncate_zero_zero truncate_zero_zero\n\n",
 "truncate_zero_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n@[simp]\ntheorem truncate_zero_one {X : Type _} [TopologicalSpace X] {a b : X} (γ : Path a b) :\n    γ.truncate 0 1 = γ.cast (by simp [zero_le_one, extend_zero]) (by simp) :=\n  by\n  ext x\n  rw [cast_coe]\n  have : ↑x ∈ (Icc 0 1 : Set (exprℝ)) := x.2\n  rw [truncate, coe_mk, max_eq_left this.1, min_eq_left this.2, extend_extends']\n#align truncate_zero_one truncate_zero_one\n\n",
 "truncate_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n@[simp]\ntheorem truncate_self {X : Type _} [TopologicalSpace X] {a b : X} (γ : Path a b) (t : exprℝ) :\n    γ.truncate t t = (Path.refl <| γ.extend t).cast (by rw [min_self]) rfl :=\n  by\n  ext x\n  rw [cast_coe]\n  simp only [truncate, CoeFun.coe, coe_fn, refl, min_def, max_def]\n  split_ifs with h₁ h₂ <;> congr\n#align truncate_self truncate_self\n\n",
 "truncate_range":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem truncate_range {X : Type _} [TopologicalSpace X] {a b : X} (γ : Path a b) {t₀ t₁ : exprℝ} :\n    range (γ.truncate t₀ t₁) ⊆ range γ := by\n  rw [← γ.extend_range]\n  simp only [range_subset_iff, SetCoe.exists, SetCoe.forall]\n  intro x hx\n  simp only [CoeFun.coe, coe_fn, Path.truncate, mem_range_self]\n#align truncate_range truncate_range\n\n",
 "truncate_one_one":
 "@[simp]\ntheorem truncate_one_one {X : Type _} [TopologicalSpace X] {a b : X} (γ : Path a b) :\n    γ.truncate 1 1 = (Path.refl b).cast (by rw [min_self, γ.extend_one]) γ.extend_one := by\n  convert γ.truncate_self 1 <;> exact γ.extend_one.symm\n#align truncate_one_one truncate_one_one\n\n",
 "truncate_continuous_family":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `unit_interval -/\n/-- For a path `γ`, `γ.truncate` gives a \"continuous family of paths\", by which we\n  mean the uncurried function which maps `(t₀, t₁, s)` to `γ.truncate t₀ t₁ s` is continuous. -/\n@[continuity]\ntheorem truncate_continuous_family {X : Type _} [TopologicalSpace X] {a b : X} (γ : Path a b) :\n    Continuous (fun x => γ.truncate x.1 x.2.1 x.2.2 : exprℝ × exprℝ × unit_interval → X) :=\n  γ.continuous_extend.comp\n    (((continuous_subtype_val.comp (continuous_snd.comp continuous_snd)).max continuous_fst).min\n      (continuous_fst.comp continuous_snd))\n#align truncate_continuous_family truncate_continuous_family\n\n",
 "truncate_const_continuous_family":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `unit_interval -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `unit_interval -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uncurry -/\n/- TODO : When `continuity` gets quicker, change the proof back to :\n    `begin`\n      `simp only [has_coe_to_fun.coe, coe_fn, path.truncate],`\n      `continuity,`\n      `exact continuous_subtype_coe`\n    `end` -/\n@[continuity]\ntheorem truncate_const_continuous_family {X : Type _} [TopologicalSpace X] {a b : X} (γ : Path a b) (t : exprℝ) :\n    Continuous (uncurry (γ.truncate t)) :=\n  by\n  have key : Continuous (fun x => (t, x) : exprℝ × unit_interval → exprℝ × exprℝ × unit_interval) :=\n    continuous_const.prod_mk continuous_id\n  convert γ.truncate_continuous_family.comp key\n#align truncate_const_continuous_family truncate_const_continuous_family\n\n",
 "trans_symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n@[simp]\ntheorem trans_symm (γ : Path x y) (γ' : Path y z) : (γ.trans γ').symm = γ'.symm.trans γ.symm :=\n  by\n  ext t\n  simp only [trans_apply, ← one_div, symm_apply, not_le, comp_app]\n  split_ifs with h h₁ h₂ h₃ h₄ <;> rw [coe_symm_eq] at h\n  · have ht : (t : exprℝ) = 1 / 2 := by linarith [unitInterval.nonneg t, unitInterval.le_one t]\n    norm_num [ht]\n  · refine' congr_arg _ (Subtype.ext _)\n    norm_num [sub_sub_eq_add_sub, mul_sub]\n  · refine' congr_arg _ (Subtype.ext _)\n    have h : 2 - 2 * (t : exprℝ) - 1 = 1 - 2 * t := by linarith\n    norm_num [mul_sub, h]\n  · exfalso\n    linarith [unitInterval.nonneg t, unitInterval.le_one t]\n#align trans_symm trans_symm\n\n",
 "trans_range":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem trans_range {X : Type _} [TopologicalSpace X] {a b c : X} (γ₁ : Path a b) (γ₂ : Path b c) :\n    range (γ₁.trans γ₂) = range γ₁ ∪ range γ₂ := by\n  rw [Path.trans]\n  apply eq_of_subset_of_subset\n  · rintro x ⟨⟨t, ht0, ht1⟩, hxt⟩\n    by_cases h : t ≤ 1 / 2\n    · left\n      use 2 * t, ⟨by linarith, by linarith⟩\n      rw [← γ₁.extend_extends]\n      unfold_coes  at hxt\n      simp only [h, comp_app, if_true] at hxt\n      exact hxt\n    · right\n      use 2 * t - 1, ⟨by linarith, by linarith⟩\n      rw [← γ₂.extend_extends]\n      unfold_coes  at hxt\n      simp only [h, comp_app, if_false] at hxt\n      exact hxt\n  · rintro x (⟨⟨t, ht0, ht1⟩, hxt⟩ | ⟨⟨t, ht0, ht1⟩, hxt⟩)\n    · use ⟨t / 2, ⟨by linarith, by linarith⟩⟩\n      unfold_coes\n      have : t / 2 ≤ 1 / 2 := by linarith\n      simp only [this, comp_app, if_true]\n      ring_nf\n      rwa [γ₁.extend_extends]\n    · by_cases h : t = 0\n      · use ⟨1 / 2, ⟨by linarith, by linarith⟩⟩\n        unfold_coes\n        simp only [h, comp_app, if_true, le_refl, mul_one_div_cancel (two_ne_zero' (exprℝ))]\n        rw [γ₁.extend_one]\n        rwa [← γ₂.extend_extends, h, γ₂.extend_zero] at hxt\n      · use ⟨(t + 1) / 2, ⟨by linarith, by linarith⟩⟩\n        unfold_coes\n        change t ≠ 0 at h\n        have ht0 := lt_of_le_of_ne ht0 h.symm\n        have : ¬(t + 1) / 2 ≤ 1 / 2 := by\n          rw [not_le]\n          linarith\n        simp only [comp_app, if_false, this]\n        ring_nf\n        rwa [γ₂.extend_extends]\n#align trans_range trans_range\n\n",
 "trans_prod_eq_prod_trans":
 "/-- Path composition commutes with products -/\ntheorem trans_prod_eq_prod_trans (γ₁ : Path a₁ a₂) (δ₁ : Path a₂ a₃) (γ₂ : Path b₁ b₂) (δ₂ : Path b₂ b₃) :\n    (γ₁.prod γ₂).trans (δ₁.prod δ₂) = (γ₁.trans δ₁).prod (γ₂.trans δ₂) := by\n  ext t <;> unfold Path.trans <;> simp only [Path.coe_mk_mk, Path.prod_coe, Function.comp_apply] <;> split_ifs <;> rfl\n#align trans_prod_eq_prod_trans trans_prod_eq_prod_trans\n\n",
 "trans_pi_eq_pi_trans":
 "/-- Path composition commutes with products -/\ntheorem trans_pi_eq_pi_trans (γ₀ : ∀ i, Path (as i) (bs i)) (γ₁ : ∀ i, Path (bs i) (cs i)) :\n    (Path.pi γ₀).trans (Path.pi γ₁) = Path.pi fun i => (γ₀ i).trans (γ₁ i) :=\n  by\n  ext (t i)\n  unfold Path.trans\n  simp only [Path.coe_mk_mk, Function.comp_apply, pi_coe_fn]\n  split_ifs <;> rfl\n#align trans_pi_eq_pi_trans trans_pi_eq_pi_trans\n\n",
 "trans_continuous_family":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `unit_interval -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `unit_interval -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uncurry -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uncurry -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uncurry -/\n@[continuity]\ntheorem trans_continuous_family {X ι : Type _} [TopologicalSpace X] [TopologicalSpace ι] {a b c : ι → X}\n    (γ₁ : ∀ t : ι, Path (a t) (b t)) (h₁ : Continuous (uncurry γ₁)) (γ₂ : ∀ t : ι, Path (b t) (c t))\n    (h₂ : Continuous (uncurry γ₂)) : Continuous (uncurry fun t => (γ₁ t).trans (γ₂ t)) :=\n  by\n  have h₁' := Path.continuous_uncurry_extend_of_continuous_family γ₁ h₁\n  have h₂' := Path.continuous_uncurry_extend_of_continuous_family γ₂ h₂\n  simp only [has_uncurry.uncurry, CoeFun.coe, coe_fn, Path.trans, (· ∘ ·)]\n  refine' Continuous.if_le _ _ (continuous_subtype_coe.comp continuous_snd) continuous_const _\n  · change\n      Continuous ((fun p : ι × exprℝ => (γ₁ p.1).extend p.2) ∘ prod.map id (fun x => 2 * x : unit_interval → exprℝ))\n    exact h₁'.comp (continuous_id.prod_map <| continuous_const.mul continuous_subtype_val)\n  · change\n      Continuous ((fun p : ι × exprℝ => (γ₂ p.1).extend p.2) ∘ prod.map id (fun x => 2 * x - 1 : unit_interval → exprℝ))\n    exact h₂'.comp (continuous_id.prod_map <| (continuous_const.mul continuous_subtype_val).sub continuous_const)\n  · rintro st hst\n    simp [hst, mul_inv_cancel (two_ne_zero' (exprℝ))]\n#align trans_continuous_family trans_continuous_family\n\n",
 "trans_cast":
 "@[simp]\ntheorem trans_cast {X : Type _} [TopologicalSpace X] {a₁ a₂ b₁ b₂ c₁ c₂ : X} (γ : Path a₂ b₂) (γ' : Path b₂ c₂)\n    (ha : a₁ = a₂) (hb : b₁ = b₂) (hc : c₁ = c₂) : (γ.cast ha hb).trans (γ'.cast hb hc) = (γ.trans γ').cast ha hc :=\n  rfl\n#align trans_cast trans_cast\n\n",
 "trans_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `unit_interval -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n-- TODO: the following are provable by `continuity` but it is too slow\ntheorem trans_apply (γ : Path x y) (γ' : Path y z) (t : unit_interval) :\n    (γ.trans γ') t =\n      if h : (t : exprℝ) ≤ 1 / 2 then γ ⟨2 * t, (mul_pos_mem_iff zero_lt_two).2 ⟨t.2.1, h⟩⟩\n      else γ' ⟨2 * t - 1, two_mul_sub_one_mem_iff.2 ⟨(not_le.1 h).le, t.2.2⟩⟩ :=\n  show ite _ _ _ = _ by split_ifs <;> rw [extend_extends]\n#align trans_apply trans_apply\n\n",
 "trans":
 "#print JoinedIn.trans /-\ntheorem JoinedIn.trans (hxy : JoinedIn F x y) (hyz : JoinedIn F y z) : JoinedIn F x z :=\n  by\n  cases' hxy.mem with hx hy\n  cases' hyz.mem with hx hy\n  simp_all [joinedIn_iff_joined]\n  exact hxy.trans hyz\n#align joined_in.trans JoinedIn.trans\n-/\n\n",
 "target_mem":
 "#print JoinedIn.target_mem /-\ntheorem JoinedIn.target_mem (h : JoinedIn F x y) : y ∈ F :=\n  h.mem.2\n#align joined_in.target_mem JoinedIn.target_mem\n-/\n\n",
 "target":
 "@[simp]\nprotected theorem target : γ 1 = y :=\n  γ.target'\n#align target target\n\n",
 "symm_symm":
 "@[simp]\ntheorem symm_symm {γ : Path x y} : γ.symm.symm = γ := by\n  ext\n  simp\n#align symm_symm symm_symm\n\n",
 "symm_range":
 "@[simp]\ntheorem symm_range {a b : X} (γ : Path a b) : range γ.symm = range γ :=\n  by\n  ext x\n  simp only [mem_range, Path.symm, CoeFun.coe, coe_fn, unitInterval.symm, SetCoe.exists, comp_app, Subtype.coe_mk,\n    subtype.val_eq_coe]\n  constructor <;> rintro ⟨y, hy, hxy⟩ <;> refine' ⟨1 - y, mem_iff_one_sub_mem.mp hy, _⟩ <;> convert hxy\n  simp\n#align symm_range symm_range\n\n",
 "symm_continuous_family":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uncurry -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uncurry -/\n@[continuity]\ntheorem symm_continuous_family {X ι : Type _} [TopologicalSpace X] [TopologicalSpace ι] {a b : ι → X}\n    (γ : ∀ t : ι, Path (a t) (b t)) (h : Continuous (uncurry γ)) : Continuous (uncurry fun t => (γ t).symm) :=\n  h.comp (continuous_id.prod_map continuous_symm)\n#align symm_continuous_family symm_continuous_family\n\n",
 "symm_cast":
 "@[simp]\ntheorem symm_cast {X : Type _} [TopologicalSpace X] {a₁ a₂ b₁ b₂ : X} (γ : Path a₂ b₂) (ha : a₁ = a₂) (hb : b₁ = b₂) :\n    (γ.cast ha hb).symm = γ.symm.cast hb ha :=\n  rfl\n#align symm_cast symm_cast\n\n",
 "symm":
 "#print JoinedIn.symm /-\n@[symm]\ntheorem JoinedIn.symm (h : JoinedIn F x y) : JoinedIn F y x :=\n  by\n  cases' h.mem with hx hy\n  simp_all [joinedIn_iff_joined]\n  exact h.symm\n#align joined_in.symm JoinedIn.symm\n-/\n\n",
 "subset_pathComponent":
 "#print IsPathConnected.subset_pathComponent /-\ntheorem IsPathConnected.subset_pathComponent (h : IsPathConnected F) (x_in : x ∈ F) : F ⊆ pathComponent x :=\n  fun y y_in => h.mem_path_component x_in y_in\n#align is_path_connected.subset_path_component IsPathConnected.subset_pathComponent\n-/\n\n",
 "source_mem":
 "#print JoinedIn.source_mem /-\ntheorem JoinedIn.source_mem (h : JoinedIn F x y) : x ∈ F :=\n  h.mem.1\n#align joined_in.source_mem JoinedIn.source_mem\n-/\n\n",
 "source":
 "@[simp]\nprotected theorem source : γ 0 = x :=\n  γ.source'\n#align source source\n\n",
 "somePath_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `unit_interval -/\n#print JoinedIn.somePath_mem /-\ntheorem JoinedIn.somePath_mem (h : JoinedIn F x y) (t : unit_interval) : h.some_path t ∈ F :=\n  Classical.choose_spec h t\n#align joined_in.some_path_mem JoinedIn.somePath_mem\n-/\n\n",
 "reparam_id":
 "@[simp]\ntheorem reparam_id (γ : Path x y) : γ.reparam id continuous_id rfl rfl = γ :=\n  by\n  ext\n  rfl\n#align reparam_id reparam_id\n\n",
 "refl_trans_refl":
 "@[simp]\ntheorem refl_trans_refl {X : Type _} [TopologicalSpace X] {a : X} : (Path.refl a).trans (Path.refl a) = Path.refl a :=\n  by\n  ext\n  simp only [Path.trans, if_t_t, one_div, Path.refl_extend]\n  rfl\n#align refl_trans_refl refl_trans_refl\n\n",
 "refl_symm":
 "@[simp]\ntheorem refl_symm {a : X} : (Path.refl a).symm = Path.refl a :=\n  by\n  ext\n  rfl\n#align refl_symm refl_symm\n\n",
 "refl_reparam":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `unit_interval -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `unit_interval -/\ntheorem refl_reparam {f : unit_interval → unit_interval} (hfcont : Continuous f) (hf₀ : f 0 = 0) (hf₁ : f 1 = 1) :\n    (refl x).reparam f hfcont hf₀ hf₁ = refl x := by\n  ext\n  simp\n#align refl_reparam refl_reparam\n\n",
 "refl_range":
 "@[simp]\ntheorem refl_range {a : X} : range (Path.refl a) = {a} := by simp [Path.refl, CoeFun.coe, coe_fn]\n#align refl_range refl_range\n\n",
 "refl_extend":
 "@[simp]\ntheorem refl_extend {X : Type _} [TopologicalSpace X] {a : X} : (Path.refl a).extend = fun _ => a :=\n  rfl\n#align refl_extend refl_extend\n\n",
 "refl":
 "#print JoinedIn.refl /-\ntheorem JoinedIn.refl (h : x ∈ F) : JoinedIn F x x :=\n  ⟨Path.refl x, fun t => h⟩\n#align joined_in.refl JoinedIn.refl\n-/\n\n",
 "range_reparam":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `unit_interval -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `unit_interval -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\ntheorem range_reparam (γ : Path x y) {f : unit_interval → unit_interval} (hfcont : Continuous f) (hf₀ : f 0 = 0)\n    (hf₁ : f 1 = 1) : range («expr⇑ » (γ.reparam f hfcont hf₀ hf₁)) = range γ :=\n  by\n  change range (γ ∘ f) = range γ\n  have : range f = univ := by\n    rw [range_iff_surjective]\n    intro t\n    have h₁ : Continuous (Icc_extend (zero_le_one' (exprℝ)) f) := by continuity\n    have := intermediate_value_Icc (zero_le_one' (exprℝ)) h₁.continuous_on\n    · rw [Icc_extend_left, Icc_extend_right] at this\n      change Icc (f 0) (f 1) ⊆ _ at this\n      rw [hf₀, hf₁] at this\n      rcases this t.2 with ⟨w, hw₁, hw₂⟩\n      rw [Icc_extend_of_mem _ _ hw₁] at hw₂\n      use ⟨w, hw₁⟩, hw₂\n  rw [range_comp, this, image_univ]\n#align range_reparam range_reparam\n\n",
 "prod_coe_fn":
 "@[simp]\ntheorem prod_coe_fn (γ₁ : Path a₁ a₂) (γ₂ : Path b₁ b₂) : coe_fn (γ₁.prod γ₂) = fun t => (γ₁ t, γ₂ t) :=\n  rfl\n#align prod_coe_fn prod_coe_fn\n\n",
 "preimage_coe":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n#print IsPathConnected.preimage_coe /-\n/-- If a set `W` is path-connected, then it is also path-connected when seen as a set in a smaller\nambient type `U` (when `U` contains `W`). -/\ntheorem IsPathConnected.preimage_coe {U W : Set X} (hW : IsPathConnected W) (hWU : W ⊆ U) :\n    IsPathConnected («expr ⁻¹' » (coe : U → X) W) :=\n  by\n  rcases hW with ⟨x, x_in, hx⟩\n  use ⟨x, hWU x_in⟩, by simp [x_in]\n  rintro ⟨y, hyU⟩ hyW\n  exact ⟨(hx hyW).joined_subtype.some_path.map (continuous_inclusion hWU), by simp⟩\n#align is_path_connected.preimage_coe IsPathConnected.preimage_coe\n-/\n\n",
 "pi_coe_fn":
 "@[simp]\ntheorem pi_coe_fn (γ : ∀ i, Path (as i) (bs i)) : coe_fn (Path.pi γ) = fun t i => γ i t :=\n  rfl\n#align pi_coe_fn pi_coe_fn\n\n",
 "path_trans":
 "#print Continuous.path_trans /-\n@[continuity]\ntheorem Continuous.path_trans {f : Y → Path x y} {g : Y → Path y z} :\n    Continuous f → Continuous g → Continuous fun t => (f t).trans (g t) :=\n  by\n  intro hf hg\n  apply continuous_uncurry_iff.mp\n  exact trans_continuous_family _ (continuous_uncurry_iff.mpr hf) _ (continuous_uncurry_iff.mpr hg)\n#align continuous.path_trans Continuous.path_trans\n-/\n\n",
 "path_extend":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uncurry -/\n#print ContinuousAt.path_extend /-\ntheorem ContinuousAt.path_extend {g : Y → exprℝ} {l r : Y → X} (γ : ∀ y, Path (l y) (r y)) {y : Y}\n    (hγ : ContinuousAt (uncurry γ) (y, projIcc 0 1 zero_le_one (g y))) (hg : ContinuousAt g y) :\n    ContinuousAt (fun i => (γ i).extend (g i)) y :=\n  hγ.Icc_extend (fun x => γ x) hg\n#align continuous_at.path_extend ContinuousAt.path_extend\n-/\n\n",
 "path_eval":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `unit_interval -/\n#print Continuous.path_eval /-\n@[continuity]\ntheorem Continuous.path_eval {Y} [TopologicalSpace Y] {f : Y → Path x y} {g : Y → unit_interval} (hf : Continuous f)\n    (hg : Continuous g) : Continuous fun y => f y (g y) :=\n  Continuous.comp continuous_eval (hf.prod_mk hg)\n#align continuous.path_eval Continuous.path_eval\n-/\n\n",
 "pathConnected_subset_basis":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print pathConnected_subset_basis /-\ntheorem pathConnected_subset_basis [LocPathConnectedSpace X] {U : Set X} (h : IsOpen U) (hx : x ∈ U) :\n    ((nhds) x).has_basis (fun s : Set X => s ∈ (nhds) x ∧ IsPathConnected s ∧ s ⊆ U) id :=\n  (path_connected_basis x).has_basis_self_subset (IsOpen.mem_nhds h hx)\n#align path_connected_subset_basis pathConnected_subset_basis\n-/\n\n",
 "pathConnectedSpace_iff_zerothHomotopy":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟦ ⟧» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟦ ⟧» -/\n#print pathConnectedSpace_iff_zerothHomotopy /-\ntheorem pathConnectedSpace_iff_zerothHomotopy :\n    PathConnectedSpace X ↔ Nonempty (ZerothHomotopy X) ∧ subsingleton (ZerothHomotopy X) :=\n  by\n  letI := pathSetoid X\n  constructor\n  · intro h\n    refine' ⟨(nonempty_quotient_iff _).mpr h.1, ⟨_⟩⟩\n    rintro ⟨x⟩ ⟨y⟩\n    exact quotient.sound (path_connected_space.joined x y)\n  · unfold ZerothHomotopy\n    rintro ⟨h, h'⟩\n    skip\n    exact ⟨(nonempty_quotient_iff _).mp h, fun x y => quotient.exact <| subsingleton.elim («expr⟦ ⟧» x) («expr⟦ ⟧» y)⟩\n#align path_connected_space_iff_zeroth_homotopy pathConnectedSpace_iff_zerothHomotopy\n-/\n\n",
 "pathConnectedSpace_iff_univ":
 "#print pathConnectedSpace_iff_univ /-\ntheorem pathConnectedSpace_iff_univ : PathConnectedSpace X ↔ IsPathConnected (univ : Set X) :=\n  by\n  constructor\n  · intro h\n    haveI := @path_connected_space.nonempty X _ _\n    inhabit X\n    refine' ⟨default, mem_univ _, _⟩\n    simpa using path_connected_space.joined default\n  · intro h\n    have h' := h.joined_in\n    cases' h with x h\n    exact ⟨⟨x⟩, by simpa using h'⟩\n#align path_connected_space_iff_univ pathConnectedSpace_iff_univ\n-/\n\n",
 "pathConnectedSpace_iff_eq":
 "#print pathConnectedSpace_iff_eq /-\ntheorem pathConnectedSpace_iff_eq : PathConnectedSpace X ↔ ∃ x : X, pathComponent x = univ := by\n  simp [pathConnectedSpace_iff_univ, isPathConnected_iff_eq]\n#align path_connected_space_iff_eq pathConnectedSpace_iff_eq\n-/\n\n",
 "pathConnectedSpace_iff_connectedSpace":
 "#print pathConnectedSpace_iff_connectedSpace /-\ntheorem pathConnectedSpace_iff_connectedSpace [LocPathConnectedSpace X] : PathConnectedSpace X ↔ ConnectedSpace X :=\n  by\n  constructor\n  · intro h\n    infer_instance\n  · intro hX\n    rw [pathConnectedSpace_iff_eq]\n    use Classical.arbitrary X\n    refine' IsClopen.eq_univ ⟨_, _⟩ (by simp)\n    · rw [isOpen_iff_mem_nhds]\n      intro y y_in\n      rcases(path_connected_basis y).ex_mem with ⟨U, ⟨U_in, hU⟩⟩\n      apply mem_of_superset U_in\n      rw [← pathComponent_congr y_in]\n      exact hU.subset_path_component (mem_of_mem_nhds U_in)\n    · rw [isClosed_iff_nhds]\n      intro y H\n      rcases(path_connected_basis y).ex_mem with ⟨U, ⟨U_in, hU⟩⟩\n      rcases H U U_in with ⟨z, hz, hz'⟩\n      exact (hU.joined_in z hz y <| mem_of_mem_nhds U_in).joined.mem_path_component hz'\n#align path_connected_space_iff_connected_space pathConnectedSpace_iff_connectedSpace\n-/\n\n",
 "pathComponent_symm":
 "#print pathComponent_symm /-\ntheorem pathComponent_symm : x ∈ pathComponent y ↔ y ∈ pathComponent x :=\n  ⟨fun h => mem_pathComponent_of_mem h, fun h => mem_pathComponent_of_mem h⟩\n#align path_component_symm pathComponent_symm\n-/\n\n",
 "pathComponent_subset_component":
 "#print pathComponent_subset_component /-\ntheorem pathComponent_subset_component (x : X) : pathComponent x ⊆ connectedComponent x := fun y h =>\n  (isConnected_range h.some_path.continuous).subset_connected_component ⟨0, by simp⟩ ⟨1, by simp⟩\n#align path_component_subset_component pathComponent_subset_component\n-/\n\n",
 "pathComponent_congr":
 "#print pathComponent_congr /-\ntheorem pathComponent_congr (h : x ∈ pathComponent y) : pathComponent x = pathComponent y :=\n  by\n  ext z\n  constructor\n  · intro h'\n    rw [pathComponent_symm]\n    exact (h.trans h').symm\n  · intro h'\n    rw [pathComponent_symm] at h'⊢\n    exact h'.trans h\n#align path_component_congr pathComponent_congr\n-/\n\n",
 "pathComponentIn_univ":
 "#print pathComponentIn_univ /-\n@[simp]\ntheorem pathComponentIn_univ (x : X) : pathComponentIn x univ = pathComponent x := by\n  simp [pathComponentIn, pathComponent, JoinedIn, Joined, exists_true_iff_nonempty]\n#align path_component_in_univ pathComponentIn_univ\n-/\n\n",
 "of_line_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `unit_interval -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `unit_interval -/\ntheorem of_line_mem {f : exprℝ → X} (hf : ContinuousOn f (unit_interval)) (h₀ : f 0 = x) (h₁ : f 1 = y) :\n    ∀ t, ofLine hf h₀ h₁ t ∈ «expr '' » f (unit_interval) := fun ⟨t, t_in⟩ => ⟨t, t_in, rfl⟩\n#align of_line_mem of_line_mem\n\n",
 "ofLine":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `unit_interval -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `unit_interval -/\n#print JoinedIn.ofLine /-\ntheorem JoinedIn.ofLine {f : exprℝ → X} (hf : ContinuousOn f (unit_interval)) (h₀ : f 0 = x) (h₁ : f 1 = y)\n    (hF : «expr '' » f (unit_interval) ⊆ F) : JoinedIn F x y :=\n  ⟨Path.ofLine hf h₀ h₁, fun t => hF <| Path.ofLine_mem hf h₀ h₁ t⟩\n#align joined_in.of_line JoinedIn.ofLine\n-/\n\n",
 "nonempty":
 "#print pathComponent.nonempty /-\n@[simp]\ntheorem pathComponent.nonempty (x : X) : (pathComponent x).nonempty :=\n  ⟨x, mem_pathComponent_self x⟩\n#align path_component.nonempty pathComponent.nonempty\n-/\n\n",
 "mul_apply":
 "@[to_additive]\nprotected theorem mul_apply [Mul X] [ContinuousMul X] {a₁ b₁ a₂ b₂ : X} (γ₁ : Path a₁ b₁) (γ₂ : Path a₂ b₂)\n    (t : unitInterval) : (γ₁.mul γ₂) t = γ₁ t * γ₂ t :=\n  rfl\n#align mul_apply mul_apply\n\n",
 "mono":
 "#print JoinedIn.mono /-\ntheorem JoinedIn.mono {U V : Set X} (h : JoinedIn U x y) (hUV : U ⊆ V) : JoinedIn V x y :=\n  ⟨h.some_path, fun t => hUV (h.some_path_mem t)⟩\n#align joined_in.mono JoinedIn.mono\n-/\n\n",
 "mem_pathComponent_self":
 "#print mem_pathComponent_self /-\n@[simp]\ntheorem mem_pathComponent_self (x : X) : x ∈ pathComponent x :=\n  Joined.refl x\n#align mem_path_component_self mem_pathComponent_self\n-/\n\n",
 "mem_pathComponent_of_mem":
 "#print mem_pathComponent_of_mem /-\ntheorem mem_pathComponent_of_mem (h : x ∈ pathComponent y) : y ∈ pathComponent x :=\n  Joined.symm h\n#align mem_path_component_of_mem mem_pathComponent_of_mem\n-/\n\n",
 "mem_pathComponent":
 "#print IsPathConnected.mem_pathComponent /-\ntheorem IsPathConnected.mem_pathComponent (h : IsPathConnected F) (x_in : x ∈ F) (y_in : y ∈ F) : y ∈ pathComponent x :=\n  (h.joined_in x x_in y y_in).joined\n#align is_path_connected.mem_path_component IsPathConnected.mem_pathComponent\n-/\n\n",
 "mem":
 "#print JoinedIn.mem /-\ntheorem JoinedIn.mem (h : JoinedIn F x y) : x ∈ F ∧ y ∈ F :=\n  by\n  rcases h with ⟨γ, γ_in⟩\n  have : γ 0 ∈ F ∧ γ 1 ∈ F := by constructor <;> apply γ_in\n  simpa using this\n#align joined_in.mem JoinedIn.mem\n-/\n\n",
 "map_trans":
 "@[simp]\ntheorem map_trans (γ : Path x y) (γ' : Path y z) {Y : Type _} [TopologicalSpace Y] {f : X → Y} (h : Continuous f) :\n    (γ.trans γ').map h = (γ.map h).trans (γ'.map h) := by\n  ext t\n  rw [trans_apply, map_coe, comp_app, trans_apply]\n  split_ifs <;> rfl\n#align map_trans map_trans\n\n",
 "map_symm":
 "@[simp]\ntheorem map_symm (γ : Path x y) {Y : Type _} [TopologicalSpace Y] {f : X → Y} (h : Continuous f) :\n    (γ.map h).symm = γ.symm.map h :=\n  rfl\n#align map_symm map_symm\n\n",
 "map_map":
 "@[simp]\ntheorem map_map (γ : Path x y) {Y : Type _} [TopologicalSpace Y] {Z : Type _} [TopologicalSpace Z] {f : X → Y}\n    (hf : Continuous f) {g : Y → Z} (hg : Continuous g) : (γ.map hf).map hg = γ.map (hg.comp hf) :=\n  by\n  ext\n  rfl\n#align map_map map_map\n\n",
 "map_id":
 "@[simp]\ntheorem map_id (γ : Path x y) : γ.map continuous_id = γ :=\n  by\n  ext\n  rfl\n#align map_id map_id\n\n",
 "map_coe":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `unit_interval -/\n@[simp]\ntheorem map_coe (γ : Path x y) {Y : Type _} [TopologicalSpace Y] {f : X → Y} (h : Continuous f) :\n    (γ.map h : unit_interval → Y) = f ∘ γ := by\n  ext t\n  rfl\n#align map_coe map_coe\n\n",
 "locPathConnected_of_isOpen":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n#print locPathConnected_of_isOpen /-\ntheorem locPathConnected_of_isOpen [LocPathConnectedSpace X] {U : Set X} (h : IsOpen U) : LocPathConnectedSpace U :=\n  ⟨by\n    rintro ⟨x, x_in⟩\n    rw [nhds_subtype_eq_comap]\n    constructor\n    intro V\n    rw [(has_basis.comap (coe : U → X) (pathConnected_subset_basis h x_in)).mem_iff]\n    constructor\n    · rintro ⟨W, ⟨W_in, hW, hWU⟩, hWV⟩\n      exact ⟨«expr ⁻¹' » coe W, ⟨⟨preimage_mem_comap W_in, hW.preimage_coe hWU⟩, hWV⟩⟩\n    · rintro ⟨W, ⟨W_in, hW⟩, hWV⟩\n      refine'\n        ⟨«expr '' » coe W,\n          ⟨Filter.image_coe_mem_of_mem_comap (IsOpen.mem_nhds h x_in) W_in, hW.image continuous_subtype_val,\n            Subtype.coe_image_subset U W⟩,\n          _⟩\n      rintro x ⟨y, ⟨y_in, hy⟩⟩\n      rw [← Subtype.coe_injective hy]\n      tauto⟩\n#align loc_path_connected_of_is_open locPathConnected_of_isOpen\n-/\n\n",
 "locPathConnected_of_bases":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print locPathConnected_of_bases /-\ntheorem locPathConnected_of_bases {p : ι → Prop} {s : X → ι → Set X} (h : ∀ x, ((nhds) x).has_basis p (s x))\n    (h' : ∀ x i, p i → IsPathConnected (s x i)) : LocPathConnectedSpace X :=\n  by\n  constructor\n  intro x\n  apply (h x).to_has_basis\n  · intro i pi\n    exact ⟨s x i, ⟨(h x).mem_of_mem pi, h' x i pi⟩, by rfl⟩\n  · rintro U ⟨U_in, hU⟩\n    rcases(h x).mem_iff.mp U_in with ⟨i, pi, hi⟩\n    tauto\n#align loc_path_connected_of_bases locPathConnected_of_bases\n-/\n\n",
 "joined_subtype":
 "#print JoinedIn.joined_subtype /-\n/-- If `x` and `y` are joined in the set `F`, then they are joined in the subtype `F`. -/\ntheorem JoinedIn.joined_subtype (h : JoinedIn F x y) : Joined (⟨x, h.source_mem⟩ : F) (⟨y, h.target_mem⟩ : F) :=\n  ⟨{  to_fun := fun t => ⟨h.some_path t, h.some_path_mem t⟩\n      continuous_to_fun := by continuity\n      source' := by simp\n      target' := by simp }⟩\n#align joined_in.joined_subtype JoinedIn.joined_subtype\n-/\n\n",
 "joinedIn_univ":
 "#print joinedIn_univ /-\n@[simp]\ntheorem joinedIn_univ : JoinedIn univ x y ↔ Joined x y := by simp [JoinedIn, Joined, exists_true_iff_nonempty]\n#align joined_in_univ joinedIn_univ\n-/\n\n",
 "joinedIn_iff_joined":
 "#print joinedIn_iff_joined /-\ntheorem joinedIn_iff_joined (x_in : x ∈ F) (y_in : y ∈ F) : JoinedIn F x y ↔ Joined (⟨x, x_in⟩ : F) (⟨y, y_in⟩ : F) :=\n  ⟨fun h => h.joined_subtype, fun h => ⟨h.some_path.map continuous_subtype_val, by simp⟩⟩\n#align joined_in_iff_joined joinedIn_iff_joined\n-/\n\n",
 "joinedIn":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (x y «expr ∈ » F) -/\n#print IsPathConnected.joinedIn /-\ntheorem IsPathConnected.joinedIn (h : IsPathConnected F) : ∀ (x) (_ : x ∈ F) (y) (_ : y ∈ F), JoinedIn F x y :=\n  fun x x_in x y_in =>\n  let ⟨b, b_in, hb⟩ := h\n  (hb x_in).symm.trans (hb y_in)\n#align is_path_connected.joined_in IsPathConnected.joinedIn\n-/\n\n",
 "joined":
 "#print JoinedIn.joined /-\ntheorem JoinedIn.joined (h : JoinedIn F x y) : Joined x y :=\n  ⟨h.some_path⟩\n#align joined_in.joined JoinedIn.joined\n-/\n\n",
 "isPathConnected_iff_pathConnectedSpace":
 "#print isPathConnected_iff_pathConnectedSpace /-\ntheorem isPathConnected_iff_pathConnectedSpace : IsPathConnected F ↔ PathConnectedSpace F :=\n  by\n  rw [isPathConnected_iff]\n  constructor\n  · rintro ⟨⟨x, x_in⟩, h⟩\n    refine' ⟨⟨⟨x, x_in⟩⟩, _⟩\n    rintro ⟨y, y_in⟩ ⟨z, z_in⟩\n    have H := h y y_in z z_in\n    rwa [joinedIn_iff_joined y_in z_in] at H\n  · rintro ⟨⟨x, x_in⟩, H⟩\n    refine' ⟨⟨x, x_in⟩, fun y y_in z z_in => _⟩\n    rw [joinedIn_iff_joined y_in z_in]\n    apply H\n#align is_path_connected_iff_path_connected_space isPathConnected_iff_pathConnectedSpace\n-/\n\n",
 "isPathConnected_iff_eq":
 "#print isPathConnected_iff_eq /-\ntheorem isPathConnected_iff_eq : IsPathConnected F ↔ ∃ x ∈ F, pathComponentIn x F = F :=\n  by\n  constructor <;> rintro ⟨x, x_in, h⟩ <;> use x, x_in\n  · ext y\n    exact ⟨fun hy => hy.mem.2, h⟩\n  · intro y y_in\n    rwa [← h] at y_in\n#align is_path_connected_iff_eq isPathConnected_iff_eq\n-/\n\n",
 "isPathConnected_iff":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (x y «expr ∈ » F) -/\n#print isPathConnected_iff /-\ntheorem isPathConnected_iff : IsPathConnected F ↔ F.nonempty ∧ ∀ (x) (_ : x ∈ F) (y) (_ : y ∈ F), JoinedIn F x y :=\n  ⟨fun h =>\n    ⟨let ⟨b, b_in, hb⟩ := h\n      ⟨b, b_in⟩,\n      h.joined_in⟩,\n    fun ⟨⟨b, b_in⟩, h⟩ => ⟨b, b_in, fun x x_in => h b b_in x x_in⟩⟩\n#align is_path_connected_iff isPathConnected_iff\n-/\n\n",
 "isConnected_iff_isPathConnected":
 "#print IsOpen.isConnected_iff_isPathConnected /-\ntheorem IsOpen.isConnected_iff_isPathConnected [LocPathConnectedSpace X] {U : Set X} (U_op : IsOpen U) :\n    IsPathConnected U ↔ IsConnected U :=\n  by\n  rw [isConnected_iff_connectedSpace, isPathConnected_iff_pathConnectedSpace]\n  haveI := locPathConnected_of_isOpen U_op\n  exact pathConnectedSpace_iff_connectedSpace\n#align is_open.is_connected_iff_is_path_connected IsOpen.isConnected_iff_isPathConnected\n-/\n\n",
 "isConnected":
 "#print IsPathConnected.isConnected /-\n-- see Note [lower instance priority]\ntheorem IsPathConnected.isConnected (hF : IsPathConnected F) : IsConnected F :=\n  by\n  rw [isConnected_iff_connectedSpace]\n  rw [isPathConnected_iff_pathConnectedSpace] at hF\n  exact @PathConnectedSpace.connectedSpace _ _ hF\n#align is_path_connected.is_connected IsPathConnected.isConnected\n-/\n\n",
 "image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n#print IsPathConnected.image /-\ntheorem IsPathConnected.image {Y : Type _} [TopologicalSpace Y] (hF : IsPathConnected F) {f : X → Y}\n    (hf : Continuous f) : IsPathConnected («expr '' » f F) :=\n  by\n  rcases hF with ⟨x, x_in, hx⟩\n  use f x, mem_image_of_mem f x_in\n  rintro _ ⟨y, y_in, rfl⟩\n  exact ⟨(hx y_in).some_path.map hf, fun t => ⟨_, (hx y_in).some_path_mem t, rfl⟩⟩\n#align is_path_connected.image IsPathConnected.image\n-/\n\n",
 "extend_zero":
 "theorem extend_zero : γ.extend 0 = x := by simp\n#align extend_zero extend_zero\n\n",
 "extend_range":
 "@[simp]\ntheorem extend_range {X : Type _} [TopologicalSpace X] {a b : X} (γ : Path a b) : range γ.extend = range γ :=\n  IccExtend_range _ γ\n#align extend_range extend_range\n\n",
 "extend_one":
 "theorem extend_one : γ.extend 1 = y := by simp\n#align extend_one extend_one\n\n",
 "extend_of_one_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem extend_of_one_le {X : Type _} [TopologicalSpace X] {a b : X} (γ : Path a b) {t : exprℝ} (ht : 1 ≤ t) :\n    γ.extend t = b :=\n  (IccExtend_of_right_le _ _ ht).trans γ.target\n#align extend_of_one_le extend_of_one_le\n\n",
 "extend_of_le_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem extend_of_le_zero {X : Type _} [TopologicalSpace X] {a b : X} (γ : Path a b) {t : exprℝ} (ht : t ≤ 0) :\n    γ.extend t = a :=\n  (IccExtend_of_le_left _ _ ht).trans γ.source\n#align extend_of_le_zero extend_of_le_zero\n\n",
 "extend_extends'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n@[simp]\ntheorem extend_extends' {X : Type _} [TopologicalSpace X] {a b : X} (γ : Path a b) (t : (Icc 0 1 : Set (exprℝ))) :\n    γ.extend t = γ t :=\n  Icc_extend_coe _ γ t\n#align extend_extends' extend_extends'\n\n",
 "extend_extends":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n@[simp]\ntheorem extend_extends {X : Type _} [TopologicalSpace X] {a b : X} (γ : Path a b) {t : exprℝ}\n    (ht : t ∈ (Icc 0 1 : Set (exprℝ))) : γ.extend t = γ ⟨t, ht⟩ :=\n  IccExtend_of_mem _ γ ht\n#align extend_extends extend_extends\n\n",
 "ext":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `unit_interval -/\n#print Path.ext /-\n/-\nCopyright (c) 2020 Patrick Massot. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Patrick Massot\n-/\n@[ext]\nprotected theorem Path.ext : ∀ {γ₁ γ₂ : Path x y}, (γ₁ : unit_interval → X) = γ₂ → γ₁ = γ₂\n  | ⟨⟨x, h11⟩, h12, h13⟩, ⟨⟨x, h21⟩, h22, h23⟩, rfl => rfl\n#align path.ext Path.ext\n-/\n\n",
 "exists_path_through_family'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `unit_interval -/\ntheorem exists_path_through_family' {n : ℕ} (p : Fin (n + 1) → X) :\n    ∃ (γ : Path (p 0) (p n))(t : Fin (n + 1) → unit_interval), ∀ i, γ (t i) = p i :=\n  by\n  have : IsPathConnected (univ : Set X) := path_connected_space_iff_univ.mp (by infer_instance)\n  rcases this.exists_path_through_family' p fun i => true.intro with ⟨γ, t, -, h⟩\n  exact ⟨γ, t, h⟩\n#align exists_path_through_family' exists_path_through_family'\n\n",
 "exists_path_through_family":
 "theorem exists_path_through_family {n : ℕ} (p : Fin (n + 1) → X) : ∃ γ : Path (p 0) (p n), ∀ i, p i ∈ range γ :=\n  by\n  have : IsPathConnected (univ : Set X) := path_connected_space_iff_univ.mp (by infer_instance)\n  rcases this.exists_path_through_family p fun i => true.intro with ⟨γ, -, h⟩\n  exact ⟨γ, h⟩\n#align exists_path_through_family exists_path_through_family\n\n",
 "continuous_uncurry_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uncurry -/\ntheorem continuous_uncurry_iff {Y} [TopologicalSpace Y] {g : Y → Path x y} : Continuous (uncurry g) ↔ Continuous g :=\n  iff.symm <|\n    continuous_induced_rng.trans ⟨fun h => continuous_uncurry_of_continuous ⟨_, h⟩, continuous_of_continuous_uncurry ↑g⟩\n#align continuous_uncurry_iff continuous_uncurry_iff\n\n",
 "continuous_uncurry_extend_of_continuous_family":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uncurry -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uncurry -/\n@[continuity]\ntheorem continuous_uncurry_extend_of_continuous_family {X ι : Type _} [TopologicalSpace X] [TopologicalSpace ι]\n    {a b : ι → X} (γ : ∀ t : ι, Path (a t) (b t)) (h : Continuous (uncurry γ)) :\n    Continuous (uncurry fun t => (γ t).extend) :=\n  h.comp (continuous_id.prod_map continuous_projIcc)\n#align continuous_uncurry_extend_of_continuous_family continuous_uncurry_extend_of_continuous_family\n\n",
 "continuous_trans":
 "@[continuity]\ntheorem continuous_trans {x y z : X} : Continuous fun ρ : Path x y × Path y z => ρ.1.trans ρ.2 :=\n  continuous_fst.path_trans continuous_snd\n#align continuous_trans continuous_trans\n\n",
 "continuous_symm":
 "@[continuity]\ntheorem continuous_symm : Continuous (symm : Path x y → Path y x) :=\n  continuous_uncurry_iff.mp <| symm_continuous_family _ (continuous_fst.path_eval continuous_snd)\n#align continuous_symm continuous_symm\n\n",
 "continuous_extend":
 "/-- A useful special case of `continuous.path_extend`. -/\n@[continuity]\ntheorem continuous_extend : Continuous γ.extend :=\n  γ.continuous.Icc_extend'\n#align continuous_extend continuous_extend\n\n",
 "continuous_eval":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `unit_interval -/\ntheorem continuous_eval : Continuous fun p : Path x y × unit_interval => p.1 p.2 :=\n  continuous_eval'.comp <| continuous_induced_dom.prod_map continuous_id\n#align continuous_eval continuous_eval\n\n",
 "coe_to_fun":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `unit_interval -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `unit_interval -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n@[simp]\ntheorem coe_to_fun (γ : Path x y) {f : unit_interval → unit_interval} (hfcont : Continuous f) (hf₀ : f 0 = 0)\n    (hf₁ : f 1 = 1) : «expr⇑ » (γ.reparam f hfcont hf₀ hf₁) = γ ∘ f :=\n  rfl\n#align coe_to_fun coe_to_fun\n\n",
 "coe_to_continuous_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n@[simp]\ntheorem coe_to_continuous_map : «expr⇑ » γ.to_continuous_map = γ :=\n  rfl\n#align coe_to_continuous_map coe_to_continuous_map\n\n",
 "coe_mk":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `unit_interval -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n@[simp]\ntheorem coe_mk (f : unit_interval → X) (h₁ h₂ h₃) : «expr⇑ » (mk ⟨f, h₁⟩ h₂ h₃ : Path x y) = f :=\n  rfl\n#align coe_mk coe_mk\n\n",
 "cast_coe":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `unit_interval -/\n@[simp]\ntheorem cast_coe (γ : Path x y) {x' y'} (hx : x' = x) (hy : y' = y) : (γ.cast hx hy : unit_interval → X) = γ :=\n  rfl\n#align cast_coe cast_coe\n\n",
 "Continuous":
 "#print Continuous /-\n@[continuity]\nprotected theorem Continuous : Continuous γ :=\n  γ.continuous_to_fun\n#align continuous Continuous\n-/\n\n"}