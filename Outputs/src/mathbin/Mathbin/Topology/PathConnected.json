{"union":
 "theorem is_path_connected.union {U V : set X} (hU : is_path_connected U) (hV : is_path_connected V)\n    (hUV : (U ∩ V).nonempty) : is_path_connected (U ∪ V) :=\n  by\n  rcases hUV with ⟨x, xU, xV⟩\n  use x, or.inl xU\n  rintro y (yU | yV)\n  · exact (hU.joined_in x xU y yU).mono (subset_union_left U V)\n  · exact (hV.joined_in x xV y yV).mono (subset_union_right U V)\n#align is_path_connected.union is_path_connected.union\n\n",
 "truncate_zero_zero":
 "@[simp]\ntheorem truncate_zero_zero {X : Type _} [topological_space X] {a b : X} (γ : path a b) :\n    γ.truncate 0 0 = (path.refl a).cast (by rw [min_self, γ.extend_zero]) γ.extend_zero := by\n  convert γ.truncate_self 0 <;> exact γ.extend_zero.symm\n#align truncate_zero_zero truncate_zero_zero\n\n",
 "truncate_zero_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n@[simp]\ntheorem truncate_zero_one {X : Type _} [topological_space X] {a b : X} (γ : path a b) :\n    γ.truncate 0 1 = γ.cast (by simp [zero_le_one, extend_zero]) (by simp) :=\n  by\n  ext x\n  rw [cast_coe]\n  have : ↑x ∈ (Icc 0 1 : set (exprℝ)) := x.2\n  rw [truncate, coe_mk, max_eq_left this.1, min_eq_left this.2, extend_extends']\n#align truncate_zero_one truncate_zero_one\n\n",
 "truncate_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n@[simp]\ntheorem truncate_self {X : Type _} [topological_space X] {a b : X} (γ : path a b) (t : exprℝ) :\n    γ.truncate t t = (path.refl <| γ.extend t).cast (by rw [min_self]) rfl :=\n  by\n  ext x\n  rw [cast_coe]\n  simp only [truncate, CoeFun.coe, coe_fn, refl, min_def, max_def]\n  split_ifs with h₁ h₂ <;> congr\n#align truncate_self truncate_self\n\n",
 "truncate_range":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem truncate_range {X : Type _} [topological_space X] {a b : X} (γ : path a b) {t₀ t₁ : exprℝ} :\n    range (γ.truncate t₀ t₁) ⊆ range γ := by\n  rw [← γ.extend_range]\n  simp only [range_subset_iff, SetCoe.exists, SetCoe.forall]\n  intro x hx\n  simp only [CoeFun.coe, coe_fn, path.truncate, mem_range_self]\n#align truncate_range truncate_range\n\n",
 "truncate_one_one":
 "@[simp]\ntheorem truncate_one_one {X : Type _} [topological_space X] {a b : X} (γ : path a b) :\n    γ.truncate 1 1 = (path.refl b).cast (by rw [min_self, γ.extend_one]) γ.extend_one := by\n  convert γ.truncate_self 1 <;> exact γ.extend_one.symm\n#align truncate_one_one truncate_one_one\n\n",
 "truncate_continuous_family":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `unit_interval -/\n/-- For a path `γ`, `γ.truncate` gives a \"continuous family of paths\", by which we\n  mean the uncurried function which maps `(t₀, t₁, s)` to `γ.truncate t₀ t₁ s` is continuous. -/\n@[continuity]\ntheorem truncate_continuous_family {X : Type _} [topological_space X] {a b : X} (γ : path a b) :\n    continuous (fun x => γ.truncate x.1 x.2.1 x.2.2 : exprℝ × exprℝ × unit_interval → X) :=\n  γ.continuous_extend.comp\n    (((continuous_subtype_coe.comp (continuous_snd.comp continuous_snd)).max continuous_fst).min\n      (continuous_fst.comp continuous_snd))\n#align truncate_continuous_family truncate_continuous_family\n\n",
 "truncate_const_continuous_family":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `unit_interval -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `unit_interval -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uncurry -/\n/- TODO : When `continuity` gets quicker, change the proof back to :\n    `begin`\n      `simp only [has_coe_to_fun.coe, coe_fn, path.truncate],`\n      `continuity,`\n      `exact continuous_subtype_coe`\n    `end` -/\n@[continuity]\ntheorem truncate_const_continuous_family {X : Type _} [topological_space X] {a b : X} (γ : path a b) (t : exprℝ) :\n    continuous (uncurry (γ.truncate t)) :=\n  by\n  have key : continuous (fun x => (t, x) : exprℝ × unit_interval → exprℝ × exprℝ × unit_interval) :=\n    continuous_const.prod_mk continuous_id\n  convert γ.truncate_continuous_family.comp key\n#align truncate_const_continuous_family truncate_const_continuous_family\n\n",
 "trans_symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n@[simp]\ntheorem trans_symm (γ : path x y) (γ' : path y z) : (γ.trans γ').symm = γ'.symm.trans γ.symm :=\n  by\n  ext t\n  simp only [trans_apply, ← one_div, symm_apply, not_le, comp_app]\n  split_ifs with h h₁ h₂ h₃ h₄ <;> rw [coe_symm_eq] at h\n  · have ht : (t : exprℝ) = 1 / 2 := by linarith [unit_interval.nonneg t, unit_interval.le_one t]\n    norm_num [ht]\n  · refine' congr_arg _ (subtype.ext _)\n    norm_num [sub_sub_eq_add_sub, mul_sub]\n  · refine' congr_arg _ (subtype.ext _)\n    have h : 2 - 2 * (t : exprℝ) - 1 = 1 - 2 * t := by linarith\n    norm_num [mul_sub, h]\n  · exfalso\n    linarith [unit_interval.nonneg t, unit_interval.le_one t]\n#align trans_symm trans_symm\n\n",
 "trans_range":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem trans_range {X : Type _} [topological_space X] {a b c : X} (γ₁ : path a b) (γ₂ : path b c) :\n    range (γ₁.trans γ₂) = range γ₁ ∪ range γ₂ := by\n  rw [path.trans]\n  apply eq_of_subset_of_subset\n  · rintro x ⟨⟨t, ht0, ht1⟩, hxt⟩\n    by_cases h : t ≤ 1 / 2\n    · left\n      use 2 * t, ⟨by linarith, by linarith⟩\n      rw [← γ₁.extend_extends]\n      unfold_coes  at hxt\n      simp only [h, comp_app, if_true] at hxt\n      exact hxt\n    · right\n      use 2 * t - 1, ⟨by linarith, by linarith⟩\n      rw [← γ₂.extend_extends]\n      unfold_coes  at hxt\n      simp only [h, comp_app, if_false] at hxt\n      exact hxt\n  · rintro x (⟨⟨t, ht0, ht1⟩, hxt⟩ | ⟨⟨t, ht0, ht1⟩, hxt⟩)\n    · use ⟨t / 2, ⟨by linarith, by linarith⟩⟩\n      unfold_coes\n      have : t / 2 ≤ 1 / 2 := by linarith\n      simp only [this, comp_app, if_true]\n      ring_nf\n      rwa [γ₁.extend_extends]\n    · by_cases h : t = 0\n      · use ⟨1 / 2, ⟨by linarith, by linarith⟩⟩\n        unfold_coes\n        simp only [h, comp_app, if_true, le_refl, mul_one_div_cancel (two_ne_zero' (exprℝ))]\n        rw [γ₁.extend_one]\n        rwa [← γ₂.extend_extends, h, γ₂.extend_zero] at hxt\n      · use ⟨(t + 1) / 2, ⟨by linarith, by linarith⟩⟩\n        unfold_coes\n        change t ≠ 0 at h\n        have ht0 := lt_of_le_of_ne ht0 h.symm\n        have : ¬(t + 1) / 2 ≤ 1 / 2 := by\n          rw [not_le]\n          linarith\n        simp only [comp_app, if_false, this]\n        ring_nf\n        rwa [γ₂.extend_extends]\n#align trans_range trans_range\n\n",
 "trans_prod_eq_prod_trans":
 "/-- Path composition commutes with products -/\ntheorem trans_prod_eq_prod_trans (γ₁ : path a₁ a₂) (δ₁ : path a₂ a₃) (γ₂ : path b₁ b₂) (δ₂ : path b₂ b₃) :\n    (γ₁.prod γ₂).trans (δ₁.prod δ₂) = (γ₁.trans δ₁).prod (γ₂.trans δ₂) := by\n  ext t <;> unfold path.trans <;> simp only [path.coe_mk, path.prod_coe_fn, Function.comp_apply] <;> split_ifs <;> rfl\n#align trans_prod_eq_prod_trans trans_prod_eq_prod_trans\n\n",
 "trans_pi_eq_pi_trans":
 "/-- Path composition commutes with products -/\ntheorem trans_pi_eq_pi_trans (γ₀ : ∀ i, path (as i) (bs i)) (γ₁ : ∀ i, path (bs i) (cs i)) :\n    (path.pi γ₀).trans (path.pi γ₁) = path.pi fun i => (γ₀ i).trans (γ₁ i) :=\n  by\n  ext (t i)\n  unfold path.trans\n  simp only [path.coe_mk, Function.comp_apply, pi_coe_fn]\n  split_ifs <;> rfl\n#align trans_pi_eq_pi_trans trans_pi_eq_pi_trans\n\n",
 "trans_continuous_family":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `unit_interval -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `unit_interval -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uncurry -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uncurry -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uncurry -/\n@[continuity]\ntheorem trans_continuous_family {X ι : Type _} [topological_space X] [topological_space ι] {a b c : ι → X}\n    (γ₁ : ∀ t : ι, path (a t) (b t)) (h₁ : continuous (uncurry γ₁)) (γ₂ : ∀ t : ι, path (b t) (c t))\n    (h₂ : continuous (uncurry γ₂)) : continuous (uncurry fun t => (γ₁ t).trans (γ₂ t)) :=\n  by\n  have h₁' := path.continuous_uncurry_extend_of_continuous_family γ₁ h₁\n  have h₂' := path.continuous_uncurry_extend_of_continuous_family γ₂ h₂\n  simp only [has_uncurry.uncurry, CoeFun.coe, coe_fn, path.trans, (· ∘ ·)]\n  refine' continuous.if_le _ _ (continuous_subtype_coe.comp continuous_snd) continuous_const _\n  · change\n      continuous ((fun p : ι × exprℝ => (γ₁ p.1).extend p.2) ∘ prod.map id (fun x => 2 * x : unit_interval → exprℝ))\n    exact h₁'.comp (continuous_id.prod_map <| continuous_const.mul continuous_subtype_coe)\n  · change\n      continuous ((fun p : ι × exprℝ => (γ₂ p.1).extend p.2) ∘ prod.map id (fun x => 2 * x - 1 : unit_interval → exprℝ))\n    exact h₂'.comp (continuous_id.prod_map <| (continuous_const.mul continuous_subtype_coe).sub continuous_const)\n  · rintro st hst\n    simp [hst, mul_inv_cancel (two_ne_zero' (exprℝ))]\n#align trans_continuous_family trans_continuous_family\n\n",
 "trans_cast":
 "@[simp]\ntheorem trans_cast {X : Type _} [topological_space X] {a₁ a₂ b₁ b₂ c₁ c₂ : X} (γ : path a₂ b₂) (γ' : path b₂ c₂)\n    (ha : a₁ = a₂) (hb : b₁ = b₂) (hc : c₁ = c₂) : (γ.cast ha hb).trans (γ'.cast hb hc) = (γ.trans γ').cast ha hc :=\n  rfl\n#align trans_cast trans_cast\n\n",
 "trans_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `unit_interval -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n-- TODO: the following are provable by `continuity` but it is too slow\ntheorem trans_apply (γ : path x y) (γ' : path y z) (t : unit_interval) :\n    (γ.trans γ') t =\n      if h : (t : exprℝ) ≤ 1 / 2 then γ ⟨2 * t, (mul_pos_mem_iff zero_lt_two).2 ⟨t.2.1, h⟩⟩\n      else γ' ⟨2 * t - 1, two_mul_sub_one_mem_iff.2 ⟨(not_le.1 h).le, t.2.2⟩⟩ :=\n  show ite _ _ _ = _ by split_ifs <;> rw [extend_extends]\n#align trans_apply trans_apply\n\n",
 "trans":
 "theorem joined_in.trans (hxy : joined_in F x y) (hyz : joined_in F y z) : joined_in F x z :=\n  by\n  cases' hxy.mem with hx hy\n  cases' hyz.mem with hx hy\n  simp_all [joined_in_iff_joined]\n  exact hxy.trans hyz\n#align joined_in.trans joined_in.trans\n\n",
 "target_mem":
 "theorem joined_in.target_mem (h : joined_in F x y) : y ∈ F :=\n  h.mem.2\n#align joined_in.target_mem joined_in.target_mem\n\n",
 "target":
 "@[simp]\nprotected theorem target : γ 1 = y :=\n  γ.target'\n#align target target\n\n",
 "symm_symm":
 "@[simp]\ntheorem symm_symm {γ : path x y} : γ.symm.symm = γ := by\n  ext\n  simp\n#align symm_symm symm_symm\n\n",
 "symm_range":
 "@[simp]\ntheorem symm_range {a b : X} (γ : path a b) : range γ.symm = range γ :=\n  by\n  ext x\n  simp only [mem_range, path.symm, CoeFun.coe, coe_fn, unit_interval.symm, SetCoe.exists, comp_app, subtype.coe_mk,\n    subtype.val_eq_coe]\n  constructor <;> rintro ⟨y, hy, hxy⟩ <;> refine' ⟨1 - y, mem_iff_one_sub_mem.mp hy, _⟩ <;> convert hxy\n  simp\n#align symm_range symm_range\n\n",
 "symm_continuous_family":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uncurry -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uncurry -/\n@[continuity]\ntheorem symm_continuous_family {X ι : Type _} [topological_space X] [topological_space ι] {a b : ι → X}\n    (γ : ∀ t : ι, path (a t) (b t)) (h : continuous (uncurry γ)) : continuous (uncurry fun t => (γ t).symm) :=\n  h.comp (continuous_id.prod_map continuous_symm)\n#align symm_continuous_family symm_continuous_family\n\n",
 "symm_cast":
 "@[simp]\ntheorem symm_cast {X : Type _} [topological_space X] {a₁ a₂ b₁ b₂ : X} (γ : path a₂ b₂) (ha : a₁ = a₂) (hb : b₁ = b₂) :\n    (γ.cast ha hb).symm = γ.symm.cast hb ha :=\n  rfl\n#align symm_cast symm_cast\n\n",
 "symm":
 "@[symm]\ntheorem joined_in.symm (h : joined_in F x y) : joined_in F y x :=\n  by\n  cases' h.mem with hx hy\n  simp_all [joined_in_iff_joined]\n  exact h.symm\n#align joined_in.symm joined_in.symm\n\n",
 "subset_path_component":
 "theorem is_path_connected.subset_path_component (h : is_path_connected F) (x_in : x ∈ F) : F ⊆ path_component x :=\n  fun y y_in => h.mem_path_component x_in y_in\n#align is_path_connected.subset_path_component is_path_connected.subset_path_component\n\n",
 "source_mem":
 "theorem joined_in.source_mem (h : joined_in F x y) : x ∈ F :=\n  h.mem.1\n#align joined_in.source_mem joined_in.source_mem\n\n",
 "source":
 "@[simp]\nprotected theorem source : γ 0 = x :=\n  γ.source'\n#align source source\n\n",
 "some_path_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `unit_interval -/\ntheorem joined_in.some_path_mem (h : joined_in F x y) (t : unit_interval) : h.some_path t ∈ F :=\n  Classical.choose_spec h t\n#align joined_in.some_path_mem joined_in.some_path_mem\n\n",
 "reparam_id":
 "@[simp]\ntheorem reparam_id (γ : path x y) : γ.reparam id continuous_id rfl rfl = γ :=\n  by\n  ext\n  rfl\n#align reparam_id reparam_id\n\n",
 "refl_trans_refl":
 "@[simp]\ntheorem refl_trans_refl {X : Type _} [topological_space X] {a : X} : (path.refl a).trans (path.refl a) = path.refl a :=\n  by\n  ext\n  simp only [path.trans, if_t_t, one_div, path.refl_extend]\n  rfl\n#align refl_trans_refl refl_trans_refl\n\n",
 "refl_symm":
 "@[simp]\ntheorem refl_symm {a : X} : (path.refl a).symm = path.refl a :=\n  by\n  ext\n  rfl\n#align refl_symm refl_symm\n\n",
 "refl_reparam":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `unit_interval -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `unit_interval -/\ntheorem refl_reparam {f : unit_interval → unit_interval} (hfcont : continuous f) (hf₀ : f 0 = 0) (hf₁ : f 1 = 1) :\n    (refl x).reparam f hfcont hf₀ hf₁ = refl x := by\n  ext\n  simp\n#align refl_reparam refl_reparam\n\n",
 "refl_range":
 "@[simp]\ntheorem refl_range {a : X} : range (path.refl a) = {a} := by simp [path.refl, CoeFun.coe, coe_fn]\n#align refl_range refl_range\n\n",
 "refl_extend":
 "@[simp]\ntheorem refl_extend {X : Type _} [topological_space X] {a : X} : (path.refl a).extend = fun _ => a :=\n  rfl\n#align refl_extend refl_extend\n\n",
 "refl":
 "theorem joined_in.refl (h : x ∈ F) : joined_in F x x :=\n  ⟨path.refl x, fun t => h⟩\n#align joined_in.refl joined_in.refl\n\n",
 "range_reparam":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `unit_interval -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `unit_interval -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\ntheorem range_reparam (γ : path x y) {f : unit_interval → unit_interval} (hfcont : continuous f) (hf₀ : f 0 = 0)\n    (hf₁ : f 1 = 1) : range («expr⇑ » (γ.reparam f hfcont hf₀ hf₁)) = range γ :=\n  by\n  change range (γ ∘ f) = range γ\n  have : range f = univ := by\n    rw [range_iff_surjective]\n    intro t\n    have h₁ : continuous (Icc_extend (zero_le_one' (exprℝ)) f) := by continuity\n    have := intermediate_value_Icc (zero_le_one' (exprℝ)) h₁.continuous_on\n    · rw [Icc_extend_left, Icc_extend_right] at this\n      change Icc (f 0) (f 1) ⊆ _ at this\n      rw [hf₀, hf₁] at this\n      rcases this t.2 with ⟨w, hw₁, hw₂⟩\n      rw [Icc_extend_of_mem _ _ hw₁] at hw₂\n      use ⟨w, hw₁⟩, hw₂\n  rw [range_comp, this, image_univ]\n#align range_reparam range_reparam\n\n",
 "prod_coe_fn":
 "@[simp]\ntheorem prod_coe_fn (γ₁ : path a₁ a₂) (γ₂ : path b₁ b₂) : coe_fn (γ₁.prod γ₂) = fun t => (γ₁ t, γ₂ t) :=\n  rfl\n#align prod_coe_fn prod_coe_fn\n\n",
 "preimage_coe":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/-- If a set `W` is path-connected, then it is also path-connected when seen as a set in a smaller\nambient type `U` (when `U` contains `W`). -/\ntheorem is_path_connected.preimage_coe {U W : set X} (hW : is_path_connected W) (hWU : W ⊆ U) :\n    is_path_connected («expr ⁻¹' » (coe : U → X) W) :=\n  by\n  rcases hW with ⟨x, x_in, hx⟩\n  use ⟨x, hWU x_in⟩, by simp [x_in]\n  rintro ⟨y, hyU⟩ hyW\n  exact ⟨(hx hyW).joined_subtype.some_path.map (continuous_inclusion hWU), by simp⟩\n#align is_path_connected.preimage_coe is_path_connected.preimage_coe\n\n",
 "pi_coe_fn":
 "@[simp]\ntheorem pi_coe_fn (γ : ∀ i, path (as i) (bs i)) : coe_fn (path.pi γ) = fun t i => γ i t :=\n  rfl\n#align pi_coe_fn pi_coe_fn\n\n",
 "path_trans":
 "@[continuity]\ntheorem _root_.continuous.path_trans {f : Y → path x y} {g : Y → path y z} :\n    continuous f → continuous g → continuous fun t => (f t).trans (g t) :=\n  by\n  intro hf hg\n  apply continuous_uncurry_iff.mp\n  exact trans_continuous_family _ (continuous_uncurry_iff.mpr hf) _ (continuous_uncurry_iff.mpr hg)\n#align continuous.path_trans continuous.path_trans\n\n",
 "path_extend":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uncurry -/\ntheorem _root_.continuous_at.path_extend {g : Y → exprℝ} {l r : Y → X} (γ : ∀ y, path (l y) (r y)) {y : Y}\n    (hγ : continuous_at (uncurry γ) (y, projIcc 0 1 zero_le_one (g y))) (hg : continuous_at g y) :\n    continuous_at (fun i => (γ i).extend (g i)) y :=\n  hγ.Icc_extend (fun x => γ x) hg\n#align continuous_at.path_extend continuous_at.path_extend\n\n",
 "path_eval":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `unit_interval -/\n@[continuity]\ntheorem _root_.continuous.path_eval {Y} [topological_space Y] {f : Y → path x y} {g : Y → unit_interval}\n    (hf : continuous f) (hg : continuous g) : continuous fun y => f y (g y) :=\n  continuous.comp continuous_eval (hf.prod_mk hg)\n#align continuous.path_eval continuous.path_eval\n\n",
 "path_connected_subset_basis":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem path_connected_subset_basis [loc_path_connected_space X] {U : set X} (h : is_open U) (hx : x ∈ U) :\n    ((nhds) x).has_basis (fun s : set X => s ∈ (nhds) x ∧ is_path_connected s ∧ s ⊆ U) id :=\n  (path_connected_basis x).has_basis_self_subset (is_open.mem_nhds h hx)\n#align path_connected_subset_basis path_connected_subset_basis\n\n",
 "path_connected_space_iff_zeroth_homotopy":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟦ ⟧» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟦ ⟧» -/\ntheorem path_connected_space_iff_zeroth_homotopy :\n    path_connected_space X ↔ nonempty (zeroth_homotopy X) ∧ subsingleton (zeroth_homotopy X) :=\n  by\n  letI := path_setoid X\n  constructor\n  · intro h\n    refine' ⟨(nonempty_quotient_iff _).mpr h.1, ⟨_⟩⟩\n    rintro ⟨x⟩ ⟨y⟩\n    exact quotient.sound (path_connected_space.joined x y)\n  · unfold zeroth_homotopy\n    rintro ⟨h, h'⟩\n    skip\n    exact ⟨(nonempty_quotient_iff _).mp h, fun x y => quotient.exact <| subsingleton.elim («expr⟦ ⟧» x) («expr⟦ ⟧» y)⟩\n#align path_connected_space_iff_zeroth_homotopy path_connected_space_iff_zeroth_homotopy\n\n",
 "path_connected_space_iff_univ":
 "theorem path_connected_space_iff_univ : path_connected_space X ↔ is_path_connected (univ : set X) :=\n  by\n  constructor\n  · intro h\n    haveI := @path_connected_space.nonempty X _ _\n    inhabit X\n    refine' ⟨default, mem_univ _, _⟩\n    simpa using path_connected_space.joined default\n  · intro h\n    have h' := h.joined_in\n    cases' h with x h\n    exact ⟨⟨x⟩, by simpa using h'⟩\n#align path_connected_space_iff_univ path_connected_space_iff_univ\n\n",
 "path_connected_space_iff_eq":
 "theorem path_connected_space_iff_eq : path_connected_space X ↔ ∃ x : X, path_component x = univ := by\n  simp [path_connected_space_iff_univ, is_path_connected_iff_eq]\n#align path_connected_space_iff_eq path_connected_space_iff_eq\n\n",
 "path_connected_space_iff_connected_space":
 "theorem path_connected_space_iff_connected_space [loc_path_connected_space X] :\n    path_connected_space X ↔ connected_space X := by\n  constructor\n  · intro h\n    infer_instance\n  · intro hX\n    rw [path_connected_space_iff_eq]\n    use classical.arbitrary X\n    refine' is_clopen.eq_univ ⟨_, _⟩ (by simp)\n    · rw [is_open_iff_mem_nhds]\n      intro y y_in\n      rcases(path_connected_basis y).ex_mem with ⟨U, ⟨U_in, hU⟩⟩\n      apply mem_of_superset U_in\n      rw [← path_component_congr y_in]\n      exact hU.subset_path_component (mem_of_mem_nhds U_in)\n    · rw [is_closed_iff_nhds]\n      intro y H\n      rcases(path_connected_basis y).ex_mem with ⟨U, ⟨U_in, hU⟩⟩\n      rcases H U U_in with ⟨z, hz, hz'⟩\n      exact (hU.joined_in z hz y <| mem_of_mem_nhds U_in).joined.mem_path_component hz'\n#align path_connected_space_iff_connected_space path_connected_space_iff_connected_space\n\n",
 "path_component_symm":
 "theorem path_component_symm : x ∈ path_component y ↔ y ∈ path_component x :=\n  ⟨fun h => mem_path_component_of_mem h, fun h => mem_path_component_of_mem h⟩\n#align path_component_symm path_component_symm\n\n",
 "path_component_subset_component":
 "theorem path_component_subset_component (x : X) : path_component x ⊆ connected_component x := fun y h =>\n  (is_connected_range h.some_path.continuous).subset_connected_component ⟨0, by simp⟩ ⟨1, by simp⟩\n#align path_component_subset_component path_component_subset_component\n\n",
 "path_component_in_univ":
 "@[simp]\ntheorem path_component_in_univ (x : X) : path_component_in x univ = path_component x := by\n  simp [path_component_in, path_component, joined_in, joined, exists_true_iff_nonempty]\n#align path_component_in_univ path_component_in_univ\n\n",
 "path_component_congr":
 "theorem path_component_congr (h : x ∈ path_component y) : path_component x = path_component y :=\n  by\n  ext z\n  constructor\n  · intro h'\n    rw [path_component_symm]\n    exact (h.trans h').symm\n  · intro h'\n    rw [path_component_symm] at h'⊢\n    exact h'.trans h\n#align path_component_congr path_component_congr\n\n",
 "of_line_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `unit_interval -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `unit_interval -/\ntheorem of_line_mem {f : exprℝ → X} (hf : continuous_on f (unit_interval)) (h₀ : f 0 = x) (h₁ : f 1 = y) :\n    ∀ t, of_line hf h₀ h₁ t ∈ «expr '' » f (unit_interval) := fun ⟨t, t_in⟩ => ⟨t, t_in, rfl⟩\n#align of_line_mem of_line_mem\n\n",
 "of_line":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `unit_interval -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `unit_interval -/\ntheorem joined_in.of_line {f : exprℝ → X} (hf : continuous_on f (unit_interval)) (h₀ : f 0 = x) (h₁ : f 1 = y)\n    (hF : «expr '' » f (unit_interval) ⊆ F) : joined_in F x y :=\n  ⟨path.of_line hf h₀ h₁, fun t => hF <| path.of_line_mem hf h₀ h₁ t⟩\n#align joined_in.of_line joined_in.of_line\n\n",
 "nonempty":
 "@[simp]\ntheorem path_component.nonempty (x : X) : (path_component x).nonempty :=\n  ⟨x, mem_path_component_self x⟩\n#align path_component.nonempty path_component.nonempty\n\n",
 "mul_apply":
 "@[to_additive]\nprotected theorem mul_apply [Mul X] [has_continuous_mul X] {a₁ b₁ a₂ b₂ : X} (γ₁ : path a₁ b₁) (γ₂ : path a₂ b₂)\n    (t : unit_interval) : (γ₁.mul γ₂) t = γ₁ t * γ₂ t :=\n  rfl\n#align mul_apply mul_apply\n\n",
 "mono":
 "theorem joined_in.mono {U V : set X} (h : joined_in U x y) (hUV : U ⊆ V) : joined_in V x y :=\n  ⟨h.some_path, fun t => hUV (h.some_path_mem t)⟩\n#align joined_in.mono joined_in.mono\n\n",
 "mem_path_component_self":
 "@[simp]\ntheorem mem_path_component_self (x : X) : x ∈ path_component x :=\n  joined.refl x\n#align mem_path_component_self mem_path_component_self\n\n",
 "mem_path_component_of_mem":
 "theorem mem_path_component_of_mem (h : x ∈ path_component y) : y ∈ path_component x :=\n  joined.symm h\n#align mem_path_component_of_mem mem_path_component_of_mem\n\n",
 "mem_path_component":
 "theorem is_path_connected.mem_path_component (h : is_path_connected F) (x_in : x ∈ F) (y_in : y ∈ F) :\n    y ∈ path_component x :=\n  (h.joined_in x x_in y y_in).joined\n#align is_path_connected.mem_path_component is_path_connected.mem_path_component\n\n",
 "mem":
 "theorem joined_in.mem (h : joined_in F x y) : x ∈ F ∧ y ∈ F :=\n  by\n  rcases h with ⟨γ, γ_in⟩\n  have : γ 0 ∈ F ∧ γ 1 ∈ F := by constructor <;> apply γ_in\n  simpa using this\n#align joined_in.mem joined_in.mem\n\n",
 "map_trans":
 "@[simp]\ntheorem map_trans (γ : path x y) (γ' : path y z) {Y : Type _} [topological_space Y] {f : X → Y} (h : continuous f) :\n    (γ.trans γ').map h = (γ.map h).trans (γ'.map h) := by\n  ext t\n  rw [trans_apply, map_coe, comp_app, trans_apply]\n  split_ifs <;> rfl\n#align map_trans map_trans\n\n",
 "map_symm":
 "@[simp]\ntheorem map_symm (γ : path x y) {Y : Type _} [topological_space Y] {f : X → Y} (h : continuous f) :\n    (γ.map h).symm = γ.symm.map h :=\n  rfl\n#align map_symm map_symm\n\n",
 "map_map":
 "@[simp]\ntheorem map_map (γ : path x y) {Y : Type _} [topological_space Y] {Z : Type _} [topological_space Z] {f : X → Y}\n    (hf : continuous f) {g : Y → Z} (hg : continuous g) : (γ.map hf).map hg = γ.map (hg.comp hf) :=\n  by\n  ext\n  rfl\n#align map_map map_map\n\n",
 "map_id":
 "@[simp]\ntheorem map_id (γ : path x y) : γ.map continuous_id = γ :=\n  by\n  ext\n  rfl\n#align map_id map_id\n\n",
 "map_coe":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `unit_interval -/\n@[simp]\ntheorem map_coe (γ : path x y) {Y : Type _} [topological_space Y] {f : X → Y} (h : continuous f) :\n    (γ.map h : unit_interval → Y) = f ∘ γ := by\n  ext t\n  rfl\n#align map_coe map_coe\n\n",
 "loc_path_connected_of_is_open":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem loc_path_connected_of_is_open [loc_path_connected_space X] {U : set X} (h : is_open U) :\n    loc_path_connected_space U :=\n  ⟨by\n    rintro ⟨x, x_in⟩\n    rw [nhds_subtype_eq_comap]\n    constructor\n    intro V\n    rw [(has_basis.comap (coe : U → X) (path_connected_subset_basis h x_in)).mem_iff]\n    constructor\n    · rintro ⟨W, ⟨W_in, hW, hWU⟩, hWV⟩\n      exact ⟨«expr ⁻¹' » coe W, ⟨⟨preimage_mem_comap W_in, hW.preimage_coe hWU⟩, hWV⟩⟩\n    · rintro ⟨W, ⟨W_in, hW⟩, hWV⟩\n      refine'\n        ⟨«expr '' » coe W,\n          ⟨filter.image_coe_mem_of_mem_comap (is_open.mem_nhds h x_in) W_in, hW.image continuous_subtype_coe,\n            Subtype.coe_image_subset U W⟩,\n          _⟩\n      rintro x ⟨y, ⟨y_in, hy⟩⟩\n      rw [← subtype.coe_injective hy]\n      tauto⟩\n#align loc_path_connected_of_is_open loc_path_connected_of_is_open\n\n",
 "loc_path_connected_of_bases":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem loc_path_connected_of_bases {p : ι → Prop} {s : X → ι → set X} (h : ∀ x, ((nhds) x).has_basis p (s x))\n    (h' : ∀ x i, p i → is_path_connected (s x i)) : loc_path_connected_space X :=\n  by\n  constructor\n  intro x\n  apply (h x).to_has_basis\n  · intro i pi\n    exact ⟨s x i, ⟨(h x).mem_of_mem pi, h' x i pi⟩, by rfl⟩\n  · rintro U ⟨U_in, hU⟩\n    rcases(h x).mem_iff.mp U_in with ⟨i, pi, hi⟩\n    tauto\n#align loc_path_connected_of_bases loc_path_connected_of_bases\n\n",
 "joined_subtype":
 "/-- If `x` and `y` are joined in the set `F`, then they are joined in the subtype `F`. -/\ntheorem joined_in.joined_subtype (h : joined_in F x y) : joined (⟨x, h.source_mem⟩ : F) (⟨y, h.target_mem⟩ : F) :=\n  ⟨{  to_fun := fun t => ⟨h.some_path t, h.some_path_mem t⟩\n      continuous_to_fun := by continuity\n      source' := by simp\n      target' := by simp }⟩\n#align joined_in.joined_subtype joined_in.joined_subtype\n\n",
 "joined_in_univ":
 "@[simp]\ntheorem joined_in_univ : joined_in univ x y ↔ joined x y := by simp [joined_in, joined, exists_true_iff_nonempty]\n#align joined_in_univ joined_in_univ\n\n",
 "joined_in_iff_joined":
 "theorem joined_in_iff_joined (x_in : x ∈ F) (y_in : y ∈ F) : joined_in F x y ↔ joined (⟨x, x_in⟩ : F) (⟨y, y_in⟩ : F) :=\n  ⟨fun h => h.joined_subtype, fun h => ⟨h.some_path.map continuous_subtype_coe, by simp⟩⟩\n#align joined_in_iff_joined joined_in_iff_joined\n\n",
 "joined_in":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:632:2: warning: expanding binder collection (x y «expr ∈ » F) -/\ntheorem is_path_connected.joined_in (h : is_path_connected F) : ∀ (x) (_ : x ∈ F) (y) (_ : y ∈ F), joined_in F x y :=\n  fun x x_in x y_in =>\n  let ⟨b, b_in, hb⟩ := h\n  (hb x_in).symm.trans (hb y_in)\n#align is_path_connected.joined_in is_path_connected.joined_in\n\n",
 "joined":
 "theorem joined_in.joined (h : joined_in F x y) : joined x y :=\n  ⟨h.some_path⟩\n#align joined_in.joined joined_in.joined\n\n",
 "is_path_connected_iff_path_connected_space":
 "theorem is_path_connected_iff_path_connected_space : is_path_connected F ↔ path_connected_space F :=\n  by\n  rw [is_path_connected_iff]\n  constructor\n  · rintro ⟨⟨x, x_in⟩, h⟩\n    refine' ⟨⟨⟨x, x_in⟩⟩, _⟩\n    rintro ⟨y, y_in⟩ ⟨z, z_in⟩\n    have H := h y y_in z z_in\n    rwa [joined_in_iff_joined y_in z_in] at H\n  · rintro ⟨⟨x, x_in⟩, H⟩\n    refine' ⟨⟨x, x_in⟩, fun y y_in z z_in => _⟩\n    rw [joined_in_iff_joined y_in z_in]\n    apply H\n#align is_path_connected_iff_path_connected_space is_path_connected_iff_path_connected_space\n\n",
 "is_path_connected_iff_eq":
 "theorem is_path_connected_iff_eq : is_path_connected F ↔ ∃ x ∈ F, path_component_in x F = F :=\n  by\n  constructor <;> rintro ⟨x, x_in, h⟩ <;> use x, x_in\n  · ext y\n    exact ⟨fun hy => hy.mem.2, h⟩\n  · intro y y_in\n    rwa [← h] at y_in\n#align is_path_connected_iff_eq is_path_connected_iff_eq\n\n",
 "is_path_connected_iff":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:632:2: warning: expanding binder collection (x y «expr ∈ » F) -/\ntheorem is_path_connected_iff : is_path_connected F ↔ F.nonempty ∧ ∀ (x) (_ : x ∈ F) (y) (_ : y ∈ F), joined_in F x y :=\n  ⟨fun h =>\n    ⟨let ⟨b, b_in, hb⟩ := h\n      ⟨b, b_in⟩,\n      h.joined_in⟩,\n    fun ⟨⟨b, b_in⟩, h⟩ => ⟨b, b_in, fun x x_in => h b b_in x x_in⟩⟩\n#align is_path_connected_iff is_path_connected_iff\n\n",
 "is_connected_iff_is_path_connected":
 "theorem is_open.is_connected_iff_is_path_connected [loc_path_connected_space X] {U : set X} (U_op : is_open U) :\n    is_path_connected U ↔ is_connected U :=\n  by\n  rw [is_connected_iff_connected_space, is_path_connected_iff_path_connected_space]\n  haveI := loc_path_connected_of_is_open U_op\n  exact path_connected_space_iff_connected_space\n#align is_open.is_connected_iff_is_path_connected is_open.is_connected_iff_is_path_connected\n\n",
 "is_connected":
 "-- see Note [lower instance priority]\ntheorem is_path_connected.is_connected (hF : is_path_connected F) : is_connected F :=\n  by\n  rw [is_connected_iff_connected_space]\n  rw [is_path_connected_iff_path_connected_space] at hF\n  exact @path_connected_space.connected_space _ _ hF\n#align is_path_connected.is_connected is_path_connected.is_connected\n\n",
 "image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem is_path_connected.image {Y : Type _} [topological_space Y] (hF : is_path_connected F) {f : X → Y}\n    (hf : continuous f) : is_path_connected («expr '' » f F) :=\n  by\n  rcases hF with ⟨x, x_in, hx⟩\n  use f x, mem_image_of_mem f x_in\n  rintro _ ⟨y, y_in, rfl⟩\n  exact ⟨(hx y_in).some_path.map hf, fun t => ⟨_, (hx y_in).some_path_mem t, rfl⟩⟩\n#align is_path_connected.image is_path_connected.image\n\n",
 "extend_zero":
 "theorem extend_zero : γ.extend 0 = x := by simp\n#align extend_zero extend_zero\n\n",
 "extend_range":
 "@[simp]\ntheorem extend_range {X : Type _} [topological_space X] {a b : X} (γ : path a b) : range γ.extend = range γ :=\n  IccExtend_range _ γ\n#align extend_range extend_range\n\n",
 "extend_one":
 "theorem extend_one : γ.extend 1 = y := by simp\n#align extend_one extend_one\n\n",
 "extend_of_one_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem extend_of_one_le {X : Type _} [topological_space X] {a b : X} (γ : path a b) {t : exprℝ} (ht : 1 ≤ t) :\n    γ.extend t = b :=\n  (IccExtend_of_right_le _ _ ht).trans γ.target\n#align extend_of_one_le extend_of_one_le\n\n",
 "extend_of_le_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem extend_of_le_zero {X : Type _} [topological_space X] {a b : X} (γ : path a b) {t : exprℝ} (ht : t ≤ 0) :\n    γ.extend t = a :=\n  (IccExtend_of_le_left _ _ ht).trans γ.source\n#align extend_of_le_zero extend_of_le_zero\n\n",
 "extend_extends'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n@[simp]\ntheorem extend_extends' {X : Type _} [topological_space X] {a b : X} (γ : path a b) (t : (Icc 0 1 : set (exprℝ))) :\n    γ.extend t = γ t :=\n  Icc_extend_coe _ γ t\n#align extend_extends' extend_extends'\n\n",
 "extend_extends":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n@[simp]\ntheorem extend_extends {X : Type _} [topological_space X] {a b : X} (γ : path a b) {t : exprℝ}\n    (ht : t ∈ (Icc 0 1 : set (exprℝ))) : γ.extend t = γ ⟨t, ht⟩ :=\n  IccExtend_of_mem _ γ ht\n#align extend_extends extend_extends\n\n",
 "ext":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `unit_interval -/\n/-\nCopyright (c) 2020 Patrick Massot. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Patrick Massot\n-/\n@[ext]\nprotected theorem path.ext : ∀ {γ₁ γ₂ : path x y}, (γ₁ : unit_interval → X) = γ₂ → γ₁ = γ₂\n  | ⟨⟨x, h11⟩, h12, h13⟩, ⟨⟨x, h21⟩, h22, h23⟩, rfl => rfl\n#align path.ext path.ext\n\n",
 "exists_path_through_family'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `unit_interval -/\ntheorem exists_path_through_family' {n : ℕ} (p : fin (n + 1) → X) :\n    ∃ (γ : path (p 0) (p n))(t : fin (n + 1) → unit_interval), ∀ i, γ (t i) = p i :=\n  by\n  have : is_path_connected (univ : set X) := path_connected_space_iff_univ.mp (by infer_instance)\n  rcases this.exists_path_through_family' p fun i => true.intro with ⟨γ, t, -, h⟩\n  exact ⟨γ, t, h⟩\n#align exists_path_through_family' exists_path_through_family'\n\n",
 "exists_path_through_family":
 "theorem exists_path_through_family {n : ℕ} (p : fin (n + 1) → X) : ∃ γ : path (p 0) (p n), ∀ i, p i ∈ range γ :=\n  by\n  have : is_path_connected (univ : set X) := path_connected_space_iff_univ.mp (by infer_instance)\n  rcases this.exists_path_through_family p fun i => true.intro with ⟨γ, -, h⟩\n  exact ⟨γ, h⟩\n#align exists_path_through_family exists_path_through_family\n\n",
 "continuous_uncurry_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uncurry -/\ntheorem continuous_uncurry_iff {Y} [topological_space Y] {g : Y → path x y} : continuous (uncurry g) ↔ continuous g :=\n  iff.symm <|\n    continuous_induced_rng.trans ⟨fun h => continuous_uncurry_of_continuous ⟨_, h⟩, continuous_of_continuous_uncurry ↑g⟩\n#align continuous_uncurry_iff continuous_uncurry_iff\n\n",
 "continuous_uncurry_extend_of_continuous_family":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uncurry -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uncurry -/\n@[continuity]\ntheorem continuous_uncurry_extend_of_continuous_family {X ι : Type _} [topological_space X] [topological_space ι]\n    {a b : ι → X} (γ : ∀ t : ι, path (a t) (b t)) (h : continuous (uncurry γ)) :\n    continuous (uncurry fun t => (γ t).extend) :=\n  h.comp (continuous_id.prod_map continuous_proj_Icc)\n#align continuous_uncurry_extend_of_continuous_family continuous_uncurry_extend_of_continuous_family\n\n",
 "continuous_trans":
 "@[continuity]\ntheorem continuous_trans {x y z : X} : continuous fun ρ : path x y × path y z => ρ.1.trans ρ.2 :=\n  continuous_fst.path_trans continuous_snd\n#align continuous_trans continuous_trans\n\n",
 "continuous_symm":
 "@[continuity]\ntheorem continuous_symm : continuous (symm : path x y → path y x) :=\n  continuous_uncurry_iff.mp <| symm_continuous_family _ (continuous_fst.path_eval continuous_snd)\n#align continuous_symm continuous_symm\n\n",
 "continuous_extend":
 "/-- A useful special case of `continuous.path_extend`. -/\n@[continuity]\ntheorem continuous_extend : continuous γ.extend :=\n  γ.continuous.Icc_extend'\n#align continuous_extend continuous_extend\n\n",
 "continuous_eval":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `unit_interval -/\ntheorem continuous_eval : continuous fun p : path x y × unit_interval => p.1 p.2 :=\n  continuous_eval'.comp <| continuous_induced_dom.prod_map continuous_id\n#align continuous_eval continuous_eval\n\n",
 "continuous":
 "@[continuity]\nprotected theorem continuous : continuous γ :=\n  γ.continuous_to_fun\n#align continuous continuous\n\n",
 "coe_to_fun":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `unit_interval -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `unit_interval -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n@[simp]\ntheorem coe_to_fun (γ : path x y) {f : unit_interval → unit_interval} (hfcont : continuous f) (hf₀ : f 0 = 0)\n    (hf₁ : f 1 = 1) : «expr⇑ » (γ.reparam f hfcont hf₀ hf₁) = γ ∘ f :=\n  rfl\n#align coe_to_fun coe_to_fun\n\n",
 "coe_to_continuous_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n@[simp]\ntheorem coe_to_continuous_map : «expr⇑ » γ.to_continuous_map = γ :=\n  rfl\n#align coe_to_continuous_map coe_to_continuous_map\n\n",
 "coe_mk":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `unit_interval -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n@[simp]\ntheorem coe_mk (f : unit_interval → X) (h₁ h₂ h₃) : «expr⇑ » (mk ⟨f, h₁⟩ h₂ h₃ : path x y) = f :=\n  rfl\n#align coe_mk coe_mk\n\n",
 "cast_coe":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `unit_interval -/\n@[simp]\ntheorem cast_coe (γ : path x y) {x' y'} (hx : x' = x) (hy : y' = y) : (γ.cast hx hy : unit_interval → X) = γ :=\n  rfl\n#align cast_coe cast_coe\n\n"}