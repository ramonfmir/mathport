{"to_trivialization_apply":
 "theorem to_trivialization_apply {x : E} {I : Type _} [TopologicalSpace I] (h : IsEvenlyCovered f (f x) I) :\n    (h.to_trivialization x).2 = ⟨x, rfl⟩ :=\n  let e := Classical.choose h.2\n  let h := Classical.choose_spec h.2\n  let he := e.mk_proj_snd' h\n  Subtype.ext\n    ((e.to_local_equiv.eq_symm_apply (e.mem_source.mpr h)\n            (by rwa [he, e.mem_target, e.coe_fst (e.mem_source.mpr h)])).mpr\n        he.symm).symm\n#align to_trivialization_apply to_trivialization_apply\n\n",
 "to_is_evenly_covered_preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem to_is_evenly_covered_preimage {x : X} {I : Type _} [TopologicalSpace I] (h : IsEvenlyCovered f x I) :\n    IsEvenlyCovered f x («expr ⁻¹' » f {x}) :=\n  let ⟨h1, h2⟩ := h\n  ⟨((Classical.choose h2).preimage_singleton_homeomorph (Classical.choose_spec h2)).embedding.discrete_topology, _,\n    h.mem_to_trivialization_base_set⟩\n#align to_is_evenly_covered_preimage to_is_evenly_covered_preimage\n\n",
 "mk":
 "theorem mk (F : X → Type _) [∀ x, TopologicalSpace (F x)] [hF : ∀ x, DiscreteTopology (F x)]\n    (e : ∀ x, Trivialization (F x) f) (h : ∀ x, x ∈ (e x).base_set) : IsCoveringMap f :=\n  isCoveringMap_iff_isCoveringMapOn_univ.mpr (IsCoveringMapOn.mk f Set.univ F (fun x hx => e x) fun x hx => h x)\n#align mk mk\n\n",
 "mem_to_trivialization_base_set":
 "/-\nCopyright (c) 2022 Thomas Browning. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Thomas Browning\n-/\ntheorem mem_to_trivialization_base_set {x : X} {I : Type _} [TopologicalSpace I] (h : IsEvenlyCovered f x I) :\n    x ∈ h.to_trivialization.base_set :=\n  Classical.choose_spec h.2\n#align mem_to_trivialization_base_set mem_to_trivialization_base_set\n\n",
 "isCoveringMap_iff_isCoveringMapOn_univ":
 "#print isCoveringMap_iff_isCoveringMapOn_univ /-\ntheorem isCoveringMap_iff_isCoveringMapOn_univ : IsCoveringMap f ↔ IsCoveringMapOn f Set.univ := by\n  simp only [IsCoveringMap, IsCoveringMapOn, Set.mem_univ, forall_true_left]\n#align is_covering_map_iff_is_covering_map_on_univ isCoveringMap_iff_isCoveringMapOn_univ\n-/\n\n",
 "isCoveringMapOn":
 "#print IsCoveringMap.isCoveringMapOn /-\nprotected theorem IsCoveringMap.isCoveringMapOn (hf : IsCoveringMap f) : IsCoveringMapOn f Set.univ :=\n  isCoveringMap_iff_isCoveringMapOn_univ.mp hf\n#align is_covering_map.is_covering_map_on IsCoveringMap.isCoveringMapOn\n-/\n\n",
 "isCoveringMap":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprπ -/\n#print FiberBundle.isCoveringMap /-\nprotected theorem FiberBundle.isCoveringMap {F : Type _} {E : X → Type _} [TopologicalSpace F] [DiscreteTopology F]\n    [TopologicalSpace (Bundle.TotalSpace E)] [∀ x, TopologicalSpace (E x)] [hf : FiberBundle F E] :\n    IsCoveringMap ((exprπ) E) :=\n  IsFiberBundle.isCoveringMap fun x => ⟨trivialization_at F E x, mem_base_set_trivialization_at F E x⟩\n#align fiber_bundle.is_covering_map FiberBundle.isCoveringMap\n-/\n\n",
 "QuotientMap":
 "#print QuotientMap /-\nprotected theorem QuotientMap (hf : IsCoveringMap f) (hf' : function.surjective f) : QuotientMap f :=\n  hf.is_open_map.to_quotient_map hf.continuous hf'\n#align quotient_map QuotientMap\n-/\n\n",
 "IsOpenMap":
 "#print IsOpenMap /-\nprotected theorem IsOpenMap (hf : IsCoveringMap f) : IsOpenMap f :=\n  hf.is_locally_homeomorph.is_open_map\n#align is_open_map IsOpenMap\n-/\n\n",
 "IsLocallyHomeomorphOn":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n#print IsLocallyHomeomorphOn /-\nprotected theorem IsLocallyHomeomorphOn (hf : IsCoveringMapOn f s) : IsLocallyHomeomorphOn f («expr ⁻¹' » f s) :=\n  by\n  refine' IsLocallyHomeomorphOn.mk f («expr ⁻¹' » f s) fun x hx => _\n  let e := (hf (f x) hx).to_trivialization\n  have h := (hf (f x) hx).mem_to_trivialization_base_set\n  let he := e.mem_source.2 h\n  refine'\n    ⟨e.to_local_homeomorph.trans\n        { to_fun := fun p => p.1\n          inv_fun := fun p => ⟨p, x, rfl⟩\n          source := lower_set.prod e.base_set ({⟨x, rfl⟩} : Set («expr ⁻¹' » f {f x}))\n          target := e.base_set\n          open_source := e.open_base_set.prod (singletons_open_iff_discrete.2 (hf (f x) hx).1 ⟨x, rfl⟩)\n          open_target := e.open_base_set\n          map_source' := fun p => And.left\n          map_target' := fun p hp => ⟨hp, rfl⟩\n          left_inv' := fun p hp => Prod.ext rfl hp.2.symm\n          right_inv' := fun p hp => rfl\n          continuous_to_fun := continuous_fst.continuous_on\n          continuous_inv_fun := (continuous_id'.prod_mk continuous_const).continuous_on },\n      ⟨he, by rwa [e.to_local_homeomorph.symm_symm, e.proj_to_fun x he], (hf (f x) hx).to_trivialization_apply⟩,\n      fun p h => (e.proj_to_fun p h.1).symm⟩\n#align is_locally_homeomorph_on IsLocallyHomeomorphOn\n-/\n\n",
 "IsLocallyHomeomorph":
 "#print IsLocallyHomeomorph /-\nprotected theorem IsLocallyHomeomorph (hf : IsCoveringMap f) : IsLocallyHomeomorph f :=\n  isLocallyHomeomorph_iff_isLocallyHomeomorphOn_univ.mpr hf.is_covering_map_on.is_locally_homeomorph_on\n#align is_locally_homeomorph IsLocallyHomeomorph\n-/\n\n",
 "ContinuousOn":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n#print ContinuousOn /-\nprotected theorem ContinuousOn (hf : IsCoveringMapOn f s) : ContinuousOn f («expr ⁻¹' » f s) :=\n  ContinuousAt.continuousOn fun x => hf.continuous_at\n#align continuous_on ContinuousOn\n-/\n\n",
 "ContinuousAt":
 "#print ContinuousAt /-\nprotected theorem ContinuousAt (hf : IsCoveringMapOn f s) {x : E} (hx : f x ∈ s) : ContinuousAt f x :=\n  (hf (f x) hx).continuous_at\n#align continuous_at ContinuousAt\n-/\n\n",
 "Continuous":
 "#print Continuous /-\nprotected theorem Continuous (hf : IsCoveringMap f) : Continuous f :=\n  continuous_iff_continuousOn_univ.mpr hf.is_covering_map_on.continuous_on\n#align continuous Continuous\n-/\n\n"}