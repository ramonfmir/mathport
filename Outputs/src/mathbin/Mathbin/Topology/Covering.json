{"to_trivialization_apply":
 "theorem to_trivialization_apply {x : E} {I : Type _} [topological_space I] (h : is_evenly_covered f (f x) I) :\n    (h.to_trivialization x).2 = ⟨x, rfl⟩ :=\n  let e := Classical.choose h.2\n  let h := Classical.choose_spec h.2\n  let he := e.mk_proj_snd' h\n  subtype.ext\n    ((e.to_local_equiv.eq_symm_apply (e.mem_source.mpr h)\n            (by rwa [he, e.mem_target, e.coe_fst (e.mem_source.mpr h)])).mpr\n        he.symm).symm\n#align to_trivialization_apply to_trivialization_apply\n\n",
 "to_is_evenly_covered_preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem to_is_evenly_covered_preimage {x : X} {I : Type _} [topological_space I] (h : is_evenly_covered f x I) :\n    is_evenly_covered f x («expr ⁻¹' » f {x}) :=\n  let ⟨h1, h2⟩ := h\n  ⟨((Classical.choose h2).preimage_singleton_homeomorph (Classical.choose_spec h2)).embedding.discrete_topology, _,\n    h.mem_to_trivialization_base_set⟩\n#align to_is_evenly_covered_preimage to_is_evenly_covered_preimage\n\n",
 "quotient_map":
 "protected theorem quotient_map (hf : is_covering_map f) (hf' : function.surjective f) : quotient_map f :=\n  hf.is_open_map.to_quotient_map hf.continuous hf'\n#align quotient_map quotient_map\n\n",
 "mk":
 "theorem mk (F : X → Type _) [∀ x, topological_space (F x)] [hF : ∀ x, discrete_topology (F x)]\n    (e : ∀ x, trivialization (F x) f) (h : ∀ x, x ∈ (e x).base_set) : is_covering_map f :=\n  is_covering_map_iff_is_covering_map_on_univ.mpr (is_covering_map_on.mk f Set.univ F (fun x hx => e x) fun x hx => h x)\n#align mk mk\n\n",
 "mem_to_trivialization_base_set":
 "/-\nCopyright (c) 2022 Thomas Browning. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Thomas Browning\n-/\ntheorem mem_to_trivialization_base_set {x : X} {I : Type _} [topological_space I] (h : is_evenly_covered f x I) :\n    x ∈ h.to_trivialization.base_set :=\n  Classical.choose_spec h.2\n#align mem_to_trivialization_base_set mem_to_trivialization_base_set\n\n",
 "is_open_map":
 "protected theorem is_open_map (hf : is_covering_map f) : is_open_map f :=\n  hf.is_locally_homeomorph.is_open_map\n#align is_open_map is_open_map\n\n",
 "is_locally_homeomorph_on":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\nprotected theorem is_locally_homeomorph_on (hf : is_covering_map_on f s) :\n    is_locally_homeomorph_on f («expr ⁻¹' » f s) :=\n  by\n  refine' is_locally_homeomorph_on.mk f («expr ⁻¹' » f s) fun x hx => _\n  let e := (hf (f x) hx).to_trivialization\n  have h := (hf (f x) hx).mem_to_trivialization_base_set\n  let he := e.mem_source.2 h\n  refine'\n    ⟨e.to_local_homeomorph.trans\n        { to_fun := fun p => p.1\n          inv_fun := fun p => ⟨p, x, rfl⟩\n          source := lower_set.prod e.base_set ({⟨x, rfl⟩} : set («expr ⁻¹' » f {f x}))\n          target := e.base_set\n          open_source := e.open_base_set.prod (singletons_open_iff_discrete.2 (hf (f x) hx).1 ⟨x, rfl⟩)\n          open_target := e.open_base_set\n          map_source' := fun p => And.left\n          map_target' := fun p hp => ⟨hp, rfl⟩\n          left_inv' := fun p hp => Prod.ext rfl hp.2.symm\n          right_inv' := fun p hp => rfl\n          continuous_to_fun := continuous_fst.continuous_on\n          continuous_inv_fun := (continuous_id'.prod_mk continuous_const).continuous_on },\n      ⟨he, by rwa [e.to_local_homeomorph.symm_symm, e.proj_to_fun x he], (hf (f x) hx).to_trivialization_apply⟩,\n      fun p h => (e.proj_to_fun p h.1).symm⟩\n#align is_locally_homeomorph_on is_locally_homeomorph_on\n\n",
 "is_locally_homeomorph":
 "protected theorem is_locally_homeomorph (hf : is_covering_map f) : is_locally_homeomorph f :=\n  is_locally_homeomorph_iff_is_locally_homeomorph_on_univ.mpr hf.is_covering_map_on.is_locally_homeomorph_on\n#align is_locally_homeomorph is_locally_homeomorph\n\n",
 "is_covering_map_on":
 "protected theorem is_covering_map.is_covering_map_on (hf : is_covering_map f) : is_covering_map_on f Set.univ :=\n  is_covering_map_iff_is_covering_map_on_univ.mp hf\n#align is_covering_map.is_covering_map_on is_covering_map.is_covering_map_on\n\n",
 "is_covering_map_iff_is_covering_map_on_univ":
 "theorem is_covering_map_iff_is_covering_map_on_univ : is_covering_map f ↔ is_covering_map_on f Set.univ := by\n  simp only [is_covering_map, is_covering_map_on, Set.mem_univ, forall_true_left]\n#align is_covering_map_iff_is_covering_map_on_univ is_covering_map_iff_is_covering_map_on_univ\n\n",
 "is_covering_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprπ -/\nprotected theorem fiber_bundle.is_covering_map {F : Type _} {E : X → Type _} [topological_space F] [discrete_topology F]\n    [topological_space (Bundle.TotalSpace E)] [∀ x, topological_space (E x)] [hf : fiber_bundle F E] :\n    is_covering_map ((exprπ) E) :=\n  is_fiber_bundle.is_covering_map fun x => ⟨trivialization_at F E x, mem_base_set_trivialization_at F E x⟩\n#align fiber_bundle.is_covering_map fiber_bundle.is_covering_map\n\n",
 "continuous_on":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\nprotected theorem continuous_on (hf : is_covering_map_on f s) : continuous_on f («expr ⁻¹' » f s) :=\n  continuous_at.continuous_on fun x => hf.continuous_at\n#align continuous_on continuous_on\n\n",
 "continuous_at":
 "protected theorem continuous_at (hf : is_covering_map_on f s) {x : E} (hx : f x ∈ s) : continuous_at f x :=\n  (hf (f x) hx).continuous_at\n#align continuous_at continuous_at\n\n",
 "continuous":
 "protected theorem continuous (hf : is_covering_map f) : continuous f :=\n  continuous_iff_continuous_on_univ.mpr hf.is_covering_map_on.continuous_on\n#align continuous continuous\n\n"}