{"tendsto_remove_nth":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `sym.cons' -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `sym.cons' -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem tendsto_remove_nth :\n    ∀ {n : ℕ} {l : list α}, tendsto (fun l => remove_nth l n) ((nhds) l) ((nhds) (remove_nth l n))\n  | _, [] => by rw [nhds_nil] <;> exact tendsto_pure_nhds _ _\n  | 0, sym.cons' a l => by rw [tendsto_cons_iff] <;> exact tendsto_snd\n  | n + 1, sym.cons' a l => by\n    rw [tendsto_cons_iff]\n    dsimp [remove_nth]\n    exact tendsto_fst.cons ((@tendsto_remove_nth n l).comp tendsto_snd)\n#align tendsto_remove_nth tendsto_remove_nth\n\n",
 "tendsto_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n@[to_additive]\ntheorem tendsto_prod [monoid α] [has_continuous_mul α] {l : list α} : tendsto List.prod ((nhds) l) ((nhds) l.prod) :=\n  by\n  induction' l with x l ih\n  · simp (config := { contextual := true }) [nhds_nil, mem_of_mem_nhds, tendsto_pure_left]\n  simp_rw [tendsto_cons_iff, prod_cons]\n  have := continuous_iff_continuous_at.mp continuous_mul (x, l.prod)\n  rw [continuous_at, nhds_prod_eq] at this\n  exact this.comp (tendsto_id.prod_map ih)\n#align tendsto_prod tendsto_prod\n\n",
 "tendsto_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `sym.cons' -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `sym.cons' -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `sym.cons' -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem tendsto_nhds {β : Type _} {f : list α → β} {r : list α → _root_.filter β} (h_nil : tendsto f (pure []) (r []))\n    (h_cons :\n      ∀ l a,\n        tendsto f ((nhds) l) (r l) →\n          tendsto (fun p : α × list α => f (sym.cons' p.1 p.2)) (filter.prod ((nhds) a) ((nhds) l))\n            (r (sym.cons' a l))) :\n    ∀ l, tendsto f ((nhds) l) (r l)\n  | [] => by rwa [nhds_nil]\n  | sym.cons' a l => by rw [tendsto_cons_iff] <;> exact h_cons l a (tendsto_nhds l)\n#align tendsto_nhds tendsto_nhds\n\n",
 "tendsto_insert_nth'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `sym.cons' -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `sym.cons' -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `sym.cons' -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem tendsto_insert_nth' {a : α} :\n    ∀ {n : ℕ} {l : list α},\n      tendsto (fun p : α × list α => insertNth n p.1 p.2) (filter.prod ((nhds) a) ((nhds) l)) ((nhds) (insertNth n a l))\n  | 0, l => tendsto_cons\n  | n + 1, [] => by simp\n  | n + 1, sym.cons' a' l =>\n    by\n    have :\n      filter.prod ((nhds) a) ((nhds) (sym.cons' a' l)) =\n        (filter.prod ((nhds) a) (filter.prod ((nhds) a') ((nhds) l))).map fun p : α × α × list α =>\n          (p.1, sym.cons' p.2.1 p.2.2) :=\n      by\n      simp only [nhds_cons, filter.prod_eq, ← filter.map_def, ← filter.seq_eq_filter_seq]\n      simp [-filter.seq_eq_filter_seq, -filter.map_def, (· ∘ ·), functor_norm]\n    rw [this, tendsto_map'_iff]\n    exact\n      (tendsto_fst.comp tendsto_snd).cons\n        ((@tendsto_insert_nth' n l).comp <| tendsto_fst.prod_mk <| tendsto_snd.comp tendsto_snd)\n#align tendsto_insert_nth' tendsto_insert_nth'\n\n",
 "tendsto_insert_nth":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem tendsto_insert_nth {n : ℕ} {i : fin (n + 1)} {a : α} :\n    ∀ {l : Vector α n},\n      tendsto (fun p : α × Vector α n => insert_nth p.1 i p.2) (filter.prod ((nhds) a) ((nhds) l))\n        ((nhds) (insert_nth a i l))\n  | ⟨l, hl⟩ => by\n    rw [insert_nth, tendsto_subtype_rng]\n    simp [insert_nth_val]\n    exact list.tendsto_insert_nth tendsto_fst (tendsto.comp continuous_at_subtype_coe tendsto_snd : _)\n#align tendsto_insert_nth tendsto_insert_nth\n\n",
 "tendsto_cons_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `sym.cons' -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `sym.cons' -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `sym.cons' -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `sym.cons' -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem tendsto_cons_iff {β : Type _} {f : list α → β} {b : _root_.filter β} {a : α} {l : list α} :\n    tendsto f ((nhds) (sym.cons' a l)) b ↔\n      tendsto (fun p : α × list α => f (sym.cons' p.1 p.2)) (filter.prod ((nhds) a) ((nhds) l)) b :=\n  by\n  have : (nhds) (sym.cons' a l) = (filter.prod ((nhds) a) ((nhds) l)).map fun p : α × list α => sym.cons' p.1 p.2 :=\n    by\n    simp only [nhds_cons, filter.prod_eq, (filter.map_def _ _).symm, (filter.seq_eq_filter_seq _ _).symm]\n    simp [-filter.seq_eq_filter_seq, -filter.map_def, (· ∘ ·), functor_norm]\n  rw [this, filter.tendsto_map'_iff]\n#align tendsto_cons_iff tendsto_cons_iff\n\n",
 "tendsto_cons":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ᵥ » -/\ntheorem tendsto_cons {n : ℕ} {a : α} {l : Vector α n} :\n    tendsto (fun p : α × Vector α n => «expr ::ᵥ » p.1 p.2) (filter.prod ((nhds) a) ((nhds) l))\n      ((nhds) («expr ::ᵥ » a l)) :=\n  by\n  simp [tendsto_subtype_rng, ← subtype.val_eq_coe, cons_val]\n  exact tendsto_fst.cons (tendsto.comp continuous_at_subtype_coe tendsto_snd)\n#align tendsto_cons tendsto_cons\n\n",
 "nhds_nil":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n@[simp]\ntheorem nhds_nil : (nhds) ([] : list α) = pure [] := by rw [nhds_list, list.traverse_nil _] <;> infer_instance\n#align nhds_nil nhds_nil\n\n",
 "nhds_list":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `sym.cons' -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-\nCopyright (c) 2019 Reid Barton. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johannes Hölzl\n-/\ntheorem nhds_list (as : list α) : (nhds) as = traverse (nhds) as :=\n  by\n  refine' nhds_mk_of_nhds _ _ _ _\n  · intro l\n    induction l\n    case nil => exact le_rfl\n    case\n      cons a l ih =>\n      suffices list.cons <$> pure a <*> pure l ≤ list.cons <$> (nhds) a <*> traverse (nhds) l by\n        simpa only [functor_norm] using this\n      exact filter.seq_mono (filter.map_mono <| pure_le_nhds a) ih\n  · intro l s hs\n    rcases(mem_traverse_iff _ _).1 hs with ⟨u, hu, hus⟩\n    clear as hs\n    have : ∃ v : list (set α), l.forall₂ (fun a s => is_open s ∧ a ∈ s) v ∧ sequence v ⊆ s :=\n      by\n      induction hu generalizing s\n      case nil hs this => exists ; simpa only [List.forall₂_nil_left_iff, exists_eq_left]\n      case cons a s as ss ht h ih t hts =>\n        rcases mem_nhds_iff.1 ht with ⟨u, hut, hu⟩\n        rcases ih (subset.refl _) with ⟨v, hv, hvss⟩\n        exact ⟨sym.cons' u v, List.Forall₂.cons hu hv, subset.trans (Set.seq_mono (Set.image_subset _ hut) hvss) hts⟩\n    rcases this with ⟨v, hv, hvs⟩\n    refine' ⟨sequence v, mem_traverse _ _ _, hvs, _⟩\n    · exact hv.imp fun a s ⟨hs, ha⟩ => is_open.mem_nhds hs ha\n    · intro u hu\n      have hu := (list.mem_traverse _ _).1 hu\n      have : List.Forall₂ (fun a s => is_open s ∧ a ∈ s) u v :=\n        by\n        refine' List.Forall₂.flip _\n        replace hv := hv.flip\n        simp only [List.forall₂_and_left, flip] at hv⊢\n        exact ⟨hv.1, hu.flip⟩\n      refine' mem_of_superset _ hvs\n      exact mem_traverse _ _ (this.imp fun a s ⟨hs, ha⟩ => is_open.mem_nhds hs ha)\n#align nhds_list nhds_list\n\n",
 "nhds_cons":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `sym.cons' -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem nhds_cons (a : α) (l : list α) : (nhds) (sym.cons' a l) = list.cons <$> (nhds) a <*> (nhds) l := by\n  rw [nhds_list, list.traverse_cons _, ← nhds_list] <;> infer_instance\n#align nhds_cons nhds_cons\n\n",
 "continuous_remove_nth":
 "theorem continuous_remove_nth {n : ℕ} {i : fin (n + 1)} : continuous (removeNth i : Vector α (n + 1) → Vector α n) :=\n  continuous_iff_continuous_at.mpr fun ⟨a, l⟩ => continuous_at_remove_nth\n#align continuous_remove_nth continuous_remove_nth\n\n",
 "continuous_prod":
 "@[to_additive]\ntheorem continuous_prod [monoid α] [has_continuous_mul α] : continuous (prod : list α → α) :=\n  continuous_iff_continuous_at.mpr fun l => tendsto_prod\n#align continuous_prod continuous_prod\n\n",
 "continuous_insert_nth'":
 "theorem continuous_insert_nth' {n : ℕ} {i : fin (n + 1)} : continuous fun p : α × Vector α n => insert_nth p.1 i p.2 :=\n  continuous_iff_continuous_at.mpr fun ⟨a, l⟩ => by rw [continuous_at, nhds_prod_eq] <;> exact tendsto_insert_nth\n#align continuous_insert_nth' continuous_insert_nth'\n\n",
 "continuous_insert_nth":
 "theorem continuous_insert_nth {n : ℕ} {i : fin (n + 1)} {f : β → α} {g : β → Vector α n} (hf : continuous f)\n    (hg : continuous g) : continuous fun b => insert_nth (f b) i (g b) :=\n  continuous_insert_nth'.comp (hf.prod_mk hg : _)\n#align continuous_insert_nth continuous_insert_nth\n\n",
 "continuous_cons":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `sym.cons' -/\ntheorem continuous_cons : continuous fun x : α × list α => (sym.cons' x.1 x.2 : list α) :=\n  continuous_iff_continuous_at.mpr fun ⟨x, y⟩ => continuous_at_fst.cons continuous_at_snd\n#align continuous_cons continuous_cons\n\n",
 "continuous_at_remove_nth":
 "theorem continuous_at_remove_nth {n : ℕ} {i : fin (n + 1)} : ∀ {l : Vector α (n + 1)}, continuous_at (removeNth i) l\n  | ⟨l, hl⟩ =>--  ∀{l:vector α (n+1)}, tendsto (remove_nth i) (𝓝 l) (𝓝 (remove_nth i l))\n  --| ⟨l, hl⟩ :=\n  by\n    rw [continuous_at, remove_nth, tendsto_subtype_rng]\n    simp only [← subtype.val_eq_coe, vector.remove_nth_val]\n    exact tendsto.comp list.tendsto_remove_nth continuous_at_subtype_coe\n#align continuous_at_remove_nth continuous_at_remove_nth\n\n",
 "continuous_at_length":
 "theorem continuous_at_length : ∀ l : list α, continuous_at list.length l :=\n  by\n  simp only [continuous_at, nhds_discrete]\n  refine' tendsto_nhds _ _\n  · exact tendsto_pure_pure _ _\n  · intro l a ih\n    dsimp only [list.length]\n    refine' tendsto.comp (tendsto_pure_pure (fun x => x + 1) _) _\n    refine' tendsto.comp ih tendsto_snd\n#align continuous_at_length continuous_at_length\n\n",
 "cons":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `sym.cons' -/\ntheorem filter.tendsto.cons {α : Type _} {f : α → β} {g : α → list β} {a : _root_.filter α} {b : β} {l : list β}\n    (hf : tendsto f a ((nhds) b)) (hg : tendsto g a ((nhds) l)) :\n    tendsto (fun a => list.cons (f a) (g a)) a ((nhds) (sym.cons' b l)) :=\n  list.tendsto_cons.comp (tendsto.prod_mk hf hg)\n#align filter.tendsto.cons filter.tendsto.cons\n\n"}