{"tendsto_remove_nth":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `sym.cons' -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `sym.cons' -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem tendsto_remove_nth :\n    ∀ {n : ℕ} {l : List α}, Tendsto (fun l => remove_nth l n) ((nhds) l) ((nhds) (remove_nth l n))\n  | _, [] => by rw [nhds_nil] <;> exact tendsto_pure_nhds _ _\n  | 0, sym.cons' a l => by rw [tendsto_cons_iff] <;> exact tendsto_snd\n  | n + 1, sym.cons' a l => by\n    rw [tendsto_cons_iff]\n    dsimp [remove_nth]\n    exact tendsto_fst.cons ((@tendsto_remove_nth n l).comp tendsto_snd)\n#align tendsto_remove_nth tendsto_remove_nth\n\n",
 "tendsto_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n@[to_additive]\ntheorem tendsto_prod [Monoid α] [ContinuousMul α] {l : List α} : Tendsto List.prod ((nhds) l) ((nhds) l.prod) :=\n  by\n  induction' l with x l ih\n  · simp (config := { contextual := true }) [nhds_nil, mem_of_mem_nhds, tendsto_pure_left]\n  simp_rw [tendsto_cons_iff, prod_cons]\n  have := continuous_iff_continuous_at.mp continuous_mul (x, l.prod)\n  rw [ContinuousAt, nhds_prod_eq] at this\n  exact this.comp (tendsto_id.prod_map ih)\n#align tendsto_prod tendsto_prod\n\n",
 "tendsto_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `sym.cons' -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `sym.cons' -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `sym.cons' -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print tendsto_nhds /-\ntheorem tendsto_nhds {β : Type _} {f : List α → β} {r : List α → Filter β} (h_nil : Tendsto f (pure []) (r []))\n    (h_cons :\n      ∀ l a,\n        Tendsto f ((nhds) l) (r l) →\n          Tendsto (fun p : α × List α => f (sym.cons' p.1 p.2)) (filter.prod ((nhds) a) ((nhds) l))\n            (r (sym.cons' a l))) :\n    ∀ l, Tendsto f ((nhds) l) (r l)\n  | [] => by rwa [nhds_nil]\n  | sym.cons' a l => by rw [tendsto_cons_iff] <;> exact h_cons l a (tendsto_nhds l)\n#align tendsto_nhds tendsto_nhds\n-/\n\n",
 "tendsto_insert_nth'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `sym.cons' -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `sym.cons' -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `sym.cons' -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem tendsto_insert_nth' {a : α} :\n    ∀ {n : ℕ} {l : List α},\n      Tendsto (fun p : α × List α => insertNth n p.1 p.2) (filter.prod ((nhds) a) ((nhds) l)) ((nhds) (insertNth n a l))\n  | 0, l => tendsto_cons\n  | n + 1, [] => by simp\n  | n + 1, sym.cons' a' l =>\n    by\n    have :\n      filter.prod ((nhds) a) ((nhds) (sym.cons' a' l)) =\n        (filter.prod ((nhds) a) (filter.prod ((nhds) a') ((nhds) l))).map fun p : α × α × List α =>\n          (p.1, sym.cons' p.2.1 p.2.2) :=\n      by\n      simp only [nhds_cons, Filter.prod_eq, ← Filter.map_def, ← Filter.seq_eq_filter_seq]\n      simp [-Filter.seq_eq_filter_seq, -Filter.map_def, (· ∘ ·), functor_norm]\n    rw [this, tendsto_map'_iff]\n    exact\n      (tendsto_fst.comp tendsto_snd).cons\n        ((@tendsto_insert_nth' n l).comp <| tendsto_fst.prod_mk <| tendsto_snd.comp tendsto_snd)\n#align tendsto_insert_nth' tendsto_insert_nth'\n\n",
 "tendsto_insert_nth":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem tendsto_insert_nth {n : ℕ} {i : Fin (n + 1)} {a : α} :\n    ∀ {l : Vector α n},\n      Tendsto (fun p : α × Vector α n => insertNth p.1 i p.2) (filter.prod ((nhds) a) ((nhds) l))\n        ((nhds) (insertNth a i l))\n  | ⟨l, hl⟩ => by\n    rw [insert_nth, tendsto_subtype_rng]\n    simp [insert_nth_val]\n    exact List.tendsto_insertNth tendsto_fst (tendsto.comp continuousAt_subtype_val tendsto_snd : _)\n#align tendsto_insert_nth tendsto_insert_nth\n\n",
 "tendsto_cons_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `sym.cons' -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `sym.cons' -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `sym.cons' -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `sym.cons' -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem tendsto_cons_iff {β : Type _} {f : List α → β} {b : Filter β} {a : α} {l : List α} :\n    Tendsto f ((nhds) (sym.cons' a l)) b ↔\n      Tendsto (fun p : α × List α => f (sym.cons' p.1 p.2)) (filter.prod ((nhds) a) ((nhds) l)) b :=\n  by\n  have : (nhds) (sym.cons' a l) = (filter.prod ((nhds) a) ((nhds) l)).map fun p : α × List α => sym.cons' p.1 p.2 :=\n    by\n    simp only [nhds_cons, Filter.prod_eq, (Filter.map_def _ _).symm, (Filter.seq_eq_filter_seq _ _).symm]\n    simp [-Filter.seq_eq_filter_seq, -Filter.map_def, (· ∘ ·), functor_norm]\n  rw [this, Filter.tendsto_map'_iff]\n#align tendsto_cons_iff tendsto_cons_iff\n\n",
 "tendsto_cons":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ᵥ » -/\ntheorem tendsto_cons {n : ℕ} {a : α} {l : Vector α n} :\n    Tendsto (fun p : α × Vector α n => «expr ::ᵥ » p.1 p.2) (filter.prod ((nhds) a) ((nhds) l))\n      ((nhds) («expr ::ᵥ » a l)) :=\n  by\n  simp [tendsto_subtype_rng, ← subtype.val_eq_coe, cons_val]\n  exact tendsto_fst.cons (tendsto.comp continuousAt_subtype_val tendsto_snd)\n#align tendsto_cons tendsto_cons\n\n",
 "nhds_nil":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print nhds_nil /-\n@[simp]\ntheorem nhds_nil : (nhds) ([] : List α) = pure [] := by rw [nhds_list, List.traverse_nil _] <;> infer_instance\n#align nhds_nil nhds_nil\n-/\n\n",
 "nhds_list":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `sym.cons' -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print nhds_list /-\n/-\nCopyright (c) 2019 Reid Barton. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johannes Hölzl\n-/\ntheorem nhds_list (as : List α) : (nhds) as = traverse (nhds) as :=\n  by\n  refine' nhds_mk_of_nhds _ _ _ _\n  · intro l\n    induction l\n    case nil => exact le_rfl\n    case\n      cons a l ih =>\n      suffices List.cons <$> pure a <*> pure l ≤ List.cons <$> (nhds) a <*> traverse (nhds) l by\n        simpa only [functor_norm] using this\n      exact Filter.seq_mono (Filter.map_mono <| pure_le_nhds a) ih\n  · intro l s hs\n    rcases(mem_traverse_iff _ _).1 hs with ⟨u, hu, hus⟩\n    clear as hs\n    have : ∃ v : List (Set α), l.forall₂ (fun a s => IsOpen s ∧ a ∈ s) v ∧ sequence v ⊆ s :=\n      by\n      induction hu generalizing s\n      case nil hs this => exists ; simpa only [List.forall₂_nil_left_iff, exists_eq_left]\n      case cons a s as ss ht h ih t hts =>\n        rcases mem_nhds_iff.1 ht with ⟨u, hut, hu⟩\n        rcases ih _ subset.rfl with ⟨v, hv, hvss⟩\n        exact ⟨sym.cons' u v, List.Forall₂.cons hu hv, subset.trans (Set.seq_mono (Set.image_subset _ hut) hvss) hts⟩\n    rcases this with ⟨v, hv, hvs⟩\n    refine' ⟨sequence v, mem_traverse _ _ _, hvs, _⟩\n    · exact hv.imp fun a s ⟨hs, ha⟩ => IsOpen.mem_nhds hs ha\n    · intro u hu\n      have hu := (List.mem_traverse _ _).1 hu\n      have : List.Forall₂ (fun a s => IsOpen s ∧ a ∈ s) u v :=\n        by\n        refine' List.Forall₂.flip _\n        replace hv := hv.flip\n        simp only [List.forall₂_and_left, flip] at hv⊢\n        exact ⟨hv.1, hu.flip⟩\n      refine' mem_of_superset _ hvs\n      exact mem_traverse _ _ (this.imp fun a s ⟨hs, ha⟩ => IsOpen.mem_nhds hs ha)\n#align nhds_list nhds_list\n-/\n\n",
 "nhds_cons":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `sym.cons' -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print nhds_cons /-\ntheorem nhds_cons (a : α) (l : List α) : (nhds) (sym.cons' a l) = List.cons <$> (nhds) a <*> (nhds) l := by\n  rw [nhds_list, List.traverse_cons _, ← nhds_list] <;> infer_instance\n#align nhds_cons nhds_cons\n-/\n\n",
 "continuous_remove_nth":
 "theorem continuous_remove_nth {n : ℕ} {i : Fin (n + 1)} : Continuous (removeNth i : Vector α (n + 1) → Vector α n) :=\n  continuous_iff_continuousAt.mpr fun ⟨a, l⟩ => continuousAt_removeNth\n#align continuous_remove_nth continuous_remove_nth\n\n",
 "continuous_prod":
 "@[to_additive]\ntheorem continuous_prod [Monoid α] [ContinuousMul α] : Continuous (prod : List α → α) :=\n  continuous_iff_continuousAt.mpr fun l => tendsto_prod\n#align continuous_prod continuous_prod\n\n",
 "continuous_insert_nth'":
 "theorem continuous_insert_nth' {n : ℕ} {i : Fin (n + 1)} : Continuous fun p : α × Vector α n => insertNth p.1 i p.2 :=\n  continuous_iff_continuousAt.mpr fun ⟨a, l⟩ => by rw [ContinuousAt, nhds_prod_eq] <;> exact tendsto_insert_nth\n#align continuous_insert_nth' continuous_insert_nth'\n\n",
 "continuous_insert_nth":
 "theorem continuous_insert_nth {n : ℕ} {i : Fin (n + 1)} {f : β → α} {g : β → Vector α n} (hf : Continuous f)\n    (hg : Continuous g) : Continuous fun b => insertNth (f b) i (g b) :=\n  continuous_insertNth'.comp (hf.prod_mk hg : _)\n#align continuous_insert_nth continuous_insert_nth\n\n",
 "continuous_cons":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `sym.cons' -/\ntheorem continuous_cons : Continuous fun x : α × List α => (sym.cons' x.1 x.2 : List α) :=\n  continuous_iff_continuousAt.mpr fun ⟨x, y⟩ => continuousAt_fst.cons continuousAt_snd\n#align continuous_cons continuous_cons\n\n",
 "continuous_at_remove_nth":
 "theorem continuous_at_remove_nth {n : ℕ} {i : Fin (n + 1)} : ∀ {l : Vector α (n + 1)}, ContinuousAt (removeNth i) l\n  | ⟨l, hl⟩ =>--  ∀{l:vector α (n+1)}, tendsto (remove_nth i) (𝓝 l) (𝓝 (remove_nth i l))\n  --| ⟨l, hl⟩ :=\n  by\n    rw [ContinuousAt, remove_nth, tendsto_subtype_rng]\n    simp only [← subtype.val_eq_coe, Vector.removeNth_val]\n    exact tendsto.comp List.tendsto_removeNth continuousAt_subtype_val\n#align continuous_at_remove_nth continuous_at_remove_nth\n\n",
 "continuous_at_length":
 "theorem continuous_at_length : ∀ l : List α, ContinuousAt list.length l :=\n  by\n  simp only [ContinuousAt, nhds_discrete]\n  refine' tendsto_nhds _ _\n  · exact tendsto_pure_pure _ _\n  · intro l a ih\n    dsimp only [list.length]\n    refine' tendsto.comp (tendsto_pure_pure (fun x => x + 1) _) _\n    refine' tendsto.comp ih tendsto_snd\n#align continuous_at_length continuous_at_length\n\n",
 "cons":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `sym.cons' -/\n#print Filter.Tendsto.cons /-\ntheorem Filter.Tendsto.cons {α : Type _} {f : α → β} {g : α → List β} {a : Filter α} {b : β} {l : List β}\n    (hf : Tendsto f a ((nhds) b)) (hg : Tendsto g a ((nhds) l)) :\n    Tendsto (fun a => List.cons (f a) (g a)) a ((nhds) (sym.cons' b l)) :=\n  List.tendsto_cons.comp (Tendsto.prod_mk hf hg)\n#align filter.tendsto.cons Filter.Tendsto.cons\n-/\n\n"}