{"to_quotient_map":
 "/-- A continuous surjective open map is a quotient map. -/\ntheorem to_quotient_map {f : α → β} (open_map : is_open_map f) (cont : continuous f) (surj : surjective f) :\n    quotient_map f :=\n  quotient_map_iff.2 ⟨surj, fun s => ⟨fun h => h.preimage cont, fun h => surj.image_preimage s ▸ open_map _ h⟩⟩\n#align to_quotient_map to_quotient_map\n\n",
 "tendsto_nhds_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem closed_embedding.tendsto_nhds_iff {ι : Type _} {g : ι → α} {a : filter ι} {b : α} (hf : closed_embedding f) :\n    tendsto g a ((nhds) b) ↔ tendsto (f ∘ g) a ((nhds) (f b)) :=\n  hf.to_embedding.tendsto_nhds_iff\n#align closed_embedding.tendsto_nhds_iff closed_embedding.tendsto_nhds_iff\n\n",
 "surjective":
 "protected theorem surjective (hf : quotient_map f) : surjective f :=\n  hf.1\n#align surjective surjective\n\n",
 "range_mem_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem range_mem_nhds (hf : is_open_map f) (x : α) : range f ∈ (nhds) (f x) :=\n  hf.is_open_range.mem_nhds <| mem_range_self _\n#align range_mem_nhds range_mem_nhds\n\n",
 "quotient_map_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem quotient_map_iff {α β : Type _} [topological_space α] [topological_space β] {f : α → β} :\n    quotient_map f ↔ surjective f ∧ ∀ s : set β, is_open s ↔ is_open («expr ⁻¹' » f s) :=\n  and_congr iff.rfl topological_space_eq_iff\n#align quotient_map_iff quotient_map_iff\n\n",
 "preimage_interior_eq_interior_preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem preimage_interior_eq_interior_preimage (hf₁ : is_open_map f) (hf₂ : continuous f) (s : set β) :\n    «expr ⁻¹' » f (interior s) = interior («expr ⁻¹' » f s) :=\n  Subset.antisymm (preimage_interior_subset_interior_preimage hf₂) (interior_preimage_subset_preimage_interior hf₁)\n#align preimage_interior_eq_interior_preimage preimage_interior_eq_interior_preimage\n\n",
 "preimage_frontier_subset_frontier_preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem preimage_frontier_subset_frontier_preimage (hf : is_open_map f) {s : set β} :\n    «expr ⁻¹' » f (frontier s) ⊆ frontier («expr ⁻¹' » f s) := by\n  simpa only [frontier_eq_closure_inter_closure, preimage_inter] using\n    inter_subset_inter hf.preimage_closure_subset_closure_preimage hf.preimage_closure_subset_closure_preimage\n#align preimage_frontier_subset_frontier_preimage preimage_frontier_subset_frontier_preimage\n\n",
 "preimage_frontier_eq_frontier_preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem preimage_frontier_eq_frontier_preimage (hf : is_open_map f) (hfc : continuous f) (s : set β) :\n    «expr ⁻¹' » f (frontier s) = frontier («expr ⁻¹' » f s) := by\n  simp only [frontier_eq_closure_inter_closure, preimage_inter, preimage_compl,\n    hf.preimage_closure_eq_closure_preimage hfc]\n#align preimage_frontier_eq_frontier_preimage preimage_frontier_eq_frontier_preimage\n\n",
 "preimage_closure_subset_closure_preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem preimage_closure_subset_closure_preimage (hf : is_open_map f) {s : set β} :\n    «expr ⁻¹' » f (closure s) ⊆ closure («expr ⁻¹' » f s) :=\n  by\n  rw [← compl_subset_compl]\n  simp only [← interior_compl, ← preimage_compl, hf.interior_preimage_subset_preimage_interior]\n#align preimage_closure_subset_closure_preimage preimage_closure_subset_closure_preimage\n\n",
 "preimage_closure_eq_closure_preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem preimage_closure_eq_closure_preimage (hf : is_open_map f) (hfc : continuous f) (s : set β) :\n    «expr ⁻¹' » f (closure s) = closure («expr ⁻¹' » f s) :=\n  hf.preimage_closure_subset_closure_preimage.antisymm (hfc.closure_preimage_subset s)\n#align preimage_closure_eq_closure_preimage preimage_closure_eq_closure_preimage\n\n",
 "open_iff_preimage_open":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem open_embedding.open_iff_preimage_open {f : α → β} (hf : open_embedding f) {s : set β} (hs : s ⊆ range f) :\n    is_open s ↔ is_open («expr ⁻¹' » f s) :=\n  by\n  convert ← hf.open_iff_image_open.symm\n  rwa [image_preimage_eq_inter_range, inter_eq_self_of_subset_left]\n#align open_embedding.open_iff_preimage_open open_embedding.open_iff_preimage_open\n\n",
 "open_iff_image_open":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem open_embedding.open_iff_image_open {f : α → β} (hf : open_embedding f) {s : set α} :\n    is_open s ↔ is_open («expr '' » f s) :=\n  ⟨hf.is_open_map s, fun h => by\n    convert ← h.preimage hf.to_embedding.continuous\n    apply preimage_image_eq _ hf.inj⟩\n#align open_embedding.open_iff_image_open open_embedding.open_iff_image_open\n\n",
 "open_embedding_of_embedding_open":
 "theorem open_embedding_of_embedding_open {f : α → β} (h₁ : embedding f) (h₂ : is_open_map f) : open_embedding f :=\n  ⟨h₁, h₂.is_open_range⟩\n#align open_embedding_of_embedding_open open_embedding_of_embedding_open\n\n",
 "open_embedding_of_continuous_injective_open":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem open_embedding_of_continuous_injective_open {f : α → β} (h₁ : continuous f) (h₂ : injective f)\n    (h₃ : is_open_map f) : open_embedding f :=\n  by\n  simp only [open_embedding_iff_embedding_open, embedding_iff, inducing_iff_nhds, *, and_true_iff]\n  exact fun a => le_antisymm (h₁.tendsto _).le_comap (@comap_map _ _ ((nhds) a) _ h₂ ▸ comap_mono (h₃.nhds_le _))\n#align open_embedding_of_continuous_injective_open open_embedding_of_continuous_injective_open\n\n",
 "open_embedding_iff_embedding_open":
 "theorem open_embedding_iff_embedding_open {f : α → β} : open_embedding f ↔ embedding f ∧ is_open_map f :=\n  ⟨fun h => ⟨h.1, h.is_open_map⟩, fun h => open_embedding_of_embedding_open h.1 h.2⟩\n#align open_embedding_iff_embedding_open open_embedding_iff_embedding_open\n\n",
 "open_embedding_iff_continuous_injective_open":
 "theorem open_embedding_iff_continuous_injective_open {f : α → β} :\n    open_embedding f ↔ continuous f ∧ injective f ∧ is_open_map f :=\n  ⟨fun h => ⟨h.continuous, h.inj, h.is_open_map⟩, fun h => open_embedding_of_continuous_injective_open h.1 h.2.1 h.2.2⟩\n#align open_embedding_iff_continuous_injective_open open_embedding_iff_continuous_injective_open\n\n",
 "open_embedding_id":
 "theorem open_embedding_id : open_embedding (@id α) :=\n  ⟨embedding_id, is_open_map.id.is_open_range⟩\n#align open_embedding_id open_embedding_id\n\n",
 "of_sections":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem of_sections {f : α → β} (h : ∀ x, ∃ g : β → α, continuous_at g (f x) ∧ g (f x) = x ∧ right_inverse g f) :\n    is_open_map f :=\n  of_nhds_le fun x =>\n    let ⟨g, hgc, hgx, hgf⟩ := h x\n    calc\n      (nhds) (f x) = map f (map g ((nhds) (f x))) := by rw [map_map, hgf.comp_eq_id, map_id]\n      _ ≤ map f ((nhds) (g (f x))) := map_mono hgc\n      _ = map f ((nhds) x) := by rw [hgx]\n      \n#align of_sections of_sections\n\n",
 "of_quotient_map_compose":
 "protected theorem of_quotient_map_compose (hf : continuous f) (hg : continuous g) (hgf : quotient_map (g ∘ f)) :\n    quotient_map g :=\n  ⟨hgf.1.of_comp,\n    le_antisymm\n      (by\n        rw [hgf.right, ← continuous_iff_coinduced_le]\n        apply continuous_coinduced_rng.comp hf)\n      (by rwa [← continuous_iff_coinduced_le])⟩\n#align of_quotient_map_compose of_quotient_map_compose\n\n",
 "of_nonempty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem of_nonempty {f : α → β} (h : ∀ s, is_closed s → s.nonempty → is_closed («expr '' » f s)) : is_closed_map f :=\n  by\n  intro s hs; cases' eq_empty_or_nonempty s with h2s h2s\n  · simp_rw [h2s, image_empty, is_closed_empty]\n  · exact h s hs h2s\n#align of_nonempty of_nonempty\n\n",
 "of_nhds_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem of_nhds_le (hf : ∀ a, (nhds) (f a) ≤ map f ((nhds) a)) : is_open_map f := fun s hs =>\n  is_open_iff_mem_nhds.2 fun b ⟨a, has, hab⟩ => hab ▸ hf _ (image_mem_map <| is_open.mem_nhds hs has)\n#align of_nhds_le of_nhds_le\n\n",
 "of_inverse":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem of_inverse {f : α → β} {f' : β → α} (h : continuous f') (l_inv : left_inverse f f')\n    (r_inv : right_inverse f f') : is_closed_map f := fun s hs =>\n  have : «expr ⁻¹' » f' s = «expr '' » f s := by ext x <;> simp [mem_image_iff_of_inverse r_inv l_inv]\n  this ▸ hs.preimage h\n#align of_inverse of_inverse\n\n",
 "of_comp_iff":
 "theorem open_embedding.of_comp_iff (f : α → β) {g : β → γ} (hg : open_embedding g) :\n    open_embedding (g ∘ f) ↔ open_embedding f := by\n  simp only [open_embedding_iff_continuous_injective_open, ← hg.is_open_map_iff, ← hg.1.continuous_iff,\n    hg.inj.of_comp_iff]\n#align open_embedding.of_comp_iff open_embedding.of_comp_iff\n\n",
 "of_comp":
 "theorem open_embedding.of_comp (f : α → β) {g : β → γ} (hg : open_embedding g) (h : open_embedding (g ∘ f)) :\n    open_embedding f :=\n  (open_embedding.of_comp_iff f hg).1 h\n#align open_embedding.of_comp open_embedding.of_comp\n\n",
 "nhds_set_eq_comap":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_set -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_set -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem inducing.nhds_set_eq_comap {f : α → β} (hf : inducing f) (s : set α) :\n    (nhds_set) s = comap f ((nhds_set) («expr '' » f s)) := by\n  simp only [nhds_set, supₛ_image, comap_supr, hf.nhds_eq_comap, supᵢ_image]\n#align inducing.nhds_set_eq_comap inducing.nhds_set_eq_comap\n\n",
 "nhds_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem nhds_le (hf : is_open_map f) (a : α) : (nhds) (f a) ≤ ((nhds) a).map f :=\n  le_map fun s => hf.image_mem_nhds\n#align nhds_le nhds_le\n\n",
 "nhds_eq_comap":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem inducing.nhds_eq_comap {f : α → β} (hf : inducing f) : ∀ a : α, (nhds) a = comap f (nhds <| f a) :=\n  inducing_iff_nhds.1 hf\n#align inducing.nhds_eq_comap inducing.nhds_eq_comap\n\n",
 "mk'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem embedding.mk' (f : α → β) (inj : injective f) (induced : ∀ a, comap f ((nhds) (f a)) = (nhds) a) :\n    embedding f :=\n  ⟨inducing_iff_nhds.2 fun a => (induced a).symm, inj⟩\n#align embedding.mk' embedding.mk'\n\n",
 "maps_to_interior":
 "theorem maps_to_interior (hf : is_open_map f) {s : set α} {t : set β} (h : MapsTo f s t) :\n    MapsTo f (interior s) (interior t) :=\n  mapsTo'.2 <| interior_maximal (h.mono interior_subset Subset.rfl).image_subset (hf _ is_open_interior)\n#align maps_to_interior maps_to_interior\n\n",
 "map_nhds_of_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem embedding.map_nhds_of_mem {f : α → β} (hf : embedding f) (a : α) (h : range f ∈ (nhds) (f a)) :\n    ((nhds) a).map f = (nhds) (f a) :=\n  hf.1.map_nhds_of_mem a h\n#align embedding.map_nhds_of_mem embedding.map_nhds_of_mem\n\n",
 "map_nhds_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem open_embedding.map_nhds_eq {f : α → β} (hf : open_embedding f) (a : α) : map f ((nhds) a) = (nhds) (f a) :=\n  hf.to_embedding.map_nhds_of_mem _ <| hf.open_range.mem_nhds <| mem_range_self _\n#align open_embedding.map_nhds_eq open_embedding.map_nhds_eq\n\n",
 "is_open_range":
 "theorem is_open_range (hf : is_open_map f) : is_open (range f) :=\n  by\n  rw [← image_univ]\n  exact hf _ is_open_univ\n#align is_open_range is_open_range\n\n",
 "is_open_preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\nprotected theorem is_open_preimage (hf : quotient_map f) {s : set β} : is_open («expr ⁻¹' » f s) ↔ is_open s :=\n  ((quotient_map_iff.1 hf).2 s).symm\n#align is_open_preimage is_open_preimage\n\n",
 "is_open_map_iff_nhds_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem is_open_map_iff_nhds_le [topological_space α] [topological_space β] {f : α → β} :\n    is_open_map f ↔ ∀ a : α, (nhds) (f a) ≤ ((nhds) a).map f :=\n  ⟨fun hf => hf.nhds_le, is_open_map.of_nhds_le⟩\n#align is_open_map_iff_nhds_le is_open_map_iff_nhds_le\n\n",
 "is_open_map_iff_interior":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem is_open_map_iff_interior [topological_space α] [topological_space β] {f : α → β} :\n    is_open_map f ↔ ∀ s, «expr '' » f (interior s) ⊆ interior («expr '' » f s) :=\n  ⟨is_open_map.image_interior_subset, fun hs u hu =>\n    subset_interior_iff_is_open.mp <|\n      calc\n        «expr '' » f u = «expr '' » f (interior u) := by rw [hu.interior_eq]\n        _ ⊆ interior («expr '' » f u) := hs u\n        ⟩\n#align is_open_map_iff_interior is_open_map_iff_interior\n\n",
 "is_open_map_iff":
 "theorem open_embedding.is_open_map_iff {g : β → γ} {f : α → β} (hg : open_embedding g) :\n    is_open_map f ↔ is_open_map (g ∘ f) := by\n  simp only [is_open_map_iff_nhds_le, ← @map_map _ _ _ _ f g, ← hg.map_nhds_eq, map_le_map_iff hg.inj]\n#align open_embedding.is_open_map_iff open_embedding.is_open_map_iff\n\n",
 "is_open_map":
 "theorem open_embedding.is_open_map {f : α → β} (hf : open_embedding f) : is_open_map f :=\n  hf.to_embedding.to_inducing.is_open_map hf.open_range\n#align open_embedding.is_open_map open_embedding.is_open_map\n\n",
 "is_open_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem inducing.is_open_iff {f : α → β} (hf : inducing f) {s : set α} :\n    is_open s ↔ ∃ t, is_open t ∧ «expr ⁻¹' » f t = s := by rw [hf.induced, is_open_induced_iff]\n#align inducing.is_open_iff inducing.is_open_iff\n\n",
 "is_closed_preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\nprotected theorem is_closed_preimage (hf : quotient_map f) {s : set β} : is_closed («expr ⁻¹' » f s) ↔ is_closed s := by\n  simp only [← is_open_compl_iff, ← preimage_compl, hf.is_open_preimage]\n#align is_closed_preimage is_closed_preimage\n\n",
 "is_closed_map_iff_closure_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem is_closed_map_iff_closure_image [topological_space α] [topological_space β] {f : α → β} :\n    is_closed_map f ↔ ∀ s, closure («expr '' » f s) ⊆ «expr '' » f (closure s) :=\n  ⟨is_closed_map.closure_image_subset, fun hs c hc =>\n    is_closed_of_closure_subset <|\n      calc\n        closure («expr '' » f c) ⊆ «expr '' » f (closure c) := hs c\n        _ = «expr '' » f c := by rw [hc.closure_eq]\n        ⟩\n#align is_closed_map_iff_closure_image is_closed_map_iff_closure_image\n\n",
 "is_closed_map":
 "theorem closed_embedding.is_closed_map (hf : closed_embedding f) : is_closed_map f :=\n  hf.to_embedding.to_inducing.is_closed_map hf.closed_range\n#align closed_embedding.is_closed_map closed_embedding.is_closed_map\n\n",
 "is_closed_iff'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem inducing.is_closed_iff' {f : α → β} (hf : inducing f) {s : set α} :\n    is_closed s ↔ ∀ x, f x ∈ closure («expr '' » f s) → x ∈ s := by rw [hf.induced, is_closed_induced_iff']\n#align inducing.is_closed_iff' inducing.is_closed_iff'\n\n",
 "is_closed_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem inducing.is_closed_iff {f : α → β} (hf : inducing f) {s : set α} :\n    is_closed s ↔ ∃ t, is_closed t ∧ «expr ⁻¹' » f t = s := by rw [hf.induced, is_closed_induced_iff]\n#align inducing.is_closed_iff inducing.is_closed_iff\n\n",
 "interior_preimage_subset_preimage_interior":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem interior_preimage_subset_preimage_interior (hf : is_open_map f) {s : set β} :\n    interior («expr ⁻¹' » f s) ⊆ «expr ⁻¹' » f (interior s) :=\n  hf.maps_to_interior (mapsTo_preimage _ _)\n#align interior_preimage_subset_preimage_interior interior_preimage_subset_preimage_interior\n\n",
 "inducing_of_inducing_compose":
 "theorem inducing_of_inducing_compose {f : α → β} {g : β → γ} (hf : continuous f) (hg : continuous g)\n    (hgf : inducing (g ∘ f)) : inducing f :=\n  ⟨le_antisymm (by rwa [← continuous_iff_le_induced])\n      (by\n        rw [hgf.induced, ← continuous_iff_le_induced]\n        apply hg.comp continuous_induced_dom)⟩\n#align inducing_of_inducing_compose inducing_of_inducing_compose\n\n",
 "inducing_iff_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem inducing_iff_nhds {f : α → β} : inducing f ↔ ∀ a, (nhds) a = comap f ((nhds) (f a)) :=\n  (inducing_iff _).trans (induced_iff_nhds_eq f)\n#align inducing_iff_nhds inducing_iff_nhds\n\n",
 "inducing_iff":
 "protected theorem inducing.inducing_iff {f : α → β} {g : β → γ} (hg : inducing g) : inducing f ↔ inducing (g ∘ f) :=\n  by\n  refine' ⟨fun h => hg.comp h, fun hgf => inducing_of_inducing_compose _ hg.continuous hgf⟩\n  rw [hg.continuous_iff]\n  exact hgf.continuous\n#align inducing.inducing_iff inducing.inducing_iff\n\n",
 "inducing_id":
 "/-\nCopyright (c) 2017 Johannes Hölzl. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johannes Hölzl, Mario Carneiro, Patrick Massot\n-/\ntheorem inducing_id : inducing (@id α) :=\n  ⟨induced_id.symm⟩\n#align inducing_id inducing_id\n\n",
 "image_mem_nhds_within":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\ntheorem inducing.image_mem_nhds_within {f : α → β} (hf : inducing f) {a : α} {s : set α} (hs : s ∈ (nhds) a) :\n    «expr '' » f s ∈ nhds_within (range f) (f a) :=\n  hf.map_nhds_eq a ▸ image_mem_map hs\n#align inducing.image_mem_nhds_within inducing.image_mem_nhds_within\n\n",
 "image_mem_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem image_mem_nhds (hf : is_open_map f) {x : α} {s : set α} (hx : s ∈ (nhds) x) : «expr '' » f s ∈ (nhds) (f x) :=\n  let ⟨t, hts, ht, hxt⟩ := mem_nhds_iff.1 hx\n  mem_of_superset (is_open.mem_nhds (hf t ht) (mem_image_of_mem _ hxt)) (image_subset _ hts)\n#align image_mem_nhds image_mem_nhds\n\n",
 "image_interior_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem image_interior_subset (hf : is_open_map f) (s : set α) :\n    «expr '' » f (interior s) ⊆ interior («expr '' » f s) :=\n  (hf.maps_to_interior (mapsTo_image f s)).image_subset\n#align image_interior_subset image_interior_subset\n\n",
 "id":
 "#print id /-\nprotected theorem id : is_closed_map (@id α) := fun s hs => by rwa [image_id]\n#align id id\n-/\n\n",
 "embedding_of_embedding_compose":
 "theorem embedding_of_embedding_compose {f : α → β} {g : β → γ} (hf : continuous f) (hg : continuous g)\n    (hgf : embedding (g ∘ f)) : embedding f :=\n  { induced := (inducing_of_inducing_compose hf hg hgf.to_inducing).induced\n    inj := fun a₁ a₂ h => hgf.inj <| by simp [h, (· ∘ ·)] }\n#align embedding_of_embedding_compose embedding_of_embedding_compose\n\n",
 "embedding_induced":
 "theorem function.injective.embedding_induced [t : topological_space β] {f : α → β} (hf : injective f) :\n    @_root_.embedding α β (t.induced f) t f :=\n  { induced := rfl\n    inj := hf }\n#align function.injective.embedding_induced function.injective.embedding_induced\n\n",
 "embedding_id":
 "theorem embedding_id : embedding (@id α) :=\n  ⟨inducing_id, fun a₁ a₂ h => h⟩\n#align embedding_id embedding_id\n\n",
 "embedding":
 "protected theorem function.left_inverse.embedding {f : α → β} {g : β → α} (h : left_inverse f g) (hf : continuous f)\n    (hg : continuous g) : embedding g :=\n  embedding_of_embedding_compose hg hf <| h.comp_eq_id.symm ▸ embedding_id\n#align function.left_inverse.embedding function.left_inverse.embedding\n\n",
 "dense_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem inducing.dense_iff {f : α → β} (hf : inducing f) {s : set α} : dense s ↔ ∀ x, f x ∈ closure («expr '' » f s) :=\n  by simp only [dense, hf.closure_eq_preimage_closure_image, mem_preimage]\n#align inducing.dense_iff inducing.dense_iff\n\n",
 "continuous_iff":
 "protected theorem continuous_iff (hf : quotient_map f) : continuous g ↔ continuous (g ∘ f) := by\n  rw [continuous_iff_coinduced_le, continuous_iff_coinduced_le, hf.right, coinduced_compose]\n#align continuous_iff continuous_iff\n\n",
 "continuous_at_iff'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem inducing.continuous_at_iff' {f : α → β} {g : β → γ} (hf : inducing f) {x : α} (h : range f ∈ (nhds) (f x)) :\n    continuous_at (g ∘ f) x ↔ continuous_at g (f x) := by\n  simp_rw [continuous_at, filter.tendsto, ← hf.map_nhds_of_mem _ h, filter.map_map]\n#align inducing.continuous_at_iff' inducing.continuous_at_iff'\n\n",
 "continuous_at_iff":
 "theorem inducing.continuous_at_iff {f : α → β} {g : β → γ} (hg : inducing g) {x : α} :\n    continuous_at f x ↔ continuous_at (g ∘ f) x := by simp_rw [continuous_at, inducing.tendsto_nhds_iff hg]\n#align inducing.continuous_at_iff inducing.continuous_at_iff\n\n",
 "continuous":
 "theorem closed_embedding.continuous (hf : closed_embedding f) : continuous f :=\n  hf.to_embedding.continuous\n#align closed_embedding.continuous closed_embedding.continuous\n\n",
 "comp":
 "theorem closed_embedding.comp {g : β → γ} {f : α → β} (hg : closed_embedding g) (hf : closed_embedding f) :\n    closed_embedding (g ∘ f) :=\n  ⟨hg.to_embedding.comp hf.to_embedding,\n    show is_closed (range (g ∘ f)) by rw [range_comp, ← hg.closed_iff_image_closed] <;> exact hf.closed_range⟩\n#align closed_embedding.comp closed_embedding.comp\n\n",
 "closure_image_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem closure_image_subset {f : α → β} (hf : is_closed_map f) (s : set α) :\n    closure («expr '' » f s) ⊆ «expr '' » f (closure s) :=\n  closure_minimal (image_subset _ subset_closure) (hf _ is_closed_closure)\n#align closure_image_subset closure_image_subset\n\n",
 "closure_image_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem closed_embedding.closure_image_eq {f : α → β} (hf : closed_embedding f) (s : set α) :\n    closure («expr '' » f s) = «expr '' » f (closure s) :=\n  (hf.is_closed_map.closure_image_subset _).antisymm (image_closure_subset_closure_image hf.continuous)\n#align closed_embedding.closure_image_eq closed_embedding.closure_image_eq\n\n",
 "closure_eq_preimage_closure_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem embedding.closure_eq_preimage_closure_image {e : α → β} (he : embedding e) (s : set α) :\n    closure s = «expr ⁻¹' » e (closure («expr '' » e s)) :=\n  he.1.closure_eq_preimage_closure_image s\n#align embedding.closure_eq_preimage_closure_image embedding.closure_eq_preimage_closure_image\n\n",
 "closed_range":
 "theorem closed_range {f : α → β} (hf : is_closed_map f) : is_closed (range f) :=\n  @image_univ _ _ f ▸ hf _ is_closed_univ\n#align closed_range closed_range\n\n",
 "closed_iff_preimage_closed":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem closed_embedding.closed_iff_preimage_closed (hf : closed_embedding f) {s : set β} (hs : s ⊆ range f) :\n    is_closed s ↔ is_closed («expr ⁻¹' » f s) :=\n  by\n  convert ← hf.closed_iff_image_closed.symm\n  rwa [image_preimage_eq_inter_range, inter_eq_self_of_subset_left]\n#align closed_embedding.closed_iff_preimage_closed closed_embedding.closed_iff_preimage_closed\n\n",
 "closed_iff_image_closed":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem closed_embedding.closed_iff_image_closed (hf : closed_embedding f) {s : set α} :\n    is_closed s ↔ is_closed («expr '' » f s) :=\n  ⟨hf.is_closed_map s, fun h => by\n    convert ← continuous_iff_is_closed.mp hf.continuous _ h\n    apply preimage_image_eq _ hf.inj⟩\n#align closed_embedding.closed_iff_image_closed closed_embedding.closed_iff_image_closed\n\n",
 "closed_embedding_of_embedding_closed":
 "theorem closed_embedding_of_embedding_closed (h₁ : embedding f) (h₂ : is_closed_map f) : closed_embedding f :=\n  ⟨h₁, by convert h₂ univ is_closed_univ <;> simp⟩\n#align closed_embedding_of_embedding_closed closed_embedding_of_embedding_closed\n\n",
 "closed_embedding_of_continuous_injective_closed":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem closed_embedding_of_continuous_injective_closed (h₁ : continuous f) (h₂ : injective f) (h₃ : is_closed_map f) :\n    closed_embedding f := by\n  refine' closed_embedding_of_embedding_closed ⟨⟨_⟩, h₂⟩ h₃\n  apply le_antisymm (continuous_iff_le_induced.mp h₁) _\n  intro s'\n  change is_open _ ≤ is_open _\n  rw [← is_closed_compl_iff, ← is_closed_compl_iff]\n  generalize «expr ᶜ» s' = s\n  rw [is_closed_induced_iff]\n  refine' fun hs => ⟨«expr '' » f s, h₃ s hs, _⟩\n  rw [preimage_image_eq _ h₂]\n#align closed_embedding_of_continuous_injective_closed closed_embedding_of_continuous_injective_closed\n\n",
 "closed_embedding_id":
 "theorem closed_embedding_id : closed_embedding (@id α) :=\n  ⟨embedding_id, by convert is_closed_univ <;> apply range_id⟩\n#align closed_embedding_id closed_embedding_id\n\n"}