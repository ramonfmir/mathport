{"to_quotient_map":
 "/-- A continuous surjective open map is a quotient map. -/\ntheorem to_quotient_map {f : α → β} (open_map : IsOpenMap f) (cont : Continuous f) (surj : surjective f) :\n    QuotientMap f :=\n  quotientMap_iff.2 ⟨surj, fun s => ⟨fun h => h.preimage cont, fun h => surj.image_preimage s ▸ open_map _ h⟩⟩\n#align to_quotient_map to_quotient_map\n\n",
 "tendsto_nhds_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print ClosedEmbedding.tendsto_nhds_iff /-\ntheorem ClosedEmbedding.tendsto_nhds_iff {ι : Type _} {g : ι → α} {a : Filter ι} {b : α} (hf : ClosedEmbedding f) :\n    Tendsto g a ((nhds) b) ↔ Tendsto (f ∘ g) a ((nhds) (f b)) :=\n  hf.to_embedding.tendsto_nhds_iff\n#align closed_embedding.tendsto_nhds_iff ClosedEmbedding.tendsto_nhds_iff\n-/\n\n",
 "surjective":
 "protected theorem surjective (hf : QuotientMap f) : surjective f :=\n  hf.1\n#align surjective surjective\n\n",
 "range_mem_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem range_mem_nhds (hf : IsOpenMap f) (x : α) : range f ∈ (nhds) (f x) :=\n  hf.is_open_range.mem_nhds <| mem_range_self _\n#align range_mem_nhds range_mem_nhds\n\n",
 "quotientMap_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n#print quotientMap_iff /-\ntheorem quotientMap_iff {α β : Type _} [TopologicalSpace α] [TopologicalSpace β] {f : α → β} :\n    QuotientMap f ↔ surjective f ∧ ∀ s : Set β, IsOpen s ↔ IsOpen («expr ⁻¹' » f s) :=\n  and_congr iff.rfl topologicalSpace_eq_iff\n#align quotient_map_iff quotientMap_iff\n-/\n\n",
 "preimage_interior_eq_interior_preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem preimage_interior_eq_interior_preimage (hf₁ : IsOpenMap f) (hf₂ : Continuous f) (s : Set β) :\n    «expr ⁻¹' » f (interior s) = interior («expr ⁻¹' » f s) :=\n  Subset.antisymm (preimage_interior_subset_interior_preimage hf₂) (interior_preimage_subset_preimage_interior hf₁)\n#align preimage_interior_eq_interior_preimage preimage_interior_eq_interior_preimage\n\n",
 "preimage_frontier_subset_frontier_preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem preimage_frontier_subset_frontier_preimage (hf : IsOpenMap f) {s : Set β} :\n    «expr ⁻¹' » f (frontier s) ⊆ frontier («expr ⁻¹' » f s) := by\n  simpa only [frontier_eq_closure_inter_closure, preimage_inter] using\n    inter_subset_inter hf.preimage_closure_subset_closure_preimage hf.preimage_closure_subset_closure_preimage\n#align preimage_frontier_subset_frontier_preimage preimage_frontier_subset_frontier_preimage\n\n",
 "preimage_frontier_eq_frontier_preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem preimage_frontier_eq_frontier_preimage (hf : IsOpenMap f) (hfc : Continuous f) (s : Set β) :\n    «expr ⁻¹' » f (frontier s) = frontier («expr ⁻¹' » f s) := by\n  simp only [frontier_eq_closure_inter_closure, preimage_inter, preimage_compl,\n    hf.preimage_closure_eq_closure_preimage hfc]\n#align preimage_frontier_eq_frontier_preimage preimage_frontier_eq_frontier_preimage\n\n",
 "preimage_closure_subset_closure_preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem preimage_closure_subset_closure_preimage (hf : IsOpenMap f) {s : Set β} :\n    «expr ⁻¹' » f (closure s) ⊆ closure («expr ⁻¹' » f s) :=\n  by\n  rw [← compl_subset_compl]\n  simp only [← interior_compl, ← preimage_compl, hf.interior_preimage_subset_preimage_interior]\n#align preimage_closure_subset_closure_preimage preimage_closure_subset_closure_preimage\n\n",
 "preimage_closure_eq_closure_preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem preimage_closure_eq_closure_preimage (hf : IsOpenMap f) (hfc : Continuous f) (s : Set β) :\n    «expr ⁻¹' » f (closure s) = closure («expr ⁻¹' » f s) :=\n  hf.preimage_closure_subset_closure_preimage.antisymm (hfc.closure_preimage_subset s)\n#align preimage_closure_eq_closure_preimage preimage_closure_eq_closure_preimage\n\n",
 "open_iff_preimage_open":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n#print OpenEmbedding.open_iff_preimage_open /-\ntheorem OpenEmbedding.open_iff_preimage_open {f : α → β} (hf : OpenEmbedding f) {s : Set β} (hs : s ⊆ range f) :\n    IsOpen s ↔ IsOpen («expr ⁻¹' » f s) :=\n  by\n  convert← hf.open_iff_image_open.symm\n  rwa [image_preimage_eq_inter_range, inter_eq_self_of_subset_left]\n#align open_embedding.open_iff_preimage_open OpenEmbedding.open_iff_preimage_open\n-/\n\n",
 "open_iff_image_open":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n#print OpenEmbedding.open_iff_image_open /-\ntheorem OpenEmbedding.open_iff_image_open {f : α → β} (hf : OpenEmbedding f) {s : Set α} :\n    IsOpen s ↔ IsOpen («expr '' » f s) :=\n  ⟨hf.is_open_map s, fun h => by\n    convert← h.preimage hf.to_embedding.continuous\n    apply preimage_image_eq _ hf.inj⟩\n#align open_embedding.open_iff_image_open OpenEmbedding.open_iff_image_open\n-/\n\n",
 "openEmbedding_of_embedding_open":
 "#print openEmbedding_of_embedding_open /-\ntheorem openEmbedding_of_embedding_open {f : α → β} (h₁ : Embedding f) (h₂ : IsOpenMap f) : OpenEmbedding f :=\n  ⟨h₁, h₂.is_open_range⟩\n#align open_embedding_of_embedding_open openEmbedding_of_embedding_open\n-/\n\n",
 "openEmbedding_of_continuous_injective_open":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print openEmbedding_of_continuous_injective_open /-\ntheorem openEmbedding_of_continuous_injective_open {f : α → β} (h₁ : Continuous f) (h₂ : injective f)\n    (h₃ : IsOpenMap f) : OpenEmbedding f :=\n  by\n  simp only [openEmbedding_iff_embedding_open, embedding_iff, inducing_iff_nhds, *, and_true_iff]\n  exact fun a => le_antisymm (h₁.tendsto _).le_comap (@comap_map _ _ ((nhds) a) _ h₂ ▸ comap_mono (h₃.nhds_le _))\n#align open_embedding_of_continuous_injective_open openEmbedding_of_continuous_injective_open\n-/\n\n",
 "openEmbedding_iff_embedding_open":
 "#print openEmbedding_iff_embedding_open /-\ntheorem openEmbedding_iff_embedding_open {f : α → β} : OpenEmbedding f ↔ Embedding f ∧ IsOpenMap f :=\n  ⟨fun h => ⟨h.1, h.is_open_map⟩, fun h => openEmbedding_of_embedding_open h.1 h.2⟩\n#align open_embedding_iff_embedding_open openEmbedding_iff_embedding_open\n-/\n\n",
 "openEmbedding_iff_continuous_injective_open":
 "#print openEmbedding_iff_continuous_injective_open /-\ntheorem openEmbedding_iff_continuous_injective_open {f : α → β} :\n    OpenEmbedding f ↔ Continuous f ∧ injective f ∧ IsOpenMap f :=\n  ⟨fun h => ⟨h.continuous, h.inj, h.is_open_map⟩, fun h => openEmbedding_of_continuous_injective_open h.1 h.2.1 h.2.2⟩\n#align open_embedding_iff_continuous_injective_open openEmbedding_iff_continuous_injective_open\n-/\n\n",
 "openEmbedding_id":
 "#print openEmbedding_id /-\ntheorem openEmbedding_id : OpenEmbedding (@id α) :=\n  ⟨embedding_id, IsOpenMap.id.is_open_range⟩\n#align open_embedding_id openEmbedding_id\n-/\n\n",
 "of_sections":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem of_sections {f : α → β} (h : ∀ x, ∃ g : β → α, ContinuousAt g (f x) ∧ g (f x) = x ∧ right_inverse g f) :\n    IsOpenMap f :=\n  of_nhds_le fun x =>\n    let ⟨g, hgc, hgx, hgf⟩ := h x\n    calc\n      (nhds) (f x) = map f (map g ((nhds) (f x))) := by rw [map_map, hgf.comp_eq_id, map_id]\n      _ ≤ map f ((nhds) (g (f x))) := (map_mono hgc)\n      _ = map f ((nhds) x) := by rw [hgx]\n      \n#align of_sections of_sections\n\n",
 "of_quotient_map_compose":
 "protected theorem of_quotient_map_compose (hf : Continuous f) (hg : Continuous g) (hgf : QuotientMap (g ∘ f)) :\n    QuotientMap g :=\n  ⟨hgf.1.of_comp,\n    le_antisymm\n      (by\n        rw [hgf.right, ← continuous_iff_coinduced_le]\n        apply continuous_coinduced_rng.comp hf)\n      (by rwa [← continuous_iff_coinduced_le])⟩\n#align of_quotient_map_compose of_quotient_map_compose\n\n",
 "of_nonempty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem of_nonempty {f : α → β} (h : ∀ s, IsClosed s → s.nonempty → IsClosed («expr '' » f s)) : IsClosedMap f :=\n  by\n  intro s hs; cases' eq_empty_or_nonempty s with h2s h2s\n  · simp_rw [h2s, image_empty, isClosed_empty]\n  · exact h s hs h2s\n#align of_nonempty of_nonempty\n\n",
 "of_nhds_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem of_nhds_le (hf : ∀ a, (nhds) (f a) ≤ map f ((nhds) a)) : IsOpenMap f := fun s hs =>\n  isOpen_iff_mem_nhds.2 fun b ⟨a, has, hab⟩ => hab ▸ hf _ (image_mem_map <| IsOpen.mem_nhds hs has)\n#align of_nhds_le of_nhds_le\n\n",
 "of_inverse":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem of_inverse {f : α → β} {f' : β → α} (h : Continuous f') (l_inv : left_inverse f f')\n    (r_inv : right_inverse f f') : IsClosedMap f := fun s hs =>\n  have : «expr ⁻¹' » f' s = «expr '' » f s := by ext x <;> simp [mem_image_iff_of_inverse r_inv l_inv]\n  this ▸ hs.preimage h\n#align of_inverse of_inverse\n\n",
 "of_comp_iff":
 "#print OpenEmbedding.of_comp_iff /-\ntheorem OpenEmbedding.of_comp_iff (f : α → β) {g : β → γ} (hg : OpenEmbedding g) :\n    OpenEmbedding (g ∘ f) ↔ OpenEmbedding f := by\n  simp only [openEmbedding_iff_continuous_injective_open, ← hg.is_open_map_iff, ← hg.1.continuous_iff,\n    hg.inj.of_comp_iff]\n#align open_embedding.of_comp_iff OpenEmbedding.of_comp_iff\n-/\n\n",
 "of_comp":
 "#print OpenEmbedding.of_comp /-\ntheorem OpenEmbedding.of_comp (f : α → β) {g : β → γ} (hg : OpenEmbedding g) (h : OpenEmbedding (g ∘ f)) :\n    OpenEmbedding f :=\n  (OpenEmbedding.of_comp_iff f hg).1 h\n#align open_embedding.of_comp OpenEmbedding.of_comp\n-/\n\n",
 "nhds_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem nhds_le (hf : IsOpenMap f) (a : α) : (nhds) (f a) ≤ ((nhds) a).map f :=\n  le_map fun s => hf.image_mem_nhds\n#align nhds_le nhds_le\n\n",
 "nhds_eq_comap":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print Inducing.nhds_eq_comap /-\ntheorem Inducing.nhds_eq_comap {f : α → β} (hf : Inducing f) : ∀ a : α, (nhds) a = comap f (nhds <| f a) :=\n  inducing_iff_nhds.1 hf\n#align inducing.nhds_eq_comap Inducing.nhds_eq_comap\n-/\n\n",
 "nhdsSet_eq_comap":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_set -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_set -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n#print Inducing.nhdsSet_eq_comap /-\ntheorem Inducing.nhdsSet_eq_comap {f : α → β} (hf : Inducing f) (s : Set α) :\n    (nhds_set) s = comap f ((nhds_set) («expr '' » f s)) := by\n  simp only [nhdsSet, supₛ_image, comap_supr, hf.nhds_eq_comap, supᵢ_image]\n#align inducing.nhds_set_eq_comap Inducing.nhdsSet_eq_comap\n-/\n\n",
 "mk'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print Embedding.mk' /-\ntheorem Embedding.mk' (f : α → β) (inj : injective f) (induced : ∀ a, comap f ((nhds) (f a)) = (nhds) a) :\n    Embedding f :=\n  ⟨inducing_iff_nhds.2 fun a => (induced a).symm, inj⟩\n#align embedding.mk' Embedding.mk'\n-/\n\n",
 "maps_to_interior":
 "theorem maps_to_interior (hf : IsOpenMap f) {s : Set α} {t : Set β} (h : MapsTo f s t) :\n    MapsTo f (interior s) (interior t) :=\n  mapsTo'.2 <| interior_maximal (h.mono interior_subset Subset.rfl).image_subset (hf _ isOpen_interior)\n#align maps_to_interior maps_to_interior\n\n",
 "map_nhds_of_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print Embedding.map_nhds_of_mem /-\ntheorem Embedding.map_nhds_of_mem {f : α → β} (hf : Embedding f) (a : α) (h : range f ∈ (nhds) (f a)) :\n    ((nhds) a).map f = (nhds) (f a) :=\n  hf.1.map_nhds_of_mem a h\n#align embedding.map_nhds_of_mem Embedding.map_nhds_of_mem\n-/\n\n",
 "map_nhds_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print OpenEmbedding.map_nhds_eq /-\ntheorem OpenEmbedding.map_nhds_eq {f : α → β} (hf : OpenEmbedding f) (a : α) : map f ((nhds) a) = (nhds) (f a) :=\n  hf.to_embedding.map_nhds_of_mem _ <| hf.open_range.mem_nhds <| mem_range_self _\n#align open_embedding.map_nhds_eq OpenEmbedding.map_nhds_eq\n-/\n\n",
 "is_open_range":
 "theorem is_open_range (hf : IsOpenMap f) : IsOpen (range f) :=\n  by\n  rw [← image_univ]\n  exact hf _ isOpen_univ\n#align is_open_range is_open_range\n\n",
 "is_open_preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\nprotected theorem is_open_preimage (hf : QuotientMap f) {s : Set β} : IsOpen («expr ⁻¹' » f s) ↔ IsOpen s :=\n  ((quotientMap_iff.1 hf).2 s).symm\n#align is_open_preimage is_open_preimage\n\n",
 "is_closed_preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\nprotected theorem is_closed_preimage (hf : QuotientMap f) {s : Set β} : IsClosed («expr ⁻¹' » f s) ↔ IsClosed s := by\n  simp only [← isOpen_compl_iff, ← preimage_compl, hf.is_open_preimage]\n#align is_closed_preimage is_closed_preimage\n\n",
 "isOpen_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n#print Inducing.isOpen_iff /-\ntheorem Inducing.isOpen_iff {f : α → β} (hf : Inducing f) {s : Set α} :\n    IsOpen s ↔ ∃ t, IsOpen t ∧ «expr ⁻¹' » f t = s := by rw [hf.induced, isOpen_induced_iff]\n#align inducing.is_open_iff Inducing.isOpen_iff\n-/\n\n",
 "isOpenMap_iff_nhds_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print isOpenMap_iff_nhds_le /-\ntheorem isOpenMap_iff_nhds_le [TopologicalSpace α] [TopologicalSpace β] {f : α → β} :\n    IsOpenMap f ↔ ∀ a : α, (nhds) (f a) ≤ ((nhds) a).map f :=\n  ⟨fun hf => hf.nhds_le, IsOpenMap.of_nhds_le⟩\n#align is_open_map_iff_nhds_le isOpenMap_iff_nhds_le\n-/\n\n",
 "isOpenMap_iff_interior":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n#print isOpenMap_iff_interior /-\ntheorem isOpenMap_iff_interior [TopologicalSpace α] [TopologicalSpace β] {f : α → β} :\n    IsOpenMap f ↔ ∀ s, «expr '' » f (interior s) ⊆ interior («expr '' » f s) :=\n  ⟨IsOpenMap.image_interior_subset, fun hs u hu =>\n    subset_interior_iff_isOpen.mp <|\n      calc\n        «expr '' » f u = «expr '' » f (interior u) := by rw [hu.interior_eq]\n        _ ⊆ interior («expr '' » f u) := hs u\n        ⟩\n#align is_open_map_iff_interior isOpenMap_iff_interior\n-/\n\n",
 "isOpenMap_iff":
 "#print OpenEmbedding.isOpenMap_iff /-\ntheorem OpenEmbedding.isOpenMap_iff {g : β → γ} {f : α → β} (hg : OpenEmbedding g) : IsOpenMap f ↔ IsOpenMap (g ∘ f) :=\n  by simp only [isOpenMap_iff_nhds_le, ← @map_map _ _ _ _ f g, ← hg.map_nhds_eq, map_le_map_iff hg.inj]\n#align open_embedding.is_open_map_iff OpenEmbedding.isOpenMap_iff\n-/\n\n",
 "isOpenMap":
 "#print OpenEmbedding.isOpenMap /-\ntheorem OpenEmbedding.isOpenMap {f : α → β} (hf : OpenEmbedding f) : IsOpenMap f :=\n  hf.to_embedding.to_inducing.is_open_map hf.open_range\n#align open_embedding.is_open_map OpenEmbedding.isOpenMap\n-/\n\n",
 "isClosed_preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n#print Inducing.isClosed_preimage /-\ntheorem Inducing.isClosed_preimage {f : α → β} (h : Inducing f) (s : Set β) (hs : IsClosed s) :\n    IsClosed («expr ⁻¹' » f s) :=\n  (Inducing.isClosed_iff h).mpr ⟨s, hs, rfl⟩\n#align inducing.is_closed_preimage Inducing.isClosed_preimage\n-/\n\n",
 "isClosed_iff'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n#print Inducing.isClosed_iff' /-\ntheorem Inducing.isClosed_iff' {f : α → β} (hf : Inducing f) {s : Set α} :\n    IsClosed s ↔ ∀ x, f x ∈ closure («expr '' » f s) → x ∈ s := by rw [hf.induced, isClosed_induced_iff']\n#align inducing.is_closed_iff' Inducing.isClosed_iff'\n-/\n\n",
 "isClosed_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n#print Inducing.isClosed_iff /-\ntheorem Inducing.isClosed_iff {f : α → β} (hf : Inducing f) {s : Set α} :\n    IsClosed s ↔ ∃ t, IsClosed t ∧ «expr ⁻¹' » f t = s := by rw [hf.induced, isClosed_induced_iff]\n#align inducing.is_closed_iff Inducing.isClosed_iff\n-/\n\n",
 "isClosedMap_iff_closure_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n#print isClosedMap_iff_closure_image /-\ntheorem isClosedMap_iff_closure_image [TopologicalSpace α] [TopologicalSpace β] {f : α → β} :\n    IsClosedMap f ↔ ∀ s, closure («expr '' » f s) ⊆ «expr '' » f (closure s) :=\n  ⟨IsClosedMap.closure_image_subset, fun hs c hc =>\n    isClosed_of_closure_subset <|\n      calc\n        closure («expr '' » f c) ⊆ «expr '' » f (closure c) := hs c\n        _ = «expr '' » f c := by rw [hc.closure_eq]\n        ⟩\n#align is_closed_map_iff_closure_image isClosedMap_iff_closure_image\n-/\n\n",
 "isClosedMap":
 "#print ClosedEmbedding.isClosedMap /-\ntheorem ClosedEmbedding.isClosedMap (hf : ClosedEmbedding f) : IsClosedMap f :=\n  hf.to_embedding.to_inducing.is_closed_map hf.closed_range\n#align closed_embedding.is_closed_map ClosedEmbedding.isClosedMap\n-/\n\n",
 "interior_preimage_subset_preimage_interior":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem interior_preimage_subset_preimage_interior (hf : IsOpenMap f) {s : Set β} :\n    interior («expr ⁻¹' » f s) ⊆ «expr ⁻¹' » f (interior s) :=\n  hf.maps_to_interior (mapsTo_preimage _ _)\n#align interior_preimage_subset_preimage_interior interior_preimage_subset_preimage_interior\n\n",
 "inducing_of_inducing_compose":
 "#print inducing_of_inducing_compose /-\ntheorem inducing_of_inducing_compose {f : α → β} {g : β → γ} (hf : Continuous f) (hg : Continuous g)\n    (hgf : Inducing (g ∘ f)) : Inducing f :=\n  ⟨le_antisymm (by rwa [← continuous_iff_le_induced])\n      (by\n        rw [hgf.induced, ← continuous_iff_le_induced]\n        apply hg.comp continuous_induced_dom)⟩\n#align inducing_of_inducing_compose inducing_of_inducing_compose\n-/\n\n",
 "inducing_iff_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print inducing_iff_nhds /-\ntheorem inducing_iff_nhds {f : α → β} : Inducing f ↔ ∀ a, (nhds) a = comap f ((nhds) (f a)) :=\n  (inducing_iff _).trans (induced_iff_nhds_eq f)\n#align inducing_iff_nhds inducing_iff_nhds\n-/\n\n",
 "inducing_iff":
 "#print Inducing.inducing_iff /-\nprotected theorem Inducing.inducing_iff {f : α → β} {g : β → γ} (hg : Inducing g) : Inducing f ↔ Inducing (g ∘ f) :=\n  by\n  refine' ⟨fun h => hg.comp h, fun hgf => inducing_of_inducing_compose _ hg.continuous hgf⟩\n  rw [hg.continuous_iff]\n  exact hgf.continuous\n#align inducing.inducing_iff Inducing.inducing_iff\n-/\n\n",
 "inducing_id":
 "#print inducing_id /-\n/-\nCopyright (c) 2017 Johannes Hölzl. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johannes Hölzl, Mario Carneiro, Patrick Massot\n-/\ntheorem inducing_id : Inducing (@id α) :=\n  ⟨induced_id.symm⟩\n#align inducing_id inducing_id\n-/\n\n",
 "image_mem_nhdsWithin":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n#print Inducing.image_mem_nhdsWithin /-\ntheorem Inducing.image_mem_nhdsWithin {f : α → β} (hf : Inducing f) {a : α} {s : Set α} (hs : s ∈ (nhds) a) :\n    «expr '' » f s ∈ nhds_within (range f) (f a) :=\n  hf.map_nhds_eq a ▸ image_mem_map hs\n#align inducing.image_mem_nhds_within Inducing.image_mem_nhdsWithin\n-/\n\n",
 "image_mem_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem image_mem_nhds (hf : IsOpenMap f) {x : α} {s : Set α} (hx : s ∈ (nhds) x) : «expr '' » f s ∈ (nhds) (f x) :=\n  let ⟨t, hts, ht, hxt⟩ := mem_nhds_iff.1 hx\n  mem_of_superset (IsOpen.mem_nhds (hf t ht) (mem_image_of_mem _ hxt)) (image_subset _ hts)\n#align image_mem_nhds image_mem_nhds\n\n",
 "image_interior_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem image_interior_subset (hf : IsOpenMap f) (s : Set α) : «expr '' » f (interior s) ⊆ interior («expr '' » f s) :=\n  (hf.maps_to_interior (mapsTo_image f s)).image_subset\n#align image_interior_subset image_interior_subset\n\n",
 "id":
 "#print id /-\nprotected theorem id : IsClosedMap (@id α) := fun s hs => by rwa [image_id]\n#align id id\n-/\n\n",
 "embedding_of_embedding_compose":
 "#print embedding_of_embedding_compose /-\ntheorem embedding_of_embedding_compose {f : α → β} {g : β → γ} (hf : Continuous f) (hg : Continuous g)\n    (hgf : Embedding (g ∘ f)) : Embedding f :=\n  { induced := (inducing_of_inducing_compose hf hg hgf.to_inducing).induced\n    inj := fun a₁ a₂ h => hgf.inj <| by simp [h, (· ∘ ·)] }\n#align embedding_of_embedding_compose embedding_of_embedding_compose\n-/\n\n",
 "embedding_induced":
 "#print Function.Injective.embedding_induced /-\ntheorem Function.Injective.embedding_induced [t : TopologicalSpace β] {f : α → β} (hf : injective f) :\n    @Embedding α β (t.induced f) t f :=\n  { induced := rfl\n    inj := hf }\n#align function.injective.embedding_induced Function.Injective.embedding_induced\n-/\n\n",
 "embedding_id":
 "#print embedding_id /-\ntheorem embedding_id : Embedding (@id α) :=\n  ⟨inducing_id, fun a₁ a₂ h => h⟩\n#align embedding_id embedding_id\n-/\n\n",
 "embedding":
 "#print Function.LeftInverse.embedding /-\nprotected theorem Function.LeftInverse.embedding {f : α → β} {g : β → α} (h : left_inverse f g) (hf : Continuous f)\n    (hg : Continuous g) : Embedding g :=\n  embedding_of_embedding_compose hg hf <| h.comp_eq_id.symm ▸ embedding_id\n#align function.left_inverse.embedding Function.LeftInverse.embedding\n-/\n\n",
 "discreteTopology":
 "#print Embedding.discreteTopology /-\n/-- The topology induced under an inclusion `f : X → Y` from the discrete topological space `Y`\nis the discrete topology on `X`. -/\ntheorem Embedding.discreteTopology {X Y : Type _} [TopologicalSpace X] [tY : TopologicalSpace Y] [DiscreteTopology Y]\n    {f : X → Y} (hf : Embedding f) : DiscreteTopology X :=\n  discreteTopology_iff_nhds.2 fun x => by\n    rw [hf.nhds_eq_comap, nhds_discrete, comap_pure, ← image_singleton, hf.inj.preimage_image, principal_singleton]\n#align embedding.discrete_topology Embedding.discreteTopology\n-/\n\n",
 "dense_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n#print Inducing.dense_iff /-\ntheorem Inducing.dense_iff {f : α → β} (hf : Inducing f) {s : Set α} : Dense s ↔ ∀ x, f x ∈ closure («expr '' » f s) :=\n  by simp only [Dense, hf.closure_eq_preimage_closure_image, mem_preimage]\n#align inducing.dense_iff Inducing.dense_iff\n-/\n\n",
 "continuous_iff":
 "protected theorem continuous_iff (hf : QuotientMap f) : Continuous g ↔ Continuous (g ∘ f) := by\n  rw [continuous_iff_coinduced_le, continuous_iff_coinduced_le, hf.right, coinduced_compose]\n#align continuous_iff continuous_iff\n\n",
 "continuousAt_iff'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print Inducing.continuousAt_iff' /-\ntheorem Inducing.continuousAt_iff' {f : α → β} {g : β → γ} (hf : Inducing f) {x : α} (h : range f ∈ (nhds) (f x)) :\n    ContinuousAt (g ∘ f) x ↔ ContinuousAt g (f x) := by\n  simp_rw [ContinuousAt, Filter.Tendsto, ← hf.map_nhds_of_mem _ h, Filter.map_map]\n#align inducing.continuous_at_iff' Inducing.continuousAt_iff'\n-/\n\n",
 "continuousAt_iff":
 "#print Inducing.continuousAt_iff /-\ntheorem Inducing.continuousAt_iff {f : α → β} {g : β → γ} (hg : Inducing g) {x : α} :\n    ContinuousAt f x ↔ ContinuousAt (g ∘ f) x := by simp_rw [ContinuousAt, Inducing.tendsto_nhds_iff hg]\n#align inducing.continuous_at_iff Inducing.continuousAt_iff\n-/\n\n",
 "continuous":
 "#print ClosedEmbedding.continuous /-\ntheorem ClosedEmbedding.continuous (hf : ClosedEmbedding f) : Continuous f :=\n  hf.to_embedding.continuous\n#align closed_embedding.continuous ClosedEmbedding.continuous\n-/\n\n",
 "comp":
 "#print ClosedEmbedding.comp /-\ntheorem ClosedEmbedding.comp {g : β → γ} {f : α → β} (hg : ClosedEmbedding g) (hf : ClosedEmbedding f) :\n    ClosedEmbedding (g ∘ f) :=\n  ⟨hg.to_embedding.comp hf.to_embedding,\n    show IsClosed (range (g ∘ f)) by rw [range_comp, ← hg.closed_iff_image_closed] <;> exact hf.closed_range⟩\n#align closed_embedding.comp ClosedEmbedding.comp\n-/\n\n",
 "closure_image_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem closure_image_subset {f : α → β} (hf : IsClosedMap f) (s : Set α) :\n    closure («expr '' » f s) ⊆ «expr '' » f (closure s) :=\n  closure_minimal (image_subset _ subset_closure) (hf _ isClosed_closure)\n#align closure_image_subset closure_image_subset\n\n",
 "closure_image_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n#print ClosedEmbedding.closure_image_eq /-\ntheorem ClosedEmbedding.closure_image_eq {f : α → β} (hf : ClosedEmbedding f) (s : Set α) :\n    closure («expr '' » f s) = «expr '' » f (closure s) :=\n  (hf.is_closed_map.closure_image_subset _).antisymm (image_closure_subset_closure_image hf.continuous)\n#align closed_embedding.closure_image_eq ClosedEmbedding.closure_image_eq\n-/\n\n",
 "closure_eq_preimage_closure_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n#print Embedding.closure_eq_preimage_closure_image /-\ntheorem Embedding.closure_eq_preimage_closure_image {e : α → β} (he : Embedding e) (s : Set α) :\n    closure s = «expr ⁻¹' » e (closure («expr '' » e s)) :=\n  he.1.closure_eq_preimage_closure_image s\n#align embedding.closure_eq_preimage_closure_image Embedding.closure_eq_preimage_closure_image\n-/\n\n",
 "closed_range":
 "theorem closed_range {f : α → β} (hf : IsClosedMap f) : IsClosed (range f) :=\n  @image_univ _ _ f ▸ hf _ isClosed_univ\n#align closed_range closed_range\n\n",
 "closed_iff_preimage_closed":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n#print ClosedEmbedding.closed_iff_preimage_closed /-\ntheorem ClosedEmbedding.closed_iff_preimage_closed (hf : ClosedEmbedding f) {s : Set β} (hs : s ⊆ range f) :\n    IsClosed s ↔ IsClosed («expr ⁻¹' » f s) :=\n  by\n  convert← hf.closed_iff_image_closed.symm\n  rwa [image_preimage_eq_inter_range, inter_eq_self_of_subset_left]\n#align closed_embedding.closed_iff_preimage_closed ClosedEmbedding.closed_iff_preimage_closed\n-/\n\n",
 "closed_iff_image_closed":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n#print ClosedEmbedding.closed_iff_image_closed /-\ntheorem ClosedEmbedding.closed_iff_image_closed (hf : ClosedEmbedding f) {s : Set α} :\n    IsClosed s ↔ IsClosed («expr '' » f s) :=\n  ⟨hf.is_closed_map s, fun h => by\n    convert← continuous_iff_is_closed.mp hf.continuous _ h\n    apply preimage_image_eq _ hf.inj⟩\n#align closed_embedding.closed_iff_image_closed ClosedEmbedding.closed_iff_image_closed\n-/\n\n",
 "closedEmbedding_of_embedding_closed":
 "#print closedEmbedding_of_embedding_closed /-\ntheorem closedEmbedding_of_embedding_closed (h₁ : Embedding f) (h₂ : IsClosedMap f) : ClosedEmbedding f :=\n  ⟨h₁, by convert h₂ univ isClosed_univ <;> simp⟩\n#align closed_embedding_of_embedding_closed closedEmbedding_of_embedding_closed\n-/\n\n",
 "closedEmbedding_of_continuous_injective_closed":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n#print closedEmbedding_of_continuous_injective_closed /-\ntheorem closedEmbedding_of_continuous_injective_closed (h₁ : Continuous f) (h₂ : injective f) (h₃ : IsClosedMap f) :\n    ClosedEmbedding f := by\n  refine' closedEmbedding_of_embedding_closed ⟨⟨_⟩, h₂⟩ h₃\n  apply le_antisymm (continuous_iff_le_induced.mp h₁) _\n  intro s'\n  change IsOpen _ ≤ IsOpen _\n  rw [← isClosed_compl_iff, ← isClosed_compl_iff]\n  generalize «expr ᶜ» s' = s\n  rw [isClosed_induced_iff]\n  refine' fun hs => ⟨«expr '' » f s, h₃ s hs, _⟩\n  rw [preimage_image_eq _ h₂]\n#align closed_embedding_of_continuous_injective_closed closedEmbedding_of_continuous_injective_closed\n-/\n\n",
 "closedEmbedding_id":
 "#print closedEmbedding_id /-\ntheorem closedEmbedding_id : ClosedEmbedding (@id α) :=\n  ⟨embedding_id, by convert isClosed_univ <;> apply range_id⟩\n#align closed_embedding_id closedEmbedding_id\n-/\n\n",
 "Continuous":
 "#print Continuous /-\nprotected theorem Continuous (hf : QuotientMap f) : Continuous f :=\n  hf.continuous_iff.mp continuous_id\n#align continuous Continuous\n-/\n\n"}