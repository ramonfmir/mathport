{"zero_section_snd":
 "@[simp, mfld_simps]\ntheorem zero_section_snd [∀ x, Zero (E x)] (x : B) : (zero_section E x).2 = 0 :=\n  rfl\n#align zero_section_snd zero_section_snd\n\n",
 "zero_section_proj":
 "@[simp, mfld_simps]\ntheorem zero_section_proj [∀ x, Zero (E x)] (x : B) : (zero_section E x).proj = x :=\n  rfl\n#align zero_section_proj zero_section_proj\n\n",
 "zero_section":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprπ -/\nprotected theorem zero_section (e : Trivialization F ((exprπ) E)) [e.is_linear R] {x : B} (hx : x ∈ e.base_set) :\n    e (zero_section E x) = (x, 0) := by\n  simp_rw [zero_section, total_space_mk, e.apply_eq_prod_continuous_linear_equiv_at R x hx 0, map_zero]\n#align zero_section zero_section\n\n",
 "trivialization_at_symmL":
 "@[simp, mfld_simps]\ntheorem trivialization_at_symmL {b₀ b : B} (hb : b ∈ (trivialization_at F Z.fiber b₀).base_set) :\n    (trivialization_at F Z.fiber b₀).symmL R b = Z.coord_change (Z.index_at b₀) (Z.index_at b) b :=\n  Z.local_triv_symmL hb\n#align trivialization_at_symmL trivialization_at_symmL\n\n",
 "trivialization_at_coord_change_eq":
 "@[simp, mfld_simps]\ntheorem trivialization_at_coord_change_eq {b₀ b₁ b : B}\n    (hb : b ∈ (trivialization_at F Z.fiber b₀).base_set ∩ (trivialization_at F Z.fiber b₁).base_set) (v : F) :\n    (trivialization_at F Z.fiber b₀).coord_changeL R (trivialization_at F Z.fiber b₁) b v =\n      Z.coord_change (Z.index_at b₀) (Z.index_at b₁) b v :=\n  Z.local_triv_coord_change_eq _ _ hb v\n#align trivialization_at_coord_change_eq trivialization_at_coord_change_eq\n\n",
 "trivialization_at_continuous_linear_map_at":
 "@[simp, mfld_simps]\ntheorem trivialization_at_continuous_linear_map_at {b₀ b : B} (hb : b ∈ (trivialization_at F Z.fiber b₀).base_set) :\n    (trivialization_at F Z.fiber b₀).continuous_linear_map_at R b = Z.coord_change (Z.index_at b) (Z.index_at b₀) b :=\n  Z.local_triv_continuous_linear_map_at hb\n#align trivialization_at_continuous_linear_map_at trivialization_at_continuous_linear_map_at\n\n",
 "total_space_mk_preimage_source":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n@[simp]\ntheorem total_space_mk_preimage_source (b : B) :\n    «expr ⁻¹' » (totalSpaceMk b) (a.pretrivialization_at b).source = univ :=\n  a.to_fiber_prebundle.total_space_mk_preimage_source b\n#align total_space_mk_preimage_source total_space_mk_preimage_source\n\n",
 "to_vector_bundle":
 "/-- Make a `vector_bundle` from a `vector_prebundle`.  Concretely this means\nthat, given a `vector_prebundle` structure for a sigma-type `E` -- which consists of a\nnumber of \"pretrivializations\" identifying parts of `E` with product spaces `U × F` -- one\nestablishes that for the topology constructed on the sigma-type using\n`vector_prebundle.total_space_topology`, these \"pretrivializations\" are actually\n\"trivializations\" (i.e., homeomorphisms with respect to the constructed topology). -/\ntheorem to_vector_bundle :\n    @vector_bundle R _ F E _ _ _ _ _ _ a.total_space_topology a.fiber_topology a.to_fiber_bundle :=\n  { trivialization_linear' := by\n      rintro _ ⟨e, he, rfl⟩\n      apply linear_of_mem_pretrivialization_atlas\n    continuous_on_coord_change' := by\n      rintro _ _ ⟨e, he, rfl⟩ ⟨e', he', rfl⟩\n      refine' (a.continuous_on_coord_change he he').congr _\n      intro b hb\n      ext v\n      rw [a.coord_change_apply he he' hb v, ContinuousLinearEquiv.coe_coe, trivialization.coord_changeL_apply]\n      exacts[rfl, hb] }\n#align to_vector_bundle to_vector_bundle\n\n",
 "symmₗ_linear_map_at":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprπ -/\ntheorem symmₗ_linear_map_at (e : Trivialization F ((exprπ) E)) [e.is_linear R] {b : B} (hb : b ∈ e.base_set) (y : E b) :\n    e.symmₗ R b (e.linear_map_at R b y) = y :=\n  e.to_pretrivialization.symmₗ_linear_map_at hb y\n#align symmₗ_linear_map_at symmₗ_linear_map_at\n\n",
 "symm_coord_changeL":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprπ -/\ntheorem symm_coord_changeL (e e' : Trivialization F ((exprπ) E)) [e.is_linear R] [e'.is_linear R] {b : B}\n    (hb : b ∈ e'.base_set ∩ e.base_set) : (e.coord_changeL R e' b).symm = e'.coord_changeL R e b :=\n  by\n  apply ContinuousLinearEquiv.toLinearEquiv_injective\n  rw [coe_coord_changeL' e' e hb, (coord_changeL R e e' b).symm_to_linear_equiv, coe_coord_changeL' e e' hb.symm,\n    LinearEquiv.trans_symm, LinearEquiv.symm_symm]\n#align symm_coord_changeL symm_coord_changeL\n\n",
 "symm_continuous_linear_equiv_at_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprπ -/\ntheorem symm_continuous_linear_equiv_at_eq (e : Trivialization F ((exprπ) E)) [e.is_linear R] {b : B}\n    (hb : b ∈ e.base_set) : ((e.continuous_linear_equiv_at R b hb).symm : F → E b) = e.symmL R b :=\n  rfl\n#align symm_continuous_linear_equiv_at_eq symm_continuous_linear_equiv_at_eq\n\n",
 "symm_apply_eq_mk_continuous_linear_equiv_at_symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprπ -/\ntheorem symm_apply_eq_mk_continuous_linear_equiv_at_symm (e : Trivialization F ((exprπ) E)) [e.is_linear R] (b : B)\n    (hb : b ∈ e.base_set) (z : F) :\n    e.to_local_homeomorph.symm ⟨b, z⟩ = totalSpaceMk b ((e.continuous_linear_equiv_at R b hb).symm z) :=\n  by\n  have h : (b, z) ∈ e.target := by\n    rw [e.target_eq]\n    exact ⟨hb, mem_univ _⟩\n  apply e.inj_on (e.map_target h)\n  · simp only [e.source_eq, hb, mem_preimage]\n  simp_rw [e.right_inv h, coe_coe, e.apply_eq_prod_continuous_linear_equiv_at R b hb,\n    ContinuousLinearEquiv.apply_symm_apply]\n#align symm_apply_eq_mk_continuous_linear_equiv_at_symm symm_apply_eq_mk_continuous_linear_equiv_at_symm\n\n",
 "symmL_continuous_linear_map_at":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprπ -/\n-- given explicitly to help `simps`\n-- given explicitly to help `simps`\ntheorem symmL_continuous_linear_map_at (e : Trivialization F ((exprπ) E)) [e.is_linear R] {b : B} (hb : b ∈ e.base_set)\n    (y : E b) : e.symmL R b (e.continuous_linear_map_at R b y) = y :=\n  e.symmₗ_linear_map_at hb y\n#align symmL_continuous_linear_map_at symmL_continuous_linear_map_at\n\n",
 "mk_coord_changeL":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprπ -/\ntheorem mk_coord_changeL (e e' : Trivialization F ((exprπ) E)) [e.is_linear R] [e'.is_linear R] {b : B}\n    (hb : b ∈ e.base_set ∩ e'.base_set) (y : F) : (b, coord_changeL R e e' b y) = e' (totalSpaceMk b (e.symm b y)) :=\n  by\n  ext\n  · rw [e.mk_symm hb.1 y, e'.coe_fst', e.proj_symm_apply' hb.1]\n    rw [e.proj_symm_apply' hb.1]\n    exact hb.2\n  · exact e.coord_changeL_apply e' hb y\n#align mk_coord_changeL mk_coord_changeL\n\n",
 "mk_coord_change":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprπ -/\ntheorem mk_coord_change (a : vector_prebundle R F E) {e e' : Pretrivialization F ((exprπ) E)}\n    (he : e ∈ a.pretrivialization_atlas) (he' : e' ∈ a.pretrivialization_atlas) {b : B}\n    (hb : b ∈ e.base_set ∩ e'.base_set) (v : F) : (b, a.coord_change he he' b v) = e' (totalSpaceMk b (e.symm b v)) :=\n  by\n  ext\n  · rw [e.mk_symm hb.1 v, e'.coe_fst', e.proj_symm_apply' hb.1]\n    rw [e.proj_symm_apply' hb.1]\n    exact hb.2\n  · exact a.coord_change_apply he he' hb v\n#align mk_coord_change mk_coord_change\n\n",
 "mem_trivialization_at_source":
 "theorem mem_trivialization_at_source (b : B) (x : E b) : totalSpaceMk b x ∈ (a.pretrivialization_at b).source :=\n  a.to_fiber_prebundle.mem_trivialization_at_source b x\n#align mem_trivialization_at_source mem_trivialization_at_source\n\n",
 "mem_triv_change_source":
 "@[simp, mfld_simps]\ntheorem mem_triv_change_source (i j : ι) (p : B × F) :\n    p ∈ (Z.triv_change i j).source ↔ p.1 ∈ Z.base_set i ∩ Z.base_set j :=\n  FiberBundleCore.mem_trivChange_source (↑Z) i j p\n#align mem_triv_change_source mem_triv_change_source\n\n",
 "mem_source_at":
 "@[simp, mfld_simps]\ntheorem mem_source_at : (⟨b, a⟩ : Z.total_space) ∈ (Z.local_triv_at b).source :=\n  by\n  rw [local_triv_at, mem_local_triv_source]\n  exact Z.mem_base_set_at b\n#align mem_source_at mem_source_at\n\n",
 "mem_local_triv_target":
 "@[simp, mfld_simps]\ntheorem mem_local_triv_target (p : B × F) : p ∈ (Z.local_triv i).target ↔ p.1 ∈ (Z.local_triv i).base_set :=\n  Z.to_fiber_bundle_core.mem_local_triv_target i p\n#align mem_local_triv_target mem_local_triv_target\n\n",
 "mem_local_triv_source":
 "@[simp, mfld_simps]\ntheorem mem_local_triv_source (p : Z.total_space) : p ∈ (Z.local_triv i).source ↔ p.1 ∈ Z.base_set i := by\n  dsimp [vector_bundle_core.fiber] <;> exact iff.rfl\n#align mem_local_triv_source mem_local_triv_source\n\n",
 "mem_local_triv_at_base_set":
 "@[simp, mfld_simps]\ntheorem mem_local_triv_at_base_set : b ∈ (Z.local_triv_at b).base_set :=\n  FiberBundleCore.mem_localTrivAt_baseSet Z b\n#align mem_local_triv_at_base_set mem_local_triv_at_base_set\n\n",
 "local_triv_symm_fst":
 "@[simp, mfld_simps]\ntheorem local_triv_symm_fst (p : B × F) :\n    (Z.local_triv i).to_local_homeomorph.symm p = ⟨p.1, Z.coord_change i (Z.index_at p.1) p.1 p.2⟩ :=\n  rfl\n#align local_triv_symm_fst local_triv_symm_fst\n\n",
 "local_triv_symm_apply":
 "@[simp, mfld_simps]\ntheorem local_triv_symm_apply {b : B} (hb : b ∈ Z.base_set i) (v : F) :\n    (Z.local_triv i).symm b v = Z.coord_change i (Z.index_at b) b v := by apply (Z.local_triv i).symm_apply hb v\n#align local_triv_symm_apply local_triv_symm_apply\n\n",
 "local_triv_symmL":
 "@[simp, mfld_simps]\ntheorem local_triv_symmL {b : B} (hb : b ∈ Z.base_set i) :\n    (Z.local_triv i).symmL R b = Z.coord_change i (Z.index_at b) b :=\n  by\n  ext1 v\n  rw [(Z.local_triv i).symmL_apply R, (Z.local_triv i).symm_apply]\n  exacts[rfl, hb]\n#align local_triv_symmL local_triv_symmL\n\n",
 "local_triv_coord_change_eq":
 "@[simp, mfld_simps]\ntheorem local_triv_coord_change_eq {b : B} (hb : b ∈ Z.base_set i ∩ Z.base_set j) (v : F) :\n    (Z.local_triv i).coord_changeL R (Z.local_triv j) b v = Z.coord_change i j b v :=\n  by\n  rw [trivialization.coord_changeL_apply', local_triv_symm_fst, local_triv_apply, coord_change_comp]\n  exacts[⟨⟨hb.1, Z.mem_base_set_at b⟩, hb.2⟩, hb]\n#align local_triv_coord_change_eq local_triv_coord_change_eq\n\n",
 "local_triv_continuous_linear_map_at":
 "@[simp, mfld_simps]\ntheorem local_triv_continuous_linear_map_at {b : B} (hb : b ∈ Z.base_set i) :\n    (Z.local_triv i).continuous_linear_map_at R b = Z.coord_change (Z.index_at b) i b :=\n  by\n  ext1 v\n  rw [(Z.local_triv i).continuous_linear_map_at_apply R, (Z.local_triv i).coe_linear_map_at_of_mem]\n  exacts[rfl, hb]\n#align local_triv_continuous_linear_map_at local_triv_continuous_linear_map_at\n\n",
 "local_triv_at_def":
 "@[simp, mfld_simps]\ntheorem local_triv_at_def : Z.local_triv (Z.index_at b) = Z.local_triv_at b :=\n  rfl\n#align local_triv_at_def local_triv_at_def\n\n",
 "local_triv_at_apply_mk":
 "@[simp, mfld_simps]\ntheorem local_triv_at_apply_mk (b : B) (a : F) : (Z.local_triv_at b) ⟨b, a⟩ = ⟨b, a⟩ :=\n  Z.local_triv_at_apply _\n#align local_triv_at_apply_mk local_triv_at_apply_mk\n\n",
 "local_triv_at_apply":
 "@[simp, mfld_simps]\ntheorem local_triv_at_apply (p : Z.total_space) : (Z.local_triv_at p.1) p = ⟨p.1, p.2⟩ :=\n  FiberBundleCore.localTrivAt_apply Z p\n#align local_triv_at_apply local_triv_at_apply\n\n",
 "local_triv_apply":
 "@[simp, mfld_simps]\ntheorem local_triv_apply (p : Z.total_space) : (Z.local_triv i) p = ⟨p.1, Z.coord_change (Z.index_at p.1) i p.1 p.2⟩ :=\n  rfl\n#align local_triv_apply local_triv_apply\n\n",
 "linear_of_mem_pretrivialization_atlas":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprπ -/\ntheorem linear_of_mem_pretrivialization_atlas (a : vector_prebundle R F E) {e : Pretrivialization F ((exprπ) E)}\n    (he : e ∈ a.pretrivialization_atlas) :\n    @trivialization.is_linear R B F _ _ _ _ a.total_space_topology _ _ _ _\n      (trivialization_of_mem_pretrivialization_atlas a he) :=\n  { linear := (a.pretrivialization_linear' e he).linear }\n#align linear_of_mem_pretrivialization_atlas linear_of_mem_pretrivialization_atlas\n\n",
 "linear_map_at_symmₗ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprπ -/\ntheorem linear_map_at_symmₗ (e : Trivialization F ((exprπ) E)) [e.is_linear R] {b : B} (hb : b ∈ e.base_set) (y : F) :\n    e.linear_map_at R b (e.symmₗ R b y) = y :=\n  e.to_pretrivialization.linear_map_at_symmₗ hb y\n#align linear_map_at_symmₗ linear_map_at_symmₗ\n\n",
 "linear_map_at_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprπ -/\ntheorem linear_map_at_eq_zero (e : Pretrivialization F ((exprπ) E)) [e.is_linear R] {b : B} (hb : b ∉ e.base_set) :\n    e.linear_map_at R b = 0 :=\n  dif_neg hb\n#align linear_map_at_eq_zero linear_map_at_eq_zero\n\n",
 "linear_map_at_def_of_not_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprπ -/\ntheorem linear_map_at_def_of_not_mem (e : Trivialization F ((exprπ) E)) [e.is_linear R] {b : B} (hb : b ∉ e.base_set) :\n    e.linear_map_at R b = 0 :=\n  dif_neg hb\n#align linear_map_at_def_of_not_mem linear_map_at_def_of_not_mem\n\n",
 "linear_map_at_def_of_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprπ -/\ntheorem linear_map_at_def_of_mem (e : Trivialization F ((exprπ) E)) [e.is_linear R] {b : B} (hb : b ∈ e.base_set) :\n    e.linear_map_at R b = e.linear_equiv_at R b hb :=\n  dif_pos hb\n#align linear_map_at_def_of_mem linear_map_at_def_of_mem\n\n",
 "linear_map_at_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprπ -/\ntheorem linear_map_at_apply (e : Trivialization F ((exprπ) E)) [e.is_linear R] {b : B} (y : E b) :\n    e.linear_map_at R b y = if b ∈ e.base_set then (e (totalSpaceMk b y)).2 else 0 := by rw [coe_linear_map_at]\n#align linear_map_at_apply linear_map_at_apply\n\n",
 "linear_equiv_at_symm_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprπ -/\n@[simp]\ntheorem linear_equiv_at_symm_apply (e : Trivialization F ((exprπ) E)) [e.is_linear R] (b : B) (hb : b ∈ e.base_set)\n    (v : F) : (e.linear_equiv_at R b hb).symm v = e.symm b v :=\n  rfl\n#align linear_equiv_at_symm_apply linear_equiv_at_symm_apply\n\n",
 "linear_equiv_at_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprπ -/\n@[simp]\ntheorem linear_equiv_at_apply (e : Trivialization F ((exprπ) E)) [e.is_linear R] (b : B) (hb : b ∈ e.base_set)\n    (v : E b) : e.linear_equiv_at R b hb v = (e (totalSpaceMk b v)).2 :=\n  rfl\n#align linear_equiv_at_apply linear_equiv_at_apply\n\n",
 "linear":
 "protected theorem linear [AddCommMonoid F] [Module R F] [∀ x, AddCommMonoid (E x)] [∀ x, Module R (E x)] [e.is_linear R]\n    {b : B} (hb : b ∈ e.base_set) : IsLinearMap R fun y : E b => (e (totalSpaceMk b y)).2 :=\n  trivialization.is_linear.linear b hb\n#align linear linear\n\n",
 "is_open_map_proj":
 "/-- The projection on the base of a vector bundle created from core is an open map -/\ntheorem is_open_map_proj : IsOpenMap Z.proj :=\n  FiberBundleCore.isOpenMap_proj Z\n#align is_open_map_proj is_open_map_proj\n\n",
 "inducing_total_space_mk":
 "@[continuity]\ntheorem inducing_total_space_mk (b : B) : @Inducing _ _ (a.fiber_topology b) a.total_space_topology (totalSpaceMk b) :=\n  a.to_fiber_prebundle.inducing_total_space_mk b\n#align inducing_total_space_mk inducing_total_space_mk\n\n",
 "in_coordinates_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n/-- rewrite `in_coordinates` in a `vector_bundle_core`. -/\nprotected theorem vector_bundle_core.in_coordinates_eq {ι ι'} (Z : vector_bundle_core 𝕜₁ B F ι)\n    (Z' : vector_bundle_core 𝕜₂ B' F' ι') {x₀ x : B} {y₀ y : B'} (ϕ : «expr →SL[ ] » F σ F')\n    (hx : x ∈ Z.base_set (Z.index_at x₀)) (hy : y ∈ Z'.base_set (Z'.index_at y₀)) :\n    in_coordinates F Z.fiber F' Z'.fiber x₀ x y₀ y ϕ =\n      (Z'.coord_change (Z'.index_at y) (Z'.index_at y₀) y).comp\n        (ϕ.comp <| Z.coord_change (Z.index_at x₀) (Z.index_at x) x) :=\n  by simp_rw [in_coordinates, Z'.trivialization_at_continuous_linear_map_at hy, Z.trivialization_at_symmL hx]\n#align vector_bundle_core.in_coordinates_eq vector_bundle_core.in_coordinates_eq\n\n",
 "coord_change_linear_comp":
 "theorem coord_change_linear_comp (i j k : ι) :\n    ∀ x ∈ Z.base_set i ∩ Z.base_set j ∩ Z.base_set k,\n      (Z.coord_change j k x).comp (Z.coord_change i j x) = Z.coord_change i k x :=\n  fun x hx => by\n  ext v\n  exact Z.coord_change_comp i j k x hx v\n#align coord_change_linear_comp coord_change_linear_comp\n\n",
 "coord_change_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprπ -/\ntheorem coord_change_apply (a : vector_prebundle R F E) {e e' : Pretrivialization F ((exprπ) E)}\n    (he : e ∈ a.pretrivialization_atlas) (he' : e' ∈ a.pretrivialization_atlas) {b : B}\n    (hb : b ∈ e.base_set ∩ e'.base_set) (v : F) : a.coord_change he he' b v = (e' (totalSpaceMk b (e.symm b v))).2 :=\n  (Classical.choose_spec (a.exists_coord_change e he e' he')).2 b hb v\n#align coord_change_apply coord_change_apply\n\n",
 "coord_changeL_symm_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprπ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\ntheorem coord_changeL_symm_apply (e e' : Trivialization F ((exprπ) E)) [e.is_linear R] [e'.is_linear R] {b : B}\n    (hb : b ∈ e.base_set ∩ e'.base_set) :\n    «expr⇑ » (coord_changeL R e e' b).symm = (e'.linear_equiv_at R b hb.2).symm.trans (e.linear_equiv_at R b hb.1) :=\n  congr_arg linear_equiv.inv_fun (dif_pos hb)\n#align coord_changeL_symm_apply coord_changeL_symm_apply\n\n",
 "coord_changeL_apply'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprπ -/\n/-- A version of `coord_change_apply` that fully unfolds `coord_change`. The right-hand side is\nugly, but has good definitional properties for specifically defined trivializations. -/\ntheorem coord_changeL_apply' (e e' : Trivialization F ((exprπ) E)) [e.is_linear R] [e'.is_linear R] {b : B}\n    (hb : b ∈ e.base_set ∩ e'.base_set) (y : F) :\n    coord_changeL R e e' b y = (e' (e.to_local_homeomorph.symm (b, y))).2 := by\n  rw [e.coord_changeL_apply e' hb, e.mk_symm hb.1]\n#align coord_changeL_apply' coord_changeL_apply'\n\n",
 "coord_changeL_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprπ -/\ntheorem coord_changeL_apply (e e' : Trivialization F ((exprπ) E)) [e.is_linear R] [e'.is_linear R] {b : B}\n    (hb : b ∈ e.base_set ∩ e'.base_set) (y : F) : coord_changeL R e e' b y = (e' (totalSpaceMk b (e.symm b y))).2 :=\n  congr_arg (fun f => linear_equiv.to_fun f y) (dif_pos hb)\n#align coord_changeL_apply coord_changeL_apply\n\n",
 "continuous_total_space_mk":
 "@[continuity]\ntheorem continuous_total_space_mk (b : B) :\n    @Continuous _ _ (a.fiber_topology b) a.total_space_topology (totalSpaceMk b) :=\n  a.to_fiber_prebundle.continuous_total_space_mk b\n#align continuous_total_space_mk continuous_total_space_mk\n\n",
 "continuous_proj":
 "/-- The projection on the base of a vector bundle created from core is continuous -/\n@[continuity]\ntheorem continuous_proj : Continuous Z.proj :=\n  FiberBundleCore.continuous_proj Z\n#align continuous_proj continuous_proj\n\n",
 "continuous_on_coord_change":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprπ -/\ntheorem continuous_on_coord_change (a : vector_prebundle R F E) {e e' : Pretrivialization F ((exprπ) E)}\n    (he : e ∈ a.pretrivialization_atlas) (he' : e' ∈ a.pretrivialization_atlas) :\n    ContinuousOn (a.coord_change he he') (e.base_set ∩ e'.base_set) :=\n  (Classical.choose_spec (a.exists_coord_change e he e' he')).1\n#align continuous_on_coord_change continuous_on_coord_change\n\n",
 "continuous_linear_map_at_symmL":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprπ -/\ntheorem continuous_linear_map_at_symmL (e : Trivialization F ((exprπ) E)) [e.is_linear R] {b : B} (hb : b ∈ e.base_set)\n    (y : F) : e.continuous_linear_map_at R b (e.symmL R b y) = y :=\n  e.linear_map_at_symmₗ hb y\n#align continuous_linear_map_at_symmL continuous_linear_map_at_symmL\n\n",
 "continuous_linear_equiv_at_apply'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprπ -/\n@[simp]\ntheorem continuous_linear_equiv_at_apply' (e : Trivialization F ((exprπ) E)) [e.is_linear R] (x : TotalSpace E)\n    (hx : x ∈ e.source) : e.continuous_linear_equiv_at R x.proj (e.mem_source.1 hx) x.2 = (e x).2 :=\n  by\n  cases x\n  rfl\n#align continuous_linear_equiv_at_apply' continuous_linear_equiv_at_apply'\n\n",
 "comp_continuous_linear_equiv_at_eq_coord_change":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprπ -/\ntheorem comp_continuous_linear_equiv_at_eq_coord_change (e e' : Trivialization F ((exprπ) E)) [e.is_linear R]\n    [e'.is_linear R] {b : B} (hb : b ∈ e.base_set ∩ e'.base_set) :\n    (e.continuous_linear_equiv_at R b hb.1).symm.trans (e'.continuous_linear_equiv_at R b hb.2) =\n      coord_changeL R e e' b :=\n  by\n  ext v\n  rw [coord_changeL_apply e e' hb]\n  rfl\n#align comp_continuous_linear_equiv_at_eq_coord_change comp_continuous_linear_equiv_at_eq_coord_change\n\n",
 "coe_symmₗ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprπ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\ntheorem coe_symmₗ (e : Trivialization F ((exprπ) E)) [e.is_linear R] (b : B) : «expr⇑ » (e.symmₗ R b) = e.symm b :=\n  rfl\n#align coe_symmₗ coe_symmₗ\n\n",
 "coe_linear_map_at_of_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprπ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\ntheorem coe_linear_map_at_of_mem (e : Trivialization F ((exprπ) E)) [e.is_linear R] {b : B} (hb : b ∈ e.base_set) :\n    «expr⇑ » (e.linear_map_at R b) = fun y => (e (totalSpaceMk b y)).2 := by simp_rw [coe_linear_map_at, if_pos hb]\n#align coe_linear_map_at_of_mem coe_linear_map_at_of_mem\n\n",
 "coe_linear_map_at":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprπ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\ntheorem coe_linear_map_at (e : Trivialization F ((exprπ) E)) [e.is_linear R] (b : B) :\n    «expr⇑ » (e.linear_map_at R b) = fun y => if b ∈ e.base_set then (e (totalSpaceMk b y)).2 else 0 :=\n  e.to_pretrivialization.coe_linear_map_at b\n#align coe_linear_map_at coe_linear_map_at\n\n",
 "coe_coord_changeL'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprπ -/\ntheorem coe_coord_changeL' (e e' : Trivialization F ((exprπ) E)) [e.is_linear R] [e'.is_linear R] {b : B}\n    (hb : b ∈ e.base_set ∩ e'.base_set) :\n    (coord_changeL R e e' b).to_linear_equiv = (e.linear_equiv_at R b hb.1).symm.trans (e'.linear_equiv_at R b hb.2) :=\n  LinearEquiv.coe_injective (coe_coord_changeL _ _ _)\n#align coe_coord_changeL' coe_coord_changeL'\n\n",
 "coe_coord_changeL":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprπ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\ntheorem coe_coord_changeL (e e' : Trivialization F ((exprπ) E)) [e.is_linear R] [e'.is_linear R] {b : B}\n    (hb : b ∈ e.base_set ∩ e'.base_set) :\n    «expr⇑ » (coord_changeL R e e' b) = (e.linear_equiv_at R b hb.1).symm.trans (e'.linear_equiv_at R b hb.2) :=\n  congr_arg linear_equiv.to_fun (dif_pos hb)\n#align coe_coord_changeL coe_coord_changeL\n\n",
 "coe_coord_change":
 "@[simp, mfld_simps]\ntheorem coe_coord_change (i j : ι) : Z.to_fiber_bundle_core.coord_change i j b = Z.coord_change i j b :=\n  rfl\n#align coe_coord_change coe_coord_change\n\n",
 "coe_continuous_linear_equiv_at_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprπ -/\n-- given explicitly to help `simps`\n-- given explicitly to help `simps`\ntheorem coe_continuous_linear_equiv_at_eq (e : Trivialization F ((exprπ) E)) [e.is_linear R] {b : B}\n    (hb : b ∈ e.base_set) : (e.continuous_linear_equiv_at R b hb : E b → F) = e.continuous_linear_map_at R b :=\n  (e.coe_linear_map_at_of_mem hb).symm\n#align coe_continuous_linear_equiv_at_eq coe_continuous_linear_equiv_at_eq\n\n",
 "base_set_at":
 "@[simp, mfld_simps]\ntheorem base_set_at : Z.base_set i = (Z.local_triv i).base_set :=\n  rfl\n#align base_set_at base_set_at\n\n",
 "apply_symm_apply_eq_coord_changeL":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprπ -/\ntheorem apply_symm_apply_eq_coord_changeL (e e' : Trivialization F ((exprπ) E)) [e.is_linear R] [e'.is_linear R] {b : B}\n    (hb : b ∈ e.base_set ∩ e'.base_set) (v : F) :\n    e' (e.to_local_homeomorph.symm (b, v)) = (b, e.coord_changeL R e' b v) := by\n  rw [e.mk_coord_changeL e' hb, e.mk_symm hb.1]\n#align apply_symm_apply_eq_coord_changeL apply_symm_apply_eq_coord_changeL\n\n",
 "apply_eq_prod_continuous_linear_equiv_at":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprπ -/\ntheorem apply_eq_prod_continuous_linear_equiv_at (e : Trivialization F ((exprπ) E)) [e.is_linear R] (b : B)\n    (hb : b ∈ e.base_set) (z : E b) : e ⟨b, z⟩ = (b, e.continuous_linear_equiv_at R b hb z) :=\n  by\n  ext\n  · refine' e.coe_fst _\n    rw [e.source_eq]\n    exact hb\n  · simp only [coe_coe, continuous_linear_equiv_at_apply]\n#align apply_eq_prod_continuous_linear_equiv_at apply_eq_prod_continuous_linear_equiv_at\n\n"}