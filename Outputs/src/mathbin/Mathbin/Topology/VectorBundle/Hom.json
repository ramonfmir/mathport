{"hom_trivialization_at_target":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n@[simp, mfld_simps]\ntheorem hom_trivialization_at_target (x₀ : B) :\n    (trivialization_at («expr →SL[ ] » F₁ σ F₂) (bundle.continuous_linear_map σ F₁ E₁ F₂ E₂) x₀).target =\n      lower_set.prod ((trivialization_at F₁ E₁ x₀).base_set ∩ (trivialization_at F₂ E₂ x₀).base_set) Set.univ :=\n  rfl\n#align hom_trivialization_at_target hom_trivialization_at_target\n\n",
 "hom_trivialization_at_source":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprπ -/\n@[simp, mfld_simps]\ntheorem hom_trivialization_at_source (x₀ : B) :\n    (trivialization_at («expr →SL[ ] » F₁ σ F₂) (bundle.continuous_linear_map σ F₁ E₁ F₂ E₂) x₀).source =\n      «expr ⁻¹' » ((exprπ) (bundle.continuous_linear_map σ F₁ E₁ F₂ E₂))\n        ((trivialization_at F₁ E₁ x₀).base_set ∩ (trivialization_at F₂ E₂ x₀).base_set) :=\n  rfl\n#align hom_trivialization_at_source hom_trivialization_at_source\n\n",
 "hom_trivialization_at_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\ntheorem hom_trivialization_at_apply (x₀ : B) (x : TotalSpace (bundle.continuous_linear_map σ F₁ E₁ F₂ E₂)) :\n    trivialization_at («expr →SL[ ] » F₁ σ F₂) (bundle.continuous_linear_map σ F₁ E₁ F₂ E₂) x₀ x =\n      ⟨x.1, in_coordinates F₁ E₁ F₂ E₂ x₀ x.1 x₀ x.1 x.2⟩ :=\n  rfl\n#align hom_trivialization_at_apply hom_trivialization_at_apply\n\n",
 "continuous_on_continuous_linear_map_coord_change":
 "/-\nCopyright © 2022 Heather Macbeth. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Heather Macbeth, Floris van Doorn\n-/\n-- In this definition we require the scalar rings `𝕜₁` and `𝕜₂` to be normed fields, although\n-- something much weaker (maybe `comm_semiring`) would suffice mathematically -- this is because of\n-- a typeclass inference bug with pi-types:\n-- https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/vector.20bundles.20--.20typeclass.20inference.20issue\ntheorem continuous_on_continuous_linear_map_coord_change [vector_bundle 𝕜₁ F₁ E₁] [vector_bundle 𝕜₂ F₂ E₂]\n    [MemTrivializationAtlas e₁] [MemTrivializationAtlas e₁'] [MemTrivializationAtlas e₂] [MemTrivializationAtlas e₂'] :\n    ContinuousOn (continuous_linear_map_coord_change σ e₁ e₁' e₂ e₂')\n      (e₁.base_set ∩ e₂.base_set ∩ (e₁'.base_set ∩ e₂'.base_set)) :=\n  by\n  have h₁ := (compSL F₁ F₂ F₂ σ (RingHom.id 𝕜₂)).continuous\n  have h₂ := (continuous_linear_map.flip (compSL F₁ F₁ F₂ (RingHom.id 𝕜₁) σ)).continuous\n  have h₃ := continuous_on_coord_change 𝕜₁ e₁' e₁\n  have h₄ := continuous_on_coord_change 𝕜₂ e₂ e₂'\n  refine' ((h₁.comp_continuous_on (h₄.mono _)).clm_comp (h₂.comp_continuous_on (h₃.mono _))).congr _\n  · mfld_set_tac\n  · mfld_set_tac\n  · intro b hb\n    ext (L v)\n    simp only [continuous_linear_map_coord_change, ContinuousLinearEquiv.coe_coe,\n      continuous_linear_equiv.arrow_congrSL_apply, comp_apply, Function.comp, compSL_apply, flip_apply,\n      ContinuousLinearEquiv.symm_symm]\n#align continuous_on_continuous_linear_map_coord_change continuous_on_continuous_linear_map_coord_change\n\n",
 "continuous_linear_map_symm_apply'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\ntheorem continuous_linear_map_symm_apply' {b : B} (hb : b ∈ e₁.base_set ∩ e₂.base_set) (L : «expr →SL[ ] » F₁ σ F₂) :\n    (continuous_linear_map σ e₁ e₂).symm b L = (e₂.symmL 𝕜₂ b).comp (L.comp <| e₁.continuous_linear_map_at 𝕜₁ b) := by\n  rw [symm_apply]; rfl; exact hb\n#align continuous_linear_map_symm_apply' continuous_linear_map_symm_apply'\n\n",
 "continuous_linear_map_symm_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\ntheorem continuous_linear_map_symm_apply (p : B × «expr →SL[ ] » F₁ σ F₂) :\n    (continuous_linear_map σ e₁ e₂).to_local_equiv.symm p =\n      ⟨p.1, (e₂.symmL 𝕜₂ p.1).comp <| p.2.comp <| e₁.continuous_linear_map_at 𝕜₁ p.1⟩ :=\n  rfl\n#align continuous_linear_map_symm_apply continuous_linear_map_symm_apply\n\n",
 "continuous_linear_map_coord_change_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\ntheorem continuous_linear_map_coord_change_apply [RingHomIsometric σ] (b : B)\n    (hb : b ∈ e₁.base_set ∩ e₂.base_set ∩ (e₁'.base_set ∩ e₂'.base_set)) (L : «expr →SL[ ] » F₁ σ F₂) :\n    continuous_linear_map_coord_change σ e₁ e₁' e₂ e₂' b L =\n      (continuous_linear_map σ e₁' e₂' (totalSpaceMk b ((continuous_linear_map σ e₁ e₂).symm b L))).2 :=\n  by\n  ext v\n  simp_rw [continuous_linear_map_coord_change, ContinuousLinearEquiv.coe_coe,\n    continuous_linear_equiv.arrow_congrSL_apply, continuous_linear_map_apply,\n    continuous_linear_map_symm_apply' σ e₁ e₂ hb.1, comp_apply, ContinuousLinearEquiv.coe_coe,\n    ContinuousLinearEquiv.symm_symm, trivialization.continuous_linear_map_at_apply, trivialization.symmL_apply]\n  dsimp only [total_space_mk]\n  rw [e₂.coord_changeL_apply e₂', e₁'.coord_changeL_apply e₁, e₁.coe_linear_map_at_of_mem hb.1.1,\n    e₂'.coe_linear_map_at_of_mem hb.2.2]\n  exacts[⟨hb.2.1, hb.1.1⟩, ⟨hb.1.2, hb.2.2⟩]\n#align continuous_linear_map_coord_change_apply continuous_linear_map_coord_change_apply\n\n",
 "continuous_linear_map_apply":
 "theorem trivialization.continuous_linear_map_apply (p : TotalSpace (bundle.continuous_linear_map σ F₁ E₁ F₂ E₂)) :\n    e₁.continuous_linear_map σ e₂ p = ⟨p.1, (e₂.continuous_linear_map_at 𝕜₂ p.1).comp <| p.2.comp <| e₁.symmL 𝕜₁ p.1⟩ :=\n  rfl\n#align trivialization.continuous_linear_map_apply trivialization.continuous_linear_map_apply\n\n",
 "base_set_continuous_linear_map":
 "@[simp]\ntheorem trivialization.base_set_continuous_linear_map :\n    (e₁.continuous_linear_map σ e₂).base_set = e₁.base_set ∩ e₂.base_set :=\n  rfl\n#align trivialization.base_set_continuous_linear_map trivialization.base_set_continuous_linear_map\n\n"}