{"is_sheaf_unit":
 "/-\nCopyright (c) 2020 Scott Morrison. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Scott Morrison\n-/\n/-- The presheaf valued in `unit` over any topological space is a sheaf.\n-/\ntheorem is_sheaf_unit (F : presheaf (CategoryTheory.Discrete Unit) X) : F.is_sheaf := fun x U S hS x hx =>\n  ⟨eqToHom (subsingleton.elim _ _), by tidy, by tidy⟩\n#align is_sheaf_unit is_sheaf_unit\n\n",
 "is_sheaf_of_iso":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≅ » -/\n/-- Transfer the sheaf condition across an isomorphism of presheaves.\n-/\ntheorem is_sheaf_of_iso {F G : presheaf C X} (α : «expr ≅ » F G) (h : F.is_sheaf) : G.is_sheaf :=\n  (is_sheaf_iso_iff α).1 h\n#align is_sheaf_of_iso is_sheaf_of_iso\n\n",
 "is_sheaf_iso_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≅ » -/\ntheorem is_sheaf_iso_iff {F G : presheaf C X} (α : «expr ≅ » F G) : F.is_sheaf ↔ G.is_sheaf :=\n  Presheaf.isSheaf_of_iso_iff α\n#align is_sheaf_iso_iff is_sheaf_iso_iff\n\n",
 "id_app":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n-- Let's construct a trivial example, to keep the inhabited linter happy.\n-- Note: These can be proved by simp.\ntheorem id_app (F : sheaf C X) (t) : ((«expr𝟙») F : «expr ⟶ » F F).1.app t = («expr𝟙») _ :=\n  rfl\n#align id_app id_app\n\n",
 "comp_app":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem comp_app {F G H : sheaf C X} (f : «expr ⟶ » F G) (g : «expr ⟶ » G H) (t) :\n    («expr ≫ » f g).1.app t = «expr ≫ » (f.1.app t) (g.1.app t) :=\n  rfl\n#align comp_app comp_app\n\n"}