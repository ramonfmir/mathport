{"stalk_to_fiber_surjective":
 "/-- The `stalk_to_fiber` map is surjective at `x` if\nevery point in the fiber `T x` has an allowed section passing through it.\n-/\ntheorem stalk_to_fiber_surjective (P : local_predicate T) (x : X)\n    (w : âˆ€ t : T x, âˆƒ (U : OpenNhds x)(f : âˆ€ y : U.1, T y)(h : P.pred f), f âŸ¨x, U.2âŸ© = t) :\n    function.surjective (stalk_to_fiber P x) := fun t =>\n  by\n  rcases w t with âŸ¨U, f, h, rflâŸ©\n  fconstructor\n  Â· exact (subsheaf_to_Types P).presheaf.germ âŸ¨x, U.2âŸ© âŸ¨f, hâŸ©\n  Â· exact stalk_to_fiber_germ _ U.1 âŸ¨x, U.2âŸ© âŸ¨f, hâŸ©\n#align stalk_to_fiber_surjective stalk_to_fiber_surjective\n\n",
 "stalk_to_fiber_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr áµ’áµ–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/-- The `stalk_to_fiber` map is injective at `x` if any two allowed sections which agree at `x`\nagree on some neighborhood of `x`.\n-/\ntheorem stalk_to_fiber_injective (P : local_predicate T) (x : X)\n    (w :\n      âˆ€ (U V : OpenNhds x) (fU : âˆ€ y : U.1, T y) (hU : P.pred fU) (fV : âˆ€ y : V.1, T y) (hV : P.pred fV)\n        (e : fU âŸ¨x, U.2âŸ© = fV âŸ¨x, V.2âŸ©),\n        âˆƒ (W : OpenNhds x)(iU : Â«expr âŸ¶ Â» W U)(iV : Â«expr âŸ¶ Â» W V), âˆ€ w : W.1, fU (iU w : U.1) = fV (iV w : V.1)) :\n    function.injective (stalk_to_fiber P x) := fun tU tV h =>\n  by\n  -- We promise to provide all the ingredients of the proof later:\n  let Q :\n    âˆƒ (W : Â«expr áµ’áµ–Â» (open_nhds x))(s : âˆ€ w : (unop W).1, T w)(hW : P.pred s),\n      tU = (subsheaf_to_Types P).presheaf.germ âŸ¨x, (unop W).2âŸ© âŸ¨s, hWâŸ© âˆ§\n        tV = (subsheaf_to_Types P).presheaf.germ âŸ¨x, (unop W).2âŸ© âŸ¨s, hWâŸ© :=\n    _\n  Â· choose W s hW e using Q\n    exact e.1.trans e.2.symm\n  -- Then use induction to pick particular representatives of `tU tV : stalk x`\n  obtain âŸ¨U, âŸ¨fU, hUâŸ©, rflâŸ© := jointly_surjective'.{v, v} tU\n  obtain âŸ¨V, âŸ¨fV, hVâŸ©, rflâŸ© := jointly_surjective'.{v, v} tV\n  Â· -- Decompose everything into its constituent parts:\n    dsimp\n    simp only [stalk_to_fiber, types.colimit.Î¹_desc_apply'] at h\n    specialize w (unop U) (unop V) fU hU fV hV h\n    rcases w with âŸ¨W, iU, iV, wâŸ©\n    -- and put it back together again in the correct order.\n    refine' âŸ¨op W, fun w => fU (iU w : (unop U).1), P.res _ _ hU, _âŸ©\n    rcases W with âŸ¨W, mâŸ©\n    exact âŸ¨colimit_sound iU.op (Subtype.eq rfl), colimit_sound iV.op (Subtype.eq (funext w).symm)âŸ©\n#align stalk_to_fiber_injective stalk_to_fiber_injective\n\n",
 "stalk_to_fiber_germ":
 "@[simp]\ntheorem stalk_to_fiber_germ (P : local_predicate T) (U : Opens X) (x : U) (f) :\n    stalk_to_fiber P x ((subsheaf_to_Types P).presheaf.germ x f) = f.1 x :=\n  by\n  dsimp [presheaf.germ, stalk_to_fiber]\n  cases x\n  simp\n  rfl\n#align stalk_to_fiber_germ stalk_to_fiber_germ\n\n",
 "sheafify_of":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprðŸ™Â» -/\n/-\nCopyright (c) 2020 Scott Morrison. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johan Commelin, Scott Morrison, Adam Topaz\n-/\ntheorem prelocal_predicate.sheafify_of {T : X â†’ Type v} {P : prelocal_predicate T} {U : Opens X} {f : âˆ€ x : U, T x}\n    (h : P.pred f) : P.sheafify.pred f := fun x =>\n  âŸ¨U, x.2, (Â«exprðŸ™Â») _, by\n    convert h\n    ext âŸ¨y, wâŸ©\n    rflâŸ©\n#align prelocal_predicate.sheafify_of prelocal_predicate.sheafify_of\n\n",
 "is_sheaf":
 "/-- The functions satisfying a local predicate satisfy the sheaf condition.\n-/\ntheorem is_sheaf (P : local_predicate T) : (subpresheaf_to_Types P.to_prelocal_predicate).is_sheaf :=\n  presheaf.is_sheaf_of_is_sheaf_unique_gluing_types _ fun Î¹ U sf sf_comp =>\n    by\n    -- We show the sheaf condition in terms of unique gluing.\n    -- First we obtain a family of sections for the underlying sheaf of functions,\n    -- by forgetting that the prediacte holds\n    let sf' : âˆ€ i : Î¹, (presheaf_to_Types X T).obj (op (U i)) := fun i => (sf i).val\n    -- Since our original family is compatible, this one is as well\n    have sf'_comp : (presheaf_to_Types X T).is_compatible U sf' := fun i j => congr_arg Subtype.val (sf_comp i j)\n    -- So, we can obtain a unique gluing\n    obtain âŸ¨gl, gl_spec, gl_uniqâŸ© := (sheaf_to_Types X T).exists_unique_gluing U sf' sf'_comp\n    refine' âŸ¨âŸ¨gl, _âŸ©, _, _âŸ©\n    Â· -- Our first goal is to show that this chosen gluing satisfies the\n      -- predicate. Of course, we use locality of the predicate.\n      apply P.locality\n      rintro âŸ¨x, memâŸ©\n      -- Once we're at a particular point `x`, we can select some open set `x âˆˆ U i`.\n      choose i hi using opens.mem_supr.mp mem\n      -- We claim that the predicate holds in `U i`\n      use U i, hi, opens.le_supr U i\n      -- This follows, since our original family `sf` satisfies the predicate\n      convert(sf i).property\n      exact gl_spec i\n    -- It remains to show that the chosen lift is really a gluing for the subsheaf and\n    -- that it is unique. Both of which follow immediately from the corresponding facts\n    -- in the sheaf of functions without the local predicate.\n    Â· intro i\n      ext1\n      exact gl_spec i\n    Â· intro gl' hgl'\n      ext1\n      exact gl_uniq gl'.1 fun i => congr_arg Subtype.val (hgl' i)\n#align is_sheaf is_sheaf\n\n"}