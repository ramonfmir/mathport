{"stalk_to_fiber_surjective":
 "/-- The `stalk_to_fiber` map is surjective at `x` if\nevery point in the fiber `T x` has an allowed section passing through it.\n-/\ntheorem stalk_to_fiber_surjective (P : local_predicate T) (x : X)\n    (w : ∀ t : T x, ∃ (U : OpenNhds x)(f : ∀ y : U.1, T y)(h : P.pred f), f ⟨x, U.2⟩ = t) :\n    function.surjective (stalk_to_fiber P x) := fun t =>\n  by\n  rcases w t with ⟨U, f, h, rfl⟩\n  fconstructor\n  · exact (subsheaf_to_Types P).presheaf.germ ⟨x, U.2⟩ ⟨f, h⟩\n  · exact stalk_to_fiber_germ _ U.1 ⟨x, U.2⟩ ⟨f, h⟩\n#align stalk_to_fiber_surjective stalk_to_fiber_surjective\n\n",
 "stalk_to_fiber_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵖ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/-- The `stalk_to_fiber` map is injective at `x` if any two allowed sections which agree at `x`\nagree on some neighborhood of `x`.\n-/\ntheorem stalk_to_fiber_injective (P : local_predicate T) (x : X)\n    (w :\n      ∀ (U V : OpenNhds x) (fU : ∀ y : U.1, T y) (hU : P.pred fU) (fV : ∀ y : V.1, T y) (hV : P.pred fV)\n        (e : fU ⟨x, U.2⟩ = fV ⟨x, V.2⟩),\n        ∃ (W : OpenNhds x)(iU : «expr ⟶ » W U)(iV : «expr ⟶ » W V), ∀ w : W.1, fU (iU w : U.1) = fV (iV w : V.1)) :\n    function.injective (stalk_to_fiber P x) := fun tU tV h =>\n  by\n  -- We promise to provide all the ingredients of the proof later:\n  let Q :\n    ∃ (W : «expr ᵒᵖ» (open_nhds x))(s : ∀ w : (unop W).1, T w)(hW : P.pred s),\n      tU = (subsheaf_to_Types P).presheaf.germ ⟨x, (unop W).2⟩ ⟨s, hW⟩ ∧\n        tV = (subsheaf_to_Types P).presheaf.germ ⟨x, (unop W).2⟩ ⟨s, hW⟩ :=\n    _\n  · choose W s hW e using Q\n    exact e.1.trans e.2.symm\n  -- Then use induction to pick particular representatives of `tU tV : stalk x`\n  obtain ⟨U, ⟨fU, hU⟩, rfl⟩ := jointly_surjective'.{v, v} tU\n  obtain ⟨V, ⟨fV, hV⟩, rfl⟩ := jointly_surjective'.{v, v} tV\n  · -- Decompose everything into its constituent parts:\n    dsimp\n    simp only [stalk_to_fiber, types.colimit.ι_desc_apply'] at h\n    specialize w (unop U) (unop V) fU hU fV hV h\n    rcases w with ⟨W, iU, iV, w⟩\n    -- and put it back together again in the correct order.\n    refine' ⟨op W, fun w => fU (iU w : (unop U).1), P.res _ _ hU, _⟩\n    rcases W with ⟨W, m⟩\n    exact ⟨colimit_sound iU.op (Subtype.eq rfl), colimit_sound iV.op (Subtype.eq (funext w).symm)⟩\n#align stalk_to_fiber_injective stalk_to_fiber_injective\n\n",
 "stalk_to_fiber_germ":
 "@[simp]\ntheorem stalk_to_fiber_germ (P : local_predicate T) (U : Opens X) (x : U) (f) :\n    stalk_to_fiber P x ((subsheaf_to_Types P).presheaf.germ x f) = f.1 x :=\n  by\n  dsimp [presheaf.germ, stalk_to_fiber]\n  cases x\n  simp\n  rfl\n#align stalk_to_fiber_germ stalk_to_fiber_germ\n\n",
 "sheafify_of":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/-\nCopyright (c) 2020 Scott Morrison. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johan Commelin, Scott Morrison, Adam Topaz\n-/\ntheorem prelocal_predicate.sheafify_of {T : X → Type v} {P : prelocal_predicate T} {U : Opens X} {f : ∀ x : U, T x}\n    (h : P.pred f) : P.sheafify.pred f := fun x =>\n  ⟨U, x.2, («expr𝟙») _, by\n    convert h\n    ext ⟨y, w⟩\n    rfl⟩\n#align prelocal_predicate.sheafify_of prelocal_predicate.sheafify_of\n\n",
 "is_sheaf":
 "/-- The functions satisfying a local predicate satisfy the sheaf condition.\n-/\ntheorem is_sheaf (P : local_predicate T) : (subpresheaf_to_Types P.to_prelocal_predicate).is_sheaf :=\n  presheaf.is_sheaf_of_is_sheaf_unique_gluing_types _ fun ι U sf sf_comp =>\n    by\n    -- We show the sheaf condition in terms of unique gluing.\n    -- First we obtain a family of sections for the underlying sheaf of functions,\n    -- by forgetting that the prediacte holds\n    let sf' : ∀ i : ι, (presheaf_to_Types X T).obj (op (U i)) := fun i => (sf i).val\n    -- Since our original family is compatible, this one is as well\n    have sf'_comp : (presheaf_to_Types X T).is_compatible U sf' := fun i j => congr_arg Subtype.val (sf_comp i j)\n    -- So, we can obtain a unique gluing\n    obtain ⟨gl, gl_spec, gl_uniq⟩ := (sheaf_to_Types X T).exists_unique_gluing U sf' sf'_comp\n    refine' ⟨⟨gl, _⟩, _, _⟩\n    · -- Our first goal is to show that this chosen gluing satisfies the\n      -- predicate. Of course, we use locality of the predicate.\n      apply P.locality\n      rintro ⟨x, mem⟩\n      -- Once we're at a particular point `x`, we can select some open set `x ∈ U i`.\n      choose i hi using opens.mem_supr.mp mem\n      -- We claim that the predicate holds in `U i`\n      use U i, hi, opens.le_supr U i\n      -- This follows, since our original family `sf` satisfies the predicate\n      convert(sf i).property\n      exact gl_spec i\n    -- It remains to show that the chosen lift is really a gluing for the subsheaf and\n    -- that it is unique. Both of which follow immediately from the corresponding facts\n    -- in the sheaf of functions without the local predicate.\n    · intro i\n      ext1\n      exact gl_spec i\n    · intro gl' hgl'\n      ext1\n      exact gl_uniq gl'.1 fun i => congr_arg Subtype.val (hgl' i)\n#align is_sheaf is_sheaf\n\n"}