{"stalk_to_fiber_surjective":
 "/-\nCopyright (c) 2020 Scott Morrison. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Scott Morrison\n-/\ntheorem stalk_to_fiber_surjective (x : X) : function.surjective (F.stalk_to_fiber x) :=\n  by\n  apply stalk_to_fiber_surjective\n  intro t\n  obtain ⟨U, m, s, rfl⟩ := F.germ_exist _ t\n  · use ⟨U, m⟩\n    fconstructor\n    · exact fun y => F.germ y s\n    · exact ⟨prelocal_predicate.sheafify_of ⟨s, fun _ => rfl⟩, rfl⟩\n#align stalk_to_fiber_surjective stalk_to_fiber_surjective\n\n",
 "stalk_to_fiber_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem stalk_to_fiber_injective (x : X) : function.injective (F.stalk_to_fiber x) :=\n  by\n  apply stalk_to_fiber_injective\n  intros\n  rcases hU ⟨x, U.2⟩ with ⟨U', mU, iU, gU, wU⟩\n  rcases hV ⟨x, V.2⟩ with ⟨V', mV, iV, gV, wV⟩\n  have wUx := wU ⟨x, mU⟩\n  dsimp at wUx; erw [wUx] at e; clear wUx\n  have wVx := wV ⟨x, mV⟩\n  dsimp at wVx; erw [wVx] at e; clear wVx\n  rcases F.germ_eq x mU mV gU gV e with ⟨W, mW, iU', iV', e'⟩\n  dsimp at e'\n  use ⟨«expr ⊓ » W («expr ⊓ » U' V'), ⟨mW, mU, mV⟩⟩\n  refine' ⟨_, _, _⟩\n  · change «expr ⟶ » («expr ⊓ » W («expr ⊓ » U' V')) U.obj\n    exact «expr ≫ » (opens.inf_le_right _ _) («expr ≫ » (opens.inf_le_left _ _) iU)\n  · change «expr ⟶ » («expr ⊓ » W («expr ⊓ » U' V')) V.obj\n    exact «expr ≫ » (opens.inf_le_right _ _) («expr ≫ » (opens.inf_le_right _ _) iV)\n  · intro w\n    dsimp\n    specialize wU ⟨w.1, w.2.2.1⟩\n    dsimp at wU\n    specialize wV ⟨w.1, w.2.2.2⟩\n    dsimp at wV\n    erw [wU, ← F.germ_res iU' ⟨w, w.2.1⟩, wV, ← F.germ_res iV' ⟨w, w.2.1⟩, CategoryTheory.types_comp_apply,\n      CategoryTheory.types_comp_apply, e']\n#align stalk_to_fiber_injective stalk_to_fiber_injective\n\n"}