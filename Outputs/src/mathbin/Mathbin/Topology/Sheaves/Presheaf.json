{"to_pushforward_of_iso_app":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≅ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr _* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵖ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp]\ntheorem to_pushforward_of_iso_app {X Y : TopCat} (H₁ : «expr ≅ » X Y) {ℱ : X.presheaf C} {𝒢 : Y.presheaf C}\n    (H₂ : «expr ⟶ » («expr _* » H₁.hom ℱ) 𝒢) (U : «expr ᵒᵖ» (Opens X)) :\n    (to_pushforward_of_iso H₁ H₂).app U =\n      «expr ≫ » (ℱ.map (eqToHom (by simp [opens.map, Set.preimage_preimage])))\n        (H₂.app (op ((Opens.map H₁.inv).obj (unop U)))) :=\n  by\n  delta to_pushforward_of_iso\n  simp only [Equiv.toFun_as_coe, nat_trans.comp_app, equivalence.equivalence_mk'_unit, eq_to_hom_map, eq_to_hom_op,\n    eq_to_hom_trans, presheaf_equiv_of_iso_unit_iso_hom_app_app, equivalence.to_adjunction,\n    equivalence.equivalence_mk'_counit, presheaf_equiv_of_iso_inverse_map_app,\n    adjunction.mk_of_unit_counit_hom_equiv_apply]\n  congr\n#align to_pushforward_of_iso_app to_pushforward_of_iso_app\n\n",
 "restrict_restrict":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr |_ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr |_ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr |_ » -/\n/-\nCopyright (c) 2018 Scott Morrison. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Scott Morrison, Mario Carneiro, Reid Barton, Andrew Yang\n-/\n@[simp]\ntheorem restrict_restrict {X : TopCat} {C : Type _} [Category C] [ConcreteCategory C] {F : X.presheaf C}\n    {U V W : Opens X} (e₁ : U ≤ V) (e₂ : V ≤ W) (x : F.obj (op W)) : «expr |_ » («expr |_ » x V) U = «expr |_ » x U :=\n  by\n  delta restrict_open restrict\n  rw [← comp_apply, ← functor.map_comp]\n  rfl\n#align restrict_restrict restrict_restrict\n\n",
 "pushforward_to_of_iso_app":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≅ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr _* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵖ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp]\ntheorem pushforward_to_of_iso_app {X Y : TopCat} (H₁ : «expr ≅ » X Y) {ℱ : Y.presheaf C} {𝒢 : X.presheaf C}\n    (H₂ : «expr ⟶ » ℱ («expr _* » H₁.hom 𝒢)) (U : «expr ᵒᵖ» (Opens X)) :\n    (pushforward_to_of_iso H₁ H₂).app U =\n      «expr ≫ » (H₂.app (op ((Opens.map H₁.inv).obj (unop U))))\n        (𝒢.map (eqToHom (by simp [opens.map, Set.preimage_preimage]))) :=\n  by simpa [pushforward_to_of_iso, equivalence.to_adjunction]\n#align pushforward_to_of_iso_app pushforward_to_of_iso_app\n\n",
 "pushforward_obj_obj":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵖ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr _* » -/\n@[simp]\ntheorem pushforward_obj_obj {X Y : TopCat.{w}} (f : «expr ⟶ » X Y) (ℱ : X.presheaf C) (U : «expr ᵒᵖ» (Opens Y)) :\n    («expr _* » f ℱ).obj U = ℱ.obj ((Opens.map f).op.obj U) :=\n  rfl\n#align pushforward_obj_obj pushforward_obj_obj\n\n",
 "pushforward_obj_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵖ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr _* » -/\n@[simp]\ntheorem pushforward_obj_map {X Y : TopCat.{w}} (f : «expr ⟶ » X Y) (ℱ : X.presheaf C) {U V : «expr ᵒᵖ» (Opens Y)}\n    (i : «expr ⟶ » U V) : («expr _* » f ℱ).map i = ℱ.map ((Opens.map f).op.map i) :=\n  rfl\n#align pushforward_obj_map pushforward_obj_map\n\n",
 "pushforward_map_app'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵖ» -/\n@[simp]\ntheorem pushforward_map_app' {X Y : TopCat.{w}} (f : «expr ⟶ » X Y) {ℱ 𝒢 : X.presheaf C} (α : «expr ⟶ » ℱ 𝒢)\n    {U : «expr ᵒᵖ» (Opens Y)} : ((pushforward C f).map α).app U = α.app (op <| (Opens.map f).obj U.unop) :=\n  rfl\n#align pushforward_map_app' pushforward_map_app'\n\n",
 "pushforward_eq_rfl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n@[simp]\ntheorem pushforward_eq_rfl {X Y : TopCat.{w}} (f : «expr ⟶ » X Y) (ℱ : X.presheaf C) (U) :\n    (pushforward_eq (rfl : f = f) ℱ).hom.app (op U) = («expr𝟙») _ :=\n  by\n  dsimp [pushforward_eq]\n  simp\n#align pushforward_eq_rfl pushforward_eq_rfl\n\n",
 "pushforward_eq_hom_app":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n@[simp]\ntheorem pushforward_eq_hom_app {X Y : TopCat.{w}} {f g : «expr ⟶ » X Y} (h : f = g) (ℱ : X.presheaf C) (U) :\n    (pushforward_eq h ℱ).hom.app U = ℱ.map (by dsimp [functor.op]; apply Quiver.Hom.op; apply eq_to_hom; rw [h]) := by\n  simp [pushforward_eq]\n#align pushforward_eq_hom_app pushforward_eq_hom_app\n\n",
 "pushforward_eq_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem pushforward_eq_eq {X Y : TopCat.{w}} {f g : «expr ⟶ » X Y} (h₁ h₂ : f = g) (ℱ : X.presheaf C) :\n    ℱ.pushforward_eq h₁ = ℱ.pushforward_eq h₂ :=\n  rfl\n#align pushforward_eq_eq pushforward_eq_eq\n\n",
 "pushforward_eq'_hom_app":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem pushforward_eq'_hom_app {X Y : TopCat.{w}} {f g : «expr ⟶ » X Y} (h : f = g) (ℱ : X.presheaf C) (U) :\n    nat_trans.app (eqToHom (pushforward_eq' h ℱ)) U = ℱ.map (eqToHom (by rw [h])) := by simpa [eq_to_hom_map]\n#align pushforward_eq'_hom_app pushforward_eq'_hom_app\n\n",
 "pushforward_eq'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr _* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr _* » -/\ntheorem pushforward_eq' {X Y : TopCat.{w}} {f g : «expr ⟶ » X Y} (h : f = g) (ℱ : X.presheaf C) :\n    «expr _* » f ℱ = «expr _* » g ℱ := by rw [h]\n#align pushforward_eq' pushforward_eq'\n\n",
 "pullback_obj_eq_pullback_obj":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n@[simp]\ntheorem pullback_obj_eq_pullback_obj {C} [Category C] [HasColimits C] {X Y : TopCat.{w}} (f : «expr ⟶ » X Y)\n    (ℱ : Y.presheaf C) : (pullback C f).obj ℱ = pullback_obj f ℱ :=\n  rfl\n#align pullback_obj_eq_pullback_obj pullback_obj_eq_pullback_obj\n\n",
 "map_restrict":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr |_ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr |_ » -/\n@[simp]\ntheorem map_restrict {X : TopCat} {C : Type _} [Category C] [ConcreteCategory C] {F G : X.presheaf C}\n    (e : «expr ⟶ » F G) {U V : Opens X} (h : U ≤ V) (x : F.obj (op V)) :\n    e.app _ («expr |_ » x U) = «expr |_ » (e.app _ x) U :=\n  by\n  delta restrict_open restrict\n  rw [← comp_apply, nat_trans.naturality, comp_apply]\n#align map_restrict map_restrict\n\n",
 "id_pushforward":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟭» -/\ntheorem id_pushforward {X : TopCat.{w}} : pushforward C ((«expr𝟙») X) = («expr𝟭») (X.presheaf C) :=\n  by\n  apply CategoryTheory.Functor.ext\n  · intros\n    ext U\n    have h := f.congr\n    erw [h (opens.op_map_id_obj U)]\n    simpa [eq_to_hom_map]\n  · intros\n    apply pushforward.id_eq\n#align id_pushforward id_pushforward\n\n",
 "id_inv_app'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n@[simp]\ntheorem id_inv_app' (U) (p) : (id ℱ).inv.app (op ⟨U, p⟩) = ℱ.map ((«expr𝟙») (op ⟨U, p⟩)) :=\n  by\n  dsimp [id]\n  simp\n#align id_inv_app' id_inv_app'\n\n",
 "id_inv_app":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\ntheorem id_inv_app (U : Opens Y) :\n    (id ℱ).inv.app (op U) =\n      colimit.ι (Lan.diagram (Opens.map ((«expr𝟙») Y)).op ℱ (op U))\n        (@CostructuredArrow.mk _ _ _ _ _ (op U) _ (eqToHom (by simp))) :=\n  by\n  rw [← category.id_comp ((id ℱ).inv.app (op U)), ← nat_iso.app_inv, iso.comp_inv_eq]\n  dsimp [id]\n  rw [colimit.ι_desc_assoc]\n  dsimp\n  rw [← ℱ.map_comp, ← ℱ.map_id]; rfl\n#align id_inv_app id_inv_app\n\n",
 "id_hom_app'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n@[simp]\ntheorem id_hom_app' (U) (p) : (id ℱ).hom.app (op ⟨U, p⟩) = ℱ.map ((«expr𝟙») (op ⟨U, p⟩)) :=\n  by\n  dsimp [id]\n  simp\n#align id_hom_app' id_hom_app'\n\n",
 "id_hom_app":
 "@[simp]\ntheorem id_hom_app (U) : (id ℱ).hom.app U = ℱ.map (eqToHom (Opens.op_map_id_obj U)) :=\n  by\n  -- was `tidy`\n  induction U using Opposite.rec'\n  cases U\n  rw [id_hom_app']\n  congr\n#align id_hom_app id_hom_app\n\n",
 "id_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr _* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n#print id_eq /-\ntheorem id_eq : «expr _* » ((«expr𝟙») X) ℱ = ℱ :=\n  by\n  unfold pushforward_obj\n  rw [opens.map_id_eq]\n  erw [functor.id_comp]\n#align id_eq id_eq\n-/\n\n",
 "comp_inv_app":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n@[simp]\ntheorem comp_inv_app {Y Z : TopCat.{w}} (f : «expr ⟶ » X Y) (g : «expr ⟶ » Y Z) (U) :\n    (comp ℱ f g).inv.app U = («expr𝟙») _ := by\n  dsimp [comp]\n  tidy\n#align comp_inv_app comp_inv_app\n\n",
 "comp_hom_app":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n@[simp]\ntheorem comp_hom_app {Y Z : TopCat.{w}} (f : «expr ⟶ » X Y) (g : «expr ⟶ » Y Z) (U) :\n    (comp ℱ f g).hom.app U = («expr𝟙») _ := by\n  dsimp [comp]\n  tidy\n#align comp_hom_app comp_hom_app\n\n",
 "comp_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr _* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr _* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr _* » -/\ntheorem comp_eq {Y Z : TopCat.{w}} (f : «expr ⟶ » X Y) (g : «expr ⟶ » Y Z) :\n    «expr _* » («expr ≫ » f g) ℱ = «expr _* » g («expr _* » f ℱ) :=\n  rfl\n#align comp_eq comp_eq\n\n"}