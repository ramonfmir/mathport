{"stalk_specializes_stalk_pushforward":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⤳ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr _* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1, elementwise]\ntheorem stalk_specializes_stalk_pushforward (f : «expr ⟶ » X Y) (F : X.presheaf C) {x y : X} (h : «expr ⤳ » x y) :\n    «expr ≫ » ((«expr _* » f F).stalk_specializes (f.map_specializes h)) (F.stalk_pushforward _ f x) =\n      «expr ≫ » (F.stalk_pushforward _ f y) (F.stalk_specializes h) :=\n  by\n  ext\n  delta stalk_pushforward\n  simpa [stalk_specializes]\n#align stalk_specializes_stalk_pushforward stalk_specializes_stalk_pushforward\n\n",
 "stalk_specializes_stalk_functor_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⤳ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1, elementwise]\ntheorem stalk_specializes_stalk_functor_map {F G : X.presheaf C} (f : «expr ⟶ » F G) {x y : X} (h : «expr ⤳ » x y) :\n    «expr ≫ » (F.stalk_specializes h) ((stalk_functor C x).map f) =\n      «expr ≫ » ((stalk_functor C y).map f) (G.stalk_specializes h) :=\n  by\n  ext\n  delta stalk_functor\n  simpa [stalk_specializes]\n#align stalk_specializes_stalk_functor_map stalk_specializes_stalk_functor_map\n\n",
 "stalk_specializes_refl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n@[simp]\ntheorem stalk_specializes_refl {C : Type _} [Category C] [Limits.HasColimits C] {X : TopCat} (F : X.presheaf C)\n    (x : X) : F.stalk_specializes (specializes_refl x) = («expr𝟙») _ :=\n  F.stalk_hom_ext fun _ _ => by\n    dsimp\n    simpa\n#align stalk_specializes_refl stalk_specializes_refl\n\n",
 "stalk_specializes_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⤳ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⤳ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1, elementwise]\ntheorem stalk_specializes_comp {C : Type _} [Category C] [Limits.HasColimits C] {X : TopCat} (F : X.presheaf C)\n    {x y z : X} (h : «expr ⤳ » x y) (h' : «expr ⤳ » y z) :\n    «expr ≫ » (F.stalk_specializes h') (F.stalk_specializes h) = F.stalk_specializes (h.trans h') :=\n  F.stalk_hom_ext fun _ _ => by simp\n#align stalk_specializes_comp stalk_specializes_comp\n\n",
 "stalk_pushforward_iso_of_open_embedding":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≪≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr _* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr _* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem stalk_pushforward_iso_of_open_embedding {f : «expr ⟶ » X Y} (hf : OpenEmbedding f) (F : X.presheaf C) (x : X) :\n    IsIso (F.stalk_pushforward _ f x) :=\n  by\n  haveI := functor.initial_of_adjunction (hf.is_open_map.adjunction_nhds x)\n  convert is_iso.of_iso\n      («expr ≪≫ »\n        (functor.final.colimit_iso (hf.is_open_map.functor_nhds x).op\n              («expr ⋙ » (open_nhds.inclusion (f x)).op («expr _* » f F)) :\n            _).symm\n        (colim.map_iso _))\n  swap\n  · fapply nat_iso.of_components\n    · intro U\n      refine' F.map_iso (eq_to_iso _)\n      dsimp only [functor.op]\n      exact congr_arg op (opens.ext <| Set.preimage_image_eq (unop U).1.1 hf.inj)\n    · intro U V i\n      erw [← F.map_comp, ← F.map_comp]\n      congr\n  · ext U\n    rw [← iso.comp_inv_eq]\n    erw [colimit.ι_map_assoc]\n    rw [colimit.ι_pre, category.assoc]\n    erw [colimit.ι_map_assoc, colimit.ι_pre, ← F.map_comp_assoc]\n    apply colimit.w («expr ⋙ » (open_nhds.inclusion (f x)).op («expr _* » f F)) _\n    dsimp only [functor.op]\n    refine' ((hom_of_le _).op : «expr ⟶ » (op (unop U)) _)\n    exact Set.image_preimage_subset _ _\n#align stalk_pushforward_iso_of_open_embedding stalk_pushforward_iso_of_open_embedding\n\n",
 "stalk_pushforward_germ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr _* » -/\n-- This is a hack; Lean doesn't like to elaborate the term written directly.\n@[simp, elementwise, reassoc.1]\ntheorem stalk_pushforward_germ (f : «expr ⟶ » X Y) (F : X.presheaf C) (U : Opens Y) (x : (Opens.map f).obj U) :\n    «expr ≫ » ((«expr _* » f F).germ ⟨f x, x.2⟩) (F.stalk_pushforward C f x) = F.germ x :=\n  by\n  rw [stalk_pushforward, germ, colimit.ι_map_assoc, colimit.ι_pre, whisker_right_app]\n  erw [CategoryTheory.Functor.map_id, category.id_comp]\n  rfl\n#align stalk_pushforward_germ stalk_pushforward_germ\n\n",
 "stalk_open_algebra_map":
 "@[simp]\ntheorem stalk_open_algebra_map {X : TopCat} (F : X.presheaf CommRing) {U : Opens X} (x : U) :\n    algebraMap (F.obj <| op U) (F.stalk x) = F.germ x :=\n  rfl\n#align stalk_open_algebra_map stalk_open_algebra_map\n\n",
 "stalk_mono_of_mono":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem stalk_mono_of_mono {F G : sheaf C X} (f : «expr ⟶ » F G) [Mono f] : ∀ x, Mono <| (stalk_functor C x).map f.1 :=\n  fun x => by convert functor.map_mono («expr ⋙ » (sheaf.forget.{v} C X) (stalk_functor C x)) f\n#align stalk_mono_of_mono stalk_mono_of_mono\n\n",
 "stalk_hom_ext":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/-- A morphism from the stalk of `F` at `x` to some object `Y` is completely determined by its\ncomposition with the `germ` morphisms.\n-/\ntheorem stalk_hom_ext (F : X.presheaf C) {x} {Y : C} {f₁ f₂ : «expr ⟶ » (F.stalk x) Y}\n    (ih : ∀ (U : Opens X) (hxU : x ∈ U), «expr ≫ » (F.germ ⟨x, hxU⟩) f₁ = «expr ≫ » (F.germ ⟨x, hxU⟩) f₂) : f₁ = f₂ :=\n  colimit.hom_ext fun U => by\n    induction U using Opposite.rec'\n    cases' U with U hxU\n    exact ih U hxU\n#align stalk_hom_ext stalk_hom_ext\n\n",
 "stalk_functor_obj":
 "/-\nCopyright (c) 2019 Scott Morrison. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Scott Morrison, Justus Springer\n-/\n-- -- colimit ((open_nhds.inclusion x).op ⋙ ℱ)\n@[simp]\ntheorem stalk_functor_obj (ℱ : X.presheaf C) (x : X) : (stalk_functor C x).obj ℱ = ℱ.stalk x :=\n  rfl\n#align stalk_functor_obj stalk_functor_obj\n\n",
 "stalk_functor_map_injective_of_app_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem stalk_functor_map_injective_of_app_injective {F G : presheaf C X} (f : «expr ⟶ » F G)\n    (h : ∀ U : Opens X, function.injective (f.app (op U))) (x : X) : function.injective ((stalk_functor C x).map f) :=\n  fun s t hst => by\n  rcases germ_exist F x s with ⟨U₁, hxU₁, s, rfl⟩\n  rcases germ_exist F x t with ⟨U₂, hxU₂, t, rfl⟩\n  simp only [stalk_functor_map_germ_apply _ ⟨x, _⟩] at hst\n  obtain ⟨W, hxW, iWU₁, iWU₂, heq⟩ := G.germ_eq x hxU₁ hxU₂ _ _ hst\n  rw [← comp_apply, ← comp_apply, ← f.naturality, ← f.naturality, comp_apply, comp_apply] at heq\n  replace heq := h W HEq\n  convert congr_arg (F.germ ⟨x, hxW⟩) HEq\n  exacts[(F.germ_res_apply iWU₁ ⟨x, hxW⟩ s).symm, (F.germ_res_apply iWU₂ ⟨x, hxW⟩ t).symm]\n#align stalk_functor_map_injective_of_app_injective stalk_functor_map_injective_of_app_injective\n\n",
 "stalk_functor_map_germ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1, elementwise]\ntheorem stalk_functor_map_germ {F G : X.presheaf C} (U : Opens X) (x : U) (f : «expr ⟶ » F G) :\n    «expr ≫ » (germ F x) ((stalk_functor C x.1).map f) = «expr ≫ » (f.app (op U)) (germ G x) :=\n  colimit.ι_map (whiskerLeft (OpenNhds.inclusion x.1).op f) (op ⟨U, x.2⟩)\n#align stalk_functor_map_germ stalk_functor_map_germ\n\n",
 "section_ext":
 "/-- Let `F` be a sheaf valued in a concrete category, whose forgetful functor reflects isomorphisms,\npreserves limits and filtered colimits. Then two sections who agree on every stalk must be equal.\n-/\ntheorem section_ext (F : sheaf C X) (U : Opens X) (s t : F.1.obj (op U))\n    (h : ∀ x : U, F.presheaf.germ x s = F.presheaf.germ x t) : s = t :=\n  by\n  -- We use `germ_eq` and the axiom of choice, to pick for every point `x` a neighbourhood\n  -- `V x`, such that the restrictions of `s` and `t` to `V x` coincide.\n  choose V m i₁ i₂ heq using fun x : U => F.presheaf.germ_eq x.1 x.2 x.2 s t (h x)\n  -- Since `F` is a sheaf, we can prove the equality locally, if we can show that these\n  -- neighborhoods form a cover of `U`.\n  apply F.eq_of_locally_eq' V U i₁\n  · intro x hxU\n    rw [opens.mem_supr]\n    exact ⟨⟨x, hxU⟩, m ⟨x, hxU⟩⟩\n  · intro x\n    rw [HEq, subsingleton.elim (i₁ x) (i₂ x)]\n#align section_ext section_ext\n\n",
 "mono_of_stalk_mono":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem mono_of_stalk_mono {F G : sheaf C X} (f : «expr ⟶ » F G) [∀ x, Mono <| (stalk_functor C x).map f.1] : Mono f :=\n  (Sheaf.Hom.mono_iff_presheaf_mono _ _ _).mpr <|\n    (NatTrans.mono_iff_mono_app _ _).mpr fun U =>\n      (ConcreteCategory.mono_iff_injective_of_preservesPullback _).mpr <|\n        app_injective_of_stalk_functor_map_injective f.1 U.unop fun ⟨x, hx⟩ =>\n          (ConcreteCategory.mono_iff_injective_of_preservesPullback _).mp <| inferInstance\n#align mono_of_stalk_mono mono_of_stalk_mono\n\n",
 "mono_iff_stalk_mono":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem mono_iff_stalk_mono {F G : sheaf C X} (f : «expr ⟶ » F G) : Mono f ↔ ∀ x, Mono ((stalk_functor C x).map f.1) :=\n  ⟨by\n    intro m\n    exact stalk_mono_of_mono _, by\n    intro m\n    exact mono_of_stalk_mono _⟩\n#align mono_iff_stalk_mono mono_iff_stalk_mono\n\n",
 "is_iso_of_stalk_functor_map_iso":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵖ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n-- Making this an instance would cause a loop in typeclass resolution with `functor.map_is_iso`\n/-- Let `F` and `G` be sheaves valued in a concrete category, whose forgetful functor reflects\nisomorphisms, preserves limits and filtered colimits. Then if the stalk maps of a morphism\n`f : F ⟶ G` are all isomorphisms, `f` must be an isomorphism.\n-/\ntheorem is_iso_of_stalk_functor_map_iso {F G : sheaf C X} (f : «expr ⟶ » F G)\n    [∀ x : X, IsIso ((stalk_functor C x).map f.1)] : IsIso f :=\n  by\n  -- Since the inclusion functor from sheaves to presheaves is fully faithful, it suffices to\n  -- show that `f`, as a morphism between _presheaves_, is an isomorphism.\n  suffices is_iso ((sheaf.forget C X).map f) by exact is_iso_of_fully_faithful (sheaf.forget C X) f\n  -- We show that all components of `f` are isomorphisms.\n  suffices ∀ U : «expr ᵒᵖ» (opens X), is_iso (f.1.app U) by exact @nat_iso.is_iso_of_is_iso_app _ _ _ _ F.1 G.1 f.1 this\n  intro U\n  induction U using Opposite.rec'\n  apply app_is_iso_of_stalk_functor_map_iso\n#align is_iso_of_stalk_functor_map_iso is_iso_of_stalk_functor_map_iso\n\n",
 "is_iso_iff_stalk_functor_map_iso":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/-- Let `F` and `G` be sheaves valued in a concrete category, whose forgetful functor reflects\nisomorphisms, preserves limits and filtered colimits. Then a morphism `f : F ⟶ G` is an\nisomorphism if and only if all of its stalk maps are isomorphisms.\n-/\ntheorem is_iso_iff_stalk_functor_map_iso {F G : sheaf C X} (f : «expr ⟶ » F G) :\n    IsIso f ↔ ∀ x : X, IsIso ((stalk_functor C x).map f.1) :=\n  by\n  constructor\n  · intro h x\n    skip\n    exact @functor.map_is_iso _ _ _ _ _ _ (stalk_functor C x) f.1 ((sheaf.forget C X).map_is_iso f)\n  · intro h\n    exact is_iso_of_stalk_functor_map_iso f\n#align is_iso_iff_stalk_functor_map_iso is_iso_iff_stalk_functor_map_iso\n\n",
 "id":
 "/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:69:18: unsupported non-interactive tactic tactic.op_induction' -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n#print id /-\n-- Here are two other potential solutions, suggested by @fpvandoorn at\n-- <https://github.com/leanprover-community/mathlib/pull/1018#discussion_r283978240>\n-- However, I can't get the subsequent two proofs to work with either one.\n-- def stalk_pushforward (f : X ⟶ Y) (ℱ : X.presheaf C) (x : X) :\n--   (f _* ℱ).stalk (f x) ⟶ ℱ.stalk x :=\n-- colim.map ((functor.associator _ _ _).inv ≫\n--   whisker_right (nat_trans.op (open_nhds.inclusion_map_iso f x).inv) ℱ) ≫\n-- colimit.pre ((open_nhds.inclusion x).op ⋙ ℱ) (open_nhds.map f x).op\n-- def stalk_pushforward (f : X ⟶ Y) (ℱ : X.presheaf C) (x : X) :\n--   (f _* ℱ).stalk (f x) ⟶ ℱ.stalk x :=\n-- (colim.map (whisker_right (nat_trans.op (open_nhds.inclusion_map_iso f x).inv) ℱ) :\n--   colim.obj ((open_nhds.inclusion (f x) ⋙ opens.map f).op ⋙ ℱ) ⟶ _) ≫\n-- colimit.pre ((open_nhds.inclusion x).op ⋙ ℱ) (open_nhds.map f x).op\n@[simp]\ntheorem id (ℱ : X.presheaf C) (x : X) :\n    ℱ.stalk_pushforward C ((«expr𝟙») X) x = (stalk_functor C x).map (pushforward.id ℱ).hom :=\n  by\n  dsimp [stalk_pushforward, stalk_functor]\n  ext1\n  run_tac\n    tactic.op_induction'\n  rcases j with ⟨⟨_, _⟩, _⟩\n  rw [colimit.ι_map_assoc, colimit.ι_map, colimit.ι_pre, whisker_left_app, whisker_right_app, pushforward.id_hom_app,\n    eq_to_hom_map, eq_to_hom_refl]\n  dsimp\n  -- FIXME A simp lemma which unfortunately doesn't fire:\n  erw [CategoryTheory.Functor.map_id]\n#align id id\n-/\n\n",
 "germ_stalk_specializes'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⤳ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1, elementwise]\ntheorem germ_stalk_specializes' (F : X.presheaf C) {U : Opens X} {x y : X} (h : «expr ⤳ » x y) (hy : y ∈ U) :\n    «expr ≫ » (F.germ ⟨y, hy⟩) (F.stalk_specializes h) = F.germ ⟨x, h.mem_open U.is_open hy⟩ :=\n  colimit.ι_desc _ _\n#align germ_stalk_specializes' germ_stalk_specializes'\n\n",
 "germ_stalk_specializes":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⤳ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1, elementwise]\ntheorem germ_stalk_specializes (F : X.presheaf C) {U : Opens X} {y : U} {x : X} (h : «expr ⤳ » x y) :\n    «expr ≫ » (F.germ y) (F.stalk_specializes h) = F.germ (⟨x, h.mem_open U.is_open y.prop⟩ : U) :=\n  colimit.ι_desc _ _\n#align germ_stalk_specializes germ_stalk_specializes\n\n",
 "germ_res":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, elementwise]\ntheorem germ_res (F : X.presheaf C) {U V : Opens X} (i : «expr ⟶ » U V) (x : U) :\n    «expr ≫ » (F.map i.op) (germ F x) = germ F (i x : V) :=\n  let i' : «expr ⟶ » (⟨U, x.2⟩ : OpenNhds x.1) ⟨V, (i x : V).2⟩ := i\n  colimit.w («expr ⋙ » (OpenNhds.inclusion x.1).op F) i'.op\n#align germ_res germ_res\n\n",
 "germ_ext":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n@[ext]\ntheorem germ_ext (F : X.presheaf C) {U V : Opens X} {x : X} {hxU : x ∈ U} {hxV : x ∈ V} (W : Opens X) (hxW : x ∈ W)\n    (iWU : «expr ⟶ » W U) (iWV : «expr ⟶ » W V) {sU : F.obj (op U)} {sV : F.obj (op V)}\n    (ih : F.map iWU.op sU = F.map iWV.op sV) : F.germ ⟨x, hxU⟩ sU = F.germ ⟨x, hxV⟩ sV := by\n  erw [← F.germ_res iWU ⟨x, hxW⟩, ← F.germ_res iWV ⟨x, hxW⟩, comp_apply, comp_apply, ih]\n#align germ_ext germ_ext\n\n",
 "germ_exist":
 "/-- For presheaves valued in a concrete category whose forgetful functor preserves filtered colimits,\nevery element of the stalk is the germ of a section.\n-/\ntheorem germ_exist (F : X.presheaf C) (x : X) (t : stalk F x) :\n    ∃ (U : Opens X)(m : x ∈ U)(s : F.obj (op U)), F.germ ⟨x, m⟩ s = t :=\n  by\n  obtain ⟨U, s, e⟩ := Types.jointly_surjective.{v, v} _ (is_colimit_of_preserves (forget C) (colimit.is_colimit _)) t\n  revert s e\n  rw [show U = op (unop U) from rfl]\n  generalize unop U = V; clear U\n  cases' V with V m\n  intro s e\n  exact ⟨V, m, s, e⟩\n#align germ_exist germ_exist\n\n",
 "germ_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem germ_eq (F : X.presheaf C) {U V : Opens X} (x : X) (mU : x ∈ U) (mV : x ∈ V) (s : F.obj (op U))\n    (t : F.obj (op V)) (h : germ F ⟨x, mU⟩ s = germ F ⟨x, mV⟩ t) :\n    ∃ (W : Opens X)(m : x ∈ W)(iU : «expr ⟶ » W U)(iV : «expr ⟶ » W V), F.map iU.op s = F.map iV.op t :=\n  by\n  obtain ⟨W, iU, iV, e⟩ :=\n    (Types.FilteredColimit.isColimit_eq_iff.{v, v} _\n          (is_colimit_of_preserves _ (colimit.is_colimit («expr ⋙ » (open_nhds.inclusion x).op F)))).mp\n      h\n  exact ⟨(unop W).1, (unop W).2, iU.unop, iV.unop, e⟩\n#align germ_eq germ_eq\n\n",
 "comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr _* » -/\n-- This proof is sadly not at all robust:\n-- having to use `erw` at all is a bad sign.\n@[simp]\ntheorem comp (ℱ : X.presheaf C) (f : «expr ⟶ » X Y) (g : «expr ⟶ » Y Z) (x : X) :\n    ℱ.stalk_pushforward C («expr ≫ » f g) x =\n      «expr ≫ » ((«expr _* » f ℱ).stalk_pushforward C g (f x)) (ℱ.stalk_pushforward C f x) :=\n  by\n  dsimp [stalk_pushforward, stalk_functor]\n  ext U\n  induction U using Opposite.rec'\n  rcases U with ⟨⟨_, _⟩, _⟩\n  simp only [colimit.ι_map_assoc, colimit.ι_pre_assoc, whisker_right_app, category.assoc]\n  dsimp\n  -- FIXME: Some of these are simp lemmas, but don't fire successfully:\n  erw [CategoryTheory.Functor.map_id, category.id_comp, category.id_comp, category.id_comp, colimit.ι_pre,\n    colimit.ι_pre]\n  rfl\n#align comp comp\n\n",
 "app_surjective_of_stalk_functor_map_bijective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem app_surjective_of_stalk_functor_map_bijective {F G : sheaf C X} (f : «expr ⟶ » F G) (U : Opens X)\n    (h : ∀ x : U, function.bijective ((stalk_functor C x.val).map f.1)) : function.surjective (f.1.app (op U)) :=\n  by\n  refine' app_surjective_of_injective_of_locally_surjective f U (fun x => (h x).1) fun t x => _\n  -- Now we need to prove our initial claim: That we can find preimages of `t` locally.\n  -- Since `f` is surjective on stalks, we can find a preimage `s₀` of the germ of `t` at `x`\n  obtain ⟨s₀, hs₀⟩ := (h x).2 (G.presheaf.germ x t)\n  -- ... and this preimage must come from some section `s₁` defined on some open neighborhood `V₁`\n  obtain ⟨V₁, hxV₁, s₁, hs₁⟩ := F.presheaf.germ_exist x.1 s₀\n  subst hs₁; rename' hs₀ => hs₁\n  erw [stalk_functor_map_germ_apply V₁ ⟨x.1, hxV₁⟩ f.1 s₁] at hs₁\n  -- Now, the germ of `f.app (op V₁) s₁` equals the germ of `t`, hence they must coincide on\n  -- some open neighborhood `V₂`.\n  obtain ⟨V₂, hxV₂, iV₂V₁, iV₂U, heq⟩ := G.presheaf.germ_eq x.1 hxV₁ x.2 _ _ hs₁\n  -- The restriction of `s₁` to that neighborhood is our desired local preimage.\n  use V₂, hxV₂, iV₂U, F.1.map iV₂V₁.op s₁\n  rw [← comp_apply, f.1.naturality, comp_apply, HEq]\n#align app_surjective_of_stalk_functor_map_bijective app_surjective_of_stalk_functor_map_bijective\n\n",
 "app_surjective_of_injective_of_locally_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/-- For surjectivity, we are given an arbitrary section `t` and need to find a preimage for it.\nWe claim that it suffices to find preimages *locally*. That is, for each `x : U` we construct\na neighborhood `V ≤ U` and a section `s : F.obj (op V))` such that `f.app (op V) s` and `t`\nagree on `V`. -/\ntheorem app_surjective_of_injective_of_locally_surjective {F G : sheaf C X} (f : «expr ⟶ » F G) (U : Opens X)\n    (hinj : ∀ x : U, function.injective ((stalk_functor C x.1).map f.1))\n    (hsurj :\n      ∀ (t) (x : U),\n        ∃ (V : Opens X)(m : x.1 ∈ V)(iVU : «expr ⟶ » V U)(s : F.1.obj (op V)), f.1.app (op V) s = G.1.map iVU.op t) :\n    function.surjective (f.1.app (op U)) := by\n  intro t\n  -- We use the axiom of choice to pick around each point `x` an open neighborhood `V` and a\n  -- preimage under `f` on `V`.\n  choose V mV iVU sf heq using hsurj t\n  -- These neighborhoods clearly cover all of `U`.\n  have V_cover : U ≤ supᵢ V := by\n    intro x hxU\n    rw [opens.mem_supr]\n    exact ⟨⟨x, hxU⟩, mV ⟨x, hxU⟩⟩\n  -- Since `F` is a sheaf, we can glue all the local preimages together to get a global preimage.\n  obtain ⟨s, s_spec, -⟩ := F.exists_unique_gluing' V U iVU V_cover sf _\n  · use s\n    apply G.eq_of_locally_eq' V U iVU V_cover\n    intro x\n    rw [← comp_apply, ← f.1.naturality, comp_apply, s_spec, HEq]\n  · intro x y\n    -- What's left to show here is that the secions `sf` are compatible, i.e. they agree on\n    -- the intersections `V x ⊓ V y`. We prove this by showing that all germs are equal.\n    apply section_ext\n    intro z\n    -- Here, we need to use injectivity of the stalk maps.\n    apply hinj ⟨z, (iVU x).le ((inf_le_left : «expr ⊓ » (V x) (V y) ≤ V x) z.2)⟩\n    dsimp only\n    erw [stalk_functor_map_germ_apply, stalk_functor_map_germ_apply]\n    simp_rw [← comp_apply, f.1.naturality, comp_apply, HEq, ← comp_apply, ← G.1.map_comp]\n    rfl\n#align app_surjective_of_injective_of_locally_surjective app_surjective_of_injective_of_locally_surjective\n\n",
 "app_is_iso_of_stalk_functor_map_iso":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem app_is_iso_of_stalk_functor_map_iso {F G : sheaf C X} (f : «expr ⟶ » F G) (U : Opens X)\n    [∀ x : U, IsIso ((stalk_functor C x.val).map f.1)] : IsIso (f.1.app (op U)) :=\n  by\n  -- Since the forgetful functor of `C` reflects isomorphisms, it suffices to see that the\n  -- underlying map between types is an isomorphism, i.e. bijective.\n  suffices is_iso ((forget C).map (f.1.app (op U))) by exact is_iso_of_reflects_iso (f.1.app (op U)) (forget C)\n  rw [is_iso_iff_bijective]\n  apply app_bijective_of_stalk_functor_map_bijective\n  intro x\n  apply (is_iso_iff_bijective _).mp\n  exact functor.map_is_iso (forget C) ((stalk_functor C x.1).map f.1)\n#align app_is_iso_of_stalk_functor_map_iso app_is_iso_of_stalk_functor_map_iso\n\n",
 "app_injective_of_stalk_functor_map_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/-\nNote that the analogous statement for surjectivity is false: Surjectivity on stalks does not\nimply surjectivity of the components of a sheaf morphism. However it does imply that the morphism\nis an epi, but this fact is not yet formalized.\n-/\ntheorem app_injective_of_stalk_functor_map_injective {F : sheaf C X} {G : presheaf C X} (f : «expr ⟶ » F.1 G)\n    (U : Opens X) (h : ∀ x : U, function.injective ((stalk_functor C x.val).map f)) :\n    function.injective (f.app (op U)) := fun s t hst =>\n  section_ext F _ _ _ fun x => h x <| by rw [stalk_functor_map_germ_apply, stalk_functor_map_germ_apply, hst]\n#align app_injective_of_stalk_functor_map_injective app_injective_of_stalk_functor_map_injective\n\n",
 "app_injective_iff_stalk_functor_map_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem app_injective_iff_stalk_functor_map_injective {F : sheaf C X} {G : presheaf C X} (f : «expr ⟶ » F.1 G) :\n    (∀ x : X, function.injective ((stalk_functor C x).map f)) ↔ ∀ U : Opens X, function.injective (f.app (op U)) :=\n  ⟨fun h U => app_injective_of_stalk_functor_map_injective f U fun x => h x.1,\n    stalk_functor_map_injective_of_app_injective f⟩\n#align app_injective_iff_stalk_functor_map_injective app_injective_iff_stalk_functor_map_injective\n\n",
 "app_bijective_of_stalk_functor_map_bijective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem app_bijective_of_stalk_functor_map_bijective {F G : sheaf C X} (f : «expr ⟶ » F G) (U : Opens X)\n    (h : ∀ x : U, function.bijective ((stalk_functor C x.val).map f.1)) : function.bijective (f.1.app (op U)) :=\n  ⟨app_injective_of_stalk_functor_map_injective f.1 U fun x => (h x).1,\n    app_surjective_of_stalk_functor_map_bijective f U h⟩\n#align app_bijective_of_stalk_functor_map_bijective app_bijective_of_stalk_functor_map_bijective\n\n"}