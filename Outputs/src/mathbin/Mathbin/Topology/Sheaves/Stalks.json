{"stalk_specializes_stalk_pushforward":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¤³ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr _* Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n@[simp, reassoc.1, elementwise]\ntheorem stalk_specializes_stalk_pushforward (f : Â«expr âŸ¶ Â» X Y) (F : X.presheaf C) {x y : X} (h : Â«expr â¤³ Â» x y) :\n    Â«expr â‰« Â» ((Â«expr _* Â» f F).stalk_specializes (f.map_specializes h)) (F.stalk_pushforward _ f x) =\n      Â«expr â‰« Â» (F.stalk_pushforward _ f y) (F.stalk_specializes h) :=\n  by\n  ext\n  delta stalk_pushforward\n  simpa [stalk_specializes]\n#align stalk_specializes_stalk_pushforward stalk_specializes_stalk_pushforward\n\n",
 "stalk_specializes_stalk_functor_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¤³ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n@[simp, reassoc.1, elementwise]\ntheorem stalk_specializes_stalk_functor_map {F G : X.presheaf C} (f : Â«expr âŸ¶ Â» F G) {x y : X} (h : Â«expr â¤³ Â» x y) :\n    Â«expr â‰« Â» (F.stalk_specializes h) ((stalk_functor C x).map f) =\n      Â«expr â‰« Â» ((stalk_functor C y).map f) (G.stalk_specializes h) :=\n  by\n  ext\n  delta stalk_functor\n  simpa [stalk_specializes]\n#align stalk_specializes_stalk_functor_map stalk_specializes_stalk_functor_map\n\n",
 "stalk_specializes_refl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n@[simp]\ntheorem stalk_specializes_refl {C : Type _} [Category C] [Limits.HasColimits C] {X : TopCat} (F : X.presheaf C)\n    (x : X) : F.stalk_specializes (specializes_refl x) = (Â«exprğŸ™Â») _ :=\n  F.stalk_hom_ext fun _ _ => by\n    dsimp\n    simpa\n#align stalk_specializes_refl stalk_specializes_refl\n\n",
 "stalk_specializes_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¤³ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¤³ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n@[simp, reassoc.1, elementwise]\ntheorem stalk_specializes_comp {C : Type _} [Category C] [Limits.HasColimits C] {X : TopCat} (F : X.presheaf C)\n    {x y z : X} (h : Â«expr â¤³ Â» x y) (h' : Â«expr â¤³ Â» y z) :\n    Â«expr â‰« Â» (F.stalk_specializes h') (F.stalk_specializes h) = F.stalk_specializes (h.trans h') :=\n  F.stalk_hom_ext fun _ _ => by simp\n#align stalk_specializes_comp stalk_specializes_comp\n\n",
 "stalk_pushforward_iso_of_open_embedding":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰ªâ‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‹™ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr _* Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‹™ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr _* Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem stalk_pushforward_iso_of_open_embedding {f : Â«expr âŸ¶ Â» X Y} (hf : OpenEmbedding f) (F : X.presheaf C) (x : X) :\n    IsIso (F.stalk_pushforward _ f x) :=\n  by\n  haveI := functor.initial_of_adjunction (hf.is_open_map.adjunction_nhds x)\n  convert is_iso.of_iso\n      (Â«expr â‰ªâ‰« Â»\n        (functor.final.colimit_iso (hf.is_open_map.functor_nhds x).op\n              (Â«expr â‹™ Â» (open_nhds.inclusion (f x)).op (Â«expr _* Â» f F)) :\n            _).symm\n        (colim.map_iso _))\n  swap\n  Â· fapply nat_iso.of_components\n    Â· intro U\n      refine' F.map_iso (eq_to_iso _)\n      dsimp only [functor.op]\n      exact congr_arg op (opens.ext <| Set.preimage_image_eq (unop U).1.1 hf.inj)\n    Â· intro U V i\n      erw [â† F.map_comp, â† F.map_comp]\n      congr\n  Â· ext U\n    rw [â† iso.comp_inv_eq]\n    erw [colimit.Î¹_map_assoc]\n    rw [colimit.Î¹_pre, category.assoc]\n    erw [colimit.Î¹_map_assoc, colimit.Î¹_pre, â† F.map_comp_assoc]\n    apply colimit.w (Â«expr â‹™ Â» (open_nhds.inclusion (f x)).op (Â«expr _* Â» f F)) _\n    dsimp only [functor.op]\n    refine' ((hom_of_le _).op : Â«expr âŸ¶ Â» (op (unop U)) _)\n    exact Set.image_preimage_subset _ _\n#align stalk_pushforward_iso_of_open_embedding stalk_pushforward_iso_of_open_embedding\n\n",
 "stalk_pushforward_germ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr _* Â» -/\n-- This is a hack; Lean doesn't like to elaborate the term written directly.\n@[simp, elementwise, reassoc.1]\ntheorem stalk_pushforward_germ (f : Â«expr âŸ¶ Â» X Y) (F : X.presheaf C) (U : Opens Y) (x : (Opens.map f).obj U) :\n    Â«expr â‰« Â» ((Â«expr _* Â» f F).germ âŸ¨f x, x.2âŸ©) (F.stalk_pushforward C f x) = F.germ x :=\n  by\n  rw [stalk_pushforward, germ, colimit.Î¹_map_assoc, colimit.Î¹_pre, whisker_right_app]\n  erw [CategoryTheory.Functor.map_id, category.id_comp]\n  rfl\n#align stalk_pushforward_germ stalk_pushforward_germ\n\n",
 "stalk_open_algebra_map":
 "@[simp]\ntheorem stalk_open_algebra_map {X : TopCat} (F : X.presheaf CommRing) {U : Opens X} (x : U) :\n    algebraMap (F.obj <| op U) (F.stalk x) = F.germ x :=\n  rfl\n#align stalk_open_algebra_map stalk_open_algebra_map\n\n",
 "stalk_mono_of_mono":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‹™ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem stalk_mono_of_mono {F G : sheaf C X} (f : Â«expr âŸ¶ Â» F G) [Mono f] : âˆ€ x, Mono <| (stalk_functor C x).map f.1 :=\n  fun x => by convert functor.map_mono (Â«expr â‹™ Â» (sheaf.forget.{v} C X) (stalk_functor C x)) f\n#align stalk_mono_of_mono stalk_mono_of_mono\n\n",
 "stalk_hom_ext":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/-- A morphism from the stalk of `F` at `x` to some object `Y` is completely determined by its\ncomposition with the `germ` morphisms.\n-/\ntheorem stalk_hom_ext (F : X.presheaf C) {x} {Y : C} {fâ‚ fâ‚‚ : Â«expr âŸ¶ Â» (F.stalk x) Y}\n    (ih : âˆ€ (U : Opens X) (hxU : x âˆˆ U), Â«expr â‰« Â» (F.germ âŸ¨x, hxUâŸ©) fâ‚ = Â«expr â‰« Â» (F.germ âŸ¨x, hxUâŸ©) fâ‚‚) : fâ‚ = fâ‚‚ :=\n  colimit.hom_ext fun U => by\n    induction U using Opposite.rec'\n    cases' U with U hxU\n    exact ih U hxU\n#align stalk_hom_ext stalk_hom_ext\n\n",
 "stalk_functor_obj":
 "/-\nCopyright (c) 2019 Scott Morrison. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Scott Morrison, Justus Springer\n-/\n-- -- colimit ((open_nhds.inclusion x).op â‹™ â„±)\n@[simp]\ntheorem stalk_functor_obj (â„± : X.presheaf C) (x : X) : (stalk_functor C x).obj â„± = â„±.stalk x :=\n  rfl\n#align stalk_functor_obj stalk_functor_obj\n\n",
 "stalk_functor_map_injective_of_app_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem stalk_functor_map_injective_of_app_injective {F G : presheaf C X} (f : Â«expr âŸ¶ Â» F G)\n    (h : âˆ€ U : Opens X, function.injective (f.app (op U))) (x : X) : function.injective ((stalk_functor C x).map f) :=\n  fun s t hst => by\n  rcases germ_exist F x s with âŸ¨Uâ‚, hxUâ‚, s, rflâŸ©\n  rcases germ_exist F x t with âŸ¨Uâ‚‚, hxUâ‚‚, t, rflâŸ©\n  simp only [stalk_functor_map_germ_apply _ âŸ¨x, _âŸ©] at hst\n  obtain âŸ¨W, hxW, iWUâ‚, iWUâ‚‚, heqâŸ© := G.germ_eq x hxUâ‚ hxUâ‚‚ _ _ hst\n  rw [â† comp_apply, â† comp_apply, â† f.naturality, â† f.naturality, comp_apply, comp_apply] at heq\n  replace heq := h W HEq\n  convert congr_arg (F.germ âŸ¨x, hxWâŸ©) HEq\n  exacts[(F.germ_res_apply iWUâ‚ âŸ¨x, hxWâŸ© s).symm, (F.germ_res_apply iWUâ‚‚ âŸ¨x, hxWâŸ© t).symm]\n#align stalk_functor_map_injective_of_app_injective stalk_functor_map_injective_of_app_injective\n\n",
 "stalk_functor_map_germ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n@[simp, reassoc.1, elementwise]\ntheorem stalk_functor_map_germ {F G : X.presheaf C} (U : Opens X) (x : U) (f : Â«expr âŸ¶ Â» F G) :\n    Â«expr â‰« Â» (germ F x) ((stalk_functor C x.1).map f) = Â«expr â‰« Â» (f.app (op U)) (germ G x) :=\n  colimit.Î¹_map (whiskerLeft (OpenNhds.inclusion x.1).op f) (op âŸ¨U, x.2âŸ©)\n#align stalk_functor_map_germ stalk_functor_map_germ\n\n",
 "section_ext":
 "/-- Let `F` be a sheaf valued in a concrete category, whose forgetful functor reflects isomorphisms,\npreserves limits and filtered colimits. Then two sections who agree on every stalk must be equal.\n-/\ntheorem section_ext (F : sheaf C X) (U : Opens X) (s t : F.1.obj (op U))\n    (h : âˆ€ x : U, F.presheaf.germ x s = F.presheaf.germ x t) : s = t :=\n  by\n  -- We use `germ_eq` and the axiom of choice, to pick for every point `x` a neighbourhood\n  -- `V x`, such that the restrictions of `s` and `t` to `V x` coincide.\n  choose V m iâ‚ iâ‚‚ heq using fun x : U => F.presheaf.germ_eq x.1 x.2 x.2 s t (h x)\n  -- Since `F` is a sheaf, we can prove the equality locally, if we can show that these\n  -- neighborhoods form a cover of `U`.\n  apply F.eq_of_locally_eq' V U iâ‚\n  Â· intro x hxU\n    rw [opens.mem_supr]\n    exact âŸ¨âŸ¨x, hxUâŸ©, m âŸ¨x, hxUâŸ©âŸ©\n  Â· intro x\n    rw [HEq, subsingleton.elim (iâ‚ x) (iâ‚‚ x)]\n#align section_ext section_ext\n\n",
 "mono_of_stalk_mono":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem mono_of_stalk_mono {F G : sheaf C X} (f : Â«expr âŸ¶ Â» F G) [âˆ€ x, Mono <| (stalk_functor C x).map f.1] : Mono f :=\n  (Sheaf.Hom.mono_iff_presheaf_mono _ _ _).mpr <|\n    (NatTrans.mono_iff_mono_app _ _).mpr fun U =>\n      (ConcreteCategory.mono_iff_injective_of_preservesPullback _).mpr <|\n        app_injective_of_stalk_functor_map_injective f.1 U.unop fun âŸ¨x, hxâŸ© =>\n          (ConcreteCategory.mono_iff_injective_of_preservesPullback _).mp <| inferInstance\n#align mono_of_stalk_mono mono_of_stalk_mono\n\n",
 "mono_iff_stalk_mono":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem mono_iff_stalk_mono {F G : sheaf C X} (f : Â«expr âŸ¶ Â» F G) : Mono f â†” âˆ€ x, Mono ((stalk_functor C x).map f.1) :=\n  âŸ¨by\n    intro m\n    exact stalk_mono_of_mono _, by\n    intro m\n    exact mono_of_stalk_mono _âŸ©\n#align mono_iff_stalk_mono mono_iff_stalk_mono\n\n",
 "is_iso_of_stalk_functor_map_iso":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr áµ’áµ–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n-- Making this an instance would cause a loop in typeclass resolution with `functor.map_is_iso`\n/-- Let `F` and `G` be sheaves valued in a concrete category, whose forgetful functor reflects\nisomorphisms, preserves limits and filtered colimits. Then if the stalk maps of a morphism\n`f : F âŸ¶ G` are all isomorphisms, `f` must be an isomorphism.\n-/\ntheorem is_iso_of_stalk_functor_map_iso {F G : sheaf C X} (f : Â«expr âŸ¶ Â» F G)\n    [âˆ€ x : X, IsIso ((stalk_functor C x).map f.1)] : IsIso f :=\n  by\n  -- Since the inclusion functor from sheaves to presheaves is fully faithful, it suffices to\n  -- show that `f`, as a morphism between _presheaves_, is an isomorphism.\n  suffices is_iso ((sheaf.forget C X).map f) by exact is_iso_of_fully_faithful (sheaf.forget C X) f\n  -- We show that all components of `f` are isomorphisms.\n  suffices âˆ€ U : Â«expr áµ’áµ–Â» (opens X), is_iso (f.1.app U) by exact @nat_iso.is_iso_of_is_iso_app _ _ _ _ F.1 G.1 f.1 this\n  intro U\n  induction U using Opposite.rec'\n  apply app_is_iso_of_stalk_functor_map_iso\n#align is_iso_of_stalk_functor_map_iso is_iso_of_stalk_functor_map_iso\n\n",
 "is_iso_iff_stalk_functor_map_iso":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/-- Let `F` and `G` be sheaves valued in a concrete category, whose forgetful functor reflects\nisomorphisms, preserves limits and filtered colimits. Then a morphism `f : F âŸ¶ G` is an\nisomorphism if and only if all of its stalk maps are isomorphisms.\n-/\ntheorem is_iso_iff_stalk_functor_map_iso {F G : sheaf C X} (f : Â«expr âŸ¶ Â» F G) :\n    IsIso f â†” âˆ€ x : X, IsIso ((stalk_functor C x).map f.1) :=\n  by\n  constructor\n  Â· intro h x\n    skip\n    exact @functor.map_is_iso _ _ _ _ _ _ (stalk_functor C x) f.1 ((sheaf.forget C X).map_is_iso f)\n  Â· intro h\n    exact is_iso_of_stalk_functor_map_iso f\n#align is_iso_iff_stalk_functor_map_iso is_iso_iff_stalk_functor_map_iso\n\n",
 "id":
 "/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:69:18: unsupported non-interactive tactic tactic.op_induction' -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n#print id /-\n-- Here are two other potential solutions, suggested by @fpvandoorn at\n-- <https://github.com/leanprover-community/mathlib/pull/1018#discussion_r283978240>\n-- However, I can't get the subsequent two proofs to work with either one.\n-- def stalk_pushforward (f : X âŸ¶ Y) (â„± : X.presheaf C) (x : X) :\n--   (f _* â„±).stalk (f x) âŸ¶ â„±.stalk x :=\n-- colim.map ((functor.associator _ _ _).inv â‰«\n--   whisker_right (nat_trans.op (open_nhds.inclusion_map_iso f x).inv) â„±) â‰«\n-- colimit.pre ((open_nhds.inclusion x).op â‹™ â„±) (open_nhds.map f x).op\n-- def stalk_pushforward (f : X âŸ¶ Y) (â„± : X.presheaf C) (x : X) :\n--   (f _* â„±).stalk (f x) âŸ¶ â„±.stalk x :=\n-- (colim.map (whisker_right (nat_trans.op (open_nhds.inclusion_map_iso f x).inv) â„±) :\n--   colim.obj ((open_nhds.inclusion (f x) â‹™ opens.map f).op â‹™ â„±) âŸ¶ _) â‰«\n-- colimit.pre ((open_nhds.inclusion x).op â‹™ â„±) (open_nhds.map f x).op\n@[simp]\ntheorem id (â„± : X.presheaf C) (x : X) :\n    â„±.stalk_pushforward C ((Â«exprğŸ™Â») X) x = (stalk_functor C x).map (pushforward.id â„±).hom :=\n  by\n  dsimp [stalk_pushforward, stalk_functor]\n  ext1\n  run_tac\n    tactic.op_induction'\n  rcases j with âŸ¨âŸ¨_, _âŸ©, _âŸ©\n  rw [colimit.Î¹_map_assoc, colimit.Î¹_map, colimit.Î¹_pre, whisker_left_app, whisker_right_app, pushforward.id_hom_app,\n    eq_to_hom_map, eq_to_hom_refl]\n  dsimp\n  -- FIXME A simp lemma which unfortunately doesn't fire:\n  erw [CategoryTheory.Functor.map_id]\n#align id id\n-/\n\n",
 "germ_stalk_specializes'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¤³ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n@[simp, reassoc.1, elementwise]\ntheorem germ_stalk_specializes' (F : X.presheaf C) {U : Opens X} {x y : X} (h : Â«expr â¤³ Â» x y) (hy : y âˆˆ U) :\n    Â«expr â‰« Â» (F.germ âŸ¨y, hyâŸ©) (F.stalk_specializes h) = F.germ âŸ¨x, h.mem_open U.is_open hyâŸ© :=\n  colimit.Î¹_desc _ _\n#align germ_stalk_specializes' germ_stalk_specializes'\n\n",
 "germ_stalk_specializes":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¤³ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n@[simp, reassoc.1, elementwise]\ntheorem germ_stalk_specializes (F : X.presheaf C) {U : Opens X} {y : U} {x : X} (h : Â«expr â¤³ Â» x y) :\n    Â«expr â‰« Â» (F.germ y) (F.stalk_specializes h) = F.germ (âŸ¨x, h.mem_open U.is_open y.propâŸ© : U) :=\n  colimit.Î¹_desc _ _\n#align germ_stalk_specializes germ_stalk_specializes\n\n",
 "germ_res":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‹™ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n@[simp, elementwise]\ntheorem germ_res (F : X.presheaf C) {U V : Opens X} (i : Â«expr âŸ¶ Â» U V) (x : U) :\n    Â«expr â‰« Â» (F.map i.op) (germ F x) = germ F (i x : V) :=\n  let i' : Â«expr âŸ¶ Â» (âŸ¨U, x.2âŸ© : OpenNhds x.1) âŸ¨V, (i x : V).2âŸ© := i\n  colimit.w (Â«expr â‹™ Â» (OpenNhds.inclusion x.1).op F) i'.op\n#align germ_res germ_res\n\n",
 "germ_ext":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n@[ext]\ntheorem germ_ext (F : X.presheaf C) {U V : Opens X} {x : X} {hxU : x âˆˆ U} {hxV : x âˆˆ V} (W : Opens X) (hxW : x âˆˆ W)\n    (iWU : Â«expr âŸ¶ Â» W U) (iWV : Â«expr âŸ¶ Â» W V) {sU : F.obj (op U)} {sV : F.obj (op V)}\n    (ih : F.map iWU.op sU = F.map iWV.op sV) : F.germ âŸ¨x, hxUâŸ© sU = F.germ âŸ¨x, hxVâŸ© sV := by\n  erw [â† F.germ_res iWU âŸ¨x, hxWâŸ©, â† F.germ_res iWV âŸ¨x, hxWâŸ©, comp_apply, comp_apply, ih]\n#align germ_ext germ_ext\n\n",
 "germ_exist":
 "/-- For presheaves valued in a concrete category whose forgetful functor preserves filtered colimits,\nevery element of the stalk is the germ of a section.\n-/\ntheorem germ_exist (F : X.presheaf C) (x : X) (t : stalk F x) :\n    âˆƒ (U : Opens X)(m : x âˆˆ U)(s : F.obj (op U)), F.germ âŸ¨x, mâŸ© s = t :=\n  by\n  obtain âŸ¨U, s, eâŸ© := Types.jointly_surjective.{v, v} _ (is_colimit_of_preserves (forget C) (colimit.is_colimit _)) t\n  revert s e\n  rw [show U = op (unop U) from rfl]\n  generalize unop U = V; clear U\n  cases' V with V m\n  intro s e\n  exact âŸ¨V, m, s, eâŸ©\n#align germ_exist germ_exist\n\n",
 "germ_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‹™ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem germ_eq (F : X.presheaf C) {U V : Opens X} (x : X) (mU : x âˆˆ U) (mV : x âˆˆ V) (s : F.obj (op U))\n    (t : F.obj (op V)) (h : germ F âŸ¨x, mUâŸ© s = germ F âŸ¨x, mVâŸ© t) :\n    âˆƒ (W : Opens X)(m : x âˆˆ W)(iU : Â«expr âŸ¶ Â» W U)(iV : Â«expr âŸ¶ Â» W V), F.map iU.op s = F.map iV.op t :=\n  by\n  obtain âŸ¨W, iU, iV, eâŸ© :=\n    (Types.FilteredColimit.isColimit_eq_iff.{v, v} _\n          (is_colimit_of_preserves _ (colimit.is_colimit (Â«expr â‹™ Â» (open_nhds.inclusion x).op F)))).mp\n      h\n  exact âŸ¨(unop W).1, (unop W).2, iU.unop, iV.unop, eâŸ©\n#align germ_eq germ_eq\n\n",
 "comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr _* Â» -/\n-- This proof is sadly not at all robust:\n-- having to use `erw` at all is a bad sign.\n@[simp]\ntheorem comp (â„± : X.presheaf C) (f : Â«expr âŸ¶ Â» X Y) (g : Â«expr âŸ¶ Â» Y Z) (x : X) :\n    â„±.stalk_pushforward C (Â«expr â‰« Â» f g) x =\n      Â«expr â‰« Â» ((Â«expr _* Â» f â„±).stalk_pushforward C g (f x)) (â„±.stalk_pushforward C f x) :=\n  by\n  dsimp [stalk_pushforward, stalk_functor]\n  ext U\n  induction U using Opposite.rec'\n  rcases U with âŸ¨âŸ¨_, _âŸ©, _âŸ©\n  simp only [colimit.Î¹_map_assoc, colimit.Î¹_pre_assoc, whisker_right_app, category.assoc]\n  dsimp\n  -- FIXME: Some of these are simp lemmas, but don't fire successfully:\n  erw [CategoryTheory.Functor.map_id, category.id_comp, category.id_comp, category.id_comp, colimit.Î¹_pre,\n    colimit.Î¹_pre]\n  rfl\n#align comp comp\n\n",
 "app_surjective_of_stalk_functor_map_bijective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem app_surjective_of_stalk_functor_map_bijective {F G : sheaf C X} (f : Â«expr âŸ¶ Â» F G) (U : Opens X)\n    (h : âˆ€ x : U, function.bijective ((stalk_functor C x.val).map f.1)) : function.surjective (f.1.app (op U)) :=\n  by\n  refine' app_surjective_of_injective_of_locally_surjective f U (fun x => (h x).1) fun t x => _\n  -- Now we need to prove our initial claim: That we can find preimages of `t` locally.\n  -- Since `f` is surjective on stalks, we can find a preimage `sâ‚€` of the germ of `t` at `x`\n  obtain âŸ¨sâ‚€, hsâ‚€âŸ© := (h x).2 (G.presheaf.germ x t)\n  -- ... and this preimage must come from some section `sâ‚` defined on some open neighborhood `Vâ‚`\n  obtain âŸ¨Vâ‚, hxVâ‚, sâ‚, hsâ‚âŸ© := F.presheaf.germ_exist x.1 sâ‚€\n  subst hsâ‚; rename' hsâ‚€ => hsâ‚\n  erw [stalk_functor_map_germ_apply Vâ‚ âŸ¨x.1, hxVâ‚âŸ© f.1 sâ‚] at hsâ‚\n  -- Now, the germ of `f.app (op Vâ‚) sâ‚` equals the germ of `t`, hence they must coincide on\n  -- some open neighborhood `Vâ‚‚`.\n  obtain âŸ¨Vâ‚‚, hxVâ‚‚, iVâ‚‚Vâ‚, iVâ‚‚U, heqâŸ© := G.presheaf.germ_eq x.1 hxVâ‚ x.2 _ _ hsâ‚\n  -- The restriction of `sâ‚` to that neighborhood is our desired local preimage.\n  use Vâ‚‚, hxVâ‚‚, iVâ‚‚U, F.1.map iVâ‚‚Vâ‚.op sâ‚\n  rw [â† comp_apply, f.1.naturality, comp_apply, HEq]\n#align app_surjective_of_stalk_functor_map_bijective app_surjective_of_stalk_functor_map_bijective\n\n",
 "app_surjective_of_injective_of_locally_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŠ“ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/-- For surjectivity, we are given an arbitrary section `t` and need to find a preimage for it.\nWe claim that it suffices to find preimages *locally*. That is, for each `x : U` we construct\na neighborhood `V â‰¤ U` and a section `s : F.obj (op V))` such that `f.app (op V) s` and `t`\nagree on `V`. -/\ntheorem app_surjective_of_injective_of_locally_surjective {F G : sheaf C X} (f : Â«expr âŸ¶ Â» F G) (U : Opens X)\n    (hinj : âˆ€ x : U, function.injective ((stalk_functor C x.1).map f.1))\n    (hsurj :\n      âˆ€ (t) (x : U),\n        âˆƒ (V : Opens X)(m : x.1 âˆˆ V)(iVU : Â«expr âŸ¶ Â» V U)(s : F.1.obj (op V)), f.1.app (op V) s = G.1.map iVU.op t) :\n    function.surjective (f.1.app (op U)) := by\n  intro t\n  -- We use the axiom of choice to pick around each point `x` an open neighborhood `V` and a\n  -- preimage under `f` on `V`.\n  choose V mV iVU sf heq using hsurj t\n  -- These neighborhoods clearly cover all of `U`.\n  have V_cover : U â‰¤ supáµ¢ V := by\n    intro x hxU\n    rw [opens.mem_supr]\n    exact âŸ¨âŸ¨x, hxUâŸ©, mV âŸ¨x, hxUâŸ©âŸ©\n  -- Since `F` is a sheaf, we can glue all the local preimages together to get a global preimage.\n  obtain âŸ¨s, s_spec, -âŸ© := F.exists_unique_gluing' V U iVU V_cover sf _\n  Â· use s\n    apply G.eq_of_locally_eq' V U iVU V_cover\n    intro x\n    rw [â† comp_apply, â† f.1.naturality, comp_apply, s_spec, HEq]\n  Â· intro x y\n    -- What's left to show here is that the secions `sf` are compatible, i.e. they agree on\n    -- the intersections `V x âŠ“ V y`. We prove this by showing that all germs are equal.\n    apply section_ext\n    intro z\n    -- Here, we need to use injectivity of the stalk maps.\n    apply hinj âŸ¨z, (iVU x).le ((inf_le_left : Â«expr âŠ“ Â» (V x) (V y) â‰¤ V x) z.2)âŸ©\n    dsimp only\n    erw [stalk_functor_map_germ_apply, stalk_functor_map_germ_apply]\n    simp_rw [â† comp_apply, f.1.naturality, comp_apply, HEq, â† comp_apply, â† G.1.map_comp]\n    rfl\n#align app_surjective_of_injective_of_locally_surjective app_surjective_of_injective_of_locally_surjective\n\n",
 "app_is_iso_of_stalk_functor_map_iso":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem app_is_iso_of_stalk_functor_map_iso {F G : sheaf C X} (f : Â«expr âŸ¶ Â» F G) (U : Opens X)\n    [âˆ€ x : U, IsIso ((stalk_functor C x.val).map f.1)] : IsIso (f.1.app (op U)) :=\n  by\n  -- Since the forgetful functor of `C` reflects isomorphisms, it suffices to see that the\n  -- underlying map between types is an isomorphism, i.e. bijective.\n  suffices is_iso ((forget C).map (f.1.app (op U))) by exact is_iso_of_reflects_iso (f.1.app (op U)) (forget C)\n  rw [is_iso_iff_bijective]\n  apply app_bijective_of_stalk_functor_map_bijective\n  intro x\n  apply (is_iso_iff_bijective _).mp\n  exact functor.map_is_iso (forget C) ((stalk_functor C x.1).map f.1)\n#align app_is_iso_of_stalk_functor_map_iso app_is_iso_of_stalk_functor_map_iso\n\n",
 "app_injective_of_stalk_functor_map_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/-\nNote that the analogous statement for surjectivity is false: Surjectivity on stalks does not\nimply surjectivity of the components of a sheaf morphism. However it does imply that the morphism\nis an epi, but this fact is not yet formalized.\n-/\ntheorem app_injective_of_stalk_functor_map_injective {F : sheaf C X} {G : presheaf C X} (f : Â«expr âŸ¶ Â» F.1 G)\n    (U : Opens X) (h : âˆ€ x : U, function.injective ((stalk_functor C x.val).map f)) :\n    function.injective (f.app (op U)) := fun s t hst =>\n  section_ext F _ _ _ fun x => h x <| by rw [stalk_functor_map_germ_apply, stalk_functor_map_germ_apply, hst]\n#align app_injective_of_stalk_functor_map_injective app_injective_of_stalk_functor_map_injective\n\n",
 "app_injective_iff_stalk_functor_map_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem app_injective_iff_stalk_functor_map_injective {F : sheaf C X} {G : presheaf C X} (f : Â«expr âŸ¶ Â» F.1 G) :\n    (âˆ€ x : X, function.injective ((stalk_functor C x).map f)) â†” âˆ€ U : Opens X, function.injective (f.app (op U)) :=\n  âŸ¨fun h U => app_injective_of_stalk_functor_map_injective f U fun x => h x.1,\n    stalk_functor_map_injective_of_app_injective fâŸ©\n#align app_injective_iff_stalk_functor_map_injective app_injective_iff_stalk_functor_map_injective\n\n",
 "app_bijective_of_stalk_functor_map_bijective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem app_bijective_of_stalk_functor_map_bijective {F G : sheaf C X} (f : Â«expr âŸ¶ Â» F G) (U : Opens X)\n    (h : âˆ€ x : U, function.bijective ((stalk_functor C x.val).map f.1)) : function.bijective (f.1.app (op U)) :=\n  âŸ¨app_injective_of_stalk_functor_map_injective f.1 U fun x => (h x).1,\n    app_surjective_of_stalk_functor_map_bijective f U hâŸ©\n#align app_bijective_of_stalk_functor_map_bijective app_bijective_of_stalk_functor_map_bijective\n\n"}