{"is_sheaf_unique_gluing_of_is_sheaf_types":
 "/-- The sheaf condition in terms of unique gluings can be obtained from the usual\n\"equalizer\" sheaf condition.\n-/\ntheorem is_sheaf_unique_gluing_of_is_sheaf_types (Fsh : F.is_sheaf) : F.is_sheaf_unique_gluing :=\n  by\n  rw [is_sheaf_iff_is_sheaf_equalizer_products] at Fsh\n  intro ι U sf hsf\n  let sf' := (pi_opens_iso_sections_family F U).inv sf\n  have hsf' : left_res F U sf' = right_res F U sf' := by\n    rwa [← compatible_iff_left_res_eq_right_res F U sf', inv_hom_id_apply]\n  choose s s_spec s_uniq using types.unique_of_type_equalizer _ _ (Fsh U).some sf' hsf'\n  use s\n  dsimp\n  constructor\n  · convert(is_gluing_iff_eq_res F U sf' _).mpr s_spec\n    rw [inv_hom_id_apply]\n  · intro y hy\n    apply s_uniq\n    rw [← is_gluing_iff_eq_res F U]\n    convert hy\n    rw [inv_hom_id_apply]\n#align is_sheaf_unique_gluing_of_is_sheaf_types is_sheaf_unique_gluing_of_is_sheaf_types\n\n",
 "is_sheaf_of_is_sheaf_unique_gluing_types":
 "/-- The \"equalizer\" sheaf condition can be obtained from the sheaf condition\nin terms of unique gluings.\n-/\ntheorem is_sheaf_of_is_sheaf_unique_gluing_types (Fsh : F.is_sheaf_unique_gluing) : F.is_sheaf :=\n  by\n  rw [is_sheaf_iff_is_sheaf_equalizer_products]\n  intro ι U\n  refine' ⟨fork.is_limit.mk' _ _⟩\n  intro s\n  have h_compatible : ∀ x : s.X, F.is_compatible U ((F.pi_opens_iso_sections_family U).hom (s.ι x)) :=\n    by\n    intro x\n    rw [compatible_iff_left_res_eq_right_res]\n    convert congr_fun s.condition x\n  choose m m_spec m_uniq using fun x : s.X => Fsh U ((pi_opens_iso_sections_family F U).hom (s.ι x)) (h_compatible x)\n  refine' ⟨m, _, _⟩\n  · ext (⟨i⟩x)\n    simp [res]\n    exact m_spec x i\n  · intro l hl\n    ext x\n    apply m_uniq\n    rw [is_gluing_iff_eq_res]\n    exact congr_fun hl x\n#align is_sheaf_of_is_sheaf_unique_gluing_types is_sheaf_of_is_sheaf_unique_gluing_types\n\n",
 "is_sheaf_iff_is_sheaf_unique_gluing_types":
 "/-- For type-valued presheaves, the sheaf condition in terms of unique gluings is equivalent to the\nusual sheaf condition in terms of equalizer diagrams.\n-/\ntheorem is_sheaf_iff_is_sheaf_unique_gluing_types : F.is_sheaf ↔ F.is_sheaf_unique_gluing :=\n  iff.intro (is_sheaf_unique_gluing_of_is_sheaf_types F) (is_sheaf_of_is_sheaf_unique_gluing_types F)\n#align is_sheaf_iff_is_sheaf_unique_gluing_types is_sheaf_iff_is_sheaf_unique_gluing_types\n\n",
 "is_sheaf_iff_is_sheaf_unique_gluing":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/-- For presheaves valued in a concrete category, whose forgetful functor reflects isomorphisms and\npreserves limits, the sheaf condition in terms of unique gluings is equivalent to the usual one\nin terms of equalizer diagrams.\n-/\ntheorem is_sheaf_iff_is_sheaf_unique_gluing : F.is_sheaf ↔ F.is_sheaf_unique_gluing :=\n  iff.trans (is_sheaf_iff_is_sheaf_comp (forget C) F)\n    (is_sheaf_iff_is_sheaf_unique_gluing_types («expr ⋙ » F (forget C)))\n#align is_sheaf_iff_is_sheaf_unique_gluing is_sheaf_iff_is_sheaf_unique_gluing\n\n",
 "is_gluing_iff_eq_res":
 "/-- Under the isomorphism `pi_opens_iso_sections_family`, being a gluing of a family of\nsections `sf` is the same as lying in the preimage of `res` (the leftmost arrow of the\nequalizer diagram).\n-/\n@[simp]\ntheorem is_gluing_iff_eq_res (sf : pi_opens F U) (s : F.obj (op (supᵢ U))) :\n    is_gluing F U ((pi_opens_iso_sections_family F U).hom sf) s ↔ res F U s = sf :=\n  by\n  constructor <;> intro h\n  · ext ⟨i⟩\n    rw [res, types.limit.lift_π_apply', fan.mk_π_app]\n    exact h i\n  · intro i\n    convert congr_arg (limits.pi.π (fun i : ι => F.obj (op (U i))) i) h\n    rw [res, types.pi_lift_π_apply]\n    rfl\n#align is_gluing_iff_eq_res is_gluing_iff_eq_res\n\n",
 "exists_unique_gluing'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/-- In this version of the lemma, the inclusion homs `iUV` can be specified directly by the user,\nwhich can be more convenient in practice.\n-/\ntheorem exists_unique_gluing' (V : Opens X) (iUV : ∀ i : ι, «expr ⟶ » (U i) V) (hcover : V ≤ supᵢ U)\n    (sf : ∀ i : ι, F.1.obj (op (U i))) (h : is_compatible F.1 U sf) :\n    ∃! s : F.1.obj (op V), ∀ i : ι, F.1.map (iUV i).op s = sf i :=\n  by\n  have V_eq_supr_U : V = supᵢ U := le_antisymm hcover (supᵢ_le fun i => (iUV i).le)\n  obtain ⟨gl, gl_spec, gl_uniq⟩ := F.exists_unique_gluing U sf h\n  refine' ⟨F.1.map (eq_to_hom V_eq_supr_U).op gl, _, _⟩\n  · intro i\n    rw [← comp_apply, ← F.1.map_comp]\n    exact gl_spec i\n  · intro gl' gl'_spec\n    convert congr_arg _ (gl_uniq (F.1.map (eq_to_hom V_eq_supr_U.symm).op gl') fun i => _) <;>\n      rw [← comp_apply, ← F.1.map_comp]\n    · rw [eq_to_hom_op, eq_to_hom_op, eq_to_hom_trans, eq_to_hom_refl, F.1.map_id, id_apply]\n    · convert gl'_spec i\n#align exists_unique_gluing' exists_unique_gluing'\n\n",
 "exists_unique_gluing":
 "/-- A more convenient way of obtaining a unique gluing of sections for a sheaf.\n-/\ntheorem exists_unique_gluing (sf : ∀ i : ι, F.1.obj (op (U i))) (h : is_compatible F.1 U sf) :\n    ∃! s : F.1.obj (op (supᵢ U)), is_gluing F.1 U sf s :=\n  (is_sheaf_iff_is_sheaf_unique_gluing F.1).mp F.cond U sf h\n#align exists_unique_gluing exists_unique_gluing\n\n",
 "eq_of_locally_eq₂":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\ntheorem eq_of_locally_eq₂ {U₁ U₂ V : Opens X} (i₁ : «expr ⟶ » U₁ V) (i₂ : «expr ⟶ » U₂ V) (hcover : V ≤ «expr ⊔ » U₁ U₂)\n    (s t : F.1.obj (op V)) (h₁ : F.1.map i₁.op s = F.1.map i₁.op t) (h₂ : F.1.map i₂.op s = F.1.map i₂.op t) : s = t :=\n  by\n  classical\n    fapply F.eq_of_locally_eq' fun t : ULift Bool => if t.1 then U₁ else U₂\n    · exact fun i => if h : i.1 then «expr ≫ » (eq_to_hom (if_pos h)) i₁ else «expr ≫ » (eq_to_hom (if_neg h)) i₂\n    · refine' le_trans hcover _\n      rw [sup_le_iff]\n      constructor\n      · convert le_supᵢ (fun t : ULift Bool => if t.1 then U₁ else U₂) (ULift.up True)\n      · convert le_supᵢ (fun t : ULift Bool => if t.1 then U₁ else U₂) (ULift.up False)\n    · rintro ⟨_ | _⟩ <;> simp [h₁, h₂]\n#align eq_of_locally_eq₂ eq_of_locally_eq₂\n\n",
 "eq_of_locally_eq'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/-- In this version of the lemma, the inclusion homs `iUV` can be specified directly by the user,\nwhich can be more convenient in practice.\n-/\ntheorem eq_of_locally_eq' (V : Opens X) (iUV : ∀ i : ι, «expr ⟶ » (U i) V) (hcover : V ≤ supᵢ U) (s t : F.1.obj (op V))\n    (h : ∀ i, F.1.map (iUV i).op s = F.1.map (iUV i).op t) : s = t :=\n  by\n  have V_eq_supr_U : V = supᵢ U := le_antisymm hcover (supᵢ_le fun i => (iUV i).le)\n  suffices F.1.map (eq_to_hom V_eq_supr_U.symm).op s = F.1.map (eq_to_hom V_eq_supr_U.symm).op t by\n    convert congr_arg (F.1.map (eq_to_hom V_eq_supr_U).op) this <;>\n      rw [← comp_apply, ← F.1.map_comp, eq_to_hom_op, eq_to_hom_op, eq_to_hom_trans, eq_to_hom_refl, F.1.map_id,\n        id_apply]\n  apply eq_of_locally_eq\n  intro i\n  rw [← comp_apply, ← comp_apply, ← F.1.map_comp]\n  convert h i\n#align eq_of_locally_eq' eq_of_locally_eq'\n\n",
 "eq_of_locally_eq":
 "@[ext]\ntheorem eq_of_locally_eq (s t : F.1.obj (op (supᵢ U)))\n    (h : ∀ i, F.1.map (Opens.leSupr U i).op s = F.1.map (Opens.leSupr U i).op t) : s = t :=\n  by\n  let sf : ∀ i : ι, F.1.obj (op (U i)) := fun i => F.1.map (opens.le_supr U i).op s\n  have sf_compatible : is_compatible _ U sf := by\n    intro i j\n    simp_rw [← comp_apply, ← F.1.map_comp]\n    rfl\n  obtain ⟨gl, -, gl_uniq⟩ := F.exists_unique_gluing U sf sf_compatible\n  trans gl\n  · apply gl_uniq\n    intro i\n    rfl\n  · symm\n    apply gl_uniq\n    intro i\n    rw [← h]\n#align eq_of_locally_eq eq_of_locally_eq\n\n",
 "compatible_iff_left_res_eq_right_res":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/-\nCopyright (c) 2021 Justus Springer. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Justus Springer\n-/\n/-- Under the isomorphism `pi_opens_iso_sections_family`, compatibility of sections is the same\nas being equalized by the arrows `left_res` and `right_res` of the equalizer diagram.\n-/\ntheorem compatible_iff_left_res_eq_right_res (sf : pi_opens F U) :\n    is_compatible F U ((pi_opens_iso_sections_family F U).hom sf) ↔ left_res F U sf = right_res F U sf :=\n  by\n  constructor <;> intro h\n  · ext ⟨i, j⟩\n    rw [left_res, types.limit.lift_π_apply', fan.mk_π_app, right_res, types.limit.lift_π_apply', fan.mk_π_app]\n    exact h i j\n  · intro i j\n    convert congr_arg (limits.pi.π (fun p : ι × ι => F.obj (op («expr ⊓ » (U p.1) (U p.2)))) (i, j)) h\n    · rw [left_res, types.pi_lift_π_apply]\n      rfl\n    · rw [right_res, types.pi_lift_π_apply]\n      rfl\n#align compatible_iff_left_res_eq_right_res compatible_iff_left_res_eq_right_res\n\n"}