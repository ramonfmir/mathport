{"supr_eq_of_mem_grothendieck":
 "/-- If `R` is a presieve in the grothendieck topology on `opens X`, the covering family associated to\n`R` really is _covering_, i.e. the union of all open sets equals `U`.\n-/\ntheorem supr_eq_of_mem_grothendieck (hR : Sieve.generate R ∈ Opens.grothendieckTopology X U) :\n    supᵢ (covering_of_presieve U R) = U := by\n  apply le_antisymm\n  · refine' supᵢ_le _\n    intro f\n    exact f.2.1.le\n  intro x hxU\n  rw [opens.mem_supr]\n  obtain ⟨V, iVU, ⟨W, iVW, iWU, hiWU, -⟩, hxV⟩ := hR x hxU\n  exact ⟨⟨W, ⟨iWU, hiWU⟩⟩, iVW.le hxV⟩\n#align supr_eq_of_mem_grothendieck supr_eq_of_mem_grothendieck\n\n",
 "mem_grothendieck_topology":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/-- The sieve generated by `presieve_of_covering U` is a member of the grothendieck topology.\n-/\ntheorem mem_grothendieck_topology : Sieve.generate (presieve_of_covering U) ∈ Opens.grothendieckTopology X (supᵢ U) :=\n  by\n  intro x hx\n  obtain ⟨i, hxi⟩ := opens.mem_supr.mp hx\n  exact ⟨U i, opens.le_supr U i, ⟨U i, («expr𝟙») _, opens.le_supr U i, ⟨i, rfl⟩, category.id_comp _⟩, hxi⟩\n#align mem_grothendieck_topology mem_grothendieck_topology\n\n",
 "is_sheaf_of_open_embedding":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\ntheorem Top.presheaf.is_sheaf_of_open_embedding (h : OpenEmbedding f) (hF : F.is_sheaf) :\n    is_sheaf («expr ⋙ » h.is_open_map.functor.op F) :=\n  pullback_isSheaf_of_coverPreserving h.compatible_preserving h.is_open_map.cover_preserving ⟨_, hF⟩\n#align Top.presheaf.is_sheaf_of_open_embedding Top.presheaf.is_sheaf_of_open_embedding\n\n",
 "index_of_hom_spec":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem index_of_hom_spec (f : ΣV, { f : «expr ⟶ » V (supᵢ U) // presieve_of_covering U f }) :\n    f.1 = U (index_of_hom U f) :=\n  f.2.2.some_spec\n#align index_of_hom_spec index_of_hom_spec\n\n",
 "hom_ext":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem hom_ext {α β : «expr ⟶ » F F'.1} (he : ∀ i, α.app (op (B i)) = β.app (op (B i))) : α = β :=\n  by\n  apply (restrict_hom_equiv_hom F F' h).symm.injective\n  ext i\n  exact he i.unop\n#align hom_ext hom_ext\n\n",
 "extend_hom_app":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n@[simp]\ntheorem extend_hom_app (α : «expr ⟶ » («expr ⋙ » (inducedFunctor B).op F) («expr ⋙ » (inducedFunctor B).op F'.1))\n    (i : ι) : (restrict_hom_equiv_hom F F' h α).app (op (B i)) = α.app (op i) :=\n  by\n  nth_rw 2 [← (restrict_hom_equiv_hom F F' h).left_inv α]\n  rfl\n#align extend_hom_app extend_hom_app\n\n",
 "covering_presieve_eq_self":
 "/-- Given a presieve `R` on `Y`, if we take its associated family of opens via\n    `covering_of_presieve` (which may not cover `Y` if `R` is not covering), and take\n    the presieve on `Y` associated to the family of opens via `presieve_of_covering_aux`,\n    then we get back the original presieve `R`. -/\n@[simp]\ntheorem covering_presieve_eq_self {Y : Opens X} (R : Presieve Y) :\n    presieve_of_covering_aux (covering_of_presieve Y R) Y = R :=\n  by\n  ext (Z f)\n  exact ⟨fun ⟨⟨_, _, h⟩, rfl⟩ => by convert h, fun h => ⟨⟨Z, f, h⟩, rfl⟩⟩\n#align covering_presieve_eq_self covering_presieve_eq_self\n\n",
 "covering_of_presieve_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/-\nCopyright (c) 2021 Justus Springer. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Justus Springer\n-/\n@[simp]\ntheorem covering_of_presieve_apply (U : Opens X) (R : Presieve U) (f : ΣV, { f : «expr ⟶ » V U // R f }) :\n    covering_of_presieve U R f = f.1 :=\n  rfl\n#align covering_of_presieve_apply covering_of_presieve_apply\n\n",
 "cover_preserving":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\ntheorem is_open_map.cover_preserving (hf : IsOpenMap f) :\n    CoverPreserving (Opens.grothendieckTopology X) (Opens.grothendieckTopology Y) hf.functor :=\n  by\n  constructor\n  rintro U S hU _ ⟨x, hx, rfl⟩\n  obtain ⟨V, i, hV, hxV⟩ := hU x hx\n  exact ⟨_, hf.functor.map i, ⟨_, i, («expr𝟙») _, hV, rfl⟩, Set.mem_image_of_mem f hxV⟩\n#align is_open_map.cover_preserving is_open_map.cover_preserving\n\n",
 "cover_dense_induced_functor":
 "theorem cover_dense_induced_functor {B : ι → Opens X} (h : Opens.IsBasis (Set.range B)) :\n    cover_dense (Opens.grothendieckTopology X) (inducedFunctor B) :=\n  (cover_dense_iff_is_basis _).2 h\n#align cover_dense_induced_functor cover_dense_induced_functor\n\n",
 "cover_dense_iff_is_basis":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\ntheorem cover_dense_iff_is_basis [Category ι] (B : «expr ⥤ » ι (Opens X)) :\n    cover_dense (Opens.grothendieckTopology X) B ↔ Opens.IsBasis (Set.range B.obj) :=\n  by\n  rw [opens.is_basis_iff_nbhd]\n  constructor; intro hd U x hx; rcases hd.1 U x hx with ⟨V, f, ⟨i, f₁, f₂, hc⟩, hV⟩\n  exact ⟨B.obj i, ⟨i, rfl⟩, f₁.le hV, f₂.le⟩\n  intro hb; constructor; intro U x hx; rcases hb hx with ⟨_, ⟨i, rfl⟩, hx, hi⟩\n  exact ⟨B.obj i, ⟨⟨hi⟩⟩, ⟨⟨i, («expr𝟙») _, ⟨⟨hi⟩⟩, rfl⟩⟩, hx⟩\n#align cover_dense_iff_is_basis cover_dense_iff_is_basis\n\n",
 "compatible_preserving":
 "theorem open_embedding.compatible_preserving (hf : OpenEmbedding f) :\n    CompatiblePreserving (Opens.grothendieckTopology Y) hf.is_open_map.functor :=\n  by\n  haveI : mono f := (TopCat.mono_iff_injective f).mpr hf.inj\n  apply compatible_preserving_of_downwards_closed\n  intro U V i\n  refine' ⟨(opens.map f).obj V, eq_to_iso <| opens.ext <| Set.image_preimage_eq_of_subset fun x h => _⟩\n  obtain ⟨_, _, rfl⟩ := i.le h\n  exact ⟨_, rfl⟩\n#align open_embedding.compatible_preserving open_embedding.compatible_preserving\n\n"}