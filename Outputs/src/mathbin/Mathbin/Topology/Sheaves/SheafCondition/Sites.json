{"supr_eq_of_mem_grothendieck":
 "/-- If `R` is a presieve in the grothendieck topology on `opens X`, the covering family associated to\n`R` really is _covering_, i.e. the union of all open sets equals `U`.\n-/\ntheorem supr_eq_of_mem_grothendieck (hR : Sieve.generate R âˆˆ Opens.grothendieckTopology X U) :\n    supáµ¢ (covering_of_presieve U R) = U := by\n  apply le_antisymm\n  Â· refine' supáµ¢_le _\n    intro f\n    exact f.2.1.le\n  intro x hxU\n  rw [opens.mem_supr]\n  obtain âŸ¨V, iVU, âŸ¨W, iVW, iWU, hiWU, -âŸ©, hxVâŸ© := hR x hxU\n  exact âŸ¨âŸ¨W, âŸ¨iWU, hiWUâŸ©âŸ©, iVW.le hxVâŸ©\n#align supr_eq_of_mem_grothendieck supr_eq_of_mem_grothendieck\n\n",
 "mem_grothendieck_topology":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n/-- The sieve generated by `presieve_of_covering U` is a member of the grothendieck topology.\n-/\ntheorem mem_grothendieck_topology : Sieve.generate (presieve_of_covering U) âˆˆ Opens.grothendieckTopology X (supáµ¢ U) :=\n  by\n  intro x hx\n  obtain âŸ¨i, hxiâŸ© := opens.mem_supr.mp hx\n  exact âŸ¨U i, opens.le_supr U i, âŸ¨U i, (Â«exprğŸ™Â») _, opens.le_supr U i, âŸ¨i, rflâŸ©, category.id_comp _âŸ©, hxiâŸ©\n#align mem_grothendieck_topology mem_grothendieck_topology\n\n",
 "is_sheaf_of_open_embedding":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‹™ Â» -/\ntheorem Top.presheaf.is_sheaf_of_open_embedding (h : OpenEmbedding f) (hF : F.is_sheaf) :\n    is_sheaf (Â«expr â‹™ Â» h.is_open_map.functor.op F) :=\n  pullback_isSheaf_of_coverPreserving h.compatible_preserving h.is_open_map.cover_preserving âŸ¨_, hFâŸ©\n#align Top.presheaf.is_sheaf_of_open_embedding Top.presheaf.is_sheaf_of_open_embedding\n\n",
 "index_of_hom_spec":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem index_of_hom_spec (f : Î£V, { f : Â«expr âŸ¶ Â» V (supáµ¢ U) // presieve_of_covering U f }) :\n    f.1 = U (index_of_hom U f) :=\n  f.2.2.some_spec\n#align index_of_hom_spec index_of_hom_spec\n\n",
 "hom_ext":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem hom_ext {Î± Î² : Â«expr âŸ¶ Â» F F'.1} (he : âˆ€ i, Î±.app (op (B i)) = Î².app (op (B i))) : Î± = Î² :=\n  by\n  apply (restrict_hom_equiv_hom F F' h).symm.injective\n  ext i\n  exact he i.unop\n#align hom_ext hom_ext\n\n",
 "extend_hom_app":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‹™ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‹™ Â» -/\n@[simp]\ntheorem extend_hom_app (Î± : Â«expr âŸ¶ Â» (Â«expr â‹™ Â» (inducedFunctor B).op F) (Â«expr â‹™ Â» (inducedFunctor B).op F'.1))\n    (i : Î¹) : (restrict_hom_equiv_hom F F' h Î±).app (op (B i)) = Î±.app (op i) :=\n  by\n  nth_rw 2 [â† (restrict_hom_equiv_hom F F' h).left_inv Î±]\n  rfl\n#align extend_hom_app extend_hom_app\n\n",
 "covering_presieve_eq_self":
 "/-- Given a presieve `R` on `Y`, if we take its associated family of opens via\n    `covering_of_presieve` (which may not cover `Y` if `R` is not covering), and take\n    the presieve on `Y` associated to the family of opens via `presieve_of_covering_aux`,\n    then we get back the original presieve `R`. -/\n@[simp]\ntheorem covering_presieve_eq_self {Y : Opens X} (R : Presieve Y) :\n    presieve_of_covering_aux (covering_of_presieve Y R) Y = R :=\n  by\n  ext (Z f)\n  exact âŸ¨fun âŸ¨âŸ¨_, _, hâŸ©, rflâŸ© => by convert h, fun h => âŸ¨âŸ¨Z, f, hâŸ©, rflâŸ©âŸ©\n#align covering_presieve_eq_self covering_presieve_eq_self\n\n",
 "covering_of_presieve_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/-\nCopyright (c) 2021 Justus Springer. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Justus Springer\n-/\n@[simp]\ntheorem covering_of_presieve_apply (U : Opens X) (R : Presieve U) (f : Î£V, { f : Â«expr âŸ¶ Â» V U // R f }) :\n    covering_of_presieve U R f = f.1 :=\n  rfl\n#align covering_of_presieve_apply covering_of_presieve_apply\n\n",
 "cover_preserving":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\ntheorem is_open_map.cover_preserving (hf : IsOpenMap f) :\n    CoverPreserving (Opens.grothendieckTopology X) (Opens.grothendieckTopology Y) hf.functor :=\n  by\n  constructor\n  rintro U S hU _ âŸ¨x, hx, rflâŸ©\n  obtain âŸ¨V, i, hV, hxVâŸ© := hU x hx\n  exact âŸ¨_, hf.functor.map i, âŸ¨_, i, (Â«exprğŸ™Â») _, hV, rflâŸ©, Set.mem_image_of_mem f hxVâŸ©\n#align is_open_map.cover_preserving is_open_map.cover_preserving\n\n",
 "cover_dense_induced_functor":
 "theorem cover_dense_induced_functor {B : Î¹ â†’ Opens X} (h : Opens.IsBasis (Set.range B)) :\n    cover_dense (Opens.grothendieckTopology X) (inducedFunctor B) :=\n  (cover_dense_iff_is_basis _).2 h\n#align cover_dense_induced_functor cover_dense_induced_functor\n\n",
 "cover_dense_iff_is_basis":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\ntheorem cover_dense_iff_is_basis [Category Î¹] (B : Â«expr â¥¤ Â» Î¹ (Opens X)) :\n    cover_dense (Opens.grothendieckTopology X) B â†” Opens.IsBasis (Set.range B.obj) :=\n  by\n  rw [opens.is_basis_iff_nbhd]\n  constructor; intro hd U x hx; rcases hd.1 U x hx with âŸ¨V, f, âŸ¨i, fâ‚, fâ‚‚, hcâŸ©, hVâŸ©\n  exact âŸ¨B.obj i, âŸ¨i, rflâŸ©, fâ‚.le hV, fâ‚‚.leâŸ©\n  intro hb; constructor; intro U x hx; rcases hb hx with âŸ¨_, âŸ¨i, rflâŸ©, hx, hiâŸ©\n  exact âŸ¨B.obj i, âŸ¨âŸ¨hiâŸ©âŸ©, âŸ¨âŸ¨i, (Â«exprğŸ™Â») _, âŸ¨âŸ¨hiâŸ©âŸ©, rflâŸ©âŸ©, hxâŸ©\n#align cover_dense_iff_is_basis cover_dense_iff_is_basis\n\n",
 "compatible_preserving":
 "theorem open_embedding.compatible_preserving (hf : OpenEmbedding f) :\n    CompatiblePreserving (Opens.grothendieckTopology Y) hf.is_open_map.functor :=\n  by\n  haveI : mono f := (TopCat.mono_iff_injective f).mpr hf.inj\n  apply compatible_preserving_of_downwards_closed\n  intro U V i\n  refine' âŸ¨(opens.map f).obj V, eq_to_iso <| opens.ext <| Set.image_preimage_eq_of_subset fun x h => _âŸ©\n  obtain âŸ¨_, _, rflâŸ© := i.le h\n  exact âŸ¨_, rflâŸ©\n#align open_embedding.compatible_preserving open_embedding.compatible_preserving\n\n"}