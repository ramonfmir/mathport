{"obj_sup_iso_prod_eq_locus_inv_snd":
 "theorem obj_sup_iso_prod_eq_locus_inv_snd {X : Top} (F : X.sheaf CommRing) (U V : opens X) (x) :\n    F.1.map (hom_of_le le_sup_right).op ((F.obj_sup_iso_prod_eq_locus U V).inv x) = x.1.2 :=\n  concrete_category.congr_hom\n    ((F.is_limit_pullback_cone U V).cone_point_unique_up_to_iso_inv_comp (CommRing.pullback_cone_is_limit _ _)\n      walking_cospan.right)\n    x\n#align obj_sup_iso_prod_eq_locus_inv_snd obj_sup_iso_prod_eq_locus_inv_snd\n\n",
 "obj_sup_iso_prod_eq_locus_inv_fst":
 "theorem obj_sup_iso_prod_eq_locus_inv_fst {X : Top} (F : X.sheaf CommRing) (U V : opens X) (x) :\n    F.1.map (hom_of_le le_sup_left).op ((F.obj_sup_iso_prod_eq_locus U V).inv x) = x.1.1 :=\n  concrete_category.congr_hom\n    ((F.is_limit_pullback_cone U V).cone_point_unique_up_to_iso_inv_comp (CommRing.pullback_cone_is_limit _ _)\n      walking_cospan.left)\n    x\n#align obj_sup_iso_prod_eq_locus_inv_fst obj_sup_iso_prod_eq_locus_inv_fst\n\n",
 "obj_sup_iso_prod_eq_locus_hom_snd":
 "theorem obj_sup_iso_prod_eq_locus_hom_snd {X : Top} (F : X.sheaf CommRing) (U V : opens X) (x) :\n    ((F.obj_sup_iso_prod_eq_locus U V).hom x).1.snd = F.1.map (hom_of_le le_sup_right).op x :=\n  concrete_category.congr_hom\n    ((F.is_limit_pullback_cone U V).cone_point_unique_up_to_iso_hom_comp (CommRing.pullback_cone_is_limit _ _)\n      walking_cospan.right)\n    x\n#align obj_sup_iso_prod_eq_locus_hom_snd obj_sup_iso_prod_eq_locus_hom_snd\n\n",
 "obj_sup_iso_prod_eq_locus_hom_fst":
 "theorem obj_sup_iso_prod_eq_locus_hom_fst {X : Top} (F : X.sheaf CommRing) (U V : opens X) (x) :\n    ((F.obj_sup_iso_prod_eq_locus U V).hom x).1.fst = F.1.map (hom_of_le le_sup_left).op x :=\n  concrete_category.congr_hom\n    ((F.is_limit_pullback_cone U V).cone_point_unique_up_to_iso_hom_comp (CommRing.pullback_cone_is_limit _ _)\n      walking_cospan.left)\n    x\n#align obj_sup_iso_prod_eq_locus_hom_fst obj_sup_iso_prod_eq_locus_hom_fst\n\n",
 "is_sheaf_opens_le_cover_iff_is_sheaf_pairwise_intersections":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n/-\nCopyright (c) 2020 Scott Morrison. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Scott Morrison\n-/\n-- This is a case bash: for each pair of types of objects in `pairwise ι`,\n-- we have to explicitly construct a zigzag.\n/-- The sheaf condition\nin terms of a limit diagram over all `{ V : opens X // ∃ i, V ≤ U i }`\nis equivalent to the reformulation\nin terms of a limit diagram over `U i` and `U i ⊓ U j`.\n-/\ntheorem is_sheaf_opens_le_cover_iff_is_sheaf_pairwise_intersections :\n    F.is_sheaf_opens_le_cover ↔ F.is_sheaf_pairwise_intersections :=\n  forall₂_congr fun ι U =>\n    equiv.nonempty_congr <|\n      calc\n        «expr ≃ » (is_limit (F.map_cone (opens_le_cover_cocone U).op))\n            (is_limit ((F.map_cone (opens_le_cover_cocone U).op).whisker (pairwise_to_opens_le_cover U).op)) :=\n          (functor.initial.is_limit_whisker_equiv (pairwise_to_opens_le_cover U).op _).symm\n        «expr ≃ » _ (is_limit (F.map_cone ((opens_le_cover_cocone U).op.whisker (pairwise_to_opens_le_cover U).op))) :=\n          is_limit.equiv_iso_limit F.map_cone_whisker.symm\n        «expr ≃ » _\n            (is_limit\n              ((cones.postcompose_equivalence _).functor.obj\n                (F.map_cone ((opens_le_cover_cocone U).op.whisker (pairwise_to_opens_le_cover U).op)))) :=\n          (is_limit.postcompose_hom_equiv _ _).symm\n        «expr ≃ » _\n            (is_limit\n              (F.map_cone\n                ((cones.postcompose_equivalence _).functor.obj\n                  ((opens_le_cover_cocone U).op.whisker (pairwise_to_opens_le_cover U).op)))) :=\n          is_limit.equiv_iso_limit (functor.map_cone_postcompose_equivalence_functor _).symm\n        «expr ≃ » _ (is_limit (F.map_cone (pairwise.cocone U).op)) :=\n          is_limit.equiv_iso_limit ((cones.functoriality _ _).map_iso (pairwise_cocone_iso U : _).symm)\n        \n#align\n  is_sheaf_opens_le_cover_iff_is_sheaf_pairwise_intersections is_sheaf_opens_le_cover_iff_is_sheaf_pairwise_intersections\n\n",
 "is_sheaf_iff_is_sheaf_preserves_limit_pairwise_intersections":
 "/-- The sheaf condition in terms of an equalizer diagram is equivalent\nto the reformulation in terms of the presheaf preserving the limit of the diagram\nconsisting of the `U i` and `U i ⊓ U j`.\n-/\ntheorem is_sheaf_iff_is_sheaf_preserves_limit_pairwise_intersections :\n    F.is_sheaf ↔ F.is_sheaf_preserves_limit_pairwise_intersections :=\n  by\n  rw [is_sheaf_iff_is_sheaf_pairwise_intersections]\n  constructor\n  · intro h ι U\n    exact ⟨preserves_limit_of_preserves_limit_cone (pairwise.cocone_is_colimit U).op (h U).some⟩\n  · intro h ι U\n    haveI := (h U).some\n    exact ⟨preserves_limit.preserves (pairwise.cocone_is_colimit U).op⟩\n#align\n  is_sheaf_iff_is_sheaf_preserves_limit_pairwise_intersections is_sheaf_iff_is_sheaf_preserves_limit_pairwise_intersections\n\n",
 "is_sheaf_iff_is_sheaf_pairwise_intersections":
 "/-- The sheaf condition in terms of an equalizer diagram is equivalent\nto the reformulation in terms of a limit diagram over `U i` and `U i ⊓ U j`.\n-/\ntheorem is_sheaf_iff_is_sheaf_pairwise_intersections : F.is_sheaf ↔ F.is_sheaf_pairwise_intersections := by\n  rw [is_sheaf_iff_is_sheaf_opens_le_cover, is_sheaf_opens_le_cover_iff_is_sheaf_pairwise_intersections]\n#align is_sheaf_iff_is_sheaf_pairwise_intersections is_sheaf_iff_is_sheaf_pairwise_intersections\n\n",
 "inter_union_pullback_cone_snd":
 "@[simp]\ntheorem inter_union_pullback_cone_snd : (inter_union_pullback_cone F U V).snd = F.1.map (hom_of_le le_sup_right).op :=\n  rfl\n#align inter_union_pullback_cone_snd inter_union_pullback_cone_snd\n\n",
 "inter_union_pullback_cone_lift_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem inter_union_pullback_cone_lift_right :\n    «expr ≫ » (inter_union_pullback_cone_lift F U V s) (F.1.map (hom_of_le le_sup_right).op) = s.snd :=\n  by\n  erw [category.assoc, ← F.1.map_comp]\n  exact\n    (F.presheaf.is_sheaf_iff_is_sheaf_pairwise_intersections.mp F.2 _).some.fac _\n      (op <| pairwise.single (ulift.up walking_pair.right))\n#align inter_union_pullback_cone_lift_right inter_union_pullback_cone_lift_right\n\n",
 "inter_union_pullback_cone_lift_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem inter_union_pullback_cone_lift_left :\n    «expr ≫ » (inter_union_pullback_cone_lift F U V s) (F.1.map (hom_of_le le_sup_left).op) = s.fst :=\n  by\n  erw [category.assoc, ← F.1.map_comp]\n  exact\n    (F.presheaf.is_sheaf_iff_is_sheaf_pairwise_intersections.mp F.2 _).some.fac _\n      (op <| pairwise.single (ulift.up walking_pair.left))\n#align inter_union_pullback_cone_lift_left inter_union_pullback_cone_lift_left\n\n",
 "inter_union_pullback_cone_fst":
 "@[simp]\ntheorem inter_union_pullback_cone_fst : (inter_union_pullback_cone F U V).fst = F.1.map (hom_of_le le_sup_left).op :=\n  rfl\n#align inter_union_pullback_cone_fst inter_union_pullback_cone_fst\n\n",
 "inter_union_pullback_cone_X":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n@[simp]\ntheorem inter_union_pullback_cone_X : (inter_union_pullback_cone F U V).X = F.1.obj (op <| «expr ⊔ » U V) :=\n  rfl\n#align inter_union_pullback_cone_X inter_union_pullback_cone_X\n\n"}