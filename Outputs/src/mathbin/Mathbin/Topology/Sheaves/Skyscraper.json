{"to_skyscraper_from_stalk":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem to_skyscraper_from_stalk {ğ“• : presheaf C X} {c : C} (f : Â«expr âŸ¶ Â» ğ“• (skyscraper_presheaf pâ‚€ c)) :\n    to_skyscraper_presheaf pâ‚€ (from_stalk _ f) = f :=\n  nat_trans.ext _ _ <|\n    funext fun U =>\n      (em (pâ‚€ âˆˆ U.unop)).elim\n        (fun h => by\n          dsimp\n          split_ifs\n          erw [â† category.assoc, colimit.Î¹_desc, category.assoc, eq_to_hom_trans, eq_to_hom_refl, category.comp_id]\n          rfl)\n        fun h => by\n        dsimp\n        split_ifs\n        apply ((if_neg h).symm.rec terminal_is_terminal).hom_ext\n#align to_skyscraper_from_stalk to_skyscraper_from_stalk\n\n",
 "skyscraper_presheaf_is_sheaf":
 "-- In this section, we calculate the stalks for skyscraper presheaves.\n-- We need to restrict universe level.\ntheorem skyscraper_presheaf_is_sheaf : (skyscraper_presheaf pâ‚€ A).is_sheaf := by\n  classical exact\n      (presheaf.is_sheaf_iso_iff (eq_to_iso <| skyscraper_presheaf_eq_pushforward pâ‚€ A)).mpr\n        (sheaf.pushforward_sheaf_of_sheaf _\n          (presheaf.is_sheaf_on_punit_of_is_terminal _\n            (by\n              dsimp\n              rw [if_neg]\n              exact terminal_is_terminal\n              exact Set.not_mem_empty PUnit.unit)))\n#align skyscraper_presheaf_is_sheaf skyscraper_presheaf_is_sheaf\n\n",
 "skyscraper_presheaf_eq_pushforward":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr _* Â» -/\n/-\nCopyright (c) 2022 Jujian Zhang. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Jujian Zhang, Junyan Xu\n-/\ntheorem skyscraper_presheaf_eq_pushforward [hd : âˆ€ U : opens (Top.of PUnit.{u + 1}), decidable (PUnit.unit âˆˆ U)] :\n    skyscraper_presheaf pâ‚€ A = Â«expr _* Â» (continuous_map.const (Top.of PUnit) pâ‚€) (skyscraper_presheaf PUnit.unit A) :=\n  by\n  convert_to @skyscraper_presheaf X pâ‚€ (fun U => hd <| (opens.map <| continuous_map.const _ pâ‚€).obj U) C _ _ A = _ <;>\n    first |congr |rfl\n#align skyscraper_presheaf_eq_pushforward skyscraper_presheaf_eq_pushforward\n\n",
 "map'_id":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\ntheorem skyscraper_presheaf_functor.map'_id {a : C} : skyscraper_presheaf_functor.map' pâ‚€ ((Â«exprğŸ™Â») a) = (Â«exprğŸ™Â») _ :=\n  by\n  ext1; ext1; simp only [skyscraper_presheaf_functor.map'_app, nat_trans.id_app]; split_ifs\n  Â· simp only [category.id_comp, category.comp_id, eq_to_hom_trans, eq_to_hom_refl]\n  Â· apply ((if_neg h).symm.rec terminal_is_terminal).hom_ext\n#align skyscraper_presheaf_functor.map'_id skyscraper_presheaf_functor.map'_id\n\n",
 "map'_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\ntheorem skyscraper_presheaf_functor.map'_comp {a b c : C} (f : Â«expr âŸ¶ Â» a b) (g : Â«expr âŸ¶ Â» b c) :\n    skyscraper_presheaf_functor.map' pâ‚€ (Â«expr â‰« Â» f g) =\n      Â«expr â‰« Â» (skyscraper_presheaf_functor.map' pâ‚€ f) (skyscraper_presheaf_functor.map' pâ‚€ g) :=\n  by\n  ext1; ext1; simp only [skyscraper_presheaf_functor.map'_app, nat_trans.comp_app]; split_ifs\n  Â· simp only [category.assoc, eq_to_hom_trans_assoc, eq_to_hom_refl, category.id_comp]\n  Â· apply ((if_neg h).symm.rec terminal_is_terminal).hom_ext\n#align skyscraper_presheaf_functor.map'_comp skyscraper_presheaf_functor.map'_comp\n\n",
 "from_stalk_to_skyscraper":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem from_stalk_to_skyscraper {ğ“• : presheaf C X} {c : C} (f : Â«expr âŸ¶ Â» (ğ“•.stalk pâ‚€) c) :\n    from_stalk pâ‚€ (to_skyscraper_presheaf _ f) = f :=\n  colimit.hom_ext fun U => by\n    erw [colimit.Î¹_desc]\n    dsimp\n    rw [dif_pos U.unop.2]\n    rw [category.assoc, category.assoc, eq_to_hom_trans, eq_to_hom_refl, category.comp_id, presheaf.germ]\n    congr 3\n    apply_fun opposite.unop using unop_injective\n    rw [unop_op]\n    ext\n    rfl\n#align from_stalk_to_skyscraper from_stalk_to_skyscraper\n\n"}