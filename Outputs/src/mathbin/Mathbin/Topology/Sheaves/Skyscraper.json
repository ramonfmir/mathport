{"to_skyscraper_from_stalk":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem to_skyscraper_from_stalk {𝓕 : presheaf C X} {c : C} (f : «expr ⟶ » 𝓕 (skyscraper_presheaf p₀ c)) :\n    to_skyscraper_presheaf p₀ (from_stalk _ f) = f :=\n  nat_trans.ext _ _ <|\n    funext fun U =>\n      (em (p₀ ∈ U.unop)).elim\n        (fun h => by\n          dsimp\n          split_ifs\n          erw [← category.assoc, colimit.ι_desc, category.assoc, eq_to_hom_trans, eq_to_hom_refl, category.comp_id]\n          rfl)\n        fun h => by\n        dsimp\n        split_ifs\n        apply ((if_neg h).symm.rec terminal_is_terminal).hom_ext\n#align to_skyscraper_from_stalk to_skyscraper_from_stalk\n\n",
 "skyscraper_presheaf_is_sheaf":
 "-- In this section, we calculate the stalks for skyscraper presheaves.\n-- We need to restrict universe level.\ntheorem skyscraper_presheaf_is_sheaf : (skyscraper_presheaf p₀ A).is_sheaf := by\n  classical exact\n      (presheaf.is_sheaf_iso_iff (eq_to_iso <| skyscraper_presheaf_eq_pushforward p₀ A)).mpr\n        (sheaf.pushforward_sheaf_of_sheaf _\n          (presheaf.is_sheaf_on_punit_of_is_terminal _\n            (by\n              dsimp\n              rw [if_neg]\n              exact terminal_is_terminal\n              exact Set.not_mem_empty PUnit.unit)))\n#align skyscraper_presheaf_is_sheaf skyscraper_presheaf_is_sheaf\n\n",
 "skyscraper_presheaf_eq_pushforward":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr _* » -/\n/-\nCopyright (c) 2022 Jujian Zhang. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Jujian Zhang, Junyan Xu\n-/\ntheorem skyscraper_presheaf_eq_pushforward [hd : ∀ U : opens (Top.of PUnit.{u + 1}), decidable (PUnit.unit ∈ U)] :\n    skyscraper_presheaf p₀ A = «expr _* » (continuous_map.const (Top.of PUnit) p₀) (skyscraper_presheaf PUnit.unit A) :=\n  by\n  convert_to @skyscraper_presheaf X p₀ (fun U => hd <| (opens.map <| continuous_map.const _ p₀).obj U) C _ _ A = _ <;>\n    first |congr |rfl\n#align skyscraper_presheaf_eq_pushforward skyscraper_presheaf_eq_pushforward\n\n",
 "map'_id":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\ntheorem skyscraper_presheaf_functor.map'_id {a : C} : skyscraper_presheaf_functor.map' p₀ ((«expr𝟙») a) = («expr𝟙») _ :=\n  by\n  ext1; ext1; simp only [skyscraper_presheaf_functor.map'_app, nat_trans.id_app]; split_ifs\n  · simp only [category.id_comp, category.comp_id, eq_to_hom_trans, eq_to_hom_refl]\n  · apply ((if_neg h).symm.rec terminal_is_terminal).hom_ext\n#align skyscraper_presheaf_functor.map'_id skyscraper_presheaf_functor.map'_id\n\n",
 "map'_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem skyscraper_presheaf_functor.map'_comp {a b c : C} (f : «expr ⟶ » a b) (g : «expr ⟶ » b c) :\n    skyscraper_presheaf_functor.map' p₀ («expr ≫ » f g) =\n      «expr ≫ » (skyscraper_presheaf_functor.map' p₀ f) (skyscraper_presheaf_functor.map' p₀ g) :=\n  by\n  ext1; ext1; simp only [skyscraper_presheaf_functor.map'_app, nat_trans.comp_app]; split_ifs\n  · simp only [category.assoc, eq_to_hom_trans_assoc, eq_to_hom_refl, category.id_comp]\n  · apply ((if_neg h).symm.rec terminal_is_terminal).hom_ext\n#align skyscraper_presheaf_functor.map'_comp skyscraper_presheaf_functor.map'_comp\n\n",
 "from_stalk_to_skyscraper":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem from_stalk_to_skyscraper {𝓕 : presheaf C X} {c : C} (f : «expr ⟶ » (𝓕.stalk p₀) c) :\n    from_stalk p₀ (to_skyscraper_presheaf _ f) = f :=\n  colimit.hom_ext fun U => by\n    erw [colimit.ι_desc]\n    dsimp\n    rw [dif_pos U.unop.2]\n    rw [category.assoc, category.assoc, eq_to_hom_trans, eq_to_hom_refl, category.comp_id, presheaf.germ]\n    congr 3\n    apply_fun opposite.unop using unop_injective\n    rw [unop_op]\n    ext\n    rfl\n#align from_stalk_to_skyscraper from_stalk_to_skyscraper\n\n"}