{"to_Types_is_sheaf":
 "/-\nCopyright (c) 2020 Scott Morrison. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johan Commelin, Scott Morrison\n-/\n/-- We show that the presheaf of functions to a type `T`\n(no continuity assumptions, just plain functions)\nform a sheaf.\n\nIn fact, the proof is identical when we do this for dependent functions to a type family `T`,\nso we do the more general case.\n-/\ntheorem to_Types_is_sheaf (T : X → Type u) : (presheaf_to_Types X T).is_sheaf :=\n  is_sheaf_of_is_sheaf_unique_gluing_types _ fun ι U sf hsf => -- We use the sheaf condition in terms of unique gluing\n  -- U is a family of open sets, indexed by `ι` and `sf` is a compatible family of sections.\n  -- In the informal comments below, I'll just write `U` to represent the union.\n  by\n    -- Our first goal is to define a function \"lifted\" to all of `U`.\n    -- We do this one point at a time. Using the axiom of choice, we can pick for each\n    -- `x : supr U` an index `i : ι` such that `x` lies in `U i`\n    choose index index_spec using fun x : supᵢ U => opens.mem_supr.mp x.2\n    -- Using this data, we can glue our functions together to a single section\n    let s : ∀ x : supᵢ U, T x := fun x => sf (index x) ⟨x.1, index_spec x⟩\n    refine' ⟨s, _, _⟩\n    · intro i\n      ext x\n      -- Now we need to verify that this lifted function restricts correctly to each set `U i`.\n      -- Of course, the difficulty is that at any given point `x ∈ U i`,\n      -- we may have used the axiom of choice to pick a different `j` with `x ∈ U j`\n      -- when defining the function.\n      -- Thus we'll need to use the fact that the restrictions are compatible.\n      convert congr_fun (hsf (index ⟨x, _⟩) i) ⟨x, ⟨index_spec ⟨x.1, _⟩, x.2⟩⟩\n      ext\n      rfl\n    · -- Now we just need to check that the lift we picked was the only possible one.\n      -- So we suppose we had some other gluing `t` of our sections\n      intro t ht\n      -- and observe that we need to check that it agrees with our choice\n      -- for each `f : s .X` and each `x ∈ supr U`.\n      ext x\n      convert congr_fun (ht (index x)) ⟨x.1, index_spec x⟩\n      ext\n      rfl\n#align to_Types_is_sheaf to_Types_is_sheaf\n\n",
 "to_Type_is_sheaf":
 "-- We verify that the non-dependent version is an immediate consequence:\n/-- The presheaf of not-necessarily-continuous functions to\na target type `T` satsifies the sheaf condition.\n-/\ntheorem to_Type_is_sheaf (T : Type u) : (presheaf_to_Type X T).is_sheaf :=\n  to_Types_is_sheaf X fun _ => T\n#align to_Type_is_sheaf to_Type_is_sheaf\n\n"}