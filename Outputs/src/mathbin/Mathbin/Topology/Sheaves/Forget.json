{"is_sheaf_iff_is_sheaf_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/-\nCopyright (c) 2020 Scott Morrison. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Scott Morrison\n-/\n-- non-terminal `simp`, but `squeeze_simp` fails\n-- non-terminal `simp`, but `squeeze_simp` fails\n/-- If `G : C ⥤ D` is a functor which reflects isomorphisms and preserves limits\n(we assume all limits exist in both `C` and `D`),\nthen checking the sheaf condition for a presheaf `F : presheaf C X`\nis equivalent to checking the sheaf condition for `F ⋙ G`.\n\nThe important special case is when\n`C` is a concrete category with a forgetful functor\nthat preserves limits and reflects isomorphisms.\nThen to check the sheaf condition it suffices to check it on the underlying sheaf of types.\n\nAnother useful example is the forgetful functor `TopCommRing ⥤ Top`.\n\nSee <https://stacks.math.columbia.edu/tag/0073>.\nIn fact we prove a stronger version with arbitrary complete target category.\n-/\ntheorem is_sheaf_iff_is_sheaf_comp : presheaf.is_sheaf F ↔ presheaf.is_sheaf («expr ⋙ » F G) :=\n  by\n  rw [presheaf.is_sheaf_iff_is_sheaf_equalizer_products, presheaf.is_sheaf_iff_is_sheaf_equalizer_products]\n  constructor\n  · intro S ι U\n    -- We have that the sheaf condition fork for `F` is a limit fork,\n    obtain ⟨t₁⟩ := S U\n    -- and since `G` preserves limits, the image under `G` of this fork is a limit fork too.\n    letI := preserves_smallest_limits_of_preserves_limits G\n    have t₂ := @preserves_limit.preserves _ _ _ _ _ _ _ G _ _ t₁\n    -- As we established above, that image is just the sheaf condition fork\n    -- for `F ⋙ G` postcomposed with some natural isomorphism,\n    have t₃ := is_limit.of_iso_limit t₂ (map_cone_fork G F U)\n    -- and as postcomposing by a natural isomorphism preserves limit cones,\n    have t₄ := is_limit.postcompose_inv_equiv _ _ t₃\n    -- we have our desired conclusion.\n    exact ⟨t₄⟩\n  · intro S ι U\n    refine' ⟨_⟩\n    -- Let `f` be the universal morphism from `F.obj U` to the equalizer\n    -- of the sheaf condition fork, whatever it is.\n    -- Our goal is to show that this is an isomorphism.\n    let f := equalizer.lift _ (w F U)\n    -- If we can do that,\n    suffices is_iso (G.map f) by\n      skip\n      -- we have that `f` itself is an isomorphism, since `G` reflects isomorphisms\n      haveI : is_iso f := is_iso_of_reflects_iso f G\n      -- TODO package this up as a result elsewhere:\n      apply is_limit.of_iso_limit (limit.is_limit _)\n      apply iso.symm\n      fapply cones.ext\n      exact as_iso f\n      rintro ⟨_ | _⟩ <;>\n        · dsimp [f]\n          simp\n    · -- Returning to the task of shwoing that `G.map f` is an isomorphism,\n      -- we note that `G.map f` is almost but not quite (see below) a morphism\n      -- from the sheaf condition cone for `F ⋙ G` to the\n      -- image under `G` of the equalizer cone for the sheaf condition diagram.\n      let c := fork («expr ⋙ » F G) U\n      obtain ⟨hc⟩ := S U\n      let d := G.map_cone (equalizer.fork (left_res.{v} F U) (right_res F U))\n      letI := preserves_smallest_limits_of_preserves_limits G\n      have hd : is_limit d := preserves_limit.preserves (limit.is_limit _)\n      -- Since both of these are limit cones\n      -- (`c` by our hypothesis `S`, and `d` because `G` preserves limits),\n      -- we hope to be able to conclude that `f` is an isomorphism.\n      -- We say \"not quite\" above because `c` and `d` don't quite have the same shape:\n      -- we need to postcompose by the natural isomorphism `diagram_comp_preserves_limits`\n      -- introduced above.\n      let d' := (cones.postcompose (diagram_comp_preserves_limits G F U).hom).obj d\n      have hd' : is_limit d' := (is_limit.postcompose_hom_equiv (diagram_comp_preserves_limits G F U : _) d).symm hd\n      -- Now everything works: we verify that `f` really is a morphism between these cones:\n      let f' : «expr ⟶ » c d' :=\n        fork.mk_hom (G.map f)\n          (by\n            dsimp only [c, d, d', f, diagram_comp_preserves_limits, res]\n            dsimp only [fork.ι]\n            ext1 j\n            dsimp\n            simp only [category.assoc, ← functor.map_comp_assoc, equalizer.lift_ι, map_lift_pi_comparison_assoc]\n            dsimp [res]; simp)\n      -- conclude that it is an isomorphism,\n      -- just because it's a morphism between two limit cones.\n      haveI : is_iso f' := is_limit.hom_is_iso hc hd' f'\n      -- A cone morphism is an isomorphism exactly if the morphism between the cone points is,\n      -- so we're done!\n      exact is_iso.of_iso ((cones.forget _).map_iso (as_iso f'))\n#align is_sheaf_iff_is_sheaf_comp is_sheaf_iff_is_sheaf_comp\n\n"}