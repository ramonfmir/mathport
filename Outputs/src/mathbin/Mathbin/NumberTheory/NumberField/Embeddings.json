{"range_eval_eq_root_set_minpoly":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/-- Let `A` be an algebraically closed field and let `x ∈ K`, with `K` a number field.\nThe images of `x` by the embeddings of `K` in `A` are exactly the roots in `A` of\nthe minimal polynomial of `x` over `ℚ`. -/\ntheorem range_eval_eq_root_set_minpoly : (range fun φ : «expr →+* » K A => φ x) = (minpoly (exprℚ) x).root_set A :=\n  by\n  convert(number_field.is_algebraic K).range_eval_eq_root_set_minpoly A x using 1\n  ext a\n  exact ⟨fun ⟨φ, hφ⟩ => ⟨φ.to_rat_alg_hom, hφ⟩, fun ⟨φ, hφ⟩ => ⟨φ.to_ring_hom, hφ⟩⟩\n#align range_eval_eq_root_set_minpoly range_eval_eq_root_set_minpoly\n\n",
 "prod_eq_abs_norm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/-- The infinite part of the product formula : for `x ∈ K`, we have `Π_w ‖x‖_w = |norm(x)|` where\n`‖·‖_w` is the normalized absolute value for `w`.  -/\ntheorem prod_eq_abs_norm (x : K) :\n    (Finset.univ.prod fun w : infinite_place K => ite w.is_real (w x) (w x ^ 2)) = abs (algebra.norm (exprℚ) x) :=\n  by\n  convert(congr_arg Complex.abs (@algebra.norm_eq_prod_embeddings (exprℚ) _ _ _ _ (exprℂ) _ _ _ _ _ x)).symm\n  · rw [map_prod, ←\n      Equiv.prod_comp' RingHom.equivRatAlgHom (fun f => Complex.abs (f x)) (fun φ => Complex.abs (φ x)) fun _ => by\n        simpa only [ring_hom.equiv_rat_alg_hom_apply] ]\n    dsimp only\n    conv =>\n      rhs\n      congr\n      skip\n      ext\n      rw [(by simp only [if_t_t] :\n          Complex.abs (f x) = ite (complex_embedding.is_real f) (Complex.abs (f x)) (Complex.abs (f x)))]\n    rw [Finset.prod_ite, Finset.prod_ite]\n    refine' congr (congr_arg has_mul.mul _) _\n    · rw [← Finset.prod_subtype_eq_prod_filter, ← Finset.prod_subtype_eq_prod_filter]\n      convert(Equiv.prod_comp' (mk_real K) (fun φ => Complex.abs (φ x)) (fun w => w x) _).symm\n      any_goals ext; simp only [Finset.mem_subtype, Finset.mem_univ]\n      exact fun φ => mk_real.apply K φ x\n    · rw [Finset.filter_congr fun (w : infinite_place K) _ => @not_is_real_iff_is_complex K _ w, ←\n        Finset.prod_subtype_eq_prod_filter, ← Finset.prod_subtype_eq_prod_filter]\n      convert Finset.prod_fiberwise Finset.univ (fun φ => mk_complex K φ) fun φ => Complex.abs (φ x)\n      any_goals ext; simp only [Finset.mem_subtype, Finset.mem_univ, not_is_real_iff_is_complex]\n      · ext w\n        rw [@Finset.prod_congr _ _ _ _ _ (fun φ => w x) _ (Eq.refl _) fun φ hφ =>\n            (mk_complex.apply K φ x).symm.trans (congr_fun (congr_arg coe_fn (Finset.mem_filter.1 hφ).2) x),\n          Finset.prod_const, mk_complex.filter_card K w]\n        rfl\n  · rw [eq_ratCast, ← Complex.abs_ofReal, Complex.ofReal_rat_cast]\n#align prod_eq_abs_norm prod_eq_abs_norm\n\n",
 "pow_eq_one_of_norm_eq_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/-- An algebraic integer whose conjugates are all of norm one is a root of unity. -/\ntheorem pow_eq_one_of_norm_eq_one {x : K} (hxi : is_integral ℤ x) (hx : ∀ φ : «expr →+* » K A, «expr‖ ‖» (φ x) = 1) :\n    ∃ (n : ℕ)(hn : 0 < n), x ^ n = 1 :=\n  by\n  obtain ⟨a, -, b, -, habne, h⟩ :=\n    @Set.Infinite.exists_ne_map_eq_of_mapsTo _ _ _ _ ((· ^ ·) x : ℕ → K) Set.infinite_univ _\n      (finite_of_norm_le K A (1 : exprℝ))\n  · wlog hlt : b < a\n    · exact this hxi hx b a habne.symm h.symm (habne.lt_or_lt.resolve_right hlt)\n    refine' ⟨a - b, tsub_pos_of_lt hlt, _⟩\n    rw [← nat.sub_add_cancel hlt.le, pow_add, mul_left_eq_self₀] at h\n    refine' h.resolve_right fun hp => _\n    specialize hx (is_alg_closed.lift (number_field.is_algebraic K)).to_ring_hom\n    rw [pow_eq_zero hp, map_zero, norm_zero] at hx\n    norm_num at hx\n  · exact fun a _ => ⟨hxi.pow a, fun φ => by simp only [hx φ, norm_pow, one_pow, map_pow]⟩\n#align pow_eq_one_of_norm_eq_one pow_eq_one_of_norm_eq_one\n\n",
 "pos_iff":
 "theorem pos_iff {w : infinite_place K} {x : K} : 0 < w x ↔ x ≠ 0 :=\n  AbsoluteValue.pos_iff w.1\n#align pos_iff pos_iff\n\n",
 "place_embedding_apply":
 "@[simp]\ntheorem is_real.place_embedding_apply {w : infinite_place K} (hw : is_real w) (x : K) :\n    place (is_real.embedding hw) x = w x :=\n  by\n  rw [is_real.embedding, complex_embedding.is_real.place_embedding, ← coe_mk]\n  exact congr_fun (congr_arg coe_fn (mk_embedding w)) x\n#align is_real.place_embedding_apply is_real.place_embedding_apply\n\n",
 "place_embedding":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\ntheorem is_real.place_embedding {φ : «expr →+* » K (exprℂ)} (hφ : is_real φ) : place hφ.embedding = place φ :=\n  by\n  ext x\n  simp only [place_apply, Real.norm_eq_abs, ← abs_of_real, norm_eq_abs, hφ.coe_embedding_apply x]\n#align is_real.place_embedding is_real.place_embedding\n\n",
 "place_conjugate":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\ntheorem place_conjugate (φ : «expr →+* » K (exprℂ)) : place (conjugate φ) = place φ :=\n  by\n  ext\n  simp only [place_apply, norm_eq_abs, abs_conj, conjugate_coe_eq]\n#align place_conjugate place_conjugate\n\n",
 "place_apply":
 "@[simp]\ntheorem number_field.place_apply (x : K) : (number_field.place φ) x = norm (φ x) :=\n  rfl\n#align number_field.place_apply number_field.place_apply\n\n",
 "not_is_real_iff_is_complex":
 "@[simp]\ntheorem not_is_real_iff_is_complex {w : infinite_place K} : ¬is_real w ↔ is_complex w := by\n  rw [is_complex_iff, is_real_iff]\n#align not_is_real_iff_is_complex not_is_real_iff_is_complex\n\n",
 "not_is_complex_iff_is_real":
 "@[simp]\ntheorem not_is_complex_iff_is_real {w : infinite_place K} : ¬is_complex w ↔ is_real w := by\n  rw [← not_is_real_iff_is_complex, Classical.not_not]\n#align not_is_complex_iff_is_real not_is_complex_iff_is_real\n\n",
 "mk_real_coe":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n@[simp]\ntheorem mk_real_coe (φ : { φ : «expr →+* » K (exprℂ) // complex_embedding.is_real φ }) :\n    (mk_real K φ : infinite_place K) = mk (φ : «expr →+* » K (exprℂ)) :=\n  rfl\n#align mk_real_coe mk_real_coe\n\n",
 "mk_eq_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n@[simp]\ntheorem mk_eq_iff {φ ψ : «expr →+* » K (exprℂ)} : mk φ = mk ψ ↔ φ = ψ ∨ complex_embedding.conjugate φ = ψ :=\n  by\n  constructor\n  · -- We prove that the map ψ ∘ φ⁻¹ between φ(K) and ℂ is uniform continuous, thus it is either the\n    -- inclusion or the complex conjugation using complex.uniform_continuous_ring_hom_eq_id_or_conj\n    intro h₀\n    obtain ⟨j, hiφ⟩ := φ.injective.has_left_inverse\n    let ι := RingEquiv.ofLeftInverse hiφ\n    have hlip : LipschitzWith 1 (RingHom.comp ψ ι.symm.to_ring_hom) :=\n      by\n      change LipschitzWith 1 (ψ ∘ ι.symm)\n      apply LipschitzWith.of_dist_le_mul\n      intro x y\n      rw [Nonneg.coe_one, one_mul, normed_field.dist_eq, ← map_sub, ← map_sub]\n      apply le_of_eq\n      suffices «expr‖ ‖» (φ (ι.symm (x - y))) = «expr‖ ‖» (ψ (ι.symm (x - y)))\n        by\n        rw [← this, ← RingEquiv.ofLeftInverse_apply hiφ _, RingEquiv.apply_symm_apply ι _]\n        rfl\n      exact congr_fun (congr_arg coe_fn h₀) _\n    cases complex.uniform_continuous_ring_hom_eq_id_or_conj φ.field_range hlip.uniform_continuous\n    · left\n      ext1 x\n      convert(congr_fun h (ι x)).symm\n      exact (RingEquiv.apply_symm_apply ι.symm x).symm\n    · right\n      ext1 x\n      convert(congr_fun h (ι x)).symm\n      exact (RingEquiv.apply_symm_apply ι.symm x).symm\n  · rintro (⟨h⟩ | ⟨h⟩)\n    · exact congr_arg mk h\n    · rw [← mk_conjugate_eq]\n      exact congr_arg mk h\n#align mk_eq_iff mk_eq_iff\n\n",
 "mk_embedding":
 "@[simp]\ntheorem mk_embedding (w : infinite_place K) : mk (embedding w) = w :=\n  Subtype.ext w.2.some_spec\n#align mk_embedding mk_embedding\n\n",
 "mk_conjugate_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n@[simp]\ntheorem mk_conjugate_eq (φ : «expr →+* » K (exprℂ)) : mk (complex_embedding.conjugate φ) = mk φ :=\n  by\n  ext x\n  exact congr_fun (congr_arg coe_fn (complex_embedding.place_conjugate φ)) x\n#align mk_conjugate_eq mk_conjugate_eq\n\n",
 "mk_complex_embedding":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\ntheorem mk_complex_embedding (φ : { φ : «expr →+* » K (exprℂ) // ¬complex_embedding.is_real φ }) :\n    (mk_complex K φ : infinite_place K).embedding = φ ∨\n      (mk_complex K φ : infinite_place K).embedding = complex_embedding.conjugate φ :=\n  by\n  rw [@eq_comm _ _ ↑φ, @eq_comm _ _ (complex_embedding.conjugate ↑φ), ← mk_eq_iff, mk_embedding]\n  rfl\n#align mk_complex_embedding mk_complex_embedding\n\n",
 "mk_complex_coe":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n@[simp]\ntheorem mk_complex_coe (φ : { φ : «expr →+* » K (exprℂ) // ¬complex_embedding.is_real φ }) :\n    (mk_complex K φ : infinite_place K) = mk (φ : «expr →+* » K (exprℂ)) :=\n  rfl\n#align mk_complex_coe mk_complex_coe\n\n",
 "le_iff_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem le_iff_le (x : K) (r : exprℝ) :\n    (∀ w : infinite_place K, w x ≤ r) ↔ ∀ φ : «expr →+* » K (exprℂ), «expr‖ ‖» (φ x) ≤ r :=\n  ⟨fun hw φ => hw (mk φ), fun hφ ⟨w, ⟨φ, rfl⟩⟩ => hφ φ⟩\n#align le_iff_le le_iff_le\n\n",
 "is_real_or_is_complex":
 "theorem is_real_or_is_complex (w : infinite_place K) : is_real w ∨ is_complex w :=\n  by\n  rw [← not_is_real_iff_is_complex]\n  exact em _\n#align is_real_or_is_complex is_real_or_is_complex\n\n",
 "is_real_iff":
 "theorem is_real_iff {w : infinite_place K} : is_real w ↔ complex_embedding.is_real (embedding w) :=\n  by\n  constructor\n  · rintro ⟨φ, ⟨hφ, rfl⟩⟩\n    rwa [_root_.number_field.complex_embeddings.is_real.embedding_mk hφ]\n  · exact fun h => ⟨Embedding w, h, mk_embedding w⟩\n#align is_real_iff is_real_iff\n\n",
 "is_real_conjugate_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\ntheorem is_real_conjugate_iff {φ : «expr →+* » K (exprℂ)} : is_real (conjugate φ) ↔ is_real φ :=\n  IsSelfAdjoint.star_iff\n#align is_real_conjugate_iff is_real_conjugate_iff\n\n",
 "is_complex_iff":
 "theorem is_complex_iff {w : infinite_place K} : is_complex w ↔ ¬complex_embedding.is_real (embedding w) :=\n  by\n  constructor\n  · rintro ⟨φ, ⟨hφ, rfl⟩⟩\n    contrapose! hφ\n    cases mk_eq_iff.mp (mk_embedding (mk φ))\n    · rwa [← h]\n    · rw [← complex_embedding.is_real_conjugate_iff] at hφ\n      rwa [← h]\n  · exact fun h => ⟨Embedding w, h, mk_embedding w⟩\n#align is_complex_iff is_complex_iff\n\n",
 "finite_of_norm_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/-- Let `B` be a real number. The set of algebraic integers in `K` whose conjugates are all\nsmaller in norm than `B` is finite. -/\ntheorem finite_of_norm_le (B : exprℝ) :\n    { x : K | is_integral ℤ x ∧ ∀ φ : «expr →+* » K A, «expr‖ ‖» (φ x) ≤ B }.finite :=\n  by\n  let C := Nat.ceil (max B 1 ^ finrank (exprℚ) K * (finrank (exprℚ) K).choose (finrank (exprℚ) K / 2))\n  have := bUnion_roots_finite (algebraMap ℤ K) (finrank (exprℚ) K) (finite_Icc (-C : ℤ) C)\n  refine' this.subset fun x hx => _; simp_rw [mem_Union]\n  have h_map_ℚ_minpoly := minpoly.is_integrally_closed_eq_field_fractions' (exprℚ) hx.1\n  refine' ⟨_, ⟨_, fun i => _⟩, mem_root_set.2 ⟨minpoly.ne_zero hx.1, minpoly.aeval ℤ x⟩⟩\n  · rw [← (minpoly.monic hx.1).nat_degree_map (algebraMap ℤ (exprℚ)), ← h_map_ℚ_minpoly]\n    exact minpoly.nat_degree_le (is_integral_of_is_scalar_tower hx.1)\n  rw [mem_Icc, ← abs_le, ← @Int.cast_le (exprℝ)]\n  refine' (Eq.trans_le _ <| coeff_bdd_of_norm_le hx.2 i).trans (Nat.le_ceil _)\n  rw [h_map_ℚ_minpoly, coeff_map, eq_intCast, Int.norm_cast_rat, Int.norm_eq_abs, Int.cast_abs]\n#align finite_of_norm_le finite_of_norm_le\n\n",
 "filter_card":
 "theorem mk_complex.filter_card (w : { w : infinite_place K // w.is_complex }) :\n    (Finset.univ.filter fun φ => mk_complex K φ = w).card = 2 :=\n  by\n  rw [mk_complex.filter]\n  exact\n    Finset.card_doubleton\n      (subtype.mk_eq_mk.not.2 <| ne_comm.1 <| complex_embedding.is_real_iff.not.1 <| is_complex_iff.1 w.2)\n#align mk_complex.filter_card mk_complex.filter_card\n\n",
 "filter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\ntheorem mk_complex.filter (w : { w : infinite_place K // w.is_complex }) :\n    (Finset.univ.filter fun φ => mk_complex K φ = w) =\n      {⟨w.1.embedding, is_complex_iff.1 w.2⟩,\n        ⟨complex_embedding.conjugate w.1.embedding,\n          complex_embedding.is_real_conjugate_iff.not.2 (is_complex_iff.1 w.2)⟩} :=\n  by\n  ext φ\n  simp_rw [Finset.mem_filter, subtype.val_eq_coe, Finset.mem_insert, Finset.mem_singleton,\n    @Subtype.ext_iff_val (infinite_place K), @Subtype.ext_iff_val («expr →+* » K (exprℂ)), @eq_comm _ φ.val, ←\n    mk_eq_iff, mk_embedding, @eq_comm _ _ w.val]\n  simpa only [Finset.mem_univ, true_and_iff]\n#align mk_complex.filter mk_complex.filter\n\n",
 "eq_iff_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem eq_iff_eq (x : K) (r : exprℝ) :\n    (∀ w : infinite_place K, w x = r) ↔ ∀ φ : «expr →+* » K (exprℂ), «expr‖ ‖» (φ x) = r :=\n  ⟨fun hw φ => hw (mk φ), fun hφ ⟨w, ⟨φ, rfl⟩⟩ => hφ φ⟩\n#align eq_iff_eq eq_iff_eq\n\n",
 "embedding_mk":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n@[simp]\ntheorem _root_.number_field.complex_embeddings.is_real.embedding_mk {φ : «expr →+* » K (exprℂ)}\n    (h : complex_embedding.is_real φ) : embedding (mk φ) = φ :=\n  by\n  have := mk_eq_iff.mp (mk_embedding (mk φ)).symm\n  rwa [complex_embedding.is_real_iff.mp h, or_self_iff, eq_comm] at this\n#align number_field.complex_embeddings.is_real.embedding_mk number_field.complex_embeddings.is_real.embedding_mk\n\n",
 "conjugate_coe_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `star_ring_end -/\n@[simp]\ntheorem conjugate_coe_eq (φ : «expr →+* » K (exprℂ)) (x : K) : (conjugate φ) x = (star_ring_end) (φ x) :=\n  rfl\n#align conjugate_coe_eq conjugate_coe_eq\n\n",
 "coeff_bdd_of_norm_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\ntheorem coeff_bdd_of_norm_le {B : exprℝ} {x : K} (h : ∀ φ : «expr →+* » K A, «expr‖ ‖» (φ x) ≤ B) (i : ℕ) :\n    «expr‖ ‖» ((minpoly (exprℚ) x).coeff i) ≤\n      max B 1 ^ finrank (exprℚ) K * (finrank (exprℚ) K).choose (finrank (exprℚ) K / 2) :=\n  by\n  have hx := is_separable.is_integral (exprℚ) x\n  rw [← norm_algebraMap' A, ← coeff_map (algebraMap (exprℚ) A)]\n  refine'\n    coeff_bdd_of_roots_le _ (minpoly.monic hx) (is_alg_closed.splits_codomain _) (minpoly.nat_degree_le hx)\n      (fun z hz => _) i\n  classical\n    rw [← Multiset.mem_toFinset] at hz\n    obtain ⟨φ, rfl⟩ := (range_eval_eq_root_set_minpoly K A x).symm.subset hz\n    exact h φ\n#align coeff_bdd_of_norm_le coeff_bdd_of_norm_le\n\n",
 "coe_mk":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\ntheorem coe_mk (φ : «expr →+* » K (exprℂ)) : «expr⇑ » (mk φ) = place φ :=\n  rfl\n#align coe_mk coe_mk\n\n",
 "coe_embedding_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n@[simp]\ntheorem is_real.coe_embedding_apply {φ : «expr →+* » K (exprℂ)} (hφ : is_real φ) (x : K) :\n    (hφ.embedding x : exprℂ) = φ x := by\n  ext; · rfl\n  · rw [of_real_im, eq_comm, ← Complex.conj_eq_iff_im]\n    rw [is_real] at hφ\n    exact RingHom.congr_fun hφ x\n#align is_real.coe_embedding_apply is_real.coe_embedding_apply\n\n",
 "card_real_embeddings":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\ntheorem card_real_embeddings :\n    card { φ : «expr →+* » K (exprℂ) // complex_embedding.is_real φ } = card { w : infinite_place K // is_real w } := by\n  convert(Fintype.ofEquiv_card (mk_real K)).symm\n#align card_real_embeddings card_real_embeddings\n\n",
 "card_complex_embeddings":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\ntheorem card_complex_embeddings :\n    card { φ : «expr →+* » K (exprℂ) // ¬complex_embedding.is_real φ } =\n      2 * card { w : infinite_place K // is_complex w } :=\n  by\n  rw [Fintype.card, Fintype.card, mul_comm, ← Algebra.id.smul_eq_mul, ← Finset.sum_const]\n  conv =>\n    rhs\n    congr\n    skip\n    ext\n    rw [← mk_complex.filter_card K x]\n  simp_rw [Finset.card_eq_sum_ones]\n  exact (Finset.sum_fiberwise Finset.univ (fun φ => mk_complex K φ) fun φ => 1).symm\n#align card_complex_embeddings card_complex_embeddings\n\n",
 "card":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/-\nCopyright (c) 2022 Xavier Roblot. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Alex J. Best, Xavier Roblot\n-/\n/-- The number of embeddings of a number field is equal to its finrank. -/\ntheorem card : Fintype.card («expr →+* » K A) = finrank (exprℚ) K := by\n  rw [Fintype.ofEquiv_card ring_hom.equiv_rat_alg_hom.symm, alg_hom.card]\n#align card card\n\n",
 "apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n@[simp]\ntheorem mk_complex.apply (φ : { φ : «expr →+* » K (exprℂ) // ¬complex_embedding.is_real φ }) (x : K) :\n    mk_complex K φ x = Complex.abs (φ x) :=\n  apply φ x\n#align mk_complex.apply mk_complex.apply\n\n",
 "abs_embedding_apply":
 "@[simp]\ntheorem is_real.abs_embedding_apply {w : infinite_place K} (hw : is_real w) (x : K) : |is_real.embedding hw x| = w x :=\n  by\n  rw [← is_real.place_embedding_apply hw x]\n  congr\n#align is_real.abs_embedding_apply is_real.abs_embedding_apply\n\n",
 "abs_embedding":
 "@[simp]\ntheorem abs_embedding (w : infinite_place K) (x : K) : Complex.abs (embedding w x) = w x :=\n  congr_fun (congr_arg coe_fn w.2.some_spec) x\n#align abs_embedding abs_embedding\n\n"}