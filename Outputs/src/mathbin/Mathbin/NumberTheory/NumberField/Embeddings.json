{"range_eval_eq_root_set_minpoly":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/-- Let `A` be an algebraically closed field and let `x ∈ K`, with `K` a number field.\nThe images of `x` by the embeddings of `K` in `A` are exactly the roots in `A` of\nthe minimal polynomial of `x` over `ℚ`. -/\ntheorem range_eval_eq_root_set_minpoly : (range fun φ : «expr →+* » K A => φ x) = (minpoly (exprℚ) x).root_set A :=\n  by\n  convert (number_field.is_algebraic K).range_eval_eq_root_set_minpoly A x using 1\n  ext a\n  exact ⟨fun ⟨φ, hφ⟩ => ⟨φ.to_rat_alg_hom, hφ⟩, fun ⟨φ, hφ⟩ => ⟨φ.to_ring_hom, hφ⟩⟩\n#align range_eval_eq_root_set_minpoly range_eval_eq_root_set_minpoly\n\n",
 "pow_eq_one_of_norm_eq_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/-- An algebraic integer whose conjugates are all of norm one is a root of unity. -/\ntheorem pow_eq_one_of_norm_eq_one {x : K} (hxi : is_integral ℤ x) (hx : ∀ φ : «expr →+* » K A, «expr‖ ‖» (φ x) = 1) :\n    ∃ (n : ℕ)(hn : 0 < n), x ^ n = 1 :=\n  by\n  obtain ⟨a, -, b, -, habne, h⟩ :=\n    @set.infinite.exists_ne_map_eq_of_maps_to _ _ _ _ ((· ^ ·) x : ℕ → K) set.infinite_univ _\n      (finite_of_norm_le K A (1 : exprℝ))\n  · replace habne := habne.lt_or_lt\n    have : _\n    swap\n    cases habne\n    swap\n    · revert a b\n      exact this\n    · exact this b a h.symm habne\n    refine' fun a b h hlt => ⟨a - b, tsub_pos_of_lt hlt, _⟩\n    rw [← nat.sub_add_cancel hlt.le, pow_add, mul_left_eq_self₀] at h\n    refine' h.resolve_right fun hp => _\n    specialize hx (is_alg_closed.lift (number_field.is_algebraic K)).to_ring_hom\n    rw [pow_eq_zero hp, map_zero, norm_zero] at hx\n    norm_num at hx\n  · exact fun a _ => ⟨hxi.pow a, fun φ => by simp only [hx φ, norm_pow, one_pow, map_pow]⟩\n#align pow_eq_one_of_norm_eq_one pow_eq_one_of_norm_eq_one\n\n",
 "pos_iff":
 "theorem pos_iff (w : infinite_place K) (x : K) : 0 < w x ↔ x ≠ 0 :=\n  AbsoluteValue.pos_iff w.1\n#align pos_iff pos_iff\n\n",
 "place_embedding":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\ntheorem is_real.place_embedding {φ : «expr →+* » K (exprℂ)} (hφ : is_real φ) : place hφ.embedding = place φ :=\n  by\n  ext x\n  simp only [place_apply, real.norm_eq_abs, ← abs_of_real, norm_eq_abs, hφ.coe_embedding_apply x]\n#align is_real.place_embedding is_real.place_embedding\n\n",
 "place_conjugate":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\ntheorem place_conjugate (φ : «expr →+* » K (exprℂ)) : place (conjugate φ) = place φ :=\n  by\n  ext\n  simp only [place_apply, norm_eq_abs, abs_conj, conjugate_coe_eq]\n#align place_conjugate place_conjugate\n\n",
 "place_apply":
 "@[simp]\ntheorem number_field.place_apply (x : K) : (number_field.place φ) x = norm (φ x) :=\n  rfl\n#align number_field.place_apply number_field.place_apply\n\n",
 "mk_embedding":
 "theorem mk_embedding (w : infinite_place K) : mk (embedding w) = w :=\n  subtype.ext w.2.some_spec\n#align mk_embedding mk_embedding\n\n",
 "is_real_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\ntheorem is_real_iff {φ : «expr →+* » K (exprℂ)} : is_real φ ↔ conjugate φ = φ :=\n  is_self_adjoint_iff\n#align is_real_iff is_real_iff\n\n",
 "is_real_conjugate_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\ntheorem is_real_conjugate_iff {φ : «expr →+* » K (exprℂ)} : is_real (conjugate φ) ↔ is_real φ :=\n  is_self_adjoint.star_iff\n#align is_real_conjugate_iff is_real_conjugate_iff\n\n",
 "finite_of_norm_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/-- Let `B` be a real number. The set of algebraic integers in `K` whose conjugates are all\nsmaller in norm than `B` is finite. -/\ntheorem finite_of_norm_le (B : exprℝ) :\n    { x : K | is_integral ℤ x ∧ ∀ φ : «expr →+* » K A, «expr‖ ‖» (φ x) ≤ B }.finite :=\n  by\n  let C := Nat.ceil (max B 1 ^ finrank (exprℚ) K * (finrank (exprℚ) K).choose (finrank (exprℚ) K / 2))\n  have := bUnion_roots_finite (algebra_map ℤ K) (finrank (exprℚ) K) (finite_Icc (-C : ℤ) C)\n  refine' this.subset fun x hx => _; simp_rw [mem_Union]\n  have h_map_ℚ_minpoly := minpoly.gcd_domain_eq_field_fractions' (exprℚ) hx.1\n  refine' ⟨_, ⟨_, fun i => _⟩, mem_root_set.2 ⟨minpoly.ne_zero hx.1, minpoly.aeval ℤ x⟩⟩\n  · rw [← (minpoly.monic hx.1).nat_degree_map (algebra_map ℤ (exprℚ)), ← h_map_ℚ_minpoly]\n    exact minpoly.nat_degree_le (is_integral_of_is_scalar_tower hx.1)\n  rw [mem_Icc, ← abs_le, ← @Int.cast_le (exprℝ)]\n  refine' (eq.trans_le _ <| coeff_bdd_of_norm_le hx.2 i).trans (Nat.le_ceil _)\n  rw [h_map_ℚ_minpoly, coeff_map, eq_intCast, int.norm_cast_rat, int.norm_eq_abs, Int.cast_abs]\n#align finite_of_norm_le finite_of_norm_le\n\n",
 "conjugate_coe_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `star_ring_end -/\n@[simp]\ntheorem conjugate_coe_eq (φ : «expr →+* » K (exprℂ)) (x : K) : (conjugate φ) x = (star_ring_end) (φ x) :=\n  rfl\n#align conjugate_coe_eq conjugate_coe_eq\n\n",
 "coeff_bdd_of_norm_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\ntheorem coeff_bdd_of_norm_le {B : exprℝ} {x : K} (h : ∀ φ : «expr →+* » K A, «expr‖ ‖» (φ x) ≤ B) (i : ℕ) :\n    «expr‖ ‖» ((minpoly (exprℚ) x).coeff i) ≤\n      max B 1 ^ finrank (exprℚ) K * (finrank (exprℚ) K).choose (finrank (exprℚ) K / 2) :=\n  by\n  have hx := is_separable.is_integral (exprℚ) x\n  rw [← norm_algebra_map' A, ← coeff_map (algebra_map (exprℚ) A)]\n  refine'\n    coeff_bdd_of_roots_le _ (minpoly.monic hx) (is_alg_closed.splits_codomain _) (minpoly.nat_degree_le hx)\n      (fun z hz => _) i\n  classical\n    rw [← Multiset.mem_toFinset] at hz\n    obtain ⟨φ, rfl⟩ := (range_eval_eq_root_set_minpoly K A x).symm.subset hz\n    exact h φ\n#align coeff_bdd_of_norm_le coeff_bdd_of_norm_le\n\n",
 "coe_mk":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\ntheorem coe_mk (φ : «expr →+* » K (exprℂ)) : «expr⇑ » (mk φ) = place φ :=\n  rfl\n#align coe_mk coe_mk\n\n",
 "coe_embedding_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n@[simp]\ntheorem is_real.coe_embedding_apply {φ : «expr →+* » K (exprℂ)} (hφ : is_real φ) (x : K) :\n    (hφ.embedding x : exprℂ) = φ x := by\n  ext; · rfl\n  · rw [of_real_im, eq_comm, ← complex.eq_conj_iff_im]\n    rw [is_real] at hφ\n    exact RingHom.congr_fun hφ x\n#align is_real.coe_embedding_apply is_real.coe_embedding_apply\n\n",
 "card":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/-\nCopyright (c) 2022 Xavier Roblot. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Alex J. Best, Xavier Roblot\n-/\n/-- The number of embeddings of a number field is equal to its finrank. -/\ntheorem card : fintype.card («expr →+* » K A) = finrank (exprℚ) K := by\n  rw [fintype.of_equiv_card ring_hom.equiv_rat_alg_hom.symm, alg_hom.card]\n#align card card\n\n",
 "apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\ntheorem apply (φ : «expr →+* » K (exprℂ)) (x : K) : (mk φ) x = complex.abs (φ x) :=\n  rfl\n#align apply apply\n\n"}