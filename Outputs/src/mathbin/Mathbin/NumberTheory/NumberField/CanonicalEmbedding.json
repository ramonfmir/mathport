{"space_rank":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprE -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/-\nCopyright (c) 2022 Xavier Roblot. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Xavier Roblot\n-/\n-- The ambient space `ℝ^r₁ × ℂ^r₂` with `(r₁, r₂)` the signature of `K`.\ntheorem space_rank [number_field K] : finrank (exprℝ) (exprE) = finrank (exprℚ) K :=\n  by\n  haveI : Module.Free (exprℝ) (exprℂ) := inferInstance\n  rw [finrank_prod, finrank_pi, finrank_pi_fintype, Complex.finrank_real_complex, Finset.sum_const, Finset.card_univ, ←\n    card_real_embeddings, Algebra.id.smul_eq_mul, mul_comm, ← card_complex_embeddings, ←\n    number_field.embeddings.card K (exprℂ), Fintype.card_subtype_compl, nat.add_sub_of_le (Fintype.card_subtype_le _)]\n#align space_rank space_rank\n\n",
 "norm_le_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem norm_le_iff [number_field K] (x : K) (r : exprℝ) :\n    «expr‖ ‖» (canonical_embedding K x) ≤ r ↔ ∀ w : infinite_place K, w x ≤ r :=\n  by\n  obtain hr | hr := lt_or_le r 0\n  · obtain ⟨w⟩ := infinite_place.nonempty K\n    exact iff_of_false (hr.trans_le <| norm_nonneg _).not_le fun h => hr.not_le <| (map_nonneg w _).trans <| h _\n  · lift r to NNReal using hr\n    simp_rw [← coe_nnnorm, nnnorm_eq, NNReal.coe_le_coe, Finset.sup_le_iff, Finset.mem_univ, forall_true_left, ←\n      NNReal.coe_le_coe, Subtype.coe_mk]\n#align norm_le_iff norm_le_iff\n\n",
 "non_trivial_space":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprE -/\ntheorem non_trivial_space [number_field K] : Nontrivial (exprE) :=\n  by\n  obtain ⟨w⟩ := infinite_place.nonempty K\n  obtain hw | hw := w.is_real_or_is_complex\n  · haveI : Nonempty { w : infinite_place K // is_real w } := ⟨⟨w, hw⟩⟩\n    exact nontrivial_prod_left\n  · haveI : Nonempty { w : infinite_place K // is_complex w } := ⟨⟨w, hw⟩⟩\n    exact nontrivial_prod_right\n#align non_trivial_space non_trivial_space\n\n",
 "nnnorm_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\ntheorem nnnorm_eq [number_field K] (x : K) :\n    «expr‖ ‖₊» (canonical_embedding K x) = Finset.univ.sup fun w : infinite_place K => ⟨w x, map_nonneg w x⟩ :=\n  by\n  rw [Prod.nnnorm_def', Pi.nnnorm_def, Pi.nnnorm_def]\n  rw [(_ :\n      Finset.univ = { w : infinite_place K | is_real w }.to_finset ∪ { w : infinite_place K | is_complex w }.to_finset)]\n  · rw [Finset.sup_union, sup_eq_max]\n    refine' congr_arg₂ _ _ _\n    · convert(finset.univ.sup_map (Function.Embedding.subtype fun w : infinite_place K => is_real w) fun w =>\n            (⟨w x, map_nonneg w x⟩ : NNReal)).symm using 2\n      ext w\n      simp only [apply_at_real_infinite_place, coe_nnnorm, Real.norm_eq_abs, Function.Embedding.coe_subtype,\n        Subtype.coe_mk, is_real.abs_embedding_apply]\n    · convert(finset.univ.sup_map (Function.Embedding.subtype fun w : infinite_place K => is_complex w) fun w =>\n            (⟨w x, map_nonneg w x⟩ : NNReal)).symm using 2\n      ext w\n      simp only [apply_at_complex_infinite_place, subtype.val_eq_coe, coe_nnnorm, complex.norm_eq_abs,\n        Function.Embedding.coe_subtype, Subtype.coe_mk, abs_embedding]\n  · ext w\n    simp only [w.is_real_or_is_complex, Set.mem_setOf_eq, Finset.mem_union, Set.mem_toFinset, Finset.mem_univ]\n#align nnnorm_eq nnnorm_eq\n\n",
 "inter_ball_finite":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprE -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprE -/\ntheorem integer_lattice.inter_ball_finite [number_field K] (r : exprℝ) :\n    ((integer_lattice K : Set (exprE)) ∩ closedBall 0 r).finite :=\n  by\n  obtain hr | hr := lt_or_le r 0\n  · simp [closed_ball_eq_empty.2 hr]\n  have heq :\n    ∀ x, canonical_embedding K x ∈ closed_ball (0 : exprE) r ↔ ∀ φ : «expr →+* » K (exprℂ), «expr‖ ‖» (φ x) ≤ r :=\n    by\n    simp only [← place_apply, ← infinite_place.coe_mk, mem_closedBall_zero_iff, norm_le_iff]\n    exact fun x => le_iff_le x r\n  convert(embeddings.finite_of_norm_le K (exprℂ) r).image (canonical_embedding K)\n  ext\n  constructor\n  · rintro ⟨⟨_, ⟨x, rfl⟩, rfl⟩, hx2⟩\n    exact ⟨x, ⟨SetLike.coe_mem x, (HEq x).mp hx2⟩, rfl⟩\n  · rintro ⟨x, ⟨hx1, hx2⟩, rfl⟩\n    exact ⟨⟨x, ⟨⟨x, hx1⟩, rfl⟩, rfl⟩, (HEq x).mpr hx2⟩\n#align integer_lattice.inter_ball_finite integer_lattice.inter_ball_finite\n\n",
 "canonical_embedding_injective":
 "theorem _root_.number_field.canonical_embedding_injective [number_field K] :\n    injective (number_field.canonical_embedding K) :=\n  @RingHom.injective _ _ _ _ (non_trivial_space K) _\n#align number_field.canonical_embedding_injective number_field.canonical_embedding_injective\n\n",
 "apply_at_real_infinite_place":
 "@[simp]\ntheorem apply_at_real_infinite_place (w : { w : infinite_place K // is_real w }) (x : K) :\n    (number_field.canonical_embedding K x).1 w = w.prop.embedding x := by\n  simp only [canonical_embedding, RingHom.prod_apply, Pi.ringHom_apply]\n#align apply_at_real_infinite_place apply_at_real_infinite_place\n\n",
 "apply_at_complex_infinite_place":
 "@[simp]\ntheorem apply_at_complex_infinite_place (w : { w : infinite_place K // is_complex w }) (x : K) :\n    (number_field.canonical_embedding K x).2 w = Embedding w.val x := by\n  simp only [canonical_embedding, RingHom.prod_apply, Pi.ringHom_apply]\n#align apply_at_complex_infinite_place apply_at_complex_infinite_place\n\n"}