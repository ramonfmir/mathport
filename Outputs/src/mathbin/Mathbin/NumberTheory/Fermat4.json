{"not_minimal":
 "-- If we have a solution to a ^ 4 + b ^ 4 = c ^ 2, we can construct a smaller one. This\n-- implies there can't be a smallest solution.\ntheorem not_minimal {a b c : ℤ} (h : Minimal a b c) (ha2 : a % 2 = 1) (hc : 0 < c) : False :=\n  by\n  -- Use the fact that a ^ 2, b ^ 2, c form a pythagorean triple to obtain m and n such that\n  -- a ^ 2 = m ^ 2 - n ^ 2, b ^ 2 = 2 * m * n and c = m ^ 2 + n ^ 2\n  -- first the formula:\n  have ht : PythagoreanTriple (a ^ 2) (b ^ 2) c :=\n    by\n    delta PythagoreanTriple\n    linear_combination h.1.2.2\n  -- coprime requirement:\n  have h2 : int.gcd (a ^ 2) (b ^ 2) = 1 := int.gcd_eq_one_iff_coprime.mpr (coprime_of_minimal h).pow\n  -- in order to reduce the possibilities we get from the classification of pythagorean triples\n  -- it helps if we know the parity of a ^ 2 (and the sign of c):\n  have ha22 : a ^ 2 % 2 = 1 := by\n    rw [sq, Int.mul_emod, ha2]\n    norm_num\n  obtain ⟨m, n, ht1, ht2, ht3, ht4, ht5, ht6⟩ := ht.coprime_classification' h2 ha22 hc\n  -- Now a, n, m form a pythagorean triple and so we can obtain r and s such that\n  -- a = r ^ 2 - s ^ 2, n = 2 * r * s and m = r ^ 2 + s ^ 2\n  -- formula:\n  have htt : PythagoreanTriple a n m := by\n    delta PythagoreanTriple\n    linear_combination ht1\n  -- a and n are coprime, because a ^ 2 = m ^ 2 - n ^ 2 and m and n are coprime.\n  have h3 : int.gcd a n = 1 := by\n    apply int.gcd_eq_one_iff_coprime.mpr\n    apply @IsCoprime.of_mul_left_left _ _ _ a\n    rw [← sq, ht1, (by ring : m ^ 2 - n ^ 2 = m ^ 2 + -n * n)]\n    exact (int.gcd_eq_one_iff_coprime.mp ht4).pow_left.add_mul_right_left (-n)\n  -- m is positive because b is non-zero and b ^ 2 = 2 * m * n and we already have 0 ≤ m.\n  have hb20 : b ^ 2 ≠ 0 := mt pow_eq_zero h.1.2.1\n  have h4 : 0 < m := by\n    apply lt_of_le_of_ne ht6\n    rintro rfl\n    revert hb20\n    rw [ht2]\n    simp\n  obtain ⟨r, s, htt1, htt2, htt3, htt4, htt5, htt6⟩ := htt.coprime_classification' h3 ha2 h4\n  -- Now use the fact that (b / 2) ^ 2 = m * r * s, and m, r and s are pairwise coprime to obtain\n  -- i, j and k such that m = i ^ 2, r = j ^ 2 and s = k ^ 2.\n  -- m and r * s are coprime because m = r ^ 2 + s ^ 2 and r and s are coprime.\n  have hcp : int.gcd m (r * s) = 1 := by\n    rw [htt3]\n    exact int.gcd_eq_one_iff_coprime.mpr (Int.coprime_of_sq_sum' (int.gcd_eq_one_iff_coprime.mp htt4))\n  -- b is even because b ^ 2 = 2 * m * n.\n  have hb2 : 2 ∣ b := by\n    apply @Int.Prime.dvd_pow' _ 2 _ Nat.prime_two\n    rw [ht2, mul_assoc]\n    exact dvd_mul_right 2 (m * n)\n  cases' hb2 with b' hb2'\n  have hs : b' ^ 2 = m * (r * s) :=\n    by\n    apply (mul_right_inj' (by norm_num : (4 : ℤ) ≠ 0)).mp\n    linear_combination (-b - 2 * b') * hb2' + ht2 + 2 * m * htt2\n  have hrsz : r * s ≠ 0 :=\n    by\n    -- because b ^ 2 is not zero and (b / 2) ^ 2 = m * (r * s)\n    by_contra hrsz\n    revert hb20\n    rw [ht2, htt2, mul_assoc, @mul_assoc _ _ _ r s, hrsz]\n    simp\n  have h2b0 : b' ≠ 0 := by\n    apply ne_zero_pow two_ne_zero\n    rw [hs]\n    apply mul_ne_zero\n    · exact ne_of_gt h4\n    · exact hrsz\n  obtain ⟨i, hi⟩ := Int.sq_of_gcd_eq_one hcp hs.symm\n  -- use m is positive to exclude m = - i ^ 2\n  have hi' : ¬m = -i ^ 2 := by\n    by_contra h1\n    have hit : -i ^ 2 ≤ 0\n    apply neg_nonpos.mpr (sq_nonneg i)\n    rw [← h1] at hit\n    apply absurd h4 (not_lt.mpr hit)\n  replace hi : m = i ^ 2\n  · apply or.resolve_right hi hi'\n  rw [mul_comm] at hs\n  rw [Int.gcd_comm] at hcp\n  -- obtain d such that r * s = d ^ 2\n  obtain ⟨d, hd⟩ := Int.sq_of_gcd_eq_one hcp hs.symm\n  -- (b / 2) ^ 2 and m are positive so r * s is positive\n  have hd' : ¬r * s = -d ^ 2 := by\n    by_contra h1\n    rw [h1] at hs\n    have h2 : b' ^ 2 ≤ 0 := by\n      rw [hs, (by ring : -d ^ 2 * m = -(d ^ 2 * m))]\n      exact neg_nonpos.mpr ((zero_le_mul_right h4).mpr (sq_nonneg d))\n    have h2' : 0 ≤ b' ^ 2 := by apply sq_nonneg b'\n    exact absurd (lt_of_le_of_ne h2' (ne.symm (pow_ne_zero _ h2b0))) (not_lt.mpr h2)\n  replace hd : r * s = d ^ 2\n  · apply or.resolve_right hd hd'\n  -- r = +/- j ^ 2\n  obtain ⟨j, hj⟩ := Int.sq_of_gcd_eq_one htt4 hd\n  have hj0 : j ≠ 0 := by\n    intro h0\n    rw [h0, zero_pow zero_lt_two, neg_zero, or_self_iff] at hj\n    apply left_ne_zero_of_mul hrsz hj\n  rw [mul_comm] at hd\n  rw [Int.gcd_comm] at htt4\n  -- s = +/- k ^ 2\n  obtain ⟨k, hk⟩ := Int.sq_of_gcd_eq_one htt4 hd\n  have hk0 : k ≠ 0 := by\n    intro h0\n    rw [h0, zero_pow zero_lt_two, neg_zero, or_self_iff] at hk\n    apply right_ne_zero_of_mul hrsz hk\n  have hj2 : r ^ 2 = j ^ 4 := by\n    cases' hj with hjp hjp <;>\n      · rw [hjp]\n        ring\n  have hk2 : s ^ 2 = k ^ 4 := by\n    cases' hk with hkp hkp <;>\n      · rw [hkp]\n        ring\n  -- from m = r ^ 2 + s ^ 2 we now get a new solution to a ^ 4 + b ^ 4 = c ^ 2:\n  have hh : i ^ 2 = j ^ 4 + k ^ 4 := by rw [← hi, htt3, hj2, hk2]\n  have hn : n ≠ 0 := by\n    rw [ht2] at hb20\n    apply right_ne_zero_of_mul hb20\n  -- and it has a smaller c: from c = m ^ 2 + n ^ 2 we see that m is smaller than c, and i ^ 2 = m.\n  have hic : Int.natAbs i < Int.natAbs c := by\n    apply int.coe_nat_lt.mp\n    rw [← Int.eq_natAbs_of_zero_le (le_of_lt hc)]\n    apply gt_of_gt_of_ge _ (Int.natAbs_le_self_sq i)\n    rw [← hi, ht3]\n    apply gt_of_gt_of_ge _ (Int.le_self_sq m)\n    exact lt_add_of_pos_right (m ^ 2) (sq_pos_of_ne_zero n hn)\n  have hic' : Int.natAbs c ≤ Int.natAbs i := by\n    apply h.2 j k i\n    exact ⟨hj0, hk0, hh.symm⟩\n  apply absurd (not_le_of_lt hic) (not_not.mpr hic')\n#align not_minimal not_minimal\n\n",
 "not_fermat_42":
 "#print not_fermat_42 /-\ntheorem not_fermat_42 {a b c : ℤ} (ha : a ≠ 0) (hb : b ≠ 0) : a ^ 4 + b ^ 4 ≠ c ^ 2 :=\n  by\n  intro h\n  obtain ⟨a0, b0, c0, ⟨hf, h2, hp⟩⟩ := Fermat42.exists_pos_odd_minimal (and.intro ha (and.intro hb h))\n  apply Fermat42.not_minimal hf h2 hp\n#align not_fermat_42 not_fermat_42\n-/\n\n",
 "not_fermat_4":
 "#print not_fermat_4 /-\ntheorem not_fermat_4 {a b c : ℤ} (ha : a ≠ 0) (hb : b ≠ 0) : a ^ 4 + b ^ 4 ≠ c ^ 4 :=\n  by\n  intro heq\n  apply @not_fermat_42 _ _ (c ^ 2) ha hb\n  rw [HEq]; ring\n#align not_fermat_4 not_fermat_4\n-/\n\n",
 "neg_of_minimal":
 "/-- We can assume that a minimal solution to `a ^ 4 + b ^ 4 = c ^ 2` has positive `c`. -/\ntheorem neg_of_minimal {a b c : ℤ} : Minimal a b c → Minimal a b (-c) :=\n  by\n  rintro ⟨⟨ha, hb, heq⟩, h2⟩\n  constructor\n  · apply and.intro ha (and.intro hb _)\n    rw [HEq]\n    exact (neg_sq c).symm\n  rwa [Int.natAbs_neg c]\n#align neg_of_minimal neg_of_minimal\n\n",
 "mul":
 "theorem mul {a b c k : ℤ} (hk0 : k ≠ 0) : Fermat42 a b c ↔ Fermat42 (k * a) (k * b) (k ^ 2 * c) :=\n  by\n  delta Fermat42\n  constructor\n  · intro f42\n    constructor\n    · exact mul_ne_zero hk0 f42.1\n    constructor\n    · exact mul_ne_zero hk0 f42.2.1\n    · have H : a ^ 4 + b ^ 4 = c ^ 2 := f42.2.2\n      linear_combination k ^ 4 * H\n  · intro f42\n    constructor\n    · exact right_ne_zero_of_mul f42.1\n    constructor\n    · exact right_ne_zero_of_mul f42.2.1\n    apply (mul_right_inj' (pow_ne_zero 4 hk0)).mp\n    linear_combination f42.2.2\n#align mul mul\n\n",
 "minimal_comm":
 "/-- We can swap `a` and `b` in a minimal solution to `a ^ 4 + b ^ 4 = c ^ 2`. -/\ntheorem minimal_comm {a b c : ℤ} : Minimal a b c → Minimal b a c := fun ⟨h1, h2⟩ => ⟨Fermat42.comm.mp h1, h2⟩\n#align minimal_comm minimal_comm\n\n",
 "exists_pos_odd_minimal":
 "/-- We can assume that a minimal solution to `a ^ 4 + b ^ 4 = c ^ 2` has\n`a` odd and `c` positive. -/\ntheorem exists_pos_odd_minimal {a b c : ℤ} (h : Fermat42 a b c) : ∃ a0 b0 c0, Minimal a0 b0 c0 ∧ a0 % 2 = 1 ∧ 0 < c0 :=\n  by\n  obtain ⟨a0, b0, c0, hf, hc⟩ := exists_odd_minimal h\n  rcases lt_trichotomy 0 c0 with (h1 | rfl | h1)\n  · use a0, b0, c0\n    tauto\n  · exfalso\n    exact NeZero hf.1 rfl\n  · use a0, b0, -c0, neg_of_minimal hf, hc\n    exact neg_pos.mpr h1\n#align exists_pos_odd_minimal exists_pos_odd_minimal\n\n",
 "exists_odd_minimal":
 "/-- We can assume that a minimal solution to `a ^ 4 + b ^ 4 = c ^ 2` has `a` odd. -/\ntheorem exists_odd_minimal {a b c : ℤ} (h : Fermat42 a b c) : ∃ a0 b0 c0, Minimal a0 b0 c0 ∧ a0 % 2 = 1 :=\n  by\n  obtain ⟨a0, b0, c0, hf⟩ := exists_minimal h\n  cases' Int.emod_two_eq_zero_or_one a0 with hap hap\n  · cases' Int.emod_two_eq_zero_or_one b0 with hbp hbp\n    · exfalso\n      have h1 : 2 ∣ (int.gcd a0 b0 : ℤ) := Int.dvd_gcd (Int.dvd_of_emod_eq_zero hap) (Int.dvd_of_emod_eq_zero hbp)\n      rw [int.gcd_eq_one_iff_coprime.mpr (coprime_of_minimal hf)] at h1\n      revert h1\n      norm_num\n    · exact ⟨b0, ⟨a0, ⟨c0, minimal_comm hf, hbp⟩⟩⟩\n  exact ⟨a0, ⟨b0, ⟨c0, hf, hap⟩⟩⟩\n#align exists_odd_minimal exists_odd_minimal\n\n",
 "exists_minimal":
 "/-- if we have a solution to `a ^ 4 + b ^ 4 = c ^ 2` then there must be a minimal one. -/\ntheorem exists_minimal {a b c : ℤ} (h : Fermat42 a b c) : ∃ a0 b0 c0, Minimal a0 b0 c0 :=\n  by\n  let S : Set ℕ := { n | ∃ s : ℤ × ℤ × ℤ, Fermat42 s.1 s.2.1 s.2.2 ∧ n = Int.natAbs s.2.2 }\n  have S_nonempty : S.nonempty := by\n    use Int.natAbs c\n    rw [Set.mem_setOf_eq]\n    use ⟨a, ⟨b, c⟩⟩\n    tauto\n  let m : ℕ := nat.find S_nonempty\n  have m_mem : m ∈ S := nat.find_spec S_nonempty\n  rcases m_mem with ⟨s0, hs0, hs1⟩\n  use s0.1, s0.2.1, s0.2.2, hs0\n  intro a1 b1 c1 h1\n  rw [← hs1]\n  apply nat.find_min'\n  use ⟨a1, ⟨b1, c1⟩⟩\n  tauto\n#align exists_minimal exists_minimal\n\n",
 "coprime_of_sq_sum'":
 "#print Int.coprime_of_sq_sum' /-\ntheorem Int.coprime_of_sq_sum' {r s : ℤ} (h : IsCoprime r s) : IsCoprime (r ^ 2 + s ^ 2) (r * s) :=\n  by\n  apply IsCoprime.mul_right (Int.coprime_of_sq_sum (is_coprime_comm.mp h))\n  rw [add_comm]; apply Int.coprime_of_sq_sum h\n#align int.coprime_of_sq_sum' Int.coprime_of_sq_sum'\n-/\n\n",
 "coprime_of_sq_sum":
 "#print Int.coprime_of_sq_sum /-\ntheorem Int.coprime_of_sq_sum {r s : ℤ} (h2 : IsCoprime s r) : IsCoprime (r ^ 2 + s ^ 2) r :=\n  by\n  rw [sq, sq]\n  exact (IsCoprime.mul_left h2 h2).mul_add_left_left r\n#align int.coprime_of_sq_sum Int.coprime_of_sq_sum\n-/\n\n",
 "coprime_of_minimal":
 "/-- a minimal solution to `a ^ 4 + b ^ 4 = c ^ 2` must have `a` and `b` coprime. -/\ntheorem coprime_of_minimal {a b c : ℤ} (h : Minimal a b c) : IsCoprime a b :=\n  by\n  apply int.gcd_eq_one_iff_coprime.mp\n  by_contra hab\n  obtain ⟨p, hp, hpa, hpb⟩ := nat.prime.not_coprime_iff_dvd.mp hab\n  obtain ⟨a1, rfl⟩ := int.coe_nat_dvd_left.mpr hpa\n  obtain ⟨b1, rfl⟩ := int.coe_nat_dvd_left.mpr hpb\n  have hpc : (p : ℤ) ^ 2 ∣ c := by\n    rw [← Int.pow_dvd_pow_iff zero_lt_two, ← h.1.2.2]\n    apply Dvd.intro (a1 ^ 4 + b1 ^ 4)\n    ring\n  obtain ⟨c1, rfl⟩ := hpc\n  have hf : Fermat42 a1 b1 c1 := (Fermat42.mul (int.coe_nat_ne_zero.mpr (Nat.Prime.ne_zero hp))).mpr h.1\n  apply nat.le_lt_antisymm (h.2 _ _ _ hf)\n  rw [Int.natAbs_mul, lt_mul_iff_one_lt_left, Int.natAbs_pow, Int.natAbs_ofNat]\n  · exact Nat.one_lt_pow _ _ zero_lt_two (Nat.Prime.one_lt hp)\n  · exact nat.pos_of_ne_zero (Int.natAbs_ne_zero_of_ne_zero (NeZero hf))\n#align coprime_of_minimal coprime_of_minimal\n\n",
 "comm":
 "#print comm /-\n/-\nCopyright (c) 2020 Paul van Wamelen. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Paul van Wamelen\n-/\ntheorem comm {a b c : ℤ} : Fermat42 a b c ↔ Fermat42 b a c :=\n  by\n  delta Fermat42\n  rw [add_comm]\n  tauto\n#align comm comm\n-/\n\n",
 "NeZero":
 "#print NeZero /-\ntheorem NeZero {a b c : ℤ} (h : Fermat42 a b c) : c ≠ 0 :=\n  by\n  apply ne_zero_pow two_ne_zero _; apply ne_of_gt\n  rw [← h.2.2, (by ring : a ^ 4 + b ^ 4 = (a ^ 2) ^ 2 + (b ^ 2) ^ 2)]\n  exact add_pos (sq_pos_of_ne_zero _ (pow_ne_zero 2 h.1)) (sq_pos_of_ne_zero _ (pow_ne_zero 2 h.2.1))\n#align ne_zero NeZero\n-/\n\n"}