{"sum_range_pow_eq_bernoulli_sub":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/-- Another version of `bernoulli.sum_range_pow`. -/\ntheorem sum_range_pow_eq_bernoulli_sub (n p : ℕ) :\n    (p + 1 : exprℚ) *\n        finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (range n)\n          ((k : exprℚ) ^ p) =\n      (bernoulli p.succ).eval n - _root_.bernoulli p.succ :=\n  by\n  rw [sum_range_pow, bernoulli_def, eval_finset_sum, ← sum_div, mul_div_cancel' _ _]\n  · simp_rw [eval_monomial]\n    symm\n    rw [← sum_flip _, sum_range_succ]\n    simp only [tsub_self, tsub_zero, choose_zero_right, cast_one, mul_one, pow_zero, add_tsub_cancel_right]\n    apply sum_congr rfl fun x hx => _\n    apply congr_arg₂ _ (congr_arg₂ _ _ _) rfl\n    · rw [nat.sub_sub_self (mem_range_le hx)]\n    · rw [← choose_symm (mem_range_le hx)]\n  · norm_cast\n    apply succ_ne_zero _\n#align sum_range_pow_eq_bernoulli_sub sum_range_pow_eq_bernoulli_sub\n\n",
 "sum_bernoulli":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n@[simp]\ntheorem sum_bernoulli (n : ℕ) :\n    finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (range (n + 1))\n        («expr • » ((n + 1).choose k : exprℚ) (bernoulli k)) =\n      monomial n (n + 1 : exprℚ) :=\n  by\n  simp_rw [bernoulli_def, finset.smul_sum, finset.range_eq_Ico, ← finset.sum_Ico_Ico_comm, finset.sum_Ico_eq_sum_range]\n  simp only [add_tsub_cancel_left, tsub_zero, zero_add, linear_map.map_add]\n  simp_rw [smul_monomial, mul_comm (_root_.bernoulli _) _, smul_eq_mul, ← mul_assoc]\n  conv_lhs =>\n    apply_congr\n    skip\n    conv =>\n      apply_congr\n      skip\n      rw [← nat.cast_mul, choose_mul ((le_tsub_iff_left <| mem_range_le H).1 <| mem_range_le H_1) (le.intro rfl),\n        nat.cast_mul, add_comm x x_1, add_tsub_cancel_right, mul_assoc, mul_comm, ← smul_eq_mul, ← smul_monomial]\n    rw [← sum_smul]\n  rw [sum_range_succ_comm]\n  simp only [add_right_eq_self, mul_one, cast_one, cast_add, add_tsub_cancel_left, choose_succ_self_right, one_smul,\n    _root_.bernoulli_zero, sum_singleton, zero_add, linear_map.map_add, range_one]\n  apply sum_eq_zero fun x hx => _\n  have f : ∀ x ∈ range n, ¬n + 1 - x = 1 := by\n    rintro x H\n    rw [mem_range] at H\n    rw [eq_comm]\n    exact ne_of_lt (nat.lt_of_lt_of_le one_lt_two (le_tsub_of_add_le_left (succ_le_succ H)))\n  rw [sum_bernoulli]\n  have g : ite (n + 1 - x = 1) (1 : exprℚ) 0 = 0 :=\n    by\n    simp only [ite_eq_right_iff, one_ne_zero]\n    intro h₁\n    exact (f x hx) h₁\n  rw [g, zero_smul]\n#align sum_bernoulli sum_bernoulli\n\n",
 "derivative_bernoulli_add_one":
 "theorem derivative_bernoulli_add_one (k : ℕ) : (bernoulli (k + 1)).derivative = (k + 1) * bernoulli k :=\n  by\n  simp_rw [bernoulli, derivative_sum, derivative_monomial, nat.sub_sub, nat.add_sub_add_right]\n  -- LHS sum has an extra term, but the coefficient is zero:\n  rw [range_add_one, sum_insert not_mem_range_self, tsub_self, cast_zero, mul_zero, map_zero, zero_add, mul_sum]\n  -- the rest of the sum is termwise equal:\n  refine' sum_congr (by rfl) fun m hm => _\n  conv_rhs => rw [← Nat.cast_one, ← Nat.cast_add, ← C_eq_nat_cast, C_mul_monomial, mul_comm]\n  rw [mul_assoc, mul_assoc, ← nat.cast_mul, ← nat.cast_mul]\n  congr 3\n  rw [(choose_mul_succ_eq k m).symm, mul_comm]\n#align derivative_bernoulli_add_one derivative_bernoulli_add_one\n\n",
 "derivative_bernoulli":
 "theorem derivative_bernoulli (k : ℕ) : (bernoulli k).derivative = k * bernoulli (k - 1) :=\n  by\n  cases k\n  · rw [Nat.cast_zero, zero_mul, bernoulli_zero, derivative_one]\n  · exact_mod_cast derivative_bernoulli_add_one k\n#align derivative_bernoulli derivative_bernoulli\n\n",
 "bernoulli_zero":
 "/-\n### examples\n-/\n@[simp]\ntheorem bernoulli_zero : bernoulli 0 = 1 := by simp [bernoulli]\n#align bernoulli_zero bernoulli_zero\n\n",
 "bernoulli_succ_eval":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/-- Rearrangement of `polynomial.sum_range_pow_eq_bernoulli_sub`. -/\ntheorem bernoulli_succ_eval (n p : ℕ) :\n    (bernoulli p.succ).eval n =\n      _root_.bernoulli p.succ +\n        (p + 1 : exprℚ) *\n          finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (range n)\n            ((k : exprℚ) ^ p) :=\n  by\n  apply eq_add_of_sub_eq'\n  rw [sum_range_pow_eq_bernoulli_sub]\n#align bernoulli_succ_eval bernoulli_succ_eval\n\n",
 "bernoulli_generating_function":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n-- TODO: define exponential generating functions, and use them here\n-- This name should probably be updated afterwards\n/-- The theorem that $(e^X - 1) * ∑ Bₙ(t)* X^n/n! = Xe^{tX}$ -/\ntheorem bernoulli_generating_function (t : A) :\n    (mk fun n => aeval t («expr • » (1 / nat.factorial n : exprℚ) (bernoulli n))) * (exp A - 1) =\n      power_series.X * rescale t (exp A) :=\n  by\n  -- check equality of power series by checking coefficients of X^n\n  ext n\n  -- n = 0 case solved by `simp`\n  cases n;\n  · simp\n  -- n ≥ 1, the coefficients is a sum to n+2, so use `sum_range_succ` to write as\n  -- last term plus sum to n+1\n  rw [coeff_succ_X_mul, coeff_rescale, coeff_exp, power_series.coeff_mul, nat.sum_antidiagonal_eq_sum_range_succ_mk,\n    sum_range_succ]\n  -- last term is zero so kill with `add_zero`\n  simp only [RingHom.map_sub, tsub_self, constant_coeff_one, constant_coeff_exp, coeff_zero_eq_constant_coeff, mul_zero,\n    sub_self, add_zero]\n  -- Let's multiply both sides by (n+1)! (OK because it's a unit)\n  have hnp1 : is_unit (nat.factorial (n + 1) : exprℚ) := IsUnit.mk0 _ (by exact_mod_cast factorial_ne_zero (n + 1))\n  rw [← (hnp1.map (algebra_map (exprℚ) A)).mul_right_inj]\n  -- do trivial rearrangements to make RHS (n+1)*t^n\n  rw [mul_left_comm, ← RingHom.map_mul]\n  change _ = t ^ n * algebra_map (exprℚ) A (((n + 1) * nat.factorial n : ℕ) * (1 / nat.factorial n))\n  rw [cast_mul, mul_assoc,\n    mul_one_div_cancel (show (nat.factorial n : exprℚ) ≠ 0 from cast_ne_zero.2 (factorial_ne_zero n)), mul_one,\n    mul_comm (t ^ n), ← aeval_monomial, cast_add, cast_one]\n  -- But this is the RHS of `sum_bernoulli_poly`\n  rw [← sum_bernoulli, finset.mul_sum, alg_hom.map_sum]\n  -- and now we have to prove a sum is a sum, but all the terms are equal.\n  apply finset.sum_congr rfl\n  -- The rest is just trivialities, hampered by the fact that we're coercing\n  -- factorials and binomial coefficients between ℕ and ℚ and A.\n  intro i hi\n  -- deal with coefficients of e^X-1\n  simp only [nat.cast_choose (exprℚ) (mem_range_le hi), coeff_mk, if_neg (mem_range_sub_ne_zero hi), one_div,\n    alg_hom.map_smul, power_series.coeff_one, coeff_exp, sub_zero, linear_map.map_sub, algebra.smul_mul_assoc,\n    algebra.smul_def, mul_right_comm _ ((aeval t) _), ← mul_assoc, ← RingHom.map_mul, succ_eq_add_one, ←\n    polynomial.C_eq_algebra_map, polynomial.aeval_mul, polynomial.aeval_C]\n  -- finally cancel the Bernoulli polynomial and the algebra_map\n  congr\n  apply congr_arg\n  rw [mul_assoc, div_eq_mul_inv, ← mul_inv]\n#align bernoulli_generating_function bernoulli_generating_function\n\n",
 "bernoulli_eval_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n@[simp]\ntheorem bernoulli_eval_zero (n : ℕ) : (bernoulli n).eval 0 = _root_.bernoulli n :=\n  by\n  rw [bernoulli, eval_finset_sum, sum_range_succ]\n  have :\n    finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (range n)\n        (_root_.bernoulli x * n.choose x * 0 ^ (n - x)) =\n      0 :=\n    by\n    apply sum_eq_zero fun x hx => _\n    have h : 0 < n - x := tsub_pos_of_lt (mem_range.1 hx)\n    simp [h]\n  simp [this]\n#align bernoulli_eval_zero bernoulli_eval_zero\n\n",
 "bernoulli_eval_one_add":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\ntheorem bernoulli_eval_one_add (n : ℕ) (x : exprℚ) :\n    (bernoulli n).eval (1 + x) = (bernoulli n).eval x + n * x ^ (n - 1) :=\n  by\n  apply nat.strong_induction_on n fun d hd => _\n  have nz : ((d.succ : ℕ) : exprℚ) ≠ 0 := by\n    norm_cast\n    exact d.succ_ne_zero\n  apply (mul_right_inj' nz).1\n  rw [← smul_eq_mul, ← eval_smul, bernoulli_eq_sub_sum, mul_add, ← smul_eq_mul, ← eval_smul, bernoulli_eq_sub_sum,\n    eval_sub, eval_finset_sum]\n  conv_lhs =>\n    congr\n    skip\n    apply_congr\n    skip\n    rw [eval_smul, hd x_1 (mem_range.1 H)]\n  rw [eval_sub, eval_finset_sum]\n  simp_rw [eval_smul, smul_add]\n  rw [sum_add_distrib, sub_add, sub_eq_sub_iff_sub_eq_sub, _root_.add_sub_sub_cancel]\n  conv_rhs =>\n    congr\n    skip\n    congr\n    rw [succ_eq_add_one, ← choose_succ_self_right d]\n  rw [Nat.cast_succ, ← smul_eq_mul, ← sum_range_succ _ d, eval_monomial_one_add_sub]\n  simp_rw [smul_eq_mul]\n#align bernoulli_eval_one_add bernoulli_eval_one_add\n\n",
 "bernoulli_eval_one":
 "@[simp]\ntheorem bernoulli_eval_one (n : ℕ) : (bernoulli n).eval 1 = _root_.bernoulli' n :=\n  by\n  simp only [bernoulli, eval_finset_sum]\n  simp only [← succ_eq_add_one, sum_range_succ, mul_one, cast_one, choose_self, (_root_.bernoulli _).mul_comm,\n    sum_bernoulli, one_pow, mul_one, eval_C, eval_monomial]\n  by_cases h : n = 1\n  · norm_num [h]\n  · simp [h]\n    exact bernoulli_eq_bernoulli'_of_ne_one h\n#align bernoulli_eval_one bernoulli_eval_one\n\n",
 "bernoulli_eq_sub_sum":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/-- Another version of `polynomial.sum_bernoulli`. -/\ntheorem bernoulli_eq_sub_sum (n : ℕ) :\n    «expr • » (n.succ : exprℚ) (bernoulli n) =\n      monomial n (n.succ : exprℚ) -\n        finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (Finset.range n)\n          («expr • » ((n + 1).choose k : exprℚ) (bernoulli k)) :=\n  by rw [Nat.cast_succ, ← sum_bernoulli n, sum_range_succ, add_sub_cancel', choose_succ_self_right, Nat.cast_succ]\n#align bernoulli_eq_sub_sum bernoulli_eq_sub_sum\n\n",
 "bernoulli_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/-\nCopyright (c) 2021 Ashvni Narayanan. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Ashvni Narayanan, David Loeffler\n-/\ntheorem bernoulli_def (n : ℕ) :\n    bernoulli n =\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (range (n + 1))\n        (polynomial.monomial i (_root_.bernoulli (n - i) * choose n i)) :=\n  by\n  rw [← sum_range_reflect, add_succ_sub_one, add_zero, bernoulli]\n  apply sum_congr rfl\n  rintro x hx\n  rw [mem_range_succ_iff] at hx; rw [choose_symm hx, tsub_tsub_cancel_of_le hx]\n#align bernoulli_def bernoulli_def\n\n"}