{"quot_adjoin_equiv_quot_map_apply_mk":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr < >» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr < >» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr < >» -/\n--the kernel of the map is clearly `(I * S) ∩ R<x>`. To get injectivity, we need to show that\n--this is contained in `I * R<x>`, which is the content of the previous lemma.\n-- Surjectivity follows from the surjectivity of the canonical map `R<x> → S ⧸ (I * S)`,\n-- which in turn follows from the fact that `I * S + (conductor R x) = S`.\n@[simp]\ntheorem quot_adjoin_equiv_quot_map_apply_mk (hx : «expr ⊔ » ((conductor R x).comap (algebraMap R S)) I = «expr⊤»)\n    (h_alg : function.injective (algebraMap («expr < >» R x) S)) (a : «expr < >» R x) :\n    quot_adjoin_equiv_quot_map hx h_alg ((I.map (algebraMap R («expr < >» R x))).quotient.mk a) =\n      (I.map (algebraMap R S)).quotient.mk ↑a :=\n  rfl\n#align quot_adjoin_equiv_quot_map_apply_mk quot_adjoin_equiv_quot_map_apply_mk\n\n",
 "prod_mem_ideal_map_of_mem_conductor":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr < >» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr < >» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr < >» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr < >» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr < >» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr < >» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr < >» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr < >» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr < >» -/\n/-- This technical lemma tell us that if `C` is the conductor of `R<x>` and `I` is an ideal of `R`\n  then `p * (I * S) ⊆ I * R<x>` for any `p` in `C ∩ R` -/\ntheorem prod_mem_ideal_map_of_mem_conductor {p : R} {z : S} (hp : p ∈ Ideal.comap (algebraMap R S) (conductor R x))\n    (hz' : z ∈ I.map (algebraMap R S)) :\n    algebraMap R S p * z ∈ «expr '' » (algebraMap («expr < >» R x) S) ↑(I.map (algebraMap R («expr < >» R x))) :=\n  by\n  rw [Ideal.map, Ideal.span, Finsupp.mem_span_image_iff_total] at hz'\n  obtain ⟨l, H, H'⟩ := hz'\n  rw [Finsupp.total_apply] at H'\n  rw [← H', mul_comm, Finsupp.sum_mul]\n  have lem :\n    ∀ {a : R},\n      a ∈ I →\n        «expr • » (l a) (algebraMap R S a) * algebraMap R S p ∈\n          «expr '' » (algebraMap («expr < >» R x) S) (I.map (algebraMap R («expr < >» R x))) :=\n    by\n    intro a ha\n    rw [Algebra.id.smul_eq_mul, mul_assoc, mul_comm, mul_assoc, Set.mem_image]\n    refine'\n      exists.intro\n        (algebraMap R («expr < >» R x) a *\n          ⟨l a * algebraMap R S p, show l a * algebraMap R S p ∈ «expr < >» R x from _⟩)\n        _\n    · rw [mul_comm]\n      exact mem_conductor_iff.mp (ideal.mem_comap.mp hp) _\n    refine' ⟨_, by simpa only [RingHom.map_mul, mul_comm (algebraMap R S p) (l a)] ⟩\n    rw [mul_comm]\n    apply Ideal.mul_mem_left (I.map (algebraMap R («expr < >» R x))) _ (Ideal.mem_map_of_mem _ ha)\n  refine'\n    Finset.sum_induction _\n      (fun u => u ∈ «expr '' » (algebraMap («expr < >» R x) S) (I.map (algebraMap R («expr < >» R x)))) (fun a b => _) _\n      _\n  rintro ⟨z, hz, rfl⟩ ⟨y, hy, rfl⟩\n  rw [← RingHom.map_add]\n  exact ⟨z + y, Ideal.add_mem _ (set_like.mem_coe.mp hz) hy, rfl⟩\n  · refine' ⟨0, set_like.mem_coe.mpr <| Ideal.zero_mem _, RingHom.map_zero _⟩\n  · intro y hy\n    exact lem ((Finsupp.mem_supported _ l).mp H hy)\n#align prod_mem_ideal_map_of_mem_conductor prod_mem_ideal_map_of_mem_conductor\n\n",
 "normalized_factors_ideal_map_eq_normalized_factors_min_poly_mk_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/-- The **Kummer-Dedekind Theorem**. -/\ntheorem normalized_factors_ideal_map_eq_normalized_factors_min_poly_mk_map (hI : IsMaximal I) (hI' : I ≠ «expr⊥»)\n    (hx : «expr ⊔ » ((conductor R x).comap (algebraMap R S)) I = «expr⊤») (hx' : is_integral R x) :\n    normalizedFactors (I.map (algebraMap R S)) =\n      Multiset.map\n        (fun f => ((normalized_factors_map_equiv_normalized_factors_min_poly_mk hI hI' hx hx').symm f : Ideal S))\n        (normalizedFactors (Polynomial.map I.quotient.mk (minpoly R x))).attach :=\n  by\n  ext J\n  -- WLOG, assume J is a normalized factor\n  by_cases hJ : J ∈ normalized_factors (I.map (algebraMap R S))\n  swap\n  · rw [multiset.count_eq_zero.mpr hJ, eq_comm, Multiset.count_eq_zero, Multiset.mem_map]\n    simp only [Multiset.mem_attach, true_and_iff, not_exists]\n    rintro J' rfl\n    exact hJ ((normalized_factors_map_equiv_normalized_factors_min_poly_mk hI hI' hx hx').symm J').prop\n  -- Then we just have to compare the multiplicities, which we already proved are equal.\n  have := multiplicity_factors_map_eq_multiplicity hI hI' hx hx' hJ\n  rw [multiplicity_eq_count_normalized_factors, multiplicity_eq_count_normalized_factors,\n    UniqueFactorizationMonoid.normalize_normalized_factor _ hJ, UniqueFactorizationMonoid.normalize_normalized_factor,\n    PartENat.natCast_inj] at this\n  refine' this.trans _\n  -- Get rid of the `map` by applying the equiv to both sides.\n  generalize hJ' : (normalized_factors_map_equiv_normalized_factors_min_poly_mk hI hI' hx hx') ⟨J, hJ⟩ = J'\n  have : ((normalized_factors_map_equiv_normalized_factors_min_poly_mk hI hI' hx hx').symm J' : Ideal S) = J := by\n    rw [← hJ', Equiv.symm_apply_apply _ _, Subtype.coe_mk]\n  subst this\n  -- Get rid of the `attach` by applying the subtype `coe` to both sides.\n  rw [Multiset.count_map_eq_count' fun f =>\n      ((normalized_factors_map_equiv_normalized_factors_min_poly_mk hI hI' hx hx').symm f : Ideal S),\n    Multiset.attach_count_eq_count_coe]\n  · exact subtype.coe_injective.comp (Equiv.injective _)\n  · exact (normalized_factors_map_equiv_normalized_factors_min_poly_mk hI hI' hx hx' _).prop\n  ·\n    exact\n      irreducible_of_normalized_factor _\n        (normalized_factors_map_equiv_normalized_factors_min_poly_mk hI hI' hx hx' _).prop\n  · exact Polynomial.map_monic_ne_zero (minpoly.monic hx')\n  · exact irreducible_of_normalized_factor _ hJ\n  · rwa [← bot_eq_zero, ne.def, map_eq_bot_iff_of_injective (NoZeroSMulDivisors.algebraMap_injective R S)]\n#align normalized_factors_ideal_map_eq_normalized_factors_min_poly_mk_map normalized_factors_ideal_map_eq_normalized_factors_min_poly_mk_map\n\n",
 "multiplicity_factors_map_eq_multiplicity":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n--show that `I * S` ≠ ⊥\n--show that the ideal spanned by `(minpoly R pb.gen) mod I` is non-zero\n/-- The second half of the **Kummer-Dedekind Theorem** in the monogenic case, stating that the\n    bijection `factors_equiv'` defined in the first half preserves multiplicities. -/\ntheorem multiplicity_factors_map_eq_multiplicity (hI : IsMaximal I) (hI' : I ≠ «expr⊥»)\n    (hx : «expr ⊔ » ((conductor R x).comap (algebraMap R S)) I = «expr⊤») (hx' : is_integral R x) {J : Ideal S}\n    (hJ : J ∈ normalizedFactors (I.map (algebraMap R S))) :\n    multiplicity J (I.map (algebraMap R S)) =\n      multiplicity (↑(normalized_factors_map_equiv_normalized_factors_min_poly_mk hI hI' hx hx' ⟨J, hJ⟩))\n        (map I.quotient.mk (minpoly R x)) :=\n  by\n  rw [normalized_factors_map_equiv_normalized_factors_min_poly_mk, Equiv.coe_trans, Function.comp_apply,\n    multiplicity_normalized_factors_equiv_span_normalized_factors_symm_eq_multiplicity,\n    normalized_factors_equiv_of_quot_equiv_multiplicity_eq_multiplicity]\n#align multiplicity_factors_map_eq_multiplicity multiplicity_factors_map_eq_multiplicity\n\n",
 "mem_conductor_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr < >» -/\ntheorem mem_conductor_iff {y : S} : y ∈ conductor R x ↔ ∀ b : S, y * b ∈ «expr < >» R x :=\n  ⟨fun h => h, fun h => h⟩\n#align mem_conductor_iff mem_conductor_iff\n\n",
 "irreducible_map_of_irreducible_minpoly":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem ideal.irreducible_map_of_irreducible_minpoly (hI : IsMaximal I) (hI' : I ≠ «expr⊥»)\n    (hx : «expr ⊔ » ((conductor R x).comap (algebraMap R S)) I = «expr⊤») (hx' : is_integral R x)\n    (hf : Irreducible (map I.quotient.mk (minpoly R x))) : Irreducible (I.map (algebraMap R S)) :=\n  by\n  have mem_norm_factors :\n    normalize (map I.quotient.mk (minpoly R x)) ∈ normalized_factors (map I.quotient.mk (minpoly R x)) := by\n    simp [normalized_factors_irreducible hf]\n  suffices ∃ y, normalized_factors (I.map (algebraMap R S)) = {y}\n    by\n    obtain ⟨y, hy⟩ := this\n    have h :=\n      normalized_factors_prod\n        (show I.map (algebraMap R S) ≠ 0 by\n          rwa [← bot_eq_zero, ne.def, map_eq_bot_iff_of_injective (NoZeroSMulDivisors.algebraMap_injective R S)])\n    rw [associated_iff_eq, hy, Multiset.prod_singleton] at h\n    rw [← h]\n    exact irreducible_of_normalized_factor y (show y ∈ normalized_factors (I.map (algebraMap R S)) by simp [hy])\n  rw [normalized_factors_ideal_map_eq_normalized_factors_min_poly_mk_map hI hI' hx hx']\n  use\n    ((normalized_factors_map_equiv_normalized_factors_min_poly_mk hI hI' hx hx').symm\n        ⟨normalize (map I.quotient.mk (minpoly R x)), mem_norm_factors⟩ :\n      Ideal S)\n  rw [Multiset.map_eq_singleton]\n  use ⟨normalize (map I.quotient.mk (minpoly R x)), mem_norm_factors⟩\n  refine' ⟨_, rfl⟩\n  apply Multiset.map_injective Subtype.coe_injective\n  rw [Multiset.attach_map_val, Multiset.map_singleton, Subtype.coe_mk]\n  exact normalized_factors_irreducible hf\n#align ideal.irreducible_map_of_irreducible_minpoly ideal.irreducible_map_of_irreducible_minpoly\n\n",
 "conductor_subset_adjoin":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr < >» -/\ntheorem conductor_subset_adjoin : (conductor R x : Set S) ⊆ «expr < >» R x := fun y hy => by\n  simpa only [mul_one] using hy 1\n#align conductor_subset_adjoin conductor_subset_adjoin\n\n",
 "conductor_eq_top_of_power_basis":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem conductor_eq_top_of_power_basis (pb : power_basis R S) : conductor R pb.gen = «expr⊤» :=\n  conductor_eq_top_of_adjoin_eq_top pb.adjoin_gen_eq_top\n#align conductor_eq_top_of_power_basis conductor_eq_top_of_power_basis\n\n",
 "conductor_eq_top_of_adjoin_eq_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr < >» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem conductor_eq_top_of_adjoin_eq_top (h : «expr < >» R x = «expr⊤») : conductor R x = «expr⊤» := by\n  simp only [Ideal.eq_top_iff_one, mem_conductor_iff, h, mem_top, forall_const]\n#align conductor_eq_top_of_adjoin_eq_top conductor_eq_top_of_adjoin_eq_top\n\n",
 "conductor_eq_of_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr < >» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr < >» -/\n/-\nCopyright (c) 2021 Anne Baanen. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Anne Baanen, Paul Lezeau\n-/\ntheorem conductor_eq_of_eq {y : S} (h : («expr < >» R x : Set S) = «expr < >» R y) : conductor R x = conductor R y :=\n  Ideal.ext fun a => forall_congr' fun b => Set.ext_iff.mp h _\n#align conductor_eq_of_eq conductor_eq_of_eq\n\n",
 "comap_map_eq_map_adjoin_of_coprime_conductor":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr < >» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr < >» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr < >» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr < >» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr < >» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr < >» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr < >» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr < >» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr < >» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr < >» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr < >» -/\n/-- A technical result telling us that `(I * S) ∩ R<x> = I * R<x>` for any ideal `I` of `R`. -/\ntheorem comap_map_eq_map_adjoin_of_coprime_conductor\n    (hx : «expr ⊔ » ((conductor R x).comap (algebraMap R S)) I = «expr⊤»)\n    (h_alg : function.injective (algebraMap («expr < >» R x) S)) :\n    (I.map (algebraMap R S)).comap (algebraMap («expr < >» R x) S) = I.map (algebraMap R («expr < >» R x)) :=\n  by\n  apply le_antisymm\n  · -- This is adapted from [Neukirch1992]. Let `C = (conductor R x)`. The idea of the proof\n    -- is that since `I` and `C ∩ R` are coprime, we have\n    -- `(I * S) ∩ R<x> ⊆ (I + C) * ((I * S) ∩ R<x>) ⊆ I * R<x> + I * C * S ⊆ I * R<x>`.\n    intro y hy\n    obtain ⟨z, hz⟩ := y\n    obtain ⟨p, hp, q, hq, hpq⟩ := submodule.mem_sup.mp ((Ideal.eq_top_iff_one _).mp hx)\n    have temp : algebraMap R S p * z + algebraMap R S q * z = z := by\n      simp only [← add_mul, ← RingHom.map_add (algebraMap R S), hpq, map_one, one_mul]\n    suffices\n      z ∈ «expr '' » (algebraMap («expr < >» R x) S) (I.map (algebraMap R («expr < >» R x))) ↔\n        (⟨z, hz⟩ : «expr < >» R x) ∈ I.map (algebraMap R («expr < >» R x))\n      by\n      rw [← this, ← temp]\n      obtain ⟨a, ha⟩ :=\n        (Set.mem_image _ _ _).mp\n          (prod_mem_ideal_map_of_mem_conductor hp (show z ∈ I.map (algebraMap R S) by rwa [Ideal.mem_comap] at hy))\n      use a + algebraMap R («expr < >» R x) q * ⟨z, hz⟩\n      refine'\n        ⟨Ideal.add_mem (I.map (algebraMap R («expr < >» R x))) ha.left _, by\n          simpa only [ha.right, map_add, AlgHom.map_mul, add_right_inj] ⟩\n      rw [mul_comm]\n      exact Ideal.mul_mem_left (I.map (algebraMap R («expr < >» R x))) _ (Ideal.mem_map_of_mem _ hq)\n    refine' ⟨fun h => _, fun h => (Set.mem_image _ _ _).mpr (exists.intro ⟨z, hz⟩ ⟨by simp [h], rfl⟩)⟩\n    · obtain ⟨x₁, hx₁, hx₂⟩ := (Set.mem_image _ _ _).mp h\n      have : x₁ = ⟨z, hz⟩ := by\n        apply h_alg\n        simpa [hx₂]\n      rwa [← this]\n  · -- The converse inclusion is trivial\n    have : algebraMap R S = (algebraMap _ S).comp (algebraMap R («expr < >» R x)) :=\n      by\n      ext\n      rfl\n    rw [this, ← Ideal.map_map]\n    apply Ideal.le_comap_map\n#align comap_map_eq_map_adjoin_of_coprime_conductor comap_map_eq_map_adjoin_of_coprime_conductor\n\n"}