{"quot_adjoin_equiv_quot_map_apply_mk":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr < >» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr < >» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr < >» -/\n--the kernel of the map is clearly `(I * S) ∩ R<x>`. To get injectivity, we need to show that\n--this is contained in `I * R<x>`, which is the content of the previous lemma.\n-- Surjectivity follows from the surjectivity of the canonical map `R<x> → S ⧸ (I * S)`,\n-- which in turn follows from the fact that `I * S + (conductor R x) = S`.\n@[simp]\ntheorem quot_adjoin_equiv_quot_map_apply_mk (hx : «expr ⊔ » ((conductor R x).comap (algebra_map R S)) I = «expr⊤»)\n    (h_alg : function.injective (algebra_map («expr < >» R x) S)) (a : «expr < >» R x) :\n    quot_adjoin_equiv_quot_map hx h_alg ((I.map (algebra_map R («expr < >» R x))) a) = (I.map (algebra_map R S)) ↑a :=\n  rfl\n#align quot_adjoin_equiv_quot_map_apply_mk quot_adjoin_equiv_quot_map_apply_mk\n\n",
 "prod_mem_ideal_map_of_mem_conductor":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr < >» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr < >» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr < >» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr < >» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr < >» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr < >» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr < >» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr < >» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr < >» -/\n/-- This technical lemma tell us that if `C` is the conductor of `R<x>` and `I` is an ideal of `R`\n  then `p * (I * S) ⊆ I * R<x>` for any `p` in `C ∩ R` -/\ntheorem prod_mem_ideal_map_of_mem_conductor {p : R} {z : S} (hp : p ∈ ideal.comap (algebra_map R S) (conductor R x))\n    (hz' : z ∈ I.map (algebra_map R S)) :\n    algebra_map R S p * z ∈ «expr '' » (algebra_map («expr < >» R x) S) ↑(I.map (algebra_map R («expr < >» R x))) :=\n  by\n  rw [ideal.map, ideal.span, finsupp.mem_span_image_iff_total] at hz'\n  obtain ⟨l, H, H'⟩ := hz'\n  rw [finsupp.total_apply] at H'\n  rw [← H', mul_comm, finsupp.sum_mul]\n  have lem :\n    ∀ {a : R},\n      a ∈ I →\n        «expr • » (l a) (algebra_map R S a) * algebra_map R S p ∈\n          «expr '' » (algebra_map («expr < >» R x) S) (I.map (algebra_map R («expr < >» R x))) :=\n    by\n    intro a ha\n    rw [algebra.id.smul_eq_mul, mul_assoc, mul_comm, mul_assoc, Set.mem_image]\n    refine'\n      exists.intro\n        (algebra_map R («expr < >» R x) a *\n          ⟨l a * algebra_map R S p, show l a * algebra_map R S p ∈ «expr < >» R x from _⟩)\n        _\n    · rw [mul_comm]\n      exact mem_conductor_iff.mp (ideal.mem_comap.mp hp) _\n    refine' ⟨_, by simpa only [RingHom.map_mul, mul_comm (algebra_map R S p) (l a)] ⟩\n    rw [mul_comm]\n    apply ideal.mul_mem_left (I.map (algebra_map R («expr < >» R x))) _ (ideal.mem_map_of_mem _ ha)\n  refine'\n    finset.sum_induction _\n      (fun u => u ∈ «expr '' » (algebra_map («expr < >» R x) S) (I.map (algebra_map R («expr < >» R x)))) (fun a b => _)\n      _ _\n  rintro ⟨z, hz, rfl⟩ ⟨y, hy, rfl⟩\n  rw [← RingHom.map_add]\n  exact ⟨z + y, ideal.add_mem _ (set_like.mem_coe.mp hz) hy, rfl⟩\n  · refine' ⟨0, set_like.mem_coe.mpr <| ideal.zero_mem _, RingHom.map_zero _⟩\n  · intro y hy\n    exact lem ((finsupp.mem_supported _ l).mp H hy)\n#align prod_mem_ideal_map_of_mem_conductor prod_mem_ideal_map_of_mem_conductor\n\n",
 "normalized_factors_ideal_map_eq_normalized_factors_min_poly_mk_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/-- The **Kummer-Dedekind Theorem**. -/\ntheorem normalized_factors_ideal_map_eq_normalized_factors_min_poly_mk_map (hI : is_maximal I) (hI' : I ≠ «expr⊥») :\n    normalized_factors (I.map (algebra_map R S)) =\n      Multiset.map (fun f => ((normalized_factors_map_equiv_normalized_factors_min_poly_mk pb hI hI').symm f : ideal S))\n        (normalized_factors (polynomial.map I (minpoly R pb.gen))).attach :=\n  by\n  ext J\n  -- WLOG, assume J is a normalized factor\n  by_cases hJ : J ∈ normalized_factors (I.map (algebra_map R S))\n  swap\n  · rw [multiset.count_eq_zero.mpr hJ, eq_comm, Multiset.count_eq_zero, Multiset.mem_map]\n    simp only [Multiset.mem_attach, true_and_iff, not_exists]\n    rintro J' rfl\n    exact hJ ((normalized_factors_map_equiv_normalized_factors_min_poly_mk pb hI hI').symm J').prop\n  -- Then we just have to compare the multiplicities, which we already proved are equal.\n  have := multiplicity_factors_map_eq_multiplicity pb hI hI' hJ\n  rw [multiplicity_eq_count_normalized_factors, multiplicity_eq_count_normalized_factors,\n    unique_factorization_monoid.normalize_normalized_factor _ hJ,\n    unique_factorization_monoid.normalize_normalized_factor, part_enat.coe_inj] at this\n  refine' this.trans _\n  -- Get rid of the `map` by applying the equiv to both sides.\n  generalize hJ' : (normalized_factors_map_equiv_normalized_factors_min_poly_mk pb hI hI') ⟨J, hJ⟩ = J'\n  have : ((normalized_factors_map_equiv_normalized_factors_min_poly_mk pb hI hI').symm J' : ideal S) = J := by\n    rw [← hJ', equiv.symm_apply_apply _ _, subtype.coe_mk]\n  subst this\n  -- Get rid of the `attach` by applying the subtype `coe` to both sides.\n  rw [Multiset.count_map_eq_count' fun f =>\n      ((normalized_factors_map_equiv_normalized_factors_min_poly_mk pb hI hI').symm f : ideal S),\n    Multiset.attach_count_eq_count_coe]\n  · exact subtype.coe_injective.comp (Equiv.injective _)\n  · exact (normalized_factors_map_equiv_normalized_factors_min_poly_mk pb hI hI' _).prop\n  ·\n    exact\n      irreducible_of_normalized_factor _ (normalized_factors_map_equiv_normalized_factors_min_poly_mk pb hI hI' _).prop\n  · exact polynomial.map_monic_ne_zero (minpoly.monic pb.is_integral_gen)\n  · exact irreducible_of_normalized_factor _ hJ\n  · rwa [← bot_eq_zero, ne.def, map_eq_bot_iff_of_injective pb.basis.algebra_map_injective]\n#align\n  normalized_factors_ideal_map_eq_normalized_factors_min_poly_mk_map normalized_factors_ideal_map_eq_normalized_factors_min_poly_mk_map\n\n",
 "multiplicity_factors_map_eq_multiplicity":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n--show that `I * S` ≠ ⊥\n--show that the ideal spanned by `(minpoly R pb.gen) mod I` is non-zero\n/-- The second half of the **Kummer-Dedekind Theorem** in the monogenic case, stating that the\n    bijection `factors_equiv'` defined in the first half preserves multiplicities. -/\ntheorem multiplicity_factors_map_eq_multiplicity (hI : is_maximal I) (hI' : I ≠ «expr⊥») {J : ideal S}\n    (hJ : J ∈ normalized_factors (I.map (algebra_map R S))) :\n    multiplicity J (I.map (algebra_map R S)) =\n      multiplicity (↑(normalized_factors_map_equiv_normalized_factors_min_poly_mk pb hI hI' ⟨J, hJ⟩))\n        (map I (minpoly R pb.gen)) :=\n  by\n  rw [normalized_factors_map_equiv_normalized_factors_min_poly_mk, equiv.coe_trans, Function.comp_apply,\n    multiplicity_normalized_factors_equiv_span_normalized_factors_symm_eq_multiplicity,\n    normalized_factors_equiv_of_quot_equiv_multiplicity_eq_multiplicity]\n#align multiplicity_factors_map_eq_multiplicity multiplicity_factors_map_eq_multiplicity\n\n",
 "mem_conductor_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr < >» -/\ntheorem mem_conductor_iff {y : S} : y ∈ conductor R x ↔ ∀ b : S, y * b ∈ «expr < >» R x :=\n  ⟨fun h => h, fun h => h⟩\n#align mem_conductor_iff mem_conductor_iff\n\n",
 "irreducible_map_of_irreducible_minpoly":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem ideal.irreducible_map_of_irreducible_minpoly (hI : is_maximal I) (hI' : I ≠ «expr⊥»)\n    (hf : Irreducible (map I (minpoly R pb.gen))) : Irreducible (I.map (algebra_map R S)) :=\n  by\n  have mem_norm_factors : normalize (map I (minpoly R pb.gen)) ∈ normalized_factors (map I (minpoly R pb.gen)) := by\n    simp [normalized_factors_irreducible hf]\n  suffices ∃ x, normalized_factors (I.map (algebra_map R S)) = {x}\n    by\n    obtain ⟨x, hx⟩ := this\n    have h :=\n      normalized_factors_prod\n        (show I.map (algebra_map R S) ≠ 0 by\n          rwa [← bot_eq_zero, ne.def, map_eq_bot_iff_of_injective pb.basis.algebra_map_injective])\n    rw [associated_iff_eq, hx, Multiset.prod_singleton] at h\n    rw [← h]\n    exact irreducible_of_normalized_factor x (show x ∈ normalized_factors (I.map (algebra_map R S)) by simp [hx])\n  rw [normalized_factors_ideal_map_eq_normalized_factors_min_poly_mk_map pb hI hI']\n  use\n    ((normalized_factors_map_equiv_normalized_factors_min_poly_mk pb hI hI').symm\n        ⟨normalize (map I (minpoly R pb.gen)), mem_norm_factors⟩ :\n      ideal S)\n  rw [Multiset.map_eq_singleton]\n  use ⟨normalize (map I (minpoly R pb.gen)), mem_norm_factors⟩\n  refine' ⟨_, rfl⟩\n  apply Multiset.map_injective subtype.coe_injective\n  rw [Multiset.attach_map_val, Multiset.map_singleton, subtype.coe_mk]\n  exact normalized_factors_irreducible hf\n#align ideal.irreducible_map_of_irreducible_minpoly ideal.irreducible_map_of_irreducible_minpoly\n\n",
 "conductor_subset_adjoin":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr < >» -/\ntheorem conductor_subset_adjoin : (conductor R x : set S) ⊆ «expr < >» R x := fun y hy => by\n  simpa only [mul_one] using hy 1\n#align conductor_subset_adjoin conductor_subset_adjoin\n\n",
 "conductor_eq_of_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr < >» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr < >» -/\n/-\nCopyright (c) 2021 Anne Baanen. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Anne Baanen, Paul Lezeau\n-/\ntheorem conductor_eq_of_eq {y : S} (h : («expr < >» R x : set S) = «expr < >» R y) : conductor R x = conductor R y :=\n  ideal.ext fun a => forall_congr' fun b => Set.ext_iff.mp h _\n#align conductor_eq_of_eq conductor_eq_of_eq\n\n",
 "comap_map_eq_map_adjoin_of_coprime_conductor":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr < >» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr < >» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr < >» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr < >» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr < >» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr < >» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr < >» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr < >» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr < >» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr < >» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr < >» -/\n/-- A technical result telling us that `(I * S) ∩ R<x> = I * R<x>` for any ideal `I` of `R`. -/\ntheorem comap_map_eq_map_adjoin_of_coprime_conductor\n    (hx : «expr ⊔ » ((conductor R x).comap (algebra_map R S)) I = «expr⊤»)\n    (h_alg : function.injective (algebra_map («expr < >» R x) S)) :\n    (I.map (algebra_map R S)).comap (algebra_map («expr < >» R x) S) = I.map (algebra_map R («expr < >» R x)) :=\n  by\n  apply le_antisymm\n  · -- This is adapted from [Neukirch1992]. Let `C = (conductor R x)`. The idea of the proof\n    -- is that since `I` and `C ∩ R` are coprime, we have\n    -- `(I * S) ∩ R<x> ⊆ (I + C) * ((I * S) ∩ R<x>) ⊆ I * R<x> + I * C * S ⊆ I * R<x>`.\n    intro y hy\n    obtain ⟨z, hz⟩ := y\n    obtain ⟨p, hp, q, hq, hpq⟩ := submodule.mem_sup.mp ((ideal.eq_top_iff_one _).mp hx)\n    have temp : algebra_map R S p * z + algebra_map R S q * z = z := by\n      simp only [← add_mul, ← RingHom.map_add (algebra_map R S), hpq, map_one, one_mul]\n    suffices\n      z ∈ «expr '' » (algebra_map («expr < >» R x) S) (I.map (algebra_map R («expr < >» R x))) ↔\n        (⟨z, hz⟩ : «expr < >» R x) ∈ I.map (algebra_map R («expr < >» R x))\n      by\n      rw [← this, ← temp]\n      obtain ⟨a, ha⟩ :=\n        (Set.mem_image _ _ _).mp\n          (prod_mem_ideal_map_of_mem_conductor hp (show z ∈ I.map (algebra_map R S) by rwa [ideal.mem_comap] at hy))\n      use a + algebra_map R («expr < >» R x) q * ⟨z, hz⟩\n      refine'\n        ⟨ideal.add_mem (I.map (algebra_map R («expr < >» R x))) ha.left _, by\n          simpa only [ha.right, map_add, alg_hom.map_mul, add_right_inj] ⟩\n      rw [mul_comm]\n      exact ideal.mul_mem_left (I.map (algebra_map R («expr < >» R x))) _ (ideal.mem_map_of_mem _ hq)\n    refine' ⟨fun h => _, fun h => (Set.mem_image _ _ _).mpr (exists.intro ⟨z, hz⟩ ⟨by simp [h], rfl⟩)⟩\n    · obtain ⟨x₁, hx₁, hx₂⟩ := (Set.mem_image _ _ _).mp h\n      have : x₁ = ⟨z, hz⟩ := by\n        apply h_alg\n        simpa [hx₂]\n      rwa [← this]\n  · -- The converse inclusion is trivial\n    have : algebra_map R S = (algebra_map _ S).comp (algebra_map R («expr < >» R x)) :=\n      by\n      ext\n      rfl\n    rw [this, ← ideal.map_map]\n    apply ideal.le_comap_map\n#align comap_map_eq_map_adjoin_of_coprime_conductor comap_map_eq_map_adjoin_of_coprime_conductor\n\n"}