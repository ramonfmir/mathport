{"exists_partition_int":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⌊ ⌋» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⌊ ⌋» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⌈ ⌉₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-\nCopyright (c) 2021 Anne Baanen. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Anne Baanen\n-/\n/-- We can partition a finite family into `partition_card ε` sets, such that the remainders\nin each set are close together. -/\ntheorem exists_partition_int (n : ℕ) {ε : exprℝ} (hε : 0 < ε) {b : ℤ} (hb : b ≠ 0) (A : Fin n → ℤ) :\n    ∃ t : Fin n → Fin («expr⌈ ⌉₊» (1 / ε)), ∀ i₀ i₁, t i₀ = t i₁ → ↑(abs (A i₁ % b - A i₀ % b)) < «expr • » (abs b) ε :=\n  by\n  have hb' : (0 : exprℝ) < ↑(abs b) := int.cast_pos.mpr (abs_pos.mpr hb)\n  have hbε : 0 < «expr • » (abs b) ε := by\n    rw [Algebra.smul_def]\n    exact mul_pos hb' hε\n  have hfloor : ∀ i, 0 ≤ floor ((A i % b : ℤ) / «expr • » (abs b) ε : exprℝ) :=\n    by\n    intro i\n    exact floor_nonneg.mpr (div_nonneg (cast_nonneg.mpr (mod_nonneg _ hb)) hbε.le)\n  refine' ⟨fun i => ⟨nat_abs (floor ((A i % b : ℤ) / «expr • » (abs b) ε : exprℝ)), _⟩, _⟩\n  · rw [← coe_nat_lt, nat_abs_of_nonneg (hfloor i), floor_lt]\n    apply lt_of_lt_of_le _ (Nat.le_ceil _)\n    rw [Algebra.smul_def, eq_intCast, ← div_div, div_lt_div_right hε, div_lt_iff hb', one_mul, cast_lt]\n    exact Int.emod_lt _ hb\n  intro i₀ i₁ hi\n  have hi :\n    ((«expr⌊ ⌋» (↑(A i₀ % b) / «expr • » (abs b) ε)).nat_abs : ℤ) =\n      («expr⌊ ⌋» (↑(A i₁ % b) / «expr • » (abs b) ε)).nat_abs :=\n    congr_arg (coe : ℕ → ℤ) (fin.mk_eq_mk.mp hi)\n  rw [nat_abs_of_nonneg (hfloor i₀), nat_abs_of_nonneg (hfloor i₁)] at hi\n  have hi := abs_sub_lt_one_of_floor_eq_floor hi\n  rw [abs_sub_comm, ← sub_div, abs_div, abs_of_nonneg hbε.le, div_lt_iff hbε, one_mul] at hi\n  rwa [Int.cast_abs, Int.cast_sub]\n#align exists_partition_int exists_partition_int\n\n"}