{"exists_partition_polynomial_aux":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⌈ ⌉₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- A slightly stronger version of `exists_partition` on which we perform induction on `n`:\nfor all `ε > 0`, we can partition the remainders of any family of polynomials `A`\ninto equivalence classes, where the equivalence(!) relation is \"closer than `ε`\". -/\ntheorem exists_partition_polynomial_aux (n : ℕ) {ε : exprℝ} (hε : 0 < ε) {b : polynomial Fq} (hb : b ≠ 0)\n    (A : Fin n → polynomial Fq) :\n    ∃ t : Fin n → Fin (Fintype.card Fq ^ «expr⌈ ⌉₊» (-log ε / log (Fintype.card Fq))),\n      ∀ i₀ i₁ : Fin n, t i₀ = t i₁ ↔ (cardPowDegree (A i₁ % b - A i₀ % b) : exprℝ) < «expr • » (cardPowDegree b) ε :=\n  by\n  have hbε : 0 < «expr • » (card_pow_degree b) ε :=\n    by\n    rw [Algebra.smul_def, eq_intCast]\n    exact mul_pos (int.cast_pos.mpr (AbsoluteValue.pos _ hb)) hε\n  -- We go by induction on the size `A`.\n  induction' n with n ih\n  · refine' ⟨finZeroElim, finZeroElim⟩\n  -- Show `anti_archimedean` also holds for real distances.\n  have anti_archim' :\n    ∀ {i j k} {ε : exprℝ},\n      (card_pow_degree (A i % b - A j % b) : exprℝ) < ε →\n        (card_pow_degree (A j % b - A k % b) : exprℝ) < ε → (card_pow_degree (A i % b - A k % b) : exprℝ) < ε :=\n    by\n    intro i j k ε\n    simp_rw [← Int.lt_ceil]\n    exact card_pow_degree_anti_archimedean\n  obtain ⟨t', ht'⟩ := ih (Fin.tail A)\n  -- We got rid of `A 0`, so determine the index `j` of the partition we'll re-add it to.\n  rsuffices ⟨j, hj⟩ :\n    ∃ j, ∀ i, t' i = j ↔ (card_pow_degree (A 0 % b - A i.succ % b) : exprℝ) < «expr • » (card_pow_degree b) ε\n  · refine' ⟨Fin.cons j t', fun i₀ i₁ => _⟩\n    refine' Fin.cases _ (fun i₀ => _) i₀ <;> refine' Fin.cases _ (fun i₁ => _) i₁\n    · simpa using hbε\n    · rw [Fin.cons_succ, Fin.cons_zero, eq_comm, AbsoluteValue.map_sub]\n      exact hj i₁\n    · rw [Fin.cons_succ, Fin.cons_zero]\n      exact hj i₀\n    · rw [Fin.cons_succ, Fin.cons_succ]\n      exact ht' i₀ i₁\n  -- `exists_approx_polynomial` guarantees that we can insert `A 0` into some partition `j`,\n  -- but not that `j` is uniquely defined (which is needed to keep the induction going).\n  obtain ⟨j, hj⟩ :\n    ∃ j, ∀ i : Fin n, t' i = j → (card_pow_degree (A 0 % b - A i.succ % b) : exprℝ) < «expr • » (card_pow_degree b) ε :=\n    by\n    by_contra this\n    push_neg  at this\n    obtain ⟨j₀, j₁, j_ne, approx⟩ :=\n      exists_approx_polynomial hb hε (Fin.cons (A 0) fun j => A (fin.succ (Classical.choose (this j))))\n    revert j_ne approx\n    refine' Fin.cases _ (fun j₀ => _) j₀ <;> refine' Fin.cases (fun j_ne approx => _) (fun j₁ j_ne approx => _) j₁\n    · exact absurd rfl j_ne\n    · rw [Fin.cons_succ, Fin.cons_zero, ← not_le, AbsoluteValue.map_sub] at approx\n      have := (Classical.choose_spec (this j₁)).2\n      contradiction\n    · rw [Fin.cons_succ, Fin.cons_zero, ← not_le] at approx\n      have := (Classical.choose_spec (this j₀)).2\n      contradiction\n    · rw [Fin.cons_succ, Fin.cons_succ] at approx\n      rw [ne.def, Fin.succ_inj] at j_ne\n      have : j₀ = j₁ :=\n        (Classical.choose_spec (this j₀)).1.symm.trans\n          (((ht' (Classical.choose (this j₀)) (Classical.choose (this j₁))).mpr approx).trans\n            (Classical.choose_spec (this j₁)).1)\n      contradiction\n  -- However, if one of those partitions `j` is inhabited by some `i`, then this `j` works.\n  by_cases exists_nonempty_j :\n    ∃ j,\n      (∃ i, t' i = j) ∧\n        ∀ i, t' i = j → (card_pow_degree (A 0 % b - A i.succ % b) : exprℝ) < «expr • » (card_pow_degree b) ε\n  · obtain ⟨j, ⟨i, hi⟩, hj⟩ := exists_nonempty_j\n    refine' ⟨j, fun i' => ⟨hj i', fun hi' => trans ((ht' _ _).mpr _) hi⟩⟩\n    apply anti_archim' _ hi'\n    rw [AbsoluteValue.map_sub]\n    exact hj _ hi\n  -- And otherwise, we can just take any `j`, since those are empty.\n  refine' ⟨j, fun i => ⟨hj i, fun hi => _⟩⟩\n  have := exists_nonempty_j ⟨t' i, ⟨i, rfl⟩, fun i' hi' => anti_archim' hi ((ht' _ _).mp hi')⟩\n  contradiction\n#align exists_partition_polynomial_aux exists_partition_polynomial_aux\n\n",
 "exists_partition_polynomial":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⌈ ⌉₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- For all `ε > 0`, we can partition the remainders of any family of polynomials `A`\ninto classes, where all remainders in a class are close together. -/\ntheorem exists_partition_polynomial (n : ℕ) {ε : exprℝ} (hε : 0 < ε) {b : polynomial Fq} (hb : b ≠ 0)\n    (A : Fin n → polynomial Fq) :\n    ∃ t : Fin n → Fin (Fintype.card Fq ^ «expr⌈ ⌉₊» (-log ε / log (Fintype.card Fq))),\n      ∀ i₀ i₁ : Fin n, t i₀ = t i₁ → (cardPowDegree (A i₁ % b - A i₀ % b) : exprℝ) < «expr • » (cardPowDegree b) ε :=\n  by\n  obtain ⟨t, ht⟩ := exists_partition_polynomial_aux n hε hb A\n  exact ⟨t, fun i₀ i₁ hi => (ht i₀ i₁).mp hi⟩\n#align exists_partition_polynomial exists_partition_polynomial\n\n",
 "exists_eq_polynomial":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/-\nCopyright (c) 2021 Anne Baanen. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Anne Baanen\n-/\n/-- If `A` is a family of enough low-degree polynomials over a finite semiring, there is a\npair of equal elements in `A`. -/\ntheorem exists_eq_polynomial [Semiring Fq] {d : ℕ} {m : ℕ} (hm : Fintype.card Fq ^ d ≤ m) (b : polynomial Fq)\n    (hb : natDegree b ≤ d) (A : Fin m.succ → polynomial Fq) (hA : ∀ i, degree (A i) < degree b) :\n    ∃ i₀ i₁, i₀ ≠ i₁ ∧ A i₁ = A i₀ :=\n  by\n  -- Since there are > q^d elements of A, and only q^d choices for the highest `d` coefficients,\n  -- there must be two elements of A with the same coefficients at\n  -- `0`, ... `degree b - 1` ≤ `d - 1`.\n  -- In other words, the following map is not injective:\n  set f : Fin m.succ → Fin d → Fq := fun i j => (A i).coeff j\n  have : Fintype.card (Fin d → Fq) < Fintype.card (Fin m.succ) := by simpa using lt_of_le_of_lt hm (nat.lt_succ_self m)\n  -- Therefore, the differences have all coefficients higher than `deg b - d` equal.\n  obtain ⟨i₀, i₁, i_ne, i_eq⟩ := Fintype.exists_ne_map_eq_of_card_lt f this\n  use i₀, i₁, i_ne\n  ext j\n  -- The coefficients higher than `deg b` are the same because they are equal to 0.\n  by_cases hbj : degree b ≤ j\n  · rw [coeff_eq_zero_of_degree_lt (lt_of_lt_of_le (hA _) hbj), coeff_eq_zero_of_degree_lt (lt_of_lt_of_le (hA _) hbj)]\n  -- So we only need to look for the coefficients between `0` and `deg b`.\n  rw [not_le] at hbj\n  apply congr_fun i_eq.symm ⟨j, _⟩\n  exact lt_of_lt_of_le (coe_lt_degree.mp hbj) hb\n#align exists_eq_polynomial exists_eq_polynomial\n\n",
 "exists_approx_polynomial_aux":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/-- If `A` is a family of enough low-degree polynomials over a finite ring,\nthere is a pair of elements in `A` (with different indices but not necessarily\ndistinct), such that their difference has small degree. -/\ntheorem exists_approx_polynomial_aux [Ring Fq] {d : ℕ} {m : ℕ} (hm : Fintype.card Fq ^ d ≤ m) (b : polynomial Fq)\n    (A : Fin m.succ → polynomial Fq) (hA : ∀ i, degree (A i) < degree b) :\n    ∃ i₀ i₁, i₀ ≠ i₁ ∧ degree (A i₁ - A i₀) < ↑(natDegree b - d) :=\n  by\n  have hb : b ≠ 0 := by\n    rintro rfl\n    specialize hA 0\n    rw [degree_zero] at hA\n    exact not_lt_of_le bot_le hA\n  -- Since there are > q^d elements of A, and only q^d choices for the highest `d` coefficients,\n  -- there must be two elements of A with the same coefficients at\n  -- `degree b - 1`, ... `degree b - d`.\n  -- In other words, the following map is not injective:\n  set f : Fin m.succ → Fin d → Fq := fun i j => (A i).coeff (nat_degree b - j.succ)\n  have : Fintype.card (Fin d → Fq) < Fintype.card (Fin m.succ) := by simpa using lt_of_le_of_lt hm (nat.lt_succ_self m)\n  -- Therefore, the differences have all coefficients higher than `deg b - d` equal.\n  obtain ⟨i₀, i₁, i_ne, i_eq⟩ := Fintype.exists_ne_map_eq_of_card_lt f this\n  use i₀, i₁, i_ne\n  refine' (degree_lt_iff_coeff_zero _ _).mpr fun j hj => _\n  -- The coefficients higher than `deg b` are the same because they are equal to 0.\n  by_cases hbj : degree b ≤ j\n  · refine' coeff_eq_zero_of_degree_lt (lt_of_lt_of_le _ hbj)\n    exact lt_of_le_of_lt (degree_sub_le _ _) (max_lt (hA _) (hA _))\n  -- So we only need to look for the coefficients between `deg b - d` and `deg b`.\n  rw [coeff_sub, sub_eq_zero]\n  rw [not_le, degree_eq_nat_degree hb, WithBot.coe_lt_coe] at hbj\n  have hj : nat_degree b - j.succ < d := by\n    by_cases hd : nat_degree b < d\n    · exact lt_of_le_of_lt tsub_le_self hd\n    · rw [not_lt] at hd\n      have := lt_of_le_of_lt hj (nat.lt_succ_self j)\n      rwa [tsub_lt_iff_tsub_lt hd hbj] at this\n  have : j = b.nat_degree - (nat_degree b - j.succ).succ := by\n    rw [← nat.succ_sub hbj, nat.succ_sub_succ, tsub_tsub_cancel_of_le hbj.le]\n  convert congr_fun i_eq.symm ⟨nat_degree b - j.succ, hj⟩\n#align exists_approx_polynomial_aux exists_approx_polynomial_aux\n\n",
 "exists_approx_polynomial":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⌈ ⌉₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⌈ ⌉₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- If `A` is a family of enough low-degree polynomials over a finite field,\nthere is a pair of elements in `A` (with different indices but not necessarily\ndistinct), such that the difference of their remainders is close together. -/\ntheorem exists_approx_polynomial {b : polynomial Fq} (hb : b ≠ 0) {ε : exprℝ} (hε : 0 < ε)\n    (A : Fin (Fintype.card Fq ^ «expr⌈ ⌉₊» (-log ε / log (Fintype.card Fq))).succ → polynomial Fq) :\n    ∃ i₀ i₁, i₀ ≠ i₁ ∧ (cardPowDegree (A i₁ % b - A i₀ % b) : exprℝ) < «expr • » (cardPowDegree b) ε :=\n  by\n  have hbε : 0 < «expr • » (card_pow_degree b) ε :=\n    by\n    rw [Algebra.smul_def, eq_intCast]\n    exact mul_pos (int.cast_pos.mpr (AbsoluteValue.pos _ hb)) hε\n  have one_lt_q : 1 < Fintype.card Fq := Fintype.one_lt_card\n  have one_lt_q' : (1 : exprℝ) < Fintype.card Fq := by assumption_mod_cast\n  have q_pos : 0 < Fintype.card Fq := by linarith\n  have q_pos' : (0 : exprℝ) < Fintype.card Fq := by assumption_mod_cast\n  -- If `b` is already small enough, then the remainders are equal and we are done.\n  by_cases le_b : b.nat_degree ≤ «expr⌈ ⌉₊» (-log ε / log (Fintype.card Fq))\n  · obtain ⟨i₀, i₁, i_ne, mod_eq⟩ :=\n      exists_eq_polynomial le_rfl b le_b (fun i => A i % b) fun i => EuclideanDomain.mod_lt (A i) hb\n    refine' ⟨i₀, i₁, i_ne, _⟩\n    simp only at mod_eq\n    rwa [mod_eq, sub_self, map_zero, Int.cast_zero]\n  -- Otherwise, it suffices to choose two elements whose difference is of small enough degree.\n  rw [not_le] at le_b\n  obtain ⟨i₀, i₁, i_ne, deg_lt⟩ :=\n    exists_approx_polynomial_aux le_rfl b (fun i => A i % b) fun i => EuclideanDomain.mod_lt (A i) hb\n  simp only at deg_lt\n  use i₀, i₁, i_ne\n  -- Again, if the remainders are equal we are done.\n  by_cases h : A i₁ % b = A i₀ % b\n  · rwa [h, sub_self, map_zero, Int.cast_zero]\n  have h' : A i₁ % b - A i₀ % b ≠ 0 := mt sub_eq_zero.mp h\n  -- If the remainders are not equal, we'll show their difference is of small degree.\n  -- In particular, we'll show the degree is less than the following:\n  suffices (nat_degree (A i₁ % b - A i₀ % b) : exprℝ) < b.nat_degree + log ε / log (Fintype.card Fq) by\n    rwa [← real.log_lt_log_iff (int.cast_pos.mpr (card_pow_degree.pos h')) hbε, card_pow_degree_nonzero _ h',\n      card_pow_degree_nonzero _ hb, Algebra.smul_def, eq_intCast, Int.cast_pow, Int.cast_ofNat, Int.cast_pow,\n      Int.cast_ofNat, log_mul (pow_ne_zero _ q_pos'.ne') hε.ne', ← rpow_nat_cast, ← rpow_nat_cast, log_rpow q_pos',\n      log_rpow q_pos', ← lt_div_iff (log_pos one_lt_q'), add_div, mul_div_cancel _ (log_pos one_lt_q').ne']\n  -- And that result follows from manipulating the result from `exists_approx_polynomial_aux`\n  -- to turn the `-⌈-stuff⌉₊` into `+ stuff`.\n  refine' lt_of_lt_of_le (nat.cast_lt.mpr (with_bot.coe_lt_coe.mp _)) _\n  swap\n  · convert deg_lt\n    rw [degree_eq_nat_degree h']\n  rw [← sub_neg_eq_add, neg_div]\n  refine' le_trans _ (sub_le_sub_left (Nat.le_ceil _) (b.nat_degree : exprℝ))\n  rw [← neg_div]\n  exact le_of_eq (Nat.cast_sub le_b.le)\n#align exists_approx_polynomial exists_approx_polynomial\n\n",
 "card_pow_degree_anti_archimedean":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/-- If `x` is close to `y` and `y` is close to `z`, then `x` and `z` are at least as close. -/\ntheorem card_pow_degree_anti_archimedean {x y z : polynomial Fq} {a : ℤ} (hxy : cardPowDegree (x - y) < a)\n    (hyz : cardPowDegree (y - z) < a) : cardPowDegree (x - z) < a :=\n  by\n  have ha : 0 < a := lt_of_le_of_lt (AbsoluteValue.nonneg _ _) hxy\n  by_cases hxy' : x = y\n  · rwa [hxy']\n  by_cases hyz' : y = z\n  · rwa [← hyz']\n  by_cases hxz' : x = z\n  · rwa [hxz', sub_self, map_zero]\n  rw [← ne.def, ← sub_ne_zero] at hxy' hyz' hxz'\n  refine' lt_of_le_of_lt _ (max_lt hxy hyz)\n  rw [card_pow_degree_nonzero _ hxz', card_pow_degree_nonzero _ hxy', card_pow_degree_nonzero _ hyz']\n  have : (1 : ℤ) ≤ Fintype.card Fq := by exact_mod_cast (@Fintype.one_lt_card Fq _ _).le\n  simp only [Int.cast_pow, Int.cast_ofNat, le_max_iff]\n  refine' Or.imp (pow_le_pow this) (pow_le_pow this) _\n  rw [nat_degree_le_iff_degree_le, nat_degree_le_iff_degree_le, ← le_max_iff, ← degree_eq_nat_degree hxy', ←\n    degree_eq_nat_degree hyz']\n  convert degree_add_le (x - y) (y - z) using 2\n  exact (sub_add_sub_cancel _ _ _).symm\n#align card_pow_degree_anti_archimedean card_pow_degree_anti_archimedean\n\n"}