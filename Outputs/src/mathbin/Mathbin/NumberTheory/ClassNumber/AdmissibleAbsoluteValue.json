{"exists_partition":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-\nCopyright (c) 2021 Anne Baanen. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Anne Baanen\n-/\n/-- For all `ε > 0` and finite families `A`, we can partition the remainders of `A` mod `b`\ninto `abv.card ε` sets, such that all elements in each part of remainders are close together. -/\ntheorem exists_partition {ι : Type _} [Fintype ι] {ε : exprℝ} (hε : 0 < ε) {b : R} (hb : b ≠ 0) (A : ι → R)\n    (h : abv.is_admissible) :\n    ∃ t : ι → Fin (h.card ε), ∀ i₀ i₁, t i₀ = t i₁ → (abv (A i₁ % b - A i₀ % b) : exprℝ) < «expr • » (abv b) ε :=\n  by\n  let e := Fintype.equivFin ι\n  obtain ⟨t, ht⟩ := h.exists_partition' (Fintype.card ι) hε hb (A ∘ e.symm)\n  refine' ⟨t ∘ e, fun i₀ i₁ h => _⟩\n  convert ht (e i₀) (e i₁) h <;> simp only [e.symm_apply_apply]\n#align exists_partition exists_partition\n\n",
 "exists_approx_aux":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- Any large enough family of vectors in `R^n` has a pair of elements\nwhose remainders are close together, pointwise. -/\ntheorem exists_approx_aux (n : ℕ) (h : abv.is_admissible) :\n    ∀ {ε : exprℝ} (hε : 0 < ε) {b : R} (hb : b ≠ 0) (A : Fin (h.card ε ^ n).succ → Fin n → R),\n      ∃ i₀ i₁, i₀ ≠ i₁ ∧ ∀ k, (abv (A i₁ k % b - A i₀ k % b) : exprℝ) < «expr • » (abv b) ε :=\n  by\n  haveI := Classical.decEq R\n  induction' n with n ih\n  · intro ε hε b hb A\n    refine' ⟨0, 1, _, _⟩\n    · simp\n    rintro ⟨i, ⟨⟩⟩\n  intro ε hε b hb A\n  set M := h.card ε with hM\n  -- By the \"nicer\" pigeonhole principle, we can find a collection `s`\n  -- of more than `M^n` remainders where the first components lie close together:\n  obtain ⟨s, s_inj, hs⟩ :\n    ∃ s : Fin (M ^ n).succ → Fin (M ^ n.succ).succ,\n      function.injective s ∧ ∀ i₀ i₁, (abv (A (s i₁) 0 % b - A (s i₀) 0 % b) : exprℝ) < «expr • » (abv b) ε :=\n    by\n    -- We can partition the `A`s into `M` subsets where\n    -- the first components lie close together:\n    obtain ⟨t, ht⟩ :\n      ∃ t : Fin (M ^ n.succ).succ → Fin M,\n        ∀ i₀ i₁, t i₀ = t i₁ → (abv (A i₁ 0 % b - A i₀ 0 % b) : exprℝ) < «expr • » (abv b) ε :=\n      h.exists_partition hε hb fun x => A x 0\n    -- Since the `M` subsets contain more than `M * M^n` elements total,\n    -- there must be a subset that contains more than `M^n` elements.\n    obtain ⟨s, hs⟩ :=\n      @Fintype.exists_lt_card_fiber_of_mul_lt_card _ _ _ _ _ t (M ^ n)\n        (by simpa only [Fintype.card_fin, pow_succ] using nat.lt_succ_self (M ^ n.succ))\n    refine' ⟨fun i => (finset.univ.filter fun x => t x = s).to_list.nth_le i _, _, fun i₀ i₁ => ht _ _ _⟩\n    · refine' i.2.trans_le _\n      rwa [Finset.length_toList]\n    · intro i j h\n      ext\n      exact list.nodup_iff_nth_le_inj.mp (Finset.nodup_toList _) _ _ _ _ h\n    have : ∀ i h, (finset.univ.filter fun x => t x = s).to_list.nth_le i h ∈ finset.univ.filter fun x => t x = s :=\n      by\n      intro i h\n      exact finset.mem_to_list.mp (List.nthLe_mem _ _ _)\n    obtain ⟨_, h₀⟩ := finset.mem_filter.mp (this i₀ _)\n    obtain ⟨_, h₁⟩ := finset.mem_filter.mp (this i₁ _)\n    exact h₀.trans h₁.symm\n  -- Since `s` is large enough, there are two elements of `A ∘ s`\n  -- where the second components lie close together.\n  obtain ⟨k₀, k₁, hk, h⟩ := ih hε hb fun x => Fin.tail (A (s x))\n  refine' ⟨s k₀, s k₁, fun h => hk (s_inj h), fun i => Fin.cases _ (fun i => _) i⟩\n  · exact hs k₀ k₁\n  · exact h i\n#align exists_approx_aux exists_approx_aux\n\n",
 "exists_approx":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- Any large enough family of vectors in `R^ι` has a pair of elements\nwhose remainders are close together, pointwise. -/\ntheorem exists_approx {ι : Type _} [Fintype ι] {ε : exprℝ} (hε : 0 < ε) {b : R} (hb : b ≠ 0) (h : abv.is_admissible)\n    (A : Fin (h.card ε ^ Fintype.card ι).succ → ι → R) :\n    ∃ i₀ i₁, i₀ ≠ i₁ ∧ ∀ k, (abv (A i₁ k % b - A i₀ k % b) : exprℝ) < «expr • » (abv b) ε :=\n  by\n  let e := Fintype.equivFin ι\n  obtain ⟨i₀, i₁, ne, h⟩ := h.exists_approx_aux (Fintype.card ι) hε hb fun x y => A x (e.symm y)\n  refine' ⟨i₀, i₁, ne, fun k => _⟩\n  convert h (e k) <;> simp only [e.symm_apply_apply]\n#align exists_approx exists_approx\n\n"}