{"zero_not_mem":
 "theorem finset_approx.zero_not_mem : (0 : R) ∉ finset_approx bS adm :=\n  Finset.not_mem_erase _ _\n#align finset_approx.zero_not_mem finset_approx.zero_not_mem\n\n",
 "prod_finset_approx_ne_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\ntheorem prod_finset_approx_ne_zero :\n    algebraMap R S\n        (finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\"\n          (finset_approx bS adm) m) ≠\n      0 :=\n  by\n  refine' mt ((injective_iff_map_eq_zero _).mp bS.algebra_map_injective _) _\n  simp only [Finset.prod_eq_zero_iff, not_exists]\n  rintro x hx rfl\n  exact finset_approx.zero_not_mem bS adm hx\n#align prod_finset_approx_ne_zero prod_finset_approx_ne_zero\n\n",
 "norm_lt":
 "/-- If the `R`-integral element `a : S` has coordinates `< y` with respect to some basis `b`,\nits norm is strictly less than `norm_bound abv b * y ^ dim S`. -/\ntheorem norm_lt {T : Type _} [LinearOrderedRing T] (a : S) {y : T} (hy : ∀ k, (abv (bS.repr a k) : T) < y) :\n    (abv (algebra.norm R a) : T) < norm_bound abv bS * y ^ Fintype.card ι :=\n  by\n  obtain ⟨i⟩ := bS.index_nonempty\n  have him : (finset.univ.image fun k => abv (bS.repr a k)).nonempty :=\n    ⟨_, finset.mem_image.mpr ⟨i, Finset.mem_univ _, rfl⟩⟩\n  set y' : ℤ := Finset.max' _ him with y'_def\n  have hy' : ∀ k, abv (bS.repr a k) ≤ y' := by\n    intro k\n    exact Finset.le_max' _ _ (finset.mem_image.mpr ⟨k, Finset.mem_univ _, rfl⟩)\n  have : (y' : T) < y :=\n    by\n    rw [y'_def, ← Finset.max'_image (show Monotone (coe : ℤ → T) from fun x y h => int.cast_le.mpr h)]\n    apply (Finset.max'_lt_iff _ (him.image _)).mpr\n    simp only [Finset.mem_image, exists_prop]\n    rintro _ ⟨x, ⟨k, -, rfl⟩, rfl⟩\n    exact hy k\n  have y'_nonneg : 0 ≤ y' := le_trans (abv.nonneg _) (hy' i)\n  apply (int.cast_le.mpr (norm_le abv bS a hy')).trans_lt\n  simp only [Int.cast_mul, Int.cast_pow]\n  apply mul_lt_mul' le_rfl\n  · exact pow_lt_pow_of_lt_left this (int.cast_nonneg.mpr y'_nonneg) (fintype.card_pos_iff.mpr ⟨i⟩)\n  · exact pow_nonneg (int.cast_nonneg.mpr y'_nonneg) _\n  · exact int.cast_pos.mpr (norm_bound_pos abv bS)\n  · infer_instance\n#align norm_lt norm_lt\n\n",
 "norm_le":
 "/-- If the `R`-integral element `a : S` has coordinates `≤ y` with respect to some basis `b`,\nits norm is less than `norm_bound abv b * y ^ dim S`. -/\ntheorem norm_le (a : S) {y : ℤ} (hy : ∀ k, abv (bS.repr a k) ≤ y) :\n    abv (algebra.norm R a) ≤ norm_bound abv bS * y ^ Fintype.card ι :=\n  by\n  conv_lhs => rw [← bS.sum_repr a]\n  rw [algebra.norm_apply, ← LinearMap.det_toMatrix bS]\n  simp only [algebra.norm_apply, AlgHom.map_sum, AlgHom.map_smul, LinearEquiv.map_sum, LinearEquiv.map_smul,\n    Algebra.toMatrix_lmul_eq, norm_bound, smul_mul_assoc, ← mul_pow]\n  convert Matrix.det_sum_smul_le Finset.univ _ hy using 3\n  · rw [Finset.card_univ, smul_mul_assoc, mul_comm]\n  · intro i j k\n    apply Finset.le_max'\n    exact finset.mem_image.mpr ⟨⟨i, j, k⟩, Finset.mem_univ _, rfl⟩\n#align norm_le norm_le\n\n",
 "norm_bound_pos":
 "/-\nCopyright (c) 2021 Anne Baanen. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Anne Baanen\n-/\ntheorem norm_bound_pos : 0 < norm_bound abv bS :=\n  by\n  obtain ⟨i, j, k, hijk⟩ : ∃ i j k, Algebra.leftMulMatrix bS (bS i) j k ≠ 0 :=\n    by\n    by_contra' h\n    obtain ⟨i⟩ := bS.index_nonempty\n    apply bS.ne_zero i\n    apply (injective_iff_map_eq_zero (Algebra.leftMulMatrix bS)).mp (Algebra.leftMulMatrix_injective bS)\n    ext (j k)\n    simp [h, DMatrix.zero_apply]\n  simp only [norm_bound, Algebra.smul_def, eq_natCast]\n  refine' mul_pos (int.coe_nat_pos.mpr (Nat.factorial_pos _)) _\n  refine' pow_pos (mul_pos (int.coe_nat_pos.mpr (fintype.card_pos_iff.mpr ⟨i⟩)) _) _\n  refine' lt_of_lt_of_le (abv.pos hijk) (Finset.le_max' _ _ _)\n  exact finset.mem_image.mpr ⟨⟨i, j, k⟩, Finset.mem_univ _, rfl⟩\n#align norm_bound_pos norm_bound_pos\n\n",
 "ne_bot_of_prod_finset_approx_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem ne_bot_of_prod_finset_approx_mem (J : Ideal S)\n    (h :\n      algebraMap _ _\n          (finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\"\n            (finset_approx bS adm) m) ∈\n        J) :\n    J ≠ «expr⊥» :=\n  (Submodule.ne_bot_iff _).mpr ⟨_, h, prod_finset_approx_ne_zero _ _⟩\n#align ne_bot_of_prod_finset_approx_mem ne_bot_of_prod_finset_approx_mem\n\n",
 "mk_M_mem_surjective":
 "theorem mk_M_mem_surjective [is_dedekind_domain S] (h : algebra.is_algebraic R L) :\n    function.surjective (class_group.mk_M_mem bS adm) :=\n  by\n  intro I'\n  obtain ⟨⟨I, hI⟩, rfl⟩ := class_group.mk0_surjective I'\n  obtain ⟨J, mk0_eq_mk0, J_dvd⟩ := exists_mk0_eq_mk0 L bS adm h ⟨I, hI⟩\n  exact ⟨⟨J, J_dvd⟩, mk0_eq_mk0.symm⟩\n#align mk_M_mem_surjective mk_M_mem_surjective\n\n",
 "mem_finset_approx":
 "@[simp]\ntheorem mem_finset_approx {x : R} :\n    x ∈ finset_approx bS adm ↔ ∃ i j, i ≠ j ∧ distinct_elems bS adm i - distinct_elems bS adm j = x :=\n  by\n  simp only [finset_approx, Finset.mem_erase, Finset.mem_image]\n  constructor\n  · rintro ⟨hx, ⟨i, j⟩, _, rfl⟩\n    refine' ⟨i, j, _, rfl⟩\n    rintro rfl\n    simpa using hx\n  · rintro ⟨i, j, hij, rfl⟩\n    refine' ⟨_, ⟨i, j⟩, Finset.mem_univ _, rfl⟩\n    rw [ne.def, sub_eq_zero]\n    exact fun h => hij ((distinct_elems bS adm).injective h)\n#align mem_finset_approx mem_finset_approx\n\n",
 "exists_mk0_eq_mk0":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/-- Each class in the class group contains an ideal `J`\nsuch that `M := Π m ∈ finset_approx` is in `J`. -/\ntheorem exists_mk0_eq_mk0 [is_dedekind_domain S] (h : algebra.is_algebraic R L) (I : non_zero_divisors (Ideal S)) :\n    ∃ J : non_zero_divisors (Ideal S),\n      class_group.mk0 I = class_group.mk0 J ∧\n        algebraMap _ _\n            (finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\"\n              (finset_approx bS adm) m) ∈\n          (J : Ideal S) :=\n  by\n  set M :=\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\"\n      (finset_approx bS adm) m with\n    M_eq\n  have hM : algebraMap R S M ≠ 0 := prod_finset_approx_ne_zero bS adm\n  obtain ⟨b, b_mem, b_ne_zero, b_min⟩ := exists_min abv I\n  suffices Ideal.span {b} ∣ Ideal.span {algebraMap _ _ M} * I.1\n    by\n    obtain ⟨J, hJ⟩ := this\n    refine' ⟨⟨J, _⟩, _, _⟩\n    · rw [mem_nonZeroDivisors_iff_ne_zero]\n      rintro rfl\n      rw [Ideal.zero_eq_bot, Ideal.mul_bot] at hJ\n      exact hM (ideal.span_singleton_eq_bot.mp (I.2 _ hJ))\n    · rw [class_group.mk0_eq_mk0_iff]\n      exact ⟨algebraMap _ _ M, b, hM, b_ne_zero, hJ⟩\n    rw [← SetLike.mem_coe, ← Set.singleton_subset_iff, ← Ideal.span_le, ← ideal.dvd_iff_le]\n    refine' (mul_dvd_mul_iff_left _).mp _\n    swap\n    · exact mt ideal.span_singleton_eq_bot.mp b_ne_zero\n    rw [Subtype.coe_mk, ideal.dvd_iff_le, ← hJ, mul_comm]\n    apply Ideal.mul_mono le_rfl\n    rw [Ideal.span_le, Set.singleton_subset_iff]\n    exact b_mem\n  rw [ideal.dvd_iff_le, Ideal.mul_le]\n  intro r' hr' a ha\n  rw [Ideal.mem_span_singleton] at hr'⊢\n  obtain ⟨q, r, r_mem, lt⟩ := exists_mem_finset_approx' L bS adm h a b_ne_zero\n  apply @dvd_of_mul_left_dvd _ _ q\n  simp only [Algebra.smul_def] at lt\n  rw [← sub_eq_zero.mp (b_min _ (I.1.sub_mem (I.1.mul_mem_left _ ha) (I.1.mul_mem_left _ b_mem)) lt)]\n  refine' mul_dvd_mul_right (dvd_trans (RingHom.map_dvd _ _) hr') _\n  exact Multiset.dvd_prod (multiset.mem_map.mpr ⟨_, r_mem, rfl⟩)\n#align exists_mk0_eq_mk0 exists_mk0_eq_mk0\n\n",
 "exists_min":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n/-- A nonzero ideal has an element of minimal norm. -/\ntheorem exists_min (I : non_zero_divisors (Ideal S)) :\n    ∃ b ∈ (I : Ideal S), b ≠ 0 ∧ ∀ c ∈ (I : Ideal S), abv (algebra.norm R c) < abv (algebra.norm R b) → c = (0 : S) :=\n  by\n  obtain ⟨_, ⟨b, b_mem, b_ne_zero, rfl⟩, min⟩ :=\n    @Int.exists_least_of_bdd (fun a => ∃ b ∈ (I : Ideal S), b ≠ (0 : S) ∧ abv (algebra.norm R b) = a) _ _\n  · refine' ⟨b, b_mem, b_ne_zero, _⟩\n    intro c hc lt\n    contrapose! lt with c_ne_zero\n    exact min _ ⟨c, hc, c_ne_zero, rfl⟩\n  · use 0\n    rintro _ ⟨b, b_mem, b_ne_zero, rfl⟩\n    apply abv.nonneg\n  · obtain ⟨b, b_mem, b_ne_zero⟩ := (I : Ideal S).ne_bot_iff.mp (nonZeroDivisors.coe_ne_zero I)\n    exact ⟨_, ⟨b, b_mem, b_ne_zero, rfl⟩⟩\n#align exists_min exists_min\n\n",
 "exists_mem_finset_approx'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- We can approximate `a / b : L` with `q / r`, where `r` has finitely many options for `L`. -/\ntheorem exists_mem_finset_approx' (h : algebra.is_algebraic R L) (a : S) {b : S} (hb : b ≠ 0) :\n    ∃ q : S, ∃ r ∈ finset_approx bS adm, abv (algebra.norm R («expr • » r a - q * b)) < abv (algebra.norm R b) :=\n  by\n  have inj : function.injective (algebraMap R L) :=\n    by\n    rw [IsScalarTower.algebraMap_eq R S L]\n    exact (is_integral_closure.algebra_map_injective S R L).comp bS.algebra_map_injective\n  obtain ⟨a', b', hb', h⟩ := is_integral_closure.exists_smul_eq_mul h inj a hb\n  obtain ⟨q, r, hr, hqr⟩ := exists_mem_finset_approx bS adm a' hb'\n  refine' ⟨q, r, hr, _⟩\n  refine' lt_of_mul_lt_mul_left _ (show 0 ≤ abv (algebra.norm R (algebraMap R S b')) from abv.nonneg _)\n  refine'\n    lt_of_le_of_lt (le_of_eq _)\n      (mul_lt_mul hqr le_rfl (abv.pos ((algebra.norm_ne_zero_iff_of_basis bS).mpr hb)) (abv.nonneg _))\n  rw [← abv.map_mul, ← MonoidHom.map_mul, ← abv.map_mul, ← MonoidHom.map_mul, ← Algebra.smul_def, smul_sub b', sub_mul,\n    smul_comm, h, mul_comm b a', Algebra.smul_mul_assoc r a' b, Algebra.smul_mul_assoc b' q b]\n#align exists_mem_finset_approx' exists_mem_finset_approx'\n\n",
 "exists_mem_finset_approx":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ↪ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- We can approximate `a / b : L` with `q / r`, where `r` has finitely many options for `L`. -/\ntheorem exists_mem_finset_approx (a : S) {b} (hb : b ≠ (0 : R)) :\n    ∃ q : S,\n      ∃ r ∈ finset_approx bS adm,\n        abv (algebra.norm R («expr • » r a - «expr • » b q)) < abv (algebra.norm R (algebraMap R S b)) :=\n  by\n  have dim_pos := fintype.card_pos_iff.mpr bS.index_nonempty\n  set ε : exprℝ := norm_bound abv bS ^ (-1 / Fintype.card ι : exprℝ) with ε_eq\n  have hε : 0 < ε := real.rpow_pos_of_pos (int.cast_pos.mpr (norm_bound_pos abv bS)) _\n  have ε_le : (norm_bound abv bS : exprℝ) * «expr • » (abv b) ε ^ Fintype.card ι ≤ abv b ^ Fintype.card ι :=\n    by\n    have := norm_bound_pos abv bS\n    have := abv.nonneg b\n    rw [ε_eq, Algebra.smul_def, eq_intCast, ← rpow_nat_cast, mul_rpow, ← rpow_mul, div_mul_cancel, rpow_neg_one,\n        mul_left_comm, mul_inv_cancel, mul_one, rpow_nat_cast] <;>\n      try norm_cast; linarith\n    · apply rpow_nonneg_of_nonneg\n      norm_cast\n      linarith\n  let μ : «expr ↪ » (Fin (cardM bS adm).succ) R := distinct_elems bS adm\n  set s := bS.repr a\n  have s_eq : ∀ i, s i = bS.repr a i := fun i => rfl\n  set qs := fun j i => μ j * s i / b\n  have q_eq : ∀ j i, qs j i = μ j * s i / b := fun i j => rfl\n  set rs := fun j i => μ j * s i % b with r_eq\n  have r_eq : ∀ j i, rs j i = μ j * s i % b := fun i j => rfl\n  have μ_eq : ∀ i j, μ j * s i = b * qs j i + rs j i := by\n    intro i j\n    rw [q_eq, r_eq, EuclideanDomain.div_add_mod]\n  have μ_mul_a_eq :\n    ∀ j,\n      «expr • » (μ j) a =\n        «expr • » b\n            (finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n              («expr • » (qs j i) (bS i))) +\n          finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n            («expr • » (rs j i) (bS i)) :=\n    by\n    intro j\n    rw [← bS.sum_repr a]\n    simp only [Finset.smul_sum, ← Finset.sum_add_distrib]\n    refine' Finset.sum_congr rfl fun i _ => _\n    rw [← s_eq, ← mul_smul, μ_eq, add_smul, mul_smul]\n  obtain ⟨j, k, j_ne_k, hjk⟩ := adm.exists_approx hε hb fun j i => μ j * s i\n  have hjk' : ∀ i, (abv (rs k i - rs j i) : exprℝ) < «expr • » (abv b) ε := by simpa only [r_eq] using hjk\n  set q :=\n    finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n      («expr • » (qs k i - qs j i) (bS i)) with\n    q_eq\n  set r := μ k - μ j with r_eq\n  refine' ⟨q, r, (mem_finset_approx bS adm).mpr _, _⟩\n  · exact ⟨k, j, j_ne_k.symm, rfl⟩\n  have :\n    «expr • » r a - «expr • » b q =\n      finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n        («expr • » (rs k x) (bS x) - «expr • » (rs j x) (bS x)) :=\n    by\n    simp only [r_eq, sub_smul, μ_mul_a_eq, q_eq, Finset.smul_sum, ← Finset.sum_add_distrib, ← Finset.sum_sub_distrib,\n      smul_sub]\n    refine' Finset.sum_congr rfl fun x _ => _\n    ring\n  rw [this, algebra.norm_algebra_map_of_basis bS, abv.map_pow]\n  refine' int.cast_lt.mp ((norm_lt abv bS _ fun i => lt_of_le_of_lt _ (hjk' i)).trans_le _)\n  · apply le_of_eq\n    congr\n    simp_rw [LinearEquiv.map_sum, LinearEquiv.map_sub, LinearEquiv.map_smul, Finset.sum_apply', Finsupp.sub_apply,\n      Finsupp.smul_apply, Finset.sum_sub_distrib, Basis.repr_self_apply, smul_eq_mul, mul_boole, Finset.sum_ite_eq',\n      Finset.mem_univ, if_true]\n  · exact_mod_cast ε_le\n#align exists_mem_finset_approx exists_mem_finset_approx\n\n"}