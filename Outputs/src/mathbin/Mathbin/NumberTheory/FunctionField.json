{"polynomial":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n@[simp]\ntheorem infty_valuation.polynomial {p : polynomial Fq} (hp : p ≠ 0) :\n    infty_valuation_def Fq (algebraMap (polynomial Fq) (ratfunc Fq) p) = Multiplicative.ofAdd (p.nat_degree : ℤ) :=\n  by\n  have hp' : algebraMap (polynomial Fq) (ratfunc Fq) p ≠ 0 :=\n    by\n    rw [ne.def, ratfunc.algebra_map_eq_zero_iff]\n    exact hp\n  rw [infty_valuation_def, if_neg hp', ratfunc.int_degree_polynomial]\n#align infty_valuation.polynomial infty_valuation.polynomial\n\n",
 "not_is_field":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem not_is_field : ¬IsField (ring_of_integers Fq F) := by\n  simpa [←\n    (is_integral_closure.is_integral_algebra (polynomial Fq) F).is_field_iff_is_field\n      (algebra_map_injective Fq F)] using\n    Polynomial.not_isField Fq\n#align not_is_field not_is_field\n\n",
 "map_zero'":
 "theorem infty_valuation.map_zero' : infty_valuation_def Fq 0 = 0 :=\n  if_pos rfl\n#align infty_valuation.map_zero' infty_valuation.map_zero'\n\n",
 "map_one'":
 "theorem infty_valuation.map_one' : infty_valuation_def Fq 1 = 1 :=\n  (if_neg one_ne_zero).trans <| by rw [ratfunc.int_degree_one, ofAdd_zero, WithZero.coe_one]\n#align infty_valuation.map_one' infty_valuation.map_one'\n\n",
 "map_mul'":
 "theorem infty_valuation.map_mul' (x y : ratfunc Fq) :\n    infty_valuation_def Fq (x * y) = infty_valuation_def Fq x * infty_valuation_def Fq y :=\n  by\n  rw [infty_valuation_def, infty_valuation_def, infty_valuation_def]\n  by_cases hx : x = 0\n  · rw [hx, MulZeroClass.zero_mul, if_pos (Eq.refl _), MulZeroClass.zero_mul]\n  · by_cases hy : y = 0\n    · rw [hy, MulZeroClass.mul_zero, if_pos (Eq.refl _), MulZeroClass.mul_zero]\n    ·\n      rw [if_neg hx, if_neg hy, if_neg (mul_ne_zero hx hy), ← WithZero.coe_mul, WithZero.coe_inj, ← ofAdd_add,\n        ratfunc.int_degree_mul hx hy]\n#align infty_valuation.map_mul' infty_valuation.map_mul'\n\n",
 "map_add_le_max'":
 "theorem infty_valuation.map_add_le_max' (x y : ratfunc Fq) :\n    infty_valuation_def Fq (x + y) ≤ max (infty_valuation_def Fq x) (infty_valuation_def Fq y) :=\n  by\n  by_cases hx : x = 0\n  · rw [hx, zero_add]\n    conv_rhs => rw [infty_valuation_def, if_pos (Eq.refl _)]\n    rw [max_eq_right (WithZero.zero_le (infty_valuation_def Fq y))]\n    exact le_refl _\n  · by_cases hy : y = 0\n    · rw [hy, add_zero]\n      conv_rhs => rw [max_comm, infty_valuation_def, if_pos (Eq.refl _)]\n      rw [max_eq_right (WithZero.zero_le (infty_valuation_def Fq x))]\n      exact le_refl _\n    · by_cases hxy : x + y = 0\n      · rw [infty_valuation_def, if_pos hxy]\n        exact zero_le'\n      · rw [infty_valuation_def, infty_valuation_def, infty_valuation_def, if_neg hx, if_neg hy, if_neg hxy]\n        rw [le_max_iff, WithZero.coe_le_coe, Multiplicative.ofAdd_le, WithZero.coe_le_coe, Multiplicative.ofAdd_le, ←\n          le_max_iff]\n        exact ratfunc.int_degree_add_le hy hxy\n#align infty_valuation.map_add_le_max' infty_valuation.map_add_le_max'\n\n",
 "infty_valuation_of_nonzero":
 "@[simp]\ntheorem infty_valuation_of_nonzero {x : ratfunc Fq} (hx : x ≠ 0) :\n    infty_valuation_def Fq x = Multiplicative.ofAdd x.int_degree := by rw [infty_valuation_def, if_neg hx]\n#align infty_valuation_of_nonzero infty_valuation_of_nonzero\n\n",
 "infty_valuation_apply":
 "@[simp]\ntheorem infty_valuation_apply {x : ratfunc Fq} : infty_valuation Fq x = infty_valuation_def Fq x :=\n  rfl\n#align infty_valuation_apply infty_valuation_apply\n\n",
 "function_field_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/-\nCopyright (c) 2021 Anne Baanen. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Anne Baanen, Ashvni Narayanan\n-/\n/-- `F` is a function field over `Fq` iff it is a finite extension of `Fq(t)`. -/\nprotected theorem function_field_iff (Fqt : Type _) [Field Fqt] [Algebra (polynomial Fq) Fqt]\n    [IsFractionRing (polynomial Fq) Fqt] [Algebra (ratfunc Fq) F] [Algebra Fqt F] [Algebra (polynomial Fq) F]\n    [IsScalarTower (polynomial Fq) Fqt F] [IsScalarTower (polynomial Fq) (ratfunc Fq) F] :\n    function_field Fq F ↔ FiniteDimensional Fqt F :=\n  by\n  let e := IsLocalization.algEquiv (non_zero_divisors (polynomial Fq)) (ratfunc Fq) Fqt\n  have : ∀ (c) (x : F), «expr • » (e c) x = «expr • » c x :=\n    by\n    intro c x\n    rw [Algebra.smul_def, Algebra.smul_def]\n    congr\n    refine' congr_fun _ c\n    refine' IsLocalization.ext (nonZeroDivisors (polynomial Fq)) _ _ _ _ _ _ _ <;> intros <;>\n      simp only [AlgEquiv.map_one, RingHom.map_one, AlgEquiv.map_mul, RingHom.map_mul, AlgEquiv.commutes, ←\n        IsScalarTower.algebraMap_apply]\n  constructor <;> intro h <;> skip\n  · let b := FiniteDimensional.finBasis (ratfunc Fq) F\n    exact FiniteDimensional.of_fintype_basis (b.map_coeffs e this)\n  · let b := FiniteDimensional.finBasis Fqt F\n    refine' FiniteDimensional.of_fintype_basis (b.map_coeffs e.symm _)\n    intro c x\n    convert(this (e.symm c) x).symm\n    simp only [e.apply_symm_apply]\n#align function_field_iff function_field_iff\n\n",
 "def":
 "theorem valued_Fqt_infty.def {x : Fqt_infty Fq} :\n    valued.v x = @valued.extension (ratfunc Fq) _ _ _ (infty_valued_Fqt Fq) x :=\n  rfl\n#align valued_Fqt_infty.def valued_Fqt_infty.def\n\n",
 "algebra_map_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem algebra_map_injective : function.injective («expr⇑ » (algebraMap (polynomial Fq) (ring_of_integers Fq F))) :=\n  by\n  have hinj : function.injective («expr⇑ » (algebraMap (polynomial Fq) F)) :=\n    by\n    rw [IsScalarTower.algebraMap_eq (polynomial Fq) (ratfunc Fq) F]\n    exact\n      function.injective.comp (algebraMap (ratfunc Fq) F).injective\n        (IsFractionRing.injective (polynomial Fq) (ratfunc Fq))\n  rw [injective_iff_map_eq_zero (algebraMap (polynomial Fq) («expr↥ » (ring_of_integers Fq F)))]\n  intro p hp\n  rw [← Subtype.coe_inj, Subalgebra.coe_zero] at hp\n  rw [injective_iff_map_eq_zero (algebraMap (polynomial Fq) F)] at hinj\n  exact hinj p hp\n#align algebra_map_injective algebra_map_injective\n\n",
 "X":
 "@[simp]\ntheorem infty_valuation.X : infty_valuation_def Fq ratfunc.X = Multiplicative.ofAdd (1 : ℤ) := by\n  rw [infty_valuation_def, if_neg ratfunc.X_ne_zero, ratfunc.int_degree_X]\n#align infty_valuation.X infty_valuation.X\n\n",
 "C":
 "@[simp]\ntheorem infty_valuation.C {k : Fq} (hk : k ≠ 0) : infty_valuation_def Fq (ratfunc.C k) = Multiplicative.ofAdd (0 : ℤ) :=\n  by\n  have hCk : ratfunc.C k ≠ 0 := (map_ne_zero _).mpr hk\n  rw [infty_valuation_def, if_neg hCk, ratfunc.int_degree_C]\n#align infty_valuation.C infty_valuation.C\n\n"}