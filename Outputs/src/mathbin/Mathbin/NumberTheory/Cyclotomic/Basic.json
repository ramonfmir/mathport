{"union_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ+» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ+» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ+» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ+» -/\n/-- If `B` is a cyclotomic extension of `A` given by roots of unity of order in `S ∪ T`, then `B`\nis a cyclotomic extension of `adjoin A { b : B | ∃ a : ℕ+, a ∈ S ∧ b ^ (a : ℕ) = 1 } ` given by\nroots of unity of order in `T`. -/\ntheorem union_right [h : is_cyclotomic_extension (S ∪ T) A B] :\n    is_cyclotomic_extension T (adjoin A { b : B | ∃ a : «exprℕ+», a ∈ S ∧ b ^ (a : ℕ) = 1 }) B :=\n  by\n  have :\n    { b : B | ∃ n : «exprℕ+», n ∈ S ∪ T ∧ b ^ (n : ℕ) = 1 } =\n      { b : B | ∃ n : «exprℕ+», n ∈ S ∧ b ^ (n : ℕ) = 1 } ∪ { b : B | ∃ n : «exprℕ+», n ∈ T ∧ b ^ (n : ℕ) = 1 } :=\n    by\n    refine' le_antisymm (fun x hx => _) fun x hx => _\n    · rcases hx with ⟨n, hn₁ | hn₂, hnpow⟩\n      · left\n        exact ⟨n, hn₁, hnpow⟩\n      · right\n        exact ⟨n, hn₂, hnpow⟩\n    · rcases hx with (⟨n, hn⟩ | ⟨n, hn⟩)\n      · exact ⟨n, or.inl hn.1, hn.2⟩\n      · exact ⟨n, or.inr hn.1, hn.2⟩\n  refine' ⟨fun n hn => ((is_cyclotomic_extension_iff _ _ _).1 h).1 (mem_union_right S hn), fun b => _⟩\n  replace h := ((is_cyclotomic_extension_iff _ _ _).1 h).2 b\n  rwa [this, adjoin_union_eq_adjoin_adjoin, Subalgebra.mem_restrictScalars] at h\n#align union_right union_right\n\n",
 "union_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ+» -/\n/-- If `B` is a cyclotomic extension of `A` given by roots of unity of order in `T` and `S ⊆ T`,\nthen `adjoin A { b : B | ∃ a : ℕ+, a ∈ S ∧ b ^ (a : ℕ) = 1 }` is a cyclotomic extension of `B`\ngiven by roots of unity of order in `S`. -/\ntheorem union_left [h : is_cyclotomic_extension T A B] (hS : S ⊆ T) :\n    is_cyclotomic_extension S A (adjoin A { b : B | ∃ a : «exprℕ+», a ∈ S ∧ b ^ (a : ℕ) = 1 }) :=\n  by\n  refine' ⟨fun n hn => _, fun b => _⟩\n  · obtain ⟨b, hb⟩ := ((is_cyclotomic_extension_iff _ _ _).1 h).1 (hS hn)\n    refine' ⟨⟨b, subset_adjoin ⟨n, hn, hb.pow_eq_one⟩⟩, _⟩\n    rwa [← is_primitive_root.coe_submonoid_class_iff, Subtype.coe_mk]\n  · convert mem_top\n    rw [← adjoin_adjoin_coe_preimage, preimage_set_of_eq]\n    norm_cast\n#align union_left union_left\n\n",
 "trans":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ+» -/\n#print trans /-\n/-- Transitivity of cyclotomic extensions. -/\ntheorem trans (C : Type w) [CommRing C] [Algebra A C] [Algebra B C] [IsScalarTower A B C]\n    [hS : is_cyclotomic_extension S A B] [hT : is_cyclotomic_extension T B C]\n    (h : function.injective (algebraMap B C)) : is_cyclotomic_extension (S ∪ T) A C :=\n  by\n  refine' ⟨fun n hn => _, fun x => _⟩\n  · cases hn\n    · obtain ⟨b, hb⟩ := ((is_cyclotomic_extension_iff _ _ _).1 hS).1 hn\n      refine' ⟨algebraMap B C b, _⟩\n      exact hb.map_of_injective h\n    · exact ((is_cyclotomic_extension_iff _ _ _).1 hT).1 hn\n  · refine'\n      adjoin_induction (((is_cyclotomic_extension_iff _ _ _).1 hT).2 x)\n        (fun c ⟨n, hn⟩ => subset_adjoin ⟨n, or.inr hn.1, hn.2⟩) (fun b => _)\n        (fun x y hx hy => Subalgebra.add_mem _ hx hy) fun x y hx hy => Subalgebra.mul_mem _ hx hy\n    · let f := IsScalarTower.toAlgHom A B C\n      have hb : f b ∈ (adjoin A { b : B | ∃ a : «exprℕ+», a ∈ S ∧ b ^ (a : ℕ) = 1 }).map f :=\n        ⟨b, ((is_cyclotomic_extension_iff _ _ _).1 hS).2 b, rfl⟩\n      rw [IsScalarTower.toAlgHom_apply, ← adjoin_image] at hb\n      refine' adjoin_mono (fun y hy => _) hb\n      obtain ⟨b₁, ⟨⟨n, hn⟩, h₁⟩⟩ := hy\n      exact ⟨n, ⟨mem_union_left T hn.1, by rw [← h₁, ← AlgHom.map_pow, hn.2, AlgHom.map_one]⟩⟩\n#align trans trans\n-/\n\n",
 "subsingleton_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n#print subsingleton_iff /-\n@[nontriviality]\ntheorem subsingleton_iff [subsingleton B] : is_cyclotomic_extension S A B ↔ S = { } ∨ S = {1} :=\n  by\n  constructor\n  · rintro ⟨hprim, -⟩\n    rw [← subset_singleton_iff_eq]\n    intro t ht\n    obtain ⟨ζ, hζ⟩ := hprim ht\n    rw [mem_singleton_iff, ← PNat.coe_eq_one_iff]\n    exact_mod_cast hζ.unique (is_primitive_root.of_subsingleton ζ)\n  · rintro (rfl | rfl)\n    · refine' ⟨fun _ h => h.elim, fun x => by convert(mem_top : x ∈ «expr⊤»)⟩\n    · rw [iff_singleton]\n      refine' ⟨⟨0, is_primitive_root.of_subsingleton 0⟩, fun x => by convert(mem_top : x ∈ «expr⊤»)⟩\n#align subsingleton_iff subsingleton_iff\n-/\n\n",
 "splitting_field_cyclotomic":
 "/-- If `is_cyclotomic_extension {n} K L`, then `L` is the splitting field of `cyclotomic n K`. -/\ntheorem splitting_field_cyclotomic : is_splitting_field K L (cyclotomic n K) :=\n  { splits := splits_cyclotomic K L (mem_singleton n)\n    adjoin_roots := by\n      rw [← ((iff_adjoin_eq_top {n} K L).1 inferInstance).2]\n      letI := Classical.decEq L\n      obtain ⟨ζ, hζ⟩ := @is_cyclotomic_extension.exists_prim_root {n} K L _ _ _ _ _ (mem_singleton n)\n      exact adjoin_roots_cyclotomic_eq_adjoin_nth_roots hζ }\n#align splitting_field_cyclotomic splitting_field_cyclotomic\n\n",
 "splitting_field_X_pow_sub_one":
 "/-- If `is_cyclotomic_extension {n} K L`, then `L` is the splitting field of `X ^ n - 1`. -/\ntheorem splitting_field_X_pow_sub_one : is_splitting_field K L (X ^ (n : ℕ) - 1) :=\n  { splits := splits_X_pow_sub_one K L (mem_singleton n)\n    adjoin_roots := by\n      rw [← ((iff_adjoin_eq_top {n} K L).1 inferInstance).2]\n      congr\n      refine' Set.ext fun x => _\n      simp only [Polynomial.map_pow, mem_singleton_iff, Multiset.mem_toFinset, exists_eq_left, mem_set_of_eq,\n        Polynomial.map_X, Polynomial.map_one, Finset.mem_coe, Polynomial.map_sub]\n      rwa [← RingHom.map_one C, mem_roots (@X_pow_sub_C_ne_zero L _ _ _ n.pos _), is_root.def, eval_sub, eval_pow,\n        eval_C, eval_X, sub_eq_zero] }\n#align splitting_field_X_pow_sub_one splitting_field_X_pow_sub_one\n\n",
 "splits_cyclotomic":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/-- A cyclotomic extension splits `cyclotomic n K` if `n ∈ S` and `ne_zero (n : K)`.-/\ntheorem splits_cyclotomic [is_cyclotomic_extension S K L] (hS : n ∈ S) : Splits (algebraMap K L) (cyclotomic n K) :=\n  by\n  refine' splits_of_splits_of_dvd _ (X_pow_sub_C_ne_zero n.pos _) (splits_X_pow_sub_one K L hS) _\n  use\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\"\n      (n : ℕ).proper_divisors (polynomial.cyclotomic i K)\n  rw [(eq_cyclotomic_iff n.pos _).1 rfl, RingHom.map_one]\n#align splits_cyclotomic splits_cyclotomic\n\n",
 "splits_X_pow_sub_one":
 "/-- A cyclotomic extension splits `X ^ n - 1` if `n ∈ S`.-/\ntheorem splits_X_pow_sub_one [H : is_cyclotomic_extension S K L] (hS : n ∈ S) :\n    Splits (algebraMap K L) (X ^ (n : ℕ) - 1) :=\n  by\n  rw [← splits_id_iff_splits, Polynomial.map_sub, Polynomial.map_one, Polynomial.map_pow, Polynomial.map_X]\n  obtain ⟨z, hz⟩ := ((is_cyclotomic_extension_iff _ _ _).1 H).1 hS\n  exact X_pow_sub_one_splits hz\n#align splits_X_pow_sub_one splits_X_pow_sub_one\n\n",
 "singleton_zero_of_bot_eq_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/-- If `(⊥ : subalgebra A B) = ⊤`, then `is_cyclotomic_extension ∅ A B`. -/\ntheorem singleton_zero_of_bot_eq_top (h : («expr⊥» : Subalgebra A B) = «expr⊤») : is_cyclotomic_extension ∅ A B :=\n  by\n  refine' (iff_adjoin_eq_top _ _ _).2 ⟨fun s hs => by simpa using hs, _root_.eq_top_iff.2 fun x hx => _⟩\n  rw [← h] at hx\n  simpa using hx\n#align singleton_zero_of_bot_eq_top singleton_zero_of_bot_eq_top\n\n",
 "singleton_one_of_bot_eq_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/-- If `(⊥ : subalgebra A B) = ⊤`, then `is_cyclotomic_extension {1} A B`. -/\ntheorem singleton_one_of_bot_eq_top (h : («expr⊥» : Subalgebra A B) = «expr⊤») : is_cyclotomic_extension {1} A B :=\n  by\n  convert(iff_union_singleton_one _ _ _).1 (singleton_zero_of_bot_eq_top h)\n  simp\n#align singleton_one_of_bot_eq_top singleton_one_of_bot_eq_top\n\n",
 "singleton_one_of_algebra_map_bijective":
 "/-- If `function.surjective (algebra_map A B)`, then `is_cyclotomic_extension {1} A B`. -/\ntheorem singleton_one_of_algebra_map_bijective (h : function.surjective (algebraMap A B)) :\n    is_cyclotomic_extension {1} A B :=\n  singleton_one_of_bot_eq_top (surjective_algebraMap_iff.1 h).symm\n#align singleton_one_of_algebra_map_bijective singleton_one_of_algebra_map_bijective\n\n",
 "singleton_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/-- If `is_cyclotomic_extension {1} A B`, then the image of `A` in `B` equals `B`. -/\ntheorem singleton_one [h : is_cyclotomic_extension {1} A B] : («expr⊥» : Subalgebra A B) = «expr⊤» :=\n  Algebra.eq_top_iff.2 fun x => by simpa [adjoin_singleton_one] using ((is_cyclotomic_extension_iff _ _ _).1 h).2 x\n#align singleton_one singleton_one\n\n",
 "of_union_of_dvd":
 "/-- If `∀ s ∈ S, n ∣ s` and `S` is not empty, then `is_cyclotomic_extension S A B` implies\n`is_cyclotomic_extension (S ∪ {n}) A B`. -/\ntheorem of_union_of_dvd (h : ∀ s ∈ S, n ∣ s) (hS : S.nonempty) [H : is_cyclotomic_extension S A B] :\n    is_cyclotomic_extension (S ∪ {n}) A B :=\n  by\n  refine' (iff_adjoin_eq_top _ _ _).2 ⟨fun s hs => _, _⟩\n  · rw [mem_union, mem_singleton_iff] at hs\n    obtain hs | rfl := hs\n    · exact H.exists_prim_root hs\n    · obtain ⟨m, hm⟩ := hS\n      obtain ⟨x, rfl⟩ := h m hm\n      obtain ⟨ζ, hζ⟩ := H.exists_prim_root hm\n      refine' ⟨ζ ^ (x : ℕ), _⟩\n      convert hζ.pow_of_dvd x.ne_zero (dvd_mul_left (x : ℕ) s)\n      simp only [PNat.mul_coe, nat.mul_div_left, PNat.pos]\n  · refine' _root_.eq_top_iff.2 _\n    rw [← ((iff_adjoin_eq_top S A B).1 H).2]\n    refine' adjoin_mono fun x hx => _\n    simp only [union_singleton, mem_insert_iff, mem_set_of_eq] at hx⊢\n    obtain ⟨m, hm⟩ := hx\n    exact ⟨m, ⟨or.inr hm.1, hm.2⟩⟩\n#align of_union_of_dvd of_union_of_dvd\n\n",
 "number_field":
 "/-- A cyclotomic finite extension of a number field is a number field. -/\ntheorem number_field [h : number_field K] [Finite S] [is_cyclotomic_extension S K L] : number_field L :=\n  { to_char_zero := charZero_of_injective_algebraMap (algebraMap K L).injective\n    to_finite_dimensional :=\n      by\n      haveI := charZero_of_injective_algebraMap (algebraMap K L).injective\n      haveI := Finite S K L\n      exact Module.Finite.trans K _ }\n#align number_field number_field\n\n",
 "ne_zero'":
 "@[protected]\ntheorem ne_zero' [is_cyclotomic_extension {n} A B] [IsDomain B] : NeZero ((n : ℕ) : A) :=\n  by\n  apply NeZero.nat_of_neZero (algebraMap A B)\n  exact NeZero n A B\n#align ne_zero' ne_zero'\n\n",
 "is_galois":
 "theorem is_galois : is_galois K L :=\n  letI := splitting_field_X_pow_sub_one n K L\n  is_galois.of_separable_splitting_field (X_pow_sub_one_separable_iff.2 (ne_zero' n K L).1)\n#align is_galois is_galois\n\n",
 "is_cyclotomic_extension":
 "/-- Algebraically closed fields are `S`-cyclotomic extensions over themselves if\n`ne_zero ((a : ℕ) : K))` for all `a ∈ S`. -/\ntheorem is_alg_closed.is_cyclotomic_extension (h : ∀ a ∈ S, NeZero ((a : ℕ) : K)) : is_cyclotomic_extension S K K :=\n  by\n  refine' ⟨fun a ha => _, algebra.eq_top_iff.mp <| subsingleton.elim _ _⟩\n  obtain ⟨r, hr⟩ := is_alg_closed.exists_aeval_eq_zero K _ (degree_cyclotomic_pos a K a.pos).ne'\n  refine' ⟨r, _⟩\n  haveI := h a ha\n  rwa [coe_aeval_eq_eval, ← is_root.def, is_root_cyclotomic_iff] at hr\n#align is_alg_closed.is_cyclotomic_extension is_alg_closed.is_cyclotomic_extension\n\n",
 "integral":
 "/-- A finite cyclotomic extension of an integral noetherian domain is integral -/\ntheorem integral [IsDomain B] [IsNoetherianRing A] [Finite S] [is_cyclotomic_extension S A B] :\n    algebra.is_integral A B :=\n  is_integral_of_noetherian <| isNoetherian_of_fg_of_noetherian' <| (Finite S A B).out\n#align integral integral\n\n",
 "iff_union_singleton_one":
 "/-- `is_cyclotomic_extension S A B` is equivalent to `is_cyclotomic_extension (S ∪ {1}) A B`. -/\ntheorem iff_union_singleton_one : is_cyclotomic_extension S A B ↔ is_cyclotomic_extension (S ∪ {1}) A B :=\n  by\n  obtain hS | rfl := S.eq_empty_or_nonempty.symm\n  · exact iff_union_of_dvd _ _ (fun s hs => one_dvd _) hS\n  rw [empty_union]\n  refine' ⟨fun H => _, fun H => _⟩\n  · refine' (iff_adjoin_eq_top _ _ _).2 ⟨fun s hs => ⟨1, by simp [mem_singleton_iff.1 hs]⟩, _⟩\n    simp [adjoin_singleton_one, @Empty _ _ _ _ _ H]\n  · refine' (iff_adjoin_eq_top _ _ _).2 ⟨fun s hs => (not_mem_empty s hs).elim, _⟩\n    simp [@singleton_one A B _ _ _ H]\n#align iff_union_singleton_one iff_union_singleton_one\n\n",
 "iff_union_of_dvd":
 "/-- If `∀ s ∈ S, n ∣ s` and `S` is not empty, then `is_cyclotomic_extension S A B` if and only if\n`is_cyclotomic_extension (S ∪ {n}) A B`. -/\ntheorem iff_union_of_dvd (h : ∀ s ∈ S, n ∣ s) (hS : S.nonempty) :\n    is_cyclotomic_extension S A B ↔ is_cyclotomic_extension (S ∪ {n}) A B :=\n  by\n  refine' ⟨fun H => of_union_of_dvd A B h hS, fun H => (iff_adjoin_eq_top _ _ _).2 ⟨fun s hs => _, _⟩⟩\n  · exact H.exists_prim_root (subset_union_left _ _ hs)\n  · rw [_root_.eq_top_iff, ← ((iff_adjoin_eq_top _ A B).1 H).2]\n    refine' adjoin_mono fun x hx => _\n    simp only [union_singleton, mem_insert_iff, mem_set_of_eq] at hx⊢\n    obtain ⟨m, rfl | hm, hxpow⟩ := hx\n    · obtain ⟨y, hy⟩ := hS\n      refine' ⟨y, ⟨hy, _⟩⟩\n      obtain ⟨z, rfl⟩ := h y hy\n      simp only [PNat.mul_coe, pow_mul, hxpow, one_pow]\n    · exact ⟨m, ⟨hm, hxpow⟩⟩\n#align iff_union_of_dvd iff_union_of_dvd\n\n",
 "iff_singleton":
 "/-- A reformulation of `is_cyclotomic_extension` in the case `S` is a singleton. -/\ntheorem iff_singleton :\n    is_cyclotomic_extension {n} A B ↔\n      (∃ r : B, is_primitive_root r n) ∧ ∀ x, x ∈ adjoin A { b : B | b ^ (n : ℕ) = 1 } :=\n  by simp [is_cyclotomic_extension_iff]\n#align iff_singleton iff_singleton\n\n",
 "iff_adjoin_eq_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ+» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ+» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/-\nCopyright (c) 2021 Riccardo Brasca. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Riccardo Brasca\n-/\n/-- A reformulation of `is_cyclotomic_extension` that uses `⊤`. -/\ntheorem iff_adjoin_eq_top :\n    is_cyclotomic_extension S A B ↔\n      (∀ n : «exprℕ+», n ∈ S → ∃ r : B, is_primitive_root r n) ∧\n        adjoin A { b : B | ∃ n : «exprℕ+», n ∈ S ∧ b ^ (n : ℕ) = 1 } = «expr⊤» :=\n  ⟨fun h => ⟨fun _ => h.exists_prim_root, Algebra.eq_top_iff.2 h.adjoin_roots⟩, fun h =>\n    ⟨h.1, Algebra.eq_top_iff.1 h.2⟩⟩\n#align iff_adjoin_eq_top iff_adjoin_eq_top\n\n",
 "finite_of_singleton":
 "theorem finite_of_singleton [IsDomain B] [h : is_cyclotomic_extension {n} A B] : Module.Finite A B := by\n  classical\n    rw [Module.finite_def, ← top_to_submodule, ← ((iff_adjoin_eq_top _ _ _).1 h).2]\n    refine' fg_adjoin_of_finite _ fun b hb => _\n    · simp only [mem_singleton_iff, exists_eq_left]\n      have : { b : B | b ^ (n : ℕ) = 1 } = (nth_roots n (1 : B)).to_finset :=\n        Set.ext fun x => ⟨fun h => by simpa using h, fun h => by simpa using h⟩\n      rw [this]\n      exact (nth_roots (↑n) 1).to_finset.finite_to_set\n    · simp only [mem_singleton_iff, exists_eq_left, mem_set_of_eq] at hb\n      refine' ⟨X ^ (n : ℕ) - 1, ⟨monic_X_pow_sub_C _ n.pos.ne.symm, by simp [hb]⟩⟩\n#align finite_of_singleton finite_of_singleton\n\n",
 "eq_adjoin_primitive_root":
 "theorem eq_adjoin_primitive_root {μ : cyclotomic_field n K} (h : is_primitive_root μ n) :\n    cyclotomic_ring n A K = adjoin A ({μ} : Set (cyclotomic_field n K)) :=\n  by\n  letI := classical.prop_decidable\n  rw [← is_cyclotomic_extension.adjoin_roots_cyclotomic_eq_adjoin_root_cyclotomic h,\n    is_cyclotomic_extension.adjoin_roots_cyclotomic_eq_adjoin_nth_roots h]\n  simp [cyclotomic_ring]\n#align eq_adjoin_primitive_root eq_adjoin_primitive_root\n\n",
 "algebra_base_injective":
 "theorem algebra_base_injective : function.injective <| algebraMap A (cyclotomic_ring n A K) :=\n  NoZeroSMulDivisors.algebraMap_injective _ _\n#align algebra_base_injective algebra_base_injective\n\n",
 "adjoin_roots_cyclotomic_eq_adjoin_root_cyclotomic":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ+» -/\ntheorem adjoin_roots_cyclotomic_eq_adjoin_root_cyclotomic {n : «exprℕ+»} [DecidableEq B] [IsDomain B] {ζ : B}\n    (hζ : is_primitive_root ζ n) :\n    adjoin A ((map (algebraMap A B) (cyclotomic n A)).roots.to_finset : Set B) = adjoin A {ζ} :=\n  by\n  refine' le_antisymm (adjoin_le fun x hx => _) (adjoin_mono fun x hx => _)\n  · suffices hx : x ^ ↑n = 1\n    obtain ⟨i, hin, rfl⟩ := hζ.eq_pow_of_pow_eq_one hx n.pos\n    exact SetLike.mem_coe.2 (Subalgebra.pow_mem _ (subset_adjoin <| mem_singleton ζ) _)\n    rw [is_root_of_unity_iff n.pos]\n    refine' ⟨n, Nat.mem_divisors_self n n.ne_zero, _⟩\n    rwa [Finset.mem_coe, Multiset.mem_toFinset, map_cyclotomic, mem_roots <| cyclotomic_ne_zero n B] at hx\n  · simp only [mem_singleton_iff, exists_eq_left, mem_set_of_eq] at hx\n    simpa only [hx, Multiset.mem_toFinset, Finset.mem_coe, map_cyclotomic, mem_roots (cyclotomic_ne_zero n B)] using\n      hζ.is_root_cyclotomic n.pos\n#align adjoin_roots_cyclotomic_eq_adjoin_root_cyclotomic adjoin_roots_cyclotomic_eq_adjoin_root_cyclotomic\n\n",
 "adjoin_roots_cyclotomic_eq_adjoin_nth_roots":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ+» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ+» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ+» -/\ntheorem adjoin_roots_cyclotomic_eq_adjoin_nth_roots [DecidableEq B] [IsDomain B] {ζ : B} {n : «exprℕ+»}\n    (hζ : is_primitive_root ζ n) :\n    adjoin A ↑(map (algebraMap A B) (cyclotomic n A)).roots.to_finset =\n      adjoin A { b : B | ∃ a : «exprℕ+», a ∈ ({n} : Set («exprℕ+»)) ∧ b ^ (a : ℕ) = 1 } :=\n  by\n  simp only [mem_singleton_iff, exists_eq_left, map_cyclotomic]\n  refine' le_antisymm (adjoin_mono fun x hx => _) (adjoin_le fun x hx => _)\n  · simp only [Multiset.mem_toFinset, Finset.mem_coe, map_cyclotomic, mem_roots (cyclotomic_ne_zero n B)] at hx\n    simp only [mem_singleton_iff, exists_eq_left, mem_set_of_eq]\n    rw [is_root_of_unity_iff n.pos]\n    exact ⟨n, Nat.mem_divisors_self n n.ne_zero, hx⟩\n  · simp only [mem_singleton_iff, exists_eq_left, mem_set_of_eq] at hx\n    obtain ⟨i, hin, rfl⟩ := hζ.eq_pow_of_pow_eq_one hx n.pos\n    refine' SetLike.mem_coe.2 (Subalgebra.pow_mem _ (subset_adjoin _) _)\n    rwa [Finset.mem_coe, Multiset.mem_toFinset, mem_roots <| cyclotomic_ne_zero n B]\n    exact hζ.is_root_cyclotomic n.pos\n#align adjoin_roots_cyclotomic_eq_adjoin_nth_roots adjoin_roots_cyclotomic_eq_adjoin_nth_roots\n\n",
 "adjoin_primitive_root_eq_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ+» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem adjoin_primitive_root_eq_top {n : «exprℕ+»} [IsDomain B] [h : is_cyclotomic_extension {n} A B] {ζ : B}\n    (hζ : is_primitive_root ζ n) : adjoin A ({ζ} : Set B) = «expr⊤» := by\n  classical\n    rw [← adjoin_roots_cyclotomic_eq_adjoin_root_cyclotomic hζ]\n    rw [adjoin_roots_cyclotomic_eq_adjoin_nth_roots hζ]\n    exact ((iff_adjoin_eq_top {n} A B).mp h).2\n#align adjoin_primitive_root_eq_top adjoin_primitive_root_eq_top\n\n",
 "adjoin_is_cyclotomic_extension":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ+» -/\ntheorem _root_.is_primitive_root.adjoin_is_cyclotomic_extension {ζ : B} {n : «exprℕ+»} (h : is_primitive_root ζ n) :\n    is_cyclotomic_extension {n} A (adjoin A ({ζ} : Set B)) :=\n  { exists_prim_root := fun i hi => by\n      rw [Set.mem_singleton_iff] at hi\n      refine' ⟨⟨ζ, subset_adjoin <| Set.mem_singleton ζ⟩, _⟩\n      rwa [← is_primitive_root.coe_submonoid_class_iff, Subtype.coe_mk, hi]\n    adjoin_roots := fun x =>\n      by\n      refine' adjoin_induction' (fun b hb => _) (fun a => _) (fun b₁ b₂ hb₁ hb₂ => _) (fun b₁ b₂ hb₁ hb₂ => _) x\n      · rw [Set.mem_singleton_iff] at hb\n        refine' subset_adjoin _\n        simp only [mem_singleton_iff, exists_eq_left, mem_set_of_eq, hb]\n        rw [← Subalgebra.coe_eq_one, Subalgebra.coe_pow, [anonymous]]\n        exact ((is_primitive_root.iff_def ζ n).1 h).1\n      · exact Subalgebra.algebraMap_mem _ _\n      · exact Subalgebra.add_mem _ hb₁ hb₂\n      · exact Subalgebra.mul_mem _ hb₁ hb₂ }\n#align is_primitive_root.adjoin_is_cyclotomic_extension is_primitive_root.adjoin_is_cyclotomic_extension\n\n",
 "adjoin_algebra_injective":
 "theorem adjoin_algebra_injective : function.injective <| algebraMap (cyclotomic_ring n A K) (cyclotomic_field n K) :=\n  Subtype.val_injective\n#align adjoin_algebra_injective adjoin_algebra_injective\n\n",
 "NeZero":
 "#print NeZero /-\n@[protected]\ntheorem NeZero [h : is_cyclotomic_extension {n} A B] [IsDomain B] : NeZero ((n : ℕ) : B) :=\n  by\n  obtain ⟨⟨r, hr⟩, -⟩ := (iff_singleton n A B).1 h\n  exact hr.ne_zero'\n#align ne_zero NeZero\n-/\n\n",
 "FiniteDimensional":
 "#print FiniteDimensional /-\n/-- If `S` is finite and `is_cyclotomic_extension S K A`, then `finite_dimensional K A`. -/\ntheorem FiniteDimensional (C : Type z) [Finite S] [CommRing C] [Algebra K C] [IsDomain C]\n    [is_cyclotomic_extension S K C] : FiniteDimensional K C :=\n  is_cyclotomic_extension.finite S K C\n#align finite_dimensional FiniteDimensional\n-/\n\n",
 "Finite":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ+» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ+» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ+» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ+» -/\n#print Finite /-\n/-- If `S` is finite and `is_cyclotomic_extension S A B`, then `B` is a finite `A`-algebra. -/\n@[protected]\ntheorem Finite [IsDomain B] [h₁ : Finite S] [h₂ : is_cyclotomic_extension S A B] : Module.Finite A B :=\n  by\n  cases' nonempty_fintype S with h\n  revert h₂ A B\n  refine' Set.Finite.induction_on (set.finite.intro h) (fun A B => _) fun n S hn hS H A B => _\n  · intro _ _ _ _ _\n    refine' Module.finite_def.2 ⟨({1} : Finset B), _⟩\n    simp [← top_to_submodule, ← Empty, to_submodule_bot]\n  · intro _ _ _ _ h\n    haveI : is_cyclotomic_extension S A (adjoin A { b : B | ∃ n : «exprℕ+», n ∈ S ∧ b ^ (n : ℕ) = 1 }) :=\n      union_left _ (insert n S) _ _ (subset_insert n S)\n    haveI := H A (adjoin A { b : B | ∃ n : «exprℕ+», n ∈ S ∧ b ^ (n : ℕ) = 1 })\n    have : Module.Finite (adjoin A { b : B | ∃ n : «exprℕ+», n ∈ S ∧ b ^ (n : ℕ) = 1 }) B :=\n      by\n      rw [← union_singleton] at h\n      letI := @union_right S {n} A B _ _ _ h\n      exact finite_of_singleton n _ _\n    exact Module.Finite.trans (adjoin A { b : B | ∃ n : «exprℕ+», n ∈ S ∧ b ^ (n : ℕ) = 1 }) _\n#align finite Finite\n-/\n\n",
 "Equiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₐ[ ] » -/\n#print Equiv /-\n/-- Given `(f : B ≃ₐ[A] C)`, if `is_cyclotomic_extension S A B` then\n`is_cyclotomic_extension S A C`. -/\n@[protected]\ntheorem Equiv {C : Type _} [CommRing C] [Algebra A C] [h : is_cyclotomic_extension S A B] (f : «expr ≃ₐ[ ] » B A C) :\n    is_cyclotomic_extension S A C :=\n  by\n  letI : Algebra B C := f.to_alg_hom.to_ring_hom.to_algebra\n  haveI : is_cyclotomic_extension {1} B C := singleton_one_of_algebra_map_bijective f.surjective\n  haveI : IsScalarTower A B C := IsScalarTower.of_ring_hom f.to_alg_hom\n  exact (iff_union_singleton_one _ _ _).2 (trans S {1} A B C f.injective)\n#align equiv Equiv\n-/\n\n",
 "Empty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n#print Empty /-\n/-- If `is_cyclotomic_extension ∅ A B`, then the image of `A` in `B` equals `B`. -/\ntheorem Empty [h : is_cyclotomic_extension ∅ A B] : («expr⊥» : Subalgebra A B) = «expr⊤» := by\n  simpa [Algebra.eq_top_iff, is_cyclotomic_extension_iff] using h\n#align empty Empty\n-/\n\n"}