{"discr_zeta_eq_discr_zeta_sub_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/-\nCopyright (c) 2022 Riccardo Brasca. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Riccardo Brasca\n-/\n/-- The discriminant of the power basis given by a primitive root of unity `ζ` is the same as the\ndiscriminant of the power basis given by `ζ - 1`. -/\ntheorem discr_zeta_eq_discr_zeta_sub_one (hζ : is_primitive_root ζ n) :\n    discr (exprℚ) (hζ.power_basis (exprℚ)).basis = discr (exprℚ) (hζ.sub_one_power_basis (exprℚ)).basis :=\n  by\n  haveI : number_field K := number_field.mk\n  have H₁ : (aeval (hζ.power_basis (exprℚ)).gen) (X - 1 : polynomial ℤ) = (hζ.sub_one_power_basis (exprℚ)).gen := by\n    simp\n  have H₂ : (aeval (hζ.sub_one_power_basis (exprℚ)).gen) (X + 1 : polynomial ℤ) = (hζ.power_basis (exprℚ)).gen := by\n    simp\n  refine'\n    discr_eq_discr_of_to_matrix_coeff_is_integral _ (fun i j => to_matrix_is_integral H₁ _ _ _ _) fun i j =>\n      to_matrix_is_integral H₂ _ _ _ _\n  · exact hζ.is_integral n.pos\n  · refine' minpoly.gcd_domain_eq_field_fractions' _ (hζ.is_integral n.pos)\n  · exact is_integral_sub (hζ.is_integral n.pos) is_integral_one\n  · refine' minpoly.gcd_domain_eq_field_fractions' _ _\n    exact is_integral_sub (hζ.is_integral n.pos) is_integral_one\n#align discr_zeta_eq_discr_zeta_sub_one discr_zeta_eq_discr_zeta_sub_one\n\n",
 "discr_prime_pow_ne_two'":
 "/-- If `p` is a prime and `is_cyclotomic_extension {p ^ (k + 1)} K L`, then the discriminant of\n`hζ.power_basis K` is `(-1) ^ (p ^ k * (p - 1) / 2) * p ^ (p ^ k * ((p - 1) * (k + 1) - 1))`\nif `irreducible (cyclotomic (p ^ (k + 1)) K))`, and `p ^ (k + 1) ≠ 2`. -/\ntheorem discr_prime_pow_ne_two' [is_cyclotomic_extension {p ^ (k + 1)} K L] [hp : fact (p : ℕ).prime]\n    (hζ : is_primitive_root ζ ↑(p ^ (k + 1))) (hirr : Irreducible (cyclotomic (↑(p ^ (k + 1)) : ℕ) K))\n    (hk : p ^ (k + 1) ≠ 2) :\n    discr K (hζ.power_basis K).basis =\n      (-1) ^ ((p : ℕ) ^ k * (p - 1) / 2) * p ^ ((p : ℕ) ^ k * ((p - 1) * (k + 1) - 1)) :=\n  by simpa [totient_prime_pow hp.out (succ_pos k)] using discr_prime_pow_ne_two hζ hirr hk\n#align discr_prime_pow_ne_two' discr_prime_pow_ne_two'\n\n",
 "discr_prime_pow_ne_two":
 "/-- If `p` is a prime and `is_cyclotomic_extension {p ^ (k + 1)} K L`, then the discriminant of\n`hζ.power_basis K` is `(-1) ^ ((p ^ (k + 1).totient) / 2) * p ^ (p ^ k * ((p - 1) * (k + 1) - 1))`\nif `irreducible (cyclotomic (p ^ (k + 1)) K))`, and `p ^ (k + 1) ≠ 2`. -/\ntheorem discr_prime_pow_ne_two [is_cyclotomic_extension {p ^ (k + 1)} K L] [hp : fact (p : ℕ).prime]\n    (hζ : is_primitive_root ζ ↑(p ^ (k + 1))) (hirr : Irreducible (cyclotomic (↑(p ^ (k + 1)) : ℕ) K))\n    (hk : p ^ (k + 1) ≠ 2) :\n    discr K (hζ.power_basis K).basis =\n      (-1) ^ ((p ^ (k + 1) : ℕ).totient / 2) * p ^ ((p : ℕ) ^ k * ((p - 1) * (k + 1) - 1)) :=\n  by\n  haveI hne := is_cyclotomic_extension.ne_zero' (p ^ (k + 1)) K L\n  have hp2 : p = 2 → 1 ≤ k := by\n    intro hp\n    refine' one_le_iff_ne_zero.2 fun h => _\n    rw [h, hp, zero_add, pow_one] at hk\n    exact hk rfl\n  rw [discr_power_basis_eq_norm, finrank _ hirr, hζ.power_basis_gen _, ← hζ.minpoly_eq_cyclotomic_of_irreducible hirr,\n    PNat.pow_coe, totient_prime_pow hp.out (succ_pos k)]\n  congr 1\n  · by_cases hptwo : p = 2\n    · obtain ⟨k₁, hk₁⟩ := nat.exists_eq_succ_of_ne_zero (one_le_iff_ne_zero.1 (hp2 hptwo))\n      rw [hk₁, succ_sub_one, hptwo, PNat.coe_bit0, PNat.one_coe, succ_sub_succ_eq_sub, tsub_zero, mul_one, pow_succ,\n        mul_assoc, nat.mul_div_cancel_left _ zero_lt_two, nat.mul_div_cancel_left _ zero_lt_two]\n      by_cases hk₁zero : k₁ = 0\n      · simp [hk₁zero]\n      obtain ⟨k₂, rfl⟩ := nat.exists_eq_succ_of_ne_zero hk₁zero\n      rw [pow_succ, mul_assoc, pow_mul (-1 : K), pow_mul (-1 : K), neg_one_sq, one_pow, one_pow]\n    · simp only [succ_sub_succ_eq_sub, tsub_zero]\n      replace hptwo : ↑p ≠ 2\n      · intro h\n        rw [← PNat.one_coe, ← PNat.coe_bit0, PNat.coe_inj] at h\n        exact hptwo h\n      obtain ⟨a, ha⟩ := even_sub_one_of_prime_ne_two hp.out hptwo\n      rw [mul_comm ((p : ℕ) ^ k), mul_assoc, ha]\n      nth_rw 1 [← mul_one a]\n      nth_rw 5 [← mul_one a]\n      rw [← nat.mul_succ, mul_comm a, mul_assoc, mul_assoc 2, nat.mul_div_cancel_left _ zero_lt_two,\n        nat.mul_div_cancel_left _ zero_lt_two, ← mul_assoc, mul_comm (a * (p : ℕ) ^ k), pow_mul, ← ha]\n      congr 1\n      refine'\n        Odd.neg_one_pow\n          (nat.even.sub_odd (Nat.succ_le_iff.2 (mul_pos (tsub_pos_iff_lt.2 hp.out.one_lt) (pow_pos hp.out.pos _)))\n            (Even.mul_right (nat.even_sub_one_of_prime_ne_two hp.out hptwo) _) odd_one)\n  · have H := congr_arg derivative (cyclotomic_prime_pow_mul_X_pow_sub_one K p k)\n    rw [derivative_mul, derivative_sub, derivative_one, sub_zero, derivative_X_pow, C_eq_nat_cast, derivative_sub,\n      derivative_one, sub_zero, derivative_X_pow, C_eq_nat_cast, ← PNat.pow_coe,\n      hζ.minpoly_eq_cyclotomic_of_irreducible hirr] at H\n    replace H := congr_arg (fun P => aeval ζ P) H\n    simp only [aeval_add, aeval_mul, minpoly.aeval, zero_mul, add_zero, aeval_nat_cast, _root_.map_sub, aeval_one,\n      aeval_X_pow] at H\n    replace H := congr_arg (algebra.norm K) H\n    have hnorm : (norm K) (ζ ^ (p : ℕ) ^ k - 1) = p ^ (p : ℕ) ^ k :=\n      by\n      by_cases hp : p = 2\n      · exact hζ.pow_sub_one_norm_prime_pow_of_one_le hirr rfl.le (hp2 hp)\n      · exact hζ.pow_sub_one_norm_prime_ne_two hirr rfl.le hp\n    rw [MonoidHom.map_mul, hnorm, MonoidHom.map_mul, ← map_nat_cast (algebra_map K L), algebra.norm_algebra_map,\n      finrank _ hirr, PNat.pow_coe, totient_prime_pow hp.out (succ_pos k), nat.sub_one, nat.pred_succ, ←\n      hζ.minpoly_eq_cyclotomic_of_irreducible hirr, map_pow, hζ.norm_eq_one hk hirr, one_pow, mul_one, cast_pow, ←\n      coe_coe, ← pow_mul, ← mul_assoc, mul_comm (k + 1), mul_assoc] at H\n    · have := mul_pos (succ_pos k) (tsub_pos_iff_lt.2 hp.out.one_lt)\n      rw [← succ_pred_eq_of_pos this, mul_succ, pow_add _ _ ((p : ℕ) ^ k)] at H\n      replace H := (mul_left_inj' fun h => _).1 H\n      · simpa only [← PNat.pow_coe, H, mul_comm _ (k + 1)]\n      · replace h := pow_eq_zero h\n        rw [coe_coe] at h\n        simpa using hne.1\n    all_goals infer_instance\n  all_goals infer_instance\n#align discr_prime_pow_ne_two discr_prime_pow_ne_two\n\n",
 "discr_prime_pow_eq_unit_mul_pow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/-- If `p` is a prime and `is_cyclotomic_extension {p ^ k} K L`, then there are `u : ℤˣ` and\n`n : ℕ` such that the discriminant of `hζ.power_basis K` is `u * p ^ n`. Often this is enough and\nless cumbersome to use than `is_cyclotomic_extension.discr_prime_pow`. -/\ntheorem discr_prime_pow_eq_unit_mul_pow [is_cyclotomic_extension {p ^ k} K L] [hp : fact (p : ℕ).prime]\n    (hζ : is_primitive_root ζ ↑(p ^ k)) (hirr : Irreducible (cyclotomic (↑(p ^ k) : ℕ) K)) :\n    ∃ (u : «expr ˣ» ℤ)(n : ℕ), discr K (hζ.power_basis K).basis = u * p ^ n :=\n  by\n  rw [discr_prime_pow hζ hirr]\n  by_cases heven : Even ((p ^ k : ℕ).totient / 2)\n  · refine' ⟨1, (p : ℕ) ^ (k - 1) * ((p - 1) * k - 1), by simp [heven.neg_one_pow]⟩\n  · exact ⟨-1, (p : ℕ) ^ (k - 1) * ((p - 1) * k - 1), by simp [(odd_iff_not_even.2 heven).neg_one_pow]⟩\n#align discr_prime_pow_eq_unit_mul_pow discr_prime_pow_eq_unit_mul_pow\n\n",
 "discr_prime_pow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ+» -/\n/-- If `p` is a prime and `is_cyclotomic_extension {p ^ k} K L`, then the discriminant of\n`hζ.power_basis K` is `(-1) ^ ((p ^ k).totient / 2) * p ^ (p ^ (k - 1) * ((p - 1) * k - 1))`\nif `irreducible (cyclotomic (p ^ k) K))`. Beware that in the cases `p ^ k = 1` and `p ^ k = 2`\nthe formula uses `1 / 2 = 0` and `0 - 1 = 0`. It is useful only to have a uniform result.\nSee also `is_cyclotomic_extension.discr_prime_pow_eq_unit_mul_pow`. -/\ntheorem discr_prime_pow [hcycl : is_cyclotomic_extension {p ^ k} K L] [hp : fact (p : ℕ).prime]\n    (hζ : is_primitive_root ζ ↑(p ^ k)) (hirr : Irreducible (cyclotomic (↑(p ^ k) : ℕ) K)) :\n    discr K (hζ.power_basis K).basis = (-1) ^ ((p ^ k : ℕ).totient / 2) * p ^ ((p : ℕ) ^ (k - 1) * ((p - 1) * k - 1)) :=\n  by\n  cases k\n  · simp only [coe_basis, pow_zero, power_basis_gen, totient_one, mul_zero, mul_one, show 1 / 2 = 0 by rfl, discr,\n      trace_matrix]\n    have hζone : ζ = 1 := by simpa using hζ\n    rw [hζ.power_basis_dim _, hζone, ← (algebra_map K L).map_one,\n      minpoly.eq_X_sub_C_of_algebra_map_inj _ (algebra_map K L).injective, nat_degree_X_sub_C]\n    simp only [trace_matrix, map_one, one_pow, matrix.det_unique, trace_form_apply, mul_one]\n    rw [← (algebra_map K L).map_one, trace_algebra_map, finrank _ hirr]\n    · simp\n    · infer_instance\n    · exact hcycl\n  · by_cases hk : p ^ (k + 1) = 2\n    · have hp : p = 2 :=\n        by\n        rw [← PNat.coe_inj, PNat.coe_bit0, PNat.one_coe, PNat.pow_coe, ← pow_one 2] at hk\n        replace hk := eq_of_prime_pow_eq (prime_iff.1 hp.out) (prime_iff.1 Nat.prime_two) (succ_pos _) hk\n        rwa [show 2 = ((2 : «exprℕ+») : ℕ) by simp, PNat.coe_inj] at hk\n      rw [hp, ← PNat.coe_inj, PNat.pow_coe, PNat.coe_bit0, PNat.one_coe] at hk\n      nth_rw 2 [← pow_one 2] at hk\n      replace hk := Nat.pow_right_injective rfl.le hk\n      rw [add_left_eq_self] at hk\n      simp only [hp, hk, pow_one, PNat.coe_bit0, PNat.one_coe] at hζ\n      simp only [hp, hk, show 1 / 2 = 0 by rfl, coe_basis, pow_one, power_basis_gen, PNat.coe_bit0, PNat.one_coe,\n        totient_two, pow_zero, mul_one, mul_zero]\n      rw [power_basis_dim, hζ.eq_neg_one_of_two_right, show (-1 : L) = algebra_map K L (-1) by simp,\n        minpoly.eq_X_sub_C_of_algebra_map_inj _ (algebra_map K L).injective, nat_degree_X_sub_C]\n      simp only [discr, trace_matrix, matrix.det_unique, fin.default_eq_zero, Fin.val_zero, pow_zero, trace_form_apply,\n        mul_one]\n      rw [← (algebra_map K L).map_one, trace_algebra_map, finrank _ hirr, hp, hk]\n      · simp\n      · infer_instance\n      · exact hcycl\n    · exact discr_prime_pow_ne_two hζ hirr hk\n#align discr_prime_pow discr_prime_pow\n\n",
 "discr_odd_prime":
 "/-- If `p` is an odd prime and `is_cyclotomic_extension {p} K L`, then\n`discr K (hζ.power_basis K).basis = (-1) ^ ((p - 1) / 2) * p ^ (p - 2)` if\n`irreducible (cyclotomic p K)`. -/\ntheorem discr_odd_prime [is_cyclotomic_extension {p} K L] [hp : fact (p : ℕ).prime] (hζ : is_primitive_root ζ p)\n    (hirr : Irreducible (cyclotomic p K)) (hodd : p ≠ 2) :\n    discr K (hζ.power_basis K).basis = (-1) ^ (((p : ℕ) - 1) / 2) * p ^ ((p : ℕ) - 2) :=\n  by\n  have : is_cyclotomic_extension {p ^ (0 + 1)} K L :=\n    by\n    rw [zero_add, pow_one]\n    infer_instance\n  have hζ' : is_primitive_root ζ ↑(p ^ (0 + 1)) := by simpa using hζ\n  convert discr_prime_pow_ne_two hζ' (by simpa [hirr] ) (by simp [hodd])\n  · rw [zero_add, pow_one, totient_prime hp.out]\n  · rw [pow_zero, one_mul, zero_add, mul_one, nat.sub_sub]\n#align discr_odd_prime discr_odd_prime\n\n"}