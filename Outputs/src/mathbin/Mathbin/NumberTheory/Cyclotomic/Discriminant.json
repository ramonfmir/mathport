{"discr_zeta_eq_discr_zeta_sub_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/-\nCopyright (c) 2022 Riccardo Brasca. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Riccardo Brasca\n-/\n/-- The discriminant of the power basis given by a primitive root of unity `ζ` is the same as the\ndiscriminant of the power basis given by `ζ - 1`. -/\ntheorem discr_zeta_eq_discr_zeta_sub_one (hζ : is_primitive_root ζ n) :\n    discr (exprℚ) (hζ.power_basis (exprℚ)).basis = discr (exprℚ) (hζ.sub_one_power_basis (exprℚ)).basis :=\n  by\n  haveI : number_field K := number_field.mk\n  have H₁ : (aeval (hζ.power_basis (exprℚ)).gen) (X - 1 : polynomial ℤ) = (hζ.sub_one_power_basis (exprℚ)).gen := by\n    simp\n  have H₂ : (aeval (hζ.sub_one_power_basis (exprℚ)).gen) (X + 1 : polynomial ℤ) = (hζ.power_basis (exprℚ)).gen := by\n    simp\n  refine'\n    discr_eq_discr_of_to_matrix_coeff_is_integral _ (fun i j => to_matrix_is_integral H₁ _ _ _ _) fun i j =>\n      to_matrix_is_integral H₂ _ _ _ _\n  · exact hζ.is_integral n.pos\n  · refine' minpoly.is_integrally_closed_eq_field_fractions' _ (hζ.is_integral n.pos)\n  · exact is_integral_sub (hζ.is_integral n.pos) is_integral_one\n  · refine' minpoly.is_integrally_closed_eq_field_fractions' _ _\n    exact is_integral_sub (hζ.is_integral n.pos) is_integral_one\n#align discr_zeta_eq_discr_zeta_sub_one discr_zeta_eq_discr_zeta_sub_one\n\n",
 "discr_prime_pow_ne_two'":
 "/-- If `p` is a prime and `is_cyclotomic_extension {p ^ (k + 1)} K L`, then the discriminant of\n`hζ.power_basis K` is `(-1) ^ (p ^ k * (p - 1) / 2) * p ^ (p ^ k * ((p - 1) * (k + 1) - 1))`\nif `irreducible (cyclotomic (p ^ (k + 1)) K))`, and `p ^ (k + 1) ≠ 2`. -/\ntheorem discr_prime_pow_ne_two' [is_cyclotomic_extension {p ^ (k + 1)} K L] [hp : Fact (p : ℕ).prime]\n    (hζ : is_primitive_root ζ ↑(p ^ (k + 1))) (hirr : Irreducible (cyclotomic (↑(p ^ (k + 1)) : ℕ) K))\n    (hk : p ^ (k + 1) ≠ 2) :\n    discr K (hζ.power_basis K).basis =\n      (-1) ^ ((p : ℕ) ^ k * (p - 1) / 2) * p ^ ((p : ℕ) ^ k * ((p - 1) * (k + 1) - 1)) :=\n  by simpa [totient_prime_pow hp.out (succ_pos k)] using discr_prime_pow_ne_two hζ hirr hk\n#align discr_prime_pow_ne_two' discr_prime_pow_ne_two'\n\n",
 "discr_prime_pow_ne_two":
 "/-- If `p` is a prime and `is_cyclotomic_extension {p ^ (k + 1)} K L`, then the discriminant of\n`hζ.power_basis K` is `(-1) ^ ((p ^ (k + 1).totient) / 2) * p ^ (p ^ k * ((p - 1) * (k + 1) - 1))`\nif `irreducible (cyclotomic (p ^ (k + 1)) K))`, and `p ^ (k + 1) ≠ 2`. -/\ntheorem discr_prime_pow_ne_two [is_cyclotomic_extension {p ^ (k + 1)} K L] [hp : Fact (p : ℕ).prime]\n    (hζ : is_primitive_root ζ ↑(p ^ (k + 1))) (hirr : Irreducible (cyclotomic (↑(p ^ (k + 1)) : ℕ) K))\n    (hk : p ^ (k + 1) ≠ 2) :\n    discr K (hζ.power_basis K).basis =\n      (-1) ^ ((p ^ (k + 1) : ℕ).totient / 2) * p ^ ((p : ℕ) ^ k * ((p - 1) * (k + 1) - 1)) :=\n  by\n  haveI hne := is_cyclotomic_extension.ne_zero' (p ^ (k + 1)) K L\n  rw [discr_power_basis_eq_norm, finrank L hirr, hζ.power_basis_gen _, ← hζ.minpoly_eq_cyclotomic_of_irreducible hirr,\n    PNat.pow_coe, totient_prime_pow hp.out (succ_pos k), succ_sub_one]\n  have hp2 : p = 2 → k ≠ 0 := by\n    rintro rfl rfl\n    exact absurd rfl hk\n  congr 1\n  · rcases eq_or_ne p 2 with (rfl | hp2)\n    · rcases nat.exists_eq_succ_of_ne_zero (hp2 rfl) with ⟨k, rfl⟩\n      rw [PNat.coe_bit0, PNat.one_coe, succ_sub_succ_eq_sub, tsub_zero, mul_one, pow_succ, mul_assoc,\n        nat.mul_div_cancel_left _ zero_lt_two, nat.mul_div_cancel_left _ zero_lt_two]\n      cases k\n      · simp\n      · rw [pow_succ, (even_two.mul_right _).neg_one_pow, ((even_two.mul_right _).mul_right _).neg_one_pow]\n    · replace hp2 : (p : ℕ) ≠ 2\n      · rwa [ne.def, ← PNat.one_coe, ← PNat.coe_bit0, PNat.coe_inj]\n      have hpo : Odd (p : ℕ) := hp.out.odd_of_ne_two hp2\n      obtain ⟨a, ha⟩ := (hp.out.even_sub_one hp2).two_dvd\n      rw [ha, mul_left_comm, mul_assoc, nat.mul_div_cancel_left _ two_pos, nat.mul_div_cancel_left _ two_pos,\n        mul_right_comm, pow_mul, (hpo.pow.mul _).neg_one_pow, pow_mul, hpo.pow.neg_one_pow]\n      refine' Nat.Even.sub_odd _ (even_two_mul _) odd_one\n      rw [mul_left_comm, ← ha]\n      exact one_le_mul (one_le_pow _ _ hp.1.pos) (succ_le_iff.2 <| tsub_pos_of_lt hp.1.one_lt)\n  · have H := congr_arg derivative (cyclotomic_prime_pow_mul_X_pow_sub_one K p k)\n    rw [derivative_mul, derivative_sub, derivative_one, sub_zero, derivative_X_pow, C_eq_nat_cast, derivative_sub,\n      derivative_one, sub_zero, derivative_X_pow, C_eq_nat_cast, ← PNat.pow_coe,\n      hζ.minpoly_eq_cyclotomic_of_irreducible hirr] at H\n    replace H := congr_arg (fun P => aeval ζ P) H\n    simp only [aeval_add, aeval_mul, minpoly.aeval, MulZeroClass.zero_mul, add_zero, aeval_nat_cast, _root_.map_sub,\n      aeval_one, aeval_X_pow] at H\n    replace H := congr_arg (algebra.norm K) H\n    have hnorm : (norm K) (ζ ^ (p : ℕ) ^ k - 1) = p ^ (p : ℕ) ^ k :=\n      by\n      by_cases hp : p = 2\n      · exact hζ.pow_sub_one_norm_prime_pow_of_ne_zero hirr le_rfl (hp2 hp)\n      · exact hζ.pow_sub_one_norm_prime_ne_two hirr le_rfl hp\n    rw [MonoidHom.map_mul, hnorm, MonoidHom.map_mul, ← map_natCast (algebraMap K L), algebra.norm_algebra_map,\n      finrank L hirr, PNat.pow_coe, totient_prime_pow hp.out (succ_pos k), nat.sub_one, nat.pred_succ, ←\n      hζ.minpoly_eq_cyclotomic_of_irreducible hirr, map_pow, hζ.norm_eq_one hk hirr, one_pow, mul_one, cast_pow, ←\n      coe_coe, ← pow_mul, ← mul_assoc, mul_comm (k + 1), mul_assoc] at H\n    · have := mul_pos (succ_pos k) (tsub_pos_of_lt hp.out.one_lt)\n      rw [← succ_pred_eq_of_pos this, mul_succ, pow_add _ _ ((p : ℕ) ^ k)] at H\n      replace H := (mul_left_inj' fun h => _).1 H\n      · simpa only [← PNat.pow_coe, H, mul_comm _ (k + 1)]\n      · replace h := pow_eq_zero h\n        rw [coe_coe] at h\n        simpa using hne.1\n#align discr_prime_pow_ne_two discr_prime_pow_ne_two\n\n",
 "discr_prime_pow_eq_unit_mul_pow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/-- If `p` is a prime and `is_cyclotomic_extension {p ^ k} K L`, then there are `u : ℤˣ` and\n`n : ℕ` such that the discriminant of `hζ.power_basis K` is `u * p ^ n`. Often this is enough and\nless cumbersome to use than `is_cyclotomic_extension.discr_prime_pow`. -/\ntheorem discr_prime_pow_eq_unit_mul_pow [is_cyclotomic_extension {p ^ k} K L] [hp : Fact (p : ℕ).prime]\n    (hζ : is_primitive_root ζ ↑(p ^ k)) (hirr : Irreducible (cyclotomic (↑(p ^ k) : ℕ) K)) :\n    ∃ (u : «expr ˣ» ℤ)(n : ℕ), discr K (hζ.power_basis K).basis = u * p ^ n :=\n  by\n  rw [discr_prime_pow hζ hirr]\n  by_cases heven : Even ((p ^ k : ℕ).totient / 2)\n  · refine' ⟨1, (p : ℕ) ^ (k - 1) * ((p - 1) * k - 1), by simp [heven.neg_one_pow]⟩\n  · exact ⟨-1, (p : ℕ) ^ (k - 1) * ((p - 1) * k - 1), by simp [(odd_iff_not_even.2 heven).neg_one_pow]⟩\n#align discr_prime_pow_eq_unit_mul_pow discr_prime_pow_eq_unit_mul_pow\n\n",
 "discr_prime_pow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ+» -/\n/-- If `p` is a prime and `is_cyclotomic_extension {p ^ k} K L`, then the discriminant of\n`hζ.power_basis K` is `(-1) ^ ((p ^ k).totient / 2) * p ^ (p ^ (k - 1) * ((p - 1) * k - 1))`\nif `irreducible (cyclotomic (p ^ k) K))`. Beware that in the cases `p ^ k = 1` and `p ^ k = 2`\nthe formula uses `1 / 2 = 0` and `0 - 1 = 0`. It is useful only to have a uniform result.\nSee also `is_cyclotomic_extension.discr_prime_pow_eq_unit_mul_pow`. -/\ntheorem discr_prime_pow [hcycl : is_cyclotomic_extension {p ^ k} K L] [hp : Fact (p : ℕ).prime]\n    (hζ : is_primitive_root ζ ↑(p ^ k)) (hirr : Irreducible (cyclotomic (↑(p ^ k) : ℕ) K)) :\n    discr K (hζ.power_basis K).basis = (-1) ^ ((p ^ k : ℕ).totient / 2) * p ^ ((p : ℕ) ^ (k - 1) * ((p - 1) * k - 1)) :=\n  by\n  cases k\n  · simp only [coe_basis, pow_zero, power_basis_gen, totient_one, MulZeroClass.mul_zero, mul_one, show 1 / 2 = 0 by rfl,\n      discr, trace_matrix]\n    have hζone : ζ = 1 := by simpa using hζ\n    rw [hζ.power_basis_dim _, hζone, ← (algebraMap K L).map_one,\n      minpoly.eq_X_sub_C_of_algebra_map_inj _ (algebraMap K L).injective, nat_degree_X_sub_C]\n    simp only [trace_matrix, map_one, one_pow, Matrix.det_unique, trace_form_apply, mul_one]\n    rw [← (algebraMap K L).map_one, trace_algebra_map, finrank _ hirr]\n    · simp\n    · infer_instance\n    · exact hcycl\n  · by_cases hk : p ^ (k + 1) = 2\n    · have hp : p = 2 :=\n        by\n        rw [← PNat.coe_inj, PNat.coe_bit0, PNat.one_coe, PNat.pow_coe, ← pow_one 2] at hk\n        replace hk := eq_of_prime_pow_eq (prime_iff.1 hp.out) (prime_iff.1 Nat.prime_two) (succ_pos _) hk\n        rwa [show 2 = ((2 : «exprℕ+») : ℕ) by simp, PNat.coe_inj] at hk\n      rw [hp, ← PNat.coe_inj, PNat.pow_coe, PNat.coe_bit0, PNat.one_coe] at hk\n      nth_rw 2 [← pow_one 2] at hk\n      replace hk := Nat.pow_right_injective rfl.le hk\n      rw [add_left_eq_self] at hk\n      simp only [hp, hk, pow_one, PNat.coe_bit0, PNat.one_coe] at hζ\n      simp only [hp, hk, show 1 / 2 = 0 by rfl, coe_basis, pow_one, power_basis_gen, PNat.coe_bit0, PNat.one_coe,\n        totient_two, pow_zero, mul_one, MulZeroClass.mul_zero]\n      rw [power_basis_dim, hζ.eq_neg_one_of_two_right, show (-1 : L) = algebraMap K L (-1) by simp,\n        minpoly.eq_X_sub_C_of_algebra_map_inj _ (algebraMap K L).injective, nat_degree_X_sub_C]\n      simp only [discr, trace_matrix_apply, Matrix.det_unique, Fin.default_eq_zero, Fin.val_zero, pow_zero,\n        trace_form_apply, mul_one]\n      rw [← (algebraMap K L).map_one, trace_algebra_map, finrank _ hirr, hp, hk]\n      · simp\n      · infer_instance\n      · exact hcycl\n    · exact discr_prime_pow_ne_two hζ hirr hk\n#align discr_prime_pow discr_prime_pow\n\n",
 "discr_odd_prime":
 "/-- If `p` is an odd prime and `is_cyclotomic_extension {p} K L`, then\n`discr K (hζ.power_basis K).basis = (-1) ^ ((p - 1) / 2) * p ^ (p - 2)` if\n`irreducible (cyclotomic p K)`. -/\ntheorem discr_odd_prime [is_cyclotomic_extension {p} K L] [hp : Fact (p : ℕ).prime] (hζ : is_primitive_root ζ p)\n    (hirr : Irreducible (cyclotomic p K)) (hodd : p ≠ 2) :\n    discr K (hζ.power_basis K).basis = (-1) ^ (((p : ℕ) - 1) / 2) * p ^ ((p : ℕ) - 2) :=\n  by\n  have : is_cyclotomic_extension {p ^ (0 + 1)} K L :=\n    by\n    rw [zero_add, pow_one]\n    infer_instance\n  have hζ' : is_primitive_root ζ ↑(p ^ (0 + 1)) := by simpa using hζ\n  convert discr_prime_pow_ne_two hζ' (by simpa [hirr] ) (by simp [hodd])\n  · rw [zero_add, pow_one, totient_prime hp.out]\n  · rw [pow_zero, one_mul, zero_add, mul_one, nat.sub_sub]\n#align discr_odd_prime discr_odd_prime\n\n"}