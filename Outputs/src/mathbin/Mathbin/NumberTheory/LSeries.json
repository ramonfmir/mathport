{"zeta_l_series_summable_iff_one_lt_re":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `arithmetic_function.zeta -/\ntheorem zeta_l_series_summable_iff_one_lt_re {z : exprℂ} : l_series_summable (arithmetic_function.zeta) z ↔ 1 < z.re :=\n  by\n  rw [← l_series_summable_iff_of_re_eq_re (complex.of_real_re z.re), l_series_summable, ← summable_norm_iff, ←\n    real.summable_one_div_nat_rpow, iff_iff_eq]\n  by_cases h0 : z.re = 0\n  · rw [h0, ← summable_nat_add_iff 1]\n    swap\n    · infer_instance\n    apply congr rfl\n    ext n\n    simp [n.succ_ne_zero]\n  · apply congr rfl\n    ext ⟨- | n⟩\n    · simp [h0]\n    simp only [cast_zero, nat_coe_apply, zeta_apply, succ_ne_zero, if_false, cast_succ, one_div, complex.norm_eq_abs,\n      map_inv₀, complex.abs_cpow_real, inv_inj, zero_add]\n    rw [← cast_one, ← cast_add, complex.abs_of_nat, cast_add, cast_one]\n#align zeta_l_series_summable_iff_one_lt_re zeta_l_series_summable_iff_one_lt_re\n\n",
 "l_series_summable_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n@[simp]\ntheorem l_series_summable_zero {z : exprℂ} : l_series_summable 0 z := by simp [l_series_summable, summable_zero]\n#align l_series_summable_zero l_series_summable_zero\n\n",
 "l_series_summable_of_bounded_of_one_lt_real":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem l_series_summable_of_bounded_of_one_lt_real {f : arithmetic_function (exprℂ)} {m : exprℝ}\n    (h : ∀ n : ℕ, complex.abs (f n) ≤ m) {z : exprℝ} (hz : 1 < z) : f.l_series_summable z :=\n  by\n  by_cases h0 : m = 0\n  · subst h0\n    have hf : f = 0 := arithmetic_function.ext fun n => complex.abs.eq_zero.1 (le_antisymm (h n) (complex.abs.nonneg _))\n    simp [hf]\n  refine' summable_of_norm_bounded (fun n : ℕ => m / n ^ z) _ _\n  · simp_rw [div_eq_mul_inv]\n    exact (summable_mul_left_iff h0).1 (real.summable_nat_rpow_inv.2 hz)\n  · intro n\n    have hm : 0 ≤ m := le_trans (complex.abs.nonneg _) (h 0)\n    cases n\n    · simp [hm, real.zero_rpow (ne_of_gt (lt_trans real.zero_lt_one hz))]\n    simp only [map_div₀, complex.norm_eq_abs]\n    apply div_le_div hm (h _) (real.rpow_pos_of_pos (nat.cast_pos.2 n.succ_pos) _) (le_of_eq _)\n    rw [complex.abs_cpow_real, complex.abs_cast_nat]\n#align l_series_summable_of_bounded_of_one_lt_real l_series_summable_of_bounded_of_one_lt_real\n\n",
 "l_series_summable_of_bounded_of_one_lt_re":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\ntheorem l_series_summable_of_bounded_of_one_lt_re {f : arithmetic_function (exprℂ)} {m : exprℝ}\n    (h : ∀ n : ℕ, complex.abs (f n) ≤ m) {z : exprℂ} (hz : 1 < z.re) : f.l_series_summable z :=\n  by\n  rw [← l_series_summable_iff_of_re_eq_re (complex.of_real_re z.re)]\n  apply l_series_summable_of_bounded_of_one_lt_real h\n  exact hz\n#align l_series_summable_of_bounded_of_one_lt_re l_series_summable_of_bounded_of_one_lt_re\n\n",
 "l_series_summable_iff_of_re_eq_re":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\ntheorem l_series_summable_iff_of_re_eq_re {f : arithmetic_function (exprℂ)} {w z : exprℂ} (h : w.re = z.re) :\n    f.l_series_summable w ↔ f.l_series_summable z :=\n  by\n  suffices h : ∀ n : ℕ, complex.abs (f n) / complex.abs (↑n ^ w) = complex.abs (f n) / complex.abs (↑n ^ z)\n  · simp [l_series_summable, ← summable_norm_iff, h, complex.norm_eq_abs]\n  intro n\n  cases n\n  · simp\n  apply congr rfl\n  have h0 : (n.succ : exprℂ) ≠ 0 := by\n    rw [ne.def, Nat.cast_eq_zero]\n    apply n.succ_ne_zero\n  rw [complex.cpow_def, complex.cpow_def, if_neg h0, if_neg h0, complex.abs_exp_eq_iff_re_eq]\n  simp only [h, complex.mul_re, mul_eq_mul_left_iff, sub_right_inj]\n  right\n  rw [complex.log_im, ← complex.of_real_nat_cast]\n  exact complex.arg_of_real_of_nonneg (le_of_lt (cast_pos.2 n.succ_pos))\n#align l_series_summable_iff_of_re_eq_re l_series_summable_iff_of_re_eq_re\n\n",
 "l_series_eq_zero_of_not_l_series_summable":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/-\nCopyright (c) 2021 Aaron Anderson. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Aaron Anderson\n-/\ntheorem l_series_eq_zero_of_not_l_series_summable (f : arithmetic_function (exprℂ)) (z : exprℂ) :\n    ¬f.l_series_summable z → f.l_series z = 0 :=\n  tsum_eq_zero_of_not_summable\n#align l_series_eq_zero_of_not_l_series_summable l_series_eq_zero_of_not_l_series_summable\n\n",
 "l_series_add":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n@[simp]\ntheorem l_series_add {f g : arithmetic_function (exprℂ)} {z : exprℂ} (hf : f.l_series_summable z)\n    (hg : g.l_series_summable z) : (f + g).l_series z = f.l_series z + g.l_series z :=\n  by\n  simp only [l_series, add_apply]\n  rw [← tsum_add hf hg]\n  apply congr rfl (funext fun n => _)\n  apply _root_.add_div\n#align l_series_add l_series_add\n\n"}