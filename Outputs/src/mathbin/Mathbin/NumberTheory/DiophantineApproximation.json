{"infinite_rat_abs_sub_lt_one_div_denom_sq_of_irrational":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⌊ ⌋» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/-- If `ξ` is an irrational real number, then there are infinitely many good\nrational approximations to `ξ`. -/\ntheorem infinite_rat_abs_sub_lt_one_div_denom_sq_of_irrational {ξ : exprℝ} (hξ : irrational ξ) :\n    { q : exprℚ | |ξ - q| < 1 / q.denom ^ 2 }.infinite :=\n  by\n  refine' or.resolve_left (set.finite_or_infinite _) fun h => _\n  obtain ⟨q, _, hq⟩ :=\n    exists_min_image { q : exprℚ | |ξ - q| < 1 / q.denom ^ 2 } (fun q => |ξ - q|) h\n      ⟨«expr⌊ ⌋» ξ, by simp [abs_of_nonneg, Int.fract_lt_one]⟩\n  obtain ⟨q', hmem, hbetter⟩ := exists_rat_abs_sub_lt_and_lt_of_irrational hξ q\n  exact lt_irrefl _ (lt_of_le_of_lt (hq q' hmem) hbetter)\n#align infinite_rat_abs_sub_lt_one_div_denom_sq_of_irrational infinite_rat_abs_sub_lt_one_div_denom_sq_of_irrational\n\n",
 "infinite_rat_abs_sub_lt_one_div_denom_sq_iff_irrational":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/-- The set of good rational approximations to a real number `ξ` is infinite if and only if\n`ξ` is irrational. -/\ntheorem real.infinite_rat_abs_sub_lt_one_div_denom_sq_iff_irrational (ξ : exprℝ) :\n    { q : exprℚ | |ξ - q| < 1 / q.denom ^ 2 }.infinite ↔ irrational ξ :=\n  by\n  refine'\n    ⟨fun h => (irrational_iff_ne_rational ξ).mpr fun a b H => set.not_infinite.mpr _ h,\n      real.infinite_rat_abs_sub_lt_one_div_denom_sq_of_irrational⟩\n  convert rat.finite_rat_abs_sub_lt_one_div_denom_sq ((a : exprℚ) / b)\n  ext q\n  rw [H, (by push_cast : (1 : exprℝ) / q.denom ^ 2 = (1 / q.denom ^ 2 : exprℚ))]\n  norm_cast\n#align\n  real.infinite_rat_abs_sub_lt_one_div_denom_sq_iff_irrational real.infinite_rat_abs_sub_lt_one_div_denom_sq_iff_irrational\n\n",
 "finite_rat_abs_sub_lt_one_div_denom_sq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⌈ ⌉» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⌊ ⌋» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/-- A rational number has only finitely many good rational approximations. -/\ntheorem finite_rat_abs_sub_lt_one_div_denom_sq (ξ : exprℚ) : { q : exprℚ | |ξ - q| < 1 / q.denom ^ 2 }.finite :=\n  by\n  let f : exprℚ → ℤ × ℕ := fun q => (q.num, q.denom)\n  set s := { q : exprℚ | |ξ - q| < 1 / q.denom ^ 2 }\n  have hinj : function.injective f := by\n    intro a b hab\n    simp only [prod.mk.inj_iff] at hab\n    rw [← Rat.num_div_den a, ← Rat.num_div_den b, hab.1, hab.2]\n  have H :\n    «expr '' » f s ⊆\n      «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n        (lower_set.prod (Icc («expr⌈ ⌉» (ξ * y) - 1) («expr⌊ ⌋» (ξ * y) + 1)) {y}) :=\n    by\n    intro xy hxy\n    simp only [mem_image, mem_set_of_eq] at hxy\n    obtain ⟨q, hq₁, hq₂⟩ := hxy\n    obtain ⟨hd, hn⟩ := denom_le_and_le_num_le_of_sub_lt_one_div_denom_sq hq₁\n    simp_rw [mem_Union]\n    refine' ⟨q.denom, set.mem_Ioc.mpr ⟨q.pos, hd⟩, _⟩\n    simp only [prod_singleton, mem_image, mem_Icc, (congr_arg prod.snd (eq.symm hq₂)).trans rfl]\n    exact ⟨q.num, hn, hq₂⟩\n  refine' finite.of_finite_image (finite.subset _ H) (inj_on_of_injective hinj s)\n  exact finite.bUnion (finite_Ioc _ _) fun x hx => finite.prod (finite_Icc _ _) (finite_singleton _)\n#align finite_rat_abs_sub_lt_one_div_denom_sq finite_rat_abs_sub_lt_one_div_denom_sq\n\n",
 "exists_rat_abs_sub_lt_and_lt_of_irrational":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/-- Given any rational approximation `q` to the irrational real number `ξ`, there is\na good rational approximation `q'` such that `|ξ - q'| < |ξ - q|`. -/\ntheorem exists_rat_abs_sub_lt_and_lt_of_irrational {ξ : exprℝ} (hξ : irrational ξ) (q : exprℚ) :\n    ∃ q' : exprℚ, |ξ - q'| < 1 / q'.denom ^ 2 ∧ |ξ - q'| < |ξ - q| :=\n  by\n  have h := abs_pos.mpr (sub_ne_zero.mpr <| irrational.ne_rat hξ q)\n  obtain ⟨m, hm⟩ := exists_nat_gt (1 / |ξ - q|)\n  have m_pos : (0 : exprℝ) < m := (one_div_pos.mpr h).trans hm\n  obtain ⟨q', hbd, hden⟩ := exists_rat_abs_sub_le_and_denom_le ξ (nat.cast_pos.mp m_pos)\n  have den_pos : (0 : exprℝ) < q'.denom := nat.cast_pos.mpr q'.pos\n  have md_pos := mul_pos (add_pos m_pos zero_lt_one) den_pos\n  refine'\n    ⟨q', lt_of_le_of_lt hbd _,\n      lt_of_le_of_lt hbd <|\n        (one_div_lt md_pos h).mpr <|\n          hm.trans <|\n            lt_of_lt_of_le (lt_add_one _) <|\n              (le_mul_iff_one_le_right <| add_pos m_pos zero_lt_one).mpr <| by exact_mod_cast (q'.pos : 1 ≤ q'.denom)⟩\n  rw [sq, one_div_lt_one_div md_pos (mul_pos den_pos den_pos), mul_lt_mul_right den_pos]\n  exact lt_add_of_le_of_pos (nat.cast_le.mpr hden) zero_lt_one\n#align exists_rat_abs_sub_lt_and_lt_of_irrational exists_rat_abs_sub_lt_and_lt_of_irrational\n\n",
 "exists_rat_abs_sub_le_and_denom_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/-- *Dirichlet's approximation theorem:*\nFor any real number `ξ` and positive natural `n`, there is a fraction `q`\nsuch that `q.denom ≤ n` and `|ξ - q| ≤ 1/((n+1)*q.denom)`. -/\ntheorem exists_rat_abs_sub_le_and_denom_le (ξ : exprℝ) {n : ℕ} (n_pos : 0 < n) :\n    ∃ q : exprℚ, |ξ - q| ≤ 1 / ((n + 1) * q.denom) ∧ q.denom ≤ n :=\n  by\n  obtain ⟨j, k, hk₀, hk₁, h⟩ := exists_int_int_abs_mul_sub_le ξ n_pos\n  have hk₀' : (0 : exprℝ) < k := int.cast_pos.mpr hk₀\n  have hden : ((j / k : exprℚ).denom : ℤ) ≤ k :=\n    by\n    convert le_of_dvd hk₀ (Rat.den_dvd j k)\n    exact Rat.coe_int_div_eq_divInt\n  refine' ⟨j / k, _, nat.cast_le.mp (hden.trans hk₁)⟩\n  rw [← div_div, le_div_iff (nat.cast_pos.mpr <| Rat.pos _ : (0 : exprℝ) < _)]\n  refine' (mul_le_mul_of_nonneg_left (int.cast_le.mpr hden : _ ≤ (k : exprℝ)) (abs_nonneg _)).trans _\n  rwa [← abs_of_pos hk₀', Rat.cast_div, Rat.cast_coe_int, Rat.cast_coe_int, ← abs_mul, sub_mul,\n    div_mul_cancel _ hk₀'.ne', mul_comm]\n#align exists_rat_abs_sub_le_and_denom_le exists_rat_abs_sub_le_and_denom_le\n\n",
 "exists_nat_abs_mul_sub_round_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- *Dirichlet's approximation theorem:*\nFor any real number `ξ` and positive natural `n`, there is a natural number `k`,\nwith `0 < k ≤ n` such that `|k*ξ - round(k*ξ)| ≤ 1/(n+1)`.\n-/\ntheorem exists_nat_abs_mul_sub_round_le (ξ : exprℝ) {n : ℕ} (n_pos : 0 < n) :\n    ∃ k : ℕ, 0 < k ∧ k ≤ n ∧ |↑k * ξ - round (↑k * ξ)| ≤ 1 / (n + 1) :=\n  by\n  obtain ⟨j, k, hk₀, hk₁, h⟩ := exists_int_int_abs_mul_sub_le ξ n_pos\n  have hk := to_nat_of_nonneg hk₀.le\n  rw [← hk] at hk₀ hk₁ h\n  exact ⟨k.to_nat, coe_nat_pos.mp hk₀, nat.cast_le.mp hk₁, (round_le (↑k.to_nat * ξ) j).trans h⟩\n#align exists_nat_abs_mul_sub_round_le exists_nat_abs_mul_sub_round_le\n\n",
 "exists_int_int_abs_mul_sub_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⌊ ⌋» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⌊ ⌋» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⌊ ⌋» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⌊ ⌋» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-\nCopyright (c) 2022 Michael Stoll. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Michael Geißer, Michael Stoll\n-/\n/-- *Dirichlet's approximation theorem:*\nFor any real number `ξ` and positive natural `n`, there are integers `j` and `k`,\nwith `0 < k ≤ n` and `|k*ξ - j| ≤ 1/(n+1)`.\n\nSee also `real.exists_nat_abs_mul_sub_round_le`. -/\ntheorem exists_int_int_abs_mul_sub_le (ξ : exprℝ) {n : ℕ} (n_pos : 0 < n) :\n    ∃ j k : ℤ, 0 < k ∧ k ≤ n ∧ |↑k * ξ - j| ≤ 1 / (n + 1) :=\n  by\n  let f : ℤ → ℤ := fun m => «expr⌊ ⌋» (fract (ξ * m) * (n + 1))\n  have hn : 0 < (n : exprℝ) + 1 := by exact_mod_cast nat.succ_pos _\n  have hfu := fun m : ℤ => mul_lt_of_lt_one_left hn <| fract_lt_one (ξ * ↑m)\n  conv in |_| ≤ _ => rw [mul_comm, le_div_iff hn, ← abs_of_pos hn, ← abs_mul]\n  let D := Icc (0 : ℤ) n\n  by_cases H : ∃ m ∈ D, f m = n\n  · obtain ⟨m, hm, hf⟩ := H\n    have hf' : ((n : ℤ) : exprℝ) ≤ fract (ξ * m) * (n + 1) := hf ▸ floor_le (fract (ξ * m) * (n + 1))\n    have hm₀ : 0 < m :=\n      by\n      have hf₀ : f 0 = 0 := by\n        simp only [floor_eq_zero_iff, algebra_map.coe_zero, mul_zero, fract_zero, zero_mul, Set.left_mem_Ico,\n          zero_lt_one]\n      refine' Ne.lt_of_le (fun h => n_pos.ne _) (mem_Icc.mp hm).1\n      exact_mod_cast hf₀.symm.trans (h.symm ▸ hf : f 0 = n)\n    refine' ⟨«expr⌊ ⌋» (ξ * m) + 1, m, hm₀, (mem_Icc.mp hm).2, _⟩\n    rw [cast_add, ← sub_sub, sub_mul, cast_one, one_mul, abs_le]\n    refine' ⟨le_sub_iff_add_le.mpr _, sub_le_iff_le_add.mpr <| le_of_lt <| (hfu m).trans <| lt_one_add _⟩\n    simpa only [neg_add_cancel_comm_assoc] using hf'\n  · simp_rw [not_exists] at H\n    have hD : (Ico (0 : ℤ) n).card < D.card := by\n      rw [card_Icc, card_Ico]\n      exact lt_add_one n\n    have hfu' : ∀ m, f m ≤ n := fun m => lt_add_one_iff.mp (floor_lt.mpr (by exact_mod_cast hfu m))\n    have hwd : ∀ m : ℤ, m ∈ D → f m ∈ Ico (0 : ℤ) n := fun x hx =>\n      mem_Ico.mpr ⟨floor_nonneg.mpr (mul_nonneg (fract_nonneg (ξ * x)) hn.le), Ne.lt_of_le (H x hx) (hfu' x)⟩\n    have : ∃ (x : ℤ)(hx : x ∈ D)(y : ℤ)(hy : y ∈ D), x < y ∧ f x = f y :=\n      by\n      obtain ⟨x, hx, y, hy, x_ne_y, hxy⟩ := exists_ne_map_eq_of_card_lt_of_maps_to hD hwd\n      rcases lt_trichotomy x y with (h | h | h)\n      exacts[⟨x, hx, y, hy, h, hxy⟩, false.elim (x_ne_y h), ⟨y, hy, x, hx, h, hxy.symm⟩]\n    obtain ⟨x, hx, y, hy, x_lt_y, hxy⟩ := this\n    refine'\n      ⟨«expr⌊ ⌋» (ξ * y) - «expr⌊ ⌋» (ξ * x), y - x, sub_pos_of_lt x_lt_y,\n        sub_le_iff_le_add.mpr <| le_add_of_le_of_nonneg (mem_Icc.mp hy).2 (mem_Icc.mp hx).1, _⟩\n    convert_to |fract (ξ * y) * (n + 1) - fract (ξ * x) * (n + 1)| ≤ 1\n    · congr\n      push_cast\n      simp only [fract]\n      ring\n    exact (abs_sub_lt_one_of_floor_eq_floor hxy.symm).le\n#align exists_int_int_abs_mul_sub_le exists_int_int_abs_mul_sub_le\n\n",
 "denom_le_and_le_num_le_of_sub_lt_one_div_denom_sq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⌈ ⌉» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⌊ ⌋» -/\n/-- If `ξ` is rational, then the good rational approximations to `ξ` have bounded\nnumerator and denominator. -/\ntheorem denom_le_and_le_num_le_of_sub_lt_one_div_denom_sq {ξ q : exprℚ} (h : |ξ - q| < 1 / q.denom ^ 2) :\n    q.denom ≤ ξ.denom ∧ «expr⌈ ⌉» (ξ * q.denom) - 1 ≤ q.num ∧ q.num ≤ «expr⌊ ⌋» (ξ * q.denom) + 1 :=\n  by\n  have hq₀ : (0 : exprℚ) < q.denom := nat.cast_pos.mpr q.pos\n  replace h : |ξ * q.denom - q.num| < 1 / q.denom\n  · rw [← mul_lt_mul_right hq₀] at h\n    conv_lhs at h => rw [← abs_of_pos hq₀, ← abs_mul, sub_mul, mul_denom_eq_num]\n    rwa [sq, div_mul, mul_div_cancel_left _ hq₀.ne'] at h\n  constructor\n  · rcases eq_or_ne ξ q with (rfl | H)\n    · exact le_rfl\n    · have hξ₀ : (0 : exprℚ) < ξ.denom := nat.cast_pos.mpr ξ.pos\n      rw [← Rat.num_div_den ξ, div_mul_eq_mul_div, div_sub' _ _ _ hξ₀.ne', abs_div, abs_of_pos hξ₀, div_lt_iff hξ₀,\n        div_mul_comm, mul_one] at h\n      refine' nat.cast_le.mp ((one_lt_div hq₀).mp <| lt_of_le_of_lt _ h).le\n      norm_cast\n      rw [mul_comm _ q.num]\n      exact Int.one_le_abs (sub_ne_zero_of_ne <| mt rat.eq_iff_mul_eq_mul.mpr H)\n  · obtain ⟨h₁, h₂⟩ :=\n      abs_sub_lt_iff.mp\n        (h.trans_le <| (one_div_le zero_lt_one hq₀).mp <| (@one_div_one (exprℚ) _).symm ▸ nat.cast_le.mpr q.pos)\n    rw [sub_lt_iff_lt_add, add_comm] at h₁ h₂\n    rw [← sub_lt_iff_lt_add] at h₂\n    norm_cast  at h₁ h₂\n    exact ⟨sub_le_iff_le_add.mpr (int.ceil_le.mpr h₁.le), sub_le_iff_le_add.mp (int.le_floor.mpr h₂.le)⟩\n#align denom_le_and_le_num_le_of_sub_lt_one_div_denom_sq denom_le_and_le_num_le_of_sub_lt_one_div_denom_sq\n\n"}