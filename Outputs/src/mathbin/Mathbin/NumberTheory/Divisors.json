{"swap_mem_divisors_antidiagonal":
 "@[simp]\ntheorem swap_mem_divisors_antidiagonal {x : ℕ × ℕ} : x.swap ∈ divisors_antidiagonal n ↔ x ∈ divisors_antidiagonal n :=\n  by rw [mem_divisors_antidiagonal, mem_divisors_antidiagonal, mul_comm, prod.swap]\n#align swap_mem_divisors_antidiagonal swap_mem_divisors_antidiagonal\n\n",
 "sum_proper_divisors_eq_one_iff_prime":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem sum_proper_divisors_eq_one_iff_prime :\n    finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" n.proper_divisors\n          x =\n        1 ↔\n      n.prime :=\n  by\n  cases n\n  · simp [Nat.not_prime_zero]\n  cases n\n  · simp [Nat.not_prime_one]\n  rw [← proper_divisors_eq_singleton_one_iff_prime]\n  refine' ⟨fun h => _, fun h => h.symm ▸ sum_singleton⟩\n  rw [@eq_comm (Finset ℕ) _ _]\n  apply\n    eq_proper_divisors_of_subset_of_sum_eq_sum\n      (singleton_subset_iff.2 (one_mem_proper_divisors_iff_one_lt.2 (succ_lt_succ (nat.succ_pos _))))\n      (eq.trans sum_singleton h.symm)\n#align sum_proper_divisors_eq_one_iff_prime sum_proper_divisors_eq_one_iff_prime\n\n",
 "sum_proper_divisors_dvd":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem sum_proper_divisors_dvd\n    (h :\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" n.proper_divisors\n          x ∣\n        n) :\n    finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" n.proper_divisors\n          x =\n        1 ∨\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" n.proper_divisors\n          x =\n        n :=\n  by\n  cases n\n  · simp\n  cases n\n  · contrapose! h\n    simp\n  rw [or_iff_not_imp_right]\n  intro ne_n\n  have hlt :\n    finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n        n.succ.succ.proper_divisors x <\n      n.succ.succ :=\n    lt_of_le_of_ne (nat.le_of_dvd (nat.succ_pos _) h) ne_n\n  symm\n  rw [← mem_singleton,\n    eq_proper_divisors_of_subset_of_sum_eq_sum (singleton_subset_iff.2 (mem_proper_divisors.2 ⟨h, hlt⟩)) sum_singleton,\n    mem_proper_divisors]\n  refine' ⟨one_dvd _, nat.succ_lt_succ (nat.succ_pos _)⟩\n#align sum_proper_divisors_dvd sum_proper_divisors_dvd\n\n",
 "sum_divisors_eq_sum_proper_divisors_add_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem sum_divisors_eq_sum_proper_divisors_add_self :\n    finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (divisors n) i =\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n          (proper_divisors n) i +\n        n :=\n  by\n  rcases decidable.eq_or_ne n 0 with (rfl | hn)\n  · simp\n  · rw [← cons_self_proper_divisors hn, finset.sum_cons, add_comm]\n#align sum_divisors_eq_sum_proper_divisors_add_self sum_divisors_eq_sum_proper_divisors_add_self\n\n",
 "snd_mem_divisors_of_mem_antidiagonal":
 "theorem snd_mem_divisors_of_mem_antidiagonal {x : ℕ × ℕ} (h : x ∈ divisors_antidiagonal n) : x.snd ∈ divisors n :=\n  by\n  rw [mem_divisors_antidiagonal] at h\n  simp [Dvd.intro_left _ h.1, h.2]\n#align snd_mem_divisors_of_mem_antidiagonal snd_mem_divisors_of_mem_antidiagonal\n\n",
 "proper_divisors_zero":
 "@[simp]\ntheorem proper_divisors_zero : proper_divisors 0 = ∅ := by\n  ext\n  simp\n#align proper_divisors_zero proper_divisors_zero\n\n",
 "proper_divisors_subset_divisors":
 "theorem proper_divisors_subset_divisors : proper_divisors n ⊆ divisors n :=\n  filter_subset_filter _ <| Ico_subset_Ico_right n.le_succ\n#align proper_divisors_subset_divisors proper_divisors_subset_divisors\n\n",
 "proper_divisors_prime_pow":
 "theorem proper_divisors_prime_pow {p : ℕ} (pp : p.prime) (k : ℕ) :\n    proper_divisors (p ^ k) = (Finset.range k).map ⟨pow p, pow_right_injective pp.two_le⟩ :=\n  by\n  ext\n  simp [mem_proper_divisors_prime_pow, pp, Nat.lt_succ_iff, @eq_comm _ a]\n#align proper_divisors_prime_pow proper_divisors_prime_pow\n\n",
 "proper_divisors_one":
 "@[simp]\ntheorem proper_divisors_one : proper_divisors 1 = ∅ := by rw [proper_divisors, Ico_self, filter_empty]\n#align proper_divisors_one proper_divisors_one\n\n",
 "proper_divisors_eq_singleton_one_iff_prime":
 "theorem proper_divisors_eq_singleton_one_iff_prime : n.proper_divisors = {1} ↔ n.prime :=\n  ⟨fun h => by\n    have h1 := mem_singleton.2 rfl\n    rw [← h, mem_proper_divisors] at h1\n    refine' nat.prime_def_lt''.mpr ⟨h1.2, fun m hdvd => _⟩\n    rw [← mem_singleton, ← h, mem_proper_divisors]\n    have hle := nat.le_of_dvd (lt_trans (nat.succ_pos _) h1.2) hdvd\n    exact or.imp_left (fun hlt => ⟨hdvd, hlt⟩) hle.lt_or_eq, prime.proper_divisors⟩\n#align proper_divisors_eq_singleton_one_iff_prime proper_divisors_eq_singleton_one_iff_prime\n\n",
 "proper_divisors":
 "theorem prime.proper_divisors {p : ℕ} (pp : p.prime) : proper_divisors p = {1} := by\n  rw [← erase_insert proper_divisors.not_self_mem, insert_self_proper_divisors pp.ne_zero, pp.divisors, pair_comm,\n    erase_insert fun con => pp.ne_one (mem_singleton.1 con)]\n#align prime.proper_divisors prime.proper_divisors\n\n",
 "prod_proper_divisors_prime_pow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n@[simp, to_additive]\ntheorem prod_proper_divisors_prime_pow {α : Type _} [comm_monoid α] {k p : ℕ} {f : ℕ → α} (h : p.prime) :\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\"\n        (p ^ k).proper_divisors (f x) =\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" (range k)\n        (f (p ^ x)) :=\n  by simp [h, proper_divisors_prime_pow]\n#align prod_proper_divisors_prime_pow prod_proper_divisors_prime_pow\n\n",
 "prod_proper_divisors":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n@[simp, to_additive]\ntheorem prime.prod_proper_divisors {α : Type _} [comm_monoid α] {p : ℕ} {f : ℕ → α} (h : p.prime) :\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" p.proper_divisors\n        (f x) =\n      f 1 :=\n  by simp [h.proper_divisors]\n#align prime.prod_proper_divisors prime.prod_proper_divisors\n\n",
 "prod_divisors_prime_pow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n@[simp, to_additive sum_divisors_prime_pow]\ntheorem prod_divisors_prime_pow {α : Type _} [comm_monoid α] {k p : ℕ} {f : ℕ → α} (h : p.prime) :\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" (p ^ k).divisors\n        (f x) =\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" (range (k + 1))\n        (f (p ^ x)) :=\n  by simp [h, divisors_prime_pow]\n#align prod_divisors_prime_pow prod_divisors_prime_pow\n\n",
 "prod_divisors_antidiagonal'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n@[to_additive]\ntheorem prod_divisors_antidiagonal' {M : Type _} [comm_monoid M] (f : ℕ → ℕ → M) {n : ℕ} :\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\"\n        n.divisors_antidiagonal (f i.1 i.2) =\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" n.divisors\n        (f (n / i) i) :=\n  by\n  rw [← map_swap_divisors_antidiagonal, finset.prod_map]\n  exact prod_divisors_antidiagonal fun i j => f j i\n#align prod_divisors_antidiagonal' prod_divisors_antidiagonal'\n\n",
 "prod_divisors_antidiagonal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n@[to_additive]\ntheorem prod_divisors_antidiagonal {M : Type _} [comm_monoid M] (f : ℕ → ℕ → M) {n : ℕ} :\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\"\n        n.divisors_antidiagonal (f i.1 i.2) =\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" n.divisors\n        (f i (n / i)) :=\n  by\n  rw [← map_div_right_divisors, finset.prod_map]\n  rfl\n#align prod_divisors_antidiagonal prod_divisors_antidiagonal\n\n",
 "prod_divisors":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n@[simp, to_additive]\ntheorem prime.prod_divisors {α : Type _} [comm_monoid α] {p : ℕ} {f : ℕ → α} (h : p.prime) :\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" p.divisors (f x) =\n      f p * f 1 :=\n  by rw [← cons_self_proper_divisors h.ne_zero, prod_cons, h.prod_proper_divisors]\n#align prime.prod_divisors prime.prod_divisors\n\n",
 "prod_div_divisors":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n@[simp, to_additive sum_div_divisors]\ntheorem prod_div_divisors {α : Type _} [comm_monoid α] (n : ℕ) (f : ℕ → α) :\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" n.divisors\n        (f (n / d)) =\n      n.divisors.prod f :=\n  by\n  by_cases hn : n = 0; · simp [hn]\n  rw [← prod_image]\n  · exact prod_congr (image_div_divisors_eq_divisors n) (by simp)\n  · intro x hx y hy h\n    rw [mem_divisors] at hx hy\n    exact (div_eq_iff_eq_of_dvd_dvd hn hx.1 hy.1).mp h\n#align prod_div_divisors prod_div_divisors\n\n",
 "prime_divisors_eq_to_filter_divisors_prime":
 "/-- The factors of `n` are the prime divisors -/\ntheorem prime_divisors_eq_to_filter_divisors_prime (n : ℕ) : n.factors.to_finset = (divisors n).filter Prime :=\n  by\n  rcases n.eq_zero_or_pos with (rfl | hn)\n  · simp\n  · ext q\n    simpa [hn, hn.ne', mem_factors] using and_comm' (Prime q) (q ∣ n)\n#align prime_divisors_eq_to_filter_divisors_prime prime_divisors_eq_to_filter_divisors_prime\n\n",
 "pos_of_mem_proper_divisors":
 "theorem pos_of_mem_proper_divisors {m : ℕ} (h : m ∈ n.proper_divisors) : 0 < m :=\n  pos_of_mem_divisors (proper_divisors_subset_divisors h)\n#align pos_of_mem_proper_divisors pos_of_mem_proper_divisors\n\n",
 "pos_of_mem_divisors":
 "theorem pos_of_mem_divisors {m : ℕ} (h : m ∈ n.divisors) : 0 < m :=\n  by\n  cases m\n  · rw [mem_divisors, zero_dvd_iff] at h\n    cases h.2 h.1\n  apply nat.succ_pos\n#align pos_of_mem_divisors pos_of_mem_divisors\n\n",
 "perfect_iff_sum_proper_divisors":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem perfect_iff_sum_proper_divisors (h : 0 < n) :\n    perfect n ↔\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n          (proper_divisors n) i =\n        n :=\n  and_iff_left h\n#align perfect_iff_sum_proper_divisors perfect_iff_sum_proper_divisors\n\n",
 "perfect_iff_sum_divisors_eq_two_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem perfect_iff_sum_divisors_eq_two_mul (h : 0 < n) :\n    perfect n ↔\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (divisors n) i =\n        2 * n :=\n  by\n  rw [perfect_iff_sum_proper_divisors h, sum_divisors_eq_sum_proper_divisors_add_self, two_mul]\n  constructor <;> intro h\n  · rw [h]\n  · apply add_right_cancel h\n#align perfect_iff_sum_divisors_eq_two_mul perfect_iff_sum_divisors_eq_two_mul\n\n",
 "one_mem_proper_divisors_iff_one_lt":
 "theorem one_mem_proper_divisors_iff_one_lt : 1 ∈ n.proper_divisors ↔ 1 < n := by\n  rw [mem_proper_divisors, and_iff_right (one_dvd _)]\n#align one_mem_proper_divisors_iff_one_lt one_mem_proper_divisors_iff_one_lt\n\n",
 "one_mem_divisors":
 "theorem one_mem_divisors : 1 ∈ divisors n ↔ n ≠ 0 := by simp\n#align one_mem_divisors one_mem_divisors\n\n",
 "not_self_mem":
 "theorem proper_divisors.not_self_mem : ¬n ∈ proper_divisors n := by simp [proper_divisors]\n#align proper_divisors.not_self_mem proper_divisors.not_self_mem\n\n",
 "mem_proper_divisors_prime_pow":
 "theorem mem_proper_divisors_prime_pow {p : ℕ} (pp : p.prime) (k : ℕ) {x : ℕ} :\n    x ∈ proper_divisors (p ^ k) ↔ ∃ (j : ℕ)(H : j < k), x = p ^ j :=\n  by\n  rw [mem_proper_divisors, Nat.dvd_prime_pow pp, ← exists_and_right]\n  simp only [exists_prop, and_assoc']\n  apply exists_congr\n  intro a\n  constructor <;> intro h\n  · rcases h with ⟨h_left, rfl, h_right⟩\n    rwa [pow_lt_pow_iff pp.one_lt] at h_right\n    simpa\n  · rcases h with ⟨h_left, rfl⟩\n    rwa [pow_lt_pow_iff pp.one_lt]\n    simp [h_left, le_of_lt]\n#align mem_proper_divisors_prime_pow mem_proper_divisors_prime_pow\n\n",
 "mem_proper_divisors":
 "@[simp]\ntheorem mem_proper_divisors {m : ℕ} : n ∈ proper_divisors m ↔ n ∣ m ∧ n < m :=\n  by\n  rcases eq_or_ne m 0 with (rfl | hm); · simp [proper_divisors]\n  simp only [and_comm', ← filter_dvd_eq_proper_divisors hm, mem_filter, mem_range]\n#align mem_proper_divisors mem_proper_divisors\n\n",
 "mem_divisors_self":
 "theorem mem_divisors_self (n : ℕ) (h : n ≠ 0) : n ∈ n.divisors :=\n  mem_divisors.2 ⟨dvd_rfl, h⟩\n#align mem_divisors_self mem_divisors_self\n\n",
 "mem_divisors_prime_pow":
 "theorem mem_divisors_prime_pow {p : ℕ} (pp : p.prime) (k : ℕ) {x : ℕ} :\n    x ∈ divisors (p ^ k) ↔ ∃ (j : ℕ)(H : j ≤ k), x = p ^ j := by\n  rw [mem_divisors, Nat.dvd_prime_pow pp, and_iff_left (ne_of_gt (pow_pos pp.pos k))]\n#align mem_divisors_prime_pow mem_divisors_prime_pow\n\n",
 "mem_divisors_antidiagonal":
 "@[simp]\ntheorem mem_divisors_antidiagonal {x : ℕ × ℕ} : x ∈ divisors_antidiagonal n ↔ x.fst * x.snd = n ∧ n ≠ 0 :=\n  by\n  simp only [divisors_antidiagonal, finset.mem_Ico, ne.def, Finset.mem_filter, finset.mem_product]\n  rw [and_comm']\n  apply and_congr_right\n  rintro rfl\n  constructor <;> intro h\n  · contrapose! h\n    simp [h]\n  · rw [Nat.lt_add_one_iff, Nat.lt_add_one_iff]\n    rw [mul_eq_zero, decidable.not_or_iff_and_not] at h\n    simp only [succ_le_of_lt (nat.pos_of_ne_zero h.1), succ_le_of_lt (nat.pos_of_ne_zero h.2), true_and_iff]\n    exact ⟨le_mul_of_pos_right (nat.pos_of_ne_zero h.2), le_mul_of_pos_left (nat.pos_of_ne_zero h.1)⟩\n#align mem_divisors_antidiagonal mem_divisors_antidiagonal\n\n",
 "mem_divisors":
 "@[simp]\ntheorem mem_divisors {m : ℕ} : n ∈ divisors m ↔ n ∣ m ∧ m ≠ 0 :=\n  by\n  rcases eq_or_ne m 0 with (rfl | hm); · simp [divisors]\n  simp only [hm, ne.def, not_false_iff, and_true_iff, ← filter_dvd_eq_divisors hm, mem_filter, mem_range,\n    and_iff_right_iff_imp, lt_succ_iff]\n  exact le_of_dvd hm.bot_lt\n#align mem_divisors mem_divisors\n\n",
 "map_swap_divisors_antidiagonal":
 "@[simp]\ntheorem map_swap_divisors_antidiagonal :\n    (divisors_antidiagonal n).map (Equiv.prodComm _ _).to_embedding = divisors_antidiagonal n :=\n  by\n  rw [← coe_inj, coe_map, Equiv.coe_toEmbedding, Equiv.coe_prodComm, Set.image_swap_eq_preimage_swap]\n  ext\n  exact swap_mem_divisors_antidiagonal\n#align map_swap_divisors_antidiagonal map_swap_divisors_antidiagonal\n\n",
 "map_div_right_divisors":
 "theorem map_div_right_divisors :\n    n.divisors.map ⟨fun d => (d, n / d), fun p₁ p₂ => congr_arg prod.fst⟩ = n.divisors_antidiagonal :=\n  by\n  ext ⟨d, nd⟩\n  simp only [mem_map, mem_divisors_antidiagonal, Function.Embedding.coeFn_mk, mem_divisors, prod.ext_iff, exists_prop,\n    and_left_comm, exists_eq_left]\n  constructor\n  · rintro ⟨⟨⟨k, rfl⟩, hn⟩, rfl⟩\n    rw [nat.mul_div_cancel_left _ (left_ne_zero_of_mul hn).bot_lt]\n    exact ⟨rfl, hn⟩\n  · rintro ⟨rfl, hn⟩\n    exact ⟨⟨dvd_mul_right _ _, hn⟩, nat.mul_div_cancel_left _ (left_ne_zero_of_mul hn).bot_lt⟩\n#align map_div_right_divisors map_div_right_divisors\n\n",
 "map_div_left_divisors":
 "theorem map_div_left_divisors :\n    n.divisors.map ⟨fun d => (n / d, d), fun p₁ p₂ => congr_arg prod.snd⟩ = n.divisors_antidiagonal :=\n  by\n  apply Finset.map_injective (Equiv.prodComm _ _).to_embedding\n  rw [map_swap_divisors_antidiagonal, ← map_div_right_divisors, Finset.map_map]\n  rfl\n#align map_div_left_divisors map_div_left_divisors\n\n",
 "insert_self_proper_divisors":
 "theorem insert_self_proper_divisors (h : n ≠ 0) : insert n (proper_divisors n) = divisors n := by\n  rw [divisors, proper_divisors, Ico_succ_right_eq_insert_Ico (one_le_iff_ne_zero.2 h), Finset.filter_insert,\n    if_pos (dvd_refl n)]\n#align insert_self_proper_divisors insert_self_proper_divisors\n\n",
 "image_snd_divisors_antidiagonal":
 "@[simp]\ntheorem image_snd_divisors_antidiagonal : (divisors_antidiagonal n).image prod.snd = divisors n :=\n  by\n  rw [← map_swap_divisors_antidiagonal, map_eq_image, image_image]\n  exact image_fst_divisors_antidiagonal\n#align image_snd_divisors_antidiagonal image_snd_divisors_antidiagonal\n\n",
 "image_fst_divisors_antidiagonal":
 "@[simp]\ntheorem image_fst_divisors_antidiagonal : (divisors_antidiagonal n).image prod.fst = divisors n :=\n  by\n  ext\n  simp [has_dvd.dvd, @eq_comm _ n (_ * _)]\n#align image_fst_divisors_antidiagonal image_fst_divisors_antidiagonal\n\n",
 "image_div_divisors_eq_divisors":
 "@[simp]\ntheorem image_div_divisors_eq_divisors (n : ℕ) : image (fun x : ℕ => n / x) n.divisors = n.divisors :=\n  by\n  by_cases hn : n = 0; · simp [hn]\n  ext\n  constructor\n  · rw [mem_image]\n    rintro ⟨x, hx1, hx2⟩\n    rw [mem_divisors] at *\n    refine' ⟨_, hn⟩\n    rw [← hx2]\n    exact div_dvd_of_dvd hx1.1\n  · rw [mem_divisors, mem_image]\n    rintro ⟨h1, -⟩\n    exact ⟨n / a, mem_divisors.mpr ⟨div_dvd_of_dvd h1, hn⟩, Nat.div_div_self h1 hn⟩\n#align image_div_divisors_eq_divisors image_div_divisors_eq_divisors\n\n",
 "fst_mem_divisors_of_mem_antidiagonal":
 "theorem fst_mem_divisors_of_mem_antidiagonal {x : ℕ × ℕ} (h : x ∈ divisors_antidiagonal n) : x.fst ∈ divisors n :=\n  by\n  rw [mem_divisors_antidiagonal] at h\n  simp [Dvd.intro _ h.1, h.2]\n#align fst_mem_divisors_of_mem_antidiagonal fst_mem_divisors_of_mem_antidiagonal\n\n",
 "filter_dvd_eq_proper_divisors":
 "@[simp]\ntheorem filter_dvd_eq_proper_divisors (h : n ≠ 0) : (Finset.range n).filter (· ∣ n) = n.proper_divisors :=\n  by\n  ext\n  simp only [proper_divisors, mem_filter, mem_range, mem_Ico, and_congr_left_iff, iff_and_self]\n  exact fun ha _ => succ_le_iff.mpr (pos_of_dvd_of_pos ha h.bot_lt)\n#align filter_dvd_eq_proper_divisors filter_dvd_eq_proper_divisors\n\n",
 "filter_dvd_eq_divisors":
 "/-\nCopyright (c) 2020 Aaron Anderson. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Aaron Anderson\n-/\n@[simp]\ntheorem filter_dvd_eq_divisors (h : n ≠ 0) : (Finset.range n.succ).filter (· ∣ n) = n.divisors :=\n  by\n  ext\n  simp only [divisors, mem_filter, mem_range, mem_Ico, and_congr_left_iff, iff_and_self]\n  exact fun ha _ => succ_le_iff.mpr (pos_of_dvd_of_pos ha h.bot_lt)\n#align filter_dvd_eq_divisors filter_dvd_eq_divisors\n\n",
 "eq_proper_divisors_of_subset_of_sum_eq_sum":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem eq_proper_divisors_of_subset_of_sum_eq_sum {s : Finset ℕ} (hsub : s ⊆ n.proper_divisors) :\n    finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s x =\n        finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n          n.proper_divisors x →\n      s = n.proper_divisors :=\n  by\n  cases n\n  · rw [proper_divisors_zero, subset_empty] at hsub\n    simp [hsub]\n  classical\n    rw [← sum_sdiff hsub]\n    intro h\n    apply subset.antisymm hsub\n    rw [← sdiff_eq_empty_iff_subset]\n    contrapose h\n    rw [← ne.def, ← nonempty_iff_ne_empty] at h\n    apply ne_of_lt\n    rw [←\n      zero_add (finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s x), ←\n      add_assoc, add_zero]\n    apply add_lt_add_right\n    have hlt := sum_lt_sum_of_nonempty h fun x hx => pos_of_mem_proper_divisors (sdiff_subset _ _ hx)\n    simp only [sum_const_zero] at hlt\n    apply hlt\n#align eq_proper_divisors_of_subset_of_sum_eq_sum eq_proper_divisors_of_subset_of_sum_eq_sum\n\n",
 "dvd_of_mem_divisors":
 "theorem dvd_of_mem_divisors {m : ℕ} (h : n ∈ divisors m) : n ∣ m :=\n  by\n  cases m\n  · apply dvd_zero\n  · simp [mem_divisors.1 h]\n#align dvd_of_mem_divisors dvd_of_mem_divisors\n\n",
 "divisors_zero":
 "@[simp]\ntheorem divisors_zero : divisors 0 = ∅ := by\n  ext\n  simp\n#align divisors_zero divisors_zero\n\n",
 "divisors_subset_proper_divisors":
 "theorem divisors_subset_proper_divisors {m : ℕ} (hzero : n ≠ 0) (h : m ∣ n) (hdiff : m ≠ n) :\n    divisors m ⊆ proper_divisors n := by\n  apply Finset.subset_iff.2\n  intro x hx\n  exact\n    nat.mem_proper_divisors.2\n      ⟨(nat.mem_divisors.1 hx).1.trans h,\n        lt_of_le_of_lt (divisor_le hx) (lt_of_le_of_ne (divisor_le (nat.mem_divisors.2 ⟨h, hzero⟩)) hdiff)⟩\n#align divisors_subset_proper_divisors divisors_subset_proper_divisors\n\n",
 "divisors_subset_of_dvd":
 "theorem divisors_subset_of_dvd {m : ℕ} (hzero : n ≠ 0) (h : m ∣ n) : divisors m ⊆ divisors n :=\n  Finset.subset_iff.2 fun x hx => nat.mem_divisors.mpr ⟨(nat.mem_divisors.mp hx).1.trans h, hzero⟩\n#align divisors_subset_of_dvd divisors_subset_of_dvd\n\n",
 "divisors_prime_pow":
 "theorem divisors_prime_pow {p : ℕ} (pp : p.prime) (k : ℕ) :\n    divisors (p ^ k) = (Finset.range (k + 1)).map ⟨pow p, pow_right_injective pp.two_le⟩ :=\n  by\n  ext\n  simp [mem_divisors_prime_pow, pp, Nat.lt_succ_iff, @eq_comm _ a]\n#align divisors_prime_pow divisors_prime_pow\n\n",
 "divisors_one":
 "@[simp]\ntheorem divisors_one : divisors 1 = {1} := by\n  ext\n  simp\n#align divisors_one divisors_one\n\n",
 "divisors_antidiagonal_zero":
 "@[simp]\ntheorem divisors_antidiagonal_zero : divisors_antidiagonal 0 = ∅ :=\n  by\n  ext\n  simp\n#align divisors_antidiagonal_zero divisors_antidiagonal_zero\n\n",
 "divisors_antidiagonal_one":
 "@[simp]\ntheorem divisors_antidiagonal_one : divisors_antidiagonal 1 = {(1, 1)} :=\n  by\n  ext\n  simp [Nat.mul_eq_one_iff, prod.ext_iff]\n#align divisors_antidiagonal_one divisors_antidiagonal_one\n\n",
 "divisors":
 "theorem prime.divisors {p : ℕ} (pp : p.prime) : divisors p = {1, p} :=\n  by\n  ext\n  rw [mem_divisors, dvd_prime pp, and_iff_left pp.ne_zero, Finset.mem_insert, Finset.mem_singleton]\n#align prime.divisors prime.divisors\n\n",
 "divisor_le":
 "theorem divisor_le {m : ℕ} : n ∈ divisors m → n ≤ m := by\n  cases m\n  · simp\n  simp only [mem_divisors, m.succ_ne_zero, and_true_iff, ne.def, not_false_iff]\n  exact nat.le_of_dvd (nat.succ_pos m)\n#align divisor_le divisor_le\n\n",
 "cons_self_proper_divisors":
 "theorem cons_self_proper_divisors (h : n ≠ 0) : cons n (proper_divisors n) proper_divisors.not_self_mem = divisors n :=\n  by rw [cons_eq_insert, insert_self_proper_divisors h]\n#align cons_self_proper_divisors cons_self_proper_divisors\n\n"}