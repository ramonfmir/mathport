{"zero_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℚ_[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟦ ⟧» -/\n-- short circuits\ntheorem zero_def : (0 : «exprℚ_[ ]» p) = «expr⟦ ⟧» 0 :=\n  rfl\n#align zero_def zero_def\n\n",
 "valuation_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℚ_[ ]» -/\n@[simp]\ntheorem valuation_zero : valuation (0 : «exprℚ_[ ]» p) = 0 :=\n  dif_pos ((const_equiv p).2 rfl)\n#align valuation_zero valuation_zero\n\n",
 "valuation_p":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℚ_[ ]» -/\n@[simp]\ntheorem valuation_p : valuation (p : «exprℚ_[ ]» p) = 1 :=\n  by\n  have h : (1 : exprℝ) < p := by exact_mod_cast (fact.out p.prime).one_lt\n  refine' neg_injective ((zpow_strictMono h).injective <| (norm_eq_pow_val _).symm.trans _)\n  · exact_mod_cast (fact.out p.prime).ne_zero\n  · simp\n#align valuation_p valuation_p\n\n",
 "valuation_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℚ_[ ]» -/\n@[simp]\ntheorem valuation_one : valuation (1 : «exprℚ_[ ]» p) = 0 :=\n  by\n  change dite (CauSeq.const (padicNorm p) 1 ≈ _) _ _ = _\n  have h : ¬CauSeq.const (padicNorm p) 1 ≈ 0 := by\n    intro H\n    erw [const_equiv p] at H\n    exact one_ne_zero H\n  rw [dif_neg h]\n  simp\n#align valuation_one valuation_one\n\n",
 "valuation_map_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℚ_[ ]» -/\n@[simp]\ntheorem valuation_map_mul {x y : «exprℚ_[ ]» p} (hx : x ≠ 0) (hy : y ≠ 0) :\n    valuation (x * y) = valuation x + valuation y :=\n  by\n  have h_norm : «expr‖ ‖» (x * y) = «expr‖ ‖» x * «expr‖ ‖» y := norm_mul x y\n  have hp_ne_one : (p : exprℝ) ≠ 1 := by\n    rw [← Nat.cast_one, ne.def, Nat.cast_inj]\n    exact Nat.Prime.ne_one hp.elim\n  have hp_pos : (0 : exprℝ) < p := by\n    rw [← Nat.cast_zero, Nat.cast_lt]\n    exact Nat.Prime.pos hp.elim\n  rw [norm_eq_pow_val hx, norm_eq_pow_val hy, norm_eq_pow_val (mul_ne_zero hx hy), ← zpow_add₀ (ne_of_gt hp_pos),\n    zpow_inj hp_pos hp_ne_one, ← neg_add, neg_inj] at h_norm\n  exact h_norm\n#align valuation_map_mul valuation_map_mul\n\n",
 "valuation_map_add":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℚ_[ ]» -/\ntheorem valuation_map_add {x y : «exprℚ_[ ]» p} (hxy : x + y ≠ 0) :\n    min (valuation x) (valuation y) ≤ valuation (x + y) :=\n  by\n  by_cases hx : x = 0\n  · rw [hx, zero_add]\n    exact min_le_right _ _\n  · by_cases hy : y = 0\n    · rw [hy, add_zero]\n      exact min_le_left _ _\n    · have h_norm : «expr‖ ‖» (x + y) ≤ max («expr‖ ‖» x) («expr‖ ‖» y) := padic_norm_e.nonarchimedean x y\n      have hp_one : (1 : exprℝ) < p := by\n        rw [← Nat.cast_one, Nat.cast_lt]\n        exact Nat.Prime.one_lt hp.elim\n      rwa [norm_eq_pow_val hx, norm_eq_pow_val hy, norm_eq_pow_val hxy, zpow_le_max_iff_min_le hp_one] at h_norm\n#align valuation_map_add valuation_map_add\n\n",
 "val_eq_iff_norm_eq":
 "theorem val_eq_iff_norm_eq {f g : padic_seq p} (hf : ¬f ≈ 0) (hg : ¬g ≈ 0) :\n    f.valuation = g.valuation ↔ f.norm = g.norm :=\n  by\n  rw [norm_eq_pow_val hf, norm_eq_pow_val hg, ← neg_inj, zpow_inj]\n  · exact_mod_cast (fact.out p.prime).pos\n  · exact_mod_cast (fact.out p.prime).ne_one\n#align val_eq_iff_norm_eq val_eq_iff_norm_eq\n\n",
 "stationary_point_spec":
 "theorem stationary_point_spec {f : padic_seq p} (hf : ¬f ≈ 0) :\n    ∀ {m n}, stationary_point hf ≤ m → stationary_point hf ≤ n → padicNorm p (f n) = padicNorm p (f m) :=\n  Classical.choose_spec <| stationary hf\n#align stationary_point_spec stationary_point_spec\n\n",
 "stationary":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/-\nCopyright (c) 2018 Robert Y. Lewis. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Robert Y. Lewis\n-/\n/-- The `p`-adic norm of the entries of a nonzero Cauchy sequence of rationals is eventually\nconstant. -/\ntheorem stationary {f : CauSeq (exprℚ) (padicNorm p)} (hf : ¬f ≈ 0) :\n    ∃ N, ∀ m n, N ≤ m → N ≤ n → padicNorm p (f n) = padicNorm p (f m) :=\n  have : ∃ ε > 0, ∃ N1, ∀ j ≥ N1, ε ≤ padicNorm p (f j) :=\n    CauSeq.abv_pos_of_not_limZero <| not_limZero_of_not_congr_zero hf\n  let ⟨ε, hε, N1, hN1⟩ := this\n  let ⟨N2, hN2⟩ := CauSeq.cauchy₂ f hε\n  ⟨max N1 N2, fun n m hn hm =>\n    by\n    have : padicNorm p (f n - f m) < ε := hN2 _ (max_le_iff.1 hn).2 _ (max_le_iff.1 hm).2\n    have : padicNorm p (f n - f m) < padicNorm p (f n) := lt_of_lt_of_le this <| hN1 _ (max_le_iff.1 hn).1\n    have : padicNorm p (f n - f m) < max (padicNorm p (f n)) (padicNorm p (f m)) := lt_max_iff.2 (or.inl this)\n    by_contra hne\n    rw [← padicNorm.neg (f m)] at hne\n    have hnam := add_eq_max_of_ne hne\n    rw [padicNorm.neg, max_comm] at hnam\n    rw [← hnam, sub_eq_add_neg, add_comm] at this\n    apply _root_.lt_irrefl _ this⟩\n#align stationary stationary\n\n",
 "rat_dense'":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (m n «expr ≥ » N) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℚ_[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\ntheorem rat_dense' (q : «exprℚ_[ ]» p) {ε : exprℚ} (hε : 0 < ε) : ∃ r : exprℚ, padic_norm_e (q - r) < ε :=\n  Quotient.inductionOn q fun q' =>\n    have : ∃ N, ∀ (m) (_ : m ≥ N) (n) (_ : n ≥ N), padicNorm p (q' m - q' n) < ε := cauchy₂ _ hε\n    let ⟨N, hN⟩ := this\n    ⟨q' N, by\n      dsimp [padic_norm_e]\n      change padic_seq.norm (q' - const _ (q' N)) < ε\n      cases' decidable.em (q' - const (padicNorm p) (q' N) ≈ 0) with heq hne'\n      · simpa only [HEq, padic_seq.norm, dif_pos]\n      · simp only [padic_seq.norm, dif_neg hne']\n        change padicNorm p (q' _ - q' _) < ε\n        have := stationary_point_spec hne'\n        cases' decidable.em (stationary_point hne' ≤ N) with hle hle\n        · have := Eq.symm (this le_rfl hle)\n          simp only [const_apply, sub_apply, padicNorm.zero, sub_self] at this\n          simpa only [this]\n        · exact hN _ (lt_of_not_ge hle).le _ le_rfl⟩\n#align rat_dense' rat_dense'\n\n",
 "rat_dense":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℚ_[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem rat_dense (q : «exprℚ_[ ]» p) {ε : exprℝ} (hε : 0 < ε) : ∃ r : exprℚ, «expr‖ ‖» (q - r) < ε :=\n  let ⟨ε', hε'l, hε'r⟩ := exists_rat_btwn hε\n  let ⟨r, hr⟩ := rat_dense' q (by simpa using hε'l)\n  ⟨r, lt_trans (by simpa [has_norm.norm] using hr) hε'r⟩\n#align rat_dense rat_dense\n\n",
 "padic_norm_e_lim_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℚ_[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem padic_norm_e_lim_le {f : CauSeq («exprℚ_[ ]» p) norm} {a : exprℝ} (ha : 0 < a) (hf : ∀ i, «expr‖ ‖» (f i) ≤ a) :\n    «expr‖ ‖» f.lim ≤ a :=\n  let ⟨N, hN⟩ := setoid.symm (CauSeq.equiv_lim f) _ ha\n  calc\n    «expr‖ ‖» f.lim = «expr‖ ‖» (f.lim - f N + f N) := by simp\n    _ ≤ max («expr‖ ‖» (f.lim - f N)) («expr‖ ‖» (f N)) := (padic_norm_e.nonarchimedean _ _)\n    _ ≤ a := max_le (le_of_lt (hN _ le_rfl)) (hf _)\n    \n#align padic_norm_e_lim_le padic_norm_e_lim_le\n\n",
 "not_lim_zero_const_of_nonzero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\ntheorem not_lim_zero_const_of_nonzero {q : exprℚ} (hq : q ≠ 0) : ¬LimZero (const (padicNorm p) q) := fun h' =>\n  hq <| const_limZero.1 h'\n#align not_lim_zero_const_of_nonzero not_lim_zero_const_of_nonzero\n\n",
 "not_equiv_zero_const_of_nonzero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\ntheorem not_equiv_zero_const_of_nonzero {q : exprℚ} (hq : q ≠ 0) : ¬const (padicNorm p) q ≈ 0 :=\n  fun h : LimZero (const (padicNorm p) q - 0) => not_lim_zero_const_of_nonzero hq <| by simpa using h\n#align not_equiv_zero_const_of_nonzero not_equiv_zero_const_of_nonzero\n\n",
 "norm_zero_iff":
 "theorem norm_zero_iff (f : padic_seq p) : f.norm = 0 ↔ f ≈ 0 :=\n  by\n  constructor\n  · intro h\n    by_contra hf\n    unfold norm at h\n    split_ifs  at h\n    apply hf\n    intro ε hε\n    exists stationary_point hf\n    intro j hj\n    have heq := stationary_point_spec hf le_rfl hj\n    simpa [h, HEq]\n  · intro h\n    simp [norm, h]\n#align norm_zero_iff norm_zero_iff\n\n",
 "norm_values_discrete":
 "theorem norm_values_discrete (a : padic_seq p) (ha : ¬a ≈ 0) : ∃ z : ℤ, a.norm = p ^ (-z) :=\n  by\n  let ⟨k, hk, hk'⟩ := norm_eq_norm_app_of_nonzero ha\n  simpa [hk] using padicNorm.values_discrete hk'\n#align norm_values_discrete norm_values_discrete\n\n",
 "norm_rat_le_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℚ_[ ]» -/\ntheorem norm_rat_le_one : ∀ {q : exprℚ} (hq : ¬p ∣ q.denom), «expr‖ ‖» (q : «exprℚ_[ ]» p) ≤ 1\n  | ⟨n, d, hn, hd⟩ => fun hq : ¬p ∣ d =>\n    if hnz : n = 0 then by\n      have : (⟨n, d, hn, hd⟩ : exprℚ) = 0 := Rat.zero_iff_num_zero.mpr hnz\n      norm_num [this]\n    else\n      by\n      have hnz' :\n        {   num := n\n            denom := d\n            pos := hn\n            cop := hd } ≠ 0 := mt Rat.zero_iff_num_zero.1 hnz\n      rw [padic_norm_e.eq_padic_norm]\n      norm_cast\n      rw [padicNorm.eq_zpow_of_nonzero hnz', padicValRat, neg_sub, padicValNat.eq_zero_of_not_dvd hq]\n      norm_cast\n      rw [zero_sub, zpow_neg, zpow_ofNat]\n      apply inv_le_one\n      · norm_cast\n        apply one_le_pow\n        exact hp.1.pos\n#align norm_rat_le_one norm_rat_le_one\n\n",
 "norm_p_zpow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℚ_[ ]» -/\n@[simp]\ntheorem norm_p_zpow (n : ℤ) : «expr‖ ‖» (p ^ n : «exprℚ_[ ]» p) = p ^ (-n) := by\n  rw [norm_zpow, norm_p, zpow_neg, inv_zpow]\n#align norm_p_zpow norm_p_zpow\n\n",
 "norm_p_pow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℚ_[ ]» -/\n@[simp]\ntheorem norm_p_pow (n : ℕ) : «expr‖ ‖» (p ^ n : «exprℚ_[ ]» p) = p ^ (-n : ℤ) := by rw [← norm_p_zpow, zpow_ofNat]\n#align norm_p_pow norm_p_pow\n\n",
 "norm_p_lt_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℚ_[ ]» -/\ntheorem norm_p_lt_one : «expr‖ ‖» (p : «exprℚ_[ ]» p) < 1 :=\n  by\n  rw [norm_p]\n  apply inv_lt_one\n  exact_mod_cast hp.1.one_lt\n#align norm_p_lt_one norm_p_lt_one\n\n",
 "norm_p":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℚ_[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℚ_[ ]» -/\n@[simp]\ntheorem norm_p : «expr‖ ‖» (p : «exprℚ_[ ]» p) = p⁻¹ :=\n  by\n  have p₀ : p ≠ 0 := hp.1.ne_zero\n  have p₁ : p ≠ 1 := hp.1.ne_one\n  rw [← @Rat.cast_coe_nat (exprℝ) _ p]\n  rw [← @Rat.cast_coe_nat («exprℚ_[ ]» p) _ p]\n  simp [p₀, p₁, norm, padicNorm, padicValRat, padicValInt, zpow_neg, -Rat.cast_coe_nat]\n#align norm_p norm_p\n\n",
 "norm_one":
 "theorem norm_one : norm (1 : padic_seq p) = 1 :=\n  by\n  have h1 : ¬(1 : padic_seq p) ≈ 0 := one_not_equiv_zero _\n  simp [h1, norm, hp.1.one_lt]\n#align norm_one norm_one\n\n",
 "norm_nonzero_of_not_equiv_zero":
 "theorem norm_nonzero_of_not_equiv_zero {f : padic_seq p} (hf : ¬f ≈ 0) : f.norm ≠ 0 :=\n  hf ∘ f.norm_zero_iff.1\n#align norm_nonzero_of_not_equiv_zero norm_nonzero_of_not_equiv_zero\n\n",
 "norm_nonneg":
 "#print norm_nonneg /-\ntheorem norm_nonneg (f : padic_seq p) : 0 ≤ f.norm :=\n  if hf : f ≈ 0 then by simp [hf, norm] else by simp [norm, hf, padicNorm.nonneg]\n#align norm_nonneg norm_nonneg\n-/\n\n",
 "norm_nonarchimedean_aux":
 "private theorem norm_nonarchimedean_aux {f g : padic_seq p} (hfg : ¬f + g ≈ 0) (hf : ¬f ≈ 0) (hg : ¬g ≈ 0) :\n    (f + g).norm ≤ max f.norm g.norm := by\n  unfold norm; split_ifs\n  padic_index_simp [hfg, hf, hg]\n  apply padicNorm.nonarchimedean\n#align norm_nonarchimedean_aux norm_nonarchimedean_aux\n\n",
 "norm_nonarchimedean":
 "theorem norm_nonarchimedean (f g : padic_seq p) : (f + g).norm ≤ max f.norm g.norm :=\n  if hfg : f + g ≈ 0 then by\n    have : 0 ≤ max f.norm g.norm := le_max_of_le_left (norm_nonneg _)\n    simpa only [hfg, norm, ne.def, le_max_iff, CauSeq.add_apply, not_true, dif_pos]\n  else\n    if hf : f ≈ 0 then\n      by\n      have hfg' : f + g ≈ g := by\n        change lim_zero (f - 0) at hf\n        show lim_zero (f + g - g); · simpa only [sub_zero, add_sub_cancel] using hf\n      have hcfg : (f + g).norm = g.norm := norm_equiv hfg'\n      have hcl : f.norm = 0 := (norm_zero_iff f).2 hf\n      have : max f.norm g.norm = g.norm := by rw [hcl] <;> exact max_eq_right (norm_nonneg _)\n      rw [this, hcfg]\n    else\n      if hg : g ≈ 0 then\n        by\n        have hfg' : f + g ≈ f := by\n          change lim_zero (g - 0) at hg\n          show lim_zero (f + g - f); · simpa only [add_sub_cancel', sub_zero] using hg\n        have hcfg : (f + g).norm = f.norm := norm_equiv hfg'\n        have hcl : g.norm = 0 := (norm_zero_iff g).2 hg\n        have : max f.norm g.norm = f.norm := by rw [hcl] <;> exact max_eq_left (norm_nonneg _)\n        rw [this, hcfg]\n      else norm_nonarchimedean_aux hfg hf hg\n#align norm_nonarchimedean norm_nonarchimedean\n\n",
 "norm_neg":
 "#print norm_neg /-\ntheorem norm_neg (a : padic_seq p) : (-a).norm = a.norm :=\n  norm_eq <| by simp\n#align norm_neg norm_neg\n-/\n\n",
 "norm_mul":
 "#print norm_mul /-\ntheorem norm_mul (f g : padic_seq p) : (f * g).norm = f.norm * g.norm :=\n  if hf : f ≈ 0 then by\n    have hg : f * g ≈ 0 := mul_equiv_zero' _ hf\n    simp only [hf, hg, norm, dif_pos, MulZeroClass.zero_mul]\n  else\n    if hg : g ≈ 0 then by\n      have hf : f * g ≈ 0 := mul_equiv_zero _ hg\n      simp only [hf, hg, norm, dif_pos, MulZeroClass.mul_zero]\n    else by\n      have hfg : ¬f * g ≈ 0 := by apply mul_not_equiv_zero <;> assumption\n      unfold norm\n      split_ifs\n      padic_index_simp [hfg, hf, hg]\n      apply padicNorm.mul\n#align norm_mul norm_mul\n-/\n\n",
 "norm_lt_pow_iff_norm_le_pow_sub_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℚ_[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem norm_lt_pow_iff_norm_le_pow_sub_one (x : «exprℚ_[ ]» p) (n : ℤ) :\n    «expr‖ ‖» x < p ^ n ↔ «expr‖ ‖» x ≤ p ^ (n - 1) := by rw [norm_le_pow_iff_norm_lt_pow_add_one, sub_add_cancel]\n#align norm_lt_pow_iff_norm_le_pow_sub_one norm_lt_pow_iff_norm_le_pow_sub_one\n\n",
 "norm_le_pow_iff_norm_lt_pow_add_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℚ_[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem norm_le_pow_iff_norm_lt_pow_add_one (x : «exprℚ_[ ]» p) (n : ℤ) :\n    «expr‖ ‖» x ≤ p ^ n ↔ «expr‖ ‖» x < p ^ (n + 1) :=\n  by\n  have aux : ∀ n : ℤ, 0 < (p ^ n : exprℝ) := by\n    apply Nat.zpow_pos_of_pos\n    exact hp.1.pos\n  by_cases hx0 : x = 0\n  · simp [hx0, norm_zero, aux, le_of_lt (aux _)]\n  rw [norm_eq_pow_val hx0]\n  have h1p : 1 < (p : exprℝ) := by exact_mod_cast hp.1.one_lt\n  have H := zpow_strictMono h1p\n  rw [H.le_iff_le, H.lt_iff_lt, Int.lt_add_one_iff]\n#align norm_le_pow_iff_norm_lt_pow_add_one norm_le_pow_iff_norm_lt_pow_add_one\n\n",
 "norm_le_one_iff_val_nonneg":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℚ_[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem norm_le_one_iff_val_nonneg (x : «exprℚ_[ ]» p) : «expr‖ ‖» x ≤ 1 ↔ 0 ≤ x.valuation :=\n  by\n  by_cases hx : x = 0\n  · simp only [hx, norm_zero, valuation_zero, zero_le_one, le_refl]\n  · rw [norm_eq_pow_val hx, ← zpow_zero (p : exprℝ), zpow_le_iff_le, Right.neg_nonpos_iff]\n    exact Nat.one_lt_cast.2 (Nat.Prime.one_lt' p).1\n#align norm_le_one_iff_val_nonneg norm_le_one_iff_val_nonneg\n\n",
 "norm_int_lt_one_iff_dvd":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℚ_[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℚ_[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℚ_[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℚ_[ ]» -/\ntheorem norm_int_lt_one_iff_dvd (k : ℤ) : «expr‖ ‖» (k : «exprℚ_[ ]» p) < 1 ↔ ↑p ∣ k :=\n  by\n  constructor\n  · intro h\n    contrapose! h\n    apply le_of_eq\n    rw [eq_comm]\n    calc\n      «expr‖ ‖» (k : «exprℚ_[ ]» p) = «expr‖ ‖» ((k : exprℚ) : «exprℚ_[ ]» p) := by norm_cast\n      _ = padicNorm p k := (padic_norm_e.eq_padic_norm _)\n      _ = 1 := _\n      \n    rw [padicNorm]\n    split_ifs with H\n    · exfalso\n      apply h\n      norm_cast  at H\n      rw [H]\n      apply dvd_zero\n    · norm_cast  at H⊢\n      convert zpow_zero _\n      rw [neg_eq_zero, padicValRat.of_int]\n      norm_cast\n      apply padicValInt.eq_zero_of_not_dvd h\n  · rintro ⟨x, rfl⟩\n    push_cast\n    rw [padic_norm_e.mul]\n    calc\n      _ ≤ «expr‖ ‖» (p : «exprℚ_[ ]» p) * 1 :=\n        mul_le_mul le_rfl (by simpa using norm_int_le_one _) (norm_nonneg _) (norm_nonneg _)\n      _ < 1 := _\n      \n    · rw [mul_one, padic_norm_e.norm_p]\n      apply inv_lt_one\n      exact_mod_cast hp.1.one_lt\n#align norm_int_lt_one_iff_dvd norm_int_lt_one_iff_dvd\n\n",
 "norm_int_le_pow_iff_dvd":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℚ_[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℚ_[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℚ_[ ]» -/\ntheorem norm_int_le_pow_iff_dvd (k : ℤ) (n : ℕ) : «expr‖ ‖» (k : «exprℚ_[ ]» p) ≤ ↑p ^ (-n : ℤ) ↔ ↑(p ^ n) ∣ k :=\n  by\n  have : (p : exprℝ) ^ (-n : ℤ) = ↑(p ^ (-n : ℤ) : exprℚ) := by simp\n  rw [show (k : «exprℚ_[ ]» p) = ((k : exprℚ) : «exprℚ_[ ]» p) by norm_cast, eq_padic_norm, this]\n  norm_cast\n  rw [← padicNorm.dvd_iff_norm_le]\n#align norm_int_le_pow_iff_dvd norm_int_le_pow_iff_dvd\n\n",
 "norm_int_le_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℚ_[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℚ_[ ]» -/\ntheorem norm_int_le_one (z : ℤ) : «expr‖ ‖» (z : «exprℚ_[ ]» p) ≤ 1 :=\n  suffices «expr‖ ‖» ((z : exprℚ) : «exprℚ_[ ]» p) ≤ 1 by simpa\n  norm_rat_le_one <| by simp [hp.1.ne_one]\n#align norm_int_le_one norm_int_le_one\n\n",
 "norm_equiv":
 "theorem norm_equiv {f g : padic_seq p} (hfg : f ≈ g) : f.norm = g.norm :=\n  if hf : f ≈ 0 then by\n    have hg : g ≈ 0 := setoid.trans (setoid.symm hfg) hf\n    simp [norm, hf, hg]\n  else by\n    have hg : ¬g ≈ 0 := hf ∘ setoid.trans hfg\n    unfold norm <;> split_ifs <;> exact norm_eq_of_equiv hf hg hfg\n#align norm_equiv norm_equiv\n\n",
 "norm_eq_pow_val":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℚ_[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem norm_eq_pow_val {x : «exprℚ_[ ]» p} : x ≠ 0 → «expr‖ ‖» x = p ^ (-x.valuation) :=\n  by\n  apply Quotient.inductionOn' x; clear x\n  intro f hf\n  change (padic_seq.norm _ : exprℝ) = (p : exprℝ) ^ (-padic_seq.valuation _)\n  rw [padic_seq.norm_eq_pow_val]\n  change ↑((p : exprℚ) ^ (-padic_seq.valuation f)) = (p : exprℝ) ^ (-padic_seq.valuation f)\n  · rw [Rat.cast_zpow, Rat.cast_coe_nat]\n  · apply CauSeq.not_limZero_of_not_congr_zero\n    contrapose! hf\n    apply quotient.sound\n    simpa using hf\n#align norm_eq_pow_val norm_eq_pow_val\n\n",
 "norm_eq_of_equiv_aux":
 "private theorem norm_eq_of_equiv_aux {f g : padic_seq p} (hf : ¬f ≈ 0) (hg : ¬g ≈ 0) (hfg : f ≈ g)\n    (h : padicNorm p (f (stationary_point hf)) ≠ padicNorm p (g (stationary_point hg)))\n    (hlt : padicNorm p (g (stationary_point hg)) < padicNorm p (f (stationary_point hf))) : False :=\n  by\n  have hpn : 0 < padicNorm p (f (stationary_point hf)) - padicNorm p (g (stationary_point hg)) := sub_pos_of_lt hlt\n  cases' hfg _ hpn with N hN\n  let i := max N (max (stationary_point hf) (stationary_point hg))\n  have hi : N ≤ i := le_max_left _ _\n  have hN' := hN _ hi\n  padic_index_simp [N, hf, hg]  at hN' h hlt\n  have hpne : padicNorm p (f i) ≠ padicNorm p (-g i) := by rwa [← padicNorm.neg (g i)] at h\n  let hpnem := add_eq_max_of_ne hpne\n  have hpeq : padicNorm p ((f - g) i) = max (padicNorm p (f i)) (padicNorm p (g i)) := by rwa [padicNorm.neg] at hpnem\n  rw [hpeq, max_eq_left_of_lt hlt] at hN'\n  have : padicNorm p (f i) < padicNorm p (f i) :=\n    by\n    apply lt_of_lt_of_le hN'\n    apply sub_le_self\n    apply padicNorm.nonneg\n  exact lt_irrefl _ this\n#align norm_eq_of_equiv_aux norm_eq_of_equiv_aux\n\n",
 "norm_eq_of_equiv":
 "private theorem norm_eq_of_equiv {f g : padic_seq p} (hf : ¬f ≈ 0) (hg : ¬g ≈ 0) (hfg : f ≈ g) :\n    padicNorm p (f (stationary_point hf)) = padicNorm p (g (stationary_point hg)) :=\n  by\n  by_contra h\n  cases' decidable.em (padicNorm p (g (stationary_point hg)) < padicNorm p (f (stationary_point hf))) with hlt hnlt\n  · exact norm_eq_of_equiv_aux hf hg hfg h hlt\n  · apply norm_eq_of_equiv_aux hg hf (setoid.symm hfg) (ne.symm h)\n    apply lt_of_le_of_ne\n    apply le_of_not_gt hnlt\n    apply h\n#align norm_eq_of_equiv norm_eq_of_equiv\n\n",
 "norm_eq_of_add_equiv_zero":
 "theorem norm_eq_of_add_equiv_zero {f g : padic_seq p} (h : f + g ≈ 0) : f.norm = g.norm :=\n  by\n  have : LimZero (f + g - 0) := h\n  have : f ≈ -g := show LimZero (f - -g) by simpa only [sub_zero, sub_neg_eq_add]\n  have : f.norm = (-g).norm := norm_equiv this\n  simpa only [norm_neg] using this\n#align norm_eq_of_add_equiv_zero norm_eq_of_add_equiv_zero\n\n",
 "norm_eq_norm_app_of_nonzero":
 "theorem norm_eq_norm_app_of_nonzero {f : padic_seq p} (hf : ¬f ≈ 0) : ∃ k, f.norm = padicNorm p k ∧ k ≠ 0 :=\n  have heq : f.norm = padicNorm p (f <| stationary_point hf) := by simp [norm, hf]\n  ⟨f <| stationary_point hf, HEq, fun h => norm_nonzero_of_not_equiv_zero hf (by simpa [h] using HEq)⟩\n#align norm_eq_norm_app_of_nonzero norm_eq_norm_app_of_nonzero\n\n",
 "norm_eq":
 "theorem norm_eq {f g : padic_seq p} (h : ∀ k, padicNorm p (f k) = padicNorm p (g k)) : f.norm = g.norm :=\n  if hf : f ≈ 0 then by\n    have hg : g ≈ 0 := equiv_zero_of_val_eq_of_equiv_zero h hf\n    simp only [hf, hg, norm, dif_pos]\n  else\n    by\n    have hg : ¬g ≈ 0 := fun hg =>\n      hf <| equiv_zero_of_val_eq_of_equiv_zero (by simp only [h, forall_const, eq_self_iff_true]) hg\n    simp only [hg, hf, norm, dif_neg, not_false_iff]\n    let i := max (stationary_point hf) (stationary_point hg)\n    have hpf : padicNorm p (f (stationary_point hf)) = padicNorm p (f i) :=\n      by\n      apply stationary_point_spec\n      apply le_max_left\n      exact le_rfl\n    have hpg : padicNorm p (g (stationary_point hg)) = padicNorm p (g i) :=\n      by\n      apply stationary_point_spec\n      apply le_max_right\n      exact le_rfl\n    rw [hpf, hpg, h]\n#align norm_eq norm_eq\n\n",
 "norm_const":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\ntheorem norm_const (q : exprℚ) : norm (const (padicNorm p) q) = padicNorm p q :=\n  if hq : q = 0 then\n    by\n    have : const (padicNorm p) q ≈ 0 := by simp [hq] <;> apply setoid.refl (const (padicNorm p) 0)\n    subst hq <;> simp [norm, this]\n  else by\n    have : ¬const (padicNorm p) q ≈ 0 := not_equiv_zero_const_of_nonzero hq\n    simp [norm, this]\n#align norm_const norm_const\n\n",
 "nonarchimedean'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℚ_[ ]» -/\n/-- Theorems about `padic_norm_e` are named with a `'` so the names do not conflict with the\nequivalent theorems about `norm` (`‖ ‖`). -/\ntheorem nonarchimedean' (q r : «exprℚ_[ ]» p) : padic_norm_e (q + r) ≤ max (padic_norm_e q) (padic_norm_e r) :=\n  quotient.induction_on₂ q r <| norm_nonarchimedean\n#align nonarchimedean' nonarchimedean'\n\n",
 "nonarchimedean":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℚ_[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem nonarchimedean (q r : «exprℚ_[ ]» p) : «expr‖ ‖» (q + r) ≤ max («expr‖ ‖» q) («expr‖ ‖» r) :=\n  by\n  unfold has_norm.norm\n  exact_mod_cast nonarchimedean' _ _\n#align nonarchimedean nonarchimedean\n\n",
 "ne_zero_iff_nequiv_zero":
 "theorem ne_zero_iff_nequiv_zero (f : padic_seq p) : mk f ≠ 0 ↔ ¬f ≈ 0 :=\n  not_iff_not.2 (eq_zero_iff_equiv_zero _)\n#align ne_zero_iff_nequiv_zero ne_zero_iff_nequiv_zero\n\n",
 "mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℚ_[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n@[simp]\nprotected theorem mul (q r : «exprℚ_[ ]» p) : «expr‖ ‖» (q * r) = «expr‖ ‖» q * «expr‖ ‖» r := by\n  simp [has_norm.norm, map_mul]\n#align mul mul\n\n",
 "mk_eq":
 "theorem mk_eq {f g : padic_seq p} : mk f = mk g ↔ f ≈ g :=\n  Quotient.eq'\n#align mk_eq mk_eq\n\n",
 "map_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℚ_[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n#print AddValuation.map_zero /-\n@[simp]\ntheorem AddValuation.map_zero : add_valuation_def (0 : «exprℚ_[ ]» p) = «expr⊤» := by\n  simp only [add_valuation_def, if_pos (Eq.refl _)]\n#align add_valuation.map_zero AddValuation.map_zero\n-/\n\n",
 "map_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℚ_[ ]» -/\n#print AddValuation.map_one /-\n@[simp]\ntheorem AddValuation.map_one : add_valuation_def (1 : «exprℚ_[ ]» p) = 0 := by\n  simp only [add_valuation_def, if_neg one_ne_zero, valuation_one, WithTop.coe_zero]\n#align add_valuation.map_one AddValuation.map_one\n-/\n\n",
 "map_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℚ_[ ]» -/\n#print AddValuation.map_mul /-\ntheorem AddValuation.map_mul (x y : «exprℚ_[ ]» p) :\n    add_valuation_def (x * y) = add_valuation_def x + add_valuation_def y :=\n  by\n  simp only [add_valuation_def]\n  by_cases hx : x = 0\n  · rw [hx, if_pos (Eq.refl _), MulZeroClass.zero_mul, if_pos (Eq.refl _), WithTop.top_add]\n  · by_cases hy : y = 0\n    · rw [hy, if_pos (Eq.refl _), MulZeroClass.mul_zero, if_pos (Eq.refl _), WithTop.add_top]\n    ·\n      rw [if_neg hx, if_neg hy, if_neg (mul_ne_zero hx hy), ← WithTop.coe_add, WithTop.coe_eq_coe,\n        valuation_map_mul hx hy]\n#align add_valuation.map_mul AddValuation.map_mul\n-/\n\n",
 "map_add":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℚ_[ ]» -/\n#print AddValuation.map_add /-\ntheorem AddValuation.map_add (x y : «exprℚ_[ ]» p) :\n    min (add_valuation_def x) (add_valuation_def y) ≤ add_valuation_def (x + y) :=\n  by\n  simp only [add_valuation_def]\n  by_cases hxy : x + y = 0\n  · rw [hxy, if_pos (Eq.refl _)]\n    exact le_top\n  · by_cases hx : x = 0\n    · simp only [hx, if_pos (Eq.refl _), min_eq_right, le_top, zero_add, le_refl]\n    · by_cases hy : y = 0\n      · simp only [hy, if_pos (Eq.refl _), min_eq_left, le_top, add_zero, le_refl]\n      · rw [if_neg hx, if_neg hy, if_neg hxy, ← WithTop.coe_min, WithTop.coe_le_coe]\n        exact valuation_map_add hxy\n#align add_valuation.map_add AddValuation.map_add\n-/\n\n",
 "lift_index_right":
 "/-- An auxiliary lemma for manipulating sequence indices. -/\ntheorem lift_index_right {f : padic_seq p} (hf : ¬f ≈ 0) (v1 v2 : ℕ) :\n    padicNorm p (f (stationary_point hf)) = padicNorm p (f (max v1 (max v2 (stationary_point hf)))) :=\n  by\n  apply stationary_point_spec hf\n  · apply le_trans\n    · apply le_max_right v2\n    · apply le_max_right\n  · exact le_rfl\n#align lift_index_right lift_index_right\n\n",
 "lift_index_left_left":
 "/-- An auxiliary lemma for manipulating sequence indices. -/\ntheorem lift_index_left_left {f : padic_seq p} (hf : ¬f ≈ 0) (v2 v3 : ℕ) :\n    padicNorm p (f (stationary_point hf)) = padicNorm p (f (max (stationary_point hf) (max v2 v3))) :=\n  by\n  apply stationary_point_spec hf\n  · apply le_max_left\n  · exact le_rfl\n#align lift_index_left_left lift_index_left_left\n\n",
 "lift_index_left":
 "/-- An auxiliary lemma for manipulating sequence indices. -/\ntheorem lift_index_left {f : padic_seq p} (hf : ¬f ≈ 0) (v1 v3 : ℕ) :\n    padicNorm p (f (stationary_point hf)) = padicNorm p (f (max v1 (max (stationary_point hf) v3))) :=\n  by\n  apply stationary_point_spec hf\n  · apply le_trans\n    · apply le_max_left _ v3\n    · apply le_max_right\n  · exact le_rfl\n#align lift_index_left lift_index_left\n\n",
 "is_rat":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℚ_[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\nprotected theorem is_rat (q : «exprℚ_[ ]» p) : ∃ q' : exprℚ, «expr‖ ‖» q = q' :=\n  if h : q = 0 then ⟨0, by simp [h]⟩\n  else\n    let ⟨n, hn⟩ := padic_norm_e.image h\n    ⟨_, hn⟩\n#align is_rat is_rat\n\n",
 "is_norm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℚ_[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\nprotected theorem is_norm (q : «exprℚ_[ ]» p) : ↑(padic_norm_e q) = «expr‖ ‖» q :=\n  rfl\n#align is_norm is_norm\n\n",
 "image'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℚ_[ ]» -/\nprotected theorem image' {q : «exprℚ_[ ]» p} : q ≠ 0 → ∃ n : ℤ, padic_norm_e q = p ^ (-n) :=\n  Quotient.inductionOn q fun f hf =>\n    have : ¬f ≈ 0 := (ne_zero_iff_nequiv_zero f).1 hf\n    norm_values_discrete f this\n#align image' image'\n\n",
 "image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℚ_[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\nprotected theorem image {q : «exprℚ_[ ]» p} : q ≠ 0 → ∃ n : ℤ, «expr‖ ‖» q = ↑((p : exprℚ) ^ (-n)) :=\n  Quotient.inductionOn q fun f hf =>\n    have : ¬f ≈ 0 := (padic_seq.ne_zero_iff_nequiv_zero f).1 hf\n    let ⟨n, hn⟩ := padic_seq.norm_values_discrete f this\n    ⟨n, congr_arg coe hn⟩\n#align image image\n\n",
 "exi_rat_seq_conv_cauchy":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\ntheorem exi_rat_seq_conv_cauchy : IsCauSeq (padicNorm p) (lim_seq f) := fun ε hε =>\n  by\n  have hε3 : 0 < ε / 3 := div_pos hε (by norm_num)\n  let ⟨N, hN⟩ := exi_rat_seq_conv f hε3\n  let ⟨N2, hN2⟩ := f.cauchy₂ hε3\n  exists max N N2\n  intro j hj\n  suffices padic_norm_e (lim_seq f j - f (max N N2) + (f (max N N2) - lim_seq f (max N N2))) < ε\n    by\n    ring_nf  at this⊢\n    rw [← padic_norm_e.eq_padic_norm']\n    exact_mod_cast this\n  · apply lt_of_le_of_lt\n    · apply padic_norm_e.add_le\n    · have : (3 : exprℚ) ≠ 0 := by norm_num\n      have : ε = ε / 3 + ε / 3 + ε / 3 := by\n        field_simp [this]\n        simp only [bit0, bit1, mul_add, mul_one]\n      rw [this]\n      apply add_lt_add\n      · suffices padic_norm_e (lim_seq f j - f j + (f j - f (max N N2))) < ε / 3 + ε / 3 by\n          simpa only [sub_add_sub_cancel]\n        apply lt_of_le_of_lt\n        · apply padic_norm_e.add_le\n        · apply add_lt_add\n          · rw [padic_norm_e.map_sub]\n            apply_mod_cast hN\n            exact le_of_max_le_left hj\n          · exact hN2 _ (le_of_max_le_right hj) _ (le_max_right _ _)\n      · apply_mod_cast hN\n        apply le_max_left\n#align exi_rat_seq_conv_cauchy exi_rat_seq_conv_cauchy\n\n",
 "exi_rat_seq_conv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℚ_[ ]» -/\ntheorem exi_rat_seq_conv {ε : exprℚ} (hε : 0 < ε) :\n    ∃ N, ∀ i ≥ N, padic_norm_e (f i - (lim_seq f i : «exprℚ_[ ]» p)) < ε :=\n  by\n  refine' (exists_nat_gt (1 / ε)).imp fun N hN i hi => _\n  have h := Classical.choose_spec (rat_dense' (f i) (div_nat_pos i))\n  refine' lt_of_lt_of_le h ((div_le_iff' <| by exact_mod_cast succ_pos _).mpr _)\n  rw [right_distrib]\n  apply le_add_of_le_of_nonneg\n  · exact (div_le_iff hε).mp (le_trans (le_of_lt hN) (by exact_mod_cast hi))\n  · apply le_of_lt\n    simpa\n#align exi_rat_seq_conv exi_rat_seq_conv\n\n",
 "equiv_zero_of_val_eq_of_equiv_zero":
 "theorem equiv_zero_of_val_eq_of_equiv_zero {f g : padic_seq p} (h : ∀ k, padicNorm p (f k) = padicNorm p (g k))\n    (hf : f ≈ 0) : g ≈ 0 := fun ε hε =>\n  let ⟨i, hi⟩ := hf _ hε\n  ⟨i, fun j hj => by simpa [h] using hi _ hj⟩\n#align equiv_zero_of_val_eq_of_equiv_zero equiv_zero_of_val_eq_of_equiv_zero\n\n",
 "eq_zero_iff_equiv_zero":
 "theorem eq_zero_iff_equiv_zero (f : padic_seq p) : mk f = 0 ↔ f ≈ 0 :=\n  mk_eq\n#align eq_zero_iff_equiv_zero eq_zero_iff_equiv_zero\n\n",
 "eq_rat_norm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℚ_[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem eq_rat_norm (q : «exprℚ_[ ]» p) : «expr‖ ‖» q = rat_norm q :=\n  Classical.choose_spec (padic_norm_e.is_rat q)\n#align eq_rat_norm eq_rat_norm\n\n",
 "eq_padic_norm'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℚ_[ ]» -/\n@[simp]\ntheorem eq_padic_norm' (q : exprℚ) : padic_norm_e (q : «exprℚ_[ ]» p) = padicNorm p q :=\n  norm_const _\n#align eq_padic_norm' eq_padic_norm'\n\n",
 "eq_padic_norm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℚ_[ ]» -/\n@[simp]\ntheorem eq_padic_norm (q : exprℚ) : «expr‖ ‖» (q : «exprℚ_[ ]» p) = padicNorm p q :=\n  by\n  unfold has_norm.norm\n  rw [← padic_norm_e.eq_padic_norm']\n#align eq_padic_norm eq_padic_norm\n\n",
 "eq_of_norm_add_lt_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℚ_[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem eq_of_norm_add_lt_right {z1 z2 : «exprℚ_[ ]» p} (h : «expr‖ ‖» (z1 + z2) < «expr‖ ‖» z2) :\n    «expr‖ ‖» z1 = «expr‖ ‖» z2 :=\n  by_contradiction fun hne => not_lt_of_ge (by rw [padic_norm_e.add_eq_max_of_ne hne] <;> apply le_max_right) h\n#align eq_of_norm_add_lt_right eq_of_norm_add_lt_right\n\n",
 "eq_of_norm_add_lt_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℚ_[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem eq_of_norm_add_lt_left {z1 z2 : «exprℚ_[ ]» p} (h : «expr‖ ‖» (z1 + z2) < «expr‖ ‖» z1) :\n    «expr‖ ‖» z1 = «expr‖ ‖» z2 :=\n  by_contradiction fun hne => not_lt_of_ge (by rw [padic_norm_e.add_eq_max_of_ne hne] <;> apply le_max_left) h\n#align eq_of_norm_add_lt_left eq_of_norm_add_lt_left\n\n",
 "div_nat_pos":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\nprivate theorem div_nat_pos (n : ℕ) : 0 < 1 / (n + 1 : exprℚ) :=\n  div_pos zero_lt_one (by exact_mod_cast succ_pos _)\n#align div_nat_pos div_nat_pos\n\n",
 "defn":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟦ ⟧» -/\ntheorem defn (f : padic_seq p) {ε : exprℚ} (hε : 0 < ε) : ∃ N, ∀ i ≥ N, padic_norm_e («expr⟦ ⟧» f - f i) < ε :=\n  by\n  dsimp [padic_norm_e]\n  change ∃ N, ∀ i ≥ N, (f - const _ (f i)).norm < ε\n  by_contra' h\n  cases' cauchy₂ f hε with N hN\n  rcases h N with ⟨i, hi, hge⟩\n  have hne : ¬f - const (padicNorm p) (f i) ≈ 0 := by\n    intro h\n    unfold padic_seq.norm at hge <;> split_ifs  at hge\n    exact not_lt_of_ge hge hε\n  unfold padic_seq.norm at hge <;> split_ifs  at hge\n  apply not_le_of_gt _ hge\n  cases' em (N ≤ stationary_point hne) with hgen hngen\n  · apply hN _ hgen _ hi\n  · have := stationary_point_spec hne le_rfl (le_of_not_le hngen)\n    rw [← this]\n    exact hN _ le_rfl _ hi\n#align defn defn\n\n",
 "const_equiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\ntheorem const_equiv {q r : exprℚ} : const (padicNorm p) q ≈ const (padicNorm p) r ↔ q = r :=\n  ⟨fun heq => eq_of_sub_eq_zero <| const_limZero.1 HEq, fun heq => by rw [HEq] <;> apply setoid.refl _⟩\n#align const_equiv const_equiv\n\n",
 "complete'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℚ_[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℚ_[ ]» -/\ntheorem complete' : ∃ q : «exprℚ_[ ]» p, ∀ ε > 0, ∃ N, ∀ i ≥ N, padic_norm_e (q - f i) < ε :=\n  ⟨limUnder f, fun ε hε => by\n    obtain ⟨N, hN⟩ := exi_rat_seq_conv f (half_pos hε)\n    obtain ⟨N2, hN2⟩ := padic_norm_e.defn (lim' f) (half_pos hε)\n    refine' ⟨max N N2, fun i hi => _⟩\n    rw [← sub_add_sub_cancel _ (lim' f i : «exprℚ_[ ]» p) _]\n    refine' (padic_norm_e.add_le _ _).trans_lt _\n    rw [← add_halves ε]\n    apply add_lt_add\n    · apply hN2 _ (le_of_max_le_right hi)\n    · rw [padic_norm_e.map_sub]\n      exact hN _ (le_of_max_le_left hi)⟩\n#align complete' complete'\n\n",
 "coe_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℚ_[ ]» -/\n@[norm_cast]\ntheorem coe_zero : (↑0 : «exprℚ_[ ]» p) = 0 :=\n  rfl\n#align coe_zero coe_zero\n\n",
 "coe_sub":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℚ_[ ]» -/\n@[norm_cast]\ntheorem coe_sub : ∀ {x y : exprℚ}, (↑(x - y) : «exprℚ_[ ]» p) = ↑x - ↑y :=\n  Rat.cast_sub\n#align coe_sub coe_sub\n\n",
 "coe_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℚ_[ ]» -/\n@[norm_cast]\ntheorem coe_one : (↑1 : «exprℚ_[ ]» p) = 1 :=\n  rfl\n#align coe_one coe_one\n\n",
 "coe_neg":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℚ_[ ]» -/\n@[norm_cast]\ntheorem coe_neg : ∀ {x : exprℚ}, (↑(-x) : «exprℚ_[ ]» p) = -↑x :=\n  Rat.cast_neg\n#align coe_neg coe_neg\n\n",
 "coe_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℚ_[ ]» -/\n@[norm_cast]\ntheorem coe_mul : ∀ {x y : exprℚ}, (↑(x * y) : «exprℚ_[ ]» p) = ↑x * ↑y :=\n  Rat.cast_mul\n#align coe_mul coe_mul\n\n",
 "coe_inj":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℚ_[ ]» -/\n@[norm_cast]\ntheorem coe_inj {q r : exprℚ} : (↑q : «exprℚ_[ ]» p) = ↑r ↔ q = r :=\n  ⟨(const_equiv p).1 ∘ Quotient.eq'.1, fun h => by rw [h]⟩\n#align coe_inj coe_inj\n\n",
 "coe_div":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℚ_[ ]» -/\n@[norm_cast]\ntheorem coe_div : ∀ {x y : exprℚ}, (↑(x / y) : «exprℚ_[ ]» p) = ↑x / ↑y :=\n  Rat.cast_div\n#align coe_div coe_div\n\n",
 "coe_add":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℚ_[ ]» -/\n@[norm_cast]\ntheorem coe_add : ∀ {x y : exprℚ}, (↑(x + y) : «exprℚ_[ ]» p) = ↑x + ↑y :=\n  Rat.cast_add\n#align coe_add coe_add\n\n",
 "apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℚ_[ ]» -/\n@[simp]\ntheorem add_valuation.apply {x : «exprℚ_[ ]» p} (hx : x ≠ 0) : x.add_valuation = x.valuation := by\n  simp only [AddValuation, AddValuation.of_apply, add_valuation_def, if_neg hx]\n#align add_valuation.apply add_valuation.apply\n\n",
 "add_eq_max_of_ne'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℚ_[ ]» -/\n/-- Theorems about `padic_norm_e` are named with a `'` so the names do not conflict with the\nequivalent theorems about `norm` (`‖ ‖`). -/\ntheorem add_eq_max_of_ne' {q r : «exprℚ_[ ]» p} :\n    padic_norm_e q ≠ padic_norm_e r → padic_norm_e (q + r) = max (padic_norm_e q) (padic_norm_e r) :=\n  quotient.induction_on₂ q r fun _ _ => padic_seq.add_eq_max_of_ne\n#align add_eq_max_of_ne' add_eq_max_of_ne'\n\n",
 "add_eq_max_of_ne":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℚ_[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem add_eq_max_of_ne {q r : «exprℚ_[ ]» p} (h : «expr‖ ‖» q ≠ «expr‖ ‖» r) :\n    «expr‖ ‖» (q + r) = max («expr‖ ‖» q) («expr‖ ‖» r) :=\n  by\n  unfold has_norm.norm\n  apply_mod_cast add_eq_max_of_ne'\n  intro h'\n  apply h\n  unfold has_norm.norm\n  exact_mod_cast h'\n#align add_eq_max_of_ne add_eq_max_of_ne\n\n"}