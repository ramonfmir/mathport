{"zero_of_padic_norm_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/-- If the `p`-adic norm of `q` is 0, then `q` is `0`. -/\ntheorem zero_of_padic_norm_eq_zero {q : exprℚ} (h : padicNorm p q = 0) : q = 0 :=\n  by\n  apply by_contradiction; intro hq\n  unfold padicNorm at h; rw [if_neg hq] at h\n  apply absurd h\n  apply zpow_ne_zero_of_ne_zero\n  exact_mod_cast hp.1.ne_zero\n#align zero_of_padic_norm_eq_zero zero_of_padic_norm_eq_zero\n\n",
 "zero":
 "/-- The `p`-adic norm of `0` is `0`. -/\n@[simp]\nprotected theorem zero : padicNorm p 0 = 0 := by simp [padicNorm]\n#align zero zero\n\n",
 "values_discrete":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/-- `padic_norm p q` takes discrete values `p ^ -z` for `z : ℤ`. -/\nprotected theorem values_discrete {q : exprℚ} (hq : q ≠ 0) : ∃ z : ℤ, padicNorm p q = p ^ (-z) :=\n  ⟨padicValRat p q, by simp [padicNorm, hq]⟩\n#align values_discrete values_discrete\n\n",
 "triangle_ineq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/-- The `p`-adic norm respects the triangle inequality: the norm of `p + q` is at most the norm of\n`p` plus the norm of `q`. -/\ntheorem triangle_ineq (q r : exprℚ) : padicNorm p (q + r) ≤ padicNorm p q + padicNorm p r :=\n  calc\n    padicNorm p (q + r) ≤ max (padicNorm p q) (padicNorm p r) := padicNorm.nonarchimedean\n    _ ≤ padicNorm p q + padicNorm p r := max_le_add_of_nonneg (padicNorm.nonneg _) (padicNorm.nonneg _)\n    \n#align triangle_ineq triangle_ineq\n\n",
 "sum_lt'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem sum_lt' {α : Type _} {F : α → exprℚ} {t : exprℚ} {s : Finset α} (hF : ∀ i ∈ s, padicNorm p (F i) < t)\n    (ht : 0 < t) :\n    padicNorm p\n        (finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s (F i)) <\n      t :=\n  by\n  obtain rfl | hs := Finset.eq_empty_or_nonempty s\n  · simp [ht]\n  · exact sum_lt hs hF\n#align sum_lt' sum_lt'\n\n",
 "sum_lt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem sum_lt {α : Type _} {F : α → exprℚ} {t : exprℚ} {s : Finset α} :\n    s.nonempty →\n      (∀ i ∈ s, padicNorm p (F i) < t) →\n        padicNorm p\n            (finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s (F i)) <\n          t :=\n  by\n  classical\n    refine' s.induction_on (by rintro ⟨-, ⟨⟩⟩) _\n    rintro a S haS IH - ht\n    by_cases hs : S.nonempty\n    · rw [Finset.sum_insert haS]\n      exact\n        lt_of_le_of_lt padicNorm.nonarchimedean\n          (max_lt (ht a (Finset.mem_insert_self a S)) (IH hs fun b hb => ht b (Finset.mem_insert_of_mem hb)))\n    · simp_all\n#align sum_lt sum_lt\n\n",
 "sum_le'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem sum_le' {α : Type _} {F : α → exprℚ} {t : exprℚ} {s : Finset α} (hF : ∀ i ∈ s, padicNorm p (F i) ≤ t)\n    (ht : 0 ≤ t) :\n    padicNorm p\n        (finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s (F i)) ≤\n      t :=\n  by\n  obtain rfl | hs := Finset.eq_empty_or_nonempty s\n  · simp [ht]\n  · exact sum_le hs hF\n#align sum_le' sum_le'\n\n",
 "sum_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem sum_le {α : Type _} {F : α → exprℚ} {t : exprℚ} {s : Finset α} :\n    s.nonempty →\n      (∀ i ∈ s, padicNorm p (F i) ≤ t) →\n        padicNorm p\n            (finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s (F i)) ≤\n          t :=\n  by\n  classical\n    refine' s.induction_on (by rintro ⟨-, ⟨⟩⟩) _\n    rintro a S haS IH - ht\n    by_cases hs : S.nonempty\n    · rw [Finset.sum_insert haS]\n      exact\n        padic_norm.nonarchimedean.trans\n          (max_le (ht a (Finset.mem_insert_self a S)) (IH hs fun b hb => ht b (Finset.mem_insert_of_mem hb)))\n    · simp_all\n#align sum_le sum_le\n\n",
 "sub":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/-- The `p`-adic norm of a difference is at most the max of each component. Restates the archimedean\nproperty of the `p`-adic norm. -/\nprotected theorem sub {q r : exprℚ} : padicNorm p (q - r) ≤ max (padicNorm p q) (padicNorm p r) := by\n  rw [sub_eq_add_neg, ← padicNorm.neg r] <;> apply padicNorm.nonarchimedean\n#align sub sub\n\n",
 "padic_norm_p_of_prime":
 "/-- The `p`-adic norm of `p` is `p⁻¹` if `p` is prime.\n\nSee also `padic_norm.padic_norm_p` for a version assuming `1 < p`. -/\n@[simp]\ntheorem padic_norm_p_of_prime [Fact p.prime] : padicNorm p p = p⁻¹ :=\n  padicNorm_p <| Nat.Prime.one_lt (fact.out _)\n#align padic_norm_p_of_prime padic_norm_p_of_prime\n\n",
 "padic_norm_p_lt_one_of_prime":
 "/-- The `p`-adic norm of `p` is less than `1` if `p` is prime.\n\nSee also `padic_norm.padic_norm_p_lt_one` for a version assuming `1 < p`. -/\ntheorem padic_norm_p_lt_one_of_prime [Fact p.prime] : padicNorm p p < 1 :=\n  padicNorm_p_lt_one <| Nat.Prime.one_lt (fact.out _)\n#align padic_norm_p_lt_one_of_prime padic_norm_p_lt_one_of_prime\n\n",
 "padic_norm_p_lt_one":
 "/-- The `p`-adic norm of `p` is less than `1` if `1 < p`.\n\nSee also `padic_norm.padic_norm_p_lt_one_of_prime` for a version assuming `p` is prime. -/\ntheorem padic_norm_p_lt_one (hp : 1 < p) : padicNorm p p < 1 :=\n  by\n  rw [padic_norm_p hp, inv_lt_one_iff]\n  exact_mod_cast or.inr hp\n#align padic_norm_p_lt_one padic_norm_p_lt_one\n\n",
 "padic_norm_p":
 "/-- The `p`-adic norm of `p` is `p⁻¹` if `p > 1`.\n\nSee also `padic_norm.padic_norm_p_of_prime` for a version assuming `p` is prime. -/\ntheorem padic_norm_p (hp : 1 < p) : padicNorm p p = p⁻¹ := by simp [padicNorm, (pos_of_gt hp).ne', padicValNat.self hp]\n#align padic_norm_p padic_norm_p\n\n",
 "padic_norm_of_prime_of_ne":
 "/-- The `p`-adic norm of `q` is `1` if `q` is prime and not equal to `p`. -/\ntheorem padic_norm_of_prime_of_ne {q : ℕ} [p_prime : Fact p.prime] [q_prime : Fact q.prime] (neq : p ≠ q) :\n    padicNorm p q = 1 :=\n  by\n  have p : padicValRat p q = 0 := by exact_mod_cast @padicValNat_primes p q p_prime q_prime neq\n  simp [padicNorm, p, q_prime.1.1, q_prime.1.ne_zero]\n#align padic_norm_of_prime_of_ne padic_norm_of_prime_of_ne\n\n",
 "one":
 "/-- The `p`-adic norm of `1` is `1`. -/\n@[simp]\nprotected theorem one : padicNorm p 1 = 1 := by simp [padicNorm]\n#align one one\n\n",
 "of_nat":
 "theorem of_nat (m : ℕ) : padicNorm p m ≤ 1 :=\n  padicNorm.of_int (m : ℤ)\n#align of_nat of_nat\n\n",
 "of_int":
 "/-- The `p`-adic norm of an integer is at most `1`. -/\nprotected theorem of_int (z : ℤ) : padicNorm p z ≤ 1 :=\n  if hz : z = 0 then by simp [hz, zero_le_one]\n  else by\n    unfold padicNorm\n    rw [if_neg _]\n    · refine' zpow_le_one_of_nonpos _ _\n      · exact_mod_cast le_of_lt hp.1.one_lt\n      · rw [padicValRat.of_int, neg_nonpos]\n        norm_cast\n        simp\n    exact_mod_cast hz\n#align of_int of_int\n\n",
 "nonzero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/-- If `q ≠ 0`, then `padic_norm p q ≠ 0`. -/\nprotected theorem nonzero {q : exprℚ} (hq : q ≠ 0) : padicNorm p q ≠ 0 :=\n  by\n  rw [padicNorm.eq_zpow_of_nonzero hq]\n  apply zpow_ne_zero_of_ne_zero\n  exact_mod_cast ne_of_gt hp.1.pos\n#align nonzero nonzero\n\n",
 "nonneg":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/-- The `p`-adic norm is nonnegative. -/\nprotected theorem nonneg (q : exprℚ) : 0 ≤ padicNorm p q :=\n  if hq : q = 0 then by simp [hq, padicNorm]\n  else by\n    unfold padicNorm <;> split_ifs\n    apply zpow_nonneg\n    exact_mod_cast nat.zero_le _\n#align nonneg nonneg\n\n",
 "nonarchimedean_aux":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\nprivate theorem nonarchimedean_aux {q r : exprℚ} (h : padicValRat p q ≤ padicValRat p r) :\n    padicNorm p (q + r) ≤ max (padicNorm p q) (padicNorm p r) :=\n  have hnqp : padicNorm p q ≥ 0 := padicNorm.nonneg _\n  have hnrp : padicNorm p r ≥ 0 := padicNorm.nonneg _\n  if hq : q = 0 then by simp [hq, max_eq_right hnrp, le_max_right]\n  else\n    if hr : r = 0 then by simp [hr, max_eq_left hnqp, le_max_left]\n    else\n      if hqr : q + r = 0 then le_trans (by simpa [hqr] using hnqp) (le_max_left _ _)\n      else by\n        unfold padicNorm; split_ifs\n        apply le_max_iff.2\n        left\n        apply zpow_le_of_le\n        · exact_mod_cast le_of_lt hp.1.one_lt\n        · apply neg_le_neg\n          have : padicValRat p q = min (padicValRat p q) (padicValRat p r) := (min_eq_left h).symm\n          rw [this]\n          apply min_le_padic_val_rat_add <;> assumption\n#align nonarchimedean_aux nonarchimedean_aux\n\n",
 "nonarchimedean":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/-- The `p`-adic norm is nonarchimedean: the norm of `p + q` is at most the max of the norm of `p`\nand the norm of `q`. -/\nprotected theorem nonarchimedean {q r : exprℚ} : padicNorm p (q + r) ≤ max (padicNorm p q) (padicNorm p r) :=\n  by\n  wlog hle : padicValRat p q ≤ padicValRat p r generalizing q r\n  · rw [add_comm, max_comm]\n    exact this (le_of_not_le hle)\n  exact nonarchimedean_aux hle\n#align nonarchimedean nonarchimedean\n\n",
 "neg":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/-- `padic_norm p` is symmetric. -/\n@[simp]\nprotected theorem neg (q : exprℚ) : padicNorm p (-q) = padicNorm p q :=\n  if hq : q = 0 then by simp [hq] else by simp [padicNorm, hq]\n#align neg neg\n\n",
 "nat_lt_one_iff":
 "theorem nat_lt_one_iff (m : ℕ) : padicNorm p m < 1 ↔ p ∣ m := by\n  simp only [← Int.coe_nat_dvd, ← int_lt_one_iff, Int.cast_ofNat]\n#align nat_lt_one_iff nat_lt_one_iff\n\n",
 "nat_eq_one_iff":
 "/-- The `p`-adic norm of a natural `m` is one iff `p` doesn't divide `m`. -/\ntheorem nat_eq_one_iff (m : ℕ) : padicNorm p m = 1 ↔ ¬p ∣ m := by\n  simp only [← Int.coe_nat_dvd, ← int_eq_one_iff, Int.cast_ofNat]\n#align nat_eq_one_iff nat_eq_one_iff\n\n",
 "mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/-- The `p`-adic norm is multiplicative. -/\n@[simp]\nprotected theorem mul (q r : exprℚ) : padicNorm p (q * r) = padicNorm p q * padicNorm p r :=\n  if hq : q = 0 then by simp [hq]\n  else\n    if hr : r = 0 then by simp [hr]\n    else by\n      have : q * r ≠ 0 := mul_ne_zero hq hr\n      have : (p : exprℚ) ≠ 0 := by simp [hp.1.ne_zero]\n      simp [padicNorm, *, padicValRat.mul, zpow_add₀ this, mul_comm]\n#align mul mul\n\n",
 "int_lt_one_iff":
 "theorem int_lt_one_iff (m : ℤ) : padicNorm p m < 1 ↔ (p : ℤ) ∣ m :=\n  by\n  rw [← not_iff_not, ← int_eq_one_iff, eq_iff_le_not_lt]\n  simp only [padicNorm.of_int, true_and_iff]\n#align int_lt_one_iff int_lt_one_iff\n\n",
 "int_eq_one_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/-- The `p`-adic norm of an integer `m` is one iff `p` doesn't divide `m`. -/\ntheorem int_eq_one_iff (m : ℤ) : padicNorm p m = 1 ↔ ¬(p : ℤ) ∣ m :=\n  by\n  nth_rw 2 [← pow_one p]\n  simp only [dvd_iff_norm_le, Int.cast_ofNat, Nat.cast_one, zpow_neg, zpow_one, not_le]\n  constructor\n  · intro h\n    rw [h, inv_lt_one_iff_of_pos] <;> norm_cast\n    · exact Nat.Prime.one_lt (fact.out _)\n    · exact Nat.Prime.pos (fact.out _)\n  · simp only [padicNorm]\n    split_ifs\n    · rw [inv_lt_zero, ← Nat.cast_zero, Nat.cast_lt]\n      intro h\n      exact (nat.not_lt_zero p h).elim\n    · have : 1 < (p : exprℚ) := by norm_cast <;> exact Nat.Prime.one_lt (fact.out _ : Nat.Prime p)\n      rw [← zpow_neg_one, zpow_lt_iff_lt this]\n      have : 0 ≤ padicValRat p m\n      simp only [of_int, Nat.cast_nonneg]\n      intro h\n      rw [← zpow_zero (p : exprℚ), zpow_inj] <;> linarith\n#align int_eq_one_iff int_eq_one_iff\n\n",
 "eq_zpow_of_nonzero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/-\nCopyright (c) 2018 Robert Y. Lewis. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Robert Y. Lewis\n-/\n/-- Unfolds the definition of the `p`-adic norm of `q` when `q ≠ 0`. -/\n@[simp]\nprotected theorem eq_zpow_of_nonzero {q : exprℚ} (hq : q ≠ 0) : padicNorm p q = p ^ (-padicValRat p q) := by\n  simp [hq, padicNorm]\n#align eq_zpow_of_nonzero eq_zpow_of_nonzero\n\n",
 "dvd_iff_norm_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\ntheorem dvd_iff_norm_le {n : ℕ} {z : ℤ} : ↑(p ^ n) ∣ z ↔ padicNorm p z ≤ p ^ (-n : ℤ) :=\n  by\n  unfold padicNorm; split_ifs with hz\n  · norm_cast  at hz\n    have : 0 ≤ (p ^ n : exprℚ) := by\n      apply pow_nonneg\n      exact_mod_cast le_of_lt hp.1.pos\n    simp [hz, this]\n  · rw [zpow_le_iff_le, neg_le_neg_iff, padicValRat.of_int, padicValInt.of_ne_one_ne_zero hp.1.ne_one _]\n    · norm_cast\n      rw [← PartENat.coe_le_coe, PartENat.natCast_get, ← multiplicity.pow_dvd_iff_le_multiplicity]\n      simp\n    · exact_mod_cast hz\n    · exact_mod_cast hp.1.one_lt\n#align dvd_iff_norm_le dvd_iff_norm_le\n\n",
 "div":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/-- The `p`-adic norm respects division. -/\n@[simp]\nprotected theorem div (q r : exprℚ) : padicNorm p (q / r) = padicNorm p q / padicNorm p r :=\n  if hr : r = 0 then by simp [hr]\n  else eq_div_of_mul_eq (padicNorm.nonzero hr) (by rw [← padicNorm.mul, div_mul_cancel _ hr])\n#align div div\n\n",
 "add_eq_max_of_ne":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/-- If the `p`-adic norms of `q` and `r` are different, then the norm of `q + r` is equal to the max\nof the norms of `q` and `r`. -/\ntheorem add_eq_max_of_ne {q r : exprℚ} (hne : padicNorm p q ≠ padicNorm p r) :\n    padicNorm p (q + r) = max (padicNorm p q) (padicNorm p r) :=\n  by\n  wlog hlt : padicNorm p r < padicNorm p q\n  · rw [add_comm, max_comm]\n    exact this hne.symm (hne.lt_or_lt.resolve_right hlt)\n  have : padicNorm p q ≤ max (padicNorm p (q + r)) (padicNorm p r) :=\n    calc\n      padicNorm p q = padicNorm p (q + r - r) := by congr <;> ring\n      _ ≤ max (padicNorm p (q + r)) (padicNorm p (-r)) := padicNorm.nonarchimedean\n      _ = max (padicNorm p (q + r)) (padicNorm p r) := by simp\n      \n  have hnge : padicNorm p r ≤ padicNorm p (q + r) :=\n    by\n    apply le_of_not_gt\n    intro hgt\n    rw [max_eq_right_of_lt hgt] at this\n    apply not_lt_of_ge this\n    assumption\n  have : padicNorm p q ≤ padicNorm p (q + r) := by rwa [max_eq_left hnge] at this\n  apply _root_.le_antisymm\n  · apply padicNorm.nonarchimedean\n  · rwa [max_eq_left_of_lt hlt]\n#align add_eq_max_of_ne add_eq_max_of_ne\n\n"}