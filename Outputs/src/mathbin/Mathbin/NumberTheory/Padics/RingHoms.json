{"zmod_repr_spec":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ_[ ]» -/\ntheorem zmod_repr_spec : zmod_repr x < p ∧ x - zmod_repr x ∈ maximal_ideal («exprℤ_[ ]» p) :=\n  Classical.choose_spec (exists_mem_range x)\n#align zmod_repr_spec zmod_repr_spec\n\n",
 "zmod_repr_lt_p":
 "theorem zmod_repr_lt_p : zmod_repr x < p :=\n  (zmod_repr_spec _).1\n#align zmod_repr_lt_p zmod_repr_lt_p\n\n",
 "zmod_congr_of_sub_mem_span_aux":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ_[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ_[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ_[ ]» -/\ntheorem zmod_congr_of_sub_mem_span_aux (n : ℕ) (x : «exprℤ_[ ]» p) (a b : ℤ)\n    (ha : x - a ∈ (ideal.span {p ^ n} : ideal («exprℤ_[ ]» p)))\n    (hb : x - b ∈ (ideal.span {p ^ n} : ideal («exprℤ_[ ]» p))) : (a : zmod (p ^ n)) = b :=\n  by\n  rw [ideal.mem_span_singleton] at ha hb\n  rw [← sub_eq_zero, ← Int.cast_sub, zmod.int_coe_zmod_eq_zero_iff_dvd, Int.coe_nat_pow]\n  rw [← dvd_neg, neg_sub] at ha\n  have := dvd_add ha hb\n  rwa [sub_eq_add_neg, sub_eq_add_neg, add_assoc, neg_add_cancel_left, ← sub_eq_add_neg, ← Int.cast_sub,\n    pow_p_dvd_int_iff] at this\n#align zmod_congr_of_sub_mem_span_aux zmod_congr_of_sub_mem_span_aux\n\n",
 "zmod_congr_of_sub_mem_span":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ_[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ_[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ_[ ]» -/\ntheorem zmod_congr_of_sub_mem_span (n : ℕ) (x : «exprℤ_[ ]» p) (a b : ℕ)\n    (ha : x - a ∈ (ideal.span {p ^ n} : ideal («exprℤ_[ ]» p)))\n    (hb : x - b ∈ (ideal.span {p ^ n} : ideal («exprℤ_[ ]» p))) : (a : zmod (p ^ n)) = b := by\n  simpa using zmod_congr_of_sub_mem_span_aux n x a b ha hb\n#align zmod_congr_of_sub_mem_span zmod_congr_of_sub_mem_span\n\n",
 "zmod_congr_of_sub_mem_max_ideal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ_[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ_[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ_[ ]» -/\ntheorem zmod_congr_of_sub_mem_max_ideal (x : «exprℤ_[ ]» p) (m n : ℕ) (hm : x - m ∈ maximal_ideal («exprℤ_[ ]» p))\n    (hn : x - n ∈ maximal_ideal («exprℤ_[ ]» p)) : (m : zmod p) = n :=\n  by\n  rw [maximal_ideal_eq_span_p] at hm hn\n  have := zmod_congr_of_sub_mem_span_aux 1 x m n\n  simp only [pow_one] at this\n  specialize this hm hn\n  apply_fun zmod.cast_hom (show p ∣ p ^ 1 by rw [pow_one]) (zmod p)  at this\n  simp only [map_intCast] at this\n  simpa only [Int.cast_ofNat] using this\n#align zmod_congr_of_sub_mem_max_ideal zmod_congr_of_sub_mem_max_ideal\n\n",
 "zmod_cast_comp_to_zmod_pow":
 "@[simp]\ntheorem zmod_cast_comp_to_zmod_pow (m n : ℕ) (h : m ≤ n) :\n    (zmod.cast_hom (pow_dvd_pow p h) (zmod (p ^ m))).comp (to_zmod_pow n) = to_zmod_pow m :=\n  by\n  apply zmod.ring_hom_eq_of_ker_eq\n  ext x\n  rw [ring_hom.mem_ker, ring_hom.mem_ker]\n  simp only [Function.comp_apply, zmod.cast_hom_apply, RingHom.coe_comp]\n  simp only [to_zmod_pow, to_zmod_hom, RingHom.coe_mk]\n  rw [zmod.cast_nat_cast (pow_dvd_pow p h), zmod_congr_of_sub_mem_span m (x.appr n) (x.appr n) (x.appr m)]\n  · rw [sub_self]\n    apply ideal.zero_mem _\n  · rw [ideal.mem_span_singleton]\n    rcases dvd_appr_sub_appr x m n h with ⟨c, hc⟩\n    use c\n    rw [← Nat.cast_sub (appr_mono _ h), hc, nat.cast_mul, Nat.cast_pow]\n  · infer_instance\n#align zmod_cast_comp_to_zmod_pow zmod_cast_comp_to_zmod_pow\n\n",
 "to_zmod_spec":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ_[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ_[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ_[ ]» -/\n/-- `z - (to_zmod z : ℤ_[p])` is contained in the maximal ideal of `ℤ_[p]`, for every `z : ℤ_[p]`.\n\nThe coercion from `zmod p` to `ℤ_[p]` is `zmod.has_coe_t`,\nwhich coerces `zmod p` into artibrary rings.\nThis is unfortunate, but a consequence of the fact that we allow `zmod p`\nto coerce to rings of arbitrary characteristic, instead of only rings of characteristic `p`.\nThis coercion is only a ring homomorphism if it coerces into a ring whose characteristic divides\n`p`. While this is not the case here we can still make use of the coercion.\n-/\ntheorem to_zmod_spec (z : «exprℤ_[ ]» p) : z - (to_zmod z : «exprℤ_[ ]» p) ∈ maximal_ideal («exprℤ_[ ]» p) :=\n  by\n  convert sub_zmod_repr_mem z using 2\n  dsimp [to_zmod, to_zmod_hom]\n  rcases exists_eq_add_of_lt hp_prime.1.pos with ⟨p', rfl⟩\n  change ↑(zmod.val _) = _\n  simp only [zmod.val_nat_cast, add_zero, add_def, Nat.cast_inj, zero_add]\n  apply mod_eq_of_lt\n  simpa only [zero_add] using zmod_repr_lt_p z\n#align to_zmod_spec to_zmod_spec\n\n",
 "to_zmod_pow_eq_iff_ext":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ_[ ]» -/\ntheorem to_zmod_pow_eq_iff_ext {R : Type _} [NonAssocSemiring R] {g g' : «expr →+* » R («exprℤ_[ ]» p)} :\n    (∀ n, (to_zmod_pow n).comp g = (to_zmod_pow n).comp g') ↔ g = g' :=\n  by\n  constructor\n  · intro hg\n    ext x : 1\n    apply ext_of_to_zmod_pow.mp\n    intro n\n    show (to_zmod_pow n).comp g x = (to_zmod_pow n).comp g' x\n    rw [hg n]\n  · rintro rfl _\n    rfl\n#align to_zmod_pow_eq_iff_ext to_zmod_pow_eq_iff_ext\n\n",
 "sub_zmod_repr_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ_[ ]» -/\ntheorem sub_zmod_repr_mem : x - zmod_repr x ∈ maximal_ideal («exprℤ_[ ]» p) :=\n  (zmod_repr_spec _).2\n#align sub_zmod_repr_mem sub_zmod_repr_mem\n\n",
 "pow_dvd_nth_hom_sub":
 "theorem pow_dvd_nth_hom_sub (r : R) (i j : ℕ) (h : i ≤ j) : ↑p ^ i ∣ nth_hom f r j - nth_hom f r i :=\n  by\n  specialize f_compat i j h\n  rw [← Int.coe_nat_pow, ← zmod.int_coe_zmod_eq_zero_iff_dvd, Int.cast_sub]\n  dsimp [nth_hom]\n  rw [← f_compat, RingHom.comp_apply]\n  simp only [zmod.cast_id, zmod.cast_hom_apply, sub_self, zmod.nat_cast_val, zmod.int_cast_cast]\n#align pow_dvd_nth_hom_sub pow_dvd_nth_hom_sub\n\n",
 "nth_hom_zero":
 "@[simp]\ntheorem nth_hom_zero : nth_hom f 0 = 0 := by simp [nth_hom] <;> rfl\n#align nth_hom_zero nth_hom_zero\n\n",
 "nth_hom_seq_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n-- this lemma ran into issues after changing to `ne_zero` and I'm not sure why.\ntheorem nth_hom_seq_one : nth_hom_seq f_compat 1 ≈ 1 :=\n  by\n  intro ε hε\n  change _ < _ at hε\n  use 1\n  intro j hj\n  haveI : fact (1 < p ^ j) := ⟨Nat.one_lt_pow _ _ (by linarith) hp_prime.1.one_lt⟩\n  suffices ((1 : zmod (p ^ j)) : exprℚ) = 1 by simp [nth_hom_seq, nth_hom, this, hε]\n  rw [zmod.cast_eq_val, zmod.val_one, Nat.cast_one]\n#align nth_hom_seq_one nth_hom_seq_one\n\n",
 "nth_hom_seq_mul":
 "theorem nth_hom_seq_mul (r s : R) : nth_hom_seq f_compat (r * s) ≈ nth_hom_seq f_compat r * nth_hom_seq f_compat s :=\n  by\n  intro ε hε\n  obtain ⟨n, hn⟩ := exists_pow_neg_lt_rat p hε\n  use n\n  intro j hj\n  dsimp [nth_hom_seq]\n  apply lt_of_le_of_lt _ hn\n  rw [← Int.cast_mul, ← Int.cast_sub, ← padic_norm.dvd_iff_norm_le, ← zmod.int_coe_zmod_eq_zero_iff_dvd]\n  dsimp [nth_hom]\n  simp only [zmod.nat_cast_val, RingHom.map_mul, Int.cast_sub, zmod.int_cast_cast, Int.cast_mul]\n  rw [zmod.cast_mul (show p ^ n ∣ p ^ j from pow_dvd_pow _ hj), sub_self]\n  · infer_instance\n#align nth_hom_seq_mul nth_hom_seq_mul\n\n",
 "nth_hom_seq_add":
 "theorem nth_hom_seq_add (r s : R) : nth_hom_seq f_compat (r + s) ≈ nth_hom_seq f_compat r + nth_hom_seq f_compat s :=\n  by\n  intro ε hε\n  obtain ⟨n, hn⟩ := exists_pow_neg_lt_rat p hε\n  use n\n  intro j hj\n  dsimp [nth_hom_seq]\n  apply lt_of_le_of_lt _ hn\n  rw [← Int.cast_add, ← Int.cast_sub, ← padic_norm.dvd_iff_norm_le, ← zmod.int_coe_zmod_eq_zero_iff_dvd]\n  dsimp [nth_hom]\n  simp only [zmod.nat_cast_val, RingHom.map_add, Int.cast_sub, zmod.int_cast_cast, Int.cast_add]\n  rw [zmod.cast_add (show p ^ n ∣ p ^ j from pow_dvd_pow _ hj), sub_self]\n  · infer_instance\n#align nth_hom_seq_add nth_hom_seq_add\n\n",
 "norm_sub_mod_part_aux":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℚ_[ ]» -/\ntheorem norm_sub_mod_part_aux (r : exprℚ) (h : «expr‖ ‖» (r : «exprℚ_[ ]» p) ≤ 1) :\n    ↑p ∣ r.num - r.num * r.denom.gcd_a p % p * ↑r.denom :=\n  by\n  rw [← zmod.int_coe_zmod_eq_zero_iff_dvd]\n  simp only [Int.cast_ofNat, zmod.nat_cast_mod, Int.cast_mul, Int.cast_sub]\n  have := congr_arg (coe : ℤ → zmod p) (gcd_eq_gcd_ab r.denom p)\n  simp only [Int.cast_ofNat, add_zero, Int.cast_add, zmod.nat_cast_self, Int.cast_mul, zero_mul] at this\n  push_cast\n  rw [mul_right_comm, mul_assoc, ← this]\n  suffices rdcp : r.denom.coprime p\n  · rw [rdcp.gcd_eq_one]\n    simp only [mul_one, cast_one, sub_self]\n  apply coprime.symm\n  apply (coprime_or_dvd_of_prime hp_prime.1 _).resolve_right\n  rw [← Int.coe_nat_dvd, ← norm_int_lt_one_iff_dvd, not_lt]\n  apply ge_of_eq\n  rw [← is_unit_iff]\n  exact is_unit_denom r h\n#align norm_sub_mod_part_aux norm_sub_mod_part_aux\n\n",
 "norm_sub_mod_part":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ_[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℚ_[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ_[ ]» -/\ntheorem norm_sub_mod_part (h : «expr‖ ‖» (r : «exprℚ_[ ]» p) ≤ 1) :\n    «expr‖ ‖» (⟨r, h⟩ - mod_part p r : «exprℤ_[ ]» p) < 1 :=\n  by\n  let n := mod_part p r\n  rw [norm_lt_one_iff_dvd, ← (is_unit_denom r h).dvd_mul_right]\n  suffices ↑p ∣ r.num - n * r.denom\n    by\n    convert (Int.castRingHom («exprℤ_[ ]» p)).map_dvd this\n    simp only [sub_mul, Int.cast_ofNat, eq_intCast, Int.cast_mul, sub_left_inj, Int.cast_sub]\n    apply subtype.coe_injective\n    simp only [coe_mul, subtype.coe_mk, coe_nat_cast]\n    rw_mod_cast [@Rat.mul_den_eq_num r]\n    rfl\n  exact norm_sub_mod_part_aux r h\n#align norm_sub_mod_part norm_sub_mod_part\n\n",
 "mod_part_nonneg":
 "theorem mod_part_nonneg : 0 ≤ mod_part p r :=\n  Int.emod_nonneg _ <| by exact_mod_cast hp_prime.1.ne_zero\n#align mod_part_nonneg mod_part_nonneg\n\n",
 "mod_part_lt_p":
 "/-\nCopyright (c) 2020 Johan Commelin, Robert Y. Lewis. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johan Commelin, Robert Y. Lewis\n-/\ntheorem mod_part_lt_p : mod_part p r < p := by\n  convert Int.emod_lt _ _\n  · simp\n  · exact_mod_cast hp_prime.1.ne_zero\n#align mod_part_lt_p mod_part_lt_p\n\n",
 "lim_nth_hom_zero":
 "theorem lim_nth_hom_zero : lim_nth_hom f_compat 0 = 0 := by simp [lim_nth_hom] <;> rfl\n#align lim_nth_hom_zero lim_nth_hom_zero\n\n",
 "lim_nth_hom_spec":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem lim_nth_hom_spec (r : R) :\n    ∀ ε : exprℝ, 0 < ε → ∃ N : ℕ, ∀ n ≥ N, «expr‖ ‖» (lim_nth_hom f_compat r - nth_hom f r n) < ε :=\n  by\n  intro ε hε\n  obtain ⟨ε', hε'0, hε'⟩ : ∃ v : exprℚ, (0 : exprℝ) < v ∧ ↑v < ε := exists_rat_btwn hε\n  norm_cast  at hε'0\n  obtain ⟨N, hN⟩ := padic_norm_e.defn (nth_hom_seq f_compat r) hε'0\n  use N\n  intro n hn\n  apply lt_trans _ hε'\n  change ↑(padic_norm_e _) < _\n  norm_cast\n  exact hN _ hn\n#align lim_nth_hom_spec lim_nth_hom_spec\n\n",
 "lim_nth_hom_one":
 "theorem lim_nth_hom_one : lim_nth_hom f_compat 1 = 1 :=\n  subtype.ext <| quot.sound <| nth_hom_seq_one _\n#align lim_nth_hom_one lim_nth_hom_one\n\n",
 "lim_nth_hom_mul":
 "theorem lim_nth_hom_mul (r s : R) : lim_nth_hom f_compat (r * s) = lim_nth_hom f_compat r * lim_nth_hom f_compat s :=\n  subtype.ext <| quot.sound <| nth_hom_seq_mul _ _ _\n#align lim_nth_hom_mul lim_nth_hom_mul\n\n",
 "lim_nth_hom_add":
 "theorem lim_nth_hom_add (r s : R) : lim_nth_hom f_compat (r + s) = lim_nth_hom f_compat r + lim_nth_hom f_compat s :=\n  subtype.ext <| quot.sound <| nth_hom_seq_add _ _ _\n#align lim_nth_hom_add lim_nth_hom_add\n\n",
 "lift_unique":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ_[ ]» -/\n/-- One part of the universal property of `ℤ_[p]` as a projective limit.\nSee also `padic_int.lift_spec`.\n-/\ntheorem lift_unique (g : «expr →+* » R («exprℤ_[ ]» p)) (hg : ∀ n, (to_zmod_pow n).comp g = f n) : lift f_compat = g :=\n  by\n  ext1 r\n  apply eq_of_forall_dist_le\n  intro ε hε\n  obtain ⟨n, hn⟩ := exists_pow_neg_lt p hε\n  apply le_trans _ (le_of_lt hn)\n  rw [dist_eq_norm, norm_le_pow_iff_mem_span_pow, ← ker_to_zmod_pow, ring_hom.mem_ker, RingHom.map_sub, ←\n    RingHom.comp_apply, ← RingHom.comp_apply, lift_spec, hg, sub_self]\n#align lift_unique lift_unique\n\n",
 "lift_sub_val_mem_span":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ_[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ_[ ]» -/\n-- TODO: generalize this to arbitrary complete discrete valuation rings\ntheorem lift_sub_val_mem_span (r : R) (n : ℕ) :\n    lift f_compat r - (f n r).val ∈ (ideal.span {↑p ^ n} : ideal («exprℤ_[ ]» p)) :=\n  by\n  obtain ⟨k, hk⟩ :=\n    lim_nth_hom_spec f_compat r _ (show (0 : exprℝ) < p ^ (-n : ℤ) from Nat.zpow_pos_of_pos hp_prime.1.pos _)\n  have := le_of_lt (hk (max n k) (le_max_right _ _))\n  rw [norm_le_pow_iff_mem_span_pow] at this\n  dsimp [lift]\n  rw [sub_eq_sub_add_sub (lim_nth_hom f_compat r) _ ↑(nth_hom f r (max n k))]\n  apply ideal.add_mem _ _ this\n  rw [ideal.mem_span_singleton]\n  simpa only [eq_intCast, RingHom.map_pow, Int.cast_sub] using\n    (Int.castRingHom («exprℤ_[ ]» p)).map_dvd (pow_dvd_nth_hom_sub f_compat r n (max n k) (le_max_left _ _))\n#align lift_sub_val_mem_span lift_sub_val_mem_span\n\n",
 "lift_spec":
 "/-- One part of the universal property of `ℤ_[p]` as a projective limit.\nSee also `padic_int.lift_unique`.\n-/\ntheorem lift_spec (n : ℕ) : (to_zmod_pow n).comp (lift f_compat) = f n :=\n  by\n  ext r\n  rw [RingHom.comp_apply, ← zmod.nat_cast_zmod_val (f n r), ← map_nat_cast <| to_zmod_pow n, ← sub_eq_zero, ←\n    RingHom.map_sub, ← ring_hom.mem_ker, ker_to_zmod_pow]\n  apply lift_sub_val_mem_span\n#align lift_spec lift_spec\n\n",
 "lift_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ_[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ_[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ_[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ_[ ]» -/\n@[simp]\ntheorem lift_self (z : «exprℤ_[ ]» p) : @lift p _ («exprℤ_[ ]» p) _ to_zmod_pow zmod_cast_comp_to_zmod_pow z = z :=\n  by\n  show _ = RingHom.id _ z\n  rw [@lift_unique p _ («exprℤ_[ ]» p) _ _ zmod_cast_comp_to_zmod_pow (RingHom.id («exprℤ_[ ]» p))]\n  intro ; rw [RingHom.comp_id]\n#align lift_self lift_self\n\n",
 "ker_to_zmod_pow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ_[ ]» -/\ntheorem ker_to_zmod_pow (n : ℕ) :\n    (to_zmod_pow n : «expr →+* » («exprℤ_[ ]» p) (zmod (p ^ n))).ker = ideal.span {p ^ n} :=\n  by\n  ext x\n  rw [ring_hom.mem_ker]\n  constructor\n  · intro h\n    suffices x.appr n = 0 by\n      convert appr_spec n x\n      simp only [this, sub_zero, cast_zero]\n    dsimp [to_zmod_pow, to_zmod_hom] at h\n    rw [zmod.nat_coe_zmod_eq_zero_iff_dvd] at h\n    apply eq_zero_of_dvd_of_lt h (appr_lt _ _)\n  · intro h\n    rw [← sub_zero x] at h\n    dsimp [to_zmod_pow, to_zmod_hom]\n    rw [zmod_congr_of_sub_mem_span n x _ 0 _ h, cast_zero]\n    apply appr_spec\n#align ker_to_zmod_pow ker_to_zmod_pow\n\n",
 "ker_to_zmod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ_[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ_[ ]» -/\ntheorem ker_to_zmod : (to_zmod : «expr →+* » («exprℤ_[ ]» p) (zmod p)).ker = maximal_ideal («exprℤ_[ ]» p) :=\n  by\n  ext x\n  rw [ring_hom.mem_ker]\n  constructor\n  · intro h\n    simpa only [h, zmod.cast_zero, sub_zero] using to_zmod_spec x\n  · intro h\n    rw [← sub_zero x] at h\n    dsimp [to_zmod, to_zmod_hom]\n    convert zmod_congr_of_sub_mem_max_ideal x _ 0 _ h\n    norm_cast\n    apply sub_zmod_repr_mem\n#align ker_to_zmod ker_to_zmod\n\n",
 "is_unit_denom":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ_[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℚ_[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℚ_[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℚ_[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℚ_[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ_[ ]» -/\ntheorem is_unit_denom (r : exprℚ) (h : «expr‖ ‖» (r : «exprℚ_[ ]» p) ≤ 1) : is_unit (r.denom : «exprℤ_[ ]» p) :=\n  by\n  rw [is_unit_iff]\n  apply le_antisymm (r.denom : «exprℤ_[ ]» p).2\n  rw [← not_lt, val_eq_coe, coe_nat_cast]\n  intro norm_denom_lt\n  have hr : «expr‖ ‖» (r * r.denom : «exprℚ_[ ]» p) = «expr‖ ‖» (r.num : «exprℚ_[ ]» p) :=\n    by\n    rw_mod_cast [@Rat.mul_den_eq_num r]\n    rfl\n  rw [padic_norm_e.mul] at hr\n  have key : «expr‖ ‖» (r.num : «exprℚ_[ ]» p) < 1 := by\n    calc\n      _ = _ := hr.symm\n      _ < 1 * 1 := mul_lt_mul' h norm_denom_lt (norm_nonneg _) zero_lt_one\n      _ = 1 := mul_one 1\n      \n  have : ↑p ∣ r.num ∧ (p : ℤ) ∣ r.denom :=\n    by\n    simp only [← norm_int_lt_one_iff_dvd, ← padic_norm_e_of_padic_int]\n    norm_cast\n    exact ⟨key, norm_denom_lt⟩\n  apply hp_prime.1.not_dvd_one\n  rwa [← r.cop.gcd_eq_one, nat.dvd_gcd_iff, ← Int.coe_nat_dvd_left, ← Int.coe_nat_dvd]\n#align is_unit_denom is_unit_denom\n\n",
 "is_cau_seq_nth_hom":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\ntheorem is_cau_seq_nth_hom (r : R) : IsCauSeq (padic_norm p) fun n => nth_hom f r n :=\n  by\n  intro ε hε\n  obtain ⟨k, hk⟩ : ∃ k : ℕ, (p ^ (-(↑(k : ℕ) : ℤ)) : exprℚ) < ε := exists_pow_neg_lt_rat p hε\n  use k\n  intro j hj\n  refine' lt_of_le_of_lt _ hk\n  norm_cast\n  rw [← padic_norm.dvd_iff_norm_le]\n  exact_mod_cast pow_dvd_nth_hom_sub f_compat r k j hj\n#align is_cau_seq_nth_hom is_cau_seq_nth_hom\n\n",
 "ext_of_to_zmod_pow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ_[ ]» -/\ntheorem ext_of_to_zmod_pow {x y : «exprℤ_[ ]» p} : (∀ n, to_zmod_pow n x = to_zmod_pow n y) ↔ x = y :=\n  by\n  constructor\n  · intro h\n    rw [← lift_self x, ← lift_self y]\n    simp [lift, lim_nth_hom, nth_hom, h]\n  · rintro rfl _\n    rfl\n#align ext_of_to_zmod_pow ext_of_to_zmod_pow\n\n",
 "exists_mem_range_of_norm_rat_le_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℚ_[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ_[ ]» -/\ntheorem exists_mem_range_of_norm_rat_le_one (h : «expr‖ ‖» (r : «exprℚ_[ ]» p) ≤ 1) :\n    ∃ n : ℤ, 0 ≤ n ∧ n < p ∧ «expr‖ ‖» (⟨r, h⟩ - n : «exprℤ_[ ]» p) < 1 :=\n  ⟨mod_part p r, mod_part_nonneg _, mod_part_lt_p _, norm_sub_mod_part _ h⟩\n#align exists_mem_range_of_norm_rat_le_one exists_mem_range_of_norm_rat_le_one\n\n",
 "exists_mem_range":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℚ_[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℚ_[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℚ_[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℚ_[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ_[ ]» -/\ntheorem exists_mem_range : ∃ n : ℕ, n < p ∧ x - n ∈ maximal_ideal («exprℤ_[ ]» p) :=\n  by\n  simp only [maximal_ideal_eq_span_p, ideal.mem_span_singleton, ← norm_lt_one_iff_dvd]\n  obtain ⟨r, hr⟩ := rat_dense p (x : «exprℚ_[ ]» p) zero_lt_one\n  have H : «expr‖ ‖» (r : «exprℚ_[ ]» p) ≤ 1 := by\n    rw [norm_sub_rev] at hr\n    calc\n      _ = «expr‖ ‖» ((r : «exprℚ_[ ]» p) - x + x) := by ring_nf\n      _ ≤ _ := padic_norm_e.nonarchimedean _ _\n      _ ≤ _ := max_le (le_of_lt hr) x.2\n      \n  obtain ⟨n, hzn, hnp, hn⟩ := exists_mem_range_of_norm_rat_le_one r H\n  lift n to ℕ using hzn\n  use n\n  constructor\n  · exact_mod_cast hnp\n  simp only [norm_def, coe_sub, subtype.coe_mk, coe_nat_cast] at hn⊢\n  rw [show (x - n : «exprℚ_[ ]» p) = x - r + (r - n) by ring]\n  apply lt_of_le_of_lt (padic_norm_e.nonarchimedean _ _)\n  apply max_lt hr\n  simpa using hn\n#align exists_mem_range exists_mem_range\n\n",
 "dvd_appr_sub_appr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ_[ ]» -/\ntheorem dvd_appr_sub_appr (x : «exprℤ_[ ]» p) (m n : ℕ) (h : m ≤ n) : p ^ m ∣ x.appr n - x.appr m :=\n  by\n  obtain ⟨k, rfl⟩ := Nat.exists_eq_add_of_le h; clear h\n  induction' k with k ih\n  · simp only [add_zero, tsub_self, dvd_zero]\n  rw [nat.succ_eq_add_one, ← add_assoc]\n  dsimp [appr]\n  split_ifs with h\n  · exact ih\n  rw [add_comm, add_tsub_assoc_of_le (appr_mono _ (nat.le_add_right m k))]\n  apply dvd_add _ ih\n  apply dvd_mul_of_dvd_left\n  apply pow_dvd_pow _ (nat.le_add_right m k)\n#align dvd_appr_sub_appr dvd_appr_sub_appr\n\n",
 "dense_range_nat_cast":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ_[ ]» -/\ntheorem dense_range_nat_cast : dense_range (Nat.cast : ℕ → «exprℤ_[ ]» p) :=\n  by\n  intro x\n  rw [metric.mem_closure_range_iff]\n  intro ε hε\n  obtain ⟨n, hn⟩ := exists_pow_neg_lt p hε\n  use x.appr n\n  rw [dist_eq_norm]\n  apply lt_of_le_of_lt _ hn\n  rw [norm_le_pow_iff_mem_span_pow]\n  apply appr_spec\n#align dense_range_nat_cast dense_range_nat_cast\n\n",
 "dense_range_int_cast":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ_[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ_[ ]» -/\ntheorem dense_range_int_cast : dense_range (Int.cast : ℤ → «exprℤ_[ ]» p) :=\n  by\n  intro x\n  apply dense_range_nat_cast.induction_on x\n  · exact is_closed_closure\n  · intro a\n    change (a.cast : «exprℤ_[ ]» p) with (a : ℤ).cast\n    apply subset_closure\n    exact Set.mem_range_self _\n#align dense_range_int_cast dense_range_int_cast\n\n",
 "cast_to_zmod_pow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ_[ ]» -/\n@[simp]\ntheorem cast_to_zmod_pow (m n : ℕ) (h : m ≤ n) (x : «exprℤ_[ ]» p) : ↑(to_zmod_pow n x) = to_zmod_pow m x :=\n  by\n  rw [← zmod_cast_comp_to_zmod_pow _ _ h]\n  rfl\n#align cast_to_zmod_pow cast_to_zmod_pow\n\n",
 "appr_spec":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ_[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ_[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ_[ ]» -/\ntheorem appr_spec (n : ℕ) : ∀ x : «exprℤ_[ ]» p, x - appr x n ∈ (ideal.span {p ^ n} : ideal («exprℤ_[ ]» p)) :=\n  by\n  simp only [ideal.mem_span_singleton]\n  induction' n with n ih\n  · simp only [isUnit_one, is_unit.dvd, pow_zero, forall_true_iff]\n  intro x\n  dsimp only [appr]\n  split_ifs with h\n  · rw [h]\n    apply dvd_zero\n  push_cast\n  rw [sub_add_eq_sub_sub]\n  obtain ⟨c, hc⟩ := ih x\n  simp only [map_nat_cast, zmod.nat_cast_self, RingHom.map_pow, RingHom.map_mul, zmod.nat_cast_val]\n  have hc' : c ≠ 0 := by\n    rintro rfl\n    simp only [mul_zero] at hc\n    contradiction\n  conv_rhs =>\n    congr\n    simp only [hc]\n  rw [show (x - ↑(appr x n)).valuation = (↑p ^ n * c).valuation by rw [hc]]\n  rw [valuation_p_pow_mul _ _ hc', add_sub_cancel', pow_succ', ← mul_sub]\n  apply mul_dvd_mul_left\n  obtain hc0 | hc0 := c.valuation.nat_abs.eq_zero_or_pos\n  · simp only [hc0, mul_one, pow_zero]\n    rw [mul_comm, unit_coeff_spec h] at hc\n    suffices c = unit_coeff h\n      by\n      rw [← this, ← ideal.mem_span_singleton, ← maximal_ideal_eq_span_p]\n      apply to_zmod_spec\n    obtain ⟨c, rfl⟩ : is_unit c :=\n      by\n      -- TODO: write a can_lift instance for units\n      rw [Int.natAbs_eq_zero] at hc0\n      rw [is_unit_iff, norm_eq_pow_val hc', hc0, neg_zero, zpow_zero]\n    rw [discrete_valuation_ring.unit_mul_pow_congr_unit _ _ _ _ _ hc]\n    exact irreducible_p\n  · rw [zero_pow hc0]\n    simp only [sub_zero, zmod.cast_zero, mul_zero]\n    rw [unit_coeff_spec hc']\n    exact (dvd_pow_self (p : «exprℤ_[ ]» p) hc0.ne').mul_left _\n#align appr_spec appr_spec\n\n",
 "appr_mono":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ_[ ]» -/\ntheorem appr_mono (x : «exprℤ_[ ]» p) : monotone x.appr :=\n  by\n  apply monotone_nat_of_le_succ\n  intro n\n  dsimp [appr]\n  split_ifs; · rfl\n  apply nat.le_add_right\n#align appr_mono appr_mono\n\n",
 "appr_lt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ_[ ]» -/\ntheorem appr_lt (x : «exprℤ_[ ]» p) (n : ℕ) : x.appr n < p ^ n :=\n  by\n  induction' n with n ih generalizing x\n  · simp only [appr, succ_pos', pow_zero]\n  simp only [appr, map_nat_cast, zmod.nat_cast_self, RingHom.map_pow, Int.natAbs, RingHom.map_mul]\n  have hp : p ^ n < p ^ (n + 1) := by apply pow_lt_pow hp_prime.1.one_lt (lt_add_one n)\n  split_ifs with h\n  · apply lt_trans (ih _) hp\n  · calc\n      _ < p ^ n + p ^ n * (p - 1) := _\n      _ = p ^ (n + 1) := _\n      \n    · apply add_lt_add_of_lt_of_le (ih _)\n      apply nat.mul_le_mul_left\n      apply le_pred_of_lt\n      apply zmod.val_lt\n    · rw [mul_tsub, mul_one, ← pow_succ']\n      apply add_tsub_cancel_of_le (le_of_lt hp)\n#align appr_lt appr_lt\n\n"}