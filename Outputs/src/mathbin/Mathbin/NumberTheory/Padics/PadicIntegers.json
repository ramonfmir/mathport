{"valuation_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ_[ ]» -/\n@[simp]\ntheorem valuation_zero : valuation (0 : «exprℤ_[ ]» p) = 0 :=\n  padic.valuation_zero\n#align valuation_zero valuation_zero\n\n",
 "valuation_p_pow_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ_[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ_[ ]» -/\n@[simp]\ntheorem valuation_p_pow_mul (n : ℕ) (c : «exprℤ_[ ]» p) (hc : c ≠ 0) : (↑p ^ n * c).valuation = n + c.valuation :=\n  by\n  have : «expr‖ ‖» (↑p ^ n * c) = «expr‖ ‖» (p ^ n : «exprℤ_[ ]» p) * «expr‖ ‖» c := norm_mul _ _\n  have aux : ↑p ^ n * c ≠ 0 := by\n    contrapose! hc\n    rw [mul_eq_zero] at hc\n    cases hc\n    · refine' (hp.1.ne_zero _).elim\n      exact_mod_cast pow_eq_zero hc\n    · exact hc\n  rwa [norm_eq_pow_val aux, norm_p_pow, norm_eq_pow_val hc, ← zpow_add₀, ← neg_add, zpow_inj, neg_inj] at this\n  · exact_mod_cast hp.1.pos\n  · exact_mod_cast hp.1.ne_one\n  · exact_mod_cast hp.1.ne_zero\n#align valuation_p_pow_mul valuation_p_pow_mul\n\n",
 "valuation_p":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ_[ ]» -/\n@[simp]\ntheorem valuation_p : valuation (p : «exprℤ_[ ]» p) = 1 := by simp [Valuation]\n#align valuation_p valuation_p\n\n",
 "valuation_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ_[ ]» -/\n@[simp]\ntheorem valuation_one : valuation (1 : «exprℤ_[ ]» p) = 0 :=\n  padic.valuation_one\n#align valuation_one valuation_one\n\n",
 "valuation_nonneg":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ_[ ]» -/\ntheorem valuation_nonneg (x : «exprℤ_[ ]» p) : 0 ≤ x.valuation :=\n  by\n  by_cases hx : x = 0\n  · simp [hx]\n  have h : (1 : exprℝ) < p := by exact_mod_cast hp.1.one_lt\n  rw [← neg_nonpos, ← (zpow_strictMono h).le_iff_le]\n  show (p : exprℝ) ^ (-Valuation x) ≤ p ^ (0 : ℤ)\n  rw [← norm_eq_pow_val hx]\n  simpa using x.property\n#align valuation_nonneg valuation_nonneg\n\n",
 "val_eq_coe":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ_[ ]» -/\n@[simp]\ntheorem val_eq_coe (z : «exprℤ_[ ]» p) : z.val = z :=\n  rfl\n#align val_eq_coe val_eq_coe\n\n",
 "unit_coeff_spec":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℚ_[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ_[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ_[ ]» -/\ntheorem unit_coeff_spec {x : «exprℤ_[ ]» p} (hx : x ≠ 0) :\n    x = (unit_coeff hx : «exprℤ_[ ]» p) * p ^ Int.natAbs (valuation x) :=\n  by\n  apply Subtype.coe_injective\n  push_cast\n  have repr : (x : «exprℚ_[ ]» p) = unit_coeff hx * p ^ x.valuation :=\n    by\n    rw [unit_coeff_coe, mul_assoc, ← zpow_add₀]\n    · simp\n    · exact_mod_cast hp.1.ne_zero\n  convert repr using 2\n  rw [← zpow_ofNat, Int.natAbs_of_nonneg (valuation_nonneg x)]\n#align unit_coeff_spec unit_coeff_spec\n\n",
 "unit_coeff_coe":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ_[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℚ_[ ]» -/\n@[simp]\ntheorem unit_coeff_coe {x : «exprℤ_[ ]» p} (hx : x ≠ 0) : (unit_coeff hx : «exprℚ_[ ]» p) = x * p ^ (-x.valuation) :=\n  rfl\n#align unit_coeff_coe unit_coeff_coe\n\n",
 "prime_p":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ_[ ]» -/\ntheorem prime_p : Prime (p : «exprℤ_[ ]» p) :=\n  by\n  rw [← Ideal.span_singleton_prime, ← maximal_ideal_eq_span_p]\n  · infer_instance\n  · exact_mod_cast hp.1.ne_zero\n#align prime_p prime_p\n\n",
 "pow_p_dvd_int_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ_[ ]» -/\n@[simp]\ntheorem pow_p_dvd_int_iff (n : ℕ) (a : ℤ) : (p ^ n : «exprℤ_[ ]» p) ∣ a ↔ ↑p ^ n ∣ a := by\n  rw [← norm_int_le_pow_iff_dvd, norm_le_pow_iff_mem_span_pow, Ideal.mem_span_singleton]\n#align pow_p_dvd_int_iff pow_p_dvd_int_iff\n\n",
 "padic_norm_e_of_padic_int":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ_[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℚ_[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n@[simp]\ntheorem padic_norm_e_of_padic_int (z : «exprℤ_[ ]» p) : «expr‖ ‖» (z : «exprℚ_[ ]» p) = «expr‖ ‖» z := by\n  simp [norm_def]\n#align padic_norm_e_of_padic_int padic_norm_e_of_padic_int\n\n",
 "p_nonnunit":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ_[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ_[ ]» -/\ntheorem p_nonnunit : (p : «exprℤ_[ ]» p) ∈ nonunits («exprℤ_[ ]» p) :=\n  by\n  have : (p : exprℝ)⁻¹ < 1 := inv_lt_one <| by exact_mod_cast hp.1.one_lt\n  simp [this]\n#align p_nonnunit p_nonnunit\n\n",
 "norm_units":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ_[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ_[ ]» -/\n@[simp]\ntheorem norm_units (u : «expr ˣ» («exprℤ_[ ]» p)) : «expr‖ ‖» (u : «exprℤ_[ ]» p) = 1 :=\n  is_unit_iff.mp <| by simp\n#align norm_units norm_units\n\n",
 "norm_pow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ_[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n#print norm_pow /-\n@[simp]\ntheorem norm_pow (z : «exprℤ_[ ]» p) : ∀ n : ℕ, «expr‖ ‖» (z ^ n) = «expr‖ ‖» z ^ n\n  | 0 => by simp\n  | k + 1 => by\n    rw [pow_succ, pow_succ, norm_mul]\n    congr\n    apply norm_pow\n#align norm_pow norm_pow\n-/\n\n",
 "norm_p_pow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ_[ ]» -/\n@[simp]\ntheorem norm_p_pow (n : ℕ) : «expr‖ ‖» ((p : «exprℤ_[ ]» p) ^ n) = p ^ (-n : ℤ) :=\n  padic_norm_e.norm_p_pow n\n#align norm_p_pow norm_p_pow\n\n",
 "norm_p":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ_[ ]» -/\n@[simp]\ntheorem norm_p : «expr‖ ‖» (p : «exprℤ_[ ]» p) = p⁻¹ :=\n  padic_norm_e.norm_p\n#align norm_p norm_p\n\n",
 "norm_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ_[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n#print norm_mul /-\n@[simp]\ntheorem norm_mul (z1 z2 : «exprℤ_[ ]» p) : «expr‖ ‖» (z1 * z2) = «expr‖ ‖» z1 * «expr‖ ‖» z2 := by simp [norm_def]\n#align norm_mul norm_mul\n-/\n\n",
 "norm_lt_pow_iff_norm_le_pow_sub_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ_[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem norm_lt_pow_iff_norm_le_pow_sub_one (x : «exprℤ_[ ]» p) (n : ℤ) :\n    «expr‖ ‖» x < p ^ n ↔ «expr‖ ‖» x ≤ p ^ (n - 1) := by rw [norm_le_pow_iff_norm_lt_pow_add_one, sub_add_cancel]\n#align norm_lt_pow_iff_norm_le_pow_sub_one norm_lt_pow_iff_norm_le_pow_sub_one\n\n",
 "norm_lt_one_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ_[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem norm_lt_one_mul {z1 z2 : «exprℤ_[ ]» p} (hz2 : «expr‖ ‖» z2 < 1) : «expr‖ ‖» (z1 * z2) < 1 :=\n  calc\n    «expr‖ ‖» (z1 * z2) = «expr‖ ‖» z1 * «expr‖ ‖» z2 := by simp\n    _ < 1 := mul_lt_one_of_nonneg_of_lt_one_right (norm_le_one _) (norm_nonneg _) hz2\n    \n#align norm_lt_one_mul norm_lt_one_mul\n\n",
 "norm_lt_one_iff_dvd":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ_[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem norm_lt_one_iff_dvd (x : «exprℤ_[ ]» p) : «expr‖ ‖» x < 1 ↔ ↑p ∣ x :=\n  by\n  have := norm_le_pow_iff_mem_span_pow x 1\n  rw [Ideal.mem_span_singleton, pow_one] at this\n  rw [← this, norm_le_pow_iff_norm_lt_pow_add_one]\n  simp only [zpow_zero, Int.ofNat_zero, Int.ofNat_succ, add_left_neg, zero_add]\n#align norm_lt_one_iff_dvd norm_lt_one_iff_dvd\n\n",
 "norm_lt_one_add":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ_[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem norm_lt_one_add {z1 z2 : «exprℤ_[ ]» p} (hz1 : «expr‖ ‖» z1 < 1) (hz2 : «expr‖ ‖» z2 < 1) :\n    «expr‖ ‖» (z1 + z2) < 1 :=\n  lt_of_le_of_lt (nonarchimedean _ _) (max_lt hz1 hz2)\n#align norm_lt_one_add norm_lt_one_add\n\n",
 "norm_le_pow_iff_norm_lt_pow_add_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ_[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem norm_le_pow_iff_norm_lt_pow_add_one (x : «exprℤ_[ ]» p) (n : ℤ) :\n    «expr‖ ‖» x ≤ p ^ n ↔ «expr‖ ‖» x < p ^ (n + 1) := by rw [norm_def];\n  exact padic.norm_le_pow_iff_norm_lt_pow_add_one _ _\n#align norm_le_pow_iff_norm_lt_pow_add_one norm_le_pow_iff_norm_lt_pow_add_one\n\n",
 "norm_le_pow_iff_mem_span_pow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ_[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ_[ ]» -/\ntheorem norm_le_pow_iff_mem_span_pow (x : «exprℤ_[ ]» p) (n : ℕ) :\n    «expr‖ ‖» x ≤ p ^ (-n : ℤ) ↔ x ∈ (Ideal.span {p ^ n} : Ideal («exprℤ_[ ]» p)) :=\n  by\n  by_cases hx : x = 0\n  · subst hx\n    simp only [norm_zero, zpow_neg, zpow_ofNat, inv_nonneg, iff_true_iff, Submodule.zero_mem]\n    exact_mod_cast nat.zero_le _\n  rw [norm_le_pow_iff_le_valuation x hx, mem_span_pow_iff_le_valuation x hx]\n#align norm_le_pow_iff_mem_span_pow norm_le_pow_iff_mem_span_pow\n\n",
 "norm_le_pow_iff_le_valuation":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ_[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem norm_le_pow_iff_le_valuation (x : «exprℤ_[ ]» p) (hx : x ≠ 0) (n : ℕ) :\n    «expr‖ ‖» x ≤ p ^ (-n : ℤ) ↔ ↑n ≤ x.valuation :=\n  by\n  rw [norm_eq_pow_val hx]\n  lift x.valuation to ℕ using x.valuation_nonneg with k hk\n  simp only [Int.ofNat_le, zpow_neg, zpow_ofNat]\n  have aux : ∀ n : ℕ, 0 < (p ^ n : exprℝ) := by\n    apply pow_pos\n    exact_mod_cast hp.1.pos\n  rw [inv_le_inv (aux _) (aux _)]\n  have : p ^ n ≤ p ^ k ↔ n ≤ k := (pow_strictMono_right hp.1.one_lt).le_iff_le\n  rw [← this]\n  norm_cast\n#align norm_le_pow_iff_le_valuation norm_le_pow_iff_le_valuation\n\n",
 "norm_le_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ_[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem norm_le_one (z : «exprℤ_[ ]» p) : «expr‖ ‖» z ≤ 1 :=\n  z.2\n#align norm_le_one norm_le_one\n\n",
 "norm_int_lt_one_iff_dvd":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℚ_[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ_[ ]» -/\ntheorem norm_int_lt_one_iff_dvd (k : ℤ) : «expr‖ ‖» (k : «exprℤ_[ ]» p) < 1 ↔ (p : ℤ) ∣ k :=\n  suffices «expr‖ ‖» (k : «exprℚ_[ ]» p) < 1 ↔ ↑p ∣ k by rwa [norm_int_cast_eq_padic_norm]\n  padic_norm_e.norm_int_lt_one_iff_dvd k\n#align norm_int_lt_one_iff_dvd norm_int_lt_one_iff_dvd\n\n",
 "norm_int_le_pow_iff_dvd":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℚ_[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ_[ ]» -/\ntheorem norm_int_le_pow_iff_dvd {k : ℤ} {n : ℕ} : «expr‖ ‖» (k : «exprℤ_[ ]» p) ≤ p ^ (-n : ℤ) ↔ (p ^ n : ℤ) ∣ k :=\n  suffices «expr‖ ‖» (k : «exprℚ_[ ]» p) ≤ p ^ (-n : ℤ) ↔ ↑(p ^ n) ∣ k by simpa [norm_int_cast_eq_padic_norm]\n  padic_norm_e.norm_int_le_pow_iff_dvd _ _\n#align norm_int_le_pow_iff_dvd norm_int_le_pow_iff_dvd\n\n",
 "norm_int_cast_eq_padic_norm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ_[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℚ_[ ]» -/\ntheorem norm_int_cast_eq_padic_norm (z : ℤ) : «expr‖ ‖» (z : «exprℤ_[ ]» p) = «expr‖ ‖» (z : «exprℚ_[ ]» p) := by\n  simp [norm_def]\n#align norm_int_cast_eq_padic_norm norm_int_cast_eq_padic_norm\n\n",
 "norm_eq_pow_val":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ_[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem norm_eq_pow_val {x : «exprℤ_[ ]» p} (hx : x ≠ 0) : «expr‖ ‖» x = (p : exprℝ) ^ (-x.valuation) :=\n  by\n  convert padic.norm_eq_pow_val _\n  contrapose! hx\n  exact Subtype.val_injective hx\n#align norm_eq_pow_val norm_eq_pow_val\n\n",
 "norm_eq_padic_norm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℚ_[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ_[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n@[simp]\ntheorem norm_eq_padic_norm {q : «exprℚ_[ ]» p} (hq : «expr‖ ‖» q ≤ 1) : @norm («exprℤ_[ ]» p) _ ⟨q, hq⟩ = «expr‖ ‖» q :=\n  rfl\n#align norm_eq_padic_norm norm_eq_padic_norm\n\n",
 "norm_eq_of_norm_add_lt_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ_[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem norm_eq_of_norm_add_lt_right {z1 z2 : «exprℤ_[ ]» p} (h : «expr‖ ‖» (z1 + z2) < «expr‖ ‖» z2) :\n    «expr‖ ‖» z1 = «expr‖ ‖» z2 :=\n  by_contradiction fun hne => not_lt_of_ge (by rw [norm_add_eq_max_of_ne hne] <;> apply le_max_right) h\n#align norm_eq_of_norm_add_lt_right norm_eq_of_norm_add_lt_right\n\n",
 "norm_eq_of_norm_add_lt_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ_[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem norm_eq_of_norm_add_lt_left {z1 z2 : «exprℤ_[ ]» p} (h : «expr‖ ‖» (z1 + z2) < «expr‖ ‖» z1) :\n    «expr‖ ‖» z1 = «expr‖ ‖» z2 :=\n  by_contradiction fun hne => not_lt_of_ge (by rw [norm_add_eq_max_of_ne hne] <;> apply le_max_left) h\n#align norm_eq_of_norm_add_lt_left norm_eq_of_norm_add_lt_left\n\n",
 "norm_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ_[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℚ_[ ]» -/\ntheorem norm_def {z : «exprℤ_[ ]» p} : «expr‖ ‖» z = «expr‖ ‖» (z : «exprℚ_[ ]» p) :=\n  rfl\n#align norm_def norm_def\n\n",
 "norm_add_eq_max_of_ne":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ_[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem norm_add_eq_max_of_ne {q r : «exprℤ_[ ]» p} :\n    «expr‖ ‖» q ≠ «expr‖ ‖» r → «expr‖ ‖» (q + r) = max («expr‖ ‖» q) («expr‖ ‖» r) :=\n  padic_norm_e.add_eq_max_of_ne\n#align norm_add_eq_max_of_ne norm_add_eq_max_of_ne\n\n",
 "nonarchimedean":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ_[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem nonarchimedean (q r : «exprℤ_[ ]» p) : «expr‖ ‖» (q + r) ≤ max («expr‖ ‖» q) («expr‖ ‖» r) :=\n  padic_norm_e.nonarchimedean _ _\n#align nonarchimedean nonarchimedean\n\n",
 "mul_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℚ_[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ_[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n#print mul_inv /-\ntheorem mul_inv : ∀ {z : «exprℤ_[ ]» p}, «expr‖ ‖» z = 1 → z * z.inv = 1\n  | ⟨k, _⟩, h => by\n    have hk : k ≠ 0 := fun h' => zero_ne_one' («exprℚ_[ ]» p) (by simpa [h'] using h)\n    unfold padic_int.inv\n    rw [norm_eq_padic_norm] at h\n    rw [dif_pos h]\n    apply Subtype.ext_iff_val.2\n    simp [mul_inv_cancel hk]\n#align mul_inv mul_inv\n-/\n\n",
 "mk_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ_[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ_[ ]» -/\n@[simp]\ntheorem mk_zero {h} : (⟨0, h⟩ : «exprℤ_[ ]» p) = (0 : «exprℤ_[ ]» p) :=\n  rfl\n#align mk_zero mk_zero\n\n",
 "mk_units_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℚ_[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ_[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℚ_[ ]» -/\n@[simp]\ntheorem mk_units_eq {u : «exprℚ_[ ]» p} (h : «expr‖ ‖» u = 1) : ((mk_units h : «exprℤ_[ ]» p) : «exprℚ_[ ]» p) = u :=\n  rfl\n#align mk_units_eq mk_units_eq\n\n",
 "mk_coe":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ_[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ_[ ]» -/\n@[simp]\ntheorem mk_coe (k : «exprℤ_[ ]» p) : (⟨k, k.2⟩ : «exprℤ_[ ]» p) = k :=\n  Subtype.coe_eta _ _\n#align mk_coe mk_coe\n\n",
 "mem_subring_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℚ_[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n@[simp]\ntheorem mem_subring_iff {x : «exprℚ_[ ]» p} : x ∈ subring p ↔ «expr‖ ‖» x ≤ 1 :=\n  iff.rfl\n#align mem_subring_iff mem_subring_iff\n\n",
 "mem_span_pow_iff_le_valuation":
 "/- ./././Mathport/Syntax/Translate/Tactic/Lean3.lean:132:4: warning: unsupported: rw with cfg: { occs := occurrences.pos[occurrences.pos] «expr[ ,]»([2]) } -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ_[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ_[ ]» -/\ntheorem mem_span_pow_iff_le_valuation (x : «exprℤ_[ ]» p) (hx : x ≠ 0) (n : ℕ) :\n    x ∈ (Ideal.span {p ^ n} : Ideal («exprℤ_[ ]» p)) ↔ ↑n ≤ x.valuation :=\n  by\n  rw [Ideal.mem_span_singleton]\n  constructor\n  · rintro ⟨c, rfl⟩\n    suffices c ≠ 0 by\n      rw [valuation_p_pow_mul _ _ this, le_add_iff_nonneg_right]\n      apply valuation_nonneg\n    contrapose! hx\n    rw [hx, MulZeroClass.mul_zero]\n  · rw [unit_coeff_spec hx]\n    lift x.valuation to ℕ using x.valuation_nonneg with k hk\n    simp only [Int.natAbs_ofNat, Units.isUnit, IsUnit.dvd_mul_left, Int.ofNat_le]\n    intro H\n    obtain ⟨k, rfl⟩ := Nat.exists_eq_add_of_le H\n    simp only [pow_add, dvd_mul_right]\n#align mem_span_pow_iff_le_valuation mem_span_pow_iff_le_valuation\n\n",
 "mem_nonunits":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ_[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ_[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n@[simp]\ntheorem mem_nonunits {z : «exprℤ_[ ]» p} : z ∈ nonunits («exprℤ_[ ]» p) ↔ «expr‖ ‖» z < 1 := by\n  rw [lt_iff_le_and_ne] <;> simp [norm_le_one z, nonunits, is_unit_iff]\n#align mem_nonunits mem_nonunits\n\n",
 "maximal_ideal_eq_span_p":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ_[ ]» -/\ntheorem maximal_ideal_eq_span_p : maximal_ideal («exprℤ_[ ]» p) = Ideal.span {p} :=\n  by\n  apply le_antisymm\n  · intro x hx\n    simp only [local_ring.mem_maximal_ideal, mem_nonunits] at hx\n    rwa [Ideal.mem_span_singleton, ← norm_lt_one_iff_dvd]\n  · rw [Ideal.span_le, Set.singleton_subset_iff]\n    exact p_nonnunit\n#align maximal_ideal_eq_span_p maximal_ideal_eq_span_p\n\n",
 "is_unit_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ_[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem is_unit_iff {z : «exprℤ_[ ]» p} : IsUnit z ↔ «expr‖ ‖» z = 1 :=\n  ⟨fun h => by\n    rcases isUnit_iff_dvd_one.1 h with ⟨w, eq⟩\n    refine' le_antisymm (norm_le_one _) _\n    have := mul_le_mul_of_nonneg_left (norm_le_one w) (norm_nonneg z)\n    rwa [mul_one, ← norm_mul, ← Eq, norm_one] at this, fun h => ⟨⟨z, z.inv, mul_inv h, inv_mul h⟩, rfl⟩⟩\n#align is_unit_iff is_unit_iff\n\n",
 "irreducible_p":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ_[ ]» -/\ntheorem irreducible_p : Irreducible (p : «exprℤ_[ ]» p) :=\n  Prime.irreducible prime_p\n#align irreducible_p irreducible_p\n\n",
 "inv_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ_[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem inv_mul {z : «exprℤ_[ ]» p} (hz : «expr‖ ‖» z = 1) : z.inv * z = 1 := by rw [mul_comm, mul_inv hz]\n#align inv_mul inv_mul\n\n",
 "ideal_eq_span_pow_p":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ_[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem ideal_eq_span_pow_p {s : Ideal («exprℤ_[ ]» p)} (hs : s ≠ «expr⊥») : ∃ n : ℕ, s = Ideal.span {p ^ n} :=\n  discrete_valuation_ring.ideal_eq_span_pow_irreducible hs irreducible_p\n#align ideal_eq_span_pow_p ideal_eq_span_pow_p\n\n",
 "ext":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ_[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℚ_[ ]» -/\n/-\nCopyright (c) 2018 Robert Y. Lewis. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Robert Y. Lewis, Mario Carneiro, Johan Commelin\n-/\ntheorem ext {x y : «exprℤ_[ ]» p} : (x : «exprℚ_[ ]» p) = y → x = y :=\n  Subtype.ext\n#align ext ext\n\n",
 "exists_pow_neg_lt_rat":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\ntheorem exists_pow_neg_lt_rat {ε : exprℚ} (hε : 0 < ε) : ∃ k : ℕ, ↑p ^ (-(k : ℤ)) < ε :=\n  by\n  obtain ⟨k, hk⟩ := @exists_pow_neg_lt p _ ε (by exact_mod_cast hε)\n  use k\n  rw [show (p : exprℝ) = (p : exprℚ) by simp] at hk\n  exact_mod_cast hk\n#align exists_pow_neg_lt_rat exists_pow_neg_lt_rat\n\n",
 "exists_pow_neg_lt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem exists_pow_neg_lt {ε : exprℝ} (hε : 0 < ε) : ∃ k : ℕ, ↑p ^ (-(k : ℤ)) < ε :=\n  by\n  obtain ⟨k, hk⟩ := exists_nat_gt ε⁻¹\n  use k\n  rw [← inv_lt_inv hε (_root_.zpow_pos_of_pos _ _)]\n  · rw [zpow_neg, inv_inv, zpow_ofNat]\n    apply lt_of_lt_of_le hk\n    norm_cast\n    apply le_of_lt\n    convert Nat.lt_pow_self _ _ using 1\n    exact hp.1.one_lt\n  · exact_mod_cast hp.1.pos\n#align exists_pow_neg_lt exists_pow_neg_lt\n\n",
 "coe_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ_[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℚ_[ ]» -/\n@[simp, norm_cast]\ntheorem coe_zero : ((0 : «exprℤ_[ ]» p) : «exprℚ_[ ]» p) = 0 :=\n  rfl\n#align coe_zero coe_zero\n\n",
 "coe_sub":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ_[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ_[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℚ_[ ]» -/\n@[simp, norm_cast]\ntheorem coe_sub (z1 z2 : «exprℤ_[ ]» p) : ((z1 - z2 : «exprℤ_[ ]» p) : «exprℚ_[ ]» p) = z1 - z2 :=\n  rfl\n#align coe_sub coe_sub\n\n",
 "coe_pow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ_[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℚ_[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℚ_[ ]» -/\n@[simp, norm_cast]\ntheorem coe_pow (x : «exprℤ_[ ]» p) (n : ℕ) : (↑(x ^ n) : «exprℚ_[ ]» p) = (↑x : «exprℚ_[ ]» p) ^ n :=\n  rfl\n#align coe_pow coe_pow\n\n",
 "coe_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ_[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℚ_[ ]» -/\n@[simp, norm_cast]\ntheorem coe_one : ((1 : «exprℤ_[ ]» p) : «exprℚ_[ ]» p) = 1 :=\n  rfl\n#align coe_one coe_one\n\n",
 "coe_neg":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ_[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ_[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℚ_[ ]» -/\n@[simp, norm_cast]\ntheorem coe_neg (z1 : «exprℤ_[ ]» p) : ((-z1 : «exprℤ_[ ]» p) : «exprℚ_[ ]» p) = -z1 :=\n  rfl\n#align coe_neg coe_neg\n\n",
 "coe_ne_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ_[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℚ_[ ]» -/\ntheorem coe_ne_zero (z : «exprℤ_[ ]» p) : (z : «exprℚ_[ ]» p) ≠ 0 ↔ z ≠ 0 :=\n  z.coe_eq_zero.not\n#align coe_ne_zero coe_ne_zero\n\n",
 "coe_nat_cast":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ_[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℚ_[ ]» -/\n@[simp, norm_cast]\ntheorem coe_nat_cast (n : ℕ) : ((n : «exprℤ_[ ]» p) : «exprℚ_[ ]» p) = n :=\n  rfl\n#align coe_nat_cast coe_nat_cast\n\n",
 "coe_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ_[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ_[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℚ_[ ]» -/\n@[simp, norm_cast]\ntheorem coe_mul (z1 z2 : «exprℤ_[ ]» p) : ((z1 * z2 : «exprℤ_[ ]» p) : «exprℚ_[ ]» p) = z1 * z2 :=\n  rfl\n#align coe_mul coe_mul\n\n",
 "coe_int_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℚ_[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ_[ ]» -/\n@[simp, norm_cast]\ntheorem coe_int_eq (z1 z2 : ℤ) : (z1 : «exprℤ_[ ]» p) = z2 ↔ z1 = z2 :=\n  by\n  suffices (z1 : «exprℚ_[ ]» p) = z2 ↔ z1 = z2 from iff.trans (by norm_cast) this\n  norm_cast\n#align coe_int_eq coe_int_eq\n\n",
 "coe_int_cast":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ_[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℚ_[ ]» -/\n@[simp, norm_cast]\ntheorem coe_int_cast (z : ℤ) : ((z : «exprℤ_[ ]» p) : «exprℚ_[ ]» p) = z :=\n  rfl\n#align coe_int_cast coe_int_cast\n\n",
 "coe_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ_[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℚ_[ ]» -/\ntheorem coe_eq_zero (z : «exprℤ_[ ]» p) : (z : «exprℚ_[ ]» p) = 0 ↔ z = 0 := by rw [← coe_zero, Subtype.coe_inj]\n#align coe_eq_zero coe_eq_zero\n\n",
 "coe_add":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ_[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ_[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℚ_[ ]» -/\n@[simp, norm_cast]\ntheorem coe_add (z1 z2 : «exprℤ_[ ]» p) : ((z1 + z2 : «exprℤ_[ ]» p) : «exprℚ_[ ]» p) = z1 + z2 :=\n  rfl\n#align coe_add coe_add\n\n",
 "algebraMap_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ_[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ_[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℚ_[ ]» -/\n#print algebraMap_apply /-\n@[simp]\ntheorem algebraMap_apply (x : «exprℤ_[ ]» p) : algebraMap («exprℤ_[ ]» p) («exprℚ_[ ]» p) x = x :=\n  rfl\n#align algebra_map_apply algebraMap_apply\n-/\n\n"}