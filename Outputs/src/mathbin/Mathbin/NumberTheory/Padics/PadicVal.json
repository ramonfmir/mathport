{"zero_le_padic_val_rat_of_nat":
 "theorem zero_le_padic_val_rat_of_nat (n : ℕ) : 0 ≤ padic_val_rat p n := by simp\n#align zero_le_padic_val_rat_of_nat zero_le_padic_val_rat_of_nat\n\n",
 "zero":
 "/-- `padic_val_rat p 0` is `0` for any `p`. -/\n@[simp]\nprotected theorem zero : padic_val_rat p 0 = 0 := by simp [padic_val_rat]\n#align zero zero\n\n",
 "sum_pos_of_pos":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/-- A finite sum of rationals with positive `p`-adic valuation has positive `p`-adic valuation\n(if the sum is non-zero). -/\ntheorem sum_pos_of_pos {n : ℕ} {F : ℕ → exprℚ} (hF : ∀ i, i < n → 0 < padic_val_rat p (F i))\n    (hn0 :\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (Finset.range n)\n          (F i) ≠\n        0) :\n    0 <\n      padic_val_rat p\n        (finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n          (Finset.range n) (F i)) :=\n  by\n  induction' n with d hd\n  · exact false.elim (hn0 rfl)\n  · rw [finset.sum_range_succ] at hn0⊢\n    by_cases h :\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (Finset.range d)\n          (F x) =\n        0\n    · rw [h, zero_add]\n      exact hF d (lt_add_one _)\n    · refine' lt_of_lt_of_le _ (min_le_padic_val_rat_add hn0)\n      · refine' lt_min (hd (fun i hi => _) h) (hF d (lt_add_one _))\n        exact hF _ (lt_trans hi (lt_add_one _))\n#align sum_pos_of_pos sum_pos_of_pos\n\n",
 "self":
 "/-- If `p ≠ 0` and `p ≠ 1`, then `padic_val_rat p p` is `1`. -/\ntheorem self (hp : 1 < p) : padic_val_rat p p = 1 := by simp [hp]\n#align self self\n\n",
 "range_pow_padic_val_nat_subset_divisors'":
 "theorem range_pow_padic_val_nat_subset_divisors' {n : ℕ} [hp : fact p.prime] :\n    ((Finset.range (padic_val_nat p n)).image fun t => p ^ (t + 1)) ⊆ n.divisors.erase 1 :=\n  by\n  rcases eq_or_ne n 0 with (rfl | hn)\n  · simp\n  intro t ht\n  simp only [exists_prop, Finset.mem_image, Finset.mem_range] at ht\n  obtain ⟨k, hk, rfl⟩ := ht\n  rw [Finset.mem_erase, nat.mem_divisors]\n  refine' ⟨_, (pow_dvd_pow p <| succ_le_iff.2 hk).trans pow_padic_val_nat_dvd, hn⟩\n  exact (Nat.one_lt_pow _ _ k.succ_pos hp.out.one_lt).ne'\n#align range_pow_padic_val_nat_subset_divisors' range_pow_padic_val_nat_subset_divisors'\n\n",
 "range_pow_padic_val_nat_subset_divisors":
 "theorem range_pow_padic_val_nat_subset_divisors {n : ℕ} (hn : n ≠ 0) :\n    (Finset.range (padic_val_nat p n + 1)).image (pow p) ⊆ n.divisors :=\n  by\n  intro t ht\n  simp only [exists_prop, Finset.mem_image, Finset.mem_range] at ht\n  obtain ⟨k, hk, rfl⟩ := ht\n  rw [nat.mem_divisors]\n  exact ⟨(pow_dvd_pow p <| by linarith).trans pow_padic_val_nat_dvd, hn⟩\n#align range_pow_padic_val_nat_subset_divisors range_pow_padic_val_nat_subset_divisors\n\n",
 "prime_pow":
 "@[simp]\nprotected theorem prime_pow (n : ℕ) : padic_val_nat p (p ^ n) = n := by\n  rwa [padic_val_nat.pow _ (fact.out p.prime).ne_zero, padic_val_nat_self, mul_one]\n#align prime_pow prime_pow\n\n",
 "pow_succ_padic_val_nat_not_dvd":
 "theorem pow_succ_padic_val_nat_not_dvd {n : ℕ} [hp : fact p.prime] (hn : n ≠ 0) : ¬p ^ (padic_val_nat p n + 1) ∣ n :=\n  by\n  rw [padic_val_nat_dvd_iff_le hn, not_le]\n  exacts[nat.lt_succ_self _, hp]\n#align pow_succ_padic_val_nat_not_dvd pow_succ_padic_val_nat_not_dvd\n\n",
 "pow_padic_val_nat_dvd":
 "theorem pow_padic_val_nat_dvd {n : ℕ} : p ^ padic_val_nat p n ∣ n :=\n  by\n  rcases n.eq_zero_or_pos with (rfl | hn); · simp\n  rcases eq_or_ne p 1 with (rfl | hp); · simp\n  rw [multiplicity.pow_dvd_iff_le_multiplicity, padic_val_nat_def'] <;> assumption\n#align pow_padic_val_nat_dvd pow_padic_val_nat_dvd\n\n",
 "pow":
 "/-- A version of `padic_val_rat.pow` for `padic_val_nat`. -/\nprotected theorem pow (n : ℕ) (ha : a ≠ 0) : padic_val_nat p (a ^ n) = n * padic_val_nat p a := by\n  simpa only [← @Nat.cast_inj ℤ, push_cast] using padic_val_rat.pow (cast_ne_zero.mpr ha)\n#align pow pow\n\n",
 "padic_val_rat_of_nat":
 "/-- `padic_val_rat` coincides with `padic_val_nat`. -/\n@[norm_cast]\ntheorem padic_val_rat_of_nat (n : ℕ) : ↑(padic_val_nat p n) = padic_val_rat p n := by simp\n#align padic_val_rat_of_nat padic_val_rat_of_nat\n\n",
 "padic_val_rat_le_padic_val_rat_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `rat.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `rat.mk -/\n/-- A condition for `padic_val_rat p (n₁ / d₁) ≤ padic_val_rat p (n₂ / d₂)`, in terms of\ndivisibility by `p^n`. -/\ntheorem padic_val_rat_le_padic_val_rat_iff {n₁ n₂ d₁ d₂ : ℤ} (hn₁ : n₁ ≠ 0) (hn₂ : n₂ ≠ 0) (hd₁ : d₁ ≠ 0)\n    (hd₂ : d₂ ≠ 0) :\n    padic_val_rat p (rat.mk n₁ d₁) ≤ padic_val_rat p (rat.mk n₂ d₂) ↔ ∀ n : ℕ, ↑p ^ n ∣ n₁ * d₂ → ↑p ^ n ∣ n₂ * d₁ :=\n  by\n  have hf1 : Finite (p : ℤ) (n₁ * d₂) := finite_int_prime_iff.2 (mul_ne_zero hn₁ hd₂)\n  have hf2 : Finite (p : ℤ) (n₂ * d₁) := finite_int_prime_iff.2 (mul_ne_zero hn₂ hd₁)\n  conv =>\n    lhs\n    rw [padic_val_rat.defn p (Rat.divInt_ne_zero_of_ne_zero hn₁ hd₁) rfl,\n      padic_val_rat.defn p (Rat.divInt_ne_zero_of_ne_zero hn₂ hd₂) rfl, sub_le_iff_le_add', ← add_sub_assoc,\n      le_sub_iff_add_le]\n    norm_cast\n    rw [← multiplicity.mul' (Nat.prime_iff_prime_int.1 hp.1) hf1, add_comm, ←\n      multiplicity.mul' (Nat.prime_iff_prime_int.1 hp.1) hf2, part_enat.get_le_get, multiplicity_le_multiplicity_iff]\n#align padic_val_rat_le_padic_val_rat_iff padic_val_rat_le_padic_val_rat_iff\n\n",
 "padic_val_nat_self":
 "@[simp]\ntheorem padic_val_nat_self [fact p.prime] : padic_val_nat p p = 1 := by simp [padic_val_nat_def (fact.out p.prime).pos]\n#align padic_val_nat_self padic_val_nat_self\n\n",
 "padic_val_nat_primes":
 "theorem padic_val_nat_primes {q : ℕ} [hp : fact p.prime] [hq : fact q.prime] (neq : p ≠ q) : padic_val_nat p q = 0 :=\n  @padic_val_nat.eq_zero_of_not_dvd p q <| (not_congr (iff.symm (prime_dvd_prime_iff_eq hp.1 hq.1))).mp neq\n#align padic_val_nat_primes padic_val_nat_primes\n\n",
 "padic_val_nat_dvd_iff_le":
 "theorem padic_val_nat_dvd_iff_le [hp : fact p.prime] {a n : ℕ} (ha : a ≠ 0) : p ^ n ∣ a ↔ n ≤ padic_val_nat p a := by\n  rw [pow_dvd_iff_le_multiplicity, ← padic_val_nat_def' hp.out.ne_one ha.bot_lt, part_enat.coe_le_coe]\n#align padic_val_nat_dvd_iff_le padic_val_nat_dvd_iff_le\n\n",
 "padic_val_nat_dvd_iff":
 "theorem padic_val_nat_dvd_iff (n : ℕ) [hp : fact p.prime] (a : ℕ) : p ^ n ∣ a ↔ a = 0 ∨ n ≤ padic_val_nat p a :=\n  by\n  rcases eq_or_ne a 0 with (rfl | ha)\n  · exact iff_of_true (dvd_zero _) (or.inl rfl)\n  · simp only [ha, false_or_iff, padic_val_nat_dvd_iff_le ha]\n#align padic_val_nat_dvd_iff padic_val_nat_dvd_iff\n\n",
 "padic_val_nat_def'":
 "theorem padic_val_nat_def' {n : ℕ} (hp : p ≠ 1) (hn : 0 < n) : ↑(padic_val_nat p n) = multiplicity p n := by\n  simp [padic_val_nat, hp, hn]\n#align padic_val_nat_def' padic_val_nat_def'\n\n",
 "padic_val_nat_def":
 "/-- A simplification of `padic_val_nat` when one input is prime, by analogy with\n`padic_val_rat_def`. -/\ntheorem padic_val_nat_def [hp : fact p.prime] {n : ℕ} (hn : 0 < n) :\n    padic_val_nat p n = (multiplicity p n).get (multiplicity.finite_nat_iff.2 ⟨hp.out.ne_one, hn⟩) :=\n  dif_pos ⟨hp.out.ne_one, hn⟩\n#align padic_val_nat_def padic_val_nat_def\n\n",
 "padic_val_int_self":
 "theorem padic_val_int_self : padic_val_int p p = 1 :=\n  padic_val_int.self hp.out.one_lt\n#align padic_val_int_self padic_val_int_self\n\n",
 "padic_val_int_mul_eq_succ":
 "theorem padic_val_int_mul_eq_succ (a : ℤ) (ha : a ≠ 0) : padic_val_int p (a * p) = padic_val_int p a + 1 :=\n  by\n  rw [padic_val_int.mul ha (int.coe_nat_ne_zero.mpr hp.out.ne_zero)]\n  simp only [eq_self_iff_true, padic_val_int.of_nat, padic_val_nat_self]\n  exact hp\n#align padic_val_int_mul_eq_succ padic_val_int_mul_eq_succ\n\n",
 "padic_val_int_dvd_iff":
 "theorem padic_val_int_dvd_iff (n : ℕ) (a : ℤ) : (p : ℤ) ^ n ∣ a ↔ a = 0 ∨ n ≤ padic_val_int p a := by\n  rw [padic_val_int, ← Int.natAbs_eq_zero, ← padic_val_nat_dvd_iff, ← Int.coe_nat_dvd_left, Int.coe_nat_pow]\n#align padic_val_int_dvd_iff padic_val_int_dvd_iff\n\n",
 "padic_val_int_dvd":
 "theorem padic_val_int_dvd (a : ℤ) : (p : ℤ) ^ padic_val_int p a ∣ a :=\n  by\n  rw [padic_val_int_dvd_iff]\n  exact or.inr le_rfl\n#align padic_val_int_dvd padic_val_int_dvd\n\n",
 "one_le_padic_val_nat_of_dvd":
 "theorem one_le_padic_val_nat_of_dvd {n : ℕ} [hp : fact p.prime] (hn : 0 < n) (div : p ∣ n) : 1 ≤ padic_val_nat p n := by\n  rwa [← part_enat.coe_le_coe, padic_val_nat_def' hp.out.ne_one hn, ← pow_dvd_iff_le_multiplicity, pow_one]\n#align one_le_padic_val_nat_of_dvd one_le_padic_val_nat_of_dvd\n\n",
 "one":
 "/-- `padic_val_rat p 1` is `0` for any `p`. -/\n@[simp]\nprotected theorem one : padic_val_rat p 1 = 0 := by simp [padic_val_rat]\n#align one one\n\n",
 "of_ne_one_ne_zero":
 "theorem of_ne_one_ne_zero {z : ℤ} (hp : p ≠ 1) (hz : z ≠ 0) :\n    padic_val_int p z =\n      (multiplicity (p : ℤ) z).get\n        (by\n          apply multiplicity.finite_int_iff.2\n          simp [hp, hz]) :=\n  by\n  rw [padic_val_int, padic_val_nat, dif_pos (and.intro hp (Int.natAbs_pos_of_ne_zero hz))]\n  simp only [multiplicity.int.nat_abs p z]\n  rfl\n#align of_ne_one_ne_zero of_ne_one_ne_zero\n\n",
 "of_nat":
 "/-- The `p`-adic value of an integer `z ≠ 0` is its `p`-adic value as a rational. -/\n@[simp]\ntheorem of_nat {n : ℕ} : padic_val_rat p n = padic_val_nat p n := by simp [padic_val_rat]\n#align of_nat of_nat\n\n",
 "of_int_multiplicity":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/-- The `p`-adic value of an integer `z ≠ 0` is the multiplicity of `p` in `z`. -/\ntheorem of_int_multiplicity {z : ℤ} (hp : p ≠ 1) (hz : z ≠ 0) :\n    padic_val_rat p (z : exprℚ) = (multiplicity (p : ℤ) z).get (finite_int_iff.2 ⟨hp, hz⟩) := by\n  rw [of_int, padic_val_int.of_ne_one_ne_zero hp hz]\n#align of_int_multiplicity of_int_multiplicity\n\n",
 "of_int":
 "/-- The `p`-adic value of an integer `z ≠ 0` is its `p`-adic_value as a rational. -/\n@[simp]\ntheorem of_int {z : ℤ} : padic_val_rat p z = padic_val_int p z := by simp [padic_val_rat]\n#align of_int of_int\n\n",
 "neg":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/-- `padic_val_rat p q` is symmetric in `q`. -/\n@[simp]\nprotected theorem neg (q : exprℚ) : padic_val_rat p (-q) = padic_val_rat p q := by simp [padic_val_rat, padic_val_int]\n#align neg neg\n\n",
 "multiplicity_sub_multiplicity":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\ntheorem multiplicity_sub_multiplicity {q : exprℚ} (hp : p ≠ 1) (hq : q ≠ 0) :\n    padic_val_rat p q =\n      (multiplicity (p : ℤ) q.num).get (finite_int_iff.2 ⟨hp, Rat.num_ne_zero_of_ne_zero hq⟩) -\n        (multiplicity p q.denom).get\n          (by\n            rw [← finite_iff_dom, finite_nat_iff]\n            exact ⟨hp, q.pos⟩) :=\n  by\n  rw [padic_val_rat, padic_val_int.of_ne_one_ne_zero hp, padic_val_nat, dif_pos]\n  · rfl\n  · exact ⟨hp, q.pos⟩\n  · exact Rat.num_ne_zero_of_ne_zero hq\n#align multiplicity_sub_multiplicity multiplicity_sub_multiplicity\n\n",
 "mul":
 "theorem padic_val_int.mul {a b : ℤ} (ha : a ≠ 0) (hb : b ≠ 0) :\n    padic_val_int p (a * b) = padic_val_int p a + padic_val_int p b :=\n  by\n  simp_rw [padic_val_int]\n  rw [Int.natAbs_mul, padic_val_nat.mul] <;> rwa [Int.natAbs_ne_zero]\n#align padic_val_int.mul padic_val_int.mul\n\n",
 "min_le_padic_val_rat_add":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/-- The minimum of the valuations of `q` and `r` is at most the valuation of `q + r`. -/\ntheorem min_le_padic_val_rat_add {q r : exprℚ} (hqr : q + r ≠ 0) :\n    min (padic_val_rat p q) (padic_val_rat p r) ≤ padic_val_rat p (q + r) :=\n  (le_total (padic_val_rat p q) (padic_val_rat p r)).elim\n    (fun h => by rw [min_eq_left h] <;> exact le_padic_val_rat_add_of_le hqr h) fun h => by\n    rw [min_eq_right h, add_comm] <;> exact le_padic_val_rat_add_of_le (by rwa [add_comm]) h\n#align min_le_padic_val_rat_add min_le_padic_val_rat_add\n\n",
 "le_padic_val_rat_add_of_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `rat.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/-- Sufficient conditions to show that the `p`-adic valuation of `q` is less than or equal to the\n`p`-adic valuation of `q + r`. -/\ntheorem le_padic_val_rat_add_of_le {q r : exprℚ} (hqr : q + r ≠ 0) (h : padic_val_rat p q ≤ padic_val_rat p r) :\n    padic_val_rat p q ≤ padic_val_rat p (q + r) :=\n  if hq : q = 0 then by simpa [hq] using h\n  else\n    if hr : r = 0 then by simp [hr]\n    else by\n      have hqn : q.num ≠ 0 := Rat.num_ne_zero_of_ne_zero hq\n      have hqd : (q.denom : ℤ) ≠ 0 := by exact_mod_cast Rat.den_nz _\n      have hrn : r.num ≠ 0 := Rat.num_ne_zero_of_ne_zero hr\n      have hrd : (r.denom : ℤ) ≠ 0 := by exact_mod_cast Rat.den_nz _\n      have hqreq : q + r = rat.mk (q.num * r.denom + q.denom * r.num) (q.denom * r.denom) := Rat.add_num_den _ _\n      have hqrd : q.num * r.denom + q.denom * r.num ≠ 0 := Rat.mk_num_ne_zero_of_ne_zero hqr hqreq\n      conv_lhs => rw [← @Rat.num_den q]\n      rw [hqreq, padic_val_rat_le_padic_val_rat_iff hqn hqrd hqd (mul_ne_zero hqd hrd), ←\n        multiplicity_le_multiplicity_iff, mul_left_comm, multiplicity.mul (Nat.prime_iff_prime_int.1 hp.1), add_mul]\n      rw [← @Rat.num_den q, ← @Rat.num_den r, padic_val_rat_le_padic_val_rat_iff hqn hrn hqd hrd, ←\n        multiplicity_le_multiplicity_iff] at h\n      calc\n        _ ≤ min (multiplicity (↑p) (q.num * ↑r.denom * ↑q.denom)) (multiplicity (↑p) (↑q.denom * r.num * ↑q.denom)) :=\n          le_min (by rw [@multiplicity.mul _ _ _ _ (_ * _) _ (Nat.prime_iff_prime_int.1 hp.1), add_comm])\n            (by\n              rw [mul_assoc, @multiplicity.mul _ _ _ _ (q.denom : ℤ) (_ * _) (Nat.prime_iff_prime_int.1 hp.1)] <;>\n                exact add_le_add_left h _)\n        _ ≤ _ := min_le_multiplicity_add\n        \n      all_goals exact hp\n#align le_padic_val_rat_add_of_le le_padic_val_rat_add_of_le\n\n",
 "inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/-- A rewrite lemma for `padic_val_rat p (q⁻¹)` with condition `q ≠ 0`. -/\nprotected theorem inv (q : exprℚ) : padic_val_rat p q⁻¹ = -padic_val_rat p q :=\n  by\n  by_cases hq : q = 0\n  · simp [hq]\n  · rw [eq_neg_iff_add_eq_zero, ← padic_val_rat.mul (inv_ne_zero hq) hq, inv_mul_cancel hq, padic_val_rat.one]\n    exact hp\n#align inv inv\n\n",
 "finite_int_prime_iff":
 "/-- The multiplicity of `p : ℕ` in `a : ℤ` is finite exactly when `a ≠ 0`. -/\ntheorem finite_int_prime_iff {a : ℤ} : Finite (p : ℤ) a ↔ a ≠ 0 := by\n  simp [finite_int_iff, ne.symm (ne_of_lt hp.1.one_lt)]\n#align finite_int_prime_iff finite_int_prime_iff\n\n",
 "eq_zero_of_not_dvd":
 "theorem eq_zero_of_not_dvd {z : ℤ} (h : ¬(p : ℤ) ∣ z) : padic_val_int p z = 0 :=\n  by\n  rw [padic_val_int, padic_val_nat]\n  split_ifs <;> simp [multiplicity.int.nat_abs, multiplicity_eq_zero.2 h]\n#align eq_zero_of_not_dvd eq_zero_of_not_dvd\n\n",
 "eq_zero_iff":
 "@[simp]\ntheorem eq_zero_iff {n : ℕ} : padic_val_nat p n = 0 ↔ p = 1 ∨ n = 0 ∨ ¬p ∣ n := by\n  simp only [padic_val_nat, dite_eq_right_iff, part_enat.get_eq_iff_eq_coe, Nat.cast_zero, multiplicity_eq_zero,\n    and_imp, pos_iff_ne_zero, ne.def, ← or_iff_not_imp_left]\n#align eq_zero_iff eq_zero_iff\n\n",
 "dvd_of_one_le_padic_val_nat":
 "theorem dvd_of_one_le_padic_val_nat {n : ℕ} (hp : 1 ≤ padic_val_nat p n) : p ∣ n :=\n  by\n  by_contra h\n  rw [padic_val_nat.eq_zero_of_not_dvd h] at hp\n  exact lt_irrefl 0 (lt_of_lt_of_le zero_lt_one hp)\n#align dvd_of_one_le_padic_val_nat dvd_of_one_le_padic_val_nat\n\n",
 "dvd_iff_padic_val_nat_ne_zero":
 "theorem dvd_iff_padic_val_nat_ne_zero {p n : ℕ} [fact p.prime] (hn0 : n ≠ 0) : p ∣ n ↔ padic_val_nat p n ≠ 0 :=\n  ⟨fun h => one_le_iff_ne_zero.mp (one_le_padic_val_nat_of_dvd hn0.bot_lt h), fun h =>\n    not_not.1 (mt padic_val_nat.eq_zero_of_not_dvd h)⟩\n#align dvd_iff_padic_val_nat_ne_zero dvd_iff_padic_val_nat_ne_zero\n\n",
 "div_pow":
 "#print div_pow /-\nprotected theorem div_pow (dvd : p ^ a ∣ b) : padic_val_nat p (b / p ^ a) = padic_val_nat p b - a :=\n  by\n  rw [padic_val_nat.div_of_dvd dvd, padic_val_nat.prime_pow]\n  exact hp\n#align div_pow div_pow\n-/\n\n",
 "div_of_dvd":
 "protected theorem div_of_dvd (h : b ∣ a) : padic_val_nat p (a / b) = padic_val_nat p a - padic_val_nat p b :=\n  by\n  rcases eq_or_ne a 0 with (rfl | ha)\n  · simp\n  obtain ⟨k, rfl⟩ := h\n  obtain ⟨hb, hk⟩ := mul_ne_zero_iff.mp ha\n  rw [mul_comm, k.mul_div_cancel hb.bot_lt, padic_val_nat.mul hk hb, nat.add_sub_cancel]\n  exact hp\n#align div_of_dvd div_of_dvd\n\n",
 "div'":
 "protected theorem div' {m : ℕ} (cpm : coprime p m) {b : ℕ} (dvd : m ∣ b) :\n    padic_val_nat p (b / m) = padic_val_nat p b := by\n  rw [padic_val_nat.div_of_dvd dvd, eq_zero_of_not_dvd (hp.out.coprime_iff_not_dvd.mp cpm), nat.sub_zero] <;> assumption\n#align div' div'\n\n",
 "div":
 "/-- Dividing out by a prime factor reduces the `padic_val_nat` by `1`. -/\nprotected theorem div (dvd : p ∣ b) : padic_val_nat p (b / p) = padic_val_nat p b - 1 :=\n  by\n  convert padic_val_nat.div_of_dvd dvd\n  rw [padic_val_nat_self]\n  exact hp\n#align div div\n\n",
 "defn":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `rat.mk -/\n/-- A rewrite lemma for `padic_val_rat p q` when `q` is expressed in terms of `rat.mk`. -/\nprotected theorem defn (p : ℕ) [hp : fact p.prime] {q : exprℚ} {n d : ℤ} (hqz : q ≠ 0) (qdf : q = rat.mk n d) :\n    padic_val_rat p q =\n      (multiplicity (p : ℤ) n).get (finite_int_iff.2 ⟨ne.symm <| ne_of_lt hp.1.one_lt, fun hn => by simp_all⟩) -\n        (multiplicity (p : ℤ) d).get (finite_int_iff.2 ⟨ne.symm <| ne_of_lt hp.1.one_lt, fun hd => by simp_all⟩) :=\n  by\n  have hd : d ≠ 0 := Rat.mk_denom_ne_zero_of_ne_zero hqz qdf\n  let ⟨c, hc1, hc2⟩ := Rat.num_den_mk hd qdf\n  rw [padic_val_rat.multiplicity_sub_multiplicity] <;>\n    simp [hc1, hc2, multiplicity.mul' (Nat.prime_iff_prime_int.1 hp.1), ne.symm (ne_of_lt hp.1.one_lt), hqz,\n      pos_iff_ne_zero, int.coe_nat_multiplicity p q.denom]\n#align defn defn\n\n"}