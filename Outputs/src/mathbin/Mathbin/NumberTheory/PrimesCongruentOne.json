{"infinite_set_of_prime_modeq_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≡ [MOD ]» -/\n/-- For any positive `k : ℕ` there are infinitely many primes `p` such that `p ≡ 1 [MOD k]`. -/\ntheorem infinite_set_of_prime_modeq_one {k : ℕ} (hk0 : k ≠ 0) :\n    set.infinite { p : ℕ | Nat.Prime p ∧ «expr ≡ [MOD ]» p 1 k } :=\n  frequently_at_top_iff_infinite.1 (frequently_at_top_modeq_one hk0)\n#align infinite_set_of_prime_modeq_one infinite_set_of_prime_modeq_one\n\n",
 "frequently_at_top_modeq_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≡ [MOD ]» -/\ntheorem frequently_at_top_modeq_one {k : ℕ} (hk0 : k ≠ 0) :\n    «expr∃ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , »\" at_top\n      (Nat.Prime p ∧ «expr ≡ [MOD ]» p 1 k) :=\n  by\n  refine' frequently_at_top.2 fun n => _\n  obtain ⟨p, hp⟩ := exists_prime_gt_modeq_one n hk0\n  exact ⟨p, ⟨hp.2.1.le, hp.1, hp.2.2⟩⟩\n#align frequently_at_top_modeq_one frequently_at_top_modeq_one\n\n",
 "exists_prime_gt_modeq_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≡ [MOD ]» -/\n/-\nCopyright (c) 2020 Riccardo Brasca. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Riccardo Brasca\n-/\n/-- For any positive `k : ℕ` there exists an arbitrarily large prime `p` such that\n`p ≡ 1 [MOD k]`. -/\ntheorem exists_prime_gt_modeq_one {k : ℕ} (n : ℕ) (hk0 : k ≠ 0) :\n    ∃ p : ℕ, Nat.Prime p ∧ n < p ∧ «expr ≡ [MOD ]» p 1 k :=\n  by\n  rcases(one_le_iff_ne_zero.2 hk0).eq_or_lt with (rfl | hk1)\n  · rcases exists_infinite_primes (n + 1) with ⟨p, hnp, hp⟩\n    exact ⟨p, hp, hnp, modeq_one⟩\n  let b := k * nat.factorial n\n  have hgt : 1 < (eval (↑b) (cyclotomic k ℤ)).nat_abs :=\n    by\n    rcases le_iff_exists_add'.1 hk1.le with ⟨k, rfl⟩\n    have hb : 2 ≤ b := le_mul_of_le_of_one_le hk1 n.factorial_pos\n    calc\n      1 ≤ b - 1 := le_tsub_of_add_le_left hb\n      _ < (eval (b : ℤ) (cyclotomic (k + 1) ℤ)).nat_abs := sub_one_lt_nat_abs_cyclotomic_eval hk1 (succ_le_iff.1 hb).ne'\n      \n  let p := min_fac (eval (↑b) (cyclotomic k ℤ)).nat_abs\n  haveI hprime : fact p.prime := ⟨min_fac_prime (ne_of_lt hgt).symm⟩\n  have hroot : is_root (cyclotomic k (zmod p)) (cast_ring_hom (zmod p) b) :=\n    by\n    rw [is_root.def, ← map_cyclotomic_int k (zmod p), eval_map, coe_cast_ring_hom, ← Int.cast_ofNat, ←\n      Int.coe_castRingHom, eval₂_hom, Int.coe_castRingHom, zmod.int_coe_zmod_eq_zero_iff_dvd _ _]\n    apply Int.dvd_natAbs.1\n    exact_mod_cast min_fac_dvd (eval (↑b) (cyclotomic k ℤ)).nat_abs\n  have hpb : ¬p ∣ b := hprime.1.coprime_iff_not_dvd.1 (coprime_of_root_cyclotomic hk0.bot_lt hroot).symm\n  refine' ⟨p, hprime.1, not_le.1 fun habs => _, _⟩\n  · exact hpb (dvd_mul_of_dvd_right (dvd_factorial (min_fac_pos _) habs) _)\n  · have hdiv : order_of (b : zmod p) ∣ p - 1 :=\n      zmod.order_of_dvd_card_sub_one (mt (char_p.cast_eq_zero_iff _ _ _).1 hpb)\n    haveI : ne_zero (k : zmod p) := ne_zero.of_not_dvd (zmod p) fun hpk => hpb (dvd_mul_of_dvd_left hpk _)\n    have : k = order_of (b : zmod p) := (is_root_cyclotomic_iff.mp hroot).eq_order_of\n    rw [← this] at hdiv\n    exact ((modeq_iff_dvd' hprime.1.pos).2 hdiv).symm\n#align exists_prime_gt_modeq_one exists_prime_gt_modeq_one\n\n"}