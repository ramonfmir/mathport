{"three_lt_four_mul_im_sq_of_mem_fdo":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `modular_group.fdo -/\ntheorem three_lt_four_mul_im_sq_of_mem_fdo (h : z âˆˆ modular_group.fdo) : 3 < 4 * z.im ^ 2 :=\n  by\n  have : 1 < z.re * z.re + z.im * z.im := by simpa [complex.norm_sq_apply] using h.1\n  have := h.2\n  cases abs_cases z.re <;> nlinarith\n#align three_lt_four_mul_im_sq_of_mem_fdo three_lt_four_mul_im_sq_of_mem_fdo\n\n",
 "tendsto_norm_sq_coprime_pair":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚—[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚—[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚—[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„‚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„‚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‡‘ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„‚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„‚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¥Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚—[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„‚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr![ ,]Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«expr![ ,]Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„‚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„‚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„‚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„‚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„‚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `star_ring_end -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„‚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„‚ -/\n/-- The function `(c,d) â†’ |cz+d|^2` is proper, that is, preimages of bounded-above sets are finite.\n-/\ntheorem tendsto_norm_sq_coprime_pair :\n    filter.tendsto (fun p : fin 2 â†’ â„¤ => ((p 0 : exprâ„‚) * z + p 1).norm_sq) cofinite at_top :=\n  by\n  -- using this instance rather than the automatic `function.module` makes unification issues in\n  -- `linear_equiv.closed_embedding_of_injective` less bad later in the proof.\n  letI : Module (exprâ„) (fin 2 â†’ exprâ„) := normed_space.to_module\n  let Ï€â‚€ : Â«expr â†’â‚—[ ] Â» (fin 2 â†’ exprâ„) (exprâ„) (exprâ„) := linear_map.proj 0\n  let Ï€â‚ : Â«expr â†’â‚—[ ] Â» (fin 2 â†’ exprâ„) (exprâ„) (exprâ„) := linear_map.proj 1\n  let f : Â«expr â†’â‚—[ ] Â» (fin 2 â†’ exprâ„) (exprâ„) (exprâ„‚) := Ï€â‚€.smul_right (z : exprâ„‚) + Ï€â‚.smul_right 1\n  have f_def : Â«exprâ‡‘ Â» f = fun p : fin 2 â†’ exprâ„ => (p 0 : exprâ„‚) * â†‘z + p 1 :=\n    by\n    ext1\n    dsimp only [linear_map.coe_proj, real_smul, linear_map.coe_smul_right, linear_map.add_apply]\n    rw [mul_one]\n  have :\n    (fun p : fin 2 â†’ â„¤ => norm_sq ((p 0 : exprâ„‚) * â†‘z + â†‘(p 1))) =\n      norm_sq âˆ˜ f âˆ˜ fun p : fin 2 â†’ â„¤ => (coe : â„¤ â†’ exprâ„) âˆ˜ p :=\n    by\n    ext1\n    rw [f_def]\n    dsimp only [function.comp]\n    rw [of_real_int_cast, of_real_int_cast]\n  rw [this]\n  have hf : f.ker = Â«exprâŠ¥Â» :=\n    by\n    let g : Â«expr â†’â‚—[ ] Â» (exprâ„‚) (exprâ„) (fin 2 â†’ exprâ„) :=\n      linear_map.pi (Â«expr![ ,]Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«expr![ ,]Â»\")\n    suffices (Â«expr â€¢ Â» (z : exprâ„‚).imâ»Â¹ g).comp f = linear_map.id by exact linear_map.ker_eq_bot_of_inverse this\n    apply linear_map.ext\n    intro c\n    have hz : (z : exprâ„‚).im â‰  0 := z.2.ne'\n    rw [linear_map.comp_apply, linear_map.smul_apply, linear_map.id_apply]\n    ext i\n    dsimp only [g, pi.smul_apply, linear_map.pi_apply, smul_eq_mul]\n    fin_cases i\n    Â· show (z : exprâ„‚).imâ»Â¹ * (f c).im = c 0\n      rw [f_def, add_im, of_real_mul_im, of_real_im, add_zero, mul_left_comm, inv_mul_cancel hz, mul_one]\n    Â· show (z : exprâ„‚).imâ»Â¹ * ((z : exprâ„‚) * (star_ring_end) (f c)).im = c 1\n      rw [f_def, RingHom.map_add, RingHom.map_mul, mul_add, mul_left_comm, mul_conj, conj_of_real, conj_of_real, â†\n        of_real_mul, add_im, of_real_im, zero_add, inv_mul_eq_iff_eq_mulâ‚€ hz]\n      simp only [of_real_im, of_real_re, mul_im, zero_add, mul_zero]\n  have hf' : closed_embedding f :=\n    by\n    -- for some reason we get a timeout if we try and apply this lemma in a more sensible way\n    have := @linear_equiv.closed_embedding_of_injective (exprâ„) _ (fin 2 â†’ exprâ„) _ (id _) (exprâ„‚) _ _ _ _\n    rotate_left 2\n    exact f\n    exact this hf\n  have hâ‚‚ : tendsto (fun p : fin 2 â†’ â„¤ => (coe : â„¤ â†’ exprâ„) âˆ˜ p) cofinite (cocompact _) :=\n    by\n    convert tendsto.pi_map_Coprod fun i => int.tendsto_coe_cofinite\n    Â· rw [Coprod_cofinite]\n    Â· rw [Coprod_cocompact]\n  exact tendsto_norm_sq_cocompact_at_top.comp (hf'.tendsto_cocompact.comp hâ‚‚)\n#align tendsto_norm_sq_coprime_pair tendsto_norm_sq_coprime_pair\n\n",
 "tendsto_lc_row0":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr![ ,]Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«expr![ ,]Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprSL( , )Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprSL( , )Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ†‘â‚˜ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprSL( , )Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/-- The map `lc_row0` is proper, that is, preimages of cocompact sets are finite in\n`[[* , *], [c, d]]`.-/\ntheorem tendsto_lc_row0 {cd : fin 2 â†’ â„¤} (hcd : IsCoprime (cd 0) (cd 1)) :\n    tendsto (fun g : { g : Â«exprSL( , )Â» 2 â„¤ // (Â«exprâ†‘â‚˜ Â» g) 1 = cd } => lc_row0 cd â†‘(â†‘g : Â«exprSL( , )Â» 2 (exprâ„)))\n      cofinite (cocompact (exprâ„)) :=\n  by\n  let mB : exprâ„ â†’ matrix (fin 2) (fin 2) (exprâ„) := fun t =>\n    of (Â«expr![ ,]Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«expr![ ,]Â»\")\n  have hmB : continuous mB := by\n    refine' continuous_matrix _\n    simp only [Fin.forall_fin_two, mB, continuous_const, continuous_id', of_apply, cons_val_zero, cons_val_one,\n      and_self_iff]\n  refine' filter.tendsto.of_tendsto_comp _ (comap_cocompact_le hmB)\n  let fâ‚ : Â«exprSL( , )Â» 2 â„¤ â†’ matrix (fin 2) (fin 2) (exprâ„) := fun g =>\n    matrix.map (â†‘g : matrix _ _ â„¤) (coe : â„¤ â†’ exprâ„)\n  have cocompact_â„_to_cofinite_â„¤_matrix :\n    tendsto (fun m : matrix (fin 2) (fin 2) â„¤ => matrix.map m (coe : â„¤ â†’ exprâ„)) cofinite (cocompact _) := by\n    simpa only [Coprod_cofinite, Coprod_cocompact] using\n      tendsto.pi_map_Coprod fun i : fin 2 => tendsto.pi_map_Coprod fun j : fin 2 => int.tendsto_coe_cofinite\n  have hfâ‚ : tendsto fâ‚ cofinite (cocompact _) :=\n    cocompact_â„_to_cofinite_â„¤_matrix.comp subtype.coe_injective.tendsto_cofinite\n  have hfâ‚‚ : closed_embedding (lc_row0_extend hcd) :=\n    (lc_row0_extend hcd).to_continuous_linear_equiv.to_homeomorph.closed_embedding\n  convert hfâ‚‚.tendsto_cocompact.comp (hfâ‚.comp subtype.coe_injective.tendsto_cofinite) using 1\n  ext (âŸ¨g, rflâŸ©i j) : 3\n  fin_cases i <;> [fin_cases j, skip]\n  -- the following are proved by `simp`, but it is replaced by `simp only` to avoid timeouts.\n  Â·\n    simp only [mB, mul_vec, dot_product, fin.sum_univ_two, _root_.coe_coe, coe_matrix_coe, Int.coe_castRingHom,\n      lc_row0_apply, Function.comp_apply, cons_val_zero, lc_row0_extend_apply,\n      linear_map.general_linear_group.coe_fn_general_linear_equiv, general_linear_group.to_linear_apply,\n      coe_plane_conformal_matrix, neg_neg, mul_vec_lin_apply, cons_val_one, head_cons, of_apply]\n  Â· convert congr_arg (fun n : â„¤ => (-n : exprâ„)) g.det_coe.symm using 1\n    simp only [fâ‚, mul_vec, dot_product, fin.sum_univ_two, matrix.det_fin_two, Function.comp_apply, subtype.coe_mk,\n      lc_row0_extend_apply, cons_val_zero, linear_map.general_linear_group.coe_fn_general_linear_equiv,\n      general_linear_group.to_linear_apply, coe_plane_conformal_matrix, mul_vec_lin_apply, cons_val_one, head_cons,\n      map_apply, neg_mul, Int.cast_sub, Int.cast_mul, neg_sub, of_apply]\n    ring\n  Â· rfl\n#align tendsto_lc_row0 tendsto_lc_row0\n\n",
 "tendsto_abs_re_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprSL( , )Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ†‘â‚˜ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprSL( , )Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„‚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprSL( , )Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprSL( , )Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„‚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprSL( , )Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ†‘â‚˜ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprSL( , )Â» -/\ntheorem tendsto_abs_re_smul {p : fin 2 â†’ â„¤} (hp : IsCoprime (p 0) (p 1)) :\n    tendsto (fun g : { g : Â«exprSL( , )Â» 2 â„¤ // (Â«exprâ†‘â‚˜ Â» g) 1 = p } => |(Â«expr â€¢ Â» (g : Â«exprSL( , )Â» 2 â„¤) z).re|)\n      cofinite at_top :=\n  by\n  suffices\n    tendsto\n      (fun g : Â«expr â»Â¹' Â» (fun g : Â«exprSL( , )Â» 2 â„¤ => (Â«exprâ†‘â‚˜ Â» g) 1) {p} =>\n        (Â«expr â€¢ Â» (g : Â«exprSL( , )Â» 2 â„¤) z).re)\n      cofinite (cocompact (exprâ„))\n    by exact tendsto_norm_cocompact_at_top.comp this\n  have : ((p 0 : exprâ„) ^ 2 + p 1 ^ 2)â»Â¹ â‰  0 := by\n    apply inv_ne_zero\n    exact_mod_cast hp.sq_add_sq_ne_zero\n  let f := homeomorph.mul_rightâ‚€ _ this\n  let ff := homeomorph.add_right (((p 1 : exprâ„‚) * z - p 0) / ((p 0 ^ 2 + p 1 ^ 2) * (p 0 * z + p 1))).re\n  convert (f.trans ff).closed_embedding.tendsto_cocompact.comp (tendsto_lc_row0 hp)\n  ext g\n  change\n    (Â«expr â€¢ Â» (g : Â«exprSL( , )Â» 2 â„¤) z).re =\n      lc_row0 p â†‘(â†‘g : Â«exprSL( , )Â» 2 (exprâ„)) / (p 0 ^ 2 + p 1 ^ 2) +\n        (((p 1 : exprâ„‚) * z - p 0) / ((p 0 ^ 2 + p 1 ^ 2) * (p 0 * z + p 1))).re\n  exact_mod_cast congr_arg complex.re (smul_eq_lc_row0_add z hp g.2)\n#align tendsto_abs_re_smul tendsto_abs_re_smul\n\n",
 "smul_eq_lc_row0_add":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„‚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„‚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„‚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ†‘â‚˜ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprSL( , )Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„‚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„‚ -/\n/-- This replaces `(gâ€¢z).re = a/c + *` in the standard theory with the following novel identity:\n  `g â€¢ z = (a c + b d) / (c^2 + d^2) + (d z - c) / ((c^2 + d^2) (c z + d))`\n  which does not need to be decomposed depending on whether `c = 0`. -/\ntheorem smul_eq_lc_row0_add {p : fin 2 â†’ â„¤} (hp : IsCoprime (p 0) (p 1)) (hg : (Â«exprâ†‘â‚˜ Â» g) 1 = p) :\n    â†‘(Â«expr â€¢ Â» g z) =\n      (lc_row0 p â†‘(g : Â«exprSL( , )Â» 2 (exprâ„)) : exprâ„‚) / (p 0 ^ 2 + p 1 ^ 2) +\n        ((p 1 : exprâ„‚) * z - p 0) / ((p 0 ^ 2 + p 1 ^ 2) * (p 0 * z + p 1)) :=\n  by\n  have nonZ1 : (p 0 : exprâ„‚) ^ 2 + p 1 ^ 2 â‰  0 := by exact_mod_cast hp.sq_add_sq_ne_zero\n  have : (coe : â„¤ â†’ exprâ„) âˆ˜ p â‰  0 := fun h => hp.ne_zero (by ext i <;> simpa using congr_fun h i)\n  have nonZ2 : (p 0 : exprâ„‚) * z + p 1 â‰  0 := by simpa using linear_ne_zero _ z this\n  field_simp [nonZ1, nonZ2, denom_ne_zero, -upper_half_plane.denom, -denom_apply]\n  rw [(by simp : (p 1 : exprâ„‚) * z - p 0 = (p 1 * z - p 0) * â†‘(det (â†‘g : matrix (fin 2) (fin 2) â„¤)))]\n  rw [â† hg, det_fin_two]\n  simp only [Int.coe_castRingHom, coe_matrix_coe, Int.cast_mul, of_real_int_cast, map_apply, denom, Int.cast_sub,\n    _root_.coe_coe, coe_GL_pos_coe_GL_coe_matrix]\n  ring\n#align smul_eq_lc_row0_add smul_eq_lc_row0_add\n\n",
 "re_T_zpow_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\ntheorem re_T_zpow_smul (n : â„¤) : (Â«expr â€¢ Â» (T ^ n) z).re = z.re + n := by\n  rw [â† coe_re, coe_T_zpow_smul_eq, add_re, int_cast_re, coe_re]\n#align re_T_zpow_smul re_T_zpow_smul\n\n",
 "re_T_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\ntheorem re_T_smul : (Â«expr â€¢ Â» T z).re = z.re + 1 := by simpa using re_T_zpow_smul z 1\n#align re_T_smul re_T_smul\n\n",
 "re_T_inv_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\ntheorem re_T_inv_smul : (Â«expr â€¢ Â» Tâ»Â¹ z).re = z.re - 1 := by simpa using re_T_zpow_smul z (-1)\n#align re_T_inv_smul re_T_inv_smul\n\n",
 "one_lt_norm_sq_T_zpow_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `modular_group.fdo -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `upper_half_plane -/\n/-- If `z âˆˆ ğ’Ÿáµ’`, and `n : â„¤`, then `|z + n| > 1`. -/\ntheorem one_lt_norm_sq_T_zpow_smul (hz : z âˆˆ modular_group.fdo) (n : â„¤) :\n    1 < norm_sq (Â«expr â€¢ Â» (T ^ n) z : upper_half_plane) :=\n  by\n  have hzâ‚ : 1 < z.re * z.re + z.im * z.im := hz.1\n  have hzn := Int.nneg_mul_add_sq_of_abs_le_one n (abs_two_mul_re_lt_one_of_mem_fdo hz).le\n  have : 1 < (z.re + â†‘n) * (z.re + â†‘n) + z.im * z.im := by linarith\n  simpa [coe_T_zpow, norm_sq]\n#align one_lt_norm_sq_T_zpow_smul one_lt_norm_sq_T_zpow_smul\n\n",
 "norm_sq_S_smul_lt_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/-- If `1 < |z|`, then `|S â€¢ z| < 1`. -/\ntheorem norm_sq_S_smul_lt_one (h : 1 < norm_sq z) : norm_sq â†‘(Â«expr â€¢ Â» S z) < 1 := by\n  simpa [coe_S] using (inv_lt_inv z.norm_sq_pos zero_lt_one).mpr h\n#align norm_sq_S_smul_lt_one norm_sq_S_smul_lt_one\n\n",
 "lc_row0_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n@[simp]\ntheorem lc_row0_apply (p : fin 2 â†’ â„¤) (g : matrix (fin 2) (fin 2) (exprâ„)) : lc_row0 p g = p 0 * g 0 0 + p 1 * g 0 1 :=\n  rfl\n#align lc_row0_apply lc_row0_apply\n\n",
 "im_lt_im_S_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„‚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/-- If `|z| < 1`, then applying `S` strictly decreases `im`. -/\ntheorem im_lt_im_S_smul (h : norm_sq z < 1) : z.im < (Â«expr â€¢ Â» S z).im :=\n  by\n  have : z.im < z.im / norm_sq (z : exprâ„‚) :=\n    by\n    have imz : 0 < z.im := im_pos z\n    apply (lt_div_iff z.norm_sq_pos).mpr\n    nlinarith\n  convert this\n  simp only [special_linear_group.im_smul_eq_div_norm_sq]\n  field_simp [norm_sq_denom_ne_zero, norm_sq_ne_zero, S]\n#align im_lt_im_S_smul im_lt_im_S_smul\n\n",
 "im_T_zpow_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\ntheorem im_T_zpow_smul (n : â„¤) : (Â«expr â€¢ Â» (T ^ n) z).im = z.im := by\n  rw [â† coe_im, coe_T_zpow_smul_eq, add_im, int_cast_im, add_zero, coe_im]\n#align im_T_zpow_smul im_T_zpow_smul\n\n",
 "im_T_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\ntheorem im_T_smul : (Â«expr â€¢ Â» T z).im = z.im := by simpa using im_T_zpow_smul z 1\n#align im_T_smul im_T_smul\n\n",
 "im_T_inv_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\ntheorem im_T_inv_smul : (Â«expr â€¢ Â» Tâ»Â¹ z).im = z.im := by simpa using im_T_zpow_smul z (-1)\n#align im_T_inv_smul im_T_inv_smul\n\n",
 "g_eq_of_c_eq_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ†‘â‚˜ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ†‘â‚˜ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ†‘â‚˜ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ†‘â‚˜ Â» -/\n/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:76:14: unsupported tactic `congrm #[[expr Â«expr!![ Â»(matrix.notation [expr _, \",\", expr _, \";\", expr _, \",\", expr _, \"]\"] [])]] -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ†‘â‚˜ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ†‘â‚˜ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ†‘â‚˜ Â» -/\n-- If `c = 1`, then `g` factorises into a product terms involving only `T` and `S`.\ntheorem g_eq_of_c_eq_one (hc : (Â«exprâ†‘â‚˜ Â» g) 1 0 = 1) : g = T ^ (Â«exprâ†‘â‚˜ Â» g) 0 0 * S * T ^ (Â«exprâ†‘â‚˜ Â» g) 1 1 :=\n  by\n  have hg := g.det_coe.symm\n  replace hg : (Â«exprâ†‘â‚˜ Â» g) 0 1 = (Â«exprâ†‘â‚˜ Â» g) 0 0 * (Â«exprâ†‘â‚˜ Â» g) 1 1 - 1;\n  Â· rw [det_fin_two, hc] at hg\n    linarith\n  refine' subtype.ext _\n  conv_lhs => rw [matrix.eta_fin_two (Â«exprâ†‘â‚˜ Â» g)]\n  rw [hc, hg]\n  simp only [coe_mul, coe_T_zpow, coe_S, mul_fin_two]\n  trace\n      \"./././Mathport/Syntax/Translate/Tactic/Builtin.lean:76:14: unsupported tactic `congrm #[[expr Â«expr!![ Â»(matrix.notation [expr _, \\\",\\\", expr _, \\\";\\\", expr _, \\\",\\\", expr _, \\\"]\\\"] [])]]\" <;>\n    ring\n#align g_eq_of_c_eq_one g_eq_of_c_eq_one\n\n",
 "exists_smul_mem_fd":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprSL( , )Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `upper_half_plane -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprSL( , )Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `modular_group.fd -/\n/-- Any `z : â„` can be moved to `ğ’Ÿ` by an element of `SL(2,â„¤)`  -/\ntheorem exists_smul_mem_fd (z : upper_half_plane) : âˆƒ g : Â«exprSL( , )Â» 2 â„¤, Â«expr â€¢ Â» g z âˆˆ modular_group.fd :=\n  by\n  -- obtain a gâ‚€ which maximizes im (g â€¢ z),\n  obtain âŸ¨gâ‚€, hgâ‚€âŸ© := exists_max_im z\n  -- then among those, minimize re\n  obtain âŸ¨g, hg, hg'âŸ© := exists_row_one_eq_and_min_re z (bottom_row_coprime gâ‚€)\n  refine' âŸ¨g, _âŸ©\n  -- `g` has same max im property as `gâ‚€`\n  have hgâ‚€' : âˆ€ g' : Â«exprSL( , )Â» 2 â„¤, (Â«expr â€¢ Â» g' z).im â‰¤ (Â«expr â€¢ Â» g z).im :=\n    by\n    have hg'' : (Â«expr â€¢ Â» g z).im = (Â«expr â€¢ Â» gâ‚€ z).im := by\n      rw [special_linear_group.im_smul_eq_div_norm_sq, special_linear_group.im_smul_eq_div_norm_sq, denom_apply,\n        denom_apply, hg]\n    simpa only [hg''] using hgâ‚€\n  constructor\n  Â· -- Claim: `1 â‰¤ â‡‘norm_sq â†‘(g â€¢ z)`. If not, then `Sâ€¢gâ€¢z` has larger imaginary part\n    contrapose! hgâ‚€'\n    refine' âŸ¨S * g, _âŸ©\n    rw [mul_smul]\n    exact im_lt_im_S_smul hgâ‚€'\n  Â· show |(Â«expr â€¢ Â» g z).re| â‰¤ 1 / 2\n    -- if not, then either `T` or `T'` decrease |Re|.\n    rw [abs_le]\n    constructor\n    Â· contrapose! hg'\n      refine' âŸ¨T * g, (T_mul_apply_one _).symm, _âŸ©\n      rw [mul_smul, re_T_smul]\n      cases abs_cases ((Â«expr â€¢ Â» g z).re + 1) <;> cases abs_cases (Â«expr â€¢ Â» g z).re <;> linarith\n    Â· contrapose! hg'\n      refine' âŸ¨Tâ»Â¹ * g, (T_inv_mul_apply_one _).symm, _âŸ©\n      rw [mul_smul, re_T_inv_smul]\n      cases abs_cases ((Â«expr â€¢ Â» g z).re - 1) <;> cases abs_cases (Â«expr â€¢ Â» g z).re <;> linarith\n#align exists_smul_mem_fd exists_smul_mem_fd\n\n",
 "exists_row_one_eq_and_min_re":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprSL( , )Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ†‘â‚˜ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprSL( , )Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ†‘â‚˜ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprSL( , )Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ†‘â‚˜ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprSL( , )Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ†‘â‚˜ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ†‘â‚˜ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/-- Given `z : â„` and a bottom row `(c,d)`, among the `g : SL(2,â„¤)` with this bottom row, minimize\n  `|(gâ€¢z).re|`.  -/\ntheorem exists_row_one_eq_and_min_re {cd : fin 2 â†’ â„¤} (hcd : IsCoprime (cd 0) (cd 1)) :\n    âˆƒ g : Â«exprSL( , )Â» 2 â„¤,\n      (Â«exprâ†‘â‚˜ Â» g) 1 = cd âˆ§\n        âˆ€ g' : Â«exprSL( , )Â» 2 â„¤, (Â«exprâ†‘â‚˜ Â» g) 1 = (Â«exprâ†‘â‚˜ Â» g') 1 â†’ |(Â«expr â€¢ Â» g z).re| â‰¤ |(Â«expr â€¢ Â» g' z).re| :=\n  by\n  haveI : nonempty { g : Â«exprSL( , )Â» 2 â„¤ // (Â«exprâ†‘â‚˜ Â» g) 1 = cd } :=\n    let âŸ¨x, hxâŸ© := bottom_row_surj hcd\n    âŸ¨âŸ¨x, hx.2âŸ©âŸ©\n  obtain âŸ¨g, hgâŸ© := filter.tendsto.exists_forall_le (tendsto_abs_re_smul z hcd)\n  refine' âŸ¨g, g.2, _âŸ©\n  Â· intro g1 hg1\n    have : g1 âˆˆ Â«expr â»Â¹' Â» (fun g : Â«exprSL( , )Â» 2 â„¤ => (Â«exprâ†‘â‚˜ Â» g) 1) {cd} :=\n      by\n      rw [Set.mem_preimage, Set.mem_singleton_iff]\n      exact eq.trans hg1.symm (set.mem_singleton_iff.mp (set.mem_preimage.mp g.2))\n    exact hg âŸ¨g1, thisâŸ©\n#align exists_row_one_eq_and_min_re exists_row_one_eq_and_min_re\n\n",
 "exists_max_im":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr![ ,]Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«expr![ ,]Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ†‘â‚˜ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprSL( , )Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprSL( , )Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/-- For `z : â„`, there is a `g : SL(2,â„¤)` maximizing `(gâ€¢z).im` -/\ntheorem exists_max_im : âˆƒ g : Â«exprSL( , )Â» 2 â„¤, âˆ€ g' : Â«exprSL( , )Â» 2 â„¤, (Â«expr â€¢ Â» g' z).im â‰¤ (Â«expr â€¢ Â» g z).im :=\n  by\n  classical\n    let s : set (fin 2 â†’ â„¤) := { cd | IsCoprime (cd 0) (cd 1) }\n    have hs : s.nonempty :=\n      âŸ¨Â«expr![ ,]Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«expr![ ,]Â»\",\n        isCoprime_one_leftâŸ©\n    obtain âŸ¨p, hp_coprime, hpâŸ© := filter.tendsto.exists_within_forall_le hs (tendsto_norm_sq_coprime_pair z)\n    obtain âŸ¨g, -, hgâŸ© := bottom_row_surj hp_coprime\n    refine' âŸ¨g, fun g' => _âŸ©\n    rw [special_linear_group.im_smul_eq_div_norm_sq, special_linear_group.im_smul_eq_div_norm_sq, div_le_div_left]\n    Â· simpa [â† hg] using hp ((Â«exprâ†‘â‚˜ Â» g') 1) (bottom_row_coprime g')\n    Â· exact z.im_pos\n    Â· exact norm_sq_denom_pos g' z\n    Â· exact norm_sq_denom_pos g z\n#align exists_max_im exists_max_im\n\n",
 "exists_eq_T_zpow_of_c_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ†‘â‚˜ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ†‘â‚˜ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ†‘â‚˜ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ†‘â‚˜ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ†‘â‚˜ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ†‘â‚˜ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ†‘â‚˜ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `upper_half_plane -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n-- If instead we had `g` and `T` of type `PSL(2, â„¤)`, then we could simply state `g = T^n`.\ntheorem exists_eq_T_zpow_of_c_eq_zero (hc : (Â«exprâ†‘â‚˜ Â» g) 1 0 = 0) :\n    âˆƒ n : â„¤, âˆ€ z : upper_half_plane, Â«expr â€¢ Â» g z = Â«expr â€¢ Â» (T ^ n) z :=\n  by\n  have had := g.det_coe\n  replace had : (Â«exprâ†‘â‚˜ Â» g) 0 0 * (Â«exprâ†‘â‚˜ Â» g) 1 1 = 1;\n  Â· rw [det_fin_two, hc] at had\n    linarith\n  rcases Int.eq_one_or_neg_one_of_mul_eq_one' had with (âŸ¨ha, hdâŸ© | âŸ¨ha, hdâŸ©)\n  Â· use (Â«exprâ†‘â‚˜ Â» g) 0 1\n    suffices g = T ^ (Â«exprâ†‘â‚˜ Â» g) 0 1 by\n      intro z\n      conv_lhs => rw [this]\n    ext (i j)\n    fin_cases i <;> fin_cases j <;> simp [ha, hc, hd, coe_T_zpow]\n  Â· use -(Â«exprâ†‘â‚˜ Â» g) 0 1\n    suffices g = -T ^ (-(Â«exprâ†‘â‚˜ Â» g) 0 1) by\n      intro z\n      conv_lhs => rw [this, SL_neg_smul]\n    ext (i j)\n    fin_cases i <;> fin_cases j <;> simp [ha, hc, hd, coe_T_zpow]\n#align exists_eq_T_zpow_of_c_eq_zero exists_eq_T_zpow_of_c_eq_zero\n\n",
 "eq_zero_of_mem_fdo_of_T_zpow_mem_fdo":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `modular_group.fdo -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `modular_group.fdo -/\ntheorem eq_zero_of_mem_fdo_of_T_zpow_mem_fdo {n : â„¤} (hz : z âˆˆ modular_group.fdo)\n    (hg : Â«expr â€¢ Â» (T ^ n) z âˆˆ modular_group.fdo) : n = 0 :=\n  by\n  suffices |(n : exprâ„)| < 1 by rwa [â† Int.cast_abs, â† Int.cast_one, Int.cast_lt, Int.abs_lt_one_iff] at this\n  have hâ‚ := hz.2\n  have hâ‚‚ := hg.2\n  rw [re_T_zpow_smul] at hâ‚‚\n  calc\n    |(n : exprâ„)| â‰¤ |z.re| + |z.re + (n : exprâ„)| := abs_add' (n : exprâ„) z.re\n    _ < 1 / 2 + 1 / 2 := add_lt_add hâ‚ hâ‚‚\n    _ = 1 := add_halves 1\n    \n#align eq_zero_of_mem_fdo_of_T_zpow_mem_fdo eq_zero_of_mem_fdo_of_T_zpow_mem_fdo\n\n",
 "eq_smul_self_of_mem_fdo_mem_fdo":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `modular_group.fdo -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `modular_group.fdo -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/-- Second Main Fundamental Domain Lemma: if both `z` and `g â€¢ z` are in the open domain `ğ’Ÿáµ’`,\nwhere `z : â„` and `g : SL(2,â„¤)`, then `z = g â€¢ z`. -/\ntheorem eq_smul_self_of_mem_fdo_mem_fdo (hz : z âˆˆ modular_group.fdo) (hg : Â«expr â€¢ Â» g z âˆˆ modular_group.fdo) :\n    z = Â«expr â€¢ Â» g z := by\n  obtain âŸ¨n, hnâŸ© := exists_eq_T_zpow_of_c_eq_zero (c_eq_zero hz hg)\n  rw [hn] at hgâŠ¢\n  simp [eq_zero_of_mem_fdo_of_T_zpow_mem_fdo hz hg, one_smul]\n#align eq_smul_self_of_mem_fdo_mem_fdo eq_smul_self_of_mem_fdo_mem_fdo\n\n",
 "coe_T_zpow_smul_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„‚ -/\ntheorem coe_T_zpow_smul_eq {n : â„¤} : (â†‘(Â«expr â€¢ Â» (T ^ n) z) : exprâ„‚) = z + n := by simp [coe_T_zpow]\n#align coe_T_zpow_smul_eq coe_T_zpow_smul_eq\n\n",
 "coe_T_zpow":
 "/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:76:14: unsupported tactic `congrm #[[expr Â«expr!![ Â»(matrix.notation [expr _, \",\", expr _, \";\", expr _, \",\", expr _, \"]\"] [])]] -/\n/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:76:14: unsupported tactic `congrm #[[expr Â«expr!![ Â»(matrix.notation [expr _, \",\", expr _, \";\", expr _, \",\", expr _, \"]\"] [])]] -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ†‘â‚˜ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr!![ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:390:14: unsupported user notation matrix.notation -/\ntheorem coe_T_zpow (n : â„¤) :\n    Â«exprâ†‘â‚˜ Â» (T ^ n) =\n      Â«expr!![ Â» \"./././Mathport/Syntax/Translate/Expr.lean:390:14: unsupported user notation matrix.notation\" :=\n  by\n  induction' n using int.induction_on with n h n h\n  Â· rw [zpow_zero, coe_one, matrix.one_fin_two]\n  Â· simp_rw [zpow_add, zpow_one, coe_mul, h, coe_T, matrix.mul_fin_two]\n    trace\n      \"./././Mathport/Syntax/Translate/Tactic/Builtin.lean:76:14: unsupported tactic `congrm #[[expr Â«expr!![ Â»(matrix.notation [expr _, \\\",\\\", expr _, \\\";\\\", expr _, \\\",\\\", expr _, \\\"]\\\"] [])]]\"\n    rw [mul_one, mul_one, add_comm]\n  Â· simp_rw [zpow_sub, zpow_one, coe_mul, h, coe_T_inv, matrix.mul_fin_two]\n    trace\n        \"./././Mathport/Syntax/Translate/Tactic/Builtin.lean:76:14: unsupported tactic `congrm #[[expr Â«expr!![ Â»(matrix.notation [expr _, \\\",\\\", expr _, \\\";\\\", expr _, \\\",\\\", expr _, \\\"]\\\"] [])]]\" <;>\n      ring\n#align coe_T_zpow coe_T_zpow\n\n",
 "coe_T_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ†‘â‚˜ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr!![ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:390:14: unsupported user notation matrix.notation -/\ntheorem coe_T_inv :\n    Â«exprâ†‘â‚˜ Â» Tâ»Â¹ =\n      Â«expr!![ Â» \"./././Mathport/Syntax/Translate/Expr.lean:390:14: unsupported user notation matrix.notation\" :=\n  by simp [coe_inv, coe_T, adjugate_fin_two]\n#align coe_T_inv coe_T_inv\n\n",
 "coe_T":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ†‘â‚˜ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr!![ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:390:14: unsupported user notation matrix.notation -/\ntheorem coe_T :\n    Â«exprâ†‘â‚˜ Â» T =\n      Â«expr!![ Â» \"./././Mathport/Syntax/Translate/Expr.lean:390:14: unsupported user notation matrix.notation\" :=\n  rfl\n#align coe_T coe_T\n\n",
 "coe_S":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ†‘â‚˜ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr!![ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:390:14: unsupported user notation matrix.notation -/\ntheorem coe_S :\n    Â«exprâ†‘â‚˜ Â» S =\n      Â«expr!![ Â» \"./././Mathport/Syntax/Translate/Expr.lean:390:14: unsupported user notation matrix.notation\" :=\n  rfl\n#align coe_S coe_S\n\n",
 "c_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprSL( , )Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `modular_group.fdo -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ†‘â‚˜ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ†‘â‚˜ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ†‘â‚˜ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ†‘â‚˜ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ†‘â‚˜ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `modular_group.fdo -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `modular_group.fdo -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `modular_group.fdo -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ†‘â‚˜ Â» -/\n/-- An auxiliary result en route to `modular_group.eq_smul_self_of_mem_fdo_mem_fdo`. -/\ntheorem c_eq_zero (hz : z âˆˆ modular_group.fdo) (hg : Â«expr â€¢ Â» g z âˆˆ modular_group.fdo) : (Â«exprâ†‘â‚˜ Â» g) 1 0 = 0 :=\n  by\n  have hp : âˆ€ {g' : Â«exprSL( , )Â» 2 â„¤} (hg' : Â«expr â€¢ Â» g' z âˆˆ modular_group.fdo), (Â«exprâ†‘â‚˜ Â» g') 1 0 â‰  1 :=\n    by\n    intros\n    by_contra hc\n    let a := (Â«exprâ†‘â‚˜ Â» g') 0 0\n    let d := (Â«exprâ†‘â‚˜ Â» g') 1 1\n    have had : T ^ (-a) * g' = S * T ^ d := by\n      rw [g_eq_of_c_eq_one hc]\n      group\n    let w := Â«expr â€¢ Â» (T ^ (-a)) (Â«expr â€¢ Â» g' z)\n    have hâ‚ : w = Â«expr â€¢ Â» S (Â«expr â€¢ Â» (T ^ d) z) := by simp only [w, â† mul_smul, had]\n    replace hâ‚ : norm_sq w < 1 := hâ‚.symm â–¸ norm_sq_S_smul_lt_one (one_lt_norm_sq_T_zpow_smul hz d)\n    have hâ‚‚ : 1 < norm_sq w := one_lt_norm_sq_T_zpow_smul hg' (-a)\n    linarith\n  have hn : (Â«exprâ†‘â‚˜ Â» g) 1 0 â‰  -1 := by\n    intro hc\n    replace hc : (Â«exprâ†‘â‚˜ Â» (-g)) 1 0 = 1\n    Â· simp [eq_neg_of_eq_neg hc]\n    replace hg : Â«expr â€¢ Â» (-g) z âˆˆ modular_group.fdo := (SL_neg_smul g z).symm â–¸ hg\n    exact hp hg hc\n  specialize hp hg\n  rcases int.abs_le_one_iff.mp <| abs_c_le_one hz hg with âŸ¨âŸ© <;> tauto\n#align c_eq_zero c_eq_zero\n\n",
 "bottom_row_surj":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr![ ,]Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«expr![ ,]Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprSL( , )Â» -/\n/-- Every pair `![c, d]` of coprime integers is the \"bottom_row\" of some element `g=[[*,*],[c,d]]`\nof `SL(2,â„¤)`. -/\ntheorem bottom_row_surj {R : Type _} [CommRing R] :\n    Set.SurjOn (fun g : Â«exprSL( , )Â» 2 R => @coe _ (matrix (fin 2) (fin 2) R) _ g 1) Set.univ\n      { cd | IsCoprime (cd 0) (cd 1) } :=\n  by\n  rintro cd âŸ¨bâ‚€, a, gcd_eqnâŸ©\n  let A := of (Â«expr![ ,]Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«expr![ ,]Â»\")\n  have det_A_1 : det A = 1 := by\n    convert gcd_eqn\n    simp [A, det_fin_two, (by ring : a * cd 1 + bâ‚€ * cd 0 = bâ‚€ * cd 0 + a * cd 1)]\n  refine' âŸ¨âŸ¨A, det_A_1âŸ©, Set.mem_univ _, _âŸ©\n  ext <;> simp [A]\n#align bottom_row_surj bottom_row_surj\n\n",
 "bottom_row_coprime":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprSL( , )Â» -/\n/-\nCopyright (c) 2021 Alex Kontorovich and Heather Macbeth and Marc Masdeu. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Alex Kontorovich, Heather Macbeth, Marc Masdeu\n-/\n/- Disable these instances as they are not the simp-normal form, and having them disabled ensures\nwe state lemmas in this file without spurious `coe_fn` terms. -/\n/-- The two numbers `c`, `d` in the \"bottom_row\" of `g=[[*,*],[c,d]]` in `SL(2, â„¤)` are coprime. -/\ntheorem bottom_row_coprime {R : Type _} [CommRing R] (g : Â«exprSL( , )Â» 2 R) :\n    IsCoprime ((â†‘g : matrix (fin 2) (fin 2) R) 1 0) ((â†‘g : matrix (fin 2) (fin 2) R) 1 1) :=\n  by\n  use -(â†‘g : matrix (fin 2) (fin 2) R) 0 1, (â†‘g : matrix (fin 2) (fin 2) R) 0 0\n  rw [add_comm, neg_mul, â† sub_eq_add_neg, â† det_fin_two]\n  exact g.det_coe\n#align bottom_row_coprime bottom_row_coprime\n\n",
 "abs_two_mul_re_lt_one_of_mem_fdo":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `modular_group.fdo -/\ntheorem abs_two_mul_re_lt_one_of_mem_fdo (h : z âˆˆ modular_group.fdo) : |2 * z.re| < 1 :=\n  by\n  rw [abs_mul, abs_two, â† lt_div_iff' (zero_lt_two' (exprâ„))]\n  exact h.2\n#align abs_two_mul_re_lt_one_of_mem_fdo abs_two_mul_re_lt_one_of_mem_fdo\n\n",
 "abs_c_le_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ†‘â‚˜ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `modular_group.fdo -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `modular_group.fdo -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ†‘â‚˜ Â» -/\n/-- An auxiliary result en route to `modular_group.c_eq_zero`. -/\ntheorem abs_c_le_one (hz : z âˆˆ modular_group.fdo) (hg : Â«expr â€¢ Â» g z âˆˆ modular_group.fdo) : |(Â«exprâ†‘â‚˜ Â» g) 1 0| â‰¤ 1 :=\n  by\n  let c' : â„¤ := (Â«exprâ†‘â‚˜ Â» g) 1 0\n  let c : exprâ„ := (c' : exprâ„)\n  suffices 3 * c ^ 2 < 4\n    by\n    rw [â† Int.cast_pow, â† Int.cast_three, â† Int.cast_four, â† Int.cast_mul, Int.cast_lt] at this\n    replace this : c' ^ 2 â‰¤ 1 ^ 2\n    Â· linarith\n    rwa [sq_le_sq, abs_one] at this\n  suffices c â‰  0 â†’ 9 * c ^ 4 < 16 by\n    rcases eq_or_ne c 0 with (hc | hc)\n    Â· rw [hc]\n      norm_num\n    Â· refine' (abs_lt_of_sq_lt_sq' _ (by norm_num)).2\n      specialize this hc\n      linarith\n  intro hc\n  replace hc : 0 < c ^ 4\n  Â· rw [pow_bit0_pos_iff] <;> trivial\n  have hâ‚ :=\n    mul_lt_mul_of_pos_right\n      (mul_lt_mul'' (three_lt_four_mul_im_sq_of_mem_fdo hg) (three_lt_four_mul_im_sq_of_mem_fdo hz) (by linarith)\n        (by linarith))\n      hc\n  have hâ‚‚ : (c * z.im) ^ 4 / norm_sq (denom (â†‘g) z) ^ 2 â‰¤ 1 :=\n    div_le_one_of_le (pow_four_le_pow_two_of_pow_two_le (upper_half_plane.c_mul_im_sq_le_norm_sq_denom z g))\n      (sq_nonneg _)\n  let nsq := norm_sq (denom g z)\n  calc\n    9 * c ^ 4 < c ^ 4 * z.im ^ 2 * (Â«expr â€¢ Â» g z).im ^ 2 * 16 := by linarith\n    _ = c ^ 4 * z.im ^ 4 / nsq ^ 2 * 16 :=\n      by\n      rw [special_linear_group.im_smul_eq_div_norm_sq, div_pow]\n      ring\n    _ â‰¤ 16 := by\n      rw [â† mul_pow]\n      linarith\n    \n#align abs_c_le_one abs_c_le_one\n\n",
 "T_pow_mul_apply_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprSL( , )Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ†‘â‚˜ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ†‘â‚˜ Â» -/\n@[simp]\ntheorem T_pow_mul_apply_one (n : â„¤) (g : Â«exprSL( , )Â» 2 â„¤) : (Â«exprâ†‘â‚˜ Â» (T ^ n * g)) 1 = (Â«exprâ†‘â‚˜ Â» g) 1 := by\n  simp [coe_T_zpow, matrix.mul, matrix.dot_product, fin.sum_univ_succ]\n#align T_pow_mul_apply_one T_pow_mul_apply_one\n\n",
 "T_mul_apply_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprSL( , )Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ†‘â‚˜ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ†‘â‚˜ Â» -/\n@[simp]\ntheorem T_mul_apply_one (g : Â«exprSL( , )Â» 2 â„¤) : (Â«exprâ†‘â‚˜ Â» (T * g)) 1 = (Â«exprâ†‘â‚˜ Â» g) 1 := by\n  simpa using T_pow_mul_apply_one 1 g\n#align T_mul_apply_one T_mul_apply_one\n\n",
 "T_inv_mul_apply_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprSL( , )Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ†‘â‚˜ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ†‘â‚˜ Â» -/\n@[simp]\ntheorem T_inv_mul_apply_one (g : Â«exprSL( , )Â» 2 â„¤) : (Â«exprâ†‘â‚˜ Â» (Tâ»Â¹ * g)) 1 = (Â«exprâ†‘â‚˜ Â» g) 1 := by\n  simpa using T_pow_mul_apply_one (-1) g\n#align T_inv_mul_apply_one T_inv_mul_apply_one\n\n"}