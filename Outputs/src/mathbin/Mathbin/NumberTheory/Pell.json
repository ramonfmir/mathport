{"y_pow_succ_pos":
 "/-- If `(x, y)` is a solution with `x` and `y` positive, then all its powers with positive\nnatural exponents have positive `y`. -/\ntheorem y_pow_succ_pos {a : solution₁ d} (hax : 0 < a.x) (hay : 0 < a.y) (n : ℕ) : 0 < (a ^ n.succ).y :=\n  by\n  induction' n with n ih\n  · simp only [hay, pow_one]\n  · rw [pow_succ]\n    exact y_mul_pos hax hay (x_pow_pos hax _) ih\n#align y_pow_succ_pos y_pow_succ_pos\n\n",
 "y_one":
 "@[simp]\ntheorem y_one : (1 : solution₁ d).y = 0 :=\n  rfl\n#align y_one y_one\n\n",
 "y_neg":
 "@[simp]\ntheorem y_neg (a : solution₁ d) : (-a).y = -a.y :=\n  rfl\n#align y_neg y_neg\n\n",
 "y_ne_zero_of_one_lt_x":
 "/-- A solution with `x > 1` must have `y ≠ 0`. -/\ntheorem y_ne_zero_of_one_lt_x {a : solution₁ d} (ha : 1 < a.x) : a.y ≠ 0 :=\n  by\n  intro hy\n  have prop := a.prop\n  rw [hy, sq (0 : ℤ), MulZeroClass.zero_mul, MulZeroClass.mul_zero, sub_zero] at prop\n  exact lt_irrefl _ (((one_lt_sq_iff <| zero_le_one.trans ha.le).mpr ha).trans_eq prop)\n#align y_ne_zero_of_one_lt_x y_ne_zero_of_one_lt_x\n\n",
 "y_mul_pos":
 "/-- The set of solutions with `x` and `y` positive is closed under multiplication. -/\ntheorem y_mul_pos {a b : solution₁ d} (hax : 0 < a.x) (hay : 0 < a.y) (hbx : 0 < b.x) (hby : 0 < b.y) : 0 < (a * b).y :=\n  by\n  simp only [y_mul]\n  positivity\n#align y_mul_pos y_mul_pos\n\n",
 "y_mul":
 "@[simp]\ntheorem y_mul (a b : solution₁ d) : (a * b).y = a.x * b.y + a.y * b.x :=\n  rfl\n#align y_mul y_mul\n\n",
 "y_mk":
 "@[simp]\ntheorem y_mk (x y : ℤ) (prop : x ^ 2 - d * y ^ 2 = 1) : (mk x y prop).y = y :=\n  rfl\n#align y_mk y_mk\n\n",
 "y_inv":
 "@[simp]\ntheorem y_inv (a : solution₁ d) : a⁻¹.y = -a.y :=\n  rfl\n#align y_inv y_inv\n\n",
 "x_zpow_pos":
 "/-- If `(x, y)` is a solution with `x` positive, then all its powers have positive `x`. -/\ntheorem x_zpow_pos {a : solution₁ d} (hax : 0 < a.x) (n : ℤ) : 0 < (a ^ n).x :=\n  by\n  cases n\n  · rw [zpow_ofNat]\n    exact x_pow_pos hax n\n  · rw [zpow_negSucc]\n    exact x_pow_pos hax (n + 1)\n#align x_zpow_pos x_zpow_pos\n\n",
 "x_pow_pos":
 "/-- If `(x, y)` is a solution with `x` positive, then all its powers with natural exponents\nhave positive `x`. -/\ntheorem x_pow_pos {a : solution₁ d} (hax : 0 < a.x) (n : ℕ) : 0 < (a ^ n).x :=\n  by\n  induction' n with n ih\n  · simp only [pow_zero, x_one, zero_lt_one]\n  · rw [pow_succ]\n    exact x_mul_pos hax ih\n#align x_pow_pos x_pow_pos\n\n",
 "x_one":
 "@[simp]\ntheorem x_one : (1 : solution₁ d).x = 1 :=\n  rfl\n#align x_one x_one\n\n",
 "x_neg":
 "@[simp]\ntheorem x_neg (a : solution₁ d) : (-a).x = -a.x :=\n  rfl\n#align x_neg x_neg\n\n",
 "x_ne_zero":
 "/-- A solution has `x ≠ 0`. -/\ntheorem x_ne_zero (h₀ : 0 ≤ d) (a : solution₁ d) : a.x ≠ 0 :=\n  by\n  intro hx\n  have h : 0 ≤ d * a.y ^ 2 := mul_nonneg h₀ (sq_nonneg _)\n  rw [a.prop_y, hx, sq, MulZeroClass.zero_mul, zero_sub] at h\n  exact not_le.mpr (neg_one_lt_zero : (-1 : ℤ) < 0) h\n#align x_ne_zero x_ne_zero\n\n",
 "x_mul_pos":
 "/-- The set of solutions with `x > 0` is closed under multiplication. -/\ntheorem x_mul_pos {a b : solution₁ d} (ha : 0 < a.x) (hb : 0 < b.x) : 0 < (a * b).x :=\n  by\n  simp only [x_mul]\n  refine' neg_lt_iff_pos_add'.mp (abs_lt.mp _).1\n  rw [← abs_of_pos ha, ← abs_of_pos hb, ← abs_mul, ← sq_lt_sq, mul_pow a.x, a.prop_x, b.prop_x, ← sub_pos]\n  ring_nf\n  cases' le_or_lt 0 d with h h\n  · positivity\n  · rw [(eq_zero_of_d_neg h a).resolve_left ha.ne', (eq_zero_of_d_neg h b).resolve_left hb.ne', zero_pow two_pos,\n      zero_add, MulZeroClass.zero_mul, zero_add]\n    exact one_pos\n#align x_mul_pos x_mul_pos\n\n",
 "x_mul":
 "@[simp]\ntheorem x_mul (a b : solution₁ d) : (a * b).x = a.x * b.x + d * (a.y * b.y) :=\n  by\n  rw [← mul_assoc]\n  rfl\n#align x_mul x_mul\n\n",
 "x_mk":
 "@[simp]\ntheorem x_mk (x y : ℤ) (prop : x ^ 2 - d * y ^ 2 = 1) : (mk x y prop).x = x :=\n  rfl\n#align x_mk x_mk\n\n",
 "x_inv":
 "@[simp]\ntheorem x_inv (a : solution₁ d) : a⁻¹.x = a.x :=\n  rfl\n#align x_inv x_inv\n\n",
 "sign_y_zpow_eq_sign_of_x_pos_of_y_pos":
 "/-- If `(x, y)` is a solution with `x` and `y` positive, then the `y` component of any power\nhas the same sign as the exponent. -/\ntheorem sign_y_zpow_eq_sign_of_x_pos_of_y_pos {a : solution₁ d} (hax : 0 < a.x) (hay : 0 < a.y) (n : ℤ) :\n    (a ^ n).y.sign = n.sign := by\n  rcases n with ((_ | _) | _)\n  · rfl\n  · rw [zpow_ofNat]\n    exact int.sign_eq_one_of_pos (y_pow_succ_pos hax hay n)\n  · rw [zpow_negSucc]\n    exact int.sign_eq_neg_one_of_neg (neg_neg_of_pos (y_pow_succ_pos hax hay n))\n#align sign_y_zpow_eq_sign_of_x_pos_of_y_pos sign_y_zpow_eq_sign_of_x_pos_of_y_pos\n\n",
 "prop_y":
 "/-- An alternative form of the equation, suitable for rewriting `d * y^2`. -/\ntheorem prop_y (a : solution₁ d) : d * a.y ^ 2 = a.x ^ 2 - 1 :=\n  by\n  rw [← a.prop]\n  ring\n#align prop_y prop_y\n\n",
 "prop_x":
 "/-- An alternative form of the equation, suitable for rewriting `x^2`. -/\ntheorem prop_x (a : solution₁ d) : a.x ^ 2 = 1 + d * a.y ^ 2 :=\n  by\n  rw [← a.prop]\n  ring\n#align prop_x prop_x\n\n",
 "prop":
 "-- We use `solution₁ d` to allow for a more general structure `solution d m` that\n-- encodes solutions to `x^2 - d*y^2 = m` to be added later.\n/-- The proof that `a` is a solution to the Pell equation `x^2 - d*y^2 = 1` -/\ntheorem prop (a : solution₁ d) : a.x ^ 2 - d * a.y ^ 2 = 1 :=\n  is_pell_solution_iff_mem_unitary.mpr a.property\n#align prop prop\n\n",
 "is_pell_solution_iff_mem_unitary":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ√ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ√ » -/\n/-\nCopyright (c) 2023 Michael Stoll. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Michael Geißer, Michael Stoll\n-/\n/-- An element of `ℤ√d` has norm one (i.e., `a.re^2 - d*a.im^2 = 1`) if and only if\nit is contained in the submonoid of unitary elements.\n\nTODO: merge this result with `pell.is_pell_iff_mem_unitary`. -/\ntheorem is_pell_solution_iff_mem_unitary {d : ℤ} {a : «exprℤ√ » d} :\n    a.re ^ 2 - d * a.im ^ 2 = 1 ↔ a ∈ unitary («exprℤ√ » d) := by\n  rw [← norm_eq_one_iff_mem_unitary, norm_def, sq, sq, ← mul_assoc]\n#align is_pell_solution_iff_mem_unitary is_pell_solution_iff_mem_unitary\n\n",
 "ext":
 "/-- Two solutions are equal if their `x` and `y` components are equal. -/\n@[ext]\ntheorem ext {a b : solution₁ d} (hx : a.x = b.x) (hy : a.y = b.y) : a = b :=\n  Subtype.ext <| ext.mpr ⟨hx, hy⟩\n#align ext ext\n\n",
 "exists_pos_variant":
 "/-- If `a` is any solution, then one of `a`, `a⁻¹`, `-a`, `-a⁻¹` has\npositive `x` and nonnegative `y`. -/\ntheorem exists_pos_variant (h₀ : 0 < d) (a : solution₁ d) :\n    ∃ b : solution₁ d, 0 < b.x ∧ 0 ≤ b.y ∧ a ∈ ({b, b⁻¹, -b, -b⁻¹} : Set (solution₁ d)) := by\n  refine'\n        (lt_or_gt_of_ne (a.x_ne_zero h₀.le)).elim\n          ((le_total 0 a.y).elim (fun hy hx => ⟨-a⁻¹, _, _, _⟩) fun hy hx => ⟨-a, _, _, _⟩)\n          ((le_total 0 a.y).elim (fun hy hx => ⟨a, hx, hy, _⟩) fun hy hx => ⟨a⁻¹, hx, _, _⟩) <;>\n      simp only [neg_neg, inv_inv, neg_inv, Set.mem_insert_iff, Set.mem_singleton_iff, true_or_iff, eq_self_iff_true,\n        x_neg, x_inv, y_neg, y_inv, neg_pos, neg_nonneg, or_true_iff] <;>\n    assumption\n#align exists_pos_variant exists_pos_variant\n\n",
 "exists_pos_of_not_is_square":
 "/-- If `d` is a positive integer that is not a square, then there exists a solution\nto the Pell equation `x^2 - d*y^2 = 1` with `x > 1` and `y > 0`. -/\ntheorem exists_pos_of_not_is_square (h₀ : 0 < d) (hd : ¬IsSquare d) : ∃ a : solution₁ d, 1 < a.x ∧ 0 < a.y :=\n  by\n  obtain ⟨x, y, h, hy⟩ := exists_of_not_is_square h₀ hd\n  refine' ⟨mk (|x|) (|y|) (by rwa [sq_abs, sq_abs]), _, abs_pos.mpr hy⟩\n  rw [x_mk, ← one_lt_sq_iff_one_lt_abs, eq_add_of_sub_eq h, lt_add_iff_pos_right]\n  exact mul_pos h₀ (sq_pos_of_ne_zero y hy)\n#align exists_pos_of_not_is_square exists_pos_of_not_is_square\n\n",
 "exists_of_not_is_square":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/-- If `d` is a positive integer that is not a square, then there is a nontrivial solution\nto the Pell equation `x^2 - d*y^2 = 1`. -/\ntheorem exists_of_not_is_square (h₀ : 0 < d) (hd : ¬IsSquare d) : ∃ x y : ℤ, x ^ 2 - d * y ^ 2 = 1 ∧ y ≠ 0 :=\n  by\n  let ξ : exprℝ := sqrt d\n  have hξ : irrational ξ :=\n    by\n    refine' irrational_nrt_of_notint_nrt 2 d (sq_sqrt <| int.cast_nonneg.mpr h₀.le) _ two_pos\n    rintro ⟨x, hx⟩\n    refine' hd ⟨x, @Int.cast_injective (exprℝ) _ _ d (x * x) _⟩\n    rw [← sq_sqrt <| int.cast_nonneg.mpr h₀.le, Int.cast_mul, ← hx, sq]\n  obtain ⟨M, hM₁⟩ := exists_int_gt (2 * |ξ| + 1)\n  have hM : { q : exprℚ | |q.1 ^ 2 - d * q.2 ^ 2| < M }.infinite :=\n    by\n    refine' infinite.mono (fun q h => _) (infinite_rat_abs_sub_lt_one_div_denom_sq_of_irrational hξ)\n    have h0 : 0 < (q.2 : exprℝ) ^ 2 := pow_pos (nat.cast_pos.mpr q.pos) 2\n    have h1 : (q.num : exprℝ) / (q.denom : exprℝ) = q := by exact_mod_cast q.num_div_denom\n    rw [mem_set_of, abs_sub_comm, ← @Int.cast_lt (exprℝ), ← div_lt_div_right (abs_pos_of_pos h0)]\n    push_cast\n    rw [← abs_div, abs_sq, sub_div, mul_div_cancel _ h0.ne', ← div_pow, h1, ← sq_sqrt (int.cast_pos.mpr h₀).le,\n      sq_sub_sq, abs_mul, ← mul_one_div]\n    refine' mul_lt_mul'' (((abs_add ξ q).trans _).trans_lt hM₁) h (abs_nonneg _) (abs_nonneg _)\n    rw [two_mul, add_assoc, add_le_add_iff_left, ← sub_le_iff_le_add']\n    rw [mem_set_of, abs_sub_comm] at h\n    refine' (abs_sub_abs_le_abs_sub (q : exprℝ) ξ).trans (h.le.trans _)\n    rw [div_le_one h0, one_le_sq_iff_one_le_abs, Nat.abs_cast, Nat.one_le_cast]\n    exact q.pos\n  obtain ⟨m, hm⟩ : ∃ m : ℤ, { q : exprℚ | q.1 ^ 2 - d * q.2 ^ 2 = m }.infinite :=\n    by\n    contrapose! hM\n    simp only [not_infinite] at hM⊢\n    refine' (congr_arg _ (ext fun x => _)).mp (finite.bUnion (finite_Ioo (-M) M) fun m _ => hM m)\n    simp only [abs_lt, mem_set_of_eq, mem_Ioo, mem_Union, exists_prop, exists_eq_right']\n  have hm₀ : m ≠ 0 := by\n    rintro rfl\n    obtain ⟨q, hq⟩ := hm.nonempty\n    rw [mem_set_of, sub_eq_zero, mul_comm] at hq\n    obtain ⟨a, ha⟩ := (Int.pow_dvd_pow_iff two_pos).mp ⟨d, hq⟩\n    rw [ha, mul_pow, mul_right_inj' (pow_pos (int.coe_nat_pos.mpr q.pos) 2).ne'] at hq\n    exact hd ⟨a, sq a ▸ hq.symm⟩\n  haveI := ne_zero_iff.mpr (int.nat_abs_ne_zero.mpr hm₀)\n  let f : exprℚ → ZMod m.nat_abs × ZMod m.nat_abs := fun q => (q.1, q.2)\n  obtain ⟨q₁, h₁ : q₁.1 ^ 2 - d * q₁.2 ^ 2 = m, q₂, h₂ : q₂.1 ^ 2 - d * q₂.2 ^ 2 = m, hne, hqf⟩ :=\n    hm.exists_ne_map_eq_of_maps_to (maps_to_univ f _) finite_univ\n  obtain ⟨hq1 : (q₁.1 : ZMod m.nat_abs) = q₂.1, hq2 : (q₁.2 : ZMod m.nat_abs) = q₂.2⟩ := prod.ext_iff.mp hqf\n  have hd₁ : m ∣ q₁.1 * q₂.1 - d * (q₁.2 * q₂.2) :=\n    by\n    rw [← Int.natAbs_dvd, ← ZMod.int_cast_zmod_eq_zero_iff_dvd]\n    push_cast\n    rw [hq1, hq2, ← sq, ← sq]\n    norm_cast\n    rw [ZMod.int_cast_zmod_eq_zero_iff_dvd, Int.natAbs_dvd, Nat.cast_pow, ← h₂]\n  have hd₂ : m ∣ q₁.1 * q₂.2 - q₂.1 * q₁.2 :=\n    by\n    rw [← Int.natAbs_dvd, ← ZMod.int_cast_eq_int_cast_iff_dvd_sub]\n    push_cast\n    rw [hq1, hq2]\n  replace hm₀ : (m : exprℚ) ≠ 0 := int.cast_ne_zero.mpr hm₀\n  refine' ⟨(q₁.1 * q₂.1 - d * (q₁.2 * q₂.2)) / m, (q₁.1 * q₂.2 - q₂.1 * q₁.2) / m, _, _⟩\n  · qify [hd₁, hd₂]\n    field_simp [hm₀]\n    norm_cast\n    conv_rhs =>\n      congr\n      rw [sq]\n      congr\n      rw [← h₁]\n      skip\n      rw [← h₂]\n    push_cast\n    ring\n  · qify [hd₂]\n    refine' div_ne_zero_iff.mpr ⟨_, hm₀⟩\n    exact_mod_cast mt sub_eq_zero.mp (mt rat.eq_iff_mul_eq_mul.mpr hne)\n#align exists_of_not_is_square exists_of_not_is_square\n\n",
 "exists_nontrivial_of_not_is_square":
 "/-- If `d` is a positive integer that is not a square, then there exists a nontrivial solution\nto the Pell equation `x^2 - d*y^2 = 1`. -/\ntheorem exists_nontrivial_of_not_is_square (h₀ : 0 < d) (hd : ¬IsSquare d) : ∃ a : solution₁ d, a ≠ 1 ∧ a ≠ -1 :=\n  by\n  obtain ⟨x, y, prop, hy⟩ := exists_of_not_is_square h₀ hd\n  refine' ⟨mk x y prop, fun H => _, fun H => _⟩ <;> apply_fun solution₁.y  at H <;> simpa only [hy] using H\n#align exists_nontrivial_of_not_is_square exists_nontrivial_of_not_is_square\n\n",
 "exists_iff_not_is_square":
 "/-- If `d` is a positive integer, then there is a nontrivial solution\nto the Pell equation `x^2 - d*y^2 = 1` if and only if `d` is not a square. -/\ntheorem exists_iff_not_is_square (h₀ : 0 < d) : (∃ x y : ℤ, x ^ 2 - d * y ^ 2 = 1 ∧ y ≠ 0) ↔ ¬IsSquare d :=\n  by\n  refine' ⟨_, exists_of_not_is_square h₀⟩\n  rintro ⟨x, y, hxy, hy⟩ ⟨a, rfl⟩\n  rw [← sq, ← mul_pow, sq_sub_sq] at hxy\n  simpa [mul_self_pos.mp h₀, sub_eq_add_neg, eq_neg_self_iff] using Int.eq_of_mul_eq_one hxy\n#align exists_iff_not_is_square exists_iff_not_is_square\n\n",
 "eq_zero_of_d_neg":
 "/-- When `d` is negative, then `x` or `y` must be zero in a solution. -/\ntheorem eq_zero_of_d_neg (h₀ : d < 0) (a : solution₁ d) : a.x = 0 ∨ a.y = 0 :=\n  by\n  have h := a.prop\n  contrapose! h\n  have h1 := sq_pos_of_ne_zero a.x h.1\n  have h2 := sq_pos_of_ne_zero a.y h.2\n  nlinarith\n#align eq_zero_of_d_neg eq_zero_of_d_neg\n\n",
 "eq_one_or_neg_one_iff_y_eq_zero":
 "/-- A solution is `1` or `-1` if and only if `y = 0`. -/\ntheorem eq_one_or_neg_one_iff_y_eq_zero {a : solution₁ d} : a = 1 ∨ a = -1 ↔ a.y = 0 :=\n  by\n  refine' ⟨fun H => H.elim (fun h => by simp [h]) fun h => by simp [h], fun H => _⟩\n  have prop := a.prop\n  rw [H, sq (0 : ℤ), MulZeroClass.mul_zero, MulZeroClass.mul_zero, sub_zero, sq_eq_one_iff] at prop\n  exact prop.imp (fun h => ext h H) fun h => ext h H\n#align eq_one_or_neg_one_iff_y_eq_zero eq_one_or_neg_one_iff_y_eq_zero\n\n",
 "eq_one_of_x_eq_one":
 "/-- A solution with `x = 1` is trivial. -/\ntheorem eq_one_of_x_eq_one (h₀ : d ≠ 0) {a : solution₁ d} (ha : a.x = 1) : a = 1 :=\n  by\n  have prop := a.prop_y\n  rw [ha, one_pow, sub_self, mul_eq_zero, or_iff_right h₀, sq_eq_zero_iff] at prop\n  exact ext ha prop\n#align eq_one_of_x_eq_one eq_one_of_x_eq_one\n\n",
 "coe_mk":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ√ » -/\n@[simp]\ntheorem coe_mk (x y : ℤ) (prop : x ^ 2 - d * y ^ 2 = 1) : (↑(mk x y prop) : «exprℤ√ » d) = ⟨x, y⟩ :=\n  Zsqrtd.ext.mpr ⟨x_mk x y prop, y_mk x y prop⟩\n#align coe_mk coe_mk\n\n"}