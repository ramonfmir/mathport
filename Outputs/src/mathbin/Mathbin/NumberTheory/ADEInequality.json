{"sum_inv_pqr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ+» -/\n/-\nCopyright (c) 2021 Johan Commelin. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johan Commelin\n-/\ntheorem sum_inv_pqr (p q r : «exprℕ+») : sumInv {p, q, r} = p⁻¹ + q⁻¹ + r⁻¹ := by\n  simp only [sum_inv, coe_coe, add_zero, insert_eq_cons, add_assoc, map_cons, sum_cons, map_singleton, sum_singleton]\n#align sum_inv_pqr sum_inv_pqr\n\n",
 "one_lt_sum_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ+» -/\ntheorem admissible.one_lt_sum_inv {pqr : Multiset («exprℕ+»)} : Admissible pqr → 1 < sumInv pqr :=\n  by\n  rw [admissible]\n  rintro (⟨p', q', H⟩ | ⟨n, H⟩ | H | H | H)\n  · rw [← H, A', sum_inv_pqr, add_assoc]\n    simp only [lt_add_iff_pos_right, PNat.one_coe, inv_one, Nat.cast_one, coe_coe]\n    apply add_pos <;> simp only [PNat.pos, Nat.cast_pos, inv_pos]\n  · rw [← H, D', sum_inv_pqr]\n    simp only [lt_add_iff_pos_right, PNat.one_coe, inv_one, Nat.cast_one, coe_coe, PNat.coe_bit0, Nat.cast_bit0]\n    norm_num\n  all_goals rw [← H, E', sum_inv_pqr]; norm_num\n#align admissible.one_lt_sum_inv admissible.one_lt_sum_inv\n\n",
 "lt_three":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ+» -/\ntheorem lt_three {p q r : «exprℕ+»} (hpq : p ≤ q) (hqr : q ≤ r) (H : 1 < sumInv {p, q, r}) : p < 3 :=\n  by\n  have h3 : (0 : exprℚ) < 3 := by norm_num\n  contrapose! H\n  rw [sum_inv_pqr]\n  have h3q := H.trans hpq\n  have h3r := h3q.trans hqr\n  calc\n    (p⁻¹ + q⁻¹ + r⁻¹ : exprℚ) ≤ 3⁻¹ + 3⁻¹ + 3⁻¹ := add_le_add (add_le_add _ _) _\n    _ = 1 := by norm_num\n    \n  all_goals rw [inv_le_inv _ h3] <;> [assumption_mod_cast, norm_num]\n#align lt_three lt_three\n\n",
 "lt_six":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ+» -/\ntheorem lt_six {r : «exprℕ+»} (H : 1 < sumInv {2, 3, r}) : r < 6 :=\n  by\n  have h6 : (0 : exprℚ) < 6 := by norm_num\n  contrapose! H\n  rw [sum_inv_pqr]\n  simp only [PNat.coe_bit0, Nat.cast_bit0, PNat.one_coe, Nat.cast_bit1, Nat.cast_one, PNat.coe_bit1, coe_coe]\n  calc\n    (2⁻¹ + 3⁻¹ + r⁻¹ : exprℚ) ≤ 2⁻¹ + 3⁻¹ + 6⁻¹ := add_le_add (add_le_add le_rfl le_rfl) _\n    _ = 1 := by norm_num\n    \n  rw [inv_le_inv _ h6] <;> [assumption_mod_cast, norm_num]\n#align lt_six lt_six\n\n",
 "lt_four":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ+» -/\ntheorem lt_four {q r : «exprℕ+»} (hqr : q ≤ r) (H : 1 < sumInv {2, q, r}) : q < 4 :=\n  by\n  have h4 : (0 : exprℚ) < 4 := by norm_num\n  contrapose! H\n  rw [sum_inv_pqr]\n  have h4r := H.trans hqr\n  simp only [PNat.coe_bit0, Nat.cast_bit0, PNat.one_coe, Nat.cast_one, coe_coe]\n  calc\n    (2⁻¹ + q⁻¹ + r⁻¹ : exprℚ) ≤ 2⁻¹ + 4⁻¹ + 4⁻¹ := add_le_add (add_le_add le_rfl _) _\n    _ = 1 := by norm_num\n    \n  all_goals rw [inv_le_inv _ h4] <;> [assumption_mod_cast, norm_num]\n#align lt_four lt_four\n\n",
 "classification":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ+» -/\n/-- A multiset `{p,q,r}` of positive natural numbers\nis a solution to `(p⁻¹ + q⁻¹ + r⁻¹ : ℚ) > 1` if and only if\nit is `admissible` which means it is one of:\n\n* `A' q r := {1,q,r}`\n* `D' r := {2,2,r}`\n* `E6 := {2,3,3}`, or `E7 := {2,3,4}`, or `E8 := {2,3,5}`\n-/\ntheorem classification (p q r : «exprℕ+») : 1 < sumInv {p, q, r} ↔ Admissible {p, q, r} :=\n  ⟨admissible_of_one_lt_sumInv, Admissible.one_lt_sumInv⟩\n#align classification classification\n\n",
 "admissible_of_one_lt_sum_inv_aux'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ+» -/\ntheorem admissible_of_one_lt_sum_inv_aux' {p q r : «exprℕ+»} (hpq : p ≤ q) (hqr : q ≤ r) (H : 1 < sumInv {p, q, r}) :\n    Admissible {p, q, r} := by\n  have hp3 : p < 3 := lt_three hpq hqr H\n  interval_cases\n  · exact admissible_A' q r\n  have hq4 : q < 4 := lt_four hqr H\n  interval_cases\n  · exact admissible_D' r\n  have hr6 : r < 6 := lt_six H\n  interval_cases\n  · exact admissible_E6\n  · exact admissible_E7\n  · exact admissible_E8\n#align admissible_of_one_lt_sum_inv_aux' admissible_of_one_lt_sum_inv_aux'\n\n",
 "admissible_of_one_lt_sum_inv_aux":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ+» -/\ntheorem admissible_of_one_lt_sum_inv_aux :\n    ∀ {pqr : List («exprℕ+»)} (hs : pqr.sorted (· ≤ ·)) (hl : pqr.length = 3) (H : 1 < sumInv pqr), Admissible pqr\n  | [p, q, r], hs, hl, H => by\n    obtain ⟨⟨hpq, -⟩, hqr⟩ : (p ≤ q ∧ p ≤ r) ∧ q ≤ r\n    simpa using hs\n    exact admissible_of_one_lt_sum_inv_aux' hpq hqr H\n#align admissible_of_one_lt_sum_inv_aux admissible_of_one_lt_sum_inv_aux\n\n",
 "admissible_of_one_lt_sum_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ+» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ+» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ+» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ+» -/\ntheorem admissible_of_one_lt_sum_inv {p q r : «exprℕ+»} (H : 1 < sumInv {p, q, r}) : Admissible {p, q, r} :=\n  by\n  simp only [admissible]\n  let S := sort ((· ≤ ·) : «exprℕ+» → «exprℕ+» → Prop) {p, q, r}\n  have hS : S.sorted (· ≤ ·) := sort_sorted _ _\n  have hpqr : ({p, q, r} : Multiset («exprℕ+»)) = S := (sort_eq LE.le {p, q, r}).symm\n  simp only [hpqr] at *\n  apply admissible_of_one_lt_sum_inv_aux hS _ H\n  simp only [S, length_sort]\n  decide\n#align admissible_of_one_lt_sum_inv admissible_of_one_lt_sum_inv\n\n",
 "admissible_E8":
 "theorem admissible_E8 : Admissible E8 :=\n  admissible_E'5\n#align admissible_E8 admissible_E8\n\n",
 "admissible_E7":
 "theorem admissible_E7 : Admissible E7 :=\n  admissible_E'4\n#align admissible_E7 admissible_E7\n\n",
 "admissible_E6":
 "theorem admissible_E6 : Admissible E6 :=\n  admissible_E'3\n#align admissible_E6 admissible_E6\n\n",
 "admissible_E'5":
 "theorem admissible_E'5 : Admissible (E' 5) :=\n  or.inr <| or.inr <| or.inr <| or.inr rfl\n#align admissible_E'5 admissible_E'5\n\n",
 "admissible_E'4":
 "theorem admissible_E'4 : Admissible (E' 4) :=\n  or.inr <| or.inr <| or.inr <| or.inl rfl\n#align admissible_E'4 admissible_E'4\n\n",
 "admissible_E'3":
 "theorem admissible_E'3 : Admissible (E' 3) :=\n  or.inr <| or.inr <| or.inl rfl\n#align admissible_E'3 admissible_E'3\n\n",
 "admissible_D'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ+» -/\ntheorem admissible_D' (n : «exprℕ+») : Admissible (D' n) :=\n  or.inr <| or.inl ⟨n, rfl⟩\n#align admissible_D' admissible_D'\n\n",
 "admissible_A'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ+» -/\ntheorem admissible_A' (q r : «exprℕ+») : Admissible (A' q r) :=\n  or.inl ⟨q, r, rfl⟩\n#align admissible_A' admissible_A'\n\n"}