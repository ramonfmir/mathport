{"smul_subset_of_coprime":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[to_additive]\ntheorem smul_subset_of_coprime (han : (orderOf a).coprime n) :\n    «expr • » a (approx_order_of A n δ) ⊆ approx_order_of A (orderOf a * n) δ :=\n  by\n  simp_rw [approx_order_of, thickening_eq_bUnion_ball, ← image_smul, image_Union₂, image_smul, smul_ball'', smul_eq_mul,\n    mem_set_of_eq]\n  refine' Union₂_subset_iff.mpr fun b hb c hc => _\n  simp only [mem_Union, exists_prop]\n  refine' ⟨a * b, _, hc⟩\n  rw [← hb] at han⊢\n  exact (Commute.all a b).order_of_mul_eq_mul_order_of_of_coprime han\n#align smul_subset_of_coprime smul_subset_of_coprime\n\n",
 "smul_eq_of_mul_dvd":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[to_additive vadd_eq_of_mul_dvd]\ntheorem smul_eq_of_mul_dvd (hn : 0 < n) (han : orderOf a ^ 2 ∣ n) :\n    «expr • » a (approx_order_of A n δ) = approx_order_of A n δ :=\n  by\n  simp_rw [approx_order_of, thickening_eq_bUnion_ball, ← image_smul, image_Union₂, image_smul, smul_ball'', smul_eq_mul,\n    mem_set_of_eq]\n  replace han : ∀ {b : A}, orderOf b = n → orderOf (a * b) = n\n  · intro b hb\n    rw [← hb] at han hn\n    rw [sq] at han\n    rwa [(Commute.all a b).order_of_mul_eq_right_of_forall_prime_mul_dvd (order_of_pos_iff.mp hn) fun p hp hp' =>\n        dvd_trans (mul_dvd_mul_right hp' <| orderOf a) han]\n  let f : { b : A | orderOf b = n } → { b : A | orderOf b = n } := fun b => ⟨a * b, han b.property⟩\n  have hf : surjective f := by\n    rintro ⟨b, hb⟩\n    refine' ⟨⟨a⁻¹ * b, _⟩, _⟩\n    · rw [mem_set_of_eq, ← orderOf_inv, mul_inv_rev, inv_inv, mul_comm]\n      apply han\n      simpa\n    · simp only [Subtype.mk_eq_mk, Subtype.coe_mk, mul_inv_cancel_left]\n  simpa only [f, mem_set_of_eq, Subtype.coe_mk, Union_coe_set] using hf.Union_comp fun b => ball (b : A) δ\n#align smul_eq_of_mul_dvd smul_eq_of_mul_dvd\n\n",
 "mem_well_approximable_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n@[to_additive mem_add_well_approximable_iff]\ntheorem mem_well_approximable_iff {A : Type _} [SeminormedGroup A] {δ : ℕ → exprℝ} {a : A} :\n    a ∈ well_approximable A δ ↔ a ∈ blimsup (fun n => approx_order_of A n (δ n)) atTop fun n => 0 < n :=\n  iff.rfl\n#align mem_well_approximable_iff mem_well_approximable_iff\n\n",
 "mem_approx_order_of_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-\nCopyright (c) 2022 Oliver Nash. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Oliver Nash\n-/\n@[to_additive mem_approx_add_order_of_iff]\ntheorem mem_approx_order_of_iff {A : Type _} [SeminormedGroup A] {n : ℕ} {δ : exprℝ} {a : A} :\n    a ∈ approx_order_of A n δ ↔ ∃ b : A, orderOf b = n ∧ a ∈ ball b δ := by\n  simp only [approx_order_of, thickening_eq_bUnion_ball, mem_Union₂, mem_set_of_eq, exists_prop]\n#align mem_approx_order_of_iff mem_approx_order_of_iff\n\n",
 "mem_approx_add_order_of_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem mem_approx_add_order_of_iff {δ : exprℝ} {x : unit_add_circle} {n : ℕ} (hn : 0 < n) :\n    x ∈ approx_add_order_of unit_add_circle n δ ↔ ∃ m < n, gcd m n = 1 ∧ «expr‖ ‖» (x - ↑((m : exprℝ) / n)) < δ :=\n  by\n  haveI := Real.fact_zero_lt_one\n  simp only [mem_approx_add_order_of_iff, mem_set_of_eq, ball, exists_prop, dist_eq_norm,\n    add_circle.add_order_of_eq_pos_iff hn, mul_one]\n  constructor\n  · rintro ⟨y, ⟨m, hm₁, hm₂, rfl⟩, hx⟩\n    exact ⟨m, hm₁, hm₂, hx⟩\n  · rintro ⟨m, hm₁, hm₂, hx⟩\n    exact ⟨↑((m : exprℝ) / n), ⟨m, hm₁, hm₂, rfl⟩, hx⟩\n#align mem_approx_add_order_of_iff mem_approx_add_order_of_iff\n\n",
 "mem_add_well_approximable_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem mem_add_well_approximable_iff (δ : ℕ → exprℝ) (x : unit_add_circle) :\n    x ∈ add_well_approximable unit_add_circle δ ↔\n      { n : ℕ | ∃ m < n, gcd m n = 1 ∧ «expr‖ ‖» (x - ↑((m : exprℝ) / n)) < δ n }.infinite :=\n  by\n  simp only [mem_add_well_approximable_iff, ← Nat.cofinite_eq_atTop, cofinite.blimsup_set_eq, mem_set_of_eq]\n  refine' iff_of_eq (congr_arg Set.Infinite <| ext fun n => ⟨fun hn => _, fun hn => _⟩)\n  · exact (mem_approx_add_order_of_iff hn.1).mp hn.2\n  · have h : 0 < n := by\n      obtain ⟨m, hm₁, hm₂, hm₃⟩ := hn\n      exact pos_of_gt hm₁\n    exact ⟨h, (mem_approx_add_order_of_iff h).mpr hn⟩\n#align mem_add_well_approximable_iff mem_add_well_approximable_iff\n\n",
 "image_pow_subset_of_coprime":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n@[to_additive]\ntheorem image_pow_subset_of_coprime (hm : 0 < m) (hmn : n.coprime m) :\n    «expr '' » (fun y => y ^ m) (approx_order_of A n δ) ⊆ approx_order_of A n (m * δ) :=\n  by\n  rintro - ⟨a, ha, rfl⟩\n  obtain ⟨b, hb, hab⟩ := mem_approx_order_of_iff.mp ha\n  replace hb : b ^ m ∈ { u : A | orderOf u = n };\n  · rw [← hb] at hmn⊢\n    exact orderOf_pow_coprime hmn\n  apply ball_subset_thickening hb («expr • » (m : exprℝ) δ)\n  convert pow_mem_ball hm hab using 1\n  simp only [nsmul_eq_mul, Algebra.id.smul_eq_mul]\n#align image_pow_subset_of_coprime image_pow_subset_of_coprime\n\n",
 "image_pow_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n@[to_additive]\ntheorem image_pow_subset (n : ℕ) (hm : 0 < m) :\n    «expr '' » (fun y => y ^ m) (approx_order_of A (n * m) δ) ⊆ approx_order_of A n (m * δ) :=\n  by\n  rintro - ⟨a, ha, rfl⟩\n  obtain ⟨b, hb : orderOf b = n * m, hab : a ∈ ball b δ⟩ := mem_approx_order_of_iff.mp ha\n  replace hb : b ^ m ∈ { y : A | orderOf y = n }\n  · rw [mem_set_of_eq, orderOf_pow' b hm.ne', hb, Nat.gcd_mul_left_left, n.mul_div_cancel hm]\n  apply ball_subset_thickening hb (m * δ)\n  convert pow_mem_ball hm hab\n  simp only [nsmul_eq_mul]\n#align image_pow_subset image_pow_subset\n\n",
 "add_well_approximable_ae_empty_or_univ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expr𝕊 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expr𝕊 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expr𝕊 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expr𝕊 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expr𝕊 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expr𝕊 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expr𝕊 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∣∣ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expr𝕊 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expr𝕊 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expr𝕊 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expr𝕊 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expr𝕊 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expr𝕊 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expr𝕊 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expr𝕊 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expr𝕊 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expr𝕊 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expr𝕊 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∣∣ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∣∣ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expr𝕊 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expr𝕊 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr +ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expr𝕊 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expr𝕊 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expr𝕊 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr +ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:219:4: warning: unsupported binary notation `«expr +ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expr𝕊 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expr𝕊 -/\n/-- *Gallagher's ergodic theorem* on Diophantine approximation. -/\ntheorem add_well_approximable_ae_empty_or_univ (δ : ℕ → exprℝ) (hδ : Tendsto δ atTop ((nhds) 0)) :\n    «expr∀ᵐ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ , »\"\n        ¬add_well_approximable (expr𝕊) δ x ∨\n      «expr∀ᵐ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ , »\"\n        (add_well_approximable (expr𝕊) δ x) :=\n  by\n  /- Sketch of proof:\n  \n    Let `E := add_well_approximable 𝕊 δ`. For each prime `p : ℕ`, we can partition `E` into three\n    pieces `E = (A p) ∪ (B p) ∪ (C p)` where:\n      `A p = blimsup (approx_add_order_of 𝕊 n (δ n)) at_top (λ n, 0 < n ∧ (p ∤ n))`\n      `B p = blimsup (approx_add_order_of 𝕊 n (δ n)) at_top (λ n, 0 < n ∧ (p ∣∣ n))`\n      `C p = blimsup (approx_add_order_of 𝕊 n (δ n)) at_top (λ n, 0 < n ∧ (p*p ∣ n))`.\n    (In other words, `A p` is the set of points `x` for which there exist infinitely-many `n` such\n    that `x` is within a distance `δ n` of a point of order `n` and `p ∤ n`. Similarly for `B`, `C`.)\n  \n    These sets have the following key properties:\n      1. `A p` is almost invariant under the ergodic map `y ↦ p • y`\n      2. `B p` is almost invariant under the ergodic map `y ↦ p • y + 1/p`\n      3. `C p` is invariant under the map `y ↦ y + 1/p`\n    To prove 1 and 2 we need the key result `blimsup_thickening_mul_ae_eq` but 3 is elementary.\n  \n    It follows from `add_circle.ergodic_nsmul_add` and `ergodic.ae_empty_or_univ_of_image_ae_le` that\n    if either `A p` or `B p` is not almost empty for any `p`, then it is almost full and thus so is\n    `E`. We may therefore assume that both `A p` and `B p` are almost empty for all `p`. We thus have\n    `E` is almost equal to `C p` for every prime. Combining this with 3 we find that `E` is almost\n    invariant under the map `y ↦ y + 1/p` for every prime `p`. The required result then follows from\n    `add_circle.ae_empty_or_univ_of_forall_vadd_ae_eq_self`. -/\n  letI : SemilatticeSup Nat.Primes := Nat.Subtype.semilatticeSup _\n  set μ : measure (expr𝕊) := volume\n  set u : Nat.Primes → expr𝕊 := fun p => ↑((↑(1 : ℕ) : exprℝ) / p * T)\n  have hu₀ : ∀ p : Nat.Primes, addOrderOf (u p) = (p : ℕ) :=\n    by\n    rintro ⟨p, hp⟩\n    exact add_order_of_div_of_gcd_eq_one hp.pos (gcd_one_left p)\n  have hu : tendsto (addOrderOf ∘ u) at_top at_top :=\n    by\n    rw [(funext hu₀ : addOrderOf ∘ u = coe)]\n    have h_mono : Monotone (coe : Nat.Primes → ℕ) := fun p q hpq => hpq\n    refine' h_mono.tendsto_at_top_at_top fun n => _\n    obtain ⟨p, hp, hp'⟩ := n.exists_infinite_primes\n    exact ⟨⟨p, hp'⟩, hp⟩\n  set E := add_well_approximable (expr𝕊) δ\n  set X : ℕ → Set (expr𝕊) := fun n => approx_add_order_of (expr𝕊) n (δ n)\n  set A : ℕ → Set (expr𝕊) := fun p => blimsup X at_top fun n => 0 < n ∧ «expr ∤ » p n\n  set B : ℕ → Set (expr𝕊) := fun p => blimsup X at_top fun n => 0 < n ∧ «expr ∣∣ » p n\n  set C : ℕ → Set (expr𝕊) := fun p => blimsup X at_top fun n => 0 < n ∧ p ^ 2 ∣ n\n  have hA₀ : ∀ p, MeasurableSet (A p) := fun p =>\n    MeasurableSet.measurableSet_blimsup fun n hn => is_open_thickening.measurable_set\n  have hB₀ : ∀ p, MeasurableSet (B p) := fun p =>\n    MeasurableSet.measurableSet_blimsup fun n hn => is_open_thickening.measurable_set\n  have hE₀ : null_measurable_set E μ :=\n    by\n    refine' (MeasurableSet.measurableSet_blimsup fun n hn => is_open.measurable_set _).null_measurable_set\n    exact is_open_thickening\n  have hE₁ : ∀ p, E = A p ∪ B p ∪ C p := by\n    intro p\n    simp only [E, add_well_approximable, ← blimsup_or_eq_sup, ← and_or_left, ← sup_eq_union, sq]\n    congr\n    refine' funext fun n => propext <| iff_self_and.mpr fun hn => _\n    -- `tauto` can finish from here but unfortunately it's very slow.\n    simp only [(em (p ∣ n)).symm, (em (p * p ∣ n)).symm, or_and_left, or_true_iff, true_and_iff, or_assoc']\n  have hE₂ :\n    ∀ p : Nat.Primes,\n      «expr =ᵐ[ ] » (A p) μ (∅ : Set (expr𝕊)) ∧ «expr =ᵐ[ ] » (B p) μ (∅ : Set (expr𝕊)) → «expr =ᵐ[ ] » E μ (C p) :=\n    by\n    rintro p ⟨hA, hB⟩\n    rw [hE₁ p]\n    exact union_ae_eq_right_of_ae_eq_empty ((union_ae_eq_right_of_ae_eq_empty hA).trans hB)\n  have hA : ∀ p : Nat.Primes, «expr =ᵐ[ ] » (A p) μ (∅ : Set (expr𝕊)) ∨ «expr =ᵐ[ ] » (A p) μ univ :=\n    by\n    rintro ⟨p, hp⟩\n    let f : expr𝕊 → expr𝕊 := fun y => «expr • » (p : ℕ) y\n    suffices\n      «expr '' » f (A p) ⊆\n        blimsup (fun n => approx_add_order_of (expr𝕊) n (p * δ n)) at_top fun n => 0 < n ∧ «expr ∤ » p n\n      by\n      apply (ergodic_nsmul hp.one_lt).ae_empty_or_univ_of_image_ae_le (hA₀ p)\n      apply (HasSubset.Subset.eventuallyLE this).congr eventually_eq.rfl\n      exact\n        blimsup_thickening_mul_ae_eq μ (fun n => 0 < n ∧ «expr ∤ » p n) (fun n => { y | addOrderOf y = n })\n          (nat.cast_pos.mpr hp.pos) _ hδ\n    refine' (SupₛHom.setImage f).apply_blimsup_le.trans (mono_blimsup fun n hn => _)\n    replace hn := nat.coprime_comm.mp (hp.coprime_iff_not_dvd.2 hn.2)\n    exact approx_add_order_of.image_nsmul_subset_of_coprime (δ n) hp.pos hn\n  have hB : ∀ p : Nat.Primes, «expr =ᵐ[ ] » (B p) μ (∅ : Set (expr𝕊)) ∨ «expr =ᵐ[ ] » (B p) μ univ :=\n    by\n    rintro ⟨p, hp⟩\n    let x := u ⟨p, hp⟩\n    let f : expr𝕊 → expr𝕊 := fun y => «expr • » p y + x\n    suffices\n      «expr '' » f (B p) ⊆\n        blimsup (fun n => approx_add_order_of (expr𝕊) n (p * δ n)) at_top fun n => 0 < n ∧ «expr ∣∣ » p n\n      by\n      apply (ergodic_nsmul_add x hp.one_lt).ae_empty_or_univ_of_image_ae_le (hB₀ p)\n      apply (HasSubset.Subset.eventuallyLE this).congr eventually_eq.rfl\n      exact\n        blimsup_thickening_mul_ae_eq μ (fun n => 0 < n ∧ «expr ∣∣ » p n) (fun n => { y | addOrderOf y = n })\n          (nat.cast_pos.mpr hp.pos) _ hδ\n    refine' (SupₛHom.setImage f).apply_blimsup_le.trans (mono_blimsup _)\n    rintro n ⟨hn, h_div, h_ndiv⟩\n    have h_cop : (addOrderOf x).coprime (n / p) :=\n      by\n      obtain ⟨q, rfl⟩ := h_div\n      rw [hu₀, Subtype.coe_mk, hp.coprime_iff_not_dvd, q.mul_div_cancel_left hp.pos]\n      exact fun contra => h_ndiv (mul_dvd_mul_left p contra)\n    replace h_div : n / p * p = n := Nat.div_mul_cancel h_div\n    have hf : f = (fun y => x + y) ∘ fun y => «expr • » p y :=\n      by\n      ext\n      simp [add_comm x]\n    simp_rw [comp_app]\n    rw [le_eq_subset, Sup_hom.set_image_to_fun, hf, image_comp]\n    have := @monotone_image (expr𝕊) (expr𝕊) fun y => x + y\n    specialize this (approx_add_order_of.image_nsmul_subset (δ n) (n / p) hp.pos)\n    simp only [h_div] at this⊢\n    refine' this.trans _\n    convert approx_add_order_of.vadd_subset_of_coprime (p * δ n) h_cop\n    simp only [hu₀, Subtype.coe_mk, h_div, mul_comm p]\n  change\n    «expr∀ᵐ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ , »\" (x ∉ E) ∨\n      E ∈ volume.ae\n  rw [← eventually_eq_empty, ← eventually_eq_univ]\n  have hC : ∀ p : Nat.Primes, «expr +ᵥ » (u p) (C p) = C p :=\n    by\n    intro p\n    let e := (AddAction.toPerm (u p) : Equiv.Perm (expr𝕊)).to_order_iso_set\n    change e (C p) = C p\n    rw [e.apply_blimsup, ← hu₀ p]\n    exact blimsup_congr (eventually_of_forall fun n hn => approx_add_order_of.vadd_eq_of_mul_dvd (δ n) hn.1 hn.2)\n  by_cases h : ∀ p : Nat.Primes, «expr =ᵐ[ ] » (A p) μ (∅ : Set (expr𝕊)) ∧ «expr =ᵐ[ ] » (B p) μ (∅ : Set (expr𝕊))\n  · replace h : ∀ p : Nat.Primes, «expr =ᵐ[ ] » («expr +ᵥ » (u p) E : Set _) μ E\n    · intro p\n      replace hE₂ : «expr =ᵐ[ ] » E μ (C p) := hE₂ p (h p)\n      have h_qmp : MeasureTheory.Measure.QuasiMeasurePreserving ((«expr +ᵥ » · ·) (-u p)) μ μ :=\n        (measure_preserving_vadd _ μ).quasi_measure_preserving\n      refine' (h_qmp.vadd_ae_eq_of_ae_eq (u p) hE₂).trans (ae_eq_trans _ hE₂.symm)\n      rw [hC]\n    exact ae_empty_or_univ_of_forall_vadd_ae_eq_self hE₀ h hu\n  · right\n    simp only [not_forall, not_and_or] at h\n    obtain ⟨p, hp⟩ := h\n    rw [hE₁ p]\n    cases hp\n    · cases hA p\n      · contradiction\n      simp only [h, union_ae_eq_univ_of_ae_eq_univ_left]\n    · cases hB p\n      · contradiction\n      simp only [h, union_ae_eq_univ_of_ae_eq_univ_left, union_ae_eq_univ_of_ae_eq_univ_right]\n#align add_well_approximable_ae_empty_or_univ add_well_approximable_ae_empty_or_univ\n\n"}