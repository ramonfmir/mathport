{"smul_subset_of_coprime":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n@[to_additive]\ntheorem smul_subset_of_coprime (han : (orderOf a).coprime n) :\n    Â«expr â€¢ Â» a (approx_order_of A n Î´) âŠ† approx_order_of A (orderOf a * n) Î´ :=\n  by\n  simp_rw [approx_order_of, thickening_eq_bUnion_ball, â† image_smul, image_Unionâ‚‚, image_smul, smul_ball'', smul_eq_mul,\n    mem_set_of_eq]\n  refine' Unionâ‚‚_subset_iff.mpr fun b hb c hc => _\n  simp only [mem_Union, exists_prop]\n  refine' âŸ¨a * b, _, hcâŸ©\n  rw [â† hb] at hanâŠ¢\n  exact (Commute.all a b).order_of_mul_eq_mul_order_of_of_coprime han\n#align smul_subset_of_coprime smul_subset_of_coprime\n\n",
 "smul_eq_of_mul_dvd":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n@[to_additive vadd_eq_of_mul_dvd]\ntheorem smul_eq_of_mul_dvd (hn : 0 < n) (han : orderOf a ^ 2 âˆ£ n) :\n    Â«expr â€¢ Â» a (approx_order_of A n Î´) = approx_order_of A n Î´ :=\n  by\n  simp_rw [approx_order_of, thickening_eq_bUnion_ball, â† image_smul, image_Unionâ‚‚, image_smul, smul_ball'', smul_eq_mul,\n    mem_set_of_eq]\n  replace han : âˆ€ {b : A}, orderOf b = n â†’ orderOf (a * b) = n\n  Â· intro b hb\n    rw [â† hb] at han hn\n    rw [sq] at han\n    rwa [(Commute.all a b).order_of_mul_eq_right_of_forall_prime_mul_dvd (order_of_pos_iff.mp hn) fun p hp hp' =>\n        dvd_trans (mul_dvd_mul_right hp' <| orderOf a) han]\n  let f : { b : A | orderOf b = n } â†’ { b : A | orderOf b = n } := fun b => âŸ¨a * b, han b.propertyâŸ©\n  have hf : surjective f := by\n    rintro âŸ¨b, hbâŸ©\n    refine' âŸ¨âŸ¨aâ»Â¹ * b, _âŸ©, _âŸ©\n    Â· rw [mem_set_of_eq, â† orderOf_inv, mul_inv_rev, inv_inv, mul_comm]\n      apply han\n      simpa\n    Â· simp only [Subtype.mk_eq_mk, Subtype.coe_mk, mul_inv_cancel_left]\n  simpa only [f, mem_set_of_eq, Subtype.coe_mk, Union_coe_set] using hf.Union_comp fun b => ball (b : A) Î´\n#align smul_eq_of_mul_dvd smul_eq_of_mul_dvd\n\n",
 "mem_well_approximable_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n@[to_additive mem_add_well_approximable_iff]\ntheorem mem_well_approximable_iff {A : Type _} [SeminormedGroup A] {Î´ : â„• â†’ exprâ„} {a : A} :\n    a âˆˆ well_approximable A Î´ â†” a âˆˆ blimsup (fun n => approx_order_of A n (Î´ n)) atTop fun n => 0 < n :=\n  iff.rfl\n#align mem_well_approximable_iff mem_well_approximable_iff\n\n",
 "mem_approx_order_of_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/-\nCopyright (c) 2022 Oliver Nash. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Oliver Nash\n-/\n@[to_additive mem_approx_add_order_of_iff]\ntheorem mem_approx_order_of_iff {A : Type _} [SeminormedGroup A] {n : â„•} {Î´ : exprâ„} {a : A} :\n    a âˆˆ approx_order_of A n Î´ â†” âˆƒ b : A, orderOf b = n âˆ§ a âˆˆ ball b Î´ := by\n  simp only [approx_order_of, thickening_eq_bUnion_ball, mem_Unionâ‚‚, mem_set_of_eq, exists_prop]\n#align mem_approx_order_of_iff mem_approx_order_of_iff\n\n",
 "mem_approx_add_order_of_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\ntheorem mem_approx_add_order_of_iff {Î´ : exprâ„} {x : unit_add_circle} {n : â„•} (hn : 0 < n) :\n    x âˆˆ approx_add_order_of unit_add_circle n Î´ â†” âˆƒ m < n, gcd m n = 1 âˆ§ Â«exprâ€– â€–Â» (x - â†‘((m : exprâ„) / n)) < Î´ :=\n  by\n  haveI := Real.fact_zero_lt_one\n  simp only [mem_approx_add_order_of_iff, mem_set_of_eq, ball, exists_prop, dist_eq_norm,\n    add_circle.add_order_of_eq_pos_iff hn, mul_one]\n  constructor\n  Â· rintro âŸ¨y, âŸ¨m, hmâ‚, hmâ‚‚, rflâŸ©, hxâŸ©\n    exact âŸ¨m, hmâ‚, hmâ‚‚, hxâŸ©\n  Â· rintro âŸ¨m, hmâ‚, hmâ‚‚, hxâŸ©\n    exact âŸ¨â†‘((m : exprâ„) / n), âŸ¨m, hmâ‚, hmâ‚‚, rflâŸ©, hxâŸ©\n#align mem_approx_add_order_of_iff mem_approx_add_order_of_iff\n\n",
 "mem_add_well_approximable_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\ntheorem mem_add_well_approximable_iff (Î´ : â„• â†’ exprâ„) (x : unit_add_circle) :\n    x âˆˆ add_well_approximable unit_add_circle Î´ â†”\n      { n : â„• | âˆƒ m < n, gcd m n = 1 âˆ§ Â«exprâ€– â€–Â» (x - â†‘((m : exprâ„) / n)) < Î´ n }.infinite :=\n  by\n  simp only [mem_add_well_approximable_iff, â† Nat.cofinite_eq_atTop, cofinite.blimsup_set_eq, mem_set_of_eq]\n  refine' iff_of_eq (congr_arg Set.Infinite <| ext fun n => âŸ¨fun hn => _, fun hn => _âŸ©)\n  Â· exact (mem_approx_add_order_of_iff hn.1).mp hn.2\n  Â· have h : 0 < n := by\n      obtain âŸ¨m, hmâ‚, hmâ‚‚, hmâ‚ƒâŸ© := hn\n      exact pos_of_gt hmâ‚\n    exact âŸ¨h, (mem_approx_add_order_of_iff h).mpr hnâŸ©\n#align mem_add_well_approximable_iff mem_add_well_approximable_iff\n\n",
 "image_pow_subset_of_coprime":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n@[to_additive]\ntheorem image_pow_subset_of_coprime (hm : 0 < m) (hmn : n.coprime m) :\n    Â«expr '' Â» (fun y => y ^ m) (approx_order_of A n Î´) âŠ† approx_order_of A n (m * Î´) :=\n  by\n  rintro - âŸ¨a, ha, rflâŸ©\n  obtain âŸ¨b, hb, habâŸ© := mem_approx_order_of_iff.mp ha\n  replace hb : b ^ m âˆˆ { u : A | orderOf u = n };\n  Â· rw [â† hb] at hmnâŠ¢\n    exact orderOf_pow_coprime hmn\n  apply ball_subset_thickening hb (Â«expr â€¢ Â» (m : exprâ„) Î´)\n  convert pow_mem_ball hm hab using 1\n  simp only [nsmul_eq_mul, Algebra.id.smul_eq_mul]\n#align image_pow_subset_of_coprime image_pow_subset_of_coprime\n\n",
 "image_pow_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n@[to_additive]\ntheorem image_pow_subset (n : â„•) (hm : 0 < m) :\n    Â«expr '' Â» (fun y => y ^ m) (approx_order_of A (n * m) Î´) âŠ† approx_order_of A n (m * Î´) :=\n  by\n  rintro - âŸ¨a, ha, rflâŸ©\n  obtain âŸ¨b, hb : orderOf b = n * m, hab : a âˆˆ ball b Î´âŸ© := mem_approx_order_of_iff.mp ha\n  replace hb : b ^ m âˆˆ { y : A | orderOf y = n }\n  Â· rw [mem_set_of_eq, orderOf_pow' b hm.ne', hb, Nat.gcd_mul_left_left, n.mul_div_cancel hm]\n  apply ball_subset_thickening hb (m * Î´)\n  convert pow_mem_ball hm hab\n  simp only [nsmul_eq_mul]\n#align image_pow_subset image_pow_subset\n\n",
 "add_well_approximable_ae_empty_or_univ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprğ•Š -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprğ•Š -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprğ•Š -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprğ•Š -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprğ•Š -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprğ•Š -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âˆ¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprğ•Š -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âˆ£âˆ£ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprğ•Š -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr =áµ[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprğ•Š -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr =áµ[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprğ•Š -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr =áµ[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr =áµ[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprğ•Š -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr =áµ[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprğ•Š -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprğ•Š -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprğ•Š -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âˆ¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âˆ¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr =áµ[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprğ•Š -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr =áµ[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprğ•Š -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprğ•Š -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprğ•Š -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âˆ£âˆ£ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âˆ£âˆ£ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprğ•Š -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprğ•Š -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€áµ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€áµ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr +áµ¥ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprğ•Š -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr =áµ[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprğ•Š -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr =áµ[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprğ•Š -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr =áµ[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr +áµ¥ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr =áµ[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:219:4: warning: unsupported binary notation `Â«expr +áµ¥ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€áµ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€áµ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprğ•Š -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€áµ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€áµ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprğ•Š -/\n/-- *Gallagher's ergodic theorem* on Diophantine approximation. -/\ntheorem add_well_approximable_ae_empty_or_univ (Î´ : â„• â†’ exprâ„) (hÎ´ : Tendsto Î´ atTop ((nhds) 0)) :\n    Â«exprâˆ€áµ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€áµ , Â»\"\n        Â¬add_well_approximable (exprğ•Š) Î´ x âˆ¨\n      Â«exprâˆ€áµ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€áµ , Â»\"\n        (add_well_approximable (exprğ•Š) Î´ x) :=\n  by\n  /- Sketch of proof:\n  \n    Let `E := add_well_approximable ğ•Š Î´`. For each prime `p : â„•`, we can partition `E` into three\n    pieces `E = (A p) âˆª (B p) âˆª (C p)` where:\n      `A p = blimsup (approx_add_order_of ğ•Š n (Î´ n)) at_top (Î» n, 0 < n âˆ§ (p âˆ¤ n))`\n      `B p = blimsup (approx_add_order_of ğ•Š n (Î´ n)) at_top (Î» n, 0 < n âˆ§ (p âˆ£âˆ£ n))`\n      `C p = blimsup (approx_add_order_of ğ•Š n (Î´ n)) at_top (Î» n, 0 < n âˆ§ (p*p âˆ£ n))`.\n    (In other words, `A p` is the set of points `x` for which there exist infinitely-many `n` such\n    that `x` is within a distance `Î´ n` of a point of order `n` and `p âˆ¤ n`. Similarly for `B`, `C`.)\n  \n    These sets have the following key properties:\n      1. `A p` is almost invariant under the ergodic map `y â†¦ p â€¢ y`\n      2. `B p` is almost invariant under the ergodic map `y â†¦ p â€¢ y + 1/p`\n      3. `C p` is invariant under the map `y â†¦ y + 1/p`\n    To prove 1 and 2 we need the key result `blimsup_thickening_mul_ae_eq` but 3 is elementary.\n  \n    It follows from `add_circle.ergodic_nsmul_add` and `ergodic.ae_empty_or_univ_of_image_ae_le` that\n    if either `A p` or `B p` is not almost empty for any `p`, then it is almost full and thus so is\n    `E`. We may therefore assume that both `A p` and `B p` are almost empty for all `p`. We thus have\n    `E` is almost equal to `C p` for every prime. Combining this with 3 we find that `E` is almost\n    invariant under the map `y â†¦ y + 1/p` for every prime `p`. The required result then follows from\n    `add_circle.ae_empty_or_univ_of_forall_vadd_ae_eq_self`. -/\n  letI : SemilatticeSup Nat.Primes := Nat.Subtype.semilatticeSup _\n  set Î¼ : measure (exprğ•Š) := volume\n  set u : Nat.Primes â†’ exprğ•Š := fun p => â†‘((â†‘(1 : â„•) : exprâ„) / p * T)\n  have huâ‚€ : âˆ€ p : Nat.Primes, addOrderOf (u p) = (p : â„•) :=\n    by\n    rintro âŸ¨p, hpâŸ©\n    exact add_order_of_div_of_gcd_eq_one hp.pos (gcd_one_left p)\n  have hu : tendsto (addOrderOf âˆ˜ u) at_top at_top :=\n    by\n    rw [(funext huâ‚€ : addOrderOf âˆ˜ u = coe)]\n    have h_mono : Monotone (coe : Nat.Primes â†’ â„•) := fun p q hpq => hpq\n    refine' h_mono.tendsto_at_top_at_top fun n => _\n    obtain âŸ¨p, hp, hp'âŸ© := n.exists_infinite_primes\n    exact âŸ¨âŸ¨p, hp'âŸ©, hpâŸ©\n  set E := add_well_approximable (exprğ•Š) Î´\n  set X : â„• â†’ Set (exprğ•Š) := fun n => approx_add_order_of (exprğ•Š) n (Î´ n)\n  set A : â„• â†’ Set (exprğ•Š) := fun p => blimsup X at_top fun n => 0 < n âˆ§ Â«expr âˆ¤ Â» p n\n  set B : â„• â†’ Set (exprğ•Š) := fun p => blimsup X at_top fun n => 0 < n âˆ§ Â«expr âˆ£âˆ£ Â» p n\n  set C : â„• â†’ Set (exprğ•Š) := fun p => blimsup X at_top fun n => 0 < n âˆ§ p ^ 2 âˆ£ n\n  have hAâ‚€ : âˆ€ p, MeasurableSet (A p) := fun p =>\n    MeasurableSet.measurableSet_blimsup fun n hn => is_open_thickening.measurable_set\n  have hBâ‚€ : âˆ€ p, MeasurableSet (B p) := fun p =>\n    MeasurableSet.measurableSet_blimsup fun n hn => is_open_thickening.measurable_set\n  have hEâ‚€ : null_measurable_set E Î¼ :=\n    by\n    refine' (MeasurableSet.measurableSet_blimsup fun n hn => is_open.measurable_set _).null_measurable_set\n    exact is_open_thickening\n  have hEâ‚ : âˆ€ p, E = A p âˆª B p âˆª C p := by\n    intro p\n    simp only [E, add_well_approximable, â† blimsup_or_eq_sup, â† and_or_left, â† sup_eq_union, sq]\n    congr\n    refine' funext fun n => propext <| iff_self_and.mpr fun hn => _\n    -- `tauto` can finish from here but unfortunately it's very slow.\n    simp only [(em (p âˆ£ n)).symm, (em (p * p âˆ£ n)).symm, or_and_left, or_true_iff, true_and_iff, or_assoc']\n  have hEâ‚‚ :\n    âˆ€ p : Nat.Primes,\n      Â«expr =áµ[ ] Â» (A p) Î¼ (âˆ… : Set (exprğ•Š)) âˆ§ Â«expr =áµ[ ] Â» (B p) Î¼ (âˆ… : Set (exprğ•Š)) â†’ Â«expr =áµ[ ] Â» E Î¼ (C p) :=\n    by\n    rintro p âŸ¨hA, hBâŸ©\n    rw [hEâ‚ p]\n    exact union_ae_eq_right_of_ae_eq_empty ((union_ae_eq_right_of_ae_eq_empty hA).trans hB)\n  have hA : âˆ€ p : Nat.Primes, Â«expr =áµ[ ] Â» (A p) Î¼ (âˆ… : Set (exprğ•Š)) âˆ¨ Â«expr =áµ[ ] Â» (A p) Î¼ univ :=\n    by\n    rintro âŸ¨p, hpâŸ©\n    let f : exprğ•Š â†’ exprğ•Š := fun y => Â«expr â€¢ Â» (p : â„•) y\n    suffices\n      Â«expr '' Â» f (A p) âŠ†\n        blimsup (fun n => approx_add_order_of (exprğ•Š) n (p * Î´ n)) at_top fun n => 0 < n âˆ§ Â«expr âˆ¤ Â» p n\n      by\n      apply (ergodic_nsmul hp.one_lt).ae_empty_or_univ_of_image_ae_le (hAâ‚€ p)\n      apply (HasSubset.Subset.eventuallyLE this).congr eventually_eq.rfl\n      exact\n        blimsup_thickening_mul_ae_eq Î¼ (fun n => 0 < n âˆ§ Â«expr âˆ¤ Â» p n) (fun n => { y | addOrderOf y = n })\n          (nat.cast_pos.mpr hp.pos) _ hÎ´\n    refine' (Supâ‚›Hom.setImage f).apply_blimsup_le.trans (mono_blimsup fun n hn => _)\n    replace hn := nat.coprime_comm.mp (hp.coprime_iff_not_dvd.2 hn.2)\n    exact approx_add_order_of.image_nsmul_subset_of_coprime (Î´ n) hp.pos hn\n  have hB : âˆ€ p : Nat.Primes, Â«expr =áµ[ ] Â» (B p) Î¼ (âˆ… : Set (exprğ•Š)) âˆ¨ Â«expr =áµ[ ] Â» (B p) Î¼ univ :=\n    by\n    rintro âŸ¨p, hpâŸ©\n    let x := u âŸ¨p, hpâŸ©\n    let f : exprğ•Š â†’ exprğ•Š := fun y => Â«expr â€¢ Â» p y + x\n    suffices\n      Â«expr '' Â» f (B p) âŠ†\n        blimsup (fun n => approx_add_order_of (exprğ•Š) n (p * Î´ n)) at_top fun n => 0 < n âˆ§ Â«expr âˆ£âˆ£ Â» p n\n      by\n      apply (ergodic_nsmul_add x hp.one_lt).ae_empty_or_univ_of_image_ae_le (hBâ‚€ p)\n      apply (HasSubset.Subset.eventuallyLE this).congr eventually_eq.rfl\n      exact\n        blimsup_thickening_mul_ae_eq Î¼ (fun n => 0 < n âˆ§ Â«expr âˆ£âˆ£ Â» p n) (fun n => { y | addOrderOf y = n })\n          (nat.cast_pos.mpr hp.pos) _ hÎ´\n    refine' (Supâ‚›Hom.setImage f).apply_blimsup_le.trans (mono_blimsup _)\n    rintro n âŸ¨hn, h_div, h_ndivâŸ©\n    have h_cop : (addOrderOf x).coprime (n / p) :=\n      by\n      obtain âŸ¨q, rflâŸ© := h_div\n      rw [huâ‚€, Subtype.coe_mk, hp.coprime_iff_not_dvd, q.mul_div_cancel_left hp.pos]\n      exact fun contra => h_ndiv (mul_dvd_mul_left p contra)\n    replace h_div : n / p * p = n := Nat.div_mul_cancel h_div\n    have hf : f = (fun y => x + y) âˆ˜ fun y => Â«expr â€¢ Â» p y :=\n      by\n      ext\n      simp [add_comm x]\n    simp_rw [comp_app]\n    rw [le_eq_subset, Sup_hom.set_image_to_fun, hf, image_comp]\n    have := @monotone_image (exprğ•Š) (exprğ•Š) fun y => x + y\n    specialize this (approx_add_order_of.image_nsmul_subset (Î´ n) (n / p) hp.pos)\n    simp only [h_div] at thisâŠ¢\n    refine' this.trans _\n    convert approx_add_order_of.vadd_subset_of_coprime (p * Î´ n) h_cop\n    simp only [huâ‚€, Subtype.coe_mk, h_div, mul_comm p]\n  change\n    Â«exprâˆ€áµ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€áµ , Â»\" (x âˆ‰ E) âˆ¨\n      E âˆˆ volume.ae\n  rw [â† eventually_eq_empty, â† eventually_eq_univ]\n  have hC : âˆ€ p : Nat.Primes, Â«expr +áµ¥ Â» (u p) (C p) = C p :=\n    by\n    intro p\n    let e := (AddAction.toPerm (u p) : Equiv.Perm (exprğ•Š)).to_order_iso_set\n    change e (C p) = C p\n    rw [e.apply_blimsup, â† huâ‚€ p]\n    exact blimsup_congr (eventually_of_forall fun n hn => approx_add_order_of.vadd_eq_of_mul_dvd (Î´ n) hn.1 hn.2)\n  by_cases h : âˆ€ p : Nat.Primes, Â«expr =áµ[ ] Â» (A p) Î¼ (âˆ… : Set (exprğ•Š)) âˆ§ Â«expr =áµ[ ] Â» (B p) Î¼ (âˆ… : Set (exprğ•Š))\n  Â· replace h : âˆ€ p : Nat.Primes, Â«expr =áµ[ ] Â» (Â«expr +áµ¥ Â» (u p) E : Set _) Î¼ E\n    Â· intro p\n      replace hEâ‚‚ : Â«expr =áµ[ ] Â» E Î¼ (C p) := hEâ‚‚ p (h p)\n      have h_qmp : MeasureTheory.Measure.QuasiMeasurePreserving ((Â«expr +áµ¥ Â» Â· Â·) (-u p)) Î¼ Î¼ :=\n        (measure_preserving_vadd _ Î¼).quasi_measure_preserving\n      refine' (h_qmp.vadd_ae_eq_of_ae_eq (u p) hEâ‚‚).trans (ae_eq_trans _ hEâ‚‚.symm)\n      rw [hC]\n    exact ae_empty_or_univ_of_forall_vadd_ae_eq_self hEâ‚€ h hu\n  Â· right\n    simp only [not_forall, not_and_or] at h\n    obtain âŸ¨p, hpâŸ© := h\n    rw [hEâ‚ p]\n    cases hp\n    Â· cases hA p\n      Â· contradiction\n      simp only [h, union_ae_eq_univ_of_ae_eq_univ_left]\n    Â· cases hB p\n      Â· contradiction\n      simp only [h, union_ae_eq_univ_of_ae_eq_univ_left, union_ae_eq_univ_of_ae_eq_univ_right]\n#align add_well_approximable_ae_empty_or_univ add_well_approximable_ae_empty_or_univ\n\n"}