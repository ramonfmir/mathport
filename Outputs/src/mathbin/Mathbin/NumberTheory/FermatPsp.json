{"psp_from_prime_psp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≡ [ZMOD ]» -/\n/-- This is a proof that the number produced using `psp_from_prime` is actually pseudoprime to base `b`.\nThe primary purpose of this lemma is to help prove `exists_infinite_pseudoprimes`.\n\nWe use <https://primes.utm.edu/notes/proofs/a_pseudoprimes.html> as a rough outline of the proof.\n-/\nprivate theorem psp_from_prime_psp {b : ℕ} (b_ge_two : 2 ≤ b) {p : ℕ} (p_prime : p.prime) (p_gt_two : 2 < p)\n    (not_dvd : ¬p ∣ b * (b ^ 2 - 1)) : fermat_psp (psp_from_prime b p) b :=\n  by\n  unfold psp_from_prime\n  set A := (b ^ p - 1) / (b - 1)\n  set B := (b ^ p + 1) / (b + 1)\n  -- Inequalities\n  have hi_A : 1 < A := a_id_helper (nat.succ_le_iff.mp b_ge_two) (Nat.Prime.one_lt p_prime)\n  have hi_B : 1 < B := b_id_helper (nat.succ_le_iff.mp b_ge_two) p_gt_two\n  have hi_AB : 1 < A * B := one_lt_mul'' hi_A hi_B\n  have hi_b : 0 < b := by linarith\n  have hi_p : 1 ≤ p := Nat.one_le_of_lt p_gt_two\n  have hi_bsquared : 0 < b ^ 2 - 1 := by nlinarith [Nat.one_le_pow 2 b hi_b]\n  have hi_bpowtwop : 1 ≤ b ^ (2 * p) := Nat.one_le_pow (2 * p) b hi_b\n  have hi_bpowpsubone : 1 ≤ b ^ (p - 1) := Nat.one_le_pow (p - 1) b hi_b\n  -- Other useful facts\n  have p_odd : Odd p := p_prime.odd_of_ne_two p_gt_two.ne.symm\n  have AB_not_prime : ¬Nat.Prime (A * B) := Nat.not_prime_mul hi_A hi_B\n  have AB_id : A * B = (b ^ (2 * p) - 1) / (b ^ 2 - 1) := AB_id_helper _ _ b_ge_two p_odd\n  have hd : b ^ 2 - 1 ∣ b ^ (2 * p) - 1 := by simpa only [one_pow, pow_mul] using nat_sub_dvd_pow_sub_pow _ 1 p\n  -- We know that `A * B` is not prime, and that `1 < A * B`. Since two conditions of being\n  -- pseudoprime are satisfied, we only need to show that `A * B` is probable prime to base `b`\n  refine' ⟨_, AB_not_prime, hi_AB⟩\n  -- Used to prove that `2 * p * (b ^ 2 - 1) ∣ (b ^ 2 - 1) * (A * B - 1)`.\n  have ha₁ : (b ^ 2 - 1) * (A * B - 1) = b * (b ^ (p - 1) - 1) * (b ^ p + b) :=\n    by\n    apply_fun fun x => x * (b ^ 2 - 1)  at AB_id\n    rw [Nat.div_mul_cancel hd] at AB_id\n    apply_fun fun x => x - (b ^ 2 - 1)  at AB_id\n    nth_rw 2 [← one_mul (b ^ 2 - 1)] at AB_id\n    rw [← nat.mul_sub_right_distrib, mul_comm] at AB_id\n    rw [AB_id]\n    exact bp_helper hi_b hi_p\n  -- If `b` is even, then `b^p` is also even, so `2 ∣ b^p + b`\n  -- If `b` is odd, then `b^p` is also odd, so `2 ∣ b^p + b`\n  have ha₂ : 2 ∣ b ^ p + b := by\n    by_cases h : Even b\n    · replace h : 2 ∣ b := even_iff_two_dvd.mp h\n      have : p ≠ 0 := by linarith\n      have : 2 ∣ b ^ p := dvd_pow h this\n      exact dvd_add this h\n    · have h : Odd b := nat.odd_iff_not_even.mpr h\n      have : Odd (b ^ p) := Odd.pow h\n      have : Even (b ^ p + b) := Odd.add_odd this h\n      exact even_iff_two_dvd.mp this\n  -- Since `b` isn't divisible by `p`, `b` is coprime with `p`. we can use Fermat's Little Theorem\n  -- to prove this.\n  have ha₃ : p ∣ b ^ (p - 1) - 1 :=\n    by\n    have : ¬p ∣ b := mt (fun h : p ∣ b => dvd_mul_of_dvd_left h _) not_dvd\n    have : p.coprime b := or.resolve_right (Nat.coprime_or_dvd_of_prime p_prime b) this\n    have : IsCoprime (b : ℤ) ↑p := this.symm.is_coprime\n    have : «expr ≡ [ZMOD ]» (↑b ^ (p - 1)) 1 ↑p := int.modeq.pow_card_sub_one_eq_one p_prime this\n    have : ↑p ∣ ↑b ^ (p - 1) - ↑1 := Int.ModEq.dvd (Int.ModEq.symm this)\n    exact_mod_cast this\n  -- Because `p - 1` is even, there is a `c` such that `2 * c = p - 1`. `nat_sub_dvd_pow_sub_pow`\n  -- implies that `b ^ c - 1 ∣ (b ^ c) ^ 2 - 1`, and `(b ^ c) ^ 2 = b ^ (p - 1)`.\n  have ha₄ : b ^ 2 - 1 ∣ b ^ (p - 1) - 1 := by\n    cases' p_odd with k hk\n    have : 2 ∣ p - 1 := ⟨k, by simp [hk]⟩\n    cases' this with c hc\n    have : b ^ 2 - 1 ∣ (b ^ 2) ^ c - 1 := by simpa only [one_pow] using nat_sub_dvd_pow_sub_pow _ 1 c\n    have : b ^ 2 - 1 ∣ b ^ (2 * c) - 1 := by rwa [← pow_mul] at this\n    rwa [← hc] at this\n  -- Used to prove that `2 * p` divides `A * B - 1`\n  have ha₅ : 2 * p * (b ^ 2 - 1) ∣ (b ^ 2 - 1) * (A * B - 1) :=\n    by\n    suffices q : 2 * p * (b ^ 2 - 1) ∣ b * (b ^ (p - 1) - 1) * (b ^ p + b)\n    · rwa [ha₁]\n    -- We already proved that `b ^ 2 - 1 ∣ b ^ (p - 1) - 1`.\n    -- Since `2 ∣ b ^ p + b` and `p ∣ b ^ p + b`, if we show that 2 and p are coprime, then we\n    -- know that `2 * p ∣ b ^ p + b`\n    have q₁ : nat.coprime p (b ^ 2 - 1) :=\n      haveI q₂ : ¬p ∣ b ^ 2 - 1 := by\n        rw [mul_comm] at not_dvd\n        exact mt (fun h : p ∣ b ^ 2 - 1 => dvd_mul_of_dvd_left h _) not_dvd\n      (Nat.Prime.coprime_iff_not_dvd p_prime).mpr q₂\n    have q₂ : p * (b ^ 2 - 1) ∣ b ^ (p - 1) - 1 := nat.coprime.mul_dvd_of_dvd_of_dvd q₁ ha₃ ha₄\n    have q₃ : p * (b ^ 2 - 1) * 2 ∣ (b ^ (p - 1) - 1) * (b ^ p + b) := mul_dvd_mul q₂ ha₂\n    have q₄ : p * (b ^ 2 - 1) * 2 ∣ b * ((b ^ (p - 1) - 1) * (b ^ p + b)) := dvd_mul_of_dvd_right q₃ _\n    rwa [mul_assoc, mul_comm, mul_assoc b]\n  have ha₆ : 2 * p ∣ A * B - 1 := by\n    rw [mul_comm] at ha₅\n    exact Nat.dvd_of_mul_dvd_mul_left hi_bsquared ha₅\n  -- `A * B` divides `b ^ (2 * p) - 1` because `A * B * (b ^ 2 - 1) = b ^ (2 * p) - 1`.\n  -- This can be proven by multiplying both sides of `AB_id` by `b ^ 2 - 1`.\n  have ha₇ : A * B ∣ b ^ (2 * p) - 1 := by\n    use b ^ 2 - 1\n    have : A * B * (b ^ 2 - 1) = (b ^ (2 * p) - 1) / (b ^ 2 - 1) * (b ^ 2 - 1) :=\n      congr_arg (fun x : ℕ => x * (b ^ 2 - 1)) AB_id\n    simpa only [add_comm, Nat.div_mul_cancel hd, nat.sub_add_cancel hi_bpowtwop] using this.symm\n  -- Since `2 * p ∣ A * B - 1`, there is a number `q` such that `2 * p * q = A * B - 1`.\n  -- By `nat_sub_dvd_pow_sub_pow`, we know that `b ^ (2 * p) - 1 ∣ b ^ (2 * p * q) - 1`.\n  -- This means that `b ^ (2 * p) - 1 ∣ b ^ (A * B - 1) - 1`.\n  cases' ha₆ with q hq\n  have ha₈ : b ^ (2 * p) - 1 ∣ b ^ (A * B - 1) - 1 := by\n    simpa only [one_pow, pow_mul, hq] using nat_sub_dvd_pow_sub_pow _ 1 q\n  -- We have proved that `A * B ∣ b ^ (2 * p) - 1` and `b ^ (2 * p) - 1 ∣ b ^ (A * B - 1) - 1`.\n  -- Therefore, `A * B ∣ b ^ (A * B - 1) - 1`.\n  exact dvd_trans ha₇ ha₈\n#align psp_from_prime_psp psp_from_prime_psp\n\n",
 "psp_from_prime_gt_p":
 "/-- This is a proof that the number produced using `psp_from_prime` is greater than the prime `p` used\nto create it. The primary purpose of this lemma is to help prove `exists_infinite_pseudoprimes`.\n-/\nprivate theorem psp_from_prime_gt_p {b : ℕ} (b_ge_two : 2 ≤ b) {p : ℕ} (p_prime : p.prime) (p_gt_two : 2 < p) :\n    p < psp_from_prime b p := by\n  unfold psp_from_prime\n  set A := (b ^ p - 1) / (b - 1)\n  set B := (b ^ p + 1) / (b + 1)\n  rw [show A * B = (b ^ (2 * p) - 1) / (b ^ 2 - 1) from\n      AB_id_helper _ _ b_ge_two (p_prime.odd_of_ne_two p_gt_two.ne.symm)]\n  have AB_dvd : b ^ 2 - 1 ∣ b ^ (2 * p) - 1 := by simpa only [one_pow, pow_mul] using nat_sub_dvd_pow_sub_pow _ 1 p\n  suffices h : p * (b ^ 2 - 1) < b ^ (2 * p) - 1\n  · have h₁ : p * (b ^ 2 - 1) / (b ^ 2 - 1) < (b ^ (2 * p) - 1) / (b ^ 2 - 1) := Nat.div_lt_div_of_lt_of_dvd AB_dvd h\n    have h₂ : 0 < b ^ 2 - 1 := by\n      linarith [show 3 ≤ b ^ 2 - 1 from le_tsub_of_add_le_left (show 4 ≤ b ^ 2 by nlinarith)]\n    rwa [nat.mul_div_cancel _ h₂] at h₁\n  rw [nat.mul_sub_left_distrib, mul_one, pow_mul]\n  nth_rw_rhs 1 [← nat.sub_add_cancel (show 1 ≤ p by linarith)]\n  rw [pow_succ (b ^ 2)]\n  suffices h : p * b ^ 2 < b ^ 2 * (b ^ 2) ^ (p - 1)\n  · apply gt_of_ge_of_gt\n    · exact tsub_le_tsub_left (show 1 ≤ p by linarith) (b ^ 2 * (b ^ 2) ^ (p - 1))\n    · have : p ≤ p * b ^ 2 := Nat.le_mul_of_pos_right (show 0 < b ^ 2 by nlinarith)\n      exact tsub_lt_tsub_right_of_le this h\n  suffices h : p < (b ^ 2) ^ (p - 1)\n  · rw [mul_comm (b ^ 2)]\n    have : 4 ≤ b ^ 2 := by nlinarith\n    have : 0 < b ^ 2 := by linarith\n    exact mul_lt_mul_of_pos_right h this\n  rw [← pow_mul, nat.mul_sub_left_distrib, mul_one]\n  have : 2 ≤ 2 * p - 2 := le_tsub_of_add_le_left (show 4 ≤ 2 * p by linarith)\n  have : 2 + p ≤ 2 * p := by linarith\n  have : p ≤ 2 * p - 2 := le_tsub_of_add_le_left this\n  exact nat.lt_of_le_of_lt this (pow_gt_exponent _ b_ge_two)\n#align psp_from_prime_gt_p psp_from_prime_gt_p\n\n",
 "probable_prime_iff_modeq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≡ [MOD ]» -/\ntheorem probable_prime_iff_modeq (n : ℕ) {b : ℕ} (h : 1 ≤ b) : probable_prime n b ↔ «expr ≡ [MOD ]» (b ^ (n - 1)) 1 n :=\n  by\n  have : 1 ≤ b ^ (n - 1) := one_le_pow_of_one_le h (n - 1)\n  -- For exact_mod_cast\n  rw [Nat.ModEq.comm]\n  constructor\n  · intro h₁\n    apply Nat.modEq_of_dvd\n    exact_mod_cast h₁\n  · intro h₁\n    exact_mod_cast Nat.ModEq.dvd h₁\n#align probable_prime_iff_modeq probable_prime_iff_modeq\n\n",
 "pow_gt_exponent":
 "-- Lemmas that are needed to prove statements in this file, but aren't directly related to Fermat\n-- pseudoprimes\nprivate theorem pow_gt_exponent {a : ℕ} (b : ℕ) (h : 2 ≤ a) : b < a ^ b :=\n  lt_of_lt_of_le (Nat.lt_two_pow b) <| Nat.pow_le_pow_of_le_left h _\n#align pow_gt_exponent pow_gt_exponent\n\n",
 "infinite_set_of_prime_modeq_one":
 "/-- Infinite set variant of `exists_infinite_pseudoprimes`\n-/\ntheorem infinite_set_of_prime_modeq_one {b : ℕ} (h : 1 ≤ b) : set.infinite { n : ℕ | fermat_psp n b } :=\n  nat.frequently_at_top_iff_infinite.mp (frequently_at_top_fermat_psp h)\n#align infinite_set_of_prime_modeq_one infinite_set_of_prime_modeq_one\n\n",
 "frequently_at_top_fermat_psp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , » -/\ntheorem frequently_at_top_fermat_psp {b : ℕ} (h : 1 ≤ b) :\n    «expr∃ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , »\"\n      filter.at_top (fermat_psp n b) :=\n  by\n  -- Based on the proof of `nat.frequently_at_top_modeq_one`\n  refine' filter.frequently_at_top.2 fun n => _\n  obtain ⟨p, hp⟩ := exists_infinite_pseudoprimes h n\n  exact ⟨p, hp.2, hp.1⟩\n#align frequently_at_top_fermat_psp frequently_at_top_fermat_psp\n\n",
 "exists_infinite_pseudoprimes":
 "/-- For all positive bases, there exist Fermat infinite pseudoprimes to that base.\nGiven in this form: for all numbers `b ≥ 1` and `m`, there exists a pseudoprime `n` to base `b` such\nthat `m ≤ n`. This form is similar to `nat.exists_infinite_primes`.\n-/\ntheorem exists_infinite_pseudoprimes {b : ℕ} (h : 1 ≤ b) (m : ℕ) : ∃ n : ℕ, fermat_psp n b ∧ m ≤ n :=\n  by\n  by_cases b_ge_two : 2 ≤ b\n  -- If `2 ≤ b`, then because there exist infinite prime numbers, there is a prime number p such\n  -- `m ≤ p` and `¬p ∣ b*(b^2 - 1)`. We pick a prime number `b*(b^2 - 1) + 1 + m ≤ p` because we\n  -- automatically know that `p` is greater than m and that it does not divide `b*(b^2 - 1)`\n  -- (because `p` can't divide a number less than `p`).\n  -- From `p`, we can use the lemmas we proved earlier to show that\n  -- `((b^p - 1)/(b - 1)) * ((b^p + 1)/(b + 1))` is a pseudoprime to base `b`.\n  · have h := Nat.exists_infinite_primes (b * (b ^ 2 - 1) + 1 + m)\n    cases' h with p hp\n    cases' hp with hp₁ hp₂\n    have h₁ : 0 < b := pos_of_gt (nat.succ_le_iff.mp b_ge_two)\n    have h₂ : 4 ≤ b ^ 2 := pow_le_pow_of_le_left' b_ge_two 2\n    have h₃ : 0 < b ^ 2 - 1 := tsub_pos_of_lt (gt_of_ge_of_gt h₂ (by norm_num))\n    have h₄ : 0 < b * (b ^ 2 - 1) := mul_pos h₁ h₃\n    have h₅ : b * (b ^ 2 - 1) < p := by linarith\n    have h₆ : ¬p ∣ b * (b ^ 2 - 1) := Nat.not_dvd_of_pos_of_lt h₄ h₅\n    have h₇ : b ≤ b * (b ^ 2 - 1) := Nat.le_mul_of_pos_right h₃\n    have h₈ : 2 ≤ b * (b ^ 2 - 1) := le_trans b_ge_two h₇\n    have h₉ : 2 < p := gt_of_gt_of_ge h₅ h₈\n    have h₁₀ := psp_from_prime_gt_p b_ge_two hp₂ h₉\n    use psp_from_prime b p\n    constructor\n    · exact psp_from_prime_psp b_ge_two hp₂ h₉ h₆\n    · exact le_trans (show m ≤ p by linarith) (le_of_lt h₁₀)\n  -- If `¬2 ≤ b`, then `b = 1`. Since all composite numbers are pseudoprimes to base 1, we can pick\n  -- any composite number greater than m. We choose `2 * (m + 2)` because it is greater than `m` and\n  -- is composite for all natural numbers `m`.\n  · have h₁ : b = 1 := by linarith\n    rw [h₁]\n    use 2 * (m + 2)\n    have : ¬Nat.Prime (2 * (m + 2)) := Nat.not_prime_mul (by norm_num) (by norm_num)\n    exact ⟨base_one (by linarith) this, by linarith⟩\n#align exists_infinite_pseudoprimes exists_infinite_pseudoprimes\n\n",
 "coprime_of_probable_prime":
 "/-\nCopyright (c) 2022 Niels Voss. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Niels Voss\n-/\n/-- If `n` passes the Fermat primality test to base `b`, then `n` is coprime with `b`, assuming that\n`n` and `b` are both positive.\n-/\ntheorem coprime_of_probable_prime {n b : ℕ} (h : probable_prime n b) (h₁ : 1 ≤ n) (h₂ : 1 ≤ b) : nat.coprime n b :=\n  by\n  by_cases h₃ : 2 ≤ n\n  · -- To prove that `n` is coprime with `b`, we we need to show that for all prime factors of `n`,\n    -- we can derive a contradiction if `n` divides `b`.\n    apply Nat.coprime_of_dvd\n    -- If `k` is a prime number that divides both `n` and `b`, then we know that `n = m * k` and\n    -- `b = j * k` for some natural numbers `m` and `j`. We substitute these into the hypothesis.\n    rintro k hk ⟨m, rfl⟩ ⟨j, rfl⟩\n    -- Because prime numbers do not divide 1, it suffices to show that `k ∣ 1` to prove a\n    -- contradiction\n    apply Nat.Prime.not_dvd_one hk\n    -- Since `n` divides `b ^ (n - 1) - 1`, `k` also divides `b ^ (n - 1) - 1`\n    replace h := dvd_of_mul_right_dvd h\n    -- Because `k` divides `b ^ (n - 1) - 1`, if we can show that `k` also divides `b ^ (n - 1)`,\n    -- then we know `k` divides 1.\n    rw [nat.dvd_add_iff_right h, nat.sub_add_cancel (Nat.one_le_pow _ _ h₂)]\n    -- Since `k` divides `b`, `k` also divides any power of `b` except `b ^ 0`. Therefore, it\n    -- suffices to show that `n - 1` isn't zero. However, we know that `n - 1` isn't zero because we\n    -- assumed `2 ≤ n` when doing `by_cases`.\n    refine' dvd_of_mul_right_dvd (dvd_pow_self (k * j) _)\n    linarith\n  -- If `n = 1`, then it follows trivially that `n` is coprime with `b`.\n  · rw [show n = 1 by linarith]\n    norm_num\n#align coprime_of_probable_prime coprime_of_probable_prime\n\n",
 "coprime_of_fermat_psp":
 "/-- If `n` is a Fermat pseudoprime to base `b`, then `n` is coprime with `b`, assuming that `b` is\npositive.\n\nThis lemma is a small wrapper based on `coprime_of_probable_prime`\n-/\ntheorem coprime_of_fermat_psp {n b : ℕ} (h : fermat_psp n b) (h₁ : 1 ≤ b) : nat.coprime n b :=\n  by\n  rcases h with ⟨hp, hn₁, hn₂⟩\n  exact coprime_of_probable_prime hp (by linarith) h₁\n#align coprime_of_fermat_psp coprime_of_fermat_psp\n\n",
 "bp_helper":
 "/-- Used in the proof of `psp_from_prime_psp`\n-/\nprivate theorem bp_helper {b p : ℕ} (hb : 0 < b) (hp : 1 ≤ p) :\n    b ^ (2 * p) - 1 - (b ^ 2 - 1) = b * (b ^ (p - 1) - 1) * (b ^ p + b) :=\n  have hi_bsquared : 1 ≤ b ^ 2 := Nat.one_le_pow _ _ hb\n  calc\n    b ^ (2 * p) - 1 - (b ^ 2 - 1) = b ^ (2 * p) - (1 + (b ^ 2 - 1)) := by rw [nat.sub_sub]\n    _ = b ^ (2 * p) - (1 + b ^ 2 - 1) := by rw [nat.add_sub_assoc hi_bsquared]\n    _ = b ^ (2 * p) - b ^ 2 := by rw [nat.add_sub_cancel_left]\n    _ = b ^ (p * 2) - b ^ 2 := by rw [mul_comm]\n    _ = (b ^ p) ^ 2 - b ^ 2 := by rw [pow_mul]\n    _ = (b ^ p + b) * (b ^ p - b) := by rw [Nat.sq_sub_sq]\n    _ = (b ^ p - b) * (b ^ p + b) := by rw [mul_comm]\n    _ = (b ^ (p - 1 + 1) - b) * (b ^ p + b) := by rw [nat.sub_add_cancel hp]\n    _ = (b * b ^ (p - 1) - b) * (b ^ p + b) := by rw [pow_succ]\n    _ = (b * b ^ (p - 1) - b * 1) * (b ^ p + b) := by rw [mul_one]\n    _ = b * (b ^ (p - 1) - 1) * (b ^ p + b) := by rw [nat.mul_sub_left_distrib]\n    \n#align bp_helper bp_helper\n\n",
 "base_one":
 "/-- All composite numbers are Fermat pseudoprimes to base 1.\n-/\ntheorem base_one {n : ℕ} (h₁ : 1 < n) (h₂ : ¬n.prime) : fermat_psp n 1 :=\n  by\n  refine' ⟨show n ∣ 1 ^ (n - 1) - 1 from _, h₂, h₁⟩\n  exact show 0 = 1 ^ (n - 1) - 1 by norm_num ▸ dvd_zero n\n#align base_one base_one\n\n",
 "b_id_helper":
 "private theorem b_id_helper {a b : ℕ} (ha : 2 ≤ a) (hb : 2 < b) : 2 ≤ (a ^ b + 1) / (a + 1) :=\n  by\n  rw [nat.le_div_iff_mul_le (nat.zero_lt_succ _)]\n  apply nat.succ_le_succ\n  calc\n    2 * a + 1 ≤ a ^ 2 * a := by nlinarith\n    _ = a ^ 3 := by rw [pow_succ' a 2]\n    _ ≤ a ^ b := pow_le_pow (nat.le_of_succ_le ha) hb\n    \n#align b_id_helper b_id_helper\n\n",
 "a_id_helper":
 "private theorem a_id_helper {a b : ℕ} (ha : 2 ≤ a) (hb : 2 ≤ b) : 2 ≤ (a ^ b - 1) / (a - 1) :=\n  by\n  change 1 < _\n  have h₁ : a - 1 ∣ a ^ b - 1 := by simpa only [one_pow] using nat_sub_dvd_pow_sub_pow a 1 b\n  rw [Nat.lt_div_iff_mul_lt h₁, mul_one, tsub_lt_tsub_iff_right (nat.le_of_succ_le ha)]\n  convert pow_lt_pow (nat.lt_of_succ_le ha) hb\n  rw [pow_one]\n#align a_id_helper a_id_helper\n\n",
 "AB_id_helper":
 "private theorem AB_id_helper (b p : ℕ) (hb : 2 ≤ b) (hp : Odd p) :\n    (b ^ p - 1) / (b - 1) * ((b ^ p + 1) / (b + 1)) = (b ^ (2 * p) - 1) / (b ^ 2 - 1) :=\n  by\n  have q₁ : b - 1 ∣ b ^ p - 1 := by simpa only [one_pow] using nat_sub_dvd_pow_sub_pow b 1 p\n  have q₂ : b + 1 ∣ b ^ p + 1 := by simpa only [one_pow] using hp.nat_add_dvd_pow_add_pow b 1\n  convert Nat.div_mul_div_comm q₁ q₂ <;> rw [mul_comm (_ - 1), ← Nat.sq_sub_sq]\n  · ring\n  · simp\n#align AB_id_helper AB_id_helper\n\n"}