{"zero":
 "#print PythagoreanTriple.zero /-\n/-- The zeroth Pythagorean triple is all zeros. -/\ntheorem PythagoreanTriple.zero : PythagoreanTriple 0 0 0 := by\n  simp only [PythagoreanTriple, MulZeroClass.zero_mul, zero_add]\n#align pythagorean_triple.zero PythagoreanTriple.zero\n-/\n\n",
 "symm":
 "#print symm /-\n@[symm]\ntheorem symm : PythagoreanTriple y x z := by rwa [pythagoreanTriple_comm]\n#align symm symm\n-/\n\n",
 "sq_ne_two_mod_four":
 "#print Int.sq_ne_two_mod_four /-\ntheorem Int.sq_ne_two_mod_four (z : ℤ) : z * z % 4 ≠ 2 :=\n  by\n  suffices ¬z * z % (4 : ℕ) = 2 % (4 : ℕ) by norm_num at this\n  rw [← ZMod.int_cast_eq_int_cast_iff']\n  simpa using sq_ne_two_fin_zmod_four _\n#align int.sq_ne_two_mod_four Int.sq_ne_two_mod_four\n-/\n\n",
 "sq_ne_two_fin_zmod_four":
 "#print sq_ne_two_fin_zmod_four /-\n/-\nCopyright (c) 2020 Paul van Wamelen. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Paul van Wamelen\n-/\ntheorem sq_ne_two_fin_zmod_four (z : ZMod 4) : z * z ≠ 2 :=\n  by\n  change Fin 4 at z\n  fin_cases z <;> norm_num [Fin.ext_iff, Fin.val_bit0, Fin.val_bit1]\n#align sq_ne_two_fin_zmod_four sq_ne_two_fin_zmod_four\n-/\n\n",
 "pythagoreanTriple_comm":
 "#print pythagoreanTriple_comm /-\n/-- Pythagorean triples are interchangable, i.e `x * x + y * y = y * y + x * x = z * z`.\nThis comes from additive commutativity. -/\ntheorem pythagoreanTriple_comm {x y z : ℤ} : PythagoreanTriple x y z ↔ PythagoreanTriple y x z :=\n  by\n  delta PythagoreanTriple\n  rw [add_comm]\n#align pythagorean_triple_comm pythagoreanTriple_comm\n-/\n\n",
 "normalize":
 "#print normalize /-\ntheorem normalize : PythagoreanTriple (x / int.gcd x y) (y / int.gcd x y) (z / int.gcd x y) :=\n  by\n  by_cases h0 : int.gcd x y = 0\n  · have hx : x = 0 := by\n      apply int.nat_abs_eq_zero.mp\n      apply Nat.eq_zero_of_gcd_eq_zero_left h0\n    have hy : y = 0 := by\n      apply int.nat_abs_eq_zero.mp\n      apply Nat.eq_zero_of_gcd_eq_zero_right h0\n    have hz : z = 0 := by\n      simpa only [PythagoreanTriple, hx, hy, add_zero, zero_eq_mul, MulZeroClass.mul_zero, or_self_iff] using h\n    simp only [hx, hy, hz, Int.zero_div]\n    exact zero\n  rcases h.gcd_dvd with ⟨z0, rfl⟩\n  obtain ⟨k, x0, y0, k0, h2, rfl, rfl⟩ : ∃ (k : ℕ)(x0 y0 : _), 0 < k ∧ int.gcd x0 y0 = 1 ∧ x = x0 * k ∧ y = y0 * k :=\n    Int.exists_gcd_one' (nat.pos_of_ne_zero h0)\n  have hk : (k : ℤ) ≠ 0 := by\n    norm_cast\n    rwa [pos_iff_ne_zero] at k0\n  rw [Int.gcd_mul_right, h2, Int.natAbs_ofNat, one_mul] at h⊢\n  rw [mul_comm x0, mul_comm y0, mul_iff k hk] at h\n  rwa [Int.mul_ediv_cancel _ hk, Int.mul_ediv_cancel _ hk, Int.mul_ediv_cancel_left _ hk]\n#align normalize normalize\n-/\n\n",
 "ne_zero_of_coprime":
 "theorem ne_zero_of_coprime (hc : int.gcd x y = 1) : z ≠ 0 :=\n  by\n  suffices 0 < z * z by\n    rintro rfl\n    norm_num at this\n  rw [← h.eq, ← sq, ← sq]\n  have hc' : int.gcd x y ≠ 0 := by\n    rw [hc]\n    exact one_ne_zero\n  cases' Int.ne_zero_of_gcd hc' with hxz hyz\n  · apply lt_add_of_pos_of_le (sq_pos_of_ne_zero x hxz) (sq_nonneg y)\n  · apply lt_add_of_le_of_pos (sq_nonneg x) (sq_pos_of_ne_zero y hyz)\n#align ne_zero_of_coprime ne_zero_of_coprime\n\n",
 "mul_is_classified":
 "theorem mul_is_classified (k : ℤ) (hc : h.is_classified) : (h.mul k).is_classified :=\n  by\n  obtain ⟨l, m, n, ⟨⟨rfl, rfl⟩ | ⟨rfl, rfl⟩, co⟩⟩ := hc\n  · use k * l, m, n\n    apply and.intro _ co\n    left\n    constructor <;> ring\n  · use k * l, m, n\n    apply and.intro _ co\n    right\n    constructor <;> ring\n#align mul_is_classified mul_is_classified\n\n",
 "mul_iff":
 "/-- `(k*x, k*y, k*z)` is a Pythagorean triple if and only if\n`(x, y, z)` is also a triple. -/\ntheorem mul_iff (k : ℤ) (hk : k ≠ 0) : PythagoreanTriple (k * x) (k * y) (k * z) ↔ PythagoreanTriple x y z :=\n  by\n  refine' ⟨_, fun h => h.mul k⟩\n  simp only [PythagoreanTriple]\n  intro h\n  rw [← mul_left_inj' (mul_ne_zero hk hk)]\n  convert h using 1 <;> ring\n#align mul_iff mul_iff\n\n",
 "mul":
 "/-- A triple is still a triple if you multiply `x`, `y` and `z`\nby a constant `k`. -/\ntheorem mul (k : ℤ) : PythagoreanTriple (k * x) (k * y) (k * z) :=\n  calc\n    k * x * (k * x) + k * y * (k * y) = k ^ 2 * (x * x + y * y) := by ring\n    _ = k ^ 2 * (z * z) := by rw [h.eq]\n    _ = k * z * (k * z) := by ring\n    \n#align mul mul\n\n",
 "is_primitive_classified_of_coprime_of_zero_left":
 "theorem is_primitive_classified_of_coprime_of_zero_left (hc : int.gcd x y = 1) (hx : x = 0) :\n    h.is_primitive_classified := by\n  subst x\n  change Nat.gcd 0 (Int.natAbs y) = 1 at hc\n  rw [Nat.gcd_zero_left (Int.natAbs y)] at hc\n  cases' Int.natAbs_eq y with hy hy\n  · use 1, 0\n    rw [hy, hc, Int.gcd_zero_right]\n    norm_num\n  · use 0, 1\n    rw [hy, hc, Int.gcd_zero_left]\n    norm_num\n#align is_primitive_classified_of_coprime_of_zero_left is_primitive_classified_of_coprime_of_zero_left\n\n",
 "is_primitive_classified_of_coprime_of_pos":
 "theorem is_primitive_classified_of_coprime_of_pos (hc : int.gcd x y = 1) (hzpos : 0 < z) : h.is_primitive_classified :=\n  by\n  cases' h.even_odd_of_coprime hc with h1 h2\n  · exact h.is_primitive_classified_of_coprime_of_odd_of_pos hc h1.right hzpos\n  rw [Int.gcd_comm] at hc\n  obtain ⟨m, n, H⟩ := h.symm.is_primitive_classified_of_coprime_of_odd_of_pos hc h2.left hzpos\n  use m, n; tauto\n#align is_primitive_classified_of_coprime_of_pos is_primitive_classified_of_coprime_of_pos\n\n",
 "is_primitive_classified_of_coprime_of_odd_of_pos":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Tactic/Lean3.lean:132:4: warning: unsupported: rw with cfg: { occs := occurrences.pos[occurrences.pos] «expr[ ,]»([2, 3]) } -/\ntheorem is_primitive_classified_of_coprime_of_odd_of_pos (hc : int.gcd x y = 1) (hyo : y % 2 = 1) (hzpos : 0 < z) :\n    h.is_primitive_classified := by\n  by_cases h0 : x = 0\n  · exact h.is_primitive_classified_of_coprime_of_zero_left hc h0\n  let v := (x : exprℚ) / z\n  let w := (y : exprℚ) / z\n  have hz : z ≠ 0\n  apply ne_of_gt hzpos\n  have hq : v ^ 2 + w ^ 2 = 1 := by\n    field_simp [hz, sq]\n    norm_cast\n    exact h\n  have hvz : v ≠ 0 := by\n    field_simp [hz]\n    exact h0\n  have hw1 : w ≠ -1 := by\n    contrapose! hvz with hw1\n    rw [hw1, neg_sq, one_pow, add_left_eq_self] at hq\n    exact pow_eq_zero hq\n  have hQ : ∀ x : exprℚ, 1 + x ^ 2 ≠ 0 := by\n    intro q\n    apply ne_of_gt\n    exact lt_add_of_pos_of_le zero_lt_one (sq_nonneg q)\n  have hp : (⟨v, w⟩ : exprℚ × exprℚ) ∈ { p : exprℚ × exprℚ | p.1 ^ 2 + p.2 ^ 2 = 1 ∧ p.2 ≠ -1 } := ⟨hq, hw1⟩\n  let q := (circleEquivGen hQ).symm ⟨⟨v, w⟩, hp⟩\n  have ht4 : v = 2 * q / (1 + q ^ 2) ∧ w = (1 - q ^ 2) / (1 + q ^ 2) :=\n    by\n    apply prod.mk.inj\n    have := ((circleEquivGen hQ).apply_symm_apply ⟨⟨v, w⟩, hp⟩).symm\n    exact congr_arg Subtype.val this\n  let m := (q.denom : ℤ)\n  let n := q.num\n  have hm0 : m ≠ 0 := by\n    norm_cast\n    apply Rat.den_nz q\n  have hq2 : q = n / m := (Rat.num_div_den q).symm\n  have hm2n2 : 0 < m ^ 2 + n ^ 2 := by\n    apply lt_add_of_pos_of_le _ (sq_nonneg n)\n    exact lt_of_le_of_ne (sq_nonneg m) (ne.symm (pow_ne_zero 2 hm0))\n  have hw2 : w = (m ^ 2 - n ^ 2) / (m ^ 2 + n ^ 2) :=\n    by\n    rw [ht4.2, hq2]\n    field_simp [hm2n2, Rat.den_nz q, -Rat.num_div_den]\n  have hm2n20 : (m : exprℚ) ^ 2 + (n : exprℚ) ^ 2 ≠ 0 :=\n    by\n    norm_cast\n    simpa only [Int.coe_nat_pow] using ne_of_gt hm2n2\n  have hv2 : v = 2 * m * n / (m ^ 2 + n ^ 2) := by\n    apply Eq.symm\n    apply (div_eq_iff hm2n20).mpr\n    rw [ht4.1]\n    field_simp [hQ q]\n    rw [hq2]\n    field_simp [Rat.den_nz q, -Rat.num_div_den]\n    ring\n  have hnmcp : int.gcd n m = 1 := q.cop\n  have hmncp : int.gcd m n = 1 := by\n    rw [Int.gcd_comm]\n    exact hnmcp\n  cases' Int.emod_two_eq_zero_or_one m with hm2 hm2 <;> cases' Int.emod_two_eq_zero_or_one n with hn2 hn2\n  · -- m even, n even\n    exfalso\n    have h1 : 2 ∣ (int.gcd n m : ℤ) := Int.dvd_gcd (Int.dvd_of_emod_eq_zero hn2) (Int.dvd_of_emod_eq_zero hm2)\n    rw [hnmcp] at h1\n    revert h1\n    norm_num\n  · -- m even, n odd\n    apply h.is_primitive_classified_aux hc hzpos hm2n2 hv2 hw2 _ hmncp\n    · apply or.intro_left\n      exact and.intro hm2 hn2\n    · apply coprime_sq_sub_sq_add_of_even_odd hmncp hm2 hn2\n  · -- m odd, n even\n    apply h.is_primitive_classified_aux hc hzpos hm2n2 hv2 hw2 _ hmncp\n    · apply Or.intro_right\n      exact and.intro hm2 hn2\n    apply coprime_sq_sub_sq_add_of_odd_even hmncp hm2 hn2\n  · -- m odd, n odd\n    exfalso\n    have h1 :\n      2 ∣ m ^ 2 + n ^ 2 ∧\n        2 ∣ m ^ 2 - n ^ 2 ∧ (m ^ 2 - n ^ 2) / 2 % 2 = 0 ∧ int.gcd ((m ^ 2 - n ^ 2) / 2) ((m ^ 2 + n ^ 2) / 2) = 1 :=\n      coprime_sq_sub_sq_sum_of_odd_odd hmncp hm2 hn2\n    have h2 : y = (m ^ 2 - n ^ 2) / 2 ∧ z = (m ^ 2 + n ^ 2) / 2 :=\n      by\n      apply Rat.div_int_inj hzpos _ (h.coprime_of_coprime hc) h1.2.2.2\n      · show w = _\n        rw [← Rat.divInt_eq_div, ← Rat.divInt_mul_right (by norm_num : (2 : ℤ) ≠ 0)]\n        rw [Int.ediv_mul_cancel h1.1, Int.ediv_mul_cancel h1.2.1, hw2]\n        norm_cast\n      · apply (mul_lt_mul_right (by norm_num : 0 < (2 : ℤ))).mp\n        rw [Int.ediv_mul_cancel h1.1, MulZeroClass.zero_mul]\n        exact hm2n2\n    rw [h2.1, h1.2.2.1] at hyo\n    revert hyo\n    norm_num\n#align is_primitive_classified_of_coprime_of_odd_of_pos is_primitive_classified_of_coprime_of_odd_of_pos\n\n",
 "is_primitive_classified_of_coprime":
 "theorem is_primitive_classified_of_coprime (hc : int.gcd x y = 1) : h.is_primitive_classified :=\n  by\n  by_cases hz : 0 < z\n  · exact h.is_primitive_classified_of_coprime_of_pos hc hz\n  have h' : PythagoreanTriple x y (-z) := by simpa [PythagoreanTriple, neg_mul_neg] using h.eq\n  apply h'.is_primitive_classified_of_coprime_of_pos hc\n  apply lt_of_le_of_ne _ (h'.ne_zero_of_coprime hc).symm\n  exact le_neg.mp (not_lt.mp hz)\n#align is_primitive_classified_of_coprime is_primitive_classified_of_coprime\n\n",
 "is_primitive_classified_aux":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\ntheorem is_primitive_classified_aux (hc : x.gcd y = 1) (hzpos : 0 < z) {m n : ℤ} (hm2n2 : 0 < m ^ 2 + n ^ 2)\n    (hv2 : (x : exprℚ) / z = 2 * m * n / (m ^ 2 + n ^ 2)) (hw2 : (y : exprℚ) / z = (m ^ 2 - n ^ 2) / (m ^ 2 + n ^ 2))\n    (H : int.gcd (m ^ 2 - n ^ 2) (m ^ 2 + n ^ 2) = 1) (co : int.gcd m n = 1)\n    (pp : m % 2 = 0 ∧ n % 2 = 1 ∨ m % 2 = 1 ∧ n % 2 = 0) : h.is_primitive_classified :=\n  by\n  have hz : z ≠ 0\n  apply ne_of_gt hzpos\n  have h2 : y = m ^ 2 - n ^ 2 ∧ z = m ^ 2 + n ^ 2 :=\n    by\n    apply Rat.div_int_inj hzpos hm2n2 (h.coprime_of_coprime hc) H\n    rw [hw2]\n    norm_cast\n  use m, n\n  apply and.intro _ (and.intro co pp)\n  right\n  refine' ⟨_, h2.left⟩\n  rw [← Rat.coe_int_inj _ _, ← div_left_inj' ((mt (Rat.coe_int_inj z 0).mp) hz), hv2, h2.right]\n  norm_cast\n#align is_primitive_classified_aux is_primitive_classified_aux\n\n",
 "is_classified_of_normalize_is_primitive_classified":
 "theorem is_classified_of_normalize_is_primitive_classified (hc : h.normalize.is_primitive_classified) :\n    h.is_classified :=\n  by\n  convert h.normalize.mul_is_classified (int.gcd x y) (is_classified_of_is_primitive_classified h.normalize hc) <;>\n    rw [Int.mul_ediv_cancel']\n  · exact Int.gcd_dvd_left x y\n  · exact Int.gcd_dvd_right x y\n  · exact h.gcd_dvd\n#align is_classified_of_normalize_is_primitive_classified is_classified_of_normalize_is_primitive_classified\n\n",
 "is_classified_of_is_primitive_classified":
 "theorem is_classified_of_is_primitive_classified (hp : h.is_primitive_classified) : h.is_classified :=\n  by\n  obtain ⟨m, n, H⟩ := hp\n  use 1, m, n\n  rcases H with ⟨t, co, pp⟩\n  rw [one_mul, one_mul]\n  exact ⟨t, co⟩\n#align is_classified_of_is_primitive_classified is_classified_of_is_primitive_classified\n\n",
 "gcd_dvd":
 "theorem gcd_dvd : (int.gcd x y : ℤ) ∣ z := by\n  by_cases h0 : int.gcd x y = 0\n  · have hx : x = 0 := by\n      apply int.nat_abs_eq_zero.mp\n      apply Nat.eq_zero_of_gcd_eq_zero_left h0\n    have hy : y = 0 := by\n      apply int.nat_abs_eq_zero.mp\n      apply Nat.eq_zero_of_gcd_eq_zero_right h0\n    have hz : z = 0 := by\n      simpa only [PythagoreanTriple, hx, hy, add_zero, zero_eq_mul, MulZeroClass.mul_zero, or_self_iff] using h\n    simp only [hz, dvd_zero]\n  obtain ⟨k, x0, y0, k0, h2, rfl, rfl⟩ : ∃ (k : ℕ)(x0 y0 : _), 0 < k ∧ int.gcd x0 y0 = 1 ∧ x = x0 * k ∧ y = y0 * k :=\n    Int.exists_gcd_one' (nat.pos_of_ne_zero h0)\n  rw [Int.gcd_mul_right, h2, Int.natAbs_ofNat, one_mul]\n  rw [← Int.pow_dvd_pow_iff zero_lt_two, sq z, ← h.eq]\n  rw [(by ring : x0 * k * (x0 * k) + y0 * k * (y0 * k) = k ^ 2 * (x0 * x0 + y0 * y0))]\n  exact dvd_mul_right _ _\n#align gcd_dvd gcd_dvd\n\n",
 "even_odd_of_coprime":
 "theorem even_odd_of_coprime (hc : int.gcd x y = 1) : x % 2 = 0 ∧ y % 2 = 1 ∨ x % 2 = 1 ∧ y % 2 = 0 :=\n  by\n  cases' Int.emod_two_eq_zero_or_one x with hx hx <;> cases' Int.emod_two_eq_zero_or_one y with hy hy\n  · -- x even, y even\n    exfalso\n    apply Nat.not_coprime_of_dvd_of_dvd (by decide : 1 < 2) _ _ hc\n    · apply Int.coe_nat_dvd_left.1\n      apply Int.dvd_of_emod_eq_zero hx\n    · apply Int.coe_nat_dvd_left.1\n      apply Int.dvd_of_emod_eq_zero hy\n  · left\n    exact ⟨hx, hy⟩\n  -- x even, y odd\n  · right\n    exact ⟨hx, hy⟩\n  -- x odd, y even\n  · -- x odd, y odd\n    exfalso\n    obtain ⟨x0, y0, rfl, rfl⟩ : ∃ x0 y0, x = x0 * 2 + 1 ∧ y = y0 * 2 + 1 :=\n      by\n      cases' exists_eq_mul_left_of_dvd (Int.dvd_sub_of_emod_eq hx) with x0 hx2\n      cases' exists_eq_mul_left_of_dvd (Int.dvd_sub_of_emod_eq hy) with y0 hy2\n      rw [sub_eq_iff_eq_add] at hx2 hy2\n      exact ⟨x0, y0, hx2, hy2⟩\n    apply Int.sq_ne_two_mod_four z\n    rw [show z * z = 4 * (x0 * x0 + x0 + y0 * y0 + y0) + 2\n        by\n        rw [← h.eq]\n        ring]\n    norm_num [Int.add_emod]\n#align even_odd_of_coprime even_odd_of_coprime\n\n",
 "coprime_sq_sub_sq_sum_of_odd_odd":
 "private theorem coprime_sq_sub_sq_sum_of_odd_odd {m n : ℤ} (h : int.gcd m n = 1) (hm : m % 2 = 1) (hn : n % 2 = 1) :\n    2 ∣ m ^ 2 + n ^ 2 ∧\n      2 ∣ m ^ 2 - n ^ 2 ∧ (m ^ 2 - n ^ 2) / 2 % 2 = 0 ∧ int.gcd ((m ^ 2 - n ^ 2) / 2) ((m ^ 2 + n ^ 2) / 2) = 1 :=\n  by\n  cases' exists_eq_mul_left_of_dvd (Int.dvd_sub_of_emod_eq hm) with m0 hm2\n  cases' exists_eq_mul_left_of_dvd (Int.dvd_sub_of_emod_eq hn) with n0 hn2\n  rw [sub_eq_iff_eq_add] at hm2 hn2\n  subst m\n  subst n\n  have h1 : (m0 * 2 + 1) ^ 2 + (n0 * 2 + 1) ^ 2 = 2 * (2 * (m0 ^ 2 + n0 ^ 2 + m0 + n0) + 1) := by ring\n  have h2 : (m0 * 2 + 1) ^ 2 - (n0 * 2 + 1) ^ 2 = 2 * (2 * (m0 ^ 2 - n0 ^ 2 + m0 - n0)) := by ring\n  have h3 : ((m0 * 2 + 1) ^ 2 - (n0 * 2 + 1) ^ 2) / 2 % 2 = 0 :=\n    by\n    rw [h2, Int.mul_ediv_cancel_left, Int.mul_emod_right]\n    exact by decide\n  refine' ⟨⟨_, h1⟩, ⟨_, h2⟩, h3, _⟩\n  have h20 : (2 : ℤ) ≠ 0 := by decide\n  rw [h1, h2, Int.mul_ediv_cancel_left _ h20, Int.mul_ediv_cancel_left _ h20]\n  by_contra h4\n  obtain ⟨p, hp, hp1, hp2⟩ := nat.prime.not_coprime_iff_dvd.mp h4\n  apply hp.not_dvd_one\n  rw [← h]\n  rw [← Int.coe_nat_dvd_left] at hp1 hp2\n  apply Nat.dvd_gcd\n  · apply Int.Prime.dvd_natAbs_of_coe_dvd_sq hp\n    convert dvd_add hp1 hp2\n    ring\n  · apply Int.Prime.dvd_natAbs_of_coe_dvd_sq hp\n    convert dvd_sub hp2 hp1\n    ring\n#align coprime_sq_sub_sq_sum_of_odd_odd coprime_sq_sub_sq_sum_of_odd_odd\n\n",
 "coprime_sq_sub_sq_add_of_odd_even":
 "private theorem coprime_sq_sub_sq_add_of_odd_even {m n : ℤ} (h : int.gcd m n = 1) (hm : m % 2 = 1) (hn : n % 2 = 0) :\n    int.gcd (m ^ 2 - n ^ 2) (m ^ 2 + n ^ 2) = 1 :=\n  by\n  rw [int.gcd, ← Int.natAbs_neg (m ^ 2 - n ^ 2)]\n  rw [(by ring : -(m ^ 2 - n ^ 2) = n ^ 2 - m ^ 2), add_comm]\n  apply coprime_sq_sub_sq_add_of_even_odd _ hn hm; rwa [Int.gcd_comm]\n#align coprime_sq_sub_sq_add_of_odd_even coprime_sq_sub_sq_add_of_odd_even\n\n",
 "coprime_sq_sub_sq_add_of_even_odd":
 "private theorem coprime_sq_sub_sq_add_of_even_odd {m n : ℤ} (h : int.gcd m n = 1) (hm : m % 2 = 0) (hn : n % 2 = 1) :\n    int.gcd (m ^ 2 - n ^ 2) (m ^ 2 + n ^ 2) = 1 := by\n  by_contra H\n  obtain ⟨p, hp, hp1, hp2⟩ := nat.prime.not_coprime_iff_dvd.mp H\n  rw [← Int.coe_nat_dvd_left] at hp1 hp2\n  have h2m : (p : ℤ) ∣ 2 * m ^ 2 := by\n    convert dvd_add hp2 hp1\n    ring\n  have h2n : (p : ℤ) ∣ 2 * n ^ 2 := by\n    convert dvd_sub hp2 hp1\n    ring\n  have hmc : p = 2 ∨ p ∣ Int.natAbs m := prime_two_or_dvd_of_dvd_two_mul_pow_self_two hp h2m\n  have hnc : p = 2 ∨ p ∣ Int.natAbs n := prime_two_or_dvd_of_dvd_two_mul_pow_self_two hp h2n\n  by_cases h2 : p = 2\n  · have h3 : (m ^ 2 + n ^ 2) % 2 = 1 := by norm_num [sq, Int.add_emod, Int.mul_emod, hm, hn]\n    have h4 : (m ^ 2 + n ^ 2) % 2 = 0 := by\n      apply Int.emod_eq_zero_of_dvd\n      rwa [h2] at hp2\n    rw [h4] at h3\n    exact zero_ne_one h3\n  · apply hp.not_dvd_one\n    rw [← h]\n    exact Nat.dvd_gcd (or.resolve_left hmc h2) (or.resolve_left hnc h2)\n#align coprime_sq_sub_sq_add_of_even_odd coprime_sq_sub_sq_add_of_even_odd\n\n",
 "coprime_sq_sub_mul_of_odd_even":
 "private theorem coprime_sq_sub_mul_of_odd_even {m n : ℤ} (h : int.gcd m n = 1) (hm : m % 2 = 1) (hn : n % 2 = 0) :\n    int.gcd (m ^ 2 - n ^ 2) (2 * m * n) = 1 :=\n  by\n  rw [int.gcd, ← Int.natAbs_neg (m ^ 2 - n ^ 2)]\n  rw [(by ring : 2 * m * n = 2 * n * m), (by ring : -(m ^ 2 - n ^ 2) = n ^ 2 - m ^ 2)]\n  apply coprime_sq_sub_mul_of_even_odd _ hn hm; rwa [Int.gcd_comm]\n#align coprime_sq_sub_mul_of_odd_even coprime_sq_sub_mul_of_odd_even\n\n",
 "coprime_sq_sub_mul_of_even_odd":
 "private theorem coprime_sq_sub_mul_of_even_odd {m n : ℤ} (h : int.gcd m n = 1) (hm : m % 2 = 0) (hn : n % 2 = 1) :\n    int.gcd (m ^ 2 - n ^ 2) (2 * m * n) = 1 := by\n  by_contra H\n  obtain ⟨p, hp, hp1, hp2⟩ := nat.prime.not_coprime_iff_dvd.mp H\n  rw [← Int.coe_nat_dvd_left] at hp1 hp2\n  have hnp : ¬(p : ℤ) ∣ int.gcd m n := by\n    rw [h]\n    norm_cast\n    exact mt nat.dvd_one.mp (Nat.Prime.ne_one hp)\n  cases' Int.Prime.dvd_mul hp hp2 with hp2m hpn\n  · rw [Int.natAbs_mul] at hp2m\n    cases' (Nat.Prime.dvd_mul hp).mp hp2m with hp2 hpm\n    · have hp2' : p = 2 := (nat.le_of_dvd zero_lt_two hp2).antisymm hp.two_le\n      revert hp1\n      rw [hp2']\n      apply mt Int.emod_eq_zero_of_dvd\n      norm_num [sq, Int.sub_emod, Int.mul_emod, hm, hn]\n    apply mt (Int.dvd_gcd (int.coe_nat_dvd_left.mpr hpm)) hnp\n    apply (or_self_iff _).mp\n    apply Int.Prime.dvd_mul' hp\n    rw [(by ring : n * n = -(m ^ 2 - n ^ 2) + m * m)]\n    exact hp1.neg_right.add ((Int.coe_nat_dvd_left.2 hpm).mul_right _)\n  rw [Int.gcd_comm] at hnp\n  apply mt (Int.dvd_gcd (int.coe_nat_dvd_left.mpr hpn)) hnp\n  apply (or_self_iff _).mp\n  apply Int.Prime.dvd_mul' hp\n  rw [(by ring : m * m = m ^ 2 - n ^ 2 + n * n)]\n  apply dvd_add hp1\n  exact (int.coe_nat_dvd_left.mpr hpn).mul_right n\n#align coprime_sq_sub_mul_of_even_odd coprime_sq_sub_mul_of_even_odd\n\n",
 "coprime_sq_sub_mul":
 "private theorem coprime_sq_sub_mul {m n : ℤ} (h : int.gcd m n = 1)\n    (hmn : m % 2 = 0 ∧ n % 2 = 1 ∨ m % 2 = 1 ∧ n % 2 = 0) : int.gcd (m ^ 2 - n ^ 2) (2 * m * n) = 1 :=\n  by\n  cases' hmn with h1 h2\n  · exact coprime_sq_sub_mul_of_even_odd h h1.left h1.right\n  · exact coprime_sq_sub_mul_of_odd_even h h2.left h2.right\n#align coprime_sq_sub_mul coprime_sq_sub_mul\n\n",
 "coprime_of_coprime":
 "theorem coprime_of_coprime (hc : int.gcd x y = 1) : int.gcd y z = 1 :=\n  by\n  by_contra H\n  obtain ⟨p, hp, hpy, hpz⟩ := nat.prime.not_coprime_iff_dvd.mp H\n  apply hp.not_dvd_one\n  rw [← hc]\n  apply Nat.dvd_gcd (Int.Prime.dvd_natAbs_of_coe_dvd_sq hp _ _) hpy\n  rw [sq, eq_sub_of_add_eq h]\n  rw [← Int.coe_nat_dvd_left] at hpy hpz\n  exact dvd_sub (hpz.mul_right _) (hpy.mul_right _)\n#align coprime_of_coprime coprime_of_coprime\n\n",
 "coprime_classification'":
 "/-- by assuming `x` is odd and `z` is positive we get a slightly more precise classification of\nthe pythagorean triple `x ^ 2 + y ^ 2 = z ^ 2`-/\ntheorem coprime_classification' {x y z : ℤ} (h : PythagoreanTriple x y z) (h_coprime : int.gcd x y = 1)\n    (h_parity : x % 2 = 1) (h_pos : 0 < z) :\n    ∃ m n,\n      x = m ^ 2 - n ^ 2 ∧\n        y = 2 * m * n ∧ z = m ^ 2 + n ^ 2 ∧ int.gcd m n = 1 ∧ (m % 2 = 0 ∧ n % 2 = 1 ∨ m % 2 = 1 ∧ n % 2 = 0) ∧ 0 ≤ m :=\n  by\n  obtain ⟨m, n, ht1, ht2, ht3, ht4⟩ := pythagorean_triple.coprime_classification.mp (and.intro h h_coprime)\n  cases' le_or_lt 0 m with hm hm\n  · use m, n\n    cases' ht1 with h_odd h_even\n    · apply and.intro h_odd.1\n      apply and.intro h_odd.2\n      cases' ht2 with h_pos h_neg\n      · apply and.intro h_pos (and.intro ht3 (and.intro ht4 hm))\n      · exfalso\n        revert h_pos\n        rw [h_neg]\n        exact imp_false.mpr (not_lt.mpr (neg_nonpos.mpr (add_nonneg (sq_nonneg m) (sq_nonneg n))))\n    exfalso\n    rcases h_even with ⟨rfl, -⟩\n    rw [mul_assoc, Int.mul_emod_right] at h_parity\n    exact zero_ne_one h_parity\n  · use -m, -n\n    cases' ht1 with h_odd h_even\n    · rw [neg_sq m]\n      rw [neg_sq n]\n      apply and.intro h_odd.1\n      constructor\n      · rw [h_odd.2]\n        ring\n      cases' ht2 with h_pos h_neg\n      · apply and.intro h_pos\n        constructor\n        · delta int.gcd\n          rw [Int.natAbs_neg, Int.natAbs_neg]\n          exact ht3\n        · rw [Int.neg_emod_two, Int.neg_emod_two]\n          apply and.intro ht4\n          linarith\n      · exfalso\n        revert h_pos\n        rw [h_neg]\n        exact imp_false.mpr (not_lt.mpr (neg_nonpos.mpr (add_nonneg (sq_nonneg m) (sq_nonneg n))))\n    exfalso\n    rcases h_even with ⟨rfl, -⟩\n    rw [mul_assoc, Int.mul_emod_right] at h_parity\n    exact zero_ne_one h_parity\n#align coprime_classification' coprime_classification'\n\n",
 "coprime_classification":
 "theorem coprime_classification :\n    PythagoreanTriple x y z ∧ int.gcd x y = 1 ↔\n      ∃ m n,\n        (x = m ^ 2 - n ^ 2 ∧ y = 2 * m * n ∨ x = 2 * m * n ∧ y = m ^ 2 - n ^ 2) ∧\n          (z = m ^ 2 + n ^ 2 ∨ z = -(m ^ 2 + n ^ 2)) ∧\n            int.gcd m n = 1 ∧ (m % 2 = 0 ∧ n % 2 = 1 ∨ m % 2 = 1 ∧ n % 2 = 0) :=\n  by\n  constructor\n  · intro h\n    obtain ⟨m, n, H⟩ := h.left.is_primitive_classified_of_coprime h.right\n    use m, n\n    rcases H with ⟨⟨rfl, rfl⟩ | ⟨rfl, rfl⟩, co, pp⟩\n    · refine' ⟨or.inl ⟨rfl, rfl⟩, _, co, pp⟩\n      have : z ^ 2 = (m ^ 2 + n ^ 2) ^ 2 := by\n        rw [sq, ← h.left.eq]\n        ring\n      simpa using eq_or_eq_neg_of_sq_eq_sq _ _ this\n    · refine' ⟨or.inr ⟨rfl, rfl⟩, _, co, pp⟩\n      have : z ^ 2 = (m ^ 2 + n ^ 2) ^ 2 := by\n        rw [sq, ← h.left.eq]\n        ring\n      simpa using eq_or_eq_neg_of_sq_eq_sq _ _ this\n  · delta PythagoreanTriple\n    rintro ⟨m, n, ⟨rfl, rfl⟩ | ⟨rfl, rfl⟩, rfl | rfl, co, pp⟩ <;>\n      first\n        |·\n          constructor\n          · ring\n          exact coprime_sq_sub_mul co pp|·\n          constructor\n          · ring\n          rw [Int.gcd_comm]\n          exact coprime_sq_sub_mul co pp\n#align coprime_classification coprime_classification\n\n",
 "classified":
 "theorem classified : h.is_classified := by\n  by_cases h0 : int.gcd x y = 0\n  · have hx : x = 0 := by\n      apply int.nat_abs_eq_zero.mp\n      apply Nat.eq_zero_of_gcd_eq_zero_left h0\n    have hy : y = 0 := by\n      apply int.nat_abs_eq_zero.mp\n      apply Nat.eq_zero_of_gcd_eq_zero_right h0\n    use 0, 1, 0\n    norm_num [hx, hy]\n  apply h.is_classified_of_normalize_is_primitive_classified\n  apply h.normalize.is_primitive_classified_of_coprime\n  apply Int.gcd_div_gcd_div_gcd (nat.pos_of_ne_zero h0)\n#align classified classified\n\n",
 "classification":
 "/-- **Formula for Pythagorean Triples** -/\ntheorem classification :\n    PythagoreanTriple x y z ↔\n      ∃ k m n,\n        (x = k * (m ^ 2 - n ^ 2) ∧ y = k * (2 * m * n) ∨ x = k * (2 * m * n) ∧ y = k * (m ^ 2 - n ^ 2)) ∧\n          (z = k * (m ^ 2 + n ^ 2) ∨ z = -k * (m ^ 2 + n ^ 2)) :=\n  by\n  constructor\n  · intro h\n    obtain ⟨k, m, n, H⟩ := h.classified\n    use k, m, n\n    rcases H with (⟨rfl, rfl⟩ | ⟨rfl, rfl⟩)\n    · refine' ⟨or.inl ⟨rfl, rfl⟩, _⟩\n      have : z ^ 2 = (k * (m ^ 2 + n ^ 2)) ^ 2 := by\n        rw [sq, ← h.eq]\n        ring\n      simpa using eq_or_eq_neg_of_sq_eq_sq _ _ this\n    · refine' ⟨or.inr ⟨rfl, rfl⟩, _⟩\n      have : z ^ 2 = (k * (m ^ 2 + n ^ 2)) ^ 2 := by\n        rw [sq, ← h.eq]\n        ring\n      simpa using eq_or_eq_neg_of_sq_eq_sq _ _ this\n  · rintro ⟨k, m, n, ⟨rfl, rfl⟩ | ⟨rfl, rfl⟩, rfl | rfl⟩ <;> delta PythagoreanTriple <;> ring\n#align classification classification\n\n",
 "circleEquivGen_symm_apply":
 "#print circleEquivGen_symm_apply /-\n@[simp]\ntheorem circleEquivGen_symm_apply (hk : ∀ x : K, 1 + x ^ 2 ≠ 0)\n    (v : { p : K × K // p.1 ^ 2 + p.2 ^ 2 = 1 ∧ p.2 ≠ -1 }) :\n    (circleEquivGen hk).symm v = (v : K × K).1 / ((v : K × K).2 + 1) :=\n  rfl\n#align circle_equiv_symm_apply circleEquivGen_symm_apply\n-/\n\n",
 "circleEquivGen_apply":
 "#print circleEquivGen_apply /-\n@[simp]\ntheorem circleEquivGen_apply (hk : ∀ x : K, 1 + x ^ 2 ≠ 0) (x : K) :\n    (circleEquivGen hk x : K × K) = ⟨2 * x / (1 + x ^ 2), (1 - x ^ 2) / (1 + x ^ 2)⟩ :=\n  rfl\n#align circle_equiv_apply circleEquivGen_apply\n-/\n\n",
 "Eq":
 "#print Eq /-\ntheorem Eq : x * x + y * y = z * z :=\n  h\n#align eq Eq\n-/\n\n"}