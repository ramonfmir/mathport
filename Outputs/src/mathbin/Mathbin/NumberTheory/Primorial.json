{"primorial_succ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr #» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr #» -/\n#print primorial_succ /-\ntheorem primorial_succ {n : ℕ} (hn1 : n ≠ 1) (hn : Odd n) : «expr #» (n + 1) = «expr #» n :=\n  by\n  refine' prod_congr _ fun _ _ => rfl\n  rw [range_succ, filter_insert, if_neg fun h => odd_iff_not_even.mp hn _]\n  exact h.even_sub_one <| mt succ.inj hn1\n#align primorial_succ primorial_succ\n-/\n\n",
 "primorial_pos":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr #» -/\n#print primorial_pos /-\n/-\nCopyright (c) 2020 Patrick Stevens. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Patrick Stevens, Yury Kudryashov\n-/\ntheorem primorial_pos (n : ℕ) : 0 < «expr #» n :=\n  prod_pos fun p hp => (mem_filter.1 hp).2.pos\n#align primorial_pos primorial_pos\n-/\n\n",
 "primorial_le_4_pow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr #» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr #» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr #» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr #» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr #» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr #» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr #» -/\n#print primorial_le_4_pow /-\ntheorem primorial_le_4_pow (n : ℕ) : «expr #» n ≤ 4 ^ n :=\n  by\n  induction' n using nat.strong_induction_on with n ihn\n  cases n; · rfl\n  rcases n.even_or_odd with (⟨m, rfl⟩ | ho)\n  · rcases m.eq_zero_or_pos with (rfl | hm)\n    · decide\n    calc\n      «expr #» (m + m + 1) = «expr #» (m + 1 + m) := by rw [add_right_comm]\n      _ ≤ «expr #» (m + 1) * choose (m + 1 + m) (m + 1) := (primorial_add_le m.le_succ)\n      _ = «expr #» (m + 1) * choose (2 * m + 1) m := by rw [choose_symm_add, two_mul, add_right_comm]\n      _ ≤ 4 ^ (m + 1) * 4 ^ m :=\n        (mul_le_mul' (ihn _ <| succ_lt_succ <| (lt_add_iff_pos_left _).2 hm) (choose_middle_le_pow _))\n      _ ≤ 4 ^ (m + m + 1) := by rw [← pow_add, add_right_comm]\n      \n  · rcases Decidable.eq_or_ne n 1 with (rfl | hn)\n    · decide\n    ·\n      calc\n        «expr #» (n + 1) = «expr #» n := primorial_succ hn ho\n        _ ≤ 4 ^ n := (ihn n n.lt_succ_self)\n        _ ≤ 4 ^ (n + 1) := pow_le_pow_of_le_right four_pos n.le_succ\n        \n#align primorial_le_4_pow primorial_le_4_pow\n-/\n\n",
 "primorial_add_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr #» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr #» -/\n#print primorial_add_le /-\ntheorem primorial_add_le {m n : ℕ} (h : n ≤ m) : «expr #» (m + n) ≤ «expr #» m * choose (m + n) m :=\n  le_of_dvd (mul_pos (primorial_pos _) (choose_pos <| nat.le_add_right _ _)) (primorial_add_dvd h)\n#align primorial_add_le primorial_add_le\n-/\n\n",
 "primorial_add_dvd":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr #» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr #» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr #» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr #» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr #» -/\n#print primorial_add_dvd /-\ntheorem primorial_add_dvd {m n : ℕ} (h : n ≤ m) : «expr #» (m + n) ∣ «expr #» m * choose (m + n) m :=\n  calc\n    «expr #» (m + n) =\n        «expr #» m *\n          finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\"\n            (filter Nat.Prime (Ico (m + 1) (m + n + 1))) p :=\n      primorial_add _ _\n    _ ∣ «expr #» m * choose (m + n) m :=\n      mul_dvd_mul_left _ <|\n        prod_primes_dvd _ (fun k hk => (mem_filter.1 hk).2.prime) fun p hp =>\n          by\n          rw [mem_filter, mem_Ico] at hp\n          exact hp.2.dvd_choose_add hp.1.1 (h.trans_lt (m.lt_succ_self.trans_le hp.1.1)) (Nat.lt_succ_iff.1 hp.1.2)\n    \n#align primorial_add_dvd primorial_add_dvd\n-/\n\n",
 "primorial_add":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr #» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr #» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n#print primorial_add /-\ntheorem primorial_add (m n : ℕ) :\n    «expr #» (m + n) =\n      «expr #» m *\n        finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\"\n          (filter Nat.Prime (Ico (m + 1) (m + n + 1))) p :=\n  by\n  rw [primorial, primorial, ← Ico_zero_eq_range, ← prod_union, ← filter_union, Ico_union_Ico_eq_Ico]\n  exacts[zero_le _, add_le_add_right (nat.le_add_right _ _) _,\n    disjoint_filter_filter <| Ico_disjoint_Ico_consecutive _ _ _]\n#align primorial_add primorial_add\n-/\n\n"}