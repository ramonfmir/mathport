{"primorial_succ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr #» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr #» -/\n/-\nCopyright (c) 2020 Patrick Stevens. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Patrick Stevens\n-/\ntheorem primorial_succ {n : ℕ} (n_big : 1 < n) (r : n % 2 = 1) : «expr #» (n + 1) = «expr #» n :=\n  by\n  refine' prod_congr _ fun _ _ => rfl\n  rw [range_succ, filter_insert, if_neg fun h => _]\n  have two_dvd : 2 ∣ n + 1 := dvd_iff_mod_eq_zero.mpr (by rw [← mod_add_mod, r, mod_self])\n  linarith [(h.dvd_iff_eq (Nat.bit0_ne_one 1)).mp two_dvd]\n#align primorial_succ primorial_succ\n\n",
 "primorial_le_4_pow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr #» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr #» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr #» -/\ntheorem primorial_le_4_pow : ∀ n : ℕ, «expr #» n ≤ 4 ^ n\n  | 0 => le_rfl\n  | 1 => le_of_inf_eq rfl\n  | n + 2 =>\n    match nat.mod_two_eq_zero_or_one (n + 1) with\n    | or.inl n_odd =>\n      match nat.even_iff.2 n_odd with\n      | ⟨m, twice_m⟩ => by\n        have recurse : m + 1 < n + 2 := by linarith\n        calc\n          «expr #» (n + 2) =\n              finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\"\n                (filter Nat.Prime (range (2 * m + 2))) i :=\n            by simpa [two_mul, ← twice_m]\n          _ =\n              finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\"\n                (filter Nat.Prime (finset.Ico (m + 2) (2 * m + 2) ∪ range (m + 2))) i :=\n            by\n            rw [range_eq_Ico, Finset.union_comm, finset.Ico_union_Ico_eq_Ico]\n            · exact bot_le\n            · simpa only [add_le_add_iff_right, two_mul] using nat.le_add_left m m\n          _ =\n              finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\"\n                (filter Nat.Prime (finset.Ico (m + 2) (2 * m + 2)) ∪ filter Nat.Prime (range (m + 2))) i :=\n            by rw [filter_union]\n          _ =\n              finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\"\n                  (filter Nat.Prime (finset.Ico (m + 2) (2 * m + 2))) i *\n                finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\"\n                  (filter Nat.Prime (range (m + 2))) i :=\n            by\n            apply finset.prod_union\n            have disj : Disjoint (finset.Ico (m + 2) (2 * m + 2)) (range (m + 2)) :=\n              by\n              simp only [Finset.disjoint_left, and_imp, finset.mem_Ico, not_lt, Finset.mem_range]\n              intro _ pr _\n              exact pr\n            exact Finset.disjoint_filter_filter disj\n          _ ≤\n              finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\"\n                  (filter Nat.Prime (finset.Ico (m + 2) (2 * m + 2))) i *\n                4 ^ (m + 1) :=\n            nat.mul_le_mul_left _ (primorial_le_4_pow (m + 1))\n          _ ≤ choose (2 * m + 1) (m + 1) * 4 ^ (m + 1) :=\n            by\n            have s :\n              finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\"\n                  (filter Nat.Prime (finset.Ico (m + 2) (2 * m + 2))) i ∣\n                choose (2 * m + 1) (m + 1) :=\n              by\n              refine' prod_primes_dvd (choose (2 * m + 1) (m + 1)) _ _\n              · intro a\n                rw [Finset.mem_filter, Nat.prime_iff]\n                apply And.right\n              · intro a\n                rw [Finset.mem_filter]\n                intro pr\n                rcases pr with ⟨size, is_prime⟩\n                simp only [finset.mem_Ico] at size\n                rcases size with ⟨a_big, a_small⟩\n                exact dvd_choose_of_middling_prime a is_prime m a_big (nat.lt_succ_iff.mp a_small)\n            have r :\n              finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\"\n                  (filter Nat.Prime (finset.Ico (m + 2) (2 * m + 2))) i ≤\n                choose (2 * m + 1) (m + 1) :=\n              by\n              refine' @nat.le_of_dvd _ _ _ s\n              exact @choose_pos (2 * m + 1) (m + 1) (by linarith)\n            exact nat.mul_le_mul_right _ r\n          _ = choose (2 * m + 1) m * 4 ^ (m + 1) := by rw [choose_symm_half m]\n          _ ≤ 4 ^ m * 4 ^ (m + 1) := nat.mul_le_mul_right _ (choose_middle_le_pow m)\n          _ = 4 ^ (2 * m + 1) := by ring\n          _ = 4 ^ (n + 2) := by rw [two_mul, ← twice_m]\n          \n    | or.inr n_even => by\n      obtain one_lt_n | n_le_one : 1 < n + 1 ∨ n + 1 ≤ 1 := lt_or_le 1 (n + 1)\n      · rw [primorial_succ one_lt_n n_even]\n        calc\n          «expr #» (n + 1) ≤ 4 ^ n.succ := primorial_le_4_pow (n + 1)\n          _ ≤ 4 ^ (n + 2) := pow_le_pow (by norm_num) (nat.le_succ _)\n          \n      · have n_zero : n = 0 := eq_bot_iff.2 (succ_le_succ_iff.1 n_le_one)\n        norm_num [n_zero, primorial, range_succ, prod_filter, Nat.not_prime_zero, Nat.prime_two]\n#align primorial_le_4_pow primorial_le_4_pow\n\n",
 "dvd_choose_of_middling_prime":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\ntheorem dvd_choose_of_middling_prime (p : ℕ) (is_prime : Nat.Prime p) (m : ℕ) (p_big : m + 1 < p)\n    (p_small : p ≤ 2 * m + 1) : p ∣ choose (2 * m + 1) (m + 1) :=\n  by\n  have m_size : m + 1 ≤ 2 * m + 1 := le_of_lt (lt_of_lt_of_le p_big p_small)\n  have s : ¬p ∣ nat.factorial (m + 1) := by\n    intro p_div_fact\n    exact lt_le_antisymm p_big (is_prime.dvd_factorial.mp p_div_fact)\n  have t : ¬p ∣ nat.factorial (2 * m + 1 - (m + 1)) :=\n    by\n    intro p_div_fact\n    refine' lt_le_antisymm (lt_of_succ_lt p_big) _\n    convert is_prime.dvd_factorial.mp p_div_fact\n    rw [two_mul, add_assoc, nat.add_sub_cancel]\n  have expanded :\n    choose (2 * m + 1) (m + 1) * nat.factorial (m + 1) * nat.factorial (2 * m + 1 - (m + 1)) =\n      nat.factorial (2 * m + 1) :=\n    @choose_mul_factorial_mul_factorial (2 * m + 1) (m + 1) m_size\n  have p_div_big_fact : p ∣ nat.factorial (2 * m + 1) := (prime.dvd_factorial is_prime).mpr p_small\n  rw [← expanded, mul_assoc] at p_div_big_fact\n  obtain p_div_choose | p_div_facts : p ∣ choose (2 * m + 1) (m + 1) ∨ p ∣ nat.factorial _ * nat.factorial _ :=\n    (prime.dvd_mul is_prime).1 p_div_big_fact\n  · exact p_div_choose\n  cases (prime.dvd_mul is_prime).1 p_div_facts\n  exacts[(s h).elim, (t h).elim]\n#align dvd_choose_of_middling_prime dvd_choose_of_middling_prime\n\n"}