{"yz_succ_succ":
 "theorem yz_succ_succ (n) : yz (n + 2) = (2 * a : ℕ) * yz (n + 1) - yz n :=\n  eq_sub_of_add_eq <| by delta yz <;> rw [← Int.ofNat_add, ← Int.ofNat_mul, yn_succ_succ]\n#align yz_succ_succ yz_succ_succ\n\n",
 "yz_succ":
 "@[simp]\ntheorem yz_succ (n : ℕ) : yz (n + 1) = xz n + yz n * az :=\n  rfl\n#align yz_succ yz_succ\n\n",
 "yz_sub":
 "theorem yz_sub {m n} (h : n ≤ m) : yz (m - n) = xz n * yz m - xz m * yz n :=\n  by\n  rw [sub_eq_add_neg, ← mul_neg, mul_comm, add_comm]\n  exact congr_arg zsqrtd.im (pell_zd_sub a1 h)\n#align yz_sub yz_sub\n\n",
 "ysq_dvd_yy":
 "theorem ysq_dvd_yy (n) : yn n * yn n ∣ yn (n * yn n) :=\n  modEq_zero_iff_dvd.1 <|\n    ((xy_modeq_yn n (yn n)).right.of_dvd <| by simp [pow_succ]).trans\n      (modEq_zero_iff_dvd.2 <| by simp [mul_dvd_mul_left, mul_assoc])\n#align ysq_dvd_yy ysq_dvd_yy\n\n",
 "yn_zero":
 "@[simp]\ntheorem yn_zero : yn 0 = 0 :=\n  rfl\n#align yn_zero yn_zero\n\n",
 "yn_succ_succ":
 "theorem yn_succ_succ (n) : yn (n + 2) + yn n = 2 * a * yn (n + 1) :=\n  (xy_succ_succ n).2\n#align yn_succ_succ yn_succ_succ\n\n",
 "yn_succ":
 "@[simp]\ntheorem yn_succ (n : ℕ) : yn (n + 1) = xn n + yn n * a :=\n  rfl\n#align yn_succ yn_succ\n\n",
 "yn_one":
 "@[simp]\ntheorem yn_one : yn 1 = 1 := by simp\n#align yn_one yn_one\n\n",
 "yn_modeq_two":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≡ [MOD ]» -/\ntheorem yn_modeq_two : ∀ n, «expr ≡ [MOD ]» (yn n) n 2\n  | 0 => by simp\n  | 1 => by simp\n  | n + 2 =>\n    (yn_modeq_two n).add_right_cancel <|\n      by\n      rw [yn_succ_succ, mul_assoc, (by ring : n + 2 + n = 2 * (n + 1))]\n      exact (dvd_mul_right 2 _).modeq_zero_nat.trans (dvd_mul_right 2 _).zero_modeq_nat\n#align yn_modeq_two yn_modeq_two\n\n",
 "yn_modeq_a_sub_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≡ [MOD ]» -/\ntheorem yn_modeq_a_sub_one : ∀ n, «expr ≡ [MOD ]» (yn n) n (a - 1)\n  | 0 => by simp\n  | 1 => by simp\n  | n + 2 =>\n    (yn_modeq_a_sub_one n).add_right_cancel <|\n      by\n      rw [yn_succ_succ, (by ring : n + 2 + n = 2 * (n + 1))]\n      exact ((modeq_sub a1.le).mul_left 2).mul (yn_modeq_a_sub_one (n + 1))\n#align yn_modeq_a_sub_one yn_modeq_a_sub_one\n\n",
 "yn_ge_n":
 "theorem yn_ge_n : ∀ n, n ≤ yn n\n  | 0 => nat.zero_le _\n  | n + 1 => show n < yn (n + 1) from lt_of_le_of_lt (yn_ge_n n) (strict_mono_y <| nat.lt_succ_self n)\n#align yn_ge_n yn_ge_n\n\n",
 "yn_add":
 "theorem yn_add (m n) : yn (m + n) = xn m * yn n + yn m * xn n := by\n  injection pell_zd_add _ m n with _ h <;> repeat' first |rw [← Int.ofNat_add] at h|rw [← Int.ofNat_mul] at h <;>\n    exact Int.ofNat.inj h\n#align yn_add yn_add\n\n",
 "y_mul_dvd":
 "theorem y_mul_dvd (n) : ∀ k, yn n ∣ yn (n * k)\n  | 0 => dvd_zero _\n  | k + 1 => by rw [nat.mul_succ, yn_add] <;> exact dvd_add (dvd_mul_left _ _) ((y_mul_dvd k).mul_right _)\n#align y_mul_dvd y_mul_dvd\n\n",
 "y_dvd_iff":
 "theorem y_dvd_iff (m n) : yn m ∣ yn n ↔ m ∣ n :=\n  ⟨fun h =>\n    nat.dvd_of_mod_eq_zero <|\n      (nat.eq_zero_or_pos _).resolve_right fun hp =>\n        by\n        have co : Nat.coprime (yn m) (xn (m * (n / m))) :=\n          Nat.coprime.symm <| (xy_coprime _).coprime_dvd_right (y_mul_dvd m (n / m))\n        have m0 : 0 < m :=\n          m.eq_zero_or_pos.resolve_left fun e => by\n            rw [e, nat.mod_zero] at hp <;> rw [e] at h <;>\n              exact ne_of_lt (strict_mono_y a1 hp) (eq_zero_of_zero_dvd h).symm\n        rw [← nat.mod_add_div n m, yn_add] at h <;>\n          exact\n            not_le_of_gt (strict_mono_y _ <| nat.mod_lt n m0)\n              (nat.le_of_dvd (strict_mono_y _ hp) <|\n                co.dvd_of_dvd_mul_right <| (nat.dvd_add_iff_right <| (y_mul_dvd _ _ _).mul_left _).2 h),\n    fun ⟨k, e⟩ => by rw [e] <;> apply y_mul_dvd⟩\n#align y_dvd_iff y_dvd_iff\n\n",
 "xz_succ_succ":
 "theorem xz_succ_succ (n) : xz (n + 2) = (2 * a : ℕ) * xz (n + 1) - xz n :=\n  eq_sub_of_add_eq <| by delta xz <;> rw [← Int.ofNat_add, ← Int.ofNat_mul, xn_succ_succ]\n#align xz_succ_succ xz_succ_succ\n\n",
 "xz_succ":
 "@[simp]\ntheorem xz_succ (n : ℕ) : xz (n + 1) = xz n * az + ↑d * yz n :=\n  rfl\n#align xz_succ xz_succ\n\n",
 "xz_sub":
 "theorem xz_sub {m n} (h : n ≤ m) : xz (m - n) = xz m * xz n - d * yz m * yz n :=\n  by\n  rw [sub_eq_add_neg, ← mul_neg]\n  exact congr_arg zsqrtd.re (pell_zd_sub a1 h)\n#align xz_sub xz_sub\n\n",
 "xy_succ_succ":
 "theorem xy_succ_succ (n) : xn (n + 2) + xn n = 2 * a * xn (n + 1) ∧ yn (n + 2) + yn n = 2 * a * yn (n + 1) :=\n  by\n  have := pell_zd_succ_succ a1 n; unfold pell_zd at this\n  erw [Zsqrtd.smul_val (2 * a : ℕ)] at this\n  injection this with h₁ h₂\n  constructor <;> apply Int.ofNat.inj <;> [simpa using h₁, simpa using h₂]\n#align xy_succ_succ xy_succ_succ\n\n",
 "xy_modeq_yn":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≡ [MOD ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≡ [MOD ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≡ [MOD ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≡ [MOD ]» -/\ntheorem xy_modeq_yn (n) :\n    ∀ k,\n      «expr ≡ [MOD ]» (xn (n * k)) (xn n ^ k) (yn n ^ 2) ∧\n        «expr ≡ [MOD ]» (yn (n * k)) (k * xn n ^ (k - 1) * yn n) (yn n ^ 3)\n  | 0 => by constructor <;> simp\n  | k + 1 => by\n    let ⟨hx, hy⟩ := xy_modeq_yn k\n    have L : «expr ≡ [MOD ]» (xn (n * k) * xn n + d * yn (n * k) * yn n) (xn n ^ k * xn n + 0) (yn n ^ 2) :=\n      (hx.mul_right _).add <|\n        modEq_zero_iff_dvd.2 <| by\n          rw [pow_succ'] <;>\n            exact\n              mul_dvd_mul_right\n                (dvd_mul_of_dvd_right\n                  (modeq_zero_iff_dvd.1 <|\n                    (hy.of_dvd <| by simp [pow_succ']).trans <| modeq_zero_iff_dvd.2 <| by simp [-mul_comm, -mul_assoc])\n                  _)\n                _\n    have R :\n      «expr ≡ [MOD ]» (xn (n * k) * yn n + yn (n * k) * xn n) (xn n ^ k * yn n + k * xn n ^ k * yn n) (yn n ^ 3) :=\n      ModEq.add\n          (by\n            rw [pow_succ']\n            exact hx.mul_right' _) <|\n        by\n        have : k * xn n ^ (k - 1) * yn n * xn n = k * xn n ^ k * yn n := by\n          clear _let_match <;> cases' k with k <;> simp [pow_succ', mul_comm, mul_left_comm]\n        rw [← this]\n        exact hy.mul_right _\n    rw [add_tsub_cancel_right, nat.mul_succ, xn_add, yn_add, pow_succ' (xn _ n), nat.succ_mul,\n      add_comm (k * xn _ n ^ k) (xn _ n ^ k), right_distrib]\n    exact ⟨L, R⟩\n#align xy_modeq_yn xy_modeq_yn\n\n",
 "xy_modeq_of_modeq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≡ [MOD ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≡ [MOD ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≡ [MOD ]» -/\ntheorem xy_modeq_of_modeq {a b c} (a1 : 1 < a) (b1 : 1 < b) (h : «expr ≡ [MOD ]» a b c) :\n    ∀ n, «expr ≡ [MOD ]» (xn a1 n) (xn b1 n) c ∧ «expr ≡ [MOD ]» (yn a1 n) (yn b1 n) c\n  | 0 => by constructor <;> rfl\n  | 1 => by simp <;> exact ⟨h, modeq.refl 1⟩\n  | n + 2 =>\n    ⟨(xy_modeq_of_modeq n).left.add_right_cancel <|\n        by\n        rw [xn_succ_succ a1, xn_succ_succ b1]\n        exact (h.mul_left _).mul (xy_modeq_of_modeq (n + 1)).left,\n      (xy_modeq_of_modeq n).right.add_right_cancel <|\n        by\n        rw [yn_succ_succ a1, yn_succ_succ b1]\n        exact (h.mul_left _).mul (xy_modeq_of_modeq (n + 1)).right⟩\n#align xy_modeq_of_modeq xy_modeq_of_modeq\n\n",
 "xy_coprime":
 "theorem xy_coprime (n) : (xn n).coprime (yn n) :=\n  Nat.coprime_of_dvd' fun k kp kx ky => by\n    let p := pell_eq n\n    rw [← p] <;> exact nat.dvd_sub (le_of_lt <| nat.lt_of_sub_eq_succ p) (kx.mul_left _) (ky.mul_left _)\n#align xy_coprime xy_coprime\n\n",
 "xn_zero":
 "@[simp]\ntheorem xn_zero : xn 0 = 1 :=\n  rfl\n#align xn_zero xn_zero\n\n",
 "xn_succ_succ":
 "theorem xn_succ_succ (n) : xn (n + 2) + xn n = 2 * a * xn (n + 1) :=\n  (xy_succ_succ n).1\n#align xn_succ_succ xn_succ_succ\n\n",
 "xn_succ":
 "@[simp]\ntheorem xn_succ (n : ℕ) : xn (n + 1) = xn n * a + d * yn n :=\n  rfl\n#align xn_succ xn_succ\n\n",
 "xn_one":
 "@[simp]\ntheorem xn_one : xn 1 = a := by simp\n#align xn_one xn_one\n\n",
 "xn_modeq_x4n_sub":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≡ [MOD ]» -/\ntheorem xn_modeq_x4n_sub {n j} (h : j ≤ 2 * n) : «expr ≡ [MOD ]» (xn (4 * n - j)) (xn j) (xn n) :=\n  have h' : j ≤ 2 * n := le_trans h (by rw [nat.succ_mul] <;> apply nat.le_add_left)\n  ModEq.add_right_cancel' (xn (2 * n - j)) <| by\n    refine' @modeq.trans _ _ 0 _ _ (by rw [add_comm] <;> exact (xn_modeq_x2n_sub _ h).symm) <;>\n        rw [show 4 * n = 2 * n + 2 * n from right_distrib 2 2 n, add_tsub_assoc_of_le h'] <;>\n      apply xn_modeq_x2n_add\n#align xn_modeq_x4n_sub xn_modeq_x4n_sub\n\n",
 "xn_modeq_x4n_add":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≡ [MOD ]» -/\ntheorem xn_modeq_x4n_add (n j) : «expr ≡ [MOD ]» (xn (4 * n + j)) (xn j) (xn n) :=\n  ModEq.add_right_cancel' (xn (2 * n + j)) <| by\n    refine' @modeq.trans _ _ 0 _ _ (by rw [add_comm] <;> exact (xn_modeq_x2n_add _ _ _).symm) <;>\n        rw [show 4 * n = 2 * n + 2 * n from right_distrib 2 2 n, add_assoc] <;>\n      apply xn_modeq_x2n_add\n#align xn_modeq_x4n_add xn_modeq_x4n_add\n\n",
 "xn_modeq_x2n_sub_lem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≡ [MOD ]» -/\ntheorem xn_modeq_x2n_sub_lem {n j} (h : j ≤ n) : «expr ≡ [MOD ]» (xn (2 * n - j) + xn j) 0 (xn n) :=\n  by\n  have h1 : xz n ∣ ↑d * yz n * yz (n - j) + xz j := by\n    rw [yz_sub _ h, mul_sub_left_distrib, sub_add_eq_add_sub] <;>\n      exact\n        dvd_sub\n          (by\n            delta xz <;> delta yz <;> repeat' first |rw [← Int.ofNat_add]|rw [← Int.ofNat_mul] <;>\n                rw [mul_comm (xn a1 j) (yn a1 n)] <;>\n              exact Int.coe_nat_dvd.2 (xn_modeq_x2n_add_lem _ _ _))\n          ((dvd_mul_right _ _).mul_left _)\n  rw [two_mul, add_tsub_assoc_of_le h, xn_add, add_assoc, ← zero_add 0]\n  exact (dvd_mul_right _ _).modeq_zero_nat.add (Int.coe_nat_dvd.1 <| by simpa [xz, yz] using h1).modeq_zero_nat\n#align xn_modeq_x2n_sub_lem xn_modeq_x2n_sub_lem\n\n",
 "xn_modeq_x2n_sub":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≡ [MOD ]» -/\ntheorem xn_modeq_x2n_sub {n j} (h : j ≤ 2 * n) : «expr ≡ [MOD ]» (xn (2 * n - j) + xn j) 0 (xn n) :=\n  (le_total j n).elim xn_modeq_x2n_sub_lem fun jn =>\n    by\n    have : 2 * n - j + j ≤ n + j := by rw [tsub_add_cancel_of_le h, two_mul] <;> exact nat.add_le_add_left jn _\n    let t := xn_modeq_x2n_sub_lem (Nat.le_of_add_le_add_right this)\n    rwa [tsub_tsub_cancel_of_le h, add_comm] at t\n#align xn_modeq_x2n_sub xn_modeq_x2n_sub\n\n",
 "xn_modeq_x2n_add_lem":
 "theorem xn_modeq_x2n_add_lem (n j) : xn n ∣ d * yn n * (yn n * xn j) + xn j :=\n  by\n  have h1 : d * yn n * (yn n * xn j) + xn j = (d * yn n * yn n + 1) * xn j := by simp [add_mul, mul_assoc]\n  have h2 : d * yn n * yn n + 1 = xn n * xn n := by\n    apply Int.ofNat.inj <;> repeat' first |rw [Int.ofNat_add]|rw [Int.ofNat_mul] <;>\n      exact add_eq_of_eq_sub' (Eq.symm <| pell_eqz _ _)\n  rw [h2] at h1 <;> rw [h1, mul_assoc] <;> exact dvd_mul_right _ _\n#align xn_modeq_x2n_add_lem xn_modeq_x2n_add_lem\n\n",
 "xn_modeq_x2n_add":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≡ [MOD ]» -/\ntheorem xn_modeq_x2n_add (n j) : «expr ≡ [MOD ]» (xn (2 * n + j) + xn j) 0 (xn n) :=\n  by\n  rw [two_mul, add_assoc, xn_add, add_assoc, ← zero_add 0]\n  refine' (dvd_mul_right (xn a1 n) (xn a1 (n + j))).modeq_zero_nat.add _\n  rw [yn_add, left_distrib, add_assoc, ← zero_add 0]\n  exact ((dvd_mul_right _ _).mul_left _).modeq_zero_nat.add (xn_modeq_x2n_add_lem _ _ _).modeq_zero_nat\n#align xn_modeq_x2n_add xn_modeq_x2n_add\n\n",
 "xn_ge_a_pow":
 "theorem xn_ge_a_pow : ∀ n : ℕ, a ^ n ≤ xn n\n  | 0 => le_refl 1\n  | n + 1 => by simp [pow_succ'] <;> exact le_trans (nat.mul_le_mul_right _ (xn_ge_a_pow n)) (nat.le_add_right _ _)\n#align xn_ge_a_pow xn_ge_a_pow\n\n",
 "xn_add":
 "theorem xn_add (m n) : xn (m + n) = xn m * xn n + d * yn m * yn n := by\n  injection pell_zd_add _ m n with h _ <;> repeat' first |rw [← Int.ofNat_add] at h|rw [← Int.ofNat_mul] at h <;>\n    exact Int.ofNat.inj h\n#align xn_add xn_add\n\n",
 "x_sub_y_dvd_pow_lem":
 "theorem x_sub_y_dvd_pow_lem (y2 y1 y0 yn1 yn0 xn1 xn0 ay a2 : ℤ) :\n    (a2 * yn1 - yn0) * ay + y2 - (a2 * xn1 - xn0) =\n      y2 - a2 * y1 + y0 + a2 * (yn1 * ay + y1 - xn1) - (yn0 * ay + y0 - xn0) :=\n  by ring\n#align x_sub_y_dvd_pow_lem x_sub_y_dvd_pow_lem\n\n",
 "x_sub_y_dvd_pow":
 "theorem x_sub_y_dvd_pow (y : ℕ) : ∀ n, (2 * a * y - y * y - 1 : ℤ) ∣ yz n * (a - y) + ↑(y ^ n) - xz n\n  | 0 => by simp [xz, yz, Int.ofNat_zero, Int.ofNat_one]\n  | 1 => by simp [xz, yz, Int.ofNat_zero, Int.ofNat_one]\n  | n + 2 =>\n    by\n    have : (2 * a * y - y * y - 1 : ℤ) ∣ ↑(y ^ (n + 2)) - ↑(2 * a) * ↑(y ^ (n + 1)) + ↑(y ^ n) :=\n      ⟨-↑(y ^ n),\n        by\n        simp [pow_succ, mul_add, Int.ofNat_mul, show ((2 : ℕ) : ℤ) = 2 from rfl, mul_comm, mul_left_comm]\n        ring⟩\n    rw [xz_succ_succ, yz_succ_succ, x_sub_y_dvd_pow_lem ↑(y ^ (n + 2)) ↑(y ^ (n + 1)) ↑(y ^ n)]\n    exact dvd_sub (dvd_add this <| (x_sub_y_dvd_pow (n + 1)).mul_left _) (x_sub_y_dvd_pow n)\n#align x_sub_y_dvd_pow x_sub_y_dvd_pow\n\n",
 "x_pos":
 "theorem x_pos (n) : 0 < xn n :=\n  lt_of_le_of_lt (nat.zero_le n) (n_lt_xn n)\n#align x_pos x_pos\n\n",
 "strict_mono_y":
 "theorem strict_mono_y : StrictMono yn\n  | m, 0, h => absurd h <| nat.not_lt_zero _\n  | m, n + 1, h =>\n    by\n    have : yn m ≤ yn n :=\n      or.elim (lt_or_eq_of_le <| nat.le_of_succ_le_succ h) (fun hl => le_of_lt <| strict_mono_y hl) fun e => by rw [e]\n    simp <;> refine' lt_of_le_of_lt _ (nat.lt_add_of_pos_left <| x_pos a1 n) <;> rw [← mul_one (yn a1 m)] <;>\n      exact mul_le_mul this (le_of_lt a1) (nat.zero_le _) (nat.zero_le _)\n#align strict_mono_y strict_mono_y\n\n",
 "strict_mono_x":
 "theorem strict_mono_x : StrictMono xn\n  | m, 0, h => absurd h <| nat.not_lt_zero _\n  | m, n + 1, h =>\n    by\n    have : xn m ≤ xn n :=\n      or.elim (lt_or_eq_of_le <| nat.le_of_succ_le_succ h) (fun hl => le_of_lt <| strict_mono_x hl) fun e => by rw [e]\n    simp <;> refine' lt_of_lt_of_le (lt_of_le_of_lt this _) (nat.le_add_right _ _) <;>\n        have t := nat.mul_lt_mul_of_pos_left a1 (x_pos a1 n) <;>\n      rwa [mul_one] at t\n#align strict_mono_x strict_mono_x\n\n",
 "pell_zd_succ_succ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ√ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ√ » -/\ntheorem pell_zd_succ_succ (n) : pell_zd (n + 2) + pell_zd n = (2 * a : ℕ) * pell_zd (n + 1) :=\n  by\n  have : (1 : «exprℤ√ » d) + ⟨a, 1⟩ * ⟨a, 1⟩ = ⟨a, 1⟩ * (2 * a) :=\n    by\n    rw [Zsqrtd.coe_nat_val]\n    change (⟨_, _⟩ : «exprℤ√ » (d a1)) = ⟨_, _⟩\n    rw [dz_val]\n    dsimp [az]\n    rw [Zsqrtd.ext]\n    dsimp\n    constructor <;> ring\n  simpa [mul_add, mul_comm, mul_left_comm, add_comm] using congr_arg (· * pell_zd a1 n) this\n#align pell_zd_succ_succ pell_zd_succ_succ\n\n",
 "pell_zd_succ":
 "@[simp]\ntheorem pell_zd_succ (n : ℕ) : pell_zd (n + 1) = pell_zd n * ⟨a, 1⟩ := by simp [Zsqrtd.ext]\n#align pell_zd_succ pell_zd_succ\n\n",
 "pell_zd_sub":
 "theorem pell_zd_sub {m n} (h : n ≤ m) : pell_zd (m - n) = pell_zd m * star (pell_zd n) :=\n  by\n  let t := pell_zd_add n (m - n)\n  rw [add_tsub_cancel_of_le h] at t <;>\n    rw [t, mul_comm (pell_zd _ n) _, mul_assoc, is_pell_norm.1 (is_pell_pell_zd _ _), mul_one]\n#align pell_zd_sub pell_zd_sub\n\n",
 "pell_zd_re":
 "@[simp]\ntheorem pell_zd_re (n : ℕ) : (pell_zd n).re = xn n :=\n  rfl\n#align pell_zd_re pell_zd_re\n\n",
 "pell_zd_im":
 "@[simp]\ntheorem pell_zd_im (n : ℕ) : (pell_zd n).im = yn n :=\n  rfl\n#align pell_zd_im pell_zd_im\n\n",
 "pell_zd_add":
 "theorem pell_zd_add (m) : ∀ n, pell_zd (m + n) = pell_zd m * pell_zd n\n  | 0 => (mul_one _).symm\n  | n + 1 => by rw [← add_assoc, pell_zd_succ, pell_zd_succ, pell_zd_add n, ← mul_assoc]\n#align pell_zd_add pell_zd_add\n\n",
 "pell_val":
 "-- TODO(lint): Fix double namespace issue\n@[simp]\ntheorem pell_val (n : ℕ) : pell n = (xn n, yn n) :=\n  show pell n = ((pell n).1, (pell n).2) from\n    match pell n with\n    | (a, b) => rfl\n#align pell_val pell_val\n\n",
 "pell_eqz":
 "@[simp]\ntheorem pell_eqz (n : ℕ) : xz n * xz n - d * yz n * yz n = 1 :=\n  is_pell_pell_zd n\n#align pell_eqz pell_eqz\n\n",
 "pell_eq":
 "@[simp]\ntheorem pell_eq (n : ℕ) : xn n * xn n - d * yn n * yn n = 1 :=\n  let pn := pell_eqz n\n  have h : (↑(xn n * xn n) : ℤ) - ↑(d * yn n * yn n) = 1 := by repeat' rw [Int.ofNat_mul] <;> exact pn\n  have hl : d * yn n * yn n ≤ xn n * xn n := Int.le_of_ofNat_le_ofNat <| int.le.intro <| add_eq_of_eq_sub' <| Eq.symm h\n  Int.ofNat.inj (by rw [Int.ofNat_sub hl] <;> exact h)\n#align pell_eq pell_eq\n\n",
 "n_lt_xn":
 "theorem n_lt_xn (n) : n < xn n :=\n  lt_of_lt_of_le (n_lt_a_pow n) (xn_ge_a_pow n)\n#align n_lt_xn n_lt_xn\n\n",
 "n_lt_a_pow":
 "theorem n_lt_a_pow : ∀ n : ℕ, n < a ^ n\n  | 0 => nat.le_refl 1\n  | n + 1 => by\n    have IH := n_lt_a_pow n\n    have : a ^ n + a ^ n ≤ a ^ n * a := by\n      rw [← mul_two]\n      exact nat.mul_le_mul_left _ a1\n    simp [pow_succ']\n    refine' lt_of_lt_of_le _ this\n    exact add_lt_add_of_lt_of_le IH (lt_of_le_of_lt (nat.zero_le _) IH)\n#align n_lt_a_pow n_lt_a_pow\n\n",
 "modeq_of_xn_modeq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≡ [MOD ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≡ [MOD ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≡ [MOD ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≡ [MOD ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≡ [MOD ]» -/\ntheorem modeq_of_xn_modeq {i j n} (ipos : 0 < i) (hin : i ≤ n) (h : «expr ≡ [MOD ]» (xn j) (xn i) (xn n)) :\n    «expr ≡ [MOD ]» j i (4 * n) ∨ «expr ≡ [MOD ]» (j + i) 0 (4 * n) :=\n  let j' := j % (4 * n)\n  have n4 : 0 < 4 * n := mul_pos (by decide) (ipos.trans_le hin)\n  have jl : j' < 4 * n := nat.mod_lt _ n4\n  have jj : «expr ≡ [MOD ]» j j' (4 * n) := by delta modeq <;> rw [nat.mod_eq_of_lt jl]\n  have : ∀ j q, «expr ≡ [MOD ]» (xn (j + 4 * n * q)) (xn j) (xn n) :=\n    by\n    intro j q; induction' q with q IH; · simp\n    rw [nat.mul_succ, ← add_assoc, add_comm]\n    exact (xn_modeq_x4n_add _ _ _).trans IH\n  Or.imp (fun ji : j' = i => by rwa [← ji])\n    (fun ji : j' + i = 4 * n =>\n      (jj.add_right _).trans <| by\n        rw [ji]\n        exact dvd_rfl.modeq_zero_nat)\n    (eq_of_xn_modeq' ipos hin jl.le <|\n      (h.symm.trans <| by\n          rw [← nat.mod_add_div j (4 * n)]\n          exact this j' _).symm)\n#align modeq_of_xn_modeq modeq_of_xn_modeq\n\n",
 "matiyasevic":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≡ [MOD ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≡ [MOD ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≡ [MOD ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≡ [MOD ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≡ [MOD ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≡ [MOD ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≡ [MOD ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≡ [MOD ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≡ [MOD ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≡ [MOD ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≡ [MOD ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≡ [MOD ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≡ [MOD ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≡ [MOD ]» -/\ntheorem matiyasevic {a k x y} :\n    (∃ a1 : 1 < a, xn a1 k = x ∧ yn a1 k = y) ↔\n      1 < a ∧\n        k ≤ y ∧\n          (x = 1 ∧ y = 0 ∨\n            ∃ u v s t b : ℕ,\n              x * x - (a * a - 1) * y * y = 1 ∧\n                u * u - (a * a - 1) * v * v = 1 ∧\n                  s * s - (b * b - 1) * t * t = 1 ∧\n                    1 < b ∧\n                      «expr ≡ [MOD ]» b 1 (4 * y) ∧\n                        «expr ≡ [MOD ]» b a u ∧\n                          0 < v ∧ y * y ∣ v ∧ «expr ≡ [MOD ]» s x u ∧ «expr ≡ [MOD ]» t k (4 * y)) :=\n  ⟨fun ⟨a1, hx, hy⟩ => by\n    rw [← hx, ← hy] <;>\n        refine'\n          ⟨a1,\n            (nat.eq_zero_or_pos k).elim (fun k0 => by rw [k0] <;> exact ⟨le_rfl, or.inl ⟨rfl, rfl⟩⟩) fun kpos => _⟩ <;>\n      exact\n        let x := xn a1 k\n        let y := yn a1 k\n        let m := 2 * (k * y)\n        let u := xn a1 m\n        let v := yn a1 m\n        have ky : k ≤ y := yn_ge_n a1 k\n        have yv : y * y ∣ v := (ysq_dvd_yy a1 k).trans <| (y_dvd_iff _ _ _).2 <| dvd_mul_left _ _\n        have uco : Nat.coprime u (4 * y) :=\n          have : 2 ∣ v := modeq_zero_iff_dvd.1 <| (yn_modeq_two _ _).trans (dvd_mul_right _ _).modeq_zero_nat\n          have : Nat.coprime u 2 := (xy_coprime a1 m).coprime_dvd_right this\n          (this.mul_right this).mul_right <| (xy_coprime _ _).coprime_dvd_right (dvd_of_mul_left_dvd yv)\n        let ⟨b, ba, bm1⟩ := chinese_remainder uco a 1\n        have m1 : 1 < m :=\n          have : 0 < k * y := mul_pos kpos (strict_mono_y a1 kpos)\n          nat.mul_le_mul_left 2 this\n        have vp : 0 < v := strict_mono_y a1 (lt_trans zero_lt_one m1)\n        have b1 : 1 < b :=\n          have : xn a1 1 < u := strict_mono_x a1 m1\n          have : a < u := by simp at this <;> exact this\n          lt_of_lt_of_le a1 <| by\n            delta modeq at ba <;> rw [nat.mod_eq_of_lt this] at ba <;> rw [← ba] <;> apply nat.mod_le\n        let s := xn b1 k\n        let t := yn b1 k\n        have sx : «expr ≡ [MOD ]» s x u := (xy_modeq_of_modeq b1 a1 ba k).left\n        have tk : «expr ≡ [MOD ]» t k (4 * y) :=\n          have : 4 * y ∣ b - 1 := Int.coe_nat_dvd.1 <| by rw [Int.ofNat_sub (le_of_lt b1)] <;> exact bm1.symm.dvd\n          (yn_modeq_a_sub_one _ _).of_dvd this\n        ⟨ky, or.inr ⟨u, v, s, t, b, pell_eq _ _, pell_eq _ _, pell_eq _ _, b1, bm1, ba, vp, yv, sx, tk⟩⟩,\n    fun ⟨a1, ky, o⟩ =>\n    ⟨a1,\n      match o with\n      | or.inl ⟨x1, y0⟩ => by rw [y0] at ky <;> rw [nat.eq_zero_of_le_zero ky, x1, y0] <;> exact ⟨rfl, rfl⟩\n      | or.inr ⟨u, v, s, t, b, xy, uv, st, b1, rem⟩ =>\n        match x, y, eq_pell a1 xy, u, v, eq_pell a1 uv, s, t, eq_pell b1 st, rem, ky with\n        | _, _, ⟨i, rfl, rfl⟩, _, _, ⟨n, rfl, rfl⟩, _, _, ⟨j, rfl, rfl⟩,\n          ⟨(bm1 : «expr ≡ [MOD ]» b 1 (4 * yn a1 i)), (ba : «expr ≡ [MOD ]» b a (xn a1 n)), (vp : 0 < yn a1 n),\n            (yv : yn a1 i * yn a1 i ∣ yn a1 n), (sx : «expr ≡ [MOD ]» (xn b1 j) (xn a1 i) (xn a1 n)),\n            (tk : «expr ≡ [MOD ]» (yn b1 j) k (4 * yn a1 i))⟩,\n          (ky : k ≤ yn a1 i) =>\n          (nat.eq_zero_or_pos i).elim (fun i0 => by simp [i0] at ky <;> rw [i0, ky] <;> exact ⟨rfl, rfl⟩) fun ipos =>\n            by\n            suffices i = k by rw [this] <;> exact ⟨rfl, rfl⟩\n            clear _x o rem xy uv st _match _match _fun_match <;>\n              exact\n                by\n                have iln : i ≤ n :=\n                  le_of_not_gt fun hin =>\n                    not_lt_of_ge (nat.le_of_dvd vp (dvd_of_mul_left_dvd yv)) (strict_mono_y a1 hin)\n                have yd : 4 * yn a1 i ∣ 4 * n := mul_dvd_mul_left _ <| dvd_of_ysq_dvd a1 yv\n                have jk : «expr ≡ [MOD ]» j k (4 * yn a1 i) :=\n                  have : 4 * yn a1 i ∣ b - 1 :=\n                    Int.coe_nat_dvd.1 <| by rw [Int.ofNat_sub (le_of_lt b1)] <;> exact bm1.symm.dvd\n                  ((yn_modeq_a_sub_one b1 _).of_dvd this).symm.trans tk\n                have ki : k + i < 4 * yn a1 i :=\n                  lt_of_le_of_lt (add_le_add ky (yn_ge_n a1 i)) <| by\n                    rw [← two_mul] <;> exact nat.mul_lt_mul_of_pos_right (by decide) (strict_mono_y a1 ipos)\n                have ji : «expr ≡ [MOD ]» j i (4 * n) :=\n                  have : «expr ≡ [MOD ]» (xn a1 j) (xn a1 i) (xn a1 n) :=\n                    (xy_modeq_of_modeq b1 a1 ba j).left.symm.trans sx\n                  (modeq_of_xn_modeq a1 ipos iln this).resolve_right fun ji : «expr ≡ [MOD ]» (j + i) 0 (4 * n) =>\n                    not_le_of_gt ki <|\n                      nat.le_of_dvd (lt_of_lt_of_le ipos <| nat.le_add_left _ _) <|\n                        modeq_zero_iff_dvd.1 <| (jk.symm.add_right i).trans <| ji.of_dvd yd\n                have : i % (4 * yn a1 i) = k % (4 * yn a1 i) := (ji.of_dvd yd).symm.trans jk <;>\n                  rwa [nat.mod_eq_of_lt (lt_of_le_of_lt (nat.le_add_left _ _) ki),\n                    nat.mod_eq_of_lt (lt_of_le_of_lt (nat.le_add_right _ _) ki)] at this⟩⟩\n#align matiyasevic matiyasevic\n\n",
 "is_pell_star":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ√ » -/\ntheorem is_pell_star : ∀ {b : «exprℤ√ » d}, IsPell b ↔ IsPell (star b)\n  | ⟨x, y⟩ => by simp [is_pell, Zsqrtd.star_mk]\n#align is_pell_star is_pell_star\n\n",
 "is_pell_pell_zd":
 "theorem is_pell_pell_zd : ∀ n : ℕ, IsPell (pell_zd n)\n  | 0 => rfl\n  | n + 1 => by\n    let o := is_pell_one\n    simp <;> exact Pell.isPell_mul (is_pell_pell_zd n) o\n#align is_pell_pell_zd is_pell_pell_zd\n\n",
 "is_pell_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ√ » -/\ntheorem is_pell_one : IsPell (⟨a, 1⟩ : «exprℤ√ » d) :=\n  show az * az - d * 1 * 1 = 1 by simp [dz_val] <;> ring\n#align is_pell_one is_pell_one\n\n",
 "is_pell_norm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ√ » -/\n/-\nCopyright (c) 2017 Mario Carneiro. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Mario Carneiro\n-/\ntheorem is_pell_norm : ∀ {b : «exprℤ√ » d}, IsPell b ↔ b * star b = 1\n  | ⟨x, y⟩ => by simp [Zsqrtd.ext, is_pell, mul_comm] <;> ring_nf\n#align is_pell_norm is_pell_norm\n\n",
 "is_pell_nat":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ√ » -/\ntheorem is_pell_nat {x y : ℕ} : IsPell (⟨x, y⟩ : «exprℤ√ » d) ↔ x * x - d * y * y = 1 :=\n  ⟨fun h => Int.ofNat.inj (by rw [Int.ofNat_sub (Int.le_of_ofNat_le_ofNat <| int.le.intro_sub h)] <;> exact h), fun h =>\n    show ((x * x : ℕ) - (d * y * y : ℕ) : ℤ) = 1 by\n      rw [← Int.ofNat_sub <| le_of_lt <| nat.lt_of_sub_eq_succ h, h] <;> rfl⟩\n#align is_pell_nat is_pell_nat\n\n",
 "is_pell_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ√ » -/\ntheorem is_pell_mul {b c : «exprℤ√ » d} (hb : IsPell b) (hc : IsPell c) : IsPell (b * c) :=\n  isPell_norm.2 (by simp [mul_comm, mul_left_comm, star_mul, is_pell_norm.1 hb, is_pell_norm.1 hc])\n#align is_pell_mul is_pell_mul\n\n",
 "is_pell_iff_mem_unitary":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ√ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ√ » -/\ntheorem is_pell_iff_mem_unitary : ∀ {b : «exprℤ√ » d}, IsPell b ↔ b ∈ unitary («exprℤ√ » d)\n  | ⟨x, y⟩ => by rw [unitary.mem_iff, is_pell_norm, mul_comm (star _), and_self_iff]\n#align is_pell_iff_mem_unitary is_pell_iff_mem_unitary\n\n",
 "eq_pow_of_pell_lem":
 "theorem eq_pow_of_pell_lem {a y k} (hy0 : y ≠ 0) (hk0 : k ≠ 0) (hyk : y ^ k < a) :\n    (↑(y ^ k) : ℤ) < 2 * a * y - y * y - 1 :=\n  have hya : y < a := (Nat.le_self_pow hk0 _).trans_lt hyk\n  calc\n    (↑(y ^ k) : ℤ) < a := Nat.cast_lt.2 hyk\n    _ ≤ a ^ 2 - (a - 1) ^ 2 - 1 :=\n      by\n      rw [sub_sq, mul_one, one_pow, sub_add, sub_sub_cancel, two_mul, sub_sub, ← add_sub, le_add_iff_nonneg_right, ←\n        bit0, sub_nonneg, ← Nat.cast_two, Nat.cast_le, Nat.succ_le_iff]\n      exact (one_le_iff_ne_zero.2 hy0).trans_lt hya\n    _ ≤ a ^ 2 - (a - y) ^ 2 - 1 := by\n      have := hya.le\n      mono* <;> simpa only [sub_nonneg, Nat.cast_le, Nat.one_le_cast, Nat.one_le_iff_ne_zero]\n    _ = 2 * a * y - y * y - 1 := by ring\n    \n#align eq_pow_of_pell_lem eq_pow_of_pell_lem\n\n",
 "eq_pow_of_pell":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≡ [MOD ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≡ [MOD ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≡ [MOD ]» -/\ntheorem eq_pow_of_pell {m n k} :\n    n ^ k = m ↔\n      k = 0 ∧ m = 1 ∨\n        0 < k ∧\n          (n = 0 ∧ m = 0 ∨\n            0 < n ∧\n              ∃ (w a t z : ℕ)(a1 : 1 < a),\n                «expr ≡ [MOD ]» (xn a1 k) (yn a1 k * (a - n) + m) t ∧\n                  2 * a * n = t + (n * n + 1) ∧\n                    m < t ∧ n ≤ w ∧ k ≤ w ∧ a * a - ((w + 1) * (w + 1) - 1) * (w * z) * (w * z) = 1) :=\n  by\n  constructor\n  · rintro rfl\n    refine' k.eq_zero_or_pos.imp (fun k0 => k0.symm ▸ ⟨rfl, rfl⟩) fun hk => ⟨hk, _⟩\n    refine' n.eq_zero_or_pos.imp (fun n0 => n0.symm ▸ ⟨rfl, zero_pow hk⟩) fun hn => ⟨hn, _⟩\n    set w := max n k\n    have nw : n ≤ w := le_max_left _ _\n    have kw : k ≤ w := le_max_right _ _\n    have wpos : 0 < w := hn.trans_le nw\n    have w1 : 1 < w + 1 := nat.succ_lt_succ wpos\n    set a := xn w1 w\n    have a1 : 1 < a := strict_mono_x w1 wpos\n    have na : n ≤ a := nw.trans (n_lt_xn w1 w).le\n    set x := xn a1 k\n    set y := yn a1 k\n    obtain ⟨z, ze⟩ : w ∣ yn w1 w\n    exact modeq_zero_iff_dvd.1 ((yn_modeq_a_sub_one w1 w).trans dvd_rfl.modeq_zero_nat)\n    have nt : (↑(n ^ k) : ℤ) < 2 * a * n - n * n - 1 :=\n      by\n      refine' eq_pow_of_pell_lem hn.ne' hk.ne' _\n      calc\n        n ^ k ≤ n ^ w := Nat.pow_le_pow_of_le_right hn kw\n        _ < (w + 1) ^ w := (Nat.pow_lt_pow_of_lt_left (nat.lt_succ_of_le nw) wpos)\n        _ ≤ a := xn_ge_a_pow w1 w\n        \n    lift (2 * a * n - n * n - 1 : ℤ) to ℕ using (Nat.cast_nonneg _).trans nt.le with t te\n    have tm : «expr ≡ [MOD ]» x (y * (a - n) + n ^ k) t :=\n      by\n      apply modeq_of_dvd\n      rw [Int.ofNat_add, Int.ofNat_mul, Int.ofNat_sub na, te]\n      exact x_sub_y_dvd_pow a1 n k\n    have ta : 2 * a * n = t + (n * n + 1) :=\n      by\n      rw [← @Nat.cast_inj ℤ, Int.ofNat_add, te, sub_sub]\n      repeat' first |rw [Nat.cast_add]|rw [Nat.cast_mul]\n      rw [Nat.cast_one, sub_add_cancel, Nat.cast_two]\n    have zp : a * a - ((w + 1) * (w + 1) - 1) * (w * z) * (w * z) = 1 := ze ▸ pell_eq w1 w\n    exact ⟨w, a, t, z, a1, tm, ta, Nat.cast_lt.1 nt, nw, kw, zp⟩\n  · rintro (⟨rfl, rfl⟩ | ⟨hk0, ⟨rfl, rfl⟩ | ⟨hn0, w, a, t, z, a1, tm, ta, mt, nw, kw, zp⟩⟩)\n    · exact pow_zero n\n    · exact zero_pow hk0\n    have hw0 : 0 < w := hn0.trans_le nw\n    have hw1 : 1 < w + 1 := nat.succ_lt_succ hw0\n    rcases eq_pell hw1 zp with ⟨j, rfl, yj⟩\n    have hj0 : 0 < j := by\n      apply nat.pos_of_ne_zero\n      rintro rfl\n      exact lt_irrefl 1 a1\n    have wj : w ≤ j :=\n      nat.le_of_dvd hj0\n        (modeq_zero_iff_dvd.1 <| (yn_modeq_a_sub_one hw1 j).symm.trans <| modeq_zero_iff_dvd.2 ⟨z, yj.symm⟩)\n    have hnka : n ^ k < xn hw1 j\n    calc\n      n ^ k ≤ n ^ j := Nat.pow_le_pow_of_le_right hn0 (le_trans kw wj)\n      _ < (w + 1) ^ j := (Nat.pow_lt_pow_of_lt_left (nat.lt_succ_of_le nw) hj0)\n      _ ≤ xn hw1 j := xn_ge_a_pow hw1 j\n      \n    have nt : (↑(n ^ k) : ℤ) < 2 * xn hw1 j * n - n * n - 1 := eq_pow_of_pell_lem hn0.ne' hk0.ne' hnka\n    have na : n ≤ xn hw1 j := (Nat.le_self_pow hk0.ne' _).trans hnka.le\n    have te : (t : ℤ) = 2 * xn hw1 j * n - n * n - 1 :=\n      by\n      rw [sub_sub, eq_sub_iff_add_eq]\n      exact_mod_cast ta.symm\n    have : «expr ≡ [MOD ]» (xn a1 k) (yn a1 k * (xn hw1 j - n) + n ^ k) t :=\n      by\n      apply modeq_of_dvd\n      rw [te, Nat.cast_add, Nat.cast_mul, Int.ofNat_sub na]\n      exact x_sub_y_dvd_pow a1 n k\n    have : n ^ k % t = m % t := (this.symm.trans tm).add_left_cancel' _\n    rw [← te] at nt\n    rwa [nat.mod_eq_of_lt (Nat.cast_lt.1 nt), nat.mod_eq_of_lt mt] at this\n#align eq_pow_of_pell eq_pow_of_pell\n\n",
 "eq_pell_zd":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ√ » -/\ntheorem eq_pell_zd (b : «exprℤ√ » d) (b1 : 1 ≤ b) (hp : IsPell b) : ∃ n, b = pell_zd n :=\n  let ⟨n, h⟩ := @Zsqrtd.le_arch d b\n  eq_pell_lem n b b1 hp <|\n    h.trans <| by\n      rw [Zsqrtd.coe_nat_val] <;>\n        exact Zsqrtd.le_of_le_le (Int.ofNat_le_ofNat_of_le <| le_of_lt <| n_lt_xn _ _) (Int.ofNat_zero_le _)\n#align eq_pell_zd eq_pell_zd\n\n",
 "eq_pell_lem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ√ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ√ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ√ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ√ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ√ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ√ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ√ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ√ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ√ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ√ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ√ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ√ » -/\ntheorem eq_pell_lem : ∀ (n) (b : «exprℤ√ » d), 1 ≤ b → IsPell b → b ≤ pell_zd n → ∃ n, b = pell_zd n\n  | 0, b => fun h1 hp hl => ⟨0, @Zsqrtd.le_antisymm _ dnsq _ _ hl h1⟩\n  | n + 1, b => fun h1 hp h =>\n    have a1p : (0 : «exprℤ√ » d) ≤ ⟨a, 1⟩ := trivial\n    have am1p : (0 : «exprℤ√ » d) ≤ ⟨a, -1⟩ := show (_ : Nat) ≤ _ by simp <;> exact nat.pred_le _\n    have a1m : (⟨a, 1⟩ * ⟨a, -1⟩ : «exprℤ√ » d) = 1 := isPell_norm.1 is_pell_one\n    if ha : (⟨↑a, 1⟩ : «exprℤ√ » d) ≤ b then\n      let ⟨m, e⟩ :=\n        eq_pell_lem n (b * ⟨a, -1⟩) (by rw [← a1m] <;> exact mul_le_mul_of_nonneg_right ha am1p)\n          (isPell_mul hp (isPell_star.1 is_pell_one))\n          (by have t := mul_le_mul_of_nonneg_right h am1p <;> rwa [pell_zd_succ, mul_assoc, a1m, mul_one] at t)\n      ⟨m + 1, by\n        rw [show b = b * ⟨a, -1⟩ * ⟨a, 1⟩ by rw [mul_assoc, Eq.trans (mul_comm _ _) a1m] <;> simp, pell_zd_succ, e]⟩\n    else\n      suffices ¬1 < b from ⟨0, show b = 1 from (or.resolve_left (lt_or_eq_of_le h1) this).symm⟩\n      fun h1l => by\n      cases' b with x y <;>\n        exact by\n          have bm : (_ * ⟨_, _⟩ : «exprℤ√ » (d a1)) = 1 := Pell.isPell_norm.1 hp\n          have y0l : (0 : «exprℤ√ » (d a1)) < ⟨x - x, y - -y⟩ :=\n            sub_lt_sub h1l fun hn : (1 : «exprℤ√ » (d a1)) ≤ ⟨x, -y⟩ => by\n              have t := mul_le_mul_of_nonneg_left hn (le_trans zero_le_one h1) <;> rw [bm, mul_one] at t <;> exact h1l t\n          have yl2 : (⟨_, _⟩ : «exprℤ√ » _) < ⟨_, _⟩ :=\n            show (⟨x, y⟩ - ⟨x, -y⟩ : «exprℤ√ » (d a1)) < ⟨a, 1⟩ - ⟨a, -1⟩ from\n              sub_lt_sub ha fun hn : (⟨x, -y⟩ : «exprℤ√ » (d a1)) ≤ ⟨a, -1⟩ => by\n                have t := mul_le_mul_of_nonneg_right (mul_le_mul_of_nonneg_left hn (le_trans zero_le_one h1)) a1p <;>\n                    rw [bm, one_mul, mul_assoc, Eq.trans (mul_comm _ _) a1m, mul_one] at t <;>\n                  exact ha t\n          simp at y0l <;> simp at yl2 <;>\n            exact\n              match y, y0l, (yl2 : (⟨_, _⟩ : «exprℤ√ » _) < ⟨_, _⟩) with\n              | 0, y0l, yl2 => y0l (le_refl 0)\n              | (y + 1 : ℕ), y0l, yl2 =>\n                yl2\n                  (Zsqrtd.le_of_le_le (le_refl 0)\n                    (let t := Int.ofNat_le_ofNat_of_le (nat.succ_pos y)\n                    add_le_add t t))\n              | -[y+1], y0l, yl2 => y0l trivial\n#align eq_pell_lem eq_pell_lem\n\n",
 "eq_pell":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ√ » -/\n/-- Every solution to **Pell's equation** is recursively obtained from the initial solution\n`(1,0)` using the recursion `pell`. -/\ntheorem eq_pell {x y : ℕ} (hp : x * x - d * y * y = 1) : ∃ n, x = xn n ∧ y = yn n :=\n  have : (1 : «exprℤ√ » d) ≤ ⟨x, y⟩ :=\n    match x, hp with\n    | 0, (hp : 0 - _ = 1) => by rw [zero_tsub] at hp <;> contradiction\n    | x + 1, hp => Zsqrtd.le_of_le_le (Int.ofNat_le_ofNat_of_le <| nat.succ_pos x) (Int.ofNat_zero_le _)\n  let ⟨m, e⟩ := eq_pell_zd ⟨x, y⟩ this (is_pell_nat.2 hp)\n  ⟨m,\n    match x, y, e with\n    | _, _, rfl => ⟨rfl, rfl⟩⟩\n#align eq_pell eq_pell\n\n",
 "eq_of_xn_modeq_lem3":
 "theorem eq_of_xn_modeq_lem3 {i n} (npos : 0 < n) :\n    ∀ {j}, i < j → j ≤ 2 * n → j ≠ n → ¬(a = 2 ∧ n = 1 ∧ i = 0 ∧ j = 2) → xn i % xn n < xn j % xn n\n  | 0, ij, _, _, _ => absurd ij (nat.not_lt_zero _)\n  | j + 1, ij, j2n, jnn, ntriv =>\n    have lem2 : ∀ k > n, k ≤ 2 * n → (↑(xn k % xn n) : ℤ) = xn n - xn (2 * n - k) := fun k kn k2n =>\n      by\n      let k2nl :=\n        lt_of_add_lt_add_right <|\n          show 2 * n - k + k < n + k by\n            rw [tsub_add_cancel_of_le]\n            rw [two_mul] <;> exact add_lt_add_left kn n\n            exact k2n\n      have xle : xn (2 * n - k) ≤ xn n := le_of_lt <| strict_mono_x k2nl\n      suffices xn k % xn n = xn n - xn (2 * n - k) by rw [this, Int.ofNat_sub xle]\n      rw [← nat.mod_eq_of_lt (nat.sub_lt (x_pos a1 n) (x_pos a1 (2 * n - k)))]\n      apply modeq.add_right_cancel' (xn a1 (2 * n - k))\n      rw [tsub_add_cancel_of_le xle]\n      have t := xn_modeq_x2n_sub_lem a1 k2nl.le\n      rw [tsub_tsub_cancel_of_le k2n] at t\n      exact t.trans dvd_rfl.zero_modeq_nat\n    (lt_trichotomy j n).elim (fun jn : j < n => eq_of_xn_modeq_lem1 ij (lt_of_le_of_ne jn jnn)) fun o =>\n      o.elim\n        (fun jn : j = n => by\n          cases jn\n          apply Int.lt_of_ofNat_lt_ofNat\n          rw [lem2 (n + 1) (nat.lt_succ_self _) j2n,\n            show 2 * n - (n + 1) = n - 1 by rw [two_mul, tsub_add_eq_tsub_tsub, add_tsub_cancel_right]]\n          refine' lt_sub_left_of_add_lt (Int.ofNat_lt_ofNat_of_lt _)\n          cases' lt_or_eq_of_le <| nat.le_of_succ_le_succ ij with lin ein\n          · rw [nat.mod_eq_of_lt (strict_mono_x _ lin)]\n            have ll : xn a1 (n - 1) + xn a1 (n - 1) ≤ xn a1 n :=\n              by\n              rw [← two_mul, mul_comm,\n                show xn a1 n = xn a1 (n - 1 + 1) by rw [tsub_add_cancel_of_le (succ_le_of_lt npos)], xn_succ]\n              exact le_trans (nat.mul_le_mul_left _ a1) (nat.le_add_right _ _)\n            have npm : (n - 1).succ = n := nat.succ_pred_eq_of_pos npos\n            have il : i ≤ n - 1 := by\n              apply nat.le_of_succ_le_succ\n              rw [npm]\n              exact lin\n            cases' lt_or_eq_of_le il with ill ile\n            · exact lt_of_lt_of_le (nat.add_lt_add_left (strict_mono_x a1 ill) _) ll\n            · rw [ile]\n              apply lt_of_le_of_ne ll\n              rw [← two_mul]\n              exact fun e =>\n                ntriv <|\n                  by\n                  let ⟨a2, s1⟩ :=\n                    @eq_of_xn_modeq_lem2 _ a1 (n - 1) (by rwa [tsub_add_cancel_of_le (succ_le_of_lt npos)])\n                  have n1 : n = 1 := le_antisymm (tsub_eq_zero_iff_le.mp s1) npos\n                  rw [ile, a2, n1] <;> exact ⟨rfl, rfl, rfl, rfl⟩\n          · rw [ein, nat.mod_self, add_zero]\n            exact strict_mono_x _ (nat.pred_lt npos.ne'))\n        fun jn : j > n =>\n        have lem1 : j ≠ n → xn j % xn n < xn (j + 1) % xn n → xn i % xn n < xn (j + 1) % xn n := fun jn s =>\n          (lt_or_eq_of_le (nat.le_of_succ_le_succ ij)).elim\n            (fun h =>\n              lt_trans\n                (eq_of_xn_modeq_lem3 h (le_of_lt j2n) jn fun ⟨a1, n1, i0, j2⟩ => by\n                  rw [n1, j2] at j2n <;> exact absurd j2n (by decide))\n                s)\n            fun h => by rw [h] <;> exact s\n        lem1 (ne_of_gt jn) <|\n          Int.lt_of_ofNat_lt_ofNat <|\n            by\n            rw [lem2 j jn (le_of_lt j2n), lem2 (j + 1) (nat.le_succ_of_le jn) j2n]\n            refine' sub_lt_sub_left (Int.ofNat_lt_ofNat_of_lt <| strict_mono_x _ _) _\n            rw [nat.sub_succ]\n            exact nat.pred_lt (ne_of_gt <| tsub_pos_of_lt j2n)\n#align eq_of_xn_modeq_lem3 eq_of_xn_modeq_lem3\n\n",
 "eq_of_xn_modeq_lem2":
 "theorem eq_of_xn_modeq_lem2 {n} (h : 2 * xn n = xn (n + 1)) : a = 2 ∧ n = 0 := by\n  rw [xn_succ, mul_comm] at h <;>\n    exact\n      by\n      have : n = 0 :=\n        n.eq_zero_or_pos.resolve_right fun np =>\n          ne_of_lt\n            (lt_of_le_of_lt (nat.mul_le_mul_left _ a1)\n              (nat.lt_add_of_pos_right <| mul_pos (d_pos a1) (strict_mono_y a1 np)))\n            h\n      cases this <;> simp at h <;> exact ⟨h.symm, rfl⟩\n#align eq_of_xn_modeq_lem2 eq_of_xn_modeq_lem2\n\n",
 "eq_of_xn_modeq_lem1":
 "theorem eq_of_xn_modeq_lem1 {i n} : ∀ {j}, i < j → j < n → xn i % xn n < xn j % xn n\n  | 0, ij, _ => absurd ij (nat.not_lt_zero _)\n  | j + 1, ij, jn =>\n    by\n    suffices xn j % xn n < xn (j + 1) % xn n from\n      (lt_or_eq_of_le (nat.le_of_succ_le_succ ij)).elim (fun h => lt_trans (eq_of_xn_modeq_lem1 h (le_of_lt jn)) this)\n        fun h => by rw [h] <;> exact this\n    rw [nat.mod_eq_of_lt (strict_mono_x _ (nat.lt_of_succ_lt jn)), nat.mod_eq_of_lt (strict_mono_x _ jn)] <;>\n      exact strict_mono_x _ (nat.lt_succ_self _)\n#align eq_of_xn_modeq_lem1 eq_of_xn_modeq_lem1\n\n",
 "eq_of_xn_modeq_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≡ [MOD ]» -/\ntheorem eq_of_xn_modeq_le {i j n} (ij : i ≤ j) (j2n : j ≤ 2 * n) (h : «expr ≡ [MOD ]» (xn i) (xn j) (xn n))\n    (ntriv : ¬(a = 2 ∧ n = 1 ∧ i = 0 ∧ j = 2)) : i = j :=\n  if npos : n = 0 then by simp_all\n  else\n    (lt_or_eq_of_le ij).resolve_left fun ij' =>\n      if jn : j = n then by\n        refine' ne_of_gt _ h\n        rw [jn, nat.mod_self]\n        have x0 : 0 < xn a1 0 % xn a1 n := by\n          rw [nat.mod_eq_of_lt (strict_mono_x a1 (nat.pos_of_ne_zero npos))] <;> exact by decide\n        cases' i with i\n        exact x0\n        rw [jn] at ij'\n        exact\n          x0.trans\n            (eq_of_xn_modeq_lem3 _ (nat.pos_of_ne_zero npos) (nat.succ_pos _) (le_trans ij j2n) (ne_of_lt ij')\n              fun ⟨a1, n1, _, i2⟩ => by rw [n1, i2] at ij' <;> exact absurd ij' (by decide))\n      else ne_of_lt (eq_of_xn_modeq_lem3 (nat.pos_of_ne_zero npos) ij' j2n jn ntriv) h\n#align eq_of_xn_modeq_le eq_of_xn_modeq_le\n\n",
 "eq_of_xn_modeq'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≡ [MOD ]» -/\ntheorem eq_of_xn_modeq' {i j n} (ipos : 0 < i) (hin : i ≤ n) (j4n : j ≤ 4 * n)\n    (h : «expr ≡ [MOD ]» (xn j) (xn i) (xn n)) : j = i ∨ j + i = 4 * n :=\n  have i2n : i ≤ 2 * n := by apply le_trans hin <;> rw [two_mul] <;> apply nat.le_add_left\n  (le_or_gt j (2 * n)).imp\n    (fun j2n : j ≤ 2 * n =>\n      eq_of_xn_modeq j2n i2n h fun a2 n1 =>\n        ⟨fun j0 i2 => by rw [n1, i2] at hin <;> exact absurd hin (by decide), fun j2 i0 => ne_of_gt ipos i0⟩)\n    fun j2n : 2 * n < j =>\n    suffices i = 4 * n - j by rw [this, add_tsub_cancel_of_le j4n]\n    have j42n : 4 * n - j ≤ 2 * n :=\n      @Nat.le_of_add_le_add_right j _ _ <| by\n        rw [tsub_add_cancel_of_le j4n, show 4 * n = 2 * n + 2 * n from right_distrib 2 2 n] <;>\n          exact nat.add_le_add_left (le_of_lt j2n) _\n    eq_of_xn_modeq i2n j42n\n      (h.symm.trans <| by\n        let t := xn_modeq_x4n_sub j42n\n        rwa [tsub_tsub_cancel_of_le j4n] at t)\n      fun a2 n1 =>\n      ⟨fun i0 => absurd i0 (ne_of_gt ipos), fun i2 =>\n        by\n        rw [n1, i2] at hin\n        exact absurd hin (by decide)⟩\n#align eq_of_xn_modeq' eq_of_xn_modeq'\n\n",
 "eq_of_xn_modeq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≡ [MOD ]» -/\ntheorem eq_of_xn_modeq {i j n} (i2n : i ≤ 2 * n) (j2n : j ≤ 2 * n) (h : «expr ≡ [MOD ]» (xn i) (xn j) (xn n))\n    (ntriv : a = 2 → n = 1 → (i = 0 → j ≠ 2) ∧ (i = 2 → j ≠ 0)) : i = j :=\n  (le_total i j).elim (fun ij => eq_of_xn_modeq_le ij j2n h fun ⟨a2, n1, i0, j2⟩ => (ntriv a2 n1).left i0 j2) fun ij =>\n    (eq_of_xn_modeq_le ij i2n h.symm fun ⟨a2, n1, j0, i2⟩ => (ntriv a2 n1).right i2 j0).symm\n#align eq_of_xn_modeq eq_of_xn_modeq\n\n",
 "dz_val":
 "theorem dz_val : ↑d = az * az - 1 :=\n  have : 1 ≤ a * a := asq_pos\n  show ↑(a * a - 1) = _ by rw [Int.ofNat_sub this] <;> rfl\n#align dz_val dz_val\n\n",
 "dvd_of_ysq_dvd":
 "theorem dvd_of_ysq_dvd {n t} (h : yn n * yn n ∣ yn t) : yn n ∣ t :=\n  have nt : n ∣ t := (y_dvd_iff n t).1 <| dvd_of_mul_left_dvd h\n  n.eq_zero_or_pos.elim (fun n0 => by rwa [n0] at nt⊢) fun n0l : 0 < n =>\n    by\n    let ⟨k, ke⟩ := nt\n    have : yn n ∣ k * xn n ^ (k - 1) :=\n      Nat.dvd_of_mul_dvd_mul_right (strict_mono_y n0l) <|\n        modEq_zero_iff_dvd.1 <| by\n          have xm := (xy_modeq_yn a1 n k).right <;> rw [← ke] at xm <;>\n            exact (xm.of_dvd <| by simp [pow_succ]).symm.trans h.modeq_zero_nat\n    rw [ke] <;> exact dvd_mul_of_dvd_right (((xy_coprime _ _).pow_left _).symm.dvd_of_dvd_mul_right this) _\n#align dvd_of_ysq_dvd dvd_of_ysq_dvd\n\n",
 "d_pos":
 "@[simp]\ntheorem d_pos : 0 < d :=\n  tsub_pos_of_lt (mul_lt_mul a1 (le_of_lt a1) (by decide) (by decide) : 1 * 1 < a * a)\n#align d_pos d_pos\n\n",
 "asq_pos":
 "theorem asq_pos : 0 < a * a :=\n  le_trans (le_of_lt a1) (by have := @nat.mul_le_mul_left 1 a a (le_of_lt a1) <;> rwa [mul_one] at this)\n#align asq_pos asq_pos\n\n"}