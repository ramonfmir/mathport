{"sum_four_squares_of_two_mul_sum_four_squares":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ᵥ » -/\nprivate theorem sum_four_squares_of_two_mul_sum_four_squares {m a b c d : ℤ}\n    (h : a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2 = 2 * m) : ∃ w x y z : ℤ, w ^ 2 + x ^ 2 + y ^ 2 + z ^ 2 = m :=\n  have :\n    ∀ f : Fin 4 → ZMod 2,\n      f 0 ^ 2 + f 1 ^ 2 + f 2 ^ 2 + f 3 ^ 2 = 0 →\n        ∃ i : Fin 4, f i ^ 2 + f (swap i 0 1) ^ 2 = 0 ∧ f (swap i 0 2) ^ 2 + f (swap i 0 3) ^ 2 = 0 :=\n    by decide\n  let f : Fin 4 → ℤ := Vector.get («expr ::ᵥ » a («expr ::ᵥ » b («expr ::ᵥ » c («expr ::ᵥ » d Vector.nil))))\n  let ⟨i, hσ⟩ :=\n    this (fun x => coe (f x))\n      (by\n        rw [← @MulZeroClass.zero_mul (ZMod 2) _ m, ← show ((2 : ℤ) : ZMod 2) = 0 from rfl, ← Int.cast_mul, ← h] <;>\n            simp only [Int.cast_add, Int.cast_pow] <;>\n          rfl)\n  let σ := swap i 0\n  have h01 : 2 ∣ f (σ 0) ^ 2 + f (σ 1) ^ 2 :=\n    (CharP.int_cast_eq_zero_iff (ZMod 2) 2 _).1 <| by\n      simpa only [Int.cast_pow, Int.cast_add, Equiv.swap_apply_right, zmod.pow_card] using hσ.1\n  have h23 : 2 ∣ f (σ 2) ^ 2 + f (σ 3) ^ 2 :=\n    (CharP.int_cast_eq_zero_iff (ZMod 2) 2 _).1 <| by simpa only [Int.cast_pow, Int.cast_add, zmod.pow_card] using hσ.2\n  let ⟨x, hx⟩ := h01\n  let ⟨y, hy⟩ := h23\n  ⟨(f (σ 0) - f (σ 1)) / 2, (f (σ 0) + f (σ 1)) / 2, (f (σ 2) - f (σ 3)) / 2, (f (σ 2) + f (σ 3)) / 2,\n    by\n    rw [← int.sq_add_sq_of_two_mul_sq_add_sq hx.symm, add_assoc, ← int.sq_add_sq_of_two_mul_sq_add_sq hy.symm, ←\n      mul_right_inj' (show (2 : ℤ) ≠ 0 by decide), ← h, mul_add, ← hx, ← hy]\n    have :\n      finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n          (f (σ x) ^ 2) =\n        finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n          (f x ^ 2) :=\n      by conv_rhs => rw [← Equiv.sum_comp σ]\n    simpa only [Fin.sum_univ_four, add_assoc] using this⟩\n#align sum_four_squares_of_two_mul_sum_four_squares sum_four_squares_of_two_mul_sum_four_squares\n\n",
 "sum_four_squares":
 "/-- **Four squares theorem** -/\ntheorem sum_four_squares : ∀ n : ℕ, ∃ a b c d : ℕ, a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2 = n\n  | 0 => ⟨0, 0, 0, 0, rfl⟩\n  | 1 => ⟨1, 0, 0, 0, rfl⟩\n  | n@(k + 2) =>\n    have hm : Fact (minFac (k + 2)).prime := ⟨minFac_prime (by decide)⟩\n    have : n / minFac n < n := factors_lemma\n    let ⟨a, b, c, d, h₁⟩ :=\n      show ∃ a b c d : ℤ, a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2 = minFac n from prime_sum_four_squares (min_fac (k + 2))\n    let ⟨w, x, y, z, h₂⟩ := sum_four_squares (n / minFac n)\n    ⟨(a * w - b * x - c * y - d * z).nat_abs, (a * x + b * w + c * z - d * y).nat_abs,\n      (a * y - b * z + c * w + d * x).nat_abs, (a * z + b * y - c * x + d * w).nat_abs,\n      by\n      rw [← Int.coe_nat_inj', ← Nat.mul_div_cancel' (min_fac_dvd (k + 2)), Int.ofNat_mul, ← h₁, ← h₂]\n      simp [sum_four_sq_mul_sum_four_sq]⟩\n#align sum_four_squares sum_four_squares\n\n",
 "sq_add_sq_of_two_mul_sq_add_sq":
 "/-\nCopyright (c) 2019 Chris Hughes. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Chris Hughes\n-/\ntheorem sq_add_sq_of_two_mul_sq_add_sq {m x y : ℤ} (h : 2 * m = x ^ 2 + y ^ 2) :\n    m = ((x - y) / 2) ^ 2 + ((x + y) / 2) ^ 2 :=\n  have : Even (x ^ 2 + y ^ 2) := by simp [← h, even_mul]\n  have hxaddy : Even (x + y) := by simpa [sq, parity_simps]\n  have hxsuby : Even (x - y) := by simpa [sq, parity_simps]\n  (mul_right_inj' (show (2 * 2 : ℤ) ≠ 0 by decide)).1 <|\n    calc\n      2 * 2 * m = (x - y) ^ 2 + (x + y) ^ 2 := by rw [mul_assoc, h] <;> ring\n      _ = (2 * ((x - y) / 2)) ^ 2 + (2 * ((x + y) / 2)) ^ 2 :=\n        by\n        rw [even_iff_two_dvd] at hxsuby hxaddy\n        rw [Int.mul_ediv_cancel' hxsuby, Int.mul_ediv_cancel' hxaddy]\n      _ = 2 * 2 * (((x - y) / 2) ^ 2 + ((x + y) / 2) ^ 2) := by\n        simp [mul_add, pow_succ, mul_comm, mul_assoc, mul_left_comm]\n      \n#align sq_add_sq_of_two_mul_sq_add_sq sq_add_sq_of_two_mul_sq_add_sq\n\n",
 "prime_sum_four_squares":
 "private theorem prime_sum_four_squares (p : ℕ) [hp : Fact p.prime] : ∃ a b c d : ℤ, a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2 = p :=\n  have hm : ∃ m < p, 0 < m ∧ ∃ a b c d : ℤ, a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2 = m * p :=\n    let ⟨a, b, k, hk⟩ := exists_sq_add_sq_add_one_eq_k p\n    ⟨k, hk.2,\n      nat.pos_of_ne_zero fun hk0 => by\n        rw [hk0, Int.ofNat_zero, MulZeroClass.zero_mul] at hk\n        exact\n          ne_of_gt\n            (show a ^ 2 + b ^ 2 + 1 > 0 from\n              add_pos_of_nonneg_of_pos (add_nonneg (sq_nonneg _) (sq_nonneg _)) zero_lt_one)\n            hk.1,\n      a, b, 1, 0, by simpa only [zero_pow two_pos, one_pow, add_zero] using hk.1⟩\n  let m := nat.find hm\n  let ⟨a, b, c, d, (habcd : a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2 = m * p)⟩ := (nat.find_spec hm).snd.2\n  haveI hm0 : NeZero m := NeZero.of_pos (nat.find_spec hm).snd.1\n  have hmp : m < p := (nat.find_spec hm).fst\n  m.mod_two_eq_zero_or_one.elim\n    (fun hm2 : m % 2 = 0 =>\n      let ⟨k, hk⟩ := nat.dvd_iff_mod_eq_zero.2 hm2\n      have hk0 : 0 < k :=\n        nat.pos_of_ne_zero <| by\n          rintro rfl\n          rw [MulZeroClass.mul_zero] at hk\n          exact NeZero.ne m hk\n      have hkm : k < m := by rw [hk, two_mul]; exact (lt_add_iff_pos_left _).2 hk0\n      false.elim <|\n        nat.find_min hm hkm\n          ⟨lt_trans hkm hmp, hk0,\n            sum_four_squares_of_two_mul_sum_four_squares\n              (show a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2 = 2 * (k * p)\n                by\n                rw [habcd, hk, Int.ofNat_mul, mul_assoc]\n                norm_num)⟩)\n    fun hm2 : m % 2 = 1 =>\n    if hm1 : m = 1 then ⟨a, b, c, d, by simp only [hm1, habcd, Int.ofNat_one, one_mul]⟩\n    else\n      let w := (a : ZMod m).val_min_abs\n      let x := (b : ZMod m).val_min_abs\n      let y := (c : ZMod m).val_min_abs\n      let z := (d : ZMod m).val_min_abs\n      have hnat_abs :\n        w ^ 2 + x ^ 2 + y ^ 2 + z ^ 2 = (w.nat_abs ^ 2 + x.nat_abs ^ 2 + y.nat_abs ^ 2 + z.nat_abs ^ 2 : ℕ) :=\n        by\n        push_cast\n        simp_rw [sq_abs]\n      have hwxyzlt : w ^ 2 + x ^ 2 + y ^ 2 + z ^ 2 < m ^ 2 :=\n        calc\n          w ^ 2 + x ^ 2 + y ^ 2 + z ^ 2 = (w.nat_abs ^ 2 + x.nat_abs ^ 2 + y.nat_abs ^ 2 + z.nat_abs ^ 2 : ℕ) :=\n            hnat_abs\n          _ ≤ ((m / 2) ^ 2 + (m / 2) ^ 2 + (m / 2) ^ 2 + (m / 2) ^ 2 : ℕ) :=\n            (Int.ofNat_le.2 <|\n              add_le_add\n                (add_le_add\n                  (add_le_add (Nat.pow_le_pow_of_le_left (ZMod.natAbs_valMinAbs_le _) _)\n                    (Nat.pow_le_pow_of_le_left (ZMod.natAbs_valMinAbs_le _) _))\n                  (Nat.pow_le_pow_of_le_left (ZMod.natAbs_valMinAbs_le _) _))\n                (Nat.pow_le_pow_of_le_left (ZMod.natAbs_valMinAbs_le _) _))\n          _ = 4 * (m / 2 : ℕ) ^ 2 := by simp only [bit0_mul, one_mul, two_smul, Nat.cast_add, Nat.cast_pow, add_assoc]\n          _ < 4 * (m / 2 : ℕ) ^ 2 + ((4 * (m / 2) : ℕ) * (m % 2 : ℕ) + (m % 2 : ℕ) ^ 2) :=\n            ((lt_add_iff_pos_right _).2\n              (by\n                rw [hm2, Int.ofNat_one, one_pow, mul_one]\n                exact add_pos_of_nonneg_of_pos (Int.coe_nat_nonneg _) zero_lt_one))\n          _ = m ^ 2 := by\n            conv_rhs => rw [← nat.mod_add_div m 2]\n            simp [-nat.mod_add_div, mul_add, add_mul, bit0, bit1, mul_comm, mul_assoc, mul_left_comm, pow_add, add_comm,\n              add_left_comm]\n          \n      have hwxyzabcd :\n        ((w ^ 2 + x ^ 2 + y ^ 2 + z ^ 2 : ℤ) : ZMod m) = ((a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2 : ℤ) : ZMod m) := by push_cast\n      have hwxyz0 : ((w ^ 2 + x ^ 2 + y ^ 2 + z ^ 2 : ℤ) : ZMod m) = 0 := by\n        rw [hwxyzabcd, habcd, Int.cast_mul, cast_coe_nat, ZMod.nat_cast_self, MulZeroClass.zero_mul]\n      let ⟨n, hn⟩ := (CharP.int_cast_eq_zero_iff _ m _).1 hwxyz0\n      have hn0 : 0 < n.nat_abs :=\n        Int.natAbs_pos_of_ne_zero fun hn0 =>\n          have hwxyz0 : (w.nat_abs ^ 2 + x.nat_abs ^ 2 + y.nat_abs ^ 2 + z.nat_abs ^ 2 : ℕ) = 0 :=\n            by\n            rw [← Int.coe_nat_eq_zero, ← hnat_abs]\n            rwa [hn0, MulZeroClass.mul_zero] at hn\n          have habcd0 : (m : ℤ) ∣ a ∧ (m : ℤ) ∣ b ∧ (m : ℤ) ∣ c ∧ (m : ℤ) ∣ d := by\n            simpa only [add_eq_zero_iff, Int.natAbs_eq_zero, ZMod.valMinAbs_eq_zero, and_assoc, pow_eq_zero_iff two_pos,\n              CharP.int_cast_eq_zero_iff _ m _] using hwxyz0\n          let ⟨ma, hma⟩ := habcd0.1\n          let ⟨mb, hmb⟩ := habcd0.2.1\n          let ⟨mc, hmc⟩ := habcd0.2.2.1\n          let ⟨md, hmd⟩ := habcd0.2.2.2\n          have hmdvdp : m ∣ p :=\n            Int.coe_nat_dvd.1\n              ⟨ma ^ 2 + mb ^ 2 + mc ^ 2 + md ^ 2,\n                (mul_right_inj' (show (m : ℤ) ≠ 0 from Int.coe_nat_ne_zero.2 hm0.1)).1 <|\n                  by\n                  rw [← habcd, hma, hmb, hmc, hmd]\n                  ring⟩\n          (hp.1.eq_one_or_self_of_dvd _ hmdvdp).elim hm1 fun hmeqp => by simpa [lt_irrefl, hmeqp] using hmp\n      have hawbxcydz : ((m : ℕ) : ℤ) ∣ a * w + b * x + c * y + d * z :=\n        (CharP.int_cast_eq_zero_iff (ZMod m) m _).1 <| by\n          rw [← hwxyz0]\n          simp_rw [sq]\n          push_cast\n      have haxbwczdy : ((m : ℕ) : ℤ) ∣ a * x - b * w - c * z + d * y :=\n        (CharP.int_cast_eq_zero_iff (ZMod m) m _).1 <| by\n          push_cast\n          ring\n      have haybzcwdx : ((m : ℕ) : ℤ) ∣ a * y + b * z - c * w - d * x :=\n        (CharP.int_cast_eq_zero_iff (ZMod m) m _).1 <| by\n          push_cast\n          ring\n      have hazbycxdw : ((m : ℕ) : ℤ) ∣ a * z - b * y + c * x - d * w :=\n        (CharP.int_cast_eq_zero_iff (ZMod m) m _).1 <| by\n          push_cast\n          ring\n      let ⟨s, hs⟩ := hawbxcydz\n      let ⟨t, ht⟩ := haxbwczdy\n      let ⟨u, hu⟩ := haybzcwdx\n      let ⟨v, hv⟩ := hazbycxdw\n      have hn_nonneg : 0 ≤ n :=\n        nonneg_of_mul_nonneg_right\n          (by\n            erw [← hn]\n            repeat' try refine' add_nonneg _ _; try exact sq_nonneg _)\n          (Int.coe_nat_pos.2 <| NeZero.pos m)\n      have hnm : n.nat_abs < m :=\n        Int.ofNat_lt.1\n          (lt_of_mul_lt_mul_left\n            (by\n              rw [Int.natAbs_of_nonneg hn_nonneg, ← hn, ← sq]\n              exact hwxyzlt)\n            (Int.coe_nat_nonneg m))\n      have hstuv : s ^ 2 + t ^ 2 + u ^ 2 + v ^ 2 = n.nat_abs * p :=\n        (mul_right_inj' (show (m ^ 2 : ℤ) ≠ 0 from pow_ne_zero 2 (Int.coe_nat_ne_zero.2 hm0.1))).1 <|\n          calc\n            (m : ℤ) ^ 2 * (s ^ 2 + t ^ 2 + u ^ 2 + v ^ 2) =\n                ((m : ℕ) * s) ^ 2 + ((m : ℕ) * t) ^ 2 + ((m : ℕ) * u) ^ 2 + ((m : ℕ) * v) ^ 2 :=\n              by\n              simp [mul_pow]\n              ring\n            _ = (w ^ 2 + x ^ 2 + y ^ 2 + z ^ 2) * (a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2) :=\n              by\n              simp only [hs.symm, ht.symm, hu.symm, hv.symm]\n              ring\n            _ = _ := by\n              rw [hn, habcd, Int.natAbs_of_nonneg hn_nonneg]\n              dsimp [m]\n              ring\n            \n      false.elim <| nat.find_min hm hnm ⟨lt_trans hnm hmp, hn0, s, t, u, v, hstuv⟩\n#align prime_sum_four_squares prime_sum_four_squares\n\n",
 "exists_sq_add_sq_add_one_eq_k":
 "theorem exists_sq_add_sq_add_one_eq_k (p : ℕ) [hp : Fact p.prime] :\n    ∃ (a b : ℤ)(k : ℕ), a ^ 2 + b ^ 2 + 1 = k * p ∧ k < p :=\n  hp.1.eq_two_or_odd.elim (fun hp2 => hp2.symm ▸ ⟨1, 0, 1, rfl, by decide⟩) fun hp1 =>\n    let ⟨a, b, hab⟩ := zmod.sq_add_sq p (-1)\n    have hab' : (p : ℤ) ∣ a.val_min_abs ^ 2 + b.val_min_abs ^ 2 + 1 :=\n      (CharP.int_cast_eq_zero_iff (ZMod p) p _).1 <| by simpa [eq_neg_iff_add_eq_zero] using hab\n    let ⟨k, hk⟩ := hab'\n    have hk0 : 0 ≤ k :=\n      nonneg_of_mul_nonneg_right\n        (by rw [← hk] <;> exact add_nonneg (add_nonneg (sq_nonneg _) (sq_nonneg _)) zero_le_one)\n        (Int.coe_nat_pos.2 hp.1.pos)\n    ⟨a.val_min_abs, b.val_min_abs, k.nat_abs, by rw [hk, Int.natAbs_of_nonneg hk0, mul_comm],\n      lt_of_mul_lt_mul_left\n        (calc\n          p * k.nat_abs = a.val_min_abs.nat_abs ^ 2 + b.val_min_abs.nat_abs ^ 2 + 1 := by\n            rw [← Int.coe_nat_inj', Int.ofNat_add, Int.ofNat_add, Int.coe_nat_pow, Int.coe_nat_pow, Int.natAbs_sq,\n              Int.natAbs_sq, Int.ofNat_one, hk, Int.ofNat_mul, Int.natAbs_of_nonneg hk0]\n          _ ≤ (p / 2) ^ 2 + (p / 2) ^ 2 + 1 :=\n            (add_le_add\n              (add_le_add (Nat.pow_le_pow_of_le_left (ZMod.natAbs_valMinAbs_le _) _)\n                (Nat.pow_le_pow_of_le_left (ZMod.natAbs_valMinAbs_le _) _))\n              le_rfl)\n          _ < (p / 2) ^ 2 + (p / 2) ^ 2 + (p % 2) ^ 2 + (2 * (p / 2) ^ 2 + 4 * (p / 2) * (p % 2)) := by\n            rw [hp1, one_pow, mul_one] <;>\n              exact\n                (lt_add_iff_pos_right _).2\n                  (add_pos_of_nonneg_of_pos (nat.zero_le _) (mul_pos (by decide) (Nat.div_pos hp.1.two_le (by decide))))\n          _ = p * p := by\n            conv_rhs => rw [← nat.mod_add_div p 2]\n            ring\n          )\n        (show 0 ≤ p from nat.zero_le _)⟩\n#align exists_sq_add_sq_add_one_eq_k exists_sq_add_sq_add_one_eq_k\n\n"}