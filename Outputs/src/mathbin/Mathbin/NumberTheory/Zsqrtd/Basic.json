{"zero_re":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ√ » -/\n@[simp]\ntheorem zero_re : (0 : «exprℤ√ » d).re = 0 :=\n  rfl\n#align zero_re zero_re\n\n",
 "zero_im":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ√ » -/\n@[simp]\ntheorem zero_im : (0 : «exprℤ√ » d).im = 0 :=\n  rfl\n#align zero_im zero_im\n\n",
 "sqrtd_re":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ√ » -/\n@[simp]\ntheorem sqrtd_re : (sqrtd : «exprℤ√ » d).re = 0 :=\n  rfl\n#align sqrtd_re sqrtd_re\n\n",
 "sqrtd_im":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ√ » -/\n@[simp]\ntheorem sqrtd_im : (sqrtd : «exprℤ√ » d).im = 1 :=\n  rfl\n#align sqrtd_im sqrtd_im\n\n",
 "sq_le_smul":
 "theorem sq_le_smul {c d x y : ℕ} (n : ℕ) (xy : sq_le x c y d) : sq_le (n * x) c (n * y) d := by\n  simpa [sq_le, mul_left_comm, mul_assoc] using nat.mul_le_mul_left (n * n) xy\n#align sq_le_smul sq_le_smul\n\n",
 "sq_le_of_le":
 "theorem sq_le_of_le {c d x y z w : ℕ} (xz : z ≤ x) (yw : y ≤ w) (xy : sq_le x c y d) : sq_le z c w d :=\n  le_trans (mul_le_mul (nat.mul_le_mul_left _ xz) xz (nat.zero_le _) (nat.zero_le _)) <|\n    le_trans xy (mul_le_mul (nat.mul_le_mul_left _ yw) yw (nat.zero_le _) (nat.zero_le _))\n#align sq_le_of_le sq_le_of_le\n\n",
 "sq_le_mul":
 "theorem sq_le_mul {d x y z w : ℕ} :\n    (sq_le x 1 y d → sq_le z 1 w d → sq_le (x * w + y * z) d (x * z + d * y * w) 1) ∧\n      (sq_le x 1 y d → sq_le w d z 1 → sq_le (x * z + d * y * w) 1 (x * w + y * z) d) ∧\n        (sq_le y d x 1 → sq_le z 1 w d → sq_le (x * z + d * y * w) 1 (x * w + y * z) d) ∧\n          (sq_le y d x 1 → sq_le w d z 1 → sq_le (x * w + y * z) d (x * z + d * y * w) 1) :=\n  by\n  refine' ⟨_, _, _, _⟩ <;>\n    · intro xy zw\n      have :=\n        int.mul_nonneg (sub_nonneg_of_le (Int.ofNat_le_ofNat_of_le xy)) (sub_nonneg_of_le (Int.ofNat_le_ofNat_of_le zw))\n      refine' Int.le_of_ofNat_le_ofNat (le_of_sub_nonneg _)\n      convert this\n      simp only [one_mul, Int.ofNat_add, Int.ofNat_mul]\n      ring\n#align sq_le_mul sq_le_mul\n\n",
 "sq_le_cancel":
 "theorem sq_le_cancel {c d x y z w : ℕ} (zw : sq_le y d x c) (h : sq_le (x + z) c (y + w) d) : sq_le z c w d :=\n  by\n  apply le_of_not_gt\n  intro l\n  refine' not_le_of_gt _ h\n  simp [sq_le, mul_add, mul_comm, mul_left_comm, add_assoc]\n  have hm := sq_le_add_mixed zw (le_of_lt l)\n  simp [sq_le, mul_assoc] at l zw\n  exact\n    lt_of_le_of_lt (add_le_add_right zw _) (add_lt_add_left (add_lt_add_of_le_of_lt hm (add_lt_add_of_le_of_lt hm l)) _)\n#align sq_le_cancel sq_le_cancel\n\n",
 "sq_le_add_mixed":
 "theorem sq_le_add_mixed {c d x y z w : ℕ} (xy : sq_le x c y d) (zw : sq_le z c w d) : c * (x * z) ≤ d * (y * w) :=\n  Nat.mul_self_le_mul_self_iff.2 <| by\n    simpa [mul_comm, mul_left_comm] using mul_le_mul xy zw (nat.zero_le _) (nat.zero_le _)\n#align sq_le_add_mixed sq_le_add_mixed\n\n",
 "sq_le_add":
 "theorem sq_le_add {c d x y z w : ℕ} (xy : sq_le x c y d) (zw : sq_le z c w d) : sq_le (x + z) c (y + w) d :=\n  by\n  have xz := sq_le_add_mixed xy zw\n  simp [sq_le, mul_assoc] at xy zw\n  simp [sq_le, mul_add, mul_comm, mul_left_comm, add_le_add, *]\n#align sq_le_add sq_le_add\n\n",
 "smuld_val":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ√ » -/\n@[simp]\ntheorem smuld_val (n x y : ℤ) : sqrtd * (n : «exprℤ√ » d) * ⟨x, y⟩ = ⟨d * n * y, n * x⟩ := by simp [ext]\n#align smuld_val smuld_val\n\n",
 "smul_val":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ√ » -/\n@[simp]\ntheorem smul_val (n x y : ℤ) : (n : «exprℤ√ » d) * ⟨x, y⟩ = ⟨n * x, n * y⟩ := by simp [ext]\n#align smul_val smul_val\n\n",
 "smul_re":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ√ » -/\ntheorem smul_re (a : ℤ) (b : «exprℤ√ » d) : (↑a * b).re = a * b.re := by simp\n#align smul_re smul_re\n\n",
 "smul_im":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ√ » -/\ntheorem smul_im (a : ℤ) (b : «exprℤ√ » d) : (↑a * b).im = a * b.im := by simp\n#align smul_im smul_im\n\n",
 "one_re":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ√ » -/\n@[simp]\ntheorem one_re : (1 : «exprℤ√ » d).re = 1 :=\n  rfl\n#align one_re one_re\n\n",
 "one_im":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ√ » -/\n@[simp]\ntheorem one_im : (1 : «exprℤ√ » d).im = 0 :=\n  rfl\n#align one_im one_im\n\n",
 "of_int_re":
 "theorem of_int_re (n : ℤ) : (of_int n).re = n :=\n  rfl\n#align of_int_re of_int_re\n\n",
 "of_int_im":
 "theorem of_int_im (n : ℤ) : (of_int n).im = 0 :=\n  rfl\n#align of_int_im of_int_im\n\n",
 "of_int_eq_coe":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ√ » -/\n@[simp]\ntheorem of_int_eq_coe (n : ℤ) : (of_int n : «exprℤ√ » d) = n := by simp [ext, of_int_re, of_int_im]\n#align of_int_eq_coe of_int_eq_coe\n\n",
 "not_sq_le_succ":
 "theorem not_sq_le_succ (c d y) (h : 0 < c) : ¬sq_le (y + 1) c 0 d :=\n  not_le_of_gt <| mul_pos (mul_pos h <| nat.succ_pos _) <| nat.succ_pos _\n#align not_sq_le_succ not_sq_le_succ\n\n",
 "not_divides_sq":
 "theorem not_divides_sq (x y) : (x + 1) * (x + 1) ≠ d * (y + 1) * (y + 1) := fun e => by\n  have t := (divides_sq_eq_zero e).left <;> contradiction\n#align not_divides_sq not_divides_sq\n\n",
 "norm_zero":
 "@[simp]\ntheorem norm_zero : norm 0 = 0 := by simp [norm]\n#align norm_zero norm_zero\n\n",
 "norm_one":
 "@[simp]\ntheorem norm_one : norm 1 = 1 := by simp [norm]\n#align norm_one norm_one\n\n",
 "norm_nonneg":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ√ » -/\ntheorem norm_nonneg (hd : d ≤ 0) (n : «exprℤ√ » d) : 0 ≤ n.norm :=\n  add_nonneg (mul_self_nonneg _)\n    (by rw [mul_assoc, neg_mul_eq_neg_mul] <;> exact mul_nonneg (neg_nonneg.2 hd) (mul_self_nonneg _))\n#align norm_nonneg norm_nonneg\n\n",
 "norm_neg":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ√ » -/\n@[simp]\ntheorem norm_neg (x : «exprℤ√ » d) : (-x).norm = x.norm :=\n  coe_int_inj <| by simp only [norm_eq_mul_conj, conj_neg, neg_mul, mul_neg, neg_neg]\n#align norm_neg norm_neg\n\n",
 "norm_nat_cast":
 "@[simp]\ntheorem norm_nat_cast (n : ℕ) : norm n = n * n :=\n  norm_int_cast n\n#align norm_nat_cast norm_nat_cast\n\n",
 "norm_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ√ » -/\n@[simp]\ntheorem norm_mul (n m : «exprℤ√ » d) : norm (n * m) = norm n * norm m :=\n  by\n  simp only [norm, mul_im, mul_re]\n  ring\n#align norm_mul norm_mul\n\n",
 "norm_int_cast":
 "@[simp]\ntheorem norm_int_cast (n : ℤ) : norm n = n * n := by simp [norm]\n#align norm_int_cast norm_int_cast\n\n",
 "norm_eq_zero_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ√ » -/\ntheorem norm_eq_zero_iff {d : ℤ} (hd : d < 0) (z : «exprℤ√ » d) : z.norm = 0 ↔ z = 0 :=\n  by\n  constructor\n  · intro h\n    rw [ext, zero_re, zero_im]\n    rw [norm_def, sub_eq_add_neg, mul_assoc] at h\n    have left := mul_self_nonneg z.re\n    have right := neg_nonneg.mpr (mul_nonpos_of_nonpos_of_nonneg hd.le (mul_self_nonneg z.im))\n    obtain ⟨ha, hb⟩ := (add_eq_zero_iff' left right).mp h\n    constructor <;> apply eq_zero_of_mul_self_eq_zero\n    · exact ha\n    · rw [neg_eq_zero, mul_eq_zero] at hb\n      exact hb.resolve_left hd.ne\n  · rintro rfl\n    exact norm_zero\n#align norm_eq_zero_iff norm_eq_zero_iff\n\n",
 "norm_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ√ » -/\ntheorem norm_eq_zero {d : ℤ} (h_nonsquare : ∀ n : ℤ, d ≠ n * n) (a : «exprℤ√ » d) : norm a = 0 ↔ a = 0 :=\n  by\n  refine' ⟨fun ha => ext.mpr _, fun h => by rw [h, norm_zero]⟩\n  delta norm at ha\n  rw [sub_eq_zero] at ha\n  by_cases h : 0 ≤ d\n  · obtain ⟨d', rfl⟩ := Int.eq_ofNat_of_zero_le h\n    haveI : nonsquare d' := ⟨fun n h => h_nonsquare n <| by exact_mod_cast h⟩\n    exact divides_sq_eq_zero_z ha\n  · push_neg  at h\n    suffices a.re * a.re = 0 by\n      rw [eq_zero_of_mul_self_eq_zero this] at ha⊢\n      simpa only [true_and_iff, or_self_right, zero_re, zero_im, eq_self_iff_true, zero_eq_mul, mul_zero, mul_eq_zero,\n        h.ne, false_or_iff, or_self_iff] using ha\n    apply _root_.le_antisymm _ (mul_self_nonneg _)\n    rw [ha, mul_assoc]\n    exact mul_nonpos_of_nonpos_of_nonneg h.le (mul_self_nonneg _)\n#align norm_eq_zero norm_eq_zero\n\n",
 "norm_eq_one_iff'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ√ » -/\ntheorem norm_eq_one_iff' {d : ℤ} (hd : d ≤ 0) (z : «exprℤ√ » d) : z.norm = 1 ↔ is_unit z := by\n  rw [← norm_eq_one_iff, ← Int.coe_nat_inj', Int.natAbs_of_nonneg (norm_nonneg hd z), Int.ofNat_one]\n#align norm_eq_one_iff' norm_eq_one_iff'\n\n",
 "norm_eq_one_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ√ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ√ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ√ » -/\ntheorem norm_eq_one_iff {x : «exprℤ√ » d} : x.norm.nat_abs = 1 ↔ is_unit x :=\n  ⟨fun h =>\n    isUnit_iff_dvd_one.2 <|\n      (le_total 0 (norm x)).cases_on\n        (fun hx =>\n          show x ∣ 1 from\n            ⟨x.conj, by\n              rwa [← Int.coe_nat_inj', Int.natAbs_of_nonneg hx, ← @Int.cast_inj («exprℤ√ » d) _ _, norm_eq_mul_conj,\n                eq_comm] at h⟩)\n        fun hx =>\n        show x ∣ 1 from\n          ⟨-x.conj, by\n            rwa [← Int.coe_nat_inj', Int.ofNat_natAbs_of_nonpos hx, ← @Int.cast_inj («exprℤ√ » d) _ _, Int.cast_neg,\n              norm_eq_mul_conj, neg_mul_eq_mul_neg, eq_comm] at h⟩,\n    fun h => by\n    let ⟨y, hy⟩ := isUnit_iff_dvd_one.1 h\n    have := congr_arg (Int.natAbs ∘ norm) hy\n    rw [Function.comp_apply, Function.comp_apply, norm_mul, Int.natAbs_mul, norm_one, Int.natAbs_one, eq_comm,\n      Nat.mul_eq_one_iff] at this\n    exact this.1⟩\n#align norm_eq_one_iff norm_eq_one_iff\n\n",
 "norm_eq_of_associated":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ√ » -/\ntheorem norm_eq_of_associated {d : ℤ} (hd : d ≤ 0) {x y : «exprℤ√ » d} (h : Associated x y) : x.norm = y.norm :=\n  by\n  obtain ⟨u, rfl⟩ := h\n  rw [norm_mul, (norm_eq_one_iff' hd _).mpr u.is_unit, mul_one]\n#align norm_eq_of_associated norm_eq_of_associated\n\n",
 "norm_eq_mul_conj":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ√ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ√ » -/\ntheorem norm_eq_mul_conj (n : «exprℤ√ » d) : (norm n : «exprℤ√ » d) = n * n.conj := by\n  cases n <;> simp [norm, conj, zsqrtd.ext, mul_comm, sub_eq_add_neg]\n#align norm_eq_mul_conj norm_eq_mul_conj\n\n",
 "norm_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ√ » -/\ntheorem norm_def (n : «exprℤ√ » d) : n.norm = n.re * n.re - d * n.im * n.im :=\n  rfl\n#align norm_def norm_def\n\n",
 "norm_conj":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ√ » -/\n@[simp]\ntheorem norm_conj (x : «exprℤ√ » d) : x.conj.norm = x.norm :=\n  coe_int_inj <| by simp only [norm_eq_mul_conj, conj_conj, mul_comm]\n#align norm_conj norm_conj\n\n",
 "nonnegg_pos_neg":
 "theorem nonnegg_pos_neg {c d} {a b : ℕ} : nonnegg c d a (-b) ↔ sq_le b c a d := by\n  rw [nonnegg_comm] <;> exact nonnegg_neg_pos\n#align nonnegg_pos_neg nonnegg_pos_neg\n\n",
 "nonnegg_neg_pos":
 "theorem nonnegg_neg_pos {c d} : ∀ {a b : ℕ}, nonnegg c d (-a) b ↔ sq_le a d b c\n  | 0, b => ⟨by simp [sq_le, nat.zero_le], fun a => trivial⟩\n  | a + 1, b => by rw [← Int.negSucc_coe] <;> rfl\n#align nonnegg_neg_pos nonnegg_neg_pos\n\n",
 "nonnegg_comm":
 "theorem nonnegg_comm {c d : ℕ} {x y : ℤ} : nonnegg c d x y = nonnegg d c y x := by induction x <;> induction y <;> rfl\n#align nonnegg_comm nonnegg_comm\n\n",
 "nonnegg_cases_right":
 "theorem nonnegg_cases_right {c d} {a : ℕ} : ∀ {b : ℤ}, (∀ x : ℕ, b = -x → sq_le x c a d) → nonnegg c d a b\n  | (b : nat), h => trivial\n  | -[b+1], h => h (b + 1) rfl\n#align nonnegg_cases_right nonnegg_cases_right\n\n",
 "nonnegg_cases_left":
 "theorem nonnegg_cases_left {c d} {b : ℕ} {a : ℤ} (h : ∀ x : ℕ, a = -x → sq_le x d b c) : nonnegg c d a b :=\n  cast nonnegg_comm (nonnegg_cases_right h)\n#align nonnegg_cases_left nonnegg_cases_left\n\n",
 "nonneg_total":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ√ » -/\nprotected theorem nonneg_total : ∀ a : «exprℤ√ » d, nonneg a ∨ nonneg (-a)\n  | ⟨(x : ℕ), (y : ℕ)⟩ => or.inl trivial\n  | ⟨-[x+1], -[y+1]⟩ => or.inr trivial\n  | ⟨0, -[y+1]⟩ => or.inr trivial\n  | ⟨-[x+1], 0⟩ => or.inr trivial\n  | ⟨(x + 1 : ℕ), -[y+1]⟩ => nat.le_total\n  | ⟨-[x+1], (y + 1 : ℕ)⟩ => nat.le_total\n#align nonneg_total nonneg_total\n\n",
 "nonneg_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ√ » -/\ntheorem nonneg_smul {a : «exprℤ√ » d} {n : ℕ} (ha : nonneg a) : nonneg (n * a) := by\n  simp (config := { singlePass := true }) only [← Int.cast_ofNat] <;>\n    exact\n      match a, nonneg_cases ha, ha with\n      | _, ⟨x, y, or.inl rfl⟩, ha => by rw [smul_val] <;> trivial\n      | _, ⟨x, y, or.inr <| or.inl rfl⟩, ha => by\n        rw [smul_val] <;> simpa using nonnegg_pos_neg.2 (sq_le_smul n <| nonnegg_pos_neg.1 ha)\n      | _, ⟨x, y, or.inr <| or.inr rfl⟩, ha => by\n        rw [smul_val] <;> simpa using nonnegg_neg_pos.2 (sq_le_smul n <| nonnegg_neg_pos.1 ha)\n#align nonneg_smul nonneg_smul\n\n",
 "nonneg_muld":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ√ » -/\ntheorem nonneg_muld {a : «exprℤ√ » d} (ha : nonneg a) : nonneg (sqrtd * a) := by\n  refine'\n    match a, nonneg_cases ha, ha with\n    | _, ⟨x, y, or.inl rfl⟩, ha => trivial\n    | _, ⟨x, y, or.inr <| or.inl rfl⟩, ha => by\n      simp <;> apply nonnegg_neg_pos.2 <;>\n        simpa [sq_le, mul_comm, mul_left_comm] using nat.mul_le_mul_left d (nonnegg_pos_neg.1 ha)\n    | _, ⟨x, y, or.inr <| or.inr rfl⟩, ha => by\n      simp <;> apply nonnegg_pos_neg.2 <;>\n        simpa [sq_le, mul_comm, mul_left_comm] using nat.mul_le_mul_left d (nonnegg_neg_pos.1 ha)\n#align nonneg_muld nonneg_muld\n\n",
 "nonneg_mul_lem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ√ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ√ » -/\ntheorem nonneg_mul_lem {x y : ℕ} {a : «exprℤ√ » d} (ha : nonneg a) : nonneg (⟨x, y⟩ * a) :=\n  by\n  have : (⟨x, y⟩ * a : «exprℤ√ » d) = x * a + sqrtd * (y * a) := by rw [decompose, right_distrib, mul_assoc] <;> rfl\n  rw [this] <;> exact (nonneg_smul ha).add (nonneg_muld <| nonneg_smul ha)\n#align nonneg_mul_lem nonneg_mul_lem\n\n",
 "nonneg_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ√ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ√ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ√ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ√ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ√ » -/\ntheorem nonneg_mul {a b : «exprℤ√ » d} (ha : nonneg a) (hb : nonneg b) : nonneg (a * b) :=\n  match a, b, nonneg_cases ha, nonneg_cases hb, ha, hb with\n  | _, _, ⟨x, y, or.inl rfl⟩, ⟨z, w, or.inl rfl⟩, ha, hb => trivial\n  | _, _, ⟨x, y, or.inl rfl⟩, ⟨z, w, or.inr <| or.inr rfl⟩, ha, hb => nonneg_mul_lem hb\n  | _, _, ⟨x, y, or.inl rfl⟩, ⟨z, w, or.inr <| or.inl rfl⟩, ha, hb => nonneg_mul_lem hb\n  | _, _, ⟨x, y, or.inr <| or.inr rfl⟩, ⟨z, w, or.inl rfl⟩, ha, hb => by rw [mul_comm] <;> exact nonneg_mul_lem ha\n  | _, _, ⟨x, y, or.inr <| or.inl rfl⟩, ⟨z, w, or.inl rfl⟩, ha, hb => by rw [mul_comm] <;> exact nonneg_mul_lem ha\n  | _, _, ⟨x, y, or.inr <| or.inr rfl⟩, ⟨z, w, or.inr <| or.inr rfl⟩, ha, hb => by\n    rw [calc\n          (⟨-x, y⟩ * ⟨-z, w⟩ : «exprℤ√ » d) = ⟨_, _⟩ := rfl\n          _ = ⟨x * z + d * y * w, -(x * w + y * z)⟩ := by simp [add_comm]\n          ] <;>\n      exact nonnegg_pos_neg.2 (sq_le_mul.left (nonnegg_neg_pos.1 ha) (nonnegg_neg_pos.1 hb))\n  | _, _, ⟨x, y, or.inr <| or.inr rfl⟩, ⟨z, w, or.inr <| or.inl rfl⟩, ha, hb => by\n    rw [calc\n          (⟨-x, y⟩ * ⟨z, -w⟩ : «exprℤ√ » d) = ⟨_, _⟩ := rfl\n          _ = ⟨-(x * z + d * y * w), x * w + y * z⟩ := by simp [add_comm]\n          ] <;>\n      exact nonnegg_neg_pos.2 (sq_le_mul.right.left (nonnegg_neg_pos.1 ha) (nonnegg_pos_neg.1 hb))\n  | _, _, ⟨x, y, or.inr <| or.inl rfl⟩, ⟨z, w, or.inr <| or.inr rfl⟩, ha, hb => by\n    rw [calc\n          (⟨x, -y⟩ * ⟨-z, w⟩ : «exprℤ√ » d) = ⟨_, _⟩ := rfl\n          _ = ⟨-(x * z + d * y * w), x * w + y * z⟩ := by simp [add_comm]\n          ] <;>\n      exact nonnegg_neg_pos.2 (sq_le_mul.right.right.left (nonnegg_pos_neg.1 ha) (nonnegg_neg_pos.1 hb))\n  | _, _, ⟨x, y, or.inr <| or.inl rfl⟩, ⟨z, w, or.inr <| or.inl rfl⟩, ha, hb => by\n    rw [calc\n          (⟨x, -y⟩ * ⟨z, -w⟩ : «exprℤ√ » d) = ⟨_, _⟩ := rfl\n          _ = ⟨x * z + d * y * w, -(x * w + y * z)⟩ := by simp [add_comm]\n          ] <;>\n      exact nonnegg_pos_neg.2 (sq_le_mul.right.right.right (nonnegg_pos_neg.1 ha) (nonnegg_pos_neg.1 hb))\n#align nonneg_mul nonneg_mul\n\n",
 "nonneg_iff_zero_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ√ » -/\ntheorem nonneg_iff_zero_le {a : «exprℤ√ » d} : nonneg a ↔ 0 ≤ a :=\n  show _ ↔ nonneg _ by simp\n#align nonneg_iff_zero_le nonneg_iff_zero_le\n\n",
 "nonneg_cases":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ√ » -/\ntheorem nonneg_cases : ∀ {a : «exprℤ√ » d}, nonneg a → ∃ x y : ℕ, a = ⟨x, y⟩ ∨ a = ⟨x, -y⟩ ∨ a = ⟨-x, y⟩\n  | ⟨(x : ℕ), (y : ℕ)⟩, h => ⟨x, y, or.inl rfl⟩\n  | ⟨(x : ℕ), -[y+1]⟩, h => ⟨x, y + 1, or.inr <| or.inl rfl⟩\n  | ⟨-[x+1], (y : ℕ)⟩, h => ⟨x + 1, y, or.inr <| or.inr rfl⟩\n  | ⟨-[x+1], -[y+1]⟩, h => false.elim h\n#align nonneg_cases nonneg_cases\n\n",
 "nonneg_antisymm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ√ » -/\ntheorem nonneg_antisymm : ∀ {a : «exprℤ√ » d}, nonneg a → nonneg (-a) → a = 0\n  | ⟨0, 0⟩, xy, yx => rfl\n  | ⟨-[x+1], -[y+1]⟩, xy, yx => false.elim xy\n  | ⟨(x + 1 : nat), (y + 1 : nat)⟩, xy, yx => false.elim yx\n  | ⟨-[x+1], 0⟩, xy, yx => absurd xy (not_sq_le_succ _ _ _ (by decide))\n  | ⟨(x + 1 : nat), 0⟩, xy, yx => absurd yx (not_sq_le_succ _ _ _ (by decide))\n  | ⟨0, -[y+1]⟩, xy, yx => absurd xy (not_sq_le_succ _ _ _ d_pos)\n  | ⟨0, (y + 1 : nat)⟩, _, yx => absurd yx (not_sq_le_succ _ _ _ d_pos)\n  | ⟨(x + 1 : nat), -[y+1]⟩, (xy : sq_le _ _ _ _), (yx : sq_le _ _ _ _) =>\n    by\n    let t := le_antisymm yx xy\n    rw [one_mul] at t <;> exact absurd t (not_divides_sq _ _)\n  | ⟨-[x+1], (y + 1 : nat)⟩, (xy : sq_le _ _ _ _), (yx : sq_le _ _ _ _) =>\n    by\n    let t := le_antisymm xy yx\n    rw [one_mul] at t <;> exact absurd t (not_divides_sq _ _)\n#align nonneg_antisymm nonneg_antisymm\n\n",
 "nonneg_add_lem":
 "theorem nonneg_add_lem {x y z w : ℕ} (xy : nonneg ⟨x, -y⟩) (zw : nonneg ⟨-z, w⟩) : nonneg (⟨x, -y⟩ + ⟨-z, w⟩) :=\n  have : nonneg ⟨int.sub_nat_nat x z, int.sub_nat_nat w y⟩ :=\n    Int.subNatNat_elim x z (fun m n i => sq_le y d m 1 → sq_le n 1 w d → nonneg ⟨i, int.sub_nat_nat w y⟩)\n      (fun j k =>\n        Int.subNatNat_elim w y (fun m n i => sq_le n d (k + j) 1 → sq_le k 1 m d → nonneg ⟨int.of_nat j, i⟩)\n          (fun m n xy zw => trivial) fun m n xy zw => sq_le_cancel zw xy)\n      (fun j k =>\n        Int.subNatNat_elim w y (fun m n i => sq_le n d k 1 → sq_le (k + j + 1) 1 m d → nonneg ⟨-[j+1], i⟩)\n          (fun m n xy zw => sq_le_cancel xy zw) fun m n xy zw =>\n          let t := nat.le_trans zw (sq_le_of_le (nat.le_add_right n (m + 1)) le_rfl xy)\n          have : k + j + 1 ≤ k := Nat.mul_self_le_mul_self_iff.2 (by repeat' rw [one_mul] at t <;> exact t)\n          absurd this (not_le_of_gt <| nat.succ_le_succ <| nat.le_add_right _ _))\n      (nonnegg_pos_neg.1 xy) (nonnegg_neg_pos.1 zw)\n  show nonneg ⟨_, _⟩ by rw [neg_add_eq_sub] <;> rwa [Int.subNatNat_eq_coe, Int.subNatNat_eq_coe] at this\n#align nonneg_add_lem nonneg_add_lem\n\n",
 "neg_re":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ√ » -/\n@[simp]\ntheorem neg_re (z : «exprℤ√ » d) : (-z).re = -z.re :=\n  rfl\n#align neg_re neg_re\n\n",
 "neg_im":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ√ » -/\n@[simp]\ntheorem neg_im (z : «exprℤ√ » d) : (-z).im = -z.im :=\n  rfl\n#align neg_im neg_im\n\n",
 "muld_val":
 "@[simp]\ntheorem muld_val (x y : ℤ) : sqrtd * ⟨x, y⟩ = ⟨d * y, x⟩ := by simp [ext]\n#align muld_val muld_val\n\n",
 "mul_re":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ√ » -/\n@[simp]\ntheorem mul_re (z w : «exprℤ√ » d) : (z * w).re = z.re * w.re + d * z.im * w.im :=\n  rfl\n#align mul_re mul_re\n\n",
 "mul_pos":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ√ » -/\n#print mul_pos /-\nprotected theorem mul_pos (a b : «exprℤ√ » d) (a0 : 0 < a) (b0 : 0 < b) : 0 < a * b := fun ab =>\n  or.elim (eq_zero_or_eq_zero_of_mul_eq_zero (le_antisymm ab (mul_nonneg _ _ (le_of_lt a0) (le_of_lt b0))))\n    (fun e => ne_of_gt a0 e) fun e => ne_of_gt b0 e\n#align mul_pos mul_pos\n-/\n\n",
 "mul_nonneg":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ√ » -/\n#print mul_nonneg /-\nprotected theorem mul_nonneg (a b : «exprℤ√ » d) : 0 ≤ a → 0 ≤ b → 0 ≤ a * b := by\n  repeat' rw [← nonneg_iff_zero_le] <;> exact nonneg_mul\n#align mul_nonneg mul_nonneg\n-/\n\n",
 "mul_im":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ√ » -/\n@[simp]\ntheorem mul_im (z w : «exprℤ√ » d) : (z * w).im = z.re * w.im + z.im * w.re :=\n  rfl\n#align mul_im mul_im\n\n",
 "mul_conj":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ√ » -/\ntheorem mul_conj {x y : ℤ} : (⟨x, y⟩ * conj ⟨x, y⟩ : «exprℤ√ » d) = x * x - d * y * y := by\n  simp [ext, sub_eq_add_neg, mul_comm]\n#align mul_conj mul_conj\n\n",
 "lift_injective":
 "/-- `lift r` is injective if `d` is non-square, and R has characteristic zero (that is, the map from\n`ℤ` into `R` is injective). -/\ntheorem lift_injective [CharZero R] {d : ℤ} (r : { r : R // r * r = ↑d }) (hd : ∀ n : ℤ, d ≠ n * n) :\n    function.injective (lift r) :=\n  (injective_iff_map_eq_zero (lift r)).mpr fun a ha =>\n    by\n    have h_inj : function.injective (coe : ℤ → R) := Int.cast_injective\n    suffices lift r a.norm = 0\n      by\n      simp only [coe_int_re, add_zero, lift_apply_apply, coe_int_im, Int.cast_zero, zero_mul] at this\n      rwa [← Int.cast_zero, h_inj.eq_iff, norm_eq_zero hd] at this\n    rw [norm_eq_mul_conj, RingHom.map_mul, ha, zero_mul]\n#align lift_injective lift_injective\n\n",
 "le_total":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ√ » -/\n#print le_total /-\nprotected theorem le_total (a b : «exprℤ√ » d) : a ≤ b ∨ b ≤ a :=\n  by\n  have t := (b - a).nonneg_total\n  rwa [neg_sub] at t\n#align le_total le_total\n-/\n\n",
 "le_of_le_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ√ » -/\ntheorem le_of_le_le {x y z w : ℤ} (xz : x ≤ z) (yw : y ≤ w) : (⟨x, y⟩ : «exprℤ√ » d) ≤ ⟨z, w⟩ :=\n  show nonneg ⟨z - x, w - y⟩ from\n    match z - x, w - y, int.le.dest_sub xz, int.le.dest_sub yw with\n    | _, _, ⟨a, rfl⟩, ⟨b, rfl⟩ => trivial\n#align le_of_le_le le_of_le_le\n\n",
 "le_of_add_le_add_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ√ » -/\n#print le_of_add_le_add_left /-\nprotected theorem le_of_add_le_add_left (a b c : «exprℤ√ » d) (h : c + a ≤ c + b) : a ≤ b := by\n  simpa using zsqrtd.add_le_add_left _ _ h (-c)\n#align le_of_add_le_add_left le_of_add_le_add_left\n-/\n\n",
 "le_arch":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ√ » -/\ntheorem le_arch (a : «exprℤ√ » d) : ∃ n : ℕ, a ≤ n :=\n  by\n  let ⟨x, y, (h : a ≤ ⟨x, y⟩)⟩ :=\n    show ∃ x y : ℕ, nonneg (⟨x, y⟩ + -a) from\n      match -a with\n      | ⟨int.of_nat x, int.of_nat y⟩ => ⟨0, 0, trivial⟩\n      | ⟨int.of_nat x, -[y+1]⟩ => ⟨0, y + 1, by simp [Int.negSucc_coe, add_assoc]⟩\n      | ⟨-[x+1], int.of_nat y⟩ => ⟨x + 1, 0, by simp [Int.negSucc_coe, add_assoc]⟩\n      | ⟨-[x+1], -[y+1]⟩ => ⟨x + 1, y + 1, by simp [Int.negSucc_coe, add_assoc]⟩\n  refine' ⟨x + d * y, h.trans _⟩\n  change nonneg ⟨↑x + d * y - ↑x, 0 - ↑y⟩\n  cases' y with y\n  · simp\n  have h : ∀ y, sq_le y d (d * y) 1 := fun y => by\n    simpa [sq_le, mul_comm, mul_left_comm] using nat.mul_le_mul_right (y * y) (Nat.le_mul_self d)\n  rw [show (x : ℤ) + d * nat.succ y - x = d * nat.succ y by simp]\n  exact h (y + 1)\n#align le_arch le_arch\n\n",
 "le_antisymm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ√ » -/\n#print le_antisymm /-\ntheorem le_antisymm {a b : «exprℤ√ » d} (ab : a ≤ b) (ba : b ≤ a) : a = b :=\n  eq_of_sub_eq_zero <| nonneg_antisymm ba (by rw [neg_sub] <;> exact ab)\n#align le_antisymm le_antisymm\n-/\n\n",
 "is_unit_iff_norm_is_unit":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ√ » -/\ntheorem is_unit_iff_norm_is_unit {d : ℤ} (z : «exprℤ√ » d) : is_unit z ↔ is_unit z.norm := by\n  rw [Int.isUnit_iff_natAbs_eq, norm_eq_one_iff]\n#align is_unit_iff_norm_is_unit is_unit_iff_norm_is_unit\n\n",
 "hom_ext":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ√ » -/\n@[ext]\ntheorem hom_ext [Ring R] {d : ℤ} (f g : «expr →+* » («exprℤ√ » d) R) (h : f sqrtd = g sqrtd) : f = g :=\n  by\n  ext ⟨x_re, x_im⟩\n  simp [decompose, h]\n#align hom_ext hom_ext\n\n",
 "gcd_pos_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ√ » -/\ntheorem gcd_pos_iff (a : «exprℤ√ » d) : 0 < int.gcd a.re a.im ↔ a ≠ 0 :=\n  pos_iff_ne_zero.trans <| not_congr a.gcd_eq_zero_iff\n#align gcd_pos_iff gcd_pos_iff\n\n",
 "gcd_eq_zero_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ√ » -/\n#print gcd_eq_zero_iff /-\ntheorem gcd_eq_zero_iff (a : «exprℤ√ » d) : int.gcd a.re a.im = 0 ↔ a = 0 := by\n  simp only [Int.gcd_eq_zero_iff, ext, eq_self_iff_true, zero_im, zero_re]\n#align gcd_eq_zero_iff gcd_eq_zero_iff\n-/\n\n",
 "ext":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ√ » -/\n/-\nCopyright (c) 2017 Mario Carneiro. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Mario Carneiro\n-/\ntheorem ext : ∀ {z w : «exprℤ√ » d}, z = w ↔ z.re = w.re ∧ z.im = w.im\n  | ⟨x, y⟩, ⟨x', y'⟩ =>\n    ⟨fun h => by injection h <;> constructor <;> assumption, fun ⟨h₁, h₂⟩ => by congr <;> assumption⟩\n#align ext ext\n\n",
 "exists_coprime_of_gcd_pos":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ√ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ√ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ√ » -/\ntheorem exists_coprime_of_gcd_pos {a : «exprℤ√ » d} (hgcd : 0 < int.gcd a.re a.im) :\n    ∃ b : «exprℤ√ » d, a = ((int.gcd a.re a.im : ℤ) : «exprℤ√ » d) * b ∧ IsCoprime b.re b.im :=\n  by\n  obtain ⟨re, im, H1, Hre, Him⟩ := Int.exists_gcd_one hgcd\n  rw [mul_comm] at Hre Him\n  refine' ⟨⟨re, im⟩, _, _⟩\n  · rw [smul_val, ext, ← Hre, ← Him]\n    constructor <;> rfl\n  · rw [← int.gcd_eq_one_iff_coprime, H1]\n#align exists_coprime_of_gcd_pos exists_coprime_of_gcd_pos\n\n",
 "eq_zero_or_eq_zero_of_mul_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ√ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ√ » -/\nprotected theorem eq_zero_or_eq_zero_of_mul_eq_zero : ∀ {a b : «exprℤ√ » d}, a * b = 0 → a = 0 ∨ b = 0\n  | ⟨x, y⟩, ⟨z, w⟩, h => by\n    injection h with h1 h2 <;>\n      exact\n        have h1 : x * z = -(d * y * w) := eq_neg_of_add_eq_zero_left h1\n        have h2 : x * w = -(y * z) := eq_neg_of_add_eq_zero_left h2\n        have fin : x * x = d * y * y → (⟨x, y⟩ : «exprℤ√ » d) = 0 := fun e =>\n          match x, y, divides_sq_eq_zero_z e with\n          | _, _, ⟨rfl, rfl⟩ => rfl\n        if z0 : z = 0 then\n          if w0 : w = 0 then\n            or.inr\n              (match z, w, z0, w0 with\n              | _, _, rfl, rfl => rfl)\n          else\n            or.inl <|\n              fin <|\n                mul_right_cancel₀ w0 <|\n                  calc\n                    x * x * w = -y * (x * z) := by simp [h2, mul_assoc, mul_left_comm]\n                    _ = d * y * y * w := by simp [h1, mul_assoc, mul_left_comm]\n                    \n        else\n          or.inl <|\n            fin <|\n              mul_right_cancel₀ z0 <|\n                calc\n                  x * x * z = d * -y * (x * w) := by simp [h1, mul_assoc, mul_left_comm]\n                  _ = d * y * y * z := by simp [h2, mul_assoc, mul_left_comm]\n                  \n#align eq_zero_or_eq_zero_of_mul_eq_zero eq_zero_or_eq_zero_of_mul_eq_zero\n\n",
 "eq_of_smul_eq_smul_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ√ » -/\nprotected theorem eq_of_smul_eq_smul_left {a : ℤ} {b c : «exprℤ√ » d} (ha : a ≠ 0) (h : ↑a * b = a * c) : b = c :=\n  by\n  rw [ext] at h⊢\n  apply and.imp _ _ h <;> · simpa only [smul_re, smul_im] using mul_left_cancel₀ ha\n#align eq_of_smul_eq_smul_left eq_of_smul_eq_smul_left\n\n",
 "dmuld":
 "@[simp]\ntheorem dmuld : sqrtd * sqrtd = d := by simp [ext]\n#align dmuld dmuld\n\n",
 "divides_sq_eq_zero_z":
 "theorem divides_sq_eq_zero_z {x y : ℤ} (h : x * x = d * y * y) : x = 0 ∧ y = 0 := by\n  rw [mul_assoc, ← Int.natAbs_mul_self, ← Int.natAbs_mul_self, ← Int.ofNat_mul, ← mul_assoc] at h <;>\n    exact\n      let ⟨h1, h2⟩ := divides_sq_eq_zero (Int.ofNat.inj h)\n      ⟨Int.eq_zero_of_natAbs_eq_zero h1, Int.eq_zero_of_natAbs_eq_zero h2⟩\n#align divides_sq_eq_zero_z divides_sq_eq_zero_z\n\n",
 "divides_sq_eq_zero":
 "theorem divides_sq_eq_zero {x y} (h : x * x = d * y * y) : x = 0 ∧ y = 0 :=\n  let g := x.gcd y\n  or.elim g.eq_zero_or_pos (fun H => ⟨nat.eq_zero_of_gcd_eq_zero_left H, nat.eq_zero_of_gcd_eq_zero_right H⟩)\n    fun gpos =>\n    false.elim <| by\n      let ⟨m, n, co, (hx : x = m * g), (hy : y = n * g)⟩ := nat.exists_coprime gpos\n      rw [hx, hy] at h\n      have : m * m = d * (n * n) :=\n        mul_left_cancel₀ (mul_pos gpos gpos).ne' (by simpa [mul_comm, mul_left_comm] using h)\n      have co2 :=\n        let co1 := co.mul_right co\n        co1.mul co1\n      exact\n        nonsquare.ns d m\n          (nat.dvd_antisymm (by rw [this] <;> apply dvd_mul_right) <| co2.dvd_of_dvd_mul_right <| by simp [this])\n#align divides_sq_eq_zero divides_sq_eq_zero\n\n",
 "decompose":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ√ » -/\ntheorem decompose {x y : ℤ} : (⟨x, y⟩ : «exprℤ√ » d) = x + sqrtd * y := by simp [ext]\n#align decompose decompose\n\n",
 "d_pos":
 "theorem d_pos : 0 < d :=\n  lt_of_le_of_ne (nat.zero_le _) <| ne.symm <| nonsquare.ns d 0\n#align d_pos d_pos\n\n",
 "coprime_of_dvd_coprime":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ√ » -/\ntheorem coprime_of_dvd_coprime {a b : «exprℤ√ » d} (hcoprime : IsCoprime a.re a.im) (hdvd : b ∣ a) :\n    IsCoprime b.re b.im := by\n  apply is_coprime_of_dvd\n  · rintro ⟨hre, him⟩\n    obtain rfl : b = 0 := by simp only [ext, hre, eq_self_iff_true, zero_im, him, and_self_iff, zero_re]\n    rw [zero_dvd_iff] at hdvd\n    simpa only [hdvd, zero_im, zero_re, not_isCoprime_zero_zero] using hcoprime\n  · intro z hz hznezero hzdvdu hzdvdv\n    apply hz\n    obtain ⟨ha, hb⟩ : z ∣ a.re ∧ z ∣ a.im := by\n      rw [← coe_int_dvd_iff]\n      apply dvd_trans _ hdvd\n      rw [coe_int_dvd_iff]\n      exact ⟨hzdvdu, hzdvdv⟩\n    exact hcoprime.is_unit_of_dvd' ha hb\n#align coprime_of_dvd_coprime coprime_of_dvd_coprime\n\n",
 "conj_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ√ » -/\n@[simp]\ntheorem conj_zero : conj (0 : «exprℤ√ » d) = 0 :=\n  conj_hom.map_zero\n#align conj_zero conj_zero\n\n",
 "conj_sub":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ√ » -/\n@[simp]\ntheorem conj_sub (x y : «exprℤ√ » d) : (x - y).conj = x.conj - y.conj :=\n  conj_hom.map_sub x y\n#align conj_sub conj_sub\n\n",
 "conj_re":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ√ » -/\n@[simp]\ntheorem conj_re (z : «exprℤ√ » d) : (conj z).re = z.re :=\n  rfl\n#align conj_re conj_re\n\n",
 "conj_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ√ » -/\n@[simp]\ntheorem conj_one : conj (1 : «exprℤ√ » d) = 1 := by\n  simp only [zsqrtd.ext, zsqrtd.conj_re, zsqrtd.conj_im, zsqrtd.one_im, neg_zero, eq_self_iff_true, and_self_iff]\n#align conj_one conj_one\n\n",
 "conj_neg":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ√ » -/\n@[simp]\ntheorem conj_neg (x : «exprℤ√ » d) : (-x).conj = -x.conj :=\n  rfl\n#align conj_neg conj_neg\n\n",
 "conj_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ√ » -/\n#print conj_mul /-\ntheorem conj_mul {a b : «exprℤ√ » d} : conj (a * b) = conj a * conj b :=\n  by\n  simp [ext]\n  ring\n#align conj_mul conj_mul\n-/\n\n",
 "conj_im":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ√ » -/\n@[simp]\ntheorem conj_im (z : «exprℤ√ » d) : (conj z).im = -z.im :=\n  rfl\n#align conj_im conj_im\n\n",
 "conj_conj":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ√ » -/\n@[simp]\ntheorem conj_conj {d : ℤ} (x : «exprℤ√ » d) : x.conj.conj = x := by\n  simp only [ext, true_and_iff, conj_re, eq_self_iff_true, neg_neg, conj_im]\n#align conj_conj conj_conj\n\n",
 "conj_add":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ√ » -/\n@[simp]\ntheorem conj_add (x y : «exprℤ√ » d) : (x + y).conj = x.conj + y.conj :=\n  conj_hom.map_add x y\n#align conj_add conj_add\n\n",
 "coe_nat_val":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ√ » -/\ntheorem coe_nat_val (n : ℕ) : (n : «exprℤ√ » d) = ⟨n, 0⟩ :=\n  rfl\n#align coe_nat_val coe_nat_val\n\n",
 "coe_nat_re":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ√ » -/\n@[simp]\ntheorem coe_nat_re (n : ℕ) : (n : «exprℤ√ » d).re = n :=\n  rfl\n#align coe_nat_re coe_nat_re\n\n",
 "coe_nat_im":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ√ » -/\n@[simp]\ntheorem coe_nat_im (n : ℕ) : (n : «exprℤ√ » d).im = 0 :=\n  rfl\n#align coe_nat_im coe_nat_im\n\n",
 "coe_int_val":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ√ » -/\ntheorem coe_int_val (n : ℤ) : (n : «exprℤ√ » d) = ⟨n, 0⟩ := by simp [ext]\n#align coe_int_val coe_int_val\n\n",
 "coe_int_sub":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ√ » -/\nprotected theorem coe_int_sub (m n : ℤ) : (↑(m - n) : «exprℤ√ » d) = ↑m - ↑n :=\n  (Int.castRingHom _).map_sub _ _\n#align coe_int_sub coe_int_sub\n\n",
 "coe_int_re":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ√ » -/\n@[simp]\ntheorem coe_int_re (n : ℤ) : (n : «exprℤ√ » d).re = n := by cases n <;> rfl\n#align coe_int_re coe_int_re\n\n",
 "coe_int_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ√ » -/\nprotected theorem coe_int_mul (m n : ℤ) : (↑(m * n) : «exprℤ√ » d) = ↑m * ↑n :=\n  (Int.castRingHom _).map_mul _ _\n#align coe_int_mul coe_int_mul\n\n",
 "coe_int_inj":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ√ » -/\nprotected theorem coe_int_inj {m n : ℤ} (h : (↑m : «exprℤ√ » d) = ↑n) : m = n := by simpa using congr_arg re h\n#align coe_int_inj coe_int_inj\n\n",
 "coe_int_im":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ√ » -/\n@[simp]\ntheorem coe_int_im (n : ℤ) : (n : «exprℤ√ » d).im = 0 := by cases n <;> rfl\n#align coe_int_im coe_int_im\n\n",
 "coe_int_dvd_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ√ » -/\ntheorem coe_int_dvd_iff (z : ℤ) (a : «exprℤ√ » d) : ↑z ∣ a ↔ z ∣ a.re ∧ z ∣ a.im :=\n  by\n  constructor\n  · rintro ⟨x, rfl⟩\n    simp only [add_zero, coe_int_re, zero_mul, mul_im, dvd_mul_right, and_self_iff, mul_re, mul_zero, coe_int_im]\n  · rintro ⟨⟨r, hr⟩, ⟨i, hi⟩⟩\n    use ⟨r, i⟩\n    rw [smul_val, ext]\n    exact ⟨hr, hi⟩\n#align coe_int_dvd_iff coe_int_dvd_iff\n\n",
 "coe_int_dvd_coe_int":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ√ » -/\n@[simp, norm_cast]\ntheorem coe_int_dvd_coe_int (a b : ℤ) : (a : «exprℤ√ » d) ∣ b ↔ a ∣ b :=\n  by\n  rw [coe_int_dvd_iff]\n  constructor\n  · rintro ⟨hre, -⟩\n    rwa [coe_int_re] at hre\n  · rw [coe_int_re, coe_int_im]\n    exact fun hc => ⟨hc, dvd_zero a⟩\n#align coe_int_dvd_coe_int coe_int_dvd_coe_int\n\n",
 "coe_int_add":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ√ » -/\nprotected theorem coe_int_add (m n : ℤ) : (↑(m + n) : «exprℤ√ » d) = ↑m + ↑n :=\n  (Int.castRingHom _).map_add _ _\n#align coe_int_add coe_int_add\n\n",
 "bit1_re":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ√ » -/\n@[simp]\ntheorem bit1_re (z) : (bit1 z : «exprℤ√ » d).re = bit1 z.re :=\n  rfl\n#align bit1_re bit1_re\n\n",
 "bit1_im":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ√ » -/\n@[simp]\ntheorem bit1_im (z) : (bit1 z : «exprℤ√ » d).im = bit0 z.im := by simp [bit1]\n#align bit1_im bit1_im\n\n",
 "bit0_re":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ√ » -/\n@[simp]\ntheorem bit0_re (z) : (bit0 z : «exprℤ√ » d).re = bit0 z.re :=\n  rfl\n#align bit0_re bit0_re\n\n",
 "bit0_im":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ√ » -/\n@[simp]\ntheorem bit0_im (z) : (bit0 z : «exprℤ√ » d).im = bit0 z.im :=\n  rfl\n#align bit0_im bit0_im\n\n",
 "add_re":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ√ » -/\n@[simp]\ntheorem add_re (z w : «exprℤ√ » d) : (z + w).re = z.re + w.re :=\n  rfl\n#align add_re add_re\n\n",
 "add_lt_add_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ√ » -/\n#print add_lt_add_left /-\nprotected theorem add_lt_add_left (a b : «exprℤ√ » d) (h : a < b) (c) : c + a < c + b := fun h' =>\n  h (zsqrtd.le_of_add_le_add_left _ _ _ h')\n#align add_lt_add_left add_lt_add_left\n-/\n\n",
 "add_le_add_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ√ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ√ » -/\n#print add_le_add_left /-\nprotected theorem add_le_add_left (a b : «exprℤ√ » d) (ab : a ≤ b) (c : «exprℤ√ » d) : c + a ≤ c + b :=\n  show nonneg _ by rw [add_sub_add_left_eq_sub] <;> exact ab\n#align add_le_add_left add_le_add_left\n-/\n\n",
 "add_im":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ√ » -/\n@[simp]\ntheorem add_im (z w : «exprℤ√ » d) : (z + w).im = z.im + w.im :=\n  rfl\n#align add_im add_im\n\n",
 "add_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ√ » -/\n@[simp]\ntheorem add_def (x y x' y' : ℤ) : (⟨x, y⟩ + ⟨x', y'⟩ : «exprℤ√ » d) = ⟨x + x', y + y'⟩ :=\n  rfl\n#align add_def add_def\n\n",
 "add":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ√ » -/\ntheorem nonneg.add {a b : «exprℤ√ » d} (ha : nonneg a) (hb : nonneg b) : nonneg (a + b) :=\n  by\n  rcases nonneg_cases ha with ⟨x, y, rfl | rfl | rfl⟩ <;> rcases nonneg_cases hb with ⟨z, w, rfl | rfl | rfl⟩\n  · trivial\n  · refine' nonnegg_cases_right fun i h => sq_le_of_le _ _ (nonnegg_pos_neg.1 hb)\n    · exact Int.ofNat_le.1 (le_of_neg_le_neg (@int.le.intro _ _ y (by simp [add_comm, *])))\n    · apply nat.le_add_left\n  · refine' nonnegg_cases_left fun i h => sq_le_of_le _ _ (nonnegg_neg_pos.1 hb)\n    · exact Int.ofNat_le.1 (le_of_neg_le_neg (@int.le.intro _ _ x (by simp [add_comm, *])))\n    · apply nat.le_add_left\n  · refine' nonnegg_cases_right fun i h => sq_le_of_le _ _ (nonnegg_pos_neg.1 ha)\n    · exact Int.ofNat_le.1 (le_of_neg_le_neg (@int.le.intro _ _ w (by simp [*])))\n    · apply nat.le_add_right\n  · simpa [add_comm] using nonnegg_pos_neg.2 (sq_le_add (nonnegg_pos_neg.1 ha) (nonnegg_pos_neg.1 hb))\n  · exact nonneg_add_lem ha hb\n  · refine' nonnegg_cases_left fun i h => sq_le_of_le _ _ (nonnegg_neg_pos.1 ha)\n    · exact Int.ofNat_le.1 (le_of_neg_le_neg (int.le.intro h))\n    · apply nat.le_add_right\n  · dsimp\n    rw [add_comm, add_comm ↑y]\n    exact nonneg_add_lem hb ha\n  · simpa [add_comm] using nonnegg_neg_pos.2 (sq_le_add (nonnegg_neg_pos.1 ha) (nonnegg_neg_pos.1 hb))\n#align nonneg.add nonneg.add\n\n"}