{"two_pow_two_pow_sub_pow_two_pow":
 "theorem int.two_pow_two_pow_sub_pow_two_pow {x y : ℤ} (n : ℕ) (hxy : 4 ∣ x - y) (hx : ¬2 ∣ x) :\n    multiplicity 2 (x ^ 2 ^ n - y ^ 2 ^ n) = multiplicity 2 (x - y) + n := by\n  simp only [pow_two_pow_sub_pow_two_pow n, multiplicity.mul Int.prime_two, multiplicity.Finset.prod Int.prime_two,\n    add_comm, Nat.cast_one, Finset.sum_const, Finset.card_range, nsmul_one,\n    int.two_pow_two_pow_add_two_pow_two_pow hx hxy]\n#align int.two_pow_two_pow_sub_pow_two_pow int.two_pow_two_pow_sub_pow_two_pow\n\n",
 "two_pow_two_pow_add_two_pow_two_pow":
 "theorem int.two_pow_two_pow_add_two_pow_two_pow {x y : ℤ} (hx : ¬2 ∣ x) (hxy : 4 ∣ x - y) (i : ℕ) :\n    multiplicity 2 (x ^ 2 ^ i + y ^ 2 ^ i) = ↑(1 : ℕ) :=\n  by\n  have hx_odd : Odd x := by rwa [Int.odd_iff_not_even, even_iff_two_dvd]\n  have hxy_even : Even (x - y) := even_iff_two_dvd.mpr (dvd_trans (by norm_num) hxy)\n  have hy_odd : Odd y := by simpa using hx_odd.sub_even hxy_even\n  refine' multiplicity.eq_coe_iff.mpr ⟨_, _⟩\n  · rw [pow_one, ← even_iff_two_dvd]\n    exact hx_odd.pow.add_odd hy_odd.pow\n  cases' i with i\n  · intro hxy'\n    have : 2 * 2 ∣ 2 * x := by\n      convert dvd_add hxy hxy'\n      ring\n    have : 2 ∣ x := (mul_dvd_mul_iff_left (by norm_num)).mp this\n    contradiction\n  suffices ∀ x : ℤ, Odd x → x ^ 2 ^ (i + 1) % 4 = 1\n    by\n    rw [show (2 ^ (1 + 1) : ℤ) = 4 by norm_num, Int.dvd_iff_emod_eq_zero, Int.add_emod, this _ hx_odd, this _ hy_odd]\n    norm_num\n  intro x hx\n  rw [pow_succ, mul_comm, pow_mul, int.sq_mod_four_eq_one_of_odd hx.pow]\n#align int.two_pow_two_pow_add_two_pow_two_pow int.two_pow_two_pow_add_two_pow_two_pow\n\n",
 "two_pow_sub_pow'":
 "theorem int.two_pow_sub_pow' {x y : ℤ} (n : ℕ) (hxy : 4 ∣ x - y) (hx : ¬2 ∣ x) :\n    multiplicity 2 (x ^ n - y ^ n) = multiplicity 2 (x - y) + multiplicity (2 : ℤ) n :=\n  by\n  have hx_odd : Odd x := by rwa [Int.odd_iff_not_even, even_iff_two_dvd]\n  have hxy_even : Even (x - y) := even_iff_two_dvd.mpr (dvd_trans (by norm_num) hxy)\n  have hy_odd : Odd y := by simpa using hx_odd.sub_even hxy_even\n  cases n\n  · simp only [pow_zero, sub_self, multiplicity.zero, Int.ofNat_zero, PartENat.add_top]\n  have h : (multiplicity 2 n.succ).dom := multiplicity.finite_nat_iff.mpr ⟨by norm_num, n.succ_pos⟩\n  rcases multiplicity.eq_coe_iff.mp (PartENat.natCast_get h).symm with ⟨⟨k, hk⟩, hpn⟩\n  rw [hk, pow_mul, pow_mul, multiplicity.pow_sub_pow_of_prime, int.two_pow_two_pow_sub_pow_two_pow _ hxy hx, ← hk,\n    PartENat.natCast_get]\n  · norm_cast\n  · exact Int.prime_two\n  · simpa only [even_iff_two_dvd] using hx_odd.pow.sub_odd hy_odd.pow\n  · simpa only [even_iff_two_dvd, Int.odd_iff_not_even] using hx_odd.pow\n  erw [Int.coe_nat_dvd]\n  -- `erw` to deal with `2 : ℤ` vs `(2 : ℕ) : ℤ`\n  contrapose! hpn\n  rw [pow_succ']\n  conv_rhs => rw [hk]\n  exact mul_dvd_mul_left _ hpn\n#align int.two_pow_sub_pow' int.two_pow_sub_pow'\n\n",
 "two_pow_sub_pow":
 "theorem nat.two_pow_sub_pow {x y : ℕ} (hxy : 2 ∣ x - y) (hx : ¬2 ∣ x) {n : ℕ} (hn : Even n) :\n    multiplicity 2 (x ^ n - y ^ n) + 1 = multiplicity 2 (x + y) + multiplicity 2 (x - y) + multiplicity 2 n :=\n  by\n  obtain hyx | hyx := le_total y x\n  · iterate 3 rw [← multiplicity.Int.coe_nat_multiplicity]\n    have hxyn : y ^ n ≤ x ^ n := pow_le_pow_of_le_left' hyx _\n    simp only [Int.ofNat_sub hyx, Int.ofNat_sub (pow_le_pow_of_le_left' hyx _), Int.ofNat_add, Int.coe_nat_pow]\n    rw [← Int.coe_nat_dvd] at hx\n    rw [← Int.coe_nat_dvd, Int.ofNat_sub hyx] at hxy\n    convert int.two_pow_sub_pow hxy hx hn using 2\n    rw [← multiplicity.Int.coe_nat_multiplicity]\n    rfl\n  ·\n    simp only [nat.sub_eq_zero_iff_le.mpr hyx, nat.sub_eq_zero_iff_le.mpr (pow_le_pow_of_le_left' hyx n),\n      multiplicity.zero, PartENat.top_add, PartENat.add_top]\n#align nat.two_pow_sub_pow nat.two_pow_sub_pow\n\n",
 "sq_mod_four_eq_one_of_odd":
 "/- ./././Mathport/Syntax/Translate/Tactic/Mathlib/Misc2.lean:80:4: warning: unsupported fin_cases 'using hy' clause -/\ntheorem _root_.int.sq_mod_four_eq_one_of_odd {x : ℤ} : Odd x → x ^ 2 % 4 = 1 :=\n  by\n  intro hx\n  -- Replace `x : ℤ` with `y : zmod 4`\n  replace hx : x % (2 : ℕ) = 1 % (2 : ℕ);\n  · rw [Int.odd_iff] at hx\n    norm_num [hx]\n  calc\n    x ^ 2 % (4 : ℕ) = 1 % (4 : ℕ) := _\n    _ = 1 := by norm_num\n    \n  rw [← ZMod.int_cast_eq_int_cast_iff'] at hx⊢\n  push_cast\n  rw [← map_intCast (ZMod.castHom (show 2 ∣ 4 by norm_num) (ZMod 2)) x] at hx\n  set y : ZMod 4 := x\n  change ZMod.castHom _ (ZMod 2) y = _ at hx\n  -- Now we can just consider each of the 4 possible values for y\n        fin_cases y <;>\n        rw [hy] at hx⊢ <;>\n      revert hx <;>\n    decide\n#align int.sq_mod_four_eq_one_of_odd int.sq_mod_four_eq_one_of_odd\n\n",
 "sq_dvd_add_pow_sub_sub":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem sq_dvd_add_pow_sub_sub (p x : R) (n : ℕ) : p ^ 2 ∣ (x + p) ^ n - x ^ (n - 1) * p * n - x ^ n :=\n  by\n  cases n\n  · simp only [pow_zero, Nat.cast_zero, MulZeroClass.mul_zero, sub_zero, sub_self, dvd_zero]\n  · simp only [nat.succ_sub_succ_eq_sub, tsub_zero, Nat.cast_succ, add_pow, Finset.sum_range_succ, Nat.choose_self,\n      nat.succ_sub _, tsub_self, pow_one, Nat.choose_succ_self_right, pow_zero, mul_one, Nat.cast_zero, zero_add,\n      nat.succ_eq_add_one]\n    suffices\n      p ^ 2 ∣\n        finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (range n)\n          (x ^ i * p ^ (n + 1 - i) * ↑((n + 1).choose i))\n      by convert this <;> abel\n    · apply Finset.dvd_sum\n      intro y hy\n      calc\n        p ^ 2 ∣ p ^ (n + 1 - y) := pow_dvd_pow p (le_tsub_of_add_le_left (by linarith [finset.mem_range.mp hy]))\n        _ ∣ x ^ y * p ^ (n + 1 - y) * ↑((n + 1).choose y) := dvd_mul_of_dvd_left (dvd_mul_left _ _) ((n + 1).choose y)\n        \n#align sq_dvd_add_pow_sub_sub sq_dvd_add_pow_sub_sub\n\n",
 "pow_two_sub_pow":
 "theorem pow_two_sub_pow (hyx : y < x) (hxy : 2 ∣ x - y) (hx : ¬2 ∣ x) {n : ℕ} (hn : 0 < n) (hneven : Even n) :\n    padicValNat 2 (x ^ n - y ^ n) + 1 = padicValNat 2 (x + y) + padicValNat 2 (x - y) + padicValNat 2 n :=\n  by\n  simp only [← PartENat.natCast_inj, Nat.cast_add]\n  iterate 4 rw [padicValNat_def, PartENat.natCast_get]\n  · convert nat.two_pow_sub_pow hxy hx hneven using 2\n  · exact hn\n  · exact nat.sub_pos_of_lt hyx\n  · linarith\n  · simp only [tsub_pos_iff_lt, pow_lt_pow_of_lt_left hyx (@zero_le' _ y _) hn]\n#align pow_two_sub_pow pow_two_sub_pow\n\n",
 "pow_two_pow_sub_pow_two_pow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\ntheorem pow_two_pow_sub_pow_two_pow [CommRing R] {x y : R} (n : ℕ) :\n    x ^ 2 ^ n - y ^ 2 ^ n =\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" (Finset.range n)\n          (x ^ 2 ^ i + y ^ 2 ^ i) *\n        (x - y) :=\n  by\n  induction' n with d hd\n  · simp only [pow_zero, pow_one, Finset.range_zero, Finset.prod_empty, one_mul]\n  · suffices x ^ 2 ^ d.succ - y ^ 2 ^ d.succ = (x ^ 2 ^ d + y ^ 2 ^ d) * (x ^ 2 ^ d - y ^ 2 ^ d) by\n      rw [this, hd, Finset.prod_range_succ, ← mul_assoc, mul_comm (x ^ 2 ^ d + y ^ 2 ^ d)]\n    · ring1\n#align pow_two_pow_sub_pow_two_pow pow_two_pow_sub_pow_two_pow\n\n",
 "pow_sub_pow_of_prime":
 "theorem pow_sub_pow_of_prime {p : R} (hp : Prime p) {x y : R} (hxy : p ∣ x - y) (hx : ¬p ∣ x) {n : ℕ} (hn : ¬p ∣ n) :\n    multiplicity p (x ^ n - y ^ n) = multiplicity p (x - y) := by\n  rw [← geom_sum₂_mul, multiplicity.mul hp, multiplicity_eq_zero.2 (not_dvd_geom_sum₂ hp hxy hx hn), zero_add]\n#align pow_sub_pow_of_prime pow_sub_pow_of_prime\n\n",
 "pow_sub_pow":
 "theorem pow_sub_pow (hyx : y < x) (hxy : p ∣ x - y) (hx : ¬p ∣ x) {n : ℕ} (hn : 0 < n) :\n    padicValNat p (x ^ n - y ^ n) = padicValNat p (x - y) + padicValNat p n :=\n  by\n  rw [← PartENat.natCast_inj, Nat.cast_add]\n  iterate 3 rw [padicValNat_def, PartENat.natCast_get]\n  · exact multiplicity.nat.pow_sub_pow hp.out hp1 hxy hx n\n  · exact hn\n  · exact nat.sub_pos_of_lt hyx\n  · exact nat.sub_pos_of_lt (Nat.pow_lt_pow_of_lt_left hyx hn)\n#align pow_sub_pow pow_sub_pow\n\n",
 "pow_prime_sub_pow_prime":
 "theorem pow_prime_sub_pow_prime : multiplicity (↑p) (x ^ p - y ^ p) = multiplicity (↑p) (x - y) + 1 := by\n  rw [← geom_sum₂_mul, multiplicity.mul hp, geom_sum₂_eq_one hp hp1 hxy hx, add_comm]\n#align pow_prime_sub_pow_prime pow_prime_sub_pow_prime\n\n",
 "pow_prime_pow_sub_pow_prime_pow":
 "theorem pow_prime_pow_sub_pow_prime_pow (a : ℕ) :\n    multiplicity (↑p) (x ^ p ^ a - y ^ p ^ a) = multiplicity (↑p) (x - y) + a :=\n  by\n  induction' a with a h_ind\n  · rw [Nat.cast_zero, add_zero, pow_zero, pow_one, pow_one]\n  rw [← nat.add_one, Nat.cast_add, Nat.cast_one, ← add_assoc, ← h_ind, pow_succ', pow_mul, pow_mul]\n  apply pow_prime_sub_pow_prime hp hp1\n  · rw [← geom_sum₂_mul]\n    exact dvd_mul_of_dvd_right hxy _\n  · exact fun h => hx (hp.dvd_of_dvd_pow h)\n#align pow_prime_pow_sub_pow_prime_pow pow_prime_pow_sub_pow_prime_pow\n\n",
 "pow_add_pow":
 "theorem pow_add_pow (hxy : p ∣ x + y) (hx : ¬p ∣ x) {n : ℕ} (hn : Odd n) :\n    padicValNat p (x ^ n + y ^ n) = padicValNat p (x + y) + padicValNat p n :=\n  by\n  cases y\n  · have := dvd_zero p\n    contradiction\n  rw [← PartENat.natCast_inj, Nat.cast_add]\n  iterate 3 rw [padicValNat_def, PartENat.natCast_get]\n  · exact multiplicity.nat.pow_add_pow hp.out hp1 hxy hx hn\n  · exact Odd.pos hn\n  · simp only [add_pos_iff, Nat.succ_pos', or_true_iff]\n  · exact Nat.lt_add_left _ _ _ (pow_pos y.succ_pos _)\n#align pow_add_pow pow_add_pow\n\n",
 "odd_sq_dvd_geom_sum₂_sub":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem odd_sq_dvd_geom_sum₂_sub (hp : Odd p) :\n    ↑p ^ 2 ∣\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (range p)\n          ((a + p * b) ^ i * a ^ (p - 1 - i)) -\n        p * a ^ (p - 1) :=\n  by\n  have h1 : ∀ i, ↑p ^ 2 ∣ (a + ↑p * b) ^ i - (a ^ (i - 1) * (↑p * b) * ↑i + a ^ i) :=\n    by\n    intro i\n    calc\n      ↑p ^ 2 ∣ (↑p * b) ^ 2 := by simp only [mul_pow, dvd_mul_right]\n      _ ∣ (a + ↑p * b) ^ i - (a ^ (i - 1) * (↑p * b) * ↑i + a ^ i) := by\n        simp only [sq_dvd_add_pow_sub_sub (↑p * b) a i, ← sub_sub]\n      \n  simp_rw [← mem_span_singleton, ← Ideal.Quotient.eq] at *\n  calc\n    Ideal.Quotient.mk (span {↑p ^ 2})\n          (finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (range p)\n            ((a + ↑p * b) ^ i * a ^ (p - 1 - i))) =\n        finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (Finset.range p)\n          (mk (span {↑p ^ 2}) ((a ^ (i - 1) * (↑p * b) * ↑i + a ^ i) * a ^ (p - 1 - i))) :=\n      by simp_rw [RingHom.map_geom_sum₂, ← map_pow, h1, ← _root_.map_mul]\n    _ =\n        mk (span {↑p ^ 2})\n            (finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n              (Finset.range p) (a ^ (x - 1) * (a ^ (p - 1 - x) * (↑p * (b * ↑x))))) +\n          mk (span {↑p ^ 2})\n            (finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n              (Finset.range p) (a ^ (x + (p - 1 - x)))) :=\n      by\n      ring\n      simp only [← pow_add, map_add, Finset.sum_add_distrib, ← map_sum]\n    _ =\n        mk (span {↑p ^ 2})\n            (finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n              (Finset.range p) (a ^ (x - 1) * (a ^ (p - 1 - x) * (↑p * (b * ↑x))))) +\n          mk (span {↑p ^ 2})\n            (finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n              (Finset.range p) (a ^ (p - 1))) :=\n      by\n      rw [add_right_inj, Finset.sum_congr rfl]\n      intro x hx\n      rw [← nat.add_sub_assoc _ x, nat.add_sub_cancel_left]\n      exact Nat.le_pred_of_lt (finset.mem_range.mp hx)\n    _ =\n        mk (span {↑p ^ 2})\n            (finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n              (Finset.range p) (a ^ (x - 1) * (a ^ (p - 1 - x) * (↑p * (b * ↑x))))) +\n          mk (span {↑p ^ 2}) (↑p * a ^ (p - 1)) :=\n      by simp only [add_right_inj, Finset.sum_const, Finset.card_range, nsmul_eq_mul]\n    _ =\n        mk (span {↑p ^ 2})\n            (↑p * b *\n              finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n                (Finset.range p) (a ^ (p - 2) * x)) +\n          mk (span {↑p ^ 2}) (↑p * a ^ (p - 1)) :=\n      by\n      simp only [Finset.mul_sum, ← mul_assoc, ← pow_add]\n      rw [Finset.sum_congr rfl]\n      rintro (⟨⟩ | ⟨x⟩) hx\n      · rw [Nat.cast_zero, MulZeroClass.mul_zero, MulZeroClass.mul_zero]\n      · have : x.succ - 1 + (p - 1 - x.succ) = p - 2 :=\n          by\n          rw [← nat.add_sub_assoc (Nat.le_pred_of_lt (finset.mem_range.mp hx))]\n          exact congr_arg nat.pred (nat.add_sub_cancel_left _ _)\n        rw [this]\n        ring1\n    _ = mk (span {↑p ^ 2}) (↑p * a ^ (p - 1)) :=\n      by\n      simp only [add_left_eq_self, ← Finset.mul_sum]\n      norm_cast\n      simp only [Finset.sum_range_id, Nat.cast_mul, _root_.map_mul,\n        Nat.mul_div_assoc _ (even_iff_two_dvd.mp (Nat.Odd.sub_odd hp odd_one))]\n      ring\n      simp only [← map_pow, mul_eq_zero_of_left, Ideal.Quotient.eq_zero_iff_mem, mem_span_singleton]\n    \n#align odd_sq_dvd_geom_sum₂_sub odd_sq_dvd_geom_sum₂_sub\n\n",
 "not_dvd_geom_sum₂":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem not_dvd_geom_sum₂ {p : R} (hp : Prime p) (hxy : p ∣ x - y) (hx : ¬p ∣ x) (hn : ¬p ∣ n) :\n    ¬p ∣\n        finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (range n)\n          (x ^ i * y ^ (n - 1 - i)) :=\n  fun h => hx <| hp.dvd_of_dvd_pow <| (hp.dvd_or_dvd <| (dvd_geom_sum₂_iff_of_dvd_sub' hxy).mp h).resolve_left hn\n#align not_dvd_geom_sum₂ not_dvd_geom_sum₂\n\n",
 "geom_sum₂_eq_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem geom_sum₂_eq_one :\n    multiplicity (↑p)\n        (finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (range p)\n          (x ^ i * y ^ (p - 1 - i))) =\n      1 :=\n  by\n  rw [← Nat.cast_one]\n  refine' multiplicity.eq_coe_iff.2 ⟨_, _⟩\n  · rw [pow_one]\n    exact dvd_geom_sum₂_self hxy\n  rw [dvd_iff_dvd_of_dvd_sub hxy] at hx\n  cases' hxy with k hk\n  rw [one_add_one_eq_two, eq_add_of_sub_eq' hk]\n  refine' mt (dvd_iff_dvd_of_dvd_sub (@odd_sq_dvd_geom_sum₂_sub _ _ y k _ hp1)).mp _\n  rw [pow_two, mul_dvd_mul_iff_left hp.ne_zero]\n  exact mt hp.dvd_of_dvd_pow hx\n#align geom_sum₂_eq_one geom_sum₂_eq_one\n\n",
 "dvd_geom_sum₂_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem dvd_geom_sum₂_self {x y : R} (h : ↑n ∣ x - y) :\n    ↑n ∣\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (range n)\n        (x ^ i * y ^ (n - 1 - i)) :=\n  (dvd_geom_sum₂_iff_of_dvd_sub h).mpr (dvd_mul_right _ _)\n#align dvd_geom_sum₂_self dvd_geom_sum₂_self\n\n",
 "dvd_geom_sum₂_iff_of_dvd_sub'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem dvd_geom_sum₂_iff_of_dvd_sub' {x y p : R} (h : p ∣ x - y) :\n    p ∣\n        finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (range n)\n          (x ^ i * y ^ (n - 1 - i)) ↔\n      p ∣ n * x ^ (n - 1) :=\n  by rw [geom_sum₂_comm, dvd_geom_sum₂_iff_of_dvd_sub] <;> simpa using h.neg_right\n#align dvd_geom_sum₂_iff_of_dvd_sub' dvd_geom_sum₂_iff_of_dvd_sub'\n\n",
 "dvd_geom_sum₂_iff_of_dvd_sub":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/-\nCopyright (c) 2022 Tian Chen. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Tian Chen, Mantas Bakšys\n-/\ntheorem dvd_geom_sum₂_iff_of_dvd_sub {x y p : R} (h : p ∣ x - y) :\n    p ∣\n        finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (range n)\n          (x ^ i * y ^ (n - 1 - i)) ↔\n      p ∣ n * y ^ (n - 1) :=\n  by\n  rw [← mem_span_singleton, ← Ideal.Quotient.eq] at h\n  simp only [← mem_span_singleton, ← eq_zero_iff_mem, RingHom.map_geom_sum₂, h, geom_sum₂_self, _root_.map_mul, map_pow,\n    map_natCast]\n#align dvd_geom_sum₂_iff_of_dvd_sub dvd_geom_sum₂_iff_of_dvd_sub\n\n"}