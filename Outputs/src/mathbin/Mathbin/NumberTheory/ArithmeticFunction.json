{"zeta_pmul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `arithmetic_function.zeta -/\n@[simp]\ntheorem zeta_pmul (f : arithmetic_function R) : (arithmetic_function.zeta : arithmetic_function R).pmul f = f :=\n  by\n  ext x\n  cases x <;> simp [nat.succ_ne_zero]\n#align zeta_pmul zeta_pmul\n\n",
 "zeta_mul_pow_eq_sigma":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `arithmetic_function.zeta -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `arithmetic_function.sigma -/\ntheorem zeta_mul_pow_eq_sigma {k : ℕ} : arithmetic_function.zeta * pow k = (arithmetic_function.sigma) k :=\n  by\n  ext\n  rw [Sigma, zeta_mul_apply]\n  apply sum_congr rfl\n  intro x hx\n  rw [pow_apply, if_neg (not_and_of_not_right _ _)]\n  contrapose! hx\n  simp [hx]\n#align zeta_mul_pow_eq_sigma zeta_mul_pow_eq_sigma\n\n",
 "zeta_mul_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `arithmetic_function.zeta -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `arithmetic_function.zeta -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem zeta_mul_apply {f : arithmetic_function ℕ} {x : ℕ} :\n    (arithmetic_function.zeta * f) x =\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (divisors x)\n        (f i) :=\n  by rw [← nat_coe_nat (arithmetic_function.zeta), coe_zeta_mul_apply]\n#align zeta_mul_apply zeta_mul_apply\n\n",
 "zeta_apply_ne":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `arithmetic_function.zeta -/\ntheorem zeta_apply_ne {x : ℕ} (h : x ≠ 0) : (arithmetic_function.zeta) x = 1 :=\n  if_neg h\n#align zeta_apply_ne zeta_apply_ne\n\n",
 "zeta_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `arithmetic_function.zeta -/\n@[simp]\ntheorem zeta_apply {x : ℕ} : (arithmetic_function.zeta) x = if x = 0 then 0 else 1 :=\n  rfl\n#align zeta_apply zeta_apply\n\n",
 "zero_apply":
 "@[simp]\ntheorem zero_apply {x : ℕ} : (0 : arithmetic_function R) x = 0 :=\n  ZeroHom.zero_apply x\n#align zero_apply zero_apply\n\n",
 "to_fun_eq":
 "/-\nCopyright (c) 2020 Aaron Anderson. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Aaron Anderson\n-/\n@[simp]\ntheorem to_fun_eq (f : arithmetic_function R) : f.to_fun = f :=\n  rfl\n#align to_fun_eq to_fun_eq\n\n",
 "sum_eq_iff_sum_smul_moebius_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `arithmetic_function.zeta -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `moebius -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `moebius -/\n/-- Möbius inversion for functions to an `add_comm_group`. -/\ntheorem sum_eq_iff_sum_smul_moebius_eq [AddCommGroup R] {f g : ℕ → R} :\n    (∀ n : ℕ,\n        0 < n →\n          finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" n.divisors\n              (f i) =\n            g n) ↔\n      ∀ n : ℕ,\n        0 < n →\n          finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n              n.divisors_antidiagonal («expr • » ((moebius) x.fst) (g x.snd)) =\n            f n :=\n  by\n  let f' : arithmetic_function R := ⟨fun x => if x = 0 then 0 else f x, if_pos rfl⟩\n  let g' : arithmetic_function R := ⟨fun x => if x = 0 then 0 else g x, if_pos rfl⟩\n  trans «expr • » (arithmetic_function.zeta : arithmetic_function ℤ) f' = g'\n  · rw [ext_iff]\n    apply forall_congr'\n    intro n\n    cases n\n    · simp\n    rw [coe_zeta_smul_apply]\n    simp only [n.succ_ne_zero, forall_prop_of_true, succ_pos', if_false, ZeroHom.coe_mk]\n    rw [sum_congr rfl fun x hx => _]\n    rw [if_neg (ne_of_gt (Nat.pos_of_mem_divisors hx))]\n  trans «expr • » (moebius) g' = f'\n  · constructor <;> intro h\n    · rw [← h, ← mul_smul, moebius_mul_coe_zeta, one_smul]\n    · rw [← h, ← mul_smul, coe_zeta_mul_moebius, one_smul]\n  · rw [ext_iff]\n    apply forall_congr'\n    intro n\n    cases n\n    · simp\n    simp only [n.succ_ne_zero, forall_prop_of_true, succ_pos', smul_apply, if_false, ZeroHom.coe_mk]\n    rw [sum_congr rfl fun x hx => _]\n    rw [if_neg (ne_of_gt (Nat.pos_of_mem_divisors (snd_mem_divisors_of_mem_antidiagonal hx)))]\n#align sum_eq_iff_sum_smul_moebius_eq sum_eq_iff_sum_smul_moebius_eq\n\n",
 "sum_eq_iff_sum_mul_moebius_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `moebius -/\n/-- Möbius inversion for functions to a `ring`. -/\ntheorem sum_eq_iff_sum_mul_moebius_eq [Ring R] {f g : ℕ → R} :\n    (∀ n : ℕ,\n        0 < n →\n          finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" n.divisors\n              (f i) =\n            g n) ↔\n      ∀ n : ℕ,\n        0 < n →\n          finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n              n.divisors_antidiagonal (((moebius) x.fst : R) * g x.snd) =\n            f n :=\n  by\n  rw [sum_eq_iff_sum_smul_moebius_eq]\n  apply forall_congr'\n  refine' fun a => imp_congr_right fun _ => (sum_congr rfl fun x hx => _).congr_left\n  rw [zsmul_eq_mul]\n#align sum_eq_iff_sum_mul_moebius_eq sum_eq_iff_sum_mul_moebius_eq\n\n",
 "smul_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem smul_apply {f : arithmetic_function R} {g : arithmetic_function M} {n : ℕ} :\n    («expr • » f g) n =\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n        (divisorsAntidiagonal n) («expr • » (f x.fst) (g x.snd)) :=\n  rfl\n#align smul_apply smul_apply\n\n",
 "sigma_zero_apply_prime_pow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `arithmetic_function.sigma -/\ntheorem sigma_zero_apply_prime_pow {p i : ℕ} (hp : p.prime) : (arithmetic_function.sigma) 0 (p ^ i) = i + 1 := by\n  rw [sigma_zero_apply, divisors_prime_pow hp, card_map, card_range]\n#align sigma_zero_apply_prime_pow sigma_zero_apply_prime_pow\n\n",
 "sigma_zero_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `arithmetic_function.sigma -/\ntheorem sigma_zero_apply (n : ℕ) : (arithmetic_function.sigma) 0 n = (divisors n).card := by simp [sigma_apply]\n#align sigma_zero_apply sigma_zero_apply\n\n",
 "sigma_one_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `arithmetic_function.sigma -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem sigma_one_apply (n : ℕ) :\n    (arithmetic_function.sigma) 1 n =\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (divisors n) d :=\n  by simp [sigma_apply]\n#align sigma_one_apply sigma_one_apply\n\n",
 "sigma_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `arithmetic_function.sigma -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem sigma_apply {k n : ℕ} :\n    (arithmetic_function.sigma) k n =\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (divisors n)\n        (d ^ k) :=\n  rfl\n#align sigma_apply sigma_apply\n\n",
 "prod_eq_iff_prod_pow_moebius_eq_of_nonzero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `moebius -/\n/-- Möbius inversion for functions to a `comm_group_with_zero`. -/\ntheorem prod_eq_iff_prod_pow_moebius_eq_of_nonzero [CommGroupWithZero R] {f g : ℕ → R} (hf : ∀ n : ℕ, 0 < n → f n ≠ 0)\n    (hg : ∀ n : ℕ, 0 < n → g n ≠ 0) :\n    (∀ n : ℕ,\n        0 < n →\n          finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" n.divisors\n              (f i) =\n            g n) ↔\n      ∀ n : ℕ,\n        0 < n →\n          finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\"\n              n.divisors_antidiagonal (g x.snd ^ (moebius) x.fst) =\n            f n :=\n  by\n  refine'\n      iff.trans\n        (iff.trans (forall_congr' fun n => _)\n          (@prod_eq_iff_prod_pow_moebius_eq («expr ˣ» R) _ (fun n => if h : 0 < n then Units.mk0 (f n) (hf n h) else 1)\n            fun n => if h : 0 < n then Units.mk0 (g n) (hg n h) else 1))\n        (forall_congr' fun n => _) <;>\n    refine' imp_congr_right fun hn => _\n  · dsimp\n    rw [dif_pos hn, ← Units.eq_iff, ← Units.coeHom_apply, MonoidHom.map_prod, Units.val_mk0, prod_congr rfl _]\n    intro x hx\n    rw [dif_pos (Nat.pos_of_mem_divisors hx), Units.coeHom_apply, Units.val_mk0]\n  · dsimp\n    rw [dif_pos hn, ← Units.eq_iff, ← Units.coeHom_apply, MonoidHom.map_prod, Units.val_mk0, prod_congr rfl _]\n    intro x hx\n    rw [dif_pos (Nat.pos_of_mem_divisors (Nat.snd_mem_divisors_of_mem_antidiagonal hx)), Units.coeHom_apply,\n      Units.val_zpow_eq_zpow_val, Units.val_mk0]\n#align prod_eq_iff_prod_pow_moebius_eq_of_nonzero prod_eq_iff_prod_pow_moebius_eq_of_nonzero\n\n",
 "prod_eq_iff_prod_pow_moebius_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `moebius -/\n/-- Möbius inversion for functions to a `comm_group`. -/\ntheorem prod_eq_iff_prod_pow_moebius_eq [CommGroup R] {f g : ℕ → R} :\n    (∀ n : ℕ,\n        0 < n →\n          finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" n.divisors\n              (f i) =\n            g n) ↔\n      ∀ n : ℕ,\n        0 < n →\n          finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\"\n              n.divisors_antidiagonal (g x.snd ^ (moebius) x.fst) =\n            f n :=\n  @sum_eq_iff_sum_smul_moebius_eq (Additive R) _ _ _\n#align prod_eq_iff_prod_pow_moebius_eq prod_eq_iff_prod_pow_moebius_eq\n\n",
 "ppow_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `arithmetic_function.zeta -/\n@[simp]\ntheorem ppow_zero {f : arithmetic_function R} : f.ppow 0 = arithmetic_function.zeta := by rw [ppow, dif_pos rfl]\n#align ppow_zero ppow_zero\n\n",
 "ppow_succ'":
 "theorem ppow_succ' {f : arithmetic_function R} {k : ℕ} {kpos : 0 < k} : f.ppow (k + 1) = (f.ppow k).pmul f :=\n  by\n  ext x\n  rw [ppow_apply (nat.succ_pos k), pow_succ']\n  induction k <;> simp\n#align ppow_succ' ppow_succ'\n\n",
 "ppow_succ":
 "theorem ppow_succ {f : arithmetic_function R} {k : ℕ} : f.ppow (k + 1) = f.pmul (f.ppow k) :=\n  by\n  ext x\n  rw [ppow_apply (nat.succ_pos k), pow_succ]\n  induction k <;> simp\n#align ppow_succ ppow_succ\n\n",
 "ppow_apply":
 "@[simp]\ntheorem ppow_apply {f : arithmetic_function R} {k x : ℕ} (kpos : 0 < k) : f.ppow k x = f x ^ k :=\n  by\n  rw [ppow, dif_neg (ne_of_gt kpos)]\n  rfl\n#align ppow_apply ppow_apply\n\n",
 "ppow":
 "theorem is_multiplicative.ppow [CommSemiring R] {f : arithmetic_function R} (hf : f.is_multiplicative) {k : ℕ} :\n    is_multiplicative (f.ppow k) := by\n  induction' k with k hi\n  · exact is_multiplicative_zeta.nat_cast\n  · rw [ppow_succ]\n    apply hf.pmul hi\n#align is_multiplicative.ppow is_multiplicative.ppow\n\n",
 "pow_zero_eq_zeta":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `arithmetic_function.zeta -/\ntheorem pow_zero_eq_zeta : pow 0 = arithmetic_function.zeta :=\n  by\n  ext n\n  simp\n#align pow_zero_eq_zeta pow_zero_eq_zeta\n\n",
 "pow_apply":
 "@[simp]\ntheorem pow_apply {k n : ℕ} : pow k n = if k = 0 ∧ n = 0 then 0 else n ^ k :=\n  by\n  cases k\n  · simp [pow]\n  simp [pow, (ne_of_lt (nat.succ_pos k)).symm]\n#align pow_apply pow_apply\n\n",
 "pmul_zeta":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `arithmetic_function.zeta -/\n@[simp]\ntheorem pmul_zeta (f : arithmetic_function R) : f.pmul ↑(arithmetic_function.zeta) = f :=\n  by\n  ext x\n  cases x <;> simp [nat.succ_ne_zero]\n#align pmul_zeta pmul_zeta\n\n",
 "pmul_comm":
 "theorem pmul_comm [CommMonoidWithZero R] (f g : arithmetic_function R) : f.pmul g = g.pmul f :=\n  by\n  ext\n  simp [mul_comm]\n#align pmul_comm pmul_comm\n\n",
 "pmul_apply":
 "@[simp]\ntheorem pmul_apply [MulZeroClass R] {f g : arithmetic_function R} {x : ℕ} : f.pmul g x = f x * g x :=\n  rfl\n#align pmul_apply pmul_apply\n\n",
 "pmul":
 "theorem pmul [CommSemiring R] {f g : arithmetic_function R} (hf : f.is_multiplicative) (hg : g.is_multiplicative) :\n    is_multiplicative (f.pmul g) :=\n  ⟨by simp [hf, hg], fun m n cop =>\n    by\n    simp only [pmul_apply, hf.map_mul_of_coprime cop, hg.map_mul_of_coprime cop]\n    ring⟩\n#align pmul pmul\n\n",
 "one_smul'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem one_smul' (b : arithmetic_function M) : «expr • » (1 : arithmetic_function R) b = b :=\n  by\n  ext\n  rw [smul_apply]\n  by_cases x0 : x = 0\n  · simp [x0]\n  have h : {(1, x)} ⊆ divisors_antidiagonal x := by simp [x0]\n  rw [← sum_subset h]\n  · simp\n  intro y ymem ynmem\n  have y1ne : y.fst ≠ 1 := by\n    intro con\n    simp only [Con, mem_divisors_antidiagonal, one_mul, ne.def] at ymem\n    simp only [mem_singleton, Prod.ext_iff] at ynmem\n    tauto\n  simp [y1ne]\n#align one_smul' one_smul'\n\n",
 "one_one":
 "@[simp]\ntheorem one_one : (1 : arithmetic_function R) 1 = 1 :=\n  rfl\n#align one_one one_one\n\n",
 "one_apply_ne":
 "@[simp]\ntheorem one_apply_ne {x : ℕ} (h : x ≠ 1) : (1 : arithmetic_function R) x = 0 :=\n  if_neg h\n#align one_apply_ne one_apply_ne\n\n",
 "one_apply":
 "theorem one_apply {x : ℕ} : (1 : arithmetic_function R) x = ite (x = 1) 1 0 :=\n  rfl\n#align one_apply one_apply\n\n",
 "nat_coe_one":
 "@[simp]\ntheorem nat_coe_one [AddMonoidWithOne R] : ((1 : arithmetic_function ℕ) : arithmetic_function R) = 1 :=\n  by\n  ext n\n  simp [one_apply]\n#align nat_coe_one nat_coe_one\n\n",
 "nat_coe_nat":
 "@[simp]\ntheorem nat_coe_nat (f : arithmetic_function ℕ) : (↑f : arithmetic_function ℕ) = f :=\n  ext fun _ => cast_id _\n#align nat_coe_nat nat_coe_nat\n\n",
 "nat_coe_mul":
 "@[simp, norm_cast]\ntheorem nat_coe_mul [Semiring R] {f g : arithmetic_function ℕ} : (↑(f * g) : arithmetic_function R) = f * g :=\n  by\n  ext n\n  simp\n#align nat_coe_mul nat_coe_mul\n\n",
 "nat_coe_apply":
 "@[simp]\ntheorem nat_coe_apply [AddMonoidWithOne R] {f : arithmetic_function ℕ} {x : ℕ} : (f : arithmetic_function R) x = f x :=\n  rfl\n#align nat_coe_apply nat_coe_apply\n\n",
 "nat_cast":
 "theorem nat_cast {f : arithmetic_function ℕ} [Semiring R] (h : f.is_multiplicative) :\n    is_multiplicative (f : arithmetic_function R) :=\n  ⟨by simp [h], fun m n cop => by simp [cop, h]⟩\n#align nat_cast nat_cast\n\n",
 "multiplicative_factorization":
 "/-- For any multiplicative function `f` and any `n > 0`,\nwe can evaluate `f n` by evaluating `f` at `p ^ k` over the factorization of `n` -/\ntheorem multiplicative_factorization [CommMonoidWithZero R] (f : arithmetic_function R) (hf : f.is_multiplicative)\n    {n : ℕ} (hn : n ≠ 0) : f n = n.factorization.prod fun p k => f (p ^ k) :=\n  multiplicative_factorization f (fun _ _ => hf.2) hf.1 hn\n#align multiplicative_factorization multiplicative_factorization\n\n",
 "mul_zeta_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `arithmetic_function.zeta -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `arithmetic_function.zeta -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem mul_zeta_apply {f : arithmetic_function ℕ} {x : ℕ} :\n    (f * arithmetic_function.zeta) x =\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (divisors x)\n        (f i) :=\n  by rw [← nat_coe_nat (arithmetic_function.zeta), coe_mul_zeta_apply]\n#align mul_zeta_apply mul_zeta_apply\n\n",
 "mul_smul'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem mul_smul' (f g : arithmetic_function R) (h : arithmetic_function M) :\n    «expr • » (f * g) h = «expr • » f («expr • » g h) := by\n  ext n\n  simp only [mul_apply, smul_apply, sum_smul, mul_smul, smul_sum, Finset.sum_sigma']\n  apply Finset.sum_bij\n  pick_goal 5\n  · rintro ⟨⟨i, j⟩, ⟨k, l⟩⟩ H\n    exact ⟨(k, l * j), (l, j)⟩\n  · rintro ⟨⟨i, j⟩, ⟨k, l⟩⟩ H\n    simp only [Finset.mem_sigma, mem_divisors_antidiagonal] at H⊢\n    rcases H with ⟨⟨rfl, n0⟩, rfl, i0⟩\n    refine' ⟨⟨(mul_assoc _ _ _).symm, n0⟩, rfl, _⟩\n    rw [mul_ne_zero_iff] at *\n    exact ⟨i0.2, n0.2⟩\n  · rintro ⟨⟨i, j⟩, ⟨k, l⟩⟩ H\n    simp only [mul_assoc]\n  · rintro ⟨⟨a, b⟩, ⟨c, d⟩⟩ ⟨⟨i, j⟩, ⟨k, l⟩⟩ H₁ H₂\n    simp only [Finset.mem_sigma, mem_divisors_antidiagonal, and_imp, Prod.mk.inj_iff, add_comm, heq_iff_eq] at H₁ H₂⊢\n    rintro rfl h2 rfl rfl\n    exact ⟨⟨Eq.trans H₁.2.1.symm H₂.2.1, rfl⟩, rfl, rfl⟩\n  · rintro ⟨⟨i, j⟩, ⟨k, l⟩⟩ H\n    refine' ⟨⟨(i * k, l), (i, k)⟩, _, _⟩\n    · simp only [Finset.mem_sigma, mem_divisors_antidiagonal] at H⊢\n      rcases H with ⟨⟨rfl, n0⟩, rfl, j0⟩\n      refine' ⟨⟨mul_assoc _ _ _, n0⟩, rfl, _⟩\n      rw [mul_ne_zero_iff] at *\n      exact ⟨n0.1, j0.1⟩\n    · simp only [true_and_iff, mem_divisors_antidiagonal, and_true_iff, Prod.mk.inj_iff, eq_self_iff_true, ne.def,\n        mem_sigma, heq_iff_eq] at H⊢\n      rw [H.2.1]\n#align mul_smul' mul_smul'\n\n",
 "mul_apply_one":
 "theorem mul_apply_one [Semiring R] {f g : arithmetic_function R} : (f * g) 1 = f 1 * g 1 := by simp\n#align mul_apply_one mul_apply_one\n\n",
 "mul_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n@[simp]\ntheorem mul_apply [Semiring R] {f g : arithmetic_function R} {n : ℕ} :\n    (f * g) n =\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n        (divisorsAntidiagonal n) (f x.fst * g x.snd) :=\n  rfl\n#align mul_apply mul_apply\n\n",
 "mul":
 "theorem mul [CommSemiring R] {f g : arithmetic_function R} (hf : f.is_multiplicative) (hg : g.is_multiplicative) :\n    is_multiplicative (f * g) :=\n  ⟨by simp [hf, hg], by\n    simp only [mul_apply]\n    intro m n cop\n    rw [sum_mul_sum]\n    symm\n    apply sum_bij fun (x : (ℕ × ℕ) × ℕ × ℕ) h => (x.1.1 * x.2.1, x.1.2 * x.2.2)\n    · rintro ⟨⟨a1, a2⟩, ⟨b1, b2⟩⟩ h\n      simp only [mem_divisors_antidiagonal, ne.def, mem_product] at h\n      rcases h with ⟨⟨rfl, ha⟩, ⟨rfl, hb⟩⟩\n      simp only [mem_divisors_antidiagonal, Nat.mul_eq_zero, ne.def]\n      constructor\n      · ring\n      rw [Nat.mul_eq_zero] at *\n      apply not_or_of_not ha hb\n    · rintro ⟨⟨a1, a2⟩, ⟨b1, b2⟩⟩ h\n      simp only [mem_divisors_antidiagonal, ne.def, mem_product] at h\n      rcases h with ⟨⟨rfl, ha⟩, ⟨rfl, hb⟩⟩\n      dsimp only\n      rw [hf.map_mul_of_coprime cop.coprime_mul_right.coprime_mul_right_right,\n        hg.map_mul_of_coprime cop.coprime_mul_left.coprime_mul_left_right]\n      ring\n    · rintro ⟨⟨a1, a2⟩, ⟨b1, b2⟩⟩ ⟨⟨c1, c2⟩, ⟨d1, d2⟩⟩ hab hcd h\n      simp only [mem_divisors_antidiagonal, ne.def, mem_product] at hab\n      rcases hab with ⟨⟨rfl, ha⟩, ⟨rfl, hb⟩⟩\n      simp only [mem_divisors_antidiagonal, ne.def, mem_product] at hcd\n      simp only [Prod.mk.inj_iff] at h\n      ext <;> dsimp only\n      · trans Nat.gcd (a1 * a2) (a1 * b1)\n        · rw [Nat.gcd_mul_left, cop.coprime_mul_left.coprime_mul_right_right.gcd_eq_one, mul_one]\n        · rw [← hcd.1.1, ← hcd.2.1] at cop\n          rw [← hcd.1.1, h.1, Nat.gcd_mul_left, cop.coprime_mul_left.coprime_mul_right_right.gcd_eq_one, mul_one]\n      · trans Nat.gcd (a1 * a2) (a2 * b2)\n        · rw [mul_comm, Nat.gcd_mul_left, cop.coprime_mul_right.coprime_mul_left_right.gcd_eq_one, mul_one]\n        · rw [← hcd.1.1, ← hcd.2.1] at cop\n          rw [← hcd.1.1, h.2, mul_comm, Nat.gcd_mul_left, cop.coprime_mul_right.coprime_mul_left_right.gcd_eq_one,\n            mul_one]\n      · trans Nat.gcd (b1 * b2) (a1 * b1)\n        · rw [mul_comm, Nat.gcd_mul_right, cop.coprime_mul_right.coprime_mul_left_right.symm.gcd_eq_one, one_mul]\n        · rw [← hcd.1.1, ← hcd.2.1] at cop\n          rw [← hcd.2.1, h.1, mul_comm c1 d1, Nat.gcd_mul_left,\n            cop.coprime_mul_right.coprime_mul_left_right.symm.gcd_eq_one, mul_one]\n      · trans Nat.gcd (b1 * b2) (a2 * b2)\n        · rw [Nat.gcd_mul_right, cop.coprime_mul_left.coprime_mul_right_right.symm.gcd_eq_one, one_mul]\n        · rw [← hcd.1.1, ← hcd.2.1] at cop\n          rw [← hcd.2.1, h.2, Nat.gcd_mul_right, cop.coprime_mul_left.coprime_mul_right_right.symm.gcd_eq_one, one_mul]\n    · rintro ⟨b1, b2⟩ h\n      simp only [mem_divisors_antidiagonal, ne.def, mem_product] at h\n      use ((b1.gcd m, b2.gcd m), (b1.gcd n, b2.gcd n))\n      simp only [exists_prop, Prod.mk.inj_iff, ne.def, mem_product, mem_divisors_antidiagonal]\n      rw [← cop.gcd_mul _, ← cop.gcd_mul _, ← h.1, Nat.gcd_mul_gcd_of_coprime_of_mul_eq_mul cop h.1,\n        Nat.gcd_mul_gcd_of_coprime_of_mul_eq_mul cop.symm _]\n      · rw [Nat.mul_eq_zero, decidable.not_or_iff_and_not] at h\n        simp [h.2.1, h.2.2]\n      rw [mul_comm n m, h.1]⟩\n#align mul mul\n\n",
 "moebius_ne_zero_iff_squarefree":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `moebius -/\ntheorem moebius_ne_zero_iff_squarefree {n : ℕ} : (moebius) n ≠ 0 ↔ Squarefree n :=\n  by\n  constructor <;> intro h\n  · contrapose! h\n    simp [h]\n  · simp [h, pow_ne_zero]\n#align moebius_ne_zero_iff_squarefree moebius_ne_zero_iff_squarefree\n\n",
 "moebius_ne_zero_iff_eq_or":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `moebius -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `moebius -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `moebius -/\ntheorem moebius_ne_zero_iff_eq_or {n : ℕ} : (moebius) n ≠ 0 ↔ (moebius) n = 1 ∨ (moebius) n = -1 :=\n  by\n  constructor <;> intro h\n  · rw [moebius_ne_zero_iff_squarefree] at h\n    rw [moebius_apply_of_squarefree h]\n    apply neg_one_pow_eq_or\n  · rcases h with (h | h) <;> simp [h]\n#align moebius_ne_zero_iff_eq_or moebius_ne_zero_iff_eq_or\n\n",
 "moebius_mul_coe_zeta":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `moebius -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `arithmetic_function.zeta -/\n@[simp]\ntheorem moebius_mul_coe_zeta : (moebius * arithmetic_function.zeta : arithmetic_function ℤ) = 1 :=\n  by\n  ext n\n  refine' rec_on_pos_prime_pos_coprime _ _ _ _ n\n  · intro p n hp hn\n    rw [coe_mul_zeta_apply, sum_divisors_prime_pow hp, sum_range_succ']\n    simp_rw [Function.Embedding.coeFn_mk, pow_zero, moebius_apply_one, moebius_apply_prime_pow hp (nat.succ_ne_zero _),\n      Nat.succ_inj', sum_ite_eq', mem_range, if_pos hn, add_left_neg]\n    rw [one_apply_ne]\n    rw [ne.def, pow_eq_one_iff]\n    · exact hp.ne_one\n    · exact hn.ne'\n  · rw [ZeroHom.map_zero, ZeroHom.map_zero]\n  · simp\n  · intro a b ha hb hab ha' hb'\n    rw [is_multiplicative.map_mul_of_coprime _ hab, ha', hb',\n      is_multiplicative.map_mul_of_coprime is_multiplicative_one hab]\n    exact is_multiplicative_moebius.mul is_multiplicative_zeta.nat_cast\n#align moebius_mul_coe_zeta moebius_mul_coe_zeta\n\n",
 "moebius_eq_zero_of_not_squarefree":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `moebius -/\n@[simp]\ntheorem moebius_eq_zero_of_not_squarefree {n : ℕ} (h : ¬Squarefree n) : (moebius) n = 0 :=\n  if_neg h\n#align moebius_eq_zero_of_not_squarefree moebius_eq_zero_of_not_squarefree\n\n",
 "moebius_apply_prime_pow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `moebius -/\ntheorem moebius_apply_prime_pow {p k : ℕ} (hp : p.prime) (hk : k ≠ 0) : (moebius) (p ^ k) = if k = 1 then -1 else 0 :=\n  by\n  split_ifs\n  · rw [h, pow_one, moebius_apply_prime hp]\n  rw [moebius_eq_zero_of_not_squarefree]\n  rw [squarefree_pow_iff hp.ne_one hk, not_and_or]\n  exact or.inr h\n#align moebius_apply_prime_pow moebius_apply_prime_pow\n\n",
 "moebius_apply_prime":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `moebius -/\ntheorem moebius_apply_prime {p : ℕ} (hp : p.prime) : (moebius) p = -1 := by\n  rw [moebius_apply_of_squarefree hp.squarefree, card_factors_apply_prime hp, pow_one]\n#align moebius_apply_prime moebius_apply_prime\n\n",
 "moebius_apply_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `moebius -/\ntheorem moebius_apply_one : (moebius) 1 = 1 := by simp\n#align moebius_apply_one moebius_apply_one\n\n",
 "moebius_apply_of_squarefree":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `moebius -/\n@[simp]\ntheorem moebius_apply_of_squarefree {n : ℕ} (h : Squarefree n) : (moebius) n = (-1) ^ card_factors n :=\n  if_pos h\n#align moebius_apply_of_squarefree moebius_apply_of_squarefree\n\n",
 "moebius_apply_is_prime_pow_not_prime":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `moebius -/\ntheorem moebius_apply_is_prime_pow_not_prime {n : ℕ} (hn : IsPrimePow n) (hn' : ¬n.prime) : (moebius) n = 0 :=\n  by\n  obtain ⟨p, k, hp, hk, rfl⟩ := (isPrimePow_nat_iff _).1 hn\n  rw [moebius_apply_prime_pow hp hk.ne', if_neg]\n  rintro rfl\n  exact hn' (by simpa)\n#align moebius_apply_is_prime_pow_not_prime moebius_apply_is_prime_pow_not_prime\n\n",
 "map_zero":
 "#print map_zero /-\n@[simp]\ntheorem map_zero {f : arithmetic_function R} : f 0 = 0 :=\n  ZeroHom.map_zero' f\n#align map_zero map_zero\n-/\n\n",
 "map_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr on » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n#print map_prod /-\ntheorem map_prod {ι : Type _} [CommMonoidWithZero R] (g : ι → ℕ) {f : nat.arithmetic_function R}\n    (hf : f.is_multiplicative) (s : Finset ι) (hs : (s : Set ι).pairwise («expr on » coprime g)) :\n    f (finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (g i)) =\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f (g i)) :=\n  by\n  classical\n    induction' s using Finset.induction_on with a s has ih hs\n    · simp [hf]\n    rw [coe_insert, Set.pairwise_insert_of_symmetric (coprime.symmetric.comap g)] at hs\n    rw [prod_insert has, prod_insert has, hf.map_mul_of_coprime, ih hs.1]\n    exact Nat.coprime_prod_right fun i hi => hs.2 _ hi (hi.ne_of_not_mem has).symm\n#align map_prod map_prod\n-/\n\n",
 "map_one":
 "#print map_one /-\n@[simp]\ntheorem map_one {f : arithmetic_function R} (h : f.is_multiplicative) : f 1 = 1 :=\n  h.1\n#align map_one map_one\n-/\n\n",
 "map_mul_of_coprime":
 "@[simp]\ntheorem map_mul_of_coprime {f : arithmetic_function R} (hf : f.is_multiplicative) {m n : ℕ} (h : m.coprime n) :\n    f (m * n) = f m * f n :=\n  hf.2 h\n#align map_mul_of_coprime map_mul_of_coprime\n\n",
 "is_multiplicative_zeta":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `arithmetic_function.zeta -/\ntheorem is_multiplicative_zeta : is_multiplicative (arithmetic_function.zeta) :=\n  is_multiplicative.iff_ne_zero.2 ⟨by simp, by simp (config := { contextual := true })⟩\n#align is_multiplicative_zeta is_multiplicative_zeta\n\n",
 "is_multiplicative_sigma":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `arithmetic_function.sigma -/\ntheorem is_multiplicative_sigma {k : ℕ} : is_multiplicative ((arithmetic_function.sigma) k) :=\n  by\n  rw [← zeta_mul_pow_eq_sigma]\n  apply is_multiplicative_zeta.mul is_multiplicative_pow\n#align is_multiplicative_sigma is_multiplicative_sigma\n\n",
 "is_multiplicative_pow":
 "theorem is_multiplicative_pow {k : ℕ} : is_multiplicative (pow k) :=\n  is_multiplicative_id.ppow\n#align is_multiplicative_pow is_multiplicative_pow\n\n",
 "is_multiplicative_one":
 "theorem is_multiplicative_one [MonoidWithZero R] : is_multiplicative (1 : arithmetic_function R) :=\n  is_multiplicative.iff_ne_zero.2\n    ⟨by simp, by\n      intro m n hm hn hmn\n      rcases eq_or_ne m 1 with (rfl | hm')\n      · simp\n      rw [one_apply_ne, one_apply_ne hm', MulZeroClass.zero_mul]\n      rw [ne.def, mul_eq_one, not_and_or]\n      exact or.inl hm'⟩\n#align is_multiplicative_one is_multiplicative_one\n\n",
 "is_multiplicative_moebius":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `moebius -/\ntheorem is_multiplicative_moebius : is_multiplicative (moebius) :=\n  by\n  rw [is_multiplicative.iff_ne_zero]\n  refine' ⟨by simp, fun n m hn hm hnm => _⟩\n  simp only [moebius, ZeroHom.coe_mk, squarefree_mul hnm, ite_and, card_factors_mul hn hm]\n  rw [pow_add, mul_comm, ite_mul_zero_left, ite_mul_zero_right, mul_comm]\n#align is_multiplicative_moebius is_multiplicative_moebius\n\n",
 "is_multiplicative_id":
 "theorem is_multiplicative_id : is_multiplicative arithmetic_function.id :=\n  ⟨rfl, fun _ _ _ => rfl⟩\n#align is_multiplicative_id is_multiplicative_id\n\n",
 "inv_zeta_unit":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `moebius -/\n@[simp]\ntheorem inv_zeta_unit : ((zeta_unit⁻¹ : «expr ˣ» (arithmetic_function R)) : arithmetic_function R) = moebius :=\n  rfl\n#align inv_zeta_unit inv_zeta_unit\n\n",
 "int_coe_one":
 "@[simp]\ntheorem int_coe_one [AddGroupWithOne R] : ((1 : arithmetic_function ℤ) : arithmetic_function R) = 1 :=\n  by\n  ext n\n  simp [one_apply]\n#align int_coe_one int_coe_one\n\n",
 "int_coe_mul":
 "@[simp, norm_cast]\ntheorem int_coe_mul [Ring R] {f g : arithmetic_function ℤ} : (↑(f * g) : arithmetic_function R) = f * g :=\n  by\n  ext n\n  simp\n#align int_coe_mul int_coe_mul\n\n",
 "int_coe_int":
 "@[simp]\ntheorem int_coe_int (f : arithmetic_function ℤ) : (↑f : arithmetic_function ℤ) = f :=\n  ext fun _ => Int.cast_id _\n#align int_coe_int int_coe_int\n\n",
 "int_coe_apply":
 "@[simp]\ntheorem int_coe_apply [AddGroupWithOne R] {f : arithmetic_function ℤ} {x : ℕ} : (f : arithmetic_function R) x = f x :=\n  rfl\n#align int_coe_apply int_coe_apply\n\n",
 "int_cast":
 "theorem int_cast {f : arithmetic_function ℤ} [Ring R] (h : f.is_multiplicative) :\n    is_multiplicative (f : arithmetic_function R) :=\n  ⟨by simp [h], fun m n cop => by simp [cop, h]⟩\n#align int_cast int_cast\n\n",
 "iff_ne_zero":
 "/-- A recapitulation of the definition of multiplicative that is simpler for proofs -/\ntheorem iff_ne_zero [MonoidWithZero R] {f : arithmetic_function R} :\n    is_multiplicative f ↔ f 1 = 1 ∧ ∀ {m n : ℕ}, m ≠ 0 → n ≠ 0 → m.coprime n → f (m * n) = f m * f n :=\n  by\n  refine' and_congr_right' (forall₂_congr fun m n => ⟨fun h _ _ => h, fun h hmn => _⟩)\n  rcases eq_or_ne m 0 with (rfl | hm)\n  · simp\n  rcases eq_or_ne n 0 with (rfl | hn)\n  · simp\n  exact h hm hn hmn\n#align iff_ne_zero iff_ne_zero\n\n",
 "id_apply":
 "@[simp]\ntheorem id_apply {x : ℕ} : id x = x :=\n  rfl\n#align id_apply id_apply\n\n",
 "ext_iff":
 "theorem ext_iff {f g : arithmetic_function R} : f = g ↔ ∀ x, f x = g x :=\n  ZeroHom.ext_iff\n#align ext_iff ext_iff\n\n",
 "ext":
 "@[ext]\ntheorem ext ⦃f g : arithmetic_function R⦄ (h : ∀ x, f x = g x) : f = g :=\n  ZeroHom.ext h\n#align ext ext\n\n",
 "eq_iff_eq_on_prime_powers":
 "/-- Two multiplicative functions `f` and `g` are equal if and only if\nthey agree on prime powers -/\ntheorem eq_iff_eq_on_prime_powers [CommMonoidWithZero R] (f : arithmetic_function R) (hf : f.is_multiplicative)\n    (g : arithmetic_function R) (hg : g.is_multiplicative) : f = g ↔ ∀ p i : ℕ, Nat.Prime p → f (p ^ i) = g (p ^ i) :=\n  by\n  constructor\n  · intro h p i _\n    rw [h]\n  intro h\n  ext n\n  by_cases hn : n = 0\n  · rw [hn, arithmetic_function.map_zero, arithmetic_function.map_zero]\n  rw [multiplicative_factorization f hf hn, multiplicative_factorization g hg hn]\n  refine' Finset.prod_congr rfl _\n  simp only [support_factorization, List.mem_toFinset]\n  intro p hp\n  exact h p _ (Nat.prime_of_mem_factors hp)\n#align eq_iff_eq_on_prime_powers eq_iff_eq_on_prime_powers\n\n",
 "coe_zeta_unit":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `arithmetic_function.zeta -/\n@[simp]\ntheorem coe_zeta_unit :\n    ((zeta_unit : «expr ˣ» (arithmetic_function R)) : arithmetic_function R) = arithmetic_function.zeta :=\n  rfl\n#align coe_zeta_unit coe_zeta_unit\n\n",
 "coe_zeta_smul_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `arithmetic_function.zeta -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n@[simp]\ntheorem coe_zeta_smul_apply {M} [Semiring R] [AddCommMonoid M] [Module R M] {f : arithmetic_function M} {x : ℕ} :\n    («expr • » (↑(arithmetic_function.zeta) : arithmetic_function R) f) x =\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (divisors x)\n        (f i) :=\n  by\n  rw [smul_apply]\n  trans\n    finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n      (divisors_antidiagonal x) (f i.snd)\n  · refine' sum_congr rfl fun i hi => _\n    rcases mem_divisors_antidiagonal.1 hi with ⟨rfl, h⟩\n    rw [nat_coe_apply, zeta_apply_ne (left_ne_zero_of_mul h), cast_one, one_smul]\n  · rw [← map_div_left_divisors, sum_map, Function.Embedding.coeFn_mk]\n#align coe_zeta_smul_apply coe_zeta_smul_apply\n\n",
 "coe_zeta_mul_moebius":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `arithmetic_function.zeta -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `moebius -/\n@[simp]\ntheorem coe_zeta_mul_moebius : (arithmetic_function.zeta * moebius : arithmetic_function ℤ) = 1 := by\n  rw [mul_comm, moebius_mul_coe_zeta]\n#align coe_zeta_mul_moebius coe_zeta_mul_moebius\n\n",
 "coe_zeta_mul_coe_moebius":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `arithmetic_function.zeta -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `moebius -/\n@[simp]\ntheorem coe_zeta_mul_coe_moebius [Ring R] : (arithmetic_function.zeta * moebius : arithmetic_function R) = 1 := by\n  rw [← coe_coe, ← int_coe_mul, coe_zeta_mul_moebius, int_coe_one]\n#align coe_zeta_mul_coe_moebius coe_zeta_mul_coe_moebius\n\n",
 "coe_zeta_mul_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `arithmetic_function.zeta -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n@[simp]\ntheorem coe_zeta_mul_apply [Semiring R] {f : arithmetic_function R} {x : ℕ} :\n    (↑(arithmetic_function.zeta) * f) x =\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (divisors x)\n        (f i) :=\n  coe_zeta_smul_apply\n#align coe_zeta_mul_apply coe_zeta_mul_apply\n\n",
 "coe_mul_zeta_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `arithmetic_function.zeta -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n@[simp]\ntheorem coe_mul_zeta_apply [Semiring R] {f : arithmetic_function R} {x : ℕ} :\n    (f * arithmetic_function.zeta) x =\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (divisors x)\n        (f i) :=\n  by\n  rw [mul_apply]\n  trans\n    finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n      (divisors_antidiagonal x) (f i.1)\n  · refine' sum_congr rfl fun i hi => _\n    rcases mem_divisors_antidiagonal.1 hi with ⟨rfl, h⟩\n    rw [nat_coe_apply, zeta_apply_ne (right_ne_zero_of_mul h), cast_one, mul_one]\n  · rw [← map_div_right_divisors, sum_map, Function.Embedding.coeFn_mk]\n#align coe_mul_zeta_apply coe_mul_zeta_apply\n\n",
 "coe_moebius_mul_coe_zeta":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `moebius -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `arithmetic_function.zeta -/\n@[simp]\ntheorem coe_moebius_mul_coe_zeta [Ring R] : (moebius * arithmetic_function.zeta : arithmetic_function R) = 1 := by\n  rw [← coe_coe, ← int_coe_mul, moebius_mul_coe_zeta, int_coe_one]\n#align coe_moebius_mul_coe_zeta coe_moebius_mul_coe_zeta\n\n",
 "coe_inj":
 "theorem coe_inj {f g : arithmetic_function R} : (f : ℕ → R) = g ↔ f = g :=\n  ⟨fun h => ZeroHom.coe_inj h, fun h => h ▸ rfl⟩\n#align coe_inj coe_inj\n\n",
 "coe_coe":
 "@[simp]\ntheorem coe_coe [AddGroupWithOne R] {f : arithmetic_function ℕ} :\n    ((f : arithmetic_function ℤ) : arithmetic_function R) = f :=\n  by\n  ext\n  simp\n#align coe_coe coe_coe\n\n",
 "card_factors_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `card_factors -/\n@[simp]\ntheorem card_factors_one : (card_factors) 1 = 0 := by simp [card_factors]\n#align card_factors_one card_factors_one\n\n",
 "card_factors_multiset_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `card_factors -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `card_factors -/\ntheorem card_factors_multiset_prod {s : Multiset ℕ} (h0 : s.prod ≠ 0) :\n    (card_factors) s.prod = (Multiset.map (card_factors) s).sum :=\n  by\n  revert h0\n  apply s.induction_on; · simp\n  intro a t h h0\n  rw [Multiset.prod_cons, mul_ne_zero_iff] at h0\n  simp [h0, card_factors_mul, h]\n#align card_factors_multiset_prod card_factors_multiset_prod\n\n",
 "card_factors_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `card_factors -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `card_factors -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `card_factors -/\ntheorem card_factors_mul {m n : ℕ} (m0 : m ≠ 0) (n0 : n ≠ 0) :\n    (card_factors) (m * n) = (card_factors) m + (card_factors) n := by\n  rw [card_factors_apply, card_factors_apply, card_factors_apply, ← Multiset.coe_card, ← factors_eq,\n    UniqueFactorizationMonoid.normalizedFactors_mul m0 n0, factors_eq, factors_eq, Multiset.card_add, Multiset.coe_card,\n    Multiset.coe_card]\n#align card_factors_mul card_factors_mul\n\n",
 "card_factors_eq_one_iff_prime":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `card_factors -/\ntheorem card_factors_eq_one_iff_prime {n : ℕ} : (card_factors) n = 1 ↔ n.prime :=\n  by\n  refine' ⟨fun h => _, fun h => List.length_eq_one.2 ⟨n, factors_prime h⟩⟩\n  cases n\n  · contrapose! h\n    simp\n  rcases List.length_eq_one.1 h with ⟨x, hx⟩\n  rw [← prod_factors n.succ_ne_zero, hx, List.prod_singleton]\n  apply prime_of_mem_factors\n  rw [hx, List.mem_singleton]\n#align card_factors_eq_one_iff_prime card_factors_eq_one_iff_prime\n\n",
 "card_factors_apply_prime_pow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `card_factors -/\n@[simp]\ntheorem card_factors_apply_prime_pow {p k : ℕ} (hp : p.prime) : (card_factors) (p ^ k) = k := by\n  rw [card_factors_apply, hp.factors_pow, List.length_replicate]\n#align card_factors_apply_prime_pow card_factors_apply_prime_pow\n\n",
 "card_factors_apply_prime":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `card_factors -/\n@[simp]\ntheorem card_factors_apply_prime {p : ℕ} (hp : p.prime) : (card_factors) p = 1 :=\n  card_factors_eq_one_iff_prime.2 hp\n#align card_factors_apply_prime card_factors_apply_prime\n\n",
 "card_factors_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `card_factors -/\ntheorem card_factors_apply {n : ℕ} : (card_factors) n = n.factors.length :=\n  rfl\n#align card_factors_apply card_factors_apply\n\n",
 "card_distinct_factors_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `card_distinct_factors -/\ntheorem card_distinct_factors_zero : (card_distinct_factors) 0 = 0 := by simp\n#align card_distinct_factors_zero card_distinct_factors_zero\n\n",
 "card_distinct_factors_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `card_distinct_factors -/\n@[simp]\ntheorem card_distinct_factors_one : (card_distinct_factors) 1 = 0 := by simp [card_distinct_factors]\n#align card_distinct_factors_one card_distinct_factors_one\n\n",
 "card_distinct_factors_eq_card_factors_iff_squarefree":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `card_distinct_factors -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `card_factors -/\ntheorem card_distinct_factors_eq_card_factors_iff_squarefree {n : ℕ} (h0 : n ≠ 0) :\n    (card_distinct_factors) n = (card_factors) n ↔ Squarefree n :=\n  by\n  rw [squarefree_iff_nodup_factors h0, card_distinct_factors_apply]\n  constructor <;> intro h\n  · rw [← n.factors.dedup_sublist.eq_of_length h]\n    apply List.nodup_dedup\n  · rw [h.dedup]\n    rfl\n#align card_distinct_factors_eq_card_factors_iff_squarefree card_distinct_factors_eq_card_factors_iff_squarefree\n\n",
 "card_distinct_factors_apply_prime_pow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `card_distinct_factors -/\n@[simp]\ntheorem card_distinct_factors_apply_prime_pow {p k : ℕ} (hp : p.prime) (hk : k ≠ 0) :\n    (card_distinct_factors) (p ^ k) = 1 := by\n  rw [card_distinct_factors_apply, hp.factors_pow, List.replicate_dedup hk, List.length_singleton]\n#align card_distinct_factors_apply_prime_pow card_distinct_factors_apply_prime_pow\n\n",
 "card_distinct_factors_apply_prime":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `card_distinct_factors -/\n@[simp]\ntheorem card_distinct_factors_apply_prime {p : ℕ} (hp : p.prime) : (card_distinct_factors) p = 1 := by\n  rw [← pow_one p, card_distinct_factors_apply_prime_pow hp one_ne_zero]\n#align card_distinct_factors_apply_prime card_distinct_factors_apply_prime\n\n",
 "card_distinct_factors_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `card_distinct_factors -/\ntheorem card_distinct_factors_apply {n : ℕ} : (card_distinct_factors) n = n.factors.dedup.length :=\n  rfl\n#align card_distinct_factors_apply card_distinct_factors_apply\n\n",
 "add_apply":
 "@[simp]\ntheorem add_apply {f g : arithmetic_function R} {n : ℕ} : (f + g) n = f n + g n :=\n  rfl\n#align add_apply add_apply\n\n"}