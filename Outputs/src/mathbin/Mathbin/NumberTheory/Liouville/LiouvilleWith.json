{"sub_rat_iff":
 "@[simp]\ntheorem sub_rat_iff : liouville_with p (x - r) ↔ liouville_with p x := by\n  rw [sub_eq_add_neg, ← Rat.cast_neg, add_rat_iff]\n#align sub_rat_iff sub_rat_iff\n\n",
 "sub_rat":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\ntheorem sub_rat (h : liouville_with p x) (r : exprℚ) : liouville_with p (x - r) :=\n  sub_rat_iff.2 h\n#align sub_rat sub_rat\n\n",
 "sub_nat_iff":
 "@[simp]\ntheorem sub_nat_iff : liouville_with p (x - n) ↔ liouville_with p x := by rw [← Rat.cast_coe_nat, sub_rat_iff]\n#align sub_nat_iff sub_nat_iff\n\n",
 "sub_nat":
 "theorem sub_nat (h : liouville_with p x) (n : ℕ) : liouville_with p (x - n) :=\n  sub_nat_iff.2 h\n#align sub_nat sub_nat\n\n",
 "sub_int_iff":
 "@[simp]\ntheorem sub_int_iff : liouville_with p (x - m) ↔ liouville_with p x := by rw [← Rat.cast_coe_int, sub_rat_iff]\n#align sub_int_iff sub_int_iff\n\n",
 "sub_int":
 "theorem sub_int (h : liouville_with p x) (m : ℤ) : liouville_with p (x - m) :=\n  sub_int_iff.2 h\n#align sub_int sub_int\n\n",
 "rat_sub_iff":
 "@[simp]\ntheorem rat_sub_iff : liouville_with p (r - x) ↔ liouville_with p x := by simp [sub_eq_add_neg]\n#align rat_sub_iff rat_sub_iff\n\n",
 "rat_sub":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\ntheorem rat_sub (h : liouville_with p x) (r : exprℚ) : liouville_with p (r - x) :=\n  rat_sub_iff.2 h\n#align rat_sub rat_sub\n\n",
 "rat_mul_iff":
 "/-- The product `r * x`, `r : ℚ`, `r ≠ 0`, is a Liouville number with exponent `p` if and only if\n`x` satisfies the same condition. -/\ntheorem rat_mul_iff (hr : r ≠ 0) : liouville_with p (r * x) ↔ liouville_with p x := by rw [mul_comm, mul_rat_iff hr]\n#align rat_mul_iff rat_mul_iff\n\n",
 "rat_mul":
 "theorem rat_mul (h : liouville_with p x) (hr : r ≠ 0) : liouville_with p (r * x) :=\n  (rat_mul_iff hr).2 h\n#align rat_mul rat_mul\n\n",
 "rat_add_iff":
 "@[simp]\ntheorem rat_add_iff : liouville_with p (r + x) ↔ liouville_with p x := by rw [add_comm, add_rat_iff]\n#align rat_add_iff rat_add_iff\n\n",
 "rat_add":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\ntheorem rat_add (h : liouville_with p x) (r : exprℚ) : liouville_with p (r + x) :=\n  add_comm x r ▸ h.add_rat r\n#align rat_add rat_add\n\n",
 "neg_iff":
 "@[simp]\ntheorem neg_iff : liouville_with p (-x) ↔ liouville_with p x :=\n  ⟨fun h => neg_neg x ▸ h.neg, liouville_with.neg⟩\n#align neg_iff neg_iff\n\n",
 "neg":
 "protected theorem neg (h : liouville_with p x) : liouville_with p (-x) :=\n  by\n  rcases h with ⟨C, hC⟩\n  refine' ⟨C, hC.mono _⟩\n  rintro n ⟨m, hne, hlt⟩\n  use -m; simp [neg_div, abs_sub_comm _ x, *]\n#align neg neg\n\n",
 "ne_cast_int":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem ne_cast_int (h : liouville_with p x) (hp : 1 < p) (m : ℤ) : x ≠ m :=\n  by\n  rintro rfl\n  rename' m => M\n  rcases((eventually_gt_at_top 0).and_frequently (h.frequently_lt_rpow_neg hp)).exists with\n    ⟨n : ℕ, hn : 0 < n, m : ℤ, hne : (M : exprℝ) ≠ m / n, hlt : |(M - m / n : exprℝ)| < n ^ (-1 : exprℝ)⟩\n  refine' hlt.not_le _\n  have hn' : (0 : exprℝ) < n := by simpa\n  rw [rpow_neg_one, ← one_div, sub_div' _ _ _ hn'.ne', abs_div, nat.abs_cast, div_le_div_right hn']\n  norm_cast\n  rw [← zero_add (1 : ℤ), int.add_one_le_iff, abs_pos, sub_ne_zero]\n  rw [ne.def, eq_div_iff hn'.ne'] at hne\n  exact_mod_cast hne\n#align ne_cast_int ne_cast_int\n\n",
 "nat_sub_iff":
 "@[simp]\ntheorem nat_sub_iff : liouville_with p (n - x) ↔ liouville_with p x := by simp [sub_eq_add_neg]\n#align nat_sub_iff nat_sub_iff\n\n",
 "nat_sub":
 "theorem nat_sub (h : liouville_with p x) (n : ℕ) : liouville_with p (n - x) :=\n  nat_sub_iff.2 h\n#align nat_sub nat_sub\n\n",
 "nat_mul_iff":
 "theorem nat_mul_iff (hn : n ≠ 0) : liouville_with p (n * x) ↔ liouville_with p x := by rw [mul_comm, mul_nat_iff hn]\n#align nat_mul_iff nat_mul_iff\n\n",
 "nat_mul":
 "theorem nat_mul (h : liouville_with p x) (hn : n ≠ 0) : liouville_with p (n * x) :=\n  by\n  rw [mul_comm]\n  exact h.mul_nat hn\n#align nat_mul nat_mul\n\n",
 "nat_add_iff":
 "@[simp]\ntheorem nat_add_iff : liouville_with p (n + x) ↔ liouville_with p x := by rw [add_comm, add_nat_iff]\n#align nat_add_iff nat_add_iff\n\n",
 "nat_add":
 "theorem nat_add (h : liouville_with p x) (n : ℕ) : liouville_with p (n + x) :=\n  h.int_add n\n#align nat_add nat_add\n\n",
 "mul_rat_iff":
 "/-- The product `x * r`, `r : ℚ`, `r ≠ 0`, is a Liouville number with exponent `p` if and only if\n`x` satisfies the same condition. -/\ntheorem mul_rat_iff (hr : r ≠ 0) : liouville_with p (x * r) ↔ liouville_with p x :=\n  ⟨fun h => by\n    simpa only [mul_assoc, ← Rat.cast_mul, mul_inv_cancel hr, Rat.cast_one, mul_one] using h.mul_rat (inv_ne_zero hr),\n    fun h => h.mul_rat hr⟩\n#align mul_rat_iff mul_rat_iff\n\n",
 "mul_rat":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- The product of a Liouville number and a nonzero rational number is again a Liouville number.  -/\ntheorem mul_rat (h : liouville_with p x) (hr : r ≠ 0) : liouville_with p (x * r) :=\n  by\n  rcases h.exists_pos with ⟨C, hC₀, hC⟩\n  refine' ⟨r.denom ^ p * (|r| * C), (tendsto_id.nsmul_at_top r.pos).frequently (hC.mono _)⟩\n  rintro n ⟨hn, m, hne, hlt⟩\n  have A : (↑(r.num * m) : exprℝ) / ↑(«expr • » r.denom (id n)) = m / n * r := by\n    simp [← div_mul_div_comm, ← r.cast_def, mul_comm]\n  refine' ⟨r.num * m, _, _⟩\n  · rw [A]\n    simp [hne, hr]\n  · rw [A, ← sub_mul, abs_mul]\n    simp only [smul_eq_mul, id.def, nat.cast_mul]\n    refine' (mul_lt_mul_of_pos_right hlt <| abs_pos.2 <| Rat.cast_ne_zero.2 hr).trans_le _\n    rw [mul_rpow, mul_div_mul_left, mul_comm, mul_div_assoc]\n    exacts[(rpow_pos_of_pos (nat.cast_pos.2 r.pos) _).ne', nat.cast_nonneg _, nat.cast_nonneg _]\n#align mul_rat mul_rat\n\n",
 "mul_nat_iff":
 "theorem mul_nat_iff (hn : n ≠ 0) : liouville_with p (x * n) ↔ liouville_with p x := by\n  rw [← Rat.cast_coe_nat, mul_rat_iff (Nat.cast_ne_zero.2 hn)]\n#align mul_nat_iff mul_nat_iff\n\n",
 "mul_nat":
 "theorem mul_nat (h : liouville_with p x) (hn : n ≠ 0) : liouville_with p (x * n) :=\n  (mul_nat_iff hn).2 h\n#align mul_nat mul_nat\n\n",
 "mul_int_iff":
 "theorem mul_int_iff (hm : m ≠ 0) : liouville_with p (x * m) ↔ liouville_with p x := by\n  rw [← Rat.cast_coe_int, mul_rat_iff (Int.cast_ne_zero.2 hm)]\n#align mul_int_iff mul_int_iff\n\n",
 "mul_int":
 "theorem mul_int (h : liouville_with p x) (hm : m ≠ 0) : liouville_with p (x * m) :=\n  (mul_int_iff hm).2 h\n#align mul_int mul_int\n\n",
 "mono":
 "/-- If a number is Liouville with exponent `p`, then it is Liouville with any smaller exponent. -/\ntheorem mono (h : liouville_with p x) (hle : q ≤ p) : liouville_with q x :=\n  by\n  rcases h.exists_pos with ⟨C, hC₀, hC⟩\n  refine' ⟨C, hC.mono _⟩; rintro n ⟨hn, m, hne, hlt⟩\n  refine' ⟨m, hne, hlt.trans_le <| div_le_div_of_le_left hC₀.le _ _⟩\n  exacts[rpow_pos_of_pos (nat.cast_pos.2 hn) _, rpow_le_rpow_of_exponent_le (nat.one_le_cast.2 hn) hle]\n#align mono mono\n\n",
 "liouville_with_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⌊ ⌋» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⌊ ⌋» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-\nCopyright (c) 2021 Yury G. Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury G. Kudryashov\n-/\n/-- For `p = 1` (hence, for any `p ≤ 1`), the condition `liouville_with p x` is trivial. -/\ntheorem liouville_with_one (x : exprℝ) : liouville_with 1 x :=\n  by\n  use 2\n  refine' ((eventually_gt_at_top 0).mono fun n hn => _).frequently\n  have hn' : (0 : exprℝ) < n := by simpa\n  have : x < ↑(«expr⌊ ⌋» (x * ↑n) + 1) / ↑n :=\n    by\n    rw [lt_div_iff hn', Int.cast_add, Int.cast_one]\n    exact Int.lt_floor_add_one _\n  refine' ⟨«expr⌊ ⌋» (x * n) + 1, this.ne, _⟩\n  rw [abs_sub_comm, abs_of_pos (sub_pos.2 this), rpow_one, sub_lt_iff_lt_add', add_div_eq_mul_add_div _ _ hn'.ne',\n    div_lt_div_right hn']\n  simpa [bit0, ← add_assoc] using (Int.floor_le (x * n)).trans_lt (lt_add_one _)\n#align liouville_with_one liouville_with_one\n\n",
 "liouville_with":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⌈ ⌉₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⌈ ⌉₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- A Liouville number is a Liouville number with any real exponent. -/\nprotected theorem liouville_with (hx : liouville x) (p : exprℝ) : liouville_with p x :=\n  by\n  suffices : liouville_with («expr⌈ ⌉₊» p) x; exact this.mono (Nat.le_ceil p)\n  refine' ⟨1, ((eventually_gt_at_top 1).and_frequently (hx.frequently_exists_num («expr⌈ ⌉₊» p))).mono _⟩\n  rintro b ⟨hb, a, hne, hlt⟩\n  refine' ⟨a, hne, _⟩\n  rwa [rpow_nat_cast]\n#align liouville_with liouville_with\n\n",
 "irrational":
 "/-- A number satisfying the Liouville condition with exponent `p > 1` is an irrational number. -/\nprotected theorem irrational (h : liouville_with p x) (hp : 1 < p) : irrational x :=\n  by\n  rintro ⟨r, rfl⟩\n  rcases eq_or_ne r 0 with (rfl | h0)\n  · refine' h.ne_cast_int hp 0 _\n    rw [Rat.cast_zero, Int.cast_zero]\n  · refine' (h.mul_rat (inv_ne_zero h0)).ne_cast_int hp 1 _\n    simp [Rat.cast_ne_zero.2 h0]\n#align irrational irrational\n\n",
 "int_sub_iff":
 "@[simp]\ntheorem int_sub_iff : liouville_with p (m - x) ↔ liouville_with p x := by simp [sub_eq_add_neg]\n#align int_sub_iff int_sub_iff\n\n",
 "int_sub":
 "theorem int_sub (h : liouville_with p x) (m : ℤ) : liouville_with p (m - x) :=\n  int_sub_iff.2 h\n#align int_sub int_sub\n\n",
 "int_mul_iff":
 "theorem int_mul_iff (hm : m ≠ 0) : liouville_with p (m * x) ↔ liouville_with p x := by rw [mul_comm, mul_int_iff hm]\n#align int_mul_iff int_mul_iff\n\n",
 "int_mul":
 "theorem int_mul (h : liouville_with p x) (hm : m ≠ 0) : liouville_with p (m * x) :=\n  (int_mul_iff hm).2 h\n#align int_mul int_mul\n\n",
 "int_add_iff":
 "@[simp]\ntheorem int_add_iff : liouville_with p (m + x) ↔ liouville_with p x := by rw [add_comm, add_int_iff]\n#align int_add_iff int_add_iff\n\n",
 "int_add":
 "theorem int_add (h : liouville_with p x) (m : ℤ) : liouville_with p (m + x) :=\n  int_add_iff.2 h\n#align int_add int_add\n\n",
 "frequently_lt_rpow_neg":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , » -/\n/-- If `x` satisfies Liouville condition with exponent `p` and `q < p`, then `x`\nsatisfies Liouville condition with exponent `q` and constant `1`. -/\ntheorem frequently_lt_rpow_neg (h : liouville_with p x) (hlt : q < p) :\n    «expr∃ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , »\" at_top\n      (∃ m : ℤ, x ≠ m / n ∧ |x - m / n| < n ^ (-q)) :=\n  by\n  rcases h.exists_pos with ⟨C, hC₀, hC⟩\n  have :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" at_top\n      (C < n ^ (p - q)) :=\n    by\n    simpa only [(· ∘ ·), neg_sub, one_div] using\n      ((tendsto_rpow_at_top (sub_pos.2 hlt)).comp tendsto_coe_nat_at_top_at_top).eventually (eventually_gt_at_top C)\n  refine' (this.and_frequently hC).mono _\n  rintro n ⟨hnC, hn, m, hne, hlt⟩\n  replace hn : (0 : exprℝ) < n := nat.cast_pos.2 hn\n  refine' ⟨m, hne, hlt.trans <| (div_lt_iff <| rpow_pos_of_pos hn _).2 _⟩\n  rwa [mul_comm, ← rpow_add hn, ← sub_eq_add_neg]\n#align frequently_lt_rpow_neg frequently_lt_rpow_neg\n\n",
 "frequently_exists_num":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , » -/\n/-- If `x` is a Liouville number, then for any `n`, for infinitely many denominators `b` there\nexists a numerator `a` such that `x ≠ a / b` and `|x - a / b| < 1 / b ^ n`. -/\ntheorem frequently_exists_num (hx : liouville x) (n : ℕ) :\n    «expr∃ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , »\" at_top\n      (∃ a : ℤ, x ≠ a / b ∧ |x - a / b| < 1 / b ^ n) :=\n  by\n  refine' not_not.1 fun H => _\n  simp only [liouville, not_forall, not_exists, not_frequently, not_and, not_lt, eventually_at_top] at H\n  rcases H with ⟨N, hN⟩\n  have :\n    ∀ b > (1 : ℕ),\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" at_top\n        (∀ a : ℤ, (1 / b ^ m : exprℝ) ≤ |x - a / b|) :=\n    by\n    intro b hb\n    replace hb : (1 : exprℝ) < b := nat.one_lt_cast.2 hb\n    have H : tendsto (fun m => 1 / b ^ m : ℕ → exprℝ) at_top ((nhds) 0) :=\n      by\n      simp only [one_div]\n      exact tendsto_inv_at_top_zero.comp (tendsto_pow_at_top_at_top_of_one_lt hb)\n    refine' (H.eventually (hx.irrational.eventually_forall_le_dist_cast_div b)).mono _\n    exact fun m hm a => hm a\n  have :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" at_top\n      (∀ b < N, 1 < b → ∀ a : ℤ, (1 / b ^ m : exprℝ) ≤ |x - a / b|) :=\n    (finite_lt_nat N).eventually_all.2 fun b hb => eventually_imp_distrib_left.2 (this b)\n  rcases(this.and (eventually_ge_at_top n)).exists with ⟨m, hm, hnm⟩\n  rcases hx m with ⟨a, b, hb, hne, hlt⟩\n  lift b to ℕ using zero_le_one.trans hb.le\n  norm_cast  at hb\n  push_cast at hne hlt\n  cases le_or_lt N b\n  · refine' (hN b h a hne).not_lt (hlt.trans_le _)\n    replace hb : (1 : exprℝ) < b := nat.one_lt_cast.2 hb\n    have hb0 : (0 : exprℝ) < b := zero_lt_one.trans hb\n    exact one_div_le_one_div_of_le (pow_pos hb0 _) (pow_le_pow hb.le hnm)\n  · exact (hm b h hb _).not_lt hlt\n#align frequently_exists_num frequently_exists_num\n\n",
 "forall_liouville_with_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- A number satisfies the Liouville condition with any exponent if and only if it is a Liouville\nnumber. -/\ntheorem forall_liouville_with_iff {x : exprℝ} : (∀ p, liouville_with p x) ↔ liouville x :=\n  by\n  refine' ⟨fun H n => _, liouville.liouville_with⟩\n  rcases((eventually_gt_at_top 1).and_frequently ((H (n + 1)).frequently_lt_rpow_neg (lt_add_one n))).exists with\n    ⟨b, hb, a, hne, hlt⟩\n  exact ⟨a, b, by exact_mod_cast hb, hne, by simpa [rpow_neg] using hlt⟩\n#align forall_liouville_with_iff forall_liouville_with_iff\n\n",
 "exists_pos":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , » -/\n/-- The constant `C` provided by the definition of `liouville_with` can be made positive.\nWe also add `1 ≤ n` to the list of assumptions about the denominator. While it is equivalent to\nthe original statement, the case `n = 0` breaks many arguments. -/\ntheorem exists_pos (h : liouville_with p x) :\n    ∃ (C : exprℝ)(h₀ : 0 < C),\n      «expr∃ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , »\" at_top\n        (1 ≤ n ∧ ∃ m : ℤ, x ≠ m / n ∧ |x - m / n| < C / n ^ p) :=\n  by\n  rcases h with ⟨C, hC⟩\n  refine' ⟨max C 1, zero_lt_one.trans_le <| le_max_right _ _, _⟩\n  refine' ((eventually_ge_at_top 1).and_frequently hC).mono _\n  rintro n ⟨hle, m, hne, hlt⟩\n  refine' ⟨hle, m, hne, hlt.trans_le _⟩\n  exact div_le_div_of_le (rpow_nonneg_of_nonneg n.cast_nonneg _) (le_max_left _ _)\n#align exists_pos exists_pos\n\n",
 "add_rat_iff":
 "@[simp]\ntheorem add_rat_iff : liouville_with p (x + r) ↔ liouville_with p x :=\n  ⟨fun h => by simpa using h.add_rat (-r), fun h => h.add_rat r⟩\n#align add_rat_iff add_rat_iff\n\n",
 "add_rat":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\ntheorem add_rat (h : liouville_with p x) (r : exprℚ) : liouville_with p (x + r) :=\n  by\n  rcases h.exists_pos with ⟨C, hC₀, hC⟩\n  refine' ⟨r.denom ^ p * C, (tendsto_id.nsmul_at_top r.pos).frequently (hC.mono _)⟩\n  rintro n ⟨hn, m, hne, hlt⟩\n  have hr : (0 : exprℝ) < r.denom := nat.cast_pos.2 r.pos\n  have hn' : (n : exprℝ) ≠ 0 := Nat.cast_ne_zero.2 (zero_lt_one.trans_le hn).ne'\n  have : (↑(r.denom * m + r.num * n : ℤ) / ↑(«expr • » r.denom (id n)) : exprℝ) = m / n + r := by\n    simp [add_div, hr.ne', mul_div_mul_left, mul_div_mul_right, hn', ← Rat.cast_def]\n  refine' ⟨r.denom * m + r.num * n, _⟩\n  rw [this, add_sub_add_right_eq_sub]\n  refine' ⟨by simpa, hlt.trans_le (le_of_eq _)⟩\n  have : (r.denom ^ p : exprℝ) ≠ 0 := (rpow_pos_of_pos hr _).ne'\n  simp [mul_rpow, nat.cast_nonneg, mul_div_mul_left, this]\n#align add_rat add_rat\n\n",
 "add_nat_iff":
 "@[simp]\ntheorem add_nat_iff : liouville_with p (x + n) ↔ liouville_with p x := by rw [← Rat.cast_coe_nat n, add_rat_iff]\n#align add_nat_iff add_nat_iff\n\n",
 "add_nat":
 "theorem add_nat (h : liouville_with p x) (n : ℕ) : liouville_with p (x + n) :=\n  h.add_int n\n#align add_nat add_nat\n\n",
 "add_int_iff":
 "@[simp]\ntheorem add_int_iff : liouville_with p (x + m) ↔ liouville_with p x := by rw [← Rat.cast_coe_int m, add_rat_iff]\n#align add_int_iff add_int_iff\n\n",
 "add_int":
 "theorem add_int (h : liouville_with p x) (m : ℤ) : liouville_with p (x + m) :=\n  add_int_iff.2 h\n#align add_int add_int\n\n"}