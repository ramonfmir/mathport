{"set_of_liouville_eq_irrational_inter_Inter_Union":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\ntheorem set_of_liouville_eq_irrational_inter_Inter_Union :\n    { x | liouville x } =\n      { x | irrational x } ∩\n        «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\"\n          («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n            (ball (a / b) (1 / b ^ n))) :=\n  by\n  refine' subset.antisymm _ _\n  · refine' subset_inter (fun x hx => hx.irrational) _\n    rw [set_of_liouville_eq_Inter_Union]\n    exact Inter_mono fun n => Union₂_mono fun a b => Union_mono fun hb => diff_subset _ _\n  · simp only [inter_Inter, inter_Union, set_of_liouville_eq_Inter_Union]\n    refine' Inter_mono fun n => Union₂_mono fun a b => Union_mono fun hb => _\n    rw [inter_comm]\n    refine' diff_subset_diff subset.rfl (singleton_subset_iff.2 ⟨a / b, _⟩)\n    norm_cast\n#align set_of_liouville_eq_irrational_inter_Inter_Union set_of_liouville_eq_irrational_inter_Inter_Union\n\n",
 "set_of_liouville_eq_Inter_Union":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/-\nCopyright (c) 2021 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-/\ntheorem set_of_liouville_eq_Inter_Union :\n    { x | liouville x } =\n      «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\"\n        («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n          (ball (a / b) (1 / b ^ n) \\ {a / b})) :=\n  by\n  ext x\n  simp only [mem_Inter, mem_Union, liouville, mem_set_of_eq, exists_prop, mem_diff, mem_singleton_iff, mem_ball,\n    real.dist_eq, and_comm']\n#align set_of_liouville_eq_Inter_Union set_of_liouville_eq_Inter_Union\n\n",
 "is_Gδ_set_of_liouville":
 "theorem is_Gδ_set_of_liouville : is_Gδ { x | liouville x } :=\n  by\n  rw [set_of_liouville_eq_Inter_Union]\n  refine' is_Gδ_Inter fun n => is_open.is_Gδ _\n  refine' is_open_Union fun a => is_open_Union fun b => is_open_Union fun hb => _\n  exact is_open_ball.inter is_closed_singleton.is_open_compl\n#align is_Gδ_set_of_liouville is_Gδ_set_of_liouville\n\n",
 "eventually_residual_liouville":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- The set of Liouville numbers is a residual set. -/\ntheorem eventually_residual_liouville :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\"\n      (residual (exprℝ)) (liouville x) :=\n  by\n  rw [filter.eventually, set_of_liouville_eq_irrational_inter_Inter_Union]\n  refine' eventually_residual_irrational.and _\n  refine' eventually_residual.2 ⟨_, _, rat.dense_embedding_coe_real.dense.mono _, subset.rfl⟩\n  ·\n    exact\n      is_Gδ_Inter fun n =>\n        is_open.is_Gδ <| is_open_Union fun a => is_open_Union fun b => is_open_Union fun hb => is_open_ball\n  · rintro _ ⟨r, rfl⟩\n    simp only [mem_Inter, mem_Union]\n    refine' fun n => ⟨r.num * 2, r.denom * 2, _, _⟩\n    · have := Int.ofNat_le.2 r.pos\n      rw [Int.ofNat_one] at this\n      linarith\n    · convert mem_ball_self _ using 2\n      · push_cast\n        norm_cast\n        norm_num\n      · refine' one_div_pos.2 (pow_pos (Int.cast_pos.2 _) _)\n        exact mul_pos (Int.coe_nat_pos.2 r.pos) zero_lt_two\n#align eventually_residual_liouville eventually_residual_liouville\n\n",
 "dense_liouville":
 "/-- The set of Liouville numbers in dense. -/\ntheorem dense_liouville : dense { x | liouville x } :=\n  dense_of_mem_residual eventually_residual_liouville\n#align dense_liouville dense_liouville\n\n"}