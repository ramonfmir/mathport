{"transcendental":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- **Liouville's Theorem** -/\ntheorem transcendental {x : exprℝ} (lx : liouville x) : transcendental ℤ x :=\n  by\n  -- Proceed by contradiction: if `x` is algebraic, then `x` is the root (`ef0`) of a\n  -- non-zero (`f0`) polynomial `f`\n  rintro ⟨f : polynomial ℤ, f0, ef0⟩\n  -- Change `aeval x f = 0` to `eval (map _ f) = 0`, who knew.\n  replace ef0 : (f.map (algebraMap ℤ (exprℝ))).eval x = 0;\n  · rwa [aeval_def, ← eval_map] at ef0\n  -- There is a \"large\" real number `A` such that `(b + 1) ^ (deg f) * |f (x - a / (b + 1))| * A`\n  -- is at least one.  This is obtained from lemma `exists_pos_real_of_irrational_root`.\n  obtain ⟨A, hA, h⟩ :\n    ∃ A : exprℝ, 0 < A ∧ ∀ (a : ℤ) (b : ℕ), (1 : exprℝ) ≤ (b + 1) ^ f.nat_degree * (|x - a / (b + 1)| * A) :=\n    exists_pos_real_of_irrational_root lx.irrational f0 ef0\n  -- Since the real numbers are Archimedean, a power of `2` exceeds `A`: `hn : A < 2 ^ r`.\n  rcases pow_unbounded_of_one_lt A (lt_add_one 1) with ⟨r, hn⟩\n  -- Use the Liouville property, with exponent `r +  deg f`.\n  obtain ⟨a, b, b1, -, a1⟩ : ∃ a b : ℤ, 1 < b ∧ x ≠ a / b ∧ |x - a / b| < 1 / b ^ (r + f.nat_degree) :=\n    lx (r + f.nat_degree)\n  have b0 : (0 : exprℝ) < b :=\n    zero_lt_one.trans\n      (by\n        rw [← Int.cast_one]\n        exact int.cast_lt.mpr b1)\n  -- Prove that `b ^ f.nat_degree * abs (x - a / b)` is strictly smaller than itself\n  -- recall, this is a proof by contradiction!\n  refine' lt_irrefl ((b : exprℝ) ^ f.nat_degree * |x - ↑a / ↑b|) _\n  -- clear denominators at `a1`\n  rw [lt_div_iff' (pow_pos b0 _), pow_add, mul_assoc] at a1\n  -- split the inequality via `1 / A`.\n  refine' (_ : (b : exprℝ) ^ f.nat_degree * |x - a / b| < 1 / A).trans_le _\n  -- This branch of the proof uses the Liouville condition and the Archimedean property\n  · refine' (lt_div_iff' hA).mpr _\n    refine' lt_of_le_of_lt _ a1\n    refine' mul_le_mul_of_nonneg_right _ (mul_nonneg (pow_nonneg b0.le _) (abs_nonneg _))\n    refine' hn.le.trans _\n    refine' pow_le_pow_of_le_left zero_le_two _ _\n    exact int.cast_two.symm.le.trans (int.cast_le.mpr (int.add_one_le_iff.mpr b1))\n  -- this branch of the proof exploits the \"integrality\" of evaluations of polynomials\n  -- at ratios of integers.\n  · lift b to ℕ using zero_le_one.trans b1.le\n    specialize h a b.pred\n    rwa [← Nat.cast_succ, nat.succ_pred_eq_of_pos (zero_lt_one.trans _), ← mul_assoc, ← div_le_iff hA] at h\n    exact int.coe_nat_lt.mp b1\n#align transcendental transcendental\n\n",
 "irrational":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-\nCopyright (c) 2020 Jujian Zhang. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Damiano Testa, Jujian Zhang\n-/\n@[protected]\ntheorem irrational {x : exprℝ} (h : liouville x) : irrational x :=\n  by\n  -- By contradiction, `x = a / b`, with `a ∈ ℤ`, `0 < b ∈ ℕ` is a Liouville number,\n  rintro ⟨⟨a, b, bN0, cop⟩, rfl⟩\n  -- clear up the mess of constructions of rationals\n  rw [Rat.cast_mk', ← div_eq_mul_inv] at h\n  -- Since `a / b` is a Liouville number, there are `p, q ∈ ℤ`, with `q1 : 1 < q`,\n  -- `a0 : a / b ≠ p / q` and `a1 : |a / b - p / q| < 1 / q ^ (b + 1)`\n  rcases h (b + 1) with ⟨p, q, q1, a0, a1⟩\n  -- A few useful inequalities\n  have qR0 : (0 : exprℝ) < q := int.cast_pos.mpr (zero_lt_one.trans q1)\n  have b0 : (b : exprℝ) ≠ 0 := ne_of_gt (nat.cast_pos.mpr bN0)\n  have bq0 : (0 : exprℝ) < b * q := mul_pos (nat.cast_pos.mpr bN0) qR0\n  -- At a1, clear denominators...\n  replace a1 : |a * q - b * p| * q ^ (b + 1) < b * q;\n  ·\n    rwa [div_sub_div _ _ b0 (ne_of_gt qR0), abs_div, div_lt_div_iff (abs_pos.mpr (ne_of_gt bq0)) (pow_pos qR0 _),\n      abs_of_pos bq0, one_mul,\n      ←-- ... and revert to integers\n      Int.cast_pow,\n      ← Int.cast_mul, ← Int.cast_ofNat, ← Int.cast_mul, ← Int.cast_mul, ← Int.cast_sub, ← Int.cast_abs, ← Int.cast_mul,\n      Int.cast_lt] at a1\n  -- At a0, clear denominators...\n  replace a0 : ¬a * q - ↑b * p = 0;\n  ·\n    rwa [ne.def, div_eq_div_iff b0 (ne_of_gt qR0), mul_comm ↑p, ← sub_eq_zero,\n      ←-- ... and revert to integers\n      Int.cast_ofNat,\n      ← Int.cast_mul, ← Int.cast_mul, ← Int.cast_sub, Int.cast_eq_zero] at a0\n  -- Actually, `q` is a natural number\n  lift q to ℕ using (zero_lt_one.trans q1).le\n  -- Looks innocuous, but we now have an integer with non-zero absolute value: this is at\n  -- least one away from zero.  The gain here is what gets the proof going.\n  have ap : 0 < |a * ↑q - ↑b * p| := abs_pos.mpr a0\n  -- Actually, the absolute value of an integer is a natural number\n  lift |a * ↑q - ↑b * p| to ℕ using abs_nonneg (a * ↑q - ↑b * p)\n  -- At a1, revert to natural numbers\n  rw [← Int.ofNat_mul, ← Int.coe_nat_pow, ← Int.ofNat_mul, Int.ofNat_lt] at a1\n  -- Recall this is by contradiction: we obtained the inequality `b * q ≤ x * q ^ (b + 1)`, so\n  -- we are done.\n  exact not_le.mpr a1 (Nat.mul_lt_mul_pow_succ (int.coe_nat_pos.mp ap) (int.coe_nat_lt.mp q1)).le\n#align irrational irrational\n\n",
 "exists_pos_real_of_irrational_root":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem exists_pos_real_of_irrational_root {α : exprℝ} (ha : irrational α) {f : polynomial ℤ} (f0 : f ≠ 0)\n    (fa : eval α (map (algebraMap ℤ (exprℝ)) f) = 0) :\n    ∃ A : exprℝ, 0 < A ∧ ∀ a : ℤ, ∀ b : ℕ, (1 : exprℝ) ≤ (b + 1) ^ f.nat_degree * (|α - a / (b + 1)| * A) :=\n  by\n  -- `fR` is `f` viewed as a polynomial with `ℝ` coefficients.\n  set fR : polynomial (exprℝ) := map (algebraMap ℤ (exprℝ)) f\n  -- `fR` is non-zero, since `f` is non-zero.\n  obtain fR0 : fR ≠ 0 := fun fR0 =>\n    (map_injective (algebraMap ℤ (exprℝ)) fun _ _ A => int.cast_inj.mp A).ne f0 (fR0.trans (Polynomial.map_zero _).symm)\n  -- reformulating assumption `fa`: `α` is a root of `fR`.\n  have ar : α ∈ (fR.roots.to_finset : Set (exprℝ)) :=\n    finset.mem_coe.mpr (multiset.mem_to_finset.mpr ((mem_roots fR0).mpr (is_root.def.mpr fa)))\n  -- Since the polynomial `fR` has finitely many roots, there is a closed interval centered at `α`\n  -- such that `α` is the only root of `fR` in the interval.\n  obtain ⟨ζ, z0, U⟩ : ∃ ζ > 0, closed_ball α ζ ∩ fR.roots.to_finset = {α} :=\n    @exists_closed_ball_inter_eq_singleton_of_discrete _ _ _ discrete_of_t1_of_finite _ ar\n  -- Since `fR` is continuous, it is bounded on the interval above.\n  obtain ⟨xm, -, hM⟩ :\n    ∃ (xm : exprℝ)(H : xm ∈ Icc (α - ζ) (α + ζ)),\n      ∀ y : exprℝ, y ∈ Icc (α - ζ) (α + ζ) → |fR.derivative.eval y| ≤ |fR.derivative.eval xm| :=\n    IsCompact.exists_forall_ge is_compact_Icc ⟨α, (sub_lt_self α z0).le, (lt_add_of_pos_right α z0).le⟩\n      (continuous_abs.comp fR.derivative.continuous_aeval).continuous_on\n  -- Use the key lemma `exists_one_le_pow_mul_dist`: we are left to show that ...\n  refine'\n    @exists_one_le_pow_mul_dist ℤ ℕ (exprℝ) _ _ _ (fun y => fR.eval y) α ζ (|fR.derivative.eval xm|) _ z0\n      (fun y hy => _) fun z a hq => _\n  -- 1: the denominators are positive -- essentially by definition;\n  · exact fun a => one_le_pow_of_one_le ((le_add_iff_nonneg_left 1).mpr a.cast_nonneg) _\n  -- 2: the polynomial `fR` is Lipschitz at `α` -- as its derivative continuous;\n  · rw [mul_comm]\n    rw [Real.closedBall_eq_Icc] at hy\n    -- apply the Mean Value Theorem: the bound on the derivative comes from differentiability.\n    refine'\n      convex.norm_image_sub_le_of_norm_deriv_le (fun _ _ => fR.differentiable_at)\n        (fun y h => by\n          rw [fR.deriv]\n          exact hM _ h)\n        (convex_Icc _ _) hy (mem_Icc_iff_abs_le.mp _)\n    exact @mem_closed_ball_self (exprℝ) _ α ζ (le_of_lt z0)\n  -- 3: the weird inequality of Liouville type with powers of the denominators.\n  · show 1 ≤ (a + 1 : exprℝ) ^ f.nat_degree * |eval α fR - eval (z / (a + 1)) fR|\n    rw [fa, zero_sub, abs_neg]\n    rw [show (a + 1 : exprℝ) = ((a + 1 : ℕ) : ℤ) by norm_cast] at hq⊢\n    -- key observation: the right-hand side of the inequality is an *integer*.  Therefore,\n    -- if its absolute value is not at least one, then it vanishes.  Proceed by contradiction\n    refine' one_le_pow_mul_abs_eval_div (Int.coe_nat_succ_pos a) fun hy => _\n    -- As the evaluation of the polynomial vanishes, we found a root of `fR` that is rational.\n    -- We know that `α` is the only root of `fR` in our interval, and `α` is irrational:\n    -- follow your nose.\n    refine' (irrational_iff_ne_rational α).mp ha z (a + 1) (mem_singleton_iff.mp _).symm\n    refine' U.subset _\n    refine' ⟨hq, finset.mem_coe.mp (multiset.mem_to_finset.mpr _)⟩\n    exact (mem_roots fR0).mpr (is_root.def.mpr hy)\n#align exists_pos_real_of_irrational_root exists_pos_real_of_irrational_root\n\n",
 "exists_one_le_pow_mul_dist":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- Let `Z, N` be types, let `R` be a metric space, let `α : R` be a point and let\n`j : Z → N → R` be a function.  We aim to estimate how close we can get to `α`, while staying\nin the image of `j`.  The points `j z a` of `R` in the image of `j` come with a \"cost\" equal to\n`d a`.  As we get closer to `α` while staying in the image of `j`, we are interested in bounding\nthe quantity `d a * dist α (j z a)` from below by a strictly positive amount `1 / A`: the intuition\nis that approximating well `α` with the points in the image of `j` should come at a high cost.  The\nhypotheses on the function `f : R → R` provide us with sufficient conditions to ensure our goal.\nThe first hypothesis is that `f` is Lipschitz at `α`: this yields a bound on the distance.\nThe second hypothesis is specific to the Liouville argument and provides the missing bound\ninvolving the cost function `d`.\n\nThis lemma collects the properties used in the proof of `exists_pos_real_of_irrational_root`.\nIt is stated in more general form than needed: in the intended application, `Z = ℤ`, `N = ℕ`,\n`R = ℝ`, `d a = (a + 1) ^ f.nat_degree`, `j z a  = z / (a + 1)`, `f ∈ ℤ[x]`, `α` is an irrational\nroot of `f`, `ε` is small, `M` is a bound on the Lipschitz constant of `f` near `α`, `n` is\nthe degree of the polynomial `f`.\n-/\ntheorem exists_one_le_pow_mul_dist {Z N R : Type _} [PseudoMetricSpace R] {d : N → exprℝ} {j : Z → N → R} {f : R → R}\n    {α : R} {ε M : exprℝ}\n    -- denominators are positive\n    (d0 : ∀ a : N, 1 ≤ d a)\n    (e0 : 0 < ε)\n    -- function is Lipschitz at α\n    (B : ∀ ⦃y : R⦄, y ∈ closedBall α ε → dist (f α) (f y) ≤ dist α y * M)\n    -- clear denominators\n    (L : ∀ ⦃z : Z⦄, ∀ ⦃a : N⦄, j z a ∈ closedBall α ε → 1 ≤ d a * dist (f α) (f (j z a))) :\n    ∃ A : exprℝ, 0 < A ∧ ∀ z : Z, ∀ a : N, 1 ≤ d a * (dist α (j z a) * A) :=\n  by\n  -- A useful inequality to keep at hand\n  have me0 : 0 < max (1 / ε) M := lt_max_iff.mpr (or.inl (one_div_pos.mpr e0))\n  -- The maximum between `1 / ε` and `M` works\n  refine' ⟨max (1 / ε) M, me0, fun z a => _⟩\n  -- First, let's deal with the easy case in which we are far away from `α`\n  by_cases dm1 : 1 ≤ dist α (j z a) * max (1 / ε) M\n  · exact one_le_mul_of_one_le_of_one_le (d0 a) dm1\n  · -- `j z a = z / (a + 1)`: we prove that this ratio is close to `α`\n    have : j z a ∈ closed_ball α ε :=\n      by\n      refine' mem_closed_ball'.mp (le_trans _ ((one_div_le me0 e0).mpr (le_max_left _ _)))\n      exact (le_div_iff me0).mpr (not_le.mp dm1).le\n    -- use the \"separation from `1`\" (assumption `L`) for numerators,\n    refine' (L this).trans _\n    -- remove a common factor and use the Lipschitz assumption `B`\n    refine' mul_le_mul_of_nonneg_left ((B this).trans _) (zero_le_one.trans (d0 a))\n    exact mul_le_mul_of_nonneg_left (le_max_right _ M) dist_nonneg\n#align exists_one_le_pow_mul_dist exists_one_le_pow_mul_dist\n\n"}