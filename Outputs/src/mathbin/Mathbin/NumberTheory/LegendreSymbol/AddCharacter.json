{"zmod_char_primitive_of_primitive_root":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ+» -/\n/-- The additive character on `zmod n` associated to a primitive `n`th root of unity\nis primitive -/\ntheorem zmod_char_primitive_of_primitive_root (n : «exprℕ+») {ζ : C} (h : is_primitive_root ζ n) :\n    is_primitive (zmod_char n ((is_primitive_root.iff_def ζ n).mp h).left) :=\n  by\n  apply zmod_char_primitive_of_eq_one_only_at_zero\n  intro a ha\n  rw [zmod_char_apply, ← pow_zero ζ] at ha\n  exact (ZMod.val_eq_zero a).mp (is_primitive_root.pow_inj h (ZMod.val_lt a) n.pos ha)\n#align zmod_char_primitive_of_primitive_root zmod_char_primitive_of_primitive_root\n\n",
 "zmod_char_primitive_of_eq_one_only_at_zero":
 "/-- The converse: if the additive character takes the value `1` only at `0`,\nthen it is primitive. -/\ntheorem zmod_char_primitive_of_eq_one_only_at_zero (n : ℕ) (ψ : add_char (ZMod n) C) (hψ : ∀ a, ψ a = 1 → a = 0) :\n    is_primitive ψ := by\n  refine' fun a ha => (is_nontrivial_iff_ne_trivial _).mpr fun hf => _\n  have h : mul_shift ψ a 1 = (1 : add_char (ZMod n) C) (1 : ZMod n) := congr_fun (congr_arg coe_fn hf) 1\n  rw [mul_shift_apply, mul_one, MonoidHom.one_apply] at h\n  exact ha (hψ a h)\n#align zmod_char_primitive_of_eq_one_only_at_zero zmod_char_primitive_of_eq_one_only_at_zero\n\n",
 "zmod_char_is_nontrivial_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ+» -/\n/-- An additive character on `zmod n` is nontrivial iff it takes a value `≠ 1` on `1`. -/\ntheorem zmod_char_is_nontrivial_iff (n : «exprℕ+») (ψ : add_char (ZMod n) C) : is_nontrivial ψ ↔ ψ 1 ≠ 1 :=\n  by\n  refine' ⟨_, fun h => ⟨1, h⟩⟩\n  contrapose!\n  rintro h₁ ⟨a, ha⟩\n  have ha₁ : a = «expr • » a.val 1 := by\n    rw [nsmul_eq_mul, mul_one]\n    exact (ZMod.nat_cast_zmod_val a).symm\n  rw [ha₁, map_nsmul_pow, h₁, one_pow] at ha\n  exact ha rfl\n#align zmod_char_is_nontrivial_iff zmod_char_is_nontrivial_iff\n\n",
 "zmod_char_eq_one_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ+» -/\n/-- A primitive additive character on `zmod n` takes the value `1` only at `0`. -/\ntheorem is_primitive.zmod_char_eq_one_iff (n : «exprℕ+») {ψ : add_char (ZMod n) C} (hψ : is_primitive ψ) (a : ZMod n) :\n    ψ a = 1 ↔ a = 0 :=\n  by\n  refine' ⟨fun h => not_imp_comm.mp (hψ a) _, fun ha => by rw [ha, map_zero_one]⟩\n  rw [zmod_char_is_nontrivial_iff n (mul_shift ψ a), mul_shift_apply, mul_one, h, Classical.not_not]\n#align is_primitive.zmod_char_eq_one_iff is_primitive.zmod_char_eq_one_iff\n\n",
 "zmod_char_apply'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ+» -/\ntheorem zmod_char_apply' {n : «exprℕ+»} {ζ : C} (hζ : ζ ^ ↑n = 1) (a : ℕ) : zmod_char n hζ a = ζ ^ a := by\n  rw [pow_eq_pow_mod a hζ, zmod_char_apply, ZMod.val_nat_cast a]\n#align zmod_char_apply' zmod_char_apply'\n\n",
 "zmod_char_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ+» -/\n-- can't prove that they always exist\n-- so we can write simply `to_add`, which we need here again\n/-- The additive character on `zmod n` defined using `ζ` sends `a` to `ζ^a`. -/\ntheorem zmod_char_apply {n : «exprℕ+»} {ζ : C} (hζ : ζ ^ ↑n = 1) (a : ZMod n) : zmod_char n hζ a = ζ ^ a.val :=\n  rfl\n#align zmod_char_apply zmod_char_apply\n\n",
 "to_mul_shift_inj_of_is_primitive":
 "/-- The map associating to `a : R` the multiplicative shift of `ψ` by `a`\nis injective when `ψ` is primitive. -/\ntheorem to_mul_shift_inj_of_is_primitive {ψ : add_char R R'} (hψ : is_primitive ψ) : function.injective ψ.mul_shift :=\n  by\n  intro a b h\n  apply_fun fun x => x * mul_shift ψ (-b)  at h\n  simp only [mul_shift_mul, mul_shift_zero, add_right_neg] at h\n  have h₂ := hψ (a + -b)\n  rw [h, is_nontrivial_iff_ne_trivial, ← sub_eq_add_neg, sub_ne_zero] at h₂\n  exact not_not.mp fun h => h₂ h rfl\n#align to_mul_shift_inj_of_is_primitive to_mul_shift_inj_of_is_primitive\n\n",
 "sum_mul_shift":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/-- The sum over the values of `mul_shift ψ b` for `ψ` primitive is zero when `b ≠ 0`\nand `#R` otherwise. -/\ntheorem sum_mul_shift [DecidableEq R] [IsDomain R'] {ψ : add_char R R'} (b : R) (hψ : is_primitive ψ) :\n    finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n        (ψ (x * b)) =\n      if b = 0 then Fintype.card R else 0 :=\n  by\n  split_ifs with h\n  · -- case `b = 0`\n    simp only [h, MulZeroClass.mul_zero, map_zero_one, Finset.sum_const, Nat.smul_one_eq_coe]\n    rfl\n  · -- case `b ≠ 0`\n    simp_rw [mul_comm]\n    exact sum_eq_zero_of_is_nontrivial (hψ b h)\n#align sum_mul_shift sum_mul_shift\n\n",
 "sum_eq_zero_of_is_nontrivial":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/-- The sum over the values of a nontrivial additive character vanishes if the target ring\nis a domain. -/\ntheorem sum_eq_zero_of_is_nontrivial [IsDomain R'] {ψ : add_char R R'} (hψ : is_nontrivial ψ) :\n    finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\" (ψ a) =\n      0 :=\n  by\n  rcases hψ with ⟨b, hb⟩\n  have h₁ :\n    finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n        (ψ (b + a)) =\n      finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\" (ψ a) :=\n    Fintype.sum_bijective _ (AddGroup.addLeft_bijective b) _ _ fun x => rfl\n  simp_rw [map_add_mul] at h₁\n  have h₂ :\n    finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\" (ψ a) =\n      finset.univ.sum («expr⇑ » ψ) :=\n    rfl\n  rw [← Finset.mul_sum, h₂] at h₁\n  exact eq_zero_of_mul_eq_self_left hb h₁\n#align sum_eq_zero_of_is_nontrivial sum_eq_zero_of_is_nontrivial\n\n",
 "sum_eq_card_of_is_trivial":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/-- The sum over the values of the trivial additive character is the cardinality of the source. -/\ntheorem sum_eq_card_of_is_trivial {ψ : add_char R R'} (hψ : ¬is_nontrivial ψ) :\n    finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\" (ψ a) =\n      Fintype.card R :=\n  by\n  simp only [is_nontrivial] at hψ\n  push_neg  at hψ\n  simp only [hψ, Finset.sum_const, Nat.smul_one_eq_coe]\n  rfl\n#align sum_eq_card_of_is_trivial sum_eq_card_of_is_trivial\n\n",
 "pow_mul_shift":
 "/-- If `n` is a natural number, then `ψ ^ n = mul_shift ψ n`. -/\ntheorem pow_mul_shift (ψ : add_char R R') (n : ℕ) : ψ ^ n = mul_shift ψ n :=\n  by\n  ext x\n  rw [show (ψ ^ n) x = ψ x ^ n from rfl, ← mul_shift_spec']\n#align pow_mul_shift pow_mul_shift\n\n",
 "mul_shift_zero":
 "/-- `mul_shift ψ 0` is the trivial character. -/\n@[simp]\ntheorem mul_shift_zero (ψ : add_char R R') : mul_shift ψ 0 = 1 :=\n  by\n  ext\n  simp only [mul_shift_apply, MulZeroClass.zero_mul, map_zero_one, MonoidHom.one_apply]\n#align mul_shift_zero mul_shift_zero\n\n",
 "mul_shift_spec'":
 "/-- If `n` is a natural number, then `mul_shift ψ n x = (ψ x) ^ n`. -/\ntheorem mul_shift_spec' (ψ : add_char R R') (n : ℕ) (x : R) : mul_shift ψ n x = ψ x ^ n := by\n  rw [mul_shift_apply, ← nsmul_eq_mul, map_nsmul_pow]\n#align mul_shift_spec' mul_shift_spec'\n\n",
 "mul_shift_mul":
 "/-- The product of `mul_shift ψ a` and `mul_shift ψ b` is `mul_shift ψ (a + b)`. -/\ntheorem mul_shift_mul (ψ : add_char R R') (a b : R) : mul_shift ψ a * mul_shift ψ b = mul_shift ψ (a + b) :=\n  by\n  ext\n  simp only [right_distrib, MonoidHom.mul_apply, mul_shift_apply, map_add_mul]\n#align mul_shift_mul mul_shift_mul\n\n",
 "mul_shift_apply":
 "@[simp]\ntheorem mul_shift_apply {ψ : add_char R R'} {a : R} {x : R} : mul_shift ψ a x = ψ (a * x) :=\n  rfl\n#align mul_shift_apply mul_shift_apply\n\n",
 "map_zsmul_zpow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- An additive character maps multiples by integers to powers. -/\n@[simp]\ntheorem map_zsmul_zpow {R' : Type v} [CommGroup R'] (ψ : add_char R R') (n : ℤ) (x : R) : ψ («expr • » n x) = ψ x ^ n :=\n  by rw [coe_to_fun_apply, coe_to_fun_apply _ x, ofAdd_zsmul, map_zpow]\n#align map_zsmul_zpow map_zsmul_zpow\n\n",
 "map_zero_one":
 "/-- An additive character maps `0` to `1`. -/\n@[simp]\ntheorem map_zero_one (ψ : add_char R R') : ψ 0 = 1 := by rw [coe_to_fun_apply, ofAdd_zero, map_one]\n#align map_zero_one map_zero_one\n\n",
 "map_nsmul_pow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- An additive character maps multiples by natural numbers to powers. -/\n@[simp]\ntheorem map_nsmul_pow (ψ : add_char R R') (n : ℕ) (x : R) : ψ («expr • » n x) = ψ x ^ n := by\n  rw [coe_to_fun_apply, coe_to_fun_apply _ x, ofAdd_nsmul, map_pow]\n#align map_nsmul_pow map_nsmul_pow\n\n",
 "map_add_mul":
 "/-- An additive character maps sums to products. -/\n@[simp]\ntheorem map_add_mul (ψ : add_char R R') (x y : R) : ψ (x + y) = ψ x * ψ y := by\n  rw [coe_to_fun_apply, coe_to_fun_apply _ x, coe_to_fun_apply _ y, ofAdd_add, map_mul]\n#align map_add_mul map_add_mul\n\n",
 "is_primitive":
 "-- `add_comm_group.equiv_direct_sum_zmod_of_fintype`\n-- gives the structure theorem for finite abelian groups.\n-- This could be used to show that the map above is a bijection.\n-- We leave this for a later occasion.\n/-- When `R` is a field `F`, then a nontrivial additive character is primitive -/\ntheorem is_nontrivial.is_primitive {F : Type u} [Field F] {ψ : add_char F R'} (hψ : is_nontrivial ψ) : is_primitive ψ :=\n  by\n  intro a ha\n  cases' hψ with x h\n  use a⁻¹ * x\n  rwa [mul_shift_apply, mul_inv_cancel_left₀ ha]\n#align is_nontrivial.is_primitive is_nontrivial.is_primitive\n\n",
 "is_nontrivial_iff_ne_trivial":
 "-- The domain and target of our additive characters. Now we restrict to rings on both sides.\n/-- An additive character is nontrivial iff it is not the trivial character. -/\ntheorem is_nontrivial_iff_ne_trivial (ψ : add_char R R') : is_nontrivial ψ ↔ ψ ≠ 1 :=\n  by\n  refine' not_forall.symm.trans (Iff.not _)\n  rw [FunLike.ext_iff]\n  rfl\n#align is_nontrivial_iff_ne_trivial is_nontrivial_iff_ne_trivial\n\n",
 "inv_mul_shift":
 "/-- `ψ⁻¹ = mul_shift ψ (-1))`. -/\ntheorem inv_mul_shift (ψ : add_char R R') : ψ⁻¹ = mul_shift ψ (-1) :=\n  by\n  ext\n  rw [inv_apply, mul_shift_apply, neg_mul, one_mul]\n#align inv_mul_shift inv_mul_shift\n\n",
 "inv_apply":
 "theorem inv_apply (ψ : add_char R R') (x : R) : ψ⁻¹ x = ψ (-x) :=\n  rfl\n#align inv_apply inv_apply\n\n",
 "coe_to_fun_apply":
 "/-\nCopyright (c) 2022 Michael Stoll. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Michael Stoll\n-/\n-- The domain of our additive characters\n-- The target\ntheorem coe_to_fun_apply (ψ : add_char R R') (a : R) : ψ a = ψ.to_monoid_hom (ofAdd a) :=\n  rfl\n#align coe_to_fun_apply coe_to_fun_apply\n\n"}