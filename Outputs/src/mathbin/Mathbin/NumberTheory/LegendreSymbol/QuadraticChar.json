{"quadratic_char_zero":
 "@[simp]\ntheorem quadratic_char_zero : quadratic_char F 0 = 0 := by simp only [quadratic_char_apply, quadratic_char_fun_zero]\n#align quadratic_char_zero quadratic_char_zero\n\n",
 "quadratic_char_two":
 "/-- The value of the quadratic character at `2` -/\ntheorem quadratic_char_two [DecidableEq F] (hF : ringChar F ≠ 2) : quadratic_char F 2 = χ₈ (Fintype.card F) :=\n  is_quadratic.eq_of_eq_coe (quadratic_char_is_quadratic F) is_quadratic_χ₈ hF\n    ((quadratic_char_eq_pow_of_char_ne_two' hF 2).trans (finite_field.two_pow_card hF))\n#align quadratic_char_two quadratic_char_two\n\n",
 "quadratic_char_sum_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/-- The sum over the values of the quadratic character is zero when the characteristic is odd. -/\ntheorem quadratic_char_sum_zero (hF : ringChar F ≠ 2) :\n    finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n        (quadratic_char F a) =\n      0 :=\n  is_nontrivial.sum_eq_zero (quadratic_char_is_nontrivial hF)\n#align quadratic_char_sum_zero quadratic_char_sum_zero\n\n",
 "quadratic_char_sq_one'":
 "/-- The quadratic character takes the value `1` on nonzero squares. -/\ntheorem quadratic_char_sq_one' {a : F} (ha : a ≠ 0) : quadratic_char F (a ^ 2) = 1 := by\n  simp only [quadratic_char_fun, ha, pow_eq_zero_iff, Nat.succ_pos', IsSquare_sq, if_true, if_false,\n    quadratic_char_apply]\n#align quadratic_char_sq_one' quadratic_char_sq_one'\n\n",
 "quadratic_char_sq_one":
 "/-- The square of the quadratic character on nonzero arguments is `1`. -/\ntheorem quadratic_char_sq_one {a : F} (ha : a ≠ 0) : quadratic_char F a ^ 2 = 1 := by\n  rwa [pow_two, ← map_mul, ← pow_two, quadratic_char_sq_one']\n#align quadratic_char_sq_one quadratic_char_sq_one\n\n",
 "quadratic_char_one_iff_is_square":
 "/-- For nonzero `a : F`, `quadratic_char F a = 1 ↔ is_square a`. -/\ntheorem quadratic_char_one_iff_is_square {a : F} (ha : a ≠ 0) : quadratic_char F a = 1 ↔ IsSquare a := by\n  simp only [quadratic_char_apply, quadratic_char_fun, ha, (by decide : (-1 : ℤ) ≠ 1), if_false, ite_eq_left_iff,\n    imp_false, Classical.not_not]\n#align quadratic_char_one_iff_is_square quadratic_char_one_iff_is_square\n\n",
 "quadratic_char_odd_prime":
 "/-- The value of the quadratic character at an odd prime `p` different from `ring_char F`. -/\ntheorem quadratic_char_odd_prime [DecidableEq F] (hF : ringChar F ≠ 2) {p : ℕ} [Fact p.prime] (hp₁ : p ≠ 2)\n    (hp₂ : ringChar F ≠ p) : quadratic_char F p = quadratic_char (ZMod p) (χ₄ (Fintype.card F) * Fintype.card F) :=\n  by\n  rw [← quadratic_char_neg_one hF]\n  have h :=\n    quadratic_char_card_card hF (ne_of_eq_of_ne (ring_char_zmod_n p) hp₁) (ne_of_eq_of_ne (ring_char_zmod_n p) hp₂.symm)\n  rwa [card p] at h\n#align quadratic_char_odd_prime quadratic_char_odd_prime\n\n",
 "quadratic_char_neg_two":
 "/-- The value of the quadratic character at `-2` -/\ntheorem quadratic_char_neg_two [DecidableEq F] (hF : ringChar F ≠ 2) : quadratic_char F (-2) = χ₈' (Fintype.card F) :=\n  by\n  rw [(by norm_num : (-2 : F) = -1 * 2), map_mul, χ₈'_eq_χ₄_mul_χ₈, quadratic_char_neg_one hF, quadratic_char_two hF,\n    @cast_nat_cast _ (ZMod 4) _ _ _ (by norm_num : 4 ∣ 8)]\n#align quadratic_char_neg_two quadratic_char_neg_two\n\n",
 "quadratic_char_neg_one_iff_not_is_square":
 "/-- For `a : F`, `quadratic_char F a = -1 ↔ ¬ is_square a`. -/\ntheorem quadratic_char_neg_one_iff_not_is_square {a : F} : quadratic_char F a = -1 ↔ ¬IsSquare a :=\n  by\n  by_cases ha : a = 0\n  · simp only [ha, isSquare_zero, mul_char.map_zero, zero_eq_neg, one_ne_zero, not_true]\n  · rw [quadratic_char_eq_neg_one_iff_not_one ha, quadratic_char_one_iff_is_square ha]\n#align quadratic_char_neg_one_iff_not_is_square quadratic_char_neg_one_iff_not_is_square\n\n",
 "quadratic_char_neg_one":
 "/-- The value of the quadratic character at `-1` -/\ntheorem quadratic_char_neg_one [DecidableEq F] (hF : ringChar F ≠ 2) : quadratic_char F (-1) = χ₄ (Fintype.card F) :=\n  by\n  have h := quadratic_char_eq_pow_of_char_ne_two hF (neg_ne_zero.mpr one_ne_zero)\n  rw [h, χ₄_eq_neg_one_pow (finite_field.odd_card_of_char_ne_two hF)]\n  set n := Fintype.card F / 2\n  cases' Nat.even_or_odd n with h₂ h₂\n  · simp only [Even.neg_one_pow h₂, eq_self_iff_true, if_true]\n  · simp only [Odd.neg_one_pow h₂, ite_eq_right_iff]\n    exact fun hf => false.rec (1 = -1) (Ring.neg_one_ne_one_of_char_ne_two hF hf)\n#align quadratic_char_neg_one quadratic_char_neg_one\n\n",
 "quadratic_char_is_quadratic":
 "/-- The quadratic character is quadratic as a multiplicative character. -/\ntheorem quadratic_char_is_quadratic : (quadratic_char F).is_quadratic :=\n  by\n  intro a\n  by_cases ha : a = 0\n  · left\n    rw [ha]\n    exact quadratic_char_zero\n  · right\n    exact quadratic_char_dichotomy ha\n#align quadratic_char_is_quadratic quadratic_char_is_quadratic\n\n",
 "quadratic_char_is_nontrivial":
 "/-- The quadratic character is nontrivial as a multiplicative character\nwhen the domain has odd characteristic. -/\ntheorem quadratic_char_is_nontrivial (hF : ringChar F ≠ 2) : (quadratic_char F).is_nontrivial :=\n  by\n  rcases quadratic_char_exists_neg_one hF with ⟨a, ha⟩\n  have hu : IsUnit a := by\n    by_contra hf\n    rw [map_nonunit _ hf] at ha\n    norm_num at ha\n  refine' ⟨hu.unit, (_ : quadratic_char F a ≠ 1)⟩\n  rw [ha]\n  norm_num\n#align quadratic_char_is_nontrivial quadratic_char_is_nontrivial\n\n",
 "quadratic_char_fun_zero":
 "@[simp]\ntheorem quadratic_char_fun_zero : quadratic_char_fun F 0 = 0 := by\n  simp only [quadratic_char_fun, eq_self_iff_true, if_true, id.def]\n#align quadratic_char_fun_zero quadratic_char_fun_zero\n\n",
 "quadratic_char_fun_one":
 "@[simp]\ntheorem quadratic_char_fun_one : quadratic_char_fun F 1 = 1 := by\n  simp only [quadratic_char_fun, one_ne_zero, isSquare_one, if_true, if_false, id.def]\n#align quadratic_char_fun_one quadratic_char_fun_one\n\n",
 "quadratic_char_fun_mul":
 "/-- The quadratic character is multiplicative. -/\ntheorem quadratic_char_fun_mul (a b : F) :\n    quadratic_char_fun F (a * b) = quadratic_char_fun F a * quadratic_char_fun F b :=\n  by\n  by_cases ha : a = 0\n  · rw [ha, MulZeroClass.zero_mul, quadratic_char_fun_zero, MulZeroClass.zero_mul]\n  -- now `a ≠ 0`\n  by_cases hb : b = 0\n  · rw [hb, MulZeroClass.mul_zero, quadratic_char_fun_zero, MulZeroClass.mul_zero]\n  -- now `a ≠ 0` and `b ≠ 0`\n  have hab := mul_ne_zero ha hb\n  by_cases hF : ringChar F = 2\n  ·-- case `ring_char F = 2`\n    rw [quadratic_char_fun_eq_one_of_char_two hF ha, quadratic_char_fun_eq_one_of_char_two hF hb,\n      quadratic_char_fun_eq_one_of_char_two hF hab, mul_one]\n  · -- case of odd characteristic\n    rw [quadratic_char_fun_eq_pow_of_char_ne_two hF ha, quadratic_char_fun_eq_pow_of_char_ne_two hF hb,\n      quadratic_char_fun_eq_pow_of_char_ne_two hF hab, mul_pow]\n    cases' finite_field.pow_dichotomy hF hb with hb' hb'\n    · simp only [hb', mul_one, eq_self_iff_true, if_true]\n    · have h := Ring.neg_one_ne_one_of_char_ne_two hF\n      -- `-1 ≠ 1`\n      simp only [hb', h, mul_neg, mul_one, if_false, ite_mul, neg_mul]\n      cases' finite_field.pow_dichotomy hF ha with ha' ha' <;>\n        simp only [ha', h, neg_neg, eq_self_iff_true, if_true, if_false]\n#align quadratic_char_fun_mul quadratic_char_fun_mul\n\n",
 "quadratic_char_fun_eq_zero_iff":
 "/-\nCopyright (c) 2022 Michael Stoll. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Michael Stoll\n-/\n/-- Some basic API lemmas -/\ntheorem quadratic_char_fun_eq_zero_iff {a : F} : quadratic_char_fun F a = 0 ↔ a = 0 :=\n  by\n  simp only [quadratic_char_fun]\n  by_cases ha : a = 0\n  · simp only [ha, eq_self_iff_true, if_true]\n  · simp only [ha, if_false, iff_false_iff]\n    split_ifs <;> simp only [neg_eq_zero, one_ne_zero, not_false_iff]\n#align quadratic_char_fun_eq_zero_iff quadratic_char_fun_eq_zero_iff\n\n",
 "quadratic_char_fun_eq_pow_of_char_ne_two":
 "/-- If `ring_char F` is odd, then `quadratic_char_fun F a` can be computed in\nterms of `a ^ (fintype.card F / 2)`. -/\ntheorem quadratic_char_fun_eq_pow_of_char_ne_two (hF : ringChar F ≠ 2) {a : F} (ha : a ≠ 0) :\n    quadratic_char_fun F a = if a ^ (Fintype.card F / 2) = 1 then 1 else -1 :=\n  by\n  simp only [quadratic_char_fun, ha, if_false]\n  simp_rw [finite_field.is_square_iff hF ha]\n#align quadratic_char_fun_eq_pow_of_char_ne_two quadratic_char_fun_eq_pow_of_char_ne_two\n\n",
 "quadratic_char_fun_eq_one_of_char_two":
 "/-- If `ring_char F = 2`, then `quadratic_char_fun F` takes the value `1` on nonzero elements. -/\ntheorem quadratic_char_fun_eq_one_of_char_two (hF : ringChar F = 2) {a : F} (ha : a ≠ 0) : quadratic_char_fun F a = 1 :=\n  by\n  simp only [quadratic_char_fun, ha, if_false, ite_eq_left_iff]\n  exact fun h => false.rec _ (h (finite_field.is_square_of_char_two hF a))\n#align quadratic_char_fun_eq_one_of_char_two quadratic_char_fun_eq_one_of_char_two\n\n",
 "quadratic_char_exists_neg_one":
 "/-- If `F` has odd characteristic, then `quadratic_char F` takes the value `-1`. -/\ntheorem quadratic_char_exists_neg_one (hF : ringChar F ≠ 2) : ∃ a, quadratic_char F a = -1 :=\n  (finite_field.exists_nonsquare hF).imp fun b h₁ => quadratic_char_neg_one_iff_not_is_square.mpr h₁\n#align quadratic_char_exists_neg_one quadratic_char_exists_neg_one\n\n",
 "quadratic_char_eq_zero_iff":
 "/-- The value of the quadratic character on `a` is zero iff `a = 0`. -/\ntheorem quadratic_char_eq_zero_iff {a : F} : quadratic_char F a = 0 ↔ a = 0 :=\n  quadratic_char_fun_eq_zero_iff\n#align quadratic_char_eq_zero_iff quadratic_char_eq_zero_iff\n\n",
 "quadratic_char_eq_pow_of_char_ne_two'":
 "theorem quadratic_char_eq_pow_of_char_ne_two' (hF : ringChar F ≠ 2) (a : F) :\n    (quadratic_char F a : F) = a ^ (Fintype.card F / 2) :=\n  by\n  by_cases ha : a = 0\n  · have : 0 < Fintype.card F / 2 := Nat.div_pos Fintype.one_lt_card two_pos\n    simp only [ha, zero_pow this, quadratic_char_apply, quadratic_char_zero, Int.cast_zero]\n  · rw [quadratic_char_eq_pow_of_char_ne_two hF ha]\n    by_cases ha' : a ^ (Fintype.card F / 2) = 1\n    · simp only [ha', eq_self_iff_true, if_true, Int.cast_one]\n    · have ha'' := or.resolve_left (finite_field.pow_dichotomy hF ha) ha'\n      simp only [ha'', Int.cast_ite, Int.cast_one, Int.cast_neg, ite_eq_right_iff]\n      exact Eq.symm\n#align quadratic_char_eq_pow_of_char_ne_two' quadratic_char_eq_pow_of_char_ne_two'\n\n",
 "quadratic_char_eq_pow_of_char_ne_two":
 "/-- If `ring_char F` is odd, then `quadratic_char F a` can be computed in\nterms of `a ^ (fintype.card F / 2)`. -/\ntheorem quadratic_char_eq_pow_of_char_ne_two (hF : ringChar F ≠ 2) {a : F} (ha : a ≠ 0) :\n    quadratic_char F a = if a ^ (Fintype.card F / 2) = 1 then 1 else -1 :=\n  quadratic_char_fun_eq_pow_of_char_ne_two hF ha\n#align quadratic_char_eq_pow_of_char_ne_two quadratic_char_eq_pow_of_char_ne_two\n\n",
 "quadratic_char_eq_one_of_char_two":
 "/-- If `ring_char F = 2`, then `quadratic_char F` takes the value `1` on nonzero elements. -/\ntheorem quadratic_char_eq_one_of_char_two (hF : ringChar F = 2) {a : F} (ha : a ≠ 0) : quadratic_char F a = 1 :=\n  quadratic_char_fun_eq_one_of_char_two hF ha\n#align quadratic_char_eq_one_of_char_two quadratic_char_eq_one_of_char_two\n\n",
 "quadratic_char_eq_neg_one_iff_not_one":
 "/-- The quadratic character is `1` or `-1` on nonzero arguments. -/\ntheorem quadratic_char_eq_neg_one_iff_not_one {a : F} (ha : a ≠ 0) :\n    quadratic_char F a = -1 ↔ ¬quadratic_char F a = 1 :=\n  by\n  refine' ⟨fun h => _, fun h₂ => (or_iff_right h₂).mp (quadratic_char_dichotomy ha)⟩\n  rw [h]\n  norm_num\n#align quadratic_char_eq_neg_one_iff_not_one quadratic_char_eq_neg_one_iff_not_one\n\n",
 "quadratic_char_dichotomy":
 "/-- The quadratic character is `1` or `-1` on nonzero arguments. -/\ntheorem quadratic_char_dichotomy {a : F} (ha : a ≠ 0) : quadratic_char F a = 1 ∨ quadratic_char F a = -1 :=\n  sq_eq_one_iff.1 <| quadratic_char_sq_one ha\n#align quadratic_char_dichotomy quadratic_char_dichotomy\n\n",
 "quadratic_char_card_sqrts":
 "/-- The number of solutions to `x^2 = a` is determined by the quadratic character. -/\ntheorem quadratic_char_card_sqrts (hF : ringChar F ≠ 2) (a : F) :\n    ↑{ x : F | x ^ 2 = a }.to_finset.card = quadratic_char F a + 1 :=\n  by\n  -- we consider the cases `a = 0`, `a` is a nonzero square and `a` is a nonsquare in turn\n  by_cases h₀ : a = 0\n  ·\n    simp only [h₀, pow_eq_zero_iff, Nat.succ_pos', Int.ofNat_succ, Int.ofNat_zero, mul_char.map_zero,\n      Set.setOf_eq_eq_singleton, Set.toFinset_card, Set.card_singleton]\n  · set s := { x : F | x ^ 2 = a }.to_finset with hs\n    by_cases h : IsSquare a\n    · rw [(quadratic_char_one_iff_is_square h₀).mpr h]\n      rcases h with ⟨b, h⟩\n      rw [h, mul_self_eq_zero] at h₀\n      have h₁ : s = [b, -b].to_finset := by\n        ext x\n        simp only [Finset.mem_filter, Finset.mem_univ, true_and_iff, List.toFinset_cons, List.toFinset_nil,\n          insert_emptyc_eq, Finset.mem_insert, Finset.mem_singleton]\n        rw [← pow_two] at h\n        simp only [hs, Set.mem_toFinset, Set.mem_setOf_eq, h]\n        constructor\n        · exact eq_or_eq_neg_of_sq_eq_sq _ _\n        · rintro (h₂ | h₂) <;> rw [h₂]\n          simp only [neg_sq]\n      norm_cast\n      rw [h₁, List.toFinset_cons, List.toFinset_cons, List.toFinset_nil]\n      exact Finset.card_doubleton (ne.symm (mt (Ring.eq_self_iff_eq_zero_of_char_ne_two hF).mp h₀))\n    · rw [quadratic_char_neg_one_iff_not_is_square.mpr h]\n      simp only [Int.coe_nat_eq_zero, Finset.card_eq_zero, Set.toFinset_card, Fintype.card_ofFinset, Set.mem_setOf_eq,\n        add_left_neg]\n      ext x\n      simp only [iff_false_iff, Finset.mem_filter, Finset.mem_univ, true_and_iff, Finset.not_mem_empty]\n      rw [isSquare_iff_exists_sq] at h\n      exact fun h' => h ⟨_, h'.symm⟩\n#align quadratic_char_card_sqrts quadratic_char_card_sqrts\n\n",
 "quadratic_char_card_card":
 "/-- The relation between the values of the quadratic character of one field `F` at the\ncardinality of another field `F'` and of the quadratic character of `F'` at the cardinality\nof `F`. -/\ntheorem quadratic_char_card_card [DecidableEq F] (hF : ringChar F ≠ 2) {F' : Type _} [Field F'] [Fintype F']\n    [DecidableEq F'] (hF' : ringChar F' ≠ 2) (h : ringChar F' ≠ ringChar F) :\n    quadratic_char F (Fintype.card F') = quadratic_char F' (quadratic_char F (-1) * Fintype.card F) :=\n  by\n  let χ := (quadratic_char F).ring_hom_comp (algebraMap ℤ F')\n  have hχ₁ : χ.is_nontrivial := by\n    obtain ⟨a, ha⟩ := quadratic_char_exists_neg_one hF\n    have hu : IsUnit a := by\n      contrapose ha\n      exact ne_of_eq_of_ne (map_nonunit (quadratic_char F) ha) (mt zero_eq_neg.mp one_ne_zero)\n    use hu.unit\n    simp only [IsUnit.unit_spec, ring_hom_comp_apply, eq_intCast, ne.def, ha]\n    rw [Int.cast_neg, Int.cast_one]\n    exact Ring.neg_one_ne_one_of_char_ne_two hF'\n  have hχ₂ : χ.is_quadratic := is_quadratic.comp (quadratic_char_is_quadratic F) _\n  have h := char.card_pow_card hχ₁ hχ₂ h hF'\n  rw [← quadratic_char_eq_pow_of_char_ne_two' hF'] at h\n  exact (is_quadratic.eq_of_eq_coe (quadratic_char_is_quadratic F') (quadratic_char_is_quadratic F) hF' h).symm\n#align quadratic_char_card_card quadratic_char_card_card\n\n",
 "is_square_two_iff":
 "/-- `2` is a square in `F` iff `#F` is not congruent to `3` or `5` mod `8`. -/\ntheorem finite_field.is_square_two_iff : IsSquare (2 : F) ↔ Fintype.card F % 8 ≠ 3 ∧ Fintype.card F % 8 ≠ 5 := by\n  classical\n    by_cases hF : ringChar F = 2\n    focus\n      have h := finite_field.even_card_of_char_two hF\n      simp only [finite_field.is_square_of_char_two hF, true_iff_iff]\n    rotate_left\n    focus\n      have h := finite_field.odd_card_of_char_ne_two hF\n      rw [← quadratic_char_one_iff_is_square (Ring.two_ne_zero hF), quadratic_char_two hF, χ₈_nat_eq_if_mod_eight]\n      simp only [h, nat.one_ne_zero, if_false, ite_eq_left_iff, ne.def, (by decide : (-1 : ℤ) ≠ 1), imp_false,\n        Classical.not_not]\n    all_goals\n      rw [← Nat.mod_mod_of_dvd _ (by norm_num : 2 ∣ 8)] at h\n      have h₁ := nat.mod_lt (Fintype.card F) (by decide : 0 < 8)\n      revert h₁ h\n      generalize Fintype.card F % 8 = n\n      decide!\n#align finite_field.is_square_two_iff finite_field.is_square_two_iff\n\n",
 "is_square_odd_prime_iff":
 "/-- An odd prime `p` is a square in `F` iff the quadratic character of `zmod p` does not\ntake the value `-1` on `χ₄(#F) * #F`. -/\ntheorem finite_field.is_square_odd_prime_iff (hF : ringChar F ≠ 2) {p : ℕ} [Fact p.prime] (hp : p ≠ 2) :\n    IsSquare (p : F) ↔ quadratic_char (ZMod p) (χ₄ (Fintype.card F) * Fintype.card F) ≠ -1 := by\n  classical\n    by_cases hFp : ringChar F = p\n    · rw [show (p : F) = 0 by\n          rw [← hFp]\n          exact ringChar.Nat.cast_ringChar]\n      simp only [isSquare_zero, ne.def, true_iff_iff, map_mul]\n      obtain ⟨n, _, hc⟩ := finite_field.card F (ringChar F)\n      have hchar : ringChar F = ringChar (ZMod p) := by\n        rw [hFp]\n        exact (ring_char_zmod_n p).symm\n      conv =>\n        congr\n        lhs\n        congr\n        skip\n        rw [hc, Nat.cast_pow, map_pow, hchar, map_ring_char]\n      simp only [zero_pow n.pos, MulZeroClass.mul_zero, zero_eq_neg, one_ne_zero, not_false_iff]\n    · rw [← Iff.not_left (@quadratic_char_neg_one_iff_not_is_square F _ _ _ _), quadratic_char_odd_prime hF hp]\n      exact hFp\n#align finite_field.is_square_odd_prime_iff finite_field.is_square_odd_prime_iff\n\n",
 "is_square_neg_two_iff":
 "/-- `-2` is a square in `F` iff `#F` is not congruent to `5` or `7` mod `8`. -/\ntheorem finite_field.is_square_neg_two_iff : IsSquare (-2 : F) ↔ Fintype.card F % 8 ≠ 5 ∧ Fintype.card F % 8 ≠ 7 := by\n  classical\n    by_cases hF : ringChar F = 2\n    focus\n      have h := finite_field.even_card_of_char_two hF\n      simp only [finite_field.is_square_of_char_two hF, true_iff_iff]\n    rotate_left\n    focus\n      have h := finite_field.odd_card_of_char_ne_two hF\n      rw [← quadratic_char_one_iff_is_square (neg_ne_zero.mpr (Ring.two_ne_zero hF)), quadratic_char_neg_two hF,\n        χ₈'_nat_eq_if_mod_eight]\n      simp only [h, nat.one_ne_zero, if_false, ite_eq_left_iff, ne.def, (by decide : (-1 : ℤ) ≠ 1), imp_false,\n        Classical.not_not]\n    all_goals\n      rw [← Nat.mod_mod_of_dvd _ (by norm_num : 2 ∣ 8)] at h\n      have h₁ := nat.mod_lt (Fintype.card F) (by decide : 0 < 8)\n      revert h₁ h\n      generalize Fintype.card F % 8 = n\n      decide!\n#align finite_field.is_square_neg_two_iff finite_field.is_square_neg_two_iff\n\n",
 "is_square_neg_one_iff":
 "/-- `-1` is a square in `F` iff `#F` is not congruent to `3` mod `4`. -/\ntheorem finite_field.is_square_neg_one_iff : IsSquare (-1 : F) ↔ Fintype.card F % 4 ≠ 3 := by\n  classical\n    -- suggested by the linter (instead of `[decidable_eq F]`)\n    by_cases hF : ringChar F = 2\n    · simp only [finite_field.is_square_of_char_two hF, ne.def, true_iff_iff]\n      exact fun hf =>\n        one_ne_zero <| (Nat.odd_of_mod_four_eq_three hf).symm.trans <| finite_field.even_card_of_char_two hF\n    · have h₁ := finite_field.odd_card_of_char_ne_two hF\n      rw [← quadratic_char_one_iff_is_square (neg_ne_zero.mpr (one_ne_zero' F)), quadratic_char_neg_one hF,\n        χ₄_nat_eq_if_mod_four, h₁]\n      simp only [nat.one_ne_zero, if_false, ite_eq_left_iff, ne.def, (by decide : (-1 : ℤ) ≠ 1), imp_false,\n        Classical.not_not]\n      exact ⟨fun h => ne_of_eq_of_ne h (by decide : 1 ≠ 3), or.resolve_right (nat.odd_mod_four_iff.mp h₁)⟩\n#align finite_field.is_square_neg_one_iff finite_field.is_square_neg_one_iff\n\n"}