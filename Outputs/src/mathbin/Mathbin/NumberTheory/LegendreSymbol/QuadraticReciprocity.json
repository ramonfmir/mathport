{"sq_one'":
 "/-- The Legendre symbol of `a^2` at `p` is 1 if `p ∤ a`. -/\ntheorem sq_one' {a : ℤ} (ha : (a : zmod p) ≠ 0) : legendre_sym p (a ^ 2) = 1 := by\n  exact_mod_cast quadratic_char_sq_one' ha\n#align sq_one' sq_one'\n\n",
 "sq_one":
 "/-- The square of the symbol is 1 if `p ∤ a`. -/\ntheorem sq_one {a : ℤ} (ha : (a : zmod p) ≠ 0) : legendre_sym p a ^ 2 = 1 :=\n  quadratic_char_sq_one ha\n#align sq_one sq_one\n\n",
 "quadratic_reciprocity_three_mod_four":
 "/-- The Law of Quadratic Reciprocity: if `p` and `q` are primes that are both congruent\nto `3` mod `4`, then `(q / p) = -(p / q)`. -/\ntheorem quadratic_reciprocity_three_mod_four (hp : p % 4 = 3) (hq : q % 4 = 3) : legendre_sym q p = -legendre_sym p q :=\n  by\n  let nop := @neg_one_pow_div_two_of_three_mod_four\n  rw [quadratic_reciprocity', pow_mul, nop hp, nop hq, neg_one_mul] <;>\n    rwa [← prime.mod_two_eq_one_iff_ne_two, odd_of_mod_four_eq_three]\n#align quadratic_reciprocity_three_mod_four quadratic_reciprocity_three_mod_four\n\n",
 "quadratic_reciprocity_one_mod_four":
 "/-- The Law of Quadratic Reciprocity: if `p` and `q` are odd primes and `p % 4 = 1`,\nthen `(q / p) = (p / q)`. -/\ntheorem quadratic_reciprocity_one_mod_four (hp : p % 4 = 1) (hq : q ≠ 2) : legendre_sym q p = legendre_sym p q := by\n  rw [quadratic_reciprocity' (prime.mod_two_eq_one_iff_ne_two.mp (odd_of_mod_four_eq_one hp)) hq, pow_mul,\n    neg_one_pow_div_two_of_one_mod_four hp, one_pow, one_mul]\n#align quadratic_reciprocity_one_mod_four quadratic_reciprocity_one_mod_four\n\n",
 "quadratic_reciprocity'":
 "/-- The Law of Quadratic Reciprocity: if `p` and `q` are odd primes, then\n`(q / p) = (-1)^((p-1)(q-1)/4) * (p / q)`. -/\ntheorem quadratic_reciprocity' (hp : p ≠ 2) (hq : q ≠ 2) :\n    legendre_sym q p = (-1) ^ (p / 2 * (q / 2)) * legendre_sym p q :=\n  by\n  cases' eq_or_ne p q with h h\n  · subst p\n    rw [(eq_zero_iff q q).mpr (by exact_mod_cast nat_cast_self q), mul_zero]\n  · have qr := congr_arg (· * legendre_sym p q) (quadratic_reciprocity hp hq h)\n    have : ((q : ℤ) : zmod p) ≠ 0 := by exact_mod_cast prime_ne_zero p q h\n    simpa only [mul_assoc, ← pow_two, sq_one p this, mul_one] using qr\n#align quadratic_reciprocity' quadratic_reciprocity'\n\n",
 "quadratic_reciprocity":
 "/-- The Law of Quadratic Reciprocity: if `p` and `q` are distinct odd primes, then\n`(q / p) * (p / q) = (-1)^((p-1)(q-1)/4)`. -/\ntheorem quadratic_reciprocity (hp : p ≠ 2) (hq : q ≠ 2) (hpq : p ≠ q) :\n    legendre_sym q p * legendre_sym p q = (-1) ^ (p / 2 * (q / 2)) :=\n  by\n  have hp₁ := (prime.eq_two_or_odd <| fact.out p.prime).resolve_left hp\n  have hq₁ := (prime.eq_two_or_odd <| fact.out q.prime).resolve_left hq\n  have hq₂ := (ring_char_zmod_n q).substr hq\n  have h := quadratic_char_odd_prime ((ring_char_zmod_n p).substr hp) hq ((ring_char_zmod_n p).substr hpq)\n  rw [card p] at h\n  have nc : ∀ n r : ℕ, ((n : ℤ) : zmod r) = n := fun n r => by norm_cast\n  have nc' : (((-1) ^ (p / 2) : ℤ) : zmod q) = (-1) ^ (p / 2) := by norm_cast\n  rw [legendre_sym, legendre_sym, nc, nc, h, map_mul, mul_rotate', mul_comm (p / 2), ← pow_two,\n    quadratic_char_sq_one (prime_ne_zero q p hpq.symm), mul_one, pow_mul, χ₄_eq_neg_one_pow hp₁, nc', map_pow,\n    quadratic_char_neg_one hq₂, card q, χ₄_eq_neg_one_pow hq₁]\n#align quadratic_reciprocity quadratic_reciprocity\n\n",
 "pow_div_two_eq_neg_one_or_one":
 "/-- If `a : zmod p` is nonzero, then `a^(p/2)` is either `1` or `-1`. -/\ntheorem pow_div_two_eq_neg_one_or_one {a : zmod p} (ha : a ≠ 0) : a ^ (p / 2) = 1 ∨ a ^ (p / 2) = -1 :=\n  by\n  cases' prime.eq_two_or_odd (fact.out p.prime) with hp2 hp_odd\n  · subst p\n    revert a ha\n    decide\n  rw [← mul_self_eq_one_iff, ← pow_add, ← two_mul, two_mul_odd_div_two hp_odd]\n  exact pow_card_sub_one_eq_one ha\n#align pow_div_two_eq_neg_one_or_one pow_div_two_eq_neg_one_or_one\n\n",
 "mul":
 "/-- The Legendre symbol is multiplicative in `a` for `p` fixed. -/\nprotected theorem mul (a b : ℤ) : legendre_sym p (a * b) = legendre_sym p a * legendre_sym p b := by\n  simp only [legendre_sym, Int.cast_mul, map_mul]\n#align mul mul\n\n",
 "mod_four_ne_three_of_sq_eq_neg_sq'":
 "/-- If two nonzero squares are negatives of each other in `zmod p`, then `p % 4 ≠ 3`. -/\ntheorem mod_four_ne_three_of_sq_eq_neg_sq' {x y : zmod p} (hy : y ≠ 0) (hxy : x ^ 2 = -y ^ 2) : p % 4 ≠ 3 :=\n  @mod_four_ne_three_of_sq_eq_neg_one p _ (x / y)\n    (by\n      apply_fun fun z => z / y ^ 2  at hxy\n      rwa [neg_div, ← div_pow, ← div_pow, div_self hy, one_pow] at hxy)\n#align mod_four_ne_three_of_sq_eq_neg_sq' mod_four_ne_three_of_sq_eq_neg_sq'\n\n",
 "mod_four_ne_three_of_sq_eq_neg_sq":
 "theorem mod_four_ne_three_of_sq_eq_neg_sq {x y : zmod p} (hx : x ≠ 0) (hxy : x ^ 2 = -y ^ 2) : p % 4 ≠ 3 :=\n  mod_four_ne_three_of_sq_eq_neg_sq' hx (eq_neg_iff_eq_neg.1 hxy)\n#align mod_four_ne_three_of_sq_eq_neg_sq mod_four_ne_three_of_sq_eq_neg_sq\n\n",
 "mod_four_ne_three_of_sq_eq_neg_one":
 "theorem mod_four_ne_three_of_sq_eq_neg_one {y : zmod p} (hy : y ^ 2 = -1) : p % 4 ≠ 3 :=\n  exists_sq_eq_neg_one_iff.1 ⟨y, hy ▸ pow_two y⟩\n#align mod_four_ne_three_of_sq_eq_neg_one mod_four_ne_three_of_sq_eq_neg_one\n\n",
 "mod":
 "/-- The Legendre symbol depends only on `a` mod `p`. -/\nprotected theorem mod (a : ℤ) : legendre_sym p a = legendre_sym p (a % p) := by simp only [legendre_sym, int_cast_mod]\n#align mod mod\n\n",
 "exists_sq_eq_two_iff":
 "/-- `2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `7` mod `8`. -/\ntheorem exists_sq_eq_two_iff : IsSquare (2 : zmod p) ↔ p % 8 = 1 ∨ p % 8 = 7 :=\n  by\n  rw [finite_field.is_square_two_iff, card p]\n  have h₁ := prime.mod_two_eq_one_iff_ne_two.mpr hp\n  rw [← mod_mod_of_dvd p (by norm_num : 2 ∣ 8)] at h₁\n  have h₂ := mod_lt p (by norm_num : 0 < 8)\n  revert h₂ h₁\n  generalize hm : p % 8 = m; clear! p\n  decide!\n#align exists_sq_eq_two_iff exists_sq_eq_two_iff\n\n",
 "exists_sq_eq_prime_iff_of_mod_four_eq_three":
 "/-- If `p` and `q` are distinct primes that are both congruent to `3` mod `4`, then `q` is\na square mod `p` iff `p` is a nonsquare mod `q`. -/\ntheorem exists_sq_eq_prime_iff_of_mod_four_eq_three (hp3 : p % 4 = 3) (hq3 : q % 4 = 3) (hpq : p ≠ q) :\n    IsSquare (q : zmod p) ↔ ¬IsSquare (p : zmod q) := by\n  rw [← eq_one_iff' p (prime_ne_zero p q hpq), ← eq_neg_one_iff' q, quadratic_reciprocity_three_mod_four hp3 hq3,\n    neg_inj]\n#align exists_sq_eq_prime_iff_of_mod_four_eq_three exists_sq_eq_prime_iff_of_mod_four_eq_three\n\n",
 "exists_sq_eq_prime_iff_of_mod_four_eq_one":
 "/-- If `p` and `q` are odd primes and `p % 4 = 1`, then `q` is a square mod `p` iff\n`p` is a square mod `q`. -/\ntheorem exists_sq_eq_prime_iff_of_mod_four_eq_one (hp1 : p % 4 = 1) (hq1 : q ≠ 2) :\n    IsSquare (q : zmod p) ↔ IsSquare (p : zmod q) :=\n  by\n  cases' eq_or_ne p q with h h\n  · subst p\n  ·\n    rw [← eq_one_iff' p (prime_ne_zero p q h), ← eq_one_iff' q (prime_ne_zero q p h.symm),\n      quadratic_reciprocity_one_mod_four hp1 hq1]\n#align exists_sq_eq_prime_iff_of_mod_four_eq_one exists_sq_eq_prime_iff_of_mod_four_eq_one\n\n",
 "exists_sq_eq_neg_two_iff":
 "/-- `-2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `3` mod `8`. -/\ntheorem exists_sq_eq_neg_two_iff : IsSquare (-2 : zmod p) ↔ p % 8 = 1 ∨ p % 8 = 3 :=\n  by\n  rw [finite_field.is_square_neg_two_iff, card p]\n  have h₁ := prime.mod_two_eq_one_iff_ne_two.mpr hp\n  rw [← mod_mod_of_dvd p (by norm_num : 2 ∣ 8)] at h₁\n  have h₂ := mod_lt p (by norm_num : 0 < 8)\n  revert h₂ h₁\n  generalize hm : p % 8 = m; clear! p\n  decide!\n#align exists_sq_eq_neg_two_iff exists_sq_eq_neg_two_iff\n\n",
 "exists_sq_eq_neg_one_iff":
 "/-- `-1` is a square in `zmod p` iff `p` is not congruent to `3` mod `4`. -/\ntheorem exists_sq_eq_neg_one_iff : IsSquare (-1 : zmod p) ↔ p % 4 ≠ 3 := by\n  rw [finite_field.is_square_neg_one_iff, card p]\n#align exists_sq_eq_neg_one_iff exists_sq_eq_neg_one_iff\n\n",
 "euler_criterion_units":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/-\nCopyright (c) 2018 Chris Hughes. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Chris Hughes, Michael Stoll\n-/\n/-- Euler's Criterion: A unit `x` of `zmod p` is a square if and only if `x ^ (p / 2) = 1`. -/\ntheorem euler_criterion_units (x : «expr ˣ» (zmod p)) : (∃ y : «expr ˣ» (zmod p), y ^ 2 = x) ↔ x ^ (p / 2) = 1 :=\n  by\n  by_cases hc : p = 2\n  · subst hc\n    simp only [eq_iff_true_of_subsingleton, exists_const]\n  · have h₀ := finite_field.unit_is_square_iff (by rwa [ring_char_zmod_n]) x\n    have hs : (∃ y : «expr ˣ» (zmod p), y ^ 2 = x) ↔ IsSquare x :=\n      by\n      rw [isSquare_iff_exists_sq x]\n      simp_rw [eq_comm]\n    rw [hs]\n    rwa [card p] at h₀\n#align euler_criterion_units euler_criterion_units\n\n",
 "euler_criterion":
 "/-- Euler's Criterion: a nonzero `a : zmod p` is a square if and only if `x ^ (p / 2) = 1`. -/\ntheorem euler_criterion {a : zmod p} (ha : a ≠ 0) : IsSquare (a : zmod p) ↔ a ^ (p / 2) = 1 :=\n  by\n  apply (iff_congr _ (by simp [Units.ext_iff])).mp (euler_criterion_units p (Units.mk0 a ha))\n  simp only [Units.ext_iff, sq, Units.val_mk0, Units.val_mul]\n  constructor;\n  · rintro ⟨y, hy⟩\n    exact ⟨y, hy.symm⟩\n  · rintro ⟨y, rfl⟩\n    have hy : y ≠ 0 := by\n      rintro rfl\n      simpa [zero_pow] using ha\n    refine' ⟨Units.mk0 y hy, _⟩\n    simp\n#align euler_criterion euler_criterion\n\n",
 "eq_zero_iff":
 "/-- The Legendre symbol of `p` and `a` is zero iff `p ∣ a`. -/\ntheorem eq_zero_iff (a : ℤ) : legendre_sym p a = 0 ↔ (a : zmod p) = 0 :=\n  quadratic_char_eq_zero_iff\n#align eq_zero_iff eq_zero_iff\n\n",
 "eq_pow":
 "/-- We have the congruence `legendre_sym p a ≡ a ^ (p / 2) mod p`. -/\ntheorem eq_pow (a : ℤ) : (legendre_sym p a : zmod p) = a ^ (p / 2) :=\n  by\n  cases' eq_or_ne (ring_char (zmod p)) 2 with hc hc\n  · by_cases ha : (a : zmod p) = 0\n    · rw [legendre_sym, ha, quadratic_char_zero, zero_pow (Nat.div_pos (fact.out p.prime).two_le (succ_pos 1))]\n      norm_cast\n    · have := (ring_char_zmod_n p).symm.trans hc\n      -- p = 2\n      subst p\n      rw [legendre_sym, quadratic_char_eq_one_of_char_two hc ha]\n      revert ha\n      generalize (a : zmod 2) = b\n      revert b\n      decide\n  · convert quadratic_char_eq_pow_of_char_ne_two' hc (a : zmod p)\n    exact (card p).symm\n#align eq_pow eq_pow\n\n",
 "eq_one_or_neg_one":
 "/-- If `p ∤ a`, then `legendre_sym p a` is `1` or `-1`. -/\ntheorem eq_one_or_neg_one {a : ℤ} (ha : (a : zmod p) ≠ 0) : legendre_sym p a = 1 ∨ legendre_sym p a = -1 :=\n  quadratic_char_dichotomy ha\n#align eq_one_or_neg_one eq_one_or_neg_one\n\n",
 "eq_one_iff'":
 "theorem eq_one_iff' {a : ℕ} (ha0 : (a : zmod p) ≠ 0) : legendre_sym p a = 1 ↔ IsSquare (a : zmod p) :=\n  by\n  rw [eq_one_iff]\n  norm_cast\n  exact_mod_cast ha0\n#align eq_one_iff' eq_one_iff'\n\n",
 "eq_one_iff":
 "/-- When `p ∤ a`, then `legendre_sym p a = 1` iff `a` is a square mod `p`. -/\ntheorem eq_one_iff {a : ℤ} (ha0 : (a : zmod p) ≠ 0) : legendre_sym p a = 1 ↔ IsSquare (a : zmod p) :=\n  quadratic_char_one_iff_is_square ha0\n#align eq_one_iff eq_one_iff\n\n",
 "eq_neg_one_iff_not_one":
 "theorem eq_neg_one_iff_not_one {a : ℤ} (ha : (a : zmod p) ≠ 0) : legendre_sym p a = -1 ↔ ¬legendre_sym p a = 1 :=\n  quadratic_char_eq_neg_one_iff_not_one ha\n#align eq_neg_one_iff_not_one eq_neg_one_iff_not_one\n\n",
 "eq_neg_one_iff'":
 "theorem eq_neg_one_iff' {a : ℕ} : legendre_sym p a = -1 ↔ ¬IsSquare (a : zmod p) :=\n  by\n  rw [eq_neg_one_iff]\n  norm_cast\n#align eq_neg_one_iff' eq_neg_one_iff'\n\n",
 "eq_neg_one_iff":
 "/-- `legendre_sym p a = -1` iff `a` is a nonsquare mod `p`. -/\ntheorem eq_neg_one_iff {a : ℤ} : legendre_sym p a = -1 ↔ ¬IsSquare (a : zmod p) :=\n  quadratic_char_neg_one_iff_not_is_square\n#align eq_neg_one_iff eq_neg_one_iff\n\n",
 "card_sqrts":
 "/-- The number of square roots of `a` modulo `p` is determined by the Legendre symbol. -/\ntheorem card_sqrts (hp : p ≠ 2) (a : ℤ) : ↑{ x : zmod p | x ^ 2 = a }.to_finset.card = legendre_sym p a + 1 :=\n  quadratic_char_card_sqrts ((ring_char_zmod_n p).substr hp) a\n#align card_sqrts card_sqrts\n\n",
 "at_zero":
 "@[simp]\ntheorem at_zero : legendre_sym p 0 = 0 := by rw [legendre_sym, Int.cast_zero, mul_char.map_zero]\n#align at_zero at_zero\n\n",
 "at_two":
 "/-- `legendre_sym p 2` is given by `χ₈ p`. -/\ntheorem at_two : legendre_sym p 2 = χ₈ p := by\n  simp only [legendre_sym, card p, quadratic_char_two ((ring_char_zmod_n p).substr hp), Int.cast_bit0, Int.cast_one]\n#align at_two at_two\n\n",
 "at_one":
 "@[simp]\ntheorem at_one : legendre_sym p 1 = 1 := by rw [legendre_sym, Int.cast_one, mul_char.map_one]\n#align at_one at_one\n\n",
 "at_neg_two":
 "/-- `legendre_sym p (-2)` is given by `χ₈' p`. -/\ntheorem at_neg_two : legendre_sym p (-2) = χ₈' p := by\n  simp only [legendre_sym, card p, quadratic_char_neg_two ((ring_char_zmod_n p).substr hp), Int.cast_bit0, Int.cast_one,\n    Int.cast_neg]\n#align at_neg_two at_neg_two\n\n",
 "at_neg_one":
 "/-- `legendre_sym p (-1)` is given by `χ₄ p`. -/\ntheorem legendre_sym.at_neg_one (hp : p ≠ 2) : legendre_sym p (-1) = χ₄ p := by\n  simp only [legendre_sym, card p, quadratic_char_neg_one ((ring_char_zmod_n p).substr hp), Int.cast_neg, Int.cast_one]\n#align legendre_sym.at_neg_one legendre_sym.at_neg_one\n\n"}