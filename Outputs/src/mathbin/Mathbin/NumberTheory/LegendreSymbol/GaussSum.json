{"two_pow_card":
 "/-- For every finite field `F` of odd characteristic, we have `2^(#F/2) = χ₈(#F)` in `F`. -/\ntheorem finite_field.two_pow_card {F : Type _} [Fintype F] [Field F] (hF : ringChar F ≠ 2) :\n    (2 : F) ^ (Fintype.card F / 2) = χ₈ (Fintype.card F) :=\n  by\n  have hp2 : ∀ n : ℕ, (2 ^ n : F) ≠ 0 := fun n => pow_ne_zero n (Ring.two_ne_zero hF)\n  obtain ⟨n, hp, hc⟩ := finite_field.card F (ringChar F)\n  -- we work in `FF`, the eighth cyclotomic field extension of `F`\n  let FF := (polynomial.cyclotomic 8 F).splitting_field\n  haveI : FiniteDimensional F FF := polynomial.is_splitting_field.finite_dimensional FF (polynomial.cyclotomic 8 F)\n  haveI : Fintype FF := FiniteDimensional.fintypeOfFintype F FF\n  have hchar := Algebra.ringChar_eq F FF\n  have FFp := hchar.subst hp\n  haveI := fact.mk FFp\n  have hFF := ne_of_eq_of_ne hchar.symm hF\n  -- `ring_char FF ≠ 2`\n  have hu : IsUnit (ringChar FF : ZMod 8) :=\n    by\n    rw [isUnit_iff_not_dvd_char, ring_char_zmod_n]\n    rw [ne, ← Nat.prime_dvd_prime_iff_eq FFp Nat.prime_two] at hFF\n    change ¬_ ∣ 2 ^ 3\n    exact mt FFp.dvd_of_dvd_pow hFF\n  -- there is a primitive additive character `ℤ/8ℤ → FF`, sending `a + 8ℤ ↦ τ^a`\n  -- with a primitive eighth root of unity `τ`\n  let ψ₈ := primitive_zmod_char 8 F (by convert hp2 3 <;> norm_num)\n  let τ : FF := ψ₈.char 1\n  have τ_spec : τ ^ 4 = -1 := by\n    refine' (sq_eq_one_iff.1 _).resolve_left _ <;>\n      · simp only [τ, ← map_nsmul_pow]\n        erw [add_char.is_primitive.zmod_char_eq_one_iff 8 ψ₈.prim]\n        decide\n  -- we consider `χ₈` as a multiplicative character `ℤ/8ℤ → FF`\n  let χ := χ₈.ring_hom_comp (Int.castRingHom FF)\n  have hχ : χ (-1) = 1 := norm_num.int_cast_one\n  have hq : is_quadratic χ := is_quadratic_χ₈.comp _\n  -- we now show that the Gauss sum of `χ` and `ψ₈` has the relevant property\n  have hg : gauss_sum χ ψ₈.char ^ 2 = χ (-1) * Fintype.card (ZMod 8) :=\n    by\n    rw [hχ, one_mul, card, gauss_sum]\n    convert← congr_arg (· ^ 2) (Fin.sum_univ_eight fun x => (χ₈ x : FF) * τ ^ x.val)\n    · ext\n      congr\n      apply pow_one\n    convert_to(0 + 1 * τ ^ 1 + 0 + -1 * τ ^ 3 + 0 + -1 * τ ^ 5 + 0 + 1 * τ ^ 7) ^ 2 = _\n    · simp only [χ₈_apply, Matrix.cons_val_zero, Matrix.cons_val_one, Matrix.head_cons, Matrix.cons_vec_bit0_eq_alt0,\n        Matrix.cons_vec_bit1_eq_alt1, Matrix.cons_vecAppend, Matrix.cons_vecAlt0, Matrix.cons_vecAlt1, Int.cast_zero,\n        Int.cast_one, Int.cast_neg, MulZeroClass.zero_mul]\n      rfl\n    convert_to 8 + (τ ^ 4 + 1) * (τ ^ 10 - 2 * τ ^ 8 - 2 * τ ^ 6 + 6 * τ ^ 4 + τ ^ 2 - 8) = _\n    · ring\n    · rw [τ_spec]\n      norm_num\n  -- this allows us to apply `card_pow_char_pow` to our situation\n  have h := char.card_pow_char_pow hq ψ₈.char (ringChar FF) n hu hFF hg\n  rw [card, ← hchar, hχ, one_mul, ← hc, ← Nat.cast_pow (ringChar F), ← hc] at h\n  -- finally, we change `2` to `8` on the left hand side\n  convert_to(8 : F) ^ (Fintype.card F / 2) = _\n  ·\n    rw [(by norm_num : (8 : F) = 2 ^ 2 * 2), mul_pow, (finite_field.is_square_iff hF <| hp2 2).mp ⟨2, pow_two 2⟩,\n      one_mul]\n  apply (algebraMap F FF).injective\n  simp only [map_pow, map_bit0, map_one, map_intCast]\n  convert h\n  norm_num\n#align finite_field.two_pow_card finite_field.two_pow_card\n\n",
 "gauss_sum_sq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/-- When `χ` is a nontrivial quadratic character, then the square of `gauss_sum χ ψ`\nis `χ(-1)` times the cardinality of `R`. -/\ntheorem gauss_sum_sq {χ : mul_char R R'} (hχ₁ : is_nontrivial χ) (hχ₂ : is_quadratic χ) {ψ : add_char R R'}\n    (hψ : is_primitive ψ) : gauss_sum χ ψ ^ 2 = χ (-1) * Fintype.card R :=\n  by\n  rw [pow_two, ← gauss_sum_mul_gauss_sum_eq_card hχ₁ hψ, hχ₂.inv, mul_rotate']\n  congr\n  rw [mul_comm, ← gauss_sum_mul_shift _ _ (-1 : «expr ˣ» R), inv_mul_shift]\n  rfl\n#align gauss_sum_sq gauss_sum_sq\n\n",
 "gauss_sum_mul_shift":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/-\nCopyright (c) 2022 Michael Stoll. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Michael Stoll\n-/\n-- `R` is the domain of the characters\n-- `R'` is the target of the characters\n/-- Replacing `ψ` by `mul_shift ψ a` and multiplying the Gauss sum by `χ a` does not change it. -/\ntheorem gauss_sum_mul_shift (χ : mul_char R R') (ψ : add_char R R') (a : «expr ˣ» R) :\n    χ a * gauss_sum χ (mul_shift ψ a) = gauss_sum χ ψ :=\n  by\n  simp only [gauss_sum, mul_shift_apply, Finset.mul_sum]\n  simp_rw [← mul_assoc, ← map_mul]\n  exact Fintype.sum_bijective _ a.mul_left_bijective _ _ fun x => rfl\n#align gauss_sum_mul_shift gauss_sum_mul_shift\n\n",
 "gauss_sum_mul_gauss_sum_eq_card":
 "/-- We have `gauss_sum χ ψ * gauss_sum χ⁻¹ ψ⁻¹ = fintype.card R`\nwhen `χ` is nontrivial and `ψ` is primitive (and `R` is a field). -/\ntheorem gauss_sum_mul_gauss_sum_eq_card {χ : mul_char R R'} (hχ : is_nontrivial χ) {ψ : add_char R R'}\n    (hψ : is_primitive ψ) : gauss_sum χ ψ * gauss_sum χ⁻¹ ψ⁻¹ = Fintype.card R :=\n  by\n  simp only [gauss_sum, add_char.inv_apply, Finset.sum_mul, Finset.mul_sum, mul_char.inv_apply']\n  conv in _ * _ * (_ * _) => rw [mul_mul_mul_comm, ← map_mul, ← map_add_mul, ← sub_eq_add_neg]\n  simp_rw [gauss_sum_mul_aux hχ ψ]\n  rw [Finset.sum_comm]\n  classical\n    -- to get `[decidable_eq R]` for `sum_mul_shift`\n    simp_rw [← Finset.mul_sum, sum_mul_shift _ hψ, sub_eq_zero, mul_ite, MulZeroClass.mul_zero]\n    rw [Finset.sum_ite_eq' Finset.univ (1 : R)]\n    simp only [Finset.mem_univ, map_one, one_mul, if_true]\n#align gauss_sum_mul_gauss_sum_eq_card gauss_sum_mul_gauss_sum_eq_card\n\n",
 "gauss_sum_mul_aux":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n-- In the following, we need `R` to be a finite field and `R'` to be a domain.\n-- A helper lemma for `gauss_sum_mul_gauss_sum_eq_card` below\n-- Is this useful enough in other contexts to be public?\nprivate theorem gauss_sum_mul_aux {χ : mul_char R R'} (hχ : is_nontrivial χ) (ψ : add_char R R') (b : R) :\n    finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n        (χ (a * b⁻¹) * ψ (a - b)) =\n      finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n        (χ c * ψ (b * (c - 1))) :=\n  by\n  cases' eq_or_ne b 0 with hb hb\n  · -- case `b = 0`\n    simp only [hb, inv_zero, MulZeroClass.mul_zero, mul_char.map_zero, MulZeroClass.zero_mul, Finset.sum_const_zero,\n      map_zero_one, mul_one]\n    exact hχ.sum_eq_zero.symm\n  · -- case `b ≠ 0`\n    refine' (Fintype.sum_bijective _ (mulLeft_bijective₀ b hb) _ _ fun x => _).symm\n    rw [mul_assoc, mul_comm x, ← mul_assoc, mul_inv_cancel hb, one_mul, mul_sub, mul_one]\n#align gauss_sum_mul_aux gauss_sum_mul_aux\n\n",
 "gauss_sum_frob_iter":
 "/-- For a quadratic character `χ` and when the characteristic `p` of the target ring\nis a unit in the source ring and `n` is a natural number, the `p^n`th power of the Gauss\nsum of`χ` and `ψ` is `χ (p^n)` times the original Gauss sum. -/\ntheorem mul_char.is_quadratic.gauss_sum_frob_iter (n : ℕ) (hp : IsUnit (p : R)) {χ : mul_char R R'}\n    (hχ : is_quadratic χ) (ψ : add_char R R') : gauss_sum χ ψ ^ p ^ n = χ (p ^ n) * gauss_sum χ ψ :=\n  by\n  induction' n with n ih\n  · rw [pow_zero, pow_one, pow_zero, mul_char.map_one, one_mul]\n  ·\n    rw [pow_succ, mul_comm p, pow_mul, ih, mul_pow, hχ.gauss_sum_frob _ hp, ← mul_assoc, pow_succ, mul_comm (p : R),\n      map_mul, ← pow_apply' χ fp.1.pos (p ^ n), hχ.pow_char p]\n#align mul_char.is_quadratic.gauss_sum_frob_iter mul_char.is_quadratic.gauss_sum_frob_iter\n\n",
 "gauss_sum_frob":
 "/-- For a quadratic character `χ` and when the characteristic `p` of the target ring\nis a unit in the source ring, the `p`th power of the Gauss sum of`χ` and `ψ` is\n`χ p` times the original Gauss sum. -/\ntheorem mul_char.is_quadratic.gauss_sum_frob (hp : IsUnit (p : R)) {χ : mul_char R R'} (hχ : is_quadratic χ)\n    (ψ : add_char R R') : gauss_sum χ ψ ^ p = χ p * gauss_sum χ ψ := by\n  rw [gauss_sum_frob, pow_mul_shift, hχ.pow_char p, ← gauss_sum_mul_shift χ ψ hp.unit, ← mul_assoc, hp.unit_spec, ←\n    pow_two, ← pow_apply' _ (by norm_num : 0 < 2), hχ.sq_eq_one, ← hp.unit_spec, one_apply_coe, one_mul]\n#align mul_char.is_quadratic.gauss_sum_frob mul_char.is_quadratic.gauss_sum_frob\n\n",
 "card_pow_char_pow":
 "/-- If the square of the Gauss sum of a quadratic character is `χ(-1) * #R`,\nthen we get, for all `n : ℕ`, the relation `(χ(-1) * #R) ^ (p^n/2) = χ(p^n)`,\nwhere `p` is the (odd) characteristic of the target ring `R'`.\nThis version can be used when `R` is not a field, e.g., `ℤ/8ℤ`. -/\ntheorem char.card_pow_char_pow {χ : mul_char R R'} (hχ : is_quadratic χ) (ψ : add_char R R') (p n : ℕ)\n    [fp : Fact p.prime] [hch : CharP R' p] (hp : IsUnit (p : R)) (hp' : p ≠ 2)\n    (hg : gauss_sum χ ψ ^ 2 = χ (-1) * Fintype.card R) : (χ (-1) * Fintype.card R) ^ (p ^ n / 2) = χ (p ^ n) :=\n  by\n  have : gauss_sum χ ψ ≠ 0 := by\n    intro hf\n    rw [hf, zero_pow (by norm_num : 0 < 2), eq_comm, mul_eq_zero] at hg\n    exact\n      not_isUnit_prime_of_dvd_card p\n        ((char_p.cast_eq_zero_iff R' p _).mp <| hg.resolve_left (is_unit_one.neg.map χ).ne_zero) hp\n  rw [← hg]\n  apply mul_right_cancel₀ this\n  rw [← hχ.gauss_sum_frob_iter p n hp ψ, ← pow_mul, mul_comm, ← pow_succ,\n    Nat.two_mul_div_two_add_one_of_odd (fp.1.eq_two_or_odd'.resolve_left hp').pow]\n#align char.card_pow_char_pow char.card_pow_char_pow\n\n",
 "card_pow_card":
 "/-- When `F` and `F'` are finite fields and `χ : F → F'` is a nontrivial quadratic character,\nthen `(χ(-1) * #F)^(#F'/2) = χ(#F')`. -/\ntheorem char.card_pow_card {F : Type _} [Field F] [Fintype F] {F' : Type _} [Field F'] [Fintype F'] {χ : mul_char F F'}\n    (hχ₁ : is_nontrivial χ) (hχ₂ : is_quadratic χ) (hch₁ : ringChar F' ≠ ringChar F) (hch₂ : ringChar F' ≠ 2) :\n    (χ (-1) * Fintype.card F) ^ (Fintype.card F' / 2) = χ (Fintype.card F') :=\n  by\n  obtain ⟨n, hp, hc⟩ := finite_field.card F (ringChar F)\n  obtain ⟨n', hp', hc'⟩ := finite_field.card F' (ringChar F')\n  let ψ := primitive_char_finite_field F F' hch₁\n  let FF' := cyclotomic_field ψ.n F'\n  have hchar := Algebra.ringChar_eq F' FF'\n  apply (algebraMap F' FF').injective\n  rw [map_pow, map_mul, map_natCast, hc', hchar, Nat.cast_pow]\n  simp only [← mul_char.ring_hom_comp_apply]\n  haveI := fact.mk hp'\n  haveI := fact.mk (hchar.subst hp')\n  rw [ne, ← Nat.prime_dvd_prime_iff_eq hp' hp, ← isUnit_iff_not_dvd_char, hchar] at hch₁\n  exact\n    char.card_pow_char_pow (hχ₂.comp _) ψ.char (ringChar FF') n' hch₁ (hchar ▸ hch₂)\n      (gauss_sum_sq (hχ₁.comp <| RingHom.injective _) (hχ₂.comp _) ψ.prim)\n#align char.card_pow_card char.card_pow_card\n\n"}