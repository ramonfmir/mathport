{"to_unit_hom_eq":
 "@[simp]\ntheorem to_unit_hom_eq (χ : mul_char R R') : to_unit_hom χ = equiv_to_unit_hom χ :=\n  rfl\n#align to_unit_hom_eq to_unit_hom_eq\n\n",
 "to_fun_eq_coe":
 "@[simp]\ntheorem to_fun_eq_coe (χ : mul_char R R') : χ.to_fun = χ :=\n  rfl\n#align to_fun_eq_coe to_fun_eq_coe\n\n",
 "sum_one_eq_card_units":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/-- The sum over all values of the trivial multiplicative character on a finite ring is\nthe cardinality of its unit group. -/\ntheorem sum_one_eq_card_units [Fintype R] [DecidableEq R] :\n    finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n        ((1 : mul_char R R') a) =\n      Fintype.card («expr ˣ» R) :=\n  by\n  calc\n    finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n          ((1 : mul_char R R') a) =\n        finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n          (if IsUnit a then 1 else 0) :=\n      Finset.sum_congr rfl fun a _ => _\n    _ = ((Finset.univ : Finset R).filter IsUnit).card := Finset.sum_boole\n    _ = (finset.univ.map ⟨(coe : «expr ˣ» R → R), Units.ext⟩).card := _\n    _ = Fintype.card («expr ˣ» R) := congr_arg _ (Finset.card_map _)\n    \n  · split_ifs with h h\n    · exact one_apply_coe h.unit\n    · exact map_nonunit _ h\n  · congr\n    ext a\n    simp only [Finset.mem_filter, Finset.mem_univ, true_and_iff, Finset.mem_map, Function.Embedding.coeFn_mk,\n      exists_true_left, IsUnit]\n#align sum_one_eq_card_units sum_one_eq_card_units\n\n",
 "sum_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/-- The sum over all values of a nontrivial multiplicative character on a finite ring is zero\n(when the target is a domain). -/\ntheorem is_nontrivial.sum_eq_zero [Fintype R] [IsDomain R'] {χ : mul_char R R'} (hχ : χ.is_nontrivial) :\n    finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\" (χ a) =\n      0 :=\n  by\n  rcases hχ with ⟨b, hb⟩\n  refine' eq_zero_of_mul_eq_self_left hb _\n  simp only [Finset.mul_sum, ← map_mul]\n  exact Fintype.sum_bijective _ (Units.mulLeft_bijective b) _ _ fun x => rfl\n#align is_nontrivial.sum_eq_zero is_nontrivial.sum_eq_zero\n\n",
 "sq_eq_one":
 "/-- The square of a quadratic character is the trivial character. -/\ntheorem is_quadratic.sq_eq_one {χ : mul_char R R'} (hχ : χ.is_quadratic) : χ ^ 2 = 1 :=\n  by\n  convert mul_left_inv _\n  rw [pow_two, hχ.inv]\n#align is_quadratic.sq_eq_one is_quadratic.sq_eq_one\n\n",
 "pow_odd":
 "/-- The `n`th power of a quadratic character is itself, when `n` is odd. -/\ntheorem is_quadratic.pow_odd {χ : mul_char R R'} (hχ : χ.is_quadratic) {n : ℕ} (hn : Odd n) : χ ^ n = χ :=\n  by\n  obtain ⟨n, rfl⟩ := hn\n  rw [pow_add, pow_one, hχ.pow_even (even_two_mul _), one_mul]\n#align is_quadratic.pow_odd is_quadratic.pow_odd\n\n",
 "pow_even":
 "/-- The `n`th power of a quadratic character is the trivial character, when `n` is even. -/\ntheorem is_quadratic.pow_even {χ : mul_char R R'} (hχ : χ.is_quadratic) {n : ℕ} (hn : Even n) : χ ^ n = 1 :=\n  by\n  obtain ⟨n, rfl⟩ := even_iff_two_dvd.mp hn\n  rw [pow_mul, hχ.sq_eq_one, one_pow]\n#align is_quadratic.pow_even is_quadratic.pow_even\n\n",
 "pow_char":
 "/-- The `p`th power of a quadratic character is itself, when `p` is the (prime) characteristic\nof the target ring. -/\ntheorem is_quadratic.pow_char {χ : mul_char R R'} (hχ : χ.is_quadratic) (p : ℕ) [hp : Fact p.prime] [CharP R' p] :\n    χ ^ p = χ := by\n  ext x\n  rw [pow_apply_coe]\n  rcases hχ x with (hx | hx | hx) <;> rw [hx]\n  · rw [zero_pow (fact.out p.prime).pos]\n  · rw [one_pow]\n  · exact CharP.neg_one_pow_char R' p\n#align is_quadratic.pow_char is_quadratic.pow_char\n\n",
 "pow_apply_coe":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/-- If `a` is a unit and `n : ℕ`, then `(χ ^ n) a = (χ a) ^ n`. -/\ntheorem pow_apply_coe (χ : mul_char R R') (n : ℕ) (a : «expr ˣ» R) : (χ ^ n) a = χ a ^ n :=\n  by\n  induction' n with n ih\n  · rw [pow_zero, pow_zero, one_apply_coe]\n  · rw [pow_succ, pow_succ, mul_apply, ih]\n#align pow_apply_coe pow_apply_coe\n\n",
 "pow_apply'":
 "/-- If `n` is positive, then `(χ ^ n) a = (χ a) ^ n`. -/\ntheorem pow_apply' (χ : mul_char R R') {n : ℕ} (hn : 0 < n) (a : R) : (χ ^ n) a = χ a ^ n :=\n  by\n  by_cases ha : IsUnit a\n  · exact pow_apply_coe χ n ha.unit\n  · rw [map_nonunit (χ ^ n) ha, map_nonunit χ ha, zero_pow hn]\n#align pow_apply' pow_apply'\n\n",
 "one_mul":
 "#print one_mul /-\nprotected theorem one_mul (χ : mul_char R R') : (1 : mul_char R R') * χ = χ :=\n  by\n  ext\n  simp\n#align one_mul one_mul\n-/\n\n",
 "one_apply_coe":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/-- Evaluation of the trivial character -/\n@[simp]\ntheorem one_apply_coe (a : «expr ˣ» R) : (1 : mul_char R R') a = 1 := by classical exact dif_pos a.is_unit\n#align one_apply_coe one_apply_coe\n\n",
 "of_unit_hom_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n@[simp]\ntheorem of_unit_hom_eq (χ : «expr →* » («expr ˣ» R) («expr ˣ» R')) : of_unit_hom χ = equiv_to_unit_hom.symm χ :=\n  rfl\n#align of_unit_hom_eq of_unit_hom_eq\n\n",
 "of_unit_hom_coe":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\ntheorem of_unit_hom_coe (f : «expr →* » («expr ˣ» R) («expr ˣ» R')) (a : «expr ˣ» R) : of_unit_hom f ↑a = f a := by\n  simp [of_unit_hom]\n#align of_unit_hom_coe of_unit_hom_coe\n\n",
 "mul_one":
 "#print mul_one /-\nprotected theorem mul_one (χ : mul_char R R') : χ * 1 = χ :=\n  by\n  ext\n  simp\n#align mul_one mul_one\n-/\n\n",
 "mul_apply":
 "theorem mul_apply (χ χ' : mul_char R R') (a : R) : (χ * χ') a = χ a * χ' a :=\n  rfl\n#align mul_apply mul_apply\n\n",
 "map_zero":
 "#print map_zero /-\n/-- If the domain has a zero (and is nontrivial), then `χ 0 = 0`. -/\nprotected theorem map_zero {R : Type u} [CommMonoidWithZero R] [Nontrivial R] (χ : mul_char R R') : χ (0 : R) = 0 := by\n  rw [map_nonunit χ not_isUnit_zero]\n#align map_zero map_zero\n-/\n\n",
 "map_ring_char":
 "/-- If the domain is a ring `R`, then `χ (ring_char R) = 0`. -/\ntheorem map_ring_char {R : Type u} [CommRing R] [Nontrivial R] (χ : mul_char R R') : χ (ringChar R) = 0 := by\n  rw [ringChar.Nat.cast_ringChar, χ.map_zero]\n#align map_ring_char map_ring_char\n\n",
 "map_one":
 "#print map_one /-\nprotected theorem map_one (χ : mul_char R R') : χ (1 : R) = 1 :=\n  χ.map_one'\n#align map_one map_one\n-/\n\n",
 "map_nonunit":
 "theorem map_nonunit (χ : mul_char R R') {a : R} (ha : ¬IsUnit a) : χ a = 0 :=\n  χ.map_nonunit' a ha\n#align map_nonunit map_nonunit\n\n",
 "is_nontrivial_iff":
 "/-- A multiplicative character is nontrivial iff it is not the trivial character. -/\ntheorem is_nontrivial_iff (χ : mul_char R R') : χ.is_nontrivial ↔ χ ≠ 1 := by\n  simp only [is_nontrivial, ne.def, ext_iff, not_forall, one_apply_coe]\n#align is_nontrivial_iff is_nontrivial_iff\n\n",
 "inv_mul":
 "/-- The product of a character with its inverse is the trivial character. -/\n@[simp]\ntheorem inv_mul (χ : mul_char R R') : χ⁻¹ * χ = 1 := by\n  ext x\n  rw [coe_to_fun_mul, Pi.mul_apply, inv_apply_eq_inv, Ring.inverse_mul_cancel _ (IsUnit.map _ x.is_unit), one_apply_coe]\n#align inv_mul inv_mul\n\n",
 "inv_apply_eq_inv'":
 "/-- The inverse of a multiplicative character `χ`, applied to `a`, is the inverse of `χ a`.\nVariant when the target is a field -/\ntheorem inv_apply_eq_inv' {R' : Type v} [Field R'] (χ : mul_char R R') (a : R) : χ⁻¹ a = (χ a)⁻¹ :=\n  (inv_apply_eq_inv χ a).trans <| Ring.inverse_eq_inv (χ a)\n#align inv_apply_eq_inv' inv_apply_eq_inv'\n\n",
 "inv_apply_eq_inv":
 "/-- The inverse of a multiplicative character `χ`, applied to `a`, is the inverse of `χ a`. -/\ntheorem inv_apply_eq_inv (χ : mul_char R R') (a : R) : χ⁻¹ a = Ring.inverse (χ a) :=\n  Eq.refl <| inv χ a\n#align inv_apply_eq_inv inv_apply_eq_inv\n\n",
 "inv_apply'":
 "/-- When the domain has a zero, then the inverse of a multiplicative character `χ`,\napplied to `a`, is `χ` applied to the inverse of `a`. -/\ntheorem inv_apply' {R : Type u} [Field R] (χ : mul_char R R') (a : R) : χ⁻¹ a = χ a⁻¹ :=\n  (inv_apply χ a).trans <| congr_arg _ (Ring.inverse_eq_inv a)\n#align inv_apply' inv_apply'\n\n",
 "inv_apply":
 "/-- When the domain has a zero, then the inverse of a multiplicative character `χ`,\napplied to `a`, is `χ` applied to the inverse of `a`. -/\ntheorem inv_apply {R : Type u} [CommMonoidWithZero R] (χ : mul_char R R') (a : R) : χ⁻¹ a = χ (Ring.inverse a) :=\n  by\n  by_cases ha : IsUnit a\n  · rw [inv_apply_eq_inv]\n    have h := IsUnit.map χ ha\n    apply_fun (· * ·) (χ a) using IsUnit.mul_right_injective h\n    rw [Ring.mul_inverse_cancel _ h, ← map_mul, Ring.mul_inverse_cancel _ ha, mul_char.map_one]\n  · revert ha\n    nontriviality R\n    intro ha\n    -- `nontriviality R` by itself doesn't do it\n    rw [map_nonunit _ ha, Ring.inverse_non_unit a ha, mul_char.map_zero χ]\n#align inv_apply inv_apply\n\n",
 "inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/-- The inverse of a quadratic character is itself. →  -/\ntheorem is_quadratic.inv {χ : mul_char R R'} (hχ : χ.is_quadratic) : χ⁻¹ = χ :=\n  by\n  ext x\n  rw [inv_apply_eq_inv]\n  rcases hχ x with (h₀ | h₁ | h₂)\n  · rw [h₀, Ring.inverse_zero]\n  · rw [h₁, Ring.inverse_one]\n  · rw [h₂, (by norm_cast : (-1 : R') = (-1 : «expr ˣ» R')), Ring.inverse_unit (-1 : «expr ˣ» R')]\n    rfl\n#align is_quadratic.inv is_quadratic.inv\n\n",
 "ext_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\ntheorem ext_iff {χ χ' : mul_char R R'} : χ = χ' ↔ ∀ a : «expr ˣ» R, χ a = χ' a :=\n  ⟨by\n    rintro rfl a\n    rfl, ext⟩\n#align ext_iff ext_iff\n\n",
 "ext'":
 "/-- Extensionality. See `ext` below for the version that will actually be used. -/\ntheorem ext' {χ χ' : mul_char R R'} (h : ∀ a, χ a = χ' a) : χ = χ' :=\n  by\n  cases χ\n  cases χ'\n  congr\n  exact MonoidHom.ext h\n#align ext' ext'\n\n",
 "ext":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/-- Extensionality. Since `mul_char`s always take the value zero on non-units, it is sufficient\nto compare the values on units. -/\n@[ext]\ntheorem ext {χ χ' : mul_char R R'} (h : ∀ a : «expr ˣ» R, χ a = χ' a) : χ = χ' :=\n  by\n  apply ext'\n  intro a\n  by_cases ha : IsUnit a\n  · exact h ha.unit\n  · rw [map_nonunit χ ha, map_nonunit χ' ha]\n#align ext ext\n\n",
 "equiv_unit_hom_symm_coe":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n@[simp]\ntheorem equiv_unit_hom_symm_coe (f : «expr →* » («expr ˣ» R) («expr ˣ» R')) (a : «expr ˣ» R) :\n    equiv_to_unit_hom.symm f ↑a = f a :=\n  of_unit_hom_coe f a\n#align equiv_unit_hom_symm_coe equiv_unit_hom_symm_coe\n\n",
 "eq_of_eq_coe":
 "/-- If two values of quadratic characters with target `ℤ` agree after coercion into a ring\nof characteristic not `2`, then they agree in `ℤ`. -/\ntheorem is_quadratic.eq_of_eq_coe {χ : mul_char R ℤ} (hχ : is_quadratic χ) {χ' : mul_char R' ℤ} (hχ' : is_quadratic χ')\n    [Nontrivial R''] (hR'' : ringChar R'' ≠ 2) {a : R} {a' : R'} (h : (χ a : R'') = χ' a') : χ a = χ' a' :=\n  Int.cast_injOn_of_ringChar_ne_two hR'' (hχ a) (hχ' a') h\n#align is_quadratic.eq_of_eq_coe is_quadratic.eq_of_eq_coe\n\n",
 "comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/-- Composition with a ring homomorphism preserves the property of being a quadratic character. -/\ntheorem is_quadratic.comp {χ : mul_char R R'} (hχ : χ.is_quadratic) (f : «expr →+* » R' R'') :\n    (χ.ring_hom_comp f).is_quadratic := by\n  intro a\n  rcases hχ a with (ha | ha | ha) <;> simp [ha]\n#align is_quadratic.comp is_quadratic.comp\n\n",
 "coe_to_unit_hom":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\ntheorem coe_to_unit_hom (χ : mul_char R R') (a : «expr ˣ» R) : ↑(χ.to_unit_hom a) = χ a :=\n  rfl\n#align coe_to_unit_hom coe_to_unit_hom\n\n",
 "coe_to_fun_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n@[simp]\ntheorem coe_to_fun_mul (χ χ' : mul_char R R') : «expr⇑ » (χ * χ') = χ * χ' :=\n  rfl\n#align coe_to_fun_mul coe_to_fun_mul\n\n",
 "coe_mk":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n@[simp]\ntheorem coe_mk (f : «expr →* » R R') (hf) : (mul_char.mk f hf : R → R') = f :=\n  rfl\n#align coe_mk coe_mk\n\n",
 "coe_equiv_to_unit_hom":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n@[simp]\ntheorem coe_equiv_to_unit_hom (χ : mul_char R R') (a : «expr ˣ» R) : ↑(equiv_to_unit_hom χ a) = χ a :=\n  coe_to_unit_hom χ a\n#align coe_equiv_to_unit_hom coe_equiv_to_unit_hom\n\n",
 "coe_coe":
 "/-\nCopyright (c) 2022 Michael Stoll. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Michael Stoll\n-/\n-- The domain of our multiplicative characters\n-- The target\n-- The domain of our multiplicative characters\n-- The target\n@[simp]\ntheorem coe_coe (χ : mul_char R R') : (χ.to_monoid_hom : R → R') = χ :=\n  rfl\n#align coe_coe coe_coe\n\n"}