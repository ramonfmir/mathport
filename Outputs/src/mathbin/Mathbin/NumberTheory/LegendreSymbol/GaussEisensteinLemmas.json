{"wilsons_lemma":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\n/-\nCopyright (c) 2018 Chris Hughes. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Chris Hughes\n-/\n/-- **Wilson's Lemma**: the product of `1`, ..., `p-1` is `-1` modulo `p`. -/\n@[simp]\ntheorem wilsons_lemma : (nat.factorial (p - 1) : ZMod p) = -1 :=\n  by\n  refine'\n    calc\n      (nat.factorial (p - 1) : ZMod p) =\n          finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\"\n            (Ico 1 (succ (p - 1))) x :=\n        by rw [← Finset.prod_Ico_id_eq_factorial, prod_nat_cast]\n      _ =\n          finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n            x :=\n        _\n      _ = -1 := by\n        simp_rw [← Units.coeHom_apply, ← (Units.coeHom (ZMod p)).map_prod, prod_univ_units_id_eq_neg_one,\n          Units.coeHom_apply, Units.val_neg, Units.val_one]\n      \n  have hp : 0 < p := (fact.out p.prime).pos\n  symm\n  refine' prod_bij (fun a _ => (a : ZMod p).val) _ _ _ _\n  · intro a ha\n    rw [mem_Ico, ← nat.succ_sub hp, nat.succ_sub_one]\n    constructor\n    · apply nat.pos_of_ne_zero\n      rw [← @val_zero p]\n      intro h\n      apply Units.ne_zero a (val_injective p h)\n    · exact val_lt _\n  · intro a ha\n    simp only [cast_id, nat_cast_val]\n  · intro _ _ _ _ h\n    rw [Units.ext_iff]\n    exact val_injective p h\n  · intro b hb\n    rw [mem_Ico, Nat.succ_le_iff, ← succ_sub hp, succ_sub_one, pos_iff_ne_zero] at hb\n    refine' ⟨Units.mk0 b _, Finset.mem_univ _, _⟩\n    · intro h\n      apply hb.1\n      apply_fun val  at h\n      simpa only [val_cast_of_lt hb.right, val_zero] using h\n    · simp only [val_cast_of_lt hb.right, Units.val_mk0]\n#align wilsons_lemma wilsons_lemma\n\n",
 "sum_mul_div_add_sum_mul_div_eq_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/-- Each of the sums in this lemma is the cardinality of the set integer points in each of the\n  two triangles formed by the diagonal of the rectangle `(0, p/2) × (0, q/2)`. Adding them\n  gives the number of points in the rectangle. -/\ntheorem sum_mul_div_add_sum_mul_div_eq_mul (p q : ℕ) [hp : Fact p.prime] (hq0 : (q : ZMod p) ≠ 0) :\n    finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (Ico 1 (p / 2).succ)\n          (a * q / p) +\n        finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n          (Ico 1 (q / 2).succ) (a * p / q) =\n      p / 2 * (q / 2) :=\n  by\n  have hswap :\n    ((lower_set.prod (Ico 1 (q / 2).succ) (Ico 1 (p / 2).succ)).filter fun x : ℕ × ℕ => x.2 * q ≤ x.1 * p).card =\n      ((lower_set.prod (Ico 1 (p / 2).succ) (Ico 1 (q / 2).succ)).filter fun x : ℕ × ℕ => x.1 * q ≤ x.2 * p).card :=\n    card_congr (fun x _ => Prod.swap x)\n      (fun ⟨_, _⟩ => by\n        simp (config := { contextual := true }) only [mem_filter, and_self_iff, Prod.swap_prod_mk, forall_true_iff,\n          mem_product])\n      (fun ⟨_, _⟩ ⟨_, _⟩ => by\n        simp (config := { contextual := true }) only [Prod.mk.inj_iff, eq_self_iff_true, and_self_iff,\n          Prod.swap_prod_mk, forall_true_iff])\n      fun ⟨x₁, x₂⟩ h =>\n      ⟨⟨x₂, x₁⟩, by\n        revert h <;>\n          simp (config := { contextual := true }) only [mem_filter, eq_self_iff_true, and_self_iff, exists_prop_of_true,\n            Prod.swap_prod_mk, forall_true_iff, mem_product]⟩\n  have hdisj :\n    Disjoint ((lower_set.prod (Ico 1 (p / 2).succ) (Ico 1 (q / 2).succ)).filter fun x : ℕ × ℕ => x.2 * p ≤ x.1 * q)\n      ((lower_set.prod (Ico 1 (p / 2).succ) (Ico 1 (q / 2).succ)).filter fun x : ℕ × ℕ => x.1 * q ≤ x.2 * p) :=\n    by\n    apply disjoint_filter.2 fun x hx hpq hqp => _\n    have hxp : x.1 < p :=\n      lt_of_le_of_lt (show x.1 ≤ p / 2 by simp_all only [lt_succ_iff, mem_Ico, mem_product] <;> tauto)\n        (nat.div_lt_self hp.1.pos (by decide))\n    have : (x.1 : ZMod p) = 0 := by simpa [hq0] using congr_arg (coe : ℕ → ZMod p) (le_antisymm hpq hqp)\n    apply_fun ZMod.val  at this\n    rw [val_cast_of_lt hxp, val_zero] at this\n    simpa only [this, nonpos_iff_eq_zero, mem_Ico, one_ne_zero, false_and_iff, mem_product] using hx\n  have hunion :\n    (((lower_set.prod (Ico 1 (p / 2).succ) (Ico 1 (q / 2).succ)).filter fun x : ℕ × ℕ => x.2 * p ≤ x.1 * q) ∪\n        (lower_set.prod (Ico 1 (p / 2).succ) (Ico 1 (q / 2).succ)).filter fun x : ℕ × ℕ => x.1 * q ≤ x.2 * p) =\n      lower_set.prod (Ico 1 (p / 2).succ) (Ico 1 (q / 2).succ) :=\n    Finset.ext fun x => by\n      have := le_total (x.2 * p) (x.1 * q) <;> simp only [mem_union, mem_filter, mem_Ico, mem_product] <;> tauto\n  rw [sum_Ico_eq_card_lt, sum_Ico_eq_card_lt, hswap, ← card_disjoint_union hdisj, hunion, card_product]\n  simp only [card_Ico, tsub_zero, succ_sub_succ_eq_sub]\n#align sum_mul_div_add_sum_mul_div_eq_mul sum_mul_div_add_sum_mul_div_eq_mul\n\n",
 "sum_Ico_eq_card_lt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n/-- The given sum is the number of integer points in the triangle formed by the diagonal of the\n  rectangle `(0, p/2) × (0, q/2)`  -/\nprivate theorem sum_Ico_eq_card_lt {p q : ℕ} :\n    finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (Ico 1 (p / 2).succ)\n        (a * q / p) =\n      ((lower_set.prod (Ico 1 (p / 2).succ) (Ico 1 (q / 2).succ)).filter fun x : ℕ × ℕ => x.2 * p ≤ x.1 * q).card :=\n  if hp0 : p = 0 then by simp [hp0, Finset.ext_iff]\n  else\n    calc\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n            (Ico 1 (p / 2).succ) (a * q / p) =\n          finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n            (Ico 1 (p / 2).succ) ((Ico 1 (q / 2).succ).filter fun x => x * p ≤ a * q).card :=\n        Finset.sum_congr rfl fun x hx =>\n          div_eq_filter_card (nat.pos_of_ne_zero hp0)\n            (calc\n              x * q / p ≤ p / 2 * q / p :=\n                Nat.div_le_div_right (mul_le_mul_of_nonneg_right (le_of_lt_succ <| (mem_Ico.mp hx).2) (nat.zero_le _))\n              _ ≤ _ := Nat.div_mul_div_le_div _ _ _\n              )\n      _ = _ := by\n        rw [← card_sigma] <;>\n          exact\n            card_congr (fun a _ => ⟨a.1, a.2⟩)\n              (by\n                simp (config := { contextual := true }) only [mem_filter, mem_sigma, and_self_iff, forall_true_iff,\n                  mem_product])\n              (fun ⟨_, _⟩ ⟨_, _⟩ => by\n                simp (config := { contextual := true }) only [Prod.mk.inj_iff, eq_self_iff_true, and_self_iff,\n                  heq_iff_eq, forall_true_iff])\n              fun ⟨b₁, b₂⟩ h =>\n              ⟨⟨b₁, b₂⟩, by\n                revert h <;>\n                  simp (config := { contextual := true }) only [mem_filter, eq_self_iff_true, exists_prop_of_true,\n                    mem_sigma, and_self_iff, forall_true_iff, mem_product]⟩\n      \n#align sum_Ico_eq_card_lt sum_Ico_eq_card_lt\n\n",
 "prod_Ico_one_prime":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n@[simp]\ntheorem prod_Ico_one_prime :\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" (Ico 1 p)\n        (x : ZMod p) =\n      -1 :=\n  by\n  conv in Ico 1 p => rw [← succ_sub_one p, succ_sub (fact.out p.prime).pos]\n  rw [← prod_nat_cast, Finset.prod_Ico_id_eq_factorial, wilsons_lemma]\n#align prod_Ico_one_prime prod_Ico_one_prime\n\n",
 "gauss_lemma_aux₁":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\nprivate theorem gauss_lemma_aux₁ (p : ℕ) [Fact p.prime] [Fact (p % 2 = 1)] {a : ℤ} (hap : (a : ZMod p) ≠ 0) :\n    (a ^ (p / 2) * nat.factorial (p / 2) : ZMod p) =\n      (-1) ^ ((Ico 1 (p / 2).succ).filter fun x : ℕ => ¬(a * x : ZMod p).val ≤ p / 2).card * nat.factorial (p / 2) :=\n  calc\n    (a ^ (p / 2) * nat.factorial (p / 2) : ZMod p) =\n        finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\"\n          (Ico 1 (p / 2).succ) (a * x) :=\n      by rw [prod_mul_distrib, ← prod_nat_cast, prod_Ico_id_eq_factorial, prod_const, card_Ico, succ_sub_one] <;> simp\n    _ =\n        finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\"\n          (Ico 1 (p / 2).succ) (a * x : ZMod p).val :=\n      by simp\n    _ =\n        finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\"\n          (Ico 1 (p / 2).succ)\n          ((if (a * x : ZMod p).val ≤ p / 2 then 1 else -1) * (a * x : ZMod p).val_min_abs.nat_abs) :=\n      (prod_congr rfl fun _ _ => by\n        simp only [nat_cast_nat_abs_val_min_abs]\n        split_ifs <;> simp)\n    _ =\n        (-1) ^ ((Ico 1 (p / 2).succ).filter fun x : ℕ => ¬(a * x : ZMod p).val ≤ p / 2).card *\n          finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\"\n            (Ico 1 (p / 2).succ) (a * x : ZMod p).val_min_abs.nat_abs :=\n      by\n      have :\n        finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\"\n            (Ico 1 (p / 2).succ) (if (a * x : ZMod p).val ≤ p / 2 then (1 : ZMod p) else -1) =\n          finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\"\n            ((Ico 1 (p / 2).succ).filter fun x : ℕ => ¬(a * x : ZMod p).val ≤ p / 2) (-1) :=\n        prod_bij_ne_one (fun x _ _ => x) (fun x => by split_ifs <;> simp_all (config := { contextual := true }))\n          (fun _ _ _ _ _ _ => id) (fun b h _ => ⟨b, by simp_all [-not_le]⟩) (by intros <;> split_ifs  at * <;> simp_all)\n      rw [prod_mul_distrib, this] <;> simp\n    _ = (-1) ^ ((Ico 1 (p / 2).succ).filter fun x : ℕ => ¬(a * x : ZMod p).val ≤ p / 2).card * nat.factorial (p / 2) :=\n      by\n      rw [← prod_nat_cast, Finset.prod_eq_multiset_prod, Ico_map_val_min_abs_nat_abs_eq_Ico_map_id p a hap, ←\n        Finset.prod_eq_multiset_prod, prod_Ico_id_eq_factorial]\n    \n#align gauss_lemma_aux₁ gauss_lemma_aux₁\n\n",
 "gauss_lemma_aux":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\ntheorem gauss_lemma_aux (p : ℕ) [hp : Fact p.prime] [Fact (p % 2 = 1)] {a : ℤ} (hap : (a : ZMod p) ≠ 0) :\n    (a ^ (p / 2) : ZMod p) = (-1) ^ ((Ico 1 (p / 2).succ).filter fun x : ℕ => p / 2 < (a * x : ZMod p).val).card :=\n  (mul_left_inj'\n        (show (nat.factorial (p / 2) : ZMod p) ≠ 0 by\n          rw [ne.def, char_p.cast_eq_zero_iff (ZMod p) p, hp.1.dvd_factorial, not_le] <;>\n            exact nat.div_lt_self hp.1.pos (by decide))).1 <|\n    by simpa using gauss_lemma_aux₁ p hap\n#align gauss_lemma_aux gauss_lemma_aux\n\n",
 "gauss_lemma":
 "/-- Gauss' lemma. The legendre symbol can be computed by considering the number of naturals less\n  than `p/2` such that `(a * x) % p > p / 2` -/\ntheorem gauss_lemma {p : ℕ} [Fact p.prime] {a : ℤ} (hp : p ≠ 2) (ha0 : (a : ZMod p) ≠ 0) :\n    legendre_sym p a = (-1) ^ ((Ico 1 (p / 2).succ).filter fun x : ℕ => p / 2 < (a * x : ZMod p).val).card :=\n  by\n  haveI hp' : Fact (p % 2 = 1) := ⟨nat.prime.mod_two_eq_one_iff_ne_two.mpr hp⟩\n  have :\n    (legendre_sym p a : ZMod p) =\n      (((-1) ^ ((Ico 1 (p / 2).succ).filter fun x : ℕ => p / 2 < (a * x : ZMod p).val).card : ℤ) : ZMod p) :=\n    by rw [legendre_sym.eq_pow, gauss_lemma_aux p ha0] <;> simp\n  cases legendre_sym.eq_one_or_neg_one p ha0 <;>\n      cases neg_one_pow_eq_or ℤ ((Ico 1 (p / 2).succ).filter fun x : ℕ => p / 2 < (a * x : ZMod p).val).card <;>\n    simp_all [ne_neg_self p one_ne_zero, (ne_neg_self p one_ne_zero).symm]\n#align gauss_lemma gauss_lemma\n\n",
 "eisenstein_lemma_aux₁":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\nprivate theorem eisenstein_lemma_aux₁ (p : ℕ) [Fact p.prime] [hp2 : Fact (p % 2 = 1)] {a : ℕ} (hap : (a : ZMod p) ≠ 0) :\n    ((finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n            (Ico 1 (p / 2).succ) (a * x) :\n          ℕ) :\n        ZMod 2) =\n      ((Ico 1 (p / 2).succ).filter fun x : ℕ => p / 2 < (a * x : ZMod p).val).card +\n          finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n            (Ico 1 (p / 2).succ) x +\n        (finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n            (Ico 1 (p / 2).succ) (a * x / p) :\n          ℕ) :=\n  have hp2 : (p : ZMod 2) = (1 : ℕ) := (eq_iff_modEq_nat _).2 hp2.1\n  calc\n    ((finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n              (Ico 1 (p / 2).succ) (a * x) :\n            ℕ) :\n          ZMod 2) =\n        ((finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n              (Ico 1 (p / 2).succ) (a * x % p + p * (a * x / p)) :\n            ℕ) :\n          ZMod 2) :=\n      by simp only [mod_add_div]\n    _ =\n        (finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n              (Ico 1 (p / 2).succ) ((a * x : ℕ) : ZMod p).val :\n            ℕ) +\n          (finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n              (Ico 1 (p / 2).succ) (a * x / p) :\n            ℕ) :=\n      by\n      simp only [val_nat_cast] <;> simp [sum_add_distrib, mul_sum.symm, Nat.cast_add, Nat.cast_mul, Nat.cast_sum, hp2]\n    _ = _ :=\n      congr_arg₂ (· + ·)\n        (calc\n          ((finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n                    (Ico 1 (p / 2).succ) ((a * x : ℕ) : ZMod p).val :\n                  ℕ) :\n                ZMod 2) =\n              finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n                (Ico 1 (p / 2).succ)\n                (((a * x : ZMod p).val_min_abs + if (a * x : ZMod p).val ≤ p / 2 then 0 else p : ℤ) : ZMod 2) :=\n            by simp only [(val_eq_ite_val_min_abs _).symm] <;> simp [Nat.cast_sum]\n          _ =\n              ((Ico 1 (p / 2).succ).filter fun x : ℕ => p / 2 < (a * x : ZMod p).val).card +\n                (finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n                    (Ico 1 (p / 2).succ) (a * x : ZMod p).val_min_abs.nat_abs :\n                  ℕ) :=\n            by simp [ite_cast, add_comm, sum_add_distrib, Finset.sum_ite, hp2, Nat.cast_sum]\n          _ = _ := by\n            rw [Finset.sum_eq_multiset_sum, Ico_map_val_min_abs_nat_abs_eq_Ico_map_id p a hap, ←\n                Finset.sum_eq_multiset_sum] <;>\n              simp [Nat.cast_sum]\n          )\n        rfl\n    \n#align eisenstein_lemma_aux₁ eisenstein_lemma_aux₁\n\n",
 "eisenstein_lemma_aux":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≡ [MOD ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem eisenstein_lemma_aux (p : ℕ) [Fact p.prime] [Fact (p % 2 = 1)] {a : ℕ} (ha2 : a % 2 = 1)\n    (hap : (a : ZMod p) ≠ 0) :\n    «expr ≡ [MOD ]» ((Ico 1 (p / 2).succ).filter fun x : ℕ => p / 2 < (a * x : ZMod p).val).card\n      (finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n        (Ico 1 (p / 2).succ) (x * a / p))\n      2 :=\n  have ha2 : (a : ZMod 2) = (1 : ℕ) := (eq_iff_modEq_nat _).2 ha2\n  (eq_iff_modEq_nat 2).1 <|\n    sub_eq_zero.1 <| by\n      simpa [add_left_comm, sub_eq_add_neg, finset.mul_sum.symm, mul_comm, ha2, Nat.cast_sum,\n        add_neg_eq_iff_eq_add.symm, neg_eq_self_mod_two, add_assoc] using Eq.symm (eisenstein_lemma_aux₁ p hap)\n#align eisenstein_lemma_aux eisenstein_lemma_aux\n\n",
 "eisenstein_lemma":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem eisenstein_lemma {p : ℕ} [Fact p.prime] (hp : p ≠ 2) {a : ℕ} (ha1 : a % 2 = 1) (ha0 : (a : ZMod p) ≠ 0) :\n    legendre_sym p a =\n      (-1) ^\n        finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n          (Ico 1 (p / 2).succ) (x * a / p) :=\n  by\n  haveI hp' : Fact (p % 2 = 1) := ⟨nat.prime.mod_two_eq_one_iff_ne_two.mpr hp⟩\n  have ha0' : ((a : ℤ) : ZMod p) ≠ 0 := by\n    norm_cast\n    exact ha0\n  rw [neg_one_pow_eq_pow_mod_two, gauss_lemma hp ha0', neg_one_pow_eq_pow_mod_two,\n    (by norm_cast : ((a : ℤ) : ZMod p) = (a : ZMod p)), show _ = _ from eisenstein_lemma_aux p ha1 ha0]\n#align eisenstein_lemma eisenstein_lemma\n\n",
 "div_eq_filter_card":
 "theorem div_eq_filter_card {a b c : ℕ} (hb0 : 0 < b) (hc : a / b ≤ c) :\n    a / b = ((Ico 1 c.succ).filter fun x => x * b ≤ a).card :=\n  calc\n    a / b = (Ico 1 (a / b).succ).card := by simp\n    _ = ((Ico 1 c.succ).filter fun x => x * b ≤ a).card :=\n      congr_arg _ <|\n        Finset.ext fun x =>\n          by\n          have : x * b ≤ a → x ≤ c := fun h => le_trans (by rwa [le_div_iff_mul_le hb0]) hc\n          simp [lt_succ_iff, le_div_iff_mul_le hb0] <;> tauto\n    \n#align div_eq_filter_card div_eq_filter_card\n\n",
 "Ico_map_val_min_abs_nat_abs_eq_Ico_map_id":
 "/-- The image of the map sending a non zero natural number `x ≤ p / 2` to the absolute value\n  of the element of interger in the interval `(-p/2, p/2]` congruent to `a * x` mod p is the set\n  of non zero natural numbers `x` such that `x ≤ p / 2` -/\ntheorem Ico_map_val_min_abs_nat_abs_eq_Ico_map_id (p : ℕ) [hp : Fact p.prime] (a : ZMod p) (hap : a ≠ 0) :\n    ((Ico 1 (p / 2).succ).1.map fun x => (a * x).val_min_abs.nat_abs) = (Ico 1 (p / 2).succ).1.map fun a => a :=\n  by\n  have he : ∀ {x}, x ∈ Ico 1 (p / 2).succ → x ≠ 0 ∧ x ≤ p / 2 := by\n    simp (config := { contextual := true }) [Nat.lt_succ_iff, Nat.succ_le_iff, pos_iff_ne_zero]\n  have hep : ∀ {x}, x ∈ Ico 1 (p / 2).succ → x < p := fun x hx =>\n    lt_of_le_of_lt (he hx).2 (nat.div_lt_self hp.1.pos (by decide))\n  have hpe : ∀ {x}, x ∈ Ico 1 (p / 2).succ → ¬p ∣ x := fun x hx hpx =>\n    not_lt_of_ge (le_of_dvd (nat.pos_of_ne_zero (he hx).1) hpx) (hep hx)\n  have hmem : ∀ (x : ℕ) (hx : x ∈ Ico 1 (p / 2).succ), (a * x : ZMod p).val_min_abs.nat_abs ∈ Ico 1 (p / 2).succ :=\n    by\n    intro x hx\n    simp [hap, char_p.cast_eq_zero_iff (ZMod p) p, hpe hx, lt_succ_iff, succ_le_iff, pos_iff_ne_zero,\n      nat_abs_val_min_abs_le _]\n  have hsurj :\n    ∀ (b : ℕ) (hb : b ∈ Ico 1 (p / 2).succ), ∃ x ∈ Ico 1 (p / 2).succ, b = (a * x : ZMod p).val_min_abs.nat_abs :=\n    by\n    intro b hb\n    refine' ⟨(b / a : ZMod p).val_min_abs.nat_abs, mem_Ico.mpr ⟨_, _⟩, _⟩\n    · apply nat.pos_of_ne_zero\n      simp only [div_eq_mul_inv, hap, char_p.cast_eq_zero_iff (ZMod p) p, hpe hb, not_false_iff, val_min_abs_eq_zero,\n        inv_eq_zero, Int.natAbs_eq_zero, ne.def, mul_eq_zero, or_self_iff]\n    · apply lt_succ_of_le\n      apply nat_abs_val_min_abs_le\n    · rw [nat_cast_nat_abs_val_min_abs]\n      split_ifs\n      ·\n        erw [mul_div_cancel' _ hap, val_min_abs_def_pos, val_cast_of_lt (hep hb),\n          if_pos (le_of_lt_succ (mem_Ico.1 hb).2), Int.natAbs_ofNat]\n      ·\n        erw [mul_neg, mul_div_cancel' _ hap, nat_abs_val_min_abs_neg, val_min_abs_def_pos, val_cast_of_lt (hep hb),\n          if_pos (le_of_lt_succ (mem_Ico.1 hb).2), Int.natAbs_ofNat]\n  exact\n    Multiset.map_eq_map_of_bij_of_nodup _ _ (finset.nodup _) (finset.nodup _)\n      (fun x _ => (a * x : ZMod p).val_min_abs.nat_abs) hmem (fun _ _ => rfl)\n      (inj_on_of_surj_on_of_card_le _ hmem hsurj le_rfl) hsurj\n#align Ico_map_val_min_abs_nat_abs_eq_Ico_map_id Ico_map_val_min_abs_nat_abs_eq_Ico_map_id\n\n"}