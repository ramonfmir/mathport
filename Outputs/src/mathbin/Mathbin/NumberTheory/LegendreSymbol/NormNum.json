{"zero_right":
 "/-\nCopyright (c) 2022 Michael Stoll. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Michael Stoll\n-/\n/-- Base cases: `b = 0`, `b = 1`, `a = 0`, `a = 1`. -/\ntheorem jacobi_sym_nat.zero_right (a : ℕ) : jacobi_sym_nat a 0 = 1 := by rwa [jacobi_sym_nat, jacobi_sym.zero_right]\n#align jacobi_sym_nat.zero_right jacobi_sym_nat.zero_right\n\n",
 "zero_left_odd":
 "theorem jacobi_sym_nat.zero_left_odd (b : ℕ) (hb : b ≠ 0) : jacobi_sym_nat 0 (bit1 b) = 0 := by\n  rw [jacobi_sym_nat, Nat.cast_zero, jacobi_sym.zero_left (Nat.one_lt_bit1 hb)]\n#align jacobi_sym_nat.zero_left_odd jacobi_sym_nat.zero_left_odd\n\n",
 "zero_left_even":
 "theorem jacobi_sym_nat.zero_left_even (b : ℕ) (hb : b ≠ 0) : jacobi_sym_nat 0 (bit0 b) = 0 := by\n  rw [jacobi_sym_nat, Nat.cast_zero, jacobi_sym.zero_left (Nat.one_lt_bit0 hb)]\n#align jacobi_sym_nat.zero_left_even jacobi_sym_nat.zero_left_even\n\n",
 "to_jacobi_sym":
 "/-- Turn a Legendre symbol into a Jacobi symbol. -/\ntheorem legendre_sym.to_jacobi_sym (p : ℕ) (pp : fact p.prime) (a r : ℤ) (hr : jacobi_sym a p = r) :\n    legendre_sym p a = r := by rwa [@legendre_sym.to_jacobi_sym p pp a]\n#align legendre_sym.to_jacobi_sym legendre_sym.to_jacobi_sym\n\n",
 "qr₃_mod":
 "theorem jacobi_sym_nat.qr₃_mod (a b ab : ℕ) (r : ℤ) (hab : bit1 (bit1 b) % bit1 (bit1 a) = ab)\n    (hr : jacobi_sym_nat ab (bit1 (bit1 a)) = r) : jacobi_sym_nat (bit1 (bit1 a)) (bit1 (bit1 b)) = -r :=\n  jacobi_sym_nat.qr₃ _ _ _ <| jacobi_sym_nat.mod_left _ _ ab r hab hr\n#align jacobi_sym_nat.qr₃_mod jacobi_sym_nat.qr₃_mod\n\n",
 "qr₃":
 "theorem jacobi_sym_nat.qr₃ (a b : ℕ) (r : ℤ) (hr : jacobi_sym_nat (bit1 (bit1 b)) (bit1 (bit1 a)) = r) :\n    jacobi_sym_nat (bit1 (bit1 a)) (bit1 (bit1 b)) = -r :=\n  by\n  have hb : bit1 (bit1 b) % 4 = 3 := by rw [nat.bit1_mod_bit0, Nat.bit1_mod_two]\n  have ha : bit1 (bit1 a) % 4 = 3 := by rw [nat.bit1_mod_bit0, Nat.bit1_mod_two]\n  rwa [jacobi_sym_nat, jacobi_sym.quadratic_reciprocity_three_mod_four ha hb, neg_inj]\n#align jacobi_sym_nat.qr₃ jacobi_sym_nat.qr₃\n\n",
 "qr₁_mod":
 "theorem jacobi_sym_nat.qr₁_mod (a b ab : ℕ) (r : ℤ) (hab : bit1 b % bit1 (bit0 a) = ab)\n    (hr : jacobi_sym_nat ab (bit1 (bit0 a)) = r) : jacobi_sym_nat (bit1 (bit0 a)) (bit1 b) = r :=\n  jacobi_sym_nat.qr₁ _ _ _ <| jacobi_sym_nat.mod_left _ _ ab r hab hr\n#align jacobi_sym_nat.qr₁_mod jacobi_sym_nat.qr₁_mod\n\n",
 "qr₁'_mod":
 "theorem jacobi_sym_nat.qr₁'_mod (a b ab : ℕ) (r : ℤ) (hab : bit1 (bit0 b) % bit1 a = ab)\n    (hr : jacobi_sym_nat ab (bit1 a) = r) : jacobi_sym_nat (bit1 a) (bit1 (bit0 b)) = r :=\n  jacobi_sym_nat.qr₁' _ _ _ <| jacobi_sym_nat.mod_left _ _ ab r hab hr\n#align jacobi_sym_nat.qr₁'_mod jacobi_sym_nat.qr₁'_mod\n\n",
 "qr₁'":
 "theorem jacobi_sym_nat.qr₁' (a b : ℕ) (r : ℤ) (hr : jacobi_sym_nat (bit1 (bit0 b)) (bit1 a) = r) :\n    jacobi_sym_nat (bit1 a) (bit1 (bit0 b)) = r :=\n  by\n  have hb : bit1 (bit0 b) % 4 = 1 := by rw [nat.bit1_mod_bit0, Nat.bit0_mod_two]\n  have ha := Nat.bit1_mod_two\n  rwa [jacobi_sym_nat, ← jacobi_sym.quadratic_reciprocity_one_mod_four hb (nat.odd_iff.mpr ha)]\n#align jacobi_sym_nat.qr₁' jacobi_sym_nat.qr₁'\n\n",
 "qr₁":
 "/-- Use quadratic reciproity to reduce to smaller `b`. -/\ntheorem jacobi_sym_nat.qr₁ (a b : ℕ) (r : ℤ) (hr : jacobi_sym_nat (bit1 b) (bit1 (bit0 a)) = r) :\n    jacobi_sym_nat (bit1 (bit0 a)) (bit1 b) = r :=\n  by\n  have ha : bit1 (bit0 a) % 4 = 1 := by rw [nat.bit1_mod_bit0, Nat.bit0_mod_two]\n  have hb := Nat.bit1_mod_two\n  rwa [jacobi_sym_nat, jacobi_sym.quadratic_reciprocity_one_mod_four ha (nat.odd_iff.mpr hb)]\n#align jacobi_sym_nat.qr₁ jacobi_sym_nat.qr₁\n\n",
 "one_right":
 "theorem jacobi_sym_nat.one_right (a : ℕ) : jacobi_sym_nat a 1 = 1 := by rwa [jacobi_sym_nat, jacobi_sym.one_right]\n#align jacobi_sym_nat.one_right jacobi_sym_nat.one_right\n\n",
 "one_left_odd":
 "theorem jacobi_sym_nat.one_left_odd (b : ℕ) : jacobi_sym_nat 1 (bit1 b) = 1 := by\n  rw [jacobi_sym_nat, Nat.cast_one, jacobi_sym.one_left]\n#align jacobi_sym_nat.one_left_odd jacobi_sym_nat.one_left_odd\n\n",
 "one_left_even":
 "theorem jacobi_sym_nat.one_left_even (b : ℕ) : jacobi_sym_nat 1 (bit0 b) = 1 := by\n  rw [jacobi_sym_nat, Nat.cast_one, jacobi_sym.one_left]\n#align jacobi_sym_nat.one_left_even jacobi_sym_nat.one_left_even\n\n",
 "odd_even":
 "/-- When `a` is odd and `b` is even, we can replace `b` by `b / 2`. -/\ntheorem jacobi_sym_nat.odd_even (a b : ℕ) (r : ℤ) (hr : jacobi_sym_nat (bit1 a) b = r) :\n    jacobi_sym_nat (bit1 a) (bit0 b) = r :=\n  by\n  have ha : legendre_sym 2 (bit1 a) = 1 := by\n    simp only [legendre_sym, quadratic_char_apply, quadratic_char_fun_one, Int.cast_bit1, char_two.bit1_eq_one,\n      pi.one_apply]\n  cases' eq_or_ne b 0 with hb hb\n  · rw [← hr, hb, jacobi_sym_nat.zero_right]\n  · haveI : ne_zero b := ⟨hb⟩\n    -- for `jacobi_sym.mul_right`\n    rwa [bit0_eq_two_mul b, jacobi_sym_nat, jacobi_sym.mul_right, ← _root_.legendre_sym.to_jacobi_sym, Nat.cast_bit1,\n      ha, one_mul]\n#align jacobi_sym_nat.odd_even jacobi_sym_nat.odd_even\n\n",
 "mod_left":
 "theorem jacobi_sym_nat.mod_left (a b ab : ℕ) (r : ℤ) (hab : a % b = ab) (hr : jacobi_sym_nat ab b = r) :\n    jacobi_sym_nat a b = r :=\n  by\n  rw [← hr, jacobi_sym_nat, jacobi_sym_nat, _root_.jacobi_sym.mod_left a b, ← hab]\n  rfl\n#align jacobi_sym_nat.mod_left jacobi_sym_nat.mod_left\n\n",
 "even_odd₇":
 "theorem jacobi_sym_nat.even_odd₇ (a b : ℕ) (r : ℤ) (hr : jacobi_sym_nat a (bit1 (bit1 (bit1 b))) = r) :\n    jacobi_sym_nat (bit0 a) (bit1 (bit1 (bit1 b))) = r :=\n  by\n  have hb : bit1 (bit1 (bit1 b)) % 8 = 7 := by rw [nat.bit1_mod_bit0, nat.bit1_mod_bit0, Nat.bit1_mod_two]\n  rw [jacobi_sym_nat, bit0_eq_two_mul a, nat.cast_mul, jacobi_sym.mul_left, Nat.cast_two,\n    jacobi_sym.at_two (odd_bit1 _), zmod.χ₈_nat_mod_eight, hb]\n  norm_num\n  exact hr\n#align jacobi_sym_nat.even_odd₇ jacobi_sym_nat.even_odd₇\n\n",
 "even_odd₅":
 "theorem jacobi_sym_nat.even_odd₅ (a b : ℕ) (r : ℤ) (hr : jacobi_sym_nat a (bit1 (bit0 (bit1 b))) = r) :\n    jacobi_sym_nat (bit0 a) (bit1 (bit0 (bit1 b))) = -r :=\n  by\n  have hb : bit1 (bit0 (bit1 b)) % 8 = 5 := by rw [nat.bit1_mod_bit0, nat.bit0_mod_bit0, Nat.bit1_mod_two]\n  rw [jacobi_sym_nat, bit0_eq_two_mul a, nat.cast_mul, jacobi_sym.mul_left, Nat.cast_two,\n    jacobi_sym.at_two (odd_bit1 _), zmod.χ₈_nat_mod_eight, hb]\n  norm_num\n  exact hr\n#align jacobi_sym_nat.even_odd₅ jacobi_sym_nat.even_odd₅\n\n",
 "even_odd₃":
 "theorem jacobi_sym_nat.even_odd₃ (a b : ℕ) (r : ℤ) (hr : jacobi_sym_nat a (bit1 (bit1 (bit0 b))) = r) :\n    jacobi_sym_nat (bit0 a) (bit1 (bit1 (bit0 b))) = -r :=\n  by\n  have hb : bit1 (bit1 (bit0 b)) % 8 = 3 := by rw [nat.bit1_mod_bit0, nat.bit1_mod_bit0, Nat.bit0_mod_two]\n  rw [jacobi_sym_nat, bit0_eq_two_mul a, nat.cast_mul, jacobi_sym.mul_left, Nat.cast_two,\n    jacobi_sym.at_two (odd_bit1 _), zmod.χ₈_nat_mod_eight, hb]\n  norm_num\n  exact hr\n#align jacobi_sym_nat.even_odd₃ jacobi_sym_nat.even_odd₃\n\n",
 "even_odd₁":
 "/-- If `a` is even and `b` is odd, then we can remove a factor `2` from `a`,\nbut we may have to change the sign, depending on `b % 8`.\nWe give one version for each of the four odd residue classes mod `8`. -/\ntheorem jacobi_sym_nat.even_odd₁ (a b : ℕ) (r : ℤ) (hr : jacobi_sym_nat a (bit1 (bit0 (bit0 b))) = r) :\n    jacobi_sym_nat (bit0 a) (bit1 (bit0 (bit0 b))) = r :=\n  by\n  have hb : bit1 (bit0 (bit0 b)) % 8 = 1 := by rw [nat.bit1_mod_bit0, nat.bit0_mod_bit0, Nat.bit0_mod_two]\n  rw [jacobi_sym_nat, bit0_eq_two_mul a, nat.cast_mul, jacobi_sym.mul_left, Nat.cast_two,\n    jacobi_sym.at_two (odd_bit1 _), zmod.χ₈_nat_mod_eight, hb]\n  norm_num\n  exact hr\n#align jacobi_sym_nat.even_odd₁ jacobi_sym_nat.even_odd₁\n\n",
 "even_even":
 "/-- The symbol vanishes when both entries are even (and `b ≠ 0`). -/\ntheorem jacobi_sym_nat.even_even (a b : ℕ) (hb₀ : b ≠ 0) : jacobi_sym_nat (bit0 a) (bit0 b) = 0 :=\n  by\n  refine' jacobi_sym.eq_zero_iff.mpr ⟨Nat.bit0_ne_zero hb₀, fun hf => _⟩\n  have h : 2 ∣ (bit0 a).gcd (bit0 b) := nat.dvd_gcd two_dvd_bit0 two_dvd_bit0\n  change 2 ∣ (bit0 a : ℤ).gcd (bit0 b) at h\n  rw [← Nat.cast_bit0, ← Nat.cast_bit0, hf, ← even_iff_two_dvd] at h\n  exact nat.not_even_one h\n#align jacobi_sym_nat.even_even jacobi_sym_nat.even_even\n\n",
 "double_even":
 "/-- If `a` is divisible by `4` and `b` is odd, then we can remove the factor `4` from `a`. -/\ntheorem jacobi_sym_nat.double_even (a b : ℕ) (r : ℤ) (hr : jacobi_sym_nat a (bit1 b) = r) :\n    jacobi_sym_nat (bit0 (bit0 a)) (bit1 b) = r :=\n  by\n  have : ((2 : ℕ) : ℤ).gcd (bit1 b : ℕ) = 1 := by\n    rw [Int.coe_nat_gcd, Nat.bit1_eq_succ_bit0, bit0_eq_two_mul b, nat.succ_eq_add_one, Nat.gcd_mul_left_add_right,\n      nat.gcd_one_right]\n  rwa [bit0_eq_two_mul a, bit0_eq_two_mul (2 * a), ← mul_assoc, ← pow_two, jacobi_sym_nat, nat.cast_mul, Nat.cast_pow,\n    jacobi_sym.mul_left, jacobi_sym.sq_one' this, one_mul]\n#align jacobi_sym_nat.double_even jacobi_sym_nat.double_even\n\n"}