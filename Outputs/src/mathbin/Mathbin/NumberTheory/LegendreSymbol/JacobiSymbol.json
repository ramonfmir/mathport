{"zero_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprJ( | )» -/\n/-\nCopyright (c) 2022 Michael Stoll. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Michael Stoll\n-/\n-- Since we need the fact that the factors are prime, we use `list.pmap`.\n-- Notation for the Jacobi symbol.\n/-- The symbol `J(a | 0)` has the value `1`. -/\n@[simp]\ntheorem zero_right (a : ℤ) : «exprJ( | )» a 0 = 1 := by simp only [jacobi_sym, factors_zero, List.prod_nil, List.pmap]\n#align zero_right zero_right\n\n",
 "zero_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprJ( | )» -/\n/-- The symbol `J(0 | b)` vanishes when `b > 1`. -/\ntheorem zero_left {b : ℕ} (hb : 1 < b) : «exprJ( | )» 0 b = 0 :=\n  (@eq_zero_iff_not_coprime 0 b ⟨ne_zero_of_lt hb⟩).mpr <|\n    by\n    rw [Int.gcd_zero_left, Int.natAbs_ofNat]\n    exact hb.ne'\n#align zero_left zero_left\n\n",
 "value_at":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprJ( | )» -/\n/-- If `χ` is a multiplicative function such that `J(a | p) = χ p` for all odd primes `p`,\nthen `J(a | b)` equals `χ b` for all odd natural numbers `b`. -/\ntheorem value_at (a : ℤ) {R : Type _} [CommSemiring R] (χ : «expr →* » R ℤ)\n    (hp : ∀ (p : ℕ) (pp : p.prime) (h2 : p ≠ 2), @legendre_sym p ⟨pp⟩ a = χ p) {b : ℕ} (hb : Odd b) :\n    «exprJ( | )» a b = χ b :=\n  by\n  conv_rhs => rw [← prod_factors hb.pos.ne', cast_list_prod, χ.map_list_prod]\n  rw [jacobi_sym, list.map_map, ← List.pmap_eq_map Nat.Prime _ _ fun _ => prime_of_mem_factors]\n  congr 1; apply List.pmap_congr\n  exact fun p h pp _ => hp p pp (hb.factors_ne_two h)\n#align value_at value_at\n\n",
 "trichotomy":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprJ( | )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprJ( | )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprJ( | )» -/\n/-- The Jacobi symbol takes only the values `0`, `1` and `-1`. -/\ntheorem trichotomy (a : ℤ) (b : ℕ) : «exprJ( | )» a b = 0 ∨ «exprJ( | )» a b = 1 ∨ «exprJ( | )» a b = -1 :=\n  ((@sign_type.cast_hom ℤ _ _).to_monoid_hom.mrange.copy {0, 1, -1} <|\n        by\n        rw [Set.pair_comm]\n        exact (sign_type.range_eq sign_type.cast_hom).symm).list_prod_mem\n    (by\n      intro _ ha'\n      rcases list.mem_pmap.mp ha' with ⟨p, hp, rfl⟩\n      haveI : fact p.prime := ⟨prime_of_mem_factors hp⟩\n      exact quadratic_char_is_quadratic (zmod p) a)\n#align trichotomy trichotomy\n\n",
 "to_jacobi_sym":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprJ( | )» -/\n/-- The Legendre symbol `legendre_sym p a` with an integer `a` and a prime number `p`\nis the same as the Jacobi symbol `J(a | p)`. -/\ntheorem _root_.legendre_sym.to_jacobi_sym (p : ℕ) [fp : fact p.prime] (a : ℤ) : legendre_sym p a = «exprJ( | )» a p :=\n  by simp only [jacobi_sym, factors_prime fp.1, List.prod_cons, List.prod_nil, mul_one, List.pmap]\n#align legendre_sym.to_jacobi_sym legendre_sym.to_jacobi_sym\n\n",
 "symm":
 "#print symm /-\n/-- `qr_sign` is symmetric when both arguments are odd. -/\nprotected theorem symm {m n : ℕ} (hm : Odd m) (hn : Odd n) : qr_sign m n = qr_sign n m := by\n  rw [neg_one_pow hm hn, neg_one_pow hn hm, mul_comm (m / 2)]\n#align symm symm\n-/\n\n",
 "sq_one'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprJ( | )» -/\n/-- The symbol `J(a^2 | b)` is `1` when `a` and `b` are coprime. -/\ntheorem sq_one' {a : ℤ} {b : ℕ} (h : a.gcd b = 1) : «exprJ( | )» (a ^ 2) b = 1 := by rw [pow_left, sq_one h]\n#align sq_one' sq_one'\n\n",
 "sq_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprJ( | )» -/\n/-- The square of `J(a | b)` is `1` when `a` and `b` are coprime. -/\ntheorem sq_one {a : ℤ} {b : ℕ} (h : a.gcd b = 1) : «exprJ( | )» a b ^ 2 = 1 := by\n  cases' eq_one_or_neg_one h with h₁ h₁ <;> rw [h₁] <;> rfl\n#align sq_one sq_one\n\n",
 "sq_eq_one":
 "/-- When `m` and `n` are odd, then the square of `qr_sign m n` is `1`. -/\ntheorem sq_eq_one {m n : ℕ} (hm : Odd m) (hn : Odd n) : qr_sign m n ^ 2 = 1 := by\n  rw [neg_one_pow hm hn, ← pow_mul, mul_comm, pow_mul, neg_one_sq, one_pow]\n#align sq_eq_one sq_eq_one\n\n",
 "quadratic_reciprocity_three_mod_four":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprJ( | )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprJ( | )» -/\n/-- The Law of Quadratic Reciprocityfor the Jacobi symbol: if `a` and `b` are natural numbers\nboth congruent to `3` mod `4`, then `J(a | b) = -J(b | a)`. -/\ntheorem quadratic_reciprocity_three_mod_four {a b : ℕ} (ha : a % 4 = 3) (hb : b % 4 = 3) :\n    «exprJ( | )» a b = -«exprJ( | )» b a :=\n  by\n  let nop := @neg_one_pow_div_two_of_three_mod_four\n  rw [quadratic_reciprocity, pow_mul, nop ha, nop hb, neg_one_mul] <;> rwa [odd_iff, odd_of_mod_four_eq_three]\n#align quadratic_reciprocity_three_mod_four quadratic_reciprocity_three_mod_four\n\n",
 "quadratic_reciprocity_one_mod_four'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprJ( | )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprJ( | )» -/\n/-- The Law of Quadratic Reciprocity for the Jacobi symbol: if `a` and `b` are natural numbers\nwith `a` odd and `b % 4 = 1`, then `J(a | b) = J(b | a)`. -/\ntheorem quadratic_reciprocity_one_mod_four' {a b : ℕ} (ha : Odd a) (hb : b % 4 = 1) :\n    «exprJ( | )» a b = «exprJ( | )» b a :=\n  (quadratic_reciprocity_one_mod_four hb ha).symm\n#align quadratic_reciprocity_one_mod_four' quadratic_reciprocity_one_mod_four'\n\n",
 "quadratic_reciprocity_one_mod_four":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprJ( | )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprJ( | )» -/\n/-- The Law of Quadratic Reciprocity for the Jacobi symbol: if `a` and `b` are natural numbers\nwith `a % 4 = 1` and `b` odd, then `J(a | b) = J(b | a)`. -/\ntheorem quadratic_reciprocity_one_mod_four {a b : ℕ} (ha : a % 4 = 1) (hb : Odd b) :\n    «exprJ( | )» a b = «exprJ( | )» b a := by\n  rw [quadratic_reciprocity (odd_iff.mpr (odd_of_mod_four_eq_one ha)) hb, pow_mul,\n    neg_one_pow_div_two_of_one_mod_four ha, one_pow, one_mul]\n#align quadratic_reciprocity_one_mod_four quadratic_reciprocity_one_mod_four\n\n",
 "quadratic_reciprocity'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprJ( | )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprJ( | )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprJ( | )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprJ( | )» -/\n/-- The Law of Quadratic Reciprocity for the Jacobi symbol, version with `qr_sign` -/\ntheorem quadratic_reciprocity' {a b : ℕ} (ha : Odd a) (hb : Odd b) :\n    «exprJ( | )» a b = qr_sign b a * «exprJ( | )» b a :=\n  by\n  -- define the right hand side for fixed `a` as a `ℕ →* ℤ`\n  let rhs : ℕ → «expr →* » ℕ ℤ := fun a =>\n    { to_fun := fun x => qr_sign x a * «exprJ( | )» x a\n      map_one' := by\n        convert ← mul_one _\n        symm\n        all_goals apply one_left\n      map_mul' := fun x y => by rw [qr_sign.mul_left, nat.cast_mul, mul_left, mul_mul_mul_comm] }\n  have rhs_apply : ∀ a b : ℕ, rhs a b = qr_sign b a * «exprJ( | )» b a := fun a b => rfl\n  refine' value_at a (rhs a) (fun p pp hp => eq.symm _) hb\n  have hpo := pp.eq_two_or_odd'.resolve_left hp\n  rw [@legendre_sym.to_jacobi_sym p ⟨pp⟩, rhs_apply, nat.cast_id, qr_sign.eq_iff_eq hpo ha, qr_sign.symm hpo ha]\n  refine' value_at p (rhs p) (fun q pq hq => _) ha\n  have hqo := pq.eq_two_or_odd'.resolve_left hq\n  rw [rhs_apply, nat.cast_id, ← @legendre_sym.to_jacobi_sym p ⟨pp⟩, qr_sign.symm hqo hpo, qr_sign.neg_one_pow hpo hqo,\n    @legendre_sym.quadratic_reciprocity' p q ⟨pp⟩ ⟨pq⟩ hp hq]\n#align quadratic_reciprocity' quadratic_reciprocity'\n\n",
 "quadratic_reciprocity":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprJ( | )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprJ( | )» -/\n/-- The Law of Quadratic Reciprocity for the Jacobi symbol -/\ntheorem quadratic_reciprocity {a b : ℕ} (ha : Odd a) (hb : Odd b) :\n    «exprJ( | )» a b = (-1) ^ (a / 2 * (b / 2)) * «exprJ( | )» b a := by\n  rw [← qr_sign.neg_one_pow ha hb, qr_sign.symm ha hb, quadratic_reciprocity' ha hb]\n#align quadratic_reciprocity quadratic_reciprocity\n\n",
 "pow_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprJ( | )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprJ( | )» -/\n/-- We have that `J(a | b^e) = J(a | b)^e`. -/\ntheorem pow_right (a : ℤ) (b e : ℕ) : «exprJ( | )» a (b ^ e) = «exprJ( | )» a b ^ e :=\n  by\n  induction' e with e ih\n  · rw [pow_zero, pow_zero, one_right]\n  · cases' eq_zero_or_neZero b with hb\n    · rw [hb, zero_pow (succ_pos e), zero_right, one_pow]\n    · rw [pow_succ, pow_succ, mul_right, ih]\n#align pow_right pow_right\n\n",
 "pow_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprJ( | )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprJ( | )» -/\n/-- We have that `J(a^e | b) = J(a | b)^e`. -/\ntheorem pow_left (a : ℤ) (e b : ℕ) : «exprJ( | )» (a ^ e) b = «exprJ( | )» a b ^ e :=\n  nat.rec_on e (by rw [pow_zero, pow_zero, one_left]) fun _ ih => by rw [pow_succ, pow_succ, mul_left, ih]\n#align pow_left pow_left\n\n",
 "one_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprJ( | )» -/\n/-- The symbol `J(a | 1)` has the value `1`. -/\n@[simp]\ntheorem one_right (a : ℤ) : «exprJ( | )» a 1 = 1 := by simp only [jacobi_sym, factors_one, List.prod_nil, List.pmap]\n#align one_right one_right\n\n",
 "one_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprJ( | )» -/\n/-- The symbol `J(1 | b)` has the value `1`. -/\n@[simp]\ntheorem one_left (b : ℕ) : «exprJ( | )» 1 b = 1 :=\n  List.prod_eq_one fun z hz => by\n    let ⟨p, hp, he⟩ := List.mem_pmap.1 hz\n    rw [← he, legendre_sym.at_one]\n#align one_left one_left\n\n",
 "nonsquare_of_jacobi_sym_eq_neg_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprJ( | )» -/\n/-- If `J(a | b)` is `-1`, then `a` is not a square modulo `b`. -/\ntheorem nonsquare_of_jacobi_sym_eq_neg_one {a : ℤ} {b : ℕ} (h : «exprJ( | )» a b = -1) : ¬IsSquare (a : zmod b) :=\n  fun ⟨r, ha⟩ => by\n  rw [← r.coe_val_min_abs, ← Int.cast_mul, int_coe_eq_int_coe_iff', ← sq] at ha\n  apply (by norm_num : ¬(0 : ℤ) ≤ -1)\n  rw [← h, mod_left, ha, ← mod_left, pow_left]\n  apply sq_nonneg\n#align nonsquare_of_jacobi_sym_eq_neg_one nonsquare_of_jacobi_sym_eq_neg_one\n\n",
 "nonsquare_iff_jacobi_sym_eq_neg_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprJ( | )» -/\n/-- If `p` is prime, then `J(a | p)` is `-1` iff `a` is not a square modulo `p`. -/\ntheorem nonsquare_iff_jacobi_sym_eq_neg_one {a : ℤ} {p : ℕ} [fact p.prime] :\n    «exprJ( | )» a p = -1 ↔ ¬IsSquare (a : zmod p) :=\n  by\n  rw [← legendre_sym.to_jacobi_sym]\n  exact legendre_sym.eq_neg_one_iff p\n#align nonsquare_iff_jacobi_sym_eq_neg_one nonsquare_iff_jacobi_sym_eq_neg_one\n\n",
 "neg_one_pow":
 "/-- We can express `qr_sign m n` as a power of `-1` when `m` and `n` are odd. -/\ntheorem neg_one_pow {m n : ℕ} (hm : Odd m) (hn : Odd n) : qr_sign m n = (-1) ^ (m / 2 * (n / 2)) :=\n  by\n  rw [qr_sign, pow_mul, ← χ₄_eq_neg_one_pow (odd_iff.mp hm)]\n  cases' odd_mod_four_iff.mp (odd_iff.mp hm) with h h\n  · rw [χ₄_nat_one_mod_four h, jacobi_sym.one_left, one_pow]\n  · rw [χ₄_nat_three_mod_four h, ← χ₄_eq_neg_one_pow (odd_iff.mp hn), jacobi_sym.at_neg_one hn]\n#align neg_one_pow neg_one_pow\n\n",
 "neg":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprJ( | )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprJ( | )» -/\n/-- If `b` is odd, then `J(-a | b) = χ₄ b * J(a | b)`. -/\nprotected theorem neg (a : ℤ) {b : ℕ} (hb : Odd b) : «exprJ( | )» (-a) b = χ₄ b * «exprJ( | )» a b := by\n  rw [neg_eq_neg_one_mul, mul_left, at_neg_one hb]\n#align neg neg\n\n",
 "ne_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprJ( | )» -/\n/-- The symbol `J(a | b)` is nonzero when `a` and `b` are coprime. -/\nprotected theorem ne_zero {a : ℤ} {b : ℕ} (h : a.gcd b = 1) : «exprJ( | )» a b ≠ 0 :=\n  by\n  cases' eq_zero_or_neZero b with hb\n  · rw [hb, zero_right]\n    exact one_ne_zero\n  · contrapose! h\n    exact eq_zero_iff_not_coprime.1 h\n#align ne_zero ne_zero\n\n",
 "mul_right'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprJ( | )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprJ( | )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprJ( | )» -/\n/-- The Jacobi symbol is multiplicative in its second argument. -/\ntheorem mul_right' (a : ℤ) {b₁ b₂ : ℕ} (hb₁ : b₁ ≠ 0) (hb₂ : b₂ ≠ 0) :\n    «exprJ( | )» a (b₁ * b₂) = «exprJ( | )» a b₁ * «exprJ( | )» a b₂ :=\n  by\n  rw [jacobi_sym, ((perm_factors_mul hb₁ hb₂).pmap _).prod_eq, List.pmap_append, List.prod_append]\n  exacts[rfl, fun p hp => (list.mem_append.mp hp).elim prime_of_mem_factors prime_of_mem_factors]\n#align mul_right' mul_right'\n\n",
 "mul_right":
 "/-- `qr_sign` is multiplicative in the second argument. -/\ntheorem mul_right (m n₁ n₂ : ℕ) [ne_zero n₁] [ne_zero n₂] : qr_sign m (n₁ * n₂) = qr_sign m n₁ * qr_sign m n₂ :=\n  jacobi_sym.mul_right (χ₄ m) n₁ n₂\n#align mul_right mul_right\n\n",
 "mul_left":
 "/-- `qr_sign` is multiplicative in the first argument. -/\ntheorem mul_left (m₁ m₂ n : ℕ) : qr_sign (m₁ * m₂) n = qr_sign m₁ n * qr_sign m₂ n := by\n  simp_rw [qr_sign, nat.cast_mul, map_mul, jacobi_sym.mul_left]\n#align mul_left mul_left\n\n",
 "mod_right'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprJ( | )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprJ( | )» -/\n/-- The Jacobi symbol `J(a | b)` depends only on `b` mod `4*a` (version for `a : ℕ`). -/\ntheorem mod_right' (a : ℕ) {b : ℕ} (hb : Odd b) : «exprJ( | )» a b = «exprJ( | )» a (b % (4 * a)) :=\n  by\n  rcases eq_or_ne a 0 with (rfl | ha₀)\n  · rw [mul_zero, mod_zero]\n  have hb' : Odd (b % (4 * a)) := hb.mod_even (Even.mul_right (by norm_num) _)\n  rcases exists_eq_pow_mul_and_not_dvd ha₀ 2 (by norm_num) with ⟨e, a', ha₁', ha₂⟩\n  have ha₁ := odd_iff.mpr (two_dvd_ne_zero.mp ha₁')\n  nth_rw 2 [ha₂]; nth_rw 1 [ha₂]\n  rw [nat.cast_mul, mul_left, mul_left, quadratic_reciprocity' ha₁ hb, quadratic_reciprocity' ha₁ hb', Nat.cast_pow,\n    pow_left, pow_left, Nat.cast_two, at_two hb, at_two hb']\n  congr 1; swap; congr 1\n  · simp_rw [qr_sign]\n    rw [χ₄_nat_mod_four, χ₄_nat_mod_four (b % (4 * a)), mod_mod_of_dvd b (dvd_mul_right 4 a)]\n  · rw [mod_left ↑(b % _), mod_left b, Int.coe_nat_mod, Int.emod_emod_of_dvd b]\n    simp only [ha₂, nat.cast_mul, ← mul_assoc]\n    exact dvd_mul_left a' _\n  cases e; · rfl\n  · rw [χ₈_nat_mod_eight, χ₈_nat_mod_eight (b % (4 * a)), mod_mod_of_dvd b]\n    use 2 ^ e * a'\n    rw [ha₂, pow_succ]\n    ring\n#align mod_right' mod_right'\n\n",
 "mod_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprJ( | )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprJ( | )» -/\n/-- The Jacobi symbol `J(a | b)` depends only on `b` mod `4*a`. -/\ntheorem mod_right (a : ℤ) {b : ℕ} (hb : Odd b) : «exprJ( | )» a b = «exprJ( | )» a (b % (4 * a.nat_abs)) :=\n  by\n  cases' Int.natAbs_eq a with ha ha <;> nth_rw 2 [ha] <;> nth_rw 1 [ha]\n  · exact mod_right' a.nat_abs hb\n  · have hb' : Odd (b % (4 * a.nat_abs)) := hb.mod_even (Even.mul_right (by norm_num) _)\n    rw [jacobi_sym.neg _ hb, jacobi_sym.neg _ hb', mod_right' _ hb, χ₄_nat_mod_four, χ₄_nat_mod_four (b % (4 * _)),\n      mod_mod_of_dvd b (dvd_mul_right 4 _)]\n#align mod_right mod_right\n\n",
 "mod_left'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprJ( | )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprJ( | )» -/\n/-- The symbol `J(a | b)` depends only on `a` mod `b`. -/\ntheorem mod_left' {a₁ a₂ : ℤ} {b : ℕ} (h : a₁ % b = a₂ % b) : «exprJ( | )» a₁ b = «exprJ( | )» a₂ b := by\n  rw [mod_left, h, ← mod_left]\n#align mod_left' mod_left'\n\n",
 "mod_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprJ( | )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprJ( | )» -/\n/-- The symbol `J(a | b)` depends only on `a` mod `b`. -/\ntheorem mod_left (a : ℤ) (b : ℕ) : «exprJ( | )» a b = «exprJ( | )» (a % b) b :=\n  congr_arg List.prod <|\n    List.pmap_congr _\n      (by\n        rintro p hp _ _\n        conv_rhs =>\n          rw [legendre_sym.mod, Int.emod_emod_of_dvd _ (Int.coe_nat_dvd.2 <| dvd_of_mem_factors hp), ←\n            legendre_sym.mod])\n#align mod_left mod_left\n\n",
 "is_square_of_jacobi_sym_eq_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprJ( | )» -/\n/-- If `p` is prime and `J(a | p) = 1`, then `a` is q square mod `p`. -/\ntheorem is_square_of_jacobi_sym_eq_one {a : ℤ} {p : ℕ} [fact p.prime] (h : «exprJ( | )» a p = 1) :\n    IsSquare (a : zmod p) :=\n  not_not.mp <| by\n    rw [← nonsquare_iff_jacobi_sym_eq_neg_one, h]\n    decide\n#align is_square_of_jacobi_sym_eq_one is_square_of_jacobi_sym_eq_one\n\n",
 "eq_zero_iff_not_coprime":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprJ( | )» -/\n/-- The symbol `J(a | b)` vanishes iff `a` and `b` are not coprime (assuming `b ≠ 0`). -/\ntheorem eq_zero_iff_not_coprime {a : ℤ} {b : ℕ} [ne_zero b] : «exprJ( | )» a b = 0 ↔ a.gcd b ≠ 1 :=\n  List.prod_eq_zero_iff.trans\n    (by\n      rw [List.mem_pmap, int.gcd_eq_nat_abs, ne, prime.not_coprime_iff_dvd]\n      simp_rw [legendre_sym.eq_zero_iff, int_coe_zmod_eq_zero_iff_dvd, mem_factors (ne_zero.ne b), ←\n        Int.coe_nat_dvd_left, Int.coe_nat_dvd, exists_prop, and_assoc', and_comm'])\n#align eq_zero_iff_not_coprime eq_zero_iff_not_coprime\n\n",
 "eq_zero_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprJ( | )» -/\n/-- The symbol `J(a | b)` vanishes if and only if `b ≠ 0` and `a` and `b` are not coprime. -/\ntheorem eq_zero_iff {a : ℤ} {b : ℕ} : «exprJ( | )» a b = 0 ↔ b ≠ 0 ∧ a.gcd b ≠ 1 :=\n  ⟨fun h => by\n    cases' eq_or_ne b 0 with hb hb\n    · rw [hb, zero_right] at h\n      cases h\n    exact ⟨hb, mt jacobi_sym.ne_zero <| not_not.2 h⟩, fun ⟨hb, h⟩ =>\n    by\n    rw [← neZero_iff] at hb\n    exact eq_zero_iff_not_coprime.2 h⟩\n#align eq_zero_iff eq_zero_iff\n\n",
 "eq_one_or_neg_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprJ( | )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprJ( | )» -/\n/-- The symbol `J(a | b)` takes the value `1` or `-1` if `a` and `b` are coprime. -/\ntheorem eq_one_or_neg_one {a : ℤ} {b : ℕ} (h : a.gcd b = 1) : «exprJ( | )» a b = 1 ∨ «exprJ( | )» a b = -1 :=\n  (trichotomy a b).resolve_left <| jacobi_sym.ne_zero h\n#align eq_one_or_neg_one eq_one_or_neg_one\n\n",
 "eq_iff_eq":
 "/-- We can move `qr_sign m n` from one side of an equality to the other when `m` and `n` are odd. -/\ntheorem eq_iff_eq {m n : ℕ} (hm : Odd m) (hn : Odd n) (x y : ℤ) : qr_sign m n * x = y ↔ x = qr_sign m n * y := by\n  refine'\n      ⟨fun h' =>\n        let h := h'.symm\n        _,\n        fun h => _⟩ <;>\n    rw [h, ← mul_assoc, ← pow_two, sq_eq_one hm hn, one_mul]\n#align eq_iff_eq eq_iff_eq\n\n",
 "at_two":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprJ( | )» -/\n/-- If `b` is odd, then `J(2 | b)` is given by `χ₈ b`. -/\ntheorem at_two {b : ℕ} (hb : Odd b) : «exprJ( | )» 2 b = χ₈ b :=\n  value_at 2 χ₈ (fun p pp => @legendre_sym.at_two p ⟨pp⟩) hb\n#align at_two at_two\n\n",
 "at_neg_two":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprJ( | )» -/\n/-- If `b` is odd, then `J(-2 | b)` is given by `χ₈' b`. -/\ntheorem at_neg_two {b : ℕ} (hb : Odd b) : «exprJ( | )» (-2) b = χ₈' b :=\n  value_at (-2) χ₈' (fun p pp => @legendre_sym.at_neg_two p ⟨pp⟩) hb\n#align at_neg_two at_neg_two\n\n",
 "at_neg_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprJ( | )» -/\n/-- If `b` is odd, then `J(-1 | b)` is given by `χ₄ b`. -/\ntheorem at_neg_one {b : ℕ} (hb : Odd b) : «exprJ( | )» (-1) b = χ₄ b :=\n  value_at (-1) χ₄ (fun p pp => @legendre_sym.at_neg_one p ⟨pp⟩) hb\n#align at_neg_one at_neg_one\n\n"}