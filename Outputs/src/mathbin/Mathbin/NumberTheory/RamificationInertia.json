{"sum_ramification_inertia":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/-- The **fundamental identity** of ramification index `e` and inertia degree `f`:\nfor `P` ranging over the primes lying over `p`, `∑ P, e P * f P = [Frac(S) : Frac(R)]`;\nhere `S` is a finite `R`-module (and thus `Frac(S) : Frac(R)` is a finite extension) and `p`\nis maximal.\n-/\ntheorem sum_ramification_inertia (K L : Type _) [Field K] [Field L] [IsDomain R] [is_dedekind_domain R] [algebra R K]\n    [is_fraction_ring R K] [algebra S L] [is_fraction_ring S L] [algebra K L] [algebra R L] [IsScalarTower R S L]\n    [IsScalarTower R K L] [is_noetherian R S] [is_integral_closure S R L] [p.is_maximal] (hp0 : p ≠ «expr⊥») :\n    finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n        (factors (map (algebra_map R S) p)).to_finset\n        (ramification_idx (algebra_map R S) p P * inertia_deg (algebra_map R S) p P) =\n      finrank K L :=\n  by\n  set e := ramification_idx (algebra_map R S) p\n  set f := inertia_deg (algebra_map R S) p\n  have inj_RL : function.injective (algebra_map R L) :=\n    by\n    rw [is_scalar_tower.algebra_map_eq R K L, RingHom.coe_comp]\n    exact (RingHom.injective _).comp (is_fraction_ring.injective R K)\n  have inj_RS : function.injective (algebra_map R S) :=\n    by\n    refine' function.injective.of_comp (show function.injective (algebra_map S L ∘ _) from _)\n    rw [← RingHom.coe_comp, ← is_scalar_tower.algebra_map_eq]\n    exact inj_RL\n  calc\n    finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n          (factors (map (algebra_map R S) p)).to_finset (e P * f P) =\n        finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n          (factors (map (algebra_map R S) p)).to_finset.attach\n          (finrank («expr ⧸ » R p) («expr ⧸ » S ((P : ideal S) ^ e P))) :=\n      _\n    _ =\n        finrank («expr ⧸ » R p)\n          (∀ P : (factors (map (algebra_map R S) p)).to_finset, «expr ⧸ » S ((P : ideal S) ^ e P)) :=\n      (module.free.finrank_pi_fintype («expr ⧸ » R p)).symm\n    _ = finrank («expr ⧸ » R p) («expr ⧸ » S (map (algebra_map R S) p)) := _\n    _ = finrank K L := _\n    \n  · rw [← finset.sum_attach]\n    refine' finset.sum_congr rfl fun P _ => _\n    rw [factors.finrank_pow_ramification_idx]\n  · refine' linear_equiv.finrank_eq (factors.pi_quotient_linear_equiv S p _).symm\n    rwa [ne.def, ideal.map_eq_bot_iff_le_ker, (ring_hom.injective_iff_ker_eq_bot _).mp inj_RS, le_bot_iff]\n  · exact finrank_quotient_map p K L\n#align sum_ramification_inertia sum_ramification_inertia\n\n",
 "span_eq_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/-- If `b` mod `p` spans `S/p` as `R/p`-space, then `b` itself spans `Frac(S)` as `K`-space.\n\nHere,\n * `p` is an ideal of `R` such that `R / p` is nontrivial\n * `K` is a field that has an embedding of `R` (in particular we can take `K = Frac(R)`)\n * `L` is a field extension of `K`\n * `S` is the integral closure of `R` in `L`\n\nMore precisely, we avoid quotients in this statement and instead require that `b ∪ pS` spans `S`.\n-/\ntheorem finrank_quotient_map.span_eq_top [IsDomain R] [IsDomain S] [algebra K L] [is_noetherian R S] [algebra R L]\n    [IsScalarTower R S L] [IsScalarTower R K L] [is_integral_closure S R L] [NoZeroSMulDivisors R K] (hp : p ≠ «expr⊤»)\n    (b : set S) (hb' : «expr ⊔ » (submodule.span R b) ((p.map (algebra_map R S)).restrict_scalars R) = «expr⊤») :\n    submodule.span K («expr '' » (algebra_map S L) b) = «expr⊤» :=\n  by\n  have hRL : function.injective (algebra_map R L) :=\n    by\n    rw [is_scalar_tower.algebra_map_eq R K L]\n    exact (algebra_map K L).injective.comp (no_zero_smul_divisors.algebra_map_injective R K)\n  -- Let `M` be the `R`-module spanned by the proposed basis elements.\n  set M : submodule R S := submodule.span R b with hM\n  -- Then `S / M` is generated by some finite set of `n` vectors `a`.\n  letI h : module.finite R («expr ⧸ » S M) :=\n    module.finite.of_surjective (submodule.mkq _) (submodule.quotient.mk_surjective _)\n  obtain ⟨n, a, ha⟩ := @module.finite.exists_fin _ _ _ h\n  -- Because the image of `p` in `S / M` is `⊤`,\n  have smul_top_eq : «expr • » p («expr⊤» : submodule R («expr ⧸ » S M)) = «expr⊤» := by\n    calc\n      «expr • » p («expr⊤») = submodule.map M.mkq («expr • » p («expr⊤»)) := by\n        rw [submodule.map_smul'', submodule.map_top, M.range_mkq]\n      _ = «expr⊤» := by rw [ideal.smul_top_eq_map, (submodule.map_mkq_eq_top M _).mpr hb']\n      \n  -- we can write the elements of `a` as `p`-linear combinations of other elements of `a`.\n  have exists_sum :\n    ∀ x : «expr ⧸ » S M,\n      ∃ a' : fin n → R,\n        (∀ i, a' i ∈ p) ∧\n          finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n              («expr • » (a' i) (a i)) =\n            x :=\n    by\n    intro x\n    obtain ⟨a'', ha'', hx⟩ := (submodule.mem_ideal_smul_span_iff_exists_sum p a x).1 _\n    · refine' ⟨fun i => a'' i, fun i => ha'' _, _⟩\n      rw [← hx, finsupp.sum_fintype]\n      exact fun _ => zero_smul _ _\n    · rw [ha, smul_top_eq]\n      exact submodule.mem_top\n  choose A' hA'p hA' using fun i => exists_sum (a i)\n  -- This gives us a(n invertible) matrix `A` such that `det A ∈ (M = span R b)`,\n  let A : matrix (fin n) (fin n) R := A' - 1\n  let B := A.adjugate\n  have A_smul :\n    ∀ i,\n      finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n          («expr • » (A i j) (a j)) =\n        0 :=\n    by\n    intros\n    simp only [A, pi.sub_apply, sub_smul, finset.sum_sub_distrib, hA', matrix.one_apply, ite_smul, one_smul, zero_smul,\n      finset.sum_ite_eq, finset.mem_univ, if_true, sub_self]\n  -- since `span S {det A} / M = 0`.\n  have d_smul : ∀ i, «expr • » A.det (a i) = 0 := by\n    intro i\n    calc\n      «expr • » A.det (a i) =\n          finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n            («expr • » ((matrix.mul B A) i j) (a j)) :=\n        _\n      _ =\n          finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n            («expr • » (B i k)\n              (finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n                («expr • » (A k j) (a j)))) :=\n        _\n      _ = 0 := finset.sum_eq_zero fun k _ => _\n      \n    ·\n      simp only [matrix.adjugate_mul, pi.smul_apply, matrix.one_apply, mul_ite, ite_smul, smul_eq_mul, mul_one,\n        mul_zero, one_smul, zero_smul, finset.sum_ite_eq, finset.mem_univ, if_true]\n    · simp only [matrix.mul_apply, finset.smul_sum, finset.sum_smul, smul_smul]\n      rw [finset.sum_comm]\n    · rw [A_smul, smul_zero]\n  -- In the rings of integers we have the desired inclusion.\n  have span_d : (submodule.span S ({algebra_map R S A.det} : set S)).restrict_scalars R ≤ M :=\n    by\n    intro x hx\n    rw [submodule.restrict_scalars_mem] at hx\n    obtain ⟨x', rfl⟩ := submodule.mem_span_singleton.mp hx\n    rw [smul_eq_mul, mul_comm, ← algebra.smul_def] at hx⊢\n    rw [← submodule.quotient.mk_eq_zero, submodule.quotient.mk_smul]\n    obtain ⟨a', _, quot_x_eq⟩ := exists_sum (submodule.quotient.mk x')\n    simp_rw [← quot_x_eq, finset.smul_sum, smul_comm A.det, d_smul, smul_zero, finset.sum_const_zero]\n  -- So now we lift everything to the fraction field.\n  refine'\n    top_le_iff.mp\n      (calc\n        «expr⊤» = (ideal.span {algebra_map R L A.det}).restrict_scalars K := _\n        _ ≤ submodule.span K («expr '' » (algebra_map S L) b) := _\n        )\n  -- Because `det A ≠ 0`, we have `span L {det A} = ⊤`.\n  · rw [eq_comm, submodule.restrict_scalars_eq_top_iff, ideal.span_singleton_eq_top]\n    refine'\n      IsUnit.mk0 _ ((map_ne_zero_iff (algebra_map R L) hRL).mpr (@ne_zero_of_map _ _ _ _ _ _ (ideal.quotient.mk p) _ _))\n    haveI := ideal.quotient.nontrivial hp\n    calc\n      ideal.quotient.mk p A.det = matrix.det ((ideal.quotient.mk p).map_matrix A) := by\n        rw [ring_hom.map_det, ring_hom.map_matrix_apply]\n      _ = matrix.det ((ideal.quotient.mk p).map_matrix (A' - 1)) := rfl\n      _ = matrix.det fun i j => (ideal.quotient.mk p) (A' i j) - (1 : matrix (fin n) (fin n) («expr ⧸ » R p)) i j := _\n      _ = matrix.det (-1 : matrix (fin n) (fin n) («expr ⧸ » R p)) := _\n      _ = (-1 : «expr ⧸ » R p) ^ n := by rw [matrix.det_neg, fintype.card_fin, matrix.det_one, mul_one]\n      _ ≠ 0 := IsUnit.ne_zero (is_unit_one.neg.pow _)\n      \n    · refine' congr_arg matrix.det (matrix.ext fun i j => _)\n      rw [map_sub, ring_hom.map_matrix_apply, map_one]\n      rfl\n    · refine' congr_arg matrix.det (matrix.ext fun i j => _)\n      rw [ideal.quotient.eq_zero_iff_mem.mpr (hA'p i j), zero_sub]\n      rfl\n  -- And we conclude `L = span L {det A} ≤ span K b`, so `span K b` spans everything.\n  · intro x hx\n    rw [submodule.restrict_scalars_mem, is_scalar_tower.algebra_map_apply R S L] at hx\n    refine' is_fraction_ring.ideal_span_singleton_map_subset R _ hRL span_d hx\n    haveI : NoZeroSMulDivisors R L := no_zero_smul_divisors.of_algebra_map_injective hRL\n    rw [← is_fraction_ring.is_algebraic_iff' R S]\n    intro x\n    exact is_integral.is_algebraic _ (is_integral_of_noetherian infer_instance _)\n#align finrank_quotient_map.span_eq_top finrank_quotient_map.span_eq_top\n\n",
 "ramification_idx_spec":
 "theorem ramification_idx_spec {n : ℕ} (hle : map f p ≤ P ^ n) (hgt : ¬map f p ≤ P ^ (n + 1)) :\n    ramification_idx f p P = n :=\n  by\n  have : ∀ k : ℕ, map f p ≤ P ^ k → k ≤ n := by\n    intro k hk\n    refine' le_of_not_lt fun hnk => _\n    exact hgt (hk.trans (ideal.pow_le_pow hnk))\n  rw [ramification_idx_eq_find ⟨n, this⟩]\n  · refine' le_antisymm (nat.find_min' _ this) (le_of_not_gt fun h : nat.find _ < n => _)\n    obtain this' := nat.find_spec ⟨n, this⟩\n    exact h.not_le (this' _ hle)\n#align ramification_idx_spec ramification_idx_spec\n\n",
 "ramification_idx_of_not_le":
 "@[simp]\ntheorem ramification_idx_of_not_le (h : ¬map f p ≤ P) : ramification_idx f p P = 0 :=\n  ramification_idx_spec (by simp) (by simpa using h)\n#align ramification_idx_of_not_le ramification_idx_of_not_le\n\n",
 "ramification_idx_ne_zero":
 "theorem factors.ramification_idx_ne_zero (P : (factors (map (algebra_map R S) p)).to_finset) :\n    ramification_idx (algebra_map R S) p P ≠ 0 :=\n  is_dedekind_domain.ramification_idx_ne_zero (ne_zero_of_mem_factors (Multiset.mem_toFinset.mp P.2))\n    (factors.is_prime p P) (ideal.le_of_dvd (dvd_of_mem_factors (Multiset.mem_toFinset.mp P.2)))\n#align factors.ramification_idx_ne_zero factors.ramification_idx_ne_zero\n\n",
 "ramification_idx_lt":
 "theorem ramification_idx_lt {n : ℕ} (hgt : ¬map f p ≤ P ^ n) : ramification_idx f p P < n :=\n  by\n  cases n\n  · simpa using hgt\n  rw [Nat.lt_succ_iff]\n  have : ∀ k, map f p ≤ P ^ k → k ≤ n :=\n    by\n    refine' fun k hk => le_of_not_lt fun hnk => _\n    exact hgt (hk.trans (ideal.pow_le_pow hnk))\n  rw [ramification_idx_eq_find ⟨n, this⟩]\n  exact nat.find_min' ⟨n, this⟩ this\n#align ramification_idx_lt ramification_idx_lt\n\n",
 "ramification_idx_eq_zero":
 "theorem ramification_idx_eq_zero (h : ∀ n : ℕ, ∃ k, map f p ≤ P ^ k ∧ n < k) : ramification_idx f p P = 0 :=\n  dif_neg (by push_neg <;> exact h)\n#align ramification_idx_eq_zero ramification_idx_eq_zero\n\n",
 "ramification_idx_eq_normalized_factors_count":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem ramification_idx_eq_normalized_factors_count (hp0 : map f p ≠ «expr⊥») (hP : P.is_prime) (hP0 : P ≠ «expr⊥») :\n    ramification_idx f p P = (normalized_factors (map f p)).count P :=\n  by\n  have hPirr := (ideal.prime_of_is_prime hP0 hP).irreducible\n  refine' ramification_idx_spec (ideal.le_of_dvd _) (mt ideal.dvd_iff_le.mpr _) <;>\n    rw [dvd_iff_normalized_factors_le_normalized_factors (pow_ne_zero _ hP0) hp0, normalized_factors_pow,\n      normalized_factors_irreducible hPirr, normalize_eq, Multiset.nsmul_singleton, ←\n      Multiset.le_count_iff_replicate_le]\n  · exact (nat.lt_succ_self _).not_le\n#align ramification_idx_eq_normalized_factors_count ramification_idx_eq_normalized_factors_count\n\n",
 "ramification_idx_eq_find":
 "/-\nCopyright (c) 2022 Anne Baanen. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Anne Baanen\n-/\ntheorem ramification_idx_eq_find (h : ∃ n, ∀ k, map f p ≤ P ^ k → k ≤ n) : ramification_idx f p P = nat.find h :=\n  nat.Sup_def h\n#align ramification_idx_eq_find ramification_idx_eq_find\n\n",
 "ramification_idx_eq_factors_count":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem ramification_idx_eq_factors_count (hp0 : map f p ≠ «expr⊥») (hP : P.is_prime) (hP0 : P ≠ «expr⊥») :\n    ramification_idx f p P = (factors (map f p)).count P := by\n  rw [is_dedekind_domain.ramification_idx_eq_normalized_factors_count hp0 hP hP0, factors_eq_normalized_factors]\n#align ramification_idx_eq_factors_count ramification_idx_eq_factors_count\n\n",
 "ramification_idx_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem ramification_idx_bot : ramification_idx f («expr⊥») P = 0 :=\n  dif_neg <| not_exists.mpr fun n hn => n.lt_succ_self.not_le (hn _ (by simp))\n#align ramification_idx_bot ramification_idx_bot\n\n",
 "quotient_to_quotient_range_pow_quot_succ_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expre -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expre -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expre -/\ntheorem quotient_to_quotient_range_pow_quot_succ_surjective [IsDomain S] [is_dedekind_domain S] (hP0 : P ≠ «expr⊥»)\n    [hP : P.is_prime] {i : ℕ} (hi : i < expre) {a : S} (a_mem : a ∈ P ^ i) (a_not_mem : a ∉ P ^ (i + 1)) :\n    function.surjective (quotient_to_quotient_range_pow_quot_succ f p P a_mem) :=\n  by\n  rintro ⟨⟨⟨x⟩, hx⟩⟩\n  have Pe_le_Pi : P ^ expre ≤ P ^ i := ideal.pow_le_pow hi.le\n  have Pe_le_Pi1 : P ^ expre ≤ P ^ (i + 1) := ideal.pow_le_pow hi\n  rw [submodule.quotient.quot_mk_eq_mk, ideal.quotient.mk_eq_mk, ideal.mem_quotient_iff_mem_sup,\n    sup_eq_left.mpr Pe_le_Pi] at hx\n  suffices hx' : x ∈ «expr ⊔ » (ideal.span {a}) (P ^ (i + 1))\n  · obtain ⟨y', hy', z, hz, rfl⟩ := submodule.mem_sup.mp hx'\n    obtain ⟨y, rfl⟩ := ideal.mem_span_singleton.mp hy'\n    refine' ⟨submodule.quotient.mk y, _⟩\n    simp only [submodule.quotient.quot_mk_eq_mk, quotient_to_quotient_range_pow_quot_succ_mk, submodule.quotient.eq,\n      linear_map.mem_range, subtype.ext_iff, subtype.coe_mk, submodule.coe_sub]\n    refine' ⟨⟨_, ideal.mem_map_of_mem _ (submodule.neg_mem _ hz)⟩, _⟩\n    rw [pow_quot_succ_inclusion_apply_coe, subtype.coe_mk, ideal.quotient.mk_eq_mk, map_add, mul_comm y a,\n      sub_add_cancel', map_neg]\n  letI := classical.dec_eq (ideal S)\n  rw [sup_eq_prod_inf_factors _ (pow_ne_zero _ hP0), normalized_factors_pow,\n    normalized_factors_irreducible ((ideal.prime_iff_is_prime hP0).mpr hP).irreducible, normalize_eq,\n    Multiset.nsmul_singleton, Multiset.inter_replicate, Multiset.prod_replicate]\n  rw [← submodule.span_singleton_le_iff_mem, ideal.submodule_span_eq] at a_mem a_not_mem\n  rwa [ideal.count_normalized_factors_eq a_mem a_not_mem, min_eq_left i.le_succ]\n  · intro ha\n    rw [ideal.span_singleton_eq_bot.mp ha] at a_not_mem\n    have := (P ^ (i + 1)).zero_mem\n    contradiction\n#align quotient_to_quotient_range_pow_quot_succ_surjective quotient_to_quotient_range_pow_quot_succ_surjective\n\n",
 "quotient_to_quotient_range_pow_quot_succ_mk":
 "theorem quotient_to_quotient_range_pow_quot_succ_mk {i : ℕ} {a : S} (a_mem : a ∈ P ^ i) (x : S) :\n    quotient_to_quotient_range_pow_quot_succ f p P a_mem (submodule.quotient.mk x) =\n      submodule.quotient.mk ⟨_, ideal.mem_map_of_mem _ (ideal.mul_mem_left _ x a_mem)⟩ :=\n  quotient_to_quotient_range_pow_quot_succ_aux_mk f p P a_mem x\n#align quotient_to_quotient_range_pow_quot_succ_mk quotient_to_quotient_range_pow_quot_succ_mk\n\n",
 "quotient_to_quotient_range_pow_quot_succ_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expre -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expre -/\ntheorem quotient_to_quotient_range_pow_quot_succ_injective [IsDomain S] [is_dedekind_domain S] [P.is_prime] {i : ℕ}\n    (hi : i < expre) {a : S} (a_mem : a ∈ P ^ i) (a_not_mem : a ∉ P ^ (i + 1)) :\n    function.injective (quotient_to_quotient_range_pow_quot_succ f p P a_mem) := fun x =>\n  Quotient.inductionOn' x fun x y =>\n    Quotient.inductionOn' y fun y h =>\n      by\n      have Pe_le_Pi1 : P ^ expre ≤ P ^ (i + 1) := ideal.pow_le_pow hi\n      simp only [submodule.quotient.mk'_eq_mk, quotient_to_quotient_range_pow_quot_succ_mk, submodule.quotient.eq,\n        linear_map.mem_range, subtype.ext_iff, subtype.coe_mk, submodule.coe_sub] at h⊢\n      rcases h with ⟨⟨⟨z⟩, hz⟩, h⟩\n      rw [submodule.quotient.quot_mk_eq_mk, ideal.quotient.mk_eq_mk, ideal.mem_quotient_iff_mem_sup,\n        sup_eq_left.mpr Pe_le_Pi1] at hz\n      rw [pow_quot_succ_inclusion_apply_coe, subtype.coe_mk, submodule.quotient.quot_mk_eq_mk, ideal.quotient.mk_eq_mk,\n        ← map_sub, ideal.quotient.eq, ← sub_mul] at h\n      exact (ideal.is_prime.mul_mem_pow _ ((submodule.sub_mem_iff_right _ hz).mp (Pe_le_Pi1 h))).resolve_right a_not_mem\n#align quotient_to_quotient_range_pow_quot_succ_injective quotient_to_quotient_range_pow_quot_succ_injective\n\n",
 "quotient_to_quotient_range_pow_quot_succ_aux_mk":
 "theorem quotient_to_quotient_range_pow_quot_succ_aux_mk {i : ℕ} {a : S} (a_mem : a ∈ P ^ i) (x : S) :\n    quotient_to_quotient_range_pow_quot_succ_aux f p P a_mem (submodule.quotient.mk x) =\n      submodule.quotient.mk ⟨_, ideal.mem_map_of_mem _ (ideal.mul_mem_left _ x a_mem)⟩ :=\n  by apply quotient.map'_mk'\n#align quotient_to_quotient_range_pow_quot_succ_aux_mk quotient_to_quotient_range_pow_quot_succ_aux_mk\n\n",
 "pow_quot_succ_inclusion_injective":
 "theorem pow_quot_succ_inclusion_injective (i : ℕ) : function.injective (pow_quot_succ_inclusion f p P i) :=\n  by\n  rw [← linear_map.ker_eq_bot, linear_map.ker_eq_bot']\n  rintro ⟨x, hx⟩ hx0\n  rw [subtype.ext_iff] at hx0⊢\n  rwa [pow_quot_succ_inclusion_apply_coe] at hx0\n#align pow_quot_succ_inclusion_injective pow_quot_succ_inclusion_injective\n\n",
 "pi_quotient_equiv_mk":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem factors.pi_quotient_equiv_mk (p : ideal R) (hp : map (algebra_map R S) p ≠ «expr⊥») (x : S) :\n    factors.pi_quotient_equiv p hp (ideal.quotient.mk _ x) = fun P => ideal.quotient.mk _ x :=\n  rfl\n#align factors.pi_quotient_equiv_mk factors.pi_quotient_equiv_mk\n\n",
 "pi_quotient_equiv_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem factors.pi_quotient_equiv_map (p : ideal R) (hp : map (algebra_map R S) p ≠ «expr⊥») (x : R) :\n    factors.pi_quotient_equiv p hp (algebra_map _ _ x) = fun P => ideal.quotient.mk _ (algebra_map _ _ x) :=\n  rfl\n#align factors.pi_quotient_equiv_map factors.pi_quotient_equiv_map\n\n",
 "ne_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem factors.ne_bot (P : (factors (map (algebra_map R S) p)).to_finset) : (P : ideal S) ≠ «expr⊥» :=\n  (prime_of_factor _ (Multiset.mem_toFinset.mp P.2)).ne_zero\n#align factors.ne_bot factors.ne_bot\n\n",
 "linear_independent_of_nontrivial":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/-- Let `V` be a vector space over `K = Frac(R)`, `S / R` a ring extension\nand `V'` a module over `S`. If `b`, in the intersection `V''` of `V` and `V'`,\nis linear independent over `S` in `V'`, then it is linear independent over `R` in `V`.\n\nThe statement we prove is actually slightly more general:\n * it suffices that the inclusion `algebra_map R S : R → S` is nontrivial\n * the function `f' : V'' → V'` doesn't need to be injective\n-/\ntheorem finrank_quotient_map.linear_independent_of_nontrivial [IsDomain R] [is_dedekind_domain R]\n    (hRS : (algebra_map R S).ker ≠ «expr⊤») (f : «expr →ₗ[ ] » V'' R V) (hf : function.injective f)\n    (f' : «expr →ₗ[ ] » V'' R V') {ι : Type _} {b : ι → V''} (hb' : linear_independent S (f' ∘ b)) :\n    linear_independent K (f ∘ b) := by\n  contrapose! hb' with hb\n  -- Informally, if we have a nontrivial linear dependence with coefficients `g` in `K`,\n  -- then we can find a linear dependence with coefficients `I.quotient.mk g'` in `R/I`,\n  -- where `I = ker (algebra_map R S)`.\n  -- We make use of the same principle but stay in `R` everywhere.\n  simp only [linear_independent_iff', not_forall] at hb⊢\n  obtain ⟨s, g, eq, j', hj's, hj'g⟩ := hb\n  use s\n  obtain ⟨a, hag, j, hjs, hgI⟩ := ideal.exist_integer_multiples_not_mem hRS s g hj's hj'g\n  choose g'' hg'' using hag\n  letI := classical.prop_decidable\n  let g' i := if h : i ∈ s then g'' i h else 0\n  have hg' : ∀ i ∈ s, algebra_map _ _ (g' i) = a * g i :=\n    by\n    intro i hi\n    exact (congr_arg _ (dif_pos hi)).trans (hg'' i hi)\n  -- Because `R/I` is nontrivial, we can lift `g` to a nontrivial linear dependence in `S`.\n  have hgI : algebra_map R S (g' j) ≠ 0 :=\n    by\n    simp only [fractional_ideal.mem_coe_ideal, not_exists, not_and'] at hgI\n    exact hgI _ (hg' j hjs)\n  refine' ⟨fun i => algebra_map R S (g' i), _, j, hjs, hgI⟩\n  have eq :\n    f\n        (finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s\n          («expr • » (g' i) (b i))) =\n      0 :=\n    by\n    rw [linear_map.map_sum, ← smul_zero a, ← eq, finset.smul_sum, finset.sum_congr rfl]\n    intro i hi\n    rw [linear_map.map_smul, ← is_scalar_tower.algebra_map_smul K, hg' i hi, ← smul_assoc, smul_eq_mul]\n    infer_instance\n  simp only [is_scalar_tower.algebra_map_smul, ← linear_map.map_smul, ← linear_map.map_sum,\n    (f.map_eq_zero_iff hf).mp eq, linear_map.map_zero]\n#align finrank_quotient_map.linear_independent_of_nontrivial finrank_quotient_map.linear_independent_of_nontrivial\n\n",
 "le_pow_ramification_idx":
 "theorem le_pow_ramification_idx : map f p ≤ P ^ ramification_idx f p P :=\n  le_pow_of_le_ramification_idx (le_refl _)\n#align le_pow_ramification_idx le_pow_ramification_idx\n\n",
 "le_pow_of_le_ramification_idx":
 "theorem le_pow_of_le_ramification_idx {n : ℕ} (hn : n ≤ ramification_idx f p P) : map f p ≤ P ^ n :=\n  by\n  contrapose! hn\n  exact ramification_idx_lt hn\n#align le_pow_of_le_ramification_idx le_pow_of_le_ramification_idx\n\n",
 "le_comap_pow_ramification_idx":
 "theorem le_comap_pow_ramification_idx : p ≤ comap f (P ^ ramification_idx f p P) :=\n  map_le_iff_le_comap.mp le_pow_ramification_idx\n#align le_comap_pow_ramification_idx le_comap_pow_ramification_idx\n\n",
 "le_comap_of_ramification_idx_ne_zero":
 "theorem le_comap_of_ramification_idx_ne_zero (h : ramification_idx f p P ≠ 0) : p ≤ comap f P :=\n  ideal.map_le_iff_le_comap.mp <| le_pow_ramification_idx.trans <| ideal.pow_le_self <| h\n#align le_comap_of_ramification_idx_ne_zero le_comap_of_ramification_idx_ne_zero\n\n",
 "inertia_deg_of_subsingleton":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n-- Useful for the `nontriviality` tactic using `comap_eq_of_scalar_tower_quotient`.\n@[simp]\ntheorem inertia_deg_of_subsingleton [hp : p.is_maximal] [hQ : subsingleton («expr ⧸ » S P)] : inertia_deg f p P = 0 :=\n  by\n  have := ideal.quotient.subsingleton_iff.mp hQ\n  subst this\n  exact dif_neg fun h => hp.ne_top <| h.symm.trans comap_top\n#align inertia_deg_of_subsingleton inertia_deg_of_subsingleton\n\n",
 "inertia_deg_ne_zero":
 "theorem factors.inertia_deg_ne_zero [is_noetherian R S] [p.is_maximal]\n    (P : (factors (map (algebra_map R S) p)).to_finset) : inertia_deg (algebra_map R S) p P ≠ 0 :=\n  by\n  rw [inertia_deg_algebra_map]\n  exact (finite_dimensional.finrank_pos_iff.mpr infer_instance).ne'\n#align factors.inertia_deg_ne_zero factors.inertia_deg_ne_zero\n\n",
 "inertia_deg_algebra_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n@[simp]\ntheorem inertia_deg_algebra_map [algebra R S] [algebra («expr ⧸ » R p) («expr ⧸ » S P)]\n    [IsScalarTower R («expr ⧸ » R p) («expr ⧸ » S P)] [hp : p.is_maximal] :\n    inertia_deg (algebra_map R S) p P = finrank («expr ⧸ » R p) («expr ⧸ » S P) :=\n  by\n  nontriviality «expr ⧸ » S P using inertia_deg_of_subsingleton, finrank_zero_of_subsingleton\n  have := comap_eq_of_scalar_tower_quotient (algebra_map («expr ⧸ » R p) («expr ⧸ » S P)).injective\n  rw [inertia_deg, dif_pos this]\n  congr\n  refine' algebra.algebra_ext _ _ fun x' => Quotient.inductionOn' x' fun x => _\n  change ideal.quotient.lift p _ _ (ideal.quotient.mk p x) = algebra_map _ _ (ideal.quotient.mk p x)\n  rw [ideal.quotient.lift_mk, ← ideal.quotient.algebra_map_eq, ← is_scalar_tower.algebra_map_eq, ←\n    ideal.quotient.algebra_map_eq, ← is_scalar_tower.algebra_map_apply]\n#align inertia_deg_algebra_map inertia_deg_algebra_map\n\n",
 "finrank_quotient_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/-- If `p` is a maximal ideal of `R`, and `S` is the integral closure of `R` in `L`,\nthen the dimension `[S/pS : R/p]` is equal to `[Frac(S) : Frac(R)]`. -/\ntheorem finrank_quotient_map [IsDomain R] [IsDomain S] [is_dedekind_domain R] [algebra K L] [algebra R L]\n    [IsScalarTower R K L] [IsScalarTower R S L] [is_integral_closure S R L] [hp : p.is_maximal] [is_noetherian R S] :\n    finrank («expr ⧸ » R p) («expr ⧸ » S (map (algebra_map R S) p)) = finrank K L :=\n  by\n  -- Choose an arbitrary basis `b` for `[S/pS : R/p]`.\n  -- We'll use the previous results to turn it into a basis on `[Frac(S) : Frac(R)]`.\n  letI : Field («expr ⧸ » R p) := ideal.quotient.field _\n  let ι := module.free.choose_basis_index («expr ⧸ » R p) («expr ⧸ » S (map (algebra_map R S) p))\n  let b : basis ι («expr ⧸ » R p) («expr ⧸ » S (map (algebra_map R S) p)) := module.free.choose_basis _ _\n  -- Namely, choose a representative `b' i : S` for each `b i : S / pS`.\n  let b' : ι → S := fun i => (ideal.quotient.mk_surjective (b i)).some\n  have b_eq_b' : «expr⇑ » b = (submodule.mkq _).restrict_scalars R ∘ b' :=\n    funext fun i => (ideal.quotient.mk_surjective (b i)).some_spec.symm\n  -- We claim `b'` is a basis for `Frac(S)` over `Frac(R)` because it is linear independent\n  -- and spans the whole of `Frac(S)`.\n  let b'' : ι → L := algebra_map S L ∘ b'\n  have b''_li : linear_independent _ b'' := _\n  have b''_sp : submodule.span _ (Set.range b'') = «expr⊤» := _\n  -- Since the two bases have the same index set, the spaces have the same dimension.\n  let c : basis ι K L := basis.mk b''_li b''_sp.ge\n  rw [finrank_eq_card_basis b, finrank_eq_card_basis c]\n  -- It remains to show that the basis is indeed linear independent and spans the whole space.\n  · rw [Set.range_comp]\n    refine' finrank_quotient_map.span_eq_top p hp.ne_top _ (top_le_iff.mp _)\n    -- The nicest way to show `S ≤ span b' ⊔ pS` is by reducing both sides modulo pS.\n    -- However, this would imply distinguishing between `pS` as `S`-ideal,\n    -- and `pS` as `R`-submodule, since they have different (non-defeq) quotients.\n    -- Instead we'll lift `x mod pS ∈ span b` to `y ∈ span b'` for some `y - x ∈ pS`.\n    intro x hx\n    have mem_span_b :\n      ((submodule.mkq (map (algebra_map R S) p)) x : «expr ⧸ » S (map (algebra_map R S) p)) ∈\n        submodule.span («expr ⧸ » R p) (Set.range b) :=\n      b.mem_span _\n    rw [← @submodule.restrict_scalars_mem R,\n      algebra.span_restrict_scalars_eq_span_of_surjective\n        (show function.surjective (algebra_map R («expr ⧸ » R p)) from ideal.quotient.mk_surjective) _,\n      b_eq_b', Set.range_comp, ← submodule.map_span] at mem_span_b\n    obtain ⟨y, y_mem, y_eq⟩ := submodule.mem_map.mp mem_span_b\n    suffices y + -(y - x) ∈ _ by simpa\n    rw [linear_map.restrict_scalars_apply, submodule.mkq_apply, submodule.mkq_apply, submodule.quotient.eq] at y_eq\n    exact add_mem (submodule.mem_sup_left y_mem) (neg_mem <| submodule.mem_sup_right y_eq)\n  · have := b.linear_independent\n    rw [b_eq_b'] at this\n    convert\n      finrank_quotient_map.linear_independent_of_nontrivial K _ ((algebra.linear_map S L).restrict_scalars R) _\n        ((submodule.mkq _).restrict_scalars R) this\n    · rw [quotient.algebra_map_eq, ideal.mk_ker]\n      exact hp.ne_top\n    · exact is_fraction_ring.injective S L\n#align finrank_quotient_map finrank_quotient_map\n\n",
 "finrank_prime_pow_ramification_idx":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expre -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expre -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expre -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expre -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/-- If `p` is a maximal ideal of `R`, `S` extends `R` and `P^e` lies over `p`,\nthen the dimension `[S/(P^e) : R/p]`, as a natural number, is equal to `e * [S/P : R/p]`. -/\ntheorem finrank_prime_pow_ramification_idx [IsDomain S] [is_dedekind_domain S] (hP0 : P ≠ «expr⊥») [p.is_maximal]\n    [P.is_prime] (he : expre ≠ 0) :\n    finrank («expr ⧸ » R p) («expr ⧸ » S (P ^ expre)) =\n      expre *\n        @finrank («expr ⧸ » R p) («expr ⧸ » S P) _ _\n          (@algebra.to_module _ _ _ _ <| @quotient.algebra_quotient_of_ramification_idx_ne_zero _ _ _ _ _ ⟨he⟩) :=\n  by\n  letI : ne_zero (expre) := ⟨he⟩\n  letI : algebra («expr ⧸ » R p) («expr ⧸ » S P) := quotient.algebra_quotient_of_ramification_idx_ne_zero f p P\n  letI := ideal.quotient.field p\n  have hdim := dim_prime_pow_ramification_idx _ _ _ hP0 he\n  by_cases hP : finite_dimensional («expr ⧸ » R p) («expr ⧸ » S P)\n  · haveI := hP\n    haveI := (finite_dimensional_iff_of_rank_eq_nsmul he hdim).mpr hP\n    refine' cardinal.nat_cast_injective _\n    rw [finrank_eq_dim, nat.cast_mul, finrank_eq_dim, hdim, nsmul_eq_mul]\n  have hPe := mt (finite_dimensional_iff_of_rank_eq_nsmul he hdim).mp hP\n  simp only [finrank_of_infinite_dimensional hP, finrank_of_infinite_dimensional hPe, mul_zero]\n#align finrank_prime_pow_ramification_idx finrank_prime_pow_ramification_idx\n\n",
 "finrank_pow_ramification_idx":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\ntheorem factors.finrank_pow_ramification_idx [p.is_maximal] (P : (factors (map (algebra_map R S) p)).to_finset) :\n    finrank («expr ⧸ » R p) («expr ⧸ » S ((P : ideal S) ^ ramification_idx (algebra_map R S) p P)) =\n      ramification_idx (algebra_map R S) p P * inertia_deg (algebra_map R S) p P :=\n  by\n  rw [finrank_prime_pow_ramification_idx, inertia_deg_algebra_map]\n  exact factors.ne_bot p P\n#align factors.finrank_pow_ramification_idx factors.finrank_pow_ramification_idx\n\n",
 "dim_prime_pow_ramification_idx":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expre -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expre -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expre -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expre -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expre -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/-- If `p` is a maximal ideal of `R`, `S` extends `R` and `P^e` lies over `p`,\nthen the dimension `[S/(P^e) : R/p]` is equal to `e * [S/P : R/p]`. -/\ntheorem dim_prime_pow_ramification_idx [IsDomain S] [is_dedekind_domain S] [p.is_maximal] [P.is_prime]\n    (hP0 : P ≠ «expr⊥») (he : expre ≠ 0) :\n    module.rank («expr ⧸ » R p) («expr ⧸ » S (P ^ expre)) =\n      «expr • » (expre)\n        (@module.rank («expr ⧸ » R p) («expr ⧸ » S P) _ _\n          (@algebra.to_module _ _ _ _ <| @quotient.algebra_quotient_of_ramification_idx_ne_zero _ _ _ _ _ ⟨he⟩)) :=\n  by\n  letI : ne_zero (expre) := ⟨he⟩\n  have := dim_pow_quot f p P hP0 0 (nat.zero_le (expre))\n  rw [pow_zero, nat.sub_zero, ideal.one_eq_top, ideal.map_top] at this\n  exact (dim_top («expr ⧸ » R p) _).symm.trans this\n#align dim_prime_pow_ramification_idx dim_prime_pow_ramification_idx\n\n",
 "dim_pow_quot_aux":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expre -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expre -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expre -/\n/-- Since the inclusion `(P^(i + 1) / P^e) ⊂ (P^i / P^e)` has a kernel isomorphic to `P / S`,\n`[P^i / P^e : R / p] = [P^(i+1) / P^e : R / p] + [P / S : R / p]` -/\ntheorem dim_pow_quot_aux [IsDomain S] [is_dedekind_domain S] [p.is_maximal] [P.is_prime] (hP0 : P ≠ «expr⊥») {i : ℕ}\n    (hi : i < expre) :\n    module.rank («expr ⧸ » R p) (ideal.map (P ^ expre) (P ^ i)) =\n      module.rank («expr ⧸ » R p) («expr ⧸ » S P) + module.rank («expr ⧸ » R p) (ideal.map (P ^ expre) (P ^ (i + 1))) :=\n  by\n  letI : Field («expr ⧸ » R p) := ideal.quotient.field _\n  rw [dim_eq_of_injective _ (pow_quot_succ_inclusion_injective f p P i),\n    (quotient_range_pow_quot_succ_inclusion_equiv f p P hP0 hi).symm.dim_eq]\n  exact (dim_quotient_add_dim (linear_map.range (pow_quot_succ_inclusion f p P i))).symm\n#align dim_pow_quot_aux dim_pow_quot_aux\n\n",
 "dim_pow_quot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expre -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expre -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expre -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expre -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expre -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\ntheorem dim_pow_quot [IsDomain S] [is_dedekind_domain S] [p.is_maximal] [P.is_prime] (hP0 : P ≠ «expr⊥») (i : ℕ)\n    (hi : i ≤ expre) :\n    module.rank («expr ⧸ » R p) (ideal.map (P ^ expre) (P ^ i)) =\n      «expr • » (expre - i) (module.rank («expr ⧸ » R p) («expr ⧸ » S P)) :=\n  by\n  refine' @Nat.decreasingInduction' _ i (expre) (fun j lt_e le_j ih => _) hi _\n  · rw [dim_pow_quot_aux f p P _ lt_e, ih, ← succ_nsmul, nat.sub_succ, ← nat.succ_eq_add_one,\n      nat.succ_pred_eq_of_pos (nat.sub_pos_of_lt lt_e)]\n    assumption\n  · rw [nat.sub_self, zero_nsmul, map_quotient_self]\n    exact dim_bot («expr ⧸ » R p) («expr ⧸ » S (P ^ expre))\n#align dim_pow_quot dim_pow_quot\n\n",
 "algebra_map_quotient_pow_ramification_idx":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expre -/\n@[simp]\ntheorem quotient.algebra_map_quotient_pow_ramification_idx (x : R) :\n    algebra_map («expr ⧸ » R p) («expr ⧸ » S (P ^ expre)) (ideal.quotient.mk p x) = ideal.quotient.mk _ (f x) :=\n  rfl\n#align quotient.algebra_map_quotient_pow_ramification_idx quotient.algebra_map_quotient_pow_ramification_idx\n\n",
 "algebra_map_quotient_of_ramification_idx_ne_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n-- In this file, the value for `f` can be inferred.\n@[simp]\ntheorem quotient.algebra_map_quotient_of_ramification_idx_ne_zero (x : R) :\n    algebra_map («expr ⧸ » R p) («expr ⧸ » S P) (ideal.quotient.mk p x) = ideal.quotient.mk _ (f x) :=\n  rfl\n#align\n  quotient.algebra_map_quotient_of_ramification_idx_ne_zero quotient.algebra_map_quotient_of_ramification_idx_ne_zero\n\n"}