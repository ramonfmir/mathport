{"sum_ramification_inertia":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/-- The **fundamental identity** of ramification index `e` and inertia degree `f`:\nfor `P` ranging over the primes lying over `p`, `∑ P, e P * f P = [Frac(S) : Frac(R)]`;\nhere `S` is a finite `R`-module (and thus `Frac(S) : Frac(R)` is a finite extension) and `p`\nis maximal.\n-/\ntheorem sum_ramification_inertia (K L : Type _) [Field K] [Field L] [IsDomain R] [is_dedekind_domain R] [Algebra R K]\n    [IsFractionRing R K] [Algebra S L] [IsFractionRing S L] [Algebra K L] [Algebra R L] [IsScalarTower R S L]\n    [IsScalarTower R K L] [IsNoetherian R S] [is_integral_closure S R L] [p.is_maximal] (hp0 : p ≠ «expr⊥») :\n    finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n        (factors (map (algebraMap R S) p)).to_finset\n        (ramification_idx (algebraMap R S) p P * inertia_deg (algebraMap R S) p P) =\n      finrank K L :=\n  by\n  set e := ramification_idx (algebraMap R S) p\n  set f := inertia_deg (algebraMap R S) p\n  have inj_RL : function.injective (algebraMap R L) :=\n    by\n    rw [IsScalarTower.algebraMap_eq R K L, RingHom.coe_comp]\n    exact (RingHom.injective _).comp (IsFractionRing.injective R K)\n  have inj_RS : function.injective (algebraMap R S) :=\n    by\n    refine' Function.Injective.of_comp (show function.injective (algebraMap S L ∘ _) from _)\n    rw [← RingHom.coe_comp, ← IsScalarTower.algebraMap_eq]\n    exact inj_RL\n  calc\n    finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n          (factors (map (algebraMap R S) p)).to_finset (e P * f P) =\n        finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n          (factors (map (algebraMap R S) p)).to_finset.attach\n          (finrank («expr ⧸ » R p) («expr ⧸ » S ((P : Ideal S) ^ e P))) :=\n      _\n    _ =\n        finrank («expr ⧸ » R p)\n          (∀ P : (factors (map (algebraMap R S) p)).to_finset, «expr ⧸ » S ((P : Ideal S) ^ e P)) :=\n      (finrank_pi_fintype («expr ⧸ » R p)).symm\n    _ = finrank («expr ⧸ » R p) («expr ⧸ » S (map (algebraMap R S) p)) := _\n    _ = finrank K L := _\n    \n  · rw [← Finset.sum_attach]\n    refine' Finset.sum_congr rfl fun P _ => _\n    rw [factors.finrank_pow_ramification_idx]\n  · refine' LinearEquiv.finrank_eq (factors.pi_quotient_linear_equiv S p _).symm\n    rwa [ne.def, Ideal.map_eq_bot_iff_le_ker, (RingHom.injective_iff_ker_eq_bot _).mp inj_RS, le_bot_iff]\n  · exact finrank_quotient_map p K L\n#align sum_ramification_inertia sum_ramification_inertia\n\n",
 "span_eq_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/-- If `b` mod `p` spans `S/p` as `R/p`-space, then `b` itself spans `Frac(S)` as `K`-space.\n\nHere,\n * `p` is an ideal of `R` such that `R / p` is nontrivial\n * `K` is a field that has an embedding of `R` (in particular we can take `K = Frac(R)`)\n * `L` is a field extension of `K`\n * `S` is the integral closure of `R` in `L`\n\nMore precisely, we avoid quotients in this statement and instead require that `b ∪ pS` spans `S`.\n-/\ntheorem finrank_quotient_map.span_eq_top [IsDomain R] [IsDomain S] [Algebra K L] [IsNoetherian R S] [Algebra R L]\n    [IsScalarTower R S L] [IsScalarTower R K L] [is_integral_closure S R L] [NoZeroSMulDivisors R K] (hp : p ≠ «expr⊤»)\n    (b : Set S) (hb' : «expr ⊔ » (Submodule.span R b) ((p.map (algebraMap R S)).restrict_scalars R) = «expr⊤») :\n    Submodule.span K («expr '' » (algebraMap S L) b) = «expr⊤» :=\n  by\n  have hRL : function.injective (algebraMap R L) :=\n    by\n    rw [IsScalarTower.algebraMap_eq R K L]\n    exact (algebraMap K L).injective.comp (NoZeroSMulDivisors.algebraMap_injective R K)\n  -- Let `M` be the `R`-module spanned by the proposed basis elements.\n  set M : Submodule R S := Submodule.span R b with hM\n  -- Then `S / M` is generated by some finite set of `n` vectors `a`.\n  letI h : Module.Finite R («expr ⧸ » S M) :=\n    Module.Finite.of_surjective (Submodule.mkQ _) (Submodule.Quotient.mk_surjective _)\n  obtain ⟨n, a, ha⟩ := @Module.Finite.exists_fin _ _ _ h\n  -- Because the image of `p` in `S / M` is `⊤`,\n  have smul_top_eq : «expr • » p («expr⊤» : Submodule R («expr ⧸ » S M)) = «expr⊤» := by\n    calc\n      «expr • » p («expr⊤») = Submodule.map M.mkq («expr • » p («expr⊤»)) := by\n        rw [Submodule.map_smul'', Submodule.map_top, M.range_mkq]\n      _ = «expr⊤» := by rw [Ideal.smul_top_eq_map, (Submodule.map_mkQ_eq_top M _).mpr hb']\n      \n  -- we can write the elements of `a` as `p`-linear combinations of other elements of `a`.\n  have exists_sum :\n    ∀ x : «expr ⧸ » S M,\n      ∃ a' : Fin n → R,\n        (∀ i, a' i ∈ p) ∧\n          finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n              («expr • » (a' i) (a i)) =\n            x :=\n    by\n    intro x\n    obtain ⟨a'', ha'', hx⟩ := (Submodule.mem_ideal_smul_span_iff_exists_sum p a x).1 _\n    · refine' ⟨fun i => a'' i, fun i => ha'' _, _⟩\n      rw [← hx, Finsupp.sum_fintype]\n      exact fun _ => zero_smul _ _\n    · rw [ha, smul_top_eq]\n      exact Submodule.mem_top\n  choose A' hA'p hA' using fun i => exists_sum (a i)\n  -- This gives us a(n invertible) matrix `A` such that `det A ∈ (M = span R b)`,\n  let A : Matrix (Fin n) (Fin n) R := A' - 1\n  let B := A.adjugate\n  have A_smul :\n    ∀ i,\n      finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n          («expr • » (A i j) (a j)) =\n        0 :=\n    by\n    intros\n    simp only [A, Pi.sub_apply, sub_smul, Finset.sum_sub_distrib, hA', Matrix.one_apply, ite_smul, one_smul, zero_smul,\n      Finset.sum_ite_eq, Finset.mem_univ, if_true, sub_self]\n  -- since `span S {det A} / M = 0`.\n  have d_smul : ∀ i, «expr • » A.det (a i) = 0 := by\n    intro i\n    calc\n      «expr • » A.det (a i) =\n          finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n            («expr • » ((matrix.mul B A) i j) (a j)) :=\n        _\n      _ =\n          finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n            («expr • » (B i k)\n              (finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n                («expr • » (A k j) (a j)))) :=\n        _\n      _ = 0 := Finset.sum_eq_zero fun k _ => _\n      \n    ·\n      simp only [Matrix.adjugate_mul, Pi.smul_apply, Matrix.one_apply, mul_ite, ite_smul, smul_eq_mul, mul_one,\n        MulZeroClass.mul_zero, one_smul, zero_smul, Finset.sum_ite_eq, Finset.mem_univ, if_true]\n    · simp only [Matrix.mul_apply, Finset.smul_sum, Finset.sum_smul, smul_smul]\n      rw [Finset.sum_comm]\n    · rw [A_smul, smul_zero]\n  -- In the rings of integers we have the desired inclusion.\n  have span_d : (Submodule.span S ({algebraMap R S A.det} : Set S)).restrict_scalars R ≤ M :=\n    by\n    intro x hx\n    rw [Submodule.restrictScalars_mem] at hx\n    obtain ⟨x', rfl⟩ := submodule.mem_span_singleton.mp hx\n    rw [smul_eq_mul, mul_comm, ← Algebra.smul_def] at hx⊢\n    rw [← Submodule.Quotient.mk_eq_zero, Submodule.Quotient.mk_smul]\n    obtain ⟨a', _, quot_x_eq⟩ := exists_sum (Submodule.Quotient.mk x')\n    simp_rw [← quot_x_eq, Finset.smul_sum, smul_comm A.det, d_smul, smul_zero, Finset.sum_const_zero]\n  -- So now we lift everything to the fraction field.\n  refine'\n    top_le_iff.mp\n      (calc\n        «expr⊤» = (Ideal.span {algebraMap R L A.det}).restrict_scalars K := _\n        _ ≤ Submodule.span K («expr '' » (algebraMap S L) b) := _\n        )\n  -- Because `det A ≠ 0`, we have `span L {det A} = ⊤`.\n  · rw [eq_comm, Submodule.restrictScalars_eq_top_iff, Ideal.span_singleton_eq_top]\n    refine'\n      IsUnit.mk0 _ ((map_ne_zero_iff (algebraMap R L) hRL).mpr (@ne_zero_of_map _ _ _ _ _ _ (Ideal.Quotient.mk p) _ _))\n    haveI := Ideal.Quotient.nontrivial hp\n    calc\n      Ideal.Quotient.mk p A.det = Matrix.det ((Ideal.Quotient.mk p).map_matrix A) := by\n        rw [RingHom.map_det, ring_hom.map_matrix_apply]\n      _ = Matrix.det ((Ideal.Quotient.mk p).map_matrix (A' - 1)) := rfl\n      _ = Matrix.det fun i j => (Ideal.Quotient.mk p) (A' i j) - (1 : Matrix (Fin n) (Fin n) («expr ⧸ » R p)) i j := _\n      _ = Matrix.det (-1 : Matrix (Fin n) (Fin n) («expr ⧸ » R p)) := _\n      _ = (-1 : «expr ⧸ » R p) ^ n := by rw [Matrix.det_neg, Fintype.card_fin, Matrix.det_one, mul_one]\n      _ ≠ 0 := IsUnit.ne_zero (is_unit_one.neg.pow _)\n      \n    · refine' congr_arg Matrix.det (Matrix.ext fun i j => _)\n      rw [map_sub, ring_hom.map_matrix_apply, map_one]\n      rfl\n    · refine' congr_arg Matrix.det (Matrix.ext fun i j => _)\n      rw [ideal.quotient.eq_zero_iff_mem.mpr (hA'p i j), zero_sub]\n      rfl\n  -- And we conclude `L = span L {det A} ≤ span K b`, so `span K b` spans everything.\n  · intro x hx\n    rw [Submodule.restrictScalars_mem, IsScalarTower.algebraMap_apply R S L] at hx\n    refine' is_fraction_ring.ideal_span_singleton_map_subset R _ hRL span_d hx\n    haveI : NoZeroSMulDivisors R L := NoZeroSMulDivisors.of_algebraMap_injective hRL\n    rw [← is_fraction_ring.is_algebraic_iff' R S]\n    intro x\n    exact is_integral.is_algebraic _ (is_integral_of_noetherian inferInstance _)\n#align finrank_quotient_map.span_eq_top finrank_quotient_map.span_eq_top\n\n",
 "rank_prime_pow_ramification_idx":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expre -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expre -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expre -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expre -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expre -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/-- If `p` is a maximal ideal of `R`, `S` extends `R` and `P^e` lies over `p`,\nthen the dimension `[S/(P^e) : R/p]` is equal to `e * [S/P : R/p]`. -/\ntheorem rank_prime_pow_ramification_idx [IsDomain S] [is_dedekind_domain S] [p.is_maximal] [P.is_prime]\n    (hP0 : P ≠ «expr⊥») (he : expre ≠ 0) :\n    Module.rank («expr ⧸ » R p) («expr ⧸ » S (P ^ expre)) =\n      «expr • » (expre)\n        (@Module.rank («expr ⧸ » R p) («expr ⧸ » S P) _ _\n          (@Algebra.toModule _ _ _ _ <| @quotient.algebra_quotient_of_ramification_idx_ne_zero _ _ _ _ _ ⟨he⟩)) :=\n  by\n  letI : NeZero (expre) := ⟨he⟩\n  have := rank_pow_quot f p P hP0 0 (nat.zero_le (expre))\n  rw [pow_zero, nat.sub_zero, Ideal.one_eq_top, Ideal.map_top] at this\n  exact (rank_top («expr ⧸ » R p) _).symm.trans this\n#align rank_prime_pow_ramification_idx rank_prime_pow_ramification_idx\n\n",
 "rank_pow_quot_aux":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expre -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expre -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expre -/\n/-- Since the inclusion `(P^(i + 1) / P^e) ⊂ (P^i / P^e)` has a kernel isomorphic to `P / S`,\n`[P^i / P^e : R / p] = [P^(i+1) / P^e : R / p] + [P / S : R / p]` -/\ntheorem rank_pow_quot_aux [IsDomain S] [is_dedekind_domain S] [p.is_maximal] [P.is_prime] (hP0 : P ≠ «expr⊥») {i : ℕ}\n    (hi : i < expre) :\n    Module.rank («expr ⧸ » R p) (Ideal.map (P ^ expre).quotient.mk (P ^ i)) =\n      Module.rank («expr ⧸ » R p) («expr ⧸ » S P) +\n        Module.rank («expr ⧸ » R p) (Ideal.map (P ^ expre).quotient.mk (P ^ (i + 1))) :=\n  by\n  letI : Field («expr ⧸ » R p) := Ideal.Quotient.field _\n  rw [rank_eq_of_injective _ (pow_quot_succ_inclusion_injective f p P i),\n    (quotient_range_pow_quot_succ_inclusion_equiv f p P hP0 hi).symm.rank_eq]\n  exact (rank_quotient_add_rank (LinearMap.range (pow_quot_succ_inclusion f p P i))).symm\n#align rank_pow_quot_aux rank_pow_quot_aux\n\n",
 "rank_pow_quot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expre -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expre -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expre -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expre -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expre -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\ntheorem rank_pow_quot [IsDomain S] [is_dedekind_domain S] [p.is_maximal] [P.is_prime] (hP0 : P ≠ «expr⊥») (i : ℕ)\n    (hi : i ≤ expre) :\n    Module.rank («expr ⧸ » R p) (Ideal.map (P ^ expre).quotient.mk (P ^ i)) =\n      «expr • » (expre - i) (Module.rank («expr ⧸ » R p) («expr ⧸ » S P)) :=\n  by\n  refine' @Nat.decreasingInduction' _ i (expre) (fun j lt_e le_j ih => _) hi _\n  · rw [rank_pow_quot_aux f p P _ lt_e, ih, ← succ_nsmul, nat.sub_succ, ← nat.succ_eq_add_one,\n      nat.succ_pred_eq_of_pos (nat.sub_pos_of_lt lt_e)]\n    assumption\n  · rw [nat.sub_self, zero_nsmul, map_quotient_self]\n    exact rank_bot («expr ⧸ » R p) («expr ⧸ » S (P ^ expre))\n#align rank_pow_quot rank_pow_quot\n\n",
 "ramification_idx_spec":
 "theorem ramification_idx_spec {n : ℕ} (hle : map f p ≤ P ^ n) (hgt : ¬map f p ≤ P ^ (n + 1)) :\n    ramification_idx f p P = n :=\n  by\n  have : ∀ k : ℕ, map f p ≤ P ^ k → k ≤ n := by\n    intro k hk\n    refine' le_of_not_lt fun hnk => _\n    exact hgt (hk.trans (Ideal.pow_le_pow hnk))\n  rw [ramification_idx_eq_find ⟨n, this⟩]\n  · refine' le_antisymm (nat.find_min' _ this) (le_of_not_gt fun h : nat.find _ < n => _)\n    obtain this' := nat.find_spec ⟨n, this⟩\n    exact h.not_le (this' _ hle)\n#align ramification_idx_spec ramification_idx_spec\n\n",
 "ramification_idx_of_not_le":
 "@[simp]\ntheorem ramification_idx_of_not_le (h : ¬map f p ≤ P) : ramification_idx f p P = 0 :=\n  ramification_idx_spec (by simp) (by simpa using h)\n#align ramification_idx_of_not_le ramification_idx_of_not_le\n\n",
 "ramification_idx_ne_zero":
 "theorem factors.ramification_idx_ne_zero (P : (factors (map (algebraMap R S) p)).to_finset) :\n    ramification_idx (algebraMap R S) p P ≠ 0 :=\n  is_dedekind_domain.ramification_idx_ne_zero (ne_zero_of_mem_factors (Multiset.mem_toFinset.mp P.2))\n    (factors.is_prime p P) (Ideal.le_of_dvd (dvd_of_mem_factors (Multiset.mem_toFinset.mp P.2)))\n#align factors.ramification_idx_ne_zero factors.ramification_idx_ne_zero\n\n",
 "ramification_idx_lt":
 "theorem ramification_idx_lt {n : ℕ} (hgt : ¬map f p ≤ P ^ n) : ramification_idx f p P < n :=\n  by\n  cases n\n  · simpa using hgt\n  rw [Nat.lt_succ_iff]\n  have : ∀ k, map f p ≤ P ^ k → k ≤ n :=\n    by\n    refine' fun k hk => le_of_not_lt fun hnk => _\n    exact hgt (hk.trans (Ideal.pow_le_pow hnk))\n  rw [ramification_idx_eq_find ⟨n, this⟩]\n  exact nat.find_min' ⟨n, this⟩ this\n#align ramification_idx_lt ramification_idx_lt\n\n",
 "ramification_idx_eq_zero":
 "theorem ramification_idx_eq_zero (h : ∀ n : ℕ, ∃ k, map f p ≤ P ^ k ∧ n < k) : ramification_idx f p P = 0 :=\n  dif_neg (by push_neg <;> exact h)\n#align ramification_idx_eq_zero ramification_idx_eq_zero\n\n",
 "ramification_idx_eq_normalized_factors_count":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem ramification_idx_eq_normalized_factors_count (hp0 : map f p ≠ «expr⊥») (hP : P.is_prime) (hP0 : P ≠ «expr⊥») :\n    ramification_idx f p P = (normalizedFactors (map f p)).count P :=\n  by\n  have hPirr := (ideal.prime_of_is_prime hP0 hP).irreducible\n  refine' ramification_idx_spec (Ideal.le_of_dvd _) (mt ideal.dvd_iff_le.mpr _) <;>\n    rw [dvd_iff_normalized_factors_le_normalized_factors (pow_ne_zero _ hP0) hp0, normalized_factors_pow,\n      normalized_factors_irreducible hPirr, normalize_eq, Multiset.nsmul_singleton, ←\n      Multiset.le_count_iff_replicate_le]\n  · exact (nat.lt_succ_self _).not_le\n#align ramification_idx_eq_normalized_factors_count ramification_idx_eq_normalized_factors_count\n\n",
 "ramification_idx_eq_find":
 "/-\nCopyright (c) 2022 Anne Baanen. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Anne Baanen\n-/\ntheorem ramification_idx_eq_find (h : ∃ n, ∀ k, map f p ≤ P ^ k → k ≤ n) : ramification_idx f p P = nat.find h :=\n  Nat.supₛ_def h\n#align ramification_idx_eq_find ramification_idx_eq_find\n\n",
 "ramification_idx_eq_factors_count":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem ramification_idx_eq_factors_count (hp0 : map f p ≠ «expr⊥») (hP : P.is_prime) (hP0 : P ≠ «expr⊥») :\n    ramification_idx f p P = (factors (map f p)).count P := by\n  rw [is_dedekind_domain.ramification_idx_eq_normalized_factors_count hp0 hP hP0, factors_eq_normalized_factors]\n#align ramification_idx_eq_factors_count ramification_idx_eq_factors_count\n\n",
 "ramification_idx_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem ramification_idx_bot : ramification_idx f («expr⊥») P = 0 :=\n  dif_neg <| not_exists.mpr fun n hn => n.lt_succ_self.not_le (hn _ (by simp))\n#align ramification_idx_bot ramification_idx_bot\n\n",
 "quotient_to_quotient_range_pow_quot_succ_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expre -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expre -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expre -/\ntheorem quotient_to_quotient_range_pow_quot_succ_surjective [IsDomain S] [is_dedekind_domain S] (hP0 : P ≠ «expr⊥»)\n    [hP : P.is_prime] {i : ℕ} (hi : i < expre) {a : S} (a_mem : a ∈ P ^ i) (a_not_mem : a ∉ P ^ (i + 1)) :\n    function.surjective (quotient_to_quotient_range_pow_quot_succ f p P a_mem) :=\n  by\n  rintro ⟨⟨⟨x⟩, hx⟩⟩\n  have Pe_le_Pi : P ^ expre ≤ P ^ i := Ideal.pow_le_pow hi.le\n  have Pe_le_Pi1 : P ^ expre ≤ P ^ (i + 1) := Ideal.pow_le_pow hi\n  rw [Submodule.Quotient.quot_mk_eq_mk, Ideal.Quotient.mk_eq_mk, Ideal.mem_quotient_iff_mem_sup,\n    sup_eq_left.mpr Pe_le_Pi] at hx\n  suffices hx' : x ∈ «expr ⊔ » (Ideal.span {a}) (P ^ (i + 1))\n  · obtain ⟨y', hy', z, hz, rfl⟩ := submodule.mem_sup.mp hx'\n    obtain ⟨y, rfl⟩ := ideal.mem_span_singleton.mp hy'\n    refine' ⟨Submodule.Quotient.mk y, _⟩\n    simp only [Submodule.Quotient.quot_mk_eq_mk, quotient_to_quotient_range_pow_quot_succ_mk, Submodule.Quotient.eq,\n      LinearMap.mem_range, Subtype.ext_iff, Subtype.coe_mk, Submodule.coe_sub]\n    refine' ⟨⟨_, Ideal.mem_map_of_mem _ (Submodule.neg_mem _ hz)⟩, _⟩\n    rw [pow_quot_succ_inclusion_apply_coe, Subtype.coe_mk, Ideal.Quotient.mk_eq_mk, map_add, mul_comm y a,\n      sub_add_cancel', map_neg]\n  letI := Classical.decEq (Ideal S)\n  rw [sup_eq_prod_inf_factors _ (pow_ne_zero _ hP0), normalized_factors_pow,\n    normalized_factors_irreducible ((ideal.prime_iff_is_prime hP0).mpr hP).irreducible, normalize_eq,\n    Multiset.nsmul_singleton, Multiset.inter_replicate, Multiset.prod_replicate]\n  rw [← Submodule.span_singleton_le_iff_mem, Ideal.submodule_span_eq] at a_mem a_not_mem\n  rwa [ideal.count_normalized_factors_eq a_mem a_not_mem, min_eq_left i.le_succ]\n  · intro ha\n    rw [ideal.span_singleton_eq_bot.mp ha] at a_not_mem\n    have := (P ^ (i + 1)).zero_mem\n    contradiction\n#align quotient_to_quotient_range_pow_quot_succ_surjective quotient_to_quotient_range_pow_quot_succ_surjective\n\n",
 "quotient_to_quotient_range_pow_quot_succ_mk":
 "theorem quotient_to_quotient_range_pow_quot_succ_mk {i : ℕ} {a : S} (a_mem : a ∈ P ^ i) (x : S) :\n    quotient_to_quotient_range_pow_quot_succ f p P a_mem (Submodule.Quotient.mk x) =\n      Submodule.Quotient.mk ⟨_, Ideal.mem_map_of_mem _ (Ideal.mul_mem_left _ x a_mem)⟩ :=\n  quotient_to_quotient_range_pow_quot_succ_aux_mk f p P a_mem x\n#align quotient_to_quotient_range_pow_quot_succ_mk quotient_to_quotient_range_pow_quot_succ_mk\n\n",
 "quotient_to_quotient_range_pow_quot_succ_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expre -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expre -/\ntheorem quotient_to_quotient_range_pow_quot_succ_injective [IsDomain S] [is_dedekind_domain S] [P.is_prime] {i : ℕ}\n    (hi : i < expre) {a : S} (a_mem : a ∈ P ^ i) (a_not_mem : a ∉ P ^ (i + 1)) :\n    function.injective (quotient_to_quotient_range_pow_quot_succ f p P a_mem) := fun x =>\n  Quotient.inductionOn' x fun x y =>\n    Quotient.inductionOn' y fun y h =>\n      by\n      have Pe_le_Pi1 : P ^ expre ≤ P ^ (i + 1) := Ideal.pow_le_pow hi\n      simp only [Submodule.Quotient.mk''_eq_mk, quotient_to_quotient_range_pow_quot_succ_mk, Submodule.Quotient.eq,\n        LinearMap.mem_range, Subtype.ext_iff, Subtype.coe_mk, Submodule.coe_sub] at h⊢\n      rcases h with ⟨⟨⟨z⟩, hz⟩, h⟩\n      rw [Submodule.Quotient.quot_mk_eq_mk, Ideal.Quotient.mk_eq_mk, Ideal.mem_quotient_iff_mem_sup,\n        sup_eq_left.mpr Pe_le_Pi1] at hz\n      rw [pow_quot_succ_inclusion_apply_coe, Subtype.coe_mk, Submodule.Quotient.quot_mk_eq_mk, Ideal.Quotient.mk_eq_mk,\n        ← map_sub, Ideal.Quotient.eq, ← sub_mul] at h\n      exact (ideal.is_prime.mul_mem_pow _ ((Submodule.sub_mem_iff_right _ hz).mp (Pe_le_Pi1 h))).resolve_right a_not_mem\n#align quotient_to_quotient_range_pow_quot_succ_injective quotient_to_quotient_range_pow_quot_succ_injective\n\n",
 "quotient_to_quotient_range_pow_quot_succ_aux_mk":
 "theorem quotient_to_quotient_range_pow_quot_succ_aux_mk {i : ℕ} {a : S} (a_mem : a ∈ P ^ i) (x : S) :\n    quotient_to_quotient_range_pow_quot_succ_aux f p P a_mem (Submodule.Quotient.mk x) =\n      Submodule.Quotient.mk ⟨_, Ideal.mem_map_of_mem _ (Ideal.mul_mem_left _ x a_mem)⟩ :=\n  by apply quotient.map'_mk'\n#align quotient_to_quotient_range_pow_quot_succ_aux_mk quotient_to_quotient_range_pow_quot_succ_aux_mk\n\n",
 "pow_quot_succ_inclusion_injective":
 "theorem pow_quot_succ_inclusion_injective (i : ℕ) : function.injective (pow_quot_succ_inclusion f p P i) :=\n  by\n  rw [← LinearMap.ker_eq_bot, LinearMap.ker_eq_bot']\n  rintro ⟨x, hx⟩ hx0\n  rw [Subtype.ext_iff] at hx0⊢\n  rwa [pow_quot_succ_inclusion_apply_coe] at hx0\n#align pow_quot_succ_inclusion_injective pow_quot_succ_inclusion_injective\n\n",
 "pi_quotient_equiv_mk":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem factors.pi_quotient_equiv_mk (p : Ideal R) (hp : map (algebraMap R S) p ≠ «expr⊥») (x : S) :\n    factors.pi_quotient_equiv p hp (Ideal.Quotient.mk _ x) = fun P => Ideal.Quotient.mk _ x :=\n  rfl\n#align factors.pi_quotient_equiv_mk factors.pi_quotient_equiv_mk\n\n",
 "pi_quotient_equiv_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem factors.pi_quotient_equiv_map (p : Ideal R) (hp : map (algebraMap R S) p ≠ «expr⊥») (x : R) :\n    factors.pi_quotient_equiv p hp (algebraMap _ _ x) = fun P => Ideal.Quotient.mk _ (algebraMap _ _ x) :=\n  rfl\n#align factors.pi_quotient_equiv_map factors.pi_quotient_equiv_map\n\n",
 "ne_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem factors.ne_bot (P : (factors (map (algebraMap R S) p)).to_finset) : (P : Ideal S) ≠ «expr⊥» :=\n  (prime_of_factor _ (Multiset.mem_toFinset.mp P.2)).ne_zero\n#align factors.ne_bot factors.ne_bot\n\n",
 "linear_independent_of_nontrivial":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/-- Let `V` be a vector space over `K = Frac(R)`, `S / R` a ring extension\nand `V'` a module over `S`. If `b`, in the intersection `V''` of `V` and `V'`,\nis linear independent over `S` in `V'`, then it is linear independent over `R` in `V`.\n\nThe statement we prove is actually slightly more general:\n * it suffices that the inclusion `algebra_map R S : R → S` is nontrivial\n * the function `f' : V'' → V'` doesn't need to be injective\n-/\ntheorem finrank_quotient_map.linear_independent_of_nontrivial [IsDomain R] [is_dedekind_domain R]\n    (hRS : (algebraMap R S).ker ≠ «expr⊤») (f : «expr →ₗ[ ] » V'' R V) (hf : function.injective f)\n    (f' : «expr →ₗ[ ] » V'' R V') {ι : Type _} {b : ι → V''} (hb' : LinearIndependent S (f' ∘ b)) :\n    LinearIndependent K (f ∘ b) := by\n  contrapose! hb' with hb\n  -- Informally, if we have a nontrivial linear dependence with coefficients `g` in `K`,\n  -- then we can find a linear dependence with coefficients `I.quotient.mk g'` in `R/I`,\n  -- where `I = ker (algebra_map R S)`.\n  -- We make use of the same principle but stay in `R` everywhere.\n  simp only [linearIndependent_iff', not_forall] at hb⊢\n  obtain ⟨s, g, eq, j', hj's, hj'g⟩ := hb\n  use s\n  obtain ⟨a, hag, j, hjs, hgI⟩ := ideal.exist_integer_multiples_not_mem hRS s g hj's hj'g\n  choose g'' hg'' using hag\n  letI := classical.prop_decidable\n  let g' i := if h : i ∈ s then g'' i h else 0\n  have hg' : ∀ i ∈ s, algebraMap _ _ (g' i) = a * g i :=\n    by\n    intro i hi\n    exact (congr_arg _ (dif_pos hi)).trans (hg'' i hi)\n  -- Because `R/I` is nontrivial, we can lift `g` to a nontrivial linear dependence in `S`.\n  have hgI : algebraMap R S (g' j) ≠ 0 :=\n    by\n    simp only [fractional_ideal.mem_coe_ideal, not_exists, not_and'] at hgI\n    exact hgI _ (hg' j hjs)\n  refine' ⟨fun i => algebraMap R S (g' i), _, j, hjs, hgI⟩\n  have eq :\n    f\n        (finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s\n          («expr • » (g' i) (b i))) =\n      0 :=\n    by\n    rw [LinearMap.map_sum, ← smul_zero a, ← Eq, Finset.smul_sum, Finset.sum_congr rfl]\n    intro i hi\n    rw [LinearMap.map_smul, ← IsScalarTower.algebraMap_smul K, hg' i hi, ← smul_assoc, smul_eq_mul]\n    infer_instance\n  simp only [IsScalarTower.algebraMap_smul, ← LinearMap.map_smul, ← LinearMap.map_sum, (f.map_eq_zero_iff hf).mp Eq,\n    LinearMap.map_zero]\n#align finrank_quotient_map.linear_independent_of_nontrivial finrank_quotient_map.linear_independent_of_nontrivial\n\n",
 "le_pow_ramification_idx":
 "theorem le_pow_ramification_idx : map f p ≤ P ^ ramification_idx f p P :=\n  le_pow_of_le_ramification_idx (le_refl _)\n#align le_pow_ramification_idx le_pow_ramification_idx\n\n",
 "le_pow_of_le_ramification_idx":
 "theorem le_pow_of_le_ramification_idx {n : ℕ} (hn : n ≤ ramification_idx f p P) : map f p ≤ P ^ n :=\n  by\n  contrapose! hn\n  exact ramification_idx_lt hn\n#align le_pow_of_le_ramification_idx le_pow_of_le_ramification_idx\n\n",
 "le_comap_pow_ramification_idx":
 "theorem le_comap_pow_ramification_idx : p ≤ comap f (P ^ ramification_idx f p P) :=\n  map_le_iff_le_comap.mp le_pow_ramification_idx\n#align le_comap_pow_ramification_idx le_comap_pow_ramification_idx\n\n",
 "le_comap_of_ramification_idx_ne_zero":
 "theorem le_comap_of_ramification_idx_ne_zero (h : ramification_idx f p P ≠ 0) : p ≤ comap f P :=\n  Ideal.map_le_iff_le_comap.mp <| le_pow_ramification_idx.trans <| Ideal.pow_le_self <| h\n#align le_comap_of_ramification_idx_ne_zero le_comap_of_ramification_idx_ne_zero\n\n",
 "inertia_deg_of_subsingleton":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n-- Useful for the `nontriviality` tactic using `comap_eq_of_scalar_tower_quotient`.\n@[simp]\ntheorem inertia_deg_of_subsingleton [hp : p.is_maximal] [hQ : subsingleton («expr ⧸ » S P)] : inertia_deg f p P = 0 :=\n  by\n  have := ideal.quotient.subsingleton_iff.mp hQ\n  subst this\n  exact dif_neg fun h => hp.ne_top <| h.symm.trans comap_top\n#align inertia_deg_of_subsingleton inertia_deg_of_subsingleton\n\n",
 "inertia_deg_ne_zero":
 "theorem factors.inertia_deg_ne_zero [IsNoetherian R S] [p.is_maximal]\n    (P : (factors (map (algebraMap R S) p)).to_finset) : inertia_deg (algebraMap R S) p P ≠ 0 :=\n  by\n  rw [inertia_deg_algebra_map]\n  exact (finite_dimensional.finrank_pos_iff.mpr inferInstance).ne'\n#align factors.inertia_deg_ne_zero factors.inertia_deg_ne_zero\n\n",
 "inertia_deg_algebra_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n@[simp]\ntheorem inertia_deg_algebra_map [Algebra R S] [Algebra («expr ⧸ » R p) («expr ⧸ » S P)]\n    [IsScalarTower R («expr ⧸ » R p) («expr ⧸ » S P)] [hp : p.is_maximal] :\n    inertia_deg (algebraMap R S) p P = finrank («expr ⧸ » R p) («expr ⧸ » S P) :=\n  by\n  nontriviality «expr ⧸ » S P using inertia_deg_of_subsingleton, finrank_zero_of_subsingleton\n  have := comap_eq_of_scalar_tower_quotient (algebraMap («expr ⧸ » R p) («expr ⧸ » S P)).injective\n  rw [inertia_deg, dif_pos this]\n  congr\n  refine' Algebra.algebra_ext _ _ fun x' => Quotient.inductionOn' x' fun x => _\n  change Ideal.Quotient.lift p _ _ (Ideal.Quotient.mk p x) = algebraMap _ _ (Ideal.Quotient.mk p x)\n  rw [Ideal.Quotient.lift_mk, ← Ideal.Quotient.algebraMap_eq, ← IsScalarTower.algebraMap_eq, ←\n    Ideal.Quotient.algebraMap_eq, ← IsScalarTower.algebraMap_apply]\n#align inertia_deg_algebra_map inertia_deg_algebra_map\n\n",
 "finrank_quotient_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/-- If `p` is a maximal ideal of `R`, and `S` is the integral closure of `R` in `L`,\nthen the dimension `[S/pS : R/p]` is equal to `[Frac(S) : Frac(R)]`. -/\ntheorem finrank_quotient_map [IsDomain R] [IsDomain S] [is_dedekind_domain R] [Algebra K L] [Algebra R L]\n    [IsScalarTower R K L] [IsScalarTower R S L] [is_integral_closure S R L] [hp : p.is_maximal] [IsNoetherian R S] :\n    finrank («expr ⧸ » R p) («expr ⧸ » S (map (algebraMap R S) p)) = finrank K L :=\n  by\n  -- Choose an arbitrary basis `b` for `[S/pS : R/p]`.\n  -- We'll use the previous results to turn it into a basis on `[Frac(S) : Frac(R)]`.\n  letI : Field («expr ⧸ » R p) := Ideal.Quotient.field _\n  let ι := Module.Free.ChooseBasisIndex («expr ⧸ » R p) («expr ⧸ » S (map (algebraMap R S) p))\n  let b : Basis ι («expr ⧸ » R p) («expr ⧸ » S (map (algebraMap R S) p)) := Module.Free.chooseBasis _ _\n  -- Namely, choose a representative `b' i : S` for each `b i : S / pS`.\n  let b' : ι → S := fun i => (Ideal.Quotient.mk_surjective (b i)).some\n  have b_eq_b' : «expr⇑ » b = (Submodule.mkQ _).restrict_scalars R ∘ b' :=\n    funext fun i => (Ideal.Quotient.mk_surjective (b i)).some_spec.symm\n  -- We claim `b'` is a basis for `Frac(S)` over `Frac(R)` because it is linear independent\n  -- and spans the whole of `Frac(S)`.\n  let b'' : ι → L := algebraMap S L ∘ b'\n  have b''_li : LinearIndependent _ b'' := _\n  have b''_sp : Submodule.span _ (Set.range b'') = «expr⊤» := _\n  -- Since the two bases have the same index set, the spaces have the same dimension.\n  let c : Basis ι K L := Basis.mk b''_li b''_sp.ge\n  rw [finrank_eq_card_basis b, finrank_eq_card_basis c]\n  -- It remains to show that the basis is indeed linear independent and spans the whole space.\n  · rw [Set.range_comp]\n    refine' finrank_quotient_map.span_eq_top p hp.ne_top _ (top_le_iff.mp _)\n    -- The nicest way to show `S ≤ span b' ⊔ pS` is by reducing both sides modulo pS.\n    -- However, this would imply distinguishing between `pS` as `S`-ideal,\n    -- and `pS` as `R`-submodule, since they have different (non-defeq) quotients.\n    -- Instead we'll lift `x mod pS ∈ span b` to `y ∈ span b'` for some `y - x ∈ pS`.\n    intro x hx\n    have mem_span_b :\n      ((Submodule.mkQ (map (algebraMap R S) p)) x : «expr ⧸ » S (map (algebraMap R S) p)) ∈\n        Submodule.span («expr ⧸ » R p) (Set.range b) :=\n      b.mem_span _\n    rw [← @Submodule.restrictScalars_mem R,\n      Submodule.restrictScalars_span R («expr ⧸ » R p) Ideal.Quotient.mk_surjective, b_eq_b', Set.range_comp, ←\n      Submodule.map_span] at mem_span_b\n    obtain ⟨y, y_mem, y_eq⟩ := submodule.mem_map.mp mem_span_b\n    suffices y + -(y - x) ∈ _ by simpa\n    rw [LinearMap.restrictScalars_apply, Submodule.mkQ_apply, Submodule.mkQ_apply, Submodule.Quotient.eq] at y_eq\n    exact add_mem (Submodule.mem_sup_left y_mem) (neg_mem <| Submodule.mem_sup_right y_eq)\n  · have := b.linear_independent\n    rw [b_eq_b'] at this\n    convert finrank_quotient_map.linear_independent_of_nontrivial K _ ((Algebra.linearMap S L).restrict_scalars R) _\n        ((Submodule.mkQ _).restrict_scalars R) this\n    · rw [quotient.algebra_map_eq, Ideal.mk_ker]\n      exact hp.ne_top\n    · exact IsFractionRing.injective S L\n#align finrank_quotient_map finrank_quotient_map\n\n",
 "finrank_prime_pow_ramification_idx":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expre -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expre -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expre -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expre -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/-- If `p` is a maximal ideal of `R`, `S` extends `R` and `P^e` lies over `p`,\nthen the dimension `[S/(P^e) : R/p]`, as a natural number, is equal to `e * [S/P : R/p]`. -/\ntheorem finrank_prime_pow_ramification_idx [IsDomain S] [is_dedekind_domain S] (hP0 : P ≠ «expr⊥») [p.is_maximal]\n    [P.is_prime] (he : expre ≠ 0) :\n    finrank («expr ⧸ » R p) («expr ⧸ » S (P ^ expre)) =\n      expre *\n        @finrank («expr ⧸ » R p) («expr ⧸ » S P) _ _\n          (@Algebra.toModule _ _ _ _ <| @quotient.algebra_quotient_of_ramification_idx_ne_zero _ _ _ _ _ ⟨he⟩) :=\n  by\n  letI : NeZero (expre) := ⟨he⟩\n  letI : Algebra («expr ⧸ » R p) («expr ⧸ » S P) := quotient.algebra_quotient_of_ramification_idx_ne_zero f p P\n  letI := Ideal.Quotient.field p\n  have hdim := rank_prime_pow_ramification_idx _ _ _ hP0 he\n  by_cases hP : FiniteDimensional («expr ⧸ » R p) («expr ⧸ » S P)\n  · haveI := hP\n    haveI := (finite_dimensional_iff_of_rank_eq_nsmul he hdim).mpr hP\n    refine' Cardinal.natCast_injective _\n    rw [finrank_eq_rank', Nat.cast_mul, finrank_eq_rank', hdim, nsmul_eq_mul]\n  have hPe := mt (finite_dimensional_iff_of_rank_eq_nsmul he hdim).mp hP\n  simp only [finrank_of_infinite_dimensional hP, finrank_of_infinite_dimensional hPe, MulZeroClass.mul_zero]\n#align finrank_prime_pow_ramification_idx finrank_prime_pow_ramification_idx\n\n",
 "finrank_pow_ramification_idx":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\ntheorem factors.finrank_pow_ramification_idx [p.is_maximal] (P : (factors (map (algebraMap R S) p)).to_finset) :\n    finrank («expr ⧸ » R p) («expr ⧸ » S ((P : Ideal S) ^ ramification_idx (algebraMap R S) p P)) =\n      ramification_idx (algebraMap R S) p P * inertia_deg (algebraMap R S) p P :=\n  by\n  rw [finrank_prime_pow_ramification_idx, inertia_deg_algebra_map]\n  exact factors.ne_bot p P\n#align factors.finrank_pow_ramification_idx factors.finrank_pow_ramification_idx\n\n",
 "algebra_map_quotient_pow_ramification_idx":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expre -/\n@[simp]\ntheorem quotient.algebra_map_quotient_pow_ramification_idx (x : R) :\n    algebraMap («expr ⧸ » R p) («expr ⧸ » S (P ^ expre)) (Ideal.Quotient.mk p x) = Ideal.Quotient.mk _ (f x) :=\n  rfl\n#align quotient.algebra_map_quotient_pow_ramification_idx quotient.algebra_map_quotient_pow_ramification_idx\n\n",
 "algebra_map_quotient_of_ramification_idx_ne_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n-- In this file, the value for `f` can be inferred.\n@[simp]\ntheorem quotient.algebra_map_quotient_of_ramification_idx_ne_zero (x : R) :\n    algebraMap («expr ⧸ » R p) («expr ⧸ » S P) (Ideal.Quotient.mk p x) = Ideal.Quotient.mk _ (f x) :=\n  rfl\n#align quotient.algebra_map_quotient_of_ramification_idx_ne_zero quotient.algebra_map_quotient_of_ramification_idx_ne_zero\n\n"}