{"vertex_subgroup":
 "theorem is_normal.vertex_subgroup (Sn : is_normal S) (c : C) (cS : c ∈ S.objs) : (S.vertex_subgroup cS).normal :=\n  {\n    conj_mem := fun x hx y => by\n      rw [mul_assoc]\n      exact Sn.conj' y hx }\n#align is_normal.vertex_subgroup is_normal.vertex_subgroup\n\n",
 "top_is_normal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem top_is_normal : is_normal («expr⊤» : subgroupoid C) :=\n  { wide := fun c => trivial\n    conj := fun a b c d e => trivial }\n#align top_is_normal top_is_normal\n\n",
 "subset_generated":
 "-- TODO: proof that generated is just \"words in X\" and generated_normal is similarly\ntheorem subset_generated (c d : C) : X c d ⊆ (generated X).arrows c d :=\n  by\n  dsimp only [generated, Inf]\n  simp only [subset_Inter₂_iff]\n  exact fun S hS f fS => hS _ _ fS\n#align subset_generated subset_generated\n\n",
 "obj_surjective_of_im_eq_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem obj_surjective_of_im_eq_top (hφ : function.injective φ.obj) (hφ' : im φ hφ = «expr⊤») :\n    function.surjective φ.obj := by\n  rintro d\n  rw [← mem_im_objs_iff, hφ']\n  apply mem_top_objs\n#align obj_surjective_of_im_eq_top obj_surjective_of_im_eq_top\n\n",
 "mul_mem_cancel_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem mul_mem_cancel_right {c d e : C} {f : «expr ⟶ » c d} {g : «expr ⟶ » d e} (hg : g ∈ S.arrows d e) :\n    «expr ≫ » f g ∈ S.arrows c e ↔ f ∈ S.arrows c d :=\n  by\n  constructor\n  · rintro h\n    suffices «expr ≫ » («expr ≫ » f g) (inv g) ∈ S.arrows c d by\n      simpa only [inv_eq_inv, is_iso.hom_inv_id, category.comp_id, category.assoc] using this\n    · apply S.mul h (S.inv hg)\n  · exact fun hf => S.mul hf hg\n#align mul_mem_cancel_right mul_mem_cancel_right\n\n",
 "mul_mem_cancel_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem mul_mem_cancel_left {c d e : C} {f : «expr ⟶ » c d} {g : «expr ⟶ » d e} (hf : f ∈ S.arrows c d) :\n    «expr ≫ » f g ∈ S.arrows c e ↔ g ∈ S.arrows d e :=\n  by\n  constructor\n  · rintro h\n    suffices «expr ≫ » (inv f) («expr ≫ » f g) ∈ S.arrows d e by\n      simpa only [inv_eq_inv, is_iso.inv_hom_id_assoc] using this\n    · apply S.mul (S.inv hf) h\n  · apply S.mul hf\n#align mul_mem_cancel_left mul_mem_cancel_left\n\n",
 "mem_top_objs":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem mem_top_objs (c : C) : c ∈ («expr⊤» : subgroupoid C).objs :=\n  by\n  dsimp [has_top.top, objs]\n  simp only [univ_nonempty]\n#align mem_top_objs mem_top_objs\n\n",
 "mem_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem mem_top {c d : C} (f : «expr ⟶ » c d) : f ∈ («expr⊤» : subgroupoid C).arrows c d :=\n  trivial\n#align mem_top mem_top\n\n",
 "mem_objs_of_tgt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem mem_objs_of_tgt {c d : C} {f : «expr ⟶ » c d} (h : f ∈ S.arrows c d) : d ∈ S.objs :=\n  ⟨«expr ≫ » (inv f) f, S.mul (S.inv h) h⟩\n#align mem_objs_of_tgt mem_objs_of_tgt\n\n",
 "mem_objs_of_src":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem mem_objs_of_src {c d : C} {f : «expr ⟶ » c d} (h : f ∈ S.arrows c d) : c ∈ S.objs :=\n  ⟨«expr ≫ » f (inv f), S.mul h (S.inv h)⟩\n#align mem_objs_of_src mem_objs_of_src\n\n",
 "mem_map_objs_iff":
 "theorem mem_map_objs_iff (hφ : function.injective φ.obj) (d : D) : d ∈ (map φ hφ S).objs ↔ ∃ c ∈ S.objs, φ.obj c = d :=\n  by\n  dsimp [objs, map]\n  constructor\n  · rintro ⟨f, hf⟩\n    change map.arrows φ hφ S d d f at hf\n    rw [map.arrows_iff] at hf\n    obtain ⟨c, d, g, ec, ed, eg, gS, eg⟩ := hf\n    exact ⟨c, ⟨mem_objs_of_src S eg, ec⟩⟩\n  · rintro ⟨c, ⟨γ, γS⟩, rfl⟩\n    exact ⟨φ.map γ, ⟨γ, γS⟩⟩\n#align mem_map_objs_iff mem_map_objs_iff\n\n",
 "mem_map_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem mem_map_iff (hφ : function.injective φ.obj) (S : subgroupoid C) {c d : D} (f : «expr ⟶ » c d) :\n    f ∈ (map φ hφ S).arrows c d ↔\n      ∃ (a b : C)(g : «expr ⟶ » a b)(ha : φ.obj a = c)(hb : φ.obj b = d)(hg : g ∈ S.arrows a b),\n        f = «expr ≫ » (eq_to_hom ha.symm) («expr ≫ » (φ.map g) (eq_to_hom hb)) :=\n  map.arrows_iff φ hφ S f\n#align mem_map_iff mem_map_iff\n\n",
 "mem_ker_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem mem_ker_iff {c d : C} (f : «expr ⟶ » c d) :\n    f ∈ (ker φ).arrows c d ↔ ∃ h : φ.obj c = φ.obj d, φ.map f = eq_to_hom h :=\n  mem_discrete_iff (φ.map f)\n#align mem_ker_iff mem_ker_iff\n\n",
 "mem_im_objs_iff":
 "theorem mem_im_objs_iff (hφ : function.injective φ.obj) (d : D) : d ∈ (im φ hφ).objs ↔ ∃ c : C, φ.obj c = d := by\n  simp only [im, mem_map_objs_iff, mem_top_objs, exists_true_left]\n#align mem_im_objs_iff mem_im_objs_iff\n\n",
 "mem_im_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem mem_im_iff (hφ : function.injective φ.obj) {c d : D} (f : «expr ⟶ » c d) :\n    f ∈ (im φ hφ).arrows c d ↔\n      ∃ (a b : C)(g : «expr ⟶ » a b)(ha : φ.obj a = c)(hb : φ.obj b = d),\n        f = «expr ≫ » (eq_to_hom ha.symm) («expr ≫ » (φ.map g) (eq_to_hom hb)) :=\n  by\n  convert map.arrows_iff φ hφ («expr⊤») f\n  simp only [has_top.top, mem_univ, exists_true_left]\n#align mem_im_iff mem_im_iff\n\n",
 "mem_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem mem_iff (S : subgroupoid C) (F : Σc d, «expr ⟶ » c d) : F ∈ S ↔ F.2.2 ∈ S.arrows F.1 F.2.1 :=\n  iff.rfl\n#align mem_iff mem_iff\n\n",
 "mem_full_objs_iff":
 "@[simp]\ntheorem mem_full_objs_iff {c : C} : c ∈ (full D).objs ↔ c ∈ D := by rw [full_objs]\n#align mem_full_objs_iff mem_full_objs_iff\n\n",
 "mem_full_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n@[simp]\ntheorem mem_full_iff {c d : C} {f : «expr ⟶ » c d} : f ∈ (full D).arrows c d ↔ c ∈ D ∧ d ∈ D :=\n  iff.rfl\n#align mem_full_iff mem_full_iff\n\n",
 "mem_discrete_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem mem_discrete_iff {c d : C} (f : «expr ⟶ » c d) : f ∈ discrete.arrows c d ↔ ∃ h : c = d, f = eq_to_hom h :=\n  ⟨by\n    rintro ⟨⟩\n    exact ⟨rfl, rfl⟩, by\n    rintro ⟨rfl, rfl⟩\n    constructor⟩\n#align mem_discrete_iff mem_discrete_iff\n\n",
 "mem_disconnect_objs_iff":
 "@[simp]\ntheorem mem_disconnect_objs_iff {c : C} : c ∈ S.disconnect.objs ↔ c ∈ S.objs :=\n  ⟨fun ⟨γ, h, γS⟩ => ⟨γ, γS⟩, fun ⟨γ, γS⟩ => ⟨γ, rfl, γS⟩⟩\n#align mem_disconnect_objs_iff mem_disconnect_objs_iff\n\n",
 "map_objs_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n@[simp]\ntheorem map_objs_eq (hφ : function.injective φ.obj) : (map φ hφ S).objs = «expr '' » φ.obj S.objs :=\n  by\n  ext\n  convert mem_map_objs_iff S φ hφ x\n  simp only [mem_image, exists_prop]\n#align map_objs_eq map_objs_eq\n\n",
 "map_mono":
 "theorem map_mono (hφ : function.injective φ.obj) (S T : subgroupoid C) : S ≤ T → map φ hφ S ≤ map φ hφ T := fun h =>\n  (galois_connection_map_comap φ hφ).monotone_l h\n#align map_mono map_mono\n\n",
 "map_le_iff_le_comap":
 "theorem map_le_iff_le_comap (hφ : function.injective φ.obj) (S : subgroupoid C) (T : subgroupoid D) :\n    map φ hφ S ≤ T ↔ S ≤ comap φ T :=\n  (galois_connection_map_comap φ hφ).le_iff_le\n#align map_le_iff_le_comap map_le_iff_le_comap\n\n",
 "map_comap_le":
 "theorem map_comap_le (hφ : function.injective φ.obj) (T : subgroupoid D) : map φ hφ (comap φ T) ≤ T :=\n  (galois_connection_map_comap φ hφ).l_u_le T\n#align map_comap_le map_comap_le\n\n",
 "le_objs":
 "theorem le_objs {S T : subgroupoid C} (h : S ≤ T) : S.objs ⊆ T.objs := fun s ⟨γ, hγ⟩ => ⟨γ, @h ⟨s, s, γ⟩ hγ⟩\n#align le_objs le_objs\n\n",
 "le_iff":
 "theorem le_iff (S T : subgroupoid C) : S ≤ T ↔ ∀ {c d}, S.arrows c d ⊆ T.arrows c d :=\n  by\n  rw [SetLike.le_def, sigma.forall]\n  exact forall_congr' fun c => sigma.forall\n#align le_iff le_iff\n\n",
 "le_comap_map":
 "theorem le_comap_map (hφ : function.injective φ.obj) (S : subgroupoid C) : S ≤ comap φ (map φ hφ S) :=\n  (galois_connection_map_comap φ hφ).le_u_l S\n#align le_comap_map le_comap_map\n\n",
 "ker_is_normal":
 "theorem ker_is_normal : (ker φ).is_normal :=\n  is_normal_comap φ discrete_is_normal\n#align ker_is_normal ker_is_normal\n\n",
 "ker_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n@[simp]\ntheorem ker_comp {E : Type _} [groupoid E] (ψ : «expr ⥤ » D E) : ker («expr ⋙ » φ ψ) = comap φ (ker ψ) :=\n  rfl\n#align ker_comp ker_comp\n\n",
 "is_wide_iff_objs_eq_univ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem is_wide_iff_objs_eq_univ : S.is_wide ↔ S.objs = Set.univ :=\n  by\n  constructor\n  · rintro h\n    ext\n    constructor <;> simp only [top_eq_univ, mem_univ, imp_true_iff, forall_true_left]\n    apply mem_objs_of_src S (h.wide x)\n  · rintro h\n    refine' ⟨fun c => _⟩\n    obtain ⟨γ, γS⟩ := (le_of_eq h.symm : «expr⊤» ⊆ S.objs) (Set.mem_univ c)\n    exact id_mem_of_src S γS\n#align is_wide_iff_objs_eq_univ is_wide_iff_objs_eq_univ\n\n",
 "is_totally_disconnected_iff":
 "theorem is_totally_disconnected_iff : S.is_totally_disconnected ↔ ∀ c d, (S.arrows c d).nonempty → c = d :=\n  by\n  constructor\n  · rintro h c d ⟨f, fS⟩\n    rw [← @subtype.mk_eq_mk _ _ c (mem_objs_of_src S fS) d (mem_objs_of_tgt S fS)]\n    exact h ⟨c, mem_objs_of_src S fS⟩ ⟨d, mem_objs_of_tgt S fS⟩ ⟨f, fS⟩\n  · rintro h ⟨c, hc⟩ ⟨d, hd⟩ ⟨f, fS⟩\n    simp only [subtype.mk_eq_mk]\n    exact h c d ⟨f, fS⟩\n#align is_totally_disconnected_iff is_totally_disconnected_iff\n\n",
 "is_thin_iff":
 "theorem is_thin_iff : S.is_thin ↔ ∀ c : S.objs, subsingleton (S.arrows c c) := by apply is_thin_iff\n#align is_thin_iff is_thin_iff\n\n",
 "is_normal_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem is_normal_map (hφ : function.injective φ.obj) (hφ' : im φ hφ = «expr⊤») (Sn : S.is_normal) :\n    (map φ hφ S).is_normal :=\n  { wide := fun d => by\n      obtain ⟨c, rfl⟩ := obj_surjective_of_im_eq_top φ hφ hφ' d\n      change map.arrows φ hφ S _ _ ((«expr𝟙») _)\n      rw [← Functor.map_id]\n      constructor\n      exact Sn.wide c\n    conj := fun d d' g δ hδ => by\n      rw [mem_map_iff] at hδ\n      obtain ⟨c, c', γ, cd, cd', γS, hγ⟩ := hδ\n      subst_vars\n      cases hφ cd'\n      have : d' ∈ (im φ hφ).objs := by\n        rw [hφ']\n        apply mem_top_objs\n      rw [mem_im_objs_iff] at this\n      obtain ⟨c', rfl⟩ := this\n      have : g ∈ (im φ hφ).arrows (φ.obj c) (φ.obj c') := by\n        rw [hφ']\n        trivial\n      rw [mem_im_iff] at this\n      obtain ⟨b, b', f, hb, hb', _, hf⟩ := this\n      subst_vars\n      cases hφ hb\n      cases hφ hb'\n      change map.arrows φ hφ S (φ.obj c') (φ.obj c') _\n      simp only [eq_to_hom_refl, category.comp_id, category.id_comp, inv_eq_inv]\n      suffices map.arrows φ hφ S (φ.obj c') (φ.obj c') (φ.map <| «expr ≫ » (inv f) («expr ≫ » γ f))\n        by\n        simp only [inv_eq_inv, functor.map_comp, functor.map_inv] at this\n        exact this\n      · constructor\n        apply Sn.conj f γS }\n#align is_normal_map is_normal_map\n\n",
 "is_normal_comap":
 "theorem is_normal_comap {S : subgroupoid D} (Sn : is_normal S) : is_normal (comap φ S) :=\n  { wide := fun c => by\n      rw [comap, mem_set_of, Functor.map_id]\n      apply Sn.wide\n    conj := fun c d f γ hγ =>\n      by\n      simp_rw [inv_eq_inv f, comap, mem_set_of, functor.map_comp, functor.map_inv, ← inv_eq_inv]\n      exact Sn.conj _ hγ }\n#align is_normal_comap is_normal_comap\n\n",
 "inv_mem_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/-\nCopyright (c) 2022 Rémi Bottinelli. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Rémi Bottinelli, Junyan Xu\n-/\ntheorem inv_mem_iff {c d : C} (f : «expr ⟶ » c d) : inv f ∈ S.arrows d c ↔ f ∈ S.arrows c d :=\n  by\n  constructor\n  · rintro h\n    suffices inv (inv f) ∈ S.arrows c d by simpa only [inv_eq_inv, is_iso.inv_inv] using this\n    · apply S.inv h\n  · apply S.inv\n#align inv_mem_iff inv_mem_iff\n\n",
 "inj_on_objects":
 "theorem hom.inj_on_objects : function.injective (hom S).obj :=\n  by\n  rintro ⟨c, hc⟩ ⟨d, hd⟩ hcd\n  simp only [subtype.mk_eq_mk]\n  exact hcd\n#align hom.inj_on_objects hom.inj_on_objects\n\n",
 "inclusion_trans":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\ntheorem inclusion_trans {R S T : subgroupoid C} (k : R ≤ S) (h : S ≤ T) :\n    inclusion (k.trans h) = «expr ⋙ » (inclusion k) (inclusion h) :=\n  rfl\n#align inclusion_trans inclusion_trans\n\n",
 "inclusion_refl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟭» -/\ntheorem inclusion_refl {S : subgroupoid C} : inclusion (le_refl S) = («expr𝟭») S.objs :=\n  functor.hext (fun ⟨s, hs⟩ => rfl) fun ⟨s, hs⟩ ⟨t, ht⟩ ⟨f, hf⟩ => heq_of_eq rfl\n#align inclusion_refl inclusion_refl\n\n",
 "inclusion_inj_on_objects":
 "theorem inclusion_inj_on_objects {S T : subgroupoid C} (h : S ≤ T) : function.injective (inclusion h).obj :=\n  fun ⟨s, hs⟩ ⟨t, ht⟩ => by simpa only [inclusion, subtype.mk_eq_mk] using id\n#align inclusion_inj_on_objects inclusion_inj_on_objects\n\n",
 "inclusion_faithful":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem inclusion_faithful {S T : subgroupoid C} (h : S ≤ T) (s t : S.objs) :\n    function.injective fun f : «expr ⟶ » s t => (inclusion h).map f := fun ⟨f, hf⟩ ⟨g, hg⟩ =>\n  by\n  dsimp only [inclusion]\n  simpa only [subtype.mk_eq_mk] using id\n#align inclusion_faithful inclusion_faithful\n\n",
 "inclusion_comp_embedding":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\ntheorem inclusion_comp_embedding {S T : subgroupoid C} (h : S ≤ T) : «expr ⋙ » (inclusion h) T.hom = S.hom :=\n  rfl\n#align inclusion_comp_embedding inclusion_comp_embedding\n\n",
 "id_mem_of_tgt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\ntheorem id_mem_of_tgt {c d : C} {f : «expr ⟶ » c d} (h : f ∈ S.arrows c d) : («expr𝟙») d ∈ S.arrows d d :=\n  id_mem_of_nonempty_isotropy S d (mem_objs_of_tgt S h)\n#align id_mem_of_tgt id_mem_of_tgt\n\n",
 "id_mem_of_src":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\ntheorem id_mem_of_src {c d : C} {f : «expr ⟶ » c d} (h : f ∈ S.arrows c d) : («expr𝟙») c ∈ S.arrows c c :=\n  id_mem_of_nonempty_isotropy S c (mem_objs_of_src S h)\n#align id_mem_of_src id_mem_of_src\n\n",
 "id_mem_of_nonempty_isotropy":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\ntheorem id_mem_of_nonempty_isotropy (c : C) : c ∈ objs S → («expr𝟙») c ∈ S.arrows c c :=\n  by\n  rintro ⟨γ, hγ⟩\n  convert S.mul hγ (S.inv hγ)\n  simp only [inv_eq_inv, is_iso.hom_inv_id]\n#align id_mem_of_nonempty_isotropy id_mem_of_nonempty_isotropy\n\n",
 "id_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\ntheorem is_wide.id_mem {S : subgroupoid C} (Sw : S.is_wide) (c : C) : («expr𝟙») c ∈ S.arrows c c :=\n  Sw.wide c\n#align is_wide.id_mem is_wide.id_mem\n\n",
 "generated_normal_le":
 "theorem is_normal.generated_normal_le {S : subgroupoid C} (Sn : S.is_normal) :\n    generated_normal X ≤ S ↔ ∀ c d, X c d ⊆ S.arrows c d :=\n  by\n  constructor\n  · rintro h c d\n    let h' := generated_le_generated_normal X\n    rw [le_iff] at h h'\n    exact ((subset_generated X c d).trans (@h' c d)).trans (@h c d)\n  · rintro h\n    apply @infₛ_le (subgroupoid C) _\n    exact ⟨h, Sn⟩\n#align is_normal.generated_normal_le is_normal.generated_normal_le\n\n",
 "generated_normal_is_normal":
 "theorem generated_normal_is_normal : (generated_normal X).is_normal :=\n  Inf_is_normal _ fun S h => h.right\n#align generated_normal_is_normal generated_normal_is_normal\n\n",
 "generated_le_generated_normal":
 "theorem generated_le_generated_normal : generated X ≤ generated_normal X :=\n  by\n  apply @infₛ_le_infₛ (subgroupoid C) _\n  exact fun S ⟨h, _⟩ => h\n#align generated_le_generated_normal generated_le_generated_normal\n\n",
 "galois_connection_map_comap":
 "theorem galois_connection_map_comap (hφ : function.injective φ.obj) : GaloisConnection (map φ hφ) (comap φ) :=\n  by\n  rintro S T; simp_rw [le_iff]; constructor\n  · exact fun h c d f fS => h (map.arrows.im f fS)\n  · rintro h _ _ g ⟨a, gφS⟩\n    exact h gφS\n#align galois_connection_map_comap galois_connection_map_comap\n\n",
 "full_univ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem full_univ : full Set.univ = («expr⊤» : subgroupoid C) :=\n  by\n  ext\n  simp only [mem_full_iff, mem_univ, and_self_iff, true_iff_iff]\n#align full_univ full_univ\n\n",
 "full_objs":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\ntheorem full_objs : (full D).objs = D :=\n  Set.ext fun _ => ⟨fun ⟨f, h, _⟩ => h, fun h => ⟨(«expr𝟙») _, h, h⟩⟩\n#align full_objs full_objs\n\n",
 "full_mono":
 "theorem full_mono {D E : set C} (h : D ≤ E) : full D ≤ full E :=\n  by\n  rw [le_iff]\n  rintro c d f\n  simp only [mem_full_iff]\n  exact fun ⟨hc, hd⟩ => ⟨h hc, h hd⟩\n#align full_mono full_mono\n\n",
 "full_empty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem full_empty : full ∅ = («expr⊥» : subgroupoid C) :=\n  by\n  ext\n  simp only [has_bot.bot, mem_full_iff, mem_empty_iff_false, and_self_iff]\n#align full_empty full_empty\n\n",
 "full_arrow_eq_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem full_arrow_eq_iff {c d : (full D).objs} {f g : «expr ⟶ » c d} : f = g ↔ (↑f : «expr ⟶ » c.val d.val) = ↑g := by\n  apply subtype.ext_iff\n#align full_arrow_eq_iff full_arrow_eq_iff\n\n",
 "faithful":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem hom.faithful : ∀ c d, function.injective fun f : «expr ⟶ » c d => (hom S).map f :=\n  by\n  rintro ⟨c, hc⟩ ⟨d, hd⟩ ⟨f, hf⟩ ⟨g, hg⟩ hfg\n  simp only [subtype.mk_eq_mk]\n  exact hfg\n#align hom.faithful hom.faithful\n\n",
 "eq_to_hom_mem":
 "theorem is_wide.eq_to_hom_mem {S : subgroupoid C} (Sw : S.is_wide) {c d : C} (h : c = d) : eq_to_hom h ∈ S.arrows c d :=\n  by\n  cases h\n  simp only [eq_to_hom_refl]\n  apply Sw.id_mem c\n#align is_wide.eq_to_hom_mem is_wide.eq_to_hom_mem\n\n",
 "discrete_is_normal":
 "theorem discrete_is_normal : (@discrete C _).is_normal :=\n  { wide := fun c => by constructor\n    conj := fun c d f γ hγ => by\n      cases hγ\n      simp only [inv_eq_inv, category.id_comp, is_iso.inv_hom_id]\n      constructor }\n#align discrete_is_normal discrete_is_normal\n\n",
 "disconnect_objs":
 "theorem disconnect_objs : S.disconnect.objs = S.objs :=\n  by\n  apply Set.ext\n  apply mem_disconnect_objs_iff\n#align disconnect_objs disconnect_objs\n\n",
 "disconnect_normal":
 "theorem disconnect_normal (Sn : S.is_normal) : S.disconnect.is_normal :=\n  { wide := fun c => ⟨rfl, Sn.wide c⟩\n    conj := fun c d p γ ⟨_, h'⟩ => ⟨rfl, Sn.conj _ h'⟩ }\n#align disconnect_normal disconnect_normal\n\n",
 "disconnect_le":
 "theorem disconnect_le : S.disconnect ≤ S := by\n  rw [le_iff]\n  rintro _ _ _ ⟨⟩\n  assumption\n#align disconnect_le disconnect_le\n\n",
 "disconnect_is_totally_disconnected":
 "theorem disconnect_is_totally_disconnected : S.disconnect.is_totally_disconnected :=\n  by\n  rw [is_totally_disconnected_iff]\n  exact fun c d ⟨f, h, fS⟩ => h\n#align disconnect_is_totally_disconnected disconnect_is_totally_disconnected\n\n",
 "conjugation_bij":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫= » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem is_normal.conjugation_bij (Sn : is_normal S) {c d} (p : «expr ⟶ » c d) :\n    Set.BijOn (fun γ : «expr ⟶ » c c => «expr ≫ » (inv p) («expr ≫ » γ p)) (S.arrows c c) (S.arrows d d) :=\n  by\n  refine'\n    ⟨fun γ γS => Sn.conj p γS, fun γ₁ γ₁S γ₂ γ₂S h => _, fun δ δS =>\n      ⟨«expr ≫ » p («expr ≫ » δ (inv p)), Sn.conj' p δS, _⟩⟩\n  ·\n    simpa only [inv_eq_inv, category.assoc, is_iso.hom_inv_id, category.comp_id, is_iso.hom_inv_id_assoc] using\n      «expr ≫= » p («expr =≫ » h (inv p))\n  · simp only [inv_eq_inv, category.assoc, is_iso.inv_hom_id, category.comp_id, is_iso.inv_hom_id_assoc]\n#align is_normal.conjugation_bij is_normal.conjugation_bij\n\n",
 "conj'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem is_normal.conj' {S : subgroupoid C} (Sn : is_normal S) :\n    ∀ {c d} (p : «expr ⟶ » d c) {γ : «expr ⟶ » c c} (hs : γ ∈ S.arrows c c),\n      «expr ≫ » p («expr ≫ » γ (inv p)) ∈ S.arrows d d :=\n  fun c d p γ hs => by\n  convert Sn.conj (inv p) hs\n  simp\n#align is_normal.conj' is_normal.conj'\n\n",
 "comap_mono":
 "theorem comap_mono (S T : subgroupoid D) : S ≤ T → comap φ S ≤ comap φ T := fun ST ⟨c, d, p⟩ => @ST ⟨_, _, _⟩\n#align comap_mono comap_mono\n\n",
 "comap_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n@[simp]\ntheorem comap_comp {E : Type _} [groupoid E] (ψ : «expr ⥤ » D E) : comap («expr ⋙ » φ ψ) = comap φ ∘ comap ψ :=\n  rfl\n#align comap_comp comap_comp\n\n",
 "coe_inv_coe'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n@[simp]\ntheorem coe_inv_coe' {c d : S.objs} (p : «expr ⟶ » c d) : (CategoryTheory.inv p).val = CategoryTheory.inv p.val := by\n  simp only [subtype.val_eq_coe, ← inv_eq_inv, coe_inv_coe]\n#align coe_inv_coe' coe_inv_coe'\n\n",
 "arrows_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem map.arrows_iff (hφ : function.injective φ.obj) (S : subgroupoid C) {c d : D} (f : «expr ⟶ » c d) :\n    map.arrows φ hφ S c d f ↔\n      ∃ (a b : C)(g : «expr ⟶ » a b)(ha : φ.obj a = c)(hb : φ.obj b = d)(hg : g ∈ S.arrows a b),\n        f = «expr ≫ » (eq_to_hom ha.symm) («expr ≫ » (φ.map g) (eq_to_hom hb)) :=\n  by\n  constructor\n  · rintro ⟨g, hg⟩\n    exact ⟨_, _, g, rfl, rfl, hg, eq_conj_eq_to_hom _⟩\n  · rintro ⟨a, b, g, rfl, rfl, hg, rfl⟩\n    rw [← eq_conj_eq_to_hom]\n    constructor\n    exact hg\n#align map.arrows_iff map.arrows_iff\n\n",
 "Inf_is_normal":
 "theorem Inf_is_normal (s : set <| subgroupoid C) (sn : ∀ S ∈ s, is_normal S) : is_normal (infₛ s) :=\n  { wide := by\n      simp_rw [Inf, mem_Inter₂]\n      exact fun c S Ss => (sn S Ss).wide c\n    conj := by\n      simp_rw [Inf, mem_Inter₂]\n      exact fun c d p γ hγ S Ss => (sn S Ss).conj p (hγ S Ss) }\n#align Inf_is_normal Inf_is_normal\n\n"}