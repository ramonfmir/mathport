{"vertex_subgroup":
 "theorem is_normal.vertex_subgroup (Sn : is_normal S) (c : C) (cS : c âˆˆ S.objs) : (S.vertex_subgroup cS).normal :=\n  {\n    conj_mem := fun x hx y => by\n      rw [mul_assoc]\n      exact Sn.conj' y hx }\n#align is_normal.vertex_subgroup is_normal.vertex_subgroup\n\n",
 "top_is_normal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\ntheorem top_is_normal : is_normal (Â«exprâŠ¤Â» : subgroupoid C) :=\n  { wide := fun c => trivial\n    conj := fun a b c d e => trivial }\n#align top_is_normal top_is_normal\n\n",
 "subset_generated":
 "-- TODO:Â proof that generated is just \"words in X\" and generated_normal is similarly\ntheorem subset_generated (c d : C) : X c d âŠ† (generated X).arrows c d :=\n  by\n  dsimp only [generated, Inf]\n  simp only [subset_Interâ‚‚_iff]\n  exact fun S hS f fS => hS _ _ fS\n#align subset_generated subset_generated\n\n",
 "obj_surjective_of_im_eq_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\ntheorem obj_surjective_of_im_eq_top (hÏ† : function.injective Ï†.obj) (hÏ†' : im Ï† hÏ† = Â«exprâŠ¤Â») :\n    function.surjective Ï†.obj := by\n  rintro d\n  rw [â† mem_im_objs_iff, hÏ†']\n  apply mem_top_objs\n#align obj_surjective_of_im_eq_top obj_surjective_of_im_eq_top\n\n",
 "mul_mem_cancel_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\ntheorem mul_mem_cancel_right {c d e : C} {f : Â«expr âŸ¶ Â» c d} {g : Â«expr âŸ¶ Â» d e} (hg : g âˆˆ S.arrows d e) :\n    Â«expr â‰« Â» f g âˆˆ S.arrows c e â†” f âˆˆ S.arrows c d :=\n  by\n  constructor\n  Â· rintro h\n    suffices Â«expr â‰« Â» (Â«expr â‰« Â» f g) (inv g) âˆˆ S.arrows c d by\n      simpa only [inv_eq_inv, is_iso.hom_inv_id, category.comp_id, category.assoc] using this\n    Â· apply S.mul h (S.inv hg)\n  Â· exact fun hf => S.mul hf hg\n#align mul_mem_cancel_right mul_mem_cancel_right\n\n",
 "mul_mem_cancel_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\ntheorem mul_mem_cancel_left {c d e : C} {f : Â«expr âŸ¶ Â» c d} {g : Â«expr âŸ¶ Â» d e} (hf : f âˆˆ S.arrows c d) :\n    Â«expr â‰« Â» f g âˆˆ S.arrows c e â†” g âˆˆ S.arrows d e :=\n  by\n  constructor\n  Â· rintro h\n    suffices Â«expr â‰« Â» (inv f) (Â«expr â‰« Â» f g) âˆˆ S.arrows d e by\n      simpa only [inv_eq_inv, is_iso.inv_hom_id_assoc] using this\n    Â· apply S.mul (S.inv hf) h\n  Â· apply S.mul hf\n#align mul_mem_cancel_left mul_mem_cancel_left\n\n",
 "mem_top_objs":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\ntheorem mem_top_objs (c : C) : c âˆˆ (Â«exprâŠ¤Â» : subgroupoid C).objs :=\n  by\n  dsimp [has_top.top, objs]\n  simp only [univ_nonempty]\n#align mem_top_objs mem_top_objs\n\n",
 "mem_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\ntheorem mem_top {c d : C} (f : Â«expr âŸ¶ Â» c d) : f âˆˆ (Â«exprâŠ¤Â» : subgroupoid C).arrows c d :=\n  trivial\n#align mem_top mem_top\n\n",
 "mem_objs_of_tgt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem mem_objs_of_tgt {c d : C} {f : Â«expr âŸ¶ Â» c d} (h : f âˆˆ S.arrows c d) : d âˆˆ S.objs :=\n  âŸ¨Â«expr â‰« Â» (inv f) f, S.mul (S.inv h) hâŸ©\n#align mem_objs_of_tgt mem_objs_of_tgt\n\n",
 "mem_objs_of_src":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem mem_objs_of_src {c d : C} {f : Â«expr âŸ¶ Â» c d} (h : f âˆˆ S.arrows c d) : c âˆˆ S.objs :=\n  âŸ¨Â«expr â‰« Â» f (inv f), S.mul h (S.inv h)âŸ©\n#align mem_objs_of_src mem_objs_of_src\n\n",
 "mem_map_objs_iff":
 "theorem mem_map_objs_iff (hÏ† : function.injective Ï†.obj) (d : D) : d âˆˆ (map Ï† hÏ† S).objs â†” âˆƒ c âˆˆ S.objs, Ï†.obj c = d :=\n  by\n  dsimp [objs, map]\n  constructor\n  Â· rintro âŸ¨f, hfâŸ©\n    change map.arrows Ï† hÏ† S d d f at hf\n    rw [map.arrows_iff] at hf\n    obtain âŸ¨c, d, g, ec, ed, eg, gS, egâŸ© := hf\n    exact âŸ¨c, âŸ¨mem_objs_of_src S eg, ecâŸ©âŸ©\n  Â· rintro âŸ¨c, âŸ¨Î³, Î³SâŸ©, rflâŸ©\n    exact âŸ¨Ï†.map Î³, âŸ¨Î³, Î³SâŸ©âŸ©\n#align mem_map_objs_iff mem_map_objs_iff\n\n",
 "mem_map_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\ntheorem mem_map_iff (hÏ† : function.injective Ï†.obj) (S : subgroupoid C) {c d : D} (f : Â«expr âŸ¶ Â» c d) :\n    f âˆˆ (map Ï† hÏ† S).arrows c d â†”\n      âˆƒ (a b : C)(g : Â«expr âŸ¶ Â» a b)(ha : Ï†.obj a = c)(hb : Ï†.obj b = d)(hg : g âˆˆ S.arrows a b),\n        f = Â«expr â‰« Â» (eq_to_hom ha.symm) (Â«expr â‰« Â» (Ï†.map g) (eq_to_hom hb)) :=\n  map.arrows_iff Ï† hÏ† S f\n#align mem_map_iff mem_map_iff\n\n",
 "mem_ker_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem mem_ker_iff {c d : C} (f : Â«expr âŸ¶ Â» c d) :\n    f âˆˆ (ker Ï†).arrows c d â†” âˆƒ h : Ï†.obj c = Ï†.obj d, Ï†.map f = eq_to_hom h :=\n  mem_discrete_iff (Ï†.map f)\n#align mem_ker_iff mem_ker_iff\n\n",
 "mem_im_objs_iff":
 "theorem mem_im_objs_iff (hÏ† : function.injective Ï†.obj) (d : D) : d âˆˆ (im Ï† hÏ†).objs â†” âˆƒ c : C, Ï†.obj c = d := by\n  simp only [im, mem_map_objs_iff, mem_top_objs, exists_true_left]\n#align mem_im_objs_iff mem_im_objs_iff\n\n",
 "mem_im_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\ntheorem mem_im_iff (hÏ† : function.injective Ï†.obj) {c d : D} (f : Â«expr âŸ¶ Â» c d) :\n    f âˆˆ (im Ï† hÏ†).arrows c d â†”\n      âˆƒ (a b : C)(g : Â«expr âŸ¶ Â» a b)(ha : Ï†.obj a = c)(hb : Ï†.obj b = d),\n        f = Â«expr â‰« Â» (eq_to_hom ha.symm) (Â«expr â‰« Â» (Ï†.map g) (eq_to_hom hb)) :=\n  by\n  convert map.arrows_iff Ï† hÏ† (Â«exprâŠ¤Â») f\n  simp only [has_top.top, mem_univ, exists_true_left]\n#align mem_im_iff mem_im_iff\n\n",
 "mem_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem mem_iff (S : subgroupoid C) (F : Î£c d, Â«expr âŸ¶ Â» c d) : F âˆˆ S â†” F.2.2 âˆˆ S.arrows F.1 F.2.1 :=\n  iff.rfl\n#align mem_iff mem_iff\n\n",
 "mem_full_objs_iff":
 "@[simp]\ntheorem mem_full_objs_iff {c : C} : c âˆˆ (full D).objs â†” c âˆˆ D := by rw [full_objs]\n#align mem_full_objs_iff mem_full_objs_iff\n\n",
 "mem_full_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n@[simp]\ntheorem mem_full_iff {c d : C} {f : Â«expr âŸ¶ Â» c d} : f âˆˆ (full D).arrows c d â†” c âˆˆ D âˆ§ d âˆˆ D :=\n  iff.rfl\n#align mem_full_iff mem_full_iff\n\n",
 "mem_discrete_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem mem_discrete_iff {c d : C} (f : Â«expr âŸ¶ Â» c d) : f âˆˆ discrete.arrows c d â†” âˆƒ h : c = d, f = eq_to_hom h :=\n  âŸ¨by\n    rintro âŸ¨âŸ©\n    exact âŸ¨rfl, rflâŸ©, by\n    rintro âŸ¨rfl, rflâŸ©\n    constructorâŸ©\n#align mem_discrete_iff mem_discrete_iff\n\n",
 "mem_disconnect_objs_iff":
 "@[simp]\ntheorem mem_disconnect_objs_iff {c : C} : c âˆˆ S.disconnect.objs â†” c âˆˆ S.objs :=\n  âŸ¨fun âŸ¨Î³, h, Î³SâŸ© => âŸ¨Î³, Î³SâŸ©, fun âŸ¨Î³, Î³SâŸ© => âŸ¨Î³, rfl, Î³SâŸ©âŸ©\n#align mem_disconnect_objs_iff mem_disconnect_objs_iff\n\n",
 "map_objs_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n@[simp]\ntheorem map_objs_eq (hÏ† : function.injective Ï†.obj) : (map Ï† hÏ† S).objs = Â«expr '' Â» Ï†.obj S.objs :=\n  by\n  ext\n  convert mem_map_objs_iff S Ï† hÏ† x\n  simp only [mem_image, exists_prop]\n#align map_objs_eq map_objs_eq\n\n",
 "map_mono":
 "theorem map_mono (hÏ† : function.injective Ï†.obj) (S T : subgroupoid C) : S â‰¤ T â†’ map Ï† hÏ† S â‰¤ map Ï† hÏ† T := fun h =>\n  (galois_connection_map_comap Ï† hÏ†).monotone_l h\n#align map_mono map_mono\n\n",
 "map_le_iff_le_comap":
 "theorem map_le_iff_le_comap (hÏ† : function.injective Ï†.obj) (S : subgroupoid C) (T : subgroupoid D) :\n    map Ï† hÏ† S â‰¤ T â†” S â‰¤ comap Ï† T :=\n  (galois_connection_map_comap Ï† hÏ†).le_iff_le\n#align map_le_iff_le_comap map_le_iff_le_comap\n\n",
 "map_comap_le":
 "theorem map_comap_le (hÏ† : function.injective Ï†.obj) (T : subgroupoid D) : map Ï† hÏ† (comap Ï† T) â‰¤ T :=\n  (galois_connection_map_comap Ï† hÏ†).l_u_le T\n#align map_comap_le map_comap_le\n\n",
 "le_objs":
 "theorem le_objs {S T : subgroupoid C} (h : S â‰¤ T) : S.objs âŠ† T.objs := fun s âŸ¨Î³, hÎ³âŸ© => âŸ¨Î³, @h âŸ¨s, s, Î³âŸ© hÎ³âŸ©\n#align le_objs le_objs\n\n",
 "le_iff":
 "theorem le_iff (S T : subgroupoid C) : S â‰¤ T â†” âˆ€ {c d}, S.arrows c d âŠ† T.arrows c d :=\n  by\n  rw [SetLike.le_def, sigma.forall]\n  exact forall_congr' fun c => sigma.forall\n#align le_iff le_iff\n\n",
 "le_comap_map":
 "theorem le_comap_map (hÏ† : function.injective Ï†.obj) (S : subgroupoid C) : S â‰¤ comap Ï† (map Ï† hÏ† S) :=\n  (galois_connection_map_comap Ï† hÏ†).le_u_l S\n#align le_comap_map le_comap_map\n\n",
 "ker_is_normal":
 "theorem ker_is_normal : (ker Ï†).is_normal :=\n  is_normal_comap Ï† discrete_is_normal\n#align ker_is_normal ker_is_normal\n\n",
 "ker_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‹™ Â» -/\n@[simp]\ntheorem ker_comp {E : Type _} [groupoid E] (Ïˆ : Â«expr â¥¤ Â» D E) : ker (Â«expr â‹™ Â» Ï† Ïˆ) = comap Ï† (ker Ïˆ) :=\n  rfl\n#align ker_comp ker_comp\n\n",
 "is_wide_iff_objs_eq_univ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\ntheorem is_wide_iff_objs_eq_univ : S.is_wide â†” S.objs = Set.univ :=\n  by\n  constructor\n  Â· rintro h\n    ext\n    constructor <;> simp only [top_eq_univ, mem_univ, imp_true_iff, forall_true_left]\n    apply mem_objs_of_src S (h.wide x)\n  Â· rintro h\n    refine' âŸ¨fun c => _âŸ©\n    obtain âŸ¨Î³, Î³SâŸ© := (le_of_eq h.symm : Â«exprâŠ¤Â» âŠ† S.objs) (Set.mem_univ c)\n    exact id_mem_of_src S Î³S\n#align is_wide_iff_objs_eq_univ is_wide_iff_objs_eq_univ\n\n",
 "is_totally_disconnected_iff":
 "theorem is_totally_disconnected_iff : S.is_totally_disconnected â†” âˆ€ c d, (S.arrows c d).nonempty â†’ c = d :=\n  by\n  constructor\n  Â· rintro h c d âŸ¨f, fSâŸ©\n    rw [â† @subtype.mk_eq_mk _ _ c (mem_objs_of_src S fS) d (mem_objs_of_tgt S fS)]\n    exact h âŸ¨c, mem_objs_of_src S fSâŸ© âŸ¨d, mem_objs_of_tgt S fSâŸ© âŸ¨f, fSâŸ©\n  Â· rintro h âŸ¨c, hcâŸ© âŸ¨d, hdâŸ© âŸ¨f, fSâŸ©\n    simp only [subtype.mk_eq_mk]\n    exact h c d âŸ¨f, fSâŸ©\n#align is_totally_disconnected_iff is_totally_disconnected_iff\n\n",
 "is_thin_iff":
 "theorem is_thin_iff : S.is_thin â†” âˆ€ c : S.objs, subsingleton (S.arrows c c) := by apply is_thin_iff\n#align is_thin_iff is_thin_iff\n\n",
 "is_normal_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\ntheorem is_normal_map (hÏ† : function.injective Ï†.obj) (hÏ†' : im Ï† hÏ† = Â«exprâŠ¤Â») (Sn : S.is_normal) :\n    (map Ï† hÏ† S).is_normal :=\n  { wide := fun d => by\n      obtain âŸ¨c, rflâŸ© := obj_surjective_of_im_eq_top Ï† hÏ† hÏ†' d\n      change map.arrows Ï† hÏ† S _ _ ((Â«exprğŸ™Â») _)\n      rw [â† Functor.map_id]\n      constructor\n      exact Sn.wide c\n    conj := fun d d' g Î´ hÎ´ => by\n      rw [mem_map_iff] at hÎ´\n      obtain âŸ¨c, c', Î³, cd, cd', Î³S, hÎ³âŸ© := hÎ´\n      subst_vars\n      cases hÏ† cd'\n      have : d' âˆˆ (im Ï† hÏ†).objs := by\n        rw [hÏ†']\n        apply mem_top_objs\n      rw [mem_im_objs_iff] at this\n      obtain âŸ¨c', rflâŸ© := this\n      have : g âˆˆ (im Ï† hÏ†).arrows (Ï†.obj c) (Ï†.obj c') := by\n        rw [hÏ†']\n        trivial\n      rw [mem_im_iff] at this\n      obtain âŸ¨b, b', f, hb, hb', _, hfâŸ© := this\n      subst_vars\n      cases hÏ† hb\n      cases hÏ† hb'\n      change map.arrows Ï† hÏ† S (Ï†.obj c') (Ï†.obj c') _\n      simp only [eq_to_hom_refl, category.comp_id, category.id_comp, inv_eq_inv]\n      suffices map.arrows Ï† hÏ† S (Ï†.obj c') (Ï†.obj c') (Ï†.map <| Â«expr â‰« Â» (inv f) (Â«expr â‰« Â» Î³ f))\n        by\n        simp only [inv_eq_inv, functor.map_comp, functor.map_inv] at this\n        exact this\n      Â· constructor\n        apply Sn.conj f Î³S }\n#align is_normal_map is_normal_map\n\n",
 "is_normal_comap":
 "theorem is_normal_comap {S : subgroupoid D} (Sn : is_normal S) : is_normal (comap Ï† S) :=\n  { wide := fun c => by\n      rw [comap, mem_set_of, Functor.map_id]\n      apply Sn.wide\n    conj := fun c d f Î³ hÎ³ =>\n      by\n      simp_rw [inv_eq_inv f, comap, mem_set_of, functor.map_comp, functor.map_inv, â† inv_eq_inv]\n      exact Sn.conj _ hÎ³ }\n#align is_normal_comap is_normal_comap\n\n",
 "inv_mem_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/-\nCopyright (c) 2022 RÃ©mi Bottinelli. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: RÃ©mi Bottinelli, Junyan Xu\n-/\ntheorem inv_mem_iff {c d : C} (f : Â«expr âŸ¶ Â» c d) : inv f âˆˆ S.arrows d c â†” f âˆˆ S.arrows c d :=\n  by\n  constructor\n  Â· rintro h\n    suffices inv (inv f) âˆˆ S.arrows c d by simpa only [inv_eq_inv, is_iso.inv_inv] using this\n    Â· apply S.inv h\n  Â· apply S.inv\n#align inv_mem_iff inv_mem_iff\n\n",
 "inj_on_objects":
 "theorem hom.inj_on_objects : function.injective (hom S).obj :=\n  by\n  rintro âŸ¨c, hcâŸ© âŸ¨d, hdâŸ© hcd\n  simp only [subtype.mk_eq_mk]\n  exact hcd\n#align hom.inj_on_objects hom.inj_on_objects\n\n",
 "inclusion_trans":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‹™ Â» -/\ntheorem inclusion_trans {R S T : subgroupoid C} (k : R â‰¤ S) (h : S â‰¤ T) :\n    inclusion (k.trans h) = Â«expr â‹™ Â» (inclusion k) (inclusion h) :=\n  rfl\n#align inclusion_trans inclusion_trans\n\n",
 "inclusion_refl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ­Â» -/\ntheorem inclusion_refl {S : subgroupoid C} : inclusion (le_refl S) = (Â«exprğŸ­Â») S.objs :=\n  functor.hext (fun âŸ¨s, hsâŸ© => rfl) fun âŸ¨s, hsâŸ© âŸ¨t, htâŸ© âŸ¨f, hfâŸ© => heq_of_eq rfl\n#align inclusion_refl inclusion_refl\n\n",
 "inclusion_inj_on_objects":
 "theorem inclusion_inj_on_objects {S T : subgroupoid C} (h : S â‰¤ T) : function.injective (inclusion h).obj :=\n  fun âŸ¨s, hsâŸ© âŸ¨t, htâŸ© => by simpa only [inclusion, subtype.mk_eq_mk] using id\n#align inclusion_inj_on_objects inclusion_inj_on_objects\n\n",
 "inclusion_faithful":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem inclusion_faithful {S T : subgroupoid C} (h : S â‰¤ T) (s t : S.objs) :\n    function.injective fun f : Â«expr âŸ¶ Â» s t => (inclusion h).map f := fun âŸ¨f, hfâŸ© âŸ¨g, hgâŸ© =>\n  by\n  dsimp only [inclusion]\n  simpa only [subtype.mk_eq_mk] using id\n#align inclusion_faithful inclusion_faithful\n\n",
 "inclusion_comp_embedding":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‹™ Â» -/\ntheorem inclusion_comp_embedding {S T : subgroupoid C} (h : S â‰¤ T) : Â«expr â‹™ Â» (inclusion h) T.hom = S.hom :=\n  rfl\n#align inclusion_comp_embedding inclusion_comp_embedding\n\n",
 "id_mem_of_tgt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\ntheorem id_mem_of_tgt {c d : C} {f : Â«expr âŸ¶ Â» c d} (h : f âˆˆ S.arrows c d) : (Â«exprğŸ™Â») d âˆˆ S.arrows d d :=\n  id_mem_of_nonempty_isotropy S d (mem_objs_of_tgt S h)\n#align id_mem_of_tgt id_mem_of_tgt\n\n",
 "id_mem_of_src":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\ntheorem id_mem_of_src {c d : C} {f : Â«expr âŸ¶ Â» c d} (h : f âˆˆ S.arrows c d) : (Â«exprğŸ™Â») c âˆˆ S.arrows c c :=\n  id_mem_of_nonempty_isotropy S c (mem_objs_of_src S h)\n#align id_mem_of_src id_mem_of_src\n\n",
 "id_mem_of_nonempty_isotropy":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\ntheorem id_mem_of_nonempty_isotropy (c : C) : c âˆˆ objs S â†’ (Â«exprğŸ™Â») c âˆˆ S.arrows c c :=\n  by\n  rintro âŸ¨Î³, hÎ³âŸ©\n  convert S.mul hÎ³ (S.inv hÎ³)\n  simp only [inv_eq_inv, is_iso.hom_inv_id]\n#align id_mem_of_nonempty_isotropy id_mem_of_nonempty_isotropy\n\n",
 "id_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\ntheorem is_wide.id_mem {S : subgroupoid C} (Sw : S.is_wide) (c : C) : (Â«exprğŸ™Â») c âˆˆ S.arrows c c :=\n  Sw.wide c\n#align is_wide.id_mem is_wide.id_mem\n\n",
 "generated_normal_le":
 "theorem is_normal.generated_normal_le {S : subgroupoid C} (Sn : S.is_normal) :\n    generated_normal X â‰¤ S â†” âˆ€ c d, X c d âŠ† S.arrows c d :=\n  by\n  constructor\n  Â· rintro h c d\n    let h' := generated_le_generated_normal X\n    rw [le_iff] at h h'\n    exact ((subset_generated X c d).trans (@h' c d)).trans (@h c d)\n  Â· rintro h\n    apply @infâ‚›_le (subgroupoid C) _\n    exact âŸ¨h, SnâŸ©\n#align is_normal.generated_normal_le is_normal.generated_normal_le\n\n",
 "generated_normal_is_normal":
 "theorem generated_normal_is_normal : (generated_normal X).is_normal :=\n  Inf_is_normal _ fun S h => h.right\n#align generated_normal_is_normal generated_normal_is_normal\n\n",
 "generated_le_generated_normal":
 "theorem generated_le_generated_normal : generated X â‰¤ generated_normal X :=\n  by\n  apply @infâ‚›_le_infâ‚› (subgroupoid C) _\n  exact fun S âŸ¨h, _âŸ© => h\n#align generated_le_generated_normal generated_le_generated_normal\n\n",
 "galois_connection_map_comap":
 "theorem galois_connection_map_comap (hÏ† : function.injective Ï†.obj) : GaloisConnection (map Ï† hÏ†) (comap Ï†) :=\n  by\n  rintro S T; simp_rw [le_iff]; constructor\n  Â· exact fun h c d f fS => h (map.arrows.im f fS)\n  Â· rintro h _ _ g âŸ¨a, gÏ†SâŸ©\n    exact h gÏ†S\n#align galois_connection_map_comap galois_connection_map_comap\n\n",
 "full_univ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\n@[simp]\ntheorem full_univ : full Set.univ = (Â«exprâŠ¤Â» : subgroupoid C) :=\n  by\n  ext\n  simp only [mem_full_iff, mem_univ, and_self_iff, true_iff_iff]\n#align full_univ full_univ\n\n",
 "full_objs":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\ntheorem full_objs : (full D).objs = D :=\n  Set.ext fun _ => âŸ¨fun âŸ¨f, h, _âŸ© => h, fun h => âŸ¨(Â«exprğŸ™Â») _, h, hâŸ©âŸ©\n#align full_objs full_objs\n\n",
 "full_mono":
 "theorem full_mono {D E : set C} (h : D â‰¤ E) : full D â‰¤ full E :=\n  by\n  rw [le_iff]\n  rintro c d f\n  simp only [mem_full_iff]\n  exact fun âŸ¨hc, hdâŸ© => âŸ¨h hc, h hdâŸ©\n#align full_mono full_mono\n\n",
 "full_empty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¥Â» -/\n@[simp]\ntheorem full_empty : full âˆ… = (Â«exprâŠ¥Â» : subgroupoid C) :=\n  by\n  ext\n  simp only [has_bot.bot, mem_full_iff, mem_empty_iff_false, and_self_iff]\n#align full_empty full_empty\n\n",
 "full_arrow_eq_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem full_arrow_eq_iff {c d : (full D).objs} {f g : Â«expr âŸ¶ Â» c d} : f = g â†” (â†‘f : Â«expr âŸ¶ Â» c.val d.val) = â†‘g := by\n  apply subtype.ext_iff\n#align full_arrow_eq_iff full_arrow_eq_iff\n\n",
 "faithful":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem hom.faithful : âˆ€ c d, function.injective fun f : Â«expr âŸ¶ Â» c d => (hom S).map f :=\n  by\n  rintro âŸ¨c, hcâŸ© âŸ¨d, hdâŸ© âŸ¨f, hfâŸ© âŸ¨g, hgâŸ© hfg\n  simp only [subtype.mk_eq_mk]\n  exact hfg\n#align hom.faithful hom.faithful\n\n",
 "eq_to_hom_mem":
 "theorem is_wide.eq_to_hom_mem {S : subgroupoid C} (Sw : S.is_wide) {c d : C} (h : c = d) : eq_to_hom h âˆˆ S.arrows c d :=\n  by\n  cases h\n  simp only [eq_to_hom_refl]\n  apply Sw.id_mem c\n#align is_wide.eq_to_hom_mem is_wide.eq_to_hom_mem\n\n",
 "discrete_is_normal":
 "theorem discrete_is_normal : (@discrete C _).is_normal :=\n  { wide := fun c => by constructor\n    conj := fun c d f Î³ hÎ³ => by\n      cases hÎ³\n      simp only [inv_eq_inv, category.id_comp, is_iso.inv_hom_id]\n      constructor }\n#align discrete_is_normal discrete_is_normal\n\n",
 "disconnect_objs":
 "theorem disconnect_objs : S.disconnect.objs = S.objs :=\n  by\n  apply Set.ext\n  apply mem_disconnect_objs_iff\n#align disconnect_objs disconnect_objs\n\n",
 "disconnect_normal":
 "theorem disconnect_normal (Sn : S.is_normal) : S.disconnect.is_normal :=\n  { wide := fun c => âŸ¨rfl, Sn.wide câŸ©\n    conj := fun c d p Î³ âŸ¨_, h'âŸ© => âŸ¨rfl, Sn.conj _ h'âŸ© }\n#align disconnect_normal disconnect_normal\n\n",
 "disconnect_le":
 "theorem disconnect_le : S.disconnect â‰¤ S := by\n  rw [le_iff]\n  rintro _ _ _ âŸ¨âŸ©\n  assumption\n#align disconnect_le disconnect_le\n\n",
 "disconnect_is_totally_disconnected":
 "theorem disconnect_is_totally_disconnected : S.disconnect.is_totally_disconnected :=\n  by\n  rw [is_totally_disconnected_iff]\n  exact fun c d âŸ¨f, h, fSâŸ© => h\n#align disconnect_is_totally_disconnected disconnect_is_totally_disconnected\n\n",
 "conjugation_bij":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰«= Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr =â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\ntheorem is_normal.conjugation_bij (Sn : is_normal S) {c d} (p : Â«expr âŸ¶ Â» c d) :\n    Set.BijOn (fun Î³ : Â«expr âŸ¶ Â» c c => Â«expr â‰« Â» (inv p) (Â«expr â‰« Â» Î³ p)) (S.arrows c c) (S.arrows d d) :=\n  by\n  refine'\n    âŸ¨fun Î³ Î³S => Sn.conj p Î³S, fun Î³â‚ Î³â‚S Î³â‚‚ Î³â‚‚S h => _, fun Î´ Î´S =>\n      âŸ¨Â«expr â‰« Â» p (Â«expr â‰« Â» Î´ (inv p)), Sn.conj' p Î´S, _âŸ©âŸ©\n  Â·\n    simpa only [inv_eq_inv, category.assoc, is_iso.hom_inv_id, category.comp_id, is_iso.hom_inv_id_assoc] using\n      Â«expr â‰«= Â» p (Â«expr =â‰« Â» h (inv p))\n  Â· simp only [inv_eq_inv, category.assoc, is_iso.inv_hom_id, category.comp_id, is_iso.inv_hom_id_assoc]\n#align is_normal.conjugation_bij is_normal.conjugation_bij\n\n",
 "conj'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\ntheorem is_normal.conj' {S : subgroupoid C} (Sn : is_normal S) :\n    âˆ€ {c d} (p : Â«expr âŸ¶ Â» d c) {Î³ : Â«expr âŸ¶ Â» c c} (hs : Î³ âˆˆ S.arrows c c),\n      Â«expr â‰« Â» p (Â«expr â‰« Â» Î³ (inv p)) âˆˆ S.arrows d d :=\n  fun c d p Î³ hs => by\n  convert Sn.conj (inv p) hs\n  simp\n#align is_normal.conj' is_normal.conj'\n\n",
 "comap_mono":
 "theorem comap_mono (S T : subgroupoid D) : S â‰¤ T â†’ comap Ï† S â‰¤ comap Ï† T := fun ST âŸ¨c, d, pâŸ© => @ST âŸ¨_, _, _âŸ©\n#align comap_mono comap_mono\n\n",
 "comap_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‹™ Â» -/\n@[simp]\ntheorem comap_comp {E : Type _} [groupoid E] (Ïˆ : Â«expr â¥¤ Â» D E) : comap (Â«expr â‹™ Â» Ï† Ïˆ) = comap Ï† âˆ˜ comap Ïˆ :=\n  rfl\n#align comap_comp comap_comp\n\n",
 "coe_inv_coe'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n@[simp]\ntheorem coe_inv_coe' {c d : S.objs} (p : Â«expr âŸ¶ Â» c d) : (CategoryTheory.inv p).val = CategoryTheory.inv p.val := by\n  simp only [subtype.val_eq_coe, â† inv_eq_inv, coe_inv_coe]\n#align coe_inv_coe' coe_inv_coe'\n\n",
 "arrows_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\ntheorem map.arrows_iff (hÏ† : function.injective Ï†.obj) (S : subgroupoid C) {c d : D} (f : Â«expr âŸ¶ Â» c d) :\n    map.arrows Ï† hÏ† S c d f â†”\n      âˆƒ (a b : C)(g : Â«expr âŸ¶ Â» a b)(ha : Ï†.obj a = c)(hb : Ï†.obj b = d)(hg : g âˆˆ S.arrows a b),\n        f = Â«expr â‰« Â» (eq_to_hom ha.symm) (Â«expr â‰« Â» (Ï†.map g) (eq_to_hom hb)) :=\n  by\n  constructor\n  Â· rintro âŸ¨g, hgâŸ©\n    exact âŸ¨_, _, g, rfl, rfl, hg, eq_conj_eq_to_hom _âŸ©\n  Â· rintro âŸ¨a, b, g, rfl, rfl, hg, rflâŸ©\n    rw [â† eq_conj_eq_to_hom]\n    constructor\n    exact hg\n#align map.arrows_iff map.arrows_iff\n\n",
 "Inf_is_normal":
 "theorem Inf_is_normal (s : set <| subgroupoid C) (sn : âˆ€ S âˆˆ s, is_normal S) : is_normal (infâ‚› s) :=\n  { wide := by\n      simp_rw [Inf, mem_Interâ‚‚]\n      exact fun c S Ss => (sn S Ss).wide c\n    conj := by\n      simp_rw [Inf, mem_Interâ‚‚]\n      exact fun c d p Î³ hÎ³ S Ss => (sn S Ss).conj p (hÎ³ S Ss) }\n#align Inf_is_normal Inf_is_normal\n\n"}