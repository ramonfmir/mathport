{"of_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‹™q Â» -/\n#print of_eq /-\ntheorem of_eq :\n    of V = (Â«expr â‹™q Â» Quiver.Symmetrify.of Paths.of).comp (Quotient.functor <| @red_step V _).to_prefunctor :=\n  by\n  apply Prefunctor.ext; rotate_left\n  Â· rintro X\n    rfl\n  Â· rintro X Y f\n    rfl\n#align of_eq of_eq\n-/\n\n",
 "lift_unique":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤q Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‹™q Â» -/\ntheorem lift_unique (Ï† : Â«expr â¥¤q Â» V V') (Î¦ : Â«expr â¥¤ Â» (free_groupoid V) V')\n    (hÎ¦ : Â«expr â‹™q Â» (of V) Î¦.to_prefunctor = Ï†) : Î¦ = lift Ï† :=\n  by\n  apply quotient.lift_unique\n  apply paths.lift_unique\n  fapply @Quiver.Symmetrify.lift_unique _ _ _ _ _ _ _ _ _\n  Â· rw [â† functor.to_prefunctor_comp]\n    exact hÎ¦\n  Â· constructor\n    rintro X Y f\n    simp only [â† functor.to_prefunctor_comp, Prefunctor.comp_map, paths.of_map, inv_eq_inv]\n    change\n      Î¦.map (inv ((quotient.functor red_step).to_prefunctor.map f.to_path)) =\n        inv (Î¦.map ((quotient.functor red_step).to_prefunctor.map f.to_path))\n    have := functor.map_inv Î¦ ((quotient.functor red_step).to_prefunctor.map f.to_path)\n    convert this <;> simp only [inv_eq_inv]\n#align lift_unique lift_unique\n\n",
 "lift_spec":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤q Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‹™q Â» -/\ntheorem lift_spec (Ï† : Â«expr â¥¤q Â» V V') : Â«expr â‹™q Â» (of V) (lift Ï†).to_prefunctor = Ï† :=\n  by\n  rw [of_eq, Prefunctor.comp_assoc, Prefunctor.comp_assoc, functor.to_prefunctor_comp]\n  dsimp [lift]\n  rw [quotient.lift_spec, paths.lift_spec, Quiver.Symmetrify.lift_spec]\n#align lift_spec lift_spec\n\n",
 "free_groupoid_functor_id":
 "theorem free_groupoid_functor_id : free_groupoid_functor (Prefunctor.id V) = Functor.id (free_groupoid V) :=\n  by\n  dsimp only [free_groupoid_functor]; symm\n  apply lift_unique; rfl\n#align free_groupoid_functor_id free_groupoid_functor_id\n\n",
 "free_groupoid_functor_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤q Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤q Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‹™q Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‹™ Â» -/\ntheorem free_groupoid_functor_comp (Ï† : Â«expr â¥¤q Â» V V') (Ï†' : Â«expr â¥¤q Â» V' V'') :\n    free_groupoid_functor (Â«expr â‹™q Â» Ï† Ï†') = Â«expr â‹™ Â» (free_groupoid_functor Ï†) (free_groupoid_functor Ï†') :=\n  by\n  dsimp only [free_groupoid_functor]; symm\n  apply lift_unique; rfl\n#align free_groupoid_functor_comp free_groupoid_functor_comp\n\n",
 "congr_reverse_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\ntheorem congr_reverse_comp {X Y : Paths <| Quiver.Symmetrify V} (p : Â«expr âŸ¶ Â» X Y) :\n    Quot.mk (@Quotient.CompClosure _ _ red_step _ _) (Â«expr â‰« Â» p.reverse p) =\n      Quot.mk (@Quotient.CompClosure _ _ red_step _ _) ((Â«exprğŸ™Â») Y) :=\n  by\n  nth_rw 2 [â† Quiver.Path.reverse_reverse p]\n  apply congr_comp_reverse\n#align congr_reverse_comp congr_reverse_comp\n\n",
 "congr_reverse":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/-\nCopyright (c) 2022 RÃ©mi Bottinelli. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: RÃ©mi Bottinelli\n-/\ntheorem congr_reverse {X Y : Paths <| Quiver.Symmetrify V} (p q : Â«expr âŸ¶ Â» X Y) :\n    Quotient.CompClosure red_step p q â†’ Quotient.CompClosure red_step p.reverse q.reverse :=\n  by\n  rintro âŸ¨XW, pp, qq, WY, _, Z, fâŸ©\n  have :\n    quotient.comp_closure red_step (Â«expr â‰« Â» WY.reverse (Â«expr â‰« Â» ((Â«exprğŸ™Â») _) XW.reverse))\n      (Â«expr â‰« Â» WY.reverse (Â«expr â‰« Â» (Â«expr â‰« Â» f.to_path (Quiver.reverse f).to_path) XW.reverse)) :=\n    by\n    apply quotient.comp_closure.intro\n    apply red_step.step\n  simpa only [category_struct.comp, category_struct.id, Quiver.Path.reverse, Quiver.Path.nil_comp,\n    Quiver.Path.reverse_comp, Quiver.reverse_reverse, Quiver.Path.reverse_toPath, Quiver.Path.comp_assoc] using this\n#align congr_reverse congr_reverse\n\n",
 "congr_comp_reverse":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\ntheorem congr_comp_reverse {X Y : Paths <| Quiver.Symmetrify V} (p : Â«expr âŸ¶ Â» X Y) :\n    Quot.mk (@Quotient.CompClosure _ _ red_step _ _) (Â«expr â‰« Â» p p.reverse) =\n      Quot.mk (@Quotient.CompClosure _ _ red_step _ _) ((Â«exprğŸ™Â») X) :=\n  by\n  apply Quot.EqvGen_sound\n  induction' p with _ _ q f ih\n  Â· apply eqv_gen.refl\n  Â· simp only [Quiver.Path.reverse]\n    fapply eqv_gen.trans\n    Â· exact Â«expr â‰« Â» q q.reverse\n    Â· apply eqv_gen.symm\n      apply eqv_gen.rel\n      have :\n        quotient.comp_closure red_step (Â«expr â‰« Â» q (Â«expr â‰« Â» ((Â«exprğŸ™Â») _) q.reverse))\n          (Â«expr â‰« Â» q (Â«expr â‰« Â» (Â«expr â‰« Â» f.to_path (Quiver.reverse f).to_path) q.reverse)) :=\n        by\n        apply quotient.comp_closure.intro\n        apply red_step.step\n      have that : q.cons f = q.comp f.to_path := by rfl\n      rw [that]\n      simp only [category.assoc, category.id_comp] at thisâŠ¢\n      simp only [category_struct.comp, Quiver.Path.comp_assoc] at thisâŠ¢\n      exact this\n    Â· exact ih\n#align congr_comp_reverse congr_comp_reverse\n\n"}