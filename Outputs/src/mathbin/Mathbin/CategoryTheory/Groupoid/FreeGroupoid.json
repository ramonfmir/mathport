{"of_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙q » -/\n#print of_eq /-\ntheorem of_eq :\n    of V = («expr ⋙q » Quiver.Symmetrify.of Paths.of).comp (Quotient.functor <| @red_step V _).to_prefunctor :=\n  by\n  apply Prefunctor.ext; rotate_left\n  · rintro X\n    rfl\n  · rintro X Y f\n    rfl\n#align of_eq of_eq\n-/\n\n",
 "lift_unique":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤q » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙q » -/\ntheorem lift_unique (φ : «expr ⥤q » V V') (Φ : «expr ⥤ » (free_groupoid V) V')\n    (hΦ : «expr ⋙q » (of V) Φ.to_prefunctor = φ) : Φ = lift φ :=\n  by\n  apply quotient.lift_unique\n  apply paths.lift_unique\n  fapply @Quiver.Symmetrify.lift_unique _ _ _ _ _ _ _ _ _\n  · rw [← functor.to_prefunctor_comp]\n    exact hΦ\n  · constructor\n    rintro X Y f\n    simp only [← functor.to_prefunctor_comp, Prefunctor.comp_map, paths.of_map, inv_eq_inv]\n    change\n      Φ.map (inv ((quotient.functor red_step).to_prefunctor.map f.to_path)) =\n        inv (Φ.map ((quotient.functor red_step).to_prefunctor.map f.to_path))\n    have := functor.map_inv Φ ((quotient.functor red_step).to_prefunctor.map f.to_path)\n    convert this <;> simp only [inv_eq_inv]\n#align lift_unique lift_unique\n\n",
 "lift_spec":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤q » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙q » -/\ntheorem lift_spec (φ : «expr ⥤q » V V') : «expr ⋙q » (of V) (lift φ).to_prefunctor = φ :=\n  by\n  rw [of_eq, Prefunctor.comp_assoc, Prefunctor.comp_assoc, functor.to_prefunctor_comp]\n  dsimp [lift]\n  rw [quotient.lift_spec, paths.lift_spec, Quiver.Symmetrify.lift_spec]\n#align lift_spec lift_spec\n\n",
 "free_groupoid_functor_id":
 "theorem free_groupoid_functor_id : free_groupoid_functor (Prefunctor.id V) = Functor.id (free_groupoid V) :=\n  by\n  dsimp only [free_groupoid_functor]; symm\n  apply lift_unique; rfl\n#align free_groupoid_functor_id free_groupoid_functor_id\n\n",
 "free_groupoid_functor_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤q » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤q » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙q » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\ntheorem free_groupoid_functor_comp (φ : «expr ⥤q » V V') (φ' : «expr ⥤q » V' V'') :\n    free_groupoid_functor («expr ⋙q » φ φ') = «expr ⋙ » (free_groupoid_functor φ) (free_groupoid_functor φ') :=\n  by\n  dsimp only [free_groupoid_functor]; symm\n  apply lift_unique; rfl\n#align free_groupoid_functor_comp free_groupoid_functor_comp\n\n",
 "congr_reverse_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\ntheorem congr_reverse_comp {X Y : Paths <| Quiver.Symmetrify V} (p : «expr ⟶ » X Y) :\n    Quot.mk (@Quotient.CompClosure _ _ red_step _ _) («expr ≫ » p.reverse p) =\n      Quot.mk (@Quotient.CompClosure _ _ red_step _ _) ((«expr𝟙») Y) :=\n  by\n  nth_rw 2 [← Quiver.Path.reverse_reverse p]\n  apply congr_comp_reverse\n#align congr_reverse_comp congr_reverse_comp\n\n",
 "congr_reverse":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/-\nCopyright (c) 2022 Rémi Bottinelli. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Rémi Bottinelli\n-/\ntheorem congr_reverse {X Y : Paths <| Quiver.Symmetrify V} (p q : «expr ⟶ » X Y) :\n    Quotient.CompClosure red_step p q → Quotient.CompClosure red_step p.reverse q.reverse :=\n  by\n  rintro ⟨XW, pp, qq, WY, _, Z, f⟩\n  have :\n    quotient.comp_closure red_step («expr ≫ » WY.reverse («expr ≫ » ((«expr𝟙») _) XW.reverse))\n      («expr ≫ » WY.reverse («expr ≫ » («expr ≫ » f.to_path (Quiver.reverse f).to_path) XW.reverse)) :=\n    by\n    apply quotient.comp_closure.intro\n    apply red_step.step\n  simpa only [category_struct.comp, category_struct.id, Quiver.Path.reverse, Quiver.Path.nil_comp,\n    Quiver.Path.reverse_comp, Quiver.reverse_reverse, Quiver.Path.reverse_toPath, Quiver.Path.comp_assoc] using this\n#align congr_reverse congr_reverse\n\n",
 "congr_comp_reverse":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\ntheorem congr_comp_reverse {X Y : Paths <| Quiver.Symmetrify V} (p : «expr ⟶ » X Y) :\n    Quot.mk (@Quotient.CompClosure _ _ red_step _ _) («expr ≫ » p p.reverse) =\n      Quot.mk (@Quotient.CompClosure _ _ red_step _ _) ((«expr𝟙») X) :=\n  by\n  apply Quot.EqvGen_sound\n  induction' p with _ _ q f ih\n  · apply eqv_gen.refl\n  · simp only [Quiver.Path.reverse]\n    fapply eqv_gen.trans\n    · exact «expr ≫ » q q.reverse\n    · apply eqv_gen.symm\n      apply eqv_gen.rel\n      have :\n        quotient.comp_closure red_step («expr ≫ » q («expr ≫ » ((«expr𝟙») _) q.reverse))\n          («expr ≫ » q («expr ≫ » («expr ≫ » f.to_path (Quiver.reverse f).to_path) q.reverse)) :=\n        by\n        apply quotient.comp_closure.intro\n        apply red_step.step\n      have that : q.cons f = q.comp f.to_path := by rfl\n      rw [that]\n      simp only [category.assoc, category.id_comp] at this⊢\n      simp only [category_struct.comp, Quiver.Path.comp_assoc] at this⊢\n      exact this\n    · exact ih\n#align congr_comp_reverse congr_comp_reverse\n\n"}