{"w_mk_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n-- `w_mk_left` is not needed, as it is a consequence of `w` and `mk_hom`.\n@[simp, reassoc.1]\ntheorem w_mk_right {f : arrow T} {X Y : T} {g : «expr ⟶ » X Y} (sq : «expr ⟶ » f (mk g)) :\n    «expr ≫ » sq.left g = «expr ≫ » f.hom sq.right :=\n  sq.w\n#align w_mk_right w_mk_right\n\n",
 "w":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem w {f g : arrow T} (sq : «expr ⟶ » f g) : «expr ≫ » sq.left g.hom = «expr ≫ » f.hom sq.right :=\n  sq.w\n#align w w\n\n",
 "square_to_iso_invert":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≅ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/-- Given a square from an arrow `i` to an isomorphism `p`, express the source part of `sq`\nin terms of the inverse of `p`. -/\n@[simp]\ntheorem square_to_iso_invert (i : arrow T) {X Y : T} (p : «expr ≅ » X Y) (sq : «expr ⟶ » i (arrow.mk p.hom)) :\n    «expr ≫ » i.hom («expr ≫ » sq.right p.inv) = sq.left := by\n  simpa only [category.assoc] using (iso.comp_inv_eq p).mpr (arrow.w_mk_right sq).symm\n#align square_to_iso_invert square_to_iso_invert\n\n",
 "square_from_iso_invert":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≅ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/-- Given a square from an isomorphism `i` to an arrow `p`, express the target part of `sq`\nin terms of the inverse of `i`. -/\ntheorem square_from_iso_invert {X Y : T} (i : «expr ≅ » X Y) (p : arrow T) (sq : «expr ⟶ » (arrow.mk i.hom) p) :\n    «expr ≫ » i.inv («expr ≫ » sq.left p.hom) = sq.right := by simp only [iso.inv_hom_id_assoc, arrow.w, arrow.mk_hom]\n#align square_from_iso_invert square_from_iso_invert\n\n",
 "mk_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem mk_injective (A B : T) : function.injective (arrow.mk : «expr ⟶ » A B → arrow T) := fun f g h =>\n  by\n  cases h\n  rfl\n#align mk_injective mk_injective\n\n",
 "mk_inj":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem mk_inj (A B : T) {f g : «expr ⟶ » A B} : arrow.mk f = arrow.mk g ↔ f = g :=\n  (mk_injective A B).eq_iff\n#align mk_inj mk_inj\n\n",
 "mk_eq":
 "@[simp]\ntheorem mk_eq (f : arrow T) : arrow.mk f.hom = f := by\n  cases f\n  rfl\n#align mk_eq mk_eq\n\n",
 "left_hom_inv_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp]\ntheorem left_hom_inv_right [IsIso sq] : «expr ≫ » sq.left («expr ≫ » g.hom (inv sq.right)) = f.hom := by\n  simp only [← category.assoc, is_iso.comp_inv_eq, w]\n#align left_hom_inv_right left_hom_inv_right\n\n",
 "iso_w'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≅ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem iso_w' {W X Y Z : T} {f : «expr ⟶ » W X} {g : «expr ⟶ » Y Z} (e : «expr ≅ » (arrow.mk f) (arrow.mk g)) :\n    g = «expr ≫ » e.inv.left («expr ≫ » f e.hom.right) :=\n  iso_w e\n#align iso_w' iso_w'\n\n",
 "iso_w":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≅ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem iso_w {f g : arrow T} (e : «expr ≅ » f g) : g.hom = «expr ≫ » e.inv.left («expr ≫ » f.hom e.hom.right) :=\n  by\n  have eq := arrow.hom.congr_right e.inv_hom_id\n  dsimp at eq\n  erw [w_assoc, eq, category.comp_id]\n#align iso_w iso_w\n\n",
 "is_iso_of_iso_left_of_is_iso_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem is_iso_of_iso_left_of_is_iso_right {f g : arrow T} (ff : «expr ⟶ » f g) [IsIso ff.left] [IsIso ff.right] :\n    IsIso ff :=\n  {\n    out :=\n      ⟨⟨inv ff.left, inv ff.right⟩, by ext <;> dsimp <;> simp only [is_iso.hom_inv_id], by\n        ext <;> dsimp <;> simp only [is_iso.inv_hom_id]⟩ }\n#align is_iso_of_iso_left_of_is_iso_right is_iso_of_iso_left_of_is_iso_right\n\n",
 "inv_right":
 "@[simp]\ntheorem inv_right [IsIso sq] : (inv sq).right = inv sq.right :=\n  is_iso.eq_inv_of_hom_inv_id <| by rw [← comma.comp_right, is_iso.hom_inv_id, id_right]\n#align inv_right inv_right\n\n",
 "inv_left_hom_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n-- simp proves this\ntheorem inv_left_hom_right [IsIso sq] : «expr ≫ » (inv sq.left) («expr ≫ » f.hom sq.right) = g.hom := by\n  simp only [w, is_iso.inv_comp_eq]\n#align inv_left_hom_right inv_left_hom_right\n\n",
 "inv_left":
 "@[simp]\ntheorem inv_left [IsIso sq] : (inv sq).left = inv sq.left :=\n  is_iso.eq_inv_of_hom_inv_id <| by rw [← comma.comp_left, is_iso.hom_inv_id, id_left]\n#align inv_left inv_left\n\n",
 "id_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n@[simp]\ntheorem id_right (f : arrow T) : comma_morphism.right ((«expr𝟙») f) = («expr𝟙») f.right :=\n  rfl\n#align id_right id_right\n\n",
 "id_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/-\nCopyright (c) 2020 Markus Himmel. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Markus Himmel\n-/\n-- morphism levels before object levels. See note [category_theory universes].\n-- Satisfying the inhabited linter\n@[simp]\ntheorem id_left (f : arrow T) : comma_morphism.left ((«expr𝟙») f) = («expr𝟙») f.left :=\n  rfl\n#align id_left id_left\n\n",
 "congr_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem hom.congr_right {f g : arrow T} {φ₁ φ₂ : «expr ⟶ » f g} (h : φ₁ = φ₂) : φ₁.right = φ₂.right := by rw [h]\n#align hom.congr_right hom.congr_right\n\n",
 "congr_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem hom.congr_left {f g : arrow T} {φ₁ φ₂ : «expr ⟶ » f g} (h : φ₁ = φ₂) : φ₁.left = φ₂.left := by rw [h]\n#align hom.congr_left hom.congr_left\n\n"}