{"wide_cospan_map_term":
 "@[simp]\ntheorem wide_cospan_map_term {A : C} (s : Set (Subobject A)) (j) :\n    (wideCospan s).map (wide_pullback_shape.hom.term j) = ((equivShrink (Subobject A)).symm j).arrow :=\n  rfl\n#align wide_cospan_map_term wide_cospan_map_term\n\n",
 "underlying_iso_top_hom":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\ntheorem underlying_iso_top_hom {B : C} : (underlyingIso ((Â«exprğŸ™Â») B)).hom = (Â«exprâŠ¤Â» : Subobject B).arrow :=\n  by\n  convert underlying_iso_hom_comp_eq_mk ((Â«exprğŸ™Â») B)\n  simp only [comp_id]\n#align underlying_iso_top_hom underlying_iso_top_hom\n\n",
 "underlying_iso_inv_top_arrow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n@[simp, reassoc.1]\ntheorem underlying_iso_inv_top_arrow {B : C} :\n    Â«expr â‰« Â» (underlyingIso _).inv (Â«exprâŠ¤Â» : Subobject B).arrow = (Â«exprğŸ™Â») B :=\n  underlyingIso_arrow _\n#align underlying_iso_inv_top_arrow underlying_iso_inv_top_arrow\n\n",
 "top_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\n/-\nCopyright (c) 2020 Scott Morrison. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Bhavik Mehta, Scott Morrison\n-/\n@[simp]\ntheorem top_left (X : C) : ((Â«exprâŠ¤Â» : MonoOver X) : C) = X :=\n  rfl\n#align top_left top_left\n\n",
 "top_factors":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\ntheorem top_factors {A B : C} (f : Â«expr âŸ¶ Â» A B) : (Â«exprâŠ¤Â» : Subobject B).factors f :=\n  âŸ¨f, comp_id _âŸ©\n#align top_factors top_factors\n\n",
 "top_eq_id":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\ntheorem top_eq_id (B : C) : (Â«exprâŠ¤Â» : Subobject B) = Subobject.mk ((Â«exprğŸ™Â») B) :=\n  rfl\n#align top_eq_id top_eq_id\n\n",
 "top_arrow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n@[simp]\ntheorem top_arrow (X : C) : (Â«exprâŠ¤Â» : MonoOver X).arrow = (Â«exprğŸ™Â») X :=\n  rfl\n#align top_arrow top_arrow\n\n",
 "symm_apply_mem_iff_mem_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰ƒ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\ntheorem symm_apply_mem_iff_mem_image {Î± Î² : Type _} (e : Â«expr â‰ƒ Â» Î± Î²) (s : Set Î±) (x : Î²) :\n    e.symm x âˆˆ s â†” x âˆˆ Â«expr '' Â» e s :=\n  âŸ¨fun h => âŸ¨e.symm x, h, by simpâŸ©, by\n    rintro âŸ¨a, m, rflâŸ©\n    simpa using mâŸ©\n#align symm_apply_mem_iff_mem_image symm_apply_mem_iff_mem_image\n\n",
 "supâ‚›_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n#print supâ‚›_le /-\ntheorem supâ‚›_le {A : C} (s : Set (Subobject A)) (f : Subobject A) (k : âˆ€ g âˆˆ s, g â‰¤ f) : sup s â‰¤ f :=\n  by\n  fapply le_of_comm\n  Â· dsimp [Sup]\n    refine' Â«expr â‰« Â» (underlying_iso _).hom (image.lift âŸ¨_, f.arrow, _, _âŸ©)\n    Â· refine' sigma.desc _\n      rintro âŸ¨g, mâŸ©\n      refine' underlying.map (hom_of_le (k _ _))\n      simpa [symm_apply_mem_iff_mem_image] using m\n    Â· ext j\n      rcases j with âŸ¨j, mâŸ©\n      dsimp [small_coproduct_desc]\n      simp\n      dsimp\n      simp\n  Â· dsimp [Sup]\n    simp\n#align Sup_le supâ‚›_le\n-/\n\n",
 "sup_factors_of_factors_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŠ” Â» -/\ntheorem sup_factors_of_factors_right {A B : C} {X Y : Subobject B} {f : Â«expr âŸ¶ Â» A B} (P : Y.factors f) :\n    (Â«expr âŠ” Â» X Y).factors f :=\n  factors_of_le f le_sup_right P\n#align sup_factors_of_factors_right sup_factors_of_factors_right\n\n",
 "sup_factors_of_factors_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŠ” Â» -/\ntheorem sup_factors_of_factors_left {A B : C} {X Y : Subobject B} {f : Â«expr âŸ¶ Â» A B} (P : X.factors f) :\n    (Â«expr âŠ” Â» X Y).factors f :=\n  factors_of_le f le_sup_left P\n#align sup_factors_of_factors_left sup_factors_of_factors_left\n\n",
 "pullback_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\ntheorem pullback_top (f : Â«expr âŸ¶ Â» X Y) : (pullback f).obj (Â«exprâŠ¤Â») = Â«exprâŠ¤Â» :=\n  Quotient.sound' âŸ¨MonoOver.pullbackTop fâŸ©\n#align pullback_top pullback_top\n\n",
 "pullback_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\ntheorem pullback_self {A B : C} (f : Â«expr âŸ¶ Â» A B) [Mono f] : (pullback f).obj (mk f) = Â«exprâŠ¤Â» :=\n  Quotient.sound' âŸ¨MonoOver.pullbackSelf fâŸ©\n#align pullback_self pullback_self\n\n",
 "prod_eq_inf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¨¯ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŠ“ Â» -/\ntheorem prod_eq_inf {A : C} {fâ‚ fâ‚‚ : Subobject A} [HasBinaryProduct fâ‚ fâ‚‚] : Â«expr â¨¯ Â» fâ‚ fâ‚‚ = Â«expr âŠ“ Â» fâ‚ fâ‚‚ :=\n  le_antisymm (le_inf Limits.prod.fst.le Limits.prod.snd.le) (prod.lift inf_le_left.hom inf_le_right.hom).le\n#align prod_eq_inf prod_eq_inf\n\n",
 "nontrivial_of_not_is_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n/-- A nonzero object has nontrivial subobject lattice. -/\ntheorem nontrivial_of_not_is_zero {X : C} (h : Â¬IsZero X) : Nontrivial (Subobject X) :=\n  âŸ¨âŸ¨mk (0 : Â«expr âŸ¶ Â» 0 X), mk ((Â«exprğŸ™Â») X), fun w => h (IsZero.of_iso (isZero_zero C) (isoOfMkEqMk _ _ w).symm)âŸ©âŸ©\n#align nontrivial_of_not_is_zero nontrivial_of_not_is_zero\n\n",
 "mk_eq_top_of_is_iso":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\ntheorem mk_eq_top_of_is_iso {X Y : C} (f : Â«expr âŸ¶ Â» X Y) [IsIso f] : mk f = Â«exprâŠ¤Â» :=\n  (isIso_iff_mk_eq_top f).mp inferInstance\n#align mk_eq_top_of_is_iso mk_eq_top_of_is_iso\n\n",
 "mk_eq_bot_iff_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¥Â» -/\ntheorem mk_eq_bot_iff_zero {f : Â«expr âŸ¶ Â» X Y} [Mono f] : Subobject.mk f = Â«exprâŠ¥Â» â†” f = 0 :=\n  âŸ¨fun h => by simpa [h, bot_factors_iff_zero] using mk_factors_self f, fun h =>\n    mk_eq_mk_of_comm _ _ ((isoZeroOfMonoEqZero h).trans HasZeroObject.zeroIsoInitial) (by simp [h])âŸ©\n#align mk_eq_bot_iff_zero mk_eq_bot_iff_zero\n\n",
 "map_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\n@[simp]\ntheorem map_top (f : Â«expr âŸ¶ Â» X Y) [Mono f] : (map f).obj (Â«exprâŠ¤Â») = Subobject.mk f :=\n  Quotient.sound' âŸ¨MonoOver.mapTop fâŸ©\n#align map_top map_top\n\n",
 "map_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¥Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¥Â» -/\ntheorem map_bot (f : Â«expr âŸ¶ Â» X Y) [Mono f] : (map f).obj (Â«exprâŠ¥Â») = Â«exprâŠ¥Â» :=\n  Quotient.sound' âŸ¨MonoOver.mapBot fâŸ©\n#align map_bot map_bot\n\n",
 "le_supâ‚›":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (f Â«expr âˆˆ Â» s) -/\n#print le_supâ‚› /-\ntheorem le_supâ‚› {A : C} (s : Set (Subobject A)) (f) (_ : f âˆˆ s) : f â‰¤ sup s :=\n  by\n  fapply le_of_comm\n  Â· dsimp [Sup]\n    refine' Â«expr â‰« Â» _ (Â«expr â‰« Â» (factor_thru_image _) (underlying_iso _).inv)\n    refine' Â«expr â‰« Â» _ (sigma.Î¹ _ âŸ¨equivShrink _ f, by simpa [Set.mem_image] using HâŸ©)\n    exact eq_to_hom (congr_arg (fun X : subobject A => (X : C)) (Equiv.symm_apply_apply _ _).symm)\n  Â· dsimp [Sup, small_coproduct_desc]\n    simp\n    dsimp\n    simp\n#align le_Sup le_supâ‚›\n-/\n\n",
 "le_infâ‚›":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n#print le_infâ‚› /-\ntheorem le_infâ‚› {A : C} (s : Set (Subobject A)) (f : Subobject A) (k : âˆ€ g âˆˆ s, f â‰¤ g) : f â‰¤ infâ‚› s :=\n  by\n  fapply le_of_comm\n  Â· exact Â«expr â‰« Â» (limits.limit.lift _ (le_Inf_cone s f k)) (underlying_iso _).inv\n  Â· dsimp [Inf, wide_pullback_Î¹]\n    simp\n#align le_Inf le_infâ‚›\n-/\n\n",
 "le_inf":
 "#print le_inf /-\ntheorem le_inf {A : C} (h f g : Subobject A) : h â‰¤ f â†’ h â‰¤ g â†’ h â‰¤ (inf.obj f).obj g :=\n  Quotient.inductionOnâ‚ƒ' h f g\n    (by\n      rintro f g h âŸ¨kâŸ© âŸ¨lâŸ©\n      exact âŸ¨mono_over.le_inf _ _ _ k lâŸ©)\n#align le_inf le_inf\n-/\n\n",
 "le_Inf_cone_Ï€_app_none":
 "@[simp]\ntheorem le_Inf_cone_Ï€_app_none {A : C} (s : Set (Subobject A)) (f : Subobject A) (k : âˆ€ g âˆˆ s, f â‰¤ g) :\n    (leInfCone s f k).Ï€.app none = f.arrow :=\n  rfl\n#align le_Inf_cone_Ï€_app_none le_Inf_cone_Ï€_app_none\n\n",
 "is_iso_iff_mk_eq_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\ntheorem is_iso_iff_mk_eq_top {X Y : C} (f : Â«expr âŸ¶ Â» X Y) [Mono f] : IsIso f â†” mk f = Â«exprâŠ¤Â» :=\n  âŸ¨fun _ => mk_eq_mk_of_comm _ _ (as_iso f) (category.comp_id _), fun h =>\n    by\n    rw [â† of_mk_le_mk_comp h.le, category.comp_id]\n    exact is_iso.of_iso (iso_of_mk_eq_mk _ _ h)âŸ©\n#align is_iso_iff_mk_eq_top is_iso_iff_mk_eq_top\n\n",
 "is_iso_arrow_iff_eq_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\ntheorem is_iso_arrow_iff_eq_top {Y : C} (P : Subobject Y) : IsIso P.arrow â†” P = Â«exprâŠ¤Â» := by\n  rw [is_iso_iff_mk_eq_top, mk_arrow]\n#align is_iso_arrow_iff_eq_top is_iso_arrow_iff_eq_top\n\n",
 "infâ‚›_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (f Â«expr âˆˆ Â» s) -/\n#print infâ‚›_le /-\ntheorem infâ‚›_le {A : C} (s : Set (Subobject A)) (f) (_ : f âˆˆ s) : infâ‚› s â‰¤ f :=\n  by\n  fapply le_of_comm\n  Â· refine'\n      Â«expr â‰« Â» (underlying_iso _).hom\n        (Â«expr â‰« Â»\n          (limits.limit.Ï€ (wide_cospan s) (some âŸ¨equivShrink _ f, Set.mem_image_of_mem (equivShrink (subobject A)) HâŸ©))\n          _)\n    apply eq_to_hom\n    apply congr_arg fun X : subobject A => (X : C)\n    exact Equiv.symm_apply_apply _ _\n  Â· dsimp [Inf]\n    simp only [category.comp_id, category.assoc, â† underlying_iso_hom_comp_eq_mk, subobject.arrow_congr,\n      congr_arg_mpr_hom_left, iso.cancel_iso_hom_left]\n    convert limit.w (wide_cospan s) (wide_pullback_shape.hom.term _)\n#align Inf_le infâ‚›_le\n-/\n\n",
 "inf_pullback":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŠ“ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŠ“ Â» -/\n/-- `âŠ“` commutes with pullback. -/\ntheorem inf_pullback {X Y : C} (g : Â«expr âŸ¶ Â» X Y) (fâ‚ fâ‚‚) :\n    (pullback g).obj (Â«expr âŠ“ Â» fâ‚ fâ‚‚) = Â«expr âŠ“ Â» ((pullback g).obj fâ‚) ((pullback g).obj fâ‚‚) :=\n  by\n  revert fâ‚\n  apply Quotient.ind'\n  intro fâ‚\n  erw [inf_def, inf_def, inf_eq_map_pullback', inf_eq_map_pullback', â† pullback_comp, â†\n    map_pullback pullback.condition (pullback_is_pullback fâ‚.arrow g), â† pullback_comp, pullback.condition]\n  rfl\n#align inf_pullback inf_pullback\n\n",
 "inf_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŠ“ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŠ“ Â» -/\n/-- `âŠ“` commutes with map. -/\ntheorem inf_map {X Y : C} (g : Â«expr âŸ¶ Â» Y X) [Mono g] (fâ‚ fâ‚‚) :\n    (map g).obj (Â«expr âŠ“ Â» fâ‚ fâ‚‚) = Â«expr âŠ“ Â» ((map g).obj fâ‚) ((map g).obj fâ‚‚) :=\n  by\n  revert fâ‚\n  apply Quotient.ind'\n  intro fâ‚\n  erw [inf_def, inf_def, inf_eq_map_pullback', inf_eq_map_pullback', â† map_comp]\n  dsimp\n  rw [pullback_comp, pullback_map_self]\n#align inf_map inf_map\n\n",
 "inf_le_right":
 "#print inf_le_right /-\ntheorem inf_le_right {A : C} (f g : Subobject A) : (inf.obj f).obj g â‰¤ g :=\n  Quotient.inductionOnâ‚‚' f g fun a b => âŸ¨MonoOver.infLERight _ _âŸ©\n#align inf_le_right inf_le_right\n-/\n\n",
 "inf_le_left":
 "#print inf_le_left /-\ntheorem inf_le_left {A : C} (f g : Subobject A) : (inf.obj f).obj g â‰¤ f :=\n  Quotient.inductionOnâ‚‚' f g fun a b => âŸ¨MonoOver.infLELeft _ _âŸ©\n#align inf_le_left inf_le_left\n-/\n\n",
 "inf_factors":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŠ“ Â» -/\n@[simp]\ntheorem inf_factors {A B : C} {X Y : Subobject B} (f : Â«expr âŸ¶ Â» A B) :\n    (Â«expr âŠ“ Â» X Y).factors f â†” X.factors f âˆ§ Y.factors f :=\n  âŸ¨fun h => âŸ¨factors_left_of_inf_factors h, factors_right_of_inf_factors hâŸ©,\n    by\n    revert X Y\n    refine' Quotient.indâ‚‚' _\n    rintro X Y âŸ¨âŸ¨gâ‚, rflâŸ©, âŸ¨gâ‚‚, hgâ‚‚âŸ©âŸ©\n    exact âŸ¨_, pullback.lift_snd_assoc _ _ hgâ‚‚ _âŸ©âŸ©\n#align inf_factors inf_factors\n\n",
 "inf_eq_map_pullback'":
 "theorem inf_eq_map_pullback' {A : C} (fâ‚ : MonoOver A) (fâ‚‚ : Subobject A) :\n    (Subobject.inf.obj (Quotient.mk'' fâ‚)).obj fâ‚‚ =\n      (Subobject.map fâ‚.arrow).obj ((Subobject.pullback fâ‚.arrow).obj fâ‚‚) :=\n  by\n  apply Quotient.inductionOn' fâ‚‚\n  intro fâ‚‚\n  rfl\n#align inf_eq_map_pullback' inf_eq_map_pullback'\n\n",
 "inf_eq_map_pullback":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŠ“ Â» -/\ntheorem inf_eq_map_pullback {A : C} (fâ‚ : MonoOver A) (fâ‚‚ : Subobject A) :\n    (Â«expr âŠ“ Â» (Quotient.mk'' fâ‚) fâ‚‚ : Subobject A) = (map fâ‚.arrow).obj ((pullback fâ‚.arrow).obj fâ‚‚) :=\n  inf_eq_map_pullback' fâ‚ fâ‚‚\n#align inf_eq_map_pullback inf_eq_map_pullback\n\n",
 "inf_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŠ“ Â» -/\ntheorem inf_def {B : C} (m m' : Subobject B) : Â«expr âŠ“ Â» m m' = (inf.obj m).obj m' :=\n  rfl\n#align inf_def inf_def\n\n",
 "inf_arrow_factors_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŠ“ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŠ“ Â» -/\ntheorem inf_arrow_factors_right {B : C} (X Y : Subobject B) : Y.factors (Â«expr âŠ“ Â» X Y).arrow :=\n  (factors_iff _ _).mpr âŸ¨ofLE (Â«expr âŠ“ Â» X Y) Y (inf_le_right X Y), by simpâŸ©\n#align inf_arrow_factors_right inf_arrow_factors_right\n\n",
 "inf_arrow_factors_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŠ“ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŠ“ Â» -/\ntheorem inf_arrow_factors_left {B : C} (X Y : Subobject B) : X.factors (Â«expr âŠ“ Â» X Y).arrow :=\n  (factors_iff _ _).mpr âŸ¨ofLE (Â«expr âŠ“ Â» X Y) X (inf_le_left X Y), by simpâŸ©\n#align inf_arrow_factors_left inf_arrow_factors_left\n\n",
 "finset_sup_factors":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem finset_sup_factors {I : Type _} {A B : C} {s : Finset I} {P : I â†’ Subobject B} {f : Â«expr âŸ¶ Â» A B}\n    (h : âˆƒ i âˆˆ s, (P i).factors f) : (s.sup P).factors f := by\n  classical\n    revert h\n    apply Finset.induction_on s\n    Â· rintro âŸ¨_, âŸ¨âŸ¨âŸ©, _âŸ©âŸ©\n    Â· rintro i s nm ih âŸ¨j, âŸ¨m, hâŸ©âŸ©\n      simp only [Finset.sup_insert]\n      simp at m\n      rcases m with (rfl | m)\n      Â· exact sup_factors_of_factors_left h\n      Â· exact sup_factors_of_factors_right (ih âŸ¨j, âŸ¨m, hâŸ©âŸ©)\n#align finset_sup_factors finset_sup_factors\n\n",
 "finset_inf_factors":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n@[simp]\ntheorem finset_inf_factors {I : Type _} {A B : C} {s : Finset I} {P : I â†’ Subobject B} (f : Â«expr âŸ¶ Â» A B) :\n    (s.inf P).factors f â†” âˆ€ i âˆˆ s, (P i).factors f := by\n  classical\n    apply Finset.induction_on s\n    Â· simp [top_factors]\n    Â· intro i s nm ih\n      simp [ih]\n#align finset_inf_factors finset_inf_factors\n\n",
 "finset_inf_arrow_factors":
 "-- `i` is explicit here because often we'd like to defer a proof of `m`\ntheorem finset_inf_arrow_factors {I : Type _} {B : C} (s : Finset I) (P : I â†’ Subobject B) (i : I) (m : i âˆˆ s) :\n    (P i).factors (s.inf P).arrow := by\n  revert i m\n  classical\n    apply Finset.induction_on s\n    Â· rintro _ âŸ¨âŸ©\n    Â· intro i s nm ih j m\n      rw [Finset.inf_insert]\n      simp only [Finset.mem_insert] at m\n      rcases m with (rfl | m)\n      Â· rw [â† factor_thru_arrow _ _ (inf_arrow_factors_left _ _)]\n        exact factors_comp_arrow _\n      Â· rw [â† factor_thru_arrow _ _ (inf_arrow_factors_right _ _)]\n        apply factors_of_factors_right\n        exact ih _ m\n#align finset_inf_arrow_factors finset_inf_arrow_factors\n\n",
 "factors_right_of_inf_factors":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŠ“ Â» -/\ntheorem factors_right_of_inf_factors {A B : C} {X Y : Subobject B} {f : Â«expr âŸ¶ Â» A B} (h : (Â«expr âŠ“ Â» X Y).factors f) :\n    Y.factors f :=\n  factors_of_le _ (inf_le_right _ _) h\n#align factors_right_of_inf_factors factors_right_of_inf_factors\n\n",
 "factors_left_of_inf_factors":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŠ“ Â» -/\ntheorem factors_left_of_inf_factors {A B : C} {X Y : Subobject B} {f : Â«expr âŸ¶ Â» A B} (h : (Â«expr âŠ“ Â» X Y).factors f) :\n    X.factors f :=\n  factors_of_le _ (inf_le_left _ _) h\n#align factors_left_of_inf_factors factors_left_of_inf_factors\n\n",
 "eq_top_of_is_iso_arrow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\ntheorem eq_top_of_is_iso_arrow {Y : C} (P : Subobject Y) [IsIso P.arrow] : P = Â«exprâŠ¤Â» :=\n  (isIso_arrow_iff_eq_top P).mp inferInstance\n#align eq_top_of_is_iso_arrow eq_top_of_is_iso_arrow\n\n",
 "bot_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¥Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¥_ Â» -/\n@[simp]\ntheorem bot_left (X : C) : ((Â«exprâŠ¥Â» : MonoOver X) : C) = Â«exprâŠ¥_ Â» C :=\n  rfl\n#align bot_left bot_left\n\n",
 "bot_factors_iff_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¥Â» -/\ntheorem bot_factors_iff_zero {A B : C} (f : Â«expr âŸ¶ Â» A B) : (Â«exprâŠ¥Â» : Subobject B).factors f â†” f = 0 :=\n  âŸ¨by\n    rintro âŸ¨h, rflâŸ©\n    simp, by\n    rintro rfl\n    exact âŸ¨0, by simpâŸ©âŸ©\n#align bot_factors_iff_zero bot_factors_iff_zero\n\n",
 "bot_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¥Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n#print bot_eq_zero /-\ntheorem bot_eq_zero {B : C} : (Â«exprâŠ¥Â» : Subobject B) = Subobject.mk (0 : Â«expr âŸ¶ Â» 0 B) :=\n  mk_eq_mk_of_comm _ _ (initialIsInitial.unique_up_to_iso HasZeroObject.zeroIsInitial) (by simp)\n#align bot_eq_zero bot_eq_zero\n-/\n\n",
 "bot_eq_initial_to":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¥Â» -/\ntheorem bot_eq_initial_to {B : C} : (Â«exprâŠ¥Â» : Subobject B) = Subobject.mk (initial.to B) :=\n  rfl\n#align bot_eq_initial_to bot_eq_initial_to\n\n",
 "bot_arrow_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¥Â» -/\n@[simp]\ntheorem bot_arrow_eq_zero [HasZeroMorphisms C] {B : C} : (Â«exprâŠ¥Â» : MonoOver B).arrow = 0 :=\n  zero_of_source_iso_zero _ botCoeIsoZero\n#align bot_arrow_eq_zero bot_arrow_eq_zero\n\n",
 "bot_arrow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¥Â» -/\n@[simp]\ntheorem bot_arrow {B : C} : (Â«exprâŠ¥Â» : Subobject B).arrow = 0 :=\n  zero_of_source_iso_zero _ botCoeIsoZero\n#align bot_arrow bot_arrow\n\n"}