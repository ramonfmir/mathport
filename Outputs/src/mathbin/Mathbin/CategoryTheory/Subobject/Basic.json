{"underlying_iso_hom_comp_eq_mk":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n@[simp, reassoc.1]\ntheorem underlying_iso_hom_comp_eq_mk {X Y : C} (f : Â«expr âŸ¶ Â» X Y) [Mono f] :\n    Â«expr â‰« Â» (underlying_iso f).hom f = (mk f).arrow :=\n  (Iso.eq_inv_comp _).1 (underlying_iso_arrow f).symm\n#align underlying_iso_hom_comp_eq_mk underlying_iso_hom_comp_eq_mk\n\n",
 "underlying_iso_arrow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n@[simp, reassoc.1, elementwise]\ntheorem underlying_iso_arrow {X Y : C} (f : Â«expr âŸ¶ Â» X Y) [Mono f] :\n    Â«expr â‰« Â» (underlying_iso f).inv (subobject.mk f).arrow = f :=\n  over.w _\n#align underlying_iso_arrow underlying_iso_arrow\n\n",
 "underlying_as_coe":
 "@[simp]\ntheorem underlying_as_coe {X : C} (P : subobject X) : underlying.obj P = P :=\n  rfl\n#align underlying_as_coe underlying_as_coe\n\n",
 "underlying_arrow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n@[simp, reassoc.1]\ntheorem underlying_arrow {X : C} {Y Z : subobject X} (f : Â«expr âŸ¶ Â» Y Z) :\n    Â«expr â‰« Â» (underlying.map f) (arrow Z) = arrow Y :=\n  over.w (representative.map f)\n#align underlying_arrow underlying_arrow\n\n",
 "representative_coe":
 "@[simp]\ntheorem representative_coe (Y : subobject X) : (representative.obj Y : C) = (Y : C) :=\n  rfl\n#align representative_coe representative_coe\n\n",
 "representative_arrow":
 "@[simp]\ntheorem representative_arrow (Y : subobject X) : (representative.obj Y).arrow = Y.arrow :=\n  rfl\n#align representative_arrow representative_arrow\n\n",
 "pullback_map_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n@[simp]\ntheorem pullback_map_self [has_pullbacks C] (f : Â«expr âŸ¶ Â» X Y) [Mono f] (g : subobject X) :\n    (pullback f).obj ((map f).obj g) = g := by\n  revert g\n  apply quotient.ind\n  intro g'\n  apply quotient.sound\n  exact âŸ¨(mono_over.pullback_map_self f).app _âŸ©\n#align pullback_map_self pullback_map_self\n\n",
 "pullback_id":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\ntheorem pullback_id (x : subobject X) : (pullback ((Â«exprğŸ™Â») X)).obj x = x :=\n  by\n  apply Quotient.inductionOn' x\n  intro f\n  apply quotient.sound\n  exact âŸ¨mono_over.pullback_id.app fâŸ©\n#align pullback_id pullback_id\n\n",
 "pullback_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\ntheorem pullback_comp (f : Â«expr âŸ¶ Â» X Y) (g : Â«expr âŸ¶ Â» Y Z) (x : subobject Z) :\n    (pullback (Â«expr â‰« Â» f g)).obj x = (pullback f).obj ((pullback g).obj x) :=\n  by\n  apply Quotient.inductionOn' x\n  intro t\n  apply quotient.sound\n  refine' âŸ¨(mono_over.pullback_comp _ _).app tâŸ©\n#align pullback_comp pullback_comp\n\n",
 "of_mk_le_mk_refl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n@[simp]\ntheorem of_mk_le_mk_refl {B Aâ‚ : C} (f : Â«expr âŸ¶ Â» Aâ‚ B) [Mono f] : of_mk_le_mk f f le_rfl = (Â«exprğŸ™Â») _ :=\n  by\n  apply (cancel_mono f).mp\n  simp\n#align of_mk_le_mk_refl of_mk_le_mk_refl\n\n",
 "of_mk_le_mk_comp_of_mk_le_mk":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n@[simp, reassoc.1]\ntheorem of_mk_le_mk_comp_of_mk_le_mk {B Aâ‚ Aâ‚‚ Aâ‚ƒ : C} (f : Â«expr âŸ¶ Â» Aâ‚ B) [Mono f] (g : Â«expr âŸ¶ Â» Aâ‚‚ B) [Mono g]\n    (h : Â«expr âŸ¶ Â» Aâ‚ƒ B) [Mono h] (hâ‚ : mk f â‰¤ mk g) (hâ‚‚ : mk g â‰¤ mk h) :\n    Â«expr â‰« Â» (of_mk_le_mk f g hâ‚) (of_mk_le_mk g h hâ‚‚) = of_mk_le_mk f h (hâ‚.trans hâ‚‚) := by\n  simp [of_mk_le, of_le_mk, of_le, of_mk_le_mk, â† functor.map_comp_assoc underlying]\n#align of_mk_le_mk_comp_of_mk_le_mk of_mk_le_mk_comp_of_mk_le_mk\n\n",
 "of_mk_le_mk_comp_of_mk_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n@[simp, reassoc.1]\ntheorem of_mk_le_mk_comp_of_mk_le {B Aâ‚ Aâ‚‚ : C} (f : Â«expr âŸ¶ Â» Aâ‚ B) [Mono f] (g : Â«expr âŸ¶ Â» Aâ‚‚ B) [Mono g]\n    (X : subobject B) (hâ‚ : mk f â‰¤ mk g) (hâ‚‚ : mk g â‰¤ X) :\n    Â«expr â‰« Â» (of_mk_le_mk f g hâ‚) (of_mk_le g X hâ‚‚) = of_mk_le f X (hâ‚.trans hâ‚‚) := by\n  simp [of_mk_le, of_le_mk, of_le, of_mk_le_mk, â† functor.map_comp underlying]\n#align of_mk_le_mk_comp_of_mk_le of_mk_le_mk_comp_of_mk_le\n\n",
 "of_mk_le_mk_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n@[simp]\ntheorem of_mk_le_mk_comp {B Aâ‚ Aâ‚‚ : C} {f : Â«expr âŸ¶ Â» Aâ‚ B} {g : Â«expr âŸ¶ Â» Aâ‚‚ B} [Mono f] [Mono g] (h : mk f â‰¤ mk g) :\n    Â«expr â‰« Â» (of_mk_le_mk f g h) g = f := by simp [of_mk_le_mk]\n#align of_mk_le_mk_comp of_mk_le_mk_comp\n\n",
 "of_mk_le_comp_of_le_mk":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n@[simp, reassoc.1]\ntheorem of_mk_le_comp_of_le_mk {B Aâ‚ Aâ‚‚ : C} (f : Â«expr âŸ¶ Â» Aâ‚ B) [Mono f] (X : subobject B) (g : Â«expr âŸ¶ Â» Aâ‚‚ B)\n    [Mono g] (hâ‚ : mk f â‰¤ X) (hâ‚‚ : X â‰¤ mk g) :\n    Â«expr â‰« Â» (of_mk_le f X hâ‚) (of_le_mk X g hâ‚‚) = of_mk_le_mk f g (hâ‚.trans hâ‚‚) := by\n  simp [of_mk_le, of_le_mk, of_le, of_mk_le_mk, â† functor.map_comp_assoc underlying]\n#align of_mk_le_comp_of_le_mk of_mk_le_comp_of_le_mk\n\n",
 "of_mk_le_comp_of_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n@[simp, reassoc.1]\ntheorem of_mk_le_comp_of_le {B Aâ‚ : C} (f : Â«expr âŸ¶ Â» Aâ‚ B) [Mono f] (X Y : subobject B) (hâ‚ : mk f â‰¤ X) (hâ‚‚ : X â‰¤ Y) :\n    Â«expr â‰« Â» (of_mk_le f X hâ‚) (of_le X Y hâ‚‚) = of_mk_le f Y (hâ‚.trans hâ‚‚) := by\n  simp [of_mk_le, of_le_mk, of_le, of_mk_le_mk, â† functor.map_comp underlying]\n#align of_mk_le_comp_of_le of_mk_le_comp_of_le\n\n",
 "of_mk_le_arrow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n@[simp]\ntheorem of_mk_le_arrow {B A : C} {f : Â«expr âŸ¶ Â» A B} [Mono f] {X : subobject B} (h : mk f â‰¤ X) :\n    Â«expr â‰« Â» (of_mk_le f X h) X.arrow = f := by simp [of_mk_le]\n#align of_mk_le_arrow of_mk_le_arrow\n\n",
 "of_le_refl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n@[simp]\ntheorem of_le_refl {B : C} (X : subobject B) : of_le X X le_rfl = (Â«exprğŸ™Â») _ :=\n  by\n  apply (cancel_mono X.arrow).mp\n  simp\n#align of_le_refl of_le_refl\n\n",
 "of_le_mk_le_mk_of_comm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\ntheorem of_le_mk_le_mk_of_comm {B Aâ‚ Aâ‚‚ : C} {fâ‚ : Â«expr âŸ¶ Â» Aâ‚ B} {fâ‚‚ : Â«expr âŸ¶ Â» Aâ‚‚ B} [Mono fâ‚] [Mono fâ‚‚]\n    (g : Â«expr âŸ¶ Â» Aâ‚ Aâ‚‚) (w : Â«expr â‰« Â» g fâ‚‚ = fâ‚) :\n    of_le _ _ (mk_le_mk_of_comm g w) = Â«expr â‰« Â» (underlying_iso _).hom (Â«expr â‰« Â» g (underlying_iso _).inv) :=\n  by\n  ext\n  simp [w]\n#align of_le_mk_le_mk_of_comm of_le_mk_le_mk_of_comm\n\n",
 "of_le_mk_comp_of_mk_le_mk":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n@[simp, reassoc.1]\ntheorem of_le_mk_comp_of_mk_le_mk {B Aâ‚ Aâ‚‚ : C} (X : subobject B) (f : Â«expr âŸ¶ Â» Aâ‚ B) [Mono f] (g : Â«expr âŸ¶ Â» Aâ‚‚ B)\n    [Mono g] (hâ‚ : X â‰¤ mk f) (hâ‚‚ : mk f â‰¤ mk g) :\n    Â«expr â‰« Â» (of_le_mk X f hâ‚) (of_mk_le_mk f g hâ‚‚) = of_le_mk X g (hâ‚.trans hâ‚‚) := by\n  simp [of_mk_le, of_le_mk, of_le, of_mk_le_mk, â† functor.map_comp_assoc underlying]\n#align of_le_mk_comp_of_mk_le_mk of_le_mk_comp_of_mk_le_mk\n\n",
 "of_le_mk_comp_of_mk_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n@[simp, reassoc.1]\ntheorem of_le_mk_comp_of_mk_le {B A : C} (X : subobject B) (f : Â«expr âŸ¶ Â» A B) [Mono f] (Y : subobject B)\n    (hâ‚ : X â‰¤ mk f) (hâ‚‚ : mk f â‰¤ Y) : Â«expr â‰« Â» (of_le_mk X f hâ‚) (of_mk_le f Y hâ‚‚) = of_le X Y (hâ‚.trans hâ‚‚) := by\n  simp [of_mk_le, of_le_mk, of_le, â† functor.map_comp underlying]\n#align of_le_mk_comp_of_mk_le of_le_mk_comp_of_mk_le\n\n",
 "of_le_mk_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n@[simp]\ntheorem of_le_mk_comp {B A : C} {X : subobject B} {f : Â«expr âŸ¶ Â» A B} [Mono f] (h : X â‰¤ mk f) :\n    Â«expr â‰« Â» (of_le_mk X f h) f = X.arrow := by simp [of_le_mk]\n#align of_le_mk_comp of_le_mk_comp\n\n",
 "of_le_comp_of_le_mk":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n@[simp, reassoc.1]\ntheorem of_le_comp_of_le_mk {B A : C} (X Y : subobject B) (f : Â«expr âŸ¶ Â» A B) [Mono f] (hâ‚ : X â‰¤ Y) (hâ‚‚ : Y â‰¤ mk f) :\n    Â«expr â‰« Â» (of_le X Y hâ‚) (of_le_mk Y f hâ‚‚) = of_le_mk X f (hâ‚.trans hâ‚‚) := by\n  simp [of_mk_le, of_le_mk, of_le, â† functor.map_comp_assoc underlying]\n#align of_le_comp_of_le_mk of_le_comp_of_le_mk\n\n",
 "of_le_comp_of_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n@[simp, reassoc.1]\ntheorem of_le_comp_of_le {B : C} (X Y Z : subobject B) (hâ‚ : X â‰¤ Y) (hâ‚‚ : Y â‰¤ Z) :\n    Â«expr â‰« Â» (of_le X Y hâ‚) (of_le Y Z hâ‚‚) = of_le X Z (hâ‚.trans hâ‚‚) := by simp [of_le, â† functor.map_comp underlying]\n#align of_le_comp_of_le of_le_comp_of_le\n\n",
 "of_le_arrow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n-- We make `X` and `Y` explicit arguments here so that when `of_le` appears in goal statements\n-- it is possible to see its source and target\n-- (`h` will just display as `_`, because it is in `Prop`).\n@[simp, reassoc.1]\ntheorem of_le_arrow {B : C} {X Y : subobject B} (h : X â‰¤ Y) : Â«expr â‰« Â» (of_le X Y h) Y.arrow = X.arrow :=\n  underlying_arrow _\n#align of_le_arrow of_le_arrow\n\n",
 "mk_le_of_comm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\ntheorem mk_le_of_comm {B A : C} {X : subobject B} {f : Â«expr âŸ¶ Â» A B} [Mono f] (g : Â«expr âŸ¶ Â» A (X : C))\n    (w : Â«expr â‰« Â» g X.arrow = f) : mk f â‰¤ X :=\n  le_of_comm (Â«expr â‰« Â» (underlying_iso f).hom g) <| by simp [w]\n#align mk_le_of_comm mk_le_of_comm\n\n",
 "mk_le_mk_of_comm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\ntheorem mk_le_mk_of_comm {B Aâ‚ Aâ‚‚ : C} {fâ‚ : Â«expr âŸ¶ Â» Aâ‚ B} {fâ‚‚ : Â«expr âŸ¶ Â» Aâ‚‚ B} [Mono fâ‚] [Mono fâ‚‚]\n    (g : Â«expr âŸ¶ Â» Aâ‚ Aâ‚‚) (w : Â«expr â‰« Â» g fâ‚‚ = fâ‚) : mk fâ‚ â‰¤ mk fâ‚‚ :=\n  âŸ¨mono_over.hom_mk _ wâŸ©\n#align mk_le_mk_of_comm mk_le_mk_of_comm\n\n",
 "mk_eq_of_comm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰… Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/-- To show that two subobjects are equal, it suffices to exhibit an isomorphism commuting with\n    the arrows. -/\n@[ext]\ntheorem mk_eq_of_comm {B A : C} {X : subobject B} (f : Â«expr âŸ¶ Â» A B) [Mono f] (i : Â«expr â‰… Â» A (X : C))\n    (w : Â«expr â‰« Â» i.hom X.arrow = f) : mk f = X :=\n  eq.symm <| eq_mk_of_comm _ i.symm <| by rw [iso.symm_hom, iso.inv_comp_eq, w]\n#align mk_eq_of_comm mk_eq_of_comm\n\n",
 "mk_eq_mk_of_comm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰… Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/-- To show that two subobjects are equal, it suffices to exhibit an isomorphism commuting with\n    the arrows. -/\n@[ext]\ntheorem mk_eq_mk_of_comm {B Aâ‚ Aâ‚‚ : C} (f : Â«expr âŸ¶ Â» Aâ‚ B) (g : Â«expr âŸ¶ Â» Aâ‚‚ B) [Mono f] [Mono g] (i : Â«expr â‰… Â» Aâ‚ Aâ‚‚)\n    (w : Â«expr â‰« Â» i.hom g = f) : mk f = mk g :=\n  eq_mk_of_comm _ ((underlying_iso f).trans i) <| by simp [w]\n#align mk_eq_mk_of_comm mk_eq_mk_of_comm\n\n",
 "mk_arrow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰ªâ‰« Â» -/\n@[simp]\ntheorem mk_arrow (P : subobject X) : mk P.arrow = P :=\n  Quotient.inductionOn' P fun Q =>\n    by\n    obtain âŸ¨eâŸ© := @quotient.mk_out' _ (is_isomorphic_setoid _) Q\n    refine' quotient.sound' âŸ¨Â«expr â‰ªâ‰« Â» (mono_over.iso_mk _ _) eâŸ© <;> tidy\n#align mk_arrow mk_arrow\n\n",
 "map_pullback":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\ntheorem map_pullback [has_pullbacks C] {X Y Z W : C} {f : Â«expr âŸ¶ Â» X Y} {g : Â«expr âŸ¶ Â» X Z} {h : Â«expr âŸ¶ Â» Y W}\n    {k : Â«expr âŸ¶ Â» Z W} [Mono h] [Mono g] (comm : Â«expr â‰« Â» f h = Â«expr â‰« Â» g k)\n    (t : is_limit (pullback_cone.mk f g comm)) (p : subobject Y) :\n    (map g).obj ((pullback f).obj p) = (pullback k).obj ((map h).obj p) :=\n  by\n  revert p\n  apply quotient.ind'\n  intro a\n  apply quotient.sound\n  apply thin_skeleton.equiv_of_both_ways\n  Â· refine' mono_over.hom_mk (pullback.lift pullback.fst _ _) (pullback.lift_snd _ _ _)\n    change Â«expr â‰« Â» _ (Â«expr â‰« Â» a.arrow h) = Â«expr â‰« Â» (Â«expr â‰« Â» pullback.snd g) _\n    rw [assoc, â† comm, pullback.condition_assoc]\n  Â· refine'\n      mono_over.hom_mk\n        (pullback.lift pullback.fst (pullback_cone.is_limit.lift' t (Â«expr â‰« Â» pullback.fst a.arrow) pullback.snd _).1\n          (pullback_cone.is_limit.lift' _ _ _ _).2.1.symm)\n        _\n    Â· rw [â† pullback.condition, assoc]\n      rfl\n    Â· dsimp\n      rw [pullback.lift_snd_assoc]\n      apply (pullback_cone.is_limit.lift' _ _ _ _).2.2\n#align map_pullback map_pullback\n\n",
 "map_iso_to_order_iso_symm_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰… Â» -/\n@[simp]\ntheorem map_iso_to_order_iso_symm_apply (e : Â«expr â‰… Â» X Y) (Q : subobject Y) :\n    (map_iso_to_order_iso e).symm Q = (map e.inv).obj Q :=\n  rfl\n#align map_iso_to_order_iso_symm_apply map_iso_to_order_iso_symm_apply\n\n",
 "map_iso_to_order_iso_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰… Â» -/\n-- @[simps] here generates a lemma `map_iso_to_order_iso_to_equiv_symm_apply`\n-- whose left hand side is not in simp normal form.\n@[simp]\ntheorem map_iso_to_order_iso_apply (e : Â«expr â‰… Â» X Y) (P : subobject X) :\n    map_iso_to_order_iso e P = (map e.hom).obj P :=\n  rfl\n#align map_iso_to_order_iso_apply map_iso_to_order_iso_apply\n\n",
 "map_id":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\ntheorem map_id (x : subobject X) : (map ((Â«exprğŸ™Â») X)).obj x = x :=\n  by\n  apply Quotient.inductionOn' x\n  intro f\n  apply quotient.sound\n  exact âŸ¨mono_over.map_id.app fâŸ©\n#align map_id map_id\n\n",
 "map_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\ntheorem map_comp (f : Â«expr âŸ¶ Â» X Y) (g : Â«expr âŸ¶ Â» Y Z) [Mono f] [Mono g] (x : subobject X) :\n    (map (Â«expr â‰« Â» f g)).obj x = (map g).obj ((map f).obj x) :=\n  by\n  apply Quotient.inductionOn' x\n  intro t\n  apply quotient.sound\n  refine' âŸ¨(mono_over.map_comp _ _).app tâŸ©\n#align map_comp map_comp\n\n",
 "lower_iso":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰… Â» -/\n-- As with `of_le`, we have `X` and `Y` as explicit arguments for readability.\n/-- Isomorphic functors become equal when lowered to `subobject`.\n(It's not as evil as usual to talk about equality between functors\nbecause the categories are thin and skeletal.) -/\ntheorem lower_iso (Fâ‚ Fâ‚‚ : Â«expr â¥¤ Â» (mono_over X) (mono_over Y)) (h : Â«expr â‰… Â» Fâ‚ Fâ‚‚) : lower Fâ‚ = lower Fâ‚‚ :=\n  thin_skeleton.map_iso_eq h\n#align lower_iso lower_iso\n\n",
 "lower_comm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‹™ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‹™ Â» -/\n@[simp]\ntheorem lower_comm (F : Â«expr â¥¤ Â» (mono_over Y) (mono_over X)) :\n    Â«expr â‹™ Â» (to_thin_skeleton _) (lower F) = Â«expr â‹™ Â» F (to_thin_skeleton _) :=\n  rfl\n#align lower_comm lower_comm\n\n",
 "lift_mk":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n@[simp]\nprotected theorem lift_mk {Î± : Sort _} {X : C} (F : âˆ€ â¦ƒA : Câ¦„ (f : Â«expr âŸ¶ Â» A X) [Mono f], Î±) {h A} (f : Â«expr âŸ¶ Â» A X)\n    [Mono f] : subobject.lift F h (subobject.mk f) = F f :=\n  rfl\n#align lift_mk lift_mk\n\n",
 "le_of_comm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\ntheorem le_of_comm {B : C} {X Y : subobject B} (f : Â«expr âŸ¶ Â» (X : C) (Y : C)) (w : Â«expr â‰« Â» f Y.arrow = X.arrow) :\n    X â‰¤ Y := by convert mk_le_mk_of_comm _ w <;> simp\n#align le_of_comm le_of_comm\n\n",
 "le_mk_of_comm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\ntheorem le_mk_of_comm {B A : C} {X : subobject B} {f : Â«expr âŸ¶ Â» A B} [Mono f] (g : Â«expr âŸ¶ Â» (X : C) A)\n    (w : Â«expr â‰« Â» g f = X.arrow) : X â‰¤ mk f :=\n  le_of_comm (Â«expr â‰« Â» g (underlying_iso f).inv) <| by simp [w]\n#align le_mk_of_comm le_mk_of_comm\n\n",
 "indâ‚‚":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\nprotected theorem indâ‚‚ {X : C} (p : subobject X â†’ subobject X â†’ Prop)\n    (h : âˆ€ â¦ƒA B : Câ¦„ (f : Â«expr âŸ¶ Â» A X) (g : Â«expr âŸ¶ Â» B X) [Mono f] [Mono g], p (subobject.mk f) (subobject.mk g))\n    (P Q : subobject X) : p P Q := by\n  apply Quotient.inductionOnâ‚‚'\n  intro a b\n  convert h a.arrow b.arrow <;> ext <;> rfl\n#align indâ‚‚ indâ‚‚\n\n",
 "ind":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/-\nCopyright (c) 2020 Bhavik Mehta. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Bhavik Mehta, Scott Morrison\n-/\nprotected theorem ind {X : C} (p : subobject X â†’ Prop) (h : âˆ€ â¦ƒA : Câ¦„ (f : Â«expr âŸ¶ Â» A X) [Mono f], p (subobject.mk f))\n    (P : subobject X) : p P := by\n  apply Quotient.inductionOn'\n  intro a\n  convert h a.arrow\n  ext <;> rfl\n#align ind ind\n\n",
 "exists_iso_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/-- When `f : X âŸ¶ Y` is a monomorphism, `exists f` agrees with `map f`.\n-/\ntheorem exists_iso_map (f : Â«expr âŸ¶ Â» X Y) [Mono f] : exists f = map f :=\n  lower_iso _ _ (mono_over.exists_iso_map f)\n#align exists_iso_map exists_iso_map\n\n",
 "eq_of_comp_arrow_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/-- Two morphisms into a subobject are equal exactly if\nthe morphisms into the ambient object are equal -/\n@[ext]\ntheorem eq_of_comp_arrow_eq {X Y : C} {P : subobject Y} {f g : Â«expr âŸ¶ Â» X P}\n    (h : Â«expr â‰« Â» f P.arrow = Â«expr â‰« Â» g P.arrow) : f = g :=\n  (cancel_mono P.arrow).mp h\n#align eq_of_comp_arrow_eq eq_of_comp_arrow_eq\n\n",
 "eq_of_comm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰… Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/-- To show that two subobjects are equal, it suffices to exhibit an isomorphism commuting with\n    the arrows. -/\n@[ext]\ntheorem eq_of_comm {B : C} {X Y : subobject B} (f : Â«expr â‰… Â» (X : C) (Y : C)) (w : Â«expr â‰« Â» f.hom Y.arrow = X.arrow) :\n    X = Y :=\n  le_antisymm (le_of_comm f.hom w) <| le_of_comm f.inv <| f.inv_comp_eq.2 w.symm\n#align eq_of_comm eq_of_comm\n\n",
 "eq_mk_of_comm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰… Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/-- To show that two subobjects are equal, it suffices to exhibit an isomorphism commuting with\n    the arrows. -/\n@[ext]\ntheorem eq_mk_of_comm {B A : C} {X : subobject B} (f : Â«expr âŸ¶ Â» A B) [Mono f] (i : Â«expr â‰… Â» (X : C) A)\n    (w : Â«expr â‰« Â» i.hom f = X.arrow) : X = mk f :=\n  eq_of_comm (i.trans (underlying_iso f).symm) <| by simp [w]\n#align eq_mk_of_comm eq_mk_of_comm\n\n",
 "arrow_congr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n@[simp]\ntheorem arrow_congr {A : C} (X Y : subobject A) (h : X = Y) :\n    Â«expr â‰« Â» (eq_to_hom (congr_arg (fun X : subobject A => (X : C)) h)) Y.arrow = X.arrow :=\n  by\n  induction h\n  simp\n#align arrow_congr arrow_congr\n\n"}