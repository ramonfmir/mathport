{"underlying_iso_hom_comp_eq_mk":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem underlying_iso_hom_comp_eq_mk {X Y : C} (f : «expr ⟶ » X Y) [Mono f] :\n    «expr ≫ » (underlyingIso f).hom f = (mk f).arrow :=\n  (Iso.eq_inv_comp _).1 (underlyingIso_arrow f).symm\n#align underlying_iso_hom_comp_eq_mk underlying_iso_hom_comp_eq_mk\n\n",
 "underlying_iso_arrow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1, elementwise]\ntheorem underlying_iso_arrow {X Y : C} (f : «expr ⟶ » X Y) [Mono f] :\n    «expr ≫ » (underlyingIso f).inv (Subobject.mk f).arrow = f :=\n  Over.w _\n#align underlying_iso_arrow underlying_iso_arrow\n\n",
 "underlying_as_coe":
 "@[simp]\ntheorem underlying_as_coe {X : C} (P : Subobject X) : underlying.obj P = P :=\n  rfl\n#align underlying_as_coe underlying_as_coe\n\n",
 "underlying_arrow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem underlying_arrow {X : C} {Y Z : Subobject X} (f : «expr ⟶ » Y Z) :\n    «expr ≫ » (underlying.map f) (arrow Z) = arrow Y :=\n  Over.w (representative.map f)\n#align underlying_arrow underlying_arrow\n\n",
 "representative_coe":
 "@[simp]\ntheorem representative_coe (Y : Subobject X) : (representative.obj Y : C) = (Y : C) :=\n  rfl\n#align representative_coe representative_coe\n\n",
 "representative_arrow":
 "@[simp]\ntheorem representative_arrow (Y : Subobject X) : (representative.obj Y).arrow = Y.arrow :=\n  rfl\n#align representative_arrow representative_arrow\n\n",
 "pullback_map_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n@[simp]\ntheorem pullback_map_self [HasPullbacks C] (f : «expr ⟶ » X Y) [Mono f] (g : Subobject X) :\n    (pullback f).obj ((map f).obj g) = g := by\n  revert g\n  apply quotient.ind\n  intro g'\n  apply quotient.sound\n  exact ⟨(mono_over.pullback_map_self f).app _⟩\n#align pullback_map_self pullback_map_self\n\n",
 "pullback_id":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\ntheorem pullback_id (x : Subobject X) : (pullback ((«expr𝟙») X)).obj x = x :=\n  by\n  apply Quotient.inductionOn' x\n  intro f\n  apply quotient.sound\n  exact ⟨mono_over.pullback_id.app f⟩\n#align pullback_id pullback_id\n\n",
 "pullback_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem pullback_comp (f : «expr ⟶ » X Y) (g : «expr ⟶ » Y Z) (x : Subobject Z) :\n    (pullback («expr ≫ » f g)).obj x = (pullback f).obj ((pullback g).obj x) :=\n  by\n  apply Quotient.inductionOn' x\n  intro t\n  apply quotient.sound\n  refine' ⟨(mono_over.pullback_comp _ _).app t⟩\n#align pullback_comp pullback_comp\n\n",
 "of_mk_le_mk_refl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n@[simp]\ntheorem of_mk_le_mk_refl {B A₁ : C} (f : «expr ⟶ » A₁ B) [Mono f] : ofMkLEMk f f le_rfl = («expr𝟙») _ :=\n  by\n  apply (cancel_mono f).mp\n  simp\n#align of_mk_le_mk_refl of_mk_le_mk_refl\n\n",
 "of_mk_le_mk_comp_of_mk_le_mk":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem of_mk_le_mk_comp_of_mk_le_mk {B A₁ A₂ A₃ : C} (f : «expr ⟶ » A₁ B) [Mono f] (g : «expr ⟶ » A₂ B) [Mono g]\n    (h : «expr ⟶ » A₃ B) [Mono h] (h₁ : mk f ≤ mk g) (h₂ : mk g ≤ mk h) :\n    «expr ≫ » (ofMkLEMk f g h₁) (ofMkLEMk g h h₂) = ofMkLEMk f h (h₁.trans h₂) := by\n  simp [of_mk_le, of_le_mk, of_le, of_mk_le_mk, ← functor.map_comp_assoc underlying]\n#align of_mk_le_mk_comp_of_mk_le_mk of_mk_le_mk_comp_of_mk_le_mk\n\n",
 "of_mk_le_mk_comp_of_mk_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem of_mk_le_mk_comp_of_mk_le {B A₁ A₂ : C} (f : «expr ⟶ » A₁ B) [Mono f] (g : «expr ⟶ » A₂ B) [Mono g]\n    (X : Subobject B) (h₁ : mk f ≤ mk g) (h₂ : mk g ≤ X) :\n    «expr ≫ » (ofMkLEMk f g h₁) (ofMkLE g X h₂) = ofMkLE f X (h₁.trans h₂) := by\n  simp [of_mk_le, of_le_mk, of_le, of_mk_le_mk, ← functor.map_comp underlying]\n#align of_mk_le_mk_comp_of_mk_le of_mk_le_mk_comp_of_mk_le\n\n",
 "of_mk_le_mk_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp]\ntheorem of_mk_le_mk_comp {B A₁ A₂ : C} {f : «expr ⟶ » A₁ B} {g : «expr ⟶ » A₂ B} [Mono f] [Mono g] (h : mk f ≤ mk g) :\n    «expr ≫ » (ofMkLEMk f g h) g = f := by simp [of_mk_le_mk]\n#align of_mk_le_mk_comp of_mk_le_mk_comp\n\n",
 "of_mk_le_comp_of_le_mk":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem of_mk_le_comp_of_le_mk {B A₁ A₂ : C} (f : «expr ⟶ » A₁ B) [Mono f] (X : Subobject B) (g : «expr ⟶ » A₂ B)\n    [Mono g] (h₁ : mk f ≤ X) (h₂ : X ≤ mk g) : «expr ≫ » (ofMkLE f X h₁) (ofLEMk X g h₂) = ofMkLEMk f g (h₁.trans h₂) :=\n  by simp [of_mk_le, of_le_mk, of_le, of_mk_le_mk, ← functor.map_comp_assoc underlying]\n#align of_mk_le_comp_of_le_mk of_mk_le_comp_of_le_mk\n\n",
 "of_mk_le_comp_of_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem of_mk_le_comp_of_le {B A₁ : C} (f : «expr ⟶ » A₁ B) [Mono f] (X Y : Subobject B) (h₁ : mk f ≤ X) (h₂ : X ≤ Y) :\n    «expr ≫ » (ofMkLE f X h₁) (ofLE X Y h₂) = ofMkLE f Y (h₁.trans h₂) := by\n  simp [of_mk_le, of_le_mk, of_le, of_mk_le_mk, ← functor.map_comp underlying]\n#align of_mk_le_comp_of_le of_mk_le_comp_of_le\n\n",
 "of_mk_le_arrow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp]\ntheorem of_mk_le_arrow {B A : C} {f : «expr ⟶ » A B} [Mono f] {X : Subobject B} (h : mk f ≤ X) :\n    «expr ≫ » (ofMkLE f X h) X.arrow = f := by simp [of_mk_le]\n#align of_mk_le_arrow of_mk_le_arrow\n\n",
 "of_le_refl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n@[simp]\ntheorem of_le_refl {B : C} (X : Subobject B) : ofLE X X le_rfl = («expr𝟙») _ :=\n  by\n  apply (cancel_mono X.arrow).mp\n  simp\n#align of_le_refl of_le_refl\n\n",
 "of_le_mk_le_mk_of_comm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem of_le_mk_le_mk_of_comm {B A₁ A₂ : C} {f₁ : «expr ⟶ » A₁ B} {f₂ : «expr ⟶ » A₂ B} [Mono f₁] [Mono f₂]\n    (g : «expr ⟶ » A₁ A₂) (w : «expr ≫ » g f₂ = f₁) :\n    ofLE _ _ (mk_le_mk_of_comm g w) = «expr ≫ » (underlyingIso _).hom («expr ≫ » g (underlyingIso _).inv) :=\n  by\n  ext\n  simp [w]\n#align of_le_mk_le_mk_of_comm of_le_mk_le_mk_of_comm\n\n",
 "of_le_mk_comp_of_mk_le_mk":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem of_le_mk_comp_of_mk_le_mk {B A₁ A₂ : C} (X : Subobject B) (f : «expr ⟶ » A₁ B) [Mono f] (g : «expr ⟶ » A₂ B)\n    [Mono g] (h₁ : X ≤ mk f) (h₂ : mk f ≤ mk g) :\n    «expr ≫ » (ofLEMk X f h₁) (ofMkLEMk f g h₂) = ofLEMk X g (h₁.trans h₂) := by\n  simp [of_mk_le, of_le_mk, of_le, of_mk_le_mk, ← functor.map_comp_assoc underlying]\n#align of_le_mk_comp_of_mk_le_mk of_le_mk_comp_of_mk_le_mk\n\n",
 "of_le_mk_comp_of_mk_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem of_le_mk_comp_of_mk_le {B A : C} (X : Subobject B) (f : «expr ⟶ » A B) [Mono f] (Y : Subobject B)\n    (h₁ : X ≤ mk f) (h₂ : mk f ≤ Y) : «expr ≫ » (ofLEMk X f h₁) (ofMkLE f Y h₂) = ofLE X Y (h₁.trans h₂) := by\n  simp [of_mk_le, of_le_mk, of_le, ← functor.map_comp underlying]\n#align of_le_mk_comp_of_mk_le of_le_mk_comp_of_mk_le\n\n",
 "of_le_mk_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp]\ntheorem of_le_mk_comp {B A : C} {X : Subobject B} {f : «expr ⟶ » A B} [Mono f] (h : X ≤ mk f) :\n    «expr ≫ » (ofLEMk X f h) f = X.arrow := by simp [of_le_mk]\n#align of_le_mk_comp of_le_mk_comp\n\n",
 "of_le_comp_of_le_mk":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem of_le_comp_of_le_mk {B A : C} (X Y : Subobject B) (f : «expr ⟶ » A B) [Mono f] (h₁ : X ≤ Y) (h₂ : Y ≤ mk f) :\n    «expr ≫ » (ofLE X Y h₁) (ofLEMk Y f h₂) = ofLEMk X f (h₁.trans h₂) := by\n  simp [of_mk_le, of_le_mk, of_le, ← functor.map_comp_assoc underlying]\n#align of_le_comp_of_le_mk of_le_comp_of_le_mk\n\n",
 "of_le_comp_of_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem of_le_comp_of_le {B : C} (X Y Z : Subobject B) (h₁ : X ≤ Y) (h₂ : Y ≤ Z) :\n    «expr ≫ » (ofLE X Y h₁) (ofLE Y Z h₂) = ofLE X Z (h₁.trans h₂) := by simp [of_le, ← functor.map_comp underlying]\n#align of_le_comp_of_le of_le_comp_of_le\n\n",
 "of_le_arrow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n-- We make `X` and `Y` explicit arguments here so that when `of_le` appears in goal statements\n-- it is possible to see its source and target\n-- (`h` will just display as `_`, because it is in `Prop`).\n@[simp, reassoc.1]\ntheorem of_le_arrow {B : C} {X Y : Subobject B} (h : X ≤ Y) : «expr ≫ » (ofLE X Y h) Y.arrow = X.arrow :=\n  underlying_arrow _\n#align of_le_arrow of_le_arrow\n\n",
 "mk_le_of_comm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem mk_le_of_comm {B A : C} {X : Subobject B} {f : «expr ⟶ » A B} [Mono f] (g : «expr ⟶ » A (X : C))\n    (w : «expr ≫ » g X.arrow = f) : mk f ≤ X :=\n  le_of_comm («expr ≫ » (underlyingIso f).hom g) <| by simp [w]\n#align mk_le_of_comm mk_le_of_comm\n\n",
 "mk_le_mk_of_comm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem mk_le_mk_of_comm {B A₁ A₂ : C} {f₁ : «expr ⟶ » A₁ B} {f₂ : «expr ⟶ » A₂ B} [Mono f₁] [Mono f₂]\n    (g : «expr ⟶ » A₁ A₂) (w : «expr ≫ » g f₂ = f₁) : mk f₁ ≤ mk f₂ :=\n  ⟨MonoOver.homMk _ w⟩\n#align mk_le_mk_of_comm mk_le_mk_of_comm\n\n",
 "mk_eq_of_comm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≅ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/-- To show that two subobjects are equal, it suffices to exhibit an isomorphism commuting with\n    the arrows. -/\n@[ext]\ntheorem mk_eq_of_comm {B A : C} {X : Subobject B} (f : «expr ⟶ » A B) [Mono f] (i : «expr ≅ » A (X : C))\n    (w : «expr ≫ » i.hom X.arrow = f) : mk f = X :=\n  Eq.symm <| eq_mk_of_comm _ i.symm <| by rw [iso.symm_hom, iso.inv_comp_eq, w]\n#align mk_eq_of_comm mk_eq_of_comm\n\n",
 "mk_eq_mk_of_comm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≅ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/-- To show that two subobjects are equal, it suffices to exhibit an isomorphism commuting with\n    the arrows. -/\n@[ext]\ntheorem mk_eq_mk_of_comm {B A₁ A₂ : C} (f : «expr ⟶ » A₁ B) (g : «expr ⟶ » A₂ B) [Mono f] [Mono g] (i : «expr ≅ » A₁ A₂)\n    (w : «expr ≫ » i.hom g = f) : mk f = mk g :=\n  eq_mk_of_comm _ ((underlyingIso f).trans i) <| by simp [w]\n#align mk_eq_mk_of_comm mk_eq_mk_of_comm\n\n",
 "mk_arrow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≪≫ » -/\n@[simp]\ntheorem mk_arrow (P : Subobject X) : mk P.arrow = P :=\n  Quotient.inductionOn' P fun Q =>\n    by\n    obtain ⟨e⟩ := @Quotient.mk_out' _ (is_isomorphic_setoid _) Q\n    refine' Quotient.sound' ⟨«expr ≪≫ » (mono_over.iso_mk _ _) e⟩ <;> tidy\n#align mk_arrow mk_arrow\n\n",
 "map_pullback":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem map_pullback [HasPullbacks C] {X Y Z W : C} {f : «expr ⟶ » X Y} {g : «expr ⟶ » X Z} {h : «expr ⟶ » Y W}\n    {k : «expr ⟶ » Z W} [Mono h] [Mono g] (comm : «expr ≫ » f h = «expr ≫ » g k)\n    (t : IsLimit (PullbackCone.mk f g comm)) (p : Subobject Y) :\n    (map g).obj ((pullback f).obj p) = (pullback k).obj ((map h).obj p) :=\n  by\n  revert p\n  apply Quotient.ind'\n  intro a\n  apply quotient.sound\n  apply thin_skeleton.equiv_of_both_ways\n  · refine' mono_over.hom_mk (pullback.lift pullback.fst _ _) (pullback.lift_snd _ _ _)\n    change «expr ≫ » _ («expr ≫ » a.arrow h) = «expr ≫ » («expr ≫ » pullback.snd g) _\n    rw [assoc, ← comm, pullback.condition_assoc]\n  · refine'\n      mono_over.hom_mk\n        (pullback.lift pullback.fst (pullback_cone.is_limit.lift' t («expr ≫ » pullback.fst a.arrow) pullback.snd _).1\n          (pullback_cone.is_limit.lift' _ _ _ _).2.1.symm)\n        _\n    · rw [← pullback.condition, assoc]\n      rfl\n    · dsimp\n      rw [pullback.lift_snd_assoc]\n      apply (pullback_cone.is_limit.lift' _ _ _ _).2.2\n#align map_pullback map_pullback\n\n",
 "map_iso_to_order_iso_symm_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≅ » -/\n@[simp]\ntheorem map_iso_to_order_iso_symm_apply (e : «expr ≅ » X Y) (Q : Subobject Y) :\n    (mapIsoToOrderIso e).symm Q = (map e.inv).obj Q :=\n  rfl\n#align map_iso_to_order_iso_symm_apply map_iso_to_order_iso_symm_apply\n\n",
 "map_iso_to_order_iso_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≅ » -/\n-- @[simps] here generates a lemma `map_iso_to_order_iso_to_equiv_symm_apply`\n-- whose left hand side is not in simp normal form.\n@[simp]\ntheorem map_iso_to_order_iso_apply (e : «expr ≅ » X Y) (P : Subobject X) : mapIsoToOrderIso e P = (map e.hom).obj P :=\n  rfl\n#align map_iso_to_order_iso_apply map_iso_to_order_iso_apply\n\n",
 "map_id":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\ntheorem map_id (x : Subobject X) : (map ((«expr𝟙») X)).obj x = x :=\n  by\n  apply Quotient.inductionOn' x\n  intro f\n  apply quotient.sound\n  exact ⟨mono_over.map_id.app f⟩\n#align map_id map_id\n\n",
 "map_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem map_comp (f : «expr ⟶ » X Y) (g : «expr ⟶ » Y Z) [Mono f] [Mono g] (x : Subobject X) :\n    (map («expr ≫ » f g)).obj x = (map g).obj ((map f).obj x) :=\n  by\n  apply Quotient.inductionOn' x\n  intro t\n  apply quotient.sound\n  refine' ⟨(mono_over.map_comp _ _).app t⟩\n#align map_comp map_comp\n\n",
 "lower_iso":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≅ » -/\n-- As with `of_le`, we have `X` and `Y` as explicit arguments for readability.\n/-- Isomorphic functors become equal when lowered to `subobject`.\n(It's not as evil as usual to talk about equality between functors\nbecause the categories are thin and skeletal.) -/\ntheorem lower_iso (F₁ F₂ : «expr ⥤ » (MonoOver X) (MonoOver Y)) (h : «expr ≅ » F₁ F₂) : lower F₁ = lower F₂ :=\n  ThinSkeleton.map_iso_eq h\n#align lower_iso lower_iso\n\n",
 "lower_comm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n@[simp]\ntheorem lower_comm (F : «expr ⥤ » (MonoOver Y) (MonoOver X)) :\n    «expr ⋙ » (toThinSkeleton _) (lower F) = «expr ⋙ » F (toThinSkeleton _) :=\n  rfl\n#align lower_comm lower_comm\n\n",
 "lift_mk":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n@[simp]\nprotected theorem lift_mk {α : Sort _} {X : C} (F : ∀ ⦃A : C⦄ (f : «expr ⟶ » A X) [Mono f], α) {h A} (f : «expr ⟶ » A X)\n    [Mono f] : Subobject.lift F h (Subobject.mk f) = F f :=\n  rfl\n#align lift_mk lift_mk\n\n",
 "le_of_comm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem le_of_comm {B : C} {X Y : Subobject B} (f : «expr ⟶ » (X : C) (Y : C)) (w : «expr ≫ » f Y.arrow = X.arrow) :\n    X ≤ Y := by convert mk_le_mk_of_comm _ w <;> simp\n#align le_of_comm le_of_comm\n\n",
 "le_mk_of_comm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem le_mk_of_comm {B A : C} {X : Subobject B} {f : «expr ⟶ » A B} [Mono f] (g : «expr ⟶ » (X : C) A)\n    (w : «expr ≫ » g f = X.arrow) : X ≤ mk f :=\n  le_of_comm («expr ≫ » g (underlyingIso f).inv) <| by simp [w]\n#align le_mk_of_comm le_mk_of_comm\n\n",
 "ind₂":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\nprotected theorem ind₂ {X : C} (p : Subobject X → Subobject X → Prop)\n    (h : ∀ ⦃A B : C⦄ (f : «expr ⟶ » A X) (g : «expr ⟶ » B X) [Mono f] [Mono g], p (subobject.mk f) (subobject.mk g))\n    (P Q : Subobject X) : p P Q := by\n  apply Quotient.inductionOn₂'\n  intro a b\n  convert h a.arrow b.arrow <;> ext <;> rfl\n#align ind₂ ind₂\n\n",
 "ind":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/-\nCopyright (c) 2020 Bhavik Mehta. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Bhavik Mehta, Scott Morrison\n-/\nprotected theorem ind {X : C} (p : Subobject X → Prop) (h : ∀ ⦃A : C⦄ (f : «expr ⟶ » A X) [Mono f], p (subobject.mk f))\n    (P : Subobject X) : p P := by\n  apply Quotient.inductionOn'\n  intro a\n  convert h a.arrow\n  ext <;> rfl\n#align ind ind\n\n",
 "exists_iso_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/-- When `f : X ⟶ Y` is a monomorphism, `exists f` agrees with `map f`.\n-/\ntheorem exists_iso_map (f : «expr ⟶ » X Y) [Mono f] : exists f = map f :=\n  lower_iso _ _ (MonoOver.existsIsoMap f)\n#align exists_iso_map exists_iso_map\n\n",
 "eq_of_comp_arrow_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/-- Two morphisms into a subobject are equal exactly if\nthe morphisms into the ambient object are equal -/\n@[ext]\ntheorem eq_of_comp_arrow_eq {X Y : C} {P : Subobject Y} {f g : «expr ⟶ » X P}\n    (h : «expr ≫ » f P.arrow = «expr ≫ » g P.arrow) : f = g :=\n  (cancel_mono P.arrow).mp h\n#align eq_of_comp_arrow_eq eq_of_comp_arrow_eq\n\n",
 "eq_of_comm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≅ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/-- To show that two subobjects are equal, it suffices to exhibit an isomorphism commuting with\n    the arrows. -/\n@[ext]\ntheorem eq_of_comm {B : C} {X Y : Subobject B} (f : «expr ≅ » (X : C) (Y : C)) (w : «expr ≫ » f.hom Y.arrow = X.arrow) :\n    X = Y :=\n  le_antisymm (le_of_comm f.hom w) <| le_of_comm f.inv <| f.inv_comp_eq.2 w.symm\n#align eq_of_comm eq_of_comm\n\n",
 "eq_mk_of_comm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≅ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/-- To show that two subobjects are equal, it suffices to exhibit an isomorphism commuting with\n    the arrows. -/\n@[ext]\ntheorem eq_mk_of_comm {B A : C} {X : Subobject B} (f : «expr ⟶ » A B) [Mono f] (i : «expr ≅ » (X : C) A)\n    (w : «expr ≫ » i.hom f = X.arrow) : X = mk f :=\n  eq_of_comm (i.trans (underlyingIso f).symm) <| by simp [w]\n#align eq_mk_of_comm eq_mk_of_comm\n\n",
 "arrow_congr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp]\ntheorem arrow_congr {A : C} (X Y : Subobject A) (h : X = Y) :\n    «expr ≫ » (eqToHom (congr_arg (fun X : Subobject A => (X : C)) h)) Y.arrow = X.arrow :=\n  by\n  induction h\n  simp\n#align arrow_congr arrow_congr\n\n"}