{"unop_left_comp_underlying_iso_hom_unop":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵖ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/-- Technical lemma for `lift_project_quotient`. -/\n@[simp]\ntheorem unop_left_comp_underlying_iso_hom_unop {A : CostructuredArrow S T} {P : «expr ᵒᵖ» (CostructuredArrow S T)}\n    (f : «expr ⟶ » P (op A)) [Mono f.unop.left.op] :\n    «expr ≫ » f.unop.left (Subobject.underlyingIso f.unop.left.op).hom.unop =\n      (Subobject.mk f.unop.left.op).arrow.unop :=\n  by\n  conv_lhs =>\n    congr\n    rw [← Quiver.Hom.unop_op f.unop.left]\n  rw [← unop_comp, subobject.underlying_iso_hom_comp_eq_mk]\n#align unop_left_comp_underlying_iso_hom_unop unop_left_comp_underlying_iso_hom_unop\n\n",
 "unop_left_comp_of_mk_le_mk_unop":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵖ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/-- Technical lemma for `quotient_equiv`. -/\ntheorem unop_left_comp_of_mk_le_mk_unop {A : CostructuredArrow S T} {P Q : «expr ᵒᵖ» (CostructuredArrow S T)}\n    {f : «expr ⟶ » P (op A)} {g : «expr ⟶ » Q (op A)} [Mono f.unop.left.op] [Mono g.unop.left.op]\n    (h : Subobject.mk f.unop.left.op ≤ Subobject.mk g.unop.left.op) :\n    «expr ≫ » g.unop.left (Subobject.ofMkLEMk f.unop.left.op g.unop.left.op h).unop = f.unop.left :=\n  by\n  conv_lhs =>\n    congr\n    rw [← Quiver.Hom.unop_op g.unop.left]\n  rw [← unop_comp]\n  simp only [subobject.of_mk_le_mk_comp, Quiver.Hom.unop_op]\n#align unop_left_comp_of_mk_le_mk_unop unop_left_comp_of_mk_le_mk_unop\n\n",
 "project_subobject_mk":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/-\nCopyright (c) 2022 Markus Himmel. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Markus Himmel\n-/\n@[simp]\ntheorem project_subobject_mk [HasLimits C] [PreservesLimits T] {A P : StructuredArrow S T} (f : «expr ⟶ » P A)\n    [Mono f] : projectSubobject (Subobject.mk f) = Subobject.mk f.right :=\n  rfl\n#align project_subobject_mk project_subobject_mk\n\n",
 "project_subobject_factors":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem project_subobject_factors [HasLimits C] [PreservesLimits T] {A : StructuredArrow S T} :\n    ∀ P : Subobject A, ∃ q, «expr ≫ » q (T.map (projectSubobject P).arrow) = A.hom :=\n  Subobject.ind _ fun P f hf =>\n    ⟨«expr ≫ » P.hom (T.map (Subobject.underlyingIso _).inv),\n      by\n      dsimp\n      simp [← T.map_comp]⟩\n#align project_subobject_factors project_subobject_factors\n\n",
 "project_quotient_mk":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵖ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n@[simp]\ntheorem project_quotient_mk [HasColimits C] [PreservesColimits S] {A : CostructuredArrow S T}\n    {P : «expr ᵒᵖ» (CostructuredArrow S T)} (f : «expr ⟶ » P (op A)) [Mono f] :\n    projectQuotient (Subobject.mk f) = Subobject.mk f.unop.left.op :=\n  rfl\n#align project_quotient_mk project_quotient_mk\n\n",
 "project_quotient_factors":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem project_quotient_factors [HasColimits C] [PreservesColimits S] {A : CostructuredArrow S T} :\n    ∀ P : Subobject (op A), ∃ q, «expr ≫ » (S.map (projectQuotient P).arrow.unop) q = A.hom :=\n  Subobject.ind _ fun P f hf =>\n    ⟨«expr ≫ » (S.map (Subobject.underlyingIso _).unop.inv) P.unop.hom,\n      by\n      dsimp\n      rw [← category.assoc, ← S.map_comp, ← unop_comp]\n      simp⟩\n#align project_quotient_factors project_quotient_factors\n\n",
 "lift_project_subobject":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/-- Projecting and then lifting a subobject recovers the original subobject, because there is at\n    most one morphism making the projected subobject into a structured arrow. -/\ntheorem lift_project_subobject [HasLimits C] [PreservesLimits T] {A : StructuredArrow S T} :\n    ∀ (P : Subobject A) {q} (hq : «expr ≫ » q (T.map (projectSubobject P).arrow) = A.hom),\n      liftSubobject (projectSubobject P) hq = P :=\n  Subobject.ind _\n    (by\n      intro P f hf q hq\n      fapply subobject.mk_eq_mk_of_comm\n      · fapply iso_mk\n        · exact subobject.underlying_iso _\n        ·\n          exact\n            (cancel_mono (T.map f.right)).1\n              (by\n                dsimp\n                simpa [← T.map_comp] using hq)\n      ·\n        exact\n          ext _ _\n            (by\n              dsimp\n              simp))\n#align lift_project_subobject lift_project_subobject\n\n",
 "lift_project_quotient":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≅ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/-- Projecting and then lifting a quotient recovers the original quotient, because there is at most\n    one morphism making the projected quotient into a costructured arrow. -/\ntheorem lift_project_quotient [HasColimits C] [PreservesColimits S] {A : CostructuredArrow S T} :\n    ∀ (P : Subobject (op A)) {q} (hq : «expr ≫ » (S.map (projectQuotient P).arrow.unop) q = A.hom),\n      liftQuotient (projectQuotient P) hq = P :=\n  Subobject.ind _\n    (by\n      intro P f hf q hq\n      fapply subobject.mk_eq_mk_of_comm\n      · refine' (iso.op (iso_mk _ _) : «expr ≅ » _ (op (unop P)))\n        · exact (subobject.underlying_iso f.unop.left.op).unop\n        · refine' (cancel_epi (S.map f.unop.left)).1 _\n          simpa [← category.assoc, ← S.map_comp] using hq\n      ·\n        exact\n          Quiver.Hom.unop_inj\n            (ext _ _\n              (by\n                dsimp\n                simp)))\n#align lift_project_quotient lift_project_quotient\n\n"}