{"mk_factors_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem mk_factors_self (f : Â«expr âŸ¶ Â» X Y) [Mono f] : (mk f).factors f :=\n  âŸ¨(Â«exprğŸ™Â») _, by simpâŸ©\n#align mk_factors_self mk_factors_self\n\n",
 "mk_factors_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n@[simp]\ntheorem mk_factors_iff {X Y Z : C} (f : Â«expr âŸ¶ Â» Y X) [Mono f] (g : Â«expr âŸ¶ Â» Z X) :\n    (subobject.mk f).factors g â†” (mono_over.mk' f).factors g :=\n  iff.rfl\n#align mk_factors_iff mk_factors_iff\n\n",
 "factors_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem factors_zero [has_zero_morphisms C] {X Y : C} {P : subobject Y} : P.factors (0 : Â«expr âŸ¶ Â» X Y) :=\n  (factors_iff _ _).mpr âŸ¨0, by simpâŸ©\n#align factors_zero factors_zero\n\n",
 "factors_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\ntheorem factors_self {X : C} (P : subobject X) : P.factors P.arrow :=\n  (factors_iff _ _).mpr âŸ¨(Â«exprğŸ™Â») P, by simpâŸ©\n#align factors_self factors_self\n\n",
 "factors_right_of_factors_add":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem factors_right_of_factors_add {X Y : C} {P : subobject Y} (f g : Â«expr âŸ¶ Â» X Y) (w : P.factors (f + g))\n    (wf : P.factors f) : P.factors g :=\n  (factors_iff _ _).mpr âŸ¨P.factor_thru (f + g) w - P.factor_thru f wf, by simpâŸ©\n#align factors_right_of_factors_add factors_right_of_factors_add\n\n",
 "factors_of_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem factors_of_le {Y Z : C} {P Q : subobject Y} (f : Â«expr âŸ¶ Â» Z Y) (h : P â‰¤ Q) : P.factors f â†’ Q.factors f :=\n  by\n  simp only [factors_iff]\n  exact fun âŸ¨u, huâŸ© => âŸ¨Â«expr â‰« Â» u (of_le _ _ h), by simp [â† hu]âŸ©\n#align factors_of_le factors_of_le\n\n",
 "factors_of_factors_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\ntheorem factors_of_factors_right {X Y Z : C} {P : subobject Z} (f : Â«expr âŸ¶ Â» X Y) {g : Â«expr âŸ¶ Â» Y Z}\n    (h : P.factors g) : P.factors (Â«expr â‰« Â» f g) := by\n  revert P\n  refine' quotient.ind' _\n  intro P\n  rintro âŸ¨g, rflâŸ©\n  exact âŸ¨Â«expr â‰« Â» f g, by simpâŸ©\n#align factors_of_factors_right factors_of_factors_right\n\n",
 "factors_left_of_factors_add":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem factors_left_of_factors_add {X Y : C} {P : subobject Y} (f g : Â«expr âŸ¶ Â» X Y) (w : P.factors (f + g))\n    (wg : P.factors g) : P.factors f :=\n  (factors_iff _ _).mpr âŸ¨P.factor_thru (f + g) w - P.factor_thru g wg, by simpâŸ©\n#align factors_left_of_factors_add factors_left_of_factors_add\n\n",
 "factors_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem factors_iff {X Y : C} (P : subobject Y) (f : Â«expr âŸ¶ Â» X Y) : P.factors f â†” (representative.obj P).factors f :=\n  Quot.inductionOn P fun a => mono_over.factors_congr _ (representative_iso _).symm\n#align factors_iff factors_iff\n\n",
 "factors_congr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰… Â» -/\n/-\nCopyright (c) 2020 Scott Morrison. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Bhavik Mehta, Scott Morrison\n-/\ntheorem factors_congr {X : C} {f g : mono_over X} {Y : C} (h : Â«expr âŸ¶ Â» Y X) (e : Â«expr â‰… Â» f g) :\n    f.factors h â†” g.factors h :=\n  âŸ¨fun âŸ¨u, huâŸ© => âŸ¨Â«expr â‰« Â» u ((mono_over.forget _).map e.hom).left, by simp [hu]âŸ©, fun âŸ¨u, huâŸ© =>\n    âŸ¨Â«expr â‰« Â» u ((mono_over.forget _).map e.inv).left, by simp [hu]âŸ©âŸ©\n#align factors_congr factors_congr\n\n",
 "factors_comp_arrow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\ntheorem factors_comp_arrow {X Y : C} {P : subobject Y} (f : Â«expr âŸ¶ Â» X P) : P.factors (Â«expr â‰« Â» f P.arrow) :=\n  (factors_iff _ _).mpr âŸ¨f, rflâŸ©\n#align factors_comp_arrow factors_comp_arrow\n\n",
 "factors_add":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem factors_add {X Y : C} {P : subobject Y} (f g : Â«expr âŸ¶ Â» X Y) (wf : P.factors f) (wg : P.factors g) :\n    P.factors (f + g) :=\n  (factors_iff _ _).mpr âŸ¨P.factor_thru f wf + P.factor_thru g wg, by simpâŸ©\n#align factors_add factors_add\n\n",
 "factor_thru_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n@[simp]\ntheorem factor_thru_zero [has_zero_morphisms C] {X Y : C} {P : subobject Y} (h : P.factors (0 : Â«expr âŸ¶ Â» X Y)) :\n    P.factor_thru 0 h = 0 := by simp\n#align factor_thru_zero factor_thru_zero\n\n",
 "factor_thru_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n@[simp]\ntheorem factor_thru_self {X : C} (P : subobject X) (h) : P.factor_thru P.arrow h = (Â«exprğŸ™Â») P :=\n  by\n  ext\n  simp\n#align factor_thru_self factor_thru_self\n\n",
 "factor_thru_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\ntheorem factor_thru_right {X Y Z : C} {P : subobject Z} (f : Â«expr âŸ¶ Â» X Y) (g : Â«expr âŸ¶ Â» Y Z) (h : P.factors g) :\n    Â«expr â‰« Â» f (P.factor_thru g h) = P.factor_thru (Â«expr â‰« Â» f g) (factors_of_factors_right f h) :=\n  by\n  apply (cancel_mono P.arrow).mp\n  simp\n#align factor_thru_right factor_thru_right\n\n",
 "factor_thru_of_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n-- `h` is an explicit argument here so we can use\n-- `rw factor_thru_le h`, obtaining a subgoal `P.factors f`.\n-- (While the reverse direction looks plausible as a simp lemma, it seems to be unproductive.)\ntheorem factor_thru_of_le {Y Z : C} {P Q : subobject Y} {f : Â«expr âŸ¶ Â» Z Y} (h : P â‰¤ Q) (w : P.factors f) :\n    Q.factor_thru f (factors_of_le f h w) = Â«expr â‰« Â» (P.factor_thru f w) (of_le P Q h) :=\n  by\n  ext\n  simp\n#align factor_thru_of_le factor_thru_of_le\n\n",
 "factor_thru_mk_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n@[simp]\ntheorem factor_thru_mk_self (f : Â«expr âŸ¶ Â» X Y) [Mono f] :\n    (mk f).factor_thru f (mk_factors_self f) = (underlying_iso f).inv :=\n  by\n  ext\n  simp\n#align factor_thru_mk_self factor_thru_mk_self\n\n",
 "factor_thru_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr =â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n@[simp]\ntheorem factor_thru_eq_zero [has_zero_morphisms C] {X Y : C} {P : subobject Y} {f : Â«expr âŸ¶ Â» X Y} {h : factors P f} :\n    P.factor_thru f h = 0 â†” f = 0 := by\n  fconstructor\n  Â· intro w\n    replace w := Â«expr =â‰« Â» w P.arrow\n    simpa using w\n  Â· rintro rfl\n    ext\n    simp\n#align factor_thru_eq_zero factor_thru_eq_zero\n\n",
 "factor_thru_comp_arrow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n@[simp]\ntheorem factor_thru_comp_arrow {X Y : C} {P : subobject Y} (f : Â«expr âŸ¶ Â» X P) (h) :\n    P.factor_thru (Â«expr â‰« Â» f P.arrow) h = f := by\n  ext\n  simp\n#align factor_thru_comp_arrow factor_thru_comp_arrow\n\n",
 "factor_thru_arrow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n@[simp, reassoc.1]\ntheorem factor_thru_arrow {X Y : C} (P : subobject Y) (f : Â«expr âŸ¶ Â» X Y) (h : factors P f) :\n    Â«expr â‰« Â» (P.factor_thru f h) P.arrow = f :=\n  Classical.choose_spec ((factors_iff _ _).mp h)\n#align factor_thru_arrow factor_thru_arrow\n\n",
 "factor_thru_add_sub_factor_thru_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n@[simp]\ntheorem factor_thru_add_sub_factor_thru_right {X Y : C} {P : subobject Y} (f g : Â«expr âŸ¶ Â» X Y) (w : P.factors (f + g))\n    (wg : P.factors g) :\n    P.factor_thru (f + g) w - P.factor_thru g wg = P.factor_thru f (factors_left_of_factors_add f g w wg) :=\n  by\n  ext\n  simp\n#align factor_thru_add_sub_factor_thru_right factor_thru_add_sub_factor_thru_right\n\n",
 "factor_thru_add_sub_factor_thru_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n@[simp]\ntheorem factor_thru_add_sub_factor_thru_left {X Y : C} {P : subobject Y} (f g : Â«expr âŸ¶ Â» X Y) (w : P.factors (f + g))\n    (wf : P.factors f) :\n    P.factor_thru (f + g) w - P.factor_thru f wf = P.factor_thru g (factors_right_of_factors_add f g w wf) :=\n  by\n  ext\n  simp\n#align factor_thru_add_sub_factor_thru_left factor_thru_add_sub_factor_thru_left\n\n",
 "factor_thru_add":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n-- This can't be a `simp` lemma as `wf` and `wg` may not exist.\n-- However you can `rw` by it to assert that `f` and `g` factor through `P` separately.\ntheorem factor_thru_add {X Y : C} {P : subobject Y} (f g : Â«expr âŸ¶ Â» X Y) (w : P.factors (f + g)) (wf : P.factors f)\n    (wg : P.factors g) : P.factor_thru (f + g) w = P.factor_thru f wf + P.factor_thru g wg :=\n  by\n  ext\n  simp\n#align factor_thru_add factor_thru_add\n\n"}