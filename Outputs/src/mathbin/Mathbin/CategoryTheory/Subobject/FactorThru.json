{"mk_factors_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem mk_factors_self (f : «expr ⟶ » X Y) [Mono f] : (mk f).factors f :=\n  ⟨(«expr𝟙») _, by simp⟩\n#align mk_factors_self mk_factors_self\n\n",
 "mk_factors_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n@[simp]\ntheorem mk_factors_iff {X Y Z : C} (f : «expr ⟶ » Y X) [Mono f] (g : «expr ⟶ » Z X) :\n    (subobject.mk f).factors g ↔ (mono_over.mk' f).factors g :=\n  iff.rfl\n#align mk_factors_iff mk_factors_iff\n\n",
 "factors_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem factors_zero [has_zero_morphisms C] {X Y : C} {P : subobject Y} : P.factors (0 : «expr ⟶ » X Y) :=\n  (factors_iff _ _).mpr ⟨0, by simp⟩\n#align factors_zero factors_zero\n\n",
 "factors_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\ntheorem factors_self {X : C} (P : subobject X) : P.factors P.arrow :=\n  (factors_iff _ _).mpr ⟨(«expr𝟙») P, by simp⟩\n#align factors_self factors_self\n\n",
 "factors_right_of_factors_add":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem factors_right_of_factors_add {X Y : C} {P : subobject Y} (f g : «expr ⟶ » X Y) (w : P.factors (f + g))\n    (wf : P.factors f) : P.factors g :=\n  (factors_iff _ _).mpr ⟨P.factor_thru (f + g) w - P.factor_thru f wf, by simp⟩\n#align factors_right_of_factors_add factors_right_of_factors_add\n\n",
 "factors_of_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem factors_of_le {Y Z : C} {P Q : subobject Y} (f : «expr ⟶ » Z Y) (h : P ≤ Q) : P.factors f → Q.factors f :=\n  by\n  simp only [factors_iff]\n  exact fun ⟨u, hu⟩ => ⟨«expr ≫ » u (of_le _ _ h), by simp [← hu]⟩\n#align factors_of_le factors_of_le\n\n",
 "factors_of_factors_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem factors_of_factors_right {X Y Z : C} {P : subobject Z} (f : «expr ⟶ » X Y) {g : «expr ⟶ » Y Z}\n    (h : P.factors g) : P.factors («expr ≫ » f g) := by\n  revert P\n  refine' quotient.ind' _\n  intro P\n  rintro ⟨g, rfl⟩\n  exact ⟨«expr ≫ » f g, by simp⟩\n#align factors_of_factors_right factors_of_factors_right\n\n",
 "factors_left_of_factors_add":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem factors_left_of_factors_add {X Y : C} {P : subobject Y} (f g : «expr ⟶ » X Y) (w : P.factors (f + g))\n    (wg : P.factors g) : P.factors f :=\n  (factors_iff _ _).mpr ⟨P.factor_thru (f + g) w - P.factor_thru g wg, by simp⟩\n#align factors_left_of_factors_add factors_left_of_factors_add\n\n",
 "factors_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem factors_iff {X Y : C} (P : subobject Y) (f : «expr ⟶ » X Y) : P.factors f ↔ (representative.obj P).factors f :=\n  Quot.inductionOn P fun a => mono_over.factors_congr _ (representative_iso _).symm\n#align factors_iff factors_iff\n\n",
 "factors_congr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≅ » -/\n/-\nCopyright (c) 2020 Scott Morrison. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Bhavik Mehta, Scott Morrison\n-/\ntheorem factors_congr {X : C} {f g : mono_over X} {Y : C} (h : «expr ⟶ » Y X) (e : «expr ≅ » f g) :\n    f.factors h ↔ g.factors h :=\n  ⟨fun ⟨u, hu⟩ => ⟨«expr ≫ » u ((mono_over.forget _).map e.hom).left, by simp [hu]⟩, fun ⟨u, hu⟩ =>\n    ⟨«expr ≫ » u ((mono_over.forget _).map e.inv).left, by simp [hu]⟩⟩\n#align factors_congr factors_congr\n\n",
 "factors_comp_arrow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem factors_comp_arrow {X Y : C} {P : subobject Y} (f : «expr ⟶ » X P) : P.factors («expr ≫ » f P.arrow) :=\n  (factors_iff _ _).mpr ⟨f, rfl⟩\n#align factors_comp_arrow factors_comp_arrow\n\n",
 "factors_add":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem factors_add {X Y : C} {P : subobject Y} (f g : «expr ⟶ » X Y) (wf : P.factors f) (wg : P.factors g) :\n    P.factors (f + g) :=\n  (factors_iff _ _).mpr ⟨P.factor_thru f wf + P.factor_thru g wg, by simp⟩\n#align factors_add factors_add\n\n",
 "factor_thru_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n@[simp]\ntheorem factor_thru_zero [has_zero_morphisms C] {X Y : C} {P : subobject Y} (h : P.factors (0 : «expr ⟶ » X Y)) :\n    P.factor_thru 0 h = 0 := by simp\n#align factor_thru_zero factor_thru_zero\n\n",
 "factor_thru_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n@[simp]\ntheorem factor_thru_self {X : C} (P : subobject X) (h) : P.factor_thru P.arrow h = («expr𝟙») P :=\n  by\n  ext\n  simp\n#align factor_thru_self factor_thru_self\n\n",
 "factor_thru_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem factor_thru_right {X Y Z : C} {P : subobject Z} (f : «expr ⟶ » X Y) (g : «expr ⟶ » Y Z) (h : P.factors g) :\n    «expr ≫ » f (P.factor_thru g h) = P.factor_thru («expr ≫ » f g) (factors_of_factors_right f h) :=\n  by\n  apply (cancel_mono P.arrow).mp\n  simp\n#align factor_thru_right factor_thru_right\n\n",
 "factor_thru_of_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n-- `h` is an explicit argument here so we can use\n-- `rw factor_thru_le h`, obtaining a subgoal `P.factors f`.\n-- (While the reverse direction looks plausible as a simp lemma, it seems to be unproductive.)\ntheorem factor_thru_of_le {Y Z : C} {P Q : subobject Y} {f : «expr ⟶ » Z Y} (h : P ≤ Q) (w : P.factors f) :\n    Q.factor_thru f (factors_of_le f h w) = «expr ≫ » (P.factor_thru f w) (of_le P Q h) :=\n  by\n  ext\n  simp\n#align factor_thru_of_le factor_thru_of_le\n\n",
 "factor_thru_mk_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n@[simp]\ntheorem factor_thru_mk_self (f : «expr ⟶ » X Y) [Mono f] :\n    (mk f).factor_thru f (mk_factors_self f) = (underlying_iso f).inv :=\n  by\n  ext\n  simp\n#align factor_thru_mk_self factor_thru_mk_self\n\n",
 "factor_thru_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n@[simp]\ntheorem factor_thru_eq_zero [has_zero_morphisms C] {X Y : C} {P : subobject Y} {f : «expr ⟶ » X Y} {h : factors P f} :\n    P.factor_thru f h = 0 ↔ f = 0 := by\n  fconstructor\n  · intro w\n    replace w := «expr =≫ » w P.arrow\n    simpa using w\n  · rintro rfl\n    ext\n    simp\n#align factor_thru_eq_zero factor_thru_eq_zero\n\n",
 "factor_thru_comp_arrow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp]\ntheorem factor_thru_comp_arrow {X Y : C} {P : subobject Y} (f : «expr ⟶ » X P) (h) :\n    P.factor_thru («expr ≫ » f P.arrow) h = f := by\n  ext\n  simp\n#align factor_thru_comp_arrow factor_thru_comp_arrow\n\n",
 "factor_thru_arrow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem factor_thru_arrow {X Y : C} (P : subobject Y) (f : «expr ⟶ » X Y) (h : factors P f) :\n    «expr ≫ » (P.factor_thru f h) P.arrow = f :=\n  Classical.choose_spec ((factors_iff _ _).mp h)\n#align factor_thru_arrow factor_thru_arrow\n\n",
 "factor_thru_add_sub_factor_thru_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n@[simp]\ntheorem factor_thru_add_sub_factor_thru_right {X Y : C} {P : subobject Y} (f g : «expr ⟶ » X Y) (w : P.factors (f + g))\n    (wg : P.factors g) :\n    P.factor_thru (f + g) w - P.factor_thru g wg = P.factor_thru f (factors_left_of_factors_add f g w wg) :=\n  by\n  ext\n  simp\n#align factor_thru_add_sub_factor_thru_right factor_thru_add_sub_factor_thru_right\n\n",
 "factor_thru_add_sub_factor_thru_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n@[simp]\ntheorem factor_thru_add_sub_factor_thru_left {X Y : C} {P : subobject Y} (f g : «expr ⟶ » X Y) (w : P.factors (f + g))\n    (wf : P.factors f) :\n    P.factor_thru (f + g) w - P.factor_thru f wf = P.factor_thru g (factors_right_of_factors_add f g w wf) :=\n  by\n  ext\n  simp\n#align factor_thru_add_sub_factor_thru_left factor_thru_add_sub_factor_thru_left\n\n",
 "factor_thru_add":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n-- This can't be a `simp` lemma as `wf` and `wg` may not exist.\n-- However you can `rw` by it to assert that `f` and `g` factor through `P` separately.\ntheorem factor_thru_add {X Y : C} {P : subobject Y} (f g : «expr ⟶ » X Y) (w : P.factors (f + g)) (wf : P.factors f)\n    (wg : P.factors g) : P.factor_thru (f + g) w = P.factor_thru f wf + P.factor_thru g wg :=\n  by\n  ext\n  simp\n#align factor_thru_add factor_thru_add\n\n"}