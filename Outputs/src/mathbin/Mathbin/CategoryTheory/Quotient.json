{"sound":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\nprotected theorem sound {a b : C} {f₁ f₂ : «expr ⟶ » a b} (h : r f₁ f₂) : (functor r).map f₁ = (functor r).map f₂ := by\n  simpa using quot.sound (comp_closure.intro ((«expr𝟙») a) f₁ f₂ ((«expr𝟙») b) h)\n#align sound sound\n\n",
 "of":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/-\nCopyright (c) 2020 David Wärn. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: David Wärn\n-/\ntheorem comp_closure.of {a b} (m₁ m₂ : «expr ⟶ » a b) (h : r m₁ m₂) : comp_closure r m₁ m₂ := by\n  simpa using comp_closure.intro ((«expr𝟙») _) m₁ m₂ ((«expr𝟙») _) h\n#align comp_closure.of comp_closure.of\n\n",
 "lift_unique":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\ntheorem lift_unique (Φ : «expr ⥤ » (quotient r) D) (hΦ : «expr ⋙ » (functor r) Φ = F) : Φ = lift r F H :=\n  by\n  subst_vars\n  apply functor.hext\n  · rintro X\n    dsimp [lift, functor]\n    congr\n    ext\n    rfl\n  · rintro X Y f\n    dsimp [lift, functor]\n    apply Quot.inductionOn f\n    rintro ff\n    simp only [Quot.liftOn_mk, functor.comp_map]\n    congr <;> ext <;> rfl\n#align lift_unique lift_unique\n\n",
 "lift_spec":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\ntheorem lift_spec : «expr ⋙ » (functor r) (lift r F H) = F :=\n  by\n  apply Functor.ext; rotate_left\n  · rintro X\n    rfl\n  · rintro X Y f\n    simp\n#align lift_spec lift_spec\n\n",
 "lift_map_functor_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem lift_map_functor_map {X Y : C} (f : «expr ⟶ » X Y) : (lift r F H).map ((functor r).map f) = F.map f :=\n  by\n  rw [← nat_iso.naturality_1 (lift.is_lift r F H)]\n  dsimp\n  simp\n#align lift_map_functor_map lift_map_functor_map\n\n",
 "is_lift_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n@[simp]\ntheorem lift.is_lift_inv (X : C) : (lift.is_lift r F H).inv.app X = («expr𝟙») (F.obj X) :=\n  rfl\n#align lift.is_lift_inv lift.is_lift_inv\n\n",
 "is_lift_hom":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n@[simp]\ntheorem lift.is_lift_hom (X : C) : (lift.is_lift r F H).hom.app X = («expr𝟙») (F.obj X) :=\n  rfl\n#align lift.is_lift_hom lift.is_lift_hom\n\n",
 "induction":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\nprotected theorem induction {P : ∀ {a b : quotient r}, «expr ⟶ » a b → Prop}\n    (h : ∀ {x y : C} (f : «expr ⟶ » x y), P ((functor r).map f)) : ∀ {a b : quotient r} (f : «expr ⟶ » a b), P f :=\n  by\n  rintro ⟨x⟩ ⟨y⟩ ⟨f⟩\n  exact h f\n#align induction induction\n\n",
 "functor_map_eq_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem functor_map_eq_iff [congruence r] {X Y : C} (f f' : «expr ⟶ » X Y) :\n    (functor r).map f = (functor r).map f' ↔ r f f' :=\n  by\n  constructor\n  · erw [quot.eq]\n    intro h\n    induction' h with m m' hm\n    · cases hm\n      apply congruence.comp_left\n      apply congruence.comp_right\n      assumption\n    · apply refl\n    · apply symm\n      assumption\n    · apply trans <;> assumption\n  · apply quotient.sound\n#align functor_map_eq_iff functor_map_eq_iff\n\n",
 "comp_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem comp_right {a b c : C} (g : «expr ⟶ » b c) :\n    ∀ (f₁ f₂ : «expr ⟶ » a b) (h : comp_closure r f₁ f₂), comp_closure r («expr ≫ » f₁ g) («expr ≫ » f₂ g)\n  | _, _, ⟨x, m₁, m₂, y, h⟩ => by simpa using comp_closure.intro x m₁ m₂ («expr ≫ » y g) h\n#align comp_right comp_right\n\n",
 "comp_mk":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp]\ntheorem comp_mk {a b c : quotient r} (f : «expr ⟶ » a.as b.as) (g : «expr ⟶ » b.as c.as) :\n    comp r (Quot.mk _ f) (Quot.mk _ g) = Quot.mk _ («expr ≫ » f g) :=\n  rfl\n#align comp_mk comp_mk\n\n",
 "comp_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem comp_left {a b c : C} (f : «expr ⟶ » a b) :\n    ∀ (g₁ g₂ : «expr ⟶ » b c) (h : comp_closure r g₁ g₂), comp_closure r («expr ≫ » f g₁) («expr ≫ » f g₂)\n  | _, _, ⟨x, m₁, m₂, y, h⟩ => by simpa using comp_closure.intro («expr ≫ » f x) m₁ m₂ y h\n#align comp_left comp_left\n\n"}