{"whiskering_left_obj_preimage_app":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚•§ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚ü∂ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚ãô ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚ãô ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚â´ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚â´ ¬ª -/\ntheorem whiskering_left_obj_preimage_app {F G : ¬´expr ‚•§ ¬ª (karoubi C) D}\n    (œÑ : ¬´expr ‚ü∂ ¬ª (¬´expr ‚ãô ¬ª (to_karoubi _) F) (¬´expr ‚ãô ¬ª (to_karoubi _) G)) (P : karoubi C) :\n    (((whiskeringLeft _ _ _).obj (to_karoubi _)).preimage œÑ).app P =\n      ¬´expr ‚â´ ¬ª (F.map P.decomp_id_i) (¬´expr ‚â´ ¬ª (œÑ.app P.X) (G.map P.decomp_id_p)) :=\n  by\n  rw [nat_trans_eq]\n  congr 2\n  exact congr_app (((whiskering_left _ _ _).obj (to_karoubi _)).image_preimage œÑ) P.X\n#align whiskering_left_obj_preimage_app whiskering_left_obj_preimage_app\n\n",
 "nat_trans_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚•§ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚ü∂ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚â´ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚â´ ¬ª -/\n/-\nCopyright (c) 2022 Jo√´l Riou. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Jo√´l Riou\n-/\n/-- A natural transformation between functors `karoubi C ‚•§ D` is determined\nby its value on objects coming from `C`. -/\ntheorem nat_trans_eq {F G : ¬´expr ‚•§ ¬ª (karoubi C) D} (œÜ : ¬´expr ‚ü∂ ¬ª F G) (P : karoubi C) :\n    œÜ.app P = ¬´expr ‚â´ ¬ª (F.map (decomp_id_i P)) (¬´expr ‚â´ ¬ª (œÜ.app P.X) (G.map (decomp_id_p P))) :=\n  by\n  rw [‚Üê œÜ.naturality, ‚Üê assoc, ‚Üê F.map_comp]\n  conv =>\n    lhs\n    rw [‚Üê id_comp (œÜ.app P), ‚Üê F.map_id]\n  congr\n  apply decomp_id\n#align nat_trans_eq nat_trans_eq\n\n",
 "karoubi_universal‚ÇÇ_functor_eq":
 "theorem karoubi_universal‚ÇÇ_functor_eq : (karoubi_universal‚ÇÇ C D).functor = functor_extension‚ÇÇ C D :=\n  rfl\n#align karoubi_universal‚ÇÇ_functor_eq karoubi_universal‚ÇÇ_functor_eq\n\n",
 "karoubi_universal_functor_eq":
 "theorem karoubi_universal_functor_eq : (karoubi_universal C D).functor = functor_extension C D :=\n  rfl\n#align karoubi_universal_functor_eq karoubi_universal_functor_eq\n\n",
 "functor_extension‚ÇÇ_comp_whiskering_left_to_karoubi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚ãô ¬ª -/\ntheorem functor_extension‚ÇÇ_comp_whiskering_left_to_karoubi :\n    ¬´expr ‚ãô ¬ª (functor_extension‚ÇÇ C D) ((whiskeringLeft C (karoubi C) (karoubi D)).obj (to_karoubi C)) =\n      (whiskeringRight C D (karoubi D)).obj (to_karoubi D) :=\n  by simp only [functor_extension‚ÇÇ, functor.assoc, functor_extension‚ÇÅ_comp_whiskering_left_to_karoubi, functor.comp_id]\n#align functor_extension‚ÇÇ_comp_whiskering_left_to_karoubi functor_extension‚ÇÇ_comp_whiskering_left_to_karoubi\n\n",
 "functor_extension‚ÇÅ_comp_whiskering_left_to_karoubi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚ãô ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´exprùü≠¬ª -/\ntheorem functor_extension‚ÇÅ_comp_whiskering_left_to_karoubi :\n    ¬´expr ‚ãô ¬ª (functor_extension‚ÇÅ C D) ((whiskeringLeft C (karoubi C) (karoubi D)).obj (to_karoubi C)) = (¬´exprùü≠¬ª) _ :=\n  by\n  refine' Functor.ext _ _\n  ¬∑ intro F\n    refine' Functor.ext _ _\n    ¬∑ intro X\n      ext\n      ¬∑ dsimp\n        rw [id_comp, comp_id, F.map_id, id_eq]\n      ¬∑ rfl\n    ¬∑ intro X Y f\n      ext\n      dsimp\n      simp only [comp_id, eq_to_hom_f, eq_to_hom_refl, comp_p, functor_extension‚ÇÅ.obj_obj_p, to_karoubi_obj_p, comp_f]\n      dsimp\n      simp only [Functor.map_id, id_eq, p_comp]\n  ¬∑ intro F G œÜ\n    ext X\n    dsimp\n    simp only [eq_to_hom_app, F.map_id, comp_f, eq_to_hom_f, id_eq, p_comp, eq_to_hom_refl, comp_id, comp_p,\n      functor_extension‚ÇÅ.obj_obj_p, to_karoubi_obj_p, F.map_id X]\n#align functor_extension‚ÇÅ_comp_whiskering_left_to_karoubi functor_extension‚ÇÅ_comp_whiskering_left_to_karoubi\n\n",
 "functor_extension‚ÇÅ_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚•§ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚•§ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚ãô ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚ãô ¬ª -/\ntheorem functor_extension‚ÇÅ_comp (F : ¬´expr ‚•§ ¬ª C (karoubi D)) (G : ¬´expr ‚•§ ¬ª D (karoubi E)) :\n    (functor_extension‚ÇÅ C E).obj (¬´expr ‚ãô ¬ª F ((functor_extension‚ÇÅ D E).obj G)) =\n      ¬´expr ‚ãô ¬ª ((functor_extension‚ÇÅ C D).obj F) ((functor_extension‚ÇÅ D E).obj G) :=\n  functor.ext (by tidy) fun X Y f => by\n    dsimp\n    simpa only [id_comp, comp_id]\n#align functor_extension‚ÇÅ_comp functor_extension‚ÇÅ_comp\n\n"}