{"split_imp_of_iso":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰… Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\ntheorem split_imp_of_iso {X X' : C} (Ï† : Â«expr â‰… Â» X X') (p : Â«expr âŸ¶ Â» X X) (p' : Â«expr âŸ¶ Â» X' X')\n    (hpp' : Â«expr â‰« Â» p Ï†.hom = Â«expr â‰« Â» Ï†.hom p')\n    (h : âˆƒ (Y : C)(i : Â«expr âŸ¶ Â» Y X)(e : Â«expr âŸ¶ Â» X Y), Â«expr â‰« Â» i e = (Â«exprğŸ™Â») Y âˆ§ Â«expr â‰« Â» e i = p) :\n    âˆƒ (Y' : C)(i' : Â«expr âŸ¶ Â» Y' X')(e' : Â«expr âŸ¶ Â» X' Y'), Â«expr â‰« Â» i' e' = (Â«exprğŸ™Â») Y' âˆ§ Â«expr â‰« Â» e' i' = p' :=\n  by\n  rcases h with âŸ¨Y, i, e, âŸ¨hâ‚, hâ‚‚âŸ©âŸ©\n  use Y, Â«expr â‰« Â» i Ï†.hom, Â«expr â‰« Â» Ï†.inv e\n  constructor\n  Â· slice_lhs 2 3 => rw [Ï†.hom_inv_id]\n    rw [id_comp, hâ‚]\n  Â· slice_lhs 2 3 => rw [hâ‚‚]\n    rw [hpp', â† assoc, Ï†.inv_hom_id, id_comp]\n#align split_imp_of_iso split_imp_of_iso\n\n",
 "split_iff_of_iso":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰… Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\ntheorem split_iff_of_iso {X X' : C} (Ï† : Â«expr â‰… Â» X X') (p : Â«expr âŸ¶ Â» X X) (p' : Â«expr âŸ¶ Â» X' X')\n    (hpp' : Â«expr â‰« Â» p Ï†.hom = Â«expr â‰« Â» Ï†.hom p') :\n    (âˆƒ (Y : C)(i : Â«expr âŸ¶ Â» Y X)(e : Â«expr âŸ¶ Â» X Y), Â«expr â‰« Â» i e = (Â«exprğŸ™Â») Y âˆ§ Â«expr â‰« Â» e i = p) â†”\n      âˆƒ (Y' : C)(i' : Â«expr âŸ¶ Â» Y' X')(e' : Â«expr âŸ¶ Â» X' Y'), Â«expr â‰« Â» i' e' = (Â«exprğŸ™Â») Y' âˆ§ Â«expr â‰« Â» e' i' = p' :=\n  by\n  constructor\n  Â· exact split_imp_of_iso Ï† p p' hpp'\n  Â· apply split_imp_of_iso Ï†.symm p' p\n    rw [â† comp_id p, â† Ï†.hom_inv_id]\n    slice_rhs 2 3 => rw [hpp']\n    slice_rhs 1 2 => erw [Ï†.inv_hom_id]\n    simpa only [id_comp]\n#align split_iff_of_iso split_iff_of_iso\n\n",
 "is_idempotent_complete_of_is_idempotent_complete_opposite":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr áµ’áµ–Â» -/\ntheorem is_idempotent_complete_of_is_idempotent_complete_opposite (h : is_idempotent_complete (Â«expr áµ’áµ–Â» C)) :\n    is_idempotent_complete C := by\n  refine' âŸ¨_âŸ©\n  intro X p hp\n  rcases is_idempotent_complete.idempotents_split (op X) p.op (by rw [â† op_comp, hp]) with âŸ¨Y, i, e, âŸ¨hâ‚, hâ‚‚âŸ©âŸ©\n  use Y.unop, e.unop, i.unop\n  constructor\n  Â· simpa only [â† unop_comp, hâ‚]\n  Â· simpa only [â† unop_comp, hâ‚‚]\n#align\n  is_idempotent_complete_of_is_idempotent_complete_opposite is_idempotent_complete_of_is_idempotent_complete_opposite\n\n",
 "is_idempotent_complete_iff_opposite":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr áµ’áµ–Â» -/\ntheorem is_idempotent_complete_iff_opposite : is_idempotent_complete (Â«expr áµ’áµ–Â» C) â†” is_idempotent_complete C :=\n  by\n  constructor\n  Â· exact is_idempotent_complete_of_is_idempotent_complete_opposite\n  Â· intro h\n    apply is_idempotent_complete_of_is_idempotent_complete_opposite\n    rw [is_idempotent_complete_iff_of_equivalence (op_op_equivalence C)]\n    exact h\n#align is_idempotent_complete_iff_opposite is_idempotent_complete_iff_opposite\n\n",
 "is_idempotent_complete_iff_of_equivalence":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰Œ Â» -/\n/-- If `C` and `D` are equivalent categories, that `C` is idempotent complete iff `D` is. -/\ntheorem is_idempotent_complete_iff_of_equivalence {D : Type _} [Category D] (Îµ : Â«expr â‰Œ Â» C D) :\n    is_idempotent_complete C â†” is_idempotent_complete D :=\n  by\n  constructor\n  Â· exact equivalence.is_idempotent_complete Îµ\n  Â· exact equivalence.is_idempotent_complete Îµ.symm\n#align is_idempotent_complete_iff_of_equivalence is_idempotent_complete_iff_of_equivalence\n\n",
 "is_idempotent_complete_iff_idempotents_have_kernels":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/-- A preadditive category is pseudoabelian iff all idempotent endomorphisms have a kernel. -/\ntheorem is_idempotent_complete_iff_idempotents_have_kernels [preadditive C] :\n    is_idempotent_complete C â†” âˆ€ (X : C) (p : Â«expr âŸ¶ Â» X X), Â«expr â‰« Â» p p = p â†’ has_kernel p :=\n  by\n  rw [is_idempotent_complete_iff_has_equalizer_of_id_and_idempotent]\n  constructor\n  Â· intro h X p hp\n    haveI := h X ((Â«exprğŸ™Â») _ - p) (idem_of_id_sub_idem p hp)\n    convert has_kernel_of_has_equalizer ((Â«exprğŸ™Â») X) ((Â«exprğŸ™Â») X - p)\n    rw [sub_sub_cancel]\n  Â· intro h X p hp\n    haveI : has_kernel ((Â«exprğŸ™Â») _ - p) := h X ((Â«exprğŸ™Â») _ - p) (idem_of_id_sub_idem p hp)\n    apply preadditive.has_equalizer_of_has_kernel\n#align is_idempotent_complete_iff_idempotents_have_kernels is_idempotent_complete_iff_idempotents_have_kernels\n\n",
 "is_idempotent_complete_iff_has_equalizer_of_id_and_idempotent":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n/-\nCopyright (c) 2022 JoÃ«l Riou. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: JoÃ«l Riou\n-/\n/-- A category is idempotent complete iff for all idempotent endomorphisms,\nthe equalizer of the identity and this idempotent exists. -/\ntheorem is_idempotent_complete_iff_has_equalizer_of_id_and_idempotent :\n    is_idempotent_complete C â†” âˆ€ (X : C) (p : Â«expr âŸ¶ Â» X X), Â«expr â‰« Â» p p = p â†’ has_equalizer ((Â«exprğŸ™Â») X) p :=\n  by\n  constructor\n  Â· intro\n    intro X p hp\n    rcases is_idempotent_complete.idempotents_split X p hp with âŸ¨Y, i, e, âŸ¨hâ‚, hâ‚‚âŸ©âŸ©\n    exact\n      âŸ¨nonempty.intro\n          { cone :=\n              fork.of_Î¹ i (show Â«expr â‰« Â» i ((Â«exprğŸ™Â») X) = Â«expr â‰« Â» i p by rw [comp_id, â† hâ‚‚, â† assoc, hâ‚, id_comp])\n            is_limit := by\n              apply fork.is_limit.mk'\n              intro s\n              refine' âŸ¨Â«expr â‰« Â» s.Î¹ e, _âŸ©\n              constructor\n              Â· erw [assoc, hâ‚‚, â† limits.fork.condition s, comp_id]\n              Â· intro m hm\n                rw [fork.Î¹_of_Î¹] at hm\n                rw [â† hm]\n                simp only [â† hm, assoc, hâ‚]\n                exact (comp_id m).symm }âŸ©\n  Â· intro h\n    refine' âŸ¨_âŸ©\n    intro X p hp\n    haveI := h X p hp\n    use equalizer ((Â«exprğŸ™Â») X) p\n    use equalizer.Î¹ ((Â«exprğŸ™Â») X) p\n    use equalizer.lift p (show Â«expr â‰« Â» p ((Â«exprğŸ™Â») X) = Â«expr â‰« Â» p p by rw [hp, comp_id])\n    constructor\n    Â· ext\n      rw [assoc, equalizer.lift_Î¹, id_comp]\n      conv =>\n        rhs\n        erw [â† comp_id (equalizer.Î¹ ((Â«exprğŸ™Â») X) p)]\n      exact (limits.fork.condition (equalizer.fork ((Â«exprğŸ™Â») X) p)).symm\n    Â· rw [equalizer.lift_Î¹]\n#align\n  is_idempotent_complete_iff_has_equalizer_of_id_and_idempotent is_idempotent_complete_iff_has_equalizer_of_id_and_idempotent\n\n",
 "is_idempotent_complete":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰Œ Â» -/\ntheorem equivalence.is_idempotent_complete {D : Type _} [Category D] (Îµ : Â«expr â‰Œ Â» C D)\n    (h : is_idempotent_complete C) : is_idempotent_complete D :=\n  by\n  refine' âŸ¨_âŸ©\n  intro X' p hp\n  let Ï† := Îµ.counit_iso.symm.app X'\n  erw [split_iff_of_iso Ï† p (Â«expr â‰« Â» Ï†.inv (Â«expr â‰« Â» p Ï†.hom))\n      (by\n        slice_rhs 1 2 => rw [Ï†.hom_inv_id]\n        rw [id_comp])]\n  rcases is_idempotent_complete.idempotents_split (Îµ.inverse.obj X') (Îµ.inverse.map p)\n      (by rw [â† Îµ.inverse.map_comp, hp]) with\n    âŸ¨Y, i, e, âŸ¨hâ‚, hâ‚‚âŸ©âŸ©\n  use Îµ.functor.obj Y, Îµ.functor.map i, Îµ.functor.map e\n  constructor\n  Â· rw [â† Îµ.functor.map_comp, hâ‚, Îµ.functor.map_id]\n  Â· simpa only [â† Îµ.functor.map_comp, hâ‚‚, equivalence.fun_inv_map]\n#align equivalence.is_idempotent_complete equivalence.is_idempotent_complete\n\n",
 "idem_of_id_sub_idem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n/-- In a preadditive category, when `p : X âŸ¶ X` is idempotent,\nthen `ğŸ™ X - p` is also idempotent. -/\ntheorem idem_of_id_sub_idem [preadditive C] {X : C} (p : Â«expr âŸ¶ Â» X X) (hp : Â«expr â‰« Â» p p = p) :\n    Â«expr â‰« Â» ((Â«exprğŸ™Â») _ - p) ((Â«exprğŸ™Â») _ - p) = (Â«exprğŸ™Â») _ - p := by\n  simp only [comp_sub, sub_comp, id_comp, comp_id, hp, sub_self, sub_zero]\n#align idem_of_id_sub_idem idem_of_id_sub_idem\n\n"}