{"split_imp_of_iso":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≅ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem split_imp_of_iso {X X' : C} (φ : «expr ≅ » X X') (p : «expr ⟶ » X X) (p' : «expr ⟶ » X' X')\n    (hpp' : «expr ≫ » p φ.hom = «expr ≫ » φ.hom p')\n    (h : ∃ (Y : C)(i : «expr ⟶ » Y X)(e : «expr ⟶ » X Y), «expr ≫ » i e = («expr𝟙») Y ∧ «expr ≫ » e i = p) :\n    ∃ (Y' : C)(i' : «expr ⟶ » Y' X')(e' : «expr ⟶ » X' Y'), «expr ≫ » i' e' = («expr𝟙») Y' ∧ «expr ≫ » e' i' = p' :=\n  by\n  rcases h with ⟨Y, i, e, ⟨h₁, h₂⟩⟩\n  use Y, «expr ≫ » i φ.hom, «expr ≫ » φ.inv e\n  constructor\n  · slice_lhs 2 3 => rw [φ.hom_inv_id]\n    rw [id_comp, h₁]\n  · slice_lhs 2 3 => rw [h₂]\n    rw [hpp', ← assoc, φ.inv_hom_id, id_comp]\n#align split_imp_of_iso split_imp_of_iso\n\n",
 "split_iff_of_iso":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≅ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem split_iff_of_iso {X X' : C} (φ : «expr ≅ » X X') (p : «expr ⟶ » X X) (p' : «expr ⟶ » X' X')\n    (hpp' : «expr ≫ » p φ.hom = «expr ≫ » φ.hom p') :\n    (∃ (Y : C)(i : «expr ⟶ » Y X)(e : «expr ⟶ » X Y), «expr ≫ » i e = («expr𝟙») Y ∧ «expr ≫ » e i = p) ↔\n      ∃ (Y' : C)(i' : «expr ⟶ » Y' X')(e' : «expr ⟶ » X' Y'), «expr ≫ » i' e' = («expr𝟙») Y' ∧ «expr ≫ » e' i' = p' :=\n  by\n  constructor\n  · exact split_imp_of_iso φ p p' hpp'\n  · apply split_imp_of_iso φ.symm p' p\n    rw [← comp_id p, ← φ.hom_inv_id]\n    slice_rhs 2 3 => rw [hpp']\n    slice_rhs 1 2 => erw [φ.inv_hom_id]\n    simpa only [id_comp]\n#align split_iff_of_iso split_iff_of_iso\n\n",
 "is_idempotent_complete_of_is_idempotent_complete_opposite":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵖ» -/\ntheorem is_idempotent_complete_of_is_idempotent_complete_opposite (h : is_idempotent_complete («expr ᵒᵖ» C)) :\n    is_idempotent_complete C := by\n  refine' ⟨_⟩\n  intro X p hp\n  rcases is_idempotent_complete.idempotents_split (op X) p.op (by rw [← op_comp, hp]) with ⟨Y, i, e, ⟨h₁, h₂⟩⟩\n  use Y.unop, e.unop, i.unop\n  constructor\n  · simpa only [← unop_comp, h₁]\n  · simpa only [← unop_comp, h₂]\n#align\n  is_idempotent_complete_of_is_idempotent_complete_opposite is_idempotent_complete_of_is_idempotent_complete_opposite\n\n",
 "is_idempotent_complete_iff_opposite":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵖ» -/\ntheorem is_idempotent_complete_iff_opposite : is_idempotent_complete («expr ᵒᵖ» C) ↔ is_idempotent_complete C :=\n  by\n  constructor\n  · exact is_idempotent_complete_of_is_idempotent_complete_opposite\n  · intro h\n    apply is_idempotent_complete_of_is_idempotent_complete_opposite\n    rw [is_idempotent_complete_iff_of_equivalence (op_op_equivalence C)]\n    exact h\n#align is_idempotent_complete_iff_opposite is_idempotent_complete_iff_opposite\n\n",
 "is_idempotent_complete_iff_of_equivalence":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≌ » -/\n/-- If `C` and `D` are equivalent categories, that `C` is idempotent complete iff `D` is. -/\ntheorem is_idempotent_complete_iff_of_equivalence {D : Type _} [Category D] (ε : «expr ≌ » C D) :\n    is_idempotent_complete C ↔ is_idempotent_complete D :=\n  by\n  constructor\n  · exact equivalence.is_idempotent_complete ε\n  · exact equivalence.is_idempotent_complete ε.symm\n#align is_idempotent_complete_iff_of_equivalence is_idempotent_complete_iff_of_equivalence\n\n",
 "is_idempotent_complete_iff_idempotents_have_kernels":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/-- A preadditive category is pseudoabelian iff all idempotent endomorphisms have a kernel. -/\ntheorem is_idempotent_complete_iff_idempotents_have_kernels [preadditive C] :\n    is_idempotent_complete C ↔ ∀ (X : C) (p : «expr ⟶ » X X), «expr ≫ » p p = p → has_kernel p :=\n  by\n  rw [is_idempotent_complete_iff_has_equalizer_of_id_and_idempotent]\n  constructor\n  · intro h X p hp\n    haveI := h X ((«expr𝟙») _ - p) (idem_of_id_sub_idem p hp)\n    convert has_kernel_of_has_equalizer ((«expr𝟙») X) ((«expr𝟙») X - p)\n    rw [sub_sub_cancel]\n  · intro h X p hp\n    haveI : has_kernel ((«expr𝟙») _ - p) := h X ((«expr𝟙») _ - p) (idem_of_id_sub_idem p hp)\n    apply preadditive.has_equalizer_of_has_kernel\n#align is_idempotent_complete_iff_idempotents_have_kernels is_idempotent_complete_iff_idempotents_have_kernels\n\n",
 "is_idempotent_complete_iff_has_equalizer_of_id_and_idempotent":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/-\nCopyright (c) 2022 Joël Riou. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Joël Riou\n-/\n/-- A category is idempotent complete iff for all idempotent endomorphisms,\nthe equalizer of the identity and this idempotent exists. -/\ntheorem is_idempotent_complete_iff_has_equalizer_of_id_and_idempotent :\n    is_idempotent_complete C ↔ ∀ (X : C) (p : «expr ⟶ » X X), «expr ≫ » p p = p → has_equalizer ((«expr𝟙») X) p :=\n  by\n  constructor\n  · intro\n    intro X p hp\n    rcases is_idempotent_complete.idempotents_split X p hp with ⟨Y, i, e, ⟨h₁, h₂⟩⟩\n    exact\n      ⟨nonempty.intro\n          { cone :=\n              fork.of_ι i (show «expr ≫ » i ((«expr𝟙») X) = «expr ≫ » i p by rw [comp_id, ← h₂, ← assoc, h₁, id_comp])\n            is_limit := by\n              apply fork.is_limit.mk'\n              intro s\n              refine' ⟨«expr ≫ » s.ι e, _⟩\n              constructor\n              · erw [assoc, h₂, ← limits.fork.condition s, comp_id]\n              · intro m hm\n                rw [fork.ι_of_ι] at hm\n                rw [← hm]\n                simp only [← hm, assoc, h₁]\n                exact (comp_id m).symm }⟩\n  · intro h\n    refine' ⟨_⟩\n    intro X p hp\n    haveI := h X p hp\n    use equalizer ((«expr𝟙») X) p\n    use equalizer.ι ((«expr𝟙») X) p\n    use equalizer.lift p (show «expr ≫ » p ((«expr𝟙») X) = «expr ≫ » p p by rw [hp, comp_id])\n    constructor\n    · ext\n      rw [assoc, equalizer.lift_ι, id_comp]\n      conv =>\n        rhs\n        erw [← comp_id (equalizer.ι ((«expr𝟙») X) p)]\n      exact (limits.fork.condition (equalizer.fork ((«expr𝟙») X) p)).symm\n    · rw [equalizer.lift_ι]\n#align\n  is_idempotent_complete_iff_has_equalizer_of_id_and_idempotent is_idempotent_complete_iff_has_equalizer_of_id_and_idempotent\n\n",
 "is_idempotent_complete":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≌ » -/\ntheorem equivalence.is_idempotent_complete {D : Type _} [Category D] (ε : «expr ≌ » C D)\n    (h : is_idempotent_complete C) : is_idempotent_complete D :=\n  by\n  refine' ⟨_⟩\n  intro X' p hp\n  let φ := ε.counit_iso.symm.app X'\n  erw [split_iff_of_iso φ p («expr ≫ » φ.inv («expr ≫ » p φ.hom))\n      (by\n        slice_rhs 1 2 => rw [φ.hom_inv_id]\n        rw [id_comp])]\n  rcases is_idempotent_complete.idempotents_split (ε.inverse.obj X') (ε.inverse.map p)\n      (by rw [← ε.inverse.map_comp, hp]) with\n    ⟨Y, i, e, ⟨h₁, h₂⟩⟩\n  use ε.functor.obj Y, ε.functor.map i, ε.functor.map e\n  constructor\n  · rw [← ε.functor.map_comp, h₁, ε.functor.map_id]\n  · simpa only [← ε.functor.map_comp, h₂, equivalence.fun_inv_map]\n#align equivalence.is_idempotent_complete equivalence.is_idempotent_complete\n\n",
 "idem_of_id_sub_idem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/-- In a preadditive category, when `p : X ⟶ X` is idempotent,\nthen `𝟙 X - p` is also idempotent. -/\ntheorem idem_of_id_sub_idem [preadditive C] {X : C} (p : «expr ⟶ » X X) (hp : «expr ≫ » p p = p) :\n    «expr ≫ » ((«expr𝟙») _ - p) ((«expr𝟙») _ - p) = («expr𝟙») _ - p := by\n  simp only [comp_sub, sub_comp, id_comp, comp_id, hp, sub_self, sub_zero]\n#align idem_of_id_sub_idem idem_of_id_sub_idem\n\n"}