{"punit_ext'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/-\nCopyright (c) 2018 Scott Morrison. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Scott Morrison, Bhavik Mehta\n-/\n-- morphism levels before object levels. See note [category_theory universes].\n/-- Any two functors to `discrete punit` are *equal*.\nYou probably want to use `punit_ext` instead of this.\n-/\ntheorem punit_ext' (F G : «expr ⥤ » C (discrete PUnit)) : F = G :=\n  functor.ext (fun _ => by decide) fun _ _ _ => by decide\n#align punit_ext' punit_ext'\n\n",
 "equiv_punit_iff_unique":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:219:4: warning: unsupported binary notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≌ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n-- See note [dsimp, simp].\n/-- A category being equivalent to `punit` is equivalent to it having a unique morphism between\n  any two objects. (In fact, such a category is also a groupoid; see `groupoid.of_hom_unique`) -/\ntheorem equiv_punit_iff_unique :\n    nonempty («expr ≌ » C (discrete PUnit)) ↔ nonempty C ∧ ∀ x y : C, nonempty <| unique («expr ⟶ » x y) :=\n  by\n  constructor\n  · rintro ⟨h⟩\n    refine' ⟨⟨h.inverse.obj ⟨⟨⟩⟩⟩, fun x y => nonempty.intro _⟩\n    apply unique_of_subsingleton _\n    swap\n    · have hx : «expr ⟶ » x (h.inverse.obj ⟨⟨⟩⟩) := by convert h.unit.app x\n      have hy : «expr ⟶ » (h.inverse.obj ⟨⟨⟩⟩) y := by convert h.unit_inv.app y\n      exact «expr ≫ » hx hy\n    have : ∀ z, z = «expr ≫ » (h.unit.app x) («expr ≫ » ((«expr ⋙ » h.functor h.inverse).map z) (h.unit_inv.app y)) :=\n      by\n      intro z\n      simpa using congr_arg («expr ≫ » · (h.unit_inv.app y)) (h.unit.naturality z)\n    apply subsingleton.intro\n    intro a b\n    rw [this a, this b]\n    simp only [functor.comp_map]\n    congr\n  · rintro ⟨⟨p⟩, h⟩\n    haveI := fun x y => (h x y).some\n    refine'\n      nonempty.intro\n        (category_theory.equivalence.mk ((Functor.Const _).obj ⟨⟨⟩⟩) ((Functor.Const _).obj p) _\n          (by apply functor.punit_ext))\n    exact\n      nat_iso.of_components\n        (fun _ =>\n          { hom := default\n            inv := default })\n        fun _ _ _ => by tidy\n#align equiv_punit_iff_unique equiv_punit_iff_unique\n\n"}