{"van_kampen'":
 "theorem adhesive.van_kampen' [adhesive C] [Mono g] (H : IsPushout f g h i) : H.is_van_kampen :=\n  (adhesive.van_kampen H.flip).flip\n#align adhesive.van_kampen' adhesive.van_kampen'\n\n",
 "mono_of_mono_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprðŸ™Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprðŸ™Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprðŸ™Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprðŸ™Â» -/\ntheorem is_pushout.is_van_kampen.mono_of_mono_right [Mono g] {H : IsPushout f g h i} (H' : H.is_van_kampen) : Mono h :=\n  IsKernelPair.mono_of_isIso_fst\n    ((H' f ((Â«exprðŸ™Â») _) ((Â«exprðŸ™Â») _) f ((Â«exprðŸ™Â») _) ((Â«exprðŸ™Â») _) g h (IsPullback.of_vert_isIso âŸ¨by simpâŸ©)\n            (IsKernelPair.id_of_mono g) âŸ¨rflâŸ© H.1 âŸ¨by simpâŸ©).mp\n        (IsPushout.of_vert_isIso âŸ¨by simpâŸ©)).1\n#align is_pushout.is_van_kampen.mono_of_mono_right is_pushout.is_van_kampen.mono_of_mono_right\n\n",
 "mono_of_mono_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprðŸ™Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprðŸ™Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprðŸ™Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprðŸ™Â» -/\ntheorem is_pushout.is_van_kampen.mono_of_mono_left [Mono f] {H : IsPushout f g h i} (H' : H.is_van_kampen) : Mono i :=\n  IsKernelPair.mono_of_isIso_fst\n    ((H' ((Â«exprðŸ™Â») _) g g ((Â«exprðŸ™Â») Y) ((Â«exprðŸ™Â») _) f ((Â«exprðŸ™Â») _) i (IsKernelPair.id_of_mono f)\n            (IsPullback.of_vert_isIso âŸ¨by simpâŸ©) H.1.flip âŸ¨rflâŸ© âŸ¨by simpâŸ©).mp\n        (IsPushout.of_horiz_isIso âŸ¨by simpâŸ©)).2\n#align is_pushout.is_van_kampen.mono_of_mono_left is_pushout.is_van_kampen.mono_of_mono_left\n\n",
 "mono_of_is_pushout_of_mono_right":
 "theorem adhesive.mono_of_is_pushout_of_mono_right [adhesive C] (H : IsPushout f g h i) [Mono g] : Mono h :=\n  (adhesive.van_kampen' H).mono_of_mono_right\n#align adhesive.mono_of_is_pushout_of_mono_right adhesive.mono_of_is_pushout_of_mono_right\n\n",
 "mono_of_is_pushout_of_mono_left":
 "theorem adhesive.mono_of_is_pushout_of_mono_left [adhesive C] (H : IsPushout f g h i) [Mono f] : Mono i :=\n  (adhesive.van_kampen H).mono_of_mono_left\n#align adhesive.mono_of_is_pushout_of_mono_left adhesive.mono_of_is_pushout_of_mono_left\n\n",
 "is_van_kampen_inl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem is_pushout.is_van_kampen_inl {W E X Z : C} (c : BinaryCofan W E) [finitary_extensive C] [HasPullbacks C]\n    (hc : IsColimit c) (f : Â«expr âŸ¶ Â» W X) (h : Â«expr âŸ¶ Â» X Z) (i : Â«expr âŸ¶ Â» c.X Z) (H : IsPushout f c.inl h i) :\n    H.is_van_kampen := by\n  obtain âŸ¨hcâ‚âŸ© := (is_coprod_iff_is_pushout c hc H.1).mpr H\n  introv W' hf hg hh hi w\n  obtain âŸ¨hcâ‚‚âŸ© :=\n    ((binary_cofan.is_van_kampen_iff _).mp (finitary_extensive.van_kampen c hc) (binary_cofan.mk _ pullback.fst) _ _ _\n          hg.w.symm pullback.condition.symm).mpr\n      âŸ¨hg, is_pullback.of_has_pullback Î±Y c.inrâŸ©\n  refine' (is_coprod_iff_is_pushout _ hcâ‚‚ w).symm.trans _\n  refine'\n    ((binary_cofan.is_van_kampen_iff _).mp (finitary_extensive.van_kampen _ hcâ‚) (binary_cofan.mk _ _) pullback.snd _ _\n          _ hh.w.symm).trans\n      _\n  Â· dsimp\n    rw [â† pullback.condition_assoc, category.assoc, hi.w]\n  constructor\n  Â· rintro âŸ¨hcâ‚ƒ, hcâ‚„âŸ©\n    refine' âŸ¨hcâ‚„, _âŸ©\n    let Y'' := pullback Î±Z i\n    let cmp : Â«expr âŸ¶ Â» Y' Y'' := pullback.lift i' Î±Y hi.w\n    have eâ‚ : Â«expr â‰« Â» (Â«expr â‰« Â» g' cmp) pullback.snd = Â«expr â‰« Â» Î±W c.inl := by\n      rw [category.assoc, pullback.lift_snd, hg.w]\n    have eâ‚‚ :\n      Â«expr â‰« Â» (Â«expr â‰« Â» pullback.fst cmp : Â«expr âŸ¶ Â» (pullback Î±Y c.inr) _) pullback.snd =\n        Â«expr â‰« Â» pullback.snd c.inr :=\n      by rw [category.assoc, pullback.lift_snd, pullback.condition]\n    obtain âŸ¨hcâ‚„âŸ© :=\n      ((binary_cofan.is_van_kampen_iff _).mp (finitary_extensive.van_kampen c hc) (binary_cofan.mk _ _) Î±W _ _ eâ‚.symm\n            eâ‚‚.symm).mpr\n        âŸ¨_, _âŸ©\n    Â· rw [â† category.id_comp Î±Z, â† show Â«expr â‰« Â» cmp pullback.snd = Î±Y from pullback.lift_snd _ _ _]\n      apply is_pullback.paste_vert _ (is_pullback.of_has_pullback Î±Z i)\n      have : cmp = (hcâ‚‚.cocone_point_unique_up_to_iso hcâ‚„).hom :=\n        by\n        apply binary_cofan.is_colimit.hom_ext hcâ‚‚\n        exacts[(hcâ‚‚.comp_cocone_point_unique_up_to_iso_hom hcâ‚„ âŸ¨walking_pair.leftâŸ©).symm,\n          (hcâ‚‚.comp_cocone_point_unique_up_to_iso_hom hcâ‚„ âŸ¨walking_pair.rightâŸ©).symm]\n      rw [this]\n      exact is_pullback.of_vert_is_iso âŸ¨by rw [â† this, category.comp_id, pullback.lift_fst]âŸ©\n    Â· apply is_pullback.of_right _ eâ‚ (is_pullback.of_has_pullback _ _)\n      rw [category.assoc, pullback.lift_fst, â† H.w, â† w.w]\n      exact hf.paste_horiz hcâ‚„\n    Â· apply is_pullback.of_right _ eâ‚‚ (is_pullback.of_has_pullback _ _)\n      rw [category.assoc, pullback.lift_fst]\n      exact hcâ‚ƒ\n  Â· rintro âŸ¨hcâ‚ƒ, hcâ‚„âŸ©\n    exact âŸ¨(is_pullback.of_has_pullback Î±Y c.inr).paste_horiz hcâ‚„, hcâ‚ƒâŸ©\n#align is_pushout.is_van_kampen_inl is_pushout.is_van_kampen_inl\n\n",
 "is_van_kampen_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\ntheorem is_pushout.is_van_kampen_iff (H : IsPushout f g h i) :\n    H.is_van_kampen â†” is_van_kampen_colimit (PushoutCocone.mk h i H.w) :=\n  by\n  constructor\n  Â· intro H F' c' Î± fÎ± eÎ± hÎ±\n    refine'\n      iff.trans _\n        ((H (F'.map walking_span.hom.fst) (F'.map walking_span.hom.snd) (c'.Î¹.app _) (c'.Î¹.app _) (Î±.app _) (Î±.app _)\n              (Î±.app _) fÎ± (by convert hÎ± walking_span.hom.fst) (by convert hÎ± walking_span.hom.snd) _ _ _).trans\n          _)\n    Â· have :\n        Â«expr â‰« Â» (F'.map walking_span.hom.fst) (c'.Î¹.app walking_span.left) =\n          Â«expr â‰« Â» (F'.map walking_span.hom.snd) (c'.Î¹.app walking_span.right) :=\n        by simp only [cocone.w]\n      rw [(is_colimit.equiv_of_nat_iso_of_iso (diagram_iso_span F') c' (pushout_cocone.mk _ _ this) _).nonempty_congr]\n      Â· exact âŸ¨fun h => âŸ¨âŸ¨thisâŸ©, hâŸ©, fun h => h.2âŸ©\n      Â· refine' cocones.ext (iso.refl c'.X) _\n        rintro (_ | _ | _) <;> dsimp <;> simp only [c'.w, category.assoc, category.id_comp, category.comp_id]\n    Â· exact âŸ¨nat_trans.congr_app eÎ±.symm _âŸ©\n    Â· exact âŸ¨nat_trans.congr_app eÎ±.symm _âŸ©\n    Â· exact âŸ¨by simpâŸ©\n    constructor\n    Â· rintro âŸ¨hâ‚, hâ‚‚âŸ© (_ | _ | _)\n      Â· rw [â† c'.w walking_span.hom.fst]\n        exact (hÎ± walking_span.hom.fst).paste_horiz hâ‚\n      exacts[hâ‚, hâ‚‚]\n    Â· intro h\n      exact âŸ¨h _, h _âŸ©\n  Â· introv H W' hf hg hh hi w\n    refine'\n      iff.trans _\n        ((H w.cocone\n              âŸ¨by\n                rintro (_ | _ | _)\n                exacts[Î±W, Î±X, Î±Y], _âŸ©\n              Î±Z _ _).trans\n          _)\n    rotate_left\n    Â· rintro i _ (_ | _ | _)\n      Â· dsimp\n        simp only [Functor.map_id, category.comp_id, category.id_comp]\n      exacts[hf.w, hg.w]\n    Â· ext (_ | _ | _)\n      Â· dsimp\n        rw [pushout_cocone.condition_zero]\n        erw [category.assoc, hh.w, hf.w_assoc]\n      exacts[hh.w.symm, hi.w.symm]\n    Â· rintro i _ (_ | _ | _)\n      Â· dsimp\n        simp_rw [Functor.map_id]\n        exact is_pullback.of_horiz_is_iso âŸ¨by rw [category.comp_id, category.id_comp]âŸ©\n      exacts[hf, hg]\n    Â· constructor\n      Â· intro h\n        exact âŸ¨h walking_cospan.left, h walking_cospan.rightâŸ©\n      Â· rintro âŸ¨hâ‚, hâ‚‚âŸ© (_ | _ | _)\n        Â· dsimp\n          rw [pushout_cocone.condition_zero]\n          exact hf.paste_horiz hâ‚\n        exacts[hâ‚, hâ‚‚]\n    Â· exact âŸ¨fun h => h.2, fun h => âŸ¨_, hâŸ©âŸ©\n#align is_pushout.is_van_kampen_iff is_pushout.is_van_kampen_iff\n\n",
 "is_pullback_of_mono_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprðŸ™Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprðŸ™Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprðŸ™Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprðŸ™Â» -/\ntheorem is_pushout.is_van_kampen.is_pullback_of_mono_right [Mono g] {H : IsPushout f g h i} (H' : H.is_van_kampen) :\n    IsPullback f g h i :=\n  ((H' f ((Â«exprðŸ™Â») _) ((Â«exprðŸ™Â») _) f ((Â«exprðŸ™Â») _) ((Â«exprðŸ™Â») _) g h (IsPullback.of_vert_isIso âŸ¨by simpâŸ©)\n          (IsKernelPair.id_of_mono g) âŸ¨rflâŸ© H.1 âŸ¨by simpâŸ©).mp\n      (IsPushout.of_vert_isIso âŸ¨by simpâŸ©)).2\n#align is_pushout.is_van_kampen.is_pullback_of_mono_right is_pushout.is_van_kampen.is_pullback_of_mono_right\n\n",
 "is_pullback_of_mono_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprðŸ™Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprðŸ™Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprðŸ™Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprðŸ™Â» -/\ntheorem is_pushout.is_van_kampen.is_pullback_of_mono_left [Mono f] {H : IsPushout f g h i} (H' : H.is_van_kampen) :\n    IsPullback f g h i :=\n  ((H' ((Â«exprðŸ™Â») _) g g ((Â«exprðŸ™Â») Y) ((Â«exprðŸ™Â») _) f ((Â«exprðŸ™Â») _) i (IsKernelPair.id_of_mono f)\n            (IsPullback.of_vert_isIso âŸ¨by simpâŸ©) H.1.flip âŸ¨rflâŸ© âŸ¨by simpâŸ©).mp\n        (IsPushout.of_horiz_isIso âŸ¨by simpâŸ©)).1.flip\n#align is_pushout.is_van_kampen.is_pullback_of_mono_left is_pushout.is_van_kampen.is_pullback_of_mono_left\n\n",
 "is_pullback_of_is_pushout_of_mono_right":
 "theorem adhesive.is_pullback_of_is_pushout_of_mono_right [adhesive C] (H : IsPushout f g h i) [Mono g] :\n    IsPullback f g h i :=\n  (adhesive.van_kampen' H).is_pullback_of_mono_right\n#align adhesive.is_pullback_of_is_pushout_of_mono_right adhesive.is_pullback_of_is_pushout_of_mono_right\n\n",
 "is_pullback_of_is_pushout_of_mono_left":
 "theorem adhesive.is_pullback_of_is_pushout_of_mono_left [adhesive C] (H : IsPushout f g h i) [Mono f] :\n    IsPullback f g h i :=\n  (adhesive.van_kampen H).is_pullback_of_mono_left\n#align adhesive.is_pullback_of_is_pushout_of_mono_left adhesive.is_pullback_of_is_pushout_of_mono_left\n\n",
 "is_coprod_iff_is_pushout":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\ntheorem is_coprod_iff_is_pushout {X E Y YE : C} (c : BinaryCofan X E) (hc : IsColimit c) {f : Â«expr âŸ¶ Â» X Y}\n    {iY : Â«expr âŸ¶ Â» Y YE} {fE : Â«expr âŸ¶ Â» c.X YE} (H : CommSq f c.inl iY fE) :\n    Nonempty (IsColimit (BinaryCofan.mk (Â«expr â‰« Â» c.inr fE) iY)) â†” IsPushout f c.inl iY fE :=\n  by\n  constructor\n  Â· rintro âŸ¨hâŸ©\n    refine' âŸ¨H, âŸ¨limits.pushout_cocone.is_colimit_aux' _ _âŸ©âŸ©\n    intro s\n    dsimp\n    refine' âŸ¨h.desc (binary_cofan.mk (Â«expr â‰« Â» c.inr s.inr) s.inl), h.fac _ âŸ¨walking_pair.rightâŸ©, _, _âŸ©\n    Â· apply binary_cofan.is_colimit.hom_ext hc\n      Â· rw [â† H.w_assoc]\n        erw [h.fac _ âŸ¨walking_pair.rightâŸ©]\n        exact s.condition\n      Â· rw [â† category.assoc]\n        exact h.fac _ âŸ¨walking_pair.leftâŸ©\n    Â· intro m eâ‚ eâ‚‚\n      apply binary_cofan.is_colimit.hom_ext h\n      Â· dsimp\n        rw [category.assoc, eâ‚‚, eq_comm]\n        exact h.fac _ âŸ¨walking_pair.leftâŸ©\n      Â· refine' eâ‚.trans (Eq.symm _)\n        exact h.fac _ _\n  Â· refine' fun H => âŸ¨_âŸ©\n    fapply limits.binary_cofan.is_colimit_mk\n    Â·\n      exact fun s =>\n        H.is_colimit.desc\n          (pushout_cocone.mk s.inr _ <| (hc.fac (binary_cofan.mk (Â«expr â‰« Â» f s.inr) s.inl) âŸ¨walking_pair.leftâŸ©).symm)\n    Â· intro s\n      erw [category.assoc, H.is_colimit.fac _ walking_span.right, hc.fac]\n      rfl\n    Â· intro s\n      exact H.is_colimit.fac _ walking_span.left\n    Â· intro s m eâ‚ eâ‚‚\n      apply pushout_cocone.is_colimit.hom_ext H.is_colimit\n      Â· symm\n        exact (H.is_colimit.fac _ walking_span.left).trans eâ‚‚.symm\n      Â· erw [H.is_colimit.fac _ walking_span.right]\n        apply binary_cofan.is_colimit.hom_ext hc\n        Â· dsimp\n          erw [hc.fac, â† H.w_assoc, eâ‚‚]\n          rfl\n        Â· refine' ((category.assoc _ _ _).symm.trans eâ‚).trans _\n          symm\n          exact hc.fac _ _\n#align is_coprod_iff_is_pushout is_coprod_iff_is_pushout\n\n",
 "flip":
 "/-\nCopyright (c) 2022 Andrew Yang. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Andrew Yang\n-/\n-- This only makes sense when the original diagram is a pushout.\ntheorem is_pushout.is_van_kampen.flip {H : IsPushout f g h i} (H' : H.is_van_kampen) : H.flip.is_van_kampen :=\n  by\n  introv W' hf hg hh hi w\n  simpa only [is_pushout.flip_iff, is_pullback.flip_iff, and_comm'] using H' g' f' i' h' Î±W Î±Y Î±X Î±Z hg hf hi hh w.flip\n#align is_pushout.is_van_kampen.flip is_pushout.is_van_kampen.flip\n\n"}