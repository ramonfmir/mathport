{"van_kampen'":
 "theorem adhesive.van_kampen' [adhesive C] [Mono g] (H : IsPushout f g h i) : H.is_van_kampen :=\n  (adhesive.van_kampen H.flip).flip\n#align adhesive.van_kampen' adhesive.van_kampen'\n\n",
 "mono_of_mono_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\ntheorem is_pushout.is_van_kampen.mono_of_mono_right [Mono g] {H : IsPushout f g h i} (H' : H.is_van_kampen) : Mono h :=\n  IsKernelPair.mono_of_isIso_fst\n    ((H' f ((«expr𝟙») _) ((«expr𝟙») _) f ((«expr𝟙») _) ((«expr𝟙») _) g h (IsPullback.of_vert_isIso ⟨by simp⟩)\n            (IsKernelPair.id_of_mono g) ⟨rfl⟩ H.1 ⟨by simp⟩).mp\n        (IsPushout.of_vert_isIso ⟨by simp⟩)).1\n#align is_pushout.is_van_kampen.mono_of_mono_right is_pushout.is_van_kampen.mono_of_mono_right\n\n",
 "mono_of_mono_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\ntheorem is_pushout.is_van_kampen.mono_of_mono_left [Mono f] {H : IsPushout f g h i} (H' : H.is_van_kampen) : Mono i :=\n  IsKernelPair.mono_of_isIso_fst\n    ((H' ((«expr𝟙») _) g g ((«expr𝟙») Y) ((«expr𝟙») _) f ((«expr𝟙») _) i (IsKernelPair.id_of_mono f)\n            (IsPullback.of_vert_isIso ⟨by simp⟩) H.1.flip ⟨rfl⟩ ⟨by simp⟩).mp\n        (IsPushout.of_horiz_isIso ⟨by simp⟩)).2\n#align is_pushout.is_van_kampen.mono_of_mono_left is_pushout.is_van_kampen.mono_of_mono_left\n\n",
 "mono_of_is_pushout_of_mono_right":
 "theorem adhesive.mono_of_is_pushout_of_mono_right [adhesive C] (H : IsPushout f g h i) [Mono g] : Mono h :=\n  (adhesive.van_kampen' H).mono_of_mono_right\n#align adhesive.mono_of_is_pushout_of_mono_right adhesive.mono_of_is_pushout_of_mono_right\n\n",
 "mono_of_is_pushout_of_mono_left":
 "theorem adhesive.mono_of_is_pushout_of_mono_left [adhesive C] (H : IsPushout f g h i) [Mono f] : Mono i :=\n  (adhesive.van_kampen H).mono_of_mono_left\n#align adhesive.mono_of_is_pushout_of_mono_left adhesive.mono_of_is_pushout_of_mono_left\n\n",
 "is_van_kampen_inl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem is_pushout.is_van_kampen_inl {W E X Z : C} (c : BinaryCofan W E) [finitary_extensive C] [HasPullbacks C]\n    (hc : IsColimit c) (f : «expr ⟶ » W X) (h : «expr ⟶ » X Z) (i : «expr ⟶ » c.X Z) (H : IsPushout f c.inl h i) :\n    H.is_van_kampen := by\n  obtain ⟨hc₁⟩ := (is_coprod_iff_is_pushout c hc H.1).mpr H\n  introv W' hf hg hh hi w\n  obtain ⟨hc₂⟩ :=\n    ((binary_cofan.is_van_kampen_iff _).mp (finitary_extensive.van_kampen c hc) (binary_cofan.mk _ pullback.fst) _ _ _\n          hg.w.symm pullback.condition.symm).mpr\n      ⟨hg, is_pullback.of_has_pullback αY c.inr⟩\n  refine' (is_coprod_iff_is_pushout _ hc₂ w).symm.trans _\n  refine'\n    ((binary_cofan.is_van_kampen_iff _).mp (finitary_extensive.van_kampen _ hc₁) (binary_cofan.mk _ _) pullback.snd _ _\n          _ hh.w.symm).trans\n      _\n  · dsimp\n    rw [← pullback.condition_assoc, category.assoc, hi.w]\n  constructor\n  · rintro ⟨hc₃, hc₄⟩\n    refine' ⟨hc₄, _⟩\n    let Y'' := pullback αZ i\n    let cmp : «expr ⟶ » Y' Y'' := pullback.lift i' αY hi.w\n    have e₁ : «expr ≫ » («expr ≫ » g' cmp) pullback.snd = «expr ≫ » αW c.inl := by\n      rw [category.assoc, pullback.lift_snd, hg.w]\n    have e₂ :\n      «expr ≫ » («expr ≫ » pullback.fst cmp : «expr ⟶ » (pullback αY c.inr) _) pullback.snd =\n        «expr ≫ » pullback.snd c.inr :=\n      by rw [category.assoc, pullback.lift_snd, pullback.condition]\n    obtain ⟨hc₄⟩ :=\n      ((binary_cofan.is_van_kampen_iff _).mp (finitary_extensive.van_kampen c hc) (binary_cofan.mk _ _) αW _ _ e₁.symm\n            e₂.symm).mpr\n        ⟨_, _⟩\n    · rw [← category.id_comp αZ, ← show «expr ≫ » cmp pullback.snd = αY from pullback.lift_snd _ _ _]\n      apply is_pullback.paste_vert _ (is_pullback.of_has_pullback αZ i)\n      have : cmp = (hc₂.cocone_point_unique_up_to_iso hc₄).hom :=\n        by\n        apply binary_cofan.is_colimit.hom_ext hc₂\n        exacts[(hc₂.comp_cocone_point_unique_up_to_iso_hom hc₄ ⟨walking_pair.left⟩).symm,\n          (hc₂.comp_cocone_point_unique_up_to_iso_hom hc₄ ⟨walking_pair.right⟩).symm]\n      rw [this]\n      exact is_pullback.of_vert_is_iso ⟨by rw [← this, category.comp_id, pullback.lift_fst]⟩\n    · apply is_pullback.of_right _ e₁ (is_pullback.of_has_pullback _ _)\n      rw [category.assoc, pullback.lift_fst, ← H.w, ← w.w]\n      exact hf.paste_horiz hc₄\n    · apply is_pullback.of_right _ e₂ (is_pullback.of_has_pullback _ _)\n      rw [category.assoc, pullback.lift_fst]\n      exact hc₃\n  · rintro ⟨hc₃, hc₄⟩\n    exact ⟨(is_pullback.of_has_pullback αY c.inr).paste_horiz hc₄, hc₃⟩\n#align is_pushout.is_van_kampen_inl is_pushout.is_van_kampen_inl\n\n",
 "is_van_kampen_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem is_pushout.is_van_kampen_iff (H : IsPushout f g h i) :\n    H.is_van_kampen ↔ is_van_kampen_colimit (PushoutCocone.mk h i H.w) :=\n  by\n  constructor\n  · intro H F' c' α fα eα hα\n    refine'\n      iff.trans _\n        ((H (F'.map walking_span.hom.fst) (F'.map walking_span.hom.snd) (c'.ι.app _) (c'.ι.app _) (α.app _) (α.app _)\n              (α.app _) fα (by convert hα walking_span.hom.fst) (by convert hα walking_span.hom.snd) _ _ _).trans\n          _)\n    · have :\n        «expr ≫ » (F'.map walking_span.hom.fst) (c'.ι.app walking_span.left) =\n          «expr ≫ » (F'.map walking_span.hom.snd) (c'.ι.app walking_span.right) :=\n        by simp only [cocone.w]\n      rw [(is_colimit.equiv_of_nat_iso_of_iso (diagram_iso_span F') c' (pushout_cocone.mk _ _ this) _).nonempty_congr]\n      · exact ⟨fun h => ⟨⟨this⟩, h⟩, fun h => h.2⟩\n      · refine' cocones.ext (iso.refl c'.X) _\n        rintro (_ | _ | _) <;> dsimp <;> simp only [c'.w, category.assoc, category.id_comp, category.comp_id]\n    · exact ⟨nat_trans.congr_app eα.symm _⟩\n    · exact ⟨nat_trans.congr_app eα.symm _⟩\n    · exact ⟨by simp⟩\n    constructor\n    · rintro ⟨h₁, h₂⟩ (_ | _ | _)\n      · rw [← c'.w walking_span.hom.fst]\n        exact (hα walking_span.hom.fst).paste_horiz h₁\n      exacts[h₁, h₂]\n    · intro h\n      exact ⟨h _, h _⟩\n  · introv H W' hf hg hh hi w\n    refine'\n      iff.trans _\n        ((H w.cocone\n              ⟨by\n                rintro (_ | _ | _)\n                exacts[αW, αX, αY], _⟩\n              αZ _ _).trans\n          _)\n    rotate_left\n    · rintro i _ (_ | _ | _)\n      · dsimp\n        simp only [Functor.map_id, category.comp_id, category.id_comp]\n      exacts[hf.w, hg.w]\n    · ext (_ | _ | _)\n      · dsimp\n        rw [pushout_cocone.condition_zero]\n        erw [category.assoc, hh.w, hf.w_assoc]\n      exacts[hh.w.symm, hi.w.symm]\n    · rintro i _ (_ | _ | _)\n      · dsimp\n        simp_rw [Functor.map_id]\n        exact is_pullback.of_horiz_is_iso ⟨by rw [category.comp_id, category.id_comp]⟩\n      exacts[hf, hg]\n    · constructor\n      · intro h\n        exact ⟨h walking_cospan.left, h walking_cospan.right⟩\n      · rintro ⟨h₁, h₂⟩ (_ | _ | _)\n        · dsimp\n          rw [pushout_cocone.condition_zero]\n          exact hf.paste_horiz h₁\n        exacts[h₁, h₂]\n    · exact ⟨fun h => h.2, fun h => ⟨_, h⟩⟩\n#align is_pushout.is_van_kampen_iff is_pushout.is_van_kampen_iff\n\n",
 "is_pullback_of_mono_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\ntheorem is_pushout.is_van_kampen.is_pullback_of_mono_right [Mono g] {H : IsPushout f g h i} (H' : H.is_van_kampen) :\n    IsPullback f g h i :=\n  ((H' f ((«expr𝟙») _) ((«expr𝟙») _) f ((«expr𝟙») _) ((«expr𝟙») _) g h (IsPullback.of_vert_isIso ⟨by simp⟩)\n          (IsKernelPair.id_of_mono g) ⟨rfl⟩ H.1 ⟨by simp⟩).mp\n      (IsPushout.of_vert_isIso ⟨by simp⟩)).2\n#align is_pushout.is_van_kampen.is_pullback_of_mono_right is_pushout.is_van_kampen.is_pullback_of_mono_right\n\n",
 "is_pullback_of_mono_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\ntheorem is_pushout.is_van_kampen.is_pullback_of_mono_left [Mono f] {H : IsPushout f g h i} (H' : H.is_van_kampen) :\n    IsPullback f g h i :=\n  ((H' ((«expr𝟙») _) g g ((«expr𝟙») Y) ((«expr𝟙») _) f ((«expr𝟙») _) i (IsKernelPair.id_of_mono f)\n            (IsPullback.of_vert_isIso ⟨by simp⟩) H.1.flip ⟨rfl⟩ ⟨by simp⟩).mp\n        (IsPushout.of_horiz_isIso ⟨by simp⟩)).1.flip\n#align is_pushout.is_van_kampen.is_pullback_of_mono_left is_pushout.is_van_kampen.is_pullback_of_mono_left\n\n",
 "is_pullback_of_is_pushout_of_mono_right":
 "theorem adhesive.is_pullback_of_is_pushout_of_mono_right [adhesive C] (H : IsPushout f g h i) [Mono g] :\n    IsPullback f g h i :=\n  (adhesive.van_kampen' H).is_pullback_of_mono_right\n#align adhesive.is_pullback_of_is_pushout_of_mono_right adhesive.is_pullback_of_is_pushout_of_mono_right\n\n",
 "is_pullback_of_is_pushout_of_mono_left":
 "theorem adhesive.is_pullback_of_is_pushout_of_mono_left [adhesive C] (H : IsPushout f g h i) [Mono f] :\n    IsPullback f g h i :=\n  (adhesive.van_kampen H).is_pullback_of_mono_left\n#align adhesive.is_pullback_of_is_pushout_of_mono_left adhesive.is_pullback_of_is_pushout_of_mono_left\n\n",
 "is_coprod_iff_is_pushout":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem is_coprod_iff_is_pushout {X E Y YE : C} (c : BinaryCofan X E) (hc : IsColimit c) {f : «expr ⟶ » X Y}\n    {iY : «expr ⟶ » Y YE} {fE : «expr ⟶ » c.X YE} (H : CommSq f c.inl iY fE) :\n    Nonempty (IsColimit (BinaryCofan.mk («expr ≫ » c.inr fE) iY)) ↔ IsPushout f c.inl iY fE :=\n  by\n  constructor\n  · rintro ⟨h⟩\n    refine' ⟨H, ⟨limits.pushout_cocone.is_colimit_aux' _ _⟩⟩\n    intro s\n    dsimp\n    refine' ⟨h.desc (binary_cofan.mk («expr ≫ » c.inr s.inr) s.inl), h.fac _ ⟨walking_pair.right⟩, _, _⟩\n    · apply binary_cofan.is_colimit.hom_ext hc\n      · rw [← H.w_assoc]\n        erw [h.fac _ ⟨walking_pair.right⟩]\n        exact s.condition\n      · rw [← category.assoc]\n        exact h.fac _ ⟨walking_pair.left⟩\n    · intro m e₁ e₂\n      apply binary_cofan.is_colimit.hom_ext h\n      · dsimp\n        rw [category.assoc, e₂, eq_comm]\n        exact h.fac _ ⟨walking_pair.left⟩\n      · refine' e₁.trans (Eq.symm _)\n        exact h.fac _ _\n  · refine' fun H => ⟨_⟩\n    fapply limits.binary_cofan.is_colimit_mk\n    ·\n      exact fun s =>\n        H.is_colimit.desc\n          (pushout_cocone.mk s.inr _ <| (hc.fac (binary_cofan.mk («expr ≫ » f s.inr) s.inl) ⟨walking_pair.left⟩).symm)\n    · intro s\n      erw [category.assoc, H.is_colimit.fac _ walking_span.right, hc.fac]\n      rfl\n    · intro s\n      exact H.is_colimit.fac _ walking_span.left\n    · intro s m e₁ e₂\n      apply pushout_cocone.is_colimit.hom_ext H.is_colimit\n      · symm\n        exact (H.is_colimit.fac _ walking_span.left).trans e₂.symm\n      · erw [H.is_colimit.fac _ walking_span.right]\n        apply binary_cofan.is_colimit.hom_ext hc\n        · dsimp\n          erw [hc.fac, ← H.w_assoc, e₂]\n          rfl\n        · refine' ((category.assoc _ _ _).symm.trans e₁).trans _\n          symm\n          exact hc.fac _ _\n#align is_coprod_iff_is_pushout is_coprod_iff_is_pushout\n\n",
 "flip":
 "/-\nCopyright (c) 2022 Andrew Yang. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Andrew Yang\n-/\n-- This only makes sense when the original diagram is a pushout.\ntheorem is_pushout.is_van_kampen.flip {H : IsPushout f g h i} (H' : H.is_van_kampen) : H.flip.is_van_kampen :=\n  by\n  introv W' hf hg hh hi w\n  simpa only [is_pushout.flip_iff, is_pullback.flip_iff, and_comm'] using H' g' f' i' h' αW αY αX αZ hg hf hi hh w.flip\n#align is_pushout.is_van_kampen.flip is_pushout.is_van_kampen.flip\n\n"}