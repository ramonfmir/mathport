{"right_derived_zero_to_self_natural":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/-- Given `P : InjectiveResolution X` and `Q : InjectiveResolution Y` and a morphism `f : X ⟶ Y`,\nnaturality of the square given by `right_derived_zero_to_self_natural`. -/\ntheorem right_derived_zero_to_self_natural [enough_injectives C] {X : C} {Y : C} (f : «expr ⟶ » X Y)\n    (P : InjectiveResolution X) (Q : InjectiveResolution Y) :\n    «expr ≫ » (F.map f) (right_derived_zero_to_self_app_inv F Q) =\n      «expr ≫ » (right_derived_zero_to_self_app_inv F P) ((F.right_derived 0).map f) :=\n  by\n  dsimp [right_derived_zero_to_self_app_inv]\n  simp only [category_theory.functor.map_id, category.id_comp, ← category.assoc]\n  rw [iso.comp_inv_eq, right_derived_map_eq F 0 f (InjectiveResolution.desc f Q P) (by simp), category.assoc,\n    category.assoc, category.assoc, category.assoc, iso.inv_hom_id, category.comp_id, ←\n    category.assoc (F.right_derived_obj_iso 0 P).inv, iso.inv_hom_id, category.id_comp]\n  dsimp only [homology_functor_map]\n  ext\n  rw [category.assoc, homology.lift_ι, category.assoc, homology.map_ι, ← category.assoc (homology.lift _ _ _ _ _) _ _,\n    homology.lift_ι, category.assoc, cokernel.π_desc, ← category.assoc, ← functor.map_comp, ← category.assoc,\n    homological_complex.hom.sq_from_left, map_homological_complex_map_f, ← functor.map_comp,\n    show «expr ≫ » f (Q.ι.f 0) = «expr ≫ » (P.ι.f 0) ((InjectiveResolution.desc f Q P).f 0) from\n      homological_complex.congr_hom (InjectiveResolution.desc_commutes f Q P).symm 0]\n#align right_derived_zero_to_self_natural right_derived_zero_to_self_natural\n\n",
 "right_derived_zero_to_self_app_inv_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\ntheorem right_derived_zero_to_self_app_inv_comp [enough_injectives C] [preserves_finite_limits F] {X : C}\n    (P : InjectiveResolution X) :\n    «expr ≫ » (right_derived_zero_to_self_app_inv F P) (right_derived_zero_to_self_app F P) = («expr𝟙») _ :=\n  by\n  dsimp [right_derived_zero_to_self_app, right_derived_zero_to_self_app_inv]\n  rw [← category.assoc _ (F.right_derived_obj_iso 0 P).hom, category.assoc _ _ (F.right_derived_obj_iso 0 P).hom,\n    iso.inv_hom_id, category.comp_id, ← category.assoc, ← category.assoc, is_iso.comp_inv_eq, category.id_comp]\n  ext\n  simp only [limits.kernel.lift_ι_assoc, category.assoc, limits.kernel.lift_ι, homology.lift]\n  rw [← category.assoc, ← category.assoc, category.assoc _ _ (homology_iso_kernel_desc _ _ _).hom]\n  simp\n#align right_derived_zero_to_self_app_inv_comp right_derived_zero_to_self_app_inv_comp\n\n",
 "right_derived_zero_to_self_app_comp_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\ntheorem right_derived_zero_to_self_app_comp_inv [enough_injectives C] [preserves_finite_limits F] {X : C}\n    (P : InjectiveResolution X) :\n    «expr ≫ » (right_derived_zero_to_self_app F P) (right_derived_zero_to_self_app_inv F P) = («expr𝟙») _ :=\n  by\n  dsimp [right_derived_zero_to_self_app, right_derived_zero_to_self_app_inv]\n  rw [← category.assoc, iso.comp_inv_eq, category.id_comp, category.assoc, category.assoc, ← iso.eq_inv_comp,\n    iso.inv_hom_id]\n  ext\n  rw [category.assoc, category.assoc, homology.lift_ι, category.id_comp, homology.π'_ι, category.assoc, ←\n    category.assoc _ _ (cokernel.π _), abelian.kernel.lift.inv, ← category.assoc, ← category.assoc _ (kernel.ι _),\n    limits.kernel.lift_ι, category.assoc, category.assoc, ← category.assoc (homology_iso_kernel_desc _ _ _).hom _ _, ←\n    homology.ι, ← category.assoc, homology.π'_ι, category.assoc, ← category.assoc (cokernel.π _), cokernel.π_desc,\n    whisker_eq]\n  convert category.id_comp (cokernel.π _)\n#align right_derived_zero_to_self_app_comp_inv right_derived_zero_to_self_app_comp_inv\n\n",
 "right_derived_map_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/-\nCopyright (c) 2022 Jujian Zhang. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Jujian Zhang, Scott Morrison\n-/\n/-- We can compute a right derived functor on a morphism using a descent of that morphism\nto a cochain map between chosen injective resolutions.\n-/\ntheorem functor.right_derived_map_eq (F : «expr ⥤ » C D) [F.additive] (n : ℕ) {X Y : C} (f : «expr ⟶ » Y X)\n    {P : InjectiveResolution X} {Q : InjectiveResolution Y} (g : «expr ⟶ » Q.cocomplex P.cocomplex)\n    (w : «expr ≫ » Q.ι g = «expr ≫ » ((cochain_complex.single₀ C).map f) P.ι) :\n    (F.right_derived n).map f =\n      «expr ≫ » (F.right_derived_obj_iso n Q).hom\n        («expr ≫ » ((homology_functor D _ n).map ((F.map_homological_complex _).map g))\n          (F.right_derived_obj_iso n P).inv) :=\n  by\n  dsimp only [functor.right_derived, functor.right_derived_obj_iso]\n  dsimp; simp only [category.comp_id, category.id_comp]\n  rw [← homology_functor_map, homotopy_category.homology_functor_map_factors]\n  simp only [← functor.map_comp]\n  congr 1\n  apply homotopy_category.eq_of_homotopy\n  apply functor.map_homotopy\n  apply homotopy.trans\n  exact homotopy_category.homotopy_out_map _\n  apply InjectiveResolution.desc_homotopy f\n  · simp\n  · simp only [InjectiveResolution.homotopy_equiv_hom_ι_assoc]\n    rw [← category.assoc, w, category.assoc]\n    simp only [InjectiveResolution.homotopy_equiv_inv_ι]\n#align functor.right_derived_map_eq functor.right_derived_map_eq\n\n",
 "right_derived_id":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n@[simp]\ntheorem nat_trans.right_derived_id (F : «expr ⥤ » C D) [F.additive] (n : ℕ) :\n    nat_trans.right_derived ((«expr𝟙») F) n = («expr𝟙») (F.right_derived n) :=\n  by\n  simp [nat_trans.right_derived]\n  rfl\n#align nat_trans.right_derived_id nat_trans.right_derived_id\n\n",
 "right_derived_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/-- A component of the natural transformation between right-derived functors can be computed\nusing a chosen injective resolution.\n-/\ntheorem nat_trans.right_derived_eq {F G : «expr ⥤ » C D} [F.additive] [G.additive] (α : «expr ⟶ » F G) (n : ℕ) {X : C}\n    (P : InjectiveResolution X) :\n    (nat_trans.right_derived α n).app X =\n      «expr ≫ » (F.right_derived_obj_iso n P).hom\n        («expr ≫ » ((homology_functor D _ n).map ((nat_trans.map_homological_complex α _).app P.cocomplex))\n          (G.right_derived_obj_iso n P).inv) :=\n  by\n  symm\n  dsimp [nat_trans.right_derived, functor.right_derived_obj_iso]\n  simp only [category.comp_id, category.id_comp]\n  rw [← homology_functor_map, homotopy_category.homology_functor_map_factors]\n  simp only [← functor.map_comp]\n  congr 1\n  apply homotopy_category.eq_of_homotopy\n  simp only [nat_trans.map_homological_complex_naturality_assoc, ← functor.map_comp]\n  apply homotopy.comp_left_id\n  rw [← Functor.map_id]\n  apply functor.map_homotopy\n  apply homotopy_equiv.homotopy_hom_inv_id\n#align nat_trans.right_derived_eq nat_trans.right_derived_eq\n\n",
 "right_derived_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, nolint simp_nf]\ntheorem nat_trans.right_derived_comp {F G H : «expr ⥤ » C D} [F.additive] [G.additive] [H.additive] (α : «expr ⟶ » F G)\n    (β : «expr ⟶ » G H) (n : ℕ) :\n    nat_trans.right_derived («expr ≫ » α β) n = «expr ≫ » (nat_trans.right_derived α n) (nat_trans.right_derived β n) :=\n  by simp [nat_trans.right_derived]\n#align nat_trans.right_derived_comp nat_trans.right_derived_comp\n\n",
 "preserves_exact_of_preserves_finite_limits_of_mono":
 "/-- If `preserves_finite_limits F` and `mono f`, then `exact (F.map f) (F.map g)` if\n`exact f g`. -/\ntheorem preserves_exact_of_preserves_finite_limits_of_mono [preserves_finite_limits F] [Mono f] (ex : exact f g) :\n    exact (F.map f) (F.map g) :=\n  abelian.exact_of_is_kernel _ _ (by simp [← functor.map_comp, ex.w]) <|\n    limits.is_limit_fork_map_of_is_limit' _ ex.w (abelian.is_limit_of_exact_of_mono _ _ ex)\n#align preserves_exact_of_preserves_finite_limits_of_mono preserves_exact_of_preserves_finite_limits_of_mono\n\n",
 "exact_of_map_injective_resolution":
 "theorem exact_of_map_injective_resolution (P : InjectiveResolution X) [preserves_finite_limits F] :\n    exact (F.map (P.ι.f 0)) (((F.map_homological_complex (complex_shape.up ℕ)).obj P.cocomplex).d_from 0) :=\n  preadditive.exact_of_iso_of_exact' (F.map (P.ι.f 0)) (F.map (P.cocomplex.d 0 1)) _ _ (Iso.refl _) (Iso.refl _)\n    (homological_complex.X_next_iso ((F.map_homological_complex _).obj P.cocomplex) rfl).symm (by simp)\n    (by rw [iso.refl_hom, category.id_comp, iso.symm_hom, homological_complex.d_from_eq] <;> congr )\n    (preserves_exact_of_preserves_finite_limits_of_mono _ P.exact₀)\n#align exact_of_map_injective_resolution exact_of_map_injective_resolution\n\n"}