{"right_derived_zero_to_self_natural":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/-- Given `P : InjectiveResolution X` and `Q : InjectiveResolution Y` and a morphism `f : X âŸ¶ Y`,\nnaturality of the square given by `right_derived_zero_to_self_natural`. -/\ntheorem right_derived_zero_to_self_natural [enough_injectives C] {X : C} {Y : C} (f : Â«expr âŸ¶ Â» X Y)\n    (P : InjectiveResolution X) (Q : InjectiveResolution Y) :\n    Â«expr â‰« Â» (F.map f) (right_derived_zero_to_self_app_inv F Q) =\n      Â«expr â‰« Â» (right_derived_zero_to_self_app_inv F P) ((F.right_derived 0).map f) :=\n  by\n  dsimp [right_derived_zero_to_self_app_inv]\n  simp only [category_theory.functor.map_id, category.id_comp, â† category.assoc]\n  rw [iso.comp_inv_eq, right_derived_map_eq F 0 f (InjectiveResolution.desc f Q P) (by simp), category.assoc,\n    category.assoc, category.assoc, category.assoc, iso.inv_hom_id, category.comp_id, â†\n    category.assoc (F.right_derived_obj_iso 0 P).inv, iso.inv_hom_id, category.id_comp]\n  dsimp only [homology_functor_map]\n  ext\n  rw [category.assoc, homology.lift_Î¹, category.assoc, homology.map_Î¹, â† category.assoc (homology.lift _ _ _ _ _) _ _,\n    homology.lift_Î¹, category.assoc, cokernel.Ï€_desc, â† category.assoc, â† functor.map_comp, â† category.assoc,\n    homological_complex.hom.sq_from_left, map_homological_complex_map_f, â† functor.map_comp,\n    show Â«expr â‰« Â» f (Q.Î¹.f 0) = Â«expr â‰« Â» (P.Î¹.f 0) ((InjectiveResolution.desc f Q P).f 0) from\n      homological_complex.congr_hom (InjectiveResolution.desc_commutes f Q P).symm 0]\n#align right_derived_zero_to_self_natural right_derived_zero_to_self_natural\n\n",
 "right_derived_zero_to_self_app_inv_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\ntheorem right_derived_zero_to_self_app_inv_comp [enough_injectives C] [preserves_finite_limits F] {X : C}\n    (P : InjectiveResolution X) :\n    Â«expr â‰« Â» (right_derived_zero_to_self_app_inv F P) (right_derived_zero_to_self_app F P) = (Â«exprğŸ™Â») _ :=\n  by\n  dsimp [right_derived_zero_to_self_app, right_derived_zero_to_self_app_inv]\n  rw [â† category.assoc _ (F.right_derived_obj_iso 0 P).hom, category.assoc _ _ (F.right_derived_obj_iso 0 P).hom,\n    iso.inv_hom_id, category.comp_id, â† category.assoc, â† category.assoc, is_iso.comp_inv_eq, category.id_comp]\n  ext\n  simp only [limits.kernel.lift_Î¹_assoc, category.assoc, limits.kernel.lift_Î¹, homology.lift]\n  rw [â† category.assoc, â† category.assoc, category.assoc _ _ (homology_iso_kernel_desc _ _ _).hom]\n  simp\n#align right_derived_zero_to_self_app_inv_comp right_derived_zero_to_self_app_inv_comp\n\n",
 "right_derived_zero_to_self_app_comp_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\ntheorem right_derived_zero_to_self_app_comp_inv [enough_injectives C] [preserves_finite_limits F] {X : C}\n    (P : InjectiveResolution X) :\n    Â«expr â‰« Â» (right_derived_zero_to_self_app F P) (right_derived_zero_to_self_app_inv F P) = (Â«exprğŸ™Â») _ :=\n  by\n  dsimp [right_derived_zero_to_self_app, right_derived_zero_to_self_app_inv]\n  rw [â† category.assoc, iso.comp_inv_eq, category.id_comp, category.assoc, category.assoc, â† iso.eq_inv_comp,\n    iso.inv_hom_id]\n  ext\n  rw [category.assoc, category.assoc, homology.lift_Î¹, category.id_comp, homology.Ï€'_Î¹, category.assoc, â†\n    category.assoc _ _ (cokernel.Ï€ _), abelian.kernel.lift.inv, â† category.assoc, â† category.assoc _ (kernel.Î¹ _),\n    limits.kernel.lift_Î¹, category.assoc, category.assoc, â† category.assoc (homology_iso_kernel_desc _ _ _).hom _ _, â†\n    homology.Î¹, â† category.assoc, homology.Ï€'_Î¹, category.assoc, â† category.assoc (cokernel.Ï€ _), cokernel.Ï€_desc,\n    whisker_eq]\n  convert category.id_comp (cokernel.Ï€ _)\n#align right_derived_zero_to_self_app_comp_inv right_derived_zero_to_self_app_comp_inv\n\n",
 "right_derived_map_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/-\nCopyright (c) 2022 Jujian Zhang. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Jujian Zhang, Scott Morrison\n-/\n/-- We can compute a right derived functor on a morphism using a descent of that morphism\nto a cochain map between chosen injective resolutions.\n-/\ntheorem functor.right_derived_map_eq (F : Â«expr â¥¤ Â» C D) [F.additive] (n : â„•) {X Y : C} (f : Â«expr âŸ¶ Â» Y X)\n    {P : InjectiveResolution X} {Q : InjectiveResolution Y} (g : Â«expr âŸ¶ Â» Q.cocomplex P.cocomplex)\n    (w : Â«expr â‰« Â» Q.Î¹ g = Â«expr â‰« Â» ((cochain_complex.singleâ‚€ C).map f) P.Î¹) :\n    (F.right_derived n).map f =\n      Â«expr â‰« Â» (F.right_derived_obj_iso n Q).hom\n        (Â«expr â‰« Â» ((homology_functor D _ n).map ((F.map_homological_complex _).map g))\n          (F.right_derived_obj_iso n P).inv) :=\n  by\n  dsimp only [functor.right_derived, functor.right_derived_obj_iso]\n  dsimp; simp only [category.comp_id, category.id_comp]\n  rw [â† homology_functor_map, homotopy_category.homology_functor_map_factors]\n  simp only [â† functor.map_comp]\n  congr 1\n  apply homotopy_category.eq_of_homotopy\n  apply functor.map_homotopy\n  apply homotopy.trans\n  exact homotopy_category.homotopy_out_map _\n  apply InjectiveResolution.desc_homotopy f\n  Â· simp\n  Â· simp only [InjectiveResolution.homotopy_equiv_hom_Î¹_assoc]\n    rw [â† category.assoc, w, category.assoc]\n    simp only [InjectiveResolution.homotopy_equiv_inv_Î¹]\n#align functor.right_derived_map_eq functor.right_derived_map_eq\n\n",
 "right_derived_id":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n@[simp]\ntheorem nat_trans.right_derived_id (F : Â«expr â¥¤ Â» C D) [F.additive] (n : â„•) :\n    nat_trans.right_derived ((Â«exprğŸ™Â») F) n = (Â«exprğŸ™Â») (F.right_derived n) :=\n  by\n  simp [nat_trans.right_derived]\n  rfl\n#align nat_trans.right_derived_id nat_trans.right_derived_id\n\n",
 "right_derived_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/-- A component of the natural transformation between right-derived functors can be computed\nusing a chosen injective resolution.\n-/\ntheorem nat_trans.right_derived_eq {F G : Â«expr â¥¤ Â» C D} [F.additive] [G.additive] (Î± : Â«expr âŸ¶ Â» F G) (n : â„•) {X : C}\n    (P : InjectiveResolution X) :\n    (nat_trans.right_derived Î± n).app X =\n      Â«expr â‰« Â» (F.right_derived_obj_iso n P).hom\n        (Â«expr â‰« Â» ((homology_functor D _ n).map ((nat_trans.map_homological_complex Î± _).app P.cocomplex))\n          (G.right_derived_obj_iso n P).inv) :=\n  by\n  symm\n  dsimp [nat_trans.right_derived, functor.right_derived_obj_iso]\n  simp only [category.comp_id, category.id_comp]\n  rw [â† homology_functor_map, homotopy_category.homology_functor_map_factors]\n  simp only [â† functor.map_comp]\n  congr 1\n  apply homotopy_category.eq_of_homotopy\n  simp only [nat_trans.map_homological_complex_naturality_assoc, â† functor.map_comp]\n  apply homotopy.comp_left_id\n  rw [â† Functor.map_id]\n  apply functor.map_homotopy\n  apply homotopy_equiv.homotopy_hom_inv_id\n#align nat_trans.right_derived_eq nat_trans.right_derived_eq\n\n",
 "right_derived_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n@[simp, nolint simp_nf]\ntheorem nat_trans.right_derived_comp {F G H : Â«expr â¥¤ Â» C D} [F.additive] [G.additive] [H.additive] (Î± : Â«expr âŸ¶ Â» F G)\n    (Î² : Â«expr âŸ¶ Â» G H) (n : â„•) :\n    nat_trans.right_derived (Â«expr â‰« Â» Î± Î²) n = Â«expr â‰« Â» (nat_trans.right_derived Î± n) (nat_trans.right_derived Î² n) :=\n  by simp [nat_trans.right_derived]\n#align nat_trans.right_derived_comp nat_trans.right_derived_comp\n\n",
 "preserves_exact_of_preserves_finite_limits_of_mono":
 "/-- If `preserves_finite_limits F` and `mono f`, then `exact (F.map f) (F.map g)` if\n`exact f g`. -/\ntheorem preserves_exact_of_preserves_finite_limits_of_mono [preserves_finite_limits F] [Mono f] (ex : exact f g) :\n    exact (F.map f) (F.map g) :=\n  abelian.exact_of_is_kernel _ _ (by simp [â† functor.map_comp, ex.w]) <|\n    limits.is_limit_fork_map_of_is_limit' _ ex.w (abelian.is_limit_of_exact_of_mono _ _ ex)\n#align preserves_exact_of_preserves_finite_limits_of_mono preserves_exact_of_preserves_finite_limits_of_mono\n\n",
 "exact_of_map_injective_resolution":
 "theorem exact_of_map_injective_resolution (P : InjectiveResolution X) [preserves_finite_limits F] :\n    exact (F.map (P.Î¹.f 0)) (((F.map_homological_complex (complex_shape.up â„•)).obj P.cocomplex).d_from 0) :=\n  preadditive.exact_of_iso_of_exact' (F.map (P.Î¹.f 0)) (F.map (P.cocomplex.d 0 1)) _ _ (Iso.refl _) (Iso.refl _)\n    (homological_complex.X_next_iso ((F.map_homological_complex _).obj P.cocomplex) rfl).symm (by simp)\n    (by rw [iso.refl_hom, category.id_comp, iso.symm_hom, homological_complex.d_from_eq] <;> congr )\n    (preserves_exact_of_preserves_finite_limits_of_mono _ P.exactâ‚€)\n#align exact_of_map_injective_resolution exact_of_map_injective_resolution\n\n"}