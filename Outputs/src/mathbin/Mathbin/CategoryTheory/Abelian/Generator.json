{"has_projective_separator":
 "theorem has_projective_separator [has_colimits C] [enough_projectives C] (G : C) (hG : is_coseparator G) :\n    ∃ G : C, projective G ∧ is_separator G :=\n  by\n  obtain ⟨T, hT₁, hT₂⟩ := has_injective_coseparator (op G) ((is_separator_op_iff _).2 hG)\n  exact ⟨unop T, infer_instance, (is_separator_unop_iff _).2 hT₂⟩\n#align has_projective_separator has_projective_separator\n\n",
 "has_injective_coseparator":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵖ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/-\nCopyright (c) 2022 Markus Himmel. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Markus Himmel\n-/\ntheorem has_injective_coseparator [has_limits C] [enough_injectives C] (G : C) (hG : is_separator G) :\n    ∃ G : C, injective G ∧ is_coseparator G :=\n  by\n  haveI : well_powered C := well_powered_of_is_detector G hG.is_detector\n  haveI : has_products_of_shape (subobject (op G)) C := has_products_of_shape_of_small _ _\n  let T : C := injective.under (pi_obj fun P : subobject (op G) => unop P)\n  refine' ⟨T, infer_instance, (preadditive.is_coseparator_iff _).2 fun X Y f hf => _⟩\n  refine' (preadditive.is_separator_iff _).1 hG _ fun h => _\n  suffices hh : factor_thru_image («expr ≫ » h f) = 0\n  · rw [← limits.image.fac («expr ≫ » h f), hh, zero_comp]\n  let R := subobject.mk (factor_thru_image («expr ≫ » h f)).op\n  let q₁ : «expr ⟶ » (image («expr ≫ » h f)) (unop R) :=\n    (subobject.underlying_iso (factor_thru_image («expr ≫ » h f)).op).unop.hom\n  let q₂ : «expr ⟶ » (unop (R : «expr ᵒᵖ» C)) (pi_obj fun P : subobject (op G) => unop P) :=\n    section_ (pi.π (fun P : subobject (op G) => unop P) R)\n  let q : «expr ⟶ » (image («expr ≫ » h f)) T := «expr ≫ » q₁ («expr ≫ » q₂ (injective.ι _))\n  exact\n    zero_of_comp_mono q\n      (by\n        rw [← injective.comp_factor_thru q (limits.image.ι («expr ≫ » h f)), limits.image.fac_assoc, category.assoc, hf,\n          comp_zero])\n#align has_injective_coseparator has_injective_coseparator\n\n"}