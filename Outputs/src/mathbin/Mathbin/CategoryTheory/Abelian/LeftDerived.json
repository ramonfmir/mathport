{"preserves_exact_of_preserves_finite_colimits_of_epi":
 "/-\nCopyright (c) 2022 Riccardo Brasca. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Riccardo Brasca, Adam Topaz\n-/\n/-- If `preserves_finite_colimits F` and `epi g`, then `exact (F.map f) (F.map g)` if\n`exact f g`. -/\ntheorem preserves_exact_of_preserves_finite_colimits_of_epi [PreservesFiniteColimits F] [Epi g] (ex : Exact f g) :\n    Exact (F.map f) (F.map g) :=\n  Abelian.exact_of_is_cokernel _ _ (by simp [‚Üê functor.map_comp, ex.w]) <|\n    Limits.isColimitCoforkMapOfIsColimit' _ ex.w (Abelian.isColimitOfExactOfEpi _ _ ex)\n#align preserves_exact_of_preserves_finite_colimits_of_epi preserves_exact_of_preserves_finite_colimits_of_epi\n\n",
 "left_derived_zero_to_self_natural":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚â´ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚â´ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚ü∂ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚â´ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚â´ ¬ª -/\n/-- Given `P : ProjectiveResolution X` and `Q : ProjectiveResolution Y` and a morphism `f : X ‚ü∂ Y`,\nnaturality of the square given by `left_derived_zero_to_self_obj_hom. -/\ntheorem left_derived_zero_to_self_natural [EnoughProjectives C] {X : C} {Y : C} (f : ¬´expr ‚ü∂ ¬ª X Y)\n    (P : ProjectiveResolution X) (Q : ProjectiveResolution Y) :\n    ¬´expr ‚â´ ¬ª ((F.left_derived 0).map f) (left_derived_zero_to_self_app F Q) =\n      ¬´expr ‚â´ ¬ª (left_derived_zero_to_self_app F P) (F.map f) :=\n  by\n  dsimp only [left_derived_zero_to_self_app]\n  rw [functor.left_derived_map_eq F 0 f (ProjectiveResolution.lift f P Q) (by simp), category.assoc, category.assoc, ‚Üê\n    category.assoc _ (F.left_derived_obj_iso 0 Q).hom, iso.inv_hom_id, category.id_comp, category.assoc, whisker_eq]\n  dsimp only [homology_functor_map]\n  ext\n  simp only [HomologicalComplex.Hom.sqTo_right, map_homological_complex_map_f, homology.œÄ'_map_assoc, homology.œÄ'_desc',\n    kernel.lift_Œπ_assoc, category.assoc, homology.œÄ'_desc'_assoc, ‚Üê map_comp,\n    show ¬´expr ‚â´ ¬ª ((ProjectiveResolution.lift f P Q).f 0) _ = ¬´expr ‚â´ ¬ª _ f from\n      HomologicalComplex.congr_hom (ProjectiveResolution.lift_commutes f P Q) 0]\n#align left_derived_zero_to_self_natural left_derived_zero_to_self_natural\n\n",
 "left_derived_zero_to_self_app_inv_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚â´ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´exprùüô¬ª -/\ntheorem left_derived_zero_to_self_app_inv_comp [EnoughProjectives C] [PreservesFiniteColimits F] {X : C}\n    (P : ProjectiveResolution X) :\n    ¬´expr ‚â´ ¬ª (left_derived_zero_to_self_app_inv F P) (left_derived_zero_to_self_app F P) = (¬´exprùüô¬ª) _ :=\n  by\n  dsimp [left_derived_zero_to_self_app, left_derived_zero_to_self_app_inv]\n  rw [category.assoc, category.assoc, category.assoc, ‚Üê category.assoc (F.left_derived_obj_iso 0 P).inv, iso.inv_hom_id,\n    category.id_comp, is_iso.inv_comp_eq, category.comp_id]\n  ext\n  simp only [cokernel.œÄ_desc_assoc, category.assoc, cokernel.œÄ_desc, homology.desc']\n  rw [‚Üê category.assoc, ‚Üê category.assoc (homologyIsoCokernelLift _ _ _).inv, iso.inv_hom_id, category.id_comp]\n  simp only [category.assoc, cokernel.œÄ_desc, kernel.lift_Œπ_assoc, category.id_comp]\n#align left_derived_zero_to_self_app_inv_comp left_derived_zero_to_self_app_inv_comp\n\n",
 "left_derived_zero_to_self_app_comp_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚â´ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´exprùüô¬ª -/\ntheorem left_derived_zero_to_self_app_comp_inv [EnoughProjectives C] [PreservesFiniteColimits F] {X : C}\n    (P : ProjectiveResolution X) :\n    ¬´expr ‚â´ ¬ª (left_derived_zero_to_self_app F P) (left_derived_zero_to_self_app_inv F P) = (¬´exprùüô¬ª) _ :=\n  by\n  dsimp [left_derived_zero_to_self_app, left_derived_zero_to_self_app_inv]\n  rw [‚Üê category.assoc, ‚Üê category.assoc, ‚Üê category.assoc, iso.comp_inv_eq, category.id_comp, category.assoc,\n    category.assoc, category.assoc]\n  convert category.comp_id _\n  rw [‚Üê category.assoc, ‚Üê category.assoc, iso.comp_inv_eq, category.id_comp]\n  ext\n  rw [‚Üê category.assoc, ‚Üê category.assoc, homology.œÄ'_desc', category.assoc, category.assoc, ‚Üê category.assoc (F.map _),\n    abelian.cokernel.desc.inv, cokernel.œÄ_desc, homology.œÄ', category.assoc, iso.inv_hom_id, category.comp_id, ‚Üê\n    category.assoc]\n  convert category.id_comp _ using 2\n  ext\n  rw [category.id_comp, category.assoc, equalizer_as_kernel, kernel.lift_Œπ, category.comp_id]\n#align left_derived_zero_to_self_app_comp_inv left_derived_zero_to_self_app_comp_inv\n\n",
 "exact_of_map_projective_resolution":
 "theorem exact_of_map_projective_resolution (P : ProjectiveResolution X) [PreservesFiniteColimits F] :\n    Exact (((F.map_homological_complex (ComplexShape.down ‚Ñï)).obj P.complex).d_to 0) (F.map (P.œÄ.f 0)) :=\n  Preadditive.exact_of_iso_of_exact' (F.map (P.complex.d 1 0)) (F.map (P.œÄ.f 0)) _ _\n    (HomologicalComplex.xPrevIso ((F.map_homological_complex _).obj P.complex) rfl).symm (Iso.refl _) (Iso.refl _)\n    (by simp) (by simp) (preserves_exact_of_preserves_finite_colimits_of_epi _ P.exact‚ÇÄ)\n#align exact_of_map_projective_resolution exact_of_map_projective_resolution\n\n"}