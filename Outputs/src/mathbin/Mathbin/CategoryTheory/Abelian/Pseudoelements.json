{"zero_of_map_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/-- A morphism that is injective on pseudoelements only maps the zero element to zero. -/\ntheorem zero_of_map_zero {P Q : C} (f : Â«expr âŸ¶ Â» P Q) : function.injective f â†’ âˆ€ a, f a = 0 â†’ a = 0 := fun h a ha =>\n  by\n  rw [â† apply_zero f] at ha\n  exact h ha\n#align zero_of_map_zero zero_of_map_zero\n\n",
 "zero_morphism_ext'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem zero_morphism_ext' {P Q : C} (f : Â«expr âŸ¶ Â» P Q) : (âˆ€ a, f a = 0) â†’ 0 = f :=\n  eq.symm âˆ˜ zero_morphism_ext f\n#align zero_morphism_ext' zero_morphism_ext'\n\n",
 "zero_morphism_ext":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/-- An extensionality lemma for being the zero arrow. -/\ntheorem zero_morphism_ext {P Q : C} (f : Â«expr âŸ¶ Â» P Q) : (âˆ€ a, f a = 0) â†’ f = 0 := fun h =>\n  by\n  rw [â† category.id_comp f]\n  exact (pseudo_zero_iff (Â«expr â‰« Â» ((Â«exprğŸ™Â») P) f : over Q)).1 (h ((Â«exprğŸ™Â») P))\n#align zero_morphism_ext zero_morphism_ext\n\n",
 "zero_eq_zero'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŸ¦ âŸ§Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŸ¦ âŸ§Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem zero_eq_zero' {P Q R : C} :\n    Â«exprâŸ¦ âŸ§Â» ((0 : Â«expr âŸ¶ Â» Q P) : over P) = Â«exprâŸ¦ âŸ§Â» ((0 : Â«expr âŸ¶ Â» R P) : over P) :=\n  quotient.sound <| (pseudo_zero_aux R _).2 rfl\n#align zero_eq_zero' zero_eq_zero'\n\n",
 "zero_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŸ¦ âŸ§Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n@[simp]\ntheorem zero_eq_zero {P Q : C} : Â«exprâŸ¦ âŸ§Â» ((0 : Â«expr âŸ¶ Â» Q P) : over P) = (0 : pseudoelement P) :=\n  zero_eq_zero'\n#align zero_eq_zero zero_eq_zero\n\n",
 "zero_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/-- The zero morphism maps every pseudoelement to 0. -/\n@[simp]\ntheorem zero_apply {P : C} (Q : C) (a : P) : (0 : Â«expr âŸ¶ Â» P Q) a = 0 :=\n  Quotient.inductionOn a fun a' => by\n    rw [pseudo_zero_def, pseudo_apply_mk]\n    simp\n#align zero_apply zero_apply\n\n",
 "sub_of_eq_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŸ¦ âŸ§Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŸ¦ âŸ§Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/-- If two pseudoelements `x` and `y` have the same image under some morphism `f`, then we can form\n    their \"difference\" `z`. This pseudoelement has the properties that `f z = 0` and for all\n    morphisms `g`, if `g y = 0` then `g z = g x`. -/\ntheorem sub_of_eq_image {P Q : C} (f : Â«expr âŸ¶ Â» P Q) (x y : P) :\n    f x = f y â†’ âˆƒ z, f z = 0 âˆ§ âˆ€ (R : C) (g : Â«expr âŸ¶ Â» P R), (g : Â«expr âŸ¶ Â» P R) y = 0 â†’ g z = g x :=\n  quotient.induction_onâ‚‚ x y fun a a' h =>\n    match quotient.exact h with\n    | âŸ¨R, p, q, ep, eq, commâŸ© =>\n      let a'' : Â«expr âŸ¶ Â» R P := Â«expr â‰« Â» p a.hom - Â«expr â‰« Â» q a'.hom\n      âŸ¨a'',\n        âŸ¨show Â«exprâŸ¦ âŸ§Â» (Â«expr â‰« Â» (Â«expr â‰« Â» p a.hom - Â«expr â‰« Â» q a'.hom) f : over Q) = Â«exprâŸ¦ âŸ§Â» (0 : Â«expr âŸ¶ Â» Q Q)\n            by\n            dsimp at comm\n            simp [sub_eq_zero.2 comm],\n          fun Z g hh => by\n          obtain âŸ¨X, p', q', ep', eq', comm'âŸ© := quotient.exact hh\n          have : Â«expr â‰« Â» a'.hom g = 0 :=\n            by\n            apply (epi_iff_cancel_zero _).1 ep' _ (Â«expr â‰« Â» a'.hom g)\n            simpa using comm'\n          apply quotient.sound\n          -- Can we prevent quotient.sound from giving us this weird `coe_b` thingy?\n          change app g (a'' : over P) â‰ˆ app g a\n          exact âŸ¨R, (Â«exprğŸ™Â») R, p, by infer_instance, ep, by simp [sub_eq_add_neg, this]âŸ©âŸ©âŸ©\n#align sub_of_eq_image sub_of_eq_image\n\n",
 "pseudo_zero_iff":
 "/-- The pseudoelement induced by an arrow is zero precisely when that arrow is zero -/\ntheorem pseudo_zero_iff {P : C} (a : over P) : (a : P) = 0 â†” a.hom = 0 :=\n  by\n  rw [â† pseudo_zero_aux P a]\n  exact quotient.eq\n#align pseudo_zero_iff pseudo_zero_iff\n\n",
 "pseudo_zero_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŸ¦ âŸ§Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem pseudo_zero_def {P : C} : (0 : pseudoelement P) = Â«exprâŸ¦ âŸ§Â» (0 : Â«expr âŸ¶ Â» P P) :=\n  rfl\n#align pseudo_zero_def pseudo_zero_def\n\n",
 "pseudo_zero_aux":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/-- The arrows pseudo-equal to a zero morphism are precisely the zero morphisms -/\ntheorem pseudo_zero_aux {P : C} (Q : C) (f : over P) : f â‰ˆ (0 : Â«expr âŸ¶ Â» Q P) â†” f.hom = 0 :=\n  âŸ¨fun âŸ¨R, p, q, ep, eq, commâŸ© => zero_of_epi_comp p (by simp [comm]), fun hf =>\n    âŸ¨biprod f.1 Q, biprod.fst, biprod.snd, by infer_instance, by infer_instance, by\n      rw [hf, over.coe_hom, has_zero_morphisms.comp_zero, has_zero_morphisms.comp_zero]âŸ©âŸ©\n#align pseudo_zero_aux pseudo_zero_aux\n\n",
 "pseudo_surjective_of_epi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/-- An epimorphism is surjective on pseudoelements. -/\ntheorem pseudo_surjective_of_epi {P Q : C} (f : Â«expr âŸ¶ Â» P Q) [Epi f] : function.surjective f := fun qbar =>\n  Quotient.inductionOn qbar fun q =>\n    âŸ¨((pullback.fst : Â«expr âŸ¶ Â» (pullback f q.hom) P) : over P),\n      quotient.sound <|\n        âŸ¨pullback f q.hom, (Â«exprğŸ™Â») (pullback f q.hom), pullback.snd, by infer_instance, by infer_instance, by\n          rw [category.id_comp, â† pullback.condition, app_hom, over.coe_hom]âŸ©âŸ©\n#align pseudo_surjective_of_epi pseudo_surjective_of_epi\n\n",
 "pseudo_pullback":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/-- If `f : P âŸ¶ R` and `g : Q âŸ¶ R` are morphisms and `p : P` and `q : Q` are pseudoelements such\n    that `f p = g q`, then there is some `s : pullback f g` such that `fst s = p` and `snd s = q`.\n\n    Remark: Borceux claims that `s` is unique, but this is false. See\n    `counterexamples/pseudoelement` for details. -/\ntheorem pseudo_pullback {P Q R : C} {f : Â«expr âŸ¶ Â» P R} {g : Â«expr âŸ¶ Â» Q R} {p : P} {q : Q} :\n    f p = g q â†’\n      âˆƒ s, (pullback.fst : Â«expr âŸ¶ Â» (pullback f g) P) s = p âˆ§ (pullback.snd : Â«expr âŸ¶ Â» (pullback f g) Q) s = q :=\n  quotient.induction_onâ‚‚ p q fun x y h =>\n    by\n    obtain âŸ¨Z, a, b, ea, eb, commâŸ© := quotient.exact h\n    obtain âŸ¨l, hlâ‚, hlâ‚‚âŸ© :=\n      @pullback.lift' _ _ _ _ _ _ f g _ (Â«expr â‰« Â» a x.hom) (Â«expr â‰« Â» b y.hom)\n        (by\n          simp only [category.assoc]\n          exact comm)\n    exact\n      âŸ¨l,\n        âŸ¨quotient.sound âŸ¨Z, (Â«exprğŸ™Â») Z, a, by infer_instance, ea, by rwa [category.id_comp]âŸ©,\n          quotient.sound âŸ¨Z, (Â«exprğŸ™Â») Z, b, by infer_instance, eb, by rwa [category.id_comp]âŸ©âŸ©âŸ©\n#align pseudo_pullback pseudo_pullback\n\n",
 "pseudo_injective_of_mono":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŸ¦ âŸ§Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŸ¦ âŸ§Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/-- A monomorphism is injective on pseudoelements. -/\ntheorem pseudo_injective_of_mono {P Q : C} (f : Â«expr âŸ¶ Â» P Q) [Mono f] : function.injective f := fun abar abar' =>\n  quotient.induction_onâ‚‚ abar abar' fun a a' ha =>\n    quotient.sound <|\n      have : Â«exprâŸ¦ âŸ§Â» (Â«expr â‰« Â» a.hom f : over Q) = Â«exprâŸ¦ âŸ§Â» (Â«expr â‰« Â» a'.hom f) := by convert ha\n      match quotient.exact this with\n      | âŸ¨R, p, q, ep, eq, commâŸ© =>\n        âŸ¨R, p, q, ep, eq,\n          (cancel_mono f).1 <| by\n            simp only [category.assoc]\n            exact commâŸ©\n#align pseudo_injective_of_mono pseudo_injective_of_mono\n\n",
 "pseudo_exact_of_exact":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/-- Two morphisms in an exact sequence are exact on pseudoelements. -/\ntheorem pseudo_exact_of_exact {P Q R : C} {f : Â«expr âŸ¶ Â» P Q} {g : Â«expr âŸ¶ Â» Q R} (h : exact f g) :\n    (âˆ€ a, g (f a) = 0) âˆ§ âˆ€ b, g b = 0 â†’ âˆƒ a, f a = b :=\n  âŸ¨fun a => by\n    rw [â† comp_apply, h.w]\n    exact zero_apply _ _, fun b' =>\n    Quotient.inductionOn b' fun b hb =>\n      by\n      have hb' : Â«expr â‰« Â» b.hom g = 0 := (pseudo_zero_iff _).1 hb\n      -- By exactness, b factors through im f = ker g via some c\n      obtain âŸ¨c, hcâŸ© := kernel_fork.is_limit.lift' (is_limit_image f g h) _ hb'\n      -- We compute the pullback of the map into the image and c.\n      -- The pseudoelement induced by the first pullback map will be our preimage.\n      use (pullback.fst : Â«expr âŸ¶ Â» (pullback (abelian.factor_thru_image f) c) P)\n      -- It remains to show that the image of this element under f is pseudo-equal to b.\n      apply quotient.sound\n      -- pullback.snd is an epimorphism because the map onto the image is!\n      refine'\n        âŸ¨pullback (abelian.factor_thru_image f) c, (Â«exprğŸ™Â») _, pullback.snd, by infer_instance, by infer_instance, _âŸ©\n      -- Now we can verify that the diagram commutes.\n      calc\n        Â«expr â‰« Â» ((Â«exprğŸ™Â») (pullback (abelian.factor_thru_image f) c)) (Â«expr â‰« Â» pullback.fst f) =\n            Â«expr â‰« Â» pullback.fst f :=\n          category.id_comp _\n        _ = Â«expr â‰« Â» pullback.fst (Â«expr â‰« Â» (abelian.factor_thru_image f) (kernel.Î¹ (cokernel.Ï€ f))) := by\n          rw [abelian.image.fac]\n        _ = Â«expr â‰« Â» (Â«expr â‰« Â» pullback.snd c) (kernel.Î¹ (cokernel.Ï€ f)) := by\n          rw [â† category.assoc, pullback.condition]\n        _ = Â«expr â‰« Â» pullback.snd b.hom := by\n          rw [category.assoc]\n          congr\n        âŸ©\n#align pseudo_exact_of_exact pseudo_exact_of_exact\n\n",
 "pseudo_equal_trans":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/-- Pseudoequality is transitive: Just take the pullback. The pullback morphisms will\n    be epimorphisms since in an abelian category, pullbacks of epimorphisms are epimorphisms. -/\ntheorem pseudo_equal_trans {P : C} : transitive (pseudo_equal P) :=\n  fun f g h âŸ¨R, p, q, ep, eq, commâŸ© âŸ¨R', p', q', ep', eq', comm'âŸ© =>\n  by\n  refine' âŸ¨pullback q p', Â«expr â‰« Â» pullback.fst p, Â«expr â‰« Â» pullback.snd q', _, _, _âŸ©\n  Â· skip\n    exact epi_comp _ _\n  Â· skip\n    exact epi_comp _ _\n  Â· rw [category.assoc, comm, â† category.assoc, pullback.condition, category.assoc, comm', category.assoc]\n#align pseudo_equal_trans pseudo_equal_trans\n\n",
 "pseudo_equal_symm":
 "theorem pseudo_equal_symm {P : C} : symmetric (pseudo_equal P) := fun f g âŸ¨R, p, q, ep, eq, commâŸ© =>\n  âŸ¨R, q, p, eq, ep, comm.symmâŸ©\n#align pseudo_equal_symm pseudo_equal_symm\n\n",
 "pseudo_equal_refl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\ntheorem pseudo_equal_refl {P : C} : reflexive (pseudo_equal P) := fun f =>\n  âŸ¨f.1, (Â«exprğŸ™Â») f.1, (Â«exprğŸ™Â») f.1, by infer_instance, by infer_instance, by simpâŸ©\n#align pseudo_equal_refl pseudo_equal_refl\n\n",
 "pseudo_apply_mk":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŸ¦ âŸ§Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŸ¦ âŸ§Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\ntheorem pseudo_apply_mk {P Q : C} (f : Â«expr âŸ¶ Â» P Q) (a : over P) : f (Â«exprâŸ¦ âŸ§Â» a) = Â«exprâŸ¦ âŸ§Â» (Â«expr â‰« Â» a.hom f) :=\n  rfl\n#align pseudo_apply_mk pseudo_apply_mk\n\n",
 "pseudo_apply_aux":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/-- If two elements are pseudo-equal, then their composition with a morphism is, too. -/\ntheorem pseudo_apply_aux {P Q : C} (f : Â«expr âŸ¶ Â» P Q) (a b : over P) : a â‰ˆ b â†’ app f a â‰ˆ app f b :=\n  fun âŸ¨R, p, q, ep, eq, commâŸ© =>\n  âŸ¨R, p, q, ep, eq, show Â«expr â‰« Â» p (Â«expr â‰« Â» a.hom f) = Â«expr â‰« Â» q (Â«expr â‰« Â» b.hom f) by rw [reassoc_of comm]âŸ©\n#align pseudo_apply_aux pseudo_apply_aux\n\n",
 "over_coe_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŸ¦ âŸ§Â» -/\ntheorem over_coe_def {P Q : C} (a : Â«expr âŸ¶ Â» Q P) : (a : pseudoelement P) = Â«exprâŸ¦ âŸ§Â» a :=\n  rfl\n#align over_coe_def over_coe_def\n\n",
 "mono_of_zero_of_map_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/-- A morphism that only maps the zero pseudoelement to zero is a monomorphism. -/\ntheorem mono_of_zero_of_map_zero {P Q : C} (f : Â«expr âŸ¶ Â» P Q) : (âˆ€ a, f a = 0 â†’ a = 0) â†’ Mono f := fun h =>\n  (mono_iff_cancel_zero _).2 fun R g hg =>\n    (pseudo_zero_iff (g : over P)).1 <| h _ <| show f g = 0 from (pseudo_zero_iff (Â«expr â‰« Â» g f : over Q)).2 hg\n#align mono_of_zero_of_map_zero mono_of_zero_of_map_zero\n\n",
 "exact_of_pseudo_exact":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/-- If two morphisms are exact on pseudoelements, they are exact. -/\ntheorem exact_of_pseudo_exact {P Q R : C} (f : Â«expr âŸ¶ Â» P Q) (g : Â«expr âŸ¶ Â» Q R) :\n    ((âˆ€ a, g (f a) = 0) âˆ§ âˆ€ b, g b = 0 â†’ âˆƒ a, f a = b) â†’ exact f g := fun âŸ¨hâ‚, hâ‚‚âŸ© =>\n  (abelian.exact_iff _ _).2\n    âŸ¨zero_morphism_ext _ fun a => by rw [comp_apply, hâ‚ a],\n      by\n      -- If we apply g to the pseudoelement induced by its kernel, we get 0 (of course!).\n      have : g (kernel.Î¹ g) = 0 := apply_eq_zero_of_comp_eq_zero _ _ (kernel.condition _)\n      -- By pseudo-exactness, we get a preimage.\n      obtain âŸ¨a', haâŸ© := hâ‚‚ _ this\n      obtain âŸ¨a, ha'âŸ© := quotient.exists_rep a'\n      rw [â† ha'] at ha\n      obtain âŸ¨Z, r, q, er, eq, commâŸ© := quotient.exact ha\n      -- Consider the pullback of kernel.Î¹ (cokernel.Ï€ f) and kernel.Î¹ g.\n      -- The commutative diagram given by the pseudo-equality f a = b induces\n      -- a cone over this pullback, so we get a factorization z.\n      obtain âŸ¨z, hzâ‚, hzâ‚‚âŸ© :=\n        @pullback.lift' _ _ _ _ _ _ (kernel.Î¹ (cokernel.Ï€ f)) (kernel.Î¹ g) _\n          (Â«expr â‰« Â» r (Â«expr â‰« Â» a.hom (abelian.factor_thru_image f))) q\n          (by\n            simp only [category.assoc, abelian.image.fac]\n            exact comm)\n      -- Let's give a name to the second pullback morphism.\n      let j : Â«expr âŸ¶ Â» (pullback (kernel.Î¹ (cokernel.Ï€ f)) (kernel.Î¹ g)) (kernel g) := pullback.snd\n      -- Since q is an epimorphism, in particular this means that j is an epimorphism.\n      haveI pe : epi j := epi_of_epi_fac hzâ‚‚\n      -- But is is also a monomorphism, because kernel.Î¹ (cokernel.Ï€ f) is: A kernel is\n      -- always a monomorphism and the pullback of a monomorphism is a monomorphism.\n      -- But mono + epi = iso, so j is an isomorphism.\n      haveI : is_iso j := is_iso_of_mono_of_epi _\n      -- But then kernel.Î¹ g can be expressed using all of the maps of the pullback square, and we\n      -- are done.\n      rw [(iso.eq_inv_comp (as_iso j)).2 pullback.condition.symm]\n      simp only [category.assoc, kernel.condition, has_zero_morphisms.comp_zero]âŸ©\n#align exact_of_pseudo_exact exact_of_pseudo_exact\n\n",
 "eq_zero_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem eq_zero_iff {P Q : C} (f : Â«expr âŸ¶ Â» P Q) : f = 0 â†” âˆ€ a, f a = 0 :=\n  âŸ¨fun h a => by simp [h], zero_morphism_ext _âŸ©\n#align eq_zero_iff eq_zero_iff\n\n",
 "eq_range_of_pseudoequal":
 "/-- In the category `Module R`, if `x` and `y` are pseudoequal, then the range of the associated\nmorphisms is the same. -/\ntheorem Module.eq_range_of_pseudoequal {R : Type _} [CommRing R] {G : Module R} {x y : over G}\n    (h : pseudo_equal G x y) : x.hom.range = y.hom.range :=\n  by\n  obtain âŸ¨P, p, q, hp, hq, HâŸ© := h\n  refine' submodule.ext fun a => âŸ¨fun ha => _, fun ha => _âŸ©\n  Â· obtain âŸ¨a', ha'âŸ© := ha\n    obtain âŸ¨a'', ha''âŸ© := (Module.epi_iff_surjective p).1 hp a'\n    refine' âŸ¨q a'', _âŸ©\n    rw [â† linear_map.comp_apply, â† Module.comp_def, â† H, Module.comp_def, linear_map.comp_apply, ha'', ha']\n  Â· obtain âŸ¨a', ha'âŸ© := ha\n    obtain âŸ¨a'', ha''âŸ© := (Module.epi_iff_surjective q).1 hq a'\n    refine' âŸ¨p a'', _âŸ©\n    rw [â† linear_map.comp_apply, â† Module.comp_def, H, Module.comp_def, linear_map.comp_apply, ha'', ha']\n#align Module.eq_range_of_pseudoequal Module.eq_range_of_pseudoequal\n\n",
 "epi_of_pseudo_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŸ¦ âŸ§Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŸ¦ âŸ§Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/-- A morphism that is surjective on pseudoelements is an epimorphism. -/\ntheorem epi_of_pseudo_surjective {P Q : C} (f : Â«expr âŸ¶ Â» P Q) : function.surjective f â†’ Epi f := fun h =>\n  match h ((Â«exprğŸ™Â») Q) with\n  | âŸ¨pbar, hpbarâŸ© =>\n    match quotient.exists_rep pbar with\n    | âŸ¨p, hpâŸ© =>\n      have : Â«exprâŸ¦ âŸ§Â» (Â«expr â‰« Â» p.hom f : over Q) = Â«exprâŸ¦ âŸ§Â» ((Â«exprğŸ™Â») Q) :=\n        by\n        rw [â† hp] at hpbar\n        exact hpbar\n      match quotient.exact this with\n      | âŸ¨R, x, y, ex, ey, commâŸ© =>\n        @epi_of_epi_fac _ _ _ _ _ (Â«expr â‰« Â» x p.hom) f y ey <|\n          by\n          dsimp at comm\n          rw [category.assoc, comm]\n          apply category.comp_id\n#align epi_of_pseudo_surjective epi_of_pseudo_surjective\n\n",
 "comp_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/-- Composition of functions on pseudoelements is composition of morphisms. -/\ntheorem comp_comp {P Q R : C} (f : Â«expr âŸ¶ Â» P Q) (g : Â«expr âŸ¶ Â» Q R) : g âˆ˜ f = Â«expr â‰« Â» f g :=\n  funext fun x => (comp_apply _ _ _).symm\n#align comp_comp comp_comp\n\n",
 "comp_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/-- Applying a pseudoelement to a composition of morphisms is the same as composing\n    with each morphism. Sadly, this is not a definitional equality, but at least it is\n    true. -/\ntheorem comp_apply {P Q R : C} (f : Â«expr âŸ¶ Â» P Q) (g : Â«expr âŸ¶ Â» Q R) (a : P) : (Â«expr â‰« Â» f g) a = g (f a) :=\n  Quotient.inductionOn a fun x =>\n    quotient.sound <| by\n      unfold app\n      rw [â† category.assoc, over.coe_hom]\n#align comp_apply comp_apply\n\n",
 "apply_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/-- Morphisms map the zero pseudoelement to the zero pseudoelement -/\n@[simp]\ntheorem apply_zero {P Q : C} (f : Â«expr âŸ¶ Â» P Q) : f 0 = 0 :=\n  by\n  rw [pseudo_zero_def, pseudo_apply_mk]\n  simp\n#align apply_zero apply_zero\n\n",
 "apply_eq_zero_of_comp_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\ntheorem apply_eq_zero_of_comp_eq_zero {P Q R : C} (f : Â«expr âŸ¶ Â» Q R) (a : Â«expr âŸ¶ Â» P Q) :\n    Â«expr â‰« Â» a f = 0 â†’ f a = 0 := fun h => by simp [over_coe_def, pseudo_apply_mk, over.coe_hom, h]\n#align apply_eq_zero_of_comp_eq_zero apply_eq_zero_of_comp_eq_zero\n\n",
 "app_hom":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/-\nCopyright (c) 2020 Markus Himmel. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Markus Himmel\n-/\n@[simp]\ntheorem app_hom {P Q : C} (f : Â«expr âŸ¶ Â» P Q) (a : over P) : (app f a).hom = Â«expr â‰« Â» a.hom f :=\n  rfl\n#align app_hom app_hom\n\n"}