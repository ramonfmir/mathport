{"zero_of_map_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/-- A morphism that is injective on pseudoelements only maps the zero element to zero. -/\ntheorem zero_of_map_zero {P Q : C} (f : «expr ⟶ » P Q) : function.injective f → ∀ a, f a = 0 → a = 0 := fun h a ha =>\n  by\n  rw [← apply_zero f] at ha\n  exact h ha\n#align zero_of_map_zero zero_of_map_zero\n\n",
 "zero_morphism_ext'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem zero_morphism_ext' {P Q : C} (f : «expr ⟶ » P Q) : (∀ a, f a = 0) → 0 = f :=\n  eq.symm ∘ zero_morphism_ext f\n#align zero_morphism_ext' zero_morphism_ext'\n\n",
 "zero_morphism_ext":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/-- An extensionality lemma for being the zero arrow. -/\ntheorem zero_morphism_ext {P Q : C} (f : «expr ⟶ » P Q) : (∀ a, f a = 0) → f = 0 := fun h =>\n  by\n  rw [← category.id_comp f]\n  exact (pseudo_zero_iff («expr ≫ » ((«expr𝟙») P) f : over Q)).1 (h ((«expr𝟙») P))\n#align zero_morphism_ext zero_morphism_ext\n\n",
 "zero_eq_zero'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟦ ⟧» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟦ ⟧» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem zero_eq_zero' {P Q R : C} :\n    «expr⟦ ⟧» ((0 : «expr ⟶ » Q P) : over P) = «expr⟦ ⟧» ((0 : «expr ⟶ » R P) : over P) :=\n  quotient.sound <| (pseudo_zero_aux R _).2 rfl\n#align zero_eq_zero' zero_eq_zero'\n\n",
 "zero_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟦ ⟧» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n@[simp]\ntheorem zero_eq_zero {P Q : C} : «expr⟦ ⟧» ((0 : «expr ⟶ » Q P) : over P) = (0 : pseudoelement P) :=\n  zero_eq_zero'\n#align zero_eq_zero zero_eq_zero\n\n",
 "zero_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/-- The zero morphism maps every pseudoelement to 0. -/\n@[simp]\ntheorem zero_apply {P : C} (Q : C) (a : P) : (0 : «expr ⟶ » P Q) a = 0 :=\n  Quotient.inductionOn a fun a' => by\n    rw [pseudo_zero_def, pseudo_apply_mk]\n    simp\n#align zero_apply zero_apply\n\n",
 "sub_of_eq_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟦ ⟧» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟦ ⟧» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/-- If two pseudoelements `x` and `y` have the same image under some morphism `f`, then we can form\n    their \"difference\" `z`. This pseudoelement has the properties that `f z = 0` and for all\n    morphisms `g`, if `g y = 0` then `g z = g x`. -/\ntheorem sub_of_eq_image {P Q : C} (f : «expr ⟶ » P Q) (x y : P) :\n    f x = f y → ∃ z, f z = 0 ∧ ∀ (R : C) (g : «expr ⟶ » P R), (g : «expr ⟶ » P R) y = 0 → g z = g x :=\n  quotient.induction_on₂ x y fun a a' h =>\n    match quotient.exact h with\n    | ⟨R, p, q, ep, eq, comm⟩ =>\n      let a'' : «expr ⟶ » R P := «expr ≫ » p a.hom - «expr ≫ » q a'.hom\n      ⟨a'',\n        ⟨show «expr⟦ ⟧» («expr ≫ » («expr ≫ » p a.hom - «expr ≫ » q a'.hom) f : over Q) = «expr⟦ ⟧» (0 : «expr ⟶ » Q Q)\n            by\n            dsimp at comm\n            simp [sub_eq_zero.2 comm],\n          fun Z g hh => by\n          obtain ⟨X, p', q', ep', eq', comm'⟩ := quotient.exact hh\n          have : «expr ≫ » a'.hom g = 0 :=\n            by\n            apply (epi_iff_cancel_zero _).1 ep' _ («expr ≫ » a'.hom g)\n            simpa using comm'\n          apply quotient.sound\n          -- Can we prevent quotient.sound from giving us this weird `coe_b` thingy?\n          change app g (a'' : over P) ≈ app g a\n          exact ⟨R, («expr𝟙») R, p, by infer_instance, ep, by simp [sub_eq_add_neg, this]⟩⟩⟩\n#align sub_of_eq_image sub_of_eq_image\n\n",
 "pseudo_zero_iff":
 "/-- The pseudoelement induced by an arrow is zero precisely when that arrow is zero -/\ntheorem pseudo_zero_iff {P : C} (a : over P) : (a : P) = 0 ↔ a.hom = 0 :=\n  by\n  rw [← pseudo_zero_aux P a]\n  exact quotient.eq\n#align pseudo_zero_iff pseudo_zero_iff\n\n",
 "pseudo_zero_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟦ ⟧» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem pseudo_zero_def {P : C} : (0 : pseudoelement P) = «expr⟦ ⟧» (0 : «expr ⟶ » P P) :=\n  rfl\n#align pseudo_zero_def pseudo_zero_def\n\n",
 "pseudo_zero_aux":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/-- The arrows pseudo-equal to a zero morphism are precisely the zero morphisms -/\ntheorem pseudo_zero_aux {P : C} (Q : C) (f : over P) : f ≈ (0 : «expr ⟶ » Q P) ↔ f.hom = 0 :=\n  ⟨fun ⟨R, p, q, ep, eq, comm⟩ => zero_of_epi_comp p (by simp [comm]), fun hf =>\n    ⟨biprod f.1 Q, biprod.fst, biprod.snd, by infer_instance, by infer_instance, by\n      rw [hf, over.coe_hom, has_zero_morphisms.comp_zero, has_zero_morphisms.comp_zero]⟩⟩\n#align pseudo_zero_aux pseudo_zero_aux\n\n",
 "pseudo_surjective_of_epi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/-- An epimorphism is surjective on pseudoelements. -/\ntheorem pseudo_surjective_of_epi {P Q : C} (f : «expr ⟶ » P Q) [Epi f] : function.surjective f := fun qbar =>\n  Quotient.inductionOn qbar fun q =>\n    ⟨((pullback.fst : «expr ⟶ » (pullback f q.hom) P) : over P),\n      quotient.sound <|\n        ⟨pullback f q.hom, («expr𝟙») (pullback f q.hom), pullback.snd, by infer_instance, by infer_instance, by\n          rw [category.id_comp, ← pullback.condition, app_hom, over.coe_hom]⟩⟩\n#align pseudo_surjective_of_epi pseudo_surjective_of_epi\n\n",
 "pseudo_pullback":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/-- If `f : P ⟶ R` and `g : Q ⟶ R` are morphisms and `p : P` and `q : Q` are pseudoelements such\n    that `f p = g q`, then there is some `s : pullback f g` such that `fst s = p` and `snd s = q`.\n\n    Remark: Borceux claims that `s` is unique, but this is false. See\n    `counterexamples/pseudoelement` for details. -/\ntheorem pseudo_pullback {P Q R : C} {f : «expr ⟶ » P R} {g : «expr ⟶ » Q R} {p : P} {q : Q} :\n    f p = g q →\n      ∃ s, (pullback.fst : «expr ⟶ » (pullback f g) P) s = p ∧ (pullback.snd : «expr ⟶ » (pullback f g) Q) s = q :=\n  quotient.induction_on₂ p q fun x y h =>\n    by\n    obtain ⟨Z, a, b, ea, eb, comm⟩ := quotient.exact h\n    obtain ⟨l, hl₁, hl₂⟩ :=\n      @pullback.lift' _ _ _ _ _ _ f g _ («expr ≫ » a x.hom) («expr ≫ » b y.hom)\n        (by\n          simp only [category.assoc]\n          exact comm)\n    exact\n      ⟨l,\n        ⟨quotient.sound ⟨Z, («expr𝟙») Z, a, by infer_instance, ea, by rwa [category.id_comp]⟩,\n          quotient.sound ⟨Z, («expr𝟙») Z, b, by infer_instance, eb, by rwa [category.id_comp]⟩⟩⟩\n#align pseudo_pullback pseudo_pullback\n\n",
 "pseudo_injective_of_mono":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟦ ⟧» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟦ ⟧» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/-- A monomorphism is injective on pseudoelements. -/\ntheorem pseudo_injective_of_mono {P Q : C} (f : «expr ⟶ » P Q) [Mono f] : function.injective f := fun abar abar' =>\n  quotient.induction_on₂ abar abar' fun a a' ha =>\n    quotient.sound <|\n      have : «expr⟦ ⟧» («expr ≫ » a.hom f : over Q) = «expr⟦ ⟧» («expr ≫ » a'.hom f) := by convert ha\n      match quotient.exact this with\n      | ⟨R, p, q, ep, eq, comm⟩ =>\n        ⟨R, p, q, ep, eq,\n          (cancel_mono f).1 <| by\n            simp only [category.assoc]\n            exact comm⟩\n#align pseudo_injective_of_mono pseudo_injective_of_mono\n\n",
 "pseudo_exact_of_exact":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/-- Two morphisms in an exact sequence are exact on pseudoelements. -/\ntheorem pseudo_exact_of_exact {P Q R : C} {f : «expr ⟶ » P Q} {g : «expr ⟶ » Q R} (h : exact f g) :\n    (∀ a, g (f a) = 0) ∧ ∀ b, g b = 0 → ∃ a, f a = b :=\n  ⟨fun a => by\n    rw [← comp_apply, h.w]\n    exact zero_apply _ _, fun b' =>\n    Quotient.inductionOn b' fun b hb =>\n      by\n      have hb' : «expr ≫ » b.hom g = 0 := (pseudo_zero_iff _).1 hb\n      -- By exactness, b factors through im f = ker g via some c\n      obtain ⟨c, hc⟩ := kernel_fork.is_limit.lift' (is_limit_image f g h) _ hb'\n      -- We compute the pullback of the map into the image and c.\n      -- The pseudoelement induced by the first pullback map will be our preimage.\n      use (pullback.fst : «expr ⟶ » (pullback (abelian.factor_thru_image f) c) P)\n      -- It remains to show that the image of this element under f is pseudo-equal to b.\n      apply quotient.sound\n      -- pullback.snd is an epimorphism because the map onto the image is!\n      refine'\n        ⟨pullback (abelian.factor_thru_image f) c, («expr𝟙») _, pullback.snd, by infer_instance, by infer_instance, _⟩\n      -- Now we can verify that the diagram commutes.\n      calc\n        «expr ≫ » ((«expr𝟙») (pullback (abelian.factor_thru_image f) c)) («expr ≫ » pullback.fst f) =\n            «expr ≫ » pullback.fst f :=\n          category.id_comp _\n        _ = «expr ≫ » pullback.fst («expr ≫ » (abelian.factor_thru_image f) (kernel.ι (cokernel.π f))) := by\n          rw [abelian.image.fac]\n        _ = «expr ≫ » («expr ≫ » pullback.snd c) (kernel.ι (cokernel.π f)) := by\n          rw [← category.assoc, pullback.condition]\n        _ = «expr ≫ » pullback.snd b.hom := by\n          rw [category.assoc]\n          congr\n        ⟩\n#align pseudo_exact_of_exact pseudo_exact_of_exact\n\n",
 "pseudo_equal_trans":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/-- Pseudoequality is transitive: Just take the pullback. The pullback morphisms will\n    be epimorphisms since in an abelian category, pullbacks of epimorphisms are epimorphisms. -/\ntheorem pseudo_equal_trans {P : C} : transitive (pseudo_equal P) :=\n  fun f g h ⟨R, p, q, ep, eq, comm⟩ ⟨R', p', q', ep', eq', comm'⟩ =>\n  by\n  refine' ⟨pullback q p', «expr ≫ » pullback.fst p, «expr ≫ » pullback.snd q', _, _, _⟩\n  · skip\n    exact epi_comp _ _\n  · skip\n    exact epi_comp _ _\n  · rw [category.assoc, comm, ← category.assoc, pullback.condition, category.assoc, comm', category.assoc]\n#align pseudo_equal_trans pseudo_equal_trans\n\n",
 "pseudo_equal_symm":
 "theorem pseudo_equal_symm {P : C} : symmetric (pseudo_equal P) := fun f g ⟨R, p, q, ep, eq, comm⟩ =>\n  ⟨R, q, p, eq, ep, comm.symm⟩\n#align pseudo_equal_symm pseudo_equal_symm\n\n",
 "pseudo_equal_refl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\ntheorem pseudo_equal_refl {P : C} : reflexive (pseudo_equal P) := fun f =>\n  ⟨f.1, («expr𝟙») f.1, («expr𝟙») f.1, by infer_instance, by infer_instance, by simp⟩\n#align pseudo_equal_refl pseudo_equal_refl\n\n",
 "pseudo_apply_mk":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟦ ⟧» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟦ ⟧» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem pseudo_apply_mk {P Q : C} (f : «expr ⟶ » P Q) (a : over P) : f («expr⟦ ⟧» a) = «expr⟦ ⟧» («expr ≫ » a.hom f) :=\n  rfl\n#align pseudo_apply_mk pseudo_apply_mk\n\n",
 "pseudo_apply_aux":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/-- If two elements are pseudo-equal, then their composition with a morphism is, too. -/\ntheorem pseudo_apply_aux {P Q : C} (f : «expr ⟶ » P Q) (a b : over P) : a ≈ b → app f a ≈ app f b :=\n  fun ⟨R, p, q, ep, eq, comm⟩ =>\n  ⟨R, p, q, ep, eq, show «expr ≫ » p («expr ≫ » a.hom f) = «expr ≫ » q («expr ≫ » b.hom f) by rw [reassoc_of comm]⟩\n#align pseudo_apply_aux pseudo_apply_aux\n\n",
 "over_coe_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟦ ⟧» -/\ntheorem over_coe_def {P Q : C} (a : «expr ⟶ » Q P) : (a : pseudoelement P) = «expr⟦ ⟧» a :=\n  rfl\n#align over_coe_def over_coe_def\n\n",
 "mono_of_zero_of_map_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/-- A morphism that only maps the zero pseudoelement to zero is a monomorphism. -/\ntheorem mono_of_zero_of_map_zero {P Q : C} (f : «expr ⟶ » P Q) : (∀ a, f a = 0 → a = 0) → Mono f := fun h =>\n  (mono_iff_cancel_zero _).2 fun R g hg =>\n    (pseudo_zero_iff (g : over P)).1 <| h _ <| show f g = 0 from (pseudo_zero_iff («expr ≫ » g f : over Q)).2 hg\n#align mono_of_zero_of_map_zero mono_of_zero_of_map_zero\n\n",
 "exact_of_pseudo_exact":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/-- If two morphisms are exact on pseudoelements, they are exact. -/\ntheorem exact_of_pseudo_exact {P Q R : C} (f : «expr ⟶ » P Q) (g : «expr ⟶ » Q R) :\n    ((∀ a, g (f a) = 0) ∧ ∀ b, g b = 0 → ∃ a, f a = b) → exact f g := fun ⟨h₁, h₂⟩ =>\n  (abelian.exact_iff _ _).2\n    ⟨zero_morphism_ext _ fun a => by rw [comp_apply, h₁ a],\n      by\n      -- If we apply g to the pseudoelement induced by its kernel, we get 0 (of course!).\n      have : g (kernel.ι g) = 0 := apply_eq_zero_of_comp_eq_zero _ _ (kernel.condition _)\n      -- By pseudo-exactness, we get a preimage.\n      obtain ⟨a', ha⟩ := h₂ _ this\n      obtain ⟨a, ha'⟩ := quotient.exists_rep a'\n      rw [← ha'] at ha\n      obtain ⟨Z, r, q, er, eq, comm⟩ := quotient.exact ha\n      -- Consider the pullback of kernel.ι (cokernel.π f) and kernel.ι g.\n      -- The commutative diagram given by the pseudo-equality f a = b induces\n      -- a cone over this pullback, so we get a factorization z.\n      obtain ⟨z, hz₁, hz₂⟩ :=\n        @pullback.lift' _ _ _ _ _ _ (kernel.ι (cokernel.π f)) (kernel.ι g) _\n          («expr ≫ » r («expr ≫ » a.hom (abelian.factor_thru_image f))) q\n          (by\n            simp only [category.assoc, abelian.image.fac]\n            exact comm)\n      -- Let's give a name to the second pullback morphism.\n      let j : «expr ⟶ » (pullback (kernel.ι (cokernel.π f)) (kernel.ι g)) (kernel g) := pullback.snd\n      -- Since q is an epimorphism, in particular this means that j is an epimorphism.\n      haveI pe : epi j := epi_of_epi_fac hz₂\n      -- But is is also a monomorphism, because kernel.ι (cokernel.π f) is: A kernel is\n      -- always a monomorphism and the pullback of a monomorphism is a monomorphism.\n      -- But mono + epi = iso, so j is an isomorphism.\n      haveI : is_iso j := is_iso_of_mono_of_epi _\n      -- But then kernel.ι g can be expressed using all of the maps of the pullback square, and we\n      -- are done.\n      rw [(iso.eq_inv_comp (as_iso j)).2 pullback.condition.symm]\n      simp only [category.assoc, kernel.condition, has_zero_morphisms.comp_zero]⟩\n#align exact_of_pseudo_exact exact_of_pseudo_exact\n\n",
 "eq_zero_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem eq_zero_iff {P Q : C} (f : «expr ⟶ » P Q) : f = 0 ↔ ∀ a, f a = 0 :=\n  ⟨fun h a => by simp [h], zero_morphism_ext _⟩\n#align eq_zero_iff eq_zero_iff\n\n",
 "eq_range_of_pseudoequal":
 "/-- In the category `Module R`, if `x` and `y` are pseudoequal, then the range of the associated\nmorphisms is the same. -/\ntheorem Module.eq_range_of_pseudoequal {R : Type _} [CommRing R] {G : Module R} {x y : over G}\n    (h : pseudo_equal G x y) : x.hom.range = y.hom.range :=\n  by\n  obtain ⟨P, p, q, hp, hq, H⟩ := h\n  refine' submodule.ext fun a => ⟨fun ha => _, fun ha => _⟩\n  · obtain ⟨a', ha'⟩ := ha\n    obtain ⟨a'', ha''⟩ := (Module.epi_iff_surjective p).1 hp a'\n    refine' ⟨q a'', _⟩\n    rw [← linear_map.comp_apply, ← Module.comp_def, ← H, Module.comp_def, linear_map.comp_apply, ha'', ha']\n  · obtain ⟨a', ha'⟩ := ha\n    obtain ⟨a'', ha''⟩ := (Module.epi_iff_surjective q).1 hq a'\n    refine' ⟨p a'', _⟩\n    rw [← linear_map.comp_apply, ← Module.comp_def, H, Module.comp_def, linear_map.comp_apply, ha'', ha']\n#align Module.eq_range_of_pseudoequal Module.eq_range_of_pseudoequal\n\n",
 "epi_of_pseudo_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟦ ⟧» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟦ ⟧» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/-- A morphism that is surjective on pseudoelements is an epimorphism. -/\ntheorem epi_of_pseudo_surjective {P Q : C} (f : «expr ⟶ » P Q) : function.surjective f → Epi f := fun h =>\n  match h ((«expr𝟙») Q) with\n  | ⟨pbar, hpbar⟩ =>\n    match quotient.exists_rep pbar with\n    | ⟨p, hp⟩ =>\n      have : «expr⟦ ⟧» («expr ≫ » p.hom f : over Q) = «expr⟦ ⟧» ((«expr𝟙») Q) :=\n        by\n        rw [← hp] at hpbar\n        exact hpbar\n      match quotient.exact this with\n      | ⟨R, x, y, ex, ey, comm⟩ =>\n        @epi_of_epi_fac _ _ _ _ _ («expr ≫ » x p.hom) f y ey <|\n          by\n          dsimp at comm\n          rw [category.assoc, comm]\n          apply category.comp_id\n#align epi_of_pseudo_surjective epi_of_pseudo_surjective\n\n",
 "comp_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/-- Composition of functions on pseudoelements is composition of morphisms. -/\ntheorem comp_comp {P Q R : C} (f : «expr ⟶ » P Q) (g : «expr ⟶ » Q R) : g ∘ f = «expr ≫ » f g :=\n  funext fun x => (comp_apply _ _ _).symm\n#align comp_comp comp_comp\n\n",
 "comp_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/-- Applying a pseudoelement to a composition of morphisms is the same as composing\n    with each morphism. Sadly, this is not a definitional equality, but at least it is\n    true. -/\ntheorem comp_apply {P Q R : C} (f : «expr ⟶ » P Q) (g : «expr ⟶ » Q R) (a : P) : («expr ≫ » f g) a = g (f a) :=\n  Quotient.inductionOn a fun x =>\n    quotient.sound <| by\n      unfold app\n      rw [← category.assoc, over.coe_hom]\n#align comp_apply comp_apply\n\n",
 "apply_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/-- Morphisms map the zero pseudoelement to the zero pseudoelement -/\n@[simp]\ntheorem apply_zero {P Q : C} (f : «expr ⟶ » P Q) : f 0 = 0 :=\n  by\n  rw [pseudo_zero_def, pseudo_apply_mk]\n  simp\n#align apply_zero apply_zero\n\n",
 "apply_eq_zero_of_comp_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem apply_eq_zero_of_comp_eq_zero {P Q R : C} (f : «expr ⟶ » Q R) (a : «expr ⟶ » P Q) :\n    «expr ≫ » a f = 0 → f a = 0 := fun h => by simp [over_coe_def, pseudo_apply_mk, over.coe_hom, h]\n#align apply_eq_zero_of_comp_eq_zero apply_eq_zero_of_comp_eq_zero\n\n",
 "app_hom":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/-\nCopyright (c) 2020 Markus Himmel. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Markus Himmel\n-/\n@[simp]\ntheorem app_hom {P Q : C} (f : «expr ⟶ » P Q) (a : over P) : (app f a).hom = «expr ≫ » a.hom f :=\n  rfl\n#align app_hom app_hom\n\n"}