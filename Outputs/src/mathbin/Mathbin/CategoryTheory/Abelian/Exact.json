{"unop_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵖ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem exact.unop_iff {X Y Z : «expr ᵒᵖ» C} (g : «expr ⟶ » X Y) (f : «expr ⟶ » Y Z) :\n    exact f.unop g.unop ↔ exact g f :=\n  ⟨fun e => by rwa [← f.op_unop, ← g.op_unop, ← exact.op_iff] at e, fun e => @exact.unop _ _ g f e⟩\n#align exact.unop_iff exact.unop_iff\n\n",
 "unop":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵖ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem exact.unop {X Y Z : «expr ᵒᵖ» C} (g : «expr ⟶ » X Y) (f : «expr ⟶ » Y Z) (h : exact g f) :\n    exact f.unop g.unop := by\n  rw [← f.op_unop, ← g.op_unop] at h\n  rwa [← exact.op_iff]\n#align exact.unop exact.unop\n\n",
 "tfae_mono":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- failed to parenthesize: parenthesize: uncaught backtrack exception\n[PrettyPrinter.parenthesize.input] (Command.declaration\n     (Command.declModifiers [] [] [] [] [] [])\n     (Command.theorem\n      \"theorem\"\n      (Command.declId `tfae_mono [])\n      (Command.declSig\n       []\n       (Term.typeSpec\n        \":\"\n        (Term.app\n         `TFAE\n         [(«term[_]»\n           \"[\"\n           [(Term.app `Mono [`f])\n            \",\"\n            («term_=_» (Term.app `kernel.ι [`f]) \"=\" (num \"0\"))\n            \",\"\n            (Term.app `exact [(Term.typeAscription \"(\" (num \"0\") \":\" [(Term.app `«expr ⟶ » [`Z `X])] \")\") `f])]\n           \"]\")])))\n      (Command.declValSimple\n       \":=\"\n       (Term.byTactic\n        \"by\"\n        (Tactic.tacticSeq\n         (Tactic.tacticSeq1Indented\n          [(Tactic.tfaeHave \"tfae_have\" [] (num \"3\") \"→\" (num \"2\"))\n           []\n           (tactic__\n            (cdotTk (patternIgnore (token.«· » \"·\")))\n            [(Tactic.exact \"exact\" (Term.app `kernel_ι_eq_zero_of_exact_zero_left [`Z]))])\n           []\n           (Tactic.tfaeHave \"tfae_have\" [] (num \"1\") \"→\" (num \"3\"))\n           []\n           (tactic__\n            (cdotTk (patternIgnore (token.«· » \"·\")))\n            [(Tactic.intros \"intros\" []) [] (Tactic.exact \"exact\" (Term.app `exact_zero_left_of_mono [`Z]))])\n           []\n           (Tactic.tfaeHave \"tfae_have\" [] (num \"2\") \"→\" (num \"1\"))\n           []\n           (tactic__\n            (cdotTk (patternIgnore (token.«· » \"·\")))\n            [(Tactic.exact \"exact\" (Term.app `mono_of_kernel_ι_eq_zero [(Term.hole \"_\")]))])\n           []\n           (Tactic.tfaeFinish \"tfae_finish\")])))\n       [])\n      []\n      []))\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.byTactic\n       \"by\"\n       (Tactic.tacticSeq\n        (Tactic.tacticSeq1Indented\n         [(Tactic.tfaeHave \"tfae_have\" [] (num \"3\") \"→\" (num \"2\"))\n          []\n          (tactic__\n           (cdotTk (patternIgnore (token.«· » \"·\")))\n           [(Tactic.exact \"exact\" (Term.app `kernel_ι_eq_zero_of_exact_zero_left [`Z]))])\n          []\n          (Tactic.tfaeHave \"tfae_have\" [] (num \"1\") \"→\" (num \"3\"))\n          []\n          (tactic__\n           (cdotTk (patternIgnore (token.«· » \"·\")))\n           [(Tactic.intros \"intros\" []) [] (Tactic.exact \"exact\" (Term.app `exact_zero_left_of_mono [`Z]))])\n          []\n          (Tactic.tfaeHave \"tfae_have\" [] (num \"2\") \"→\" (num \"1\"))\n          []\n          (tactic__\n           (cdotTk (patternIgnore (token.«· » \"·\")))\n           [(Tactic.exact \"exact\" (Term.app `mono_of_kernel_ι_eq_zero [(Term.hole \"_\")]))])\n          []\n          (Tactic.tfaeFinish \"tfae_finish\")])))\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.tfaeFinish \"tfae_finish\")\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (tactic__\n       (cdotTk (patternIgnore (token.«· » \"·\")))\n       [(Tactic.exact \"exact\" (Term.app `mono_of_kernel_ι_eq_zero [(Term.hole \"_\")]))])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.exact \"exact\" (Term.app `mono_of_kernel_ι_eq_zero [(Term.hole \"_\")]))\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.app `mono_of_kernel_ι_eq_zero [(Term.hole \"_\")])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.namedArgument'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.ellipsis'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.hole \"_\")\n[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))\n      `mono_of_kernel_ι_eq_zero\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1022, term)\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.tfaeHave \"tfae_have\" [] (num \"2\") \"→\" (num \"1\"))\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind '«→»', expected 'token.« → »'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind '«→»', expected 'token.« ↔ »'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind '«→»', expected 'token.« ← »'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.declValEqns'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.whereStructInst'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception\ntheorem\n  tfae_mono\n  : TFAE [ Mono f , kernel.ι f = 0 , exact ( 0 : «expr ⟶ » Z X ) f ]\n  :=\n    by\n      tfae_have 3 → 2\n        · exact kernel_ι_eq_zero_of_exact_zero_left Z\n        tfae_have 1 → 3\n        · intros exact exact_zero_left_of_mono Z\n        tfae_have 2 → 1\n        · exact mono_of_kernel_ι_eq_zero _\n        tfae_finish\n#align tfae_mono tfae_mono\n\n",
 "tfae_epi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- failed to parenthesize: parenthesize: uncaught backtrack exception\n[PrettyPrinter.parenthesize.input] (Command.declaration\n     (Command.declModifiers [] [] [] [] [] [])\n     (Command.theorem\n      \"theorem\"\n      (Command.declId `tfae_epi [])\n      (Command.declSig\n       []\n       (Term.typeSpec\n        \":\"\n        (Term.app\n         `TFAE\n         [(«term[_]»\n           \"[\"\n           [(Term.app `Epi [`f])\n            \",\"\n            («term_=_» (Term.app `cokernel.π [`f]) \"=\" (num \"0\"))\n            \",\"\n            (Term.app `exact [`f (Term.typeAscription \"(\" (num \"0\") \":\" [(Term.app `«expr ⟶ » [`Y `Z])] \")\")])]\n           \"]\")])))\n      (Command.declValSimple\n       \":=\"\n       (Term.byTactic\n        \"by\"\n        (Tactic.tacticSeq\n         (Tactic.tacticSeq1Indented\n          [(Tactic.tfaeHave \"tfae_have\" [] (num \"3\") \"→\" (num \"2\"))\n           []\n           (tactic__\n            (cdotTk (patternIgnore (token.«· » \"·\")))\n            [(Tactic.rwSeq \"rw\" [] (Tactic.rwRuleSeq \"[\" [(Tactic.rwRule [] `exact_iff)] \"]\") [])\n             []\n             (Std.Tactic.rintro\n              \"rintro\"\n              [(Std.Tactic.RCases.rintroPat.one\n                (Std.Tactic.RCases.rcasesPat.tuple\n                 \"⟨\"\n                 [(Std.Tactic.RCases.rcasesPatLo\n                   (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.clear \"-\")])\n                   [])\n                  \",\"\n                  (Std.Tactic.RCases.rcasesPatLo\n                   (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `h)])\n                   [])]\n                 \"⟩\"))]\n              [])\n             []\n             (Tactic.exact \"exact\" (Term.app `zero_of_epi_comp [(Term.hole \"_\") `h]))])\n           []\n           (Tactic.tfaeHave \"tfae_have\" [] (num \"1\") \"→\" (num \"3\"))\n           []\n           (tactic__\n            (cdotTk (patternIgnore (token.«· » \"·\")))\n            [(Tactic.rwSeq \"rw\" [] (Tactic.rwRuleSeq \"[\" [(Tactic.rwRule [] `exact_iff)] \"]\") [])\n             []\n             (Tactic.intro \"intro\" [])\n             []\n             (Tactic.exact\n              \"exact\"\n              (Term.anonymousCtor\n               \"⟨\"\n               [(Term.byTactic\n                 \"by\"\n                 (Tactic.tacticSeq (Tactic.tacticSeq1Indented [(Tactic.simp \"simp\" [] [] [] [] [])])))\n                \",\"\n                (Term.byTactic\n                 \"by\"\n                 (Tactic.tacticSeq\n                  (Tactic.tacticSeq1Indented\n                   [(Tactic.simp \"simp\" [] [] [] [\"[\" [(Tactic.simpLemma [] [] `cokernel.π_of_epi)] \"]\"] [])])))]\n               \"⟩\"))])\n           []\n           (Tactic.tfaeHave \"tfae_have\" [] (num \"2\") \"→\" (num \"1\"))\n           []\n           (tactic__\n            (cdotTk (patternIgnore (token.«· » \"·\")))\n            [(Tactic.exact \"exact\" (Term.app `epi_of_cokernel_π_eq_zero [(Term.hole \"_\")]))])\n           []\n           (Tactic.tfaeFinish \"tfae_finish\")])))\n       [])\n      []\n      []))\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.byTactic\n       \"by\"\n       (Tactic.tacticSeq\n        (Tactic.tacticSeq1Indented\n         [(Tactic.tfaeHave \"tfae_have\" [] (num \"3\") \"→\" (num \"2\"))\n          []\n          (tactic__\n           (cdotTk (patternIgnore (token.«· » \"·\")))\n           [(Tactic.rwSeq \"rw\" [] (Tactic.rwRuleSeq \"[\" [(Tactic.rwRule [] `exact_iff)] \"]\") [])\n            []\n            (Std.Tactic.rintro\n             \"rintro\"\n             [(Std.Tactic.RCases.rintroPat.one\n               (Std.Tactic.RCases.rcasesPat.tuple\n                \"⟨\"\n                [(Std.Tactic.RCases.rcasesPatLo\n                  (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.clear \"-\")])\n                  [])\n                 \",\"\n                 (Std.Tactic.RCases.rcasesPatLo\n                  (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `h)])\n                  [])]\n                \"⟩\"))]\n             [])\n            []\n            (Tactic.exact \"exact\" (Term.app `zero_of_epi_comp [(Term.hole \"_\") `h]))])\n          []\n          (Tactic.tfaeHave \"tfae_have\" [] (num \"1\") \"→\" (num \"3\"))\n          []\n          (tactic__\n           (cdotTk (patternIgnore (token.«· » \"·\")))\n           [(Tactic.rwSeq \"rw\" [] (Tactic.rwRuleSeq \"[\" [(Tactic.rwRule [] `exact_iff)] \"]\") [])\n            []\n            (Tactic.intro \"intro\" [])\n            []\n            (Tactic.exact\n             \"exact\"\n             (Term.anonymousCtor\n              \"⟨\"\n              [(Term.byTactic \"by\" (Tactic.tacticSeq (Tactic.tacticSeq1Indented [(Tactic.simp \"simp\" [] [] [] [] [])])))\n               \",\"\n               (Term.byTactic\n                \"by\"\n                (Tactic.tacticSeq\n                 (Tactic.tacticSeq1Indented\n                  [(Tactic.simp \"simp\" [] [] [] [\"[\" [(Tactic.simpLemma [] [] `cokernel.π_of_epi)] \"]\"] [])])))]\n              \"⟩\"))])\n          []\n          (Tactic.tfaeHave \"tfae_have\" [] (num \"2\") \"→\" (num \"1\"))\n          []\n          (tactic__\n           (cdotTk (patternIgnore (token.«· » \"·\")))\n           [(Tactic.exact \"exact\" (Term.app `epi_of_cokernel_π_eq_zero [(Term.hole \"_\")]))])\n          []\n          (Tactic.tfaeFinish \"tfae_finish\")])))\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.tfaeFinish \"tfae_finish\")\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (tactic__\n       (cdotTk (patternIgnore (token.«· » \"·\")))\n       [(Tactic.exact \"exact\" (Term.app `epi_of_cokernel_π_eq_zero [(Term.hole \"_\")]))])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.exact \"exact\" (Term.app `epi_of_cokernel_π_eq_zero [(Term.hole \"_\")]))\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.app `epi_of_cokernel_π_eq_zero [(Term.hole \"_\")])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.namedArgument'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.ellipsis'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.hole \"_\")\n[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))\n      `epi_of_cokernel_π_eq_zero\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1022, term)\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.tfaeHave \"tfae_have\" [] (num \"2\") \"→\" (num \"1\"))\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind '«→»', expected 'token.« → »'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind '«→»', expected 'token.« ↔ »'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind '«→»', expected 'token.« ← »'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.declValEqns'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.whereStructInst'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception\ntheorem\n  tfae_epi\n  : TFAE [ Epi f , cokernel.π f = 0 , exact f ( 0 : «expr ⟶ » Y Z ) ]\n  :=\n    by\n      tfae_have 3 → 2\n        · rw [ exact_iff ] rintro ⟨ - , h ⟩ exact zero_of_epi_comp _ h\n        tfae_have 1 → 3\n        · rw [ exact_iff ] intro exact ⟨ by simp , by simp [ cokernel.π_of_epi ] ⟩\n        tfae_have 2 → 1\n        · exact epi_of_cokernel_π_eq_zero _\n        tfae_finish\n#align tfae_epi tfae_epi\n\n",
 "preserves_zero_morphisms_of_map_exact":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/-- A functor which preserves exactness preserves zero morphisms. -/\ntheorem preserves_zero_morphisms_of_map_exact : L.preserves_zero_morphisms :=\n  by\n  replace h := (h (exact_of_zero ((«expr𝟙») 0) ((«expr𝟙») 0))).w\n  rw [L.map_id, category.comp_id] at h\n  exact preserves_zero_morphisms_of_map_zero_object (id_zero_equiv_iso_zero _ h)\n#align preserves_zero_morphisms_of_map_exact preserves_zero_morphisms_of_map_exact\n\n",
 "preserves_monomorphisms_of_map_exact":
 "/-- A functor which preserves exactness preserves monomorphisms. -/\ntheorem preserves_monomorphisms_of_map_exact : L.preserves_monomorphisms :=\n  {\n    preserves := fun X Y f hf => by\n      letI := preserves_zero_morphisms_of_map_exact L h\n      apply ((tfae_mono (L.obj 0) (L.map f)).out 2 0).mp\n      rw [← L.map_zero]\n      exact h (((tfae_mono 0 f).out 0 2).mp hf) }\n#align preserves_monomorphisms_of_map_exact preserves_monomorphisms_of_map_exact\n\n",
 "preserves_epimorphisms_of_map_exact":
 "/-- A functor which preserves exactness preserves epimorphisms. -/\ntheorem preserves_epimorphisms_of_map_exact : L.preserves_epimorphisms :=\n  {\n    preserves := fun X Y f hf => by\n      letI := preserves_zero_morphisms_of_map_exact L h\n      apply ((tfae_epi (L.obj 0) (L.map f)).out 2 0).mp\n      rw [← L.map_zero]\n      exact h (((tfae_epi 0 f).out 0 2).mp hf) }\n#align preserves_epimorphisms_of_map_exact preserves_epimorphisms_of_map_exact\n\n",
 "op_iff":
 "theorem exact.op_iff : exact g.op f.op ↔ exact f g :=\n  ⟨fun e => by\n    rw [← is_equivalence.exact_iff _ _ (op_op_equivalence C).inverse]\n    exact exact.op _ _ e, exact.op _ _⟩\n#align exact.op_iff exact.op_iff\n\n",
 "op":
 "theorem exact.op (h : exact f g) : exact g.op f.op :=\n  by\n  rw [exact_iff]\n  refine' ⟨by simp [← op_comp, h.w], quiver.hom.unop_inj _⟩\n  simp only [unop_comp, cokernel.π_op, eq_to_hom_refl, kernel.ι_op, category.id_comp, category.assoc,\n    kernel_comp_cokernel_assoc _ _ h, zero_comp, comp_zero, unop_zero]\n#align exact.op exact.op\n\n",
 "mono_iff_kernel_ι_eq_zero":
 "-- Note we've already proved `mono_iff_exact_zero_left : mono f ↔ exact (0 : Z ⟶ X) f`\n-- in any preadditive category with kernels and images.\ntheorem mono_iff_kernel_ι_eq_zero : Mono f ↔ kernel.ι f = 0 :=\n  (tfae_mono X f).out 0 1\n#align mono_iff_kernel_ι_eq_zero mono_iff_kernel_ι_eq_zero\n\n",
 "map_exact":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/-- A functor preserving finite limits and finite colimits preserves exactness. The converse\nresult is also true, see `functor.preserves_finite_limits_of_map_exact` and\n`functor.preserves_finite_colimits_of_map_exact`. -/\ntheorem map_exact {X Y Z : A} (f : «expr ⟶ » X Y) (g : «expr ⟶ » Y Z) (e1 : exact f g) : exact (L.map f) (L.map g) :=\n  by\n  let hcoker := is_colimit_of_has_cokernel_of_preserves_colimit L f\n  let hker := is_limit_of_has_kernel_of_preserves_limit L g\n  refine' (exact_iff' _ _ hker hcoker).2 ⟨by simp [← L.map_comp, e1.1], _⟩\n  rw [fork.ι_of_ι, cofork.π_of_π, ← L.map_comp, kernel_comp_cokernel _ _ e1, L.map_zero]\n#align map_exact map_exact\n\n",
 "inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem kernel.lift.inv [Mono f] (ex : exact f g) : «expr ≫ » (inv (kernel.lift _ _ ex.w)) f = kernel.ι g := by simp\n#align kernel.lift.inv kernel.lift.inv\n\n",
 "exact_tfae":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- failed to parenthesize: parenthesize: uncaught backtrack exception\n[PrettyPrinter.parenthesize.input] (Command.declaration\n     (Command.declModifiers [] [] [] [] [] [])\n     (Command.theorem\n      \"theorem\"\n      (Command.declId `exact_tfae [])\n      (Command.declSig\n       []\n       (Term.typeSpec\n        \":\"\n        (Term.app\n         `TFAE\n         [(«term[_]»\n           \"[\"\n           [(Term.app `exact [`f `g])\n            \",\"\n            («term_∧_»\n             («term_=_» (Term.app `«expr ≫ » [`f `g]) \"=\" (num \"0\"))\n             \"∧\"\n             («term_=_» (Term.app `«expr ≫ » [(Term.app `kernel.ι [`g]) (Term.app `cokernel.π [`f])]) \"=\" (num \"0\")))\n            \",\"\n            («term_=_» (Term.app `image_subobject [`f]) \"=\" (Term.app `kernel_subobject [`g]))]\n           \"]\")])))\n      (Command.declValSimple\n       \":=\"\n       (Term.byTactic\n        \"by\"\n        (Tactic.tacticSeq\n         (Tactic.tacticSeq1Indented\n          [(Tactic.tfaeHave \"tfae_have\" [] (num \"1\") \"↔\" (num \"2\"))\n           \";\"\n           (tactic__ (cdotTk (patternIgnore (token.«· » \"·\"))) [(Tactic.apply \"apply\" `exact_iff)])\n           []\n           (Tactic.tfaeHave \"tfae_have\" [] (num \"1\") \"↔\" (num \"3\"))\n           \";\"\n           (tactic__ (cdotTk (patternIgnore (token.«· » \"·\"))) [(Tactic.apply \"apply\" `exact_iff_image_eq_kernel)])\n           []\n           (Tactic.tfaeFinish \"tfae_finish\")])))\n       [])\n      []\n      []))\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.byTactic\n       \"by\"\n       (Tactic.tacticSeq\n        (Tactic.tacticSeq1Indented\n         [(Tactic.tfaeHave \"tfae_have\" [] (num \"1\") \"↔\" (num \"2\"))\n          \";\"\n          (tactic__ (cdotTk (patternIgnore (token.«· » \"·\"))) [(Tactic.apply \"apply\" `exact_iff)])\n          []\n          (Tactic.tfaeHave \"tfae_have\" [] (num \"1\") \"↔\" (num \"3\"))\n          \";\"\n          (tactic__ (cdotTk (patternIgnore (token.«· » \"·\"))) [(Tactic.apply \"apply\" `exact_iff_image_eq_kernel)])\n          []\n          (Tactic.tfaeFinish \"tfae_finish\")])))\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.tfaeFinish \"tfae_finish\")\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (tactic__ (cdotTk (patternIgnore (token.«· » \"·\"))) [(Tactic.apply \"apply\" `exact_iff_image_eq_kernel)])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.apply \"apply\" `exact_iff_image_eq_kernel)\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `exact_iff_image_eq_kernel\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.tfaeHave \"tfae_have\" [] (num \"1\") \"↔\" (num \"3\"))\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind '«↔»', expected 'token.« → »'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind '«↔»', expected 'token.« ↔ »'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind '«↔»', expected 'token.« ← »'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.declValEqns'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.whereStructInst'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception\ntheorem\n  exact_tfae\n  :\n    TFAE\n      [ exact f g , «expr ≫ » f g = 0 ∧ «expr ≫ » kernel.ι g cokernel.π f = 0 , image_subobject f = kernel_subobject g ]\n  := by tfae_have 1 ↔ 2 ; · apply exact_iff tfae_have 1 ↔ 3 ; · apply exact_iff_image_eq_kernel tfae_finish\n#align exact_tfae exact_tfae\n\n",
 "exact_of_is_kernel":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem exact_of_is_kernel (w : «expr ≫ » f g = 0) (h : is_limit (kernel_fork.of_ι _ w)) : exact f g :=\n  by\n  refine' (exact_iff _ _).2 ⟨w, _⟩\n  have := h.fac (kernel_fork.of_ι _ (kernel.condition g)) walking_parallel_pair.zero\n  simp only [fork.of_ι_π_app] at this\n  rw [← this, category.assoc, cokernel.condition, comp_zero]\n#align exact_of_is_kernel exact_of_is_kernel\n\n",
 "exact_of_is_cokernel":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem exact_of_is_cokernel (w : «expr ≫ » f g = 0) (h : is_colimit (cokernel_cofork.of_π _ w)) : exact f g :=\n  by\n  refine' (exact_iff _ _).2 ⟨w, _⟩\n  have := h.fac (cokernel_cofork.of_π _ (cokernel.condition f)) walking_parallel_pair.one\n  simp only [cofork.of_π_ι_app] at this\n  rw [← this, ← category.assoc, kernel.condition, zero_comp]\n#align exact_of_is_cokernel exact_of_is_cokernel\n\n",
 "exact_iff_image_eq_kernel":
 "/-\nCopyright (c) 2020 Markus Himmel. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Markus Himmel, Adam Topaz, Johan Commelin, Jakob von Raumer\n-/\n/-- In an abelian category, a pair of morphisms `f : X ⟶ Y`, `g : Y ⟶ Z` is exact\niff `image_subobject f = kernel_subobject g`.\n-/\ntheorem exact_iff_image_eq_kernel : exact f g ↔ image_subobject f = kernel_subobject g :=\n  by\n  constructor\n  · intro h\n    fapply subobject.eq_of_comm\n    · suffices is_iso (image_to_kernel _ _ h.w) by exact as_iso (image_to_kernel _ _ h.w)\n      exact is_iso_of_mono_of_epi _\n    · simp\n  · apply exact_of_image_eq_kernel\n#align exact_iff_image_eq_kernel exact_iff_image_eq_kernel\n\n",
 "exact_iff_exact_image_ι":
 "theorem exact_iff_exact_image_ι : exact f g ↔ exact (abelian.image.ι f) g := by\n  conv_lhs => rw [← abelian.image.fac f] <;> apply exact_epi_comp_iff\n#align exact_iff_exact_image_ι exact_iff_exact_image_ι\n\n",
 "exact_iff_exact_coimage_π":
 "theorem exact_iff_exact_coimage_π : exact f g ↔ exact f (coimage.π g) := by\n  conv_lhs => rw [← abelian.coimage.fac g] <;> apply exact_comp_mono_iff\n#align exact_iff_exact_coimage_π exact_iff_exact_coimage_π\n\n",
 "exact_iff'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem exact_iff' {cg : kernel_fork g} (hg : is_limit cg) {cf : cokernel_cofork f} (hf : is_colimit cf) :\n    exact f g ↔ «expr ≫ » f g = 0 ∧ «expr ≫ » cg.ι cf.π = 0 :=\n  by\n  constructor\n  · intro h\n    exact ⟨h.1, fork_ι_comp_cofork_π f g h cg cf⟩\n  · rw [exact_iff]\n    refine' fun h => ⟨h.1, _⟩\n    apply zero_of_epi_comp (is_limit.cone_point_unique_up_to_iso hg (limit.is_limit _)).hom\n    apply zero_of_comp_mono (is_colimit.cocone_point_unique_up_to_iso (colimit.is_colimit _) hf).hom\n    simp [h.2]\n#align exact_iff' exact_iff'\n\n",
 "exact_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\ntheorem is_equivalence.exact_iff {D : Type u₁} [Category.{v₁} D] [abelian D] (F : «expr ⥤ » C D) [is_equivalence F] :\n    exact (F.map f) (F.map g) ↔ exact f g :=\n  by\n  simp only [exact_iff, ← F.map_eq_zero_iff, F.map_comp, category.assoc, ← kernel_comparison_comp_ι g F, ←\n    π_comp_cokernel_comparison f F]\n  rw [is_iso.comp_left_eq_zero (kernel_comparison g F), ← category.assoc,\n    is_iso.comp_right_eq_zero _ (cokernel_comparison f F)]\n#align is_equivalence.exact_iff is_equivalence.exact_iff\n\n",
 "exact_epi_comp_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/-- The dual result is true even in non-abelian categories, see\n    `category_theory.exact_comp_mono_iff`. -/\ntheorem exact_epi_comp_iff {W : C} (h : «expr ⟶ » W X) [Epi h] : exact («expr ≫ » h f) g ↔ exact f g :=\n  by\n  refine' ⟨fun hfg => _, fun h => exact_epi_comp h⟩\n  let hc :=\n    is_cokernel_of_comp _ _ (colimit.is_colimit (parallel_pair («expr ≫ » h f) 0))\n      (by rw [← cancel_epi h, ← category.assoc, cokernel_cofork.condition, comp_zero]) rfl\n  refine' (exact_iff' _ _ (limit.is_limit _) hc).2 ⟨_, ((exact_iff _ _).1 hfg).2⟩\n  exact zero_of_epi_comp h (by rw [← hfg.1, category.assoc])\n#align exact_epi_comp_iff exact_epi_comp_iff\n\n",
 "exact_cokernel":
 "theorem exact_cokernel : exact f (cokernel.π f) := by\n  rw [exact_iff]\n  tidy\n#align exact_cokernel exact_cokernel\n\n",
 "epi_iff_cokernel_π_eq_zero":
 "-- Note we've already proved `epi_iff_exact_zero_right : epi f ↔ exact f (0 : Y ⟶ Z)`\n-- in any preadditive category with equalizers and images.\ntheorem epi_iff_cokernel_π_eq_zero : Epi f ↔ cokernel.π f = 0 :=\n  (tfae_epi X f).out 0 1\n#align epi_iff_cokernel_π_eq_zero epi_iff_cokernel_π_eq_zero\n\n"}