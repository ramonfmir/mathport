{"unop_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr áµ’áµ–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem exact.unop_iff {X Y Z : Â«expr áµ’áµ–Â» C} (g : Â«expr âŸ¶ Â» X Y) (f : Â«expr âŸ¶ Â» Y Z) :\n    Exact f.unop g.unop â†” Exact g f :=\n  âŸ¨fun e => by rwa [â† f.op_unop, â† g.op_unop, â† exact.op_iff] at e, fun e => @Exact.unop _ _ g f eâŸ©\n#align exact.unop_iff exact.unop_iff\n\n",
 "unop":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr áµ’áµ–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem exact.unop {X Y Z : Â«expr áµ’áµ–Â» C} (g : Â«expr âŸ¶ Â» X Y) (f : Â«expr âŸ¶ Â» Y Z) (h : Exact g f) :\n    Exact f.unop g.unop := by\n  rw [â† f.op_unop, â† g.op_unop] at h\n  rwa [â† exact.op_iff]\n#align exact.unop exact.unop\n\n",
 "tfae_mono":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem tfae_mono : TFAE [Mono f, kernel.Î¹ f = 0, Exact (0 : Â«expr âŸ¶ Â» Z X) f] :=\n  by\n  tfae_have 3 â†’ 2\n  Â· exact kernel_Î¹_eq_zero_of_exact_zero_left Z\n  tfae_have 1 â†’ 3\n  Â· intros\n    exact exact_zero_left_of_mono Z\n  tfae_have 2 â†’ 1\n  Â· exact mono_of_kernel_Î¹_eq_zero _\n  tfae_finish\n#align tfae_mono tfae_mono\n\n",
 "tfae_epi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem tfae_epi : TFAE [Epi f, cokernel.Ï€ f = 0, Exact f (0 : Â«expr âŸ¶ Â» Y Z)] :=\n  by\n  tfae_have 3 â†’ 2\n  Â· rw [exact_iff]\n    rintro âŸ¨-, hâŸ©\n    exact zero_of_epi_comp _ h\n  tfae_have 1 â†’ 3\n  Â· rw [exact_iff]\n    intro\n    exact âŸ¨by simp, by simp [cokernel.Ï€_of_epi]âŸ©\n  tfae_have 2 â†’ 1\n  Â· exact epi_of_cokernel_Ï€_eq_zero _\n  tfae_finish\n#align tfae_epi tfae_epi\n\n",
 "preserves_zero_morphisms_of_map_exact":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n/-- A functor which preserves exactness preserves zero morphisms. -/\ntheorem preserves_zero_morphisms_of_map_exact : L.preserves_zero_morphisms :=\n  by\n  replace h := (h (exact_of_zero ((Â«exprğŸ™Â») 0) ((Â«exprğŸ™Â») 0))).w\n  rw [L.map_id, category.comp_id] at h\n  exact preserves_zero_morphisms_of_map_zero_object (id_zero_equiv_iso_zero _ h)\n#align preserves_zero_morphisms_of_map_exact preserves_zero_morphisms_of_map_exact\n\n",
 "preserves_monomorphisms_of_map_exact":
 "/-- A functor which preserves exactness preserves monomorphisms. -/\ntheorem preserves_monomorphisms_of_map_exact : L.preserves_monomorphisms :=\n  {\n    preserves := fun X Y f hf => by\n      letI := preserves_zero_morphisms_of_map_exact L h\n      apply ((tfae_mono (L.obj 0) (L.map f)).out 2 0).mp\n      rw [â† L.map_zero]\n      exact h (((tfae_mono 0 f).out 0 2).mp hf) }\n#align preserves_monomorphisms_of_map_exact preserves_monomorphisms_of_map_exact\n\n",
 "preserves_epimorphisms_of_map_exact":
 "/-- A functor which preserves exactness preserves epimorphisms. -/\ntheorem preserves_epimorphisms_of_map_exact : L.preserves_epimorphisms :=\n  {\n    preserves := fun X Y f hf => by\n      letI := preserves_zero_morphisms_of_map_exact L h\n      apply ((tfae_epi (L.obj 0) (L.map f)).out 2 0).mp\n      rw [â† L.map_zero]\n      exact h (((tfae_epi 0 f).out 0 2).mp hf) }\n#align preserves_epimorphisms_of_map_exact preserves_epimorphisms_of_map_exact\n\n",
 "op_iff":
 "theorem exact.op_iff : Exact g.op f.op â†” Exact f g :=\n  âŸ¨fun e => by\n    rw [â† is_equivalence.exact_iff _ _ (op_op_equivalence C).inverse]\n    exact exact.op _ _ e, Exact.op _ _âŸ©\n#align exact.op_iff exact.op_iff\n\n",
 "op":
 "theorem exact.op (h : Exact f g) : Exact g.op f.op :=\n  by\n  rw [exact_iff]\n  refine' âŸ¨by simp [â† op_comp, h.w], Quiver.Hom.unop_inj _âŸ©\n  simp only [unop_comp, cokernel.Ï€_op, eq_to_hom_refl, kernel.Î¹_op, category.id_comp, category.assoc,\n    kernel_comp_cokernel_assoc _ _ h, zero_comp, comp_zero, unop_zero]\n#align exact.op exact.op\n\n",
 "mono_iff_kernel_Î¹_eq_zero":
 "-- Note we've already proved `mono_iff_exact_zero_left : mono f â†” exact (0 : Z âŸ¶ X) f`\n-- in any preadditive category with kernels and images.\ntheorem mono_iff_kernel_Î¹_eq_zero : Mono f â†” kernel.Î¹ f = 0 :=\n  (tfae_mono X f).out 0 1\n#align mono_iff_kernel_Î¹_eq_zero mono_iff_kernel_Î¹_eq_zero\n\n",
 "map_exact":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/-- A functor preserving finite limits and finite colimits preserves exactness. The converse\nresult is also true, see `functor.preserves_finite_limits_of_map_exact` and\n`functor.preserves_finite_colimits_of_map_exact`. -/\ntheorem map_exact {X Y Z : A} (f : Â«expr âŸ¶ Â» X Y) (g : Â«expr âŸ¶ Â» Y Z) (e1 : Exact f g) : Exact (L.map f) (L.map g) :=\n  by\n  let hcoker := is_colimit_of_has_cokernel_of_preserves_colimit L f\n  let hker := is_limit_of_has_kernel_of_preserves_limit L g\n  refine' (exact_iff' _ _ hker hcoker).2 âŸ¨by simp [â† L.map_comp, e1.1], _âŸ©\n  rw [fork.Î¹_of_Î¹, cofork.Ï€_of_Ï€, â† L.map_comp, kernel_comp_cokernel _ _ e1, L.map_zero]\n#align map_exact map_exact\n\n",
 "inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n@[simp, reassoc.1]\ntheorem kernel.lift.inv [Mono f] (ex : Exact f g) : Â«expr â‰« Â» (inv (kernel.lift _ _ ex.w)) f = kernel.Î¹ g := by simp\n#align kernel.lift.inv kernel.lift.inv\n\n",
 "exact_tfae":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\ntheorem exact_tfae :\n    TFAE\n      [Exact f g, Â«expr â‰« Â» f g = 0 âˆ§ Â«expr â‰« Â» (kernel.Î¹ g) (cokernel.Ï€ f) = 0,\n        imageSubobject f = kernelSubobject g] :=\n  by\n  tfae_have 1 â†” 2; Â· apply exact_iff\n  tfae_have 1 â†” 3; Â· apply exact_iff_image_eq_kernel\n  tfae_finish\n#align exact_tfae exact_tfae\n\n",
 "exact_of_is_kernel":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\ntheorem exact_of_is_kernel (w : Â«expr â‰« Â» f g = 0) (h : IsLimit (KernelFork.ofÎ¹ _ w)) : Exact f g :=\n  by\n  refine' (exact_iff _ _).2 âŸ¨w, _âŸ©\n  have := h.fac (kernel_fork.of_Î¹ _ (kernel.condition g)) walking_parallel_pair.zero\n  simp only [fork.of_Î¹_Ï€_app] at this\n  rw [â† this, category.assoc, cokernel.condition, comp_zero]\n#align exact_of_is_kernel exact_of_is_kernel\n\n",
 "exact_of_is_cokernel":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\ntheorem exact_of_is_cokernel (w : Â«expr â‰« Â» f g = 0) (h : IsColimit (CokernelCofork.ofÏ€ _ w)) : Exact f g :=\n  by\n  refine' (exact_iff _ _).2 âŸ¨w, _âŸ©\n  have := h.fac (cokernel_cofork.of_Ï€ _ (cokernel.condition f)) walking_parallel_pair.one\n  simp only [cofork.of_Ï€_Î¹_app] at this\n  rw [â† this, â† category.assoc, kernel.condition, zero_comp]\n#align exact_of_is_cokernel exact_of_is_cokernel\n\n",
 "exact_iff_image_eq_kernel":
 "/-\nCopyright (c) 2020 Markus Himmel. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Markus Himmel, Adam Topaz, Johan Commelin, Jakob von Raumer\n-/\n/-- In an abelian category, a pair of morphisms `f : X âŸ¶ Y`, `g : Y âŸ¶ Z` is exact\niff `image_subobject f = kernel_subobject g`.\n-/\ntheorem exact_iff_image_eq_kernel : Exact f g â†” imageSubobject f = kernelSubobject g :=\n  by\n  constructor\n  Â· intro h\n    fapply subobject.eq_of_comm\n    Â· suffices is_iso (imageToKernel _ _ h.w) by exact as_iso (imageToKernel _ _ h.w)\n      exact is_iso_of_mono_of_epi _\n    Â· simp\n  Â· apply exact_of_image_eq_kernel\n#align exact_iff_image_eq_kernel exact_iff_image_eq_kernel\n\n",
 "exact_iff_exact_image_Î¹":
 "theorem exact_iff_exact_image_Î¹ : Exact f g â†” Exact (Abelian.image.Î¹ f) g := by\n  conv_lhs => rw [â† abelian.image.fac f] <;> apply exact_epi_comp_iff\n#align exact_iff_exact_image_Î¹ exact_iff_exact_image_Î¹\n\n",
 "exact_iff_exact_coimage_Ï€":
 "theorem exact_iff_exact_coimage_Ï€ : Exact f g â†” Exact f (coimage.Ï€ g) := by\n  conv_lhs => rw [â† abelian.coimage.fac g] <;> apply exact_comp_mono_iff\n#align exact_iff_exact_coimage_Ï€ exact_iff_exact_coimage_Ï€\n\n",
 "exact_iff'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\ntheorem exact_iff' {cg : KernelFork g} (hg : IsLimit cg) {cf : CokernelCofork f} (hf : IsColimit cf) :\n    Exact f g â†” Â«expr â‰« Â» f g = 0 âˆ§ Â«expr â‰« Â» cg.Î¹ cf.Ï€ = 0 :=\n  by\n  constructor\n  Â· intro h\n    exact âŸ¨h.1, fork_Î¹_comp_cofork_Ï€ f g h cg cfâŸ©\n  Â· rw [exact_iff]\n    refine' fun h => âŸ¨h.1, _âŸ©\n    apply zero_of_epi_comp (is_limit.cone_point_unique_up_to_iso hg (limit.is_limit _)).hom\n    apply zero_of_comp_mono (is_colimit.cocone_point_unique_up_to_iso (colimit.is_colimit _) hf).hom\n    simp [h.2]\n#align exact_iff' exact_iff'\n\n",
 "exact_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\ntheorem is_equivalence.exact_iff {D : Type uâ‚} [Category.{vâ‚} D] [Abelian D] (F : Â«expr â¥¤ Â» C D) [IsEquivalence F] :\n    Exact (F.map f) (F.map g) â†” Exact f g :=\n  by\n  simp only [exact_iff, â† F.map_eq_zero_iff, F.map_comp, category.assoc, â† kernel_comparison_comp_Î¹ g F, â†\n    Ï€_comp_cokernel_comparison f F]\n  rw [is_iso.comp_left_eq_zero (kernel_comparison g F), â† category.assoc,\n    is_iso.comp_right_eq_zero _ (cokernel_comparison f F)]\n#align is_equivalence.exact_iff is_equivalence.exact_iff\n\n",
 "exact_epi_comp_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/-- The dual result is true even in non-abelian categories, see\n    `category_theory.exact_comp_mono_iff`. -/\ntheorem exact_epi_comp_iff {W : C} (h : Â«expr âŸ¶ Â» W X) [Epi h] : Exact (Â«expr â‰« Â» h f) g â†” Exact f g :=\n  by\n  refine' âŸ¨fun hfg => _, fun h => exact_epi_comp hâŸ©\n  let hc :=\n    is_cokernel_of_comp _ _ (colimit.is_colimit (parallel_pair (Â«expr â‰« Â» h f) 0))\n      (by rw [â† cancel_epi h, â† category.assoc, cokernel_cofork.condition, comp_zero]) rfl\n  refine' (exact_iff' _ _ (limit.is_limit _) hc).2 âŸ¨_, ((exact_iff _ _).1 hfg).2âŸ©\n  exact zero_of_epi_comp h (by rw [â† hfg.1, category.assoc])\n#align exact_epi_comp_iff exact_epi_comp_iff\n\n",
 "exact_cokernel":
 "theorem exact_cokernel : Exact f (cokernel.Ï€ f) := by\n  rw [exact_iff]\n  tidy\n#align exact_cokernel exact_cokernel\n\n",
 "epi_iff_cokernel_Ï€_eq_zero":
 "-- Note we've already proved `epi_iff_exact_zero_right : epi f â†” exact f (0 : Y âŸ¶ Z)`\n-- in any preadditive category with equalizers and images.\ntheorem epi_iff_cokernel_Ï€_eq_zero : Epi f â†” cokernel.Ï€ f = 0 :=\n  (tfae_epi X f).out 0 1\n#align epi_iff_cokernel_Ï€_eq_zero epi_iff_cokernel_Ï€_eq_zero\n\n"}