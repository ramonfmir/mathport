{"unop_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr áµ’áµ–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem exact.unop_iff {X Y Z : Â«expr áµ’áµ–Â» C} (g : Â«expr âŸ¶ Â» X Y) (f : Â«expr âŸ¶ Â» Y Z) :\n    exact f.unop g.unop â†” exact g f :=\n  âŸ¨fun e => by rwa [â† f.op_unop, â† g.op_unop, â† exact.op_iff] at e, fun e => @exact.unop _ _ g f eâŸ©\n#align exact.unop_iff exact.unop_iff\n\n",
 "unop":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr áµ’áµ–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem exact.unop {X Y Z : Â«expr áµ’áµ–Â» C} (g : Â«expr âŸ¶ Â» X Y) (f : Â«expr âŸ¶ Â» Y Z) (h : exact g f) :\n    exact f.unop g.unop := by\n  rw [â† f.op_unop, â† g.op_unop] at h\n  rwa [â† exact.op_iff]\n#align exact.unop exact.unop\n\n",
 "tfae_mono":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- failed to parenthesize: parenthesize: uncaught backtrack exception\n[PrettyPrinter.parenthesize.input] (Command.declaration\n     (Command.declModifiers [] [] [] [] [] [])\n     (Command.theorem\n      \"theorem\"\n      (Command.declId `tfae_mono [])\n      (Command.declSig\n       []\n       (Term.typeSpec\n        \":\"\n        (Term.app\n         `TFAE\n         [(Â«term[_]Â»\n           \"[\"\n           [(Term.app `Mono [`f])\n            \",\"\n            (Â«term_=_Â» (Term.app `kernel.Î¹ [`f]) \"=\" (num \"0\"))\n            \",\"\n            (Term.app `exact [(Term.typeAscription \"(\" (num \"0\") \":\" [(Term.app `Â«expr âŸ¶ Â» [`Z `X])] \")\") `f])]\n           \"]\")])))\n      (Command.declValSimple\n       \":=\"\n       (Term.byTactic\n        \"by\"\n        (Tactic.tacticSeq\n         (Tactic.tacticSeq1Indented\n          [(Tactic.tfaeHave \"tfae_have\" [] (num \"3\") \"â†’\" (num \"2\"))\n           []\n           (tactic__\n            (cdotTk (patternIgnore (token.Â«Â· Â» \"Â·\")))\n            [(Tactic.exact \"exact\" (Term.app `kernel_Î¹_eq_zero_of_exact_zero_left [`Z]))])\n           []\n           (Tactic.tfaeHave \"tfae_have\" [] (num \"1\") \"â†’\" (num \"3\"))\n           []\n           (tactic__\n            (cdotTk (patternIgnore (token.Â«Â· Â» \"Â·\")))\n            [(Tactic.intros \"intros\" []) [] (Tactic.exact \"exact\" (Term.app `exact_zero_left_of_mono [`Z]))])\n           []\n           (Tactic.tfaeHave \"tfae_have\" [] (num \"2\") \"â†’\" (num \"1\"))\n           []\n           (tactic__\n            (cdotTk (patternIgnore (token.Â«Â· Â» \"Â·\")))\n            [(Tactic.exact \"exact\" (Term.app `mono_of_kernel_Î¹_eq_zero [(Term.hole \"_\")]))])\n           []\n           (Tactic.tfaeFinish \"tfae_finish\")])))\n       [])\n      []\n      []))\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.byTactic\n       \"by\"\n       (Tactic.tacticSeq\n        (Tactic.tacticSeq1Indented\n         [(Tactic.tfaeHave \"tfae_have\" [] (num \"3\") \"â†’\" (num \"2\"))\n          []\n          (tactic__\n           (cdotTk (patternIgnore (token.Â«Â· Â» \"Â·\")))\n           [(Tactic.exact \"exact\" (Term.app `kernel_Î¹_eq_zero_of_exact_zero_left [`Z]))])\n          []\n          (Tactic.tfaeHave \"tfae_have\" [] (num \"1\") \"â†’\" (num \"3\"))\n          []\n          (tactic__\n           (cdotTk (patternIgnore (token.Â«Â· Â» \"Â·\")))\n           [(Tactic.intros \"intros\" []) [] (Tactic.exact \"exact\" (Term.app `exact_zero_left_of_mono [`Z]))])\n          []\n          (Tactic.tfaeHave \"tfae_have\" [] (num \"2\") \"â†’\" (num \"1\"))\n          []\n          (tactic__\n           (cdotTk (patternIgnore (token.Â«Â· Â» \"Â·\")))\n           [(Tactic.exact \"exact\" (Term.app `mono_of_kernel_Î¹_eq_zero [(Term.hole \"_\")]))])\n          []\n          (Tactic.tfaeFinish \"tfae_finish\")])))\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.tfaeFinish \"tfae_finish\")\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (tactic__\n       (cdotTk (patternIgnore (token.Â«Â· Â» \"Â·\")))\n       [(Tactic.exact \"exact\" (Term.app `mono_of_kernel_Î¹_eq_zero [(Term.hole \"_\")]))])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.exact \"exact\" (Term.app `mono_of_kernel_Î¹_eq_zero [(Term.hole \"_\")]))\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.app `mono_of_kernel_Î¹_eq_zero [(Term.hole \"_\")])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.namedArgument'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.ellipsis'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.hole \"_\")\n[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))\n      `mono_of_kernel_Î¹_eq_zero\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1022, term)\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.tfaeHave \"tfae_have\" [] (num \"2\") \"â†’\" (num \"1\"))\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Â«â†’Â»', expected 'token.Â« â†’ Â»'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Â«â†’Â»', expected 'token.Â« â†” Â»'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Â«â†’Â»', expected 'token.Â« â† Â»'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.declValEqns'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.whereStructInst'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception\ntheorem\n  tfae_mono\n  : TFAE [ Mono f , kernel.Î¹ f = 0 , exact ( 0 : Â«expr âŸ¶ Â» Z X ) f ]\n  :=\n    by\n      tfae_have 3 â†’ 2\n        Â· exact kernel_Î¹_eq_zero_of_exact_zero_left Z\n        tfae_have 1 â†’ 3\n        Â· intros exact exact_zero_left_of_mono Z\n        tfae_have 2 â†’ 1\n        Â· exact mono_of_kernel_Î¹_eq_zero _\n        tfae_finish\n#align tfae_mono tfae_mono\n\n",
 "tfae_epi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- failed to parenthesize: parenthesize: uncaught backtrack exception\n[PrettyPrinter.parenthesize.input] (Command.declaration\n     (Command.declModifiers [] [] [] [] [] [])\n     (Command.theorem\n      \"theorem\"\n      (Command.declId `tfae_epi [])\n      (Command.declSig\n       []\n       (Term.typeSpec\n        \":\"\n        (Term.app\n         `TFAE\n         [(Â«term[_]Â»\n           \"[\"\n           [(Term.app `Epi [`f])\n            \",\"\n            (Â«term_=_Â» (Term.app `cokernel.Ï€ [`f]) \"=\" (num \"0\"))\n            \",\"\n            (Term.app `exact [`f (Term.typeAscription \"(\" (num \"0\") \":\" [(Term.app `Â«expr âŸ¶ Â» [`Y `Z])] \")\")])]\n           \"]\")])))\n      (Command.declValSimple\n       \":=\"\n       (Term.byTactic\n        \"by\"\n        (Tactic.tacticSeq\n         (Tactic.tacticSeq1Indented\n          [(Tactic.tfaeHave \"tfae_have\" [] (num \"3\") \"â†’\" (num \"2\"))\n           []\n           (tactic__\n            (cdotTk (patternIgnore (token.Â«Â· Â» \"Â·\")))\n            [(Tactic.rwSeq \"rw\" [] (Tactic.rwRuleSeq \"[\" [(Tactic.rwRule [] `exact_iff)] \"]\") [])\n             []\n             (Std.Tactic.rintro\n              \"rintro\"\n              [(Std.Tactic.RCases.rintroPat.one\n                (Std.Tactic.RCases.rcasesPat.tuple\n                 \"âŸ¨\"\n                 [(Std.Tactic.RCases.rcasesPatLo\n                   (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.clear \"-\")])\n                   [])\n                  \",\"\n                  (Std.Tactic.RCases.rcasesPatLo\n                   (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `h)])\n                   [])]\n                 \"âŸ©\"))]\n              [])\n             []\n             (Tactic.exact \"exact\" (Term.app `zero_of_epi_comp [(Term.hole \"_\") `h]))])\n           []\n           (Tactic.tfaeHave \"tfae_have\" [] (num \"1\") \"â†’\" (num \"3\"))\n           []\n           (tactic__\n            (cdotTk (patternIgnore (token.Â«Â· Â» \"Â·\")))\n            [(Tactic.rwSeq \"rw\" [] (Tactic.rwRuleSeq \"[\" [(Tactic.rwRule [] `exact_iff)] \"]\") [])\n             []\n             (Tactic.intro \"intro\" [])\n             []\n             (Tactic.exact\n              \"exact\"\n              (Term.anonymousCtor\n               \"âŸ¨\"\n               [(Term.byTactic\n                 \"by\"\n                 (Tactic.tacticSeq (Tactic.tacticSeq1Indented [(Tactic.simp \"simp\" [] [] [] [] [])])))\n                \",\"\n                (Term.byTactic\n                 \"by\"\n                 (Tactic.tacticSeq\n                  (Tactic.tacticSeq1Indented\n                   [(Tactic.simp \"simp\" [] [] [] [\"[\" [(Tactic.simpLemma [] [] `cokernel.Ï€_of_epi)] \"]\"] [])])))]\n               \"âŸ©\"))])\n           []\n           (Tactic.tfaeHave \"tfae_have\" [] (num \"2\") \"â†’\" (num \"1\"))\n           []\n           (tactic__\n            (cdotTk (patternIgnore (token.Â«Â· Â» \"Â·\")))\n            [(Tactic.exact \"exact\" (Term.app `epi_of_cokernel_Ï€_eq_zero [(Term.hole \"_\")]))])\n           []\n           (Tactic.tfaeFinish \"tfae_finish\")])))\n       [])\n      []\n      []))\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.byTactic\n       \"by\"\n       (Tactic.tacticSeq\n        (Tactic.tacticSeq1Indented\n         [(Tactic.tfaeHave \"tfae_have\" [] (num \"3\") \"â†’\" (num \"2\"))\n          []\n          (tactic__\n           (cdotTk (patternIgnore (token.Â«Â· Â» \"Â·\")))\n           [(Tactic.rwSeq \"rw\" [] (Tactic.rwRuleSeq \"[\" [(Tactic.rwRule [] `exact_iff)] \"]\") [])\n            []\n            (Std.Tactic.rintro\n             \"rintro\"\n             [(Std.Tactic.RCases.rintroPat.one\n               (Std.Tactic.RCases.rcasesPat.tuple\n                \"âŸ¨\"\n                [(Std.Tactic.RCases.rcasesPatLo\n                  (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.clear \"-\")])\n                  [])\n                 \",\"\n                 (Std.Tactic.RCases.rcasesPatLo\n                  (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `h)])\n                  [])]\n                \"âŸ©\"))]\n             [])\n            []\n            (Tactic.exact \"exact\" (Term.app `zero_of_epi_comp [(Term.hole \"_\") `h]))])\n          []\n          (Tactic.tfaeHave \"tfae_have\" [] (num \"1\") \"â†’\" (num \"3\"))\n          []\n          (tactic__\n           (cdotTk (patternIgnore (token.Â«Â· Â» \"Â·\")))\n           [(Tactic.rwSeq \"rw\" [] (Tactic.rwRuleSeq \"[\" [(Tactic.rwRule [] `exact_iff)] \"]\") [])\n            []\n            (Tactic.intro \"intro\" [])\n            []\n            (Tactic.exact\n             \"exact\"\n             (Term.anonymousCtor\n              \"âŸ¨\"\n              [(Term.byTactic \"by\" (Tactic.tacticSeq (Tactic.tacticSeq1Indented [(Tactic.simp \"simp\" [] [] [] [] [])])))\n               \",\"\n               (Term.byTactic\n                \"by\"\n                (Tactic.tacticSeq\n                 (Tactic.tacticSeq1Indented\n                  [(Tactic.simp \"simp\" [] [] [] [\"[\" [(Tactic.simpLemma [] [] `cokernel.Ï€_of_epi)] \"]\"] [])])))]\n              \"âŸ©\"))])\n          []\n          (Tactic.tfaeHave \"tfae_have\" [] (num \"2\") \"â†’\" (num \"1\"))\n          []\n          (tactic__\n           (cdotTk (patternIgnore (token.Â«Â· Â» \"Â·\")))\n           [(Tactic.exact \"exact\" (Term.app `epi_of_cokernel_Ï€_eq_zero [(Term.hole \"_\")]))])\n          []\n          (Tactic.tfaeFinish \"tfae_finish\")])))\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.tfaeFinish \"tfae_finish\")\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (tactic__\n       (cdotTk (patternIgnore (token.Â«Â· Â» \"Â·\")))\n       [(Tactic.exact \"exact\" (Term.app `epi_of_cokernel_Ï€_eq_zero [(Term.hole \"_\")]))])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.exact \"exact\" (Term.app `epi_of_cokernel_Ï€_eq_zero [(Term.hole \"_\")]))\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.app `epi_of_cokernel_Ï€_eq_zero [(Term.hole \"_\")])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.namedArgument'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.ellipsis'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.hole \"_\")\n[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))\n      `epi_of_cokernel_Ï€_eq_zero\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1022, term)\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.tfaeHave \"tfae_have\" [] (num \"2\") \"â†’\" (num \"1\"))\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Â«â†’Â»', expected 'token.Â« â†’ Â»'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Â«â†’Â»', expected 'token.Â« â†” Â»'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Â«â†’Â»', expected 'token.Â« â† Â»'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.declValEqns'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.whereStructInst'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception\ntheorem\n  tfae_epi\n  : TFAE [ Epi f , cokernel.Ï€ f = 0 , exact f ( 0 : Â«expr âŸ¶ Â» Y Z ) ]\n  :=\n    by\n      tfae_have 3 â†’ 2\n        Â· rw [ exact_iff ] rintro âŸ¨ - , h âŸ© exact zero_of_epi_comp _ h\n        tfae_have 1 â†’ 3\n        Â· rw [ exact_iff ] intro exact âŸ¨ by simp , by simp [ cokernel.Ï€_of_epi ] âŸ©\n        tfae_have 2 â†’ 1\n        Â· exact epi_of_cokernel_Ï€_eq_zero _\n        tfae_finish\n#align tfae_epi tfae_epi\n\n",
 "preserves_zero_morphisms_of_map_exact":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n/-- A functor which preserves exactness preserves zero morphisms. -/\ntheorem preserves_zero_morphisms_of_map_exact : L.preserves_zero_morphisms :=\n  by\n  replace h := (h (exact_of_zero ((Â«exprğŸ™Â») 0) ((Â«exprğŸ™Â») 0))).w\n  rw [L.map_id, category.comp_id] at h\n  exact preserves_zero_morphisms_of_map_zero_object (id_zero_equiv_iso_zero _ h)\n#align preserves_zero_morphisms_of_map_exact preserves_zero_morphisms_of_map_exact\n\n",
 "preserves_monomorphisms_of_map_exact":
 "/-- A functor which preserves exactness preserves monomorphisms. -/\ntheorem preserves_monomorphisms_of_map_exact : L.preserves_monomorphisms :=\n  {\n    preserves := fun X Y f hf => by\n      letI := preserves_zero_morphisms_of_map_exact L h\n      apply ((tfae_mono (L.obj 0) (L.map f)).out 2 0).mp\n      rw [â† L.map_zero]\n      exact h (((tfae_mono 0 f).out 0 2).mp hf) }\n#align preserves_monomorphisms_of_map_exact preserves_monomorphisms_of_map_exact\n\n",
 "preserves_epimorphisms_of_map_exact":
 "/-- A functor which preserves exactness preserves epimorphisms. -/\ntheorem preserves_epimorphisms_of_map_exact : L.preserves_epimorphisms :=\n  {\n    preserves := fun X Y f hf => by\n      letI := preserves_zero_morphisms_of_map_exact L h\n      apply ((tfae_epi (L.obj 0) (L.map f)).out 2 0).mp\n      rw [â† L.map_zero]\n      exact h (((tfae_epi 0 f).out 0 2).mp hf) }\n#align preserves_epimorphisms_of_map_exact preserves_epimorphisms_of_map_exact\n\n",
 "op_iff":
 "theorem exact.op_iff : exact g.op f.op â†” exact f g :=\n  âŸ¨fun e => by\n    rw [â† is_equivalence.exact_iff _ _ (op_op_equivalence C).inverse]\n    exact exact.op _ _ e, exact.op _ _âŸ©\n#align exact.op_iff exact.op_iff\n\n",
 "op":
 "theorem exact.op (h : exact f g) : exact g.op f.op :=\n  by\n  rw [exact_iff]\n  refine' âŸ¨by simp [â† op_comp, h.w], quiver.hom.unop_inj _âŸ©\n  simp only [unop_comp, cokernel.Ï€_op, eq_to_hom_refl, kernel.Î¹_op, category.id_comp, category.assoc,\n    kernel_comp_cokernel_assoc _ _ h, zero_comp, comp_zero, unop_zero]\n#align exact.op exact.op\n\n",
 "mono_iff_kernel_Î¹_eq_zero":
 "-- Note we've already proved `mono_iff_exact_zero_left : mono f â†” exact (0 : Z âŸ¶ X) f`\n-- in any preadditive category with kernels and images.\ntheorem mono_iff_kernel_Î¹_eq_zero : Mono f â†” kernel.Î¹ f = 0 :=\n  (tfae_mono X f).out 0 1\n#align mono_iff_kernel_Î¹_eq_zero mono_iff_kernel_Î¹_eq_zero\n\n",
 "map_exact":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/-- A functor preserving finite limits and finite colimits preserves exactness. The converse\nresult is also true, see `functor.preserves_finite_limits_of_map_exact` and\n`functor.preserves_finite_colimits_of_map_exact`. -/\ntheorem map_exact {X Y Z : A} (f : Â«expr âŸ¶ Â» X Y) (g : Â«expr âŸ¶ Â» Y Z) (e1 : exact f g) : exact (L.map f) (L.map g) :=\n  by\n  let hcoker := is_colimit_of_has_cokernel_of_preserves_colimit L f\n  let hker := is_limit_of_has_kernel_of_preserves_limit L g\n  refine' (exact_iff' _ _ hker hcoker).2 âŸ¨by simp [â† L.map_comp, e1.1], _âŸ©\n  rw [fork.Î¹_of_Î¹, cofork.Ï€_of_Ï€, â† L.map_comp, kernel_comp_cokernel _ _ e1, L.map_zero]\n#align map_exact map_exact\n\n",
 "inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n@[simp, reassoc.1]\ntheorem kernel.lift.inv [Mono f] (ex : exact f g) : Â«expr â‰« Â» (inv (kernel.lift _ _ ex.w)) f = kernel.Î¹ g := by simp\n#align kernel.lift.inv kernel.lift.inv\n\n",
 "exact_tfae":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- failed to parenthesize: parenthesize: uncaught backtrack exception\n[PrettyPrinter.parenthesize.input] (Command.declaration\n     (Command.declModifiers [] [] [] [] [] [])\n     (Command.theorem\n      \"theorem\"\n      (Command.declId `exact_tfae [])\n      (Command.declSig\n       []\n       (Term.typeSpec\n        \":\"\n        (Term.app\n         `TFAE\n         [(Â«term[_]Â»\n           \"[\"\n           [(Term.app `exact [`f `g])\n            \",\"\n            (Â«term_âˆ§_Â»\n             (Â«term_=_Â» (Term.app `Â«expr â‰« Â» [`f `g]) \"=\" (num \"0\"))\n             \"âˆ§\"\n             (Â«term_=_Â» (Term.app `Â«expr â‰« Â» [(Term.app `kernel.Î¹ [`g]) (Term.app `cokernel.Ï€ [`f])]) \"=\" (num \"0\")))\n            \",\"\n            (Â«term_=_Â» (Term.app `image_subobject [`f]) \"=\" (Term.app `kernel_subobject [`g]))]\n           \"]\")])))\n      (Command.declValSimple\n       \":=\"\n       (Term.byTactic\n        \"by\"\n        (Tactic.tacticSeq\n         (Tactic.tacticSeq1Indented\n          [(Tactic.tfaeHave \"tfae_have\" [] (num \"1\") \"â†”\" (num \"2\"))\n           \";\"\n           (tactic__ (cdotTk (patternIgnore (token.Â«Â· Â» \"Â·\"))) [(Tactic.apply \"apply\" `exact_iff)])\n           []\n           (Tactic.tfaeHave \"tfae_have\" [] (num \"1\") \"â†”\" (num \"3\"))\n           \";\"\n           (tactic__ (cdotTk (patternIgnore (token.Â«Â· Â» \"Â·\"))) [(Tactic.apply \"apply\" `exact_iff_image_eq_kernel)])\n           []\n           (Tactic.tfaeFinish \"tfae_finish\")])))\n       [])\n      []\n      []))\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.byTactic\n       \"by\"\n       (Tactic.tacticSeq\n        (Tactic.tacticSeq1Indented\n         [(Tactic.tfaeHave \"tfae_have\" [] (num \"1\") \"â†”\" (num \"2\"))\n          \";\"\n          (tactic__ (cdotTk (patternIgnore (token.Â«Â· Â» \"Â·\"))) [(Tactic.apply \"apply\" `exact_iff)])\n          []\n          (Tactic.tfaeHave \"tfae_have\" [] (num \"1\") \"â†”\" (num \"3\"))\n          \";\"\n          (tactic__ (cdotTk (patternIgnore (token.Â«Â· Â» \"Â·\"))) [(Tactic.apply \"apply\" `exact_iff_image_eq_kernel)])\n          []\n          (Tactic.tfaeFinish \"tfae_finish\")])))\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.tfaeFinish \"tfae_finish\")\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (tactic__ (cdotTk (patternIgnore (token.Â«Â· Â» \"Â·\"))) [(Tactic.apply \"apply\" `exact_iff_image_eq_kernel)])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.apply \"apply\" `exact_iff_image_eq_kernel)\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `exact_iff_image_eq_kernel\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.tfaeHave \"tfae_have\" [] (num \"1\") \"â†”\" (num \"3\"))\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Â«â†”Â»', expected 'token.Â« â†’ Â»'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Â«â†”Â»', expected 'token.Â« â†” Â»'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Â«â†”Â»', expected 'token.Â« â† Â»'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.declValEqns'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.whereStructInst'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception\ntheorem\n  exact_tfae\n  :\n    TFAE\n      [ exact f g , Â«expr â‰« Â» f g = 0 âˆ§ Â«expr â‰« Â» kernel.Î¹ g cokernel.Ï€ f = 0 , image_subobject f = kernel_subobject g ]\n  := by tfae_have 1 â†” 2 ; Â· apply exact_iff tfae_have 1 â†” 3 ; Â· apply exact_iff_image_eq_kernel tfae_finish\n#align exact_tfae exact_tfae\n\n",
 "exact_of_is_kernel":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\ntheorem exact_of_is_kernel (w : Â«expr â‰« Â» f g = 0) (h : is_limit (kernel_fork.of_Î¹ _ w)) : exact f g :=\n  by\n  refine' (exact_iff _ _).2 âŸ¨w, _âŸ©\n  have := h.fac (kernel_fork.of_Î¹ _ (kernel.condition g)) walking_parallel_pair.zero\n  simp only [fork.of_Î¹_Ï€_app] at this\n  rw [â† this, category.assoc, cokernel.condition, comp_zero]\n#align exact_of_is_kernel exact_of_is_kernel\n\n",
 "exact_of_is_cokernel":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\ntheorem exact_of_is_cokernel (w : Â«expr â‰« Â» f g = 0) (h : is_colimit (cokernel_cofork.of_Ï€ _ w)) : exact f g :=\n  by\n  refine' (exact_iff _ _).2 âŸ¨w, _âŸ©\n  have := h.fac (cokernel_cofork.of_Ï€ _ (cokernel.condition f)) walking_parallel_pair.one\n  simp only [cofork.of_Ï€_Î¹_app] at this\n  rw [â† this, â† category.assoc, kernel.condition, zero_comp]\n#align exact_of_is_cokernel exact_of_is_cokernel\n\n",
 "exact_iff_image_eq_kernel":
 "/-\nCopyright (c) 2020 Markus Himmel. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Markus Himmel, Adam Topaz, Johan Commelin, Jakob von Raumer\n-/\n/-- In an abelian category, a pair of morphisms `f : X âŸ¶ Y`, `g : Y âŸ¶ Z` is exact\niff `image_subobject f = kernel_subobject g`.\n-/\ntheorem exact_iff_image_eq_kernel : exact f g â†” image_subobject f = kernel_subobject g :=\n  by\n  constructor\n  Â· intro h\n    fapply subobject.eq_of_comm\n    Â· suffices is_iso (image_to_kernel _ _ h.w) by exact as_iso (image_to_kernel _ _ h.w)\n      exact is_iso_of_mono_of_epi _\n    Â· simp\n  Â· apply exact_of_image_eq_kernel\n#align exact_iff_image_eq_kernel exact_iff_image_eq_kernel\n\n",
 "exact_iff_exact_image_Î¹":
 "theorem exact_iff_exact_image_Î¹ : exact f g â†” exact (abelian.image.Î¹ f) g := by\n  conv_lhs => rw [â† abelian.image.fac f] <;> apply exact_epi_comp_iff\n#align exact_iff_exact_image_Î¹ exact_iff_exact_image_Î¹\n\n",
 "exact_iff_exact_coimage_Ï€":
 "theorem exact_iff_exact_coimage_Ï€ : exact f g â†” exact f (coimage.Ï€ g) := by\n  conv_lhs => rw [â† abelian.coimage.fac g] <;> apply exact_comp_mono_iff\n#align exact_iff_exact_coimage_Ï€ exact_iff_exact_coimage_Ï€\n\n",
 "exact_iff'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\ntheorem exact_iff' {cg : kernel_fork g} (hg : is_limit cg) {cf : cokernel_cofork f} (hf : is_colimit cf) :\n    exact f g â†” Â«expr â‰« Â» f g = 0 âˆ§ Â«expr â‰« Â» cg.Î¹ cf.Ï€ = 0 :=\n  by\n  constructor\n  Â· intro h\n    exact âŸ¨h.1, fork_Î¹_comp_cofork_Ï€ f g h cg cfâŸ©\n  Â· rw [exact_iff]\n    refine' fun h => âŸ¨h.1, _âŸ©\n    apply zero_of_epi_comp (is_limit.cone_point_unique_up_to_iso hg (limit.is_limit _)).hom\n    apply zero_of_comp_mono (is_colimit.cocone_point_unique_up_to_iso (colimit.is_colimit _) hf).hom\n    simp [h.2]\n#align exact_iff' exact_iff'\n\n",
 "exact_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\ntheorem is_equivalence.exact_iff {D : Type uâ‚} [Category.{vâ‚} D] [abelian D] (F : Â«expr â¥¤ Â» C D) [is_equivalence F] :\n    exact (F.map f) (F.map g) â†” exact f g :=\n  by\n  simp only [exact_iff, â† F.map_eq_zero_iff, F.map_comp, category.assoc, â† kernel_comparison_comp_Î¹ g F, â†\n    Ï€_comp_cokernel_comparison f F]\n  rw [is_iso.comp_left_eq_zero (kernel_comparison g F), â† category.assoc,\n    is_iso.comp_right_eq_zero _ (cokernel_comparison f F)]\n#align is_equivalence.exact_iff is_equivalence.exact_iff\n\n",
 "exact_epi_comp_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/-- The dual result is true even in non-abelian categories, see\n    `category_theory.exact_comp_mono_iff`. -/\ntheorem exact_epi_comp_iff {W : C} (h : Â«expr âŸ¶ Â» W X) [Epi h] : exact (Â«expr â‰« Â» h f) g â†” exact f g :=\n  by\n  refine' âŸ¨fun hfg => _, fun h => exact_epi_comp hâŸ©\n  let hc :=\n    is_cokernel_of_comp _ _ (colimit.is_colimit (parallel_pair (Â«expr â‰« Â» h f) 0))\n      (by rw [â† cancel_epi h, â† category.assoc, cokernel_cofork.condition, comp_zero]) rfl\n  refine' (exact_iff' _ _ (limit.is_limit _) hc).2 âŸ¨_, ((exact_iff _ _).1 hfg).2âŸ©\n  exact zero_of_epi_comp h (by rw [â† hfg.1, category.assoc])\n#align exact_epi_comp_iff exact_epi_comp_iff\n\n",
 "exact_cokernel":
 "theorem exact_cokernel : exact f (cokernel.Ï€ f) := by\n  rw [exact_iff]\n  tidy\n#align exact_cokernel exact_cokernel\n\n",
 "epi_iff_cokernel_Ï€_eq_zero":
 "-- Note we've already proved `epi_iff_exact_zero_right : epi f â†” exact f (0 : Y âŸ¶ Z)`\n-- in any preadditive category with equalizers and images.\ntheorem epi_iff_cokernel_Ï€_eq_zero : Epi f â†” cokernel.Ï€ f = 0 :=\n  (tfae_epi X f).out 0 1\n#align epi_iff_cokernel_Ï€_eq_zero epi_iff_cokernel_Ï€_eq_zero\n\n"}