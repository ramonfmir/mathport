{"unop_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵖ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem exact.unop_iff {X Y Z : «expr ᵒᵖ» C} (g : «expr ⟶ » X Y) (f : «expr ⟶ » Y Z) :\n    Exact f.unop g.unop ↔ Exact g f :=\n  ⟨fun e => by rwa [← f.op_unop, ← g.op_unop, ← exact.op_iff] at e, fun e => @Exact.unop _ _ g f e⟩\n#align exact.unop_iff exact.unop_iff\n\n",
 "unop":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵖ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem exact.unop {X Y Z : «expr ᵒᵖ» C} (g : «expr ⟶ » X Y) (f : «expr ⟶ » Y Z) (h : Exact g f) :\n    Exact f.unop g.unop := by\n  rw [← f.op_unop, ← g.op_unop] at h\n  rwa [← exact.op_iff]\n#align exact.unop exact.unop\n\n",
 "tfae_mono":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem tfae_mono : TFAE [Mono f, kernel.ι f = 0, Exact (0 : «expr ⟶ » Z X) f] :=\n  by\n  tfae_have 3 → 2\n  · exact kernel_ι_eq_zero_of_exact_zero_left Z\n  tfae_have 1 → 3\n  · intros\n    exact exact_zero_left_of_mono Z\n  tfae_have 2 → 1\n  · exact mono_of_kernel_ι_eq_zero _\n  tfae_finish\n#align tfae_mono tfae_mono\n\n",
 "tfae_epi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem tfae_epi : TFAE [Epi f, cokernel.π f = 0, Exact f (0 : «expr ⟶ » Y Z)] :=\n  by\n  tfae_have 3 → 2\n  · rw [exact_iff]\n    rintro ⟨-, h⟩\n    exact zero_of_epi_comp _ h\n  tfae_have 1 → 3\n  · rw [exact_iff]\n    intro\n    exact ⟨by simp, by simp [cokernel.π_of_epi]⟩\n  tfae_have 2 → 1\n  · exact epi_of_cokernel_π_eq_zero _\n  tfae_finish\n#align tfae_epi tfae_epi\n\n",
 "preserves_zero_morphisms_of_map_exact":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/-- A functor which preserves exactness preserves zero morphisms. -/\ntheorem preserves_zero_morphisms_of_map_exact : L.preserves_zero_morphisms :=\n  by\n  replace h := (h (exact_of_zero ((«expr𝟙») 0) ((«expr𝟙») 0))).w\n  rw [L.map_id, category.comp_id] at h\n  exact preserves_zero_morphisms_of_map_zero_object (id_zero_equiv_iso_zero _ h)\n#align preserves_zero_morphisms_of_map_exact preserves_zero_morphisms_of_map_exact\n\n",
 "preserves_monomorphisms_of_map_exact":
 "/-- A functor which preserves exactness preserves monomorphisms. -/\ntheorem preserves_monomorphisms_of_map_exact : L.preserves_monomorphisms :=\n  {\n    preserves := fun X Y f hf => by\n      letI := preserves_zero_morphisms_of_map_exact L h\n      apply ((tfae_mono (L.obj 0) (L.map f)).out 2 0).mp\n      rw [← L.map_zero]\n      exact h (((tfae_mono 0 f).out 0 2).mp hf) }\n#align preserves_monomorphisms_of_map_exact preserves_monomorphisms_of_map_exact\n\n",
 "preserves_epimorphisms_of_map_exact":
 "/-- A functor which preserves exactness preserves epimorphisms. -/\ntheorem preserves_epimorphisms_of_map_exact : L.preserves_epimorphisms :=\n  {\n    preserves := fun X Y f hf => by\n      letI := preserves_zero_morphisms_of_map_exact L h\n      apply ((tfae_epi (L.obj 0) (L.map f)).out 2 0).mp\n      rw [← L.map_zero]\n      exact h (((tfae_epi 0 f).out 0 2).mp hf) }\n#align preserves_epimorphisms_of_map_exact preserves_epimorphisms_of_map_exact\n\n",
 "op_iff":
 "theorem exact.op_iff : Exact g.op f.op ↔ Exact f g :=\n  ⟨fun e => by\n    rw [← is_equivalence.exact_iff _ _ (op_op_equivalence C).inverse]\n    exact exact.op _ _ e, Exact.op _ _⟩\n#align exact.op_iff exact.op_iff\n\n",
 "op":
 "theorem exact.op (h : Exact f g) : Exact g.op f.op :=\n  by\n  rw [exact_iff]\n  refine' ⟨by simp [← op_comp, h.w], Quiver.Hom.unop_inj _⟩\n  simp only [unop_comp, cokernel.π_op, eq_to_hom_refl, kernel.ι_op, category.id_comp, category.assoc,\n    kernel_comp_cokernel_assoc _ _ h, zero_comp, comp_zero, unop_zero]\n#align exact.op exact.op\n\n",
 "mono_iff_kernel_ι_eq_zero":
 "-- Note we've already proved `mono_iff_exact_zero_left : mono f ↔ exact (0 : Z ⟶ X) f`\n-- in any preadditive category with kernels and images.\ntheorem mono_iff_kernel_ι_eq_zero : Mono f ↔ kernel.ι f = 0 :=\n  (tfae_mono X f).out 0 1\n#align mono_iff_kernel_ι_eq_zero mono_iff_kernel_ι_eq_zero\n\n",
 "map_exact":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/-- A functor preserving finite limits and finite colimits preserves exactness. The converse\nresult is also true, see `functor.preserves_finite_limits_of_map_exact` and\n`functor.preserves_finite_colimits_of_map_exact`. -/\ntheorem map_exact {X Y Z : A} (f : «expr ⟶ » X Y) (g : «expr ⟶ » Y Z) (e1 : Exact f g) : Exact (L.map f) (L.map g) :=\n  by\n  let hcoker := is_colimit_of_has_cokernel_of_preserves_colimit L f\n  let hker := is_limit_of_has_kernel_of_preserves_limit L g\n  refine' (exact_iff' _ _ hker hcoker).2 ⟨by simp [← L.map_comp, e1.1], _⟩\n  rw [fork.ι_of_ι, cofork.π_of_π, ← L.map_comp, kernel_comp_cokernel _ _ e1, L.map_zero]\n#align map_exact map_exact\n\n",
 "inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem kernel.lift.inv [Mono f] (ex : Exact f g) : «expr ≫ » (inv (kernel.lift _ _ ex.w)) f = kernel.ι g := by simp\n#align kernel.lift.inv kernel.lift.inv\n\n",
 "exact_tfae":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem exact_tfae :\n    TFAE\n      [Exact f g, «expr ≫ » f g = 0 ∧ «expr ≫ » (kernel.ι g) (cokernel.π f) = 0,\n        imageSubobject f = kernelSubobject g] :=\n  by\n  tfae_have 1 ↔ 2; · apply exact_iff\n  tfae_have 1 ↔ 3; · apply exact_iff_image_eq_kernel\n  tfae_finish\n#align exact_tfae exact_tfae\n\n",
 "exact_of_is_kernel":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem exact_of_is_kernel (w : «expr ≫ » f g = 0) (h : IsLimit (KernelFork.ofι _ w)) : Exact f g :=\n  by\n  refine' (exact_iff _ _).2 ⟨w, _⟩\n  have := h.fac (kernel_fork.of_ι _ (kernel.condition g)) walking_parallel_pair.zero\n  simp only [fork.of_ι_π_app] at this\n  rw [← this, category.assoc, cokernel.condition, comp_zero]\n#align exact_of_is_kernel exact_of_is_kernel\n\n",
 "exact_of_is_cokernel":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem exact_of_is_cokernel (w : «expr ≫ » f g = 0) (h : IsColimit (CokernelCofork.ofπ _ w)) : Exact f g :=\n  by\n  refine' (exact_iff _ _).2 ⟨w, _⟩\n  have := h.fac (cokernel_cofork.of_π _ (cokernel.condition f)) walking_parallel_pair.one\n  simp only [cofork.of_π_ι_app] at this\n  rw [← this, ← category.assoc, kernel.condition, zero_comp]\n#align exact_of_is_cokernel exact_of_is_cokernel\n\n",
 "exact_iff_image_eq_kernel":
 "/-\nCopyright (c) 2020 Markus Himmel. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Markus Himmel, Adam Topaz, Johan Commelin, Jakob von Raumer\n-/\n/-- In an abelian category, a pair of morphisms `f : X ⟶ Y`, `g : Y ⟶ Z` is exact\niff `image_subobject f = kernel_subobject g`.\n-/\ntheorem exact_iff_image_eq_kernel : Exact f g ↔ imageSubobject f = kernelSubobject g :=\n  by\n  constructor\n  · intro h\n    fapply subobject.eq_of_comm\n    · suffices is_iso (imageToKernel _ _ h.w) by exact as_iso (imageToKernel _ _ h.w)\n      exact is_iso_of_mono_of_epi _\n    · simp\n  · apply exact_of_image_eq_kernel\n#align exact_iff_image_eq_kernel exact_iff_image_eq_kernel\n\n",
 "exact_iff_exact_image_ι":
 "theorem exact_iff_exact_image_ι : Exact f g ↔ Exact (Abelian.image.ι f) g := by\n  conv_lhs => rw [← abelian.image.fac f] <;> apply exact_epi_comp_iff\n#align exact_iff_exact_image_ι exact_iff_exact_image_ι\n\n",
 "exact_iff_exact_coimage_π":
 "theorem exact_iff_exact_coimage_π : Exact f g ↔ Exact f (coimage.π g) := by\n  conv_lhs => rw [← abelian.coimage.fac g] <;> apply exact_comp_mono_iff\n#align exact_iff_exact_coimage_π exact_iff_exact_coimage_π\n\n",
 "exact_iff'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem exact_iff' {cg : KernelFork g} (hg : IsLimit cg) {cf : CokernelCofork f} (hf : IsColimit cf) :\n    Exact f g ↔ «expr ≫ » f g = 0 ∧ «expr ≫ » cg.ι cf.π = 0 :=\n  by\n  constructor\n  · intro h\n    exact ⟨h.1, fork_ι_comp_cofork_π f g h cg cf⟩\n  · rw [exact_iff]\n    refine' fun h => ⟨h.1, _⟩\n    apply zero_of_epi_comp (is_limit.cone_point_unique_up_to_iso hg (limit.is_limit _)).hom\n    apply zero_of_comp_mono (is_colimit.cocone_point_unique_up_to_iso (colimit.is_colimit _) hf).hom\n    simp [h.2]\n#align exact_iff' exact_iff'\n\n",
 "exact_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\ntheorem is_equivalence.exact_iff {D : Type u₁} [Category.{v₁} D] [Abelian D] (F : «expr ⥤ » C D) [IsEquivalence F] :\n    Exact (F.map f) (F.map g) ↔ Exact f g :=\n  by\n  simp only [exact_iff, ← F.map_eq_zero_iff, F.map_comp, category.assoc, ← kernel_comparison_comp_ι g F, ←\n    π_comp_cokernel_comparison f F]\n  rw [is_iso.comp_left_eq_zero (kernel_comparison g F), ← category.assoc,\n    is_iso.comp_right_eq_zero _ (cokernel_comparison f F)]\n#align is_equivalence.exact_iff is_equivalence.exact_iff\n\n",
 "exact_epi_comp_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/-- The dual result is true even in non-abelian categories, see\n    `category_theory.exact_comp_mono_iff`. -/\ntheorem exact_epi_comp_iff {W : C} (h : «expr ⟶ » W X) [Epi h] : Exact («expr ≫ » h f) g ↔ Exact f g :=\n  by\n  refine' ⟨fun hfg => _, fun h => exact_epi_comp h⟩\n  let hc :=\n    is_cokernel_of_comp _ _ (colimit.is_colimit (parallel_pair («expr ≫ » h f) 0))\n      (by rw [← cancel_epi h, ← category.assoc, cokernel_cofork.condition, comp_zero]) rfl\n  refine' (exact_iff' _ _ (limit.is_limit _) hc).2 ⟨_, ((exact_iff _ _).1 hfg).2⟩\n  exact zero_of_epi_comp h (by rw [← hfg.1, category.assoc])\n#align exact_epi_comp_iff exact_epi_comp_iff\n\n",
 "exact_cokernel":
 "theorem exact_cokernel : Exact f (cokernel.π f) := by\n  rw [exact_iff]\n  tidy\n#align exact_cokernel exact_cokernel\n\n",
 "epi_iff_cokernel_π_eq_zero":
 "-- Note we've already proved `epi_iff_exact_zero_right : epi f ↔ exact f (0 : Y ⟶ Z)`\n-- in any preadditive category with equalizers and images.\ntheorem epi_iff_cokernel_π_eq_zero : Epi f ↔ cokernel.π f = 0 :=\n  (tfae_epi X f).out 0 1\n#align epi_iff_cokernel_π_eq_zero epi_iff_cokernel_π_eq_zero\n\n"}