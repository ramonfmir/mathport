{"mono_of_kernel_ι_eq_zero":
 "theorem mono_of_kernel_ι_eq_zero (h : kernel.ι f = 0) : Mono f :=\n  mono_of_kernel_zero h\n#align mono_of_kernel_ι_eq_zero mono_of_kernel_ι_eq_zero\n\n",
 "mono_lift_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem mono_lift_comp [Mono f] {T : C} (g : «expr ⟶ » T Y) (hg : «expr ≫ » g (cokernel.π f) = 0) :\n    «expr ≫ » (mono_lift f g hg) f = g :=\n  (mono_is_kernel_of_cokernel _ (colimit.is_colimit _)).fac (kernel_fork.of_ι _ hg) walking_parallel_pair.zero\n#align mono_lift_comp mono_lift_comp\n\n",
 "mono_inr_of_is_colimit":
 "theorem mono_inr_of_is_colimit [Mono f] {s : pushout_cocone f g} (hs : is_colimit s) : Mono s.inr :=\n  by\n  convert mono_of_mono_fac (is_colimit.comp_cocone_point_unique_up_to_iso_hom hs (colimit.is_colimit _) _)\n  · rfl\n  · exact abelian.mono_pushout_of_mono_f _ _\n#align mono_inr_of_is_colimit mono_inr_of_is_colimit\n\n",
 "mono_inl_of_is_colimit":
 "theorem mono_inl_of_is_colimit [Mono g] {s : pushout_cocone f g} (hs : is_colimit s) : Mono s.inl :=\n  by\n  convert mono_of_mono_fac (is_colimit.comp_cocone_point_unique_up_to_iso_hom hs (colimit.is_colimit _) _)\n  · rfl\n  · exact abelian.mono_pushout_of_mono_g _ _\n#align mono_inl_of_is_colimit mono_inl_of_is_colimit\n\n",
 "mono_inl_of_factor_thru_epi_mono_factorization":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/-- Suppose `f` and `g` are two morphisms with a common domain and suppose we have written `g` as\n    an epimorphism followed by a monomorphism. If `f` factors through the epi part of this\n    factorization, then any pushout of `g` along `f` is a monomorphism. -/\ntheorem mono_inl_of_factor_thru_epi_mono_factorization (f : «expr ⟶ » X Y) (g : «expr ⟶ » X Z) (g₁ : «expr ⟶ » X W)\n    [Epi g₁] (g₂ : «expr ⟶ » W Z) [Mono g₂] (hg : «expr ≫ » g₁ g₂ = g) (f' : «expr ⟶ » W Y) (hf : «expr ≫ » g₁ f' = f)\n    (t : pushout_cocone f g) (ht : is_colimit t) : Mono t.inl := by\n  apply mono_inl_of_is_colimit _ _ (pushout_cocone.is_colimit_of_factors _ _ _ _ _ hf hg t ht)\n#align mono_inl_of_factor_thru_epi_mono_factorization mono_inl_of_factor_thru_epi_mono_factorization\n\n",
 "image_ι_comp_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem image_ι_comp_eq_zero {R : C} {g : «expr ⟶ » Q R} (h : «expr ≫ » f g = 0) :\n    «expr ≫ » (abelian.image.ι f) g = 0 :=\n  zero_of_epi_comp (abelian.factor_thru_image f) <| by simp [h]\n#align image_ι_comp_eq_zero image_ι_comp_eq_zero\n\n",
 "image_mono_factorisation_e'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/-\nCopyright (c) 2020 Markus Himmel. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Markus Himmel, Johan Commelin, Scott Morrison\n-/\ntheorem image_mono_factorisation_e' {X Y : C} (f : «expr ⟶ » X Y) :\n    (image_mono_factorisation f).e = «expr ≫ » (cokernel.π _) (abelian.coimage_image_comparison f) :=\n  by\n  ext\n  simp only [abelian.coimage_image_comparison, image_mono_factorisation_e, category.assoc, cokernel.π_desc_assoc]\n#align image_mono_factorisation_e' image_mono_factorisation_e'\n\n",
 "has_images":
 "/-- A category in which coimage-image comparisons are all isomorphisms has images. -/\ntheorem has_images : has_images C :=\n  { has_image := fun X Y f => { exists_image := ⟨image_factorisation f⟩ } }\n#align has_images has_images\n\n",
 "epi_snd_of_is_limit":
 "-- It will suffice to consider some morphism e : Y ⟶ R such that\n-- pullback.snd ≫ e = 0 and show that e = 0.\n-- Consider the morphism u := (0, e) : X ⊞ Y⟶ R.\n-- The composite pullback f g ⟶ X ⊞ Y ⟶ R is zero by assumption.\n-- pullback_to_biproduct f g is a kernel of (f, -g), so (f, -g) is a\n-- cokernel of pullback_to_biproduct f g\n-- We use this fact to obtain a factorization of u through (f, -g) via some d : Z ⟶ R.\n-- But then f ≫ d = 0:\n-- But f is an epimorphism, so d = 0...\n-- ...or, in other words, e = 0.\n-- It will suffice to consider some morphism e : X ⟶ R such that\n-- pullback.fst ≫ e = 0 and show that e = 0.\n-- Consider the morphism u := (e, 0) : X ⊞ Y ⟶ R.\n-- The composite pullback f g ⟶ X ⊞ Y ⟶ R is zero by assumption.\n-- pullback_to_biproduct f g is a kernel of (f, -g), so (f, -g) is a\n-- cokernel of pullback_to_biproduct f g\n-- We use this fact to obtain a factorization of u through (f, -g) via some d : Z ⟶ R.\n-- But then (-g) ≫ d = 0:\n-- But g is an epimorphism, thus so is -g, so d = 0...\n-- ...or, in other words, e = 0.\ntheorem epi_snd_of_is_limit [Epi f] {s : pullback_cone f g} (hs : is_limit s) : Epi s.snd :=\n  by\n  convert epi_of_epi_fac (is_limit.cone_point_unique_up_to_iso_hom_comp (limit.is_limit _) hs _)\n  · rfl\n  · exact abelian.epi_pullback_of_epi_f _ _\n#align epi_snd_of_is_limit epi_snd_of_is_limit\n\n",
 "epi_of_cokernel_π_eq_zero":
 "theorem epi_of_cokernel_π_eq_zero (h : cokernel.π f = 0) : Epi f :=\n  by\n  apply normal_mono_category.epi_of_zero_cokernel _ (cokernel f)\n  simp_rw [← h]\n  exact is_colimit.of_iso_colimit (colimit.is_colimit (parallel_pair f 0)) (iso_of_π _)\n#align epi_of_cokernel_π_eq_zero epi_of_cokernel_π_eq_zero\n\n",
 "epi_fst_of_is_limit":
 "theorem epi_fst_of_is_limit [Epi g] {s : pullback_cone f g} (hs : is_limit s) : Epi s.fst :=\n  by\n  convert epi_of_epi_fac (is_limit.cone_point_unique_up_to_iso_hom_comp (limit.is_limit _) hs _)\n  · rfl\n  · exact abelian.epi_pullback_of_epi_g _ _\n#align epi_fst_of_is_limit epi_fst_of_is_limit\n\n",
 "epi_fst_of_factor_thru_epi_mono_factorization":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/-- Suppose `f` and `g` are two morphisms with a common codomain and suppose we have written `g` as\n    an epimorphism followed by a monomorphism. If `f` factors through the mono part of this\n    factorization, then any pullback of `g` along `f` is an epimorphism. -/\ntheorem epi_fst_of_factor_thru_epi_mono_factorization (g₁ : «expr ⟶ » Y W) [Epi g₁] (g₂ : «expr ⟶ » W Z) [Mono g₂]\n    (hg : «expr ≫ » g₁ g₂ = g) (f' : «expr ⟶ » X W) (hf : «expr ≫ » f' g₂ = f) (t : pullback_cone f g)\n    (ht : is_limit t) : Epi t.fst := by\n  apply epi_fst_of_is_limit _ _ (pullback_cone.is_limit_of_factors f g g₂ f' g₁ hf hg t ht)\n#align epi_fst_of_factor_thru_epi_mono_factorization epi_fst_of_factor_thru_epi_mono_factorization\n\n",
 "comp_epi_desc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n-- In particular, this means that it has well-behaved images.\n@[simp, reassoc.1]\ntheorem comp_epi_desc [Epi f] {T : C} (g : «expr ⟶ » X T) (hg : «expr ≫ » (kernel.ι f) g = 0) :\n    «expr ≫ » f (epi_desc f g hg) = g :=\n  (epi_is_cokernel_of_kernel _ (limit.is_limit _)).fac (cokernel_cofork.of_π _ hg) walking_parallel_pair.one\n#align comp_epi_desc comp_epi_desc\n\n",
 "comp_coimage_π_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem comp_coimage_π_eq_zero {R : C} {g : «expr ⟶ » Q R} (h : «expr ≫ » f g = 0) :\n    «expr ≫ » f (abelian.coimage.π g) = 0 :=\n  zero_of_comp_mono (abelian.factor_thru_coimage g) <| by simp [h]\n#align comp_coimage_π_eq_zero comp_coimage_π_eq_zero\n\n"}