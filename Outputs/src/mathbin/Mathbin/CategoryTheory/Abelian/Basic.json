{"mono_of_kernel_ι_eq_zero":
 "theorem mono_of_kernel_ι_eq_zero (h : kernel.ι f = 0) : Mono f :=\n  mono_of_kernel_zero h\n#align mono_of_kernel_ι_eq_zero mono_of_kernel_ι_eq_zero\n\n",
 "mono_lift_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem mono_lift_comp [Mono f] {T : C} (g : «expr ⟶ » T Y) (hg : «expr ≫ » g (cokernel.π f) = 0) :\n    «expr ≫ » (monoLift f g hg) f = g :=\n  (monoIsKernelOfCokernel _ (colimit.isColimit _)).fac (KernelFork.ofι _ hg) walking_parallel_pair.zero\n#align mono_lift_comp mono_lift_comp\n\n",
 "mono_inr_of_is_colimit":
 "theorem mono_inr_of_is_colimit [Mono f] {s : PushoutCocone f g} (hs : IsColimit s) : Mono s.inr :=\n  by\n  convert mono_of_mono_fac (is_colimit.comp_cocone_point_unique_up_to_iso_hom hs (colimit.is_colimit _) _)\n  · rfl\n  · exact abelian.mono_pushout_of_mono_f _ _\n#align mono_inr_of_is_colimit mono_inr_of_is_colimit\n\n",
 "mono_inl_of_is_colimit":
 "theorem mono_inl_of_is_colimit [Mono g] {s : PushoutCocone f g} (hs : IsColimit s) : Mono s.inl :=\n  by\n  convert mono_of_mono_fac (is_colimit.comp_cocone_point_unique_up_to_iso_hom hs (colimit.is_colimit _) _)\n  · rfl\n  · exact abelian.mono_pushout_of_mono_g _ _\n#align mono_inl_of_is_colimit mono_inl_of_is_colimit\n\n",
 "mono_inl_of_factor_thru_epi_mono_factorization":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/-- Suppose `f` and `g` are two morphisms with a common domain and suppose we have written `g` as\n    an epimorphism followed by a monomorphism. If `f` factors through the epi part of this\n    factorization, then any pushout of `g` along `f` is a monomorphism. -/\ntheorem mono_inl_of_factor_thru_epi_mono_factorization (f : «expr ⟶ » X Y) (g : «expr ⟶ » X Z) (g₁ : «expr ⟶ » X W)\n    [Epi g₁] (g₂ : «expr ⟶ » W Z) [Mono g₂] (hg : «expr ≫ » g₁ g₂ = g) (f' : «expr ⟶ » W Y) (hf : «expr ≫ » g₁ f' = f)\n    (t : PushoutCocone f g) (ht : IsColimit t) : Mono t.inl := by\n  apply mono_inl_of_is_colimit _ _ (pushout_cocone.is_colimit_of_factors _ _ _ _ _ hf hg t ht)\n#align mono_inl_of_factor_thru_epi_mono_factorization mono_inl_of_factor_thru_epi_mono_factorization\n\n",
 "image_ι_comp_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem image_ι_comp_eq_zero {R : C} {g : «expr ⟶ » Q R} (h : «expr ≫ » f g = 0) :\n    «expr ≫ » (Abelian.image.ι f) g = 0 :=\n  zero_of_epi_comp (Abelian.factorThruImage f) <| by simp [h]\n#align image_ι_comp_eq_zero image_ι_comp_eq_zero\n\n",
 "image_mono_factorisation_e'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/-\nCopyright (c) 2020 Markus Himmel. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Markus Himmel, Johan Commelin, Scott Morrison\n-/\ntheorem image_mono_factorisation_e' {X Y : C} (f : «expr ⟶ » X Y) :\n    (imageMonoFactorisation f).e = «expr ≫ » (cokernel.π _) (Abelian.coimageImageComparison f) :=\n  by\n  ext\n  simp only [abelian.coimage_image_comparison, image_mono_factorisation_e, category.assoc, cokernel.π_desc_assoc]\n#align image_mono_factorisation_e' image_mono_factorisation_e'\n\n",
 "image_iso_image_inv":
 "theorem image_iso_image_inv :\n    (imageIsoImage f).inv = kernel.lift _ (Limits.image.ι f) (by simp [← cancel_epi (factor_thru_image f)]) :=\n  by\n  ext\n  simp only [is_image.iso_ext_inv, image.is_image_lift, limits.image.fac_lift,\n    image_strong_epi_mono_factorisation_to_mono_factorisation_e, category.assoc, kernel.lift_ι, limits.image.fac]\n#align image_iso_image_inv image_iso_image_inv\n\n",
 "image_iso_image_hom_comp_image_ι":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem image_iso_image_hom_comp_image_ι : «expr ≫ » (imageIsoImage f).hom (Limits.image.ι _) = kernel.ι _ := by\n  simp only [is_image.iso_ext_hom, is_image.lift_ι, image_strong_epi_mono_factorisation_to_mono_factorisation_m]\n#align image_iso_image_hom_comp_image_ι image_iso_image_hom_comp_image_ι\n\n",
 "has_images":
 "/-- A category in which coimage-image comparisons are all isomorphisms has images. -/\ntheorem has_images : HasImages C :=\n  { has_image := fun X Y f => { exists_image := ⟨imageFactorisation f⟩ } }\n#align has_images has_images\n\n",
 "has_finite_biproducts":
 "-- Porting note: this should be an instance,\n-- but triggers https://github.com/leanprover/lean4/issues/2055\n-- We set it as a local instance instead.\n-- @[priority 100] instance\n/-- An abelian category has finite biproducts. -/\ntheorem has_finite_biproducts : HasFiniteBiproducts C :=\n  Limits.HasFiniteBiproducts.of_hasFiniteProducts\n#align has_finite_biproducts has_finite_biproducts\n\n",
 "factor_thru_image_comp_coimage_iso_image'_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem factor_thru_image_comp_coimage_iso_image'_inv :\n    «expr ≫ » (factorThruImage f) (coimageIsoImage' f).inv = cokernel.π _ := by\n  simp only [is_image.iso_ext_inv, image.is_image_lift, image.fac_lift,\n    coimage_strong_epi_mono_factorisation_to_mono_factorisation_e]\n#align factor_thru_image_comp_coimage_iso_image'_inv factor_thru_image_comp_coimage_iso_image'_inv\n\n",
 "epi_snd_of_is_limit":
 "-- It will suffice to consider some morphism e : Y ⟶ R such that\n-- pullback.snd ≫ e = 0 and show that e = 0.\n-- Consider the morphism u := (0, e) : X ⊞ Y⟶ R.\n-- The composite pullback f g ⟶ X ⊞ Y ⟶ R is zero by assumption.\n-- pullback_to_biproduct f g is a kernel of (f, -g), so (f, -g) is a\n-- cokernel of pullback_to_biproduct f g\n-- We use this fact to obtain a factorization of u through (f, -g) via some d : Z ⟶ R.\n-- But then f ≫ d = 0:\n-- But f is an epimorphism, so d = 0...\n-- ...or, in other words, e = 0.\n-- It will suffice to consider some morphism e : X ⟶ R such that\n-- pullback.fst ≫ e = 0 and show that e = 0.\n-- Consider the morphism u := (e, 0) : X ⊞ Y ⟶ R.\n-- The composite pullback f g ⟶ X ⊞ Y ⟶ R is zero by assumption.\n-- pullback_to_biproduct f g is a kernel of (f, -g), so (f, -g) is a\n-- cokernel of pullback_to_biproduct f g\n-- We use this fact to obtain a factorization of u through (f, -g) via some d : Z ⟶ R.\n-- But then (-g) ≫ d = 0:\n-- But g is an epimorphism, thus so is -g, so d = 0...\n-- ...or, in other words, e = 0.\ntheorem epi_snd_of_is_limit [Epi f] {s : PullbackCone f g} (hs : IsLimit s) : Epi s.snd :=\n  by\n  convert epi_of_epi_fac (is_limit.cone_point_unique_up_to_iso_hom_comp (limit.is_limit _) hs _)\n  · rfl\n  · exact abelian.epi_pullback_of_epi_f _ _\n#align epi_snd_of_is_limit epi_snd_of_is_limit\n\n",
 "epi_of_cokernel_π_eq_zero":
 "theorem epi_of_cokernel_π_eq_zero (h : cokernel.π f = 0) : Epi f :=\n  by\n  apply normal_mono_category.epi_of_zero_cokernel _ (cokernel f)\n  simp_rw [← h]\n  exact is_colimit.of_iso_colimit (colimit.is_colimit (parallel_pair f 0)) (iso_of_π _)\n#align epi_of_cokernel_π_eq_zero epi_of_cokernel_π_eq_zero\n\n",
 "epi_fst_of_is_limit":
 "theorem epi_fst_of_is_limit [Epi g] {s : PullbackCone f g} (hs : IsLimit s) : Epi s.fst :=\n  by\n  convert epi_of_epi_fac (is_limit.cone_point_unique_up_to_iso_hom_comp (limit.is_limit _) hs _)\n  · rfl\n  · exact abelian.epi_pullback_of_epi_g _ _\n#align epi_fst_of_is_limit epi_fst_of_is_limit\n\n",
 "epi_fst_of_factor_thru_epi_mono_factorization":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/-- Suppose `f` and `g` are two morphisms with a common codomain and suppose we have written `g` as\n    an epimorphism followed by a monomorphism. If `f` factors through the mono part of this\n    factorization, then any pullback of `g` along `f` is an epimorphism. -/\ntheorem epi_fst_of_factor_thru_epi_mono_factorization (g₁ : «expr ⟶ » Y W) [Epi g₁] (g₂ : «expr ⟶ » W Z) [Mono g₂]\n    (hg : «expr ≫ » g₁ g₂ = g) (f' : «expr ⟶ » X W) (hf : «expr ≫ » f' g₂ = f) (t : PullbackCone f g) (ht : IsLimit t) :\n    Epi t.fst := by apply epi_fst_of_is_limit _ _ (pullback_cone.is_limit_of_factors f g g₂ f' g₁ hf hg t ht)\n#align epi_fst_of_factor_thru_epi_mono_factorization epi_fst_of_factor_thru_epi_mono_factorization\n\n",
 "comp_epi_desc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem comp_epi_desc [Epi f] {T : C} (g : «expr ⟶ » X T) (hg : «expr ≫ » (kernel.ι f) g = 0) :\n    «expr ≫ » f (epiDesc f g hg) = g :=\n  (epiIsCokernelOfKernel _ (limit.isLimit _)).fac (CokernelCofork.ofπ _ hg) walking_parallel_pair.one\n#align comp_epi_desc comp_epi_desc\n\n",
 "comp_coimage_π_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem comp_coimage_π_eq_zero {R : C} {g : «expr ⟶ » Q R} (h : «expr ≫ » f g = 0) :\n    «expr ≫ » f (Abelian.coimage.π g) = 0 :=\n  zero_of_comp_mono (Abelian.factorThruCoimage g) <| by simp [h]\n#align comp_coimage_π_eq_zero comp_coimage_π_eq_zero\n\n",
 "coimage_iso_image'_hom":
 "-- In particular, this means that it has well-behaved images.\ntheorem coimage_iso_image'_hom :\n    (coimageIsoImage' f).hom = cokernel.desc _ (factorThruImage f) (by simp [← cancel_mono (limits.image.ι f)]) :=\n  by\n  ext\n  simp only [← cancel_mono (limits.image.ι f), is_image.iso_ext_hom, cokernel.π_desc, category.assoc, is_image.lift_ι,\n    coimage_strong_epi_mono_factorisation_to_mono_factorisation_m, limits.image.fac]\n#align coimage_iso_image'_hom coimage_iso_image'_hom\n\n"}