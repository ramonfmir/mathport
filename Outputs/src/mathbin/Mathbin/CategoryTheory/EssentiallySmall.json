{"to_from":
 "-- a fresh variable with no category instance attached\n@[simp]\ntheorem to_from (X : C') : fromShrinkHoms (toShrinkHoms X) = X :=\n  rfl\n#align to_from to_from\n\n",
 "mk'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≌ » -/\n/-\nCopyright (c) 2021 Scott Morrison. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Scott Morrison\n-/\n/-- Constructor for `essentially_small C` from an explicit small category witness. -/\ntheorem essentially_small.mk' {C : Type u} [Category.{v} C] {S : Type w} [SmallCategory S] (e : «expr ≌ » C S) :\n    EssentiallySmall.{w} C :=\n  ⟨⟨S, _, ⟨e⟩⟩⟩\n#align essentially_small.mk' essentially_small.mk'\n\n",
 "locally_small_congr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≌ » -/\ntheorem locally_small_congr {C : Type u} [Category.{v} C] {D : Type u'} [Category.{v'} D] (e : «expr ≌ » C D) :\n    LocallySmall.{w} C ↔ LocallySmall.{w} D := by\n  fconstructor\n  · rintro ⟨L⟩\n    fconstructor\n    intro X Y\n    specialize L (e.inverse.obj X) (e.inverse.obj Y)\n    refine' (small_congr _).mpr L\n    exact equiv_of_fully_faithful e.inverse\n  · rintro ⟨L⟩\n    fconstructor\n    intro X Y\n    specialize L (e.functor.obj X) (e.functor.obj Y)\n    refine' (small_congr _).mpr L\n    exact equiv_of_fully_faithful e.functor\n#align locally_small_congr locally_small_congr\n\n",
 "from_to":
 "@[simp]\ntheorem from_to (X : ShrinkHoms C') : toShrinkHoms (fromShrinkHoms X) = X :=\n  rfl\n#align from_to from_to\n\n",
 "essentially_small_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≌ » -/\ntheorem essentially_small_self : EssentiallySmall.{max w v u} C :=\n  EssentiallySmall.mk' (AsSmall.equiv : «expr ≌ » C (AsSmall.{w} C))\n#align essentially_small_self essentially_small_self\n\n",
 "essentially_small_of_small":
 "theorem discrete.essentially_small_of_small {α : Type u} [Small.{w} α] : EssentiallySmall.{w} (Discrete α) :=\n  ⟨⟨Discrete (Shrink α), ⟨inferInstance, ⟨Discrete.equivalence (equivShrink _)⟩⟩⟩⟩\n#align discrete.essentially_small_of_small discrete.essentially_small_of_small\n\n",
 "essentially_small_iff_of_thin":
 "/-- A thin category is essentially small if and only if the underlying type of its skeleton is small.\n-/\ntheorem essentially_small_iff_of_thin {C : Type u} [Category.{v} C] [Quiver.IsThin C] :\n    EssentiallySmall.{w} C ↔ Small.{w} (Skeleton C) := by\n  simp [essentially_small_iff, CategoryTheory.locallySmall_of_thin]\n#align essentially_small_iff_of_thin essentially_small_iff_of_thin\n\n",
 "essentially_small_iff":
 "/-- A category is essentially small if and only if\nthe underlying type of its skeleton (i.e. the \"set\" of isomorphism classes) is small,\nand it is locally small.\n-/\ntheorem essentially_small_iff (C : Type u) [Category.{v} C] :\n    EssentiallySmall.{w} C ↔ Small.{w} (Skeleton C) ∧ LocallySmall.{w} C :=\n  by\n  -- This theorem is the only bit of real work in this file.\n  fconstructor\n  · intro h\n    fconstructor\n    · rcases h with ⟨S, 𝒮, ⟨e⟩⟩\n      skip\n      refine' ⟨⟨skeleton S, ⟨_⟩⟩⟩\n      exact e.skeleton_equiv\n    · skip\n      infer_instance\n  · rintro ⟨⟨S, ⟨e⟩⟩, L⟩\n    skip\n    let e' := (shrink_homs.equivalence C).skeleton_equiv.symm\n    refine' ⟨⟨S, _, ⟨_⟩⟩⟩\n    apply induced_category.category (e'.trans e).symm\n    refine'\n      (shrink_homs.equivalence C).trans\n        ((skeleton_equivalence _).symm.trans (induced_functor (e'.trans e).symm).as_equivalence.symm)\n#align essentially_small_iff essentially_small_iff\n\n",
 "essentially_small_congr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≌ » -/\ntheorem essentially_small_congr {C : Type u} [Category.{v} C] {D : Type u'} [Category.{v'} D] (e : «expr ≌ » C D) :\n    EssentiallySmall.{w} C ↔ EssentiallySmall.{w} D :=\n  by\n  fconstructor\n  · rintro ⟨S, 𝒮, ⟨f⟩⟩\n    skip\n    exact essentially_small.mk' (e.symm.trans f)\n  · rintro ⟨S, 𝒮, ⟨f⟩⟩\n    skip\n    exact essentially_small.mk' (e.trans f)\n#align essentially_small_congr essentially_small_congr\n\n"}