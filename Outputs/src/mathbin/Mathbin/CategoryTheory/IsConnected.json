{"zigzag_symmetric":
 "theorem zigzag_symmetric : symmetric (@zigzag J _) :=\n  relation.refl_trans_gen.symmetric zag_symmetric\n#align zigzag_symmetric zigzag_symmetric\n\n",
 "zigzag_obj_of_zigzag":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/-- If there is a zigzag from `j₁` to `j₂`, then there is a zigzag from `F j₁` to\n`F j₂` as long as `F` is a functor.\n-/\ntheorem zigzag_obj_of_zigzag (F : «expr ⥤ » J K) {j₁ j₂ : J} (h : zigzag j₁ j₂) : zigzag (F.obj j₁) (F.obj j₂) :=\n  h.lift _ fun j k => Or.imp (nonempty.map fun f => F.map f) (nonempty.map fun f => F.map f)\n#align zigzag_obj_of_zigzag zigzag_obj_of_zigzag\n\n",
 "zigzag_is_connected":
 "/-- If any two objects in an nonempty category are related by `zigzag`, the category is connected.\n-/\ntheorem zigzag_is_connected [nonempty J] (h : ∀ j₁ j₂ : J, zigzag j₁ j₂) : is_connected J :=\n  by\n  apply is_connected.of_induct\n  intro p hp hjp j\n  have : ∀ j₁ j₂ : J, zigzag j₁ j₂ → (j₁ ∈ p ↔ j₂ ∈ p) :=\n    by\n    introv k\n    induction' k with _ _ rt_zag zag\n    · rfl\n    · rw [k_ih]\n      rcases zag with (⟨⟨_⟩⟩ | ⟨⟨_⟩⟩)\n      apply hjp zag\n      apply (hjp zag).symm\n  rwa [this j (classical.arbitrary J) (h _ _)]\n#align zigzag_is_connected zigzag_is_connected\n\n",
 "zigzag_equivalence":
 "theorem zigzag_equivalence : _root_.equivalence (@zigzag J _) :=\n  Equivalence.mk _ Relation.reflexive_reflTransGen zigzag_symmetric Relation.transitive_reflTransGen\n#align zigzag_equivalence zigzag_equivalence\n\n",
 "zag_symmetric":
 "theorem zag_symmetric : symmetric (@zag J _) := fun j₂ j₁ h => h.swap\n#align zag_symmetric zag_symmetric\n\n",
 "zag_of_zag_obj":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n-- TODO: figure out the right way to generalise this to `zigzag`.\ntheorem zag_of_zag_obj (F : «expr ⥤ » J K) [Full F] {j₁ j₂ : J} (h : zag (F.obj j₁) (F.obj j₂)) : zag j₁ j₂ :=\n  Or.imp (nonempty.map F.preimage) (nonempty.map F.preimage) h\n#align zag_of_zag_obj zag_of_zag_obj\n\n",
 "of_induct":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/-- If any maximal connected component containing some element j₀ of J is all of J, then J is connected.\n\nThe converse of `induct_on_objects`.\n-/\ntheorem is_connected.of_induct [nonempty J] {j₀ : J}\n    (h : ∀ p : set J, j₀ ∈ p → (∀ {j₁ j₂ : J} (f : «expr ⟶ » j₁ j₂), j₁ ∈ p ↔ j₂ ∈ p) → ∀ j : J, j ∈ p) :\n    is_connected J :=\n  is_connected.of_constant_of_preserves_morphisms fun α F a =>\n    by\n    have w := h { j | F j = F j₀ } rfl fun _ _ f => by simp [a f]\n    dsimp at w\n    intro j j'\n    rw [w j, w j']\n#align is_connected.of_induct is_connected.of_induct\n\n",
 "of_constant_of_preserves_morphisms":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/-- `J` is connected if: given any function `F : J → α` which is constant for any\n`j₁, j₂` for which there is a morphism `j₁ ⟶ j₂`, then `F` is constant.\nThis can be thought of as a local-to-global property.\n\nThe converse of `constant_of_preserves_morphisms`.\n-/\ntheorem is_connected.of_constant_of_preserves_morphisms [nonempty J]\n    (h : ∀ {α : Type u₁} (F : J → α), (∀ {j₁ j₂ : J} (f : «expr ⟶ » j₁ j₂), F j₁ = F j₂) → ∀ j j' : J, F j = F j') :\n    is_connected J :=\n  is_connected.of_any_functor_const_on_obj fun _ F =>\n    h F.obj fun _ _ f => by\n      ext\n      exact discrete.eq_of_hom (F.map f)\n#align is_connected.of_constant_of_preserves_morphisms is_connected.of_constant_of_preserves_morphisms\n\n",
 "of_any_functor_const_on_obj":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/-- If any functor to a discrete category is constant on objects, J is connected.\nThe converse of `any_functor_const_on_obj`.\n-/\ntheorem is_connected.of_any_functor_const_on_obj [nonempty J]\n    (h : ∀ {α : Type u₁} (F : «expr ⥤ » J (discrete α)), ∀ j j' : J, F.obj j = F.obj j') : is_connected J :=\n  {\n    iso_constant := fun α F j' =>\n      ⟨NatIso.ofComponents (fun j => eq_to_iso (h F j j')) fun _ _ _ => subsingleton.elim _ _⟩ }\n#align is_connected.of_any_functor_const_on_obj is_connected.of_any_functor_const_on_obj\n\n",
 "nat_trans_from_is_connected":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/-- For objects `X Y : C`, any natural transformation `α : const X ⟶ const Y` from a connected\ncategory must be constant.\nThis is the key property of connected categories which we use to establish properties about limits.\n-/\ntheorem nat_trans_from_is_connected [is_preconnected J] {X Y : C}\n    (α : «expr ⟶ » ((functor.const J).obj X) ((functor.const J).obj Y)) :\n    ∀ j j' : J, α.app j = (α.app j' : «expr ⟶ » X Y) :=\n  @constant_of_preserves_morphisms _ _ _ («expr ⟶ » X Y) (fun j => α.app j) fun _ _ f =>\n    by\n    have := α.naturality f\n    erw [id_comp, comp_id] at this\n    exact this.symm\n#align nat_trans_from_is_connected nat_trans_from_is_connected\n\n",
 "is_preconnected_of_is_preconnected_op":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵖ» -/\ntheorem is_preconnected_of_is_preconnected_op [is_preconnected («expr ᵒᵖ» J)] : is_preconnected J :=\n  is_preconnected_of_equivalent (op_op_equivalence J)\n#align is_preconnected_of_is_preconnected_op is_preconnected_of_is_preconnected_op\n\n",
 "is_preconnected_of_equivalent":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≅ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≅ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≅ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≅ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≌ » -/\n/-- If `J` and `K` are equivalent, then if `J` is preconnected then `K` is as well. -/\ntheorem is_preconnected_of_equivalent {K : Type u₁} [Category.{v₂} K] [is_preconnected J] (e : «expr ≌ » J K) :\n    is_preconnected K :=\n  {\n    iso_constant := fun α F k =>\n      ⟨calc\n          «expr ≅ » F («expr ⋙ » e.inverse («expr ⋙ » e.functor F)) := (e.inv_fun_id_assoc F).symm\n          «expr ≅ » _ («expr ⋙ » e.inverse ((functor.const J).obj ((«expr ⋙ » e.functor F).obj (e.inverse.obj k)))) :=\n            isoWhiskerLeft e.inverse (iso_constant («expr ⋙ » e.functor F) (e.inverse.obj k))\n          «expr ≅ » _ («expr ⋙ » e.inverse ((functor.const J).obj (F.obj k))) :=\n            isoWhiskerLeft _ ((«expr ⋙ » F (functor.const J)).map_iso (e.counit_iso.app k))\n          «expr ≅ » _ ((functor.const K).obj (F.obj k)) := NatIso.ofComponents (fun X => Iso.refl _) (by simp)\n          ⟩ }\n#align is_preconnected_of_equivalent is_preconnected_of_equivalent\n\n",
 "is_preconnected_induction":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/-- Another induction principle for `is_preconnected J`:\ngiven a type family `Z : J → Sort*` and\na rule for transporting in *both* directions along a morphism in `J`,\nwe can transport an `x : Z j₀` to a point in `Z j` for any `j`.\n-/\ntheorem is_preconnected_induction [is_preconnected J] (Z : J → Sort _)\n    (h₁ : ∀ {j₁ j₂ : J} (f : «expr ⟶ » j₁ j₂), Z j₁ → Z j₂) (h₂ : ∀ {j₁ j₂ : J} (f : «expr ⟶ » j₁ j₂), Z j₂ → Z j₁)\n    {j₀ : J} (x : Z j₀) (j : J) : nonempty (Z j) :=\n  (induct_on_objects { j | nonempty (Z j) } ⟨x⟩\n      (fun j₁ j₂ f =>\n        ⟨by\n          rintro ⟨y⟩\n          exact ⟨h₁ f y⟩, by\n          rintro ⟨y⟩\n          exact ⟨h₂ f y⟩⟩)\n      j :\n    _)\n#align is_preconnected_induction is_preconnected_induction\n\n",
 "is_connected_zigzag":
 "/-- In a connected category, any two objects are related by `zigzag`. -/\ntheorem is_connected_zigzag [is_connected J] (j₁ j₂ : J) : zigzag j₁ j₂ :=\n  equiv_relation _ zigzag_equivalence (fun _ _ f => relation.refl_trans_gen.single (or.inl (nonempty.intro f))) _ _\n#align is_connected_zigzag is_connected_zigzag\n\n",
 "is_connected_of_zigzag":
 "/-- If any two objects in an nonempty category are linked by a sequence of (potentially reversed)\nmorphisms, then J is connected.\n\nThe converse of `exists_zigzag'`.\n-/\ntheorem is_connected_of_zigzag [nonempty J]\n    (h : ∀ j₁ j₂ : J, ∃ l, List.Chain zag j₁ l ∧ List.getLast (j₁ :: l) (List.cons_ne_nil _ _) = j₂) : is_connected J :=\n  by\n  apply zigzag_is_connected\n  intro j₁ j₂\n  rcases h j₁ j₂ with ⟨l, hl₁, hl₂⟩\n  apply List.relationReflTransGen_of_exists_chain l hl₁ hl₂\n#align is_connected_of_zigzag is_connected_of_zigzag\n\n",
 "is_connected_of_is_connected_op":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵖ» -/\ntheorem is_connected_of_is_connected_op [is_connected («expr ᵒᵖ» J)] : is_connected J :=\n  is_connected_of_equivalent (op_op_equivalence J)\n#align is_connected_of_is_connected_op is_connected_of_is_connected_op\n\n",
 "is_connected_of_equivalent":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≌ » -/\n/-- If `J` and `K` are equivalent, then if `J` is connected then `K` is as well. -/\ntheorem is_connected_of_equivalent {K : Type u₁} [Category.{v₂} K] (e : «expr ≌ » J K) [is_connected J] :\n    is_connected K :=\n  { is_nonempty := nonempty.map e.functor.obj (by infer_instance)\n    to_is_preconnected := is_preconnected_of_equivalent e }\n#align is_connected_of_equivalent is_connected_of_equivalent\n\n",
 "induct_on_objects":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/-- An inductive-like property for the objects of a connected category.\nIf the set `p` is nonempty, and `p` is closed under morphisms of `J`,\nthen `p` contains all of `J`.\n\nThe converse is given in `is_connected.of_induct`.\n-/\ntheorem induct_on_objects [is_preconnected J] (p : set J) {j₀ : J} (h0 : j₀ ∈ p)\n    (h1 : ∀ {j₁ j₂ : J} (f : «expr ⟶ » j₁ j₂), j₁ ∈ p ↔ j₂ ∈ p) (j : J) : j ∈ p :=\n  by\n  injection constant_of_preserves_morphisms (fun k => ulift.up (k ∈ p)) (fun j₁ j₂ f => _) j j₀ with i\n  rwa [i]\n  dsimp\n  exact congr_arg ulift.up (propext (h1 f))\n#align induct_on_objects induct_on_objects\n\n",
 "exists_zigzag'":
 "theorem exists_zigzag' [is_connected J] (j₁ j₂ : J) :\n    ∃ l, List.Chain zag j₁ l ∧ List.getLast (j₁ :: l) (List.cons_ne_nil _ _) = j₂ :=\n  List.exists_chain_of_relationReflTransGen (is_connected_zigzag _ _)\n#align exists_zigzag' exists_zigzag'\n\n",
 "equiv_relation":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/-- Any equivalence relation containing (⟶) holds for all pairs of a connected category. -/\ntheorem equiv_relation [is_connected J] (r : J → J → Prop) (hr : _root_.equivalence r)\n    (h : ∀ {j₁ j₂ : J} (f : «expr ⟶ » j₁ j₂), r j₁ j₂) : ∀ j₁ j₂ : J, r j₁ j₂ :=\n  by\n  have z : ∀ j : J, r (classical.arbitrary J) j :=\n    induct_on_objects (fun k => r (classical.arbitrary J) k) (hr.1 (classical.arbitrary J)) fun _ _ f =>\n      ⟨fun t => hr.2.2 t (h f), fun t => hr.2.2 t (hr.2.1 (h f))⟩\n  intros ; apply hr.2.2 (hr.2.1 (z _)) (z _)\n#align equiv_relation equiv_relation\n\n",
 "constant_of_preserves_morphisms":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/-- If `J` is connected, then given any function `F` such that the presence of a\nmorphism `j₁ ⟶ j₂` implies `F j₁ = F j₂`, we have that `F` is constant.\nThis can be thought of as a local-to-global property.\n\nThe converse is shown in `is_connected.of_constant_of_preserves_morphisms`\n-/\ntheorem constant_of_preserves_morphisms [is_preconnected J] {α : Type u₁} (F : J → α)\n    (h : ∀ (j₁ j₂ : J) (f : «expr ⟶ » j₁ j₂), F j₁ = F j₂) (j j' : J) : F j = F j' := by\n  simpa using\n    any_functor_const_on_obj\n      { obj := discrete.mk ∘ F\n        map := fun _ _ f =>\n          eq_to_hom\n            (by\n              ext\n              exact h _ _ f) }\n      j j'\n#align constant_of_preserves_morphisms constant_of_preserves_morphisms\n\n",
 "any_functor_const_on_obj":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/-\nCopyright (c) 2020 Bhavik Mehta. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Bhavik Mehta, Jakob von Raumer\n-/\n/-- If J is connected, any functor to a discrete category is constant on objects.\nThe converse is given in `is_connected.of_any_functor_const_on_obj`.\n-/\ntheorem any_functor_const_on_obj [is_preconnected J] {α : Type u₁} (F : «expr ⥤ » J (discrete α)) (j j' : J) :\n    F.obj j = F.obj j' := by\n  ext\n  exact ((iso_constant F j').hom.app j).down.1\n#align any_functor_const_on_obj any_functor_const_on_obj\n\n"}