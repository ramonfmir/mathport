{"unit_obj_eq_map_unit":
 "/-\nCopyright (c) 2020 Bhavik Mehta. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Bhavik Mehta\n-/\n-- TODO: This holds more generally for idempotent adjunctions, not just reflective adjunctions.\n/-- For a reflective functor `i` (with left adjoint `L`), with unit `η`, we have `η_iL = iL η`.\n-/\ntheorem unit_obj_eq_map_unit [Reflective i] (X : C) :\n    (ofRightAdjoint i).unit.app (i.obj ((leftAdjoint i).obj X)) =\n      i.map ((leftAdjoint i).map ((ofRightAdjoint i).unit.app X)) :=\n  by\n  rw [← cancel_mono (i.map ((of_right_adjoint i).counit.app ((left_adjoint i).obj X))), ← i.map_comp]\n  simp\n#align unit_obj_eq_map_unit unit_obj_eq_map_unit\n\n",
 "unit_is_iso":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/-- If `A` is essentially in the image of a reflective functor `i`, then `η_A` is an isomorphism.\nThis gives that the \"witness\" for `A` being in the essential image can instead be given as the\nreflection of `A`, with the isomorphism as `η_A`.\n\n(For any `B` in the reflective subcategory, we automatically have that `ε_B` is an iso.)\n-/\ntheorem functor.ess_image.unit_is_iso [Reflective i] {A : C} (h : A ∈ i.ess_image) :\n    IsIso ((ofRightAdjoint i).unit.app A) :=\n  by\n  suffices\n    (of_right_adjoint i).unit.app A =\n      «expr ≫ » h.get_iso.inv\n        («expr ≫ » ((of_right_adjoint i).unit.app (i.obj h.witness)) ((«expr ⋙ » (left_adjoint i) i).map h.get_iso.hom))\n    by\n    rw [this]\n    infer_instance\n  rw [← nat_trans.naturality]\n  simp\n#align functor.ess_image.unit_is_iso functor.ess_image.unit_is_iso\n\n",
 "unit_comp_partial_bijective_symm_natural":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem unit_comp_partial_bijective_symm_natural [Reflective i] (A : C) {B B' : C} (h : «expr ⟶ » B B')\n    (hB : B ∈ i.ess_image) (hB' : B' ∈ i.ess_image) (f : «expr ⟶ » (i.obj ((leftAdjoint i).obj A)) B) :\n    (unitCompPartialBijective A hB').symm («expr ≫ » f h) = «expr ≫ » ((unitCompPartialBijective A hB).symm f) h := by\n  simp\n#align unit_comp_partial_bijective_symm_natural unit_comp_partial_bijective_symm_natural\n\n",
 "unit_comp_partial_bijective_symm_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp]\ntheorem unit_comp_partial_bijective_symm_apply [Reflective i] (A : C) {B : C} (hB : B ∈ i.ess_image) (f) :\n    (unitCompPartialBijective A hB).symm f = «expr ≫ » ((ofRightAdjoint i).unit.app A) f := by\n  simp [unit_comp_partial_bijective, unit_comp_partial_bijective_aux_symm_apply]\n#align unit_comp_partial_bijective_symm_apply unit_comp_partial_bijective_symm_apply\n\n",
 "unit_comp_partial_bijective_natural":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem unit_comp_partial_bijective_natural [Reflective i] (A : C) {B B' : C} (h : «expr ⟶ » B B')\n    (hB : B ∈ i.ess_image) (hB' : B' ∈ i.ess_image) (f : «expr ⟶ » A B) :\n    (unitCompPartialBijective A hB') («expr ≫ » f h) = «expr ≫ » (unitCompPartialBijective A hB f) h := by\n  rw [← Equiv.eq_symm_apply, unit_comp_partial_bijective_symm_natural A h, Equiv.symm_apply_apply]\n#align unit_comp_partial_bijective_natural unit_comp_partial_bijective_natural\n\n",
 "unit_comp_partial_bijective_aux_symm_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/-- The description of the inverse of the bijection `unit_comp_partial_bijective_aux`. -/\ntheorem unit_comp_partial_bijective_aux_symm_apply [Reflective i] {A : C} {B : D}\n    (f : «expr ⟶ » (i.obj ((leftAdjoint i).obj A)) (i.obj B)) :\n    (unitCompPartialBijectiveAux _ _).symm f = «expr ≫ » ((ofRightAdjoint i).unit.app A) f := by\n  simp [unit_comp_partial_bijective_aux]\n#align unit_comp_partial_bijective_aux_symm_apply unit_comp_partial_bijective_aux_symm_apply\n\n",
 "mem_ess_image_of_unit_is_split_mono":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟭» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/-- If `η_A` is a split monomorphism, then `A` is in the reflective subcategory. -/\ntheorem mem_ess_image_of_unit_is_split_mono [Reflective i] {A : C} [IsSplitMono ((ofRightAdjoint i).unit.app A)] :\n    A ∈ i.ess_image :=\n  by\n  let η : «expr ⟶ » ((«expr𝟭») C) («expr ⋙ » (left_adjoint i) i) := (of_right_adjoint i).unit\n  haveI : is_iso (η.app (i.obj ((left_adjoint i).obj A))) := (i.obj_mem_ess_image _).unit_is_iso\n  have : epi (η.app A) := by\n    apply epi_of_epi (retraction (η.app A)) _\n    rw [show «expr ≫ » (retraction _) (η.app A) = _ from η.naturality (retraction (η.app A))]\n    apply epi_comp (η.app (i.obj ((left_adjoint i).obj A)))\n  skip\n  haveI := is_iso_of_epi_of_is_split_mono (η.app A)\n  exact mem_ess_image_of_unit_is_iso A\n#align mem_ess_image_of_unit_is_split_mono mem_ess_image_of_unit_is_split_mono\n\n",
 "mem_ess_image_of_unit_is_iso":
 "/-- If `η_A` is an isomorphism, then `A` is in the essential image of `i`. -/\ntheorem mem_ess_image_of_unit_is_iso [IsRightAdjoint i] (A : C) [IsIso ((ofRightAdjoint i).unit.app A)] :\n    A ∈ i.ess_image :=\n  ⟨(leftAdjoint i).obj A, ⟨(asIso ((ofRightAdjoint i).unit.app A)).symm⟩⟩\n#align mem_ess_image_of_unit_is_iso mem_ess_image_of_unit_is_iso\n\n"}