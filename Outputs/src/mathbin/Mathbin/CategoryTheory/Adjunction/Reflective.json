{"unit_obj_eq_map_unit":
 "/-\nCopyright (c) 2020 Bhavik Mehta. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Bhavik Mehta\n-/\n-- TODO: This holds more generally for idempotent adjunctions, not just reflective adjunctions.\n/-- For a reflective functor `i` (with left adjoint `L`), with unit `Î·`, we have `Î·_iL = iL Î·`.\n-/\ntheorem unit_obj_eq_map_unit [Reflective i] (X : C) :\n    (ofRightAdjoint i).unit.app (i.obj ((leftAdjoint i).obj X)) =\n      i.map ((leftAdjoint i).map ((ofRightAdjoint i).unit.app X)) :=\n  by\n  rw [â† cancel_mono (i.map ((of_right_adjoint i).counit.app ((left_adjoint i).obj X))), â† i.map_comp]\n  simp\n#align unit_obj_eq_map_unit unit_obj_eq_map_unit\n\n",
 "unit_is_iso":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‹™ Â» -/\n/-- If `A` is essentially in the image of a reflective functor `i`, then `Î·_A` is an isomorphism.\nThis gives that the \"witness\" for `A` being in the essential image can instead be given as the\nreflection of `A`, with the isomorphism as `Î·_A`.\n\n(For any `B` in the reflective subcategory, we automatically have that `Îµ_B` is an iso.)\n-/\ntheorem functor.ess_image.unit_is_iso [Reflective i] {A : C} (h : A âˆˆ i.ess_image) :\n    IsIso ((ofRightAdjoint i).unit.app A) :=\n  by\n  suffices\n    (of_right_adjoint i).unit.app A =\n      Â«expr â‰« Â» h.get_iso.inv\n        (Â«expr â‰« Â» ((of_right_adjoint i).unit.app (i.obj h.witness)) ((Â«expr â‹™ Â» (left_adjoint i) i).map h.get_iso.hom))\n    by\n    rw [this]\n    infer_instance\n  rw [â† nat_trans.naturality]\n  simp\n#align functor.ess_image.unit_is_iso functor.ess_image.unit_is_iso\n\n",
 "unit_comp_partial_bijective_symm_natural":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\ntheorem unit_comp_partial_bijective_symm_natural [Reflective i] (A : C) {B B' : C} (h : Â«expr âŸ¶ Â» B B')\n    (hB : B âˆˆ i.ess_image) (hB' : B' âˆˆ i.ess_image) (f : Â«expr âŸ¶ Â» (i.obj ((leftAdjoint i).obj A)) B) :\n    (unitCompPartialBijective A hB').symm (Â«expr â‰« Â» f h) = Â«expr â‰« Â» ((unitCompPartialBijective A hB).symm f) h := by\n  simp\n#align unit_comp_partial_bijective_symm_natural unit_comp_partial_bijective_symm_natural\n\n",
 "unit_comp_partial_bijective_symm_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n@[simp]\ntheorem unit_comp_partial_bijective_symm_apply [Reflective i] (A : C) {B : C} (hB : B âˆˆ i.ess_image) (f) :\n    (unitCompPartialBijective A hB).symm f = Â«expr â‰« Â» ((ofRightAdjoint i).unit.app A) f := by\n  simp [unit_comp_partial_bijective, unit_comp_partial_bijective_aux_symm_apply]\n#align unit_comp_partial_bijective_symm_apply unit_comp_partial_bijective_symm_apply\n\n",
 "unit_comp_partial_bijective_natural":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\ntheorem unit_comp_partial_bijective_natural [Reflective i] (A : C) {B B' : C} (h : Â«expr âŸ¶ Â» B B')\n    (hB : B âˆˆ i.ess_image) (hB' : B' âˆˆ i.ess_image) (f : Â«expr âŸ¶ Â» A B) :\n    (unitCompPartialBijective A hB') (Â«expr â‰« Â» f h) = Â«expr â‰« Â» (unitCompPartialBijective A hB f) h := by\n  rw [â† Equiv.eq_symm_apply, unit_comp_partial_bijective_symm_natural A h, Equiv.symm_apply_apply]\n#align unit_comp_partial_bijective_natural unit_comp_partial_bijective_natural\n\n",
 "unit_comp_partial_bijective_aux_symm_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/-- The description of the inverse of the bijection `unit_comp_partial_bijective_aux`. -/\ntheorem unit_comp_partial_bijective_aux_symm_apply [Reflective i] {A : C} {B : D}\n    (f : Â«expr âŸ¶ Â» (i.obj ((leftAdjoint i).obj A)) (i.obj B)) :\n    (unitCompPartialBijectiveAux _ _).symm f = Â«expr â‰« Â» ((ofRightAdjoint i).unit.app A) f := by\n  simp [unit_comp_partial_bijective_aux]\n#align unit_comp_partial_bijective_aux_symm_apply unit_comp_partial_bijective_aux_symm_apply\n\n",
 "mem_ess_image_of_unit_is_split_mono":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ­Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‹™ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/-- If `Î·_A` is a split monomorphism, then `A` is in the reflective subcategory. -/\ntheorem mem_ess_image_of_unit_is_split_mono [Reflective i] {A : C} [IsSplitMono ((ofRightAdjoint i).unit.app A)] :\n    A âˆˆ i.ess_image :=\n  by\n  let Î· : Â«expr âŸ¶ Â» ((Â«exprğŸ­Â») C) (Â«expr â‹™ Â» (left_adjoint i) i) := (of_right_adjoint i).unit\n  haveI : is_iso (Î·.app (i.obj ((left_adjoint i).obj A))) := (i.obj_mem_ess_image _).unit_is_iso\n  have : epi (Î·.app A) := by\n    apply epi_of_epi (retraction (Î·.app A)) _\n    rw [show Â«expr â‰« Â» (retraction _) (Î·.app A) = _ from Î·.naturality (retraction (Î·.app A))]\n    apply epi_comp (Î·.app (i.obj ((left_adjoint i).obj A)))\n  skip\n  haveI := is_iso_of_epi_of_is_split_mono (Î·.app A)\n  exact mem_ess_image_of_unit_is_iso A\n#align mem_ess_image_of_unit_is_split_mono mem_ess_image_of_unit_is_split_mono\n\n",
 "mem_ess_image_of_unit_is_iso":
 "/-- If `Î·_A` is an isomorphism, then `A` is in the essential image of `i`. -/\ntheorem mem_ess_image_of_unit_is_iso [IsRightAdjoint i] (A : C) [IsIso ((ofRightAdjoint i).unit.app A)] :\n    A âˆˆ i.ess_image :=\n  âŸ¨(leftAdjoint i).obj A, âŸ¨(asIso ((ofRightAdjoint i).unit.app A)).symmâŸ©âŸ©\n#align mem_ess_image_of_unit_is_iso mem_ess_image_of_unit_is_iso\n\n"}