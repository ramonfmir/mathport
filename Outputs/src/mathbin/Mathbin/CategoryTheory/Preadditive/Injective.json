{"projective_iff_injective_op":
 "theorem projective_iff_injective_op {P : C} : Projective P ↔ Injective (op P) :=\n  ⟨fun h => inferInstance, fun h => show Projective (unop (op P)) from inferInstance⟩\n#align projective_iff_injective_op projective_iff_injective_op\n\n",
 "of_iso":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≅ » -/\ntheorem of_iso {P Q : C} (i : «expr ≅ » P Q) (hP : Injective P) : Injective Q :=\n  {\n    factors := fun X Y g f mono =>\n      by\n      obtain ⟨h, h_eq⟩ := @injective.factors C _ P _ _ _ («expr ≫ » g i.inv) f mono\n      refine' ⟨«expr ≫ » h i.hom, _⟩\n      rw [← category.assoc, h_eq, category.assoc, iso.inv_hom_id, category.comp_id] }\n#align of_iso of_iso\n\n",
 "map_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊣ » -/\ntheorem map_injective (adj : «expr ⊣ » F G) [F.preserves_monomorphisms] (I : D) (hI : Injective I) :\n    Injective (G.obj I) :=\n  ⟨fun X Y f g => by\n    intro\n    rcases hI.factors («expr ≫ » (F.map f) (adj.counit.app _)) (F.map g) with ⟨⟩\n    use «expr ≫ » (adj.unit.app Y) (G.map w)\n    rw [← unit_naturality_assoc, ← G.map_comp, h]\n    simp⟩\n#align map_injective map_injective\n\n",
 "iso_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≅ » -/\ntheorem iso_iff {P Q : C} (i : «expr ≅ » P Q) : Injective P ↔ Injective Q :=\n  ⟨of_iso i, of_iso i.symm⟩\n#align iso_iff iso_iff\n\n",
 "injective_of_map_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊣ » -/\ntheorem injective_of_map_injective (adj : «expr ⊣ » F G) [Full G] [Faithful G] (I : D) (hI : Injective (G.obj I)) :\n    Injective I :=\n  ⟨fun X Y f g => by\n    intro\n    haveI : PreservesLimitsOfSize.{0, 0} G := adj.right_adjoint_preserves_limits\n    rcases hI.factors (G.map f) (G.map g) with ⟨⟩\n    use «expr ≫ » (inv (adj.counit.app _)) («expr ≫ » (F.map w) (adj.counit.app _))\n    refine' faithful.map_injective G _\n    simpa⟩\n#align injective_of_map_injective injective_of_map_injective\n\n",
 "injective_of_adjoint":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊣ » -/\ntheorem injective_of_adjoint (adj : «expr ⊣ » L R) (J : D) [Injective J] : Injective <| R.obj J :=\n  ⟨fun A A' g f im =>\n    ⟨adj.hom_equiv _ _ (factor_thru ((adj.hom_equiv A J).symm g) (L.map f)),\n      (adj.hom_equiv _ _).symm.injective (by simp)⟩⟩\n#align injective_of_adjoint injective_of_adjoint\n\n",
 "injective_iff_projective_op":
 "theorem injective_iff_projective_op {J : C} : Injective J ↔ Projective (op J) :=\n  ⟨fun h => inferInstance, fun h => show Injective (unop (op J)) from inferInstance⟩\n#align injective_iff_projective_op injective_iff_projective_op\n\n",
 "injective_iff_preserves_epimorphisms_yoneda_obj":
 "theorem injective_iff_preserves_epimorphisms_yoneda_obj (J : C) : Injective J ↔ (yoneda.obj J).preserves_epimorphisms :=\n  by\n  rw [injective_iff_projective_op, projective.projective_iff_preserves_epimorphisms_coyoneda_obj]\n  exact functor.preserves_epimorphisms.iso_iff (coyoneda.obj_op_op _)\n#align injective_iff_preserves_epimorphisms_yoneda_obj injective_iff_preserves_epimorphisms_yoneda_obj\n\n",
 "enough_projectives_of_enough_injectives_op":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵖ» -/\ntheorem enough_projectives_of_enough_injectives_op [EnoughInjectives («expr ᵒᵖ» C)] : EnoughProjectives C :=\n  ⟨fun X => ⟨⟨_, inferInstance, (Injective.ι (op X)).unop, inferInstance⟩⟩⟩\n#align enough_projectives_of_enough_injectives_op enough_projectives_of_enough_injectives_op\n\n",
 "enough_injectives_of_enough_projectives_op":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵖ» -/\ntheorem enough_injectives_of_enough_projectives_op [EnoughProjectives («expr ᵒᵖ» C)] : EnoughInjectives C :=\n  ⟨fun X => ⟨⟨_, inferInstance, (Projective.π (op X)).unop, inferInstance⟩⟩⟩\n#align enough_injectives_of_enough_projectives_op enough_injectives_of_enough_projectives_op\n\n",
 "enough_injectives_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≌ » -/\ntheorem enough_injectives_iff (F : «expr ≌ » C D) : EnoughInjectives C ↔ EnoughInjectives D :=\n  by\n  constructor\n  all_goals intro H; constructor; intro X; constructor\n  ·\n    exact\n      F.symm.injective_presentation_of_map_injective_presentation _ (Nonempty.some (H.presentation (F.inverse.obj X)))\n  · exact F.injective_presentation_of_map_injective_presentation X (Nonempty.some (H.presentation (F.functor.obj X)))\n#align enough_injectives_iff enough_injectives_iff\n\n",
 "comp_factor_thru":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/-\nCopyright (c) 2022 Jujian Zhang. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Jujian Zhang, Kevin Buzzard\n-/\n@[simp]\ntheorem comp_factor_thru {J X Y : C} [Injective J] (g : «expr ⟶ » X J) (f : «expr ⟶ » X Y) [Mono f] :\n    «expr ≫ » f (factorThru g f) = g :=\n  (injective.factors g f).some_spec\n#align comp_factor_thru comp_factor_thru\n\n",
 "comp_desc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp]\ntheorem exact.comp_desc {J Q R S : C} [Injective J] (h : «expr ⟶ » R J) (f : «expr ⟶ » Q R) (g : «expr ⟶ » R S)\n    (hgf : Exact g.op f.op) (w : «expr ≫ » f h = 0) : «expr ≫ » g (Exact.desc h f g hgf w) = h := by\n  convert congr_arg Quiver.Hom.unop (exact.lift_comp h.op g.op f.op hgf (congr_arg Quiver.Hom.op w))\n#align exact.comp_desc exact.comp_desc\n\n"}