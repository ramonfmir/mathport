{"projective_iff_injective_op":
 "theorem projective_iff_injective_op {P : C} : projective P ↔ injective (op P) :=\n  ⟨fun h => infer_instance, fun h => show projective (unop (op P)) from infer_instance⟩\n#align projective_iff_injective_op projective_iff_injective_op\n\n",
 "of_iso":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≅ » -/\ntheorem of_iso {P Q : C} (i : «expr ≅ » P Q) (hP : injective P) : injective Q :=\n  {\n    factors := fun X Y g f mono =>\n      by\n      obtain ⟨h, h_eq⟩ := @injective.factors C _ P _ _ _ («expr ≫ » g i.inv) f mono\n      refine' ⟨«expr ≫ » h i.hom, _⟩\n      rw [← category.assoc, h_eq, category.assoc, iso.inv_hom_id, category.comp_id] }\n#align of_iso of_iso\n\n",
 "map_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊣ » -/\ntheorem map_injective (adj : «expr ⊣ » F G) [F.preserves_monomorphisms] (I : D) (hI : injective I) :\n    injective (G.obj I) :=\n  ⟨fun X Y f g => by\n    intro\n    rcases hI.factors («expr ≫ » (F.map f) (adj.counit.app _)) (F.map g) with ⟨⟩\n    use «expr ≫ » (adj.unit.app Y) (G.map w)\n    rw [← unit_naturality_assoc, ← G.map_comp, h]\n    simp⟩\n#align map_injective map_injective\n\n",
 "iso_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≅ » -/\ntheorem iso_iff {P Q : C} (i : «expr ≅ » P Q) : injective P ↔ injective Q :=\n  ⟨of_iso i, of_iso i.symm⟩\n#align iso_iff iso_iff\n\n",
 "injective_of_map_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊣ » -/\ntheorem injective_of_map_injective (adj : «expr ⊣ » F G) [Full G] [Faithful G] (I : D) (hI : injective (G.obj I)) :\n    injective I :=\n  ⟨fun X Y f g => by\n    intro\n    haveI := adj.right_adjoint_preserves_limits\n    rcases hI.factors (G.map f) (G.map g) with ⟨⟩\n    use «expr ≫ » (inv (adj.counit.app _)) («expr ≫ » (F.map w) (adj.counit.app _))\n    refine' faithful.map_injective G _\n    simpa⟩\n#align injective_of_map_injective injective_of_map_injective\n\n",
 "injective_of_adjoint":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊣ » -/\ntheorem injective_of_adjoint (adj : «expr ⊣ » L R) (J : D) [injective J] : injective <| R.obj J :=\n  ⟨fun A A' g f im =>\n    ⟨adj.hom_equiv _ _ (factor_thru ((adj.hom_equiv A J).symm g) (L.map f)),\n      (adj.hom_equiv _ _).symm.injective (by simp)⟩⟩\n#align injective_of_adjoint injective_of_adjoint\n\n",
 "injective_iff_projective_op":
 "theorem injective_iff_projective_op {J : C} : injective J ↔ projective (op J) :=\n  ⟨fun h => infer_instance, fun h => show injective (unop (op J)) from infer_instance⟩\n#align injective_iff_projective_op injective_iff_projective_op\n\n",
 "injective_iff_preserves_epimorphisms_yoneda_obj":
 "theorem injective_iff_preserves_epimorphisms_yoneda_obj (J : C) : injective J ↔ (yoneda.obj J).preserves_epimorphisms :=\n  by\n  rw [injective_iff_projective_op, projective.projective_iff_preserves_epimorphisms_coyoneda_obj]\n  exact functor.preserves_epimorphisms.iso_iff (coyoneda.obj_op_op _)\n#align injective_iff_preserves_epimorphisms_yoneda_obj injective_iff_preserves_epimorphisms_yoneda_obj\n\n",
 "injective_iff_preserves_epimorphisms_preadditive_yoneda_obj'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\ntheorem injective_iff_preserves_epimorphisms_preadditive_yoneda_obj' (J : C) :\n    injective J ↔ (preadditive_yoneda_obj J).preserves_epimorphisms :=\n  by\n  rw [injective_iff_preserves_epimorphisms_yoneda_obj]\n  refine' ⟨fun h : («expr ⋙ » (preadditive_yoneda_obj J) (forget _)).preserves_epimorphisms => _, _⟩\n  · exact functor.preserves_epimorphisms_of_preserves_of_reflects (preadditive_yoneda_obj J) (forget _)\n  · intro\n    exact (infer_instance : («expr ⋙ » (preadditive_yoneda_obj J) (forget _)).preserves_epimorphisms)\n#align\n  injective_iff_preserves_epimorphisms_preadditive_yoneda_obj' injective_iff_preserves_epimorphisms_preadditive_yoneda_obj'\n\n",
 "injective_iff_preserves_epimorphisms_preadditive_yoneda_obj":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\ntheorem injective_iff_preserves_epimorphisms_preadditive_yoneda_obj (J : C) :\n    injective J ↔ (preadditive_yoneda.obj J).preserves_epimorphisms :=\n  by\n  rw [injective_iff_preserves_epimorphisms_yoneda_obj]\n  refine' ⟨fun h : («expr ⋙ » (preadditive_yoneda.obj J) (forget _)).preserves_epimorphisms => _, _⟩\n  · exact functor.preserves_epimorphisms_of_preserves_of_reflects (preadditive_yoneda.obj J) (forget _)\n  · intro\n    exact (infer_instance : («expr ⋙ » (preadditive_yoneda.obj J) (forget _)).preserves_epimorphisms)\n#align\n  injective_iff_preserves_epimorphisms_preadditive_yoneda_obj injective_iff_preserves_epimorphisms_preadditive_yoneda_obj\n\n",
 "enough_projectives_of_enough_injectives_op":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵖ» -/\ntheorem enough_projectives_of_enough_injectives_op [enough_injectives («expr ᵒᵖ» C)] : enough_projectives C :=\n  ⟨fun X => ⟨⟨_, infer_instance, (injective.ι (op X)).unop, infer_instance⟩⟩⟩\n#align enough_projectives_of_enough_injectives_op enough_projectives_of_enough_injectives_op\n\n",
 "enough_injectives_of_enough_projectives_op":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵖ» -/\ntheorem enough_injectives_of_enough_projectives_op [enough_projectives («expr ᵒᵖ» C)] : enough_injectives C :=\n  ⟨fun X => ⟨⟨_, infer_instance, (projective.π (op X)).unop, infer_instance⟩⟩⟩\n#align enough_injectives_of_enough_projectives_op enough_injectives_of_enough_projectives_op\n\n",
 "enough_injectives_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≌ » -/\ntheorem enough_injectives_iff (F : «expr ≌ » C D) : enough_injectives C ↔ enough_injectives D :=\n  by\n  constructor\n  all_goals intro H; constructor; intro X; constructor\n  ·\n    exact\n      F.symm.injective_presentation_of_map_injective_presentation _ (nonempty.some (H.presentation (F.inverse.obj X)))\n  · exact F.injective_presentation_of_map_injective_presentation X (nonempty.some (H.presentation (F.functor.obj X)))\n#align enough_injectives_iff enough_injectives_iff\n\n",
 "comp_factor_thru":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/-\nCopyright (c) 2022 Jujian Zhang. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Jujian Zhang, Kevin Buzzard\n-/\n@[simp]\ntheorem comp_factor_thru {J X Y : C} [injective J] (g : «expr ⟶ » X J) (f : «expr ⟶ » X Y) [Mono f] :\n    «expr ≫ » f (factor_thru g f) = g :=\n  (injective.factors g f).some_spec\n#align comp_factor_thru comp_factor_thru\n\n",
 "comp_desc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp]\ntheorem exact.comp_desc {J Q R S : C} [injective J] (h : «expr ⟶ » R J) (f : «expr ⟶ » Q R) (g : «expr ⟶ » R S)\n    (hgf : exact g.op f.op) (w : «expr ≫ » f h = 0) : «expr ≫ » g (exact.desc h f g hgf w) = h := by\n  convert congr_arg Quiver.Hom.unop (exact.lift_comp h.op g.op f.op hgf (congr_arg Quiver.Hom.op w))\n#align exact.comp_desc exact.comp_desc\n\n"}