{"mono_of_nonzero_from_simple":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/-\nCopyright (c) 2020 Scott Morrison. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Markus Himmel, Scott Morrison\n-/\n-- See also `epi_of_nonzero_to_simple`, which does not require `preadditive C`.\ntheorem mono_of_nonzero_from_simple [HasKernels C] {X Y : C} [Simple X] {f : Â«expr âŸ¶ Â» X Y} (w : f â‰  0) : Mono f :=\n  Preadditive.mono_of_kernel_zero (kernel_zero_of_nonzero_from_simple w)\n#align mono_of_nonzero_from_simple mono_of_nonzero_from_simple\n\n",
 "is_iso_of_hom_simple":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/-- The part of **Schur's lemma** that holds in any preadditive category with kernels:\nthat a nonzero morphism between simple objects is an isomorphism.\n-/\ntheorem is_iso_of_hom_simple [HasKernels C] {X Y : C} [Simple X] [Simple Y] {f : Â«expr âŸ¶ Â» X Y} (w : f â‰  0) : IsIso f :=\n  haveI := mono_of_nonzero_from_simple w\n  is_iso_of_mono_of_nonzero w\n#align is_iso_of_hom_simple is_iso_of_hom_simple\n\n",
 "is_iso_iff_nonzero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/-- As a corollary of Schur's lemma for preadditive categories,\nany morphism between simple objects is (exclusively) either an isomorphism or zero.\n-/\ntheorem is_iso_iff_nonzero [HasKernels C] {X Y : C} [Simple X] [Simple Y] (f : Â«expr âŸ¶ Â» X Y) : IsIso f â†” f â‰  0 :=\n  âŸ¨fun I => by\n    intro h\n    apply id_nonzero X\n    simp only [â† is_iso.hom_inv_id f, h, zero_comp], fun w => is_iso_of_hom_simple wâŸ©\n#align is_iso_iff_nonzero is_iso_iff_nonzero\n\n",
 "finrank_hom_simple_simple_le_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr =â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n-- There is a symmetric argument that uses `[finite_dimensional ğ•œ (Y âŸ¶ Y)]` instead,\n-- but we don't bother proving that here.\n/-- **Schur's lemma** for `ğ•œ`-linear categories:\nif hom spaces are finite dimensional, then the hom space between simples is at most 1-dimensional.\n\nSee `finrank_hom_simple_simple_eq_one_iff` and `finrank_hom_simple_simple_eq_zero_iff` below\nfor the refinements when we know whether or not the simples are isomorphic.\n-/\ntheorem finrank_hom_simple_simple_le_one (X Y : C) [FiniteDimensional ğ•œ (Â«expr âŸ¶ Â» X X)] [Simple X] [Simple Y] :\n    finrank ğ•œ (Â«expr âŸ¶ Â» X Y) â‰¤ 1 :=\n  by\n  cases' subsingleton_or_nontrivial (Â«expr âŸ¶ Â» X Y) with h\n  Â· skip\n    rw [finrank_zero_of_subsingleton]\n    exact zero_le_one\n  Â· obtain âŸ¨f, nzâŸ© := (nontrivial_iff_exists_ne 0).mp h\n    haveI fi := (is_iso_iff_nonzero f).mpr nz\n    refine' finrank_le_one f _\n    intro g\n    obtain âŸ¨c, wâŸ© := endomorphism_simple_eq_smul_id ğ•œ (Â«expr â‰« Â» g (inv f))\n    exact âŸ¨c, by simpa using Â«expr =â‰« Â» w fâŸ©\n#align finrank_hom_simple_simple_le_one finrank_hom_simple_simple_le_one\n\n",
 "finrank_hom_simple_simple_eq_zero_of_not_iso":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰… Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/-- Part of **Schur's lemma** for `ğ•œ`-linear categories:\nthe hom space between two non-isomorphic simple objects is 0-dimensional.\n-/\ntheorem finrank_hom_simple_simple_eq_zero_of_not_iso [HasKernels C] [Linear ğ•œ C] {X Y : C} [Simple X] [Simple Y]\n    (h : Â«expr â‰… Â» X Y â†’ False) : finrank ğ•œ (Â«expr âŸ¶ Â» X Y) = 0 :=\n  haveI :=\n    subsingleton_of_forall_eq (0 : Â«expr âŸ¶ Â» X Y) fun f =>\n      by\n      have p := not_congr (is_iso_iff_nonzero f)\n      simp only [Classical.not_not, ne.def] at p\n      refine' p.mp fun _ => h (as_iso f)\n  finrank_zero_of_subsingleton\n#align finrank_hom_simple_simple_eq_zero_of_not_iso finrank_hom_simple_simple_eq_zero_of_not_iso\n\n",
 "finrank_hom_simple_simple_eq_zero_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰… Â» -/\ntheorem finrank_hom_simple_simple_eq_zero_iff (X Y : C) [FiniteDimensional ğ•œ (Â«expr âŸ¶ Â» X X)]\n    [FiniteDimensional ğ•œ (Â«expr âŸ¶ Â» X Y)] [Simple X] [Simple Y] :\n    finrank ğ•œ (Â«expr âŸ¶ Â» X Y) = 0 â†” IsEmpty (Â«expr â‰… Â» X Y) :=\n  by\n  rw [â† not_nonempty_iff, â† not_congr (finrank_hom_simple_simple_eq_one_iff ğ•œ X Y)]\n  refine'\n    âŸ¨fun h => by\n      rw [h]\n      simp, fun h => _âŸ©\n  have := finrank_hom_simple_simple_le_one ğ•œ X Y\n  interval_cases h' : finrank ğ•œ (Â«expr âŸ¶ Â» X Y)\n  Â· exact h'\n  Â· exact false.elim (h h')\n#align finrank_hom_simple_simple_eq_zero_iff finrank_hom_simple_simple_eq_zero_iff\n\n",
 "finrank_hom_simple_simple_eq_one_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰… Â» -/\ntheorem finrank_hom_simple_simple_eq_one_iff (X Y : C) [FiniteDimensional ğ•œ (Â«expr âŸ¶ Â» X X)]\n    [FiniteDimensional ğ•œ (Â«expr âŸ¶ Â» X Y)] [Simple X] [Simple Y] :\n    finrank ğ•œ (Â«expr âŸ¶ Â» X Y) = 1 â†” Nonempty (Â«expr â‰… Â» X Y) :=\n  by\n  fconstructor\n  Â· intro h\n    rw [finrank_eq_one_iff'] at h\n    obtain âŸ¨f, nz, -âŸ© := h\n    rw [â† is_iso_iff_nonzero] at nz\n    exact âŸ¨as_iso fâŸ©\n  Â· rintro âŸ¨fâŸ©\n    have le_one := finrank_hom_simple_simple_le_one ğ•œ X Y\n    have zero_lt : 0 < finrank ğ•œ (Â«expr âŸ¶ Â» X Y) :=\n      finrank_pos_iff_exists_ne_zero.mpr âŸ¨f.hom, (is_iso_iff_nonzero f.hom).mp inferInstanceâŸ©\n    linarith\n#align finrank_hom_simple_simple_eq_one_iff finrank_hom_simple_simple_eq_one_iff\n\n",
 "finrank_hom_simple_simple":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰… Â» -/\ntheorem finrank_hom_simple_simple (X Y : C) [âˆ€ X Y : C, FiniteDimensional ğ•œ (Â«expr âŸ¶ Â» X Y)] [Simple X] [Simple Y] :\n    finrank ğ•œ (Â«expr âŸ¶ Â» X Y) = if Nonempty (Â«expr â‰… Â» X Y) then 1 else 0 :=\n  by\n  split_ifs\n  exact (finrank_hom_simple_simple_eq_one_iff ğ•œ X Y).2 h\n  exact (finrank_hom_simple_simple_eq_zero_iff ğ•œ X Y).2 (not_nonempty_iff.mp h)\n#align finrank_hom_simple_simple finrank_hom_simple_simple\n\n",
 "finrank_endomorphism_simple_eq_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/-- **Schur's lemma** for endomorphisms in `ğ•œ`-linear categories.\n-/\ntheorem finrank_endomorphism_simple_eq_one (X : C) [Simple X] [I : FiniteDimensional ğ•œ (Â«expr âŸ¶ Â» X X)] :\n    finrank ğ•œ (Â«expr âŸ¶ Â» X X) = 1 :=\n  finrank_endomorphism_eq_one ğ•œ is_iso_iff_nonzero\n#align finrank_endomorphism_simple_eq_one finrank_endomorphism_simple_eq_one\n\n",
 "finrank_endomorphism_eq_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n-- In the proof below we have some difficulty using `I : finite_dimensional ğ•œ (X âŸ¶ X)`\n-- where we need a `finite_dimensional ğ•œ (End X)`.\n-- These are definitionally equal, but without eta reduction Lean can't see this.\n-- To get around this, we use `convert I`,\n-- then check the various instances agree field-by-field,\n-- We prove this with the explicit `is_iso_iff_nonzero` assumption,\n-- rather than just `[simple X]`, as this form is useful for\n-- MÃ¼ger's formulation of semisimplicity.\n/-- An auxiliary lemma for Schur's lemma.\n\nIf `X âŸ¶ X` is finite dimensional, and every nonzero endomorphism is invertible,\nthen `X âŸ¶ X` is 1-dimensional.\n-/\ntheorem finrank_endomorphism_eq_one {X : C} (is_iso_iff_nonzero : âˆ€ f : Â«expr âŸ¶ Â» X X, IsIso f â†” f â‰  0)\n    [I : FiniteDimensional ğ•œ (Â«expr âŸ¶ Â» X X)] : finrank ğ•œ (Â«expr âŸ¶ Â» X X) = 1 :=\n  by\n  have id_nonzero := (is_iso_iff_nonzero ((Â«exprğŸ™Â») X)).mp (by infer_instance)\n  refine' finrank_eq_one ((Â«exprğŸ™Â») X) id_nonzero _\n  Â· intro f\n    haveI : Nontrivial (End X) := nontrivial_of_ne _ _ id_nonzero\n    obtain âŸ¨c, nuâŸ© :=\n      @spectrum.nonempty_of_is_alg_closed_of_finite_dimensional ğ•œ (End X) _ _ _ _ _\n        (by\n          convert I\n          ext\n          rfl\n          ext\n          rfl)\n        (End.of f)\n    use c\n    rw [spectrum.mem_iff, IsUnit.sub_iff, is_unit_iff_is_iso, is_iso_iff_nonzero, ne.def, Classical.not_not,\n      sub_eq_zero, Algebra.algebraMap_eq_smul_one] at nu\n    exact nu.symm\n#align finrank_endomorphism_eq_one finrank_endomorphism_eq_one\n\n",
 "endomorphism_simple_eq_smul_id":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\ntheorem endomorphism_simple_eq_smul_id {X : C} [Simple X] [I : FiniteDimensional ğ•œ (Â«expr âŸ¶ Â» X X)]\n    (f : Â«expr âŸ¶ Â» X X) : âˆƒ c : ğ•œ, Â«expr â€¢ Â» c ((Â«exprğŸ™Â») X) = f :=\n  (finrank_eq_one_iff_of_nonzero' ((Â«exprğŸ™Â») X) (id_nonzero X)).mp (finrank_endomorphism_simple_eq_one ğ•œ X) f\n#align endomorphism_simple_eq_smul_id endomorphism_simple_eq_smul_id\n\n"}