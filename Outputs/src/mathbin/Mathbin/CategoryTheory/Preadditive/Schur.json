{"mono_of_nonzero_from_simple":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/-\nCopyright (c) 2020 Scott Morrison. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Markus Himmel, Scott Morrison\n-/\n-- See also `epi_of_nonzero_to_simple`, which does not require `preadditive C`.\ntheorem mono_of_nonzero_from_simple [HasKernels C] {X Y : C} [Simple X] {f : «expr ⟶ » X Y} (w : f ≠ 0) : Mono f :=\n  Preadditive.mono_of_kernel_zero (kernel_zero_of_nonzero_from_simple w)\n#align mono_of_nonzero_from_simple mono_of_nonzero_from_simple\n\n",
 "is_iso_of_hom_simple":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/-- The part of **Schur's lemma** that holds in any preadditive category with kernels:\nthat a nonzero morphism between simple objects is an isomorphism.\n-/\ntheorem is_iso_of_hom_simple [HasKernels C] {X Y : C} [Simple X] [Simple Y] {f : «expr ⟶ » X Y} (w : f ≠ 0) : IsIso f :=\n  haveI := mono_of_nonzero_from_simple w\n  is_iso_of_mono_of_nonzero w\n#align is_iso_of_hom_simple is_iso_of_hom_simple\n\n",
 "is_iso_iff_nonzero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/-- As a corollary of Schur's lemma for preadditive categories,\nany morphism between simple objects is (exclusively) either an isomorphism or zero.\n-/\ntheorem is_iso_iff_nonzero [HasKernels C] {X Y : C} [Simple X] [Simple Y] (f : «expr ⟶ » X Y) : IsIso f ↔ f ≠ 0 :=\n  ⟨fun I => by\n    intro h\n    apply id_nonzero X\n    simp only [← is_iso.hom_inv_id f, h, zero_comp], fun w => is_iso_of_hom_simple w⟩\n#align is_iso_iff_nonzero is_iso_iff_nonzero\n\n",
 "finrank_hom_simple_simple_le_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n-- There is a symmetric argument that uses `[finite_dimensional 𝕜 (Y ⟶ Y)]` instead,\n-- but we don't bother proving that here.\n/-- **Schur's lemma** for `𝕜`-linear categories:\nif hom spaces are finite dimensional, then the hom space between simples is at most 1-dimensional.\n\nSee `finrank_hom_simple_simple_eq_one_iff` and `finrank_hom_simple_simple_eq_zero_iff` below\nfor the refinements when we know whether or not the simples are isomorphic.\n-/\ntheorem finrank_hom_simple_simple_le_one (X Y : C) [FiniteDimensional 𝕜 («expr ⟶ » X X)] [Simple X] [Simple Y] :\n    finrank 𝕜 («expr ⟶ » X Y) ≤ 1 :=\n  by\n  cases' subsingleton_or_nontrivial («expr ⟶ » X Y) with h\n  · skip\n    rw [finrank_zero_of_subsingleton]\n    exact zero_le_one\n  · obtain ⟨f, nz⟩ := (nontrivial_iff_exists_ne 0).mp h\n    haveI fi := (is_iso_iff_nonzero f).mpr nz\n    refine' finrank_le_one f _\n    intro g\n    obtain ⟨c, w⟩ := endomorphism_simple_eq_smul_id 𝕜 («expr ≫ » g (inv f))\n    exact ⟨c, by simpa using «expr =≫ » w f⟩\n#align finrank_hom_simple_simple_le_one finrank_hom_simple_simple_le_one\n\n",
 "finrank_hom_simple_simple_eq_zero_of_not_iso":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≅ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/-- Part of **Schur's lemma** for `𝕜`-linear categories:\nthe hom space between two non-isomorphic simple objects is 0-dimensional.\n-/\ntheorem finrank_hom_simple_simple_eq_zero_of_not_iso [HasKernels C] [Linear 𝕜 C] {X Y : C} [Simple X] [Simple Y]\n    (h : «expr ≅ » X Y → False) : finrank 𝕜 («expr ⟶ » X Y) = 0 :=\n  haveI :=\n    subsingleton_of_forall_eq (0 : «expr ⟶ » X Y) fun f =>\n      by\n      have p := not_congr (is_iso_iff_nonzero f)\n      simp only [Classical.not_not, ne.def] at p\n      refine' p.mp fun _ => h (as_iso f)\n  finrank_zero_of_subsingleton\n#align finrank_hom_simple_simple_eq_zero_of_not_iso finrank_hom_simple_simple_eq_zero_of_not_iso\n\n",
 "finrank_hom_simple_simple_eq_zero_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≅ » -/\ntheorem finrank_hom_simple_simple_eq_zero_iff (X Y : C) [FiniteDimensional 𝕜 («expr ⟶ » X X)]\n    [FiniteDimensional 𝕜 («expr ⟶ » X Y)] [Simple X] [Simple Y] :\n    finrank 𝕜 («expr ⟶ » X Y) = 0 ↔ IsEmpty («expr ≅ » X Y) :=\n  by\n  rw [← not_nonempty_iff, ← not_congr (finrank_hom_simple_simple_eq_one_iff 𝕜 X Y)]\n  refine'\n    ⟨fun h => by\n      rw [h]\n      simp, fun h => _⟩\n  have := finrank_hom_simple_simple_le_one 𝕜 X Y\n  interval_cases h' : finrank 𝕜 («expr ⟶ » X Y)\n  · exact h'\n  · exact false.elim (h h')\n#align finrank_hom_simple_simple_eq_zero_iff finrank_hom_simple_simple_eq_zero_iff\n\n",
 "finrank_hom_simple_simple_eq_one_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≅ » -/\ntheorem finrank_hom_simple_simple_eq_one_iff (X Y : C) [FiniteDimensional 𝕜 («expr ⟶ » X X)]\n    [FiniteDimensional 𝕜 («expr ⟶ » X Y)] [Simple X] [Simple Y] :\n    finrank 𝕜 («expr ⟶ » X Y) = 1 ↔ Nonempty («expr ≅ » X Y) :=\n  by\n  fconstructor\n  · intro h\n    rw [finrank_eq_one_iff'] at h\n    obtain ⟨f, nz, -⟩ := h\n    rw [← is_iso_iff_nonzero] at nz\n    exact ⟨as_iso f⟩\n  · rintro ⟨f⟩\n    have le_one := finrank_hom_simple_simple_le_one 𝕜 X Y\n    have zero_lt : 0 < finrank 𝕜 («expr ⟶ » X Y) :=\n      finrank_pos_iff_exists_ne_zero.mpr ⟨f.hom, (is_iso_iff_nonzero f.hom).mp inferInstance⟩\n    linarith\n#align finrank_hom_simple_simple_eq_one_iff finrank_hom_simple_simple_eq_one_iff\n\n",
 "finrank_hom_simple_simple":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≅ » -/\ntheorem finrank_hom_simple_simple (X Y : C) [∀ X Y : C, FiniteDimensional 𝕜 («expr ⟶ » X Y)] [Simple X] [Simple Y] :\n    finrank 𝕜 («expr ⟶ » X Y) = if Nonempty («expr ≅ » X Y) then 1 else 0 :=\n  by\n  split_ifs\n  exact (finrank_hom_simple_simple_eq_one_iff 𝕜 X Y).2 h\n  exact (finrank_hom_simple_simple_eq_zero_iff 𝕜 X Y).2 (not_nonempty_iff.mp h)\n#align finrank_hom_simple_simple finrank_hom_simple_simple\n\n",
 "finrank_endomorphism_simple_eq_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/-- **Schur's lemma** for endomorphisms in `𝕜`-linear categories.\n-/\ntheorem finrank_endomorphism_simple_eq_one (X : C) [Simple X] [I : FiniteDimensional 𝕜 («expr ⟶ » X X)] :\n    finrank 𝕜 («expr ⟶ » X X) = 1 :=\n  finrank_endomorphism_eq_one 𝕜 is_iso_iff_nonzero\n#align finrank_endomorphism_simple_eq_one finrank_endomorphism_simple_eq_one\n\n",
 "finrank_endomorphism_eq_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n-- In the proof below we have some difficulty using `I : finite_dimensional 𝕜 (X ⟶ X)`\n-- where we need a `finite_dimensional 𝕜 (End X)`.\n-- These are definitionally equal, but without eta reduction Lean can't see this.\n-- To get around this, we use `convert I`,\n-- then check the various instances agree field-by-field,\n-- We prove this with the explicit `is_iso_iff_nonzero` assumption,\n-- rather than just `[simple X]`, as this form is useful for\n-- Müger's formulation of semisimplicity.\n/-- An auxiliary lemma for Schur's lemma.\n\nIf `X ⟶ X` is finite dimensional, and every nonzero endomorphism is invertible,\nthen `X ⟶ X` is 1-dimensional.\n-/\ntheorem finrank_endomorphism_eq_one {X : C} (is_iso_iff_nonzero : ∀ f : «expr ⟶ » X X, IsIso f ↔ f ≠ 0)\n    [I : FiniteDimensional 𝕜 («expr ⟶ » X X)] : finrank 𝕜 («expr ⟶ » X X) = 1 :=\n  by\n  have id_nonzero := (is_iso_iff_nonzero ((«expr𝟙») X)).mp (by infer_instance)\n  refine' finrank_eq_one ((«expr𝟙») X) id_nonzero _\n  · intro f\n    haveI : Nontrivial (End X) := nontrivial_of_ne _ _ id_nonzero\n    obtain ⟨c, nu⟩ :=\n      @spectrum.nonempty_of_is_alg_closed_of_finite_dimensional 𝕜 (End X) _ _ _ _ _\n        (by\n          convert I\n          ext\n          rfl\n          ext\n          rfl)\n        (End.of f)\n    use c\n    rw [spectrum.mem_iff, IsUnit.sub_iff, is_unit_iff_is_iso, is_iso_iff_nonzero, ne.def, Classical.not_not,\n      sub_eq_zero, Algebra.algebraMap_eq_smul_one] at nu\n    exact nu.symm\n#align finrank_endomorphism_eq_one finrank_endomorphism_eq_one\n\n",
 "endomorphism_simple_eq_smul_id":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\ntheorem endomorphism_simple_eq_smul_id {X : C} [Simple X] [I : FiniteDimensional 𝕜 («expr ⟶ » X X)]\n    (f : «expr ⟶ » X X) : ∃ c : 𝕜, «expr • » c ((«expr𝟙») X) = f :=\n  (finrank_eq_one_iff_of_nonzero' ((«expr𝟙») X) (id_nonzero X)).mp (finrank_endomorphism_simple_eq_one 𝕜 X) f\n#align endomorphism_simple_eq_smul_id endomorphism_simple_eq_smul_id\n\n"}