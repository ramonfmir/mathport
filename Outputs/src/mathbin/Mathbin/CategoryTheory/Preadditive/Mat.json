{"id_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\ntheorem id_def (M : Mat R) : («expr𝟙») M = fun i j => if h : i = j then 1 else 0 :=\n  rfl\n#align id_def id_def\n\n",
 "id_apply_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n@[simp]\ntheorem id_apply_self (M : Mat R) (i : M) : ((«expr𝟙») M : Matrix M M R) i i = 1 := by simp [id_apply]\n#align id_apply_self id_apply_self\n\n",
 "id_apply_of_ne":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n@[simp]\ntheorem id_apply_of_ne (M : Mat R) (i j : M) (h : i ≠ j) : ((«expr𝟙») M : Matrix M M R) i j = 0 := by simp [id_apply, h]\n#align id_apply_of_ne id_apply_of_ne\n\n",
 "id_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\ntheorem id_apply (M : Mat R) (i j : M) : ((«expr𝟙») M : Matrix M M R) i j = if h : i = j then 1 else 0 :=\n  rfl\n#align id_apply id_apply\n\n",
 "equivalence_self_of_has_finite_biproducts_inverse":
 "@[simp]\ntheorem equivalence_self_of_has_finite_biproducts_inverse {C : Type (u₁ + 1)} [LargeCategory C] [Preadditive C]\n    [HasFiniteBiproducts C] : (equivalence_self_of_has_finite_biproducts C).inverse = embedding C :=\n  rfl\n#align equivalence_self_of_has_finite_biproducts_inverse equivalence_self_of_has_finite_biproducts_inverse\n\n",
 "equivalence_self_of_has_finite_biproducts_functor":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟭» -/\n-- Not sure why this doesn't fire via `simp`.\n-- TODO is there some uniqueness statement for the natural isomorphism in `lift_unique`?\n-- I suspect this is already an adjoint equivalence, but it seems painful to verify.\n@[simp]\ntheorem equivalence_self_of_has_finite_biproducts_functor {C : Type (u₁ + 1)} [LargeCategory C] [Preadditive C]\n    [HasFiniteBiproducts C] : (equivalence_self_of_has_finite_biproducts C).functor = lift ((«expr𝟭») C) :=\n  rfl\n#align equivalence_self_of_has_finite_biproducts_functor equivalence_self_of_has_finite_biproducts_functor\n\n",
 "comp_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\ntheorem comp_def {M N K : Mat R} (f : «expr ⟶ » M N) (g : «expr ⟶ » N K) :\n    «expr ≫ » f g = fun i k =>\n      finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n        (f i j * g j k) :=\n  rfl\n#align comp_def comp_def\n\n",
 "comp_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n@[simp]\ntheorem comp_apply {M N K : Mat R} (f : «expr ⟶ » M N) (g : «expr ⟶ » N K) (i k) :\n    («expr ≫ » f g) i k =\n      finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n        (f i j * g j k) :=\n  rfl\n#align comp_apply comp_apply\n\n",
 "additive_obj_iso_biproduct_naturality'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[reassoc.1]\ntheorem additive_obj_iso_biproduct_naturality' (F : «expr ⥤ » (Mat_ C) D) [Functor.Additive F] {M N : Mat_ C}\n    (f : «expr ⟶ » M N) :\n    «expr ≫ » (additive_obj_iso_biproduct F M).inv (F.map f) =\n      «expr ≫ » (biproduct.matrix (fun i j => F.map ((embedding C).map (f i j)) : _))\n        (additive_obj_iso_biproduct F N).inv :=\n  by rw [iso.inv_comp_eq, ← category.assoc, iso.eq_comp_inv, additive_obj_iso_biproduct_naturality]\n#align additive_obj_iso_biproduct_naturality' additive_obj_iso_biproduct_naturality'\n\n",
 "additive_obj_iso_biproduct_naturality":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n-- Notice we were careful not to use `subst` until we had a goal in `Prop`.\n-- I'm not sure why we can't just `simp` by `finset.sum_apply`: something doesn't quite match\n@[reassoc.1]\ntheorem additive_obj_iso_biproduct_naturality (F : «expr ⥤ » (Mat_ C) D) [Functor.Additive F] {M N : Mat_ C}\n    (f : «expr ⟶ » M N) :\n    «expr ≫ » (F.map f) (additive_obj_iso_biproduct F N).hom =\n      «expr ≫ » (additive_obj_iso_biproduct F M).hom (biproduct.matrix fun i j => F.map ((embedding C).map (f i j))) :=\n  by\n  -- This is disappointingly tedious.\n  ext\n  simp only [additive_obj_iso_biproduct_hom, category.assoc, biproduct.lift_π, functor.map_bicone_π, biproduct.bicone_π,\n    biproduct.lift_matrix]\n  dsimp [Embedding]\n  simp only [← F.map_comp, biproduct.lift_π, biproduct.matrix_π, category.assoc]\n  simp only [← F.map_comp, ← F.map_sum, biproduct.lift_desc, biproduct.lift_π_assoc, comp_sum]\n  simp only [comp_def, comp_dite, comp_zero, Finset.sum_dite_eq', Finset.mem_univ, if_true]\n  dsimp\n  simp only [Finset.sum_singleton, dite_comp, zero_comp]\n  congr\n  symm\n  convert Finset.sum_fn _ _\n  -- It's hard to use this as a simp lemma!\n  simp only [Finset.sum_fn, Finset.sum_dite_eq]\n  ext\n  simp\n#align additive_obj_iso_biproduct_naturality additive_obj_iso_biproduct_naturality\n\n",
 "add_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n@[simp]\ntheorem add_apply {M N : Mat_ C} (f g : «expr ⟶ » M N) (i j) : (f + g) i j = f i j + g i j :=\n  rfl\n#align add_apply add_apply\n\n"}