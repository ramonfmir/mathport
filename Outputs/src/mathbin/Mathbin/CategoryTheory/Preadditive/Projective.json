{"projective_of_map_projective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊣ » -/\ntheorem projective_of_map_projective (adj : «expr ⊣ » F G) [Full F] [Faithful F] (P : C) (hP : projective (F.obj P)) :\n    projective P :=\n  ⟨fun X Y f g => by\n    intro\n    haveI := adj.left_adjoint_preserves_colimits\n    rcases(@hP).1 (F.map f) (F.map g) with ⟨⟩\n    use «expr ≫ » (adj.unit.app _) («expr ≫ » (G.map w) (inv <| adj.unit.app _))\n    refine' faithful.map_injective F _\n    simpa⟩\n#align projective_of_map_projective projective_of_map_projective\n\n",
 "projective_iff_preserves_epimorphisms_preadditive_coyoneda_obj'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\ntheorem projective_iff_preserves_epimorphisms_preadditive_coyoneda_obj' (P : C) :\n    projective P ↔ (preadditive_coyoneda_obj (op P)).preserves_epimorphisms :=\n  by\n  rw [projective_iff_preserves_epimorphisms_coyoneda_obj]\n  refine' ⟨fun h : («expr ⋙ » (preadditive_coyoneda_obj (op P)) (forget _)).preserves_epimorphisms => _, _⟩\n  · exact functor.preserves_epimorphisms_of_preserves_of_reflects (preadditive_coyoneda_obj (op P)) (forget _)\n  · intro\n    exact (infer_instance : («expr ⋙ » (preadditive_coyoneda_obj (op P)) (forget _)).preserves_epimorphisms)\n#align\n  projective_iff_preserves_epimorphisms_preadditive_coyoneda_obj' projective_iff_preserves_epimorphisms_preadditive_coyoneda_obj'\n\n",
 "projective_iff_preserves_epimorphisms_preadditive_coyoneda_obj":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\ntheorem projective_iff_preserves_epimorphisms_preadditive_coyoneda_obj (P : C) :\n    projective P ↔ (preadditive_coyoneda.obj (op P)).preserves_epimorphisms :=\n  by\n  rw [projective_iff_preserves_epimorphisms_coyoneda_obj]\n  refine' ⟨fun h : («expr ⋙ » (preadditive_coyoneda.obj (op P)) (forget _)).preserves_epimorphisms => _, _⟩\n  · exact functor.preserves_epimorphisms_of_preserves_of_reflects (preadditive_coyoneda.obj (op P)) (forget _)\n  · intro\n    exact (infer_instance : («expr ⋙ » (preadditive_coyoneda.obj (op P)) (forget _)).preserves_epimorphisms)\n#align\n  projective_iff_preserves_epimorphisms_preadditive_coyoneda_obj projective_iff_preserves_epimorphisms_preadditive_coyoneda_obj\n\n",
 "projective_iff_preserves_epimorphisms_coyoneda_obj":
 "theorem projective_iff_preserves_epimorphisms_coyoneda_obj (P : C) :\n    projective P ↔ (coyoneda.obj (op P)).preserves_epimorphisms :=\n  ⟨fun hP =>\n    ⟨fun X Y f hf =>\n      (epi_iff_surjective _).2 fun g =>\n        have : projective (unop (op P)) := hP\n        ⟨factor_thru g f, factor_thru_comp _ _⟩⟩,\n    fun h => ⟨fun E X f e he => (epi_iff_surjective _).1 (infer_instance : epi ((coyoneda.obj (op P)).map e)) f⟩⟩\n#align projective_iff_preserves_epimorphisms_coyoneda_obj projective_iff_preserves_epimorphisms_coyoneda_obj\n\n",
 "of_iso":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≅ » -/\ntheorem of_iso {P Q : C} (i : «expr ≅ » P Q) (hP : projective P) : projective Q :=\n  by\n  fconstructor\n  intro E X f e e_epi\n  obtain ⟨f', hf'⟩ := projective.factors («expr ≫ » i.hom f) e\n  exact ⟨«expr ≫ » i.inv f', by simp [hf']⟩\n#align of_iso of_iso\n\n",
 "map_projective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊣ » -/\ntheorem map_projective (adj : «expr ⊣ » F G) [G.preserves_epimorphisms] (P : C) (hP : projective P) :\n    projective (F.obj P) :=\n  ⟨fun X Y f g => by\n    intro\n    rcases hP.factors («expr ≫ » (adj.unit.app P) (G.map f)) (G.map g) with ⟨⟩\n    use «expr ≫ » (F.map w) (adj.counit.app X)\n    rw [category.assoc, ← adjunction.counit_naturality, ← category.assoc, ← F.map_comp, h]\n    simp⟩\n#align map_projective map_projective\n\n",
 "lift_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp]\ntheorem exact.lift_comp {P Q R S : C} [projective P] (h : «expr ⟶ » P R) (f : «expr ⟶ » Q R) (g : «expr ⟶ » R S)\n    (hfg : exact f g) (w : «expr ≫ » h g = 0) : «expr ≫ » (exact.lift h f g hfg w) f = h :=\n  by\n  simp [exact.lift]\n  conv_lhs =>\n    congr\n    skip\n    rw [← image_subobject_arrow_comp f]\n  rw [← category.assoc, factor_thru_comp, ← image_to_kernel_arrow, ← category.assoc,\n    category_theory.projective.factor_thru_comp, factor_thru_kernel_subobject_comp_arrow]\n#align exact.lift_comp exact.lift_comp\n\n",
 "iso_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≅ » -/\ntheorem iso_iff {P Q : C} (i : «expr ≅ » P Q) : projective P ↔ projective Q :=\n  ⟨of_iso i, of_iso i.symm⟩\n#align iso_iff iso_iff\n\n",
 "factor_thru_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/-\nCopyright (c) 2020 Markus Himmel. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Markus Himmel, Scott Morrison\n-/\n@[simp]\ntheorem factor_thru_comp {P X E : C} [projective P] (f : «expr ⟶ » P X) (e : «expr ⟶ » E X) [Epi e] :\n    «expr ≫ » (factor_thru f e) e = f :=\n  (projective.factors f e).some_spec\n#align factor_thru_comp factor_thru_comp\n\n",
 "enough_projectives_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≌ » -/\ntheorem enough_projectives_iff (F : «expr ≌ » C D) : enough_projectives C ↔ enough_projectives D :=\n  by\n  constructor\n  all_goals intro H; constructor; intro X; constructor\n  ·\n    exact\n      F.symm.projective_presentation_of_map_projective_presentation _ (nonempty.some (H.presentation (F.inverse.obj X)))\n  · exact F.projective_presentation_of_map_projective_presentation X (nonempty.some (H.presentation (F.functor.obj X)))\n#align enough_projectives_iff enough_projectives_iff\n\n"}