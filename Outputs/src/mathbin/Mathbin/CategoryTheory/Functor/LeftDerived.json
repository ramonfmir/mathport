{"left_derived_map_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/-\nCopyright (c) 2021 Scott Morrison. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Scott Morrison\n-/\n-- Importing `category_theory.abelian.projective` and assuming\n-- `[abelian C] [enough_projectives C] [abelian D]` suffices to acquire all the following:\n-- TODO the left derived functors are additive (and linear when `F` is linear)\n/-- We can compute a left derived functor on a morphism using a lift of that morphism\nto a chain map between chosen projective resolutions.\n-/\ntheorem functor.left_derived_map_eq (F : Â«expr â¥¤ Â» C D) [F.additive] (n : â„•) {X Y : C} (f : Â«expr âŸ¶ Â» X Y)\n    {P : ProjectiveResolution X} {Q : ProjectiveResolution Y} (g : Â«expr âŸ¶ Â» P.complex Q.complex)\n    (w : Â«expr â‰« Â» g Q.Ï€ = Â«expr â‰« Â» P.Ï€ ((ChainComplex.singleâ‚€ C).map f)) :\n    (F.left_derived n).map f =\n      Â«expr â‰« Â» (F.left_derived_obj_iso n P).hom\n        (Â«expr â‰« Â» ((homologyFunctor D _ n).map ((F.map_homological_complex _).map g))\n          (F.left_derived_obj_iso n Q).inv) :=\n  by\n  dsimp only [functor.left_derived, functor.left_derived_obj_iso]\n  dsimp; simp only [category.comp_id, category.id_comp]\n  rw [â† homology_functor_map, HomotopyCategory.homologyFunctor_map_factors]\n  simp only [â† functor.map_comp]\n  congr 1\n  apply HomotopyCategory.eq_of_homotopy\n  apply functor.map_homotopy\n  apply Homotopy.trans\n  exact HomotopyCategory.homotopyOutMap _\n  apply ProjectiveResolution.lift_homotopy f\n  Â· simp\n  Â· simp [w]\n#align functor.left_derived_map_eq functor.left_derived_map_eq\n\n",
 "left_derived_id":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n@[simp]\ntheorem nat_trans.left_derived_id (F : Â«expr â¥¤ Â» C D) [F.additive] (n : â„•) :\n    NatTrans.leftDerived ((Â«exprğŸ™Â») F) n = (Â«exprğŸ™Â») (F.left_derived n) :=\n  by\n  simp [nat_trans.left_derived]\n  rfl\n#align nat_trans.left_derived_id nat_trans.left_derived_id\n\n",
 "left_derived_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/-- A component of the natural transformation between left-derived functors can be computed\nusing a chosen projective resolution.\n-/\ntheorem nat_trans.left_derived_eq {F G : Â«expr â¥¤ Â» C D} [F.additive] [G.additive] (Î± : Â«expr âŸ¶ Â» F G) (n : â„•) {X : C}\n    (P : ProjectiveResolution X) :\n    (NatTrans.leftDerived Î± n).app X =\n      Â«expr â‰« Â» (F.left_derived_obj_iso n P).hom\n        (Â«expr â‰« Â» ((homologyFunctor D _ n).map ((NatTrans.mapHomologicalComplex Î± _).app P.complex))\n          (G.left_derived_obj_iso n P).inv) :=\n  by\n  symm\n  dsimp [nat_trans.left_derived, functor.left_derived_obj_iso]\n  simp only [category.comp_id, category.id_comp]\n  rw [â† homology_functor_map, HomotopyCategory.homologyFunctor_map_factors]\n  simp only [â† functor.map_comp]\n  congr 1\n  apply HomotopyCategory.eq_of_homotopy\n  simp only [nat_trans.map_homological_complex_naturality_assoc, â† functor.map_comp]\n  apply Homotopy.compLeftId\n  rw [â† Functor.map_id]\n  apply functor.map_homotopy\n  apply homotopy_equiv.homotopy_hom_inv_id\n#align nat_trans.left_derived_eq nat_trans.left_derived_eq\n\n",
 "left_derived_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n-- The `simp_nf` linter times out here, so we disable it.\n@[simp, nolint simp_nf]\ntheorem nat_trans.left_derived_comp {F G H : Â«expr â¥¤ Â» C D} [F.additive] [G.additive] [H.additive] (Î± : Â«expr âŸ¶ Â» F G)\n    (Î² : Â«expr âŸ¶ Â» G H) (n : â„•) :\n    NatTrans.leftDerived (Â«expr â‰« Â» Î± Î²) n = Â«expr â‰« Â» (NatTrans.leftDerived Î± n) (NatTrans.leftDerived Î² n) := by\n  simp [nat_trans.left_derived]\n#align nat_trans.left_derived_comp nat_trans.left_derived_comp\n\n"}