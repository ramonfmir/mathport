{"left_derived_map_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/-\nCopyright (c) 2021 Scott Morrison. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Scott Morrison\n-/\n-- Importing `category_theory.abelian.projective` and assuming\n-- `[abelian C] [enough_projectives C] [abelian D]` suffices to acquire all the following:\n-- TODO the left derived functors are additive (and linear when `F` is linear)\n/-- We can compute a left derived functor on a morphism using a lift of that morphism\nto a chain map between chosen projective resolutions.\n-/\ntheorem functor.left_derived_map_eq (F : «expr ⥤ » C D) [F.additive] (n : ℕ) {X Y : C} (f : «expr ⟶ » X Y)\n    {P : ProjectiveResolution X} {Q : ProjectiveResolution Y} (g : «expr ⟶ » P.complex Q.complex)\n    (w : «expr ≫ » g Q.π = «expr ≫ » P.π ((ChainComplex.single₀ C).map f)) :\n    (F.left_derived n).map f =\n      «expr ≫ » (F.left_derived_obj_iso n P).hom\n        («expr ≫ » ((homologyFunctor D _ n).map ((F.map_homological_complex _).map g))\n          (F.left_derived_obj_iso n Q).inv) :=\n  by\n  dsimp only [functor.left_derived, functor.left_derived_obj_iso]\n  dsimp; simp only [category.comp_id, category.id_comp]\n  rw [← homology_functor_map, HomotopyCategory.homologyFunctor_map_factors]\n  simp only [← functor.map_comp]\n  congr 1\n  apply HomotopyCategory.eq_of_homotopy\n  apply functor.map_homotopy\n  apply Homotopy.trans\n  exact HomotopyCategory.homotopyOutMap _\n  apply ProjectiveResolution.lift_homotopy f\n  · simp\n  · simp [w]\n#align functor.left_derived_map_eq functor.left_derived_map_eq\n\n",
 "left_derived_id":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n@[simp]\ntheorem nat_trans.left_derived_id (F : «expr ⥤ » C D) [F.additive] (n : ℕ) :\n    NatTrans.leftDerived ((«expr𝟙») F) n = («expr𝟙») (F.left_derived n) :=\n  by\n  simp [nat_trans.left_derived]\n  rfl\n#align nat_trans.left_derived_id nat_trans.left_derived_id\n\n",
 "left_derived_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/-- A component of the natural transformation between left-derived functors can be computed\nusing a chosen projective resolution.\n-/\ntheorem nat_trans.left_derived_eq {F G : «expr ⥤ » C D} [F.additive] [G.additive] (α : «expr ⟶ » F G) (n : ℕ) {X : C}\n    (P : ProjectiveResolution X) :\n    (NatTrans.leftDerived α n).app X =\n      «expr ≫ » (F.left_derived_obj_iso n P).hom\n        («expr ≫ » ((homologyFunctor D _ n).map ((NatTrans.mapHomologicalComplex α _).app P.complex))\n          (G.left_derived_obj_iso n P).inv) :=\n  by\n  symm\n  dsimp [nat_trans.left_derived, functor.left_derived_obj_iso]\n  simp only [category.comp_id, category.id_comp]\n  rw [← homology_functor_map, HomotopyCategory.homologyFunctor_map_factors]\n  simp only [← functor.map_comp]\n  congr 1\n  apply HomotopyCategory.eq_of_homotopy\n  simp only [nat_trans.map_homological_complex_naturality_assoc, ← functor.map_comp]\n  apply Homotopy.compLeftId\n  rw [← Functor.map_id]\n  apply functor.map_homotopy\n  apply homotopy_equiv.homotopy_hom_inv_id\n#align nat_trans.left_derived_eq nat_trans.left_derived_eq\n\n",
 "left_derived_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n-- The `simp_nf` linter times out here, so we disable it.\n@[simp, nolint simp_nf]\ntheorem nat_trans.left_derived_comp {F G H : «expr ⥤ » C D} [F.additive] [G.additive] [H.additive] (α : «expr ⟶ » F G)\n    (β : «expr ⟶ » G H) (n : ℕ) :\n    NatTrans.leftDerived («expr ≫ » α β) n = «expr ≫ » (NatTrans.leftDerived α n) (NatTrans.leftDerived β n) := by\n  simp [nat_trans.left_derived]\n#align nat_trans.left_derived_comp nat_trans.left_derived_comp\n\n"}