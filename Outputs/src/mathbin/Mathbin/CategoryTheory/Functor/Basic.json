{"to_prefunctor_obj":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n@[simp]\ntheorem to_prefunctor_obj (F : «expr ⥤ » C D) (X : C) : F.to_prefunctor.obj X = F.obj X :=\n  rfl\n#align to_prefunctor_obj to_prefunctor_obj\n\n",
 "to_prefunctor_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n@[simp]\ntheorem to_prefunctor_map (F : «expr ⥤ » C D) {X Y : C} (f : «expr ⟶ » X Y) : F.to_prefunctor.map f = F.map f :=\n  rfl\n#align to_prefunctor_map to_prefunctor_map\n\n",
 "to_prefunctor_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n@[simp]\ntheorem to_prefunctor_comp (F : «expr ⥤ » C D) (G : «expr ⥤ » D E) :\n    F.to_prefunctor.comp G.to_prefunctor = («expr ⋙ » F G).to_prefunctor :=\n  rfl\n#align to_prefunctor_comp to_prefunctor_comp\n\n",
 "map_dite":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n@[simp]\ntheorem map_dite (F : «expr ⥤ » C D) {X Y : C} {P : Prop} [decidable P] (f : P → «expr ⟶ » X Y)\n    (g : ¬P → «expr ⟶ » X Y) : F.map (if h : P then f h else g h) = if h : P then F.map (f h) else F.map (g h) := by\n  split_ifs <;> rfl\n#align map_dite map_dite\n\n",
 "id_obj":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟭» -/\n/-\nCopyright (c) 2017 Scott Morrison. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Tim Baumann, Stephen Morgan, Scott Morrison\n-/\n-- declare the `v`'s first; see `category_theory.category` for an explanation\n-- A functor is basically a function, so give ⥤ a similar precedence to → (25).\n-- For example, `C × D ⥤ E` should parse as `(C × D) ⥤ E` not `C × (D ⥤ E)`.\n-- type as \\func --\n-- We don't use `@[simps]` here because we want `C` implicit for the simp lemmas.\n-- Type this as `\\sb1`\n@[simp]\ntheorem id_obj (X : C) : ((«expr𝟭») C).obj X = X :=\n  rfl\n#align id_obj id_obj\n\n",
 "id_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟭» -/\n@[simp]\ntheorem id_map {X Y : C} (f : «expr ⟶ » X Y) : ((«expr𝟭») C).map f = f :=\n  rfl\n#align id_map id_map\n\n",
 "id_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟭» -/\nprotected theorem id_comp (F : «expr ⥤ » C D) : «expr ⋙ » ((«expr𝟭») C) F = F := by cases F <;> rfl\n#align id_comp id_comp\n\n",
 "comp_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n@[simp]\ntheorem comp_map (F : «expr ⥤ » C D) (G : «expr ⥤ » D E) {X Y : C} (f : «expr ⟶ » X Y) :\n    («expr ⋙ » F G).map f = G.map (F.map f) :=\n  rfl\n#align comp_map comp_map\n\n",
 "comp_id":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟭» -/\n-- These are not simp lemmas because rewriting along equalities between functors\n-- is not necessarily a good idea.\n-- Natural isomorphisms are also provided in `whiskering.lean`.\nprotected theorem comp_id (F : «expr ⥤ » C D) : «expr ⋙ » F ((«expr𝟭») D) = F := by cases F <;> rfl\n#align comp_id comp_id\n\n"}