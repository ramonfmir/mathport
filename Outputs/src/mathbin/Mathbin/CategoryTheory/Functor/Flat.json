{"uniq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‹™ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‹™ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‹™ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‹™ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‹™ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\ntheorem uniq {K : Â«expr â¥¤ Â» J C} {c : Cone K} (hc : IsLimit c) (s : Cone (Â«expr â‹™ Â» K F))\n    (fâ‚ fâ‚‚ : Â«expr âŸ¶ Â» s.X (F.obj c.X)) (hâ‚ : âˆ€ j : J, Â«expr â‰« Â» fâ‚ ((F.map_cone c).Ï€.app j) = s.Ï€.app j)\n    (hâ‚‚ : âˆ€ j : J, Â«expr â‰« Â» fâ‚‚ ((F.map_cone c).Ï€.app j) = s.Ï€.app j) : fâ‚ = fâ‚‚ :=\n  by\n  -- We can make two cones over the diagram of `s` via `fâ‚` and `fâ‚‚`.\n  let Î±â‚ : Â«expr âŸ¶ Â» (Â«expr â‹™ Â» (to_diagram (F.map_cone c)) (map fâ‚)) (to_diagram s) :=\n    { app := fun X => eq_to_hom (by simp [â† hâ‚])\n      naturality' := fun _ _ _ => by\n        ext\n        simp }\n  let Î±â‚‚ : Â«expr âŸ¶ Â» (Â«expr â‹™ Â» (to_diagram (F.map_cone c)) (map fâ‚‚)) (to_diagram s) :=\n    { app := fun X => eq_to_hom (by simp [â† hâ‚‚])\n      naturality' := fun _ _ _ => by\n        ext\n        simp }\n  let câ‚ : cone (Â«expr â‹™ Â» (to_diagram s) (pre s.X K F)) :=\n    (cones.postcompose (whisker_right Î±â‚ (pre s.X K F) : _)).obj (to_cone F c fâ‚)\n  let câ‚‚ : cone (Â«expr â‹™ Â» (to_diagram s) (pre s.X K F)) :=\n    (cones.postcompose (whisker_right Î±â‚‚ (pre s.X K F) : _)).obj (to_cone F c fâ‚‚)\n  -- The two cones can then be combined and we may obtain a cone over the two cones since\n  -- `structured_arrow s.X F` is cofiltered.\n  let câ‚€ := is_cofiltered.cone (bicone_mk _ câ‚ câ‚‚)\n  let gâ‚ : Â«expr âŸ¶ Â» câ‚€.X câ‚.X := câ‚€.Ï€.app bicone.left\n  let gâ‚‚ : Â«expr âŸ¶ Â» câ‚€.X câ‚‚.X := câ‚€.Ï€.app bicone.right\n  -- Then `gâ‚.right` and `gâ‚‚.right` are two maps from the same cone into the `c`.\n  have : âˆ€ j : J, Â«expr â‰« Â» gâ‚.right (c.Ï€.app j) = Â«expr â‰« Â» gâ‚‚.right (c.Ï€.app j) :=\n    by\n    intro j\n    injection câ‚€.Ï€.naturality (bicone_hom.left j) with _ eâ‚\n    injection câ‚€.Ï€.naturality (bicone_hom.right j) with _ eâ‚‚\n    simpa using eâ‚.symm.trans eâ‚‚\n  have : c.extend gâ‚.right = c.extend gâ‚‚.right := by\n    unfold cone.extend\n    congr 1\n    ext x\n    apply this\n  -- And thus they are equal as `c` is the limit.\n  have : gâ‚.right = gâ‚‚.right\n  calc\n    gâ‚.right = hc.lift (c.extend gâ‚.right) := by\n      apply hc.uniq (c.extend _)\n      tidy\n    _ = hc.lift (c.extend gâ‚‚.right) := by\n      congr\n      exact this\n    _ = gâ‚‚.right := by\n      symm\n      apply hc.uniq (c.extend _)\n      tidy\n    \n  -- Finally, since `fáµ¢` factors through `F(gáµ¢)`, the result follows.\n  calc\n    fâ‚ = Â«expr â‰« Â» ((Â«exprğŸ™Â») _) fâ‚ := by simp\n    _ = Â«expr â‰« Â» câ‚€.X.hom (F.map gâ‚.right) := gâ‚.w\n    _ = Â«expr â‰« Â» câ‚€.X.hom (F.map gâ‚‚.right) := by rw [this]\n    _ = Â«expr â‰« Â» ((Â«exprğŸ™Â») _) fâ‚‚ := gâ‚‚.w.symm\n    _ = fâ‚‚ := by simp\n    \n#align uniq uniq\n\n",
 "flat_of_preserves_finite_limits":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\ntheorem flat_of_preserves_finite_limits [HasFiniteLimits C] (F : Â«expr â¥¤ Â» C D) [PreservesFiniteLimits F] :\n    RepresentablyFlat F :=\n  âŸ¨fun X =>\n    haveI : has_finite_limits (structured_arrow X F) :=\n      by\n      apply hasFiniteLimits_of_hasFiniteLimits_of_size.{vâ‚} (structured_arrow X F)\n      intro J sJ fJ; skip; constructor\n    cofiltered_of_has_finite_limitsâŸ©\n#align flat_of_preserves_finite_limits flat_of_preserves_finite_limits\n\n",
 "flat_iff_Lan_flat":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr áµ’áµ–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr áµ’áµ–Â» -/\ntheorem flat_iff_Lan_flat (F : Â«expr â¥¤ Â» C D) :\n    RepresentablyFlat F â†” RepresentablyFlat (lan F.op : Â«expr â¥¤ Â» _ (Â«expr â¥¤ Â» (Â«expr áµ’áµ–Â» D) (Type uâ‚))) :=\n  âŸ¨fun H => inferInstance, fun H => by\n    skip\n    haveI := preserves_finite_limits_of_flat (Lan F.op : Â«expr â¥¤ Â» _ (Â«expr â¥¤ Â» (Â«expr áµ’áµ–Â» D) (Type uâ‚)))\n    haveI : preserves_finite_limits F :=\n      by\n      apply preservesFiniteLimitsOfPreservesFiniteLimitsOfSize.{uâ‚}\n      intros ; skip; apply preserves_limit_of_Lan_preserves_limit\n    apply flat_of_preserves_finite_limitsâŸ©\n#align flat_iff_Lan_flat flat_iff_Lan_flat\n\n",
 "fac":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\ntheorem fac (x : J) : Â«expr â‰« Â» (lift F hc s) ((F.map_cone c).Ï€.app x) = s.Ï€.app x := by\n  simpa [lift, â† functor.map_comp]\n#align fac fac\n\n",
 "cofiltered_of_has_finite_limits":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤_ Â» -/\n/-\nCopyright (c) 2021 Andrew Yang. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Andrew Yang\n-/\ntheorem cofiltered_of_has_finite_limits [HasFiniteLimits C] : IsCofiltered C :=\n  { cone_objs := fun A B => âŸ¨Limits.prod A B, Limits.prod.fst, Limits.prod.snd, trivialâŸ©\n    cone_maps := fun A B f g => âŸ¨equalizer f g, equalizer.Î¹ f g, equalizer.condition f gâŸ©\n    nonempty := âŸ¨Â«exprâŠ¤_ Â» CâŸ© }\n#align cofiltered_of_has_finite_limits cofiltered_of_has_finite_limits\n\n"}