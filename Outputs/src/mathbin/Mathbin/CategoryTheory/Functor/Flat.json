{"uniq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem uniq {K : «expr ⥤ » J C} {c : Cone K} (hc : IsLimit c) (s : Cone («expr ⋙ » K F))\n    (f₁ f₂ : «expr ⟶ » s.X (F.obj c.X)) (h₁ : ∀ j : J, «expr ≫ » f₁ ((F.map_cone c).π.app j) = s.π.app j)\n    (h₂ : ∀ j : J, «expr ≫ » f₂ ((F.map_cone c).π.app j) = s.π.app j) : f₁ = f₂ :=\n  by\n  -- We can make two cones over the diagram of `s` via `f₁` and `f₂`.\n  let α₁ : «expr ⟶ » («expr ⋙ » (to_diagram (F.map_cone c)) (map f₁)) (to_diagram s) :=\n    { app := fun X => eq_to_hom (by simp [← h₁])\n      naturality' := fun _ _ _ => by\n        ext\n        simp }\n  let α₂ : «expr ⟶ » («expr ⋙ » (to_diagram (F.map_cone c)) (map f₂)) (to_diagram s) :=\n    { app := fun X => eq_to_hom (by simp [← h₂])\n      naturality' := fun _ _ _ => by\n        ext\n        simp }\n  let c₁ : cone («expr ⋙ » (to_diagram s) (pre s.X K F)) :=\n    (cones.postcompose (whisker_right α₁ (pre s.X K F) : _)).obj (to_cone F c f₁)\n  let c₂ : cone («expr ⋙ » (to_diagram s) (pre s.X K F)) :=\n    (cones.postcompose (whisker_right α₂ (pre s.X K F) : _)).obj (to_cone F c f₂)\n  -- The two cones can then be combined and we may obtain a cone over the two cones since\n  -- `structured_arrow s.X F` is cofiltered.\n  let c₀ := is_cofiltered.cone (bicone_mk _ c₁ c₂)\n  let g₁ : «expr ⟶ » c₀.X c₁.X := c₀.π.app bicone.left\n  let g₂ : «expr ⟶ » c₀.X c₂.X := c₀.π.app bicone.right\n  -- Then `g₁.right` and `g₂.right` are two maps from the same cone into the `c`.\n  have : ∀ j : J, «expr ≫ » g₁.right (c.π.app j) = «expr ≫ » g₂.right (c.π.app j) :=\n    by\n    intro j\n    injection c₀.π.naturality (bicone_hom.left j) with _ e₁\n    injection c₀.π.naturality (bicone_hom.right j) with _ e₂\n    simpa using e₁.symm.trans e₂\n  have : c.extend g₁.right = c.extend g₂.right := by\n    unfold cone.extend\n    congr 1\n    ext x\n    apply this\n  -- And thus they are equal as `c` is the limit.\n  have : g₁.right = g₂.right\n  calc\n    g₁.right = hc.lift (c.extend g₁.right) := by\n      apply hc.uniq (c.extend _)\n      tidy\n    _ = hc.lift (c.extend g₂.right) := by\n      congr\n      exact this\n    _ = g₂.right := by\n      symm\n      apply hc.uniq (c.extend _)\n      tidy\n    \n  -- Finally, since `fᵢ` factors through `F(gᵢ)`, the result follows.\n  calc\n    f₁ = «expr ≫ » ((«expr𝟙») _) f₁ := by simp\n    _ = «expr ≫ » c₀.X.hom (F.map g₁.right) := g₁.w\n    _ = «expr ≫ » c₀.X.hom (F.map g₂.right) := by rw [this]\n    _ = «expr ≫ » ((«expr𝟙») _) f₂ := g₂.w.symm\n    _ = f₂ := by simp\n    \n#align uniq uniq\n\n",
 "flat_of_preserves_finite_limits":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\ntheorem flat_of_preserves_finite_limits [HasFiniteLimits C] (F : «expr ⥤ » C D) [PreservesFiniteLimits F] :\n    RepresentablyFlat F :=\n  ⟨fun X =>\n    haveI : has_finite_limits (structured_arrow X F) :=\n      by\n      apply hasFiniteLimits_of_hasFiniteLimits_of_size.{v₁} (structured_arrow X F)\n      intro J sJ fJ; skip; constructor\n    cofiltered_of_has_finite_limits⟩\n#align flat_of_preserves_finite_limits flat_of_preserves_finite_limits\n\n",
 "flat_iff_Lan_flat":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵖ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵖ» -/\ntheorem flat_iff_Lan_flat (F : «expr ⥤ » C D) :\n    RepresentablyFlat F ↔ RepresentablyFlat (lan F.op : «expr ⥤ » _ («expr ⥤ » («expr ᵒᵖ» D) (Type u₁))) :=\n  ⟨fun H => inferInstance, fun H => by\n    skip\n    haveI := preserves_finite_limits_of_flat (Lan F.op : «expr ⥤ » _ («expr ⥤ » («expr ᵒᵖ» D) (Type u₁)))\n    haveI : preserves_finite_limits F :=\n      by\n      apply preservesFiniteLimitsOfPreservesFiniteLimitsOfSize.{u₁}\n      intros ; skip; apply preserves_limit_of_Lan_preserves_limit\n    apply flat_of_preserves_finite_limits⟩\n#align flat_iff_Lan_flat flat_iff_Lan_flat\n\n",
 "fac":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem fac (x : J) : «expr ≫ » (lift F hc s) ((F.map_cone c).π.app x) = s.π.app x := by\n  simpa [lift, ← functor.map_comp]\n#align fac fac\n\n",
 "cofiltered_of_has_finite_limits":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤_ » -/\n/-\nCopyright (c) 2021 Andrew Yang. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Andrew Yang\n-/\ntheorem cofiltered_of_has_finite_limits [HasFiniteLimits C] : IsCofiltered C :=\n  { cone_objs := fun A B => ⟨Limits.prod A B, Limits.prod.fst, Limits.prod.snd, trivial⟩\n    cone_maps := fun A B f g => ⟨equalizer f g, equalizer.ι f g, equalizer.condition f g⟩\n    nonempty := ⟨«expr⊤_ » C⟩ }\n#align cofiltered_of_has_finite_limits cofiltered_of_has_finite_limits\n\n"}