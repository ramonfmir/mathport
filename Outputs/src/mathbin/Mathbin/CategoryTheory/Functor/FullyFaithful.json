{"preimage_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n@[simp]\ntheorem preimage_map (f : «expr ⟶ » X Y) : F.preimage (F.map f) = f :=\n  F.map_injective (by simp)\n#align preimage_map preimage_map\n\n",
 "preimage_iso_map_iso":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≅ » -/\n@[simp]\ntheorem preimage_iso_map_iso (f : «expr ≅ » X Y) : F.preimage_iso (F.map_iso f) = f :=\n  by\n  ext\n  simp\n#align preimage_iso_map_iso preimage_iso_map_iso\n\n",
 "preimage_id":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n@[simp]\ntheorem preimage_id : F.preimage ((«expr𝟙») (F.obj X)) = («expr𝟙») X :=\n  F.map_injective (by simp)\n#align preimage_id preimage_id\n\n",
 "preimage_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp]\ntheorem preimage_comp (f : «expr ⟶ » (F.obj X) (F.obj Y)) (g : «expr ⟶ » (F.obj Y) (F.obj Z)) :\n    F.preimage («expr ≫ » f g) = «expr ≫ » (F.preimage f) (F.preimage g) :=\n  F.map_injective (by simp)\n#align preimage_comp preimage_comp\n\n",
 "of_iso":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≅ » -/\ntheorem faithful.of_iso [Faithful F] (α : «expr ≅ » F F') : Faithful F' :=\n  {\n    map_injective' := fun X Y f f' h =>\n      F.map_injective (by rw [← nat_iso.naturality_1 α.symm, h, nat_iso.naturality_1 α.symm]) }\n#align faithful.of_iso faithful.of_iso\n\n",
 "of_comp_iso":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≅ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\ntheorem faithful.of_comp_iso {H : «expr ⥤ » C E} [ℋ : Faithful H] (h : «expr ≅ » («expr ⋙ » F G) H) : Faithful F :=\n  @Faithful.of_comp _ _ _ _ _ _ F G (Faithful.of_iso h.symm)\n#align faithful.of_comp_iso faithful.of_comp_iso\n\n",
 "of_comp_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n-- We could prove this from `faithful.of_comp_iso` using `eq_to_iso`,\n-- but that would introduce a cyclic import.\ntheorem faithful.of_comp_eq {H : «expr ⥤ » C E} [ℋ : Faithful H] (h : «expr ⋙ » F G = H) : Faithful F :=\n  @Faithful.of_comp _ _ _ _ _ _ F G (h.symm ▸ ℋ)\n#align faithful.of_comp_eq faithful.of_comp_eq\n\n",
 "of_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\ntheorem faithful.of_comp [Faithful <| «expr ⋙ » F G] : Faithful F :=\n  { map_injective' := fun X Y => («expr ⋙ » F G).map_injective.of_comp }\n#align faithful.of_comp faithful.of_comp\n\n",
 "nat_iso_of_comp_fully_faithful_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≅ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\ntheorem nat_iso_of_comp_fully_faithful_inv (i : «expr ≅ » («expr ⋙ » F H) («expr ⋙ » G H)) :\n    (natIsoOfCompFullyFaithful H i).inv = natTransOfCompFullyFaithful H i.inv :=\n  by\n  ext\n  simp [← preimage_comp]\n  dsimp\n  simp\n#align nat_iso_of_comp_fully_faithful_inv nat_iso_of_comp_fully_faithful_inv\n\n",
 "nat_iso_of_comp_fully_faithful_hom":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≅ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\ntheorem nat_iso_of_comp_fully_faithful_hom (i : «expr ≅ » («expr ⋙ » F H) («expr ⋙ » G H)) :\n    (natIsoOfCompFullyFaithful H i).hom = natTransOfCompFullyFaithful H i.hom :=\n  by\n  ext\n  simp [nat_iso_of_comp_fully_faithful]\n#align nat_iso_of_comp_fully_faithful_hom nat_iso_of_comp_fully_faithful_hom\n\n",
 "map_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\ntheorem map_surjective (F : «expr ⥤ » C D) [Full F] : function.surjective (@functor.map _ _ _ _ F X Y) := fun f =>\n  ⟨F.preimage f, F.image_preimage f⟩\n#align map_surjective map_surjective\n\n",
 "map_iso_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\ntheorem map_iso_injective (F : «expr ⥤ » C D) [Faithful F] : function.injective <| @Functor.mapIso _ _ _ _ F X Y :=\n  fun i j h => Iso.ext (map_injective F (congr_arg Iso.hom h : _))\n#align map_iso_injective map_iso_injective\n\n",
 "map_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/-\nCopyright (c) 2018 Scott Morrison. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Scott Morrison\n-/\n-- declare the `v`'s first; see `category_theory.category` for an explanation\ntheorem map_injective (F : «expr ⥤ » C D) [Faithful F] : function.injective <| @functor.map _ _ _ _ F X Y :=\n  Faithful.map_injective F\n#align map_injective map_injective\n\n",
 "is_iso_of_fully_faithful":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/-- If the image of a morphism under a fully faithful functor in an isomorphism,\nthen the original morphisms is also an isomorphism.\n-/\ntheorem is_iso_of_fully_faithful (f : «expr ⟶ » X Y) [IsIso (F.map f)] : IsIso f :=\n  ⟨⟨F.preimage (inv (F.map f)), ⟨F.map_injective (by simp), F.map_injective (by simp)⟩⟩⟩\n#align is_iso_of_fully_faithful is_iso_of_fully_faithful\n\n",
 "image_preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n@[simp]\ntheorem image_preimage (F : «expr ⥤ » C D) [Full F] {X Y : C} (f : «expr ⟶ » (F.obj X) (F.obj Y)) :\n    F.map (preimage F f) = f := by unfold preimage <;> obviously\n#align image_preimage image_preimage\n\n",
 "fully_faithful_cancel_right_inv_app":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≅ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n@[simp]\ntheorem fully_faithful_cancel_right_inv_app {F G : «expr ⥤ » C D} {H : «expr ⥤ » D E} [Full H] [Faithful H]\n    (comp_iso : «expr ≅ » («expr ⋙ » F H) («expr ⋙ » G H)) (X : C) :\n    (fullyFaithfulCancelRight H comp_iso).inv.app X = H.preimage (comp_iso.inv.app X) :=\n  rfl\n#align fully_faithful_cancel_right_inv_app fully_faithful_cancel_right_inv_app\n\n",
 "fully_faithful_cancel_right_hom_app":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≅ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n@[simp]\ntheorem fully_faithful_cancel_right_hom_app {F G : «expr ⥤ » C D} {H : «expr ⥤ » D E} [Full H] [Faithful H]\n    (comp_iso : «expr ≅ » («expr ⋙ » F H) («expr ⋙ » G H)) (X : C) :\n    (fullyFaithfulCancelRight H comp_iso).hom.app X = H.preimage (comp_iso.hom.app X) :=\n  rfl\n#align fully_faithful_cancel_right_hom_app fully_faithful_cancel_right_hom_app\n\n",
 "div_faithful":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem faithful.div_faithful (F : «expr ⥤ » C E) [Faithful F] (G : «expr ⥤ » D E) [Faithful G] (obj : C → D)\n    (h_obj : ∀ X, G.obj (obj X) = F.obj X) (map : ∀ {X Y}, «expr ⟶ » X Y → «expr ⟶ » (obj X) (obj Y))\n    (h_map : ∀ {X Y} {f : «expr ⟶ » X Y}, HEq (G.map (map f)) (F.map f)) :\n    Faithful (Faithful.div F G obj @h_obj @map @h_map) :=\n  (Faithful.div_comp F G _ h_obj _ @h_map).faithful_of_comp\n#align faithful.div_faithful faithful.div_faithful\n\n",
 "div_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n-- This follows immediately from `functor.hext` (`functor.hext h_obj @h_map`),\n-- but importing `category_theory.eq_to_hom` causes an import loop:\n-- category_theory.eq_to_hom → category_theory.opposites →\n-- category_theory.equivalence → category_theory.fully_faithful\ntheorem faithful.div_comp (F : «expr ⥤ » C E) [Faithful F] (G : «expr ⥤ » D E) [Faithful G] (obj : C → D)\n    (h_obj : ∀ X, G.obj (obj X) = F.obj X) (map : ∀ {X Y}, «expr ⟶ » X Y → «expr ⟶ » (obj X) (obj Y))\n    (h_map : ∀ {X Y} {f : «expr ⟶ » X Y}, HEq (G.map (map f)) (F.map f)) :\n    «expr ⋙ » (Faithful.div F G obj @h_obj @map @h_map) G = F :=\n  by\n  cases' F with F_obj _ _ _; cases' G with G_obj _ _ _\n  unfold faithful.div Functor.Comp\n  unfold_projs  at h_obj\n  have : F_obj = G_obj ∘ obj := (funext h_obj).symm\n  subst this\n  congr\n  funext\n  exact eq_of_heq h_map\n#align faithful.div_comp faithful.div_comp\n\n"}