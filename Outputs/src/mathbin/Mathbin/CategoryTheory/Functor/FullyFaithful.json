{"preimage_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n@[simp]\ntheorem preimage_map (f : Â«expr âŸ¶ Â» X Y) : F.preimage (F.map f) = f :=\n  F.map_injective (by simp)\n#align preimage_map preimage_map\n\n",
 "preimage_iso_map_iso":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰… Â» -/\n@[simp]\ntheorem preimage_iso_map_iso (f : Â«expr â‰… Â» X Y) : F.preimage_iso (F.map_iso f) = f :=\n  by\n  ext\n  simp\n#align preimage_iso_map_iso preimage_iso_map_iso\n\n",
 "preimage_id":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n@[simp]\ntheorem preimage_id : F.preimage ((Â«exprğŸ™Â») (F.obj X)) = (Â«exprğŸ™Â») X :=\n  F.map_injective (by simp)\n#align preimage_id preimage_id\n\n",
 "preimage_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n@[simp]\ntheorem preimage_comp (f : Â«expr âŸ¶ Â» (F.obj X) (F.obj Y)) (g : Â«expr âŸ¶ Â» (F.obj Y) (F.obj Z)) :\n    F.preimage (Â«expr â‰« Â» f g) = Â«expr â‰« Â» (F.preimage f) (F.preimage g) :=\n  F.map_injective (by simp)\n#align preimage_comp preimage_comp\n\n",
 "of_iso":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰… Â» -/\ntheorem faithful.of_iso [Faithful F] (Î± : Â«expr â‰… Â» F F') : Faithful F' :=\n  {\n    map_injective' := fun X Y f f' h =>\n      F.map_injective (by rw [â† nat_iso.naturality_1 Î±.symm, h, nat_iso.naturality_1 Î±.symm]) }\n#align faithful.of_iso faithful.of_iso\n\n",
 "of_comp_iso":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰… Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‹™ Â» -/\ntheorem faithful.of_comp_iso {H : Â«expr â¥¤ Â» C E} [â„‹ : Faithful H] (h : Â«expr â‰… Â» (Â«expr â‹™ Â» F G) H) : Faithful F :=\n  @Faithful.of_comp _ _ _ _ _ _ F G (Faithful.of_iso h.symm)\n#align faithful.of_comp_iso faithful.of_comp_iso\n\n",
 "of_comp_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‹™ Â» -/\n-- We could prove this from `faithful.of_comp_iso` using `eq_to_iso`,\n-- but that would introduce a cyclic import.\ntheorem faithful.of_comp_eq {H : Â«expr â¥¤ Â» C E} [â„‹ : Faithful H] (h : Â«expr â‹™ Â» F G = H) : Faithful F :=\n  @Faithful.of_comp _ _ _ _ _ _ F G (h.symm â–¸ â„‹)\n#align faithful.of_comp_eq faithful.of_comp_eq\n\n",
 "of_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‹™ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‹™ Â» -/\ntheorem faithful.of_comp [Faithful <| Â«expr â‹™ Â» F G] : Faithful F :=\n  { map_injective' := fun X Y => (Â«expr â‹™ Â» F G).map_injective.of_comp }\n#align faithful.of_comp faithful.of_comp\n\n",
 "nat_iso_of_comp_fully_faithful_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰… Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‹™ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‹™ Â» -/\ntheorem nat_iso_of_comp_fully_faithful_inv (i : Â«expr â‰… Â» (Â«expr â‹™ Â» F H) (Â«expr â‹™ Â» G H)) :\n    (natIsoOfCompFullyFaithful H i).inv = natTransOfCompFullyFaithful H i.inv :=\n  by\n  ext\n  simp [â† preimage_comp]\n  dsimp\n  simp\n#align nat_iso_of_comp_fully_faithful_inv nat_iso_of_comp_fully_faithful_inv\n\n",
 "nat_iso_of_comp_fully_faithful_hom":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰… Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‹™ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‹™ Â» -/\ntheorem nat_iso_of_comp_fully_faithful_hom (i : Â«expr â‰… Â» (Â«expr â‹™ Â» F H) (Â«expr â‹™ Â» G H)) :\n    (natIsoOfCompFullyFaithful H i).hom = natTransOfCompFullyFaithful H i.hom :=\n  by\n  ext\n  simp [nat_iso_of_comp_fully_faithful]\n#align nat_iso_of_comp_fully_faithful_hom nat_iso_of_comp_fully_faithful_hom\n\n",
 "map_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\ntheorem map_surjective (F : Â«expr â¥¤ Â» C D) [Full F] : function.surjective (@functor.map _ _ _ _ F X Y) := fun f =>\n  âŸ¨F.preimage f, F.image_preimage fâŸ©\n#align map_surjective map_surjective\n\n",
 "map_iso_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\ntheorem map_iso_injective (F : Â«expr â¥¤ Â» C D) [Faithful F] : function.injective <| @Functor.mapIso _ _ _ _ F X Y :=\n  fun i j h => Iso.ext (map_injective F (congr_arg Iso.hom h : _))\n#align map_iso_injective map_iso_injective\n\n",
 "map_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/-\nCopyright (c) 2018 Scott Morrison. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Scott Morrison\n-/\n-- declare the `v`'s first; see `category_theory.category` for an explanation\ntheorem map_injective (F : Â«expr â¥¤ Â» C D) [Faithful F] : function.injective <| @functor.map _ _ _ _ F X Y :=\n  Faithful.map_injective F\n#align map_injective map_injective\n\n",
 "is_iso_of_fully_faithful":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/-- If the image of a morphism under a fully faithful functor in an isomorphism,\nthen the original morphisms is also an isomorphism.\n-/\ntheorem is_iso_of_fully_faithful (f : Â«expr âŸ¶ Â» X Y) [IsIso (F.map f)] : IsIso f :=\n  âŸ¨âŸ¨F.preimage (inv (F.map f)), âŸ¨F.map_injective (by simp), F.map_injective (by simp)âŸ©âŸ©âŸ©\n#align is_iso_of_fully_faithful is_iso_of_fully_faithful\n\n",
 "image_preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n@[simp]\ntheorem image_preimage (F : Â«expr â¥¤ Â» C D) [Full F] {X Y : C} (f : Â«expr âŸ¶ Â» (F.obj X) (F.obj Y)) :\n    F.map (preimage F f) = f := by unfold preimage <;> obviously\n#align image_preimage image_preimage\n\n",
 "fully_faithful_cancel_right_inv_app":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰… Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‹™ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‹™ Â» -/\n@[simp]\ntheorem fully_faithful_cancel_right_inv_app {F G : Â«expr â¥¤ Â» C D} {H : Â«expr â¥¤ Â» D E} [Full H] [Faithful H]\n    (comp_iso : Â«expr â‰… Â» (Â«expr â‹™ Â» F H) (Â«expr â‹™ Â» G H)) (X : C) :\n    (fullyFaithfulCancelRight H comp_iso).inv.app X = H.preimage (comp_iso.inv.app X) :=\n  rfl\n#align fully_faithful_cancel_right_inv_app fully_faithful_cancel_right_inv_app\n\n",
 "fully_faithful_cancel_right_hom_app":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰… Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‹™ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‹™ Â» -/\n@[simp]\ntheorem fully_faithful_cancel_right_hom_app {F G : Â«expr â¥¤ Â» C D} {H : Â«expr â¥¤ Â» D E} [Full H] [Faithful H]\n    (comp_iso : Â«expr â‰… Â» (Â«expr â‹™ Â» F H) (Â«expr â‹™ Â» G H)) (X : C) :\n    (fullyFaithfulCancelRight H comp_iso).hom.app X = H.preimage (comp_iso.hom.app X) :=\n  rfl\n#align fully_faithful_cancel_right_hom_app fully_faithful_cancel_right_hom_app\n\n",
 "div_faithful":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem faithful.div_faithful (F : Â«expr â¥¤ Â» C E) [Faithful F] (G : Â«expr â¥¤ Â» D E) [Faithful G] (obj : C â†’ D)\n    (h_obj : âˆ€ X, G.obj (obj X) = F.obj X) (map : âˆ€ {X Y}, Â«expr âŸ¶ Â» X Y â†’ Â«expr âŸ¶ Â» (obj X) (obj Y))\n    (h_map : âˆ€ {X Y} {f : Â«expr âŸ¶ Â» X Y}, HEq (G.map (map f)) (F.map f)) :\n    Faithful (Faithful.div F G obj @h_obj @map @h_map) :=\n  (Faithful.div_comp F G _ h_obj _ @h_map).faithful_of_comp\n#align faithful.div_faithful faithful.div_faithful\n\n",
 "div_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‹™ Â» -/\n-- This follows immediately from `functor.hext` (`functor.hext h_obj @h_map`),\n-- but importing `category_theory.eq_to_hom` causes an import loop:\n-- category_theory.eq_to_hom â†’ category_theory.opposites â†’\n-- category_theory.equivalence â†’ category_theory.fully_faithful\ntheorem faithful.div_comp (F : Â«expr â¥¤ Â» C E) [Faithful F] (G : Â«expr â¥¤ Â» D E) [Faithful G] (obj : C â†’ D)\n    (h_obj : âˆ€ X, G.obj (obj X) = F.obj X) (map : âˆ€ {X Y}, Â«expr âŸ¶ Â» X Y â†’ Â«expr âŸ¶ Â» (obj X) (obj Y))\n    (h_map : âˆ€ {X Y} {f : Â«expr âŸ¶ Â» X Y}, HEq (G.map (map f)) (F.map f)) :\n    Â«expr â‹™ Â» (Faithful.div F G obj @h_obj @map @h_map) G = F :=\n  by\n  cases' F with F_obj _ _ _; cases' G with G_obj _ _ _\n  unfold faithful.div Functor.Comp\n  unfold_projs  at h_obj\n  have : F_obj = G_obj âˆ˜ obj := (funext h_obj).symm\n  subst this\n  congr\n  funext\n  exact eq_of_heq h_map\n#align faithful.div_comp faithful.div_comp\n\n"}