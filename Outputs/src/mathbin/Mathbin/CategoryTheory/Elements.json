{"to_structured_arrow_obj":
 "@[simp]\ntheorem to_structured_arrow_obj (X) :\n    (toStructuredArrow F).obj X =\n      { left := âŸ¨âŸ¨âŸ©âŸ©\n        right := X.1\n        hom := fun _ => X.2 } :=\n  rfl\n#align to_structured_arrow_obj to_structured_arrow_obj\n\n",
 "to_from_costructured_arrow_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprðŸ™Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprðŸ™Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprðŸ™Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr áµ’áµ–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‹™ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprðŸ­Â» -/\n/-- The counit of the equivalence `F.elementsáµ’áµ– â‰… (yoneda, F)` is indeed iso. -/\ntheorem to_from_costructured_arrow_eq (F : Â«expr â¥¤ Â» (Â«expr áµ’áµ–Â» C) (Type v)) :\n    Â«expr â‹™ Â» (fromCostructuredArrow F).right_op (toCostructuredArrow F) = (Â«exprðŸ­Â») _ :=\n  by\n  apply functor.hext\n  Â· intro X\n    cases X\n    cases X_right\n    simp only [functor.id_obj, functor.right_op_obj, to_costructured_arrow_obj, functor.comp_obj, costructured_arrow.mk]\n    congr\n    ext (x f)\n    convert congr_fun (X_hom.naturality f.op).symm ((Â«exprðŸ™Â») X_left)\n    simp only [Quiver.Hom.unop_op, yoneda_obj_map]\n    erw [category.comp_id]\n  intro X Y f\n  rcases X with âŸ¨X_left, âŸ¨âŸ¨âŸ©âŸ©âŸ©; rcases Y with âŸ¨Y_left, âŸ¨âŸ¨âŸ©âŸ©âŸ©; cases f\n  simp [costructured_arrow.hom_mk]\n  delta costructured_arrow.mk\n  congr\n  Â· ext (x f)\n    convert congr_fun (X_hom.naturality f.op).symm ((Â«exprðŸ™Â») X_left)\n    simp only [Quiver.Hom.unop_op, category_theory.yoneda_obj_map]\n    erw [category.comp_id]\n  Â· ext (x f)\n    convert congr_fun (Y_hom.naturality f.op).symm ((Â«exprðŸ™Â») Y_left)\n    simp only [Quiver.Hom.unop_op, category_theory.yoneda_obj_map]\n    erw [category.comp_id]\n  simp\n  exact proof_irrel_heq _ _\n#align to_from_costructured_arrow_eq to_from_costructured_arrow_eq\n\n",
 "to_comma_map_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n@[simp]\ntheorem to_comma_map_right {X Y} (f : Â«expr âŸ¶ Â» X Y) : ((toStructuredArrow F).map f).right = f.val :=\n  rfl\n#align to_comma_map_right to_comma_map_right\n\n",
 "map_Ï€":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‹™ Â» -/\n@[simp]\ntheorem map_Ï€ {Fâ‚ Fâ‚‚ : Â«expr â¥¤ Â» C (Type w)} (Î± : Â«expr âŸ¶ Â» Fâ‚ Fâ‚‚) : Â«expr â‹™ Â» (map Î±) (Ï€ Fâ‚‚) = Ï€ Fâ‚ :=\n  rfl\n#align map_Ï€ map_Ï€\n\n",
 "id_val":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprðŸ™Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprðŸ™Â» -/\n@[simp]\ntheorem id_val {F : Â«expr â¥¤ Â» C (Type w)} {p : F.elements} : ((Â«exprðŸ™Â») p : Â«expr âŸ¶ Â» p p).val = (Â«exprðŸ™Â») p.1 :=\n  rfl\n#align id_val id_val\n\n",
 "from_to_costructured_arrow_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr áµ’áµ–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‹™ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprðŸ­Â» -/\n/-- The unit of the equivalence `F.elementsáµ’áµ– â‰… (yoneda, F)` is indeed iso. -/\ntheorem from_to_costructured_arrow_eq (F : Â«expr â¥¤ Â» (Â«expr áµ’áµ–Â» C) (Type v)) :\n    Â«expr â‹™ Â» (toCostructuredArrow F).right_op (fromCostructuredArrow F) = (Â«exprðŸ­Â») _ :=\n  by\n  apply Functor.ext\n  intro X Y f\n  have :\n    âˆ€ {a b : F.elements} (H : a = b),\n      â†‘(eq_to_hom H) =\n        eq_to_hom\n          (show a.fst = b.fst by\n            cases H\n            rfl) :=\n    fun _ _ H => by\n    cases H\n    rfl\n  ext; simp [this]\n  tidy\n#align from_to_costructured_arrow_eq from_to_costructured_arrow_eq\n\n",
 "from_structured_arrow_obj":
 "@[simp]\ntheorem from_structured_arrow_obj (X) : (fromStructuredArrow F).obj X = âŸ¨X.right, X.hom PUnit.unitâŸ© :=\n  rfl\n#align from_structured_arrow_obj from_structured_arrow_obj\n\n",
 "from_structured_arrow_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n@[simp]\ntheorem from_structured_arrow_map {X Y} (f : Â«expr âŸ¶ Â» X Y) :\n    (fromStructuredArrow F).map f = âŸ¨f.right, congr_fun f.w'.symm PUnit.unitâŸ© :=\n  rfl\n#align from_structured_arrow_map from_structured_arrow_map\n\n",
 "from_costructured_arrow_obj_mk":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr áµ’áµ–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n@[simp]\ntheorem from_costructured_arrow_obj_mk (F : Â«expr â¥¤ Â» (Â«expr áµ’áµ–Â» C) (Type v)) {X : C} (f : Â«expr âŸ¶ Â» (yoneda.obj X) F) :\n    (fromCostructuredArrow F).obj (op (CostructuredArrow.mk f)) = âŸ¨op X, yonedaEquiv.1 fâŸ© :=\n  rfl\n#align from_costructured_arrow_obj_mk from_costructured_arrow_obj_mk\n\n",
 "ext":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/-\nCopyright (c) 2019 Scott Morrison. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Scott Morrison\n-/\n@[ext]\ntheorem ext (F : Â«expr â¥¤ Â» C (Type w)) {x y : F.elements} (f g : Â«expr âŸ¶ Â» x y) (w : f.val = g.val) : f = g :=\n  Subtype.ext_val w\n#align ext ext\n\n",
 "costructured_arrow_yoneda_equivalence_naturality":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr áµ’áµ–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr áµ’áµ–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‹™ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‹™ Â» -/\n/-- The equivalence `(-.elements)áµ’áµ– â‰… (yoneda, -)` of is actually a natural isomorphism of functors.\n-/\ntheorem costructured_arrow_yoneda_equivalence_naturality {Fâ‚ Fâ‚‚ : Â«expr â¥¤ Â» (Â«expr áµ’áµ–Â» C) (Type v)}\n    (Î± : Â«expr âŸ¶ Â» Fâ‚ Fâ‚‚) :\n    Â«expr â‹™ Â» (map Î±).op (toCostructuredArrow Fâ‚‚) = Â«expr â‹™ Â» (toCostructuredArrow Fâ‚) (CostructuredArrow.map Î±) :=\n  by\n  fapply Functor.ext\n  Â· intro X\n    simp only [costructured_arrow.map_mk, to_costructured_arrow_obj, functor.op_obj, functor.comp_obj]\n    congr\n    ext (x f)\n    simpa using congr_fun (Î±.naturality f.op).symm (unop X).snd\n  Â· intro X Y f\n    ext\n    have :\n      âˆ€ {F : Â«expr â¥¤ Â» (Â«expr áµ’áµ–Â» C) (Type v)} {a b : costructured_arrow yoneda F} (H : a = b),\n        comma_morphism.left (eq_to_hom H) =\n          eq_to_hom\n            (show a.left = b.left by\n              cases H\n              rfl) :=\n      fun _ _ _ H => by\n      cases H\n      rfl\n    simp [this]\n#align costructured_arrow_yoneda_equivalence_naturality costructured_arrow_yoneda_equivalence_naturality\n\n",
 "comp_val":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n@[simp]\ntheorem comp_val {F : Â«expr â¥¤ Â» C (Type w)} {p q r : F.elements} {f : Â«expr âŸ¶ Â» p q} {g : Â«expr âŸ¶ Â» q r} :\n    (Â«expr â‰« Â» f g).val = Â«expr â‰« Â» f.val g.val :=\n  rfl\n#align comp_val comp_val\n\n"}