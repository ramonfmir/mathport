{"to_structured_arrow_obj":
 "@[simp]\ntheorem to_structured_arrow_obj (X) :\n    (toStructuredArrow F).obj X =\n      { left := ⟨⟨⟩⟩\n        right := X.1\n        hom := fun _ => X.2 } :=\n  rfl\n#align to_structured_arrow_obj to_structured_arrow_obj\n\n",
 "to_from_costructured_arrow_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵖ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟭» -/\n/-- The counit of the equivalence `F.elementsᵒᵖ ≅ (yoneda, F)` is indeed iso. -/\ntheorem to_from_costructured_arrow_eq (F : «expr ⥤ » («expr ᵒᵖ» C) (Type v)) :\n    «expr ⋙ » (fromCostructuredArrow F).right_op (toCostructuredArrow F) = («expr𝟭») _ :=\n  by\n  apply functor.hext\n  · intro X\n    cases X\n    cases X_right\n    simp only [functor.id_obj, functor.right_op_obj, to_costructured_arrow_obj, functor.comp_obj, costructured_arrow.mk]\n    congr\n    ext (x f)\n    convert congr_fun (X_hom.naturality f.op).symm ((«expr𝟙») X_left)\n    simp only [Quiver.Hom.unop_op, yoneda_obj_map]\n    erw [category.comp_id]\n  intro X Y f\n  rcases X with ⟨X_left, ⟨⟨⟩⟩⟩; rcases Y with ⟨Y_left, ⟨⟨⟩⟩⟩; cases f\n  simp [costructured_arrow.hom_mk]\n  delta costructured_arrow.mk\n  congr\n  · ext (x f)\n    convert congr_fun (X_hom.naturality f.op).symm ((«expr𝟙») X_left)\n    simp only [Quiver.Hom.unop_op, category_theory.yoneda_obj_map]\n    erw [category.comp_id]\n  · ext (x f)\n    convert congr_fun (Y_hom.naturality f.op).symm ((«expr𝟙») Y_left)\n    simp only [Quiver.Hom.unop_op, category_theory.yoneda_obj_map]\n    erw [category.comp_id]\n  simp\n  exact proof_irrel_heq _ _\n#align to_from_costructured_arrow_eq to_from_costructured_arrow_eq\n\n",
 "to_comma_map_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n@[simp]\ntheorem to_comma_map_right {X Y} (f : «expr ⟶ » X Y) : ((toStructuredArrow F).map f).right = f.val :=\n  rfl\n#align to_comma_map_right to_comma_map_right\n\n",
 "map_π":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n@[simp]\ntheorem map_π {F₁ F₂ : «expr ⥤ » C (Type w)} (α : «expr ⟶ » F₁ F₂) : «expr ⋙ » (map α) (π F₂) = π F₁ :=\n  rfl\n#align map_π map_π\n\n",
 "id_val":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n@[simp]\ntheorem id_val {F : «expr ⥤ » C (Type w)} {p : F.elements} : ((«expr𝟙») p : «expr ⟶ » p p).val = («expr𝟙») p.1 :=\n  rfl\n#align id_val id_val\n\n",
 "from_to_costructured_arrow_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵖ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟭» -/\n/-- The unit of the equivalence `F.elementsᵒᵖ ≅ (yoneda, F)` is indeed iso. -/\ntheorem from_to_costructured_arrow_eq (F : «expr ⥤ » («expr ᵒᵖ» C) (Type v)) :\n    «expr ⋙ » (toCostructuredArrow F).right_op (fromCostructuredArrow F) = («expr𝟭») _ :=\n  by\n  apply Functor.ext\n  intro X Y f\n  have :\n    ∀ {a b : F.elements} (H : a = b),\n      ↑(eq_to_hom H) =\n        eq_to_hom\n          (show a.fst = b.fst by\n            cases H\n            rfl) :=\n    fun _ _ H => by\n    cases H\n    rfl\n  ext; simp [this]\n  tidy\n#align from_to_costructured_arrow_eq from_to_costructured_arrow_eq\n\n",
 "from_structured_arrow_obj":
 "@[simp]\ntheorem from_structured_arrow_obj (X) : (fromStructuredArrow F).obj X = ⟨X.right, X.hom PUnit.unit⟩ :=\n  rfl\n#align from_structured_arrow_obj from_structured_arrow_obj\n\n",
 "from_structured_arrow_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n@[simp]\ntheorem from_structured_arrow_map {X Y} (f : «expr ⟶ » X Y) :\n    (fromStructuredArrow F).map f = ⟨f.right, congr_fun f.w'.symm PUnit.unit⟩ :=\n  rfl\n#align from_structured_arrow_map from_structured_arrow_map\n\n",
 "from_costructured_arrow_obj_mk":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵖ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n@[simp]\ntheorem from_costructured_arrow_obj_mk (F : «expr ⥤ » («expr ᵒᵖ» C) (Type v)) {X : C} (f : «expr ⟶ » (yoneda.obj X) F) :\n    (fromCostructuredArrow F).obj (op (CostructuredArrow.mk f)) = ⟨op X, yonedaEquiv.1 f⟩ :=\n  rfl\n#align from_costructured_arrow_obj_mk from_costructured_arrow_obj_mk\n\n",
 "ext":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/-\nCopyright (c) 2019 Scott Morrison. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Scott Morrison\n-/\n@[ext]\ntheorem ext (F : «expr ⥤ » C (Type w)) {x y : F.elements} (f g : «expr ⟶ » x y) (w : f.val = g.val) : f = g :=\n  Subtype.ext_val w\n#align ext ext\n\n",
 "costructured_arrow_yoneda_equivalence_naturality":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵖ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵖ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/-- The equivalence `(-.elements)ᵒᵖ ≅ (yoneda, -)` of is actually a natural isomorphism of functors.\n-/\ntheorem costructured_arrow_yoneda_equivalence_naturality {F₁ F₂ : «expr ⥤ » («expr ᵒᵖ» C) (Type v)}\n    (α : «expr ⟶ » F₁ F₂) :\n    «expr ⋙ » (map α).op (toCostructuredArrow F₂) = «expr ⋙ » (toCostructuredArrow F₁) (CostructuredArrow.map α) :=\n  by\n  fapply Functor.ext\n  · intro X\n    simp only [costructured_arrow.map_mk, to_costructured_arrow_obj, functor.op_obj, functor.comp_obj]\n    congr\n    ext (x f)\n    simpa using congr_fun (α.naturality f.op).symm (unop X).snd\n  · intro X Y f\n    ext\n    have :\n      ∀ {F : «expr ⥤ » («expr ᵒᵖ» C) (Type v)} {a b : costructured_arrow yoneda F} (H : a = b),\n        comma_morphism.left (eq_to_hom H) =\n          eq_to_hom\n            (show a.left = b.left by\n              cases H\n              rfl) :=\n      fun _ _ _ H => by\n      cases H\n      rfl\n    simp [this]\n#align costructured_arrow_yoneda_equivalence_naturality costructured_arrow_yoneda_equivalence_naturality\n\n",
 "comp_val":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp]\ntheorem comp_val {F : «expr ⥤ » C (Type w)} {p q r : F.elements} {f : «expr ⟶ » p q} {g : «expr ⟶ » q r} :\n    («expr ≫ » f g).val = «expr ≫ » f.val g.val :=\n  rfl\n#align comp_val comp_val\n\n"}