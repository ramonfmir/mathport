{"precomp_map_heq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\ntheorem precomp_map_heq (H : «expr ⥤ » E C) (hmap : ∀ {X Y} (f : «expr ⟶ » X Y), HEq (F.map f) (G.map f)) {X Y : E}\n    (f : «expr ⟶ » X Y) : HEq ((«expr ⋙ » H F).map f) ((«expr ⋙ » H G).map f) :=\n  hmap _\n#align precomp_map_heq precomp_map_heq\n\n",
 "postcomp_map_heq'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\ntheorem postcomp_map_heq' (H : «expr ⥤ » D E) (hobj : ∀ X : C, F.obj X = G.obj X)\n    (hmap : ∀ {X Y} (f : «expr ⟶ » X Y), HEq (F.map f) (G.map f)) :\n    HEq ((«expr ⋙ » F H).map f) ((«expr ⋙ » G H).map f) := by rw [functor.hext hobj fun _ _ => hmap]\n#align postcomp_map_heq' postcomp_map_heq'\n\n",
 "postcomp_map_heq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\ntheorem postcomp_map_heq (H : «expr ⥤ » D E) (hx : F.obj X = G.obj X) (hy : F.obj Y = G.obj Y)\n    (hmap : HEq (F.map f) (G.map f)) : HEq ((«expr ⋙ » F H).map f) ((«expr ⋙ » G H).map f) :=\n  by\n  dsimp\n  congr\n#align postcomp_map_heq postcomp_map_heq\n\n",
 "map_comp_heq'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem map_comp_heq' (hobj : ∀ X : C, F.obj X = G.obj X)\n    (hmap : ∀ {X Y} (f : «expr ⟶ » X Y), HEq (F.map f) (G.map f)) :\n    HEq (F.map («expr ≫ » f g)) (G.map («expr ≫ » f g)) := by rw [functor.hext hobj fun _ _ => hmap]\n#align map_comp_heq' map_comp_heq'\n\n",
 "map_comp_heq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n-- Composition of functors and maps w.r.t. heq\ntheorem map_comp_heq (hx : F.obj X = G.obj X) (hy : F.obj Y = G.obj Y) (hz : F.obj Z = G.obj Z)\n    (hf : HEq (F.map f) (G.map f)) (hg : HEq (F.map g) (G.map g)) :\n    HEq (F.map («expr ≫ » f g)) (G.map («expr ≫ » f g)) :=\n  by\n  rw [F.map_comp, G.map_comp]\n  congr\n#align map_comp_heq map_comp_heq\n\n",
 "inv_eq_to_hom":
 "@[simp]\ntheorem inv_eq_to_hom {X Y : C} (h : X = Y) : inv (eqToHom h) = eqToHom h.symm :=\n  by\n  ext\n  simp\n#align inv_eq_to_hom inv_eq_to_hom\n\n",
 "inv":
 "@[simp]\ntheorem eq_to_iso.inv {X Y : C} (p : X = Y) : (eqToIso p).inv = eqToHom p.symm :=\n  rfl\n#align eq_to_iso.inv eq_to_iso.inv\n\n",
 "hom":
 "@[simp]\ntheorem eq_to_iso.hom {X Y : C} (p : X = Y) : (eqToIso p).hom = eqToHom p :=\n  rfl\n#align eq_to_iso.hom eq_to_iso.hom\n\n",
 "hext":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/-- Proving equality between functors using heterogeneous equality. -/\ntheorem hext {F G : «expr ⥤ » C D} (h_obj : ∀ X, F.obj X = G.obj X)\n    (h_map : ∀ (X Y) (f : «expr ⟶ » X Y), HEq (F.map f) (G.map f)) : F = G :=\n  Functor.ext h_obj fun _ _ f => (conj_eqToHom_iff_hEq _ _ (h_obj _) (h_obj _)).2 <| h_map _ _ f\n#align hext hext\n\n",
 "hcongr_hom":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem hcongr_hom {F G : «expr ⥤ » C D} (h : F = G) {X Y} (f : «expr ⟶ » X Y) : HEq (F.map f) (G.map f) := by subst h\n#align hcongr_hom hcongr_hom\n\n",
 "ext":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/-- Proving equality between functors. This isn't an extensionality lemma,\n  because usually you don't really want to do this. -/\ntheorem ext {F G : «expr ⥤ » C D} (h_obj : ∀ X, F.obj X = G.obj X)\n    (h_map : ∀ X Y f, F.map f = «expr ≫ » (eqToHom (h_obj X)) («expr ≫ » (G.map f) (eqToHom (h_obj Y).symm))) : F = G :=\n  by\n  cases' F with F_obj _ _ _\n  cases' G with G_obj _ _ _\n  obtain rfl : F_obj = G_obj := by\n    ext X\n    apply h_obj\n  congr\n  funext X Y f\n  simpa using h_map X Y f\n#align ext ext\n\n",
 "eq_to_iso_trans":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≪≫ » -/\n@[simp]\ntheorem eq_to_iso_trans {X Y Z : C} (p : X = Y) (q : Y = Z) :\n    «expr ≪≫ » (eqToIso p) (eqToIso q) = eqToIso (p.trans q) := by ext <;> simp\n#align eq_to_iso_trans eq_to_iso_trans\n\n",
 "eq_to_iso_refl":
 "@[simp]\ntheorem eq_to_iso_refl {X : C} (p : X = X) : eqToIso p = Iso.refl X :=\n  rfl\n#align eq_to_iso_refl eq_to_iso_refl\n\n",
 "eq_to_iso_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/-- See the note on `eq_to_hom_map` regarding using this as a `simp` lemma.\n-/\ntheorem eq_to_iso_map (F : «expr ⥤ » C D) {X Y : C} (p : X = Y) : F.map_iso (eqToIso p) = eqToIso (congr_arg F.obj p) :=\n  by ext <;> cases p <;> simp\n#align eq_to_iso_map eq_to_iso_map\n\n",
 "eq_to_hom_unop":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵖ» -/\n@[simp]\ntheorem eq_to_hom_unop {X Y : «expr ᵒᵖ» C} (h : X = Y) : (eqToHom h).unop = eqToHom (congr_arg unop h.symm) :=\n  by\n  cases h\n  rfl\n#align eq_to_hom_unop eq_to_hom_unop\n\n",
 "eq_to_hom_trans":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem eq_to_hom_trans {X Y Z : C} (p : X = Y) (q : Y = Z) : «expr ≫ » (eqToHom p) (eqToHom q) = eqToHom (p.trans q) :=\n  by\n  cases p\n  cases q\n  simp\n#align eq_to_hom_trans eq_to_hom_trans\n\n",
 "eq_to_hom_refl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/-\nCopyright (c) 2018 Reid Barton. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Reid Barton, Scott Morrison\n-/\n-- morphism levels before object levels. See note [category_theory universes].\n@[simp]\ntheorem eq_to_hom_refl (X : C) (p : X = X) : eqToHom p = («expr𝟙») X :=\n  rfl\n#align eq_to_hom_refl eq_to_hom_refl\n\n",
 "eq_to_hom_op":
 "@[simp]\ntheorem eq_to_hom_op {X Y : C} (h : X = Y) : (eqToHom h).op = eqToHom (congr_arg op h.symm) :=\n  by\n  cases h\n  rfl\n#align eq_to_hom_op eq_to_hom_op\n\n",
 "eq_to_hom_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/-- This is not always a good idea as a `@[simp]` lemma,\nas we lose the ability to use results that interact with `F`,\ne.g. the naturality of a natural transformation.\n\nIn some files it may be appropriate to use `local attribute [simp] eq_to_hom_map`, however.\n-/\ntheorem eq_to_hom_map (F : «expr ⥤ » C D) {X Y : C} (p : X = Y) : F.map (eqToHom p) = eqToHom (congr_arg F.obj p) := by\n  cases p <;> simp\n#align eq_to_hom_map eq_to_hom_map\n\n",
 "eq_to_hom_comp_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem eq_to_hom_comp_iff {X X' Y : C} (p : X = X') (f : «expr ⟶ » X Y) (g : «expr ⟶ » X' Y) :\n    «expr ≫ » (eqToHom p) g = f ↔ g = «expr ≫ » (eqToHom p.symm) f :=\n  { mp := fun h => h ▸ by simp\n    mpr := fun h => h ▸ by simp [whisker_eq _ h] }\n#align eq_to_hom_comp_iff eq_to_hom_comp_iff\n\n",
 "eq_to_hom_app":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n@[simp]\ntheorem eq_to_hom_app {F G : «expr ⥤ » C D} (h : F = G) (X : C) :\n    (eqToHom h : «expr ⟶ » F G).app X = eqToHom (Functor.congr_obj h X) := by subst h <;> rfl\n#align eq_to_hom_app eq_to_hom_app\n\n",
 "eq_conj_eq_to_hom":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem eq_conj_eq_to_hom {X Y : C} (f : «expr ⟶ » X Y) : f = «expr ≫ » (eqToHom rfl) («expr ≫ » f (eqToHom rfl)) := by\n  simp only [category.id_comp, eq_to_hom_refl, category.comp_id]\n#align eq_conj_eq_to_hom eq_conj_eq_to_hom\n\n",
 "dcongr_arg":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem dcongr_arg {ι : Type _} {F G : ι → C} (α : ∀ i, «expr ⟶ » (F i) (G i)) {i j : ι} (h : i = j) :\n    α i = «expr ≫ » (eqToHom (congr_arg F h)) («expr ≫ » (α j) (eqToHom (congr_arg G h.symm))) :=\n  by\n  subst h\n  simp\n#align dcongr_arg dcongr_arg\n\n",
 "conj_eq_to_hom_iff_heq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/-- Two morphisms are conjugate via eq_to_hom if and only if they are heterogeneously equal. -/\ntheorem conj_eq_to_hom_iff_heq {W X Y Z : C} (f : «expr ⟶ » W X) (g : «expr ⟶ » Y Z) (h : W = Y) (h' : X = Z) :\n    f = «expr ≫ » (eqToHom h) («expr ≫ » g (eqToHom h'.symm)) ↔ HEq f g :=\n  by\n  cases h\n  cases h'\n  simp\n#align conj_eq_to_hom_iff_heq conj_eq_to_hom_iff_heq\n\n",
 "congr_obj":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n-- Using equalities between functors.\ntheorem congr_obj {F G : «expr ⥤ » C D} (h : F = G) (X) : F.obj X = G.obj X := by subst h\n#align congr_obj congr_obj\n\n",
 "congr_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem congr_map (F : «expr ⥤ » C D) {X Y : C} {f g : «expr ⟶ » X Y} (h : f = g) : F.map f = F.map g := by rw [h]\n#align congr_map congr_map\n\n",
 "congr_inv_of_congr_hom":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≅ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem congr_inv_of_congr_hom (F G : «expr ⥤ » C D) {X Y : C} (e : «expr ≅ » X Y) (hX : F.obj X = G.obj X)\n    (hY : F.obj Y = G.obj Y)\n    (h₂ : F.map e.hom = «expr ≫ » (eqToHom (by rw [hX])) («expr ≫ » (G.map e.hom) (eqToHom (by rw [hY])))) :\n    F.map e.inv = «expr ≫ » (eqToHom (by rw [hY])) («expr ≫ » (G.map e.inv) (eqToHom (by rw [hX]))) := by\n  simp only [← is_iso.iso.inv_hom e, functor.map_inv, h₂, is_iso.inv_comp, inv_eq_to_hom, category.assoc]\n#align congr_inv_of_congr_hom congr_inv_of_congr_hom\n\n",
 "congr_hom":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem congr_hom {F G : «expr ⥤ » C D} (h : F = G) {X Y} (f : «expr ⟶ » X Y) :\n    F.map f = «expr ≫ » (eqToHom (congr_obj h X)) («expr ≫ » (G.map f) (eqToHom (congr_obj h Y).symm)) := by\n  subst h <;> simp\n#align congr_hom congr_hom\n\n",
 "congr_arg_mpr_hom_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/-- If we (perhaps unintentionally) perform equational rewriting on\nthe target object of a morphism,\nwe can replace the resulting `_.mpr f` term by a composition with an `eq_to_hom`.\n\nIt may be advisable to introduce any necessary `eq_to_hom` morphisms manually,\nrather than relying on this lemma firing.\n-/\n@[simp]\ntheorem congr_arg_mpr_hom_right {X Y Z : C} (p : «expr ⟶ » X Y) (q : Z = Y) :\n    (congr_arg (fun W : C => «expr ⟶ » X W) q).mpr p = «expr ≫ » p (eqToHom q.symm) :=\n  by\n  cases q\n  simp\n#align congr_arg_mpr_hom_right congr_arg_mpr_hom_right\n\n",
 "congr_arg_mpr_hom_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/-- If we (perhaps unintentionally) perform equational rewriting on\nthe source object of a morphism,\nwe can replace the resulting `_.mpr f` term by a composition with an `eq_to_hom`.\n\nIt may be advisable to introduce any necessary `eq_to_hom` morphisms manually,\nrather than relying on this lemma firing.\n-/\n@[simp]\ntheorem congr_arg_mpr_hom_left {X Y Z : C} (p : X = Y) (q : «expr ⟶ » Y Z) :\n    (congr_arg (fun W : C => «expr ⟶ » W Z) p).mpr q = «expr ≫ » (eqToHom p) q :=\n  by\n  cases p\n  simp\n#align congr_arg_mpr_hom_left congr_arg_mpr_hom_left\n\n",
 "congr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem nat_trans.congr {F G : «expr ⥤ » C D} (α : «expr ⟶ » F G) {X Y : C} (h : X = Y) :\n    α.app X = «expr ≫ » (F.map (eqToHom h)) («expr ≫ » (α.app Y) (G.map (eqToHom h.symm))) :=\n  by\n  rw [α.naturality_assoc]\n  simp [eq_to_hom_map]\n#align nat_trans.congr nat_trans.congr\n\n",
 "comp_eq_to_hom_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem comp_eq_to_hom_iff {X Y Y' : C} (p : Y = Y') (f : «expr ⟶ » X Y) (g : «expr ⟶ » X Y') :\n    «expr ≫ » f (eqToHom p) = g ↔ f = «expr ≫ » g (eqToHom p.symm) :=\n  { mp := fun h => h ▸ by simp\n    mpr := fun h => by simp [eq_whisker h (eq_to_hom p)] }\n#align comp_eq_to_hom_iff comp_eq_to_hom_iff\n\n"}