{"pi_ext":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/-- Two functors to a product category are equal iff they agree on every coordinate. -/\ntheorem pi_ext (f f' : «expr ⥤ » A (∀ i, C i)) (h : ∀ i, «expr ⋙ » f (pi.eval C i) = «expr ⋙ » f' (pi.eval C i)) :\n    f = f' := by\n  apply Functor.ext; swap\n  · intro X\n    ext i\n    specialize h i\n    have := congr_obj h X\n    simpa\n  · intro x y p\n    ext i\n    specialize h i\n    have := congr_hom h p\n    simpa\n#align pi_ext pi_ext\n\n",
 "pi'_eval":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n-- One could add some natural isomorphisms showing\n-- how `functor.pi` commutes with `pi.eval` and `pi.comap`.\n@[simp]\ntheorem pi'_eval (f : ∀ i, «expr ⥤ » A (C i)) (i : I) : «expr ⋙ » (pi' f) (pi.eval C i) = f i :=\n  by\n  apply Functor.ext <;> intros\n  · simp; · rfl\n#align pi'_eval pi'_eval\n\n",
 "iso_app_trans":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≅ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≅ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≪≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≪≫ » -/\n@[simp]\ntheorem iso_app_trans {X Y Z : ∀ i, C i} (f : «expr ≅ » X Y) (g : «expr ≅ » Y Z) (i : I) :\n    iso_app («expr ≪≫ » f g) i = «expr ≪≫ » (iso_app f i) (iso_app g i) :=\n  rfl\n#align iso_app_trans iso_app_trans\n\n",
 "iso_app_symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≅ » -/\n@[simp]\ntheorem iso_app_symm {X Y : ∀ i, C i} (f : «expr ≅ » X Y) (i : I) : iso_app f.symm i = (iso_app f i).symm :=\n  rfl\n#align iso_app_symm iso_app_symm\n\n",
 "iso_app_refl":
 "@[simp]\ntheorem iso_app_refl (X : ∀ i, C i) (i : I) : iso_app (Iso.refl X) i = Iso.refl (X i) :=\n  rfl\n#align iso_app_refl iso_app_refl\n\n",
 "id_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/-\nCopyright (c) 2020 Scott Morrison. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Simon Hudon, Scott Morrison\n-/\n@[simp]\ntheorem id_apply (X : ∀ i, C i) (i) : ((«expr𝟙») X : ∀ i, «expr ⟶ » (X i) (X i)) i = («expr𝟙») (X i) :=\n  rfl\n#align id_apply id_apply\n\n",
 "eq_to_hom_proj":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n@[simp]\ntheorem eq_to_hom_proj {x x' : ∀ i, C i} (h : x = x') (i : I) :\n    (eq_to_hom h : «expr ⟶ » x x') i = eq_to_hom (function.funext_iff.mp h i) :=\n  by\n  subst h\n  rfl\n#align eq_to_hom_proj eq_to_hom_proj\n\n",
 "comp_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp]\ntheorem comp_apply {X Y Z : ∀ i, C i} (f : «expr ⟶ » X Y) (g : «expr ⟶ » Y Z) (i) :\n    («expr ≫ » f g : ∀ i, «expr ⟶ » (X i) (Z i)) i = «expr ≫ » (f i) (g i) :=\n  rfl\n#align comp_apply comp_apply\n\n"}