{"preinclusion_obj":
 "/-\nCopyright (c) 2022 Yuma Mizuno. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yuma Mizuno, Junyan Xu\n-/\n@[simp]\ntheorem preinclusion_obj (a : B) : (preinclusion B).obj a = a :=\n  rfl\n#align preinclusion_obj preinclusion_obj\n\n",
 "preinclusion_map₂":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n@[simp]\ntheorem preinclusion_map₂ {a b : B} (f g : Discrete (Path.{v + 1} a b)) (η : «expr ⟶ » f g) :\n    (preinclusion B).map₂ η = eqToHom (congr_arg _ (discrete.ext _ _ (Discrete.eq_of_hom η))) :=\n  by\n  rcases η with ⟨⟨⟩⟩\n  cases discrete.ext _ _ η\n  exact (inclusion_path a b).map_id _\n#align preinclusion_map₂ preinclusion_map₂\n\n",
 "normalize_naturality":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `bicategory.whisker_left -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/-- The 2-isomorphism `normalize_iso p f` is natural in `f`. -/\ntheorem normalize_naturality {a b c : B} (p : Path a b) {f g : hom b c} (η : «expr ⟶ » f g) :\n    «expr ≫ » (bicategory.whisker_left ((preinclusion B).map ⟨p⟩) η) (normalize_iso p g).hom =\n      «expr ≫ » (normalize_iso p f).hom\n        ((preinclusion B).map₂ (eqToHom (discrete.ext _ _ (normalize_aux_congr p η)))) :=\n  by\n  rcases η with ⟨⟩; induction η\n  case id => simp\n  case vcomp _ _ _ _ _ _ _ ihf ihg =>\n    rw [mk_vcomp, bicategory.whisker_left_comp]\n    slice_lhs 2 3 => rw [ihg]\n    slice_lhs 1 2 => rw [ihf]\n    simp\n  case\n    whisker_left _ _ _ _ _ _ _ ih =>-- p ≠ nil required! See the docstring of `normalize_aux`.\n    dsimp;\n    simp_rw [associator_inv_naturality_right_assoc, whisker_exchange_assoc, ih, assoc]\n  case whisker_right _ _ _ _ _ h η ih =>\n    dsimp\n    rw [associator_inv_naturality_middle_assoc, ← comp_whisker_right_assoc, ih, comp_whisker_right]\n    have := dcongr_arg (fun x => (normalize_iso x h).hom) (normalize_aux_congr p (Quot.mk _ η))\n    dsimp at this; simp [this]\n  all_goals dsimp; dsimp [id_def, comp_def]; simp\n#align normalize_naturality normalize_naturality\n\n",
 "normalize_aux_nil_comp":
 "@[simp]\ntheorem normalize_aux_nil_comp {a b c : B} (f : hom a b) (g : hom b c) :\n    normalize_aux nil (f.comp g) = (normalize_aux nil f).comp (normalize_aux nil g) :=\n  by\n  induction g generalizing a\n  case id => rfl\n  case of => rfl\n  case comp _ _ _ g _ ihf ihg => erw [ihg (f.comp g), ihf f, ihg g, comp_assoc]\n#align normalize_aux_nil_comp normalize_aux_nil_comp\n\n",
 "normalize_aux_congr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/-\nWe may define\n```\ndef normalize_aux' : ∀ {a b : B}, hom a b → path a b\n| _ _ (hom.of f) := f.to_path\n| _ _ (hom.id b) := nil\n| _ _ (hom.comp f g) := (normalize_aux' f).comp (normalize_aux' g)\n```\nand define `normalize_aux p f` to be `p.comp (normalize_aux' f)` and this will be\nequal to the above definition, but the equality proof requires `comp_assoc`, and it\nthus lacks the correct definitional property to make the definition of `normalize_iso`\ntypecheck.\n```\nexample {a b c : B} (p : path a b) (f : hom b c) :\n  normalize_aux p f = p.comp (normalize_aux' f) :=\nby { induction f, refl, refl,\n  case comp : _ _ _ _ _ ihf ihg { rw [normalize_aux, ihf, ihg], apply comp_assoc } }\n```\n-/\n/-- Given a 2-morphism between `f` and `g` in the free bicategory, we have the equality\n`normalize_aux p f = normalize_aux p g`.\n-/\ntheorem normalize_aux_congr {a b c : B} (p : Path a b) {f g : hom b c} (η : «expr ⟶ » f g) :\n    normalize_aux p f = normalize_aux p g := by\n  rcases η with ⟨⟩\n  apply @congr_fun _ _ fun p => normalize_aux p f\n  clear p\n  induction η\n  case vcomp => apply Eq.trans <;> assumption\n  -- p ≠ nil required! See the docstring of `normalize_aux`.\n  case whisker_left _ _ _ _ _ _ _ ih => funext; apply congr_fun ih\n  case whisker_right _ _ _ _ _ _ _ ih => funext; apply congr_arg₂ _ (congr_fun ih p) rfl\n  all_goals funext; rfl\n#align normalize_aux_congr normalize_aux_congr\n\n"}