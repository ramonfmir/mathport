{"skeleton_skeletal":
 "theorem skeleton_skeletal : skeletal (skeleton C) :=\n  by\n  rintro X Y âŸ¨hâŸ©\n  have : X.out â‰ˆ Y.out := âŸ¨(from_skeleton C).map_iso hâŸ©\n  simpa using quotient.sound this\n#align skeleton_skeletal skeleton_skeletal\n\n",
 "skeletal":
 "theorem skeletal : skeletal (thin_skeleton C) := fun X Y =>\n  quotient.induction_onâ‚‚ X Y fun x y h => h.elim fun i => i.1.le.antisymm i.2.le\n#align skeletal skeletal\n\n",
 "map_iso_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰… Â» -/\ntheorem map_iso_eq {Fâ‚ Fâ‚‚ : Â«expr â¥¤ Â» D C} (h : Â«expr â‰… Â» Fâ‚ Fâ‚‚) : map Fâ‚ = map Fâ‚‚ :=\n  functor.eq_of_iso skeletal\n    { hom := map_nat_trans h.hom\n      inv := map_nat_trans h.inv }\n#align map_iso_eq map_iso_eq\n\n",
 "map_id_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ­Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ­Â» -/\ntheorem map_id_eq : map ((Â«exprğŸ­Â») C) = (Â«exprğŸ­Â») (thin_skeleton C) :=\n  functor.eq_of_iso skeletal <|\n    NatIso.ofComponents (fun X => quotient.rec_on_subsingleton X fun x => Iso.refl _) (by tidy)\n#align map_id_eq map_id_eq\n\n",
 "map_comp_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‹™ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‹™ Â» -/\ntheorem map_comp_eq (F : Â«expr â¥¤ Â» E D) (G : Â«expr â¥¤ Â» D C) : map (Â«expr â‹™ Â» F G) = Â«expr â‹™ Â» (map F) (map G) :=\n  functor.eq_of_iso skeletal <|\n    NatIso.ofComponents (fun X => quotient.rec_on_subsingleton X fun x => Iso.refl _) (by tidy)\n#align map_comp_eq map_comp_eq\n\n",
 "functor_skeletal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/-- If `C` is thin and skeletal, `D â¥¤ C` is skeletal.\n`category_theory.functor_thin` shows it is thin also.\n-/\ntheorem functor_skeletal [Quiver.IsThin C] (hC : skeletal C) : skeletal (Â«expr â¥¤ Â» D C) := fun Fâ‚ Fâ‚‚ h =>\n  h.elim (functor.eq_of_iso hC)\n#align functor_skeletal functor_skeletal\n\n",
 "equiv_of_both_ways":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n-- TODO: state the lemmas about what happens when you compose with `to_thin_skeleton`\ntheorem equiv_of_both_ways {X Y : C} (f : Â«expr âŸ¶ Â» X Y) (g : Â«expr âŸ¶ Â» Y X) : X â‰ˆ Y :=\n  âŸ¨iso_of_both_ways f gâŸ©\n#align equiv_of_both_ways equiv_of_both_ways\n\n",
 "eq_of_iso":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰… Â» -/\n/-\nCopyright (c) 2020 Bhavik Mehta. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Bhavik Mehta\n-/\n/-- If `C` is thin and skeletal, then any naturally isomorphic functors to `C` are equal. -/\ntheorem functor.eq_of_iso {Fâ‚ Fâ‚‚ : Â«expr â¥¤ Â» D C} [Quiver.IsThin C] (hC : skeletal C) (hF : Â«expr â‰… Â» Fâ‚ Fâ‚‚) :\n    Fâ‚ = Fâ‚‚ :=\n  functor.ext (fun X => hC âŸ¨hF.app XâŸ©) fun _ _ _ => subsingleton.elim _ _\n#align functor.eq_of_iso functor.eq_of_iso\n\n",
 "comp_to_thin_skeleton":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‹™ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‹™ Â» -/\ntheorem comp_to_thin_skeleton (F : Â«expr â¥¤ Â» C D) :\n    Â«expr â‹™ Â» F (to_thin_skeleton D) = Â«expr â‹™ Â» (to_thin_skeleton C) (map F) :=\n  rfl\n#align comp_to_thin_skeleton comp_to_thin_skeleton\n\n"}