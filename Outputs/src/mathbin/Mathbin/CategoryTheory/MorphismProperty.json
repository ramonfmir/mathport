{"unop_op":
 "/-\nCopyright (c) 2022 Andrew Yang. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Andrew Yang\n-/\ntheorem unop_op (P : morphism_property C) : P.op.unop = P :=\n  rfl\n#align unop_op unop_op\n\n",
 "unop":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵖ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵖ» -/\ntheorem unop {W : morphism_property C} {L : «expr ⥤ » («expr ᵒᵖ» C) («expr ᵒᵖ» D)} (h : W.op.is_inverted_by L) :\n    W.is_inverted_by L.unop := fun X Y f hf => by\n  haveI := h f.op hf\n  dsimp\n  infer_instance\n#align unop unop\n\n",
 "universally_stable_under_base_change":
 "theorem universally_stable_under_base_change (P : morphism_property C) : P.universally.stable_under_base_change :=\n  fun X Y Y' S f g f' g' H h₁ Y'' X'' i₁ i₂ f'' H' => h₁ _ _ _ (H'.paste_vert H.flip)\n#align universally_stable_under_base_change universally_stable_under_base_change\n\n",
 "universally_respects_iso":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem universally_respects_iso (P : morphism_property C) : P.universally.respects_iso :=\n  by\n  constructor\n  · intro X Y Z e f hf X' Z' i₁ i₂ f' H\n    have : is_pullback ((«expr𝟙») _) («expr ≫ » i₁ e.hom) i₁ e.inv :=\n      is_pullback.of_horiz_is_iso ⟨by rw [category.id_comp, category.assoc, e.hom_inv_id, category.comp_id]⟩\n    replace this := this.paste_horiz H\n    rw [iso.inv_hom_id_assoc, category.id_comp] at this\n    exact hf _ _ _ this\n  · intro X Y Z e f hf X' Z' i₁ i₂ f' H\n    have : is_pullback ((«expr𝟙») _) i₂ («expr ≫ » i₂ e.inv) e.inv := is_pullback.of_horiz_is_iso ⟨category.id_comp _⟩\n    replace this := H.paste_horiz this\n    rw [category.assoc, iso.hom_inv_id, category.comp_id, category.comp_id] at this\n    exact hf _ _ _ this\n#align universally_respects_iso universally_respects_iso\n\n",
 "universally_mono":
 "theorem universally_mono : monotone (universally : morphism_property C → morphism_property C) :=\n  fun P₁ P₂ h X Y f h₁ X' Y' i₁ i₂ f' H => h _ _ _ (h₁ _ _ _ H)\n#align universally_mono universally_mono\n\n",
 "universally_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\ntheorem universally_le (P : morphism_property C) : P.universally ≤ P :=\n  by\n  intro X Y f hf\n  exact hf ((«expr𝟙») _) ((«expr𝟙») _) _ (is_pullback.of_vert_is_iso ⟨by rw [category.comp_id, category.id_comp]⟩)\n#align universally_le universally_le\n\n",
 "universally_eq":
 "theorem stable_under_base_change.universally_eq {P : morphism_property C} (hP : P.stable_under_base_change) :\n    P.universally = P :=\n  P.universally_le.antisymm fun X Y f hf X' Y' i₁ i₂ f' H => hP H.flip hf\n#align stable_under_base_change.universally_eq stable_under_base_change.universally_eq\n\n",
 "universally":
 "theorem stable_under_composition.universally [has_pullbacks C] {P : morphism_property C}\n    (hP : P.stable_under_composition) : P.universally.stable_under_composition :=\n  by\n  intro X Y Z f g hf hg X' Z' i₁ i₂ f' H\n  have := pullback.lift_fst _ _ (H.w.trans (category.assoc _ _ _).symm)\n  rw [← this] at H⊢\n  apply hP _ _ _ (hg _ _ _ <| is_pullback.of_has_pullback _ _)\n  exact hf _ _ _ (H.of_right (pullback.lift_snd _ _ _) (is_pullback.of_has_pullback i₂ g))\n#align stable_under_composition.universally stable_under_composition.universally\n\n",
 "surjective_stable_under_composition":
 "theorem surjective_stable_under_composition : (morphism_property.surjective C).stable_under_composition :=\n  fun X Y Z f g hf hg => by\n  delta morphism_property.surjective\n  rw [coe_comp]\n  exact hg.comp hf\n#align surjective_stable_under_composition surjective_stable_under_composition\n\n",
 "surjective_respects_iso":
 "theorem surjective_respects_iso : (morphism_property.surjective C).respects_iso :=\n  (surjective_stable_under_composition C).respects_iso fun X Y e => ((forget C).map_iso e).to_equiv.surjective\n#align surjective_respects_iso surjective_respects_iso\n\n",
 "snd":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem stable_under_base_change.snd {P : morphism_property C} (hP : stable_under_base_change P) {X Y S : C}\n    (f : «expr ⟶ » X S) (g : «expr ⟶ » Y S) [has_pullback f g] (H : P f) :\n    P (pullback.snd : «expr ⟶ » (pullback f g) Y) :=\n  hP (is_pullback.of_has_pullback f g) H\n#align stable_under_base_change.snd stable_under_base_change.snd\n\n",
 "right_op":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵖ» -/\ntheorem right_op {W : morphism_property C} {L : «expr ⥤ » («expr ᵒᵖ» C) D} (h : W.op.is_inverted_by L) :\n    W.is_inverted_by L.right_op := fun X Y f hf =>\n  by\n  haveI := h f.op hf\n  dsimp\n  infer_instance\n#align right_op right_op\n\n",
 "respects_iso":
 "theorem stable_under_cobase_change.respects_iso {P : morphism_property C} (hP : stable_under_cobase_change P) :\n    respects_iso P :=\n  respects_iso.of_respects_arrow_iso _ fun f g e => hP (is_pushout.of_horiz_is_iso (comm_sq.mk e.hom.w))\n#align stable_under_cobase_change.respects_iso stable_under_cobase_change.respects_iso\n\n",
 "pullback_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\ntheorem stable_under_base_change.pullback_map [has_pullbacks C] {P : morphism_property C}\n    (hP : stable_under_base_change P) (hP' : stable_under_composition P) {S X X' Y Y' : C} {f : «expr ⟶ » X S}\n    {g : «expr ⟶ » Y S} {f' : «expr ⟶ » X' S} {g' : «expr ⟶ » Y' S} {i₁ : «expr ⟶ » X X'} {i₂ : «expr ⟶ » Y Y'}\n    (h₁ : P i₁) (h₂ : P i₂) (e₁ : f = «expr ≫ » i₁ f') (e₂ : g = «expr ≫ » i₂ g') :\n    P (pullback.map f g f' g' i₁ i₂ ((«expr𝟙») _) ((category.comp_id _).trans e₁) ((category.comp_id _).trans e₂)) :=\n  by\n  have :\n    pullback.map f g f' g' i₁ i₂ ((«expr𝟙») _) ((category.comp_id _).trans e₁) ((category.comp_id _).trans e₂) =\n      «expr ≫ »\n        («expr ≫ » (pullback_symmetry _ _).hom\n          ((base_change _).map (over.hom_mk _ e₂.symm : «expr ⟶ » (over.mk g) (over.mk g'))).left)\n        («expr ≫ » (pullback_symmetry _ _).hom\n          ((base_change g').map (over.hom_mk _ e₁.symm : «expr ⟶ » (over.mk f) (over.mk f'))).left) :=\n    by apply pullback.hom_ext <;> dsimp <;> simp\n  rw [this]\n  apply hP' <;> rw [hP.respects_iso.cancel_left_is_iso]\n  exacts[hP.base_change_map _ (over.hom_mk _ e₂.symm : «expr ⟶ » (over.mk g) (over.mk g')) h₂,\n    hP.base_change_map _ (over.hom_mk _ e₁.symm : «expr ⟶ » (over.mk f) (over.mk f')) h₁]\n#align stable_under_base_change.pullback_map stable_under_base_change.pullback_map\n\n",
 "op_unop":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵖ» -/\ntheorem op_unop (P : morphism_property («expr ᵒᵖ» C)) : P.unop.op = P :=\n  rfl\n#align op_unop op_unop\n\n",
 "op":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\ntheorem op {W : morphism_property C} {L : «expr ⥤ » C D} (h : W.is_inverted_by L) : W.op.is_inverted_by L.op :=\n  fun X Y f hf => by\n  haveI := h f.unop hf\n  dsimp\n  infer_instance\n#align op op\n\n",
 "of_respects_arrow_iso":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≅ » -/\ntheorem respects_iso.of_respects_arrow_iso (P : morphism_property C)\n    (hP : ∀ (f g : arrow C) (e : «expr ≅ » f g) (hf : P f.hom), P g.hom) : respects_iso P :=\n  by\n  constructor\n  · intro X Y Z e f hf\n    refine' hP (arrow.mk f) (arrow.mk («expr ≫ » e.hom f)) (arrow.iso_mk e.symm (iso.refl _) _) hf\n    dsimp\n    simp only [iso.inv_hom_id_assoc, category.comp_id]\n  · intro X Y Z e f hf\n    refine' hP (arrow.mk f) (arrow.mk («expr ≫ » f e.hom)) (arrow.iso_mk (iso.refl _) e _) hf\n    dsimp\n    simp only [category.id_comp]\n#align respects_iso.of_respects_arrow_iso respects_iso.of_respects_arrow_iso\n\n",
 "of_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\ntheorem of_comp {C₁ C₂ C₃ : Type _} [Category C₁] [Category C₂] [Category C₃] (W : morphism_property C₁)\n    (F : «expr ⥤ » C₁ C₂) (hF : W.is_inverted_by F) (G : «expr ⥤ » C₂ C₃) : W.is_inverted_by («expr ⋙ » F G) :=\n  fun X Y f hf => by\n  haveI := hF f hf\n  dsimp\n  infer_instance\n#align of_comp of_comp\n\n",
 "monomorphisms":
 "theorem stable_under_composition.monomorphisms : stable_under_composition (monomorphisms C) := fun X Y Z f g hf hg =>\n  by\n  rw [monomorphisms.iff] at hf hg⊢\n  haveI := hf\n  haveI := hg\n  apply mono_comp\n#align stable_under_composition.monomorphisms stable_under_composition.monomorphisms\n\n",
 "mk":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem stable_under_cobase_change.mk {P : morphism_property C} [has_pushouts C] (hP₁ : respects_iso P)\n    (hP₂ :\n      ∀ (A B A' : C) (f : «expr ⟶ » A A') (g : «expr ⟶ » A B) (hf : P f), P (pushout.inr : «expr ⟶ » B (pushout f g))) :\n    stable_under_cobase_change P := fun A A' B B' f g f' g' sq hf =>\n  by\n  let e := sq.flip.iso_pushout\n  rw [← hP₁.cancel_right_is_iso _ e.hom, sq.flip.inr_iso_pushout_hom]\n  exact hP₂ _ _ _ f g hf\n#align stable_under_cobase_change.mk stable_under_cobase_change.mk\n\n",
 "left_op":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵖ» -/\ntheorem left_op {W : morphism_property C} {L : «expr ⥤ » C («expr ᵒᵖ» D)} (h : W.is_inverted_by L) :\n    W.op.is_inverted_by L.left_op := fun X Y f hf =>\n  by\n  haveI := h f.unop hf\n  dsimp\n  infer_instance\n#align left_op left_op\n\n",
 "isomorphisms":
 "theorem stable_under_composition.isomorphisms : stable_under_composition (isomorphisms C) := fun X Y Z f g hf hg =>\n  by\n  rw [isomorphisms.iff] at hf hg⊢\n  haveI := hf\n  haveI := hg\n  infer_instance\n#align stable_under_composition.isomorphisms stable_under_composition.isomorphisms\n\n",
 "is_stable_under_inverse":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem is_stable_under_inverse {F₁ F₂ : «expr ⥤ » C D} (app : ∀ X, «expr ⟶ » (F₁.obj X) (F₂.obj X)) :\n    (naturality_property app).stable_under_inverse := fun X Y e he =>\n  by\n  simp only [naturality_property] at he⊢\n  rw [← cancel_epi (F₁.map e.hom)]\n  slice_rhs 1 2 => rw [he]\n  simp only [category.assoc, ← F₁.map_comp_assoc, ← F₂.map_comp, e.hom_inv_id, Functor.map_id, category.id_comp,\n    category.comp_id]\n#align is_stable_under_inverse is_stable_under_inverse\n\n",
 "is_stable_under_composition":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem is_stable_under_composition {F₁ F₂ : «expr ⥤ » C D} (app : ∀ X, «expr ⟶ » (F₁.obj X) (F₂.obj X)) :\n    (naturality_property app).stable_under_composition := fun X Y Z f g hf hg =>\n  by\n  simp only [naturality_property] at hf hg⊢\n  simp only [functor.map_comp, category.assoc, hg]\n  slice_lhs 1 2 => rw [hf]\n  rw [category.assoc]\n#align is_stable_under_composition is_stable_under_composition\n\n",
 "inverse_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\ntheorem stable_under_composition.inverse_image {P : morphism_property D} (h : stable_under_composition P)\n    (F : «expr ⥤ » C D) : stable_under_composition (P.inverse_image F) := fun X Y Z f g hf hg => by\n  simpa only [← F.map_comp] using h (F.map f) (F.map g) hf hg\n#align stable_under_composition.inverse_image stable_under_composition.inverse_image\n\n",
 "inr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem stable_under_cobase_change.inr {P : morphism_property C} (hP : stable_under_cobase_change P) {A B A' : C}\n    (f : «expr ⟶ » A A') (g : «expr ⟶ » A B) [has_pushout f g] (H : P f) :\n    P (pushout.inr : «expr ⟶ » B (pushout f g)) :=\n  hP (is_pushout.of_has_pushout f g).flip H\n#align stable_under_cobase_change.inr stable_under_cobase_change.inr\n\n",
 "inl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem stable_under_cobase_change.inl {P : morphism_property C} (hP : stable_under_cobase_change P) {A B A' : C}\n    (f : «expr ⟶ » A A') (g : «expr ⟶ » A B) [has_pushout f g] (H : P g) :\n    P (pushout.inl : «expr ⟶ » A' (pushout f g)) :=\n  hP (is_pushout.of_has_pushout f g) H\n#align stable_under_cobase_change.inl stable_under_cobase_change.inl\n\n",
 "injective_stable_under_composition":
 "theorem injective_stable_under_composition : (morphism_property.injective C).stable_under_composition :=\n  fun X Y Z f g hf hg => by\n  delta morphism_property.injective\n  rw [coe_comp]\n  exact hg.comp hf\n#align injective_stable_under_composition injective_stable_under_composition\n\n",
 "injective_respects_iso":
 "theorem injective_respects_iso : (morphism_property.injective C).respects_iso :=\n  (injective_stable_under_composition C).respects_iso fun X Y e => ((forget C).map_iso e).to_equiv.injective\n#align injective_respects_iso injective_respects_iso\n\n",
 "infer_property":
 "theorem epimorphisms.infer_property [hf : Epi f] : (epimorphisms C) f :=\n  hf\n#align epimorphisms.infer_property epimorphisms.infer_property\n\n",
 "iff_of_iso":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≅ » -/\ntheorem is_inverted_by.iff_of_iso (W : morphism_property C) {F₁ F₂ : «expr ⥤ » C D} (e : «expr ≅ » F₁ F₂) :\n    W.is_inverted_by F₁ ↔ W.is_inverted_by F₂ :=\n  by\n  suffices ∀ (X Y : C) (f : «expr ⟶ » X Y), is_iso (F₁.map f) ↔ is_iso (F₂.map f)\n    by\n    constructor\n    exact fun h X Y f hf => by\n      rw [← this]\n      exact h f hf\n    exact fun h X Y f hf => by\n      rw [this]\n      exact h f hf\n  intro X Y f\n  exact (respects_iso.isomorphisms D).arrow_mk_iso_iff (arrow.iso_mk (e.app X) (e.app Y) (by simp))\n#align is_inverted_by.iff_of_iso is_inverted_by.iff_of_iso\n\n",
 "iff":
 "@[simp]\ntheorem epimorphisms.iff : (epimorphisms C) f ↔ Epi f := by rfl\n#align epimorphisms.iff epimorphisms.iff\n\n",
 "fst":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem stable_under_base_change.fst {P : morphism_property C} (hP : stable_under_base_change P) {X Y S : C}\n    (f : «expr ⟶ » X S) (g : «expr ⟶ » Y S) [has_pullback f g] (H : P g) :\n    P (pullback.fst : «expr ⟶ » (pullback f g) X) :=\n  hP (is_pullback.of_has_pullback f g).flip H\n#align stable_under_base_change.fst stable_under_base_change.fst\n\n",
 "epimorphisms":
 "theorem stable_under_composition.epimorphisms : stable_under_composition (epimorphisms C) := fun X Y Z f g hf hg =>\n  by\n  rw [epimorphisms.iff] at hf hg⊢\n  haveI := hf\n  haveI := hg\n  apply epi_comp\n#align stable_under_composition.epimorphisms stable_under_composition.epimorphisms\n\n",
 "diagonal_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem diagonal_iff {X Y : C} {f : «expr ⟶ » X Y} : P.diagonal f ↔ P (pullback.diagonal f) :=\n  iff.rfl\n#align diagonal_iff diagonal_iff\n\n",
 "diagonal":
 "theorem stable_under_base_change.diagonal (hP : stable_under_base_change P) (hP' : respects_iso P) :\n    P.diagonal.stable_under_base_change :=\n  stable_under_base_change.mk hP'.diagonal\n    (by\n      introv h\n      rw [diagonal_iff, diagonal_pullback_fst, hP'.cancel_left_is_iso, hP'.cancel_right_is_iso]\n      convert hP.base_change_map f _ _ <;> simp <;> assumption)\n#align stable_under_base_change.diagonal stable_under_base_change.diagonal\n\n",
 "cancel_right_is_iso":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem respects_iso.cancel_right_is_iso {P : morphism_property C} (hP : respects_iso P) {X Y Z : C} (f : «expr ⟶ » X Y)\n    (g : «expr ⟶ » Y Z) [IsIso g] : P («expr ≫ » f g) ↔ P f :=\n  ⟨fun h => by simpa using hP.2 (as_iso g).symm («expr ≫ » f g) h, hP.2 (asIso g) f⟩\n#align respects_iso.cancel_right_is_iso respects_iso.cancel_right_is_iso\n\n",
 "cancel_left_is_iso":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem respects_iso.cancel_left_is_iso {P : morphism_property C} (hP : respects_iso P) {X Y Z : C} (f : «expr ⟶ » X Y)\n    (g : «expr ⟶ » Y Z) [IsIso f] : P («expr ≫ » f g) ↔ P g :=\n  ⟨fun h => by simpa using hP.1 (as_iso f).symm («expr ≫ » f g) h, hP.1 (asIso f) g⟩\n#align respects_iso.cancel_left_is_iso respects_iso.cancel_left_is_iso\n\n",
 "bijective_stable_under_composition":
 "theorem bijective_stable_under_composition : (morphism_property.bijective C).stable_under_composition :=\n  fun X Y Z f g hf hg => by\n  delta morphism_property.bijective\n  rw [coe_comp]\n  exact hg.comp hf\n#align bijective_stable_under_composition bijective_stable_under_composition\n\n",
 "bijective_respects_iso":
 "theorem bijective_respects_iso : (morphism_property.bijective C).respects_iso :=\n  (bijective_stable_under_composition C).respects_iso fun X Y e => ((forget C).map_iso e).to_equiv.bijective\n#align bijective_respects_iso bijective_respects_iso\n\n",
 "bijective_eq_sup":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\ntheorem bijective_eq_sup :\n    morphism_property.bijective C = «expr ⊓ » (morphism_property.injective C) (morphism_property.surjective C) :=\n  rfl\n#align bijective_eq_sup bijective_eq_sup\n\n",
 "base_change_obj":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem stable_under_base_change.base_change_obj [has_pullbacks C] {P : morphism_property C}\n    (hP : stable_under_base_change P) {S S' : C} (f : «expr ⟶ » S' S) (X : over S) (H : P X.hom) :\n    P ((base_change f).obj X).hom :=\n  hP.snd X.hom f H\n#align stable_under_base_change.base_change_obj stable_under_base_change.base_change_obj\n\n",
 "base_change_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≪≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem stable_under_base_change.base_change_map [has_pullbacks C] {P : morphism_property C}\n    (hP : stable_under_base_change P) {S S' : C} (f : «expr ⟶ » S' S) {X Y : over S} (g : «expr ⟶ » X Y)\n    (H : P g.left) : P ((base_change f).map g).left :=\n  by\n  let e :=\n    «expr ≪≫ » (pullback_right_pullback_fst_iso Y.hom f g.left)\n      (pullback.congr_hom (g.w.trans (category.comp_id _)) rfl)\n  have : «expr ≫ » e.inv pullback.snd = ((base_change f).map g).left := by apply pullback.hom_ext <;> dsimp <;> simp\n  rw [← this, hP.respects_iso.cancel_left_is_iso]\n  exact hP.snd _ _ H\n#align stable_under_base_change.base_change_map stable_under_base_change.base_change_map\n\n",
 "arrow_mk_iso_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≅ » -/\ntheorem respects_iso.arrow_mk_iso_iff {P : morphism_property C} (hP : respects_iso P) {W X Y Z : C} {f : «expr ⟶ » W X}\n    {g : «expr ⟶ » Y Z} (e : «expr ≅ » (arrow.mk f) (arrow.mk g)) : P f ↔ P g :=\n  hP.arrow_iso_iff e\n#align respects_iso.arrow_mk_iso_iff respects_iso.arrow_mk_iso_iff\n\n",
 "arrow_iso_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≅ » -/\ntheorem respects_iso.arrow_iso_iff {P : morphism_property C} (hP : respects_iso P) {f g : arrow C} (e : «expr ≅ » f g) :\n    P f.hom ↔ P g.hom :=\n  by\n  rw [← arrow.inv_left_hom_right e.hom, hP.cancel_left_is_iso, hP.cancel_right_is_iso]\n  rfl\n#align respects_iso.arrow_iso_iff respects_iso.arrow_iso_iff\n\n"}