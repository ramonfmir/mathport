{"to_preimages":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\ntheorem is_mittag_leffler.to_preimages (h : F.is_mittag_leffler) : (F.to_preimages s).is_mittag_leffler :=\n  (is_mittag_leffler_iff_subset_range_comp _).2 fun j =>\n    by\n    obtain âŸ¨jâ‚, gâ‚, fâ‚, -âŸ© := cone_objs i j\n    obtain âŸ¨jâ‚‚, fâ‚‚, hâ‚‚âŸ© := F.is_mittag_leffler_iff_eventual_range.1 h jâ‚\n    refine' âŸ¨jâ‚‚, Â«expr â‰« Â» fâ‚‚ fâ‚, fun jâ‚ƒ fâ‚ƒ => _âŸ©\n    rintro _ âŸ¨âŸ¨x, hxâŸ©, rflâŸ©\n    have : F.map fâ‚‚ x âˆˆ F.eventual_range jâ‚ := by\n      rw [hâ‚‚]\n      exact âŸ¨_, rflâŸ©\n    obtain âŸ¨y, hy, hâ‚ƒâŸ© := h.subset_image_eventual_range F (Â«expr â‰« Â» fâ‚ƒ fâ‚‚) this\n    refine' âŸ¨âŸ¨y, mem_Inter.2 fun gâ‚‚ => _âŸ©, subtype.ext _âŸ©\n    Â· obtain âŸ¨jâ‚„, fâ‚„, hâ‚„âŸ© := cone_maps gâ‚‚ (Â«expr â‰« Â» (Â«expr â‰« Â» fâ‚ƒ fâ‚‚) gâ‚)\n      obtain âŸ¨y, rflâŸ© := F.mem_eventual_range_iff.1 hy fâ‚„\n      rw [â† map_comp_apply] at hâ‚ƒ\n      rw [mem_preimage, â† map_comp_apply, hâ‚„, â† category.assoc, map_comp_apply, hâ‚ƒ, â† map_comp_apply]\n      apply mem_Inter.1 hx\n    Â· simp_rw [to_preimages_map, maps_to.coe_restrict_apply, subtype.coe_mk]\n      rw [â† category.assoc, map_comp_apply, hâ‚ƒ, map_comp_apply]\n#align is_mittag_leffler.to_preimages is_mittag_leffler.to_preimages\n\n",
 "to_eventual_ranges_nonempty":
 "/-- If `F` is nonempty at each index and Mittag-Leffler, then so is `F.to_eventual_ranges`. -/\ntheorem to_eventual_ranges_nonempty (h : F.is_mittag_leffler) [âˆ€ j : J, nonempty (F.obj j)] (j : J) :\n    nonempty (F.to_eventual_ranges.obj j) :=\n  by\n  let âŸ¨i, f, hâŸ© := F.is_mittag_leffler_iff_eventual_range.1 h j\n  rw [to_eventual_ranges_obj, h]\n  infer_instance\n#align to_eventual_ranges_nonempty to_eventual_ranges_nonempty\n\n",
 "thin_diagram_of_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/-- If `F` has all arrows surjective, then it \"factors through a poset\". -/\ntheorem thin_diagram_of_surjective (Fsur : âˆ€ (i j : J) (f : Â«expr âŸ¶ Â» i j), (F.map f).surjective) (i j)\n    (f g : Â«expr âŸ¶ Â» i j) : F.map f = F.map g :=\n  let âŸ¨k, Ï†, hÏ†âŸ© := cone_maps f g\n  (Fsur k i Ï†).injective_comp_right <| by simp_rw [â† types_comp, â† F.map_comp, hÏ†]\n#align thin_diagram_of_surjective thin_diagram_of_surjective\n\n",
 "surjective_to_eventual_ranges":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/-- If `F` satisfies the Mittag-Leffler condition, its restriction to eventual ranges is a surjective\nfunctor.\n-/\ntheorem surjective_to_eventual_ranges (h : F.is_mittag_leffler) (f : Â«expr âŸ¶ Â» i j) :\n    (F.to_eventual_ranges.map f).surjective := fun âŸ¨x, hxâŸ© =>\n  by\n  obtain âŸ¨y, hy, rflâŸ© := h.subset_image_eventual_range F f hx\n  exact âŸ¨âŸ¨y, hyâŸ©, rflâŸ©\n#align surjective_to_eventual_ranges surjective_to_eventual_ranges\n\n",
 "subset_image_eventual_range":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\ntheorem is_mittag_leffler.subset_image_eventual_range (h : F.is_mittag_leffler) (f : Â«expr âŸ¶ Â» j i) :\n    F.eventual_range i âŠ† Â«expr '' Â» (F.map f) (F.eventual_range j) :=\n  by\n  obtain âŸ¨k, g, hgâŸ© := F.is_mittag_leffler_iff_eventual_range.1 h j\n  rw [hg]; intro x hx\n  obtain âŸ¨x, rflâŸ© := F.mem_eventual_range_iff.1 hx (Â«expr â‰« Â» g f)\n  refine' âŸ¨_, âŸ¨x, rflâŸ©, by simpa only [F.map_comp] âŸ©\n#align is_mittag_leffler.subset_image_eventual_range is_mittag_leffler.subset_image_eventual_range\n\n",
 "mem_eventual_range_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/-\nCopyright (c) 2022 RÃ©mi Bottinelli, Junyan Xu. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: RÃ©mi Bottinelli, Junyan Xu\n-/\ntheorem mem_eventual_range_iff {x : F.obj j} :\n    x âˆˆ F.eventual_range j â†” âˆ€ â¦ƒiâ¦„ (f : Â«expr âŸ¶ Â» i j), x âˆˆ range (F.map f) :=\n  mem_Interâ‚‚\n#align mem_eventual_range_iff mem_eventual_range_iff\n\n",
 "is_mittag_leffler_of_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem is_mittag_leffler_of_surjective (h : âˆ€ (i j : J) (f : Â«expr âŸ¶ Â» i j), (F.map f).surjective) :\n    F.is_mittag_leffler := fun j => âŸ¨j, (Â«exprğŸ™Â») j, fun k g => by rw [map_id, types_id, range_id, (h k j g).range_eq]âŸ©\n#align is_mittag_leffler_of_surjective is_mittag_leffler_of_surjective\n\n",
 "is_mittag_leffler_of_exists_finite_range":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem is_mittag_leffler_of_exists_finite_range\n    (h : âˆ€ j : J, âˆƒ (i : _)(f : Â«expr âŸ¶ Â» i j), (range <| F.map f).finite) : F.is_mittag_leffler := fun j =>\n  by\n  obtain âŸ¨i, hi, hfâŸ© := h j\n  obtain âŸ¨m, âŸ¨i, f, hmâŸ©, hminâŸ© :=\n    finset.is_well_founded_lt.wf.has_min { s : Finset (F.obj j) | âˆƒ (i : _)(f : Â«expr âŸ¶ Â» i j), â†‘s = range (F.map f) }\n      âŸ¨_, i, hi, hf.coe_to_finsetâŸ©\n  refine'\n    âŸ¨i, f, fun k g => (directed_on_range.mp <| F.ranges_directed j).is_bot_of_is_min âŸ¨âŸ¨i, fâŸ©, rflâŸ© _ _ âŸ¨âŸ¨k, gâŸ©, rflâŸ©âŸ©\n  rintro _ âŸ¨âŸ¨k', g'âŸ©, rflâŸ© hl\n  refine' (eq_of_le_of_not_lt hl _).ge\n  have := hmin _ âŸ¨k', g', (m.finite_to_set.subset <| hm.substr hl).coe_to_finsetâŸ©\n  rwa [Finset.lt_iff_ssubset, â† Finset.coe_ssubset, set.finite.coe_to_finset, hm] at this\n#align is_mittag_leffler_of_exists_finite_range is_mittag_leffler_of_exists_finite_range\n\n",
 "is_mittag_leffler_iff_subset_range_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\ntheorem is_mittag_leffler_iff_subset_range_comp :\n    F.is_mittag_leffler â†”\n      âˆ€ j : J,\n        âˆƒ (i : _)(f : Â«expr âŸ¶ Â» i j), âˆ€ â¦ƒkâ¦„ (g : Â«expr âŸ¶ Â» k i), range (F.map f) âŠ† range (F.map <| Â«expr â‰« Â» g f) :=\n  by simp_rw [is_mittag_leffler_iff_eventual_range, eventual_range_eq_iff]\n#align is_mittag_leffler_iff_subset_range_comp is_mittag_leffler_iff_subset_range_comp\n\n",
 "is_mittag_leffler_iff_eventual_range":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem is_mittag_leffler_iff_eventual_range :\n    F.is_mittag_leffler â†” âˆ€ j : J, âˆƒ (i : _)(f : Â«expr âŸ¶ Â» i j), F.eventual_range j = range (F.map f) :=\n  forall_congr' fun j =>\n    existsâ‚‚_congr fun i f => âŸ¨fun h => (interáµ¢â‚‚_subset _ _).antisymm <| subset_interáµ¢â‚‚ h, fun h => h â–¸ Interâ‚‚_subsetâŸ©\n#align is_mittag_leffler_iff_eventual_range is_mittag_leffler_iff_eventual_range\n\n",
 "eventual_range_maps_to":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem eventual_range_maps_to (f : Â«expr âŸ¶ Â» j i) : (F.eventual_range j).maps_to (F.map f) (F.eventual_range i) :=\n  fun x hx => by\n  rw [mem_eventual_range_iff] at hxâŠ¢\n  intro k f'\n  obtain âŸ¨l, g, g', heâŸ© := cospan f f'\n  obtain âŸ¨x, rflâŸ© := hx g\n  rw [â† map_comp_apply, he, F.map_comp]\n  exact âŸ¨_, rflâŸ©\n#align eventual_range_maps_to eventual_range_maps_to\n\n",
 "eventual_range_eq_range_precomp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\ntheorem eventual_range_eq_range_precomp (f : Â«expr âŸ¶ Â» i j) (g : Â«expr âŸ¶ Â» j k)\n    (h : F.eventual_range k = range (F.map g)) : F.eventual_range k = range (F.map <| Â«expr â‰« Â» f g) :=\n  by\n  apply subset_antisymm\n  Â· apply Interâ‚‚_subset\n  Â· rw [h, F.map_comp]\n    apply range_comp_subset_range\n#align eventual_range_eq_range_precomp eventual_range_eq_range_precomp\n\n",
 "eventual_range_eq_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\ntheorem eventual_range_eq_iff {f : Â«expr âŸ¶ Â» i j} :\n    F.eventual_range j = range (F.map f) â†”\n      âˆ€ â¦ƒkâ¦„ (g : Â«expr âŸ¶ Â» k i), range (F.map f) âŠ† range (F.map <| Â«expr â‰« Â» g f) :=\n  by\n  rw [subset_antisymm_iff, eventual_range, and_iff_right (Interâ‚‚_subset _ _), subset_Interâ‚‚_iff]\n  refine' âŸ¨fun h k g => h _ _, fun h j' f' => _âŸ©\n  obtain âŸ¨k, g, g', heâŸ© := cospan f f'\n  refine' (h g).trans _\n  rw [he, F.map_comp]\n  apply range_comp_subset_range\n#align eventual_range_eq_iff eventual_range_eq_iff\n\n",
 "eq_image_eventual_range":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\ntheorem is_mittag_leffler.eq_image_eventual_range (h : F.is_mittag_leffler) (f : Â«expr âŸ¶ Â» j i) :\n    F.eventual_range i = Â«expr '' Â» (F.map f) (F.eventual_range j) :=\n  (h.subset_image_eventual_range F f).antisymm <| mapsTo'.1 (F.eventual_range_maps_to f)\n#align is_mittag_leffler.eq_image_eventual_range is_mittag_leffler.eq_image_eventual_range\n\n"}