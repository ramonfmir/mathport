{"to_preimages":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem is_mittag_leffler.to_preimages (h : F.is_mittag_leffler) : (F.to_preimages s).is_mittag_leffler :=\n  (is_mittag_leffler_iff_subset_range_comp _).2 fun j =>\n    by\n    obtain ⟨j₁, g₁, f₁, -⟩ := cone_objs i j\n    obtain ⟨j₂, f₂, h₂⟩ := F.is_mittag_leffler_iff_eventual_range.1 h j₁\n    refine' ⟨j₂, «expr ≫ » f₂ f₁, fun j₃ f₃ => _⟩\n    rintro _ ⟨⟨x, hx⟩, rfl⟩\n    have : F.map f₂ x ∈ F.eventual_range j₁ := by\n      rw [h₂]\n      exact ⟨_, rfl⟩\n    obtain ⟨y, hy, h₃⟩ := h.subset_image_eventual_range F («expr ≫ » f₃ f₂) this\n    refine' ⟨⟨y, mem_Inter.2 fun g₂ => _⟩, subtype.ext _⟩\n    · obtain ⟨j₄, f₄, h₄⟩ := cone_maps g₂ («expr ≫ » («expr ≫ » f₃ f₂) g₁)\n      obtain ⟨y, rfl⟩ := F.mem_eventual_range_iff.1 hy f₄\n      rw [← map_comp_apply] at h₃\n      rw [mem_preimage, ← map_comp_apply, h₄, ← category.assoc, map_comp_apply, h₃, ← map_comp_apply]\n      apply mem_Inter.1 hx\n    · simp_rw [to_preimages_map, maps_to.coe_restrict_apply, subtype.coe_mk]\n      rw [← category.assoc, map_comp_apply, h₃, map_comp_apply]\n#align is_mittag_leffler.to_preimages is_mittag_leffler.to_preimages\n\n",
 "to_eventual_ranges_nonempty":
 "/-- If `F` is nonempty at each index and Mittag-Leffler, then so is `F.to_eventual_ranges`. -/\ntheorem to_eventual_ranges_nonempty (h : F.is_mittag_leffler) [∀ j : J, nonempty (F.obj j)] (j : J) :\n    nonempty (F.to_eventual_ranges.obj j) :=\n  by\n  let ⟨i, f, h⟩ := F.is_mittag_leffler_iff_eventual_range.1 h j\n  rw [to_eventual_ranges_obj, h]\n  infer_instance\n#align to_eventual_ranges_nonempty to_eventual_ranges_nonempty\n\n",
 "thin_diagram_of_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/-- If `F` has all arrows surjective, then it \"factors through a poset\". -/\ntheorem thin_diagram_of_surjective (Fsur : ∀ (i j : J) (f : «expr ⟶ » i j), (F.map f).surjective) (i j)\n    (f g : «expr ⟶ » i j) : F.map f = F.map g :=\n  let ⟨k, φ, hφ⟩ := cone_maps f g\n  (Fsur k i φ).injective_comp_right <| by simp_rw [← types_comp, ← F.map_comp, hφ]\n#align thin_diagram_of_surjective thin_diagram_of_surjective\n\n",
 "surjective_to_eventual_ranges":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/-- If `F` satisfies the Mittag-Leffler condition, its restriction to eventual ranges is a surjective\nfunctor.\n-/\ntheorem surjective_to_eventual_ranges (h : F.is_mittag_leffler) (f : «expr ⟶ » i j) :\n    (F.to_eventual_ranges.map f).surjective := fun ⟨x, hx⟩ =>\n  by\n  obtain ⟨y, hy, rfl⟩ := h.subset_image_eventual_range F f hx\n  exact ⟨⟨y, hy⟩, rfl⟩\n#align surjective_to_eventual_ranges surjective_to_eventual_ranges\n\n",
 "subset_image_eventual_range":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem is_mittag_leffler.subset_image_eventual_range (h : F.is_mittag_leffler) (f : «expr ⟶ » j i) :\n    F.eventual_range i ⊆ «expr '' » (F.map f) (F.eventual_range j) :=\n  by\n  obtain ⟨k, g, hg⟩ := F.is_mittag_leffler_iff_eventual_range.1 h j\n  rw [hg]; intro x hx\n  obtain ⟨x, rfl⟩ := F.mem_eventual_range_iff.1 hx («expr ≫ » g f)\n  refine' ⟨_, ⟨x, rfl⟩, by simpa only [F.map_comp] ⟩\n#align is_mittag_leffler.subset_image_eventual_range is_mittag_leffler.subset_image_eventual_range\n\n",
 "mem_eventual_range_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/-\nCopyright (c) 2022 Rémi Bottinelli, Junyan Xu. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Rémi Bottinelli, Junyan Xu\n-/\ntheorem mem_eventual_range_iff {x : F.obj j} :\n    x ∈ F.eventual_range j ↔ ∀ ⦃i⦄ (f : «expr ⟶ » i j), x ∈ range (F.map f) :=\n  mem_Inter₂\n#align mem_eventual_range_iff mem_eventual_range_iff\n\n",
 "is_mittag_leffler_of_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem is_mittag_leffler_of_surjective (h : ∀ (i j : J) (f : «expr ⟶ » i j), (F.map f).surjective) :\n    F.is_mittag_leffler := fun j => ⟨j, («expr𝟙») j, fun k g => by rw [map_id, types_id, range_id, (h k j g).range_eq]⟩\n#align is_mittag_leffler_of_surjective is_mittag_leffler_of_surjective\n\n",
 "is_mittag_leffler_of_exists_finite_range":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem is_mittag_leffler_of_exists_finite_range\n    (h : ∀ j : J, ∃ (i : _)(f : «expr ⟶ » i j), (range <| F.map f).finite) : F.is_mittag_leffler := fun j =>\n  by\n  obtain ⟨i, hi, hf⟩ := h j\n  obtain ⟨m, ⟨i, f, hm⟩, hmin⟩ :=\n    finset.is_well_founded_lt.wf.has_min { s : Finset (F.obj j) | ∃ (i : _)(f : «expr ⟶ » i j), ↑s = range (F.map f) }\n      ⟨_, i, hi, hf.coe_to_finset⟩\n  refine'\n    ⟨i, f, fun k g => (directed_on_range.mp <| F.ranges_directed j).is_bot_of_is_min ⟨⟨i, f⟩, rfl⟩ _ _ ⟨⟨k, g⟩, rfl⟩⟩\n  rintro _ ⟨⟨k', g'⟩, rfl⟩ hl\n  refine' (eq_of_le_of_not_lt hl _).ge\n  have := hmin _ ⟨k', g', (m.finite_to_set.subset <| hm.substr hl).coe_to_finset⟩\n  rwa [Finset.lt_iff_ssubset, ← Finset.coe_ssubset, set.finite.coe_to_finset, hm] at this\n#align is_mittag_leffler_of_exists_finite_range is_mittag_leffler_of_exists_finite_range\n\n",
 "is_mittag_leffler_iff_subset_range_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem is_mittag_leffler_iff_subset_range_comp :\n    F.is_mittag_leffler ↔\n      ∀ j : J,\n        ∃ (i : _)(f : «expr ⟶ » i j), ∀ ⦃k⦄ (g : «expr ⟶ » k i), range (F.map f) ⊆ range (F.map <| «expr ≫ » g f) :=\n  by simp_rw [is_mittag_leffler_iff_eventual_range, eventual_range_eq_iff]\n#align is_mittag_leffler_iff_subset_range_comp is_mittag_leffler_iff_subset_range_comp\n\n",
 "is_mittag_leffler_iff_eventual_range":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem is_mittag_leffler_iff_eventual_range :\n    F.is_mittag_leffler ↔ ∀ j : J, ∃ (i : _)(f : «expr ⟶ » i j), F.eventual_range j = range (F.map f) :=\n  forall_congr' fun j =>\n    exists₂_congr fun i f => ⟨fun h => (interᵢ₂_subset _ _).antisymm <| subset_interᵢ₂ h, fun h => h ▸ Inter₂_subset⟩\n#align is_mittag_leffler_iff_eventual_range is_mittag_leffler_iff_eventual_range\n\n",
 "eventual_range_maps_to":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem eventual_range_maps_to (f : «expr ⟶ » j i) : (F.eventual_range j).maps_to (F.map f) (F.eventual_range i) :=\n  fun x hx => by\n  rw [mem_eventual_range_iff] at hx⊢\n  intro k f'\n  obtain ⟨l, g, g', he⟩ := cospan f f'\n  obtain ⟨x, rfl⟩ := hx g\n  rw [← map_comp_apply, he, F.map_comp]\n  exact ⟨_, rfl⟩\n#align eventual_range_maps_to eventual_range_maps_to\n\n",
 "eventual_range_eq_range_precomp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem eventual_range_eq_range_precomp (f : «expr ⟶ » i j) (g : «expr ⟶ » j k)\n    (h : F.eventual_range k = range (F.map g)) : F.eventual_range k = range (F.map <| «expr ≫ » f g) :=\n  by\n  apply subset_antisymm\n  · apply Inter₂_subset\n  · rw [h, F.map_comp]\n    apply range_comp_subset_range\n#align eventual_range_eq_range_precomp eventual_range_eq_range_precomp\n\n",
 "eventual_range_eq_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem eventual_range_eq_iff {f : «expr ⟶ » i j} :\n    F.eventual_range j = range (F.map f) ↔\n      ∀ ⦃k⦄ (g : «expr ⟶ » k i), range (F.map f) ⊆ range (F.map <| «expr ≫ » g f) :=\n  by\n  rw [subset_antisymm_iff, eventual_range, and_iff_right (Inter₂_subset _ _), subset_Inter₂_iff]\n  refine' ⟨fun h k g => h _ _, fun h j' f' => _⟩\n  obtain ⟨k, g, g', he⟩ := cospan f f'\n  refine' (h g).trans _\n  rw [he, F.map_comp]\n  apply range_comp_subset_range\n#align eventual_range_eq_iff eventual_range_eq_iff\n\n",
 "eq_image_eventual_range":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem is_mittag_leffler.eq_image_eventual_range (h : F.is_mittag_leffler) (f : «expr ⟶ » j i) :\n    F.eventual_range i = «expr '' » (F.map f) (F.eventual_range j) :=\n  (h.subset_image_eventual_range F f).antisymm <| mapsTo'.1 (F.eventual_range_maps_to f)\n#align is_mittag_leffler.eq_image_eventual_range is_mittag_leffler.eq_image_eventual_range\n\n"}