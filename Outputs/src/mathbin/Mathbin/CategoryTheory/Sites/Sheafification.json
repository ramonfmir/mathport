{"to_sheafify_sheafify_lift":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵖ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem to_sheafify_sheafify_lift {P Q : «expr ⥤ » («expr ᵒᵖ» C) D} (η : «expr ⟶ » P Q) (hQ : Presheaf.IsSheaf J Q) :\n    «expr ≫ » (J.to_sheafify P) (sheafifyLift J η hQ) = η :=\n  by\n  dsimp only [sheafify_lift, to_sheafify]\n  simp\n#align to_sheafify_sheafify_lift to_sheafify_sheafify_lift\n\n",
 "to_sheafify_naturality":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵖ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem to_sheafify_naturality {P Q : «expr ⥤ » («expr ᵒᵖ» C) D} (η : «expr ⟶ » P Q) :\n    «expr ≫ » η (J.to_sheafify _) = «expr ≫ » (J.to_sheafify _) (J.sheafify_map η) :=\n  by\n  dsimp [sheafify_map, sheafify, to_sheafify]\n  simp\n#align to_sheafify_naturality to_sheafify_naturality\n\n",
 "to_sheafification_app":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵖ» -/\n@[simp]\ntheorem to_sheafification_app (P : «expr ⥤ » («expr ᵒᵖ» C) D) : (J.to_sheafification D).app P = J.to_sheafify P :=\n  rfl\n#align to_sheafification_app to_sheafification_app\n\n",
 "to_plus_mk":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵖ» -/\ntheorem to_plus_mk {X : C} {P : «expr ⥤ » («expr ᵒᵖ» C) D} (S : J.cover X) (x : P.obj (op X)) :\n    (J.to_plus P).app _ x = mk (Meq.mk S x) := by\n  dsimp [mk, to_plus]\n  let e : «expr ⟶ » S («expr⊤») := hom_of_le (order_top.le_top _)\n  rw [← colimit.w _ e.op]\n  delta cover.to_multiequalizer\n  simp only [comp_apply]\n  congr 1\n  dsimp [diagram]\n  apply concrete.multiequalizer_ext\n  intro i\n  simpa only [← comp_apply, category.assoc, multiequalizer.lift_ι, category.comp_id, meq.equiv_symm_eq_apply]\n#align to_plus_mk to_plus_mk\n\n",
 "to_plus_eq_mk":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵖ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem to_plus_eq_mk {X : C} {P : «expr ⥤ » («expr ᵒᵖ» C) D} (x : P.obj (op X)) :\n    (J.to_plus P).app _ x = mk (Meq.mk («expr⊤») x) :=\n  by\n  dsimp [mk, to_plus]\n  delta cover.to_multiequalizer\n  simp only [comp_apply]\n  congr 1\n  apply_fun meq.equiv P («expr⊤»)\n  ext i\n  simpa\n#align to_plus_eq_mk to_plus_eq_mk\n\n",
 "to_plus_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵖ» -/\ntheorem to_plus_apply {X : C} {P : «expr ⥤ » («expr ᵒᵖ» C) D} (S : J.cover X) (x : Meq P S) (I : S.arrow) :\n    (J.to_plus P).app _ (x I) = (J.plus_obj P).map I.f.op (mk x) :=\n  by\n  dsimp only [to_plus, plus_obj]\n  delta cover.to_multiequalizer\n  dsimp [mk]\n  simp only [← comp_apply, colimit.ι_pre, ι_colim_map_assoc]\n  simp only [comp_apply]\n  dsimp only [functor.op]\n  let e : «expr ⟶ » ((J.pullback I.f).obj (unop (op S))) («expr⊤») := hom_of_le (order_top.le_top _)\n  rw [← colimit.w _ e.op]\n  simp only [comp_apply]\n  congr 1\n  apply concrete.multiequalizer_ext\n  intro i\n  dsimp [diagram]\n  simp only [← comp_apply, category.assoc, multiequalizer.lift_ι, category.comp_id, meq.equiv_symm_eq_apply]\n  let RR : S.relation :=\n    ⟨_, _, _, i.f, («expr𝟙») _, I.f, «expr ≫ » i.f I.f, I.hf, sieve.downward_closed _ I.hf _, by simp⟩\n  cases I\n  erw [x.condition RR]\n  simpa [RR]\n#align to_plus_apply to_plus_apply\n\n",
 "sheafify_map_sheafify_lift":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵖ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem sheafify_map_sheafify_lift {P Q R : «expr ⥤ » («expr ᵒᵖ» C) D} (η : «expr ⟶ » P Q) (γ : «expr ⟶ » Q R)\n    (hR : Presheaf.IsSheaf J R) :\n    «expr ≫ » (J.sheafify_map η) (J.sheafify_lift γ hR) = J.sheafify_lift («expr ≫ » η γ) hR :=\n  by\n  apply J.sheafify_lift_unique\n  rw [← category.assoc, ← J.to_sheafify_naturality, category.assoc, to_sheafify_sheafify_lift]\n#align sheafify_map_sheafify_lift sheafify_map_sheafify_lift\n\n",
 "sheafify_map_id":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵖ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n@[simp]\ntheorem sheafify_map_id (P : «expr ⥤ » («expr ᵒᵖ» C) D) : J.sheafify_map ((«expr𝟙») P) = («expr𝟙») (J.sheafify P) :=\n  by\n  dsimp [sheafify_map, sheafify]\n  simp\n#align sheafify_map_id sheafify_map_id\n\n",
 "sheafify_map_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵖ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp]\ntheorem sheafify_map_comp {P Q R : «expr ⥤ » («expr ᵒᵖ» C) D} (η : «expr ⟶ » P Q) (γ : «expr ⟶ » Q R) :\n    J.sheafify_map («expr ≫ » η γ) = «expr ≫ » (J.sheafify_map η) (J.sheafify_map γ) :=\n  by\n  dsimp [sheafify_map, sheafify]\n  simp\n#align sheafify_map_comp sheafify_map_comp\n\n",
 "sheafify_lift_unique":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵖ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem sheafify_lift_unique {P Q : «expr ⥤ » («expr ᵒᵖ» C) D} (η : «expr ⟶ » P Q) (hQ : Presheaf.IsSheaf J Q)\n    (γ : «expr ⟶ » (J.sheafify P) Q) : «expr ≫ » (J.to_sheafify P) γ = η → γ = sheafifyLift J η hQ :=\n  by\n  intro h\n  apply plus_lift_unique\n  apply plus_lift_unique\n  rw [← category.assoc, ← plus_map_to_plus]\n  exact h\n#align sheafify_lift_unique sheafify_lift_unique\n\n",
 "sheafify_is_sheaf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵖ» -/\ntheorem grothendieck_topology.sheafify_is_sheaf (P : «expr ⥤ » («expr ᵒᵖ» C) D) : Presheaf.IsSheaf J (J.sheafify P) :=\n  GrothendieckTopology.Plus.isSheaf_plus_plus _ _\n#align grothendieck_topology.sheafify_is_sheaf grothendieck_topology.sheafify_is_sheaf\n\n",
 "sheafify_hom_ext":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵖ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem sheafify_hom_ext {P Q : «expr ⥤ » («expr ᵒᵖ» C) D} (η γ : «expr ⟶ » (J.sheafify P) Q)\n    (hQ : Presheaf.IsSheaf J Q) (h : «expr ≫ » (J.to_sheafify P) η = «expr ≫ » (J.to_sheafify P) γ) : η = γ :=\n  by\n  apply J.plus_hom_ext _ _ hQ\n  apply J.plus_hom_ext _ _ hQ\n  rw [← category.assoc, ← category.assoc, ← plus_map_to_plus]\n  exact h\n#align sheafify_hom_ext sheafify_hom_ext\n\n",
 "sheafification_obj":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵖ» -/\n@[simp]\ntheorem sheafification_obj (P : «expr ⥤ » («expr ᵒᵖ» C) D) : (J.sheafification D).obj P = J.sheafify P :=\n  rfl\n#align sheafification_obj sheafification_obj\n\n",
 "sheafification_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵖ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n@[simp]\ntheorem sheafification_map {P Q : «expr ⥤ » («expr ᵒᵖ» C) D} (η : «expr ⟶ » P Q) :\n    (J.sheafification D).map η = J.sheafify_map η :=\n  rfl\n#align sheafification_map sheafification_map\n\n",
 "sep":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵖ» -/\n/-- `P⁺` is always separated. -/\ntheorem sep {X : C} (P : «expr ⥤ » («expr ᵒᵖ» C) D) (S : J.cover X) (x y : (J.plus_obj P).obj (op X))\n    (h : ∀ I : S.arrow, (J.plus_obj P).map I.f.op x = (J.plus_obj P).map I.f.op y) : x = y :=\n  by\n  -- First, we choose representatives for x and y.\n  obtain ⟨Sx, x, rfl⟩ := exists_rep x\n  obtain ⟨Sy, y, rfl⟩ := exists_rep y\n  simp only [res_mk_eq_mk_pullback] at h\n  -- Next, using our assumption,\n  -- choose covers over which the pullbacks of these representatives become equal.\n  choose W h1 h2 hh using fun I : S.arrow => (eq_mk_iff_exists _ _).mp (h I)\n  -- To prove equality, it suffices to prove that there exists a cover over which\n  -- the representatives become equal.\n  rw [eq_mk_iff_exists]\n  -- Construct the cover over which the representatives become equal by combining the various\n  -- covers chosen above.\n  let B : J.cover X := S.bind W\n  use B\n  -- Prove that this cover refines the two covers over which our representatives are defined\n  -- and use these proofs.\n  let ex : «expr ⟶ » B Sx :=\n    hom_of_le\n      (by\n        rintro Y f ⟨Z, e1, e2, he2, he1, hee⟩\n        rw [← hee]\n        apply le_of_hom (h1 ⟨_, _, he2⟩)\n        exact he1)\n  let ey : «expr ⟶ » B Sy :=\n    hom_of_le\n      (by\n        rintro Y f ⟨Z, e1, e2, he2, he1, hee⟩\n        rw [← hee]\n        apply le_of_hom (h2 ⟨_, _, he2⟩)\n        exact he1)\n  use ex, ey\n  -- Now prove that indeed the representatives become equal over `B`.\n  -- This will follow by using the fact that our representatives become\n  -- equal over the chosen covers.\n  ext1 I\n  let IS : S.arrow := I.from_middle\n  specialize hh IS\n  let IW : (W IS).arrow := I.to_middle\n  apply_fun fun e => e IW  at hh\n  convert hh\n  · let Rx : Sx.relation :=\n      ⟨I.Y, I.Y, I.Y, («expr𝟙») _, («expr𝟙») _, I.f, «expr ≫ » I.to_middle_hom I.from_middle_hom, _, _, by\n        simp [I.middle_spec]⟩\n    have := x.condition Rx\n    simpa using this\n  · let Ry : Sy.relation :=\n      ⟨I.Y, I.Y, I.Y, («expr𝟙») _, («expr𝟙») _, I.f, «expr ≫ » I.to_middle_hom I.from_middle_hom, _, _, by\n        simp [I.middle_spec]⟩\n    have := y.condition Ry\n    simpa using this\n#align sep sep\n\n",
 "res_mk_eq_mk_pullback":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵖ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem res_mk_eq_mk_pullback {Y X : C} {P : «expr ⥤ » («expr ᵒᵖ» C) D} {S : J.cover X} (x : Meq P S)\n    (f : «expr ⟶ » Y X) : (J.plus_obj P).map f.op (mk x) = mk (x.pullback f) :=\n  by\n  dsimp [mk, plus_obj]\n  simp only [← comp_apply, colimit.ι_pre, ι_colim_map_assoc]\n  simp_rw [comp_apply]\n  congr 1\n  apply_fun meq.equiv P _\n  erw [Equiv.apply_symm_apply]\n  ext i\n  simp only [diagram_pullback_app, meq.pullback_apply, meq.equiv_apply, ← comp_apply]\n  erw [multiequalizer.lift_ι, meq.equiv_symm_eq_apply]\n  cases i; rfl\n#align res_mk_eq_mk_pullback res_mk_eq_mk_pullback\n\n",
 "refine_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵖ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n@[simp]\ntheorem refine_apply {X : C} {P : «expr ⥤ » («expr ᵒᵖ» C) D} {S T : J.cover X} (x : Meq P T) (e : «expr ⟶ » S T)\n    (I : S.arrow) : x.refine e I = x ⟨I.Y, I.f, (leOfHom e) _ I.hf⟩ :=\n  rfl\n#align refine_apply refine_apply\n\n",
 "pullback_refine":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵖ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n@[simp]\ntheorem pullback_refine {Y X : C} {P : «expr ⥤ » («expr ᵒᵖ» C) D} {S T : J.cover X} (h : «expr ⟶ » S T)\n    (f : «expr ⟶ » Y X) (x : Meq P T) : (x.pullback f).refine ((J.pullback f).map h) = (refine x h).pullback _ :=\n  rfl\n#align pullback_refine pullback_refine\n\n",
 "pullback_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵖ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp]\ntheorem pullback_apply {Y X : C} {P : «expr ⥤ » («expr ᵒᵖ» C) D} {S : J.cover X} (x : Meq P S) (f : «expr ⟶ » Y X)\n    (I : ((J.pullback f).obj S).arrow) : x.pullback f I = x ⟨_, «expr ≫ » I.f f, I.hf⟩ :=\n  rfl\n#align pullback_apply pullback_apply\n\n",
 "mono_iff_presheaf_mono":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem Sheaf.hom.mono_iff_presheaf_mono {F G : Sheaf J D} (f : «expr ⟶ » F G) : Mono f ↔ Mono f.1 :=\n  ⟨fun m => by\n    skip\n    infer_instance, fun m => by\n    skip\n    exact Sheaf.hom.mono_of_presheaf_mono J D f⟩\n#align Sheaf.hom.mono_iff_presheaf_mono Sheaf.hom.mono_iff_presheaf_mono\n\n",
 "mk_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵖ» -/\ntheorem mk_apply {X : C} {P : «expr ⥤ » («expr ᵒᵖ» C) D} (S : J.cover X) (x : P.obj (op X)) (I : S.arrow) :\n    mk S x I = P.map I.f.op x :=\n  rfl\n#align mk_apply mk_apply\n\n",
 "iso_sheafify_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵖ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n@[simp]\ntheorem iso_sheafify_inv {P : «expr ⥤ » («expr ᵒᵖ» C) D} (hP : Presheaf.IsSheaf J P) :\n    (J.iso_sheafify hP).inv = J.sheafify_lift ((«expr𝟙») _) hP :=\n  by\n  apply J.sheafify_lift_unique\n  simp [iso.comp_inv_eq]\n#align iso_sheafify_inv iso_sheafify_inv\n\n",
 "iso_sheafify_hom":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵖ» -/\n@[simp]\ntheorem iso_sheafify_hom {P : «expr ⥤ » («expr ᵒᵖ» C) D} (hP : Presheaf.IsSheaf J P) :\n    (J.iso_sheafify hP).hom = J.to_sheafify P :=\n  rfl\n#align iso_sheafify_hom iso_sheafify_hom\n\n",
 "is_sheaf_plus_plus":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵖ» -/\n/-- `P⁺⁺` is always a sheaf. -/\ntheorem is_sheaf_plus_plus (P : «expr ⥤ » («expr ᵒᵖ» C) D) : Presheaf.IsSheaf J (J.plus_obj (J.plus_obj P)) :=\n  by\n  apply is_sheaf_of_sep\n  intro X S x y\n  apply sep\n#align is_sheaf_plus_plus is_sheaf_plus_plus\n\n",
 "is_sheaf_of_sep":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵖ» -/\n/-- If `P` is separated, then `P⁺` is a sheaf. -/\ntheorem is_sheaf_of_sep (P : «expr ⥤ » («expr ᵒᵖ» C) D)\n    (hsep : ∀ (X : C) (S : J.cover X) (x y : P.obj (op X)), (∀ I : S.arrow, P.map I.f.op x = P.map I.f.op y) → x = y) :\n    Presheaf.IsSheaf J (J.plus_obj P) :=\n  by\n  rw [presheaf.is_sheaf_iff_multiequalizer]\n  intro X S\n  apply is_iso_of_reflects_iso _ (forget D)\n  rw [is_iso_iff_bijective]\n  constructor\n  · intro x y h\n    apply sep P S _ _\n    intro I\n    apply_fun meq.equiv _ _  at h\n    apply_fun fun e => e I  at h\n    convert h\n    · erw [meq.equiv_apply, ← comp_apply, multiequalizer.lift_ι]\n    · erw [meq.equiv_apply, ← comp_apply, multiequalizer.lift_ι]\n  · rintro (x : (multiequalizer (S.index _) : D))\n    obtain ⟨t, ht⟩ := exists_of_sep P hsep X S (meq.equiv _ _ x)\n    use t\n    apply_fun meq.equiv _ _\n    swap\n    · infer_instance\n    rw [← ht]\n    ext i\n    dsimp\n    rw [← comp_apply, multiequalizer.lift_ι]\n    rfl\n#align is_sheaf_of_sep is_sheaf_of_sep\n\n",
 "is_iso_to_sheafify":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵖ» -/\ntheorem is_iso_to_sheafify {P : «expr ⥤ » («expr ᵒᵖ» C) D} (hP : Presheaf.IsSheaf J P) : IsIso (J.to_sheafify P) :=\n  by\n  dsimp [to_sheafify]\n  haveI : is_iso (J.to_plus P) := by apply is_iso_to_plus_of_is_sheaf J P hP\n  haveI : is_iso ((J.plus_functor D).map (J.to_plus P)) := by apply functor.map_is_iso\n  exact @is_iso.comp_is_iso _ _ _ _ _ (J.to_plus P) ((J.plus_functor D).map (J.to_plus P)) _ _\n#align is_iso_to_sheafify is_iso_to_sheafify\n\n",
 "inj_of_sep":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵖ» -/\ntheorem inj_of_sep (P : «expr ⥤ » («expr ᵒᵖ» C) D)\n    (hsep : ∀ (X : C) (S : J.cover X) (x y : P.obj (op X)), (∀ I : S.arrow, P.map I.f.op x = P.map I.f.op y) → x = y)\n    (X : C) : function.injective ((J.to_plus P).app (op X)) :=\n  by\n  intro x y h\n  simp only [to_plus_eq_mk] at h\n  rw [eq_mk_iff_exists] at h\n  obtain ⟨W, h1, h2, hh⟩ := h\n  apply hsep X W\n  intro I\n  apply_fun fun e => e I  at hh\n  exact hh\n#align inj_of_sep inj_of_sep\n\n",
 "ext":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵖ» -/\n/-\nCopyright (c) 2021 Adam Topaz. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Adam Topaz\n-/\n@[ext]\ntheorem ext {X} {P : «expr ⥤ » («expr ᵒᵖ» C) D} {S : J.cover X} (x y : Meq P S) (h : ∀ I : S.arrow, x I = y I) :\n    x = y :=\n  Subtype.ext <| funext <| h\n#align ext ext\n\n",
 "exists_rep":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵖ» -/\ntheorem exists_rep {X : C} {P : «expr ⥤ » («expr ᵒᵖ» C) D} (x : (J.plus_obj P).obj (op X)) :\n    ∃ (S : J.cover X)(y : Meq P S), x = mk y :=\n  by\n  obtain ⟨S, y, h⟩ := concrete.colimit_exists_rep (J.diagram P X) x\n  use S.unop, meq.equiv _ _ y\n  rw [← h]\n  dsimp [mk]\n  simp\n#align exists_rep exists_rep\n\n",
 "exists_of_sep":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵖ» -/\ntheorem exists_of_sep (P : «expr ⥤ » («expr ᵒᵖ» C) D)\n    (hsep : ∀ (X : C) (S : J.cover X) (x y : P.obj (op X)), (∀ I : S.arrow, P.map I.f.op x = P.map I.f.op y) → x = y)\n    (X : C) (S : J.cover X) (s : Meq (J.plus_obj P) S) : ∃ t : (J.plus_obj P).obj (op X), Meq.mk S t = s :=\n  by\n  have inj : ∀ X : C, function.injective ((J.to_plus P).app (op X)) := inj_of_sep _ hsep\n  -- Choose representatives for the given local sections.\n  choose T t ht using fun I => exists_rep (s I)\n  -- Construct a large cover over which we will define a representative that will\n  -- provide the gluing of the given local sections.\n  let B : J.cover X := S.bind T\n  choose Z e1 e2 he2 he1 hee using fun I : B.arrow => I.hf\n  -- Construct a compatible system of local sections over this large cover, using the chosen\n  -- representatives of our local sections.\n  -- The compatilibity here follows from the separatedness assumption.\n  let w : meq P B := meq_of_sep P hsep X S s T t ht\n  -- The associated gluing will be the candidate section.\n  use mk w\n  ext I\n  erw [ht, res_mk_eq_mk_pullback]\n  -- Use the separatedness of `P⁺` to prove that this is indeed a gluing of our\n  -- original local sections.\n  apply sep P (T I)\n  intro II\n  simp only [res_mk_eq_mk_pullback, eq_mk_iff_exists]\n  -- It suffices to prove equality for representatives over a\n  -- convenient sufficiently large cover...\n  use (J.pullback II.f).obj (T I)\n  let e0 : «expr ⟶ » ((J.pullback II.f).obj (T I)) ((J.pullback II.f).obj ((J.pullback I.f).obj B)) :=\n    hom_of_le\n      (by\n        intro Y f hf\n        apply sieve.le_pullback_bind _ _ _ I.hf\n        · cases I\n          exact hf)\n  use e0, («expr𝟙») _\n  ext IV\n  dsimp only [meq.refine_apply, meq.pullback_apply, w]\n  let IA : B.arrow := ⟨_, «expr ≫ » («expr ≫ » IV.f II.f) I.f, _⟩\n  swap\n  · refine' ⟨I.Y, _, _, I.hf, _, rfl⟩\n    apply sieve.downward_closed\n    convert II.hf\n    cases I\n    rfl\n  let IB : S.arrow := IA.from_middle\n  let IC : (T IB).arrow := IA.to_middle\n  let ID : (T I).arrow := ⟨IV.Y, «expr ≫ » IV.f II.f, sieve.downward_closed (T I) II.hf IV.f⟩\n  change t IB IC = t I ID\n  apply inj IV.Y\n  erw [to_plus_apply (T I) (t I) ID, to_plus_apply (T IB) (t IB) IC, ← ht, ← ht]\n  -- Conclude by constructing the relation showing equality...\n  let IR : S.relation := ⟨_, _, IV.Y, IC.f, ID.f, IB.f, I.f, _, I.hf, IA.middle_spec⟩\n  convert s.condition IR\n  cases I; rfl\n#align exists_of_sep exists_of_sep\n\n",
 "equiv_symm_eq_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵖ» -/\n@[simp]\ntheorem equiv_symm_eq_apply {X : C} {P : «expr ⥤ » («expr ᵒᵖ» C) D} {S : J.cover X} [HasMultiequalizer (S.index P)]\n    (x : Meq P S) (I : S.arrow) : Multiequalizer.ι (S.index P) I ((Meq.equiv P S).symm x) = x I :=\n  by\n  let z := (meq.equiv P S).symm x\n  rw [← equiv_apply]\n  simp\n#align equiv_symm_eq_apply equiv_symm_eq_apply\n\n",
 "equiv_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵖ» -/\n@[simp]\ntheorem equiv_apply {X : C} {P : «expr ⥤ » («expr ᵒᵖ» C) D} {S : J.cover X} [HasMultiequalizer (S.index P)]\n    (x : multiequalizer (S.index P)) (I : S.arrow) : equiv P S x I = Multiequalizer.ι (S.index P) I x :=\n  rfl\n#align equiv_apply equiv_apply\n\n",
 "eq_mk_iff_exists":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵖ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem eq_mk_iff_exists {X : C} {P : «expr ⥤ » («expr ᵒᵖ» C) D} {S T : J.cover X} (x : Meq P S) (y : Meq P T) :\n    mk x = mk y ↔ ∃ (W : J.cover X)(h1 : «expr ⟶ » W S)(h2 : «expr ⟶ » W T), x.refine h1 = y.refine h2 :=\n  by\n  constructor\n  · intro h\n    obtain ⟨W, h1, h2, hh⟩ := concrete.colimit_exists_of_rep_eq _ _ _ h\n    use W.unop, h1.unop, h2.unop\n    ext I\n    apply_fun multiequalizer.ι (W.unop.index P) I  at hh\n    convert hh\n    all_goals\n      dsimp [diagram]\n      simp only [← comp_apply, multiequalizer.lift_ι, category.comp_id, meq.equiv_symm_eq_apply]\n      cases I; rfl\n  · rintro ⟨S, h1, h2, e⟩\n    apply concrete.colimit_rep_eq_of_exists\n    use op S, h1.op, h2.op\n    apply concrete.multiequalizer_ext\n    intro i\n    apply_fun fun ee => ee i  at e\n    convert e\n    all_goals\n      dsimp [diagram]\n      simp only [← comp_apply, multiequalizer.lift_ι, meq.equiv_symm_eq_apply]\n      cases i; rfl\n#align eq_mk_iff_exists eq_mk_iff_exists\n\n",
 "condition":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵖ» -/\ntheorem condition {X} {P : «expr ⥤ » («expr ᵒᵖ» C) D} {S : J.cover X} (x : Meq P S) (I : S.relation) :\n    P.map I.g₁.op (x ((S.index P).fst_to I)) = P.map I.g₂.op (x ((S.index P).snd_to I)) :=\n  x.2 _\n#align condition condition\n\n"}