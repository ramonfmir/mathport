{"to_sheafify_sheafify_lift":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr áµ’áµ–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n@[simp, reassoc.1]\ntheorem to_sheafify_sheafify_lift {P Q : Â«expr â¥¤ Â» (Â«expr áµ’áµ–Â» C) D} (Î· : Â«expr âŸ¶ Â» P Q) (hQ : Presheaf.IsSheaf J Q) :\n    Â«expr â‰« Â» (J.to_sheafify P) (sheafifyLift J Î· hQ) = Î· :=\n  by\n  dsimp only [sheafify_lift, to_sheafify]\n  simp\n#align to_sheafify_sheafify_lift to_sheafify_sheafify_lift\n\n",
 "to_sheafify_naturality":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr áµ’áµ–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n@[simp, reassoc.1]\ntheorem to_sheafify_naturality {P Q : Â«expr â¥¤ Â» (Â«expr áµ’áµ–Â» C) D} (Î· : Â«expr âŸ¶ Â» P Q) :\n    Â«expr â‰« Â» Î· (J.to_sheafify _) = Â«expr â‰« Â» (J.to_sheafify _) (J.sheafify_map Î·) :=\n  by\n  dsimp [sheafify_map, sheafify, to_sheafify]\n  simp\n#align to_sheafify_naturality to_sheafify_naturality\n\n",
 "to_sheafification_app":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr áµ’áµ–Â» -/\n@[simp]\ntheorem to_sheafification_app (P : Â«expr â¥¤ Â» (Â«expr áµ’áµ–Â» C) D) : (J.to_sheafification D).app P = J.to_sheafify P :=\n  rfl\n#align to_sheafification_app to_sheafification_app\n\n",
 "to_plus_mk":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr áµ’áµ–Â» -/\ntheorem to_plus_mk {X : C} {P : Â«expr â¥¤ Â» (Â«expr áµ’áµ–Â» C) D} (S : J.cover X) (x : P.obj (op X)) :\n    (J.to_plus P).app _ x = mk (Meq.mk S x) := by\n  dsimp [mk, to_plus]\n  let e : Â«expr âŸ¶ Â» S (Â«exprâŠ¤Â») := hom_of_le (order_top.le_top _)\n  rw [â† colimit.w _ e.op]\n  delta cover.to_multiequalizer\n  simp only [comp_apply]\n  congr 1\n  dsimp [diagram]\n  apply concrete.multiequalizer_ext\n  intro i\n  simpa only [â† comp_apply, category.assoc, multiequalizer.lift_Î¹, category.comp_id, meq.equiv_symm_eq_apply]\n#align to_plus_mk to_plus_mk\n\n",
 "to_plus_eq_mk":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr áµ’áµ–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\ntheorem to_plus_eq_mk {X : C} {P : Â«expr â¥¤ Â» (Â«expr áµ’áµ–Â» C) D} (x : P.obj (op X)) :\n    (J.to_plus P).app _ x = mk (Meq.mk (Â«exprâŠ¤Â») x) :=\n  by\n  dsimp [mk, to_plus]\n  delta cover.to_multiequalizer\n  simp only [comp_apply]\n  congr 1\n  apply_fun meq.equiv P (Â«exprâŠ¤Â»)\n  ext i\n  simpa\n#align to_plus_eq_mk to_plus_eq_mk\n\n",
 "to_plus_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr áµ’áµ–Â» -/\ntheorem to_plus_apply {X : C} {P : Â«expr â¥¤ Â» (Â«expr áµ’áµ–Â» C) D} (S : J.cover X) (x : Meq P S) (I : S.arrow) :\n    (J.to_plus P).app _ (x I) = (J.plus_obj P).map I.f.op (mk x) :=\n  by\n  dsimp only [to_plus, plus_obj]\n  delta cover.to_multiequalizer\n  dsimp [mk]\n  simp only [â† comp_apply, colimit.Î¹_pre, Î¹_colim_map_assoc]\n  simp only [comp_apply]\n  dsimp only [functor.op]\n  let e : Â«expr âŸ¶ Â» ((J.pullback I.f).obj (unop (op S))) (Â«exprâŠ¤Â») := hom_of_le (order_top.le_top _)\n  rw [â† colimit.w _ e.op]\n  simp only [comp_apply]\n  congr 1\n  apply concrete.multiequalizer_ext\n  intro i\n  dsimp [diagram]\n  simp only [â† comp_apply, category.assoc, multiequalizer.lift_Î¹, category.comp_id, meq.equiv_symm_eq_apply]\n  let RR : S.relation :=\n    âŸ¨_, _, _, i.f, (Â«exprğŸ™Â») _, I.f, Â«expr â‰« Â» i.f I.f, I.hf, sieve.downward_closed _ I.hf _, by simpâŸ©\n  cases I\n  erw [x.condition RR]\n  simpa [RR]\n#align to_plus_apply to_plus_apply\n\n",
 "sheafify_map_sheafify_lift":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr áµ’áµ–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n@[simp, reassoc.1]\ntheorem sheafify_map_sheafify_lift {P Q R : Â«expr â¥¤ Â» (Â«expr áµ’áµ–Â» C) D} (Î· : Â«expr âŸ¶ Â» P Q) (Î³ : Â«expr âŸ¶ Â» Q R)\n    (hR : Presheaf.IsSheaf J R) :\n    Â«expr â‰« Â» (J.sheafify_map Î·) (J.sheafify_lift Î³ hR) = J.sheafify_lift (Â«expr â‰« Â» Î· Î³) hR :=\n  by\n  apply J.sheafify_lift_unique\n  rw [â† category.assoc, â† J.to_sheafify_naturality, category.assoc, to_sheafify_sheafify_lift]\n#align sheafify_map_sheafify_lift sheafify_map_sheafify_lift\n\n",
 "sheafify_map_id":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr áµ’áµ–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n@[simp]\ntheorem sheafify_map_id (P : Â«expr â¥¤ Â» (Â«expr áµ’áµ–Â» C) D) : J.sheafify_map ((Â«exprğŸ™Â») P) = (Â«exprğŸ™Â») (J.sheafify P) :=\n  by\n  dsimp [sheafify_map, sheafify]\n  simp\n#align sheafify_map_id sheafify_map_id\n\n",
 "sheafify_map_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr áµ’áµ–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n@[simp]\ntheorem sheafify_map_comp {P Q R : Â«expr â¥¤ Â» (Â«expr áµ’áµ–Â» C) D} (Î· : Â«expr âŸ¶ Â» P Q) (Î³ : Â«expr âŸ¶ Â» Q R) :\n    J.sheafify_map (Â«expr â‰« Â» Î· Î³) = Â«expr â‰« Â» (J.sheafify_map Î·) (J.sheafify_map Î³) :=\n  by\n  dsimp [sheafify_map, sheafify]\n  simp\n#align sheafify_map_comp sheafify_map_comp\n\n",
 "sheafify_lift_unique":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr áµ’áµ–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\ntheorem sheafify_lift_unique {P Q : Â«expr â¥¤ Â» (Â«expr áµ’áµ–Â» C) D} (Î· : Â«expr âŸ¶ Â» P Q) (hQ : Presheaf.IsSheaf J Q)\n    (Î³ : Â«expr âŸ¶ Â» (J.sheafify P) Q) : Â«expr â‰« Â» (J.to_sheafify P) Î³ = Î· â†’ Î³ = sheafifyLift J Î· hQ :=\n  by\n  intro h\n  apply plus_lift_unique\n  apply plus_lift_unique\n  rw [â† category.assoc, â† plus_map_to_plus]\n  exact h\n#align sheafify_lift_unique sheafify_lift_unique\n\n",
 "sheafify_is_sheaf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr áµ’áµ–Â» -/\ntheorem grothendieck_topology.sheafify_is_sheaf (P : Â«expr â¥¤ Â» (Â«expr áµ’áµ–Â» C) D) : Presheaf.IsSheaf J (J.sheafify P) :=\n  GrothendieckTopology.Plus.isSheaf_plus_plus _ _\n#align grothendieck_topology.sheafify_is_sheaf grothendieck_topology.sheafify_is_sheaf\n\n",
 "sheafify_hom_ext":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr áµ’áµ–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\ntheorem sheafify_hom_ext {P Q : Â«expr â¥¤ Â» (Â«expr áµ’áµ–Â» C) D} (Î· Î³ : Â«expr âŸ¶ Â» (J.sheafify P) Q)\n    (hQ : Presheaf.IsSheaf J Q) (h : Â«expr â‰« Â» (J.to_sheafify P) Î· = Â«expr â‰« Â» (J.to_sheafify P) Î³) : Î· = Î³ :=\n  by\n  apply J.plus_hom_ext _ _ hQ\n  apply J.plus_hom_ext _ _ hQ\n  rw [â† category.assoc, â† category.assoc, â† plus_map_to_plus]\n  exact h\n#align sheafify_hom_ext sheafify_hom_ext\n\n",
 "sheafification_obj":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr áµ’áµ–Â» -/\n@[simp]\ntheorem sheafification_obj (P : Â«expr â¥¤ Â» (Â«expr áµ’áµ–Â» C) D) : (J.sheafification D).obj P = J.sheafify P :=\n  rfl\n#align sheafification_obj sheafification_obj\n\n",
 "sheafification_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr áµ’áµ–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n@[simp]\ntheorem sheafification_map {P Q : Â«expr â¥¤ Â» (Â«expr áµ’áµ–Â» C) D} (Î· : Â«expr âŸ¶ Â» P Q) :\n    (J.sheafification D).map Î· = J.sheafify_map Î· :=\n  rfl\n#align sheafification_map sheafification_map\n\n",
 "sep":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr áµ’áµ–Â» -/\n/-- `Pâº` is always separated. -/\ntheorem sep {X : C} (P : Â«expr â¥¤ Â» (Â«expr áµ’áµ–Â» C) D) (S : J.cover X) (x y : (J.plus_obj P).obj (op X))\n    (h : âˆ€ I : S.arrow, (J.plus_obj P).map I.f.op x = (J.plus_obj P).map I.f.op y) : x = y :=\n  by\n  -- First, we choose representatives for x and y.\n  obtain âŸ¨Sx, x, rflâŸ© := exists_rep x\n  obtain âŸ¨Sy, y, rflâŸ© := exists_rep y\n  simp only [res_mk_eq_mk_pullback] at h\n  -- Next, using our assumption,\n  -- choose covers over which the pullbacks of these representatives become equal.\n  choose W h1 h2 hh using fun I : S.arrow => (eq_mk_iff_exists _ _).mp (h I)\n  -- To prove equality, it suffices to prove that there exists a cover over which\n  -- the representatives become equal.\n  rw [eq_mk_iff_exists]\n  -- Construct the cover over which the representatives become equal by combining the various\n  -- covers chosen above.\n  let B : J.cover X := S.bind W\n  use B\n  -- Prove that this cover refines the two covers over which our representatives are defined\n  -- and use these proofs.\n  let ex : Â«expr âŸ¶ Â» B Sx :=\n    hom_of_le\n      (by\n        rintro Y f âŸ¨Z, e1, e2, he2, he1, heeâŸ©\n        rw [â† hee]\n        apply le_of_hom (h1 âŸ¨_, _, he2âŸ©)\n        exact he1)\n  let ey : Â«expr âŸ¶ Â» B Sy :=\n    hom_of_le\n      (by\n        rintro Y f âŸ¨Z, e1, e2, he2, he1, heeâŸ©\n        rw [â† hee]\n        apply le_of_hom (h2 âŸ¨_, _, he2âŸ©)\n        exact he1)\n  use ex, ey\n  -- Now prove that indeed the representatives become equal over `B`.\n  -- This will follow by using the fact that our representatives become\n  -- equal over the chosen covers.\n  ext1 I\n  let IS : S.arrow := I.from_middle\n  specialize hh IS\n  let IW : (W IS).arrow := I.to_middle\n  apply_fun fun e => e IW  at hh\n  convert hh\n  Â· let Rx : Sx.relation :=\n      âŸ¨I.Y, I.Y, I.Y, (Â«exprğŸ™Â») _, (Â«exprğŸ™Â») _, I.f, Â«expr â‰« Â» I.to_middle_hom I.from_middle_hom, _, _, by\n        simp [I.middle_spec]âŸ©\n    have := x.condition Rx\n    simpa using this\n  Â· let Ry : Sy.relation :=\n      âŸ¨I.Y, I.Y, I.Y, (Â«exprğŸ™Â») _, (Â«exprğŸ™Â») _, I.f, Â«expr â‰« Â» I.to_middle_hom I.from_middle_hom, _, _, by\n        simp [I.middle_spec]âŸ©\n    have := y.condition Ry\n    simpa using this\n#align sep sep\n\n",
 "res_mk_eq_mk_pullback":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr áµ’áµ–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem res_mk_eq_mk_pullback {Y X : C} {P : Â«expr â¥¤ Â» (Â«expr áµ’áµ–Â» C) D} {S : J.cover X} (x : Meq P S)\n    (f : Â«expr âŸ¶ Â» Y X) : (J.plus_obj P).map f.op (mk x) = mk (x.pullback f) :=\n  by\n  dsimp [mk, plus_obj]\n  simp only [â† comp_apply, colimit.Î¹_pre, Î¹_colim_map_assoc]\n  simp_rw [comp_apply]\n  congr 1\n  apply_fun meq.equiv P _\n  erw [Equiv.apply_symm_apply]\n  ext i\n  simp only [diagram_pullback_app, meq.pullback_apply, meq.equiv_apply, â† comp_apply]\n  erw [multiequalizer.lift_Î¹, meq.equiv_symm_eq_apply]\n  cases i; rfl\n#align res_mk_eq_mk_pullback res_mk_eq_mk_pullback\n\n",
 "refine_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr áµ’áµ–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n@[simp]\ntheorem refine_apply {X : C} {P : Â«expr â¥¤ Â» (Â«expr áµ’áµ–Â» C) D} {S T : J.cover X} (x : Meq P T) (e : Â«expr âŸ¶ Â» S T)\n    (I : S.arrow) : x.refine e I = x âŸ¨I.Y, I.f, (leOfHom e) _ I.hfâŸ© :=\n  rfl\n#align refine_apply refine_apply\n\n",
 "pullback_refine":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr áµ’áµ–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n@[simp]\ntheorem pullback_refine {Y X : C} {P : Â«expr â¥¤ Â» (Â«expr áµ’áµ–Â» C) D} {S T : J.cover X} (h : Â«expr âŸ¶ Â» S T)\n    (f : Â«expr âŸ¶ Â» Y X) (x : Meq P T) : (x.pullback f).refine ((J.pullback f).map h) = (refine x h).pullback _ :=\n  rfl\n#align pullback_refine pullback_refine\n\n",
 "pullback_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr áµ’áµ–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n@[simp]\ntheorem pullback_apply {Y X : C} {P : Â«expr â¥¤ Â» (Â«expr áµ’áµ–Â» C) D} {S : J.cover X} (x : Meq P S) (f : Â«expr âŸ¶ Â» Y X)\n    (I : ((J.pullback f).obj S).arrow) : x.pullback f I = x âŸ¨_, Â«expr â‰« Â» I.f f, I.hfâŸ© :=\n  rfl\n#align pullback_apply pullback_apply\n\n",
 "mono_iff_presheaf_mono":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem Sheaf.hom.mono_iff_presheaf_mono {F G : Sheaf J D} (f : Â«expr âŸ¶ Â» F G) : Mono f â†” Mono f.1 :=\n  âŸ¨fun m => by\n    skip\n    infer_instance, fun m => by\n    skip\n    exact Sheaf.hom.mono_of_presheaf_mono J D fâŸ©\n#align Sheaf.hom.mono_iff_presheaf_mono Sheaf.hom.mono_iff_presheaf_mono\n\n",
 "mk_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr áµ’áµ–Â» -/\ntheorem mk_apply {X : C} {P : Â«expr â¥¤ Â» (Â«expr áµ’áµ–Â» C) D} (S : J.cover X) (x : P.obj (op X)) (I : S.arrow) :\n    mk S x I = P.map I.f.op x :=\n  rfl\n#align mk_apply mk_apply\n\n",
 "iso_sheafify_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr áµ’áµ–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n@[simp]\ntheorem iso_sheafify_inv {P : Â«expr â¥¤ Â» (Â«expr áµ’áµ–Â» C) D} (hP : Presheaf.IsSheaf J P) :\n    (J.iso_sheafify hP).inv = J.sheafify_lift ((Â«exprğŸ™Â») _) hP :=\n  by\n  apply J.sheafify_lift_unique\n  simp [iso.comp_inv_eq]\n#align iso_sheafify_inv iso_sheafify_inv\n\n",
 "iso_sheafify_hom":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr áµ’áµ–Â» -/\n@[simp]\ntheorem iso_sheafify_hom {P : Â«expr â¥¤ Â» (Â«expr áµ’áµ–Â» C) D} (hP : Presheaf.IsSheaf J P) :\n    (J.iso_sheafify hP).hom = J.to_sheafify P :=\n  rfl\n#align iso_sheafify_hom iso_sheafify_hom\n\n",
 "is_sheaf_plus_plus":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr áµ’áµ–Â» -/\n/-- `Pâºâº` is always a sheaf. -/\ntheorem is_sheaf_plus_plus (P : Â«expr â¥¤ Â» (Â«expr áµ’áµ–Â» C) D) : Presheaf.IsSheaf J (J.plus_obj (J.plus_obj P)) :=\n  by\n  apply is_sheaf_of_sep\n  intro X S x y\n  apply sep\n#align is_sheaf_plus_plus is_sheaf_plus_plus\n\n",
 "is_sheaf_of_sep":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr áµ’áµ–Â» -/\n/-- If `P` is separated, then `Pâº` is a sheaf. -/\ntheorem is_sheaf_of_sep (P : Â«expr â¥¤ Â» (Â«expr áµ’áµ–Â» C) D)\n    (hsep : âˆ€ (X : C) (S : J.cover X) (x y : P.obj (op X)), (âˆ€ I : S.arrow, P.map I.f.op x = P.map I.f.op y) â†’ x = y) :\n    Presheaf.IsSheaf J (J.plus_obj P) :=\n  by\n  rw [presheaf.is_sheaf_iff_multiequalizer]\n  intro X S\n  apply is_iso_of_reflects_iso _ (forget D)\n  rw [is_iso_iff_bijective]\n  constructor\n  Â· intro x y h\n    apply sep P S _ _\n    intro I\n    apply_fun meq.equiv _ _  at h\n    apply_fun fun e => e I  at h\n    convert h\n    Â· erw [meq.equiv_apply, â† comp_apply, multiequalizer.lift_Î¹]\n    Â· erw [meq.equiv_apply, â† comp_apply, multiequalizer.lift_Î¹]\n  Â· rintro (x : (multiequalizer (S.index _) : D))\n    obtain âŸ¨t, htâŸ© := exists_of_sep P hsep X S (meq.equiv _ _ x)\n    use t\n    apply_fun meq.equiv _ _\n    swap\n    Â· infer_instance\n    rw [â† ht]\n    ext i\n    dsimp\n    rw [â† comp_apply, multiequalizer.lift_Î¹]\n    rfl\n#align is_sheaf_of_sep is_sheaf_of_sep\n\n",
 "is_iso_to_sheafify":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr áµ’áµ–Â» -/\ntheorem is_iso_to_sheafify {P : Â«expr â¥¤ Â» (Â«expr áµ’áµ–Â» C) D} (hP : Presheaf.IsSheaf J P) : IsIso (J.to_sheafify P) :=\n  by\n  dsimp [to_sheafify]\n  haveI : is_iso (J.to_plus P) := by apply is_iso_to_plus_of_is_sheaf J P hP\n  haveI : is_iso ((J.plus_functor D).map (J.to_plus P)) := by apply functor.map_is_iso\n  exact @is_iso.comp_is_iso _ _ _ _ _ (J.to_plus P) ((J.plus_functor D).map (J.to_plus P)) _ _\n#align is_iso_to_sheafify is_iso_to_sheafify\n\n",
 "inj_of_sep":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr áµ’áµ–Â» -/\ntheorem inj_of_sep (P : Â«expr â¥¤ Â» (Â«expr áµ’áµ–Â» C) D)\n    (hsep : âˆ€ (X : C) (S : J.cover X) (x y : P.obj (op X)), (âˆ€ I : S.arrow, P.map I.f.op x = P.map I.f.op y) â†’ x = y)\n    (X : C) : function.injective ((J.to_plus P).app (op X)) :=\n  by\n  intro x y h\n  simp only [to_plus_eq_mk] at h\n  rw [eq_mk_iff_exists] at h\n  obtain âŸ¨W, h1, h2, hhâŸ© := h\n  apply hsep X W\n  intro I\n  apply_fun fun e => e I  at hh\n  exact hh\n#align inj_of_sep inj_of_sep\n\n",
 "ext":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr áµ’áµ–Â» -/\n/-\nCopyright (c) 2021 Adam Topaz. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Adam Topaz\n-/\n@[ext]\ntheorem ext {X} {P : Â«expr â¥¤ Â» (Â«expr áµ’áµ–Â» C) D} {S : J.cover X} (x y : Meq P S) (h : âˆ€ I : S.arrow, x I = y I) :\n    x = y :=\n  Subtype.ext <| funext <| h\n#align ext ext\n\n",
 "exists_rep":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr áµ’áµ–Â» -/\ntheorem exists_rep {X : C} {P : Â«expr â¥¤ Â» (Â«expr áµ’áµ–Â» C) D} (x : (J.plus_obj P).obj (op X)) :\n    âˆƒ (S : J.cover X)(y : Meq P S), x = mk y :=\n  by\n  obtain âŸ¨S, y, hâŸ© := concrete.colimit_exists_rep (J.diagram P X) x\n  use S.unop, meq.equiv _ _ y\n  rw [â† h]\n  dsimp [mk]\n  simp\n#align exists_rep exists_rep\n\n",
 "exists_of_sep":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr áµ’áµ–Â» -/\ntheorem exists_of_sep (P : Â«expr â¥¤ Â» (Â«expr áµ’áµ–Â» C) D)\n    (hsep : âˆ€ (X : C) (S : J.cover X) (x y : P.obj (op X)), (âˆ€ I : S.arrow, P.map I.f.op x = P.map I.f.op y) â†’ x = y)\n    (X : C) (S : J.cover X) (s : Meq (J.plus_obj P) S) : âˆƒ t : (J.plus_obj P).obj (op X), Meq.mk S t = s :=\n  by\n  have inj : âˆ€ X : C, function.injective ((J.to_plus P).app (op X)) := inj_of_sep _ hsep\n  -- Choose representatives for the given local sections.\n  choose T t ht using fun I => exists_rep (s I)\n  -- Construct a large cover over which we will define a representative that will\n  -- provide the gluing of the given local sections.\n  let B : J.cover X := S.bind T\n  choose Z e1 e2 he2 he1 hee using fun I : B.arrow => I.hf\n  -- Construct a compatible system of local sections over this large cover, using the chosen\n  -- representatives of our local sections.\n  -- The compatilibity here follows from the separatedness assumption.\n  let w : meq P B := meq_of_sep P hsep X S s T t ht\n  -- The associated gluing will be the candidate section.\n  use mk w\n  ext I\n  erw [ht, res_mk_eq_mk_pullback]\n  -- Use the separatedness of `Pâº` to prove that this is indeed a gluing of our\n  -- original local sections.\n  apply sep P (T I)\n  intro II\n  simp only [res_mk_eq_mk_pullback, eq_mk_iff_exists]\n  -- It suffices to prove equality for representatives over a\n  -- convenient sufficiently large cover...\n  use (J.pullback II.f).obj (T I)\n  let e0 : Â«expr âŸ¶ Â» ((J.pullback II.f).obj (T I)) ((J.pullback II.f).obj ((J.pullback I.f).obj B)) :=\n    hom_of_le\n      (by\n        intro Y f hf\n        apply sieve.le_pullback_bind _ _ _ I.hf\n        Â· cases I\n          exact hf)\n  use e0, (Â«exprğŸ™Â») _\n  ext IV\n  dsimp only [meq.refine_apply, meq.pullback_apply, w]\n  let IA : B.arrow := âŸ¨_, Â«expr â‰« Â» (Â«expr â‰« Â» IV.f II.f) I.f, _âŸ©\n  swap\n  Â· refine' âŸ¨I.Y, _, _, I.hf, _, rflâŸ©\n    apply sieve.downward_closed\n    convert II.hf\n    cases I\n    rfl\n  let IB : S.arrow := IA.from_middle\n  let IC : (T IB).arrow := IA.to_middle\n  let ID : (T I).arrow := âŸ¨IV.Y, Â«expr â‰« Â» IV.f II.f, sieve.downward_closed (T I) II.hf IV.fâŸ©\n  change t IB IC = t I ID\n  apply inj IV.Y\n  erw [to_plus_apply (T I) (t I) ID, to_plus_apply (T IB) (t IB) IC, â† ht, â† ht]\n  -- Conclude by constructing the relation showing equality...\n  let IR : S.relation := âŸ¨_, _, IV.Y, IC.f, ID.f, IB.f, I.f, _, I.hf, IA.middle_specâŸ©\n  convert s.condition IR\n  cases I; rfl\n#align exists_of_sep exists_of_sep\n\n",
 "equiv_symm_eq_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr áµ’áµ–Â» -/\n@[simp]\ntheorem equiv_symm_eq_apply {X : C} {P : Â«expr â¥¤ Â» (Â«expr áµ’áµ–Â» C) D} {S : J.cover X} [HasMultiequalizer (S.index P)]\n    (x : Meq P S) (I : S.arrow) : Multiequalizer.Î¹ (S.index P) I ((Meq.equiv P S).symm x) = x I :=\n  by\n  let z := (meq.equiv P S).symm x\n  rw [â† equiv_apply]\n  simp\n#align equiv_symm_eq_apply equiv_symm_eq_apply\n\n",
 "equiv_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr áµ’áµ–Â» -/\n@[simp]\ntheorem equiv_apply {X : C} {P : Â«expr â¥¤ Â» (Â«expr áµ’áµ–Â» C) D} {S : J.cover X} [HasMultiequalizer (S.index P)]\n    (x : multiequalizer (S.index P)) (I : S.arrow) : equiv P S x I = Multiequalizer.Î¹ (S.index P) I x :=\n  rfl\n#align equiv_apply equiv_apply\n\n",
 "eq_mk_iff_exists":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr áµ’áµ–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem eq_mk_iff_exists {X : C} {P : Â«expr â¥¤ Â» (Â«expr áµ’áµ–Â» C) D} {S T : J.cover X} (x : Meq P S) (y : Meq P T) :\n    mk x = mk y â†” âˆƒ (W : J.cover X)(h1 : Â«expr âŸ¶ Â» W S)(h2 : Â«expr âŸ¶ Â» W T), x.refine h1 = y.refine h2 :=\n  by\n  constructor\n  Â· intro h\n    obtain âŸ¨W, h1, h2, hhâŸ© := concrete.colimit_exists_of_rep_eq _ _ _ h\n    use W.unop, h1.unop, h2.unop\n    ext I\n    apply_fun multiequalizer.Î¹ (W.unop.index P) I  at hh\n    convert hh\n    all_goals\n      dsimp [diagram]\n      simp only [â† comp_apply, multiequalizer.lift_Î¹, category.comp_id, meq.equiv_symm_eq_apply]\n      cases I; rfl\n  Â· rintro âŸ¨S, h1, h2, eâŸ©\n    apply concrete.colimit_rep_eq_of_exists\n    use op S, h1.op, h2.op\n    apply concrete.multiequalizer_ext\n    intro i\n    apply_fun fun ee => ee i  at e\n    convert e\n    all_goals\n      dsimp [diagram]\n      simp only [â† comp_apply, multiequalizer.lift_Î¹, meq.equiv_symm_eq_apply]\n      cases i; rfl\n#align eq_mk_iff_exists eq_mk_iff_exists\n\n",
 "condition":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr áµ’áµ–Â» -/\ntheorem condition {X} {P : Â«expr â¥¤ Â» (Â«expr áµ’áµ–Â» C) D} {S : J.cover X} (x : Meq P S) (I : S.relation) :\n    P.map I.gâ‚.op (x ((S.index P).fst_to I)) = P.map I.gâ‚‚.op (x ((S.index P).snd_to I)) :=\n  x.2 _\n#align condition condition\n\n"}