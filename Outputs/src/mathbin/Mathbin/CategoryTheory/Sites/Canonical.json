{"sheaf_for_finest_topology":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵖ» -/\n-- This is the hard part of the construction, showing that the given set of sieves satisfies\n-- the transitivity axiom.\n/-- Check that if `P ∈ Ps`, then `P` is indeed a sheaf for the finest topology on `Ps`. -/\ntheorem sheaf_for_finest_topology (Ps : Set («expr ⥤ » («expr ᵒᵖ» C) (Type v))) (h : P ∈ Ps) :\n    Presieve.IsSheaf (finest_topology Ps) P := fun X S hS => by\n  simpa using hS _ ⟨⟨_, _, ⟨_, h, rfl⟩, rfl⟩, rfl⟩ _ ((«expr𝟙») _)\n#align sheaf_for_finest_topology sheaf_for_finest_topology\n\n",
 "of_yoneda_is_sheaf":
 "/-- If every functor `yoneda.obj X` is a `J`-sheaf, then `J` is subcanonical. -/\ntheorem of_yoneda_is_sheaf (J : GrothendieckTopology C) (h : ∀ X, Presieve.IsSheaf J (yoneda.obj X)) : subcanonical J :=\n  le_finest_topology _ _\n    (by\n      rintro P ⟨X, rfl⟩\n      apply h)\n#align of_yoneda_is_sheaf of_yoneda_is_sheaf\n\n",
 "le_finest_topology":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵖ» -/\n/-- Check that if each `P ∈ Ps` is a sheaf for `J`, then `J` is a subtopology of `finest_topology Ps`.\n-/\ntheorem le_finest_topology (Ps : Set («expr ⥤ » («expr ᵒᵖ» C) (Type v))) (J : GrothendieckTopology C)\n    (hJ : ∀ P ∈ Ps, Presieve.IsSheaf J P) : J ≤ finest_topology Ps :=\n  by\n  rintro X S hS _ ⟨⟨_, _, ⟨P, hP, rfl⟩, rfl⟩, rfl⟩\n  intro Y f\n  -- this can't be combined with the previous because the `subst` is applied at the end\n  exact hJ P hP (S.pullback f) (J.pullback_stable f hS)\n#align le_finest_topology le_finest_topology\n\n",
 "is_sheaf_yoneda_obj":
 "/-- `yoneda.obj X` is a sheaf for the canonical topology. -/\ntheorem is_sheaf_yoneda_obj (X : C) : Presieve.IsSheaf (canonical_topology C) (yoneda.obj X) := fun Y S hS =>\n  sheaf_for_finest_topology _ (Set.mem_range_self _) _ hS\n#align is_sheaf_yoneda_obj is_sheaf_yoneda_obj\n\n",
 "is_sheaf_of_representable":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵖ» -/\n/-- If `J` is subcanonical, then any representable is a `J`-sheaf. -/\ntheorem is_sheaf_of_representable {J : GrothendieckTopology C} (hJ : subcanonical J)\n    (P : «expr ⥤ » («expr ᵒᵖ» C) (Type v)) [P.representable] : Presieve.IsSheaf J P :=\n  Presieve.isSheaf_of_le _ hJ (is_sheaf_of_representable P)\n#align is_sheaf_of_representable is_sheaf_of_representable\n\n",
 "is_sheaf_for_trans":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵖ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/-- Given two sieves `R` and `S`, to show that `P` is a sheaf for `S`, we can show:\n* `P` is a sheaf for `R`\n* `P` is a sheaf for the pullback of `S` along any arrow in `R`\n* `P` is separated for the pullback of `R` along any arrow in `S`.\n\nThis is mostly an auxiliary lemma to construct `finest_topology`.\nAdapted from [Elephant], Lemma C2.1.7(ii) with suggestions as mentioned in\nhttps://math.stackexchange.com/a/358709\n-/\ntheorem is_sheaf_for_trans (P : «expr ⥤ » («expr ᵒᵖ» C) (Type v)) (R S : Sieve X) (hR : Presieve.IsSheafFor P R)\n    (hR' : ∀ ⦃Y⦄ ⦃f : «expr ⟶ » Y X⦄ (hf : S f), Presieve.IsSeparatedFor P (R.pullback f))\n    (hS : ∀ ⦃Y⦄ ⦃f : «expr ⟶ » Y X⦄ (hf : R f), Presieve.IsSheafFor P (S.pullback f)) : Presieve.IsSheafFor P S :=\n  by\n  have : (bind R fun Y f hf => S.pullback f : presieve X) ≤ S :=\n    by\n    rintro Z f ⟨W, f, g, hg, hf : S _, rfl⟩\n    apply hf\n  apply presieve.is_sheaf_for_subsieve_aux P this\n  apply is_sheaf_for_bind _ _ _ hR hS\n  · intro Y f hf Z g\n    dsimp\n    rw [← pullback_comp]\n    apply (hS (R.downward_closed hf _)).is_separated_for\n  · intro Y f hf\n    have : sieve.pullback f (bind R fun T (k : «expr ⟶ » T X) (hf : R k) => pullback k S) = R.pullback f :=\n      by\n      ext (Z g)\n      constructor\n      · rintro ⟨W, k, l, hl, _, comm⟩\n        rw [pullback_apply, ← comm]\n        simp [hl]\n      · intro a\n        refine' ⟨Z, («expr𝟙») Z, _, a, _⟩\n        simp [hf]\n    rw [this]\n    apply hR' hf\n#align is_sheaf_for_trans is_sheaf_for_trans\n\n",
 "is_sheaf_for_bind":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵖ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/-\nCopyright (c) 2020 Bhavik Mehta. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Bhavik Mehta\n-/\n/-- To show `P` is a sheaf for the binding of `U` with `B`, it suffices to show that `P` is a sheaf for\n`U`, that `P` is a sheaf for each sieve in `B`, and that it is separated for any pullback of any\nsieve in `B`.\n\nThis is mostly an auxiliary lemma to show `is_sheaf_for_trans`.\nAdapted from [Elephant], Lemma C2.1.7(i) with suggestions as mentioned in\nhttps://math.stackexchange.com/a/358709/\n-/\ntheorem is_sheaf_for_bind (P : «expr ⥤ » («expr ᵒᵖ» C) (Type v)) (U : Sieve X)\n    (B : ∀ ⦃Y⦄ ⦃f : «expr ⟶ » Y X⦄, U f → Sieve Y) (hU : Presieve.IsSheafFor P U)\n    (hB : ∀ ⦃Y⦄ ⦃f : «expr ⟶ » Y X⦄ (hf : U f), Presieve.IsSheafFor P (B hf))\n    (hB' : ∀ ⦃Y⦄ ⦃f : «expr ⟶ » Y X⦄ (h : U f) ⦃Z⦄ (g : «expr ⟶ » Z Y), Presieve.IsSeparatedFor P ((B h).pullback g)) :\n    Presieve.IsSheafFor P (Sieve.bind U B) := by\n  intro s hs\n  let y : ∀ ⦃Y⦄ ⦃f : «expr ⟶ » Y X⦄ (hf : U f), presieve.family_of_elements P (B hf) := fun Y f hf Z g hg =>\n    s _ (presieve.bind_comp _ _ hg)\n  have hy : ∀ ⦃Y⦄ ⦃f : «expr ⟶ » Y X⦄ (hf : U f), (y hf).compatible :=\n    by\n    intro Y f H Y₁ Y₂ Z g₁ g₂ f₁ f₂ hf₁ hf₂ comm\n    apply hs\n    apply reassoc_of comm\n  let t : presieve.family_of_elements P U := fun Y f hf => (hB hf).amalgamate (y hf) (hy hf)\n  have ht : ∀ ⦃Y⦄ ⦃f : «expr ⟶ » Y X⦄ (hf : U f), (y hf).is_amalgamation (t f hf) := fun Y f hf =>\n    (hB hf).is_amalgamation _\n  have hT : t.compatible := by\n    rw [presieve.compatible_iff_sieve_compatible]\n    intro Z W f h hf\n    apply (hB (U.downward_closed hf h)).is_separated_for.ext\n    intro Y l hl\n    apply (hB' hf («expr ≫ » l h)).ext\n    intro M m hm\n    have : bind U B («expr ≫ » m («expr ≫ » l («expr ≫ » h f))) :=\n      by\n      have : bind U B _ := presieve.bind_comp f hf hm\n      simpa using this\n    trans s («expr ≫ » m («expr ≫ » l («expr ≫ » h f))) this\n    · have := ht (U.downward_closed hf h) _ ((B _).downward_closed hl m)\n      rw [op_comp, functor_to_types.map_comp_apply] at this\n      rw [this]\n      change s _ _ = s _ _\n      simp\n    · have : s _ _ = _ := (ht hf _ hm).symm\n      simp only [assoc] at this\n      rw [this]\n      simp\n  refine' ⟨hU.amalgamate t hT, _, _⟩\n  · rintro Z _ ⟨Y, f, g, hg, hf, rfl⟩\n    rw [op_comp, functor_to_types.map_comp_apply, presieve.is_sheaf_for.valid_glue _ _ _ hg]\n    apply ht hg _ hf\n  · intro y hy\n    apply hU.is_separated_for.ext\n    intro Y f hf\n    apply (hB hf).is_separated_for.ext\n    intro Z g hg\n    rw [← functor_to_types.map_comp_apply, ← op_comp, hy _ (presieve.bind_comp _ _ hg), hU.valid_glue _ _ hf,\n      ht hf _ hg]\n#align is_sheaf_for_bind is_sheaf_for_bind\n\n"}