{"sheaf_for_finest_topology":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr áµ’áµ–Â» -/\n-- This is the hard part of the construction, showing that the given set of sieves satisfies\n-- the transitivity axiom.\n/-- Check that if `P âˆˆ Ps`, then `P` is indeed a sheaf for the finest topology on `Ps`. -/\ntheorem sheaf_for_finest_topology (Ps : Set (Â«expr â¥¤ Â» (Â«expr áµ’áµ–Â» C) (Type v))) (h : P âˆˆ Ps) :\n    Presieve.IsSheaf (finest_topology Ps) P := fun X S hS => by\n  simpa using hS _ âŸ¨âŸ¨_, _, âŸ¨_, h, rflâŸ©, rflâŸ©, rflâŸ© _ ((Â«exprğŸ™Â») _)\n#align sheaf_for_finest_topology sheaf_for_finest_topology\n\n",
 "of_yoneda_is_sheaf":
 "/-- If every functor `yoneda.obj X` is a `J`-sheaf, then `J` is subcanonical. -/\ntheorem of_yoneda_is_sheaf (J : GrothendieckTopology C) (h : âˆ€ X, Presieve.IsSheaf J (yoneda.obj X)) : subcanonical J :=\n  le_finest_topology _ _\n    (by\n      rintro P âŸ¨X, rflâŸ©\n      apply h)\n#align of_yoneda_is_sheaf of_yoneda_is_sheaf\n\n",
 "le_finest_topology":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr áµ’áµ–Â» -/\n/-- Check that if each `P âˆˆ Ps` is a sheaf for `J`, then `J` is a subtopology of `finest_topology Ps`.\n-/\ntheorem le_finest_topology (Ps : Set (Â«expr â¥¤ Â» (Â«expr áµ’áµ–Â» C) (Type v))) (J : GrothendieckTopology C)\n    (hJ : âˆ€ P âˆˆ Ps, Presieve.IsSheaf J P) : J â‰¤ finest_topology Ps :=\n  by\n  rintro X S hS _ âŸ¨âŸ¨_, _, âŸ¨P, hP, rflâŸ©, rflâŸ©, rflâŸ©\n  intro Y f\n  -- this can't be combined with the previous because the `subst` is applied at the end\n  exact hJ P hP (S.pullback f) (J.pullback_stable f hS)\n#align le_finest_topology le_finest_topology\n\n",
 "is_sheaf_yoneda_obj":
 "/-- `yoneda.obj X` is a sheaf for the canonical topology. -/\ntheorem is_sheaf_yoneda_obj (X : C) : Presieve.IsSheaf (canonical_topology C) (yoneda.obj X) := fun Y S hS =>\n  sheaf_for_finest_topology _ (Set.mem_range_self _) _ hS\n#align is_sheaf_yoneda_obj is_sheaf_yoneda_obj\n\n",
 "is_sheaf_of_representable":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr áµ’áµ–Â» -/\n/-- If `J` is subcanonical, then any representable is a `J`-sheaf. -/\ntheorem is_sheaf_of_representable {J : GrothendieckTopology C} (hJ : subcanonical J)\n    (P : Â«expr â¥¤ Â» (Â«expr áµ’áµ–Â» C) (Type v)) [P.representable] : Presieve.IsSheaf J P :=\n  Presieve.isSheaf_of_le _ hJ (is_sheaf_of_representable P)\n#align is_sheaf_of_representable is_sheaf_of_representable\n\n",
 "is_sheaf_for_trans":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr áµ’áµ–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/-- Given two sieves `R` and `S`, to show that `P` is a sheaf for `S`, we can show:\n* `P` is a sheaf for `R`\n* `P` is a sheaf for the pullback of `S` along any arrow in `R`\n* `P` is separated for the pullback of `R` along any arrow in `S`.\n\nThis is mostly an auxiliary lemma to construct `finest_topology`.\nAdapted from [Elephant], Lemma C2.1.7(ii) with suggestions as mentioned in\nhttps://math.stackexchange.com/a/358709\n-/\ntheorem is_sheaf_for_trans (P : Â«expr â¥¤ Â» (Â«expr áµ’áµ–Â» C) (Type v)) (R S : Sieve X) (hR : Presieve.IsSheafFor P R)\n    (hR' : âˆ€ â¦ƒYâ¦„ â¦ƒf : Â«expr âŸ¶ Â» Y Xâ¦„ (hf : S f), Presieve.IsSeparatedFor P (R.pullback f))\n    (hS : âˆ€ â¦ƒYâ¦„ â¦ƒf : Â«expr âŸ¶ Â» Y Xâ¦„ (hf : R f), Presieve.IsSheafFor P (S.pullback f)) : Presieve.IsSheafFor P S :=\n  by\n  have : (bind R fun Y f hf => S.pullback f : presieve X) â‰¤ S :=\n    by\n    rintro Z f âŸ¨W, f, g, hg, hf : S _, rflâŸ©\n    apply hf\n  apply presieve.is_sheaf_for_subsieve_aux P this\n  apply is_sheaf_for_bind _ _ _ hR hS\n  Â· intro Y f hf Z g\n    dsimp\n    rw [â† pullback_comp]\n    apply (hS (R.downward_closed hf _)).is_separated_for\n  Â· intro Y f hf\n    have : sieve.pullback f (bind R fun T (k : Â«expr âŸ¶ Â» T X) (hf : R k) => pullback k S) = R.pullback f :=\n      by\n      ext (Z g)\n      constructor\n      Â· rintro âŸ¨W, k, l, hl, _, commâŸ©\n        rw [pullback_apply, â† comm]\n        simp [hl]\n      Â· intro a\n        refine' âŸ¨Z, (Â«exprğŸ™Â») Z, _, a, _âŸ©\n        simp [hf]\n    rw [this]\n    apply hR' hf\n#align is_sheaf_for_trans is_sheaf_for_trans\n\n",
 "is_sheaf_for_bind":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr áµ’áµ–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/-\nCopyright (c) 2020 Bhavik Mehta. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Bhavik Mehta\n-/\n/-- To show `P` is a sheaf for the binding of `U` with `B`, it suffices to show that `P` is a sheaf for\n`U`, that `P` is a sheaf for each sieve in `B`, and that it is separated for any pullback of any\nsieve in `B`.\n\nThis is mostly an auxiliary lemma to show `is_sheaf_for_trans`.\nAdapted from [Elephant], Lemma C2.1.7(i) with suggestions as mentioned in\nhttps://math.stackexchange.com/a/358709/\n-/\ntheorem is_sheaf_for_bind (P : Â«expr â¥¤ Â» (Â«expr áµ’áµ–Â» C) (Type v)) (U : Sieve X)\n    (B : âˆ€ â¦ƒYâ¦„ â¦ƒf : Â«expr âŸ¶ Â» Y Xâ¦„, U f â†’ Sieve Y) (hU : Presieve.IsSheafFor P U)\n    (hB : âˆ€ â¦ƒYâ¦„ â¦ƒf : Â«expr âŸ¶ Â» Y Xâ¦„ (hf : U f), Presieve.IsSheafFor P (B hf))\n    (hB' : âˆ€ â¦ƒYâ¦„ â¦ƒf : Â«expr âŸ¶ Â» Y Xâ¦„ (h : U f) â¦ƒZâ¦„ (g : Â«expr âŸ¶ Â» Z Y), Presieve.IsSeparatedFor P ((B h).pullback g)) :\n    Presieve.IsSheafFor P (Sieve.bind U B) := by\n  intro s hs\n  let y : âˆ€ â¦ƒYâ¦„ â¦ƒf : Â«expr âŸ¶ Â» Y Xâ¦„ (hf : U f), presieve.family_of_elements P (B hf) := fun Y f hf Z g hg =>\n    s _ (presieve.bind_comp _ _ hg)\n  have hy : âˆ€ â¦ƒYâ¦„ â¦ƒf : Â«expr âŸ¶ Â» Y Xâ¦„ (hf : U f), (y hf).compatible :=\n    by\n    intro Y f H Yâ‚ Yâ‚‚ Z gâ‚ gâ‚‚ fâ‚ fâ‚‚ hfâ‚ hfâ‚‚ comm\n    apply hs\n    apply reassoc_of comm\n  let t : presieve.family_of_elements P U := fun Y f hf => (hB hf).amalgamate (y hf) (hy hf)\n  have ht : âˆ€ â¦ƒYâ¦„ â¦ƒf : Â«expr âŸ¶ Â» Y Xâ¦„ (hf : U f), (y hf).is_amalgamation (t f hf) := fun Y f hf =>\n    (hB hf).is_amalgamation _\n  have hT : t.compatible := by\n    rw [presieve.compatible_iff_sieve_compatible]\n    intro Z W f h hf\n    apply (hB (U.downward_closed hf h)).is_separated_for.ext\n    intro Y l hl\n    apply (hB' hf (Â«expr â‰« Â» l h)).ext\n    intro M m hm\n    have : bind U B (Â«expr â‰« Â» m (Â«expr â‰« Â» l (Â«expr â‰« Â» h f))) :=\n      by\n      have : bind U B _ := presieve.bind_comp f hf hm\n      simpa using this\n    trans s (Â«expr â‰« Â» m (Â«expr â‰« Â» l (Â«expr â‰« Â» h f))) this\n    Â· have := ht (U.downward_closed hf h) _ ((B _).downward_closed hl m)\n      rw [op_comp, functor_to_types.map_comp_apply] at this\n      rw [this]\n      change s _ _ = s _ _\n      simp\n    Â· have : s _ _ = _ := (ht hf _ hm).symm\n      simp only [assoc] at this\n      rw [this]\n      simp\n  refine' âŸ¨hU.amalgamate t hT, _, _âŸ©\n  Â· rintro Z _ âŸ¨Y, f, g, hg, hf, rflâŸ©\n    rw [op_comp, functor_to_types.map_comp_apply, presieve.is_sheaf_for.valid_glue _ _ _ hg]\n    apply ht hg _ hf\n  Â· intro y hy\n    apply hU.is_separated_for.ext\n    intro Y f hf\n    apply (hB hf).is_separated_for.ext\n    intro Z g hg\n    rw [â† functor_to_types.map_comp_apply, â† op_comp, hy _ (presieve.bind_comp _ _ hg), hU.valid_glue _ _ hf,\n      ht hf _ hg]\n#align is_sheaf_for_bind is_sheaf_for_bind\n\n"}