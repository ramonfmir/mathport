{"union_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n@[simp]\ntheorem union_apply {R S : sieve X} {Y} (f : «expr ⟶ » Y X) : («expr ⊔ » R S) f ↔ R f ∨ S f :=\n  iff.rfl\n#align union_apply union_apply\n\n",
 "top_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem top_apply (f : «expr ⟶ » Y X) : («expr⊤» : sieve X) f :=\n  trivial\n#align top_apply top_apply\n\n",
 "supₛ_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n#print supₛ_apply /-\n@[simp]\ntheorem supₛ_apply {Ss : set (sieve X)} {Y} (f : «expr ⟶ » Y X) : supₛ Ss f ↔ ∃ (S : sieve X)(H : S ∈ Ss), S f :=\n  iff.rfl\n#align Sup_apply supₛ_apply\n-/\n\n",
 "singleton_self":
 "theorem singleton_self : singleton f f :=\n  singleton.mk\n#align singleton_self singleton_self\n\n",
 "singleton_eq_iff_domain":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n-- Note we can't make this into `has_singleton` because of the out-param.\n@[simp]\ntheorem singleton_eq_iff_domain (f g : «expr ⟶ » Y X) : singleton f g ↔ f = g :=\n  by\n  constructor\n  · rintro ⟨a, rfl⟩\n    rfl\n  · rintro rfl\n    apply singleton.mk\n#align singleton_eq_iff_domain singleton_eq_iff_domain\n\n",
 "sieve_of_subfunctor_functor_inclusion":
 "-- TODO: Show that when `f` is mono, this is right inverse to `functor_inclusion` up to isomorphism.\ntheorem sieve_of_subfunctor_functor_inclusion : sieve_of_subfunctor S.functor_inclusion = S :=\n  by\n  ext\n  simp only [functor_inclusion_app, sieve_of_subfunctor_apply, subtype.val_eq_coe]\n  constructor\n  · rintro ⟨⟨f, hf⟩, rfl⟩\n    exact hf\n  · intro hf\n    exact ⟨⟨_, hf⟩, rfl⟩\n#align sieve_of_subfunctor_functor_inclusion sieve_of_subfunctor_functor_inclusion\n\n",
 "sets_iff_generate":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\ntheorem sets_iff_generate (R : presieve X) (S : sieve X) : generate R ≤ S ↔ R ≤ S :=\n  ⟨fun H Y g hg => H _ ⟨_, («expr𝟙») _, _, hg, id_comp _⟩, fun ss Y f =>\n    by\n    rintro ⟨Z, f, g, hg, rfl⟩\n    exact S.downward_closed (ss Z hg) f⟩\n#align sets_iff_generate sets_iff_generate\n\n",
 "pushforward_union":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\ntheorem pushforward_union {f : «expr ⟶ » Y X} (S R : sieve Y) :\n    («expr ⊔ » S R).pushforward f = «expr ⊔ » (S.pushforward f) (R.pushforward f) :=\n  (galois_connection f).l_sup\n#align pushforward_union pushforward_union\n\n",
 "pushforward_monotone":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem pushforward_monotone (f : «expr ⟶ » Y X) : monotone (sieve.pushforward f) :=\n  (galois_connection f).monotone_l\n#align pushforward_monotone pushforward_monotone\n\n",
 "pushforward_le_bind_of_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem pushforward_le_bind_of_mem (S : presieve X) (R : ∀ ⦃Y : C⦄ ⦃f : «expr ⟶ » Y X⦄, S f → sieve Y)\n    (f : «expr ⟶ » Y X) (h : S f) : (R h).pushforward f ≤ bind S R :=\n  by\n  rintro Z _ ⟨g, rfl, hg⟩\n  exact ⟨_, g, f, h, hg, rfl⟩\n#align pushforward_le_bind_of_mem pushforward_le_bind_of_mem\n\n",
 "pushforward_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem pushforward_comp {f : «expr ⟶ » Y X} {g : «expr ⟶ » Z Y} (R : sieve Z) :\n    R.pushforward («expr ≫ » g f) = (R.pushforward g).pushforward f :=\n  sieve.ext fun W h =>\n    ⟨fun ⟨f₁, hq, hf₁⟩ => ⟨«expr ≫ » f₁ g, by simpa, f₁, rfl, hf₁⟩, fun ⟨y, hy, z, hR, hz⟩ =>\n      ⟨z, by rwa [reassoc_of hR], hz⟩⟩\n#align pushforward_comp pushforward_comp\n\n",
 "pushforward_apply_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem pushforward_apply_comp {R : sieve Y} {Z : C} {g : «expr ⟶ » Z Y} (hg : R g) (f : «expr ⟶ » Y X) :\n    R.pushforward f («expr ≫ » g f) :=\n  ⟨g, rfl, hg⟩\n#align pushforward_apply_comp pushforward_apply_comp\n\n",
 "pullback_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem pullback_top {f : «expr ⟶ » Y X} : («expr⊤» : sieve X).pullback f = «expr⊤» :=\n  top_unique fun _ g => id\n#align pullback_top pullback_top\n\n",
 "pullback_singleton":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem pullback_singleton [has_pullbacks C] (g : «expr ⟶ » Z X) :\n    pullback_arrows f (singleton g) = singleton (pullback.snd : «expr ⟶ » (pullback g f) _) :=\n  by\n  ext (W h)\n  constructor\n  · rintro ⟨W, _, _, _⟩\n    exact singleton.mk\n  · rintro ⟨_⟩\n    exact pullback_arrows.mk Z g singleton.mk\n#align pullback_singleton pullback_singleton\n\n",
 "pullback_pushforward_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem pullback_pushforward_le (f : «expr ⟶ » Y X) (R : sieve X) : (R.pullback f).pushforward f ≤ R :=\n  (galois_connection f).l_u_le _\n#align pullback_pushforward_le pullback_pushforward_le\n\n",
 "pullback_monotone":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem pullback_monotone (f : «expr ⟶ » Y X) : monotone (sieve.pullback f) :=\n  (galois_connection f).monotone_u\n#align pullback_monotone pullback_monotone\n\n",
 "pullback_inter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n@[simp]\ntheorem pullback_inter {f : «expr ⟶ » Y X} (S R : sieve X) :\n    («expr ⊓ » S R).pullback f = «expr ⊓ » (S.pullback f) (R.pullback f) := by simp [sieve.ext_iff]\n#align pullback_inter pullback_inter\n\n",
 "pullback_id":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n@[simp]\ntheorem pullback_id : S.pullback ((«expr𝟙») _) = S := by simp [sieve.ext_iff]\n#align pullback_id pullback_id\n\n",
 "pullback_eq_top_of_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem pullback_eq_top_of_mem (S : sieve X) {f : «expr ⟶ » Y X} : S f → S.pullback f = «expr⊤» :=\n  (pullback_eq_top_iff_mem f).1\n#align pullback_eq_top_of_mem pullback_eq_top_of_mem\n\n",
 "pullback_eq_top_iff_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem pullback_eq_top_iff_mem (f : «expr ⟶ » Y X) : S f ↔ S.pullback f = «expr⊤» := by\n  rw [← id_mem_iff_eq_top, pullback_apply, id_comp]\n#align pullback_eq_top_iff_mem pullback_eq_top_iff_mem\n\n",
 "pullback_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem pullback_comp {f : «expr ⟶ » Y X} {g : «expr ⟶ » Z Y} (S : sieve X) :\n    S.pullback («expr ≫ » g f) = (S.pullback f).pullback g := by simp [sieve.ext_iff]\n#align pullback_comp pullback_comp\n\n",
 "pullback_arrows_comm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem pullback_arrows_comm [has_pullbacks C] {X Y : C} (f : «expr ⟶ » Y X) (R : presieve X) :\n    sieve.generate (R.pullback_arrows f) = (sieve.generate R).pullback f :=\n  by\n  ext (Z g)\n  constructor\n  · rintro ⟨_, h, k, hk, rfl⟩\n    cases' hk with W g hg\n    change (sieve.generate R).pullback f («expr ≫ » h pullback.snd)\n    rw [sieve.pullback_apply, assoc, ← pullback.condition, ← assoc]\n    exact sieve.downward_closed _ (sieve.le_generate R W hg) («expr ≫ » h pullback.fst)\n  · rintro ⟨W, h, k, hk, comm⟩\n    exact ⟨_, _, _, presieve.pullback_arrows.mk _ _ hk, pullback.lift_snd _ _ comm⟩\n#align pullback_arrows_comm pullback_arrows_comm\n\n",
 "of_arrows_punit":
 "theorem of_arrows_punit : (of_arrows _ fun _ : PUnit => f) = singleton f :=\n  by\n  ext (Y g)\n  constructor\n  · rintro ⟨_⟩\n    apply singleton.mk\n  · rintro ⟨_⟩\n    exact of_arrows.mk PUnit.unit\n#align of_arrows_punit of_arrows_punit\n\n",
 "of_arrows_pullback":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem of_arrows_pullback [has_pullbacks C] {ι : Type _} (Z : ι → C) (g : ∀ i : ι, «expr ⟶ » (Z i) X) :\n    (of_arrows (fun i => pullback (g i) f) fun i => pullback.snd) = pullback_arrows f (of_arrows Z g) :=\n  by\n  ext (T h)\n  constructor\n  · rintro ⟨hk⟩\n    exact pullback_arrows.mk _ _ (of_arrows.mk hk)\n  · rintro ⟨W, k, hk₁⟩\n    cases' hk₁ with i hi\n    apply of_arrows.mk\n#align of_arrows_pullback of_arrows_pullback\n\n",
 "of_arrows_bind":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem of_arrows_bind {ι : Type _} (Z : ι → C) (g : ∀ i : ι, «expr ⟶ » (Z i) X)\n    (j : ∀ ⦃Y⦄ (f : «expr ⟶ » Y X), of_arrows Z g f → Type _) (W : ∀ ⦃Y⦄ (f : «expr ⟶ » Y X) (H), j f H → C)\n    (k : ∀ ⦃Y⦄ (f : «expr ⟶ » Y X) (H i), «expr ⟶ » (W f H i) Y) :\n    ((of_arrows Z g).bind fun Y f H => of_arrows (W f H) (k f H)) =\n      of_arrows (fun i : Σi, j _ (of_arrows.mk i) => W (g i.1) _ i.2) fun ij =>\n        «expr ≫ » (k (g ij.1) _ ij.2) (g ij.1) :=\n  by\n  ext (Y f)\n  constructor\n  · rintro ⟨_, _, _, ⟨i⟩, ⟨i'⟩, rfl⟩\n    exact of_arrows.mk (sigma.mk _ _)\n  · rintro ⟨i⟩\n    exact bind_comp _ (of_arrows.mk _) (of_arrows.mk _)\n#align of_arrows_bind of_arrows_bind\n\n",
 "nat_trans_of_le_comm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem nat_trans_of_le_comm {S T : sieve X} (h : S ≤ T) :\n    «expr ≫ » (nat_trans_of_le h) (functor_inclusion _) = functor_inclusion _ :=\n  rfl\n#align nat_trans_of_le_comm nat_trans_of_le_comm\n\n",
 "le_pushforward_pullback":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem le_pushforward_pullback (f : «expr ⟶ » Y X) (R : sieve Y) : R ≤ (R.pushforward f).pullback f :=\n  (galois_connection f).le_u_l _\n#align le_pushforward_pullback le_pushforward_pullback\n\n",
 "le_pullback_bind":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem le_pullback_bind (S : presieve X) (R : ∀ ⦃Y : C⦄ ⦃f : «expr ⟶ » Y X⦄, S f → sieve Y) (f : «expr ⟶ » Y X)\n    (h : S f) : R h ≤ (bind S R).pullback f := by\n  rw [← GaloisConnection f]\n  apply pushforward_le_bind_of_mem\n#align le_pullback_bind le_pullback_bind\n\n",
 "le_generate":
 "theorem le_generate (R : presieve X) : R ≤ generate R :=\n  gi_generate.gc.le_u_l R\n#align le_generate le_generate\n\n",
 "le_functor_pushforward_pullback":
 "theorem le_functor_pushforward_pullback (R : sieve X) : R ≤ (R.functor_pushforward F).functor_pullback F :=\n  (functor_galois_connection F X).le_u_l _\n#align le_functor_pushforward_pullback le_functor_pushforward_pullback\n\n",
 "inter_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n@[simp]\ntheorem inter_apply {R S : sieve X} {Y} (f : «expr ⟶ » Y X) : («expr ⊓ » R S) f ↔ R f ∧ S f :=\n  iff.rfl\n#align inter_apply inter_apply\n\n",
 "infₛ_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n#print infₛ_apply /-\n@[simp]\ntheorem infₛ_apply {Ss : set (sieve X)} {Y} (f : «expr ⟶ » Y X) : infₛ Ss f ↔ ∀ (S : sieve X) (H : S ∈ Ss), S f :=\n  iff.rfl\n#align Inf_apply infₛ_apply\n-/\n\n",
 "image_mem_functor_pushforward":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem image_mem_functor_pushforward (R : sieve X) {V} {f : «expr ⟶ » V X} (h : R f) :\n    R.functor_pushforward F (F.map f) :=\n  ⟨V, f, («expr𝟙») _, h, by simp⟩\n#align image_mem_functor_pushforward image_mem_functor_pushforward\n\n",
 "id_mem_iff_eq_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/-- If the identity arrow is in a sieve, the sieve is maximal. -/\ntheorem id_mem_iff_eq_top : S ((«expr𝟙») X) ↔ S = «expr⊤» :=\n  ⟨fun h => top_unique fun Y f _ => by simpa using downward_closed _ h f, fun h => h.symm ▸ trivial⟩\n#align id_mem_iff_eq_top id_mem_iff_eq_top\n\n",
 "generate_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem generate_top : generate («expr⊤» : presieve X) = «expr⊤» :=\n  generate_of_contains_is_split_epi ((«expr𝟙») _) ⟨⟩\n#align generate_top generate_top\n\n",
 "generate_sieve":
 "@[simp]\ntheorem generate_sieve (S : sieve X) : generate S = S :=\n  gi_generate.l_u_eq S\n#align generate_sieve generate_sieve\n\n",
 "generate_of_singleton_is_split_epi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem generate_of_singleton_is_split_epi (f : «expr ⟶ » Y X) [is_split_epi f] :\n    generate (presieve.singleton f) = «expr⊤» :=\n  generate_of_contains_is_split_epi f (presieve.singleton_self _)\n#align generate_of_singleton_is_split_epi generate_of_singleton_is_split_epi\n\n",
 "generate_of_contains_is_split_epi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/-- If an arrow set contains a split epi, it generates the maximal sieve. -/\ntheorem generate_of_contains_is_split_epi {R : presieve X} (f : «expr ⟶ » Y X) [is_split_epi f] (hf : R f) :\n    generate R = «expr⊤» := by\n  rw [← id_mem_iff_eq_top]\n  exact ⟨_, section_ f, f, hf, by simp⟩\n#align generate_of_contains_is_split_epi generate_of_contains_is_split_epi\n\n",
 "functor_pushforward_union":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\ntheorem functor_pushforward_union (S R : sieve X) :\n    («expr ⊔ » S R).functor_pushforward F = «expr ⊔ » (S.functor_pushforward F) (R.functor_pushforward F) :=\n  (functor_galois_connection F X).l_sup\n#align functor_pushforward_union functor_pushforward_union\n\n",
 "functor_pushforward_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem functor_pushforward_top (F : «expr ⥤ » C D) (X : C) : («expr⊤» : sieve X).functor_pushforward F = «expr⊤» :=\n  by\n  refine' (generate_sieve _).symm.trans _\n  apply generate_of_contains_is_split_epi ((«expr𝟙») (F.obj X))\n  refine' ⟨X, («expr𝟙») _, («expr𝟙») _, trivial, by simp⟩\n#align functor_pushforward_top functor_pushforward_top\n\n",
 "functor_pushforward_monotone":
 "theorem functor_pushforward_monotone (X : C) : monotone (sieve.functor_pushforward F : sieve X → sieve (F.obj X)) :=\n  (functor_galois_connection F X).monotone_l\n#align functor_pushforward_monotone functor_pushforward_monotone\n\n",
 "functor_pushforward_id":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟭» -/\n@[simp]\ntheorem functor_pushforward_id (R : sieve X) : R.functor_pushforward ((«expr𝟭») _) = R :=\n  by\n  ext (X f)\n  constructor\n  · intro hf\n    obtain ⟨X, g, h, hg, rfl⟩ := hf\n    exact R.downward_closed hg h\n  · intro hf\n    exact ⟨X, f, («expr𝟙») _, hf, by simp⟩\n#align functor_pushforward_id functor_pushforward_id\n\n",
 "functor_pushforward_extend_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem functor_pushforward_extend_eq {R : presieve X} :\n    (generate R).arrows.functor_pushforward F = R.functor_pushforward F :=\n  by\n  ext (Y f); constructor\n  · rintro ⟨X', g, f', ⟨X'', g', f'', h₁, rfl⟩, rfl⟩\n    exact ⟨X'', f'', «expr ≫ » f' (F.map g'), h₁, by simp⟩\n  · rintro ⟨X', g, f', h₁, h₂⟩\n    exact ⟨X', g, f', le_generate R _ h₁, h₂⟩\n#align functor_pushforward_extend_eq functor_pushforward_extend_eq\n\n",
 "functor_pushforward_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\ntheorem functor_pushforward_comp (R : sieve X) :\n    R.functor_pushforward («expr ⋙ » F G) = (R.functor_pushforward F).functor_pushforward G :=\n  by\n  ext\n  simpa [R.arrows.functor_pushforward_comp F G]\n#align functor_pushforward_comp functor_pushforward_comp\n\n",
 "functor_pushforward_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem functor_pushforward_bot (F : «expr ⥤ » C D) (X : C) : («expr⊥» : sieve X).functor_pushforward F = «expr⊥» :=\n  (functor_galois_connection F X).l_bot\n#align functor_pushforward_bot functor_pushforward_bot\n\n",
 "functor_pullback_union":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\ntheorem functor_pullback_union (S R : sieve (F.obj X)) :\n    («expr ⊔ » S R).functor_pullback F = «expr ⊔ » (S.functor_pullback F) (R.functor_pullback F) :=\n  rfl\n#align functor_pullback_union functor_pullback_union\n\n",
 "functor_pullback_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem functor_pullback_top (F : «expr ⥤ » C D) (X : C) : («expr⊤» : sieve (F.obj X)).functor_pullback F = «expr⊤» :=\n  rfl\n#align functor_pullback_top functor_pullback_top\n\n",
 "functor_pullback_pushforward_le":
 "theorem functor_pullback_pushforward_le (R : sieve (F.obj X)) : (R.functor_pullback F).functor_pushforward F ≤ R :=\n  (functor_galois_connection F X).l_u_le _\n#align functor_pullback_pushforward_le functor_pullback_pushforward_le\n\n",
 "functor_pullback_monotone":
 "theorem functor_pullback_monotone (X : C) : monotone (sieve.functor_pullback F : sieve (F.obj X) → sieve X) :=\n  (functor_galois_connection F X).monotone_u\n#align functor_pullback_monotone functor_pullback_monotone\n\n",
 "functor_pullback_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n@[simp]\ntheorem functor_pullback_mem (R : presieve (F.obj X)) {Y} (f : «expr ⟶ » Y X) : R.functor_pullback F f ↔ R (F.map f) :=\n  iff.rfl\n#align functor_pullback_mem functor_pullback_mem\n\n",
 "functor_pullback_inter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\ntheorem functor_pullback_inter (S R : sieve (F.obj X)) :\n    («expr ⊓ » S R).functor_pullback F = «expr ⊓ » (S.functor_pullback F) (R.functor_pullback F) :=\n  rfl\n#align functor_pullback_inter functor_pullback_inter\n\n",
 "functor_pullback_id":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟭» -/\n@[simp]\ntheorem functor_pullback_id (R : sieve X) : R.functor_pullback ((«expr𝟭») _) = R :=\n  by\n  ext\n  rfl\n#align functor_pullback_id functor_pullback_id\n\n",
 "functor_pullback_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\ntheorem functor_pullback_comp (R : sieve ((«expr ⋙ » F G).obj X)) :\n    R.functor_pullback («expr ⋙ » F G) = (R.functor_pullback G).functor_pullback F :=\n  by\n  ext\n  rfl\n#align functor_pullback_comp functor_pullback_comp\n\n",
 "functor_pullback_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem functor_pullback_bot (F : «expr ⥤ » C D) (X : C) : («expr⊥» : sieve (F.obj X)).functor_pullback F = «expr⊥» :=\n  rfl\n#align functor_pullback_bot functor_pullback_bot\n\n",
 "functor_pullback_arrows":
 "@[simp]\ntheorem functor_pullback_arrows (R : sieve (F.obj X)) : (R.functor_pullback F).arrows = R.arrows.functor_pullback F :=\n  rfl\n#align functor_pullback_arrows functor_pullback_arrows\n\n",
 "functor_galois_connection":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\ntheorem functor_galois_connection (X : C) :\n    GaloisConnection (sieve.functor_pushforward F : sieve X → sieve (F.obj X)) (sieve.functor_pullback F) :=\n  by\n  intro R S\n  constructor\n  · intro hle X f hf\n    apply hle\n    refine' ⟨X, f, («expr𝟙») _, hf, _⟩\n    rw [id_comp]\n  · rintro hle Y f ⟨X, g, h, hg, rfl⟩\n    apply sieve.downward_closed S\n    exact hle g hg\n#align functor_galois_connection functor_galois_connection\n\n",
 "ext_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\nprotected theorem ext_iff {R S : sieve X} : R = S ↔ ∀ ⦃Y⦄ (f : «expr ⟶ » Y X), R f ↔ S f :=\n  ⟨fun h Y f => h ▸ iff.rfl, sieve.ext⟩\n#align ext_iff ext_iff\n\n",
 "ext":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n@[ext]\nprotected theorem ext {R S : sieve X} (h : ∀ ⦃Y⦄ (f : «expr ⟶ » Y X), R f ↔ S f) : R = S :=\n  arrows_ext <| funext fun x => funext fun f => propext <| h f\n#align ext ext\n\n",
 "downward_closed":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp]\ntheorem downward_closed (S : sieve X) {f : «expr ⟶ » Y X} (hf : S f) (g : «expr ⟶ » Z Y) : S («expr ≫ » g f) :=\n  S.downward_closed' hf g\n#align downward_closed downward_closed\n\n",
 "bind_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/-\nCopyright (c) 2020 Bhavik Mehta. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Bhavik Mehta, E. W. Ayers\n-/\n@[simp]\ntheorem bind_comp {S : presieve X} {R : ∀ ⦃Y : C⦄ ⦃f : «expr ⟶ » Y X⦄, S f → presieve Y} {g : «expr ⟶ » Z Y} (h₁ : S f)\n    (h₂ : R h₁ g) : bind S R («expr ≫ » g f) :=\n  ⟨_, _, _, h₁, h₂, rfl⟩\n#align bind_comp bind_comp\n\n",
 "arrows_ext":
 "theorem arrows_ext : ∀ {R S : sieve X}, R.arrows = S.arrows → R = S\n  | ⟨Ra, _⟩, ⟨Sa, _⟩, rfl => rfl\n#align arrows_ext arrows_ext\n\n",
 "GaloisConnection":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n#print GaloisConnection /-\ntheorem GaloisConnection (f : «expr ⟶ » Y X) : GaloisConnection (sieve.pushforward f) (sieve.pullback f) := fun S R =>\n  ⟨fun hR Z g hg => hR _ ⟨g, rfl, hg⟩, fun hS Z g ⟨h, hg, hh⟩ => hg ▸ hS h hh⟩\n#align galois_connection GaloisConnection\n-/\n\n"}