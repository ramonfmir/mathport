{"pullback_is_sheaf_of_cover_preserving":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‹™ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‹™ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‹™ Â» -/\n/-- If `G` is cover-preserving and compatible-preserving,\nthen `G.op â‹™ _` pulls sheaves back to sheaves.\n\nThis result is basically <https://stacks.math.columbia.edu/tag/00WW>.\n-/\ntheorem pullback_is_sheaf_of_cover_preserving {G : Â«expr â¥¤ Â» C D} (hGâ‚ : CompatiblePreserving.{vâ‚ƒ} K G)\n    (hGâ‚‚ : CoverPreserving J K G) (â„± : Sheaf K A) : Presheaf.IsSheaf J (Â«expr â‹™ Â» G.op â„±.val) :=\n  by\n  intro X U S hS x hx\n  change family_of_elements (Â«expr â‹™ Â» G.op (Â«expr â‹™ Â» â„±.val (coyoneda.obj (op X)))) _ at x\n  let H := â„±.2 X _ (hGâ‚‚.cover_preserve hS)\n  let hx' := hx.functor_pushforward hGâ‚ (sheaf_over â„± X)\n  constructor; swap\n  Â· apply H.amalgamate (x.functor_pushforward G)\n    exact hx'\n  constructor\n  Â· intro V f hf\n    convert H.is_amalgamation hx' (G.map f) (image_mem_functor_pushforward G S hf)\n    rw [hGâ‚.apply_map (sheaf_over â„± X) hx]\n  Â· intro y hy\n    refine' H.is_separated_for _ y _ _ (H.is_amalgamation (hx.functor_pushforward hGâ‚ (sheaf_over â„± X)))\n    rintro V f âŸ¨Z, f', g', h, rflâŸ©\n    erw [family_of_elements.comp_of_compatible (S.functor_pushforward G) hx' (image_mem_functor_pushforward G S h) g']\n    dsimp\n    simp [hGâ‚.apply_map (sheaf_over â„± X) hx h, â† hy f' h]\n#align pullback_is_sheaf_of_cover_preserving pullback_is_sheaf_of_cover_preserving\n\n",
 "id_cover_preserving":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ­Â» -/\n/-\nCopyright (c) 2021 Andrew Yang. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Andrew Yang\n-/\n/-- The identity functor on a site is cover-preserving. -/\ntheorem id_cover_preserving : CoverPreserving J J ((Â«exprğŸ­Â») _) :=\n  âŸ¨fun U S hS => by simpa using hSâŸ©\n#align id_cover_preserving id_cover_preserving\n\n",
 "functor_pushforward":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/-- `compatible_preserving` functors indeed preserve compatible families. -/\ntheorem presieve.family_of_elements.compatible.functor_pushforward : (x.functor_pushforward G).compatible :=\n  by\n  rintro Zâ‚ Zâ‚‚ W gâ‚ gâ‚‚ fâ‚' fâ‚‚' Hâ‚ Hâ‚‚ eq\n  unfold family_of_elements.functor_pushforward\n  rcases get_functor_pushforward_structure Hâ‚ with âŸ¨Xâ‚, fâ‚, hâ‚, hfâ‚, rflâŸ©\n  rcases get_functor_pushforward_structure Hâ‚‚ with âŸ¨Xâ‚‚, fâ‚‚, hâ‚‚, hfâ‚‚, rflâŸ©\n  suffices : â„±.val.map (Â«expr â‰« Â» gâ‚ hâ‚).op (x fâ‚ hfâ‚) = â„±.val.map (Â«expr â‰« Â» gâ‚‚ hâ‚‚).op (x fâ‚‚ hfâ‚‚)\n  simpa using this\n  apply hG.compatible â„± h _ _ hfâ‚ hfâ‚‚\n  simpa using Eq\n#align presieve.family_of_elements.compatible.functor_pushforward presieve.family_of_elements.compatible.functor_pushforward\n\n",
 "compatible_preserving_of_flat":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‹™ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‹™ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‹™ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\ntheorem compatible_preserving_of_flat {C : Type uâ‚} [Category.{vâ‚} C] {D : Type uâ‚} [Category.{vâ‚} D]\n    (K : GrothendieckTopology D) (G : Â«expr â¥¤ Â» C D) [RepresentablyFlat G] : CompatiblePreserving K G :=\n  by\n  constructor\n  intro â„± Z T x hx Yâ‚ Yâ‚‚ X fâ‚ fâ‚‚ gâ‚ gâ‚‚ hgâ‚ hgâ‚‚ e\n  -- First, `fâ‚` and `fâ‚‚` form a cone over `cospan gâ‚ gâ‚‚ â‹™ u`.\n  let c : cone (Â«expr â‹™ Â» (cospan gâ‚ gâ‚‚) G) :=\n    (cones.postcompose (diagram_iso_cospan (Â«expr â‹™ Â» (cospan gâ‚ gâ‚‚) G)).inv).obj (pullback_cone.mk fâ‚ fâ‚‚ e)\n  /-\n    This can then be viewed as a cospan of structured arrows, and we may obtain an arbitrary cone\n    over it since `structured_arrow W u` is cofiltered.\n    Then, it suffices to prove that it is compatible when restricted onto `u(c'.X.right)`.\n    -/\n  let c' := is_cofiltered.cone (Â«expr â‹™ Â» (structured_arrow_cone.to_diagram c) (structured_arrow.pre _ _ _))\n  have eqâ‚ : fâ‚ = Â«expr â‰« Â» (Â«expr â‰« Â» c'.X.hom (G.map (c'.Ï€.app left).right)) (eq_to_hom (by simp)) :=\n    by\n    erw [â† (c'.Ï€.app left).w]\n    dsimp\n    simp\n  have eqâ‚‚ : fâ‚‚ = Â«expr â‰« Â» (Â«expr â‰« Â» c'.X.hom (G.map (c'.Ï€.app right).right)) (eq_to_hom (by simp)) :=\n    by\n    erw [â† (c'.Ï€.app right).w]\n    dsimp\n    simp\n  conv_lhs => rw [eqâ‚]\n  conv_rhs => rw [eqâ‚‚]\n  simp only [op_comp, functor.map_comp, types_comp_apply, eq_to_hom_op, eq_to_hom_map]\n  congr 1\n  /-\n    Since everything now falls in the image of `u`,\n    the result follows from the compatibility of `x` in the image of `u`.\n    -/\n  injection c'.Ï€.naturality walking_cospan.hom.inl with _ eâ‚\n  injection c'.Ï€.naturality walking_cospan.hom.inr with _ eâ‚‚\n  exact hx (c'.Ï€.app left).right (c'.Ï€.app right).right hgâ‚ hgâ‚‚ (eâ‚.symm.trans eâ‚‚)\n#align compatible_preserving_of_flat compatible_preserving_of_flat\n\n",
 "compatible_preserving_of_downwards_closed":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰… Â» -/\ntheorem compatible_preserving_of_downwards_closed (F : Â«expr â¥¤ Â» C D) [Full F] [Faithful F]\n    (hF : âˆ€ {c : C} {d : D} (f : Â«expr âŸ¶ Â» d (F.obj c)), Î£c', Â«expr â‰… Â» (F.obj c') d) : CompatiblePreserving K F :=\n  by\n  constructor\n  introv hx he\n  obtain âŸ¨X', eâŸ© := hF fâ‚\n  apply (â„±.1.map_iso e.op).to_equiv.injective\n  simp only [iso.op_hom, iso.to_equiv_fun, â„±.1.map_iso_hom, â† functor_to_types.map_comp_apply]\n  simpa using\n    hx (F.preimage <| Â«expr â‰« Â» e.hom fâ‚) (F.preimage <| Â«expr â‰« Â» e.hom fâ‚‚) hgâ‚ hgâ‚‚\n      (F.map_injective <| by simpa using he)\n#align compatible_preserving_of_downwards_closed compatible_preserving_of_downwards_closed\n\n",
 "comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‹™ Â» -/\n/-- The composition of two cover-preserving functors is cover-preserving. -/\ntheorem cover_preserving.comp {F} (hF : CoverPreserving J K F) {G} (hG : CoverPreserving K L G) :\n    CoverPreserving J L (Â«expr â‹™ Â» F G) :=\n  âŸ¨fun U S hS => by\n    rw [sieve.functor_pushforward_comp]\n    exact hG.cover_preserve (hF.cover_preserve hS)âŸ©\n#align cover_preserving.comp cover_preserving.comp\n\n",
 "apply_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n@[simp]\ntheorem compatible_preserving.apply_map {Y : C} {f : Â«expr âŸ¶ Â» Y Z} (hf : T f) :\n    x.functor_pushforward G (G.map f) (image_mem_functorPushforward G T hf) = x f hf :=\n  by\n  unfold family_of_elements.functor_pushforward\n  rcases eâ‚ : get_functor_pushforward_structure (image_mem_functor_pushforward G T hf) with âŸ¨X, g, f', hg, eqâŸ©\n  simpa using hG.compatible â„± h f' ((Â«exprğŸ™Â») _) hg hf (by simp [Eq])\n#align compatible_preserving.apply_map compatible_preserving.apply_map\n\n"}