{"pullback_is_sheaf_of_cover_preserving":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/-- If `G` is cover-preserving and compatible-preserving,\nthen `G.op ⋙ _` pulls sheaves back to sheaves.\n\nThis result is basically <https://stacks.math.columbia.edu/tag/00WW>.\n-/\ntheorem pullback_is_sheaf_of_cover_preserving {G : «expr ⥤ » C D} (hG₁ : CompatiblePreserving.{v₃} K G)\n    (hG₂ : CoverPreserving J K G) (ℱ : Sheaf K A) : Presheaf.IsSheaf J («expr ⋙ » G.op ℱ.val) :=\n  by\n  intro X U S hS x hx\n  change family_of_elements («expr ⋙ » G.op («expr ⋙ » ℱ.val (coyoneda.obj (op X)))) _ at x\n  let H := ℱ.2 X _ (hG₂.cover_preserve hS)\n  let hx' := hx.functor_pushforward hG₁ (sheaf_over ℱ X)\n  constructor; swap\n  · apply H.amalgamate (x.functor_pushforward G)\n    exact hx'\n  constructor\n  · intro V f hf\n    convert H.is_amalgamation hx' (G.map f) (image_mem_functor_pushforward G S hf)\n    rw [hG₁.apply_map (sheaf_over ℱ X) hx]\n  · intro y hy\n    refine' H.is_separated_for _ y _ _ (H.is_amalgamation (hx.functor_pushforward hG₁ (sheaf_over ℱ X)))\n    rintro V f ⟨Z, f', g', h, rfl⟩\n    erw [family_of_elements.comp_of_compatible (S.functor_pushforward G) hx' (image_mem_functor_pushforward G S h) g']\n    dsimp\n    simp [hG₁.apply_map (sheaf_over ℱ X) hx h, ← hy f' h]\n#align pullback_is_sheaf_of_cover_preserving pullback_is_sheaf_of_cover_preserving\n\n",
 "id_cover_preserving":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟭» -/\n/-\nCopyright (c) 2021 Andrew Yang. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Andrew Yang\n-/\n/-- The identity functor on a site is cover-preserving. -/\ntheorem id_cover_preserving : CoverPreserving J J ((«expr𝟭») _) :=\n  ⟨fun U S hS => by simpa using hS⟩\n#align id_cover_preserving id_cover_preserving\n\n",
 "functor_pushforward":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/-- `compatible_preserving` functors indeed preserve compatible families. -/\ntheorem presieve.family_of_elements.compatible.functor_pushforward : (x.functor_pushforward G).compatible :=\n  by\n  rintro Z₁ Z₂ W g₁ g₂ f₁' f₂' H₁ H₂ eq\n  unfold family_of_elements.functor_pushforward\n  rcases get_functor_pushforward_structure H₁ with ⟨X₁, f₁, h₁, hf₁, rfl⟩\n  rcases get_functor_pushforward_structure H₂ with ⟨X₂, f₂, h₂, hf₂, rfl⟩\n  suffices : ℱ.val.map («expr ≫ » g₁ h₁).op (x f₁ hf₁) = ℱ.val.map («expr ≫ » g₂ h₂).op (x f₂ hf₂)\n  simpa using this\n  apply hG.compatible ℱ h _ _ hf₁ hf₂\n  simpa using Eq\n#align presieve.family_of_elements.compatible.functor_pushforward presieve.family_of_elements.compatible.functor_pushforward\n\n",
 "compatible_preserving_of_flat":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\ntheorem compatible_preserving_of_flat {C : Type u₁} [Category.{v₁} C] {D : Type u₁} [Category.{v₁} D]\n    (K : GrothendieckTopology D) (G : «expr ⥤ » C D) [RepresentablyFlat G] : CompatiblePreserving K G :=\n  by\n  constructor\n  intro ℱ Z T x hx Y₁ Y₂ X f₁ f₂ g₁ g₂ hg₁ hg₂ e\n  -- First, `f₁` and `f₂` form a cone over `cospan g₁ g₂ ⋙ u`.\n  let c : cone («expr ⋙ » (cospan g₁ g₂) G) :=\n    (cones.postcompose (diagram_iso_cospan («expr ⋙ » (cospan g₁ g₂) G)).inv).obj (pullback_cone.mk f₁ f₂ e)\n  /-\n    This can then be viewed as a cospan of structured arrows, and we may obtain an arbitrary cone\n    over it since `structured_arrow W u` is cofiltered.\n    Then, it suffices to prove that it is compatible when restricted onto `u(c'.X.right)`.\n    -/\n  let c' := is_cofiltered.cone («expr ⋙ » (structured_arrow_cone.to_diagram c) (structured_arrow.pre _ _ _))\n  have eq₁ : f₁ = «expr ≫ » («expr ≫ » c'.X.hom (G.map (c'.π.app left).right)) (eq_to_hom (by simp)) :=\n    by\n    erw [← (c'.π.app left).w]\n    dsimp\n    simp\n  have eq₂ : f₂ = «expr ≫ » («expr ≫ » c'.X.hom (G.map (c'.π.app right).right)) (eq_to_hom (by simp)) :=\n    by\n    erw [← (c'.π.app right).w]\n    dsimp\n    simp\n  conv_lhs => rw [eq₁]\n  conv_rhs => rw [eq₂]\n  simp only [op_comp, functor.map_comp, types_comp_apply, eq_to_hom_op, eq_to_hom_map]\n  congr 1\n  /-\n    Since everything now falls in the image of `u`,\n    the result follows from the compatibility of `x` in the image of `u`.\n    -/\n  injection c'.π.naturality walking_cospan.hom.inl with _ e₁\n  injection c'.π.naturality walking_cospan.hom.inr with _ e₂\n  exact hx (c'.π.app left).right (c'.π.app right).right hg₁ hg₂ (e₁.symm.trans e₂)\n#align compatible_preserving_of_flat compatible_preserving_of_flat\n\n",
 "compatible_preserving_of_downwards_closed":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≅ » -/\ntheorem compatible_preserving_of_downwards_closed (F : «expr ⥤ » C D) [Full F] [Faithful F]\n    (hF : ∀ {c : C} {d : D} (f : «expr ⟶ » d (F.obj c)), Σc', «expr ≅ » (F.obj c') d) : CompatiblePreserving K F :=\n  by\n  constructor\n  introv hx he\n  obtain ⟨X', e⟩ := hF f₁\n  apply (ℱ.1.map_iso e.op).to_equiv.injective\n  simp only [iso.op_hom, iso.to_equiv_fun, ℱ.1.map_iso_hom, ← functor_to_types.map_comp_apply]\n  simpa using\n    hx (F.preimage <| «expr ≫ » e.hom f₁) (F.preimage <| «expr ≫ » e.hom f₂) hg₁ hg₂\n      (F.map_injective <| by simpa using he)\n#align compatible_preserving_of_downwards_closed compatible_preserving_of_downwards_closed\n\n",
 "comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/-- The composition of two cover-preserving functors is cover-preserving. -/\ntheorem cover_preserving.comp {F} (hF : CoverPreserving J K F) {G} (hG : CoverPreserving K L G) :\n    CoverPreserving J L («expr ⋙ » F G) :=\n  ⟨fun U S hS => by\n    rw [sieve.functor_pushforward_comp]\n    exact hG.cover_preserve (hF.cover_preserve hS)⟩\n#align cover_preserving.comp cover_preserving.comp\n\n",
 "apply_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n@[simp]\ntheorem compatible_preserving.apply_map {Y : C} {f : «expr ⟶ » Y Z} (hf : T f) :\n    x.functor_pushforward G (G.map f) (image_mem_functorPushforward G T hf) = x f hf :=\n  by\n  unfold family_of_elements.functor_pushforward\n  rcases e₁ : get_functor_pushforward_structure (image_mem_functor_pushforward G T hf) with ⟨X, g, f', hg, eq⟩\n  simpa using hG.compatible ℱ h f' ((«expr𝟙») _) hg hf (by simp [Eq])\n#align compatible_preserving.apply_map compatible_preserving.apply_map\n\n"}