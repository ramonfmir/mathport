{"pullback_is_sheaf_of_cover_preserving":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/-- If `G` is cover-preserving and compatible-preserving,\nthen `G.op ⋙ _` pulls sheaves back to sheaves.\n\nThis result is basically <https://stacks.math.columbia.edu/tag/00WW>.\n-/\ntheorem pullback_is_sheaf_of_cover_preserving {G : «expr ⥤ » C D} (hG₁ : compatible_preserving.{v₃} K G)\n    (hG₂ : cover_preserving J K G) (ℱ : Sheaf K A) : presheaf.is_sheaf J («expr ⋙ » G.op ℱ.val) :=\n  by\n  intro X U S hS x hx\n  change family_of_elements («expr ⋙ » G.op («expr ⋙ » ℱ.val (coyoneda.obj (op X)))) _ at x\n  let H := ℱ.2 X _ (hG₂.cover_preserve hS)\n  let hx' := hx.functor_pushforward hG₁ (sheaf_over ℱ X)\n  constructor; swap\n  · apply H.amalgamate (x.functor_pushforward G)\n    exact hx'\n  constructor\n  · intro V f hf\n    convert H.is_amalgamation hx' (G.map f) (image_mem_functor_pushforward G S hf)\n    rw [hG₁.apply_map (sheaf_over ℱ X) hx]\n  · intro y hy\n    refine' H.is_separated_for _ y _ _ (H.is_amalgamation (hx.functor_pushforward hG₁ (sheaf_over ℱ X)))\n    rintro V f ⟨Z, f', g', h, rfl⟩\n    erw [family_of_elements.comp_of_compatible (S.functor_pushforward G) hx' (image_mem_functor_pushforward G S h) g']\n    dsimp\n    simp [hG₁.apply_map (sheaf_over ℱ X) hx h, ← hy f' h]\n#align pullback_is_sheaf_of_cover_preserving pullback_is_sheaf_of_cover_preserving\n\n",
 "id_cover_preserving":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟭» -/\n/-\nCopyright (c) 2021 Andrew Yang. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Andrew Yang\n-/\n/-- The identity functor on a site is cover-preserving. -/\ntheorem id_cover_preserving : cover_preserving J J ((«expr𝟭») _) :=\n  ⟨fun U S hS => by simpa using hS⟩\n#align id_cover_preserving id_cover_preserving\n\n",
 "functor_pushforward":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/-- `compatible_preserving` functors indeed preserve compatible families. -/\ntheorem presieve.family_of_elements.compatible.functor_pushforward : (x.functor_pushforward G).compatible :=\n  by\n  rintro Z₁ Z₂ W g₁ g₂ f₁' f₂' H₁ H₂ eq\n  unfold family_of_elements.functor_pushforward\n  rcases get_functor_pushforward_structure H₁ with ⟨X₁, f₁, h₁, hf₁, rfl⟩\n  rcases get_functor_pushforward_structure H₂ with ⟨X₂, f₂, h₂, hf₂, rfl⟩\n  suffices : ℱ.val.map («expr ≫ » g₁ h₁).op (x f₁ hf₁) = ℱ.val.map («expr ≫ » g₂ h₂).op (x f₂ hf₂)\n  simpa using this\n  apply hG.compatible ℱ h _ _ hf₁ hf₂\n  simpa using eq\n#align\n  presieve.family_of_elements.compatible.functor_pushforward presieve.family_of_elements.compatible.functor_pushforward\n\n",
 "compatible_preserving_of_flat":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- failed to parenthesize: parenthesize: uncaught backtrack exception\n[PrettyPrinter.parenthesize.input] (Command.declaration\n     (Command.declModifiers [] [] [] [] [] [])\n     (Command.theorem\n      \"theorem\"\n      (Command.declId `compatible_preserving_of_flat [])\n      (Command.declSig\n       [(Term.implicitBinder \"{\" [`C] [\":\" (Term.type \"Type\" [`u₁])] \"}\")\n        (Term.instBinder \"[\" [] (Term.app (Term.explicitUniv `Category \".{\" [`v₁] \"}\") [`C]) \"]\")\n        (Term.implicitBinder \"{\" [`D] [\":\" (Term.type \"Type\" [`u₁])] \"}\")\n        (Term.instBinder \"[\" [] (Term.app (Term.explicitUniv `Category \".{\" [`v₁] \"}\") [`D]) \"]\")\n        (Term.explicitBinder \"(\" [`K] [\":\" (Term.app `grothendieck_topology [`D])] [] \")\")\n        (Term.explicitBinder \"(\" [`G] [\":\" (Term.app `«expr ⥤ » [`C `D])] [] \")\")\n        (Term.instBinder \"[\" [] (Term.app `representably_flat [`G]) \"]\")]\n       (Term.typeSpec \":\" (Term.app `compatible_preserving [`K `G])))\n      (Command.declValSimple\n       \":=\"\n       (Term.byTactic\n        \"by\"\n        (Tactic.tacticSeq\n         (Tactic.tacticSeq1Indented\n          [(Tactic.constructor \"constructor\")\n           []\n           (Tactic.intro \"intro\" [`ℱ `Z `T `x `hx `Y₁ `Y₂ `X `f₁ `f₂ `g₁ `g₂ `hg₁ `hg₂ `e])\n           []\n           (Tactic.tacticLet_\n            \"let\"\n            (Term.letDecl\n             (Term.letIdDecl\n              `c\n              []\n              [(Term.typeSpec \":\" (Term.app `cone [(Term.app `«expr ⋙ » [(Term.app `cospan [`g₁ `g₂]) `G])]))]\n              \":=\"\n              (Term.app\n               (Term.proj\n                (Term.app\n                 `cones.postcompose\n                 [(Term.proj\n                   (Term.app `diagram_iso_cospan [(Term.app `«expr ⋙ » [(Term.app `cospan [`g₁ `g₂]) `G])])\n                   \".\"\n                   `inv)])\n                \".\"\n                `obj)\n               [(Term.app `pullback_cone.mk [`f₁ `f₂ `e])]))))\n           []\n           (Tactic.tacticLet_\n            \"let\"\n            (Term.letDecl\n             (Term.letIdDecl\n              `c'\n              []\n              []\n              \":=\"\n              (Term.app\n               `is_cofiltered.cone\n               [(Term.app\n                 `«expr ⋙ »\n                 [(Term.app `structured_arrow_cone.to_diagram [`c])\n                  (Term.app `structured_arrow.pre [(Term.hole \"_\") (Term.hole \"_\") (Term.hole \"_\")])])]))))\n           []\n           (Tactic.tacticHave_\n            \"have\"\n            (Term.haveDecl\n             (Term.haveIdDecl\n              [`eq₁ []]\n              [(Term.typeSpec\n                \":\"\n                («term_=_»\n                 `f₁\n                 \"=\"\n                 (Term.app\n                  `«expr ≫ »\n                  [(Term.app\n                    `«expr ≫ »\n                    [`c'.X.hom (Term.app `G.map [(Term.proj (Term.app `c'.π.app [`left]) \".\" `right)])])\n                   (Term.app\n                    `eq_to_hom\n                    [(Term.byTactic\n                      \"by\"\n                      (Tactic.tacticSeq (Tactic.tacticSeq1Indented [(Tactic.simp \"simp\" [] [] [] [] [])])))])])))]\n              \":=\"\n              (Term.byTactic\n               \"by\"\n               (Tactic.tacticSeq\n                (Tactic.tacticSeq1Indented\n                 [(Tactic.tacticErw__\n                   \"erw\"\n                   (Tactic.rwRuleSeq\n                    \"[\"\n                    [(Tactic.rwRule [(patternIgnore (token.«← » \"←\"))] (Term.proj (Term.app `c'.π.app [`left]) \".\" `w))]\n                    \"]\")\n                   [])\n                  []\n                  (Tactic.dsimp \"dsimp\" [] [] [] [] [])\n                  []\n                  (Tactic.simp \"simp\" [] [] [] [] [])]))))))\n           []\n           (Tactic.tacticHave_\n            \"have\"\n            (Term.haveDecl\n             (Term.haveIdDecl\n              [`eq₂ []]\n              [(Term.typeSpec\n                \":\"\n                («term_=_»\n                 `f₂\n                 \"=\"\n                 (Term.app\n                  `«expr ≫ »\n                  [(Term.app\n                    `«expr ≫ »\n                    [`c'.X.hom (Term.app `G.map [(Term.proj (Term.app `c'.π.app [`right]) \".\" `right)])])\n                   (Term.app\n                    `eq_to_hom\n                    [(Term.byTactic\n                      \"by\"\n                      (Tactic.tacticSeq (Tactic.tacticSeq1Indented [(Tactic.simp \"simp\" [] [] [] [] [])])))])])))]\n              \":=\"\n              (Term.byTactic\n               \"by\"\n               (Tactic.tacticSeq\n                (Tactic.tacticSeq1Indented\n                 [(Tactic.tacticErw__\n                   \"erw\"\n                   (Tactic.rwRuleSeq\n                    \"[\"\n                    [(Tactic.rwRule\n                      [(patternIgnore (token.«← » \"←\"))]\n                      (Term.proj (Term.app `c'.π.app [`right]) \".\" `w))]\n                    \"]\")\n                   [])\n                  []\n                  (Tactic.dsimp \"dsimp\" [] [] [] [] [])\n                  []\n                  (Tactic.simp \"simp\" [] [] [] [] [])]))))))\n           []\n           (Mathlib.Tactic.Conv.convLHS\n            \"conv_lhs\"\n            []\n            []\n            \"=>\"\n            (Tactic.Conv.convSeq\n             (Tactic.Conv.convSeq1Indented\n              [(Tactic.Conv.convRw__ \"rw\" [] (Tactic.rwRuleSeq \"[\" [(Tactic.rwRule [] `eq₁)] \"]\"))])))\n           []\n           (Mathlib.Tactic.Conv.convRHS\n            \"conv_rhs\"\n            []\n            []\n            \"=>\"\n            (Tactic.Conv.convSeq\n             (Tactic.Conv.convSeq1Indented\n              [(Tactic.Conv.convRw__ \"rw\" [] (Tactic.rwRuleSeq \"[\" [(Tactic.rwRule [] `eq₂)] \"]\"))])))\n           []\n           (Tactic.simp\n            \"simp\"\n            []\n            []\n            [\"only\"]\n            [\"[\"\n             [(Tactic.simpLemma [] [] `op_comp)\n              \",\"\n              (Tactic.simpLemma [] [] `functor.map_comp)\n              \",\"\n              (Tactic.simpLemma [] [] `types_comp_apply)\n              \",\"\n              (Tactic.simpLemma [] [] `eq_to_hom_op)\n              \",\"\n              (Tactic.simpLemma [] [] `eq_to_hom_map)]\n             \"]\"]\n            [])\n           []\n           (Tactic.congr \"congr\" [(num \"1\")])\n           []\n           (Tactic.injection \"injection\" (Term.app `c'.π.naturality [`walking_cospan.hom.inl]) [\"with\" [\"_\" `e₁]])\n           []\n           (Tactic.injection \"injection\" (Term.app `c'.π.naturality [`walking_cospan.hom.inr]) [\"with\" [\"_\" `e₂]])\n           []\n           (Tactic.exact\n            \"exact\"\n            (Term.app\n             `hx\n             [(Term.proj (Term.app `c'.π.app [`left]) \".\" `right)\n              (Term.proj (Term.app `c'.π.app [`right]) \".\" `right)\n              `hg₁\n              `hg₂\n              (Term.app `e₁.symm.trans [`e₂])]))])))\n       [])\n      []\n      []))\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.byTactic\n       \"by\"\n       (Tactic.tacticSeq\n        (Tactic.tacticSeq1Indented\n         [(Tactic.constructor \"constructor\")\n          []\n          (Tactic.intro \"intro\" [`ℱ `Z `T `x `hx `Y₁ `Y₂ `X `f₁ `f₂ `g₁ `g₂ `hg₁ `hg₂ `e])\n          []\n          (Tactic.tacticLet_\n           \"let\"\n           (Term.letDecl\n            (Term.letIdDecl\n             `c\n             []\n             [(Term.typeSpec \":\" (Term.app `cone [(Term.app `«expr ⋙ » [(Term.app `cospan [`g₁ `g₂]) `G])]))]\n             \":=\"\n             (Term.app\n              (Term.proj\n               (Term.app\n                `cones.postcompose\n                [(Term.proj\n                  (Term.app `diagram_iso_cospan [(Term.app `«expr ⋙ » [(Term.app `cospan [`g₁ `g₂]) `G])])\n                  \".\"\n                  `inv)])\n               \".\"\n               `obj)\n              [(Term.app `pullback_cone.mk [`f₁ `f₂ `e])]))))\n          []\n          (Tactic.tacticLet_\n           \"let\"\n           (Term.letDecl\n            (Term.letIdDecl\n             `c'\n             []\n             []\n             \":=\"\n             (Term.app\n              `is_cofiltered.cone\n              [(Term.app\n                `«expr ⋙ »\n                [(Term.app `structured_arrow_cone.to_diagram [`c])\n                 (Term.app `structured_arrow.pre [(Term.hole \"_\") (Term.hole \"_\") (Term.hole \"_\")])])]))))\n          []\n          (Tactic.tacticHave_\n           \"have\"\n           (Term.haveDecl\n            (Term.haveIdDecl\n             [`eq₁ []]\n             [(Term.typeSpec\n               \":\"\n               («term_=_»\n                `f₁\n                \"=\"\n                (Term.app\n                 `«expr ≫ »\n                 [(Term.app\n                   `«expr ≫ »\n                   [`c'.X.hom (Term.app `G.map [(Term.proj (Term.app `c'.π.app [`left]) \".\" `right)])])\n                  (Term.app\n                   `eq_to_hom\n                   [(Term.byTactic\n                     \"by\"\n                     (Tactic.tacticSeq (Tactic.tacticSeq1Indented [(Tactic.simp \"simp\" [] [] [] [] [])])))])])))]\n             \":=\"\n             (Term.byTactic\n              \"by\"\n              (Tactic.tacticSeq\n               (Tactic.tacticSeq1Indented\n                [(Tactic.tacticErw__\n                  \"erw\"\n                  (Tactic.rwRuleSeq\n                   \"[\"\n                   [(Tactic.rwRule [(patternIgnore (token.«← » \"←\"))] (Term.proj (Term.app `c'.π.app [`left]) \".\" `w))]\n                   \"]\")\n                  [])\n                 []\n                 (Tactic.dsimp \"dsimp\" [] [] [] [] [])\n                 []\n                 (Tactic.simp \"simp\" [] [] [] [] [])]))))))\n          []\n          (Tactic.tacticHave_\n           \"have\"\n           (Term.haveDecl\n            (Term.haveIdDecl\n             [`eq₂ []]\n             [(Term.typeSpec\n               \":\"\n               («term_=_»\n                `f₂\n                \"=\"\n                (Term.app\n                 `«expr ≫ »\n                 [(Term.app\n                   `«expr ≫ »\n                   [`c'.X.hom (Term.app `G.map [(Term.proj (Term.app `c'.π.app [`right]) \".\" `right)])])\n                  (Term.app\n                   `eq_to_hom\n                   [(Term.byTactic\n                     \"by\"\n                     (Tactic.tacticSeq (Tactic.tacticSeq1Indented [(Tactic.simp \"simp\" [] [] [] [] [])])))])])))]\n             \":=\"\n             (Term.byTactic\n              \"by\"\n              (Tactic.tacticSeq\n               (Tactic.tacticSeq1Indented\n                [(Tactic.tacticErw__\n                  \"erw\"\n                  (Tactic.rwRuleSeq\n                   \"[\"\n                   [(Tactic.rwRule [(patternIgnore (token.«← » \"←\"))] (Term.proj (Term.app `c'.π.app [`right]) \".\" `w))]\n                   \"]\")\n                  [])\n                 []\n                 (Tactic.dsimp \"dsimp\" [] [] [] [] [])\n                 []\n                 (Tactic.simp \"simp\" [] [] [] [] [])]))))))\n          []\n          (Mathlib.Tactic.Conv.convLHS\n           \"conv_lhs\"\n           []\n           []\n           \"=>\"\n           (Tactic.Conv.convSeq\n            (Tactic.Conv.convSeq1Indented\n             [(Tactic.Conv.convRw__ \"rw\" [] (Tactic.rwRuleSeq \"[\" [(Tactic.rwRule [] `eq₁)] \"]\"))])))\n          []\n          (Mathlib.Tactic.Conv.convRHS\n           \"conv_rhs\"\n           []\n           []\n           \"=>\"\n           (Tactic.Conv.convSeq\n            (Tactic.Conv.convSeq1Indented\n             [(Tactic.Conv.convRw__ \"rw\" [] (Tactic.rwRuleSeq \"[\" [(Tactic.rwRule [] `eq₂)] \"]\"))])))\n          []\n          (Tactic.simp\n           \"simp\"\n           []\n           []\n           [\"only\"]\n           [\"[\"\n            [(Tactic.simpLemma [] [] `op_comp)\n             \",\"\n             (Tactic.simpLemma [] [] `functor.map_comp)\n             \",\"\n             (Tactic.simpLemma [] [] `types_comp_apply)\n             \",\"\n             (Tactic.simpLemma [] [] `eq_to_hom_op)\n             \",\"\n             (Tactic.simpLemma [] [] `eq_to_hom_map)]\n            \"]\"]\n           [])\n          []\n          (Tactic.congr \"congr\" [(num \"1\")])\n          []\n          (Tactic.injection \"injection\" (Term.app `c'.π.naturality [`walking_cospan.hom.inl]) [\"with\" [\"_\" `e₁]])\n          []\n          (Tactic.injection \"injection\" (Term.app `c'.π.naturality [`walking_cospan.hom.inr]) [\"with\" [\"_\" `e₂]])\n          []\n          (Tactic.exact\n           \"exact\"\n           (Term.app\n            `hx\n            [(Term.proj (Term.app `c'.π.app [`left]) \".\" `right)\n             (Term.proj (Term.app `c'.π.app [`right]) \".\" `right)\n             `hg₁\n             `hg₂\n             (Term.app `e₁.symm.trans [`e₂])]))])))\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.exact\n       \"exact\"\n       (Term.app\n        `hx\n        [(Term.proj (Term.app `c'.π.app [`left]) \".\" `right)\n         (Term.proj (Term.app `c'.π.app [`right]) \".\" `right)\n         `hg₁\n         `hg₂\n         (Term.app `e₁.symm.trans [`e₂])]))\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.app\n       `hx\n       [(Term.proj (Term.app `c'.π.app [`left]) \".\" `right)\n        (Term.proj (Term.app `c'.π.app [`right]) \".\" `right)\n        `hg₁\n        `hg₂\n        (Term.app `e₁.symm.trans [`e₂])])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.namedArgument'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.ellipsis'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.app `e₁.symm.trans [`e₂])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `e₂\n[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))\n      `e₁.symm.trans\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1022, term)\n[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1022, (some 1023, term) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] parenthesized: (Term.paren \"(\" (Term.app `e₁.symm.trans [`e₂]) \")\")\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))\n      `hg₂\n[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (some 1024, term)\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))\n      `hg₁\n[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (some 1024, term)\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.proj', expected 'Lean.Parser.Term.namedArgument'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.proj', expected 'Lean.Parser.Term.ellipsis'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))\n      (Term.proj (Term.app `c'.π.app [`right]) \".\" `right)\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))\n      (Term.app `c'.π.app [`right])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `right\n[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))\n      `c'.π.app\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1022, term)\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (some 1024, term)\n[PrettyPrinter.parenthesize] parenthesized: (Term.paren \"(\" (Term.app `c'.π.app [`right]) \")\")\n[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (some 1024, term)\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.proj', expected 'Lean.Parser.Term.namedArgument'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.proj', expected 'Lean.Parser.Term.ellipsis'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))\n      (Term.proj (Term.app `c'.π.app [`left]) \".\" `right)\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))\n      (Term.app `c'.π.app [`left])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `left\n[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))\n      `c'.π.app\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1022, term)\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (some 1024, term)\n[PrettyPrinter.parenthesize] parenthesized: (Term.paren \"(\" (Term.app `c'.π.app [`left]) \")\")\n[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (some 1024, term)\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))\n      `hx\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1022, term)\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.injection \"injection\" (Term.app `c'.π.naturality [`walking_cospan.hom.inr]) [\"with\" [\"_\" `e₂]])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind '_', expected 'ident'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind '_', expected 'Lean.Parser.Term.hole'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.declValEqns'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.whereStructInst'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception\ntheorem\n  compatible_preserving_of_flat\n  { C : Type u₁ }\n      [ Category .{ v₁ } C ]\n      { D : Type u₁ }\n      [ Category .{ v₁ } D ]\n      ( K : grothendieck_topology D )\n      ( G : «expr ⥤ » C D )\n      [ representably_flat G ]\n    : compatible_preserving K G\n  :=\n    by\n      constructor\n        intro ℱ Z T x hx Y₁ Y₂ X f₁ f₂ g₁ g₂ hg₁ hg₂ e\n        let\n          c\n            : cone «expr ⋙ » cospan g₁ g₂ G\n            :=\n            cones.postcompose diagram_iso_cospan «expr ⋙ » cospan g₁ g₂ G . inv . obj pullback_cone.mk f₁ f₂ e\n        let c' := is_cofiltered.cone «expr ⋙ » structured_arrow_cone.to_diagram c structured_arrow.pre _ _ _\n        have\n          eq₁\n            : f₁ = «expr ≫ » «expr ≫ » c'.X.hom G.map c'.π.app left . right eq_to_hom by simp\n            :=\n            by erw [ ← c'.π.app left . w ] dsimp simp\n        have\n          eq₂\n            : f₂ = «expr ≫ » «expr ≫ » c'.X.hom G.map c'.π.app right . right eq_to_hom by simp\n            :=\n            by erw [ ← c'.π.app right . w ] dsimp simp\n        conv_lhs => rw [ eq₁ ]\n        conv_rhs => rw [ eq₂ ]\n        simp only [ op_comp , functor.map_comp , types_comp_apply , eq_to_hom_op , eq_to_hom_map ]\n        congr 1\n        injection c'.π.naturality walking_cospan.hom.inl with _ e₁\n        injection c'.π.naturality walking_cospan.hom.inr with _ e₂\n        exact hx c'.π.app left . right c'.π.app right . right hg₁ hg₂ e₁.symm.trans e₂\n#align compatible_preserving_of_flat compatible_preserving_of_flat\n\n",
 "compatible_preserving_of_downwards_closed":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≅ » -/\ntheorem compatible_preserving_of_downwards_closed (F : «expr ⥤ » C D) [Full F] [Faithful F]\n    (hF : ∀ {c : C} {d : D} (f : «expr ⟶ » d (F.obj c)), Σc', «expr ≅ » (F.obj c') d) : compatible_preserving K F :=\n  by\n  constructor\n  introv hx he\n  obtain ⟨X', e⟩ := hF f₁\n  apply (ℱ.1.map_iso e.op).to_equiv.injective\n  simp only [iso.op_hom, iso.to_equiv_fun, ℱ.1.map_iso_hom, ← functor_to_types.map_comp_apply]\n  simpa using\n    hx (F.preimage <| «expr ≫ » e.hom f₁) (F.preimage <| «expr ≫ » e.hom f₂) hg₁ hg₂\n      (F.map_injective <| by simpa using he)\n#align compatible_preserving_of_downwards_closed compatible_preserving_of_downwards_closed\n\n",
 "comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/-- The composition of two cover-preserving functors is cover-preserving. -/\ntheorem cover_preserving.comp {F} (hF : cover_preserving J K F) {G} (hG : cover_preserving K L G) :\n    cover_preserving J L («expr ⋙ » F G) :=\n  ⟨fun U S hS => by\n    rw [sieve.functor_pushforward_comp]\n    exact hG.cover_preserve (hF.cover_preserve hS)⟩\n#align cover_preserving.comp cover_preserving.comp\n\n",
 "apply_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n@[simp]\ntheorem compatible_preserving.apply_map {Y : C} {f : «expr ⟶ » Y Z} (hf : T f) :\n    x.functor_pushforward G (G.map f) (image_mem_functor_pushforward G T hf) = x f hf :=\n  by\n  unfold family_of_elements.functor_pushforward\n  rcases e₁ : get_functor_pushforward_structure (image_mem_functor_pushforward G T hf) with ⟨X, g, f', hg, eq⟩\n  simpa using hG.compatible ℱ h f' ((«expr𝟙») _) hg hf (by simp [eq])\n#align compatible_preserving.apply_map compatible_preserving.apply_map\n\n"}