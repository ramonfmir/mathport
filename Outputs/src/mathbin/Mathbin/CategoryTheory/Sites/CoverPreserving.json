{"pullback_is_sheaf_of_cover_preserving":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‹™ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‹™ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‹™ Â» -/\n/-- If `G` is cover-preserving and compatible-preserving,\nthen `G.op â‹™ _` pulls sheaves back to sheaves.\n\nThis result is basically <https://stacks.math.columbia.edu/tag/00WW>.\n-/\ntheorem pullback_is_sheaf_of_cover_preserving {G : Â«expr â¥¤ Â» C D} (hGâ‚ : compatible_preserving.{vâ‚ƒ} K G)\n    (hGâ‚‚ : cover_preserving J K G) (â„± : Sheaf K A) : presheaf.is_sheaf J (Â«expr â‹™ Â» G.op â„±.val) :=\n  by\n  intro X U S hS x hx\n  change family_of_elements (Â«expr â‹™ Â» G.op (Â«expr â‹™ Â» â„±.val (coyoneda.obj (op X)))) _ at x\n  let H := â„±.2 X _ (hGâ‚‚.cover_preserve hS)\n  let hx' := hx.functor_pushforward hGâ‚ (sheaf_over â„± X)\n  constructor; swap\n  Â· apply H.amalgamate (x.functor_pushforward G)\n    exact hx'\n  constructor\n  Â· intro V f hf\n    convert H.is_amalgamation hx' (G.map f) (image_mem_functor_pushforward G S hf)\n    rw [hGâ‚.apply_map (sheaf_over â„± X) hx]\n  Â· intro y hy\n    refine' H.is_separated_for _ y _ _ (H.is_amalgamation (hx.functor_pushforward hGâ‚ (sheaf_over â„± X)))\n    rintro V f âŸ¨Z, f', g', h, rflâŸ©\n    erw [family_of_elements.comp_of_compatible (S.functor_pushforward G) hx' (image_mem_functor_pushforward G S h) g']\n    dsimp\n    simp [hGâ‚.apply_map (sheaf_over â„± X) hx h, â† hy f' h]\n#align pullback_is_sheaf_of_cover_preserving pullback_is_sheaf_of_cover_preserving\n\n",
 "id_cover_preserving":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ­Â» -/\n/-\nCopyright (c) 2021 Andrew Yang. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Andrew Yang\n-/\n/-- The identity functor on a site is cover-preserving. -/\ntheorem id_cover_preserving : cover_preserving J J ((Â«exprğŸ­Â») _) :=\n  âŸ¨fun U S hS => by simpa using hSâŸ©\n#align id_cover_preserving id_cover_preserving\n\n",
 "functor_pushforward":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/-- `compatible_preserving` functors indeed preserve compatible families. -/\ntheorem presieve.family_of_elements.compatible.functor_pushforward : (x.functor_pushforward G).compatible :=\n  by\n  rintro Zâ‚ Zâ‚‚ W gâ‚ gâ‚‚ fâ‚' fâ‚‚' Hâ‚ Hâ‚‚ eq\n  unfold family_of_elements.functor_pushforward\n  rcases get_functor_pushforward_structure Hâ‚ with âŸ¨Xâ‚, fâ‚, hâ‚, hfâ‚, rflâŸ©\n  rcases get_functor_pushforward_structure Hâ‚‚ with âŸ¨Xâ‚‚, fâ‚‚, hâ‚‚, hfâ‚‚, rflâŸ©\n  suffices : â„±.val.map (Â«expr â‰« Â» gâ‚ hâ‚).op (x fâ‚ hfâ‚) = â„±.val.map (Â«expr â‰« Â» gâ‚‚ hâ‚‚).op (x fâ‚‚ hfâ‚‚)\n  simpa using this\n  apply hG.compatible â„± h _ _ hfâ‚ hfâ‚‚\n  simpa using eq\n#align\n  presieve.family_of_elements.compatible.functor_pushforward presieve.family_of_elements.compatible.functor_pushforward\n\n",
 "compatible_preserving_of_flat":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‹™ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‹™ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‹™ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- failed to parenthesize: parenthesize: uncaught backtrack exception\n[PrettyPrinter.parenthesize.input] (Command.declaration\n     (Command.declModifiers [] [] [] [] [] [])\n     (Command.theorem\n      \"theorem\"\n      (Command.declId `compatible_preserving_of_flat [])\n      (Command.declSig\n       [(Term.implicitBinder \"{\" [`C] [\":\" (Term.type \"Type\" [`uâ‚])] \"}\")\n        (Term.instBinder \"[\" [] (Term.app (Term.explicitUniv `Category \".{\" [`vâ‚] \"}\") [`C]) \"]\")\n        (Term.implicitBinder \"{\" [`D] [\":\" (Term.type \"Type\" [`uâ‚])] \"}\")\n        (Term.instBinder \"[\" [] (Term.app (Term.explicitUniv `Category \".{\" [`vâ‚] \"}\") [`D]) \"]\")\n        (Term.explicitBinder \"(\" [`K] [\":\" (Term.app `grothendieck_topology [`D])] [] \")\")\n        (Term.explicitBinder \"(\" [`G] [\":\" (Term.app `Â«expr â¥¤ Â» [`C `D])] [] \")\")\n        (Term.instBinder \"[\" [] (Term.app `representably_flat [`G]) \"]\")]\n       (Term.typeSpec \":\" (Term.app `compatible_preserving [`K `G])))\n      (Command.declValSimple\n       \":=\"\n       (Term.byTactic\n        \"by\"\n        (Tactic.tacticSeq\n         (Tactic.tacticSeq1Indented\n          [(Tactic.constructor \"constructor\")\n           []\n           (Tactic.intro \"intro\" [`â„± `Z `T `x `hx `Yâ‚ `Yâ‚‚ `X `fâ‚ `fâ‚‚ `gâ‚ `gâ‚‚ `hgâ‚ `hgâ‚‚ `e])\n           []\n           (Tactic.tacticLet_\n            \"let\"\n            (Term.letDecl\n             (Term.letIdDecl\n              `c\n              []\n              [(Term.typeSpec \":\" (Term.app `cone [(Term.app `Â«expr â‹™ Â» [(Term.app `cospan [`gâ‚ `gâ‚‚]) `G])]))]\n              \":=\"\n              (Term.app\n               (Term.proj\n                (Term.app\n                 `cones.postcompose\n                 [(Term.proj\n                   (Term.app `diagram_iso_cospan [(Term.app `Â«expr â‹™ Â» [(Term.app `cospan [`gâ‚ `gâ‚‚]) `G])])\n                   \".\"\n                   `inv)])\n                \".\"\n                `obj)\n               [(Term.app `pullback_cone.mk [`fâ‚ `fâ‚‚ `e])]))))\n           []\n           (Tactic.tacticLet_\n            \"let\"\n            (Term.letDecl\n             (Term.letIdDecl\n              `c'\n              []\n              []\n              \":=\"\n              (Term.app\n               `is_cofiltered.cone\n               [(Term.app\n                 `Â«expr â‹™ Â»\n                 [(Term.app `structured_arrow_cone.to_diagram [`c])\n                  (Term.app `structured_arrow.pre [(Term.hole \"_\") (Term.hole \"_\") (Term.hole \"_\")])])]))))\n           []\n           (Tactic.tacticHave_\n            \"have\"\n            (Term.haveDecl\n             (Term.haveIdDecl\n              [`eqâ‚ []]\n              [(Term.typeSpec\n                \":\"\n                (Â«term_=_Â»\n                 `fâ‚\n                 \"=\"\n                 (Term.app\n                  `Â«expr â‰« Â»\n                  [(Term.app\n                    `Â«expr â‰« Â»\n                    [`c'.X.hom (Term.app `G.map [(Term.proj (Term.app `c'.Ï€.app [`left]) \".\" `right)])])\n                   (Term.app\n                    `eq_to_hom\n                    [(Term.byTactic\n                      \"by\"\n                      (Tactic.tacticSeq (Tactic.tacticSeq1Indented [(Tactic.simp \"simp\" [] [] [] [] [])])))])])))]\n              \":=\"\n              (Term.byTactic\n               \"by\"\n               (Tactic.tacticSeq\n                (Tactic.tacticSeq1Indented\n                 [(Tactic.tacticErw__\n                   \"erw\"\n                   (Tactic.rwRuleSeq\n                    \"[\"\n                    [(Tactic.rwRule [(patternIgnore (token.Â«â† Â» \"â†\"))] (Term.proj (Term.app `c'.Ï€.app [`left]) \".\" `w))]\n                    \"]\")\n                   [])\n                  []\n                  (Tactic.dsimp \"dsimp\" [] [] [] [] [])\n                  []\n                  (Tactic.simp \"simp\" [] [] [] [] [])]))))))\n           []\n           (Tactic.tacticHave_\n            \"have\"\n            (Term.haveDecl\n             (Term.haveIdDecl\n              [`eqâ‚‚ []]\n              [(Term.typeSpec\n                \":\"\n                (Â«term_=_Â»\n                 `fâ‚‚\n                 \"=\"\n                 (Term.app\n                  `Â«expr â‰« Â»\n                  [(Term.app\n                    `Â«expr â‰« Â»\n                    [`c'.X.hom (Term.app `G.map [(Term.proj (Term.app `c'.Ï€.app [`right]) \".\" `right)])])\n                   (Term.app\n                    `eq_to_hom\n                    [(Term.byTactic\n                      \"by\"\n                      (Tactic.tacticSeq (Tactic.tacticSeq1Indented [(Tactic.simp \"simp\" [] [] [] [] [])])))])])))]\n              \":=\"\n              (Term.byTactic\n               \"by\"\n               (Tactic.tacticSeq\n                (Tactic.tacticSeq1Indented\n                 [(Tactic.tacticErw__\n                   \"erw\"\n                   (Tactic.rwRuleSeq\n                    \"[\"\n                    [(Tactic.rwRule\n                      [(patternIgnore (token.Â«â† Â» \"â†\"))]\n                      (Term.proj (Term.app `c'.Ï€.app [`right]) \".\" `w))]\n                    \"]\")\n                   [])\n                  []\n                  (Tactic.dsimp \"dsimp\" [] [] [] [] [])\n                  []\n                  (Tactic.simp \"simp\" [] [] [] [] [])]))))))\n           []\n           (Mathlib.Tactic.Conv.convLHS\n            \"conv_lhs\"\n            []\n            []\n            \"=>\"\n            (Tactic.Conv.convSeq\n             (Tactic.Conv.convSeq1Indented\n              [(Tactic.Conv.convRw__ \"rw\" [] (Tactic.rwRuleSeq \"[\" [(Tactic.rwRule [] `eqâ‚)] \"]\"))])))\n           []\n           (Mathlib.Tactic.Conv.convRHS\n            \"conv_rhs\"\n            []\n            []\n            \"=>\"\n            (Tactic.Conv.convSeq\n             (Tactic.Conv.convSeq1Indented\n              [(Tactic.Conv.convRw__ \"rw\" [] (Tactic.rwRuleSeq \"[\" [(Tactic.rwRule [] `eqâ‚‚)] \"]\"))])))\n           []\n           (Tactic.simp\n            \"simp\"\n            []\n            []\n            [\"only\"]\n            [\"[\"\n             [(Tactic.simpLemma [] [] `op_comp)\n              \",\"\n              (Tactic.simpLemma [] [] `functor.map_comp)\n              \",\"\n              (Tactic.simpLemma [] [] `types_comp_apply)\n              \",\"\n              (Tactic.simpLemma [] [] `eq_to_hom_op)\n              \",\"\n              (Tactic.simpLemma [] [] `eq_to_hom_map)]\n             \"]\"]\n            [])\n           []\n           (Tactic.congr \"congr\" [(num \"1\")])\n           []\n           (Tactic.injection \"injection\" (Term.app `c'.Ï€.naturality [`walking_cospan.hom.inl]) [\"with\" [\"_\" `eâ‚]])\n           []\n           (Tactic.injection \"injection\" (Term.app `c'.Ï€.naturality [`walking_cospan.hom.inr]) [\"with\" [\"_\" `eâ‚‚]])\n           []\n           (Tactic.exact\n            \"exact\"\n            (Term.app\n             `hx\n             [(Term.proj (Term.app `c'.Ï€.app [`left]) \".\" `right)\n              (Term.proj (Term.app `c'.Ï€.app [`right]) \".\" `right)\n              `hgâ‚\n              `hgâ‚‚\n              (Term.app `eâ‚.symm.trans [`eâ‚‚])]))])))\n       [])\n      []\n      []))\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.byTactic\n       \"by\"\n       (Tactic.tacticSeq\n        (Tactic.tacticSeq1Indented\n         [(Tactic.constructor \"constructor\")\n          []\n          (Tactic.intro \"intro\" [`â„± `Z `T `x `hx `Yâ‚ `Yâ‚‚ `X `fâ‚ `fâ‚‚ `gâ‚ `gâ‚‚ `hgâ‚ `hgâ‚‚ `e])\n          []\n          (Tactic.tacticLet_\n           \"let\"\n           (Term.letDecl\n            (Term.letIdDecl\n             `c\n             []\n             [(Term.typeSpec \":\" (Term.app `cone [(Term.app `Â«expr â‹™ Â» [(Term.app `cospan [`gâ‚ `gâ‚‚]) `G])]))]\n             \":=\"\n             (Term.app\n              (Term.proj\n               (Term.app\n                `cones.postcompose\n                [(Term.proj\n                  (Term.app `diagram_iso_cospan [(Term.app `Â«expr â‹™ Â» [(Term.app `cospan [`gâ‚ `gâ‚‚]) `G])])\n                  \".\"\n                  `inv)])\n               \".\"\n               `obj)\n              [(Term.app `pullback_cone.mk [`fâ‚ `fâ‚‚ `e])]))))\n          []\n          (Tactic.tacticLet_\n           \"let\"\n           (Term.letDecl\n            (Term.letIdDecl\n             `c'\n             []\n             []\n             \":=\"\n             (Term.app\n              `is_cofiltered.cone\n              [(Term.app\n                `Â«expr â‹™ Â»\n                [(Term.app `structured_arrow_cone.to_diagram [`c])\n                 (Term.app `structured_arrow.pre [(Term.hole \"_\") (Term.hole \"_\") (Term.hole \"_\")])])]))))\n          []\n          (Tactic.tacticHave_\n           \"have\"\n           (Term.haveDecl\n            (Term.haveIdDecl\n             [`eqâ‚ []]\n             [(Term.typeSpec\n               \":\"\n               (Â«term_=_Â»\n                `fâ‚\n                \"=\"\n                (Term.app\n                 `Â«expr â‰« Â»\n                 [(Term.app\n                   `Â«expr â‰« Â»\n                   [`c'.X.hom (Term.app `G.map [(Term.proj (Term.app `c'.Ï€.app [`left]) \".\" `right)])])\n                  (Term.app\n                   `eq_to_hom\n                   [(Term.byTactic\n                     \"by\"\n                     (Tactic.tacticSeq (Tactic.tacticSeq1Indented [(Tactic.simp \"simp\" [] [] [] [] [])])))])])))]\n             \":=\"\n             (Term.byTactic\n              \"by\"\n              (Tactic.tacticSeq\n               (Tactic.tacticSeq1Indented\n                [(Tactic.tacticErw__\n                  \"erw\"\n                  (Tactic.rwRuleSeq\n                   \"[\"\n                   [(Tactic.rwRule [(patternIgnore (token.Â«â† Â» \"â†\"))] (Term.proj (Term.app `c'.Ï€.app [`left]) \".\" `w))]\n                   \"]\")\n                  [])\n                 []\n                 (Tactic.dsimp \"dsimp\" [] [] [] [] [])\n                 []\n                 (Tactic.simp \"simp\" [] [] [] [] [])]))))))\n          []\n          (Tactic.tacticHave_\n           \"have\"\n           (Term.haveDecl\n            (Term.haveIdDecl\n             [`eqâ‚‚ []]\n             [(Term.typeSpec\n               \":\"\n               (Â«term_=_Â»\n                `fâ‚‚\n                \"=\"\n                (Term.app\n                 `Â«expr â‰« Â»\n                 [(Term.app\n                   `Â«expr â‰« Â»\n                   [`c'.X.hom (Term.app `G.map [(Term.proj (Term.app `c'.Ï€.app [`right]) \".\" `right)])])\n                  (Term.app\n                   `eq_to_hom\n                   [(Term.byTactic\n                     \"by\"\n                     (Tactic.tacticSeq (Tactic.tacticSeq1Indented [(Tactic.simp \"simp\" [] [] [] [] [])])))])])))]\n             \":=\"\n             (Term.byTactic\n              \"by\"\n              (Tactic.tacticSeq\n               (Tactic.tacticSeq1Indented\n                [(Tactic.tacticErw__\n                  \"erw\"\n                  (Tactic.rwRuleSeq\n                   \"[\"\n                   [(Tactic.rwRule [(patternIgnore (token.Â«â† Â» \"â†\"))] (Term.proj (Term.app `c'.Ï€.app [`right]) \".\" `w))]\n                   \"]\")\n                  [])\n                 []\n                 (Tactic.dsimp \"dsimp\" [] [] [] [] [])\n                 []\n                 (Tactic.simp \"simp\" [] [] [] [] [])]))))))\n          []\n          (Mathlib.Tactic.Conv.convLHS\n           \"conv_lhs\"\n           []\n           []\n           \"=>\"\n           (Tactic.Conv.convSeq\n            (Tactic.Conv.convSeq1Indented\n             [(Tactic.Conv.convRw__ \"rw\" [] (Tactic.rwRuleSeq \"[\" [(Tactic.rwRule [] `eqâ‚)] \"]\"))])))\n          []\n          (Mathlib.Tactic.Conv.convRHS\n           \"conv_rhs\"\n           []\n           []\n           \"=>\"\n           (Tactic.Conv.convSeq\n            (Tactic.Conv.convSeq1Indented\n             [(Tactic.Conv.convRw__ \"rw\" [] (Tactic.rwRuleSeq \"[\" [(Tactic.rwRule [] `eqâ‚‚)] \"]\"))])))\n          []\n          (Tactic.simp\n           \"simp\"\n           []\n           []\n           [\"only\"]\n           [\"[\"\n            [(Tactic.simpLemma [] [] `op_comp)\n             \",\"\n             (Tactic.simpLemma [] [] `functor.map_comp)\n             \",\"\n             (Tactic.simpLemma [] [] `types_comp_apply)\n             \",\"\n             (Tactic.simpLemma [] [] `eq_to_hom_op)\n             \",\"\n             (Tactic.simpLemma [] [] `eq_to_hom_map)]\n            \"]\"]\n           [])\n          []\n          (Tactic.congr \"congr\" [(num \"1\")])\n          []\n          (Tactic.injection \"injection\" (Term.app `c'.Ï€.naturality [`walking_cospan.hom.inl]) [\"with\" [\"_\" `eâ‚]])\n          []\n          (Tactic.injection \"injection\" (Term.app `c'.Ï€.naturality [`walking_cospan.hom.inr]) [\"with\" [\"_\" `eâ‚‚]])\n          []\n          (Tactic.exact\n           \"exact\"\n           (Term.app\n            `hx\n            [(Term.proj (Term.app `c'.Ï€.app [`left]) \".\" `right)\n             (Term.proj (Term.app `c'.Ï€.app [`right]) \".\" `right)\n             `hgâ‚\n             `hgâ‚‚\n             (Term.app `eâ‚.symm.trans [`eâ‚‚])]))])))\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.exact\n       \"exact\"\n       (Term.app\n        `hx\n        [(Term.proj (Term.app `c'.Ï€.app [`left]) \".\" `right)\n         (Term.proj (Term.app `c'.Ï€.app [`right]) \".\" `right)\n         `hgâ‚\n         `hgâ‚‚\n         (Term.app `eâ‚.symm.trans [`eâ‚‚])]))\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.app\n       `hx\n       [(Term.proj (Term.app `c'.Ï€.app [`left]) \".\" `right)\n        (Term.proj (Term.app `c'.Ï€.app [`right]) \".\" `right)\n        `hgâ‚\n        `hgâ‚‚\n        (Term.app `eâ‚.symm.trans [`eâ‚‚])])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.namedArgument'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.ellipsis'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.app `eâ‚.symm.trans [`eâ‚‚])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `eâ‚‚\n[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))\n      `eâ‚.symm.trans\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1022, term)\n[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1022, (some 1023, term) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] parenthesized: (Term.paren \"(\" (Term.app `eâ‚.symm.trans [`eâ‚‚]) \")\")\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))\n      `hgâ‚‚\n[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (some 1024, term)\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))\n      `hgâ‚\n[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (some 1024, term)\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.proj', expected 'Lean.Parser.Term.namedArgument'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.proj', expected 'Lean.Parser.Term.ellipsis'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))\n      (Term.proj (Term.app `c'.Ï€.app [`right]) \".\" `right)\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))\n      (Term.app `c'.Ï€.app [`right])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `right\n[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))\n      `c'.Ï€.app\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1022, term)\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (some 1024, term)\n[PrettyPrinter.parenthesize] parenthesized: (Term.paren \"(\" (Term.app `c'.Ï€.app [`right]) \")\")\n[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (some 1024, term)\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.proj', expected 'Lean.Parser.Term.namedArgument'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.proj', expected 'Lean.Parser.Term.ellipsis'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))\n      (Term.proj (Term.app `c'.Ï€.app [`left]) \".\" `right)\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))\n      (Term.app `c'.Ï€.app [`left])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `left\n[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))\n      `c'.Ï€.app\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1022, term)\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (some 1024, term)\n[PrettyPrinter.parenthesize] parenthesized: (Term.paren \"(\" (Term.app `c'.Ï€.app [`left]) \")\")\n[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (some 1024, term)\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))\n      `hx\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1022, term)\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.injection \"injection\" (Term.app `c'.Ï€.naturality [`walking_cospan.hom.inr]) [\"with\" [\"_\" `eâ‚‚]])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind '_', expected 'ident'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind '_', expected 'Lean.Parser.Term.hole'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.declValEqns'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.whereStructInst'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception\ntheorem\n  compatible_preserving_of_flat\n  { C : Type uâ‚ }\n      [ Category .{ vâ‚ } C ]\n      { D : Type uâ‚ }\n      [ Category .{ vâ‚ } D ]\n      ( K : grothendieck_topology D )\n      ( G : Â«expr â¥¤ Â» C D )\n      [ representably_flat G ]\n    : compatible_preserving K G\n  :=\n    by\n      constructor\n        intro â„± Z T x hx Yâ‚ Yâ‚‚ X fâ‚ fâ‚‚ gâ‚ gâ‚‚ hgâ‚ hgâ‚‚ e\n        let\n          c\n            : cone Â«expr â‹™ Â» cospan gâ‚ gâ‚‚ G\n            :=\n            cones.postcompose diagram_iso_cospan Â«expr â‹™ Â» cospan gâ‚ gâ‚‚ G . inv . obj pullback_cone.mk fâ‚ fâ‚‚ e\n        let c' := is_cofiltered.cone Â«expr â‹™ Â» structured_arrow_cone.to_diagram c structured_arrow.pre _ _ _\n        have\n          eqâ‚\n            : fâ‚ = Â«expr â‰« Â» Â«expr â‰« Â» c'.X.hom G.map c'.Ï€.app left . right eq_to_hom by simp\n            :=\n            by erw [ â† c'.Ï€.app left . w ] dsimp simp\n        have\n          eqâ‚‚\n            : fâ‚‚ = Â«expr â‰« Â» Â«expr â‰« Â» c'.X.hom G.map c'.Ï€.app right . right eq_to_hom by simp\n            :=\n            by erw [ â† c'.Ï€.app right . w ] dsimp simp\n        conv_lhs => rw [ eqâ‚ ]\n        conv_rhs => rw [ eqâ‚‚ ]\n        simp only [ op_comp , functor.map_comp , types_comp_apply , eq_to_hom_op , eq_to_hom_map ]\n        congr 1\n        injection c'.Ï€.naturality walking_cospan.hom.inl with _ eâ‚\n        injection c'.Ï€.naturality walking_cospan.hom.inr with _ eâ‚‚\n        exact hx c'.Ï€.app left . right c'.Ï€.app right . right hgâ‚ hgâ‚‚ eâ‚.symm.trans eâ‚‚\n#align compatible_preserving_of_flat compatible_preserving_of_flat\n\n",
 "compatible_preserving_of_downwards_closed":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰… Â» -/\ntheorem compatible_preserving_of_downwards_closed (F : Â«expr â¥¤ Â» C D) [Full F] [Faithful F]\n    (hF : âˆ€ {c : C} {d : D} (f : Â«expr âŸ¶ Â» d (F.obj c)), Î£c', Â«expr â‰… Â» (F.obj c') d) : compatible_preserving K F :=\n  by\n  constructor\n  introv hx he\n  obtain âŸ¨X', eâŸ© := hF fâ‚\n  apply (â„±.1.map_iso e.op).to_equiv.injective\n  simp only [iso.op_hom, iso.to_equiv_fun, â„±.1.map_iso_hom, â† functor_to_types.map_comp_apply]\n  simpa using\n    hx (F.preimage <| Â«expr â‰« Â» e.hom fâ‚) (F.preimage <| Â«expr â‰« Â» e.hom fâ‚‚) hgâ‚ hgâ‚‚\n      (F.map_injective <| by simpa using he)\n#align compatible_preserving_of_downwards_closed compatible_preserving_of_downwards_closed\n\n",
 "comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‹™ Â» -/\n/-- The composition of two cover-preserving functors is cover-preserving. -/\ntheorem cover_preserving.comp {F} (hF : cover_preserving J K F) {G} (hG : cover_preserving K L G) :\n    cover_preserving J L (Â«expr â‹™ Â» F G) :=\n  âŸ¨fun U S hS => by\n    rw [sieve.functor_pushforward_comp]\n    exact hG.cover_preserve (hF.cover_preserve hS)âŸ©\n#align cover_preserving.comp cover_preserving.comp\n\n",
 "apply_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n@[simp]\ntheorem compatible_preserving.apply_map {Y : C} {f : Â«expr âŸ¶ Â» Y Z} (hf : T f) :\n    x.functor_pushforward G (G.map f) (image_mem_functor_pushforward G T hf) = x f hf :=\n  by\n  unfold family_of_elements.functor_pushforward\n  rcases eâ‚ : get_functor_pushforward_structure (image_mem_functor_pushforward G T hf) with âŸ¨X, g, f', hg, eqâŸ©\n  simpa using hG.compatible â„± h f' ((Â«exprğŸ™Â») _) hg hf (by simp [eq])\n#align compatible_preserving.apply_map compatible_preserving.apply_map\n\n"}