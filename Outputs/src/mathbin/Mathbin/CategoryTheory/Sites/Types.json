{"yoneda'_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n@[simp]\ntheorem yoneda'_comp : «expr ⋙ » yoneda'.{u} (SheafOfTypes_to_presheaf _) = yoneda :=\n  rfl\n#align yoneda'_comp yoneda'_comp\n\n",
 "types_grothendieck_topology_eq_canonical":
 "theorem types_grothendieck_topology_eq_canonical :\n    types_grothendieck_topology.{u} = sheaf.canonical_topology (Type u) :=\n  le_antisymm subcanonical_types_grothendieck_topology <|\n    infₛ_le\n      ⟨yoneda.obj (ULift bool), ⟨_, rfl⟩,\n        grothendieck_topology.ext <|\n          funext fun α =>\n            Set.ext fun S =>\n              ⟨fun hs x =>\n                by_contradiction fun hsx =>\n                  have :\n                    (fun _ => ulift.up true : (yoneda.obj (ULift bool)).obj (op PUnit)) = fun _ => ulift.up false :=\n                    (hs PUnit fun _ => x).is_separated_for.ext fun β f hf =>\n                      funext fun y => hsx.elim <| S.2 hf fun _ => y\n                  bool.no_confusion <| ulift.up.inj <| (congr_fun this PUnit.unit : _),\n                fun hs β f => is_sheaf_yoneda' _ fun y => hs _⟩⟩\n#align types_grothendieck_topology_eq_canonical types_grothendieck_topology_eq_canonical\n\n",
 "types_glue_eval":
 "theorem types_glue_eval {S hs α} (s) : types_glue.{u} S hs α (eval S α s) = s :=\n  (hs.is_sheaf_for _ _ (generate_discrete_presieve_mem α)).is_separated_for.ext fun β f hf =>\n    (is_sheaf_for.valid_glue _ _ _ hf).trans <|\n      (functor_to_types.map_comp_apply _ _ _ _).symm.trans <|\n        by\n        rw [← op_comp]\n        congr 2\n        exact funext fun x => congr_arg f (Classical.choose_spec hf x).symm\n#align types_glue_eval types_glue_eval\n\n",
 "subcanonical_types_grothendieck_topology":
 "-- α ≅ punit ⟶ α\ntheorem subcanonical_types_grothendieck_topology : sheaf.subcanonical types_grothendieck_topology.{u} :=\n  sheaf.subcanonical.of_yoneda_is_sheaf _ fun X => is_sheaf_yoneda'\n#align subcanonical_types_grothendieck_topology subcanonical_types_grothendieck_topology\n\n",
 "is_sheaf_yoneda'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\ntheorem is_sheaf_yoneda' {α : Type u} : is_sheaf types_grothendieck_topology (yoneda.obj α) := fun β S hs x hx =>\n  ⟨fun y => x _ (hs y) PUnit.unit, fun γ f h =>\n    funext fun z => by\n      have := congr_fun (hx ((«expr𝟙») _) (fun _ => z) (hs <| f z) h rfl) PUnit.unit\n      convert this\n      exact rfl,\n    fun f hf => funext fun y => by convert congr_fun (hf _ (hs y)) PUnit.unit⟩\n#align is_sheaf_yoneda' is_sheaf_yoneda'\n\n",
 "generate_discrete_presieve_mem":
 "theorem generate_discrete_presieve_mem (α : Type u) :\n    sieve.generate (discrete_presieve α) ∈ types_grothendieck_topology α := fun x =>\n  ⟨PUnit, id, fun _ => x, ⟨PUnit.unit, fun _ => subsingleton.elim _ _⟩, rfl⟩\n#align generate_discrete_presieve_mem generate_discrete_presieve_mem\n\n",
 "eval_types_glue":
 "theorem eval_types_glue {S hs α} (f) : eval.{u} S α (types_glue S hs α f) = f :=\n  funext fun x =>\n    (is_sheaf_for.valid_glue _ _ _ <| ⟨PUnit.unit, fun _ => subsingleton.elim _ _⟩).trans <|\n      by\n      convert functor_to_types.map_id_apply _ _\n      rw [← op_id]\n      congr\n#align eval_types_glue eval_types_glue\n\n",
 "eval_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵖ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem eval_map (S : «expr ⥤ » («expr ᵒᵖ» (Type u)) (Type u)) (α β) (f : «expr ⟶ » β α) (s x) :\n    eval S β (S.map f.op s) x = eval S α s (f x) :=\n  by\n  simp_rw [eval, ← functor_to_types.map_comp_apply, ← op_comp]\n  rfl\n#align eval_map eval_map\n\n",
 "eval_app":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `category_theory.as_hom -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem eval_app (S₁ S₂ : SheafOfTypes.{u} types_grothendieck_topology) (f : «expr ⟶ » S₁ S₂) (α : Type u)\n    (s : S₁.1.obj (op α)) (x : α) : eval S₂.1 α (f.val.app (op α) s) x = f.val.app (op PUnit) (eval S₁.1 α s x) :=\n  (congr_fun (f.val.naturality (category_theory.as_hom fun _ : PUnit => x).op) s).symm\n#align eval_app eval_app\n\n",
 "discrete_sieve_mem":
 "/-\nCopyright (c) 2020 Kenny Lau. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Kenny Lau\n-/\ntheorem discrete_sieve_mem (α : Type u) : discrete_sieve α ∈ types_grothendieck_topology α := fun x => ⟨x, fun y => rfl⟩\n#align discrete_sieve_mem discrete_sieve_mem\n\n"}