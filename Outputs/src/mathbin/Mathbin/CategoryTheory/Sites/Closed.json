{"topology_of_closure_operator_self":
 "/-- The topology given by the closure operator `J.close` on a Grothendieck topology is the same as `J`.\n-/\ntheorem topology_of_closure_operator_self :\n    (topology_of_closure_operator J₁.closure_operator fun X Y => J₁.pullback_close) = J₁ :=\n  by\n  ext (X S)\n  apply grothendieck_topology.close_eq_top_iff_mem\n#align topology_of_closure_operator_self topology_of_closure_operator_self\n\n",
 "topology_of_closure_operator_close":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem topology_of_closure_operator_close (c : ∀ X : C, ClosureOperator (sieve X))\n    (pb : ∀ ⦃X Y : C⦄ (f : «expr ⟶ » Y X) (S : sieve X), c Y (S.pullback f) = (c X S).pullback f) (X : C)\n    (S : sieve X) : (topology_of_closure_operator c pb).close S = c X S :=\n  by\n  ext\n  change c _ (sieve.pullback f S) = «expr⊤» ↔ c _ S f\n  rw [pb, sieve.pullback_eq_top_iff_mem]\n#align topology_of_closure_operator_close topology_of_closure_operator_close\n\n",
 "topology_eq_iff_same_sheaves":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵖ» -/\n/-- If being a sheaf for `J₁` is equivalent to being a sheaf for `J₂`, then `J₁ = J₂`. -/\ntheorem topology_eq_iff_same_sheaves {J₁ J₂ : grothendieck_topology C} :\n    J₁ = J₂ ↔ ∀ P : «expr ⥤ » («expr ᵒᵖ» C) (Type max v u), presieve.is_sheaf J₁ P ↔ presieve.is_sheaf J₂ P :=\n  by\n  constructor\n  · rintro rfl\n    intro P\n    rfl\n  · intro h\n    apply le_antisymm\n    · apply le_topology_of_closed_sieves_is_sheaf\n      rw [h]\n      apply classifier_is_sheaf\n    · apply le_topology_of_closed_sieves_is_sheaf\n      rw [← h]\n      apply classifier_is_sheaf\n#align topology_eq_iff_same_sheaves topology_eq_iff_same_sheaves\n\n",
 "pullback_close":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/-- Closing under `J` is stable under pullback. -/\ntheorem pullback_close {X Y : C} (f : «expr ⟶ » Y X) (S : sieve X) :\n    J₁.close (S.pullback f) = (J₁.close S).pullback f :=\n  by\n  apply le_antisymm\n  · refine' J₁.le_close_of_is_closed (sieve.pullback_monotone _ (J₁.le_close S)) _\n    apply J₁.is_closed_pullback _ _ (J₁.close_is_closed _)\n  · intro Z g hg\n    change _ ∈ J₁ _\n    rw [← sieve.pullback_comp]\n    apply hg\n#align pullback_close pullback_close\n\n",
 "monotone_close":
 "@[mono]\ntheorem monotone_close {X : C} : monotone (J₁.close : sieve X → sieve X) := fun S₁ S₂ h =>\n  J₁.le_close_of_is_closed (h.trans (J₁.le_close _)) (J₁.close_is_closed S₂)\n#align monotone_close monotone_close\n\n",
 "le_topology_of_closed_sieves_is_sheaf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/-- If presheaf of `J₁`-closed sieves is a `J₂`-sheaf then `J₁ ≤ J₂`. Note the converse is true by\n`classifier_is_sheaf` and `is_sheaf_of_le`.\n-/\ntheorem le_topology_of_closed_sieves_is_sheaf {J₁ J₂ : grothendieck_topology C}\n    (h : presieve.is_sheaf J₁ (functor.closed_sieves J₂)) : J₁ ≤ J₂ := fun X S hS =>\n  by\n  rw [← J₂.close_eq_top_iff_mem]\n  have : J₂.is_closed («expr⊤» : sieve X) := by\n    intro Y f hf\n    trivial\n  suffices (⟨J₂.close S, J₂.close_is_closed S⟩ : subtype _) = ⟨«expr⊤», this⟩\n    by\n    rw [subtype.ext_iff] at this\n    exact this\n  apply (h S hS).is_separated_for.ext\n  · intro Y f hf\n    ext1\n    dsimp\n    rw [sieve.pullback_top, ← J₂.pullback_close, S.pullback_eq_top_of_mem hf, J₂.close_eq_top_iff_mem]\n    apply J₂.top_mem\n#align le_topology_of_closed_sieves_is_sheaf le_topology_of_closed_sieves_is_sheaf\n\n",
 "le_close_of_is_closed":
 "/-- The closure of a sieve `S` is the largest closed sieve which contains `S` (justifying the name\n\"closure\").\n-/\ntheorem le_close_of_is_closed {X : C} {S T : sieve X} (h : S ≤ T) (hT : J₁.is_closed T) : J₁.close S ≤ T :=\n  fun Y f hf => hT _ (J₁.superset_covering (sieve.pullback_monotone f h) hf)\n#align le_close_of_is_closed le_close_of_is_closed\n\n",
 "le_close":
 "/-\nCopyright (c) 2020 Bhavik Mehta. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Bhavik Mehta\n-/\n/-- Any sieve is smaller than its closure. -/\ntheorem le_close {X : C} (S : sieve X) : S ≤ J₁.close S := fun Y g hg =>\n  J₁.covering_of_eq_top (S.pullback_eq_top_of_mem hg)\n#align le_close le_close\n\n",
 "is_closed_pullback":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/-- Being `J`-closed is stable under pullback. -/\ntheorem is_closed_pullback {X Y : C} (f : «expr ⟶ » Y X) (S : sieve X) : J₁.is_closed S → J₁.is_closed (S.pullback f) :=\n  fun hS Z g hg => hS («expr ≫ » g f) (by rwa [J₁.covers_iff, sieve.pullback_comp])\n#align is_closed_pullback is_closed_pullback\n\n",
 "is_closed_iff_close_eq_self":
 "/-- The sieve `S` is closed iff its closure is equal to itself. -/\ntheorem is_closed_iff_close_eq_self {X : C} (S : sieve X) : J₁.is_closed S ↔ J₁.close S = S :=\n  by\n  constructor\n  · intro h\n    apply le_antisymm\n    · intro Y f hf\n      rw [← J₁.covers_iff_mem_of_closed h]\n      apply hf\n    · apply J₁.le_close\n  · intro e\n    rw [← e]\n    apply J₁.close_is_closed\n#align is_closed_iff_close_eq_self is_closed_iff_close_eq_self\n\n",
 "covers_iff_mem_of_closed":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/-- If `S` is `J₁`-closed, then `S` covers exactly the arrows it contains. -/\ntheorem covers_iff_mem_of_closed {X : C} {S : sieve X} (h : J₁.is_closed S) {Y : C} (f : «expr ⟶ » Y X) :\n    J₁.covers S f ↔ S f :=\n  ⟨h _, J₁.arrow_max _ _⟩\n#align covers_iff_mem_of_closed covers_iff_mem_of_closed\n\n",
 "closed_iff_closed":
 "@[simp]\ntheorem closed_iff_closed {X : C} (S : sieve X) : S ∈ (J₁.closure_operator X).closed ↔ J₁.is_closed S :=\n  (J₁.is_closed_iff_close_eq_self S).symm\n#align closed_iff_closed closed_iff_closed\n\n",
 "close_is_closed":
 "/-- The closure of a sieve is closed. -/\ntheorem close_is_closed {X : C} (S : sieve X) : J₁.is_closed (J₁.close S) := fun Y g hg =>\n  J₁.arrow_trans g _ S hg fun Z h hS => hS\n#align close_is_closed close_is_closed\n\n",
 "close_eq_top_iff_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/-- The sieve `S` is in the topology iff its closure is the maximal sieve. This shows that the closure\noperator determines the topology.\n-/\ntheorem close_eq_top_iff_mem {X : C} (S : sieve X) : J₁.close S = «expr⊤» ↔ S ∈ J₁ X :=\n  by\n  constructor\n  · intro h\n    apply J₁.transitive (J₁.top_mem X)\n    intro Y f hf\n    change J₁.close S f\n    rwa [h]\n  · intro hS\n    rw [eq_top_iff]\n    intro Y f hf\n    apply J₁.pullback_stable _ hS\n#align close_eq_top_iff_mem close_eq_top_iff_mem\n\n",
 "close_eq_self_of_is_closed":
 "theorem close_eq_self_of_is_closed {X : C} {S : sieve X} (hS : J₁.is_closed S) : J₁.close S = S :=\n  (J₁.is_closed_iff_close_eq_self S).1 hS\n#align close_eq_self_of_is_closed close_eq_self_of_is_closed\n\n",
 "close_close":
 "@[simp]\ntheorem close_close {X : C} (S : sieve X) : J₁.close (J₁.close S) = J₁.close S :=\n  le_antisymm (J₁.le_close_of_is_closed le_rfl (J₁.close_is_closed S)) (J₁.monotone_close (J₁.le_close _))\n#align close_close close_close\n\n",
 "classifier_is_sheaf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/-- The presheaf of `J`-closed sieves is a `J`-sheaf.\nThe proof of this is adapted from [MM92], Chatper III, Section 7, Lemma 1.\n-/\ntheorem classifier_is_sheaf : presieve.is_sheaf J₁ (functor.closed_sieves J₁) :=\n  by\n  intro X S hS\n  rw [← presieve.is_separated_for_and_exists_is_amalgamation_iff_sheaf_for]\n  refine' ⟨_, _⟩\n  · rintro x ⟨M, hM⟩ ⟨N, hN⟩ hM₂ hN₂\n    ext\n    dsimp only [subtype.coe_mk]\n    rw [← J₁.covers_iff_mem_of_closed hM, ← J₁.covers_iff_mem_of_closed hN]\n    have q : ∀ ⦃Z : C⦄ (g : «expr ⟶ » Z X) (hg : S g), M.pullback g = N.pullback g :=\n      by\n      intro Z g hg\n      apply congr_arg subtype.val ((hM₂ g hg).trans (hN₂ g hg).symm)\n    have MSNS : «expr ⊓ » M S = «expr ⊓ » N S := by\n      ext (Z g)\n      rw [sieve.inter_apply, sieve.inter_apply, and_comm' (N g), and_comm']\n      apply and_congr_right\n      intro hg\n      rw [sieve.pullback_eq_top_iff_mem, sieve.pullback_eq_top_iff_mem, q g hg]\n    constructor\n    · intro hf\n      rw [J₁.covers_iff]\n      apply J₁.superset_covering (sieve.pullback_monotone f inf_le_left)\n      rw [← MSNS]\n      apply J₁.arrow_intersect f M S hf (J₁.pullback_stable _ hS)\n    · intro hf\n      rw [J₁.covers_iff]\n      apply J₁.superset_covering (sieve.pullback_monotone f inf_le_left)\n      rw [MSNS]\n      apply J₁.arrow_intersect f N S hf (J₁.pullback_stable _ hS)\n  · intro x hx\n    rw [presieve.compatible_iff_sieve_compatible] at hx\n    let M := sieve.bind S fun Y f hf => (x f hf).1\n    have : ∀ ⦃Y⦄ (f : «expr ⟶ » Y X) (hf : S f), M.pullback f = (x f hf).1 :=\n      by\n      intro Y f hf\n      apply le_antisymm\n      · rintro Z u ⟨W, g, f', hf', hg : (x f' hf').1 _, c⟩\n        rw [sieve.pullback_eq_top_iff_mem, ←\n          show (x («expr ≫ » u f) _).1 = (x f hf).1.pullback u from congr_arg subtype.val (hx f u hf)]\n        simp_rw [← c]\n        rw [show (x («expr ≫ » g f') _).1 = _ from congr_arg subtype.val (hx f' g hf')]\n        apply sieve.pullback_eq_top_of_mem _ hg\n      · apply sieve.le_pullback_bind S fun Y f hf => (x f hf).1\n    refine' ⟨⟨_, J₁.close_is_closed M⟩, _⟩\n    · intro Y f hf\n      ext1\n      dsimp\n      rw [← J₁.pullback_close, this _ hf]\n      apply le_antisymm (J₁.le_close_of_is_closed le_rfl (x f hf).2) (J₁.le_close _)\n#align classifier_is_sheaf classifier_is_sheaf\n\n"}