{"w":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\ntheorem w : Â«expr â‰« Â» (fork_map P R) (first_map P R) = Â«expr â‰« Â» (fork_map P R) (second_map P R) :=\n  by\n  apply limit.hom_ext\n  rintro âŸ¨âŸ¨Y, f, hfâŸ©, âŸ¨Z, g, hgâŸ©âŸ©\n  simp only [first_map, second_map, fork_map]\n  simp only [limit.lift_Ï€, limit.lift_Ï€_assoc, assoc, fan.mk_Ï€_app, subtype.coe_mk, subtype.val_eq_coe]\n  rw [â† P.map_comp, â† op_comp, pullback.condition]\n  simp\n#align w w\n\n",
 "valid_glue":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n@[simp]\ntheorem is_sheaf_for.valid_glue (t : is_sheaf_for P R) {x : family_of_elements P R} (hx : x.compatible)\n    (f : Â«expr âŸ¶ Â» Y X) (Hf : R f) : P.map f.op (t.amalgamate x hx) = x f Hf :=\n  t.is_amalgamation hx f Hf\n#align is_sheaf_for.valid_glue is_sheaf_for.valid_glue\n\n",
 "unique_extend":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr áµ’áµ–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/-- The extension of `f` to `yoneda.obj X` is unique. -/\ntheorem is_sheaf_for.unique_extend {P : Â«expr â¥¤ Â» (Â«expr áµ’áµ–Â» C) (Type vâ‚)} (h : is_sheaf_for P S)\n    {f : Â«expr âŸ¶ Â» S.functor P} (t : Â«expr âŸ¶ Â» (yoneda.obj X) P) (ht : Â«expr â‰« Â» S.functor_inclusion t = f) :\n    t = h.extend f :=\n  (is_sheaf_for_iff_yoneda_sheaf_condition.1 h f).unique ht (h.functor_inclusion_comp_extend f)\n#align is_sheaf_for.unique_extend is_sheaf_for.unique_extend\n\n",
 "to_sieve_compatible":
 "theorem family_of_elements.compatible.to_sieve_compatible {x : family_of_elements P S} (t : x.compatible) :\n    x.sieve_compatible :=\n  (compatible_iff_sieve_compatible x).1 t\n#align family_of_elements.compatible.to_sieve_compatible family_of_elements.compatible.to_sieve_compatible\n\n",
 "sieve_extend":
 "/-- The extension of a compatible family to the generated sieve is compatible. -/\ntheorem family_of_elements.compatible.sieve_extend {x : family_of_elements P R} (hx : x.compatible) :\n    x.sieve_extend.compatible := by\n  intro _ _ _ _ _ _ _ hâ‚ hâ‚‚ comm\n  iterate 2 erw [â† functor_to_types.map_comp_apply]; rw [â† op_comp]; apply hx\n  simp [comm, hâ‚.some_spec.some_spec.some_spec.2, hâ‚‚.some_spec.some_spec.some_spec.2]\n#align family_of_elements.compatible.sieve_extend family_of_elements.compatible.sieve_extend\n\n",
 "sheaf_condition":
 "/-- `P` is a sheaf for `R`, iff the fork given by `w` is an equalizer.\nSee <https://stacks.math.columbia.edu/tag/00VM>.\n-/\ntheorem sheaf_condition : R.is_sheaf_for P â†” nonempty (is_limit (fork.of_Î¹ _ (w P R))) :=\n  by\n  rw [types.type_equalizer_iff_unique]\n  erw [â† equiv.forall_congr_left (first_obj_eq_family P R).to_equiv.symm]\n  simp_rw [â† compatible_iff, â† iso.to_equiv_fun, equiv.apply_symm_apply]\n  apply ball_congr\n  intro x hx\n  apply exists_unique_congr\n  intro t\n  rw [equiv.eq_symm_apply]\n  constructor\n  Â· intro q\n    ext (Y f hf)\n    simpa [fork_map] using q _ _\n  Â· intro q Y f hf\n    rw [â† q]\n    simp [fork_map]\n#align sheaf_condition sheaf_condition\n\n",
 "restrict_inj":
 "/-- Two compatible families on the sieve generated by a presieve `R` are equal if and only if they are\nequal when restricted to `R`.\n-/\ntheorem restrict_inj {xâ‚ xâ‚‚ : family_of_elements P (generate R)} (tâ‚ : xâ‚.compatible) (tâ‚‚ : xâ‚‚.compatible) :\n    xâ‚.restrict (le_generate R) = xâ‚‚.restrict (le_generate R) â†’ xâ‚ = xâ‚‚ := fun h =>\n  by\n  rw [â† extend_restrict tâ‚, â† extend_restrict tâ‚‚]\n  congr\n  exact h\n#align restrict_inj restrict_inj\n\n",
 "restrict_extend":
 "/-- The restriction of an extension is the original. -/\n@[simp]\ntheorem restrict_extend {x : family_of_elements P R} (t : x.compatible) : x.sieve_extend.restrict (le_generate R) = x :=\n  by\n  ext (Y f hf)\n  exact extend_agrees t hf\n#align restrict_extend restrict_extend\n\n",
 "restrict":
 "/-- The restriction of a compatible family is compatible. -/\ntheorem family_of_elements.compatible.restrict {Râ‚ Râ‚‚ : presieve X} (h : Râ‚ â‰¤ Râ‚‚) {x : family_of_elements P Râ‚‚} :\n    x.compatible â†’ (x.restrict h).compatible := fun q Yâ‚ Yâ‚‚ Z gâ‚ gâ‚‚ fâ‚ fâ‚‚ hâ‚ hâ‚‚ comm => q gâ‚ gâ‚‚ (h _ hâ‚) (h _ hâ‚‚) comm\n#align family_of_elements.compatible.restrict family_of_elements.compatible.restrict\n\n",
 "pullback_compatible_iff":
 "/-\nCopyright (c) 2020 Bhavik Mehta. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Bhavik Mehta\n-/\ntheorem pullback_compatible_iff (x : family_of_elements P R) [has_pullbacks C] : x.compatible â†” x.pullback_compatible :=\n  by\n  constructor\n  Â· intro t Yâ‚ Yâ‚‚ fâ‚ fâ‚‚ hfâ‚ hfâ‚‚\n    apply t\n    apply pullback.condition\n  Â· intro t Yâ‚ Yâ‚‚ Z gâ‚ gâ‚‚ fâ‚ fâ‚‚ hfâ‚ hfâ‚‚ comm\n    rw [â† pullback.lift_fst _ _ comm, op_comp, functor_to_types.map_comp_apply, t hfâ‚ hfâ‚‚, â†\n      functor_to_types.map_comp_apply, â† op_comp, pullback.lift_snd]\n#align pullback_compatible_iff pullback_compatible_iff\n\n",
 "pullback":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem family_of_elements.compatible.pullback (f : Â«expr âŸ¶ Â» Y X) {x : family_of_elements P S} (h : x.compatible) :\n    (x.pullback f).compatible := by\n  simp only [compatible_iff_sieve_compatible] at hâŠ¢\n  intro W Z fâ‚ fâ‚‚ hf\n  unfold family_of_elements.pullback\n  rw [â† h (Â«expr â‰« Â» fâ‚ f) fâ‚‚ hf]\n  simp only [assoc]\n#align family_of_elements.compatible.pullback family_of_elements.compatible.pullback\n\n",
 "is_sheaf_pretopology":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‡‘ Â» -/\n/-- For a topology generated by a basis, it suffices to check the sheaf condition on the basis\npresieves only.\n-/\ntheorem is_sheaf_pretopology [has_pullbacks C] (K : pretopology C) :\n    is_sheaf (K.to_grothendieck C) P â†” âˆ€ {X : C} (R : presieve X), R âˆˆ K X â†’ is_sheaf_for P R :=\n  by\n  constructor\n  Â· intro PJ X R hR\n    rw [is_sheaf_for_iff_generate]\n    apply PJ (sieve.generate R) âŸ¨_, hR, le_generate RâŸ©\n  Â· rintro PK X S âŸ¨R, hR, RSâŸ©\n    have gRS : Â«exprâ‡‘ Â» (generate R) â‰¤ S := by\n      apply gi_generate.gc.monotone_u\n      rwa [sets_iff_generate]\n    apply is_sheaf_for_subsieve P gRS _\n    intro Y f\n    rw [â† pullback_arrows_comm, â† is_sheaf_for_iff_generate]\n    exact PK (pullback_arrows f R) (K.pullbacks f R hR)\n#align is_sheaf_pretopology is_sheaf_pretopology\n\n",
 "is_sheaf_of_yoneda":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr áµ’áµ–Â» -/\ntheorem is_sheaf_of_yoneda {P : Â«expr â¥¤ Â» (Â«expr áµ’áµ–Â» C) (Type vâ‚)}\n    (h : âˆ€ {X} (S : sieve X), S âˆˆ J X â†’ yoneda_sheaf_condition P S) : is_sheaf J P := fun X S hS =>\n  is_sheaf_for_iff_yoneda_sheaf_condition.2 (h _ hS)\n#align is_sheaf_of_yoneda is_sheaf_of_yoneda\n\n",
 "is_sheaf_of_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr áµ’áµ–Â» -/\ntheorem is_sheaf_of_le (P : Â«expr â¥¤ Â» (Â«expr áµ’áµ–Â» C) (Type w)) {Jâ‚ Jâ‚‚ : grothendieck_topology C} :\n    Jâ‚ â‰¤ Jâ‚‚ â†’ is_sheaf Jâ‚‚ P â†’ is_sheaf Jâ‚ P := fun h t X S hS => t S (h _ hS)\n#align is_sheaf_of_le is_sheaf_of_le\n\n",
 "is_sheaf_iso":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr áµ’áµ–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰… Â» -/\n/-- The property of being a sheaf is preserved by isomorphism. -/\ntheorem is_sheaf_iso {P' : Â«expr â¥¤ Â» (Â«expr áµ’áµ–Â» C) (Type w)} (i : Â«expr â‰… Â» P P') (h : is_sheaf J P) : is_sheaf J P' :=\n  fun X S hS => is_sheaf_for_iso i (h S hS)\n#align is_sheaf_iso is_sheaf_iso\n\n",
 "is_sheaf_for_top_sieve":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr áµ’áµ–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\n/-- Every presheaf is a sheaf for the maximal sieve.\n\n[Elephant] C2.1.5(ii)\n-/\ntheorem is_sheaf_for_top_sieve (P : Â«expr â¥¤ Â» (Â«expr áµ’áµ–Â» C) (Type w)) :\n    is_sheaf_for P ((Â«exprâŠ¤Â» : sieve X) : presieve X) :=\n  by\n  rw [â† generate_of_singleton_is_split_epi ((Â«exprğŸ™Â») X)]\n  rw [â† is_sheaf_for_iff_generate]\n  apply is_sheaf_for_singleton_iso\n#align is_sheaf_for_top_sieve is_sheaf_for_top_sieve\n\n",
 "is_sheaf_for_subsieve_aux":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr áµ’áµ–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/-- If a presieve `R` on `X` has a subsieve `S` such that:\n\n* `P` is a sheaf for `S`.\n* For every `f` in `R`, `P` is separated for the pullback of `S` along `f`,\n\nthen `P` is a sheaf for `R`.\n\nThis is closely related to [Elephant] C2.1.6(i).\n-/\ntheorem is_sheaf_for_subsieve_aux (P : Â«expr â¥¤ Â» (Â«expr áµ’áµ–Â» C) (Type w)) {S : sieve X} {R : presieve X}\n    (h : (S : presieve X) â‰¤ R) (hS : is_sheaf_for P S)\n    (trans : âˆ€ â¦ƒYâ¦„ â¦ƒf : Â«expr âŸ¶ Â» Y Xâ¦„, R f â†’ is_separated_for P (S.pullback f)) : is_sheaf_for P R :=\n  by\n  rw [â† is_separated_for_and_exists_is_amalgamation_iff_sheaf_for]\n  constructor\n  Â· intro x tâ‚ tâ‚‚ htâ‚ htâ‚‚\n    exact hS.is_separated_for _ _ _ (is_amalgamation_restrict h x tâ‚ htâ‚) (is_amalgamation_restrict h x tâ‚‚ htâ‚‚)\n  Â· intro x hx\n    use hS.amalgamate _ (hx.restrict h)\n    intro W j hj\n    apply (trans hj).ext\n    intro Y f hf\n    rw [â† functor_to_types.map_comp_apply, â† op_comp, hS.valid_glue (hx.restrict h) _ hf, family_of_elements.restrict, â†\n      hx ((Â«exprğŸ™Â») _) f _ _ (id_comp _)]\n    simp\n#align is_sheaf_for_subsieve_aux is_sheaf_for_subsieve_aux\n\n",
 "is_sheaf_for_subsieve":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr áµ’áµ–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/-- If `P` is a sheaf for every pullback of the sieve `S`, then `P` is a sheaf for any presieve which\ncontains `S`.\nThis is closely related to [Elephant] C2.1.6.\n-/\ntheorem is_sheaf_for_subsieve (P : Â«expr â¥¤ Â» (Â«expr áµ’áµ–Â» C) (Type w)) {S : sieve X} {R : presieve X}\n    (h : (S : presieve X) â‰¤ R) (trans : âˆ€ â¦ƒYâ¦„ (f : Â«expr âŸ¶ Â» Y X), is_sheaf_for P (S.pullback f)) : is_sheaf_for P R :=\n  is_sheaf_for_subsieve_aux P h (by simpa using trans ((Â«exprğŸ™Â») _)) fun Y f hf => (trans f).is_separated_for\n#align is_sheaf_for_subsieve is_sheaf_for_subsieve\n\n",
 "is_sheaf_for_singleton_iso":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr áµ’áµ–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n/-- Every presheaf is a sheaf for the family {ğŸ™ X}.\n\n[Elephant] C2.1.5(i)\n-/\ntheorem is_sheaf_for_singleton_iso (P : Â«expr â¥¤ Â» (Â«expr áµ’áµ–Â» C) (Type w)) :\n    is_sheaf_for P (presieve.singleton ((Â«exprğŸ™Â») X)) :=\n  by\n  intro x hx\n  refine' âŸ¨x _ (presieve.singleton_self _), _, _âŸ©\n  Â· rintro _ _ âŸ¨rfl, rflâŸ©\n    simp\n  Â· intro t ht\n    simpa using ht _ (presieve.singleton_self _)\n#align is_sheaf_for_singleton_iso is_sheaf_for_singleton_iso\n\n",
 "is_sheaf_for_iso":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr áµ’áµ–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰… Â» -/\n/-- If `P` is a sheaf for `S`, and it is iso to `P'`, then `P'` is a sheaf for `S`. This shows that\n\"being a sheaf for a presieve\" is a mathematical or hygenic property.\n-/\ntheorem is_sheaf_for_iso {P' : Â«expr â¥¤ Â» (Â«expr áµ’áµ–Â» C) (Type w)} (i : Â«expr â‰… Â» P P') :\n    is_sheaf_for P R â†’ is_sheaf_for P' R := by\n  intro h x hx\n  let x' := x.comp_presheaf_map i.inv\n  have : x'.compatible := family_of_elements.compatible.comp_presheaf_map i.inv hx\n  obtain âŸ¨t, ht1, ht2âŸ© := h x' this\n  use i.hom.app _ t\n  fconstructor\n  Â· convert family_of_elements.is_amalgamation.comp_presheaf_map i.hom ht1\n    dsimp [x']\n    simp\n  Â· intro y hy\n    rw [show y = (Â«expr â‰« Â» (i.inv.app (op X)) (i.hom.app (op X))) y by simp]\n    simp [ht2 (i.inv.app _ y) (family_of_elements.is_amalgamation.comp_presheaf_map i.inv hy)]\n#align is_sheaf_for_iso is_sheaf_for_iso\n\n",
 "is_sheaf_for_iff_yoneda_sheaf_condition":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr áµ’áµ–Â» -/\n-- See note [dsimp, simp].\n/-- The yoneda version of the sheaf condition is equivalent to the sheaf condition.\n\nC2.1.4 of [Elephant].\n-/\ntheorem is_sheaf_for_iff_yoneda_sheaf_condition {P : Â«expr â¥¤ Â» (Â«expr áµ’áµ–Â» C) (Type vâ‚)} :\n    is_sheaf_for P S â†” yoneda_sheaf_condition P S :=\n  by\n  rw [is_sheaf_for, yoneda_sheaf_condition]\n  simp_rw [extension_iff_amalgamation]\n  rw [equiv.forall_congr_left' nat_trans_equiv_compatible_family]\n  rw [subtype.forall]\n  apply ball_congr\n  intro x hx\n  rw [equiv.exists_unique_congr_left _]\n  simp\n#align is_sheaf_for_iff_yoneda_sheaf_condition is_sheaf_for_iff_yoneda_sheaf_condition\n\n",
 "is_sheaf_for_iff_generate":
 "/-- C2.1.3 in [Elephant] -/\ntheorem is_sheaf_for_iff_generate (R : presieve X) : is_sheaf_for P R â†” is_sheaf_for P (generate R) :=\n  by\n  rw [â† is_separated_for_and_exists_is_amalgamation_iff_sheaf_for]\n  rw [â† is_separated_for_and_exists_is_amalgamation_iff_sheaf_for]\n  rw [â† is_separated_for_iff_generate]\n  apply and_congr (iff.refl _)\n  constructor\n  Â· intro q x hx\n    apply Exists.imp _ (q _ (hx.restrict (le_generate R)))\n    intro t ht\n    simpa [hx] using is_amalgamation_sieve_extend _ _ ht\n  Â· intro q x hx\n    apply Exists.imp _ (q _ hx.sieve_extend)\n    intro t ht\n    simpa [hx] using is_amalgamation_restrict (le_generate R) _ _ ht\n#align is_sheaf_for_iff_generate is_sheaf_for_iff_generate\n\n",
 "is_sheaf_for":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr áµ’áµ–Â» -/\ntheorem is_sheaf.is_sheaf_for {P : Â«expr â¥¤ Â» (Â«expr áµ’áµ–Â» C) (Type w)} (hp : is_sheaf J P) (R : presieve X)\n    (hr : generate R âˆˆ J X) : is_sheaf_for P R :=\n  (is_sheaf_for_iff_generate R).2 <| hp _ hr\n#align is_sheaf.is_sheaf_for is_sheaf.is_sheaf_for\n\n",
 "is_sheaf_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¥Â» -/\n/-- Any presheaf is a sheaf for the bottom (trivial) grothendieck topology. -/\ntheorem is_sheaf_bot : is_sheaf (Â«exprâŠ¥Â» : grothendieck_topology C) P := fun X => by simp [is_sheaf_for_top_sieve]\n#align is_sheaf_bot is_sheaf_bot\n\n",
 "is_separated_of_is_sheaf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr áµ’áµ–Â» -/\ntheorem is_separated_of_is_sheaf (P : Â«expr â¥¤ Â» (Â«expr áµ’áµ–Â» C) (Type w)) (h : is_sheaf J P) : is_separated J P :=\n  fun X S hS => (h S hS).is_separated_for\n#align is_separated_of_is_sheaf is_separated_of_is_sheaf\n\n",
 "is_separated_for_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr áµ’áµ–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\ntheorem is_separated_for_top (P : Â«expr â¥¤ Â» (Â«expr áµ’áµ–Â» C) (Type w)) : is_separated_for P (Â«exprâŠ¤Â» : presieve X) :=\n  fun x tâ‚ tâ‚‚ hâ‚ hâ‚‚ => by\n  have qâ‚ := hâ‚ ((Â«exprğŸ™Â») X) (by simp)\n  have qâ‚‚ := hâ‚‚ ((Â«exprğŸ™Â») X) (by simp)\n  simp only [op_id, functor_to_types.map_id_apply] at qâ‚ qâ‚‚\n  rw [qâ‚, qâ‚‚]\n#align is_separated_for_top is_separated_for_top\n\n",
 "is_separated_for_iff_generate":
 "theorem is_separated_for_iff_generate : is_separated_for P R â†” is_separated_for P (generate R) :=\n  by\n  constructor\n  Â· intro h x tâ‚ tâ‚‚ htâ‚ htâ‚‚\n    apply h (x.restrict (le_generate R)) tâ‚ tâ‚‚ _ _\n    Â· exact is_amalgamation_restrict _ x tâ‚ htâ‚\n    Â· exact is_amalgamation_restrict _ x tâ‚‚ htâ‚‚\n  Â· intro h x tâ‚ tâ‚‚ htâ‚ htâ‚‚\n    apply h x.sieve_extend\n    Â· exact is_amalgamation_sieve_extend x tâ‚ htâ‚\n    Â· exact is_amalgamation_sieve_extend x tâ‚‚ htâ‚‚\n#align is_separated_for_iff_generate is_separated_for_iff_generate\n\n",
 "is_separated_for_and_exists_is_amalgamation_iff_sheaf_for":
 "/-- `P` is a sheaf for `R` iff it is separated for `R` and there exists an amalgamation. -/\ntheorem is_separated_for_and_exists_is_amalgamation_iff_sheaf_for :\n    (is_separated_for P R âˆ§ âˆ€ x : family_of_elements P R, x.compatible â†’ âˆƒ t, x.is_amalgamation t) â†” is_sheaf_for P R :=\n  by\n  rw [is_separated_for, â† forall_and]\n  apply forall_congr'\n  intro x\n  constructor\n  Â· intro z hx\n    exact exists_unique_of_exists_of_unique (z.2 hx) z.1\n  Â· intro h\n    refine' âŸ¨_, ExistsUnique.exists âˆ˜ hâŸ©\n    intro tâ‚ tâ‚‚ htâ‚ htâ‚‚\n    apply (h _).unique htâ‚ htâ‚‚\n    exact is_compatible_of_exists_amalgamation x âŸ¨_, htâ‚‚âŸ©\n#align\n  is_separated_for_and_exists_is_amalgamation_iff_sheaf_for is_separated_for_and_exists_is_amalgamation_iff_sheaf_for\n\n",
 "is_separated_for":
 "/-- If `P` is a sheaf for `R`, it is separated for `R`. -/\ntheorem is_sheaf_for.is_separated_for : is_sheaf_for P R â†’ is_separated_for P R := fun q =>\n  (is_separated_for_and_exists_is_amalgamation_iff_sheaf_for.2 q).1\n#align is_sheaf_for.is_separated_for is_sheaf_for.is_separated_for\n\n",
 "is_compatible_of_exists_amalgamation":
 "theorem is_compatible_of_exists_amalgamation (x : family_of_elements P R) (h : âˆƒ t, x.is_amalgamation t) :\n    x.compatible := by\n  cases' h with t ht\n  intro Yâ‚ Yâ‚‚ Z gâ‚ gâ‚‚ fâ‚ fâ‚‚ hâ‚ hâ‚‚ comm\n  rw [â† ht _ hâ‚, â† ht _ hâ‚‚, â† functor_to_types.map_comp_apply, â† op_comp, comm]\n  simp\n#align is_compatible_of_exists_amalgamation is_compatible_of_exists_amalgamation\n\n",
 "is_amalgamation_sieve_extend":
 "theorem is_amalgamation_sieve_extend {R : presieve X} (x : family_of_elements P R) (t : P.obj (op X))\n    (ht : x.is_amalgamation t) : x.sieve_extend.is_amalgamation t :=\n  by\n  intro Y f hf\n  dsimp [family_of_elements.sieve_extend]\n  rw [â† ht _, â† functor_to_types.map_comp_apply, â† op_comp, hf.some_spec.some_spec.some_spec.2]\n#align is_amalgamation_sieve_extend is_amalgamation_sieve_extend\n\n",
 "is_amalgamation_restrict":
 "theorem is_amalgamation_restrict {Râ‚ Râ‚‚ : presieve X} (h : Râ‚ â‰¤ Râ‚‚) (x : family_of_elements P Râ‚‚) (t : P.obj (op X))\n    (ht : x.is_amalgamation t) : (x.restrict h).is_amalgamation t := fun Y f hf => ht f (h Y hf)\n#align is_amalgamation_restrict is_amalgamation_restrict\n\n",
 "is_amalgamation":
 "theorem is_sheaf_for.is_amalgamation (t : is_sheaf_for P R) {x : family_of_elements P R} (hx : x.compatible) :\n    x.is_amalgamation (t.amalgamate x hx) :=\n  (t x hx).exists.some_spec\n#align is_sheaf_for.is_amalgamation is_sheaf_for.is_amalgamation\n\n",
 "hom_ext":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr áµ’áµ–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/-- If `P` is a sheaf for the sieve `S` on `X`, then if two natural transformations from `yoneda.obj X`\nto `P` agree when restricted to the subfunctor given by `S`, they are equal.\n-/\ntheorem is_sheaf_for.hom_ext {P : Â«expr â¥¤ Â» (Â«expr áµ’áµ–Â» C) (Type vâ‚)} (h : is_sheaf_for P S)\n    (tâ‚ tâ‚‚ : Â«expr âŸ¶ Â» (yoneda.obj X) P) (ht : Â«expr â‰« Â» S.functor_inclusion tâ‚ = Â«expr â‰« Â» S.functor_inclusion tâ‚‚) :\n    tâ‚ = tâ‚‚ :=\n  (h.unique_extend tâ‚ ht).trans (h.unique_extend tâ‚‚ rfl).symm\n#align is_sheaf_for.hom_ext is_sheaf_for.hom_ext\n\n",
 "functor_pullback":
 "theorem family_of_elements.compatible.functor_pullback (h : x.compatible) : (x.functor_pullback F).compatible :=\n  by\n  intro Zâ‚ Zâ‚‚ W gâ‚ gâ‚‚ fâ‚ fâ‚‚ hâ‚ hâ‚‚ eq\n  exact h (F.map gâ‚) (F.map gâ‚‚) hâ‚ hâ‚‚ (by simp only [â† F.map_comp, eq])\n#align family_of_elements.compatible.functor_pullback family_of_elements.compatible.functor_pullback\n\n",
 "functor_inclusion_comp_extend":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr áµ’áµ–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/-- Show that the extension of `f : S.functor âŸ¶ P` to all of `yoneda.obj X` is in fact an extension, ie\nthat the triangle below commutes, provided `P` is a sheaf for `S`\n\n      f\n   S  â†’  P\n   â†“  â†—\n   yX\n\n-/\n@[simp, reassoc.1]\ntheorem is_sheaf_for.functor_inclusion_comp_extend {P : Â«expr â¥¤ Â» (Â«expr áµ’áµ–Â» C) (Type vâ‚)} (h : is_sheaf_for P S)\n    (f : Â«expr âŸ¶ Â» S.functor P) : Â«expr â‰« Â» S.functor_inclusion (h.extend f) = f :=\n  (is_sheaf_for_iff_yoneda_sheaf_condition.1 h f).exists.some_spec\n#align is_sheaf_for.functor_inclusion_comp_extend is_sheaf_for.functor_inclusion_comp_extend\n\n",
 "extension_iff_amalgamation":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr áµ’áµ–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n-- TODO: We can generalize the universe parameter vâ‚ above by composing with\n-- appropriate `ulift_functor`s.\n/-- (Implementation). A lemma useful to prove `yoneda_condition_iff_sheaf_condition`. -/\ntheorem extension_iff_amalgamation {P : Â«expr â¥¤ Â» (Â«expr áµ’áµ–Â» C) (Type vâ‚)} (x : Â«expr âŸ¶ Â» S.functor P)\n    (g : Â«expr âŸ¶ Â» (yoneda.obj X) P) :\n    Â«expr â‰« Â» S.functor_inclusion g = x â†” (nat_trans_equiv_compatible_family x).1.is_amalgamation (yoneda_equiv g) :=\n  by\n  change _ â†” âˆ€ â¦ƒY : Câ¦„ (f : Â«expr âŸ¶ Â» Y X) (h : S f), P.map f.op (yoneda_equiv g) = x.app (op Y) âŸ¨f, hâŸ©\n  constructor\n  Â· rintro rfl Y f hf\n    rw [yoneda_equiv_naturality]\n    dsimp\n    simp\n  -- See note [dsimp, simp].\n  Â· intro h\n    ext (YâŸ¨f, hfâŸ©)\n    have : _ = x.app Y _ := h f hf\n    rw [yoneda_equiv_naturality] at this\n    rw [â† this]\n    dsimp\n    simp\n#align extension_iff_amalgamation extension_iff_amalgamation\n\n",
 "extend_restrict":
 "/-- Given a family of elements `x` for the sieve `S` generated by a presieve `R`, if `x` is restricted\nto `R` and then extended back up to `S`, the resulting extension equals `x`.\n-/\n@[simp]\ntheorem extend_restrict {x : family_of_elements P (generate R)} (t : x.compatible) :\n    (x.restrict (le_generate R)).sieve_extend = x :=\n  by\n  rw [compatible_iff_sieve_compatible] at t\n  ext (_ _ h); apply (t _ _ _).symm.trans; congr\n  exact h.some_spec.some_spec.some_spec.2\n#align extend_restrict extend_restrict\n\n",
 "extend_agrees":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/-- The extension of a family agrees with the original family. -/\ntheorem extend_agrees {x : family_of_elements P R} (t : x.compatible) {f : Â«expr âŸ¶ Â» Y X} (hf : R f) :\n    x.sieve_extend f (le_generate R Y hf) = x f hf :=\n  by\n  have h := (le_generate R Y hf).some_spec\n  unfold family_of_elements.sieve_extend\n  rw [t h.some ((Â«exprğŸ™Â») _) _ hf _]\n  Â· simp;\n  Â· rw [id_comp]\n    exact h.some_spec.some_spec.2\n#align extend_agrees extend_agrees\n\n",
 "ext":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem is_separated_for.ext {R : presieve X} (hR : is_separated_for P R) {tâ‚ tâ‚‚ : P.obj (op X)}\n    (h : âˆ€ â¦ƒYâ¦„ â¦ƒf : Â«expr âŸ¶ Â» Y Xâ¦„ (hf : R f), P.map f.op tâ‚ = P.map f.op tâ‚‚) : tâ‚ = tâ‚‚ :=\n  hR (fun Y f hf => P.map f.op tâ‚‚) tâ‚ tâ‚‚ (fun Y f hf => h hf) fun Y f hf => rfl\n#align is_separated_for.ext is_separated_for.ext\n\n",
 "equalizer_sheaf_condition":
 "/-- `P` is a sheaf for `S`, iff the fork given by `w` is an equalizer. -/\ntheorem equalizer_sheaf_condition : presieve.is_sheaf_for P S â†” nonempty (is_limit (fork.of_Î¹ _ (w P S))) :=\n  by\n  rw [types.type_equalizer_iff_unique, â† equiv.forall_congr_left (first_obj_eq_family P S).to_equiv.symm]\n  simp_rw [â† compatible_iff]\n  simp only [inv_hom_id_apply, iso.to_equiv_symm_fun]\n  apply ball_congr\n  intro x tx\n  apply exists_unique_congr\n  intro t\n  rw [â† iso.to_equiv_symm_fun]\n  rw [equiv.eq_symm_apply]\n  constructor\n  Â· intro q\n    ext (Y f hf)\n    simpa [first_obj_eq_family, fork_map] using q _ _\n  Â· intro q Y f hf\n    rw [â† q]\n    simp [first_obj_eq_family, fork_map]\n#align equalizer_sheaf_condition equalizer_sheaf_condition\n\n",
 "compatible_iff_sieve_compatible":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\ntheorem compatible_iff_sieve_compatible (x : family_of_elements P S) : x.compatible â†” x.sieve_compatible :=\n  by\n  constructor\n  Â· intro h Y Z f g hf\n    simpa using h ((Â«exprğŸ™Â») _) g (S.downward_closed hf g) hf (id_comp _)\n  Â· intro h Yâ‚ Yâ‚‚ Z gâ‚ gâ‚‚ fâ‚ fâ‚‚ hâ‚ hâ‚‚ k\n    simp_rw [â† h fâ‚ gâ‚ hâ‚, k, h fâ‚‚ gâ‚‚ hâ‚‚]\n#align compatible_iff_sieve_compatible compatible_iff_sieve_compatible\n\n",
 "compatible_iff":
 "/-- The family of elements given by `x : first_obj P S` is compatible iff `first_map` and `second_map`\nmap it to the same point.\n-/\ntheorem compatible_iff (x : first_obj P R) :\n    ((first_obj_eq_family P R).hom x).compatible â†” first_map P R x = second_map P R x :=\n  by\n  rw [presieve.pullback_compatible_iff]\n  constructor\n  Â· intro t\n    ext âŸ¨âŸ¨Y, f, hfâŸ©, Z, g, hgâŸ©\n    simpa [first_map, second_map] using t hf hg\n  Â· intro t Y Z f g hf hg\n    rw [types.limit_ext_iff'] at t\n    simpa [first_map, second_map] using t âŸ¨âŸ¨âŸ¨Y, f, hfâŸ©, Z, g, hgâŸ©âŸ©\n#align compatible_iff compatible_iff\n\n",
 "comp_presheaf_map_id":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n@[simp]\ntheorem family_of_elements.comp_presheaf_map_id (x : family_of_elements P R) : x.comp_presheaf_map ((Â«exprğŸ™Â») P) = x :=\n  rfl\n#align family_of_elements.comp_presheaf_map_id family_of_elements.comp_presheaf_map_id\n\n",
 "comp_presheaf_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem family_of_elements.is_amalgamation.comp_presheaf_map {x : family_of_elements P R} {t} (f : Â«expr âŸ¶ Â» P Q)\n    (h : x.is_amalgamation t) : (x.comp_presheaf_map f).is_amalgamation (f.app (op X) t) :=\n  by\n  intro Y g hg\n  dsimp [family_of_elements.comp_presheaf_map]\n  change (Â«expr â‰« Â» (f.app _) (Q.map _)) _ = _\n  simp [â† f.naturality, h g hg]\n#align family_of_elements.is_amalgamation.comp_presheaf_map family_of_elements.is_amalgamation.comp_presheaf_map\n\n",
 "comp_prersheaf_map_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n@[simp]\ntheorem family_of_elements.comp_prersheaf_map_comp (x : family_of_elements P R) (f : Â«expr âŸ¶ Â» P Q)\n    (g : Â«expr âŸ¶ Â» Q U) : (x.comp_presheaf_map f).comp_presheaf_map g = x.comp_presheaf_map (Â«expr â‰« Â» f g) :=\n  rfl\n#align family_of_elements.comp_prersheaf_map_comp family_of_elements.comp_prersheaf_map_comp\n\n",
 "comp_of_compatible":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\ntheorem family_of_elements.comp_of_compatible (S : sieve X) {x : family_of_elements P S} (t : x.compatible)\n    {f : Â«expr âŸ¶ Â» Y X} (hf : S f) {Z} (g : Â«expr âŸ¶ Â» Z Y) :\n    x (Â«expr â‰« Â» g f) (S.downward_closed hf g) = P.map g.op (x f hf) := by\n  simpa using t ((Â«exprğŸ™Â») _) g (S.downward_closed hf g) hf (id_comp _)\n#align family_of_elements.comp_of_compatible family_of_elements.comp_of_compatible\n\n"}