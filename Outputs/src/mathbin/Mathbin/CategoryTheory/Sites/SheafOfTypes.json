{"w":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem w : «expr ≫ » (fork_map P R) (first_map P R) = «expr ≫ » (fork_map P R) (second_map P R) :=\n  by\n  apply limit.hom_ext\n  rintro ⟨⟨Y, f, hf⟩, ⟨Z, g, hg⟩⟩\n  simp only [first_map, second_map, fork_map]\n  simp only [limit.lift_π, limit.lift_π_assoc, assoc, fan.mk_π_app, subtype.coe_mk, subtype.val_eq_coe]\n  rw [← P.map_comp, ← op_comp, pullback.condition]\n  simp\n#align w w\n\n",
 "valid_glue":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n@[simp]\ntheorem is_sheaf_for.valid_glue (t : is_sheaf_for P R) {x : family_of_elements P R} (hx : x.compatible)\n    (f : «expr ⟶ » Y X) (Hf : R f) : P.map f.op (t.amalgamate x hx) = x f Hf :=\n  t.is_amalgamation hx f Hf\n#align is_sheaf_for.valid_glue is_sheaf_for.valid_glue\n\n",
 "unique_extend":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵖ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/-- The extension of `f` to `yoneda.obj X` is unique. -/\ntheorem is_sheaf_for.unique_extend {P : «expr ⥤ » («expr ᵒᵖ» C) (Type v₁)} (h : is_sheaf_for P S)\n    {f : «expr ⟶ » S.functor P} (t : «expr ⟶ » (yoneda.obj X) P) (ht : «expr ≫ » S.functor_inclusion t = f) :\n    t = h.extend f :=\n  (is_sheaf_for_iff_yoneda_sheaf_condition.1 h f).unique ht (h.functor_inclusion_comp_extend f)\n#align is_sheaf_for.unique_extend is_sheaf_for.unique_extend\n\n",
 "to_sieve_compatible":
 "theorem family_of_elements.compatible.to_sieve_compatible {x : family_of_elements P S} (t : x.compatible) :\n    x.sieve_compatible :=\n  (compatible_iff_sieve_compatible x).1 t\n#align family_of_elements.compatible.to_sieve_compatible family_of_elements.compatible.to_sieve_compatible\n\n",
 "sieve_extend":
 "/-- The extension of a compatible family to the generated sieve is compatible. -/\ntheorem family_of_elements.compatible.sieve_extend {x : family_of_elements P R} (hx : x.compatible) :\n    x.sieve_extend.compatible := by\n  intro _ _ _ _ _ _ _ h₁ h₂ comm\n  iterate 2 erw [← functor_to_types.map_comp_apply]; rw [← op_comp]; apply hx\n  simp [comm, h₁.some_spec.some_spec.some_spec.2, h₂.some_spec.some_spec.some_spec.2]\n#align family_of_elements.compatible.sieve_extend family_of_elements.compatible.sieve_extend\n\n",
 "sheaf_condition":
 "/-- `P` is a sheaf for `R`, iff the fork given by `w` is an equalizer.\nSee <https://stacks.math.columbia.edu/tag/00VM>.\n-/\ntheorem sheaf_condition : R.is_sheaf_for P ↔ nonempty (is_limit (fork.of_ι _ (w P R))) :=\n  by\n  rw [types.type_equalizer_iff_unique]\n  erw [← equiv.forall_congr_left (first_obj_eq_family P R).to_equiv.symm]\n  simp_rw [← compatible_iff, ← iso.to_equiv_fun, equiv.apply_symm_apply]\n  apply ball_congr\n  intro x hx\n  apply exists_unique_congr\n  intro t\n  rw [equiv.eq_symm_apply]\n  constructor\n  · intro q\n    ext (Y f hf)\n    simpa [fork_map] using q _ _\n  · intro q Y f hf\n    rw [← q]\n    simp [fork_map]\n#align sheaf_condition sheaf_condition\n\n",
 "restrict_inj":
 "/-- Two compatible families on the sieve generated by a presieve `R` are equal if and only if they are\nequal when restricted to `R`.\n-/\ntheorem restrict_inj {x₁ x₂ : family_of_elements P (generate R)} (t₁ : x₁.compatible) (t₂ : x₂.compatible) :\n    x₁.restrict (le_generate R) = x₂.restrict (le_generate R) → x₁ = x₂ := fun h =>\n  by\n  rw [← extend_restrict t₁, ← extend_restrict t₂]\n  congr\n  exact h\n#align restrict_inj restrict_inj\n\n",
 "restrict_extend":
 "/-- The restriction of an extension is the original. -/\n@[simp]\ntheorem restrict_extend {x : family_of_elements P R} (t : x.compatible) : x.sieve_extend.restrict (le_generate R) = x :=\n  by\n  ext (Y f hf)\n  exact extend_agrees t hf\n#align restrict_extend restrict_extend\n\n",
 "restrict":
 "/-- The restriction of a compatible family is compatible. -/\ntheorem family_of_elements.compatible.restrict {R₁ R₂ : presieve X} (h : R₁ ≤ R₂) {x : family_of_elements P R₂} :\n    x.compatible → (x.restrict h).compatible := fun q Y₁ Y₂ Z g₁ g₂ f₁ f₂ h₁ h₂ comm => q g₁ g₂ (h _ h₁) (h _ h₂) comm\n#align family_of_elements.compatible.restrict family_of_elements.compatible.restrict\n\n",
 "pullback_compatible_iff":
 "/-\nCopyright (c) 2020 Bhavik Mehta. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Bhavik Mehta\n-/\ntheorem pullback_compatible_iff (x : family_of_elements P R) [has_pullbacks C] : x.compatible ↔ x.pullback_compatible :=\n  by\n  constructor\n  · intro t Y₁ Y₂ f₁ f₂ hf₁ hf₂\n    apply t\n    apply pullback.condition\n  · intro t Y₁ Y₂ Z g₁ g₂ f₁ f₂ hf₁ hf₂ comm\n    rw [← pullback.lift_fst _ _ comm, op_comp, functor_to_types.map_comp_apply, t hf₁ hf₂, ←\n      functor_to_types.map_comp_apply, ← op_comp, pullback.lift_snd]\n#align pullback_compatible_iff pullback_compatible_iff\n\n",
 "pullback":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem family_of_elements.compatible.pullback (f : «expr ⟶ » Y X) {x : family_of_elements P S} (h : x.compatible) :\n    (x.pullback f).compatible := by\n  simp only [compatible_iff_sieve_compatible] at h⊢\n  intro W Z f₁ f₂ hf\n  unfold family_of_elements.pullback\n  rw [← h («expr ≫ » f₁ f) f₂ hf]\n  simp only [assoc]\n#align family_of_elements.compatible.pullback family_of_elements.compatible.pullback\n\n",
 "is_sheaf_pretopology":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n/-- For a topology generated by a basis, it suffices to check the sheaf condition on the basis\npresieves only.\n-/\ntheorem is_sheaf_pretopology [has_pullbacks C] (K : pretopology C) :\n    is_sheaf (K.to_grothendieck C) P ↔ ∀ {X : C} (R : presieve X), R ∈ K X → is_sheaf_for P R :=\n  by\n  constructor\n  · intro PJ X R hR\n    rw [is_sheaf_for_iff_generate]\n    apply PJ (sieve.generate R) ⟨_, hR, le_generate R⟩\n  · rintro PK X S ⟨R, hR, RS⟩\n    have gRS : «expr⇑ » (generate R) ≤ S := by\n      apply gi_generate.gc.monotone_u\n      rwa [sets_iff_generate]\n    apply is_sheaf_for_subsieve P gRS _\n    intro Y f\n    rw [← pullback_arrows_comm, ← is_sheaf_for_iff_generate]\n    exact PK (pullback_arrows f R) (K.pullbacks f R hR)\n#align is_sheaf_pretopology is_sheaf_pretopology\n\n",
 "is_sheaf_of_yoneda":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵖ» -/\ntheorem is_sheaf_of_yoneda {P : «expr ⥤ » («expr ᵒᵖ» C) (Type v₁)}\n    (h : ∀ {X} (S : sieve X), S ∈ J X → yoneda_sheaf_condition P S) : is_sheaf J P := fun X S hS =>\n  is_sheaf_for_iff_yoneda_sheaf_condition.2 (h _ hS)\n#align is_sheaf_of_yoneda is_sheaf_of_yoneda\n\n",
 "is_sheaf_of_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵖ» -/\ntheorem is_sheaf_of_le (P : «expr ⥤ » («expr ᵒᵖ» C) (Type w)) {J₁ J₂ : grothendieck_topology C} :\n    J₁ ≤ J₂ → is_sheaf J₂ P → is_sheaf J₁ P := fun h t X S hS => t S (h _ hS)\n#align is_sheaf_of_le is_sheaf_of_le\n\n",
 "is_sheaf_iso":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵖ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≅ » -/\n/-- The property of being a sheaf is preserved by isomorphism. -/\ntheorem is_sheaf_iso {P' : «expr ⥤ » («expr ᵒᵖ» C) (Type w)} (i : «expr ≅ » P P') (h : is_sheaf J P) : is_sheaf J P' :=\n  fun X S hS => is_sheaf_for_iso i (h S hS)\n#align is_sheaf_iso is_sheaf_iso\n\n",
 "is_sheaf_for_top_sieve":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵖ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/-- Every presheaf is a sheaf for the maximal sieve.\n\n[Elephant] C2.1.5(ii)\n-/\ntheorem is_sheaf_for_top_sieve (P : «expr ⥤ » («expr ᵒᵖ» C) (Type w)) :\n    is_sheaf_for P ((«expr⊤» : sieve X) : presieve X) :=\n  by\n  rw [← generate_of_singleton_is_split_epi ((«expr𝟙») X)]\n  rw [← is_sheaf_for_iff_generate]\n  apply is_sheaf_for_singleton_iso\n#align is_sheaf_for_top_sieve is_sheaf_for_top_sieve\n\n",
 "is_sheaf_for_subsieve_aux":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵖ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/-- If a presieve `R` on `X` has a subsieve `S` such that:\n\n* `P` is a sheaf for `S`.\n* For every `f` in `R`, `P` is separated for the pullback of `S` along `f`,\n\nthen `P` is a sheaf for `R`.\n\nThis is closely related to [Elephant] C2.1.6(i).\n-/\ntheorem is_sheaf_for_subsieve_aux (P : «expr ⥤ » («expr ᵒᵖ» C) (Type w)) {S : sieve X} {R : presieve X}\n    (h : (S : presieve X) ≤ R) (hS : is_sheaf_for P S)\n    (trans : ∀ ⦃Y⦄ ⦃f : «expr ⟶ » Y X⦄, R f → is_separated_for P (S.pullback f)) : is_sheaf_for P R :=\n  by\n  rw [← is_separated_for_and_exists_is_amalgamation_iff_sheaf_for]\n  constructor\n  · intro x t₁ t₂ ht₁ ht₂\n    exact hS.is_separated_for _ _ _ (is_amalgamation_restrict h x t₁ ht₁) (is_amalgamation_restrict h x t₂ ht₂)\n  · intro x hx\n    use hS.amalgamate _ (hx.restrict h)\n    intro W j hj\n    apply (trans hj).ext\n    intro Y f hf\n    rw [← functor_to_types.map_comp_apply, ← op_comp, hS.valid_glue (hx.restrict h) _ hf, family_of_elements.restrict, ←\n      hx ((«expr𝟙») _) f _ _ (id_comp _)]\n    simp\n#align is_sheaf_for_subsieve_aux is_sheaf_for_subsieve_aux\n\n",
 "is_sheaf_for_subsieve":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵖ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/-- If `P` is a sheaf for every pullback of the sieve `S`, then `P` is a sheaf for any presieve which\ncontains `S`.\nThis is closely related to [Elephant] C2.1.6.\n-/\ntheorem is_sheaf_for_subsieve (P : «expr ⥤ » («expr ᵒᵖ» C) (Type w)) {S : sieve X} {R : presieve X}\n    (h : (S : presieve X) ≤ R) (trans : ∀ ⦃Y⦄ (f : «expr ⟶ » Y X), is_sheaf_for P (S.pullback f)) : is_sheaf_for P R :=\n  is_sheaf_for_subsieve_aux P h (by simpa using trans ((«expr𝟙») _)) fun Y f hf => (trans f).is_separated_for\n#align is_sheaf_for_subsieve is_sheaf_for_subsieve\n\n",
 "is_sheaf_for_singleton_iso":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵖ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/-- Every presheaf is a sheaf for the family {𝟙 X}.\n\n[Elephant] C2.1.5(i)\n-/\ntheorem is_sheaf_for_singleton_iso (P : «expr ⥤ » («expr ᵒᵖ» C) (Type w)) :\n    is_sheaf_for P (presieve.singleton ((«expr𝟙») X)) :=\n  by\n  intro x hx\n  refine' ⟨x _ (presieve.singleton_self _), _, _⟩\n  · rintro _ _ ⟨rfl, rfl⟩\n    simp\n  · intro t ht\n    simpa using ht _ (presieve.singleton_self _)\n#align is_sheaf_for_singleton_iso is_sheaf_for_singleton_iso\n\n",
 "is_sheaf_for_iso":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵖ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≅ » -/\n/-- If `P` is a sheaf for `S`, and it is iso to `P'`, then `P'` is a sheaf for `S`. This shows that\n\"being a sheaf for a presieve\" is a mathematical or hygenic property.\n-/\ntheorem is_sheaf_for_iso {P' : «expr ⥤ » («expr ᵒᵖ» C) (Type w)} (i : «expr ≅ » P P') :\n    is_sheaf_for P R → is_sheaf_for P' R := by\n  intro h x hx\n  let x' := x.comp_presheaf_map i.inv\n  have : x'.compatible := family_of_elements.compatible.comp_presheaf_map i.inv hx\n  obtain ⟨t, ht1, ht2⟩ := h x' this\n  use i.hom.app _ t\n  fconstructor\n  · convert family_of_elements.is_amalgamation.comp_presheaf_map i.hom ht1\n    dsimp [x']\n    simp\n  · intro y hy\n    rw [show y = («expr ≫ » (i.inv.app (op X)) (i.hom.app (op X))) y by simp]\n    simp [ht2 (i.inv.app _ y) (family_of_elements.is_amalgamation.comp_presheaf_map i.inv hy)]\n#align is_sheaf_for_iso is_sheaf_for_iso\n\n",
 "is_sheaf_for_iff_yoneda_sheaf_condition":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵖ» -/\n-- See note [dsimp, simp].\n/-- The yoneda version of the sheaf condition is equivalent to the sheaf condition.\n\nC2.1.4 of [Elephant].\n-/\ntheorem is_sheaf_for_iff_yoneda_sheaf_condition {P : «expr ⥤ » («expr ᵒᵖ» C) (Type v₁)} :\n    is_sheaf_for P S ↔ yoneda_sheaf_condition P S :=\n  by\n  rw [is_sheaf_for, yoneda_sheaf_condition]\n  simp_rw [extension_iff_amalgamation]\n  rw [equiv.forall_congr_left' nat_trans_equiv_compatible_family]\n  rw [subtype.forall]\n  apply ball_congr\n  intro x hx\n  rw [equiv.exists_unique_congr_left _]\n  simp\n#align is_sheaf_for_iff_yoneda_sheaf_condition is_sheaf_for_iff_yoneda_sheaf_condition\n\n",
 "is_sheaf_for_iff_generate":
 "/-- C2.1.3 in [Elephant] -/\ntheorem is_sheaf_for_iff_generate (R : presieve X) : is_sheaf_for P R ↔ is_sheaf_for P (generate R) :=\n  by\n  rw [← is_separated_for_and_exists_is_amalgamation_iff_sheaf_for]\n  rw [← is_separated_for_and_exists_is_amalgamation_iff_sheaf_for]\n  rw [← is_separated_for_iff_generate]\n  apply and_congr (iff.refl _)\n  constructor\n  · intro q x hx\n    apply Exists.imp _ (q _ (hx.restrict (le_generate R)))\n    intro t ht\n    simpa [hx] using is_amalgamation_sieve_extend _ _ ht\n  · intro q x hx\n    apply Exists.imp _ (q _ hx.sieve_extend)\n    intro t ht\n    simpa [hx] using is_amalgamation_restrict (le_generate R) _ _ ht\n#align is_sheaf_for_iff_generate is_sheaf_for_iff_generate\n\n",
 "is_sheaf_for":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵖ» -/\ntheorem is_sheaf.is_sheaf_for {P : «expr ⥤ » («expr ᵒᵖ» C) (Type w)} (hp : is_sheaf J P) (R : presieve X)\n    (hr : generate R ∈ J X) : is_sheaf_for P R :=\n  (is_sheaf_for_iff_generate R).2 <| hp _ hr\n#align is_sheaf.is_sheaf_for is_sheaf.is_sheaf_for\n\n",
 "is_sheaf_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/-- Any presheaf is a sheaf for the bottom (trivial) grothendieck topology. -/\ntheorem is_sheaf_bot : is_sheaf («expr⊥» : grothendieck_topology C) P := fun X => by simp [is_sheaf_for_top_sieve]\n#align is_sheaf_bot is_sheaf_bot\n\n",
 "is_separated_of_is_sheaf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵖ» -/\ntheorem is_separated_of_is_sheaf (P : «expr ⥤ » («expr ᵒᵖ» C) (Type w)) (h : is_sheaf J P) : is_separated J P :=\n  fun X S hS => (h S hS).is_separated_for\n#align is_separated_of_is_sheaf is_separated_of_is_sheaf\n\n",
 "is_separated_for_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵖ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem is_separated_for_top (P : «expr ⥤ » («expr ᵒᵖ» C) (Type w)) : is_separated_for P («expr⊤» : presieve X) :=\n  fun x t₁ t₂ h₁ h₂ => by\n  have q₁ := h₁ ((«expr𝟙») X) (by simp)\n  have q₂ := h₂ ((«expr𝟙») X) (by simp)\n  simp only [op_id, functor_to_types.map_id_apply] at q₁ q₂\n  rw [q₁, q₂]\n#align is_separated_for_top is_separated_for_top\n\n",
 "is_separated_for_iff_generate":
 "theorem is_separated_for_iff_generate : is_separated_for P R ↔ is_separated_for P (generate R) :=\n  by\n  constructor\n  · intro h x t₁ t₂ ht₁ ht₂\n    apply h (x.restrict (le_generate R)) t₁ t₂ _ _\n    · exact is_amalgamation_restrict _ x t₁ ht₁\n    · exact is_amalgamation_restrict _ x t₂ ht₂\n  · intro h x t₁ t₂ ht₁ ht₂\n    apply h x.sieve_extend\n    · exact is_amalgamation_sieve_extend x t₁ ht₁\n    · exact is_amalgamation_sieve_extend x t₂ ht₂\n#align is_separated_for_iff_generate is_separated_for_iff_generate\n\n",
 "is_separated_for_and_exists_is_amalgamation_iff_sheaf_for":
 "/-- `P` is a sheaf for `R` iff it is separated for `R` and there exists an amalgamation. -/\ntheorem is_separated_for_and_exists_is_amalgamation_iff_sheaf_for :\n    (is_separated_for P R ∧ ∀ x : family_of_elements P R, x.compatible → ∃ t, x.is_amalgamation t) ↔ is_sheaf_for P R :=\n  by\n  rw [is_separated_for, ← forall_and]\n  apply forall_congr'\n  intro x\n  constructor\n  · intro z hx\n    exact exists_unique_of_exists_of_unique (z.2 hx) z.1\n  · intro h\n    refine' ⟨_, ExistsUnique.exists ∘ h⟩\n    intro t₁ t₂ ht₁ ht₂\n    apply (h _).unique ht₁ ht₂\n    exact is_compatible_of_exists_amalgamation x ⟨_, ht₂⟩\n#align\n  is_separated_for_and_exists_is_amalgamation_iff_sheaf_for is_separated_for_and_exists_is_amalgamation_iff_sheaf_for\n\n",
 "is_separated_for":
 "/-- If `P` is a sheaf for `R`, it is separated for `R`. -/\ntheorem is_sheaf_for.is_separated_for : is_sheaf_for P R → is_separated_for P R := fun q =>\n  (is_separated_for_and_exists_is_amalgamation_iff_sheaf_for.2 q).1\n#align is_sheaf_for.is_separated_for is_sheaf_for.is_separated_for\n\n",
 "is_compatible_of_exists_amalgamation":
 "theorem is_compatible_of_exists_amalgamation (x : family_of_elements P R) (h : ∃ t, x.is_amalgamation t) :\n    x.compatible := by\n  cases' h with t ht\n  intro Y₁ Y₂ Z g₁ g₂ f₁ f₂ h₁ h₂ comm\n  rw [← ht _ h₁, ← ht _ h₂, ← functor_to_types.map_comp_apply, ← op_comp, comm]\n  simp\n#align is_compatible_of_exists_amalgamation is_compatible_of_exists_amalgamation\n\n",
 "is_amalgamation_sieve_extend":
 "theorem is_amalgamation_sieve_extend {R : presieve X} (x : family_of_elements P R) (t : P.obj (op X))\n    (ht : x.is_amalgamation t) : x.sieve_extend.is_amalgamation t :=\n  by\n  intro Y f hf\n  dsimp [family_of_elements.sieve_extend]\n  rw [← ht _, ← functor_to_types.map_comp_apply, ← op_comp, hf.some_spec.some_spec.some_spec.2]\n#align is_amalgamation_sieve_extend is_amalgamation_sieve_extend\n\n",
 "is_amalgamation_restrict":
 "theorem is_amalgamation_restrict {R₁ R₂ : presieve X} (h : R₁ ≤ R₂) (x : family_of_elements P R₂) (t : P.obj (op X))\n    (ht : x.is_amalgamation t) : (x.restrict h).is_amalgamation t := fun Y f hf => ht f (h Y hf)\n#align is_amalgamation_restrict is_amalgamation_restrict\n\n",
 "is_amalgamation":
 "theorem is_sheaf_for.is_amalgamation (t : is_sheaf_for P R) {x : family_of_elements P R} (hx : x.compatible) :\n    x.is_amalgamation (t.amalgamate x hx) :=\n  (t x hx).exists.some_spec\n#align is_sheaf_for.is_amalgamation is_sheaf_for.is_amalgamation\n\n",
 "hom_ext":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵖ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/-- If `P` is a sheaf for the sieve `S` on `X`, then if two natural transformations from `yoneda.obj X`\nto `P` agree when restricted to the subfunctor given by `S`, they are equal.\n-/\ntheorem is_sheaf_for.hom_ext {P : «expr ⥤ » («expr ᵒᵖ» C) (Type v₁)} (h : is_sheaf_for P S)\n    (t₁ t₂ : «expr ⟶ » (yoneda.obj X) P) (ht : «expr ≫ » S.functor_inclusion t₁ = «expr ≫ » S.functor_inclusion t₂) :\n    t₁ = t₂ :=\n  (h.unique_extend t₁ ht).trans (h.unique_extend t₂ rfl).symm\n#align is_sheaf_for.hom_ext is_sheaf_for.hom_ext\n\n",
 "functor_pullback":
 "theorem family_of_elements.compatible.functor_pullback (h : x.compatible) : (x.functor_pullback F).compatible :=\n  by\n  intro Z₁ Z₂ W g₁ g₂ f₁ f₂ h₁ h₂ eq\n  exact h (F.map g₁) (F.map g₂) h₁ h₂ (by simp only [← F.map_comp, eq])\n#align family_of_elements.compatible.functor_pullback family_of_elements.compatible.functor_pullback\n\n",
 "functor_inclusion_comp_extend":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵖ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/-- Show that the extension of `f : S.functor ⟶ P` to all of `yoneda.obj X` is in fact an extension, ie\nthat the triangle below commutes, provided `P` is a sheaf for `S`\n\n      f\n   S  →  P\n   ↓  ↗\n   yX\n\n-/\n@[simp, reassoc.1]\ntheorem is_sheaf_for.functor_inclusion_comp_extend {P : «expr ⥤ » («expr ᵒᵖ» C) (Type v₁)} (h : is_sheaf_for P S)\n    (f : «expr ⟶ » S.functor P) : «expr ≫ » S.functor_inclusion (h.extend f) = f :=\n  (is_sheaf_for_iff_yoneda_sheaf_condition.1 h f).exists.some_spec\n#align is_sheaf_for.functor_inclusion_comp_extend is_sheaf_for.functor_inclusion_comp_extend\n\n",
 "extension_iff_amalgamation":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵖ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n-- TODO: We can generalize the universe parameter v₁ above by composing with\n-- appropriate `ulift_functor`s.\n/-- (Implementation). A lemma useful to prove `yoneda_condition_iff_sheaf_condition`. -/\ntheorem extension_iff_amalgamation {P : «expr ⥤ » («expr ᵒᵖ» C) (Type v₁)} (x : «expr ⟶ » S.functor P)\n    (g : «expr ⟶ » (yoneda.obj X) P) :\n    «expr ≫ » S.functor_inclusion g = x ↔ (nat_trans_equiv_compatible_family x).1.is_amalgamation (yoneda_equiv g) :=\n  by\n  change _ ↔ ∀ ⦃Y : C⦄ (f : «expr ⟶ » Y X) (h : S f), P.map f.op (yoneda_equiv g) = x.app (op Y) ⟨f, h⟩\n  constructor\n  · rintro rfl Y f hf\n    rw [yoneda_equiv_naturality]\n    dsimp\n    simp\n  -- See note [dsimp, simp].\n  · intro h\n    ext (Y⟨f, hf⟩)\n    have : _ = x.app Y _ := h f hf\n    rw [yoneda_equiv_naturality] at this\n    rw [← this]\n    dsimp\n    simp\n#align extension_iff_amalgamation extension_iff_amalgamation\n\n",
 "extend_restrict":
 "/-- Given a family of elements `x` for the sieve `S` generated by a presieve `R`, if `x` is restricted\nto `R` and then extended back up to `S`, the resulting extension equals `x`.\n-/\n@[simp]\ntheorem extend_restrict {x : family_of_elements P (generate R)} (t : x.compatible) :\n    (x.restrict (le_generate R)).sieve_extend = x :=\n  by\n  rw [compatible_iff_sieve_compatible] at t\n  ext (_ _ h); apply (t _ _ _).symm.trans; congr\n  exact h.some_spec.some_spec.some_spec.2\n#align extend_restrict extend_restrict\n\n",
 "extend_agrees":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/-- The extension of a family agrees with the original family. -/\ntheorem extend_agrees {x : family_of_elements P R} (t : x.compatible) {f : «expr ⟶ » Y X} (hf : R f) :\n    x.sieve_extend f (le_generate R Y hf) = x f hf :=\n  by\n  have h := (le_generate R Y hf).some_spec\n  unfold family_of_elements.sieve_extend\n  rw [t h.some ((«expr𝟙») _) _ hf _]\n  · simp;\n  · rw [id_comp]\n    exact h.some_spec.some_spec.2\n#align extend_agrees extend_agrees\n\n",
 "ext":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem is_separated_for.ext {R : presieve X} (hR : is_separated_for P R) {t₁ t₂ : P.obj (op X)}\n    (h : ∀ ⦃Y⦄ ⦃f : «expr ⟶ » Y X⦄ (hf : R f), P.map f.op t₁ = P.map f.op t₂) : t₁ = t₂ :=\n  hR (fun Y f hf => P.map f.op t₂) t₁ t₂ (fun Y f hf => h hf) fun Y f hf => rfl\n#align is_separated_for.ext is_separated_for.ext\n\n",
 "equalizer_sheaf_condition":
 "/-- `P` is a sheaf for `S`, iff the fork given by `w` is an equalizer. -/\ntheorem equalizer_sheaf_condition : presieve.is_sheaf_for P S ↔ nonempty (is_limit (fork.of_ι _ (w P S))) :=\n  by\n  rw [types.type_equalizer_iff_unique, ← equiv.forall_congr_left (first_obj_eq_family P S).to_equiv.symm]\n  simp_rw [← compatible_iff]\n  simp only [inv_hom_id_apply, iso.to_equiv_symm_fun]\n  apply ball_congr\n  intro x tx\n  apply exists_unique_congr\n  intro t\n  rw [← iso.to_equiv_symm_fun]\n  rw [equiv.eq_symm_apply]\n  constructor\n  · intro q\n    ext (Y f hf)\n    simpa [first_obj_eq_family, fork_map] using q _ _\n  · intro q Y f hf\n    rw [← q]\n    simp [first_obj_eq_family, fork_map]\n#align equalizer_sheaf_condition equalizer_sheaf_condition\n\n",
 "compatible_iff_sieve_compatible":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\ntheorem compatible_iff_sieve_compatible (x : family_of_elements P S) : x.compatible ↔ x.sieve_compatible :=\n  by\n  constructor\n  · intro h Y Z f g hf\n    simpa using h ((«expr𝟙») _) g (S.downward_closed hf g) hf (id_comp _)\n  · intro h Y₁ Y₂ Z g₁ g₂ f₁ f₂ h₁ h₂ k\n    simp_rw [← h f₁ g₁ h₁, k, h f₂ g₂ h₂]\n#align compatible_iff_sieve_compatible compatible_iff_sieve_compatible\n\n",
 "compatible_iff":
 "/-- The family of elements given by `x : first_obj P S` is compatible iff `first_map` and `second_map`\nmap it to the same point.\n-/\ntheorem compatible_iff (x : first_obj P R) :\n    ((first_obj_eq_family P R).hom x).compatible ↔ first_map P R x = second_map P R x :=\n  by\n  rw [presieve.pullback_compatible_iff]\n  constructor\n  · intro t\n    ext ⟨⟨Y, f, hf⟩, Z, g, hg⟩\n    simpa [first_map, second_map] using t hf hg\n  · intro t Y Z f g hf hg\n    rw [types.limit_ext_iff'] at t\n    simpa [first_map, second_map] using t ⟨⟨⟨Y, f, hf⟩, Z, g, hg⟩⟩\n#align compatible_iff compatible_iff\n\n",
 "comp_presheaf_map_id":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n@[simp]\ntheorem family_of_elements.comp_presheaf_map_id (x : family_of_elements P R) : x.comp_presheaf_map ((«expr𝟙») P) = x :=\n  rfl\n#align family_of_elements.comp_presheaf_map_id family_of_elements.comp_presheaf_map_id\n\n",
 "comp_presheaf_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem family_of_elements.is_amalgamation.comp_presheaf_map {x : family_of_elements P R} {t} (f : «expr ⟶ » P Q)\n    (h : x.is_amalgamation t) : (x.comp_presheaf_map f).is_amalgamation (f.app (op X) t) :=\n  by\n  intro Y g hg\n  dsimp [family_of_elements.comp_presheaf_map]\n  change («expr ≫ » (f.app _) (Q.map _)) _ = _\n  simp [← f.naturality, h g hg]\n#align family_of_elements.is_amalgamation.comp_presheaf_map family_of_elements.is_amalgamation.comp_presheaf_map\n\n",
 "comp_prersheaf_map_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp]\ntheorem family_of_elements.comp_prersheaf_map_comp (x : family_of_elements P R) (f : «expr ⟶ » P Q)\n    (g : «expr ⟶ » Q U) : (x.comp_presheaf_map f).comp_presheaf_map g = x.comp_presheaf_map («expr ≫ » f g) :=\n  rfl\n#align family_of_elements.comp_prersheaf_map_comp family_of_elements.comp_prersheaf_map_comp\n\n",
 "comp_of_compatible":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem family_of_elements.comp_of_compatible (S : sieve X) {x : family_of_elements P S} (t : x.compatible)\n    {f : «expr ⟶ » Y X} (hf : S f) {Z} (g : «expr ⟶ » Z Y) :\n    x («expr ≫ » g f) (S.downward_closed hf g) = P.map g.op (x f hf) := by\n  simpa using t ((«expr𝟙») _) g (S.downward_closed hf g) hf (id_comp _)\n#align family_of_elements.comp_of_compatible family_of_elements.comp_of_compatible\n\n"}