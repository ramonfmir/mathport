{"top_subpresheaf_obj":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\n@[simp]\ntheorem top_subpresheaf_obj (U) : (Â«exprâŠ¤Â» : subpresheaf F).obj U = Â«exprâŠ¤Â» :=\n  rfl\n#align top_subpresheaf_obj top_subpresheaf_obj\n\n",
 "to_sheafify_lift_unique":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\ntheorem subpresheaf.to_sheafify_lift_unique (h : Presieve.IsSheaf J F')\n    (lâ‚ lâ‚‚ : Â«expr âŸ¶ Â» (G.sheafify J).to_presheaf F')\n    (e :\n      Â«expr â‰« Â» (subpresheaf.hom_of_le (G.le_sheafify J)) lâ‚ = Â«expr â‰« Â» (subpresheaf.hom_of_le (G.le_sheafify J)) lâ‚‚) :\n    lâ‚ = lâ‚‚ := by\n  ext (UâŸ¨s, hsâŸ©)\n  apply (h _ hs).is_separated_for.ext\n  rintro V i hi\n  dsimp at hi\n  erw [â† functor_to_types.naturality, â† functor_to_types.naturality]\n  exact (congr_fun (congr_app e <| op V) âŸ¨_, hiâŸ© : _)\n#align subpresheaf.to_sheafify_lift_unique subpresheaf.to_sheafify_lift_unique\n\n",
 "to_sheafify_lift":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\ntheorem subpresheaf.to_sheafify_lift (f : Â«expr âŸ¶ Â» G.to_presheaf F') (h : Presieve.IsSheaf J F') :\n    Â«expr â‰« Â» (subpresheaf.hom_of_le (G.le_sheafify J)) (G.sheafify_lift f h) = f :=\n  by\n  ext (U s)\n  apply (h _ ((subpresheaf.hom_of_le (G.le_sheafify J)).app U s).prop).is_separated_for.ext\n  intro V i hi\n  have := elementwise_of f.naturality\n  exact (presieve.is_sheaf_for.valid_glue _ _ _ hi).trans (this _ _)\n#align subpresheaf.to_sheafify_lift subpresheaf.to_sheafify_lift\n\n",
 "to_image_sheaf_Î¹":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n@[simp, reassoc.1]\ntheorem to_image_sheaf_Î¹ {F F' : Sheaf J (Type w)} (f : Â«expr âŸ¶ Â» F F') :\n    Â«expr â‰« Â» (to_image_sheaf f) (image_sheaf_Î¹ f) = f :=\n  by\n  ext1\n  simp [to_image_presheaf_sheafify]\n#align to_image_sheaf_Î¹ to_image_sheaf_Î¹\n\n",
 "to_image_presheaf_Î¹":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n@[simp, reassoc.1]\ntheorem to_image_presheaf_Î¹ (f : Â«expr âŸ¶ Â» F' F) : Â«expr â‰« Â» (to_image_presheaf f) (image_presheaf f).Î¹ = f :=\n  (image_presheaf f).lift_Î¹ _ _\n#align to_image_presheaf_Î¹ to_image_presheaf_Î¹\n\n",
 "sheafify_sheafify":
 "theorem subpresheaf.sheafify_sheafify (h : Presieve.IsSheaf J F) : (G.sheafify J).sheafify J = G.sheafify J :=\n  ((subpresheaf.eq_sheafify_iff _ h).mpr <| G.sheafify_is_sheaf h).symm\n#align subpresheaf.sheafify_sheafify subpresheaf.sheafify_sheafify\n\n",
 "sheafify_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem subpresheaf.sheafify_le (h : G â‰¤ G') (hF : Presieve.IsSheaf J F) (hG' : Presieve.IsSheaf J G'.to_presheaf) :\n    G.sheafify J â‰¤ G' := by\n  intro U x hx\n  convert((G.sheafify_lift (subpresheaf.hom_of_le h) hG').app U âŸ¨x, hxâŸ©).2\n  apply (hF _ hx).is_separated_for.ext\n  intro V i hi\n  have :=\n    congr_arg (fun f : Â«expr âŸ¶ Â» G.to_presheaf G'.to_presheaf => (nat_trans.app f (op V) âŸ¨_, hiâŸ©).1)\n      (G.to_sheafify_lift (subpresheaf.hom_of_le h) hG')\n  convert this.symm\n  erw [â† subpresheaf.nat_trans_naturality]\n  rfl\n#align subpresheaf.sheafify_le subpresheaf.sheafify_le\n\n",
 "sheafify_is_sheaf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\ntheorem subpresheaf.sheafify_is_sheaf (hF : Presieve.IsSheaf J F) : Presieve.IsSheaf J (G.sheafify J).to_presheaf :=\n  by\n  intro U S hS x hx\n  let S' := sieve.bind S fun Y f hf => G.sieve_of_section (x f hf).1\n  have := fun {V} {i : Â«expr âŸ¶ Â» V U} (hi : S' i) => hi\n  choose W iâ‚ iâ‚‚ hiâ‚‚ hâ‚ hâ‚‚\n  dsimp [-sieve.bind_apply] at *\n  let x'' : presieve.family_of_elements F S' := fun V i hi => F.map (iâ‚ hi).op (x _ (hiâ‚‚ hi))\n  have H : âˆ€ s, x.is_amalgamation s â†” x''.is_amalgamation s.1 :=\n    by\n    intro s\n    constructor\n    Â· intro H V i hi\n      dsimp only [x'']\n      conv_lhs => rw [â† hâ‚‚ hi]\n      rw [â† H _ (hiâ‚‚ hi)]\n      exact functor_to_types.map_comp_apply F (iâ‚‚ hi).op (iâ‚ hi).op _\n    Â· intro H V i hi\n      ext1\n      apply (hF _ (x i hi).2).is_separated_for.ext\n      intro V' i' hi'\n      have hi'' : S' (Â«expr â‰« Â» i' i) := âŸ¨_, _, _, hi, hi', rflâŸ©\n      have := H _ hi''\n      rw [op_comp, F.map_comp] at this\n      refine' this.trans (congr_arg Subtype.val (hx _ _ (hiâ‚‚ hi'') hi (hâ‚‚ hi'')))\n  have : x''.compatible := by\n    intro Vâ‚ Vâ‚‚ Vâ‚ƒ gâ‚ gâ‚‚ gâ‚ƒ gâ‚„ Sâ‚ Sâ‚‚ e\n    rw [â† functor_to_types.map_comp_apply, â† functor_to_types.map_comp_apply]\n    exact\n      congr_arg Subtype.val\n        (hx (Â«expr â‰« Â» gâ‚ (iâ‚ Sâ‚)) (Â«expr â‰« Â» gâ‚‚ (iâ‚ Sâ‚‚)) (hiâ‚‚ Sâ‚) (hiâ‚‚ Sâ‚‚) (by simp only [category.assoc, hâ‚‚, e]))\n  obtain âŸ¨t, ht, ht'âŸ© := hF _ (J.bind_covering hS fun V i hi => (x i hi).2) _ this\n  refine' âŸ¨âŸ¨t, _âŸ©, (H âŸ¨t, _âŸ©).mpr ht, fun y hy => Subtype.ext (ht' _ ((H _).mp hy))âŸ©\n  show G.sieve_of_section t âˆˆ J _\n  refine' J.superset_covering _ (J.bind_covering hS fun V i hi => (x i hi).2)\n  intro V i hi\n  dsimp\n  rw [ht _ hi]\n  exact hâ‚ hi\n#align subpresheaf.sheafify_is_sheaf subpresheaf.sheafify_is_sheaf\n\n",
 "nat_trans_naturality":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr áµ’áµ–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem subpresheaf.nat_trans_naturality (f : Â«expr âŸ¶ Â» F' G.to_presheaf) {U V : Â«expr áµ’áµ–Â» C} (i : Â«expr âŸ¶ Â» U V)\n    (x : F'.obj U) : (f.app V (F'.map i x)).1 = F.map i (f.app U x).1 :=\n  congr_arg Subtype.val (FunctorToTypes.naturality _ _ f i x)\n#align subpresheaf.nat_trans_naturality subpresheaf.nat_trans_naturality\n\n",
 "lift_Î¹":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n@[simp, reassoc.1]\ntheorem subpresheaf.lift_Î¹ (f : Â«expr âŸ¶ Â» F' F) (hf : âˆ€ U x, f.app U x âˆˆ G.obj U) : Â«expr â‰« Â» (G.lift f hf) G.Î¹ = f :=\n  by\n  ext\n  rfl\n#align subpresheaf.lift_Î¹ subpresheaf.lift_Î¹\n\n",
 "le_sheafify":
 "theorem subpresheaf.le_sheafify : G â‰¤ G.sheafify J :=\n  by\n  intro U s hs\n  change _ âˆˆ J _\n  convert J.top_mem _\n  rw [eq_top_iff]\n  rintro V i -\n  exact G.map i.op hs\n#align subpresheaf.le_sheafify subpresheaf.le_sheafify\n\n",
 "is_sheaf_iff":
 "theorem subpresheaf.is_sheaf_iff (h : Presieve.IsSheaf J F) :\n    Presieve.IsSheaf J G.to_presheaf â†” âˆ€ (U) (s : F.obj U), G.sieve_of_section s âˆˆ J (unop U) â†’ s âˆˆ G.obj U :=\n  by\n  rw [â† G.eq_sheafify_iff h]\n  change _ â†” G.sheafify J â‰¤ G\n  exact âŸ¨Eq.ge, (G.le_sheafify J).antisymmâŸ©\n#align subpresheaf.is_sheaf_iff subpresheaf.is_sheaf_iff\n\n",
 "image_presheaf_id":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\n@[simp]\ntheorem image_presheaf_id : image_presheaf ((Â«exprğŸ™Â») F) = Â«exprâŠ¤Â» :=\n  by\n  ext\n  simp\n#align image_presheaf_id image_presheaf_id\n\n",
 "image_presheaf_comp_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\ntheorem image_presheaf_comp_le (fâ‚ : Â«expr âŸ¶ Â» F F') (fâ‚‚ : Â«expr âŸ¶ Â» F' F'') :\n    image_presheaf (Â«expr â‰« Â» fâ‚ fâ‚‚) â‰¤ image_presheaf fâ‚‚ := fun U x hx => âŸ¨fâ‚.app U hx.some, hx.some_specâŸ©\n#align image_presheaf_comp_le image_presheaf_comp_le\n\n",
 "hom_of_le_Î¹":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/-\nCopyright (c) 2022 Andrew Yang. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Andrew Yang\n-/\n@[simp, reassoc.1]\ntheorem subpresheaf.hom_of_le_Î¹ {G G' : subpresheaf F} (h : G â‰¤ G') : Â«expr â‰« Â» (subpresheaf.hom_of_le h) G'.Î¹ = G.Î¹ :=\n  by\n  ext\n  rfl\n#align subpresheaf.hom_of_le_Î¹ subpresheaf.hom_of_le_Î¹\n\n",
 "family_of_elements_compatible":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr áµ’áµ–Â» -/\ntheorem subpresheaf.family_of_elements_compatible {U : Â«expr áµ’áµ–Â» C} (s : F.obj U) :\n    (G.family_of_elements_of_section s).compatible :=\n  by\n  intro Yâ‚ Yâ‚‚ Z gâ‚ gâ‚‚ fâ‚ fâ‚‚ hâ‚ hâ‚‚ e\n  ext1\n  change F.map gâ‚.op (F.map fâ‚.op s) = F.map gâ‚‚.op (F.map fâ‚‚.op s)\n  rw [â† functor_to_types.map_comp_apply, â† functor_to_types.map_comp_apply, â† op_comp, â† op_comp, e]\n#align subpresheaf.family_of_elements_compatible subpresheaf.family_of_elements_compatible\n\n",
 "eq_top_iff_is_iso":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\ntheorem subpresheaf.eq_top_iff_is_iso : G = Â«exprâŠ¤Â» â†” IsIso G.Î¹ :=\n  by\n  constructor\n  Â· rintro rfl\n    infer_instance\n  Â· intro H\n    ext (U x)\n    apply (iff_true_iff _).mpr\n    rw [â† is_iso.inv_hom_id_apply (G.Î¹.app U) x]\n    exact ((inv (G.Î¹.app U)) x).2\n#align subpresheaf.eq_top_iff_is_iso subpresheaf.eq_top_iff_is_iso\n\n",
 "eq_sheafify_iff":
 "theorem subpresheaf.eq_sheafify_iff (h : Presieve.IsSheaf J F) : G = G.sheafify J â†” Presieve.IsSheaf J G.to_presheaf :=\n  âŸ¨fun e => e.symm â–¸ G.sheafify_is_sheaf h, G.eq_sheafify hâŸ©\n#align subpresheaf.eq_sheafify_iff subpresheaf.eq_sheafify_iff\n\n",
 "eq_sheafify":
 "theorem subpresheaf.eq_sheafify (h : Presieve.IsSheaf J F) (hG : Presieve.IsSheaf J G.to_presheaf) : G = G.sheafify J :=\n  by\n  apply (G.le_sheafify J).antisymm\n  intro U s hs\n  suffices ((hG _ hs).amalgamate _ (G.family_of_elements_compatible s)).1 = s\n    by\n    rw [â† this]\n    exact ((hG _ hs).amalgamate _ (G.family_of_elements_compatible s)).2\n  apply (h _ hs).is_separated_for.ext\n  intro V i hi\n  exact (congr_arg Subtype.val ((hG _ hs).valid_glue (G.family_of_elements_compatible s) _ hi) : _)\n#align subpresheaf.eq_sheafify subpresheaf.eq_sheafify\n\n"}