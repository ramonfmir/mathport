{"top_subpresheaf_obj":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem top_subpresheaf_obj (U) : («expr⊤» : subpresheaf F).obj U = «expr⊤» :=\n  rfl\n#align top_subpresheaf_obj top_subpresheaf_obj\n\n",
 "to_sheafify_lift_unique":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem subpresheaf.to_sheafify_lift_unique (h : Presieve.IsSheaf J F')\n    (l₁ l₂ : «expr ⟶ » (G.sheafify J).to_presheaf F')\n    (e :\n      «expr ≫ » (subpresheaf.hom_of_le (G.le_sheafify J)) l₁ = «expr ≫ » (subpresheaf.hom_of_le (G.le_sheafify J)) l₂) :\n    l₁ = l₂ := by\n  ext (U⟨s, hs⟩)\n  apply (h _ hs).is_separated_for.ext\n  rintro V i hi\n  dsimp at hi\n  erw [← functor_to_types.naturality, ← functor_to_types.naturality]\n  exact (congr_fun (congr_app e <| op V) ⟨_, hi⟩ : _)\n#align subpresheaf.to_sheafify_lift_unique subpresheaf.to_sheafify_lift_unique\n\n",
 "to_sheafify_lift":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem subpresheaf.to_sheafify_lift (f : «expr ⟶ » G.to_presheaf F') (h : Presieve.IsSheaf J F') :\n    «expr ≫ » (subpresheaf.hom_of_le (G.le_sheafify J)) (G.sheafify_lift f h) = f :=\n  by\n  ext (U s)\n  apply (h _ ((subpresheaf.hom_of_le (G.le_sheafify J)).app U s).prop).is_separated_for.ext\n  intro V i hi\n  have := elementwise_of f.naturality\n  exact (presieve.is_sheaf_for.valid_glue _ _ _ hi).trans (this _ _)\n#align subpresheaf.to_sheafify_lift subpresheaf.to_sheafify_lift\n\n",
 "to_image_sheaf_ι":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem to_image_sheaf_ι {F F' : Sheaf J (Type w)} (f : «expr ⟶ » F F') :\n    «expr ≫ » (to_image_sheaf f) (image_sheaf_ι f) = f :=\n  by\n  ext1\n  simp [to_image_presheaf_sheafify]\n#align to_image_sheaf_ι to_image_sheaf_ι\n\n",
 "to_image_presheaf_ι":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem to_image_presheaf_ι (f : «expr ⟶ » F' F) : «expr ≫ » (to_image_presheaf f) (image_presheaf f).ι = f :=\n  (image_presheaf f).lift_ι _ _\n#align to_image_presheaf_ι to_image_presheaf_ι\n\n",
 "sheafify_sheafify":
 "theorem subpresheaf.sheafify_sheafify (h : Presieve.IsSheaf J F) : (G.sheafify J).sheafify J = G.sheafify J :=\n  ((subpresheaf.eq_sheafify_iff _ h).mpr <| G.sheafify_is_sheaf h).symm\n#align subpresheaf.sheafify_sheafify subpresheaf.sheafify_sheafify\n\n",
 "sheafify_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem subpresheaf.sheafify_le (h : G ≤ G') (hF : Presieve.IsSheaf J F) (hG' : Presieve.IsSheaf J G'.to_presheaf) :\n    G.sheafify J ≤ G' := by\n  intro U x hx\n  convert((G.sheafify_lift (subpresheaf.hom_of_le h) hG').app U ⟨x, hx⟩).2\n  apply (hF _ hx).is_separated_for.ext\n  intro V i hi\n  have :=\n    congr_arg (fun f : «expr ⟶ » G.to_presheaf G'.to_presheaf => (nat_trans.app f (op V) ⟨_, hi⟩).1)\n      (G.to_sheafify_lift (subpresheaf.hom_of_le h) hG')\n  convert this.symm\n  erw [← subpresheaf.nat_trans_naturality]\n  rfl\n#align subpresheaf.sheafify_le subpresheaf.sheafify_le\n\n",
 "sheafify_is_sheaf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem subpresheaf.sheafify_is_sheaf (hF : Presieve.IsSheaf J F) : Presieve.IsSheaf J (G.sheafify J).to_presheaf :=\n  by\n  intro U S hS x hx\n  let S' := sieve.bind S fun Y f hf => G.sieve_of_section (x f hf).1\n  have := fun {V} {i : «expr ⟶ » V U} (hi : S' i) => hi\n  choose W i₁ i₂ hi₂ h₁ h₂\n  dsimp [-sieve.bind_apply] at *\n  let x'' : presieve.family_of_elements F S' := fun V i hi => F.map (i₁ hi).op (x _ (hi₂ hi))\n  have H : ∀ s, x.is_amalgamation s ↔ x''.is_amalgamation s.1 :=\n    by\n    intro s\n    constructor\n    · intro H V i hi\n      dsimp only [x'']\n      conv_lhs => rw [← h₂ hi]\n      rw [← H _ (hi₂ hi)]\n      exact functor_to_types.map_comp_apply F (i₂ hi).op (i₁ hi).op _\n    · intro H V i hi\n      ext1\n      apply (hF _ (x i hi).2).is_separated_for.ext\n      intro V' i' hi'\n      have hi'' : S' («expr ≫ » i' i) := ⟨_, _, _, hi, hi', rfl⟩\n      have := H _ hi''\n      rw [op_comp, F.map_comp] at this\n      refine' this.trans (congr_arg Subtype.val (hx _ _ (hi₂ hi'') hi (h₂ hi'')))\n  have : x''.compatible := by\n    intro V₁ V₂ V₃ g₁ g₂ g₃ g₄ S₁ S₂ e\n    rw [← functor_to_types.map_comp_apply, ← functor_to_types.map_comp_apply]\n    exact\n      congr_arg Subtype.val\n        (hx («expr ≫ » g₁ (i₁ S₁)) («expr ≫ » g₂ (i₁ S₂)) (hi₂ S₁) (hi₂ S₂) (by simp only [category.assoc, h₂, e]))\n  obtain ⟨t, ht, ht'⟩ := hF _ (J.bind_covering hS fun V i hi => (x i hi).2) _ this\n  refine' ⟨⟨t, _⟩, (H ⟨t, _⟩).mpr ht, fun y hy => Subtype.ext (ht' _ ((H _).mp hy))⟩\n  show G.sieve_of_section t ∈ J _\n  refine' J.superset_covering _ (J.bind_covering hS fun V i hi => (x i hi).2)\n  intro V i hi\n  dsimp\n  rw [ht _ hi]\n  exact h₁ hi\n#align subpresheaf.sheafify_is_sheaf subpresheaf.sheafify_is_sheaf\n\n",
 "nat_trans_naturality":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵖ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem subpresheaf.nat_trans_naturality (f : «expr ⟶ » F' G.to_presheaf) {U V : «expr ᵒᵖ» C} (i : «expr ⟶ » U V)\n    (x : F'.obj U) : (f.app V (F'.map i x)).1 = F.map i (f.app U x).1 :=\n  congr_arg Subtype.val (FunctorToTypes.naturality _ _ f i x)\n#align subpresheaf.nat_trans_naturality subpresheaf.nat_trans_naturality\n\n",
 "lift_ι":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem subpresheaf.lift_ι (f : «expr ⟶ » F' F) (hf : ∀ U x, f.app U x ∈ G.obj U) : «expr ≫ » (G.lift f hf) G.ι = f :=\n  by\n  ext\n  rfl\n#align subpresheaf.lift_ι subpresheaf.lift_ι\n\n",
 "le_sheafify":
 "theorem subpresheaf.le_sheafify : G ≤ G.sheafify J :=\n  by\n  intro U s hs\n  change _ ∈ J _\n  convert J.top_mem _\n  rw [eq_top_iff]\n  rintro V i -\n  exact G.map i.op hs\n#align subpresheaf.le_sheafify subpresheaf.le_sheafify\n\n",
 "is_sheaf_iff":
 "theorem subpresheaf.is_sheaf_iff (h : Presieve.IsSheaf J F) :\n    Presieve.IsSheaf J G.to_presheaf ↔ ∀ (U) (s : F.obj U), G.sieve_of_section s ∈ J (unop U) → s ∈ G.obj U :=\n  by\n  rw [← G.eq_sheafify_iff h]\n  change _ ↔ G.sheafify J ≤ G\n  exact ⟨Eq.ge, (G.le_sheafify J).antisymm⟩\n#align subpresheaf.is_sheaf_iff subpresheaf.is_sheaf_iff\n\n",
 "image_presheaf_id":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem image_presheaf_id : image_presheaf ((«expr𝟙») F) = «expr⊤» :=\n  by\n  ext\n  simp\n#align image_presheaf_id image_presheaf_id\n\n",
 "image_presheaf_comp_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem image_presheaf_comp_le (f₁ : «expr ⟶ » F F') (f₂ : «expr ⟶ » F' F'') :\n    image_presheaf («expr ≫ » f₁ f₂) ≤ image_presheaf f₂ := fun U x hx => ⟨f₁.app U hx.some, hx.some_spec⟩\n#align image_presheaf_comp_le image_presheaf_comp_le\n\n",
 "hom_of_le_ι":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/-\nCopyright (c) 2022 Andrew Yang. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Andrew Yang\n-/\n@[simp, reassoc.1]\ntheorem subpresheaf.hom_of_le_ι {G G' : subpresheaf F} (h : G ≤ G') : «expr ≫ » (subpresheaf.hom_of_le h) G'.ι = G.ι :=\n  by\n  ext\n  rfl\n#align subpresheaf.hom_of_le_ι subpresheaf.hom_of_le_ι\n\n",
 "family_of_elements_compatible":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵖ» -/\ntheorem subpresheaf.family_of_elements_compatible {U : «expr ᵒᵖ» C} (s : F.obj U) :\n    (G.family_of_elements_of_section s).compatible :=\n  by\n  intro Y₁ Y₂ Z g₁ g₂ f₁ f₂ h₁ h₂ e\n  ext1\n  change F.map g₁.op (F.map f₁.op s) = F.map g₂.op (F.map f₂.op s)\n  rw [← functor_to_types.map_comp_apply, ← functor_to_types.map_comp_apply, ← op_comp, ← op_comp, e]\n#align subpresheaf.family_of_elements_compatible subpresheaf.family_of_elements_compatible\n\n",
 "eq_top_iff_is_iso":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem subpresheaf.eq_top_iff_is_iso : G = «expr⊤» ↔ IsIso G.ι :=\n  by\n  constructor\n  · rintro rfl\n    infer_instance\n  · intro H\n    ext (U x)\n    apply (iff_true_iff _).mpr\n    rw [← is_iso.inv_hom_id_apply (G.ι.app U) x]\n    exact ((inv (G.ι.app U)) x).2\n#align subpresheaf.eq_top_iff_is_iso subpresheaf.eq_top_iff_is_iso\n\n",
 "eq_sheafify_iff":
 "theorem subpresheaf.eq_sheafify_iff (h : Presieve.IsSheaf J F) : G = G.sheafify J ↔ Presieve.IsSheaf J G.to_presheaf :=\n  ⟨fun e => e.symm ▸ G.sheafify_is_sheaf h, G.eq_sheafify h⟩\n#align subpresheaf.eq_sheafify_iff subpresheaf.eq_sheafify_iff\n\n",
 "eq_sheafify":
 "theorem subpresheaf.eq_sheafify (h : Presieve.IsSheaf J F) (hG : Presieve.IsSheaf J G.to_presheaf) : G = G.sheafify J :=\n  by\n  apply (G.le_sheafify J).antisymm\n  intro U s hs\n  suffices ((hG _ hs).amalgamate _ (G.family_of_elements_compatible s)).1 = s\n    by\n    rw [← this]\n    exact ((hG _ hs).amalgamate _ (G.family_of_elements_compatible s)).2\n  apply (h _ hs).is_separated_for.ext\n  intro V i hi\n  exact (congr_arg Subtype.val ((hG _ hs).valid_glue (G.family_of_elements_compatible s) _ hi) : _)\n#align subpresheaf.eq_sheafify subpresheaf.eq_sheafify\n\n"}