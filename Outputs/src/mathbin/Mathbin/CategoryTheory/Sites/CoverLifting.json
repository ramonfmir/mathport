{"pulledback_family_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n@[simp]\ntheorem pulledback_family_apply (Y : StructuredArrow (op U) G.op) {W} {f : Â«expr âŸ¶ Â» W _} (Hf) :\n    pulledbackFamily â„± S x Y f Hf =\n      Â«expr â‰« Â» (x (Â«expr â‰« Â» (G.map f) Y.hom.unop) Hf) (((Ran.adjunction A G.op).counit.app â„±.val).app (op W)) :=\n  rfl\n#align pulledback_family_apply pulledback_family_apply\n\n",
 "id_cover_lifting":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprðŸ­Â» -/\n/-\nCopyright (c) 2021 Andrew Yang. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Andrew Yang\n-/\n/-- The identity functor on a site is cover-lifting. -/\ntheorem id_cover_lifting : CoverLifting J J ((Â«exprðŸ­Â») _) :=\n  âŸ¨fun _ _ h => by simpa using hâŸ©\n#align id_cover_lifting id_cover_lifting\n\n",
 "helper":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/-- A helper lemma for the following two lemmas. Basically stating that if the section `y : X âŸ¶ ð’¢(V)`\ncoincides with `x` on `G(V')` for all `G(V') âŠ† V âˆˆ S`, then `X âŸ¶ ð’¢(V) âŸ¶ â„±(W)` is indeed the\nsection obtained in `get_sections`. That said, this is littered with some more categorical jargon\nin order to be applied in the following lemmas easier.\n-/\ntheorem helper {V} (f : Â«expr âŸ¶ Â» V U) (y : Â«expr âŸ¶ Â» X (((ran G.op).obj â„±.val).obj (op V))) (W)\n    (H :\n      âˆ€ {V'} {fV : Â«expr âŸ¶ Â» (G.obj V') V} (hV),\n        Â«expr â‰« Â» y (((ran G.op).obj â„±.val).map fV.op) = x (Â«expr â‰« Â» fV f) hV) :\n    Â«expr â‰« Â» y (limit.Ï€ (Ran.diagram G.op â„±.val (op V)) W) =\n      (gluedLimitCone hu â„± hS hx).Ï€.app ((StructuredArrow.map f.op).obj W) :=\n  by\n  dsimp only [glued_limit_cone_Ï€_app]\n  apply get_section_is_unique hu â„± hS hx ((structured_arrow.map f.op).obj W)\n  intro V' fV' hV'\n  dsimp only [Ran.adjunction, Ran.equiv, pulledback_family_apply]\n  erw [adjunction.adjunction_of_equiv_right_counit_app]\n  have :\n    Â«expr â‰« Â» y (((Ran G.op).obj â„±.val).map (Â«expr â‰« Â» (G.map fV') W.hom.unop).op) =\n      x (Â«expr â‰« Â» (G.map fV') (Â«expr â‰« Â» W.hom.unop f)) (by simpa only using hV') :=\n    by\n    convert H (show S (Â«expr â‰« Â» (Â«expr â‰« Â» (G.map fV') W.hom.unop) f) by simpa only [category.assoc] using hV') using 2\n    simp only [category.assoc]\n  simp only [Quiver.Hom.unop_op, Equiv.symm_symm, structured_arrow.map_obj_hom, unop_comp, Equiv.coe_fn_mk,\n    functor.comp_map, coyoneda_obj_map, category.assoc, â† this, op_comp, Ran_obj_map, nat_trans.id_app]\n  erw [category.id_comp, limit.pre_Ï€]\n  congr\n  convert limit.w (Ran.diagram G.op â„±.val (op V)) (structured_arrow.hom_mk' W fV'.op)\n  rw [structured_arrow.map_mk]\n  erw [category.comp_id]\n  simp only [Quiver.Hom.unop_op, functor.op_map, Quiver.Hom.op_unop]\n#align helper helper\n\n",
 "glued_section_is_unique":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprðŸ™Â» -/\n/-- Verify that the amalgamation is indeed unique. -/\ntheorem glued_section_is_unique (y) (hy : x.is_amalgamation y) : y = gluedSection hu â„± hS hx :=\n  by\n  unfold glued_section limit.lift\n  ext W\n  erw [limit.lift_Ï€]\n  convert helper hu â„± hS hx ((Â«exprðŸ™Â») _) y W _\n  Â· simp only [op_id, structured_arrow.map_id]\n  Â· intro V' fV' hV'\n    convert hy fV' (by simpa only [category.comp_id] using hV')\n    erw [category.comp_id]\n#align glued_section_is_unique glued_section_is_unique\n\n",
 "glued_section_is_amalgamation":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprðŸ™Â» -/\n/-- Verify that the `glued_section` is an amalgamation of `x`. -/\ntheorem glued_section_is_amalgamation : x.is_amalgamation (gluedSection hu â„± hS hx) :=\n  by\n  intro V fV hV\n  ext W\n  simp only [functor.comp_map, limit.lift_pre, coyoneda_obj_map, Ran_obj_map, glued_section]\n  erw [limit.lift_Ï€]\n  symm\n  convert helper hu â„± hS hx _ (x fV hV) _ _ using 1\n  intro V' fV' hV'\n  convert hx fV' ((Â«exprðŸ™Â») _) hV hV' (by rw [category.id_comp])\n  simp only [op_id, functor_to_types.map_id_apply]\n#align glued_section_is_amalgamation glued_section_is_amalgamation\n\n",
 "glued_limit_cone_Ï€_app":
 "@[simp]\ntheorem glued_limit_cone_Ï€_app (W) : (gluedLimitCone hu â„± hS hx).Ï€.app W = getSection hu â„± hS hx W :=\n  rfl\n#align glued_limit_cone_Ï€_app glued_limit_cone_Ï€_app\n\n",
 "get_section_is_unique":
 "theorem get_section_is_unique (Y : StructuredArrow (op U) G.op) {y} (H : (pulledbackFamily â„± S x Y).is_amalgamation y) :\n    y = getSection hu â„± hS hx Y :=\n  by\n  apply is_sheaf_for.is_separated_for _ (pulledback_family â„± S x Y)\n  Â· exact H\n  Â· apply get_section_is_amalgamation\n  Â· exact â„±.2 X _ (hu.cover_lift (K.pullback_stable Y.hom.unop hS))\n#align get_section_is_unique get_section_is_unique\n\n",
 "get_section_is_amalgamation":
 "theorem get_section_is_amalgamation (Y : StructuredArrow (op U) G.op) :\n    (pulledbackFamily â„± S x Y).is_amalgamation (getSection hu â„± hS hx Y) :=\n  IsSheafFor.isAmalgamation _ _\n#align get_section_is_amalgamation get_section_is_amalgamation\n\n",
 "get_section_commute":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n@[simp]\ntheorem get_section_commute {Y Z : StructuredArrow (op U) G.op} (f : Â«expr âŸ¶ Â» Y Z) :\n    Â«expr â‰« Â» (getSection hu â„± hS hx Y) (â„±.val.map f.right) = getSection hu â„± hS hx Z :=\n  by\n  apply get_section_is_unique\n  intro V' fV' hV'\n  have eq : Z.hom = Â«expr â‰« Â» Y.hom (G.map f.right.unop).op :=\n    by\n    convert f.w\n    erw [category.id_comp]\n  rw [Eq] at hV'\n  convert get_section_is_amalgamation hu â„± hS hx Y (Â«expr â‰« Â» fV' f.right.unop) _ using 1\n  Â· tidy\n  Â· simp only [Eq, Quiver.Hom.unop_op, pulledback_family_apply, functor.map_comp, unop_comp, category.assoc]\n  Â· change S (Â«expr â‰« Â» (G.map _) Y.hom.unop)\n    simpa only [functor.map_comp, category.assoc] using hV'\n#align get_section_commute get_section_commute\n\n",
 "comp_cover_lifting":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‹™ Â» -/\n/-- The composition of two cover-lifting functors are cover-lifting -/\ntheorem comp_cover_lifting {F : Â«expr â¥¤ Â» C D} (hu : CoverLifting J K F) {G : Â«expr â¥¤ Â» D E} (hv : CoverLifting K L G) :\n    CoverLifting J L (Â«expr â‹™ Â» F G) :=\n  âŸ¨fun _ S h => hu.cover_lift (hv.cover_lift h)âŸ©\n#align comp_cover_lifting comp_cover_lifting\n\n",
 "Ran_is_sheaf_of_cover_lifting":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/-- If `G` is cover_lifting, then `Ran G.op` pushes sheaves to sheaves.\n\nThis result is basically https://stacks.math.columbia.edu/tag/00XK,\nbut without the condition that `C` or `D` has pullbacks.\n-/\ntheorem Ran_is_sheaf_of_cover_lifting {G : Â«expr â¥¤ Â» C D} (hG : CoverLifting J K G) (â„± : Sheaf J A) :\n    Presheaf.IsSheaf K ((ran G.op).obj â„±.val) := by\n  intro X U S hS x hx\n  constructor; swap\n  Â· apply Ran_is_sheaf_of_cover_lifting.glued_section hG â„± hS hx\n  constructor\n  Â· apply Ran_is_sheaf_of_cover_lifting.glued_section_is_amalgamation\n  Â· apply Ran_is_sheaf_of_cover_lifting.glued_section_is_unique\n#align Ran_is_sheaf_of_cover_lifting Ran_is_sheaf_of_cover_lifting\n\n"}