{"pulledback_family_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp]\ntheorem pulledback_family_apply (Y : StructuredArrow (op U) G.op) {W} {f : «expr ⟶ » W _} (Hf) :\n    pulledbackFamily ℱ S x Y f Hf =\n      «expr ≫ » (x («expr ≫ » (G.map f) Y.hom.unop) Hf) (((Ran.adjunction A G.op).counit.app ℱ.val).app (op W)) :=\n  rfl\n#align pulledback_family_apply pulledback_family_apply\n\n",
 "id_cover_lifting":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟭» -/\n/-\nCopyright (c) 2021 Andrew Yang. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Andrew Yang\n-/\n/-- The identity functor on a site is cover-lifting. -/\ntheorem id_cover_lifting : CoverLifting J J ((«expr𝟭») _) :=\n  ⟨fun _ _ h => by simpa using h⟩\n#align id_cover_lifting id_cover_lifting\n\n",
 "helper":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/-- A helper lemma for the following two lemmas. Basically stating that if the section `y : X ⟶ 𝒢(V)`\ncoincides with `x` on `G(V')` for all `G(V') ⊆ V ∈ S`, then `X ⟶ 𝒢(V) ⟶ ℱ(W)` is indeed the\nsection obtained in `get_sections`. That said, this is littered with some more categorical jargon\nin order to be applied in the following lemmas easier.\n-/\ntheorem helper {V} (f : «expr ⟶ » V U) (y : «expr ⟶ » X (((ran G.op).obj ℱ.val).obj (op V))) (W)\n    (H :\n      ∀ {V'} {fV : «expr ⟶ » (G.obj V') V} (hV),\n        «expr ≫ » y (((ran G.op).obj ℱ.val).map fV.op) = x («expr ≫ » fV f) hV) :\n    «expr ≫ » y (limit.π (Ran.diagram G.op ℱ.val (op V)) W) =\n      (gluedLimitCone hu ℱ hS hx).π.app ((StructuredArrow.map f.op).obj W) :=\n  by\n  dsimp only [glued_limit_cone_π_app]\n  apply get_section_is_unique hu ℱ hS hx ((structured_arrow.map f.op).obj W)\n  intro V' fV' hV'\n  dsimp only [Ran.adjunction, Ran.equiv, pulledback_family_apply]\n  erw [adjunction.adjunction_of_equiv_right_counit_app]\n  have :\n    «expr ≫ » y (((Ran G.op).obj ℱ.val).map («expr ≫ » (G.map fV') W.hom.unop).op) =\n      x («expr ≫ » (G.map fV') («expr ≫ » W.hom.unop f)) (by simpa only using hV') :=\n    by\n    convert H (show S («expr ≫ » («expr ≫ » (G.map fV') W.hom.unop) f) by simpa only [category.assoc] using hV') using 2\n    simp only [category.assoc]\n  simp only [Quiver.Hom.unop_op, Equiv.symm_symm, structured_arrow.map_obj_hom, unop_comp, Equiv.coe_fn_mk,\n    functor.comp_map, coyoneda_obj_map, category.assoc, ← this, op_comp, Ran_obj_map, nat_trans.id_app]\n  erw [category.id_comp, limit.pre_π]\n  congr\n  convert limit.w (Ran.diagram G.op ℱ.val (op V)) (structured_arrow.hom_mk' W fV'.op)\n  rw [structured_arrow.map_mk]\n  erw [category.comp_id]\n  simp only [Quiver.Hom.unop_op, functor.op_map, Quiver.Hom.op_unop]\n#align helper helper\n\n",
 "glued_section_is_unique":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/-- Verify that the amalgamation is indeed unique. -/\ntheorem glued_section_is_unique (y) (hy : x.is_amalgamation y) : y = gluedSection hu ℱ hS hx :=\n  by\n  unfold glued_section limit.lift\n  ext W\n  erw [limit.lift_π]\n  convert helper hu ℱ hS hx ((«expr𝟙») _) y W _\n  · simp only [op_id, structured_arrow.map_id]\n  · intro V' fV' hV'\n    convert hy fV' (by simpa only [category.comp_id] using hV')\n    erw [category.comp_id]\n#align glued_section_is_unique glued_section_is_unique\n\n",
 "glued_section_is_amalgamation":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/-- Verify that the `glued_section` is an amalgamation of `x`. -/\ntheorem glued_section_is_amalgamation : x.is_amalgamation (gluedSection hu ℱ hS hx) :=\n  by\n  intro V fV hV\n  ext W\n  simp only [functor.comp_map, limit.lift_pre, coyoneda_obj_map, Ran_obj_map, glued_section]\n  erw [limit.lift_π]\n  symm\n  convert helper hu ℱ hS hx _ (x fV hV) _ _ using 1\n  intro V' fV' hV'\n  convert hx fV' ((«expr𝟙») _) hV hV' (by rw [category.id_comp])\n  simp only [op_id, functor_to_types.map_id_apply]\n#align glued_section_is_amalgamation glued_section_is_amalgamation\n\n",
 "glued_limit_cone_π_app":
 "@[simp]\ntheorem glued_limit_cone_π_app (W) : (gluedLimitCone hu ℱ hS hx).π.app W = getSection hu ℱ hS hx W :=\n  rfl\n#align glued_limit_cone_π_app glued_limit_cone_π_app\n\n",
 "get_section_is_unique":
 "theorem get_section_is_unique (Y : StructuredArrow (op U) G.op) {y} (H : (pulledbackFamily ℱ S x Y).is_amalgamation y) :\n    y = getSection hu ℱ hS hx Y :=\n  by\n  apply is_sheaf_for.is_separated_for _ (pulledback_family ℱ S x Y)\n  · exact H\n  · apply get_section_is_amalgamation\n  · exact ℱ.2 X _ (hu.cover_lift (K.pullback_stable Y.hom.unop hS))\n#align get_section_is_unique get_section_is_unique\n\n",
 "get_section_is_amalgamation":
 "theorem get_section_is_amalgamation (Y : StructuredArrow (op U) G.op) :\n    (pulledbackFamily ℱ S x Y).is_amalgamation (getSection hu ℱ hS hx Y) :=\n  IsSheafFor.isAmalgamation _ _\n#align get_section_is_amalgamation get_section_is_amalgamation\n\n",
 "get_section_commute":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp]\ntheorem get_section_commute {Y Z : StructuredArrow (op U) G.op} (f : «expr ⟶ » Y Z) :\n    «expr ≫ » (getSection hu ℱ hS hx Y) (ℱ.val.map f.right) = getSection hu ℱ hS hx Z :=\n  by\n  apply get_section_is_unique\n  intro V' fV' hV'\n  have eq : Z.hom = «expr ≫ » Y.hom (G.map f.right.unop).op :=\n    by\n    convert f.w\n    erw [category.id_comp]\n  rw [Eq] at hV'\n  convert get_section_is_amalgamation hu ℱ hS hx Y («expr ≫ » fV' f.right.unop) _ using 1\n  · tidy\n  · simp only [Eq, Quiver.Hom.unop_op, pulledback_family_apply, functor.map_comp, unop_comp, category.assoc]\n  · change S («expr ≫ » (G.map _) Y.hom.unop)\n    simpa only [functor.map_comp, category.assoc] using hV'\n#align get_section_commute get_section_commute\n\n",
 "comp_cover_lifting":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/-- The composition of two cover-lifting functors are cover-lifting -/\ntheorem comp_cover_lifting {F : «expr ⥤ » C D} (hu : CoverLifting J K F) {G : «expr ⥤ » D E} (hv : CoverLifting K L G) :\n    CoverLifting J L («expr ⋙ » F G) :=\n  ⟨fun _ S h => hu.cover_lift (hv.cover_lift h)⟩\n#align comp_cover_lifting comp_cover_lifting\n\n",
 "Ran_is_sheaf_of_cover_lifting":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/-- If `G` is cover_lifting, then `Ran G.op` pushes sheaves to sheaves.\n\nThis result is basically https://stacks.math.columbia.edu/tag/00XK,\nbut without the condition that `C` or `D` has pullbacks.\n-/\ntheorem Ran_is_sheaf_of_cover_lifting {G : «expr ⥤ » C D} (hG : CoverLifting J K G) (ℱ : Sheaf J A) :\n    Presheaf.IsSheaf K ((ran G.op).obj ℱ.val) := by\n  intro X U S hS x hx\n  constructor; swap\n  · apply Ran_is_sheaf_of_cover_lifting.glued_section hG ℱ hS hx\n  constructor\n  · apply Ran_is_sheaf_of_cover_lifting.glued_section_is_amalgamation\n  · apply Ran_is_sheaf_of_cover_lifting.glued_section_is_unique\n#align Ran_is_sheaf_of_cover_lifting Ran_is_sheaf_of_cover_lifting\n\n"}