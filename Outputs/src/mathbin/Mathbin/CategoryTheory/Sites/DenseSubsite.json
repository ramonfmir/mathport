{"sheaf_hom_restrict_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/-- The constructed `sheaf_hom α` is equal to `α` when restricted onto `C`.\n-/\ntheorem sheaf_hom_restrict_eq (α : «expr ⟶ » («expr ⋙ » G.op ℱ) («expr ⋙ » G.op ℱ'.val)) :\n    whiskerLeft G.op (sheaf_hom H α) = α := by\n  ext X\n  apply yoneda.map_injective\n  ext U\n  erw [yoneda.image_preimage]\n  symm\n  change (show («expr ⋙ » ℱ'.val (coyoneda.obj (op (unop U)))).obj (op (G.obj (unop X))) from _) = _\n  apply sheaf_eq_amalgamation ℱ' (H.is_cover _)\n  intro Y f hf\n  conv_lhs => rw [← hf.some.fac]\n  simp only [pushforward_family, functor.comp_map, yoneda_map_app, coyoneda_obj_map, op_comp,\n    functor_to_types.map_comp_apply, hom_over_app, ← category.assoc]\n  congr 1\n  simp only [category.assoc]\n  congr 1\n  rw [← G.image_preimage hf.some.map]\n  symm\n  apply α.naturality (G.preimage hf.some.map).op\n  infer_instance\n#align sheaf_hom_restrict_eq sheaf_hom_restrict_eq\n\n",
 "sheaf_hom_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/-- If the pullback map is obtained via whiskering,\nthen the result `sheaf_hom (whisker_left G.op α)` is equal to `α`.\n-/\ntheorem sheaf_hom_eq (α : «expr ⟶ » ℱ ℱ'.val) : sheaf_hom H (whiskerLeft G.op α) = α :=\n  by\n  ext X\n  apply yoneda.map_injective\n  swap; · infer_instance\n  ext U\n  erw [yoneda.image_preimage]\n  symm\n  change (show («expr ⋙ » ℱ'.val (coyoneda.obj (op (unop U)))).obj (op (unop X)) from _) = _\n  apply sheaf_eq_amalgamation ℱ' (H.is_cover _)\n  intro Y f hf\n  conv_lhs => rw [← hf.some.fac]\n  dsimp\n  simp\n#align sheaf_hom_eq sheaf_hom_eq\n\n",
 "sheaf_eq_amalgamation":
 "theorem sheaf_eq_amalgamation (ℱ : Sheaf K A) {X : A} {U : D} {T : Sieve U} (hT) (x : FamilyOfElements _ T) (hx) (t)\n    (h : x.is_amalgamation t) : t = (ℱ.cond X T hT).amalgamate x hx :=\n  (ℱ.cond X T hT).is_separated_for x t _ h ((ℱ.cond X T hT).is_amalgamation hx)\n#align sheaf_eq_amalgamation sheaf_eq_amalgamation\n\n",
 "pushforward_family_compatible":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/-- (Implementation). The `pushforward_family` defined is compatible. -/\ntheorem pushforward_family_compatible {X} (x : ℱ.obj (op X)) : (pushforward_family H α x).compatible :=\n  by\n  intro Y₁ Y₂ Z g₁ g₂ f₁ f₂ h₁ h₂ e\n  apply H.ext\n  intro Y f\n  simp only [pushforward_family, ← functor_to_types.map_comp_apply, ← op_comp]\n  change\n    («expr ≫ » (ℱ.map _) («expr ≫ » (α.app (op _)) (ℱ'.val.map _))) _ =\n      («expr ≫ » (ℱ.map _) («expr ≫ » (α.app (op _)) (ℱ'.val.map _))) _\n  rw [← G.image_preimage («expr ≫ » f («expr ≫ » g₁ _))]\n  rw [← G.image_preimage («expr ≫ » f («expr ≫ » g₂ _))]\n  erw [← α.naturality (G.preimage _).op]\n  erw [← α.naturality (G.preimage _).op]\n  refine' congr_fun _ x\n  simp only [Quiver.Hom.unop_op, functor.comp_map, ← op_comp, ← category.assoc, functor.op_map, ← ℱ.map_comp,\n    G.image_preimage]\n  congr 3\n  simp [e]\n#align pushforward_family_compatible pushforward_family_compatible\n\n",
 "pushforward_family_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n@[simp]\ntheorem pushforward_family_apply {X} (x : ℱ.obj (op X)) {Y : C} (f : «expr ⟶ » (G.obj Y) X) :\n    pushforward_family H α x f (presieve.in_cover_by_image G f) = α.app (op Y) (ℱ.map f.op x) :=\n  by\n  unfold pushforward_family\n  refine' congr_fun _ x\n  rw [← G.image_preimage (Nonempty.some _ : presieve.cover_by_image_structure _ _).lift]\n  change «expr ≫ » (ℱ.map _) («expr ≫ » (α.app (op _)) (ℱ'.val.map _)) = «expr ≫ » (ℱ.map f.op) (α.app (op Y))\n  erw [← α.naturality (G.preimage _).op]\n  simp only [← functor.map_comp, ← category.assoc, functor.comp_map, G.image_preimage, G.op_map, Quiver.Hom.unop_op, ←\n    op_comp, presieve.cover_by_image_structure.fac]\n#align pushforward_family_apply pushforward_family_apply\n\n",
 "iso_of_restrict_iso":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/-- Given a full and cover-dense functor `G` and a natural transformation of sheaves `α : ℱ ⟶ ℱ'`,\nif the pullback of `α` along `G` is iso, then `α` is also iso.\n-/\ntheorem iso_of_restrict_iso {ℱ ℱ' : Sheaf K A} (α : «expr ⟶ » ℱ ℱ') (i : IsIso (whiskerLeft G.op α.val)) : IsIso α :=\n  by\n  convert is_iso.of_iso (sheaf_iso H (as_iso (whisker_left G.op α.val))) using 1\n  ext1\n  apply (sheaf_hom_eq _ _).symm\n#align iso_of_restrict_iso iso_of_restrict_iso\n\n",
 "in_cover_by_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/-\nCopyright (c) 2021 Andrew Yang. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Andrew Yang\n-/\ntheorem presieve.in_cover_by_image (G : «expr ⥤ » C D) {X : D} {Y : C} (f : «expr ⟶ » (G.obj Y) X) :\n    presieve.cover_by_image G X f :=\n  ⟨⟨Y, («expr𝟙») _, f, by simp⟩⟩\n#align presieve.in_cover_by_image presieve.in_cover_by_image\n\n",
 "functor_pullback_pushforward_covering":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem functor_pullback_pushforward_covering [Full G] (H : cover_dense K G) {X : C} (T : K (G.obj X)) :\n    (T.val.functor_pullback G).functor_pushforward G ∈ K (G.obj X) :=\n  by\n  refine' K.superset_covering _ (K.bind_covering T.property fun Y f Hf => H.is_cover Y)\n  rintro Y _ ⟨Z, _, f, hf, ⟨W, g, f', ⟨rfl⟩⟩, rfl⟩\n  use W; use G.preimage («expr ≫ » f' f); use g\n  constructor\n  · simpa using T.val.downward_closed hf f'\n  · simp\n#align functor_pullback_pushforward_covering functor_pullback_pushforward_covering\n\n",
 "ext":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n-- this is not marked with `@[ext]` because `H` can not be inferred from the type\ntheorem ext (H : cover_dense K G) (ℱ : SheafOfTypes K) (X : D) {s t : ℱ.val.obj (op X)}\n    (h : ∀ ⦃Y : C⦄ (f : «expr ⟶ » (G.obj Y) X), ℱ.val.map f.op s = ℱ.val.map f.op t) : s = t :=\n  by\n  apply (ℱ.cond (sieve.cover_by_image G X) (H.is_cover X)).is_separated_for.ext\n  rintro Y _ ⟨Z, f₁, f₂, ⟨rfl⟩⟩\n  simp [h f₂]\n#align ext ext\n\n",
 "compatible_preserving":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/-- A fully faithful cover-dense functor preserves compatible families. -/\ntheorem compatible_preserving [Faithful G] : CompatiblePreserving K G :=\n  by\n  constructor\n  intro ℱ Z T x hx Y₁ Y₂ X f₁ f₂ g₁ g₂ hg₁ hg₂ eq\n  apply H.ext\n  intro W i\n  simp only [← functor_to_types.map_comp_apply, ← op_comp]\n  rw [← G.image_preimage («expr ≫ » i f₁)]\n  rw [← G.image_preimage («expr ≫ » i f₂)]\n  apply hx\n  apply G.map_injective\n  simp [Eq]\n#align compatible_preserving compatible_preserving\n\n",
 "app_hom_valid_glue":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp]\ntheorem app_hom_valid_glue {X : D} {Y : C} (f : «expr ⟶ » (op X) (op (G.obj Y))) :\n    «expr ≫ » (app_hom H α X) (ℱ'.val.map f) = «expr ≫ » (ℱ.map f) (α.app (op Y)) :=\n  by\n  ext\n  apply app_hom_restrict\n#align app_hom_valid_glue app_hom_valid_glue\n\n",
 "app_hom_restrict":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n@[simp]\ntheorem app_hom_restrict {X : D} {Y : C} (f : «expr ⟶ » (op X) (op (G.obj Y))) (x) :\n    ℱ'.val.map f (app_hom H α X x) = α.app (op Y) (ℱ.map f x) :=\n  by\n  refine'\n    ((ℱ'.cond _ (H.is_cover X)).valid_glue (pushforward_family_compatible H α x) f.unop\n          (presieve.in_cover_by_image G f.unop)).trans\n      _\n  apply pushforward_family_apply\n#align app_hom_restrict app_hom_restrict\n\n"}