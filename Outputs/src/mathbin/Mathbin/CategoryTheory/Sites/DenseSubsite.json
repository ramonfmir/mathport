{"sheaf_hom_restrict_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‹™ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‹™ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‹™ Â» -/\n/-- The constructed `sheaf_hom Î±` is equal to `Î±` when restricted onto `C`.\n-/\ntheorem sheaf_hom_restrict_eq (Î± : Â«expr âŸ¶ Â» (Â«expr â‹™ Â» G.op â„±) (Â«expr â‹™ Â» G.op â„±'.val)) :\n    whiskerLeft G.op (sheaf_hom H Î±) = Î± := by\n  ext X\n  apply yoneda.map_injective\n  ext U\n  erw [yoneda.image_preimage]\n  symm\n  change (show (Â«expr â‹™ Â» â„±'.val (coyoneda.obj (op (unop U)))).obj (op (G.obj (unop X))) from _) = _\n  apply sheaf_eq_amalgamation â„±' (H.is_cover _)\n  intro Y f hf\n  conv_lhs => rw [â† hf.some.fac]\n  simp only [pushforward_family, functor.comp_map, yoneda_map_app, coyoneda_obj_map, op_comp,\n    functor_to_types.map_comp_apply, hom_over_app, â† category.assoc]\n  congr 1\n  simp only [category.assoc]\n  congr 1\n  rw [â† G.image_preimage hf.some.map]\n  symm\n  apply Î±.naturality (G.preimage hf.some.map).op\n  infer_instance\n#align sheaf_hom_restrict_eq sheaf_hom_restrict_eq\n\n",
 "sheaf_hom_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‹™ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/-- If the pullback map is obtained via whiskering,\nthen the result `sheaf_hom (whisker_left G.op Î±)` is equal to `Î±`.\n-/\ntheorem sheaf_hom_eq (Î± : Â«expr âŸ¶ Â» â„± â„±'.val) : sheaf_hom H (whiskerLeft G.op Î±) = Î± :=\n  by\n  ext X\n  apply yoneda.map_injective\n  swap; Â· infer_instance\n  ext U\n  erw [yoneda.image_preimage]\n  symm\n  change (show (Â«expr â‹™ Â» â„±'.val (coyoneda.obj (op (unop U)))).obj (op (unop X)) from _) = _\n  apply sheaf_eq_amalgamation â„±' (H.is_cover _)\n  intro Y f hf\n  conv_lhs => rw [â† hf.some.fac]\n  dsimp\n  simp\n#align sheaf_hom_eq sheaf_hom_eq\n\n",
 "sheaf_eq_amalgamation":
 "theorem sheaf_eq_amalgamation (â„± : Sheaf K A) {X : A} {U : D} {T : Sieve U} (hT) (x : FamilyOfElements _ T) (hx) (t)\n    (h : x.is_amalgamation t) : t = (â„±.cond X T hT).amalgamate x hx :=\n  (â„±.cond X T hT).is_separated_for x t _ h ((â„±.cond X T hT).is_amalgamation hx)\n#align sheaf_eq_amalgamation sheaf_eq_amalgamation\n\n",
 "pushforward_family_compatible":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/-- (Implementation). The `pushforward_family` defined is compatible. -/\ntheorem pushforward_family_compatible {X} (x : â„±.obj (op X)) : (pushforward_family H Î± x).compatible :=\n  by\n  intro Yâ‚ Yâ‚‚ Z gâ‚ gâ‚‚ fâ‚ fâ‚‚ hâ‚ hâ‚‚ e\n  apply H.ext\n  intro Y f\n  simp only [pushforward_family, â† functor_to_types.map_comp_apply, â† op_comp]\n  change\n    (Â«expr â‰« Â» (â„±.map _) (Â«expr â‰« Â» (Î±.app (op _)) (â„±'.val.map _))) _ =\n      (Â«expr â‰« Â» (â„±.map _) (Â«expr â‰« Â» (Î±.app (op _)) (â„±'.val.map _))) _\n  rw [â† G.image_preimage (Â«expr â‰« Â» f (Â«expr â‰« Â» gâ‚ _))]\n  rw [â† G.image_preimage (Â«expr â‰« Â» f (Â«expr â‰« Â» gâ‚‚ _))]\n  erw [â† Î±.naturality (G.preimage _).op]\n  erw [â† Î±.naturality (G.preimage _).op]\n  refine' congr_fun _ x\n  simp only [Quiver.Hom.unop_op, functor.comp_map, â† op_comp, â† category.assoc, functor.op_map, â† â„±.map_comp,\n    G.image_preimage]\n  congr 3\n  simp [e]\n#align pushforward_family_compatible pushforward_family_compatible\n\n",
 "pushforward_family_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n@[simp]\ntheorem pushforward_family_apply {X} (x : â„±.obj (op X)) {Y : C} (f : Â«expr âŸ¶ Â» (G.obj Y) X) :\n    pushforward_family H Î± x f (presieve.in_cover_by_image G f) = Î±.app (op Y) (â„±.map f.op x) :=\n  by\n  unfold pushforward_family\n  refine' congr_fun _ x\n  rw [â† G.image_preimage (Nonempty.some _ : presieve.cover_by_image_structure _ _).lift]\n  change Â«expr â‰« Â» (â„±.map _) (Â«expr â‰« Â» (Î±.app (op _)) (â„±'.val.map _)) = Â«expr â‰« Â» (â„±.map f.op) (Î±.app (op Y))\n  erw [â† Î±.naturality (G.preimage _).op]\n  simp only [â† functor.map_comp, â† category.assoc, functor.comp_map, G.image_preimage, G.op_map, Quiver.Hom.unop_op, â†\n    op_comp, presieve.cover_by_image_structure.fac]\n#align pushforward_family_apply pushforward_family_apply\n\n",
 "iso_of_restrict_iso":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/-- Given a full and cover-dense functor `G` and a natural transformation of sheaves `Î± : â„± âŸ¶ â„±'`,\nif the pullback of `Î±` along `G` is iso, then `Î±` is also iso.\n-/\ntheorem iso_of_restrict_iso {â„± â„±' : Sheaf K A} (Î± : Â«expr âŸ¶ Â» â„± â„±') (i : IsIso (whiskerLeft G.op Î±.val)) : IsIso Î± :=\n  by\n  convert is_iso.of_iso (sheaf_iso H (as_iso (whisker_left G.op Î±.val))) using 1\n  ext1\n  apply (sheaf_hom_eq _ _).symm\n#align iso_of_restrict_iso iso_of_restrict_iso\n\n",
 "in_cover_by_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/-\nCopyright (c) 2021 Andrew Yang. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Andrew Yang\n-/\ntheorem presieve.in_cover_by_image (G : Â«expr â¥¤ Â» C D) {X : D} {Y : C} (f : Â«expr âŸ¶ Â» (G.obj Y) X) :\n    presieve.cover_by_image G X f :=\n  âŸ¨âŸ¨Y, (Â«exprğŸ™Â») _, f, by simpâŸ©âŸ©\n#align presieve.in_cover_by_image presieve.in_cover_by_image\n\n",
 "functor_pullback_pushforward_covering":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\ntheorem functor_pullback_pushforward_covering [Full G] (H : cover_dense K G) {X : C} (T : K (G.obj X)) :\n    (T.val.functor_pullback G).functor_pushforward G âˆˆ K (G.obj X) :=\n  by\n  refine' K.superset_covering _ (K.bind_covering T.property fun Y f Hf => H.is_cover Y)\n  rintro Y _ âŸ¨Z, _, f, hf, âŸ¨W, g, f', âŸ¨rflâŸ©âŸ©, rflâŸ©\n  use W; use G.preimage (Â«expr â‰« Â» f' f); use g\n  constructor\n  Â· simpa using T.val.downward_closed hf f'\n  Â· simp\n#align functor_pullback_pushforward_covering functor_pullback_pushforward_covering\n\n",
 "ext":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n-- this is not marked with `@[ext]` because `H` can not be inferred from the type\ntheorem ext (H : cover_dense K G) (â„± : SheafOfTypes K) (X : D) {s t : â„±.val.obj (op X)}\n    (h : âˆ€ â¦ƒY : Câ¦„ (f : Â«expr âŸ¶ Â» (G.obj Y) X), â„±.val.map f.op s = â„±.val.map f.op t) : s = t :=\n  by\n  apply (â„±.cond (sieve.cover_by_image G X) (H.is_cover X)).is_separated_for.ext\n  rintro Y _ âŸ¨Z, fâ‚, fâ‚‚, âŸ¨rflâŸ©âŸ©\n  simp [h fâ‚‚]\n#align ext ext\n\n",
 "compatible_preserving":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/-- A fully faithful cover-dense functor preserves compatible families. -/\ntheorem compatible_preserving [Faithful G] : CompatiblePreserving K G :=\n  by\n  constructor\n  intro â„± Z T x hx Yâ‚ Yâ‚‚ X fâ‚ fâ‚‚ gâ‚ gâ‚‚ hgâ‚ hgâ‚‚ eq\n  apply H.ext\n  intro W i\n  simp only [â† functor_to_types.map_comp_apply, â† op_comp]\n  rw [â† G.image_preimage (Â«expr â‰« Â» i fâ‚)]\n  rw [â† G.image_preimage (Â«expr â‰« Â» i fâ‚‚)]\n  apply hx\n  apply G.map_injective\n  simp [Eq]\n#align compatible_preserving compatible_preserving\n\n",
 "app_hom_valid_glue":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n@[simp]\ntheorem app_hom_valid_glue {X : D} {Y : C} (f : Â«expr âŸ¶ Â» (op X) (op (G.obj Y))) :\n    Â«expr â‰« Â» (app_hom H Î± X) (â„±'.val.map f) = Â«expr â‰« Â» (â„±.map f) (Î±.app (op Y)) :=\n  by\n  ext\n  apply app_hom_restrict\n#align app_hom_valid_glue app_hom_valid_glue\n\n",
 "app_hom_restrict":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n@[simp]\ntheorem app_hom_restrict {X : D} {Y : C} (f : Â«expr âŸ¶ Â» (op X) (op (G.obj Y))) (x) :\n    â„±'.val.map f (app_hom H Î± X x) = Î±.app (op Y) (â„±.map f x) :=\n  by\n  refine'\n    ((â„±'.cond _ (H.is_cover X)).valid_glue (pushforward_family_compatible H Î± x) f.unop\n          (presieve.in_cover_by_image G f.unop)).trans\n      _\n  apply pushforward_family_apply\n#align app_hom_restrict app_hom_restrict\n\n"}