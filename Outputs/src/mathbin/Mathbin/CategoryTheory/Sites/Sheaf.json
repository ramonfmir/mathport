{"w":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem w : «expr ≫ » (forkMap R P) (firstMap R P) = «expr ≫ » (forkMap R P) (secondMap R P) :=\n  by\n  apply limit.hom_ext\n  rintro ⟨⟨Y, f, hf⟩, ⟨Z, g, hg⟩⟩\n  simp only [first_map, second_map, fork_map, limit.lift_π, limit.lift_π_assoc, assoc, fan.mk_π_app, Subtype.coe_mk,\n    subtype.val_eq_coe]\n  rw [← P.map_comp, ← op_comp, pullback.condition]\n  simp\n#align w w\n\n",
 "subsingleton_iff_is_separated_for":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵖ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/-- Given sieve `S` and presheaf `P : Cᵒᵖ ⥤ A`, their natural associated cone admits at most one\n    morphism from every cone in the same category (i.e. over the same diagram),\n    iff `Hom (E, P -)`is separated for the sieve `S` and all `E : A`. -/\ntheorem subsingleton_iff_is_separated_for :\n    (∀ c, subsingleton («expr ⟶ » c (P.map_cone S.arrows.cocone.op))) ↔\n      ∀ E : «expr ᵒᵖ» A, IsSeparatedFor («expr ⋙ » P (coyoneda.obj E)) S :=\n  by\n  constructor\n  · intro hs E x t₁ t₂ h₁ h₂\n    have hx := is_compatible_of_exists_amalgamation x ⟨t₁, h₁⟩\n    rw [compatible_iff_sieve_compatible] at hx\n    specialize hs hx.cone\n    cases hs\n    have := (hom_equiv_amalgamation hx).symm.injective\n    exact Subtype.ext_iff.1 (@this ⟨t₁, h₁⟩ ⟨t₂, h₂⟩ (hs _ _))\n  · rintro h ⟨E, π⟩\n    let eqv := cones_equiv_sieve_compatible_family P S (op E)\n    constructor\n    rw [← eqv.left_inv π]\n    intro f₁ f₂\n    let eqv' := hom_equiv_amalgamation (eqv π).2\n    apply eqv'.injective\n    ext\n    apply h _ (eqv π).1 <;> exact (eqv' _).2\n#align subsingleton_iff_is_separated_for subsingleton_iff_is_separated_for\n\n",
 "mono_of_presheaf_mono":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n-- Let's make the inhabited linter happy...\n/-- This is stated as a lemma to prevent class search from forming a loop since a sheaf morphism is\nmonic if and only if it is monic as a presheaf morphism (under suitable assumption).-/\ntheorem Sheaf.hom.mono_of_presheaf_mono {F G : Sheaf J A} (f : «expr ⟶ » F G) [h : Mono f.1] : Mono f :=\n  (sheafToPresheaf J A).mono_of_mono_map h\n#align Sheaf.hom.mono_of_presheaf_mono Sheaf.hom.mono_of_presheaf_mono\n\n",
 "is_sheaf_of_iso_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵖ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≅ » -/\ntheorem is_sheaf_of_iso_iff {P P' : «expr ⥤ » («expr ᵒᵖ» C) A} (e : «expr ≅ » P P') : IsSheaf J P ↔ IsSheaf J P' :=\n  forall_congr' fun a =>\n    ⟨Presieve.isSheaf_iso J (isoWhiskerRight e _), Presieve.isSheaf_iso J (isoWhiskerRight e.symm _)⟩\n#align is_sheaf_of_iso_iff is_sheaf_of_iso_iff\n\n",
 "is_sheaf_of_is_terminal":
 "theorem is_sheaf_of_is_terminal {X : A} (hX : IsTerminal X) :\n    Presheaf.IsSheaf J ((CategoryTheory.Functor.const _).obj X) := fun _ _ _ _ _ _ =>\n  ⟨hX.from _, fun _ _ _ => hX.hom_ext _ _, fun _ _ => hX.hom_ext _ _⟩\n#align is_sheaf_of_is_terminal is_sheaf_of_is_terminal\n\n",
 "is_sheaf_iff_multifork":
 "-- Under here is the equalizer story, which is equivalent if A has products (and doesn't\n-- make sense otherwise). It's described in https://stacks.math.columbia.edu/tag/00VL,\n-- between 00VQ and 00VR.\ntheorem is_sheaf_iff_multifork : IsSheaf J P ↔ ∀ (X : C) (S : J.cover X), Nonempty (IsLimit (S.multifork P)) :=\n  by\n  refine' ⟨fun hP X S => ⟨is_limit_of_is_sheaf _ _ _ hP⟩, _⟩\n  intro h E X S hS x hx\n  let T : J.cover X := ⟨S, hS⟩\n  obtain ⟨hh⟩ := h _ T\n  let K : multifork (T.index P) := multifork.of_ι _ E (fun I => x I.f I.hf) fun I => hx _ _ _ _ I.w\n  use hh.lift K\n  dsimp; constructor\n  · intro Y f hf\n    apply hh.fac K (walking_multicospan.left ⟨Y, f, hf⟩)\n  · intro e he\n    apply hh.uniq K\n    rintro (a | b)\n    · apply he\n    · rw [← K.w (walking_multicospan.hom.fst b), ← (T.multifork P).w (walking_multicospan.hom.fst b), ← assoc]\n      congr 1\n      apply he\n#align is_sheaf_iff_multifork is_sheaf_iff_multifork\n\n",
 "is_sheaf_iff_multiequalizer":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≅ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem is_sheaf_iff_multiequalizer [∀ (X : C) (S : J.cover X), HasMultiequalizer (S.index P)] :\n    IsSheaf J P ↔ ∀ (X : C) (S : J.cover X), IsIso (S.to_multiequalizer P) :=\n  by\n  rw [is_sheaf_iff_multifork]\n  refine' forall₂_congr fun X S => ⟨_, _⟩\n  · rintro ⟨h⟩\n    let e : «expr ≅ » (P.obj (op X)) (multiequalizer (S.index P)) := h.cone_point_unique_up_to_iso (limit.is_limit _)\n    exact (inferInstance : is_iso e.hom)\n  · intro h\n    refine' ⟨is_limit.of_iso_limit (limit.is_limit _) (cones.ext _ _)⟩\n    · apply (@as_iso _ _ _ _ _ h).symm\n    · intro a\n      symm\n      erw [is_iso.inv_comp_eq]\n      change _ = «expr ≫ » (limit.lift _ _) _\n      simp\n#align is_sheaf_iff_multiequalizer is_sheaf_iff_multiequalizer\n\n",
 "is_sheaf_iff_is_sheaf_of_type":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≪≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵖ» -/\ntheorem is_sheaf_iff_is_sheaf_of_type (P : «expr ⥤ » («expr ᵒᵖ» C) (Type w)) :\n    Presheaf.IsSheaf J P ↔ Presieve.IsSheaf J P := by\n  constructor\n  · intro hP\n    refine' presieve.is_sheaf_iso J _ (hP PUnit)\n    exact «expr ≪≫ » (iso_whisker_left _ coyoneda.punit_iso) P.right_unitor\n  · intro hP X Y S hS z hz\n    refine' ⟨fun x => (hP S hS).amalgamate (fun Z f hf => z f hf x) _, _, _⟩\n    · intro Y₁ Y₂ Z g₁ g₂ f₁ f₂ hf₁ hf₂ h\n      exact congr_fun (hz g₁ g₂ hf₁ hf₂ h) x\n    · intro Z f hf\n      ext x\n      apply presieve.is_sheaf_for.valid_glue\n    · intro y hy\n      ext x\n      apply (hP S hS).is_separated_for.ext\n      intro Y' f hf\n      rw [presieve.is_sheaf_for.valid_glue _ _ _ hf, ← hy _ hf]\n      rfl\n#align is_sheaf_iff_is_sheaf_of_type is_sheaf_iff_is_sheaf_of_type\n\n",
 "is_sheaf_iff_is_sheaf_forget":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/-- For a concrete category `(A, s)` where the forgetful functor `s : A ⥤ Type v` preserves limits and\nreflects isomorphisms, and `A` has limits, an `A`-valued presheaf `P : Cᵒᵖ ⥤ A` is a sheaf iff its\nunderlying `Type`-valued presheaf `P ⋙ s : Cᵒᵖ ⥤ Type` is a sheaf.\n\nNote this lemma applies for \"algebraic\" categories, eg groups, abelian groups and rings, but not\nfor the category of topological spaces, topological rings, etc since reflecting isomorphisms doesn't\nhold.\n-/\ntheorem is_sheaf_iff_is_sheaf_forget (s : «expr ⥤ » A (Type max v₁ u₁)) [HasLimits A] [PreservesLimits s]\n    [ReflectsIsomorphisms s] : IsSheaf J P ↔ IsSheaf J («expr ⋙ » P s) :=\n  by\n  rw [is_sheaf_iff_is_sheaf', is_sheaf_iff_is_sheaf']\n  apply forall_congr' fun U => _\n  apply ball_congr fun R hR => _\n  letI : reflects_limits s := reflects_limits_of_reflects_isomorphisms\n  have : «expr ≃ » (is_limit (s.map_cone (fork.of_ι _ (w R P)))) (is_limit (fork.of_ι _ (w R («expr ⋙ » P s)))) :=\n    is_sheaf_for_is_sheaf_for' P s U R\n  rw [← Equiv.nonempty_congr this]\n  constructor\n  · haveI := preserves_smallest_limits_of_preserves_limits s\n    exact Nonempty.map fun t => is_limit_of_preserves s t\n  · haveI := reflects_smallest_limits_of_reflects_limits s\n    exact Nonempty.map fun t => is_limit_of_reflects s t\n#align is_sheaf_iff_is_sheaf_forget is_sheaf_iff_is_sheaf_forget\n\n",
 "is_sheaf_iff_is_sheaf'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/-- The equalizer definition of a sheaf given by `is_sheaf'` is equivalent to `is_sheaf`. -/\ntheorem is_sheaf_iff_is_sheaf' : IsSheaf J P ↔ IsSheaf' J P :=\n  by\n  constructor\n  · intro h U R hR\n    refine' ⟨_⟩\n    apply coyoneda_jointly_reflects_limits\n    intro X\n    have q : presieve.is_sheaf_for («expr ⋙ » P (coyoneda.obj X)) _ := h X.unop _ hR\n    rw [← presieve.is_sheaf_for_iff_generate] at q\n    rw [equalizer.presieve.sheaf_condition] at q\n    replace q := Classical.choice q\n    apply (is_sheaf_for_is_sheaf_for' _ _ _ _).symm q\n  · intro h U X S hS\n    rw [equalizer.presieve.sheaf_condition]\n    refine' ⟨_⟩\n    refine' is_sheaf_for_is_sheaf_for' _ _ _ _ _\n    letI := preserves_smallest_limits_of_preserves_limits (coyoneda.obj (op U))\n    apply is_limit_of_preserves\n    apply Classical.choice (h _ S _)\n    simpa\n#align is_sheaf_iff_is_sheaf' is_sheaf_iff_is_sheaf'\n\n",
 "is_sheaf_iff_is_limit_pretopology":
 "/-- A presheaf `P` is a sheaf for the Grothendieck topology generated by a pretopology `K`\n    iff for every covering presieve `R` of `K`, the natural cone associated to `P` and\n    `sieve.generate R` is a limit cone. -/\ntheorem is_sheaf_iff_is_limit_pretopology [HasPullbacks C] (K : Pretopology C) :\n    IsSheaf (K.to_grothendieck C) P ↔\n      ∀ ⦃X : C⦄ (R : Presieve X), R ∈ K X → Nonempty (IsLimit (P.map_cone (generate R).arrows.cocone.op)) :=\n  by\n  dsimp [is_sheaf]\n  simp_rw [is_sheaf_pretopology]\n  exact\n    ⟨fun h X R hR => (is_limit_iff_is_sheaf_for_presieve P R).2 fun E => h E.unop R hR, fun h E X R hR =>\n      (is_limit_iff_is_sheaf_for_presieve P R).1 (h R hR) (op E)⟩\n#align is_sheaf_iff_is_limit_pretopology is_sheaf_iff_is_limit_pretopology\n\n",
 "is_sheaf_iff_is_limit":
 "/-- A presheaf `P` is a sheaf for the Grothendieck topology `J` iff for every covering sieve\n    `S` of `J`, the natural cone associated to `P` and `S` is a limit cone. -/\ntheorem is_sheaf_iff_is_limit :\n    IsSheaf J P ↔ ∀ ⦃X : C⦄ (S : Sieve X), S ∈ J X → Nonempty (IsLimit (P.map_cone S.arrows.cocone.op)) :=\n  ⟨fun h X S hS => (isLimit_iff_isSheafFor P S).2 fun E => h E.unop S hS, fun h E X S hS =>\n    (isLimit_iff_isSheafFor P S).1 (h S hS) (op E)⟩\n#align is_sheaf_iff_is_limit is_sheaf_iff_is_limit\n\n",
 "is_separated_iff_subsingleton":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/-- A presheaf `P` is separated for the Grothendieck topology `J` iff for every covering sieve\n    `S` of `J`, the natural cone associated to `P` and `S` admits at most one morphism from every\n    cone in the same category. -/\ntheorem is_separated_iff_subsingleton :\n    (∀ E : A, IsSeparated J («expr ⋙ » P (coyoneda.obj (op E)))) ↔\n      ∀ ⦃X : C⦄ (S : Sieve X), S ∈ J X → ∀ c, subsingleton («expr ⟶ » c (P.map_cone S.arrows.cocone.op)) :=\n  ⟨fun h X S hS => (subsingleton_iff_isSeparatedFor P S).2 fun E => h E.unop S hS, fun h E X S hS =>\n    (subsingleton_iff_isSeparatedFor P S).1 (h S hS) (op E)⟩\n#align is_separated_iff_subsingleton is_separated_iff_subsingleton\n\n",
 "is_limit_iff_is_sheaf_for_presieve":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵖ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/-- Given presieve `R` and presheaf `P : Cᵒᵖ ⥤ A`, the natural cone associated to `P` and\n    the sieve `sieve.generate R` generated by `R` is a limit cone iff `Hom (E, P -)` is a\n    sheaf of types for the presieve `R` and all `E : A`. -/\ntheorem is_limit_iff_is_sheaf_for_presieve :\n    Nonempty (IsLimit (P.map_cone (generate R).arrows.cocone.op)) ↔\n      ∀ E : «expr ᵒᵖ» A, IsSheafFor («expr ⋙ » P (coyoneda.obj E)) R :=\n  (isLimit_iff_isSheafFor P _).trans (forall_congr' fun _ => (isSheafFor_iff_generate _).symm)\n#align is_limit_iff_is_sheaf_for_presieve is_limit_iff_is_sheaf_for_presieve\n\n",
 "is_limit_iff_is_sheaf_for":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵖ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/-\nCopyright (c) 2020 Kevin Buzzard, Bhavik Mehta. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Kevin Buzzard, Bhavik Mehta\n-/\n-- We follow https://stacks.math.columbia.edu/tag/00VL definition 00VR\n/-- Given sieve `S` and presheaf `P : Cᵒᵖ ⥤ A`, their natural associated cone is a limit cone\n    iff `Hom (E, P -)` is a sheaf of types for the sieve `S` and all `E : A`. -/\ntheorem is_limit_iff_is_sheaf_for :\n    Nonempty (IsLimit (P.map_cone S.arrows.cocone.op)) ↔\n      ∀ E : «expr ᵒᵖ» A, IsSheafFor («expr ⋙ » P (coyoneda.obj E)) S :=\n  by\n  dsimp [is_sheaf_for]; simp_rw [compatible_iff_sieve_compatible]\n  rw [((cone.is_limit_equiv_is_terminal _).trans (is_terminal_equiv_unique _ _)).nonempty_congr]\n  rw [Classical.nonempty_pi]; constructor\n  · intro hu E x hx\n    specialize hu hx.cone\n    erw [(hom_equiv_amalgamation hx).unique_congr.nonempty_congr] at hu\n    exact (unique_subtype_iff_exists_unique _).1 hu\n  · rintro h ⟨E, π⟩\n    let eqv := cones_equiv_sieve_compatible_family P S (op E)\n    rw [← eqv.left_inv π]\n    erw [(hom_equiv_amalgamation (eqv π).2).unique_congr.nonempty_congr]\n    rw [unique_subtype_iff_exists_unique]\n    exact h _ _ (eqv π).2\n#align is_limit_iff_is_sheaf_for is_limit_iff_is_sheaf_for\n\n",
 "hom_ext":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵖ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem is_sheaf.hom_ext {A : Type u₂} [Category.{max v₁ u₁} A] {E : A} {X : C} {P : «expr ⥤ » («expr ᵒᵖ» C) A}\n    (hP : Presheaf.IsSheaf J P) (S : J.cover X) (e₁ e₂ : «expr ⟶ » E (P.obj (op X)))\n    (h : ∀ I : S.arrow, «expr ≫ » e₁ (P.map I.f.op) = «expr ≫ » e₂ (P.map I.f.op)) : e₁ = e₂ :=\n  (hP _ _ S.condition).is_separated_for.ext fun Y f hf => h ⟨Y, f, hf⟩\n#align is_sheaf.hom_ext is_sheaf.hom_ext\n\n",
 "amalgamate_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵖ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem is_sheaf.amalgamate_map {A : Type u₂} [Category.{max v₁ u₁} A] {E : A} {X : C} {P : «expr ⥤ » («expr ᵒᵖ» C) A}\n    (hP : Presheaf.IsSheaf J P) (S : J.cover X) (x : ∀ I : S.arrow, «expr ⟶ » E (P.obj (op I.Y)))\n    (hx : ∀ I : S.relation, «expr ≫ » (x I.fst) (P.map I.g₁.op) = «expr ≫ » (x I.snd) (P.map I.g₂.op)) (I : S.arrow) :\n    «expr ≫ » (hP.amalgamate S x hx) (P.map I.f.op) = x _ :=\n  by\n  rcases I with ⟨Y, f, hf⟩\n  apply\n    @presieve.is_sheaf_for.valid_glue _ _ _ _ _ _ (hP _ _ S.condition) (fun Y f hf => x ⟨Y, f, hf⟩)\n      (fun Y₁ Y₂ Z g₁ g₂ f₁ f₂ h₁ h₂ w => hx ⟨Y₁, Y₂, Z, g₁, g₂, f₁, f₂, h₁, h₂, w⟩) f hf\n#align is_sheaf.amalgamate_map is_sheaf.amalgamate_map\n\n",
 "add_app":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n@[simp]\ntheorem Sheaf.hom.add_app (f g : «expr ⟶ » P Q) (U) : (f + g).1.app U = f.1.app U + g.1.app U :=\n  rfl\n#align Sheaf.hom.add_app Sheaf.hom.add_app\n\n"}