{"trivial_eq_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¥Â» -/\n@[simp]\ntheorem trivial_eq_bot : trivial C = Â«exprâŠ¥Â» :=\n  rfl\n#align trivial_eq_bot trivial_eq_bot\n\n",
 "trivial_covering":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\ntheorem trivial_covering : S âˆˆ trivial C X â†” S = Â«exprâŠ¤Â» :=\n  Set.mem_singleton_iff\n#align trivial_covering trivial_covering\n\n",
 "transitive":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem transitive (hS : S âˆˆ J X) (R : sieve X) (h : âˆ€ â¦ƒYâ¦„ â¦ƒf : Â«expr âŸ¶ Â» Y Xâ¦„, S f â†’ R.pullback f âˆˆ J Y) : R âˆˆ J X :=\n  J.transitive' hS R h\n#align transitive transitive\n\n",
 "top_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\n-- Also known as the maximality axiom.\n@[simp]\ntheorem top_mem (X : C) : Â«exprâŠ¤Â» âˆˆ J X :=\n  J.top_mem' X\n#align top_mem top_mem\n\n",
 "top_covers":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\n@[simp]\ntheorem top_covers (S : sieve X) (f : Â«expr âŸ¶ Â» Y X) : (Â«exprâŠ¤Â» : grothendieck_topology C).covers S f := by\n  simp [covers_iff]\n#align top_covers top_covers\n\n",
 "top_covering":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\n@[simp]\ntheorem top_covering : S âˆˆ (Â«exprâŠ¤Â» : grothendieck_topology C) X :=\n  âŸ¨âŸ©\n#align top_covering top_covering\n\n",
 "to_middle_condition":
 "theorem arrow.to_middle_condition {X : C} {S : J.cover X} {T : âˆ€ I : S.arrow, J.cover I.Y} (I : (S.bind T).arrow) :\n    (T I.from_middle) I.to_middle_hom :=\n  I.hf.some_spec.some_spec.some_spec.some_spec.1\n#align arrow.to_middle_condition arrow.to_middle_condition\n\n",
 "superset_covering":
 "/-- If `S` is a subset of `R`, and `S` is covering, then `R` is covering as well.\n\nSee <https://stacks.math.columbia.edu/tag/00Z5> (2), or discussion after [MM92] Chapter III,\nSection 2, Definition 1.\n-/\ntheorem superset_covering (Hss : S â‰¤ R) (sjx : S âˆˆ J X) : R âˆˆ J X :=\n  by\n  apply J.transitive sjx R fun Y f hf => _\n  apply covering_of_eq_top\n  rw [â† top_le_iff, â† S.pullback_eq_top_of_mem hf]\n  apply sieve.pullback_monotone _ Hss\n#align superset_covering superset_covering\n\n",
 "right_ore_of_pullbacks":
 "theorem right_ore_of_pullbacks [limits.has_pullbacks C] : right_ore_condition C := fun X Y Z yx zx =>\n  âŸ¨_, _, _, limits.pullback.conditionâŸ©\n#align right_ore_of_pullbacks right_ore_of_pullbacks\n\n",
 "pullback_stable":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n-- Also known as the stability axiom.\n@[simp]\ntheorem pullback_stable (f : Â«expr âŸ¶ Â» Y X) (hS : S âˆˆ J X) : S.pullback f âˆˆ J Y :=\n  J.pullback_stable' f hS\n#align pullback_stable pullback_stable\n\n",
 "middle_spec":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\ntheorem arrow.middle_spec {X : C} {S : J.cover X} {T : âˆ€ I : S.arrow, J.cover I.Y} (I : (S.bind T).arrow) :\n    Â«expr â‰« Â» I.to_middle_hom I.from_middle_hom = I.f :=\n  I.hf.some_spec.some_spec.some_spec.some_spec.2\n#align arrow.middle_spec arrow.middle_spec\n\n",
 "mem_sieves_iff_coe":
 "@[simp]\ntheorem mem_sieves_iff_coe : S âˆˆ J.sieves X â†” S âˆˆ J X :=\n  iff.rfl\n#align mem_sieves_iff_coe mem_sieves_iff_coe\n\n",
 "map_snd":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n@[simp]\ntheorem relation.map_snd {S T : J.cover X} (I : S.relation) (f : Â«expr âŸ¶ Â» S T) : I.snd.map f = (I.map f).snd :=\n  rfl\n#align relation.map_snd relation.map_snd\n\n",
 "map_fst":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n@[simp]\ntheorem relation.map_fst {S T : J.cover X} (I : S.relation) (f : Â«expr âŸ¶ Â» S T) : I.fst.map f = (I.map f).fst :=\n  rfl\n#align relation.map_fst relation.map_fst\n\n",
 "le_def":
 "theorem le_def {Jâ‚ Jâ‚‚ : grothendieck_topology C} : Jâ‚ â‰¤ Jâ‚‚ â†” (Jâ‚ : âˆ€ X : C, set (sieve X)) â‰¤ Jâ‚‚ :=\n  iff.rfl\n#align le_def le_def\n\n",
 "isGLB_infâ‚›":
 "#print isGLB_infâ‚› /-\n/-- See <https://stacks.math.columbia.edu/tag/00Z7> -/\ntheorem isGLB_infâ‚› (s : set (grothendieck_topology C)) : IsGLB s (infâ‚› s) :=\n  by\n  refine' @IsGLB.of_image _ _ _ _ sieves _ _ _ _\n  Â· intros\n    rfl\n  Â· exact isGLB_infâ‚› _\n#align is_glb_Inf isGLB_infâ‚›\n-/\n\n",
 "intersection_covering_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŠ“ Â» -/\n@[simp]\ntheorem intersection_covering_iff : Â«expr âŠ“ Â» R S âˆˆ J X â†” R âˆˆ J X âˆ§ S âˆˆ J X :=\n  âŸ¨fun h => âŸ¨J.superset_covering inf_le_left h, J.superset_covering inf_le_right hâŸ©, fun t =>\n    intersection_covering _ t.1 t.2âŸ©\n#align intersection_covering_iff intersection_covering_iff\n\n",
 "intersection_covering":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŠ“ Â» -/\n/-- The intersection of two covering sieves is covering.\n\nSee <https://stacks.math.columbia.edu/tag/00Z5> (1), or [MM92] Chapter III,\nSection 2, Definition 1 (iv).\n-/\ntheorem intersection_covering (rj : R âˆˆ J X) (sj : S âˆˆ J X) : Â«expr âŠ“ Â» R S âˆˆ J X :=\n  by\n  apply J.transitive rj _ fun Y f Hf => _\n  rw [sieve.pullback_inter, R.pullback_eq_top_of_mem Hf]\n  simp [sj]\n#align intersection_covering intersection_covering\n\n",
 "from_middle_condition":
 "theorem arrow.from_middle_condition {X : C} {S : J.cover X} {T : âˆ€ I : S.arrow, J.cover I.Y} (I : (S.bind T).arrow) :\n    S I.from_middle_hom :=\n  I.hf.some_spec.some_spec.some_spec.some\n#align arrow.from_middle_condition arrow.from_middle_condition\n\n",
 "ext":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n@[ext]\ntheorem ext (S T : J.cover X) (h : âˆ€ â¦ƒYâ¦„ (f : Â«expr âŸ¶ Â» Y X), S f â†” T f) : S = T :=\n  subtype.ext <| sieve.ext h\n#align ext ext\n\n",
 "discrete_eq_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\n@[simp]\ntheorem discrete_eq_top : discrete C = Â«exprâŠ¤Â» :=\n  rfl\n#align discrete_eq_top discrete_eq_top\n\n",
 "dense_covering":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\ntheorem dense_covering : S âˆˆ dense X â†” âˆ€ {Y} (f : Â«expr âŸ¶ Â» Y X), âˆƒ (Z : _)(g : Â«expr âŸ¶ Â» Z Y), S (Â«expr â‰« Â» g f) :=\n  iff.rfl\n#align dense_covering dense_covering\n\n",
 "covers_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem covers_iff (S : sieve X) (f : Â«expr âŸ¶ Â» Y X) : J.covers S f â†” S.pullback f âˆˆ J Y :=\n  iff.rfl\n#align covers_iff covers_iff\n\n",
 "covering_of_eq_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\ntheorem covering_of_eq_top : S = Â«exprâŠ¤Â» â†’ S âˆˆ J X := fun h => h.symm â–¸ J.top_mem X\n#align covering_of_eq_top covering_of_eq_top\n\n",
 "covering_iff_covers_id":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\ntheorem covering_iff_covers_id (S : sieve X) : S âˆˆ J X â†” J.covers S ((Â«exprğŸ™Â») X) := by simp [covers_iff]\n#align covering_iff_covers_id covering_iff_covers_id\n\n",
 "condition":
 "theorem condition (S : J.cover X) : (S : sieve X) âˆˆ J X :=\n  S.2\n#align condition condition\n\n",
 "coe_pullback":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n@[simp]\ntheorem coe_pullback {Z : C} (f : Â«expr âŸ¶ Â» Y X) (g : Â«expr âŸ¶ Â» Z Y) (S : J.cover X) :\n    (S.pullback f) g â†” S (Â«expr â‰« Â» g f) :=\n  iff.rfl\n#align coe_pullback coe_pullback\n\n",
 "coe_fun_coe":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n@[simp]\ntheorem coe_fun_coe (S : J.cover X) (f : Â«expr âŸ¶ Â» Y X) : (S : sieve X) f = S f :=\n  rfl\n#align coe_fun_coe coe_fun_coe\n\n",
 "bot_covers":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¥Â» -/\ntheorem bot_covers (S : sieve X) (f : Â«expr âŸ¶ Â» Y X) : (Â«exprâŠ¥Â» : grothendieck_topology C).covers S f â†” S f := by\n  rw [covers_iff, bot_covering, â† sieve.pullback_eq_top_iff_mem]\n#align bot_covers bot_covers\n\n",
 "bot_covering":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¥Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\n@[simp]\ntheorem bot_covering : S âˆˆ (Â«exprâŠ¥Â» : grothendieck_topology C) X â†” S = Â«exprâŠ¤Â» :=\n  trivial_covering\n#align bot_covering bot_covering\n\n",
 "bind_covering":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem bind_covering {S : sieve X} {R : âˆ€ â¦ƒY : Câ¦„ â¦ƒf : Â«expr âŸ¶ Â» Y Xâ¦„, S f â†’ sieve Y} (hS : S âˆˆ J X)\n    (hR : âˆ€ â¦ƒYâ¦„ â¦ƒf : Â«expr âŸ¶ Â» Y Xâ¦„ (H : S f), R H âˆˆ J Y) : sieve.bind S R âˆˆ J X :=\n  J.transitive hS _ fun Y f hf => superset_covering J (sieve.le_pullback_bind S R f hf) (hR hf)\n#align bind_covering bind_covering\n\n",
 "base_snd":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n@[simp]\ntheorem relation.base_snd {f : Â«expr âŸ¶ Â» Y X} {S : J.cover X} (I : (S.pullback f).relation) : I.snd.base = I.base.snd :=\n  rfl\n#align relation.base_snd relation.base_snd\n\n",
 "base_fst":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n@[simp]\ntheorem relation.base_fst {f : Â«expr âŸ¶ Â» Y X} {S : J.cover X} (I : (S.pullback f).relation) : I.fst.base = I.base.fst :=\n  rfl\n#align relation.base_fst relation.base_fst\n\n",
 "arrow_trans":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/-- The transitivity axiom in 'arrow' form: If `S` covers `f` and every arrow in `S` is covered by\n`R`, then `R` covers `f`.\n-/\ntheorem arrow_trans (f : Â«expr âŸ¶ Â» Y X) (S R : sieve X) (h : J.covers S f) :\n    (âˆ€ {Z : C} (g : Â«expr âŸ¶ Â» Z X), S g â†’ J.covers R g) â†’ J.covers R f :=\n  by\n  intro k\n  apply J.transitive h\n  intro Z g hg\n  rw [â† sieve.pullback_comp]\n  apply k (Â«expr â‰« Â» g f) hg\n#align arrow_trans arrow_trans\n\n",
 "arrow_stable":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/-- The stability axiom in 'arrow' form: If `S` covers `f` then `S` covers `g â‰« f` for any `g`. -/\ntheorem arrow_stable (f : Â«expr âŸ¶ Â» Y X) (S : sieve X) (h : J.covers S f) {Z : C} (g : Â«expr âŸ¶ Â» Z Y) :\n    J.covers S (Â«expr â‰« Â» g f) := by\n  rw [covers_iff] at hâŠ¢\n  simp [h, sieve.pullback_comp]\n#align arrow_stable arrow_stable\n\n",
 "arrow_max":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/-- The maximality axiom in 'arrow' form: Any arrow `f` in `S` is covered by `S`. -/\ntheorem arrow_max (f : Â«expr âŸ¶ Â» Y X) (S : sieve X) (hf : S f) : J.covers S f :=\n  by\n  rw [covers, (sieve.pullback_eq_top_iff_mem f).1 hf]\n  apply J.top_mem\n#align arrow_max arrow_max\n\n",
 "arrow_intersect":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŠ“ Â» -/\ntheorem arrow_intersect (f : Â«expr âŸ¶ Â» Y X) (S R : sieve X) (hS : J.covers S f) (hR : J.covers R f) :\n    J.covers (Â«expr âŠ“ Â» S R) f := by simpa [covers_iff] using and.intro hS hR\n#align arrow_intersect arrow_intersect\n\n"}