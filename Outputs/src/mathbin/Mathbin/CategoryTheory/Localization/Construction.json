{"uniq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\ntheorem uniq (G₁ G₂ : «expr ⥤ » W.localization D) (h : «expr ⋙ » W.Q G₁ = «expr ⋙ » W.Q G₂) : G₁ = G₂ :=\n  by\n  suffices h' : «expr ⋙ » (quotient.functor _) G₁ = «expr ⋙ » (quotient.functor _) G₂\n  · refine' Functor.ext _ _\n    · rintro ⟨⟨X⟩⟩\n      apply functor.congr_obj h\n    · rintro ⟨⟨X⟩⟩ ⟨⟨Y⟩⟩ ⟨f⟩\n      apply functor.congr_hom h'\n  · refine' paths.ext_functor _ _\n    · ext X\n      cases X\n      apply functor.congr_obj h\n    · rintro ⟨X⟩ ⟨Y⟩ (f | ⟨w, hw⟩)\n      · simpa only using functor.congr_hom h f\n      · have hw : W.Q.map w = (Wiso w hw).hom := rfl\n        have hw' := functor.congr_hom h w\n        simp only [functor.comp_map, hw] at hw'\n        refine' functor.congr_inv_of_congr_hom _ _ _ _ _ hw'\n        all_goals apply functor.congr_obj h\n#align uniq uniq\n\n",
 "nat_trans_hcomp_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ◫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ◫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\ntheorem nat_trans_hcomp_injective {F G : «expr ⥤ » W.localization D} {τ₁ τ₂ : «expr ⟶ » F G}\n    (h : «expr ◫ » ((«expr𝟙») W.Q) τ₁ = «expr ◫ » ((«expr𝟙») W.Q) τ₂) : τ₁ = τ₂ :=\n  by\n  ext X\n  have eq := (obj_equiv W).right_inv X\n  simp only [obj_equiv] at eq\n  rw [← eq, ← nat_trans.id_hcomp_app, ← nat_trans.id_hcomp_app, h]\n#align nat_trans_hcomp_injective nat_trans_hcomp_injective\n\n",
 "nat_trans_extension_hcomp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ◫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n@[simp]\ntheorem nat_trans_extension_hcomp {F G : «expr ⥤ » W.localization D}\n    (τ : «expr ⟶ » («expr ⋙ » W.Q F) («expr ⋙ » W.Q G)) : «expr ◫ » ((«expr𝟙») W.Q) (nat_trans_extension τ) = τ :=\n  by\n  ext X\n  simp only [nat_trans.hcomp_app, nat_trans.id_app, G.map_id, comp_id, nat_trans_extension_app,\n    nat_trans_extension.app_eq]\n#align nat_trans_extension_hcomp nat_trans_extension_hcomp\n\n",
 "morphism_property_is_top'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≅ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/-- A `morphism_property` in `W.localization` is satisfied by all\nmorphisms in the localized category if it contains the image of the\nmorphisms in the original category, if is stable under composition\nand if the property is stable by passing to inverses. -/\ntheorem morphism_property_is_top' (P : morphism_property W.localization)\n    (hP₁ : ∀ ⦃X Y : C⦄ (f : «expr ⟶ » X Y), P (W.Q.map f))\n    (hP₂ : ∀ ⦃X Y : W.localization⦄ (e : «expr ≅ » X Y) (he : P e.hom), P e.inv) (hP₃ : P.stable_under_composition) :\n    P = «expr⊤» :=\n  morphism_property_is_top P hP₁ (fun X Y w hw => hP₂ _ (hP₁ w)) hP₃\n#align morphism_property_is_top' morphism_property_is_top'\n\n",
 "morphism_property_is_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/-- A `morphism_property` in `W.localization` is satisfied by all\nmorphisms in the localized category if it contains the image of the\nmorphisms in the original category, the inverses of the morphisms\nin `W` and if it is stable under composition -/\ntheorem morphism_property_is_top (P : morphism_property W.localization)\n    (hP₁ : ∀ ⦃X Y : C⦄ (f : «expr ⟶ » X Y), P (W.Q.map f))\n    (hP₂ : ∀ ⦃X Y : C⦄ (w : «expr ⟶ » X Y) (hw : W w), P (Winv w hw)) (hP₃ : P.stable_under_composition) :\n    P = «expr⊤» := by\n  ext (X Y f)\n  constructor\n  · intro hf\n    simp only [Pi.top_apply]\n  · intro hf\n    clear hf\n    let G : «expr ⥤ » _ W.localization := quotient.functor _\n    suffices\n      ∀ (X₁ X₂ : C) (p : «expr ⟶ » (localization.construction.ι_paths W X₁) (localization.construction.ι_paths W X₂)),\n        P (G.map p)\n      by\n      rcases X with ⟨⟨X⟩⟩\n      rcases Y with ⟨⟨Y⟩⟩\n      simpa only [functor.image_preimage] using this _ _ (G.preimage f)\n    intro X₁ X₂ p\n    induction' p with X₂ X₃ p g hp\n    · simpa only [Functor.map_id] using hP₁ ((«expr𝟙») X₁)\n    · cases X₂\n      cases X₃\n      let p' : «expr ⟶ » (ι_paths W X₁) (ι_paths W X₂) := p\n      rw [show p.cons g = «expr ≫ » p' (quiver.hom.to_path g) by rfl, G.map_comp]\n      refine' hP₃ _ _ hp _\n      rcases g with (g | ⟨g, hg⟩)\n      · apply hP₁\n      · apply hP₂\n#align morphism_property_is_top morphism_property_is_top\n\n",
 "fac":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n@[simp]\ntheorem fac : «expr ⋙ » W.Q (lift G hG) = G :=\n  functor.ext (fun X => rfl)\n    (by\n      intro X Y f\n      simp only [functor.comp_map, eq_to_hom_refl, comp_id, id_comp]\n      dsimp [lift, lift_to_path_category, morphism_property.Q]\n      rw [compose_path_to_path])\n#align fac fac\n\n",
 "app_eq":
 "@[simp]\ntheorem app_eq (X : C) : (app τ) (W.Q.obj X) = τ.app X := by simpa only [app, eq_to_hom_refl, comp_id, id_comp]\n#align app_eq app_eq\n\n",
 "Q_inverts":
 "/-\nCopyright (c) 2022 Joël Riou. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Joël Riou\n-/\ntheorem _root_.category_theory.morphism_property.Q_inverts : W.is_inverted_by W.Q := fun X Y w hw =>\n  IsIso.of_iso (localization.construction.Wiso w hw)\n#align category_theory.morphism_property.Q_inverts category_theory.morphism_property.Q_inverts\n\n"}