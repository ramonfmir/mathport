{"uniq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‹™ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‹™ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‹™ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‹™ Â» -/\ntheorem uniq (Gâ‚ Gâ‚‚ : Â«expr â¥¤ Â» W.localization D) (h : Â«expr â‹™ Â» W.Q Gâ‚ = Â«expr â‹™ Â» W.Q Gâ‚‚) : Gâ‚ = Gâ‚‚ :=\n  by\n  suffices h' : Â«expr â‹™ Â» (quotient.functor _) Gâ‚ = Â«expr â‹™ Â» (quotient.functor _) Gâ‚‚\n  Â· refine' Functor.ext _ _\n    Â· rintro âŸ¨âŸ¨XâŸ©âŸ©\n      apply functor.congr_obj h\n    Â· rintro âŸ¨âŸ¨XâŸ©âŸ© âŸ¨âŸ¨YâŸ©âŸ© âŸ¨fâŸ©\n      apply functor.congr_hom h'\n  Â· refine' paths.ext_functor _ _\n    Â· ext X\n      cases X\n      apply functor.congr_obj h\n    Â· rintro âŸ¨XâŸ© âŸ¨YâŸ© (f | âŸ¨w, hwâŸ©)\n      Â· simpa only using functor.congr_hom h f\n      Â· have hw : W.Q.map w = (Wiso w hw).hom := rfl\n        have hw' := functor.congr_hom h w\n        simp only [functor.comp_map, hw] at hw'\n        refine' functor.congr_inv_of_congr_hom _ _ _ _ _ hw'\n        all_goals apply functor.congr_obj h\n#align uniq uniq\n\n",
 "nat_trans_hcomp_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â—« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprðŸ™Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â—« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprðŸ™Â» -/\ntheorem nat_trans_hcomp_injective {F G : Â«expr â¥¤ Â» W.localization D} {Ï„â‚ Ï„â‚‚ : Â«expr âŸ¶ Â» F G}\n    (h : Â«expr â—« Â» ((Â«exprðŸ™Â») W.Q) Ï„â‚ = Â«expr â—« Â» ((Â«exprðŸ™Â») W.Q) Ï„â‚‚) : Ï„â‚ = Ï„â‚‚ :=\n  by\n  ext X\n  have eq := (obj_equiv W).right_inv X\n  simp only [obj_equiv] at eq\n  rw [â† eq, â† nat_trans.id_hcomp_app, â† nat_trans.id_hcomp_app, h]\n#align nat_trans_hcomp_injective nat_trans_hcomp_injective\n\n",
 "nat_trans_extension_hcomp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‹™ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‹™ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â—« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprðŸ™Â» -/\n@[simp]\ntheorem nat_trans_extension_hcomp {F G : Â«expr â¥¤ Â» W.localization D}\n    (Ï„ : Â«expr âŸ¶ Â» (Â«expr â‹™ Â» W.Q F) (Â«expr â‹™ Â» W.Q G)) : Â«expr â—« Â» ((Â«exprðŸ™Â») W.Q) (nat_trans_extension Ï„) = Ï„ :=\n  by\n  ext X\n  simp only [nat_trans.hcomp_app, nat_trans.id_app, G.map_id, comp_id, nat_trans_extension_app,\n    nat_trans_extension.app_eq]\n#align nat_trans_extension_hcomp nat_trans_extension_hcomp\n\n",
 "morphism_property_is_top'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰… Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\n/-- A `morphism_property` in `W.localization` is satisfied by all\nmorphisms in the localized category if it contains the image of the\nmorphisms in the original category, if is stable under composition\nand if the property is stable by passing to inverses. -/\ntheorem morphism_property_is_top' (P : morphism_property W.localization)\n    (hPâ‚ : âˆ€ â¦ƒX Y : Câ¦„ (f : Â«expr âŸ¶ Â» X Y), P (W.Q.map f))\n    (hPâ‚‚ : âˆ€ â¦ƒX Y : W.localizationâ¦„ (e : Â«expr â‰… Â» X Y) (he : P e.hom), P e.inv) (hPâ‚ƒ : P.stable_under_composition) :\n    P = Â«exprâŠ¤Â» :=\n  morphism_property_is_top P hPâ‚ (fun X Y w hw => hPâ‚‚ _ (hPâ‚ w)) hPâ‚ƒ\n#align morphism_property_is_top' morphism_property_is_top'\n\n",
 "morphism_property_is_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprðŸ™Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\n/-- A `morphism_property` in `W.localization` is satisfied by all\nmorphisms in the localized category if it contains the image of the\nmorphisms in the original category, the inverses of the morphisms\nin `W` and if it is stable under composition -/\ntheorem morphism_property_is_top (P : morphism_property W.localization)\n    (hPâ‚ : âˆ€ â¦ƒX Y : Câ¦„ (f : Â«expr âŸ¶ Â» X Y), P (W.Q.map f))\n    (hPâ‚‚ : âˆ€ â¦ƒX Y : Câ¦„ (w : Â«expr âŸ¶ Â» X Y) (hw : W w), P (Winv w hw)) (hPâ‚ƒ : P.stable_under_composition) :\n    P = Â«exprâŠ¤Â» := by\n  ext (X Y f)\n  constructor\n  Â· intro hf\n    simp only [Pi.top_apply]\n  Â· intro hf\n    clear hf\n    let G : Â«expr â¥¤ Â» _ W.localization := quotient.functor _\n    suffices\n      âˆ€ (Xâ‚ Xâ‚‚ : C) (p : Â«expr âŸ¶ Â» (localization.construction.Î¹_paths W Xâ‚) (localization.construction.Î¹_paths W Xâ‚‚)),\n        P (G.map p)\n      by\n      rcases X with âŸ¨âŸ¨XâŸ©âŸ©\n      rcases Y with âŸ¨âŸ¨YâŸ©âŸ©\n      simpa only [functor.image_preimage] using this _ _ (G.preimage f)\n    intro Xâ‚ Xâ‚‚ p\n    induction' p with Xâ‚‚ Xâ‚ƒ p g hp\n    Â· simpa only [Functor.map_id] using hPâ‚ ((Â«exprðŸ™Â») Xâ‚)\n    Â· cases Xâ‚‚\n      cases Xâ‚ƒ\n      let p' : Â«expr âŸ¶ Â» (Î¹_paths W Xâ‚) (Î¹_paths W Xâ‚‚) := p\n      rw [show p.cons g = Â«expr â‰« Â» p' (quiver.hom.to_path g) by rfl, G.map_comp]\n      refine' hPâ‚ƒ _ _ hp _\n      rcases g with (g | âŸ¨g, hgâŸ©)\n      Â· apply hPâ‚\n      Â· apply hPâ‚‚\n#align morphism_property_is_top morphism_property_is_top\n\n",
 "fac":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‹™ Â» -/\n@[simp]\ntheorem fac : Â«expr â‹™ Â» W.Q (lift G hG) = G :=\n  functor.ext (fun X => rfl)\n    (by\n      intro X Y f\n      simp only [functor.comp_map, eq_to_hom_refl, comp_id, id_comp]\n      dsimp [lift, lift_to_path_category, morphism_property.Q]\n      rw [compose_path_to_path])\n#align fac fac\n\n",
 "app_eq":
 "@[simp]\ntheorem app_eq (X : C) : (app Ï„) (W.Q.obj X) = Ï„.app X := by simpa only [app, eq_to_hom_refl, comp_id, id_comp]\n#align app_eq app_eq\n\n",
 "Q_inverts":
 "/-\nCopyright (c) 2022 JoÃ«l Riou. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: JoÃ«l Riou\n-/\ntheorem _root_.category_theory.morphism_property.Q_inverts : W.is_inverted_by W.Q := fun X Y w hw =>\n  IsIso.of_iso (localization.construction.Wiso w hw)\n#align category_theory.morphism_property.Q_inverts category_theory.morphism_property.Q_inverts\n\n"}