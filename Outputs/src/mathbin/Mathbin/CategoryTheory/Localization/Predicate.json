{"whiskering_left_functor'_obj":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n@[simp]\ntheorem whiskering_left_functor'_obj (F : «expr ⥤ » D E) : (whiskering_left_functor' L W E).obj F = «expr ⋙ » L F :=\n  rfl\n#align whiskering_left_functor'_obj whiskering_left_functor'_obj\n\n",
 "whiskering_left_functor'_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\ntheorem whiskering_left_functor'_eq :\n    whiskering_left_functor' L W E = «expr ⋙ » (localization.whiskering_left_functor L W E) (inducedFunctor _) :=\n  rfl\n#align whiskering_left_functor'_eq whiskering_left_functor'_eq\n\n",
 "of_iso":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≅ » -/\ntheorem of_iso {L₁ L₂ : «expr ⥤ » C D} (e : «expr ≅ » L₁ L₂) [L₁.is_localization W] : L₂.is_localization W :=\n  by\n  have h := localization.inverts L₁ W\n  rw [morphism_property.is_inverted_by.iff_of_iso W e] at h\n  let F₁ := localization.construction.lift L₁ (localization.inverts L₁ W)\n  let F₂ := localization.construction.lift L₂ h\n  exact\n    { inverts := h\n      nonempty_is_equivalence :=\n        nonempty.intro (is_equivalence.of_iso (lift_nat_iso W.Q W L₁ L₂ F₁ F₂ e) infer_instance) }\n#align of_iso of_iso\n\n",
 "of_equivalence_target":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≅ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≌ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≅ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/-- If `L : C ⥤ D` is a localization for `W : morphism_property C`, then it is also\nthe case of a functor obtained by post-composing `L` with an equivalence of categories. -/\ntheorem of_equivalence_target {E : Type _} [Category E] (L' : «expr ⥤ » C E) (eq : «expr ≌ » D E) [L.is_localization W]\n    (e : «expr ≅ » («expr ⋙ » L eq.functor) L') : L'.is_localization W :=\n  by\n  have h : W.is_inverted_by L' :=\n    by\n    rw [← morphism_property.is_inverted_by.iff_of_iso W e]\n    exact morphism_property.is_inverted_by.of_comp W L (localization.inverts L W) eq.functor\n  let F₁ := localization.construction.lift L (localization.inverts L W)\n  let F₂ := localization.construction.lift L' h\n  let e' : «expr ≅ » («expr ⋙ » F₁ eq.functor) F₂ := lift_nat_iso W.Q W («expr ⋙ » L eq.functor) L' _ _ e\n  exact\n    { inverts := h\n      nonempty_is_equivalence := nonempty.intro (is_equivalence.of_iso e' infer_instance) }\n#align of_equivalence_target of_equivalence_target\n\n",
 "nat_trans_ext":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem nat_trans_ext {F₁ F₂ : «expr ⥤ » D E} (τ τ' : «expr ⟶ » F₁ F₂)\n    (h : ∀ X : C, τ.app (L.obj X) = τ'.app (L.obj X)) : τ = τ' :=\n  by\n  haveI : CategoryTheory.EssSurj L := ess_surj L W\n  ext Y\n  rw [← cancel_epi (F₁.map (L.obj_obj_preimage_iso Y).hom), τ.naturality, τ'.naturality, h]\n#align nat_trans_ext nat_trans_ext\n\n",
 "mk'":
 "/-\nCopyright (c) 2022 Joël Riou. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Joël Riou\n-/\ntheorem is_localization.mk' (h₁ : localization.strict_universal_property_fixed_target L W D)\n    (h₂ : localization.strict_universal_property_fixed_target L W W.localization) : is_localization L W :=\n  { inverts := h₁.inverts\n    nonempty_is_equivalence :=\n      nonempty.intro\n        { inverse := h₂.lift W.Q W.Q_inverts\n          unit_iso :=\n            eq_to_iso\n              (localization.construction.uniq _ _\n                (by simp only [← functor.assoc, localization.construction.fac, h₂.fac, functor.comp_id]))\n          counit_iso :=\n            eq_to_iso\n              (h₁.uniq _ _ (by simp only [← functor.assoc, h₂.fac, localization.construction.fac, functor.comp_id]))\n          functor_unit_iso_comp' := fun X => by\n            simpa only [eq_to_iso.hom, eq_to_hom_app, eq_to_hom_map, eq_to_hom_trans, eq_to_hom_refl] } }\n#align is_localization.mk' is_localization.mk'\n\n",
 "lift_nat_trans_id":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n@[simp]\ntheorem lift_nat_trans_id (F : «expr ⥤ » C E) (F' : «expr ⥤ » D E) [h : lifting L W F F'] :\n    lift_nat_trans L W F F F' F' ((«expr𝟙») F) = («expr𝟙») F' :=\n  nat_trans_ext L W _ _ fun X => by simpa only [lift_nat_trans_app, nat_trans.id_app, id_comp, iso.hom_inv_id_app]\n#align lift_nat_trans_id lift_nat_trans_id\n\n",
 "lift_nat_trans_app":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp]\ntheorem lift_nat_trans_app (F₁ F₂ : «expr ⥤ » C E) (F₁' F₂' : «expr ⥤ » D E) [lifting L W F₁ F₁'] [lifting L W F₂ F₂']\n    (τ : «expr ⟶ » F₁ F₂) (X : C) :\n    (lift_nat_trans L W F₁ F₂ F₁' F₂' τ).app (L.obj X) =\n      «expr ≫ » ((lifting.iso L W F₁ F₁').hom.app X) («expr ≫ » (τ.app X) ((lifting.iso L W F₂ F₂').inv.app X)) :=\n  congr_app (Functor.image_preimage (whiskering_left_functor' L W E) _) X\n#align lift_nat_trans_app lift_nat_trans_app\n\n",
 "inverts":
 "theorem inverts : W.is_inverted_by L :=\n  (infer_instance : L.is_localization W).inverts\n#align inverts inverts\n\n",
 "for_id":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟭» -/\ntheorem is_localization.for_id (hW : W ⊆ morphism_property.isomorphisms C) : ((«expr𝟭») C).is_localization W :=\n  is_localization.mk' _ _ (localization.strict_universal_property_fixed_target_id W _ hW)\n    (localization.strict_universal_property_fixed_target_id W _ hW)\n#align is_localization.for_id is_localization.for_id\n\n",
 "ess_surj":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≪≫ » -/\ntheorem ess_surj : EssSurj L :=\n  ⟨fun X =>\n    ⟨(construction.obj_equiv W).inv_fun ((equivalence_from_model L W).inverse.obj X),\n      nonempty.intro\n        («expr ≪≫ » ((Q_comp_equivalence_from_model_functor_iso L W).symm.app _)\n          ((equivalence_from_model L W).counit_iso.app X))⟩⟩\n#align ess_surj ess_surj\n\n",
 "comp_lift_nat_trans":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem comp_lift_nat_trans (F₁ F₂ F₃ : «expr ⥤ » C E) (F₁' F₂' F₃' : «expr ⥤ » D E) [h₁ : lifting L W F₁ F₁']\n    [h₂ : lifting L W F₂ F₂'] [h₃ : lifting L W F₃ F₃'] (τ : «expr ⟶ » F₁ F₂) (τ' : «expr ⟶ » F₂ F₃) :\n    «expr ≫ » (lift_nat_trans L W F₁ F₂ F₁' F₂' τ) (lift_nat_trans L W F₂ F₃ F₂' F₃' τ') =\n      lift_nat_trans L W F₁ F₃ F₁' F₃' («expr ≫ » τ τ') :=\n  nat_trans_ext L W _ _ fun X => by simp only [nat_trans.comp_app, lift_nat_trans_app, assoc, iso.inv_hom_id_app_assoc]\n#align comp_lift_nat_trans comp_lift_nat_trans\n\n"}