{"whiskering_left_functor'_obj":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‹™ Â» -/\n@[simp]\ntheorem whiskering_left_functor'_obj (F : Â«expr â¥¤ Â» D E) : (whiskering_left_functor' L W E).obj F = Â«expr â‹™ Â» L F :=\n  rfl\n#align whiskering_left_functor'_obj whiskering_left_functor'_obj\n\n",
 "whiskering_left_functor'_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‹™ Â» -/\ntheorem whiskering_left_functor'_eq :\n    whiskering_left_functor' L W E = Â«expr â‹™ Â» (localization.whiskering_left_functor L W E) (inducedFunctor _) :=\n  rfl\n#align whiskering_left_functor'_eq whiskering_left_functor'_eq\n\n",
 "of_iso":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰… Â» -/\ntheorem of_iso {Lâ‚ Lâ‚‚ : Â«expr â¥¤ Â» C D} (e : Â«expr â‰… Â» Lâ‚ Lâ‚‚) [Lâ‚.is_localization W] : Lâ‚‚.is_localization W :=\n  by\n  have h := localization.inverts Lâ‚ W\n  rw [morphism_property.is_inverted_by.iff_of_iso W e] at h\n  let Fâ‚ := localization.construction.lift Lâ‚ (localization.inverts Lâ‚ W)\n  let Fâ‚‚ := localization.construction.lift Lâ‚‚ h\n  exact\n    { inverts := h\n      nonempty_is_equivalence :=\n        nonempty.intro (is_equivalence.of_iso (lift_nat_iso W.Q W Lâ‚ Lâ‚‚ Fâ‚ Fâ‚‚ e) infer_instance) }\n#align of_iso of_iso\n\n",
 "of_equivalence_target":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰… Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‹™ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‹™ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰Œ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰… Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‹™ Â» -/\n/-- If `L : C â¥¤ D` is a localization for `W : morphism_property C`, then it is also\nthe case of a functor obtained by post-composing `L` with an equivalence of categories. -/\ntheorem of_equivalence_target {E : Type _} [Category E] (L' : Â«expr â¥¤ Â» C E) (eq : Â«expr â‰Œ Â» D E) [L.is_localization W]\n    (e : Â«expr â‰… Â» (Â«expr â‹™ Â» L eq.functor) L') : L'.is_localization W :=\n  by\n  have h : W.is_inverted_by L' :=\n    by\n    rw [â† morphism_property.is_inverted_by.iff_of_iso W e]\n    exact morphism_property.is_inverted_by.of_comp W L (localization.inverts L W) eq.functor\n  let Fâ‚ := localization.construction.lift L (localization.inverts L W)\n  let Fâ‚‚ := localization.construction.lift L' h\n  let e' : Â«expr â‰… Â» (Â«expr â‹™ Â» Fâ‚ eq.functor) Fâ‚‚ := lift_nat_iso W.Q W (Â«expr â‹™ Â» L eq.functor) L' _ _ e\n  exact\n    { inverts := h\n      nonempty_is_equivalence := nonempty.intro (is_equivalence.of_iso e' infer_instance) }\n#align of_equivalence_target of_equivalence_target\n\n",
 "nat_trans_ext":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem nat_trans_ext {Fâ‚ Fâ‚‚ : Â«expr â¥¤ Â» D E} (Ï„ Ï„' : Â«expr âŸ¶ Â» Fâ‚ Fâ‚‚)\n    (h : âˆ€ X : C, Ï„.app (L.obj X) = Ï„'.app (L.obj X)) : Ï„ = Ï„' :=\n  by\n  haveI : CategoryTheory.EssSurj L := ess_surj L W\n  ext Y\n  rw [â† cancel_epi (Fâ‚.map (L.obj_obj_preimage_iso Y).hom), Ï„.naturality, Ï„'.naturality, h]\n#align nat_trans_ext nat_trans_ext\n\n",
 "mk'":
 "/-\nCopyright (c) 2022 JoÃ«l Riou. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: JoÃ«l Riou\n-/\ntheorem is_localization.mk' (hâ‚ : localization.strict_universal_property_fixed_target L W D)\n    (hâ‚‚ : localization.strict_universal_property_fixed_target L W W.localization) : is_localization L W :=\n  { inverts := hâ‚.inverts\n    nonempty_is_equivalence :=\n      nonempty.intro\n        { inverse := hâ‚‚.lift W.Q W.Q_inverts\n          unit_iso :=\n            eq_to_iso\n              (localization.construction.uniq _ _\n                (by simp only [â† functor.assoc, localization.construction.fac, hâ‚‚.fac, functor.comp_id]))\n          counit_iso :=\n            eq_to_iso\n              (hâ‚.uniq _ _ (by simp only [â† functor.assoc, hâ‚‚.fac, localization.construction.fac, functor.comp_id]))\n          functor_unit_iso_comp' := fun X => by\n            simpa only [eq_to_iso.hom, eq_to_hom_app, eq_to_hom_map, eq_to_hom_trans, eq_to_hom_refl] } }\n#align is_localization.mk' is_localization.mk'\n\n",
 "lift_nat_trans_id":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n@[simp]\ntheorem lift_nat_trans_id (F : Â«expr â¥¤ Â» C E) (F' : Â«expr â¥¤ Â» D E) [h : lifting L W F F'] :\n    lift_nat_trans L W F F F' F' ((Â«exprğŸ™Â») F) = (Â«exprğŸ™Â») F' :=\n  nat_trans_ext L W _ _ fun X => by simpa only [lift_nat_trans_app, nat_trans.id_app, id_comp, iso.hom_inv_id_app]\n#align lift_nat_trans_id lift_nat_trans_id\n\n",
 "lift_nat_trans_app":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n@[simp]\ntheorem lift_nat_trans_app (Fâ‚ Fâ‚‚ : Â«expr â¥¤ Â» C E) (Fâ‚' Fâ‚‚' : Â«expr â¥¤ Â» D E) [lifting L W Fâ‚ Fâ‚'] [lifting L W Fâ‚‚ Fâ‚‚']\n    (Ï„ : Â«expr âŸ¶ Â» Fâ‚ Fâ‚‚) (X : C) :\n    (lift_nat_trans L W Fâ‚ Fâ‚‚ Fâ‚' Fâ‚‚' Ï„).app (L.obj X) =\n      Â«expr â‰« Â» ((lifting.iso L W Fâ‚ Fâ‚').hom.app X) (Â«expr â‰« Â» (Ï„.app X) ((lifting.iso L W Fâ‚‚ Fâ‚‚').inv.app X)) :=\n  congr_app (Functor.image_preimage (whiskering_left_functor' L W E) _) X\n#align lift_nat_trans_app lift_nat_trans_app\n\n",
 "inverts":
 "theorem inverts : W.is_inverted_by L :=\n  (infer_instance : L.is_localization W).inverts\n#align inverts inverts\n\n",
 "for_id":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ­Â» -/\ntheorem is_localization.for_id (hW : W âŠ† morphism_property.isomorphisms C) : ((Â«exprğŸ­Â») C).is_localization W :=\n  is_localization.mk' _ _ (localization.strict_universal_property_fixed_target_id W _ hW)\n    (localization.strict_universal_property_fixed_target_id W _ hW)\n#align is_localization.for_id is_localization.for_id\n\n",
 "ess_surj":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰ªâ‰« Â» -/\ntheorem ess_surj : EssSurj L :=\n  âŸ¨fun X =>\n    âŸ¨(construction.obj_equiv W).inv_fun ((equivalence_from_model L W).inverse.obj X),\n      nonempty.intro\n        (Â«expr â‰ªâ‰« Â» ((Q_comp_equivalence_from_model_functor_iso L W).symm.app _)\n          ((equivalence_from_model L W).counit_iso.app X))âŸ©âŸ©\n#align ess_surj ess_surj\n\n",
 "comp_lift_nat_trans":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n@[simp, reassoc.1]\ntheorem comp_lift_nat_trans (Fâ‚ Fâ‚‚ Fâ‚ƒ : Â«expr â¥¤ Â» C E) (Fâ‚' Fâ‚‚' Fâ‚ƒ' : Â«expr â¥¤ Â» D E) [hâ‚ : lifting L W Fâ‚ Fâ‚']\n    [hâ‚‚ : lifting L W Fâ‚‚ Fâ‚‚'] [hâ‚ƒ : lifting L W Fâ‚ƒ Fâ‚ƒ'] (Ï„ : Â«expr âŸ¶ Â» Fâ‚ Fâ‚‚) (Ï„' : Â«expr âŸ¶ Â» Fâ‚‚ Fâ‚ƒ) :\n    Â«expr â‰« Â» (lift_nat_trans L W Fâ‚ Fâ‚‚ Fâ‚' Fâ‚‚' Ï„) (lift_nat_trans L W Fâ‚‚ Fâ‚ƒ Fâ‚‚' Fâ‚ƒ' Ï„') =\n      lift_nat_trans L W Fâ‚ Fâ‚ƒ Fâ‚' Fâ‚ƒ' (Â«expr â‰« Â» Ï„ Ï„') :=\n  nat_trans_ext L W _ _ fun X => by simp only [nat_trans.comp_app, lift_nat_trans_app, assoc, iso.inv_hom_id_app_assoc]\n#align comp_lift_nat_trans comp_lift_nat_trans\n\n"}