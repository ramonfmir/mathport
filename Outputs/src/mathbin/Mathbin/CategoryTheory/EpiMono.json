{"of_mono_retraction'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/-- Every split mono whose retraction is mono is an iso. -/\ntheorem is_iso.of_mono_retraction' {X Y : C} {f : «expr ⟶ » X Y} (hf : SplitMono f) [Mono <| hf.retraction] : IsIso f :=\n  ⟨⟨hf.retraction, ⟨by simp, (cancel_mono_id <| hf.retraction).mp (by simp)⟩⟩⟩\n#align is_iso.of_mono_retraction' is_iso.of_mono_retraction'\n\n",
 "of_mono_retraction":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/-- Every split mono whose retraction is mono is an iso. -/\ntheorem is_iso.of_mono_retraction {X Y : C} (f : «expr ⟶ » X Y) [hf : IsSplitMono f] [hf' : Mono <| retraction f] :\n    IsIso f :=\n  @IsIso.of_mono_retraction' _ _ _ _ _ hf.exists_split_mono.some hf'\n#align is_iso.of_mono_retraction is_iso.of_mono_retraction\n\n",
 "of_epi_section'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/-- Every split epi whose section is epi is an iso. -/\ntheorem is_iso.of_epi_section' {X Y : C} {f : «expr ⟶ » X Y} (hf : SplitEpi f) [Epi <| hf.section_] : IsIso f :=\n  ⟨⟨hf.section_, ⟨(cancel_epi_id <| hf.section_).mp (by simp), by simp⟩⟩⟩\n#align is_iso.of_epi_section' is_iso.of_epi_section'\n\n",
 "of_epi_section":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/-- Every split epi whose section is epi is an iso. -/\ntheorem is_iso.of_epi_section {X Y : C} (f : «expr ⟶ » X Y) [hf : IsSplitEpi f] [hf' : Epi <| section_ f] : IsIso f :=\n  @IsIso.of_epi_section' _ _ _ _ _ hf.exists_split_epi.some hf'\n#align is_iso.of_epi_section is_iso.of_epi_section\n\n",
 "mono":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem split_mono.mono {X Y : C} {f : «expr ⟶ » X Y} (sm : SplitMono f) : Mono f :=\n  { right_cancellation := fun Z g h w => by replace w := «expr =≫ » w sm.retraction; simpa using w }\n#align split_mono.mono split_mono.mono\n\n",
 "mk'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/-- A constructor for `is_split_epi f` taking a `split_epi f` as an argument -/\ntheorem is_split_epi.mk' {X Y : C} {f : «expr ⟶ » X Y} (se : SplitEpi f) : IsSplitEpi f :=\n  ⟨nonempty.intro se⟩\n#align is_split_epi.mk' is_split_epi.mk'\n\n",
 "is_split_mono_of_mono":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n-- FIXME this has unnecessarily become noncomputable!\n/-- In a category in which every monomorphism is split, every monomorphism splits. This is not an\n    instance because it would create an instance loop. -/\ntheorem is_split_mono_of_mono [SplitMonoCategory C] {X Y : C} (f : «expr ⟶ » X Y) [Mono f] : IsSplitMono f :=\n  SplitMonoCategory.isSplitMono_of_mono _\n#align is_split_mono_of_mono is_split_mono_of_mono\n\n",
 "is_split_epi_of_epi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/-- In a category in which every epimorphism is split, every epimorphism splits. This is not an\n    instance because it would create an instance loop. -/\ntheorem is_split_epi_of_epi [SplitEpiCategory C] {X Y : C} (f : «expr ⟶ » X Y) [Epi f] : IsSplitEpi f :=\n  SplitEpiCategory.isSplitEpi_of_epi _\n#align is_split_epi_of_epi is_split_epi_of_epi\n\n",
 "is_iso_of_mono_of_is_split_epi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/-- A split epi which is mono is an iso. -/\ntheorem is_iso_of_mono_of_is_split_epi {X Y : C} (f : «expr ⟶ » X Y) [Mono f] [IsSplitEpi f] : IsIso f :=\n  ⟨⟨section_ f, ⟨by simp [← cancel_mono f], by simp⟩⟩⟩\n#align is_iso_of_mono_of_is_split_epi is_iso_of_mono_of_is_split_epi\n\n",
 "is_iso_of_epi_of_is_split_mono":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/-- A split mono which is epi is an iso. -/\ntheorem is_iso_of_epi_of_is_split_mono {X Y : C} (f : «expr ⟶ » X Y) [IsSplitMono f] [Epi f] : IsIso f :=\n  ⟨⟨retraction f, ⟨by simp, by simp [← cancel_epi f]⟩⟩⟩\n#align is_iso_of_epi_of_is_split_mono is_iso_of_epi_of_is_split_mono\n\n",
 "id":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n@[simp, reassoc.1]\ntheorem is_split_epi.id {X Y : C} (f : «expr ⟶ » X Y) [hf : IsSplitEpi f] : «expr ≫ » (section_ f) f = («expr𝟙») Y :=\n  hf.exists_split_epi.some.id\n#align is_split_epi.id is_split_epi.id\n\n",
 "epi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫= » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem split_epi.epi {X Y : C} {f : «expr ⟶ » X Y} (se : SplitEpi f) : Epi f :=\n  { left_cancellation := fun Z g h w => by replace w := «expr ≫= » se.section_ w; simpa using w }\n#align split_epi.epi split_epi.epi\n\n"}