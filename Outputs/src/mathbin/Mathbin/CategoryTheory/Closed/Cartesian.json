{"uncurry_pre":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\ntheorem uncurry_pre (f : «expr ⟶ » B A) [exponentiable B] (X : C) :\n    cartesian_closed.uncurry ((pre f).app X) = «expr ≫ » (Limits.prod.map f ((«expr𝟙») _)) ((exp.ev A).app X) := by\n  rw [uncurry_eq, prod_map_pre_app_comp_ev]\n#align uncurry_pre uncurry_pre\n\n",
 "uncurry_natural_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟹ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[reassoc.1]\ntheorem uncurry_natural_right (f : «expr ⟶ » X («expr ⟹ » A Y)) (g : «expr ⟶ » Y Y') :\n    uncurry («expr ≫ » f ((exp _).map g)) = «expr ≫ » (uncurry f) g :=\n  Adjunction.homEquiv_naturality_right_symm _ _ _\n#align uncurry_natural_right uncurry_natural_right\n\n",
 "uncurry_natural_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟹ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n@[reassoc.1]\ntheorem uncurry_natural_left (f : «expr ⟶ » X X') (g : «expr ⟶ » X' («expr ⟹ » A Y)) :\n    uncurry («expr ≫ » f g) = «expr ≫ » (Limits.prod.map ((«expr𝟙») _) f) (uncurry g) :=\n  Adjunction.homEquiv_naturality_left_symm _ _ _\n#align uncurry_natural_left uncurry_natural_left\n\n",
 "uncurry_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟹ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⨯ » -/\ntheorem uncurry_injective : function.injective (uncurry : «expr ⟶ » Y («expr ⟹ » A X) → «expr ⟶ » («expr ⨯ » A Y) X) :=\n  (closed.is_adj.adj.hom_equiv _ _).symm.injective\n#align uncurry_injective uncurry_injective\n\n",
 "uncurry_id_eq_ev":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟹ » -/\ntheorem uncurry_id_eq_ev (A X : C) [exponentiable A] : uncurry ((«expr𝟙») («expr ⟹ » A X)) = (exp.ev A).app X := by\n  rw [uncurry_eq, prod.map_id_id, id_comp]\n#align uncurry_id_eq_ev uncurry_id_eq_ev\n\n",
 "uncurry_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟹ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n-- I don't think these two should be simp.\ntheorem uncurry_eq (g : «expr ⟶ » Y («expr ⟹ » A X)) :\n    uncurry g = «expr ≫ » (Limits.prod.map ((«expr𝟙») A) g) ((exp.ev A).app X) :=\n  Adjunction.homEquiv_counit _\n#align uncurry_eq uncurry_eq\n\n",
 "uncurry_curry":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⨯ » -/\n@[simp]\ntheorem uncurry_curry (f : «expr ⟶ » («expr ⨯ » A X) Y) : uncurry (curry f) = f :=\n  (closed.is_adj.adj.hom_equiv _ _).left_inv f\n#align uncurry_curry uncurry_curry\n\n",
 "strict_initial":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n-- TODO: Generalise the below to its commutated variants.\n-- TODO: Define a distributive category, so that zero_mul and friends can be derived from this.\n/-- If an initial object `I` exists in a CCC then it is a strict initial object,\ni.e. any morphism to `I` is an iso.\nThis actually shows a slightly stronger version: any morphism to an initial object from an\nexponentiable object is an isomorphism.\n-/\ntheorem strict_initial {I : C} (t : IsInitial I) (f : «expr ⟶ » A I) : IsIso f :=\n  by\n  haveI : mono («expr ≫ » (limits.prod.lift ((«expr𝟙») A) f) (MulZeroClass.zero_mul t).hom) := mono_comp _ _\n  rw [zero_mul_hom, prod.lift_snd] at _inst\n  haveI : is_split_epi f := is_split_epi.mk' ⟨t.to _, t.hom_ext _ _⟩\n  apply is_iso_of_mono_of_is_split_epi\n#align strict_initial strict_initial\n\n",
 "prod_map_pre_app_comp_ev":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟹ » -/\ntheorem prod_map_pre_app_comp_ev (f : «expr ⟶ » B A) [exponentiable B] (X : C) :\n    «expr ≫ » (Limits.prod.map ((«expr𝟙») B) ((pre f).app X)) ((exp.ev B).app X) =\n      «expr ≫ » (Limits.prod.map f ((«expr𝟙») («expr ⟹ » A X))) ((exp.ev A).app X) :=\n  transferNatTransSelf_counit _ _ (prod.functor.map f) X\n#align prod_map_pre_app_comp_ev prod_map_pre_app_comp_ev\n\n",
 "pre_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp]\ntheorem pre_map {A₁ A₂ A₃ : C} [exponentiable A₁] [exponentiable A₂] [exponentiable A₃] (f : «expr ⟶ » A₁ A₂)\n    (g : «expr ⟶ » A₂ A₃) : pre («expr ≫ » f g) = «expr ≫ » (pre g) (pre f) := by\n  rw [pre, pre, pre, transfer_nat_trans_self_comp, prod.functor.map_comp]\n#align pre_map pre_map\n\n",
 "pre_id":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n@[simp]\ntheorem pre_id (A : C) [exponentiable A] : pre ((«expr𝟙») A) = («expr𝟙») _ := by simp [pre]\n#align pre_id pre_id\n\n",
 "initial_mono":
 "/-- If an initial object `0` exists in a CCC then every morphism from it is monic. -/\ntheorem initial_mono {I : C} (B : C) (t : IsInitial I) [cartesian_closed C] : Mono (t.to B) :=\n  ⟨fun B g h _ => by\n    haveI := strict_initial t g\n    haveI := strict_initial t h\n    exact eq_of_inv_eq_inv (t.hom_ext _ _)⟩\n#align initial_mono initial_mono\n\n",
 "hom_equiv_symm_apply_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟹ » -/\n@[simp]\ntheorem hom_equiv_symm_apply_eq (f : «expr ⟶ » Y («expr ⟹ » A X)) :\n    ((exp.adjunction A).hom_equiv _ _).symm f = uncurry f :=\n  rfl\n#align hom_equiv_symm_apply_eq hom_equiv_symm_apply_eq\n\n",
 "hom_equiv_apply_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⨯ » -/\n-- Wrap these in a namespace so we don't clash with the core versions.\n@[simp]\ntheorem hom_equiv_apply_eq (f : «expr ⟶ » («expr ⨯ » A Y) X) : (exp.adjunction A).hom_equiv _ _ f = curry f :=\n  rfl\n#align hom_equiv_apply_eq hom_equiv_apply_eq\n\n",
 "ev_coev":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⨯ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⨯ » -/\n/-\nCopyright (c) 2020 Bhavik Mehta, Edward Ayers, Thomas Read. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Bhavik Mehta, Edward Ayers, Thomas Read\n-/\n@[simp, reassoc.1]\ntheorem ev_coev :\n    «expr ≫ » (Limits.prod.map ((«expr𝟙») A) ((coev A).app B)) ((ev A).app («expr ⨯ » A B)) =\n      («expr𝟙») («expr ⨯ » A B) :=\n  ihom.ev_coev A B\n#align ev_coev ev_coev\n\n",
 "eq_curry_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⨯ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟹ » -/\ntheorem eq_curry_iff (f : «expr ⟶ » («expr ⨯ » A Y) X) (g : «expr ⟶ » Y («expr ⟹ » A X)) :\n    g = curry f ↔ uncurry g = f :=\n  Adjunction.eq_homEquiv_apply _ f g\n#align eq_curry_iff eq_curry_iff\n\n",
 "curry_uncurry":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟹ » -/\n@[simp]\ntheorem curry_uncurry (f : «expr ⟶ » X («expr ⟹ » A Y)) : curry (uncurry f) = f :=\n  (closed.is_adj.adj.hom_equiv _ _).right_inv f\n#align curry_uncurry curry_uncurry\n\n",
 "curry_natural_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⨯ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[reassoc.1]\ntheorem curry_natural_right (f : «expr ⟶ » («expr ⨯ » A X) Y) (g : «expr ⟶ » Y Y') :\n    curry («expr ≫ » f g) = «expr ≫ » (curry f) ((exp _).map g) :=\n  Adjunction.homEquiv_naturality_right _ _ _\n#align curry_natural_right curry_natural_right\n\n",
 "curry_natural_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⨯ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[reassoc.1]\ntheorem curry_natural_left (f : «expr ⟶ » X X') (g : «expr ⟶ » («expr ⨯ » A X') Y) :\n    curry («expr ≫ » (Limits.prod.map ((«expr𝟙») _) f) g) = «expr ≫ » f (curry g) :=\n  Adjunction.homEquiv_naturality_left _ _ _\n#align curry_natural_left curry_natural_left\n\n",
 "curry_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⨯ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟹ » -/\ntheorem curry_injective : function.injective (curry : «expr ⟶ » («expr ⨯ » A Y) X → «expr ⟶ » Y («expr ⟹ » A X)) :=\n  (closed.is_adj.adj.hom_equiv _ _).injective\n#align curry_injective curry_injective\n\n",
 "curry_id_eq_coev":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⨯ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\ntheorem curry_id_eq_coev (A X : C) [exponentiable A] : curry ((«expr𝟙») _) = (exp.coev A).app X :=\n  by\n  rw [curry_eq, (exp A).map_id («expr ⨯ » A _)]\n  apply comp_id\n#align curry_id_eq_coev curry_id_eq_coev\n\n",
 "curry_eq_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⨯ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟹ » -/\ntheorem curry_eq_iff (f : «expr ⟶ » («expr ⨯ » A Y) X) (g : «expr ⟶ » Y («expr ⟹ » A X)) :\n    curry f = g ↔ f = uncurry g :=\n  Adjunction.homEquiv_apply_eq _ f g\n#align curry_eq_iff curry_eq_iff\n\n",
 "curry_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⨯ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem curry_eq (g : «expr ⟶ » («expr ⨯ » A Y) X) : curry g = «expr ≫ » ((exp.coev A).app Y) ((exp A).map g) :=\n  Adjunction.homEquiv_unit _\n#align curry_eq curry_eq\n\n",
 "coev_ev":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟹ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟹ » -/\n@[simp, reassoc.1]\ntheorem coev_ev : «expr ≫ » ((coev A).app («expr ⟹ » A B)) ((exp A).map ((ev A).app B)) = («expr𝟙») («expr ⟹ » A B) :=\n  ihom.coev_ev A B\n#align coev_ev coev_ev\n\n",
 "coev_app_comp_pre_app":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⨯ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\ntheorem coev_app_comp_pre_app (f : «expr ⟶ » B A) [exponentiable B] :\n    «expr ≫ » ((exp.coev A).app X) ((pre f).app («expr ⨯ » A X)) =\n      «expr ≫ » ((exp.coev B).app X) ((exp B).map (Limits.prod.map f ((«expr𝟙») _))) :=\n  unit_transferNatTransSelf _ _ (prod.functor.map f) X\n#align coev_app_comp_pre_app coev_app_comp_pre_app\n\n"}