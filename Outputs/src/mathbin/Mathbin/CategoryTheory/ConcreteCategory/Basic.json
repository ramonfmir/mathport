{"surjective_of_epi_of_preserves_pushout":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem concrete_category.surjective_of_epi_of_preserves_pushout {X Y : C} (f : «expr ⟶ » X Y) [Epi f]\n    [PreservesColimitsOfShape WalkingSpan (forget C)] : function.surjective f :=\n  (epi_iff_surjective ((forget C).map f)).mp inferInstance\n#align concrete_category.surjective_of_epi_of_preserves_pushout concrete_category.surjective_of_epi_of_preserves_pushout\n\n",
 "mono_of_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/-- In any concrete category, injective morphisms are monomorphisms. -/\ntheorem concrete_category.mono_of_injective {X Y : C} (f : «expr ⟶ » X Y) (i : function.injective f) : Mono f :=\n  (forget C).mono_of_mono_map ((mono_iff_injective f).2 i)\n#align concrete_category.mono_of_injective concrete_category.mono_of_injective\n\n",
 "mono_iff_injective_of_preserves_pullback":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem concrete_category.mono_iff_injective_of_preserves_pullback {X Y : C} (f : «expr ⟶ » X Y)\n    [PreservesLimitsOfShape WalkingCospan (forget C)] : Mono f ↔ function.injective f :=\n  ((forget C).mono_map_iff_mono _).symm.trans (mono_iff_injective _)\n#align concrete_category.mono_iff_injective_of_preserves_pullback concrete_category.mono_iff_injective_of_preserves_pullback\n\n",
 "injective_of_mono_of_preserves_pullback":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem concrete_category.injective_of_mono_of_preserves_pullback {X Y : C} (f : «expr ⟶ » X Y) [Mono f]\n    [PreservesLimitsOfShape WalkingCospan (forget C)] : function.injective f :=\n  (mono_iff_injective ((forget C).map f)).mp inferInstance\n#align concrete_category.injective_of_mono_of_preserves_pullback concrete_category.injective_of_mono_of_preserves_pullback\n\n",
 "id_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n@[simp]\ntheorem id_apply {X : C} (x : X) : ((«expr𝟙») X : X → X) x = x :=\n  congr_fun ((forget _).map_id X) x\n#align id_apply id_apply\n\n",
 "hom_ext":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/-- In any concrete category, we can test equality of morphisms by pointwise evaluations.-/\ntheorem concrete_category.hom_ext {X Y : C} (f g : «expr ⟶ » X Y) (w : ∀ x : X, f x = g x) : f = g :=\n  by\n  apply faithful.map_injective (forget C)\n  ext\n  exact w x\n#align concrete_category.hom_ext concrete_category.hom_ext\n\n",
 "has_coe_to_fun_Type":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n@[simp]\ntheorem concrete_category.has_coe_to_fun_Type {X Y : Type u} (f : «expr ⟶ » X Y) : coe_fn f = f :=\n  rfl\n#align concrete_category.has_coe_to_fun_Type concrete_category.has_coe_to_fun_Type\n\n",
 "forget_obj_eq_coe":
 "/-\nCopyright (c) 2018 Scott Morrison. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Scott Morrison, Johannes Hölzl, Reid Barton, Sean Leather, Yury Kudryashov\n-/\n@[simp]\ntheorem forget_obj_eq_coe {X : C} : (forget C).obj X = X :=\n  rfl\n#align forget_obj_eq_coe forget_obj_eq_coe\n\n",
 "forget_map_eq_coe":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n@[simp]\ntheorem forget_map_eq_coe {X Y : C} (f : «expr ⟶ » X Y) : (forget C).map f = f :=\n  rfl\n#align forget_map_eq_coe forget_map_eq_coe\n\n",
 "epi_of_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/-- In any concrete category, surjective morphisms are epimorphisms. -/\ntheorem concrete_category.epi_of_surjective {X Y : C} (f : «expr ⟶ » X Y) (s : function.surjective f) : Epi f :=\n  (forget C).epi_of_epi_map ((epi_iff_surjective f).2 s)\n#align concrete_category.epi_of_surjective concrete_category.epi_of_surjective\n\n",
 "epi_iff_surjective_of_preserves_pushout":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem concrete_category.epi_iff_surjective_of_preserves_pushout {X Y : C} (f : «expr ⟶ » X Y)\n    [PreservesColimitsOfShape WalkingSpan (forget C)] : Epi f ↔ function.surjective f :=\n  ((forget C).epi_map_iff_epi _).symm.trans (epi_iff_surjective _)\n#align concrete_category.epi_iff_surjective_of_preserves_pushout concrete_category.epi_iff_surjective_of_preserves_pushout\n\n",
 "congr_hom":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem concrete_category.congr_hom {X Y : C} {f g : «expr ⟶ » X Y} (h : f = g) (x : X) : f x = g x :=\n  congr_fun (congr_arg (fun f : «expr ⟶ » X Y => (f : X → Y)) h) x\n#align concrete_category.congr_hom concrete_category.congr_hom\n\n",
 "congr_arg":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem concrete_category.congr_arg {X Y : C} (f : «expr ⟶ » X Y) {x x' : X} (h : x = x') : f x = f x' :=\n  congr_arg (f : X → Y) h\n#align concrete_category.congr_arg concrete_category.congr_arg\n\n",
 "comp_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp]\ntheorem comp_apply {X Y Z : C} (f : «expr ⟶ » X Y) (g : «expr ⟶ » Y Z) (x : X) : («expr ≫ » f g) x = g (f x) :=\n  congr_fun ((forget _).map_comp _ _) x\n#align comp_apply comp_apply\n\n",
 "coe_id":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\ntheorem coe_id {X : C} : ((«expr𝟙») X : X → X) = id :=\n  (forget _).map_id X\n#align coe_id coe_id\n\n",
 "coe_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem coe_comp {X Y Z : C} (f : «expr ⟶ » X Y) (g : «expr ⟶ » Y Z) : («expr ≫ » f g : X → Z) = g ∘ f :=\n  (forget _).map_comp f g\n#align coe_comp coe_comp\n\n",
 "bijective_of_is_iso":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem concrete_category.bijective_of_is_iso {X Y : C} (f : «expr ⟶ » X Y) [IsIso f] :\n    function.bijective ((forget C).map f) := by\n  rw [← is_iso_iff_bijective]\n  infer_instance\n#align concrete_category.bijective_of_is_iso concrete_category.bijective_of_is_iso\n\n"}