{"is_skeletal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\ntheorem is_skeletal : skeletal skeleton.{u} := fun X Y âŸ¨hâŸ© =>\n  ext _ _ <|\n    fin.equiv_iff_eq.mp <|\n      nonempty.intro <|\n        { to_fun := fun x => (h.hom âŸ¨xâŸ©).down\n          inv_fun := fun x => (h.inv âŸ¨xâŸ©).down\n          left_inv := by\n            intro a\n            change ulift.down _ = _\n            rw [ulift.up_down]\n            change ((Â«expr â‰« Â» h.hom h.inv) _).down = _\n            simpa\n          right_inv := by\n            intro a\n            change ulift.down _ = _\n            rw [ulift.up_down]\n            change ((Â«expr â‰« Â» h.inv h.hom) _).down = _\n            simpa }\n#align is_skeletal is_skeletal\n\n",
 "incl_mk_nat_card":
 "@[simp]\ntheorem incl_mk_nat_card (n : â„•) : fintype.card (incl.obj (mk n)) = n :=\n  by\n  convert finset.card_fin n\n  apply fintype.of_equiv_card\n#align incl_mk_nat_card incl_mk_nat_card\n\n",
 "id_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n/-\nCopyright (c) 2020 Adam Topaz. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Bhavik Mehta, Adam Topaz\n-/\n@[simp]\ntheorem id_apply (X : Fintype) (x : X) : ((Â«exprğŸ™Â») X : X â†’ X) x = x :=\n  rfl\n#align id_apply id_apply\n\n",
 "ext":
 "-- See `equiv_equiv_iso` in the root namespace for the analogue in `Type`.\n@[ext]\ntheorem ext (X Y : skeleton) : X.len = Y.len â†’ X = Y :=\n  ulift.ext _ _\n#align ext ext\n\n",
 "comp_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n@[simp]\ntheorem comp_apply {X Y Z : Fintype} (f : Â«expr âŸ¶ Â» X Y) (g : Â«expr âŸ¶ Â» Y Z) (x : X) : (Â«expr â‰« Â» f g) x = g (f x) :=\n  rfl\n#align comp_apply comp_apply\n\n"}