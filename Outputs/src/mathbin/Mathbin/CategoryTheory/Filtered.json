{"tulip":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/-- Given a \"tulip\" of morphisms\n```\n j₁    j₂    j₃\n |\\   / \\   / |\n | \\ /   \\ /  |\n |  vv    vv  |\n \\  k₁    k₂ /\n  \\         /\n   \\       /\n    \\     /\n     \\   /\n      v v\n       l\n```\nin a filtered category, we can construct an object `s` and three morphisms from `k₁`, `k₂` and `l`\nto `s`, making the resulting squares commute.\n-/\ntheorem tulip {j₁ j₂ j₃ k₁ k₂ l : C} (f₁ : «expr ⟶ » j₁ k₁) (f₂ : «expr ⟶ » j₂ k₁) (f₃ : «expr ⟶ » j₂ k₂)\n    (f₄ : «expr ⟶ » j₃ k₂) (g₁ : «expr ⟶ » j₁ l) (g₂ : «expr ⟶ » j₃ l) :\n    ∃ (s : C)(α : «expr ⟶ » k₁ s)(β : «expr ⟶ » l s)(γ : «expr ⟶ » k₂ s),\n      «expr ≫ » f₁ α = «expr ≫ » g₁ β ∧ «expr ≫ » f₂ α = «expr ≫ » f₃ γ ∧ «expr ≫ » f₄ γ = «expr ≫ » g₂ β :=\n  by\n  obtain ⟨l', k₁l, k₂l, hl⟩ := span f₂ f₃\n  obtain ⟨s, ls, l's, hs₁, hs₂⟩ := bowtie g₁ («expr ≫ » f₁ k₁l) g₂ («expr ≫ » f₄ k₂l)\n  refine' ⟨s, «expr ≫ » k₁l l's, ls, «expr ≫ » k₂l l's, _, by rw [reassoc_of hl], _⟩ <;>\n    simp only [hs₁, hs₂, category.assoc]\n#align tulip tulip\n\n",
 "to_sup_commutes":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/-- The triangles of consisting of a morphism in `H` and the maps to `sup O H` commute.\n-/\ntheorem to_sup_commutes {X Y : C} (mX : X ∈ O) (mY : Y ∈ O) {f : «expr ⟶ » X Y}\n    (mf : (⟨X, Y, mX, mY, f⟩ : Σ'(X Y : C)(mX : X ∈ O)(mY : Y ∈ O), «expr ⟶ » X Y) ∈ H) :\n    «expr ≫ » f (to_sup O H mY) = to_sup O H mX :=\n  (sup_exists O H).some_spec.some_spec mX mY mf\n#align to_sup_commutes to_sup_commutes\n\n",
 "sup_objs_exists":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/-- Any finite collection of objects in a filtered category has an object \"to the right\".\n-/\ntheorem sup_objs_exists (O : Finset C) : ∃ S : C, ∀ {X}, X ∈ O → _root_.nonempty («expr ⟶ » X S) := by\n  classical\n    apply Finset.induction_on O\n    · exact ⟨is_filtered.nonempty.some, by rintro - ⟨⟩⟩\n    · rintro X O' nm ⟨S', w'⟩\n      use max X S'\n      rintro Y mY\n      obtain rfl | h := eq_or_ne Y X\n      · exact ⟨left_to_max _ _⟩\n      · exact ⟨«expr ≫ » (w' (Finset.mem_of_mem_insert_of_ne mY h)).some (right_to_max _ _)⟩\n#align sup_objs_exists sup_objs_exists\n\n",
 "sup_exists":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/-- Given any `finset` of objects `{X, ...}` and\nindexed collection of `finset`s of morphisms `{f, ...}` in `C`,\nthere exists an object `S`, with a morphism `T X : X ⟶ S` from each `X`,\nsuch that the triangles commute: `f ≫ T Y = T X`, for `f : X ⟶ Y` in the `finset`.\n-/\ntheorem sup_exists :\n    ∃ (S : C)(T : ∀ {X : C}, X ∈ O → «expr ⟶ » X S),\n      ∀ {X Y : C} (mX : X ∈ O) (mY : Y ∈ O) {f : «expr ⟶ » X Y},\n        (⟨X, Y, mX, mY, f⟩ : Σ'(X Y : C)(mX : X ∈ O)(mY : Y ∈ O), «expr ⟶ » X Y) ∈ H → «expr ≫ » f (T mY) = T mX :=\n  by\n  classical\n    apply Finset.induction_on H\n    · obtain ⟨S, f⟩ := sup_objs_exists O\n      refine' ⟨S, fun X mX => (f mX).some, _⟩\n      rintro - - - - - ⟨⟩\n    · rintro ⟨X, Y, mX, mY, f⟩ H' nmf ⟨S', T', w'⟩\n      refine'\n        ⟨coeq («expr ≫ » f (T' mY)) (T' mX), fun Z mZ => «expr ≫ » (T' mZ) (coeq_hom («expr ≫ » f (T' mY)) (T' mX)), _⟩\n      intro X' Y' mX' mY' f' mf'\n      rw [← category.assoc]\n      by_cases h : X = X' ∧ Y = Y'\n      · rcases h with ⟨rfl, rfl⟩\n        by_cases hf : f = f'\n        · subst hf\n          apply coeq_condition\n        · rw [@w' _ _ mX mY f' (by simpa [hf ∘ eq.symm] using mf')]\n      · rw [@w' _ _ mX' mY' f' _]\n        apply Finset.mem_of_mem_insert_of_ne mf'\n        contrapose! h\n        obtain ⟨rfl, h⟩ := h\n        rw [heq_iff_eq, psigma.mk.inj_iff] at h\n        exact ⟨rfl, h.1.symm⟩\n#align sup_exists sup_exists\n\n",
 "span":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/-- For every span `j ⟵ i ⟶ j'`, there\n   exists a cocone `j ⟶ k ⟵ j'` such that the square commutes. -/\ntheorem span {i j j' : C} (f : «expr ⟶ » i j) (f' : «expr ⟶ » i j') :\n    ∃ (k : C)(g : «expr ⟶ » j k)(g' : «expr ⟶ » j' k), «expr ≫ » f g = «expr ≫ » f' g' :=\n  let ⟨K, G, G', _⟩ := cocone_objs j j'\n  let ⟨k, e, he⟩ := cocone_maps («expr ≫ » f G) («expr ≫ » f' G')\n  ⟨k, «expr ≫ » G e, «expr ≫ » G' e, by simpa only [← category.assoc] ⟩\n#align span span\n\n",
 "ranges_directed":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:219:4: warning: unsupported binary notation `«expr ⊇ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem _root_.category_theory.functor.ranges_directed (F : «expr ⥤ » C (Type _)) (j : C) :\n    Directed («expr ⊇ » · ·) fun f : Σ'i, «expr ⟶ » i j => Set.range (F.map f.2) := fun ⟨i, ij⟩ ⟨k, kj⟩ =>\n  by\n  let ⟨l, li, lk, e⟩ := cospan ij kj\n  refine' ⟨⟨l, «expr ≫ » lk kj⟩, e ▸ _, _⟩ <;> simp_rw [F.map_comp] <;> apply Set.range_comp_subset_range\n#align category_theory.functor.ranges_directed category_theory.functor.ranges_directed\n\n",
 "of_right_adjoint":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊣ » -/\n/-- If `C` is filtered, and we have a functor `R : C ⥤ D` with a left adjoint, then `D` is filtered.\n-/\ntheorem of_right_adjoint {L : «expr ⥤ » D C} {R : «expr ⥤ » C D} (h : «expr ⊣ » L R) : is_filtered D :=\n  { cocone_objs := fun X Y => ⟨_, h.hom_equiv _ _ (left_to_max _ _), h.hom_equiv _ _ (right_to_max _ _), ⟨⟩⟩\n    cocone_maps := fun X Y f g =>\n      ⟨_, h.hom_equiv _ _ (coeq_hom _ _), by\n        rw [← h.hom_equiv_naturality_left, ← h.hom_equiv_naturality_left, coeq_condition]⟩\n    nonempty := is_filtered.nonempty.map R.obj }\n#align of_right_adjoint of_right_adjoint\n\n",
 "of_left_adjoint":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊣ » -/\n/-- If `C` is cofiltered, and we have a functor `L : C ⥤ D` with a right adjoint,\nthen `D` is cofiltered.\n-/\ntheorem of_left_adjoint {L : «expr ⥤ » C D} {R : «expr ⥤ » D C} (h : «expr ⊣ » L R) : is_cofiltered D :=\n  { cone_objs := fun X Y =>\n      ⟨L.obj (min (R.obj X) (R.obj Y)), (h.hom_equiv _ X).symm (min_to_left _ _),\n        (h.hom_equiv _ Y).symm (min_to_right _ _), ⟨⟩⟩\n    cone_maps := fun X Y f g =>\n      ⟨L.obj (eq (R.map f) (R.map g)), (h.hom_equiv _ _).symm (eq_hom _ _), by\n        rw [← h.hom_equiv_naturality_right_symm, ← h.hom_equiv_naturality_right_symm, eq_condition]⟩\n    nonempty := is_cofiltered.nonempty.map L.obj }\n#align of_left_adjoint of_left_adjoint\n\n",
 "of_is_right_adjoint":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/-- If `C` is filtered, and we have a right adjoint functor `R : C ⥤ D`, then `D` is filtered. -/\ntheorem of_is_right_adjoint (R : «expr ⥤ » C D) [is_right_adjoint R] : is_filtered D :=\n  of_right_adjoint (adjunction.of_right_adjoint R)\n#align of_is_right_adjoint of_is_right_adjoint\n\n",
 "of_is_left_adjoint":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/-- If `C` is cofiltered, and we have a left adjoint functor `L : C ⥤ D`, then `D` is cofiltered. -/\ntheorem of_is_left_adjoint (L : «expr ⥤ » C D) [is_left_adjoint L] : is_cofiltered D :=\n  of_left_adjoint (adjunction.of_left_adjoint L)\n#align of_is_left_adjoint of_is_left_adjoint\n\n",
 "of_equivalence":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≌ » -/\n/-- Being cofiltered is preserved by equivalence of categories. -/\ntheorem of_equivalence (h : «expr ≌ » C D) : is_cofiltered D :=\n  of_left_adjoint h.to_adjunction\n#align of_equivalence of_equivalence\n\n",
 "inf_to_commutes":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/-- The triangles consisting of a morphism in `H` and the maps from `inf O H` commute.\n-/\ntheorem inf_to_commutes {X Y : C} (mX : X ∈ O) (mY : Y ∈ O) {f : «expr ⟶ » X Y}\n    (mf : (⟨X, Y, mX, mY, f⟩ : Σ'(X Y : C)(mX : X ∈ O)(mY : Y ∈ O), «expr ⟶ » X Y) ∈ H) :\n    «expr ≫ » (inf_to O H mX) f = inf_to O H mY :=\n  (inf_exists O H).some_spec.some_spec mX mY mf\n#align inf_to_commutes inf_to_commutes\n\n",
 "inf_objs_exists":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/-- Any finite collection of objects in a cofiltered category has an object \"to the left\".\n-/\ntheorem inf_objs_exists (O : Finset C) : ∃ S : C, ∀ {X}, X ∈ O → _root_.nonempty («expr ⟶ » S X) := by\n  classical\n    apply Finset.induction_on O\n    · exact ⟨is_cofiltered.nonempty.some, by rintro - ⟨⟩⟩\n    · rintro X O' nm ⟨S', w'⟩\n      use min X S'\n      rintro Y mY\n      obtain rfl | h := eq_or_ne Y X\n      · exact ⟨min_to_left _ _⟩\n      · exact ⟨«expr ≫ » (min_to_right _ _) (w' (Finset.mem_of_mem_insert_of_ne mY h)).some⟩\n#align inf_objs_exists inf_objs_exists\n\n",
 "inf_exists":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/-- Given any `finset` of objects `{X, ...}` and\nindexed collection of `finset`s of morphisms `{f, ...}` in `C`,\nthere exists an object `S`, with a morphism `T X : S ⟶ X` from each `X`,\nsuch that the triangles commute: `T X ≫ f = T Y`, for `f : X ⟶ Y` in the `finset`.\n-/\ntheorem inf_exists :\n    ∃ (S : C)(T : ∀ {X : C}, X ∈ O → «expr ⟶ » S X),\n      ∀ {X Y : C} (mX : X ∈ O) (mY : Y ∈ O) {f : «expr ⟶ » X Y},\n        (⟨X, Y, mX, mY, f⟩ : Σ'(X Y : C)(mX : X ∈ O)(mY : Y ∈ O), «expr ⟶ » X Y) ∈ H → «expr ≫ » (T mX) f = T mY :=\n  by\n  classical\n    apply Finset.induction_on H\n    · obtain ⟨S, f⟩ := inf_objs_exists O\n      refine' ⟨S, fun X mX => (f mX).some, _⟩\n      rintro - - - - - ⟨⟩\n    · rintro ⟨X, Y, mX, mY, f⟩ H' nmf ⟨S', T', w'⟩\n      refine'\n        ⟨eq («expr ≫ » (T' mX) f) (T' mY), fun Z mZ => «expr ≫ » (eq_hom («expr ≫ » (T' mX) f) (T' mY)) (T' mZ), _⟩\n      intro X' Y' mX' mY' f' mf'\n      rw [category.assoc]\n      by_cases h : X = X' ∧ Y = Y'\n      · rcases h with ⟨rfl, rfl⟩\n        by_cases hf : f = f'\n        · subst hf\n          apply eq_condition\n        · rw [@w' _ _ mX mY f' (by simpa [hf ∘ eq.symm] using mf')]\n      · rw [@w' _ _ mX' mY' f' _]\n        apply Finset.mem_of_mem_insert_of_ne mf'\n        contrapose! h\n        obtain ⟨rfl, h⟩ := h\n        rw [heq_iff_eq, psigma.mk.inj_iff] at h\n        exact ⟨rfl, h.1.symm⟩\n#align inf_exists inf_exists\n\n",
 "eq_condition":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/-- `eq_condition f f'`, for morphisms `f f' : j ⟶ j'`, is the proof that\n`eq_hom f f' ≫ f = eq_hom f f' ≫ f'`.\n-/\n@[simp, reassoc.1]\ntheorem eq_condition {j j' : C} (f f' : «expr ⟶ » j j') : «expr ≫ » (eq_hom f f') f = «expr ≫ » (eq_hom f f') f' :=\n  (cone_maps f f').some_spec.some_spec\n#align eq_condition eq_condition\n\n",
 "cospan":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/-- For every cospan `j ⟶ i ⟵ j'`,\n there exists a cone `j ⟵ k ⟶ j'` such that the square commutes. -/\ntheorem cospan {i j j' : C} (f : «expr ⟶ » j i) (f' : «expr ⟶ » j' i) :\n    ∃ (k : C)(g : «expr ⟶ » k j)(g' : «expr ⟶ » k j'), «expr ≫ » g f = «expr ≫ » g' f' :=\n  let ⟨K, G, G', _⟩ := cone_objs j j'\n  let ⟨k, e, he⟩ := cone_maps («expr ≫ » G f) («expr ≫ » G' f')\n  ⟨k, «expr ≫ » e G, «expr ≫ » e G', by simpa only [category.assoc] using he⟩\n#align cospan cospan\n\n",
 "cone_objs":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n-- Sanity checks\ntheorem cone_objs : ∀ X Y : C, ∃ (W : _)(f : «expr ⟶ » W X)(g : «expr ⟶ » W Y), true :=\n  is_cofiltered_or_empty.cone_objs\n#align cone_objs cone_objs\n\n",
 "cone_nonempty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/-- If we have `is_cofiltered C`, then for any functor `F : J ⥤ C` with `fin_category J`,\nthere exists a cone over `F`.\n-/\ntheorem cone_nonempty (F : «expr ⥤ » J C) : _root_.nonempty (cone F) := by\n  classical\n    let O := finset.univ.image F.obj\n    let H : Finset (Σ'(X Y : C)(mX : X ∈ O)(mY : Y ∈ O), «expr ⟶ » X Y) :=\n      finset.univ.bUnion fun X : J =>\n        finset.univ.bUnion fun Y : J =>\n          finset.univ.image fun f : «expr ⟶ » X Y => ⟨F.obj X, F.obj Y, by simp, by simp, F.map f⟩\n    obtain ⟨Z, f, w⟩ := inf_exists O H\n    refine' ⟨⟨Z, ⟨fun X => f (by simp), _⟩⟩⟩\n    intro j j' g\n    dsimp\n    simp only [category.id_comp]\n    symm\n    apply w\n    simp only [finset.mem_univ, Finset.mem_bunionᵢ, exists_and_left, exists_prop_of_true, Finset.mem_image]\n    exact ⟨j, rfl, j', g, by simp⟩\n#align cone_nonempty cone_nonempty\n\n",
 "cone_maps":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem cone_maps : ∀ ⦃X Y : C⦄ (f g : «expr ⟶ » X Y), ∃ (W : _)(h : «expr ⟶ » W X), «expr ≫ » h f = «expr ≫ » h g :=\n  is_cofiltered_or_empty.cone_maps\n#align cone_maps cone_maps\n\n",
 "coeq₃_condition₃":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem coeq₃_condition₃ {j₁ j₂ : C} (f g h : «expr ⟶ » j₁ j₂) :\n    «expr ≫ » f (coeq₃_hom f g h) = «expr ≫ » h (coeq₃_hom f g h) :=\n  eq.trans (coeq₃_condition₁ f g h) (coeq₃_condition₂ f g h)\n#align coeq₃_condition₃ coeq₃_condition₃\n\n",
 "coeq₃_condition₂":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem coeq₃_condition₂ {j₁ j₂ : C} (f g h : «expr ⟶ » j₁ j₂) :\n    «expr ≫ » g (coeq₃_hom f g h) = «expr ≫ » h (coeq₃_hom f g h) :=\n  by\n  dsimp [coeq₃_hom]\n  slice_lhs 2 4 => rw [← category.assoc, coeq_condition _ _]\n  slice_rhs 2 4 => rw [← category.assoc, coeq_condition _ _]\n  slice_lhs 1 3 => rw [← category.assoc, coeq_condition _ _]\n  simp only [category.assoc]\n#align coeq₃_condition₂ coeq₃_condition₂\n\n",
 "coeq₃_condition₁":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem coeq₃_condition₁ {j₁ j₂ : C} (f g h : «expr ⟶ » j₁ j₂) :\n    «expr ≫ » f (coeq₃_hom f g h) = «expr ≫ » g (coeq₃_hom f g h) := by rw [coeq₃_hom, reassoc_of (coeq_condition f g)]\n#align coeq₃_condition₁ coeq₃_condition₁\n\n",
 "coeq_condition":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/-- `coeq_condition f f'`, for morphisms `f f' : j ⟶ j'`, is the proof that\n`f ≫ coeq_hom f f' = f' ≫ coeq_hom f f'`.\n-/\n@[simp, reassoc.1]\ntheorem coeq_condition {j j' : C} (f f' : «expr ⟶ » j j') :\n    «expr ≫ » f (coeq_hom f f') = «expr ≫ » f' (coeq_hom f f') :=\n  (cocone_maps f f').some_spec.some_spec\n#align coeq_condition coeq_condition\n\n",
 "cocone_objs":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/-\nCopyright (c) 2019 Reid Barton. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Reid Barton, Scott Morrison\n-/\n-- declare the `v`'s first; see `category_theory.category` for an explanation\n-- Sanity checks\ntheorem cocone_objs : ∀ X Y : C, ∃ (Z : _)(f : «expr ⟶ » X Z)(g : «expr ⟶ » Y Z), true :=\n  is_filtered_or_empty.cocone_objs\n#align cocone_objs cocone_objs\n\n",
 "cocone_nonempty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/-- If we have `is_filtered C`, then for any functor `F : J ⥤ C` with `fin_category J`,\nthere exists a cocone over `F`.\n-/\ntheorem cocone_nonempty (F : «expr ⥤ » J C) : _root_.nonempty (cocone F) := by\n  classical\n    let O := finset.univ.image F.obj\n    let H : Finset (Σ'(X Y : C)(mX : X ∈ O)(mY : Y ∈ O), «expr ⟶ » X Y) :=\n      finset.univ.bUnion fun X : J =>\n        finset.univ.bUnion fun Y : J =>\n          finset.univ.image fun f : «expr ⟶ » X Y => ⟨F.obj X, F.obj Y, by simp, by simp, F.map f⟩\n    obtain ⟨Z, f, w⟩ := sup_exists O H\n    refine' ⟨⟨Z, ⟨fun X => f (by simp), _⟩⟩⟩\n    intro j j' g\n    dsimp\n    simp only [category.comp_id]\n    apply w\n    simp only [finset.mem_univ, Finset.mem_bunionᵢ, exists_and_left, exists_prop_of_true, Finset.mem_image]\n    exact ⟨j, rfl, j', g, by simp⟩\n#align cocone_nonempty cocone_nonempty\n\n",
 "cocone_maps":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem cocone_maps : ∀ ⦃X Y : C⦄ (f g : «expr ⟶ » X Y), ∃ (Z : _)(h : «expr ⟶ » Y Z), «expr ≫ » f h = «expr ≫ » g h :=\n  is_filtered_or_empty.cocone_maps\n#align cocone_maps cocone_maps\n\n",
 "bowtie":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/-- Given a \"bowtie\" of morphisms\n```\n j₁   j₂\n |\\  /|\n | \\/ |\n | /\\ |\n |/  \\∣\n vv  vv\n k₁  k₂\n```\nin a filtered category, we can construct an object `s` and two morphisms from `k₁` and `k₂` to `s`,\nmaking the resulting squares commute.\n-/\ntheorem bowtie {j₁ j₂ k₁ k₂ : C} (f₁ : «expr ⟶ » j₁ k₁) (g₁ : «expr ⟶ » j₁ k₂) (f₂ : «expr ⟶ » j₂ k₁)\n    (g₂ : «expr ⟶ » j₂ k₂) :\n    ∃ (s : C)(α : «expr ⟶ » k₁ s)(β : «expr ⟶ » k₂ s),\n      «expr ≫ » f₁ α = «expr ≫ » g₁ β ∧ «expr ≫ » f₂ α = «expr ≫ » g₂ β :=\n  by\n  obtain ⟨t, k₁t, k₂t, ht⟩ := span f₁ g₁\n  obtain ⟨s, ts, hs⟩ := cocone_maps («expr ≫ » f₂ k₁t) («expr ≫ » g₂ k₂t)\n  simp_rw [category.assoc] at hs\n  exact ⟨s, «expr ≫ » k₁t ts, «expr ≫ » k₂t ts, by rw [reassoc_of ht], hs⟩\n#align bowtie bowtie\n\n"}