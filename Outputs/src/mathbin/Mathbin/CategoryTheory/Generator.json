{"well_powered_of_is_detector":
 "theorem well_powered_of_is_detector [HasPullbacks C] (G : C) (hG : IsDetector G) : WellPowered C :=\n  wellPowered_of_isDetecting hG\n#align well_powered_of_is_detector well_powered_of_is_detector\n\n",
 "well_powered_of_is_detecting":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/-- A category with pullbacks and a small detecting set is well-powered. -/\ntheorem well_powered_of_is_detecting [HasPullbacks C] {𝒢 : Set C} [Small.{v₁} 𝒢] (h𝒢 : IsDetecting 𝒢) : WellPowered C :=\n  ⟨fun X =>\n    @small_of_injective _ _ _ (fun P : Subobject X => { f : ΣG : 𝒢, «expr ⟶ » G.1 X | P.factors f.2 }) fun P Q h =>\n      Subobject.eq_of_isDetecting h𝒢 _ _ (by simpa [Set.ext_iff] using h)⟩\n#align well_powered_of_is_detecting well_powered_of_is_detecting\n\n",
 "thin_of_is_separating_empty":
 "theorem thin_of_is_separating_empty (h : IsSeparating (∅ : Set C)) : Quiver.IsThin C := fun _ _ =>\n  ⟨fun f g => h _ _ fun G => false.elim⟩\n#align thin_of_is_separating_empty thin_of_is_separating_empty\n\n",
 "thin_of_is_coseparating_empty":
 "theorem thin_of_is_coseparating_empty (h : IsCoseparating (∅ : Set C)) : Quiver.IsThin C := fun _ _ =>\n  ⟨fun f g => h _ _ fun G => false.elim⟩\n#align thin_of_is_coseparating_empty thin_of_is_coseparating_empty\n\n",
 "mono":
 "theorem is_codetecting.mono {𝒢 : Set C} (h𝒢 : IsCodetecting 𝒢) {ℋ : Set C} (h𝒢ℋ : 𝒢 ⊆ ℋ) : IsCodetecting ℋ :=\n  fun X Y f hf => h𝒢 _ fun G hG h => hf _ (h𝒢ℋ hG) _\n#align is_codetecting.mono is_codetecting.mono\n\n",
 "is_separator_unop_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵖ» -/\ntheorem is_separator_unop_iff (G : «expr ᵒᵖ» C) : IsSeparator (unop G) ↔ IsCoseparator G := by\n  rw [is_separator, is_coseparator, ← is_separating_unop_iff, Set.singleton_unop]\n#align is_separator_unop_iff is_separator_unop_iff\n\n",
 "is_separator_sigma_of_is_separator":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∐ » -/\ntheorem is_separator_sigma_of_is_separator {β : Type w} (f : β → C) [HasCoproduct f] (b : β) (hb : IsSeparator (f b)) :\n    IsSeparator («expr∐ » f) :=\n  (isSeparator_sigma _).2 <| IsSeparating.mono hb <| by simp\n#align is_separator_sigma_of_is_separator is_separator_sigma_of_is_separator\n\n",
 "is_separator_sigma":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫= » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∐ » -/\ntheorem is_separator_sigma {β : Type w} (f : β → C) [HasCoproduct f] :\n    IsSeparator («expr∐ » f) ↔ IsSeparating (Set.range f) :=\n  by\n  refine' ⟨fun h X Y u v huv => _, fun h => (is_separator_def _).2 fun X Y u v huv => h _ _ fun Z hZ g => _⟩\n  · refine' h.def _ _ fun g => colimit.hom_ext fun b => _\n    simpa using huv (f b.as) (by simp) («expr ≫ » (colimit.ι (discrete.functor f) _) g)\n  · obtain ⟨b, rfl⟩ := Set.mem_range.1 hZ\n    classical simpa using «expr ≫= » (sigma.ι f b) (huv (sigma.desc (Pi.single b g)))\n#align is_separator_sigma is_separator_sigma\n\n",
 "is_separator_op_iff":
 "theorem is_separator_op_iff (G : C) : IsSeparator (op G) ↔ IsCoseparator G := by\n  rw [is_separator, is_coseparator, ← is_separating_op_iff, Set.singleton_op]\n#align is_separator_op_iff is_separator_op_iff\n\n",
 "is_separator_iff_faithful_coyoneda_obj":
 "theorem is_separator_iff_faithful_coyoneda_obj (G : C) : IsSeparator G ↔ Faithful (coyoneda.obj (op G)) :=\n  ⟨fun hG => ⟨fun X Y f g hfg => hG.def _ _ (congr_fun hfg)⟩, fun h =>\n    (isSeparator_def _).2 fun X Y f g hfg => (coyoneda.obj (op G)).map_injective (funext hfg)⟩\n#align is_separator_iff_faithful_coyoneda_obj is_separator_iff_faithful_coyoneda_obj\n\n",
 "is_separator_iff_epi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫= » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem is_separator_iff_epi (G : C) [∀ A : C, HasCoproduct fun f : «expr ⟶ » G A => G] :\n    IsSeparator G ↔ ∀ A : C, Epi (Sigma.desc fun f : «expr ⟶ » G A => f) :=\n  by\n  rw [is_separator_def]\n  refine' ⟨fun h A => ⟨fun Z u v huv => h _ _ fun i => _⟩, fun h X Y f g hh => _⟩\n  · simpa using «expr ≫= » (sigma.ι _ i) huv\n  · haveI := h X\n    refine' (cancel_epi (sigma.desc fun f : «expr ⟶ » G X => f)).1 (colimit.hom_ext fun j => _)\n    simpa using hh j.as\n#align is_separator_iff_epi is_separator_iff_epi\n\n",
 "is_separator_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem is_separator_def (G : C) :\n    IsSeparator G ↔ ∀ ⦃X Y : C⦄ (f g : «expr ⟶ » X Y), (∀ h : «expr ⟶ » G X, «expr ≫ » h f = «expr ≫ » h g) → f = g :=\n  ⟨fun hG X Y f g hfg =>\n    hG _ _ fun H hH h => by\n      obtain rfl := Set.mem_singleton_iff.1 hH\n      exact hfg h,\n    fun hG X Y f g hfg => hG _ _ fun h => hfg _ (Set.mem_singleton _) _⟩\n#align is_separator_def is_separator_def\n\n",
 "is_separator_coprod_of_is_separator_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⨿ » -/\ntheorem is_separator_coprod_of_is_separator_right (G H : C) [HasBinaryCoproduct G H] (hH : IsSeparator H) :\n    IsSeparator («expr ⨿ » G H) :=\n  (isSeparator_coprod _ _).2 <| IsSeparating.mono hH <| by simp\n#align is_separator_coprod_of_is_separator_right is_separator_coprod_of_is_separator_right\n\n",
 "is_separator_coprod_of_is_separator_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⨿ » -/\ntheorem is_separator_coprod_of_is_separator_left (G H : C) [HasBinaryCoproduct G H] (hG : IsSeparator G) :\n    IsSeparator («expr ⨿ » G H) :=\n  (isSeparator_coprod _ _).2 <| IsSeparating.mono hG <| by simp\n#align is_separator_coprod_of_is_separator_left is_separator_coprod_of_is_separator_left\n\n",
 "is_separator_coprod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫= » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫= » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⨿ » -/\ntheorem is_separator_coprod (G H : C) [HasBinaryCoproduct G H] :\n    IsSeparator («expr ⨿ » G H) ↔ IsSeparating ({G, H} : Set C) :=\n  by\n  refine' ⟨fun h X Y u v huv => _, fun h => (is_separator_def _).2 fun X Y u v huv => h _ _ fun Z hZ g => _⟩\n  · refine' h.def _ _ fun g => coprod.hom_ext _ _\n    · simpa using huv G (by simp) («expr ≫ » coprod.inl g)\n    · simpa using huv H (by simp) («expr ≫ » coprod.inr g)\n  · simp only [Set.mem_insert_iff, Set.mem_singleton_iff] at hZ\n    rcases hZ with (rfl | rfl)\n    · simpa using «expr ≫= » coprod.inl (huv (coprod.desc g 0))\n    · simpa using «expr ≫= » coprod.inr (huv (coprod.desc 0 g))\n#align is_separator_coprod is_separator_coprod\n\n",
 "is_separator":
 "theorem is_detector.is_separator [HasEqualizers C] {G : C} : IsDetector G → IsSeparator G :=\n  IsDetecting.isSeparating\n#align is_detector.is_separator is_detector.is_separator\n\n",
 "is_separating_unop_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵖ» -/\ntheorem is_separating_unop_iff (𝒢 : Set («expr ᵒᵖ» C)) : IsSeparating 𝒢.unop ↔ IsCoseparating 𝒢 := by\n  rw [← is_coseparating_op_iff, Set.unop_op]\n#align is_separating_unop_iff is_separating_unop_iff\n\n",
 "is_separating_proj_preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem is_separating_proj_preimage {𝒢 : Set C} (h𝒢 : IsSeparating 𝒢) : IsSeparating («expr ⁻¹' » (proj S T).obj 𝒢) :=\n  by\n  refine' fun X Y f g hfg => ext _ _ (h𝒢 _ _ fun G hG h => _)\n  convert congr_arg comma_morphism.left (hfg (mk («expr ≫ » (S.map h) X.hom)) hG (hom_mk h rfl))\n#align is_separating_proj_preimage is_separating_proj_preimage\n\n",
 "is_separating_op_iff":
 "/-\nCopyright (c) 2022 Markus Himmel. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Markus Himmel\n-/\ntheorem is_separating_op_iff (𝒢 : Set C) : IsSeparating 𝒢.op ↔ IsCoseparating 𝒢 :=\n  by\n  refine' ⟨fun h𝒢 X Y f g hfg => _, fun h𝒢 X Y f g hfg => _⟩\n  · refine' Quiver.Hom.op_inj (h𝒢 _ _ fun G hG h => Quiver.Hom.unop_inj _)\n    simpa only [unop_comp, Quiver.Hom.unop_op] using hfg _ (Set.mem_op.1 hG) _\n  · refine' Quiver.Hom.unop_inj (h𝒢 _ _ fun G hG h => Quiver.Hom.op_inj _)\n    simpa only [op_comp, Quiver.Hom.op_unop] using hfg _ (Set.op_mem_op.2 hG) _\n#align is_separating_op_iff is_separating_op_iff\n\n",
 "is_separating_iff_epi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫= » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem is_separating_iff_epi (𝒢 : Set C) [∀ A : C, HasCoproduct fun f : ΣG : 𝒢, «expr ⟶ » (G : C) A => (f.1 : C)] :\n    IsSeparating 𝒢 ↔ ∀ A : C, Epi (Sigma.desc (@Sigma.snd 𝒢 fun G => «expr ⟶ » (G : C) A)) :=\n  by\n  refine' ⟨fun h A => ⟨fun Z u v huv => h _ _ fun G hG f => _⟩, fun h X Y f g hh => _⟩\n  · simpa using «expr ≫= » (sigma.ι (fun f : ΣG : 𝒢, «expr ⟶ » (G : C) A => (f.1 : C)) ⟨⟨G, hG⟩, f⟩) huv\n  · haveI := h X\n    refine' (cancel_epi (sigma.desc (@Sigma.snd 𝒢 fun G => «expr ⟶ » (G : C) X))).1 (colimit.hom_ext fun j => _)\n    simpa using hh j.as.1.1 j.as.1.2 j.as.2\n#align is_separating_iff_epi is_separating_iff_epi\n\n",
 "is_separating_empty_of_thin":
 "theorem is_separating_empty_of_thin [Quiver.IsThin C] : IsSeparating (∅ : Set C) := fun X Y f g hfg =>\n  subsingleton.elim _ _\n#align is_separating_empty_of_thin is_separating_empty_of_thin\n\n",
 "is_separating":
 "theorem is_detecting.is_separating [HasEqualizers C] {𝒢 : Set C} (h𝒢 : IsDetecting 𝒢) : IsSeparating 𝒢 :=\n  fun X Y f g hfg =>\n  have : IsIso (equalizer.ι f g) := h𝒢 _ fun G hG h => equalizer.existsUnique _ (hfg _ hG _)\n  eq_of_epi_equalizer\n#align is_detecting.is_separating is_detecting.is_separating\n\n",
 "is_detector_unop_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵖ» -/\ntheorem is_detector_unop_iff (G : «expr ᵒᵖ» C) : IsDetector (unop G) ↔ IsCodetector G := by\n  rw [is_detector, is_codetector, ← is_detecting_unop_iff, Set.singleton_unop]\n#align is_detector_unop_iff is_detector_unop_iff\n\n",
 "is_detector_op_iff":
 "theorem is_detector_op_iff (G : C) : IsDetector (op G) ↔ IsCodetector G := by\n  rw [is_detector, is_codetector, ← is_detecting_op_iff, Set.singleton_op]\n#align is_detector_op_iff is_detector_op_iff\n\n",
 "is_detector_iff_reflects_isomorphisms_coyoneda_obj":
 "theorem is_detector_iff_reflects_isomorphisms_coyoneda_obj (G : C) :\n    IsDetector G ↔ ReflectsIsomorphisms (coyoneda.obj (op G)) :=\n  by\n  refine' ⟨fun hG => ⟨fun X Y f hf => hG.def _ fun h => _⟩, fun h => (is_detector_def _).2 fun X Y f hf => _⟩\n  · rw [is_iso_iff_bijective, Function.bijective_iff_existsUnique] at hf\n    exact hf h\n  · suffices is_iso ((coyoneda.obj (op G)).map f) by\n      exact @is_iso_of_reflects_iso _ _ _ _ _ _ _ (coyoneda.obj (op G)) _ h\n    rwa [is_iso_iff_bijective, Function.bijective_iff_existsUnique]\n#align is_detector_iff_reflects_isomorphisms_coyoneda_obj is_detector_iff_reflects_isomorphisms_coyoneda_obj\n\n",
 "is_detector_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem is_detector_def (G : C) :\n    IsDetector G ↔ ∀ ⦃X Y : C⦄ (f : «expr ⟶ » X Y), (∀ h : «expr ⟶ » G Y, ∃! h', «expr ≫ » h' f = h) → IsIso f :=\n  ⟨fun hG X Y f hf =>\n    hG _ fun H hH h => by\n      obtain rfl := Set.mem_singleton_iff.1 hH\n      exact hf h,\n    fun hG X Y f hf => hG _ fun h => hf _ (Set.mem_singleton _) _⟩\n#align is_detector_def is_detector_def\n\n",
 "is_detector":
 "theorem is_separator.is_detector [Balanced C] {G : C} : IsSeparator G → IsDetector G :=\n  IsSeparating.isDetecting\n#align is_separator.is_detector is_separator.is_detector\n\n",
 "is_detecting_unop_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵖ» -/\ntheorem is_detecting_unop_iff (𝒢 : Set («expr ᵒᵖ» C)) : IsDetecting 𝒢.unop ↔ IsCodetecting 𝒢 := by\n  rw [← is_codetecting_op_iff, Set.unop_op]\n#align is_detecting_unop_iff is_detecting_unop_iff\n\n",
 "is_detecting_op_iff":
 "theorem is_detecting_op_iff (𝒢 : Set C) : IsDetecting 𝒢.op ↔ IsCodetecting 𝒢 :=\n  by\n  refine' ⟨fun h𝒢 X Y f hf => _, fun h𝒢 X Y f hf => _⟩\n  · refine' (is_iso_op_iff _).1 (h𝒢 _ fun G hG h => _)\n    obtain ⟨t, ht, ht'⟩ := hf (unop G) (Set.mem_op.1 hG) h.unop\n    exact ⟨t.op, Quiver.Hom.unop_inj ht, fun y hy => Quiver.Hom.unop_inj (ht' _ (Quiver.Hom.op_inj hy))⟩\n  · refine' (is_iso_unop_iff _).1 (h𝒢 _ fun G hG h => _)\n    obtain ⟨t, ht, ht'⟩ := hf (op G) (Set.op_mem_op.2 hG) h.op\n    refine' ⟨t.unop, Quiver.Hom.op_inj ht, fun y hy => Quiver.Hom.op_inj (ht' _ _)⟩\n    exact Quiver.Hom.unop_inj (by simpa only using hy)\n#align is_detecting_op_iff is_detecting_op_iff\n\n",
 "is_detecting_iff_is_separating":
 "theorem is_detecting_iff_is_separating [HasEqualizers C] [Balanced C] (𝒢 : Set C) : IsDetecting 𝒢 ↔ IsSeparating 𝒢 :=\n  ⟨IsDetecting.isSeparating, IsSeparating.isDetecting⟩\n#align is_detecting_iff_is_separating is_detecting_iff_is_separating\n\n",
 "is_detecting_empty_of_groupoid":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem is_detecting_empty_of_groupoid [∀ {X Y : C} (f : «expr ⟶ » X Y), IsIso f] : IsDetecting (∅ : Set C) :=\n  fun X Y f hf => inferInstance\n#align is_detecting_empty_of_groupoid is_detecting_empty_of_groupoid\n\n",
 "is_detecting":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem is_separating.is_detecting [Balanced C] {𝒢 : Set C} (h𝒢 : IsSeparating 𝒢) : IsDetecting 𝒢 :=\n  by\n  intro X Y f hf\n  refine' (is_iso_iff_mono_and_epi _).2 ⟨⟨fun Z g h hgh => h𝒢 _ _ fun G hG i => _⟩, ⟨fun Z g h hgh => _⟩⟩\n  · obtain ⟨t, -, ht⟩ := hf G hG («expr ≫ » i («expr ≫ » g f))\n    rw [ht («expr ≫ » i g) (category.assoc _ _ _), ht («expr ≫ » i h) (hgh.symm ▸ category.assoc _ _ _)]\n  · refine' h𝒢 _ _ fun G hG i => _\n    obtain ⟨t, rfl, -⟩ := hf G hG i\n    rw [category.assoc, hgh, category.assoc]\n#align is_separating.is_detecting is_separating.is_detecting\n\n",
 "is_coseparator_unop_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵖ» -/\ntheorem is_coseparator_unop_iff (G : «expr ᵒᵖ» C) : IsCoseparator (unop G) ↔ IsSeparator G := by\n  rw [is_separator, is_coseparator, ← is_coseparating_unop_iff, Set.singleton_unop]\n#align is_coseparator_unop_iff is_coseparator_unop_iff\n\n",
 "is_coseparator_prod_of_is_coseparator_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⨯ » -/\ntheorem is_coseparator_prod_of_is_coseparator_right (G H : C) [HasBinaryProduct G H] (hH : IsCoseparator H) :\n    IsCoseparator («expr ⨯ » G H) :=\n  (isCoseparator_prod _ _).2 <| IsCoseparating.mono hH <| by simp\n#align is_coseparator_prod_of_is_coseparator_right is_coseparator_prod_of_is_coseparator_right\n\n",
 "is_coseparator_prod_of_is_coseparator_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⨯ » -/\ntheorem is_coseparator_prod_of_is_coseparator_left (G H : C) [HasBinaryProduct G H] (hG : IsCoseparator G) :\n    IsCoseparator («expr ⨯ » G H) :=\n  (isCoseparator_prod _ _).2 <| IsCoseparating.mono hG <| by simp\n#align is_coseparator_prod_of_is_coseparator_left is_coseparator_prod_of_is_coseparator_left\n\n",
 "is_coseparator_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⨯ » -/\ntheorem is_coseparator_prod (G H : C) [HasBinaryProduct G H] :\n    IsCoseparator («expr ⨯ » G H) ↔ IsCoseparating ({G, H} : Set C) :=\n  by\n  refine' ⟨fun h X Y u v huv => _, fun h => (is_coseparator_def _).2 fun X Y u v huv => h _ _ fun Z hZ g => _⟩\n  · refine' h.def _ _ fun g => prod.hom_ext _ _\n    · simpa using huv G (by simp) («expr ≫ » g limits.prod.fst)\n    · simpa using huv H (by simp) («expr ≫ » g limits.prod.snd)\n  · simp only [Set.mem_insert_iff, Set.mem_singleton_iff] at hZ\n    rcases hZ with (rfl | rfl)\n    · simpa using «expr =≫ » (huv (prod.lift g 0)) limits.prod.fst\n    · simpa using «expr =≫ » (huv (prod.lift 0 g)) limits.prod.snd\n#align is_coseparator_prod is_coseparator_prod\n\n",
 "is_coseparator_pi_of_is_coseparator":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∏ » -/\ntheorem is_coseparator_pi_of_is_coseparator {β : Type w} (f : β → C) [HasProduct f] (b : β) (hb : IsCoseparator (f b)) :\n    IsCoseparator («expr∏ » f) :=\n  (isCoseparator_pi _).2 <| IsCoseparating.mono hb <| by simp\n#align is_coseparator_pi_of_is_coseparator is_coseparator_pi_of_is_coseparator\n\n",
 "is_coseparator_pi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∏ » -/\ntheorem is_coseparator_pi {β : Type w} (f : β → C) [HasProduct f] :\n    IsCoseparator («expr∏ » f) ↔ IsCoseparating (Set.range f) :=\n  by\n  refine' ⟨fun h X Y u v huv => _, fun h => (is_coseparator_def _).2 fun X Y u v huv => h _ _ fun Z hZ g => _⟩\n  · refine' h.def _ _ fun g => limit.hom_ext fun b => _\n    simpa using huv (f b.as) (by simp) («expr ≫ » g (limit.π (discrete.functor f) _))\n  · obtain ⟨b, rfl⟩ := Set.mem_range.1 hZ\n    classical simpa using «expr =≫ » (huv (pi.lift (Pi.single b g))) (pi.π f b)\n#align is_coseparator_pi is_coseparator_pi\n\n",
 "is_coseparator_op_iff":
 "theorem is_coseparator_op_iff (G : C) : IsCoseparator (op G) ↔ IsSeparator G := by\n  rw [is_separator, is_coseparator, ← is_coseparating_op_iff, Set.singleton_op]\n#align is_coseparator_op_iff is_coseparator_op_iff\n\n",
 "is_coseparator_iff_mono":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem is_coseparator_iff_mono (G : C) [∀ A : C, HasProduct fun f : «expr ⟶ » A G => G] :\n    IsCoseparator G ↔ ∀ A : C, Mono (Pi.lift fun f : «expr ⟶ » A G => f) :=\n  by\n  rw [is_coseparator_def]\n  refine' ⟨fun h A => ⟨fun Z u v huv => h _ _ fun i => _⟩, fun h X Y f g hh => _⟩\n  · simpa using «expr =≫ » huv (pi.π _ i)\n  · haveI := h Y\n    refine' (cancel_mono (pi.lift fun f : «expr ⟶ » Y G => f)).1 (limit.hom_ext fun j => _)\n    simpa using hh j.as\n#align is_coseparator_iff_mono is_coseparator_iff_mono\n\n",
 "is_coseparator_iff_faithful_yoneda_obj":
 "theorem is_coseparator_iff_faithful_yoneda_obj (G : C) : IsCoseparator G ↔ Faithful (yoneda.obj G) :=\n  ⟨fun hG => ⟨fun X Y f g hfg => Quiver.Hom.unop_inj (hG.def _ _ (congr_fun hfg))⟩, fun h =>\n    (isCoseparator_def _).2 fun X Y f g hfg => Quiver.Hom.op_inj <| (yoneda.obj G).map_injective (funext hfg)⟩\n#align is_coseparator_iff_faithful_yoneda_obj is_coseparator_iff_faithful_yoneda_obj\n\n",
 "is_coseparator_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem is_coseparator_def (G : C) :\n    IsCoseparator G ↔ ∀ ⦃X Y : C⦄ (f g : «expr ⟶ » X Y), (∀ h : «expr ⟶ » Y G, «expr ≫ » f h = «expr ≫ » g h) → f = g :=\n  ⟨fun hG X Y f g hfg =>\n    hG _ _ fun H hH h => by\n      obtain rfl := Set.mem_singleton_iff.1 hH\n      exact hfg h,\n    fun hG X Y f g hfg => hG _ _ fun h => hfg _ (Set.mem_singleton _) _⟩\n#align is_coseparator_def is_coseparator_def\n\n",
 "is_coseparator":
 "theorem is_codetector.is_coseparator [HasCoequalizers C] {G : C} : IsCodetector G → IsCoseparator G :=\n  IsCodetecting.isCoseparating\n#align is_codetector.is_coseparator is_codetector.is_coseparator\n\n",
 "is_coseparating_unop_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵖ» -/\ntheorem is_coseparating_unop_iff (𝒢 : Set («expr ᵒᵖ» C)) : IsCoseparating 𝒢.unop ↔ IsSeparating 𝒢 := by\n  rw [← is_separating_op_iff, Set.unop_op]\n#align is_coseparating_unop_iff is_coseparating_unop_iff\n\n",
 "is_coseparating_proj_preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem is_coseparating_proj_preimage {𝒢 : Set C} (h𝒢 : IsCoseparating 𝒢) :\n    IsCoseparating («expr ⁻¹' » (proj S T).obj 𝒢) :=\n  by\n  refine' fun X Y f g hfg => ext _ _ (h𝒢 _ _ fun G hG h => _)\n  exact congr_arg comma_morphism.right (hfg (mk («expr ≫ » Y.hom (T.map h))) hG (hom_mk h rfl))\n#align is_coseparating_proj_preimage is_coseparating_proj_preimage\n\n",
 "is_coseparating_op_iff":
 "theorem is_coseparating_op_iff (𝒢 : Set C) : IsCoseparating 𝒢.op ↔ IsSeparating 𝒢 :=\n  by\n  refine' ⟨fun h𝒢 X Y f g hfg => _, fun h𝒢 X Y f g hfg => _⟩\n  · refine' Quiver.Hom.op_inj (h𝒢 _ _ fun G hG h => Quiver.Hom.unop_inj _)\n    simpa only [unop_comp, Quiver.Hom.unop_op] using hfg _ (Set.mem_op.1 hG) _\n  · refine' Quiver.Hom.unop_inj (h𝒢 _ _ fun G hG h => Quiver.Hom.op_inj _)\n    simpa only [op_comp, Quiver.Hom.op_unop] using hfg _ (Set.op_mem_op.2 hG) _\n#align is_coseparating_op_iff is_coseparating_op_iff\n\n",
 "is_coseparating_iff_mono":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem is_coseparating_iff_mono (𝒢 : Set C) [∀ A : C, HasProduct fun f : ΣG : 𝒢, «expr ⟶ » A (G : C) => (f.1 : C)] :\n    IsCoseparating 𝒢 ↔ ∀ A : C, Mono (Pi.lift (@Sigma.snd 𝒢 fun G => «expr ⟶ » A (G : C))) :=\n  by\n  refine' ⟨fun h A => ⟨fun Z u v huv => h _ _ fun G hG f => _⟩, fun h X Y f g hh => _⟩\n  · simpa using «expr =≫ » huv (pi.π (fun f : ΣG : 𝒢, «expr ⟶ » A (G : C) => (f.1 : C)) ⟨⟨G, hG⟩, f⟩)\n  · haveI := h Y\n    refine' (cancel_mono (pi.lift (@Sigma.snd 𝒢 fun G => «expr ⟶ » Y (G : C)))).1 (limit.hom_ext fun j => _)\n    simpa using hh j.as.1.1 j.as.1.2 j.as.2\n#align is_coseparating_iff_mono is_coseparating_iff_mono\n\n",
 "is_coseparating_empty_of_thin":
 "theorem is_coseparating_empty_of_thin [Quiver.IsThin C] : IsCoseparating (∅ : Set C) := fun X Y f g hfg =>\n  subsingleton.elim _ _\n#align is_coseparating_empty_of_thin is_coseparating_empty_of_thin\n\n",
 "is_coseparating":
 "theorem is_codetecting.is_coseparating [HasCoequalizers C] {𝒢 : Set C} : IsCodetecting 𝒢 → IsCoseparating 𝒢 := by\n  simpa only [← is_separating_op_iff, ← is_detecting_op_iff] using is_detecting.is_separating\n#align is_codetecting.is_coseparating is_codetecting.is_coseparating\n\n",
 "is_codetector_unop_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵖ» -/\ntheorem is_codetector_unop_iff (G : «expr ᵒᵖ» C) : IsCodetector (unop G) ↔ IsDetector G := by\n  rw [is_detector, is_codetector, ← is_codetecting_unop_iff, Set.singleton_unop]\n#align is_codetector_unop_iff is_codetector_unop_iff\n\n",
 "is_codetector_op_iff":
 "theorem is_codetector_op_iff (G : C) : IsCodetector (op G) ↔ IsDetector G := by\n  rw [is_detector, is_codetector, ← is_codetecting_op_iff, Set.singleton_op]\n#align is_codetector_op_iff is_codetector_op_iff\n\n",
 "is_codetector_iff_reflects_isomorphisms_yoneda_obj":
 "theorem is_codetector_iff_reflects_isomorphisms_yoneda_obj (G : C) :\n    IsCodetector G ↔ ReflectsIsomorphisms (yoneda.obj G) :=\n  by\n  refine' ⟨fun hG => ⟨fun X Y f hf => _⟩, fun h => (is_codetector_def _).2 fun X Y f hf => _⟩\n  · refine' (is_iso_unop_iff _).1 (hG.def _ _)\n    rwa [is_iso_iff_bijective, Function.bijective_iff_existsUnique] at hf\n  · rw [← is_iso_op_iff]\n    suffices is_iso ((yoneda.obj G).map f.op) by exact @is_iso_of_reflects_iso _ _ _ _ _ _ _ (yoneda.obj G) _ h\n    rwa [is_iso_iff_bijective, Function.bijective_iff_existsUnique]\n#align is_codetector_iff_reflects_isomorphisms_yoneda_obj is_codetector_iff_reflects_isomorphisms_yoneda_obj\n\n",
 "is_codetector_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem is_codetector_def (G : C) :\n    IsCodetector G ↔ ∀ ⦃X Y : C⦄ (f : «expr ⟶ » X Y), (∀ h : «expr ⟶ » X G, ∃! h', «expr ≫ » f h' = h) → IsIso f :=\n  ⟨fun hG X Y f hf =>\n    hG _ fun H hH h => by\n      obtain rfl := Set.mem_singleton_iff.1 hH\n      exact hf h,\n    fun hG X Y f hf => hG _ fun h => hf _ (Set.mem_singleton _) _⟩\n#align is_codetector_def is_codetector_def\n\n",
 "is_codetector":
 "theorem is_cospearator.is_codetector [Balanced C] {G : C} : IsCoseparator G → IsCodetector G :=\n  IsCoseparating.isCodetecting\n#align is_cospearator.is_codetector is_cospearator.is_codetector\n\n",
 "is_codetecting_unop_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵖ» -/\ntheorem is_codetecting_unop_iff {𝒢 : Set («expr ᵒᵖ» C)} : IsCodetecting 𝒢.unop ↔ IsDetecting 𝒢 := by\n  rw [← is_detecting_op_iff, Set.unop_op]\n#align is_codetecting_unop_iff is_codetecting_unop_iff\n\n",
 "is_codetecting_op_iff":
 "theorem is_codetecting_op_iff (𝒢 : Set C) : IsCodetecting 𝒢.op ↔ IsDetecting 𝒢 :=\n  by\n  refine' ⟨fun h𝒢 X Y f hf => _, fun h𝒢 X Y f hf => _⟩\n  · refine' (is_iso_op_iff _).1 (h𝒢 _ fun G hG h => _)\n    obtain ⟨t, ht, ht'⟩ := hf (unop G) (Set.mem_op.1 hG) h.unop\n    exact ⟨t.op, Quiver.Hom.unop_inj ht, fun y hy => Quiver.Hom.unop_inj (ht' _ (Quiver.Hom.op_inj hy))⟩\n  · refine' (is_iso_unop_iff _).1 (h𝒢 _ fun G hG h => _)\n    obtain ⟨t, ht, ht'⟩ := hf (op G) (Set.op_mem_op.2 hG) h.op\n    refine' ⟨t.unop, Quiver.Hom.op_inj ht, fun y hy => Quiver.Hom.op_inj (ht' _ _)⟩\n    exact Quiver.Hom.unop_inj (by simpa only using hy)\n#align is_codetecting_op_iff is_codetecting_op_iff\n\n",
 "is_codetecting_iff_is_coseparating":
 "theorem is_codetecting_iff_is_coseparating [HasCoequalizers C] [Balanced C] {𝒢 : Set C} :\n    IsCodetecting 𝒢 ↔ IsCoseparating 𝒢 :=\n  ⟨IsCodetecting.isCoseparating, IsCoseparating.isCodetecting⟩\n#align is_codetecting_iff_is_coseparating is_codetecting_iff_is_coseparating\n\n",
 "is_codetecting_empty_of_groupoid":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem is_codetecting_empty_of_groupoid [∀ {X Y : C} (f : «expr ⟶ » X Y), IsIso f] : IsCodetecting (∅ : Set C) :=\n  fun X Y f hf => inferInstance\n#align is_codetecting_empty_of_groupoid is_codetecting_empty_of_groupoid\n\n",
 "is_codetecting":
 "theorem is_coseparating.is_codetecting [Balanced C] {𝒢 : Set C} : IsCoseparating 𝒢 → IsCodetecting 𝒢 := by\n  simpa only [← is_detecting_op_iff, ← is_separating_op_iff] using is_separating.is_detecting\n#align is_coseparating.is_codetecting is_coseparating.is_codetecting\n\n",
 "inf_eq_of_is_detecting":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\ntheorem inf_eq_of_is_detecting [HasPullbacks C] {𝒢 : Set C} (h𝒢 : IsDetecting 𝒢) {X : C} (P Q : Subobject X)\n    (h : ∀ G ∈ 𝒢, ∀ {f : «expr ⟶ » G X}, P.factors f → Q.factors f) : «expr ⊓ » P Q = P :=\n  eq_of_le_of_isDetecting h𝒢 _ _ inf_le_left fun G hG f hf => (inf_factors _).2 ⟨hf, h _ hG hf⟩\n#align inf_eq_of_is_detecting inf_eq_of_is_detecting\n\n",
 "has_terminal_of_is_separating":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵖ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵖ» -/\n/-- An ingredient of the proof of the Special Adjoint Functor Theorem: a cocomplete well-copowered\n    category with a small separating set has a terminal object.\n\n    In fact, it follows from the Special Adjoint Functor Theorem that `C` is already complete, see\n    `has_limits_of_has_colimits_of_is_separating`. -/\ntheorem has_terminal_of_is_separating [WellPowered («expr ᵒᵖ» C)] [HasColimits C] {𝒢 : Set C} [Small.{v₁} 𝒢]\n    (h𝒢 : IsSeparating 𝒢) : HasTerminal C :=\n  by\n  haveI : Small.{v₁} 𝒢.op := small_of_injective (Set.opEquiv_self 𝒢).injective\n  haveI : has_initial («expr ᵒᵖ» C) := has_initial_of_is_coseparating ((is_coseparating_op_iff _).2 h𝒢)\n  exact has_terminal_of_has_initial_op\n#align has_terminal_of_is_separating has_terminal_of_is_separating\n\n",
 "has_initial_of_is_coseparating":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/-- An ingredient of the proof of the Special Adjoint Functor Theorem: a complete well-powered\n    category with a small coseparating set has an initial object.\n\n    In fact, it follows from the Special Adjoint Functor Theorem that `C` is already cocomplete,\n    see `has_colimits_of_has_limits_of_is_coseparating`. -/\ntheorem has_initial_of_is_coseparating [WellPowered C] [HasLimits C] {𝒢 : Set C} [Small.{v₁} 𝒢]\n    (h𝒢 : IsCoseparating 𝒢) : HasInitial C :=\n  by\n  haveI := has_products_of_shape_of_small C 𝒢\n  haveI := fun A => hasProductsOfShape_of_small.{v₁} C (ΣG : 𝒢, «expr ⟶ » A (G : C))\n  letI := completeLatticeOfCompleteSemilatticeInf (subobject (pi_obj (coe : 𝒢 → C)))\n  suffices ∀ A : C, Unique («expr ⟶ » ((«expr⊥» : subobject (pi_obj (coe : 𝒢 → C))) : C) A) by\n    exact has_initial_of_unique ((«expr⊥» : subobject (pi_obj (coe : 𝒢 → C))) : C)\n  refine' fun A => ⟨⟨_⟩, fun f => _⟩\n  · let s := pi.lift fun f : ΣG : 𝒢, «expr ⟶ » A (G : C) => id (pi.π (coe : 𝒢 → C)) f.1\n    let t := pi.lift (@Sigma.snd 𝒢 fun G => «expr ⟶ » A (G : C))\n    haveI : mono t := (is_coseparating_iff_mono 𝒢).1 h𝒢 A\n    exact «expr ≫ » (subobject.of_le_mk _ (pullback.fst : «expr ⟶ » (pullback s t) _) bot_le) pullback.snd\n  · generalize default = g\n    suffices is_split_epi (equalizer.ι f g) by exact eq_of_epi_equalizer\n    exact\n      is_split_epi.mk'\n        ⟨subobject.of_le_mk _ («expr ≫ » (equalizer.ι f g) (subobject.arrow _)) bot_le,\n          by\n          ext\n          simp⟩\n#align has_initial_of_is_coseparating has_initial_of_is_coseparating\n\n",
 "groupoid_of_is_detecting_empty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem groupoid_of_is_detecting_empty (h : IsDetecting (∅ : Set C)) {X Y : C} (f : «expr ⟶ » X Y) : IsIso f :=\n  h _ fun G => false.elim\n#align groupoid_of_is_detecting_empty groupoid_of_is_detecting_empty\n\n",
 "groupoid_of_is_codetecting_empty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem groupoid_of_is_codetecting_empty (h : IsCodetecting (∅ : Set C)) {X Y : C} (f : «expr ⟶ » X Y) : IsIso f :=\n  h _ fun G => false.elim\n#align groupoid_of_is_codetecting_empty groupoid_of_is_codetecting_empty\n\n",
 "eq_of_le_of_is_detecting":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem eq_of_le_of_is_detecting {𝒢 : Set C} (h𝒢 : IsDetecting 𝒢) {X : C} (P Q : Subobject X) (h₁ : P ≤ Q)\n    (h₂ : ∀ G ∈ 𝒢, ∀ {f : «expr ⟶ » G X}, Q.factors f → P.factors f) : P = Q :=\n  by\n  suffices is_iso (of_le _ _ h₁) by exact le_antisymm h₁ (le_of_comm (inv (of_le _ _ h₁)) (by simp))\n  refine' h𝒢 _ fun G hG f => _\n  have : P.factors («expr ≫ » f Q.arrow) := h₂ _ hG ((factors_iff _ _).2 ⟨_, rfl⟩)\n  refine' ⟨factor_thru _ _ this, _, fun g (hg : «expr ≫ » g _ = f) => _⟩\n  · simp only [← cancel_mono Q.arrow, category.assoc, of_le_arrow, factor_thru_arrow]\n  ·\n    simp only [← cancel_mono (subobject.of_le _ _ h₁), ← cancel_mono Q.arrow, hg, category.assoc, of_le_arrow,\n      factor_thru_arrow]\n#align eq_of_le_of_is_detecting eq_of_le_of_is_detecting\n\n",
 "eq_of_is_detecting":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem eq_of_is_detecting [HasPullbacks C] {𝒢 : Set C} (h𝒢 : IsDetecting 𝒢) {X : C} (P Q : Subobject X)\n    (h : ∀ G ∈ 𝒢, ∀ {f : «expr ⟶ » G X}, P.factors f ↔ Q.factors f) : P = Q :=\n  calc\n    P = «expr ⊓ » P Q := Eq.symm <| inf_eq_of_isDetecting h𝒢 _ _ fun G hG f hf => (h G hG).1 hf\n    _ = «expr ⊓ » Q P := inf_comm\n    _ = Q := inf_eq_of_isDetecting h𝒢 _ _ fun G hG f hf => (h G hG).2 hf\n    \n#align eq_of_is_detecting eq_of_is_detecting\n\n",
 "def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem is_codetector.def {G : C} :\n    IsCodetector G → ∀ ⦃X Y : C⦄ (f : «expr ⟶ » X Y), (∀ h : «expr ⟶ » X G, ∃! h', «expr ≫ » f h' = h) → IsIso f :=\n  (isCodetector_def _).1\n#align is_codetector.def is_codetector.def\n\n"}