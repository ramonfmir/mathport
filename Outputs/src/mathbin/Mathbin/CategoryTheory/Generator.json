{"well_powered_of_is_detector":
 "theorem well_powered_of_is_detector [has_pullbacks C] (G : C) (hG : is_detector G) : well_powered C :=\n  well_powered_of_is_detecting hG\n#align well_powered_of_is_detector well_powered_of_is_detector\n\n",
 "well_powered_of_is_detecting":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/-- A category with pullbacks and a small detecting set is well-powered. -/\ntheorem well_powered_of_is_detecting [has_pullbacks C] {ğ’¢ : set C} [Small.{vâ‚} ğ’¢] (hğ’¢ : is_detecting ğ’¢) :\n    well_powered C :=\n  âŸ¨fun X =>\n    @small_of_injective _ _ _ (fun P : subobject X => { f : Î£G : ğ’¢, Â«expr âŸ¶ Â» G.1 X | P.factors f.2 }) fun P Q h =>\n      subobject.eq_of_is_detecting hğ’¢ _ _ (by simpa [Set.ext_iff] using h)âŸ©\n#align well_powered_of_is_detecting well_powered_of_is_detecting\n\n",
 "thin_of_is_separating_empty":
 "theorem thin_of_is_separating_empty (h : is_separating (âˆ… : set C)) : Quiver.IsThin C := fun _ _ =>\n  âŸ¨fun f g => h _ _ fun G => false.elimâŸ©\n#align thin_of_is_separating_empty thin_of_is_separating_empty\n\n",
 "thin_of_is_coseparating_empty":
 "theorem thin_of_is_coseparating_empty (h : is_coseparating (âˆ… : set C)) : Quiver.IsThin C := fun _ _ =>\n  âŸ¨fun f g => h _ _ fun G => false.elimâŸ©\n#align thin_of_is_coseparating_empty thin_of_is_coseparating_empty\n\n",
 "mono":
 "theorem is_codetecting.mono {ğ’¢ : set C} (hğ’¢ : is_codetecting ğ’¢) {â„‹ : set C} (hğ’¢â„‹ : ğ’¢ âŠ† â„‹) : is_codetecting â„‹ :=\n  fun X Y f hf => hğ’¢ _ fun G hG h => hf _ (hğ’¢â„‹ hG) _\n#align is_codetecting.mono is_codetecting.mono\n\n",
 "is_separator_unop_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr áµ’áµ–Â» -/\ntheorem is_separator_unop_iff (G : Â«expr áµ’áµ–Â» C) : is_separator (unop G) â†” is_coseparator G := by\n  rw [is_separator, is_coseparator, â† is_separating_unop_iff, set.singleton_unop]\n#align is_separator_unop_iff is_separator_unop_iff\n\n",
 "is_separator_sigma_of_is_separator":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ Â» -/\ntheorem is_separator_sigma_of_is_separator {Î² : Type w} (f : Î² â†’ C) [has_coproduct f] (b : Î²)\n    (hb : is_separator (f b)) : is_separator (Â«exprâˆ Â» f) :=\n  (is_separator_sigma _).2 <| is_separating.mono hb <| by simp\n#align is_separator_sigma_of_is_separator is_separator_sigma_of_is_separator\n\n",
 "is_separator_sigma":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰«= Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ Â» -/\ntheorem is_separator_sigma {Î² : Type w} (f : Î² â†’ C) [has_coproduct f] :\n    is_separator (Â«exprâˆ Â» f) â†” is_separating (Set.range f) :=\n  by\n  refine' âŸ¨fun h X Y u v huv => _, fun h => (is_separator_def _).2 fun X Y u v huv => h _ _ fun Z hZ g => _âŸ©\n  Â· refine' h.def _ _ fun g => colimit.hom_ext fun b => _\n    simpa using huv (f b.as) (by simp) (Â«expr â‰« Â» (colimit.Î¹ (discrete.functor f) _) g)\n  Â· obtain âŸ¨b, rflâŸ© := Set.mem_range.1 hZ\n    classical simpa using Â«expr â‰«= Â» (sigma.Î¹ f b) (huv (sigma.desc (Pi.single b g)))\n#align is_separator_sigma is_separator_sigma\n\n",
 "is_separator_op_iff":
 "theorem is_separator_op_iff (G : C) : is_separator (op G) â†” is_coseparator G := by\n  rw [is_separator, is_coseparator, â† is_separating_op_iff, set.singleton_op]\n#align is_separator_op_iff is_separator_op_iff\n\n",
 "is_separator_iff_faithful_coyoneda_obj":
 "theorem is_separator_iff_faithful_coyoneda_obj (G : C) : is_separator G â†” Faithful (coyoneda.obj (op G)) :=\n  âŸ¨fun hG => âŸ¨fun X Y f g hfg => hG.def _ _ (congr_fun hfg)âŸ©, fun h =>\n    (is_separator_def _).2 fun X Y f g hfg => (coyoneda.obj (op G)).map_injective (funext hfg)âŸ©\n#align is_separator_iff_faithful_coyoneda_obj is_separator_iff_faithful_coyoneda_obj\n\n",
 "is_separator_iff_epi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰«= Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem is_separator_iff_epi (G : C) [âˆ€ A : C, has_coproduct fun f : Â«expr âŸ¶ Â» G A => G] :\n    is_separator G â†” âˆ€ A : C, Epi (sigma.desc fun f : Â«expr âŸ¶ Â» G A => f) :=\n  by\n  rw [is_separator_def]\n  refine' âŸ¨fun h A => âŸ¨fun Z u v huv => h _ _ fun i => _âŸ©, fun h X Y f g hh => _âŸ©\n  Â· simpa using Â«expr â‰«= Â» (sigma.Î¹ _ i) huv\n  Â· haveI := h X\n    refine' (cancel_epi (sigma.desc fun f : Â«expr âŸ¶ Â» G X => f)).1 (colimit.hom_ext fun j => _)\n    simpa using hh j.as\n#align is_separator_iff_epi is_separator_iff_epi\n\n",
 "is_separator_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\ntheorem is_separator_def (G : C) :\n    is_separator G â†” âˆ€ â¦ƒX Y : Câ¦„ (f g : Â«expr âŸ¶ Â» X Y), (âˆ€ h : Â«expr âŸ¶ Â» G X, Â«expr â‰« Â» h f = Â«expr â‰« Â» h g) â†’ f = g :=\n  âŸ¨fun hG X Y f g hfg =>\n    hG _ _ fun H hH h => by\n      obtain rfl := Set.mem_singleton_iff.1 hH\n      exact hfg h,\n    fun hG X Y f g hfg => hG _ _ fun h => hfg _ (Set.mem_singleton _) _âŸ©\n#align is_separator_def is_separator_def\n\n",
 "is_separator_coprod_of_is_separator_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¨¿ Â» -/\ntheorem is_separator_coprod_of_is_separator_right (G H : C) [has_binary_coproduct G H] (hH : is_separator H) :\n    is_separator (Â«expr â¨¿ Â» G H) :=\n  (is_separator_coprod _ _).2 <| is_separating.mono hH <| by simp\n#align is_separator_coprod_of_is_separator_right is_separator_coprod_of_is_separator_right\n\n",
 "is_separator_coprod_of_is_separator_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¨¿ Â» -/\ntheorem is_separator_coprod_of_is_separator_left (G H : C) [has_binary_coproduct G H] (hG : is_separator G) :\n    is_separator (Â«expr â¨¿ Â» G H) :=\n  (is_separator_coprod _ _).2 <| is_separating.mono hG <| by simp\n#align is_separator_coprod_of_is_separator_left is_separator_coprod_of_is_separator_left\n\n",
 "is_separator_coprod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰«= Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰«= Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¨¿ Â» -/\ntheorem is_separator_coprod (G H : C) [has_binary_coproduct G H] :\n    is_separator (Â«expr â¨¿ Â» G H) â†” is_separating ({G, H} : set C) :=\n  by\n  refine' âŸ¨fun h X Y u v huv => _, fun h => (is_separator_def _).2 fun X Y u v huv => h _ _ fun Z hZ g => _âŸ©\n  Â· refine' h.def _ _ fun g => coprod.hom_ext _ _\n    Â· simpa using huv G (by simp) (Â«expr â‰« Â» coprod.inl g)\n    Â· simpa using huv H (by simp) (Â«expr â‰« Â» coprod.inr g)\n  Â· simp only [Set.mem_insert_iff, Set.mem_singleton_iff] at hZ\n    rcases hZ with (rfl | rfl)\n    Â· simpa using Â«expr â‰«= Â» coprod.inl (huv (coprod.desc g 0))\n    Â· simpa using Â«expr â‰«= Â» coprod.inr (huv (coprod.desc 0 g))\n#align is_separator_coprod is_separator_coprod\n\n",
 "is_separator":
 "theorem is_detector.is_separator [has_equalizers C] {G : C} : is_detector G â†’ is_separator G :=\n  is_detecting.is_separating\n#align is_detector.is_separator is_detector.is_separator\n\n",
 "is_separating_unop_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr áµ’áµ–Â» -/\ntheorem is_separating_unop_iff (ğ’¢ : set (Â«expr áµ’áµ–Â» C)) : is_separating ğ’¢.unop â†” is_coseparating ğ’¢ := by\n  rw [â† is_coseparating_op_iff, set.unop_op]\n#align is_separating_unop_iff is_separating_unop_iff\n\n",
 "is_separating_proj_preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\ntheorem is_separating_proj_preimage {ğ’¢ : set C} (hğ’¢ : is_separating ğ’¢) : is_separating (Â«expr â»Â¹' Â» (proj S T).obj ğ’¢) :=\n  by\n  refine' fun X Y f g hfg => ext _ _ (hğ’¢ _ _ fun G hG h => _)\n  convert congr_arg comma_morphism.left (hfg (mk (Â«expr â‰« Â» (S.map h) X.hom)) hG (hom_mk h rfl))\n#align is_separating_proj_preimage is_separating_proj_preimage\n\n",
 "is_separating_op_iff":
 "/-\nCopyright (c) 2022 Markus Himmel. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Markus Himmel\n-/\ntheorem is_separating_op_iff (ğ’¢ : set C) : is_separating ğ’¢.op â†” is_coseparating ğ’¢ :=\n  by\n  refine' âŸ¨fun hğ’¢ X Y f g hfg => _, fun hğ’¢ X Y f g hfg => _âŸ©\n  Â· refine' quiver.hom.op_inj (hğ’¢ _ _ fun G hG h => quiver.hom.unop_inj _)\n    simpa only [unop_comp, quiver.hom.unop_op] using hfg _ (set.mem_op.1 hG) _\n  Â· refine' quiver.hom.unop_inj (hğ’¢ _ _ fun G hG h => quiver.hom.op_inj _)\n    simpa only [op_comp, quiver.hom.op_unop] using hfg _ (set.op_mem_op.2 hG) _\n#align is_separating_op_iff is_separating_op_iff\n\n",
 "is_separating_iff_epi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰«= Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem is_separating_iff_epi (ğ’¢ : set C) [âˆ€ A : C, has_coproduct fun f : Î£G : ğ’¢, Â«expr âŸ¶ Â» (G : C) A => (f.1 : C)] :\n    is_separating ğ’¢ â†” âˆ€ A : C, Epi (sigma.desc (@sigma.snd ğ’¢ fun G => Â«expr âŸ¶ Â» (G : C) A)) :=\n  by\n  refine' âŸ¨fun h A => âŸ¨fun Z u v huv => h _ _ fun G hG f => _âŸ©, fun h X Y f g hh => _âŸ©\n  Â· simpa using Â«expr â‰«= Â» (sigma.Î¹ (fun f : Î£G : ğ’¢, Â«expr âŸ¶ Â» (G : C) A => (f.1 : C)) âŸ¨âŸ¨G, hGâŸ©, fâŸ©) huv\n  Â· haveI := h X\n    refine' (cancel_epi (sigma.desc (@sigma.snd ğ’¢ fun G => Â«expr âŸ¶ Â» (G : C) X))).1 (colimit.hom_ext fun j => _)\n    simpa using hh j.as.1.1 j.as.1.2 j.as.2\n#align is_separating_iff_epi is_separating_iff_epi\n\n",
 "is_separating_empty_of_thin":
 "theorem is_separating_empty_of_thin [Quiver.IsThin C] : is_separating (âˆ… : set C) := fun X Y f g hfg =>\n  subsingleton.elim _ _\n#align is_separating_empty_of_thin is_separating_empty_of_thin\n\n",
 "is_separating":
 "theorem is_detecting.is_separating [has_equalizers C] {ğ’¢ : set C} (hğ’¢ : is_detecting ğ’¢) : is_separating ğ’¢ :=\n  fun X Y f g hfg =>\n  have : IsIso (equalizer.Î¹ f g) := hğ’¢ _ fun G hG h => equalizer.exists_unique _ (hfg _ hG _)\n  eq_of_epi_equalizer\n#align is_detecting.is_separating is_detecting.is_separating\n\n",
 "is_detector_unop_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr áµ’áµ–Â» -/\ntheorem is_detector_unop_iff (G : Â«expr áµ’áµ–Â» C) : is_detector (unop G) â†” is_codetector G := by\n  rw [is_detector, is_codetector, â† is_detecting_unop_iff, set.singleton_unop]\n#align is_detector_unop_iff is_detector_unop_iff\n\n",
 "is_detector_op_iff":
 "theorem is_detector_op_iff (G : C) : is_detector (op G) â†” is_codetector G := by\n  rw [is_detector, is_codetector, â† is_detecting_op_iff, set.singleton_op]\n#align is_detector_op_iff is_detector_op_iff\n\n",
 "is_detector_iff_reflects_isomorphisms_coyoneda_obj":
 "theorem is_detector_iff_reflects_isomorphisms_coyoneda_obj (G : C) :\n    is_detector G â†” reflects_isomorphisms (coyoneda.obj (op G)) :=\n  by\n  refine' âŸ¨fun hG => âŸ¨fun X Y f hf => hG.def _ fun h => _âŸ©, fun h => (is_detector_def _).2 fun X Y f hf => _âŸ©\n  Â· rw [is_iso_iff_bijective, Function.bijective_iff_existsUnique] at hf\n    exact hf h\n  Â· suffices is_iso ((coyoneda.obj (op G)).map f) by\n      exact @is_iso_of_reflects_iso _ _ _ _ _ _ _ (coyoneda.obj (op G)) _ h\n    rwa [is_iso_iff_bijective, Function.bijective_iff_existsUnique]\n#align is_detector_iff_reflects_isomorphisms_coyoneda_obj is_detector_iff_reflects_isomorphisms_coyoneda_obj\n\n",
 "is_detector_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\ntheorem is_detector_def (G : C) :\n    is_detector G â†” âˆ€ â¦ƒX Y : Câ¦„ (f : Â«expr âŸ¶ Â» X Y), (âˆ€ h : Â«expr âŸ¶ Â» G Y, âˆƒ! h', Â«expr â‰« Â» h' f = h) â†’ IsIso f :=\n  âŸ¨fun hG X Y f hf =>\n    hG _ fun H hH h => by\n      obtain rfl := Set.mem_singleton_iff.1 hH\n      exact hf h,\n    fun hG X Y f hf => hG _ fun h => hf _ (Set.mem_singleton _) _âŸ©\n#align is_detector_def is_detector_def\n\n",
 "is_detector":
 "theorem is_separator.is_detector [balanced C] {G : C} : is_separator G â†’ is_detector G :=\n  is_separating.is_detecting\n#align is_separator.is_detector is_separator.is_detector\n\n",
 "is_detecting_unop_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr áµ’áµ–Â» -/\ntheorem is_detecting_unop_iff (ğ’¢ : set (Â«expr áµ’áµ–Â» C)) : is_detecting ğ’¢.unop â†” is_codetecting ğ’¢ := by\n  rw [â† is_codetecting_op_iff, set.unop_op]\n#align is_detecting_unop_iff is_detecting_unop_iff\n\n",
 "is_detecting_op_iff":
 "theorem is_detecting_op_iff (ğ’¢ : set C) : is_detecting ğ’¢.op â†” is_codetecting ğ’¢ :=\n  by\n  refine' âŸ¨fun hğ’¢ X Y f hf => _, fun hğ’¢ X Y f hf => _âŸ©\n  Â· refine' (is_iso_op_iff _).1 (hğ’¢ _ fun G hG h => _)\n    obtain âŸ¨t, ht, ht'âŸ© := hf (unop G) (set.mem_op.1 hG) h.unop\n    exact âŸ¨t.op, quiver.hom.unop_inj ht, fun y hy => quiver.hom.unop_inj (ht' _ (quiver.hom.op_inj hy))âŸ©\n  Â· refine' (is_iso_unop_iff _).1 (hğ’¢ _ fun G hG h => _)\n    obtain âŸ¨t, ht, ht'âŸ© := hf (op G) (set.op_mem_op.2 hG) h.op\n    refine' âŸ¨t.unop, quiver.hom.op_inj ht, fun y hy => quiver.hom.op_inj (ht' _ _)âŸ©\n    exact quiver.hom.unop_inj (by simpa only using hy)\n#align is_detecting_op_iff is_detecting_op_iff\n\n",
 "is_detecting_iff_is_separating":
 "theorem is_detecting_iff_is_separating [has_equalizers C] [balanced C] (ğ’¢ : set C) : is_detecting ğ’¢ â†” is_separating ğ’¢ :=\n  âŸ¨is_detecting.is_separating, is_separating.is_detectingâŸ©\n#align is_detecting_iff_is_separating is_detecting_iff_is_separating\n\n",
 "is_detecting_empty_of_groupoid":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem is_detecting_empty_of_groupoid [âˆ€ {X Y : C} (f : Â«expr âŸ¶ Â» X Y), IsIso f] : is_detecting (âˆ… : set C) :=\n  fun X Y f hf => infer_instance\n#align is_detecting_empty_of_groupoid is_detecting_empty_of_groupoid\n\n",
 "is_detecting":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\ntheorem is_separating.is_detecting [balanced C] {ğ’¢ : set C} (hğ’¢ : is_separating ğ’¢) : is_detecting ğ’¢ :=\n  by\n  intro X Y f hf\n  refine' (is_iso_iff_mono_and_epi _).2 âŸ¨âŸ¨fun Z g h hgh => hğ’¢ _ _ fun G hG i => _âŸ©, âŸ¨fun Z g h hgh => _âŸ©âŸ©\n  Â· obtain âŸ¨t, -, htâŸ© := hf G hG (Â«expr â‰« Â» i (Â«expr â‰« Â» g f))\n    rw [ht (Â«expr â‰« Â» i g) (category.assoc _ _ _), ht (Â«expr â‰« Â» i h) (hgh.symm â–¸ category.assoc _ _ _)]\n  Â· refine' hğ’¢ _ _ fun G hG i => _\n    obtain âŸ¨t, rfl, -âŸ© := hf G hG i\n    rw [category.assoc, hgh, category.assoc]\n#align is_separating.is_detecting is_separating.is_detecting\n\n",
 "is_coseparator_unop_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr áµ’áµ–Â» -/\ntheorem is_coseparator_unop_iff (G : Â«expr áµ’áµ–Â» C) : is_coseparator (unop G) â†” is_separator G := by\n  rw [is_separator, is_coseparator, â† is_coseparating_unop_iff, set.singleton_unop]\n#align is_coseparator_unop_iff is_coseparator_unop_iff\n\n",
 "is_coseparator_prod_of_is_coseparator_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¨¯ Â» -/\ntheorem is_coseparator_prod_of_is_coseparator_right (G H : C) [has_binary_product G H] (hH : is_coseparator H) :\n    is_coseparator (Â«expr â¨¯ Â» G H) :=\n  (is_coseparator_prod _ _).2 <| is_coseparating.mono hH <| by simp\n#align is_coseparator_prod_of_is_coseparator_right is_coseparator_prod_of_is_coseparator_right\n\n",
 "is_coseparator_prod_of_is_coseparator_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¨¯ Â» -/\ntheorem is_coseparator_prod_of_is_coseparator_left (G H : C) [has_binary_product G H] (hG : is_coseparator G) :\n    is_coseparator (Â«expr â¨¯ Â» G H) :=\n  (is_coseparator_prod _ _).2 <| is_coseparating.mono hG <| by simp\n#align is_coseparator_prod_of_is_coseparator_left is_coseparator_prod_of_is_coseparator_left\n\n",
 "is_coseparator_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr =â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr =â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¨¯ Â» -/\ntheorem is_coseparator_prod (G H : C) [has_binary_product G H] :\n    is_coseparator (Â«expr â¨¯ Â» G H) â†” is_coseparating ({G, H} : set C) :=\n  by\n  refine' âŸ¨fun h X Y u v huv => _, fun h => (is_coseparator_def _).2 fun X Y u v huv => h _ _ fun Z hZ g => _âŸ©\n  Â· refine' h.def _ _ fun g => prod.hom_ext _ _\n    Â· simpa using huv G (by simp) (Â«expr â‰« Â» g limits.prod.fst)\n    Â· simpa using huv H (by simp) (Â«expr â‰« Â» g limits.prod.snd)\n  Â· simp only [Set.mem_insert_iff, Set.mem_singleton_iff] at hZ\n    rcases hZ with (rfl | rfl)\n    Â· simpa using Â«expr =â‰« Â» (huv (prod.lift g 0)) limits.prod.fst\n    Â· simpa using Â«expr =â‰« Â» (huv (prod.lift 0 g)) limits.prod.snd\n#align is_coseparator_prod is_coseparator_prod\n\n",
 "is_coseparator_pi_of_is_coseparator":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ Â» -/\ntheorem is_coseparator_pi_of_is_coseparator {Î² : Type w} (f : Î² â†’ C) [has_product f] (b : Î²)\n    (hb : is_coseparator (f b)) : is_coseparator (Â«exprâˆ Â» f) :=\n  (is_coseparator_pi _).2 <| is_coseparating.mono hb <| by simp\n#align is_coseparator_pi_of_is_coseparator is_coseparator_pi_of_is_coseparator\n\n",
 "is_coseparator_pi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr =â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ Â» -/\ntheorem is_coseparator_pi {Î² : Type w} (f : Î² â†’ C) [has_product f] :\n    is_coseparator (Â«exprâˆ Â» f) â†” is_coseparating (Set.range f) :=\n  by\n  refine' âŸ¨fun h X Y u v huv => _, fun h => (is_coseparator_def _).2 fun X Y u v huv => h _ _ fun Z hZ g => _âŸ©\n  Â· refine' h.def _ _ fun g => limit.hom_ext fun b => _\n    simpa using huv (f b.as) (by simp) (Â«expr â‰« Â» g (limit.Ï€ (discrete.functor f) _))\n  Â· obtain âŸ¨b, rflâŸ© := Set.mem_range.1 hZ\n    classical simpa using Â«expr =â‰« Â» (huv (pi.lift (Pi.single b g))) (pi.Ï€ f b)\n#align is_coseparator_pi is_coseparator_pi\n\n",
 "is_coseparator_op_iff":
 "theorem is_coseparator_op_iff (G : C) : is_coseparator (op G) â†” is_separator G := by\n  rw [is_separator, is_coseparator, â† is_coseparating_op_iff, set.singleton_op]\n#align is_coseparator_op_iff is_coseparator_op_iff\n\n",
 "is_coseparator_iff_mono":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr =â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem is_coseparator_iff_mono (G : C) [âˆ€ A : C, has_product fun f : Â«expr âŸ¶ Â» A G => G] :\n    is_coseparator G â†” âˆ€ A : C, Mono (pi.lift fun f : Â«expr âŸ¶ Â» A G => f) :=\n  by\n  rw [is_coseparator_def]\n  refine' âŸ¨fun h A => âŸ¨fun Z u v huv => h _ _ fun i => _âŸ©, fun h X Y f g hh => _âŸ©\n  Â· simpa using Â«expr =â‰« Â» huv (pi.Ï€ _ i)\n  Â· haveI := h Y\n    refine' (cancel_mono (pi.lift fun f : Â«expr âŸ¶ Â» Y G => f)).1 (limit.hom_ext fun j => _)\n    simpa using hh j.as\n#align is_coseparator_iff_mono is_coseparator_iff_mono\n\n",
 "is_coseparator_iff_faithful_yoneda_obj":
 "theorem is_coseparator_iff_faithful_yoneda_obj (G : C) : is_coseparator G â†” Faithful (yoneda.obj G) :=\n  âŸ¨fun hG => âŸ¨fun X Y f g hfg => quiver.hom.unop_inj (hG.def _ _ (congr_fun hfg))âŸ©, fun h =>\n    (is_coseparator_def _).2 fun X Y f g hfg => quiver.hom.op_inj <| (yoneda.obj G).map_injective (funext hfg)âŸ©\n#align is_coseparator_iff_faithful_yoneda_obj is_coseparator_iff_faithful_yoneda_obj\n\n",
 "is_coseparator_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\ntheorem is_coseparator_def (G : C) :\n    is_coseparator G â†”\n      âˆ€ â¦ƒX Y : Câ¦„ (f g : Â«expr âŸ¶ Â» X Y), (âˆ€ h : Â«expr âŸ¶ Â» Y G, Â«expr â‰« Â» f h = Â«expr â‰« Â» g h) â†’ f = g :=\n  âŸ¨fun hG X Y f g hfg =>\n    hG _ _ fun H hH h => by\n      obtain rfl := Set.mem_singleton_iff.1 hH\n      exact hfg h,\n    fun hG X Y f g hfg => hG _ _ fun h => hfg _ (Set.mem_singleton _) _âŸ©\n#align is_coseparator_def is_coseparator_def\n\n",
 "is_coseparator":
 "theorem is_codetector.is_coseparator [has_coequalizers C] {G : C} : is_codetector G â†’ is_coseparator G :=\n  is_codetecting.is_coseparating\n#align is_codetector.is_coseparator is_codetector.is_coseparator\n\n",
 "is_coseparating_unop_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr áµ’áµ–Â» -/\ntheorem is_coseparating_unop_iff (ğ’¢ : set (Â«expr áµ’áµ–Â» C)) : is_coseparating ğ’¢.unop â†” is_separating ğ’¢ := by\n  rw [â† is_separating_op_iff, set.unop_op]\n#align is_coseparating_unop_iff is_coseparating_unop_iff\n\n",
 "is_coseparating_proj_preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\ntheorem is_coseparating_proj_preimage {ğ’¢ : set C} (hğ’¢ : is_coseparating ğ’¢) :\n    is_coseparating (Â«expr â»Â¹' Â» (proj S T).obj ğ’¢) :=\n  by\n  refine' fun X Y f g hfg => ext _ _ (hğ’¢ _ _ fun G hG h => _)\n  exact congr_arg comma_morphism.right (hfg (mk (Â«expr â‰« Â» Y.hom (T.map h))) hG (hom_mk h rfl))\n#align is_coseparating_proj_preimage is_coseparating_proj_preimage\n\n",
 "is_coseparating_op_iff":
 "theorem is_coseparating_op_iff (ğ’¢ : set C) : is_coseparating ğ’¢.op â†” is_separating ğ’¢ :=\n  by\n  refine' âŸ¨fun hğ’¢ X Y f g hfg => _, fun hğ’¢ X Y f g hfg => _âŸ©\n  Â· refine' quiver.hom.op_inj (hğ’¢ _ _ fun G hG h => quiver.hom.unop_inj _)\n    simpa only [unop_comp, quiver.hom.unop_op] using hfg _ (set.mem_op.1 hG) _\n  Â· refine' quiver.hom.unop_inj (hğ’¢ _ _ fun G hG h => quiver.hom.op_inj _)\n    simpa only [op_comp, quiver.hom.op_unop] using hfg _ (set.op_mem_op.2 hG) _\n#align is_coseparating_op_iff is_coseparating_op_iff\n\n",
 "is_coseparating_iff_mono":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr =â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem is_coseparating_iff_mono (ğ’¢ : set C) [âˆ€ A : C, has_product fun f : Î£G : ğ’¢, Â«expr âŸ¶ Â» A (G : C) => (f.1 : C)] :\n    is_coseparating ğ’¢ â†” âˆ€ A : C, Mono (pi.lift (@sigma.snd ğ’¢ fun G => Â«expr âŸ¶ Â» A (G : C))) :=\n  by\n  refine' âŸ¨fun h A => âŸ¨fun Z u v huv => h _ _ fun G hG f => _âŸ©, fun h X Y f g hh => _âŸ©\n  Â· simpa using Â«expr =â‰« Â» huv (pi.Ï€ (fun f : Î£G : ğ’¢, Â«expr âŸ¶ Â» A (G : C) => (f.1 : C)) âŸ¨âŸ¨G, hGâŸ©, fâŸ©)\n  Â· haveI := h Y\n    refine' (cancel_mono (pi.lift (@sigma.snd ğ’¢ fun G => Â«expr âŸ¶ Â» Y (G : C)))).1 (limit.hom_ext fun j => _)\n    simpa using hh j.as.1.1 j.as.1.2 j.as.2\n#align is_coseparating_iff_mono is_coseparating_iff_mono\n\n",
 "is_coseparating_empty_of_thin":
 "theorem is_coseparating_empty_of_thin [Quiver.IsThin C] : is_coseparating (âˆ… : set C) := fun X Y f g hfg =>\n  subsingleton.elim _ _\n#align is_coseparating_empty_of_thin is_coseparating_empty_of_thin\n\n",
 "is_coseparating":
 "theorem is_codetecting.is_coseparating [has_coequalizers C] {ğ’¢ : set C} : is_codetecting ğ’¢ â†’ is_coseparating ğ’¢ := by\n  simpa only [â† is_separating_op_iff, â† is_detecting_op_iff] using is_detecting.is_separating\n#align is_codetecting.is_coseparating is_codetecting.is_coseparating\n\n",
 "is_codetector_unop_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr áµ’áµ–Â» -/\ntheorem is_codetector_unop_iff (G : Â«expr áµ’áµ–Â» C) : is_codetector (unop G) â†” is_detector G := by\n  rw [is_detector, is_codetector, â† is_codetecting_unop_iff, set.singleton_unop]\n#align is_codetector_unop_iff is_codetector_unop_iff\n\n",
 "is_codetector_op_iff":
 "theorem is_codetector_op_iff (G : C) : is_codetector (op G) â†” is_detector G := by\n  rw [is_detector, is_codetector, â† is_codetecting_op_iff, set.singleton_op]\n#align is_codetector_op_iff is_codetector_op_iff\n\n",
 "is_codetector_iff_reflects_isomorphisms_yoneda_obj":
 "theorem is_codetector_iff_reflects_isomorphisms_yoneda_obj (G : C) :\n    is_codetector G â†” reflects_isomorphisms (yoneda.obj G) :=\n  by\n  refine' âŸ¨fun hG => âŸ¨fun X Y f hf => _âŸ©, fun h => (is_codetector_def _).2 fun X Y f hf => _âŸ©\n  Â· refine' (is_iso_unop_iff _).1 (hG.def _ _)\n    rwa [is_iso_iff_bijective, Function.bijective_iff_existsUnique] at hf\n  Â· rw [â† is_iso_op_iff]\n    suffices is_iso ((yoneda.obj G).map f.op) by exact @is_iso_of_reflects_iso _ _ _ _ _ _ _ (yoneda.obj G) _ h\n    rwa [is_iso_iff_bijective, Function.bijective_iff_existsUnique]\n#align is_codetector_iff_reflects_isomorphisms_yoneda_obj is_codetector_iff_reflects_isomorphisms_yoneda_obj\n\n",
 "is_codetector_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\ntheorem is_codetector_def (G : C) :\n    is_codetector G â†” âˆ€ â¦ƒX Y : Câ¦„ (f : Â«expr âŸ¶ Â» X Y), (âˆ€ h : Â«expr âŸ¶ Â» X G, âˆƒ! h', Â«expr â‰« Â» f h' = h) â†’ IsIso f :=\n  âŸ¨fun hG X Y f hf =>\n    hG _ fun H hH h => by\n      obtain rfl := Set.mem_singleton_iff.1 hH\n      exact hf h,\n    fun hG X Y f hf => hG _ fun h => hf _ (Set.mem_singleton _) _âŸ©\n#align is_codetector_def is_codetector_def\n\n",
 "is_codetector":
 "theorem is_cospearator.is_codetector [balanced C] {G : C} : is_coseparator G â†’ is_codetector G :=\n  is_coseparating.is_codetecting\n#align is_cospearator.is_codetector is_cospearator.is_codetector\n\n",
 "is_codetecting_unop_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr áµ’áµ–Â» -/\ntheorem is_codetecting_unop_iff {ğ’¢ : set (Â«expr áµ’áµ–Â» C)} : is_codetecting ğ’¢.unop â†” is_detecting ğ’¢ := by\n  rw [â† is_detecting_op_iff, set.unop_op]\n#align is_codetecting_unop_iff is_codetecting_unop_iff\n\n",
 "is_codetecting_op_iff":
 "theorem is_codetecting_op_iff (ğ’¢ : set C) : is_codetecting ğ’¢.op â†” is_detecting ğ’¢ :=\n  by\n  refine' âŸ¨fun hğ’¢ X Y f hf => _, fun hğ’¢ X Y f hf => _âŸ©\n  Â· refine' (is_iso_op_iff _).1 (hğ’¢ _ fun G hG h => _)\n    obtain âŸ¨t, ht, ht'âŸ© := hf (unop G) (set.mem_op.1 hG) h.unop\n    exact âŸ¨t.op, quiver.hom.unop_inj ht, fun y hy => quiver.hom.unop_inj (ht' _ (quiver.hom.op_inj hy))âŸ©\n  Â· refine' (is_iso_unop_iff _).1 (hğ’¢ _ fun G hG h => _)\n    obtain âŸ¨t, ht, ht'âŸ© := hf (op G) (set.op_mem_op.2 hG) h.op\n    refine' âŸ¨t.unop, quiver.hom.op_inj ht, fun y hy => quiver.hom.op_inj (ht' _ _)âŸ©\n    exact quiver.hom.unop_inj (by simpa only using hy)\n#align is_codetecting_op_iff is_codetecting_op_iff\n\n",
 "is_codetecting_iff_is_coseparating":
 "theorem is_codetecting_iff_is_coseparating [has_coequalizers C] [balanced C] {ğ’¢ : set C} :\n    is_codetecting ğ’¢ â†” is_coseparating ğ’¢ :=\n  âŸ¨is_codetecting.is_coseparating, is_coseparating.is_codetectingâŸ©\n#align is_codetecting_iff_is_coseparating is_codetecting_iff_is_coseparating\n\n",
 "is_codetecting_empty_of_groupoid":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem is_codetecting_empty_of_groupoid [âˆ€ {X Y : C} (f : Â«expr âŸ¶ Â» X Y), IsIso f] : is_codetecting (âˆ… : set C) :=\n  fun X Y f hf => infer_instance\n#align is_codetecting_empty_of_groupoid is_codetecting_empty_of_groupoid\n\n",
 "is_codetecting":
 "theorem is_coseparating.is_codetecting [balanced C] {ğ’¢ : set C} : is_coseparating ğ’¢ â†’ is_codetecting ğ’¢ := by\n  simpa only [â† is_detecting_op_iff, â† is_separating_op_iff] using is_separating.is_detecting\n#align is_coseparating.is_codetecting is_coseparating.is_codetecting\n\n",
 "inf_eq_of_is_detecting":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŠ“ Â» -/\ntheorem inf_eq_of_is_detecting [has_pullbacks C] {ğ’¢ : set C} (hğ’¢ : is_detecting ğ’¢) {X : C} (P Q : subobject X)\n    (h : âˆ€ G âˆˆ ğ’¢, âˆ€ {f : Â«expr âŸ¶ Â» G X}, P.factors f â†’ Q.factors f) : Â«expr âŠ“ Â» P Q = P :=\n  eq_of_le_of_is_detecting hğ’¢ _ _ inf_le_left fun G hG f hf => (inf_factors _).2 âŸ¨hf, h _ hG hfâŸ©\n#align inf_eq_of_is_detecting inf_eq_of_is_detecting\n\n",
 "has_terminal_of_is_separating":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr áµ’áµ–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr áµ’áµ–Â» -/\n/-- An ingredient of the proof of the Special Adjoint Functor Theorem: a cocomplete well-copowered\n    category with a small separating set has a terminal object.\n\n    In fact, it follows from the Special Adjoint Functor Theorem that `C` is already complete, see\n    `has_limits_of_has_colimits_of_is_separating`. -/\ntheorem has_terminal_of_is_separating [well_powered (Â«expr áµ’áµ–Â» C)] [has_colimits C] {ğ’¢ : set C} [Small.{vâ‚} ğ’¢]\n    (hğ’¢ : is_separating ğ’¢) : has_terminal C :=\n  by\n  haveI : Small.{vâ‚} ğ’¢.op := small_of_injective (Set.opEquiv_self ğ’¢).injective\n  haveI : has_initial (Â«expr áµ’áµ–Â» C) := has_initial_of_is_coseparating ((is_coseparating_op_iff _).2 hğ’¢)\n  exact has_terminal_of_has_initial_op\n#align has_terminal_of_is_separating has_terminal_of_is_separating\n\n",
 "has_initial_of_is_coseparating":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¥Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¥Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/-- An ingredient of the proof of the Special Adjoint Functor Theorem: a complete well-powered\n    category with a small coseparating set has an initial object.\n\n    In fact, it follows from the Special Adjoint Functor Theorem that `C` is already cocomplete,\n    see `has_colimits_of_has_limits_of_is_coseparating`. -/\ntheorem has_initial_of_is_coseparating [well_powered C] [has_limits C] {ğ’¢ : set C} [Small.{vâ‚} ğ’¢]\n    (hğ’¢ : is_coseparating ğ’¢) : has_initial C :=\n  by\n  haveI := has_products_of_shape_of_small C ğ’¢\n  haveI := fun A => has_products_of_shape_of_small.{vâ‚} C (Î£G : ğ’¢, Â«expr âŸ¶ Â» A (G : C))\n  letI := completeLatticeOfCompleteSemilatticeInf (subobject (pi_obj (coe : ğ’¢ â†’ C)))\n  suffices âˆ€ A : C, unique (Â«expr âŸ¶ Â» ((Â«exprâŠ¥Â» : subobject (pi_obj (coe : ğ’¢ â†’ C))) : C) A) by\n    exact has_initial_of_unique ((Â«exprâŠ¥Â» : subobject (pi_obj (coe : ğ’¢ â†’ C))) : C)\n  refine' fun A => âŸ¨âŸ¨_âŸ©, fun f => _âŸ©\n  Â· let s := pi.lift fun f : Î£G : ğ’¢, Â«expr âŸ¶ Â» A (G : C) => id (pi.Ï€ (coe : ğ’¢ â†’ C)) f.1\n    let t := pi.lift (@sigma.snd ğ’¢ fun G => Â«expr âŸ¶ Â» A (G : C))\n    haveI : mono t := (is_coseparating_iff_mono ğ’¢).1 hğ’¢ A\n    exact Â«expr â‰« Â» (subobject.of_le_mk _ (pullback.fst : Â«expr âŸ¶ Â» (pullback s t) _) bot_le) pullback.snd\n  Â· generalize default = g\n    suffices is_split_epi (equalizer.Î¹ f g) by exact eq_of_epi_equalizer\n    exact\n      is_split_epi.mk'\n        âŸ¨subobject.of_le_mk _ (Â«expr â‰« Â» (equalizer.Î¹ f g) (subobject.arrow _)) bot_le,\n          by\n          ext\n          simpâŸ©\n#align has_initial_of_is_coseparating has_initial_of_is_coseparating\n\n",
 "groupoid_of_is_detecting_empty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem groupoid_of_is_detecting_empty (h : is_detecting (âˆ… : set C)) {X Y : C} (f : Â«expr âŸ¶ Â» X Y) : IsIso f :=\n  h _ fun G => false.elim\n#align groupoid_of_is_detecting_empty groupoid_of_is_detecting_empty\n\n",
 "groupoid_of_is_codetecting_empty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem groupoid_of_is_codetecting_empty (h : is_codetecting (âˆ… : set C)) {X Y : C} (f : Â«expr âŸ¶ Â» X Y) : IsIso f :=\n  h _ fun G => false.elim\n#align groupoid_of_is_codetecting_empty groupoid_of_is_codetecting_empty\n\n",
 "eq_of_le_of_is_detecting":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem eq_of_le_of_is_detecting {ğ’¢ : set C} (hğ’¢ : is_detecting ğ’¢) {X : C} (P Q : subobject X) (hâ‚ : P â‰¤ Q)\n    (hâ‚‚ : âˆ€ G âˆˆ ğ’¢, âˆ€ {f : Â«expr âŸ¶ Â» G X}, Q.factors f â†’ P.factors f) : P = Q :=\n  by\n  suffices is_iso (of_le _ _ hâ‚) by exact le_antisymm hâ‚ (le_of_comm (inv (of_le _ _ hâ‚)) (by simp))\n  refine' hğ’¢ _ fun G hG f => _\n  have : P.factors (Â«expr â‰« Â» f Q.arrow) := hâ‚‚ _ hG ((factors_iff _ _).2 âŸ¨_, rflâŸ©)\n  refine' âŸ¨factor_thru _ _ this, _, fun g (hg : Â«expr â‰« Â» g _ = f) => _âŸ©\n  Â· simp only [â† cancel_mono Q.arrow, category.assoc, of_le_arrow, factor_thru_arrow]\n  Â·\n    simp only [â† cancel_mono (subobject.of_le _ _ hâ‚), â† cancel_mono Q.arrow, hg, category.assoc, of_le_arrow,\n      factor_thru_arrow]\n#align eq_of_le_of_is_detecting eq_of_le_of_is_detecting\n\n",
 "eq_of_is_detecting":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŠ“ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŠ“ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem eq_of_is_detecting [has_pullbacks C] {ğ’¢ : set C} (hğ’¢ : is_detecting ğ’¢) {X : C} (P Q : subobject X)\n    (h : âˆ€ G âˆˆ ğ’¢, âˆ€ {f : Â«expr âŸ¶ Â» G X}, P.factors f â†” Q.factors f) : P = Q :=\n  calc\n    P = Â«expr âŠ“ Â» P Q := eq.symm <| inf_eq_of_is_detecting hğ’¢ _ _ fun G hG f hf => (h G hG).1 hf\n    _ = Â«expr âŠ“ Â» Q P := inf_comm\n    _ = Q := inf_eq_of_is_detecting hğ’¢ _ _ fun G hG f hf => (h G hG).2 hf\n    \n#align eq_of_is_detecting eq_of_is_detecting\n\n",
 "def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\ntheorem is_codetector.def {G : C} :\n    is_codetector G â†’ âˆ€ â¦ƒX Y : Câ¦„ (f : Â«expr âŸ¶ Â» X Y), (âˆ€ h : Â«expr âŸ¶ Â» X G, âˆƒ! h', Â«expr â‰« Â» f h' = h) â†’ IsIso f :=\n  (is_codetector_def _).1\n#align is_codetector.def is_codetector.def\n\n"}