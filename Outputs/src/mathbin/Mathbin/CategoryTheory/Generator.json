{"well_powered_of_is_detector":
 "theorem well_powered_of_is_detector [has_pullbacks C] (G : C) (hG : is_detector G) : well_powered C :=\n  well_powered_of_is_detecting hG\n#align well_powered_of_is_detector well_powered_of_is_detector\n\n",
 "well_powered_of_is_detecting":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/-- A category with pullbacks and a small detecting set is well-powered. -/\ntheorem well_powered_of_is_detecting [has_pullbacks C] {𝒢 : set C} [Small.{v₁} 𝒢] (h𝒢 : is_detecting 𝒢) :\n    well_powered C :=\n  ⟨fun X =>\n    @small_of_injective _ _ _ (fun P : subobject X => { f : ΣG : 𝒢, «expr ⟶ » G.1 X | P.factors f.2 }) fun P Q h =>\n      subobject.eq_of_is_detecting h𝒢 _ _ (by simpa [Set.ext_iff] using h)⟩\n#align well_powered_of_is_detecting well_powered_of_is_detecting\n\n",
 "thin_of_is_separating_empty":
 "theorem thin_of_is_separating_empty (h : is_separating (∅ : set C)) : Quiver.IsThin C := fun _ _ =>\n  ⟨fun f g => h _ _ fun G => false.elim⟩\n#align thin_of_is_separating_empty thin_of_is_separating_empty\n\n",
 "thin_of_is_coseparating_empty":
 "theorem thin_of_is_coseparating_empty (h : is_coseparating (∅ : set C)) : Quiver.IsThin C := fun _ _ =>\n  ⟨fun f g => h _ _ fun G => false.elim⟩\n#align thin_of_is_coseparating_empty thin_of_is_coseparating_empty\n\n",
 "mono":
 "theorem is_codetecting.mono {𝒢 : set C} (h𝒢 : is_codetecting 𝒢) {ℋ : set C} (h𝒢ℋ : 𝒢 ⊆ ℋ) : is_codetecting ℋ :=\n  fun X Y f hf => h𝒢 _ fun G hG h => hf _ (h𝒢ℋ hG) _\n#align is_codetecting.mono is_codetecting.mono\n\n",
 "is_separator_unop_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵖ» -/\ntheorem is_separator_unop_iff (G : «expr ᵒᵖ» C) : is_separator (unop G) ↔ is_coseparator G := by\n  rw [is_separator, is_coseparator, ← is_separating_unop_iff, set.singleton_unop]\n#align is_separator_unop_iff is_separator_unop_iff\n\n",
 "is_separator_sigma_of_is_separator":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∐ » -/\ntheorem is_separator_sigma_of_is_separator {β : Type w} (f : β → C) [has_coproduct f] (b : β)\n    (hb : is_separator (f b)) : is_separator («expr∐ » f) :=\n  (is_separator_sigma _).2 <| is_separating.mono hb <| by simp\n#align is_separator_sigma_of_is_separator is_separator_sigma_of_is_separator\n\n",
 "is_separator_sigma":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫= » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∐ » -/\ntheorem is_separator_sigma {β : Type w} (f : β → C) [has_coproduct f] :\n    is_separator («expr∐ » f) ↔ is_separating (Set.range f) :=\n  by\n  refine' ⟨fun h X Y u v huv => _, fun h => (is_separator_def _).2 fun X Y u v huv => h _ _ fun Z hZ g => _⟩\n  · refine' h.def _ _ fun g => colimit.hom_ext fun b => _\n    simpa using huv (f b.as) (by simp) («expr ≫ » (colimit.ι (discrete.functor f) _) g)\n  · obtain ⟨b, rfl⟩ := Set.mem_range.1 hZ\n    classical simpa using «expr ≫= » (sigma.ι f b) (huv (sigma.desc (Pi.single b g)))\n#align is_separator_sigma is_separator_sigma\n\n",
 "is_separator_op_iff":
 "theorem is_separator_op_iff (G : C) : is_separator (op G) ↔ is_coseparator G := by\n  rw [is_separator, is_coseparator, ← is_separating_op_iff, set.singleton_op]\n#align is_separator_op_iff is_separator_op_iff\n\n",
 "is_separator_iff_faithful_coyoneda_obj":
 "theorem is_separator_iff_faithful_coyoneda_obj (G : C) : is_separator G ↔ Faithful (coyoneda.obj (op G)) :=\n  ⟨fun hG => ⟨fun X Y f g hfg => hG.def _ _ (congr_fun hfg)⟩, fun h =>\n    (is_separator_def _).2 fun X Y f g hfg => (coyoneda.obj (op G)).map_injective (funext hfg)⟩\n#align is_separator_iff_faithful_coyoneda_obj is_separator_iff_faithful_coyoneda_obj\n\n",
 "is_separator_iff_epi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫= » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem is_separator_iff_epi (G : C) [∀ A : C, has_coproduct fun f : «expr ⟶ » G A => G] :\n    is_separator G ↔ ∀ A : C, Epi (sigma.desc fun f : «expr ⟶ » G A => f) :=\n  by\n  rw [is_separator_def]\n  refine' ⟨fun h A => ⟨fun Z u v huv => h _ _ fun i => _⟩, fun h X Y f g hh => _⟩\n  · simpa using «expr ≫= » (sigma.ι _ i) huv\n  · haveI := h X\n    refine' (cancel_epi (sigma.desc fun f : «expr ⟶ » G X => f)).1 (colimit.hom_ext fun j => _)\n    simpa using hh j.as\n#align is_separator_iff_epi is_separator_iff_epi\n\n",
 "is_separator_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem is_separator_def (G : C) :\n    is_separator G ↔ ∀ ⦃X Y : C⦄ (f g : «expr ⟶ » X Y), (∀ h : «expr ⟶ » G X, «expr ≫ » h f = «expr ≫ » h g) → f = g :=\n  ⟨fun hG X Y f g hfg =>\n    hG _ _ fun H hH h => by\n      obtain rfl := Set.mem_singleton_iff.1 hH\n      exact hfg h,\n    fun hG X Y f g hfg => hG _ _ fun h => hfg _ (Set.mem_singleton _) _⟩\n#align is_separator_def is_separator_def\n\n",
 "is_separator_coprod_of_is_separator_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⨿ » -/\ntheorem is_separator_coprod_of_is_separator_right (G H : C) [has_binary_coproduct G H] (hH : is_separator H) :\n    is_separator («expr ⨿ » G H) :=\n  (is_separator_coprod _ _).2 <| is_separating.mono hH <| by simp\n#align is_separator_coprod_of_is_separator_right is_separator_coprod_of_is_separator_right\n\n",
 "is_separator_coprod_of_is_separator_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⨿ » -/\ntheorem is_separator_coprod_of_is_separator_left (G H : C) [has_binary_coproduct G H] (hG : is_separator G) :\n    is_separator («expr ⨿ » G H) :=\n  (is_separator_coprod _ _).2 <| is_separating.mono hG <| by simp\n#align is_separator_coprod_of_is_separator_left is_separator_coprod_of_is_separator_left\n\n",
 "is_separator_coprod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫= » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫= » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⨿ » -/\ntheorem is_separator_coprod (G H : C) [has_binary_coproduct G H] :\n    is_separator («expr ⨿ » G H) ↔ is_separating ({G, H} : set C) :=\n  by\n  refine' ⟨fun h X Y u v huv => _, fun h => (is_separator_def _).2 fun X Y u v huv => h _ _ fun Z hZ g => _⟩\n  · refine' h.def _ _ fun g => coprod.hom_ext _ _\n    · simpa using huv G (by simp) («expr ≫ » coprod.inl g)\n    · simpa using huv H (by simp) («expr ≫ » coprod.inr g)\n  · simp only [Set.mem_insert_iff, Set.mem_singleton_iff] at hZ\n    rcases hZ with (rfl | rfl)\n    · simpa using «expr ≫= » coprod.inl (huv (coprod.desc g 0))\n    · simpa using «expr ≫= » coprod.inr (huv (coprod.desc 0 g))\n#align is_separator_coprod is_separator_coprod\n\n",
 "is_separator":
 "theorem is_detector.is_separator [has_equalizers C] {G : C} : is_detector G → is_separator G :=\n  is_detecting.is_separating\n#align is_detector.is_separator is_detector.is_separator\n\n",
 "is_separating_unop_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵖ» -/\ntheorem is_separating_unop_iff (𝒢 : set («expr ᵒᵖ» C)) : is_separating 𝒢.unop ↔ is_coseparating 𝒢 := by\n  rw [← is_coseparating_op_iff, set.unop_op]\n#align is_separating_unop_iff is_separating_unop_iff\n\n",
 "is_separating_proj_preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem is_separating_proj_preimage {𝒢 : set C} (h𝒢 : is_separating 𝒢) : is_separating («expr ⁻¹' » (proj S T).obj 𝒢) :=\n  by\n  refine' fun X Y f g hfg => ext _ _ (h𝒢 _ _ fun G hG h => _)\n  convert congr_arg comma_morphism.left (hfg (mk («expr ≫ » (S.map h) X.hom)) hG (hom_mk h rfl))\n#align is_separating_proj_preimage is_separating_proj_preimage\n\n",
 "is_separating_op_iff":
 "/-\nCopyright (c) 2022 Markus Himmel. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Markus Himmel\n-/\ntheorem is_separating_op_iff (𝒢 : set C) : is_separating 𝒢.op ↔ is_coseparating 𝒢 :=\n  by\n  refine' ⟨fun h𝒢 X Y f g hfg => _, fun h𝒢 X Y f g hfg => _⟩\n  · refine' quiver.hom.op_inj (h𝒢 _ _ fun G hG h => quiver.hom.unop_inj _)\n    simpa only [unop_comp, quiver.hom.unop_op] using hfg _ (set.mem_op.1 hG) _\n  · refine' quiver.hom.unop_inj (h𝒢 _ _ fun G hG h => quiver.hom.op_inj _)\n    simpa only [op_comp, quiver.hom.op_unop] using hfg _ (set.op_mem_op.2 hG) _\n#align is_separating_op_iff is_separating_op_iff\n\n",
 "is_separating_iff_epi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫= » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem is_separating_iff_epi (𝒢 : set C) [∀ A : C, has_coproduct fun f : ΣG : 𝒢, «expr ⟶ » (G : C) A => (f.1 : C)] :\n    is_separating 𝒢 ↔ ∀ A : C, Epi (sigma.desc (@sigma.snd 𝒢 fun G => «expr ⟶ » (G : C) A)) :=\n  by\n  refine' ⟨fun h A => ⟨fun Z u v huv => h _ _ fun G hG f => _⟩, fun h X Y f g hh => _⟩\n  · simpa using «expr ≫= » (sigma.ι (fun f : ΣG : 𝒢, «expr ⟶ » (G : C) A => (f.1 : C)) ⟨⟨G, hG⟩, f⟩) huv\n  · haveI := h X\n    refine' (cancel_epi (sigma.desc (@sigma.snd 𝒢 fun G => «expr ⟶ » (G : C) X))).1 (colimit.hom_ext fun j => _)\n    simpa using hh j.as.1.1 j.as.1.2 j.as.2\n#align is_separating_iff_epi is_separating_iff_epi\n\n",
 "is_separating_empty_of_thin":
 "theorem is_separating_empty_of_thin [Quiver.IsThin C] : is_separating (∅ : set C) := fun X Y f g hfg =>\n  subsingleton.elim _ _\n#align is_separating_empty_of_thin is_separating_empty_of_thin\n\n",
 "is_separating":
 "theorem is_detecting.is_separating [has_equalizers C] {𝒢 : set C} (h𝒢 : is_detecting 𝒢) : is_separating 𝒢 :=\n  fun X Y f g hfg =>\n  have : IsIso (equalizer.ι f g) := h𝒢 _ fun G hG h => equalizer.exists_unique _ (hfg _ hG _)\n  eq_of_epi_equalizer\n#align is_detecting.is_separating is_detecting.is_separating\n\n",
 "is_detector_unop_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵖ» -/\ntheorem is_detector_unop_iff (G : «expr ᵒᵖ» C) : is_detector (unop G) ↔ is_codetector G := by\n  rw [is_detector, is_codetector, ← is_detecting_unop_iff, set.singleton_unop]\n#align is_detector_unop_iff is_detector_unop_iff\n\n",
 "is_detector_op_iff":
 "theorem is_detector_op_iff (G : C) : is_detector (op G) ↔ is_codetector G := by\n  rw [is_detector, is_codetector, ← is_detecting_op_iff, set.singleton_op]\n#align is_detector_op_iff is_detector_op_iff\n\n",
 "is_detector_iff_reflects_isomorphisms_coyoneda_obj":
 "theorem is_detector_iff_reflects_isomorphisms_coyoneda_obj (G : C) :\n    is_detector G ↔ reflects_isomorphisms (coyoneda.obj (op G)) :=\n  by\n  refine' ⟨fun hG => ⟨fun X Y f hf => hG.def _ fun h => _⟩, fun h => (is_detector_def _).2 fun X Y f hf => _⟩\n  · rw [is_iso_iff_bijective, Function.bijective_iff_existsUnique] at hf\n    exact hf h\n  · suffices is_iso ((coyoneda.obj (op G)).map f) by\n      exact @is_iso_of_reflects_iso _ _ _ _ _ _ _ (coyoneda.obj (op G)) _ h\n    rwa [is_iso_iff_bijective, Function.bijective_iff_existsUnique]\n#align is_detector_iff_reflects_isomorphisms_coyoneda_obj is_detector_iff_reflects_isomorphisms_coyoneda_obj\n\n",
 "is_detector_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem is_detector_def (G : C) :\n    is_detector G ↔ ∀ ⦃X Y : C⦄ (f : «expr ⟶ » X Y), (∀ h : «expr ⟶ » G Y, ∃! h', «expr ≫ » h' f = h) → IsIso f :=\n  ⟨fun hG X Y f hf =>\n    hG _ fun H hH h => by\n      obtain rfl := Set.mem_singleton_iff.1 hH\n      exact hf h,\n    fun hG X Y f hf => hG _ fun h => hf _ (Set.mem_singleton _) _⟩\n#align is_detector_def is_detector_def\n\n",
 "is_detector":
 "theorem is_separator.is_detector [balanced C] {G : C} : is_separator G → is_detector G :=\n  is_separating.is_detecting\n#align is_separator.is_detector is_separator.is_detector\n\n",
 "is_detecting_unop_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵖ» -/\ntheorem is_detecting_unop_iff (𝒢 : set («expr ᵒᵖ» C)) : is_detecting 𝒢.unop ↔ is_codetecting 𝒢 := by\n  rw [← is_codetecting_op_iff, set.unop_op]\n#align is_detecting_unop_iff is_detecting_unop_iff\n\n",
 "is_detecting_op_iff":
 "theorem is_detecting_op_iff (𝒢 : set C) : is_detecting 𝒢.op ↔ is_codetecting 𝒢 :=\n  by\n  refine' ⟨fun h𝒢 X Y f hf => _, fun h𝒢 X Y f hf => _⟩\n  · refine' (is_iso_op_iff _).1 (h𝒢 _ fun G hG h => _)\n    obtain ⟨t, ht, ht'⟩ := hf (unop G) (set.mem_op.1 hG) h.unop\n    exact ⟨t.op, quiver.hom.unop_inj ht, fun y hy => quiver.hom.unop_inj (ht' _ (quiver.hom.op_inj hy))⟩\n  · refine' (is_iso_unop_iff _).1 (h𝒢 _ fun G hG h => _)\n    obtain ⟨t, ht, ht'⟩ := hf (op G) (set.op_mem_op.2 hG) h.op\n    refine' ⟨t.unop, quiver.hom.op_inj ht, fun y hy => quiver.hom.op_inj (ht' _ _)⟩\n    exact quiver.hom.unop_inj (by simpa only using hy)\n#align is_detecting_op_iff is_detecting_op_iff\n\n",
 "is_detecting_iff_is_separating":
 "theorem is_detecting_iff_is_separating [has_equalizers C] [balanced C] (𝒢 : set C) : is_detecting 𝒢 ↔ is_separating 𝒢 :=\n  ⟨is_detecting.is_separating, is_separating.is_detecting⟩\n#align is_detecting_iff_is_separating is_detecting_iff_is_separating\n\n",
 "is_detecting_empty_of_groupoid":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem is_detecting_empty_of_groupoid [∀ {X Y : C} (f : «expr ⟶ » X Y), IsIso f] : is_detecting (∅ : set C) :=\n  fun X Y f hf => infer_instance\n#align is_detecting_empty_of_groupoid is_detecting_empty_of_groupoid\n\n",
 "is_detecting":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem is_separating.is_detecting [balanced C] {𝒢 : set C} (h𝒢 : is_separating 𝒢) : is_detecting 𝒢 :=\n  by\n  intro X Y f hf\n  refine' (is_iso_iff_mono_and_epi _).2 ⟨⟨fun Z g h hgh => h𝒢 _ _ fun G hG i => _⟩, ⟨fun Z g h hgh => _⟩⟩\n  · obtain ⟨t, -, ht⟩ := hf G hG («expr ≫ » i («expr ≫ » g f))\n    rw [ht («expr ≫ » i g) (category.assoc _ _ _), ht («expr ≫ » i h) (hgh.symm ▸ category.assoc _ _ _)]\n  · refine' h𝒢 _ _ fun G hG i => _\n    obtain ⟨t, rfl, -⟩ := hf G hG i\n    rw [category.assoc, hgh, category.assoc]\n#align is_separating.is_detecting is_separating.is_detecting\n\n",
 "is_coseparator_unop_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵖ» -/\ntheorem is_coseparator_unop_iff (G : «expr ᵒᵖ» C) : is_coseparator (unop G) ↔ is_separator G := by\n  rw [is_separator, is_coseparator, ← is_coseparating_unop_iff, set.singleton_unop]\n#align is_coseparator_unop_iff is_coseparator_unop_iff\n\n",
 "is_coseparator_prod_of_is_coseparator_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⨯ » -/\ntheorem is_coseparator_prod_of_is_coseparator_right (G H : C) [has_binary_product G H] (hH : is_coseparator H) :\n    is_coseparator («expr ⨯ » G H) :=\n  (is_coseparator_prod _ _).2 <| is_coseparating.mono hH <| by simp\n#align is_coseparator_prod_of_is_coseparator_right is_coseparator_prod_of_is_coseparator_right\n\n",
 "is_coseparator_prod_of_is_coseparator_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⨯ » -/\ntheorem is_coseparator_prod_of_is_coseparator_left (G H : C) [has_binary_product G H] (hG : is_coseparator G) :\n    is_coseparator («expr ⨯ » G H) :=\n  (is_coseparator_prod _ _).2 <| is_coseparating.mono hG <| by simp\n#align is_coseparator_prod_of_is_coseparator_left is_coseparator_prod_of_is_coseparator_left\n\n",
 "is_coseparator_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⨯ » -/\ntheorem is_coseparator_prod (G H : C) [has_binary_product G H] :\n    is_coseparator («expr ⨯ » G H) ↔ is_coseparating ({G, H} : set C) :=\n  by\n  refine' ⟨fun h X Y u v huv => _, fun h => (is_coseparator_def _).2 fun X Y u v huv => h _ _ fun Z hZ g => _⟩\n  · refine' h.def _ _ fun g => prod.hom_ext _ _\n    · simpa using huv G (by simp) («expr ≫ » g limits.prod.fst)\n    · simpa using huv H (by simp) («expr ≫ » g limits.prod.snd)\n  · simp only [Set.mem_insert_iff, Set.mem_singleton_iff] at hZ\n    rcases hZ with (rfl | rfl)\n    · simpa using «expr =≫ » (huv (prod.lift g 0)) limits.prod.fst\n    · simpa using «expr =≫ » (huv (prod.lift 0 g)) limits.prod.snd\n#align is_coseparator_prod is_coseparator_prod\n\n",
 "is_coseparator_pi_of_is_coseparator":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∏ » -/\ntheorem is_coseparator_pi_of_is_coseparator {β : Type w} (f : β → C) [has_product f] (b : β)\n    (hb : is_coseparator (f b)) : is_coseparator («expr∏ » f) :=\n  (is_coseparator_pi _).2 <| is_coseparating.mono hb <| by simp\n#align is_coseparator_pi_of_is_coseparator is_coseparator_pi_of_is_coseparator\n\n",
 "is_coseparator_pi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∏ » -/\ntheorem is_coseparator_pi {β : Type w} (f : β → C) [has_product f] :\n    is_coseparator («expr∏ » f) ↔ is_coseparating (Set.range f) :=\n  by\n  refine' ⟨fun h X Y u v huv => _, fun h => (is_coseparator_def _).2 fun X Y u v huv => h _ _ fun Z hZ g => _⟩\n  · refine' h.def _ _ fun g => limit.hom_ext fun b => _\n    simpa using huv (f b.as) (by simp) («expr ≫ » g (limit.π (discrete.functor f) _))\n  · obtain ⟨b, rfl⟩ := Set.mem_range.1 hZ\n    classical simpa using «expr =≫ » (huv (pi.lift (Pi.single b g))) (pi.π f b)\n#align is_coseparator_pi is_coseparator_pi\n\n",
 "is_coseparator_op_iff":
 "theorem is_coseparator_op_iff (G : C) : is_coseparator (op G) ↔ is_separator G := by\n  rw [is_separator, is_coseparator, ← is_coseparating_op_iff, set.singleton_op]\n#align is_coseparator_op_iff is_coseparator_op_iff\n\n",
 "is_coseparator_iff_mono":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem is_coseparator_iff_mono (G : C) [∀ A : C, has_product fun f : «expr ⟶ » A G => G] :\n    is_coseparator G ↔ ∀ A : C, Mono (pi.lift fun f : «expr ⟶ » A G => f) :=\n  by\n  rw [is_coseparator_def]\n  refine' ⟨fun h A => ⟨fun Z u v huv => h _ _ fun i => _⟩, fun h X Y f g hh => _⟩\n  · simpa using «expr =≫ » huv (pi.π _ i)\n  · haveI := h Y\n    refine' (cancel_mono (pi.lift fun f : «expr ⟶ » Y G => f)).1 (limit.hom_ext fun j => _)\n    simpa using hh j.as\n#align is_coseparator_iff_mono is_coseparator_iff_mono\n\n",
 "is_coseparator_iff_faithful_yoneda_obj":
 "theorem is_coseparator_iff_faithful_yoneda_obj (G : C) : is_coseparator G ↔ Faithful (yoneda.obj G) :=\n  ⟨fun hG => ⟨fun X Y f g hfg => quiver.hom.unop_inj (hG.def _ _ (congr_fun hfg))⟩, fun h =>\n    (is_coseparator_def _).2 fun X Y f g hfg => quiver.hom.op_inj <| (yoneda.obj G).map_injective (funext hfg)⟩\n#align is_coseparator_iff_faithful_yoneda_obj is_coseparator_iff_faithful_yoneda_obj\n\n",
 "is_coseparator_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem is_coseparator_def (G : C) :\n    is_coseparator G ↔\n      ∀ ⦃X Y : C⦄ (f g : «expr ⟶ » X Y), (∀ h : «expr ⟶ » Y G, «expr ≫ » f h = «expr ≫ » g h) → f = g :=\n  ⟨fun hG X Y f g hfg =>\n    hG _ _ fun H hH h => by\n      obtain rfl := Set.mem_singleton_iff.1 hH\n      exact hfg h,\n    fun hG X Y f g hfg => hG _ _ fun h => hfg _ (Set.mem_singleton _) _⟩\n#align is_coseparator_def is_coseparator_def\n\n",
 "is_coseparator":
 "theorem is_codetector.is_coseparator [has_coequalizers C] {G : C} : is_codetector G → is_coseparator G :=\n  is_codetecting.is_coseparating\n#align is_codetector.is_coseparator is_codetector.is_coseparator\n\n",
 "is_coseparating_unop_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵖ» -/\ntheorem is_coseparating_unop_iff (𝒢 : set («expr ᵒᵖ» C)) : is_coseparating 𝒢.unop ↔ is_separating 𝒢 := by\n  rw [← is_separating_op_iff, set.unop_op]\n#align is_coseparating_unop_iff is_coseparating_unop_iff\n\n",
 "is_coseparating_proj_preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem is_coseparating_proj_preimage {𝒢 : set C} (h𝒢 : is_coseparating 𝒢) :\n    is_coseparating («expr ⁻¹' » (proj S T).obj 𝒢) :=\n  by\n  refine' fun X Y f g hfg => ext _ _ (h𝒢 _ _ fun G hG h => _)\n  exact congr_arg comma_morphism.right (hfg (mk («expr ≫ » Y.hom (T.map h))) hG (hom_mk h rfl))\n#align is_coseparating_proj_preimage is_coseparating_proj_preimage\n\n",
 "is_coseparating_op_iff":
 "theorem is_coseparating_op_iff (𝒢 : set C) : is_coseparating 𝒢.op ↔ is_separating 𝒢 :=\n  by\n  refine' ⟨fun h𝒢 X Y f g hfg => _, fun h𝒢 X Y f g hfg => _⟩\n  · refine' quiver.hom.op_inj (h𝒢 _ _ fun G hG h => quiver.hom.unop_inj _)\n    simpa only [unop_comp, quiver.hom.unop_op] using hfg _ (set.mem_op.1 hG) _\n  · refine' quiver.hom.unop_inj (h𝒢 _ _ fun G hG h => quiver.hom.op_inj _)\n    simpa only [op_comp, quiver.hom.op_unop] using hfg _ (set.op_mem_op.2 hG) _\n#align is_coseparating_op_iff is_coseparating_op_iff\n\n",
 "is_coseparating_iff_mono":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem is_coseparating_iff_mono (𝒢 : set C) [∀ A : C, has_product fun f : ΣG : 𝒢, «expr ⟶ » A (G : C) => (f.1 : C)] :\n    is_coseparating 𝒢 ↔ ∀ A : C, Mono (pi.lift (@sigma.snd 𝒢 fun G => «expr ⟶ » A (G : C))) :=\n  by\n  refine' ⟨fun h A => ⟨fun Z u v huv => h _ _ fun G hG f => _⟩, fun h X Y f g hh => _⟩\n  · simpa using «expr =≫ » huv (pi.π (fun f : ΣG : 𝒢, «expr ⟶ » A (G : C) => (f.1 : C)) ⟨⟨G, hG⟩, f⟩)\n  · haveI := h Y\n    refine' (cancel_mono (pi.lift (@sigma.snd 𝒢 fun G => «expr ⟶ » Y (G : C)))).1 (limit.hom_ext fun j => _)\n    simpa using hh j.as.1.1 j.as.1.2 j.as.2\n#align is_coseparating_iff_mono is_coseparating_iff_mono\n\n",
 "is_coseparating_empty_of_thin":
 "theorem is_coseparating_empty_of_thin [Quiver.IsThin C] : is_coseparating (∅ : set C) := fun X Y f g hfg =>\n  subsingleton.elim _ _\n#align is_coseparating_empty_of_thin is_coseparating_empty_of_thin\n\n",
 "is_coseparating":
 "theorem is_codetecting.is_coseparating [has_coequalizers C] {𝒢 : set C} : is_codetecting 𝒢 → is_coseparating 𝒢 := by\n  simpa only [← is_separating_op_iff, ← is_detecting_op_iff] using is_detecting.is_separating\n#align is_codetecting.is_coseparating is_codetecting.is_coseparating\n\n",
 "is_codetector_unop_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵖ» -/\ntheorem is_codetector_unop_iff (G : «expr ᵒᵖ» C) : is_codetector (unop G) ↔ is_detector G := by\n  rw [is_detector, is_codetector, ← is_codetecting_unop_iff, set.singleton_unop]\n#align is_codetector_unop_iff is_codetector_unop_iff\n\n",
 "is_codetector_op_iff":
 "theorem is_codetector_op_iff (G : C) : is_codetector (op G) ↔ is_detector G := by\n  rw [is_detector, is_codetector, ← is_codetecting_op_iff, set.singleton_op]\n#align is_codetector_op_iff is_codetector_op_iff\n\n",
 "is_codetector_iff_reflects_isomorphisms_yoneda_obj":
 "theorem is_codetector_iff_reflects_isomorphisms_yoneda_obj (G : C) :\n    is_codetector G ↔ reflects_isomorphisms (yoneda.obj G) :=\n  by\n  refine' ⟨fun hG => ⟨fun X Y f hf => _⟩, fun h => (is_codetector_def _).2 fun X Y f hf => _⟩\n  · refine' (is_iso_unop_iff _).1 (hG.def _ _)\n    rwa [is_iso_iff_bijective, Function.bijective_iff_existsUnique] at hf\n  · rw [← is_iso_op_iff]\n    suffices is_iso ((yoneda.obj G).map f.op) by exact @is_iso_of_reflects_iso _ _ _ _ _ _ _ (yoneda.obj G) _ h\n    rwa [is_iso_iff_bijective, Function.bijective_iff_existsUnique]\n#align is_codetector_iff_reflects_isomorphisms_yoneda_obj is_codetector_iff_reflects_isomorphisms_yoneda_obj\n\n",
 "is_codetector_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem is_codetector_def (G : C) :\n    is_codetector G ↔ ∀ ⦃X Y : C⦄ (f : «expr ⟶ » X Y), (∀ h : «expr ⟶ » X G, ∃! h', «expr ≫ » f h' = h) → IsIso f :=\n  ⟨fun hG X Y f hf =>\n    hG _ fun H hH h => by\n      obtain rfl := Set.mem_singleton_iff.1 hH\n      exact hf h,\n    fun hG X Y f hf => hG _ fun h => hf _ (Set.mem_singleton _) _⟩\n#align is_codetector_def is_codetector_def\n\n",
 "is_codetector":
 "theorem is_cospearator.is_codetector [balanced C] {G : C} : is_coseparator G → is_codetector G :=\n  is_coseparating.is_codetecting\n#align is_cospearator.is_codetector is_cospearator.is_codetector\n\n",
 "is_codetecting_unop_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵖ» -/\ntheorem is_codetecting_unop_iff {𝒢 : set («expr ᵒᵖ» C)} : is_codetecting 𝒢.unop ↔ is_detecting 𝒢 := by\n  rw [← is_detecting_op_iff, set.unop_op]\n#align is_codetecting_unop_iff is_codetecting_unop_iff\n\n",
 "is_codetecting_op_iff":
 "theorem is_codetecting_op_iff (𝒢 : set C) : is_codetecting 𝒢.op ↔ is_detecting 𝒢 :=\n  by\n  refine' ⟨fun h𝒢 X Y f hf => _, fun h𝒢 X Y f hf => _⟩\n  · refine' (is_iso_op_iff _).1 (h𝒢 _ fun G hG h => _)\n    obtain ⟨t, ht, ht'⟩ := hf (unop G) (set.mem_op.1 hG) h.unop\n    exact ⟨t.op, quiver.hom.unop_inj ht, fun y hy => quiver.hom.unop_inj (ht' _ (quiver.hom.op_inj hy))⟩\n  · refine' (is_iso_unop_iff _).1 (h𝒢 _ fun G hG h => _)\n    obtain ⟨t, ht, ht'⟩ := hf (op G) (set.op_mem_op.2 hG) h.op\n    refine' ⟨t.unop, quiver.hom.op_inj ht, fun y hy => quiver.hom.op_inj (ht' _ _)⟩\n    exact quiver.hom.unop_inj (by simpa only using hy)\n#align is_codetecting_op_iff is_codetecting_op_iff\n\n",
 "is_codetecting_iff_is_coseparating":
 "theorem is_codetecting_iff_is_coseparating [has_coequalizers C] [balanced C] {𝒢 : set C} :\n    is_codetecting 𝒢 ↔ is_coseparating 𝒢 :=\n  ⟨is_codetecting.is_coseparating, is_coseparating.is_codetecting⟩\n#align is_codetecting_iff_is_coseparating is_codetecting_iff_is_coseparating\n\n",
 "is_codetecting_empty_of_groupoid":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem is_codetecting_empty_of_groupoid [∀ {X Y : C} (f : «expr ⟶ » X Y), IsIso f] : is_codetecting (∅ : set C) :=\n  fun X Y f hf => infer_instance\n#align is_codetecting_empty_of_groupoid is_codetecting_empty_of_groupoid\n\n",
 "is_codetecting":
 "theorem is_coseparating.is_codetecting [balanced C] {𝒢 : set C} : is_coseparating 𝒢 → is_codetecting 𝒢 := by\n  simpa only [← is_detecting_op_iff, ← is_separating_op_iff] using is_separating.is_detecting\n#align is_coseparating.is_codetecting is_coseparating.is_codetecting\n\n",
 "inf_eq_of_is_detecting":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\ntheorem inf_eq_of_is_detecting [has_pullbacks C] {𝒢 : set C} (h𝒢 : is_detecting 𝒢) {X : C} (P Q : subobject X)\n    (h : ∀ G ∈ 𝒢, ∀ {f : «expr ⟶ » G X}, P.factors f → Q.factors f) : «expr ⊓ » P Q = P :=\n  eq_of_le_of_is_detecting h𝒢 _ _ inf_le_left fun G hG f hf => (inf_factors _).2 ⟨hf, h _ hG hf⟩\n#align inf_eq_of_is_detecting inf_eq_of_is_detecting\n\n",
 "has_terminal_of_is_separating":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵖ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵖ» -/\n/-- An ingredient of the proof of the Special Adjoint Functor Theorem: a cocomplete well-copowered\n    category with a small separating set has a terminal object.\n\n    In fact, it follows from the Special Adjoint Functor Theorem that `C` is already complete, see\n    `has_limits_of_has_colimits_of_is_separating`. -/\ntheorem has_terminal_of_is_separating [well_powered («expr ᵒᵖ» C)] [has_colimits C] {𝒢 : set C} [Small.{v₁} 𝒢]\n    (h𝒢 : is_separating 𝒢) : has_terminal C :=\n  by\n  haveI : Small.{v₁} 𝒢.op := small_of_injective (Set.opEquiv_self 𝒢).injective\n  haveI : has_initial («expr ᵒᵖ» C) := has_initial_of_is_coseparating ((is_coseparating_op_iff _).2 h𝒢)\n  exact has_terminal_of_has_initial_op\n#align has_terminal_of_is_separating has_terminal_of_is_separating\n\n",
 "has_initial_of_is_coseparating":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/-- An ingredient of the proof of the Special Adjoint Functor Theorem: a complete well-powered\n    category with a small coseparating set has an initial object.\n\n    In fact, it follows from the Special Adjoint Functor Theorem that `C` is already cocomplete,\n    see `has_colimits_of_has_limits_of_is_coseparating`. -/\ntheorem has_initial_of_is_coseparating [well_powered C] [has_limits C] {𝒢 : set C} [Small.{v₁} 𝒢]\n    (h𝒢 : is_coseparating 𝒢) : has_initial C :=\n  by\n  haveI := has_products_of_shape_of_small C 𝒢\n  haveI := fun A => has_products_of_shape_of_small.{v₁} C (ΣG : 𝒢, «expr ⟶ » A (G : C))\n  letI := completeLatticeOfCompleteSemilatticeInf (subobject (pi_obj (coe : 𝒢 → C)))\n  suffices ∀ A : C, unique («expr ⟶ » ((«expr⊥» : subobject (pi_obj (coe : 𝒢 → C))) : C) A) by\n    exact has_initial_of_unique ((«expr⊥» : subobject (pi_obj (coe : 𝒢 → C))) : C)\n  refine' fun A => ⟨⟨_⟩, fun f => _⟩\n  · let s := pi.lift fun f : ΣG : 𝒢, «expr ⟶ » A (G : C) => id (pi.π (coe : 𝒢 → C)) f.1\n    let t := pi.lift (@sigma.snd 𝒢 fun G => «expr ⟶ » A (G : C))\n    haveI : mono t := (is_coseparating_iff_mono 𝒢).1 h𝒢 A\n    exact «expr ≫ » (subobject.of_le_mk _ (pullback.fst : «expr ⟶ » (pullback s t) _) bot_le) pullback.snd\n  · generalize default = g\n    suffices is_split_epi (equalizer.ι f g) by exact eq_of_epi_equalizer\n    exact\n      is_split_epi.mk'\n        ⟨subobject.of_le_mk _ («expr ≫ » (equalizer.ι f g) (subobject.arrow _)) bot_le,\n          by\n          ext\n          simp⟩\n#align has_initial_of_is_coseparating has_initial_of_is_coseparating\n\n",
 "groupoid_of_is_detecting_empty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem groupoid_of_is_detecting_empty (h : is_detecting (∅ : set C)) {X Y : C} (f : «expr ⟶ » X Y) : IsIso f :=\n  h _ fun G => false.elim\n#align groupoid_of_is_detecting_empty groupoid_of_is_detecting_empty\n\n",
 "groupoid_of_is_codetecting_empty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem groupoid_of_is_codetecting_empty (h : is_codetecting (∅ : set C)) {X Y : C} (f : «expr ⟶ » X Y) : IsIso f :=\n  h _ fun G => false.elim\n#align groupoid_of_is_codetecting_empty groupoid_of_is_codetecting_empty\n\n",
 "eq_of_le_of_is_detecting":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem eq_of_le_of_is_detecting {𝒢 : set C} (h𝒢 : is_detecting 𝒢) {X : C} (P Q : subobject X) (h₁ : P ≤ Q)\n    (h₂ : ∀ G ∈ 𝒢, ∀ {f : «expr ⟶ » G X}, Q.factors f → P.factors f) : P = Q :=\n  by\n  suffices is_iso (of_le _ _ h₁) by exact le_antisymm h₁ (le_of_comm (inv (of_le _ _ h₁)) (by simp))\n  refine' h𝒢 _ fun G hG f => _\n  have : P.factors («expr ≫ » f Q.arrow) := h₂ _ hG ((factors_iff _ _).2 ⟨_, rfl⟩)\n  refine' ⟨factor_thru _ _ this, _, fun g (hg : «expr ≫ » g _ = f) => _⟩\n  · simp only [← cancel_mono Q.arrow, category.assoc, of_le_arrow, factor_thru_arrow]\n  ·\n    simp only [← cancel_mono (subobject.of_le _ _ h₁), ← cancel_mono Q.arrow, hg, category.assoc, of_le_arrow,\n      factor_thru_arrow]\n#align eq_of_le_of_is_detecting eq_of_le_of_is_detecting\n\n",
 "eq_of_is_detecting":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem eq_of_is_detecting [has_pullbacks C] {𝒢 : set C} (h𝒢 : is_detecting 𝒢) {X : C} (P Q : subobject X)\n    (h : ∀ G ∈ 𝒢, ∀ {f : «expr ⟶ » G X}, P.factors f ↔ Q.factors f) : P = Q :=\n  calc\n    P = «expr ⊓ » P Q := eq.symm <| inf_eq_of_is_detecting h𝒢 _ _ fun G hG f hf => (h G hG).1 hf\n    _ = «expr ⊓ » Q P := inf_comm\n    _ = Q := inf_eq_of_is_detecting h𝒢 _ _ fun G hG f hf => (h G hG).2 hf\n    \n#align eq_of_is_detecting eq_of_is_detecting\n\n",
 "def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem is_codetector.def {G : C} :\n    is_codetector G → ∀ ⦃X Y : C⦄ (f : «expr ⟶ » X Y), (∀ h : «expr ⟶ » X G, ∃! h', «expr ≫ » f h' = h) → IsIso f :=\n  (is_codetector_def _).1\n#align is_codetector.def is_codetector.def\n\n"}