{"zero_not_simple":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/-- We don't want the definition of 'simple' to include the zero object, so we check that here. -/\ntheorem zero_not_simple [Simple (0 : C)] : False :=\n  (simple.mono_is_iso_iff_nonzero (0 : Â«expr âŸ¶ Â» (0 : C) (0 : C))).mp âŸ¨âŸ¨0, by tidyâŸ©âŸ© rfl\n#align zero_not_simple zero_not_simple\n\n",
 "subobject_simple_iff_is_atom":
 "/-- A subobject is simple iff it is an atom in the subobject lattice. -/\ntheorem subobject_simple_iff_is_atom {X : C} (Y : Subobject X) : Simple (Y : C) â†” IsAtom Y :=\n  (simple_iff_subobject_isSimpleOrder _).trans\n    ((OrderIso.isSimpleOrder_iff (subobjectOrderIso Y)).trans Set.isSimpleOrder_Iic_iff_isAtom)\n#align subobject_simple_iff_is_atom subobject_simple_iff_is_atom\n\n",
 "simple_of_is_simple_order_subobject":
 "/-- If `X` has subobject lattice `{âŠ¥, âŠ¤}`, then `X` is simple. -/\ntheorem simple_of_is_simple_order_subobject (X : C) [IsSimpleOrder (Subobject X)] : Simple X :=\n  by\n  constructor; intros ; constructor\n  Â· intro i\n    rw [subobject.is_iso_iff_mk_eq_top] at i\n    intro w\n    rw [â† subobject.mk_eq_bot_iff_zero] at w\n    exact IsSimpleOrder.bot_ne_top (w.symm.trans i)\n  Â· intro i\n    rcases is_simple_order.eq_bot_or_eq_top (subobject.mk f) with (h | h)\n    Â· rw [subobject.mk_eq_bot_iff_zero] at h\n      exact false.elim (i h)\n    Â· exact (subobject.is_iso_iff_mk_eq_top _).mpr h\n#align simple_of_is_simple_order_subobject simple_of_is_simple_order_subobject\n\n",
 "simple_of_cosimple":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n-- We next make the dual arguments, but for this we must be in an abelian category.\n/-- In an abelian category, an object satisfying the dual of the definition of a simple object is\n    simple. -/\ntheorem simple_of_cosimple (X : C) (h : âˆ€ {Z : C} (f : Â«expr âŸ¶ Â» X Z) [Epi f], IsIso f â†” f â‰  0) : Simple X :=\n  âŸ¨fun Y f I => by\n    classical\n      fconstructor\n      Â· intros\n        have hx := cokernel.Ï€_of_epi f\n        by_contra\n        subst h\n        exact (h _).mp (cokernel.Ï€_of_zero _ _) hx\n      Â· intro hf\n        suffices epi f by exact is_iso_of_mono_of_epi _\n        apply preadditive.epi_of_cokernel_zero\n        by_contra h'\n        exact cokernel_not_iso_of_nonzero hf ((h _).mpr h')âŸ©\n#align simple_of_cosimple simple_of_cosimple\n\n",
 "simple_iff_subobject_is_simple_order":
 "/-- `X` is simple iff it has subobject lattice `{âŠ¥, âŠ¤}`. -/\ntheorem simple_iff_subobject_is_simple_order (X : C) : Simple X â†” IsSimpleOrder (Subobject X) :=\n  âŸ¨by\n    intro h\n    infer_instance, by\n    intro h\n    exact simple_of_is_simple_order_subobject XâŸ©\n#align simple_iff_subobject_is_simple_order simple_iff_subobject_is_simple_order\n\n",
 "of_iso":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰… Â» -/\ntheorem simple.of_iso {X Y : C} [Simple Y] (i : Â«expr â‰… Â» X Y) : Simple X :=\n  {\n    mono_is_iso_iff_nonzero := fun Z f m => by\n      skip\n      haveI : mono (Â«expr â‰« Â» f i.hom) := mono_comp _ _\n      constructor\n      Â· intro h w\n        have j : is_iso (Â«expr â‰« Â» f i.hom)\n        infer_instance\n        rw [simple.mono_is_iso_iff_nonzero] at j\n        subst w\n        simpa using j\n      Â· intro h\n        have j : is_iso (Â«expr â‰« Â» f i.hom) := by\n          apply is_iso_of_mono_of_nonzero\n          intro w\n          apply h\n          simpa using (cancel_mono i.inv).2 w\n        rw [â† category.comp_id f, â† i.hom_inv_id, â† category.assoc]\n        infer_instance }\n#align simple.of_iso simple.of_iso\n\n",
 "not_is_zero":
 "theorem simple.not_is_zero (X : C) [Simple X] : Â¬IsZero X := by simpa [limits.is_zero.iff_id_eq_zero] using id_nonzero X\n#align simple.not_is_zero simple.not_is_zero\n\n",
 "mono_to_simple_zero_of_not_iso":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem mono_to_simple_zero_of_not_iso {X Y : C} [Simple Y] {f : Â«expr âŸ¶ Â» X Y} [Mono f] (w : IsIso f â†’ False) :\n    f = 0 := by\n  classical\n    by_contra\n    exact w (is_iso_of_mono_of_nonzero h)\n#align mono_to_simple_zero_of_not_iso mono_to_simple_zero_of_not_iso\n\n",
 "kernel_zero_of_nonzero_from_simple":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem kernel_zero_of_nonzero_from_simple {X Y : C} [Simple X] {f : Â«expr âŸ¶ Â» X Y} [HasKernel f] (w : f â‰  0) :\n    kernel.Î¹ f = 0 := by\n  classical\n    by_contra\n    haveI := is_iso_of_mono_of_nonzero h\n    exact w (eq_zero_of_epi_kernel f)\n#align kernel_zero_of_nonzero_from_simple kernel_zero_of_nonzero_from_simple\n\n",
 "is_iso_of_mono_of_nonzero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/-\nCopyright (c) 2020 Scott Morrison. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Markus Himmel, Scott Morrison\n-/\n/-- A nonzero monomorphism to a simple object is an isomorphism. -/\ntheorem is_iso_of_mono_of_nonzero {X Y : C} [Simple Y] {f : Â«expr âŸ¶ Â» X Y} [Mono f] (w : f â‰  0) : IsIso f :=\n  (simple.mono_is_iso_iff_nonzero f).mpr w\n#align is_iso_of_mono_of_nonzero is_iso_of_mono_of_nonzero\n\n",
 "is_iso_of_epi_of_nonzero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/-- A nonzero epimorphism from a simple object is an isomorphism. -/\ntheorem is_iso_of_epi_of_nonzero {X Y : C} [Simple X] {f : Â«expr âŸ¶ Â» X Y} [Epi f] (w : f â‰  0) : IsIso f :=\n  haveI-- `f â‰  0` means that `kernel.Î¹ f` is not an iso, and hence zero, and hence `f` is a mono.\n   : mono f := preadditive.mono_of_kernel_zero (mono_to_simple_zero_of_not_iso (kernel_not_iso_of_nonzero w))\n  is_iso_of_mono_of_epi f\n#align is_iso_of_epi_of_nonzero is_iso_of_epi_of_nonzero\n\n",
 "is_iso_inl_iff_is_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr =â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŠž Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŠž Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŠž Â» -/\n-- There are another three potential variations of this lemma,\n-- but as any one suffices to prove `indecomposable_of_simple` we will not give them all.\ntheorem biprod.is_iso_inl_iff_is_zero (X Y : C) : IsIso (biprod.inl : Â«expr âŸ¶ Â» X (Â«expr âŠž Â» X Y)) â†” IsZero Y :=\n  by\n  rw [biprod.is_iso_inl_iff_id_eq_fst_comp_inl, â† biprod.total, add_right_eq_self]\n  constructor\n  Â· intro h\n    replace h := Â«expr =â‰« Â» h biprod.snd\n    simpa [â† is_zero.iff_is_split_epi_eq_zero (biprod.snd : Â«expr âŸ¶ Â» (Â«expr âŠž Â» X Y) Y)] using h\n  Â· intro h\n    rw [is_zero.iff_is_split_epi_eq_zero (biprod.snd : Â«expr âŸ¶ Â» (Â«expr âŠž Â» X Y) Y)] at h\n    rw [h, zero_comp]\n#align biprod.is_iso_inl_iff_is_zero biprod.is_iso_inl_iff_is_zero\n\n",
 "indecomposable_of_simple":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŠž Â» -/\n/-- Any simple object in a preadditive category is indecomposable. -/\ntheorem indecomposable_of_simple (X : C) [Simple X] : Indecomposable X :=\n  âŸ¨Simple.not_isZero X, fun Y Z i => by\n    refine' or_iff_not_imp_left.mpr fun h => _\n    rw [is_zero.iff_is_split_mono_eq_zero (biprod.inl : Â«expr âŸ¶ Â» Y (Â«expr âŠž Â» Y Z))] at h\n    change biprod.inl â‰  0 at h\n    rw [â† simple.mono_is_iso_iff_nonzero biprod.inl] at h\n    Â· rwa [biprod.is_iso_inl_iff_is_zero] at h\n    Â· exact simple.of_iso i.symm\n    Â· infer_instanceâŸ©\n#align indecomposable_of_simple indecomposable_of_simple\n\n",
 "iff_of_iso":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰… Â» -/\ntheorem simple.iff_of_iso {X Y : C} (i : Â«expr â‰… Â» X Y) : Simple X â†” Simple Y :=\n  âŸ¨fun h => simple.of_iso i.symm, fun h => simple.of_iso iâŸ©\n#align simple.iff_of_iso simple.iff_of_iso\n\n",
 "id_nonzero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprðŸ™Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprðŸ™Â» -/\ntheorem id_nonzero (X : C) [Simple.{v} X] : (Â«exprðŸ™Â») X â‰  0 :=\n  (simple.mono_is_iso_iff_nonzero ((Â«exprðŸ™Â») X)).mp (by infer_instance)\n#align id_nonzero id_nonzero\n\n",
 "epi_of_nonzero_to_simple":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n-- See also `mono_of_nonzero_from_simple`, which requires `preadditive C`.\n/-- A nonzero morphism `f` to a simple object is an epimorphism\n(assuming `f` has an image, and `C` has equalizers).\n-/\ntheorem epi_of_nonzero_to_simple [HasEqualizers C] {X Y : C} [Simple Y] {f : Â«expr âŸ¶ Â» X Y} [HasImage f] (w : f â‰  0) :\n    Epi f := by\n  rw [â† image.fac f]\n  haveI : is_iso (image.Î¹ f) := is_iso_of_mono_of_nonzero fun h => w (eq_zero_of_image_eq_zero h)\n  apply epi_comp\n#align epi_of_nonzero_to_simple epi_of_nonzero_to_simple\n\n",
 "epi_from_simple_zero_of_not_iso":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem epi_from_simple_zero_of_not_iso {X Y : C} [Simple X] {f : Â«expr âŸ¶ Â» X Y} [Epi f] (w : IsIso f â†’ False) :\n    f = 0 := by\n  classical\n    by_contra\n    exact w (is_iso_of_epi_of_nonzero h)\n#align epi_from_simple_zero_of_not_iso epi_from_simple_zero_of_not_iso\n\n",
 "cokernel_zero_of_nonzero_to_simple":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem cokernel_zero_of_nonzero_to_simple {X Y : C} [Simple Y] {f : Â«expr âŸ¶ Â» X Y} (w : f â‰  0) : cokernel.Ï€ f = 0 := by\n  classical\n    by_contra h\n    haveI := is_iso_of_epi_of_nonzero h\n    exact w (eq_zero_of_mono_cokernel f)\n#align cokernel_zero_of_nonzero_to_simple cokernel_zero_of_nonzero_to_simple\n\n"}