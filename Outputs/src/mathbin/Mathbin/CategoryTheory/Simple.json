{"zero_not_simple":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/-- We don't want the definition of 'simple' to include the zero object, so we check that here. -/\ntheorem zero_not_simple [Simple (0 : C)] : False :=\n  (simple.mono_is_iso_iff_nonzero (0 : «expr ⟶ » (0 : C) (0 : C))).mp ⟨⟨0, by tidy⟩⟩ rfl\n#align zero_not_simple zero_not_simple\n\n",
 "subobject_simple_iff_is_atom":
 "/-- A subobject is simple iff it is an atom in the subobject lattice. -/\ntheorem subobject_simple_iff_is_atom {X : C} (Y : Subobject X) : Simple (Y : C) ↔ IsAtom Y :=\n  (simple_iff_subobject_isSimpleOrder _).trans\n    ((OrderIso.isSimpleOrder_iff (subobjectOrderIso Y)).trans Set.isSimpleOrder_Iic_iff_isAtom)\n#align subobject_simple_iff_is_atom subobject_simple_iff_is_atom\n\n",
 "simple_of_is_simple_order_subobject":
 "/-- If `X` has subobject lattice `{⊥, ⊤}`, then `X` is simple. -/\ntheorem simple_of_is_simple_order_subobject (X : C) [IsSimpleOrder (Subobject X)] : Simple X :=\n  by\n  constructor; intros ; constructor\n  · intro i\n    rw [subobject.is_iso_iff_mk_eq_top] at i\n    intro w\n    rw [← subobject.mk_eq_bot_iff_zero] at w\n    exact IsSimpleOrder.bot_ne_top (w.symm.trans i)\n  · intro i\n    rcases is_simple_order.eq_bot_or_eq_top (subobject.mk f) with (h | h)\n    · rw [subobject.mk_eq_bot_iff_zero] at h\n      exact false.elim (i h)\n    · exact (subobject.is_iso_iff_mk_eq_top _).mpr h\n#align simple_of_is_simple_order_subobject simple_of_is_simple_order_subobject\n\n",
 "simple_of_cosimple":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n-- We next make the dual arguments, but for this we must be in an abelian category.\n/-- In an abelian category, an object satisfying the dual of the definition of a simple object is\n    simple. -/\ntheorem simple_of_cosimple (X : C) (h : ∀ {Z : C} (f : «expr ⟶ » X Z) [Epi f], IsIso f ↔ f ≠ 0) : Simple X :=\n  ⟨fun Y f I => by\n    classical\n      fconstructor\n      · intros\n        have hx := cokernel.π_of_epi f\n        by_contra\n        subst h\n        exact (h _).mp (cokernel.π_of_zero _ _) hx\n      · intro hf\n        suffices epi f by exact is_iso_of_mono_of_epi _\n        apply preadditive.epi_of_cokernel_zero\n        by_contra h'\n        exact cokernel_not_iso_of_nonzero hf ((h _).mpr h')⟩\n#align simple_of_cosimple simple_of_cosimple\n\n",
 "simple_iff_subobject_is_simple_order":
 "/-- `X` is simple iff it has subobject lattice `{⊥, ⊤}`. -/\ntheorem simple_iff_subobject_is_simple_order (X : C) : Simple X ↔ IsSimpleOrder (Subobject X) :=\n  ⟨by\n    intro h\n    infer_instance, by\n    intro h\n    exact simple_of_is_simple_order_subobject X⟩\n#align simple_iff_subobject_is_simple_order simple_iff_subobject_is_simple_order\n\n",
 "of_iso":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≅ » -/\ntheorem simple.of_iso {X Y : C} [Simple Y] (i : «expr ≅ » X Y) : Simple X :=\n  {\n    mono_is_iso_iff_nonzero := fun Z f m => by\n      skip\n      haveI : mono («expr ≫ » f i.hom) := mono_comp _ _\n      constructor\n      · intro h w\n        have j : is_iso («expr ≫ » f i.hom)\n        infer_instance\n        rw [simple.mono_is_iso_iff_nonzero] at j\n        subst w\n        simpa using j\n      · intro h\n        have j : is_iso («expr ≫ » f i.hom) := by\n          apply is_iso_of_mono_of_nonzero\n          intro w\n          apply h\n          simpa using (cancel_mono i.inv).2 w\n        rw [← category.comp_id f, ← i.hom_inv_id, ← category.assoc]\n        infer_instance }\n#align simple.of_iso simple.of_iso\n\n",
 "not_is_zero":
 "theorem simple.not_is_zero (X : C) [Simple X] : ¬IsZero X := by simpa [limits.is_zero.iff_id_eq_zero] using id_nonzero X\n#align simple.not_is_zero simple.not_is_zero\n\n",
 "mono_to_simple_zero_of_not_iso":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem mono_to_simple_zero_of_not_iso {X Y : C} [Simple Y] {f : «expr ⟶ » X Y} [Mono f] (w : IsIso f → False) :\n    f = 0 := by\n  classical\n    by_contra\n    exact w (is_iso_of_mono_of_nonzero h)\n#align mono_to_simple_zero_of_not_iso mono_to_simple_zero_of_not_iso\n\n",
 "kernel_zero_of_nonzero_from_simple":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem kernel_zero_of_nonzero_from_simple {X Y : C} [Simple X] {f : «expr ⟶ » X Y} [HasKernel f] (w : f ≠ 0) :\n    kernel.ι f = 0 := by\n  classical\n    by_contra\n    haveI := is_iso_of_mono_of_nonzero h\n    exact w (eq_zero_of_epi_kernel f)\n#align kernel_zero_of_nonzero_from_simple kernel_zero_of_nonzero_from_simple\n\n",
 "is_iso_of_mono_of_nonzero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/-\nCopyright (c) 2020 Scott Morrison. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Markus Himmel, Scott Morrison\n-/\n/-- A nonzero monomorphism to a simple object is an isomorphism. -/\ntheorem is_iso_of_mono_of_nonzero {X Y : C} [Simple Y] {f : «expr ⟶ » X Y} [Mono f] (w : f ≠ 0) : IsIso f :=\n  (simple.mono_is_iso_iff_nonzero f).mpr w\n#align is_iso_of_mono_of_nonzero is_iso_of_mono_of_nonzero\n\n",
 "is_iso_of_epi_of_nonzero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/-- A nonzero epimorphism from a simple object is an isomorphism. -/\ntheorem is_iso_of_epi_of_nonzero {X Y : C} [Simple X] {f : «expr ⟶ » X Y} [Epi f] (w : f ≠ 0) : IsIso f :=\n  haveI-- `f ≠ 0` means that `kernel.ι f` is not an iso, and hence zero, and hence `f` is a mono.\n   : mono f := preadditive.mono_of_kernel_zero (mono_to_simple_zero_of_not_iso (kernel_not_iso_of_nonzero w))\n  is_iso_of_mono_of_epi f\n#align is_iso_of_epi_of_nonzero is_iso_of_epi_of_nonzero\n\n",
 "is_iso_inl_iff_is_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊞ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊞ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊞ » -/\n-- There are another three potential variations of this lemma,\n-- but as any one suffices to prove `indecomposable_of_simple` we will not give them all.\ntheorem biprod.is_iso_inl_iff_is_zero (X Y : C) : IsIso (biprod.inl : «expr ⟶ » X («expr ⊞ » X Y)) ↔ IsZero Y :=\n  by\n  rw [biprod.is_iso_inl_iff_id_eq_fst_comp_inl, ← biprod.total, add_right_eq_self]\n  constructor\n  · intro h\n    replace h := «expr =≫ » h biprod.snd\n    simpa [← is_zero.iff_is_split_epi_eq_zero (biprod.snd : «expr ⟶ » («expr ⊞ » X Y) Y)] using h\n  · intro h\n    rw [is_zero.iff_is_split_epi_eq_zero (biprod.snd : «expr ⟶ » («expr ⊞ » X Y) Y)] at h\n    rw [h, zero_comp]\n#align biprod.is_iso_inl_iff_is_zero biprod.is_iso_inl_iff_is_zero\n\n",
 "indecomposable_of_simple":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊞ » -/\n/-- Any simple object in a preadditive category is indecomposable. -/\ntheorem indecomposable_of_simple (X : C) [Simple X] : Indecomposable X :=\n  ⟨Simple.not_isZero X, fun Y Z i => by\n    refine' or_iff_not_imp_left.mpr fun h => _\n    rw [is_zero.iff_is_split_mono_eq_zero (biprod.inl : «expr ⟶ » Y («expr ⊞ » Y Z))] at h\n    change biprod.inl ≠ 0 at h\n    rw [← simple.mono_is_iso_iff_nonzero biprod.inl] at h\n    · rwa [biprod.is_iso_inl_iff_is_zero] at h\n    · exact simple.of_iso i.symm\n    · infer_instance⟩\n#align indecomposable_of_simple indecomposable_of_simple\n\n",
 "iff_of_iso":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≅ » -/\ntheorem simple.iff_of_iso {X Y : C} (i : «expr ≅ » X Y) : Simple X ↔ Simple Y :=\n  ⟨fun h => simple.of_iso i.symm, fun h => simple.of_iso i⟩\n#align simple.iff_of_iso simple.iff_of_iso\n\n",
 "id_nonzero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\ntheorem id_nonzero (X : C) [Simple.{v} X] : («expr𝟙») X ≠ 0 :=\n  (simple.mono_is_iso_iff_nonzero ((«expr𝟙») X)).mp (by infer_instance)\n#align id_nonzero id_nonzero\n\n",
 "epi_of_nonzero_to_simple":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n-- See also `mono_of_nonzero_from_simple`, which requires `preadditive C`.\n/-- A nonzero morphism `f` to a simple object is an epimorphism\n(assuming `f` has an image, and `C` has equalizers).\n-/\ntheorem epi_of_nonzero_to_simple [HasEqualizers C] {X Y : C} [Simple Y] {f : «expr ⟶ » X Y} [HasImage f] (w : f ≠ 0) :\n    Epi f := by\n  rw [← image.fac f]\n  haveI : is_iso (image.ι f) := is_iso_of_mono_of_nonzero fun h => w (eq_zero_of_image_eq_zero h)\n  apply epi_comp\n#align epi_of_nonzero_to_simple epi_of_nonzero_to_simple\n\n",
 "epi_from_simple_zero_of_not_iso":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem epi_from_simple_zero_of_not_iso {X Y : C} [Simple X] {f : «expr ⟶ » X Y} [Epi f] (w : IsIso f → False) :\n    f = 0 := by\n  classical\n    by_contra\n    exact w (is_iso_of_epi_of_nonzero h)\n#align epi_from_simple_zero_of_not_iso epi_from_simple_zero_of_not_iso\n\n",
 "cokernel_zero_of_nonzero_to_simple":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem cokernel_zero_of_nonzero_to_simple {X Y : C} [Simple Y] {f : «expr ⟶ » X Y} (w : f ≠ 0) : cokernel.π f = 0 := by\n  classical\n    by_contra h\n    haveI := is_iso_of_epi_of_nonzero h\n    exact w (eq_zero_of_mono_cokernel f)\n#align cokernel_zero_of_nonzero_to_simple cokernel_zero_of_nonzero_to_simple\n\n"}