{"unit_inverse_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≌ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/-- The other triangle equality. The proof follows the following proof in Globular:\n  http://globular.science/1905.001 -/\n@[simp]\ntheorem unit_inverse_comp (e : «expr ≌ » C D) (Y : D) :\n    «expr ≫ » (e.unit.app (e.inverse.obj Y)) (e.inverse.map (e.counit.app Y)) = («expr𝟙») (e.inverse.obj Y) :=\n  by\n  rw [← id_comp (e.inverse.map _), ← map_id e.inverse, ← counit_inv_functor_comp, map_comp]\n  dsimp\n  rw [← iso.hom_inv_id_assoc (e.unit_iso.app _) (e.inverse.map (e.functor.map _)), app_hom, app_inv]\n  slice_lhs 2 3 => erw [e.unit.naturality]\n  slice_lhs 1 2 => erw [e.unit.naturality]\n  slice_lhs 4 4 => rw [← iso.hom_inv_id_assoc (e.inverse.map_iso (e.counit_iso.app _)) (e.unit_inv.app _)]\n  slice_lhs 3 4 =>\n    erw [← map_comp e.inverse, e.counit.naturality]\n    erw [(e.counit_iso.app _).hom_inv_id, map_id]\n  erw [id_comp]\n  slice_lhs 2 3 => erw [← map_comp e.inverse, e.counit_iso.inv.naturality, map_comp]\n  slice_lhs 3 4 => erw [e.unit_inv.naturality]\n  slice_lhs 4 5 => erw [← map_comp («expr ⋙ » e.functor e.inverse), (e.unit_iso.app _).hom_inv_id, map_id]\n  erw [id_comp]\n  slice_lhs 3 4 => erw [← e.unit_inv.naturality]\n  slice_lhs 2 3 => erw [← map_comp e.inverse, ← e.counit_iso.inv.naturality, (e.counit_iso.app _).hom_inv_id, map_id]\n  erw [id_comp, (e.unit_iso.app _).hom_inv_id]; rfl\n#align unit_inverse_comp unit_inverse_comp\n\n",
 "unit_inv_app_inverse":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≌ » -/\ntheorem unit_inv_app_inverse (e : «expr ≌ » C D) (Y : D) :\n    e.unit_inv.app (e.inverse.obj Y) = e.inverse.map (e.counit.app Y) :=\n  by\n  symm\n  erw [← iso.hom_comp_eq_id (e.unit_iso.app _), unit_inverse_comp]\n  rfl\n#align unit_inv_app_inverse unit_inv_app_inverse\n\n",
 "unit_app_inverse":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≌ » -/\ntheorem unit_app_inverse (e : «expr ≌ » C D) (Y : D) :\n    e.unit.app (e.inverse.obj Y) = e.inverse.map (e.counit_inv.app Y) :=\n  by\n  erw [← iso.comp_hom_eq_id (e.inverse.map_iso (e.counit_iso.app Y)), unit_inverse_comp]\n  rfl\n#align unit_app_inverse unit_app_inverse\n\n",
 "pow_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≌ » -/\n#print pow_zero /-\n-- There's of course a monoid structure on `C ≌ C`,\n-- but let's not encourage using it.\n-- The power structure is nevertheless useful.\n@[simp]\ntheorem pow_zero (e : «expr ≌ » C C) : e ^ (0 : ℤ) = equivalence.refl :=\n  rfl\n#align pow_zero pow_zero\n-/\n\n",
 "pow_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≌ » -/\n#print pow_one /-\n@[simp]\ntheorem pow_one (e : «expr ≌ » C C) : e ^ (1 : ℤ) = e :=\n  rfl\n#align pow_one pow_one\n-/\n\n",
 "pow_neg_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≌ » -/\n@[simp]\ntheorem pow_neg_one (e : «expr ≌ » C C) : e ^ (-1 : ℤ) = e.symm :=\n  rfl\n#align pow_neg_one pow_neg_one\n\n",
 "of_iso_trans":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≅ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≅ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≪≫ » -/\n/-- Compatibility of `of_iso` with the composition of isomorphisms of functors -/\ntheorem of_iso_trans {F G H : «expr ⥤ » C D} (e : «expr ≅ » F G) (e' : «expr ≅ » G H) (hF : is_equivalence F) :\n    of_iso e' (of_iso e hF) = of_iso («expr ≪≫ » e e') hF :=\n  by\n  dsimp [of_iso]\n  congr 1 <;> ext X <;> dsimp [nat_iso.hcomp]\n  · simp only [id_comp, assoc, functor.map_comp]\n  · simp only [Functor.map_id, comp_id, id_comp, assoc]\n#align of_iso_trans of_iso_trans\n\n",
 "of_iso_refl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/-- Compatibility of `of_iso` with identity isomorphisms of functors -/\ntheorem of_iso_refl (F : «expr ⥤ » C D) (hF : is_equivalence F) : of_iso (Iso.refl F) hF = hF :=\n  by\n  rcases hF with ⟨Finv, Funit, Fcounit, Fcomp⟩\n  dsimp [of_iso]\n  congr 1 <;> ext X <;> dsimp [nat_iso.hcomp]\n  · simp only [comp_id, map_id]\n  · simp only [id_comp, map_id]\n#align of_iso_refl of_iso_refl\n\n",
 "inverse_map_inj_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≌ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n@[simp]\ntheorem inverse_map_inj_iff (e : «expr ≌ » C D) {X Y : D} (f g : «expr ⟶ » X Y) :\n    e.inverse.map f = e.inverse.map g ↔ f = g :=\n  functor_map_inj_iff e.symm f g\n#align inverse_map_inj_iff inverse_map_inj_iff\n\n",
 "inverse_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≌ » -/\n@[simp]\ntheorem inverse_inv (E : «expr ≌ » C D) : E.inverse.inv = E.functor :=\n  rfl\n#align inverse_inv inverse_inv\n\n",
 "inverse_counit_inv_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≪≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≌ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n@[simp]\ntheorem inverse_counit_inv_comp (e : «expr ≌ » C D) (Y : D) :\n    «expr ≫ » (e.inverse.map (e.counit_inv.app Y)) (e.unit_inv.app (e.inverse.obj Y)) = («expr𝟙») (e.inverse.obj Y) :=\n  by\n  erw [iso.inv_eq_inv («expr ≪≫ » (e.unit_iso.app (e.inverse.obj Y)) (e.inverse.map_iso (e.counit_iso.app Y)))\n      (iso.refl _)]\n  exact e.unit_inverse_comp Y\n#align inverse_counit_inv_comp inverse_counit_inv_comp\n\n",
 "inverse_as_equivalence":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≌ » -/\n@[simp]\ntheorem inverse_as_equivalence (E : «expr ≌ » C D) : E.inverse.as_equivalence = E.symm :=\n  by\n  cases E\n  congr\n#align inverse_as_equivalence inverse_as_equivalence\n\n",
 "inv_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n#print inv_inv /-\n@[simp]\ntheorem inv_inv (F : «expr ⥤ » C D) [is_equivalence F] : inv (inv F) = F :=\n  rfl\n#align inv_inv inv_inv\n-/\n\n",
 "inv_fun_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp]\ntheorem inv_fun_map (F : «expr ⥤ » C D) [is_equivalence F] (X Y : C) (f : «expr ⟶ » X Y) :\n    F.inv.map (F.map f) = «expr ≫ » (F.as_equivalence.unit_inv.app X) («expr ≫ » f (F.as_equivalence.unit.app Y)) :=\n  by\n  erw [nat_iso.naturality_1]\n  rfl\n#align inv_fun_map inv_fun_map\n\n",
 "inv_fun_id_assoc_inv_app":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≌ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n@[simp]\ntheorem inv_fun_id_assoc_inv_app (e : «expr ≌ » C D) (F : «expr ⥤ » D E) (X : D) :\n    (inv_fun_id_assoc e F).inv.app X = F.map (e.counit_inv.app X) :=\n  by\n  dsimp [inv_fun_id_assoc]\n  tidy\n#align inv_fun_id_assoc_inv_app inv_fun_id_assoc_inv_app\n\n",
 "inv_fun_id_assoc_hom_app":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≌ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n@[simp]\ntheorem inv_fun_id_assoc_hom_app (e : «expr ≌ » C D) (F : «expr ⥤ » D E) (X : D) :\n    (inv_fun_id_assoc e F).hom.app X = F.map (e.counit.app X) :=\n  by\n  dsimp [inv_fun_id_assoc]\n  tidy\n#align inv_fun_id_assoc_hom_app inv_fun_id_assoc_hom_app\n\n",
 "functor_unit_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≌ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n@[simp]\ntheorem functor_unit_comp (e : «expr ≌ » C D) (X : C) :\n    «expr ≫ » (e.functor.map (e.unit.app X)) (e.counit.app (e.functor.obj X)) = («expr𝟙») (e.functor.obj X) :=\n  e.functor_unit_iso_comp X\n#align functor_unit_comp functor_unit_comp\n\n",
 "functor_map_inj_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≌ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n-- see Note [lower instance priority]\n-- see Note [lower instance priority]\n@[simp]\ntheorem functor_map_inj_iff (e : «expr ≌ » C D) {X Y : C} (f g : «expr ⟶ » X Y) :\n    e.functor.map f = e.functor.map g ↔ f = g :=\n  ⟨fun h => e.functor.map_injective h, fun h => h ▸ rfl⟩\n#align functor_map_inj_iff functor_map_inj_iff\n\n",
 "functor_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≌ » -/\n@[simp]\ntheorem functor_inv (E : «expr ≌ » C D) : E.functor.inv = E.inverse :=\n  rfl\n#align functor_inv functor_inv\n\n",
 "functor_as_equivalence":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≌ » -/\n@[simp]\ntheorem functor_as_equivalence (E : «expr ≌ » C D) : E.functor.as_equivalence = E :=\n  by\n  cases E\n  congr\n#align functor_as_equivalence functor_as_equivalence\n\n",
 "fun_inv_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp]\ntheorem fun_inv_map (F : «expr ⥤ » C D) [is_equivalence F] (X Y : D) (f : «expr ⟶ » X Y) :\n    F.map (F.inv.map f) = «expr ≫ » (F.as_equivalence.counit.app X) («expr ≫ » f (F.as_equivalence.counit_inv.app Y)) :=\n  by\n  erw [nat_iso.naturality_2]\n  rfl\n#align fun_inv_map fun_inv_map\n\n",
 "fun_inv_id_assoc_inv_app":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≌ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n@[simp]\ntheorem fun_inv_id_assoc_inv_app (e : «expr ≌ » C D) (F : «expr ⥤ » C E) (X : C) :\n    (fun_inv_id_assoc e F).inv.app X = F.map (e.unit.app X) :=\n  by\n  dsimp [fun_inv_id_assoc]\n  tidy\n#align fun_inv_id_assoc_inv_app fun_inv_id_assoc_inv_app\n\n",
 "fun_inv_id_assoc_hom_app":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≌ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n-- We wouldn't have needed to give this proof if we'd used `equivalence.mk`,\n-- but we choose to avoid using that here, for the sake of good structure projection `simp`\n-- lemmas.\n@[simp]\ntheorem fun_inv_id_assoc_hom_app (e : «expr ≌ » C D) (F : «expr ⥤ » C E) (X : C) :\n    (fun_inv_id_assoc e F).hom.app X = F.map (e.unit_inv.app X) :=\n  by\n  dsimp [fun_inv_id_assoc]\n  tidy\n#align fun_inv_id_assoc_hom_app fun_inv_id_assoc_hom_app\n\n",
 "ess_surj_of_equivalence":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/-- An equivalence is essentially surjective.\n\nSee <https://stacks.math.columbia.edu/tag/02C3>.\n-/\ntheorem ess_surj_of_equivalence (F : «expr ⥤ » C D) [is_equivalence F] : EssSurj F :=\n  ⟨fun Y => ⟨F.inv.obj Y, ⟨F.as_equivalence.counit_iso.app Y⟩⟩⟩\n#align ess_surj_of_equivalence ess_surj_of_equivalence\n\n",
 "equivalence_mk'_unit_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≌ » -/\n@[simp]\ntheorem equivalence_mk'_unit_inv (functor inverse unit_iso counit_iso f) :\n    (⟨functor, inverse, unit_iso, counit_iso, f⟩ : «expr ≌ » C D).unit_inv = unit_iso.inv :=\n  rfl\n#align equivalence_mk'_unit_inv equivalence_mk'_unit_inv\n\n",
 "equivalence_mk'_unit":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≌ » -/\n/-\nCopyright (c) 2017 Scott Morrison. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Tim Baumann, Stephen Morgan, Scott Morrison, Floris van Doorn\n-/\n-- declare the `v`'s first; see `category_theory.category` for an explanation\n/- While these abbreviations are convenient, they also cause some trouble,\npreventing structure projections from unfolding. -/\n@[simp]\ntheorem equivalence_mk'_unit (functor inverse unit_iso counit_iso f) :\n    (⟨functor, inverse, unit_iso, counit_iso, f⟩ : «expr ≌ » C D).unit = unit_iso.hom :=\n  rfl\n#align equivalence_mk'_unit equivalence_mk'_unit\n\n",
 "equivalence_mk'_counit_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≌ » -/\n@[simp]\ntheorem equivalence_mk'_counit_inv (functor inverse unit_iso counit_iso f) :\n    (⟨functor, inverse, unit_iso, counit_iso, f⟩ : «expr ≌ » C D).counit_inv = counit_iso.inv :=\n  rfl\n#align equivalence_mk'_counit_inv equivalence_mk'_counit_inv\n\n",
 "equivalence_mk'_counit":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≌ » -/\n@[simp]\ntheorem equivalence_mk'_counit (functor inverse unit_iso counit_iso f) :\n    (⟨functor, inverse, unit_iso, counit_iso, f⟩ : «expr ≌ » C D).counit = counit_iso.hom :=\n  rfl\n#align equivalence_mk'_counit equivalence_mk'_counit\n\n",
 "counit_inv_functor_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≪≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≌ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n@[simp]\ntheorem counit_inv_functor_comp (e : «expr ≌ » C D) (X : C) :\n    «expr ≫ » (e.counit_inv.app (e.functor.obj X)) (e.functor.map (e.unit_inv.app X)) = («expr𝟙») (e.functor.obj X) :=\n  by\n  erw [iso.inv_eq_inv («expr ≪≫ » (e.functor.map_iso (e.unit_iso.app X)) (e.counit_iso.app (e.functor.obj X)))\n      (iso.refl _)]\n  exact e.functor_unit_comp X\n#align counit_inv_functor_comp counit_inv_functor_comp\n\n",
 "counit_inv_app_functor":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≌ » -/\ntheorem counit_inv_app_functor (e : «expr ≌ » C D) (X : C) :\n    e.counit_inv.app (e.functor.obj X) = e.functor.map (e.unit.app X) :=\n  by\n  symm\n  erw [← iso.comp_hom_eq_id (e.counit_iso.app _), functor_unit_comp]\n  rfl\n#align counit_inv_app_functor counit_inv_app_functor\n\n",
 "counit_app_functor":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≌ » -/\ntheorem counit_app_functor (e : «expr ≌ » C D) (X : C) :\n    e.counit.app (e.functor.obj X) = e.functor.map (e.unit_inv.app X) :=\n  by\n  erw [← iso.hom_comp_eq_id (e.functor.map_iso (e.unit_iso.app X)), functor_unit_comp]\n  rfl\n#align counit_app_functor counit_app_functor\n\n",
 "cancel_unit_right_assoc'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp]\ntheorem cancel_unit_right_assoc' {W X X' Y Y' Z : C} (f : «expr ⟶ » W X) (g : «expr ⟶ » X Y) (h : «expr ⟶ » Y Z)\n    (f' : «expr ⟶ » W X') (g' : «expr ⟶ » X' Y') (h' : «expr ⟶ » Y' Z) :\n    «expr ≫ » f («expr ≫ » g («expr ≫ » h (e.unit.app Z))) = «expr ≫ » f' («expr ≫ » g' («expr ≫ » h' (e.unit.app Z))) ↔\n      «expr ≫ » f («expr ≫ » g h) = «expr ≫ » f' («expr ≫ » g' h') :=\n  by simp only [← category.assoc, cancel_mono]\n#align cancel_unit_right_assoc' cancel_unit_right_assoc'\n\n",
 "cancel_unit_right_assoc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp]\ntheorem cancel_unit_right_assoc {W X X' Y : C} (f : «expr ⟶ » W X) (g : «expr ⟶ » X Y) (f' : «expr ⟶ » W X')\n    (g' : «expr ⟶ » X' Y) :\n    «expr ≫ » f («expr ≫ » g (e.unit.app Y)) = «expr ≫ » f' («expr ≫ » g' (e.unit.app Y)) ↔\n      «expr ≫ » f g = «expr ≫ » f' g' :=\n  by simp only [← category.assoc, cancel_mono]\n#align cancel_unit_right_assoc cancel_unit_right_assoc\n\n",
 "cancel_unit_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- We need special forms of `cancel_nat_iso_hom_right(_assoc)` and\n`cancel_nat_iso_inv_right(_assoc)` for units and counits, because neither `simp` or `rw` will apply\nthose lemmas in this setting without providing `e.unit_iso` (or similar) as an explicit argument.\nWe also provide the lemmas for length four compositions, since they're occasionally useful.\n(e.g. in proving that equivalences take monos to monos) -/\n@[simp]\ntheorem cancel_unit_right {X Y : C} (f f' : «expr ⟶ » X Y) :\n    «expr ≫ » f (e.unit.app Y) = «expr ≫ » f' (e.unit.app Y) ↔ f = f' := by simp only [cancel_mono]\n#align cancel_unit_right cancel_unit_right\n\n",
 "cancel_unit_inv_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp]\ntheorem cancel_unit_inv_right {X Y : C} (f f' : «expr ⟶ » X (e.inverse.obj (e.functor.obj Y))) :\n    «expr ≫ » f (e.unit_inv.app Y) = «expr ≫ » f' (e.unit_inv.app Y) ↔ f = f' := by simp only [cancel_mono]\n#align cancel_unit_inv_right cancel_unit_inv_right\n\n",
 "cancel_counit_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp]\ntheorem cancel_counit_right {X Y : D} (f f' : «expr ⟶ » X (e.functor.obj (e.inverse.obj Y))) :\n    «expr ≫ » f (e.counit.app Y) = «expr ≫ » f' (e.counit.app Y) ↔ f = f' := by simp only [cancel_mono]\n#align cancel_counit_right cancel_counit_right\n\n",
 "cancel_counit_inv_right_assoc'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp]\ntheorem cancel_counit_inv_right_assoc' {W X X' Y Y' Z : D} (f : «expr ⟶ » W X) (g : «expr ⟶ » X Y) (h : «expr ⟶ » Y Z)\n    (f' : «expr ⟶ » W X') (g' : «expr ⟶ » X' Y') (h' : «expr ⟶ » Y' Z) :\n    «expr ≫ » f («expr ≫ » g («expr ≫ » h (e.counit_inv.app Z))) =\n        «expr ≫ » f' («expr ≫ » g' («expr ≫ » h' (e.counit_inv.app Z))) ↔\n      «expr ≫ » f («expr ≫ » g h) = «expr ≫ » f' («expr ≫ » g' h') :=\n  by simp only [← category.assoc, cancel_mono]\n#align cancel_counit_inv_right_assoc' cancel_counit_inv_right_assoc'\n\n",
 "cancel_counit_inv_right_assoc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp]\ntheorem cancel_counit_inv_right_assoc {W X X' Y : D} (f : «expr ⟶ » W X) (g : «expr ⟶ » X Y) (f' : «expr ⟶ » W X')\n    (g' : «expr ⟶ » X' Y) :\n    «expr ≫ » f («expr ≫ » g (e.counit_inv.app Y)) = «expr ≫ » f' («expr ≫ » g' (e.counit_inv.app Y)) ↔\n      «expr ≫ » f g = «expr ≫ » f' g' :=\n  by simp only [← category.assoc, cancel_mono]\n#align cancel_counit_inv_right_assoc cancel_counit_inv_right_assoc\n\n",
 "cancel_counit_inv_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp]\ntheorem cancel_counit_inv_right {X Y : D} (f f' : «expr ⟶ » X Y) :\n    «expr ≫ » f (e.counit_inv.app Y) = «expr ≫ » f' (e.counit_inv.app Y) ↔ f = f' := by simp only [cancel_mono]\n#align cancel_counit_inv_right cancel_counit_inv_right\n\n",
 "as_equivalence_unit":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n@[simp]\ntheorem as_equivalence_unit {F : «expr ⥤ » C D} [h : is_equivalence F] :\n    F.as_equivalence.unit_iso = @is_equivalence.unit_iso _ _ h :=\n  rfl\n#align as_equivalence_unit as_equivalence_unit\n\n",
 "as_equivalence_inverse":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n@[simp]\ntheorem as_equivalence_inverse (F : «expr ⥤ » C D) [is_equivalence F] : F.as_equivalence.inverse = inv F :=\n  rfl\n#align as_equivalence_inverse as_equivalence_inverse\n\n",
 "as_equivalence_functor":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n-- TODO as necessary, add the natural isomorphisms `(e^a).trans e^b ≅ e^(a+b)`.\n-- At this point, we haven't even defined the category of equivalences.\n@[simp]\ntheorem as_equivalence_functor (F : «expr ⥤ » C D) [is_equivalence F] : F.as_equivalence.functor = F :=\n  rfl\n#align as_equivalence_functor as_equivalence_functor\n\n",
 "as_equivalence_counit":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n@[simp]\ntheorem as_equivalence_counit {F : «expr ⥤ » C D} [is_equivalence F] :\n    F.as_equivalence.counit_iso = is_equivalence.counit_iso :=\n  rfl\n#align as_equivalence_counit as_equivalence_counit\n\n",
 "adjointify_η_ε":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n-- In this section we convert an arbitrary equivalence to a half-adjoint equivalence.\ntheorem adjointify_η_ε (X : C) :\n    «expr ≫ » (F.map ((adjointify_η η ε).hom.app X)) (ε.hom.app (F.obj X)) = («expr𝟙») (F.obj X) :=\n  by\n  dsimp [adjointify_η]; simp\n  have := ε.hom.naturality (F.map (η.inv.app X)); dsimp at this; rw [this]; clear this\n  rw [← assoc _ _ (F.map _)]\n  have := ε.hom.naturality (ε.inv.app <| F.obj X); dsimp at this; rw [this]; clear this\n  have := (ε.app <| F.obj X).hom_inv_id; dsimp at this; rw [this]; clear this\n  rw [id_comp]; have := (F.map_iso <| η.app X).hom_inv_id; dsimp at this; rw [this]\n#align adjointify_η_ε adjointify_η_ε\n\n"}