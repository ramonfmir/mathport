{"unit_inverse_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‹™ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰Œ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n/-- The other triangle equality. The proof follows the following proof in Globular:\n  http://globular.science/1905.001 -/\n@[simp]\ntheorem unit_inverse_comp (e : Â«expr â‰Œ Â» C D) (Y : D) :\n    Â«expr â‰« Â» (e.unit.app (e.inverse.obj Y)) (e.inverse.map (e.counit.app Y)) = (Â«exprğŸ™Â») (e.inverse.obj Y) :=\n  by\n  rw [â† id_comp (e.inverse.map _), â† map_id e.inverse, â† counit_inv_functor_comp, map_comp]\n  dsimp\n  rw [â† iso.hom_inv_id_assoc (e.unit_iso.app _) (e.inverse.map (e.functor.map _)), app_hom, app_inv]\n  slice_lhs 2 3 => erw [e.unit.naturality]\n  slice_lhs 1 2 => erw [e.unit.naturality]\n  slice_lhs 4 4 => rw [â† iso.hom_inv_id_assoc (e.inverse.map_iso (e.counit_iso.app _)) (e.unit_inv.app _)]\n  slice_lhs 3 4 =>\n    erw [â† map_comp e.inverse, e.counit.naturality]\n    erw [(e.counit_iso.app _).hom_inv_id, map_id]\n  erw [id_comp]\n  slice_lhs 2 3 => erw [â† map_comp e.inverse, e.counit_iso.inv.naturality, map_comp]\n  slice_lhs 3 4 => erw [e.unit_inv.naturality]\n  slice_lhs 4 5 => erw [â† map_comp (Â«expr â‹™ Â» e.functor e.inverse), (e.unit_iso.app _).hom_inv_id, map_id]\n  erw [id_comp]\n  slice_lhs 3 4 => erw [â† e.unit_inv.naturality]\n  slice_lhs 2 3 => erw [â† map_comp e.inverse, â† e.counit_iso.inv.naturality, (e.counit_iso.app _).hom_inv_id, map_id]\n  erw [id_comp, (e.unit_iso.app _).hom_inv_id]; rfl\n#align unit_inverse_comp unit_inverse_comp\n\n",
 "unit_inv_app_inverse":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰Œ Â» -/\ntheorem unit_inv_app_inverse (e : Â«expr â‰Œ Â» C D) (Y : D) :\n    e.unit_inv.app (e.inverse.obj Y) = e.inverse.map (e.counit.app Y) :=\n  by\n  symm\n  erw [â† iso.hom_comp_eq_id (e.unit_iso.app _), unit_inverse_comp]\n  rfl\n#align unit_inv_app_inverse unit_inv_app_inverse\n\n",
 "unit_app_inverse":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰Œ Â» -/\ntheorem unit_app_inverse (e : Â«expr â‰Œ Â» C D) (Y : D) :\n    e.unit.app (e.inverse.obj Y) = e.inverse.map (e.counit_inv.app Y) :=\n  by\n  erw [â† iso.comp_hom_eq_id (e.inverse.map_iso (e.counit_iso.app Y)), unit_inverse_comp]\n  rfl\n#align unit_app_inverse unit_app_inverse\n\n",
 "pow_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰Œ Â» -/\n#print pow_zero /-\n-- There's of course a monoid structure on `C â‰Œ C`,\n-- but let's not encourage using it.\n-- The power structure is nevertheless useful.\n@[simp]\ntheorem pow_zero (e : Â«expr â‰Œ Â» C C) : e ^ (0 : â„¤) = equivalence.refl :=\n  rfl\n#align pow_zero pow_zero\n-/\n\n",
 "pow_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰Œ Â» -/\n#print pow_one /-\n@[simp]\ntheorem pow_one (e : Â«expr â‰Œ Â» C C) : e ^ (1 : â„¤) = e :=\n  rfl\n#align pow_one pow_one\n-/\n\n",
 "pow_neg_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰Œ Â» -/\n@[simp]\ntheorem pow_neg_one (e : Â«expr â‰Œ Â» C C) : e ^ (-1 : â„¤) = e.symm :=\n  rfl\n#align pow_neg_one pow_neg_one\n\n",
 "of_iso_trans":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰… Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰… Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰ªâ‰« Â» -/\n/-- Compatibility of `of_iso` with the composition of isomorphisms of functors -/\ntheorem of_iso_trans {F G H : Â«expr â¥¤ Â» C D} (e : Â«expr â‰… Â» F G) (e' : Â«expr â‰… Â» G H) (hF : is_equivalence F) :\n    of_iso e' (of_iso e hF) = of_iso (Â«expr â‰ªâ‰« Â» e e') hF :=\n  by\n  dsimp [of_iso]\n  congr 1 <;> ext X <;> dsimp [nat_iso.hcomp]\n  Â· simp only [id_comp, assoc, functor.map_comp]\n  Â· simp only [Functor.map_id, comp_id, id_comp, assoc]\n#align of_iso_trans of_iso_trans\n\n",
 "of_iso_refl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/-- Compatibility of `of_iso` with identity isomorphisms of functors -/\ntheorem of_iso_refl (F : Â«expr â¥¤ Â» C D) (hF : is_equivalence F) : of_iso (Iso.refl F) hF = hF :=\n  by\n  rcases hF with âŸ¨Finv, Funit, Fcounit, FcompâŸ©\n  dsimp [of_iso]\n  congr 1 <;> ext X <;> dsimp [nat_iso.hcomp]\n  Â· simp only [comp_id, map_id]\n  Â· simp only [id_comp, map_id]\n#align of_iso_refl of_iso_refl\n\n",
 "inverse_map_inj_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰Œ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n@[simp]\ntheorem inverse_map_inj_iff (e : Â«expr â‰Œ Â» C D) {X Y : D} (f g : Â«expr âŸ¶ Â» X Y) :\n    e.inverse.map f = e.inverse.map g â†” f = g :=\n  functor_map_inj_iff e.symm f g\n#align inverse_map_inj_iff inverse_map_inj_iff\n\n",
 "inverse_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰Œ Â» -/\n@[simp]\ntheorem inverse_inv (E : Â«expr â‰Œ Â» C D) : E.inverse.inv = E.functor :=\n  rfl\n#align inverse_inv inverse_inv\n\n",
 "inverse_counit_inv_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰ªâ‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰Œ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n@[simp]\ntheorem inverse_counit_inv_comp (e : Â«expr â‰Œ Â» C D) (Y : D) :\n    Â«expr â‰« Â» (e.inverse.map (e.counit_inv.app Y)) (e.unit_inv.app (e.inverse.obj Y)) = (Â«exprğŸ™Â») (e.inverse.obj Y) :=\n  by\n  erw [iso.inv_eq_inv (Â«expr â‰ªâ‰« Â» (e.unit_iso.app (e.inverse.obj Y)) (e.inverse.map_iso (e.counit_iso.app Y)))\n      (iso.refl _)]\n  exact e.unit_inverse_comp Y\n#align inverse_counit_inv_comp inverse_counit_inv_comp\n\n",
 "inverse_as_equivalence":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰Œ Â» -/\n@[simp]\ntheorem inverse_as_equivalence (E : Â«expr â‰Œ Â» C D) : E.inverse.as_equivalence = E.symm :=\n  by\n  cases E\n  congr\n#align inverse_as_equivalence inverse_as_equivalence\n\n",
 "inv_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n#print inv_inv /-\n@[simp]\ntheorem inv_inv (F : Â«expr â¥¤ Â» C D) [is_equivalence F] : inv (inv F) = F :=\n  rfl\n#align inv_inv inv_inv\n-/\n\n",
 "inv_fun_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n@[simp]\ntheorem inv_fun_map (F : Â«expr â¥¤ Â» C D) [is_equivalence F] (X Y : C) (f : Â«expr âŸ¶ Â» X Y) :\n    F.inv.map (F.map f) = Â«expr â‰« Â» (F.as_equivalence.unit_inv.app X) (Â«expr â‰« Â» f (F.as_equivalence.unit.app Y)) :=\n  by\n  erw [nat_iso.naturality_1]\n  rfl\n#align inv_fun_map inv_fun_map\n\n",
 "inv_fun_id_assoc_inv_app":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰Œ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n@[simp]\ntheorem inv_fun_id_assoc_inv_app (e : Â«expr â‰Œ Â» C D) (F : Â«expr â¥¤ Â» D E) (X : D) :\n    (inv_fun_id_assoc e F).inv.app X = F.map (e.counit_inv.app X) :=\n  by\n  dsimp [inv_fun_id_assoc]\n  tidy\n#align inv_fun_id_assoc_inv_app inv_fun_id_assoc_inv_app\n\n",
 "inv_fun_id_assoc_hom_app":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰Œ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n@[simp]\ntheorem inv_fun_id_assoc_hom_app (e : Â«expr â‰Œ Â» C D) (F : Â«expr â¥¤ Â» D E) (X : D) :\n    (inv_fun_id_assoc e F).hom.app X = F.map (e.counit.app X) :=\n  by\n  dsimp [inv_fun_id_assoc]\n  tidy\n#align inv_fun_id_assoc_hom_app inv_fun_id_assoc_hom_app\n\n",
 "functor_unit_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰Œ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n@[simp]\ntheorem functor_unit_comp (e : Â«expr â‰Œ Â» C D) (X : C) :\n    Â«expr â‰« Â» (e.functor.map (e.unit.app X)) (e.counit.app (e.functor.obj X)) = (Â«exprğŸ™Â») (e.functor.obj X) :=\n  e.functor_unit_iso_comp X\n#align functor_unit_comp functor_unit_comp\n\n",
 "functor_map_inj_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰Œ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n-- see Note [lower instance priority]\n-- see Note [lower instance priority]\n@[simp]\ntheorem functor_map_inj_iff (e : Â«expr â‰Œ Â» C D) {X Y : C} (f g : Â«expr âŸ¶ Â» X Y) :\n    e.functor.map f = e.functor.map g â†” f = g :=\n  âŸ¨fun h => e.functor.map_injective h, fun h => h â–¸ rflâŸ©\n#align functor_map_inj_iff functor_map_inj_iff\n\n",
 "functor_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰Œ Â» -/\n@[simp]\ntheorem functor_inv (E : Â«expr â‰Œ Â» C D) : E.functor.inv = E.inverse :=\n  rfl\n#align functor_inv functor_inv\n\n",
 "functor_as_equivalence":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰Œ Â» -/\n@[simp]\ntheorem functor_as_equivalence (E : Â«expr â‰Œ Â» C D) : E.functor.as_equivalence = E :=\n  by\n  cases E\n  congr\n#align functor_as_equivalence functor_as_equivalence\n\n",
 "fun_inv_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n@[simp]\ntheorem fun_inv_map (F : Â«expr â¥¤ Â» C D) [is_equivalence F] (X Y : D) (f : Â«expr âŸ¶ Â» X Y) :\n    F.map (F.inv.map f) = Â«expr â‰« Â» (F.as_equivalence.counit.app X) (Â«expr â‰« Â» f (F.as_equivalence.counit_inv.app Y)) :=\n  by\n  erw [nat_iso.naturality_2]\n  rfl\n#align fun_inv_map fun_inv_map\n\n",
 "fun_inv_id_assoc_inv_app":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰Œ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n@[simp]\ntheorem fun_inv_id_assoc_inv_app (e : Â«expr â‰Œ Â» C D) (F : Â«expr â¥¤ Â» C E) (X : C) :\n    (fun_inv_id_assoc e F).inv.app X = F.map (e.unit.app X) :=\n  by\n  dsimp [fun_inv_id_assoc]\n  tidy\n#align fun_inv_id_assoc_inv_app fun_inv_id_assoc_inv_app\n\n",
 "fun_inv_id_assoc_hom_app":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰Œ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n-- We wouldn't have needed to give this proof if we'd used `equivalence.mk`,\n-- but we choose to avoid using that here, for the sake of good structure projection `simp`\n-- lemmas.\n@[simp]\ntheorem fun_inv_id_assoc_hom_app (e : Â«expr â‰Œ Â» C D) (F : Â«expr â¥¤ Â» C E) (X : C) :\n    (fun_inv_id_assoc e F).hom.app X = F.map (e.unit_inv.app X) :=\n  by\n  dsimp [fun_inv_id_assoc]\n  tidy\n#align fun_inv_id_assoc_hom_app fun_inv_id_assoc_hom_app\n\n",
 "ess_surj_of_equivalence":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/-- An equivalence is essentially surjective.\n\nSee <https://stacks.math.columbia.edu/tag/02C3>.\n-/\ntheorem ess_surj_of_equivalence (F : Â«expr â¥¤ Â» C D) [is_equivalence F] : EssSurj F :=\n  âŸ¨fun Y => âŸ¨F.inv.obj Y, âŸ¨F.as_equivalence.counit_iso.app YâŸ©âŸ©âŸ©\n#align ess_surj_of_equivalence ess_surj_of_equivalence\n\n",
 "equivalence_mk'_unit_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰Œ Â» -/\n@[simp]\ntheorem equivalence_mk'_unit_inv (functor inverse unit_iso counit_iso f) :\n    (âŸ¨functor, inverse, unit_iso, counit_iso, fâŸ© : Â«expr â‰Œ Â» C D).unit_inv = unit_iso.inv :=\n  rfl\n#align equivalence_mk'_unit_inv equivalence_mk'_unit_inv\n\n",
 "equivalence_mk'_unit":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰Œ Â» -/\n/-\nCopyright (c) 2017 Scott Morrison. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Tim Baumann, Stephen Morgan, Scott Morrison, Floris van Doorn\n-/\n-- declare the `v`'s first; see `category_theory.category` for an explanation\n/- While these abbreviations are convenient, they also cause some trouble,\npreventing structure projections from unfolding. -/\n@[simp]\ntheorem equivalence_mk'_unit (functor inverse unit_iso counit_iso f) :\n    (âŸ¨functor, inverse, unit_iso, counit_iso, fâŸ© : Â«expr â‰Œ Â» C D).unit = unit_iso.hom :=\n  rfl\n#align equivalence_mk'_unit equivalence_mk'_unit\n\n",
 "equivalence_mk'_counit_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰Œ Â» -/\n@[simp]\ntheorem equivalence_mk'_counit_inv (functor inverse unit_iso counit_iso f) :\n    (âŸ¨functor, inverse, unit_iso, counit_iso, fâŸ© : Â«expr â‰Œ Â» C D).counit_inv = counit_iso.inv :=\n  rfl\n#align equivalence_mk'_counit_inv equivalence_mk'_counit_inv\n\n",
 "equivalence_mk'_counit":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰Œ Â» -/\n@[simp]\ntheorem equivalence_mk'_counit (functor inverse unit_iso counit_iso f) :\n    (âŸ¨functor, inverse, unit_iso, counit_iso, fâŸ© : Â«expr â‰Œ Â» C D).counit = counit_iso.hom :=\n  rfl\n#align equivalence_mk'_counit equivalence_mk'_counit\n\n",
 "counit_inv_functor_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰ªâ‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰Œ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n@[simp]\ntheorem counit_inv_functor_comp (e : Â«expr â‰Œ Â» C D) (X : C) :\n    Â«expr â‰« Â» (e.counit_inv.app (e.functor.obj X)) (e.functor.map (e.unit_inv.app X)) = (Â«exprğŸ™Â») (e.functor.obj X) :=\n  by\n  erw [iso.inv_eq_inv (Â«expr â‰ªâ‰« Â» (e.functor.map_iso (e.unit_iso.app X)) (e.counit_iso.app (e.functor.obj X)))\n      (iso.refl _)]\n  exact e.functor_unit_comp X\n#align counit_inv_functor_comp counit_inv_functor_comp\n\n",
 "counit_inv_app_functor":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰Œ Â» -/\ntheorem counit_inv_app_functor (e : Â«expr â‰Œ Â» C D) (X : C) :\n    e.counit_inv.app (e.functor.obj X) = e.functor.map (e.unit.app X) :=\n  by\n  symm\n  erw [â† iso.comp_hom_eq_id (e.counit_iso.app _), functor_unit_comp]\n  rfl\n#align counit_inv_app_functor counit_inv_app_functor\n\n",
 "counit_app_functor":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰Œ Â» -/\ntheorem counit_app_functor (e : Â«expr â‰Œ Â» C D) (X : C) :\n    e.counit.app (e.functor.obj X) = e.functor.map (e.unit_inv.app X) :=\n  by\n  erw [â† iso.hom_comp_eq_id (e.functor.map_iso (e.unit_iso.app X)), functor_unit_comp]\n  rfl\n#align counit_app_functor counit_app_functor\n\n",
 "cancel_unit_right_assoc'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n@[simp]\ntheorem cancel_unit_right_assoc' {W X X' Y Y' Z : C} (f : Â«expr âŸ¶ Â» W X) (g : Â«expr âŸ¶ Â» X Y) (h : Â«expr âŸ¶ Â» Y Z)\n    (f' : Â«expr âŸ¶ Â» W X') (g' : Â«expr âŸ¶ Â» X' Y') (h' : Â«expr âŸ¶ Â» Y' Z) :\n    Â«expr â‰« Â» f (Â«expr â‰« Â» g (Â«expr â‰« Â» h (e.unit.app Z))) = Â«expr â‰« Â» f' (Â«expr â‰« Â» g' (Â«expr â‰« Â» h' (e.unit.app Z))) â†”\n      Â«expr â‰« Â» f (Â«expr â‰« Â» g h) = Â«expr â‰« Â» f' (Â«expr â‰« Â» g' h') :=\n  by simp only [â† category.assoc, cancel_mono]\n#align cancel_unit_right_assoc' cancel_unit_right_assoc'\n\n",
 "cancel_unit_right_assoc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n@[simp]\ntheorem cancel_unit_right_assoc {W X X' Y : C} (f : Â«expr âŸ¶ Â» W X) (g : Â«expr âŸ¶ Â» X Y) (f' : Â«expr âŸ¶ Â» W X')\n    (g' : Â«expr âŸ¶ Â» X' Y) :\n    Â«expr â‰« Â» f (Â«expr â‰« Â» g (e.unit.app Y)) = Â«expr â‰« Â» f' (Â«expr â‰« Â» g' (e.unit.app Y)) â†”\n      Â«expr â‰« Â» f g = Â«expr â‰« Â» f' g' :=\n  by simp only [â† category.assoc, cancel_mono]\n#align cancel_unit_right_assoc cancel_unit_right_assoc\n\n",
 "cancel_unit_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- We need special forms of `cancel_nat_iso_hom_right(_assoc)` and\n`cancel_nat_iso_inv_right(_assoc)` for units and counits, because neither `simp` or `rw` will apply\nthose lemmas in this setting without providing `e.unit_iso` (or similar) as an explicit argument.\nWe also provide the lemmas for length four compositions, since they're occasionally useful.\n(e.g. in proving that equivalences take monos to monos) -/\n@[simp]\ntheorem cancel_unit_right {X Y : C} (f f' : Â«expr âŸ¶ Â» X Y) :\n    Â«expr â‰« Â» f (e.unit.app Y) = Â«expr â‰« Â» f' (e.unit.app Y) â†” f = f' := by simp only [cancel_mono]\n#align cancel_unit_right cancel_unit_right\n\n",
 "cancel_unit_inv_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n@[simp]\ntheorem cancel_unit_inv_right {X Y : C} (f f' : Â«expr âŸ¶ Â» X (e.inverse.obj (e.functor.obj Y))) :\n    Â«expr â‰« Â» f (e.unit_inv.app Y) = Â«expr â‰« Â» f' (e.unit_inv.app Y) â†” f = f' := by simp only [cancel_mono]\n#align cancel_unit_inv_right cancel_unit_inv_right\n\n",
 "cancel_counit_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n@[simp]\ntheorem cancel_counit_right {X Y : D} (f f' : Â«expr âŸ¶ Â» X (e.functor.obj (e.inverse.obj Y))) :\n    Â«expr â‰« Â» f (e.counit.app Y) = Â«expr â‰« Â» f' (e.counit.app Y) â†” f = f' := by simp only [cancel_mono]\n#align cancel_counit_right cancel_counit_right\n\n",
 "cancel_counit_inv_right_assoc'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n@[simp]\ntheorem cancel_counit_inv_right_assoc' {W X X' Y Y' Z : D} (f : Â«expr âŸ¶ Â» W X) (g : Â«expr âŸ¶ Â» X Y) (h : Â«expr âŸ¶ Â» Y Z)\n    (f' : Â«expr âŸ¶ Â» W X') (g' : Â«expr âŸ¶ Â» X' Y') (h' : Â«expr âŸ¶ Â» Y' Z) :\n    Â«expr â‰« Â» f (Â«expr â‰« Â» g (Â«expr â‰« Â» h (e.counit_inv.app Z))) =\n        Â«expr â‰« Â» f' (Â«expr â‰« Â» g' (Â«expr â‰« Â» h' (e.counit_inv.app Z))) â†”\n      Â«expr â‰« Â» f (Â«expr â‰« Â» g h) = Â«expr â‰« Â» f' (Â«expr â‰« Â» g' h') :=\n  by simp only [â† category.assoc, cancel_mono]\n#align cancel_counit_inv_right_assoc' cancel_counit_inv_right_assoc'\n\n",
 "cancel_counit_inv_right_assoc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n@[simp]\ntheorem cancel_counit_inv_right_assoc {W X X' Y : D} (f : Â«expr âŸ¶ Â» W X) (g : Â«expr âŸ¶ Â» X Y) (f' : Â«expr âŸ¶ Â» W X')\n    (g' : Â«expr âŸ¶ Â» X' Y) :\n    Â«expr â‰« Â» f (Â«expr â‰« Â» g (e.counit_inv.app Y)) = Â«expr â‰« Â» f' (Â«expr â‰« Â» g' (e.counit_inv.app Y)) â†”\n      Â«expr â‰« Â» f g = Â«expr â‰« Â» f' g' :=\n  by simp only [â† category.assoc, cancel_mono]\n#align cancel_counit_inv_right_assoc cancel_counit_inv_right_assoc\n\n",
 "cancel_counit_inv_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n@[simp]\ntheorem cancel_counit_inv_right {X Y : D} (f f' : Â«expr âŸ¶ Â» X Y) :\n    Â«expr â‰« Â» f (e.counit_inv.app Y) = Â«expr â‰« Â» f' (e.counit_inv.app Y) â†” f = f' := by simp only [cancel_mono]\n#align cancel_counit_inv_right cancel_counit_inv_right\n\n",
 "as_equivalence_unit":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n@[simp]\ntheorem as_equivalence_unit {F : Â«expr â¥¤ Â» C D} [h : is_equivalence F] :\n    F.as_equivalence.unit_iso = @is_equivalence.unit_iso _ _ h :=\n  rfl\n#align as_equivalence_unit as_equivalence_unit\n\n",
 "as_equivalence_inverse":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n@[simp]\ntheorem as_equivalence_inverse (F : Â«expr â¥¤ Â» C D) [is_equivalence F] : F.as_equivalence.inverse = inv F :=\n  rfl\n#align as_equivalence_inverse as_equivalence_inverse\n\n",
 "as_equivalence_functor":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n-- TODO as necessary, add the natural isomorphisms `(e^a).trans e^b â‰… e^(a+b)`.\n-- At this point, we haven't even defined the category of equivalences.\n@[simp]\ntheorem as_equivalence_functor (F : Â«expr â¥¤ Â» C D) [is_equivalence F] : F.as_equivalence.functor = F :=\n  rfl\n#align as_equivalence_functor as_equivalence_functor\n\n",
 "as_equivalence_counit":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n@[simp]\ntheorem as_equivalence_counit {F : Â«expr â¥¤ Â» C D} [is_equivalence F] :\n    F.as_equivalence.counit_iso = is_equivalence.counit_iso :=\n  rfl\n#align as_equivalence_counit as_equivalence_counit\n\n",
 "adjointify_Î·_Îµ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n-- In this section we convert an arbitrary equivalence to a half-adjoint equivalence.\ntheorem adjointify_Î·_Îµ (X : C) :\n    Â«expr â‰« Â» (F.map ((adjointify_Î· Î· Îµ).hom.app X)) (Îµ.hom.app (F.obj X)) = (Â«exprğŸ™Â») (F.obj X) :=\n  by\n  dsimp [adjointify_Î·]; simp\n  have := Îµ.hom.naturality (F.map (Î·.inv.app X)); dsimp at this; rw [this]; clear this\n  rw [â† assoc _ _ (F.map _)]\n  have := Îµ.hom.naturality (Îµ.inv.app <| F.obj X); dsimp at this; rw [this]; clear this\n  have := (Îµ.app <| F.obj X).hom_inv_id; dsimp at this; rw [this]; clear this\n  rw [id_comp]; have := (F.map_iso <| Î·.app X).hom_inv_id; dsimp at this; rw [this]\n#align adjointify_Î·_Îµ adjointify_Î·_Îµ\n\n"}