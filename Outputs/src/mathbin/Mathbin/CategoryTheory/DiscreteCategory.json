{"nat_iso_app":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≅ » -/\n@[simp]\ntheorem nat_iso_app {I : Type u₁} {F G : «expr ⥤ » (Discrete I) C} (f : ∀ i : Discrete I, «expr ≅ » (F.obj i) (G.obj i))\n    (i : Discrete I) : (Discrete.natIso f).app i = f i := by tidy\n#align nat_iso_app nat_iso_app\n\n",
 "mk_as":
 "/-\nCopyright (c) 2017 Scott Morrison. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Stephen Morgan, Scott Morrison, Floris van Doorn\n-/\n-- morphism levels before object levels. See note [category_theory universes].\n-- This is intentionally a structure rather than a type synonym\n-- to enforce using `discrete_equiv` (or `discrete.mk` and `discrete.as`) to move between\n-- `discrete α` and `α`. Otherwise there is too much API leakage.\n@[simp]\ntheorem discrete.mk_as {α : Type u₁} (X : Discrete α) : discrete.mk X.as = X :=\n  by\n  ext\n  rfl\n#align discrete.mk_as discrete.mk_as\n\n",
 "id_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n@[simp]\ntheorem id_def (X : Discrete α) : ULift.up (PLift.up (Eq.refl X.as)) = («expr𝟙») X :=\n  rfl\n#align id_def id_def\n\n",
 "functor_obj":
 "@[simp]\ntheorem functor_obj {I : Type u₁} (F : I → C) (i : I) : (Discrete.functor F).obj (discrete.mk i) = F i :=\n  rfl\n#align functor_obj functor_obj\n\n",
 "functor_map_id":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n@[simp]\ntheorem functor_map_id (F : «expr ⥤ » (Discrete J) C) {j : Discrete J} (f : «expr ⟶ » j j) :\n    F.map f = («expr𝟙») (F.obj j) :=\n  by\n  have h : f = («expr𝟙») j := by\n    cases f\n    cases f\n    ext\n  rw [h]\n  simp\n#align functor_map_id functor_map_id\n\n",
 "functor_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\ntheorem functor_map {I : Type u₁} (F : I → C) {i : Discrete I} (f : «expr ⟶ » i i) :\n    (Discrete.functor F).map f = («expr𝟙») (F i.as) := by tidy\n#align functor_map functor_map\n\n",
 "eq_of_hom":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/-- Extract the equation from a morphism in a discrete category. -/\ntheorem eq_of_hom {X Y : Discrete α} (i : «expr ⟶ » X Y) : X.as = Y.as :=\n  i.down.down\n#align eq_of_hom eq_of_hom\n\n"}