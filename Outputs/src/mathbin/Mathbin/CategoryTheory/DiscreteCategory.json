{"nat_iso_app":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰… Â» -/\n@[simp]\ntheorem nat_iso_app {I : Type uâ‚} {F G : Â«expr â¥¤ Â» (Discrete I) C} (f : âˆ€ i : Discrete I, Â«expr â‰… Â» (F.obj i) (G.obj i))\n    (i : Discrete I) : (Discrete.natIso f).app i = f i := by tidy\n#align nat_iso_app nat_iso_app\n\n",
 "mk_as":
 "/-\nCopyright (c) 2017 Scott Morrison. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Stephen Morgan, Scott Morrison, Floris van Doorn\n-/\n-- morphism levels before object levels. See note [category_theory universes].\n-- This is intentionally a structure rather than a type synonym\n-- to enforce using `discrete_equiv` (or `discrete.mk` and `discrete.as`) to move between\n-- `discrete Î±` and `Î±`. Otherwise there is too much API leakage.\n@[simp]\ntheorem discrete.mk_as {Î± : Type uâ‚} (X : Discrete Î±) : discrete.mk X.as = X :=\n  by\n  ext\n  rfl\n#align discrete.mk_as discrete.mk_as\n\n",
 "id_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n@[simp]\ntheorem id_def (X : Discrete Î±) : ULift.up (PLift.up (Eq.refl X.as)) = (Â«exprğŸ™Â») X :=\n  rfl\n#align id_def id_def\n\n",
 "functor_obj":
 "@[simp]\ntheorem functor_obj {I : Type uâ‚} (F : I â†’ C) (i : I) : (Discrete.functor F).obj (discrete.mk i) = F i :=\n  rfl\n#align functor_obj functor_obj\n\n",
 "functor_map_id":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n@[simp]\ntheorem functor_map_id (F : Â«expr â¥¤ Â» (Discrete J) C) {j : Discrete J} (f : Â«expr âŸ¶ Â» j j) :\n    F.map f = (Â«exprğŸ™Â») (F.obj j) :=\n  by\n  have h : f = (Â«exprğŸ™Â») j := by\n    cases f\n    cases f\n    ext\n  rw [h]\n  simp\n#align functor_map_id functor_map_id\n\n",
 "functor_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\ntheorem functor_map {I : Type uâ‚} (F : I â†’ C) {i : Discrete I} (f : Â«expr âŸ¶ Â» i i) :\n    (Discrete.functor F).map f = (Â«exprğŸ™Â») (F i.as) := by tidy\n#align functor_map functor_map\n\n",
 "eq_of_hom":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/-- Extract the equation from a morphism in a discrete category. -/\ntheorem eq_of_hom {X Y : Discrete Î±} (i : Â«expr âŸ¶ Â» X Y) : X.as = Y.as :=\n  i.down.down\n#align eq_of_hom eq_of_hom\n\n"}