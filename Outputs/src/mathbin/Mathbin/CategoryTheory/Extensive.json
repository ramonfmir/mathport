{"whisker_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\ntheorem nat_trans.equifibered.whisker_right {F G : Â«expr â¥¤ Â» J C} {Î± : Â«expr âŸ¶ Â» F G} (hÎ± : Î±.equifibered)\n    (H : Â«expr â¥¤ Â» C D) [preserves_limits_of_shape walking_cospan H] : (whiskerRight Î± H).equifibered := fun i j f =>\n  (hÎ± f).map H\n#align nat_trans.equifibered.whisker_right nat_trans.equifibered.whisker_right\n\n",
 "van_kampen":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\ntheorem finitary_extensive.van_kampen [finitary_extensive C] {F : Â«expr â¥¤ Â» (discrete walking_pair) C} (c : cocone F)\n    (hc : is_colimit c) : is_van_kampen_colimit c :=\n  by\n  let X := F.obj âŸ¨walking_pair.leftâŸ©\n  let Y := F.obj âŸ¨walking_pair.rightâŸ©\n  have : F = pair X Y := by\n    apply functor.hext\n    Â· rintro âŸ¨âŸ¨âŸ©âŸ© <;> rfl\n    Â· rintro âŸ¨âŸ¨âŸ©âŸ© âŸ¨jâŸ© âŸ¨âŸ¨rfl : _ = jâŸ©âŸ© <;> simpa\n  clear_value X Y\n  subst this\n  exact finitary_extensive.van_kampen' c hc\n#align finitary_extensive.van_kampen finitary_extensive.van_kampen\n\n",
 "of_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\ntheorem is_van_kampen_colimit.of_map {D : Type _} [Category D] (G : Â«expr â¥¤ Â» C D) {F : Â«expr â¥¤ Â» J C} {c : cocone F}\n    [preserves_limits_of_shape walking_cospan G] [reflects_limits_of_shape walking_cospan G]\n    [preserves_colimits_of_shape J G] [reflects_colimits_of_shape J G] (H : is_van_kampen_colimit (G.map_cocone c)) :\n    is_van_kampen_colimit c := by\n  intro F' c' Î± f h hÎ±\n  refine'\n    (iff.trans _\n          (H (G.map_cocone c') (whisker_right Î± G) (G.map f)\n            (by\n              ext j\n              simpa using G.congr_map (nat_trans.congr_app h j))\n            (hÎ±.whisker_right G))).trans\n      (forall_congr' fun j => _)\n  Â· exact âŸ¨fun h => âŸ¨is_colimit_of_preserves G h.someâŸ©, fun h => âŸ¨is_colimit_of_reflects G h.someâŸ©âŸ©\n  Â· exact is_pullback.map_iff G (nat_trans.congr_app h.symm j)\n#align is_van_kampen_colimit.of_map is_van_kampen_colimit.of_map\n\n",
 "of_iso":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰… Â» -/\ntheorem is_van_kampen_colimit.of_iso {F : Â«expr â¥¤ Â» J C} {c c' : cocone F} (H : is_van_kampen_colimit c)\n    (e : Â«expr â‰… Â» c c') : is_van_kampen_colimit c' :=\n  by\n  intro F' c'' Î± f h hÎ±\n  have : Â«expr â‰« Â» c'.Î¹ ((Functor.Const J).map e.inv.hom) = c.Î¹ :=\n    by\n    ext j\n    exact e.inv.2 j\n  rw [H c'' Î± (Â«expr â‰« Â» f e.inv.1) (by rw [functor.map_comp, â† reassoc_of h, this]) hÎ±]\n  apply forall_congr'\n  intro j\n  conv_lhs => rw [â† category.comp_id (Î±.app j)]\n  haveI : is_iso e.inv.hom := functor.map_is_iso (cocones.forget _) e.inv\n  exact (is_pullback.of_vert_is_iso âŸ¨by simpâŸ©).paste_vert_iff (nat_trans.congr_app h j).symm\n#align is_van_kampen_colimit.of_iso is_van_kampen_colimit.of_iso\n\n",
 "mono_inr_of_is_van_kampen":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\ntheorem binary_cofan.mono_inr_of_is_van_kampen [has_initial C] {X Y : C} {c : binary_cofan X Y}\n    (h : is_van_kampen_colimit c) : Mono c.inr :=\n  by\n  refine' pullback_cone.mono_of_is_limit_mk_id_id _ (is_pullback.is_limit _)\n  refine'\n    (h (binary_cofan.mk (initial.to Y) ((Â«exprğŸ™Â») Y)) (map_pair (initial.to X) ((Â«exprğŸ™Â») Y)) c.inr _\n          (map_pair_equifibered _)).mp\n      âŸ¨_âŸ© âŸ¨walking_pair.rightâŸ©\n  Â· ext âŸ¨âŸ¨âŸ©âŸ© <;> dsimp <;> simp\n  Â·\n    exact\n      ((binary_cofan.is_colimit_iff_is_iso_inr initial_is_initial _).mpr\n          (by\n            dsimp\n            infer_instance)).some\n#align binary_cofan.mono_inr_of_is_van_kampen binary_cofan.mono_inr_of_is_van_kampen\n\n",
 "mono_inr_of_is_colimit":
 "theorem finitary_extensive.mono_inr_of_is_colimit [finitary_extensive C] {c : binary_cofan X Y} (hc : is_colimit c) :\n    Mono c.inr :=\n  binary_cofan.mono_inr_of_is_van_kampen (finitary_extensive.van_kampen c hc)\n#align finitary_extensive.mono_inr_of_is_colimit finitary_extensive.mono_inr_of_is_colimit\n\n",
 "mono_inl_of_is_colimit":
 "theorem finitary_extensive.mono_inl_of_is_colimit [finitary_extensive C] {c : binary_cofan X Y} (hc : is_colimit c) :\n    Mono c.inl :=\n  finitary_extensive.mono_inr_of_is_colimit (binary_cofan.is_colimit_flip hc)\n#align finitary_extensive.mono_inl_of_is_colimit finitary_extensive.mono_inl_of_is_colimit\n\n",
 "map_pair_equifibered":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem map_pair_equifibered {F F' : Â«expr â¥¤ Â» (discrete walking_pair) C} (Î± : Â«expr âŸ¶ Â» F F') : Î±.equifibered :=\n  by\n  rintro âŸ¨âŸ¨âŸ©âŸ© âŸ¨jâŸ© âŸ¨âŸ¨rfl : _ = jâŸ©âŸ©\n  all_goals\n    dsimp; simp only [discrete.functor_map_id]\n    exact is_pullback.of_horiz_is_iso âŸ¨by simp only [category.comp_id, category.id_comp]âŸ©\n#align map_pair_equifibered map_pair_equifibered\n\n",
 "is_van_kampen_mk":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰… Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰… Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem binary_cofan.is_van_kampen_mk {X Y : C} (c : binary_cofan X Y) (cofans : âˆ€ X Y : C, binary_cofan X Y)\n    (colimits : âˆ€ X Y, is_colimit (cofans X Y))\n    (cones : âˆ€ {X Y Z : C} (f : Â«expr âŸ¶ Â» X Z) (g : Â«expr âŸ¶ Â» Y Z), pullback_cone f g)\n    (limits : âˆ€ {X Y Z : C} (f : Â«expr âŸ¶ Â» X Z) (g : Â«expr âŸ¶ Â» Y Z), is_limit (cones f g))\n    (hâ‚ :\n      âˆ€ {X' Y' : C} (Î±X : Â«expr âŸ¶ Â» X' X) (Î±Y : Â«expr âŸ¶ Â» Y' Y) (f : Â«expr âŸ¶ Â» (cofans X' Y').X c.X)\n        (hÎ±X : Â«expr â‰« Â» Î±X c.inl = Â«expr â‰« Â» (cofans X' Y').inl f)\n        (hÎ±Y : Â«expr â‰« Â» Î±Y c.inr = Â«expr â‰« Â» (cofans X' Y').inr f),\n        is_pullback (cofans X' Y').inl Î±X f c.inl âˆ§ is_pullback (cofans X' Y').inr Î±Y f c.inr)\n    (hâ‚‚ : âˆ€ {Z : C} (f : Â«expr âŸ¶ Â» Z c.X), is_colimit (binary_cofan.mk (cones f c.inl).fst (cones f c.inr).fst)) :\n    is_van_kampen_colimit c := by\n  rw [binary_cofan.is_van_kampen_iff]\n  introv hX hY\n  constructor\n  Â· rintro âŸ¨hâŸ©\n    let e := h.cocone_point_unique_up_to_iso (colimits _ _)\n    obtain âŸ¨hl, hrâŸ© := hâ‚ Î±X Î±Y (Â«expr â‰« Â» e.inv f) (by simp [hX]) (by simp [hY])\n    constructor\n    Â· rw [â† category.id_comp Î±X, â† iso.hom_inv_id_assoc e f]\n      have : Â«expr â‰« Â» c'.inl e.hom = Â«expr â‰« Â» ((Â«exprğŸ™Â») X') (cofans X' Y').inl :=\n        by\n        dsimp\n        simp\n      haveI : is_iso ((Â«exprğŸ™Â») X') := infer_instance\n      exact (is_pullback.of_vert_is_iso âŸ¨thisâŸ©).paste_vert hl\n    Â· rw [â† category.id_comp Î±Y, â† iso.hom_inv_id_assoc e f]\n      have : Â«expr â‰« Â» c'.inr e.hom = Â«expr â‰« Â» ((Â«exprğŸ™Â») Y') (cofans X' Y').inr :=\n        by\n        dsimp\n        simp\n      haveI : is_iso ((Â«exprğŸ™Â») Y') := infer_instance\n      exact (is_pullback.of_vert_is_iso âŸ¨thisâŸ©).paste_vert hr\n  Â· rintro âŸ¨Hâ‚, Hâ‚‚âŸ©\n    refine' âŸ¨is_colimit.of_iso_colimit _ <| (iso_binary_cofan_mk _).symmâŸ©\n    let eâ‚ : Â«expr â‰… Â» X' _ := Hâ‚.is_limit.cone_point_unique_up_to_iso (limits _ _)\n    let eâ‚‚ : Â«expr â‰… Â» Y' _ := Hâ‚‚.is_limit.cone_point_unique_up_to_iso (limits _ _)\n    have heâ‚ : c'.inl = Â«expr â‰« Â» eâ‚.hom (cones f c.inl).fst := by simp\n    have heâ‚‚ : c'.inr = Â«expr â‰« Â» eâ‚‚.hom (cones f c.inr).fst := by simp\n    rw [heâ‚, heâ‚‚]\n    apply binary_cofan.is_colimit_comp_right_iso (binary_cofan.mk _ _)\n    apply binary_cofan.is_colimit_comp_left_iso (binary_cofan.mk _ _)\n    exact hâ‚‚ f\n#align binary_cofan.is_van_kampen_mk binary_cofan.is_van_kampen_mk\n\n",
 "is_van_kampen_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\ntheorem binary_cofan.is_van_kampen_iff (c : binary_cofan X Y) :\n    is_van_kampen_colimit c â†”\n      âˆ€ {X' Y' : C} (c' : binary_cofan X' Y') (Î±X : Â«expr âŸ¶ Â» X' X) (Î±Y : Â«expr âŸ¶ Â» Y' Y) (f : Â«expr âŸ¶ Â» c'.X c.X)\n        (hÎ±X : Â«expr â‰« Â» Î±X c.inl = Â«expr â‰« Â» c'.inl f) (hÎ±Y : Â«expr â‰« Â» Î±Y c.inr = Â«expr â‰« Â» c'.inr f),\n        nonempty (is_colimit c') â†” is_pullback c'.inl Î±X f c.inl âˆ§ is_pullback c'.inr Î±Y f c.inr :=\n  by\n  constructor\n  Â· introv H hÎ±X hÎ±Y\n    rw [H c' (map_pair Î±X Î±Y) f (by ext âŸ¨âŸ¨âŸ©âŸ© <;> dsimp <;> assumption) (map_pair_equifibered _)]\n    constructor\n    Â· intro H\n      exact âŸ¨H _, H _âŸ©\n    Â· rintro H âŸ¨âŸ¨âŸ©âŸ©\n      exacts[H.1, H.2]\n  Â· introv H F' hÎ± h\n    let X' := F'.obj âŸ¨walking_pair.leftâŸ©\n    let Y' := F'.obj âŸ¨walking_pair.rightâŸ©\n    have : F' = pair X' Y' := by\n      apply functor.hext\n      Â· rintro âŸ¨âŸ¨âŸ©âŸ© <;> rfl\n      Â· rintro âŸ¨âŸ¨âŸ©âŸ© âŸ¨jâŸ© âŸ¨âŸ¨rfl : _ = jâŸ©âŸ© <;> simpa\n    clear_value X' Y'\n    subst this\n    change binary_cofan X' Y' at c'\n    rw [H c' _ _ _ (nat_trans.congr_app hÎ± âŸ¨walking_pair.leftâŸ©) (nat_trans.congr_app hÎ± âŸ¨walking_pair.rightâŸ©)]\n    constructor\n    Â· rintro H âŸ¨âŸ¨âŸ©âŸ©\n      exacts[H.1, H.2]\n    Â· intro H\n      exact âŸ¨H _, H _âŸ©\n#align binary_cofan.is_van_kampen_iff binary_cofan.is_van_kampen_iff\n\n",
 "is_van_kampen_colimit_of_evaluation":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\ntheorem is_van_kampen_colimit_of_evaluation [has_pullbacks D] [has_colimits_of_shape J D]\n    (F : Â«expr â¥¤ Â» J (Â«expr â¥¤ Â» C D)) (c : cocone F)\n    (hc : âˆ€ x : C, is_van_kampen_colimit (((evaluation C D).obj x).map_cocone c)) : is_van_kampen_colimit c :=\n  by\n  intro F' c' Î± f e hÎ±\n  have := fun x =>\n    hc x (((evaluation C D).obj x).map_cocone c') (whisker_right Î± _) (((evaluation C D).obj x).map f)\n      (by\n        ext y\n        dsimp\n        exact nat_trans.congr_app (nat_trans.congr_app e y) x)\n      (hÎ±.whisker_right _)\n  constructor\n  Â· rintro âŸ¨hc'âŸ© j\n    refine' âŸ¨âŸ¨(nat_trans.congr_app e j).symmâŸ©, âŸ¨evaluation_jointly_reflects_limits _ _âŸ©âŸ©\n    refine' fun x => (is_limit_map_cone_pullback_cone_equiv _ _).symm _\n    exact ((this x).mp âŸ¨preserves_colimit.preserves hc'âŸ© _).is_limit\n  Â·\n    exact fun H =>\n      âŸ¨evaluation_jointly_reflects_colimits _ fun x => ((this x).mpr fun j => (H j).map ((evaluation C D).obj x)).someâŸ©\n#align is_van_kampen_colimit_of_evaluation is_van_kampen_colimit_of_evaluation\n\n",
 "is_van_kampen_colimit":
 "theorem is_initial.is_van_kampen_colimit [has_strict_initial_objects C] {X : C} (h : is_initial X) :\n    is_van_kampen_colimit (as_empty_cocone X) := by\n  intro F' c' Î± f hf hÎ±\n  have : F' = functor.empty C := by apply functor.hext <;> rintro âŸ¨âŸ¨âŸ©âŸ©\n  subst this\n  haveI := h.is_iso_to f\n  refine' âŸ¨by rintro _ âŸ¨âŸ¨âŸ©âŸ©, fun _ => âŸ¨is_colimit.of_iso_colimit h (cocones.ext (as_iso f).symm <| by rintro âŸ¨âŸ¨âŸ©âŸ©)âŸ©âŸ©\n#align is_initial.is_van_kampen_colimit is_initial.is_van_kampen_colimit\n\n",
 "is_universal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\ntheorem is_van_kampen_colimit.is_universal {F : Â«expr â¥¤ Â» J C} {c : cocone F} (H : is_van_kampen_colimit c) :\n    is_universal_colimit c := fun _ c' Î± f h hÎ± => (H c' Î± f h hÎ±).mpr\n#align is_van_kampen_colimit.is_universal is_van_kampen_colimit.is_universal\n\n",
 "is_pullback_initial_to_of_is_van_kampen":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\ntheorem binary_cofan.is_pullback_initial_to_of_is_van_kampen [has_initial C] {c : binary_cofan X Y}\n    (h : is_van_kampen_colimit c) : is_pullback (initial.to _) (initial.to _) c.inl c.inr :=\n  by\n  refine'\n    ((h (binary_cofan.mk (initial.to Y) ((Â«exprğŸ™Â») Y)) (map_pair (initial.to X) ((Â«exprğŸ™Â») Y)) c.inr _\n            (map_pair_equifibered _)).mp\n        âŸ¨_âŸ© âŸ¨walking_pair.leftâŸ©).flip\n  Â· ext âŸ¨âŸ¨âŸ©âŸ© <;> dsimp <;> simp\n  Â·\n    exact\n      ((binary_cofan.is_colimit_iff_is_iso_inr initial_is_initial _).mpr\n          (by\n            dsimp\n            infer_instance)).some\n#align binary_cofan.is_pullback_initial_to_of_is_van_kampen binary_cofan.is_pullback_initial_to_of_is_van_kampen\n\n",
 "is_pullback_initial_to_binary_cofan":
 "theorem finitary_extensive.is_pullback_initial_to_binary_cofan [finitary_extensive C] {c : binary_cofan X Y}\n    (hc : is_colimit c) : is_pullback (initial.to _) (initial.to _) c.inl c.inr :=\n  binary_cofan.is_pullback_initial_to_of_is_van_kampen (finitary_extensive.van_kampen c hc)\n#align finitary_extensive.is_pullback_initial_to_binary_cofan finitary_extensive.is_pullback_initial_to_binary_cofan\n\n",
 "has_strict_initial_of_is_universal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¥_ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¥_ Â» -/\ntheorem has_strict_initial_of_is_universal [has_initial C]\n    (H : is_universal_colimit (binary_cofan.mk ((Â«exprğŸ™Â») (Â«exprâŠ¥_ Â» C)) ((Â«exprğŸ™Â») (Â«exprâŠ¥_ Â» C)))) :\n    has_strict_initial_objects C :=\n  has_strict_initial_objects_of_initial_is_strict\n    (by\n      intro A f\n      suffices is_colimit (binary_cofan.mk ((Â«exprğŸ™Â») A) ((Â«exprğŸ™Â») A))\n        by\n        obtain âŸ¨l, hâ‚, hâ‚‚âŸ© := limits.binary_cofan.is_colimit.desc' this (Â«expr â‰« Â» f (initial.to A)) ((Â«exprğŸ™Â») A)\n        rcases(category.id_comp _).symm.trans hâ‚‚ with rfl\n        exact âŸ¨âŸ¨_, ((category.id_comp _).symm.trans hâ‚).symm, initial_is_initial.hom_ext _ _âŸ©âŸ©\n      refine'\n        (H (binary_cofan.mk ((Â«exprğŸ™Â») _) ((Â«exprğŸ™Â») _)) (map_pair f f) f (by ext âŸ¨âŸ¨âŸ©âŸ© <;> dsimp <;> simp)\n            (map_pair_equifibered _) _).some\n      rintro âŸ¨âŸ¨âŸ©âŸ© <;> dsimp <;>\n        exact is_pullback.of_horiz_is_iso âŸ¨(category.id_comp _).trans (category.comp_id _).symmâŸ©)\n#align has_strict_initial_of_is_universal has_strict_initial_of_is_universal\n\n",
 "finitary_extensive_of_preserves_and_reflects_isomorphism":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\ntheorem finitary_extensive_of_preserves_and_reflects_isomorphism (F : Â«expr â¥¤ Â» C D) [finitary_extensive D]\n    [has_finite_coproducts C] [has_pullbacks C] [preserves_limits_of_shape walking_cospan F]\n    [preserves_colimits_of_shape (discrete walking_pair) F] [reflects_isomorphisms F] : finitary_extensive C :=\n  by\n  haveI : reflects_limits_of_shape walking_cospan F := reflects_limits_of_shape_of_reflects_isomorphisms\n  haveI : reflects_colimits_of_shape (discrete walking_pair) F := reflects_colimits_of_shape_of_reflects_isomorphisms\n  exact finitary_extensive_of_preserves_and_reflects F\n#align finitary_extensive_of_preserves_and_reflects_isomorphism finitary_extensive_of_preserves_and_reflects_isomorphism\n\n",
 "finitary_extensive_of_preserves_and_reflects":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\ntheorem finitary_extensive_of_preserves_and_reflects (F : Â«expr â¥¤ Â» C D) [finitary_extensive D]\n    [has_finite_coproducts C] [preserves_limits_of_shape walking_cospan F] [reflects_limits_of_shape walking_cospan F]\n    [preserves_colimits_of_shape (discrete walking_pair) F] [reflects_colimits_of_shape (discrete walking_pair) F] :\n    finitary_extensive C :=\n  âŸ¨fun X Y c hc => (finitary_extensive.van_kampen _ (is_colimit_of_preserves F hc)).of_map FâŸ©\n#align finitary_extensive_of_preserves_and_reflects finitary_extensive_of_preserves_and_reflects\n\n",
 "finitary_extensive_iff_of_is_terminal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\ntheorem finitary_extensive_iff_of_is_terminal (C : Type u) [Category.{v} C] [has_finite_coproducts C] (T : C)\n    (HT : is_terminal T) (câ‚€ : binary_cofan T T) (hcâ‚€ : is_colimit câ‚€) :\n    finitary_extensive C â†” is_van_kampen_colimit câ‚€ :=\n  by\n  refine' âŸ¨fun H => H.2 câ‚€ hcâ‚€, fun H => _âŸ©\n  constructor\n  simp_rw [binary_cofan.is_van_kampen_iff] at HâŠ¢\n  intro X Y c hc X' Y' c' Î±X Î±Y f hX hY\n  obtain âŸ¨d, hd, hd'âŸ© :=\n    limits.binary_cofan.is_colimit.desc' hc (Â«expr â‰« Â» (HT.from _) câ‚€.inl) (Â«expr â‰« Â» (HT.from _) câ‚€.inr)\n  rw [H c' (Â«expr â‰« Â» Î±X (HT.from _)) (Â«expr â‰« Â» Î±Y (HT.from _)) (Â«expr â‰« Â» f d)\n      (by rw [â† reassoc_of hX, hd, category.assoc]) (by rw [â† reassoc_of hY, hd', category.assoc])]\n  obtain âŸ¨hl, hrâŸ© := (H c (HT.from _) (HT.from _) d hd.symm hd'.symm).mp âŸ¨hcâŸ©\n  rw [hl.paste_vert_iff hX.symm, hr.paste_vert_iff hY.symm]\n#align finitary_extensive_iff_of_is_terminal finitary_extensive_iff_of_is_terminal\n\n",
 "equifibered_of_is_iso":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/-\nCopyright (c) 2022 Andrew Yang. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Andrew Yang\n-/\ntheorem nat_trans.equifibered_of_is_iso {F G : Â«expr â¥¤ Â» J C} (Î± : Â«expr âŸ¶ Â» F G) [IsIso Î±] : Î±.equifibered :=\n  fun _ _ f => is_pullback.of_vert_is_iso âŸ¨nat_trans.naturality _ fâŸ©\n#align nat_trans.equifibered_of_is_iso nat_trans.equifibered_of_is_iso\n\n",
 "comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\ntheorem nat_trans.equifibered.comp {F G H : Â«expr â¥¤ Â» J C} {Î± : Â«expr âŸ¶ Â» F G} {Î² : Â«expr âŸ¶ Â» G H} (hÎ± : Î±.equifibered)\n    (hÎ² : Î².equifibered) : (Â«expr â‰« Â» Î± Î²).equifibered := fun i j f => (hÎ± f).paste_vert (hÎ² f)\n#align nat_trans.equifibered.comp nat_trans.equifibered.comp\n\n"}