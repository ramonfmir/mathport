{"whisker_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\ntheorem nat_trans.equifibered.whisker_right {F G : «expr ⥤ » J C} {α : «expr ⟶ » F G} (hα : α.equifibered)\n    (H : «expr ⥤ » C D) [preserves_limits_of_shape walking_cospan H] : (whiskerRight α H).equifibered := fun i j f =>\n  (hα f).map H\n#align nat_trans.equifibered.whisker_right nat_trans.equifibered.whisker_right\n\n",
 "van_kampen":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\ntheorem finitary_extensive.van_kampen [finitary_extensive C] {F : «expr ⥤ » (discrete walking_pair) C} (c : cocone F)\n    (hc : is_colimit c) : is_van_kampen_colimit c :=\n  by\n  let X := F.obj ⟨walking_pair.left⟩\n  let Y := F.obj ⟨walking_pair.right⟩\n  have : F = pair X Y := by\n    apply functor.hext\n    · rintro ⟨⟨⟩⟩ <;> rfl\n    · rintro ⟨⟨⟩⟩ ⟨j⟩ ⟨⟨rfl : _ = j⟩⟩ <;> simpa\n  clear_value X Y\n  subst this\n  exact finitary_extensive.van_kampen' c hc\n#align finitary_extensive.van_kampen finitary_extensive.van_kampen\n\n",
 "of_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\ntheorem is_van_kampen_colimit.of_map {D : Type _} [Category D] (G : «expr ⥤ » C D) {F : «expr ⥤ » J C} {c : cocone F}\n    [preserves_limits_of_shape walking_cospan G] [reflects_limits_of_shape walking_cospan G]\n    [preserves_colimits_of_shape J G] [reflects_colimits_of_shape J G] (H : is_van_kampen_colimit (G.map_cocone c)) :\n    is_van_kampen_colimit c := by\n  intro F' c' α f h hα\n  refine'\n    (iff.trans _\n          (H (G.map_cocone c') (whisker_right α G) (G.map f)\n            (by\n              ext j\n              simpa using G.congr_map (nat_trans.congr_app h j))\n            (hα.whisker_right G))).trans\n      (forall_congr' fun j => _)\n  · exact ⟨fun h => ⟨is_colimit_of_preserves G h.some⟩, fun h => ⟨is_colimit_of_reflects G h.some⟩⟩\n  · exact is_pullback.map_iff G (nat_trans.congr_app h.symm j)\n#align is_van_kampen_colimit.of_map is_van_kampen_colimit.of_map\n\n",
 "of_iso":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≅ » -/\ntheorem is_van_kampen_colimit.of_iso {F : «expr ⥤ » J C} {c c' : cocone F} (H : is_van_kampen_colimit c)\n    (e : «expr ≅ » c c') : is_van_kampen_colimit c' :=\n  by\n  intro F' c'' α f h hα\n  have : «expr ≫ » c'.ι ((Functor.Const J).map e.inv.hom) = c.ι :=\n    by\n    ext j\n    exact e.inv.2 j\n  rw [H c'' α («expr ≫ » f e.inv.1) (by rw [functor.map_comp, ← reassoc_of h, this]) hα]\n  apply forall_congr'\n  intro j\n  conv_lhs => rw [← category.comp_id (α.app j)]\n  haveI : is_iso e.inv.hom := functor.map_is_iso (cocones.forget _) e.inv\n  exact (is_pullback.of_vert_is_iso ⟨by simp⟩).paste_vert_iff (nat_trans.congr_app h j).symm\n#align is_van_kampen_colimit.of_iso is_van_kampen_colimit.of_iso\n\n",
 "mono_inr_of_is_van_kampen":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\ntheorem binary_cofan.mono_inr_of_is_van_kampen [has_initial C] {X Y : C} {c : binary_cofan X Y}\n    (h : is_van_kampen_colimit c) : Mono c.inr :=\n  by\n  refine' pullback_cone.mono_of_is_limit_mk_id_id _ (is_pullback.is_limit _)\n  refine'\n    (h (binary_cofan.mk (initial.to Y) ((«expr𝟙») Y)) (map_pair (initial.to X) ((«expr𝟙») Y)) c.inr _\n          (map_pair_equifibered _)).mp\n      ⟨_⟩ ⟨walking_pair.right⟩\n  · ext ⟨⟨⟩⟩ <;> dsimp <;> simp\n  ·\n    exact\n      ((binary_cofan.is_colimit_iff_is_iso_inr initial_is_initial _).mpr\n          (by\n            dsimp\n            infer_instance)).some\n#align binary_cofan.mono_inr_of_is_van_kampen binary_cofan.mono_inr_of_is_van_kampen\n\n",
 "mono_inr_of_is_colimit":
 "theorem finitary_extensive.mono_inr_of_is_colimit [finitary_extensive C] {c : binary_cofan X Y} (hc : is_colimit c) :\n    Mono c.inr :=\n  binary_cofan.mono_inr_of_is_van_kampen (finitary_extensive.van_kampen c hc)\n#align finitary_extensive.mono_inr_of_is_colimit finitary_extensive.mono_inr_of_is_colimit\n\n",
 "mono_inl_of_is_colimit":
 "theorem finitary_extensive.mono_inl_of_is_colimit [finitary_extensive C] {c : binary_cofan X Y} (hc : is_colimit c) :\n    Mono c.inl :=\n  finitary_extensive.mono_inr_of_is_colimit (binary_cofan.is_colimit_flip hc)\n#align finitary_extensive.mono_inl_of_is_colimit finitary_extensive.mono_inl_of_is_colimit\n\n",
 "map_pair_equifibered":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem map_pair_equifibered {F F' : «expr ⥤ » (discrete walking_pair) C} (α : «expr ⟶ » F F') : α.equifibered :=\n  by\n  rintro ⟨⟨⟩⟩ ⟨j⟩ ⟨⟨rfl : _ = j⟩⟩\n  all_goals\n    dsimp; simp only [discrete.functor_map_id]\n    exact is_pullback.of_horiz_is_iso ⟨by simp only [category.comp_id, category.id_comp]⟩\n#align map_pair_equifibered map_pair_equifibered\n\n",
 "is_van_kampen_mk":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≅ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≅ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem binary_cofan.is_van_kampen_mk {X Y : C} (c : binary_cofan X Y) (cofans : ∀ X Y : C, binary_cofan X Y)\n    (colimits : ∀ X Y, is_colimit (cofans X Y))\n    (cones : ∀ {X Y Z : C} (f : «expr ⟶ » X Z) (g : «expr ⟶ » Y Z), pullback_cone f g)\n    (limits : ∀ {X Y Z : C} (f : «expr ⟶ » X Z) (g : «expr ⟶ » Y Z), is_limit (cones f g))\n    (h₁ :\n      ∀ {X' Y' : C} (αX : «expr ⟶ » X' X) (αY : «expr ⟶ » Y' Y) (f : «expr ⟶ » (cofans X' Y').X c.X)\n        (hαX : «expr ≫ » αX c.inl = «expr ≫ » (cofans X' Y').inl f)\n        (hαY : «expr ≫ » αY c.inr = «expr ≫ » (cofans X' Y').inr f),\n        is_pullback (cofans X' Y').inl αX f c.inl ∧ is_pullback (cofans X' Y').inr αY f c.inr)\n    (h₂ : ∀ {Z : C} (f : «expr ⟶ » Z c.X), is_colimit (binary_cofan.mk (cones f c.inl).fst (cones f c.inr).fst)) :\n    is_van_kampen_colimit c := by\n  rw [binary_cofan.is_van_kampen_iff]\n  introv hX hY\n  constructor\n  · rintro ⟨h⟩\n    let e := h.cocone_point_unique_up_to_iso (colimits _ _)\n    obtain ⟨hl, hr⟩ := h₁ αX αY («expr ≫ » e.inv f) (by simp [hX]) (by simp [hY])\n    constructor\n    · rw [← category.id_comp αX, ← iso.hom_inv_id_assoc e f]\n      have : «expr ≫ » c'.inl e.hom = «expr ≫ » ((«expr𝟙») X') (cofans X' Y').inl :=\n        by\n        dsimp\n        simp\n      haveI : is_iso ((«expr𝟙») X') := infer_instance\n      exact (is_pullback.of_vert_is_iso ⟨this⟩).paste_vert hl\n    · rw [← category.id_comp αY, ← iso.hom_inv_id_assoc e f]\n      have : «expr ≫ » c'.inr e.hom = «expr ≫ » ((«expr𝟙») Y') (cofans X' Y').inr :=\n        by\n        dsimp\n        simp\n      haveI : is_iso ((«expr𝟙») Y') := infer_instance\n      exact (is_pullback.of_vert_is_iso ⟨this⟩).paste_vert hr\n  · rintro ⟨H₁, H₂⟩\n    refine' ⟨is_colimit.of_iso_colimit _ <| (iso_binary_cofan_mk _).symm⟩\n    let e₁ : «expr ≅ » X' _ := H₁.is_limit.cone_point_unique_up_to_iso (limits _ _)\n    let e₂ : «expr ≅ » Y' _ := H₂.is_limit.cone_point_unique_up_to_iso (limits _ _)\n    have he₁ : c'.inl = «expr ≫ » e₁.hom (cones f c.inl).fst := by simp\n    have he₂ : c'.inr = «expr ≫ » e₂.hom (cones f c.inr).fst := by simp\n    rw [he₁, he₂]\n    apply binary_cofan.is_colimit_comp_right_iso (binary_cofan.mk _ _)\n    apply binary_cofan.is_colimit_comp_left_iso (binary_cofan.mk _ _)\n    exact h₂ f\n#align binary_cofan.is_van_kampen_mk binary_cofan.is_van_kampen_mk\n\n",
 "is_van_kampen_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem binary_cofan.is_van_kampen_iff (c : binary_cofan X Y) :\n    is_van_kampen_colimit c ↔\n      ∀ {X' Y' : C} (c' : binary_cofan X' Y') (αX : «expr ⟶ » X' X) (αY : «expr ⟶ » Y' Y) (f : «expr ⟶ » c'.X c.X)\n        (hαX : «expr ≫ » αX c.inl = «expr ≫ » c'.inl f) (hαY : «expr ≫ » αY c.inr = «expr ≫ » c'.inr f),\n        nonempty (is_colimit c') ↔ is_pullback c'.inl αX f c.inl ∧ is_pullback c'.inr αY f c.inr :=\n  by\n  constructor\n  · introv H hαX hαY\n    rw [H c' (map_pair αX αY) f (by ext ⟨⟨⟩⟩ <;> dsimp <;> assumption) (map_pair_equifibered _)]\n    constructor\n    · intro H\n      exact ⟨H _, H _⟩\n    · rintro H ⟨⟨⟩⟩\n      exacts[H.1, H.2]\n  · introv H F' hα h\n    let X' := F'.obj ⟨walking_pair.left⟩\n    let Y' := F'.obj ⟨walking_pair.right⟩\n    have : F' = pair X' Y' := by\n      apply functor.hext\n      · rintro ⟨⟨⟩⟩ <;> rfl\n      · rintro ⟨⟨⟩⟩ ⟨j⟩ ⟨⟨rfl : _ = j⟩⟩ <;> simpa\n    clear_value X' Y'\n    subst this\n    change binary_cofan X' Y' at c'\n    rw [H c' _ _ _ (nat_trans.congr_app hα ⟨walking_pair.left⟩) (nat_trans.congr_app hα ⟨walking_pair.right⟩)]\n    constructor\n    · rintro H ⟨⟨⟩⟩\n      exacts[H.1, H.2]\n    · intro H\n      exact ⟨H _, H _⟩\n#align binary_cofan.is_van_kampen_iff binary_cofan.is_van_kampen_iff\n\n",
 "is_van_kampen_colimit_of_evaluation":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\ntheorem is_van_kampen_colimit_of_evaluation [has_pullbacks D] [has_colimits_of_shape J D]\n    (F : «expr ⥤ » J («expr ⥤ » C D)) (c : cocone F)\n    (hc : ∀ x : C, is_van_kampen_colimit (((evaluation C D).obj x).map_cocone c)) : is_van_kampen_colimit c :=\n  by\n  intro F' c' α f e hα\n  have := fun x =>\n    hc x (((evaluation C D).obj x).map_cocone c') (whisker_right α _) (((evaluation C D).obj x).map f)\n      (by\n        ext y\n        dsimp\n        exact nat_trans.congr_app (nat_trans.congr_app e y) x)\n      (hα.whisker_right _)\n  constructor\n  · rintro ⟨hc'⟩ j\n    refine' ⟨⟨(nat_trans.congr_app e j).symm⟩, ⟨evaluation_jointly_reflects_limits _ _⟩⟩\n    refine' fun x => (is_limit_map_cone_pullback_cone_equiv _ _).symm _\n    exact ((this x).mp ⟨preserves_colimit.preserves hc'⟩ _).is_limit\n  ·\n    exact fun H =>\n      ⟨evaluation_jointly_reflects_colimits _ fun x => ((this x).mpr fun j => (H j).map ((evaluation C D).obj x)).some⟩\n#align is_van_kampen_colimit_of_evaluation is_van_kampen_colimit_of_evaluation\n\n",
 "is_van_kampen_colimit":
 "theorem is_initial.is_van_kampen_colimit [has_strict_initial_objects C] {X : C} (h : is_initial X) :\n    is_van_kampen_colimit (as_empty_cocone X) := by\n  intro F' c' α f hf hα\n  have : F' = functor.empty C := by apply functor.hext <;> rintro ⟨⟨⟩⟩\n  subst this\n  haveI := h.is_iso_to f\n  refine' ⟨by rintro _ ⟨⟨⟩⟩, fun _ => ⟨is_colimit.of_iso_colimit h (cocones.ext (as_iso f).symm <| by rintro ⟨⟨⟩⟩)⟩⟩\n#align is_initial.is_van_kampen_colimit is_initial.is_van_kampen_colimit\n\n",
 "is_universal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\ntheorem is_van_kampen_colimit.is_universal {F : «expr ⥤ » J C} {c : cocone F} (H : is_van_kampen_colimit c) :\n    is_universal_colimit c := fun _ c' α f h hα => (H c' α f h hα).mpr\n#align is_van_kampen_colimit.is_universal is_van_kampen_colimit.is_universal\n\n",
 "is_pullback_initial_to_of_is_van_kampen":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\ntheorem binary_cofan.is_pullback_initial_to_of_is_van_kampen [has_initial C] {c : binary_cofan X Y}\n    (h : is_van_kampen_colimit c) : is_pullback (initial.to _) (initial.to _) c.inl c.inr :=\n  by\n  refine'\n    ((h (binary_cofan.mk (initial.to Y) ((«expr𝟙») Y)) (map_pair (initial.to X) ((«expr𝟙») Y)) c.inr _\n            (map_pair_equifibered _)).mp\n        ⟨_⟩ ⟨walking_pair.left⟩).flip\n  · ext ⟨⟨⟩⟩ <;> dsimp <;> simp\n  ·\n    exact\n      ((binary_cofan.is_colimit_iff_is_iso_inr initial_is_initial _).mpr\n          (by\n            dsimp\n            infer_instance)).some\n#align binary_cofan.is_pullback_initial_to_of_is_van_kampen binary_cofan.is_pullback_initial_to_of_is_van_kampen\n\n",
 "is_pullback_initial_to_binary_cofan":
 "theorem finitary_extensive.is_pullback_initial_to_binary_cofan [finitary_extensive C] {c : binary_cofan X Y}\n    (hc : is_colimit c) : is_pullback (initial.to _) (initial.to _) c.inl c.inr :=\n  binary_cofan.is_pullback_initial_to_of_is_van_kampen (finitary_extensive.van_kampen c hc)\n#align finitary_extensive.is_pullback_initial_to_binary_cofan finitary_extensive.is_pullback_initial_to_binary_cofan\n\n",
 "has_strict_initial_of_is_universal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥_ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥_ » -/\ntheorem has_strict_initial_of_is_universal [has_initial C]\n    (H : is_universal_colimit (binary_cofan.mk ((«expr𝟙») («expr⊥_ » C)) ((«expr𝟙») («expr⊥_ » C)))) :\n    has_strict_initial_objects C :=\n  has_strict_initial_objects_of_initial_is_strict\n    (by\n      intro A f\n      suffices is_colimit (binary_cofan.mk ((«expr𝟙») A) ((«expr𝟙») A))\n        by\n        obtain ⟨l, h₁, h₂⟩ := limits.binary_cofan.is_colimit.desc' this («expr ≫ » f (initial.to A)) ((«expr𝟙») A)\n        rcases(category.id_comp _).symm.trans h₂ with rfl\n        exact ⟨⟨_, ((category.id_comp _).symm.trans h₁).symm, initial_is_initial.hom_ext _ _⟩⟩\n      refine'\n        (H (binary_cofan.mk ((«expr𝟙») _) ((«expr𝟙») _)) (map_pair f f) f (by ext ⟨⟨⟩⟩ <;> dsimp <;> simp)\n            (map_pair_equifibered _) _).some\n      rintro ⟨⟨⟩⟩ <;> dsimp <;>\n        exact is_pullback.of_horiz_is_iso ⟨(category.id_comp _).trans (category.comp_id _).symm⟩)\n#align has_strict_initial_of_is_universal has_strict_initial_of_is_universal\n\n",
 "finitary_extensive_of_preserves_and_reflects_isomorphism":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\ntheorem finitary_extensive_of_preserves_and_reflects_isomorphism (F : «expr ⥤ » C D) [finitary_extensive D]\n    [has_finite_coproducts C] [has_pullbacks C] [preserves_limits_of_shape walking_cospan F]\n    [preserves_colimits_of_shape (discrete walking_pair) F] [reflects_isomorphisms F] : finitary_extensive C :=\n  by\n  haveI : reflects_limits_of_shape walking_cospan F := reflects_limits_of_shape_of_reflects_isomorphisms\n  haveI : reflects_colimits_of_shape (discrete walking_pair) F := reflects_colimits_of_shape_of_reflects_isomorphisms\n  exact finitary_extensive_of_preserves_and_reflects F\n#align finitary_extensive_of_preserves_and_reflects_isomorphism finitary_extensive_of_preserves_and_reflects_isomorphism\n\n",
 "finitary_extensive_of_preserves_and_reflects":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\ntheorem finitary_extensive_of_preserves_and_reflects (F : «expr ⥤ » C D) [finitary_extensive D]\n    [has_finite_coproducts C] [preserves_limits_of_shape walking_cospan F] [reflects_limits_of_shape walking_cospan F]\n    [preserves_colimits_of_shape (discrete walking_pair) F] [reflects_colimits_of_shape (discrete walking_pair) F] :\n    finitary_extensive C :=\n  ⟨fun X Y c hc => (finitary_extensive.van_kampen _ (is_colimit_of_preserves F hc)).of_map F⟩\n#align finitary_extensive_of_preserves_and_reflects finitary_extensive_of_preserves_and_reflects\n\n",
 "finitary_extensive_iff_of_is_terminal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem finitary_extensive_iff_of_is_terminal (C : Type u) [Category.{v} C] [has_finite_coproducts C] (T : C)\n    (HT : is_terminal T) (c₀ : binary_cofan T T) (hc₀ : is_colimit c₀) :\n    finitary_extensive C ↔ is_van_kampen_colimit c₀ :=\n  by\n  refine' ⟨fun H => H.2 c₀ hc₀, fun H => _⟩\n  constructor\n  simp_rw [binary_cofan.is_van_kampen_iff] at H⊢\n  intro X Y c hc X' Y' c' αX αY f hX hY\n  obtain ⟨d, hd, hd'⟩ :=\n    limits.binary_cofan.is_colimit.desc' hc («expr ≫ » (HT.from _) c₀.inl) («expr ≫ » (HT.from _) c₀.inr)\n  rw [H c' («expr ≫ » αX (HT.from _)) («expr ≫ » αY (HT.from _)) («expr ≫ » f d)\n      (by rw [← reassoc_of hX, hd, category.assoc]) (by rw [← reassoc_of hY, hd', category.assoc])]\n  obtain ⟨hl, hr⟩ := (H c (HT.from _) (HT.from _) d hd.symm hd'.symm).mp ⟨hc⟩\n  rw [hl.paste_vert_iff hX.symm, hr.paste_vert_iff hY.symm]\n#align finitary_extensive_iff_of_is_terminal finitary_extensive_iff_of_is_terminal\n\n",
 "equifibered_of_is_iso":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/-\nCopyright (c) 2022 Andrew Yang. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Andrew Yang\n-/\ntheorem nat_trans.equifibered_of_is_iso {F G : «expr ⥤ » J C} (α : «expr ⟶ » F G) [IsIso α] : α.equifibered :=\n  fun _ _ f => is_pullback.of_vert_is_iso ⟨nat_trans.naturality _ f⟩\n#align nat_trans.equifibered_of_is_iso nat_trans.equifibered_of_is_iso\n\n",
 "comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem nat_trans.equifibered.comp {F G H : «expr ⥤ » J C} {α : «expr ⟶ » F G} {β : «expr ⟶ » G H} (hα : α.equifibered)\n    (hβ : β.equifibered) : («expr ≫ » α β).equifibered := fun i j f => (hα f).paste_vert (hβ f)\n#align nat_trans.equifibered.comp nat_trans.equifibered.comp\n\n"}