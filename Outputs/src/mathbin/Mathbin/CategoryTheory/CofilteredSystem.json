{"to_preimages_nonempty_of_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem to_preimages_nonempty_of_surjective [hFn : âˆ€ j : J, Nonempty (F.obj j)]\n    (Fsur : âˆ€ â¦ƒi j : Jâ¦„ (f : Â«expr âŸ¶ Â» i j), (F.map f).surjective) (hs : s.nonempty) (j) :\n    Nonempty ((F.to_preimages s).obj j) :=\n  by\n  simp only [to_preimages_obj, nonempty_coe_sort, nonempty_Inter, mem_preimage]\n  obtain h | âŸ¨âŸ¨jiâŸ©âŸ© := isEmpty_or_nonempty (Â«expr âŸ¶ Â» j i)\n  Â· exact âŸ¨(hFn j).some, fun ji => h.elim jiâŸ©\n  Â· obtain âŸ¨y, ysâŸ© := hs\n    obtain âŸ¨x, rflâŸ© := Fsur ji y\n    exact âŸ¨x, fun ji' => (F.thin_diagram_of_surjective Fsur ji' ji).symm â–¸ ysâŸ©\n#align to_preimages_nonempty_of_surjective to_preimages_nonempty_of_surjective\n\n",
 "to_preimages":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\ntheorem is_mittag_leffler.to_preimages (h : F.is_mittag_leffler) : (F.to_preimages s).is_mittag_leffler :=\n  (is_mittag_leffler_iff_subset_range_comp _).2 fun j =>\n    by\n    obtain âŸ¨jâ‚, gâ‚, fâ‚, -âŸ© := cone_objs i j\n    obtain âŸ¨jâ‚‚, fâ‚‚, hâ‚‚âŸ© := F.is_mittag_leffler_iff_eventual_range.1 h jâ‚\n    refine' âŸ¨jâ‚‚, Â«expr â‰« Â» fâ‚‚ fâ‚, fun jâ‚ƒ fâ‚ƒ => _âŸ©\n    rintro _ âŸ¨âŸ¨x, hxâŸ©, rflâŸ©\n    have : F.map fâ‚‚ x âˆˆ F.eventual_range jâ‚ := by\n      rw [hâ‚‚]\n      exact âŸ¨_, rflâŸ©\n    obtain âŸ¨y, hy, hâ‚ƒâŸ© := h.subset_image_eventual_range F (Â«expr â‰« Â» fâ‚ƒ fâ‚‚) this\n    refine' âŸ¨âŸ¨y, mem_Inter.2 fun gâ‚‚ => _âŸ©, Subtype.ext _âŸ©\n    Â· obtain âŸ¨jâ‚„, fâ‚„, hâ‚„âŸ© := cone_maps gâ‚‚ (Â«expr â‰« Â» (Â«expr â‰« Â» fâ‚ƒ fâ‚‚) gâ‚)\n      obtain âŸ¨y, rflâŸ© := F.mem_eventual_range_iff.1 hy fâ‚„\n      rw [â† map_comp_apply] at hâ‚ƒ\n      rw [mem_preimage, â† map_comp_apply, hâ‚„, â† category.assoc, map_comp_apply, hâ‚ƒ, â† map_comp_apply]\n      apply mem_Inter.1 hx\n    Â· simp_rw [to_preimages_map, maps_to.coe_restrict_apply, Subtype.coe_mk]\n      rw [â† category.assoc, map_comp_apply, hâ‚ƒ, map_comp_apply]\n#align is_mittag_leffler.to_preimages is_mittag_leffler.to_preimages\n\n",
 "to_eventual_ranges_nonempty":
 "/-- If `F` is nonempty at each index and Mittag-Leffler, then so is `F.to_eventual_ranges`. -/\ntheorem to_eventual_ranges_nonempty (h : F.is_mittag_leffler) [âˆ€ j : J, Nonempty (F.obj j)] (j : J) :\n    Nonempty (F.to_eventual_ranges.obj j) :=\n  by\n  let âŸ¨i, f, hâŸ© := F.is_mittag_leffler_iff_eventual_range.1 h j\n  rw [to_eventual_ranges_obj, h]\n  infer_instance\n#align to_eventual_ranges_nonempty to_eventual_ranges_nonempty\n\n",
 "thin_diagram_of_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/-- If `F` has all arrows surjective, then it \"factors through a poset\". -/\ntheorem thin_diagram_of_surjective (Fsur : âˆ€ â¦ƒi j : Jâ¦„ (f : Â«expr âŸ¶ Â» i j), (F.map f).surjective) {i j}\n    (f g : Â«expr âŸ¶ Â» i j) : F.map f = F.map g :=\n  let âŸ¨k, Ï†, hÏ†âŸ© := cone_maps f g\n  (Fsur Ï†).injective_comp_right <| by simp_rw [â† types_comp, â† F.map_comp, hÏ†]\n#align thin_diagram_of_surjective thin_diagram_of_surjective\n\n",
 "surjective_to_eventual_ranges":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/-- If `F` satisfies the Mittag-Leffler condition, its restriction to eventual ranges is a surjective\nfunctor.\n-/\ntheorem surjective_to_eventual_ranges (h : F.is_mittag_leffler) â¦ƒi jâ¦„ (f : Â«expr âŸ¶ Â» i j) :\n    (F.to_eventual_ranges.map f).surjective := fun âŸ¨x, hxâŸ© =>\n  by\n  obtain âŸ¨y, hy, rflâŸ© := h.subset_image_eventual_range F f hx\n  exact âŸ¨âŸ¨y, hyâŸ©, rflâŸ©\n#align surjective_to_eventual_ranges surjective_to_eventual_ranges\n\n",
 "subset_image_eventual_range":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\ntheorem is_mittag_leffler.subset_image_eventual_range (h : F.is_mittag_leffler) (f : Â«expr âŸ¶ Â» j i) :\n    F.eventual_range i âŠ† Â«expr '' Â» (F.map f) (F.eventual_range j) :=\n  by\n  obtain âŸ¨k, g, hgâŸ© := F.is_mittag_leffler_iff_eventual_range.1 h j\n  rw [hg]; intro x hx\n  obtain âŸ¨x, rflâŸ© := F.mem_eventual_range_iff.1 hx (Â«expr â‰« Â» g f)\n  refine' âŸ¨_, âŸ¨x, rflâŸ©, by simpa only [F.map_comp] âŸ©\n#align is_mittag_leffler.subset_image_eventual_range is_mittag_leffler.subset_image_eventual_range\n\n",
 "nonempty_sections_of_finite_inverse_system":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr áµ’áµ–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr áµ’áµ–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr áµ’áµ–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr áµ’áµ–Â» -/\n/-- The inverse limit of nonempty finite types is nonempty.\n\nSee `nonempty_sections_of_finite_cofiltered_system` for a generalization to cofiltered limits.\nThat version applies in almost all cases, and the only difference is that this version\nallows `J` to be empty.\n\nThis may be regarded as a generalization of KÅ‘nig's lemma.\nTo specialize: given a locally finite connected graph, take `Jáµ’áµ–` to be `â„•` and\n`F j` to be length-`j` paths that start from an arbitrary fixed vertex.\nElements of `F.sections` can be read off as infinite rays in the graph. -/\ntheorem nonempty_sections_of_finite_inverse_system {J : Type u} [preorder J] [IsDirected J (Â· â‰¤ Â·)]\n    (F : Â«expr â¥¤ Â» (Â«expr áµ’áµ–Â» J) (Type v)) [âˆ€ j : Â«expr áµ’áµ–Â» J, Finite (F.obj j)]\n    [âˆ€ j : Â«expr áµ’áµ–Â» J, Nonempty (F.obj j)] : F.sections.nonempty :=\n  by\n  cases isEmpty_or_nonempty J\n  Â· haveI : IsEmpty (Â«expr áµ’áµ–Â» J) := âŸ¨fun j => isEmptyElim j.unopâŸ©\n    -- TODO: this should be a global instance\n    exact âŸ¨isEmptyElim, isEmptyElimâŸ©\n  Â· exact nonempty_sections_of_finite_cofiltered_system _\n#align nonempty_sections_of_finite_inverse_system nonempty_sections_of_finite_inverse_system\n\n",
 "nonempty_sections_of_finite_cofiltered_system":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‹™ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‹™ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/-- The cofiltered limit of nonempty finite types is nonempty.\n\nSee `nonempty_sections_of_finite_inverse_system` for a specialization to inverse limits. -/\ntheorem nonempty_sections_of_finite_cofiltered_system {J : Type u} [Category.{w} J] [IsCofilteredOrEmpty J]\n    (F : Â«expr â¥¤ Â» J (Type v)) [âˆ€ j : J, Finite (F.obj j)] [âˆ€ j : J, Nonempty (F.obj j)] : F.sections.nonempty :=\n  by\n  -- Step 1: lift everything to the `max u v w` universe.\n  let J' : Type max w v u := AsSmall.{max w v} J\n  let down : Â«expr â¥¤ Â» J' J := as_small.down\n  let F' : Â«expr â¥¤ Â» J' (Type max u v w) := Â«expr â‹™ Â» down (Â«expr â‹™ Â» F uliftFunctor.{max u w, v})\n  haveI : âˆ€ i, Nonempty (F'.obj i) := fun i => âŸ¨âŸ¨Classical.arbitrary (F.obj (down.obj i))âŸ©âŸ©\n  haveI : âˆ€ i, Finite (F'.obj i) := fun i => Finite.of_equiv (F.obj (down.obj i)) equiv.ulift.symm\n  -- Step 2: apply the bootstrap theorem\n  cases isEmpty_or_nonempty J\n  Â· fconstructor <;> exact isEmptyElim\n  haveI : is_cofiltered J := âŸ¨âŸ©\n  obtain âŸ¨u, huâŸ© := nonempty_sections_of_finite_cofiltered_system.init F'\n  -- Step 3: interpret the results\n  use fun j => (u âŸ¨jâŸ©).down\n  intro j j' f\n  have h := @hu (âŸ¨jâŸ© : J') (âŸ¨j'âŸ© : J') (ULift.up f)\n  simp only [as_small.down, functor.comp_map, ulift_functor_map, functor.op_map] at h\n  simp_rw [â† h]\n  rfl\n#align nonempty_sections_of_finite_cofiltered_system nonempty_sections_of_finite_cofiltered_system\n\n",
 "mem_eventual_range_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem mem_eventual_range_iff {x : F.obj j} :\n    x âˆˆ F.eventual_range j â†” âˆ€ â¦ƒiâ¦„ (f : Â«expr âŸ¶ Â» i j), x âˆˆ range (F.map f) :=\n  mem_interáµ¢â‚‚\n#align mem_eventual_range_iff mem_eventual_range_iff\n\n",
 "is_mittag_leffler_of_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem is_mittag_leffler_of_surjective (h : âˆ€ â¦ƒi j : Jâ¦„ (f : Â«expr âŸ¶ Â» i j), (F.map f).surjective) :\n    F.is_mittag_leffler := fun j => âŸ¨j, (Â«exprğŸ™Â») j, fun k g => by rw [map_id, types_id, range_id, (h g).range_eq]âŸ©\n#align is_mittag_leffler_of_surjective is_mittag_leffler_of_surjective\n\n",
 "is_mittag_leffler_of_exists_finite_range":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem is_mittag_leffler_of_exists_finite_range\n    (h : âˆ€ j : J, âˆƒ (i : _)(f : Â«expr âŸ¶ Â» i j), (range <| F.map f).finite) : F.is_mittag_leffler := fun j =>\n  by\n  obtain âŸ¨i, hi, hfâŸ© := h j\n  obtain âŸ¨m, âŸ¨i, f, hmâŸ©, hminâŸ© :=\n    finset.is_well_founded_lt.wf.has_min { s : Finset (F.obj j) | âˆƒ (i : _)(f : Â«expr âŸ¶ Â» i j), â†‘s = range (F.map f) }\n      âŸ¨_, i, hi, hf.coe_to_finsetâŸ©\n  refine'\n    âŸ¨i, f, fun k g => (directed_on_range.mp <| F.ranges_directed j).is_bot_of_is_min âŸ¨âŸ¨i, fâŸ©, rflâŸ© _ _ âŸ¨âŸ¨k, gâŸ©, rflâŸ©âŸ©\n  rintro _ âŸ¨âŸ¨k', g'âŸ©, rflâŸ© hl\n  refine' (eq_of_le_of_not_lt hl _).ge\n  have := hmin _ âŸ¨k', g', (m.finite_to_set.subset <| hm.substr hl).coe_to_finsetâŸ©\n  rwa [Finset.lt_iff_ssubset, â† Finset.coe_ssubset, Set.Finite.coe_toFinset, hm] at this\n#align is_mittag_leffler_of_exists_finite_range is_mittag_leffler_of_exists_finite_range\n\n",
 "is_mittag_leffler_iff_subset_range_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\ntheorem is_mittag_leffler_iff_subset_range_comp :\n    F.is_mittag_leffler â†”\n      âˆ€ j : J,\n        âˆƒ (i : _)(f : Â«expr âŸ¶ Â» i j), âˆ€ â¦ƒkâ¦„ (g : Â«expr âŸ¶ Â» k i), range (F.map f) âŠ† range (F.map <| Â«expr â‰« Â» g f) :=\n  by simp_rw [is_mittag_leffler_iff_eventual_range, eventual_range_eq_iff]\n#align is_mittag_leffler_iff_subset_range_comp is_mittag_leffler_iff_subset_range_comp\n\n",
 "is_mittag_leffler_iff_eventual_range":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem is_mittag_leffler_iff_eventual_range :\n    F.is_mittag_leffler â†” âˆ€ j : J, âˆƒ (i : _)(f : Â«expr âŸ¶ Â» i j), F.eventual_range j = range (F.map f) :=\n  forall_congr' fun j =>\n    existsâ‚‚_congr fun i f => âŸ¨fun h => (interáµ¢â‚‚_subset _ _).antisymm <| subset_interáµ¢â‚‚ h, fun h => h â–¸ interáµ¢â‚‚_subsetâŸ©\n#align is_mittag_leffler_iff_eventual_range is_mittag_leffler_iff_eventual_range\n\n",
 "init":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‹™ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/-\nCopyright (c) 2022 Kyle Miller, Adam Topaz, RÃ©mi Bottinelli, Junyan Xu. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Kyle Miller, Adam Topaz, RÃ©mi Bottinelli, Junyan Xu\n-/\n/-- This bootstraps `nonempty_sections_of_finite_inverse_system`. In this version,\nthe `F` functor is between categories of the same universe, and it is an easy\ncorollary to `Top.nonempty_limit_cone_of_compact_t2_inverse_system`. -/\ntheorem nonempty_sections_of_finite_cofiltered_system.init {J : Type u} [SmallCategory J] [IsCofilteredOrEmpty J]\n    (F : Â«expr â¥¤ Â» J (Type u)) [hf : âˆ€ j, Finite (F.obj j)] [hne : âˆ€ j, Nonempty (F.obj j)] : F.sections.nonempty :=\n  by\n  let F' : Â«expr â¥¤ Â» J TopCat := Â«expr â‹™ Â» F TopCat.discrete\n  haveI : âˆ€ j, DiscreteTopology (F'.obj j) := fun _ => âŸ¨rflâŸ©\n  haveI : âˆ€ j, Finite (F'.obj j) := hf\n  haveI : âˆ€ j, Nonempty (F'.obj j) := hne\n  obtain âŸ¨âŸ¨u, huâŸ©âŸ© := TopCat.nonempty_limitCone_of_compact_t2_cofiltered_system F'\n  exact âŸ¨u, fun _ _ => huâŸ©\n#align nonempty_sections_of_finite_cofiltered_system.init nonempty_sections_of_finite_cofiltered_system.init\n\n",
 "eventually_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem eventually_injective [Nonempty J] [Finite F.sections] : âˆƒ j, âˆ€ (i) (f : Â«expr âŸ¶ Â» i j), (F.map f).injective :=\n  by\n  haveI : âˆ€ j, Fintype (F.obj j) := fun j => Fintype.ofFinite (F.obj j)\n  haveI : Fintype F.sections := Fintype.ofFinite F.sections\n  have card_le : âˆ€ j, Fintype.card (F.obj j) â‰¤ Fintype.card F.sections := fun j =>\n    Fintype.card_le_of_surjective _ (F.eval_section_surjective_of_surjective Fsur j)\n  let fn j := Fintype.card F.sections - Fintype.card (F.obj j)\n  refine'\n    âŸ¨fn.argmin nat.well_founded_lt.wf, fun i f =>\n      ((Fintype.bijective_iff_surjective_and_card _).2\n          âŸ¨Fsur f, le_antisymm _ (Fintype.card_le_of_surjective _ <| Fsur f)âŸ©).1âŸ©\n  rw [â† nat.sub_sub_self (card_le i), tsub_le_iff_tsub_le]\n  apply fn.argmin_le\n#align eventually_injective eventually_injective\n\n",
 "eventual_range_maps_to":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem eventual_range_maps_to (f : Â«expr âŸ¶ Â» j i) : (F.eventual_range j).maps_to (F.map f) (F.eventual_range i) :=\n  fun x hx => by\n  rw [mem_eventual_range_iff] at hxâŠ¢\n  intro k f'\n  obtain âŸ¨l, g, g', heâŸ© := cospan f f'\n  obtain âŸ¨x, rflâŸ© := hx g\n  rw [â† map_comp_apply, he, F.map_comp]\n  exact âŸ¨_, rflâŸ©\n#align eventual_range_maps_to eventual_range_maps_to\n\n",
 "eventual_range_eq_range_precomp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\ntheorem eventual_range_eq_range_precomp (f : Â«expr âŸ¶ Â» i j) (g : Â«expr âŸ¶ Â» j k)\n    (h : F.eventual_range k = range (F.map g)) : F.eventual_range k = range (F.map <| Â«expr â‰« Â» f g) :=\n  by\n  apply subset_antisymm\n  Â· apply Interâ‚‚_subset\n  Â· rw [h, F.map_comp]\n    apply range_comp_subset_range\n#align eventual_range_eq_range_precomp eventual_range_eq_range_precomp\n\n",
 "eventual_range_eq_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\ntheorem eventual_range_eq_iff {f : Â«expr âŸ¶ Â» i j} :\n    F.eventual_range j = range (F.map f) â†”\n      âˆ€ â¦ƒkâ¦„ (g : Â«expr âŸ¶ Â» k i), range (F.map f) âŠ† range (F.map <| Â«expr â‰« Â» g f) :=\n  by\n  rw [subset_antisymm_iff, eventual_range, and_iff_right (Interâ‚‚_subset _ _), subset_Interâ‚‚_iff]\n  refine' âŸ¨fun h k g => h _ _, fun h j' f' => _âŸ©\n  obtain âŸ¨k, g, g', heâŸ© := cospan f f'\n  refine' (h g).trans _\n  rw [he, F.map_comp]\n  apply range_comp_subset_range\n#align eventual_range_eq_iff eventual_range_eq_iff\n\n",
 "eval_section_surjective_of_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\ntheorem eval_section_surjective_of_surjective (i : J) : (fun s : F.sections => s.val i).surjective := fun x =>\n  by\n  let s : Set (F.obj i) := {x}\n  haveI := F.to_preimages_nonempty_of_surjective s Fsur (singleton_nonempty x)\n  obtain âŸ¨sec, hâŸ© := nonempty_sections_of_finite_cofiltered_system (F.to_preimages s)\n  refine' âŸ¨âŸ¨fun j => (sec j).val, fun j k jk => by simpa [Subtype.ext_iff] using h jkâŸ©, _âŸ©\n  Â· have := (sec i).prop\n    simp only [mem_Inter, mem_preimage, mem_singleton_iff] at this\n    replace this := this ((Â«exprğŸ™Â») i)\n    rwa [map_id_apply] at this\n#align eval_section_surjective_of_surjective eval_section_surjective_of_surjective\n\n",
 "eval_section_injective_of_eventually_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem eval_section_injective_of_eventually_injective {j} (Finj : âˆ€ (i) (f : Â«expr âŸ¶ Â» i j), (F.map f).injective) (i)\n    (f : Â«expr âŸ¶ Â» i j) : (fun s : F.sections => s.val j).injective :=\n  by\n  refine' fun sâ‚€ sâ‚ h => Subtype.ext <| funext fun k => _\n  obtain âŸ¨m, mi, mk, _âŸ© := cone_objs i k\n  dsimp at h\n  rw [â† sâ‚€.prop (Â«expr â‰« Â» mi f), â† sâ‚.prop (Â«expr â‰« Â» mi f)] at h\n  rw [â† sâ‚€.prop mk, â† sâ‚.prop mk]\n  refine' congr_arg _ (Finj m (Â«expr â‰« Â» mi f) h)\n#align eval_section_injective_of_eventually_injective eval_section_injective_of_eventually_injective\n\n",
 "eq_image_eventual_range":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\ntheorem is_mittag_leffler.eq_image_eventual_range (h : F.is_mittag_leffler) (f : Â«expr âŸ¶ Â» j i) :\n    F.eventual_range i = Â«expr '' Â» (F.map f) (F.eventual_range j) :=\n  (h.subset_image_eventual_range F f).antisymm <| mapsTo'.1 (F.eventual_range_maps_to f)\n#align is_mittag_leffler.eq_image_eventual_range is_mittag_leffler.eq_image_eventual_range\n\n"}