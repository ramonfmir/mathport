{"to_preimages_nonempty_of_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem to_preimages_nonempty_of_surjective [hFn : ∀ j : J, Nonempty (F.obj j)]\n    (Fsur : ∀ ⦃i j : J⦄ (f : «expr ⟶ » i j), (F.map f).surjective) (hs : s.nonempty) (j) :\n    Nonempty ((F.to_preimages s).obj j) :=\n  by\n  simp only [to_preimages_obj, nonempty_coe_sort, nonempty_Inter, mem_preimage]\n  obtain h | ⟨⟨ji⟩⟩ := isEmpty_or_nonempty («expr ⟶ » j i)\n  · exact ⟨(hFn j).some, fun ji => h.elim ji⟩\n  · obtain ⟨y, ys⟩ := hs\n    obtain ⟨x, rfl⟩ := Fsur ji y\n    exact ⟨x, fun ji' => (F.thin_diagram_of_surjective Fsur ji' ji).symm ▸ ys⟩\n#align to_preimages_nonempty_of_surjective to_preimages_nonempty_of_surjective\n\n",
 "to_preimages":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem is_mittag_leffler.to_preimages (h : F.is_mittag_leffler) : (F.to_preimages s).is_mittag_leffler :=\n  (is_mittag_leffler_iff_subset_range_comp _).2 fun j =>\n    by\n    obtain ⟨j₁, g₁, f₁, -⟩ := cone_objs i j\n    obtain ⟨j₂, f₂, h₂⟩ := F.is_mittag_leffler_iff_eventual_range.1 h j₁\n    refine' ⟨j₂, «expr ≫ » f₂ f₁, fun j₃ f₃ => _⟩\n    rintro _ ⟨⟨x, hx⟩, rfl⟩\n    have : F.map f₂ x ∈ F.eventual_range j₁ := by\n      rw [h₂]\n      exact ⟨_, rfl⟩\n    obtain ⟨y, hy, h₃⟩ := h.subset_image_eventual_range F («expr ≫ » f₃ f₂) this\n    refine' ⟨⟨y, mem_Inter.2 fun g₂ => _⟩, Subtype.ext _⟩\n    · obtain ⟨j₄, f₄, h₄⟩ := cone_maps g₂ («expr ≫ » («expr ≫ » f₃ f₂) g₁)\n      obtain ⟨y, rfl⟩ := F.mem_eventual_range_iff.1 hy f₄\n      rw [← map_comp_apply] at h₃\n      rw [mem_preimage, ← map_comp_apply, h₄, ← category.assoc, map_comp_apply, h₃, ← map_comp_apply]\n      apply mem_Inter.1 hx\n    · simp_rw [to_preimages_map, maps_to.coe_restrict_apply, Subtype.coe_mk]\n      rw [← category.assoc, map_comp_apply, h₃, map_comp_apply]\n#align is_mittag_leffler.to_preimages is_mittag_leffler.to_preimages\n\n",
 "to_eventual_ranges_nonempty":
 "/-- If `F` is nonempty at each index and Mittag-Leffler, then so is `F.to_eventual_ranges`. -/\ntheorem to_eventual_ranges_nonempty (h : F.is_mittag_leffler) [∀ j : J, Nonempty (F.obj j)] (j : J) :\n    Nonempty (F.to_eventual_ranges.obj j) :=\n  by\n  let ⟨i, f, h⟩ := F.is_mittag_leffler_iff_eventual_range.1 h j\n  rw [to_eventual_ranges_obj, h]\n  infer_instance\n#align to_eventual_ranges_nonempty to_eventual_ranges_nonempty\n\n",
 "thin_diagram_of_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/-- If `F` has all arrows surjective, then it \"factors through a poset\". -/\ntheorem thin_diagram_of_surjective (Fsur : ∀ ⦃i j : J⦄ (f : «expr ⟶ » i j), (F.map f).surjective) {i j}\n    (f g : «expr ⟶ » i j) : F.map f = F.map g :=\n  let ⟨k, φ, hφ⟩ := cone_maps f g\n  (Fsur φ).injective_comp_right <| by simp_rw [← types_comp, ← F.map_comp, hφ]\n#align thin_diagram_of_surjective thin_diagram_of_surjective\n\n",
 "surjective_to_eventual_ranges":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/-- If `F` satisfies the Mittag-Leffler condition, its restriction to eventual ranges is a surjective\nfunctor.\n-/\ntheorem surjective_to_eventual_ranges (h : F.is_mittag_leffler) ⦃i j⦄ (f : «expr ⟶ » i j) :\n    (F.to_eventual_ranges.map f).surjective := fun ⟨x, hx⟩ =>\n  by\n  obtain ⟨y, hy, rfl⟩ := h.subset_image_eventual_range F f hx\n  exact ⟨⟨y, hy⟩, rfl⟩\n#align surjective_to_eventual_ranges surjective_to_eventual_ranges\n\n",
 "subset_image_eventual_range":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem is_mittag_leffler.subset_image_eventual_range (h : F.is_mittag_leffler) (f : «expr ⟶ » j i) :\n    F.eventual_range i ⊆ «expr '' » (F.map f) (F.eventual_range j) :=\n  by\n  obtain ⟨k, g, hg⟩ := F.is_mittag_leffler_iff_eventual_range.1 h j\n  rw [hg]; intro x hx\n  obtain ⟨x, rfl⟩ := F.mem_eventual_range_iff.1 hx («expr ≫ » g f)\n  refine' ⟨_, ⟨x, rfl⟩, by simpa only [F.map_comp] ⟩\n#align is_mittag_leffler.subset_image_eventual_range is_mittag_leffler.subset_image_eventual_range\n\n",
 "nonempty_sections_of_finite_inverse_system":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵖ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵖ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵖ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵖ» -/\n/-- The inverse limit of nonempty finite types is nonempty.\n\nSee `nonempty_sections_of_finite_cofiltered_system` for a generalization to cofiltered limits.\nThat version applies in almost all cases, and the only difference is that this version\nallows `J` to be empty.\n\nThis may be regarded as a generalization of Kőnig's lemma.\nTo specialize: given a locally finite connected graph, take `Jᵒᵖ` to be `ℕ` and\n`F j` to be length-`j` paths that start from an arbitrary fixed vertex.\nElements of `F.sections` can be read off as infinite rays in the graph. -/\ntheorem nonempty_sections_of_finite_inverse_system {J : Type u} [preorder J] [IsDirected J (· ≤ ·)]\n    (F : «expr ⥤ » («expr ᵒᵖ» J) (Type v)) [∀ j : «expr ᵒᵖ» J, Finite (F.obj j)]\n    [∀ j : «expr ᵒᵖ» J, Nonempty (F.obj j)] : F.sections.nonempty :=\n  by\n  cases isEmpty_or_nonempty J\n  · haveI : IsEmpty («expr ᵒᵖ» J) := ⟨fun j => isEmptyElim j.unop⟩\n    -- TODO: this should be a global instance\n    exact ⟨isEmptyElim, isEmptyElim⟩\n  · exact nonempty_sections_of_finite_cofiltered_system _\n#align nonempty_sections_of_finite_inverse_system nonempty_sections_of_finite_inverse_system\n\n",
 "nonempty_sections_of_finite_cofiltered_system":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/-- The cofiltered limit of nonempty finite types is nonempty.\n\nSee `nonempty_sections_of_finite_inverse_system` for a specialization to inverse limits. -/\ntheorem nonempty_sections_of_finite_cofiltered_system {J : Type u} [Category.{w} J] [IsCofilteredOrEmpty J]\n    (F : «expr ⥤ » J (Type v)) [∀ j : J, Finite (F.obj j)] [∀ j : J, Nonempty (F.obj j)] : F.sections.nonempty :=\n  by\n  -- Step 1: lift everything to the `max u v w` universe.\n  let J' : Type max w v u := AsSmall.{max w v} J\n  let down : «expr ⥤ » J' J := as_small.down\n  let F' : «expr ⥤ » J' (Type max u v w) := «expr ⋙ » down («expr ⋙ » F uliftFunctor.{max u w, v})\n  haveI : ∀ i, Nonempty (F'.obj i) := fun i => ⟨⟨Classical.arbitrary (F.obj (down.obj i))⟩⟩\n  haveI : ∀ i, Finite (F'.obj i) := fun i => Finite.of_equiv (F.obj (down.obj i)) equiv.ulift.symm\n  -- Step 2: apply the bootstrap theorem\n  cases isEmpty_or_nonempty J\n  · fconstructor <;> exact isEmptyElim\n  haveI : is_cofiltered J := ⟨⟩\n  obtain ⟨u, hu⟩ := nonempty_sections_of_finite_cofiltered_system.init F'\n  -- Step 3: interpret the results\n  use fun j => (u ⟨j⟩).down\n  intro j j' f\n  have h := @hu (⟨j⟩ : J') (⟨j'⟩ : J') (ULift.up f)\n  simp only [as_small.down, functor.comp_map, ulift_functor_map, functor.op_map] at h\n  simp_rw [← h]\n  rfl\n#align nonempty_sections_of_finite_cofiltered_system nonempty_sections_of_finite_cofiltered_system\n\n",
 "mem_eventual_range_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem mem_eventual_range_iff {x : F.obj j} :\n    x ∈ F.eventual_range j ↔ ∀ ⦃i⦄ (f : «expr ⟶ » i j), x ∈ range (F.map f) :=\n  mem_interᵢ₂\n#align mem_eventual_range_iff mem_eventual_range_iff\n\n",
 "is_mittag_leffler_of_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem is_mittag_leffler_of_surjective (h : ∀ ⦃i j : J⦄ (f : «expr ⟶ » i j), (F.map f).surjective) :\n    F.is_mittag_leffler := fun j => ⟨j, («expr𝟙») j, fun k g => by rw [map_id, types_id, range_id, (h g).range_eq]⟩\n#align is_mittag_leffler_of_surjective is_mittag_leffler_of_surjective\n\n",
 "is_mittag_leffler_of_exists_finite_range":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem is_mittag_leffler_of_exists_finite_range\n    (h : ∀ j : J, ∃ (i : _)(f : «expr ⟶ » i j), (range <| F.map f).finite) : F.is_mittag_leffler := fun j =>\n  by\n  obtain ⟨i, hi, hf⟩ := h j\n  obtain ⟨m, ⟨i, f, hm⟩, hmin⟩ :=\n    finset.is_well_founded_lt.wf.has_min { s : Finset (F.obj j) | ∃ (i : _)(f : «expr ⟶ » i j), ↑s = range (F.map f) }\n      ⟨_, i, hi, hf.coe_to_finset⟩\n  refine'\n    ⟨i, f, fun k g => (directed_on_range.mp <| F.ranges_directed j).is_bot_of_is_min ⟨⟨i, f⟩, rfl⟩ _ _ ⟨⟨k, g⟩, rfl⟩⟩\n  rintro _ ⟨⟨k', g'⟩, rfl⟩ hl\n  refine' (eq_of_le_of_not_lt hl _).ge\n  have := hmin _ ⟨k', g', (m.finite_to_set.subset <| hm.substr hl).coe_to_finset⟩\n  rwa [Finset.lt_iff_ssubset, ← Finset.coe_ssubset, Set.Finite.coe_toFinset, hm] at this\n#align is_mittag_leffler_of_exists_finite_range is_mittag_leffler_of_exists_finite_range\n\n",
 "is_mittag_leffler_iff_subset_range_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem is_mittag_leffler_iff_subset_range_comp :\n    F.is_mittag_leffler ↔\n      ∀ j : J,\n        ∃ (i : _)(f : «expr ⟶ » i j), ∀ ⦃k⦄ (g : «expr ⟶ » k i), range (F.map f) ⊆ range (F.map <| «expr ≫ » g f) :=\n  by simp_rw [is_mittag_leffler_iff_eventual_range, eventual_range_eq_iff]\n#align is_mittag_leffler_iff_subset_range_comp is_mittag_leffler_iff_subset_range_comp\n\n",
 "is_mittag_leffler_iff_eventual_range":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem is_mittag_leffler_iff_eventual_range :\n    F.is_mittag_leffler ↔ ∀ j : J, ∃ (i : _)(f : «expr ⟶ » i j), F.eventual_range j = range (F.map f) :=\n  forall_congr' fun j =>\n    exists₂_congr fun i f => ⟨fun h => (interᵢ₂_subset _ _).antisymm <| subset_interᵢ₂ h, fun h => h ▸ interᵢ₂_subset⟩\n#align is_mittag_leffler_iff_eventual_range is_mittag_leffler_iff_eventual_range\n\n",
 "init":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/-\nCopyright (c) 2022 Kyle Miller, Adam Topaz, Rémi Bottinelli, Junyan Xu. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Kyle Miller, Adam Topaz, Rémi Bottinelli, Junyan Xu\n-/\n/-- This bootstraps `nonempty_sections_of_finite_inverse_system`. In this version,\nthe `F` functor is between categories of the same universe, and it is an easy\ncorollary to `Top.nonempty_limit_cone_of_compact_t2_inverse_system`. -/\ntheorem nonempty_sections_of_finite_cofiltered_system.init {J : Type u} [SmallCategory J] [IsCofilteredOrEmpty J]\n    (F : «expr ⥤ » J (Type u)) [hf : ∀ j, Finite (F.obj j)] [hne : ∀ j, Nonempty (F.obj j)] : F.sections.nonempty :=\n  by\n  let F' : «expr ⥤ » J TopCat := «expr ⋙ » F TopCat.discrete\n  haveI : ∀ j, DiscreteTopology (F'.obj j) := fun _ => ⟨rfl⟩\n  haveI : ∀ j, Finite (F'.obj j) := hf\n  haveI : ∀ j, Nonempty (F'.obj j) := hne\n  obtain ⟨⟨u, hu⟩⟩ := TopCat.nonempty_limitCone_of_compact_t2_cofiltered_system F'\n  exact ⟨u, fun _ _ => hu⟩\n#align nonempty_sections_of_finite_cofiltered_system.init nonempty_sections_of_finite_cofiltered_system.init\n\n",
 "eventually_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem eventually_injective [Nonempty J] [Finite F.sections] : ∃ j, ∀ (i) (f : «expr ⟶ » i j), (F.map f).injective :=\n  by\n  haveI : ∀ j, Fintype (F.obj j) := fun j => Fintype.ofFinite (F.obj j)\n  haveI : Fintype F.sections := Fintype.ofFinite F.sections\n  have card_le : ∀ j, Fintype.card (F.obj j) ≤ Fintype.card F.sections := fun j =>\n    Fintype.card_le_of_surjective _ (F.eval_section_surjective_of_surjective Fsur j)\n  let fn j := Fintype.card F.sections - Fintype.card (F.obj j)\n  refine'\n    ⟨fn.argmin nat.well_founded_lt.wf, fun i f =>\n      ((Fintype.bijective_iff_surjective_and_card _).2\n          ⟨Fsur f, le_antisymm _ (Fintype.card_le_of_surjective _ <| Fsur f)⟩).1⟩\n  rw [← nat.sub_sub_self (card_le i), tsub_le_iff_tsub_le]\n  apply fn.argmin_le\n#align eventually_injective eventually_injective\n\n",
 "eventual_range_maps_to":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem eventual_range_maps_to (f : «expr ⟶ » j i) : (F.eventual_range j).maps_to (F.map f) (F.eventual_range i) :=\n  fun x hx => by\n  rw [mem_eventual_range_iff] at hx⊢\n  intro k f'\n  obtain ⟨l, g, g', he⟩ := cospan f f'\n  obtain ⟨x, rfl⟩ := hx g\n  rw [← map_comp_apply, he, F.map_comp]\n  exact ⟨_, rfl⟩\n#align eventual_range_maps_to eventual_range_maps_to\n\n",
 "eventual_range_eq_range_precomp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem eventual_range_eq_range_precomp (f : «expr ⟶ » i j) (g : «expr ⟶ » j k)\n    (h : F.eventual_range k = range (F.map g)) : F.eventual_range k = range (F.map <| «expr ≫ » f g) :=\n  by\n  apply subset_antisymm\n  · apply Inter₂_subset\n  · rw [h, F.map_comp]\n    apply range_comp_subset_range\n#align eventual_range_eq_range_precomp eventual_range_eq_range_precomp\n\n",
 "eventual_range_eq_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem eventual_range_eq_iff {f : «expr ⟶ » i j} :\n    F.eventual_range j = range (F.map f) ↔\n      ∀ ⦃k⦄ (g : «expr ⟶ » k i), range (F.map f) ⊆ range (F.map <| «expr ≫ » g f) :=\n  by\n  rw [subset_antisymm_iff, eventual_range, and_iff_right (Inter₂_subset _ _), subset_Inter₂_iff]\n  refine' ⟨fun h k g => h _ _, fun h j' f' => _⟩\n  obtain ⟨k, g, g', he⟩ := cospan f f'\n  refine' (h g).trans _\n  rw [he, F.map_comp]\n  apply range_comp_subset_range\n#align eventual_range_eq_iff eventual_range_eq_iff\n\n",
 "eval_section_surjective_of_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\ntheorem eval_section_surjective_of_surjective (i : J) : (fun s : F.sections => s.val i).surjective := fun x =>\n  by\n  let s : Set (F.obj i) := {x}\n  haveI := F.to_preimages_nonempty_of_surjective s Fsur (singleton_nonempty x)\n  obtain ⟨sec, h⟩ := nonempty_sections_of_finite_cofiltered_system (F.to_preimages s)\n  refine' ⟨⟨fun j => (sec j).val, fun j k jk => by simpa [Subtype.ext_iff] using h jk⟩, _⟩\n  · have := (sec i).prop\n    simp only [mem_Inter, mem_preimage, mem_singleton_iff] at this\n    replace this := this ((«expr𝟙») i)\n    rwa [map_id_apply] at this\n#align eval_section_surjective_of_surjective eval_section_surjective_of_surjective\n\n",
 "eval_section_injective_of_eventually_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem eval_section_injective_of_eventually_injective {j} (Finj : ∀ (i) (f : «expr ⟶ » i j), (F.map f).injective) (i)\n    (f : «expr ⟶ » i j) : (fun s : F.sections => s.val j).injective :=\n  by\n  refine' fun s₀ s₁ h => Subtype.ext <| funext fun k => _\n  obtain ⟨m, mi, mk, _⟩ := cone_objs i k\n  dsimp at h\n  rw [← s₀.prop («expr ≫ » mi f), ← s₁.prop («expr ≫ » mi f)] at h\n  rw [← s₀.prop mk, ← s₁.prop mk]\n  refine' congr_arg _ (Finj m («expr ≫ » mi f) h)\n#align eval_section_injective_of_eventually_injective eval_section_injective_of_eventually_injective\n\n",
 "eq_image_eventual_range":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem is_mittag_leffler.eq_image_eventual_range (h : F.is_mittag_leffler) (f : «expr ⟶ » j i) :\n    F.eventual_range i = «expr '' » (F.map f) (F.eventual_range j) :=\n  (h.subset_image_eventual_range F f).antisymm <| mapsTo'.1 (F.eventual_range_maps_to f)\n#align is_mittag_leffler.eq_image_eventual_range is_mittag_leffler.eq_image_eventual_range\n\n"}