{"has_limits_of_shape_of_reflective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/-- If `C` has limits of shape `J` then any reflective subcategory has limits of shape `J`. -/\ntheorem has_limits_of_shape_of_reflective [has_limits_of_shape J C] (R : Â«expr â¥¤ Â» D C) [reflective R] :\n    has_limits_of_shape J D :=\n  { has_limit := fun F => has_limit_of_reflective F R }\n#align has_limits_of_shape_of_reflective has_limits_of_shape_of_reflective\n\n",
 "has_limits_of_reflective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/-- If `C` has limits then any reflective subcategory has limits. -/\ntheorem has_limits_of_reflective (R : Â«expr â¥¤ Â» D C) [has_limits_of_size.{v, u} C] [reflective R] :\n    has_limits_of_size.{v, u} D :=\n  { has_limits_of_shape := fun J ð’¥â‚ => has_limits_of_shape_of_reflective R }\n#align has_limits_of_reflective has_limits_of_reflective\n\n",
 "has_limit_of_reflective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‹™ Â» -/\ntheorem has_limit_of_reflective (F : Â«expr â¥¤ Â» J D) (R : Â«expr â¥¤ Â» D C) [has_limit (Â«expr â‹™ Â» F R)] [reflective R] :\n    has_limit F :=\n  haveI := monadic_creates_limits.{v, u} R\n  has_limit_of_created F R\n#align has_limit_of_reflective has_limit_of_reflective\n\n",
 "has_limit_of_comp_forget_has_limit":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‹™ Â» -/\n/-\nCopyright (c) 2019 Scott Morrison. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Scott Morrison, Bhavik Mehta\n-/\n-- morphism levels before object levels. See note [category_theory universes].\n-- See library note [dsimp, simp]\n-- Theorem 5.6.5 from [Riehl][riehl2017]\n/-- `D â‹™ forget T` has a limit, then `D` has a limit. -/\ntheorem has_limit_of_comp_forget_has_limit (D : Â«expr â¥¤ Â» J (algebra T)) [has_limit (Â«expr â‹™ Â» D (forget T))] :\n    has_limit D :=\n  has_limit_of_created D (forget T)\n#align has_limit_of_comp_forget_has_limit has_limit_of_comp_forget_has_limit\n\n",
 "has_colimits_of_shape_of_reflective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‹™ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰ªâ‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/-- If `C` has colimits of shape `J` then any reflective subcategory has colimits of shape `J`. -/\ntheorem has_colimits_of_shape_of_reflective (R : Â«expr â¥¤ Â» D C) [reflective R] [has_colimits_of_shape J C] :\n    has_colimits_of_shape J D :=\n  {\n    has_colimit := fun F =>\n      by\n      let c := (left_adjoint R).map_cocone (colimit.cocone (Â«expr â‹™ Â» F R))\n      letI : preserves_colimits_of_shape J _ := (adjunction.of_right_adjoint R).left_adjoint_preserves_colimits.1\n      let t : is_colimit c := is_colimit_of_preserves (left_adjoint R) (colimit.is_colimit _)\n      apply has_colimit.mk âŸ¨_, (is_colimit.precompose_inv_equiv _ _).symm tâŸ©\n      apply Â«expr â‰ªâ‰« Â» (iso_whisker_left F (as_iso (adjunction.of_right_adjoint R).counit) : _) F.right_unitor }\n#align has_colimits_of_shape_of_reflective has_colimits_of_shape_of_reflective\n\n",
 "has_colimits_of_reflective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/-- If `C` has colimits then any reflective subcategory has colimits. -/\ntheorem has_colimits_of_reflective (R : Â«expr â¥¤ Â» D C) [reflective R] [has_colimits_of_size.{v, u} C] :\n    has_colimits_of_size.{v, u} D :=\n  { has_colimits_of_shape := fun J ð’¥ => has_colimits_of_shape_of_reflective R }\n#align has_colimits_of_reflective has_colimits_of_reflective\n\n",
 "forget_creates_colimits_of_monad_preserves":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‹™ Â» -/\n-- See library note [dsimp, simp]\n-- TODO: the converse of this is true as well\n/-- For `D : J â¥¤ algebra T`, `D â‹™ forget T` has a colimit, then `D` has a colimit provided colimits\nof shape `J` are preserved by `T`.\n-/\ntheorem forget_creates_colimits_of_monad_preserves [preserves_colimits_of_shape J (T : Â«expr â¥¤ Â» C C)]\n    (D : Â«expr â¥¤ Â» J (algebra T)) [has_colimit (Â«expr â‹™ Â» D (forget T))] : has_colimit D :=\n  has_colimit_of_created D (forget T)\n#align forget_creates_colimits_of_monad_preserves forget_creates_colimits_of_monad_preserves\n\n",
 "commuting":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n-- Let's hide the implementation details in a namespace\n-- We have a diagram D of shape J in the category of algebras, and we assume that we are given a\n-- colimit for its image D â‹™ forget T under the forgetful functor, say its apex is L.\n-- We'll construct a colimiting coalgebra for D, whose carrier will also be L.\n-- To do this, we must find a map TL âŸ¶ L. Since T preserves colimits, TL is also a colimit.\n-- In particular, it is a colimit for the diagram `(D â‹™ forget T) â‹™ T`\n-- so to construct a map TL âŸ¶ L it suffices to show that L is the apex of a cocone for this diagram.\n-- In other words, we need a natural transformation from const L to `(D â‹™ forget T) â‹™ T`.\n-- But we already know that L is the apex of a cocone for the diagram `D â‹™ forget T`, so it\n-- suffices to give a natural transformation `((D â‹™ forget T) â‹™ T) âŸ¶ (D â‹™ forget T)`:\n/-- (Impl) The key property defining the map `Î» : TL âŸ¶ L`. -/\ntheorem commuting (j : J) :\n    Â«expr â‰« Â» ((T : Â«expr â¥¤ Â» C C).map (c.Î¹.app j)) (lambda c t) = Â«expr â‰« Â» (D.obj j).a (c.Î¹.app j) :=\n  (is_colimit_of_preserves _ t).fac (new_cocone c) j\n#align commuting commuting\n\n"}