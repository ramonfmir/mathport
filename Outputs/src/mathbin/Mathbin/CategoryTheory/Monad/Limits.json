{"has_limits_of_shape_of_reflective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/-- If `C` has limits of shape `J` then any reflective subcategory has limits of shape `J`. -/\ntheorem has_limits_of_shape_of_reflective [has_limits_of_shape J C] (R : «expr ⥤ » D C) [reflective R] :\n    has_limits_of_shape J D :=\n  { has_limit := fun F => has_limit_of_reflective F R }\n#align has_limits_of_shape_of_reflective has_limits_of_shape_of_reflective\n\n",
 "has_limits_of_reflective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/-- If `C` has limits then any reflective subcategory has limits. -/\ntheorem has_limits_of_reflective (R : «expr ⥤ » D C) [has_limits_of_size.{v, u} C] [reflective R] :\n    has_limits_of_size.{v, u} D :=\n  { has_limits_of_shape := fun J 𝒥₁ => has_limits_of_shape_of_reflective R }\n#align has_limits_of_reflective has_limits_of_reflective\n\n",
 "has_limit_of_reflective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\ntheorem has_limit_of_reflective (F : «expr ⥤ » J D) (R : «expr ⥤ » D C) [has_limit («expr ⋙ » F R)] [reflective R] :\n    has_limit F :=\n  haveI := monadic_creates_limits.{v, u} R\n  has_limit_of_created F R\n#align has_limit_of_reflective has_limit_of_reflective\n\n",
 "has_limit_of_comp_forget_has_limit":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/-\nCopyright (c) 2019 Scott Morrison. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Scott Morrison, Bhavik Mehta\n-/\n-- morphism levels before object levels. See note [category_theory universes].\n-- See library note [dsimp, simp]\n-- Theorem 5.6.5 from [Riehl][riehl2017]\n/-- `D ⋙ forget T` has a limit, then `D` has a limit. -/\ntheorem has_limit_of_comp_forget_has_limit (D : «expr ⥤ » J (algebra T)) [has_limit («expr ⋙ » D (forget T))] :\n    has_limit D :=\n  has_limit_of_created D (forget T)\n#align has_limit_of_comp_forget_has_limit has_limit_of_comp_forget_has_limit\n\n",
 "has_colimits_of_shape_of_reflective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≪≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/-- If `C` has colimits of shape `J` then any reflective subcategory has colimits of shape `J`. -/\ntheorem has_colimits_of_shape_of_reflective (R : «expr ⥤ » D C) [reflective R] [has_colimits_of_shape J C] :\n    has_colimits_of_shape J D :=\n  {\n    has_colimit := fun F =>\n      by\n      let c := (left_adjoint R).map_cocone (colimit.cocone («expr ⋙ » F R))\n      letI : preserves_colimits_of_shape J _ := (adjunction.of_right_adjoint R).left_adjoint_preserves_colimits.1\n      let t : is_colimit c := is_colimit_of_preserves (left_adjoint R) (colimit.is_colimit _)\n      apply has_colimit.mk ⟨_, (is_colimit.precompose_inv_equiv _ _).symm t⟩\n      apply «expr ≪≫ » (iso_whisker_left F (as_iso (adjunction.of_right_adjoint R).counit) : _) F.right_unitor }\n#align has_colimits_of_shape_of_reflective has_colimits_of_shape_of_reflective\n\n",
 "has_colimits_of_reflective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/-- If `C` has colimits then any reflective subcategory has colimits. -/\ntheorem has_colimits_of_reflective (R : «expr ⥤ » D C) [reflective R] [has_colimits_of_size.{v, u} C] :\n    has_colimits_of_size.{v, u} D :=\n  { has_colimits_of_shape := fun J 𝒥 => has_colimits_of_shape_of_reflective R }\n#align has_colimits_of_reflective has_colimits_of_reflective\n\n",
 "forget_creates_colimits_of_monad_preserves":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n-- See library note [dsimp, simp]\n-- TODO: the converse of this is true as well\n/-- For `D : J ⥤ algebra T`, `D ⋙ forget T` has a colimit, then `D` has a colimit provided colimits\nof shape `J` are preserved by `T`.\n-/\ntheorem forget_creates_colimits_of_monad_preserves [preserves_colimits_of_shape J (T : «expr ⥤ » C C)]\n    (D : «expr ⥤ » J (algebra T)) [has_colimit («expr ⋙ » D (forget T))] : has_colimit D :=\n  has_colimit_of_created D (forget T)\n#align forget_creates_colimits_of_monad_preserves forget_creates_colimits_of_monad_preserves\n\n",
 "commuting":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n-- Let's hide the implementation details in a namespace\n-- We have a diagram D of shape J in the category of algebras, and we assume that we are given a\n-- colimit for its image D ⋙ forget T under the forgetful functor, say its apex is L.\n-- We'll construct a colimiting coalgebra for D, whose carrier will also be L.\n-- To do this, we must find a map TL ⟶ L. Since T preserves colimits, TL is also a colimit.\n-- In particular, it is a colimit for the diagram `(D ⋙ forget T) ⋙ T`\n-- so to construct a map TL ⟶ L it suffices to show that L is the apex of a cocone for this diagram.\n-- In other words, we need a natural transformation from const L to `(D ⋙ forget T) ⋙ T`.\n-- But we already know that L is the apex of a cocone for the diagram `D ⋙ forget T`, so it\n-- suffices to give a natural transformation `((D ⋙ forget T) ⋙ T) ⟶ (D ⋙ forget T)`:\n/-- (Impl) The key property defining the map `λ : TL ⟶ L`. -/\ntheorem commuting (j : J) :\n    «expr ≫ » ((T : «expr ⥤ » C C).map (c.ι.app j)) (lambda c t) = «expr ≫ » (D.obj j).a (c.ι.app j) :=\n  (is_colimit_of_preserves _ t).fac (new_cocone c) j\n#align commuting commuting\n\n"}