{"μ_inv_app_eq_to_hom":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem μ_inv_app_eq_to_hom {i j i' j' : A} (h₁ : i = i') (h₂ : j = j') (X : C) :\n    «expr ≫ » (inv ((F.μ ⟨i⟩ ⟨j⟩).app X)) (eq_to_hom (by rw [h₁, h₂])) =\n      «expr ≫ » (eq_to_hom (by rw [h₁, h₂])) (inv ((F.μ ⟨i'⟩ ⟨j'⟩).app X)) :=\n  by\n  cases h₁\n  cases h₂\n  rw [eq_to_hom_refl, eq_to_hom_refl, category.id_comp, category.comp_id]\n#align μ_inv_app_eq_to_hom μ_inv_app_eq_to_hom\n\n",
 "shift_zero_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟦ ⟧'» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟦ ⟧» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟦ ⟧» -/\ntheorem shift_zero_eq_zero (X Y : C) (n : A) :\n    «expr ⟦ ⟧'» (0 : «expr ⟶ » X Y) n = (0 : «expr ⟶ » («expr ⟦ ⟧» X n) («expr ⟦ ⟧» Y n)) :=\n  category_theory.functor.map_zero _ _ _\n#align shift_zero_eq_zero shift_zero_eq_zero\n\n",
 "shift_zero'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟦ ⟧'» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem shift_zero' : «expr ⟦ ⟧'» f (0 : A) = «expr ≫ » (shift_zero A X).hom («expr ≫ » f (shift_zero A Y).inv) :=\n  by\n  symm\n  apply nat_iso.naturality_2\n#align shift_zero' shift_zero'\n\n",
 "shift_shift_neg_shift_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟦ ⟧» -/\n@[simp]\ntheorem shift_shift_neg_shift_eq (n : A) (X : C) :\n    (shift_functor C n).map_iso (shift_shift_neg X n) = shift_neg_shift («expr ⟦ ⟧» X n) n :=\n  CategoryTheory.Iso.ext <| shift_shift_neg_hom_shift _ _\n#align shift_shift_neg_shift_eq shift_shift_neg_shift_eq\n\n",
 "shift_shift_neg_inv_shift":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟦ ⟧'» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟦ ⟧» -/\ntheorem shift_shift_neg_inv_shift (n : A) (X : C) :\n    «expr ⟦ ⟧'» (shift_shift_neg X n).inv n = (shift_neg_shift («expr ⟦ ⟧» X n) n).inv :=\n  by\n  ext\n  rw [← shift_shift_neg_hom_shift, ← functor.map_comp, iso.hom_inv_id, Functor.map_id]\n#align shift_shift_neg_inv_shift shift_shift_neg_inv_shift\n\n",
 "shift_shift_neg_hom_shift":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟦ ⟧'» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟦ ⟧» -/\ntheorem shift_shift_neg_hom_shift (n : A) (X : C) :\n    «expr ⟦ ⟧'» (shift_shift_neg X n).hom n = (shift_neg_shift («expr ⟦ ⟧» X n) n).hom :=\n  by\n  -- This is just `simp, simp [eq_to_hom_map]`.\n  simp only [iso.app_hom, unit_of_tensor_iso_unit_hom_app, eq_to_iso.hom, functor.map_comp, obj_μ_app, eq_to_iso.inv,\n    obj_ε_inv_app, μ_naturalityₗ_assoc, category.assoc, μ_inv_hom_app_assoc, ε_inv_app_obj, μ_naturalityᵣ_assoc]\n  simp only [eq_to_hom_map, eq_to_hom_app, eq_to_hom_trans]\n#align shift_shift_neg_hom_shift shift_shift_neg_hom_shift\n\n",
 "shift_shift_neg'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟦ ⟧'» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟦ ⟧'» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem shift_shift_neg' (i : A) :\n    «expr ⟦ ⟧'» («expr ⟦ ⟧'» f i) (-i) = «expr ≫ » (shift_shift_neg X i).hom («expr ≫ » f (shift_shift_neg Y i).inv) :=\n  by\n  symm\n  apply nat_iso.naturality_2\n#align shift_shift_neg' shift_shift_neg'\n\n",
 "shift_shift'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟦ ⟧'» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟦ ⟧'» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟦ ⟧'» -/\ntheorem shift_shift' (i j : A) :\n    «expr ⟦ ⟧'» («expr ⟦ ⟧'» f i) j =\n      «expr ≫ » (shift_add X i j).inv («expr ≫ » («expr ⟦ ⟧'» f (i + j)) (shift_add Y i j).hom) :=\n  by\n  symm\n  apply nat_iso.naturality_1\n#align shift_shift' shift_shift'\n\n",
 "shift_obj_obj":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟦ ⟧» -/\n-- Any better notational suggestions?\n@[simp]\ntheorem has_shift.shift_obj_obj (n : A) (X : C) : (has_shift.shift.obj ⟨n⟩).obj X = «expr ⟦ ⟧» X n :=\n  rfl\n#align has_shift.shift_obj_obj has_shift.shift_obj_obj\n\n",
 "shift_neg_shift'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟦ ⟧'» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟦ ⟧'» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem shift_neg_shift' (i : A) :\n    «expr ⟦ ⟧'» («expr ⟦ ⟧'» f (-i)) i = «expr ≫ » (shift_neg_shift X i).hom («expr ≫ » f (shift_neg_shift Y i).inv) :=\n  by\n  symm\n  apply nat_iso.naturality_2\n#align shift_neg_shift' shift_neg_shift'\n\n",
 "shift_functor_inv":
 "@[simp]\ntheorem shift_functor_inv (i : A) : (shift_functor C i).inv = shift_functor C (-i) :=\n  rfl\n#align shift_functor_inv shift_functor_inv\n\n",
 "shift_equiv_triangle":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟦ ⟧'» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟦ ⟧» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟦ ⟧» -/\ntheorem shift_equiv_triangle (n : A) (X : C) :\n    «expr ≫ » («expr ⟦ ⟧'» (shift_shift_neg X n).inv n) (shift_neg_shift («expr ⟦ ⟧» X n) n).hom =\n      («expr𝟙») («expr ⟦ ⟧» X n) :=\n  (add_neg_equiv (shift_monoidal_functor C A) n).functor_unit_iso_comp X\n#align shift_equiv_triangle shift_equiv_triangle\n\n",
 "shift_comm_symm":
 "@[simp]\ntheorem shift_comm_symm (i j : A) : (shift_comm X i j).symm = shift_comm X j i := by ext; dsimp [shift_comm];\n  simpa [eq_to_hom_map]\n#align shift_comm_symm shift_comm_symm\n\n",
 "shift_comm_hom_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟦ ⟧'» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟦ ⟧'» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟦ ⟧'» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟦ ⟧'» -/\n@[reassoc.1]\ntheorem shift_comm_hom_comp (i j : A) :\n    «expr ≫ » (shift_comm X i j).hom («expr ⟦ ⟧'» («expr ⟦ ⟧'» f j) i) =\n      «expr ≫ » («expr ⟦ ⟧'» («expr ⟦ ⟧'» f i) j) (shift_comm Y i j).hom :=\n  by rw [shift_comm', ← shift_comm_symm, iso.symm_hom, iso.inv_hom_id_assoc]\n#align shift_comm_hom_comp shift_comm_hom_comp\n\n",
 "shift_comm'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟦ ⟧'» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟦ ⟧'» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟦ ⟧'» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟦ ⟧'» -/\n/-- When shifts are indexed by an additive commutative monoid, then shifts commute. -/\ntheorem shift_comm' (i j : A) :\n    «expr ⟦ ⟧'» («expr ⟦ ⟧'» f i) j =\n      «expr ≫ » (shift_comm _ _ _).hom («expr ≫ » («expr ⟦ ⟧'» («expr ⟦ ⟧'» f j) i) (shift_comm _ _ _).hom) :=\n  by\n  -- This is just `simp, simp [eq_to_hom_map]`.\n  simp only [shift_comm, iso.trans_hom, iso.symm_hom, iso.app_inv, iso.symm_inv, monoidal_functor.μ_iso_hom,\n    iso.app_hom, functor.map_iso_hom, eq_to_iso.hom, μ_naturality_assoc, nat_trans.naturality_assoc,\n    nat_trans.naturality, functor.comp_map, category.assoc, μ_inv_hom_app_assoc]\n  simp only [eq_to_hom_map, eq_to_hom_app, eq_to_hom_trans_assoc, eq_to_hom_refl, category.id_comp, μ_hom_inv_app_assoc]\n#align shift_comm' shift_comm'\n\n",
 "shift_add_hom_comp_eq_to_hom₂":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[reassoc.1]\ntheorem shift_add_hom_comp_eq_to_hom₂ (i j j' : A) (h : j = j') :\n    «expr ≫ » (shift_add X i j).hom (eq_to_hom (by rw [h])) =\n      «expr ≫ » (eq_to_hom (by rw [h])) (shift_add X i j').hom :=\n  by\n  cases h\n  rw [eq_to_hom_refl, eq_to_hom_refl, category.id_comp, category.comp_id]\n#align shift_add_hom_comp_eq_to_hom₂ shift_add_hom_comp_eq_to_hom₂\n\n",
 "shift_add_hom_comp_eq_to_hom₁₂":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[reassoc.1]\ntheorem shift_add_hom_comp_eq_to_hom₁₂ (i j i' j' : A) (h₁ : i = i') (h₂ : j = j') :\n    «expr ≫ » (shift_add X i j).hom (eq_to_hom (by rw [h₁, h₂])) =\n      «expr ≫ » (eq_to_hom (by rw [h₁, h₂])) (shift_add X i' j').hom :=\n  by\n  cases h₁\n  cases h₂\n  rw [eq_to_hom_refl, eq_to_hom_refl, category.id_comp, category.comp_id]\n#align shift_add_hom_comp_eq_to_hom₁₂ shift_add_hom_comp_eq_to_hom₁₂\n\n",
 "shift_add_hom_comp_eq_to_hom₁":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[reassoc.1]\ntheorem shift_add_hom_comp_eq_to_hom₁ (i i' j : A) (h : i = i') :\n    «expr ≫ » (shift_add X i j).hom (eq_to_hom (by rw [h])) =\n      «expr ≫ » (eq_to_hom (by rw [h])) (shift_add X i' j).hom :=\n  by\n  cases h\n  rw [eq_to_hom_refl, eq_to_hom_refl, category.id_comp, category.comp_id]\n#align shift_add_hom_comp_eq_to_hom₁ shift_add_hom_comp_eq_to_hom₁\n\n",
 "eq_to_hom_μ_app":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `tensor_iso -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `tensor_iso -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/-\nCopyright (c) 2020 Scott Morrison. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Scott Morrison, Johan Commelin, Andrew Yang\n-/\n@[simp, reassoc.1]\ntheorem eq_to_hom_μ_app {i j i' j' : A} (h₁ : i = i') (h₂ : j = j') (X : C) :\n    «expr ≫ »\n        (eq_to_hom\n          (by rw [h₁, h₂] : (tensor_iso (F.obj ⟨i⟩) (F.obj ⟨j⟩)).obj X = (tensor_iso (F.obj ⟨i'⟩) (F.obj ⟨j'⟩)).obj X))\n        ((F.μ ⟨i'⟩ ⟨j'⟩).app X) =\n      «expr ≫ » ((F.μ ⟨i⟩ ⟨j⟩).app X) (eq_to_hom (by rw [h₁, h₂])) :=\n  by\n  cases h₁\n  cases h₂\n  rw [eq_to_hom_refl, eq_to_hom_refl, category.id_comp, category.comp_id]\n#align eq_to_hom_μ_app eq_to_hom_μ_app\n\n",
 "eq_to_hom_comp_shift_add_inv₂":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[reassoc.1]\ntheorem eq_to_hom_comp_shift_add_inv₂ (i j j' : A) (h : j = j') :\n    «expr ≫ » (eq_to_hom (by rw [h])) (shift_add X i j').inv =\n      «expr ≫ » (shift_add X i j).inv (eq_to_hom (by rw [h])) :=\n  by rw [iso.comp_inv_eq, category.assoc, iso.eq_inv_comp, shift_add_hom_comp_eq_to_hom₂]\n#align eq_to_hom_comp_shift_add_inv₂ eq_to_hom_comp_shift_add_inv₂\n\n",
 "eq_to_hom_comp_shift_add_inv₁₂":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[reassoc.1]\ntheorem eq_to_hom_comp_shift_add_inv₁₂ (i j i' j' : A) (h₁ : i = i') (h₂ : j = j') :\n    «expr ≫ » (eq_to_hom (by rw [h₁, h₂])) (shift_add X i' j').inv =\n      «expr ≫ » (shift_add X i j).inv (eq_to_hom (by rw [h₁, h₂])) :=\n  by rw [iso.comp_inv_eq, category.assoc, iso.eq_inv_comp, shift_add_hom_comp_eq_to_hom₁₂]\n#align eq_to_hom_comp_shift_add_inv₁₂ eq_to_hom_comp_shift_add_inv₁₂\n\n",
 "eq_to_hom_comp_shift_add_inv₁":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[reassoc.1]\ntheorem eq_to_hom_comp_shift_add_inv₁ (i i' j : A) (h : i = i') :\n    «expr ≫ » (eq_to_hom (by rw [h])) (shift_add X i' j).inv =\n      «expr ≫ » (shift_add X i j).inv (eq_to_hom (by rw [h])) :=\n  by rw [iso.comp_inv_eq, category.assoc, iso.eq_inv_comp, shift_add_hom_comp_eq_to_hom₁]\n#align eq_to_hom_comp_shift_add_inv₁ eq_to_hom_comp_shift_add_inv₁\n\n"}