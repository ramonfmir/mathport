{"monoidal_comp_refl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊗≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/-\nCopyright (c) 2022. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Scott Morrison, Yuma Mizuno, Oleksandr Manzyuk\n-/\n-- We could likely turn this into a `Prop` valued existential if that proves useful.\n-- type as \\ot \\gg\n-- type as \\ot \\gg\n-- To automatically insert unitors/associators at the beginning or end,\n-- you can use `f ⊗≫ 𝟙 _`\n@[simp]\ntheorem monoidal_comp_refl {X Y Z : C} (f : «expr ⟶ » X Y) (g : «expr ⟶ » Y Z) : «expr ⊗≫ » f g = «expr ≫ » f g :=\n  by\n  dsimp [monoidal_comp]\n  simp\n#align monoidal_comp_refl monoidal_comp_refl\n\n",
 "insert_id_rhs":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\ntheorem insert_id_rhs {C : Type _} [Category C] {X Y : C} (f g : «expr ⟶ » X Y) (w : f = «expr ≫ » g ((«expr𝟙») _)) :\n    f = g := by simpa using w\n#align insert_id_rhs insert_id_rhs\n\n",
 "insert_id_lhs":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\ntheorem insert_id_lhs {C : Type _} [Category C] {X Y : C} (f g : «expr ⟶ » X Y) (w : «expr ≫ » f ((«expr𝟙») _) = g) :\n    f = g := by simpa using w\n#align insert_id_lhs insert_id_lhs\n\n",
 "assoc_lift_hom":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n-- We have unused typeclass arguments here.\n-- They are intentional, to ensure that `simp only [assoc_lift_hom]` only left associates\n-- monoidal structural morphisms.\n/-- Auxiliary simp lemma for the `coherence` tactic:\nthis moves brackets to the left in order to expose a maximal prefix\nbuilt out of unitors and associators.\n-/\n@[nolint unused_arguments]\ntheorem assoc_lift_hom {W X Y Z : C} [lift_obj W] [lift_obj X] [lift_obj Y] (f : «expr ⟶ » W X) (g : «expr ⟶ » X Y)\n    (h : «expr ⟶ » Y Z) [lift_hom f] [lift_hom g] : «expr ≫ » f («expr ≫ » g h) = «expr ≫ » («expr ≫ » f g) h :=\n  (category.assoc _ _ _).symm\n#align assoc_lift_hom assoc_lift_hom\n\n"}