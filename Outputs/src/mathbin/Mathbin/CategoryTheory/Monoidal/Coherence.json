{"monoidal_comp_refl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŠ—â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/-\nCopyright (c) 2022. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Scott Morrison, Yuma Mizuno, Oleksandr Manzyuk\n-/\n-- We could likely turn this into a `Prop` valued existential if that proves useful.\n-- type as \\ot \\gg\n-- type as \\ot \\gg\n-- To automatically insert unitors/associators at the beginning or end,\n-- you can use `f âŠ—â‰« ğŸ™ _`\n@[simp]\ntheorem monoidal_comp_refl {X Y Z : C} (f : Â«expr âŸ¶ Â» X Y) (g : Â«expr âŸ¶ Â» Y Z) : Â«expr âŠ—â‰« Â» f g = Â«expr â‰« Â» f g :=\n  by\n  dsimp [monoidal_comp]\n  simp\n#align monoidal_comp_refl monoidal_comp_refl\n\n",
 "insert_id_rhs":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\ntheorem insert_id_rhs {C : Type _} [Category C] {X Y : C} (f g : Â«expr âŸ¶ Â» X Y) (w : f = Â«expr â‰« Â» g ((Â«exprğŸ™Â») _)) :\n    f = g := by simpa using w\n#align insert_id_rhs insert_id_rhs\n\n",
 "insert_id_lhs":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\ntheorem insert_id_lhs {C : Type _} [Category C] {X Y : C} (f g : Â«expr âŸ¶ Â» X Y) (w : Â«expr â‰« Â» f ((Â«exprğŸ™Â») _) = g) :\n    f = g := by simpa using w\n#align insert_id_lhs insert_id_lhs\n\n",
 "assoc_lift_hom":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n-- We have unused typeclass arguments here.\n-- They are intentional, to ensure that `simp only [assoc_lift_hom]` only left associates\n-- monoidal structural morphisms.\n/-- Auxiliary simp lemma for the `coherence` tactic:\nthis moves brackets to the left in order to expose a maximal prefix\nbuilt out of unitors and associators.\n-/\n@[nolint unused_arguments]\ntheorem assoc_lift_hom {W X Y Z : C} [lift_obj W] [lift_obj X] [lift_obj Y] (f : Â«expr âŸ¶ Â» W X) (g : Â«expr âŸ¶ Â» X Y)\n    (h : Â«expr âŸ¶ Â» Y Z) [lift_hom f] [lift_hom g] : Â«expr â‰« Â» f (Â«expr â‰« Â» g h) = Â«expr â‰« Â» (Â«expr â‰« Â» f g) h :=\n  (category.assoc _ _ _).symm\n#align assoc_lift_hom assoc_lift_hom\n\n"}