{"map_path_comp'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤q » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n-- A restatement of `prefunctor.map_path_comp` using `f ≫ g` instead of `f.comp g`.\n@[simp]\ntheorem prefunctor.map_path_comp' (F : «expr ⥤q » V W) {X Y Z : Paths V} (f : «expr ⟶ » X Y) (g : «expr ⟶ » Y Z) :\n    F.map_path («expr ≫ » f g) = (F.map_path f).comp (F.map_path g) :=\n  Prefunctor.mapPath_comp _ _ _\n#align prefunctor.map_path_comp' prefunctor.map_path_comp'\n\n",
 "lift_unique":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤q » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙q » -/\ntheorem lift_unique {C} [Category C] (φ : «expr ⥤q » V C) (Φ : «expr ⥤ » (Paths V) C)\n    (hΦ : «expr ⋙q » of Φ.to_prefunctor = φ) : Φ = lift φ :=\n  by\n  subst_vars\n  apply Functor.ext; rotate_left\n  · rintro X\n    rfl\n  · rintro X Y f\n    dsimp [lift]\n    induction' f with _ _ p f' ih\n    · simp only [category.comp_id]\n      apply Functor.map_id\n    · simp only [category.comp_id, category.id_comp] at ih⊢\n      have : Φ.map (p.cons f') = «expr ≫ » (Φ.map p) (Φ.map f'.to_path) := by convert functor.map_comp Φ p f'.to_path\n      rw [this, ih]\n#align lift_unique lift_unique\n\n",
 "lift_to_path":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤q » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n@[simp]\ntheorem lift_to_path {C} [Category C] (φ : «expr ⥤q » V C) {X Y : V} (f : «expr ⟶ » X Y) :\n    (lift φ).map f.to_path = φ.map f := by\n  dsimp [Quiver.Hom.toPath, lift]\n  simp\n#align lift_to_path lift_to_path\n\n",
 "lift_spec":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤q » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙q » -/\ntheorem lift_spec {C} [Category C] (φ : «expr ⥤q » V C) : «expr ⋙q » of (lift φ).to_prefunctor = φ :=\n  by\n  apply Prefunctor.ext; rotate_left\n  · rintro X\n    rfl\n  · rintro X Y f\n    rcases φ with ⟨φo, φm⟩\n    dsimp [lift, Quiver.Hom.toPath]\n    simp only [category.id_comp]\n#align lift_spec lift_spec\n\n",
 "lift_nil":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤q » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/-\nCopyright (c) 2021 Scott Morrison. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Scott Morrison\n-/\n@[simp]\ntheorem lift_nil {C} [Category C] (φ : «expr ⥤q » V C) (X : V) : (lift φ).map quiver.path.nil = («expr𝟙») (φ.obj X) :=\n  rfl\n#align lift_nil lift_nil\n\n",
 "lift_cons":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤q » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp]\ntheorem lift_cons {C} [Category C] (φ : «expr ⥤q » V C) {X Y Z : V} (p : Quiver.Path X Y) (f : «expr ⟶ » Y Z) :\n    (lift φ).map (p.cons f) = «expr ≫ » ((lift φ).map p) (φ.map f) :=\n  rfl\n#align lift_cons lift_cons\n\n",
 "ext_functor":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/-- Two functors out of a path category are equal when they agree on singleton paths. -/\n@[ext]\ntheorem ext_functor {C} [Category C] {F G : «expr ⥤ » (Paths V) C} (h_obj : F.obj = G.obj)\n    (h :\n      ∀ (a b : V) (e : «expr ⟶ » a b),\n        F.map e.to_path =\n          «expr ≫ » (eqToHom (congr_fun h_obj a)) («expr ≫ » (G.map e.to_path) (eqToHom (congr_fun h_obj.symm b)))) :\n    F = G := by\n  ext (X Y f)\n  · induction' f with Y' Z' g e ih\n    · erw [F.map_id, G.map_id, category.id_comp, eq_to_hom_trans, eq_to_hom_refl]\n    · erw [F.map_comp g e.to_path, G.map_comp g e.to_path, ih, h]\n      simp only [category.id_comp, eq_to_hom_refl, eq_to_hom_trans_assoc, category.assoc]\n  · intro X\n    rw [h_obj]\n#align ext_functor ext_functor\n\n",
 "compose_path_to_path":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n@[simp]\ntheorem compose_path_to_path {X Y : C} (f : «expr ⟶ » X Y) : composePath f.to_path = f :=\n  Category.id_comp _\n#align compose_path_to_path compose_path_to_path\n\n",
 "compose_path_id":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n@[simp]\ntheorem compose_path_id {X : Paths C} : composePath ((«expr𝟙») X) = («expr𝟙») X :=\n  rfl\n#align compose_path_id compose_path_id\n\n",
 "compose_path_comp'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp]\ntheorem compose_path_comp' {X Y Z : Paths C} (f : «expr ⟶ » X Y) (g : «expr ⟶ » Y Z) :\n    composePath («expr ≫ » f g) = «expr ≫ » (composePath f) (composePath g) :=\n  composePath_comp f g\n#align compose_path_comp' compose_path_comp'\n\n",
 "compose_path_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp]\ntheorem compose_path_comp {X Y Z : C} (f : Path X Y) (g : Path Y Z) :\n    composePath (f.comp g) = «expr ≫ » (composePath f) (composePath g) :=\n  by\n  induction' g with Y' Z' g e ih\n  · simp\n  · simp [ih]\n#align compose_path_comp compose_path_comp\n\n"}