{"wide_pushout_exists_rep'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem concrete.wide_pushout_exists_rep' {B : C} {Î± : Type _} [Nonempty Î±] {X : Î± â†’ C} (f : âˆ€ j : Î±, Â«expr âŸ¶ Â» B (X j))\n    [HasWidePushout.{v} B X f] [PreservesColimit (wideSpan B X f) (forget C)] (x : widePushout B X f) :\n    âˆƒ (i : Î±)(y : X i), Î¹ f i y = x :=\n  by\n  rcases concrete.wide_pushout_exists_rep f x with (âŸ¨y, rflâŸ© | âŸ¨i, y, rflâŸ©)\n  Â· inhabit Î±\n    use Inhabited.default _, f _ y\n    simp only [â† arrow_Î¹ _ (Inhabited.default Î±), comp_apply]\n  Â· use i, y\n#align concrete.wide_pushout_exists_rep' concrete.wide_pushout_exists_rep'\n\n",
 "wide_pushout_exists_rep":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem concrete.wide_pushout_exists_rep {B : C} {Î± : Type _} {X : Î± â†’ C} (f : âˆ€ j : Î±, Â«expr âŸ¶ Â» B (X j))\n    [HasWidePushout.{v} B X f] [PreservesColimit (wideSpan B X f) (forget C)] (x : widePushout B X f) :\n    (âˆƒ y : B, head f y = x) âˆ¨ âˆƒ (i : Î±)(y : X i), Î¹ f i y = x :=\n  by\n  obtain âŸ¨_ | j, y, rflâŸ© := concrete.colimit_exists_rep _ x\n  Â· use y\n  Â· right\n    use j, y\n#align concrete.wide_pushout_exists_rep concrete.wide_pushout_exists_rep\n\n",
 "wide_pullback_ext'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem concrete.wide_pullback_ext' {B : C} {Î¹ : Type w} [Nonempty Î¹] {X : Î¹ â†’ C} (f : âˆ€ j : Î¹, Â«expr âŸ¶ Â» (X j) B)\n    [HasWidePullback.{w} B X f] [PreservesLimit (wideCospan B X f) (forget C)] (x y : widePullback B X f)\n    (h : âˆ€ j, Ï€ f j x = Ï€ f j y) : x = y :=\n  by\n  apply concrete.wide_pullback_ext _ _ _ _ h\n  inhabit Î¹\n  simp only [â† Ï€_arrow f (Inhabited.default _), comp_apply, h]\n#align concrete.wide_pullback_ext' concrete.wide_pullback_ext'\n\n",
 "wide_pullback_ext":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem concrete.wide_pullback_ext {B : C} {Î¹ : Type w} {X : Î¹ â†’ C} (f : âˆ€ j : Î¹, Â«expr âŸ¶ Â» (X j) B)\n    [HasWidePullback B X f] [PreservesLimit (wideCospan B X f) (forget C)] (x y : widePullback B X f)\n    (hâ‚€ : base f x = base f y) (h : âˆ€ j, Ï€ f j x = Ï€ f j y) : x = y :=\n  by\n  apply concrete.limit_ext\n  rintro (_ | j)\n  Â· exact hâ‚€\n  Â· apply h\n#align concrete.wide_pullback_ext concrete.wide_pullback_ext\n\n",
 "to_product_injective_of_is_limit":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‹™ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‹™ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰… Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/-\nCopyright (c) 2017 Scott Morrison. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Scott Morrison, Adam Topaz\n-/\ntheorem concrete.to_product_injective_of_is_limit {D : Cone F} (hD : IsLimit D) :\n    function.injective fun (x : D.X) (j : J) => D.Ï€.app j x :=\n  by\n  let E := (forget C).map_cone D\n  let hE : is_limit E := is_limit_of_preserves _ hD\n  let G := Types.limitCone.{w, v} (Â«expr â‹™ Â» F (forget C))\n  let hG := Types.limitConeIsLimit.{w, v} (Â«expr â‹™ Â» F (forget C))\n  let T : Â«expr â‰… Â» E.X G.X := hE.cone_point_unique_up_to_iso hG\n  change function.injective (Â«expr â‰« Â» T.hom fun x j => G.Ï€.app j x)\n  have h : function.injective T.hom := by\n    intro a b h\n    suffices T.inv (T.hom a) = T.inv (T.hom b) by simpa\n    rw [h]\n  suffices function.injective fun (x : G.X) j => G.Ï€.app j x by exact this.comp h\n  apply Subtype.ext\n#align concrete.to_product_injective_of_is_limit concrete.to_product_injective_of_is_limit\n\n",
 "multiequalizer_ext":
 "theorem concrete.multiequalizer_ext {I : MulticospanIndex.{w} C} [HasMultiequalizer I]\n    [PreservesLimit I.multicospan (forget C)] (x y : multiequalizer I)\n    (h : âˆ€ t : I.L, Multiequalizer.Î¹ I t x = Multiequalizer.Î¹ I t y) : x = y :=\n  by\n  apply concrete.limit_ext\n  rintro (a | b)\n  Â· apply h\n  Â· rw [â† limit.w I.multicospan (walking_multicospan.hom.fst b), comp_apply, comp_apply, h]\n#align concrete.multiequalizer_ext concrete.multiequalizer_ext\n\n",
 "multiequalizer_equiv_apply":
 "@[simp]\ntheorem concrete.multiequalizer_equiv_apply (I : MulticospanIndex.{w} C) [HasMultiequalizer I]\n    [PreservesLimit I.multicospan (forget C)] (x : multiequalizer I) (i : I.L) :\n    ((Concrete.multiequalizerEquiv I) x : âˆ€ i : I.L, I.left i) i = Multiequalizer.Î¹ I i x :=\n  rfl\n#align concrete.multiequalizer_equiv_apply concrete.multiequalizer_equiv_apply\n\n",
 "limit_ext":
 "theorem concrete.limit_ext [HasLimit F] (x y : limit F) : (âˆ€ j, limit.Ï€ F j x = limit.Ï€ F j y) â†’ x = y :=\n  Concrete.isLimit_ext F (limit.isLimit _) _ _\n#align concrete.limit_ext concrete.limit_ext\n\n",
 "is_limit_ext":
 "theorem concrete.is_limit_ext {D : Cone F} (hD : IsLimit D) (x y : D.X) : (âˆ€ j, D.Ï€.app j x = D.Ï€.app j y) â†’ x = y :=\n  fun h => Concrete.to_product_injective_of_isLimit _ hD (funext h)\n#align concrete.is_limit_ext concrete.is_limit_ext\n\n",
 "is_colimit_rep_eq_of_exists":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‹™ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‹™ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰… Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰… Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem concrete.is_colimit_rep_eq_of_exists {D : Cocone F} {i j : J} (hD : IsColimit D) (x : F.obj i) (y : F.obj j)\n    (h : âˆƒ (k : _)(f : Â«expr âŸ¶ Â» i k)(g : Â«expr âŸ¶ Â» j k), F.map f x = F.map g y) : D.Î¹.app i x = D.Î¹.app j y :=\n  by\n  let E := (forget C).map_cocone D\n  let hE : is_colimit E := is_colimit_of_preserves _ hD\n  let G := Types.colimitCocone.{v, v} (Â«expr â‹™ Â» F (forget C))\n  let hG := Types.colimitCoconeIsColimit.{v, v} (Â«expr â‹™ Â» F (forget C))\n  let T : Â«expr â‰… Â» E G := hE.unique_up_to_iso hG\n  let TX : Â«expr â‰… Â» E.X G.X := (cocones.forget _).map_iso T\n  apply_fun TX.hom\n  swap;\n  Â· suffices function.bijective TX.hom by exact this.1\n    rw [â† is_iso_iff_bijective]\n    apply is_iso.of_iso\n  change (Â«expr â‰« Â» (E.Î¹.app i) TX.hom) x = (Â«expr â‰« Â» (E.Î¹.app j) TX.hom) y\n  erw [T.hom.w, T.hom.w]\n  obtain âŸ¨k, f, g, hâŸ© := h\n  have : G.Î¹.app i x = (G.Î¹.app k (F.map f x) : G.X) := quot.sound âŸ¨f, rflâŸ©\n  rw [this, h]\n  symm\n  exact quot.sound âŸ¨g, rflâŸ©\n#align concrete.is_colimit_rep_eq_of_exists concrete.is_colimit_rep_eq_of_exists\n\n",
 "is_colimit_rep_eq_iff_exists":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem concrete.is_colimit_rep_eq_iff_exists {D : Cocone F} {i j : J} (hD : IsColimit D) (x : F.obj i) (y : F.obj j) :\n    D.Î¹.app i x = D.Î¹.app j y â†” âˆƒ (k : _)(f : Â«expr âŸ¶ Â» i k)(g : Â«expr âŸ¶ Â» j k), F.map f x = F.map g y :=\n  âŸ¨Concrete.isColimit_exists_of_rep_eq _ hD _ _, Concrete.isColimit_rep_eq_of_exists _ hD _ _âŸ©\n#align concrete.is_colimit_rep_eq_iff_exists concrete.is_colimit_rep_eq_iff_exists\n\n",
 "is_colimit_exists_rep":
 "theorem concrete.is_colimit_exists_rep {D : Cocone F} (hD : IsColimit D) (x : D.X) :\n    âˆƒ (j : J)(y : F.obj j), D.Î¹.app j y = x :=\n  by\n  obtain âŸ¨a, rflâŸ© := concrete.from_union_surjective_of_is_colimit F hD x\n  exact âŸ¨a.1, a.2, rflâŸ©\n#align concrete.is_colimit_exists_rep concrete.is_colimit_exists_rep\n\n",
 "is_colimit_exists_of_rep_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‹™ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‹™ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰… Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰… Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‹™ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprðŸ™Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprðŸ™Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprðŸ™Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem concrete.is_colimit_exists_of_rep_eq {D : Cocone F} {i j : J} (hD : IsColimit D) (x : F.obj i) (y : F.obj j)\n    (h : D.Î¹.app _ x = D.Î¹.app _ y) : âˆƒ (k : _)(f : Â«expr âŸ¶ Â» i k)(g : Â«expr âŸ¶ Â» j k), F.map f x = F.map g y :=\n  by\n  let E := (forget C).map_cocone D\n  let hE : is_colimit E := is_colimit_of_preserves _ hD\n  let G := Types.colimitCocone.{v, v} (Â«expr â‹™ Â» F (forget C))\n  let hG := Types.colimitCoconeIsColimit.{v, v} (Â«expr â‹™ Â» F (forget C))\n  let T : Â«expr â‰… Â» E G := hE.unique_up_to_iso hG\n  let TX : Â«expr â‰… Â» E.X G.X := (cocones.forget _).map_iso T\n  apply_fun TX.hom  at h\n  change (Â«expr â‰« Â» (E.Î¹.app i) TX.hom) x = (Â«expr â‰« Â» (E.Î¹.app j) TX.hom) y at h\n  erw [T.hom.w, T.hom.w] at h\n  replace h := Quot.exact _ h\n  suffices\n    âˆ€ (a b : Î£j, F.obj j) (h : EqvGen (Limits.Types.Quot.Rel.{v, v} (Â«expr â‹™ Â» F (forget C))) a b),\n      âˆƒ (k : _)(f : Â«expr âŸ¶ Â» a.1 k)(g : Â«expr âŸ¶ Â» b.1 k), F.map f a.2 = F.map g b.2\n    by exact this âŸ¨i, xâŸ© âŸ¨j, yâŸ© h\n  intro a b h\n  induction h\n  case rel x y hh =>\n    obtain âŸ¨e, heâŸ© := hh\n    use y.1, e, (Â«exprðŸ™Â») _\n    simpa using he.symm\n  case refl x => use x.1, (Â«exprðŸ™Â») _, (Â«exprðŸ™Â») _, rfl\n  case symm x y _ hh =>\n    obtain âŸ¨k, f, g, hhâŸ© := hh\n    use k, g, f, hh.symm\n  case trans x y z _ _ hh1 hh2 =>\n    obtain âŸ¨k1, f1, g1, h1âŸ© := hh1\n    obtain âŸ¨k2, f2, g2, h2âŸ© := hh2\n    let k0 : J := is_filtered.max k1 k2\n    let e1 : Â«expr âŸ¶ Â» k1 k0 := is_filtered.left_to_max _ _\n    let e2 : Â«expr âŸ¶ Â» k2 k0 := is_filtered.right_to_max _ _\n    let k : J := is_filtered.coeq (Â«expr â‰« Â» g1 e1) (Â«expr â‰« Â» f2 e2)\n    let e : Â«expr âŸ¶ Â» k0 k := is_filtered.coeq_hom _ _\n    use k, Â«expr â‰« Â» f1 (Â«expr â‰« Â» e1 e), Â«expr â‰« Â» g2 (Â«expr â‰« Â» e2 e)\n    simp only [F.map_comp, comp_apply, h1, â† h2]\n    simp only [â† comp_apply, â† F.map_comp]\n    rw [is_filtered.coeq_condition]\n#align concrete.is_colimit_exists_of_rep_eq concrete.is_colimit_exists_of_rep_eq\n\n",
 "from_union_surjective_of_is_colimit":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‹™ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‹™ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰… Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰… Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\ntheorem concrete.from_union_surjective_of_is_colimit {D : Cocone F} (hD : IsColimit D) :\n    let ff : (Î£j : J, F.obj j) â†’ D.X := fun a => D.Î¹.app a.1 a.2\n    function.surjective ff :=\n  by\n  intro ff\n  let E := (forget C).map_cocone D\n  let hE : is_colimit E := is_colimit_of_preserves _ hD\n  let G := Types.colimitCocone.{v, v} (Â«expr â‹™ Â» F (forget C))\n  let hG := Types.colimitCoconeIsColimit.{v, v} (Â«expr â‹™ Â» F (forget C))\n  let T : Â«expr â‰… Â» E G := hE.unique_up_to_iso hG\n  let TX : Â«expr â‰… Â» E.X G.X := (cocones.forget _).map_iso T\n  suffices function.surjective (TX.hom âˆ˜ ff) by\n    intro a\n    obtain âŸ¨b, hbâŸ© := this (TX.hom a)\n    refine' âŸ¨b, _âŸ©\n    apply_fun TX.inv  at hb\n    change (Â«expr â‰« Â» TX.hom TX.inv) (ff b) = (Â«expr â‰« Â» TX.hom TX.inv) _ at hb\n    simpa only [TX.hom_inv_id] using hb\n  have : TX.hom âˆ˜ ff = fun a => G.Î¹.app a.1 a.2 := by\n    ext a\n    change (Â«expr â‰« Â» (E.Î¹.app a.1) (hE.desc G)) a.2 = _\n    rw [hE.fac]\n  rw [this]\n  rintro âŸ¨âŸ¨j, aâŸ©âŸ©\n  exact âŸ¨âŸ¨j, aâŸ©, rflâŸ©\n#align concrete.from_union_surjective_of_is_colimit concrete.from_union_surjective_of_is_colimit\n\n",
 "colimit_rep_eq_of_exists":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem concrete.colimit_rep_eq_of_exists [HasColimit F] {i j : J} (x : F.obj i) (y : F.obj j)\n    (h : âˆƒ (k : _)(f : Â«expr âŸ¶ Â» i k)(g : Â«expr âŸ¶ Â» j k), F.map f x = F.map g y) : colimit.Î¹ F i x = colimit.Î¹ F j y :=\n  Concrete.isColimit_rep_eq_of_exists F (colimit.isColimit _) x y h\n#align concrete.colimit_rep_eq_of_exists concrete.colimit_rep_eq_of_exists\n\n",
 "colimit_rep_eq_iff_exists":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem concrete.colimit_rep_eq_iff_exists [HasColimit F] {i j : J} (x : F.obj i) (y : F.obj j) :\n    colimit.Î¹ F i x = colimit.Î¹ F j y â†” âˆƒ (k : _)(f : Â«expr âŸ¶ Â» i k)(g : Â«expr âŸ¶ Â» j k), F.map f x = F.map g y :=\n  âŸ¨Concrete.colimit_exists_of_rep_eq _ _ _, Concrete.colimit_rep_eq_of_exists _ _ _âŸ©\n#align concrete.colimit_rep_eq_iff_exists concrete.colimit_rep_eq_iff_exists\n\n",
 "colimit_exists_rep":
 "theorem concrete.colimit_exists_rep [HasColimit F] (x : colimit F) : âˆƒ (j : J)(y : F.obj j), colimit.Î¹ F j y = x :=\n  Concrete.isColimit_exists_rep F (colimit.isColimit _) x\n#align concrete.colimit_exists_rep concrete.colimit_exists_rep\n\n",
 "colimit_exists_of_rep_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem concrete.colimit_exists_of_rep_eq [HasColimit F] {i j : J} (x : F.obj i) (y : F.obj j)\n    (h : colimit.Î¹ F _ x = colimit.Î¹ F _ y) : âˆƒ (k : _)(f : Â«expr âŸ¶ Â» i k)(g : Â«expr âŸ¶ Â» j k), F.map f x = F.map g y :=\n  Concrete.isColimit_exists_of_rep_eq F (colimit.isColimit _) x y h\n#align concrete.colimit_exists_of_rep_eq concrete.colimit_exists_of_rep_eq\n\n",
 "cokernel_funext":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n-- TODO: Add analogous lemmas about products and equalizers.\n-- We don't mark this as an `@[ext]` lemma as we don't always want to work elementwise.\ntheorem cokernel_funext {C : Type _} [Category C] [HasZeroMorphisms C] [ConcreteCategory C] {M N K : C}\n    {f : Â«expr âŸ¶ Â» M N} [HasCokernel f] {g h : Â«expr âŸ¶ Â» (cokernel f) K}\n    (w : âˆ€ n : N, g (cokernel.Ï€ f n) = h (cokernel.Ï€ f n)) : g = h :=\n  by\n  apply coequalizer.hom_ext\n  apply concrete_category.hom_ext _ _\n  simpa using w\n#align cokernel_funext cokernel_funext\n\n"}