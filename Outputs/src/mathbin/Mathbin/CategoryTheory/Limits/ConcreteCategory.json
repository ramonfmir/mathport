{"wide_pushout_exists_rep'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem concrete.wide_pushout_exists_rep' {B : C} {α : Type _} [Nonempty α] {X : α → C} (f : ∀ j : α, «expr ⟶ » B (X j))\n    [HasWidePushout.{v} B X f] [PreservesColimit (wideSpan B X f) (forget C)] (x : widePushout B X f) :\n    ∃ (i : α)(y : X i), ι f i y = x :=\n  by\n  rcases concrete.wide_pushout_exists_rep f x with (⟨y, rfl⟩ | ⟨i, y, rfl⟩)\n  · inhabit α\n    use Inhabited.default _, f _ y\n    simp only [← arrow_ι _ (Inhabited.default α), comp_apply]\n  · use i, y\n#align concrete.wide_pushout_exists_rep' concrete.wide_pushout_exists_rep'\n\n",
 "wide_pushout_exists_rep":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem concrete.wide_pushout_exists_rep {B : C} {α : Type _} {X : α → C} (f : ∀ j : α, «expr ⟶ » B (X j))\n    [HasWidePushout.{v} B X f] [PreservesColimit (wideSpan B X f) (forget C)] (x : widePushout B X f) :\n    (∃ y : B, head f y = x) ∨ ∃ (i : α)(y : X i), ι f i y = x :=\n  by\n  obtain ⟨_ | j, y, rfl⟩ := concrete.colimit_exists_rep _ x\n  · use y\n  · right\n    use j, y\n#align concrete.wide_pushout_exists_rep concrete.wide_pushout_exists_rep\n\n",
 "wide_pullback_ext'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem concrete.wide_pullback_ext' {B : C} {ι : Type w} [Nonempty ι] {X : ι → C} (f : ∀ j : ι, «expr ⟶ » (X j) B)\n    [HasWidePullback.{w} B X f] [PreservesLimit (wideCospan B X f) (forget C)] (x y : widePullback B X f)\n    (h : ∀ j, π f j x = π f j y) : x = y :=\n  by\n  apply concrete.wide_pullback_ext _ _ _ _ h\n  inhabit ι\n  simp only [← π_arrow f (Inhabited.default _), comp_apply, h]\n#align concrete.wide_pullback_ext' concrete.wide_pullback_ext'\n\n",
 "wide_pullback_ext":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem concrete.wide_pullback_ext {B : C} {ι : Type w} {X : ι → C} (f : ∀ j : ι, «expr ⟶ » (X j) B)\n    [HasWidePullback B X f] [PreservesLimit (wideCospan B X f) (forget C)] (x y : widePullback B X f)\n    (h₀ : base f x = base f y) (h : ∀ j, π f j x = π f j y) : x = y :=\n  by\n  apply concrete.limit_ext\n  rintro (_ | j)\n  · exact h₀\n  · apply h\n#align concrete.wide_pullback_ext concrete.wide_pullback_ext\n\n",
 "to_product_injective_of_is_limit":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≅ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/-\nCopyright (c) 2017 Scott Morrison. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Scott Morrison, Adam Topaz\n-/\ntheorem concrete.to_product_injective_of_is_limit {D : Cone F} (hD : IsLimit D) :\n    function.injective fun (x : D.X) (j : J) => D.π.app j x :=\n  by\n  let E := (forget C).map_cone D\n  let hE : is_limit E := is_limit_of_preserves _ hD\n  let G := Types.limitCone.{w, v} («expr ⋙ » F (forget C))\n  let hG := Types.limitConeIsLimit.{w, v} («expr ⋙ » F (forget C))\n  let T : «expr ≅ » E.X G.X := hE.cone_point_unique_up_to_iso hG\n  change function.injective («expr ≫ » T.hom fun x j => G.π.app j x)\n  have h : function.injective T.hom := by\n    intro a b h\n    suffices T.inv (T.hom a) = T.inv (T.hom b) by simpa\n    rw [h]\n  suffices function.injective fun (x : G.X) j => G.π.app j x by exact this.comp h\n  apply Subtype.ext\n#align concrete.to_product_injective_of_is_limit concrete.to_product_injective_of_is_limit\n\n",
 "multiequalizer_ext":
 "theorem concrete.multiequalizer_ext {I : MulticospanIndex.{w} C} [HasMultiequalizer I]\n    [PreservesLimit I.multicospan (forget C)] (x y : multiequalizer I)\n    (h : ∀ t : I.L, Multiequalizer.ι I t x = Multiequalizer.ι I t y) : x = y :=\n  by\n  apply concrete.limit_ext\n  rintro (a | b)\n  · apply h\n  · rw [← limit.w I.multicospan (walking_multicospan.hom.fst b), comp_apply, comp_apply, h]\n#align concrete.multiequalizer_ext concrete.multiequalizer_ext\n\n",
 "multiequalizer_equiv_apply":
 "@[simp]\ntheorem concrete.multiequalizer_equiv_apply (I : MulticospanIndex.{w} C) [HasMultiequalizer I]\n    [PreservesLimit I.multicospan (forget C)] (x : multiequalizer I) (i : I.L) :\n    ((Concrete.multiequalizerEquiv I) x : ∀ i : I.L, I.left i) i = Multiequalizer.ι I i x :=\n  rfl\n#align concrete.multiequalizer_equiv_apply concrete.multiequalizer_equiv_apply\n\n",
 "limit_ext":
 "theorem concrete.limit_ext [HasLimit F] (x y : limit F) : (∀ j, limit.π F j x = limit.π F j y) → x = y :=\n  Concrete.isLimit_ext F (limit.isLimit _) _ _\n#align concrete.limit_ext concrete.limit_ext\n\n",
 "is_limit_ext":
 "theorem concrete.is_limit_ext {D : Cone F} (hD : IsLimit D) (x y : D.X) : (∀ j, D.π.app j x = D.π.app j y) → x = y :=\n  fun h => Concrete.to_product_injective_of_isLimit _ hD (funext h)\n#align concrete.is_limit_ext concrete.is_limit_ext\n\n",
 "is_colimit_rep_eq_of_exists":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≅ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≅ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem concrete.is_colimit_rep_eq_of_exists {D : Cocone F} {i j : J} (hD : IsColimit D) (x : F.obj i) (y : F.obj j)\n    (h : ∃ (k : _)(f : «expr ⟶ » i k)(g : «expr ⟶ » j k), F.map f x = F.map g y) : D.ι.app i x = D.ι.app j y :=\n  by\n  let E := (forget C).map_cocone D\n  let hE : is_colimit E := is_colimit_of_preserves _ hD\n  let G := Types.colimitCocone.{v, v} («expr ⋙ » F (forget C))\n  let hG := Types.colimitCoconeIsColimit.{v, v} («expr ⋙ » F (forget C))\n  let T : «expr ≅ » E G := hE.unique_up_to_iso hG\n  let TX : «expr ≅ » E.X G.X := (cocones.forget _).map_iso T\n  apply_fun TX.hom\n  swap;\n  · suffices function.bijective TX.hom by exact this.1\n    rw [← is_iso_iff_bijective]\n    apply is_iso.of_iso\n  change («expr ≫ » (E.ι.app i) TX.hom) x = («expr ≫ » (E.ι.app j) TX.hom) y\n  erw [T.hom.w, T.hom.w]\n  obtain ⟨k, f, g, h⟩ := h\n  have : G.ι.app i x = (G.ι.app k (F.map f x) : G.X) := quot.sound ⟨f, rfl⟩\n  rw [this, h]\n  symm\n  exact quot.sound ⟨g, rfl⟩\n#align concrete.is_colimit_rep_eq_of_exists concrete.is_colimit_rep_eq_of_exists\n\n",
 "is_colimit_rep_eq_iff_exists":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem concrete.is_colimit_rep_eq_iff_exists {D : Cocone F} {i j : J} (hD : IsColimit D) (x : F.obj i) (y : F.obj j) :\n    D.ι.app i x = D.ι.app j y ↔ ∃ (k : _)(f : «expr ⟶ » i k)(g : «expr ⟶ » j k), F.map f x = F.map g y :=\n  ⟨Concrete.isColimit_exists_of_rep_eq _ hD _ _, Concrete.isColimit_rep_eq_of_exists _ hD _ _⟩\n#align concrete.is_colimit_rep_eq_iff_exists concrete.is_colimit_rep_eq_iff_exists\n\n",
 "is_colimit_exists_rep":
 "theorem concrete.is_colimit_exists_rep {D : Cocone F} (hD : IsColimit D) (x : D.X) :\n    ∃ (j : J)(y : F.obj j), D.ι.app j y = x :=\n  by\n  obtain ⟨a, rfl⟩ := concrete.from_union_surjective_of_is_colimit F hD x\n  exact ⟨a.1, a.2, rfl⟩\n#align concrete.is_colimit_exists_rep concrete.is_colimit_exists_rep\n\n",
 "is_colimit_exists_of_rep_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≅ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≅ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem concrete.is_colimit_exists_of_rep_eq {D : Cocone F} {i j : J} (hD : IsColimit D) (x : F.obj i) (y : F.obj j)\n    (h : D.ι.app _ x = D.ι.app _ y) : ∃ (k : _)(f : «expr ⟶ » i k)(g : «expr ⟶ » j k), F.map f x = F.map g y :=\n  by\n  let E := (forget C).map_cocone D\n  let hE : is_colimit E := is_colimit_of_preserves _ hD\n  let G := Types.colimitCocone.{v, v} («expr ⋙ » F (forget C))\n  let hG := Types.colimitCoconeIsColimit.{v, v} («expr ⋙ » F (forget C))\n  let T : «expr ≅ » E G := hE.unique_up_to_iso hG\n  let TX : «expr ≅ » E.X G.X := (cocones.forget _).map_iso T\n  apply_fun TX.hom  at h\n  change («expr ≫ » (E.ι.app i) TX.hom) x = («expr ≫ » (E.ι.app j) TX.hom) y at h\n  erw [T.hom.w, T.hom.w] at h\n  replace h := Quot.exact _ h\n  suffices\n    ∀ (a b : Σj, F.obj j) (h : EqvGen (Limits.Types.Quot.Rel.{v, v} («expr ⋙ » F (forget C))) a b),\n      ∃ (k : _)(f : «expr ⟶ » a.1 k)(g : «expr ⟶ » b.1 k), F.map f a.2 = F.map g b.2\n    by exact this ⟨i, x⟩ ⟨j, y⟩ h\n  intro a b h\n  induction h\n  case rel x y hh =>\n    obtain ⟨e, he⟩ := hh\n    use y.1, e, («expr𝟙») _\n    simpa using he.symm\n  case refl x => use x.1, («expr𝟙») _, («expr𝟙») _, rfl\n  case symm x y _ hh =>\n    obtain ⟨k, f, g, hh⟩ := hh\n    use k, g, f, hh.symm\n  case trans x y z _ _ hh1 hh2 =>\n    obtain ⟨k1, f1, g1, h1⟩ := hh1\n    obtain ⟨k2, f2, g2, h2⟩ := hh2\n    let k0 : J := is_filtered.max k1 k2\n    let e1 : «expr ⟶ » k1 k0 := is_filtered.left_to_max _ _\n    let e2 : «expr ⟶ » k2 k0 := is_filtered.right_to_max _ _\n    let k : J := is_filtered.coeq («expr ≫ » g1 e1) («expr ≫ » f2 e2)\n    let e : «expr ⟶ » k0 k := is_filtered.coeq_hom _ _\n    use k, «expr ≫ » f1 («expr ≫ » e1 e), «expr ≫ » g2 («expr ≫ » e2 e)\n    simp only [F.map_comp, comp_apply, h1, ← h2]\n    simp only [← comp_apply, ← F.map_comp]\n    rw [is_filtered.coeq_condition]\n#align concrete.is_colimit_exists_of_rep_eq concrete.is_colimit_exists_of_rep_eq\n\n",
 "from_union_surjective_of_is_colimit":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≅ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≅ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem concrete.from_union_surjective_of_is_colimit {D : Cocone F} (hD : IsColimit D) :\n    let ff : (Σj : J, F.obj j) → D.X := fun a => D.ι.app a.1 a.2\n    function.surjective ff :=\n  by\n  intro ff\n  let E := (forget C).map_cocone D\n  let hE : is_colimit E := is_colimit_of_preserves _ hD\n  let G := Types.colimitCocone.{v, v} («expr ⋙ » F (forget C))\n  let hG := Types.colimitCoconeIsColimit.{v, v} («expr ⋙ » F (forget C))\n  let T : «expr ≅ » E G := hE.unique_up_to_iso hG\n  let TX : «expr ≅ » E.X G.X := (cocones.forget _).map_iso T\n  suffices function.surjective (TX.hom ∘ ff) by\n    intro a\n    obtain ⟨b, hb⟩ := this (TX.hom a)\n    refine' ⟨b, _⟩\n    apply_fun TX.inv  at hb\n    change («expr ≫ » TX.hom TX.inv) (ff b) = («expr ≫ » TX.hom TX.inv) _ at hb\n    simpa only [TX.hom_inv_id] using hb\n  have : TX.hom ∘ ff = fun a => G.ι.app a.1 a.2 := by\n    ext a\n    change («expr ≫ » (E.ι.app a.1) (hE.desc G)) a.2 = _\n    rw [hE.fac]\n  rw [this]\n  rintro ⟨⟨j, a⟩⟩\n  exact ⟨⟨j, a⟩, rfl⟩\n#align concrete.from_union_surjective_of_is_colimit concrete.from_union_surjective_of_is_colimit\n\n",
 "colimit_rep_eq_of_exists":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem concrete.colimit_rep_eq_of_exists [HasColimit F] {i j : J} (x : F.obj i) (y : F.obj j)\n    (h : ∃ (k : _)(f : «expr ⟶ » i k)(g : «expr ⟶ » j k), F.map f x = F.map g y) : colimit.ι F i x = colimit.ι F j y :=\n  Concrete.isColimit_rep_eq_of_exists F (colimit.isColimit _) x y h\n#align concrete.colimit_rep_eq_of_exists concrete.colimit_rep_eq_of_exists\n\n",
 "colimit_rep_eq_iff_exists":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem concrete.colimit_rep_eq_iff_exists [HasColimit F] {i j : J} (x : F.obj i) (y : F.obj j) :\n    colimit.ι F i x = colimit.ι F j y ↔ ∃ (k : _)(f : «expr ⟶ » i k)(g : «expr ⟶ » j k), F.map f x = F.map g y :=\n  ⟨Concrete.colimit_exists_of_rep_eq _ _ _, Concrete.colimit_rep_eq_of_exists _ _ _⟩\n#align concrete.colimit_rep_eq_iff_exists concrete.colimit_rep_eq_iff_exists\n\n",
 "colimit_exists_rep":
 "theorem concrete.colimit_exists_rep [HasColimit F] (x : colimit F) : ∃ (j : J)(y : F.obj j), colimit.ι F j y = x :=\n  Concrete.isColimit_exists_rep F (colimit.isColimit _) x\n#align concrete.colimit_exists_rep concrete.colimit_exists_rep\n\n",
 "colimit_exists_of_rep_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem concrete.colimit_exists_of_rep_eq [HasColimit F] {i j : J} (x : F.obj i) (y : F.obj j)\n    (h : colimit.ι F _ x = colimit.ι F _ y) : ∃ (k : _)(f : «expr ⟶ » i k)(g : «expr ⟶ » j k), F.map f x = F.map g y :=\n  Concrete.isColimit_exists_of_rep_eq F (colimit.isColimit _) x y h\n#align concrete.colimit_exists_of_rep_eq concrete.colimit_exists_of_rep_eq\n\n",
 "cokernel_funext":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n-- TODO: Add analogous lemmas about products and equalizers.\n-- We don't mark this as an `@[ext]` lemma as we don't always want to work elementwise.\ntheorem cokernel_funext {C : Type _} [Category C] [HasZeroMorphisms C] [ConcreteCategory C] {M N K : C}\n    {f : «expr ⟶ » M N} [HasCokernel f] {g h : «expr ⟶ » (cokernel f) K}\n    (w : ∀ n : N, g (cokernel.π f n) = h (cokernel.π f n)) : g = h :=\n  by\n  apply coequalizer.hom_ext\n  apply concrete_category.hom_ext _ _\n  simpa using w\n#align cokernel_funext cokernel_funext\n\n"}