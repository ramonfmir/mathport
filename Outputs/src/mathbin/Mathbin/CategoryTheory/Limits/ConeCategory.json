{"to_eq_desc_cocone_morphism":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\ntheorem is_initial.to_eq_desc_cocone_morphism {F : «expr ⥤ » J C} {c : cocone F} (hc : is_initial c) (s : cocone F) :\n    is_initial.to hc s = ((cocone.is_colimit_equiv_is_initial _).symm hc).desc_cocone_morphism s := by\n  convert (is_colimit.desc_cocone_morphism_eq_is_initial_to _ s).symm\n#align is_initial.to_eq_desc_cocone_morphism is_initial.to_eq_desc_cocone_morphism\n\n",
 "lift_cone_morphism_eq_is_terminal_from":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\ntheorem is_limit.lift_cone_morphism_eq_is_terminal_from {F : «expr ⥤ » J C} {c : cone F} (hc : is_limit c)\n    (s : cone F) : hc.lift_cone_morphism s = is_terminal.from (cone.is_limit_equiv_is_terminal _ hc) _ :=\n  rfl\n#align is_limit.lift_cone_morphism_eq_is_terminal_from is_limit.lift_cone_morphism_eq_is_terminal_from\n\n",
 "has_limits_of_shape_iff_is_left_adjoint_const":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\ntheorem has_limits_of_shape_iff_is_left_adjoint_const :\n    has_limits_of_shape J C ↔ nonempty (is_left_adjoint (const J : «expr ⥤ » C _)) :=\n  calc\n    has_limits_of_shape J C ↔ ∀ F : «expr ⥤ » J C, has_limit F :=\n      ⟨fun h => h.has_limit, fun h => has_limits_of_shape.mk⟩\n    _ ↔ ∀ F : «expr ⥤ » J C, has_terminal (cone F) := forall_congr' has_limit_iff_has_terminal_cone\n    _ ↔ ∀ F : «expr ⥤ » J C, has_terminal (costructured_arrow (const J) F) :=\n      forall_congr' fun F => (cone.equiv_costructured_arrow F).has_terminal_iff\n    _ ↔ nonempty (is_left_adjoint (const J : «expr ⥤ » C _)) :=\n      nonempty_is_left_adjoint_iff_has_terminal_costructured_arrow.symm\n    \n#align has_limits_of_shape_iff_is_left_adjoint_const has_limits_of_shape_iff_is_left_adjoint_const\n\n",
 "has_limit_iff_has_terminal_cone":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤_ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/-\nCopyright (c) 2021 Andrew Yang. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Andrew Yang\n-/\ntheorem has_limit_iff_has_terminal_cone (F : «expr ⥤ » J C) : has_limit F ↔ has_terminal (cone F) :=\n  ⟨fun h => (cone.is_limit_equiv_is_terminal _ (limit.is_limit F)).has_terminal, fun h =>\n    ⟨⟨⟨«expr⊤_ » _, (cone.is_limit_equiv_is_terminal _).symm terminal_is_terminal⟩⟩⟩⟩\n#align has_limit_iff_has_terminal_cone has_limit_iff_has_terminal_cone\n\n",
 "has_colimits_of_shape_iff_is_right_adjoint_const":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\ntheorem has_colimits_of_shape_iff_is_right_adjoint_const :\n    has_colimits_of_shape J C ↔ nonempty (is_right_adjoint (const J : «expr ⥤ » C _)) :=\n  calc\n    has_colimits_of_shape J C ↔ ∀ F : «expr ⥤ » J C, has_colimit F :=\n      ⟨fun h => h.has_colimit, fun h => has_colimits_of_shape.mk⟩\n    _ ↔ ∀ F : «expr ⥤ » J C, has_initial (cocone F) := forall_congr' has_colimit_iff_has_initial_cocone\n    _ ↔ ∀ F : «expr ⥤ » J C, has_initial (structured_arrow F (const J)) :=\n      forall_congr' fun F => (cocone.equiv_structured_arrow F).has_initial_iff\n    _ ↔ nonempty (is_right_adjoint (const J : «expr ⥤ » C _)) :=\n      nonempty_is_right_adjoint_iff_has_initial_structured_arrow.symm\n    \n#align has_colimits_of_shape_iff_is_right_adjoint_const has_colimits_of_shape_iff_is_right_adjoint_const\n\n",
 "has_colimit_iff_has_initial_cocone":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥_ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\ntheorem has_colimit_iff_has_initial_cocone (F : «expr ⥤ » J C) : has_colimit F ↔ has_initial (cocone F) :=\n  ⟨fun h => (cocone.is_colimit_equiv_is_initial _ (colimit.is_colimit F)).has_initial, fun h =>\n    ⟨⟨⟨«expr⊥_ » _, (cocone.is_colimit_equiv_is_initial _).symm initial_is_initial⟩⟩⟩⟩\n#align has_colimit_iff_has_initial_cocone has_colimit_iff_has_initial_cocone\n\n",
 "from_eq_lift_cone_morphism":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\ntheorem is_terminal.from_eq_lift_cone_morphism {F : «expr ⥤ » J C} {c : cone F} (hc : is_terminal c) (s : cone F) :\n    is_terminal.from hc s = ((cone.is_limit_equiv_is_terminal _).symm hc).lift_cone_morphism s := by\n  convert (is_limit.lift_cone_morphism_eq_is_terminal_from _ s).symm\n#align is_terminal.from_eq_lift_cone_morphism is_terminal.from_eq_lift_cone_morphism\n\n",
 "desc_cocone_morphism_eq_is_initial_to":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\ntheorem is_colimit.desc_cocone_morphism_eq_is_initial_to {F : «expr ⥤ » J C} {c : cocone F} (hc : is_colimit c)\n    (s : cocone F) : hc.desc_cocone_morphism s = is_initial.to (cocone.is_colimit_equiv_is_initial _ hc) _ :=\n  rfl\n#align is_colimit.desc_cocone_morphism_eq_is_initial_to is_colimit.desc_cocone_morphism_eq_is_initial_to\n\n"}