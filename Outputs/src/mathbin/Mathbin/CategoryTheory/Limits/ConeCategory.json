{"to_eq_desc_cocone_morphism":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\ntheorem is_initial.to_eq_desc_cocone_morphism {F : «expr ⥤ » J C} {c : Cocone F} (hc : IsInitial c) (s : Cocone F) :\n    IsInitial.to hc s = ((Cocone.isColimitEquivIsInitial _).symm hc).desc_cocone_morphism s := by\n  convert(is_colimit.desc_cocone_morphism_eq_is_initial_to _ s).symm\n#align is_initial.to_eq_desc_cocone_morphism is_initial.to_eq_desc_cocone_morphism\n\n",
 "lift_cone_morphism_eq_is_terminal_from":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\ntheorem is_limit.lift_cone_morphism_eq_is_terminal_from {F : «expr ⥤ » J C} {c : Cone F} (hc : IsLimit c) (s : Cone F) :\n    hc.lift_cone_morphism s = IsTerminal.from (Cone.isLimitEquivIsTerminal _ hc) _ :=\n  rfl\n#align is_limit.lift_cone_morphism_eq_is_terminal_from is_limit.lift_cone_morphism_eq_is_terminal_from\n\n",
 "has_limits_of_shape_iff_is_left_adjoint_const":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\ntheorem has_limits_of_shape_iff_is_left_adjoint_const :\n    HasLimitsOfShape J C ↔ Nonempty (IsLeftAdjoint (const J : «expr ⥤ » C _)) :=\n  calc\n    HasLimitsOfShape J C ↔ ∀ F : «expr ⥤ » J C, HasLimit F := ⟨fun h => h.has_limit, fun h => has_limits_of_shape.mk⟩\n    _ ↔ ∀ F : «expr ⥤ » J C, HasTerminal (Cone F) := (forall_congr' hasLimit_iff_hasTerminal_cone)\n    _ ↔ ∀ F : «expr ⥤ » J C, HasTerminal (CostructuredArrow (const J) F) :=\n      (forall_congr' fun F => (Cone.equivCostructuredArrow F).has_terminal_iff)\n    _ ↔ Nonempty (IsLeftAdjoint (const J : «expr ⥤ » C _)) :=\n      nonempty_isLeftAdjoint_iff_hasTerminal_costructuredArrow.symm\n    \n#align has_limits_of_shape_iff_is_left_adjoint_const has_limits_of_shape_iff_is_left_adjoint_const\n\n",
 "has_limit_iff_has_terminal_cone":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤_ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/-\nCopyright (c) 2021 Andrew Yang. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Andrew Yang\n-/\ntheorem has_limit_iff_has_terminal_cone (F : «expr ⥤ » J C) : HasLimit F ↔ HasTerminal (Cone F) :=\n  ⟨fun h => (cone.is_limit_equiv_is_terminal _ (limit.is_limit F)).has_terminal, fun h =>\n    ⟨⟨⟨«expr⊤_ » _, (cone.is_limit_equiv_is_terminal _).symm terminal_is_terminal⟩⟩⟩⟩\n#align has_limit_iff_has_terminal_cone has_limit_iff_has_terminal_cone\n\n",
 "has_colimits_of_shape_iff_is_right_adjoint_const":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\ntheorem has_colimits_of_shape_iff_is_right_adjoint_const :\n    HasColimitsOfShape J C ↔ Nonempty (IsRightAdjoint (const J : «expr ⥤ » C _)) :=\n  calc\n    HasColimitsOfShape J C ↔ ∀ F : «expr ⥤ » J C, HasColimit F :=\n      ⟨fun h => h.has_colimit, fun h => has_colimits_of_shape.mk⟩\n    _ ↔ ∀ F : «expr ⥤ » J C, HasInitial (Cocone F) := (forall_congr' hasColimit_iff_hasInitial_cocone)\n    _ ↔ ∀ F : «expr ⥤ » J C, HasInitial (StructuredArrow F (const J)) :=\n      (forall_congr' fun F => (Cocone.equivStructuredArrow F).has_initial_iff)\n    _ ↔ Nonempty (IsRightAdjoint (const J : «expr ⥤ » C _)) :=\n      nonempty_isRightAdjoint_iff_hasInitial_structuredArrow.symm\n    \n#align has_colimits_of_shape_iff_is_right_adjoint_const has_colimits_of_shape_iff_is_right_adjoint_const\n\n",
 "has_colimit_iff_has_initial_cocone":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥_ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\ntheorem has_colimit_iff_has_initial_cocone (F : «expr ⥤ » J C) : HasColimit F ↔ HasInitial (Cocone F) :=\n  ⟨fun h => (cocone.is_colimit_equiv_is_initial _ (colimit.is_colimit F)).has_initial, fun h =>\n    ⟨⟨⟨«expr⊥_ » _, (cocone.is_colimit_equiv_is_initial _).symm initial_is_initial⟩⟩⟩⟩\n#align has_colimit_iff_has_initial_cocone has_colimit_iff_has_initial_cocone\n\n",
 "from_eq_lift_cone_morphism":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\ntheorem is_terminal.from_eq_lift_cone_morphism {F : «expr ⥤ » J C} {c : Cone F} (hc : IsTerminal c) (s : Cone F) :\n    IsTerminal.from hc s = ((Cone.isLimitEquivIsTerminal _).symm hc).lift_cone_morphism s := by\n  convert(is_limit.lift_cone_morphism_eq_is_terminal_from _ s).symm\n#align is_terminal.from_eq_lift_cone_morphism is_terminal.from_eq_lift_cone_morphism\n\n",
 "desc_cocone_morphism_eq_is_initial_to":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\ntheorem is_colimit.desc_cocone_morphism_eq_is_initial_to {F : «expr ⥤ » J C} {c : Cocone F} (hc : IsColimit c)\n    (s : Cocone F) : hc.desc_cocone_morphism s = IsInitial.to (Cocone.isColimitEquivIsInitial _ hc) _ :=\n  rfl\n#align is_colimit.desc_cocone_morphism_eq_is_initial_to is_colimit.desc_cocone_morphism_eq_is_initial_to\n\n"}