{"ι_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem ι_map {F G : «expr ⥤ » J C} {c : Cocone F} (hc : IsColimit c) (d : Cocone G) (α : «expr ⟶ » F G) (j : J) :\n    «expr ≫ » (c.ι.app j) (IsColimit.map hc d α) = «expr ≫ » (α.app j) (d.ι.app j) :=\n  fac _ _ _\n#align ι_map ι_map\n\n",
 "uniq_cone_morphism":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n-- Repackaging the definition in terms of cone morphisms.\ntheorem uniq_cone_morphism {s t : Cone F} (h : IsLimit t) {f f' : «expr ⟶ » s t} : f = f' :=\n  have : ∀ {g : «expr ⟶ » s t}, g = h.lift_cone_morphism s := by intro g <;> ext <;> exact h.uniq _ _ g.w\n  this.trans this.symm\n#align uniq_cone_morphism uniq_cone_morphism\n\n",
 "uniq_cocone_morphism":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n-- Repackaging the definition in terms of cocone morphisms.\ntheorem uniq_cocone_morphism {s t : Cocone F} (h : IsColimit t) {f f' : «expr ⟶ » t s} : f = f' :=\n  have : ∀ {g : «expr ⟶ » t s}, g = h.desc_cocone_morphism s := by intro g <;> ext <;> exact h.uniq _ _ g.w\n  this.trans this.symm\n#align uniq_cocone_morphism uniq_cocone_morphism\n\n",
 "of_iso_limit_lift":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≅ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp]\ntheorem of_iso_limit_lift {r t : Cone F} (P : IsLimit r) (i : «expr ≅ » r t) (s) :\n    (P.of_iso_limit i).lift s = «expr ≫ » (P.lift s) i.hom.hom :=\n  rfl\n#align of_iso_limit_lift of_iso_limit_lift\n\n",
 "of_iso_colimit_desc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≅ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp]\ntheorem of_iso_colimit_desc {r t : Cocone F} (P : IsColimit r) (i : «expr ≅ » r t) (s) :\n    (P.of_iso_colimit i).desc s = «expr ≫ » i.inv.hom (P.desc s) :=\n  rfl\n#align of_iso_colimit_desc of_iso_colimit_desc\n\n",
 "of_cone_equiv_symm_apply_desc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≌ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp]\ntheorem of_cone_equiv_symm_apply_desc {D : Type u₄} [Category.{v₄} D] {G : «expr ⥤ » K D}\n    (h : «expr ≌ » (Cone G) (Cone F)) {c : Cone G} (P : IsLimit c) (s) :\n    ((ofConeEquiv h).symm P).lift s =\n      «expr ≫ » (h.counit_iso.inv.app s).hom (h.functor.map (P.lift_cone_morphism (h.inverse.obj s))).hom :=\n  rfl\n#align of_cone_equiv_symm_apply_desc of_cone_equiv_symm_apply_desc\n\n",
 "of_cone_equiv_apply_desc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≌ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp]\ntheorem of_cone_equiv_apply_desc {D : Type u₄} [Category.{v₄} D] {G : «expr ⥤ » K D} (h : «expr ≌ » (Cone G) (Cone F))\n    {c : Cone G} (P : IsLimit (h.functor.obj c)) (s) :\n    (ofConeEquiv h P).lift s =\n      «expr ≫ » («expr ≫ » (h.unit_iso.hom.app s).hom (h.functor.inv.map (P.lift_cone_morphism (h.functor.obj s))).hom)\n        (h.unit_iso.inv.app c).hom :=\n  rfl\n#align of_cone_equiv_apply_desc of_cone_equiv_apply_desc\n\n",
 "of_cocone_equiv_symm_apply_desc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≌ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp]\ntheorem of_cocone_equiv_symm_apply_desc {D : Type u₄} [Category.{v₄} D] {G : «expr ⥤ » K D}\n    (h : «expr ≌ » (Cocone G) (Cocone F)) {c : Cocone G} (P : IsColimit c) (s) :\n    ((ofCoconeEquiv h).symm P).desc s =\n      «expr ≫ » (h.functor.map (P.desc_cocone_morphism (h.inverse.obj s))).hom (h.counit.app s).hom :=\n  rfl\n#align of_cocone_equiv_symm_apply_desc of_cocone_equiv_symm_apply_desc\n\n",
 "of_cocone_equiv_apply_desc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≌ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp]\ntheorem of_cocone_equiv_apply_desc {D : Type u₄} [Category.{v₄} D] {G : «expr ⥤ » K D}\n    (h : «expr ≌ » (Cocone G) (Cocone F)) {c : Cocone G} (P : IsColimit (h.functor.obj c)) (s) :\n    (ofCoconeEquiv h P).desc s =\n      «expr ≫ » (h.unit.app c).hom\n        («expr ≫ » (h.inverse.map (P.desc_cocone_morphism (h.functor.obj s))).hom (h.unit_inv.app s).hom) :=\n  rfl\n#align of_cocone_equiv_apply_desc of_cocone_equiv_apply_desc\n\n",
 "map_π":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/-\nCopyright (c) 2018 Scott Morrison. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Reid Barton, Mario Carneiro, Scott Morrison, Floris van Doorn\n-/\n-- declare the `v`'s first; see `category_theory.category` for an explanation\n@[simp, reassoc.1]\ntheorem map_π {F G : «expr ⥤ » J C} (c : Cone F) {d : Cone G} (hd : IsLimit d) (α : «expr ⟶ » F G) (j : J) :\n    «expr ≫ » (hd.map c α) (d.π.app j) = «expr ≫ » (c.π.app j) (α.app j) :=\n  fac _ _ _\n#align map_π map_π\n\n",
 "lift_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\ntheorem lift_self {c : Cone F} (t : IsLimit c) : t.lift c = («expr𝟙») c.X :=\n  (t.uniq _ _ fun j => id_comp _).symm\n#align lift_self lift_self\n\n",
 "lift_comp_cone_points_iso_of_nat_iso_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≅ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[reassoc.1]\ntheorem lift_comp_cone_points_iso_of_nat_iso_inv {F G : «expr ⥤ » J C} {r s : Cone G} {t : Cone F} (P : IsLimit t)\n    (Q : IsLimit s) (w : «expr ≅ » F G) : «expr ≫ » (Q.lift r) (conePointsIsoOfNatIso P Q w).inv = P.map r w.inv :=\n  P.hom_ext (by simp)\n#align lift_comp_cone_points_iso_of_nat_iso_inv lift_comp_cone_points_iso_of_nat_iso_inv\n\n",
 "lift_comp_cone_points_iso_of_nat_iso_hom":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≅ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[reassoc.1]\ntheorem lift_comp_cone_points_iso_of_nat_iso_hom {F G : «expr ⥤ » J C} {r s : Cone F} {t : Cone G} (P : IsLimit s)\n    (Q : IsLimit t) (w : «expr ≅ » F G) : «expr ≫ » (P.lift r) (conePointsIsoOfNatIso P Q w).hom = Q.map r w.hom :=\n  Q.hom_ext (by simp)\n#align lift_comp_cone_points_iso_of_nat_iso_hom lift_comp_cone_points_iso_of_nat_iso_hom\n\n",
 "lift_comp_cone_point_unique_up_to_iso_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem lift_comp_cone_point_unique_up_to_iso_inv {r s t : Cone F} (P : IsLimit s) (Q : IsLimit t) :\n    «expr ≫ » (Q.lift r) (conePointUniqueUpToIso P Q).inv = P.lift r :=\n  P.uniq _ _ (by simp)\n#align lift_comp_cone_point_unique_up_to_iso_inv lift_comp_cone_point_unique_up_to_iso_inv\n\n",
 "lift_comp_cone_point_unique_up_to_iso_hom":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem lift_comp_cone_point_unique_up_to_iso_hom {r s t : Cone F} (P : IsLimit s) (Q : IsLimit t) :\n    «expr ≫ » (P.lift r) (conePointUniqueUpToIso P Q).hom = Q.lift r :=\n  Q.uniq _ _ (by simp)\n#align lift_comp_cone_point_unique_up_to_iso_hom lift_comp_cone_point_unique_up_to_iso_hom\n\n",
 "hom_of_cone_of_hom":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n@[simp]\ntheorem hom_of_cone_of_hom {Y : C} (f : «expr ⟶ » Y X) : homOfCone h (coneOfHom h f) = f :=\n  congr_arg ULift.down (congr_fun (congr_fun (congr_arg nat_trans.app h.hom_inv_id) (op Y)) ⟨f⟩ : _)\n#align hom_of_cone_of_hom hom_of_cone_of_hom\n\n",
 "hom_of_cocone_of_hom":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n@[simp]\ntheorem hom_of_cocone_of_hom {Y : C} (f : «expr ⟶ » X Y) : homOfCocone h (coconeOfHom h f) = f :=\n  congr_arg ULift.down (congr_fun (congr_fun (congr_arg nat_trans.app h.hom_inv_id) Y) ⟨f⟩ : _)\n#align hom_of_cocone_of_hom hom_of_cocone_of_hom\n\n",
 "hom_lift":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem hom_lift (h : IsLimit t) {W : C} (m : «expr ⟶ » W t.X) :\n    m =\n      h.lift\n        { X := W\n          π := { app := fun b => «expr ≫ » m (t.π.app b) } } :=\n  h.uniq\n    { X := W\n      π := { app := fun b => «expr ≫ » m (t.π.app b) } } m fun b => rfl\n#align hom_lift hom_lift\n\n",
 "hom_iso_hom":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n@[simp]\ntheorem hom_iso_hom (h : IsColimit t) {W : C} (f : ULift («expr ⟶ » t.X W)) :\n    (IsColimit.homIso h W).hom f = (t.extend f.down).ι :=\n  rfl\n#align hom_iso_hom hom_iso_hom\n\n",
 "hom_is_iso":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/-- Any cocone morphism between colimit cocones is an isomorphism. -/\ntheorem hom_is_iso {s t : Cocone F} (P : IsColimit s) (Q : IsColimit t) (f : «expr ⟶ » s t) : IsIso f :=\n  ⟨⟨Q.desc_cocone_morphism s, ⟨P.uniq_cocone_morphism, Q.uniq_cocone_morphism⟩⟩⟩\n#align hom_is_iso hom_is_iso\n\n",
 "hom_ext":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/-- Two morphisms out of a colimit are equal if their compositions with\n  each cocone morphism are equal. -/\ntheorem hom_ext (h : IsColimit t) {W : C} {f f' : «expr ⟶ » t.X W}\n    (w : ∀ j, «expr ≫ » (t.ι.app j) f = «expr ≫ » (t.ι.app j) f') : f = f' := by\n  rw [h.hom_desc f, h.hom_desc f'] <;> congr <;> exact funext w\n#align hom_ext hom_ext\n\n",
 "hom_desc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem hom_desc (h : IsColimit t) {W : C} (m : «expr ⟶ » t.X W) :\n    m =\n      h.desc\n        { X := W\n          ι :=\n            { app := fun b => «expr ≫ » (t.ι.app b) m\n              naturality' := by intros <;> erw [← assoc, t.ι.naturality, comp_id, comp_id] } } :=\n  h.uniq\n    { X := W\n      ι :=\n        { app := fun b => «expr ≫ » (t.ι.app b) m\n          naturality' := _ } }\n    m fun b => rfl\n#align hom_desc hom_desc\n\n",
 "exists_unique":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/-- Restating the definition of a colimit cocone in terms of the ∃! operator. -/\ntheorem exists_unique {t : Cocone F} (h : IsColimit t) (s : Cocone F) :\n    ∃! d : «expr ⟶ » t.X s.X, ∀ j, «expr ≫ » (t.ι.app j) d = s.ι.app j :=\n  ⟨h.desc s, h.fac s, h.uniq s⟩\n#align exists_unique exists_unique\n\n",
 "equiv_iso_limit_symm_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≅ » -/\n@[simp]\ntheorem equiv_iso_limit_symm_apply {r t : Cone F} (i : «expr ≅ » r t) (P : IsLimit t) :\n    (equivIsoLimit i).symm P = P.of_iso_limit i.symm :=\n  rfl\n#align equiv_iso_limit_symm_apply equiv_iso_limit_symm_apply\n\n",
 "equiv_iso_limit_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≅ » -/\n@[simp]\ntheorem equiv_iso_limit_apply {r t : Cone F} (i : «expr ≅ » r t) (P : IsLimit r) :\n    equivIsoLimit i P = P.of_iso_limit i :=\n  rfl\n#align equiv_iso_limit_apply equiv_iso_limit_apply\n\n",
 "equiv_iso_colimit_symm_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≅ » -/\n@[simp]\ntheorem equiv_iso_colimit_symm_apply {r t : Cocone F} (i : «expr ≅ » r t) (P : IsColimit t) :\n    (equivIsoColimit i).symm P = P.of_iso_colimit i.symm :=\n  rfl\n#align equiv_iso_colimit_symm_apply equiv_iso_colimit_symm_apply\n\n",
 "equiv_iso_colimit_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≅ » -/\n@[simp]\ntheorem equiv_iso_colimit_apply {r t : Cocone F} (i : «expr ≅ » r t) (P : IsColimit r) :\n    equivIsoColimit i P = P.of_iso_colimit i :=\n  rfl\n#align equiv_iso_colimit_apply equiv_iso_colimit_apply\n\n",
 "desc_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n@[simp]\ntheorem desc_self {t : Cocone F} (h : IsColimit t) : h.desc t = («expr𝟙») t.X :=\n  (h.uniq _ _ fun j => comp_id _).symm\n#align desc_self desc_self\n\n",
 "cone_points_iso_of_nat_iso_inv_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≅ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[reassoc.1]\ntheorem cone_points_iso_of_nat_iso_inv_comp {F G : «expr ⥤ » J C} {s : Cone F} {t : Cone G} (P : IsLimit s)\n    (Q : IsLimit t) (w : «expr ≅ » F G) (j : J) :\n    «expr ≫ » (conePointsIsoOfNatIso P Q w).inv (s.π.app j) = «expr ≫ » (t.π.app j) (w.inv.app j) := by simp\n#align cone_points_iso_of_nat_iso_inv_comp cone_points_iso_of_nat_iso_inv_comp\n\n",
 "cone_points_iso_of_nat_iso_hom_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≅ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[reassoc.1]\ntheorem cone_points_iso_of_nat_iso_hom_comp {F G : «expr ⥤ » J C} {s : Cone F} {t : Cone G} (P : IsLimit s)\n    (Q : IsLimit t) (w : «expr ≅ » F G) (j : J) :\n    «expr ≫ » (conePointsIsoOfNatIso P Q w).hom (t.π.app j) = «expr ≫ » (s.π.app j) (w.hom.app j) := by simp\n#align cone_points_iso_of_nat_iso_hom_comp cone_points_iso_of_nat_iso_hom_comp\n\n",
 "cone_point_unique_up_to_iso_inv_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem cone_point_unique_up_to_iso_inv_comp {s t : Cone F} (P : IsLimit s) (Q : IsLimit t) (j : J) :\n    «expr ≫ » (conePointUniqueUpToIso P Q).inv (s.π.app j) = t.π.app j :=\n  (uniqueUpToIso P Q).inv.w _\n#align cone_point_unique_up_to_iso_inv_comp cone_point_unique_up_to_iso_inv_comp\n\n",
 "cone_point_unique_up_to_iso_hom_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem cone_point_unique_up_to_iso_hom_comp {s t : Cone F} (P : IsLimit s) (Q : IsLimit t) (j : J) :\n    «expr ≫ » (conePointUniqueUpToIso P Q).hom (t.π.app j) = s.π.app j :=\n  (uniqueUpToIso P Q).hom.w _\n#align cone_point_unique_up_to_iso_hom_comp cone_point_unique_up_to_iso_hom_comp\n\n",
 "cone_of_hom_of_cone":
 "@[simp]\ntheorem cone_of_hom_of_cone (s : Cone F) : coneOfHom h (homOfCone h s) = s :=\n  by\n  dsimp [cone_of_hom, hom_of_cone]; cases s; congr ; dsimp\n  convert congr_fun (congr_fun (congr_arg nat_trans.app h.inv_hom_id) (op s_X)) s_π\n  exact ulift.up_down _\n#align cone_of_hom_of_cone cone_of_hom_of_cone\n\n",
 "cone_of_hom_fac":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/-- If `F.cones` is represented by `X`, the cone corresponding to a morphism `f : Y ⟶ X` is\nthe limit cone extended by `f`. -/\ntheorem cone_of_hom_fac {Y : C} (f : «expr ⟶ » Y X) : coneOfHom h f = (limitCone h).extend f :=\n  by\n  dsimp [cone_of_hom, limit_cone, cone.extend]\n  congr with j\n  have t := congr_fun (h.hom.naturality f.op) ⟨(«expr𝟙») X⟩\n  dsimp at t\n  simp only [comp_id] at t\n  rw [congr_fun (congr_arg nat_trans.app t) j]\n  rfl\n#align cone_of_hom_fac cone_of_hom_fac\n\n",
 "cone_fac":
 "/-- If `F.cones` is represented by `X`, any cone is the extension of the limit cone by the\ncorresponding morphism. -/\ntheorem cone_fac (s : Cone F) : (limitCone h).extend (homOfCone h s) = s :=\n  by\n  rw [← cone_of_hom_of_cone h s]\n  conv_lhs => simp only [hom_of_cone_of_hom]\n  apply (cone_of_hom_fac _ _).symm\n#align cone_fac cone_fac\n\n",
 "comp_cocone_points_iso_of_nat_iso_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≅ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[reassoc.1]\ntheorem comp_cocone_points_iso_of_nat_iso_inv {F G : «expr ⥤ » J C} {s : Cocone F} {t : Cocone G} (P : IsColimit s)\n    (Q : IsColimit t) (w : «expr ≅ » F G) (j : J) :\n    «expr ≫ » (t.ι.app j) (coconePointsIsoOfNatIso P Q w).inv = «expr ≫ » (w.inv.app j) (s.ι.app j) := by simp\n#align comp_cocone_points_iso_of_nat_iso_inv comp_cocone_points_iso_of_nat_iso_inv\n\n",
 "comp_cocone_points_iso_of_nat_iso_hom":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≅ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[reassoc.1]\ntheorem comp_cocone_points_iso_of_nat_iso_hom {F G : «expr ⥤ » J C} {s : Cocone F} {t : Cocone G} (P : IsColimit s)\n    (Q : IsColimit t) (w : «expr ≅ » F G) (j : J) :\n    «expr ≫ » (s.ι.app j) (coconePointsIsoOfNatIso P Q w).hom = «expr ≫ » (w.hom.app j) (t.ι.app j) := by simp\n#align comp_cocone_points_iso_of_nat_iso_hom comp_cocone_points_iso_of_nat_iso_hom\n\n",
 "comp_cocone_point_unique_up_to_iso_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem comp_cocone_point_unique_up_to_iso_inv {s t : Cocone F} (P : IsColimit s) (Q : IsColimit t) (j : J) :\n    «expr ≫ » (t.ι.app j) (coconePointUniqueUpToIso P Q).inv = s.ι.app j :=\n  (uniqueUpToIso P Q).inv.w _\n#align comp_cocone_point_unique_up_to_iso_inv comp_cocone_point_unique_up_to_iso_inv\n\n",
 "comp_cocone_point_unique_up_to_iso_hom":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem comp_cocone_point_unique_up_to_iso_hom {s t : Cocone F} (P : IsColimit s) (Q : IsColimit t) (j : J) :\n    «expr ≫ » (s.ι.app j) (coconePointUniqueUpToIso P Q).hom = t.ι.app j :=\n  (uniqueUpToIso P Q).hom.w _\n#align comp_cocone_point_unique_up_to_iso_hom comp_cocone_point_unique_up_to_iso_hom\n\n",
 "cocone_points_iso_of_nat_iso_inv_desc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≅ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[reassoc.1]\ntheorem cocone_points_iso_of_nat_iso_inv_desc {F G : «expr ⥤ » J C} {s : Cocone G} {r t : Cocone F} (P : IsColimit t)\n    (Q : IsColimit s) (w : «expr ≅ » F G) : «expr ≫ » (coconePointsIsoOfNatIso P Q w).inv (P.desc r) = Q.map _ w.inv :=\n  Q.hom_ext (by simp)\n#align cocone_points_iso_of_nat_iso_inv_desc cocone_points_iso_of_nat_iso_inv_desc\n\n",
 "cocone_points_iso_of_nat_iso_hom_desc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≅ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[reassoc.1]\ntheorem cocone_points_iso_of_nat_iso_hom_desc {F G : «expr ⥤ » J C} {s : Cocone F} {r t : Cocone G} (P : IsColimit s)\n    (Q : IsColimit t) (w : «expr ≅ » F G) : «expr ≫ » (coconePointsIsoOfNatIso P Q w).hom (Q.desc r) = P.map _ w.hom :=\n  P.hom_ext (by simp)\n#align cocone_points_iso_of_nat_iso_hom_desc cocone_points_iso_of_nat_iso_hom_desc\n\n",
 "cocone_point_unique_up_to_iso_inv_desc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem cocone_point_unique_up_to_iso_inv_desc {r s t : Cocone F} (P : IsColimit s) (Q : IsColimit t) :\n    «expr ≫ » (coconePointUniqueUpToIso P Q).inv (P.desc r) = Q.desc r :=\n  Q.uniq _ _ (by simp)\n#align cocone_point_unique_up_to_iso_inv_desc cocone_point_unique_up_to_iso_inv_desc\n\n",
 "cocone_point_unique_up_to_iso_hom_desc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem cocone_point_unique_up_to_iso_hom_desc {r s t : Cocone F} (P : IsColimit s) (Q : IsColimit t) :\n    «expr ≫ » (coconePointUniqueUpToIso P Q).hom (Q.desc r) = P.desc r :=\n  P.uniq _ _ (by simp)\n#align cocone_point_unique_up_to_iso_hom_desc cocone_point_unique_up_to_iso_hom_desc\n\n",
 "cocone_of_hom_of_cocone":
 "@[simp]\ntheorem cocone_of_hom_of_cocone (s : Cocone F) : coconeOfHom h (homOfCocone h s) = s :=\n  by\n  dsimp [cocone_of_hom, hom_of_cocone]; cases s; congr ; dsimp\n  convert congr_fun (congr_fun (congr_arg nat_trans.app h.inv_hom_id) s_X) s_ι\n  exact ulift.up_down _\n#align cocone_of_hom_of_cocone cocone_of_hom_of_cocone\n\n",
 "cocone_of_hom_fac":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/-- If `F.cocones` is corepresented by `X`, the cocone corresponding to a morphism `f : Y ⟶ X` is\nthe colimit cocone extended by `f`. -/\ntheorem cocone_of_hom_fac {Y : C} (f : «expr ⟶ » X Y) : coconeOfHom h f = (colimitCocone h).extend f :=\n  by\n  dsimp [cocone_of_hom, colimit_cocone, cocone.extend]\n  congr with j\n  have t := congr_fun (h.hom.naturality f) ⟨(«expr𝟙») X⟩\n  dsimp at t\n  simp only [id_comp] at t\n  rw [congr_fun (congr_arg nat_trans.app t) j]\n  rfl\n#align cocone_of_hom_fac cocone_of_hom_fac\n\n",
 "cocone_fac":
 "/-- If `F.cocones` is corepresented by `X`, any cocone is the extension of the colimit cocone by the\ncorresponding morphism. -/\ntheorem cocone_fac (s : Cocone F) : (colimitCocone h).extend (homOfCocone h s) = s :=\n  by\n  rw [← cocone_of_hom_of_cocone h s]\n  conv_lhs => simp only [hom_of_cocone_of_hom]\n  apply (cocone_of_hom_fac _ _).symm\n#align cocone_fac cocone_fac\n\n"}