{"Œπ_colimit_limit_iso_limit_œÄ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚•§ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚•§ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚â´ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚â´ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚â´ ¬ª -/\n@[simp, reassoc.1]\ntheorem Œπ_colimit_limit_iso_limit_œÄ (F : ¬´expr ‚•§ ¬ª J (¬´expr ‚•§ ¬ª K C)) (a) (b) :\n    ¬´expr ‚â´ ¬ª (colimit.Œπ (limit F) a) (¬´expr ‚â´ ¬ª (colimit_limit_iso F).hom (limit.œÄ (colimit F.flip) b)) =\n      ¬´expr ‚â´ ¬ª ((limit.œÄ F b).app a) ((colimit.Œπ F.flip a).app b) :=\n  by\n  dsimp [colimit_limit_iso]\n  simp only [functor.map_cone_œÄ_app, iso.symm_hom, limits.limit.cone_point_unique_up_to_iso_hom_comp_assoc,\n    limits.limit.cone_œÄ, limits.colimit.Œπ_map_assoc, limits.colimit_flip_iso_comp_colim_inv_app, assoc,\n    limits.has_limit.iso_of_nat_iso_hom_œÄ]\n  congr 1\n  simp only [‚Üê category.assoc, iso.comp_inv_eq, limits.colimit_obj_iso_colimit_comp_evaluation_Œπ_app_hom,\n    limits.has_colimit.iso_of_nat_iso_Œπ_hom, nat_iso.of_components_hom_app]\n  dsimp\n  simp\n#align Œπ_colimit_limit_iso_limit_œÄ Œπ_colimit_limit_iso_limit_œÄ\n\n",
 "colimit_limit_to_limit_colimit_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚ãô ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚ãô ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚ü∂ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚ü∂ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´exprùüô¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚ü∂ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚ü∂ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚â´ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´exprùüô¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚ü∂ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´exprùüô¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚ü∂ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚ü∂ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚ü∂ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚ü∂ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚ü∂ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚ü∂ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚ü∂ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´exprùüô¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚â´ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚ü∂ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚â´ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚ü∂ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚ü∂ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚ü∂ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚ü∂ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚ü∂ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚ü∂ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚ü∂ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚ü∂ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚â´ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚â´ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚ãô ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚ãô ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´exprùüô¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚â´ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚â´ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´exprùüô¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´exprùüô¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚ü∂ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚â´ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚â´ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´exprùüô¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´exprùüô¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚ü∂ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚â´ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚â´ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚ü∂ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´exprùüô¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´exprùüô¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚ü∂ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚â´ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚ü∂ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´exprùüô¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚ü∂ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´exprùüô¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚â´ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚ü∂ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´exprùüô¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚â´ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚â´ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚ü∂ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´exprùüô¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚â´ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚â´ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´exprùüô¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´exprùüô¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚ü∂ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´exprùüô¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´exprùüô¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´exprùüô¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´exprùüô¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚â´ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚â´ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´exprùüô¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´exprùüô¬ª -/\n/-- This follows this proof from\n* Borceux, Handbook of categorical algebra 1, Theorem 2.13.4\nalthough with different names.\n-/\ntheorem colimit_limit_to_limit_colimit_surjective : function.surjective (colimit_limit_to_limit_colimit F) := by\n  classical\n    -- We begin with some element `x` in the limit (over J) over the colimits (over K),\n    intro x\n    -- This consists of some coherent family of elements in the various colimits,\n    -- and so our first task is to pick representatives of these elements.\n    have z := fun j => jointly_surjective'.{v, v} (limit.œÄ (¬´expr ‚ãô ¬ª (curry.obj F) limits.colim) j x)\n    -- `k : J ‚ü∂ K` records where the representative of the element in the `j`-th element of `x` lives\n    let k : J ‚Üí K := fun j => (z j).some\n    -- `y j : F.obj (j, k j)` is the representative\n    let y : ‚àÄ j, F.obj (j, k j) := fun j => (z j).some_spec.some\n    -- and we record that these representatives, when mapped back into the relevant colimits,\n    -- are actually the components of `x`.\n    have e : ‚àÄ j, colimit.Œπ ((curry.obj F).obj j) (k j) (y j) = limit.œÄ (¬´expr ‚ãô ¬ª (curry.obj F) limits.colim) j x :=\n      fun j => (z j).some_spec.some_spec\n    clear_value k y\n    -- A little tidying up of things we no longer need.\n    clear z\n    -- As a first step, we use that `K` is filtered to pick some point `k' : K` above all the `k j`\n    let k' : K := is_filtered.sup (finset.univ.image k) ‚àÖ\n    -- and name the morphisms as `g j : k j ‚ü∂ k'`.\n    have g : ‚àÄ j, ¬´expr ‚ü∂ ¬ª (k j) k' := fun j => is_filtered.to_sup (finset.univ.image k) ‚àÖ (by simp)\n    clear_value k'\n    -- Recalling that the components of `x`, which are indexed by `j : J`, are \"coherent\",\n    -- in other words preserved by morphisms in the `J` direction,\n    -- we see that for any morphism `f : j ‚ü∂ j'` in `J`,\n    -- the images of `y j` and `y j'`, when mapped to `F.obj (j', k')` respectively by\n    -- `(f, g j)` and `(ùüô j', g j')`, both represent the same element in the colimit.\n    have w :\n      ‚àÄ {j j' : J} (f : ¬´expr ‚ü∂ ¬ª j j'),\n        colimit.Œπ ((curry.obj F).obj j') k' (F.map (((¬´exprùüô¬ª) j', g j') : ¬´expr ‚ü∂ ¬ª (j', k j') (j', k')) (y j')) =\n          colimit.Œπ ((curry.obj F).obj j') k' (F.map ((f, g j) : ¬´expr ‚ü∂ ¬ª (j, k j) (j', k')) (y j)) :=\n      by\n      intro j j' f\n      have t :\n        (f, g j) =\n          (¬´expr ‚â´ ¬ª ((f, (¬´exprùüô¬ª) (k j)) : ¬´expr ‚ü∂ ¬ª (j, k j) (j', k j)) ((¬´exprùüô¬ª) j', g j) :\n            ¬´expr ‚ü∂ ¬ª (j, k j) (j', k')) :=\n        by simp only [id_comp, comp_id, prod_comp]\n      erw [colimit.w_apply', t, functor_to_types.map_comp_apply, colimit.w_apply', e, ‚Üê limit.w_apply' f, ‚Üê e]\n      simp\n    -- Because `K` is filtered, we can restate this as saying that\n    -- for each such `f`, there is some place to the right of `k'`\n    -- where these images of `y j` and `y j'` become equal.\n    simp_rw [colimit_eq_iff.{v, v}] at w\n    -- We take a moment to restate `w` more conveniently.\n    let kf : ‚àÄ {j j'} (f : ¬´expr ‚ü∂ ¬ª j j'), K := fun _ _ f => (w f).some\n    let gf : ‚àÄ {j j'} (f : ¬´expr ‚ü∂ ¬ª j j'), ¬´expr ‚ü∂ ¬ª k' (kf f) := fun _ _ f => (w f).some_spec.some\n    let hf : ‚àÄ {j j'} (f : ¬´expr ‚ü∂ ¬ª j j'), ¬´expr ‚ü∂ ¬ª k' (kf f) := fun _ _ f => (w f).some_spec.some_spec.some\n    have wf :\n      ‚àÄ {j j'} (f : ¬´expr ‚ü∂ ¬ª j j'),\n        F.map (((¬´exprùüô¬ª) j', ¬´expr ‚â´ ¬ª (g j') (gf f)) : ¬´expr ‚ü∂ ¬ª (j', k j') (j', kf f)) (y j') =\n          F.map ((f, ¬´expr ‚â´ ¬ª (g j) (hf f)) : ¬´expr ‚ü∂ ¬ª (j, k j) (j', kf f)) (y j) :=\n      fun j j' f =>\n      by\n      have q : ((curry.obj F).obj j').map (gf f) (F.map _ (y j')) = ((curry.obj F).obj j').map (hf f) (F.map _ (y j)) :=\n        (w f).some_spec.some_spec.some_spec\n      dsimp at q\n      simp_rw [‚Üê functor_to_types.map_comp_apply] at q\n      convert q <;> simp only [comp_id]\n    clear_value kf gf hf\n    -- and clean up some things that are no longer needed.\n    clear w\n    -- We're now ready to use the fact that `K` is filtered a second time,\n    -- picking some place to the right of all of\n    -- the morphisms `gf f : k' ‚ü∂ kh f` and `hf f : k' ‚ü∂ kf f`.\n    -- At this point we're relying on there being only finitely morphisms in `J`.\n    let O := (finset.univ.bUnion fun j => finset.univ.bUnion fun j' => finset.univ.image (@kf j j')) ‚à™ {k'}\n    have kfO : ‚àÄ {j j'} (f : ¬´expr ‚ü∂ ¬ª j j'), kf f ‚àà O := fun j j' f =>\n      finset.mem_union.mpr\n        (or.inl\n          (by\n            rw [Finset.mem_bunion·µ¢]\n            refine' ‚ü®j, finset.mem_univ j, _‚ü©\n            rw [Finset.mem_bunion·µ¢]\n            refine' ‚ü®j', finset.mem_univ j', _‚ü©\n            rw [Finset.mem_image]\n            refine' ‚ü®f, finset.mem_univ _, _‚ü©\n            rfl))\n    have k'O : k' ‚àà O := finset.mem_union.mpr (or.inr (finset.mem_singleton.mpr rfl))\n    let H : Finset (Œ£'(X Y : K)(mX : X ‚àà O)(mY : Y ‚àà O), ¬´expr ‚ü∂ ¬ª X Y) :=\n      finset.univ.bUnion fun j : J =>\n        finset.univ.bUnion fun j' : J =>\n          finset.univ.bUnion fun f : ¬´expr ‚ü∂ ¬ª j j' => {‚ü®k', kf f, k'O, kfO f, gf f‚ü©, ‚ü®k', kf f, k'O, kfO f, hf f‚ü©}\n    obtain ‚ü®k'', i', s'‚ü© := is_filtered.sup_exists O H\n    -- We then restate this slightly more conveniently, as a family of morphism `i f : kf f ‚ü∂ k''`,\n    -- satisfying `gf f ‚â´ i f = hf f' ‚â´ i f'`.\n    let i : ‚àÄ {j j'} (f : ¬´expr ‚ü∂ ¬ª j j'), ¬´expr ‚ü∂ ¬ª (kf f) k'' := fun j j' f => i' (kfO f)\n    have s :\n      ‚àÄ {j‚ÇÅ j‚ÇÇ j‚ÇÉ j‚ÇÑ} (f : ¬´expr ‚ü∂ ¬ª j‚ÇÅ j‚ÇÇ) (f' : ¬´expr ‚ü∂ ¬ª j‚ÇÉ j‚ÇÑ), ¬´expr ‚â´ ¬ª (gf f) (i f) = ¬´expr ‚â´ ¬ª (hf f') (i f') :=\n      by\n      intros\n      rw [s', s']\n      swap\n      exact k'O\n      swap\n      ¬∑ rw [Finset.mem_bunion·µ¢]\n        refine' ‚ü®j‚ÇÅ, finset.mem_univ _, _‚ü©\n        rw [Finset.mem_bunion·µ¢]\n        refine' ‚ü®j‚ÇÇ, finset.mem_univ _, _‚ü©\n        rw [Finset.mem_bunion·µ¢]\n        refine' ‚ü®f, finset.mem_univ _, _‚ü©\n        simp only [true_or_iff, eq_self_iff_true, and_self_iff, Finset.mem_insert, heq_iff_eq]\n      ¬∑ rw [Finset.mem_bunion·µ¢]\n        refine' ‚ü®j‚ÇÉ, finset.mem_univ _, _‚ü©\n        rw [Finset.mem_bunion·µ¢]\n        refine' ‚ü®j‚ÇÑ, finset.mem_univ _, _‚ü©\n        rw [Finset.mem_bunion·µ¢]\n        refine' ‚ü®f', finset.mem_univ _, _‚ü©\n        simp only [eq_self_iff_true, or_true_iff, and_self_iff, Finset.mem_insert, Finset.mem_singleton, heq_iff_eq]\n    clear_value i\n    clear s' i' H kfO k'O O\n    -- We're finally ready to construct the pre-image, and verify it really maps to `x`.\n    fconstructor\n    ¬∑ -- We construct the pre-image (which, recall is meant to be a point\n      -- in the colimit (over `K`) of the limits (over `J`)) via a representative at `k''`.\n      apply colimit.Œπ (¬´expr ‚ãô ¬ª (curry.obj (¬´expr ‚ãô ¬ª (swap K J) F)) limits.lim) k'' _\n      dsimp\n      -- This representative is meant to be an element of a limit,\n      -- so we need to construct a family of elements in `F.obj (j, k'')` for varying `j`,\n      -- then show that are coherent with respect to morphisms in the `j` direction.\n      apply limit.mk.{v, v}\n      swap\n      ¬∑-- We construct the elements as the images of the `y j`.\n        exact fun j =>\n          F.map\n            (‚ü®(¬´exprùüô¬ª) j, ¬´expr ‚â´ ¬ª (g j) (¬´expr ‚â´ ¬ª (gf ((¬´exprùüô¬ª) j)) (i ((¬´exprùüô¬ª) j)))‚ü© :\n              ¬´expr ‚ü∂ ¬ª (j, k j) (j, k''))\n            (y j)\n      ¬∑ -- After which it's just a calculation, using `s` and `wf`, to see they are coherent.\n        dsimp\n        intro j j' f\n        simp only [‚Üê functor_to_types.map_comp_apply, prod_comp, id_comp, comp_id]\n        calc\n          F.map ((f, ¬´expr ‚â´ ¬ª (g j) (¬´expr ‚â´ ¬ª (gf ((¬´exprùüô¬ª) j)) (i ((¬´exprùüô¬ª) j)))) : ¬´expr ‚ü∂ ¬ª (j, k j) (j', k''))\n                (y j) =\n              F.map ((f, ¬´expr ‚â´ ¬ª (g j) (¬´expr ‚â´ ¬ª (hf f) (i f))) : ¬´expr ‚ü∂ ¬ª (j, k j) (j', k'')) (y j) :=\n            by rw [s ((¬´exprùüô¬ª) j) f]\n          _ =\n              F.map (((¬´exprùüô¬ª) j', i f) : ¬´expr ‚ü∂ ¬ª (j', kf f) (j', k''))\n                (F.map ((f, ¬´expr ‚â´ ¬ª (g j) (hf f)) : ¬´expr ‚ü∂ ¬ª (j, k j) (j', kf f)) (y j)) :=\n            by rw [‚Üê functor_to_types.map_comp_apply, prod_comp, comp_id, assoc]\n          _ =\n              F.map (((¬´exprùüô¬ª) j', i f) : ¬´expr ‚ü∂ ¬ª (j', kf f) (j', k''))\n                (F.map (((¬´exprùüô¬ª) j', ¬´expr ‚â´ ¬ª (g j') (gf f)) : ¬´expr ‚ü∂ ¬ª (j', k j') (j', kf f)) (y j')) :=\n            by rw [‚Üê wf f]\n          _ =\n              F.map (((¬´exprùüô¬ª) j', ¬´expr ‚â´ ¬ª (g j') (¬´expr ‚â´ ¬ª (gf f) (i f))) : ¬´expr ‚ü∂ ¬ª (j', k j') (j', k''))\n                (y j') :=\n            by rw [‚Üê functor_to_types.map_comp_apply, prod_comp, id_comp, assoc]\n          _ =\n              F.map\n                (((¬´exprùüô¬ª) j', ¬´expr ‚â´ ¬ª (g j') (¬´expr ‚â´ ¬ª (gf ((¬´exprùüô¬ª) j')) (i ((¬´exprùüô¬ª) j')))) :\n                  ¬´expr ‚ü∂ ¬ª (j', k j') (j', k''))\n                (y j') :=\n            by rw [s f ((¬´exprùüô¬ª) j'), ‚Üê s ((¬´exprùüô¬ª) j') ((¬´exprùüô¬ª) j')]\n          \n    -- Finally we check that this maps to `x`.\n    ¬∑ -- We can do this componentwise:\n      apply limit_ext'\n      intro j\n      -- and as each component is an equation in a colimit, we can verify it by\n      -- pointing out the morphism which carries one representative to the other:\n      simp only [‚Üê e, colimit_eq_iff.{v, v}, curry_obj_obj_map, limit.œÄ_mk', bifunctor.map_id_comp, id.def,\n        types_comp_apply, limits.Œπ_colimit_limit_to_limit_colimit_œÄ_apply]\n      refine' ‚ü®k'', (¬´exprùüô¬ª) k'', ¬´expr ‚â´ ¬ª (g j) (¬´expr ‚â´ ¬ª (gf ((¬´exprùüô¬ª) j)) (i ((¬´exprùüô¬ª) j))), _‚ü©\n      simp only [bifunctor.map_id_comp, types_comp_apply, bifunctor.map_id, types_id_apply]\n#align colimit_limit_to_limit_colimit_surjective colimit_limit_to_limit_colimit_surjective\n\n",
 "colimit_limit_to_limit_colimit_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚ãô ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚ü∂ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚ü∂ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´exprùüô¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚ü∂ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚ãô ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´exprùüô¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚ü∂ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚ãô ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚ü∂ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚ü∂ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚ü∂ ¬ª -/\n/-\nCopyright (c) 2020 Scott Morrison. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Scott Morrison\n-/\n/-- This follows this proof from\n* Borceux, Handbook of categorical algebra 1, Theorem 2.13.4\n-/\ntheorem colimit_limit_to_limit_colimit_injective : function.injective (colimit_limit_to_limit_colimit F) := by\n  classical\n    cases nonempty_fintype J\n    -- Suppose we have two terms `x y` in the colimit (over `K`) of the limits (over `J`),\n    -- and that these have the same image under `colimit_limit_to_limit_colimit F`.\n    intro x y h\n    -- These elements of the colimit have representatives somewhere:\n    obtain ‚ü®kx, x, rfl‚ü© := jointly_surjective'.{v, v} x\n    obtain ‚ü®ky, y, rfl‚ü© := jointly_surjective'.{v, v} y\n    dsimp at x y\n    -- Since the images of `x` and `y` are equal in a limit, they are equal componentwise\n    -- (indexed by `j : J`),\n    replace h := fun j => congr_arg (limit.œÄ (¬´expr ‚ãô ¬ª (curry.obj F) colim) j) h\n    -- and they are equations in a filtered colimit,\n    -- so for each `j` we have some place `k j` to the right of both `kx` and `ky`\n    simp [colimit_eq_iff.{v, v}] at h\n    let k j := (h j).some\n    let f : ‚àÄ j, ¬´expr ‚ü∂ ¬ª kx (k j) := fun j => (h j).some_spec.some\n    let g : ‚àÄ j, ¬´expr ‚ü∂ ¬ª ky (k j) := fun j => (h j).some_spec.some_spec.some\n    -- where the images of the components of the representatives become equal:\n    have w :\n      ‚àÄ j,\n        F.map (((¬´exprùüô¬ª) j, f j) : ¬´expr ‚ü∂ ¬ª (j, kx) (j, k j))\n            (limit.œÄ ((curry.obj (¬´expr ‚ãô ¬ª (swap K J) F)).obj kx) j x) =\n          F.map (((¬´exprùüô¬ª) j, g j) : ¬´expr ‚ü∂ ¬ª (j, ky) (j, k j))\n            (limit.œÄ ((curry.obj (¬´expr ‚ãô ¬ª (swap K J) F)).obj ky) j y) :=\n      fun j => (h j).some_spec.some_spec.some_spec\n    -- We now use that `K` is filtered, picking some point to the right of all these\n    -- morphisms `f j` and `g j`.\n    let O : Finset K := finset.univ.image k ‚à™ {kx, ky}\n    have kxO : kx ‚àà O := finset.mem_union.mpr (or.inr (by simp))\n    have kyO : ky ‚àà O := finset.mem_union.mpr (or.inr (by simp))\n    have kjO : ‚àÄ j, k j ‚àà O := fun j => finset.mem_union.mpr (or.inl (by simp))\n    let H : Finset (Œ£'(X Y : K)(mX : X ‚àà O)(mY : Y ‚àà O), ¬´expr ‚ü∂ ¬ª X Y) :=\n      (finset.univ.image fun j : J => ‚ü®kx, k j, kxO, finset.mem_union.mpr (or.inl (by simp)), f j‚ü©) ‚à™\n        finset.univ.image fun j : J => ‚ü®ky, k j, kyO, finset.mem_union.mpr (or.inl (by simp)), g j‚ü©\n    obtain ‚ü®S, T, W‚ü© := is_filtered.sup_exists O H\n    have fH : ‚àÄ j, (‚ü®kx, k j, kxO, kjO j, f j‚ü© : Œ£'(X Y : K)(mX : X ‚àà O)(mY : Y ‚àà O), ¬´expr ‚ü∂ ¬ª X Y) ‚àà H := fun j =>\n      finset.mem_union.mpr\n        (or.inl\n          (by\n            simp only [true_and_iff, finset.mem_univ, eq_self_iff_true, exists_prop_of_true, Finset.mem_image,\n              heq_iff_eq]\n            refine' ‚ü®j, rfl, _‚ü©\n            simp only [heq_iff_eq]\n            exact ‚ü®rfl, rfl, rfl‚ü©))\n    have gH : ‚àÄ j, (‚ü®ky, k j, kyO, kjO j, g j‚ü© : Œ£'(X Y : K)(mX : X ‚àà O)(mY : Y ‚àà O), ¬´expr ‚ü∂ ¬ª X Y) ‚àà H := fun j =>\n      finset.mem_union.mpr\n        (or.inr\n          (by\n            simp only [true_and_iff, finset.mem_univ, eq_self_iff_true, exists_prop_of_true, Finset.mem_image,\n              heq_iff_eq]\n            refine' ‚ü®j, rfl, _‚ü©\n            simp only [heq_iff_eq]\n            exact ‚ü®rfl, rfl, rfl‚ü©))\n    -- Our goal is now an equation between equivalence classes of representatives of a colimit,\n    -- and so it suffices to show those representative become equal somewhere, in particular at `S`.\n    apply colimit_sound'.{v, v} (T kxO) (T kyO)\n    -- We can check if two elements of a limit (in `Type`) are equal by comparing them componentwise.\n    ext\n    -- Now it's just a calculation using `W` and `w`.\n    simp only [functor.comp_map, limit.map_œÄ_apply, curry_obj_map_app, swap_map]\n    rw [‚Üê W _ _ (fH j)]\n    rw [‚Üê W _ _ (gH j)]\n    simp [w]\n#align colimit_limit_to_limit_colimit_injective colimit_limit_to_limit_colimit_injective\n\n"}