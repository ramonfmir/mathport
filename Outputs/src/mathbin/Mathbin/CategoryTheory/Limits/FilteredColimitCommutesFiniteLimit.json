{"ι_colimit_limit_iso_limit_π":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem ι_colimit_limit_iso_limit_π (F : «expr ⥤ » J («expr ⥤ » K C)) (a) (b) :\n    «expr ≫ » (colimit.ι (limit F) a) («expr ≫ » (colimit_limit_iso F).hom (limit.π (colimit F.flip) b)) =\n      «expr ≫ » ((limit.π F b).app a) ((colimit.ι F.flip a).app b) :=\n  by\n  dsimp [colimit_limit_iso]\n  simp only [functor.map_cone_π_app, iso.symm_hom, limits.limit.cone_point_unique_up_to_iso_hom_comp_assoc,\n    limits.limit.cone_π, limits.colimit.ι_map_assoc, limits.colimit_flip_iso_comp_colim_inv_app, assoc,\n    limits.has_limit.iso_of_nat_iso_hom_π]\n  congr 1\n  simp only [← category.assoc, iso.comp_inv_eq, limits.colimit_obj_iso_colimit_comp_evaluation_ι_app_hom,\n    limits.has_colimit.iso_of_nat_iso_ι_hom, nat_iso.of_components_hom_app]\n  dsimp\n  simp\n#align ι_colimit_limit_iso_limit_π ι_colimit_limit_iso_limit_π\n\n",
 "colimit_limit_to_limit_colimit_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/-- This follows this proof from\n* Borceux, Handbook of categorical algebra 1, Theorem 2.13.4\nalthough with different names.\n-/\ntheorem colimit_limit_to_limit_colimit_surjective : function.surjective (colimit_limit_to_limit_colimit F) := by\n  classical\n    -- We begin with some element `x` in the limit (over J) over the colimits (over K),\n    intro x\n    -- This consists of some coherent family of elements in the various colimits,\n    -- and so our first task is to pick representatives of these elements.\n    have z := fun j => jointly_surjective'.{v, v} (limit.π («expr ⋙ » (curry.obj F) limits.colim) j x)\n    -- `k : J ⟶ K` records where the representative of the element in the `j`-th element of `x` lives\n    let k : J → K := fun j => (z j).some\n    -- `y j : F.obj (j, k j)` is the representative\n    let y : ∀ j, F.obj (j, k j) := fun j => (z j).some_spec.some\n    -- and we record that these representatives, when mapped back into the relevant colimits,\n    -- are actually the components of `x`.\n    have e : ∀ j, colimit.ι ((curry.obj F).obj j) (k j) (y j) = limit.π («expr ⋙ » (curry.obj F) limits.colim) j x :=\n      fun j => (z j).some_spec.some_spec\n    clear_value k y\n    -- A little tidying up of things we no longer need.\n    clear z\n    -- As a first step, we use that `K` is filtered to pick some point `k' : K` above all the `k j`\n    let k' : K := is_filtered.sup (finset.univ.image k) ∅\n    -- and name the morphisms as `g j : k j ⟶ k'`.\n    have g : ∀ j, «expr ⟶ » (k j) k' := fun j => is_filtered.to_sup (finset.univ.image k) ∅ (by simp)\n    clear_value k'\n    -- Recalling that the components of `x`, which are indexed by `j : J`, are \"coherent\",\n    -- in other words preserved by morphisms in the `J` direction,\n    -- we see that for any morphism `f : j ⟶ j'` in `J`,\n    -- the images of `y j` and `y j'`, when mapped to `F.obj (j', k')` respectively by\n    -- `(f, g j)` and `(𝟙 j', g j')`, both represent the same element in the colimit.\n    have w :\n      ∀ {j j' : J} (f : «expr ⟶ » j j'),\n        colimit.ι ((curry.obj F).obj j') k' (F.map (((«expr𝟙») j', g j') : «expr ⟶ » (j', k j') (j', k')) (y j')) =\n          colimit.ι ((curry.obj F).obj j') k' (F.map ((f, g j) : «expr ⟶ » (j, k j) (j', k')) (y j)) :=\n      by\n      intro j j' f\n      have t :\n        (f, g j) =\n          («expr ≫ » ((f, («expr𝟙») (k j)) : «expr ⟶ » (j, k j) (j', k j)) ((«expr𝟙») j', g j) :\n            «expr ⟶ » (j, k j) (j', k')) :=\n        by simp only [id_comp, comp_id, prod_comp]\n      erw [colimit.w_apply', t, functor_to_types.map_comp_apply, colimit.w_apply', e, ← limit.w_apply' f, ← e]\n      simp\n    -- Because `K` is filtered, we can restate this as saying that\n    -- for each such `f`, there is some place to the right of `k'`\n    -- where these images of `y j` and `y j'` become equal.\n    simp_rw [colimit_eq_iff.{v, v}] at w\n    -- We take a moment to restate `w` more conveniently.\n    let kf : ∀ {j j'} (f : «expr ⟶ » j j'), K := fun _ _ f => (w f).some\n    let gf : ∀ {j j'} (f : «expr ⟶ » j j'), «expr ⟶ » k' (kf f) := fun _ _ f => (w f).some_spec.some\n    let hf : ∀ {j j'} (f : «expr ⟶ » j j'), «expr ⟶ » k' (kf f) := fun _ _ f => (w f).some_spec.some_spec.some\n    have wf :\n      ∀ {j j'} (f : «expr ⟶ » j j'),\n        F.map (((«expr𝟙») j', «expr ≫ » (g j') (gf f)) : «expr ⟶ » (j', k j') (j', kf f)) (y j') =\n          F.map ((f, «expr ≫ » (g j) (hf f)) : «expr ⟶ » (j, k j) (j', kf f)) (y j) :=\n      fun j j' f =>\n      by\n      have q : ((curry.obj F).obj j').map (gf f) (F.map _ (y j')) = ((curry.obj F).obj j').map (hf f) (F.map _ (y j)) :=\n        (w f).some_spec.some_spec.some_spec\n      dsimp at q\n      simp_rw [← functor_to_types.map_comp_apply] at q\n      convert q <;> simp only [comp_id]\n    clear_value kf gf hf\n    -- and clean up some things that are no longer needed.\n    clear w\n    -- We're now ready to use the fact that `K` is filtered a second time,\n    -- picking some place to the right of all of\n    -- the morphisms `gf f : k' ⟶ kh f` and `hf f : k' ⟶ kf f`.\n    -- At this point we're relying on there being only finitely morphisms in `J`.\n    let O := (finset.univ.bUnion fun j => finset.univ.bUnion fun j' => finset.univ.image (@kf j j')) ∪ {k'}\n    have kfO : ∀ {j j'} (f : «expr ⟶ » j j'), kf f ∈ O := fun j j' f =>\n      finset.mem_union.mpr\n        (or.inl\n          (by\n            rw [Finset.mem_bunionᵢ]\n            refine' ⟨j, finset.mem_univ j, _⟩\n            rw [Finset.mem_bunionᵢ]\n            refine' ⟨j', finset.mem_univ j', _⟩\n            rw [Finset.mem_image]\n            refine' ⟨f, finset.mem_univ _, _⟩\n            rfl))\n    have k'O : k' ∈ O := finset.mem_union.mpr (or.inr (finset.mem_singleton.mpr rfl))\n    let H : Finset (Σ'(X Y : K)(mX : X ∈ O)(mY : Y ∈ O), «expr ⟶ » X Y) :=\n      finset.univ.bUnion fun j : J =>\n        finset.univ.bUnion fun j' : J =>\n          finset.univ.bUnion fun f : «expr ⟶ » j j' => {⟨k', kf f, k'O, kfO f, gf f⟩, ⟨k', kf f, k'O, kfO f, hf f⟩}\n    obtain ⟨k'', i', s'⟩ := is_filtered.sup_exists O H\n    -- We then restate this slightly more conveniently, as a family of morphism `i f : kf f ⟶ k''`,\n    -- satisfying `gf f ≫ i f = hf f' ≫ i f'`.\n    let i : ∀ {j j'} (f : «expr ⟶ » j j'), «expr ⟶ » (kf f) k'' := fun j j' f => i' (kfO f)\n    have s :\n      ∀ {j₁ j₂ j₃ j₄} (f : «expr ⟶ » j₁ j₂) (f' : «expr ⟶ » j₃ j₄), «expr ≫ » (gf f) (i f) = «expr ≫ » (hf f') (i f') :=\n      by\n      intros\n      rw [s', s']\n      swap\n      exact k'O\n      swap\n      · rw [Finset.mem_bunionᵢ]\n        refine' ⟨j₁, finset.mem_univ _, _⟩\n        rw [Finset.mem_bunionᵢ]\n        refine' ⟨j₂, finset.mem_univ _, _⟩\n        rw [Finset.mem_bunionᵢ]\n        refine' ⟨f, finset.mem_univ _, _⟩\n        simp only [true_or_iff, eq_self_iff_true, and_self_iff, Finset.mem_insert, heq_iff_eq]\n      · rw [Finset.mem_bunionᵢ]\n        refine' ⟨j₃, finset.mem_univ _, _⟩\n        rw [Finset.mem_bunionᵢ]\n        refine' ⟨j₄, finset.mem_univ _, _⟩\n        rw [Finset.mem_bunionᵢ]\n        refine' ⟨f', finset.mem_univ _, _⟩\n        simp only [eq_self_iff_true, or_true_iff, and_self_iff, Finset.mem_insert, Finset.mem_singleton, heq_iff_eq]\n    clear_value i\n    clear s' i' H kfO k'O O\n    -- We're finally ready to construct the pre-image, and verify it really maps to `x`.\n    fconstructor\n    · -- We construct the pre-image (which, recall is meant to be a point\n      -- in the colimit (over `K`) of the limits (over `J`)) via a representative at `k''`.\n      apply colimit.ι («expr ⋙ » (curry.obj («expr ⋙ » (swap K J) F)) limits.lim) k'' _\n      dsimp\n      -- This representative is meant to be an element of a limit,\n      -- so we need to construct a family of elements in `F.obj (j, k'')` for varying `j`,\n      -- then show that are coherent with respect to morphisms in the `j` direction.\n      apply limit.mk.{v, v}\n      swap\n      ·-- We construct the elements as the images of the `y j`.\n        exact fun j =>\n          F.map\n            (⟨(«expr𝟙») j, «expr ≫ » (g j) («expr ≫ » (gf ((«expr𝟙») j)) (i ((«expr𝟙») j)))⟩ :\n              «expr ⟶ » (j, k j) (j, k''))\n            (y j)\n      · -- After which it's just a calculation, using `s` and `wf`, to see they are coherent.\n        dsimp\n        intro j j' f\n        simp only [← functor_to_types.map_comp_apply, prod_comp, id_comp, comp_id]\n        calc\n          F.map ((f, «expr ≫ » (g j) («expr ≫ » (gf ((«expr𝟙») j)) (i ((«expr𝟙») j)))) : «expr ⟶ » (j, k j) (j', k''))\n                (y j) =\n              F.map ((f, «expr ≫ » (g j) («expr ≫ » (hf f) (i f))) : «expr ⟶ » (j, k j) (j', k'')) (y j) :=\n            by rw [s ((«expr𝟙») j) f]\n          _ =\n              F.map (((«expr𝟙») j', i f) : «expr ⟶ » (j', kf f) (j', k''))\n                (F.map ((f, «expr ≫ » (g j) (hf f)) : «expr ⟶ » (j, k j) (j', kf f)) (y j)) :=\n            by rw [← functor_to_types.map_comp_apply, prod_comp, comp_id, assoc]\n          _ =\n              F.map (((«expr𝟙») j', i f) : «expr ⟶ » (j', kf f) (j', k''))\n                (F.map (((«expr𝟙») j', «expr ≫ » (g j') (gf f)) : «expr ⟶ » (j', k j') (j', kf f)) (y j')) :=\n            by rw [← wf f]\n          _ =\n              F.map (((«expr𝟙») j', «expr ≫ » (g j') («expr ≫ » (gf f) (i f))) : «expr ⟶ » (j', k j') (j', k''))\n                (y j') :=\n            by rw [← functor_to_types.map_comp_apply, prod_comp, id_comp, assoc]\n          _ =\n              F.map\n                (((«expr𝟙») j', «expr ≫ » (g j') («expr ≫ » (gf ((«expr𝟙») j')) (i ((«expr𝟙») j')))) :\n                  «expr ⟶ » (j', k j') (j', k''))\n                (y j') :=\n            by rw [s f ((«expr𝟙») j'), ← s ((«expr𝟙») j') ((«expr𝟙») j')]\n          \n    -- Finally we check that this maps to `x`.\n    · -- We can do this componentwise:\n      apply limit_ext'\n      intro j\n      -- and as each component is an equation in a colimit, we can verify it by\n      -- pointing out the morphism which carries one representative to the other:\n      simp only [← e, colimit_eq_iff.{v, v}, curry_obj_obj_map, limit.π_mk', bifunctor.map_id_comp, id.def,\n        types_comp_apply, limits.ι_colimit_limit_to_limit_colimit_π_apply]\n      refine' ⟨k'', («expr𝟙») k'', «expr ≫ » (g j) («expr ≫ » (gf ((«expr𝟙») j)) (i ((«expr𝟙») j))), _⟩\n      simp only [bifunctor.map_id_comp, types_comp_apply, bifunctor.map_id, types_id_apply]\n#align colimit_limit_to_limit_colimit_surjective colimit_limit_to_limit_colimit_surjective\n\n",
 "colimit_limit_to_limit_colimit_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/-\nCopyright (c) 2020 Scott Morrison. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Scott Morrison\n-/\n/-- This follows this proof from\n* Borceux, Handbook of categorical algebra 1, Theorem 2.13.4\n-/\ntheorem colimit_limit_to_limit_colimit_injective : function.injective (colimit_limit_to_limit_colimit F) := by\n  classical\n    cases nonempty_fintype J\n    -- Suppose we have two terms `x y` in the colimit (over `K`) of the limits (over `J`),\n    -- and that these have the same image under `colimit_limit_to_limit_colimit F`.\n    intro x y h\n    -- These elements of the colimit have representatives somewhere:\n    obtain ⟨kx, x, rfl⟩ := jointly_surjective'.{v, v} x\n    obtain ⟨ky, y, rfl⟩ := jointly_surjective'.{v, v} y\n    dsimp at x y\n    -- Since the images of `x` and `y` are equal in a limit, they are equal componentwise\n    -- (indexed by `j : J`),\n    replace h := fun j => congr_arg (limit.π («expr ⋙ » (curry.obj F) colim) j) h\n    -- and they are equations in a filtered colimit,\n    -- so for each `j` we have some place `k j` to the right of both `kx` and `ky`\n    simp [colimit_eq_iff.{v, v}] at h\n    let k j := (h j).some\n    let f : ∀ j, «expr ⟶ » kx (k j) := fun j => (h j).some_spec.some\n    let g : ∀ j, «expr ⟶ » ky (k j) := fun j => (h j).some_spec.some_spec.some\n    -- where the images of the components of the representatives become equal:\n    have w :\n      ∀ j,\n        F.map (((«expr𝟙») j, f j) : «expr ⟶ » (j, kx) (j, k j))\n            (limit.π ((curry.obj («expr ⋙ » (swap K J) F)).obj kx) j x) =\n          F.map (((«expr𝟙») j, g j) : «expr ⟶ » (j, ky) (j, k j))\n            (limit.π ((curry.obj («expr ⋙ » (swap K J) F)).obj ky) j y) :=\n      fun j => (h j).some_spec.some_spec.some_spec\n    -- We now use that `K` is filtered, picking some point to the right of all these\n    -- morphisms `f j` and `g j`.\n    let O : Finset K := finset.univ.image k ∪ {kx, ky}\n    have kxO : kx ∈ O := finset.mem_union.mpr (or.inr (by simp))\n    have kyO : ky ∈ O := finset.mem_union.mpr (or.inr (by simp))\n    have kjO : ∀ j, k j ∈ O := fun j => finset.mem_union.mpr (or.inl (by simp))\n    let H : Finset (Σ'(X Y : K)(mX : X ∈ O)(mY : Y ∈ O), «expr ⟶ » X Y) :=\n      (finset.univ.image fun j : J => ⟨kx, k j, kxO, finset.mem_union.mpr (or.inl (by simp)), f j⟩) ∪\n        finset.univ.image fun j : J => ⟨ky, k j, kyO, finset.mem_union.mpr (or.inl (by simp)), g j⟩\n    obtain ⟨S, T, W⟩ := is_filtered.sup_exists O H\n    have fH : ∀ j, (⟨kx, k j, kxO, kjO j, f j⟩ : Σ'(X Y : K)(mX : X ∈ O)(mY : Y ∈ O), «expr ⟶ » X Y) ∈ H := fun j =>\n      finset.mem_union.mpr\n        (or.inl\n          (by\n            simp only [true_and_iff, finset.mem_univ, eq_self_iff_true, exists_prop_of_true, Finset.mem_image,\n              heq_iff_eq]\n            refine' ⟨j, rfl, _⟩\n            simp only [heq_iff_eq]\n            exact ⟨rfl, rfl, rfl⟩))\n    have gH : ∀ j, (⟨ky, k j, kyO, kjO j, g j⟩ : Σ'(X Y : K)(mX : X ∈ O)(mY : Y ∈ O), «expr ⟶ » X Y) ∈ H := fun j =>\n      finset.mem_union.mpr\n        (or.inr\n          (by\n            simp only [true_and_iff, finset.mem_univ, eq_self_iff_true, exists_prop_of_true, Finset.mem_image,\n              heq_iff_eq]\n            refine' ⟨j, rfl, _⟩\n            simp only [heq_iff_eq]\n            exact ⟨rfl, rfl, rfl⟩))\n    -- Our goal is now an equation between equivalence classes of representatives of a colimit,\n    -- and so it suffices to show those representative become equal somewhere, in particular at `S`.\n    apply colimit_sound'.{v, v} (T kxO) (T kyO)\n    -- We can check if two elements of a limit (in `Type`) are equal by comparing them componentwise.\n    ext\n    -- Now it's just a calculation using `W` and `w`.\n    simp only [functor.comp_map, limit.map_π_apply, curry_obj_map_app, swap_map]\n    rw [← W _ _ (fH j)]\n    rw [← W _ _ (gH j)]\n    simp [w]\n#align colimit_limit_to_limit_colimit_injective colimit_limit_to_limit_colimit_injective\n\n"}