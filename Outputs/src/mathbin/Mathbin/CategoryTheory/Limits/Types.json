{"π_mk'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n@[simp]\ntheorem limit.π_mk' (F : «expr ⥤ » J (Type v)) (x : ∀ j, F.obj j)\n    (h : ∀ (j j') (f : «expr ⟶ » j j'), F.map f (x j) = x j') (j) : limit.π F j (Limit.mk.{v, v} F x h) = x j :=\n  by\n  dsimp [limit.mk]\n  simp\n#align limit.π_mk' limit.π_mk'\n\n",
 "π_mk":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n@[simp]\ntheorem limit.π_mk (F : «expr ⥤ » J (Type max v u)) (x : ∀ j, F.obj j)\n    (h : ∀ (j j') (f : «expr ⟶ » j j'), F.map f (x j) = x j') (j) : limit.π F j (Limit.mk F x h) = x j :=\n  by\n  dsimp [limit.mk]\n  simp\n#align limit.π_mk limit.π_mk\n\n",
 "ι_map_apply'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n@[simp]\ntheorem colimit.ι_map_apply' {F G : «expr ⥤ » J (Type v)} (α : «expr ⟶ » F G) (j : J) (x) :\n    colim.map α (colimit.ι F j x) = colimit.ι G j (α.app j x) :=\n  congr_fun (colimit.ι_map α j) x\n#align colimit.ι_map_apply' colimit.ι_map_apply'\n\n",
 "ι_map_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n@[simp]\ntheorem colimit.ι_map_apply {F G : «expr ⥤ » J (Type max v u)} (α : «expr ⟶ » F G) (j : J) (x) :\n    colim.map α (colimit.ι F j x) = colimit.ι G j (α.app j x) :=\n  congr_fun (colimit.ι_map α j) x\n#align colimit.ι_map_apply colimit.ι_map_apply\n\n",
 "ι_desc_apply'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n@[simp]\ntheorem colimit.ι_desc_apply' (F : «expr ⥤ » J (Type v)) (s : Cocone F) (j : J) (x : F.obj j) :\n    colimit.desc F s (colimit.ι F j x) = s.ι.app j x :=\n  congr_fun (colimit.ι_desc s j) x\n#align colimit.ι_desc_apply' colimit.ι_desc_apply'\n\n",
 "ι_desc_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n@[simp]\ntheorem colimit.ι_desc_apply (F : «expr ⥤ » J (Type max v u)) (s : Cocone F) (j : J) (x : F.obj j) :\n    colimit.desc F s (colimit.ι F j x) = s.ι.app j x :=\n  congr_fun (colimit.ι_desc s j) x\n#align colimit.ι_desc_apply colimit.ι_desc_apply\n\n",
 "w_apply'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n@[simp]\ntheorem colimit.w_apply' {F : «expr ⥤ » J (Type v)} {j j' : J} {x : F.obj j} (f : «expr ⟶ » j j') :\n    colimit.ι F j' (F.map f x) = colimit.ι F j x :=\n  congr_fun (colimit.w F f) x\n#align colimit.w_apply' colimit.w_apply'\n\n",
 "w_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n@[simp]\ntheorem colimit.w_apply {F : «expr ⥤ » J (Type max v u)} {j j' : J} {x : F.obj j} (f : «expr ⟶ » j j') :\n    colimit.ι F j' (F.map f x) = colimit.ι F j x :=\n  congr_fun (colimit.w F f) x\n#align colimit.w_apply colimit.w_apply\n\n",
 "rel_of_quot_rel":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- For filtered colimits of types, we can give an explicit description\n  of the equivalence relation generated by the relation used to form\n  the colimit.  -/\ntheorem rel_of_quot_rel (x y : Σj, F.obj j) : Quot.Rel F x y → FilteredColimit.Rel F x y := fun ⟨f, h⟩ =>\n  ⟨y.1, f, («expr𝟙») y.1, by rw [← h, functor_to_types.map_id_apply]⟩\n#align rel_of_quot_rel rel_of_quot_rel\n\n",
 "rel_equiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n-- Strategy: Prove that the map from \"the\" colimit of F (defined above) to t.X\n-- is a bijection.\nprotected theorem rel_equiv : equivalence (FilteredColimit.Rel F) :=\n  ⟨fun x => ⟨x.1, («expr𝟙») x.1, («expr𝟙») x.1, rfl⟩, fun x y ⟨k, f, g, h⟩ => ⟨k, g, f, h.symm⟩,\n    fun x y z ⟨k, f, g, h⟩ ⟨k', f', g', h'⟩ =>\n    let ⟨l, fl, gl, _⟩ := is_filtered_or_empty.cocone_objs k k'\n    let ⟨m, n, hn⟩ := is_filtered_or_empty.cocone_maps («expr ≫ » g fl) («expr ≫ » f' gl)\n    ⟨m, «expr ≫ » f («expr ≫ » fl n), «expr ≫ » g' («expr ≫ » gl n),\n      calc\n        F.map («expr ≫ » f («expr ≫ » fl n)) x.2 = F.map («expr ≫ » fl n) (F.map f x.2) := by simp\n        _ = F.map («expr ≫ » fl n) (F.map g y.2) := by rw [h]\n        _ = F.map («expr ≫ » («expr ≫ » g fl) n) y.2 := by simp\n        _ = F.map («expr ≫ » («expr ≫ » f' gl) n) y.2 := by rw [hn]\n        _ = F.map («expr ≫ » gl n) (F.map f' y.2) := by simp\n        _ = F.map («expr ≫ » gl n) (F.map g' z.2) := by rw [h']\n        _ = F.map («expr ≫ » g' («expr ≫ » gl n)) z.2 := by simp\n        ⟩⟩\n#align rel_equiv rel_equiv\n\n",
 "rel_eq_eqv_gen_quot_rel":
 "protected theorem rel_eq_eqv_gen_quot_rel : FilteredColimit.Rel F = EqvGen (Quot.Rel F) :=\n  by\n  ext (⟨j, x⟩⟨j', y⟩)\n  constructor\n  · apply eqv_gen_quot_rel_of_rel\n  · rw [← (filtered_colimit.rel_equiv F).eqv_gen_iff]\n    exact EqvGen.mono (rel_of_quot_rel F)\n#align rel_eq_eqv_gen_quot_rel rel_eq_eqv_gen_quot_rel\n\n",
 "map_π_apply'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n@[simp]\ntheorem limit.map_π_apply' {F G : «expr ⥤ » J (Type v)} (α : «expr ⟶ » F G) (j : J) (x) :\n    limit.π G j (limMap α x) = α.app j (limit.π F j x) :=\n  congr_fun (limMap_π α j) x\n#align limit.map_π_apply' limit.map_π_apply'\n\n",
 "map_π_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n@[simp]\ntheorem limit.map_π_apply {F G : «expr ⥤ » J (Type max v u)} (α : «expr ⟶ » F G) (j : J) (x) :\n    limit.π G j (limMap α x) = α.app j (limit.π F j x) :=\n  congr_fun (limMap_π α j) x\n#align limit.map_π_apply limit.map_π_apply\n\n",
 "limit_ext_iff'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\ntheorem limit_ext_iff' (F : «expr ⥤ » J (Type v)) (x y : limit F) : x = y ↔ ∀ j, limit.π F j x = limit.π F j y :=\n  ⟨fun t _ => t ▸ rfl, limit_ext _ _ _⟩\n#align limit_ext_iff' limit_ext_iff'\n\n",
 "limit_ext_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\ntheorem limit_ext_iff (F : «expr ⥤ » J (Type max v u)) (x y : limit F) : x = y ↔ ∀ j, limit.π F j x = limit.π F j y :=\n  ⟨fun t _ => t ▸ rfl, limit_ext _ _ _⟩\n#align limit_ext_iff limit_ext_iff\n\n",
 "limit_ext'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n@[ext]\ntheorem limit_ext' (F : «expr ⥤ » J (Type v)) (x y : limit F) (w : ∀ j, limit.π F j x = limit.π F j y) : x = y :=\n  by\n  apply (limitEquivSections.{v, v} F).injective\n  ext j\n  simp [w j]\n#align limit_ext' limit_ext'\n\n",
 "limit_ext":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n-- PROJECT: prove this for concrete categories where the forgetful functor preserves limits\n@[ext]\ntheorem limit_ext (F : «expr ⥤ » J (Type max v u)) (x y : limit F) (w : ∀ j, limit.π F j x = limit.π F j y) : x = y :=\n  by\n  apply (limit_equiv_sections F).injective\n  ext j\n  simp [w j]\n#align limit_ext limit_ext\n\n",
 "limit_equiv_sections_symm_apply'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n@[simp]\ntheorem limit_equiv_sections_symm_apply' (F : «expr ⥤ » J (Type v)) (x : F.sections) (j : J) :\n    limit.π F j ((limitEquivSections.{v, v} F).symm x) = (x : ∀ j, F.obj j) j :=\n  isLimitEquivSections_symm_apply _ _ _\n#align limit_equiv_sections_symm_apply' limit_equiv_sections_symm_apply'\n\n",
 "limit_equiv_sections_symm_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n@[simp]\ntheorem limit_equiv_sections_symm_apply (F : «expr ⥤ » J (Type max v u)) (x : F.sections) (j : J) :\n    limit.π F j ((limitEquivSections F).symm x) = (x : ∀ j, F.obj j) j :=\n  isLimitEquivSections_symm_apply _ _ _\n#align limit_equiv_sections_symm_apply limit_equiv_sections_symm_apply\n\n",
 "limit_equiv_sections_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n@[simp]\ntheorem limit_equiv_sections_apply (F : «expr ⥤ » J (Type max v u)) (x : limit F) (j : J) :\n    ((limitEquivSections F) x : ∀ j, F.obj j) j = limit.π F j x :=\n  rfl\n#align limit_equiv_sections_apply limit_equiv_sections_apply\n\n",
 "lift_π_apply'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n@[simp]\ntheorem limit.lift_π_apply' (F : «expr ⥤ » J (Type v)) (s : Cone F) (j : J) (x : s.X) :\n    limit.π F j (limit.lift F s x) = s.π.app j x :=\n  congr_fun (limit.lift_π s j) x\n#align limit.lift_π_apply' limit.lift_π_apply'\n\n",
 "lift_π_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n@[simp]\ntheorem limit.lift_π_apply (F : «expr ⥤ » J (Type max v u)) (s : Cone F) (j : J) (x : s.X) :\n    limit.π F j (limit.lift F s x) = s.π.app j x :=\n  congr_fun (limit.lift_π s j) x\n#align limit.lift_π_apply limit.lift_π_apply\n\n",
 "lift_fac":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n-- implementation of `has_image`\ntheorem image.lift_fac (F' : MonoFactorisation f) : «expr ≫ » (Image.lift F') F'.m = Image.ι f :=\n  by\n  ext x\n  change («expr ≫ » F'.e F'.m) _ = _\n  rw [F'.fac, (classical.indefinite_description _ x.2).2]\n  rfl\n#align image.lift_fac image.lift_fac\n\n",
 "jointly_surjective'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/-- A variant of `jointly_surjective` for `x : colimit F`. -/\ntheorem jointly_surjective' {F : «expr ⥤ » J (Type max v u)} (x : colimit F) : ∃ j y, colimit.ι F j y = x :=\n  jointly_surjective F (colimit.isColimit _) x\n#align jointly_surjective' jointly_surjective'\n\n",
 "jointly_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\ntheorem jointly_surjective (F : «expr ⥤ » J (Type max v u)) {t : Cocone F} (h : IsColimit t) (x : t.X) :\n    ∃ j y, t.ι.app j y = x :=\n  by\n  suffices (fun x : t.X => ULift.up (∃ j y, t.ι.app j y = x)) = fun _ => ULift.up True\n    by\n    have := congr_fun this x\n    have H := congr_arg ULift.down this\n    dsimp at H\n    rwa [eq_true_iff] at H\n  refine' h.hom_ext _\n  intro j\n  ext y\n  erw [iff_true_iff]\n  exact ⟨j, y, rfl⟩\n#align jointly_surjective jointly_surjective\n\n",
 "is_limit_equiv_sections_symm_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n@[simp]\ntheorem is_limit_equiv_sections_symm_apply {F : «expr ⥤ » J (Type max v u)} {c : Cone F} (t : IsLimit c)\n    (x : F.sections) (j : J) : c.π.app j ((isLimitEquivSections t).symm x) = (x : ∀ j, F.obj j) j :=\n  by\n  equiv_rw(is_limit_equiv_sections t).symm  at x\n  simp\n#align is_limit_equiv_sections_symm_apply is_limit_equiv_sections_symm_apply\n\n",
 "is_limit_equiv_sections_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/-\nCopyright (c) 2018 Scott Morrison. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Scott Morrison, Reid Barton\n-/\n@[simp]\ntheorem is_limit_equiv_sections_apply {F : «expr ⥤ » J (Type max v u)} {c : Cone F} (t : IsLimit c) (j : J) (x : c.X) :\n    ((isLimitEquivSections t) x : ∀ j, F.obj j) j = c.π.app j x :=\n  rfl\n#align is_limit_equiv_sections_apply is_limit_equiv_sections_apply\n\n",
 "is_colimit_eq_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≅ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≅ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem is_colimit_eq_iff {t : Cocone F} (ht : IsColimit t) {i j : J} {xi : F.obj i} {xj : F.obj j} :\n    t.ι.app i xi = t.ι.app j xj ↔ ∃ (k : _)(f : «expr ⟶ » i k)(g : «expr ⟶ » j k), F.map f xi = F.map g xj :=\n  by\n  let t' := colimitCocone F\n  let e : «expr ≅ » t' t := IsColimit.uniqueUpToIso (colimitCoconeIsColimit F) ht\n  let e' : «expr ≅ » t'.X t.X := (Cocones.forget _).map_iso e\n  refine' iff.trans _ (colimit_eq_iff_aux F)\n  convert e'.to_equiv.apply_eq_iff_eq <;> rw [← e.hom.w] <;> rfl\n#align is_colimit_eq_iff is_colimit_eq_iff\n\n",
 "eqv_gen_quot_rel_of_rel":
 "theorem eqv_gen_quot_rel_of_rel (x y : Σj, F.obj j) : FilteredColimit.Rel F x y → EqvGen (Quot.Rel F) x y :=\n  fun ⟨k, f, g, h⟩ =>\n  eqv_gen.trans _ ⟨k, F.map f x.2⟩ _ (eqv_gen.rel _ _ ⟨f, rfl⟩) (eqv_gen.symm _ _ (eqv_gen.rel _ _ ⟨g, h⟩))\n#align eqv_gen_quot_rel_of_rel eqv_gen_quot_rel_of_rel\n\n",
 "colimit_sound'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem colimit_sound' {F : «expr ⥤ » J (Type max v u)} {j j' : J} {x : F.obj j} {x' : F.obj j'} {j'' : J}\n    (f : «expr ⟶ » j j'') (f' : «expr ⟶ » j' j'') (w : F.map f x = F.map f' x') : colimit.ι F j x = colimit.ι F j' x' :=\n  by\n  rw [← colimit.w _ f, ← colimit.w _ f']\n  rw [types_comp_apply, types_comp_apply, w]\n#align colimit_sound' colimit_sound'\n\n",
 "colimit_sound":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem colimit_sound {F : «expr ⥤ » J (Type max v u)} {j j' : J} {x : F.obj j} {x' : F.obj j'} (f : «expr ⟶ » j j')\n    (w : F.map f x = x') : colimit.ι F j x = colimit.ι F j' x' :=\n  by\n  rw [← w]\n  simp\n#align colimit_sound colimit_sound\n\n",
 "colimit_equiv_quot_symm_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n@[simp]\ntheorem colimit_equiv_quot_symm_apply (F : «expr ⥤ » J (Type max v u)) (j : J) (x : F.obj j) :\n    (colimitEquivQuot F).symm (Quot.mk _ ⟨j, x⟩) = colimit.ι F j x :=\n  rfl\n#align colimit_equiv_quot_symm_apply colimit_equiv_quot_symm_apply\n\n",
 "colimit_equiv_quot_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n@[simp]\ntheorem colimit_equiv_quot_apply (F : «expr ⥤ » J (Type max v u)) (j : J) (x : F.obj j) :\n    (colimitEquivQuot F) (colimit.ι F j x) = Quot.mk _ ⟨j, x⟩ :=\n  by\n  apply (colimit_equiv_quot F).symm.injective\n  simp\n#align colimit_equiv_quot_apply colimit_equiv_quot_apply\n\n",
 "colimit_eq_iff_aux":
 "theorem colimit_eq_iff_aux {i j : J} {xi : F.obj i} {xj : F.obj j} :\n    (colimitCocone F).ι.app i xi = (colimitCocone F).ι.app j xj ↔ FilteredColimit.Rel F ⟨i, xi⟩ ⟨j, xj⟩ :=\n  by\n  change Quot.mk _ _ = Quot.mk _ _ ↔ _\n  rw [Quot.eq, filtered_colimit.rel_eq_eqv_gen_quot_rel]\n#align colimit_eq_iff_aux colimit_eq_iff_aux\n\n",
 "colimit_eq_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem colimit_eq_iff {i j : J} {xi : F.obj i} {xj : F.obj j} :\n    colimit.ι F i xi = colimit.ι F j xj ↔ ∃ (k : _)(f : «expr ⟶ » i k)(g : «expr ⟶ » j k), F.map f xi = F.map g xj :=\n  isColimit_eq_iff _ (colimit.isColimit F)\n#align colimit_eq_iff colimit_eq_iff\n\n",
 "colimit_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\ntheorem colimit_eq {F : «expr ⥤ » J (Type max v u)} {j j' : J} {x : F.obj j} {x' : F.obj j'}\n    (w : colimit.ι F j x = colimit.ι F j' x') : EqvGen (Quot.Rel F) ⟨j, x⟩ ⟨j', x'⟩ :=\n  by\n  apply Quot.eq.1\n  simpa using congr_arg (colimit_equiv_quot F) w\n#align colimit_eq colimit_eq\n\n"}