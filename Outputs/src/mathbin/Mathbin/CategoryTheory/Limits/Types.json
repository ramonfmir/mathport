{"Ï€_mk'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n@[simp]\ntheorem limit.Ï€_mk' (F : Â«expr â¥¤ Â» J (Type v)) (x : âˆ€ j, F.obj j)\n    (h : âˆ€ (j j') (f : Â«expr âŸ¶ Â» j j'), F.map f (x j) = x j') (j) : limit.Ï€ F j (Limit.mk.{v, v} F x h) = x j :=\n  by\n  dsimp [limit.mk]\n  simp\n#align limit.Ï€_mk' limit.Ï€_mk'\n\n",
 "Ï€_mk":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n@[simp]\ntheorem limit.Ï€_mk (F : Â«expr â¥¤ Â» J (Type max v u)) (x : âˆ€ j, F.obj j)\n    (h : âˆ€ (j j') (f : Â«expr âŸ¶ Â» j j'), F.map f (x j) = x j') (j) : limit.Ï€ F j (Limit.mk F x h) = x j :=\n  by\n  dsimp [limit.mk]\n  simp\n#align limit.Ï€_mk limit.Ï€_mk\n\n",
 "Î¹_map_apply'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n@[simp]\ntheorem colimit.Î¹_map_apply' {F G : Â«expr â¥¤ Â» J (Type v)} (Î± : Â«expr âŸ¶ Â» F G) (j : J) (x) :\n    colim.map Î± (colimit.Î¹ F j x) = colimit.Î¹ G j (Î±.app j x) :=\n  congr_fun (colimit.Î¹_map Î± j) x\n#align colimit.Î¹_map_apply' colimit.Î¹_map_apply'\n\n",
 "Î¹_map_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n@[simp]\ntheorem colimit.Î¹_map_apply {F G : Â«expr â¥¤ Â» J (Type max v u)} (Î± : Â«expr âŸ¶ Â» F G) (j : J) (x) :\n    colim.map Î± (colimit.Î¹ F j x) = colimit.Î¹ G j (Î±.app j x) :=\n  congr_fun (colimit.Î¹_map Î± j) x\n#align colimit.Î¹_map_apply colimit.Î¹_map_apply\n\n",
 "Î¹_desc_apply'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n@[simp]\ntheorem colimit.Î¹_desc_apply' (F : Â«expr â¥¤ Â» J (Type v)) (s : Cocone F) (j : J) (x : F.obj j) :\n    colimit.desc F s (colimit.Î¹ F j x) = s.Î¹.app j x :=\n  congr_fun (colimit.Î¹_desc s j) x\n#align colimit.Î¹_desc_apply' colimit.Î¹_desc_apply'\n\n",
 "Î¹_desc_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n@[simp]\ntheorem colimit.Î¹_desc_apply (F : Â«expr â¥¤ Â» J (Type max v u)) (s : Cocone F) (j : J) (x : F.obj j) :\n    colimit.desc F s (colimit.Î¹ F j x) = s.Î¹.app j x :=\n  congr_fun (colimit.Î¹_desc s j) x\n#align colimit.Î¹_desc_apply colimit.Î¹_desc_apply\n\n",
 "w_apply'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n@[simp]\ntheorem colimit.w_apply' {F : Â«expr â¥¤ Â» J (Type v)} {j j' : J} {x : F.obj j} (f : Â«expr âŸ¶ Â» j j') :\n    colimit.Î¹ F j' (F.map f x) = colimit.Î¹ F j x :=\n  congr_fun (colimit.w F f) x\n#align colimit.w_apply' colimit.w_apply'\n\n",
 "w_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n@[simp]\ntheorem colimit.w_apply {F : Â«expr â¥¤ Â» J (Type max v u)} {j j' : J} {x : F.obj j} (f : Â«expr âŸ¶ Â» j j') :\n    colimit.Î¹ F j' (F.map f x) = colimit.Î¹ F j x :=\n  congr_fun (colimit.w F f) x\n#align colimit.w_apply colimit.w_apply\n\n",
 "rel_of_quot_rel":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n/- For filtered colimits of types, we can give an explicit description\n  of the equivalence relation generated by the relation used to form\n  the colimit.  -/\ntheorem rel_of_quot_rel (x y : Î£j, F.obj j) : Quot.Rel F x y â†’ FilteredColimit.Rel F x y := fun âŸ¨f, hâŸ© =>\n  âŸ¨y.1, f, (Â«exprğŸ™Â») y.1, by rw [â† h, functor_to_types.map_id_apply]âŸ©\n#align rel_of_quot_rel rel_of_quot_rel\n\n",
 "rel_equiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n-- Strategy: Prove that the map from \"the\" colimit of F (defined above) to t.X\n-- is a bijection.\nprotected theorem rel_equiv : equivalence (FilteredColimit.Rel F) :=\n  âŸ¨fun x => âŸ¨x.1, (Â«exprğŸ™Â») x.1, (Â«exprğŸ™Â») x.1, rflâŸ©, fun x y âŸ¨k, f, g, hâŸ© => âŸ¨k, g, f, h.symmâŸ©,\n    fun x y z âŸ¨k, f, g, hâŸ© âŸ¨k', f', g', h'âŸ© =>\n    let âŸ¨l, fl, gl, _âŸ© := is_filtered_or_empty.cocone_objs k k'\n    let âŸ¨m, n, hnâŸ© := is_filtered_or_empty.cocone_maps (Â«expr â‰« Â» g fl) (Â«expr â‰« Â» f' gl)\n    âŸ¨m, Â«expr â‰« Â» f (Â«expr â‰« Â» fl n), Â«expr â‰« Â» g' (Â«expr â‰« Â» gl n),\n      calc\n        F.map (Â«expr â‰« Â» f (Â«expr â‰« Â» fl n)) x.2 = F.map (Â«expr â‰« Â» fl n) (F.map f x.2) := by simp\n        _ = F.map (Â«expr â‰« Â» fl n) (F.map g y.2) := by rw [h]\n        _ = F.map (Â«expr â‰« Â» (Â«expr â‰« Â» g fl) n) y.2 := by simp\n        _ = F.map (Â«expr â‰« Â» (Â«expr â‰« Â» f' gl) n) y.2 := by rw [hn]\n        _ = F.map (Â«expr â‰« Â» gl n) (F.map f' y.2) := by simp\n        _ = F.map (Â«expr â‰« Â» gl n) (F.map g' z.2) := by rw [h']\n        _ = F.map (Â«expr â‰« Â» g' (Â«expr â‰« Â» gl n)) z.2 := by simp\n        âŸ©âŸ©\n#align rel_equiv rel_equiv\n\n",
 "rel_eq_eqv_gen_quot_rel":
 "protected theorem rel_eq_eqv_gen_quot_rel : FilteredColimit.Rel F = EqvGen (Quot.Rel F) :=\n  by\n  ext (âŸ¨j, xâŸ©âŸ¨j', yâŸ©)\n  constructor\n  Â· apply eqv_gen_quot_rel_of_rel\n  Â· rw [â† (filtered_colimit.rel_equiv F).eqv_gen_iff]\n    exact EqvGen.mono (rel_of_quot_rel F)\n#align rel_eq_eqv_gen_quot_rel rel_eq_eqv_gen_quot_rel\n\n",
 "map_Ï€_apply'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n@[simp]\ntheorem limit.map_Ï€_apply' {F G : Â«expr â¥¤ Â» J (Type v)} (Î± : Â«expr âŸ¶ Â» F G) (j : J) (x) :\n    limit.Ï€ G j (limMap Î± x) = Î±.app j (limit.Ï€ F j x) :=\n  congr_fun (limMap_Ï€ Î± j) x\n#align limit.map_Ï€_apply' limit.map_Ï€_apply'\n\n",
 "map_Ï€_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n@[simp]\ntheorem limit.map_Ï€_apply {F G : Â«expr â¥¤ Â» J (Type max v u)} (Î± : Â«expr âŸ¶ Â» F G) (j : J) (x) :\n    limit.Ï€ G j (limMap Î± x) = Î±.app j (limit.Ï€ F j x) :=\n  congr_fun (limMap_Ï€ Î± j) x\n#align limit.map_Ï€_apply limit.map_Ï€_apply\n\n",
 "limit_ext_iff'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\ntheorem limit_ext_iff' (F : Â«expr â¥¤ Â» J (Type v)) (x y : limit F) : x = y â†” âˆ€ j, limit.Ï€ F j x = limit.Ï€ F j y :=\n  âŸ¨fun t _ => t â–¸ rfl, limit_ext _ _ _âŸ©\n#align limit_ext_iff' limit_ext_iff'\n\n",
 "limit_ext_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\ntheorem limit_ext_iff (F : Â«expr â¥¤ Â» J (Type max v u)) (x y : limit F) : x = y â†” âˆ€ j, limit.Ï€ F j x = limit.Ï€ F j y :=\n  âŸ¨fun t _ => t â–¸ rfl, limit_ext _ _ _âŸ©\n#align limit_ext_iff limit_ext_iff\n\n",
 "limit_ext'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n@[ext]\ntheorem limit_ext' (F : Â«expr â¥¤ Â» J (Type v)) (x y : limit F) (w : âˆ€ j, limit.Ï€ F j x = limit.Ï€ F j y) : x = y :=\n  by\n  apply (limitEquivSections.{v, v} F).injective\n  ext j\n  simp [w j]\n#align limit_ext' limit_ext'\n\n",
 "limit_ext":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n-- PROJECT: prove this for concrete categories where the forgetful functor preserves limits\n@[ext]\ntheorem limit_ext (F : Â«expr â¥¤ Â» J (Type max v u)) (x y : limit F) (w : âˆ€ j, limit.Ï€ F j x = limit.Ï€ F j y) : x = y :=\n  by\n  apply (limit_equiv_sections F).injective\n  ext j\n  simp [w j]\n#align limit_ext limit_ext\n\n",
 "limit_equiv_sections_symm_apply'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n@[simp]\ntheorem limit_equiv_sections_symm_apply' (F : Â«expr â¥¤ Â» J (Type v)) (x : F.sections) (j : J) :\n    limit.Ï€ F j ((limitEquivSections.{v, v} F).symm x) = (x : âˆ€ j, F.obj j) j :=\n  isLimitEquivSections_symm_apply _ _ _\n#align limit_equiv_sections_symm_apply' limit_equiv_sections_symm_apply'\n\n",
 "limit_equiv_sections_symm_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n@[simp]\ntheorem limit_equiv_sections_symm_apply (F : Â«expr â¥¤ Â» J (Type max v u)) (x : F.sections) (j : J) :\n    limit.Ï€ F j ((limitEquivSections F).symm x) = (x : âˆ€ j, F.obj j) j :=\n  isLimitEquivSections_symm_apply _ _ _\n#align limit_equiv_sections_symm_apply limit_equiv_sections_symm_apply\n\n",
 "limit_equiv_sections_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n@[simp]\ntheorem limit_equiv_sections_apply (F : Â«expr â¥¤ Â» J (Type max v u)) (x : limit F) (j : J) :\n    ((limitEquivSections F) x : âˆ€ j, F.obj j) j = limit.Ï€ F j x :=\n  rfl\n#align limit_equiv_sections_apply limit_equiv_sections_apply\n\n",
 "lift_Ï€_apply'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n@[simp]\ntheorem limit.lift_Ï€_apply' (F : Â«expr â¥¤ Â» J (Type v)) (s : Cone F) (j : J) (x : s.X) :\n    limit.Ï€ F j (limit.lift F s x) = s.Ï€.app j x :=\n  congr_fun (limit.lift_Ï€ s j) x\n#align limit.lift_Ï€_apply' limit.lift_Ï€_apply'\n\n",
 "lift_Ï€_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n@[simp]\ntheorem limit.lift_Ï€_apply (F : Â«expr â¥¤ Â» J (Type max v u)) (s : Cone F) (j : J) (x : s.X) :\n    limit.Ï€ F j (limit.lift F s x) = s.Ï€.app j x :=\n  congr_fun (limit.lift_Ï€ s j) x\n#align limit.lift_Ï€_apply limit.lift_Ï€_apply\n\n",
 "lift_fac":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n-- implementation of `has_image`\ntheorem image.lift_fac (F' : MonoFactorisation f) : Â«expr â‰« Â» (Image.lift F') F'.m = Image.Î¹ f :=\n  by\n  ext x\n  change (Â«expr â‰« Â» F'.e F'.m) _ = _\n  rw [F'.fac, (classical.indefinite_description _ x.2).2]\n  rfl\n#align image.lift_fac image.lift_fac\n\n",
 "jointly_surjective'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/-- A variant of `jointly_surjective` for `x : colimit F`. -/\ntheorem jointly_surjective' {F : Â«expr â¥¤ Â» J (Type max v u)} (x : colimit F) : âˆƒ j y, colimit.Î¹ F j y = x :=\n  jointly_surjective F (colimit.isColimit _) x\n#align jointly_surjective' jointly_surjective'\n\n",
 "jointly_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\ntheorem jointly_surjective (F : Â«expr â¥¤ Â» J (Type max v u)) {t : Cocone F} (h : IsColimit t) (x : t.X) :\n    âˆƒ j y, t.Î¹.app j y = x :=\n  by\n  suffices (fun x : t.X => ULift.up (âˆƒ j y, t.Î¹.app j y = x)) = fun _ => ULift.up True\n    by\n    have := congr_fun this x\n    have H := congr_arg ULift.down this\n    dsimp at H\n    rwa [eq_true_iff] at H\n  refine' h.hom_ext _\n  intro j\n  ext y\n  erw [iff_true_iff]\n  exact âŸ¨j, y, rflâŸ©\n#align jointly_surjective jointly_surjective\n\n",
 "is_limit_equiv_sections_symm_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n@[simp]\ntheorem is_limit_equiv_sections_symm_apply {F : Â«expr â¥¤ Â» J (Type max v u)} {c : Cone F} (t : IsLimit c)\n    (x : F.sections) (j : J) : c.Ï€.app j ((isLimitEquivSections t).symm x) = (x : âˆ€ j, F.obj j) j :=\n  by\n  equiv_rw(is_limit_equiv_sections t).symm  at x\n  simp\n#align is_limit_equiv_sections_symm_apply is_limit_equiv_sections_symm_apply\n\n",
 "is_limit_equiv_sections_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/-\nCopyright (c) 2018 Scott Morrison. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Scott Morrison, Reid Barton\n-/\n@[simp]\ntheorem is_limit_equiv_sections_apply {F : Â«expr â¥¤ Â» J (Type max v u)} {c : Cone F} (t : IsLimit c) (j : J) (x : c.X) :\n    ((isLimitEquivSections t) x : âˆ€ j, F.obj j) j = c.Ï€.app j x :=\n  rfl\n#align is_limit_equiv_sections_apply is_limit_equiv_sections_apply\n\n",
 "is_colimit_eq_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰… Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰… Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem is_colimit_eq_iff {t : Cocone F} (ht : IsColimit t) {i j : J} {xi : F.obj i} {xj : F.obj j} :\n    t.Î¹.app i xi = t.Î¹.app j xj â†” âˆƒ (k : _)(f : Â«expr âŸ¶ Â» i k)(g : Â«expr âŸ¶ Â» j k), F.map f xi = F.map g xj :=\n  by\n  let t' := colimitCocone F\n  let e : Â«expr â‰… Â» t' t := IsColimit.uniqueUpToIso (colimitCoconeIsColimit F) ht\n  let e' : Â«expr â‰… Â» t'.X t.X := (Cocones.forget _).map_iso e\n  refine' iff.trans _ (colimit_eq_iff_aux F)\n  convert e'.to_equiv.apply_eq_iff_eq <;> rw [â† e.hom.w] <;> rfl\n#align is_colimit_eq_iff is_colimit_eq_iff\n\n",
 "eqv_gen_quot_rel_of_rel":
 "theorem eqv_gen_quot_rel_of_rel (x y : Î£j, F.obj j) : FilteredColimit.Rel F x y â†’ EqvGen (Quot.Rel F) x y :=\n  fun âŸ¨k, f, g, hâŸ© =>\n  eqv_gen.trans _ âŸ¨k, F.map f x.2âŸ© _ (eqv_gen.rel _ _ âŸ¨f, rflâŸ©) (eqv_gen.symm _ _ (eqv_gen.rel _ _ âŸ¨g, hâŸ©))\n#align eqv_gen_quot_rel_of_rel eqv_gen_quot_rel_of_rel\n\n",
 "colimit_sound'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem colimit_sound' {F : Â«expr â¥¤ Â» J (Type max v u)} {j j' : J} {x : F.obj j} {x' : F.obj j'} {j'' : J}\n    (f : Â«expr âŸ¶ Â» j j'') (f' : Â«expr âŸ¶ Â» j' j'') (w : F.map f x = F.map f' x') : colimit.Î¹ F j x = colimit.Î¹ F j' x' :=\n  by\n  rw [â† colimit.w _ f, â† colimit.w _ f']\n  rw [types_comp_apply, types_comp_apply, w]\n#align colimit_sound' colimit_sound'\n\n",
 "colimit_sound":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem colimit_sound {F : Â«expr â¥¤ Â» J (Type max v u)} {j j' : J} {x : F.obj j} {x' : F.obj j'} (f : Â«expr âŸ¶ Â» j j')\n    (w : F.map f x = x') : colimit.Î¹ F j x = colimit.Î¹ F j' x' :=\n  by\n  rw [â† w]\n  simp\n#align colimit_sound colimit_sound\n\n",
 "colimit_equiv_quot_symm_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n@[simp]\ntheorem colimit_equiv_quot_symm_apply (F : Â«expr â¥¤ Â» J (Type max v u)) (j : J) (x : F.obj j) :\n    (colimitEquivQuot F).symm (Quot.mk _ âŸ¨j, xâŸ©) = colimit.Î¹ F j x :=\n  rfl\n#align colimit_equiv_quot_symm_apply colimit_equiv_quot_symm_apply\n\n",
 "colimit_equiv_quot_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n@[simp]\ntheorem colimit_equiv_quot_apply (F : Â«expr â¥¤ Â» J (Type max v u)) (j : J) (x : F.obj j) :\n    (colimitEquivQuot F) (colimit.Î¹ F j x) = Quot.mk _ âŸ¨j, xâŸ© :=\n  by\n  apply (colimit_equiv_quot F).symm.injective\n  simp\n#align colimit_equiv_quot_apply colimit_equiv_quot_apply\n\n",
 "colimit_eq_iff_aux":
 "theorem colimit_eq_iff_aux {i j : J} {xi : F.obj i} {xj : F.obj j} :\n    (colimitCocone F).Î¹.app i xi = (colimitCocone F).Î¹.app j xj â†” FilteredColimit.Rel F âŸ¨i, xiâŸ© âŸ¨j, xjâŸ© :=\n  by\n  change Quot.mk _ _ = Quot.mk _ _ â†” _\n  rw [Quot.eq, filtered_colimit.rel_eq_eqv_gen_quot_rel]\n#align colimit_eq_iff_aux colimit_eq_iff_aux\n\n",
 "colimit_eq_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem colimit_eq_iff {i j : J} {xi : F.obj i} {xj : F.obj j} :\n    colimit.Î¹ F i xi = colimit.Î¹ F j xj â†” âˆƒ (k : _)(f : Â«expr âŸ¶ Â» i k)(g : Â«expr âŸ¶ Â» j k), F.map f xi = F.map g xj :=\n  isColimit_eq_iff _ (colimit.isColimit F)\n#align colimit_eq_iff colimit_eq_iff\n\n",
 "colimit_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\ntheorem colimit_eq {F : Â«expr â¥¤ Â» J (Type max v u)} {j j' : J} {x : F.obj j} {x' : F.obj j'}\n    (w : colimit.Î¹ F j x = colimit.Î¹ F j' x') : EqvGen (Quot.Rel F) âŸ¨j, xâŸ© âŸ¨j', x'âŸ© :=\n  by\n  apply Quot.eq.1\n  simpa using congr_arg (colimit_equiv_quot F) w\n#align colimit_eq colimit_eq\n\n"}