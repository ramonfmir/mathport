{"has_weakly_initial_of_weakly_initial_set_and_has_products":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/-\nCopyright (c) 2021 Bhavik Mehta. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Bhavik Mehta\n-/\n/-- If `C` has (small) products and a small weakly initial set of objects, then it has a weakly initial\nobject.\n-/\ntheorem has_weakly_initial_of_weakly_initial_set_and_has_products [HasProducts.{v} C] {Î¹ : Type v} {B : Î¹ â†’ C}\n    (hB : âˆ€ A : C, âˆƒ i, Nonempty (Â«expr âŸ¶ Â» (B i) A)) : âˆƒ T : C, âˆ€ X, Nonempty (Â«expr âŸ¶ Â» T X) :=\n  âŸ¨Â«exprâˆ Â» B, fun X => âŸ¨Â«expr â‰« Â» (Pi.Ï€ _ _) (hB X).some_spec.someâŸ©âŸ©\n#align has_weakly_initial_of_weakly_initial_set_and_has_products has_weakly_initial_of_weakly_initial_set_and_has_products\n\n",
 "has_initial_of_weakly_initial_and_has_wide_equalizers":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/-- If `C` has (small) wide equalizers and a weakly initial object, then it has an initial object.\n\nThe initial object is constructed as the wide equalizer of all endomorphisms on the given weakly\ninitial object.\n-/\ntheorem has_initial_of_weakly_initial_and_has_wide_equalizers [HasWideEqualizers.{v} C] {T : C}\n    (hT : âˆ€ X, Nonempty (Â«expr âŸ¶ Â» T X)) : HasInitial C :=\n  by\n  let endos := Â«expr âŸ¶ Â» T T\n  let i := wide_equalizer.Î¹ (id : endos â†’ endos)\n  haveI : Nonempty endos := âŸ¨(Â«exprğŸ™Â») _âŸ©\n  have : âˆ€ X : C, Unique (Â«expr âŸ¶ Â» (wide_equalizer (id : endos â†’ endos)) X) :=\n    by\n    intro X\n    refine' âŸ¨âŸ¨Â«expr â‰« Â» i (Classical.choice (hT X))âŸ©, fun a => _âŸ©\n    let E := equalizer a (Â«expr â‰« Â» i (Classical.choice (hT _)))\n    let e : Â«expr âŸ¶ Â» E (wide_equalizer id) := equalizer.Î¹ _ _\n    let h : Â«expr âŸ¶ Â» T E := Classical.choice (hT E)\n    have : Â«expr â‰« Â» (Â«expr â‰« Â» (Â«expr â‰« Â» i h) e) i = Â«expr â‰« Â» i ((Â«exprğŸ™Â») _) :=\n      by\n      rw [category.assoc, category.assoc]\n      apply wide_equalizer.condition (id : endos â†’ endos) (Â«expr â‰« Â» h (Â«expr â‰« Â» e i))\n    rw [category.comp_id, cancel_mono_id i] at this\n    haveI : is_split_epi e := is_split_epi.mk' âŸ¨Â«expr â‰« Â» i h, thisâŸ©\n    rw [â† cancel_epi e]\n    apply equalizer.condition\n  exact has_initial_of_unique (wide_equalizer (id : endos â†’ endos))\n#align has_initial_of_weakly_initial_and_has_wide_equalizers has_initial_of_weakly_initial_and_has_wide_equalizers\n\n"}