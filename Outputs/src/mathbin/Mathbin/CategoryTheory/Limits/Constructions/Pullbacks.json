{"has_pushouts_of_has_binary_coproducts_of_has_coequalizers":
 "/-- If a category has all binary coproducts and all coequalizers, then it also has all pushouts.\n    As usual, this is not an instance, since there may be a more direct way to construct\n    pushouts. -/\ntheorem has_pushouts_of_has_binary_coproducts_of_has_coequalizers (C : Type u) [𝒞 : Category.{v} C]\n    [HasBinaryCoproducts C] [HasCoequalizers C] : HasPushouts C :=\n  hasPushouts_of_hasColimit_span C\n#align has_pushouts_of_has_binary_coproducts_of_has_coequalizers has_pushouts_of_has_binary_coproducts_of_has_coequalizers\n\n",
 "has_pullbacks_of_has_binary_products_of_has_equalizers":
 "/-- If a category has all binary products and all equalizers, then it also has all pullbacks.\n    As usual, this is not an instance, since there may be a more direct way to construct\n    pullbacks. -/\ntheorem has_pullbacks_of_has_binary_products_of_has_equalizers (C : Type u) [𝒞 : Category.{v} C] [HasBinaryProducts C]\n    [HasEqualizers C] : HasPullbacks C :=\n  { has_limit := fun F => hasLimitOfIso (diagramIsoCospan F).symm }\n#align has_pullbacks_of_has_binary_products_of_has_equalizers has_pullbacks_of_has_binary_products_of_has_equalizers\n\n",
 "has_limit_cospan_of_has_limit_pair_of_has_limit_parallel_pair":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⨯ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⨯ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/-\nCopyright (c) 2020 Markus Himmel. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Markus Himmel\n-/\n/-- If the product `X ⨯ Y` and the equalizer of `π₁ ≫ f` and `π₂ ≫ g` exist, then the\n    pullback of `f` and `g` exists: It is given by composing the equalizer with the projections. -/\ntheorem has_limit_cospan_of_has_limit_pair_of_has_limit_parallel_pair {C : Type u} [𝒞 : Category.{v} C] {X Y Z : C}\n    (f : «expr ⟶ » X Z) (g : «expr ⟶ » Y Z) [HasLimit (pair X Y)]\n    [HasLimit (parallelPair («expr ≫ » prod.fst f) («expr ≫ » prod.snd g))] : HasLimit (cospan f g) :=\n  let π₁ : «expr ⟶ » («expr ⨯ » X Y) X := prod.fst\n  let π₂ : «expr ⟶ » («expr ⨯ » X Y) Y := prod.snd\n  let e := equalizer.ι («expr ≫ » π₁ f) («expr ≫ » π₂ g)\n  HasLimit.mk\n    { cone := PullbackCone.mk («expr ≫ » e π₁) («expr ≫ » e π₂) <| by simp only [category.assoc, equalizer.condition]\n      is_limit :=\n        PullbackCone.IsLimit.mk _\n          (fun s =>\n            equalizer.lift (prod.lift (s.π.app WalkingCospan.left) (s.π.app WalkingCospan.right)) <| by\n              rw [← category.assoc, limit.lift_π, ← category.assoc, limit.lift_π] <;> exact pullback_cone.condition _)\n          (by simp) (by simp) fun s m h₁ h₂ => by\n          ext\n          · simpa using h₁\n          · simpa using h₂ }\n#align has_limit_cospan_of_has_limit_pair_of_has_limit_parallel_pair has_limit_cospan_of_has_limit_pair_of_has_limit_parallel_pair\n\n",
 "has_colimit_span_of_has_colimit_pair_of_has_colimit_parallel_pair":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⨿ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⨿ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/-- If the coproduct `Y ⨿ Z` and the coequalizer of `f ≫ ι₁` and `g ≫ ι₂` exist, then the\n    pushout of `f` and `g` exists: It is given by composing the inclusions with the coequalizer. -/\ntheorem has_colimit_span_of_has_colimit_pair_of_has_colimit_parallel_pair {C : Type u} [𝒞 : Category.{v} C] {X Y Z : C}\n    (f : «expr ⟶ » X Y) (g : «expr ⟶ » X Z) [HasColimit (pair Y Z)]\n    [HasColimit (parallelPair («expr ≫ » f coprod.inl) («expr ≫ » g coprod.inr))] : HasColimit (span f g) :=\n  let ι₁ : «expr ⟶ » Y («expr ⨿ » Y Z) := coprod.inl\n  let ι₂ : «expr ⟶ » Z («expr ⨿ » Y Z) := coprod.inr\n  let c := coequalizer.π («expr ≫ » f ι₁) («expr ≫ » g ι₂)\n  HasColimit.mk\n    { cocone :=\n        PushoutCocone.mk («expr ≫ » ι₁ c) («expr ≫ » ι₂ c) <| by\n          rw [← category.assoc, ← category.assoc, coequalizer.condition]\n      is_colimit :=\n        PushoutCocone.IsColimit.mk _\n          (fun s =>\n            coequalizer.desc (coprod.desc (s.ι.app WalkingSpan.left) (s.ι.app WalkingSpan.right)) <| by\n              rw [category.assoc, colimit.ι_desc, category.assoc, colimit.ι_desc] <;> exact pushout_cocone.condition _)\n          (by simp) (by simp) fun s m h₁ h₂ => by\n          ext\n          · simpa using h₁\n          · simpa using h₂ }\n#align has_colimit_span_of_has_colimit_pair_of_has_colimit_parallel_pair has_colimit_span_of_has_colimit_pair_of_has_colimit_parallel_pair\n\n"}