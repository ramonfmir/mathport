{"has_pushouts_of_has_binary_coproducts_of_has_coequalizers":
 "/-- If a category has all binary coproducts and all coequalizers, then it also has all pushouts.\n    As usual, this is not an instance, since there may be a more direct way to construct\n    pushouts. -/\ntheorem has_pushouts_of_has_binary_coproducts_of_has_coequalizers (C : Type u) [ğ’ : Category.{v} C]\n    [HasBinaryCoproducts C] [HasCoequalizers C] : HasPushouts C :=\n  hasPushouts_of_hasColimit_span C\n#align has_pushouts_of_has_binary_coproducts_of_has_coequalizers has_pushouts_of_has_binary_coproducts_of_has_coequalizers\n\n",
 "has_pullbacks_of_has_binary_products_of_has_equalizers":
 "/-- If a category has all binary products and all equalizers, then it also has all pullbacks.\n    As usual, this is not an instance, since there may be a more direct way to construct\n    pullbacks. -/\ntheorem has_pullbacks_of_has_binary_products_of_has_equalizers (C : Type u) [ğ’ : Category.{v} C] [HasBinaryProducts C]\n    [HasEqualizers C] : HasPullbacks C :=\n  { has_limit := fun F => hasLimitOfIso (diagramIsoCospan F).symm }\n#align has_pullbacks_of_has_binary_products_of_has_equalizers has_pullbacks_of_has_binary_products_of_has_equalizers\n\n",
 "has_limit_cospan_of_has_limit_pair_of_has_limit_parallel_pair":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¨¯ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¨¯ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/-\nCopyright (c) 2020 Markus Himmel. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Markus Himmel\n-/\n/-- If the product `X â¨¯ Y` and the equalizer of `Ï€â‚ â‰« f` and `Ï€â‚‚ â‰« g` exist, then the\n    pullback of `f` and `g` exists: It is given by composing the equalizer with the projections. -/\ntheorem has_limit_cospan_of_has_limit_pair_of_has_limit_parallel_pair {C : Type u} [ğ’ : Category.{v} C] {X Y Z : C}\n    (f : Â«expr âŸ¶ Â» X Z) (g : Â«expr âŸ¶ Â» Y Z) [HasLimit (pair X Y)]\n    [HasLimit (parallelPair (Â«expr â‰« Â» prod.fst f) (Â«expr â‰« Â» prod.snd g))] : HasLimit (cospan f g) :=\n  let Ï€â‚ : Â«expr âŸ¶ Â» (Â«expr â¨¯ Â» X Y) X := prod.fst\n  let Ï€â‚‚ : Â«expr âŸ¶ Â» (Â«expr â¨¯ Â» X Y) Y := prod.snd\n  let e := equalizer.Î¹ (Â«expr â‰« Â» Ï€â‚ f) (Â«expr â‰« Â» Ï€â‚‚ g)\n  HasLimit.mk\n    { cone := PullbackCone.mk (Â«expr â‰« Â» e Ï€â‚) (Â«expr â‰« Â» e Ï€â‚‚) <| by simp only [category.assoc, equalizer.condition]\n      is_limit :=\n        PullbackCone.IsLimit.mk _\n          (fun s =>\n            equalizer.lift (prod.lift (s.Ï€.app WalkingCospan.left) (s.Ï€.app WalkingCospan.right)) <| by\n              rw [â† category.assoc, limit.lift_Ï€, â† category.assoc, limit.lift_Ï€] <;> exact pullback_cone.condition _)\n          (by simp) (by simp) fun s m hâ‚ hâ‚‚ => by\n          ext\n          Â· simpa using hâ‚\n          Â· simpa using hâ‚‚ }\n#align has_limit_cospan_of_has_limit_pair_of_has_limit_parallel_pair has_limit_cospan_of_has_limit_pair_of_has_limit_parallel_pair\n\n",
 "has_colimit_span_of_has_colimit_pair_of_has_colimit_parallel_pair":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¨¿ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¨¿ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/-- If the coproduct `Y â¨¿ Z` and the coequalizer of `f â‰« Î¹â‚` and `g â‰« Î¹â‚‚` exist, then the\n    pushout of `f` and `g` exists: It is given by composing the inclusions with the coequalizer. -/\ntheorem has_colimit_span_of_has_colimit_pair_of_has_colimit_parallel_pair {C : Type u} [ğ’ : Category.{v} C] {X Y Z : C}\n    (f : Â«expr âŸ¶ Â» X Y) (g : Â«expr âŸ¶ Â» X Z) [HasColimit (pair Y Z)]\n    [HasColimit (parallelPair (Â«expr â‰« Â» f coprod.inl) (Â«expr â‰« Â» g coprod.inr))] : HasColimit (span f g) :=\n  let Î¹â‚ : Â«expr âŸ¶ Â» Y (Â«expr â¨¿ Â» Y Z) := coprod.inl\n  let Î¹â‚‚ : Â«expr âŸ¶ Â» Z (Â«expr â¨¿ Â» Y Z) := coprod.inr\n  let c := coequalizer.Ï€ (Â«expr â‰« Â» f Î¹â‚) (Â«expr â‰« Â» g Î¹â‚‚)\n  HasColimit.mk\n    { cocone :=\n        PushoutCocone.mk (Â«expr â‰« Â» Î¹â‚ c) (Â«expr â‰« Â» Î¹â‚‚ c) <| by\n          rw [â† category.assoc, â† category.assoc, coequalizer.condition]\n      is_colimit :=\n        PushoutCocone.IsColimit.mk _\n          (fun s =>\n            coequalizer.desc (coprod.desc (s.Î¹.app WalkingSpan.left) (s.Î¹.app WalkingSpan.right)) <| by\n              rw [category.assoc, colimit.Î¹_desc, category.assoc, colimit.Î¹_desc] <;> exact pushout_cocone.condition _)\n          (by simp) (by simp) fun s m hâ‚ hâ‚‚ => by\n          ext\n          Â· simpa using hâ‚\n          Â· simpa using hâ‚‚ }\n#align has_colimit_span_of_has_colimit_pair_of_has_colimit_parallel_pair has_colimit_span_of_has_colimit_pair_of_has_colimit_parallel_pair\n\n"}