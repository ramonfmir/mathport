{"over_products_of_wide_pullbacks":
 "/-- Given all wide pullbacks in `C`, construct products in `C/B`. -/\ntheorem over_products_of_wide_pullbacks [HasWidePullbacks.{w} C] {B : C} : HasProducts.{w} (Over B) := fun J =>\n  over_product_of_wide_pullback\n#align over_products_of_wide_pullbacks over_products_of_wide_pullbacks\n\n",
 "over_product_of_wide_pullback":
 "/-- Given a wide pullback in `C`, construct a product in `C/B`. -/\ntheorem over_product_of_wide_pullback [HasLimitsOfShape (WidePullbackShape J) C] {B : C} :\n    HasLimitsOfShape (Discrete J) (Over B) :=\n  { has_limit := fun F => has_over_limit_discrete_of_wide_pullback_limit F }\n#align over_product_of_wide_pullback over_product_of_wide_pullback\n\n",
 "over_has_terminal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprðŸ™Â» -/\n/-- Construct terminal object in the over category. This isn't an instance as it's not typically the\nway we want to define terminal objects.\n(For instance, this gives a terminal object which is different from the generic one given by\n`over_product_of_wide_pullback` above.)\n-/\ntheorem over_has_terminal (B : C) : HasTerminal (Over B) :=\n  {\n    has_limit := fun F =>\n      HasLimit.mk\n        { cone :=\n            { X := Over.mk ((Â«exprðŸ™Â») _)\n              Ï€ := { app := fun p => p.as.elim } }\n          is_limit :=\n            { lift := fun s => Over.homMk _\n              fac' := fun _ j => j.as.elim\n              uniq' := fun s m _ => by\n                ext\n                rw [over.hom_mk_left]\n                have := m.w\n                dsimp at this\n                rwa [category.comp_id, category.comp_id] at this } } }\n#align over_has_terminal over_has_terminal\n\n",
 "over_finite_products_of_finite_wide_pullbacks":
 "/-- Given all finite wide pullbacks in `C`, construct finite products in `C/B`. -/\ntheorem over_finite_products_of_finite_wide_pullbacks [HasFiniteWidePullbacks C] {B : C} : HasFiniteProducts (Over B) :=\n  âŸ¨fun n => over_product_of_wide_pullbackâŸ©\n#align over_finite_products_of_finite_wide_pullbacks over_finite_products_of_finite_wide_pullbacks\n\n",
 "over_binary_product_of_pullback":
 "/-- Given a pullback in `C`, construct a binary product in `C/B`. -/\ntheorem over_binary_product_of_pullback [HasPullbacks C] {B : C} : HasBinaryProducts (Over B) :=\n  over_product_of_wide_pullback\n#align over_binary_product_of_pullback over_binary_product_of_pullback\n\n",
 "has_over_limit_discrete_of_wide_pullback_limit":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/-\nCopyright (c) 2018 Johan Commelin. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johan Commelin, Reid Barton, Bhavik Mehta\n-/\n-- morphism levels before object levels. See note [category_theory universes].\n-- `tidy` can do this using `case_bash`, but let's try to be a good `-T50000` citizen:\n-- TODO: Can we add `. obviously` to the second arguments of `nat_iso.of_components` and\n--       `cones.ext`?\n/-- Use the above equivalence to prove we have a limit. -/\ntheorem has_over_limit_discrete_of_wide_pullback_limit {B : C} (F : Â«expr â¥¤ Â» (Discrete J) (Over B))\n    [HasLimit (wide_pullback_diagram_of_diagram_over B F)] : HasLimit F :=\n  HasLimit.mk\n    { cone := _\n      is_limit :=\n        IsLimit.ofRightAdjoint (cones_equiv B F).functor (limit.isLimit (wide_pullback_diagram_of_diagram_over B F)) }\n#align has_over_limit_discrete_of_wide_pullback_limit has_over_limit_discrete_of_wide_pullback_limit\n\n"}