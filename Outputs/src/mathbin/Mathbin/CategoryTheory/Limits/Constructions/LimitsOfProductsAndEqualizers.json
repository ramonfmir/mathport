{"has_limits_of_has_equalizers_and_products":
 "/-- Any category with products and equalizers has all limits.\n\nSee <https://stacks.math.columbia.edu/tag/002N>.\n-/\ntheorem has_limits_of_has_equalizers_and_products [HasProducts.{w} C] [HasEqualizers C] : HasLimitsOfSize.{w, w} C :=\n  { has_limits_of_shape := fun J ùí• => { has_limit := fun F => has_limit_of_equalizer_and_product F } }\n#align has_limits_of_has_equalizers_and_products has_limits_of_has_equalizers_and_products\n\n",
 "has_limit_of_equalizer_and_product":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚•§ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚ü∂ ¬ª -/\n/-\nCopyright (c) 2020 Bhavik Mehta. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Bhavik Mehta, Scott Morrison\n-/\n-- We hide the \"implementation details\" inside a namespace\n/-- Given the existence of the appropriate (possibly finite) products and equalizers, we know a limit of\n`F` exists.\n(This assumes the existence of all equalizers, which is technically stronger than needed.)\n-/\ntheorem has_limit_of_equalizer_and_product (F : ¬´expr ‚•§ ¬ª J C) [HasLimit (Discrete.functor F.obj)]\n    [HasLimit (Discrete.functor fun f : Œ£p : J √ó J, ¬´expr ‚ü∂ ¬ª p.1 p.2 => F.obj f.1.2)] [HasEqualizers C] : HasLimit F :=\n  HasLimit.mk (limitConeOfEqualizerAndProduct F)\n#align has_limit_of_equalizer_and_product has_limit_of_equalizer_and_product\n\n",
 "has_finite_limits_of_has_terminal_and_pullbacks":
 "-- See note [dsimp, simp].\ntheorem has_finite_limits_of_has_terminal_and_pullbacks [HasTerminal C] [HasPullbacks C] : HasFiniteLimits C :=\n  @hasFiniteLimits_of_hasEqualizers_and_finite_products _\n    (@hasFiniteProducts_of_has_binary_and_terminal _ (hasBinaryProducts_of_hasTerminal_and_pullbacks C) inferInstance)\n    (@hasEqualizers_of_hasPullbacks_and_binary_products _ (hasBinaryProducts_of_hasTerminal_and_pullbacks C)\n      inferInstance)\n#align has_finite_limits_of_has_terminal_and_pullbacks has_finite_limits_of_has_terminal_and_pullbacks\n\n",
 "has_finite_limits_of_has_equalizers_and_finite_products":
 "/-- Any category with finite products and equalizers has all finite limits.\n\nSee <https://stacks.math.columbia.edu/tag/002O>.\n-/\ntheorem has_finite_limits_of_has_equalizers_and_finite_products [HasFiniteProducts C] [HasEqualizers C] :\n    HasFiniteLimits C :=\n  ‚ü®fun J _ _ => { has_limit := fun F => has_limit_of_equalizer_and_product F }‚ü©\n#align has_finite_limits_of_has_equalizers_and_finite_products has_finite_limits_of_has_equalizers_and_finite_products\n\n",
 "has_finite_colimits_of_has_initial_and_pushouts":
 "-- See note [dsimp, simp].\ntheorem has_finite_colimits_of_has_initial_and_pushouts [HasInitial C] [HasPushouts C] : HasFiniteColimits C :=\n  @hasFiniteColimits_of_hasCoequalizers_and_finite_coproducts _\n    (@hasFiniteCoproducts_of_has_binary_and_initial _ (hasBinaryCoproducts_of_hasInitial_and_pushouts C) inferInstance)\n    (@hasCoequalizers_of_hasPushouts_and_binary_coproducts _ (hasBinaryCoproducts_of_hasInitial_and_pushouts C)\n      inferInstance)\n#align has_finite_colimits_of_has_initial_and_pushouts has_finite_colimits_of_has_initial_and_pushouts\n\n",
 "has_finite_colimits_of_has_coequalizers_and_finite_coproducts":
 "/-- Any category with finite coproducts and coequalizers has all finite colimits.\n\nSee <https://stacks.math.columbia.edu/tag/002Q>.\n-/\ntheorem has_finite_colimits_of_has_coequalizers_and_finite_coproducts [HasFiniteCoproducts C] [HasCoequalizers C] :\n    HasFiniteColimits C :=\n  ‚ü®fun J _ _ => { has_colimit := fun F => has_colimit_of_coequalizer_and_coproduct F }‚ü©\n#align has_finite_colimits_of_has_coequalizers_and_finite_coproducts has_finite_colimits_of_has_coequalizers_and_finite_coproducts\n\n",
 "has_colimits_of_has_coequalizers_and_coproducts":
 "/-- Any category with coproducts and coequalizers has all colimits.\n\nSee <https://stacks.math.columbia.edu/tag/002P>.\n-/\ntheorem has_colimits_of_has_coequalizers_and_coproducts [HasCoproducts.{w} C] [HasCoequalizers C] :\n    HasColimitsOfSize.{w, w} C :=\n  { has_colimits_of_shape := fun J ùí• => { has_colimit := fun F => has_colimit_of_coequalizer_and_coproduct F } }\n#align has_colimits_of_has_coequalizers_and_coproducts has_colimits_of_has_coequalizers_and_coproducts\n\n",
 "has_colimit_of_coequalizer_and_coproduct":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚•§ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚ü∂ ¬ª -/\n-- We hide the \"implementation details\" inside a namespace\n/-- Given the existence of the appropriate (possibly finite) coproducts and coequalizers,\nwe know a colimit of `F` exists.\n(This assumes the existence of all coequalizers, which is technically stronger than needed.)\n-/\ntheorem has_colimit_of_coequalizer_and_coproduct (F : ¬´expr ‚•§ ¬ª J C) [HasColimit (Discrete.functor F.obj)]\n    [HasColimit (Discrete.functor fun f : Œ£p : J √ó J, ¬´expr ‚ü∂ ¬ª p.1 p.2 => F.obj f.1.1)] [HasCoequalizers C] :\n    HasColimit F :=\n  HasColimit.mk (colimitCoconeOfCoequalizerAndCoproduct F)\n#align has_colimit_of_coequalizer_and_coproduct has_colimit_of_coequalizer_and_coproduct\n\n"}