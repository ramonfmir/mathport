{"has_limits_of_has_equalizers_and_products":
 "/-- Any category with products and equalizers has all limits.\n\nSee <https://stacks.math.columbia.edu/tag/002N>.\n-/\ntheorem has_limits_of_has_equalizers_and_products [has_products.{w} C] [has_equalizers C] :\n    has_limits_of_size.{w, w} C :=\n  { has_limits_of_shape := fun J ùí• => { has_limit := fun F => has_limit_of_equalizer_and_product F } }\n#align has_limits_of_has_equalizers_and_products has_limits_of_has_equalizers_and_products\n\n",
 "has_limit_of_equalizer_and_product":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚•§ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚ü∂ ¬ª -/\n/-\nCopyright (c) 2020 Bhavik Mehta. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Bhavik Mehta, Scott Morrison\n-/\n-- We hide the \"implementation details\" inside a namespace\n/-- Given the existence of the appropriate (possibly finite) products and equalizers, we know a limit of\n`F` exists.\n(This assumes the existence of all equalizers, which is technically stronger than needed.)\n-/\ntheorem has_limit_of_equalizer_and_product (F : ¬´expr ‚•§ ¬ª J C) [has_limit (discrete.functor F.obj)]\n    [has_limit (discrete.functor fun f : Œ£p : J √ó J, ¬´expr ‚ü∂ ¬ª p.1 p.2 => F.obj f.1.2)] [has_equalizers C] :\n    has_limit F :=\n  has_limit.mk (limit_cone_of_equalizer_and_product F)\n#align has_limit_of_equalizer_and_product has_limit_of_equalizer_and_product\n\n",
 "has_finite_limits_of_has_terminal_and_pullbacks":
 "-- See note [dsimp, simp].\ntheorem has_finite_limits_of_has_terminal_and_pullbacks [has_terminal C] [has_pullbacks C] : has_finite_limits C :=\n  @has_finite_limits_of_has_equalizers_and_finite_products _\n    (@has_finite_products_of_has_binary_and_terminal _ (has_binary_products_of_has_terminal_and_pullbacks C)\n      infer_instance)\n    (@has_equalizers_of_has_pullbacks_and_binary_products _ (has_binary_products_of_has_terminal_and_pullbacks C)\n      infer_instance)\n#align has_finite_limits_of_has_terminal_and_pullbacks has_finite_limits_of_has_terminal_and_pullbacks\n\n",
 "has_finite_limits_of_has_equalizers_and_finite_products":
 "/-- Any category with finite products and equalizers has all finite limits.\n\nSee <https://stacks.math.columbia.edu/tag/002O>.\n-/\ntheorem has_finite_limits_of_has_equalizers_and_finite_products [has_finite_products C] [has_equalizers C] :\n    has_finite_limits C :=\n  ‚ü®fun J _ _ => { has_limit := fun F => has_limit_of_equalizer_and_product F }‚ü©\n#align has_finite_limits_of_has_equalizers_and_finite_products has_finite_limits_of_has_equalizers_and_finite_products\n\n",
 "has_finite_colimits_of_has_initial_and_pushouts":
 "-- See note [dsimp, simp].\ntheorem has_finite_colimits_of_has_initial_and_pushouts [has_initial C] [has_pushouts C] : has_finite_colimits C :=\n  @has_finite_colimits_of_has_coequalizers_and_finite_coproducts _\n    (@has_finite_coproducts_of_has_binary_and_initial _ (has_binary_coproducts_of_has_initial_and_pushouts C)\n      infer_instance)\n    (@has_coequalizers_of_has_pushouts_and_binary_coproducts _ (has_binary_coproducts_of_has_initial_and_pushouts C)\n      infer_instance)\n#align has_finite_colimits_of_has_initial_and_pushouts has_finite_colimits_of_has_initial_and_pushouts\n\n",
 "has_finite_colimits_of_has_coequalizers_and_finite_coproducts":
 "/-- Any category with finite coproducts and coequalizers has all finite colimits.\n\nSee <https://stacks.math.columbia.edu/tag/002Q>.\n-/\ntheorem has_finite_colimits_of_has_coequalizers_and_finite_coproducts [has_finite_coproducts C] [has_coequalizers C] :\n    has_finite_colimits C :=\n  ‚ü®fun J _ _ => { has_colimit := fun F => has_colimit_of_coequalizer_and_coproduct F }‚ü©\n#align\n  has_finite_colimits_of_has_coequalizers_and_finite_coproducts has_finite_colimits_of_has_coequalizers_and_finite_coproducts\n\n",
 "has_colimits_of_has_coequalizers_and_coproducts":
 "/-- Any category with coproducts and coequalizers has all colimits.\n\nSee <https://stacks.math.columbia.edu/tag/002P>.\n-/\ntheorem has_colimits_of_has_coequalizers_and_coproducts [has_coproducts.{w} C] [has_coequalizers C] :\n    has_colimits_of_size.{w, w} C :=\n  { has_colimits_of_shape := fun J ùí• => { has_colimit := fun F => has_colimit_of_coequalizer_and_coproduct F } }\n#align has_colimits_of_has_coequalizers_and_coproducts has_colimits_of_has_coequalizers_and_coproducts\n\n",
 "has_colimit_of_coequalizer_and_coproduct":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚•§ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚ü∂ ¬ª -/\n-- We hide the \"implementation details\" inside a namespace\n/-- Given the existence of the appropriate (possibly finite) coproducts and coequalizers,\nwe know a colimit of `F` exists.\n(This assumes the existence of all coequalizers, which is technically stronger than needed.)\n-/\ntheorem has_colimit_of_coequalizer_and_coproduct (F : ¬´expr ‚•§ ¬ª J C) [has_colimit (discrete.functor F.obj)]\n    [has_colimit (discrete.functor fun f : Œ£p : J √ó J, ¬´expr ‚ü∂ ¬ª p.1 p.2 => F.obj f.1.1)] [has_coequalizers C] :\n    has_colimit F :=\n  has_colimit.mk (colimit_cocone_of_coequalizer_and_coproduct F)\n#align has_colimit_of_coequalizer_and_coproduct has_colimit_of_coequalizer_and_coproduct\n\n"}