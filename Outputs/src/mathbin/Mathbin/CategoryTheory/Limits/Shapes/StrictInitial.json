{"subsingleton_to":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤_ » -/\ntheorem terminal.subsingleton_to {A : C} : subsingleton («expr ⟶ » («expr⊤_ » C) A) :=\n  terminalIsTerminal.subsingleton_to\n#align terminal.subsingleton_to terminal.subsingleton_to\n\n",
 "strict_hom_ext":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem is_terminal.strict_hom_ext (hI : IsTerminal I) {A : C} (f g : «expr ⟶ » I A) : f = g :=\n  by\n  haveI := hI.is_iso_from f\n  haveI := hI.is_iso_from g\n  exact eq_of_inv_eq_inv (hI.hom_ext (inv f) (inv g))\n#align is_terminal.strict_hom_ext is_terminal.strict_hom_ext\n\n",
 "mul_is_initial_inv":
 "@[simp]\ntheorem mul_is_initial_inv (X : C) [HasBinaryProduct X I] (hI : IsInitial I) : (mulIsInitial X hI).inv = hI.to _ :=\n  hI.hom_ext _ _\n#align mul_is_initial_inv mul_is_initial_inv\n\n",
 "mul_initial_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥_ » -/\n@[simp]\ntheorem mul_initial_inv (X : C) [HasBinaryProduct X («expr⊥_ » C)] : (mulInitial X).inv = initial.to _ :=\n  subsingleton.elim _ _\n#align mul_initial_inv mul_initial_inv\n\n",
 "limit_π_is_iso_of_is_strict_terminal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (j «expr ≠ » i) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/-- If all but one object in a diagram is strict terminal, the the limit is isomorphic to the\nsaid object via `limit.π`. -/\ntheorem limit_π_is_iso_of_is_strict_terminal (F : «expr ⥤ » J C) [HasLimit F] (i : J)\n    (H : ∀ (j) (_ : j ≠ i), IsTerminal (F.obj j)) [subsingleton («expr ⟶ » i i)] : IsIso (limit.π F i) := by\n  classical\n    refine' ⟨⟨limit.lift _ ⟨_, ⟨_, _⟩⟩, _, _⟩⟩\n    ·\n      exact fun j =>\n        dite (j = i)\n          (fun h =>\n            eq_to_hom\n              (by\n                cases h\n                rfl))\n          fun h => (H _ h).from _\n    · intro j k f\n      split_ifs\n      · cases h\n        cases h_1\n        obtain rfl : f = («expr𝟙») _ := subsingleton.elim _ _\n        simpa\n      · cases h\n        erw [category.comp_id]\n        haveI : is_iso (F.map f) := (H _ h_1).is_iso_from _\n        rw [← is_iso.comp_inv_eq]\n        apply (H _ h_1).hom_ext\n      · cases h_1\n        apply (H _ h).hom_ext\n      · apply (H _ h).hom_ext\n    · ext\n      rw [assoc, limit.lift_π]\n      dsimp only\n      split_ifs\n      · cases h\n        rw [id_comp, eq_to_hom_refl]\n        exact comp_id _\n      · apply (H _ h).hom_ext\n    · rw [limit.lift_π]\n      simpa\n#align limit_π_is_iso_of_is_strict_terminal limit_π_is_iso_of_is_strict_terminal\n\n",
 "is_iso_to":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/-\nCopyright (c) 2021 Bhavik Mehta. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Bhavik Mehta\n-/\ntheorem is_initial.is_iso_to (hI : IsInitial I) {A : C} (f : «expr ⟶ » A I) : IsIso f :=\n  has_strict_initial_objects.out f hI\n#align is_initial.is_iso_to is_initial.is_iso_to\n\n",
 "is_iso_from":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem is_terminal.is_iso_from (hI : IsTerminal I) {A : C} (f : «expr ⟶ » I A) : IsIso f :=\n  has_strict_terminal_objects.out f hI\n#align is_terminal.is_iso_from is_terminal.is_iso_from\n\n",
 "is_initial_mul_inv":
 "@[simp]\ntheorem is_initial_mul_inv (X : C) [HasBinaryProduct I X] (hI : IsInitial I) : (isInitialMul X hI).inv = hI.to _ :=\n  hI.hom_ext _ _\n#align is_initial_mul_inv is_initial_mul_inv\n\n",
 "initial_mul_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥_ » -/\n@[simp]\ntheorem initial_mul_inv (X : C) [HasBinaryProduct («expr⊥_ » C) X] : (initialMul X).inv = initial.to _ :=\n  subsingleton.elim _ _\n#align initial_mul_inv initial_mul_inv\n\n",
 "hom_ext":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤_ » -/\n@[ext]\ntheorem terminal.hom_ext {A : C} (f g : «expr ⟶ » («expr⊤_ » C) A) : f = g :=\n  terminalIsTerminal.strict_hom_ext _ _\n#align terminal.hom_ext terminal.hom_ext\n\n",
 "has_strict_terminal_objects_of_terminal_is_strict":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/-- If `C` has an object such that every morphism *from* it is an isomorphism, then `C`\nhas strict terminal objects. -/\ntheorem has_strict_terminal_objects_of_terminal_is_strict (I : C) (h : ∀ (A) (f : «expr ⟶ » I A), IsIso f) :\n    HasStrictTerminalObjects C :=\n  {\n    out := fun I' A f hI' =>\n      haveI := h A («expr ≫ » (hI'.from _) f)\n      ⟨⟨«expr ≫ » (inv («expr ≫ » (hI'.from I) f)) (hI'.from I), hI'.hom_ext _ _, by rw [assoc, is_iso.inv_hom_id]⟩⟩ }\n#align has_strict_terminal_objects_of_terminal_is_strict has_strict_terminal_objects_of_terminal_is_strict\n\n",
 "has_strict_initial_objects_of_initial_is_strict":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥_ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥_ » -/\n/-- If `C` has an initial object such that every morphism *to* it is an isomorphism, then `C`\nhas strict initial objects. -/\ntheorem has_strict_initial_objects_of_initial_is_strict [HasInitial C]\n    (h : ∀ (A) (f : «expr ⟶ » A («expr⊥_ » C)), IsIso f) : HasStrictInitialObjects C :=\n  {\n    out := fun I A f hI =>\n      haveI := h A («expr ≫ » f (hI.to _))\n      ⟨⟨«expr ≫ » (hI.to _) (inv («expr ≫ » f (hI.to («expr⊥_ » C)))), by rw [← assoc, is_iso.hom_inv_id],\n          hI.hom_ext _ _⟩⟩ }\n#align has_strict_initial_objects_of_initial_is_strict has_strict_initial_objects_of_initial_is_strict\n\n"}