{"subsingleton_to":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤_ Â» -/\ntheorem terminal.subsingleton_to {A : C} : subsingleton (Â«expr âŸ¶ Â» (Â«exprâŠ¤_ Â» C) A) :=\n  terminalIsTerminal.subsingleton_to\n#align terminal.subsingleton_to terminal.subsingleton_to\n\n",
 "strict_hom_ext":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem is_terminal.strict_hom_ext (hI : IsTerminal I) {A : C} (f g : Â«expr âŸ¶ Â» I A) : f = g :=\n  by\n  haveI := hI.is_iso_from f\n  haveI := hI.is_iso_from g\n  exact eq_of_inv_eq_inv (hI.hom_ext (inv f) (inv g))\n#align is_terminal.strict_hom_ext is_terminal.strict_hom_ext\n\n",
 "mul_is_initial_inv":
 "@[simp]\ntheorem mul_is_initial_inv (X : C) [HasBinaryProduct X I] (hI : IsInitial I) : (mulIsInitial X hI).inv = hI.to _ :=\n  hI.hom_ext _ _\n#align mul_is_initial_inv mul_is_initial_inv\n\n",
 "mul_initial_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¥_ Â» -/\n@[simp]\ntheorem mul_initial_inv (X : C) [HasBinaryProduct X (Â«exprâŠ¥_ Â» C)] : (mulInitial X).inv = initial.to _ :=\n  subsingleton.elim _ _\n#align mul_initial_inv mul_initial_inv\n\n",
 "limit_Ï€_is_iso_of_is_strict_terminal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (j Â«expr â‰  Â» i) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/-- If all but one object in a diagram is strict terminal, the the limit is isomorphic to the\nsaid object via `limit.Ï€`. -/\ntheorem limit_Ï€_is_iso_of_is_strict_terminal (F : Â«expr â¥¤ Â» J C) [HasLimit F] (i : J)\n    (H : âˆ€ (j) (_ : j â‰  i), IsTerminal (F.obj j)) [subsingleton (Â«expr âŸ¶ Â» i i)] : IsIso (limit.Ï€ F i) := by\n  classical\n    refine' âŸ¨âŸ¨limit.lift _ âŸ¨_, âŸ¨_, _âŸ©âŸ©, _, _âŸ©âŸ©\n    Â·\n      exact fun j =>\n        dite (j = i)\n          (fun h =>\n            eq_to_hom\n              (by\n                cases h\n                rfl))\n          fun h => (H _ h).from _\n    Â· intro j k f\n      split_ifs\n      Â· cases h\n        cases h_1\n        obtain rfl : f = (Â«exprğŸ™Â») _ := subsingleton.elim _ _\n        simpa\n      Â· cases h\n        erw [category.comp_id]\n        haveI : is_iso (F.map f) := (H _ h_1).is_iso_from _\n        rw [â† is_iso.comp_inv_eq]\n        apply (H _ h_1).hom_ext\n      Â· cases h_1\n        apply (H _ h).hom_ext\n      Â· apply (H _ h).hom_ext\n    Â· ext\n      rw [assoc, limit.lift_Ï€]\n      dsimp only\n      split_ifs\n      Â· cases h\n        rw [id_comp, eq_to_hom_refl]\n        exact comp_id _\n      Â· apply (H _ h).hom_ext\n    Â· rw [limit.lift_Ï€]\n      simpa\n#align limit_Ï€_is_iso_of_is_strict_terminal limit_Ï€_is_iso_of_is_strict_terminal\n\n",
 "is_iso_to":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/-\nCopyright (c) 2021 Bhavik Mehta. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Bhavik Mehta\n-/\ntheorem is_initial.is_iso_to (hI : IsInitial I) {A : C} (f : Â«expr âŸ¶ Â» A I) : IsIso f :=\n  has_strict_initial_objects.out f hI\n#align is_initial.is_iso_to is_initial.is_iso_to\n\n",
 "is_iso_from":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem is_terminal.is_iso_from (hI : IsTerminal I) {A : C} (f : Â«expr âŸ¶ Â» I A) : IsIso f :=\n  has_strict_terminal_objects.out f hI\n#align is_terminal.is_iso_from is_terminal.is_iso_from\n\n",
 "is_initial_mul_inv":
 "@[simp]\ntheorem is_initial_mul_inv (X : C) [HasBinaryProduct I X] (hI : IsInitial I) : (isInitialMul X hI).inv = hI.to _ :=\n  hI.hom_ext _ _\n#align is_initial_mul_inv is_initial_mul_inv\n\n",
 "initial_mul_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¥_ Â» -/\n@[simp]\ntheorem initial_mul_inv (X : C) [HasBinaryProduct (Â«exprâŠ¥_ Â» C) X] : (initialMul X).inv = initial.to _ :=\n  subsingleton.elim _ _\n#align initial_mul_inv initial_mul_inv\n\n",
 "hom_ext":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤_ Â» -/\n@[ext]\ntheorem terminal.hom_ext {A : C} (f g : Â«expr âŸ¶ Â» (Â«exprâŠ¤_ Â» C) A) : f = g :=\n  terminalIsTerminal.strict_hom_ext _ _\n#align terminal.hom_ext terminal.hom_ext\n\n",
 "has_strict_terminal_objects_of_terminal_is_strict":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/-- If `C` has an object such that every morphism *from* it is an isomorphism, then `C`\nhas strict terminal objects. -/\ntheorem has_strict_terminal_objects_of_terminal_is_strict (I : C) (h : âˆ€ (A) (f : Â«expr âŸ¶ Â» I A), IsIso f) :\n    HasStrictTerminalObjects C :=\n  {\n    out := fun I' A f hI' =>\n      haveI := h A (Â«expr â‰« Â» (hI'.from _) f)\n      âŸ¨âŸ¨Â«expr â‰« Â» (inv (Â«expr â‰« Â» (hI'.from I) f)) (hI'.from I), hI'.hom_ext _ _, by rw [assoc, is_iso.inv_hom_id]âŸ©âŸ© }\n#align has_strict_terminal_objects_of_terminal_is_strict has_strict_terminal_objects_of_terminal_is_strict\n\n",
 "has_strict_initial_objects_of_initial_is_strict":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¥_ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¥_ Â» -/\n/-- If `C` has an initial object such that every morphism *to* it is an isomorphism, then `C`\nhas strict initial objects. -/\ntheorem has_strict_initial_objects_of_initial_is_strict [HasInitial C]\n    (h : âˆ€ (A) (f : Â«expr âŸ¶ Â» A (Â«exprâŠ¥_ Â» C)), IsIso f) : HasStrictInitialObjects C :=\n  {\n    out := fun I A f hI =>\n      haveI := h A (Â«expr â‰« Â» f (hI.to _))\n      âŸ¨âŸ¨Â«expr â‰« Â» (hI.to _) (inv (Â«expr â‰« Â» f (hI.to (Â«exprâŠ¥_ Â» C)))), by rw [â† assoc, is_iso.hom_inv_id],\n          hI.hom_ext _ _âŸ©âŸ© }\n#align has_strict_initial_objects_of_initial_is_strict has_strict_initial_objects_of_initial_is_strict\n\n"}