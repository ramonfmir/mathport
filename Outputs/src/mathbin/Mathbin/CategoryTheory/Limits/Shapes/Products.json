{"ι_reindex_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem sigma.ι_reindex_inv (b : β) : «expr ≫ » (sigma.ι f (ε b)) (sigma.reindex ε f).inv = sigma.ι (f ∘ ε) b := by\n  simp [iso.comp_inv_eq]\n#align sigma.ι_reindex_inv sigma.ι_reindex_inv\n\n",
 "ι_reindex_hom":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem sigma.ι_reindex_hom (b : β) : «expr ≫ » (sigma.ι (f ∘ ε) b) (sigma.reindex ε f).hom = sigma.ι f (ε b) :=\n  by\n  dsimp [sigma.reindex]\n  simp only [has_colimit.iso_of_equivalence_hom_π, equivalence.equivalence_mk'_unit, discrete.equivalence_unit_iso,\n    discrete.nat_iso_hom_app, eq_to_iso.hom, eq_to_hom_map, discrete.nat_iso_inv_app]\n  dsimp\n  simp [eq_to_hom_map, ← colimit.w (discrete.functor f) (discrete.eq_to_hom' (ε.apply_symm_apply (ε b)))]\n#align sigma.ι_reindex_hom sigma.ι_reindex_hom\n\n",
 "ι_comp_sigma_comparison":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem ι_comp_sigma_comparison [has_coproduct f] [has_coproduct fun b => G.obj (f b)] (b : β) :\n    «expr ≫ » (sigma.ι _ b) (sigma_comparison G f) = G.map (sigma.ι f b) :=\n  colimit.ι_desc _ (discrete.mk b)\n#align ι_comp_sigma_comparison ι_comp_sigma_comparison\n\n",
 "sigma_comparison_map_desc":
 "/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:76:14: unsupported tactic `discrete_cases #[] -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem sigma_comparison_map_desc [has_coproduct f] [has_coproduct fun b => G.obj (f b)] (P : C)\n    (g : ∀ j, «expr ⟶ » (f j) P) :\n    «expr ≫ » (sigma_comparison G f) (G.map (sigma.desc g)) = sigma.desc fun j => G.map (g j) :=\n  by\n  ext\n  trace \"./././Mathport/Syntax/Translate/Tactic/Builtin.lean:76:14: unsupported tactic `discrete_cases #[]\"\n  simp [← G.map_comp]\n#align sigma_comparison_map_desc sigma_comparison_map_desc\n\n",
 "reindex_inv_π":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem pi.reindex_inv_π (b : β) : «expr ≫ » (pi.reindex ε f).inv (pi.π (f ∘ ε) b) = pi.π f (ε b) := by\n  simp [iso.inv_comp_eq]\n#align pi.reindex_inv_π pi.reindex_inv_π\n\n",
 "reindex_hom_π":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem pi.reindex_hom_π (b : β) : «expr ≫ » (pi.reindex ε f).hom (pi.π f (ε b)) = pi.π (f ∘ ε) b :=\n  by\n  dsimp [pi.reindex]\n  simp only [has_limit.iso_of_equivalence_hom_π, discrete.nat_iso_inv_app, equivalence.equivalence_mk'_counit,\n    discrete.equivalence_counit_iso, discrete.nat_iso_hom_app, eq_to_iso.hom, eq_to_hom_map]\n  dsimp\n  simpa [eq_to_hom_map] using limit.w (discrete.functor (f ∘ ε)) (discrete.eq_to_hom' (ε.symm_apply_apply b))\n#align pi.reindex_hom_π pi.reindex_hom_π\n\n",
 "pi_comparison_comp_π":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem pi_comparison_comp_π [has_product f] [has_product fun b => G.obj (f b)] (b : β) :\n    «expr ≫ » (pi_comparison G f) (pi.π _ b) = G.map (pi.π f b) :=\n  limit.lift_π _ (discrete.mk b)\n#align pi_comparison_comp_π pi_comparison_comp_π\n\n",
 "map_lift_pi_comparison":
 "/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:76:14: unsupported tactic `discrete_cases #[] -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem map_lift_pi_comparison [has_product f] [has_product fun b => G.obj (f b)] (P : C) (g : ∀ j, «expr ⟶ » P (f j)) :\n    «expr ≫ » (G.map (pi.lift g)) (pi_comparison G f) = pi.lift fun j => G.map (g j) :=\n  by\n  ext\n  trace \"./././Mathport/Syntax/Translate/Tactic/Builtin.lean:76:14: unsupported tactic `discrete_cases #[]\"\n  simp [← G.map_comp]\n#align map_lift_pi_comparison map_lift_pi_comparison\n\n",
 "has_smallest_products_of_has_products":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≌ » -/\ntheorem has_smallest_products_of_has_products [has_products.{w} C] : has_products.{0} C := fun J =>\n  has_limits_of_shape_of_equivalence (discrete.equivalence equiv.ulift : «expr ≌ » (discrete (ULift.{w} J)) _)\n#align has_smallest_products_of_has_products has_smallest_products_of_has_products\n\n",
 "has_smallest_coproducts_of_has_coproducts":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≌ » -/\ntheorem has_smallest_coproducts_of_has_coproducts [has_coproducts.{w} C] : has_coproducts.{0} C := fun J =>\n  has_colimits_of_shape_of_equivalence (discrete.equivalence equiv.ulift : «expr ≌ » (discrete (ULift.{w} J)) _)\n#align has_smallest_coproducts_of_has_coproducts has_smallest_coproducts_of_has_coproducts\n\n",
 "has_products_of_limit_fans":
 "theorem has_products_of_limit_fans (lf : ∀ {J : Type w} (f : J → C), fan f)\n    (lf_is_limit : ∀ {J : Type w} (f : J → C), is_limit (lf f)) : has_products.{w} C := fun J : Type w =>\n  {\n    has_limit := fun F =>\n      has_limit.mk\n        ⟨(cones.postcompose discrete.nat_iso_functor.inv).obj (lf fun j => F.obj ⟨j⟩),\n          (is_limit.postcompose_inv_equiv _ _).symm (lf_is_limit _)⟩ }\n#align has_products_of_limit_fans has_products_of_limit_fans\n\n",
 "fan_mk_proj":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/-\nCopyright (c) 2018 Scott Morrison. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Scott Morrison, Bhavik Mehta\n-/\n-- We don't need an analogue of `pair` (for binary products), `parallel_pair` (for equalizers),\n-- or `(co)span`, since we already have `discrete.functor`.\n-- FIXME dualize as needed below (and rename?)\n@[simp]\ntheorem fan_mk_proj {f : β → C} (P : C) (p : ∀ b, «expr ⟶ » P (f b)) (j : β) : (fan.mk P p).proj j = p j :=\n  rfl\n#align fan_mk_proj fan_mk_proj\n\n"}