{"ι_reindex_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem sigma.ι_reindex_inv (b : β) : «expr ≫ » (Sigma.ι f (ε b)) (Sigma.reindex ε f).inv = Sigma.ι (f ∘ ε) b := by\n  simp [iso.comp_inv_eq]\n#align sigma.ι_reindex_inv sigma.ι_reindex_inv\n\n",
 "ι_reindex_hom":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem sigma.ι_reindex_hom (b : β) : «expr ≫ » (Sigma.ι (f ∘ ε) b) (Sigma.reindex ε f).hom = Sigma.ι f (ε b) :=\n  by\n  dsimp [sigma.reindex]\n  simp only [has_colimit.iso_of_equivalence_hom_π, equivalence.equivalence_mk'_unit, discrete.equivalence_unit_iso,\n    discrete.nat_iso_hom_app, eq_to_iso.hom, eq_to_hom_map, discrete.nat_iso_inv_app]\n  dsimp\n  simp [eq_to_hom_map, ← colimit.w (discrete.functor f) (discrete.eq_to_hom' (ε.apply_symm_apply (ε b)))]\n#align sigma.ι_reindex_hom sigma.ι_reindex_hom\n\n",
 "ι_comp_sigma_comparison":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem ι_comp_sigma_comparison [HasCoproduct f] [HasCoproduct fun b => G.obj (f b)] (b : β) :\n    «expr ≫ » (Sigma.ι _ b) (sigmaComparison G f) = G.map (Sigma.ι f b) :=\n  colimit.ι_desc _ (discrete.mk b)\n#align ι_comp_sigma_comparison ι_comp_sigma_comparison\n\n",
 "sigma_comparison_map_desc":
 "/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:73:14: unsupported tactic `discrete_cases #[] -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem sigma_comparison_map_desc [HasCoproduct f] [HasCoproduct fun b => G.obj (f b)] (P : C)\n    (g : ∀ j, «expr ⟶ » (f j) P) :\n    «expr ≫ » (sigmaComparison G f) (G.map (Sigma.desc g)) = Sigma.desc fun j => G.map (g j) :=\n  by\n  ext\n  trace \"./././Mathport/Syntax/Translate/Tactic/Builtin.lean:73:14: unsupported tactic `discrete_cases #[]\"\n  simp [← G.map_comp]\n#align sigma_comparison_map_desc sigma_comparison_map_desc\n\n",
 "reindex_inv_π":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem pi.reindex_inv_π (b : β) : «expr ≫ » (Pi.reindex ε f).inv (Pi.π (f ∘ ε) b) = Pi.π f (ε b) := by\n  simp [iso.inv_comp_eq]\n#align pi.reindex_inv_π pi.reindex_inv_π\n\n",
 "reindex_hom_π":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem pi.reindex_hom_π (b : β) : «expr ≫ » (Pi.reindex ε f).hom (Pi.π f (ε b)) = Pi.π (f ∘ ε) b :=\n  by\n  dsimp [pi.reindex]\n  simp only [has_limit.iso_of_equivalence_hom_π, discrete.nat_iso_inv_app, equivalence.equivalence_mk'_counit,\n    discrete.equivalence_counit_iso, discrete.nat_iso_hom_app, eq_to_iso.hom, eq_to_hom_map]\n  dsimp\n  simpa [eq_to_hom_map] using limit.w (discrete.functor (f ∘ ε)) (discrete.eq_to_hom' (ε.symm_apply_apply b))\n#align pi.reindex_hom_π pi.reindex_hom_π\n\n",
 "pi_comparison_comp_π":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem pi_comparison_comp_π [HasProduct f] [HasProduct fun b => G.obj (f b)] (b : β) :\n    «expr ≫ » (piComparison G f) (Pi.π _ b) = G.map (Pi.π f b) :=\n  limit.lift_π _ (discrete.mk b)\n#align pi_comparison_comp_π pi_comparison_comp_π\n\n",
 "map_lift_pi_comparison":
 "/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:73:14: unsupported tactic `discrete_cases #[] -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem map_lift_pi_comparison [HasProduct f] [HasProduct fun b => G.obj (f b)] (P : C) (g : ∀ j, «expr ⟶ » P (f j)) :\n    «expr ≫ » (G.map (Pi.lift g)) (piComparison G f) = Pi.lift fun j => G.map (g j) :=\n  by\n  ext\n  trace \"./././Mathport/Syntax/Translate/Tactic/Builtin.lean:73:14: unsupported tactic `discrete_cases #[]\"\n  simp [← G.map_comp]\n#align map_lift_pi_comparison map_lift_pi_comparison\n\n",
 "has_smallest_products_of_has_products":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≌ » -/\ntheorem has_smallest_products_of_has_products [HasProducts.{w} C] : HasProducts.{0} C := fun J =>\n  hasLimitsOfShape_of_equivalence (Discrete.equivalence Equiv.ulift : «expr ≌ » (Discrete (ULift.{w} J)) _)\n#align has_smallest_products_of_has_products has_smallest_products_of_has_products\n\n",
 "has_smallest_coproducts_of_has_coproducts":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≌ » -/\ntheorem has_smallest_coproducts_of_has_coproducts [HasCoproducts.{w} C] : HasCoproducts.{0} C := fun J =>\n  hasColimitsOfShape_of_equivalence (Discrete.equivalence Equiv.ulift : «expr ≌ » (Discrete (ULift.{w} J)) _)\n#align has_smallest_coproducts_of_has_coproducts has_smallest_coproducts_of_has_coproducts\n\n",
 "has_products_of_limit_fans":
 "theorem has_products_of_limit_fans (lf : ∀ {J : Type w} (f : J → C), Fan f)\n    (lf_is_limit : ∀ {J : Type w} (f : J → C), IsLimit (lf f)) : HasProducts.{w} C := fun J : Type w =>\n  {\n    has_limit := fun F =>\n      HasLimit.mk\n        ⟨(Cones.postcompose Discrete.natIsoFunctor.inv).obj (lf fun j => F.obj ⟨j⟩),\n          (IsLimit.postcomposeInvEquiv _ _).symm (lf_is_limit _)⟩ }\n#align has_products_of_limit_fans has_products_of_limit_fans\n\n",
 "fan_mk_proj":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/-\nCopyright (c) 2018 Scott Morrison. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Scott Morrison, Bhavik Mehta\n-/\n-- We don't need an analogue of `pair` (for binary products), `parallel_pair` (for equalizers),\n-- or `(co)span`, since we already have `discrete.functor`.\n-- FIXME dualize as needed below (and rename?)\n@[simp]\ntheorem fan_mk_proj {f : β → C} (P : C) (p : ∀ b, «expr ⟶ » P (f b)) (j : β) : (Fan.mk P p).proj j = p j :=\n  rfl\n#align fan_mk_proj fan_mk_proj\n\n"}