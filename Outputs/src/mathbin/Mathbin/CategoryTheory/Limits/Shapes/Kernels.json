{"π_of_π":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp]\ntheorem cokernel_cofork.π_of_π {X Y P : C} (f : «expr ⟶ » X Y) (π : «expr ⟶ » Y P) (w : «expr ≫ » f π = 0) :\n    Cofork.π (CokernelCofork.ofπ π w) = π :=\n  rfl\n#align cokernel_cofork.π_of_π cokernel_cofork.π_of_π\n\n",
 "π_of_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/-- The cokernel of a zero morphism is an isomorphism -/\ntheorem cokernel.π_of_zero : IsIso (cokernel.π (0 : «expr ⟶ » X Y)) :=\n  coequalizer.π_of_self _\n#align cokernel.π_of_zero cokernel.π_of_zero\n\n",
 "π_of_epi":
 "-- TODO the remainder of this section has obvious generalizations to `has_coequalizer f g`.\n/-- The cokernel morphism of an epimorphism is a zero morphism -/\ntheorem cokernel.π_of_epi [HasCokernel f] [Epi f] : cokernel.π f = 0 :=\n  zero_of_target_iso_zero _ (cokernel.ofEpi f)\n#align cokernel.π_of_epi cokernel.π_of_epi\n\n",
 "π_eq_zero":
 "@[simp]\ntheorem cokernel_cofork.π_eq_zero (s : CokernelCofork f) : s.ι.app zero = 0 := by simp [cofork.app_zero_eq_comp_π_right]\n#align cokernel_cofork.π_eq_zero cokernel_cofork.π_eq_zero\n\n",
 "π_desc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem cokernel.π_desc {W : C} (k : «expr ⟶ » Y W) (h : «expr ≫ » f k = 0) :\n    «expr ≫ » (cokernel.π f) (cokernel.desc f k h) = k :=\n  (cokernelIsCokernel f).fac (CokernelCofork.ofπ k h) walking_parallel_pair.one\n#align cokernel.π_desc cokernel.π_desc\n\n",
 "π_comp_cokernel_iso_of_eq_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem π_comp_cokernel_iso_of_eq_inv {f g : «expr ⟶ » X Y} [HasCokernel f] [HasCokernel g] (h : f = g) :\n    «expr ≫ » (cokernel.π _) (cokernelIsoOfEq h).inv = cokernel.π _ :=\n  by\n  induction h\n  simp\n#align π_comp_cokernel_iso_of_eq_inv π_comp_cokernel_iso_of_eq_inv\n\n",
 "π_comp_cokernel_iso_of_eq_hom":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem π_comp_cokernel_iso_of_eq_hom {f g : «expr ⟶ » X Y} [HasCokernel f] [HasCokernel g] (h : f = g) :\n    «expr ≫ » (cokernel.π _) (cokernelIsoOfEq h).hom = cokernel.π _ :=\n  by\n  induction h\n  simp\n#align π_comp_cokernel_iso_of_eq_hom π_comp_cokernel_iso_of_eq_hom\n\n",
 "π_comp_cokernel_comparison":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem π_comp_cokernel_comparison [HasCokernel f] [HasCokernel (G.map f)] :\n    «expr ≫ » (cokernel.π (G.map f)) (cokernelComparison f G) = G.map (cokernel.π _) :=\n  cokernel.π_desc _ _ _\n#align π_comp_cokernel_comparison π_comp_cokernel_comparison\n\n",
 "ι_of_ι":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp]\ntheorem kernel_fork.ι_of_ι {X Y P : C} (f : «expr ⟶ » X Y) (ι : «expr ⟶ » P X) (w : «expr ≫ » ι f = 0) :\n    Fork.ι (KernelFork.ofι ι w) = ι :=\n  rfl\n#align kernel_fork.ι_of_ι kernel_fork.ι_of_ι\n\n",
 "ι_of_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/-- The kernel morphism of a zero morphism is an isomorphism -/\ntheorem kernel.ι_of_zero : IsIso (kernel.ι (0 : «expr ⟶ » X Y)) :=\n  equalizer.ι_of_self _\n#align kernel.ι_of_zero kernel.ι_of_zero\n\n",
 "ι_of_mono":
 "/-- The kernel morphism of a monomorphism is a zero morphism -/\ntheorem kernel.ι_of_mono [HasKernel f] [Mono f] : kernel.ι f = 0 :=\n  zero_of_source_iso_zero _ (kernel.ofMono f)\n#align kernel.ι_of_mono kernel.ι_of_mono\n\n",
 "map_lift_kernel_comparison":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem map_lift_kernel_comparison [HasKernel f] [HasKernel (G.map f)] {Z : C} {h : «expr ⟶ » Z X}\n    (w : «expr ≫ » h f = 0) :\n    «expr ≫ » (G.map (kernel.lift _ h w)) (kernelComparison f G) =\n      kernel.lift _ (G.map h) (by simp only [← G.map_comp, w, functor.map_zero]) :=\n  by\n  ext\n  simp [← G.map_comp]\n#align map_lift_kernel_comparison map_lift_kernel_comparison\n\n",
 "map_desc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/-- Given a commutative diagram\n    X --f--> Y --g--> Z\n    |        |        |\n    |        |        |\n    v        v        v\n    X' -f'-> Y' -g'-> Z'\nwith horizontal arrows composing to zero,\nthen we obtain a commutative square\n   cokernel f ---> Z\n   |               |\n   | cokernel.map  |\n   |               |\n   v               v\n   cokernel f' --> Z'\n-/\ntheorem cokernel.map_desc {X Y Z X' Y' Z' : C} (f : «expr ⟶ » X Y) [HasCokernel f] (g : «expr ⟶ » Y Z)\n    (w : «expr ≫ » f g = 0) (f' : «expr ⟶ » X' Y') [HasCokernel f'] (g' : «expr ⟶ » Y' Z') (w' : «expr ≫ » f' g' = 0)\n    (p : «expr ⟶ » X X') (q : «expr ⟶ » Y Y') (r : «expr ⟶ » Z Z') (h₁ : «expr ≫ » f q = «expr ≫ » p f')\n    (h₂ : «expr ≫ » g r = «expr ≫ » q g') :\n    «expr ≫ » (cokernel.map f f' p q h₁) (cokernel.desc f' g' w') = «expr ≫ » (cokernel.desc f g w) r :=\n  by\n  ext\n  simp [h₂]\n#align cokernel.map_desc cokernel.map_desc\n\n",
 "lift_ι":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem kernel.lift_ι {W : C} (k : «expr ⟶ » W X) (h : «expr ≫ » k f = 0) :\n    «expr ≫ » (kernel.lift f k h) (kernel.ι f) = k :=\n  (kernelIsKernel f).fac (KernelFork.ofι k h) walking_parallel_pair.zero\n#align kernel.lift_ι kernel.lift_ι\n\n",
 "lift_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n@[simp]\ntheorem kernel.lift_zero {W : C} {h} : kernel.lift f (0 : «expr ⟶ » W X) h = 0 :=\n  by\n  ext\n  simp\n#align kernel.lift_zero kernel.lift_zero\n\n",
 "lift_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/-- Given a commutative diagram\n    X --f--> Y --g--> Z\n    |        |        |\n    |        |        |\n    v        v        v\n    X' -f'-> Y' -g'-> Z'\nwith horizontal arrows composing to zero,\nthen we obtain a commutative square\n   X ---> kernel g\n   |         |\n   |         | kernel.map\n   |         |\n   v         v\n   X' --> kernel g'\n-/\ntheorem kernel.lift_map {X Y Z X' Y' Z' : C} (f : «expr ⟶ » X Y) (g : «expr ⟶ » Y Z) [HasKernel g]\n    (w : «expr ≫ » f g = 0) (f' : «expr ⟶ » X' Y') (g' : «expr ⟶ » Y' Z') [HasKernel g'] (w' : «expr ≫ » f' g' = 0)\n    (p : «expr ⟶ » X X') (q : «expr ⟶ » Y Y') (r : «expr ⟶ » Z Z') (h₁ : «expr ≫ » f q = «expr ≫ » p f')\n    (h₂ : «expr ≫ » g r = «expr ≫ » q g') :\n    «expr ≫ » (kernel.lift g f w) (kernel.map g g' q r h₂) = «expr ≫ » p (kernel.lift g' f' w') :=\n  by\n  ext\n  simp [h₁]\n#align kernel.lift_map kernel.lift_map\n\n",
 "lift_comp_kernel_iso_of_eq_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem lift_comp_kernel_iso_of_eq_inv {Z} {f g : «expr ⟶ » X Y} [HasKernel f] [HasKernel g] (h : f = g)\n    (e : «expr ⟶ » Z X) (he) :\n    «expr ≫ » (kernel.lift _ e he) (kernelIsoOfEq h).inv = kernel.lift _ e (by simp [h, he]) :=\n  by\n  induction h\n  simp\n#align lift_comp_kernel_iso_of_eq_inv lift_comp_kernel_iso_of_eq_inv\n\n",
 "lift_comp_kernel_iso_of_eq_hom":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem lift_comp_kernel_iso_of_eq_hom {Z} {f g : «expr ⟶ » X Y} [HasKernel f] [HasKernel g] (h : f = g)\n    (e : «expr ⟶ » Z X) (he) :\n    «expr ≫ » (kernel.lift _ e he) (kernelIsoOfEq h).hom = kernel.lift _ e (by simp [← h, he]) :=\n  by\n  induction h\n  simp\n#align lift_comp_kernel_iso_of_eq_hom lift_comp_kernel_iso_of_eq_hom\n\n",
 "kernel_ι_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp]\ntheorem mono_factorisation.kernel_ι_comp [HasKernel f] (F : MonoFactorisation f) : «expr ≫ » (kernel.ι f) F.e = 0 := by\n  rw [← cancel_mono F.m, zero_comp, category.assoc, F.fac, kernel.condition]\n#align mono_factorisation.kernel_ι_comp mono_factorisation.kernel_ι_comp\n\n",
 "kernel_zero_iso_source_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n@[simp]\ntheorem kernel_zero_iso_source_inv :\n    kernelZeroIsoSource.inv = kernel.lift (0 : «expr ⟶ » X Y) ((«expr𝟙») X) (by simp) :=\n  by\n  ext\n  simp [kernel_zero_iso_source]\n#align kernel_zero_iso_source_inv kernel_zero_iso_source_inv\n\n",
 "kernel_zero_iso_source_hom":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n@[simp]\ntheorem kernel_zero_iso_source_hom : kernelZeroIsoSource.hom = kernel.ι (0 : «expr ⟶ » X Y) :=\n  rfl\n#align kernel_zero_iso_source_hom kernel_zero_iso_source_hom\n\n",
 "kernel_not_iso_of_nonzero":
 "theorem kernel_not_iso_of_nonzero (w : f ≠ 0) : IsIso (kernel.ι f) → False := fun I =>\n  kernel_not_epi_of_nonzero w <| by\n    skip\n    infer_instance\n#align kernel_not_iso_of_nonzero kernel_not_iso_of_nonzero\n\n",
 "kernel_not_epi_of_nonzero":
 "theorem kernel_not_epi_of_nonzero (w : f ≠ 0) : ¬Epi (kernel.ι f) := fun I => w (eq_zero_of_epi_kernel f)\n#align kernel_not_epi_of_nonzero kernel_not_epi_of_nonzero\n\n",
 "kernel_iso_of_eq_trans":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≪≫ » -/\n@[simp]\ntheorem kernel_iso_of_eq_trans {f g h : «expr ⟶ » X Y} [HasKernel f] [HasKernel g] [HasKernel h] (w₁ : f = g)\n    (w₂ : g = h) : «expr ≪≫ » (kernelIsoOfEq w₁) (kernelIsoOfEq w₂) = kernelIsoOfEq (w₁.trans w₂) :=\n  by\n  induction w₁\n  induction w₂\n  ext\n  simp [kernel_iso_of_eq]\n#align kernel_iso_of_eq_trans kernel_iso_of_eq_trans\n\n",
 "kernel_iso_of_eq_refl":
 "@[simp]\ntheorem kernel_iso_of_eq_refl {h : f = f} : kernelIsoOfEq h = Iso.refl (kernel f) :=\n  by\n  ext\n  simp [kernel_iso_of_eq]\n#align kernel_iso_of_eq_refl kernel_iso_of_eq_refl\n\n",
 "kernel_iso_of_eq_inv_comp_ι":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem kernel_iso_of_eq_inv_comp_ι {f g : «expr ⟶ » X Y} [HasKernel f] [HasKernel g] (h : f = g) :\n    «expr ≫ » (kernelIsoOfEq h).inv (kernel.ι _) = kernel.ι _ :=\n  by\n  induction h\n  simp\n#align kernel_iso_of_eq_inv_comp_ι kernel_iso_of_eq_inv_comp_ι\n\n",
 "kernel_iso_of_eq_hom_comp_ι":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem kernel_iso_of_eq_hom_comp_ι {f g : «expr ⟶ » X Y} [HasKernel f] [HasKernel g] (h : f = g) :\n    «expr ≫ » (kernelIsoOfEq h).hom (kernel.ι _) = kernel.ι _ :=\n  by\n  induction h\n  simp\n#align kernel_iso_of_eq_hom_comp_ι kernel_iso_of_eq_hom_comp_ι\n\n",
 "kernel_comparison_comp_ι":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem kernel_comparison_comp_ι [HasKernel f] [HasKernel (G.map f)] :\n    «expr ≫ » (kernelComparison f G) (kernel.ι (G.map f)) = G.map (kernel.ι f) :=\n  kernel.lift_ι _ _ _\n#align kernel_comparison_comp_ι kernel_comparison_comp_ι\n\n",
 "kernel_comparison_comp_kernel_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[reassoc.1]\ntheorem kernel_comparison_comp_kernel_map {X' Y' : C} [HasKernel f] [HasKernel (G.map f)] (g : «expr ⟶ » X' Y')\n    [HasKernel g] [HasKernel (G.map g)] (p : «expr ⟶ » X X') (q : «expr ⟶ » Y Y')\n    (hpq : «expr ≫ » f q = «expr ≫ » p g) :\n    «expr ≫ » (kernelComparison f G)\n        (kernel.map (G.map f) (G.map g) (G.map p) (G.map q) (by rw [← G.map_comp, hpq, G.map_comp])) =\n      «expr ≫ » (G.map (kernel.map f g p q hpq)) (kernelComparison g G) :=\n  kernel.lift_map _ _ (by rw [← G.map_comp, kernel.condition, G.map_zero]) _ _\n    (by rw [← G.map_comp, kernel.condition, G.map_zero]) _ _ _\n    (by simp only [← G.map_comp] <;> exact G.congr_map (kernel.lift_ι _ _ _).symm) _\n#align kernel_comparison_comp_kernel_map kernel_comparison_comp_kernel_map\n\n",
 "is_kernel_comp_mono_lift":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem is_kernel_comp_mono_lift {c : KernelFork f} (i : IsLimit c) {Z} (g : «expr ⟶ » Y Z) [hg : Mono g]\n    {h : «expr ⟶ » X Z} (hh : h = «expr ≫ » f g) (s : KernelFork h) :\n    (isKernelCompMono i g hh).lift s =\n      i.lift\n        (Fork.ofι s.ι\n          (by\n            rw [← cancel_mono g, category.assoc, ← hh]\n            simp)) :=\n  rfl\n#align is_kernel_comp_mono_lift is_kernel_comp_mono_lift\n\n",
 "is_cokernel_epi_comp_desc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp]\ntheorem is_cokernel_epi_comp_desc {c : CokernelCofork f} (i : IsColimit c) {W} (g : «expr ⟶ » W X) [hg : Epi g]\n    {h : «expr ⟶ » W Y} (hh : h = «expr ≫ » g f) (s : CokernelCofork h) :\n    (isCokernelEpiComp i g hh).desc s =\n      i.desc\n        (Cofork.ofπ s.π\n          (by\n            rw [← cancel_epi g, ← category.assoc, ← hh]\n            simp)) :=\n  rfl\n#align is_cokernel_epi_comp_desc is_cokernel_epi_comp_desc\n\n",
 "equalizer_as_kernel":
 "@[simp]\ntheorem equalizer_as_kernel : equalizer.ι f 0 = kernel.ι f :=\n  rfl\n#align equalizer_as_kernel equalizer_as_kernel\n\n",
 "eq_zero_of_mono_cokernel":
 "theorem eq_zero_of_mono_cokernel [Mono (cokernel.π f)] : f = 0 :=\n  (cancel_mono (cokernel.π f)).1 (by simp)\n#align eq_zero_of_mono_cokernel eq_zero_of_mono_cokernel\n\n",
 "eq_zero_of_epi_kernel":
 "theorem eq_zero_of_epi_kernel [Epi (kernel.ι f)] : f = 0 :=\n  (cancel_epi (kernel.ι f)).1 (by simp)\n#align eq_zero_of_epi_kernel eq_zero_of_epi_kernel\n\n",
 "desc_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n@[simp]\ntheorem cokernel.desc_zero {W : C} {h} : cokernel.desc f (0 : «expr ⟶ » Y W) h = 0 :=\n  by\n  ext\n  simp\n#align cokernel.desc_zero cokernel.desc_zero\n\n",
 "condition":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem cokernel.condition : «expr ≫ » f (cokernel.π f) = 0 :=\n  CokernelCofork.condition _\n#align cokernel.condition cokernel.condition\n\n",
 "cokernel_zero_iso_target_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n@[simp]\ntheorem cokernel_zero_iso_target_inv : cokernelZeroIsoTarget.inv = cokernel.π (0 : «expr ⟶ » X Y) :=\n  rfl\n#align cokernel_zero_iso_target_inv cokernel_zero_iso_target_inv\n\n",
 "cokernel_zero_iso_target_hom":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n@[simp]\ntheorem cokernel_zero_iso_target_hom :\n    cokernelZeroIsoTarget.hom = cokernel.desc (0 : «expr ⟶ » X Y) ((«expr𝟙») Y) (by simp) :=\n  by\n  ext\n  simp [cokernel_zero_iso_target]\n#align cokernel_zero_iso_target_hom cokernel_zero_iso_target_hom\n\n",
 "cokernel_not_mono_of_nonzero":
 "theorem cokernel_not_mono_of_nonzero (w : f ≠ 0) : ¬Mono (cokernel.π f) := fun I => w (eq_zero_of_mono_cokernel f)\n#align cokernel_not_mono_of_nonzero cokernel_not_mono_of_nonzero\n\n",
 "cokernel_not_iso_of_nonzero":
 "theorem cokernel_not_iso_of_nonzero (w : f ≠ 0) : IsIso (cokernel.π f) → False := fun I =>\n  cokernel_not_mono_of_nonzero w <| by\n    skip\n    infer_instance\n#align cokernel_not_iso_of_nonzero cokernel_not_iso_of_nonzero\n\n",
 "cokernel_map_comp_cokernel_comparison":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[reassoc.1]\ntheorem cokernel_map_comp_cokernel_comparison {X' Y' : C} [HasCokernel f] [HasCokernel (G.map f)] (g : «expr ⟶ » X' Y')\n    [HasCokernel g] [HasCokernel (G.map g)] (p : «expr ⟶ » X X') (q : «expr ⟶ » Y Y')\n    (hpq : «expr ≫ » f q = «expr ≫ » p g) :\n    «expr ≫ » (cokernel.map (G.map f) (G.map g) (G.map p) (G.map q) (by rw [← G.map_comp, hpq, G.map_comp]))\n        (cokernelComparison _ G) =\n      «expr ≫ » (cokernelComparison _ G) (G.map (cokernel.map f g p q hpq)) :=\n  cokernel.map_desc _ _ (by rw [← G.map_comp, cokernel.condition, G.map_zero]) _ _\n    (by rw [← G.map_comp, cokernel.condition, G.map_zero]) _ _ _ _\n    (by simp only [← G.map_comp] <;> exact G.congr_map (cokernel.π_desc _ _ _))\n#align cokernel_map_comp_cokernel_comparison cokernel_map_comp_cokernel_comparison\n\n",
 "cokernel_iso_of_eq_trans":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≪≫ » -/\n@[simp]\ntheorem cokernel_iso_of_eq_trans {f g h : «expr ⟶ » X Y} [HasCokernel f] [HasCokernel g] [HasCokernel h] (w₁ : f = g)\n    (w₂ : g = h) : «expr ≪≫ » (cokernelIsoOfEq w₁) (cokernelIsoOfEq w₂) = cokernelIsoOfEq (w₁.trans w₂) :=\n  by\n  induction w₁\n  induction w₂\n  ext\n  simp [cokernel_iso_of_eq]\n#align cokernel_iso_of_eq_trans cokernel_iso_of_eq_trans\n\n",
 "cokernel_iso_of_eq_refl":
 "@[simp]\ntheorem cokernel_iso_of_eq_refl {h : f = f} : cokernelIsoOfEq h = Iso.refl (cokernel f) :=\n  by\n  ext\n  simp [cokernel_iso_of_eq]\n#align cokernel_iso_of_eq_refl cokernel_iso_of_eq_refl\n\n",
 "cokernel_iso_of_eq_inv_comp_desc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem cokernel_iso_of_eq_inv_comp_desc {Z} {f g : «expr ⟶ » X Y} [HasCokernel f] [HasCokernel g] (h : f = g)\n    (e : «expr ⟶ » Y Z) (he) :\n    «expr ≫ » (cokernelIsoOfEq h).inv (cokernel.desc _ e he) = cokernel.desc _ e (by simp [← h, he]) :=\n  by\n  induction h\n  simp\n#align cokernel_iso_of_eq_inv_comp_desc cokernel_iso_of_eq_inv_comp_desc\n\n",
 "cokernel_iso_of_eq_hom_comp_desc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem cokernel_iso_of_eq_hom_comp_desc {Z} {f g : «expr ⟶ » X Y} [HasCokernel f] [HasCokernel g] (h : f = g)\n    (e : «expr ⟶ » Y Z) (he) :\n    «expr ≫ » (cokernelIsoOfEq h).hom (cokernel.desc _ e he) = cokernel.desc _ e (by simp [h, he]) :=\n  by\n  induction h\n  simp\n#align cokernel_iso_of_eq_hom_comp_desc cokernel_iso_of_eq_hom_comp_desc\n\n",
 "cokernel_comparison_map_desc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem cokernel_comparison_map_desc [HasCokernel f] [HasCokernel (G.map f)] {Z : C} {h : «expr ⟶ » Y Z}\n    (w : «expr ≫ » f h = 0) :\n    «expr ≫ » (cokernelComparison f G) (G.map (cokernel.desc _ h w)) =\n      cokernel.desc _ (G.map h) (by simp only [← G.map_comp, w, functor.map_zero]) :=\n  by\n  ext\n  simp [← G.map_comp]\n#align cokernel_comparison_map_desc cokernel_comparison_map_desc\n\n",
 "coequalizer_as_cokernel":
 "@[simp]\ntheorem coequalizer_as_cokernel : coequalizer.π f 0 = cokernel.π f :=\n  rfl\n#align coequalizer_as_cokernel coequalizer_as_cokernel\n\n",
 "app_one":
 "@[simp]\ntheorem kernel_fork.app_one (s : KernelFork f) : s.π.app one = 0 := by simp [fork.app_one_eq_ι_comp_right]\n#align kernel_fork.app_one kernel_fork.app_one\n\n"}