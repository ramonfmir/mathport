{"Ï€_precompose":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n@[simp]\ntheorem cofork.Ï€_precompose {f' g' : Â«expr âŸ¶ Â» X Y} {Î± : Â«expr âŸ¶ Â» (parallel_pair f g) (parallel_pair f' g')}\n    {c : cofork f' g'} : cofork.Ï€ ((cocones.precompose Î±).obj c) = Â«expr â‰« Â» (Î±.app _) c.Ï€ :=\n  rfl\n#align cofork.Ï€_precompose cofork.Ï€_precompose\n\n",
 "Ï€_of_Ï€":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n@[simp]\ntheorem cofork.Ï€_of_Ï€ {P : C} (Ï€ : Â«expr âŸ¶ Â» Y P) (w : Â«expr â‰« Â» f Ï€ = Â«expr â‰« Â» g Ï€) : (cofork.of_Ï€ Ï€ w).Ï€ = Ï€ :=\n  rfl\n#align cofork.Ï€_of_Ï€ cofork.Ï€_of_Ï€\n\n",
 "Ï€_of_eq":
 "/-- The coequalizer of `(f, g)`, where `f = g`, is an isomorphism. -/\ntheorem coequalizer.Ï€_of_eq [has_coequalizer f g] (h : f = g) : IsIso (coequalizer.Ï€ f g) :=\n  is_iso_colimit_cocone_parallel_pair_of_eq h <| colimit.is_colimit _\n#align coequalizer.Ï€_of_eq coequalizer.Ï€_of_eq\n\n",
 "Ï€_desc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n@[simp, reassoc.1]\ntheorem coequalizer.Ï€_desc {W : C} (k : Â«expr âŸ¶ Â» Y W) (h : Â«expr â‰« Â» f k = Â«expr â‰« Â» g k) :\n    Â«expr â‰« Â» (coequalizer.Ï€ f g) (coequalizer.desc k h) = k :=\n  colimit.Î¹_desc _ _\n#align coequalizer.Ï€_desc coequalizer.Ï€_desc\n\n",
 "Ï€_comp_hom":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n@[simp, reassoc.1]\ntheorem fork.Ï€_comp_hom {s t : cofork f g} (f : Â«expr âŸ¶ Â» s t) : Â«expr â‰« Â» s.Ï€ f.hom = t.Ï€ := by tidy\n#align fork.Ï€_comp_hom fork.Ï€_comp_hom\n\n",
 "Ï€_colim_map_desc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\ntheorem coequalizer.Ï€_colim_map_desc {X' Y' Z : C} (f' g' : Â«expr âŸ¶ Â» X' Y') [has_coequalizer f' g']\n    (p : Â«expr âŸ¶ Â» X X') (q : Â«expr âŸ¶ Â» Y Y') (wf : Â«expr â‰« Â» f q = Â«expr â‰« Â» p f')\n    (wg : Â«expr â‰« Â» g q = Â«expr â‰« Â» p g') (h : Â«expr âŸ¶ Â» Y' Z) (wh : Â«expr â‰« Â» f' h = Â«expr â‰« Â» g' h) :\n    Â«expr â‰« Â» (coequalizer.Ï€ f g)\n        (Â«expr â‰« Â» (colim_map (parallel_pair_hom f g f' g' p q wf wg)) (coequalizer.desc h wh)) =\n      Â«expr â‰« Â» q h :=\n  by rw [Î¹_colim_map_assoc, parallel_pair_hom_app_one, coequalizer.Ï€_desc]\n#align coequalizer.Ï€_colim_map_desc coequalizer.Ï€_colim_map_desc\n\n",
 "Î¹_postcompose":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n@[simp]\ntheorem fork.Î¹_postcompose {f' g' : Â«expr âŸ¶ Â» X Y} {Î± : Â«expr âŸ¶ Â» (parallel_pair f g) (parallel_pair f' g')}\n    {c : fork f g} : fork.Î¹ ((cones.postcompose Î±).obj c) = Â«expr â‰« Â» c.Î¹ (Î±.app _) :=\n  rfl\n#align fork.Î¹_postcompose fork.Î¹_postcompose\n\n",
 "Î¹_of_Î¹":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n-- See note [dsimp, simp].\n-- See note [dsimp, simp]\n@[simp]\ntheorem fork.Î¹_of_Î¹ {P : C} (Î¹ : Â«expr âŸ¶ Â» P X) (w : Â«expr â‰« Â» Î¹ f = Â«expr â‰« Â» Î¹ g) : (fork.of_Î¹ Î¹ w).Î¹ = Î¹ :=\n  rfl\n#align fork.Î¹_of_Î¹ fork.Î¹_of_Î¹\n\n",
 "Î¹_of_eq":
 "/-- The equalizer of `(f, g)`, where `f = g`, is an isomorphism. -/\ntheorem equalizer.Î¹_of_eq [has_equalizer f g] (h : f = g) : IsIso (equalizer.Î¹ f g) :=\n  is_iso_limit_cone_parallel_pair_of_eq h <| limit.is_limit _\n#align equalizer.Î¹_of_eq equalizer.Î¹_of_eq\n\n",
 "Î¹_comp_coequalizer_comparison":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n@[simp, reassoc.1]\ntheorem Î¹_comp_coequalizer_comparison [has_coequalizer f g] [has_coequalizer (G.map f) (G.map g)] :\n    Â«expr â‰« Â» (coequalizer.Ï€ _ _) (coequalizer_comparison f g G) = G.map (coequalizer.Ï€ _ _) :=\n  coequalizer.Ï€_desc _ _\n#align Î¹_comp_coequalizer_comparison Î¹_comp_coequalizer_comparison\n\n",
 "walking_parallel_pair_op_zero":
 "@[simp]\ntheorem walking_parallel_pair_op_zero : walking_parallel_pair_op.obj zero = op one :=\n  rfl\n#align walking_parallel_pair_op_zero walking_parallel_pair_op_zero\n\n",
 "walking_parallel_pair_op_right":
 "@[simp]\ntheorem walking_parallel_pair_op_right : walking_parallel_pair_op.map right = @Quiver.Hom.op _ _ zero one right :=\n  rfl\n#align walking_parallel_pair_op_right walking_parallel_pair_op_right\n\n",
 "walking_parallel_pair_op_one":
 "@[simp]\ntheorem walking_parallel_pair_op_one : walking_parallel_pair_op.obj one = op zero :=\n  rfl\n#align walking_parallel_pair_op_one walking_parallel_pair_op_one\n\n",
 "walking_parallel_pair_op_left":
 "@[simp]\ntheorem walking_parallel_pair_op_left : walking_parallel_pair_op.map left = @Quiver.Hom.op _ _ zero one left :=\n  rfl\n#align walking_parallel_pair_op_left walking_parallel_pair_op_left\n\n",
 "walking_parallel_pair_op_equiv_unit_iso_zero":
 "@[simp]\ntheorem walking_parallel_pair_op_equiv_unit_iso_zero :\n    walking_parallel_pair_op_equiv.unit_iso.app zero = Iso.refl zero :=\n  rfl\n#align walking_parallel_pair_op_equiv_unit_iso_zero walking_parallel_pair_op_equiv_unit_iso_zero\n\n",
 "walking_parallel_pair_op_equiv_unit_iso_one":
 "@[simp]\ntheorem walking_parallel_pair_op_equiv_unit_iso_one : walking_parallel_pair_op_equiv.unit_iso.app one = Iso.refl one :=\n  rfl\n#align walking_parallel_pair_op_equiv_unit_iso_one walking_parallel_pair_op_equiv_unit_iso_one\n\n",
 "walking_parallel_pair_op_equiv_counit_iso_zero":
 "@[simp]\ntheorem walking_parallel_pair_op_equiv_counit_iso_zero :\n    walking_parallel_pair_op_equiv.counit_iso.app (op zero) = Iso.refl (op zero) :=\n  rfl\n#align walking_parallel_pair_op_equiv_counit_iso_zero walking_parallel_pair_op_equiv_counit_iso_zero\n\n",
 "walking_parallel_pair_op_equiv_counit_iso_one":
 "@[simp]\ntheorem walking_parallel_pair_op_equiv_counit_iso_one :\n    walking_parallel_pair_op_equiv.counit_iso.app (op one) = Iso.refl (op one) :=\n  rfl\n#align walking_parallel_pair_op_equiv_counit_iso_one walking_parallel_pair_op_equiv_counit_iso_one\n\n",
 "walking_parallel_pair_hom_id":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n/-\nCopyright (c) 2018 Scott Morrison. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Scott Morrison, Markus Himmel\n-/\n@[simp]\ntheorem walking_parallel_pair_hom_id (X : walking_parallel_pair) : walking_parallel_pair_hom.id X = (Â«exprğŸ™Â») X :=\n  rfl\n#align walking_parallel_pair_hom_id walking_parallel_pair_hom_id\n\n",
 "parallel_pair_obj_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n-- `tidy` can cope with this, but it's too slow:\n@[simp]\ntheorem parallel_pair_obj_zero (f g : Â«expr âŸ¶ Â» X Y) : (parallel_pair f g).obj zero = X :=\n  rfl\n#align parallel_pair_obj_zero parallel_pair_obj_zero\n\n",
 "parallel_pair_obj_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n@[simp]\ntheorem parallel_pair_obj_one (f g : Â«expr âŸ¶ Â» X Y) : (parallel_pair f g).obj one = Y :=\n  rfl\n#align parallel_pair_obj_one parallel_pair_obj_one\n\n",
 "parallel_pair_map_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n@[simp]\ntheorem parallel_pair_map_right (f g : Â«expr âŸ¶ Â» X Y) : (parallel_pair f g).map right = g :=\n  rfl\n#align parallel_pair_map_right parallel_pair_map_right\n\n",
 "parallel_pair_map_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n@[simp]\ntheorem parallel_pair_map_left (f g : Â«expr âŸ¶ Â» X Y) : (parallel_pair f g).map left = f :=\n  rfl\n#align parallel_pair_map_left parallel_pair_map_left\n\n",
 "parallel_pair_hom_app_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n@[simp]\ntheorem parallel_pair_hom_app_zero {X' Y' : C} (f g : Â«expr âŸ¶ Â» X Y) (f' g' : Â«expr âŸ¶ Â» X' Y') (p : Â«expr âŸ¶ Â» X X')\n    (q : Â«expr âŸ¶ Â» Y Y') (wf : Â«expr â‰« Â» f q = Â«expr â‰« Â» p f') (wg : Â«expr â‰« Â» g q = Â«expr â‰« Â» p g') :\n    (parallel_pair_hom f g f' g' p q wf wg).app zero = p :=\n  rfl\n#align parallel_pair_hom_app_zero parallel_pair_hom_app_zero\n\n",
 "parallel_pair_hom_app_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n@[simp]\ntheorem parallel_pair_hom_app_one {X' Y' : C} (f g : Â«expr âŸ¶ Â» X Y) (f' g' : Â«expr âŸ¶ Â» X' Y') (p : Â«expr âŸ¶ Â» X X')\n    (q : Â«expr âŸ¶ Â» Y Y') (wf : Â«expr â‰« Â» f q = Â«expr â‰« Â» p f') (wg : Â«expr â‰« Â» g q = Â«expr â‰« Â» p g') :\n    (parallel_pair_hom f g f' g' p q wf wg).app one = q :=\n  rfl\n#align parallel_pair_hom_app_one parallel_pair_hom_app_one\n\n",
 "parallel_pair_functor_obj":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n@[simp]\ntheorem parallel_pair_functor_obj {F : Â«expr â¥¤ Â» walking_parallel_pair C} (j : walking_parallel_pair) :\n    (parallel_pair (F.map left) (F.map right)).obj j = F.obj j := by cases j <;> rfl\n#align parallel_pair_functor_obj parallel_pair_functor_obj\n\n",
 "of_fork_Ï€":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n@[simp]\ntheorem cone.of_fork_Ï€ {F : Â«expr â¥¤ Â» walking_parallel_pair C} (t : fork (F.map left) (F.map right)) (j) :\n    (cone.of_fork t).Ï€.app j = Â«expr â‰« Â» (t.Ï€.app j) (eq_to_hom (by tidy)) :=\n  rfl\n#align cone.of_fork_Ï€ cone.of_fork_Ï€\n\n",
 "of_cone_Ï€":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n@[simp]\ntheorem fork.of_cone_Ï€ {F : Â«expr â¥¤ Â» walking_parallel_pair C} (t : cone F) (j) :\n    (fork.of_cone t).Ï€.app j = Â«expr â‰« Â» (t.Ï€.app j) (eq_to_hom (by tidy)) :=\n  rfl\n#align fork.of_cone_Ï€ fork.of_cone_Ï€\n\n",
 "of_cofork_Î¹":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n@[simp]\ntheorem cocone.of_cofork_Î¹ {F : Â«expr â¥¤ Â» walking_parallel_pair C} (t : cofork (F.map left) (F.map right)) (j) :\n    (cocone.of_cofork t).Î¹.app j = Â«expr â‰« Â» (eq_to_hom (by tidy)) (t.Î¹.app j) :=\n  rfl\n#align cocone.of_cofork_Î¹ cocone.of_cofork_Î¹\n\n",
 "of_cocone_Î¹":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n@[simp]\ntheorem cofork.of_cocone_Î¹ {F : Â«expr â¥¤ Â» walking_parallel_pair C} (t : cocone F) (j) :\n    (cofork.of_cocone t).Î¹.app j = Â«expr â‰« Â» (eq_to_hom (by tidy)) (t.Î¹.app j) :=\n  rfl\n#align cofork.of_cocone_Î¹ cofork.of_cocone_Î¹\n\n",
 "mono_of_is_limit_fork":
 "/-- The equalizer morphism in any limit cone is a monomorphism. -/\ntheorem mono_of_is_limit_fork {c : fork f g} (i : is_limit c) : Mono (fork.Î¹ c) :=\n  { right_cancellation := fun Z h k w => fork.is_limit.hom_ext i w }\n#align mono_of_is_limit_fork mono_of_is_limit_fork\n\n",
 "map_lift_equalizer_comparison":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n@[simp, reassoc.1]\ntheorem map_lift_equalizer_comparison [has_equalizer f g] [has_equalizer (G.map f) (G.map g)] {Z : C}\n    {h : Â«expr âŸ¶ Â» Z X} (w : Â«expr â‰« Â» h f = Â«expr â‰« Â» h g) :\n    Â«expr â‰« Â» (G.map (equalizer.lift h w)) (equalizer_comparison f g G) =\n      equalizer.lift (G.map h) (by simp only [â† G.map_comp, w]) :=\n  by\n  ext\n  simp [â† G.map_comp]\n#align map_lift_equalizer_comparison map_lift_equalizer_comparison\n\n",
 "lift_Î¹":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n@[simp, reassoc.1]\ntheorem equalizer.lift_Î¹ {W : C} (k : Â«expr âŸ¶ Â» W X) (h : Â«expr â‰« Â» k f = Â«expr â‰« Â» k g) :\n    Â«expr â‰« Â» (equalizer.lift k h) (equalizer.Î¹ f g) = k :=\n  limit.lift_Ï€ _ _\n#align equalizer.lift_Î¹ equalizer.lift_Î¹\n\n",
 "iso_target_of_self_inv":
 "@[simp]\ntheorem coequalizer.iso_target_of_self_inv : (coequalizer.iso_target_of_self f).inv = coequalizer.Ï€ f f :=\n  rfl\n#align coequalizer.iso_target_of_self_inv coequalizer.iso_target_of_self_inv\n\n",
 "iso_target_of_self_hom":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n@[simp]\ntheorem coequalizer.iso_target_of_self_hom :\n    (coequalizer.iso_target_of_self f).hom = coequalizer.desc ((Â«exprğŸ™Â») Y) (by simp) :=\n  by\n  ext\n  simp [coequalizer.iso_target_of_self]\n#align coequalizer.iso_target_of_self_hom coequalizer.iso_target_of_self_hom\n\n",
 "iso_source_of_self_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n@[simp]\ntheorem equalizer.iso_source_of_self_inv :\n    (equalizer.iso_source_of_self f).inv = equalizer.lift ((Â«exprğŸ™Â») X) (by simp) :=\n  by\n  ext\n  simp [equalizer.iso_source_of_self]\n#align equalizer.iso_source_of_self_inv equalizer.iso_source_of_self_inv\n\n",
 "iso_source_of_self_hom":
 "@[simp]\ntheorem equalizer.iso_source_of_self_hom : (equalizer.iso_source_of_self f).hom = equalizer.Î¹ f f :=\n  rfl\n#align equalizer.iso_source_of_self_hom equalizer.iso_source_of_self_hom\n\n",
 "is_iso_limit_cone_parallel_pair_of_self":
 "/-- Every equalizer of `(f, f)` is an isomorphism. -/\ntheorem is_iso_limit_cone_parallel_pair_of_self {c : fork f f} (h : is_limit c) : IsIso c.Î¹ :=\n  is_iso_limit_cone_parallel_pair_of_eq rfl h\n#align is_iso_limit_cone_parallel_pair_of_self is_iso_limit_cone_parallel_pair_of_self\n\n",
 "is_iso_limit_cone_parallel_pair_of_eq":
 "/-- Every equalizer of `(f, g)`, where `f = g`, is an isomorphism. -/\ntheorem is_iso_limit_cone_parallel_pair_of_eq (hâ‚€ : f = g) {c : fork f g} (h : is_limit c) : IsIso c.Î¹ :=\n  is_iso.of_iso <| is_limit.cone_point_unique_up_to_iso h <| is_limit_id_fork hâ‚€\n#align is_iso_limit_cone_parallel_pair_of_eq is_iso_limit_cone_parallel_pair_of_eq\n\n",
 "is_iso_limit_cone_parallel_pair_of_epi":
 "/-- An equalizer that is an epimorphism is an isomorphism. -/\ntheorem is_iso_limit_cone_parallel_pair_of_epi {c : fork f g} (h : is_limit c) [Epi c.Î¹] : IsIso c.Î¹ :=\n  is_iso_limit_cone_parallel_pair_of_eq ((cancel_epi _).1 (fork.condition c)) h\n#align is_iso_limit_cone_parallel_pair_of_epi is_iso_limit_cone_parallel_pair_of_epi\n\n",
 "is_iso_limit_cocone_parallel_pair_of_epi":
 "/-- A coequalizer that is a monomorphism is an isomorphism. -/\ntheorem is_iso_limit_cocone_parallel_pair_of_epi {c : cofork f g} (h : is_colimit c) [Mono c.Ï€] : IsIso c.Ï€ :=\n  is_iso_colimit_cocone_parallel_pair_of_eq ((cancel_mono _).1 (cofork.condition c)) h\n#align is_iso_limit_cocone_parallel_pair_of_epi is_iso_limit_cocone_parallel_pair_of_epi\n\n",
 "is_iso_colimit_cocone_parallel_pair_of_self":
 "/-- Every coequalizer of `(f, f)` is an isomorphism. -/\ntheorem is_iso_colimit_cocone_parallel_pair_of_self {c : cofork f f} (h : is_colimit c) : IsIso c.Ï€ :=\n  is_iso_colimit_cocone_parallel_pair_of_eq rfl h\n#align is_iso_colimit_cocone_parallel_pair_of_self is_iso_colimit_cocone_parallel_pair_of_self\n\n",
 "is_iso_colimit_cocone_parallel_pair_of_eq":
 "/-- Every coequalizer of `(f, g)`, where `f = g`, is an isomorphism. -/\ntheorem is_iso_colimit_cocone_parallel_pair_of_eq (hâ‚€ : f = g) {c : cofork f g} (h : is_colimit c) : IsIso c.Ï€ :=\n  is_iso.of_iso <| is_colimit.cocone_point_unique_up_to_iso (is_colimit_id_cofork hâ‚€) h\n#align is_iso_colimit_cocone_parallel_pair_of_eq is_iso_colimit_cocone_parallel_pair_of_eq\n\n",
 "hom_iso_natural":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/-- The bijection of `cofork.is_colimit.hom_iso` is natural in `Z`. -/\ntheorem cofork.is_colimit.hom_iso_natural {X Y : C} {f g : Â«expr âŸ¶ Â» X Y} {t : cofork f g} {Z Z' : C}\n    (q : Â«expr âŸ¶ Â» Z Z') (ht : is_colimit t) (k : Â«expr âŸ¶ Â» t.X Z) :\n    (cofork.is_colimit.hom_iso ht _ (Â«expr â‰« Â» k q) : Â«expr âŸ¶ Â» Y Z') =\n      Â«expr â‰« Â» (cofork.is_colimit.hom_iso ht _ k : Â«expr âŸ¶ Â» Y Z) q :=\n  (category.assoc _ _ _).symm\n#align cofork.is_colimit.hom_iso_natural cofork.is_colimit.hom_iso_natural\n\n",
 "hom_ext":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/-- Two maps from a coequalizer are equal if they are equal when composed with the coequalizer\n    map -/\n@[ext]\ntheorem coequalizer.hom_ext {W : C} {k l : Â«expr âŸ¶ Â» (coequalizer f g) W}\n    (h : Â«expr â‰« Â» (coequalizer.Ï€ f g) k = Â«expr â‰« Â» (coequalizer.Ï€ f g) l) : k = l :=\n  cofork.is_colimit.hom_ext (colimit.is_colimit _) h\n#align coequalizer.hom_ext coequalizer.hom_ext\n\n",
 "hom_comp_Î¹":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n@[simp, reassoc.1]\ntheorem fork.hom_comp_Î¹ {s t : fork f g} (f : Â«expr âŸ¶ Â» s t) : Â«expr â‰« Â» f.hom t.Î¹ = s.Î¹ := by tidy\n#align fork.hom_comp_Î¹ fork.hom_comp_Î¹\n\n",
 "has_equalizers_of_has_limit_parallel_pair":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/-- If `C` has all limits of diagrams `parallel_pair f g`, then it has all equalizers -/\ntheorem has_equalizers_of_has_limit_parallel_pair [âˆ€ {X Y : C} {f g : Â«expr âŸ¶ Â» X Y}, has_limit (parallel_pair f g)] :\n    has_equalizers C :=\n  { has_limit := fun F => has_limit_of_iso (diagram_iso_parallel_pair F).symm }\n#align has_equalizers_of_has_limit_parallel_pair has_equalizers_of_has_limit_parallel_pair\n\n",
 "has_equalizer_comp_mono":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n@[instance]\ntheorem has_equalizer_comp_mono [has_equalizer f g] {Z : C} (h : Â«expr âŸ¶ Â» Y Z) [Mono h] :\n    has_equalizer (Â«expr â‰« Â» f h) (Â«expr â‰« Â» g h) :=\n  âŸ¨âŸ¨{   cone := _\n        is_limit := is_equalizer_comp_mono (limit.is_limit _) h }âŸ©âŸ©\n#align has_equalizer_comp_mono has_equalizer_comp_mono\n\n",
 "has_coequalizers_of_has_colimit_parallel_pair":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/-- If `C` has all colimits of diagrams `parallel_pair f g`, then it has all coequalizers -/\ntheorem has_coequalizers_of_has_colimit_parallel_pair\n    [âˆ€ {X Y : C} {f g : Â«expr âŸ¶ Â» X Y}, has_colimit (parallel_pair f g)] : has_coequalizers C :=\n  { has_colimit := fun F => has_colimit_of_iso (diagram_iso_parallel_pair F) }\n#align has_coequalizers_of_has_colimit_parallel_pair has_coequalizers_of_has_colimit_parallel_pair\n\n",
 "has_coequalizer_epi_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\ntheorem has_coequalizer_epi_comp [has_coequalizer f g] {W : C} (h : Â«expr âŸ¶ Â» W X) [hm : Epi h] :\n    has_coequalizer (Â«expr â‰« Â» h f) (Â«expr â‰« Â» h g) :=\n  âŸ¨âŸ¨{   cocone := _\n        is_colimit := is_coequalizer_epi_comp (colimit.is_colimit _) h }âŸ©âŸ©\n#align has_coequalizer_epi_comp has_coequalizer_epi_comp\n\n",
 "fork_Ï€_app_zero":
 "@[simp]\ntheorem equalizer.fork_Ï€_app_zero : (equalizer.fork f g).Ï€.app zero = equalizer.Î¹ f g :=\n  rfl\n#align equalizer.fork_Ï€_app_zero equalizer.fork_Ï€_app_zero\n\n",
 "fork_Î¹":
 "@[simp]\ntheorem equalizer.fork_Î¹ : (equalizer.fork f g).Î¹ = equalizer.Î¹ f g :=\n  rfl\n#align equalizer.fork_Î¹ equalizer.fork_Î¹\n\n",
 "exists_unique":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\ntheorem coequalizer.exists_unique {W : C} (k : Â«expr âŸ¶ Â» Y W) (h : Â«expr â‰« Â» f k = Â«expr â‰« Â» g k) :\n    âˆƒ! d : Â«expr âŸ¶ Â» (coequalizer f g) W, Â«expr â‰« Â» (coequalizer.Ï€ f g) d = k :=\n  cofork.is_colimit.exists_unique (colimit.is_colimit _) _ h\n#align coequalizer.exists_unique coequalizer.exists_unique\n\n",
 "equalizer_ext":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/-- To check whether two maps are equalized by both maps of a fork, it suffices to check it for the\n    first map -/\ntheorem fork.equalizer_ext (s : fork f g) {W : C} {k l : Â«expr âŸ¶ Â» W s.X} (h : Â«expr â‰« Â» k s.Î¹ = Â«expr â‰« Â» l s.Î¹) :\n    âˆ€ j : walking_parallel_pair, Â«expr â‰« Â» k (s.Ï€.app j) = Â«expr â‰« Â» l (s.Ï€.app j)\n  | zero => h\n  | one => by rw [s.app_one_eq_Î¹_comp_left, reassoc_of h]\n#align fork.equalizer_ext fork.equalizer_ext\n\n",
 "equalizer_comparison_comp_Ï€":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n@[simp, reassoc.1]\ntheorem equalizer_comparison_comp_Ï€ [has_equalizer f g] [has_equalizer (G.map f) (G.map g)] :\n    Â«expr â‰« Â» (equalizer_comparison f g G) (equalizer.Î¹ (G.map f) (G.map g)) = G.map (equalizer.Î¹ f g) :=\n  equalizer.lift_Î¹ _ _\n#align equalizer_comparison_comp_Ï€ equalizer_comparison_comp_Ï€\n\n",
 "eq_of_mono_cofork_Ï€":
 "/-- Two morphisms are equal if there is a cofork whose projection is mono. -/\ntheorem eq_of_mono_cofork_Ï€ (t : cofork f g) [Mono (cofork.Ï€ t)] : f = g :=\n  (cancel_mono (cofork.Ï€ t)).1 <| cofork.condition t\n#align eq_of_mono_cofork_Ï€ eq_of_mono_cofork_Ï€\n\n",
 "eq_of_mono_coequalizer":
 "/-- If the coequalizer of two morphisms is a monomorphism, then the two morphisms are equal. -/\ntheorem eq_of_mono_coequalizer [has_coequalizer f g] [Mono (coequalizer.Ï€ f g)] : f = g :=\n  (cancel_mono (coequalizer.Ï€ f g)).1 <| coequalizer.condition _ _\n#align eq_of_mono_coequalizer eq_of_mono_coequalizer\n\n",
 "eq_of_epi_fork_Î¹":
 "/-- Two morphisms are equal if there is a fork whose inclusion is epi. -/\ntheorem eq_of_epi_fork_Î¹ (t : fork f g) [Epi (fork.Î¹ t)] : f = g :=\n  (cancel_epi (fork.Î¹ t)).1 <| fork.condition t\n#align eq_of_epi_fork_Î¹ eq_of_epi_fork_Î¹\n\n",
 "eq_of_epi_equalizer":
 "/-- If the equalizer of two morphisms is an epimorphism, then the two morphisms are equal. -/\ntheorem eq_of_epi_equalizer [has_equalizer f g] [Epi (equalizer.Î¹ f g)] : f = g :=\n  (cancel_epi (equalizer.Î¹ f g)).1 <| equalizer.condition _ _\n#align eq_of_epi_equalizer eq_of_epi_equalizer\n\n",
 "epi_of_is_colimit_cofork":
 "/-- The coequalizer morphism in any colimit cocone is an epimorphism. -/\ntheorem epi_of_is_colimit_cofork {c : cofork f g} (i : is_colimit c) : Epi c.Ï€ :=\n  { left_cancellation := fun Z h k w => cofork.is_colimit.hom_ext i w }\n#align epi_of_is_colimit_cofork epi_of_is_colimit_cofork\n\n",
 "cone_of_is_split_mono_Î¹":
 "-- In this section we show that a split mono `f` equalizes `(retraction f â‰« f)` and `(ğŸ™ Y)`.\n@[simp]\ntheorem cone_of_is_split_mono_Î¹ : (cone_of_is_split_mono f).Î¹ = f :=\n  rfl\n#align cone_of_is_split_mono_Î¹ cone_of_is_split_mono_Î¹\n\n",
 "condition":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n@[reassoc.1]\ntheorem coequalizer.condition : Â«expr â‰« Â» f (coequalizer.Ï€ f g) = Â«expr â‰« Â» g (coequalizer.Ï€ f g) :=\n  cofork.condition <| colimit.cocone <| parallel_pair f g\n#align coequalizer.condition coequalizer.condition\n\n",
 "cofork_Ï€":
 "@[simp]\ntheorem coequalizer.cofork_Ï€ : (coequalizer.cofork f g).Ï€ = coequalizer.Ï€ f g :=\n  rfl\n#align coequalizer.cofork_Ï€ coequalizer.cofork_Ï€\n\n",
 "cofork_Î¹_app_one":
 "@[simp]\ntheorem coequalizer.cofork_Î¹_app_one : (coequalizer.cofork f g).Î¹.app one = coequalizer.Ï€ f g :=\n  rfl\n#align coequalizer.cofork_Î¹_app_one coequalizer.cofork_Î¹_app_one\n\n",
 "coequalizer_ext":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/-- To check whether two maps are coequalized by both maps of a cofork, it suffices to check it for\n    the second map -/\ntheorem cofork.coequalizer_ext (s : cofork f g) {W : C} {k l : Â«expr âŸ¶ Â» s.X W}\n    (h : Â«expr â‰« Â» (cofork.Ï€ s) k = Â«expr â‰« Â» (cofork.Ï€ s) l) :\n    âˆ€ j : walking_parallel_pair, Â«expr â‰« Â» (s.Î¹.app j) k = Â«expr â‰« Â» (s.Î¹.app j) l\n  | zero => by simp only [s.app_zero_eq_comp_Ï€_left, category.assoc, h]\n  | one => h\n#align cofork.coequalizer_ext cofork.coequalizer_ext\n\n",
 "coequalizer_comparison_map_desc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n@[simp, reassoc.1]\ntheorem coequalizer_comparison_map_desc [has_coequalizer f g] [has_coequalizer (G.map f) (G.map g)] {Z : C}\n    {h : Â«expr âŸ¶ Â» Y Z} (w : Â«expr â‰« Â» f h = Â«expr â‰« Â» g h) :\n    Â«expr â‰« Â» (coequalizer_comparison f g G) (G.map (coequalizer.desc h w)) =\n      coequalizer.desc (G.map h) (by simp only [â† G.map_comp, w]) :=\n  by\n  ext\n  simp [â† G.map_comp]\n#align coequalizer_comparison_map_desc coequalizer_comparison_map_desc\n\n",
 "cocone_of_is_split_epi_Ï€":
 "-- In this section we show that a split epi `f` coequalizes `(f â‰« section_ f)` and `(ğŸ™ X)`.\n@[simp]\ntheorem cocone_of_is_split_epi_Ï€ : (cocone_of_is_split_epi f).Ï€ = f :=\n  rfl\n#align cocone_of_is_split_epi_Ï€ cocone_of_is_split_epi_Ï€\n\n",
 "app_zero_eq_Î¹":
 "@[simp]\ntheorem fork.app_zero_eq_Î¹ (t : fork f g) : t.Ï€.app zero = t.Î¹ :=\n  rfl\n#align fork.app_zero_eq_Î¹ fork.app_zero_eq_Î¹\n\n",
 "app_zero_eq_comp_Ï€_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n@[reassoc.1]\ntheorem cofork.app_zero_eq_comp_Ï€_right (s : cofork f g) : s.Î¹.app zero = Â«expr â‰« Â» g s.Ï€ := by\n  rw [â† s.app_one_eq_Ï€, â† s.w right, parallel_pair_map_right]\n#align cofork.app_zero_eq_comp_Ï€_right cofork.app_zero_eq_comp_Ï€_right\n\n",
 "app_zero_eq_comp_Ï€_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n@[simp]\ntheorem cofork.app_zero_eq_comp_Ï€_left (s : cofork f g) : s.Î¹.app zero = Â«expr â‰« Â» f s.Ï€ := by\n  rw [â† s.app_one_eq_Ï€, â† s.w left, parallel_pair_map_left]\n#align cofork.app_zero_eq_comp_Ï€_left cofork.app_zero_eq_comp_Ï€_left\n\n",
 "app_one_eq_Ï€":
 "@[simp]\ntheorem cofork.app_one_eq_Ï€ (t : cofork f g) : t.Î¹.app one = t.Ï€ :=\n  rfl\n#align cofork.app_one_eq_Ï€ cofork.app_one_eq_Ï€\n\n",
 "app_one_eq_Î¹_comp_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n@[reassoc.1]\ntheorem fork.app_one_eq_Î¹_comp_right (s : fork f g) : s.Ï€.app one = Â«expr â‰« Â» s.Î¹ g := by\n  rw [â† s.app_zero_eq_Î¹, â† s.w right, parallel_pair_map_right]\n#align fork.app_one_eq_Î¹_comp_right fork.app_one_eq_Î¹_comp_right\n\n",
 "app_one_eq_Î¹_comp_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n@[simp]\ntheorem fork.app_one_eq_Î¹_comp_left (s : fork f g) : s.Ï€.app one = Â«expr â‰« Â» s.Î¹ f := by\n  rw [â† s.app_zero_eq_Î¹, â† s.w left, parallel_pair_map_left]\n#align fork.app_one_eq_Î¹_comp_left fork.app_one_eq_Î¹_comp_left\n\n"}