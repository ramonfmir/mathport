{"π_precompose":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp]\ntheorem cofork.π_precompose {f' g' : «expr ⟶ » X Y} {α : «expr ⟶ » (parallel_pair f g) (parallel_pair f' g')}\n    {c : cofork f' g'} : cofork.π ((cocones.precompose α).obj c) = «expr ≫ » (α.app _) c.π :=\n  rfl\n#align cofork.π_precompose cofork.π_precompose\n\n",
 "π_of_π":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp]\ntheorem cofork.π_of_π {P : C} (π : «expr ⟶ » Y P) (w : «expr ≫ » f π = «expr ≫ » g π) : (cofork.of_π π w).π = π :=\n  rfl\n#align cofork.π_of_π cofork.π_of_π\n\n",
 "π_of_eq":
 "/-- The coequalizer of `(f, g)`, where `f = g`, is an isomorphism. -/\ntheorem coequalizer.π_of_eq [has_coequalizer f g] (h : f = g) : IsIso (coequalizer.π f g) :=\n  is_iso_colimit_cocone_parallel_pair_of_eq h <| colimit.is_colimit _\n#align coequalizer.π_of_eq coequalizer.π_of_eq\n\n",
 "π_desc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem coequalizer.π_desc {W : C} (k : «expr ⟶ » Y W) (h : «expr ≫ » f k = «expr ≫ » g k) :\n    «expr ≫ » (coequalizer.π f g) (coequalizer.desc k h) = k :=\n  colimit.ι_desc _ _\n#align coequalizer.π_desc coequalizer.π_desc\n\n",
 "π_comp_hom":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem fork.π_comp_hom {s t : cofork f g} (f : «expr ⟶ » s t) : «expr ≫ » s.π f.hom = t.π := by tidy\n#align fork.π_comp_hom fork.π_comp_hom\n\n",
 "π_colim_map_desc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem coequalizer.π_colim_map_desc {X' Y' Z : C} (f' g' : «expr ⟶ » X' Y') [has_coequalizer f' g']\n    (p : «expr ⟶ » X X') (q : «expr ⟶ » Y Y') (wf : «expr ≫ » f q = «expr ≫ » p f')\n    (wg : «expr ≫ » g q = «expr ≫ » p g') (h : «expr ⟶ » Y' Z) (wh : «expr ≫ » f' h = «expr ≫ » g' h) :\n    «expr ≫ » (coequalizer.π f g)\n        («expr ≫ » (colim_map (parallel_pair_hom f g f' g' p q wf wg)) (coequalizer.desc h wh)) =\n      «expr ≫ » q h :=\n  by rw [ι_colim_map_assoc, parallel_pair_hom_app_one, coequalizer.π_desc]\n#align coequalizer.π_colim_map_desc coequalizer.π_colim_map_desc\n\n",
 "ι_postcompose":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp]\ntheorem fork.ι_postcompose {f' g' : «expr ⟶ » X Y} {α : «expr ⟶ » (parallel_pair f g) (parallel_pair f' g')}\n    {c : fork f g} : fork.ι ((cones.postcompose α).obj c) = «expr ≫ » c.ι (α.app _) :=\n  rfl\n#align fork.ι_postcompose fork.ι_postcompose\n\n",
 "ι_of_ι":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n-- See note [dsimp, simp].\n-- See note [dsimp, simp]\n@[simp]\ntheorem fork.ι_of_ι {P : C} (ι : «expr ⟶ » P X) (w : «expr ≫ » ι f = «expr ≫ » ι g) : (fork.of_ι ι w).ι = ι :=\n  rfl\n#align fork.ι_of_ι fork.ι_of_ι\n\n",
 "ι_of_eq":
 "/-- The equalizer of `(f, g)`, where `f = g`, is an isomorphism. -/\ntheorem equalizer.ι_of_eq [has_equalizer f g] (h : f = g) : IsIso (equalizer.ι f g) :=\n  is_iso_limit_cone_parallel_pair_of_eq h <| limit.is_limit _\n#align equalizer.ι_of_eq equalizer.ι_of_eq\n\n",
 "ι_comp_coequalizer_comparison":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem ι_comp_coequalizer_comparison [has_coequalizer f g] [has_coequalizer (G.map f) (G.map g)] :\n    «expr ≫ » (coequalizer.π _ _) (coequalizer_comparison f g G) = G.map (coequalizer.π _ _) :=\n  coequalizer.π_desc _ _\n#align ι_comp_coequalizer_comparison ι_comp_coequalizer_comparison\n\n",
 "walking_parallel_pair_op_zero":
 "@[simp]\ntheorem walking_parallel_pair_op_zero : walking_parallel_pair_op.obj zero = op one :=\n  rfl\n#align walking_parallel_pair_op_zero walking_parallel_pair_op_zero\n\n",
 "walking_parallel_pair_op_right":
 "@[simp]\ntheorem walking_parallel_pair_op_right : walking_parallel_pair_op.map right = @Quiver.Hom.op _ _ zero one right :=\n  rfl\n#align walking_parallel_pair_op_right walking_parallel_pair_op_right\n\n",
 "walking_parallel_pair_op_one":
 "@[simp]\ntheorem walking_parallel_pair_op_one : walking_parallel_pair_op.obj one = op zero :=\n  rfl\n#align walking_parallel_pair_op_one walking_parallel_pair_op_one\n\n",
 "walking_parallel_pair_op_left":
 "@[simp]\ntheorem walking_parallel_pair_op_left : walking_parallel_pair_op.map left = @Quiver.Hom.op _ _ zero one left :=\n  rfl\n#align walking_parallel_pair_op_left walking_parallel_pair_op_left\n\n",
 "walking_parallel_pair_op_equiv_unit_iso_zero":
 "@[simp]\ntheorem walking_parallel_pair_op_equiv_unit_iso_zero :\n    walking_parallel_pair_op_equiv.unit_iso.app zero = Iso.refl zero :=\n  rfl\n#align walking_parallel_pair_op_equiv_unit_iso_zero walking_parallel_pair_op_equiv_unit_iso_zero\n\n",
 "walking_parallel_pair_op_equiv_unit_iso_one":
 "@[simp]\ntheorem walking_parallel_pair_op_equiv_unit_iso_one : walking_parallel_pair_op_equiv.unit_iso.app one = Iso.refl one :=\n  rfl\n#align walking_parallel_pair_op_equiv_unit_iso_one walking_parallel_pair_op_equiv_unit_iso_one\n\n",
 "walking_parallel_pair_op_equiv_counit_iso_zero":
 "@[simp]\ntheorem walking_parallel_pair_op_equiv_counit_iso_zero :\n    walking_parallel_pair_op_equiv.counit_iso.app (op zero) = Iso.refl (op zero) :=\n  rfl\n#align walking_parallel_pair_op_equiv_counit_iso_zero walking_parallel_pair_op_equiv_counit_iso_zero\n\n",
 "walking_parallel_pair_op_equiv_counit_iso_one":
 "@[simp]\ntheorem walking_parallel_pair_op_equiv_counit_iso_one :\n    walking_parallel_pair_op_equiv.counit_iso.app (op one) = Iso.refl (op one) :=\n  rfl\n#align walking_parallel_pair_op_equiv_counit_iso_one walking_parallel_pair_op_equiv_counit_iso_one\n\n",
 "walking_parallel_pair_hom_id":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/-\nCopyright (c) 2018 Scott Morrison. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Scott Morrison, Markus Himmel\n-/\n@[simp]\ntheorem walking_parallel_pair_hom_id (X : walking_parallel_pair) : walking_parallel_pair_hom.id X = («expr𝟙») X :=\n  rfl\n#align walking_parallel_pair_hom_id walking_parallel_pair_hom_id\n\n",
 "parallel_pair_obj_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n-- `tidy` can cope with this, but it's too slow:\n@[simp]\ntheorem parallel_pair_obj_zero (f g : «expr ⟶ » X Y) : (parallel_pair f g).obj zero = X :=\n  rfl\n#align parallel_pair_obj_zero parallel_pair_obj_zero\n\n",
 "parallel_pair_obj_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n@[simp]\ntheorem parallel_pair_obj_one (f g : «expr ⟶ » X Y) : (parallel_pair f g).obj one = Y :=\n  rfl\n#align parallel_pair_obj_one parallel_pair_obj_one\n\n",
 "parallel_pair_map_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n@[simp]\ntheorem parallel_pair_map_right (f g : «expr ⟶ » X Y) : (parallel_pair f g).map right = g :=\n  rfl\n#align parallel_pair_map_right parallel_pair_map_right\n\n",
 "parallel_pair_map_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n@[simp]\ntheorem parallel_pair_map_left (f g : «expr ⟶ » X Y) : (parallel_pair f g).map left = f :=\n  rfl\n#align parallel_pair_map_left parallel_pair_map_left\n\n",
 "parallel_pair_hom_app_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp]\ntheorem parallel_pair_hom_app_zero {X' Y' : C} (f g : «expr ⟶ » X Y) (f' g' : «expr ⟶ » X' Y') (p : «expr ⟶ » X X')\n    (q : «expr ⟶ » Y Y') (wf : «expr ≫ » f q = «expr ≫ » p f') (wg : «expr ≫ » g q = «expr ≫ » p g') :\n    (parallel_pair_hom f g f' g' p q wf wg).app zero = p :=\n  rfl\n#align parallel_pair_hom_app_zero parallel_pair_hom_app_zero\n\n",
 "parallel_pair_hom_app_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp]\ntheorem parallel_pair_hom_app_one {X' Y' : C} (f g : «expr ⟶ » X Y) (f' g' : «expr ⟶ » X' Y') (p : «expr ⟶ » X X')\n    (q : «expr ⟶ » Y Y') (wf : «expr ≫ » f q = «expr ≫ » p f') (wg : «expr ≫ » g q = «expr ≫ » p g') :\n    (parallel_pair_hom f g f' g' p q wf wg).app one = q :=\n  rfl\n#align parallel_pair_hom_app_one parallel_pair_hom_app_one\n\n",
 "parallel_pair_functor_obj":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n@[simp]\ntheorem parallel_pair_functor_obj {F : «expr ⥤ » walking_parallel_pair C} (j : walking_parallel_pair) :\n    (parallel_pair (F.map left) (F.map right)).obj j = F.obj j := by cases j <;> rfl\n#align parallel_pair_functor_obj parallel_pair_functor_obj\n\n",
 "of_fork_π":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp]\ntheorem cone.of_fork_π {F : «expr ⥤ » walking_parallel_pair C} (t : fork (F.map left) (F.map right)) (j) :\n    (cone.of_fork t).π.app j = «expr ≫ » (t.π.app j) (eq_to_hom (by tidy)) :=\n  rfl\n#align cone.of_fork_π cone.of_fork_π\n\n",
 "of_cone_π":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp]\ntheorem fork.of_cone_π {F : «expr ⥤ » walking_parallel_pair C} (t : cone F) (j) :\n    (fork.of_cone t).π.app j = «expr ≫ » (t.π.app j) (eq_to_hom (by tidy)) :=\n  rfl\n#align fork.of_cone_π fork.of_cone_π\n\n",
 "of_cofork_ι":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp]\ntheorem cocone.of_cofork_ι {F : «expr ⥤ » walking_parallel_pair C} (t : cofork (F.map left) (F.map right)) (j) :\n    (cocone.of_cofork t).ι.app j = «expr ≫ » (eq_to_hom (by tidy)) (t.ι.app j) :=\n  rfl\n#align cocone.of_cofork_ι cocone.of_cofork_ι\n\n",
 "of_cocone_ι":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp]\ntheorem cofork.of_cocone_ι {F : «expr ⥤ » walking_parallel_pair C} (t : cocone F) (j) :\n    (cofork.of_cocone t).ι.app j = «expr ≫ » (eq_to_hom (by tidy)) (t.ι.app j) :=\n  rfl\n#align cofork.of_cocone_ι cofork.of_cocone_ι\n\n",
 "mono_of_is_limit_fork":
 "/-- The equalizer morphism in any limit cone is a monomorphism. -/\ntheorem mono_of_is_limit_fork {c : fork f g} (i : is_limit c) : Mono (fork.ι c) :=\n  { right_cancellation := fun Z h k w => fork.is_limit.hom_ext i w }\n#align mono_of_is_limit_fork mono_of_is_limit_fork\n\n",
 "map_lift_equalizer_comparison":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem map_lift_equalizer_comparison [has_equalizer f g] [has_equalizer (G.map f) (G.map g)] {Z : C}\n    {h : «expr ⟶ » Z X} (w : «expr ≫ » h f = «expr ≫ » h g) :\n    «expr ≫ » (G.map (equalizer.lift h w)) (equalizer_comparison f g G) =\n      equalizer.lift (G.map h) (by simp only [← G.map_comp, w]) :=\n  by\n  ext\n  simp [← G.map_comp]\n#align map_lift_equalizer_comparison map_lift_equalizer_comparison\n\n",
 "lift_ι":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem equalizer.lift_ι {W : C} (k : «expr ⟶ » W X) (h : «expr ≫ » k f = «expr ≫ » k g) :\n    «expr ≫ » (equalizer.lift k h) (equalizer.ι f g) = k :=\n  limit.lift_π _ _\n#align equalizer.lift_ι equalizer.lift_ι\n\n",
 "iso_target_of_self_inv":
 "@[simp]\ntheorem coequalizer.iso_target_of_self_inv : (coequalizer.iso_target_of_self f).inv = coequalizer.π f f :=\n  rfl\n#align coequalizer.iso_target_of_self_inv coequalizer.iso_target_of_self_inv\n\n",
 "iso_target_of_self_hom":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n@[simp]\ntheorem coequalizer.iso_target_of_self_hom :\n    (coequalizer.iso_target_of_self f).hom = coequalizer.desc ((«expr𝟙») Y) (by simp) :=\n  by\n  ext\n  simp [coequalizer.iso_target_of_self]\n#align coequalizer.iso_target_of_self_hom coequalizer.iso_target_of_self_hom\n\n",
 "iso_source_of_self_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n@[simp]\ntheorem equalizer.iso_source_of_self_inv :\n    (equalizer.iso_source_of_self f).inv = equalizer.lift ((«expr𝟙») X) (by simp) :=\n  by\n  ext\n  simp [equalizer.iso_source_of_self]\n#align equalizer.iso_source_of_self_inv equalizer.iso_source_of_self_inv\n\n",
 "iso_source_of_self_hom":
 "@[simp]\ntheorem equalizer.iso_source_of_self_hom : (equalizer.iso_source_of_self f).hom = equalizer.ι f f :=\n  rfl\n#align equalizer.iso_source_of_self_hom equalizer.iso_source_of_self_hom\n\n",
 "is_iso_limit_cone_parallel_pair_of_self":
 "/-- Every equalizer of `(f, f)` is an isomorphism. -/\ntheorem is_iso_limit_cone_parallel_pair_of_self {c : fork f f} (h : is_limit c) : IsIso c.ι :=\n  is_iso_limit_cone_parallel_pair_of_eq rfl h\n#align is_iso_limit_cone_parallel_pair_of_self is_iso_limit_cone_parallel_pair_of_self\n\n",
 "is_iso_limit_cone_parallel_pair_of_eq":
 "/-- Every equalizer of `(f, g)`, where `f = g`, is an isomorphism. -/\ntheorem is_iso_limit_cone_parallel_pair_of_eq (h₀ : f = g) {c : fork f g} (h : is_limit c) : IsIso c.ι :=\n  is_iso.of_iso <| is_limit.cone_point_unique_up_to_iso h <| is_limit_id_fork h₀\n#align is_iso_limit_cone_parallel_pair_of_eq is_iso_limit_cone_parallel_pair_of_eq\n\n",
 "is_iso_limit_cone_parallel_pair_of_epi":
 "/-- An equalizer that is an epimorphism is an isomorphism. -/\ntheorem is_iso_limit_cone_parallel_pair_of_epi {c : fork f g} (h : is_limit c) [Epi c.ι] : IsIso c.ι :=\n  is_iso_limit_cone_parallel_pair_of_eq ((cancel_epi _).1 (fork.condition c)) h\n#align is_iso_limit_cone_parallel_pair_of_epi is_iso_limit_cone_parallel_pair_of_epi\n\n",
 "is_iso_limit_cocone_parallel_pair_of_epi":
 "/-- A coequalizer that is a monomorphism is an isomorphism. -/\ntheorem is_iso_limit_cocone_parallel_pair_of_epi {c : cofork f g} (h : is_colimit c) [Mono c.π] : IsIso c.π :=\n  is_iso_colimit_cocone_parallel_pair_of_eq ((cancel_mono _).1 (cofork.condition c)) h\n#align is_iso_limit_cocone_parallel_pair_of_epi is_iso_limit_cocone_parallel_pair_of_epi\n\n",
 "is_iso_colimit_cocone_parallel_pair_of_self":
 "/-- Every coequalizer of `(f, f)` is an isomorphism. -/\ntheorem is_iso_colimit_cocone_parallel_pair_of_self {c : cofork f f} (h : is_colimit c) : IsIso c.π :=\n  is_iso_colimit_cocone_parallel_pair_of_eq rfl h\n#align is_iso_colimit_cocone_parallel_pair_of_self is_iso_colimit_cocone_parallel_pair_of_self\n\n",
 "is_iso_colimit_cocone_parallel_pair_of_eq":
 "/-- Every coequalizer of `(f, g)`, where `f = g`, is an isomorphism. -/\ntheorem is_iso_colimit_cocone_parallel_pair_of_eq (h₀ : f = g) {c : cofork f g} (h : is_colimit c) : IsIso c.π :=\n  is_iso.of_iso <| is_colimit.cocone_point_unique_up_to_iso (is_colimit_id_cofork h₀) h\n#align is_iso_colimit_cocone_parallel_pair_of_eq is_iso_colimit_cocone_parallel_pair_of_eq\n\n",
 "hom_iso_natural":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/-- The bijection of `cofork.is_colimit.hom_iso` is natural in `Z`. -/\ntheorem cofork.is_colimit.hom_iso_natural {X Y : C} {f g : «expr ⟶ » X Y} {t : cofork f g} {Z Z' : C}\n    (q : «expr ⟶ » Z Z') (ht : is_colimit t) (k : «expr ⟶ » t.X Z) :\n    (cofork.is_colimit.hom_iso ht _ («expr ≫ » k q) : «expr ⟶ » Y Z') =\n      «expr ≫ » (cofork.is_colimit.hom_iso ht _ k : «expr ⟶ » Y Z) q :=\n  (category.assoc _ _ _).symm\n#align cofork.is_colimit.hom_iso_natural cofork.is_colimit.hom_iso_natural\n\n",
 "hom_ext":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/-- Two maps from a coequalizer are equal if they are equal when composed with the coequalizer\n    map -/\n@[ext]\ntheorem coequalizer.hom_ext {W : C} {k l : «expr ⟶ » (coequalizer f g) W}\n    (h : «expr ≫ » (coequalizer.π f g) k = «expr ≫ » (coequalizer.π f g) l) : k = l :=\n  cofork.is_colimit.hom_ext (colimit.is_colimit _) h\n#align coequalizer.hom_ext coequalizer.hom_ext\n\n",
 "hom_comp_ι":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem fork.hom_comp_ι {s t : fork f g} (f : «expr ⟶ » s t) : «expr ≫ » f.hom t.ι = s.ι := by tidy\n#align fork.hom_comp_ι fork.hom_comp_ι\n\n",
 "has_equalizers_of_has_limit_parallel_pair":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/-- If `C` has all limits of diagrams `parallel_pair f g`, then it has all equalizers -/\ntheorem has_equalizers_of_has_limit_parallel_pair [∀ {X Y : C} {f g : «expr ⟶ » X Y}, has_limit (parallel_pair f g)] :\n    has_equalizers C :=\n  { has_limit := fun F => has_limit_of_iso (diagram_iso_parallel_pair F).symm }\n#align has_equalizers_of_has_limit_parallel_pair has_equalizers_of_has_limit_parallel_pair\n\n",
 "has_equalizer_comp_mono":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[instance]\ntheorem has_equalizer_comp_mono [has_equalizer f g] {Z : C} (h : «expr ⟶ » Y Z) [Mono h] :\n    has_equalizer («expr ≫ » f h) («expr ≫ » g h) :=\n  ⟨⟨{   cone := _\n        is_limit := is_equalizer_comp_mono (limit.is_limit _) h }⟩⟩\n#align has_equalizer_comp_mono has_equalizer_comp_mono\n\n",
 "has_coequalizers_of_has_colimit_parallel_pair":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/-- If `C` has all colimits of diagrams `parallel_pair f g`, then it has all coequalizers -/\ntheorem has_coequalizers_of_has_colimit_parallel_pair\n    [∀ {X Y : C} {f g : «expr ⟶ » X Y}, has_colimit (parallel_pair f g)] : has_coequalizers C :=\n  { has_colimit := fun F => has_colimit_of_iso (diagram_iso_parallel_pair F) }\n#align has_coequalizers_of_has_colimit_parallel_pair has_coequalizers_of_has_colimit_parallel_pair\n\n",
 "has_coequalizer_epi_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem has_coequalizer_epi_comp [has_coequalizer f g] {W : C} (h : «expr ⟶ » W X) [hm : Epi h] :\n    has_coequalizer («expr ≫ » h f) («expr ≫ » h g) :=\n  ⟨⟨{   cocone := _\n        is_colimit := is_coequalizer_epi_comp (colimit.is_colimit _) h }⟩⟩\n#align has_coequalizer_epi_comp has_coequalizer_epi_comp\n\n",
 "fork_π_app_zero":
 "@[simp]\ntheorem equalizer.fork_π_app_zero : (equalizer.fork f g).π.app zero = equalizer.ι f g :=\n  rfl\n#align equalizer.fork_π_app_zero equalizer.fork_π_app_zero\n\n",
 "fork_ι":
 "@[simp]\ntheorem equalizer.fork_ι : (equalizer.fork f g).ι = equalizer.ι f g :=\n  rfl\n#align equalizer.fork_ι equalizer.fork_ι\n\n",
 "exists_unique":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem coequalizer.exists_unique {W : C} (k : «expr ⟶ » Y W) (h : «expr ≫ » f k = «expr ≫ » g k) :\n    ∃! d : «expr ⟶ » (coequalizer f g) W, «expr ≫ » (coequalizer.π f g) d = k :=\n  cofork.is_colimit.exists_unique (colimit.is_colimit _) _ h\n#align coequalizer.exists_unique coequalizer.exists_unique\n\n",
 "equalizer_ext":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/-- To check whether two maps are equalized by both maps of a fork, it suffices to check it for the\n    first map -/\ntheorem fork.equalizer_ext (s : fork f g) {W : C} {k l : «expr ⟶ » W s.X} (h : «expr ≫ » k s.ι = «expr ≫ » l s.ι) :\n    ∀ j : walking_parallel_pair, «expr ≫ » k (s.π.app j) = «expr ≫ » l (s.π.app j)\n  | zero => h\n  | one => by rw [s.app_one_eq_ι_comp_left, reassoc_of h]\n#align fork.equalizer_ext fork.equalizer_ext\n\n",
 "equalizer_comparison_comp_π":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem equalizer_comparison_comp_π [has_equalizer f g] [has_equalizer (G.map f) (G.map g)] :\n    «expr ≫ » (equalizer_comparison f g G) (equalizer.ι (G.map f) (G.map g)) = G.map (equalizer.ι f g) :=\n  equalizer.lift_ι _ _\n#align equalizer_comparison_comp_π equalizer_comparison_comp_π\n\n",
 "eq_of_mono_cofork_π":
 "/-- Two morphisms are equal if there is a cofork whose projection is mono. -/\ntheorem eq_of_mono_cofork_π (t : cofork f g) [Mono (cofork.π t)] : f = g :=\n  (cancel_mono (cofork.π t)).1 <| cofork.condition t\n#align eq_of_mono_cofork_π eq_of_mono_cofork_π\n\n",
 "eq_of_mono_coequalizer":
 "/-- If the coequalizer of two morphisms is a monomorphism, then the two morphisms are equal. -/\ntheorem eq_of_mono_coequalizer [has_coequalizer f g] [Mono (coequalizer.π f g)] : f = g :=\n  (cancel_mono (coequalizer.π f g)).1 <| coequalizer.condition _ _\n#align eq_of_mono_coequalizer eq_of_mono_coequalizer\n\n",
 "eq_of_epi_fork_ι":
 "/-- Two morphisms are equal if there is a fork whose inclusion is epi. -/\ntheorem eq_of_epi_fork_ι (t : fork f g) [Epi (fork.ι t)] : f = g :=\n  (cancel_epi (fork.ι t)).1 <| fork.condition t\n#align eq_of_epi_fork_ι eq_of_epi_fork_ι\n\n",
 "eq_of_epi_equalizer":
 "/-- If the equalizer of two morphisms is an epimorphism, then the two morphisms are equal. -/\ntheorem eq_of_epi_equalizer [has_equalizer f g] [Epi (equalizer.ι f g)] : f = g :=\n  (cancel_epi (equalizer.ι f g)).1 <| equalizer.condition _ _\n#align eq_of_epi_equalizer eq_of_epi_equalizer\n\n",
 "epi_of_is_colimit_cofork":
 "/-- The coequalizer morphism in any colimit cocone is an epimorphism. -/\ntheorem epi_of_is_colimit_cofork {c : cofork f g} (i : is_colimit c) : Epi c.π :=\n  { left_cancellation := fun Z h k w => cofork.is_colimit.hom_ext i w }\n#align epi_of_is_colimit_cofork epi_of_is_colimit_cofork\n\n",
 "cone_of_is_split_mono_ι":
 "-- In this section we show that a split mono `f` equalizes `(retraction f ≫ f)` and `(𝟙 Y)`.\n@[simp]\ntheorem cone_of_is_split_mono_ι : (cone_of_is_split_mono f).ι = f :=\n  rfl\n#align cone_of_is_split_mono_ι cone_of_is_split_mono_ι\n\n",
 "condition":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[reassoc.1]\ntheorem coequalizer.condition : «expr ≫ » f (coequalizer.π f g) = «expr ≫ » g (coequalizer.π f g) :=\n  cofork.condition <| colimit.cocone <| parallel_pair f g\n#align coequalizer.condition coequalizer.condition\n\n",
 "cofork_π":
 "@[simp]\ntheorem coequalizer.cofork_π : (coequalizer.cofork f g).π = coequalizer.π f g :=\n  rfl\n#align coequalizer.cofork_π coequalizer.cofork_π\n\n",
 "cofork_ι_app_one":
 "@[simp]\ntheorem coequalizer.cofork_ι_app_one : (coequalizer.cofork f g).ι.app one = coequalizer.π f g :=\n  rfl\n#align coequalizer.cofork_ι_app_one coequalizer.cofork_ι_app_one\n\n",
 "coequalizer_ext":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/-- To check whether two maps are coequalized by both maps of a cofork, it suffices to check it for\n    the second map -/\ntheorem cofork.coequalizer_ext (s : cofork f g) {W : C} {k l : «expr ⟶ » s.X W}\n    (h : «expr ≫ » (cofork.π s) k = «expr ≫ » (cofork.π s) l) :\n    ∀ j : walking_parallel_pair, «expr ≫ » (s.ι.app j) k = «expr ≫ » (s.ι.app j) l\n  | zero => by simp only [s.app_zero_eq_comp_π_left, category.assoc, h]\n  | one => h\n#align cofork.coequalizer_ext cofork.coequalizer_ext\n\n",
 "coequalizer_comparison_map_desc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem coequalizer_comparison_map_desc [has_coequalizer f g] [has_coequalizer (G.map f) (G.map g)] {Z : C}\n    {h : «expr ⟶ » Y Z} (w : «expr ≫ » f h = «expr ≫ » g h) :\n    «expr ≫ » (coequalizer_comparison f g G) (G.map (coequalizer.desc h w)) =\n      coequalizer.desc (G.map h) (by simp only [← G.map_comp, w]) :=\n  by\n  ext\n  simp [← G.map_comp]\n#align coequalizer_comparison_map_desc coequalizer_comparison_map_desc\n\n",
 "cocone_of_is_split_epi_π":
 "-- In this section we show that a split epi `f` coequalizes `(f ≫ section_ f)` and `(𝟙 X)`.\n@[simp]\ntheorem cocone_of_is_split_epi_π : (cocone_of_is_split_epi f).π = f :=\n  rfl\n#align cocone_of_is_split_epi_π cocone_of_is_split_epi_π\n\n",
 "app_zero_eq_ι":
 "@[simp]\ntheorem fork.app_zero_eq_ι (t : fork f g) : t.π.app zero = t.ι :=\n  rfl\n#align fork.app_zero_eq_ι fork.app_zero_eq_ι\n\n",
 "app_zero_eq_comp_π_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[reassoc.1]\ntheorem cofork.app_zero_eq_comp_π_right (s : cofork f g) : s.ι.app zero = «expr ≫ » g s.π := by\n  rw [← s.app_one_eq_π, ← s.w right, parallel_pair_map_right]\n#align cofork.app_zero_eq_comp_π_right cofork.app_zero_eq_comp_π_right\n\n",
 "app_zero_eq_comp_π_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp]\ntheorem cofork.app_zero_eq_comp_π_left (s : cofork f g) : s.ι.app zero = «expr ≫ » f s.π := by\n  rw [← s.app_one_eq_π, ← s.w left, parallel_pair_map_left]\n#align cofork.app_zero_eq_comp_π_left cofork.app_zero_eq_comp_π_left\n\n",
 "app_one_eq_π":
 "@[simp]\ntheorem cofork.app_one_eq_π (t : cofork f g) : t.ι.app one = t.π :=\n  rfl\n#align cofork.app_one_eq_π cofork.app_one_eq_π\n\n",
 "app_one_eq_ι_comp_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[reassoc.1]\ntheorem fork.app_one_eq_ι_comp_right (s : fork f g) : s.π.app one = «expr ≫ » s.ι g := by\n  rw [← s.app_zero_eq_ι, ← s.w right, parallel_pair_map_right]\n#align fork.app_one_eq_ι_comp_right fork.app_one_eq_ι_comp_right\n\n",
 "app_one_eq_ι_comp_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp]\ntheorem fork.app_one_eq_ι_comp_left (s : fork f g) : s.π.app one = «expr ≫ » s.ι f := by\n  rw [← s.app_zero_eq_ι, ← s.w left, parallel_pair_map_left]\n#align fork.app_one_eq_ι_comp_left fork.app_one_eq_ι_comp_left\n\n"}