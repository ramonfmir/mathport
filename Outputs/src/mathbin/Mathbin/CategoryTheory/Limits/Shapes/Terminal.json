{"Î¹_colimit_const_initial_hom":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¥_ Â» -/\n@[simp, reassoc.1]\ntheorem Î¹_colimit_const_initial_hom {J : Type _} [Category J] {C : Type _} [Category C] [has_initial C] {j : J} :\n    Â«expr â‰« Â» (colimit.Î¹ ((category_theory.functor.const J).obj (Â«exprâŠ¥_ Â» C)) j) colimit_const_initial.hom =\n      initial.to _ :=\n  by ext âŸ¨âŸ¨âŸ©âŸ©\n#align Î¹_colimit_const_initial_hom Î¹_colimit_const_initial_hom\n\n",
 "to_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n@[simp]\ntheorem is_initial.to_self {X : C} (t : is_initial X) : t.to X = (Â«exprğŸ™Â») X :=\n  t.hom_ext _ _\n#align is_initial.to_self is_initial.to_self\n\n",
 "to_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n@[simp]\ntheorem initial.to_comp [has_initial C] {P Q : C} (f : Â«expr âŸ¶ Â» P Q) : Â«expr â‰« Â» (initial.to P) f = initial.to Q := by\n  tidy\n#align initial.to_comp initial.to_comp\n\n",
 "of_terminal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤_ Â» -/\n/-- To show a category is a `initial_mono_class` it suffices to show the unique morphism from the\ninitial object to a terminal object is a monomorphism. -/\ntheorem initial_mono_class.of_terminal [has_initial C] [has_terminal C] (h : Mono (initial.to (Â«exprâŠ¤_ Â» C))) :\n    initial_mono_class C :=\n  initial_mono_class.of_is_terminal initial_is_initial terminal_is_terminal h\n#align initial_mono_class.of_terminal initial_mono_class.of_terminal\n\n",
 "of_is_terminal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/-- To show a category is a `initial_mono_class` it suffices to show the unique morphism from an\ninitial object to a terminal object is a monomorphism. -/\ntheorem initial_mono_class.of_is_terminal {I T : C} (hI : is_initial I) (hT : is_terminal T) (f : Mono (hI.to T)) :\n    initial_mono_class C :=\n  initial_mono_class.of_is_initial hI fun X => mono_of_mono_fac (hI.hom_ext (Â«expr â‰« Â» _ (hT.from X)) (hI.to T))\n#align initial_mono_class.of_is_terminal initial_mono_class.of_is_terminal\n\n",
 "of_is_initial":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/-- To show a category is a `initial_mono_class` it suffices to give an initial object such that\nevery morphism out of it is a monomorphism. -/\ntheorem initial_mono_class.of_is_initial {I : C} (hI : is_initial I) (h : âˆ€ X, Mono (hI.to X)) : initial_mono_class C :=\n  {\n    is_initial_mono_from := fun I' X hI' =>\n      by\n      rw [hI'.hom_ext (hI'.to X) (Â«expr â‰« Â» (hI'.unique_up_to_iso hI).hom (hI.to X))]\n      apply mono_comp }\n#align initial_mono_class.of_is_initial initial_mono_class.of_is_initial\n\n",
 "of_initial":
 "/-- To show a category is a `initial_mono_class` it suffices to show every morphism out of the\ninitial object is a monomorphism. -/\ntheorem initial_mono_class.of_initial [has_initial C] (h : âˆ€ X : C, Mono (initial.to X)) : initial_mono_class C :=\n  initial_mono_class.of_is_initial initial_is_initial h\n#align initial_mono_class.of_initial initial_mono_class.of_initial\n\n",
 "mono_from":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem is_initial.mono_from [initial_mono_class C] {I} {X : C} (hI : is_initial I) (f : Â«expr âŸ¶ Â» I X) : Mono f :=\n  by\n  rw [hI.hom_ext f (hI.to X)]\n  apply initial_mono_class.is_initial_mono_from\n#align is_initial.mono_from is_initial.mono_from\n\n",
 "limit_const_terminal_inv_Ï€":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤_ Â» -/\n@[simp, reassoc.1]\ntheorem limit_const_terminal_inv_Ï€ {J : Type _} [Category J] {C : Type _} [Category C] [has_terminal C] {j : J} :\n    Â«expr â‰« Â» limit_const_terminal.inv (limit.Ï€ ((category_theory.functor.const J).obj (Â«exprâŠ¤_ Â» C)) j) =\n      terminal.from _ :=\n  by ext âŸ¨âŸ¨âŸ©âŸ©\n#align limit_const_terminal_inv_Ï€ limit_const_terminal_inv_Ï€\n\n",
 "is_split_mono_from":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/-- Any morphism from a terminal object is split mono. -/\ntheorem is_terminal.is_split_mono_from {X Y : C} (t : is_terminal X) (f : Â«expr âŸ¶ Â» X Y) : is_split_mono f :=\n  is_split_mono.mk' âŸ¨t.from _, t.hom_ext _ _âŸ©\n#align is_terminal.is_split_mono_from is_terminal.is_split_mono_from\n\n",
 "is_split_epi_to":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/-- Any morphism to an initial object is split epi. -/\ntheorem is_initial.is_split_epi_to {X Y : C} (t : is_initial X) (f : Â«expr âŸ¶ Â» Y X) : is_split_epi f :=\n  is_split_epi.mk' âŸ¨t.to _, t.hom_ext _ _âŸ©\n#align is_initial.is_split_epi_to is_initial.is_split_epi_to\n\n",
 "is_iso_Ï€_of_is_terminal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem is_iso_Ï€_of_is_terminal {j : J} (I : is_terminal j) (F : Â«expr â¥¤ Â» J C) [has_limit F]\n    [âˆ€ (i j : J) (f : Â«expr âŸ¶ Â» i j), IsIso (F.map f)] : IsIso (limit.Ï€ F j) :=\n  âŸ¨âŸ¨limit.lift _ (cone_of_diagram_terminal I F), by\n      ext\n      simp, by simpâŸ©âŸ©\n#align is_iso_Ï€_of_is_terminal is_iso_Ï€_of_is_terminal\n\n",
 "is_iso_Ï€_of_is_initial":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n-- TODO: Show this is an isomorphism if and only if `G` preserves initial objects.\n-- See note [dsimp, simp]\n-- This is reducible to allow usage of lemmas about `cone_point_unique_up_to_iso`.\n-- This is reducible to allow usage of lemmas about `cone_point_unique_up_to_iso`.\n-- This is reducible to allow usage of lemmas about `cocone_point_unique_up_to_iso`.\n-- This is reducible to allow usage of lemmas about `cocone_point_unique_up_to_iso`.\n/-- If `j` is initial in the index category, then the map `limit.Ï€ F j` is an isomorphism.\n-/\ntheorem is_iso_Ï€_of_is_initial {j : J} (I : is_initial j) (F : Â«expr â¥¤ Â» J C) [has_limit F] : IsIso (limit.Ï€ F j) :=\n  âŸ¨âŸ¨limit.lift _ (cone_of_diagram_initial I F),\n      âŸ¨by\n        ext\n        simp, by simpâŸ©âŸ©âŸ©\n#align is_iso_Ï€_of_is_initial is_iso_Ï€_of_is_initial\n\n",
 "is_iso_Î¹_of_is_terminal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/-- If `j` is terminal in the index category, then the map `colimit.Î¹ F j` is an isomorphism.\n-/\ntheorem is_iso_Î¹_of_is_terminal {j : J} (I : is_terminal j) (F : Â«expr â¥¤ Â» J C) [has_colimit F] :\n    IsIso (colimit.Î¹ F j) :=\n  âŸ¨âŸ¨colimit.desc _ (cocone_of_diagram_terminal I F),\n      âŸ¨by simp, by\n        ext\n        simpâŸ©âŸ©âŸ©\n#align is_iso_Î¹_of_is_terminal is_iso_Î¹_of_is_terminal\n\n",
 "is_iso_Î¹_of_is_initial":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem is_iso_Î¹_of_is_initial {j : J} (I : is_initial j) (F : Â«expr â¥¤ Â» J C) [has_colimit F]\n    [âˆ€ (i j : J) (f : Â«expr âŸ¶ Â» i j), IsIso (F.map f)] : IsIso (colimit.Î¹ F j) :=\n  âŸ¨âŸ¨colimit.desc _ (cocone_of_diagram_initial I F),\n      âŸ¨by tidy, by\n        ext\n        simpâŸ©âŸ©âŸ©\n#align is_iso_Î¹_of_is_initial is_iso_Î¹_of_is_initial\n\n",
 "hom_ext":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/-- Any two morphisms from an initial object are equal. -/\ntheorem is_initial.hom_ext {X Y : C} (t : is_initial X) (f g : Â«expr âŸ¶ Â» X Y) : f = g :=\n  t.hom_ext (by tidy)\n#align is_initial.hom_ext is_initial.hom_ext\n\n",
 "has_terminal_of_unique":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/-- We can more explicitly show that a category has a terminal object by specifying the object,\nand showing there is a unique morphism to it from any other object. -/\ntheorem has_terminal_of_unique (X : C) [h : âˆ€ Y : C, unique (Â«expr âŸ¶ Â» Y X)] : has_terminal C :=\n  { has_limit := fun F => has_limit.mk âŸ¨_, (is_terminal_equiv_unique F X).inv_fun hâŸ© }\n#align has_terminal_of_unique has_terminal_of_unique\n\n",
 "has_terminal_of_has_initial_op":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr áµ’áµ–Â» -/\ntheorem has_terminal_of_has_initial_op [has_initial (Â«expr áµ’áµ–Â» C)] : has_terminal C :=\n  (terminal_unop_of_initial initial_is_initial).has_terminal\n#align has_terminal_of_has_initial_op has_terminal_of_has_initial_op\n\n",
 "has_terminal_change_universe":
 "theorem has_terminal_change_universe [h : has_limits_of_shape (discrete.{w} PEmpty) C] :\n    has_limits_of_shape (discrete.{w'} PEmpty) C :=\n  {\n    has_limit := fun J =>\n      has_terminal_change_diagram C\n        (let f := h.1\n        f (functor.empty C)) }\n#align has_terminal_change_universe has_terminal_change_universe\n\n",
 "has_terminal_change_diagram":
 "theorem has_terminal_change_diagram (h : has_limit Fâ‚) : has_limit Fâ‚‚ :=\n  âŸ¨âŸ¨âŸ¨âŸ¨limit Fâ‚, by tidyâŸ©, is_limit_change_empty_cone C (limit.is_limit Fâ‚) _ (eq_to_iso rfl)âŸ©âŸ©âŸ©\n#align has_terminal_change_diagram has_terminal_change_diagram\n\n",
 "has_terminal":
 "theorem is_terminal.has_terminal {X : C} (h : is_terminal X) : has_terminal C :=\n  { has_limit := fun F => has_limit.mk âŸ¨âŸ¨X, by tidyâŸ©, is_limit_change_empty_cone _ h _ (Iso.refl _)âŸ© }\n#align is_terminal.has_terminal is_terminal.has_terminal\n\n",
 "has_initial_of_unique":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/-- We can more explicitly show that a category has an initial object by specifying the object,\nand showing there is a unique morphism from it to any other object. -/\ntheorem has_initial_of_unique (X : C) [h : âˆ€ Y : C, unique (Â«expr âŸ¶ Â» X Y)] : has_initial C :=\n  { has_colimit := fun F => has_colimit.mk âŸ¨_, (is_initial_equiv_unique F X).inv_fun hâŸ© }\n#align has_initial_of_unique has_initial_of_unique\n\n",
 "has_initial_of_has_terminal_op":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr áµ’áµ–Â» -/\ntheorem has_initial_of_has_terminal_op [has_terminal (Â«expr áµ’áµ–Â» C)] : has_initial C :=\n  (initial_unop_of_terminal terminal_is_terminal).has_initial\n#align has_initial_of_has_terminal_op has_initial_of_has_terminal_op\n\n",
 "has_initial_change_universe":
 "theorem has_initial_change_universe [h : has_colimits_of_shape (discrete.{w} PEmpty) C] :\n    has_colimits_of_shape (discrete.{w'} PEmpty) C :=\n  {\n    has_colimit := fun J =>\n      has_initial_change_diagram C\n        (let f := h.1\n        f (functor.empty C)) }\n#align has_initial_change_universe has_initial_change_universe\n\n",
 "has_initial_change_diagram":
 "theorem has_initial_change_diagram (h : has_colimit Fâ‚) : has_colimit Fâ‚‚ :=\n  âŸ¨âŸ¨âŸ¨âŸ¨colimit Fâ‚, by tidyâŸ©, is_colimit_change_empty_cocone C (colimit.is_colimit Fâ‚) _ (eq_to_iso rfl)âŸ©âŸ©âŸ©\n#align has_initial_change_diagram has_initial_change_diagram\n\n",
 "has_initial":
 "theorem is_initial.has_initial {X : C} (h : is_initial X) : has_initial C :=\n  { has_colimit := fun F => has_colimit.mk âŸ¨âŸ¨X, by tidyâŸ©, is_colimit_change_empty_cocone _ h _ (Iso.refl _)âŸ© }\n#align is_initial.has_initial is_initial.has_initial\n\n",
 "from_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n@[simp]\ntheorem is_terminal.from_self {X : C} (t : is_terminal X) : t.from X = (Â«exprğŸ™Â») X :=\n  t.hom_ext _ _\n#align is_terminal.from_self is_terminal.from_self\n\n",
 "epi_to":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/-- Any morphism to an initial object is epi. -/\ntheorem is_initial.epi_to {X Y : C} (t : is_initial X) (f : Â«expr âŸ¶ Â» Y X) : Epi f := by\n  haveI := t.is_split_epi_to f <;> infer_instance\n#align is_initial.epi_to is_initial.epi_to\n\n",
 "comp_from":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n@[simp]\ntheorem terminal.comp_from [has_terminal C] {P Q : C} (f : Â«expr âŸ¶ Â» P Q) :\n    Â«expr â‰« Â» f (terminal.from Q) = terminal.from P := by tidy\n#align terminal.comp_from terminal.comp_from\n\n"}