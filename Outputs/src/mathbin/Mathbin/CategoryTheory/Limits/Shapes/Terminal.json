{"Œπ_colimit_const_initial_hom":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚â´ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚ä•_ ¬ª -/\n@[simp, reassoc.1]\ntheorem Œπ_colimit_const_initial_hom {J : Type _} [Category J] {C : Type _} [Category C] [HasInitial C] {j : J} :\n    ¬´expr ‚â´ ¬ª (colimit.Œπ ((CategoryTheory.Functor.const J).obj (¬´expr‚ä•_ ¬ª C)) j) colimitConstInitial.hom =\n      initial.to _ :=\n  by ext ‚ü®‚ü®‚ü©‚ü©\n#align Œπ_colimit_const_initial_hom Œπ_colimit_const_initial_hom\n\n",
 "to_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´exprùüô¬ª -/\n@[simp]\ntheorem is_initial.to_self {X : C} (t : IsInitial X) : t.to X = (¬´exprùüô¬ª) X :=\n  t.hom_ext _ _\n#align is_initial.to_self is_initial.to_self\n\n",
 "to_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚ü∂ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚â´ ¬ª -/\n@[simp]\ntheorem initial.to_comp [HasInitial C] {P Q : C} (f : ¬´expr ‚ü∂ ¬ª P Q) : ¬´expr ‚â´ ¬ª (initial.to P) f = initial.to Q := by\n  tidy\n#align initial.to_comp initial.to_comp\n\n",
 "of_terminal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚ä§_ ¬ª -/\n/-- To show a category is a `initial_mono_class` it suffices to show the unique morphism from the\ninitial object to a terminal object is a monomorphism. -/\ntheorem initial_mono_class.of_terminal [HasInitial C] [HasTerminal C] (h : Mono (initial.to (¬´expr‚ä§_ ¬ª C))) :\n    InitialMonoClass C :=\n  InitialMonoClass.of_isTerminal initialIsInitial terminalIsTerminal h\n#align initial_mono_class.of_terminal initial_mono_class.of_terminal\n\n",
 "of_is_terminal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚â´ ¬ª -/\n/-- To show a category is a `initial_mono_class` it suffices to show the unique morphism from an\ninitial object to a terminal object is a monomorphism. -/\ntheorem initial_mono_class.of_is_terminal {I T : C} (hI : IsInitial I) (hT : IsTerminal T) (f : Mono (hI.to T)) :\n    InitialMonoClass C :=\n  InitialMonoClass.of_isInitial hI fun X => mono_of_mono_fac (hI.hom_ext (¬´expr ‚â´ ¬ª _ (hT.from X)) (hI.to T))\n#align initial_mono_class.of_is_terminal initial_mono_class.of_is_terminal\n\n",
 "of_is_initial":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚â´ ¬ª -/\n/-- To show a category is a `initial_mono_class` it suffices to give an initial object such that\nevery morphism out of it is a monomorphism. -/\ntheorem initial_mono_class.of_is_initial {I : C} (hI : IsInitial I) (h : ‚àÄ X, Mono (hI.to X)) : InitialMonoClass C :=\n  {\n    is_initial_mono_from := fun I' X hI' =>\n      by\n      rw [hI'.hom_ext (hI'.to X) (¬´expr ‚â´ ¬ª (hI'.unique_up_to_iso hI).hom (hI.to X))]\n      apply mono_comp }\n#align initial_mono_class.of_is_initial initial_mono_class.of_is_initial\n\n",
 "of_initial":
 "/-- To show a category is a `initial_mono_class` it suffices to show every morphism out of the\ninitial object is a monomorphism. -/\ntheorem initial_mono_class.of_initial [HasInitial C] (h : ‚àÄ X : C, Mono (initial.to X)) : InitialMonoClass C :=\n  InitialMonoClass.of_isInitial initialIsInitial h\n#align initial_mono_class.of_initial initial_mono_class.of_initial\n\n",
 "mono_from":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚ü∂ ¬ª -/\ntheorem is_initial.mono_from [InitialMonoClass C] {I} {X : C} (hI : IsInitial I) (f : ¬´expr ‚ü∂ ¬ª I X) : Mono f :=\n  by\n  rw [hI.hom_ext f (hI.to X)]\n  apply initial_mono_class.is_initial_mono_from\n#align is_initial.mono_from is_initial.mono_from\n\n",
 "limit_const_terminal_inv_œÄ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚â´ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚ä§_ ¬ª -/\n@[simp, reassoc.1]\ntheorem limit_const_terminal_inv_œÄ {J : Type _} [Category J] {C : Type _} [Category C] [HasTerminal C] {j : J} :\n    ¬´expr ‚â´ ¬ª limitConstTerminal.inv (limit.œÄ ((CategoryTheory.Functor.const J).obj (¬´expr‚ä§_ ¬ª C)) j) =\n      terminal.from _ :=\n  by ext ‚ü®‚ü®‚ü©‚ü©\n#align limit_const_terminal_inv_œÄ limit_const_terminal_inv_œÄ\n\n",
 "is_split_mono_from":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚ü∂ ¬ª -/\n/-- Any morphism from a terminal object is split mono. -/\ntheorem is_terminal.is_split_mono_from {X Y : C} (t : IsTerminal X) (f : ¬´expr ‚ü∂ ¬ª X Y) : IsSplitMono f :=\n  IsSplitMono.mk' ‚ü®t.from _, t.hom_ext _ _‚ü©\n#align is_terminal.is_split_mono_from is_terminal.is_split_mono_from\n\n",
 "is_split_epi_to":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚ü∂ ¬ª -/\n/-- Any morphism to an initial object is split epi. -/\ntheorem is_initial.is_split_epi_to {X Y : C} (t : IsInitial X) (f : ¬´expr ‚ü∂ ¬ª Y X) : IsSplitEpi f :=\n  IsSplitEpi.mk' ‚ü®t.to _, t.hom_ext _ _‚ü©\n#align is_initial.is_split_epi_to is_initial.is_split_epi_to\n\n",
 "is_iso_œÄ_of_is_terminal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚•§ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚ü∂ ¬ª -/\ntheorem is_iso_œÄ_of_is_terminal {j : J} (I : IsTerminal j) (F : ¬´expr ‚•§ ¬ª J C) [HasLimit F]\n    [‚àÄ (i j : J) (f : ¬´expr ‚ü∂ ¬ª i j), IsIso (F.map f)] : IsIso (limit.œÄ F j) :=\n  ‚ü®‚ü®limit.lift _ (coneOfDiagramTerminal I F), by\n      ext\n      simp, by simp‚ü©‚ü©\n#align is_iso_œÄ_of_is_terminal is_iso_œÄ_of_is_terminal\n\n",
 "is_iso_œÄ_of_is_initial":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚•§ ¬ª -/\n-- TODO: Show this is an isomorphism if and only if `G` preserves initial objects.\n-- See note [dsimp, simp]\n-- This is reducible to allow usage of lemmas about `cone_point_unique_up_to_iso`.\n-- This is reducible to allow usage of lemmas about `cone_point_unique_up_to_iso`.\n-- This is reducible to allow usage of lemmas about `cocone_point_unique_up_to_iso`.\n-- This is reducible to allow usage of lemmas about `cocone_point_unique_up_to_iso`.\n/-- If `j` is initial in the index category, then the map `limit.œÄ F j` is an isomorphism.\n-/\ntheorem is_iso_œÄ_of_is_initial {j : J} (I : IsInitial j) (F : ¬´expr ‚•§ ¬ª J C) [HasLimit F] : IsIso (limit.œÄ F j) :=\n  ‚ü®‚ü®limit.lift _ (coneOfDiagramInitial I F),\n      ‚ü®by\n        ext\n        simp, by simp‚ü©‚ü©‚ü©\n#align is_iso_œÄ_of_is_initial is_iso_œÄ_of_is_initial\n\n",
 "is_iso_Œπ_of_is_terminal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚•§ ¬ª -/\n/-- If `j` is terminal in the index category, then the map `colimit.Œπ F j` is an isomorphism.\n-/\ntheorem is_iso_Œπ_of_is_terminal {j : J} (I : IsTerminal j) (F : ¬´expr ‚•§ ¬ª J C) [HasColimit F] : IsIso (colimit.Œπ F j) :=\n  ‚ü®‚ü®colimit.desc _ (coconeOfDiagramTerminal I F),\n      ‚ü®by simp, by\n        ext\n        simp‚ü©‚ü©‚ü©\n#align is_iso_Œπ_of_is_terminal is_iso_Œπ_of_is_terminal\n\n",
 "is_iso_Œπ_of_is_initial":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚•§ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚ü∂ ¬ª -/\ntheorem is_iso_Œπ_of_is_initial {j : J} (I : IsInitial j) (F : ¬´expr ‚•§ ¬ª J C) [HasColimit F]\n    [‚àÄ (i j : J) (f : ¬´expr ‚ü∂ ¬ª i j), IsIso (F.map f)] : IsIso (colimit.Œπ F j) :=\n  ‚ü®‚ü®colimit.desc _ (coconeOfDiagramInitial I F),\n      ‚ü®by tidy, by\n        ext\n        simp‚ü©‚ü©‚ü©\n#align is_iso_Œπ_of_is_initial is_iso_Œπ_of_is_initial\n\n",
 "hom_ext":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚ü∂ ¬ª -/\n/-- Any two morphisms from an initial object are equal. -/\ntheorem is_initial.hom_ext {X Y : C} (t : IsInitial X) (f g : ¬´expr ‚ü∂ ¬ª X Y) : f = g :=\n  t.hom_ext (by tidy)\n#align is_initial.hom_ext is_initial.hom_ext\n\n",
 "has_terminal_of_unique":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚ü∂ ¬ª -/\n/-- We can more explicitly show that a category has a terminal object by specifying the object,\nand showing there is a unique morphism to it from any other object. -/\ntheorem has_terminal_of_unique (X : C) [h : ‚àÄ Y : C, Unique (¬´expr ‚ü∂ ¬ª Y X)] : HasTerminal C :=\n  { has_limit := fun F => HasLimit.mk ‚ü®_, (isTerminalEquivUnique F X).inv_fun h‚ü© }\n#align has_terminal_of_unique has_terminal_of_unique\n\n",
 "has_terminal_of_has_initial_op":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ·µí·µñ¬ª -/\ntheorem has_terminal_of_has_initial_op [HasInitial (¬´expr ·µí·µñ¬ª C)] : HasTerminal C :=\n  (terminalUnopOfInitial initialIsInitial).has_terminal\n#align has_terminal_of_has_initial_op has_terminal_of_has_initial_op\n\n",
 "has_terminal_change_universe":
 "theorem has_terminal_change_universe [h : HasLimitsOfShape (Discrete.{w} PEmpty) C] :\n    HasLimitsOfShape (Discrete.{w'} PEmpty) C :=\n  {\n    has_limit := fun J =>\n      hasTerminalChangeDiagram C\n        (let f := h.1\n        f (Functor.empty C)) }\n#align has_terminal_change_universe has_terminal_change_universe\n\n",
 "has_terminal_change_diagram":
 "theorem has_terminal_change_diagram (h : HasLimit F‚ÇÅ) : HasLimit F‚ÇÇ :=\n  ‚ü®‚ü®‚ü®‚ü®limit F‚ÇÅ, by tidy‚ü©, isLimitChangeEmptyCone C (limit.isLimit F‚ÇÅ) _ (eqToIso rfl)‚ü©‚ü©‚ü©\n#align has_terminal_change_diagram has_terminal_change_diagram\n\n",
 "has_terminal":
 "theorem is_terminal.has_terminal {X : C} (h : IsTerminal X) : HasTerminal C :=\n  { has_limit := fun F => HasLimit.mk ‚ü®‚ü®X, by tidy‚ü©, isLimitChangeEmptyCone _ h _ (Iso.refl _)‚ü© }\n#align is_terminal.has_terminal is_terminal.has_terminal\n\n",
 "has_initial_of_unique":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚ü∂ ¬ª -/\n/-- We can more explicitly show that a category has an initial object by specifying the object,\nand showing there is a unique morphism from it to any other object. -/\ntheorem has_initial_of_unique (X : C) [h : ‚àÄ Y : C, Unique (¬´expr ‚ü∂ ¬ª X Y)] : HasInitial C :=\n  { has_colimit := fun F => HasColimit.mk ‚ü®_, (isInitialEquivUnique F X).inv_fun h‚ü© }\n#align has_initial_of_unique has_initial_of_unique\n\n",
 "has_initial_of_has_terminal_op":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ·µí·µñ¬ª -/\ntheorem has_initial_of_has_terminal_op [HasTerminal (¬´expr ·µí·µñ¬ª C)] : HasInitial C :=\n  (initialUnopOfTerminal terminalIsTerminal).has_initial\n#align has_initial_of_has_terminal_op has_initial_of_has_terminal_op\n\n",
 "has_initial_change_universe":
 "theorem has_initial_change_universe [h : HasColimitsOfShape (Discrete.{w} PEmpty) C] :\n    HasColimitsOfShape (Discrete.{w'} PEmpty) C :=\n  {\n    has_colimit := fun J =>\n      hasInitialChangeDiagram C\n        (let f := h.1\n        f (Functor.empty C)) }\n#align has_initial_change_universe has_initial_change_universe\n\n",
 "has_initial_change_diagram":
 "theorem has_initial_change_diagram (h : HasColimit F‚ÇÅ) : HasColimit F‚ÇÇ :=\n  ‚ü®‚ü®‚ü®‚ü®colimit F‚ÇÅ, by tidy‚ü©, isColimitChangeEmptyCocone C (colimit.isColimit F‚ÇÅ) _ (eqToIso rfl)‚ü©‚ü©‚ü©\n#align has_initial_change_diagram has_initial_change_diagram\n\n",
 "has_initial":
 "theorem is_initial.has_initial {X : C} (h : IsInitial X) : HasInitial C :=\n  { has_colimit := fun F => HasColimit.mk ‚ü®‚ü®X, by tidy‚ü©, isColimitChangeEmptyCocone _ h _ (Iso.refl _)‚ü© }\n#align is_initial.has_initial is_initial.has_initial\n\n",
 "from_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´exprùüô¬ª -/\n@[simp]\ntheorem is_terminal.from_self {X : C} (t : IsTerminal X) : t.from X = (¬´exprùüô¬ª) X :=\n  t.hom_ext _ _\n#align is_terminal.from_self is_terminal.from_self\n\n",
 "epi_to":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚ü∂ ¬ª -/\n/-- Any morphism to an initial object is epi. -/\ntheorem is_initial.epi_to {X Y : C} (t : IsInitial X) (f : ¬´expr ‚ü∂ ¬ª Y X) : Epi f := by\n  haveI := t.is_split_epi_to f <;> infer_instance\n#align is_initial.epi_to is_initial.epi_to\n\n",
 "comp_from":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚ü∂ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚â´ ¬ª -/\n@[simp]\ntheorem terminal.comp_from [HasTerminal C] {P Q : C} (f : ¬´expr ‚ü∂ ¬ª P Q) :\n    ¬´expr ‚â´ ¬ª f (terminal.from Q) = terminal.from P := by tidy\n#align terminal.comp_from terminal.comp_from\n\n"}