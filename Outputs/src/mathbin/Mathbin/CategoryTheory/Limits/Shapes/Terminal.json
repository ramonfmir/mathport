{"Î¹_colimit_const_initial_hom":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¥_ Â» -/\n@[simp, reassoc.1]\ntheorem Î¹_colimit_const_initial_hom {J : Type _} [Category J] {C : Type _} [Category C] [HasInitial C] {j : J} :\n    Â«expr â‰« Â» (colimit.Î¹ ((CategoryTheory.Functor.const J).obj (Â«exprâŠ¥_ Â» C)) j) colimitConstInitial.hom =\n      initial.to _ :=\n  by ext âŸ¨âŸ¨âŸ©âŸ©\n#align Î¹_colimit_const_initial_hom Î¹_colimit_const_initial_hom\n\n",
 "to_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n@[simp]\ntheorem is_initial.to_self {X : C} (t : IsInitial X) : t.to X = (Â«exprğŸ™Â») X :=\n  t.hom_ext _ _\n#align is_initial.to_self is_initial.to_self\n\n",
 "to_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n@[simp]\ntheorem initial.to_comp [HasInitial C] {P Q : C} (f : Â«expr âŸ¶ Â» P Q) : Â«expr â‰« Â» (initial.to P) f = initial.to Q := by\n  tidy\n#align initial.to_comp initial.to_comp\n\n",
 "of_terminal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤_ Â» -/\n/-- To show a category is a `initial_mono_class` it suffices to show the unique morphism from the\ninitial object to a terminal object is a monomorphism. -/\ntheorem initial_mono_class.of_terminal [HasInitial C] [HasTerminal C] (h : Mono (initial.to (Â«exprâŠ¤_ Â» C))) :\n    InitialMonoClass C :=\n  InitialMonoClass.of_isTerminal initialIsInitial terminalIsTerminal h\n#align initial_mono_class.of_terminal initial_mono_class.of_terminal\n\n",
 "of_is_terminal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/-- To show a category is a `initial_mono_class` it suffices to show the unique morphism from an\ninitial object to a terminal object is a monomorphism. -/\ntheorem initial_mono_class.of_is_terminal {I T : C} (hI : IsInitial I) (hT : IsTerminal T) (f : Mono (hI.to T)) :\n    InitialMonoClass C :=\n  InitialMonoClass.of_isInitial hI fun X => mono_of_mono_fac (hI.hom_ext (Â«expr â‰« Â» _ (hT.from X)) (hI.to T))\n#align initial_mono_class.of_is_terminal initial_mono_class.of_is_terminal\n\n",
 "of_is_initial":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/-- To show a category is a `initial_mono_class` it suffices to give an initial object such that\nevery morphism out of it is a monomorphism. -/\ntheorem initial_mono_class.of_is_initial {I : C} (hI : IsInitial I) (h : âˆ€ X, Mono (hI.to X)) : InitialMonoClass C :=\n  {\n    is_initial_mono_from := fun I' X hI' =>\n      by\n      rw [hI'.hom_ext (hI'.to X) (Â«expr â‰« Â» (hI'.unique_up_to_iso hI).hom (hI.to X))]\n      apply mono_comp }\n#align initial_mono_class.of_is_initial initial_mono_class.of_is_initial\n\n",
 "of_initial":
 "/-- To show a category is a `initial_mono_class` it suffices to show every morphism out of the\ninitial object is a monomorphism. -/\ntheorem initial_mono_class.of_initial [HasInitial C] (h : âˆ€ X : C, Mono (initial.to X)) : InitialMonoClass C :=\n  InitialMonoClass.of_isInitial initialIsInitial h\n#align initial_mono_class.of_initial initial_mono_class.of_initial\n\n",
 "mono_from":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem is_initial.mono_from [InitialMonoClass C] {I} {X : C} (hI : IsInitial I) (f : Â«expr âŸ¶ Â» I X) : Mono f :=\n  by\n  rw [hI.hom_ext f (hI.to X)]\n  apply initial_mono_class.is_initial_mono_from\n#align is_initial.mono_from is_initial.mono_from\n\n",
 "limit_const_terminal_inv_Ï€":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤_ Â» -/\n@[simp, reassoc.1]\ntheorem limit_const_terminal_inv_Ï€ {J : Type _} [Category J] {C : Type _} [Category C] [HasTerminal C] {j : J} :\n    Â«expr â‰« Â» limitConstTerminal.inv (limit.Ï€ ((CategoryTheory.Functor.const J).obj (Â«exprâŠ¤_ Â» C)) j) =\n      terminal.from _ :=\n  by ext âŸ¨âŸ¨âŸ©âŸ©\n#align limit_const_terminal_inv_Ï€ limit_const_terminal_inv_Ï€\n\n",
 "is_split_mono_from":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/-- Any morphism from a terminal object is split mono. -/\ntheorem is_terminal.is_split_mono_from {X Y : C} (t : IsTerminal X) (f : Â«expr âŸ¶ Â» X Y) : IsSplitMono f :=\n  IsSplitMono.mk' âŸ¨t.from _, t.hom_ext _ _âŸ©\n#align is_terminal.is_split_mono_from is_terminal.is_split_mono_from\n\n",
 "is_split_epi_to":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/-- Any morphism to an initial object is split epi. -/\ntheorem is_initial.is_split_epi_to {X Y : C} (t : IsInitial X) (f : Â«expr âŸ¶ Â» Y X) : IsSplitEpi f :=\n  IsSplitEpi.mk' âŸ¨t.to _, t.hom_ext _ _âŸ©\n#align is_initial.is_split_epi_to is_initial.is_split_epi_to\n\n",
 "is_iso_Ï€_of_is_terminal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem is_iso_Ï€_of_is_terminal {j : J} (I : IsTerminal j) (F : Â«expr â¥¤ Â» J C) [HasLimit F]\n    [âˆ€ (i j : J) (f : Â«expr âŸ¶ Â» i j), IsIso (F.map f)] : IsIso (limit.Ï€ F j) :=\n  âŸ¨âŸ¨limit.lift _ (coneOfDiagramTerminal I F), by\n      ext\n      simp, by simpâŸ©âŸ©\n#align is_iso_Ï€_of_is_terminal is_iso_Ï€_of_is_terminal\n\n",
 "is_iso_Ï€_of_is_initial":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n-- TODO: Show this is an isomorphism if and only if `G` preserves initial objects.\n-- See note [dsimp, simp]\n-- This is reducible to allow usage of lemmas about `cone_point_unique_up_to_iso`.\n-- This is reducible to allow usage of lemmas about `cone_point_unique_up_to_iso`.\n-- This is reducible to allow usage of lemmas about `cocone_point_unique_up_to_iso`.\n-- This is reducible to allow usage of lemmas about `cocone_point_unique_up_to_iso`.\n/-- If `j` is initial in the index category, then the map `limit.Ï€ F j` is an isomorphism.\n-/\ntheorem is_iso_Ï€_of_is_initial {j : J} (I : IsInitial j) (F : Â«expr â¥¤ Â» J C) [HasLimit F] : IsIso (limit.Ï€ F j) :=\n  âŸ¨âŸ¨limit.lift _ (coneOfDiagramInitial I F),\n      âŸ¨by\n        ext\n        simp, by simpâŸ©âŸ©âŸ©\n#align is_iso_Ï€_of_is_initial is_iso_Ï€_of_is_initial\n\n",
 "is_iso_Î¹_of_is_terminal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/-- If `j` is terminal in the index category, then the map `colimit.Î¹ F j` is an isomorphism.\n-/\ntheorem is_iso_Î¹_of_is_terminal {j : J} (I : IsTerminal j) (F : Â«expr â¥¤ Â» J C) [HasColimit F] : IsIso (colimit.Î¹ F j) :=\n  âŸ¨âŸ¨colimit.desc _ (coconeOfDiagramTerminal I F),\n      âŸ¨by simp, by\n        ext\n        simpâŸ©âŸ©âŸ©\n#align is_iso_Î¹_of_is_terminal is_iso_Î¹_of_is_terminal\n\n",
 "is_iso_Î¹_of_is_initial":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem is_iso_Î¹_of_is_initial {j : J} (I : IsInitial j) (F : Â«expr â¥¤ Â» J C) [HasColimit F]\n    [âˆ€ (i j : J) (f : Â«expr âŸ¶ Â» i j), IsIso (F.map f)] : IsIso (colimit.Î¹ F j) :=\n  âŸ¨âŸ¨colimit.desc _ (coconeOfDiagramInitial I F),\n      âŸ¨by tidy, by\n        ext\n        simpâŸ©âŸ©âŸ©\n#align is_iso_Î¹_of_is_initial is_iso_Î¹_of_is_initial\n\n",
 "hom_ext":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/-- Any two morphisms from an initial object are equal. -/\ntheorem is_initial.hom_ext {X Y : C} (t : IsInitial X) (f g : Â«expr âŸ¶ Â» X Y) : f = g :=\n  t.hom_ext (by tidy)\n#align is_initial.hom_ext is_initial.hom_ext\n\n",
 "has_terminal_of_unique":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/-- We can more explicitly show that a category has a terminal object by specifying the object,\nand showing there is a unique morphism to it from any other object. -/\ntheorem has_terminal_of_unique (X : C) [h : âˆ€ Y : C, Unique (Â«expr âŸ¶ Â» Y X)] : HasTerminal C :=\n  { has_limit := fun F => HasLimit.mk âŸ¨_, (isTerminalEquivUnique F X).inv_fun hâŸ© }\n#align has_terminal_of_unique has_terminal_of_unique\n\n",
 "has_terminal_of_has_initial_op":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr áµ’áµ–Â» -/\ntheorem has_terminal_of_has_initial_op [HasInitial (Â«expr áµ’áµ–Â» C)] : HasTerminal C :=\n  (terminalUnopOfInitial initialIsInitial).has_terminal\n#align has_terminal_of_has_initial_op has_terminal_of_has_initial_op\n\n",
 "has_terminal_change_universe":
 "theorem has_terminal_change_universe [h : HasLimitsOfShape (Discrete.{w} PEmpty) C] :\n    HasLimitsOfShape (Discrete.{w'} PEmpty) C :=\n  {\n    has_limit := fun J =>\n      hasTerminalChangeDiagram C\n        (let f := h.1\n        f (Functor.empty C)) }\n#align has_terminal_change_universe has_terminal_change_universe\n\n",
 "has_terminal_change_diagram":
 "theorem has_terminal_change_diagram (h : HasLimit Fâ‚) : HasLimit Fâ‚‚ :=\n  âŸ¨âŸ¨âŸ¨âŸ¨limit Fâ‚, by tidyâŸ©, isLimitChangeEmptyCone C (limit.isLimit Fâ‚) _ (eqToIso rfl)âŸ©âŸ©âŸ©\n#align has_terminal_change_diagram has_terminal_change_diagram\n\n",
 "has_terminal":
 "theorem is_terminal.has_terminal {X : C} (h : IsTerminal X) : HasTerminal C :=\n  { has_limit := fun F => HasLimit.mk âŸ¨âŸ¨X, by tidyâŸ©, isLimitChangeEmptyCone _ h _ (Iso.refl _)âŸ© }\n#align is_terminal.has_terminal is_terminal.has_terminal\n\n",
 "has_initial_of_unique":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/-- We can more explicitly show that a category has an initial object by specifying the object,\nand showing there is a unique morphism from it to any other object. -/\ntheorem has_initial_of_unique (X : C) [h : âˆ€ Y : C, Unique (Â«expr âŸ¶ Â» X Y)] : HasInitial C :=\n  { has_colimit := fun F => HasColimit.mk âŸ¨_, (isInitialEquivUnique F X).inv_fun hâŸ© }\n#align has_initial_of_unique has_initial_of_unique\n\n",
 "has_initial_of_has_terminal_op":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr áµ’áµ–Â» -/\ntheorem has_initial_of_has_terminal_op [HasTerminal (Â«expr áµ’áµ–Â» C)] : HasInitial C :=\n  (initialUnopOfTerminal terminalIsTerminal).has_initial\n#align has_initial_of_has_terminal_op has_initial_of_has_terminal_op\n\n",
 "has_initial_change_universe":
 "theorem has_initial_change_universe [h : HasColimitsOfShape (Discrete.{w} PEmpty) C] :\n    HasColimitsOfShape (Discrete.{w'} PEmpty) C :=\n  {\n    has_colimit := fun J =>\n      hasInitialChangeDiagram C\n        (let f := h.1\n        f (Functor.empty C)) }\n#align has_initial_change_universe has_initial_change_universe\n\n",
 "has_initial_change_diagram":
 "theorem has_initial_change_diagram (h : HasColimit Fâ‚) : HasColimit Fâ‚‚ :=\n  âŸ¨âŸ¨âŸ¨âŸ¨colimit Fâ‚, by tidyâŸ©, isColimitChangeEmptyCocone C (colimit.isColimit Fâ‚) _ (eqToIso rfl)âŸ©âŸ©âŸ©\n#align has_initial_change_diagram has_initial_change_diagram\n\n",
 "has_initial":
 "theorem is_initial.has_initial {X : C} (h : IsInitial X) : HasInitial C :=\n  { has_colimit := fun F => HasColimit.mk âŸ¨âŸ¨X, by tidyâŸ©, isColimitChangeEmptyCocone _ h _ (Iso.refl _)âŸ© }\n#align is_initial.has_initial is_initial.has_initial\n\n",
 "from_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n@[simp]\ntheorem is_terminal.from_self {X : C} (t : IsTerminal X) : t.from X = (Â«exprğŸ™Â») X :=\n  t.hom_ext _ _\n#align is_terminal.from_self is_terminal.from_self\n\n",
 "epi_to":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/-- Any morphism to an initial object is epi. -/\ntheorem is_initial.epi_to {X Y : C} (t : IsInitial X) (f : Â«expr âŸ¶ Â» Y X) : Epi f := by\n  haveI := t.is_split_epi_to f <;> infer_instance\n#align is_initial.epi_to is_initial.epi_to\n\n",
 "comp_from":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n@[simp]\ntheorem terminal.comp_from [HasTerminal C] {P Q : C} (f : Â«expr âŸ¶ Â» P Q) :\n    Â«expr â‰« Â» f (terminal.from Q) = terminal.from P := by tidy\n#align terminal.comp_from terminal.comp_from\n\n"}