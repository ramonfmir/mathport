{"Œπ_colimit_const_initial_hom":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚â´ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚ä•_ ¬ª -/\n@[simp, reassoc.1]\ntheorem Œπ_colimit_const_initial_hom {J : Type _} [Category J] {C : Type _} [Category C] [has_initial C] {j : J} :\n    ¬´expr ‚â´ ¬ª (colimit.Œπ ((category_theory.functor.const J).obj (¬´expr‚ä•_ ¬ª C)) j) colimit_const_initial.hom =\n      initial.to _ :=\n  by ext ‚ü®‚ü®‚ü©‚ü©\n#align Œπ_colimit_const_initial_hom Œπ_colimit_const_initial_hom\n\n",
 "to_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´exprùüô¬ª -/\n@[simp]\ntheorem is_initial.to_self {X : C} (t : is_initial X) : t.to X = (¬´exprùüô¬ª) X :=\n  t.hom_ext _ _\n#align is_initial.to_self is_initial.to_self\n\n",
 "to_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚ü∂ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚â´ ¬ª -/\n@[simp]\ntheorem initial.to_comp [has_initial C] {P Q : C} (f : ¬´expr ‚ü∂ ¬ª P Q) : ¬´expr ‚â´ ¬ª (initial.to P) f = initial.to Q := by\n  tidy\n#align initial.to_comp initial.to_comp\n\n",
 "of_terminal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚ä§_ ¬ª -/\n/-- To show a category is a `initial_mono_class` it suffices to show the unique morphism from the\ninitial object to a terminal object is a monomorphism. -/\ntheorem initial_mono_class.of_terminal [has_initial C] [has_terminal C] (h : Mono (initial.to (¬´expr‚ä§_ ¬ª C))) :\n    initial_mono_class C :=\n  initial_mono_class.of_is_terminal initial_is_initial terminal_is_terminal h\n#align initial_mono_class.of_terminal initial_mono_class.of_terminal\n\n",
 "of_is_terminal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚â´ ¬ª -/\n/-- To show a category is a `initial_mono_class` it suffices to show the unique morphism from an\ninitial object to a terminal object is a monomorphism. -/\ntheorem initial_mono_class.of_is_terminal {I T : C} (hI : is_initial I) (hT : is_terminal T) (f : Mono (hI.to T)) :\n    initial_mono_class C :=\n  initial_mono_class.of_is_initial hI fun X => mono_of_mono_fac (hI.hom_ext (¬´expr ‚â´ ¬ª _ (hT.from X)) (hI.to T))\n#align initial_mono_class.of_is_terminal initial_mono_class.of_is_terminal\n\n",
 "of_is_initial":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚â´ ¬ª -/\n/-- To show a category is a `initial_mono_class` it suffices to give an initial object such that\nevery morphism out of it is a monomorphism. -/\ntheorem initial_mono_class.of_is_initial {I : C} (hI : is_initial I) (h : ‚àÄ X, Mono (hI.to X)) : initial_mono_class C :=\n  {\n    is_initial_mono_from := fun I' X hI' =>\n      by\n      rw [hI'.hom_ext (hI'.to X) (¬´expr ‚â´ ¬ª (hI'.unique_up_to_iso hI).hom (hI.to X))]\n      apply mono_comp }\n#align initial_mono_class.of_is_initial initial_mono_class.of_is_initial\n\n",
 "of_initial":
 "/-- To show a category is a `initial_mono_class` it suffices to show every morphism out of the\ninitial object is a monomorphism. -/\ntheorem initial_mono_class.of_initial [has_initial C] (h : ‚àÄ X : C, Mono (initial.to X)) : initial_mono_class C :=\n  initial_mono_class.of_is_initial initial_is_initial h\n#align initial_mono_class.of_initial initial_mono_class.of_initial\n\n",
 "mono_from":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚ü∂ ¬ª -/\ntheorem is_initial.mono_from [initial_mono_class C] {I} {X : C} (hI : is_initial I) (f : ¬´expr ‚ü∂ ¬ª I X) : Mono f :=\n  by\n  rw [hI.hom_ext f (hI.to X)]\n  apply initial_mono_class.is_initial_mono_from\n#align is_initial.mono_from is_initial.mono_from\n\n",
 "limit_const_terminal_inv_œÄ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚â´ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚ä§_ ¬ª -/\n@[simp, reassoc.1]\ntheorem limit_const_terminal_inv_œÄ {J : Type _} [Category J] {C : Type _} [Category C] [has_terminal C] {j : J} :\n    ¬´expr ‚â´ ¬ª limit_const_terminal.inv (limit.œÄ ((category_theory.functor.const J).obj (¬´expr‚ä§_ ¬ª C)) j) =\n      terminal.from _ :=\n  by ext ‚ü®‚ü®‚ü©‚ü©\n#align limit_const_terminal_inv_œÄ limit_const_terminal_inv_œÄ\n\n",
 "is_split_mono_from":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚ü∂ ¬ª -/\n/-- Any morphism from a terminal object is split mono. -/\ntheorem is_terminal.is_split_mono_from {X Y : C} (t : is_terminal X) (f : ¬´expr ‚ü∂ ¬ª X Y) : is_split_mono f :=\n  is_split_mono.mk' ‚ü®t.from _, t.hom_ext _ _‚ü©\n#align is_terminal.is_split_mono_from is_terminal.is_split_mono_from\n\n",
 "is_split_epi_to":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚ü∂ ¬ª -/\n/-- Any morphism to an initial object is split epi. -/\ntheorem is_initial.is_split_epi_to {X Y : C} (t : is_initial X) (f : ¬´expr ‚ü∂ ¬ª Y X) : is_split_epi f :=\n  is_split_epi.mk' ‚ü®t.to _, t.hom_ext _ _‚ü©\n#align is_initial.is_split_epi_to is_initial.is_split_epi_to\n\n",
 "is_iso_œÄ_of_is_terminal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚•§ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚ü∂ ¬ª -/\ntheorem is_iso_œÄ_of_is_terminal {j : J} (I : is_terminal j) (F : ¬´expr ‚•§ ¬ª J C) [has_limit F]\n    [‚àÄ (i j : J) (f : ¬´expr ‚ü∂ ¬ª i j), IsIso (F.map f)] : IsIso (limit.œÄ F j) :=\n  ‚ü®‚ü®limit.lift _ (cone_of_diagram_terminal I F), by\n      ext\n      simp, by simp‚ü©‚ü©\n#align is_iso_œÄ_of_is_terminal is_iso_œÄ_of_is_terminal\n\n",
 "is_iso_œÄ_of_is_initial":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚•§ ¬ª -/\n-- TODO: Show this is an isomorphism if and only if `G` preserves initial objects.\n-- See note [dsimp, simp]\n-- This is reducible to allow usage of lemmas about `cone_point_unique_up_to_iso`.\n-- This is reducible to allow usage of lemmas about `cone_point_unique_up_to_iso`.\n-- This is reducible to allow usage of lemmas about `cocone_point_unique_up_to_iso`.\n-- This is reducible to allow usage of lemmas about `cocone_point_unique_up_to_iso`.\n/-- If `j` is initial in the index category, then the map `limit.œÄ F j` is an isomorphism.\n-/\ntheorem is_iso_œÄ_of_is_initial {j : J} (I : is_initial j) (F : ¬´expr ‚•§ ¬ª J C) [has_limit F] : IsIso (limit.œÄ F j) :=\n  ‚ü®‚ü®limit.lift _ (cone_of_diagram_initial I F),\n      ‚ü®by\n        ext\n        simp, by simp‚ü©‚ü©‚ü©\n#align is_iso_œÄ_of_is_initial is_iso_œÄ_of_is_initial\n\n",
 "is_iso_Œπ_of_is_terminal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚•§ ¬ª -/\n/-- If `j` is terminal in the index category, then the map `colimit.Œπ F j` is an isomorphism.\n-/\ntheorem is_iso_Œπ_of_is_terminal {j : J} (I : is_terminal j) (F : ¬´expr ‚•§ ¬ª J C) [has_colimit F] :\n    IsIso (colimit.Œπ F j) :=\n  ‚ü®‚ü®colimit.desc _ (cocone_of_diagram_terminal I F),\n      ‚ü®by simp, by\n        ext\n        simp‚ü©‚ü©‚ü©\n#align is_iso_Œπ_of_is_terminal is_iso_Œπ_of_is_terminal\n\n",
 "is_iso_Œπ_of_is_initial":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚•§ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚ü∂ ¬ª -/\ntheorem is_iso_Œπ_of_is_initial {j : J} (I : is_initial j) (F : ¬´expr ‚•§ ¬ª J C) [has_colimit F]\n    [‚àÄ (i j : J) (f : ¬´expr ‚ü∂ ¬ª i j), IsIso (F.map f)] : IsIso (colimit.Œπ F j) :=\n  ‚ü®‚ü®colimit.desc _ (cocone_of_diagram_initial I F),\n      ‚ü®by tidy, by\n        ext\n        simp‚ü©‚ü©‚ü©\n#align is_iso_Œπ_of_is_initial is_iso_Œπ_of_is_initial\n\n",
 "hom_ext":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚ü∂ ¬ª -/\n/-- Any two morphisms from an initial object are equal. -/\ntheorem is_initial.hom_ext {X Y : C} (t : is_initial X) (f g : ¬´expr ‚ü∂ ¬ª X Y) : f = g :=\n  t.hom_ext (by tidy)\n#align is_initial.hom_ext is_initial.hom_ext\n\n",
 "has_terminal_of_unique":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚ü∂ ¬ª -/\n/-- We can more explicitly show that a category has a terminal object by specifying the object,\nand showing there is a unique morphism to it from any other object. -/\ntheorem has_terminal_of_unique (X : C) [h : ‚àÄ Y : C, unique (¬´expr ‚ü∂ ¬ª Y X)] : has_terminal C :=\n  { has_limit := fun F => has_limit.mk ‚ü®_, (is_terminal_equiv_unique F X).inv_fun h‚ü© }\n#align has_terminal_of_unique has_terminal_of_unique\n\n",
 "has_terminal_of_has_initial_op":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ·µí·µñ¬ª -/\ntheorem has_terminal_of_has_initial_op [has_initial (¬´expr ·µí·µñ¬ª C)] : has_terminal C :=\n  (terminal_unop_of_initial initial_is_initial).has_terminal\n#align has_terminal_of_has_initial_op has_terminal_of_has_initial_op\n\n",
 "has_terminal_change_universe":
 "theorem has_terminal_change_universe [h : has_limits_of_shape (discrete.{w} PEmpty) C] :\n    has_limits_of_shape (discrete.{w'} PEmpty) C :=\n  {\n    has_limit := fun J =>\n      has_terminal_change_diagram C\n        (let f := h.1\n        f (functor.empty C)) }\n#align has_terminal_change_universe has_terminal_change_universe\n\n",
 "has_terminal_change_diagram":
 "theorem has_terminal_change_diagram (h : has_limit F‚ÇÅ) : has_limit F‚ÇÇ :=\n  ‚ü®‚ü®‚ü®‚ü®limit F‚ÇÅ, by tidy‚ü©, is_limit_change_empty_cone C (limit.is_limit F‚ÇÅ) _ (eq_to_iso rfl)‚ü©‚ü©‚ü©\n#align has_terminal_change_diagram has_terminal_change_diagram\n\n",
 "has_terminal":
 "theorem is_terminal.has_terminal {X : C} (h : is_terminal X) : has_terminal C :=\n  { has_limit := fun F => has_limit.mk ‚ü®‚ü®X, by tidy‚ü©, is_limit_change_empty_cone _ h _ (Iso.refl _)‚ü© }\n#align is_terminal.has_terminal is_terminal.has_terminal\n\n",
 "has_initial_of_unique":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚ü∂ ¬ª -/\n/-- We can more explicitly show that a category has an initial object by specifying the object,\nand showing there is a unique morphism from it to any other object. -/\ntheorem has_initial_of_unique (X : C) [h : ‚àÄ Y : C, unique (¬´expr ‚ü∂ ¬ª X Y)] : has_initial C :=\n  { has_colimit := fun F => has_colimit.mk ‚ü®_, (is_initial_equiv_unique F X).inv_fun h‚ü© }\n#align has_initial_of_unique has_initial_of_unique\n\n",
 "has_initial_of_has_terminal_op":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ·µí·µñ¬ª -/\ntheorem has_initial_of_has_terminal_op [has_terminal (¬´expr ·µí·µñ¬ª C)] : has_initial C :=\n  (initial_unop_of_terminal terminal_is_terminal).has_initial\n#align has_initial_of_has_terminal_op has_initial_of_has_terminal_op\n\n",
 "has_initial_change_universe":
 "theorem has_initial_change_universe [h : has_colimits_of_shape (discrete.{w} PEmpty) C] :\n    has_colimits_of_shape (discrete.{w'} PEmpty) C :=\n  {\n    has_colimit := fun J =>\n      has_initial_change_diagram C\n        (let f := h.1\n        f (functor.empty C)) }\n#align has_initial_change_universe has_initial_change_universe\n\n",
 "has_initial_change_diagram":
 "theorem has_initial_change_diagram (h : has_colimit F‚ÇÅ) : has_colimit F‚ÇÇ :=\n  ‚ü®‚ü®‚ü®‚ü®colimit F‚ÇÅ, by tidy‚ü©, is_colimit_change_empty_cocone C (colimit.is_colimit F‚ÇÅ) _ (eq_to_iso rfl)‚ü©‚ü©‚ü©\n#align has_initial_change_diagram has_initial_change_diagram\n\n",
 "has_initial":
 "theorem is_initial.has_initial {X : C} (h : is_initial X) : has_initial C :=\n  { has_colimit := fun F => has_colimit.mk ‚ü®‚ü®X, by tidy‚ü©, is_colimit_change_empty_cocone _ h _ (Iso.refl _)‚ü© }\n#align is_initial.has_initial is_initial.has_initial\n\n",
 "from_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´exprùüô¬ª -/\n@[simp]\ntheorem is_terminal.from_self {X : C} (t : is_terminal X) : t.from X = (¬´exprùüô¬ª) X :=\n  t.hom_ext _ _\n#align is_terminal.from_self is_terminal.from_self\n\n",
 "epi_to":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚ü∂ ¬ª -/\n/-- Any morphism to an initial object is epi. -/\ntheorem is_initial.epi_to {X Y : C} (t : is_initial X) (f : ¬´expr ‚ü∂ ¬ª Y X) : Epi f := by\n  haveI := t.is_split_epi_to f <;> infer_instance\n#align is_initial.epi_to is_initial.epi_to\n\n",
 "comp_from":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚ü∂ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚â´ ¬ª -/\n@[simp]\ntheorem terminal.comp_from [has_terminal C] {P Q : C} (f : ¬´expr ‚ü∂ ¬ª P Q) :\n    ¬´expr ‚â´ ¬ª f (terminal.from Q) = terminal.from P := by tidy\n#align terminal.comp_from terminal.comp_from\n\n"}