{"pullback":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/-- If `a₁ a₂ : A ⟶ Y` is a kernel pair for `g : Y ⟶ Z`, then `a₁ ×[Z] X` and `a₂ ×[Z] X`\n(`A ×[Z] X ⟶ Y ×[Z] X`) is a kernel pair for `Y ×[Z] X ⟶ X`. -/\nprotected theorem pullback {X Y Z A : C} {g : «expr ⟶ » Y Z} {a₁ a₂ : «expr ⟶ » A Y} (h : is_kernel_pair g a₁ a₂)\n    (f : «expr ⟶ » X Z) [has_pullback f g] [has_pullback f («expr ≫ » a₁ g)] :\n    is_kernel_pair (pullback.fst : «expr ⟶ » (pullback f g) X)\n      (pullback.map f _ f _ ((«expr𝟙») X) a₁ ((«expr𝟙») Z) (by simp) <| category.comp_id _)\n      (pullback.map _ _ _ _ ((«expr𝟙») X) a₂ ((«expr𝟙») Z) (by simp) <| (category.comp_id _).trans h.1.1) :=\n  by\n  refine' ⟨⟨_⟩, ⟨_⟩⟩\n  · rw [pullback.lift_fst, pullback.lift_fst]\n  · fapply pullback_cone.is_limit_aux'\n    intro s\n    refine'\n      ⟨pullback.lift («expr ≫ » s.fst pullback.fst)\n          (h.lift' («expr ≫ » s.fst pullback.snd) («expr ≫ » s.snd pullback.snd) _).1 _,\n        _, _, _⟩\n    · simp_rw [category.assoc, ← pullback.condition, ← category.assoc, s.condition]\n    · rw [← category.assoc, (h.lift' _ _ _).2.1, category.assoc, category.assoc, pullback.condition]\n    · rw [limits.pullback_cone.mk_fst]\n      ext <;>\n        simp only [category.assoc, pullback.lift_fst, pullback.lift_snd, pullback.lift_snd_assoc, category.comp_id,\n          (h.lift' _ _ _).2.1]\n    · rw [limits.pullback_cone.mk_snd]\n      ext <;>\n        simp only [category.assoc, pullback.lift_fst, pullback.lift_snd, pullback.lift_snd_assoc, category.comp_id,\n          (h.lift' _ _ _).2.2, s.condition]\n    · intro m h₁ h₂\n      ext\n      · rw [pullback.lift_fst]\n        conv_rhs => rw [← h₁, category.assoc, pullback_cone.mk_fst]\n        congr 1\n        refine' ((pullback.lift_fst _ _ _).trans <| category.comp_id _).symm\n      · rw [pullback.lift_snd]\n        apply pullback_cone.is_limit.hom_ext h.is_limit <;> dsimp only [is_pullback.cone, comm_sq.cone] <;>\n          simp only [pullback_cone.mk_fst, pullback_cone.mk_snd, category.assoc, (h.lift' _ _ _).2.1,\n            (h.lift' _ _ _).2.2]\n        · conv_rhs => rw [← h₁, category.assoc, pullback_cone.mk_fst, pullback.lift_snd]\n        · conv_rhs => rw [← h₂, category.assoc, pullback_cone.mk_snd, pullback.lift_snd]\n#align pullback pullback\n\n",
 "of_is_iso_of_mono":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\ntheorem of_is_iso_of_mono [IsIso a] [Mono f] : is_kernel_pair f a a :=\n  by\n  delta is_kernel_pair\n  convert_to is_pullback a («expr ≫ » a ((«expr𝟙») X)) («expr ≫ » ((«expr𝟙») X) f) f\n  · rw [category.comp_id]; · rw [category.id_comp]\n  exact (is_pullback.of_horiz_is_iso ⟨rfl⟩).paste_vert (is_kernel_pair.id_of_mono f)\n#align of_is_iso_of_mono of_is_iso_of_mono\n\n",
 "mono_of_is_iso_fst":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\ntheorem mono_of_is_iso_fst (h : is_kernel_pair f a b) [IsIso a] : Mono f :=\n  by\n  obtain ⟨l, h₁, h₂⟩ := limits.pullback_cone.is_limit.lift' h.is_limit ((«expr𝟙») _) ((«expr𝟙») _) (by simp [h.w])\n  rw [is_pullback.cone_fst, ← is_iso.eq_comp_inv, category.id_comp] at h₁\n  rw [h₁, is_iso.inv_comp_eq, category.comp_id] at h₂\n  constructor\n  intro Z g₁ g₂ e\n  obtain ⟨l', rfl, rfl⟩ := limits.pullback_cone.is_limit.lift' h.is_limit _ _ e\n  rw [is_pullback.cone_fst, h₂]\n#align mono_of_is_iso_fst mono_of_is_iso_fst\n\n",
 "is_iso_of_mono":
 "theorem is_iso_of_mono (h : is_kernel_pair f a b) [Mono f] : IsIso a :=\n  by\n  rw [←\n    show _ = a from\n      (category.comp_id _).symm.trans\n        ((is_kernel_pair.id_of_mono f).is_limit.cone_point_unique_up_to_iso_inv_comp h.is_limit walking_cospan.left)]\n  infer_instance\n#align is_iso_of_mono is_iso_of_mono\n\n",
 "id_of_mono":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/-\nCopyright (c) 2020 Bhavik Mehta. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Bhavik Mehta\n-/\n/-- If `f` is a monomorphism, then `(𝟙 _, 𝟙 _)`  is a kernel pair for `f`. -/\ntheorem id_of_mono [Mono f] : is_kernel_pair f ((«expr𝟙») _) ((«expr𝟙») _) :=\n  ⟨⟨rfl⟩, ⟨pullback_cone.is_limit_mk_id_id _⟩⟩\n#align id_of_mono id_of_mono\n\n",
 "comp_of_mono":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/-- If `(a,b)` is a kernel pair for `f₁` and `f₂` is mono, then `(a,b)` is a kernel pair for `f₁ ≫ f₂`.\nThe converse of `cancel_right_of_mono`.\n-/\ntheorem comp_of_mono {f₁ : «expr ⟶ » X Y} {f₂ : «expr ⟶ » Y Z} [Mono f₂] (small_k : is_kernel_pair f₁ a b) :\n    is_kernel_pair («expr ≫ » f₁ f₂) a b :=\n  { w := by rw [small_k.w_assoc]\n    is_limit' :=\n      ⟨pullback_cone.is_limit_aux' _ fun s => by\n          refine' ⟨_, _, _, _⟩\n          apply (pullback_cone.is_limit.lift' small_k.is_limit s.fst s.snd _).1\n          rw [← cancel_mono f₂, assoc, s.condition, assoc]\n          apply (pullback_cone.is_limit.lift' small_k.is_limit s.fst s.snd _).2.1\n          apply (pullback_cone.is_limit.lift' small_k.is_limit s.fst s.snd _).2.2\n          intro m m₁ m₂\n          apply small_k.is_limit.hom_ext\n          refine' (pullback_cone.mk a b _ : pullback_cone f₁ _).equalizer_ext _ _\n          · exact m₁.trans (pullback_cone.is_limit.lift' small_k.is_limit s.fst s.snd _).2.1.symm\n          · exact m₂.trans (pullback_cone.is_limit.lift' small_k.is_limit s.fst s.snd _).2.2.symm⟩ }\n#align comp_of_mono comp_of_mono\n\n",
 "cancel_right_of_mono":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/-- If `(a,b)` is a kernel pair for `f₁ ≫ f₂` and `f₂` is mono, then `(a,b)` is a kernel pair for\njust `f₁`.\nThe converse of `comp_of_mono`.\n-/\ntheorem cancel_right_of_mono {f₁ : «expr ⟶ » X Y} {f₂ : «expr ⟶ » Y Z} [Mono f₂]\n    (big_k : is_kernel_pair («expr ≫ » f₁ f₂) a b) : is_kernel_pair f₁ a b :=\n  cancel_right (by rw [← cancel_mono f₂, assoc, assoc, big_k.w]) big_k\n#align cancel_right_of_mono cancel_right_of_mono\n\n",
 "cancel_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/-- If `(a,b)` is a kernel pair for `f₁ ≫ f₂` and `a ≫ f₁ = b ≫ f₁`, then `(a,b)` is a kernel pair for\njust `f₁`.\nThat is, to show that `(a,b)` is a kernel pair for `f₁` it suffices to only show the square\ncommutes, rather than to additionally show it's a pullback.\n-/\ntheorem cancel_right {f₁ : «expr ⟶ » X Y} {f₂ : «expr ⟶ » Y Z} (comm : «expr ≫ » a f₁ = «expr ≫ » b f₁)\n    (big_k : is_kernel_pair («expr ≫ » f₁ f₂) a b) : is_kernel_pair f₁ a b :=\n  { w := comm\n    is_limit' :=\n      ⟨pullback_cone.is_limit_aux' _ fun s =>\n          by\n          let s' : pullback_cone («expr ≫ » f₁ f₂) («expr ≫ » f₁ f₂) :=\n            pullback_cone.mk s.fst s.snd (s.condition_assoc _)\n          refine'\n            ⟨big_k.is_limit.lift s', big_k.is_limit.fac _ walking_cospan.left,\n              big_k.is_limit.fac _ walking_cospan.right, fun m m₁ m₂ => _⟩\n          apply big_k.is_limit.hom_ext\n          refine' (pullback_cone.mk a b _ : pullback_cone («expr ≫ » f₁ f₂) _).equalizer_ext _ _\n          apply m₁.trans (big_k.is_limit.fac s' walking_cospan.left).symm\n          apply m₂.trans (big_k.is_limit.fac s' walking_cospan.right).symm⟩ }\n#align cancel_right cancel_right\n\n"}