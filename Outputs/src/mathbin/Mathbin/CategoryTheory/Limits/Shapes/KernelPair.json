{"pullback":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n/-- If `aâ‚ aâ‚‚ : A âŸ¶ Y` is a kernel pair for `g : Y âŸ¶ Z`, then `aâ‚ Ã—[Z] X` and `aâ‚‚ Ã—[Z] X`\n(`A Ã—[Z] X âŸ¶ Y Ã—[Z] X`) is a kernel pair for `Y Ã—[Z] X âŸ¶ X`. -/\nprotected theorem pullback {X Y Z A : C} {g : Â«expr âŸ¶ Â» Y Z} {aâ‚ aâ‚‚ : Â«expr âŸ¶ Â» A Y} (h : is_kernel_pair g aâ‚ aâ‚‚)\n    (f : Â«expr âŸ¶ Â» X Z) [has_pullback f g] [has_pullback f (Â«expr â‰« Â» aâ‚ g)] :\n    is_kernel_pair (pullback.fst : Â«expr âŸ¶ Â» (pullback f g) X)\n      (pullback.map f _ f _ ((Â«exprğŸ™Â») X) aâ‚ ((Â«exprğŸ™Â») Z) (by simp) <| category.comp_id _)\n      (pullback.map _ _ _ _ ((Â«exprğŸ™Â») X) aâ‚‚ ((Â«exprğŸ™Â») Z) (by simp) <| (category.comp_id _).trans h.1.1) :=\n  by\n  refine' âŸ¨âŸ¨_âŸ©, âŸ¨_âŸ©âŸ©\n  Â· rw [pullback.lift_fst, pullback.lift_fst]\n  Â· fapply pullback_cone.is_limit_aux'\n    intro s\n    refine'\n      âŸ¨pullback.lift (Â«expr â‰« Â» s.fst pullback.fst)\n          (h.lift' (Â«expr â‰« Â» s.fst pullback.snd) (Â«expr â‰« Â» s.snd pullback.snd) _).1 _,\n        _, _, _âŸ©\n    Â· simp_rw [category.assoc, â† pullback.condition, â† category.assoc, s.condition]\n    Â· rw [â† category.assoc, (h.lift' _ _ _).2.1, category.assoc, category.assoc, pullback.condition]\n    Â· rw [limits.pullback_cone.mk_fst]\n      ext <;>\n        simp only [category.assoc, pullback.lift_fst, pullback.lift_snd, pullback.lift_snd_assoc, category.comp_id,\n          (h.lift' _ _ _).2.1]\n    Â· rw [limits.pullback_cone.mk_snd]\n      ext <;>\n        simp only [category.assoc, pullback.lift_fst, pullback.lift_snd, pullback.lift_snd_assoc, category.comp_id,\n          (h.lift' _ _ _).2.2, s.condition]\n    Â· intro m hâ‚ hâ‚‚\n      ext\n      Â· rw [pullback.lift_fst]\n        conv_rhs => rw [â† hâ‚, category.assoc, pullback_cone.mk_fst]\n        congr 1\n        refine' ((pullback.lift_fst _ _ _).trans <| category.comp_id _).symm\n      Â· rw [pullback.lift_snd]\n        apply pullback_cone.is_limit.hom_ext h.is_limit <;> dsimp only [is_pullback.cone, comm_sq.cone] <;>\n          simp only [pullback_cone.mk_fst, pullback_cone.mk_snd, category.assoc, (h.lift' _ _ _).2.1,\n            (h.lift' _ _ _).2.2]\n        Â· conv_rhs => rw [â† hâ‚, category.assoc, pullback_cone.mk_fst, pullback.lift_snd]\n        Â· conv_rhs => rw [â† hâ‚‚, category.assoc, pullback_cone.mk_snd, pullback.lift_snd]\n#align pullback pullback\n\n",
 "of_is_iso_of_mono":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\ntheorem of_is_iso_of_mono [IsIso a] [Mono f] : is_kernel_pair f a a :=\n  by\n  delta is_kernel_pair\n  convert_to is_pullback a (Â«expr â‰« Â» a ((Â«exprğŸ™Â») X)) (Â«expr â‰« Â» ((Â«exprğŸ™Â») X) f) f\n  Â· rw [category.comp_id]; Â· rw [category.id_comp]\n  exact (is_pullback.of_horiz_is_iso âŸ¨rflâŸ©).paste_vert (is_kernel_pair.id_of_mono f)\n#align of_is_iso_of_mono of_is_iso_of_mono\n\n",
 "mono_of_is_iso_fst":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\ntheorem mono_of_is_iso_fst (h : is_kernel_pair f a b) [IsIso a] : Mono f :=\n  by\n  obtain âŸ¨l, hâ‚, hâ‚‚âŸ© := limits.pullback_cone.is_limit.lift' h.is_limit ((Â«exprğŸ™Â») _) ((Â«exprğŸ™Â») _) (by simp [h.w])\n  rw [is_pullback.cone_fst, â† is_iso.eq_comp_inv, category.id_comp] at hâ‚\n  rw [hâ‚, is_iso.inv_comp_eq, category.comp_id] at hâ‚‚\n  constructor\n  intro Z gâ‚ gâ‚‚ e\n  obtain âŸ¨l', rfl, rflâŸ© := limits.pullback_cone.is_limit.lift' h.is_limit _ _ e\n  rw [is_pullback.cone_fst, hâ‚‚]\n#align mono_of_is_iso_fst mono_of_is_iso_fst\n\n",
 "is_iso_of_mono":
 "theorem is_iso_of_mono (h : is_kernel_pair f a b) [Mono f] : IsIso a :=\n  by\n  rw [â†\n    show _ = a from\n      (category.comp_id _).symm.trans\n        ((is_kernel_pair.id_of_mono f).is_limit.cone_point_unique_up_to_iso_inv_comp h.is_limit walking_cospan.left)]\n  infer_instance\n#align is_iso_of_mono is_iso_of_mono\n\n",
 "id_of_mono":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n/-\nCopyright (c) 2020 Bhavik Mehta. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Bhavik Mehta\n-/\n/-- If `f` is a monomorphism, then `(ğŸ™ _, ğŸ™ _)`  is a kernel pair for `f`. -/\ntheorem id_of_mono [Mono f] : is_kernel_pair f ((Â«exprğŸ™Â») _) ((Â«exprğŸ™Â») _) :=\n  âŸ¨âŸ¨rflâŸ©, âŸ¨pullback_cone.is_limit_mk_id_id _âŸ©âŸ©\n#align id_of_mono id_of_mono\n\n",
 "comp_of_mono":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/-- If `(a,b)` is a kernel pair for `fâ‚` and `fâ‚‚` is mono, then `(a,b)` is a kernel pair for `fâ‚ â‰« fâ‚‚`.\nThe converse of `cancel_right_of_mono`.\n-/\ntheorem comp_of_mono {fâ‚ : Â«expr âŸ¶ Â» X Y} {fâ‚‚ : Â«expr âŸ¶ Â» Y Z} [Mono fâ‚‚] (small_k : is_kernel_pair fâ‚ a b) :\n    is_kernel_pair (Â«expr â‰« Â» fâ‚ fâ‚‚) a b :=\n  { w := by rw [small_k.w_assoc]\n    is_limit' :=\n      âŸ¨pullback_cone.is_limit_aux' _ fun s => by\n          refine' âŸ¨_, _, _, _âŸ©\n          apply (pullback_cone.is_limit.lift' small_k.is_limit s.fst s.snd _).1\n          rw [â† cancel_mono fâ‚‚, assoc, s.condition, assoc]\n          apply (pullback_cone.is_limit.lift' small_k.is_limit s.fst s.snd _).2.1\n          apply (pullback_cone.is_limit.lift' small_k.is_limit s.fst s.snd _).2.2\n          intro m mâ‚ mâ‚‚\n          apply small_k.is_limit.hom_ext\n          refine' (pullback_cone.mk a b _ : pullback_cone fâ‚ _).equalizer_ext _ _\n          Â· exact mâ‚.trans (pullback_cone.is_limit.lift' small_k.is_limit s.fst s.snd _).2.1.symm\n          Â· exact mâ‚‚.trans (pullback_cone.is_limit.lift' small_k.is_limit s.fst s.snd _).2.2.symmâŸ© }\n#align comp_of_mono comp_of_mono\n\n",
 "cancel_right_of_mono":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/-- If `(a,b)` is a kernel pair for `fâ‚ â‰« fâ‚‚` and `fâ‚‚` is mono, then `(a,b)` is a kernel pair for\njust `fâ‚`.\nThe converse of `comp_of_mono`.\n-/\ntheorem cancel_right_of_mono {fâ‚ : Â«expr âŸ¶ Â» X Y} {fâ‚‚ : Â«expr âŸ¶ Â» Y Z} [Mono fâ‚‚]\n    (big_k : is_kernel_pair (Â«expr â‰« Â» fâ‚ fâ‚‚) a b) : is_kernel_pair fâ‚ a b :=\n  cancel_right (by rw [â† cancel_mono fâ‚‚, assoc, assoc, big_k.w]) big_k\n#align cancel_right_of_mono cancel_right_of_mono\n\n",
 "cancel_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/-- If `(a,b)` is a kernel pair for `fâ‚ â‰« fâ‚‚` and `a â‰« fâ‚ = b â‰« fâ‚`, then `(a,b)` is a kernel pair for\njust `fâ‚`.\nThat is, to show that `(a,b)` is a kernel pair for `fâ‚` it suffices to only show the square\ncommutes, rather than to additionally show it's a pullback.\n-/\ntheorem cancel_right {fâ‚ : Â«expr âŸ¶ Â» X Y} {fâ‚‚ : Â«expr âŸ¶ Â» Y Z} (comm : Â«expr â‰« Â» a fâ‚ = Â«expr â‰« Â» b fâ‚)\n    (big_k : is_kernel_pair (Â«expr â‰« Â» fâ‚ fâ‚‚) a b) : is_kernel_pair fâ‚ a b :=\n  { w := comm\n    is_limit' :=\n      âŸ¨pullback_cone.is_limit_aux' _ fun s =>\n          by\n          let s' : pullback_cone (Â«expr â‰« Â» fâ‚ fâ‚‚) (Â«expr â‰« Â» fâ‚ fâ‚‚) :=\n            pullback_cone.mk s.fst s.snd (s.condition_assoc _)\n          refine'\n            âŸ¨big_k.is_limit.lift s', big_k.is_limit.fac _ walking_cospan.left,\n              big_k.is_limit.fac _ walking_cospan.right, fun m mâ‚ mâ‚‚ => _âŸ©\n          apply big_k.is_limit.hom_ext\n          refine' (pullback_cone.mk a b _ : pullback_cone (Â«expr â‰« Â» fâ‚ fâ‚‚) _).equalizer_ext _ _\n          apply mâ‚.trans (big_k.is_limit.fac s' walking_cospan.left).symm\n          apply mâ‚‚.trans (big_k.is_limit.fac s' walking_cospan.right).symmâŸ© }\n#align cancel_right cancel_right\n\n"}