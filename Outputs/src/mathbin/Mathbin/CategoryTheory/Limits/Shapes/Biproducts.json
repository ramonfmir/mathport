{"π_of_is_colimit":
 "/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:76:14: unsupported tactic `discrete_cases #[] -/\ntheorem π_of_is_colimit {f : J → C} {t : bicone f} (ht : is_colimit t.to_cocone) (j : J) :\n    t.π j = ht.desc (cofan.mk _ fun j' => if h : j' = j then eq_to_hom (congr_arg f h) else 0) :=\n  ht.hom_ext fun j' => by\n    rw [ht.fac]\n    trace \"./././Mathport/Syntax/Translate/Tactic/Builtin.lean:76:14: unsupported tactic `discrete_cases #[]\"\n    simp [t.ι_π]\n#align π_of_is_colimit π_of_is_colimit\n\n",
 "ι_π_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n@[simp, reassoc.1]\ntheorem biproduct.ι_π_self (f : J → C) [has_biproduct f] (j : J) :\n    «expr ≫ » (biproduct.ι f j) (biproduct.π f j) = («expr𝟙») _ := by simp [biproduct.ι_π]\n#align biproduct.ι_π_self biproduct.ι_π_self\n\n",
 "ι_π_ne":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem biproduct.ι_π_ne (f : J → C) [has_biproduct f] {j j' : J} (h : j ≠ j') :\n    «expr ≫ » (biproduct.ι f j) (biproduct.π f j') = 0 := by simp [biproduct.ι_π, h]\n#align biproduct.ι_π_ne biproduct.ι_π_ne\n\n",
 "ι_π":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/-- Note that as this lemma has a `if` in the statement, we include a `decidable_eq` argument.\nThis means you may not be able to `simp` using this lemma unless you `open_locale classical`. -/\n@[reassoc.1]\ntheorem biproduct.ι_π [decidable_eq J] (f : J → C) [has_biproduct f] (j j' : J) :\n    «expr ≫ » (biproduct.ι f j) (biproduct.π f j') = if h : j = j' then eq_to_hom (congr_arg f h) else 0 := by\n  convert (biproduct.bicone f).ι_π j j'\n#align biproduct.ι_π biproduct.ι_π\n\n",
 "ι_to_subtype_subtype":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem biproduct.ι_to_subtype_subtype (j : subtype p) :\n    «expr ≫ » (biproduct.ι f j) (biproduct.to_subtype f p) = biproduct.ι (subtype.restrict p f) j :=\n  by\n  ext i\n  rw [biproduct.to_subtype, category.assoc, biproduct.lift_π, biproduct.ι_π, biproduct.ι_π]\n  split_ifs with h₁ h₂ h₂\n  exacts[rfl, false.elim (h₂ (subtype.ext h₁)), false.elim (h₁ (congr_arg subtype.val h₂)), rfl]\n#align biproduct.ι_to_subtype_subtype biproduct.ι_to_subtype_subtype\n\n",
 "ι_to_subtype":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem biproduct.ι_to_subtype [decidable_pred p] (j : J) :\n    «expr ≫ » (biproduct.ι f j) (biproduct.to_subtype f p) =\n      if h : p j then biproduct.ι (subtype.restrict p f) ⟨j, h⟩ else 0 :=\n  by\n  ext i\n  rw [biproduct.to_subtype, category.assoc, biproduct.lift_π, biproduct.ι_π]\n  by_cases h : p j\n  · rw [dif_pos h, biproduct.ι_π]\n    split_ifs with h₁ h₂ h₂\n    exacts[rfl, false.elim (h₂ (subtype.ext h₁)), false.elim (h₁ (congr_arg subtype.val h₂)), rfl]\n  · rw [dif_neg h, dif_neg (show j ≠ i from fun h₂ => h (h₂.symm ▸ i.2)), zero_comp]\n#align biproduct.ι_to_subtype biproduct.ι_to_subtype\n\n",
 "ι_of_is_limit":
 "/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:76:14: unsupported tactic `discrete_cases #[] -/\ntheorem ι_of_is_limit {f : J → C} {t : bicone f} (ht : is_limit t.to_cone) (j : J) :\n    t.ι j = ht.lift (fan.mk _ fun j' => if h : j = j' then eq_to_hom (congr_arg f h) else 0) :=\n  ht.hom_ext fun j' => by\n    rw [ht.fac]\n    trace \"./././Mathport/Syntax/Translate/Tactic/Builtin.lean:76:14: unsupported tactic `discrete_cases #[]\"\n    simp [t.ι_π]\n#align ι_of_is_limit ι_of_is_limit\n\n",
 "ι_matrix":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem biproduct.ι_matrix (m : ∀ j k, «expr ⟶ » (f j) (g k)) (j : J) :\n    «expr ≫ » (biproduct.ι f j) (biproduct.matrix m) = biproduct.lift fun k => m j k :=\n  by\n  ext\n  simp [biproduct.matrix]\n#align biproduct.ι_matrix biproduct.ι_matrix\n\n",
 "ι_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem biproduct.ι_map {f g : J → C} [has_biproduct f] [has_biproduct g] (p : ∀ j, «expr ⟶ » (f j) (g j)) (j : J) :\n    «expr ≫ » (biproduct.ι f j) (biproduct.map p) = «expr ≫ » (p j) (biproduct.ι g j) :=\n  by\n  rw [biproduct.map_eq_map']\n  convert limits.is_colimit.ι_map _ _ _ (discrete.mk j) <;> rfl\n#align biproduct.ι_map biproduct.ι_map\n\n",
 "ι_from_subtype":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem biproduct.ι_from_subtype (j : subtype p) :\n    «expr ≫ » (biproduct.ι (subtype.restrict p f) j) (biproduct.from_subtype f p) = biproduct.ι f j :=\n  biproduct.ι_desc _ _\n#align biproduct.ι_from_subtype biproduct.ι_from_subtype\n\n",
 "ι_desc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem biproduct.ι_desc {f : J → C} [has_biproduct f] {P : C} (p : ∀ b, «expr ⟶ » (f b) P) (j : J) :\n    «expr ≫ » (biproduct.ι f j) (biproduct.desc p) = p j :=\n  (biproduct.is_colimit f).fac _ ⟨j⟩\n#align biproduct.ι_desc biproduct.ι_desc\n\n",
 "to_subtype_π":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem biproduct.to_subtype_π (j : subtype p) :\n    «expr ≫ » (biproduct.to_subtype f p) (biproduct.π (subtype.restrict p f) j) = biproduct.π f j :=\n  biproduct.lift_π _ _\n#align biproduct.to_subtype_π biproduct.to_subtype_π\n\n",
 "to_subtype_from_subtype":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n@[simp, reassoc.1]\ntheorem biproduct.to_subtype_from_subtype [decidable_pred p] :\n    «expr ≫ » (biproduct.to_subtype f p) (biproduct.from_subtype f p) =\n      biproduct.map fun j => if p j then («expr𝟙») (f j) else 0 :=\n  by\n  ext1 i\n  by_cases h : p i\n  · simp [h]\n    congr\n  · simp [h]\n#align biproduct.to_subtype_from_subtype biproduct.to_subtype_from_subtype\n\n",
 "to_subtype_eq_desc":
 "theorem biproduct.to_subtype_eq_desc [decidable_pred p] :\n    biproduct.to_subtype f p =\n      biproduct.desc fun j => if h : p j then biproduct.ι (subtype.restrict p f) ⟨j, h⟩ else 0 :=\n  biproduct.hom_ext' _ _ (by simp)\n#align biproduct.to_subtype_eq_desc biproduct.to_subtype_eq_desc\n\n",
 "to_cone_π_app_right":
 "@[simp]\ntheorem to_cone_π_app_right (c : binary_bicone P Q) : c.to_cone.π.app ⟨walking_pair.right⟩ = c.snd :=\n  rfl\n#align to_cone_π_app_right to_cone_π_app_right\n\n",
 "to_cone_π_app_mk":
 "theorem to_cone_π_app_mk (B : bicone F) (j : J) : B.to_cone.π.app ⟨j⟩ = B.π j :=\n  rfl\n#align to_cone_π_app_mk to_cone_π_app_mk\n\n",
 "to_cone_π_app_left":
 "@[simp]\ntheorem to_cone_π_app_left (c : binary_bicone P Q) : c.to_cone.π.app ⟨walking_pair.left⟩ = c.fst :=\n  rfl\n#align to_cone_π_app_left to_cone_π_app_left\n\n",
 "to_cone_π_app":
 "@[simp]\ntheorem to_cone_π_app (B : bicone F) (j : discrete J) : B.to_cone.π.app j = B.π j.as :=\n  rfl\n#align to_cone_π_app to_cone_π_app\n\n",
 "to_cone_X":
 "-- see Note [lower instance priority]\n@[simp]\ntheorem to_cone_X (c : binary_bicone P Q) : c.to_cone.X = c.X :=\n  rfl\n#align to_cone_X to_cone_X\n\n",
 "to_cocone_ι_app_right":
 "@[simp]\ntheorem to_cocone_ι_app_right (c : binary_bicone P Q) : c.to_cocone.ι.app ⟨walking_pair.right⟩ = c.inr :=\n  rfl\n#align to_cocone_ι_app_right to_cocone_ι_app_right\n\n",
 "to_cocone_ι_app_mk":
 "theorem to_cocone_ι_app_mk (B : bicone F) (j : J) : B.to_cocone.ι.app ⟨j⟩ = B.ι j :=\n  rfl\n#align to_cocone_ι_app_mk to_cocone_ι_app_mk\n\n",
 "to_cocone_ι_app_left":
 "@[simp]\ntheorem to_cocone_ι_app_left (c : binary_bicone P Q) : c.to_cocone.ι.app ⟨walking_pair.left⟩ = c.inl :=\n  rfl\n#align to_cocone_ι_app_left to_cocone_ι_app_left\n\n",
 "to_cocone_ι_app":
 "@[simp]\ntheorem to_cocone_ι_app (B : bicone F) (j : discrete J) : B.to_cocone.ι.app j = B.ι j.as :=\n  rfl\n#align to_cocone_ι_app to_cocone_ι_app\n\n",
 "to_cocone_X":
 "@[simp]\ntheorem to_cocone_X (c : binary_bicone P Q) : c.to_cocone.X = c.X :=\n  rfl\n#align to_cocone_X to_cocone_X\n\n",
 "symmetry'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊞ » -/\n@[simp, reassoc.1]\ntheorem biprod.symmetry' (P Q : C) :\n    «expr ≫ » (biprod.lift biprod.snd biprod.fst) (biprod.lift biprod.snd biprod.fst) = («expr𝟙») («expr ⊞ » P Q) := by\n  tidy\n#align biprod.symmetry' biprod.symmetry'\n\n",
 "symmetry":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/-- The braiding isomorphism is symmetric. -/\n@[reassoc.1]\ntheorem biprod.symmetry (P Q : C) : «expr ≫ » (biprod.braiding P Q).hom (biprod.braiding Q P).hom = («expr𝟙») _ := by\n  simp\n#align biprod.symmetry biprod.symmetry\n\n",
 "snd_kernel_fork_ι":
 "@[simp]\ntheorem biprod.snd_kernel_fork_ι : fork.ι (biprod.snd_kernel_fork X Y) = biprod.inl :=\n  rfl\n#align biprod.snd_kernel_fork_ι biprod.snd_kernel_fork_ι\n\n",
 "mk":
 "theorem has_binary_biproduct.mk {P Q : C} (d : binary_biproduct_data P Q) : has_binary_biproduct P Q :=\n  ⟨nonempty.intro d⟩\n#align has_binary_biproduct.mk has_binary_biproduct.mk\n\n",
 "matrix_π":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n-- Per #15067, we only allow indexing in `Type 0` here.\n@[simp, reassoc.1]\ntheorem biproduct.matrix_π (m : ∀ j k, «expr ⟶ » (f j) (g k)) (k : K) :\n    «expr ≫ » (biproduct.matrix m) (biproduct.π g k) = biproduct.desc fun j => m j k :=\n  by\n  ext\n  simp [biproduct.matrix]\n#align biproduct.matrix_π biproduct.matrix_π\n\n",
 "matrix_components":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n@[simp]\ntheorem biproduct.matrix_components (m : ∀ j k, «expr ⟶ » (f j) (g k)) (j : J) (k : K) :\n    biproduct.components (biproduct.matrix m) j k = m j k := by simp [biproduct.components]\n#align biproduct.matrix_components biproduct.matrix_components\n\n",
 "map_π":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem biproduct.map_π {f g : J → C} [has_biproduct f] [has_biproduct g] (p : ∀ j, «expr ⟶ » (f j) (g j)) (j : J) :\n    «expr ≫ » (biproduct.map p) (biproduct.π g j) = «expr ≫ » (biproduct.π f j) (p j) :=\n  limits.is_limit.map_π _ _ _ (discrete.mk j)\n#align biproduct.map_π biproduct.map_π\n\n",
 "map_snd":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem biprod.map_snd {W X Y Z : C} [has_binary_biproduct W X] [has_binary_biproduct Y Z] (f : «expr ⟶ » W Y)\n    (g : «expr ⟶ » X Z) : «expr ≫ » (biprod.map f g) biprod.snd = «expr ≫ » biprod.snd g :=\n  is_limit.map_π _ _ _ (⟨walking_pair.right⟩ : discrete walking_pair)\n#align biprod.map_snd biprod.map_snd\n\n",
 "map_fst":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem biprod.map_fst {W X Y Z : C} [has_binary_biproduct W X] [has_binary_biproduct Y Z] (f : «expr ⟶ » W Y)\n    (g : «expr ⟶ » X Z) : «expr ≫ » (biprod.map f g) biprod.fst = «expr ≫ » biprod.fst f :=\n  is_limit.map_π _ _ _ (⟨walking_pair.left⟩ : discrete walking_pair)\n#align biprod.map_fst biprod.map_fst\n\n",
 "map_eq_map'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem biprod.map_eq_map' {W X Y Z : C} [has_binary_biproduct W X] [has_binary_biproduct Y Z] (f : «expr ⟶ » W Y)\n    (g : «expr ⟶ » X Z) : biprod.map f g = biprod.map' f g :=\n  by\n  ext\n  · simp only [map_pair_left, is_colimit.ι_map, is_limit.map_π, biprod.inl_fst_assoc, category.assoc, ←\n      binary_bicone.to_cone_π_app_left, ← binary_biproduct.bicone_fst, ← binary_bicone.to_cocone_ι_app_left, ←\n      binary_biproduct.bicone_inl]\n    simp\n  · simp only [map_pair_left, is_colimit.ι_map, is_limit.map_π, zero_comp, biprod.inl_snd_assoc, category.assoc, ←\n      binary_bicone.to_cone_π_app_right, ← binary_biproduct.bicone_snd, ← binary_bicone.to_cocone_ι_app_left, ←\n      binary_biproduct.bicone_inl]\n    simp\n  · simp only [map_pair_right, biprod.inr_fst_assoc, is_colimit.ι_map, is_limit.map_π, zero_comp, category.assoc, ←\n      binary_bicone.to_cone_π_app_left, ← binary_biproduct.bicone_fst, ← binary_bicone.to_cocone_ι_app_right, ←\n      binary_biproduct.bicone_inr]\n    simp\n  · simp only [map_pair_right, is_colimit.ι_map, is_limit.map_π, biprod.inr_snd_assoc, category.assoc, ←\n      binary_bicone.to_cone_π_app_right, ← binary_biproduct.bicone_snd, ← binary_bicone.to_cocone_ι_app_right, ←\n      binary_biproduct.bicone_inr]\n    simp\n#align biprod.map_eq_map' biprod.map_eq_map'\n\n",
 "map_desc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem biproduct.map_desc {f g : J → C} [has_biproduct f] [has_biproduct g] (p : ∀ j, «expr ⟶ » (f j) (g j)) {P : C}\n    (k : ∀ j, «expr ⟶ » (g j) P) :\n    «expr ≫ » (biproduct.map p) (biproduct.desc k) = biproduct.desc fun j => «expr ≫ » (p j) (k j) :=\n  by\n  ext\n  simp\n#align biproduct.map_desc biproduct.map_desc\n\n",
 "lift_π":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem biproduct.lift_π {f : J → C} [has_biproduct f] {P : C} (p : ∀ b, «expr ⟶ » P (f b)) (j : J) :\n    «expr ≫ » (biproduct.lift p) (biproduct.π f j) = p j :=\n  (biproduct.is_limit f).fac _ ⟨j⟩\n#align biproduct.lift_π biproduct.lift_π\n\n",
 "lift_snd":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem biprod.lift_snd {W X Y : C} [has_binary_biproduct X Y] (f : «expr ⟶ » W X) (g : «expr ⟶ » W Y) :\n    «expr ≫ » (biprod.lift f g) biprod.snd = g :=\n  (binary_biproduct.is_limit X Y).fac _ ⟨walking_pair.right⟩\n#align biprod.lift_snd biprod.lift_snd\n\n",
 "lift_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem biproduct.lift_map {f g : J → C} [has_biproduct f] [has_biproduct g] {P : C} (k : ∀ j, «expr ⟶ » P (f j))\n    (p : ∀ j, «expr ⟶ » (f j) (g j)) :\n    «expr ≫ » (biproduct.lift k) (biproduct.map p) = biproduct.lift fun j => «expr ≫ » (k j) (p j) :=\n  by\n  ext\n  simp\n#align biproduct.lift_map biproduct.lift_map\n\n",
 "lift_fst":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem biprod.lift_fst {W X Y : C} [has_binary_biproduct X Y] (f : «expr ⟶ » W X) (g : «expr ⟶ » W Y) :\n    «expr ≫ » (biprod.lift f g) biprod.fst = f :=\n  (binary_biproduct.is_limit X Y).fac _ ⟨walking_pair.left⟩\n#align biprod.lift_fst biprod.lift_fst\n\n",
 "iso_product_inv":
 "@[simp]\ntheorem biproduct.iso_product_inv {f : J → C} [has_biproduct f] :\n    (biproduct.iso_product f).inv = biproduct.lift (pi.π f) :=\n  biproduct.hom_ext _ _ fun j => by simp [iso.inv_comp_eq]\n#align biproduct.iso_product_inv biproduct.iso_product_inv\n\n",
 "iso_product_hom":
 "@[simp]\ntheorem biproduct.iso_product_hom {f : J → C} [has_biproduct f] :\n    (biproduct.iso_product f).hom = pi.lift (biproduct.π f) :=\n  limit.hom_ext fun j => by simp [biproduct.iso_product]\n#align biproduct.iso_product_hom biproduct.iso_product_hom\n\n",
 "iso_prod_inv":
 "@[simp]\ntheorem biprod.iso_prod_inv {X Y : C} [has_binary_biproduct X Y] :\n    (biprod.iso_prod X Y).inv = biprod.lift prod.fst prod.snd := by apply biprod.hom_ext <;> simp [iso.inv_comp_eq]\n#align biprod.iso_prod_inv biprod.iso_prod_inv\n\n",
 "iso_prod_hom":
 "@[simp]\ntheorem biprod.iso_prod_hom {X Y : C} [has_binary_biproduct X Y] :\n    (biprod.iso_prod X Y).hom = prod.lift biprod.fst biprod.snd := by ext <;> simp [biprod.iso_prod]\n#align biprod.iso_prod_hom biprod.iso_prod_hom\n\n",
 "iso_coproduct_inv":
 "@[simp]\ntheorem biproduct.iso_coproduct_inv {f : J → C} [has_biproduct f] :\n    (biproduct.iso_coproduct f).inv = sigma.desc (biproduct.ι f) :=\n  colimit.hom_ext fun j => by simp [biproduct.iso_coproduct]\n#align biproduct.iso_coproduct_inv biproduct.iso_coproduct_inv\n\n",
 "iso_coproduct_hom":
 "@[simp]\ntheorem biproduct.iso_coproduct_hom {f : J → C} [has_biproduct f] :\n    (biproduct.iso_coproduct f).hom = biproduct.desc (sigma.ι f) :=\n  biproduct.hom_ext' _ _ fun j => by simp [← iso.eq_comp_inv]\n#align biproduct.iso_coproduct_hom biproduct.iso_coproduct_hom\n\n",
 "iso_coprod_inv":
 "@[simp]\ntheorem biprod.iso_coprod_inv {X Y : C} [has_binary_biproduct X Y] :\n    (biprod.iso_coprod X Y).inv = coprod.desc biprod.inl biprod.inr := by ext <;> simp [biprod.iso_coprod] <;> rfl\n#align biprod.iso_coprod_inv biprod.iso_coprod_inv\n\n",
 "is_iso_right_of_is_iso_biprod_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/-- If\n```\n(f 0)\n(0 g)\n```\nis invertible, then `g` is invertible.\n-/\ntheorem is_iso_right_of_is_iso_biprod_map {W X Y Z : C} (f : «expr ⟶ » W Y) (g : «expr ⟶ » X Z)\n    [IsIso (biprod.map f g)] : IsIso g :=\n  letI : is_iso (biprod.map g f) := by\n    rw [← biprod.braiding_map_braiding]\n    infer_instance\n  is_iso_left_of_is_iso_biprod_map g f\n#align is_iso_right_of_is_iso_biprod_map is_iso_right_of_is_iso_biprod_map\n\n",
 "is_iso_left_of_is_iso_biprod_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊞ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊞ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊞ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊞ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n-- TODO:\n-- If someone is interested, they could provide the constructions:\n--   has_binary_biproducts ↔ has_finite_biproducts\n/-- If\n```\n(f 0)\n(0 g)\n```\nis invertible, then `f` is invertible.\n-/\ntheorem is_iso_left_of_is_iso_biprod_map {W X Y Z : C} (f : «expr ⟶ » W Y) (g : «expr ⟶ » X Z)\n    [IsIso (biprod.map f g)] : IsIso f :=\n  ⟨⟨«expr ≫ » biprod.inl («expr ≫ » (inv (biprod.map f g)) biprod.fst),\n      ⟨by\n        have t :=\n          congr_arg (fun p : «expr ⟶ » («expr ⊞ » W X) («expr ⊞ » W X) => «expr ≫ » biprod.inl («expr ≫ » p biprod.fst))\n            (is_iso.hom_inv_id (biprod.map f g))\n        simp only [category.id_comp, category.assoc, biprod.inl_map_assoc] at t\n        simp [t],\n        by\n        have t :=\n          congr_arg (fun p : «expr ⟶ » («expr ⊞ » Y Z) («expr ⊞ » Y Z) => «expr ≫ » biprod.inl («expr ≫ » p biprod.fst))\n            (is_iso.inv_hom_id (biprod.map f g))\n        simp only [category.id_comp, category.assoc, biprod.map_fst] at t\n        simp only [category.assoc]\n        simp [t]⟩⟩⟩\n#align is_iso_left_of_is_iso_biprod_map is_iso_left_of_is_iso_biprod_map\n\n",
 "is_iso_inl_iff_id_eq_fst_comp_inl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊞ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊞ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊞ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n-- There are three further variations,\n-- about `is_iso biprod.inr`, `is_iso biprod.fst` and `is_iso biprod.snd`,\n-- but any one suffices to prove `indecomposable_of_simple`\n-- and they are likely not separately useful.\ntheorem biprod.is_iso_inl_iff_id_eq_fst_comp_inl (X Y : C) [has_binary_biproduct X Y] :\n    IsIso (biprod.inl : «expr ⟶ » X («expr ⊞ » X Y)) ↔ («expr𝟙») («expr ⊞ » X Y) = «expr ≫ » biprod.fst biprod.inl :=\n  by\n  constructor\n  · intro h\n    have := (cancel_epi (inv biprod.inl : «expr ⟶ » («expr ⊞ » X Y) X)).2 biprod.inl_fst\n    rw [is_iso.inv_hom_id_assoc, category.comp_id] at this\n    rw [this, is_iso.inv_hom_id]\n  · intro h\n    exact ⟨⟨biprod.fst, biprod.inl_fst, h.symm⟩⟩\n#align biprod.is_iso_inl_iff_id_eq_fst_comp_inl biprod.is_iso_inl_iff_id_eq_fst_comp_inl\n\n",
 "inr_snd":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊞ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊞ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n@[simp, reassoc.1]\ntheorem biprod.inr_snd {X Y : C} [has_binary_biproduct X Y] :\n    «expr ≫ » (biprod.inr : «expr ⟶ » Y («expr ⊞ » X Y)) (biprod.snd : «expr ⟶ » («expr ⊞ » X Y) Y) = («expr𝟙») Y :=\n  (binary_biproduct.bicone X Y).inr_snd\n#align biprod.inr_snd biprod.inr_snd\n\n",
 "inr_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem biprod.inr_map {W X Y Z : C} [has_binary_biproduct W X] [has_binary_biproduct Y Z] (f : «expr ⟶ » W Y)\n    (g : «expr ⟶ » X Z) : «expr ≫ » biprod.inr (biprod.map f g) = «expr ≫ » g biprod.inr :=\n  by\n  rw [biprod.map_eq_map']\n  exact is_colimit.ι_map (binary_biproduct.is_colimit W X) _ _ ⟨walking_pair.right⟩\n#align biprod.inr_map biprod.inr_map\n\n",
 "inr_fst":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊞ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊞ » -/\n@[simp, reassoc.1]\ntheorem biprod.inr_fst {X Y : C} [has_binary_biproduct X Y] :\n    «expr ≫ » (biprod.inr : «expr ⟶ » Y («expr ⊞ » X Y)) (biprod.fst : «expr ⟶ » («expr ⊞ » X Y) X) = 0 :=\n  (binary_biproduct.bicone X Y).inr_fst\n#align biprod.inr_fst biprod.inr_fst\n\n",
 "inr_desc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem biprod.inr_desc {W X Y : C} [has_binary_biproduct X Y] (f : «expr ⟶ » X W) (g : «expr ⟶ » Y W) :\n    «expr ≫ » biprod.inr (biprod.desc f g) = g :=\n  (binary_biproduct.is_colimit X Y).fac _ ⟨walking_pair.right⟩\n#align biprod.inr_desc biprod.inr_desc\n\n",
 "inr_cokernel_cofork_π":
 "@[simp]\ntheorem biprod.inr_cokernel_cofork_π : cofork.π (biprod.inr_cokernel_cofork X Y) = biprod.fst :=\n  rfl\n#align biprod.inr_cokernel_cofork_π biprod.inr_cokernel_cofork_π\n\n",
 "inl_snd":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊞ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊞ » -/\n@[simp, reassoc.1]\ntheorem biprod.inl_snd {X Y : C} [has_binary_biproduct X Y] :\n    «expr ≫ » (biprod.inl : «expr ⟶ » X («expr ⊞ » X Y)) (biprod.snd : «expr ⟶ » («expr ⊞ » X Y) Y) = 0 :=\n  (binary_biproduct.bicone X Y).inl_snd\n#align biprod.inl_snd biprod.inl_snd\n\n",
 "inl_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n-- Because `biprod.map` is defined in terms of `lim` rather than `colim`,\n-- we need to provide additional `simp` lemmas.\n@[simp, reassoc.1]\ntheorem biprod.inl_map {W X Y Z : C} [has_binary_biproduct W X] [has_binary_biproduct Y Z] (f : «expr ⟶ » W Y)\n    (g : «expr ⟶ » X Z) : «expr ≫ » biprod.inl (biprod.map f g) = «expr ≫ » f biprod.inl :=\n  by\n  rw [biprod.map_eq_map']\n  exact is_colimit.ι_map (binary_biproduct.is_colimit W X) _ _ ⟨walking_pair.left⟩\n#align biprod.inl_map biprod.inl_map\n\n",
 "inl_fst":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊞ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊞ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n@[simp, reassoc.1]\ntheorem biprod.inl_fst {X Y : C} [has_binary_biproduct X Y] :\n    «expr ≫ » (biprod.inl : «expr ⟶ » X («expr ⊞ » X Y)) (biprod.fst : «expr ⟶ » («expr ⊞ » X Y) X) = («expr𝟙») X :=\n  (binary_biproduct.bicone X Y).inl_fst\n#align biprod.inl_fst biprod.inl_fst\n\n",
 "inl_desc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem biprod.inl_desc {W X Y : C} [has_binary_biproduct X Y] (f : «expr ⟶ » X W) (g : «expr ⟶ » Y W) :\n    «expr ≫ » biprod.inl (biprod.desc f g) = f :=\n  (binary_biproduct.is_colimit X Y).fac _ ⟨walking_pair.left⟩\n#align biprod.inl_desc biprod.inl_desc\n\n",
 "inl_cokernel_cofork_π":
 "@[simp]\ntheorem biprod.inl_cokernel_cofork_π : cofork.π (biprod.inl_cokernel_cofork X Y) = biprod.snd :=\n  rfl\n#align biprod.inl_cokernel_cofork_π biprod.inl_cokernel_cofork_π\n\n",
 "hom_ext'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊞ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[ext]\ntheorem biprod.hom_ext' {X Y Z : C} [has_binary_biproduct X Y] (f g : «expr ⟶ » («expr ⊞ » X Y) Z)\n    (h₀ : «expr ≫ » biprod.inl f = «expr ≫ » biprod.inl g) (h₁ : «expr ≫ » biprod.inr f = «expr ≫ » biprod.inr g) :\n    f = g :=\n  binary_cofan.is_colimit.hom_ext (binary_biproduct.is_colimit X Y) h₀ h₁\n#align biprod.hom_ext' biprod.hom_ext'\n\n",
 "hom_ext":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊞ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[ext]\ntheorem biprod.hom_ext {X Y Z : C} [has_binary_biproduct X Y] (f g : «expr ⟶ » Z («expr ⊞ » X Y))\n    (h₀ : «expr ≫ » f biprod.fst = «expr ≫ » g biprod.fst) (h₁ : «expr ≫ » f biprod.snd = «expr ≫ » g biprod.snd) :\n    f = g :=\n  binary_fan.is_limit.hom_ext (binary_biproduct.is_limit X Y) h₀ h₁\n#align biprod.hom_ext biprod.hom_ext\n\n",
 "has_biproducts_of_shape_of_equiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\ntheorem has_biproducts_of_shape_of_equiv {K : Type w'} [has_biproducts_of_shape K C] (e : «expr ≃ » J K) :\n    has_biproducts_of_shape J C :=\n  ⟨fun F =>\n    let ⟨⟨h⟩⟩ := has_biproducts_of_shape.has_biproduct (F ∘ e.symm)\n    let ⟨c, hc⟩ := h\n    has_biproduct.mk <| by\n      simpa only [(· ∘ ·), e.symm_apply_apply] using limit_bicone.mk (c.whisker e) ((c.whisker_is_bilimit_iff _).2 hc)⟩\n#align has_biproducts_of_shape_of_equiv has_biproducts_of_shape_of_equiv\n\n",
 "has_binary_biproducts_of_finite_biproducts":
 "/-- A category with finite biproducts has binary biproducts.\n\nThis is not an instance as typically in concrete categories there will be\nan alternative construction with nicer definitional properties.\n-/\ntheorem has_binary_biproducts_of_finite_biproducts [has_finite_biproducts C] : has_binary_biproducts C :=\n  {\n    has_binary_biproduct := fun P Q =>\n      has_binary_biproduct.mk\n        { bicone := (biproduct.bicone (pair_function P Q)).to_binary_bicone\n          is_bilimit := (bicone.to_binary_bicone_is_bilimit _).symm (biproduct.is_bilimit _) } }\n#align has_binary_biproducts_of_finite_biproducts has_binary_biproducts_of_finite_biproducts\n\n",
 "fst_kernel_fork_ι":
 "@[simp]\ntheorem biprod.fst_kernel_fork_ι : fork.ι (biprod.fst_kernel_fork X Y) = biprod.inr :=\n  rfl\n#align biprod.fst_kernel_fork_ι biprod.fst_kernel_fork_ι\n\n",
 "from_subtype_π_subtype":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem biproduct.from_subtype_π_subtype (j : subtype p) :\n    «expr ≫ » (biproduct.from_subtype f p) (biproduct.π f j) = biproduct.π (subtype.restrict p f) j :=\n  by\n  ext i\n  rw [biproduct.from_subtype, biproduct.ι_desc_assoc, biproduct.ι_π, biproduct.ι_π]\n  split_ifs with h₁ h₂ h₂\n  exacts[rfl, false.elim (h₂ (subtype.ext h₁)), false.elim (h₁ (congr_arg subtype.val h₂)), rfl]\n#align biproduct.from_subtype_π_subtype biproduct.from_subtype_π_subtype\n\n",
 "from_subtype_π":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem biproduct.from_subtype_π [decidable_pred p] (j : J) :\n    «expr ≫ » (biproduct.from_subtype f p) (biproduct.π f j) =\n      if h : p j then biproduct.π (subtype.restrict p f) ⟨j, h⟩ else 0 :=\n  by\n  ext i\n  rw [biproduct.from_subtype, biproduct.ι_desc_assoc, biproduct.ι_π]\n  by_cases h : p j\n  · rw [dif_pos h, biproduct.ι_π]\n    split_ifs with h₁ h₂ h₂\n    exacts[rfl, false.elim (h₂ (subtype.ext h₁)), false.elim (h₁ (congr_arg subtype.val h₂)), rfl]\n  · rw [dif_neg h, dif_neg (show (i : J) ≠ j from fun h₂ => h (h₂ ▸ i.2)), comp_zero]\n#align biproduct.from_subtype_π biproduct.from_subtype_π\n\n",
 "from_subtype_to_subtype":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨁ » -/\n@[simp, reassoc.1]\ntheorem biproduct.from_subtype_to_subtype :\n    «expr ≫ » (biproduct.from_subtype f p) (biproduct.to_subtype f p) = («expr𝟙») («expr⨁ » (subtype.restrict p f)) :=\n  by\n  refine' biproduct.hom_ext _ _ fun j => _\n  rw [category.assoc, biproduct.to_subtype_π, biproduct.from_subtype_π_subtype, category.id_comp]\n#align biproduct.from_subtype_to_subtype biproduct.from_subtype_to_subtype\n\n",
 "from_subtype_eq_lift":
 "theorem biproduct.from_subtype_eq_lift [decidable_pred p] :\n    biproduct.from_subtype f p =\n      biproduct.lift fun j => if h : p j then biproduct.π (subtype.restrict p f) ⟨j, h⟩ else 0 :=\n  biproduct.hom_ext _ _ (by simp)\n#align biproduct.from_subtype_eq_lift biproduct.from_subtype_eq_lift\n\n",
 "cone_point_unique_up_to_iso_inv":
 "/-- Auxiliary lemma for `biprod.unique_up_to_iso`. -/\ntheorem biprod.cone_point_unique_up_to_iso_inv (X Y : C) [has_binary_biproduct X Y] {b : binary_bicone X Y}\n    (hb : b.is_bilimit) :\n    (hb.is_limit.cone_point_unique_up_to_iso (binary_biproduct.is_limit _ _)).inv = biprod.desc b.inl b.inr :=\n  by\n  refine' biprod.hom_ext' _ _ (hb.is_limit.hom_ext fun j => _) (hb.is_limit.hom_ext fun j => _)\n  all_goals\n    simp only [category.assoc, is_limit.cone_point_unique_up_to_iso_inv_comp]\n    rcases j with ⟨⟨⟩⟩\n  all_goals simp\n#align biprod.cone_point_unique_up_to_iso_inv biprod.cone_point_unique_up_to_iso_inv\n\n",
 "cone_point_unique_up_to_iso_hom":
 "/-- Auxiliary lemma for `biprod.unique_up_to_iso`. -/\ntheorem biprod.cone_point_unique_up_to_iso_hom (X Y : C) [has_binary_biproduct X Y] {b : binary_bicone X Y}\n    (hb : b.is_bilimit) :\n    (hb.is_limit.cone_point_unique_up_to_iso (binary_biproduct.is_limit _ _)).hom = biprod.lift b.fst b.snd :=\n  rfl\n#align biprod.cone_point_unique_up_to_iso_hom biprod.cone_point_unique_up_to_iso_hom\n\n",
 "components_matrix":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨁ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨁ » -/\n@[simp]\ntheorem biproduct.components_matrix (m : «expr ⟶ » («expr⨁ » f) («expr⨁ » g)) :\n    (biproduct.matrix fun j k => biproduct.components m j k) = m :=\n  by\n  ext\n  simp [biproduct.components]\n#align biproduct.components_matrix biproduct.components_matrix\n\n",
 "braiding_map_braiding":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[reassoc.1]\ntheorem biprod.braiding_map_braiding {W X Y Z : C} (f : «expr ⟶ » W Y) (g : «expr ⟶ » X Z) :\n    «expr ≫ » (biprod.braiding X W).hom («expr ≫ » (biprod.map f g) (biprod.braiding Y Z).hom) = biprod.map g f := by\n  tidy\n#align biprod.braiding_map_braiding biprod.braiding_map_braiding\n\n",
 "braiding'_eq_braiding":
 "theorem biprod.braiding'_eq_braiding {P Q : C} : biprod.braiding' P Q = biprod.braiding P Q := by tidy\n#align biprod.braiding'_eq_braiding biprod.braiding'_eq_braiding\n\n",
 "braid_natural":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/-- The braiding isomorphism can be passed through a map by swapping the order. -/\n@[reassoc.1]\ntheorem biprod.braid_natural {W X Y Z : C} (f : «expr ⟶ » X Y) (g : «expr ⟶ » Z W) :\n    «expr ≫ » (biprod.map f g) (biprod.braiding _ _).hom = «expr ≫ » (biprod.braiding _ _).hom (biprod.map g f) := by\n  tidy\n#align biprod.braid_natural biprod.braid_natural\n\n",
 "biprod_iso_coprod_hom":
 "@[simp]\ntheorem biprod_iso_coprod_hom {X Y : C} [has_binary_biproduct X Y] :\n    (biprod.iso_coprod X Y).hom = biprod.desc coprod.inl coprod.inr := by\n  apply biprod.hom_ext' <;> simp [← iso.eq_comp_inv]\n#align biprod_iso_coprod_hom biprod_iso_coprod_hom\n\n",
 "binary_fan_snd_to_cone":
 "@[simp]\ntheorem binary_fan_snd_to_cone (c : binary_bicone P Q) : binary_fan.snd c.to_cone = c.snd :=\n  rfl\n#align binary_fan_snd_to_cone binary_fan_snd_to_cone\n\n",
 "binary_fan_fst_to_cone":
 "@[simp]\ntheorem binary_fan_fst_to_cone (c : binary_bicone P Q) : binary_fan.fst c.to_cone = c.fst :=\n  rfl\n#align binary_fan_fst_to_cone binary_fan_fst_to_cone\n\n",
 "binary_cofan_inr_to_cocone":
 "@[simp]\ntheorem binary_cofan_inr_to_cocone (c : binary_bicone P Q) : binary_cofan.inr c.to_cocone = c.inr :=\n  rfl\n#align binary_cofan_inr_to_cocone binary_cofan_inr_to_cocone\n\n",
 "binary_cofan_inl_to_cocone":
 "@[simp]\ntheorem binary_cofan_inl_to_cocone (c : binary_bicone P Q) : binary_cofan.inl c.to_cocone = c.inl :=\n  rfl\n#align binary_cofan_inl_to_cocone binary_cofan_inl_to_cocone\n\n",
 "bicone_π":
 "@[simp]\ntheorem biproduct.bicone_π (f : J → C) [has_biproduct f] (b : J) : (biproduct.bicone f).π b = biproduct.π f b :=\n  rfl\n#align biproduct.bicone_π biproduct.bicone_π\n\n",
 "bicone_ι_π_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/-\nCopyright (c) 2019 Scott Morrison. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Scott Morrison, Jakob von Raumer\n-/\n@[simp, reassoc.1]\ntheorem bicone_ι_π_self {F : J → C} (B : bicone F) (j : J) : «expr ≫ » (B.ι j) (B.π j) = («expr𝟙») (F j) := by\n  simpa using B.ι_π j j\n#align bicone_ι_π_self bicone_ι_π_self\n\n",
 "bicone_ι_π_ne":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem bicone_ι_π_ne {F : J → C} (B : bicone F) {j j' : J} (h : j ≠ j') : «expr ≫ » (B.ι j) (B.π j') = 0 := by\n  simpa [h] using B.ι_π j j'\n#align bicone_ι_π_ne bicone_ι_π_ne\n\n",
 "bicone_ι":
 "@[simp]\ntheorem biproduct.bicone_ι (f : J → C) [has_biproduct f] (b : J) : (biproduct.bicone f).ι b = biproduct.ι f b :=\n  rfl\n#align biproduct.bicone_ι biproduct.bicone_ι\n\n",
 "bicone_snd":
 "@[simp]\ntheorem binary_biproduct.bicone_snd : (binary_biproduct.bicone X Y).snd = biprod.snd :=\n  rfl\n#align binary_biproduct.bicone_snd binary_biproduct.bicone_snd\n\n",
 "bicone_inr":
 "@[simp]\ntheorem binary_biproduct.bicone_inr : (binary_biproduct.bicone X Y).inr = biprod.inr :=\n  rfl\n#align binary_biproduct.bicone_inr binary_biproduct.bicone_inr\n\n",
 "bicone_inl":
 "@[simp]\ntheorem binary_biproduct.bicone_inl : (binary_biproduct.bicone X Y).inl = biprod.inl :=\n  rfl\n#align binary_biproduct.bicone_inl binary_biproduct.bicone_inl\n\n",
 "bicone_fst":
 "@[simp]\ntheorem binary_biproduct.bicone_fst : (binary_biproduct.bicone X Y).fst = biprod.fst :=\n  rfl\n#align binary_biproduct.bicone_fst binary_biproduct.bicone_fst\n\n"}