{"pushout_of_epi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⨿ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⨿ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Command.lean:322:38: unsupported irreducible non-definition -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/-- The pushout of two epimorphisms exists. -/\nirreducible_def pushout_of_epi {X Y Z : C} (a : «expr ⟶ » X Y) (b : «expr ⟶ » X Z) [Epi a] [Epi b] :\n  HasColimit (span a b) :=\n  let ⟨P, f, hfa, i⟩ := normalEpiOfEpi a\n  let ⟨Q, g, hgb, i'⟩ := normalEpiOfEpi b\n  let ⟨a', ha'⟩ :=\n    CokernelCofork.IsColimit.desc' i (cokernel.π (coprod.desc f g)) <|\n      calc\n        «expr ≫ » f (cokernel.π (coprod.desc f g)) =\n            «expr ≫ » coprod.inl («expr ≫ » (coprod.desc f g) (cokernel.π (coprod.desc f g))) :=\n          by rw [coprod.inl_desc_assoc]\n        _ = «expr ≫ » coprod.inl (0 : «expr ⟶ » («expr ⨿ » P Q) (cokernel (coprod.desc f g))) := by\n          rw [cokernel.condition]\n        _ = 0 := has_zero_morphisms.comp_zero _ _\n        \n  let ⟨b', hb'⟩ :=\n    CokernelCofork.IsColimit.desc' i' (cokernel.π (coprod.desc f g)) <|\n      calc\n        «expr ≫ » g (cokernel.π (coprod.desc f g)) =\n            «expr ≫ » coprod.inr («expr ≫ » (coprod.desc f g) (cokernel.π (coprod.desc f g))) :=\n          by rw [coprod.inr_desc_assoc]\n        _ = «expr ≫ » coprod.inr (0 : «expr ⟶ » («expr ⨿ » P Q) (cokernel (coprod.desc f g))) := by\n          rw [cokernel.condition]\n        _ = 0 := has_zero_morphisms.comp_zero _ _\n        \n  HasColimit.mk\n    { cocone :=\n        PushoutCocone.mk a' b' <| by\n          simp only [cofork.π_of_π] at ha' hb'\n          rw [ha', hb']\n      is_colimit :=\n        PushoutCocone.IsColimit.mk _\n          (fun s =>\n            cokernel.desc (coprod.desc f g) («expr ≫ » b (PushoutCocone.inr s)) <|\n              coprod.hom_ext\n                (calc\n                  «expr ≫ » coprod.inl («expr ≫ » (coprod.desc f g) («expr ≫ » b (PushoutCocone.inr s))) =\n                      «expr ≫ » f («expr ≫ » b (PushoutCocone.inr s)) :=\n                    by rw [coprod.inl_desc_assoc]\n                  _ = «expr ≫ » f («expr ≫ » a (PushoutCocone.inl s)) := by rw [pushout_cocone.condition]\n                  _ = «expr ≫ » 0 (PushoutCocone.inl s) := by rw [reassoc_of hfa]\n                  _ = «expr ≫ » coprod.inl 0 := by rw [comp_zero, zero_comp]\n                  )\n                (calc\n                  «expr ≫ » coprod.inr («expr ≫ » (coprod.desc f g) («expr ≫ » b (PushoutCocone.inr s))) =\n                      «expr ≫ » g («expr ≫ » b (PushoutCocone.inr s)) :=\n                    by rw [coprod.inr_desc_assoc]\n                  _ = «expr ≫ » 0 (PushoutCocone.inr s) := by rw [reassoc_of hgb]\n                  _ = «expr ≫ » coprod.inr 0 := by rw [comp_zero, zero_comp]\n                  ))\n          (fun s =>\n            (cancel_epi a).1 <| by\n              rw [cokernel_cofork.π_of_π] at ha'\n              simp [reassoc_of ha', pushout_cocone.condition s])\n          (fun s =>\n            (cancel_epi b).1 <| by\n              rw [cokernel_cofork.π_of_π] at hb'\n              simp [reassoc_of hb'])\n          fun s m h₁ h₂ =>\n          (cancel_epi (cokernel.π (coprod.desc f g))).1 <|\n            calc\n              «expr ≫ » (cokernel.π (coprod.desc f g)) m = «expr ≫ » («expr ≫ » a a') m :=\n                by\n                congr\n                exact ha'.symm\n              _ = «expr ≫ » a (PushoutCocone.inl s) := by rw [category.assoc, h₁]\n              _ = «expr ≫ » b (PushoutCocone.inr s) := (PushoutCocone.condition s)\n              _ =\n                  «expr ≫ » (cokernel.π (coprod.desc f g))\n                    (cokernel.desc (coprod.desc f g) («expr ≫ » b (PushoutCocone.inr s)) _) :=\n                by rw [cokernel.π_desc]\n               }\n#align pushout_of_epi pushout_of_epi\n\n",
 "pullback_of_mono":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⨯ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⨯ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Command.lean:322:38: unsupported irreducible non-definition -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/-\nCopyright (c) 2020 Markus Himmel. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Markus Himmel\n-/\n/-- The pullback of two monomorphisms exists. -/\nirreducible_def pullback_of_mono {X Y Z : C} (a : «expr ⟶ » X Z) (b : «expr ⟶ » Y Z) [Mono a] [Mono b] :\n  HasLimit (cospan a b) :=\n  let ⟨P, f, haf, i⟩ := normalMonoOfMono a\n  let ⟨Q, g, hbg, i'⟩ := normalMonoOfMono b\n  let ⟨a', ha'⟩ :=\n    KernelFork.IsLimit.lift' i (kernel.ι (prod.lift f g)) <|\n      calc\n        «expr ≫ » (kernel.ι (prod.lift f g)) f =\n            «expr ≫ » (kernel.ι (prod.lift f g)) («expr ≫ » (prod.lift f g) Limits.prod.fst) :=\n          by rw [prod.lift_fst]\n        _ = «expr ≫ » (0 : «expr ⟶ » (kernel (prod.lift f g)) («expr ⨯ » P Q)) Limits.prod.fst := by\n          rw [kernel.condition_assoc]\n        _ = 0 := zero_comp\n        \n  let ⟨b', hb'⟩ :=\n    KernelFork.IsLimit.lift' i' (kernel.ι (prod.lift f g)) <|\n      calc\n        «expr ≫ » (kernel.ι (prod.lift f g)) g =\n            «expr ≫ » (kernel.ι (prod.lift f g)) («expr ≫ » (prod.lift f g) Limits.prod.snd) :=\n          by rw [prod.lift_snd]\n        _ = «expr ≫ » (0 : «expr ⟶ » (kernel (prod.lift f g)) («expr ⨯ » P Q)) Limits.prod.snd := by\n          rw [kernel.condition_assoc]\n        _ = 0 := zero_comp\n        \n  HasLimit.mk\n    { cone :=\n        PullbackCone.mk a' b' <| by\n          simp at ha' hb'\n          rw [ha', hb']\n      is_limit :=\n        PullbackCone.IsLimit.mk _\n          (fun s =>\n            kernel.lift (prod.lift f g) («expr ≫ » (PullbackCone.snd s) b) <|\n              prod.hom_ext\n                (calc\n                  «expr ≫ » («expr ≫ » («expr ≫ » (PullbackCone.snd s) b) (prod.lift f g)) Limits.prod.fst =\n                      «expr ≫ » (PullbackCone.snd s) («expr ≫ » b f) :=\n                    by simp only [prod.lift_fst, category.assoc]\n                  _ = «expr ≫ » (PullbackCone.fst s) («expr ≫ » a f) := by rw [pullback_cone.condition_assoc]\n                  _ = «expr ≫ » (PullbackCone.fst s) 0 := by rw [haf]\n                  _ = «expr ≫ » 0 Limits.prod.fst := by rw [comp_zero, zero_comp]\n                  )\n                (calc\n                  «expr ≫ » («expr ≫ » («expr ≫ » (PullbackCone.snd s) b) (prod.lift f g)) Limits.prod.snd =\n                      «expr ≫ » (PullbackCone.snd s) («expr ≫ » b g) :=\n                    by simp only [prod.lift_snd, category.assoc]\n                  _ = «expr ≫ » (PullbackCone.snd s) 0 := by rw [hbg]\n                  _ = «expr ≫ » 0 Limits.prod.snd := by rw [comp_zero, zero_comp]\n                  ))\n          (fun s =>\n            (cancel_mono a).1 <| by\n              rw [kernel_fork.ι_of_ι] at ha'\n              simp [ha', pullback_cone.condition s])\n          (fun s =>\n            (cancel_mono b).1 <| by\n              rw [kernel_fork.ι_of_ι] at hb'\n              simp [hb'])\n          fun s m h₁ h₂ =>\n          (cancel_mono (kernel.ι (prod.lift f g))).1 <|\n            calc\n              «expr ≫ » m (kernel.ι (prod.lift f g)) = «expr ≫ » m («expr ≫ » a' a) :=\n                by\n                congr\n                exact ha'.symm\n              _ = «expr ≫ » (PullbackCone.fst s) a := by rw [← category.assoc, h₁]\n              _ = «expr ≫ » (PullbackCone.snd s) b := (PullbackCone.condition s)\n              _ =\n                  «expr ≫ » (kernel.lift (prod.lift f g) («expr ≫ » (PullbackCone.snd s) b) _)\n                    (kernel.ι (prod.lift f g)) :=\n                by rw [kernel.lift_ι]\n               }\n#align pullback_of_mono pullback_of_mono\n\n",
 "mono_of_zero_kernel":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/-- If a zero morphism is a kernel of `f`, then `f` is a monomorphism. -/\ntheorem mono_of_zero_kernel {X Y : C} (f : «expr ⟶ » X Y) (Z : C)\n    (l : IsLimit (KernelFork.ofι (0 : «expr ⟶ » Z X) (show «expr ≫ » 0 f = 0 by simp))) : Mono f :=\n  ⟨fun P u v huv => by\n    obtain ⟨W, w, hw, hl⟩ := normal_epi_of_epi (coequalizer.π u v)\n    obtain ⟨m, hm⟩ := coequalizer.desc' f huv\n    have hwf : «expr ≫ » w f = 0 := by rw [← hm, reassoc_of hw, zero_comp]\n    obtain ⟨n, hn⟩ := kernel_fork.is_limit.lift' l _ hwf\n    rw [fork.ι_of_ι, has_zero_morphisms.comp_zero] at hn\n    have : is_iso (coequalizer.π u v) := by apply is_iso_colimit_cocone_parallel_pair_of_eq hn.symm hl\n    apply (cancel_mono (coequalizer.π u v)).1\n    exact coequalizer.condition _ _⟩\n#align mono_of_zero_kernel mono_of_zero_kernel\n\n",
 "mono_of_cancel_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/-- If `g ≫ f = 0` implies `g = 0` for all `g`, then `f` is a monomorphism. -/\ntheorem mono_of_cancel_zero {X Y : C} (f : «expr ⟶ » X Y)\n    (hf : ∀ (Z : C) (g : «expr ⟶ » Z X) (hgf : «expr ≫ » g f = 0), g = 0) : Mono f :=\n  mono_of_zero_kernel f 0 <| zeroKernelOfCancelZero f hf\n#align mono_of_cancel_zero mono_of_cancel_zero\n\n",
 "has_limit_parallel_pair":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Command.lean:322:38: unsupported irreducible non-definition -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/-- The equalizer of `f` and `g` exists. -/\nirreducible_def has_limit_parallel_pair {X Y : C} (f g : «expr ⟶ » X Y) : HasLimit (parallelPair f g) :=\n  have huv : (pullback.fst : «expr ⟶ » (P f g) X) = pullback.snd :=\n    calc\n      (pullback.fst : «expr ⟶ » (P f g) X) = «expr ≫ » pullback.fst ((«expr𝟙») _) := Eq.symm <| Category.comp_id _\n      _ = «expr ≫ » pullback.fst («expr ≫ » (prod.lift ((«expr𝟙») X) f) Limits.prod.fst) := by rw [prod.lift_fst]\n      _ = «expr ≫ » pullback.snd («expr ≫ » (prod.lift ((«expr𝟙») X) g) Limits.prod.fst) := by\n        rw [pullback.condition_assoc]\n      _ = pullback.snd := by rw [prod.lift_fst, category.comp_id]\n      \n  have hvu : «expr ≫ » (pullback.fst : «expr ⟶ » (P f g) X) f = «expr ≫ » pullback.snd g :=\n    calc\n      «expr ≫ » (pullback.fst : «expr ⟶ » (P f g) X) f =\n          «expr ≫ » pullback.fst («expr ≫ » (prod.lift ((«expr𝟙») X) f) Limits.prod.snd) :=\n        by rw [prod.lift_snd]\n      _ = «expr ≫ » pullback.snd («expr ≫ » (prod.lift ((«expr𝟙») X) g) Limits.prod.snd) := by\n        rw [pullback.condition_assoc]\n      _ = «expr ≫ » pullback.snd g := by rw [prod.lift_snd]\n      \n  have huu : «expr ≫ » (pullback.fst : «expr ⟶ » (P f g) X) f = «expr ≫ » pullback.fst g := by rw [hvu, ← huv]\n  HasLimit.mk\n    { cone := Fork.ofι pullback.fst huu\n      is_limit :=\n        Fork.IsLimit.mk _\n          (fun s =>\n            pullback.lift (Fork.ι s) (Fork.ι s) <|\n              prod.hom_ext (by simp only [prod.lift_fst, category.assoc])\n                (by simp only [prod.comp_lift, fork.condition]))\n          (fun s => by simp only [fork.ι_of_ι, pullback.lift_fst]) fun s m h =>\n          pullback.hom_ext (by simpa only [pullback.lift_fst] using h)\n            (by simpa only [huv.symm, pullback.lift_fst] using h) }\n#align has_limit_parallel_pair has_limit_parallel_pair\n\n",
 "has_colimit_parallel_pair":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Command.lean:322:38: unsupported irreducible non-definition -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/-- The coequalizer of `f` and `g` exists. -/\nirreducible_def has_colimit_parallel_pair {X Y : C} (f g : «expr ⟶ » X Y) : HasColimit (parallelPair f g) :=\n  have huv : (pushout.inl : «expr ⟶ » Y (Q f g)) = pushout.inr :=\n    calc\n      (pushout.inl : «expr ⟶ » Y (Q f g)) = «expr ≫ » ((«expr𝟙») _) pushout.inl := Eq.symm <| Category.id_comp _\n      _ = «expr ≫ » («expr ≫ » coprod.inl (coprod.desc ((«expr𝟙») Y) f)) pushout.inl := by rw [coprod.inl_desc]\n      _ = «expr ≫ » («expr ≫ » coprod.inl (coprod.desc ((«expr𝟙») Y) g)) pushout.inr := by\n        simp only [category.assoc, pushout.condition]\n      _ = pushout.inr := by rw [coprod.inl_desc, category.id_comp]\n      \n  have hvu : «expr ≫ » f (pushout.inl : «expr ⟶ » Y (Q f g)) = «expr ≫ » g pushout.inr :=\n    calc\n      «expr ≫ » f (pushout.inl : «expr ⟶ » Y (Q f g)) =\n          «expr ≫ » («expr ≫ » coprod.inr (coprod.desc ((«expr𝟙») Y) f)) pushout.inl :=\n        by rw [coprod.inr_desc]\n      _ = «expr ≫ » («expr ≫ » coprod.inr (coprod.desc ((«expr𝟙») Y) g)) pushout.inr := by\n        simp only [category.assoc, pushout.condition]\n      _ = «expr ≫ » g pushout.inr := by rw [coprod.inr_desc]\n      \n  have huu : «expr ≫ » f (pushout.inl : «expr ⟶ » Y (Q f g)) = «expr ≫ » g pushout.inl := by rw [hvu, huv]\n  HasColimit.mk\n    { cocone := Cofork.ofπ pushout.inl huu\n      is_colimit :=\n        Cofork.IsColimit.mk _\n          (fun s =>\n            pushout.desc (Cofork.π s) (Cofork.π s) <|\n              coprod.hom_ext (by simp only [coprod.inl_desc_assoc]) (by simp only [coprod.desc_comp, cofork.condition]))\n          (fun s => by simp only [pushout.inl_desc, cofork.π_of_π]) fun s m h =>\n          pushout.hom_ext (by simpa only [pushout.inl_desc] using h)\n            (by simpa only [huv.symm, pushout.inl_desc] using h) }\n#align has_colimit_parallel_pair has_colimit_parallel_pair\n\n",
 "epi_of_zero_cokernel":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/-- If a zero morphism is a cokernel of `f`, then `f` is an epimorphism. -/\ntheorem epi_of_zero_cokernel {X Y : C} (f : «expr ⟶ » X Y) (Z : C)\n    (l : IsColimit (CokernelCofork.ofπ (0 : «expr ⟶ » Y Z) (show «expr ≫ » f 0 = 0 by simp))) : Epi f :=\n  ⟨fun P u v huv => by\n    obtain ⟨W, w, hw, hl⟩ := normal_mono_of_mono (equalizer.ι u v)\n    obtain ⟨m, hm⟩ := equalizer.lift' f huv\n    have hwf : «expr ≫ » f w = 0 := by rw [← hm, category.assoc, hw, comp_zero]\n    obtain ⟨n, hn⟩ := cokernel_cofork.is_colimit.desc' l _ hwf\n    rw [cofork.π_of_π, zero_comp] at hn\n    have : is_iso (equalizer.ι u v) := by apply is_iso_limit_cone_parallel_pair_of_eq hn.symm hl\n    apply (cancel_epi (equalizer.ι u v)).1\n    exact equalizer.condition _ _⟩\n#align epi_of_zero_cokernel epi_of_zero_cokernel\n\n",
 "epi_of_zero_cancel":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/-- If `f ≫ g = 0` implies `g = 0` for all `g`, then `g` is a monomorphism. -/\ntheorem epi_of_zero_cancel {X Y : C} (f : «expr ⟶ » X Y)\n    (hf : ∀ (Z : C) (g : «expr ⟶ » Y Z) (hgf : «expr ≫ » f g = 0), g = 0) : Epi f :=\n  epi_of_zero_cokernel f 0 <| zeroCokernelOfZeroCancel f hf\n#align epi_of_zero_cancel epi_of_zero_cancel\n\n"}