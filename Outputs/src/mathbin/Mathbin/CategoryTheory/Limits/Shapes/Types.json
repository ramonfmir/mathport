{"unique_of_type_equalizer":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/-- The converse of `type_equalizer_of_unique`. -/\ntheorem unique_of_type_equalizer (t : IsLimit (Fork.ofι _ w)) (y : Y) (hy : g y = h y) : ∃! x : X, f x = y :=\n  by\n  let y' : «expr ⟶ » PUnit Y := fun _ => y\n  have hy' : «expr ≫ » y' g = «expr ≫ » y' h := funext fun _ => hy\n  refine' ⟨(fork.is_limit.lift' t _ hy').1 ⟨⟩, congr_fun (fork.is_limit.lift' t y' _).2 ⟨⟩, _⟩\n  intro x' hx'\n  suffices : (fun _ : PUnit => x') = (fork.is_limit.lift' t y' hy').1\n  rw [← this]\n  apply fork.is_limit.hom_ext t\n  ext ⟨⟩\n  apply hx'.trans (congr_fun (fork.is_limit.lift' t _ hy').2 ⟨⟩).symm\n#align unique_of_type_equalizer unique_of_type_equalizer\n\n",
 "type_equalizer_iff_unique":
 "theorem type_equalizer_iff_unique : Nonempty (IsLimit (Fork.ofι _ w)) ↔ ∀ y : Y, g y = h y → ∃! x : X, f x = y :=\n  ⟨fun i => unique_of_type_equalizer _ _ (Classical.choice i), fun k => ⟨typeEqualizerOfUnique f w k⟩⟩\n#align type_equalizer_iff_unique type_equalizer_iff_unique\n\n",
 "pullback_iso_pullback_inv_snd":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp]\ntheorem pullback_iso_pullback_inv_snd :\n    «expr ≫ » (pullbackIsoPullback f g).inv pullback.snd = fun p => (p : X × Y).snd :=\n  (pullbackConeIsoPullback f g).inv.w right\n#align pullback_iso_pullback_inv_snd pullback_iso_pullback_inv_snd\n\n",
 "pullback_iso_pullback_inv_fst":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp]\ntheorem pullback_iso_pullback_inv_fst :\n    «expr ≫ » (pullbackIsoPullback f g).inv pullback.fst = fun p => (p : X × Y).fst :=\n  (pullbackConeIsoPullback f g).inv.w left\n#align pullback_iso_pullback_inv_fst pullback_iso_pullback_inv_fst\n\n",
 "pullback_iso_pullback_hom_snd":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n@[simp]\ntheorem pullback_iso_pullback_hom_snd (p : pullback f g) :\n    ((pullbackIsoPullback f g).hom p : X × Y).snd = (pullback.snd : «expr ⟶ » _ Y) p :=\n  congr_fun ((pullbackConeIsoPullback f g).hom.w right) p\n#align pullback_iso_pullback_hom_snd pullback_iso_pullback_hom_snd\n\n",
 "pullback_iso_pullback_hom_fst":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n-- `pullback_obj f g` comes with a coercion to the product type `X × Y`.\n@[simp]\ntheorem pullback_iso_pullback_hom_fst (p : pullback f g) :\n    ((pullbackIsoPullback f g).hom p : X × Y).fst = (pullback.fst : «expr ⟶ » _ X) p :=\n  congr_fun ((pullbackConeIsoPullback f g).hom.w left) p\n#align pullback_iso_pullback_hom_fst pullback_iso_pullback_hom_fst\n\n",
 "product_iso_inv_comp_π":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, elementwise]\ntheorem product_iso_inv_comp_π {J : Type u} (F : J → Type max u v) (j : J) :\n    «expr ≫ » (productIso F).inv (Pi.π F j) = fun f => f j :=\n  limit.isoLimitCone_inv_π (productLimitCone F) ⟨j⟩\n#align product_iso_inv_comp_π product_iso_inv_comp_π\n\n",
 "product_iso_hom_comp_eval":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, elementwise]\ntheorem product_iso_hom_comp_eval {J : Type u} (F : J → Type max u v) (j : J) :\n    («expr ≫ » (productIso F).hom fun f => f j) = Pi.π F j :=\n  rfl\n#align product_iso_hom_comp_eval product_iso_hom_comp_eval\n\n",
 "pi_map_π_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∏ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∏ » -/\n/-- A restatement of `types.map_π_apply` that uses `pi.π` and `pi.map`. -/\n@[simp]\ntheorem pi_map_π_apply {β : Type u} {f g : β → Type u} (α : ∀ j, «expr ⟶ » (f j) (g j)) (b : β) (x) :\n    (Pi.π g b : «expr∏ » g → g b) (Pi.map α x) = α b ((Pi.π f b : «expr∏ » f → f b) x) :=\n  Limit.map_π_apply _ _ _\n#align pi_map_π_apply pi_map_π_apply\n\n",
 "pi_lift_π_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∏ » -/\n/-\nCopyright (c) 2020 Scott Morrison. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Scott Morrison\n-/\n/-- A restatement of `types.lift_π_apply` that uses `pi.π` and `pi.lift`. -/\n@[simp]\ntheorem pi_lift_π_apply {β : Type u} (f : β → Type u) {P : Type u} (s : ∀ b, «expr ⟶ » P (f b)) (b : β) (x : P) :\n    (Pi.π f b : «expr∏ » f → f b) (@Pi.lift β _ _ f _ P s x) = s b x :=\n  congr_fun (limit.lift_π (Fan.mk P s) ⟨b⟩) x\n#align pi_lift_π_apply pi_lift_π_apply\n\n",
 "equalizer_iso_inv_comp_ι":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, elementwise]\ntheorem equalizer_iso_inv_comp_ι : «expr ≫ » (equalizerIso g h).inv (equalizer.ι g h) = Subtype.val :=\n  limit.isoLimitCone_inv_π equalizerLimit walking_parallel_pair.zero\n#align equalizer_iso_inv_comp_ι equalizer_iso_inv_comp_ι\n\n",
 "equalizer_iso_hom_comp_subtype":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, elementwise]\ntheorem equalizer_iso_hom_comp_subtype : «expr ≫ » (equalizerIso g h).hom Subtype.val = equalizer.ι g h :=\n  rfl\n#align equalizer_iso_hom_comp_subtype equalizer_iso_hom_comp_subtype\n\n",
 "coproduct_iso_ι_comp_hom":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, elementwise]\ntheorem coproduct_iso_ι_comp_hom {J : Type u} (F : J → Type u) (j : J) :\n    «expr ≫ » (Sigma.ι F j) (coproductIso F).hom = fun x : F j => (⟨j, x⟩ : Σj, F j) :=\n  colimit.isoColimitCocone_ι_hom (coproductColimitCocone F) ⟨j⟩\n#align coproduct_iso_ι_comp_hom coproduct_iso_ι_comp_hom\n\n",
 "coproduct_iso_mk_comp_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `category_theory.as_hom -/\n@[simp, elementwise]\ntheorem coproduct_iso_mk_comp_inv {J : Type u} (F : J → Type u) (j : J) :\n    «expr ≫ » (category_theory.as_hom fun x : F j => (⟨j, x⟩ : Σj, F j)) (coproductIso F).inv = Sigma.ι F j :=\n  rfl\n#align coproduct_iso_mk_comp_inv coproduct_iso_mk_comp_inv\n\n",
 "coequalizer_preimage_image_eq_of_preimage_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/-- If `π : Y ⟶ Z` is an equalizer for `(f, g)`, and `U ⊆ Y` such that `f ⁻¹' U = g ⁻¹' U`,\nthen `π ⁻¹' (π '' U) = U`.\n-/\ntheorem coequalizer_preimage_image_eq_of_preimage_eq (π : «expr ⟶ » Y Z) (e : «expr ≫ » f π = «expr ≫ » g π)\n    (h : IsColimit (Cofork.ofπ π e)) (U : Set Y) (H : «expr ⁻¹' » f U = «expr ⁻¹' » g U) :\n    «expr ⁻¹' » π («expr '' » π U) = U :=\n  by\n  have lem : ∀ x y, coequalizer_rel f g x y → (x ∈ U ↔ y ∈ U) :=\n    by\n    rintro _ _ ⟨x⟩\n    change x ∈ «expr ⁻¹' » f U ↔ x ∈ «expr ⁻¹' » g U\n    congr 2\n  have eqv : _root_.equivalence fun x y => x ∈ U ↔ y ∈ U := by tidy\n  ext\n  constructor\n  · rw [←\n      show _ = π from h.comp_cocone_point_unique_up_to_iso_inv (coequalizer_colimit f g).2 walking_parallel_pair.one]\n    rintro ⟨y, hy, e'⟩\n    dsimp at e'\n    replace e' :=\n      (mono_iff_injective (h.cocone_point_unique_up_to_iso (coequalizer_colimit f g).is_colimit).inv).mp inferInstance\n        e'\n    exact (eqv.eqv_gen_iff.mp (EqvGen.mono lem (Quot.exact _ e'))).mp hy\n  · exact fun hx => ⟨x, hx, rfl⟩\n#align coequalizer_preimage_image_eq_of_preimage_eq coequalizer_preimage_image_eq_of_preimage_eq\n\n",
 "coequalizer_iso_π_comp_hom":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, elementwise]\ntheorem coequalizer_iso_π_comp_hom :\n    «expr ≫ » (coequalizer.π f g) (coequalizerIso f g).hom = Quot.mk (CoequalizerRel f g) :=\n  colimit.isoColimitCocone_ι_hom (coequalizerColimit f g) walking_parallel_pair.one\n#align coequalizer_iso_π_comp_hom coequalizer_iso_π_comp_hom\n\n",
 "coequalizer_iso_quot_comp_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `category_theory.as_hom -/\n@[simp, elementwise]\ntheorem coequalizer_iso_quot_comp_inv :\n    «expr ≫ » (category_theory.as_hom (Quot.mk (CoequalizerRel f g))) (coequalizerIso f g).inv = coequalizer.π f g :=\n  rfl\n#align coequalizer_iso_quot_comp_inv coequalizer_iso_quot_comp_inv\n\n",
 "binary_product_iso_inv_comp_snd":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, elementwise]\ntheorem binary_product_iso_inv_comp_snd (X Y : Type u) :\n    «expr ≫ » (binaryProductIso X Y).inv Limits.prod.snd = Prod.snd :=\n  limit.isoLimitCone_inv_π (binaryProductLimitCone X Y) ⟨walking_pair.right⟩\n#align binary_product_iso_inv_comp_snd binary_product_iso_inv_comp_snd\n\n",
 "binary_product_iso_inv_comp_fst":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, elementwise]\ntheorem binary_product_iso_inv_comp_fst (X Y : Type u) :\n    «expr ≫ » (binaryProductIso X Y).inv Limits.prod.fst = Prod.fst :=\n  limit.isoLimitCone_inv_π (binaryProductLimitCone X Y) ⟨walking_pair.left⟩\n#align binary_product_iso_inv_comp_fst binary_product_iso_inv_comp_fst\n\n",
 "binary_product_iso_hom_comp_snd":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, elementwise]\ntheorem binary_product_iso_hom_comp_snd (X Y : Type u) :\n    «expr ≫ » (binaryProductIso X Y).hom Prod.snd = Limits.prod.snd :=\n  limit.isoLimitCone_hom_π (binaryProductLimitCone X Y) ⟨walking_pair.right⟩\n#align binary_product_iso_hom_comp_snd binary_product_iso_hom_comp_snd\n\n",
 "binary_product_iso_hom_comp_fst":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, elementwise]\ntheorem binary_product_iso_hom_comp_fst (X Y : Type u) :\n    «expr ≫ » (binaryProductIso X Y).hom Prod.fst = Limits.prod.fst :=\n  limit.isoLimitCone_hom_π (binaryProductLimitCone X Y) ⟨walking_pair.left⟩\n#align binary_product_iso_hom_comp_fst binary_product_iso_hom_comp_fst\n\n",
 "binary_product_cone_snd":
 "@[simp]\ntheorem binary_product_cone_snd (X Y : Type u) : (binaryProductCone X Y).snd = Prod.snd :=\n  rfl\n#align binary_product_cone_snd binary_product_cone_snd\n\n",
 "binary_product_cone_fst":
 "-- We manually generate the other projection lemmas since the simp-normal form for the legs is\n-- otherwise not created correctly.\n@[simp]\ntheorem binary_product_cone_fst (X Y : Type u) : (binaryProductCone X Y).fst = Prod.fst :=\n  rfl\n#align binary_product_cone_fst binary_product_cone_fst\n\n",
 "binary_coproduct_iso_inr_comp_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `category_theory.as_hom -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n@[simp, elementwise]\ntheorem binary_coproduct_iso_inr_comp_inv (X Y : Type u) :\n    «expr ≫ » (category_theory.as_hom (Sum.inr : «expr ⟶ » Y (Sum X Y))) (binaryCoproductIso X Y).inv =\n      Limits.coprod.inr :=\n  colimit.isoColimitCocone_ι_inv (binaryCoproductColimitCocone X Y) ⟨walking_pair.right⟩\n#align binary_coproduct_iso_inr_comp_inv binary_coproduct_iso_inr_comp_inv\n\n",
 "binary_coproduct_iso_inr_comp_hom":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, elementwise]\ntheorem binary_coproduct_iso_inr_comp_hom (X Y : Type u) :\n    «expr ≫ » Limits.coprod.inr (binaryCoproductIso X Y).hom = Sum.inr :=\n  colimit.isoColimitCocone_ι_hom (binaryCoproductColimitCocone X Y) ⟨walking_pair.right⟩\n#align binary_coproduct_iso_inr_comp_hom binary_coproduct_iso_inr_comp_hom\n\n",
 "binary_coproduct_iso_inl_comp_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `category_theory.as_hom -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n@[simp, elementwise]\ntheorem binary_coproduct_iso_inl_comp_inv (X Y : Type u) :\n    «expr ≫ » (category_theory.as_hom (Sum.inl : «expr ⟶ » X (Sum X Y))) (binaryCoproductIso X Y).inv =\n      Limits.coprod.inl :=\n  colimit.isoColimitCocone_ι_inv (binaryCoproductColimitCocone X Y) ⟨walking_pair.left⟩\n#align binary_coproduct_iso_inl_comp_inv binary_coproduct_iso_inl_comp_inv\n\n",
 "binary_coproduct_iso_inl_comp_hom":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n-- We add the option `type_md` to tell `@[simps]` to not treat homomorphisms `X ⟶ Y` in `Type*` as\n-- a function type\n@[simp, elementwise]\ntheorem binary_coproduct_iso_inl_comp_hom (X Y : Type u) :\n    «expr ≫ » Limits.coprod.inl (binaryCoproductIso X Y).hom = Sum.inl :=\n  colimit.isoColimitCocone_ι_hom (binaryCoproductColimitCocone X Y) ⟨walking_pair.left⟩\n#align binary_coproduct_iso_inl_comp_hom binary_coproduct_iso_inl_comp_hom\n\n",
 "binary_cofan_is_colimit_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\ntheorem binary_cofan_is_colimit_iff {X Y : Type u} (c : BinaryCofan X Y) :\n    Nonempty (IsColimit c) ↔ injective c.inl ∧ injective c.inr ∧ IsCompl (Set.range c.inl) (Set.range c.inr) := by\n  classical\n    constructor\n    · rintro ⟨h⟩\n      rw [←\n        show _ = c.inl from h.comp_cocone_point_unique_up_to_iso_inv (binary_coproduct_colimit X Y) ⟨walking_pair.left⟩,\n        ←\n        show _ = c.inr from\n          h.comp_cocone_point_unique_up_to_iso_inv (binary_coproduct_colimit X Y) ⟨walking_pair.right⟩]\n      dsimp [binary_coproduct_cocone]\n      refine'\n        ⟨(h.cocone_point_unique_up_to_iso (binary_coproduct_colimit X Y)).symm.to_equiv.injective.comp\n            Sum.inl_injective,\n          (h.cocone_point_unique_up_to_iso (binary_coproduct_colimit X Y)).symm.to_equiv.injective.comp\n            Sum.inr_injective,\n          _⟩\n      erw [Set.range_comp, ← eq_compl_iff_isCompl, Set.range_comp _ Sum.inr, ←\n        Set.image_compl_eq (h.cocone_point_unique_up_to_iso (binary_coproduct_colimit X Y)).symm.to_equiv.bijective]\n      congr 1\n      exact set.compl_range_inr.symm\n    · rintro ⟨h₁, h₂, h₃⟩\n      have : ∀ x, x ∈ Set.range c.inl ∨ x ∈ Set.range c.inr :=\n        by\n        rw [eq_compl_iff_is_compl.mpr h₃.symm]\n        exact fun _ => or_not\n      refine' ⟨binary_cofan.is_colimit.mk _ _ _ _ _⟩\n      · intro T f g x\n        exact\n          if h : x ∈ Set.range c.inl then f ((Equiv.ofInjective _ h₁).symm ⟨x, h⟩)\n          else g ((Equiv.ofInjective _ h₂).symm ⟨x, (this x).resolve_left h⟩)\n      · intro T f g\n        ext x\n        dsimp\n        simp [h₁.eq_iff]\n      · intro T f g\n        ext x\n        dsimp\n        simp only [forall_exists_index, Equiv.ofInjective_symm_apply, dif_ctx_congr, dite_eq_right_iff]\n        intro y e\n        have : c.inr x ∈ «expr ⊓ » (Set.range c.inl) (Set.range c.inr) := ⟨⟨_, e⟩, ⟨_, rfl⟩⟩\n        rw [disjoint_iff.mp h₃.1] at this\n        exact this.elim\n      · rintro T _ _ m rfl rfl\n        ext x\n        dsimp\n        split_ifs <;> exact congr_arg _ (Equiv.apply_ofInjective_symm _ ⟨_, _⟩).symm\n#align binary_cofan_is_colimit_iff binary_cofan_is_colimit_iff\n\n"}