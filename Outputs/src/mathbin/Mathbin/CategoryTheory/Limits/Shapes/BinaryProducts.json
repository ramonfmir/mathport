{"π_app_right":
 "@[simp]\ntheorem binary_fan.π_app_right {X Y : C} (s : binary_fan X Y) : s.π.app ⟨walking_pair.right⟩ = s.snd :=\n  rfl\n#align binary_fan.π_app_right binary_fan.π_app_right\n\n",
 "π_app_left":
 "@[simp]\ntheorem binary_fan.π_app_left {X Y : C} (s : binary_fan X Y) : s.π.app ⟨walking_pair.left⟩ = s.fst :=\n  rfl\n#align binary_fan.π_app_left binary_fan.π_app_left\n\n",
 "ι_app_right":
 "@[simp]\ntheorem binary_cofan.ι_app_right {X Y : C} (s : binary_cofan X Y) : s.ι.app ⟨walking_pair.right⟩ = s.inr :=\n  rfl\n#align binary_cofan.ι_app_right binary_cofan.ι_app_right\n\n",
 "ι_app_left":
 "@[simp]\ntheorem binary_cofan.ι_app_left {X Y : C} (s : binary_cofan X Y) : s.ι.app ⟨walking_pair.left⟩ = s.inl :=\n  rfl\n#align binary_cofan.ι_app_left binary_cofan.ι_app_left\n\n",
 "triangle":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥_ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\ntheorem coprod.triangle (X Y : C) :\n    «expr ≫ » (coprod.associator X («expr⊥_ » C) Y).hom (coprod.map ((«expr𝟙») X) (coprod.left_unitor Y).hom) =\n      coprod.map (coprod.right_unitor X).hom ((«expr𝟙») Y) :=\n  by tidy\n#align coprod.triangle coprod.triangle\n\n",
 "symmetry'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⨿ » -/\n@[reassoc.1]\ntheorem coprod.symmetry' (P Q : C) :\n    «expr ≫ » (coprod.desc coprod.inr coprod.inl) (coprod.desc coprod.inr coprod.inl) = («expr𝟙») («expr ⨿ » P Q) :=\n  (coprod.braiding _ _).hom_inv_id\n#align coprod.symmetry' coprod.symmetry'\n\n",
 "symmetry":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/-- The braiding isomorphism is symmetric. -/\ntheorem coprod.symmetry (P Q : C) : «expr ≫ » (coprod.braiding P Q).hom (coprod.braiding Q P).hom = («expr𝟙») _ :=\n  coprod.symmetry' _ _\n#align coprod.symmetry coprod.symmetry\n\n",
 "swap_symm_apply_tt":
 "@[simp]\ntheorem walking_pair.swap_symm_apply_tt : walking_pair.swap.symm left = right :=\n  rfl\n#align walking_pair.swap_symm_apply_tt walking_pair.swap_symm_apply_tt\n\n",
 "swap_symm_apply_ff":
 "@[simp]\ntheorem walking_pair.swap_symm_apply_ff : walking_pair.swap.symm right = left :=\n  rfl\n#align walking_pair.swap_symm_apply_ff walking_pair.swap_symm_apply_ff\n\n",
 "swap_apply_right":
 "@[simp]\ntheorem walking_pair.swap_apply_right : walking_pair.swap right = left :=\n  rfl\n#align walking_pair.swap_apply_right walking_pair.swap_apply_right\n\n",
 "swap_apply_left":
 "/-\nCopyright (c) 2019 Scott Morrison. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Scott Morrison, Bhavik Mehta\n-/\n@[simp]\ntheorem walking_pair.swap_apply_left : walking_pair.swap left = right :=\n  rfl\n#align walking_pair.swap_apply_left walking_pair.swap_apply_left\n\n",
 "right_unitor_hom_naturality":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[reassoc.1]\ntheorem prod.right_unitor_hom_naturality [has_binary_products C] (f : «expr ⟶ » X Y) :\n    «expr ≫ » (prod.map f ((«expr𝟙») _)) (prod.right_unitor Y).hom = «expr ≫ » (prod.right_unitor X).hom f :=\n  prod.map_fst _ _\n#align prod.right_unitor_hom_naturality prod.right_unitor_hom_naturality\n\n",
 "prod_right_unitor_inv_naturality":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[reassoc.1]\ntheorem prod_right_unitor_inv_naturality [has_binary_products C] (f : «expr ⟶ » X Y) :\n    «expr ≫ » (prod.right_unitor X).inv (prod.map f ((«expr𝟙») _)) = «expr ≫ » f (prod.right_unitor Y).inv := by\n  rw [iso.inv_comp_eq, ← category.assoc, iso.eq_comp_inv, prod.right_unitor_hom_naturality]\n#align prod_right_unitor_inv_naturality prod_right_unitor_inv_naturality\n\n",
 "prod_comparison_snd":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem prod_comparison_snd : «expr ≫ » (prod_comparison F A B) prod.snd = F.map prod.snd :=\n  prod.lift_snd _ _\n#align prod_comparison_snd prod_comparison_snd\n\n",
 "prod_comparison_natural":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/-- Naturality of the prod_comparison morphism in both arguments. -/\n@[reassoc.1]\ntheorem prod_comparison_natural (f : «expr ⟶ » A A') (g : «expr ⟶ » B B') :\n    «expr ≫ » (F.map (prod.map f g)) (prod_comparison F A' B') =\n      «expr ≫ » (prod_comparison F A B) (prod.map (F.map f) (F.map g)) :=\n  by\n  rw [prod_comparison, prod_comparison, prod.lift_map, ← F.map_comp, ← F.map_comp, prod.comp_lift, ← F.map_comp,\n    prod.map_fst, ← F.map_comp, prod.map_snd]\n#align prod_comparison_natural prod_comparison_natural\n\n",
 "prod_comparison_inv_natural":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/-- If the product comparison morphism is an iso, its inverse is natural. -/\n@[reassoc.1]\ntheorem prod_comparison_inv_natural (f : «expr ⟶ » A A') (g : «expr ⟶ » B B') [IsIso (prod_comparison F A B)]\n    [IsIso (prod_comparison F A' B')] :\n    «expr ≫ » (inv (prod_comparison F A B)) (F.map (prod.map f g)) =\n      «expr ≫ » (prod.map (F.map f) (F.map g)) (inv (prod_comparison F A' B')) :=\n  by rw [is_iso.eq_comp_inv, category.assoc, is_iso.inv_comp_eq, prod_comparison_natural]\n#align prod_comparison_inv_natural prod_comparison_inv_natural\n\n",
 "prod_comparison_fst":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem prod_comparison_fst : «expr ≫ » (prod_comparison F A B) prod.fst = F.map prod.fst :=\n  prod.lift_fst _ _\n#align prod_comparison_fst prod_comparison_fst\n\n",
 "pentagon":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⨿ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⨿ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⨿ » -/\ntheorem coprod.pentagon (W X Y Z : C) :\n    «expr ≫ » (coprod.map (coprod.associator W X Y).hom ((«expr𝟙») Z))\n        («expr ≫ » (coprod.associator W («expr ⨿ » X Y) Z).hom\n          (coprod.map ((«expr𝟙») W) (coprod.associator X Y Z).hom)) =\n      «expr ≫ » (coprod.associator («expr ⨿ » W X) Y Z).hom (coprod.associator W X («expr ⨿ » Y Z)).hom :=\n  by simp\n#align coprod.pentagon coprod.pentagon\n\n",
 "pair_obj_right":
 "@[simp]\ntheorem pair_obj_right (X Y : C) : (pair X Y).obj ⟨right⟩ = Y :=\n  rfl\n#align pair_obj_right pair_obj_right\n\n",
 "pair_obj_left":
 "@[simp]\ntheorem pair_obj_left (X Y : C) : (pair X Y).obj ⟨left⟩ = X :=\n  rfl\n#align pair_obj_left pair_obj_left\n\n",
 "pair_function_right":
 "@[simp]\ntheorem pair_function_right (X Y : C) : pair_function X Y right = Y :=\n  rfl\n#align pair_function_right pair_function_right\n\n",
 "pair_function_left":
 "@[simp]\ntheorem pair_function_left (X Y : C) : pair_function X Y left = X :=\n  rfl\n#align pair_function_left pair_function_left\n\n",
 "mk_snd":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n@[simp]\ntheorem binary_fan.mk_snd {P : C} (π₁ : «expr ⟶ » P X) (π₂ : «expr ⟶ » P Y) : (binary_fan.mk π₁ π₂).snd = π₂ :=\n  rfl\n#align binary_fan.mk_snd binary_fan.mk_snd\n\n",
 "mk_inr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n@[simp]\ntheorem binary_cofan.mk_inr {P : C} (ι₁ : «expr ⟶ » X P) (ι₂ : «expr ⟶ » Y P) : (binary_cofan.mk ι₁ ι₂).inr = ι₂ :=\n  rfl\n#align binary_cofan.mk_inr binary_cofan.mk_inr\n\n",
 "mk_inl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n@[simp]\ntheorem binary_cofan.mk_inl {P : C} (ι₁ : «expr ⟶ » X P) (ι₂ : «expr ⟶ » Y P) : (binary_cofan.mk ι₁ ι₂).inl = ι₁ :=\n  rfl\n#align binary_cofan.mk_inl binary_cofan.mk_inl\n\n",
 "mk_fst":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n@[simp]\ntheorem binary_fan.mk_fst {P : C} (π₁ : «expr ⟶ » P X) (π₂ : «expr ⟶ » P Y) : (binary_fan.mk π₁ π₂).fst = π₁ :=\n  rfl\n#align binary_fan.mk_fst binary_fan.mk_fst\n\n",
 "map_swap":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n-- I don't think it's a good idea to make any of the following three simp lemmas.\n@[reassoc.1]\ntheorem coprod.map_swap {A B X Y : C} (f : «expr ⟶ » A B) (g : «expr ⟶ » X Y)\n    [has_colimits_of_shape (discrete walking_pair) C] :\n    «expr ≫ » (coprod.map ((«expr𝟙») X) f) (coprod.map g ((«expr𝟙») B)) =\n      «expr ≫ » (coprod.map g ((«expr𝟙») A)) (coprod.map ((«expr𝟙») Y) f) :=\n  by simp\n#align coprod.map_swap coprod.map_swap\n\n",
 "map_snd":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem prod.map_snd {W X Y Z : C} [has_binary_product W X] [has_binary_product Y Z] (f : «expr ⟶ » W Y)\n    (g : «expr ⟶ » X Z) : «expr ≫ » (prod.map f g) prod.snd = «expr ≫ » prod.snd g :=\n  lim_map_π _ _\n#align prod.map_snd prod.map_snd\n\n",
 "map_pair_right":
 "@[simp]\ntheorem map_pair_right : (map_pair f g).app ⟨right⟩ = g :=\n  rfl\n#align map_pair_right map_pair_right\n\n",
 "map_pair_left":
 "@[simp]\ntheorem map_pair_left : (map_pair f g).app ⟨left⟩ = f :=\n  rfl\n#align map_pair_left map_pair_left\n\n",
 "map_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n-- We take the right hand side here to be simp normal form, as this way composition lemmas for\n-- `f ≫ h` and `g ≫ k` can fire (eg `id_comp`) , while `inl_map` and `inr_map` can still work just\n-- as well.\n@[simp, reassoc.1]\ntheorem coprod.map_map {A₁ A₂ A₃ B₁ B₂ B₃ : C} [has_binary_coproduct A₁ B₁] [has_binary_coproduct A₂ B₂]\n    [has_binary_coproduct A₃ B₃] (f : «expr ⟶ » A₁ A₂) (g : «expr ⟶ » B₁ B₂) (h : «expr ⟶ » A₂ A₃)\n    (k : «expr ⟶ » B₂ B₃) : «expr ≫ » (coprod.map f g) (coprod.map h k) = coprod.map («expr ≫ » f h) («expr ≫ » g k) :=\n  by ext <;> simp\n#align coprod.map_map coprod.map_map\n\n",
 "map_inr_inv_coprod_comparison":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[reassoc.1]\ntheorem map_inr_inv_coprod_comparison [IsIso (coprod_comparison F A B)] :\n    «expr ≫ » (F.map coprod.inr) (inv (coprod_comparison F A B)) = coprod.inr := by simp [is_iso.inv_comp_eq]\n#align map_inr_inv_coprod_comparison map_inr_inv_coprod_comparison\n\n",
 "map_inl_inv_coprod_comparison":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[reassoc.1]\ntheorem map_inl_inv_coprod_comparison [IsIso (coprod_comparison F A B)] :\n    «expr ≫ » (F.map coprod.inl) (inv (coprod_comparison F A B)) = coprod.inl := by simp [is_iso.inv_comp_eq]\n#align map_inl_inv_coprod_comparison map_inl_inv_coprod_comparison\n\n",
 "map_inl_inr_codiag":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⨿ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⨿ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⨿ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⨿ » -/\n-- The simp linter says simp can prove the reassoc version of this lemma.\n@[reassoc.1, simp]\ntheorem coprod.map_inl_inr_codiag {X Y : C} [has_binary_coproduct X Y]\n    [has_binary_coproduct («expr ⨿ » X Y) («expr ⨿ » X Y)] :\n    «expr ≫ » (coprod.map coprod.inl coprod.inr) (codiag («expr ⨿ » X Y)) = («expr𝟙») («expr ⨿ » X Y) := by simp\n#align coprod.map_inl_inr_codiag coprod.map_inl_inr_codiag\n\n",
 "map_id_id":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n@[simp]\ntheorem coprod.map_id_id {X Y : C} [has_binary_coproduct X Y] : coprod.map ((«expr𝟙») X) ((«expr𝟙») Y) = («expr𝟙») _ :=\n  by ext <;> simp\n#align coprod.map_id_id coprod.map_id_id\n\n",
 "map_id_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n@[reassoc.1]\ntheorem coprod.map_id_comp {X Y Z W : C} (f : «expr ⟶ » X Y) (g : «expr ⟶ » Y Z) [has_binary_coproduct W X]\n    [has_binary_coproduct W Y] [has_binary_coproduct W Z] :\n    coprod.map ((«expr𝟙») W) («expr ≫ » f g) = «expr ≫ » (coprod.map ((«expr𝟙») W) f) (coprod.map ((«expr𝟙») W) g) := by\n  simp\n#align coprod.map_id_comp coprod.map_id_comp\n\n",
 "map_fst":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem prod.map_fst {W X Y Z : C} [has_binary_product W X] [has_binary_product Y Z] (f : «expr ⟶ » W Y)\n    (g : «expr ⟶ » X Z) : «expr ≫ » (prod.map f g) prod.fst = «expr ≫ » prod.fst f :=\n  lim_map_π _ _\n#align prod.map_fst prod.map_fst\n\n",
 "map_desc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n-- The simp linter says simp can prove the reassoc version of this lemma.\n@[reassoc.1, simp]\ntheorem coprod.map_desc {S T U V W : C} [has_binary_coproduct U W] [has_binary_coproduct T V] (f : «expr ⟶ » U S)\n    (g : «expr ⟶ » W S) (h : «expr ⟶ » T U) (k : «expr ⟶ » V W) :\n    «expr ≫ » (coprod.map h k) (coprod.desc f g) = coprod.desc («expr ≫ » h f) («expr ≫ » k g) := by ext <;> simp\n#align coprod.map_desc coprod.map_desc\n\n",
 "map_comp_inl_inr_codiag":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⨿ » -/\n-- The simp linter says simp can prove the reassoc version of this lemma.\n@[reassoc.1, simp]\ntheorem coprod.map_comp_inl_inr_codiag [has_colimits_of_shape (discrete walking_pair) C] {X X' Y Y' : C}\n    (g : «expr ⟶ » X Y) (g' : «expr ⟶ » X' Y') :\n    «expr ≫ » (coprod.map («expr ≫ » g coprod.inl) («expr ≫ » g' coprod.inr)) (codiag («expr ⨿ » Y Y')) =\n      coprod.map g g' :=\n  by simp\n#align coprod.map_comp_inl_inr_codiag coprod.map_comp_inl_inr_codiag\n\n",
 "map_comp_id":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n@[reassoc.1]\ntheorem coprod.map_comp_id {X Y Z W : C} (f : «expr ⟶ » X Y) (g : «expr ⟶ » Y Z) [has_binary_coproduct Z W]\n    [has_binary_coproduct Y W] [has_binary_coproduct X W] :\n    coprod.map («expr ≫ » f g) ((«expr𝟙») W) = «expr ≫ » (coprod.map f ((«expr𝟙») W)) (coprod.map g ((«expr𝟙») W)) := by\n  simp\n#align coprod.map_comp_id coprod.map_comp_id\n\n",
 "map_codiag":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n-- The simp linter says simp can prove the reassoc version of this lemma.\n@[reassoc.1, simp]\ntheorem coprod.map_codiag {X Y : C} (f : «expr ⟶ » X Y) [has_binary_coproduct X X] [has_binary_coproduct Y Y] :\n    «expr ≫ » (coprod.map f f) (codiag Y) = «expr ≫ » (codiag X) f := by simp\n#align coprod.map_codiag coprod.map_codiag\n\n",
 "lift_snd":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem prod.lift_snd {W X Y : C} [has_binary_product X Y] (f : «expr ⟶ » W X) (g : «expr ⟶ » W Y) :\n    «expr ≫ » (prod.lift f g) prod.snd = g :=\n  limit.lift_π _ _\n#align prod.lift_snd prod.lift_snd\n\n",
 "lift_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem prod.lift_map {V W X Y Z : C} [has_binary_product W X] [has_binary_product Y Z] (f : «expr ⟶ » V W)\n    (g : «expr ⟶ » V X) (h : «expr ⟶ » W Y) (k : «expr ⟶ » X Z) :\n    «expr ≫ » (prod.lift f g) (prod.map h k) = prod.lift («expr ≫ » f h) («expr ≫ » g k) := by ext <;> simp\n#align prod.lift_map prod.lift_map\n\n",
 "lift_fst_snd":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⨯ » -/\n@[simp]\ntheorem prod.lift_fst_snd {X Y : C} [has_binary_product X Y] :\n    prod.lift prod.fst prod.snd = («expr𝟙») («expr ⨯ » X Y) := by ext <;> simp\n#align prod.lift_fst_snd prod.lift_fst_snd\n\n",
 "lift_fst_comp_snd_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp]\ntheorem prod.lift_fst_comp_snd_comp {W X Y Z : C} [has_binary_product W Y] [has_binary_product X Z] (g : «expr ⟶ » W X)\n    (g' : «expr ⟶ » Y Z) : prod.lift («expr ≫ » prod.fst g) («expr ≫ » prod.snd g') = prod.map g g' :=\n  by\n  rw [← prod.lift_map]\n  simp\n#align prod.lift_fst_comp_snd_comp prod.lift_fst_comp_snd_comp\n\n",
 "lift_fst":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem prod.lift_fst {W X Y : C} [has_binary_product X Y] (f : «expr ⟶ » W X) (g : «expr ⟶ » W Y) :\n    «expr ≫ » (prod.lift f g) prod.fst = f :=\n  limit.lift_π _ _\n#align prod.lift_fst prod.lift_fst\n\n",
 "left_unitor_inv_naturality":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[reassoc.1]\ntheorem prod.left_unitor_inv_naturality [has_binary_products C] (f : «expr ⟶ » X Y) :\n    «expr ≫ » (prod.left_unitor X).inv (prod.map ((«expr𝟙») _) f) = «expr ≫ » f (prod.left_unitor Y).inv := by\n  rw [iso.inv_comp_eq, ← category.assoc, iso.eq_comp_inv, prod.left_unitor_hom_naturality]\n#align prod.left_unitor_inv_naturality prod.left_unitor_inv_naturality\n\n",
 "left_unitor_hom_naturality":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[reassoc.1]\ntheorem prod.left_unitor_hom_naturality [has_binary_products C] (f : «expr ⟶ » X Y) :\n    «expr ≫ » (prod.map ((«expr𝟙») _) f) (prod.left_unitor Y).hom = «expr ≫ » (prod.left_unitor X).hom f :=\n  prod.map_snd _ _\n#align prod.left_unitor_hom_naturality prod.left_unitor_hom_naturality\n\n",
 "is_limit_iff_is_iso_snd":
 "theorem binary_fan.is_limit_iff_is_iso_snd {X Y : C} (h : is_terminal X) (c : binary_fan X Y) :\n    nonempty (is_limit c) ↔ IsIso c.snd :=\n  by\n  refine' iff.trans _ (binary_fan.is_limit_iff_is_iso_fst h (binary_fan.mk c.snd c.fst))\n  exact\n    ⟨fun h => ⟨binary_fan.is_limit_flip h.some⟩, fun h =>\n      ⟨(binary_fan.is_limit_flip h.some).of_iso_limit (iso_binary_fan_mk c).symm⟩⟩\n#align binary_fan.is_limit_iff_is_iso_snd binary_fan.is_limit_iff_is_iso_snd\n\n",
 "is_limit_iff_is_iso_fst":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem binary_fan.is_limit_iff_is_iso_fst {X Y : C} (h : is_terminal Y) (c : binary_fan X Y) :\n    nonempty (is_limit c) ↔ IsIso c.fst := by\n  constructor\n  · rintro ⟨H⟩\n    obtain ⟨l, hl, -⟩ := binary_fan.is_limit.lift' H ((«expr𝟙») X) (h.from X)\n    exact\n      ⟨⟨l, binary_fan.is_limit.hom_ext H (by simpa [hl, -category.comp_id] using category.comp_id _) (h.hom_ext _ _),\n          hl⟩⟩\n  · intro\n    exact\n      ⟨binary_fan.is_limit.mk _ (fun _ f _ => «expr ≫ » f (inv c.fst)) (fun _ _ _ => by simp)\n          (fun _ _ _ => h.hom_ext _ _) fun _ _ _ _ e _ => by simp [← e]⟩\n#align binary_fan.is_limit_iff_is_iso_fst binary_fan.is_limit_iff_is_iso_fst\n\n",
 "is_colimit_iff_is_iso_inr":
 "theorem binary_cofan.is_colimit_iff_is_iso_inr {X Y : C} (h : is_initial X) (c : binary_cofan X Y) :\n    nonempty (is_colimit c) ↔ IsIso c.inr :=\n  by\n  refine' iff.trans _ (binary_cofan.is_colimit_iff_is_iso_inl h (binary_cofan.mk c.inr c.inl))\n  exact\n    ⟨fun h => ⟨binary_cofan.is_colimit_flip h.some⟩, fun h =>\n      ⟨(binary_cofan.is_colimit_flip h.some).of_iso_colimit (iso_binary_cofan_mk c).symm⟩⟩\n#align binary_cofan.is_colimit_iff_is_iso_inr binary_cofan.is_colimit_iff_is_iso_inr\n\n",
 "is_colimit_iff_is_iso_inl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem binary_cofan.is_colimit_iff_is_iso_inl {X Y : C} (h : is_initial Y) (c : binary_cofan X Y) :\n    nonempty (is_colimit c) ↔ IsIso c.inl := by\n  constructor\n  · rintro ⟨H⟩\n    obtain ⟨l, hl, -⟩ := binary_cofan.is_colimit.desc' H ((«expr𝟙») X) (h.to X)\n    exact ⟨⟨l, hl, binary_cofan.is_colimit.hom_ext H (by simp [reassoc_of hl]) (h.hom_ext _ _)⟩⟩\n  · intro\n    exact\n      ⟨binary_cofan.is_colimit.mk _ (fun _ f _ => «expr ≫ » (inv c.inl) f) (fun _ _ _ => is_iso.hom_inv_id_assoc _ _)\n          (fun _ _ _ => h.hom_ext _ _) fun _ _ _ _ e _ => (is_iso.eq_inv_comp _).mpr e⟩\n#align binary_cofan.is_colimit_iff_is_iso_inl binary_cofan.is_colimit_iff_is_iso_inl\n\n",
 "inv_prod_comparison_map_snd":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[reassoc.1]\ntheorem inv_prod_comparison_map_snd [IsIso (prod_comparison F A B)] :\n    «expr ≫ » (inv (prod_comparison F A B)) (F.map prod.snd) = prod.snd := by simp [is_iso.inv_comp_eq]\n#align inv_prod_comparison_map_snd inv_prod_comparison_map_snd\n\n",
 "inv_prod_comparison_map_fst":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[reassoc.1]\ntheorem inv_prod_comparison_map_fst [IsIso (prod_comparison F A B)] :\n    «expr ≫ » (inv (prod_comparison F A B)) (F.map prod.fst) = prod.fst := by simp [is_iso.inv_comp_eq]\n#align inv_prod_comparison_map_fst inv_prod_comparison_map_fst\n\n",
 "inr_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem coprod.inr_map {W X Y Z : C} [has_binary_coproduct W X] [has_binary_coproduct Y Z] (f : «expr ⟶ » W Y)\n    (g : «expr ⟶ » X Z) : «expr ≫ » coprod.inr (coprod.map f g) = «expr ≫ » g coprod.inr :=\n  ι_colim_map _ _\n#align coprod.inr_map coprod.inr_map\n\n",
 "inr_desc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n-- The simp linter says simp can prove the reassoc version of this lemma.\n@[reassoc.1, simp]\ntheorem coprod.inr_desc {W X Y : C} [has_binary_coproduct X Y] (f : «expr ⟶ » X W) (g : «expr ⟶ » Y W) :\n    «expr ≫ » coprod.inr (coprod.desc f g) = g :=\n  colimit.ι_desc _ _\n#align coprod.inr_desc coprod.inr_desc\n\n",
 "inl_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem coprod.inl_map {W X Y Z : C} [has_binary_coproduct W X] [has_binary_coproduct Y Z] (f : «expr ⟶ » W Y)\n    (g : «expr ⟶ » X Z) : «expr ≫ » coprod.inl (coprod.map f g) = «expr ≫ » f coprod.inl :=\n  ι_colim_map _ _\n#align coprod.inl_map coprod.inl_map\n\n",
 "inl_desc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n-- The simp linter says simp can prove the reassoc version of this lemma.\n@[reassoc.1, simp]\ntheorem coprod.inl_desc {W X Y : C} [has_binary_coproduct X Y] (f : «expr ⟶ » X W) (g : «expr ⟶ » Y W) :\n    «expr ≫ » coprod.inl (coprod.desc f g) = f :=\n  colimit.ι_desc _ _\n#align coprod.inl_desc coprod.inl_desc\n\n",
 "hom_ext":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⨿ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[ext]\ntheorem coprod.hom_ext {W X Y : C} [has_binary_coproduct X Y] {f g : «expr ⟶ » («expr ⨿ » X Y) W}\n    (h₁ : «expr ≫ » coprod.inl f = «expr ≫ » coprod.inl g) (h₂ : «expr ≫ » coprod.inr f = «expr ≫ » coprod.inr g) :\n    f = g :=\n  binary_cofan.is_colimit.hom_ext (colimit.is_colimit _) h₁ h₂\n#align coprod.hom_ext coprod.hom_ext\n\n",
 "has_binary_products_of_has_limit_pair":
 "/-- If `C` has all limits of diagrams `pair X Y`, then it has all binary products -/\ntheorem has_binary_products_of_has_limit_pair [∀ {X Y : C}, has_limit (pair X Y)] : has_binary_products C :=\n  { has_limit := fun F => has_limit_of_iso (diagram_iso_pair F).symm }\n#align has_binary_products_of_has_limit_pair has_binary_products_of_has_limit_pair\n\n",
 "has_binary_coproducts_of_has_colimit_pair":
 "/-- If `C` has all colimits of diagrams `pair X Y`, then it has all binary coproducts -/\ntheorem has_binary_coproducts_of_has_colimit_pair [∀ {X Y : C}, has_colimit (pair X Y)] : has_binary_coproducts C :=\n  { has_colimit := fun F => has_colimit_of_iso (diagram_iso_pair F) }\n#align has_binary_coproducts_of_has_colimit_pair has_binary_coproducts_of_has_colimit_pair\n\n",
 "equiv_bool_symm_apply_tt":
 "@[simp]\ntheorem walking_pair.equiv_bool_symm_apply_tt : walking_pair.equiv_bool.symm true = left :=\n  rfl\n#align walking_pair.equiv_bool_symm_apply_tt walking_pair.equiv_bool_symm_apply_tt\n\n",
 "equiv_bool_symm_apply_ff":
 "@[simp]\ntheorem walking_pair.equiv_bool_symm_apply_ff : walking_pair.equiv_bool.symm false = right :=\n  rfl\n#align walking_pair.equiv_bool_symm_apply_ff walking_pair.equiv_bool_symm_apply_ff\n\n",
 "equiv_bool_apply_right":
 "@[simp]\ntheorem walking_pair.equiv_bool_apply_right : walking_pair.equiv_bool right = ff :=\n  rfl\n#align walking_pair.equiv_bool_apply_right walking_pair.equiv_bool_apply_right\n\n",
 "equiv_bool_apply_left":
 "-- to match equiv.sum_equiv_sigma_bool\n@[simp]\ntheorem walking_pair.equiv_bool_apply_left : walking_pair.equiv_bool left = tt :=\n  rfl\n#align walking_pair.equiv_bool_apply_left walking_pair.equiv_bool_apply_left\n\n",
 "diag_map_fst_snd_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⨯ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem prod.diag_map_fst_snd_comp [has_limits_of_shape (discrete walking_pair) C] {X X' Y Y' : C} (g : «expr ⟶ » X Y)\n    (g' : «expr ⟶ » X' Y') :\n    «expr ≫ » (diag («expr ⨯ » X X')) (prod.map («expr ≫ » prod.fst g) («expr ≫ » prod.snd g')) = prod.map g g' := by\n  simp\n#align prod.diag_map_fst_snd_comp prod.diag_map_fst_snd_comp\n\n",
 "diag_map_fst_snd":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⨯ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⨯ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⨯ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⨯ » -/\n@[simp, reassoc.1]\ntheorem prod.diag_map_fst_snd {X Y : C} [has_binary_product X Y] [has_binary_product («expr ⨯ » X Y) («expr ⨯ » X Y)] :\n    «expr ≫ » (diag («expr ⨯ » X Y)) (prod.map prod.fst prod.snd) = («expr𝟙») («expr ⨯ » X Y) := by simp\n#align prod.diag_map_fst_snd prod.diag_map_fst_snd\n\n",
 "diag_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem prod.diag_map {X Y : C} (f : «expr ⟶ » X Y) [has_binary_product X X] [has_binary_product Y Y] :\n    «expr ≫ » (diag X) (prod.map f f) = «expr ≫ » f (diag Y) := by simp\n#align prod.diag_map prod.diag_map\n\n",
 "diag_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem coprod.diag_comp {X Y : C} [has_binary_coproduct X X] (f : «expr ⟶ » X Y) :\n    «expr ≫ » (codiag X) f = coprod.desc f f := by simp\n#align coprod.diag_comp coprod.diag_comp\n\n",
 "desc_inl_inr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⨿ » -/\n@[simp]\ntheorem coprod.desc_inl_inr {X Y : C} [has_binary_coproduct X Y] :\n    coprod.desc coprod.inl coprod.inr = («expr𝟙») («expr ⨿ » X Y) := by ext <;> simp\n#align coprod.desc_inl_inr coprod.desc_inl_inr\n\n",
 "desc_comp_inl_comp_inr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp]\ntheorem coprod.desc_comp_inl_comp_inr {W X Y Z : C} [has_binary_coproduct W Y] [has_binary_coproduct X Z]\n    (g : «expr ⟶ » W X) (g' : «expr ⟶ » Y Z) :\n    coprod.desc («expr ≫ » g coprod.inl) («expr ≫ » g' coprod.inr) = coprod.map g g' :=\n  by\n  rw [← coprod.map_desc]\n  simp\n#align coprod.desc_comp_inl_comp_inr coprod.desc_comp_inl_comp_inr\n\n",
 "desc_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem coprod.desc_comp {V W X Y : C} [has_binary_coproduct X Y] (f : «expr ⟶ » V W) (g : «expr ⟶ » X V)\n    (h : «expr ⟶ » Y V) : «expr ≫ » (coprod.desc g h) f = coprod.desc («expr ≫ » g f) («expr ≫ » h f) := by ext <;> simp\n#align coprod.desc_comp coprod.desc_comp\n\n",
 "coprod_comparison_natural":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/-- Naturality of the coprod_comparison morphism in both arguments. -/\n@[reassoc.1]\ntheorem coprod_comparison_natural (f : «expr ⟶ » A A') (g : «expr ⟶ » B B') :\n    «expr ≫ » (coprod_comparison F A B) (F.map (coprod.map f g)) =\n      «expr ≫ » (coprod.map (F.map f) (F.map g)) (coprod_comparison F A' B') :=\n  by\n  rw [coprod_comparison, coprod_comparison, coprod.map_desc, ← F.map_comp, ← F.map_comp, coprod.desc_comp, ← F.map_comp,\n    coprod.inl_map, ← F.map_comp, coprod.inr_map]\n#align coprod_comparison_natural coprod_comparison_natural\n\n",
 "coprod_comparison_inv_natural":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/-- If the coproduct comparison morphism is an iso, its inverse is natural. -/\n@[reassoc.1]\ntheorem coprod_comparison_inv_natural (f : «expr ⟶ » A A') (g : «expr ⟶ » B B') [IsIso (coprod_comparison F A B)]\n    [IsIso (coprod_comparison F A' B')] :\n    «expr ≫ » (inv (coprod_comparison F A B)) (coprod.map (F.map f) (F.map g)) =\n      «expr ≫ » (F.map (coprod.map f g)) (inv (coprod_comparison F A' B')) :=\n  by rw [is_iso.eq_comp_inv, category.assoc, is_iso.inv_comp_eq, coprod_comparison_natural]\n#align coprod_comparison_inv_natural coprod_comparison_inv_natural\n\n",
 "coprod_comparison_inr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem coprod_comparison_inr : «expr ≫ » coprod.inr (coprod_comparison F A B) = F.map coprod.inr :=\n  coprod.inr_desc _ _\n#align coprod_comparison_inr coprod_comparison_inr\n\n",
 "coprod_comparison_inl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem coprod_comparison_inl : «expr ≫ » coprod.inl (coprod_comparison F A B) = F.map coprod.inl :=\n  coprod.inl_desc _ _\n#align coprod_comparison_inl coprod_comparison_inl\n\n",
 "comp_lift":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n-- Making the reassoc version of this a simp lemma seems to be more harmful than helpful.\n@[reassoc.1, simp]\ntheorem prod.comp_lift {V W X Y : C} [has_binary_product X Y] (f : «expr ⟶ » V W) (g : «expr ⟶ » W X)\n    (h : «expr ⟶ » W Y) : «expr ≫ » f (prod.lift g h) = prod.lift («expr ≫ » f g) («expr ≫ » f h) := by ext <;> simp\n#align prod.comp_lift prod.comp_lift\n\n",
 "comp_diag":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem prod.comp_diag {X Y : C} [has_binary_product Y Y] (f : «expr ⟶ » X Y) : «expr ≫ » f (diag Y) = prod.lift f f :=\n  by simp\n#align prod.comp_diag prod.comp_diag\n\n",
 "braid_natural":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/-- The braiding isomorphism can be passed through a map by swapping the order. -/\n@[reassoc.1]\ntheorem braid_natural [has_binary_products C] {W X Y Z : C} (f : «expr ⟶ » X Y) (g : «expr ⟶ » Z W) :\n    «expr ≫ » (prod.map f g) (prod.braiding _ _).hom = «expr ≫ » (prod.braiding _ _).hom (prod.map g f) := by simp\n#align braid_natural braid_natural\n\n",
 "associator_naturality":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem coprod.associator_naturality {X₁ X₂ X₃ Y₁ Y₂ Y₃ : C} (f₁ : «expr ⟶ » X₁ Y₁) (f₂ : «expr ⟶ » X₂ Y₂)\n    (f₃ : «expr ⟶ » X₃ Y₃) :\n    «expr ≫ » (coprod.map (coprod.map f₁ f₂) f₃) (coprod.associator Y₁ Y₂ Y₃).hom =\n      «expr ≫ » (coprod.associator X₁ X₂ X₃).hom (coprod.map f₁ (coprod.map f₂ f₃)) :=\n  by simp\n#align coprod.associator_naturality coprod.associator_naturality\n\n"}