{"π_app_right":
 "@[simp]\ntheorem binary_fan.π_app_right {X Y : C} (s : BinaryFan X Y) : s.π.app ⟨walking_pair.right⟩ = s.snd :=\n  rfl\n#align binary_fan.π_app_right binary_fan.π_app_right\n\n",
 "π_app_left":
 "@[simp]\ntheorem binary_fan.π_app_left {X Y : C} (s : BinaryFan X Y) : s.π.app ⟨walking_pair.left⟩ = s.fst :=\n  rfl\n#align binary_fan.π_app_left binary_fan.π_app_left\n\n",
 "ι_app_right":
 "@[simp]\ntheorem binary_cofan.ι_app_right {X Y : C} (s : BinaryCofan X Y) : s.ι.app ⟨walking_pair.right⟩ = s.inr :=\n  rfl\n#align binary_cofan.ι_app_right binary_cofan.ι_app_right\n\n",
 "ι_app_left":
 "@[simp]\ntheorem binary_cofan.ι_app_left {X Y : C} (s : BinaryCofan X Y) : s.ι.app ⟨walking_pair.left⟩ = s.inl :=\n  rfl\n#align binary_cofan.ι_app_left binary_cofan.ι_app_left\n\n",
 "triangle":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥_ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\ntheorem coprod.triangle (X Y : C) :\n    «expr ≫ » (coprod.associator X («expr⊥_ » C) Y).hom (coprod.map ((«expr𝟙») X) (coprod.leftUnitor Y).hom) =\n      coprod.map (coprod.rightUnitor X).hom ((«expr𝟙») Y) :=\n  by tidy\n#align coprod.triangle coprod.triangle\n\n",
 "symmetry'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⨿ » -/\n@[reassoc.1]\ntheorem coprod.symmetry' (P Q : C) :\n    «expr ≫ » (coprod.desc coprod.inr coprod.inl) (coprod.desc coprod.inr coprod.inl) = («expr𝟙») («expr ⨿ » P Q) :=\n  (coprod.braiding _ _).hom_inv_id\n#align coprod.symmetry' coprod.symmetry'\n\n",
 "symmetry":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/-- The braiding isomorphism is symmetric. -/\ntheorem coprod.symmetry (P Q : C) : «expr ≫ » (coprod.braiding P Q).hom (coprod.braiding Q P).hom = («expr𝟙») _ :=\n  coprod.symmetry' _ _\n#align coprod.symmetry coprod.symmetry\n\n",
 "swap_symm_apply_tt":
 "@[simp]\ntheorem walking_pair.swap_symm_apply_tt : WalkingPair.swap.symm left = right :=\n  rfl\n#align walking_pair.swap_symm_apply_tt walking_pair.swap_symm_apply_tt\n\n",
 "swap_symm_apply_ff":
 "@[simp]\ntheorem walking_pair.swap_symm_apply_ff : WalkingPair.swap.symm right = left :=\n  rfl\n#align walking_pair.swap_symm_apply_ff walking_pair.swap_symm_apply_ff\n\n",
 "swap_apply_right":
 "@[simp]\ntheorem walking_pair.swap_apply_right : WalkingPair.swap right = left :=\n  rfl\n#align walking_pair.swap_apply_right walking_pair.swap_apply_right\n\n",
 "swap_apply_left":
 "/-\nCopyright (c) 2019 Scott Morrison. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Scott Morrison, Bhavik Mehta\n-/\n@[simp]\ntheorem walking_pair.swap_apply_left : WalkingPair.swap left = right :=\n  rfl\n#align walking_pair.swap_apply_left walking_pair.swap_apply_left\n\n",
 "right_unitor_hom_naturality":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[reassoc.1]\ntheorem prod.right_unitor_hom_naturality [HasBinaryProducts C] (f : «expr ⟶ » X Y) :\n    «expr ≫ » (prod.map f ((«expr𝟙») _)) (prod.rightUnitor Y).hom = «expr ≫ » (prod.rightUnitor X).hom f :=\n  prod.map_fst _ _\n#align prod.right_unitor_hom_naturality prod.right_unitor_hom_naturality\n\n",
 "prod_right_unitor_inv_naturality":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[reassoc.1]\ntheorem prod_right_unitor_inv_naturality [HasBinaryProducts C] (f : «expr ⟶ » X Y) :\n    «expr ≫ » (prod.rightUnitor X).inv (prod.map f ((«expr𝟙») _)) = «expr ≫ » f (prod.rightUnitor Y).inv := by\n  rw [iso.inv_comp_eq, ← category.assoc, iso.eq_comp_inv, prod.right_unitor_hom_naturality]\n#align prod_right_unitor_inv_naturality prod_right_unitor_inv_naturality\n\n",
 "prod_comparison_snd":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem prod_comparison_snd : «expr ≫ » (prodComparison F A B) prod.snd = F.map prod.snd :=\n  prod.lift_snd _ _\n#align prod_comparison_snd prod_comparison_snd\n\n",
 "prod_comparison_natural":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/-- Naturality of the prod_comparison morphism in both arguments. -/\n@[reassoc.1]\ntheorem prod_comparison_natural (f : «expr ⟶ » A A') (g : «expr ⟶ » B B') :\n    «expr ≫ » (F.map (prod.map f g)) (prodComparison F A' B') =\n      «expr ≫ » (prodComparison F A B) (prod.map (F.map f) (F.map g)) :=\n  by\n  rw [prod_comparison, prod_comparison, prod.lift_map, ← F.map_comp, ← F.map_comp, prod.comp_lift, ← F.map_comp,\n    Prod.map_fst, ← F.map_comp, Prod.map_snd]\n#align prod_comparison_natural prod_comparison_natural\n\n",
 "prod_comparison_inv_natural":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/-- If the product comparison morphism is an iso, its inverse is natural. -/\n@[reassoc.1]\ntheorem prod_comparison_inv_natural (f : «expr ⟶ » A A') (g : «expr ⟶ » B B') [IsIso (prodComparison F A B)]\n    [IsIso (prodComparison F A' B')] :\n    «expr ≫ » (inv (prodComparison F A B)) (F.map (prod.map f g)) =\n      «expr ≫ » (prod.map (F.map f) (F.map g)) (inv (prodComparison F A' B')) :=\n  by rw [is_iso.eq_comp_inv, category.assoc, is_iso.inv_comp_eq, prod_comparison_natural]\n#align prod_comparison_inv_natural prod_comparison_inv_natural\n\n",
 "prod_comparison_fst":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem prod_comparison_fst : «expr ≫ » (prodComparison F A B) prod.fst = F.map prod.fst :=\n  prod.lift_fst _ _\n#align prod_comparison_fst prod_comparison_fst\n\n",
 "pentagon":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⨿ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⨿ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⨿ » -/\ntheorem coprod.pentagon (W X Y Z : C) :\n    «expr ≫ » (coprod.map (coprod.associator W X Y).hom ((«expr𝟙») Z))\n        («expr ≫ » (coprod.associator W («expr ⨿ » X Y) Z).hom\n          (coprod.map ((«expr𝟙») W) (coprod.associator X Y Z).hom)) =\n      «expr ≫ » (coprod.associator («expr ⨿ » W X) Y Z).hom (coprod.associator W X («expr ⨿ » Y Z)).hom :=\n  by simp\n#align coprod.pentagon coprod.pentagon\n\n",
 "pair_obj_right":
 "@[simp]\ntheorem pair_obj_right (X Y : C) : (pair X Y).obj ⟨right⟩ = Y :=\n  rfl\n#align pair_obj_right pair_obj_right\n\n",
 "pair_obj_left":
 "@[simp]\ntheorem pair_obj_left (X Y : C) : (pair X Y).obj ⟨left⟩ = X :=\n  rfl\n#align pair_obj_left pair_obj_left\n\n",
 "pair_function_right":
 "@[simp]\ntheorem pair_function_right (X Y : C) : pairFunction X Y right = Y :=\n  rfl\n#align pair_function_right pair_function_right\n\n",
 "pair_function_left":
 "@[simp]\ntheorem pair_function_left (X Y : C) : pairFunction X Y left = X :=\n  rfl\n#align pair_function_left pair_function_left\n\n",
 "mk_snd":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n@[simp]\ntheorem binary_fan.mk_snd {P : C} (π₁ : «expr ⟶ » P X) (π₂ : «expr ⟶ » P Y) : (BinaryFan.mk π₁ π₂).snd = π₂ :=\n  rfl\n#align binary_fan.mk_snd binary_fan.mk_snd\n\n",
 "mk_inr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n@[simp]\ntheorem binary_cofan.mk_inr {P : C} (ι₁ : «expr ⟶ » X P) (ι₂ : «expr ⟶ » Y P) : (BinaryCofan.mk ι₁ ι₂).inr = ι₂ :=\n  rfl\n#align binary_cofan.mk_inr binary_cofan.mk_inr\n\n",
 "mk_inl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n@[simp]\ntheorem binary_cofan.mk_inl {P : C} (ι₁ : «expr ⟶ » X P) (ι₂ : «expr ⟶ » Y P) : (BinaryCofan.mk ι₁ ι₂).inl = ι₁ :=\n  rfl\n#align binary_cofan.mk_inl binary_cofan.mk_inl\n\n",
 "mk_fst":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n@[simp]\ntheorem binary_fan.mk_fst {P : C} (π₁ : «expr ⟶ » P X) (π₂ : «expr ⟶ » P Y) : (BinaryFan.mk π₁ π₂).fst = π₁ :=\n  rfl\n#align binary_fan.mk_fst binary_fan.mk_fst\n\n",
 "map_swap":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n-- I don't think it's a good idea to make any of the following three simp lemmas.\n@[reassoc.1]\ntheorem coprod.map_swap {A B X Y : C} (f : «expr ⟶ » A B) (g : «expr ⟶ » X Y)\n    [HasColimitsOfShape (Discrete WalkingPair) C] :\n    «expr ≫ » (coprod.map ((«expr𝟙») X) f) (coprod.map g ((«expr𝟙») B)) =\n      «expr ≫ » (coprod.map g ((«expr𝟙») A)) (coprod.map ((«expr𝟙») Y) f) :=\n  by simp\n#align coprod.map_swap coprod.map_swap\n\n",
 "map_snd":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n#print Prod.map_snd /-\n@[simp, reassoc.1]\ntheorem Prod.map_snd {W X Y Z : C} [HasBinaryProduct W X] [HasBinaryProduct Y Z] (f : «expr ⟶ » W Y)\n    (g : «expr ⟶ » X Z) : «expr ≫ » (prod.map f g) prod.snd = «expr ≫ » prod.snd g :=\n  limMap_π _ _\n#align prod.map_snd Prod.map_snd\n-/\n\n",
 "map_pair_right":
 "@[simp]\ntheorem map_pair_right : (mapPair f g).app ⟨right⟩ = g :=\n  rfl\n#align map_pair_right map_pair_right\n\n",
 "map_pair_left":
 "@[simp]\ntheorem map_pair_left : (mapPair f g).app ⟨left⟩ = f :=\n  rfl\n#align map_pair_left map_pair_left\n\n",
 "map_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n-- We take the right hand side here to be simp normal form, as this way composition lemmas for\n-- `f ≫ h` and `g ≫ k` can fire (eg `id_comp`) , while `inl_map` and `inr_map` can still work just\n-- as well.\n@[simp, reassoc.1]\ntheorem coprod.map_map {A₁ A₂ A₃ B₁ B₂ B₃ : C} [HasBinaryCoproduct A₁ B₁] [HasBinaryCoproduct A₂ B₂]\n    [HasBinaryCoproduct A₃ B₃] (f : «expr ⟶ » A₁ A₂) (g : «expr ⟶ » B₁ B₂) (h : «expr ⟶ » A₂ A₃) (k : «expr ⟶ » B₂ B₃) :\n    «expr ≫ » (coprod.map f g) (coprod.map h k) = coprod.map («expr ≫ » f h) («expr ≫ » g k) := by ext <;> simp\n#align coprod.map_map coprod.map_map\n\n",
 "map_inr_inv_coprod_comparison":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[reassoc.1]\ntheorem map_inr_inv_coprod_comparison [IsIso (coprodComparison F A B)] :\n    «expr ≫ » (F.map coprod.inr) (inv (coprodComparison F A B)) = coprod.inr := by simp [is_iso.inv_comp_eq]\n#align map_inr_inv_coprod_comparison map_inr_inv_coprod_comparison\n\n",
 "map_inl_inv_coprod_comparison":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[reassoc.1]\ntheorem map_inl_inv_coprod_comparison [IsIso (coprodComparison F A B)] :\n    «expr ≫ » (F.map coprod.inl) (inv (coprodComparison F A B)) = coprod.inl := by simp [is_iso.inv_comp_eq]\n#align map_inl_inv_coprod_comparison map_inl_inv_coprod_comparison\n\n",
 "map_inl_inr_codiag":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⨿ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⨿ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⨿ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⨿ » -/\n-- The simp linter says simp can prove the reassoc version of this lemma.\n@[reassoc.1, simp]\ntheorem coprod.map_inl_inr_codiag {X Y : C} [HasBinaryCoproduct X Y]\n    [HasBinaryCoproduct («expr ⨿ » X Y) («expr ⨿ » X Y)] :\n    «expr ≫ » (coprod.map coprod.inl coprod.inr) (codiag («expr ⨿ » X Y)) = («expr𝟙») («expr ⨿ » X Y) := by simp\n#align coprod.map_inl_inr_codiag coprod.map_inl_inr_codiag\n\n",
 "map_id_id":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n@[simp]\ntheorem coprod.map_id_id {X Y : C} [HasBinaryCoproduct X Y] : coprod.map ((«expr𝟙») X) ((«expr𝟙») Y) = («expr𝟙») _ := by\n  ext <;> simp\n#align coprod.map_id_id coprod.map_id_id\n\n",
 "map_id_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n@[reassoc.1]\ntheorem coprod.map_id_comp {X Y Z W : C} (f : «expr ⟶ » X Y) (g : «expr ⟶ » Y Z) [HasBinaryCoproduct W X]\n    [HasBinaryCoproduct W Y] [HasBinaryCoproduct W Z] :\n    coprod.map ((«expr𝟙») W) («expr ≫ » f g) = «expr ≫ » (coprod.map ((«expr𝟙») W) f) (coprod.map ((«expr𝟙») W) g) := by\n  simp\n#align coprod.map_id_comp coprod.map_id_comp\n\n",
 "map_fst":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n#print Prod.map_fst /-\n@[simp, reassoc.1]\ntheorem Prod.map_fst {W X Y Z : C} [HasBinaryProduct W X] [HasBinaryProduct Y Z] (f : «expr ⟶ » W Y)\n    (g : «expr ⟶ » X Z) : «expr ≫ » (prod.map f g) prod.fst = «expr ≫ » prod.fst f :=\n  limMap_π _ _\n#align prod.map_fst Prod.map_fst\n-/\n\n",
 "map_desc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n-- The simp linter says simp can prove the reassoc version of this lemma.\n@[reassoc.1, simp]\ntheorem coprod.map_desc {S T U V W : C} [HasBinaryCoproduct U W] [HasBinaryCoproduct T V] (f : «expr ⟶ » U S)\n    (g : «expr ⟶ » W S) (h : «expr ⟶ » T U) (k : «expr ⟶ » V W) :\n    «expr ≫ » (coprod.map h k) (coprod.desc f g) = coprod.desc («expr ≫ » h f) («expr ≫ » k g) := by ext <;> simp\n#align coprod.map_desc coprod.map_desc\n\n",
 "map_comp_inl_inr_codiag":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⨿ » -/\n-- The simp linter says simp can prove the reassoc version of this lemma.\n@[reassoc.1, simp]\ntheorem coprod.map_comp_inl_inr_codiag [HasColimitsOfShape (Discrete WalkingPair) C] {X X' Y Y' : C} (g : «expr ⟶ » X Y)\n    (g' : «expr ⟶ » X' Y') :\n    «expr ≫ » (coprod.map («expr ≫ » g coprod.inl) («expr ≫ » g' coprod.inr)) (codiag («expr ⨿ » Y Y')) =\n      coprod.map g g' :=\n  by simp\n#align coprod.map_comp_inl_inr_codiag coprod.map_comp_inl_inr_codiag\n\n",
 "map_comp_id":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n@[reassoc.1]\ntheorem coprod.map_comp_id {X Y Z W : C} (f : «expr ⟶ » X Y) (g : «expr ⟶ » Y Z) [HasBinaryCoproduct Z W]\n    [HasBinaryCoproduct Y W] [HasBinaryCoproduct X W] :\n    coprod.map («expr ≫ » f g) ((«expr𝟙») W) = «expr ≫ » (coprod.map f ((«expr𝟙») W)) (coprod.map g ((«expr𝟙») W)) := by\n  simp\n#align coprod.map_comp_id coprod.map_comp_id\n\n",
 "map_codiag":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n-- The simp linter says simp can prove the reassoc version of this lemma.\n@[reassoc.1, simp]\ntheorem coprod.map_codiag {X Y : C} (f : «expr ⟶ » X Y) [HasBinaryCoproduct X X] [HasBinaryCoproduct Y Y] :\n    «expr ≫ » (coprod.map f f) (codiag Y) = «expr ≫ » (codiag X) f := by simp\n#align coprod.map_codiag coprod.map_codiag\n\n",
 "lift_snd":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem prod.lift_snd {W X Y : C} [HasBinaryProduct X Y] (f : «expr ⟶ » W X) (g : «expr ⟶ » W Y) :\n    «expr ≫ » (prod.lift f g) prod.snd = g :=\n  limit.lift_π _ _\n#align prod.lift_snd prod.lift_snd\n\n",
 "lift_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem prod.lift_map {V W X Y Z : C} [HasBinaryProduct W X] [HasBinaryProduct Y Z] (f : «expr ⟶ » V W)\n    (g : «expr ⟶ » V X) (h : «expr ⟶ » W Y) (k : «expr ⟶ » X Z) :\n    «expr ≫ » (prod.lift f g) (prod.map h k) = prod.lift («expr ≫ » f h) («expr ≫ » g k) := by ext <;> simp\n#align prod.lift_map prod.lift_map\n\n",
 "lift_fst_snd":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⨯ » -/\n@[simp]\ntheorem prod.lift_fst_snd {X Y : C} [HasBinaryProduct X Y] : prod.lift prod.fst prod.snd = («expr𝟙») («expr ⨯ » X Y) :=\n  by ext <;> simp\n#align prod.lift_fst_snd prod.lift_fst_snd\n\n",
 "lift_fst_comp_snd_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp]\ntheorem prod.lift_fst_comp_snd_comp {W X Y Z : C} [HasBinaryProduct W Y] [HasBinaryProduct X Z] (g : «expr ⟶ » W X)\n    (g' : «expr ⟶ » Y Z) : prod.lift («expr ≫ » prod.fst g) («expr ≫ » prod.snd g') = prod.map g g' :=\n  by\n  rw [← prod.lift_map]\n  simp\n#align prod.lift_fst_comp_snd_comp prod.lift_fst_comp_snd_comp\n\n",
 "lift_fst":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem prod.lift_fst {W X Y : C} [HasBinaryProduct X Y] (f : «expr ⟶ » W X) (g : «expr ⟶ » W Y) :\n    «expr ≫ » (prod.lift f g) prod.fst = f :=\n  limit.lift_π _ _\n#align prod.lift_fst prod.lift_fst\n\n",
 "left_unitor_inv_naturality":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[reassoc.1]\ntheorem prod.left_unitor_inv_naturality [HasBinaryProducts C] (f : «expr ⟶ » X Y) :\n    «expr ≫ » (prod.leftUnitor X).inv (prod.map ((«expr𝟙») _) f) = «expr ≫ » f (prod.leftUnitor Y).inv := by\n  rw [iso.inv_comp_eq, ← category.assoc, iso.eq_comp_inv, prod.left_unitor_hom_naturality]\n#align prod.left_unitor_inv_naturality prod.left_unitor_inv_naturality\n\n",
 "left_unitor_hom_naturality":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[reassoc.1]\ntheorem prod.left_unitor_hom_naturality [HasBinaryProducts C] (f : «expr ⟶ » X Y) :\n    «expr ≫ » (prod.map ((«expr𝟙») _) f) (prod.leftUnitor Y).hom = «expr ≫ » (prod.leftUnitor X).hom f :=\n  prod.map_snd _ _\n#align prod.left_unitor_hom_naturality prod.left_unitor_hom_naturality\n\n",
 "is_limit_iff_is_iso_snd":
 "theorem binary_fan.is_limit_iff_is_iso_snd {X Y : C} (h : IsTerminal X) (c : BinaryFan X Y) :\n    Nonempty (IsLimit c) ↔ IsIso c.snd :=\n  by\n  refine' iff.trans _ (binary_fan.is_limit_iff_is_iso_fst h (binary_fan.mk c.snd c.fst))\n  exact\n    ⟨fun h => ⟨binary_fan.is_limit_flip h.some⟩, fun h =>\n      ⟨(binary_fan.is_limit_flip h.some).of_iso_limit (iso_binary_fan_mk c).symm⟩⟩\n#align binary_fan.is_limit_iff_is_iso_snd binary_fan.is_limit_iff_is_iso_snd\n\n",
 "is_limit_iff_is_iso_fst":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem binary_fan.is_limit_iff_is_iso_fst {X Y : C} (h : IsTerminal Y) (c : BinaryFan X Y) :\n    Nonempty (IsLimit c) ↔ IsIso c.fst := by\n  constructor\n  · rintro ⟨H⟩\n    obtain ⟨l, hl, -⟩ := binary_fan.is_limit.lift' H ((«expr𝟙») X) (h.from X)\n    exact\n      ⟨⟨l, binary_fan.is_limit.hom_ext H (by simpa [hl, -category.comp_id] using category.comp_id _) (h.hom_ext _ _),\n          hl⟩⟩\n  · intro\n    exact\n      ⟨binary_fan.is_limit.mk _ (fun _ f _ => «expr ≫ » f (inv c.fst)) (fun _ _ _ => by simp)\n          (fun _ _ _ => h.hom_ext _ _) fun _ _ _ _ e _ => by simp [← e]⟩\n#align binary_fan.is_limit_iff_is_iso_fst binary_fan.is_limit_iff_is_iso_fst\n\n",
 "is_colimit_iff_is_iso_inr":
 "theorem binary_cofan.is_colimit_iff_is_iso_inr {X Y : C} (h : IsInitial X) (c : BinaryCofan X Y) :\n    Nonempty (IsColimit c) ↔ IsIso c.inr :=\n  by\n  refine' iff.trans _ (binary_cofan.is_colimit_iff_is_iso_inl h (binary_cofan.mk c.inr c.inl))\n  exact\n    ⟨fun h => ⟨binary_cofan.is_colimit_flip h.some⟩, fun h =>\n      ⟨(binary_cofan.is_colimit_flip h.some).of_iso_colimit (iso_binary_cofan_mk c).symm⟩⟩\n#align binary_cofan.is_colimit_iff_is_iso_inr binary_cofan.is_colimit_iff_is_iso_inr\n\n",
 "is_colimit_iff_is_iso_inl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem binary_cofan.is_colimit_iff_is_iso_inl {X Y : C} (h : IsInitial Y) (c : BinaryCofan X Y) :\n    Nonempty (IsColimit c) ↔ IsIso c.inl := by\n  constructor\n  · rintro ⟨H⟩\n    obtain ⟨l, hl, -⟩ := binary_cofan.is_colimit.desc' H ((«expr𝟙») X) (h.to X)\n    exact ⟨⟨l, hl, binary_cofan.is_colimit.hom_ext H (by simp [reassoc_of hl]) (h.hom_ext _ _)⟩⟩\n  · intro\n    exact\n      ⟨binary_cofan.is_colimit.mk _ (fun _ f _ => «expr ≫ » (inv c.inl) f) (fun _ _ _ => is_iso.hom_inv_id_assoc _ _)\n          (fun _ _ _ => h.hom_ext _ _) fun _ _ _ _ e _ => (is_iso.eq_inv_comp _).mpr e⟩\n#align binary_cofan.is_colimit_iff_is_iso_inl binary_cofan.is_colimit_iff_is_iso_inl\n\n",
 "inv_prod_comparison_map_snd":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[reassoc.1]\ntheorem inv_prod_comparison_map_snd [IsIso (prodComparison F A B)] :\n    «expr ≫ » (inv (prodComparison F A B)) (F.map prod.snd) = prod.snd := by simp [is_iso.inv_comp_eq]\n#align inv_prod_comparison_map_snd inv_prod_comparison_map_snd\n\n",
 "inv_prod_comparison_map_fst":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[reassoc.1]\ntheorem inv_prod_comparison_map_fst [IsIso (prodComparison F A B)] :\n    «expr ≫ » (inv (prodComparison F A B)) (F.map prod.fst) = prod.fst := by simp [is_iso.inv_comp_eq]\n#align inv_prod_comparison_map_fst inv_prod_comparison_map_fst\n\n",
 "inr_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem coprod.inr_map {W X Y Z : C} [HasBinaryCoproduct W X] [HasBinaryCoproduct Y Z] (f : «expr ⟶ » W Y)\n    (g : «expr ⟶ » X Z) : «expr ≫ » coprod.inr (coprod.map f g) = «expr ≫ » g coprod.inr :=\n  ι_colimMap _ _\n#align coprod.inr_map coprod.inr_map\n\n",
 "inr_desc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n-- The simp linter says simp can prove the reassoc version of this lemma.\n@[reassoc.1, simp]\ntheorem coprod.inr_desc {W X Y : C} [HasBinaryCoproduct X Y] (f : «expr ⟶ » X W) (g : «expr ⟶ » Y W) :\n    «expr ≫ » coprod.inr (coprod.desc f g) = g :=\n  colimit.ι_desc _ _\n#align coprod.inr_desc coprod.inr_desc\n\n",
 "inl_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem coprod.inl_map {W X Y Z : C} [HasBinaryCoproduct W X] [HasBinaryCoproduct Y Z] (f : «expr ⟶ » W Y)\n    (g : «expr ⟶ » X Z) : «expr ≫ » coprod.inl (coprod.map f g) = «expr ≫ » f coprod.inl :=\n  ι_colimMap _ _\n#align coprod.inl_map coprod.inl_map\n\n",
 "inl_desc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n-- The simp linter says simp can prove the reassoc version of this lemma.\n@[reassoc.1, simp]\ntheorem coprod.inl_desc {W X Y : C} [HasBinaryCoproduct X Y] (f : «expr ⟶ » X W) (g : «expr ⟶ » Y W) :\n    «expr ≫ » coprod.inl (coprod.desc f g) = f :=\n  colimit.ι_desc _ _\n#align coprod.inl_desc coprod.inl_desc\n\n",
 "hom_ext":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⨿ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[ext]\ntheorem coprod.hom_ext {W X Y : C} [HasBinaryCoproduct X Y] {f g : «expr ⟶ » («expr ⨿ » X Y) W}\n    (h₁ : «expr ≫ » coprod.inl f = «expr ≫ » coprod.inl g) (h₂ : «expr ≫ » coprod.inr f = «expr ≫ » coprod.inr g) :\n    f = g :=\n  BinaryCofan.IsColimit.hom_ext (colimit.isColimit _) h₁ h₂\n#align coprod.hom_ext coprod.hom_ext\n\n",
 "has_binary_products_of_has_limit_pair":
 "/-- If `C` has all limits of diagrams `pair X Y`, then it has all binary products -/\ntheorem has_binary_products_of_has_limit_pair [∀ {X Y : C}, HasLimit (pair X Y)] : HasBinaryProducts C :=\n  { has_limit := fun F => hasLimitOfIso (diagramIsoPair F).symm }\n#align has_binary_products_of_has_limit_pair has_binary_products_of_has_limit_pair\n\n",
 "has_binary_coproducts_of_has_colimit_pair":
 "/-- If `C` has all colimits of diagrams `pair X Y`, then it has all binary coproducts -/\ntheorem has_binary_coproducts_of_has_colimit_pair [∀ {X Y : C}, HasColimit (pair X Y)] : HasBinaryCoproducts C :=\n  { has_colimit := fun F => hasColimitOfIso (diagramIsoPair F) }\n#align has_binary_coproducts_of_has_colimit_pair has_binary_coproducts_of_has_colimit_pair\n\n",
 "equiv_bool_symm_apply_tt":
 "@[simp]\ntheorem walking_pair.equiv_bool_symm_apply_tt : WalkingPair.equivBool.symm true = left :=\n  rfl\n#align walking_pair.equiv_bool_symm_apply_tt walking_pair.equiv_bool_symm_apply_tt\n\n",
 "equiv_bool_symm_apply_ff":
 "@[simp]\ntheorem walking_pair.equiv_bool_symm_apply_ff : WalkingPair.equivBool.symm false = right :=\n  rfl\n#align walking_pair.equiv_bool_symm_apply_ff walking_pair.equiv_bool_symm_apply_ff\n\n",
 "equiv_bool_apply_right":
 "@[simp]\ntheorem walking_pair.equiv_bool_apply_right : WalkingPair.equivBool right = false :=\n  rfl\n#align walking_pair.equiv_bool_apply_right walking_pair.equiv_bool_apply_right\n\n",
 "equiv_bool_apply_left":
 "-- to match equiv.sum_equiv_sigma_bool\n@[simp]\ntheorem walking_pair.equiv_bool_apply_left : WalkingPair.equivBool left = true :=\n  rfl\n#align walking_pair.equiv_bool_apply_left walking_pair.equiv_bool_apply_left\n\n",
 "diag_map_fst_snd_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⨯ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem prod.diag_map_fst_snd_comp [HasLimitsOfShape (Discrete WalkingPair) C] {X X' Y Y' : C} (g : «expr ⟶ » X Y)\n    (g' : «expr ⟶ » X' Y') :\n    «expr ≫ » (diag («expr ⨯ » X X')) (prod.map («expr ≫ » prod.fst g) («expr ≫ » prod.snd g')) = prod.map g g' := by\n  simp\n#align prod.diag_map_fst_snd_comp prod.diag_map_fst_snd_comp\n\n",
 "diag_map_fst_snd":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⨯ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⨯ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⨯ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⨯ » -/\n@[simp, reassoc.1]\ntheorem prod.diag_map_fst_snd {X Y : C} [HasBinaryProduct X Y] [HasBinaryProduct («expr ⨯ » X Y) («expr ⨯ » X Y)] :\n    «expr ≫ » (diag («expr ⨯ » X Y)) (prod.map prod.fst prod.snd) = («expr𝟙») («expr ⨯ » X Y) := by simp\n#align prod.diag_map_fst_snd prod.diag_map_fst_snd\n\n",
 "diag_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem prod.diag_map {X Y : C} (f : «expr ⟶ » X Y) [HasBinaryProduct X X] [HasBinaryProduct Y Y] :\n    «expr ≫ » (diag X) (prod.map f f) = «expr ≫ » f (diag Y) := by simp\n#align prod.diag_map prod.diag_map\n\n",
 "diag_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem coprod.diag_comp {X Y : C} [HasBinaryCoproduct X X] (f : «expr ⟶ » X Y) :\n    «expr ≫ » (codiag X) f = coprod.desc f f := by simp\n#align coprod.diag_comp coprod.diag_comp\n\n",
 "desc_inl_inr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⨿ » -/\n@[simp]\ntheorem coprod.desc_inl_inr {X Y : C} [HasBinaryCoproduct X Y] :\n    coprod.desc coprod.inl coprod.inr = («expr𝟙») («expr ⨿ » X Y) := by ext <;> simp\n#align coprod.desc_inl_inr coprod.desc_inl_inr\n\n",
 "desc_comp_inl_comp_inr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp]\ntheorem coprod.desc_comp_inl_comp_inr {W X Y Z : C} [HasBinaryCoproduct W Y] [HasBinaryCoproduct X Z]\n    (g : «expr ⟶ » W X) (g' : «expr ⟶ » Y Z) :\n    coprod.desc («expr ≫ » g coprod.inl) («expr ≫ » g' coprod.inr) = coprod.map g g' :=\n  by\n  rw [← coprod.map_desc]\n  simp\n#align coprod.desc_comp_inl_comp_inr coprod.desc_comp_inl_comp_inr\n\n",
 "desc_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem coprod.desc_comp {V W X Y : C} [HasBinaryCoproduct X Y] (f : «expr ⟶ » V W) (g : «expr ⟶ » X V)\n    (h : «expr ⟶ » Y V) : «expr ≫ » (coprod.desc g h) f = coprod.desc («expr ≫ » g f) («expr ≫ » h f) := by ext <;> simp\n#align coprod.desc_comp coprod.desc_comp\n\n",
 "coprod_comparison_natural":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/-- Naturality of the coprod_comparison morphism in both arguments. -/\n@[reassoc.1]\ntheorem coprod_comparison_natural (f : «expr ⟶ » A A') (g : «expr ⟶ » B B') :\n    «expr ≫ » (coprodComparison F A B) (F.map (coprod.map f g)) =\n      «expr ≫ » (coprod.map (F.map f) (F.map g)) (coprodComparison F A' B') :=\n  by\n  rw [coprod_comparison, coprod_comparison, coprod.map_desc, ← F.map_comp, ← F.map_comp, coprod.desc_comp, ← F.map_comp,\n    coprod.inl_map, ← F.map_comp, coprod.inr_map]\n#align coprod_comparison_natural coprod_comparison_natural\n\n",
 "coprod_comparison_inv_natural":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/-- If the coproduct comparison morphism is an iso, its inverse is natural. -/\n@[reassoc.1]\ntheorem coprod_comparison_inv_natural (f : «expr ⟶ » A A') (g : «expr ⟶ » B B') [IsIso (coprodComparison F A B)]\n    [IsIso (coprodComparison F A' B')] :\n    «expr ≫ » (inv (coprodComparison F A B)) (coprod.map (F.map f) (F.map g)) =\n      «expr ≫ » (F.map (coprod.map f g)) (inv (coprodComparison F A' B')) :=\n  by rw [is_iso.eq_comp_inv, category.assoc, is_iso.inv_comp_eq, coprod_comparison_natural]\n#align coprod_comparison_inv_natural coprod_comparison_inv_natural\n\n",
 "coprod_comparison_inr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem coprod_comparison_inr : «expr ≫ » coprod.inr (coprodComparison F A B) = F.map coprod.inr :=\n  coprod.inr_desc _ _\n#align coprod_comparison_inr coprod_comparison_inr\n\n",
 "coprod_comparison_inl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem coprod_comparison_inl : «expr ≫ » coprod.inl (coprodComparison F A B) = F.map coprod.inl :=\n  coprod.inl_desc _ _\n#align coprod_comparison_inl coprod_comparison_inl\n\n",
 "comp_lift":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n-- Making the reassoc version of this a simp lemma seems to be more harmful than helpful.\n@[reassoc.1, simp]\ntheorem prod.comp_lift {V W X Y : C} [HasBinaryProduct X Y] (f : «expr ⟶ » V W) (g : «expr ⟶ » W X)\n    (h : «expr ⟶ » W Y) : «expr ≫ » f (prod.lift g h) = prod.lift («expr ≫ » f g) («expr ≫ » f h) := by ext <;> simp\n#align prod.comp_lift prod.comp_lift\n\n",
 "comp_diag":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem prod.comp_diag {X Y : C} [HasBinaryProduct Y Y] (f : «expr ⟶ » X Y) : «expr ≫ » f (diag Y) = prod.lift f f := by\n  simp\n#align prod.comp_diag prod.comp_diag\n\n",
 "braid_natural":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/-- The braiding isomorphism can be passed through a map by swapping the order. -/\n@[reassoc.1]\ntheorem braid_natural [HasBinaryProducts C] {W X Y Z : C} (f : «expr ⟶ » X Y) (g : «expr ⟶ » Z W) :\n    «expr ≫ » (prod.map f g) (prod.braiding _ _).hom = «expr ≫ » (prod.braiding _ _).hom (prod.map g f) := by simp\n#align braid_natural braid_natural\n\n",
 "associator_naturality":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem coprod.associator_naturality {X₁ X₂ X₃ Y₁ Y₂ Y₃ : C} (f₁ : «expr ⟶ » X₁ Y₁) (f₂ : «expr ⟶ » X₂ Y₂)\n    (f₃ : «expr ⟶ » X₃ Y₃) :\n    «expr ≫ » (coprod.map (coprod.map f₁ f₂) f₃) (coprod.associator Y₁ Y₂ Y₃).hom =\n      «expr ≫ » (coprod.associator X₁ X₂ X₃).hom (coprod.map f₁ (coprod.map f₂ f₃)) :=\n  by simp\n#align coprod.associator_naturality coprod.associator_naturality\n\n"}