{"zigzag_of_eqv_gen_quot_rel":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\ntheorem zigzag_of_eqv_gen_quot_rel {F : «expr ⥤ » C D} {d : D} {f₁ f₂ : ΣX, «expr ⟶ » d (F.obj X)}\n    (t : EqvGen (Types.Quot.Rel.{v, v} («expr ⋙ » F (coyoneda.obj (op d)))) f₁ f₂) :\n    Zigzag (StructuredArrow.mk f₁.2) (StructuredArrow.mk f₂.2) :=\n  by\n  induction t\n  case rel x y r =>\n    obtain ⟨f, w⟩ := r\n    fconstructor\n    swap; fconstructor\n    left; fconstructor\n    exact structured_arrow.hom_mk f (by tidy)\n  case refl => fconstructor\n  case symm x y h ih =>\n    apply zigzag_symmetric\n    exact ih\n  case trans x y z h₁ h₂ ih₁ ih₂ =>\n    apply Relation.ReflTransGen.trans\n    exact ih₁; exact ih₂\n#align zigzag_of_eqv_gen_quot_rel zigzag_of_eqv_gen_quot_rel\n\n",
 "limit_pre_is_iso_aux":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\ntheorem limit_pre_is_iso_aux {t : Cone G} (P : IsLimit t) :\n    ((isLimitWhiskerEquiv F _).symm P).lift (t.whisker F) = («expr𝟙») t.X :=\n  by\n  dsimp [is_limit_whisker_equiv]\n  apply P.hom_ext\n  intro j\n  simp\n#align limit_pre_is_iso_aux limit_pre_is_iso_aux\n\n",
 "limit_cone_comp_aux":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n-- This would be true if we'd chosen `lift F Y` to be `lift F X`\n-- and `hom_to_lift F Y` to be `hom_to_lift F X ≫ f`.\n@[simp]\ntheorem limit_cone_comp_aux (s : Cone («expr ⋙ » F G)) (j : C) :\n    «expr ≫ » (s.π.app (lift F (F.obj j))) (G.map (homToLift F (F.obj j))) = s.π.app j :=\n  by\n  -- This point is that this would be true if we took `lift (F.obj j)` to just be `j`\n  -- and `hom_to_lift (F.obj j)` to be `𝟙 (F.obj j)`.\n  apply induction F fun X k => «expr ≫ » (s.π.app X) (G.map k) = (s.π.app j : _)\n  · intro j₁ j₂ k₁ k₂ f w h\n    rw [← s.w f]\n    rw [← w] at h\n    simpa using h\n  · intro j₁ j₂ k₁ k₂ f w h\n    rw [← s.w f] at h\n    rw [← w]\n    simpa using h\n  · exact s.w ((«expr𝟙») _)\n#align limit_cone_comp_aux limit_cone_comp_aux\n\n",
 "initial_of_final_op":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\ntheorem initial_of_final_op (F : «expr ⥤ » C D) [Final F.op] : Initial F :=\n  {\n    out := fun d =>\n      @isConnected_of_isConnected_op _ _ (isConnected_of_equivalent (costructuredArrowOpEquivalence F d).symm) }\n#align initial_of_final_op initial_of_final_op\n\n",
 "initial_of_adjunction":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊣ » -/\n/-- If a functor `L : C ⥤ D` is a left adjoint, it is initial. -/\ntheorem initial_of_adjunction {L : «expr ⥤ » C D} {R : «expr ⥤ » D C} (adj : «expr ⊣ » L R) : Initial L :=\n  {\n    out := fun d =>\n      let u : CostructuredArrow L d := CostructuredArrow.mk (adj.counit.app d)\n      @zigzag_isConnected _ _ ⟨u⟩ fun f g =>\n        Relation.ReflTransGen.trans\n          (Relation.ReflTransGen.single\n            (show Zag f u from or.inl ⟨CostructuredArrow.homMk (adj.hom_equiv f.left d f.hom) (by simp)⟩))\n          (Relation.ReflTransGen.single\n            (show Zag u g from or.inr ⟨CostructuredArrow.homMk (adj.hom_equiv g.left d g.hom) (by simp)⟩)) }\n#align initial_of_adjunction initial_of_adjunction\n\n",
 "has_limit_of_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/-- When `F` is initial, and `F ⋙ G` has a limit, then `G` has a limit also.\n\nWe can't make this an instance, because `F` is not determined by the goal.\n(Even if this weren't a problem, it would cause a loop with `comp_has_limit`.)\n-/\ntheorem has_limit_of_comp [HasLimit («expr ⋙ » F G)] : HasLimit G :=\n  HasLimit.mk (limitConeOfComp F (getLimitCone («expr ⋙ » F G)))\n#align has_limit_of_comp has_limit_of_comp\n\n",
 "has_colimit_of_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/-- When `F` is cofinal, and `F ⋙ G` has a colimit, then `G` has a colimit also.\n\nWe can't make this an instance, because `F` is not determined by the goal.\n(Even if this weren't a problem, it would cause a loop with `comp_has_colimit`.)\n-/\ntheorem has_colimit_of_comp [HasColimit («expr ⋙ » F G)] : HasColimit G :=\n  HasColimit.mk (colimitCoconeOfComp F (getColimitCocone («expr ⋙ » F G)))\n#align has_colimit_of_comp has_colimit_of_comp\n\n",
 "final_of_initial_op":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/-\nCopyright (c) 2020 Scott Morrison. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Scott Morrison\n-/\ntheorem final_of_initial_op (F : «expr ⥤ » C D) [Initial F.op] : Final F :=\n  {\n    out := fun d =>\n      @isConnected_of_isConnected_op _ _ (isConnected_of_equivalent (structuredArrowOpEquivalence F d).symm) }\n#align final_of_initial_op final_of_initial_op\n\n",
 "final_of_adjunction":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊣ » -/\n/-- If a functor `R : D ⥤ C` is a right adjoint, it is final. -/\ntheorem final_of_adjunction {L : «expr ⥤ » C D} {R : «expr ⥤ » D C} (adj : «expr ⊣ » L R) : Final R :=\n  {\n    out := fun c =>\n      let u : StructuredArrow c R := StructuredArrow.mk (adj.unit.app c)\n      @zigzag_isConnected _ _ ⟨u⟩ fun f g =>\n        Relation.ReflTransGen.trans\n          (Relation.ReflTransGen.single\n            (show Zag f u from or.inr ⟨StructuredArrow.homMk ((adj.hom_equiv c f.right).symm f.hom) (by simp)⟩))\n          (Relation.ReflTransGen.single\n            (show Zag u g from or.inl ⟨StructuredArrow.homMk ((adj.hom_equiv c g.right).symm g.hom) (by simp)⟩)) }\n#align final_of_adjunction final_of_adjunction\n\n",
 "colimit_pre_is_iso_aux":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\ntheorem colimit_pre_is_iso_aux {t : Cocone G} (P : IsColimit t) :\n    ((isColimitWhiskerEquiv F _).symm P).desc (t.whisker F) = («expr𝟙») t.X :=\n  by\n  dsimp [is_colimit_whisker_equiv]\n  apply P.hom_ext\n  intro j\n  dsimp; simp\n#align colimit_pre_is_iso_aux colimit_pre_is_iso_aux\n\n",
 "colimit_cocone_comp_aux":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n-- This would be true if we'd chosen `lift F X` to be `lift F Y`\n-- and `hom_to_lift F X` to be `f ≫ hom_to_lift F Y`.\n@[simp]\ntheorem colimit_cocone_comp_aux (s : Cocone («expr ⋙ » F G)) (j : C) :\n    «expr ≫ » (G.map (homToLift F (F.obj j))) (s.ι.app (lift F (F.obj j))) = s.ι.app j :=\n  by\n  -- This point is that this would be true if we took `lift (F.obj j)` to just be `j`\n  -- and `hom_to_lift (F.obj j)` to be `𝟙 (F.obj j)`.\n  apply induction F fun X k => «expr ≫ » (G.map k) (s.ι.app X) = (s.ι.app j : _)\n  · intro j₁ j₂ k₁ k₂ f w h\n    rw [← w]\n    rw [← s.w f] at h\n    simpa using h\n  · intro j₁ j₂ k₁ k₂ f w h\n    rw [← w] at h\n    rw [← s.w f]\n    simpa using h\n  · exact s.w ((«expr𝟙») _)\n#align colimit_cocone_comp_aux colimit_cocone_comp_aux\n\n",
 "cofinal_of_colimit_comp_coyoneda_iso_punit":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≅ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/-- If `colimit (F ⋙ coyoneda.obj (op d)) ≅ punit` for all `d : D`, then `F` is cofinal.\n-/\ntheorem cofinal_of_colimit_comp_coyoneda_iso_punit\n    (I : ∀ d, «expr ≅ » (colimit («expr ⋙ » F (coyoneda.obj (op d)))) PUnit) : Final F :=\n  ⟨fun d =>\n    by\n    have : Nonempty (structured_arrow d F) := by\n      have := (I d).inv PUnit.unit\n      obtain ⟨j, y, rfl⟩ := Limits.Types.jointly_surjective'.{v, v} this\n      exact ⟨structured_arrow.mk y⟩\n    apply zigzag_is_connected\n    rintro ⟨⟨⟨⟩⟩, X₁, f₁⟩ ⟨⟨⟨⟩⟩, X₂, f₂⟩\n    dsimp at *\n    let y₁ := colimit.ι («expr ⋙ » F (coyoneda.obj (op d))) X₁ f₁\n    let y₂ := colimit.ι («expr ⋙ » F (coyoneda.obj (op d))) X₂ f₂\n    have e : y₁ = y₂ := by\n      apply (I d).to_equiv.injective\n      ext\n    have t := Types.colimit_eq.{v, v} e\n    clear e y₁ y₂\n    exact zigzag_of_eqv_gen_quot_rel t⟩\n#align cofinal_of_colimit_comp_coyoneda_iso_punit cofinal_of_colimit_comp_coyoneda_iso_punit\n\n"}