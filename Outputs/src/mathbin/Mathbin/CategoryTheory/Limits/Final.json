{"zigzag_of_eqv_gen_quot_rel":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚•§ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚ü∂ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚ãô ¬ª -/\ntheorem zigzag_of_eqv_gen_quot_rel {F : ¬´expr ‚•§ ¬ª C D} {d : D} {f‚ÇÅ f‚ÇÇ : Œ£X, ¬´expr ‚ü∂ ¬ª d (F.obj X)}\n    (t : EqvGen (types.quot.rel.{v, v} (¬´expr ‚ãô ¬ª F (coyoneda.obj (op d)))) f‚ÇÅ f‚ÇÇ) :\n    zigzag (structured_arrow.mk f‚ÇÅ.2) (structured_arrow.mk f‚ÇÇ.2) :=\n  by\n  induction t\n  case rel x y r =>\n    obtain ‚ü®f, w‚ü© := r\n    fconstructor\n    swap; fconstructor\n    left; fconstructor\n    exact { right := f }\n  case refl => fconstructor\n  case symm x y h ih =>\n    apply zigzag_symmetric\n    exact ih\n  case trans x y z h‚ÇÅ h‚ÇÇ ih‚ÇÅ ih‚ÇÇ =>\n    apply relation.refl_trans_gen.trans\n    exact ih‚ÇÅ; exact ih‚ÇÇ\n#align zigzag_of_eqv_gen_quot_rel zigzag_of_eqv_gen_quot_rel\n\n",
 "limit_pre_is_iso_aux":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´exprùüô¬ª -/\ntheorem limit_pre_is_iso_aux {t : cone G} (P : is_limit t) :\n    ((is_limit_whisker_equiv F _).symm P).lift (t.whisker F) = (¬´exprùüô¬ª) t.X :=\n  by\n  dsimp [is_limit_whisker_equiv]\n  apply P.hom_ext\n  intro j\n  simp\n#align limit_pre_is_iso_aux limit_pre_is_iso_aux\n\n",
 "limit_cone_comp_aux":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚â´ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´exprùüô¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚ãô ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚â´ ¬ª -/\n-- This would be true if we'd chosen `lift F Y` to be `lift F X`\n-- and `hom_to_lift F Y` to be `hom_to_lift F X ‚â´ f`.\n@[simp]\ntheorem limit_cone_comp_aux (s : cone (¬´expr ‚ãô ¬ª F G)) (j : C) :\n    ¬´expr ‚â´ ¬ª (s.œÄ.app (lift F (F.obj j))) (G.map (hom_to_lift F (F.obj j))) = s.œÄ.app j :=\n  by\n  -- This point is that this would be true if we took `lift (F.obj j)` to just be `j`\n  -- and `hom_to_lift (F.obj j)` to be `ùüô (F.obj j)`.\n  apply induction F fun X k => ¬´expr ‚â´ ¬ª (s.œÄ.app X) (G.map k) = (s.œÄ.app j : _)\n  ¬∑ intro j‚ÇÅ j‚ÇÇ k‚ÇÅ k‚ÇÇ f w h\n    rw [‚Üê s.w f]\n    rw [‚Üê w] at h\n    simpa using h\n  ¬∑ intro j‚ÇÅ j‚ÇÇ k‚ÇÅ k‚ÇÇ f w h\n    rw [‚Üê s.w f] at h\n    rw [‚Üê w]\n    simpa using h\n  ¬∑ exact s.w ((¬´exprùüô¬ª) _)\n#align limit_cone_comp_aux limit_cone_comp_aux\n\n",
 "initial_of_final_op":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚•§ ¬ª -/\ntheorem initial_of_final_op (F : ¬´expr ‚•§ ¬ª C D) [final F.op] : initial F :=\n  {\n    out := fun d =>\n      @is_connected_of_is_connected_op _ _ (is_connected_of_equivalent (costructured_arrow_op_equivalence F d).symm) }\n#align initial_of_final_op initial_of_final_op\n\n",
 "initial_of_adjunction":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚•§ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚•§ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚ä£ ¬ª -/\n/-- If a functor `L : C ‚•§ D` is a left adjoint, it is initial. -/\ntheorem initial_of_adjunction {L : ¬´expr ‚•§ ¬ª C D} {R : ¬´expr ‚•§ ¬ª D C} (adj : ¬´expr ‚ä£ ¬ª L R) : initial L :=\n  {\n    out := fun d =>\n      let u : costructured_arrow L d := costructured_arrow.mk (adj.counit.app d)\n      @zigzag_is_connected _ _ ‚ü®u‚ü© fun f g =>\n        relation.refl_trans_gen.trans\n          (relation.refl_trans_gen.single\n            (show zag f u from or.inl ‚ü®costructured_arrow.hom_mk (adj.hom_equiv f.left d f.hom) (by simp)‚ü©))\n          (relation.refl_trans_gen.single\n            (show zag u g from or.inr ‚ü®costructured_arrow.hom_mk (adj.hom_equiv g.left d g.hom) (by simp)‚ü©)) }\n#align initial_of_adjunction initial_of_adjunction\n\n",
 "has_limit_of_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚ãô ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚ãô ¬ª -/\n/-- When `F` is initial, and `F ‚ãô G` has a limit, then `G` has a limit also.\n\nWe can't make this an instance, because `F` is not determined by the goal.\n(Even if this weren't a problem, it would cause a loop with `comp_has_limit`.)\n-/\ntheorem has_limit_of_comp [has_limit (¬´expr ‚ãô ¬ª F G)] : has_limit G :=\n  has_limit.mk (limit_cone_of_comp F (get_limit_cone (¬´expr ‚ãô ¬ª F G)))\n#align has_limit_of_comp has_limit_of_comp\n\n",
 "has_colimit_of_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚ãô ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚ãô ¬ª -/\n/-- When `F` is cofinal, and `F ‚ãô G` has a colimit, then `G` has a colimit also.\n\nWe can't make this an instance, because `F` is not determined by the goal.\n(Even if this weren't a problem, it would cause a loop with `comp_has_colimit`.)\n-/\ntheorem has_colimit_of_comp [has_colimit (¬´expr ‚ãô ¬ª F G)] : has_colimit G :=\n  has_colimit.mk (colimit_cocone_of_comp F (get_colimit_cocone (¬´expr ‚ãô ¬ª F G)))\n#align has_colimit_of_comp has_colimit_of_comp\n\n",
 "final_of_initial_op":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚•§ ¬ª -/\n/-\nCopyright (c) 2020 Scott Morrison. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Scott Morrison\n-/\ntheorem final_of_initial_op (F : ¬´expr ‚•§ ¬ª C D) [initial F.op] : final F :=\n  {\n    out := fun d =>\n      @is_connected_of_is_connected_op _ _ (is_connected_of_equivalent (structured_arrow_op_equivalence F d).symm) }\n#align final_of_initial_op final_of_initial_op\n\n",
 "final_of_adjunction":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚•§ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚•§ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚ä£ ¬ª -/\n/-- If a functor `R : D ‚•§ C` is a right adjoint, it is final. -/\ntheorem final_of_adjunction {L : ¬´expr ‚•§ ¬ª C D} {R : ¬´expr ‚•§ ¬ª D C} (adj : ¬´expr ‚ä£ ¬ª L R) : final R :=\n  {\n    out := fun c =>\n      let u : structured_arrow c R := structured_arrow.mk (adj.unit.app c)\n      @zigzag_is_connected _ _ ‚ü®u‚ü© fun f g =>\n        relation.refl_trans_gen.trans\n          (relation.refl_trans_gen.single\n            (show zag f u from or.inr ‚ü®structured_arrow.hom_mk ((adj.hom_equiv c f.right).symm f.hom) (by simp)‚ü©))\n          (relation.refl_trans_gen.single\n            (show zag u g from or.inl ‚ü®structured_arrow.hom_mk ((adj.hom_equiv c g.right).symm g.hom) (by simp)‚ü©)) }\n#align final_of_adjunction final_of_adjunction\n\n",
 "colimit_pre_is_iso_aux":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´exprùüô¬ª -/\ntheorem colimit_pre_is_iso_aux {t : cocone G} (P : is_colimit t) :\n    ((is_colimit_whisker_equiv F _).symm P).desc (t.whisker F) = (¬´exprùüô¬ª) t.X :=\n  by\n  dsimp [is_colimit_whisker_equiv]\n  apply P.hom_ext\n  intro j\n  dsimp; simp\n#align colimit_pre_is_iso_aux colimit_pre_is_iso_aux\n\n",
 "colimit_cocone_comp_aux":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚â´ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´exprùüô¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚ãô ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚â´ ¬ª -/\n-- This would be true if we'd chosen `lift F X` to be `lift F Y`\n-- and `hom_to_lift F X` to be `f ‚â´ hom_to_lift F Y`.\n@[simp]\ntheorem colimit_cocone_comp_aux (s : cocone (¬´expr ‚ãô ¬ª F G)) (j : C) :\n    ¬´expr ‚â´ ¬ª (G.map (hom_to_lift F (F.obj j))) (s.Œπ.app (lift F (F.obj j))) = s.Œπ.app j :=\n  by\n  -- This point is that this would be true if we took `lift (F.obj j)` to just be `j`\n  -- and `hom_to_lift (F.obj j)` to be `ùüô (F.obj j)`.\n  apply induction F fun X k => ¬´expr ‚â´ ¬ª (G.map k) (s.Œπ.app X) = (s.Œπ.app j : _)\n  ¬∑ intro j‚ÇÅ j‚ÇÇ k‚ÇÅ k‚ÇÇ f w h\n    rw [‚Üê w]\n    rw [‚Üê s.w f] at h\n    simpa using h\n  ¬∑ intro j‚ÇÅ j‚ÇÇ k‚ÇÅ k‚ÇÇ f w h\n    rw [‚Üê w] at h\n    rw [‚Üê s.w f]\n    simpa using h\n  ¬∑ exact s.w ((¬´exprùüô¬ª) _)\n#align colimit_cocone_comp_aux colimit_cocone_comp_aux\n\n",
 "cofinal_of_colimit_comp_coyoneda_iso_punit":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚ãô ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚ãô ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚âÖ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚ãô ¬ª -/\n/-- If `colimit (F ‚ãô coyoneda.obj (op d)) ‚âÖ punit` for all `d : D`, then `F` is cofinal.\n-/\ntheorem cofinal_of_colimit_comp_coyoneda_iso_punit\n    (I : ‚àÄ d, ¬´expr ‚âÖ ¬ª (colimit (¬´expr ‚ãô ¬ª F (coyoneda.obj (op d)))) PUnit) : final F :=\n  ‚ü®fun d =>\n    by\n    have : nonempty (structured_arrow d F) := by\n      have := (I d).inv PUnit.unit\n      obtain ‚ü®j, y, rfl‚ü© := limits.types.jointly_surjective'.{v, v} this\n      exact ‚ü®structured_arrow.mk y‚ü©\n    apply zigzag_is_connected\n    rintro ‚ü®‚ü®‚ü®‚ü©‚ü©, X‚ÇÅ, f‚ÇÅ‚ü© ‚ü®‚ü®‚ü®‚ü©‚ü©, X‚ÇÇ, f‚ÇÇ‚ü©\n    dsimp at *\n    let y‚ÇÅ := colimit.Œπ (¬´expr ‚ãô ¬ª F (coyoneda.obj (op d))) X‚ÇÅ f‚ÇÅ\n    let y‚ÇÇ := colimit.Œπ (¬´expr ‚ãô ¬ª F (coyoneda.obj (op d))) X‚ÇÇ f‚ÇÇ\n    have e : y‚ÇÅ = y‚ÇÇ := by\n      apply (I d).to_equiv.injective\n      ext\n    have t := types.colimit_eq.{v, v} e\n    clear e y‚ÇÅ y‚ÇÇ\n    exact zigzag_of_eqv_gen_quot_rel t‚ü©\n#align cofinal_of_colimit_comp_coyoneda_iso_punit cofinal_of_colimit_comp_coyoneda_iso_punit\n\n"}