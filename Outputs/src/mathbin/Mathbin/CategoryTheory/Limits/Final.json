{"zigzag_of_eqv_gen_quot_rel":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‹™ Â» -/\ntheorem zigzag_of_eqv_gen_quot_rel {F : Â«expr â¥¤ Â» C D} {d : D} {fâ‚ fâ‚‚ : Î£X, Â«expr âŸ¶ Â» d (F.obj X)}\n    (t : EqvGen (Types.Quot.Rel.{v, v} (Â«expr â‹™ Â» F (coyoneda.obj (op d)))) fâ‚ fâ‚‚) :\n    Zigzag (StructuredArrow.mk fâ‚.2) (StructuredArrow.mk fâ‚‚.2) :=\n  by\n  induction t\n  case rel x y r =>\n    obtain âŸ¨f, wâŸ© := r\n    fconstructor\n    swap; fconstructor\n    left; fconstructor\n    exact structured_arrow.hom_mk f (by tidy)\n  case refl => fconstructor\n  case symm x y h ih =>\n    apply zigzag_symmetric\n    exact ih\n  case trans x y z hâ‚ hâ‚‚ ihâ‚ ihâ‚‚ =>\n    apply Relation.ReflTransGen.trans\n    exact ihâ‚; exact ihâ‚‚\n#align zigzag_of_eqv_gen_quot_rel zigzag_of_eqv_gen_quot_rel\n\n",
 "limit_pre_is_iso_aux":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\ntheorem limit_pre_is_iso_aux {t : Cone G} (P : IsLimit t) :\n    ((isLimitWhiskerEquiv F _).symm P).lift (t.whisker F) = (Â«exprğŸ™Â») t.X :=\n  by\n  dsimp [is_limit_whisker_equiv]\n  apply P.hom_ext\n  intro j\n  simp\n#align limit_pre_is_iso_aux limit_pre_is_iso_aux\n\n",
 "limit_cone_comp_aux":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‹™ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n-- This would be true if we'd chosen `lift F Y` to be `lift F X`\n-- and `hom_to_lift F Y` to be `hom_to_lift F X â‰« f`.\n@[simp]\ntheorem limit_cone_comp_aux (s : Cone (Â«expr â‹™ Â» F G)) (j : C) :\n    Â«expr â‰« Â» (s.Ï€.app (lift F (F.obj j))) (G.map (homToLift F (F.obj j))) = s.Ï€.app j :=\n  by\n  -- This point is that this would be true if we took `lift (F.obj j)` to just be `j`\n  -- and `hom_to_lift (F.obj j)` to be `ğŸ™ (F.obj j)`.\n  apply induction F fun X k => Â«expr â‰« Â» (s.Ï€.app X) (G.map k) = (s.Ï€.app j : _)\n  Â· intro jâ‚ jâ‚‚ kâ‚ kâ‚‚ f w h\n    rw [â† s.w f]\n    rw [â† w] at h\n    simpa using h\n  Â· intro jâ‚ jâ‚‚ kâ‚ kâ‚‚ f w h\n    rw [â† s.w f] at h\n    rw [â† w]\n    simpa using h\n  Â· exact s.w ((Â«exprğŸ™Â») _)\n#align limit_cone_comp_aux limit_cone_comp_aux\n\n",
 "initial_of_final_op":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\ntheorem initial_of_final_op (F : Â«expr â¥¤ Â» C D) [Final F.op] : Initial F :=\n  {\n    out := fun d =>\n      @isConnected_of_isConnected_op _ _ (isConnected_of_equivalent (costructuredArrowOpEquivalence F d).symm) }\n#align initial_of_final_op initial_of_final_op\n\n",
 "initial_of_adjunction":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŠ£ Â» -/\n/-- If a functor `L : C â¥¤ D` is a left adjoint, it is initial. -/\ntheorem initial_of_adjunction {L : Â«expr â¥¤ Â» C D} {R : Â«expr â¥¤ Â» D C} (adj : Â«expr âŠ£ Â» L R) : Initial L :=\n  {\n    out := fun d =>\n      let u : CostructuredArrow L d := CostructuredArrow.mk (adj.counit.app d)\n      @zigzag_isConnected _ _ âŸ¨uâŸ© fun f g =>\n        Relation.ReflTransGen.trans\n          (Relation.ReflTransGen.single\n            (show Zag f u from or.inl âŸ¨CostructuredArrow.homMk (adj.hom_equiv f.left d f.hom) (by simp)âŸ©))\n          (Relation.ReflTransGen.single\n            (show Zag u g from or.inr âŸ¨CostructuredArrow.homMk (adj.hom_equiv g.left d g.hom) (by simp)âŸ©)) }\n#align initial_of_adjunction initial_of_adjunction\n\n",
 "has_limit_of_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‹™ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‹™ Â» -/\n/-- When `F` is initial, and `F â‹™ G` has a limit, then `G` has a limit also.\n\nWe can't make this an instance, because `F` is not determined by the goal.\n(Even if this weren't a problem, it would cause a loop with `comp_has_limit`.)\n-/\ntheorem has_limit_of_comp [HasLimit (Â«expr â‹™ Â» F G)] : HasLimit G :=\n  HasLimit.mk (limitConeOfComp F (getLimitCone (Â«expr â‹™ Â» F G)))\n#align has_limit_of_comp has_limit_of_comp\n\n",
 "has_colimit_of_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‹™ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‹™ Â» -/\n/-- When `F` is cofinal, and `F â‹™ G` has a colimit, then `G` has a colimit also.\n\nWe can't make this an instance, because `F` is not determined by the goal.\n(Even if this weren't a problem, it would cause a loop with `comp_has_colimit`.)\n-/\ntheorem has_colimit_of_comp [HasColimit (Â«expr â‹™ Â» F G)] : HasColimit G :=\n  HasColimit.mk (colimitCoconeOfComp F (getColimitCocone (Â«expr â‹™ Â» F G)))\n#align has_colimit_of_comp has_colimit_of_comp\n\n",
 "final_of_initial_op":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/-\nCopyright (c) 2020 Scott Morrison. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Scott Morrison\n-/\ntheorem final_of_initial_op (F : Â«expr â¥¤ Â» C D) [Initial F.op] : Final F :=\n  {\n    out := fun d =>\n      @isConnected_of_isConnected_op _ _ (isConnected_of_equivalent (structuredArrowOpEquivalence F d).symm) }\n#align final_of_initial_op final_of_initial_op\n\n",
 "final_of_adjunction":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŠ£ Â» -/\n/-- If a functor `R : D â¥¤ C` is a right adjoint, it is final. -/\ntheorem final_of_adjunction {L : Â«expr â¥¤ Â» C D} {R : Â«expr â¥¤ Â» D C} (adj : Â«expr âŠ£ Â» L R) : Final R :=\n  {\n    out := fun c =>\n      let u : StructuredArrow c R := StructuredArrow.mk (adj.unit.app c)\n      @zigzag_isConnected _ _ âŸ¨uâŸ© fun f g =>\n        Relation.ReflTransGen.trans\n          (Relation.ReflTransGen.single\n            (show Zag f u from or.inr âŸ¨StructuredArrow.homMk ((adj.hom_equiv c f.right).symm f.hom) (by simp)âŸ©))\n          (Relation.ReflTransGen.single\n            (show Zag u g from or.inl âŸ¨StructuredArrow.homMk ((adj.hom_equiv c g.right).symm g.hom) (by simp)âŸ©)) }\n#align final_of_adjunction final_of_adjunction\n\n",
 "colimit_pre_is_iso_aux":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\ntheorem colimit_pre_is_iso_aux {t : Cocone G} (P : IsColimit t) :\n    ((isColimitWhiskerEquiv F _).symm P).desc (t.whisker F) = (Â«exprğŸ™Â») t.X :=\n  by\n  dsimp [is_colimit_whisker_equiv]\n  apply P.hom_ext\n  intro j\n  dsimp; simp\n#align colimit_pre_is_iso_aux colimit_pre_is_iso_aux\n\n",
 "colimit_cocone_comp_aux":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‹™ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n-- This would be true if we'd chosen `lift F X` to be `lift F Y`\n-- and `hom_to_lift F X` to be `f â‰« hom_to_lift F Y`.\n@[simp]\ntheorem colimit_cocone_comp_aux (s : Cocone (Â«expr â‹™ Â» F G)) (j : C) :\n    Â«expr â‰« Â» (G.map (homToLift F (F.obj j))) (s.Î¹.app (lift F (F.obj j))) = s.Î¹.app j :=\n  by\n  -- This point is that this would be true if we took `lift (F.obj j)` to just be `j`\n  -- and `hom_to_lift (F.obj j)` to be `ğŸ™ (F.obj j)`.\n  apply induction F fun X k => Â«expr â‰« Â» (G.map k) (s.Î¹.app X) = (s.Î¹.app j : _)\n  Â· intro jâ‚ jâ‚‚ kâ‚ kâ‚‚ f w h\n    rw [â† w]\n    rw [â† s.w f] at h\n    simpa using h\n  Â· intro jâ‚ jâ‚‚ kâ‚ kâ‚‚ f w h\n    rw [â† w] at h\n    rw [â† s.w f]\n    simpa using h\n  Â· exact s.w ((Â«exprğŸ™Â») _)\n#align colimit_cocone_comp_aux colimit_cocone_comp_aux\n\n",
 "cofinal_of_colimit_comp_coyoneda_iso_punit":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‹™ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‹™ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰… Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‹™ Â» -/\n/-- If `colimit (F â‹™ coyoneda.obj (op d)) â‰… punit` for all `d : D`, then `F` is cofinal.\n-/\ntheorem cofinal_of_colimit_comp_coyoneda_iso_punit\n    (I : âˆ€ d, Â«expr â‰… Â» (colimit (Â«expr â‹™ Â» F (coyoneda.obj (op d)))) PUnit) : Final F :=\n  âŸ¨fun d =>\n    by\n    have : Nonempty (structured_arrow d F) := by\n      have := (I d).inv PUnit.unit\n      obtain âŸ¨j, y, rflâŸ© := Limits.Types.jointly_surjective'.{v, v} this\n      exact âŸ¨structured_arrow.mk yâŸ©\n    apply zigzag_is_connected\n    rintro âŸ¨âŸ¨âŸ¨âŸ©âŸ©, Xâ‚, fâ‚âŸ© âŸ¨âŸ¨âŸ¨âŸ©âŸ©, Xâ‚‚, fâ‚‚âŸ©\n    dsimp at *\n    let yâ‚ := colimit.Î¹ (Â«expr â‹™ Â» F (coyoneda.obj (op d))) Xâ‚ fâ‚\n    let yâ‚‚ := colimit.Î¹ (Â«expr â‹™ Â» F (coyoneda.obj (op d))) Xâ‚‚ fâ‚‚\n    have e : yâ‚ = yâ‚‚ := by\n      apply (I d).to_equiv.injective\n      ext\n    have t := Types.colimit_eq.{v, v} e\n    clear e yâ‚ yâ‚‚\n    exact zigzag_of_eqv_gen_quot_rel tâŸ©\n#align cofinal_of_colimit_comp_coyoneda_iso_punit cofinal_of_colimit_comp_coyoneda_iso_punit\n\n"}