{"ι_pre":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n@[simp, reassoc.1]\ntheorem colimit.ι_pre (k : K) : «expr ≫ » (colimit.ι («expr ⋙ » E F) k) (colimit.pre F E) = colimit.ι F (E.obj k) :=\n  by\n  erw [is_colimit.fac]\n  rfl\n#align colimit.ι_pre colimit.ι_pre\n\n",
 "ι_post":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n@[simp, reassoc.1]\ntheorem colimit.ι_post (j : J) : «expr ≫ » (colimit.ι («expr ⋙ » F G) j) (colimit.post F G) = G.map (colimit.ι F j) :=\n  by\n  erw [is_colimit.fac]\n  rfl\n#align colimit.ι_post colimit.ι_post\n\n",
 "ι_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem colimit.ι_map (j : J) : «expr ≫ » (colimit.ι F j) (colim.map α) = «expr ≫ » (α.app j) (colimit.ι G j) := by\n  apply is_colimit.fac\n#align colimit.ι_map colimit.ι_map\n\n",
 "ι_desc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/-- We have lots of lemmas describing how to simplify `colimit.ι F j ≫ _`,\nand combined with `colimit.ext` we rely on these lemmas for many calculations.\n\nHowever, since `category.assoc` is a `@[simp]` lemma, often expressions are\nright associated, and it's hard to apply these lemmas about `colimit.ι`.\n\nWe thus use `reassoc` to define additional `@[simp]` lemmas, with an arbitrary extra morphism.\n(see `tactic/reassoc_axiom.lean`)\n -/\n@[simp, reassoc.1]\ntheorem colimit.ι_desc {F : «expr ⥤ » J C} [HasColimit F] (c : Cocone F) (j : J) :\n    «expr ≫ » (colimit.ι F j) (colimit.desc F c) = c.ι.app j :=\n  is_colimit.fac _ c j\n#align colimit.ι_desc colimit.ι_desc\n\n",
 "ι_colim_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem ι_colim_map {F G : «expr ⥤ » J C} [HasColimit F] [HasColimit G] (α : «expr ⟶ » F G) (j : J) :\n    «expr ≫ » (colimit.ι F j) (colimMap α) = «expr ≫ » (α.app j) (colimit.ι G j) :=\n  colimit.ι_desc _ j\n#align ι_colim_map ι_colim_map\n\n",
 "ι_cocone_morphism":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem colimit.ι_cocone_morphism {F : «expr ⥤ » J C} [HasColimit F] (c : Cocone F) (j : J) :\n    «expr ≫ » (colimit.ι F j) (colimit.coconeMorphism c).hom = c.ι.app j := by simp\n#align colimit.ι_cocone_morphism colimit.ι_cocone_morphism\n\n",
 "w":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem colimit.w (F : «expr ⥤ » J C) [HasColimit F] {j j' : J} (f : «expr ⟶ » j j') :\n    «expr ≫ » (F.map f) (colimit.ι F j') = colimit.ι F j :=\n  (colimit.cocone F).w f\n#align colimit.w colimit.w\n\n",
 "pre_π":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n@[simp, reassoc.1]\ntheorem limit.pre_π (k : K) : «expr ≫ » (limit.pre F E) (limit.π («expr ⋙ » E F) k) = limit.π F (E.obj k) :=\n  by\n  erw [is_limit.fac]\n  rfl\n#align limit.pre_π limit.pre_π\n\n",
 "pre_pre":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n@[simp]\ntheorem colimit.pre_pre : «expr ≫ » (colimit.pre («expr ⋙ » E F) D) (colimit.pre F E) = colimit.pre F («expr ⋙ » D E) :=\n  by\n  ext j\n  rw [← assoc, colimit.ι_pre, colimit.ι_pre]\n  letI : has_colimit («expr ⋙ » («expr ⋙ » D E) F) := show has_colimit («expr ⋙ » D («expr ⋙ » E F)) by infer_instance\n  exact (colimit.ι_pre F («expr ⋙ » D E) j).symm\n#align colimit.pre_pre colimit.pre_pre\n\n",
 "pre_post":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\ntheorem colimit.pre_post {D : Type u'} [Category.{v'} D] (E : «expr ⥤ » K J) (F : «expr ⥤ » J C) (G : «expr ⥤ » C D)\n    [HasColimit F] [HasColimit («expr ⋙ » E F)] [HasColimit («expr ⋙ » F G)]\n    [H : HasColimit («expr ⋙ » («expr ⋙ » E F) G)] :-- G (colimit F) ⟶ G (colimit (E ⋙ F)) ⟶ colimit ((E ⋙ F) ⋙ G) vs \n        -- G (colimit F) ⟶ colimit F ⋙ G ⟶ colimit (E ⋙ (F ⋙ G)) or\n        «expr ≫ »\n        (colimit.post («expr ⋙ » E F) G) (G.map (colimit.pre F E)) =\n      («expr ≫ » (@colimit.pre _ _ _ («expr ⋙ » F G) _ E H) (colimit.post F G) : _) :=\n  by\n  ext\n  rw [← assoc, colimit.ι_post, ← G.map_comp, colimit.ι_pre, ← assoc]\n  letI : has_colimit («expr ⋙ » E («expr ⋙ » F G)) := show has_colimit («expr ⋙ » («expr ⋙ » E F) G) by infer_instance\n  erw [colimit.ι_pre («expr ⋙ » F G) E j, colimit.ι_post]\n#align colimit.pre_post colimit.pre_post\n\n",
 "pre_map'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem colimit.pre_map' [HasColimitsOfShape K C] (F : «expr ⥤ » J C) {E₁ E₂ : «expr ⥤ » K J} (α : «expr ⟶ » E₁ E₂) :\n    colimit.pre F E₁ = «expr ≫ » (colim.map (whiskerRight α F)) (colimit.pre F E₂) := by\n  ext1 <;> simp [← category.assoc]\n#align colimit.pre_map' colimit.pre_map'\n\n",
 "pre_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem colimit.pre_map [HasColimitsOfShape K C] (E : «expr ⥤ » K J) :\n    «expr ≫ » (colimit.pre F E) (colim.map α) = «expr ≫ » (colim.map (whiskerLeft E α)) (colimit.pre G E) := by\n  ext <;> rw [← assoc, colimit.ι_pre, colimit.ι_map, ← assoc, colimit.ι_map, assoc, colimit.ι_pre] <;> rfl\n#align colimit.pre_map colimit.pre_map\n\n",
 "pre_id":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟭» -/\ntheorem colimit.pre_id (F : «expr ⥤ » J C) : colimit.pre F ((«expr𝟭») _) = colim.map (Functor.leftUnitor F).hom := by\n  tidy\n#align colimit.pre_id colimit.pre_id\n\n",
 "pre_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/-- -\nIf we have particular colimit cocones available for `E ⋙ F` and for `F`,\nwe obtain a formula for `colimit.pre F E`.\n-/\ntheorem colimit.pre_eq (s : ColimitCocone («expr ⋙ » E F)) (t : ColimitCocone F) :\n    colimit.pre F E =\n      «expr ≫ » (colimit.isoColimitCocone s).hom\n        («expr ≫ » (s.is_colimit.desc (t.cocone.whisker E)) (colimit.isoColimitCocone t).inv) :=\n  by tidy\n#align colimit.pre_eq colimit.pre_eq\n\n",
 "pre_desc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n@[simp, reassoc.1]\ntheorem colimit.pre_desc (c : Cocone F) :\n    «expr ≫ » (colimit.pre F E) (colimit.desc F c) = colimit.desc («expr ⋙ » E F) (c.whisker E) := by\n  ext <;> rw [← assoc, colimit.ι_pre] <;> simp\n#align colimit.pre_desc colimit.pre_desc\n\n",
 "post_π":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n@[simp, reassoc.1]\ntheorem limit.post_π (j : J) : «expr ≫ » (limit.post F G) (limit.π («expr ⋙ » F G) j) = G.map (limit.π F j) :=\n  by\n  erw [is_limit.fac]\n  rfl\n#align limit.post_π limit.post_π\n\n",
 "post_post":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n@[simp]\ntheorem colimit.post_post {E : Type u''} [Category.{v''} E] (H : «expr ⥤ » D E)\n    [HasColimit («expr ⋙ » («expr ⋙ » F G) H)] :-- H G (colimit F) ⟶ H (colimit (F ⋙ G)) ⟶ colimit ((F ⋙ G) ⋙ H) equals \n        -- H G (colimit F) ⟶ colimit (F ⋙ (G ⋙ H))\n        «expr ≫ »\n        (colimit.post («expr ⋙ » F G) H) (H.map (colimit.post F G)) =\n      colimit.post F («expr ⋙ » G H) :=\n  by\n  ext\n  rw [← assoc, colimit.ι_post, ← H.map_comp, colimit.ι_post]\n  exact (colimit.ι_post F («expr ⋙ » G H) j).symm\n#align colimit.post_post colimit.post_post\n\n",
 "post_desc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n@[simp]\ntheorem colimit.post_desc (c : Cocone F) :\n    «expr ≫ » (colimit.post F G) (G.map (colimit.desc F c)) = colimit.desc («expr ⋙ » F G) (G.map_cocone c) :=\n  by\n  ext\n  rw [← assoc, colimit.ι_post, ← G.map_comp, colimit.ι_desc, colimit.ι_desc]\n  rfl\n#align colimit.post_desc colimit.post_desc\n\n",
 "of_cones_iso":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≪≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≅ » -/\n-- See the construction of limits from products and equalizers\n-- for an example usage.\n/-- If a functor `G` has the same collection of cones as a functor `F`\nwhich has a limit, then `G` also has a limit. -/\ntheorem has_limit.of_cones_iso {J K : Type u₁} [Category.{v₁} J] [Category.{v₂} K] (F : «expr ⥤ » J C)\n    (G : «expr ⥤ » K C) (h : «expr ≅ » F.cones G.cones) [HasLimit F] : HasLimit G :=\n  HasLimit.mk ⟨_, IsLimit.ofNatIso («expr ≪≫ » (IsLimit.natIso (limit.isLimit F)) h)⟩\n#align has_limit.of_cones_iso has_limit.of_cones_iso\n\n",
 "of_cocones_iso":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≪≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≅ » -/\n/-- If a functor `G` has the same collection of cocones as a functor `F`\nwhich has a colimit, then `G` also has a colimit. -/\ntheorem has_colimit.of_cocones_iso {K : Type u₁} [Category.{v₂} K] (F : «expr ⥤ » J C) (G : «expr ⥤ » K C)\n    (h : «expr ≅ » F.cocones G.cocones) [HasColimit F] : HasColimit G :=\n  HasColimit.mk ⟨_, IsColimit.ofNatIso («expr ≪≫ » (IsColimit.natIso (colimit.isColimit F)) h)⟩\n#align has_colimit.of_cocones_iso has_colimit.of_cocones_iso\n\n",
 "mk":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\ntheorem has_colimit.mk {F : «expr ⥤ » J C} (d : ColimitCocone F) : HasColimit F :=\n  ⟨nonempty.intro d⟩\n#align has_colimit.mk has_colimit.mk\n\n",
 "map_pre'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem limit.map_pre' [HasLimitsOfShape K C] (F : «expr ⥤ » J C) {E₁ E₂ : «expr ⥤ » K J} (α : «expr ⟶ » E₁ E₂) :\n    limit.pre F E₂ = «expr ≫ » (limit.pre F E₁) (lim.map (whiskerRight α F)) := by ext1 <;> simp [← category.assoc]\n#align limit.map_pre' limit.map_pre'\n\n",
 "map_pre":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem limit.map_pre [HasLimitsOfShape K C] (E : «expr ⥤ » K J) :\n    «expr ≫ » (lim.map α) (limit.pre G E) = «expr ≫ » (limit.pre F E) (lim.map (whiskerLeft E α)) :=\n  by\n  ext\n  simp\n#align limit.map_pre limit.map_pre\n\n",
 "map_post":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem colimit.map_post {D : Type u'} [Category.{v'} D] [HasColimitsOfShape J D]\n    (H : «expr ⥤ » C D) :/- H (colimit F) ⟶ H (colimit G) ⟶ colimit (G ⋙ H) vs\n           H (colimit F) ⟶ colimit (F ⋙ H) ⟶ colimit (G ⋙ H) -/\n        «expr ≫ »\n        (colimit.post F H) (H.map (colim.map α)) =\n      «expr ≫ » (colim.map (whiskerRight α H)) (colimit.post G H) :=\n  by\n  ext\n  rw [← assoc, colimit.ι_post, ← H.map_comp, colimit.ι_map, H.map_comp]\n  rw [← assoc, colimit.ι_map, assoc, colimit.ι_post]\n  rfl\n#align colimit.map_post colimit.map_post\n\n",
 "map_desc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp]\ntheorem colimit.map_desc (c : Cocone G) :\n    «expr ≫ » (colim.map α) (colimit.desc G c) = colimit.desc F ((Cocones.precompose α).obj c) := by\n  ext <;> rw [← assoc, colimit.ι_map, assoc, colimit.ι_desc, colimit.ι_desc] <;> rfl\n#align colimit.map_desc colimit.map_desc\n\n",
 "lim_map_π":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem lim_map_π {F G : «expr ⥤ » J C} [HasLimit F] [HasLimit G] (α : «expr ⟶ » F G) (j : J) :\n    «expr ≫ » (limMap α) (limit.π G j) = «expr ≫ » (limit.π F j) (α.app j) :=\n  limit.lift_π _ j\n#align lim_map_π lim_map_π\n\n",
 "lim_map_eq_lim_map":
 "-- `has_limit_comp_equivalence` and `has_limit_of_comp_equivalence`\n-- are proved in `category_theory/adjunction/limits.lean`.\n-- We generate this manually since `simps` gives it a weird name.\n@[simp]\ntheorem lim_map_eq_lim_map : lim.map α = limMap α :=\n  rfl\n#align lim_map_eq_lim_map lim_map_eq_lim_map\n\n",
 "lift_π":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem limit.lift_π {F : «expr ⥤ » J C} [HasLimit F] (c : Cone F) (j : J) :\n    «expr ≫ » (limit.lift F c) (limit.π F j) = c.π.app j :=\n  is_limit.fac _ c j\n#align limit.lift_π limit.lift_π\n\n",
 "lift_pre":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n@[simp]\ntheorem limit.lift_pre (c : Cone F) :\n    «expr ≫ » (limit.lift F c) (limit.pre F E) = limit.lift («expr ⋙ » E F) (c.whisker E) := by ext <;> simp\n#align limit.lift_pre limit.lift_pre\n\n",
 "lift_post":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n@[simp]\ntheorem limit.lift_post (c : Cone F) :\n    «expr ≫ » (G.map (limit.lift F c)) (limit.post F G) = limit.lift («expr ⋙ » F G) (G.map_cone c) :=\n  by\n  ext\n  rw [assoc, limit.post_π, ← G.map_comp, limit.lift_π, limit.lift_π]\n  rfl\n#align limit.lift_post limit.lift_post\n\n",
 "lift_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp]\ntheorem limit.lift_map {F G : «expr ⥤ » J C} [HasLimit F] [HasLimit G] (c : Cone F) (α : «expr ⟶ » F G) :\n    «expr ≫ » (limit.lift F c) (limMap α) = limit.lift G ((Cones.postcompose α).obj c) :=\n  by\n  ext\n  rw [assoc, lim_map_π, limit.lift_π_assoc, limit.lift_π]\n  rfl\n#align limit.lift_map limit.lift_map\n\n",
 "lift_iso_of_nat_iso_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≅ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem has_limit.lift_iso_of_nat_iso_inv {F G : «expr ⥤ » J C} [HasLimit F] [HasLimit G] (t : Cone G)\n    (w : «expr ≅ » F G) :\n    «expr ≫ » (limit.lift G t) (HasLimit.isoOfNatIso w).inv = limit.lift F ((Cones.postcompose w.inv).obj _) :=\n  IsLimit.lift_comp_conePointsIsoOfNatIso_inv _ _ _\n#align has_limit.lift_iso_of_nat_iso_inv has_limit.lift_iso_of_nat_iso_inv\n\n",
 "lift_iso_of_nat_iso_hom":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≅ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem has_limit.lift_iso_of_nat_iso_hom {F G : «expr ⥤ » J C} [HasLimit F] [HasLimit G] (t : Cone F)\n    (w : «expr ≅ » F G) :\n    «expr ≫ » (limit.lift F t) (HasLimit.isoOfNatIso w).hom = limit.lift G ((Cones.postcompose w.hom).obj _) :=\n  IsLimit.lift_comp_conePointsIsoOfNatIso_hom _ _ _\n#align has_limit.lift_iso_of_nat_iso_hom has_limit.lift_iso_of_nat_iso_hom\n\n",
 "lift_extend":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem limit.lift_extend {F : «expr ⥤ » J C} [HasLimit F] (c : Cone F) {X : C} (f : «expr ⟶ » X c.X) :\n    limit.lift F (c.extend f) = «expr ≫ » f (limit.lift F c) := by obviously\n#align limit.lift_extend limit.lift_extend\n\n",
 "lift_cone":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n@[simp]\ntheorem limit.lift_cone {F : «expr ⥤ » J C} [HasLimit F] : limit.lift F (limit.cone F) = («expr𝟙») (limit F) :=\n  (limit.isLimit _).lift_self\n#align limit.lift_cone limit.lift_cone\n\n",
 "iso_of_nat_iso_ι_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≅ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem has_colimit.iso_of_nat_iso_ι_inv {F G : «expr ⥤ » J C} [HasColimit F] [HasColimit G] (w : «expr ≅ » F G)\n    (j : J) : «expr ≫ » (colimit.ι G j) (HasColimit.isoOfNatIso w).inv = «expr ≫ » (w.inv.app j) (colimit.ι F j) :=\n  IsColimit.comp_coconePointsIsoOfNatIso_inv _ _ _ _\n#align has_colimit.iso_of_nat_iso_ι_inv has_colimit.iso_of_nat_iso_ι_inv\n\n",
 "iso_of_nat_iso_ι_hom":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≅ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem has_colimit.iso_of_nat_iso_ι_hom {F G : «expr ⥤ » J C} [HasColimit F] [HasColimit G] (w : «expr ≅ » F G)\n    (j : J) : «expr ≫ » (colimit.ι F j) (HasColimit.isoOfNatIso w).hom = «expr ≫ » (w.hom.app j) (colimit.ι G j) :=\n  IsColimit.comp_coconePointsIsoOfNatIso_hom _ _ _ _\n#align has_colimit.iso_of_nat_iso_ι_hom has_colimit.iso_of_nat_iso_ι_hom\n\n",
 "iso_of_nat_iso_inv_π":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≅ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem has_limit.iso_of_nat_iso_inv_π {F G : «expr ⥤ » J C} [HasLimit F] [HasLimit G] (w : «expr ≅ » F G) (j : J) :\n    «expr ≫ » (HasLimit.isoOfNatIso w).inv (limit.π F j) = «expr ≫ » (limit.π G j) (w.inv.app j) :=\n  IsLimit.conePointsIsoOfNatIso_inv_comp _ _ _ _\n#align has_limit.iso_of_nat_iso_inv_π has_limit.iso_of_nat_iso_inv_π\n\n",
 "iso_of_nat_iso_inv_desc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≅ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem has_colimit.iso_of_nat_iso_inv_desc {F G : «expr ⥤ » J C} [HasColimit F] [HasColimit G] (t : Cocone F)\n    (w : «expr ≅ » F G) :\n    «expr ≫ » (HasColimit.isoOfNatIso w).inv (colimit.desc F t) = colimit.desc G ((Cocones.precompose w.inv).obj _) :=\n  IsColimit.coconePointsIsoOfNatIso_inv_desc _ _ _\n#align has_colimit.iso_of_nat_iso_inv_desc has_colimit.iso_of_nat_iso_inv_desc\n\n",
 "iso_of_nat_iso_hom_π":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≅ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem has_limit.iso_of_nat_iso_hom_π {F G : «expr ⥤ » J C} [HasLimit F] [HasLimit G] (w : «expr ≅ » F G) (j : J) :\n    «expr ≫ » (HasLimit.isoOfNatIso w).hom (limit.π G j) = «expr ≫ » (limit.π F j) (w.hom.app j) :=\n  IsLimit.conePointsIsoOfNatIso_hom_comp _ _ _ _\n#align has_limit.iso_of_nat_iso_hom_π has_limit.iso_of_nat_iso_hom_π\n\n",
 "iso_of_nat_iso_hom_desc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≅ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem has_colimit.iso_of_nat_iso_hom_desc {F G : «expr ⥤ » J C} [HasColimit F] [HasColimit G] (t : Cocone G)\n    (w : «expr ≅ » F G) :\n    «expr ≫ » (HasColimit.isoOfNatIso w).hom (colimit.desc G t) = colimit.desc F ((Cocones.precompose w.hom).obj _) :=\n  IsColimit.coconePointsIsoOfNatIso_hom_desc _ _ _\n#align has_colimit.iso_of_nat_iso_hom_desc has_colimit.iso_of_nat_iso_hom_desc\n\n",
 "iso_of_equivalence_inv_π":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≌ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≅ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp]\ntheorem has_colimit.iso_of_equivalence_inv_π {F : «expr ⥤ » J C} [HasColimit F] {G : «expr ⥤ » K C} [HasColimit G]\n    (e : «expr ≌ » J K) (w : «expr ≅ » («expr ⋙ » e.functor G) F) (k : K) :\n    «expr ≫ » (colimit.ι G k) (HasColimit.isoOfEquivalence e w).inv =\n      «expr ≫ » (G.map (e.counit_inv.app k))\n        («expr ≫ » (w.hom.app (e.inverse.obj k)) (colimit.ι F (e.inverse.obj k))) :=\n  by\n  simp [has_colimit.iso_of_equivalence, is_colimit.cocone_points_iso_of_equivalence_inv]\n  dsimp\n  simp\n#align has_colimit.iso_of_equivalence_inv_π has_colimit.iso_of_equivalence_inv_π\n\n",
 "iso_of_equivalence_hom_π":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≌ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≅ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp]\ntheorem has_colimit.iso_of_equivalence_hom_π {F : «expr ⥤ » J C} [HasColimit F] {G : «expr ⥤ » K C} [HasColimit G]\n    (e : «expr ≌ » J K) (w : «expr ≅ » («expr ⋙ » e.functor G) F) (j : J) :\n    «expr ≫ » (colimit.ι F j) (HasColimit.isoOfEquivalence e w).hom =\n      «expr ≫ » (F.map (e.unit.app j)) («expr ≫ » (w.inv.app _) (colimit.ι G _)) :=\n  by\n  simp [has_colimit.iso_of_equivalence, is_colimit.cocone_points_iso_of_equivalence_inv]\n  dsimp\n  simp\n#align has_colimit.iso_of_equivalence_hom_π has_colimit.iso_of_equivalence_hom_π\n\n",
 "iso_limit_cone_inv_π":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem limit.iso_limit_cone_inv_π {F : «expr ⥤ » J C} [HasLimit F] (t : LimitCone F) (j : J) :\n    «expr ≫ » (limit.isoLimitCone t).inv (limit.π F j) = t.cone.π.app j :=\n  by\n  dsimp [limit.iso_limit_cone, is_limit.cone_point_unique_up_to_iso]\n  tidy\n#align limit.iso_limit_cone_inv_π limit.iso_limit_cone_inv_π\n\n",
 "iso_limit_cone_hom_π":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem limit.iso_limit_cone_hom_π {F : «expr ⥤ » J C} [HasLimit F] (t : LimitCone F) (j : J) :\n    «expr ≫ » (limit.isoLimitCone t).hom (t.cone.π.app j) = limit.π F j :=\n  by\n  dsimp [limit.iso_limit_cone, is_limit.cone_point_unique_up_to_iso]\n  tidy\n#align limit.iso_limit_cone_hom_π limit.iso_limit_cone_hom_π\n\n",
 "iso_colimit_cocone_ι_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem colimit.iso_colimit_cocone_ι_inv {F : «expr ⥤ » J C} [HasColimit F] (t : ColimitCocone F) (j : J) :\n    «expr ≫ » (t.cocone.ι.app j) (colimit.isoColimitCocone t).inv = colimit.ι F j :=\n  by\n  dsimp [colimit.iso_colimit_cocone, is_colimit.cocone_point_unique_up_to_iso]\n  tidy\n#align colimit.iso_colimit_cocone_ι_inv colimit.iso_colimit_cocone_ι_inv\n\n",
 "iso_colimit_cocone_ι_hom":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem colimit.iso_colimit_cocone_ι_hom {F : «expr ⥤ » J C} [HasColimit F] (t : ColimitCocone F) (j : J) :\n    «expr ≫ » (colimit.ι F j) (colimit.isoColimitCocone t).hom = t.cocone.ι.app j :=\n  by\n  dsimp [colimit.iso_colimit_cocone, is_colimit.cocone_point_unique_up_to_iso]\n  tidy\n#align colimit.iso_colimit_cocone_ι_hom colimit.iso_colimit_cocone_ι_hom\n\n",
 "is_limit_lift":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n@[simp]\ntheorem limit.is_limit_lift {F : «expr ⥤ » J C} [HasLimit F] (c : Cone F) : (limit.isLimit F).lift c = limit.lift F c :=\n  rfl\n#align limit.is_limit_lift limit.is_limit_lift\n\n",
 "is_colimit_desc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n@[simp]\ntheorem colimit.is_colimit_desc {F : «expr ⥤ » J C} [HasColimit F] (c : Cocone F) :\n    (colimit.isColimit F).desc c = colimit.desc F c :=\n  rfl\n#align colimit.is_colimit_desc colimit.is_colimit_desc\n\n",
 "id_pre":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟭» -/\ntheorem limit.id_pre (F : «expr ⥤ » J C) : limit.pre F ((«expr𝟭») _) = lim.map (Functor.leftUnitor F).inv := by tidy\n#align limit.id_pre limit.id_pre\n\n",
 "hom_iso_hom":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp]\ntheorem colimit.hom_iso_hom (F : «expr ⥤ » J C) [HasColimit F] {W : C} (f : ULift («expr ⟶ » (colimit F) W)) :\n    (colimit.homIso F W).hom f = «expr ≫ » (colimit.cocone F).ι ((const J).map f.down) :=\n  (colimit.isColimit F).hom_iso_hom f\n#align colimit.hom_iso_hom colimit.hom_iso_hom\n\n",
 "hom_ext":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[ext]\ntheorem colimit.hom_ext {F : «expr ⥤ » J C} [HasColimit F] {X : C} {f f' : «expr ⟶ » (colimit F) X}\n    (w : ∀ j, «expr ≫ » (colimit.ι F j) f = «expr ≫ » (colimit.ι F j) f') : f = f' :=\n  (colimit.isColimit F).hom_ext w\n#align colimit.hom_ext colimit.hom_ext\n\n",
 "has_limits_of_size_shrink":
 "/-- `has_limits_of_size_shrink.{v u} C` tries to obtain `has_limits_of_size.{v u} C`\nfrom some other `has_limits_of_size C`.\n-/\ntheorem has_limits_of_size_shrink [HasLimitsOfSize.{max v₁ v₂, max u₁ u₂} C] : HasLimitsOfSize.{v₁, u₁} C :=\n  ⟨fun J hJ => has_limits_of_shape_of_equivalence (ULiftHomULiftCategory.equiv.{v₂, u₂} J).symm⟩\n#align has_limits_of_size_shrink has_limits_of_size_shrink\n\n",
 "has_limits_of_shape_of_equivalence":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≌ » -/\n/-- We can transport limits of shape `J` along an equivalence `J ≌ J'`.\n-/\ntheorem has_limits_of_shape_of_equivalence {J' : Type u₂} [Category.{v₂} J'] (e : «expr ≌ » J J')\n    [HasLimitsOfShape J C] : HasLimitsOfShape J' C := by\n  constructor\n  intro F\n  apply has_limit_of_equivalence_comp e\n  infer_instance\n#align has_limits_of_shape_of_equivalence has_limits_of_shape_of_equivalence\n\n",
 "has_limits_of_shape":
 "theorem has_limits.has_limits_of_shape {C : Type u} [Category.{v} C] [HasLimits C] (J : Type v) [Category.{v} J] :\n    HasLimitsOfShape J C :=\n  has_limits_of_size.has_limits_of_shape J\n#align has_limits.has_limits_of_shape has_limits.has_limits_of_shape\n\n",
 "has_limit_of_iso":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≅ » -/\n/-- If a functor `F` has a limit, so does any naturally isomorphic functor.\n-/\ntheorem has_limit_of_iso {F G : «expr ⥤ » J C} [HasLimit F] (α : «expr ≅ » F G) : HasLimit G :=\n  HasLimit.mk\n    { cone := (Cones.postcompose α.hom).obj (limit.cone F)\n      is_limit :=\n        { lift := fun s => limit.lift F ((Cones.postcompose α.inv).obj s)\n          fac' := fun s j =>\n            by\n            rw [cones.postcompose_obj_π, nat_trans.comp_app, limit.cone_π, ← category.assoc, limit.lift_π]\n            simp\n          uniq' := fun s m w => by\n            apply limit.hom_ext; intro j\n            rw [limit.lift_π, cones.postcompose_obj_π, nat_trans.comp_app, ← nat_iso.app_inv, iso.eq_comp_inv]\n            simpa using w j } }\n#align has_limit_of_iso has_limit_of_iso\n\n",
 "has_limit_of_equivalence_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≌ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n-- not entirely sure why this is needed\n/-- If a `E ⋙ F` has a limit, and `E` is an equivalence, we can construct a limit of `F`.\n-/\ntheorem has_limit_of_equivalence_comp (e : «expr ≌ » K J) [HasLimit («expr ⋙ » e.functor F)] : HasLimit F :=\n  by\n  haveI : has_limit («expr ⋙ » e.inverse («expr ⋙ » e.functor F)) := limits.has_limit_equivalence_comp e.symm\n  apply has_limit_of_iso (e.inv_fun_id_assoc F)\n#align has_limit_of_equivalence_comp has_limit_of_equivalence_comp\n\n",
 "has_colimits_of_size_shrink":
 "/-- `has_colimits_of_size_shrink.{v u} C` tries to obtain `has_colimits_of_size.{v u} C`\nfrom some other `has_colimits_of_size C`.\n-/\ntheorem has_colimits_of_size_shrink [HasColimitsOfSize.{max v₁ v₂, max u₁ u₂} C] : HasColimitsOfSize.{v₁, u₁} C :=\n  ⟨fun J hJ => has_colimits_of_shape_of_equivalence (ULiftHomULiftCategory.equiv.{v₂, u₂} J).symm⟩\n#align has_colimits_of_size_shrink has_colimits_of_size_shrink\n\n",
 "has_colimits_of_shape_of_equivalence":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≌ » -/\n/-- We can transport colimits of shape `J` along an equivalence `J ≌ J'`.\n-/\ntheorem has_colimits_of_shape_of_equivalence {J' : Type u₂} [Category.{v₂} J'] (e : «expr ≌ » J J')\n    [HasColimitsOfShape J C] : HasColimitsOfShape J' C :=\n  by\n  constructor\n  intro F\n  apply has_colimit_of_equivalence_comp e\n  infer_instance\n#align has_colimits_of_shape_of_equivalence has_colimits_of_shape_of_equivalence\n\n",
 "has_colimits_of_shape":
 "theorem has_colimits.has_colimits_of_shape {C : Type u} [Category.{v} C] [HasColimits C] (J : Type v) [Category.{v} J] :\n    HasColimitsOfShape J C :=\n  has_colimits_of_size.has_colimits_of_shape J\n#align has_colimits.has_colimits_of_shape has_colimits.has_colimits_of_shape\n\n",
 "has_colimit_of_iso":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≅ » -/\n-- This has the isomorphism pointing in the opposite direction than in `has_limit_of_iso`.\n-- This is intentional; it seems to help with elaboration.\n/-- If `F` has a colimit, so does any naturally isomorphic functor.\n-/\ntheorem has_colimit_of_iso {F G : «expr ⥤ » J C} [HasColimit F] (α : «expr ≅ » G F) : HasColimit G :=\n  HasColimit.mk\n    { cocone := (Cocones.precompose α.hom).obj (colimit.cocone F)\n      is_colimit :=\n        { desc := fun s => colimit.desc F ((Cocones.precompose α.inv).obj s)\n          fac' := fun s j => by\n            rw [cocones.precompose_obj_ι, nat_trans.comp_app, colimit.cocone_ι]\n            rw [category.assoc, colimit.ι_desc, ← nat_iso.app_hom, ← iso.eq_inv_comp]; rfl\n          uniq' := fun s m w => by\n            apply colimit.hom_ext; intro j\n            rw [colimit.ι_desc, cocones.precompose_obj_ι, nat_trans.comp_app, ← nat_iso.app_inv, iso.eq_inv_comp]\n            simpa using w j } }\n#align has_colimit_of_iso has_colimit_of_iso\n\n",
 "has_colimit_of_equivalence_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≌ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/-- If a `E ⋙ F` has a colimit, and `E` is an equivalence, we can construct a colimit of `F`.\n-/\ntheorem has_colimit_of_equivalence_comp (e : «expr ≌ » K J) [HasColimit («expr ⋙ » e.functor F)] : HasColimit F :=\n  by\n  haveI : has_colimit («expr ⋙ » e.inverse («expr ⋙ » e.functor F)) := limits.has_colimit_equivalence_comp e.symm\n  apply has_colimit_of_iso (e.inv_fun_id_assoc F).symm\n#align has_colimit_of_equivalence_comp has_colimit_of_equivalence_comp\n\n",
 "exists_unique":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem colimit.exists_unique {F : «expr ⥤ » J C} [HasColimit F] (t : Cocone F) :\n    ∃! d : «expr ⟶ » (colimit F) t.X, ∀ j, «expr ≫ » (colimit.ι F j) d = t.ι.app j :=\n  (colimit.isColimit F).exists_unique _\n#align colimit.exists_unique colimit.exists_unique\n\n",
 "desc_extend":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem colimit.desc_extend (F : «expr ⥤ » J C) [HasColimit F] (c : Cocone F) {X : C} (f : «expr ⟶ » c.X X) :\n    colimit.desc F (c.extend f) = «expr ≫ » (colimit.desc F c) f := by ext1; rw [← category.assoc]; simp\n#align colimit.desc_extend colimit.desc_extend\n\n",
 "desc_cocone":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n@[simp]\ntheorem colimit.desc_cocone {F : «expr ⥤ » J C} [HasColimit F] :\n    colimit.desc F (colimit.cocone F) = («expr𝟙») (colimit F) :=\n  (colimit.isColimit _).desc_self\n#align colimit.desc_cocone colimit.desc_cocone\n\n",
 "cone_π":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n@[simp]\ntheorem limit.cone_π {F : «expr ⥤ » J C} [HasLimit F] : (limit.cone F).π.app = limit.π _ :=\n  rfl\n#align limit.cone_π limit.cone_π\n\n",
 "cone_point_unique_up_to_iso_inv_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem limit.cone_point_unique_up_to_iso_inv_comp {F : «expr ⥤ » J C} [HasLimit F] {c : Cone F} (hc : IsLimit c)\n    (j : J) : «expr ≫ » (IsLimit.conePointUniqueUpToIso (limit.isLimit _) hc).inv (limit.π F j) = c.π.app j :=\n  IsLimit.conePointUniqueUpToIso_inv_comp _ _ _\n#align limit.cone_point_unique_up_to_iso_inv_comp limit.cone_point_unique_up_to_iso_inv_comp\n\n",
 "cone_point_unique_up_to_iso_hom_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem limit.cone_point_unique_up_to_iso_hom_comp {F : «expr ⥤ » J C} [HasLimit F] {c : Cone F} (hc : IsLimit c)\n    (j : J) : «expr ≫ » (IsLimit.conePointUniqueUpToIso hc (limit.isLimit _)).hom (limit.π F j) = c.π.app j :=\n  IsLimit.conePointUniqueUpToIso_hom_comp _ _ _\n#align limit.cone_point_unique_up_to_iso_hom_comp limit.cone_point_unique_up_to_iso_hom_comp\n\n",
 "cone_morphism_π":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem limit.cone_morphism_π {F : «expr ⥤ » J C} [HasLimit F] (c : Cone F) (j : J) :\n    «expr ≫ » (limit.coneMorphism c).hom (limit.π F j) = c.π.app j := by simp\n#align limit.cone_morphism_π limit.cone_morphism_π\n\n",
 "cone_morphism_hom":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n@[simp]\ntheorem limit.cone_morphism_hom {F : «expr ⥤ » J C} [HasLimit F] (c : Cone F) :\n    (limit.coneMorphism c).hom = limit.lift F c :=\n  rfl\n#align limit.cone_morphism_hom limit.cone_morphism_hom\n\n",
 "cone_X":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n-- see Note [lower instance priority]\n-- see Note [lower instance priority]\n-- Interface to the `has_limit` class.\n@[simp]\ntheorem limit.cone_X {F : «expr ⥤ » J C} [HasLimit F] : (limit.cone F).X = limit F :=\n  rfl\n#align limit.cone_X limit.cone_X\n\n",
 "comp_cocone_point_unique_up_to_iso_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem colimit.comp_cocone_point_unique_up_to_iso_inv {F : «expr ⥤ » J C} [HasColimit F] {c : Cocone F}\n    (hc : IsColimit c) (j : J) :\n    «expr ≫ » (colimit.ι F j) (IsColimit.coconePointUniqueUpToIso hc (colimit.isColimit _)).inv = c.ι.app j :=\n  IsColimit.comp_coconePointUniqueUpToIso_inv _ _ _\n#align colimit.comp_cocone_point_unique_up_to_iso_inv colimit.comp_cocone_point_unique_up_to_iso_inv\n\n",
 "comp_cocone_point_unique_up_to_iso_hom":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem colimit.comp_cocone_point_unique_up_to_iso_hom {F : «expr ⥤ » J C} [HasColimit F] {c : Cocone F}\n    (hc : IsColimit c) (j : J) :\n    «expr ≫ » (colimit.ι F j) (IsColimit.coconePointUniqueUpToIso (colimit.isColimit _) hc).hom = c.ι.app j :=\n  IsColimit.comp_coconePointUniqueUpToIso_hom _ _ _\n#align colimit.comp_cocone_point_unique_up_to_iso_hom colimit.comp_cocone_point_unique_up_to_iso_hom\n\n",
 "cocone_ι":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n-- see Note [lower instance priority]\n-- see Note [lower instance priority]\n-- Interface to the `has_colimit` class.\n@[simp]\ntheorem colimit.cocone_ι {F : «expr ⥤ » J C} [HasColimit F] (j : J) : (colimit.cocone F).ι.app j = colimit.ι _ j :=\n  rfl\n#align colimit.cocone_ι colimit.cocone_ι\n\n",
 "cocone_morphism_hom":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n@[simp]\ntheorem colimit.cocone_morphism_hom {F : «expr ⥤ » J C} [HasColimit F] (c : Cocone F) :\n    (colimit.coconeMorphism c).hom = colimit.desc F c :=\n  rfl\n#align colimit.cocone_morphism_hom colimit.cocone_morphism_hom\n\n",
 "cocone_X":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n@[simp]\ntheorem colimit.cocone_X {F : «expr ⥤ » J C} [HasColimit F] : (colimit.cocone F).X = colimit F :=\n  rfl\n#align colimit.cocone_X colimit.cocone_X\n\n"}