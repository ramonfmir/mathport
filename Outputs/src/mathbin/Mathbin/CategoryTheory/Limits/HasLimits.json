{"ι_pre":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n@[simp, reassoc.1]\ntheorem colimit.ι_pre (k : K) : «expr ≫ » (colimit.ι («expr ⋙ » E F) k) (colimit.pre F E) = colimit.ι F (E.obj k) :=\n  by\n  erw [is_colimit.fac]\n  rfl\n#align colimit.ι_pre colimit.ι_pre\n\n",
 "ι_post":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n@[simp, reassoc.1]\ntheorem colimit.ι_post (j : J) : «expr ≫ » (colimit.ι («expr ⋙ » F G) j) (colimit.post F G) = G.map (colimit.ι F j) :=\n  by\n  erw [is_colimit.fac]\n  rfl\n#align colimit.ι_post colimit.ι_post\n\n",
 "ι_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem colimit.ι_map (j : J) : «expr ≫ » (colimit.ι F j) (colim.map α) = «expr ≫ » (α.app j) (colimit.ι G j) := by\n  apply is_colimit.fac\n#align colimit.ι_map colimit.ι_map\n\n",
 "ι_desc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/-- We have lots of lemmas describing how to simplify `colimit.ι F j ≫ _`,\nand combined with `colimit.ext` we rely on these lemmas for many calculations.\n\nHowever, since `category.assoc` is a `@[simp]` lemma, often expressions are\nright associated, and it's hard to apply these lemmas about `colimit.ι`.\n\nWe thus use `reassoc` to define additional `@[simp]` lemmas, with an arbitrary extra morphism.\n(see `tactic/reassoc_axiom.lean`)\n -/\n@[simp, reassoc.1]\ntheorem colimit.ι_desc {F : «expr ⥤ » J C} [has_colimit F] (c : cocone F) (j : J) :\n    «expr ≫ » (colimit.ι F j) (colimit.desc F c) = c.ι.app j :=\n  is_colimit.fac _ c j\n#align colimit.ι_desc colimit.ι_desc\n\n",
 "ι_colim_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem ι_colim_map {F G : «expr ⥤ » J C} [has_colimit F] [has_colimit G] (α : «expr ⟶ » F G) (j : J) :\n    «expr ≫ » (colimit.ι F j) (colim_map α) = «expr ≫ » (α.app j) (colimit.ι G j) :=\n  colimit.ι_desc _ j\n#align ι_colim_map ι_colim_map\n\n",
 "ι_cocone_morphism":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem colimit.ι_cocone_morphism {F : «expr ⥤ » J C} [has_colimit F] (c : cocone F) (j : J) :\n    «expr ≫ » (colimit.ι F j) (colimit.cocone_morphism c).hom = c.ι.app j := by simp\n#align colimit.ι_cocone_morphism colimit.ι_cocone_morphism\n\n",
 "w":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem colimit.w (F : «expr ⥤ » J C) [has_colimit F] {j j' : J} (f : «expr ⟶ » j j') :\n    «expr ≫ » (F.map f) (colimit.ι F j') = colimit.ι F j :=\n  (colimit.cocone F).w f\n#align colimit.w colimit.w\n\n",
 "pre_π":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n@[simp, reassoc.1]\ntheorem limit.pre_π (k : K) : «expr ≫ » (limit.pre F E) (limit.π («expr ⋙ » E F) k) = limit.π F (E.obj k) :=\n  by\n  erw [is_limit.fac]\n  rfl\n#align limit.pre_π limit.pre_π\n\n",
 "pre_pre":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n@[simp]\ntheorem colimit.pre_pre : «expr ≫ » (colimit.pre («expr ⋙ » E F) D) (colimit.pre F E) = colimit.pre F («expr ⋙ » D E) :=\n  by\n  ext j\n  rw [← assoc, colimit.ι_pre, colimit.ι_pre]\n  letI : has_colimit («expr ⋙ » («expr ⋙ » D E) F) := show has_colimit («expr ⋙ » D («expr ⋙ » E F)) by infer_instance\n  exact (colimit.ι_pre F («expr ⋙ » D E) j).symm\n#align colimit.pre_pre colimit.pre_pre\n\n",
 "pre_post":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\ntheorem colimit.pre_post {D : Type u'} [Category.{v'} D] (E : «expr ⥤ » K J) (F : «expr ⥤ » J C) (G : «expr ⥤ » C D)\n    [has_colimit F] [has_colimit («expr ⋙ » E F)] [has_colimit («expr ⋙ » F G)]\n    [H : has_colimit («expr ⋙ » («expr ⋙ » E F) G)] :-- G (colimit F) ⟶ G (colimit (E ⋙ F)) ⟶ colimit ((E ⋙ F) ⋙ G) vs \n        -- G (colimit F) ⟶ colimit F ⋙ G ⟶ colimit (E ⋙ (F ⋙ G)) or\n        «expr ≫ »\n        (colimit.post («expr ⋙ » E F) G) (G.map (colimit.pre F E)) =\n      («expr ≫ » (@colimit.pre _ _ _ («expr ⋙ » F G) _ E H) (colimit.post F G) : _) :=\n  by\n  ext\n  rw [← assoc, colimit.ι_post, ← G.map_comp, colimit.ι_pre, ← assoc]\n  letI : has_colimit («expr ⋙ » E («expr ⋙ » F G)) := show has_colimit («expr ⋙ » («expr ⋙ » E F) G) by infer_instance\n  erw [colimit.ι_pre («expr ⋙ » F G) E j, colimit.ι_post]\n#align colimit.pre_post colimit.pre_post\n\n",
 "pre_map'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem colimit.pre_map' [has_colimits_of_shape K C] (F : «expr ⥤ » J C) {E₁ E₂ : «expr ⥤ » K J} (α : «expr ⟶ » E₁ E₂) :\n    colimit.pre F E₁ = «expr ≫ » (colim.map (whiskerRight α F)) (colimit.pre F E₂) := by\n  ext1 <;> simp [← category.assoc]\n#align colimit.pre_map' colimit.pre_map'\n\n",
 "pre_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem colimit.pre_map [has_colimits_of_shape K C] (E : «expr ⥤ » K J) :\n    «expr ≫ » (colimit.pre F E) (colim.map α) = «expr ≫ » (colim.map (whiskerLeft E α)) (colimit.pre G E) := by\n  ext <;> rw [← assoc, colimit.ι_pre, colimit.ι_map, ← assoc, colimit.ι_map, assoc, colimit.ι_pre] <;> rfl\n#align colimit.pre_map colimit.pre_map\n\n",
 "pre_id":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟭» -/\ntheorem colimit.pre_id (F : «expr ⥤ » J C) : colimit.pre F ((«expr𝟭») _) = colim.map (Functor.leftUnitor F).hom := by\n  tidy\n#align colimit.pre_id colimit.pre_id\n\n",
 "pre_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/-- -\nIf we have particular colimit cocones available for `E ⋙ F` and for `F`,\nwe obtain a formula for `colimit.pre F E`.\n-/\ntheorem colimit.pre_eq (s : colimit_cocone («expr ⋙ » E F)) (t : colimit_cocone F) :\n    colimit.pre F E =\n      «expr ≫ » (colimit.iso_colimit_cocone s).hom\n        («expr ≫ » (s.is_colimit.desc (t.cocone.whisker E)) (colimit.iso_colimit_cocone t).inv) :=\n  by tidy\n#align colimit.pre_eq colimit.pre_eq\n\n",
 "pre_desc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n@[simp, reassoc.1]\ntheorem colimit.pre_desc (c : cocone F) :\n    «expr ≫ » (colimit.pre F E) (colimit.desc F c) = colimit.desc («expr ⋙ » E F) (c.whisker E) := by\n  ext <;> rw [← assoc, colimit.ι_pre] <;> simp\n#align colimit.pre_desc colimit.pre_desc\n\n",
 "post_π":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n@[simp, reassoc.1]\ntheorem limit.post_π (j : J) : «expr ≫ » (limit.post F G) (limit.π («expr ⋙ » F G) j) = G.map (limit.π F j) :=\n  by\n  erw [is_limit.fac]\n  rfl\n#align limit.post_π limit.post_π\n\n",
 "post_post":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n@[simp]\ntheorem colimit.post_post {E : Type u''} [Category.{v''} E] (H : «expr ⥤ » D E)\n    [has_colimit\n        («expr ⋙ » («expr ⋙ » F G) H)] :-- H G (colimit F) ⟶ H (colimit (F ⋙ G)) ⟶ colimit ((F ⋙ G) ⋙ H) equals \n        -- H G (colimit F) ⟶ colimit (F ⋙ (G ⋙ H))\n        «expr ≫ »\n        (colimit.post («expr ⋙ » F G) H) (H.map (colimit.post F G)) =\n      colimit.post F («expr ⋙ » G H) :=\n  by\n  ext\n  rw [← assoc, colimit.ι_post, ← H.map_comp, colimit.ι_post]\n  exact (colimit.ι_post F («expr ⋙ » G H) j).symm\n#align colimit.post_post colimit.post_post\n\n",
 "post_desc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n@[simp]\ntheorem colimit.post_desc (c : cocone F) :\n    «expr ≫ » (colimit.post F G) (G.map (colimit.desc F c)) = colimit.desc («expr ⋙ » F G) (G.map_cocone c) :=\n  by\n  ext\n  rw [← assoc, colimit.ι_post, ← G.map_comp, colimit.ι_desc, colimit.ι_desc]\n  rfl\n#align colimit.post_desc colimit.post_desc\n\n",
 "of_cones_iso":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≪≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≅ » -/\n-- See the construction of limits from products and equalizers\n-- for an example usage.\n/-- If a functor `G` has the same collection of cones as a functor `F`\nwhich has a limit, then `G` also has a limit. -/\ntheorem has_limit.of_cones_iso {J K : Type u₁} [Category.{v₁} J] [Category.{v₂} K] (F : «expr ⥤ » J C)\n    (G : «expr ⥤ » K C) (h : «expr ≅ » F.cones G.cones) [has_limit F] : has_limit G :=\n  has_limit.mk ⟨_, is_limit.of_nat_iso («expr ≪≫ » (is_limit.nat_iso (limit.is_limit F)) h)⟩\n#align has_limit.of_cones_iso has_limit.of_cones_iso\n\n",
 "of_cocones_iso":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≪≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≅ » -/\n/-- If a functor `G` has the same collection of cocones as a functor `F`\nwhich has a colimit, then `G` also has a colimit. -/\ntheorem has_colimit.of_cocones_iso {K : Type u₁} [Category.{v₂} K] (F : «expr ⥤ » J C) (G : «expr ⥤ » K C)\n    (h : «expr ≅ » F.cocones G.cocones) [has_colimit F] : has_colimit G :=\n  has_colimit.mk ⟨_, is_colimit.of_nat_iso («expr ≪≫ » (is_colimit.nat_iso (colimit.is_colimit F)) h)⟩\n#align has_colimit.of_cocones_iso has_colimit.of_cocones_iso\n\n",
 "mk":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\ntheorem has_colimit.mk {F : «expr ⥤ » J C} (d : colimit_cocone F) : has_colimit F :=\n  ⟨nonempty.intro d⟩\n#align has_colimit.mk has_colimit.mk\n\n",
 "map_pre'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem limit.map_pre' [has_limits_of_shape K C] (F : «expr ⥤ » J C) {E₁ E₂ : «expr ⥤ » K J} (α : «expr ⟶ » E₁ E₂) :\n    limit.pre F E₂ = «expr ≫ » (limit.pre F E₁) (lim.map (whiskerRight α F)) := by ext1 <;> simp [← category.assoc]\n#align limit.map_pre' limit.map_pre'\n\n",
 "map_pre":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem limit.map_pre [has_limits_of_shape K C] (E : «expr ⥤ » K J) :\n    «expr ≫ » (lim.map α) (limit.pre G E) = «expr ≫ » (limit.pre F E) (lim.map (whiskerLeft E α)) :=\n  by\n  ext\n  simp\n#align limit.map_pre limit.map_pre\n\n",
 "map_post":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem colimit.map_post {D : Type u'} [Category.{v'} D] [has_colimits_of_shape J D]\n    (H : «expr ⥤ » C D) :/- H (colimit F) ⟶ H (colimit G) ⟶ colimit (G ⋙ H) vs\n           H (colimit F) ⟶ colimit (F ⋙ H) ⟶ colimit (G ⋙ H) -/\n        «expr ≫ »\n        (colimit.post F H) (H.map (colim.map α)) =\n      «expr ≫ » (colim.map (whiskerRight α H)) (colimit.post G H) :=\n  by\n  ext\n  rw [← assoc, colimit.ι_post, ← H.map_comp, colimit.ι_map, H.map_comp]\n  rw [← assoc, colimit.ι_map, assoc, colimit.ι_post]\n  rfl\n#align colimit.map_post colimit.map_post\n\n",
 "map_desc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp]\ntheorem colimit.map_desc (c : cocone G) :\n    «expr ≫ » (colim.map α) (colimit.desc G c) = colimit.desc F ((cocones.precompose α).obj c) := by\n  ext <;> rw [← assoc, colimit.ι_map, assoc, colimit.ι_desc, colimit.ι_desc] <;> rfl\n#align colimit.map_desc colimit.map_desc\n\n",
 "lim_map_π":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem lim_map_π {F G : «expr ⥤ » J C} [has_limit F] [has_limit G] (α : «expr ⟶ » F G) (j : J) :\n    «expr ≫ » (lim_map α) (limit.π G j) = «expr ≫ » (limit.π F j) (α.app j) :=\n  limit.lift_π _ j\n#align lim_map_π lim_map_π\n\n",
 "lim_map_eq_lim_map":
 "-- `has_limit_comp_equivalence` and `has_limit_of_comp_equivalence`\n-- are proved in `category_theory/adjunction/limits.lean`.\n-- We generate this manually since `simps` gives it a weird name.\n@[simp]\ntheorem lim_map_eq_lim_map : lim.map α = lim_map α :=\n  rfl\n#align lim_map_eq_lim_map lim_map_eq_lim_map\n\n",
 "lift_π":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem limit.lift_π {F : «expr ⥤ » J C} [has_limit F] (c : cone F) (j : J) :\n    «expr ≫ » (limit.lift F c) (limit.π F j) = c.π.app j :=\n  is_limit.fac _ c j\n#align limit.lift_π limit.lift_π\n\n",
 "lift_pre":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n@[simp]\ntheorem limit.lift_pre (c : cone F) :\n    «expr ≫ » (limit.lift F c) (limit.pre F E) = limit.lift («expr ⋙ » E F) (c.whisker E) := by ext <;> simp\n#align limit.lift_pre limit.lift_pre\n\n",
 "lift_post":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n@[simp]\ntheorem limit.lift_post (c : cone F) :\n    «expr ≫ » (G.map (limit.lift F c)) (limit.post F G) = limit.lift («expr ⋙ » F G) (G.map_cone c) :=\n  by\n  ext\n  rw [assoc, limit.post_π, ← G.map_comp, limit.lift_π, limit.lift_π]\n  rfl\n#align limit.lift_post limit.lift_post\n\n",
 "lift_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp]\ntheorem limit.lift_map {F G : «expr ⥤ » J C} [has_limit F] [has_limit G] (c : cone F) (α : «expr ⟶ » F G) :\n    «expr ≫ » (limit.lift F c) (lim_map α) = limit.lift G ((cones.postcompose α).obj c) :=\n  by\n  ext\n  rw [assoc, lim_map_π, limit.lift_π_assoc, limit.lift_π]\n  rfl\n#align limit.lift_map limit.lift_map\n\n",
 "lift_iso_of_nat_iso_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≅ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem has_limit.lift_iso_of_nat_iso_inv {F G : «expr ⥤ » J C} [has_limit F] [has_limit G] (t : cone G)\n    (w : «expr ≅ » F G) :\n    «expr ≫ » (limit.lift G t) (has_limit.iso_of_nat_iso w).inv = limit.lift F ((cones.postcompose w.inv).obj _) :=\n  is_limit.lift_comp_cone_points_iso_of_nat_iso_inv _ _ _\n#align has_limit.lift_iso_of_nat_iso_inv has_limit.lift_iso_of_nat_iso_inv\n\n",
 "lift_iso_of_nat_iso_hom":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≅ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem has_limit.lift_iso_of_nat_iso_hom {F G : «expr ⥤ » J C} [has_limit F] [has_limit G] (t : cone F)\n    (w : «expr ≅ » F G) :\n    «expr ≫ » (limit.lift F t) (has_limit.iso_of_nat_iso w).hom = limit.lift G ((cones.postcompose w.hom).obj _) :=\n  is_limit.lift_comp_cone_points_iso_of_nat_iso_hom _ _ _\n#align has_limit.lift_iso_of_nat_iso_hom has_limit.lift_iso_of_nat_iso_hom\n\n",
 "lift_extend":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem limit.lift_extend {F : «expr ⥤ » J C} [has_limit F] (c : cone F) {X : C} (f : «expr ⟶ » X c.X) :\n    limit.lift F (c.extend f) = «expr ≫ » f (limit.lift F c) := by obviously\n#align limit.lift_extend limit.lift_extend\n\n",
 "lift_cone":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n@[simp]\ntheorem limit.lift_cone {F : «expr ⥤ » J C} [has_limit F] : limit.lift F (limit.cone F) = («expr𝟙») (limit F) :=\n  (limit.is_limit _).lift_self\n#align limit.lift_cone limit.lift_cone\n\n",
 "iso_of_nat_iso_ι_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≅ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem has_colimit.iso_of_nat_iso_ι_inv {F G : «expr ⥤ » J C} [has_colimit F] [has_colimit G] (w : «expr ≅ » F G)\n    (j : J) : «expr ≫ » (colimit.ι G j) (has_colimit.iso_of_nat_iso w).inv = «expr ≫ » (w.inv.app j) (colimit.ι F j) :=\n  is_colimit.comp_cocone_points_iso_of_nat_iso_inv _ _ _ _\n#align has_colimit.iso_of_nat_iso_ι_inv has_colimit.iso_of_nat_iso_ι_inv\n\n",
 "iso_of_nat_iso_ι_hom":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≅ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem has_colimit.iso_of_nat_iso_ι_hom {F G : «expr ⥤ » J C} [has_colimit F] [has_colimit G] (w : «expr ≅ » F G)\n    (j : J) : «expr ≫ » (colimit.ι F j) (has_colimit.iso_of_nat_iso w).hom = «expr ≫ » (w.hom.app j) (colimit.ι G j) :=\n  is_colimit.comp_cocone_points_iso_of_nat_iso_hom _ _ _ _\n#align has_colimit.iso_of_nat_iso_ι_hom has_colimit.iso_of_nat_iso_ι_hom\n\n",
 "iso_of_nat_iso_inv_π":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≅ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem has_limit.iso_of_nat_iso_inv_π {F G : «expr ⥤ » J C} [has_limit F] [has_limit G] (w : «expr ≅ » F G) (j : J) :\n    «expr ≫ » (has_limit.iso_of_nat_iso w).inv (limit.π F j) = «expr ≫ » (limit.π G j) (w.inv.app j) :=\n  is_limit.cone_points_iso_of_nat_iso_inv_comp _ _ _ _\n#align has_limit.iso_of_nat_iso_inv_π has_limit.iso_of_nat_iso_inv_π\n\n",
 "iso_of_nat_iso_inv_desc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≅ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem has_colimit.iso_of_nat_iso_inv_desc {F G : «expr ⥤ » J C} [has_colimit F] [has_colimit G] (t : cocone F)\n    (w : «expr ≅ » F G) :\n    «expr ≫ » (has_colimit.iso_of_nat_iso w).inv (colimit.desc F t) =\n      colimit.desc G ((cocones.precompose w.inv).obj _) :=\n  is_colimit.cocone_points_iso_of_nat_iso_inv_desc _ _ _\n#align has_colimit.iso_of_nat_iso_inv_desc has_colimit.iso_of_nat_iso_inv_desc\n\n",
 "iso_of_nat_iso_hom_π":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≅ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem has_limit.iso_of_nat_iso_hom_π {F G : «expr ⥤ » J C} [has_limit F] [has_limit G] (w : «expr ≅ » F G) (j : J) :\n    «expr ≫ » (has_limit.iso_of_nat_iso w).hom (limit.π G j) = «expr ≫ » (limit.π F j) (w.hom.app j) :=\n  is_limit.cone_points_iso_of_nat_iso_hom_comp _ _ _ _\n#align has_limit.iso_of_nat_iso_hom_π has_limit.iso_of_nat_iso_hom_π\n\n",
 "iso_of_nat_iso_hom_desc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≅ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem has_colimit.iso_of_nat_iso_hom_desc {F G : «expr ⥤ » J C} [has_colimit F] [has_colimit G] (t : cocone G)\n    (w : «expr ≅ » F G) :\n    «expr ≫ » (has_colimit.iso_of_nat_iso w).hom (colimit.desc G t) =\n      colimit.desc F ((cocones.precompose w.hom).obj _) :=\n  is_colimit.cocone_points_iso_of_nat_iso_hom_desc _ _ _\n#align has_colimit.iso_of_nat_iso_hom_desc has_colimit.iso_of_nat_iso_hom_desc\n\n",
 "iso_of_equivalence_inv_π":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≌ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≅ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp]\ntheorem has_colimit.iso_of_equivalence_inv_π {F : «expr ⥤ » J C} [has_colimit F] {G : «expr ⥤ » K C} [has_colimit G]\n    (e : «expr ≌ » J K) (w : «expr ≅ » («expr ⋙ » e.functor G) F) (k : K) :\n    «expr ≫ » (colimit.ι G k) (has_colimit.iso_of_equivalence e w).inv =\n      «expr ≫ » (G.map (e.counit_inv.app k))\n        («expr ≫ » (w.hom.app (e.inverse.obj k)) (colimit.ι F (e.inverse.obj k))) :=\n  by\n  simp [has_colimit.iso_of_equivalence, is_colimit.cocone_points_iso_of_equivalence_inv]\n  dsimp\n  simp\n#align has_colimit.iso_of_equivalence_inv_π has_colimit.iso_of_equivalence_inv_π\n\n",
 "iso_of_equivalence_hom_π":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≌ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≅ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp]\ntheorem has_colimit.iso_of_equivalence_hom_π {F : «expr ⥤ » J C} [has_colimit F] {G : «expr ⥤ » K C} [has_colimit G]\n    (e : «expr ≌ » J K) (w : «expr ≅ » («expr ⋙ » e.functor G) F) (j : J) :\n    «expr ≫ » (colimit.ι F j) (has_colimit.iso_of_equivalence e w).hom =\n      «expr ≫ » (F.map (e.unit.app j)) («expr ≫ » (w.inv.app _) (colimit.ι G _)) :=\n  by\n  simp [has_colimit.iso_of_equivalence, is_colimit.cocone_points_iso_of_equivalence_inv]\n  dsimp\n  simp\n#align has_colimit.iso_of_equivalence_hom_π has_colimit.iso_of_equivalence_hom_π\n\n",
 "iso_limit_cone_inv_π":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem limit.iso_limit_cone_inv_π {F : «expr ⥤ » J C} [has_limit F] (t : limit_cone F) (j : J) :\n    «expr ≫ » (limit.iso_limit_cone t).inv (limit.π F j) = t.cone.π.app j :=\n  by\n  dsimp [limit.iso_limit_cone, is_limit.cone_point_unique_up_to_iso]\n  tidy\n#align limit.iso_limit_cone_inv_π limit.iso_limit_cone_inv_π\n\n",
 "iso_limit_cone_hom_π":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem limit.iso_limit_cone_hom_π {F : «expr ⥤ » J C} [has_limit F] (t : limit_cone F) (j : J) :\n    «expr ≫ » (limit.iso_limit_cone t).hom (t.cone.π.app j) = limit.π F j :=\n  by\n  dsimp [limit.iso_limit_cone, is_limit.cone_point_unique_up_to_iso]\n  tidy\n#align limit.iso_limit_cone_hom_π limit.iso_limit_cone_hom_π\n\n",
 "iso_colimit_cocone_ι_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem colimit.iso_colimit_cocone_ι_inv {F : «expr ⥤ » J C} [has_colimit F] (t : colimit_cocone F) (j : J) :\n    «expr ≫ » (t.cocone.ι.app j) (colimit.iso_colimit_cocone t).inv = colimit.ι F j :=\n  by\n  dsimp [colimit.iso_colimit_cocone, is_colimit.cocone_point_unique_up_to_iso]\n  tidy\n#align colimit.iso_colimit_cocone_ι_inv colimit.iso_colimit_cocone_ι_inv\n\n",
 "iso_colimit_cocone_ι_hom":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem colimit.iso_colimit_cocone_ι_hom {F : «expr ⥤ » J C} [has_colimit F] (t : colimit_cocone F) (j : J) :\n    «expr ≫ » (colimit.ι F j) (colimit.iso_colimit_cocone t).hom = t.cocone.ι.app j :=\n  by\n  dsimp [colimit.iso_colimit_cocone, is_colimit.cocone_point_unique_up_to_iso]\n  tidy\n#align colimit.iso_colimit_cocone_ι_hom colimit.iso_colimit_cocone_ι_hom\n\n",
 "is_limit_lift":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n@[simp]\ntheorem limit.is_limit_lift {F : «expr ⥤ » J C} [has_limit F] (c : cone F) :\n    (limit.is_limit F).lift c = limit.lift F c :=\n  rfl\n#align limit.is_limit_lift limit.is_limit_lift\n\n",
 "is_colimit_desc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n@[simp]\ntheorem colimit.is_colimit_desc {F : «expr ⥤ » J C} [has_colimit F] (c : cocone F) :\n    (colimit.is_colimit F).desc c = colimit.desc F c :=\n  rfl\n#align colimit.is_colimit_desc colimit.is_colimit_desc\n\n",
 "id_pre":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟭» -/\ntheorem limit.id_pre (F : «expr ⥤ » J C) : limit.pre F ((«expr𝟭») _) = lim.map (Functor.leftUnitor F).inv := by tidy\n#align limit.id_pre limit.id_pre\n\n",
 "hom_iso_hom":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp]\ntheorem colimit.hom_iso_hom (F : «expr ⥤ » J C) [has_colimit F] {W : C} (f : ULift («expr ⟶ » (colimit F) W)) :\n    (colimit.hom_iso F W).hom f = «expr ≫ » (colimit.cocone F).ι ((const J).map f.down) :=\n  (colimit.is_colimit F).hom_iso_hom f\n#align colimit.hom_iso_hom colimit.hom_iso_hom\n\n",
 "hom_ext":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[ext]\ntheorem colimit.hom_ext {F : «expr ⥤ » J C} [has_colimit F] {X : C} {f f' : «expr ⟶ » (colimit F) X}\n    (w : ∀ j, «expr ≫ » (colimit.ι F j) f = «expr ≫ » (colimit.ι F j) f') : f = f' :=\n  (colimit.is_colimit F).hom_ext w\n#align colimit.hom_ext colimit.hom_ext\n\n",
 "has_limits_of_size_shrink":
 "/-- `has_limits_of_size_shrink.{v u} C` tries to obtain `has_limits_of_size.{v u} C`\nfrom some other `has_limits_of_size C`.\n-/\ntheorem has_limits_of_size_shrink [has_limits_of_size.{max v₁ v₂, max u₁ u₂} C] : has_limits_of_size.{v₁, u₁} C :=\n  ⟨fun J hJ => has_limits_of_shape_of_equivalence (ulift_hom_ulift_category.equiv.{v₂, u₂} J).symm⟩\n#align has_limits_of_size_shrink has_limits_of_size_shrink\n\n",
 "has_limits_of_shape_of_equivalence":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≌ » -/\n/-- We can transport limits of shape `J` along an equivalence `J ≌ J'`.\n-/\ntheorem has_limits_of_shape_of_equivalence {J' : Type u₂} [Category.{v₂} J'] (e : «expr ≌ » J J')\n    [has_limits_of_shape J C] : has_limits_of_shape J' C :=\n  by\n  constructor\n  intro F\n  apply has_limit_of_equivalence_comp e\n  infer_instance\n#align has_limits_of_shape_of_equivalence has_limits_of_shape_of_equivalence\n\n",
 "has_limits_of_shape":
 "theorem has_limits.has_limits_of_shape {C : Type u} [Category.{v} C] [has_limits C] (J : Type v) [Category.{v} J] :\n    has_limits_of_shape J C :=\n  has_limits_of_size.has_limits_of_shape J\n#align has_limits.has_limits_of_shape has_limits.has_limits_of_shape\n\n",
 "has_limit_of_iso":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≅ » -/\n/-- If a functor `F` has a limit, so does any naturally isomorphic functor.\n-/\ntheorem has_limit_of_iso {F G : «expr ⥤ » J C} [has_limit F] (α : «expr ≅ » F G) : has_limit G :=\n  has_limit.mk\n    { cone := (cones.postcompose α.hom).obj (limit.cone F)\n      is_limit :=\n        { lift := fun s => limit.lift F ((cones.postcompose α.inv).obj s)\n          fac' := fun s j =>\n            by\n            rw [cones.postcompose_obj_π, nat_trans.comp_app, limit.cone_π, ← category.assoc, limit.lift_π]\n            simp\n          uniq' := fun s m w => by\n            apply limit.hom_ext; intro j\n            rw [limit.lift_π, cones.postcompose_obj_π, nat_trans.comp_app, ← nat_iso.app_inv, iso.eq_comp_inv]\n            simpa using w j } }\n#align has_limit_of_iso has_limit_of_iso\n\n",
 "has_limit_of_equivalence_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≌ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n-- not entirely sure why this is needed\n/-- If a `E ⋙ F` has a limit, and `E` is an equivalence, we can construct a limit of `F`.\n-/\ntheorem has_limit_of_equivalence_comp (e : «expr ≌ » K J) [has_limit («expr ⋙ » e.functor F)] : has_limit F :=\n  by\n  haveI : has_limit («expr ⋙ » e.inverse («expr ⋙ » e.functor F)) := limits.has_limit_equivalence_comp e.symm\n  apply has_limit_of_iso (e.inv_fun_id_assoc F)\n#align has_limit_of_equivalence_comp has_limit_of_equivalence_comp\n\n",
 "has_colimits_of_size_shrink":
 "/-- `has_colimits_of_size_shrink.{v u} C` tries to obtain `has_colimits_of_size.{v u} C`\nfrom some other `has_colimits_of_size C`.\n-/\ntheorem has_colimits_of_size_shrink [has_colimits_of_size.{max v₁ v₂, max u₁ u₂} C] : has_colimits_of_size.{v₁, u₁} C :=\n  ⟨fun J hJ => has_colimits_of_shape_of_equivalence (ulift_hom_ulift_category.equiv.{v₂, u₂} J).symm⟩\n#align has_colimits_of_size_shrink has_colimits_of_size_shrink\n\n",
 "has_colimits_of_shape_of_equivalence":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≌ » -/\n/-- We can transport colimits of shape `J` along an equivalence `J ≌ J'`.\n-/\ntheorem has_colimits_of_shape_of_equivalence {J' : Type u₂} [Category.{v₂} J'] (e : «expr ≌ » J J')\n    [has_colimits_of_shape J C] : has_colimits_of_shape J' C :=\n  by\n  constructor\n  intro F\n  apply has_colimit_of_equivalence_comp e\n  infer_instance\n#align has_colimits_of_shape_of_equivalence has_colimits_of_shape_of_equivalence\n\n",
 "has_colimits_of_shape":
 "theorem has_colimits.has_colimits_of_shape {C : Type u} [Category.{v} C] [has_colimits C] (J : Type v)\n    [Category.{v} J] : has_colimits_of_shape J C :=\n  has_colimits_of_size.has_colimits_of_shape J\n#align has_colimits.has_colimits_of_shape has_colimits.has_colimits_of_shape\n\n",
 "has_colimit_of_iso":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≅ » -/\n-- This has the isomorphism pointing in the opposite direction than in `has_limit_of_iso`.\n-- This is intentional; it seems to help with elaboration.\n/-- If `F` has a colimit, so does any naturally isomorphic functor.\n-/\ntheorem has_colimit_of_iso {F G : «expr ⥤ » J C} [has_colimit F] (α : «expr ≅ » G F) : has_colimit G :=\n  has_colimit.mk\n    { cocone := (cocones.precompose α.hom).obj (colimit.cocone F)\n      is_colimit :=\n        { desc := fun s => colimit.desc F ((cocones.precompose α.inv).obj s)\n          fac' := fun s j => by\n            rw [cocones.precompose_obj_ι, nat_trans.comp_app, colimit.cocone_ι]\n            rw [category.assoc, colimit.ι_desc, ← nat_iso.app_hom, ← iso.eq_inv_comp]; rfl\n          uniq' := fun s m w => by\n            apply colimit.hom_ext; intro j\n            rw [colimit.ι_desc, cocones.precompose_obj_ι, nat_trans.comp_app, ← nat_iso.app_inv, iso.eq_inv_comp]\n            simpa using w j } }\n#align has_colimit_of_iso has_colimit_of_iso\n\n",
 "has_colimit_of_equivalence_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≌ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/-- If a `E ⋙ F` has a colimit, and `E` is an equivalence, we can construct a colimit of `F`.\n-/\ntheorem has_colimit_of_equivalence_comp (e : «expr ≌ » K J) [has_colimit («expr ⋙ » e.functor F)] : has_colimit F :=\n  by\n  haveI : has_colimit («expr ⋙ » e.inverse («expr ⋙ » e.functor F)) := limits.has_colimit_equivalence_comp e.symm\n  apply has_colimit_of_iso (e.inv_fun_id_assoc F).symm\n#align has_colimit_of_equivalence_comp has_colimit_of_equivalence_comp\n\n",
 "exists_unique":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem colimit.exists_unique {F : «expr ⥤ » J C} [has_colimit F] (t : cocone F) :\n    ∃! d : «expr ⟶ » (colimit F) t.X, ∀ j, «expr ≫ » (colimit.ι F j) d = t.ι.app j :=\n  (colimit.is_colimit F).exists_unique _\n#align colimit.exists_unique colimit.exists_unique\n\n",
 "desc_extend":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem colimit.desc_extend (F : «expr ⥤ » J C) [has_colimit F] (c : cocone F) {X : C} (f : «expr ⟶ » c.X X) :\n    colimit.desc F (c.extend f) = «expr ≫ » (colimit.desc F c) f := by ext1; rw [← category.assoc]; simp\n#align colimit.desc_extend colimit.desc_extend\n\n",
 "desc_cocone":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n@[simp]\ntheorem colimit.desc_cocone {F : «expr ⥤ » J C} [has_colimit F] :\n    colimit.desc F (colimit.cocone F) = («expr𝟙») (colimit F) :=\n  (colimit.is_colimit _).desc_self\n#align colimit.desc_cocone colimit.desc_cocone\n\n",
 "cone_π":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n@[simp]\ntheorem limit.cone_π {F : «expr ⥤ » J C} [has_limit F] : (limit.cone F).π.app = limit.π _ :=\n  rfl\n#align limit.cone_π limit.cone_π\n\n",
 "cone_point_unique_up_to_iso_inv_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem limit.cone_point_unique_up_to_iso_inv_comp {F : «expr ⥤ » J C} [has_limit F] {c : cone F} (hc : is_limit c)\n    (j : J) : «expr ≫ » (is_limit.cone_point_unique_up_to_iso (limit.is_limit _) hc).inv (limit.π F j) = c.π.app j :=\n  is_limit.cone_point_unique_up_to_iso_inv_comp _ _ _\n#align limit.cone_point_unique_up_to_iso_inv_comp limit.cone_point_unique_up_to_iso_inv_comp\n\n",
 "cone_point_unique_up_to_iso_hom_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem limit.cone_point_unique_up_to_iso_hom_comp {F : «expr ⥤ » J C} [has_limit F] {c : cone F} (hc : is_limit c)\n    (j : J) : «expr ≫ » (is_limit.cone_point_unique_up_to_iso hc (limit.is_limit _)).hom (limit.π F j) = c.π.app j :=\n  is_limit.cone_point_unique_up_to_iso_hom_comp _ _ _\n#align limit.cone_point_unique_up_to_iso_hom_comp limit.cone_point_unique_up_to_iso_hom_comp\n\n",
 "cone_morphism_π":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem limit.cone_morphism_π {F : «expr ⥤ » J C} [has_limit F] (c : cone F) (j : J) :\n    «expr ≫ » (limit.cone_morphism c).hom (limit.π F j) = c.π.app j := by simp\n#align limit.cone_morphism_π limit.cone_morphism_π\n\n",
 "cone_morphism_hom":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n@[simp]\ntheorem limit.cone_morphism_hom {F : «expr ⥤ » J C} [has_limit F] (c : cone F) :\n    (limit.cone_morphism c).hom = limit.lift F c :=\n  rfl\n#align limit.cone_morphism_hom limit.cone_morphism_hom\n\n",
 "cone_X":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n-- see Note [lower instance priority]\n-- see Note [lower instance priority]\n-- Interface to the `has_limit` class.\n@[simp]\ntheorem limit.cone_X {F : «expr ⥤ » J C} [has_limit F] : (limit.cone F).X = limit F :=\n  rfl\n#align limit.cone_X limit.cone_X\n\n",
 "comp_cocone_point_unique_up_to_iso_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem colimit.comp_cocone_point_unique_up_to_iso_inv {F : «expr ⥤ » J C} [has_colimit F] {c : cocone F}\n    (hc : is_colimit c) (j : J) :\n    «expr ≫ » (colimit.ι F j) (is_colimit.cocone_point_unique_up_to_iso hc (colimit.is_colimit _)).inv = c.ι.app j :=\n  is_colimit.comp_cocone_point_unique_up_to_iso_inv _ _ _\n#align colimit.comp_cocone_point_unique_up_to_iso_inv colimit.comp_cocone_point_unique_up_to_iso_inv\n\n",
 "comp_cocone_point_unique_up_to_iso_hom":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem colimit.comp_cocone_point_unique_up_to_iso_hom {F : «expr ⥤ » J C} [has_colimit F] {c : cocone F}\n    (hc : is_colimit c) (j : J) :\n    «expr ≫ » (colimit.ι F j) (is_colimit.cocone_point_unique_up_to_iso (colimit.is_colimit _) hc).hom = c.ι.app j :=\n  is_colimit.comp_cocone_point_unique_up_to_iso_hom _ _ _\n#align colimit.comp_cocone_point_unique_up_to_iso_hom colimit.comp_cocone_point_unique_up_to_iso_hom\n\n",
 "cocone_ι":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n-- see Note [lower instance priority]\n-- see Note [lower instance priority]\n-- Interface to the `has_colimit` class.\n@[simp]\ntheorem colimit.cocone_ι {F : «expr ⥤ » J C} [has_colimit F] (j : J) : (colimit.cocone F).ι.app j = colimit.ι _ j :=\n  rfl\n#align colimit.cocone_ι colimit.cocone_ι\n\n",
 "cocone_morphism_hom":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n@[simp]\ntheorem colimit.cocone_morphism_hom {F : «expr ⥤ » J C} [has_colimit F] (c : cocone F) :\n    (colimit.cocone_morphism c).hom = colimit.desc F c :=\n  rfl\n#align colimit.cocone_morphism_hom colimit.cocone_morphism_hom\n\n",
 "cocone_X":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n@[simp]\ntheorem colimit.cocone_X {F : «expr ⥤ » J C} [has_colimit F] : (colimit.cocone F).X = colimit F :=\n  rfl\n#align colimit.cocone_X colimit.cocone_X\n\n"}