{"pushout_eq_sup":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/-- The pushout in the category of a `semilattice_sup` with `order_bot` is the same as the supremum\nover the objects.\n-/\n@[simp]\ntheorem pushout_eq_sup [SemilatticeSup α] [OrderBot α] (x y z : α) (f : «expr ⟶ » z x) (g : «expr ⟶ » z y) :\n    pushout f g = «expr ⊔ » x y :=\n  calc\n    pushout f g = colimit (span f g) := rfl\n    _ = Finset.univ.sup (span f g).obj := by rw [finite_colimit_eq_finset_univ_sup]\n    _ = «expr ⊔ » z («expr ⊔ » x («expr ⊔ » y («expr⊥»))) := rfl\n    _ = «expr ⊔ » z («expr ⊔ » x y) := by rw [sup_bot_eq]\n    _ = «expr ⊔ » x y := sup_eq_right.mpr (le_sup_of_le_left f.le)\n    \n#align pushout_eq_sup pushout_eq_sup\n\n",
 "pullback_eq_inf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/-- The pullback in the category of a `semilattice_inf` with `order_top` is the same as the infimum\nover the objects.\n-/\n@[simp]\ntheorem pullback_eq_inf [SemilatticeInf α] [OrderTop α] {x y z : α} (f : «expr ⟶ » x z) (g : «expr ⟶ » y z) :\n    pullback f g = «expr ⊓ » x y :=\n  calc\n    pullback f g = limit (cospan f g) := rfl\n    _ = Finset.univ.inf (cospan f g).obj := by rw [finite_limit_eq_finset_univ_inf]\n    _ = «expr ⊓ » z («expr ⊓ » x («expr ⊓ » y («expr⊤»))) := rfl\n    _ = «expr ⊓ » z («expr ⊓ » x y) := by rw [inf_top_eq]\n    _ = «expr ⊓ » x y := inf_eq_right.mpr (inf_le_of_left_le f.le)\n    \n#align pullback_eq_inf pullback_eq_inf\n\n",
 "prod_eq_inf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n-- see Note [lower instance priority]\n/-- The binary product in the category of a `semilattice_inf` with `order_top` is the same as the\ninfimum.\n-/\n@[simp]\ntheorem prod_eq_inf [SemilatticeInf α] [OrderTop α] (x y : α) : Limits.prod x y = «expr ⊓ » x y :=\n  calc\n    Limits.prod x y = limit (pair x y) := rfl\n    _ = Finset.univ.inf (pair x y).obj := by rw [finite_limit_eq_finset_univ_inf (pair.{u} x y)]\n    _ = «expr ⊓ » x («expr ⊓ » y («expr⊤»)) := rfl\n    -- Note: finset.inf is realized as a fold, hence the definitional equality\n        _ =\n        «expr ⊓ » x y :=\n      by rw [inf_top_eq]\n    \n#align prod_eq_inf prod_eq_inf\n\n",
 "limit_eq_infi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n-- It would be nice to only use the `Inf` half of the complete lattice, but\n-- this seems not to have been described separately.\n-- see Note [lower instance priority]\n-- see Note [lower instance priority]\n/-- The limit of a functor into a complete lattice is the infimum of the objects in the image.\n-/\ntheorem limit_eq_infi (F : «expr ⥤ » J α) : limit F = infᵢ F.obj :=\n  (IsLimit.conePointUniqueUpToIso (limit.isLimit F) (limitCone F).is_limit).to_eq\n#align limit_eq_infi limit_eq_infi\n\n",
 "finite_product_eq_finset_inf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∏ » -/\n/-- A finite product in the category of a `semilattice_inf` with `order_top` is the same as the infimum.\n-/\ntheorem finite_product_eq_finset_inf [SemilatticeInf α] [OrderTop α] {ι : Type u} [Fintype ι] (f : ι → α) :\n    «expr∏ » f = (fintype.elems ι).inf f := by\n  trans\n  exact\n    (is_limit.cone_point_unique_up_to_iso (limit.is_limit _) (finite_limit_cone (discrete.functor f)).is_limit).to_eq\n  change finset.univ.inf (f ∘ discrete_equiv.to_embedding) = (fintype.elems ι).inf f\n  simp only [← Finset.inf_map, Finset.univ_map_equiv_to_embedding]\n  rfl\n#align finite_product_eq_finset_inf finite_product_eq_finset_inf\n\n",
 "finite_limit_eq_finset_univ_inf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/-\nCopyright (c) 2019 Scott Morrison. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Scott Morrison, Justus Springer\n-/\n-- see Note [lower instance priority]\n-- see Note [lower instance priority]\n/-- The limit of a functor from a finite diagram into a `semilattice_inf` with `order_top` is the\ninfimum of the objects in the image.\n-/\ntheorem finite_limit_eq_finset_univ_inf [SemilatticeInf α] [OrderTop α] (F : «expr ⥤ » J α) :\n    limit F = Finset.univ.inf F.obj :=\n  (IsLimit.conePointUniqueUpToIso (limit.isLimit F) (finiteLimitCone F).is_limit).to_eq\n#align finite_limit_eq_finset_univ_inf finite_limit_eq_finset_univ_inf\n\n",
 "finite_coproduct_eq_finset_sup":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∐ » -/\n/-- A finite coproduct in the category of a `semilattice_sup` with `order_bot` is the same as the\nsupremum.\n-/\ntheorem finite_coproduct_eq_finset_sup [SemilatticeSup α] [OrderBot α] {ι : Type u} [Fintype ι] (f : ι → α) :\n    «expr∐ » f = (fintype.elems ι).sup f := by\n  trans\n  exact\n    (is_colimit.cocone_point_unique_up_to_iso (colimit.is_colimit _)\n        (finite_colimit_cocone (discrete.functor f)).is_colimit).to_eq\n  change finset.univ.sup (f ∘ discrete_equiv.to_embedding) = (fintype.elems ι).sup f\n  simp only [← Finset.sup_map, Finset.univ_map_equiv_to_embedding]\n  rfl\n#align finite_coproduct_eq_finset_sup finite_coproduct_eq_finset_sup\n\n",
 "finite_colimit_eq_finset_univ_sup":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/-- The colimit of a functor from a finite diagram into a `semilattice_sup` with `order_bot`\nis the supremum of the objects in the image.\n-/\ntheorem finite_colimit_eq_finset_univ_sup [SemilatticeSup α] [OrderBot α] (F : «expr ⥤ » J α) :\n    colimit F = Finset.univ.sup F.obj :=\n  (IsColimit.coconePointUniqueUpToIso (colimit.isColimit F) (finiteColimitCocone F).is_colimit).to_eq\n#align finite_colimit_eq_finset_univ_sup finite_colimit_eq_finset_univ_sup\n\n",
 "coprod_eq_sup":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n-- see Note [lower instance priority]\n/-- The binary coproduct in the category of a `semilattice_sup` with `order_bot` is the same as the\nsupremum.\n-/\n@[simp]\ntheorem coprod_eq_sup [SemilatticeSup α] [OrderBot α] (x y : α) : Limits.coprod x y = «expr ⊔ » x y :=\n  calc\n    Limits.coprod x y = colimit (pair x y) := rfl\n    _ = Finset.univ.sup (pair x y).obj := by rw [finite_colimit_eq_finset_univ_sup (pair x y)]\n    _ = «expr ⊔ » x («expr ⊔ » y («expr⊥»)) := rfl\n    -- Note: finset.sup is realized as a fold, hence the definitional equality\n        _ =\n        «expr ⊔ » x y :=\n      by rw [sup_bot_eq]\n    \n#align coprod_eq_sup coprod_eq_sup\n\n",
 "colimit_eq_supr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/-- The colimit of a functor into a complete lattice is the supremum of the objects in the image.\n-/\ntheorem colimit_eq_supr (F : «expr ⥤ » J α) : colimit F = supᵢ F.obj :=\n  (IsColimit.coconePointUniqueUpToIso (colimit.isColimit F) (colimitCocone F).is_colimit).to_eq\n#align colimit_eq_supr colimit_eq_supr\n\n"}