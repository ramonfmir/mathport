{"mono_inl_iff":
 "theorem mono_inl_iff {A B : C} {c₁ c₂ : binary_cofan A B} (hc₁ : is_colimit c₁) (hc₂ : is_colimit c₂) :\n    Mono c₁.inl ↔ Mono c₂.inl :=\n  by\n  suffices ∀ (c₁ c₂ : binary_cofan A B) (hc₁ : is_colimit c₁) (hc₂ : is_colimit c₂) (h : mono c₁.inl), mono c₂.inl by\n    exact ⟨fun h₁ => this _ _ hc₁ hc₂ h₁, fun h₂ => this _ _ hc₂ hc₁ h₂⟩\n  intro c₁ c₂ hc₁ hc₂\n  intro\n  simpa only [is_colimit.comp_cocone_point_unique_up_to_iso_hom] using\n    mono_comp c₁.inl (hc₁.cocone_point_unique_up_to_iso hc₂).hom\n#align mono_inl_iff mono_inl_iff\n\n",
 "mk'":
 "theorem mk' (h : ∀ A B : C, ∃ (c : binary_cofan A B)(hc : is_colimit c), Mono c.inl) : mono_coprod C :=\n  ⟨fun A B c' hc' => by\n    obtain ⟨c, hc₁, hc₂⟩ := h A B\n    simpa only [mono_inl_iff hc' hc₁] using hc₂⟩\n#align mk' mk'\n\n",
 "binary_cofan_inr":
 "/-\nCopyright (c) 2022 Joël Riou. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Joël Riou\n-/\ntheorem binary_cofan_inr {A B : C} [mono_coprod C] (c : binary_cofan A B) (hc : is_colimit c) : Mono c.inr :=\n  haveI hc' : is_colimit (binary_cofan.mk c.inr c.inl) :=\n    binary_cofan.is_colimit_mk (fun s => hc.desc (binary_cofan.mk s.inr s.inl)) (by tidy) (by tidy) fun s m h₁ h₂ =>\n      binary_cofan.is_colimit.hom_ext hc\n        (by simp only [h₂, is_colimit.fac, binary_cofan.ι_app_left, binary_cofan.mk_inl])\n        (by simp only [h₁, is_colimit.fac, binary_cofan.ι_app_right, binary_cofan.mk_inr])\n  binary_cofan_inl _ hc'\n#align binary_cofan_inr binary_cofan_inr\n\n"}