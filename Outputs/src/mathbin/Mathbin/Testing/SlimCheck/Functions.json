{"injective":
 "protected theorem injective [DecidableEq α] (f : injective_function α) : injective (apply f) :=\n  by\n  cases' f with xs hperm hnodup\n  generalize h₀ : map Sigma.fst xs = xs₀\n  generalize h₁ : xs.map (@id ((Σ_ : α, α) → α) <| @Sigma.snd α fun _ : α => α) = xs₁\n  dsimp [id] at h₁\n  have hxs : xs = total_function.list.to_finmap' (xs₀.zip xs₁) :=\n    by\n    rw [← h₀, ← h₁, list.to_finmap']\n    clear h₀ h₁ xs₀ xs₁ hperm hnodup\n    induction xs\n    case nil => simp only [zip_nil_right, map_nil]\n    case\n      cons xs_hd xs_tl xs_ih =>\n      simp only [true_and_iff, to_sigma, eq_self_iff_true, Sigma.eta, zip_cons_cons, list.map]\n      exact xs_ih\n  revert hperm hnodup\n  rw [hxs]\n  intros\n  apply apply_id_injective\n  · rwa [← h₀, hxs, hperm.nodup_iff]\n  · rwa [← hxs, h₀, h₁] at hperm\n#align injective injective\n\n",
 "apply_id_zip_eq":
 "theorem list.apply_id_zip_eq [DecidableEq α] {xs ys : List α} (h₀ : List.Nodup xs) (h₁ : xs.length = ys.length)\n    (x y : α) (i : ℕ) (h₂ : xs.nth i = some x) : list.apply_id.{u} (xs.zip ys) x = y ↔ ys.nth i = some y :=\n  by\n  induction xs generalizing ys i\n  case nil ys i h₁ h₂ => cases h₂\n  case cons x' xs xs_ih ys i h₁ h₂ =>\n    cases i\n    · injection h₂ with h₀ h₁\n      subst h₀\n      cases ys\n      · cases h₁\n      · simp only [list.apply_id, to_sigma, option.get_or_else_some, nth, lookup_cons_eq, zip_cons_cons, list.map]\n    · cases ys\n      · cases h₁\n      · cases' h₀ with _ _ h₀ h₁\n        simp only [nth, zip_cons_cons, list.apply_id_cons] at h₂⊢\n        rw [if_neg]\n        · apply xs_ih <;> solve_by_elim [succ.inj]\n        · apply h₀\n          apply nth_mem h₂\n#align list.apply_id_zip_eq list.apply_id_zip_eq\n\n",
 "apply_id_mem_iff":
 "/- ./././Mathport/Syntax/Translate/Tactic/Lean3.lean:564:6: unsupported: specialize @hyp -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\ntheorem apply_id_mem_iff [DecidableEq α] {xs ys : List α} (h₀ : List.Nodup xs) (h₁ : list.perm xs ys) (x : α) :\n    list.apply_id.{u} (xs.zip ys) x ∈ ys ↔ x ∈ xs :=\n  by\n  simp only [list.apply_id]\n  cases h₃ : lookup x (map Prod.toSigma (xs.zip ys))\n  · dsimp [Option.getD]\n    rw [h₁.mem_iff]\n  · have h₂ : ys.nodup := h₁.nodup_iff.1 h₀\n    replace h₁ : xs.length = ys.length := h₁.length_eq\n    dsimp\n    induction xs generalizing ys\n    case nil ys h₃ h₂ h₁ => contradiction\n    case cons x' xs xs_ih ys h₃ h₂ h₁ =>\n      cases' ys with y ys\n      · cases h₃\n      dsimp [lookup] at h₃; split_ifs  at h₃\n      · subst x'\n        subst val\n        simp only [mem_cons_iff, true_or_iff, eq_self_iff_true]\n      · cases' h₀ with _ _ h₀ h₅\n        cases' h₂ with _ _ h₂ h₄\n        have h₆ := nat.succ.inj h₁\n        specialize xs_ih h₅ ys h₃ h₄ h₆\n        simp only [ne.symm h, xs_ih, mem_cons_iff, false_or_iff]\n        suffices : val ∈ ys\n        tauto\n        erw [← Option.mem_def, mem_lookup_iff] at h₃\n        simp only [to_sigma, mem_map, heq_iff_eq, Prod.exists] at h₃\n        rcases h₃ with ⟨a, b, h₃, h₄, h₅⟩\n        subst a\n        subst b\n        apply (mem_zip h₃).2\n        simp only [nodupkeys, keys, comp, Prod.fst_toSigma, map_map]\n        rwa [map_fst_zip _ _ (le_of_eq h₆)]\n#align apply_id_mem_iff apply_id_mem_iff\n\n",
 "apply_id_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\ntheorem apply_id_injective [DecidableEq α] {xs ys : List α} (h₀ : List.Nodup xs) (h₁ : list.perm xs ys) :\n    injective.{u + 1, u + 1} (list.apply_id (xs.zip ys)) :=\n  by\n  intro x y h\n  by_cases hx : x ∈ xs <;> by_cases hy : y ∈ xs\n  · rw [mem_iff_nth] at hx hy\n    cases' hx with i hx\n    cases' hy with j hy\n    suffices some x = some y by injection this\n    have h₂ := h₁.length_eq\n    rw [list.apply_id_zip_eq h₀ h₂ _ _ _ hx] at h\n    rw [← hx, ← hy]\n    congr\n    apply nth_injective _ (h₁.nodup_iff.1 h₀)\n    · symm\n      rw [h]\n      rw [← list.apply_id_zip_eq] <;> assumption\n    · rw [← h₁.length_eq]\n      rw [nth_eq_some] at hx\n      cases' hx with hx hx'\n      exact hx\n  · rw [← apply_id_mem_iff h₀ h₁] at hx hy\n    rw [h] at hx\n    contradiction\n  · rw [← apply_id_mem_iff h₀ h₁] at hx hy\n    rw [h] at hx\n    contradiction\n  · rwa [list.apply_id_eq_self, list.apply_id_eq_self] at h <;> assumption\n#align apply_id_injective apply_id_injective\n\n",
 "apply_id_eq_self":
 "theorem list.apply_id_eq_self [DecidableEq α] {xs ys : List α} (x : α) : x ∉ xs → list.apply_id.{u} (xs.zip ys) x = x :=\n  by\n  intro h\n  dsimp [list.apply_id]\n  rw [lookup_eq_none.2]; rfl\n  simp only [keys, not_exists, to_sigma, exists_and_right, exists_eq_right, mem_map, comp_app, map_map, Prod.exists]\n  intro y hy\n  exact h (mem_zip hy).1\n#align list.apply_id_eq_self list.apply_id_eq_self\n\n",
 "apply_id_cons":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `stream.cons -/\n/-\nCopyright (c) 2020 Simon Hudon. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Simon Hudon\n-/\n-- TODO: support a non-constant codomain type\n@[simp]\ntheorem list.apply_id_cons [DecidableEq α] (xs : List (α × α)) (x y z : α) :\n    list.apply_id (stream.cons (y, z) xs) x = if y = x then z else list.apply_id xs x := by\n  simp only [list.apply_id, List.dlookup, eq_rec_constant, Prod.toSigma, list.map] <;> split_ifs <;> rfl\n#align list.apply_id_cons list.apply_id_cons\n\n"}