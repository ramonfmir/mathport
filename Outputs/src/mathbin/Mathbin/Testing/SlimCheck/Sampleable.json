{"sizeof_drop_lt_sizeof_of_lt_length":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `stream.cons -/\n/-\nCopyright (c) 2020 Simon Hudon. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Simon Hudon\n-/\ntheorem list.sizeof_drop_lt_sizeof_of_lt_length {xs : List α} {k} (hk : 0 < k) (hk' : k < xs.length) :\n    SizeOf.sizeOf (list.drop k xs) < SizeOf.sizeOf xs :=\n  by\n  induction' xs with x xs generalizing k\n  · cases hk'\n  cases k\n  · cases hk\n  have : SizeOf.sizeOf xs < SizeOf.sizeOf (stream.cons x xs) := by unfold_wf\n  cases k\n  · simp only [this, list.drop]\n  · simp only [list.drop]\n    trans\n    · solve_by_elim [xs_ih, lt_of_succ_lt_succ hk', zero_lt_succ]\n    · assumption\n#align list.sizeof_drop_lt_sizeof_of_lt_length list.sizeof_drop_lt_sizeof_of_lt_length\n\n",
 "sizeof_cons_lt_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `stream.cons -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `stream.cons -/\ntheorem list.sizeof_cons_lt_right (a b : α) {xs : List α} (h : SizeOf.sizeOf a < SizeOf.sizeOf b) :\n    SizeOf.sizeOf (stream.cons a xs) < SizeOf.sizeOf (stream.cons b xs) := by unfold_wf <;> assumption\n#align list.sizeof_cons_lt_right list.sizeof_cons_lt_right\n\n",
 "sizeof_cons_lt_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `stream.cons -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `stream.cons -/\ntheorem list.sizeof_cons_lt_left (x : α) {xs xs' : List α} (h : SizeOf.sizeOf xs < SizeOf.sizeOf xs') :\n    SizeOf.sizeOf (stream.cons x xs) < SizeOf.sizeOf (stream.cons x xs') := by unfold_wf <;> assumption\n#align list.sizeof_cons_lt_left list.sizeof_cons_lt_left\n\n",
 "sizeof_append_lt_left":
 "theorem list.sizeof_append_lt_left {xs ys ys' : List α} (h : SizeOf.sizeOf ys < SizeOf.sizeOf ys') :\n    SizeOf.sizeOf (xs ++ ys) < SizeOf.sizeOf (xs ++ ys') :=\n  by\n  induction xs\n  · apply h\n  · unfold_wf\n    simp only [list.sizeof, add_lt_add_iff_left]\n    exact xs_ih\n#align list.sizeof_append_lt_left list.sizeof_append_lt_left\n\n",
 "rec_shrink_with_eq":
 "theorem rec_shrink_with_eq [SizeOf α]\n    (shrink_a : ∀ x : α, shrink_fn { y : α // sizeof_lt y x } → List (LazyList { y : α // sizeof_lt y x })) (x : α) :\n    rec_shrink_with shrink_a x =\n      LazyList.join (LazyList.ofList <| shrink_a x fun t' => rec_shrink _ (fun x h' => rec_shrink_with shrink_a x) _) :=\n  by\n  conv_lhs => rw [rec_shrink_with, well_founded.fix_eq]\n  congr ; ext ⟨y, h⟩; rfl\n#align rec_shrink_with_eq rec_shrink_with_eq\n\n",
 "one_le_sizeof":
 "theorem tree.one_le_sizeof {α} [SizeOf α] (t : Tree α) : 1 ≤ SizeOf.sizeOf t := by cases t <;> unfold_wf <;> linarith\n#align tree.one_le_sizeof tree.one_le_sizeof\n\n"}