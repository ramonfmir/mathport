{"prime_of_aleph_0_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n@[simp]\ntheorem prime_of_aleph_0_le (ha : cardinal.aleph_0 ≤ a) : Prime a :=\n  by\n  refine' ⟨(aleph_0_pos.trans_le ha).ne', _, fun b c hbc => _⟩\n  · rw [is_unit_iff]\n    exact (one_lt_aleph_0.trans_le ha).ne'\n  cases' eq_or_ne (b * c) 0 with hz hz\n  · rcases mul_eq_zero.mp hz with (rfl | rfl) <;> simp\n  wlog h : c ≤ b\n  · cases le_total c b <;> [skip, rw [or_comm']] <;> apply_assumption\n    assumption'\n    all_goals rwa [mul_comm]\n  left\n  have habc := le_of_dvd hz hbc\n  rwa [mul_eq_max' <| ha.trans <| habc, max_def', if_pos h] at hbc\n#align prime_of_aleph_0_le prime_of_aleph_0_le\n\n",
 "not_irreducible_of_aleph_0_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\ntheorem not_irreducible_of_aleph_0_le (ha : cardinal.aleph_0 ≤ a) : ¬Irreducible a :=\n  by\n  rw [irreducible_iff, not_and_or]\n  refine' or.inr fun h => _\n  simpa [mul_aleph_0_eq ha, is_unit_iff, (one_lt_aleph_0.trans_le ha).ne', one_lt_aleph_0.ne'] using\n    h a (cardinal.aleph_0)\n#align not_irreducible_of_aleph_0_le not_irreducible_of_aleph_0_le\n\n",
 "nat_is_prime_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n@[simp]\ntheorem nat_is_prime_iff : Prime (n : Cardinal) ↔ n.prime :=\n  by\n  simp only [Prime, Nat.prime_iff]\n  refine' and_congr (by simp) (and_congr _ ⟨fun h b c hbc => _, fun h b c hbc => _⟩)\n  · simp only [is_unit_iff, Nat.isUnit_iff]\n    exact_mod_cast iff.rfl\n  · exact_mod_cast h b c (by exact_mod_cast hbc)\n  cases' lt_or_le (b * c) (cardinal.aleph_0) with h' h'\n  · rcases mul_lt_aleph_0_iff.mp h' with (rfl | rfl | ⟨hb, hc⟩)\n    · simp\n    · simp\n    lift b to ℕ using hb\n    lift c to ℕ using hc\n    exact_mod_cast h b c (by exact_mod_cast hbc)\n  rcases aleph_0_le_mul_iff.mp h' with ⟨hb, hc, hℵ₀⟩\n  have hn : (n : Cardinal) ≠ 0 := by\n    intro h\n    rw [h, zero_dvd_iff, mul_eq_zero] at hbc\n    cases hbc <;> contradiction\n  wlog hℵ₀b : cardinal.aleph_0 ≤ b\n  · refine' (this h c b _ _ hc hb hℵ₀.symm hn (hℵ₀.resolve_left hℵ₀b)).symm <;> rwa [mul_comm]\n  exact or.inl (dvd_of_le_of_aleph_0_le hn ((nat_lt_aleph_0 n).le.trans hℵ₀b) hℵ₀b)\n#align nat_is_prime_iff nat_is_prime_iff\n\n",
 "nat_coe_dvd_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n@[simp, norm_cast]\ntheorem nat_coe_dvd_iff : (n : Cardinal) ∣ m ↔ n ∣ m :=\n  by\n  refine' ⟨_, fun ⟨h, ht⟩ => ⟨h, by exact_mod_cast ht⟩⟩\n  rintro ⟨k, hk⟩\n  have : ↑m < cardinal.aleph_0 := nat_lt_aleph_0 m\n  rw [hk, mul_lt_aleph_0_iff] at this\n  rcases this with (h | h | ⟨-, hk'⟩)\n  iterate 2 simp only [h, MulZeroClass.mul_zero, MulZeroClass.zero_mul, Nat.cast_eq_zero] at hk; simp [hk]\n  lift k to ℕ using hk'\n  exact ⟨k, by exact_mod_cast hk⟩\n#align nat_coe_dvd_iff nat_coe_dvd_iff\n\n",
 "le_of_dvd":
 "theorem le_of_dvd : ∀ {a b : Cardinal}, b ≠ 0 → a ∣ b → a ≤ b\n  | a, _, b0, ⟨b, rfl⟩ => by\n    simpa only [mul_one] using\n      mul_le_mul_left' (one_le_iff_ne_zero.2 fun h : b = 0 => by simpa only [h, MulZeroClass.mul_zero] using b0) a\n#align le_of_dvd le_of_dvd\n\n",
 "is_unit_iff":
 "/-\nCopyright (c) 2022 Eric Rodriguez. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Rodriguez\n-/\n@[simp]\ntheorem is_unit_iff : IsUnit a ↔ a = 1 :=\n  by\n  refine'\n    ⟨fun h => _, by\n      rintro rfl\n      exact isUnit_one⟩\n  rcases eq_or_ne a 0 with (rfl | ha)\n  · exact (not_isUnit_zero h).elim\n  rw [isUnit_iff_forall_dvd] at h\n  cases' h 1 with t ht\n  rw [eq_comm, mul_eq_one_iff'] at ht\n  · exact ht.1\n  all_goals rwa [one_le_iff_ne_zero]\n  · rintro rfl\n    rw [MulZeroClass.mul_zero] at ht\n    exact zero_ne_one ht\n#align is_unit_iff is_unit_iff\n\n",
 "is_prime_pow_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\ntheorem is_prime_pow_iff {a : Cardinal} : IsPrimePow a ↔ cardinal.aleph_0 ≤ a ∨ ∃ n : ℕ, a = n ∧ IsPrimePow n :=\n  by\n  by_cases h : cardinal.aleph_0 ≤ a\n  · simp [h, (prime_of_aleph_0_le h).is_prime_pow]\n  lift a to ℕ using not_le.mp h\n  simp only [h, Nat.cast_inj, exists_eq_left', false_or_iff, isPrimePow_nat_iff]\n  rw [isPrimePow_def]\n  refine' ⟨_, fun ⟨p, k, hp, hk, h⟩ => ⟨p, k, nat_is_prime_iff.2 hp, by exact_mod_cast and.intro hk h⟩⟩\n  rintro ⟨p, k, hp, hk, hpk⟩\n  have key : _ ≤ p ^ k := power_le_power_left hp.ne_zero (show (1 : Cardinal) ≤ k by exact_mod_cast hk)\n  rw [power_one, hpk] at key\n  lift p to ℕ using key.trans_lt (nat_lt_aleph_0 a)\n  exact ⟨p, k, nat_is_prime_iff.mp hp, hk, by exact_mod_cast hpk⟩\n#align is_prime_pow_iff is_prime_pow_iff\n\n",
 "is_prime_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\ntheorem is_prime_iff {a : Cardinal} : Prime a ↔ cardinal.aleph_0 ≤ a ∨ ∃ p : ℕ, a = p ∧ p.prime :=\n  by\n  cases' le_or_lt (cardinal.aleph_0) a with h h\n  · simp [h]\n  lift a to ℕ using id h\n  simp [not_le.mpr h]\n#align is_prime_iff is_prime_iff\n\n",
 "dvd_of_le_of_aleph_0_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\ntheorem dvd_of_le_of_aleph_0_le (ha : a ≠ 0) (h : a ≤ b) (hb : cardinal.aleph_0 ≤ b) : a ∣ b :=\n  ⟨b, (mul_eq_right hb h ha).symm⟩\n#align dvd_of_le_of_aleph_0_le dvd_of_le_of_aleph_0_le\n\n"}