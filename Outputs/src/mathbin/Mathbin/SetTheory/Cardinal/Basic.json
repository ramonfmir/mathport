{"zero_to_nat":
 "@[simp]\ntheorem zero_to_nat : to_nat 0 = 0 := by rw [← to_nat_cast 0, Nat.cast_zero]\n#align zero_to_nat zero_to_nat\n\n",
 "zero_powerlt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^< » -/\ntheorem zero_powerlt {a : cardinal} (h : a ≠ 0) : «expr ^< » 0 a = 1 :=\n  by\n  apply (powerlt_le.2 fun c hc => zero_power_le _).antisymm\n  rw [← power_zero]\n  exact le_powerlt 0 (pos_iff_ne_zero.2 h)\n#align zero_powerlt zero_powerlt\n\n",
 "zero_power_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.pow -/\ntheorem zero_power_le (c : cardinal.{u}) : cardinal.pow (0 : cardinal.{u}) c ≤ 1 :=\n  by\n  by_cases h : c = 0\n  rw [h, power_zero]\n  rw [zero_power h]\n  apply zero_le\n#align zero_power_le zero_power_le\n\n",
 "zero_power":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.pow -/\n@[simp]\ntheorem zero_power {a : cardinal} : a ≠ 0 → cardinal.pow 0 a = 0 :=\n  induction_on a fun α heq =>\n    mk_eq_zero_iff.2 <|\n      isEmpty_pi.2 <|\n        let ⟨a⟩ := mk_ne_zero_iff.1 HEq\n        ⟨a, pempty.is_empty⟩\n#align zero_power zero_power\n\n",
 "zero_le":
 "#print zero_le /-\nprotected theorem zero_le : ∀ a : cardinal, 0 ≤ a := by rintro ⟨α⟩ <;> exact ⟨embedding.of_is_empty⟩\n#align zero_le zero_le\n-/\n\n",
 "two_le_iff'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem two_le_iff' (x : α) : (2 : cardinal) ≤ cardinal.mk α ↔ ∃ y : α, y ≠ x := by\n  rw [two_le_iff, ← nontrivial_iff, nontrivial_iff_exists_ne x]\n#align two_le_iff' two_le_iff'\n\n",
 "two_le_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem two_le_iff : (2 : cardinal) ≤ cardinal.mk α ↔ ∃ x y : α, x ≠ y := by\n  rw [← Nat.cast_two, nat_succ, succ_le_iff, Nat.cast_one, one_lt_iff_nontrivial, nontrivial_iff]\n#align two_le_iff two_le_iff\n\n",
 "to_part_enat_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\ntheorem to_part_enat_surjective : surjective to_part_enat := fun x =>\n  part_enat.cases_on x ⟨cardinal.aleph_0, to_part_enat_apply_of_aleph_0_le le_rfl⟩ fun n => ⟨n, to_part_enat_cast n⟩\n#align to_part_enat_surjective to_part_enat_surjective\n\n",
 "to_part_enat_cast":
 "@[simp]\ntheorem to_part_enat_cast (n : ℕ) : cardinal.to_part_enat n = n := by\n  rw [to_part_enat_apply_of_lt_aleph_0 (nat_lt_aleph_0 n), to_nat_cast]\n#align to_part_enat_cast to_part_enat_cast\n\n",
 "to_part_enat_apply_of_lt_aleph_0":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\ntheorem to_part_enat_apply_of_lt_aleph_0 {c : cardinal} (h : c < cardinal.aleph_0) : c.to_part_enat = c.to_nat :=\n  if_pos h\n#align to_part_enat_apply_of_lt_aleph_0 to_part_enat_apply_of_lt_aleph_0\n\n",
 "to_part_enat_apply_of_aleph_0_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem to_part_enat_apply_of_aleph_0_le {c : cardinal} (h : cardinal.aleph_0 ≤ c) : c.to_part_enat = «expr⊤» :=\n  if_neg h.not_lt\n#align to_part_enat_apply_of_aleph_0_le to_part_enat_apply_of_aleph_0_le\n\n",
 "to_nat_surjective":
 "theorem to_nat_surjective : surjective to_nat :=\n  to_nat_right_inverse.surjective\n#align to_nat_surjective to_nat_surjective\n\n",
 "to_nat_right_inverse":
 "/-- `to_nat` has a right-inverse: coercion. -/\ntheorem to_nat_right_inverse : function.right_inverse (coe : ℕ → cardinal) to_nat :=\n  to_nat_cast\n#align to_nat_right_inverse to_nat_right_inverse\n\n",
 "to_nat_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n@[simp]\ntheorem to_nat_mul (x y : cardinal) : (x * y).to_nat = x.to_nat * y.to_nat :=\n  by\n  rcases eq_or_ne x 0 with (rfl | hx1)\n  · rw [zero_mul, zero_to_nat, zero_mul]\n  rcases eq_or_ne y 0 with (rfl | hy1)\n  · rw [mul_zero, zero_to_nat, mul_zero]\n  cases' lt_or_le x (cardinal.aleph_0) with hx2 hx2\n  · cases' lt_or_le y (cardinal.aleph_0) with hy2 hy2\n    · lift x to ℕ using hx2\n      lift y to ℕ using hy2\n      rw [← nat.cast_mul, to_nat_cast, to_nat_cast, to_nat_cast]\n    · rw [to_nat_apply_of_aleph_0_le hy2, mul_zero, to_nat_apply_of_aleph_0_le]\n      exact aleph_0_le_mul_iff'.2 (or.inl ⟨hx1, hy2⟩)\n  · rw [to_nat_apply_of_aleph_0_le hx2, zero_mul, to_nat_apply_of_aleph_0_le]\n    exact aleph_0_le_mul_iff'.2 (or.inr ⟨hx2, hy1⟩)\n#align to_nat_mul to_nat_mul\n\n",
 "to_nat_lt_of_lt_of_lt_aleph_0":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\ntheorem to_nat_lt_of_lt_of_lt_aleph_0 {c d : cardinal} (hd : d < cardinal.aleph_0) (hcd : c < d) :\n    c.to_nat < d.to_nat :=\n  (to_nat_lt_iff_lt_of_lt_aleph_0 (hcd.trans hd) hd).mpr hcd\n#align to_nat_lt_of_lt_of_lt_aleph_0 to_nat_lt_of_lt_of_lt_aleph_0\n\n",
 "to_nat_lt_iff_lt_of_lt_aleph_0":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\ntheorem to_nat_lt_iff_lt_of_lt_aleph_0 {c d : cardinal} (hc : c < cardinal.aleph_0) (hd : d < cardinal.aleph_0) :\n    c.to_nat < d.to_nat ↔ c < d := by rw [← nat_cast_lt, cast_to_nat_of_lt_aleph_0 hc, cast_to_nat_of_lt_aleph_0 hd]\n#align to_nat_lt_iff_lt_of_lt_aleph_0 to_nat_lt_iff_lt_of_lt_aleph_0\n\n",
 "to_nat_lift":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n@[simp]\ntheorem to_nat_lift (c : cardinal.{v}) : (lift.{u, v} c).to_nat = c.to_nat :=\n  by\n  apply nat_cast_injective\n  cases' lt_or_ge c (cardinal.aleph_0) with hc hc\n  · rw [cast_to_nat_of_lt_aleph_0, ← lift_nat_cast, cast_to_nat_of_lt_aleph_0 hc]\n    rwa [← lift_aleph_0, lift_lt]\n  · rw [cast_to_nat_of_aleph_0_le, ← lift_nat_cast, cast_to_nat_of_aleph_0_le hc, lift_zero]\n    rwa [← lift_aleph_0, lift_le]\n#align to_nat_lift to_nat_lift\n\n",
 "to_nat_le_of_le_of_lt_aleph_0":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\ntheorem to_nat_le_of_le_of_lt_aleph_0 {c d : cardinal} (hd : d < cardinal.aleph_0) (hcd : c ≤ d) :\n    c.to_nat ≤ d.to_nat :=\n  (to_nat_le_iff_le_of_lt_aleph_0 (hcd.trans_lt hd) hd).mpr hcd\n#align to_nat_le_of_le_of_lt_aleph_0 to_nat_le_of_le_of_lt_aleph_0\n\n",
 "to_nat_le_iff_le_of_lt_aleph_0":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\ntheorem to_nat_le_iff_le_of_lt_aleph_0 {c d : cardinal} (hc : c < cardinal.aleph_0) (hd : d < cardinal.aleph_0) :\n    c.to_nat ≤ d.to_nat ↔ c ≤ d := by rw [← nat_cast_le, cast_to_nat_of_lt_aleph_0 hc, cast_to_nat_of_lt_aleph_0 hd]\n#align to_nat_le_iff_le_of_lt_aleph_0 to_nat_le_iff_le_of_lt_aleph_0\n\n",
 "to_nat_finset_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\ntheorem to_nat_finset_prod (s : Finset α) (f : α → cardinal) :\n    to_nat (finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f i)) =\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s\n        (to_nat (f i)) :=\n  map_prod to_nat_hom _ _\n#align to_nat_finset_prod to_nat_finset_prod\n\n",
 "to_nat_eq_one_iff_unique":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem to_nat_eq_one_iff_unique {α : Type _} : (cardinal.mk α).to_nat = 1 ↔ subsingleton α ∧ nonempty α :=\n  to_nat_eq_one.trans eq_one_iff_unique\n#align to_nat_eq_one_iff_unique to_nat_eq_one_iff_unique\n\n",
 "to_nat_eq_one":
 "@[simp]\ntheorem to_nat_eq_one {c : cardinal} : to_nat c = 1 ↔ c = 1 := by rw [to_nat_eq_iff one_ne_zero, Nat.cast_one]\n#align to_nat_eq_one to_nat_eq_one\n\n",
 "to_nat_eq_iff":
 "theorem to_nat_eq_iff {c : cardinal} {n : ℕ} (hn : n ≠ 0) : to_nat c = n ↔ c = n :=\n  ⟨fun h =>\n    (cast_to_nat_of_lt_aleph_0 (lt_of_not_ge (hn ∘ h.symm.trans ∘ to_nat_apply_of_aleph_0_le))).symm.trans\n      (congr_arg coe h),\n    fun h => (congr_arg to_nat h).trans (to_nat_cast n)⟩\n#align to_nat_eq_iff to_nat_eq_iff\n\n",
 "to_nat_congr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem to_nat_congr {β : Type v} (e : «expr ≃ » α β) : (cardinal.mk α).to_nat = (cardinal.mk β).to_nat := by\n  rw [← to_nat_lift, lift_mk_eq.mpr ⟨e⟩, to_nat_lift]\n#align to_nat_congr to_nat_congr\n\n",
 "to_nat_cast":
 "@[simp]\ntheorem to_nat_cast (n : ℕ) : cardinal.to_nat n = n :=\n  by\n  rw [to_nat_apply_of_lt_aleph_0 (nat_lt_aleph_0 n), ← nat_cast_inj]\n  exact (Classical.choose_spec (lt_aleph_0.1 (nat_lt_aleph_0 n))).symm\n#align to_nat_cast to_nat_cast\n\n",
 "to_nat_apply_of_lt_aleph_0":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\ntheorem to_nat_apply_of_lt_aleph_0 {c : cardinal} (h : c < cardinal.aleph_0) :\n    c.to_nat = Classical.choose (lt_aleph_0.1 h) :=\n  dif_pos h\n#align to_nat_apply_of_lt_aleph_0 to_nat_apply_of_lt_aleph_0\n\n",
 "to_nat_apply_of_aleph_0_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\ntheorem to_nat_apply_of_aleph_0_le {c : cardinal} (h : cardinal.aleph_0 ≤ c) : c.to_nat = 0 :=\n  dif_neg h.not_lt\n#align to_nat_apply_of_aleph_0_le to_nat_apply_of_aleph_0_le\n\n",
 "to_nat_add_of_lt_aleph_0":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n@[simp]\ntheorem to_nat_add_of_lt_aleph_0 {a : cardinal.{u}} {b : cardinal.{v}} (ha : a < cardinal.aleph_0)\n    (hb : b < cardinal.aleph_0) : (lift.{v, u} a + lift.{u, v} b).to_nat = a.to_nat + b.to_nat :=\n  by\n  apply cardinal.nat_cast_injective\n  replace ha : lift.{v, u} a < cardinal.aleph_0 := by\n    rw [← lift_aleph_0]\n    exact lift_lt.2 ha\n  replace hb : lift.{u, v} b < cardinal.aleph_0 := by\n    rw [← lift_aleph_0]\n    exact lift_lt.2 hb\n  rw [Nat.cast_add, ← to_nat_lift.{v, u} a, ← to_nat_lift.{u, v} b, cast_to_nat_of_lt_aleph_0 ha,\n    cast_to_nat_of_lt_aleph_0 hb, cast_to_nat_of_lt_aleph_0 (add_lt_aleph_0 ha hb)]\n#align to_nat_add_of_lt_aleph_0 to_nat_add_of_lt_aleph_0\n\n",
 "three_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem three_le {α : Type _} (h : 3 ≤ cardinal.mk α) (x : α) (y : α) : ∃ z : α, z ≠ x ∧ z ≠ y :=\n  by\n  have : ↑(3 : ℕ) ≤ cardinal.mk α; simpa using h\n  have : ↑(2 : ℕ) < cardinal.mk α; rwa [← succ_le_iff, ← cardinal.nat_succ]\n  have := exists_not_mem_of_length_lt [x, y] this\n  simpa [not_or] using this\n#align three_le three_le\n\n",
 "supᵢ_of_empty":
 "#print supᵢ_of_empty /-\n/-- A variant of `csupr_of_empty` but with `0` on the RHS for convenience -/\n@[simp]\nprotected theorem supᵢ_of_empty {ι} (f : ι → cardinal) [is_empty ι] : supᵢ f = 0 :=\n  csupᵢ_of_empty f\n#align supr_of_empty supᵢ_of_empty\n-/\n\n",
 "supr_le_sum":
 "theorem supr_le_sum {ι} (f : ι → cardinal) : supᵢ f ≤ sum f :=\n  csupᵢ_le' <| le_sum _\n#align supr_le_sum supr_le_sum\n\n",
 "sum_nat_eq_add_sum_succ":
 "theorem sum_nat_eq_add_sum_succ (f : ℕ → cardinal.{u}) : cardinal.sum f = f 0 + cardinal.sum fun i => f (i + 1) :=\n  by\n  refine' (Equiv.sigmaNatSucc fun i => quotient.out (f i)).cardinal_eq.trans _\n  simp only [mk_sum, mk_out, lift_id, mk_sigma]\n#align sum_nat_eq_add_sum_succ sum_nat_eq_add_sum_succ\n\n",
 "sum_lt_prod":
 "/-- **König's theorem** -/\ntheorem sum_lt_prod {ι} (f g : ι → cardinal) (H : ∀ i, f i < g i) : sum f < prod g :=\n  lt_of_not_ge fun ⟨F⟩ =>\n    by\n    have : inhabited (∀ i : ι, (g i).out) :=\n      by\n      refine' ⟨fun i => classical.choice <| mk_ne_zero_iff.1 _⟩\n      rw [mk_out]\n      exact (H i).ne_bot\n    let G := inv_fun F\n    have sG : surjective G := inv_fun_surjective F.2\n    choose C hc using\n      show ∀ i, ∃ b, ∀ a, G ⟨i, a⟩ i ≠ b by\n        intro i\n        simp only [-not_exists, not_exists.symm, not_forall.symm]\n        refine' fun h => (H i).not_le _\n        rw [← mk_out (f i), ← mk_out (g i)]\n        exact ⟨embedding.of_surjective _ h⟩\n    exact\n      let ⟨⟨i, a⟩, h⟩ := sG C\n      hc i a (congr_fun h _)\n#align sum_lt_prod sum_lt_prod\n\n",
 "sum_le_supr_lift":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem sum_le_supr_lift {ι : Type u} (f : ι → cardinal.{max u v}) : sum f ≤ (cardinal.mk ι).lift * supᵢ f :=\n  by\n  rw [← (supᵢ f).lift_id, ← lift_umax, lift_umax.{max u v, u}, ← sum_const]\n  exact sum_le_sum _ _ (le_csupᵢ <| bdd_above_range.{u, v} f)\n#align sum_le_supr_lift sum_le_supr_lift\n\n",
 "sum_le_supr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem sum_le_supr {ι : Type u} (f : ι → cardinal.{u}) : sum f ≤ cardinal.mk ι * supᵢ f :=\n  by\n  rw [← lift_id (cardinal.mk ι)]\n  exact sum_le_supr_lift f\n#align sum_le_supr sum_le_supr\n\n",
 "sum_le_sum":
 "theorem sum_le_sum {ι} (f g : ι → cardinal) (H : ∀ i, f i ≤ g i) : sum f ≤ sum g :=\n  ⟨(Embedding.refl _).sigma_map fun i =>\n      classical.choice <| by have := H i <;> rwa [← quot.out_eq (f i), ← quot.out_eq (g i)] at this⟩\n#align sum_le_sum sum_le_sum\n\n",
 "sum_const'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem sum_const' (ι : Type u) (a : cardinal.{u}) : (sum fun _ : ι => a) = cardinal.mk ι * a := by simp\n#align sum_const' sum_const'\n\n",
 "sum_const":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n@[simp]\ntheorem sum_const (ι : Type u) (a : cardinal.{v}) : (sum fun i : ι => a) = lift.{v} (cardinal.mk ι) * lift.{u} a :=\n  induction_on a fun α =>\n    mk_congr <|\n      calc\n        «expr ≃ » (Σi : ι, quotient.out (cardinal.mk α)) (ι × quotient.out (cardinal.mk α)) :=\n          equiv.sigma_equiv_prod _ _\n        «expr ≃ » _ (ULift ι × ULift α) := equiv.ulift.symm.prod_congr (out_mk_equiv.trans equiv.ulift.symm)\n        \n#align sum_const sum_const\n\n",
 "sum_add_distrib'":
 "@[simp]\ntheorem sum_add_distrib' {ι} (f g : ι → cardinal) : (cardinal.sum fun i => f i + g i) = sum f + sum g :=\n  sum_add_distrib f g\n#align sum_add_distrib' sum_add_distrib'\n\n",
 "sum_add_distrib":
 "@[simp]\ntheorem sum_add_distrib {ι} (f g : ι → cardinal) : sum (f + g) = sum f + sum g := by\n  simpa only [mk_sigma, mk_sum, mk_out, lift_id] using\n    mk_congr (Equiv.sigmaSumDistrib (quotient.out ∘ f) (quotient.out ∘ g))\n#align sum_add_distrib sum_add_distrib\n\n",
 "succ_zero":
 "@[simp]\ntheorem succ_zero : succ (0 : cardinal) = 1 := by norm_cast\n#align succ_zero succ_zero\n\n",
 "succ_pos":
 "theorem succ_pos : ∀ c : cardinal, 0 < succ c :=\n  bot_lt_succ\n#align succ_pos succ_pos\n\n",
 "succ_ne_zero":
 "theorem succ_ne_zero (c : cardinal) : succ c ≠ 0 :=\n  (succ_pos _).ne'\n#align succ_ne_zero succ_ne_zero\n\n",
 "succ_def":
 "theorem succ_def (c : cardinal) : succ c = infₛ { c' | c < c' } :=\n  rfl\n#align succ_def succ_def\n\n",
 "self_le_power":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.pow -/\ntheorem self_le_power (a : cardinal) {b : cardinal} (hb : 1 ≤ b) : a ≤ cardinal.pow a b :=\n  by\n  rcases eq_or_ne a 0 with (rfl | ha)\n  · exact zero_le _\n  · convert power_le_power_left ha hb\n    exact power_one.symm\n#align self_le_power self_le_power\n\n",
 "range_nat_cast":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n@[simp]\ntheorem range_nat_cast : range (coe : ℕ → cardinal) = Iio (cardinal.aleph_0) :=\n  ext fun x => by simp only [mem_Iio, mem_range, eq_comm, lt_aleph_0]\n#align range_nat_cast range_nat_cast\n\n",
 "prod_ne_zero":
 "theorem prod_ne_zero {ι} (f : ι → cardinal) : prod f ≠ 0 ↔ ∀ i, f i ≠ 0 := by simp [prod_eq_zero]\n#align prod_ne_zero prod_ne_zero\n\n",
 "prod_le_prod":
 "theorem prod_le_prod {ι} (f g : ι → cardinal) (H : ∀ i, f i ≤ g i) : prod f ≤ prod g :=\n  ⟨embedding.Pi_congr_right fun i =>\n      classical.choice <| by have := H i <;> rwa [← mk_out (f i), ← mk_out (g i)] at this⟩\n#align prod_le_prod prod_le_prod\n\n",
 "prod_eq_zero":
 "@[simp]\ntheorem prod_eq_zero {ι} (f : ι → cardinal.{u}) : prod f = 0 ↔ ∃ i, f i = 0 :=\n  by\n  lift f to ι → Type u using fun _ => trivial\n  simp only [mk_eq_zero_iff, ← mk_pi, isEmpty_pi]\n#align prod_eq_zero prod_eq_zero\n\n",
 "prod_eq_of_fintype":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\ntheorem prod_eq_of_fintype {α : Type u} [fintype α] (f : α → cardinal.{v}) :\n    prod f =\n      cardinal.lift.{u}\n        (finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n          (f i)) :=\n  by\n  revert f\n  refine' fintype.induction_empty_option _ _ _ α\n  · intro α β hβ e h f\n    letI := fintype.of_equiv β e.symm\n    rw [← e.prod_comp f, ← h]\n    exact mk_congr (e.Pi_congr_left _).symm\n  · intro f\n    rw [fintype.univ_pempty, finset.prod_empty, lift_one, cardinal.prod, mk_eq_one]\n  · intro α hα h f\n    rw [cardinal.prod, mk_congr Equiv.piOptionEquivProd, mk_prod, lift_umax', mk_out, ← cardinal.prod, lift_prod,\n      fintype.prod_option, lift_mul, ← h fun a => f (some a)]\n    simp only [lift_id]\n#align prod_eq_of_fintype prod_eq_of_fintype\n\n",
 "prod_const'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.pow -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem prod_const' (ι : Type u) (a : cardinal.{u}) : (prod fun _ : ι => a) = cardinal.pow a (cardinal.mk ι) :=\n  induction_on a fun α => (mk_pi _).symm\n#align prod_const' prod_const'\n\n",
 "prod_const":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.pow -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n@[simp]\ntheorem prod_const (ι : Type u) (a : cardinal.{v}) :\n    (prod fun i : ι => a) = cardinal.pow (lift.{u} a) (lift.{v} (cardinal.mk ι)) :=\n  induction_on a fun α => mk_congr <| Equiv.piCongr equiv.ulift.symm fun i => out_mk_equiv.trans equiv.ulift.symm\n#align prod_const prod_const\n\n",
 "powerlt_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^< » -/\n@[simp]\ntheorem powerlt_zero {a : cardinal} : «expr ^< » a 0 = 0 :=\n  by\n  convert cardinal.supr_of_empty _\n  exact Subtype.isEmpty_of_false fun x => (cardinal.zero_le _).not_lt\n#align powerlt_zero powerlt_zero\n\n",
 "powerlt_succ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^< » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.pow -/\ntheorem powerlt_succ {a b : cardinal} (h : a ≠ 0) : «expr ^< » a (succ b) = cardinal.pow a b :=\n  (powerlt_le.2 fun c h' => power_le_power_left h <| le_of_lt_succ h').antisymm <| le_powerlt a (lt_succ b)\n#align powerlt_succ powerlt_succ\n\n",
 "powerlt_mono_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^< » -/\ntheorem powerlt_mono_left (a) : monotone fun c => «expr ^< » a c := fun b c => powerlt_le_powerlt_left\n#align powerlt_mono_left powerlt_mono_left\n\n",
 "powerlt_min":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^< » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^< » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^< » -/\ntheorem powerlt_min {a b c : cardinal} : «expr ^< » a (min b c) = min («expr ^< » a b) («expr ^< » a c) :=\n  (powerlt_mono_left a).map_min\n#align powerlt_min powerlt_min\n\n",
 "powerlt_max":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^< » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^< » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^< » -/\ntheorem powerlt_max {a b c : cardinal} : «expr ^< » a (max b c) = max («expr ^< » a b) («expr ^< » a c) :=\n  (powerlt_mono_left a).map_max\n#align powerlt_max powerlt_max\n\n",
 "powerlt_le_powerlt_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^< » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^< » -/\ntheorem powerlt_le_powerlt_left {a b c : cardinal} (h : b ≤ c) : «expr ^< » a b ≤ «expr ^< » a c :=\n  powerlt_le.2 fun x hx => le_powerlt a <| hx.trans_le h\n#align powerlt_le_powerlt_left powerlt_le_powerlt_left\n\n",
 "powerlt_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^< » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.pow -/\ntheorem powerlt_le {a b c : cardinal.{u}} : «expr ^< » a b ≤ c ↔ ∀ x < b, cardinal.pow a x ≤ c :=\n  by\n  rw [powerlt, csupᵢ_le_iff']\n  · simp\n  · rw [← image_eq_range]\n    exact bdd_above_image.{u, u} _ bddAbove_Iio\n#align powerlt_le powerlt_le\n\n",
 "power_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.pow -/\n@[simp]\ntheorem power_zero {a : cardinal} : cardinal.pow a 0 = 1 :=\n  induction_on a fun α => mk_congr <| Equiv.pemptyArrowEquivPUnit α\n#align power_zero power_zero\n\n",
 "power_pos":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.pow -/\ntheorem power_pos {a : cardinal} (b) (ha : 0 < a) : 0 < cardinal.pow a b :=\n  (power_ne_zero _ ha.ne').bot_lt\n#align power_pos power_pos\n\n",
 "power_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.pow -/\n@[simp]\ntheorem power_one {a : cardinal} : cardinal.pow a 1 = a :=\n  induction_on a fun α => mk_congr <| equiv.punit_arrow_equiv α\n#align power_one power_one\n\n",
 "power_ne_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.pow -/\ntheorem power_ne_zero {a : cardinal} (b) : a ≠ 0 → cardinal.pow a b ≠ 0 :=\n  induction_on₂ a b fun α β h =>\n    let ⟨a⟩ := mk_ne_zero_iff.1 h\n    mk_ne_zero_iff.2 ⟨fun _ => a⟩\n#align power_ne_zero power_ne_zero\n\n",
 "power_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.pow -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.pow -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.pow -/\ntheorem power_mul {a b c : cardinal} : cardinal.pow a (b * c) = cardinal.pow (cardinal.pow a b) c :=\n  by\n  rw [mul_comm b c]\n  exact induction_on₃ a b c fun α β γ => mk_congr <| Equiv.curry γ β α\n#align power_mul power_mul\n\n",
 "power_lt_aleph_0":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.pow -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\ntheorem power_lt_aleph_0 {a b : cardinal} (ha : a < cardinal.aleph_0) (hb : b < cardinal.aleph_0) :\n    cardinal.pow a b < cardinal.aleph_0 :=\n  match a, b, lt_aleph_0.1 ha, lt_aleph_0.1 hb with\n  | _, _, ⟨m, rfl⟩, ⟨n, rfl⟩ => by rw [← nat_cast_pow] <;> apply nat_lt_aleph_0\n#align power_lt_aleph_0 power_lt_aleph_0\n\n",
 "power_le_power_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.pow -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.pow -/\ntheorem power_le_power_right {a b c : cardinal} : a ≤ b → cardinal.pow a c ≤ cardinal.pow b c :=\n  induction_on₃ a b c fun α β γ ⟨e⟩ => ⟨Embedding.arrowCongrRight e⟩\n#align power_le_power_right power_le_power_right\n\n",
 "power_le_power_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.pow -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.pow -/\ntheorem power_le_power_left : ∀ {a b c : cardinal}, a ≠ 0 → b ≤ c → cardinal.pow a b ≤ cardinal.pow a c := by\n  rintro ⟨α⟩ ⟨β⟩ ⟨γ⟩ hα ⟨e⟩ <;>\n    exact\n      let ⟨a⟩ := mk_ne_zero_iff.1 hα\n      ⟨@embedding.arrow_congr_left _ _ _ ⟨a⟩ e⟩\n#align power_le_power_left power_le_power_left\n\n",
 "power_le_max_power_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.pow -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.pow -/\ntheorem power_le_max_power_one {a b c : cardinal} (h : b ≤ c) : cardinal.pow a b ≤ max (cardinal.pow a c) 1 :=\n  by\n  by_cases ha : a = 0\n  simp [ha, zero_power_le]\n  exact (power_le_power_left ha h).trans (le_max_left _ _)\n#align power_le_max_power_one power_le_max_power_one\n\n",
 "power_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.pow -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem power_def (α β) : cardinal.pow (cardinal.mk α) (cardinal.mk β) = cardinal.mk (β → α) :=\n  rfl\n#align power_def power_def\n\n",
 "power_bit1":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.pow -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.pow -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.pow -/\ntheorem power_bit1 (a b : cardinal) : cardinal.pow a (bit1 b) = cardinal.pow a b * cardinal.pow a b * a := by\n  rw [bit1, ← power_bit0, power_add, power_one]\n#align power_bit1 power_bit1\n\n",
 "power_bit0":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.pow -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.pow -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.pow -/\ntheorem power_bit0 (a b : cardinal) : cardinal.pow a (bit0 b) = cardinal.pow a b * cardinal.pow a b :=\n  power_add\n#align power_bit0 power_bit0\n\n",
 "power_add":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.pow -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.pow -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.pow -/\ntheorem power_add {a b c : cardinal} : cardinal.pow a (b + c) = cardinal.pow a b * cardinal.pow a c :=\n  induction_on₃ a b c fun α β γ => mk_congr <| Equiv.sumArrowEquivProdArrow β γ α\n#align power_add power_add\n\n",
 "pow_cast_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.pow -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.pow.nat -/\n@[simp]\ntheorem pow_cast_right (a : cardinal.{u}) (n : ℕ) : cardinal.pow a (↑n : cardinal.{u}) = cardinal.pow.nat a n :=\n  rfl\n#align pow_cast_right pow_cast_right\n\n",
 "out_embedding":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ↪ » -/\ntheorem out_embedding {c c' : cardinal} : c ≤ c' ↔ nonempty («expr ↪ » c.out c'.out) :=\n  by\n  trans _\n  rw [← quotient.out_eq c, ← quotient.out_eq c']\n  rfl\n#align out_embedding out_embedding\n\n",
 "one_to_nat":
 "@[simp]\ntheorem one_to_nat : to_nat 1 = 1 := by rw [← to_nat_cast 1, Nat.cast_one]\n#align one_to_nat one_to_nat\n\n",
 "one_power":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.pow -/\n@[simp]\ntheorem one_power {a : cardinal} : cardinal.pow 1 a = 1 :=\n  induction_on a fun α => (Equiv.arrowPUnitEquivPUnit α).cardinal_eq\n#align one_power one_power\n\n",
 "one_lt_iff_nontrivial":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n-- short-circuit type class inference\ntheorem one_lt_iff_nontrivial {α : Type u} : 1 < cardinal.mk α ↔ nontrivial α := by\n  rw [← not_le, le_one_iff_subsingleton, ← not_nontrivial_iff_subsingleton, not_not]\n#align one_lt_iff_nontrivial one_lt_iff_nontrivial\n\n",
 "one_lt_aleph_0":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n@[simp]\ntheorem one_lt_aleph_0 : 1 < cardinal.aleph_0 := by simpa using nat_lt_aleph_0 1\n#align one_lt_aleph_0 one_lt_aleph_0\n\n",
 "one_le_iff_pos":
 "theorem one_le_iff_pos {c : cardinal} : 1 ≤ c ↔ 0 < c := by rw [← succ_zero, succ_le_iff]\n#align one_le_iff_pos one_le_iff_pos\n\n",
 "one_le_iff_ne_zero":
 "theorem one_le_iff_ne_zero {c : cardinal} : 1 ≤ c ↔ c ≠ 0 := by rw [one_le_iff_pos, pos_iff_ne_zero]\n#align one_le_iff_ne_zero one_le_iff_ne_zero\n\n",
 "one_le_aleph_0":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\ntheorem one_le_aleph_0 : 1 ≤ cardinal.aleph_0 :=\n  one_lt_aleph_0.le\n#align one_le_aleph_0 one_le_aleph_0\n\n",
 "nsmul_lt_aleph_0_iff_of_ne_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n/-- See also `cardinal.nsmul_lt_aleph_0_iff` for a hypothesis-free version. -/\ntheorem nsmul_lt_aleph_0_iff_of_ne_zero {n : ℕ} {a : cardinal} (h : n ≠ 0) :\n    «expr • » n a < cardinal.aleph_0 ↔ a < cardinal.aleph_0 :=\n  nsmul_lt_aleph_0_iff.trans <| or_iff_right h\n#align nsmul_lt_aleph_0_iff_of_ne_zero nsmul_lt_aleph_0_iff_of_ne_zero\n\n",
 "nsmul_lt_aleph_0_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n/-- See also `cardinal.nsmul_lt_aleph_0_iff_of_ne_zero` if you already have `n ≠ 0`. -/\ntheorem nsmul_lt_aleph_0_iff {n : ℕ} {a : cardinal} : «expr • » n a < cardinal.aleph_0 ↔ n = 0 ∨ a < cardinal.aleph_0 :=\n  by\n  cases n\n  · simpa using nat_lt_aleph_0 0\n  simp only [nat.succ_ne_zero, false_or_iff]\n  induction' n with n ih\n  · simp\n  rw [succ_nsmul, add_lt_aleph_0_iff, ih, and_self_iff]\n#align nsmul_lt_aleph_0_iff nsmul_lt_aleph_0_iff\n\n",
 "nat_succ":
 "@[simp, norm_cast]\ntheorem nat_succ (n : ℕ) : (n.succ : cardinal) = succ n :=\n  (add_one_le_succ _).antisymm (succ_le_of_lt <| nat_cast_lt.2 <| nat.lt_succ_self _)\n#align nat_succ nat_succ\n\n",
 "nat_mul_aleph_0":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n@[simp]\ntheorem nat_mul_aleph_0 {n : ℕ} (hn : n ≠ 0) : ↑n * cardinal.aleph_0 = cardinal.aleph_0 :=\n  le_antisymm (lift_mk_fin n ▸ mk_le_aleph_0) <|\n    le_mul_of_one_le_left (zero_le _) <| by rwa [← Nat.cast_one, nat_cast_le, Nat.one_le_iff_ne_zero]\n#align nat_mul_aleph_0 nat_mul_aleph_0\n\n",
 "nat_lt_aleph_0":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\ntheorem nat_lt_aleph_0 (n : ℕ) : (n : cardinal.{u}) < cardinal.aleph_0 :=\n  succ_le_iff.1\n    (by\n      rw [← nat_succ, ← lift_mk_fin, aleph_0, lift_mk_le.{0, 0, u}]\n      exact ⟨⟨coe, fun a b => Fin.ext⟩⟩)\n#align nat_lt_aleph_0 nat_lt_aleph_0\n\n",
 "nat_eq_lift_iff":
 "@[simp]\ntheorem nat_eq_lift_iff {n : ℕ} {a : cardinal.{u}} : (n : cardinal) = lift.{v} a ↔ (n : cardinal) = a := by\n  rw [← lift_nat_cast.{v} n, lift_inj]\n#align nat_eq_lift_iff nat_eq_lift_iff\n\n",
 "nat_cast_pow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.pow -/\n@[simp, norm_cast]\ntheorem nat_cast_pow {m n : ℕ} : (↑(pow m n) : cardinal) = cardinal.pow m n := by\n  induction n <;> simp [pow_succ', power_add, *]\n#align nat_cast_pow nat_cast_pow\n\n",
 "nat_cast_lt":
 "@[simp, norm_cast]\ntheorem nat_cast_lt {m n : ℕ} : (m : cardinal) < n ↔ m < n := by simp [lt_iff_le_not_le, ← not_le]\n#align nat_cast_lt nat_cast_lt\n\n",
 "nat_cast_le":
 "@[simp, norm_cast]\ntheorem nat_cast_le {m n : ℕ} : (m : cardinal) ≤ n ↔ m ≤ n := by\n  rw [← lift_mk_fin, ← lift_mk_fin, lift_le, le_def, function.embedding.nonempty_iff_card_le, fintype.card_fin,\n    fintype.card_fin]\n#align nat_cast_le nat_cast_le\n\n",
 "nat_cast_injective":
 "theorem nat_cast_injective : injective (coe : ℕ → cardinal) :=\n  Nat.cast_injective\n#align nat_cast_injective nat_cast_injective\n\n",
 "nat_cast_inj":
 "theorem nat_cast_inj {m n : ℕ} : (m : cardinal) = n ↔ m = n :=\n  Nat.cast_inj\n#align nat_cast_inj nat_cast_inj\n\n",
 "nat_add_aleph_0":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n@[simp]\ntheorem nat_add_aleph_0 (n : ℕ) : ↑n + cardinal.aleph_0 = cardinal.aleph_0 := by rw [add_comm, aleph_0_add_nat]\n#align nat_add_aleph_0 nat_add_aleph_0\n\n",
 "mul_power":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.pow -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.pow -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.pow -/\ntheorem mul_power {a b c : cardinal} : cardinal.pow (a * b) c = cardinal.pow a c * cardinal.pow b c :=\n  induction_on₃ a b c fun α β γ => mk_congr <| Equiv.arrowProdEquivProdArrow α β γ\n#align mul_power mul_power\n\n",
 "mul_lt_aleph_0_iff_of_ne_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\ntheorem mul_lt_aleph_0_iff_of_ne_zero {a b : cardinal} (ha : a ≠ 0) (hb : b ≠ 0) :\n    a * b < cardinal.aleph_0 ↔ a < cardinal.aleph_0 ∧ b < cardinal.aleph_0 := by simp [mul_lt_aleph_0_iff, ha, hb]\n#align mul_lt_aleph_0_iff_of_ne_zero mul_lt_aleph_0_iff_of_ne_zero\n\n",
 "mul_lt_aleph_0_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\ntheorem mul_lt_aleph_0_iff {a b : cardinal} :\n    a * b < cardinal.aleph_0 ↔ a = 0 ∨ b = 0 ∨ a < cardinal.aleph_0 ∧ b < cardinal.aleph_0 :=\n  by\n  refine' ⟨fun h => _, _⟩\n  · by_cases ha : a = 0\n    · exact or.inl ha\n    right\n    by_cases hb : b = 0\n    · exact or.inl hb\n    right\n    rw [← ne, ← one_le_iff_ne_zero] at ha hb\n    constructor\n    · rw [← mul_one a]\n      refine' (mul_le_mul' le_rfl hb).trans_lt h\n    · rw [← one_mul b]\n      refine' (mul_le_mul' ha le_rfl).trans_lt h\n  rintro (rfl | rfl | ⟨ha, hb⟩) <;> simp only [*, mul_lt_aleph_0, aleph_0_pos, zero_mul, mul_zero]\n#align mul_lt_aleph_0_iff mul_lt_aleph_0_iff\n\n",
 "mul_lt_aleph_0":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\ntheorem mul_lt_aleph_0 {a b : cardinal} (ha : a < cardinal.aleph_0) (hb : b < cardinal.aleph_0) :\n    a * b < cardinal.aleph_0 :=\n  match a, b, lt_aleph_0.1 ha, lt_aleph_0.1 hb with\n  | _, _, ⟨m, rfl⟩, ⟨n, rfl⟩ => by rw [← nat.cast_mul] <;> apply nat_lt_aleph_0\n#align mul_lt_aleph_0 mul_lt_aleph_0\n\n",
 "mul_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem mul_def (α β : Type u) : cardinal.mk α * cardinal.mk β = cardinal.mk (α × β) :=\n  rfl\n#align mul_def mul_def\n\n",
 "mul_comm'":
 "private theorem mul_comm' (a b : cardinal.{u}) : a * b = b * a :=\n  induction_on₂ a b fun α β => mk_congr <| Equiv.prodComm α β\n#align mul_comm' mul_comm'\n\n",
 "mk_vector":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.pow.nat -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n@[simp]\ntheorem mk_vector (α : Type u) (n : ℕ) : cardinal.mk (Vector α n) = cardinal.pow.nat (cardinal.mk α) n :=\n  (mk_congr (equiv.vector_equiv_fin α n)).trans <| by simp\n#align mk_vector mk_vector\n\n",
 "mk_univ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n@[simp]\ntheorem mk_univ {α : Type u} : cardinal.mk (@univ α) = cardinal.mk α :=\n  mk_congr (Equiv.Set.univ α)\n#align mk_univ mk_univ\n\n",
 "mk_unit":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem mk_unit : cardinal.mk unit = 1 :=\n  mk_punit\n#align mk_unit mk_unit\n\n",
 "mk_union_of_disjoint":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem mk_union_of_disjoint {α : Type u} {S T : set α} (H : Disjoint S T) :\n    cardinal.mk (S ∪ T : set α) = cardinal.mk S + cardinal.mk T :=\n  quot.sound ⟨Equiv.Set.union H.le_bot⟩\n#align mk_union_of_disjoint mk_union_of_disjoint\n\n",
 "mk_union_le_aleph_0":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\ntheorem mk_union_le_aleph_0 {α} {P Q : set α} :\n    cardinal.mk (P ∪ Q : set α) ≤ cardinal.aleph_0 ↔\n      cardinal.mk P ≤ cardinal.aleph_0 ∧ cardinal.mk Q ≤ cardinal.aleph_0 :=\n  by simp\n#align mk_union_le_aleph_0 mk_union_le_aleph_0\n\n",
 "mk_union_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/-- The cardinality of a union is at most the sum of the cardinalities\nof the two sets. -/\ntheorem mk_union_le {α : Type u} (S T : set α) : cardinal.mk (S ∪ T : set α) ≤ cardinal.mk S + cardinal.mk T :=\n  @mk_union_add_mk_inter α S T ▸ self_le_add_right (cardinal.mk (S ∪ T : set α)) (cardinal.mk (S ∩ T : set α))\n#align mk_union_le mk_union_le\n\n",
 "mk_union_add_mk_inter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem mk_union_add_mk_inter {α : Type u} {S T : set α} :\n    cardinal.mk (S ∪ T : set α) + cardinal.mk (S ∩ T : set α) = cardinal.mk S + cardinal.mk T :=\n  quot.sound ⟨Equiv.Set.unionSumInter S T⟩\n#align mk_union_add_mk_inter mk_union_add_mk_inter\n\n",
 "mk_ulift":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n@[simp]\ntheorem mk_ulift (α) : cardinal.mk (ULift.{v, u} α) = lift.{v} (cardinal.mk α) :=\n  rfl\n#align mk_ulift mk_ulift\n\n",
 "mk_to_part_enat_of_infinite":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem mk_to_part_enat_of_infinite [h : Infinite α] : (cardinal.mk α).to_part_enat = «expr⊤» :=\n  to_part_enat_apply_of_aleph_0_le (infinite_iff.1 h)\n#align mk_to_part_enat_of_infinite mk_to_part_enat_of_infinite\n\n",
 "mk_to_part_enat_eq_coe_card":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem mk_to_part_enat_eq_coe_card [fintype α] : (cardinal.mk α).to_part_enat = fintype.card α := by simp\n#align mk_to_part_enat_eq_coe_card mk_to_part_enat_eq_coe_card\n\n",
 "mk_to_nat_of_infinite":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n@[simp]\ntheorem mk_to_nat_of_infinite [h : Infinite α] : (cardinal.mk α).to_nat = 0 :=\n  dif_neg (infinite_iff.1 h).not_lt\n#align mk_to_nat_of_infinite mk_to_nat_of_infinite\n\n",
 "mk_to_nat_eq_card":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem mk_to_nat_eq_card [fintype α] : (cardinal.mk α).to_nat = fintype.card α := by simp\n#align mk_to_nat_eq_card mk_to_nat_eq_card\n\n",
 "mk_sum_compl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem mk_sum_compl {α} (s : set α) : cardinal.mk s + cardinal.mk («expr ᶜ» s : set α) = cardinal.mk α :=\n  mk_congr (Equiv.Set.sumCompl s)\n#align mk_sum_compl mk_sum_compl\n\n",
 "mk_sum":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n@[simp]\ntheorem mk_sum (α : Type u) (β : Type v) :\n    cardinal.mk (Sum α β) = lift.{v, u} (cardinal.mk α) + lift.{u, v} (cardinal.mk β) :=\n  mk_congr (equiv.ulift.symm.sum_congr equiv.ulift.symm)\n#align mk_sum mk_sum\n\n",
 "mk_subtype_of_equiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem mk_subtype_of_equiv {α β : Type u} (p : β → Prop) (e : «expr ≃ » α β) :\n    cardinal.mk { a : α // p (e a) } = cardinal.mk { b : β // p b } :=\n  mk_congr (Equiv.subtypeEquivOfSubtype e)\n#align mk_subtype_of_equiv mk_subtype_of_equiv\n\n",
 "mk_subtype_mono":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem mk_subtype_mono {p q : α → Prop} (h : ∀ x, p x → q x) : cardinal.mk { x // p x } ≤ cardinal.mk { x // q x } :=\n  ⟨embeddingOfSubset _ _ h⟩\n#align mk_subtype_mono mk_subtype_mono\n\n",
 "mk_subtype_le_of_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem mk_subtype_le_of_subset {α : Type u} {p q : α → Prop} (h : ∀ ⦃x⦄, p x → q x) :\n    cardinal.mk (subtype p) ≤ cardinal.mk (subtype q) :=\n  ⟨Embedding.subtypeMap (Embedding.refl α) h⟩\n#align mk_subtype_le_of_subset mk_subtype_le_of_subset\n\n",
 "mk_subtype_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem mk_subtype_le {α : Type u} (p : α → Prop) : cardinal.mk (subtype p) ≤ cardinal.mk α :=\n  ⟨Embedding.subtype p⟩\n#align mk_subtype_le mk_subtype_le\n\n",
 "mk_subset_ge_of_subset_image_lift":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem mk_subset_ge_of_subset_image_lift {α : Type u} {β : Type v} (f : α → β) {s : set α} {t : set β}\n    (h : t ⊆ «expr '' » f s) : lift.{u} (cardinal.mk t) ≤ lift.{v} (cardinal.mk ({ x ∈ s | f x ∈ t } : set α)) :=\n  by\n  rw [image_eq_range] at h\n  convert mk_preimage_of_subset_range_lift _ _ h using 1\n  rw [mk_sep]\n  rfl\n#align mk_subset_ge_of_subset_image_lift mk_subset_ge_of_subset_image_lift\n\n",
 "mk_subset_ge_of_subset_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem mk_subset_ge_of_subset_image (f : α → β) {s : set α} {t : set β} (h : t ⊆ «expr '' » f s) :\n    cardinal.mk t ≤ cardinal.mk ({ x ∈ s | f x ∈ t } : set α) :=\n  by\n  rw [image_eq_range] at h\n  convert mk_preimage_of_subset_range _ _ h using 1\n  rw [mk_sep]\n  rfl\n#align mk_subset_ge_of_subset_image mk_subset_ge_of_subset_image\n\n",
 "mk_singleton":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n@[simp]\ntheorem mk_singleton {α : Type u} (x : α) : cardinal.mk ({x} : set α) = 1 :=\n  mk_eq_one _\n#align mk_singleton mk_singleton\n\n",
 "mk_sigma":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n@[simp]\ntheorem mk_sigma {ι} (f : ι → Type _) : cardinal.mk (Σi, f i) = sum fun i => cardinal.mk (f i) :=\n  mk_congr <| equiv.sigma_congr_right fun i => out_mk_equiv.symm\n#align mk_sigma mk_sigma\n\n",
 "mk_set_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem mk_set_le (s : set α) : cardinal.mk s ≤ cardinal.mk α :=\n  mk_subtype_le s\n#align mk_set_le mk_set_le\n\n",
 "mk_set_eq_nat_iff_finset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem mk_set_eq_nat_iff_finset {α} {s : set α} {n : ℕ} :\n    cardinal.mk s = n ↔ ∃ t : Finset α, (t : set α) = s ∧ t.card = n :=\n  by\n  constructor\n  · intro h\n    lift s to Finset α using lt_aleph_0_iff_set_finite.1 (h.symm ▸ nat_lt_aleph_0 n)\n    simpa using h\n  · rintro ⟨t, rfl, rfl⟩\n    exact mk_coe_finset\n#align mk_set_eq_nat_iff_finset mk_set_eq_nat_iff_finset\n\n",
 "mk_set":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.pow -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n@[simp]\ntheorem mk_set {α : Type u} : cardinal.mk (set α) = cardinal.pow 2 (cardinal.mk α) := by simp [set, mk_arrow]\n#align mk_set mk_set\n\n",
 "mk_sep":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem mk_sep (s : set α) (t : α → Prop) : cardinal.mk ({ x ∈ s | t x } : set α) = cardinal.mk { x : s | t x.1 } :=\n  mk_congr (Equiv.Set.sep s t)\n#align mk_sep mk_sep\n\n",
 "mk_sUnion_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem mk_sUnion_le {α : Type u} (A : set (set α)) :\n    cardinal.mk (⋃₀ A) ≤\n      cardinal.mk A *\n        «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n          (cardinal.mk s) :=\n  by\n  rw [sUnion_eq_Union]\n  apply mk_Union_le\n#align mk_sUnion_le mk_sUnion_le\n\n",
 "mk_range_le_lift":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem mk_range_le_lift {α : Type u} {β : Type v} {f : α → β} :\n    lift.{u} (cardinal.mk (range f)) ≤ lift.{v} (cardinal.mk α) :=\n  lift_mk_le.{v, u, 0}.mpr ⟨Embedding.ofSurjective _ surjective_onto_range⟩\n#align mk_range_le_lift mk_range_le_lift\n\n",
 "mk_range_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem mk_range_le {α β : Type u} {f : α → β} : cardinal.mk (range f) ≤ cardinal.mk α :=\n  mk_le_of_surjective surjective_onto_range\n#align mk_range_le mk_range_le\n\n",
 "mk_range_eq_of_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem mk_range_eq_of_injective {α : Type u} {β : Type v} {f : α → β} (hf : injective f) :\n    lift.{u} (cardinal.mk (range f)) = lift.{v} (cardinal.mk α) :=\n  lift_mk_eq'.mpr ⟨(Equiv.ofInjective f hf).symm⟩\n#align mk_range_eq_of_injective mk_range_eq_of_injective\n\n",
 "mk_range_eq_lift":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem mk_range_eq_lift {α : Type u} {β : Type v} {f : α → β} (hf : injective f) :\n    lift.{max u w} (cardinal.mk (range f)) = lift.{max v w} (cardinal.mk α) :=\n  lift_mk_eq.mpr ⟨(Equiv.ofInjective f hf).symm⟩\n#align mk_range_eq_lift mk_range_eq_lift\n\n",
 "mk_range_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem mk_range_eq (f : α → β) (h : injective f) : cardinal.mk (range f) = cardinal.mk α :=\n  mk_congr (Equiv.ofInjective f h).symm\n#align mk_range_eq mk_range_eq\n\n",
 "mk_quotient_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem mk_quotient_le {α : Type u} {s : setoid α} : cardinal.mk (quotient s) ≤ cardinal.mk α :=\n  mk_quot_le\n#align mk_quotient_le mk_quotient_le\n\n",
 "mk_quot_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem mk_quot_le {α : Type u} {r : α → α → Prop} : cardinal.mk (Quot r) ≤ cardinal.mk α :=\n  mk_le_of_surjective quot.exists_rep\n#align mk_quot_le mk_quot_le\n\n",
 "mk_punit":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n@[simp]\ntheorem mk_punit : cardinal.mk PUnit = 1 :=\n  mk_eq_one PUnit\n#align mk_punit mk_punit\n\n",
 "mk_psum":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n@[simp]\ntheorem mk_psum (α : Type u) (β : Type v) :\n    cardinal.mk (PSum α β) = lift.{v} (cardinal.mk α) + lift.{u} (cardinal.mk β) :=\n  (mk_congr (Equiv.psumEquivSum α β)).trans (mk_sum α β)\n#align mk_psum mk_psum\n\n",
 "mk_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n@[simp]\ntheorem mk_prod (α : Type u) (β : Type v) :\n    cardinal.mk (α × β) = lift.{v, u} (cardinal.mk α) * lift.{u, v} (cardinal.mk β) :=\n  mk_congr (equiv.ulift.symm.prod_congr equiv.ulift.symm)\n#align mk_prod mk_prod\n\n",
 "mk_preimage_of_subset_range_lift":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem mk_preimage_of_subset_range_lift {α : Type u} {β : Type v} (f : α → β) (s : set β) (h : s ⊆ range f) :\n    lift.{u} (cardinal.mk s) ≤ lift.{v} (cardinal.mk («expr ⁻¹' » f s)) :=\n  by\n  rw [lift_mk_le.{v, u, 0}]\n  refine' ⟨⟨_, _⟩⟩\n  · rintro ⟨y, hy⟩\n    rcases Classical.subtype_of_exists (h hy) with ⟨x, rfl⟩\n    exact ⟨x, hy⟩\n  rintro ⟨y, hy⟩ ⟨y', hy'⟩; dsimp\n  rcases Classical.subtype_of_exists (h hy) with ⟨x, rfl⟩\n  rcases Classical.subtype_of_exists (h hy') with ⟨x', rfl⟩\n  simp; intro hxx'; rw [hxx']\n#align mk_preimage_of_subset_range_lift mk_preimage_of_subset_range_lift\n\n",
 "mk_preimage_of_subset_range":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem mk_preimage_of_subset_range (f : α → β) (s : set β) (h : s ⊆ range f) :\n    cardinal.mk s ≤ cardinal.mk («expr ⁻¹' » f s) := by\n  convert mk_preimage_of_subset_range_lift.{u, u} f s h using 1 <;> rw [lift_id]\n#align mk_preimage_of_subset_range mk_preimage_of_subset_range\n\n",
 "mk_preimage_of_injective_of_subset_range_lift":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem mk_preimage_of_injective_of_subset_range_lift {β : Type v} (f : α → β) (s : set β) (h : injective f)\n    (h2 : s ⊆ range f) : lift.{v} (cardinal.mk («expr ⁻¹' » f s)) = lift.{u} (cardinal.mk s) :=\n  le_antisymm (mk_preimage_of_injective_lift f s h) (mk_preimage_of_subset_range_lift f s h2)\n#align mk_preimage_of_injective_of_subset_range_lift mk_preimage_of_injective_of_subset_range_lift\n\n",
 "mk_preimage_of_injective_of_subset_range":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem mk_preimage_of_injective_of_subset_range (f : α → β) (s : set β) (h : injective f) (h2 : s ⊆ range f) :\n    cardinal.mk («expr ⁻¹' » f s) = cardinal.mk s := by\n  convert mk_preimage_of_injective_of_subset_range_lift.{u, u} f s h h2 using 1 <;> rw [lift_id]\n#align mk_preimage_of_injective_of_subset_range mk_preimage_of_injective_of_subset_range\n\n",
 "mk_preimage_of_injective_lift":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem mk_preimage_of_injective_lift {α : Type u} {β : Type v} (f : α → β) (s : set β) (h : injective f) :\n    lift.{v} (cardinal.mk («expr ⁻¹' » f s)) ≤ lift.{u} (cardinal.mk s) :=\n  by\n  rw [lift_mk_le.{u, v, 0}]; use subtype.coind (fun x => f x.1) fun x => x.2\n  apply subtype.coind_injective; exact h.comp subtype.val_injective\n#align mk_preimage_of_injective_lift mk_preimage_of_injective_lift\n\n",
 "mk_preimage_of_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem mk_preimage_of_injective (f : α → β) (s : set β) (h : injective f) :\n    cardinal.mk («expr ⁻¹' » f s) ≤ cardinal.mk s := by\n  convert mk_preimage_of_injective_lift.{u, u} f s h using 1 <;> rw [lift_id]\n#align mk_preimage_of_injective mk_preimage_of_injective\n\n",
 "mk_powerset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.pow -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↥ » -/\n/-- A variant of `cardinal.mk_set` expressed in terms of a `set` instead of a `Type`. -/\n@[simp]\ntheorem mk_powerset {α : Type u} (s : set α) :\n    cardinal.mk («expr↥ » (𝒫 s)) = cardinal.pow 2 (cardinal.mk («expr↥ » s)) :=\n  (mk_congr (Equiv.Set.powerset s)).trans mk_set\n#align mk_powerset mk_powerset\n\n",
 "mk_pnat":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ+» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ+» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\ntheorem mk_pnat : cardinal.mk («exprℕ+») = cardinal.aleph_0 :=\n  mk_denumerable («exprℕ+»)\n#align mk_pnat mk_pnat\n\n",
 "mk_plift_true":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n@[simp]\ntheorem mk_plift_true : cardinal.mk (PLift true) = 1 :=\n  mk_eq_one _\n#align mk_plift_true mk_plift_true\n\n",
 "mk_plift_false":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n@[simp]\ntheorem mk_plift_false : cardinal.mk (PLift false) = 0 :=\n  mk_eq_zero _\n#align mk_plift_false mk_plift_false\n\n",
 "mk_pi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n@[simp]\ntheorem mk_pi {ι : Type u} (α : ι → Type v) : cardinal.mk (∀ i, α i) = prod fun i => cardinal.mk (α i) :=\n  mk_congr <| Equiv.piCongrRight fun i => out_mk_equiv.symm\n#align mk_pi mk_pi\n\n",
 "mk_pempty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n@[simp]\ntheorem mk_pempty : cardinal.mk PEmpty = 0 :=\n  mk_eq_zero _\n#align mk_pempty mk_pempty\n\n",
 "mk_out":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n@[simp]\ntheorem mk_out (c : cardinal) : cardinal.mk c.out = c :=\n  quotient.out_eq _\n#align mk_out mk_out\n\n",
 "mk_option":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n@[simp]\ntheorem mk_option {α : Type u} : cardinal.mk (option α) = cardinal.mk α + 1 :=\n  (Equiv.optionEquivSumPUnit α).cardinal_eq\n#align mk_option mk_option\n\n",
 "mk_ne_zero_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem mk_ne_zero_iff {α : Type u} : cardinal.mk α ≠ 0 ↔ nonempty α :=\n  (not_iff_not.2 mk_eq_zero_iff).trans not_isEmpty_iff\n#align mk_ne_zero_iff mk_ne_zero_iff\n\n",
 "mk_ne_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n@[simp]\ntheorem mk_ne_zero (α : Type u) [nonempty α] : cardinal.mk α ≠ 0 :=\n  mk_ne_zero_iff.2 ‹_›\n#align mk_ne_zero mk_ne_zero\n\n",
 "mk_nat":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\ntheorem mk_nat : cardinal.mk ℕ = cardinal.aleph_0 :=\n  (lift_id _).symm\n#align mk_nat mk_nat\n\n",
 "mk_list_eq_sum_pow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.pow.nat -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.pow.nat -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem mk_list_eq_sum_pow (α : Type u) : cardinal.mk (list α) = sum fun n : ℕ => cardinal.pow.nat (cardinal.mk α) n :=\n  calc\n    cardinal.mk (list α) = cardinal.mk (Σn, Vector α n) := mk_congr (Equiv.sigmaFiberEquiv list.length).symm\n    _ = sum fun n : ℕ => cardinal.pow.nat (cardinal.mk α) n := by simp\n    \n#align mk_list_eq_sum_pow mk_list_eq_sum_pow\n\n",
 "mk_le_one_iff_set_subsingleton":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n@[simp]\ntheorem mk_le_one_iff_set_subsingleton {s : set α} : cardinal.mk s ≤ 1 ↔ s.subsingleton :=\n  le_one_iff_subsingleton.trans s.subsingleton_coe\n#align mk_le_one_iff_set_subsingleton mk_le_one_iff_set_subsingleton\n\n",
 "mk_le_of_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem mk_le_of_surjective {α β : Type u} {f : α → β} (hf : surjective f) : cardinal.mk β ≤ cardinal.mk α :=\n  ⟨Embedding.ofSurjective f hf⟩\n#align mk_le_of_surjective mk_le_of_surjective\n\n",
 "mk_le_of_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem mk_le_of_injective {α β : Type u} {f : α → β} (hf : injective f) : cardinal.mk α ≤ cardinal.mk β :=\n  ⟨⟨f, hf⟩⟩\n#align mk_le_of_injective mk_le_of_injective\n\n",
 "mk_le_mk_of_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem mk_le_mk_of_subset {α} {s t : set α} (h : s ⊆ t) : cardinal.mk s ≤ cardinal.mk t :=\n  ⟨Set.embeddingOfSubset s t h⟩\n#align mk_le_mk_of_subset mk_le_mk_of_subset\n\n",
 "mk_le_mk_mul_of_mk_preimage_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem mk_le_mk_mul_of_mk_preimage_le {c : cardinal} (f : α → β) (hf : ∀ b : β, cardinal.mk («expr ⁻¹' » f {b}) ≤ c) :\n    cardinal.mk α ≤ cardinal.mk β * c := by\n  simpa only [← mk_congr (@Equiv.sigmaFiberEquiv α β f), mk_sigma, ← sum_const'] using sum_le_sum _ _ hf\n#align mk_le_mk_mul_of_mk_preimage_le mk_le_mk_mul_of_mk_preimage_le\n\n",
 "mk_le_aleph_0_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\ntheorem mk_le_aleph_0_iff : cardinal.mk α ≤ cardinal.aleph_0 ↔ countable α := by\n  rw [countable_iff_nonempty_embedding, aleph_0, ← lift_uzero (cardinal.mk α), lift_mk_le']\n#align mk_le_aleph_0_iff mk_le_aleph_0_iff\n\n",
 "mk_le_aleph_0":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n@[simp]\ntheorem mk_le_aleph_0 [countable α] : cardinal.mk α ≤ cardinal.aleph_0 :=\n  mk_le_aleph_0_iff.mpr ‹_›\n#align mk_le_aleph_0 mk_le_aleph_0\n\n",
 "mk_int":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\ntheorem mk_int : cardinal.mk ℤ = cardinal.aleph_0 :=\n  mk_denumerable ℤ\n#align mk_int mk_int\n\n",
 "mk_insert":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem mk_insert {α : Type u} {s : set α} {a : α} (h : a ∉ s) : cardinal.mk (insert a s : set α) = cardinal.mk s + 1 :=\n  by\n  rw [← union_singleton, mk_union_of_disjoint, mk_singleton]\n  simpa\n#align mk_insert mk_insert\n\n",
 "mk_image_le_lift":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem mk_image_le_lift {α : Type u} {β : Type v} {f : α → β} {s : set α} :\n    lift.{u} (cardinal.mk («expr '' » f s)) ≤ lift.{v} (cardinal.mk s) :=\n  lift_mk_le.{v, u, 0}.mpr ⟨Embedding.ofSurjective _ surjective_onto_image⟩\n#align mk_image_le_lift mk_image_le_lift\n\n",
 "mk_image_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem mk_image_le {α β : Type u} {f : α → β} {s : set α} : cardinal.mk («expr '' » f s) ≤ cardinal.mk s :=\n  mk_le_of_surjective surjective_onto_image\n#align mk_image_le mk_image_le\n\n",
 "mk_image_eq_of_inj_on_lift":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem mk_image_eq_of_inj_on_lift {α : Type u} {β : Type v} (f : α → β) (s : set α) (h : InjOn f s) :\n    lift.{u} (cardinal.mk («expr '' » f s)) = lift.{v} (cardinal.mk s) :=\n  lift_mk_eq.{v, u, 0}.mpr ⟨(Equiv.Set.imageOfInjOn f s h).symm⟩\n#align mk_image_eq_of_inj_on_lift mk_image_eq_of_inj_on_lift\n\n",
 "mk_image_eq_of_inj_on":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem mk_image_eq_of_inj_on {α β : Type u} (f : α → β) (s : set α) (h : InjOn f s) :\n    cardinal.mk («expr '' » f s) = cardinal.mk s :=\n  mk_congr (Equiv.Set.imageOfInjOn f s h).symm\n#align mk_image_eq_of_inj_on mk_image_eq_of_inj_on\n\n",
 "mk_image_eq_lift":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem mk_image_eq_lift {α : Type u} {β : Type v} (f : α → β) (s : set α) (h : injective f) :\n    lift.{u} (cardinal.mk («expr '' » f s)) = lift.{v} (cardinal.mk s) :=\n  lift_mk_eq.{v, u, 0}.mpr ⟨(Equiv.Set.image f s h).symm⟩\n#align mk_image_eq_lift mk_image_eq_lift\n\n",
 "mk_image_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem mk_image_eq {α β : Type u} {f : α → β} {s : set α} (hf : injective f) :\n    cardinal.mk («expr '' » f s) = cardinal.mk s :=\n  mk_congr (Equiv.Set.image f s hf).symm\n#align mk_image_eq mk_image_eq\n\n",
 "mk_fintype":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n@[simp]\ntheorem mk_fintype (α : Type u) [fintype α] : cardinal.mk α = fintype.card α :=\n  by\n  refine' fintype.induction_empty_option _ _ _ α\n  · intro α β h e hα\n    letI := fintype.of_equiv β e.symm\n    rwa [mk_congr e, fintype.card_congr e] at hα\n  · rfl\n  · intro α h hα\n    simp [hα]\n    rfl\n#align mk_fintype mk_fintype\n\n",
 "mk_finsupp_of_fintype":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.pow.nat -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem mk_finsupp_of_fintype (α β : Type u) [fintype α] [Zero β] :\n    cardinal.mk («expr →₀ » α β) = cardinal.pow.nat (cardinal.mk β) (fintype.card α) := by simp\n#align mk_finsupp_of_fintype mk_finsupp_of_fintype\n\n",
 "mk_finsupp_lift_of_fintype":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.pow.nat -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n@[simp]\ntheorem mk_finsupp_lift_of_fintype (α : Type u) (β : Type v) [fintype α] [Zero β] :\n    cardinal.mk («expr →₀ » α β) = cardinal.pow.nat (lift.{u} (cardinal.mk β)) (fintype.card α) := by\n  simpa using (@finsupp.equiv_fun_on_finite α β _ _).cardinal_eq\n#align mk_finsupp_lift_of_fintype mk_finsupp_lift_of_fintype\n\n",
 "mk_finset_of_fintype":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.pow.nat -/\ntheorem mk_finset_of_fintype [fintype α] : cardinal.mk (Finset α) = cardinal.pow.nat 2 (fintype.card α) := by simp\n#align mk_finset_of_fintype mk_finset_of_fintype\n\n",
 "mk_fin":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n@[simp]\ntheorem mk_fin (n : ℕ) : cardinal.mk (fin n) = n := by simp\n#align mk_fin mk_fin\n\n",
 "mk_eq_zero_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem mk_eq_zero_iff {α : Type u} : cardinal.mk α = 0 ↔ is_empty α :=\n  ⟨fun e =>\n    let ⟨h⟩ := quotient.exact e\n    h.is_empty,\n    @mk_eq_zero α⟩\n#align mk_eq_zero_iff mk_eq_zero_iff\n\n",
 "mk_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem mk_eq_zero (α : Type u) [is_empty α] : cardinal.mk α = 0 :=\n  (Equiv.equivPEmpty α).cardinal_eq\n#align mk_eq_zero mk_eq_zero\n\n",
 "mk_eq_two_iff'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem mk_eq_two_iff' (x : α) : cardinal.mk α = 2 ↔ ∃! y, y ≠ x :=\n  by\n  rw [mk_eq_two_iff]; constructor\n  · rintro ⟨a, b, hne, h⟩\n    simp only [eq_univ_iff_forall, mem_insert_iff, mem_singleton_iff] at h\n    rcases h x with (rfl | rfl)\n    exacts[⟨b, hne.symm, fun z => (h z).resolve_left⟩, ⟨a, hne, fun z => (h z).resolve_right⟩]\n  · rintro ⟨y, hne, hy⟩\n    exact ⟨x, y, hne.symm, eq_univ_of_forall fun z => or_iff_not_imp_left.2 (hy z)⟩\n#align mk_eq_two_iff' mk_eq_two_iff'\n\n",
 "mk_eq_two_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem mk_eq_two_iff : cardinal.mk α = 2 ↔ ∃ x y : α, x ≠ y ∧ ({x, y} : set α) = univ :=\n  by\n  simp only [← @Nat.cast_two cardinal, mk_eq_nat_iff_finset, finset.card_eq_two]\n  constructor\n  · rintro ⟨t, ht, x, y, hne, rfl⟩\n    exact ⟨x, y, hne, by simpa using ht⟩\n  · rintro ⟨x, y, hne, h⟩\n    exact ⟨{x, y}, by simpa using h, x, y, hne, rfl⟩\n#align mk_eq_two_iff mk_eq_two_iff\n\n",
 "mk_eq_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem mk_eq_one (α : Type u) [unique α] : cardinal.mk α = 1 :=\n  (Equiv.equivPUnit α).cardinal_eq\n#align mk_eq_one mk_eq_one\n\n",
 "mk_eq_nat_iff_fintype":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem mk_eq_nat_iff_fintype {n : ℕ} : cardinal.mk α = n ↔ ∃ h : fintype α, @fintype.card α h = n :=\n  by\n  rw [mk_eq_nat_iff_finset]\n  constructor\n  · rintro ⟨t, ht, hn⟩\n    exact ⟨⟨t, eq_univ_iff_forall.1 ht⟩, hn⟩\n  · rintro ⟨⟨t, ht⟩, hn⟩\n    exact ⟨t, eq_univ_iff_forall.2 ht, hn⟩\n#align mk_eq_nat_iff_fintype mk_eq_nat_iff_fintype\n\n",
 "mk_eq_nat_iff_finset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem mk_eq_nat_iff_finset {n : ℕ} : cardinal.mk α = n ↔ ∃ t : Finset α, (t : set α) = univ ∧ t.card = n := by\n  rw [← mk_univ, mk_set_eq_nat_iff_finset]\n#align mk_eq_nat_iff_finset mk_eq_nat_iff_finset\n\n",
 "mk_eq_nat_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\ntheorem mk_eq_nat_iff {α : Type u} {n : ℕ} : cardinal.mk α = n ↔ nonempty («expr ≃ » α (fin n)) := by\n  rw [← lift_mk_fin, ← lift_uzero (cardinal.mk α), lift_mk_eq']\n#align mk_eq_nat_iff mk_eq_nat_iff\n\n",
 "mk_eq_aleph_0":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n@[simp]\ntheorem mk_eq_aleph_0 (α : Type _) [countable α] [Infinite α] : cardinal.mk α = cardinal.aleph_0 :=\n  mk_le_aleph_0.antisymm <| aleph_0_le_mk _\n#align mk_eq_aleph_0 mk_eq_aleph_0\n\n",
 "mk_emptyc_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem mk_emptyc_iff {α : Type u} {s : set α} : cardinal.mk s = 0 ↔ s = ∅ :=\n  by\n  constructor\n  · intro h\n    rw [mk_eq_zero_iff] at h\n    exact eq_empty_iff_forall_not_mem.2 fun x hx => h.elim' ⟨x, hx⟩\n  · rintro rfl\n    exact mk_emptyc _\n#align mk_emptyc_iff mk_emptyc_iff\n\n",
 "mk_emptyc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n@[simp]\ntheorem mk_emptyc (α : Type u) : cardinal.mk (∅ : set α) = 0 :=\n  mk_eq_zero _\n#align mk_emptyc mk_emptyc\n\n",
 "mk_empty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n@[simp]\ntheorem mk_empty : cardinal.mk empty = 0 :=\n  mk_eq_zero _\n#align mk_empty mk_empty\n\n",
 "mk_diff_add_mk":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem mk_diff_add_mk {S T : set α} (h : T ⊆ S) : cardinal.mk (S \\ T : set α) + cardinal.mk T = cardinal.mk S :=\n  (mk_union_of_disjoint <| disjoint_sdiff_self_left).symm.trans <| by rw [diff_union_of_subset h]\n#align mk_diff_add_mk mk_diff_add_mk\n\n",
 "mk_denumerable":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n@[simp]\ntheorem mk_denumerable (α : Type u) [denumerable α] : cardinal.mk α = cardinal.aleph_0 :=\n  denumerable_iff.1 ⟨‹_›⟩\n#align mk_denumerable mk_denumerable\n\n",
 "mk_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟦ ⟧» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n@[simp]\ntheorem mk_def (α : Type u) : @eq cardinal («expr⟦ ⟧» α) (cardinal.mk α) :=\n  rfl\n#align mk_def mk_def\n\n",
 "mk_congr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem mk_congr (e : «expr ≃ » α β) : cardinal.mk α = cardinal.mk β :=\n  quot.sound ⟨e⟩\n#align mk_congr mk_congr\n\n",
 "mk_coe_finset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem mk_coe_finset {α : Type u} {s : Finset α} : cardinal.mk s = ↑(finset.card s) := by simp\n#align mk_coe_finset mk_coe_finset\n\n",
 "mk_bool":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n@[simp]\ntheorem mk_bool : cardinal.mk bool = 2 := by simp\n#align mk_bool mk_bool\n\n",
 "mk_bUnion_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem mk_bUnion_le {ι α : Type u} (A : ι → set α) (s : set ι) :\n    cardinal.mk\n        («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (A x)) ≤\n      cardinal.mk s *\n        «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n          (cardinal.mk (A x.1)) :=\n  by\n  rw [bUnion_eq_Union]\n  apply mk_Union_le\n#align mk_bUnion_le mk_bUnion_le\n\n",
 "mk_arrow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.pow -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem mk_arrow (α : Type u) (β : Type v) :\n    cardinal.mk (α → β) = cardinal.pow (lift.{u} (cardinal.mk β)) (lift.{v} (cardinal.mk α)) :=\n  mk_congr (equiv.ulift.symm.arrow_congr equiv.ulift.symm)\n#align mk_arrow mk_arrow\n\n",
 "mk_Union_le_sum_mk":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem mk_Union_le_sum_mk {α ι : Type u} {f : ι → set α} :\n    cardinal.mk\n        («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (f i)) ≤\n      sum fun i => cardinal.mk (f i) :=\n  calc\n    cardinal.mk\n          («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (f i)) ≤\n        cardinal.mk (Σi, f i) :=\n      mk_le_of_surjective (Set.sigmaToUnionᵢ_surjective f)\n    _ = sum fun i => cardinal.mk (f i) := mk_sigma _\n    \n#align mk_Union_le_sum_mk mk_Union_le_sum_mk\n\n",
 "mk_Union_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem mk_Union_le {α ι : Type u} (f : ι → set α) :\n    cardinal.mk\n        («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (f i)) ≤\n      cardinal.mk ι *\n        «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n          (cardinal.mk (f i)) :=\n  mk_Union_le_sum_mk.trans (sum_le_supr _)\n#align mk_Union_le mk_Union_le\n\n",
 "mk_Union_eq_sum_mk":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem mk_Union_eq_sum_mk {α ι : Type u} {f : ι → set α} (h : ∀ i j, i ≠ j → Disjoint (f i) (f j)) :\n    cardinal.mk\n        («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (f i)) =\n      sum fun i => cardinal.mk (f i) :=\n  calc\n    cardinal.mk\n          («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (f i)) =\n        cardinal.mk (Σi, f i) :=\n      mk_congr (Set.unionEqSigmaOfDisjoint h)\n    _ = sum fun i => cardinal.mk (f i) := mk_sigma _\n    \n#align mk_Union_eq_sum_mk mk_Union_eq_sum_mk\n\n",
 "mk_Prop":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n@[simp]\ntheorem mk_Prop : cardinal.mk Prop = 2 := by simp\n#align mk_Prop mk_Prop\n\n",
 "map_mk":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n@[simp]\ntheorem map_mk (f : Type u → Type v) (hf : ∀ α β, «expr ≃ » α β → «expr ≃ » (f α) (f β)) (α : Type u) :\n    map f hf (cardinal.mk α) = cardinal.mk (f α) :=\n  rfl\n#align map_mk map_mk\n\n",
 "lt_wf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ↪ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\nprotected theorem lt_wf : @well_founded cardinal.{u} (· < ·) :=\n  ⟨fun a =>\n    by_contradiction fun h => by\n      let ι := { c : cardinal // ¬acc (· < ·) c }\n      let f : ι → cardinal := subtype.val\n      haveI hι : nonempty ι := ⟨⟨_, h⟩⟩\n      obtain ⟨⟨c : cardinal, hc : ¬acc (· < ·) c⟩, ⟨h_1 : ∀ j, «expr ↪ » (f ⟨c, hc⟩).out (f j).out⟩⟩ :=\n        embedding.min_injective fun i => (f i).out\n      apply hc (acc.intro _ fun j h' => by_contradiction fun hj => h'.2 _)\n      have : cardinal.mk _ ≤ cardinal.mk _ := ⟨h_1 ⟨j, hj⟩⟩\n      simpa only [f, mk_out] using this⟩\n#align lt_wf lt_wf\n\n",
 "lt_lift_iff":
 "theorem lt_lift_iff {a : cardinal.{u}} {b : cardinal.{max u v}} : b < lift a ↔ ∃ a', lift a' = b ∧ a' < a :=\n  ⟨fun h =>\n    let ⟨a', e⟩ := lift_down h.le\n    ⟨a', e, lift_lt.1 <| e.symm ▸ h⟩,\n    fun ⟨a', e, h⟩ => e ▸ lift_lt.2 h⟩\n#align lt_lift_iff lt_lift_iff\n\n",
 "lt_aleph_0_of_finite":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\ntheorem lt_aleph_0_of_finite (α : Type u) [Finite α] : cardinal.mk α < cardinal.aleph_0 :=\n  lt_aleph_0_iff_finite.2 ‹_›\n#align lt_aleph_0_of_finite lt_aleph_0_of_finite\n\n",
 "lt_aleph_0_iff_subtype_finite":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n@[simp]\ntheorem lt_aleph_0_iff_subtype_finite {p : α → Prop} :\n    cardinal.mk { x // p x } < cardinal.aleph_0 ↔ { x | p x }.finite :=\n  lt_aleph_0_iff_set_finite\n#align lt_aleph_0_iff_subtype_finite lt_aleph_0_iff_subtype_finite\n\n",
 "lt_aleph_0_iff_set_finite":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n@[simp]\ntheorem lt_aleph_0_iff_set_finite {S : set α} : cardinal.mk S < cardinal.aleph_0 ↔ S.finite :=\n  lt_aleph_0_iff_finite.trans finite_coe_iff\n#align lt_aleph_0_iff_set_finite lt_aleph_0_iff_set_finite\n\n",
 "lt_aleph_0_iff_fintype":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\ntheorem lt_aleph_0_iff_fintype {α : Type u} : cardinal.mk α < cardinal.aleph_0 ↔ nonempty (fintype α) :=\n  lt_aleph_0_iff_finite.trans (finite_iff_nonempty_fintype _)\n#align lt_aleph_0_iff_fintype lt_aleph_0_iff_fintype\n\n",
 "lt_aleph_0_iff_finite":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\ntheorem lt_aleph_0_iff_finite {α : Type u} : cardinal.mk α < cardinal.aleph_0 ↔ Finite α := by\n  simp only [lt_aleph_0, mk_eq_nat_iff, finite_iff_exists_equiv_fin]\n#align lt_aleph_0_iff_finite lt_aleph_0_iff_finite\n\n",
 "lt_aleph_0":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\ntheorem lt_aleph_0 {c : cardinal} : c < cardinal.aleph_0 ↔ ∃ n : ℕ, c = n :=\n  ⟨fun h => by\n    rcases lt_lift_iff.1 h with ⟨c, rfl, h'⟩\n    rcases le_mk_iff_exists_set.1 h'.1 with ⟨S, rfl⟩\n    suffices S.finite by\n      lift S to Finset ℕ using this\n      simp\n    contrapose! h'\n    haveI := infinite.to_subtype h'\n    exact ⟨infinite.nat_embedding S⟩, fun ⟨n, e⟩ => e.symm ▸ nat_lt_aleph_0 _⟩\n#align lt_aleph_0 lt_aleph_0\n\n",
 "lift_zero":
 "@[simp]\ntheorem lift_zero : lift 0 = 0 :=\n  mk_congr (Equiv.equivPEmpty _)\n#align lift_zero lift_zero\n\n",
 "lift_uzero":
 "/-- A cardinal lifted to the zero universe equals itself. -/\n@[simp]\ntheorem lift_uzero (a : cardinal.{u}) : lift.{0} a = a :=\n  lift_id'.{0, u} a\n#align lift_uzero lift_uzero\n\n",
 "lift_umax_eq":
 "@[simp]\ntheorem lift_umax_eq {a : cardinal.{u}} {b : cardinal.{v}} :\n    lift.{max v w} a = lift.{max u w} b ↔ lift.{v} a = lift.{u} b := by rw [← lift_lift, ← lift_lift, lift_inj]\n#align lift_umax_eq lift_umax_eq\n\n",
 "lift_umax'":
 "/-- `lift.{(max v u) u}` equals `lift.{v u}`. Using `set_option pp.universes true` will make it much\n    easier to understand what's happening when using this lemma. -/\n@[simp]\ntheorem lift_umax' : lift.{max v u, u} = lift.{v, u} :=\n  lift_umax\n#align lift_umax' lift_umax'\n\n",
 "lift_umax":
 "/-- `lift.{(max u v) u}` equals `lift.{v u}`. Using `set_option pp.universes true` will make it much\n    easier to understand what's happening when using this lemma. -/\n@[simp]\ntheorem lift_umax : lift.{max u v, u} = lift.{v, u} :=\n  funext fun a => induction_on a fun α => (equiv.ulift.trans equiv.ulift.symm).cardinal_eq\n#align lift_umax lift_umax\n\n",
 "lift_two_power":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.pow -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.pow -/\ntheorem lift_two_power (a) : lift (cardinal.pow 2 a) = cardinal.pow 2 (lift a) := by simp\n#align lift_two_power lift_two_power\n\n",
 "lift_two":
 "theorem lift_two : lift.{u, v} 2 = 2 := by simp\n#align lift_two lift_two\n\n",
 "lift_supr_le_lift_supr'":
 "/-- A variant of `lift_supr_le_lift_supr` with universes specialized via `w = v` and `w' = v'`.\nThis is sometimes necessary to avoid universe unification issues. -/\ntheorem lift_supr_le_lift_supr' {ι : Type v} {ι' : Type v'} {f : ι → cardinal.{v}} {f' : ι' → cardinal.{v'}}\n    (hf : BddAbove (range f)) (hf' : BddAbove (range f')) (g : ι → ι')\n    (h : ∀ i, lift.{v'} (f i) ≤ lift.{v} (f' (g i))) : lift.{v'} (supᵢ f) ≤ lift.{v} (supᵢ f') :=\n  lift_supr_le_lift_supr hf hf' h\n#align lift_supr_le_lift_supr' lift_supr_le_lift_supr'\n\n",
 "lift_supr_le_lift_supr":
 "/-- To prove an inequality between the lifts to a common universe of two different supremums,\nit suffices to show that the lift of each cardinal from the smaller supremum\nif bounded by the lift of some cardinal from the larger supremum.\n-/\ntheorem lift_supr_le_lift_supr {ι : Type v} {ι' : Type v'} {f : ι → cardinal.{w}} {f' : ι' → cardinal.{w'}}\n    (hf : BddAbove (range f)) (hf' : BddAbove (range f')) {g : ι → ι'}\n    (h : ∀ i, lift.{w'} (f i) ≤ lift.{w} (f' (g i))) : lift.{w'} (supᵢ f) ≤ lift.{w} (supᵢ f') :=\n  by\n  rw [lift_supr hf, lift_supr hf']\n  exact csupᵢ_mono' (bdd_above_range_comp hf' _) fun i => ⟨_, h i⟩\n#align lift_supr_le_lift_supr lift_supr_le_lift_supr\n\n",
 "lift_supr_le_iff":
 "@[simp]\ntheorem lift_supr_le_iff {ι : Type v} {f : ι → cardinal.{w}} (hf : BddAbove (range f)) {t : cardinal} :\n    lift.{u} (supᵢ f) ≤ t ↔ ∀ i, lift.{u} (f i) ≤ t :=\n  by\n  rw [lift_supr hf]\n  exact csupᵢ_le_iff' (bdd_above_range_comp hf _)\n#align lift_supr_le_iff lift_supr_le_iff\n\n",
 "lift_supr_le":
 "/-- To prove that the lift of a supremum is bounded by some cardinal `t`,\nit suffices to show that the lift of each cardinal is bounded by `t`. -/\ntheorem lift_supr_le {ι : Type v} {f : ι → cardinal.{w}} {t : cardinal} (hf : BddAbove (range f))\n    (w : ∀ i, lift.{u} (f i) ≤ t) : lift.{u} (supᵢ f) ≤ t :=\n  by\n  rw [lift_supr hf]\n  exact csupᵢ_le' w\n#align lift_supr_le lift_supr_le\n\n",
 "lift_supr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/-- The lift of a supremum is the supremum of the lifts. -/\ntheorem lift_supr {ι : Type v} {f : ι → cardinal.{w}} (hf : BddAbove (range f)) :\n    lift.{u} (supᵢ f) =\n      «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n        (lift.{u} (f i)) :=\n  by rw [supᵢ, supᵢ, lift_Sup hf, ← range_comp]\n#align lift_supr lift_supr\n\n",
 "lift_sum":
 "@[simp]\ntheorem lift_sum {ι : Type u} (f : ι → cardinal.{v}) :\n    cardinal.lift.{w} (cardinal.sum f) = cardinal.sum fun i => cardinal.lift.{w} (f i) :=\n  equiv.cardinal_eq <|\n    equiv.ulift.trans <|\n      equiv.sigma_congr_right fun a => nonempty.some <| by rw [← lift_mk_eq, mk_out, mk_out, lift_lift]\n#align lift_sum lift_sum\n\n",
 "lift_succ":
 "@[simp]\ntheorem lift_succ (a) : lift (succ a) = succ (lift a) :=\n  le_antisymm\n    (le_of_not_gt fun h => by\n      rcases lt_lift_iff.1 h with ⟨b, e, h⟩\n      rw [lt_succ_iff, ← lift_le, e] at h\n      exact h.not_lt (lt_succ _))\n    (succ_le_of_lt <| lift_lt.2 <| lt_succ a)\n#align lift_succ lift_succ\n\n",
 "lift_strict_mono":
 "theorem lift_strict_mono : strict_mono lift := fun a b => lift_lt.2\n#align lift_strict_mono lift_strict_mono\n\n",
 "lift_prod":
 "@[simp]\ntheorem lift_prod {ι : Type u} (c : ι → cardinal.{v}) : lift.{w} (prod c) = prod fun i => lift.{w} (c i) :=\n  by\n  lift c to ι → Type v using fun _ => trivial\n  simp only [← mk_pi, ← mk_ulift]\n  exact mk_congr (equiv.ulift.trans <| Equiv.piCongrRight fun i => equiv.ulift.symm)\n#align lift_prod lift_prod\n\n",
 "lift_power":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.pow -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.pow -/\n@[simp]\ntheorem lift_power (a b) : lift (cardinal.pow a b) = cardinal.pow (lift a) (lift b) :=\n  induction_on₂ a b fun α β => mk_congr <| equiv.ulift.trans (equiv.ulift.arrow_congr equiv.ulift).symm\n#align lift_power lift_power\n\n",
 "lift_one":
 "@[simp]\ntheorem lift_one : lift 1 = 1 :=\n  mk_congr <| equiv.ulift.trans Equiv.punitEquivPUnit\n#align lift_one lift_one\n\n",
 "lift_nat_cast":
 "@[simp]\ntheorem lift_nat_cast (n : ℕ) : lift.{u} (n : cardinal.{v}) = n := by induction n <;> simp [*]\n#align lift_nat_cast lift_nat_cast\n\n",
 "lift_mul":
 "@[simp]\ntheorem lift_mul (a b) : lift (a * b) = lift a * lift b :=\n  induction_on₂ a b fun α β => mk_congr <| equiv.ulift.trans (Equiv.prodCongr equiv.ulift equiv.ulift).symm\n#align lift_mul lift_mul\n\n",
 "lift_monotone":
 "theorem lift_monotone : monotone lift :=\n  lift_strict_mono.monotone\n#align lift_monotone lift_monotone\n\n",
 "lift_mk_shrink''":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n@[simp]\ntheorem lift_mk_shrink'' (α : Type max u v) [Small.{v} α] :\n    cardinal.lift.{u} (cardinal.mk (Shrink.{v} α)) = cardinal.mk α := by\n  rw [← lift_umax', lift_mk_shrink.{max u v, v, 0} α, ← lift_umax, lift_id]\n#align lift_mk_shrink'' lift_mk_shrink''\n\n",
 "lift_mk_shrink'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n@[simp]\ntheorem lift_mk_shrink' (α : Type u) [Small.{v} α] :\n    cardinal.lift.{u} (cardinal.mk (Shrink.{v} α)) = cardinal.lift.{v} (cardinal.mk α) :=\n  lift_mk_shrink.{u, v, 0} α\n#align lift_mk_shrink' lift_mk_shrink'\n\n",
 "lift_mk_shrink":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n@[simp]\ntheorem lift_mk_shrink (α : Type u) [Small.{v} α] :\n    cardinal.lift.{max u w} (cardinal.mk (Shrink.{v} α)) = cardinal.lift.{max v w} (cardinal.mk α) :=\n  lift_mk_eq.2 ⟨(equivShrink α).symm⟩\n#align lift_mk_shrink lift_mk_shrink\n\n",
 "lift_mk_le_lift_mk_mul_of_lift_mk_preimage_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem lift_mk_le_lift_mk_mul_of_lift_mk_preimage_le {α : Type u} {β : Type v} {c : cardinal} (f : α → β)\n    (hf : ∀ b : β, lift.{v} (cardinal.mk («expr ⁻¹' » f {b})) ≤ c) :\n    lift.{v} (cardinal.mk α) ≤ lift.{u} (cardinal.mk β) * c :=\n  (mk_le_mk_mul_of_mk_preimage_le fun x : ULift.{v} α => ulift.up.{u} (f x.1)) <|\n    ULift.forall.2 fun b =>\n      (mk_congr <|\n            (equiv.ulift.image _).trans\n              (equiv.trans\n                (by\n                  rw [Equiv.image_eq_preimage]\n                  simp [Set.preimage])\n                equiv.ulift.symm)).trans_le\n        (hf b)\n#align lift_mk_le_lift_mk_mul_of_lift_mk_preimage_le lift_mk_le_lift_mk_mul_of_lift_mk_preimage_le\n\n",
 "lift_mk_le'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ↪ » -/\n/-- A variant of `cardinal.lift_mk_le` with specialized universes.\nBecause Lean often can not realize it should use this specialization itself,\nwe provide this statement separately so you don't have to solve the specialization problem either.\n-/\ntheorem lift_mk_le' {α : Type u} {β : Type v} :\n    lift.{v} (cardinal.mk α) ≤ lift.{u} (cardinal.mk β) ↔ nonempty («expr ↪ » α β) :=\n  lift_mk_le.{u, v, 0}\n#align lift_mk_le' lift_mk_le'\n\n",
 "lift_mk_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ↪ » -/\ntheorem lift_mk_le {α : Type u} {β : Type v} :\n    lift.{max v w} (cardinal.mk α) ≤ lift.{max u w} (cardinal.mk β) ↔ nonempty («expr ↪ » α β) :=\n  ⟨fun ⟨f⟩ => ⟨Embedding.congr equiv.ulift equiv.ulift f⟩, fun ⟨f⟩ =>\n    ⟨Embedding.congr equiv.ulift.symm equiv.ulift.symm f⟩⟩\n#align lift_mk_le lift_mk_le\n\n",
 "lift_mk_fin":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem lift_mk_fin (n : ℕ) : lift (cardinal.mk (fin n)) = n := by simp\n#align lift_mk_fin lift_mk_fin\n\n",
 "lift_mk_eq'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n/-- A variant of `cardinal.lift_mk_eq` with specialized universes.\nBecause Lean often can not realize it should use this specialization itself,\nwe provide this statement separately so you don't have to solve the specialization problem either.\n-/\ntheorem lift_mk_eq' {α : Type u} {β : Type v} :\n    lift.{v} (cardinal.mk α) = lift.{u} (cardinal.mk β) ↔ nonempty («expr ≃ » α β) :=\n  lift_mk_eq.{u, v, 0}\n#align lift_mk_eq' lift_mk_eq'\n\n",
 "lift_mk_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\ntheorem lift_mk_eq {α : Type u} {β : Type v} :\n    lift.{max v w} (cardinal.mk α) = lift.{max u w} (cardinal.mk β) ↔ nonempty («expr ≃ » α β) :=\n  quotient.eq.trans\n    ⟨fun ⟨f⟩ => ⟨equiv.ulift.symm.trans <| f.trans equiv.ulift⟩, fun ⟨f⟩ =>\n      ⟨equiv.ulift.trans <| f.trans equiv.ulift.symm⟩⟩\n#align lift_mk_eq lift_mk_eq\n\n",
 "lift_min":
 "@[simp]\ntheorem lift_min {a b : cardinal} : lift (min a b) = min (lift a) (lift b) :=\n  lift_monotone.map_min\n#align lift_min lift_min\n\n",
 "lift_max":
 "@[simp]\ntheorem lift_max {a b : cardinal} : lift (max a b) = max (lift a) (lift b) :=\n  lift_monotone.map_max\n#align lift_max lift_max\n\n",
 "lift_lt":
 "@[simp]\ntheorem lift_lt {a b : cardinal} : lift a < lift b ↔ a < b :=\n  lift_order_embedding.lt_iff_lt\n#align lift_lt lift_lt\n\n",
 "lift_lift":
 "@[simp]\ntheorem lift_lift (a : cardinal) : lift.{w} (lift.{v} a) = lift.{max v w} a :=\n  induction_on a fun α => (equiv.ulift.trans <| equiv.ulift.trans equiv.ulift.symm).cardinal_eq\n#align lift_lift lift_lift\n\n",
 "lift_le_aleph_0":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n@[simp]\ntheorem lift_le_aleph_0 {c : cardinal.{u}} : lift.{v} c ≤ cardinal.aleph_0 ↔ c ≤ cardinal.aleph_0 := by\n  rw [← lift_aleph_0, lift_le]\n#align lift_le_aleph_0 lift_le_aleph_0\n\n",
 "lift_le":
 "@[simp]\ntheorem lift_le {a b : cardinal} : lift a ≤ lift b ↔ a ≤ b :=\n  induction_on₂ a b fun α β => by\n    rw [← lift_umax]\n    exact lift_mk_le\n#align lift_le lift_le\n\n",
 "lift_injective":
 "theorem lift_injective : injective lift.{u, v} :=\n  lift_order_embedding.injective\n#align lift_injective lift_injective\n\n",
 "lift_inj":
 "@[simp]\ntheorem lift_inj {a b : cardinal} : lift a = lift b ↔ a = b :=\n  lift_injective.eq_iff\n#align lift_inj lift_inj\n\n",
 "lift_infi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n@[simp]\ntheorem lift_infi {ι} (f : ι → cardinal) :\n    lift (infᵢ f) =\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (lift (f i)) :=\n  by\n  unfold infᵢ\n  convert lift_Inf (range f)\n  rw [range_comp]\n#align lift_infi lift_infi\n\n",
 "lift_id'":
 "/-- A cardinal lifted to a lower or equal universe equals itself. -/\n@[simp]\ntheorem lift_id' (a : cardinal.{max u v}) : lift.{u} a = a :=\n  induction_on a fun α => mk_congr equiv.ulift\n#align lift_id' lift_id'\n\n",
 "lift_id":
 "/-- A cardinal lifted to the same universe equals itself. -/\n@[simp]\ntheorem lift_id (a : cardinal) : lift.{u, u} a = a :=\n  lift_id'.{u, u} a\n#align lift_id lift_id\n\n",
 "lift_eq_zero":
 "@[simp]\ntheorem lift_eq_zero {a : cardinal.{v}} : lift.{u} a = 0 ↔ a = 0 :=\n  lift_injective.eq_iff' lift_zero\n#align lift_eq_zero lift_eq_zero\n\n",
 "lift_eq_nat_iff":
 "@[simp]\ntheorem lift_eq_nat_iff {a : cardinal.{u}} {n : ℕ} : lift.{v} a = n ↔ a = n :=\n  lift_injective.eq_iff' (lift_nat_cast n)\n#align lift_eq_nat_iff lift_eq_nat_iff\n\n",
 "lift_down":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem lift_down {a : cardinal.{u}} {b : cardinal.{max u v}} : b ≤ lift a → ∃ a', lift a' = b :=\n  induction_on₂ a b fun α β => by\n    rw [← lift_id (cardinal.mk β), ← lift_umax, ← lift_umax.{u, v}, lift_mk_le] <;>\n      exact fun ⟨f⟩ =>\n        ⟨cardinal.mk (Set.range f),\n          eq.symm <|\n            lift_mk_eq.2\n              ⟨embedding.equiv_of_surjective (embedding.cod_restrict _ f Set.mem_range_self) fun ⟨a, ⟨b, e⟩⟩ =>\n                  ⟨b, subtype.eq e⟩⟩⟩\n#align lift_down lift_down\n\n",
 "lift_bit1":
 "@[simp]\ntheorem lift_bit1 (a : cardinal) : lift (bit1 a) = bit1 (lift a) := by simp [bit1]\n#align lift_bit1 lift_bit1\n\n",
 "lift_bit0":
 "@[simp]\ntheorem lift_bit0 (a : cardinal) : lift (bit0 a) = bit0 (lift a) :=\n  lift_add a a\n#align lift_bit0 lift_bit0\n\n",
 "lift_aleph_0":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n@[simp]\ntheorem lift_aleph_0 : lift (cardinal.aleph_0) = cardinal.aleph_0 :=\n  lift_lift _\n#align lift_aleph_0 lift_aleph_0\n\n",
 "lift_add":
 "@[simp]\ntheorem lift_add (a b) : lift (a + b) = lift a + lift b :=\n  induction_on₂ a b fun α β => mk_congr <| equiv.ulift.trans (Equiv.sumCongr equiv.ulift equiv.ulift).symm\n#align lift_add lift_add\n\n",
 "lift_Sup":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/-- The lift of a supremum is the supremum of the lifts. -/\ntheorem lift_Sup {s : set cardinal} (hs : BddAbove s) : lift.{u} (supₛ s) = supₛ («expr '' » lift.{u} s) :=\n  by\n  apply ((le_csupₛ_iff' (bdd_above_image _ hs)).2 fun c hc => _).antisymm (csupₛ_le' _)\n  · by_contra h\n    obtain ⟨d, rfl⟩ := cardinal.lift_down (not_le.1 h).le\n    simp_rw [lift_le] at h hc\n    rw [csupₛ_le_iff' hs] at h\n    exact h fun a ha => lift_le.1 <| hc (mem_image_of_mem _ ha)\n  · rintro i ⟨j, hj, rfl⟩\n    exact lift_le.2 (le_csupₛ hs hj)\n#align lift_Sup lift_Sup\n\n",
 "lift_Inf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n@[simp]\ntheorem lift_Inf (s : set cardinal) : lift (infₛ s) = infₛ («expr '' » lift s) :=\n  by\n  rcases eq_empty_or_nonempty s with (rfl | hs)\n  · simp\n  · exact lift_monotone.map_Inf hs\n#align lift_Inf lift_Inf\n\n",
 "le_sum":
 "theorem le_sum {ι} (f : ι → cardinal) (i) : f i ≤ sum f := by\n  rw [← quotient.out_eq (f i)] <;> exact ⟨⟨fun a => ⟨i, a⟩, fun a b h => eq_of_heq <| by injection h⟩⟩\n#align le_sum le_sum\n\n",
 "le_powerlt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.pow -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.pow -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^< » -/\ntheorem le_powerlt {b c : cardinal.{u}} (a) (h : c < b) : cardinal.pow a c ≤ «expr ^< » a b :=\n  by\n  apply @le_csupᵢ _ _ _ (fun y : Iio b => cardinal.pow a y) _ ⟨c, h⟩\n  rw [← image_eq_range]\n  exact bdd_above_image.{u, u} _ bddAbove_Iio\n#align le_powerlt le_powerlt\n\n",
 "le_one_iff_subsingleton":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem le_one_iff_subsingleton {α : Type u} : cardinal.mk α ≤ 1 ↔ subsingleton α :=\n  ⟨fun ⟨f⟩ => ⟨fun a b => f.injective (subsingleton.elim _ _)⟩, fun ⟨h⟩ => ⟨⟨fun a => PUnit.unit, fun a b _ => h _ _⟩⟩⟩\n#align le_one_iff_subsingleton le_one_iff_subsingleton\n\n",
 "le_mk_iff_exists_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem le_mk_iff_exists_subset {c : cardinal} {α : Type u} {s : set α} :\n    c ≤ cardinal.mk s ↔ ∃ p : set α, p ⊆ s ∧ cardinal.mk p = c :=\n  by\n  rw [le_mk_iff_exists_set, ← Subtype.exists_set_subtype]\n  apply exists_congr; intro t; rw [mk_image_eq]; apply subtype.val_injective\n#align le_mk_iff_exists_subset le_mk_iff_exists_subset\n\n",
 "le_mk_iff_exists_set":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem le_mk_iff_exists_set {c : cardinal} {α : Type u} : c ≤ cardinal.mk α ↔ ∃ p : set α, cardinal.mk p = c :=\n  ⟨induction_on c fun β ⟨⟨f, hf⟩⟩ => ⟨Set.range f, (Equiv.ofInjective f hf).cardinal_eq.symm⟩, fun ⟨p, e⟩ =>\n    e ▸ ⟨⟨subtype.val, fun a b => subtype.eq⟩⟩⟩\n#align le_mk_iff_exists_set le_mk_iff_exists_set\n\n",
 "le_mk_diff_add_mk":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem le_mk_diff_add_mk (S T : set α) : cardinal.mk S ≤ cardinal.mk (S \\ T : set α) + cardinal.mk T :=\n  (mk_le_mk_of_subset <| subset_diff_union _ _).trans <| mk_union_le _ _\n#align le_mk_diff_add_mk le_mk_diff_add_mk\n\n",
 "le_lift_iff":
 "theorem le_lift_iff {a : cardinal.{u}} {b : cardinal.{max u v}} : b ≤ lift a ↔ ∃ a', lift a' = b ∧ a' ≤ a :=\n  ⟨fun h =>\n    let ⟨a', e⟩ := lift_down h\n    ⟨a', e, lift_le.1 <| e.symm ▸ h⟩,\n    fun ⟨a', e, h⟩ => e ▸ lift_le.2 h⟩\n#align le_lift_iff le_lift_iff\n\n",
 "le_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ↪ » -/\ntheorem le_def (α β : Type u) : cardinal.mk α ≤ cardinal.mk β ↔ nonempty («expr ↪ » α β) :=\n  iff.rfl\n#align le_def le_def\n\n",
 "le_aleph_0_iff_subtype_countable":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n@[simp]\ntheorem le_aleph_0_iff_subtype_countable {p : α → Prop} :\n    cardinal.mk { x // p x } ≤ cardinal.aleph_0 ↔ { x | p x }.countable :=\n  le_aleph_0_iff_set_countable\n#align le_aleph_0_iff_subtype_countable le_aleph_0_iff_subtype_countable\n\n",
 "le_aleph_0_iff_set_countable":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n@[simp]\ntheorem le_aleph_0_iff_set_countable {s : set α} : cardinal.mk s ≤ cardinal.aleph_0 ↔ s.countable := by\n  rw [mk_le_aleph_0_iff, countable_coe_iff]\n#align le_aleph_0_iff_set_countable le_aleph_0_iff_set_countable\n\n",
 "infₛ_empty":
 "#print infₛ_empty /-\n@[simp]\ntheorem infₛ_empty : infₛ (∅ : set cardinal.{u}) = 0 :=\n  dif_neg not_nonempty_empty\n#align Inf_empty infₛ_empty\n-/\n\n",
 "infinite_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem infinite_iff {α : Type u} : Infinite α ↔ cardinal.aleph_0 ≤ cardinal.mk α := by\n  rw [← not_lt, lt_aleph_0_iff_finite, not_finite_iff_infinite]\n#align infinite_iff infinite_iff\n\n",
 "induction_on₃":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n@[elab_as_elim]\ntheorem induction_on₃ {p : cardinal → cardinal → cardinal → Prop} (c₁ : cardinal) (c₂ : cardinal) (c₃ : cardinal)\n    (h : ∀ α β γ, p (cardinal.mk α) (cardinal.mk β) (cardinal.mk γ)) : p c₁ c₂ c₃ :=\n  quotient.induction_on₃ c₁ c₂ c₃ h\n#align induction_on₃ induction_on₃\n\n",
 "induction_on₂":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n@[elab_as_elim]\ntheorem induction_on₂ {p : cardinal → cardinal → Prop} (c₁ : cardinal) (c₂ : cardinal)\n    (h : ∀ α β, p (cardinal.mk α) (cardinal.mk β)) : p c₁ c₂ :=\n  quotient.induction_on₂ c₁ c₂ h\n#align induction_on₂ induction_on₂\n\n",
 "induction_on":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/-\nCopyright (c) 2017 Johannes Hölzl. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johannes Hölzl, Mario Carneiro, Floris van Doorn\n-/\n@[elab_as_elim]\ntheorem induction_on {p : cardinal → Prop} (c : cardinal) (h : ∀ α, p (cardinal.mk α)) : p c :=\n  Quotient.inductionOn c h\n#align induction_on induction_on\n\n",
 "finset_card_lt_aleph_0":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\ntheorem finset_card_lt_aleph_0 (s : Finset α) : cardinal.mk (↑s : set α) < cardinal.aleph_0 :=\n  lt_aleph_0_of_finite _\n#align finset_card_lt_aleph_0 finset_card_lt_aleph_0\n\n",
 "exists_not_mem_of_length_lt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem exists_not_mem_of_length_lt {α : Type _} (l : list α) (h : ↑l.length < cardinal.mk α) : ∃ z : α, z ∉ l :=\n  by\n  contrapose! h\n  calc\n    cardinal.mk α = cardinal.mk (Set.univ : set α) := mk_univ.symm\n    _ ≤ cardinal.mk l.to_finset := mk_le_mk_of_subset fun x _ => list.mem_to_finset.mpr (h x)\n    _ = l.to_finset.card := cardinal.mk_coe_finset\n    _ ≤ l.length := cardinal.nat_cast_le.mpr (list.to_finset_card_le l)\n    \n#align exists_not_mem_of_length_lt exists_not_mem_of_length_lt\n\n",
 "exists_nat_eq_of_le_nat":
 "theorem exists_nat_eq_of_le_nat {c : cardinal} {n : ℕ} (h : c ≤ n) : ∃ m, m ≤ n ∧ c = m :=\n  let he := cast_to_nat_of_lt_aleph_0 (h.trans_lt <| nat_lt_aleph_0 n)\n  ⟨c.to_nat, nat_cast_le.1 (he.trans_le h), he.symm⟩\n#align exists_nat_eq_of_le_nat exists_nat_eq_of_le_nat\n\n",
 "eq_one_iff_unique":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem eq_one_iff_unique {α : Type _} : cardinal.mk α = 1 ↔ subsingleton α ∧ nonempty α :=\n  calc\n    cardinal.mk α = 1 ↔ cardinal.mk α ≤ 1 ∧ 1 ≤ cardinal.mk α := le_antisymm_iff\n    _ ↔ subsingleton α ∧ nonempty α := le_one_iff_subsingleton.and (one_le_iff_ne_zero.trans mk_ne_zero_iff)\n    \n#align eq_one_iff_unique eq_one_iff_unique\n\n",
 "eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\nprotected theorem eq : cardinal.mk α = cardinal.mk β ↔ nonempty («expr ≃ » α β) :=\n  quotient.eq\n#align eq eq\n\n",
 "denumerable_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\ntheorem denumerable_iff {α : Type u} : nonempty (denumerable α) ↔ cardinal.mk α = cardinal.aleph_0 :=\n  ⟨fun ⟨h⟩ => mk_congr ((@denumerable.eqv α h).trans equiv.ulift.symm), fun h =>\n    by\n    cases' quotient.exact h with f\n    exact ⟨denumerable.mk' <| f.trans equiv.ulift⟩⟩\n#align denumerable_iff denumerable_iff\n\n",
 "cast_to_nat_of_lt_aleph_0":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\ntheorem cast_to_nat_of_lt_aleph_0 {c : cardinal} (h : c < cardinal.aleph_0) : ↑c.to_nat = c := by\n  rw [to_nat_apply_of_lt_aleph_0 h, ← Classical.choose_spec (lt_aleph_0.1 h)]\n#align cast_to_nat_of_lt_aleph_0 cast_to_nat_of_lt_aleph_0\n\n",
 "cast_to_nat_of_aleph_0_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\ntheorem cast_to_nat_of_aleph_0_le {c : cardinal} (h : cardinal.aleph_0 ≤ c) : ↑c.to_nat = (0 : cardinal) := by\n  rw [to_nat_apply_of_aleph_0_le h, Nat.cast_zero]\n#align cast_to_nat_of_aleph_0_le cast_to_nat_of_aleph_0_le\n\n",
 "cardinal_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ↪ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem _root_.function.embedding.cardinal_le {α β : Type u} (f : «expr ↪ » α β) : cardinal.mk α ≤ cardinal.mk β :=\n  ⟨f⟩\n#align function.embedding.cardinal_le function.embedding.cardinal_le\n\n",
 "card_le_of_finset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem card_le_of_finset {α} (s : Finset α) : (s.card : cardinal) ≤ cardinal.mk α :=\n  @mk_coe_finset _ s ▸ mk_set_le _\n#align card_le_of_finset card_le_of_finset\n\n",
 "card_le_of":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem card_le_of {α : Type u} {n : ℕ} (H : ∀ s : Finset α, s.card ≤ n) : cardinal.mk α ≤ n :=\n  by\n  refine' le_of_lt_succ (lt_of_not_ge fun hn => _)\n  rw [← cardinal.nat_succ, ← lift_mk_fin n.succ] at hn\n  cases' hn with f\n  refine' (H <| finset.univ.map f).not_lt _\n  rw [finset.card_map, ← fintype.card, fintype.card_ulift, fintype.card_fin]\n  exact n.lt_succ_self\n#align card_le_of card_le_of\n\n",
 "cantor'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.pow -/\ntheorem cantor' (a) {b : cardinal} (hb : 1 < b) : a < cardinal.pow b a :=\n  by\n  rw [← succ_le_iff, (by norm_cast : succ (1 : cardinal) = 2)] at hb\n  exact (cantor a).trans_le (power_le_power_right hb)\n#align cantor' cantor'\n\n",
 "cantor":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.pow -/\n/-- **Cantor's theorem** -/\ntheorem cantor (a : cardinal.{u}) : a < cardinal.pow 2 a :=\n  by\n  induction' a using cardinal.induction_on with α\n  rw [← mk_set]\n  refine' ⟨⟨⟨singleton, fun a b => singleton_eq_singleton_iff.1⟩⟩, _⟩\n  rintro ⟨⟨f, hf⟩⟩\n  exact cantor_injective f hf\n#align cantor cantor\n\n",
 "bdd_above_range_comp":
 "theorem bdd_above_range_comp {ι : Type u} {f : ι → cardinal.{v}} (hf : BddAbove (range f))\n    (g : cardinal.{v} → cardinal.{max v w}) : BddAbove (range (g ∘ f)) :=\n  by\n  rw [range_comp]\n  exact bdd_above_image g hf\n#align bdd_above_range_comp bdd_above_range_comp\n\n",
 "bdd_above_range":
 "/-- The range of an indexed cardinal function, whose outputs live in a higher universe than the\n    inputs, is always bounded above. -/\ntheorem bdd_above_range {ι : Type u} (f : ι → cardinal.{max u v}) : BddAbove (Set.range f) :=\n  ⟨_, by\n    rintro a ⟨i, rfl⟩\n    exact le_sum f i⟩\n#align bdd_above_range bdd_above_range\n\n",
 "bdd_above_of_small":
 "theorem bdd_above_of_small (s : set cardinal.{u}) [h : Small.{u} s] : BddAbove s :=\n  bdd_above_iff_small.2 h\n#align bdd_above_of_small bdd_above_of_small\n\n",
 "bdd_above_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem bdd_above_image (f : cardinal.{u} → cardinal.{max u v}) {s : set cardinal.{u}} (hs : BddAbove s) :\n    BddAbove («expr '' » f s) := by\n  rw [bdd_above_iff_small] at hs⊢\n  exact small_lift _\n#align bdd_above_image bdd_above_image\n\n",
 "bdd_above_iff_small":
 "/-- A set of cardinals is bounded above iff it's small, i.e. it corresponds to an usual ZFC set. -/\ntheorem bdd_above_iff_small {s : set cardinal.{u}} : BddAbove s ↔ Small.{u} s :=\n  ⟨fun ⟨a, ha⟩ => @small_subset _ (Iic a) s (fun x h => ha h) _,\n    by\n    rintro ⟨ι, ⟨e⟩⟩\n    suffices (range fun x : ι => (e.symm x).1) = s by\n      rw [← this]\n      apply bdd_above_range.{u, u}\n    ext x\n    refine' ⟨_, fun hx => ⟨e ⟨x, hx⟩, _⟩⟩\n    · rintro ⟨a, rfl⟩\n      exact (e.symm a).prop\n    · simp_rw [subtype.val_eq_coe, equiv.symm_apply_apply]\n      rfl⟩\n#align bdd_above_iff_small bdd_above_iff_small\n\n",
 "aleph_0_to_part_enat":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem aleph_0_to_part_enat : to_part_enat (cardinal.aleph_0) = «expr⊤» :=\n  to_part_enat_apply_of_aleph_0_le le_rfl\n#align aleph_0_to_part_enat aleph_0_to_part_enat\n\n",
 "aleph_0_to_nat":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n@[simp]\ntheorem aleph_0_to_nat : to_nat (cardinal.aleph_0) = 0 :=\n  to_nat_apply_of_aleph_0_le le_rfl\n#align aleph_0_to_nat aleph_0_to_nat\n\n",
 "aleph_0_pos":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\ntheorem aleph_0_pos : 0 < cardinal.aleph_0 :=\n  pos_iff_ne_zero.2 aleph_0_ne_zero\n#align aleph_0_pos aleph_0_pos\n\n",
 "aleph_0_ne_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\ntheorem aleph_0_ne_zero : cardinal.aleph_0 ≠ 0 :=\n  mk_ne_zero _\n#align aleph_0_ne_zero aleph_0_ne_zero\n\n",
 "aleph_0_mul_nat":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n@[simp]\ntheorem aleph_0_mul_nat {n : ℕ} (hn : n ≠ 0) : cardinal.aleph_0 * n = cardinal.aleph_0 := by\n  rw [mul_comm, nat_mul_aleph_0 hn]\n#align aleph_0_mul_nat aleph_0_mul_nat\n\n",
 "aleph_0_mul_aleph_0":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\ntheorem aleph_0_mul_aleph_0 : cardinal.aleph_0 * cardinal.aleph_0 = cardinal.aleph_0 :=\n  mk_denumerable _\n#align aleph_0_mul_aleph_0 aleph_0_mul_aleph_0\n\n",
 "aleph_0_le_mul_iff'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n/-- See also `cardinal.aleph_0_le_mul_iff'`. -/\ntheorem aleph_0_le_mul_iff' {a b : cardinal.{u}} :\n    cardinal.aleph_0 ≤ a * b ↔ a ≠ 0 ∧ cardinal.aleph_0 ≤ b ∨ cardinal.aleph_0 ≤ a ∧ b ≠ 0 :=\n  by\n  have : ∀ {a : cardinal.{u}}, cardinal.aleph_0 ≤ a → a ≠ 0 := fun a => ne_bot_of_le_ne_bot aleph_0_ne_zero\n  simp only [aleph_0_le_mul_iff, and_or_left, and_iff_right_of_imp this, @and_left_comm (a ≠ 0)]\n  simp only [and_comm, or_comm]\n#align aleph_0_le_mul_iff' aleph_0_le_mul_iff'\n\n",
 "aleph_0_le_mul_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n/-- See also `cardinal.aleph_0_le_mul_iff`. -/\ntheorem aleph_0_le_mul_iff {a b : cardinal} :\n    cardinal.aleph_0 ≤ a * b ↔ a ≠ 0 ∧ b ≠ 0 ∧ (cardinal.aleph_0 ≤ a ∨ cardinal.aleph_0 ≤ b) :=\n  by\n  let h := (@mul_lt_aleph_0_iff a b).not\n  rwa [not_lt, not_or, not_or, not_and_or, not_lt, not_lt] at h\n#align aleph_0_le_mul_iff aleph_0_le_mul_iff\n\n",
 "aleph_0_le_mk":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n@[simp]\ntheorem aleph_0_le_mk (α : Type u) [Infinite α] : cardinal.aleph_0 ≤ cardinal.mk α :=\n  infinite_iff.1 ‹_›\n#align aleph_0_le_mk aleph_0_le_mk\n\n",
 "aleph_0_le_lift":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n@[simp]\ntheorem aleph_0_le_lift {c : cardinal.{u}} : cardinal.aleph_0 ≤ lift.{v} c ↔ cardinal.aleph_0 ≤ c := by\n  rw [← lift_aleph_0, lift_le]\n#align aleph_0_le_lift aleph_0_le_lift\n\n",
 "aleph_0_le_add_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\ntheorem aleph_0_le_add_iff {a b : cardinal} : cardinal.aleph_0 ≤ a + b ↔ cardinal.aleph_0 ≤ a ∨ cardinal.aleph_0 ≤ b :=\n  by simp only [← not_lt, add_lt_aleph_0_iff, not_and_or]\n#align aleph_0_le_add_iff aleph_0_le_add_iff\n\n",
 "aleph_0_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\ntheorem aleph_0_le {c : cardinal} : cardinal.aleph_0 ≤ c ↔ ∀ n : ℕ, ↑n ≤ c :=\n  ⟨fun h n => (nat_lt_aleph_0 _).le.trans h, fun h =>\n    le_of_not_lt fun hn => by\n      rcases lt_aleph_0.1 hn with ⟨n, rfl⟩\n      exact (nat.lt_succ_self _).not_le (nat_cast_le.1 (h (n + 1)))⟩\n#align aleph_0_le aleph_0_le\n\n",
 "aleph_0_add_nat":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n@[simp]\ntheorem aleph_0_add_nat (n : ℕ) : cardinal.aleph_0 + n = cardinal.aleph_0 :=\n  (add_le_aleph_0.2 ⟨le_rfl, (nat_lt_aleph_0 n).le⟩).antisymm le_self_add\n#align aleph_0_add_nat aleph_0_add_nat\n\n",
 "aleph_0_add_aleph_0":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n@[simp]\ntheorem aleph_0_add_aleph_0 : cardinal.aleph_0 + cardinal.aleph_0 = cardinal.aleph_0 :=\n  mk_denumerable _\n#align aleph_0_add_aleph_0 aleph_0_add_aleph_0\n\n",
 "add_one_le_succ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem add_one_le_succ (c : cardinal.{u}) : c + 1 ≤ succ c :=\n  by\n  refine' (le_cinfₛ_iff'' (exists_gt c)).2 fun b hlt => _\n  rcases b, c with ⟨⟨β⟩, ⟨γ⟩⟩\n  cases' le_of_lt hlt with f\n  have : ¬surjective f := fun hn => (not_le_of_lt hlt) (mk_le_of_surjective hn)\n  simp only [surjective, not_forall] at this\n  rcases this with ⟨b, hb⟩\n  calc\n    cardinal.mk γ + 1 = cardinal.mk (option γ) := mk_option.symm\n    _ ≤ cardinal.mk β := (f.option_elim b hb).cardinal_le\n    \n#align add_one_le_succ add_one_le_succ\n\n",
 "add_lt_aleph_0_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\ntheorem add_lt_aleph_0_iff {a b : cardinal} : a + b < cardinal.aleph_0 ↔ a < cardinal.aleph_0 ∧ b < cardinal.aleph_0 :=\n  ⟨fun h => ⟨(self_le_add_right _ _).trans_lt h, (self_le_add_left _ _).trans_lt h⟩, fun ⟨h1, h2⟩ =>\n    add_lt_aleph_0 h1 h2⟩\n#align add_lt_aleph_0_iff add_lt_aleph_0_iff\n\n",
 "add_lt_aleph_0":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\ntheorem add_lt_aleph_0 {a b : cardinal} (ha : a < cardinal.aleph_0) (hb : b < cardinal.aleph_0) :\n    a + b < cardinal.aleph_0 :=\n  match a, b, lt_aleph_0.1 ha, lt_aleph_0.1 hb with\n  | _, _, ⟨m, rfl⟩, ⟨n, rfl⟩ => by rw [← Nat.cast_add] <;> apply nat_lt_aleph_0\n#align add_lt_aleph_0 add_lt_aleph_0\n\n",
 "add_le_aleph_0":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n@[simp]\ntheorem add_le_aleph_0 {c₁ c₂ : cardinal} :\n    c₁ + c₂ ≤ cardinal.aleph_0 ↔ c₁ ≤ cardinal.aleph_0 ∧ c₂ ≤ cardinal.aleph_0 :=\n  ⟨fun h => ⟨le_self_add.trans h, le_add_self.trans h⟩, fun h => aleph_0_add_aleph_0 ▸ add_le_add h.1 h.2⟩\n#align add_le_aleph_0 add_le_aleph_0\n\n",
 "add_le_add'":
 "private theorem add_le_add' : ∀ {a b c d : cardinal}, a ≤ b → c ≤ d → a + c ≤ b + d := by\n  rintro ⟨α⟩ ⟨β⟩ ⟨γ⟩ ⟨δ⟩ ⟨e₁⟩ ⟨e₂⟩ <;> exact ⟨e₁.sum_map e₂⟩\n#align add_le_add' add_le_add'\n\n",
 "add_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem add_def (α β : Type u) : cardinal.mk α + cardinal.mk β = cardinal.mk (Sum α β) :=\n  rfl\n#align add_def add_def\n\n"}