{"zero_lt_bit1":
 "@[simp]\ntheorem zero_lt_bit1 (a : cardinal) : 0 < bit1 a :=\n  zero_lt_one.trans_le (self_le_add_left _ _)\n#align zero_lt_bit1 zero_lt_bit1\n\n",
 "zero_lt_bit0":
 "#print zero_lt_bit0 /-\n@[simp]\ntheorem zero_lt_bit0 (a : cardinal) : 0 < bit0 a ↔ 0 < a :=\n  by\n  rw [← not_iff_not]\n  simp [bit0]\n#align zero_lt_bit0 zero_lt_bit0\n-/\n\n",
 "type_cardinal":
 "@[simp]\ntheorem type_cardinal : @type cardinal (· < ·) _ = ordinal.univ.{u, u + 1} := by\n  rw [ordinal.univ_id] <;> exact quotient.sound ⟨aleph_idx.rel_iso⟩\n#align type_cardinal type_cardinal\n\n",
 "succ_aleph_0":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\ntheorem succ_aleph_0 : succ (cardinal.aleph_0) = aleph 1 := by rw [← aleph_zero, ← aleph_succ, ordinal.succ_zero]\n#align succ_aleph_0 succ_aleph_0\n\n",
 "rel_iso_coe":
 "@[simp]\ntheorem aleph'.rel_iso_coe : (aleph'.rel_iso : ordinal → cardinal) = aleph' :=\n  rfl\n#align aleph'.rel_iso_coe aleph'.rel_iso_coe\n\n",
 "prod_eq_two_power":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem prod_eq_two_power {ι : Type u} [Infinite ι] {c : ι → cardinal.{v}} (h₁ : ∀ i, 2 ≤ c i)\n    (h₂ : ∀ i, lift.{u} (c i) ≤ lift.{v} (cardinal.mk ι)) : prod c = 2 ^ lift.{v} (cardinal.mk ι) :=\n  by\n  rw [← lift_id' (Prod c), lift_prod, ← lift_two_power]\n  apply le_antisymm\n  · refine' (prod_le_prod _ _ h₂).trans_eq _\n    rw [prod_const, lift_lift, ← lift_power, power_self_eq (aleph_0_le_mk ι), lift_umax.{u, v}]\n  · rw [← prod_const', lift_prod]\n    refine' prod_le_prod _ _ fun i => _\n    rw [lift_two, ← lift_two.{u, v}, lift_le]\n    exact h₁ i\n#align prod_eq_two_power prod_eq_two_power\n\n",
 "principal_add_ord":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\ntheorem principal_add_ord {c : cardinal} (hc : cardinal.aleph_0 ≤ c) : ordinal.principal (· + ·) c.ord :=\n  fun a b ha hb => by\n  rw [lt_ord, ordinal.card_add] at *\n  exact add_lt_of_lt hc ha hb\n#align principal_add_ord principal_add_ord\n\n",
 "principal_add_aleph":
 "theorem principal_add_aleph (o : ordinal) : ordinal.principal (· + ·) (aleph o).ord :=\n  principal_add_ord <| aleph_0_le_aleph o\n#align principal_add_aleph principal_add_aleph\n\n",
 "powerlt_aleph_0_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^< » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\ntheorem powerlt_aleph_0_le (c : cardinal) : «expr ^< » c (cardinal.aleph_0) ≤ max c (cardinal.aleph_0) :=\n  by\n  cases le_or_lt (cardinal.aleph_0) c\n  · rw [powerlt_aleph_0 h]\n    apply le_max_left\n  rw [powerlt_le]\n  exact fun c' hc' => (power_lt_aleph_0 h hc').le.trans (le_max_right _ _)\n#align powerlt_aleph_0_le powerlt_aleph_0_le\n\n",
 "powerlt_aleph_0":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^< » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\ntheorem powerlt_aleph_0 {c : cardinal} (h : cardinal.aleph_0 ≤ c) : «expr ^< » c (cardinal.aleph_0) = c :=\n  by\n  apply le_antisymm\n  · rw [powerlt_le]\n    intro c'\n    rw [lt_aleph_0]\n    rintro ⟨n, rfl⟩\n    apply power_nat_le h\n  convert le_powerlt c one_lt_aleph_0; rw [power_one]\n#align powerlt_aleph_0 powerlt_aleph_0\n\n",
 "power_self_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\ntheorem power_self_eq {c : cardinal} (h : cardinal.aleph_0 ≤ c) : c ^ c = 2 ^ c :=\n  by\n  apply ((power_le_power_right <| (cantor c).le).trans _).antisymm\n  · convert power_le_power_right ((nat_lt_aleph_0 2).le.trans h)\n    apply nat.cast_two.symm\n  · rw [← power_mul, mul_eq_self h]\n#align power_self_eq power_self_eq\n\n",
 "power_nat_le_max":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\ntheorem power_nat_le_max {c : cardinal.{u}} {n : ℕ} : c ^ (n : cardinal.{u}) ≤ max c (cardinal.aleph_0) :=\n  by\n  cases' le_or_lt (cardinal.aleph_0) c with hc hc\n  · exact le_max_of_le_left (power_nat_le hc)\n  · exact le_max_of_le_right (power_lt_aleph_0 hc (nat_lt_aleph_0 _)).le\n#align power_nat_le_max power_nat_le_max\n\n",
 "power_nat_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\ntheorem power_nat_le {c : cardinal.{u}} {n : ℕ} (h : cardinal.aleph_0 ≤ c) : c ^ n ≤ c :=\n  pow_le h (nat_lt_aleph_0 n)\n#align power_nat_le power_nat_le\n\n",
 "power_nat_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\ntheorem power_nat_eq {c : cardinal.{u}} {n : ℕ} (h1 : cardinal.aleph_0 ≤ c) (h2 : 1 ≤ n) : c ^ n = c :=\n  pow_eq h1 (by exact_mod_cast h2) (nat_lt_aleph_0 n)\n#align power_nat_eq power_nat_eq\n\n",
 "power_eq_two_power":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\ntheorem power_eq_two_power {c₁ c₂ : cardinal} (h₁ : cardinal.aleph_0 ≤ c₁) (h₂ : 2 ≤ c₂) (h₂' : c₂ ≤ c₁) :\n    c₂ ^ c₁ = 2 ^ c₁ :=\n  le_antisymm (power_self_eq h₁ ▸ power_le_power_right h₂') (power_le_power_right h₂)\n#align power_eq_two_power power_eq_two_power\n\n",
 "pow_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\ntheorem pow_le {κ μ : cardinal.{u}} (H1 : cardinal.aleph_0 ≤ κ) (H2 : μ < cardinal.aleph_0) : κ ^ μ ≤ κ :=\n  let ⟨n, H3⟩ := lt_aleph_0.1 H2\n  H3.symm ▸\n    Quotient.inductionOn κ\n      (fun α H1 =>\n        nat.rec_on n\n          (lt_of_lt_of_le\n              (by\n                rw [Nat.cast_zero, power_zero]\n                exact one_lt_aleph_0)\n              H1).le\n          fun n ih =>\n          trans_rel_left _\n            (by\n              rw [Nat.cast_succ, power_add, power_one]\n              exact mul_le_mul_right' ih _)\n            (mul_eq_self H1))\n      H1\n#align pow_le pow_le\n\n",
 "pow_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n#print pow_eq /-\ntheorem pow_eq {κ μ : cardinal.{u}} (H1 : cardinal.aleph_0 ≤ κ) (H2 : 1 ≤ μ) (H3 : μ < cardinal.aleph_0) : κ ^ μ = κ :=\n  (pow_le H1 H3).antisymm <| self_le_power κ H2\n#align pow_eq pow_eq\n-/\n\n",
 "ord_is_limit":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n/-\nCopyright (c) 2017 Johannes Hölzl. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johannes Hölzl, Mario Carneiro, Floris van Doorn\n-/\ntheorem ord_is_limit {c} (co : cardinal.aleph_0 ≤ c) : (ord c).is_limit :=\n  by\n  refine' ⟨fun h => aleph_0_ne_zero _, fun a => lt_imp_lt_of_le_imp_le fun h => _⟩\n  · rw [← ordinal.le_zero, ord_le] at h\n    simpa only [card_zero, nonpos_iff_eq_zero] using co.trans h\n  · rw [ord_le] at h⊢\n    rwa [← @add_one_of_aleph_0_le (card a), ← card_succ]\n    rw [← ord_le, ← le_succ_of_is_limit, ord_le]\n    · exact co.trans h\n    · rw [ord_aleph_0]\n      exact omega_is_limit\n#align ord_is_limit ord_is_limit\n\n",
 "ord_card_unbounded'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.omega -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.omega -/\n/-- Infinite ordinals that are cardinals are unbounded. -/\ntheorem ord_card_unbounded' : unbounded (· < ·) { b : ordinal | b.card.ord = b ∧ ordinal.omega ≤ b } :=\n  (unbounded_lt_inter_le (ordinal.omega)).2 ord_card_unbounded\n#align ord_card_unbounded' ord_card_unbounded'\n\n",
 "ord_card_unbounded":
 "/-- Ordinals that are cardinals are unbounded. -/\ntheorem ord_card_unbounded : unbounded (· < ·) { b : ordinal | b.card.ord = b } :=\n  unbounded_lt_iff.2 fun a =>\n    ⟨_,\n      ⟨by\n        dsimp\n        rw [card_ord], (lt_ord_succ_card a).le⟩⟩\n#align ord_card_unbounded ord_card_unbounded\n\n",
 "ord_aleph_is_limit":
 "theorem ord_aleph_is_limit (o : ordinal) : is_limit (aleph o).ord :=\n  ord_is_limit <| aleph_0_le_aleph _\n#align ord_aleph_is_limit ord_aleph_is_limit\n\n",
 "ord_aleph_eq_enum_card":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.omega -/\n/-- `ord ∘ aleph` enumerates the infinite ordinals that are cardinals. -/\ntheorem ord_aleph_eq_enum_card : ord ∘ aleph = enum_ord { b : ordinal | b.card.ord = b ∧ ordinal.omega ≤ b } :=\n  by\n  rw [← eq_enum_ord _ ord_card_unbounded']\n  use aleph_is_normal.strict_mono\n  rw [range_eq_iff]\n  refine' ⟨fun a => ⟨_, _⟩, fun b hb => eq_aleph_of_eq_card_ord hb.1 hb.2⟩\n  · rw [card_ord]\n  · rw [← ord_aleph_0, ord_le_ord]\n    exact aleph_0_le_aleph _\n#align ord_aleph_eq_enum_card ord_aleph_eq_enum_card\n\n",
 "ord_aleph'_eq_enum_card":
 "/-- `ord ∘ aleph'` enumerates the ordinals that are cardinals. -/\ntheorem ord_aleph'_eq_enum_card : ord ∘ aleph' = enum_ord { b : ordinal | b.card.ord = b } :=\n  by\n  rw [← eq_enum_ord _ ord_card_unbounded, range_eq_iff]\n  exact\n    ⟨aleph'_is_normal.strict_mono,\n      ⟨fun a => by\n        dsimp\n        rw [card_ord], fun b hb => eq_aleph'_of_eq_card_ord hb⟩⟩\n#align ord_aleph'_eq_enum_card ord_aleph'_eq_enum_card\n\n",
 "one_lt_two":
 "#print one_lt_two /-\ntheorem one_lt_two : (1 : cardinal) < 2 :=\n  by\n  -- This strategy works generally to prove inequalities between numerals in `cardinality`.\n  norm_cast\n  norm_num\n#align one_lt_two one_lt_two\n-/\n\n",
 "one_lt_bit1":
 "#print one_lt_bit1 /-\n@[simp]\ntheorem one_lt_bit1 (a : cardinal) : 1 < bit1 a ↔ 0 < a := by simp [← bit1_zero]\n#align one_lt_bit1 one_lt_bit1\n-/\n\n",
 "one_lt_bit0":
 "@[simp]\ntheorem one_lt_bit0 {a : cardinal} : 1 < bit0 a ↔ 0 < a := by simp [← bit1_zero]\n#align one_lt_bit0 one_lt_bit0\n\n",
 "one_le_bit1":
 "#print one_le_bit1 /-\n@[simp]\ntheorem one_le_bit1 (a : cardinal) : 1 ≤ bit1 a :=\n  self_le_add_left _ _\n#align one_le_bit1 one_le_bit1\n-/\n\n",
 "one_le_bit0":
 "@[simp]\ntheorem one_le_bit0 (a : cardinal) : 1 ≤ bit0 a ↔ 0 < a :=\n  ⟨fun h => (zero_lt_bit0 a).mp (zero_lt_one.trans_le h), fun h => (one_le_iff_pos.mpr h).trans (self_le_add_left a a)⟩\n#align one_le_bit0 one_le_bit0\n\n",
 "nat_power_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\ntheorem nat_power_eq {c : cardinal.{u}} (h : cardinal.aleph_0 ≤ c) {n : ℕ} (hn : 2 ≤ n) :\n    (n : cardinal.{u}) ^ c = 2 ^ c :=\n  power_eq_two_power h (by assumption_mod_cast) ((nat_lt_aleph_0 n).le.trans h)\n#align nat_power_eq nat_power_eq\n\n",
 "mul_mk_eq_max":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n@[simp]\ntheorem mul_mk_eq_max {α β : Type _} [Infinite α] [Infinite β] :\n    cardinal.mk α * cardinal.mk β = max (cardinal.mk α) (cardinal.mk β) :=\n  mul_eq_max (aleph_0_le_mk α) (aleph_0_le_mk β)\n#align mul_mk_eq_max mul_mk_eq_max\n\n",
 "mul_lt_of_lt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\ntheorem mul_lt_of_lt {a b c : cardinal} (hc : cardinal.aleph_0 ≤ c) (h1 : a < c) (h2 : b < c) : a * b < c :=\n  (mul_le_mul' (le_max_left a b) (le_max_right a b)).trans_lt <|\n    (lt_or_le (max a b) (cardinal.aleph_0)).elim (fun h => (mul_lt_aleph_0 h h).trans_le hc) fun h =>\n      by\n      rw [mul_eq_self h]\n      exact max_lt h1 h2\n#align mul_lt_of_lt mul_lt_of_lt\n\n",
 "mul_le_max_of_aleph_0_le_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\ntheorem mul_le_max_of_aleph_0_le_right {a b : cardinal} (h : cardinal.aleph_0 ≤ b) : a * b ≤ max a b := by\n  simpa only [mul_comm, max_comm] using mul_le_max_of_aleph_0_le_left h\n#align mul_le_max_of_aleph_0_le_right mul_le_max_of_aleph_0_le_right\n\n",
 "mul_le_max_of_aleph_0_le_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\ntheorem mul_le_max_of_aleph_0_le_left {a b : cardinal} (h : cardinal.aleph_0 ≤ a) : a * b ≤ max a b :=\n  by\n  convert mul_le_mul' (le_max_left a b) (le_max_right a b)\n  rw [mul_eq_self]\n  refine' h.trans (le_max_left a b)\n#align mul_le_max_of_aleph_0_le_left mul_le_max_of_aleph_0_le_left\n\n",
 "mul_le_max":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\ntheorem mul_le_max (a b : cardinal) : a * b ≤ max (max a b) (cardinal.aleph_0) :=\n  by\n  rcases eq_or_ne a 0 with (rfl | ha0); · simp\n  rcases eq_or_ne b 0 with (rfl | hb0); · simp\n  cases' le_or_lt (cardinal.aleph_0) a with ha ha\n  · rw [mul_eq_max_of_aleph_0_le_left ha hb0]\n    exact le_max_left _ _\n  · cases' le_or_lt (cardinal.aleph_0) b with hb hb\n    · rw [mul_comm, mul_eq_max_of_aleph_0_le_left hb ha0, max_comm]\n      exact le_max_left _ _\n    · exact le_max_of_le_right (mul_lt_aleph_0 ha hb).le\n#align mul_le_max mul_le_max\n\n",
 "mul_eq_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ↪ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹'o » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n/-- If `α` is an infinite type, then `α × α` and `α` have the same cardinality. -/\ntheorem mul_eq_self {c : cardinal} (h : cardinal.aleph_0 ≤ c) : c * c = c :=\n  by\n  refine' le_antisymm _ (by simpa only [mul_one] using mul_le_mul_left' (one_le_aleph_0.trans h) c)\n  -- the only nontrivial part is `c * c ≤ c`. We prove it inductively.\n  refine' acc.rec_on (cardinal.lt_wf.apply c) (fun c _ => Quotient.inductionOn c fun α IH ol => _) h\n  -- consider the minimal well-order `r` on `α` (a type with cardinality `c`).\n  rcases ord_eq α with ⟨r, wo, e⟩\n  skip\n  letI := linear_order_of_STO r\n  haveI : is_well_order α (· < ·) := wo\n  -- Define an order `s` on `α × α` by writing `(a, b) < (c, d)` if `max a b < max c d`, or\n  -- the max are equal and `a < c`, or the max are equal and `a = c` and `b < d`.\n  let g : α × α → α := fun p => max p.1 p.2\n  let f : «expr ↪ » (α × α) (ordinal × α × α) :=\n    ⟨fun p : α × α => (typein (· < ·) (g p), p), fun p q => congr_arg prod.snd⟩\n  let s := «expr ⁻¹'o » f (prod.lex (· < ·) (prod.lex (· < ·) (· < ·)))\n  -- this is a well order on `α × α`.\n  haveI : is_well_order _ s := (RelEmbedding.preimage _ _).is_well_order\n  /- it suffices to show that this well order is smaller than `r`\n       if it were larger, then `r` would be a strict prefix of `s`. It would be contained in\n      `β × β` for some `β` of cardinality `< c`. By the inductive assumption, this set has the\n      same cardinality as `β` (or it is finite if `β` is finite), so it is `< c`, which is a\n      contradiction. -/\n  suffices type s ≤ type r by exact card_le_card this\n  refine' le_of_forall_lt fun o h => _\n  rcases typein_surj s h with ⟨p, rfl⟩\n  rw [← e, lt_ord]\n  refine' lt_of_le_of_lt (_ : _ ≤ card (succ (typein (· < ·) (g p))) * card (succ (typein (· < ·) (g p)))) _\n  · have : { q | s q p } ⊆ finset.product (insert (g p) { x | x < g p }) (insert (g p) { x | x < g p }) :=\n      by\n      intro q h\n      simp only [s, embedding.coe_fn_mk, Order.Preimage, typein_lt_typein, prod.lex_def, typein_inj] at h\n      exact max_le_iff.1 (le_iff_lt_or_eq.2 <| h.imp_right And.left)\n    suffices H : «expr ≃ » (insert (g p) { x | r x (g p) } : set α) (Sum { x | r x (g p) } PUnit)\n    · exact ⟨(Set.embeddingOfSubset _ _ this).trans ((Equiv.Set.prod _ _).trans (H.prod_congr H)).to_embedding⟩\n    refine' (Equiv.Set.insert _).trans ((equiv.refl _).sum_congr punit_equiv_punit)\n    apply @irrefl _ r\n  cases' lt_or_le (card (succ (typein (· < ·) (g p)))) (cardinal.aleph_0) with qo qo\n  · exact (mul_lt_aleph_0 qo qo).trans_le ol\n  · suffices\n    · exact (IH _ this qo).trans_lt this\n    rw [← lt_ord]\n    apply (ord_is_limit ol).2\n    rw [mk_def, e]\n    apply typein_lt_type\n#align mul_eq_self mul_eq_self\n\n",
 "mul_eq_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\ntheorem mul_eq_right {a b : cardinal} (hb : cardinal.aleph_0 ≤ b) (ha : a ≤ b) (ha' : a ≠ 0) : a * b = b := by\n  rw [mul_comm, mul_eq_left hb ha ha']\n#align mul_eq_right mul_eq_right\n\n",
 "mul_eq_max_of_aleph_0_le_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\ntheorem mul_eq_max_of_aleph_0_le_right {a b : cardinal} (h' : a ≠ 0) (h : cardinal.aleph_0 ≤ b) : a * b = max a b :=\n  by\n  rw [mul_comm, max_comm]\n  exact mul_eq_max_of_aleph_0_le_left h h'\n#align mul_eq_max_of_aleph_0_le_right mul_eq_max_of_aleph_0_le_right\n\n",
 "mul_eq_max_of_aleph_0_le_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\ntheorem mul_eq_max_of_aleph_0_le_left {a b : cardinal} (h : cardinal.aleph_0 ≤ a) (h' : b ≠ 0) : a * b = max a b :=\n  by\n  cases' le_or_lt (cardinal.aleph_0) b with hb hb\n  · exact mul_eq_max h hb\n  refine' (mul_le_max_of_aleph_0_le_left h).antisymm _\n  have : b ≤ a := hb.le.trans h\n  rw [max_eq_left this]\n  convert mul_le_mul_left' (one_le_iff_ne_zero.mpr h') _\n  rw [mul_one]\n#align mul_eq_max_of_aleph_0_le_left mul_eq_max_of_aleph_0_le_left\n\n",
 "mul_eq_max'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\ntheorem mul_eq_max' {a b : cardinal} (h : cardinal.aleph_0 ≤ a * b) : a * b = max a b :=\n  by\n  rcases aleph_0_le_mul_iff.mp h with ⟨ha, hb, ha' | hb'⟩\n  · exact mul_eq_max_of_aleph_0_le_left ha' hb\n  · exact mul_eq_max_of_aleph_0_le_right ha hb'\n#align mul_eq_max' mul_eq_max'\n\n",
 "mul_eq_max":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n/-- If `α` and `β` are infinite types, then the cardinality of `α × β` is the maximum\nof the cardinalities of `α` and `β`. -/\ntheorem mul_eq_max {a b : cardinal} (ha : cardinal.aleph_0 ≤ a) (hb : cardinal.aleph_0 ≤ b) : a * b = max a b :=\n  le_antisymm (mul_eq_self (ha.trans (le_max_left a b)) ▸ mul_le_mul' (le_max_left _ _) (le_max_right _ _)) <|\n    max_le (by simpa only [mul_one] using mul_le_mul_left' (one_le_aleph_0.trans hb) a)\n      (by simpa only [one_mul] using mul_le_mul_right' (one_le_aleph_0.trans ha) b)\n#align mul_eq_max mul_eq_max\n\n",
 "mul_eq_left_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\ntheorem mul_eq_left_iff {a b : cardinal} : a * b = a ↔ max (cardinal.aleph_0) b ≤ a ∧ b ≠ 0 ∨ b = 1 ∨ a = 0 :=\n  by\n  rw [max_le_iff]\n  refine' ⟨fun h => _, _⟩\n  · cases' le_or_lt (cardinal.aleph_0) a with ha ha\n    · have : a ≠ 0 := by\n        rintro rfl\n        exact ha.not_lt aleph_0_pos\n      left\n      use ha\n      · rw [← not_lt]\n        exact fun hb => ne_of_gt (hb.trans_le (le_mul_left this)) h\n      · rintro rfl\n        apply this\n        rw [mul_zero] at h\n        exact h.symm\n    right\n    by_cases h2a : a = 0\n    · exact or.inr h2a\n    have hb : b ≠ 0 := by\n      rintro rfl\n      apply h2a\n      rw [mul_zero] at h\n      exact h.symm\n    left\n    rw [← h, mul_lt_aleph_0_iff, lt_aleph_0, lt_aleph_0] at ha\n    rcases ha with (rfl | rfl | ⟨⟨n, rfl⟩, ⟨m, rfl⟩⟩)\n    contradiction\n    contradiction\n    rw [← ne] at h2a\n    rw [← one_le_iff_ne_zero] at h2a hb\n    norm_cast  at h2a hb h⊢\n    apply le_antisymm _ hb\n    rw [← not_lt]\n    apply fun h2b => ne_of_gt _ h\n    conv_lhs => rw [← mul_one n]\n    rwa [mul_lt_mul_left]\n    apply nat.lt_of_succ_le h2a\n  · rintro (⟨⟨ha, hab⟩, hb⟩ | rfl | rfl)\n    · rw [mul_eq_max_of_aleph_0_le_left ha hb, max_eq_left hab]\n    all_goals simp\n#align mul_eq_left_iff mul_eq_left_iff\n\n",
 "mul_eq_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\ntheorem mul_eq_left {a b : cardinal} (ha : cardinal.aleph_0 ≤ a) (hb : b ≤ a) (hb' : b ≠ 0) : a * b = a := by\n  rw [mul_eq_max_of_aleph_0_le_left ha hb', max_eq_left hb]\n#align mul_eq_left mul_eq_left\n\n",
 "mul_aleph_0_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n@[simp]\ntheorem mul_aleph_0_eq {a : cardinal} (ha : cardinal.aleph_0 ≤ a) : a * cardinal.aleph_0 = a :=\n  (mul_eq_max ha le_rfl).trans (max_eq_left ha)\n#align mul_aleph_0_eq mul_aleph_0_eq\n\n",
 "mk_multiset_of_nonempty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n@[simp]\ntheorem mk_multiset_of_nonempty (α : Type u) [nonempty α] :\n    cardinal.mk (Multiset α) = max (cardinal.mk α) (cardinal.aleph_0) :=\n  multiset.to_finsupp.to_equiv.cardinal_eq.trans (mk_finsupp_nat α)\n#align mk_multiset_of_nonempty mk_multiset_of_nonempty\n\n",
 "mk_multiset_of_is_empty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n@[simp]\ntheorem mk_multiset_of_is_empty (α : Type u) [is_empty α] : cardinal.mk (Multiset α) = 1 :=\n  multiset.to_finsupp.to_equiv.cardinal_eq.trans (by simp)\n#align mk_multiset_of_is_empty mk_multiset_of_is_empty\n\n",
 "mk_multiset_of_infinite":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem mk_multiset_of_infinite (α : Type u) [Infinite α] : cardinal.mk (Multiset α) = cardinal.mk α := by simp\n#align mk_multiset_of_infinite mk_multiset_of_infinite\n\n",
 "mk_multiset_of_countable":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\ntheorem mk_multiset_of_countable (α : Type u) [countable α] [nonempty α] :\n    cardinal.mk (Multiset α) = cardinal.aleph_0 :=\n  multiset.to_finsupp.to_equiv.cardinal_eq.trans (by simp)\n#align mk_multiset_of_countable mk_multiset_of_countable\n\n",
 "mk_mul_aleph_0_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n@[simp]\ntheorem mk_mul_aleph_0_eq {α : Type _} [Infinite α] : cardinal.mk α * cardinal.aleph_0 = cardinal.mk α :=\n  mul_aleph_0_eq (aleph_0_le_mk α)\n#align mk_mul_aleph_0_eq mk_mul_aleph_0_eq\n\n",
 "mk_list_le_max":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem mk_list_le_max (α : Type u) : cardinal.mk (list α) ≤ max (cardinal.aleph_0) (cardinal.mk α) :=\n  by\n  cases finite_or_infinite α\n  · exact mk_le_aleph_0.trans (le_max_left _ _)\n  · rw [mk_list_eq_mk]\n    apply le_max_right\n#align mk_list_le_max mk_list_le_max\n\n",
 "mk_list_eq_mk":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n@[simp]\ntheorem mk_list_eq_mk (α : Type u) [Infinite α] : cardinal.mk (list α) = cardinal.mk α :=\n  have H1 : cardinal.aleph_0 ≤ cardinal.mk α := aleph_0_le_mk α\n  eq.symm <|\n    le_antisymm ⟨⟨fun x => [x], fun x y H => (list.cons.inj H).1⟩⟩ <|\n      calc\n        cardinal.mk (list α) = sum fun n : ℕ => cardinal.mk α ^ (n : cardinal.{u}) := mk_list_eq_sum_pow α\n        _ ≤ sum fun n : ℕ => cardinal.mk α := sum_le_sum _ _ fun n => pow_le H1 <| nat_lt_aleph_0 n\n        _ = cardinal.mk α := by simp [H1]\n        \n#align mk_list_eq_mk mk_list_eq_mk\n\n",
 "mk_list_eq_max_mk_aleph_0":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\ntheorem mk_list_eq_max_mk_aleph_0 (α : Type u) [nonempty α] :\n    cardinal.mk (list α) = max (cardinal.mk α) (cardinal.aleph_0) :=\n  by\n  cases finite_or_infinite α\n  · rw [mk_list_eq_aleph_0, eq_comm, max_eq_right]\n    exact mk_le_aleph_0\n  · rw [mk_list_eq_mk, eq_comm, max_eq_left]\n    exact aleph_0_le_mk α\n#align mk_list_eq_max_mk_aleph_0 mk_list_eq_max_mk_aleph_0\n\n",
 "mk_list_eq_aleph_0":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\ntheorem mk_list_eq_aleph_0 (α : Type u) [countable α] [nonempty α] : cardinal.mk (list α) = cardinal.aleph_0 :=\n  mk_le_aleph_0.antisymm (aleph_0_le_mk _)\n#align mk_list_eq_aleph_0 mk_list_eq_aleph_0\n\n",
 "mk_finsupp_of_infinite'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem mk_finsupp_of_infinite' (α β : Type u) [nonempty α] [Zero β] [Infinite β] :\n    cardinal.mk («expr →₀ » α β) = max (cardinal.mk α) (cardinal.mk β) := by simp\n#align mk_finsupp_of_infinite' mk_finsupp_of_infinite'\n\n",
 "mk_finsupp_of_infinite":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem mk_finsupp_of_infinite (α β : Type u) [Infinite α] [Zero β] [nontrivial β] :\n    cardinal.mk («expr →₀ » α β) = max (cardinal.mk α) (cardinal.mk β) := by simp\n#align mk_finsupp_of_infinite mk_finsupp_of_infinite\n\n",
 "mk_finsupp_nat":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\ntheorem mk_finsupp_nat (α : Type u) [nonempty α] :\n    cardinal.mk («expr →₀ » α ℕ) = max (cardinal.mk α) (cardinal.aleph_0) := by simp\n#align mk_finsupp_nat mk_finsupp_nat\n\n",
 "mk_finsupp_lift_of_infinite'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n@[simp]\ntheorem mk_finsupp_lift_of_infinite' (α : Type u) (β : Type v) [nonempty α] [Zero β] [Infinite β] :\n    cardinal.mk («expr →₀ » α β) = max (lift.{v} (cardinal.mk α)) (lift.{u} (cardinal.mk β)) :=\n  by\n  cases fintype_or_infinite α\n  · rw [mk_finsupp_lift_of_fintype]\n    have : cardinal.aleph_0 ≤ (cardinal.mk β).lift := aleph_0_le_lift.2 (aleph_0_le_mk β)\n    rw [max_eq_right (le_trans _ this), power_nat_eq this]\n    exacts[fintype.card_pos, lift_le_aleph_0.2 (lt_aleph_0_of_finite _).le]\n  · apply mk_finsupp_lift_of_infinite\n#align mk_finsupp_lift_of_infinite' mk_finsupp_lift_of_infinite'\n\n",
 "mk_finsupp_lift_of_infinite":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n@[simp]\ntheorem mk_finsupp_lift_of_infinite (α : Type u) (β : Type v) [Infinite α] [Zero β] [nontrivial β] :\n    cardinal.mk («expr →₀ » α β) = max (lift.{v} (cardinal.mk α)) (lift.{u} (cardinal.mk β)) :=\n  by\n  apply le_antisymm\n  ·\n    calc\n      cardinal.mk («expr →₀ » α β) ≤ cardinal.mk (Finset (α × β)) := mk_le_of_injective (finsupp.graph_injective α β)\n      _ = cardinal.mk (α × β) := mk_finset_of_infinite _\n      _ = max (lift.{v} (cardinal.mk α)) (lift.{u} (cardinal.mk β)) := by\n        rw [mk_prod, mul_eq_max_of_aleph_0_le_left] <;> simp\n      \n  · apply max_le <;> rw [← lift_id (cardinal.mk («expr →₀ » α β)), ← lift_umax]\n    · cases' exists_ne (0 : β) with b hb\n      exact lift_mk_le.{u, max u v, v}.2 ⟨⟨_, finsupp.single_left_injective hb⟩⟩\n    · inhabit α\n      exact lift_mk_le.{v, max u v, u}.2 ⟨⟨_, finsupp.single_injective default⟩⟩\n#align mk_finsupp_lift_of_infinite mk_finsupp_lift_of_infinite\n\n",
 "mk_finset_of_infinite":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n@[simp]\ntheorem mk_finset_of_infinite (α : Type u) [Infinite α] : cardinal.mk (Finset α) = cardinal.mk α :=\n  eq.symm <|\n    le_antisymm (mk_le_of_injective fun x y => Finset.singleton_inj.1) <|\n      calc\n        cardinal.mk (Finset α) ≤ cardinal.mk (list α) := mk_le_of_surjective List.toFinset_surjective\n        _ = cardinal.mk α := mk_list_eq_mk α\n        \n#align mk_finset_of_infinite mk_finset_of_infinite\n\n",
 "mk_compl_of_infinite":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem mk_compl_of_infinite {α : Type _} [Infinite α] (s : set α) (h2 : cardinal.mk s < cardinal.mk α) :\n    cardinal.mk («expr ᶜ» s : set α) = cardinal.mk α :=\n  by\n  refine' eq_of_add_eq_of_aleph_0_le _ h2 (aleph_0_le_mk α)\n  exact mk_sum_compl s\n#align mk_compl_of_infinite mk_compl_of_infinite\n\n",
 "mk_compl_finset_of_infinite":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem mk_compl_finset_of_infinite {α : Type _} [Infinite α] (s : Finset α) :\n    cardinal.mk («expr ᶜ» ↑s : set α) = cardinal.mk α :=\n  by\n  apply mk_compl_of_infinite\n  exact (finset_card_lt_aleph_0 s).trans_le (aleph_0_le_mk α)\n#align mk_compl_finset_of_infinite mk_compl_finset_of_infinite\n\n",
 "mk_compl_eq_mk_compl_infinite":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\ntheorem mk_compl_eq_mk_compl_infinite {α : Type _} [Infinite α] {s t : set α} (hs : cardinal.mk s < cardinal.mk α)\n    (ht : cardinal.mk t < cardinal.mk α) : cardinal.mk («expr ᶜ» s : set α) = cardinal.mk («expr ᶜ» t : set α) := by\n  rw [mk_compl_of_infinite s hs, mk_compl_of_infinite t ht]\n#align mk_compl_eq_mk_compl_infinite mk_compl_eq_mk_compl_infinite\n\n",
 "mk_compl_eq_mk_compl_finite_same":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\ntheorem mk_compl_eq_mk_compl_finite_same {α : Type _} [Finite α] {s t : set α} (h : cardinal.mk s = cardinal.mk t) :\n    cardinal.mk («expr ᶜ» s : set α) = cardinal.mk («expr ᶜ» t : set α) :=\n  mk_compl_eq_mk_compl_finite rfl h\n#align mk_compl_eq_mk_compl_finite_same mk_compl_eq_mk_compl_finite_same\n\n",
 "mk_compl_eq_mk_compl_finite_lift":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\ntheorem mk_compl_eq_mk_compl_finite_lift {α : Type u} {β : Type v} [Finite α] {s : set α} {t : set β}\n    (h1 : lift.{max v w} (cardinal.mk α) = lift.{max u w} (cardinal.mk β))\n    (h2 : lift.{max v w} (cardinal.mk s) = lift.{max u w} (cardinal.mk t)) :\n    lift.{max v w} (cardinal.mk («expr ᶜ» s : set α)) = lift.{max u w} (cardinal.mk («expr ᶜ» t : set β)) :=\n  by\n  cases nonempty_fintype α\n  rcases lift_mk_eq.1 h1 with ⟨e⟩; letI : fintype β := fintype.of_equiv α e\n  replace h1 : fintype.card α = fintype.card β := (fintype.of_equiv_card _).symm\n  classical\n    lift s to Finset α using s.to_finite\n    lift t to Finset β using t.to_finite\n    simp only [Finset.coe_sort_coe, mk_coe_finset, lift_nat_cast, Nat.cast_inj] at h2\n    simp only [← finset.coe_compl, Finset.coe_sort_coe, mk_coe_finset, finset.card_compl, lift_nat_cast, Nat.cast_inj,\n      h1, h2]\n#align mk_compl_eq_mk_compl_finite_lift mk_compl_eq_mk_compl_finite_lift\n\n",
 "mk_compl_eq_mk_compl_finite":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\ntheorem mk_compl_eq_mk_compl_finite {α β : Type u} [Finite α] {s : set α} {t : set β}\n    (h1 : cardinal.mk α = cardinal.mk β) (h : cardinal.mk s = cardinal.mk t) :\n    cardinal.mk («expr ᶜ» s : set α) = cardinal.mk («expr ᶜ» t : set β) :=\n  by\n  rw [← lift_inj]\n  apply mk_compl_eq_mk_compl_finite_lift <;> rwa [lift_inj]\n#align mk_compl_eq_mk_compl_finite mk_compl_eq_mk_compl_finite\n\n",
 "mk_cardinal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n@[simp]\ntheorem mk_cardinal : cardinal.mk cardinal = univ.{u, u + 1} := by\n  simpa only [card_type, card_univ] using congr_arg card type_cardinal\n#align mk_cardinal mk_cardinal\n\n",
 "mk_bounded_subset_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\ntheorem mk_bounded_subset_le {α : Type u} (s : set α) (c : cardinal.{u}) :\n    cardinal.mk { t : set α // t ⊆ s ∧ cardinal.mk t ≤ c } ≤ max (cardinal.mk s) (cardinal.aleph_0) ^ c :=\n  by\n  refine' le_trans _ (mk_bounded_set_le s c)\n  refine' ⟨embedding.cod_restrict _ _ _⟩\n  use fun t => «expr ⁻¹' » coe t.1\n  · rintro ⟨t, ht1, ht2⟩ ⟨t', h1t', h2t'⟩ h\n    apply subtype.eq\n    dsimp only at h⊢\n    refine' (preimage_eq_preimage' _ _).1 h <;> rw [Subtype.range_coe] <;> assumption\n  rintro ⟨t, h1t, h2t⟩; exact (mk_preimage_of_injective _ _ subtype.val_injective).trans h2t\n#align mk_bounded_subset_le mk_bounded_subset_le\n\n",
 "mk_bounded_set_le_of_infinite":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem mk_bounded_set_le_of_infinite (α : Type u) [Infinite α] (c : cardinal) :\n    cardinal.mk { t : set α // cardinal.mk t ≤ c } ≤ cardinal.mk α ^ c :=\n  by\n  refine' le_trans _ (by rw [← add_one_eq (aleph_0_le_mk α)])\n  induction' c using cardinal.induction_on with β\n  fapply mk_le_of_surjective\n  · intro f\n    use «expr ⁻¹' » sum.inl (range f)\n    refine' le_trans (mk_preimage_of_injective _ _ fun x y => sum.inl.inj) _\n    apply mk_range_le\n  rintro ⟨s, ⟨g⟩⟩\n  use fun y => if h : ∃ x : s, g x = y then sum.inl (Classical.choose h).val else sum.inr ⟨⟩\n  apply subtype.eq; ext\n  constructor\n  · rintro ⟨y, h⟩\n    dsimp only at h\n    by_cases h' : ∃ z : s, g z = y\n    · rw [dif_pos h'] at h\n      cases sum.inl.inj h\n      exact (Classical.choose h').2\n    · rw [dif_neg h'] at h\n      cases h\n  · intro h\n    have : ∃ z : s, g z = g ⟨x, h⟩ := ⟨⟨x, h⟩, rfl⟩\n    use g ⟨x, h⟩\n    dsimp only\n    rw [dif_pos this]\n    congr\n    suffices : Classical.choose this = ⟨x, h⟩\n    exact congr_arg subtype.val this\n    apply g.2\n    exact Classical.choose_spec this\n#align mk_bounded_set_le_of_infinite mk_bounded_set_le_of_infinite\n\n",
 "mk_bounded_set_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\ntheorem mk_bounded_set_le (α : Type u) (c : cardinal) :\n    cardinal.mk { t : set α // cardinal.mk t ≤ c } ≤ max (cardinal.mk α) (cardinal.aleph_0) ^ c :=\n  by\n  trans cardinal.mk { t : set (Sum (ULift.{u} ℕ) α) // cardinal.mk t ≤ c }\n  · refine' ⟨embedding.subtype_map _ _⟩\n    apply embedding.image\n    use sum.inr\n    apply sum.inr.inj\n    intro s hs\n    exact mk_image_le.trans hs\n  apply (mk_bounded_set_le_of_infinite (Sum (ULift.{u} ℕ) α) c).trans\n  rw [max_comm, ← add_eq_max] <;> rfl\n#align mk_bounded_set_le mk_bounded_set_le\n\n",
 "mk_add_one_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n@[simp]\ntheorem mk_add_one_eq {α : Type _} [Infinite α] : cardinal.mk α + 1 = cardinal.mk α :=\n  add_one_eq (aleph_0_le_mk α)\n#align mk_add_one_eq mk_add_one_eq\n\n",
 "max_aleph_eq":
 "@[simp]\ntheorem max_aleph_eq (o₁ o₂ : ordinal) : max (aleph o₁) (aleph o₂) = aleph (max o₁ o₂) :=\n  by\n  cases' le_total (aleph o₁) (aleph o₂) with h h\n  · rw [max_eq_right h, max_eq_right (aleph_le.1 h)]\n  · rw [max_eq_left h, max_eq_left (aleph_le.1 h)]\n#align max_aleph_eq max_aleph_eq\n\n",
 "le_mul_right":
 "#print le_mul_right /-\ntheorem le_mul_right {a b : cardinal} (h : b ≠ 0) : a ≤ a * b :=\n  by\n  rw [mul_comm]\n  exact le_mul_left h\n#align le_mul_right le_mul_right\n-/\n\n",
 "le_mul_left":
 "#print le_mul_left /-\ntheorem le_mul_left {a b : cardinal} (h : b ≠ 0) : a ≤ b * a :=\n  by\n  convert mul_le_mul_right' (one_le_iff_ne_zero.mpr h) _\n  rw [one_mul]\n#align le_mul_left le_mul_left\n-/\n\n",
 "initial_seg_coe":
 "@[simp]\ntheorem aleph_idx.initial_seg_coe : (aleph_idx.initial_seg : cardinal → ordinal) = aleph_idx :=\n  rfl\n#align aleph_idx.initial_seg_coe aleph_idx.initial_seg_coe\n\n",
 "init":
 "theorem aleph_idx.init {a b} : b < aleph_idx a → ∃ c, aleph_idx c = b :=\n  aleph_idx.initial_seg.init _ _\n#align aleph_idx.init aleph_idx.init\n\n",
 "extend_function_of_lt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ↪ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\ntheorem extend_function_of_lt {α β : Type _} {s : set α} (f : «expr ↪ » s β) (hs : cardinal.mk s < cardinal.mk α)\n    (h : nonempty («expr ≃ » α β)) : ∃ g : «expr ≃ » α β, ∀ x : s, g x = f x :=\n  by\n  cases fintype_or_infinite α\n  · exact extend_function_finite f h\n  · apply extend_function f\n    cases' id h with g\n    haveI := infinite.of_injective _ g.injective\n    rw [← lift_mk_eq'] at h⊢\n    rwa [mk_compl_of_infinite s hs, mk_compl_of_infinite]\n    rwa [← lift_lt, mk_range_eq_of_injective f.injective, ← h, lift_lt]\n#align extend_function_of_lt extend_function_of_lt\n\n",
 "extend_function_finite":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ↪ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\ntheorem extend_function_finite {α β : Type _} [Finite α] {s : set α} (f : «expr ↪ » s β)\n    (h : nonempty («expr ≃ » α β)) : ∃ g : «expr ≃ » α β, ∀ x : s, g x = f x :=\n  by\n  apply extend_function f\n  cases' id h with g\n  rw [← lift_mk_eq] at h\n  rw [← lift_mk_eq, mk_compl_eq_mk_compl_finite_lift h]\n  rw [mk_range_eq_lift]; exact f.2\n#align extend_function_finite extend_function_finite\n\n",
 "extend_function":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ↪ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\ntheorem extend_function {α β : Type _} {s : set α} (f : «expr ↪ » s β)\n    (h : nonempty («expr ≃ » («expr ᶜ» s : set α) («expr ᶜ» (range f) : set β))) :\n    ∃ g : «expr ≃ » α β, ∀ x : s, g x = f x := by\n  intros ; have := h; cases' this with g\n  let h : «expr ≃ » α β :=\n    (set.sum_compl (s : set α)).symm.trans ((sum_congr (Equiv.ofInjective f f.2) g).trans (set.sum_compl (range f)))\n  refine' ⟨h, _⟩; rintro ⟨x, hx⟩; simp [set.sum_compl_symm_apply_of_mem, hx]\n#align extend_function extend_function\n\n",
 "exists_aleph":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.omega -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\ntheorem exists_aleph {c : cardinal} : cardinal.aleph_0 ≤ c ↔ ∃ o, c = aleph o :=\n  ⟨fun h =>\n    ⟨aleph_idx c - ordinal.omega,\n      by\n      rw [aleph, ordinal.add_sub_cancel_of_le, aleph'_aleph_idx]\n      rwa [← aleph_0_le_aleph', aleph'_aleph_idx]⟩,\n    fun ⟨o, e⟩ => e.symm ▸ aleph_0_le_aleph _⟩\n#align exists_aleph exists_aleph\n\n",
 "eq_of_add_eq_of_aleph_0_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\ntheorem eq_of_add_eq_of_aleph_0_le {a b c : cardinal} (h : a + b = c) (ha : a < c) (hc : cardinal.aleph_0 ≤ c) :\n    b = c := by\n  apply le_antisymm\n  · rw [← h]\n    apply self_le_add_left\n  rw [← not_lt]; intro hb\n  have : a + b < c := add_lt_of_lt hc ha hb\n  simpa [h, lt_irrefl] using this\n#align eq_of_add_eq_of_aleph_0_le eq_of_add_eq_of_aleph_0_le\n\n",
 "eq_of_add_eq_add_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\nprotected theorem eq_of_add_eq_add_right {a b c : cardinal} (h : a + b = c + b) (hb : b < cardinal.aleph_0) : a = c :=\n  by\n  rw [add_comm a b, add_comm c b] at h\n  exact cardinal.eq_of_add_eq_add_left h hb\n#align eq_of_add_eq_add_right eq_of_add_eq_add_right\n\n",
 "eq_of_add_eq_add_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\nprotected theorem eq_of_add_eq_add_left {a b c : cardinal} (h : a + b = a + c) (ha : a < cardinal.aleph_0) : b = c :=\n  by\n  cases' le_or_lt (cardinal.aleph_0) b with hb hb\n  · have : a < b := ha.trans_le hb\n    rw [add_eq_right hb this.le, eq_comm] at h\n    rw [eq_of_add_eq_of_aleph_0_le h this hb]\n  · have hc : c < cardinal.aleph_0 := by\n      rw [← not_le]\n      intro hc\n      apply lt_irrefl (cardinal.aleph_0)\n      apply (hc.trans (self_le_add_left _ a)).trans_lt\n      rw [← h]\n      apply add_lt_aleph_0 ha hb\n    rw [lt_aleph_0] at *\n    rcases ha with ⟨n, rfl⟩\n    rcases hb with ⟨m, rfl⟩\n    rcases hc with ⟨k, rfl⟩\n    norm_cast  at h⊢\n    apply add_left_cancel h\n#align eq_of_add_eq_add_left eq_of_add_eq_add_left\n\n",
 "eq_aleph_of_eq_card_ord":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.omega -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.omega -/\ntheorem eq_aleph_of_eq_card_ord {o : ordinal} (ho : o.card.ord = o) (ho' : ordinal.omega ≤ o) :\n    ∃ a, (aleph a).ord = o := by\n  cases' eq_aleph'_of_eq_card_ord ho with a ha\n  use a - ordinal.omega\n  unfold aleph\n  rwa [ordinal.add_sub_cancel_of_le]\n  rwa [← aleph_0_le_aleph', ← ord_le_ord, ha, ord_aleph_0]\n#align eq_aleph_of_eq_card_ord eq_aleph_of_eq_card_ord\n\n",
 "eq_aleph'_of_eq_card_ord":
 "theorem eq_aleph'_of_eq_card_ord {o : ordinal} (ho : o.card.ord = o) : ∃ a, (aleph' a).ord = o :=\n  ⟨cardinal.aleph_idx.rel_iso o.card, by simpa using ho⟩\n#align eq_aleph'_of_eq_card_ord eq_aleph'_of_eq_card_ord\n\n",
 "countable_iff_lt_aleph_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem countable_iff_lt_aleph_one {α : Type _} (s : set α) : s.countable ↔ cardinal.mk s < aleph 1 := by\n  rw [← succ_aleph_0, lt_succ_iff, le_aleph_0_iff_set_countable]\n#align countable_iff_lt_aleph_one countable_iff_lt_aleph_one\n\n",
 "bit1_ne_zero":
 "@[simp]\ntheorem bit1_ne_zero (a : cardinal) : ¬bit1 a = 0 := by simp [bit1]\n#align bit1_ne_zero bit1_ne_zero\n\n",
 "bit1_lt_bit1":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n#print bit1_lt_bit1 /-\n@[simp]\ntheorem bit1_lt_bit1 {a b : cardinal} : bit1 a < bit1 b ↔ a < b :=\n  by\n  cases' le_or_lt (cardinal.aleph_0) a with ha ha <;> cases' le_or_lt (cardinal.aleph_0) b with hb hb\n  · rw [bit1_eq_self_iff.2 ha, bit1_eq_self_iff.2 hb]\n  · rw [bit1_eq_self_iff.2 ha]\n    refine' iff_of_false (fun h => _) (hb.le.trans ha).not_lt\n    have A : bit1 b < cardinal.aleph_0 := by simpa using hb\n    exact lt_irrefl _ ((A.trans_le ha).trans h)\n  · rw [bit1_eq_self_iff.2 hb]\n    exact iff_of_true ((bit1_lt_aleph_0.2 ha).trans_le hb) (ha.trans_le hb)\n  · rcases lt_aleph_0.1 ha with ⟨m, rfl⟩\n    rcases lt_aleph_0.1 hb with ⟨n, rfl⟩\n    norm_cast\n    exact bit1_lt_bit1\n#align bit1_lt_bit1 bit1_lt_bit1\n-/\n\n",
 "bit1_lt_bit0":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n@[simp]\ntheorem bit1_lt_bit0 {a b : cardinal} : bit1 a < bit0 b ↔ a < b :=\n  by\n  cases' le_or_lt (cardinal.aleph_0) a with ha ha <;> cases' le_or_lt (cardinal.aleph_0) b with hb hb\n  · rw [bit1_eq_self_iff.2 ha, bit0_eq_self hb]\n  · rw [bit1_eq_self_iff.2 ha]\n    refine' iff_of_false (fun h => _) (hb.le.trans ha).not_lt\n    have A : bit0 b < cardinal.aleph_0 := by simpa using hb\n    exact lt_irrefl _ ((A.trans_le ha).trans h)\n  · rw [bit0_eq_self hb]\n    exact iff_of_true ((bit1_lt_aleph_0.2 ha).trans_le hb) (ha.trans_le hb)\n  · rcases lt_aleph_0.1 ha with ⟨m, rfl⟩\n    rcases lt_aleph_0.1 hb with ⟨n, rfl⟩\n    norm_cast\n    exact Nat.bit1_lt_bit0_iff\n#align bit1_lt_bit0 bit1_lt_bit0\n\n",
 "bit1_lt_aleph_0":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n@[simp]\ntheorem bit1_lt_aleph_0 {c : cardinal} : bit1 c < cardinal.aleph_0 ↔ c < cardinal.aleph_0 := by\n  simp [bit1, bit0, add_lt_aleph_0_iff, one_lt_aleph_0]\n#align bit1_lt_aleph_0 bit1_lt_aleph_0\n\n",
 "bit1_le_bit1":
 "#print bit1_le_bit1 /-\n@[simp]\ntheorem bit1_le_bit1 {a b : cardinal} : bit1 a ≤ bit1 b ↔ a ≤ b :=\n  ⟨fun h => bit0_le_bit1.1 ((self_le_add_right (bit0 a) 1).trans h), fun h =>\n    (add_le_add_right (add_le_add_left h a) 1).trans (add_le_add_right (add_le_add_right h b) 1)⟩\n#align bit1_le_bit1 bit1_le_bit1\n-/\n\n",
 "bit1_le_bit0":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n@[simp]\ntheorem bit1_le_bit0 {a b : cardinal} : bit1 a ≤ bit0 b ↔ a < b ∨ a ≤ b ∧ cardinal.aleph_0 ≤ a :=\n  by\n  cases' le_or_lt (cardinal.aleph_0) a with ha ha <;> cases' le_or_lt (cardinal.aleph_0) b with hb hb\n  · simp only [bit1_eq_self_iff.mpr ha, bit0_eq_self hb, ha, and_true_iff]\n    refine' ⟨fun h => or.inr h, fun h => _⟩\n    cases h\n    · exact le_of_lt h\n    · exact h\n  · rw [bit1_eq_self_iff.2 ha]\n    refine' iff_of_false (fun h => _) fun h => _\n    · have A : bit0 b < cardinal.aleph_0 := by simpa using hb\n      exact lt_irrefl _ ((A.trans_le ha).trans_le h)\n    · exact not_le_of_lt (hb.trans_le ha) (h.elim le_of_lt And.left)\n  · rw [bit0_eq_self hb]\n    exact iff_of_true ((bit1_lt_aleph_0.2 ha).le.trans hb) (or.inl <| ha.trans_le hb)\n  · rcases lt_aleph_0.1 ha with ⟨m, rfl⟩\n    rcases lt_aleph_0.1 hb with ⟨n, rfl⟩\n    norm_cast\n    simp [not_le.mpr ha]\n#align bit1_le_bit0 bit1_le_bit0\n\n",
 "bit1_eq_self_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n@[simp]\ntheorem bit1_eq_self_iff {c : cardinal} : bit1 c = c ↔ cardinal.aleph_0 ≤ c :=\n  by\n  by_cases h : cardinal.aleph_0 ≤ c\n  · simp only [bit1, bit0_eq_self h, h, eq_self_iff_true, add_one_of_aleph_0_le]\n  · refine' iff_of_false (ne_of_gt _) h\n    rcases lt_aleph_0.1 (not_le.1 h) with ⟨n, rfl⟩\n    norm_cast\n    dsimp [bit1, bit0]\n    linarith\n#align bit1_eq_self_iff bit1_eq_self_iff\n\n",
 "bit0_ne_zero":
 "#print bit0_ne_zero /-\ntheorem bit0_ne_zero (a : cardinal) : ¬bit0 a = 0 ↔ ¬a = 0 := by simp [bit0]\n#align bit0_ne_zero bit0_ne_zero\n-/\n\n",
 "bit0_lt_bit1":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n@[simp]\ntheorem bit0_lt_bit1 {a b : cardinal} : bit0 a < bit1 b ↔ a < b ∨ a ≤ b ∧ a < cardinal.aleph_0 :=\n  by\n  cases' le_or_lt (cardinal.aleph_0) a with ha ha <;> cases' le_or_lt (cardinal.aleph_0) b with hb hb\n  · simp [bit0_eq_self ha, bit1_eq_self_iff.2 hb, not_lt.mpr ha]\n  · rw [bit0_eq_self ha]\n    refine' iff_of_false (fun h => _) fun h => _\n    · have A : bit1 b < cardinal.aleph_0 := by simpa using hb\n      exact lt_irrefl _ ((A.trans_le ha).trans h)\n    · exact (hb.trans_le ha).not_le (h.elim le_of_lt And.left)\n  · rw [bit1_eq_self_iff.2 hb]\n    exact iff_of_true ((bit0_lt_aleph_0.2 ha).trans_le hb) (or.inl <| ha.trans_le hb)\n  · rcases lt_aleph_0.1 ha with ⟨m, rfl⟩\n    rcases lt_aleph_0.1 hb with ⟨n, rfl⟩\n    norm_cast\n    simp only [ha, and_true_iff, Nat.bit0_lt_bit1_iff, or_iff_right_of_imp le_of_lt]\n#align bit0_lt_bit1 bit0_lt_bit1\n\n",
 "bit0_lt_bit0":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n#print bit0_lt_bit0 /-\n@[simp]\ntheorem bit0_lt_bit0 {a b : cardinal} : bit0 a < bit0 b ↔ a < b :=\n  by\n  cases' le_or_lt (cardinal.aleph_0) a with ha ha <;> cases' le_or_lt (cardinal.aleph_0) b with hb hb\n  · rw [bit0_eq_self ha, bit0_eq_self hb]\n  · rw [bit0_eq_self ha]\n    refine' iff_of_false (fun h => _) (hb.le.trans ha).not_lt\n    have A : bit0 b < cardinal.aleph_0 := by simpa using hb\n    exact lt_irrefl _ ((A.trans_le ha).trans h)\n  · rw [bit0_eq_self hb]\n    exact iff_of_true ((bit0_lt_aleph_0.2 ha).trans_le hb) (ha.trans_le hb)\n  · rcases lt_aleph_0.1 ha with ⟨m, rfl⟩\n    rcases lt_aleph_0.1 hb with ⟨n, rfl⟩\n    norm_cast\n    exact bit0_lt_bit0\n#align bit0_lt_bit0 bit0_lt_bit0\n-/\n\n",
 "bit0_lt_aleph_0":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n@[simp]\ntheorem bit0_lt_aleph_0 {c : cardinal} : bit0 c < cardinal.aleph_0 ↔ c < cardinal.aleph_0 := by\n  simp [bit0, add_lt_aleph_0_iff]\n#align bit0_lt_aleph_0 bit0_lt_aleph_0\n\n",
 "bit0_le_bit1":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n@[simp]\ntheorem bit0_le_bit1 {a b : cardinal} : bit0 a ≤ bit1 b ↔ a ≤ b :=\n  by\n  cases' le_or_lt (cardinal.aleph_0) a with ha ha <;> cases' le_or_lt (cardinal.aleph_0) b with hb hb\n  · rw [bit0_eq_self ha, bit1_eq_self_iff.2 hb]\n  · rw [bit0_eq_self ha]\n    refine' iff_of_false (fun h => _) (hb.trans_le ha).not_le\n    have A : bit1 b < cardinal.aleph_0 := by simpa using hb\n    exact lt_irrefl _ ((A.trans_le ha).trans_le h)\n  · rw [bit1_eq_self_iff.2 hb]\n    exact iff_of_true ((bit0_lt_aleph_0.2 ha).le.trans hb) (ha.le.trans hb)\n  · rcases lt_aleph_0.1 ha with ⟨m, rfl⟩\n    rcases lt_aleph_0.1 hb with ⟨n, rfl⟩\n    norm_cast\n    exact Nat.bit0_le_bit1_iff\n#align bit0_le_bit1 bit0_le_bit1\n\n",
 "bit0_le_bit0":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n#print bit0_le_bit0 /-\n@[simp]\ntheorem bit0_le_bit0 {a b : cardinal} : bit0 a ≤ bit0 b ↔ a ≤ b :=\n  by\n  cases' le_or_lt (cardinal.aleph_0) a with ha ha <;> cases' le_or_lt (cardinal.aleph_0) b with hb hb\n  · rw [bit0_eq_self ha, bit0_eq_self hb]\n  · rw [bit0_eq_self ha]\n    refine' iff_of_false (fun h => _) (hb.trans_le ha).not_le\n    have A : bit0 b < cardinal.aleph_0 := by simpa using hb\n    exact lt_irrefl _ ((A.trans_le ha).trans_le h)\n  · rw [bit0_eq_self hb]\n    exact iff_of_true ((bit0_lt_aleph_0.2 ha).le.trans hb) (ha.le.trans hb)\n  · rcases lt_aleph_0.1 ha with ⟨m, rfl⟩\n    rcases lt_aleph_0.1 hb with ⟨n, rfl⟩\n    norm_cast\n    exact bit0_le_bit0\n#align bit0_le_bit0 bit0_le_bit0\n-/\n\n",
 "bit0_eq_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\ntheorem bit0_eq_self {c : cardinal} (h : cardinal.aleph_0 ≤ c) : bit0 c = c :=\n  add_eq_self h\n#align bit0_eq_self bit0_eq_self\n\n",
 "beth_zero":
 "@[simp]\ntheorem beth_zero : beth 0 = aleph_0 :=\n  limit_rec_on_zero _ _ _\n#align beth_zero beth_zero\n\n",
 "beth_succ":
 "@[simp]\ntheorem beth_succ (o : ordinal) : beth (succ o) = 2 ^ beth o :=\n  limit_rec_on_succ _ _ _ _\n#align beth_succ beth_succ\n\n",
 "beth_strict_mono":
 "theorem beth_strict_mono : strict_mono beth := by\n  intro a b\n  induction' b using ordinal.induction with b IH generalizing a\n  intro h\n  rcases zero_or_succ_or_limit b with (rfl | ⟨c, rfl⟩ | hb)\n  · exact (ordinal.not_lt_zero a h).elim\n  · rw [lt_succ_iff] at h\n    rw [beth_succ]\n    apply lt_of_le_of_lt _ (cantor _)\n    rcases eq_or_lt_of_le h with (rfl | h)\n    · rfl\n    exact (IH c (lt_succ c) h).le\n  · apply (cantor _).trans_le\n    rw [beth_limit hb, ← beth_succ]\n    exact le_csupᵢ (bdd_above_of_small _) (⟨_, hb.succ_lt h⟩ : Iio b)\n#align beth_strict_mono beth_strict_mono\n\n",
 "beth_pos":
 "theorem beth_pos (o : ordinal) : 0 < beth o :=\n  aleph_0_pos.trans_le <| aleph_0_le_beth o\n#align beth_pos beth_pos\n\n",
 "beth_normal":
 "theorem beth_normal : is_normal.{u} fun o => (beth o).ord :=\n  (is_normal_iff_strict_mono_limit _).2\n    ⟨ord_strict_mono.comp beth_strict_mono, fun o ho a ha =>\n      by\n      rw [beth_limit ho, ord_le]\n      exact csupᵢ_le' fun b => ord_le.1 (ha _ b.2)⟩\n#align beth_normal beth_normal\n\n",
 "beth_ne_zero":
 "theorem beth_ne_zero (o : ordinal) : beth o ≠ 0 :=\n  (beth_pos o).ne'\n#align beth_ne_zero beth_ne_zero\n\n",
 "beth_mono":
 "theorem beth_mono : monotone beth :=\n  beth_strict_mono.monotone\n#align beth_mono beth_mono\n\n",
 "beth_lt":
 "@[simp]\ntheorem beth_lt {o₁ o₂ : ordinal} : beth o₁ < beth o₂ ↔ o₁ < o₂ :=\n  beth_strict_mono.lt_iff_lt\n#align beth_lt beth_lt\n\n",
 "beth_limit":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\ntheorem beth_limit {o : ordinal} :\n    is_limit o →\n      beth o =\n        «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (beth a) :=\n  limit_rec_on_limit _ _ _ _\n#align beth_limit beth_limit\n\n",
 "beth_le":
 "@[simp]\ntheorem beth_le {o₁ o₂ : ordinal} : beth o₁ ≤ beth o₂ ↔ o₁ ≤ o₂ :=\n  beth_strict_mono.le_iff_le\n#align beth_le beth_le\n\n",
 "aleph_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n@[simp]\ntheorem aleph_zero : aleph 0 = cardinal.aleph_0 := by rw [aleph, add_zero, aleph'_omega]\n#align aleph_zero aleph_zero\n\n",
 "aleph_to_part_enat":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem aleph_to_part_enat (o : ordinal) : (aleph o).to_part_enat = «expr⊤» :=\n  to_part_enat_apply_of_aleph_0_le <| aleph_0_le_aleph o\n#align aleph_to_part_enat aleph_to_part_enat\n\n",
 "aleph_to_nat":
 "@[simp]\ntheorem aleph_to_nat (o : ordinal) : (aleph o).to_nat = 0 :=\n  to_nat_apply_of_aleph_0_le <| aleph_0_le_aleph o\n#align aleph_to_nat aleph_to_nat\n\n",
 "aleph_succ":
 "@[simp]\ntheorem aleph_succ {o : ordinal} : aleph (succ o) = succ (aleph o) := by rw [aleph, add_succ, aleph'_succ, aleph]\n#align aleph_succ aleph_succ\n\n",
 "aleph_pos":
 "theorem aleph_pos (o : ordinal) : 0 < aleph o :=\n  aleph_0_pos.trans_le (aleph_0_le_aleph o)\n#align aleph_pos aleph_pos\n\n",
 "aleph_mul_aleph_0":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n@[simp]\ntheorem aleph_mul_aleph_0 (o : ordinal) : aleph o * cardinal.aleph_0 = aleph o :=\n  mul_aleph_0_eq (aleph_0_le_aleph o)\n#align aleph_mul_aleph_0 aleph_mul_aleph_0\n\n",
 "aleph_mul_aleph":
 "@[simp]\ntheorem aleph_mul_aleph (o₁ o₂ : ordinal) : aleph o₁ * aleph o₂ = aleph (max o₁ o₂) := by\n  rw [cardinal.mul_eq_max (aleph_0_le_aleph o₁) (aleph_0_le_aleph o₂), max_aleph_eq]\n#align aleph_mul_aleph aleph_mul_aleph\n\n",
 "aleph_lt":
 "@[simp]\ntheorem aleph_lt {o₁ o₂ : ordinal} : aleph o₁ < aleph o₂ ↔ o₁ < o₂ :=\n  aleph'_lt.trans (add_lt_add_iff_left _)\n#align aleph_lt aleph_lt\n\n",
 "aleph_limit":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.omega -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\ntheorem aleph_limit {o : ordinal} (ho : is_limit o) :\n    aleph o =\n      «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (aleph a) :=\n  by\n  apply le_antisymm _ (csupᵢ_le' _)\n  · rw [aleph, aleph'_limit (ho.add _)]\n    refine' csupᵢ_mono' (bdd_above_of_small _) _\n    rintro ⟨i, hi⟩\n    cases lt_or_le i (ordinal.omega)\n    · rcases lt_omega.1 h with ⟨n, rfl⟩\n      use ⟨0, ho.pos⟩\n      simpa using (nat_lt_aleph_0 n).le\n    · exact ⟨⟨_, (sub_lt_of_le h).2 hi⟩, aleph'_le.2 (le_add_sub _ _)⟩\n  · exact fun i => aleph_le.2 (le_of_lt i.2)\n#align aleph_limit aleph_limit\n\n",
 "aleph_le_beth":
 "theorem aleph_le_beth (o : ordinal) : aleph o ≤ beth o :=\n  by\n  apply limit_rec_on o\n  · simp\n  · intro o h\n    rw [aleph_succ, beth_succ, succ_le_iff]\n    exact (cantor _).trans_le (power_le_power_left two_ne_zero h)\n  · intro o ho IH\n    rw [aleph_limit ho, beth_limit ho]\n    exact csupᵢ_mono (bdd_above_of_small _) fun x => IH x.1 x.2\n#align aleph_le_beth aleph_le_beth\n\n",
 "aleph_le":
 "@[simp]\ntheorem aleph_le {o₁ o₂ : ordinal} : aleph o₁ ≤ aleph o₂ ↔ o₁ ≤ o₂ :=\n  le_iff_le_iff_lt_iff_lt.2 aleph_lt\n#align aleph_le aleph_le\n\n",
 "aleph_is_normal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.omega -/\ntheorem aleph_is_normal : is_normal (ord ∘ aleph) :=\n  aleph'_is_normal.trans <| add_is_normal (ordinal.omega)\n#align aleph_is_normal aleph_is_normal\n\n",
 "aleph_idx_lt":
 "@[simp]\ntheorem aleph_idx_lt {a b} : aleph_idx a < aleph_idx b ↔ a < b :=\n  aleph_idx.initial_seg.to_rel_embedding.map_rel_iff\n#align aleph_idx_lt aleph_idx_lt\n\n",
 "aleph_idx_le":
 "@[simp]\ntheorem aleph_idx_le {a b} : aleph_idx a ≤ aleph_idx b ↔ a ≤ b := by rw [← not_lt, ← not_lt, aleph_idx_lt]\n#align aleph_idx_le aleph_idx_le\n\n",
 "aleph_idx_aleph'":
 "@[simp]\ntheorem aleph_idx_aleph' (o : ordinal) : (aleph' o).aleph_idx = o :=\n  cardinal.aleph_idx.rel_iso.to_equiv.apply_symm_apply o\n#align aleph_idx_aleph' aleph_idx_aleph'\n\n",
 "aleph_add_aleph":
 "@[simp]\ntheorem aleph_add_aleph (o₁ o₂ : ordinal) : aleph o₁ + aleph o₂ = aleph (max o₁ o₂) := by\n  rw [cardinal.add_eq_max (aleph_0_le_aleph o₁), max_aleph_eq]\n#align aleph_add_aleph aleph_add_aleph\n\n",
 "aleph_0_mul_mk_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n@[simp]\ntheorem aleph_0_mul_mk_eq {α : Type _} [Infinite α] : cardinal.aleph_0 * cardinal.mk α = cardinal.mk α :=\n  aleph_0_mul_eq (aleph_0_le_mk α)\n#align aleph_0_mul_mk_eq aleph_0_mul_mk_eq\n\n",
 "aleph_0_mul_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n@[simp]\ntheorem aleph_0_mul_eq {a : cardinal} (ha : cardinal.aleph_0 ≤ a) : cardinal.aleph_0 * a = a :=\n  (mul_eq_max le_rfl ha).trans (max_eq_right ha)\n#align aleph_0_mul_eq aleph_0_mul_eq\n\n",
 "aleph_0_mul_aleph":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n@[simp]\ntheorem aleph_0_mul_aleph (o : ordinal) : cardinal.aleph_0 * aleph o = aleph o :=\n  aleph_0_mul_eq (aleph_0_le_aleph o)\n#align aleph_0_mul_aleph aleph_0_mul_aleph\n\n",
 "aleph_0_lt_aleph_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\ntheorem aleph_0_lt_aleph_one : cardinal.aleph_0 < aleph 1 :=\n  by\n  rw [← succ_aleph_0]\n  apply lt_succ\n#align aleph_0_lt_aleph_one aleph_0_lt_aleph_one\n\n",
 "aleph_0_le_bit1":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n@[simp]\ntheorem aleph_0_le_bit1 {c : cardinal} : cardinal.aleph_0 ≤ bit1 c ↔ cardinal.aleph_0 ≤ c :=\n  by\n  rw [← not_iff_not]\n  simp\n#align aleph_0_le_bit1 aleph_0_le_bit1\n\n",
 "aleph_0_le_bit0":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n@[simp]\ntheorem aleph_0_le_bit0 {c : cardinal} : cardinal.aleph_0 ≤ bit0 c ↔ cardinal.aleph_0 ≤ c :=\n  by\n  rw [← not_iff_not]\n  simp\n#align aleph_0_le_bit0 aleph_0_le_bit0\n\n",
 "aleph_0_le_beth":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\ntheorem aleph_0_le_beth (o : ordinal) : cardinal.aleph_0 ≤ beth o :=\n  (aleph_0_le_aleph o).trans <| aleph_le_beth o\n#align aleph_0_le_beth aleph_0_le_beth\n\n",
 "aleph_0_le_aleph'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.omega -/\ntheorem aleph_0_le_aleph' {o : ordinal} : cardinal.aleph_0 ≤ aleph' o ↔ ordinal.omega ≤ o := by\n  rw [← aleph'_omega, aleph'_le]\n#align aleph_0_le_aleph' aleph_0_le_aleph'\n\n",
 "aleph_0_le_aleph":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\ntheorem aleph_0_le_aleph (o : ordinal) : cardinal.aleph_0 ≤ aleph o :=\n  by\n  rw [aleph, aleph_0_le_aleph']\n  apply ordinal.le_add_right\n#align aleph_0_le_aleph aleph_0_le_aleph\n\n",
 "aleph'_zero":
 "@[simp]\ntheorem aleph'_zero : aleph' 0 = 0 :=\n  by\n  rw [← nonpos_iff_eq_zero, ← aleph'_aleph_idx 0, aleph'_le]\n  apply ordinal.zero_le\n#align aleph'_zero aleph'_zero\n\n",
 "aleph'_succ":
 "@[simp]\ntheorem aleph'_succ {o : ordinal} : aleph' (succ o) = succ (aleph' o) :=\n  by\n  apply (succ_le_of_lt <| aleph'_lt.2 <| lt_succ o).antisymm' (cardinal.aleph_idx_le.1 <| _)\n  rw [aleph_idx_aleph', succ_le_iff, ← aleph'_lt, aleph'_aleph_idx]\n  apply lt_succ\n#align aleph'_succ aleph'_succ\n\n",
 "aleph'_pos":
 "theorem aleph'_pos {o : ordinal} (ho : 0 < o) : 0 < aleph' o := by rwa [← aleph'_zero, aleph'_lt]\n#align aleph'_pos aleph'_pos\n\n",
 "aleph'_omega":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.omega -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n@[simp]\ntheorem aleph'_omega : aleph' (ordinal.omega) = cardinal.aleph_0 :=\n  eq_of_forall_ge_iff fun c =>\n    by\n    simp only [aleph'_le_of_limit omega_is_limit, lt_omega, exists_imp, aleph_0_le]\n    exact forall_swap.trans (forall_congr' fun n => by simp only [forall_eq, aleph'_nat])\n#align aleph'_omega aleph'_omega\n\n",
 "aleph'_nat":
 "@[simp]\ntheorem aleph'_nat : ∀ n : ℕ, aleph' n = n\n  | 0 => aleph'_zero\n  | n + 1 => show aleph' (succ n) = n.succ by rw [aleph'_succ, aleph'_nat, nat_succ]\n#align aleph'_nat aleph'_nat\n\n",
 "aleph'_lt":
 "@[simp]\ntheorem aleph'_lt {o₁ o₂ : ordinal} : aleph' o₁ < aleph' o₂ ↔ o₁ < o₂ :=\n  aleph'.rel_iso.map_rel_iff\n#align aleph'_lt aleph'_lt\n\n",
 "aleph'_limit":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\ntheorem aleph'_limit {o : ordinal} (ho : is_limit o) :\n    aleph' o =\n      «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (aleph' a) :=\n  by\n  refine' le_antisymm _ (csupᵢ_le' fun i => aleph'_le.2 (le_of_lt i.2))\n  rw [aleph'_le_of_limit ho]\n  exact fun a ha => le_csupᵢ (bdd_above_of_small _) (⟨a, ha⟩ : Iio o)\n#align aleph'_limit aleph'_limit\n\n",
 "aleph'_le_of_limit":
 "theorem aleph'_le_of_limit {o : ordinal} (l : o.is_limit) {c} : aleph' o ≤ c ↔ ∀ o' < o, aleph' o' ≤ c :=\n  ⟨fun h o' h' => (aleph'_le.2 <| h'.le).trans h, fun h =>\n    by\n    rw [← aleph'_aleph_idx c, aleph'_le, limit_le l]\n    intro x h'\n    rw [← aleph'_le, aleph'_aleph_idx]\n    exact h _ h'⟩\n#align aleph'_le_of_limit aleph'_le_of_limit\n\n",
 "aleph'_le":
 "@[simp]\ntheorem aleph'_le {o₁ o₂ : ordinal} : aleph' o₁ ≤ aleph' o₂ ↔ o₁ ≤ o₂ :=\n  le_iff_le_iff_lt_iff_lt.2 aleph'_lt\n#align aleph'_le aleph'_le\n\n",
 "aleph'_is_normal":
 "theorem aleph'_is_normal : is_normal (ord ∘ aleph') :=\n  ⟨fun o => ord_lt_ord.2 <| aleph'_lt.2 <| lt_succ o, fun o l a => by simp only [ord_le, aleph'_le_of_limit l]⟩\n#align aleph'_is_normal aleph'_is_normal\n\n",
 "aleph'_aleph_idx":
 "@[simp]\ntheorem aleph'_aleph_idx (c : cardinal) : aleph' c.aleph_idx = c :=\n  cardinal.aleph_idx.rel_iso.to_equiv.symm_apply_apply c\n#align aleph'_aleph_idx aleph'_aleph_idx\n\n",
 "add_right_inj_of_lt_aleph_0":
 "theorem add_right_inj_of_lt_aleph_0 {α β γ : cardinal} (γ₀ : γ < aleph_0) : α + γ = β + γ ↔ α = β :=\n  ⟨fun h => cardinal.eq_of_add_eq_add_right h γ₀, fun h => congr_fun (congr_arg (· + ·) h) γ⟩\n#align add_right_inj_of_lt_aleph_0 add_right_inj_of_lt_aleph_0\n\n",
 "add_one_le_add_one_iff_of_lt_aleph_0":
 "@[simp]\ntheorem add_one_le_add_one_iff_of_lt_aleph_0 {α β : cardinal} : α + 1 ≤ β + 1 ↔ α ≤ β :=\n  add_le_add_iff_of_lt_aleph_0 one_lt_aleph_0\n#align add_one_le_add_one_iff_of_lt_aleph_0 add_one_le_add_one_iff_of_lt_aleph_0\n\n",
 "add_one_inj":
 "@[simp]\ntheorem add_one_inj {α β : cardinal} : α + 1 = β + 1 ↔ α = β :=\n  add_right_inj_of_lt_aleph_0 one_lt_aleph_0\n#align add_one_inj add_one_inj\n\n",
 "add_one_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\ntheorem add_one_eq {a : cardinal} (ha : cardinal.aleph_0 ≤ a) : a + 1 = a :=\n  add_eq_left ha (one_le_aleph_0.trans ha)\n#align add_one_eq add_one_eq\n\n",
 "add_nat_le_add_nat_iff_of_lt_aleph_0":
 "@[simp]\ntheorem add_nat_le_add_nat_iff_of_lt_aleph_0 {α β : cardinal} (n : ℕ) : α + n ≤ β + n ↔ α ≤ β :=\n  add_le_add_iff_of_lt_aleph_0 (nat_lt_aleph_0 n)\n#align add_nat_le_add_nat_iff_of_lt_aleph_0 add_nat_le_add_nat_iff_of_lt_aleph_0\n\n",
 "add_nat_inj":
 "@[simp]\ntheorem add_nat_inj {α β : cardinal} (n : ℕ) : α + n = β + n ↔ α = β :=\n  add_right_inj_of_lt_aleph_0 (nat_lt_aleph_0 _)\n#align add_nat_inj add_nat_inj\n\n",
 "add_nat_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\ntheorem add_nat_eq {a : cardinal} (n : ℕ) (ha : cardinal.aleph_0 ≤ a) : a + n = a :=\n  add_eq_left ha ((nat_lt_aleph_0 _).le.trans ha)\n#align add_nat_eq add_nat_eq\n\n",
 "add_mk_eq_max'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n@[simp]\ntheorem add_mk_eq_max' {α β : Type _} [Infinite β] :\n    cardinal.mk α + cardinal.mk β = max (cardinal.mk α) (cardinal.mk β) :=\n  add_eq_max' (aleph_0_le_mk β)\n#align add_mk_eq_max' add_mk_eq_max'\n\n",
 "add_mk_eq_max":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n@[simp]\ntheorem add_mk_eq_max {α β : Type _} [Infinite α] :\n    cardinal.mk α + cardinal.mk β = max (cardinal.mk α) (cardinal.mk β) :=\n  add_eq_max (aleph_0_le_mk α)\n#align add_mk_eq_max add_mk_eq_max\n\n",
 "add_lt_of_lt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\ntheorem add_lt_of_lt {a b c : cardinal} (hc : cardinal.aleph_0 ≤ c) (h1 : a < c) (h2 : b < c) : a + b < c :=\n  (add_le_add (le_max_left a b) (le_max_right a b)).trans_lt <|\n    (lt_or_le (max a b) (cardinal.aleph_0)).elim (fun h => (add_lt_aleph_0 h h).trans_le hc) fun h => by\n      rw [add_eq_self h] <;> exact max_lt h1 h2\n#align add_lt_of_lt add_lt_of_lt\n\n",
 "add_le_of_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\ntheorem add_le_of_le {a b c : cardinal} (hc : cardinal.aleph_0 ≤ c) (h1 : a ≤ c) (h2 : b ≤ c) : a + b ≤ c :=\n  (add_le_add h1 h2).trans <| le_of_eq <| add_eq_self hc\n#align add_le_of_le add_le_of_le\n\n",
 "add_le_max":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\ntheorem add_le_max (a b : cardinal) : a + b ≤ max (max a b) (cardinal.aleph_0) :=\n  by\n  cases' le_or_lt (cardinal.aleph_0) a with ha ha\n  · rw [add_eq_max ha]\n    exact le_max_left _ _\n  · cases' le_or_lt (cardinal.aleph_0) b with hb hb\n    · rw [add_comm, add_eq_max hb, max_comm]\n      exact le_max_left _ _\n    · exact le_max_of_le_right (add_lt_aleph_0 ha hb).le\n#align add_le_max add_le_max\n\n",
 "add_le_add_iff_of_lt_aleph_0":
 "theorem add_le_add_iff_of_lt_aleph_0 {α β γ : cardinal} (γ₀ : γ < cardinal.aleph_0) : α + γ ≤ β + γ ↔ α ≤ β :=\n  by\n  refine' ⟨fun h => _, fun h => add_le_add_right h γ⟩\n  contrapose h\n  rw [not_le, lt_iff_le_and_ne, ne] at h⊢\n  exact ⟨add_le_add_right h.1 γ, mt (add_right_inj_of_lt_aleph_0 γ₀).1 h.2⟩\n#align add_le_add_iff_of_lt_aleph_0 add_le_add_iff_of_lt_aleph_0\n\n",
 "add_eq_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n/-- If `α` is an infinite type, then `α ⊕ α` and `α` have the same cardinality. -/\ntheorem add_eq_self {c : cardinal} (h : cardinal.aleph_0 ≤ c) : c + c = c :=\n  le_antisymm\n    (by\n      simpa only [Nat.cast_bit0, Nat.cast_one, mul_eq_self h, two_mul] using\n        mul_le_mul_right' ((nat_lt_aleph_0 2).le.trans h) c)\n    (self_le_add_left c c)\n#align add_eq_self add_eq_self\n\n",
 "add_eq_right_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\ntheorem add_eq_right_iff {a b : cardinal} : a + b = b ↔ max (cardinal.aleph_0) a ≤ b ∨ a = 0 := by\n  rw [add_comm, add_eq_left_iff]\n#align add_eq_right_iff add_eq_right_iff\n\n",
 "add_eq_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\ntheorem add_eq_right {a b : cardinal} (hb : cardinal.aleph_0 ≤ b) (ha : a ≤ b) : a + b = b := by\n  rw [add_comm, add_eq_left hb ha]\n#align add_eq_right add_eq_right\n\n",
 "add_eq_max'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\ntheorem add_eq_max' {a b : cardinal} (ha : cardinal.aleph_0 ≤ b) : a + b = max a b := by\n  rw [add_comm, max_comm, add_eq_max ha]\n#align add_eq_max' add_eq_max'\n\n",
 "add_eq_max":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n/-- If `α` is an infinite type, then the cardinality of `α ⊕ β` is the maximum\nof the cardinalities of `α` and `β`. -/\ntheorem add_eq_max {a b : cardinal} (ha : cardinal.aleph_0 ≤ a) : a + b = max a b :=\n  le_antisymm (add_eq_self (ha.trans (le_max_left a b)) ▸ add_le_add (le_max_left _ _) (le_max_right _ _)) <|\n    max_le (self_le_add_right _ _) (self_le_add_left _ _)\n#align add_eq_max add_eq_max\n\n",
 "add_eq_left_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\ntheorem add_eq_left_iff {a b : cardinal} : a + b = a ↔ max (cardinal.aleph_0) b ≤ a ∨ b = 0 :=\n  by\n  rw [max_le_iff]\n  refine' ⟨fun h => _, _⟩\n  · cases' le_or_lt (cardinal.aleph_0) a with ha ha\n    · left\n      use ha\n      rw [← not_lt]\n      apply fun hb => ne_of_gt _ h\n      exact hb.trans_le (self_le_add_left b a)\n    right\n    rw [← h, add_lt_aleph_0_iff, lt_aleph_0, lt_aleph_0] at ha\n    rcases ha with ⟨⟨n, rfl⟩, ⟨m, rfl⟩⟩\n    norm_cast  at h⊢\n    rw [← add_right_inj, h, add_zero]\n  · rintro (⟨h1, h2⟩ | h3)\n    · rw [add_eq_max h1, max_eq_left h2]\n    · rw [h3, add_zero]\n#align add_eq_left_iff add_eq_left_iff\n\n",
 "add_eq_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\ntheorem add_eq_left {a b : cardinal} (ha : cardinal.aleph_0 ≤ a) (hb : b ≤ a) : a + b = a := by\n  rw [add_eq_max ha, max_eq_left hb]\n#align add_eq_left add_eq_left\n\n"}