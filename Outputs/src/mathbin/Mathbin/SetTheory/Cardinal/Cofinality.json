{"zero":
 "protected theorem zero {f : ∀ b < (0 : ordinal), ordinal} : is_fundamental_sequence 0 0 f :=\n  ⟨by rw [cof_zero, ord_zero], fun i j hi => (ordinal.not_lt_zero i hi).elim, blsub_zero f⟩\n#align zero zero\n\n",
 "univ_inaccessible":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n-- Lean's foundations prove the existence of ℵ₀ many inaccessible cardinals\ntheorem univ_inaccessible : is_inaccessible univ.{u, v} :=\n  is_inaccessible.mk (by simpa using lift_lt_univ' (cardinal.aleph_0)) (by simp) fun c h =>\n    by\n    rcases lt_univ'.1 h with ⟨c, rfl⟩\n    rw [← lift_two_power.{u, max (u + 1) v}]\n    apply lift_lt_univ'\n#align univ_inaccessible univ_inaccessible\n\n",
 "unbounded_of_unbounded_sUnion":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/-- If the union of s is unbounded and s is smaller than the cofinality,\n  then s has an unbounded member -/\ntheorem unbounded_of_unbounded_sUnion (r : α → α → Prop) [wo : is_well_order α r] {s : set (set α)}\n    (h₁ : unbounded r <| ⋃₀ s) (h₂ : cardinal.mk s < strict_order.cof r) : ∃ x ∈ s, unbounded r x :=\n  by\n  by_contra' h\n  simp_rw [not_unbounded_iff] at h\n  let f : s → α := fun x : s => wo.wf.sup x (h x.1 x.2)\n  refine' h₂.not_le (le_trans (cinfₛ_le' ⟨range f, fun x => _, rfl⟩) mk_range_le)\n  rcases h₁ x with ⟨y, ⟨c, hc, hy⟩, hxy⟩\n  exact ⟨f ⟨c, hc⟩, mem_range_self _, fun hxz => hxy (trans (wo.wf.lt_sup _ hy) hxz)⟩\n#align unbounded_of_unbounded_sUnion unbounded_of_unbounded_sUnion\n\n",
 "unbounded_of_unbounded_Union":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/-- If the union of s is unbounded and s is smaller than the cofinality,\n  then s has an unbounded member -/\ntheorem unbounded_of_unbounded_Union {α β : Type u} (r : α → α → Prop) [wo : is_well_order α r] (s : β → set α)\n    (h₁ :\n      unbounded r <|\n        «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (s x))\n    (h₂ : cardinal.mk β < strict_order.cof r) : ∃ x : β, unbounded r (s x) :=\n  by\n  rw [← sUnion_range] at h₁\n  rcases unbounded_of_unbounded_sUnion r h₁ (mk_range_le.trans_lt h₂) with ⟨_, ⟨x, rfl⟩, u⟩\n  exact ⟨x, u⟩\n#align unbounded_of_unbounded_Union unbounded_of_unbounded_Union\n\n",
 "two_power_lt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.pow -/\ntheorem is_strong_limit.two_power_lt {x c} (h : is_strong_limit c) : x < c → cardinal.pow 2 x < c :=\n  h.2 x\n#align is_strong_limit.two_power_lt is_strong_limit.two_power_lt\n\n",
 "trans":
 "#print trans /-\ntheorem trans {a o o' : ordinal.{u}} {f : ∀ b < o, ordinal.{u}} (hf : is_fundamental_sequence a o f)\n    {g : ∀ b < o', ordinal.{u}} (hg : is_fundamental_sequence o o' g) :\n    is_fundamental_sequence a o' fun i hi =>\n      f (g i hi)\n        (by\n          rw [← hg.2.2]\n          apply lt_blsub) :=\n  by\n  refine' ⟨_, fun i j _ _ h => hf.2.1 _ _ (hg.2.1 _ _ h), _⟩\n  · rw [hf.cof_eq]\n    exact hg.1.trans (ord_cof_le o)\n  · rw [@blsub_comp.{u, u, u} o _ f (@is_fundamental_sequence.monotone _ _ f hf)]\n    exact hf.2.2\n#align trans trans\n-/\n\n",
 "supr_lt_of_is_regular":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem supr_lt_of_is_regular {ι} {f : ι → cardinal} {c} (hc : is_regular c) (hι : cardinal.mk ι < c) :\n    (∀ i, f i < c) → supᵢ f < c :=\n  supr_lt (by rwa [hc.cof_eq])\n#align supr_lt_of_is_regular supr_lt_of_is_regular\n\n",
 "supr_lt_lift_of_is_regular":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem supr_lt_lift_of_is_regular {ι} {f : ι → cardinal} {c} (hc : is_regular c)\n    (hι : cardinal.lift (cardinal.mk ι) < c) : (∀ i, f i < c) → supᵢ f < c :=\n  supr_lt_lift (by rwa [hc.cof_eq])\n#align supr_lt_lift_of_is_regular supr_lt_lift_of_is_regular\n\n",
 "supr_lt_lift":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem supr_lt_lift {ι} {f : ι → cardinal} {c : cardinal} (hι : cardinal.lift (cardinal.mk ι) < c.ord.cof)\n    (hf : ∀ i, f i < c) : supᵢ f < c :=\n  by\n  rw [← ord_lt_ord, supr_ord (cardinal.bdd_above_range _)]\n  refine' sup_lt_ord_lift hι fun i => _\n  rw [ord_lt_ord]\n  apply hf\n#align supr_lt_lift supr_lt_lift\n\n",
 "supr_lt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem supr_lt {ι} {f : ι → cardinal} {c : cardinal} (hι : cardinal.mk ι < c.ord.cof) : (∀ i, f i < c) → supᵢ f < c :=\n  supr_lt_lift (by rwa [(cardinal.mk ι).lift_id])\n#align supr_lt supr_lt\n\n",
 "sup_lt_ord_of_is_regular":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem sup_lt_ord_of_is_regular {ι} {f : ι → ordinal} {c} (hc : is_regular c) (hι : cardinal.mk ι < c) :\n    (∀ i, f i < c.ord) → ordinal.sup f < c.ord :=\n  sup_lt_ord (by rwa [hc.cof_eq])\n#align sup_lt_ord_of_is_regular sup_lt_ord_of_is_regular\n\n",
 "sup_lt_ord_lift_of_is_regular":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem sup_lt_ord_lift_of_is_regular {ι} {f : ι → ordinal} {c} (hc : is_regular c)\n    (hι : cardinal.lift (cardinal.mk ι) < c) : (∀ i, f i < c.ord) → ordinal.sup f < c.ord :=\n  sup_lt_ord_lift (by rwa [hc.cof_eq])\n#align sup_lt_ord_lift_of_is_regular sup_lt_ord_lift_of_is_regular\n\n",
 "sup_lt_ord_lift":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem sup_lt_ord_lift {ι} {f : ι → ordinal} {c : ordinal} (hι : cardinal.lift (cardinal.mk ι) < c.cof)\n    (hf : ∀ i, f i < c) : sup.{u, v} f < c :=\n  (sup_le_lsub.{u, v} f).trans_lt (lsub_lt_ord_lift hι hf)\n#align sup_lt_ord_lift sup_lt_ord_lift\n\n",
 "sup_lt_ord":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem sup_lt_ord {ι} {f : ι → ordinal} {c : ordinal} (hι : cardinal.mk ι < c.cof) :\n    (∀ i, f i < c) → sup.{u, u} f < c :=\n  sup_lt_ord_lift (by rwa [(cardinal.mk ι).lift_id])\n#align sup_lt_ord sup_lt_ord\n\n",
 "sum_lt_of_is_regular":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem sum_lt_of_is_regular {ι : Type u} {f : ι → cardinal} {c : cardinal} (hc : is_regular c)\n    (hι : cardinal.mk ι < c) : (∀ i, f i < c) → sum f < c :=\n  sum_lt_lift_of_is_regular.{u, u} hc (by rwa [lift_id])\n#align sum_lt_of_is_regular sum_lt_of_is_regular\n\n",
 "sum_lt_lift_of_is_regular":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem sum_lt_lift_of_is_regular {ι : Type u} {f : ι → cardinal} {c : cardinal} (hc : is_regular c)\n    (hι : cardinal.lift.{v, u} (cardinal.mk ι) < c) (hf : ∀ i, f i < c) : sum f < c :=\n  (sum_le_supr_lift _).trans_lt <| mul_lt_of_lt hc.1 hι (supr_lt_lift_of_is_regular hc hι hf)\n#align sum_lt_lift_of_is_regular sum_lt_lift_of_is_regular\n\n",
 "succ_lt":
 "theorem is_limit.succ_lt {x c} (h : is_limit c) : x < c → succ x < c :=\n  h.2 x\n#align is_limit.succ_lt is_limit.succ_lt\n\n",
 "succ":
 "protected theorem succ : is_fundamental_sequence (succ o) 1 fun _ _ => o :=\n  by\n  refine' ⟨_, fun i j hi hj h => _, blsub_const ordinal.one_ne_zero o⟩\n  · rw [cof_succ, ord_one]\n  · rw [lt_one_iff_zero] at hi hj\n    rw [hi, hj] at h\n    exact h.false.elim\n#align succ succ\n\n",
 "strict_mono":
 "protected theorem strict_mono (hf : is_fundamental_sequence a o f) {i j} : ∀ hi hj, i < j → f i hi < f j hj :=\n  hf.2.1\n#align strict_mono strict_mono\n\n",
 "pos":
 "theorem is_regular.pos {c : cardinal} (H : c.is_regular) : 0 < c :=\n  aleph_0_pos.trans_le H.1\n#align is_regular.pos is_regular.pos\n\n",
 "ord_pos":
 "theorem is_regular.ord_pos {c : cardinal} (H : c.is_regular) : 0 < c.ord :=\n  by\n  rw [cardinal.lt_ord]\n  exact H.pos\n#align is_regular.ord_pos is_regular.ord_pos\n\n",
 "ord_cof_le":
 "theorem ord_cof_le (o : ordinal.{u}) : o.cof.ord ≤ o :=\n  (ord_le_ord.2 (cof_le_card o)).trans (ord_card_le o)\n#align ord_cof_le ord_cof_le\n\n",
 "ord_cof_eq":
 "theorem ord_cof_eq (r : α → α → Prop) [is_well_order α r] :\n    ∃ S, unbounded r S ∧ type (Subrel r S) = (cof (type r)).ord :=\n  by\n  let ⟨S, hS, e⟩ := cof_eq r\n  let ⟨s, _, e'⟩ := cardinal.ord_eq S\n  let T : set α := { a | ∃ aS : a ∈ S, ∀ b : S, s b ⟨_, aS⟩ → r b a }\n  skip; suffices\n  · refine' ⟨T, this, le_antisymm _ (cardinal.ord_le.2 <| cof_type_le this)⟩\n    rw [← e, e']\n    refine'\n      (RelEmbedding.ofMonotone\n          (fun a : T =>\n            (⟨a,\n                let ⟨aS, _⟩ := a.2\n                aS⟩ :\n              S))\n          fun a b h => _).ordinal_type_le\n    rcases a with ⟨a, aS, ha⟩\n    rcases b with ⟨b, bS, hb⟩\n    change s ⟨a, _⟩ ⟨b, _⟩\n    refine' ((trichotomous_of s _ _).resolve_left fun hn => _).resolve_left _\n    · exact asymm h (ha _ hn)\n    · intro e\n      injection e with e\n      subst b\n      exact irrefl _ h\n  · intro a\n    have : { b : S | ¬r b a }.nonempty :=\n      let ⟨b, bS, ba⟩ := hS a\n      ⟨⟨b, bS⟩, ba⟩\n    let b := is_well_founded.wf.min _ this\n    have ba : ¬r b a := is_well_founded.wf.min_mem _ this\n    refine' ⟨b, ⟨b.2, fun c => not_imp_not.1 fun h => _⟩, ba⟩\n    rw [show ∀ b : S, (⟨b, b.2⟩ : S) = b by intro b <;> cases b <;> rfl]\n    exact is_well_founded.wf.not_lt_min _ this (is_order_connected.neg_trans h ba)\n#align ord_cof_eq ord_cof_eq\n\n",
 "ord_cof":
 "theorem ord_cof (hf : is_fundamental_sequence a o f) :\n    is_fundamental_sequence a a.cof.ord fun i hi => f i (hi.trans_le (by rw [hf.cof_eq])) :=\n  by\n  have H := hf.cof_eq\n  subst H\n  exact hf\n#align ord_cof ord_cof\n\n",
 "nfp_lt_ord_of_is_regular":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\ntheorem nfp_lt_ord_of_is_regular {f : ordinal → ordinal} {c} (hc : is_regular c) (hc' : c ≠ cardinal.aleph_0)\n    (hf : ∀ i < c.ord, f i < c.ord) {a} : a < c.ord → nfp f a < c.ord :=\n  nfp_lt_ord\n    (by\n      rw [hc.cof_eq]\n      exact lt_of_le_of_ne hc.1 hc'.symm)\n    hf\n#align nfp_lt_ord_of_is_regular nfp_lt_ord_of_is_regular\n\n",
 "nfp_lt_ord":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\ntheorem nfp_lt_ord {f : ordinal → ordinal} {c} (hc : cardinal.aleph_0 < cof c) (hf : ∀ i < c, f i < c) {a} :\n    a < c → nfp f a < c :=\n  nfp_family_lt_ord_lift hc (by simpa using cardinal.one_lt_aleph_0.trans hc) fun _ => hf\n#align nfp_lt_ord nfp_lt_ord\n\n",
 "nfp_family_lt_ord_of_is_regular":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\ntheorem nfp_family_lt_ord_of_is_regular {ι} {f : ι → ordinal → ordinal} {c} (hc : is_regular c) (hι : cardinal.mk ι < c)\n    (hc' : c ≠ cardinal.aleph_0) {a} (hf : ∀ (i), ∀ b < c.ord, f i b < c.ord) :\n    a < c.ord → nfp_family.{u, u} f a < c.ord :=\n  nfp_family_lt_ord_lift_of_is_regular hc (by rwa [lift_id]) hc' hf\n#align nfp_family_lt_ord_of_is_regular nfp_family_lt_ord_of_is_regular\n\n",
 "nfp_family_lt_ord_lift_of_is_regular":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\ntheorem nfp_family_lt_ord_lift_of_is_regular {ι} {f : ι → ordinal → ordinal} {c} (hc : is_regular c)\n    (hι : (cardinal.mk ι).lift < c) (hc' : c ≠ cardinal.aleph_0) (hf : ∀ (i), ∀ b < c.ord, f i b < c.ord) {a}\n    (ha : a < c.ord) : nfp_family.{u, v} f a < c.ord :=\n  by\n  apply nfp_family_lt_ord_lift _ _ hf ha <;> rwa [hc.cof_eq]\n  exact lt_of_le_of_ne hc.1 hc'.symm\n#align nfp_family_lt_ord_lift_of_is_regular nfp_family_lt_ord_lift_of_is_regular\n\n",
 "nfp_family_lt_ord_lift":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem nfp_family_lt_ord_lift {ι} {f : ι → ordinal → ordinal} {c} (hc : cardinal.aleph_0 < cof c)\n    (hc' : (cardinal.mk ι).lift < cof c) (hf : ∀ (i), ∀ b < c, f i b < c) {a} (ha : a < c) :\n    nfp_family.{u, v} f a < c :=\n  by\n  refine' sup_lt_ord_lift ((cardinal.lift_le.2 (mk_list_le_max ι)).trans_lt _) fun l => _\n  · rw [lift_max]\n    apply max_lt _ hc'\n    rwa [cardinal.lift_aleph_0]\n  · induction' l with i l H\n    · exact ha\n    · exact hf _ _ H\n#align nfp_family_lt_ord_lift nfp_family_lt_ord_lift\n\n",
 "nfp_family_lt_ord":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem nfp_family_lt_ord {ι} {f : ι → ordinal → ordinal} {c} (hc : cardinal.aleph_0 < cof c)\n    (hc' : cardinal.mk ι < cof c) (hf : ∀ (i), ∀ b < c, f i b < c) {a} : a < c → nfp_family.{u, u} f a < c :=\n  nfp_family_lt_ord_lift hc (by rwa [(cardinal.mk ι).lift_id]) hf\n#align nfp_family_lt_ord nfp_family_lt_ord\n\n",
 "nfp_bfamily_lt_ord_of_is_regular":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\ntheorem nfp_bfamily_lt_ord_of_is_regular {o : ordinal} {f : ∀ a < o, ordinal → ordinal} {c} (hc : is_regular c)\n    (ho : o.card < c) (hc' : c ≠ cardinal.aleph_0) (hf : ∀ (i hi), ∀ b < c.ord, f i hi b < c.ord) {a} :\n    a < c.ord → nfp_bfamily.{u, u} o f a < c.ord :=\n  nfp_bfamily_lt_ord_lift_of_is_regular hc (by rwa [lift_id]) hc' hf\n#align nfp_bfamily_lt_ord_of_is_regular nfp_bfamily_lt_ord_of_is_regular\n\n",
 "nfp_bfamily_lt_ord_lift_of_is_regular":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\ntheorem nfp_bfamily_lt_ord_lift_of_is_regular {o : ordinal} {f : ∀ a < o, ordinal → ordinal} {c} (hc : is_regular c)\n    (ho : o.card.lift < c) (hc' : c ≠ cardinal.aleph_0) (hf : ∀ (i hi), ∀ b < c.ord, f i hi b < c.ord) {a} :\n    a < c.ord → nfp_bfamily.{u, v} o f a < c.ord :=\n  nfp_family_lt_ord_lift_of_is_regular hc (by rwa [mk_ordinal_out]) hc' fun i => hf _ _\n#align nfp_bfamily_lt_ord_lift_of_is_regular nfp_bfamily_lt_ord_lift_of_is_regular\n\n",
 "nfp_bfamily_lt_ord_lift":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\ntheorem nfp_bfamily_lt_ord_lift {o : ordinal} {f : ∀ a < o, ordinal → ordinal} {c} (hc : cardinal.aleph_0 < cof c)\n    (hc' : o.card.lift < cof c) (hf : ∀ (i hi), ∀ b < c, f i hi b < c) {a} : a < c → nfp_bfamily.{u, v} o f a < c :=\n  nfp_family_lt_ord_lift hc (by rwa [mk_ordinal_out]) fun i => hf _ _\n#align nfp_bfamily_lt_ord_lift nfp_bfamily_lt_ord_lift\n\n",
 "nfp_bfamily_lt_ord":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\ntheorem nfp_bfamily_lt_ord {o : ordinal} {f : ∀ a < o, ordinal → ordinal} {c} (hc : cardinal.aleph_0 < cof c)\n    (hc' : o.card < cof c) (hf : ∀ (i hi), ∀ b < c, f i hi b < c) {a} : a < c → nfp_bfamily.{u, u} o f a < c :=\n  nfp_bfamily_lt_ord_lift hc (by rwa [o.card.lift_id]) hf\n#align nfp_bfamily_lt_ord nfp_bfamily_lt_ord\n\n",
 "ne_zero":
 "theorem is_strong_limit.ne_zero {c} (h : is_strong_limit c) : c ≠ 0 :=\n  h.1\n#align is_strong_limit.ne_zero is_strong_limit.ne_zero\n\n",
 "monotone":
 "protected theorem monotone (hf : is_fundamental_sequence a o f) {i j : ordinal} (hi : i < o) (hj : j < o)\n    (hij : i ≤ j) : f i hi ≤ f j hj :=\n  by\n  rcases lt_or_eq_of_le hij with (hij | rfl)\n  · exact (hf.2.1 hi hj hij).le\n  · rfl\n#align monotone monotone\n\n",
 "mk_subset_mk_lt_cof":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.pow -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem mk_subset_mk_lt_cof {α : Type _} (h : ∀ x < cardinal.mk α, cardinal.pow 2 x < cardinal.mk α) :\n    cardinal.mk { s : set α // cardinal.mk s < cof (cardinal.mk α).ord } = cardinal.mk α :=\n  by\n  rcases eq_or_ne (cardinal.mk α) 0 with (ha | ha)\n  · rw [ha]\n    simp [fun s => (cardinal.zero_le s).not_lt]\n  have h' : is_strong_limit (cardinal.mk α) := ⟨ha, h⟩\n  rcases ord_eq α with ⟨r, wo, hr⟩\n  haveI := wo\n  apply le_antisymm\n  · nth_rw_rhs 1 [← mk_bounded_subset h hr]\n    apply mk_le_mk_of_subset fun s hs => _\n    rw [hr] at hs\n    exact lt_cof_type hs\n  · refine' @mk_le_of_injective α _ (fun x => subtype.mk {x} _) _\n    · rw [mk_singleton]\n      exact one_lt_aleph_0.trans_le (aleph_0_le_cof.2 (ord_is_limit h'.is_limit.aleph_0_le))\n    · intro a b hab\n      simpa only [singleton_eq_singleton_iff] using hab\n#align mk_subset_mk_lt_cof mk_subset_mk_lt_cof\n\n",
 "mk_bounded_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.pow -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem mk_bounded_subset {α : Type _} (h : ∀ x < cardinal.mk α, cardinal.pow 2 x < cardinal.mk α) {r : α → α → Prop}\n    [is_well_order α r] (hr : (cardinal.mk α).ord = type r) :\n    cardinal.mk { s : set α // bounded r s } = cardinal.mk α :=\n  by\n  rcases eq_or_ne (cardinal.mk α) 0 with (ha | ha)\n  · rw [ha]\n    haveI := mk_eq_zero_iff.1 ha\n    rw [mk_eq_zero_iff]\n    constructor\n    rintro ⟨s, hs⟩\n    exact (not_unbounded_iff s).2 hs (unbounded_of_is_empty s)\n  have h' : is_strong_limit (cardinal.mk α) := ⟨ha, h⟩\n  have ha := h'.is_limit.aleph_0_le\n  apply le_antisymm\n  · have :\n      { s : set α | bounded r s } =\n        «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n          (𝒫{ j | r j i }) :=\n      set_of_exists _\n    rw [← coe_set_of, this]\n    convert mk_Union_le_sum_mk.trans ((sum_le_supr _).trans (mul_le_max_of_aleph_0_le_left ha))\n    apply (max_eq_left _).symm\n    apply csupᵢ_le' fun i => _\n    rw [mk_powerset]\n    apply (h'.two_power_lt _).le\n    rw [coe_set_of, card_typein, ← lt_ord, hr]\n    apply typein_lt_type\n  · refine' @mk_le_of_injective α _ (fun x => subtype.mk {x} _) _\n    · apply bounded_singleton\n      rw [← hr]\n      apply ord_is_limit ha\n    · intro a b hab\n      simpa only [singleton_eq_singleton_iff] using hab\n#align mk_bounded_subset mk_bounded_subset\n\n",
 "mk":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.pow -/\ntheorem is_inaccessible.mk {c} (h₁ : cardinal.aleph_0 < c) (h₂ : c ≤ c.ord.cof) (h₃ : ∀ x < c, cardinal.pow 2 x < c) :\n    is_inaccessible c :=\n  ⟨h₁, ⟨h₁.le, h₂⟩, (aleph_0_pos.trans h₁).ne', h₃⟩\n#align is_inaccessible.mk is_inaccessible.mk\n\n",
 "lt_power_cof":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.pow -/\ntheorem lt_power_cof {c : cardinal.{u}} : cardinal.aleph_0 ≤ c → c < cardinal.pow c (cof c.ord) :=\n  Quotient.inductionOn c fun α h => by\n    rcases ord_eq α with ⟨r, wo, re⟩; skip\n    have := ord_is_limit h\n    rw [mk_def, re] at this⊢\n    rcases cof_eq' r this with ⟨S, H, Se⟩\n    have := sum_lt_prod (fun a : S => cardinal.mk { x // r x a }) (fun _ => cardinal.mk α) fun i => _\n    · simp only [cardinal.prod_const, cardinal.lift_id, ← Se, ← mk_sigma, power_def] at this⊢\n      refine' lt_of_le_of_lt _ this\n      refine' ⟨embedding.of_surjective _ _⟩\n      · exact fun x => x.2.1\n      ·\n        exact fun a =>\n          let ⟨b, h, ab⟩ := H a\n          ⟨⟨⟨_, h⟩, _, ab⟩, rfl⟩\n    · have := typein_lt_type r i\n      rwa [← re, lt_ord] at this\n#align lt_power_cof lt_power_cof\n\n",
 "lt_cof_type":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem lt_cof_type [is_well_order α r] {S : set α} : cardinal.mk S < cof (type r) → bounded r S := by\n  simpa using not_imp_not.2 cof_type_le\n#align lt_cof_type lt_cof_type\n\n",
 "lt_cof_power":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.pow -/\ntheorem lt_cof_power {a b : cardinal} (ha : cardinal.aleph_0 ≤ a) (b1 : 1 < b) : a < cof (cardinal.pow b a).ord :=\n  by\n  have b0 : b ≠ 0 := (zero_lt_one.trans b1).ne'\n  apply lt_imp_lt_of_le_imp_le (power_le_power_left <| power_ne_zero a b0)\n  rw [← power_mul, mul_eq_self ha]\n  exact lt_power_cof (ha.trans <| (cantor' _ b1).le)\n#align lt_cof_power lt_cof_power\n\n",
 "lsub_lt_ord_of_is_regular":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem lsub_lt_ord_of_is_regular {ι} {f : ι → ordinal} {c} (hc : is_regular c) (hι : cardinal.mk ι < c) :\n    (∀ i, f i < c.ord) → ordinal.lsub f < c.ord :=\n  lsub_lt_ord (by rwa [hc.cof_eq])\n#align lsub_lt_ord_of_is_regular lsub_lt_ord_of_is_regular\n\n",
 "lsub_lt_ord_lift_of_is_regular":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem lsub_lt_ord_lift_of_is_regular {ι} {f : ι → ordinal} {c} (hc : is_regular c)\n    (hι : cardinal.lift (cardinal.mk ι) < c) : (∀ i, f i < c.ord) → ordinal.lsub f < c.ord :=\n  lsub_lt_ord_lift (by rwa [hc.cof_eq])\n#align lsub_lt_ord_lift_of_is_regular lsub_lt_ord_lift_of_is_regular\n\n",
 "lsub_lt_ord_lift":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem lsub_lt_ord_lift {ι} {f : ι → ordinal} {c : ordinal} (hι : cardinal.lift (cardinal.mk ι) < c.cof)\n    (hf : ∀ i, f i < c) : lsub.{u, v} f < c :=\n  lt_of_le_of_ne (lsub_le hf) fun h => by\n    subst h\n    exact (cof_lsub_le_lift f).not_lt hι\n#align lsub_lt_ord_lift lsub_lt_ord_lift\n\n",
 "lsub_lt_ord":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem lsub_lt_ord {ι} {f : ι → ordinal} {c : ordinal} (hι : cardinal.mk ι < c.cof) :\n    (∀ i, f i < c) → lsub.{u, u} f < c :=\n  lsub_lt_ord_lift (by rwa [(cardinal.mk ι).lift_id])\n#align lsub_lt_ord lsub_lt_ord\n\n",
 "lift_cof":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n@[simp]\ntheorem lift_cof (o) : (cof o).lift = cof o.lift :=\n  by\n  refine' induction_on o _\n  intro α r _\n  apply le_antisymm\n  · refine' le_cof_type.2 fun S H => _\n    have : (cardinal.mk («expr ⁻¹' » ulift.up S)).lift ≤ cardinal.mk S :=\n      by\n      rw [← cardinal.lift_umax, ← cardinal.lift_id' (cardinal.mk S)]\n      exact mk_preimage_of_injective_lift ulift.up _ ULift.up_injective\n    refine' (cardinal.lift_le.2 <| cof_type_le _).trans this\n    exact fun a =>\n      let ⟨⟨b⟩, bs, br⟩ := H ⟨a⟩\n      ⟨b, bs, br⟩\n  · rcases cof_eq r with ⟨S, H, e'⟩\n    have : cardinal.mk («expr ⁻¹' » ulift.down S) ≤ (cardinal.mk S).lift :=\n      ⟨⟨fun ⟨⟨x⟩, h⟩ => ⟨⟨x, h⟩⟩, fun ⟨⟨x⟩, h₁⟩ ⟨⟨y⟩, h₂⟩ e => by simp at e <;> congr <;> injections⟩⟩\n    rw [e'] at this\n    refine' (cof_type_le _).trans this\n    exact fun ⟨a⟩ =>\n      let ⟨b, bs, br⟩ := H a\n      ⟨⟨b⟩, bs, br⟩\n#align lift_cof lift_cof\n\n",
 "le_range_of_union_finset_eq_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/-- If an infinite type `β` can be expressed as a union of finite sets,\nthen the cardinality of the collection of those finite sets\nmust be at least the cardinality of `β`.\n-/\ntheorem le_range_of_union_finset_eq_top {α β : Type _} [Infinite β] (f : α → Finset β)\n    (w :\n      «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (f a : set β) =\n        «expr⊤») :\n    cardinal.mk β ≤ cardinal.mk (range f) :=\n  by\n  have k : _root_.infinite (range f) := by\n    rw [infinite_coe_iff]\n    apply mt (union_finset_finite_of_range_finite f)\n    rw [w]\n    exact infinite_univ\n  by_contra h\n  simp only [not_le] at h\n  let u : ∀ b, ∃ a, b ∈ f a := fun b => by simpa using (w.ge : _) (Set.mem_univ b)\n  let u' : β → range f := fun b => ⟨f (u b).some, by simp⟩\n  have v' : ∀ a, «expr ⁻¹' » u' {⟨f a, by simp⟩} ≤ f a :=\n    by\n    rintro a p m\n    simp at m\n    rw [← m]\n    apply fun b => (u b).some_spec\n  obtain ⟨⟨-, ⟨a, rfl⟩⟩, p⟩ := exists_infinite_fiber u' h k\n  exact (@infinite.of_injective _ _ p (inclusion (v' a)) (inclusion_injective _)).false\n#align le_range_of_union_finset_eq_top le_range_of_union_finset_eq_top\n\n",
 "le_cof_type":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem le_cof_type [is_well_order α r] {c} : c ≤ cof (type r) ↔ ∀ S, unbounded r S → c ≤ cardinal.mk S :=\n  (le_cinfₛ_iff'' (strict_order.cof_nonempty r)).trans\n    ⟨fun H S h => H _ ⟨S, h, rfl⟩, by\n      rintro H d ⟨S, h, rfl⟩\n      exact H _ h⟩\n#align le_cof_type le_cof_type\n\n",
 "le_cof_iff_lsub":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem le_cof_iff_lsub {o : ordinal} {a : cardinal} :\n    a ≤ cof o ↔ ∀ {ι} (f : ι → ordinal), lsub.{u, u} f = o → a ≤ cardinal.mk ι :=\n  by\n  rw [cof_eq_Inf_lsub]\n  exact\n    (le_cinfₛ_iff'' (cof_lsub_def_nonempty o)).trans\n      ⟨fun H ι f hf => H _ ⟨ι, f, hf, rfl⟩, fun H b ⟨ι, f, hf, hb⟩ =>\n        by\n        rw [← hb]\n        exact H _ hf⟩\n#align le_cof_iff_lsub le_cof_iff_lsub\n\n",
 "le_cof_iff_blsub":
 "theorem le_cof_iff_blsub {b : ordinal} {a : cardinal} :\n    a ≤ cof b ↔ ∀ {o} (f : ∀ a < o, ordinal), blsub.{u, u} o f = b → a ≤ o.card :=\n  le_cof_iff_lsub.trans\n    ⟨fun H o f hf => by simpa using H _ hf, fun H ι f hf =>\n      by\n      rcases cardinal.ord_eq ι with ⟨r, hr, hι'⟩\n      rw [← @blsub_eq_lsub' ι r hr] at hf\n      simpa using H _ hf⟩\n#align le_cof_iff_blsub le_cof_iff_blsub\n\n",
 "le_cof":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem le_cof {r : α → α → Prop} [is_refl α r] (c : cardinal) :\n    c ≤ cof r ↔ ∀ {S : set α}, (∀ a, ∃ b ∈ S, r a b) → c ≤ cardinal.mk S :=\n  by\n  rw [cof, le_cinfₛ_iff'' (cof_nonempty r)]\n  use fun H S h => H _ ⟨S, h, rfl⟩\n  rintro H d ⟨S, h, rfl⟩\n  exact H h\n#align le_cof le_cof\n\n",
 "is_strong_limit_beth":
 "theorem is_strong_limit_beth {o : ordinal} (H : ∀ a < o, succ a < o) : is_strong_limit (beth o) :=\n  by\n  rcases eq_or_ne o 0 with (rfl | h)\n  · rw [beth_zero]\n    exact is_strong_limit_aleph_0\n  · refine' ⟨beth_ne_zero o, fun a ha => _⟩\n    rw [beth_limit ⟨h, H⟩] at ha\n    rcases exists_lt_of_lt_csupᵢ' ha with ⟨⟨i, hi⟩, ha⟩\n    have := power_le_power_left two_ne_zero ha.le\n    rw [← beth_succ] at this\n    exact this.trans_lt (beth_lt.2 (H i hi))\n#align is_strong_limit_beth is_strong_limit_beth\n\n",
 "is_strong_limit_aleph_0":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\ntheorem is_strong_limit_aleph_0 : is_strong_limit (cardinal.aleph_0) :=\n  ⟨aleph_0_ne_zero, fun x hx => by\n    rcases lt_aleph_0.1 hx with ⟨n, rfl⟩\n    exact_mod_cast nat_lt_aleph_0 (pow 2 n)⟩\n#align is_strong_limit_aleph_0 is_strong_limit_aleph_0\n\n",
 "is_regular_succ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\ntheorem is_regular_succ {c : cardinal.{u}} (h : cardinal.aleph_0 ≤ c) : is_regular (succ c) :=\n  ⟨h.trans (le_succ c),\n    succ_le_of_lt\n      (by\n        cases' quotient.exists_rep (@succ cardinal _ _ c) with α αe; simp at αe\n        rcases ord_eq α with ⟨r, wo, re⟩; skip\n        have := ord_is_limit (h.trans (le_succ _))\n        rw [← αe, re] at this⊢\n        rcases cof_eq' r this with ⟨S, H, Se⟩\n        rw [← Se]\n        apply lt_imp_lt_of_le_imp_le fun h => mul_le_mul_right' h c\n        rw [mul_eq_self h, ← succ_le_iff, ← αe, ← sum_const']\n        refine' le_trans _ (sum_le_sum (fun x => card (typein r x)) _ fun i => _)\n        · simp only [← card_typein, ← mk_sigma]\n          exact\n            ⟨embedding.of_surjective (fun x => x.2.1) fun a =>\n                let ⟨b, h, ab⟩ := H a\n                ⟨⟨⟨_, h⟩, _, ab⟩, rfl⟩⟩\n        · rw [← lt_succ_iff, ← lt_ord, ← αe, re]\n          apply typein_lt_type)⟩\n#align is_regular_succ is_regular_succ\n\n",
 "is_regular_cof":
 "theorem is_regular_cof {o : ordinal} (h : o.is_limit) : is_regular o.cof :=\n  ⟨aleph_0_le_cof.2 h, (cof_cof o).ge⟩\n#align is_regular_cof is_regular_cof\n\n",
 "is_regular_aleph_succ":
 "theorem is_regular_aleph_succ (o : ordinal) : is_regular (aleph (succ o)) :=\n  by\n  rw [aleph_succ]\n  exact is_regular_succ (aleph_0_le_aleph o)\n#align is_regular_aleph_succ is_regular_aleph_succ\n\n",
 "is_regular_aleph_one":
 "theorem is_regular_aleph_one : is_regular (aleph 1) :=\n  by\n  rw [← succ_aleph_0]\n  exact is_regular_succ le_rfl\n#align is_regular_aleph_one is_regular_aleph_one\n\n",
 "is_regular_aleph_0":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\ntheorem is_regular_aleph_0 : is_regular (cardinal.aleph_0) :=\n  ⟨le_rfl, by simp⟩\n#align is_regular_aleph_0 is_regular_aleph_0\n\n",
 "is_regular_aleph'_succ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.omega -/\ntheorem is_regular_aleph'_succ {o : ordinal} (h : ordinal.omega ≤ o) : is_regular (aleph' (succ o)) :=\n  by\n  rw [aleph'_succ]\n  exact is_regular_succ (aleph_0_le_aleph'.2 h)\n#align is_regular_aleph'_succ is_regular_aleph'_succ\n\n",
 "is_limit_aleph_0":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\ntheorem is_limit_aleph_0 : is_limit (cardinal.aleph_0) :=\n  is_strong_limit_aleph_0.is_limit\n#align is_limit_aleph_0 is_limit_aleph_0\n\n",
 "is_limit":
 "theorem is_strong_limit.is_limit {c} (H : is_strong_limit c) : is_limit c :=\n  ⟨H.1, fun x h => (succ_le_of_lt <| cantor x).trans_lt (H.2 _ h)⟩\n#align is_strong_limit.is_limit is_strong_limit.is_limit\n\n",
 "is_fundamental_sequence":
 "protected theorem is_normal.is_fundamental_sequence {f : ordinal.{u} → ordinal.{u}} (hf : is_normal f) {a o}\n    (ha : is_limit a) {g} (hg : is_fundamental_sequence a o g) :\n    is_fundamental_sequence (f a) o fun b hb => f (g b hb) :=\n  by\n  refine' ⟨_, fun i j _ _ h => hf.strict_mono (hg.2.1 _ _ h), _⟩\n  · rcases exists_lsub_cof (f a) with ⟨ι, f', hf', hι⟩\n    rw [← hg.cof_eq, ord_le_ord, ← hι]\n    suffices (lsub.{u, u} fun i => Inf { b : ordinal | f' i ≤ f b }) = a\n      by\n      rw [← this]\n      apply cof_lsub_le\n    have H : ∀ i, ∃ b < a, f' i ≤ f b := fun i =>\n      by\n      have := lt_lsub.{u, u} f' i\n      rwa [hf', ← is_normal.blsub_eq.{u, u} hf ha, lt_blsub_iff] at this\n    refine' (lsub_le fun i => _).antisymm (le_of_forall_lt fun b hb => _)\n    · rcases H i with ⟨b, hb, hb'⟩\n      exact lt_of_le_of_lt (cinfₛ_le' hb') hb\n    · have := hf.strict_mono hb\n      rw [← hf', lt_lsub_iff] at this\n      cases' this with i hi\n      rcases H i with ⟨b, _, hb⟩\n      exact ((le_cinfₛ_iff'' ⟨b, hb⟩).2 fun c hc => hf.strict_mono.le_iff_le.1 (hi.trans hc)).trans_lt (lt_lsub _ i)\n  · rw [@blsub_comp.{u, u, u} a _ (fun b _ => f b) (fun i j hi hj h => hf.strict_mono.monotone h) g hg.2.2]\n    exact is_normal.blsub_eq.{u, u} hf ha\n#align is_normal.is_fundamental_sequence is_normal.is_fundamental_sequence\n\n",
 "infinite_pigeonhole_set":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem infinite_pigeonhole_set {β α : Type u} {s : set β} (f : s → α) (θ : cardinal) (hθ : θ ≤ cardinal.mk s)\n    (h₁ : cardinal.aleph_0 ≤ θ) (h₂ : cardinal.mk α < θ.ord.cof) :\n    ∃ (a : α)(t : set β)(h : t ⊆ s), θ ≤ cardinal.mk t ∧ ∀ ⦃x⦄ (hx : x ∈ t), f ⟨x, h hx⟩ = a :=\n  by\n  cases' infinite_pigeonhole_card f θ hθ h₁ h₂ with a ha\n  refine' ⟨a, { x | ∃ h, f ⟨x, h⟩ = a }, _, _, _⟩\n  · rintro x ⟨hx, hx'⟩\n    exact hx\n  · refine' ha.trans (ge_of_eq <| quotient.sound ⟨equiv.trans _ (Equiv.subtypeSubtypeEquivSubtypeExists _ _).symm⟩)\n    simp only [coe_eq_subtype, mem_singleton_iff, mem_preimage, mem_set_of_eq]\n  rintro x ⟨hx, hx'⟩; exact hx'\n#align infinite_pigeonhole_set infinite_pigeonhole_set\n\n",
 "infinite_pigeonhole_card_lt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/-- A function whose codomain's cardinality is infinite but strictly smaller than its domain's\nhas a fiber with cardinality strictly great than the codomain.\n-/\ntheorem infinite_pigeonhole_card_lt {β α : Type u} (f : β → α) (w : cardinal.mk α < cardinal.mk β)\n    (w' : cardinal.aleph_0 ≤ cardinal.mk α) : ∃ a : α, cardinal.mk α < cardinal.mk («expr ⁻¹' » f {a}) :=\n  by\n  simp_rw [← succ_le_iff]\n  exact\n    ordinal.infinite_pigeonhole_card f (succ (cardinal.mk α)) (succ_le_of_lt w) (w'.trans (lt_succ _).le)\n      ((lt_succ _).trans_le (is_regular_succ w').2.ge)\n#align infinite_pigeonhole_card_lt infinite_pigeonhole_card_lt\n\n",
 "infinite_pigeonhole_card":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/-- Pigeonhole principle for a cardinality below the cardinality of the domain -/\ntheorem infinite_pigeonhole_card {β α : Type u} (f : β → α) (θ : cardinal) (hθ : θ ≤ cardinal.mk β)\n    (h₁ : cardinal.aleph_0 ≤ θ) (h₂ : cardinal.mk α < θ.ord.cof) : ∃ a : α, θ ≤ cardinal.mk («expr ⁻¹' » f {a}) :=\n  by\n  rcases le_mk_iff_exists_set.1 hθ with ⟨s, rfl⟩\n  cases' infinite_pigeonhole (f ∘ subtype.val : s → α) h₁ h₂ with a ha\n  use a; rw [← ha, @preimage_comp _ _ _ subtype.val f]\n  exact mk_preimage_of_injective _ _ subtype.val_injective\n#align infinite_pigeonhole_card infinite_pigeonhole_card\n\n",
 "infinite_pigeonhole":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/-- The infinite pigeonhole principle -/\ntheorem infinite_pigeonhole {β α : Type u} (f : β → α) (h₁ : cardinal.aleph_0 ≤ cardinal.mk β)\n    (h₂ : cardinal.mk α < (cardinal.mk β).ord.cof) : ∃ a : α, cardinal.mk («expr ⁻¹' » f {a}) = cardinal.mk β :=\n  by\n  have : ∃ a, cardinal.mk β ≤ cardinal.mk («expr ⁻¹' » f {a}) :=\n    by\n    by_contra' h\n    apply mk_univ.not_lt\n    rw [← preimage_univ, ← Union_of_singleton, preimage_Union]\n    exact\n      mk_Union_le_sum_mk.trans_lt\n        ((sum_le_supr _).trans_lt <| mul_lt_of_lt h₁ (h₂.trans_le <| cof_ord_le _) (supr_lt h₂ h))\n  cases' this with x h\n  refine' ⟨x, h.antisymm' _⟩\n  rw [le_mk_iff_exists_set]\n  exact ⟨_, rfl⟩\n#align infinite_pigeonhole infinite_pigeonhole\n\n",
 "id_of_le_cof":
 "theorem id_of_le_cof (h : o ≤ o.cof.ord) : is_fundamental_sequence o o fun a _ => a :=\n  ⟨h, fun _ _ _ _ => id, blsub_id o⟩\n#align id_of_le_cof id_of_le_cof\n\n",
 "exists_lsub_cof":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem exists_lsub_cof (o : ordinal) : ∃ (ι : _)(f : ι → ordinal), lsub.{u, u} f = o ∧ cardinal.mk ι = cof o :=\n  by\n  rw [cof_eq_Inf_lsub]\n  exact cinfₛ_mem (cof_lsub_def_nonempty o)\n#align exists_lsub_cof exists_lsub_cof\n\n",
 "exists_infinite_fiber":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/-- A function whose codomain's cardinality is infinite but strictly smaller than its domain's\nhas an infinite fiber.\n-/\ntheorem exists_infinite_fiber {β α : Type _} (f : β → α) (w : cardinal.mk α < cardinal.mk β) (w' : Infinite α) :\n    ∃ a : α, Infinite («expr ⁻¹' » f {a}) :=\n  by\n  simp_rw [cardinal.infinite_iff] at w'⊢\n  cases' infinite_pigeonhole_card_lt f w w' with a ha\n  exact ⟨a, w'.trans ha.le⟩\n#align exists_infinite_fiber exists_infinite_fiber\n\n",
 "exists_fundamental_sequence":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ↪r » -/\n/-- Every ordinal has a fundamental sequence. -/\ntheorem exists_fundamental_sequence (a : ordinal.{u}) : ∃ f, is_fundamental_sequence a a.cof.ord f :=\n  by\n  rsuffices ⟨o, f, hf⟩ : ∃ o f, is_fundamental_sequence a o f\n  · exact ⟨_, hf.ord_cof⟩\n  rcases exists_lsub_cof a with ⟨ι, f, hf, hι⟩\n  rcases ord_eq ι with ⟨r, wo, hr⟩\n  haveI := wo\n  let r' := Subrel r { i | ∀ j, r j i → f j < f i }\n  let hrr' : «expr ↪r » r' r := Subrel.relEmbedding _ _\n  haveI := hrr'.is_well_order\n  refine'\n    ⟨_, _, hrr'.ordinal_type_le.trans _, fun i j _ h _ => (enum r' j h).prop _ _,\n      le_antisymm (blsub_le fun i hi => lsub_le_iff.1 hf.le _) _⟩\n  · rw [← hι, hr]\n  · change r (hrr'.1 _) (hrr'.1 _)\n    rwa [hrr'.2, @enum_lt_enum _ r']\n  · rw [← hf, lsub_le_iff]\n    intro i\n    rsuffices ⟨i', hi', hfg⟩ : ∃ i' hi', f i ≤ bfamily_of_family' r' (fun i => f i) i' hi'\n    · exact hfg.trans_lt (lt_blsub _ _ _)\n    by_cases h : ∀ j, r j i → f j < f i\n    · refine' ⟨typein r' ⟨i, h⟩, typein_lt_type _ _, _⟩\n      rw [bfamily_of_family'_typein]\n      rfl\n    · push_neg  at h\n      cases' wo.wf.min_mem _ h with hji hij\n      refine' ⟨typein r' ⟨_, fun k hkj => lt_of_lt_of_le _ hij⟩, typein_lt_type _ _, _⟩\n      · by_contra' H\n        exact (wo.wf.not_lt_min _ h ⟨is_trans.trans _ _ _ hkj hji, H⟩) hkj\n      · rwa [bfamily_of_family'_typein]\n#align exists_fundamental_sequence exists_fundamental_sequence\n\n",
 "exists_blsub_cof":
 "theorem exists_blsub_cof (o : ordinal) : ∃ f : ∀ a < (cof o).ord, ordinal, blsub.{u, u} _ f = o :=\n  by\n  rcases exists_lsub_cof o with ⟨ι, f, hf, hι⟩\n  rcases cardinal.ord_eq ι with ⟨r, hr, hι'⟩\n  rw [← @blsub_eq_lsub' ι r hr] at hf\n  rw [← hι, hι']\n  exact ⟨_, hf⟩\n#align exists_blsub_cof exists_blsub_cof\n\n",
 "deriv_lt_ord":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\ntheorem deriv_lt_ord {f : ordinal.{u} → ordinal} {c} (hc : is_regular c) (hc' : c ≠ cardinal.aleph_0)\n    (hf : ∀ i < c.ord, f i < c.ord) {a} : a < c.ord → deriv f a < c.ord :=\n  deriv_family_lt_ord_lift hc (by simpa using cardinal.one_lt_aleph_0.trans (lt_of_le_of_ne hc.1 hc'.symm)) hc' fun _ =>\n    hf\n#align deriv_lt_ord deriv_lt_ord\n\n",
 "deriv_family_lt_ord_lift":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\ntheorem deriv_family_lt_ord_lift {ι} {f : ι → ordinal → ordinal} {c} (hc : is_regular c) (hι : (cardinal.mk ι).lift < c)\n    (hc' : c ≠ cardinal.aleph_0) (hf : ∀ (i), ∀ b < c.ord, f i b < c.ord) {a} :\n    a < c.ord → deriv_family.{u, v} f a < c.ord :=\n  by\n  have hω : cardinal.aleph_0 < c.ord.cof := by\n    rw [hc.cof_eq]\n    exact lt_of_le_of_ne hc.1 hc'.symm\n  apply a.limit_rec_on\n  · rw [deriv_family_zero]\n    exact nfp_family_lt_ord_lift hω (by rwa [hc.cof_eq]) hf\n  · intro b hb hb'\n    rw [deriv_family_succ]\n    exact nfp_family_lt_ord_lift hω (by rwa [hc.cof_eq]) hf ((ord_is_limit hc.1).2 _ (hb ((lt_succ b).trans hb')))\n  · intro b hb H hb'\n    rw [deriv_family_limit f hb]\n    exact\n      bsup_lt_ord_of_is_regular hc (ord_lt_ord.1 ((ord_card_le b).trans_lt hb')) fun o' ho' => H o' ho' (ho'.trans hb')\n#align deriv_family_lt_ord_lift deriv_family_lt_ord_lift\n\n",
 "deriv_family_lt_ord":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\ntheorem deriv_family_lt_ord {ι} {f : ι → ordinal → ordinal} {c} (hc : is_regular c) (hι : cardinal.mk ι < c)\n    (hc' : c ≠ cardinal.aleph_0) (hf : ∀ (i), ∀ b < c.ord, f i b < c.ord) {a} :\n    a < c.ord → deriv_family.{u, u} f a < c.ord :=\n  deriv_family_lt_ord_lift hc (by rwa [lift_id]) hc' hf\n#align deriv_family_lt_ord deriv_family_lt_ord\n\n",
 "deriv_bfamily_lt_ord_lift":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\ntheorem deriv_bfamily_lt_ord_lift {o : ordinal} {f : ∀ a < o, ordinal → ordinal} {c} (hc : is_regular c)\n    (hι : o.card.lift < c) (hc' : c ≠ cardinal.aleph_0) (hf : ∀ (i hi), ∀ b < c.ord, f i hi b < c.ord) {a} :\n    a < c.ord → deriv_bfamily.{u, v} o f a < c.ord :=\n  deriv_family_lt_ord_lift hc (by rwa [mk_ordinal_out]) hc' fun i => hf _ _\n#align deriv_bfamily_lt_ord_lift deriv_bfamily_lt_ord_lift\n\n",
 "deriv_bfamily_lt_ord":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\ntheorem deriv_bfamily_lt_ord {o : ordinal} {f : ∀ a < o, ordinal → ordinal} {c} (hc : is_regular c) (hι : o.card < c)\n    (hc' : c ≠ cardinal.aleph_0) (hf : ∀ (i hi), ∀ b < c.ord, f i hi b < c.ord) {a} :\n    a < c.ord → deriv_bfamily.{u, u} o f a < c.ord :=\n  deriv_bfamily_lt_ord_lift hc (by rwa [lift_id]) hc' hf\n#align deriv_bfamily_lt_ord deriv_bfamily_lt_ord\n\n",
 "cof_zero":
 "@[simp]\ntheorem cof_zero : cof 0 = 0 :=\n  (cof_le_card 0).antisymm (cardinal.zero_le _)\n#align cof_zero cof_zero\n\n",
 "cof_univ":
 "@[simp]\ntheorem cof_univ : cof univ.{u, v} = cardinal.univ :=\n  le_antisymm (cof_le_card _)\n    (by\n      refine' le_of_forall_lt fun c h => _\n      rcases lt_univ'.1 h with ⟨c, rfl⟩\n      rcases@cof_eq ordinal.{u} (· < ·) _ with ⟨S, H, Se⟩\n      rw [univ, ← lift_cof, ← cardinal.lift_lift, cardinal.lift_lt, ← Se]\n      refine' lt_of_not_ge fun h => _\n      cases' cardinal.lift_down h with a e\n      refine' Quotient.inductionOn a (fun α e => _) e\n      cases' quotient.exact e with f\n      have f := equiv.ulift.symm.trans f\n      let g a := (f a).1\n      let o := succ (sup.{u, u} g)\n      rcases H o with ⟨b, h, l⟩\n      refine' l (lt_succ_iff.2 _)\n      rw [← show g (f.symm ⟨b, h⟩) = b by dsimp [g] <;> simp]\n      apply le_sup)\n#align cof_univ cof_univ\n\n",
 "cof_type_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem cof_type_le [is_well_order α r] {S : set α} (h : unbounded r S) : cof (type r) ≤ cardinal.mk S :=\n  le_cof_type.1 le_rfl S h\n#align cof_type_le cof_type_le\n\n",
 "cof_type":
 "theorem cof_type (r : α → α → Prop) [is_well_order α r] : (type r).cof = strict_order.cof r :=\n  rfl\n#align cof_type cof_type\n\n",
 "cof_sup_le_lift":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem cof_sup_le_lift {ι} {f : ι → ordinal} (H : ∀ i, f i < sup f) : cof (sup f) ≤ (cardinal.mk ι).lift :=\n  by\n  rw [← sup_eq_lsub_iff_lt_sup] at H\n  rw [H]\n  exact cof_lsub_le_lift f\n#align cof_sup_le_lift cof_sup_le_lift\n\n",
 "cof_sup_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem cof_sup_le {ι} {f : ι → ordinal} (H : ∀ i, f i < sup.{u, u} f) : cof (sup.{u, u} f) ≤ cardinal.mk ι :=\n  by\n  rw [← (cardinal.mk ι).lift_id]\n  exact cof_sup_le_lift H\n#align cof_sup_le cof_sup_le\n\n",
 "cof_succ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n@[simp]\ntheorem cof_succ (o) : cof (succ o) = 1 := by\n  apply le_antisymm\n  · refine' induction_on o fun α r _ => _\n    change cof (type _) ≤ _\n    rw [← (_ : cardinal.mk _ = 1)]\n    apply cof_type_le\n    · refine' fun a => ⟨sum.inr PUnit.unit, Set.mem_singleton _, _⟩\n      rcases a with (a | ⟨⟨⟨⟩⟩⟩) <;> simp [empty_relation]\n    · rw [cardinal.mk_fintype, set.card_singleton]\n      simp\n  · rw [← cardinal.succ_zero, succ_le_iff]\n    simpa [lt_iff_le_and_ne, cardinal.zero_le] using fun h => succ_ne_zero o (cof_eq_zero.1 (eq.symm h))\n#align cof_succ cof_succ\n\n",
 "cof_ord_le":
 "theorem cof_ord_le (c : cardinal) : c.ord.cof ≤ c := by simpa using cof_le_card c.ord\n#align cof_ord_le cof_ord_le\n\n",
 "cof_omega":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.omega -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n@[simp]\ntheorem cof_omega : cof (ordinal.omega) = cardinal.aleph_0 :=\n  (aleph_0_le_cof.2 omega_is_limit).antisymm' <| by\n    rw [← card_omega]\n    apply cof_le_card\n#align cof_omega cof_omega\n\n",
 "cof_nonempty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/-- The set in the definition of `order.strict_order.cof` is nonempty. -/\ntheorem strict_order.cof_nonempty (r : α → α → Prop) [is_irrefl α r] :\n    { c | ∃ S : set α, unbounded r S ∧ cardinal.mk S = c }.nonempty :=\n  @order.cof_nonempty α _ (is_refl.swap («expr ᶜ» r))\n#align strict_order.cof_nonempty strict_order.cof_nonempty\n\n",
 "cof_ne_zero":
 "theorem cof_ne_zero {o} : cof o ≠ 0 ↔ o ≠ 0 :=\n  cof_eq_zero.not\n#align cof_ne_zero cof_ne_zero\n\n",
 "cof_lsub_le_lift":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem cof_lsub_le_lift {ι} (f : ι → ordinal) : cof (lsub f) ≤ cardinal.lift.{v, u} (cardinal.mk ι) :=\n  by\n  rw [← mk_ulift]\n  convert cof_lsub_le fun i : ULift ι => f i.down\n  exact\n    lsub_eq_of_range_eq.{u, max u v, max u v}\n      (Set.ext fun x => ⟨fun ⟨i, hi⟩ => ⟨ulift.up i, hi⟩, fun ⟨i, hi⟩ => ⟨_, hi⟩⟩)\n#align cof_lsub_le_lift cof_lsub_le_lift\n\n",
 "cof_lsub_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem cof_lsub_le {ι} (f : ι → ordinal) : cof (lsub.{u, u} f) ≤ cardinal.mk ι :=\n  by\n  rw [cof_eq_Inf_lsub]\n  exact cinfₛ_le' ⟨ι, f, rfl, rfl⟩\n#align cof_lsub_le cof_lsub_le\n\n",
 "cof_lsub_def_nonempty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/-- The set in the `lsub` characterization of `cof` is nonempty. -/\ntheorem cof_lsub_def_nonempty (o) :\n    { a : cardinal | ∃ (ι : _)(f : ι → ordinal), lsub.{u, u} f = o ∧ cardinal.mk ι = a }.nonempty :=\n  ⟨_, card_mem_cof⟩\n#align cof_lsub_def_nonempty cof_lsub_def_nonempty\n\n",
 "cof_le_lift":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃r » -/\ntheorem rel_iso.cof_le_lift {α : Type u} {β : Type v} {r : α → α → Prop} {s} [is_refl β s] (f : «expr ≃r » r s) :\n    cardinal.lift.{max u v} (order.cof r) ≤ cardinal.lift.{max u v} (order.cof s) :=\n  by\n  rw [order.cof, order.cof, lift_Inf, lift_Inf, le_cinfₛ_iff'' (nonempty_image_iff.2 (order.cof_nonempty s))]\n  rintro - ⟨-, ⟨u, H, rfl⟩, rfl⟩\n  apply cinfₛ_le'\n  refine' ⟨_, ⟨«expr '' » f.symm u, fun a => _, rfl⟩, lift_mk_eq.{u, v, max u v}.2 ⟨(f.symm.to_equiv.image u).symm⟩⟩\n  rcases H (f a) with ⟨b, hb, hb'⟩\n  refine' ⟨f.symm b, mem_image_of_mem _ hb, f.map_rel_iff.1 _⟩\n  rwa [RelIso.apply_symm_apply]\n#align rel_iso.cof_le_lift rel_iso.cof_le_lift\n\n",
 "cof_le_card":
 "theorem cof_le_card (o) : cof o ≤ card o := by\n  rw [cof_eq_Inf_lsub]\n  exact cinfₛ_le' card_mem_cof\n#align cof_le_card cof_le_card\n\n",
 "cof_le":
 "theorem is_normal.cof_le {f} (hf : is_normal f) (a) : cof a ≤ cof (f a) :=\n  by\n  rcases zero_or_succ_or_limit a with (rfl | ⟨b, rfl⟩ | ha)\n  · rw [cof_zero]\n    exact zero_le _\n  · rw [cof_succ, cardinal.one_le_iff_ne_zero, cof_ne_zero, ← ordinal.pos_iff_ne_zero]\n    exact (ordinal.zero_le (f b)).trans_lt (hf.1 b)\n  · rw [hf.cof_eq ha]\n#align is_normal.cof_le is_normal.cof_le\n\n",
 "cof_eq_zero":
 "@[simp]\ntheorem cof_eq_zero {o} : cof o = 0 ↔ o = 0 :=\n  ⟨induction_on o fun α r _ z =>\n      let ⟨S, hl, e⟩ := cof_eq r\n      type_eq_zero_iff_is_empty.2 <|\n        ⟨fun a =>\n          let ⟨b, h, _⟩ := hl a\n          (mk_eq_zero_iff.1 (e.trans z)).elim' ⟨_, h⟩⟩,\n    fun e => by simp [e]⟩\n#align cof_eq_zero cof_eq_zero\n\n",
 "cof_eq_one_iff_is_succ":
 "@[simp]\ntheorem cof_eq_one_iff_is_succ {o} : cof.{u} o = 1 ↔ ∃ a, o = succ a :=\n  ⟨induction_on o fun α r _ z => by\n      skip\n      rcases cof_eq r with ⟨S, hl, e⟩; rw [z] at e\n      cases' mk_ne_zero_iff.1 (by rw [e] <;> exact one_ne_zero) with a\n      refine'\n        ⟨typein r a,\n          eq.symm <| quotient.sound ⟨RelIso.ofSurjective (RelEmbedding.ofMonotone _ fun x y => _) fun x => _⟩⟩\n      · apply sum.rec <;> [exact subtype.val, exact fun _ => a]\n      · rcases x with (x | ⟨⟨⟨⟩⟩⟩) <;> rcases y with (y | ⟨⟨⟨⟩⟩⟩) <;> simp [Subrel, Order.Preimage, empty_relation]\n        exact x.2\n      · suffices r x a ∨ ∃ b : PUnit, ↑a = x by simpa\n        rcases trichotomous_of r x a with (h | h | h)\n        · exact or.inl h\n        · exact or.inr ⟨PUnit.unit, h.symm⟩\n        · rcases hl x with ⟨a', aS, hn⟩\n          rw [(_ : ↑a = a')] at h\n          · exact absurd h hn\n          refine' congr_arg subtype.val (_ : a = ⟨a', aS⟩)\n          haveI := le_one_iff_subsingleton.1 (le_of_eq e)\n          apply subsingleton.elim,\n    fun ⟨a, e⟩ => by simp [e]⟩\n#align cof_eq_one_iff_is_succ cof_eq_one_iff_is_succ\n\n",
 "cof_eq_lift":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃r » -/\ntheorem rel_iso.cof_eq_lift {α : Type u} {β : Type v} {r s} [is_refl α r] [is_refl β s] (f : «expr ≃r » r s) :\n    cardinal.lift.{max u v} (order.cof r) = cardinal.lift.{max u v} (order.cof s) :=\n  (rel_iso.cof_le_lift f).antisymm (rel_iso.cof_le_lift f.symm)\n#align rel_iso.cof_eq_lift rel_iso.cof_eq_lift\n\n",
 "cof_eq_Inf_lsub":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem cof_eq_Inf_lsub (o : ordinal.{u}) :\n    cof o = infₛ { a : cardinal | ∃ (ι : Type u)(f : ι → ordinal), lsub.{u, u} f = o ∧ cardinal.mk ι = a } :=\n  by\n  refine' le_antisymm (le_cinfₛ (cof_lsub_def_nonempty o) _) (cinfₛ_le' _)\n  · rintro a ⟨ι, f, hf, rfl⟩\n    rw [← type_lt o]\n    refine'\n      (cof_type_le fun a => _).trans\n        (@mk_le_of_injective _ _\n          (fun s : «expr ⁻¹' » (typein ((· < ·) : o.out.α → o.out.α → Prop)) (Set.range f) => Classical.choose s.prop)\n          fun s t hst => by\n          let H := congr_arg f hst\n          rwa [Classical.choose_spec s.prop, Classical.choose_spec t.prop, typein_inj, subtype.coe_inj] at H)\n    have := typein_lt_self a\n    simp_rw [← hf, lt_lsub_iff] at this\n    cases' this with i hi\n    refine' ⟨enum (· < ·) (f i) _, _, _⟩\n    · rw [type_lt, ← hf]\n      apply lt_lsub\n    · rw [mem_preimage, typein_enum]\n      exact mem_range_self i\n    · rwa [← typein_le_typein, typein_enum]\n  · rcases cof_eq (· < ·) with ⟨S, hS, hS'⟩\n    let f : S → ordinal := fun s => typein (· < ·) s.val\n    refine'\n      ⟨S, f, le_antisymm (lsub_le fun i => typein_lt_self i) (le_of_forall_lt fun a ha => _), by rwa [type_lt o] at hS'⟩\n    rw [← type_lt o] at ha\n    rcases hS (enum (· < ·) a ha) with ⟨b, hb, hb'⟩\n    rw [← typein_le_typein, typein_enum] at hb'\n    exact hb'.trans_lt (lt_lsub.{u, u} f ⟨b, hb⟩)\n#align cof_eq_Inf_lsub cof_eq_Inf_lsub\n\n",
 "cof_eq'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem cof_eq' (r : α → α → Prop) [is_well_order α r] (h : is_limit (type r)) :\n    ∃ S : set α, (∀ a, ∃ b ∈ S, r a b) ∧ cardinal.mk S = cof (type r) :=\n  let ⟨S, H, e⟩ := cof_eq r\n  ⟨S, fun a =>\n    let a' := enum r _ (h.2 _ (typein_lt_type r a))\n    let ⟨b, h, ab⟩ := H a'\n    ⟨b, h,\n      (is_order_connected.conn a b a' <|\n            (typein_lt_typein r).1\n              (by\n                rw [typein_enum]\n                exact lt_succ (typein _ _))).resolve_right\n        ab⟩,\n    e⟩\n#align cof_eq' cof_eq'\n\n",
 "cof_eq":
 "theorem is_regular.cof_eq {c : cardinal} (H : c.is_regular) : c.ord.cof = c :=\n  (cof_ord_le c).antisymm H.2\n#align is_regular.cof_eq is_regular.cof_eq\n\n",
 "cof_cof":
 "@[simp]\ntheorem cof_cof (a : ordinal.{u}) : cof (cof a).ord = cof a :=\n  by\n  cases' exists_fundamental_sequence a with f hf\n  cases' exists_fundamental_sequence a.cof.ord with g hg\n  exact ord_injective (hf.trans hg).cof_eq.symm\n#align cof_cof cof_cof\n\n",
 "cof_bsup_le_lift":
 "theorem cof_bsup_le_lift {o : ordinal} {f : ∀ a < o, ordinal} (H : ∀ i h, f i h < bsup o f) :\n    cof (bsup o f) ≤ o.card.lift := by\n  rw [← bsup_eq_blsub_iff_lt_bsup] at H\n  rw [H]\n  exact cof_blsub_le_lift f\n#align cof_bsup_le_lift cof_bsup_le_lift\n\n",
 "cof_bsup_le":
 "theorem cof_bsup_le {o : ordinal} {f : ∀ a < o, ordinal} :\n    (∀ i h, f i h < bsup.{u, u} o f) → cof (bsup.{u, u} o f) ≤ o.card :=\n  by\n  rw [← o.card.lift_id]\n  exact cof_bsup_le_lift\n#align cof_bsup_le cof_bsup_le\n\n",
 "cof_blsub_le_lift":
 "theorem cof_blsub_le_lift {o} (f : ∀ a < o, ordinal) : cof (blsub o f) ≤ cardinal.lift.{v, u} o.card :=\n  by\n  convert cof_lsub_le_lift _\n  exact (mk_ordinal_out o).symm\n#align cof_blsub_le_lift cof_blsub_le_lift\n\n",
 "cof_blsub_le":
 "theorem cof_blsub_le {o} (f : ∀ a < o, ordinal) : cof (blsub.{u, u} o f) ≤ o.card :=\n  by\n  rw [← o.card.lift_id]\n  exact cof_blsub_le_lift f\n#align cof_blsub_le cof_blsub_le\n\n",
 "cof_add":
 "@[simp]\ntheorem cof_add (a b : ordinal) : b ≠ 0 → cof (a + b) = cof b := fun h =>\n  by\n  rcases zero_or_succ_or_limit b with (rfl | ⟨c, rfl⟩ | hb)\n  · contradiction\n  · rw [add_succ, cof_succ, cof_succ]\n  · exact (add_is_normal a).cof_eq hb\n#align cof_add cof_add\n\n",
 "card_mem_cof":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\nprivate theorem card_mem_cof {o} : ∃ (ι : _)(f : ι → ordinal), lsub.{u, u} f = o ∧ cardinal.mk ι = o.card :=\n  ⟨_, _, lsub_typein o, mk_ordinal_out o⟩\n#align card_mem_cof card_mem_cof\n\n",
 "bsup_lt_ord_of_is_regular":
 "theorem bsup_lt_ord_of_is_regular {o : ordinal} {f : ∀ a < o, ordinal} {c} (hc : is_regular c) (hι : o.card < c) :\n    (∀ i hi, f i hi < c.ord) → ordinal.bsup o f < c.ord :=\n  bsup_lt_ord (by rwa [hc.cof_eq])\n#align bsup_lt_ord_of_is_regular bsup_lt_ord_of_is_regular\n\n",
 "bsup_lt_ord_lift_of_is_regular":
 "theorem bsup_lt_ord_lift_of_is_regular {o : ordinal} {f : ∀ a < o, ordinal} {c} (hc : is_regular c)\n    (hι : cardinal.lift o.card < c) : (∀ i hi, f i hi < c.ord) → ordinal.bsup o f < c.ord :=\n  bsup_lt_ord_lift (by rwa [hc.cof_eq])\n#align bsup_lt_ord_lift_of_is_regular bsup_lt_ord_lift_of_is_regular\n\n",
 "bsup_lt_ord_lift":
 "theorem bsup_lt_ord_lift {o : ordinal} {f : ∀ a < o, ordinal} {c : ordinal} (ho : o.card.lift < c.cof)\n    (hf : ∀ i hi, f i hi < c) : bsup.{u, v} o f < c :=\n  (bsup_le_blsub f).trans_lt (blsub_lt_ord_lift ho hf)\n#align bsup_lt_ord_lift bsup_lt_ord_lift\n\n",
 "bsup_lt_ord":
 "theorem bsup_lt_ord {o : ordinal} {f : ∀ a < o, ordinal} {c : ordinal} (ho : o.card < c.cof) :\n    (∀ i hi, f i hi < c) → bsup.{u, u} o f < c :=\n  bsup_lt_ord_lift (by rwa [o.card.lift_id])\n#align bsup_lt_ord bsup_lt_ord\n\n",
 "blsub_lt_ord_of_is_regular":
 "theorem blsub_lt_ord_of_is_regular {o : ordinal} {f : ∀ a < o, ordinal} {c} (hc : is_regular c) (ho : o.card < c) :\n    (∀ i hi, f i hi < c.ord) → ordinal.blsub o f < c.ord :=\n  blsub_lt_ord (by rwa [hc.cof_eq])\n#align blsub_lt_ord_of_is_regular blsub_lt_ord_of_is_regular\n\n",
 "blsub_lt_ord_lift_of_is_regular":
 "theorem blsub_lt_ord_lift_of_is_regular {o : ordinal} {f : ∀ a < o, ordinal} {c} (hc : is_regular c)\n    (ho : cardinal.lift o.card < c) : (∀ i hi, f i hi < c.ord) → ordinal.blsub o f < c.ord :=\n  blsub_lt_ord_lift (by rwa [hc.cof_eq])\n#align blsub_lt_ord_lift_of_is_regular blsub_lt_ord_lift_of_is_regular\n\n",
 "blsub_lt_ord_lift":
 "theorem blsub_lt_ord_lift {o : ordinal} {f : ∀ a < o, ordinal} {c : ordinal} (ho : o.card.lift < c.cof)\n    (hf : ∀ i hi, f i hi < c) : blsub.{u, v} o f < c :=\n  lt_of_le_of_ne (blsub_le hf) fun h => ho.not_le (by simpa [← supr_ord, hf, h] using cof_blsub_le_lift.{u} f)\n#align blsub_lt_ord_lift blsub_lt_ord_lift\n\n",
 "blsub_lt_ord":
 "theorem blsub_lt_ord {o : ordinal} {f : ∀ a < o, ordinal} {c : ordinal} (ho : o.card < c.cof)\n    (hf : ∀ i hi, f i hi < c) : blsub.{u, u} o f < c :=\n  blsub_lt_ord_lift (by rwa [o.card.lift_id]) hf\n#align blsub_lt_ord blsub_lt_ord\n\n",
 "blsub_eq":
 "theorem blsub_eq (hf : is_fundamental_sequence a o f) : blsub.{u, u} o f = a :=\n  hf.2.2\n#align blsub_eq blsub_eq\n\n",
 "aleph_cof":
 "@[simp]\ntheorem aleph_cof {o : ordinal} (ho : o.is_limit) : (aleph o).ord.cof = o.cof :=\n  aleph_is_normal.cof_eq ho\n#align aleph_cof aleph_cof\n\n",
 "aleph_0_le_cof":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\ntheorem aleph_0_le_cof {o} : cardinal.aleph_0 ≤ cof o ↔ is_limit o :=\n  by\n  rcases zero_or_succ_or_limit o with (rfl | ⟨o, rfl⟩ | l)\n  · simp [not_zero_is_limit, cardinal.aleph_0_ne_zero]\n  · simp [not_succ_is_limit, cardinal.one_lt_aleph_0]\n  · simp [l]\n    refine' le_of_not_lt fun h => _\n    cases' cardinal.lt_aleph_0.1 h with n e\n    have := cof_cof o\n    rw [e, ord_nat] at this\n    cases n\n    · simp at e\n      simpa [e, not_zero_is_limit] using l\n    · rw [nat_cast_succ, cof_succ] at this\n      rw [← this, cof_eq_one_iff_is_succ] at e\n      rcases e with ⟨a, rfl⟩\n      exact not_succ_is_limit _ l\n#align aleph_0_le_cof aleph_0_le_cof\n\n",
 "aleph_0_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\ntheorem is_regular.aleph_0_le {c : cardinal} (H : c.is_regular) : cardinal.aleph_0 ≤ c :=\n  H.1\n#align is_regular.aleph_0_le is_regular.aleph_0_le\n\n",
 "aleph'_cof":
 "@[simp]\ntheorem aleph'_cof {o : ordinal} (ho : o.is_limit) : (aleph' o).ord.cof = o.cof :=\n  aleph'_is_normal.cof_eq ho\n#align aleph'_cof aleph'_cof\n\n"}