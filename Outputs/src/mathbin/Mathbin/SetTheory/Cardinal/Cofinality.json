{"zero":
 "protected theorem zero {f : ‚àÄ b < (0 : ordinal), ordinal} : is_fundamental_sequence 0 0 f :=\n  ‚ü®by rw [cof_zero, ord_zero], fun i j hi => (ordinal.not_lt_zero i hi).elim, blsub_zero f‚ü©\n#align zero zero\n\n",
 "univ_inaccessible":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n-- Lean's foundations prove the existence of ‚Ñµ‚ÇÄ many inaccessible cardinals\ntheorem univ_inaccessible : is_inaccessible univ.{u, v} :=\n  is_inaccessible.mk (by simpa using lift_lt_univ' (cardinal.aleph_0)) (by simp) fun c h =>\n    by\n    rcases lt_univ'.1 h with ‚ü®c, rfl‚ü©\n    rw [‚Üê lift_two_power.{u, max (u + 1) v}]\n    apply lift_lt_univ'\n#align univ_inaccessible univ_inaccessible\n\n",
 "unbounded_of_unbounded_sUnion":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/-- If the union of s is unbounded and s is smaller than the cofinality,\n  then s has an unbounded member -/\ntheorem unbounded_of_unbounded_sUnion (r : Œ± ‚Üí Œ± ‚Üí Prop) [wo : is_well_order Œ± r] {s : set (set Œ±)}\n    (h‚ÇÅ : unbounded r <| ‚ãÉ‚ÇÄ s) (h‚ÇÇ : cardinal.mk s < strict_order.cof r) : ‚àÉ x ‚àà s, unbounded r x :=\n  by\n  by_contra' h\n  simp_rw [not_unbounded_iff] at h\n  let f : s ‚Üí Œ± := fun x : s => wo.wf.sup x (h x.1 x.2)\n  refine' h‚ÇÇ.not_le (le_trans (cinf‚Çõ_le' ‚ü®range f, fun x => _, rfl‚ü©) mk_range_le)\n  rcases h‚ÇÅ x with ‚ü®y, ‚ü®c, hc, hy‚ü©, hxy‚ü©\n  exact ‚ü®f ‚ü®c, hc‚ü©, mem_range_self _, fun hxz => hxy (trans (wo.wf.lt_sup _ hy) hxz)‚ü©\n#align unbounded_of_unbounded_sUnion unbounded_of_unbounded_sUnion\n\n",
 "unbounded_of_unbounded_Union":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚ãÉ , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚ãÉ , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/-- If the union of s is unbounded and s is smaller than the cofinality,\n  then s has an unbounded member -/\ntheorem unbounded_of_unbounded_Union {Œ± Œ≤ : Type u} (r : Œ± ‚Üí Œ± ‚Üí Prop) [wo : is_well_order Œ± r] (s : Œ≤ ‚Üí set Œ±)\n    (h‚ÇÅ :\n      unbounded r <|\n        ¬´expr‚ãÉ , ¬ª \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚ãÉ , ¬ª\" (s x))\n    (h‚ÇÇ : cardinal.mk Œ≤ < strict_order.cof r) : ‚àÉ x : Œ≤, unbounded r (s x) :=\n  by\n  rw [‚Üê sUnion_range] at h‚ÇÅ\n  rcases unbounded_of_unbounded_sUnion r h‚ÇÅ (mk_range_le.trans_lt h‚ÇÇ) with ‚ü®_, ‚ü®x, rfl‚ü©, u‚ü©\n  exact ‚ü®x, u‚ü©\n#align unbounded_of_unbounded_Union unbounded_of_unbounded_Union\n\n",
 "two_power_lt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.pow -/\ntheorem is_strong_limit.two_power_lt {x c} (h : is_strong_limit c) : x < c ‚Üí cardinal.pow 2 x < c :=\n  h.2 x\n#align is_strong_limit.two_power_lt is_strong_limit.two_power_lt\n\n",
 "trans":
 "#print trans /-\ntheorem trans {a o o' : ordinal.{u}} {f : ‚àÄ b < o, ordinal.{u}} (hf : is_fundamental_sequence a o f)\n    {g : ‚àÄ b < o', ordinal.{u}} (hg : is_fundamental_sequence o o' g) :\n    is_fundamental_sequence a o' fun i hi =>\n      f (g i hi)\n        (by\n          rw [‚Üê hg.2.2]\n          apply lt_blsub) :=\n  by\n  refine' ‚ü®_, fun i j _ _ h => hf.2.1 _ _ (hg.2.1 _ _ h), _‚ü©\n  ¬∑ rw [hf.cof_eq]\n    exact hg.1.trans (ord_cof_le o)\n  ¬∑ rw [@blsub_comp.{u, u, u} o _ f (@is_fundamental_sequence.monotone _ _ f hf)]\n    exact hf.2.2\n#align trans trans\n-/\n\n",
 "supr_lt_of_is_regular":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem supr_lt_of_is_regular {Œπ} {f : Œπ ‚Üí cardinal} {c} (hc : is_regular c) (hŒπ : cardinal.mk Œπ < c) :\n    (‚àÄ i, f i < c) ‚Üí sup·µ¢ f < c :=\n  supr_lt (by rwa [hc.cof_eq])\n#align supr_lt_of_is_regular supr_lt_of_is_regular\n\n",
 "supr_lt_lift_of_is_regular":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem supr_lt_lift_of_is_regular {Œπ} {f : Œπ ‚Üí cardinal} {c} (hc : is_regular c)\n    (hŒπ : cardinal.lift (cardinal.mk Œπ) < c) : (‚àÄ i, f i < c) ‚Üí sup·µ¢ f < c :=\n  supr_lt_lift (by rwa [hc.cof_eq])\n#align supr_lt_lift_of_is_regular supr_lt_lift_of_is_regular\n\n",
 "supr_lt_lift":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem supr_lt_lift {Œπ} {f : Œπ ‚Üí cardinal} {c : cardinal} (hŒπ : cardinal.lift (cardinal.mk Œπ) < c.ord.cof)\n    (hf : ‚àÄ i, f i < c) : sup·µ¢ f < c :=\n  by\n  rw [‚Üê ord_lt_ord, supr_ord (cardinal.bdd_above_range _)]\n  refine' sup_lt_ord_lift hŒπ fun i => _\n  rw [ord_lt_ord]\n  apply hf\n#align supr_lt_lift supr_lt_lift\n\n",
 "supr_lt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem supr_lt {Œπ} {f : Œπ ‚Üí cardinal} {c : cardinal} (hŒπ : cardinal.mk Œπ < c.ord.cof) : (‚àÄ i, f i < c) ‚Üí sup·µ¢ f < c :=\n  supr_lt_lift (by rwa [(cardinal.mk Œπ).lift_id])\n#align supr_lt supr_lt\n\n",
 "sup_lt_ord_of_is_regular":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem sup_lt_ord_of_is_regular {Œπ} {f : Œπ ‚Üí ordinal} {c} (hc : is_regular c) (hŒπ : cardinal.mk Œπ < c) :\n    (‚àÄ i, f i < c.ord) ‚Üí ordinal.sup f < c.ord :=\n  sup_lt_ord (by rwa [hc.cof_eq])\n#align sup_lt_ord_of_is_regular sup_lt_ord_of_is_regular\n\n",
 "sup_lt_ord_lift_of_is_regular":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem sup_lt_ord_lift_of_is_regular {Œπ} {f : Œπ ‚Üí ordinal} {c} (hc : is_regular c)\n    (hŒπ : cardinal.lift (cardinal.mk Œπ) < c) : (‚àÄ i, f i < c.ord) ‚Üí ordinal.sup f < c.ord :=\n  sup_lt_ord_lift (by rwa [hc.cof_eq])\n#align sup_lt_ord_lift_of_is_regular sup_lt_ord_lift_of_is_regular\n\n",
 "sup_lt_ord_lift":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem sup_lt_ord_lift {Œπ} {f : Œπ ‚Üí ordinal} {c : ordinal} (hŒπ : cardinal.lift (cardinal.mk Œπ) < c.cof)\n    (hf : ‚àÄ i, f i < c) : sup.{u, v} f < c :=\n  (sup_le_lsub.{u, v} f).trans_lt (lsub_lt_ord_lift hŒπ hf)\n#align sup_lt_ord_lift sup_lt_ord_lift\n\n",
 "sup_lt_ord":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem sup_lt_ord {Œπ} {f : Œπ ‚Üí ordinal} {c : ordinal} (hŒπ : cardinal.mk Œπ < c.cof) :\n    (‚àÄ i, f i < c) ‚Üí sup.{u, u} f < c :=\n  sup_lt_ord_lift (by rwa [(cardinal.mk Œπ).lift_id])\n#align sup_lt_ord sup_lt_ord\n\n",
 "sum_lt_of_is_regular":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem sum_lt_of_is_regular {Œπ : Type u} {f : Œπ ‚Üí cardinal} {c : cardinal} (hc : is_regular c)\n    (hŒπ : cardinal.mk Œπ < c) : (‚àÄ i, f i < c) ‚Üí sum f < c :=\n  sum_lt_lift_of_is_regular.{u, u} hc (by rwa [lift_id])\n#align sum_lt_of_is_regular sum_lt_of_is_regular\n\n",
 "sum_lt_lift_of_is_regular":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem sum_lt_lift_of_is_regular {Œπ : Type u} {f : Œπ ‚Üí cardinal} {c : cardinal} (hc : is_regular c)\n    (hŒπ : cardinal.lift.{v, u} (cardinal.mk Œπ) < c) (hf : ‚àÄ i, f i < c) : sum f < c :=\n  (sum_le_supr_lift _).trans_lt <| mul_lt_of_lt hc.1 hŒπ (supr_lt_lift_of_is_regular hc hŒπ hf)\n#align sum_lt_lift_of_is_regular sum_lt_lift_of_is_regular\n\n",
 "succ_lt":
 "theorem is_limit.succ_lt {x c} (h : is_limit c) : x < c ‚Üí succ x < c :=\n  h.2 x\n#align is_limit.succ_lt is_limit.succ_lt\n\n",
 "succ":
 "protected theorem succ : is_fundamental_sequence (succ o) 1 fun _ _ => o :=\n  by\n  refine' ‚ü®_, fun i j hi hj h => _, blsub_const ordinal.one_ne_zero o‚ü©\n  ¬∑ rw [cof_succ, ord_one]\n  ¬∑ rw [lt_one_iff_zero] at hi hj\n    rw [hi, hj] at h\n    exact h.false.elim\n#align succ succ\n\n",
 "strict_mono":
 "protected theorem strict_mono (hf : is_fundamental_sequence a o f) {i j} : ‚àÄ hi hj, i < j ‚Üí f i hi < f j hj :=\n  hf.2.1\n#align strict_mono strict_mono\n\n",
 "pos":
 "theorem is_regular.pos {c : cardinal} (H : c.is_regular) : 0 < c :=\n  aleph_0_pos.trans_le H.1\n#align is_regular.pos is_regular.pos\n\n",
 "ord_pos":
 "theorem is_regular.ord_pos {c : cardinal} (H : c.is_regular) : 0 < c.ord :=\n  by\n  rw [cardinal.lt_ord]\n  exact H.pos\n#align is_regular.ord_pos is_regular.ord_pos\n\n",
 "ord_cof_le":
 "theorem ord_cof_le (o : ordinal.{u}) : o.cof.ord ‚â§ o :=\n  (ord_le_ord.2 (cof_le_card o)).trans (ord_card_le o)\n#align ord_cof_le ord_cof_le\n\n",
 "ord_cof_eq":
 "theorem ord_cof_eq (r : Œ± ‚Üí Œ± ‚Üí Prop) [is_well_order Œ± r] :\n    ‚àÉ S, unbounded r S ‚àß type (Subrel r S) = (cof (type r)).ord :=\n  by\n  let ‚ü®S, hS, e‚ü© := cof_eq r\n  let ‚ü®s, _, e'‚ü© := cardinal.ord_eq S\n  let T : set Œ± := { a | ‚àÉ aS : a ‚àà S, ‚àÄ b : S, s b ‚ü®_, aS‚ü© ‚Üí r b a }\n  skip; suffices\n  ¬∑ refine' ‚ü®T, this, le_antisymm _ (cardinal.ord_le.2 <| cof_type_le this)‚ü©\n    rw [‚Üê e, e']\n    refine'\n      (RelEmbedding.ofMonotone\n          (fun a : T =>\n            (‚ü®a,\n                let ‚ü®aS, _‚ü© := a.2\n                aS‚ü© :\n              S))\n          fun a b h => _).ordinal_type_le\n    rcases a with ‚ü®a, aS, ha‚ü©\n    rcases b with ‚ü®b, bS, hb‚ü©\n    change s ‚ü®a, _‚ü© ‚ü®b, _‚ü©\n    refine' ((trichotomous_of s _ _).resolve_left fun hn => _).resolve_left _\n    ¬∑ exact asymm h (ha _ hn)\n    ¬∑ intro e\n      injection e with e\n      subst b\n      exact irrefl _ h\n  ¬∑ intro a\n    have : { b : S | ¬¨r b a }.nonempty :=\n      let ‚ü®b, bS, ba‚ü© := hS a\n      ‚ü®‚ü®b, bS‚ü©, ba‚ü©\n    let b := is_well_founded.wf.min _ this\n    have ba : ¬¨r b a := is_well_founded.wf.min_mem _ this\n    refine' ‚ü®b, ‚ü®b.2, fun c => not_imp_not.1 fun h => _‚ü©, ba‚ü©\n    rw [show ‚àÄ b : S, (‚ü®b, b.2‚ü© : S) = b by intro b <;> cases b <;> rfl]\n    exact is_well_founded.wf.not_lt_min _ this (is_order_connected.neg_trans h ba)\n#align ord_cof_eq ord_cof_eq\n\n",
 "ord_cof":
 "theorem ord_cof (hf : is_fundamental_sequence a o f) :\n    is_fundamental_sequence a a.cof.ord fun i hi => f i (hi.trans_le (by rw [hf.cof_eq])) :=\n  by\n  have H := hf.cof_eq\n  subst H\n  exact hf\n#align ord_cof ord_cof\n\n",
 "nfp_lt_ord_of_is_regular":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\ntheorem nfp_lt_ord_of_is_regular {f : ordinal ‚Üí ordinal} {c} (hc : is_regular c) (hc' : c ‚â† cardinal.aleph_0)\n    (hf : ‚àÄ i < c.ord, f i < c.ord) {a} : a < c.ord ‚Üí nfp f a < c.ord :=\n  nfp_lt_ord\n    (by\n      rw [hc.cof_eq]\n      exact lt_of_le_of_ne hc.1 hc'.symm)\n    hf\n#align nfp_lt_ord_of_is_regular nfp_lt_ord_of_is_regular\n\n",
 "nfp_lt_ord":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\ntheorem nfp_lt_ord {f : ordinal ‚Üí ordinal} {c} (hc : cardinal.aleph_0 < cof c) (hf : ‚àÄ i < c, f i < c) {a} :\n    a < c ‚Üí nfp f a < c :=\n  nfp_family_lt_ord_lift hc (by simpa using cardinal.one_lt_aleph_0.trans hc) fun _ => hf\n#align nfp_lt_ord nfp_lt_ord\n\n",
 "nfp_family_lt_ord_of_is_regular":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\ntheorem nfp_family_lt_ord_of_is_regular {Œπ} {f : Œπ ‚Üí ordinal ‚Üí ordinal} {c} (hc : is_regular c) (hŒπ : cardinal.mk Œπ < c)\n    (hc' : c ‚â† cardinal.aleph_0) {a} (hf : ‚àÄ (i), ‚àÄ b < c.ord, f i b < c.ord) :\n    a < c.ord ‚Üí nfp_family.{u, u} f a < c.ord :=\n  nfp_family_lt_ord_lift_of_is_regular hc (by rwa [lift_id]) hc' hf\n#align nfp_family_lt_ord_of_is_regular nfp_family_lt_ord_of_is_regular\n\n",
 "nfp_family_lt_ord_lift_of_is_regular":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\ntheorem nfp_family_lt_ord_lift_of_is_regular {Œπ} {f : Œπ ‚Üí ordinal ‚Üí ordinal} {c} (hc : is_regular c)\n    (hŒπ : (cardinal.mk Œπ).lift < c) (hc' : c ‚â† cardinal.aleph_0) (hf : ‚àÄ (i), ‚àÄ b < c.ord, f i b < c.ord) {a}\n    (ha : a < c.ord) : nfp_family.{u, v} f a < c.ord :=\n  by\n  apply nfp_family_lt_ord_lift _ _ hf ha <;> rwa [hc.cof_eq]\n  exact lt_of_le_of_ne hc.1 hc'.symm\n#align nfp_family_lt_ord_lift_of_is_regular nfp_family_lt_ord_lift_of_is_regular\n\n",
 "nfp_family_lt_ord_lift":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem nfp_family_lt_ord_lift {Œπ} {f : Œπ ‚Üí ordinal ‚Üí ordinal} {c} (hc : cardinal.aleph_0 < cof c)\n    (hc' : (cardinal.mk Œπ).lift < cof c) (hf : ‚àÄ (i), ‚àÄ b < c, f i b < c) {a} (ha : a < c) :\n    nfp_family.{u, v} f a < c :=\n  by\n  refine' sup_lt_ord_lift ((cardinal.lift_le.2 (mk_list_le_max Œπ)).trans_lt _) fun l => _\n  ¬∑ rw [lift_max]\n    apply max_lt _ hc'\n    rwa [cardinal.lift_aleph_0]\n  ¬∑ induction' l with i l H\n    ¬∑ exact ha\n    ¬∑ exact hf _ _ H\n#align nfp_family_lt_ord_lift nfp_family_lt_ord_lift\n\n",
 "nfp_family_lt_ord":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem nfp_family_lt_ord {Œπ} {f : Œπ ‚Üí ordinal ‚Üí ordinal} {c} (hc : cardinal.aleph_0 < cof c)\n    (hc' : cardinal.mk Œπ < cof c) (hf : ‚àÄ (i), ‚àÄ b < c, f i b < c) {a} : a < c ‚Üí nfp_family.{u, u} f a < c :=\n  nfp_family_lt_ord_lift hc (by rwa [(cardinal.mk Œπ).lift_id]) hf\n#align nfp_family_lt_ord nfp_family_lt_ord\n\n",
 "nfp_bfamily_lt_ord_of_is_regular":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\ntheorem nfp_bfamily_lt_ord_of_is_regular {o : ordinal} {f : ‚àÄ a < o, ordinal ‚Üí ordinal} {c} (hc : is_regular c)\n    (ho : o.card < c) (hc' : c ‚â† cardinal.aleph_0) (hf : ‚àÄ (i hi), ‚àÄ b < c.ord, f i hi b < c.ord) {a} :\n    a < c.ord ‚Üí nfp_bfamily.{u, u} o f a < c.ord :=\n  nfp_bfamily_lt_ord_lift_of_is_regular hc (by rwa [lift_id]) hc' hf\n#align nfp_bfamily_lt_ord_of_is_regular nfp_bfamily_lt_ord_of_is_regular\n\n",
 "nfp_bfamily_lt_ord_lift_of_is_regular":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\ntheorem nfp_bfamily_lt_ord_lift_of_is_regular {o : ordinal} {f : ‚àÄ a < o, ordinal ‚Üí ordinal} {c} (hc : is_regular c)\n    (ho : o.card.lift < c) (hc' : c ‚â† cardinal.aleph_0) (hf : ‚àÄ (i hi), ‚àÄ b < c.ord, f i hi b < c.ord) {a} :\n    a < c.ord ‚Üí nfp_bfamily.{u, v} o f a < c.ord :=\n  nfp_family_lt_ord_lift_of_is_regular hc (by rwa [mk_ordinal_out]) hc' fun i => hf _ _\n#align nfp_bfamily_lt_ord_lift_of_is_regular nfp_bfamily_lt_ord_lift_of_is_regular\n\n",
 "nfp_bfamily_lt_ord_lift":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\ntheorem nfp_bfamily_lt_ord_lift {o : ordinal} {f : ‚àÄ a < o, ordinal ‚Üí ordinal} {c} (hc : cardinal.aleph_0 < cof c)\n    (hc' : o.card.lift < cof c) (hf : ‚àÄ (i hi), ‚àÄ b < c, f i hi b < c) {a} : a < c ‚Üí nfp_bfamily.{u, v} o f a < c :=\n  nfp_family_lt_ord_lift hc (by rwa [mk_ordinal_out]) fun i => hf _ _\n#align nfp_bfamily_lt_ord_lift nfp_bfamily_lt_ord_lift\n\n",
 "nfp_bfamily_lt_ord":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\ntheorem nfp_bfamily_lt_ord {o : ordinal} {f : ‚àÄ a < o, ordinal ‚Üí ordinal} {c} (hc : cardinal.aleph_0 < cof c)\n    (hc' : o.card < cof c) (hf : ‚àÄ (i hi), ‚àÄ b < c, f i hi b < c) {a} : a < c ‚Üí nfp_bfamily.{u, u} o f a < c :=\n  nfp_bfamily_lt_ord_lift hc (by rwa [o.card.lift_id]) hf\n#align nfp_bfamily_lt_ord nfp_bfamily_lt_ord\n\n",
 "ne_zero":
 "theorem is_strong_limit.ne_zero {c} (h : is_strong_limit c) : c ‚â† 0 :=\n  h.1\n#align is_strong_limit.ne_zero is_strong_limit.ne_zero\n\n",
 "monotone":
 "protected theorem monotone (hf : is_fundamental_sequence a o f) {i j : ordinal} (hi : i < o) (hj : j < o)\n    (hij : i ‚â§ j) : f i hi ‚â§ f j hj :=\n  by\n  rcases lt_or_eq_of_le hij with (hij | rfl)\n  ¬∑ exact (hf.2.1 hi hj hij).le\n  ¬∑ rfl\n#align monotone monotone\n\n",
 "mk_subset_mk_lt_cof":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.pow -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem mk_subset_mk_lt_cof {Œ± : Type _} (h : ‚àÄ x < cardinal.mk Œ±, cardinal.pow 2 x < cardinal.mk Œ±) :\n    cardinal.mk { s : set Œ± // cardinal.mk s < cof (cardinal.mk Œ±).ord } = cardinal.mk Œ± :=\n  by\n  rcases eq_or_ne (cardinal.mk Œ±) 0 with (ha | ha)\n  ¬∑ rw [ha]\n    simp [fun s => (cardinal.zero_le s).not_lt]\n  have h' : is_strong_limit (cardinal.mk Œ±) := ‚ü®ha, h‚ü©\n  rcases ord_eq Œ± with ‚ü®r, wo, hr‚ü©\n  haveI := wo\n  apply le_antisymm\n  ¬∑ nth_rw_rhs 1 [‚Üê mk_bounded_subset h hr]\n    apply mk_le_mk_of_subset fun s hs => _\n    rw [hr] at hs\n    exact lt_cof_type hs\n  ¬∑ refine' @mk_le_of_injective Œ± _ (fun x => subtype.mk {x} _) _\n    ¬∑ rw [mk_singleton]\n      exact one_lt_aleph_0.trans_le (aleph_0_le_cof.2 (ord_is_limit h'.is_limit.aleph_0_le))\n    ¬∑ intro a b hab\n      simpa only [singleton_eq_singleton_iff] using hab\n#align mk_subset_mk_lt_cof mk_subset_mk_lt_cof\n\n",
 "mk_bounded_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚ãÉ , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚ãÉ , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.pow -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem mk_bounded_subset {Œ± : Type _} (h : ‚àÄ x < cardinal.mk Œ±, cardinal.pow 2 x < cardinal.mk Œ±) {r : Œ± ‚Üí Œ± ‚Üí Prop}\n    [is_well_order Œ± r] (hr : (cardinal.mk Œ±).ord = type r) :\n    cardinal.mk { s : set Œ± // bounded r s } = cardinal.mk Œ± :=\n  by\n  rcases eq_or_ne (cardinal.mk Œ±) 0 with (ha | ha)\n  ¬∑ rw [ha]\n    haveI := mk_eq_zero_iff.1 ha\n    rw [mk_eq_zero_iff]\n    constructor\n    rintro ‚ü®s, hs‚ü©\n    exact (not_unbounded_iff s).2 hs (unbounded_of_is_empty s)\n  have h' : is_strong_limit (cardinal.mk Œ±) := ‚ü®ha, h‚ü©\n  have ha := h'.is_limit.aleph_0_le\n  apply le_antisymm\n  ¬∑ have :\n      { s : set Œ± | bounded r s } =\n        ¬´expr‚ãÉ , ¬ª \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚ãÉ , ¬ª\"\n          (ùí´{ j | r j i }) :=\n      set_of_exists _\n    rw [‚Üê coe_set_of, this]\n    convert mk_Union_le_sum_mk.trans ((sum_le_supr _).trans (mul_le_max_of_aleph_0_le_left ha))\n    apply (max_eq_left _).symm\n    apply csup·µ¢_le' fun i => _\n    rw [mk_powerset]\n    apply (h'.two_power_lt _).le\n    rw [coe_set_of, card_typein, ‚Üê lt_ord, hr]\n    apply typein_lt_type\n  ¬∑ refine' @mk_le_of_injective Œ± _ (fun x => subtype.mk {x} _) _\n    ¬∑ apply bounded_singleton\n      rw [‚Üê hr]\n      apply ord_is_limit ha\n    ¬∑ intro a b hab\n      simpa only [singleton_eq_singleton_iff] using hab\n#align mk_bounded_subset mk_bounded_subset\n\n",
 "mk":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.pow -/\ntheorem is_inaccessible.mk {c} (h‚ÇÅ : cardinal.aleph_0 < c) (h‚ÇÇ : c ‚â§ c.ord.cof) (h‚ÇÉ : ‚àÄ x < c, cardinal.pow 2 x < c) :\n    is_inaccessible c :=\n  ‚ü®h‚ÇÅ, ‚ü®h‚ÇÅ.le, h‚ÇÇ‚ü©, (aleph_0_pos.trans h‚ÇÅ).ne', h‚ÇÉ‚ü©\n#align is_inaccessible.mk is_inaccessible.mk\n\n",
 "lt_power_cof":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.pow -/\ntheorem lt_power_cof {c : cardinal.{u}} : cardinal.aleph_0 ‚â§ c ‚Üí c < cardinal.pow c (cof c.ord) :=\n  Quotient.inductionOn c fun Œ± h => by\n    rcases ord_eq Œ± with ‚ü®r, wo, re‚ü©; skip\n    have := ord_is_limit h\n    rw [mk_def, re] at this‚ä¢\n    rcases cof_eq' r this with ‚ü®S, H, Se‚ü©\n    have := sum_lt_prod (fun a : S => cardinal.mk { x // r x a }) (fun _ => cardinal.mk Œ±) fun i => _\n    ¬∑ simp only [cardinal.prod_const, cardinal.lift_id, ‚Üê Se, ‚Üê mk_sigma, power_def] at this‚ä¢\n      refine' lt_of_le_of_lt _ this\n      refine' ‚ü®embedding.of_surjective _ _‚ü©\n      ¬∑ exact fun x => x.2.1\n      ¬∑\n        exact fun a =>\n          let ‚ü®b, h, ab‚ü© := H a\n          ‚ü®‚ü®‚ü®_, h‚ü©, _, ab‚ü©, rfl‚ü©\n    ¬∑ have := typein_lt_type r i\n      rwa [‚Üê re, lt_ord] at this\n#align lt_power_cof lt_power_cof\n\n",
 "lt_cof_type":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem lt_cof_type [is_well_order Œ± r] {S : set Œ±} : cardinal.mk S < cof (type r) ‚Üí bounded r S := by\n  simpa using not_imp_not.2 cof_type_le\n#align lt_cof_type lt_cof_type\n\n",
 "lt_cof_power":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.pow -/\ntheorem lt_cof_power {a b : cardinal} (ha : cardinal.aleph_0 ‚â§ a) (b1 : 1 < b) : a < cof (cardinal.pow b a).ord :=\n  by\n  have b0 : b ‚â† 0 := (zero_lt_one.trans b1).ne'\n  apply lt_imp_lt_of_le_imp_le (power_le_power_left <| power_ne_zero a b0)\n  rw [‚Üê power_mul, mul_eq_self ha]\n  exact lt_power_cof (ha.trans <| (cantor' _ b1).le)\n#align lt_cof_power lt_cof_power\n\n",
 "lsub_lt_ord_of_is_regular":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem lsub_lt_ord_of_is_regular {Œπ} {f : Œπ ‚Üí ordinal} {c} (hc : is_regular c) (hŒπ : cardinal.mk Œπ < c) :\n    (‚àÄ i, f i < c.ord) ‚Üí ordinal.lsub f < c.ord :=\n  lsub_lt_ord (by rwa [hc.cof_eq])\n#align lsub_lt_ord_of_is_regular lsub_lt_ord_of_is_regular\n\n",
 "lsub_lt_ord_lift_of_is_regular":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem lsub_lt_ord_lift_of_is_regular {Œπ} {f : Œπ ‚Üí ordinal} {c} (hc : is_regular c)\n    (hŒπ : cardinal.lift (cardinal.mk Œπ) < c) : (‚àÄ i, f i < c.ord) ‚Üí ordinal.lsub f < c.ord :=\n  lsub_lt_ord_lift (by rwa [hc.cof_eq])\n#align lsub_lt_ord_lift_of_is_regular lsub_lt_ord_lift_of_is_regular\n\n",
 "lsub_lt_ord_lift":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem lsub_lt_ord_lift {Œπ} {f : Œπ ‚Üí ordinal} {c : ordinal} (hŒπ : cardinal.lift (cardinal.mk Œπ) < c.cof)\n    (hf : ‚àÄ i, f i < c) : lsub.{u, v} f < c :=\n  lt_of_le_of_ne (lsub_le hf) fun h => by\n    subst h\n    exact (cof_lsub_le_lift f).not_lt hŒπ\n#align lsub_lt_ord_lift lsub_lt_ord_lift\n\n",
 "lsub_lt_ord":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem lsub_lt_ord {Œπ} {f : Œπ ‚Üí ordinal} {c : ordinal} (hŒπ : cardinal.mk Œπ < c.cof) :\n    (‚àÄ i, f i < c) ‚Üí lsub.{u, u} f < c :=\n  lsub_lt_ord_lift (by rwa [(cardinal.mk Œπ).lift_id])\n#align lsub_lt_ord lsub_lt_ord\n\n",
 "lift_cof":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚Åª¬π' ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚Åª¬π' ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n@[simp]\ntheorem lift_cof (o) : (cof o).lift = cof o.lift :=\n  by\n  refine' induction_on o _\n  intro Œ± r _\n  apply le_antisymm\n  ¬∑ refine' le_cof_type.2 fun S H => _\n    have : (cardinal.mk (¬´expr ‚Åª¬π' ¬ª ulift.up S)).lift ‚â§ cardinal.mk S :=\n      by\n      rw [‚Üê cardinal.lift_umax, ‚Üê cardinal.lift_id' (cardinal.mk S)]\n      exact mk_preimage_of_injective_lift ulift.up _ ULift.up_injective\n    refine' (cardinal.lift_le.2 <| cof_type_le _).trans this\n    exact fun a =>\n      let ‚ü®‚ü®b‚ü©, bs, br‚ü© := H ‚ü®a‚ü©\n      ‚ü®b, bs, br‚ü©\n  ¬∑ rcases cof_eq r with ‚ü®S, H, e'‚ü©\n    have : cardinal.mk (¬´expr ‚Åª¬π' ¬ª ulift.down S) ‚â§ (cardinal.mk S).lift :=\n      ‚ü®‚ü®fun ‚ü®‚ü®x‚ü©, h‚ü© => ‚ü®‚ü®x, h‚ü©‚ü©, fun ‚ü®‚ü®x‚ü©, h‚ÇÅ‚ü© ‚ü®‚ü®y‚ü©, h‚ÇÇ‚ü© e => by simp at e <;> congr <;> injections‚ü©‚ü©\n    rw [e'] at this\n    refine' (cof_type_le _).trans this\n    exact fun ‚ü®a‚ü© =>\n      let ‚ü®b, bs, br‚ü© := H a\n      ‚ü®‚ü®b‚ü©, bs, br‚ü©\n#align lift_cof lift_cof\n\n",
 "le_range_of_union_finset_eq_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚Åª¬π' ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚ãÉ , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚ãÉ , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚ä§¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/-- If an infinite type `Œ≤` can be expressed as a union of finite sets,\nthen the cardinality of the collection of those finite sets\nmust be at least the cardinality of `Œ≤`.\n-/\ntheorem le_range_of_union_finset_eq_top {Œ± Œ≤ : Type _} [Infinite Œ≤] (f : Œ± ‚Üí Finset Œ≤)\n    (w :\n      ¬´expr‚ãÉ , ¬ª \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚ãÉ , ¬ª\" (f a : set Œ≤) =\n        ¬´expr‚ä§¬ª) :\n    cardinal.mk Œ≤ ‚â§ cardinal.mk (range f) :=\n  by\n  have k : _root_.infinite (range f) := by\n    rw [infinite_coe_iff]\n    apply mt (union_finset_finite_of_range_finite f)\n    rw [w]\n    exact infinite_univ\n  by_contra h\n  simp only [not_le] at h\n  let u : ‚àÄ b, ‚àÉ a, b ‚àà f a := fun b => by simpa using (w.ge : _) (Set.mem_univ b)\n  let u' : Œ≤ ‚Üí range f := fun b => ‚ü®f (u b).some, by simp‚ü©\n  have v' : ‚àÄ a, ¬´expr ‚Åª¬π' ¬ª u' {‚ü®f a, by simp‚ü©} ‚â§ f a :=\n    by\n    rintro a p m\n    simp at m\n    rw [‚Üê m]\n    apply fun b => (u b).some_spec\n  obtain ‚ü®‚ü®-, ‚ü®a, rfl‚ü©‚ü©, p‚ü© := exists_infinite_fiber u' h k\n  exact (@infinite.of_injective _ _ p (inclusion (v' a)) (inclusion_injective _)).false\n#align le_range_of_union_finset_eq_top le_range_of_union_finset_eq_top\n\n",
 "le_cof_type":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem le_cof_type [is_well_order Œ± r] {c} : c ‚â§ cof (type r) ‚Üî ‚àÄ S, unbounded r S ‚Üí c ‚â§ cardinal.mk S :=\n  (le_cinf‚Çõ_iff'' (strict_order.cof_nonempty r)).trans\n    ‚ü®fun H S h => H _ ‚ü®S, h, rfl‚ü©, by\n      rintro H d ‚ü®S, h, rfl‚ü©\n      exact H _ h‚ü©\n#align le_cof_type le_cof_type\n\n",
 "le_cof_iff_lsub":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem le_cof_iff_lsub {o : ordinal} {a : cardinal} :\n    a ‚â§ cof o ‚Üî ‚àÄ {Œπ} (f : Œπ ‚Üí ordinal), lsub.{u, u} f = o ‚Üí a ‚â§ cardinal.mk Œπ :=\n  by\n  rw [cof_eq_Inf_lsub]\n  exact\n    (le_cinf‚Çõ_iff'' (cof_lsub_def_nonempty o)).trans\n      ‚ü®fun H Œπ f hf => H _ ‚ü®Œπ, f, hf, rfl‚ü©, fun H b ‚ü®Œπ, f, hf, hb‚ü© =>\n        by\n        rw [‚Üê hb]\n        exact H _ hf‚ü©\n#align le_cof_iff_lsub le_cof_iff_lsub\n\n",
 "le_cof_iff_blsub":
 "theorem le_cof_iff_blsub {b : ordinal} {a : cardinal} :\n    a ‚â§ cof b ‚Üî ‚àÄ {o} (f : ‚àÄ a < o, ordinal), blsub.{u, u} o f = b ‚Üí a ‚â§ o.card :=\n  le_cof_iff_lsub.trans\n    ‚ü®fun H o f hf => by simpa using H _ hf, fun H Œπ f hf =>\n      by\n      rcases cardinal.ord_eq Œπ with ‚ü®r, hr, hŒπ'‚ü©\n      rw [‚Üê @blsub_eq_lsub' Œπ r hr] at hf\n      simpa using H _ hf‚ü©\n#align le_cof_iff_blsub le_cof_iff_blsub\n\n",
 "le_cof":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem le_cof {r : Œ± ‚Üí Œ± ‚Üí Prop} [is_refl Œ± r] (c : cardinal) :\n    c ‚â§ cof r ‚Üî ‚àÄ {S : set Œ±}, (‚àÄ a, ‚àÉ b ‚àà S, r a b) ‚Üí c ‚â§ cardinal.mk S :=\n  by\n  rw [cof, le_cinf‚Çõ_iff'' (cof_nonempty r)]\n  use fun H S h => H _ ‚ü®S, h, rfl‚ü©\n  rintro H d ‚ü®S, h, rfl‚ü©\n  exact H h\n#align le_cof le_cof\n\n",
 "is_strong_limit_beth":
 "theorem is_strong_limit_beth {o : ordinal} (H : ‚àÄ a < o, succ a < o) : is_strong_limit (beth o) :=\n  by\n  rcases eq_or_ne o 0 with (rfl | h)\n  ¬∑ rw [beth_zero]\n    exact is_strong_limit_aleph_0\n  ¬∑ refine' ‚ü®beth_ne_zero o, fun a ha => _‚ü©\n    rw [beth_limit ‚ü®h, H‚ü©] at ha\n    rcases exists_lt_of_lt_csup·µ¢' ha with ‚ü®‚ü®i, hi‚ü©, ha‚ü©\n    have := power_le_power_left two_ne_zero ha.le\n    rw [‚Üê beth_succ] at this\n    exact this.trans_lt (beth_lt.2 (H i hi))\n#align is_strong_limit_beth is_strong_limit_beth\n\n",
 "is_strong_limit_aleph_0":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\ntheorem is_strong_limit_aleph_0 : is_strong_limit (cardinal.aleph_0) :=\n  ‚ü®aleph_0_ne_zero, fun x hx => by\n    rcases lt_aleph_0.1 hx with ‚ü®n, rfl‚ü©\n    exact_mod_cast nat_lt_aleph_0 (pow 2 n)‚ü©\n#align is_strong_limit_aleph_0 is_strong_limit_aleph_0\n\n",
 "is_regular_succ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\ntheorem is_regular_succ {c : cardinal.{u}} (h : cardinal.aleph_0 ‚â§ c) : is_regular (succ c) :=\n  ‚ü®h.trans (le_succ c),\n    succ_le_of_lt\n      (by\n        cases' quotient.exists_rep (@succ cardinal _ _ c) with Œ± Œ±e; simp at Œ±e\n        rcases ord_eq Œ± with ‚ü®r, wo, re‚ü©; skip\n        have := ord_is_limit (h.trans (le_succ _))\n        rw [‚Üê Œ±e, re] at this‚ä¢\n        rcases cof_eq' r this with ‚ü®S, H, Se‚ü©\n        rw [‚Üê Se]\n        apply lt_imp_lt_of_le_imp_le fun h => mul_le_mul_right' h c\n        rw [mul_eq_self h, ‚Üê succ_le_iff, ‚Üê Œ±e, ‚Üê sum_const']\n        refine' le_trans _ (sum_le_sum (fun x => card (typein r x)) _ fun i => _)\n        ¬∑ simp only [‚Üê card_typein, ‚Üê mk_sigma]\n          exact\n            ‚ü®embedding.of_surjective (fun x => x.2.1) fun a =>\n                let ‚ü®b, h, ab‚ü© := H a\n                ‚ü®‚ü®‚ü®_, h‚ü©, _, ab‚ü©, rfl‚ü©‚ü©\n        ¬∑ rw [‚Üê lt_succ_iff, ‚Üê lt_ord, ‚Üê Œ±e, re]\n          apply typein_lt_type)‚ü©\n#align is_regular_succ is_regular_succ\n\n",
 "is_regular_cof":
 "theorem is_regular_cof {o : ordinal} (h : o.is_limit) : is_regular o.cof :=\n  ‚ü®aleph_0_le_cof.2 h, (cof_cof o).ge‚ü©\n#align is_regular_cof is_regular_cof\n\n",
 "is_regular_aleph_succ":
 "theorem is_regular_aleph_succ (o : ordinal) : is_regular (aleph (succ o)) :=\n  by\n  rw [aleph_succ]\n  exact is_regular_succ (aleph_0_le_aleph o)\n#align is_regular_aleph_succ is_regular_aleph_succ\n\n",
 "is_regular_aleph_one":
 "theorem is_regular_aleph_one : is_regular (aleph 1) :=\n  by\n  rw [‚Üê succ_aleph_0]\n  exact is_regular_succ le_rfl\n#align is_regular_aleph_one is_regular_aleph_one\n\n",
 "is_regular_aleph_0":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\ntheorem is_regular_aleph_0 : is_regular (cardinal.aleph_0) :=\n  ‚ü®le_rfl, by simp‚ü©\n#align is_regular_aleph_0 is_regular_aleph_0\n\n",
 "is_regular_aleph'_succ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.omega -/\ntheorem is_regular_aleph'_succ {o : ordinal} (h : ordinal.omega ‚â§ o) : is_regular (aleph' (succ o)) :=\n  by\n  rw [aleph'_succ]\n  exact is_regular_succ (aleph_0_le_aleph'.2 h)\n#align is_regular_aleph'_succ is_regular_aleph'_succ\n\n",
 "is_limit_aleph_0":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\ntheorem is_limit_aleph_0 : is_limit (cardinal.aleph_0) :=\n  is_strong_limit_aleph_0.is_limit\n#align is_limit_aleph_0 is_limit_aleph_0\n\n",
 "is_limit":
 "theorem is_strong_limit.is_limit {c} (H : is_strong_limit c) : is_limit c :=\n  ‚ü®H.1, fun x h => (succ_le_of_lt <| cantor x).trans_lt (H.2 _ h)‚ü©\n#align is_strong_limit.is_limit is_strong_limit.is_limit\n\n",
 "is_fundamental_sequence":
 "protected theorem is_normal.is_fundamental_sequence {f : ordinal.{u} ‚Üí ordinal.{u}} (hf : is_normal f) {a o}\n    (ha : is_limit a) {g} (hg : is_fundamental_sequence a o g) :\n    is_fundamental_sequence (f a) o fun b hb => f (g b hb) :=\n  by\n  refine' ‚ü®_, fun i j _ _ h => hf.strict_mono (hg.2.1 _ _ h), _‚ü©\n  ¬∑ rcases exists_lsub_cof (f a) with ‚ü®Œπ, f', hf', hŒπ‚ü©\n    rw [‚Üê hg.cof_eq, ord_le_ord, ‚Üê hŒπ]\n    suffices (lsub.{u, u} fun i => Inf { b : ordinal | f' i ‚â§ f b }) = a\n      by\n      rw [‚Üê this]\n      apply cof_lsub_le\n    have H : ‚àÄ i, ‚àÉ b < a, f' i ‚â§ f b := fun i =>\n      by\n      have := lt_lsub.{u, u} f' i\n      rwa [hf', ‚Üê is_normal.blsub_eq.{u, u} hf ha, lt_blsub_iff] at this\n    refine' (lsub_le fun i => _).antisymm (le_of_forall_lt fun b hb => _)\n    ¬∑ rcases H i with ‚ü®b, hb, hb'‚ü©\n      exact lt_of_le_of_lt (cinf‚Çõ_le' hb') hb\n    ¬∑ have := hf.strict_mono hb\n      rw [‚Üê hf', lt_lsub_iff] at this\n      cases' this with i hi\n      rcases H i with ‚ü®b, _, hb‚ü©\n      exact ((le_cinf‚Çõ_iff'' ‚ü®b, hb‚ü©).2 fun c hc => hf.strict_mono.le_iff_le.1 (hi.trans hc)).trans_lt (lt_lsub _ i)\n  ¬∑ rw [@blsub_comp.{u, u, u} a _ (fun b _ => f b) (fun i j hi hj h => hf.strict_mono.monotone h) g hg.2.2]\n    exact is_normal.blsub_eq.{u, u} hf ha\n#align is_normal.is_fundamental_sequence is_normal.is_fundamental_sequence\n\n",
 "infinite_pigeonhole_set":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem infinite_pigeonhole_set {Œ≤ Œ± : Type u} {s : set Œ≤} (f : s ‚Üí Œ±) (Œ∏ : cardinal) (hŒ∏ : Œ∏ ‚â§ cardinal.mk s)\n    (h‚ÇÅ : cardinal.aleph_0 ‚â§ Œ∏) (h‚ÇÇ : cardinal.mk Œ± < Œ∏.ord.cof) :\n    ‚àÉ (a : Œ±)(t : set Œ≤)(h : t ‚äÜ s), Œ∏ ‚â§ cardinal.mk t ‚àß ‚àÄ ‚¶Éx‚¶Ñ (hx : x ‚àà t), f ‚ü®x, h hx‚ü© = a :=\n  by\n  cases' infinite_pigeonhole_card f Œ∏ hŒ∏ h‚ÇÅ h‚ÇÇ with a ha\n  refine' ‚ü®a, { x | ‚àÉ h, f ‚ü®x, h‚ü© = a }, _, _, _‚ü©\n  ¬∑ rintro x ‚ü®hx, hx'‚ü©\n    exact hx\n  ¬∑ refine' ha.trans (ge_of_eq <| quotient.sound ‚ü®equiv.trans _ (Equiv.subtypeSubtypeEquivSubtypeExists _ _).symm‚ü©)\n    simp only [coe_eq_subtype, mem_singleton_iff, mem_preimage, mem_set_of_eq]\n  rintro x ‚ü®hx, hx'‚ü©; exact hx'\n#align infinite_pigeonhole_set infinite_pigeonhole_set\n\n",
 "infinite_pigeonhole_card_lt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚Åª¬π' ¬ª -/\n/-- A function whose codomain's cardinality is infinite but strictly smaller than its domain's\nhas a fiber with cardinality strictly great than the codomain.\n-/\ntheorem infinite_pigeonhole_card_lt {Œ≤ Œ± : Type u} (f : Œ≤ ‚Üí Œ±) (w : cardinal.mk Œ± < cardinal.mk Œ≤)\n    (w' : cardinal.aleph_0 ‚â§ cardinal.mk Œ±) : ‚àÉ a : Œ±, cardinal.mk Œ± < cardinal.mk (¬´expr ‚Åª¬π' ¬ª f {a}) :=\n  by\n  simp_rw [‚Üê succ_le_iff]\n  exact\n    ordinal.infinite_pigeonhole_card f (succ (cardinal.mk Œ±)) (succ_le_of_lt w) (w'.trans (lt_succ _).le)\n      ((lt_succ _).trans_le (is_regular_succ w').2.ge)\n#align infinite_pigeonhole_card_lt infinite_pigeonhole_card_lt\n\n",
 "infinite_pigeonhole_card":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚Åª¬π' ¬ª -/\n/-- Pigeonhole principle for a cardinality below the cardinality of the domain -/\ntheorem infinite_pigeonhole_card {Œ≤ Œ± : Type u} (f : Œ≤ ‚Üí Œ±) (Œ∏ : cardinal) (hŒ∏ : Œ∏ ‚â§ cardinal.mk Œ≤)\n    (h‚ÇÅ : cardinal.aleph_0 ‚â§ Œ∏) (h‚ÇÇ : cardinal.mk Œ± < Œ∏.ord.cof) : ‚àÉ a : Œ±, Œ∏ ‚â§ cardinal.mk (¬´expr ‚Åª¬π' ¬ª f {a}) :=\n  by\n  rcases le_mk_iff_exists_set.1 hŒ∏ with ‚ü®s, rfl‚ü©\n  cases' infinite_pigeonhole (f ‚àò subtype.val : s ‚Üí Œ±) h‚ÇÅ h‚ÇÇ with a ha\n  use a; rw [‚Üê ha, @preimage_comp _ _ _ subtype.val f]\n  exact mk_preimage_of_injective _ _ subtype.val_injective\n#align infinite_pigeonhole_card infinite_pigeonhole_card\n\n",
 "infinite_pigeonhole":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚Åª¬π' ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚Åª¬π' ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/-- The infinite pigeonhole principle -/\ntheorem infinite_pigeonhole {Œ≤ Œ± : Type u} (f : Œ≤ ‚Üí Œ±) (h‚ÇÅ : cardinal.aleph_0 ‚â§ cardinal.mk Œ≤)\n    (h‚ÇÇ : cardinal.mk Œ± < (cardinal.mk Œ≤).ord.cof) : ‚àÉ a : Œ±, cardinal.mk (¬´expr ‚Åª¬π' ¬ª f {a}) = cardinal.mk Œ≤ :=\n  by\n  have : ‚àÉ a, cardinal.mk Œ≤ ‚â§ cardinal.mk (¬´expr ‚Åª¬π' ¬ª f {a}) :=\n    by\n    by_contra' h\n    apply mk_univ.not_lt\n    rw [‚Üê preimage_univ, ‚Üê Union_of_singleton, preimage_Union]\n    exact\n      mk_Union_le_sum_mk.trans_lt\n        ((sum_le_supr _).trans_lt <| mul_lt_of_lt h‚ÇÅ (h‚ÇÇ.trans_le <| cof_ord_le _) (supr_lt h‚ÇÇ h))\n  cases' this with x h\n  refine' ‚ü®x, h.antisymm' _‚ü©\n  rw [le_mk_iff_exists_set]\n  exact ‚ü®_, rfl‚ü©\n#align infinite_pigeonhole infinite_pigeonhole\n\n",
 "id_of_le_cof":
 "theorem id_of_le_cof (h : o ‚â§ o.cof.ord) : is_fundamental_sequence o o fun a _ => a :=\n  ‚ü®h, fun _ _ _ _ => id, blsub_id o‚ü©\n#align id_of_le_cof id_of_le_cof\n\n",
 "exists_lsub_cof":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem exists_lsub_cof (o : ordinal) : ‚àÉ (Œπ : _)(f : Œπ ‚Üí ordinal), lsub.{u, u} f = o ‚àß cardinal.mk Œπ = cof o :=\n  by\n  rw [cof_eq_Inf_lsub]\n  exact cinf‚Çõ_mem (cof_lsub_def_nonempty o)\n#align exists_lsub_cof exists_lsub_cof\n\n",
 "exists_infinite_fiber":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚Åª¬π' ¬ª -/\n/-- A function whose codomain's cardinality is infinite but strictly smaller than its domain's\nhas an infinite fiber.\n-/\ntheorem exists_infinite_fiber {Œ≤ Œ± : Type _} (f : Œ≤ ‚Üí Œ±) (w : cardinal.mk Œ± < cardinal.mk Œ≤) (w' : Infinite Œ±) :\n    ‚àÉ a : Œ±, Infinite (¬´expr ‚Åª¬π' ¬ª f {a}) :=\n  by\n  simp_rw [cardinal.infinite_iff] at w'‚ä¢\n  cases' infinite_pigeonhole_card_lt f w w' with a ha\n  exact ‚ü®a, w'.trans ha.le‚ü©\n#align exists_infinite_fiber exists_infinite_fiber\n\n",
 "exists_fundamental_sequence":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚Ü™r ¬ª -/\n/-- Every ordinal has a fundamental sequence. -/\ntheorem exists_fundamental_sequence (a : ordinal.{u}) : ‚àÉ f, is_fundamental_sequence a a.cof.ord f :=\n  by\n  rsuffices ‚ü®o, f, hf‚ü© : ‚àÉ o f, is_fundamental_sequence a o f\n  ¬∑ exact ‚ü®_, hf.ord_cof‚ü©\n  rcases exists_lsub_cof a with ‚ü®Œπ, f, hf, hŒπ‚ü©\n  rcases ord_eq Œπ with ‚ü®r, wo, hr‚ü©\n  haveI := wo\n  let r' := Subrel r { i | ‚àÄ j, r j i ‚Üí f j < f i }\n  let hrr' : ¬´expr ‚Ü™r ¬ª r' r := Subrel.relEmbedding _ _\n  haveI := hrr'.is_well_order\n  refine'\n    ‚ü®_, _, hrr'.ordinal_type_le.trans _, fun i j _ h _ => (enum r' j h).prop _ _,\n      le_antisymm (blsub_le fun i hi => lsub_le_iff.1 hf.le _) _‚ü©\n  ¬∑ rw [‚Üê hŒπ, hr]\n  ¬∑ change r (hrr'.1 _) (hrr'.1 _)\n    rwa [hrr'.2, @enum_lt_enum _ r']\n  ¬∑ rw [‚Üê hf, lsub_le_iff]\n    intro i\n    rsuffices ‚ü®i', hi', hfg‚ü© : ‚àÉ i' hi', f i ‚â§ bfamily_of_family' r' (fun i => f i) i' hi'\n    ¬∑ exact hfg.trans_lt (lt_blsub _ _ _)\n    by_cases h : ‚àÄ j, r j i ‚Üí f j < f i\n    ¬∑ refine' ‚ü®typein r' ‚ü®i, h‚ü©, typein_lt_type _ _, _‚ü©\n      rw [bfamily_of_family'_typein]\n      rfl\n    ¬∑ push_neg  at h\n      cases' wo.wf.min_mem _ h with hji hij\n      refine' ‚ü®typein r' ‚ü®_, fun k hkj => lt_of_lt_of_le _ hij‚ü©, typein_lt_type _ _, _‚ü©\n      ¬∑ by_contra' H\n        exact (wo.wf.not_lt_min _ h ‚ü®is_trans.trans _ _ _ hkj hji, H‚ü©) hkj\n      ¬∑ rwa [bfamily_of_family'_typein]\n#align exists_fundamental_sequence exists_fundamental_sequence\n\n",
 "exists_blsub_cof":
 "theorem exists_blsub_cof (o : ordinal) : ‚àÉ f : ‚àÄ a < (cof o).ord, ordinal, blsub.{u, u} _ f = o :=\n  by\n  rcases exists_lsub_cof o with ‚ü®Œπ, f, hf, hŒπ‚ü©\n  rcases cardinal.ord_eq Œπ with ‚ü®r, hr, hŒπ'‚ü©\n  rw [‚Üê @blsub_eq_lsub' Œπ r hr] at hf\n  rw [‚Üê hŒπ, hŒπ']\n  exact ‚ü®_, hf‚ü©\n#align exists_blsub_cof exists_blsub_cof\n\n",
 "deriv_lt_ord":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\ntheorem deriv_lt_ord {f : ordinal.{u} ‚Üí ordinal} {c} (hc : is_regular c) (hc' : c ‚â† cardinal.aleph_0)\n    (hf : ‚àÄ i < c.ord, f i < c.ord) {a} : a < c.ord ‚Üí deriv f a < c.ord :=\n  deriv_family_lt_ord_lift hc (by simpa using cardinal.one_lt_aleph_0.trans (lt_of_le_of_ne hc.1 hc'.symm)) hc' fun _ =>\n    hf\n#align deriv_lt_ord deriv_lt_ord\n\n",
 "deriv_family_lt_ord_lift":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\ntheorem deriv_family_lt_ord_lift {Œπ} {f : Œπ ‚Üí ordinal ‚Üí ordinal} {c} (hc : is_regular c) (hŒπ : (cardinal.mk Œπ).lift < c)\n    (hc' : c ‚â† cardinal.aleph_0) (hf : ‚àÄ (i), ‚àÄ b < c.ord, f i b < c.ord) {a} :\n    a < c.ord ‚Üí deriv_family.{u, v} f a < c.ord :=\n  by\n  have hœâ : cardinal.aleph_0 < c.ord.cof := by\n    rw [hc.cof_eq]\n    exact lt_of_le_of_ne hc.1 hc'.symm\n  apply a.limit_rec_on\n  ¬∑ rw [deriv_family_zero]\n    exact nfp_family_lt_ord_lift hœâ (by rwa [hc.cof_eq]) hf\n  ¬∑ intro b hb hb'\n    rw [deriv_family_succ]\n    exact nfp_family_lt_ord_lift hœâ (by rwa [hc.cof_eq]) hf ((ord_is_limit hc.1).2 _ (hb ((lt_succ b).trans hb')))\n  ¬∑ intro b hb H hb'\n    rw [deriv_family_limit f hb]\n    exact\n      bsup_lt_ord_of_is_regular hc (ord_lt_ord.1 ((ord_card_le b).trans_lt hb')) fun o' ho' => H o' ho' (ho'.trans hb')\n#align deriv_family_lt_ord_lift deriv_family_lt_ord_lift\n\n",
 "deriv_family_lt_ord":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\ntheorem deriv_family_lt_ord {Œπ} {f : Œπ ‚Üí ordinal ‚Üí ordinal} {c} (hc : is_regular c) (hŒπ : cardinal.mk Œπ < c)\n    (hc' : c ‚â† cardinal.aleph_0) (hf : ‚àÄ (i), ‚àÄ b < c.ord, f i b < c.ord) {a} :\n    a < c.ord ‚Üí deriv_family.{u, u} f a < c.ord :=\n  deriv_family_lt_ord_lift hc (by rwa [lift_id]) hc' hf\n#align deriv_family_lt_ord deriv_family_lt_ord\n\n",
 "deriv_bfamily_lt_ord_lift":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\ntheorem deriv_bfamily_lt_ord_lift {o : ordinal} {f : ‚àÄ a < o, ordinal ‚Üí ordinal} {c} (hc : is_regular c)\n    (hŒπ : o.card.lift < c) (hc' : c ‚â† cardinal.aleph_0) (hf : ‚àÄ (i hi), ‚àÄ b < c.ord, f i hi b < c.ord) {a} :\n    a < c.ord ‚Üí deriv_bfamily.{u, v} o f a < c.ord :=\n  deriv_family_lt_ord_lift hc (by rwa [mk_ordinal_out]) hc' fun i => hf _ _\n#align deriv_bfamily_lt_ord_lift deriv_bfamily_lt_ord_lift\n\n",
 "deriv_bfamily_lt_ord":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\ntheorem deriv_bfamily_lt_ord {o : ordinal} {f : ‚àÄ a < o, ordinal ‚Üí ordinal} {c} (hc : is_regular c) (hŒπ : o.card < c)\n    (hc' : c ‚â† cardinal.aleph_0) (hf : ‚àÄ (i hi), ‚àÄ b < c.ord, f i hi b < c.ord) {a} :\n    a < c.ord ‚Üí deriv_bfamily.{u, u} o f a < c.ord :=\n  deriv_bfamily_lt_ord_lift hc (by rwa [lift_id]) hc' hf\n#align deriv_bfamily_lt_ord deriv_bfamily_lt_ord\n\n",
 "cof_zero":
 "@[simp]\ntheorem cof_zero : cof 0 = 0 :=\n  (cof_le_card 0).antisymm (cardinal.zero_le _)\n#align cof_zero cof_zero\n\n",
 "cof_univ":
 "@[simp]\ntheorem cof_univ : cof univ.{u, v} = cardinal.univ :=\n  le_antisymm (cof_le_card _)\n    (by\n      refine' le_of_forall_lt fun c h => _\n      rcases lt_univ'.1 h with ‚ü®c, rfl‚ü©\n      rcases@cof_eq ordinal.{u} (¬∑ < ¬∑) _ with ‚ü®S, H, Se‚ü©\n      rw [univ, ‚Üê lift_cof, ‚Üê cardinal.lift_lift, cardinal.lift_lt, ‚Üê Se]\n      refine' lt_of_not_ge fun h => _\n      cases' cardinal.lift_down h with a e\n      refine' Quotient.inductionOn a (fun Œ± e => _) e\n      cases' quotient.exact e with f\n      have f := equiv.ulift.symm.trans f\n      let g a := (f a).1\n      let o := succ (sup.{u, u} g)\n      rcases H o with ‚ü®b, h, l‚ü©\n      refine' l (lt_succ_iff.2 _)\n      rw [‚Üê show g (f.symm ‚ü®b, h‚ü©) = b by dsimp [g] <;> simp]\n      apply le_sup)\n#align cof_univ cof_univ\n\n",
 "cof_type_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem cof_type_le [is_well_order Œ± r] {S : set Œ±} (h : unbounded r S) : cof (type r) ‚â§ cardinal.mk S :=\n  le_cof_type.1 le_rfl S h\n#align cof_type_le cof_type_le\n\n",
 "cof_type":
 "theorem cof_type (r : Œ± ‚Üí Œ± ‚Üí Prop) [is_well_order Œ± r] : (type r).cof = strict_order.cof r :=\n  rfl\n#align cof_type cof_type\n\n",
 "cof_sup_le_lift":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem cof_sup_le_lift {Œπ} {f : Œπ ‚Üí ordinal} (H : ‚àÄ i, f i < sup f) : cof (sup f) ‚â§ (cardinal.mk Œπ).lift :=\n  by\n  rw [‚Üê sup_eq_lsub_iff_lt_sup] at H\n  rw [H]\n  exact cof_lsub_le_lift f\n#align cof_sup_le_lift cof_sup_le_lift\n\n",
 "cof_sup_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem cof_sup_le {Œπ} {f : Œπ ‚Üí ordinal} (H : ‚àÄ i, f i < sup.{u, u} f) : cof (sup.{u, u} f) ‚â§ cardinal.mk Œπ :=\n  by\n  rw [‚Üê (cardinal.mk Œπ).lift_id]\n  exact cof_sup_le_lift H\n#align cof_sup_le cof_sup_le\n\n",
 "cof_succ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n@[simp]\ntheorem cof_succ (o) : cof (succ o) = 1 := by\n  apply le_antisymm\n  ¬∑ refine' induction_on o fun Œ± r _ => _\n    change cof (type _) ‚â§ _\n    rw [‚Üê (_ : cardinal.mk _ = 1)]\n    apply cof_type_le\n    ¬∑ refine' fun a => ‚ü®sum.inr PUnit.unit, Set.mem_singleton _, _‚ü©\n      rcases a with (a | ‚ü®‚ü®‚ü®‚ü©‚ü©‚ü©) <;> simp [empty_relation]\n    ¬∑ rw [cardinal.mk_fintype, set.card_singleton]\n      simp\n  ¬∑ rw [‚Üê cardinal.succ_zero, succ_le_iff]\n    simpa [lt_iff_le_and_ne, cardinal.zero_le] using fun h => succ_ne_zero o (cof_eq_zero.1 (eq.symm h))\n#align cof_succ cof_succ\n\n",
 "cof_ord_le":
 "theorem cof_ord_le (c : cardinal) : c.ord.cof ‚â§ c := by simpa using cof_le_card c.ord\n#align cof_ord_le cof_ord_le\n\n",
 "cof_omega":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.omega -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n@[simp]\ntheorem cof_omega : cof (ordinal.omega) = cardinal.aleph_0 :=\n  (aleph_0_le_cof.2 omega_is_limit).antisymm' <| by\n    rw [‚Üê card_omega]\n    apply cof_le_card\n#align cof_omega cof_omega\n\n",
 "cof_nonempty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ·∂ú¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/-- The set in the definition of `order.strict_order.cof` is nonempty. -/\ntheorem strict_order.cof_nonempty (r : Œ± ‚Üí Œ± ‚Üí Prop) [is_irrefl Œ± r] :\n    { c | ‚àÉ S : set Œ±, unbounded r S ‚àß cardinal.mk S = c }.nonempty :=\n  @order.cof_nonempty Œ± _ (is_refl.swap (¬´expr ·∂ú¬ª r))\n#align strict_order.cof_nonempty strict_order.cof_nonempty\n\n",
 "cof_ne_zero":
 "theorem cof_ne_zero {o} : cof o ‚â† 0 ‚Üî o ‚â† 0 :=\n  cof_eq_zero.not\n#align cof_ne_zero cof_ne_zero\n\n",
 "cof_lsub_le_lift":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem cof_lsub_le_lift {Œπ} (f : Œπ ‚Üí ordinal) : cof (lsub f) ‚â§ cardinal.lift.{v, u} (cardinal.mk Œπ) :=\n  by\n  rw [‚Üê mk_ulift]\n  convert cof_lsub_le fun i : ULift Œπ => f i.down\n  exact\n    lsub_eq_of_range_eq.{u, max u v, max u v}\n      (Set.ext fun x => ‚ü®fun ‚ü®i, hi‚ü© => ‚ü®ulift.up i, hi‚ü©, fun ‚ü®i, hi‚ü© => ‚ü®_, hi‚ü©‚ü©)\n#align cof_lsub_le_lift cof_lsub_le_lift\n\n",
 "cof_lsub_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem cof_lsub_le {Œπ} (f : Œπ ‚Üí ordinal) : cof (lsub.{u, u} f) ‚â§ cardinal.mk Œπ :=\n  by\n  rw [cof_eq_Inf_lsub]\n  exact cinf‚Çõ_le' ‚ü®Œπ, f, rfl, rfl‚ü©\n#align cof_lsub_le cof_lsub_le\n\n",
 "cof_lsub_def_nonempty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/-- The set in the `lsub` characterization of `cof` is nonempty. -/\ntheorem cof_lsub_def_nonempty (o) :\n    { a : cardinal | ‚àÉ (Œπ : _)(f : Œπ ‚Üí ordinal), lsub.{u, u} f = o ‚àß cardinal.mk Œπ = a }.nonempty :=\n  ‚ü®_, card_mem_cof‚ü©\n#align cof_lsub_def_nonempty cof_lsub_def_nonempty\n\n",
 "cof_le_lift":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr '' ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚âÉr ¬ª -/\ntheorem rel_iso.cof_le_lift {Œ± : Type u} {Œ≤ : Type v} {r : Œ± ‚Üí Œ± ‚Üí Prop} {s} [is_refl Œ≤ s] (f : ¬´expr ‚âÉr ¬ª r s) :\n    cardinal.lift.{max u v} (order.cof r) ‚â§ cardinal.lift.{max u v} (order.cof s) :=\n  by\n  rw [order.cof, order.cof, lift_Inf, lift_Inf, le_cinf‚Çõ_iff'' (nonempty_image_iff.2 (order.cof_nonempty s))]\n  rintro - ‚ü®-, ‚ü®u, H, rfl‚ü©, rfl‚ü©\n  apply cinf‚Çõ_le'\n  refine' ‚ü®_, ‚ü®¬´expr '' ¬ª f.symm u, fun a => _, rfl‚ü©, lift_mk_eq.{u, v, max u v}.2 ‚ü®(f.symm.to_equiv.image u).symm‚ü©‚ü©\n  rcases H (f a) with ‚ü®b, hb, hb'‚ü©\n  refine' ‚ü®f.symm b, mem_image_of_mem _ hb, f.map_rel_iff.1 _‚ü©\n  rwa [RelIso.apply_symm_apply]\n#align rel_iso.cof_le_lift rel_iso.cof_le_lift\n\n",
 "cof_le_card":
 "theorem cof_le_card (o) : cof o ‚â§ card o := by\n  rw [cof_eq_Inf_lsub]\n  exact cinf‚Çõ_le' card_mem_cof\n#align cof_le_card cof_le_card\n\n",
 "cof_le":
 "theorem is_normal.cof_le {f} (hf : is_normal f) (a) : cof a ‚â§ cof (f a) :=\n  by\n  rcases zero_or_succ_or_limit a with (rfl | ‚ü®b, rfl‚ü© | ha)\n  ¬∑ rw [cof_zero]\n    exact zero_le _\n  ¬∑ rw [cof_succ, cardinal.one_le_iff_ne_zero, cof_ne_zero, ‚Üê ordinal.pos_iff_ne_zero]\n    exact (ordinal.zero_le (f b)).trans_lt (hf.1 b)\n  ¬∑ rw [hf.cof_eq ha]\n#align is_normal.cof_le is_normal.cof_le\n\n",
 "cof_eq_zero":
 "@[simp]\ntheorem cof_eq_zero {o} : cof o = 0 ‚Üî o = 0 :=\n  ‚ü®induction_on o fun Œ± r _ z =>\n      let ‚ü®S, hl, e‚ü© := cof_eq r\n      type_eq_zero_iff_is_empty.2 <|\n        ‚ü®fun a =>\n          let ‚ü®b, h, _‚ü© := hl a\n          (mk_eq_zero_iff.1 (e.trans z)).elim' ‚ü®_, h‚ü©‚ü©,\n    fun e => by simp [e]‚ü©\n#align cof_eq_zero cof_eq_zero\n\n",
 "cof_eq_one_iff_is_succ":
 "@[simp]\ntheorem cof_eq_one_iff_is_succ {o} : cof.{u} o = 1 ‚Üî ‚àÉ a, o = succ a :=\n  ‚ü®induction_on o fun Œ± r _ z => by\n      skip\n      rcases cof_eq r with ‚ü®S, hl, e‚ü©; rw [z] at e\n      cases' mk_ne_zero_iff.1 (by rw [e] <;> exact one_ne_zero) with a\n      refine'\n        ‚ü®typein r a,\n          eq.symm <| quotient.sound ‚ü®RelIso.ofSurjective (RelEmbedding.ofMonotone _ fun x y => _) fun x => _‚ü©‚ü©\n      ¬∑ apply sum.rec <;> [exact subtype.val, exact fun _ => a]\n      ¬∑ rcases x with (x | ‚ü®‚ü®‚ü®‚ü©‚ü©‚ü©) <;> rcases y with (y | ‚ü®‚ü®‚ü®‚ü©‚ü©‚ü©) <;> simp [Subrel, Order.Preimage, empty_relation]\n        exact x.2\n      ¬∑ suffices r x a ‚à® ‚àÉ b : PUnit, ‚Üëa = x by simpa\n        rcases trichotomous_of r x a with (h | h | h)\n        ¬∑ exact or.inl h\n        ¬∑ exact or.inr ‚ü®PUnit.unit, h.symm‚ü©\n        ¬∑ rcases hl x with ‚ü®a', aS, hn‚ü©\n          rw [(_ : ‚Üëa = a')] at h\n          ¬∑ exact absurd h hn\n          refine' congr_arg subtype.val (_ : a = ‚ü®a', aS‚ü©)\n          haveI := le_one_iff_subsingleton.1 (le_of_eq e)\n          apply subsingleton.elim,\n    fun ‚ü®a, e‚ü© => by simp [e]‚ü©\n#align cof_eq_one_iff_is_succ cof_eq_one_iff_is_succ\n\n",
 "cof_eq_lift":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚âÉr ¬ª -/\ntheorem rel_iso.cof_eq_lift {Œ± : Type u} {Œ≤ : Type v} {r s} [is_refl Œ± r] [is_refl Œ≤ s] (f : ¬´expr ‚âÉr ¬ª r s) :\n    cardinal.lift.{max u v} (order.cof r) = cardinal.lift.{max u v} (order.cof s) :=\n  (rel_iso.cof_le_lift f).antisymm (rel_iso.cof_le_lift f.symm)\n#align rel_iso.cof_eq_lift rel_iso.cof_eq_lift\n\n",
 "cof_eq_Inf_lsub":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚Åª¬π' ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem cof_eq_Inf_lsub (o : ordinal.{u}) :\n    cof o = inf‚Çõ { a : cardinal | ‚àÉ (Œπ : Type u)(f : Œπ ‚Üí ordinal), lsub.{u, u} f = o ‚àß cardinal.mk Œπ = a } :=\n  by\n  refine' le_antisymm (le_cinf‚Çõ (cof_lsub_def_nonempty o) _) (cinf‚Çõ_le' _)\n  ¬∑ rintro a ‚ü®Œπ, f, hf, rfl‚ü©\n    rw [‚Üê type_lt o]\n    refine'\n      (cof_type_le fun a => _).trans\n        (@mk_le_of_injective _ _\n          (fun s : ¬´expr ‚Åª¬π' ¬ª (typein ((¬∑ < ¬∑) : o.out.Œ± ‚Üí o.out.Œ± ‚Üí Prop)) (Set.range f) => Classical.choose s.prop)\n          fun s t hst => by\n          let H := congr_arg f hst\n          rwa [Classical.choose_spec s.prop, Classical.choose_spec t.prop, typein_inj, subtype.coe_inj] at H)\n    have := typein_lt_self a\n    simp_rw [‚Üê hf, lt_lsub_iff] at this\n    cases' this with i hi\n    refine' ‚ü®enum (¬∑ < ¬∑) (f i) _, _, _‚ü©\n    ¬∑ rw [type_lt, ‚Üê hf]\n      apply lt_lsub\n    ¬∑ rw [mem_preimage, typein_enum]\n      exact mem_range_self i\n    ¬∑ rwa [‚Üê typein_le_typein, typein_enum]\n  ¬∑ rcases cof_eq (¬∑ < ¬∑) with ‚ü®S, hS, hS'‚ü©\n    let f : S ‚Üí ordinal := fun s => typein (¬∑ < ¬∑) s.val\n    refine'\n      ‚ü®S, f, le_antisymm (lsub_le fun i => typein_lt_self i) (le_of_forall_lt fun a ha => _), by rwa [type_lt o] at hS'‚ü©\n    rw [‚Üê type_lt o] at ha\n    rcases hS (enum (¬∑ < ¬∑) a ha) with ‚ü®b, hb, hb'‚ü©\n    rw [‚Üê typein_le_typein, typein_enum] at hb'\n    exact hb'.trans_lt (lt_lsub.{u, u} f ‚ü®b, hb‚ü©)\n#align cof_eq_Inf_lsub cof_eq_Inf_lsub\n\n",
 "cof_eq'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem cof_eq' (r : Œ± ‚Üí Œ± ‚Üí Prop) [is_well_order Œ± r] (h : is_limit (type r)) :\n    ‚àÉ S : set Œ±, (‚àÄ a, ‚àÉ b ‚àà S, r a b) ‚àß cardinal.mk S = cof (type r) :=\n  let ‚ü®S, H, e‚ü© := cof_eq r\n  ‚ü®S, fun a =>\n    let a' := enum r _ (h.2 _ (typein_lt_type r a))\n    let ‚ü®b, h, ab‚ü© := H a'\n    ‚ü®b, h,\n      (is_order_connected.conn a b a' <|\n            (typein_lt_typein r).1\n              (by\n                rw [typein_enum]\n                exact lt_succ (typein _ _))).resolve_right\n        ab‚ü©,\n    e‚ü©\n#align cof_eq' cof_eq'\n\n",
 "cof_eq":
 "theorem is_regular.cof_eq {c : cardinal} (H : c.is_regular) : c.ord.cof = c :=\n  (cof_ord_le c).antisymm H.2\n#align is_regular.cof_eq is_regular.cof_eq\n\n",
 "cof_cof":
 "@[simp]\ntheorem cof_cof (a : ordinal.{u}) : cof (cof a).ord = cof a :=\n  by\n  cases' exists_fundamental_sequence a with f hf\n  cases' exists_fundamental_sequence a.cof.ord with g hg\n  exact ord_injective (hf.trans hg).cof_eq.symm\n#align cof_cof cof_cof\n\n",
 "cof_bsup_le_lift":
 "theorem cof_bsup_le_lift {o : ordinal} {f : ‚àÄ a < o, ordinal} (H : ‚àÄ i h, f i h < bsup o f) :\n    cof (bsup o f) ‚â§ o.card.lift := by\n  rw [‚Üê bsup_eq_blsub_iff_lt_bsup] at H\n  rw [H]\n  exact cof_blsub_le_lift f\n#align cof_bsup_le_lift cof_bsup_le_lift\n\n",
 "cof_bsup_le":
 "theorem cof_bsup_le {o : ordinal} {f : ‚àÄ a < o, ordinal} :\n    (‚àÄ i h, f i h < bsup.{u, u} o f) ‚Üí cof (bsup.{u, u} o f) ‚â§ o.card :=\n  by\n  rw [‚Üê o.card.lift_id]\n  exact cof_bsup_le_lift\n#align cof_bsup_le cof_bsup_le\n\n",
 "cof_blsub_le_lift":
 "theorem cof_blsub_le_lift {o} (f : ‚àÄ a < o, ordinal) : cof (blsub o f) ‚â§ cardinal.lift.{v, u} o.card :=\n  by\n  convert cof_lsub_le_lift _\n  exact (mk_ordinal_out o).symm\n#align cof_blsub_le_lift cof_blsub_le_lift\n\n",
 "cof_blsub_le":
 "theorem cof_blsub_le {o} (f : ‚àÄ a < o, ordinal) : cof (blsub.{u, u} o f) ‚â§ o.card :=\n  by\n  rw [‚Üê o.card.lift_id]\n  exact cof_blsub_le_lift f\n#align cof_blsub_le cof_blsub_le\n\n",
 "cof_add":
 "@[simp]\ntheorem cof_add (a b : ordinal) : b ‚â† 0 ‚Üí cof (a + b) = cof b := fun h =>\n  by\n  rcases zero_or_succ_or_limit b with (rfl | ‚ü®c, rfl‚ü© | hb)\n  ¬∑ contradiction\n  ¬∑ rw [add_succ, cof_succ, cof_succ]\n  ¬∑ exact (add_is_normal a).cof_eq hb\n#align cof_add cof_add\n\n",
 "card_mem_cof":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\nprivate theorem card_mem_cof {o} : ‚àÉ (Œπ : _)(f : Œπ ‚Üí ordinal), lsub.{u, u} f = o ‚àß cardinal.mk Œπ = o.card :=\n  ‚ü®_, _, lsub_typein o, mk_ordinal_out o‚ü©\n#align card_mem_cof card_mem_cof\n\n",
 "bsup_lt_ord_of_is_regular":
 "theorem bsup_lt_ord_of_is_regular {o : ordinal} {f : ‚àÄ a < o, ordinal} {c} (hc : is_regular c) (hŒπ : o.card < c) :\n    (‚àÄ i hi, f i hi < c.ord) ‚Üí ordinal.bsup o f < c.ord :=\n  bsup_lt_ord (by rwa [hc.cof_eq])\n#align bsup_lt_ord_of_is_regular bsup_lt_ord_of_is_regular\n\n",
 "bsup_lt_ord_lift_of_is_regular":
 "theorem bsup_lt_ord_lift_of_is_regular {o : ordinal} {f : ‚àÄ a < o, ordinal} {c} (hc : is_regular c)\n    (hŒπ : cardinal.lift o.card < c) : (‚àÄ i hi, f i hi < c.ord) ‚Üí ordinal.bsup o f < c.ord :=\n  bsup_lt_ord_lift (by rwa [hc.cof_eq])\n#align bsup_lt_ord_lift_of_is_regular bsup_lt_ord_lift_of_is_regular\n\n",
 "bsup_lt_ord_lift":
 "theorem bsup_lt_ord_lift {o : ordinal} {f : ‚àÄ a < o, ordinal} {c : ordinal} (ho : o.card.lift < c.cof)\n    (hf : ‚àÄ i hi, f i hi < c) : bsup.{u, v} o f < c :=\n  (bsup_le_blsub f).trans_lt (blsub_lt_ord_lift ho hf)\n#align bsup_lt_ord_lift bsup_lt_ord_lift\n\n",
 "bsup_lt_ord":
 "theorem bsup_lt_ord {o : ordinal} {f : ‚àÄ a < o, ordinal} {c : ordinal} (ho : o.card < c.cof) :\n    (‚àÄ i hi, f i hi < c) ‚Üí bsup.{u, u} o f < c :=\n  bsup_lt_ord_lift (by rwa [o.card.lift_id])\n#align bsup_lt_ord bsup_lt_ord\n\n",
 "blsub_lt_ord_of_is_regular":
 "theorem blsub_lt_ord_of_is_regular {o : ordinal} {f : ‚àÄ a < o, ordinal} {c} (hc : is_regular c) (ho : o.card < c) :\n    (‚àÄ i hi, f i hi < c.ord) ‚Üí ordinal.blsub o f < c.ord :=\n  blsub_lt_ord (by rwa [hc.cof_eq])\n#align blsub_lt_ord_of_is_regular blsub_lt_ord_of_is_regular\n\n",
 "blsub_lt_ord_lift_of_is_regular":
 "theorem blsub_lt_ord_lift_of_is_regular {o : ordinal} {f : ‚àÄ a < o, ordinal} {c} (hc : is_regular c)\n    (ho : cardinal.lift o.card < c) : (‚àÄ i hi, f i hi < c.ord) ‚Üí ordinal.blsub o f < c.ord :=\n  blsub_lt_ord_lift (by rwa [hc.cof_eq])\n#align blsub_lt_ord_lift_of_is_regular blsub_lt_ord_lift_of_is_regular\n\n",
 "blsub_lt_ord_lift":
 "theorem blsub_lt_ord_lift {o : ordinal} {f : ‚àÄ a < o, ordinal} {c : ordinal} (ho : o.card.lift < c.cof)\n    (hf : ‚àÄ i hi, f i hi < c) : blsub.{u, v} o f < c :=\n  lt_of_le_of_ne (blsub_le hf) fun h => ho.not_le (by simpa [‚Üê supr_ord, hf, h] using cof_blsub_le_lift.{u} f)\n#align blsub_lt_ord_lift blsub_lt_ord_lift\n\n",
 "blsub_lt_ord":
 "theorem blsub_lt_ord {o : ordinal} {f : ‚àÄ a < o, ordinal} {c : ordinal} (ho : o.card < c.cof)\n    (hf : ‚àÄ i hi, f i hi < c) : blsub.{u, u} o f < c :=\n  blsub_lt_ord_lift (by rwa [o.card.lift_id]) hf\n#align blsub_lt_ord blsub_lt_ord\n\n",
 "blsub_eq":
 "theorem blsub_eq (hf : is_fundamental_sequence a o f) : blsub.{u, u} o f = a :=\n  hf.2.2\n#align blsub_eq blsub_eq\n\n",
 "aleph_cof":
 "@[simp]\ntheorem aleph_cof {o : ordinal} (ho : o.is_limit) : (aleph o).ord.cof = o.cof :=\n  aleph_is_normal.cof_eq ho\n#align aleph_cof aleph_cof\n\n",
 "aleph_0_le_cof":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\ntheorem aleph_0_le_cof {o} : cardinal.aleph_0 ‚â§ cof o ‚Üî is_limit o :=\n  by\n  rcases zero_or_succ_or_limit o with (rfl | ‚ü®o, rfl‚ü© | l)\n  ¬∑ simp [not_zero_is_limit, cardinal.aleph_0_ne_zero]\n  ¬∑ simp [not_succ_is_limit, cardinal.one_lt_aleph_0]\n  ¬∑ simp [l]\n    refine' le_of_not_lt fun h => _\n    cases' cardinal.lt_aleph_0.1 h with n e\n    have := cof_cof o\n    rw [e, ord_nat] at this\n    cases n\n    ¬∑ simp at e\n      simpa [e, not_zero_is_limit] using l\n    ¬∑ rw [nat_cast_succ, cof_succ] at this\n      rw [‚Üê this, cof_eq_one_iff_is_succ] at e\n      rcases e with ‚ü®a, rfl‚ü©\n      exact not_succ_is_limit _ l\n#align aleph_0_le_cof aleph_0_le_cof\n\n",
 "aleph_0_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\ntheorem is_regular.aleph_0_le {c : cardinal} (H : c.is_regular) : cardinal.aleph_0 ‚â§ c :=\n  H.1\n#align is_regular.aleph_0_le is_regular.aleph_0_le\n\n",
 "aleph'_cof":
 "@[simp]\ntheorem aleph'_cof {o : ordinal} (ho : o.is_limit) : (aleph' o).ord.cof = o.cof :=\n  aleph'_is_normal.cof_eq ho\n#align aleph'_cof aleph'_cof\n\n"}