{"total":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ↪ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ↪ » -/\n/-- The cardinals are totally ordered. See `cardinal.linear_order` for (one of) the lattice\ninstance. -/\ntheorem total (α : Type u) (β : Type v) : Nonempty («expr ↪ » α β) ∨ Nonempty («expr ↪ » β α) :=\n  match @min_injective Bool (fun b => cond b (ULift α) (ULift.{max u v, v} β)) ⟨true⟩ with\n  | ⟨tt, ⟨h⟩⟩ =>\n    let ⟨f, hf⟩ := h false\n    or.inl ⟨Embedding.congr Equiv.ulift Equiv.ulift ⟨f, hf⟩⟩\n  | ⟨ff, ⟨h⟩⟩ =>\n    let ⟨f, hf⟩ := h true\n    or.inr ⟨Embedding.congr Equiv.ulift Equiv.ulift ⟨f, hf⟩⟩\n#align total total\n\n",
 "schroeder_bernstein":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →o » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/-\nCopyright (c) 2017 Johannes Hölzl. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johannes Hölzl, Mario Carneiro\n-/\n/-- **The Schröder-Bernstein Theorem**:\nGiven injections `α → β` and `β → α`, we can get a bijection `α → β`. -/\ntheorem schroeder_bernstein {f : α → β} {g : β → α} (hf : function.injective f) (hg : function.injective g) :\n    ∃ h : α → β, bijective h := by\n  cases' isEmpty_or_nonempty β with hβ hβ\n  · have : IsEmpty α := Function.isEmpty f\n    exact ⟨_, ((Equiv.equivEmpty α).trans (Equiv.equivEmpty β).symm).bijective⟩\n  set F : «expr →o » (Set α) (Set α) :=\n    { to_fun := fun s => «expr ᶜ» («expr '' » g («expr ᶜ» («expr '' » f s)))\n      monotone' := fun s t hst =>\n        compl_subset_compl.mpr <| image_subset _ <| compl_subset_compl.mpr <| image_subset _ hst }\n  set s : Set α := F.lfp\n  have hs : «expr ᶜ» («expr '' » g («expr ᶜ» («expr '' » f s))) = s := F.map_lfp\n  have hns : «expr '' » g («expr ᶜ» («expr '' » f s)) = «expr ᶜ» s := compl_injective (by simp [hs])\n  set g' := inv_fun g\n  have g'g : left_inverse g' g := left_inverse_inv_fun hg\n  have hg'ns : «expr '' » g' («expr ᶜ» s) = «expr ᶜ» («expr '' » f s) := by rw [← hns, g'g.image_image]\n  set h : α → β := s.piecewise f g'\n  have : surjective h := by rw [← range_iff_surjective, range_piecewise, hg'ns, union_compl_self]\n  have : injective h := by\n    refine' (injective_piecewise_iff _).2 ⟨hf.inj_on _, _, _⟩\n    · intro x hx y hy hxy\n      obtain ⟨x', hx', rfl⟩ : x ∈ «expr '' » g («expr ᶜ» («expr '' » f s)) := by rwa [hns]\n      obtain ⟨y', hy', rfl⟩ : y ∈ «expr '' » g («expr ᶜ» («expr '' » f s)) := by rwa [hns]\n      rw [g'g _, g'g _] at hxy\n      rw [hxy]\n    · intro x hx y hy hxy\n      obtain ⟨y', hy', rfl⟩ : y ∈ «expr '' » g («expr ᶜ» («expr '' » f s)) := by rwa [hns]\n      rw [g'g _] at hxy\n      exact hy' ⟨x, hx, hxy⟩\n  exact ⟨h, ‹injective h›, ‹surjective h›⟩\n#align schroeder_bernstein schroeder_bernstein\n\n",
 "min_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ↪ » -/\n/-- The cardinals are well-ordered. We express it here by the fact that in any set of cardinals\nthere is an element that injects into the others. See `cardinal.linear_order` for (one of) the\nlattice instances. -/\ntheorem min_injective [I : Nonempty ι] : ∃ i, Nonempty (∀ j, «expr ↪ » (β i) (β j)) :=\n  let ⟨s, hs, ms⟩ :=\n    show ∃ s ∈ sets, ∀ a ∈ sets, s ⊆ a → a = s from\n      zorn_subset sets fun c hc hcc =>\n        ⟨⋃₀ c, fun x ⟨p, hpc, hxp⟩ y ⟨q, hqc, hyq⟩ i hi =>\n          (hcc.total hpc hqc).elim (fun h => hc hqc x (h hxp) y hyq i hi) fun h => hc hpc x hxp y (h hyq) i hi, fun _ =>\n          subset_unionₛ_of_mem⟩\n  let ⟨i, e⟩ :=\n    show ∃ i, ∀ y, ∃ x ∈ s, (x : ∀ i, β i) i = y from\n      by_contradiction fun h =>\n        have h : ∀ i, ∃ y, ∀ x ∈ s, (x : ∀ i, β i) i ≠ y := by simpa only [not_exists, not_forall] using h\n        let ⟨f, hf⟩ := classical.axiom_of_choice h\n        have : f ∈ s :=\n          have : insert f s ∈ sets := fun x hx y hy =>\n            by\n            cases hx <;> cases hy; · simp [hx, hy]\n            · subst x\n              exact fun i e => (hf i y hy e.symm).elim\n            · subst y\n              exact fun i e => (hf i x hx e).elim\n            · exact hs x hx y hy\n          ms _ this (subset_insert f s) ▸ mem_insert _ _\n        let ⟨i⟩ := I\n        hf i f this rfl\n  let ⟨f, hf⟩ := classical.axiom_of_choice e\n  ⟨i,\n    ⟨fun j =>\n      ⟨fun a => f a j, fun a b e' => by\n        let ⟨sa, ea⟩ := hf a\n        let ⟨sb, eb⟩ := hf b\n        rw [← ea, ← eb, hs _ sa _ sb _ e']⟩⟩⟩\n#align min_injective min_injective\n\n",
 "antisymm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ↪ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ↪ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n#print antisymm /-\n/-- **The Schröder-Bernstein Theorem**: Given embeddings `α ↪ β` and `β ↪ α`, there exists an\nequivalence `α ≃ β`. -/\ntheorem antisymm : «expr ↪ » α β → «expr ↪ » β α → Nonempty («expr ≃ » α β)\n  | ⟨e₁, h₁⟩, ⟨e₂, h₂⟩ =>\n    let ⟨f, hf⟩ := schroeder_bernstein h₁ h₂\n    ⟨Equiv.ofBijective f hf⟩\n#align antisymm antisymm\n-/\n\n"}