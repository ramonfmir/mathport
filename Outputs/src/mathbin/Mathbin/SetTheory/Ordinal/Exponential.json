{"zero_opow'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.pow -/\ntheorem zero_opow' (a : Ordinal) : ordinal.pow 0 a = 1 - a := by simp only [opow_def, if_pos rfl]\n#align zero_opow' zero_opow'\n\n",
 "zero_opow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.pow -/\n@[simp]\ntheorem zero_opow {a : Ordinal} (a0 : a ≠ 0) : ordinal.pow 0 a = 0 := by\n  rwa [zero_opow', Ordinal.sub_eq_zero_iff_le, one_le_iff_ne_zero]\n#align zero_opow zero_opow\n\n",
 "sup_opow_nat":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.pow -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.pow -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.omega -/\ntheorem sup_opow_nat {o : Ordinal} (ho : 0 < o) : (sup fun n : ℕ => ordinal.pow o n) = ordinal.pow o (ordinal.omega) :=\n  by\n  rcases lt_or_eq_of_le (one_le_iff_pos.2 ho) with (ho₁ | rfl)\n  · exact (opow_is_normal ho₁).apply_omega\n  · rw [one_opow]\n    refine' le_antisymm (sup_le fun n => by rw [one_opow]) _\n    convert le_sup _ 0\n    rw [Nat.cast_zero, opow_zero]\n#align sup_opow_nat sup_opow_nat\n\n",
 "succ_log_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.pow -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.pow -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.pow -/\ntheorem succ_log_def {b x : Ordinal} (hb : 1 < b) (hx : x ≠ 0) : succ (log b x) = infₛ { o | x < ordinal.pow b o } :=\n  by\n  let t := Inf { o | x < ordinal.pow b o }\n  have : x < ordinal.pow b t := cinfₛ_mem (log_nonempty hb)\n  rcases zero_or_succ_or_limit t with (h | h | h)\n  · refine' ((one_le_iff_ne_zero.2 hx).not_lt _).elim\n    simpa only [h, opow_zero]\n  · rw [show log b x = pred t from log_def hb x, succ_pred_iff_is_succ.2 h]\n  · rcases(lt_opow_of_limit (zero_lt_one.trans hb).ne' h).1 this with ⟨a, h₁, h₂⟩\n    exact h₁.not_le.elim ((le_cinfₛ_iff'' (log_nonempty hb)).1 le_rfl a h₂)\n#align succ_log_def succ_log_def\n\n",
 "right_le_opow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.pow -/\ntheorem right_le_opow {a : Ordinal} (b) (a1 : 1 < a) : b ≤ ordinal.pow a b :=\n  (opow_isNormal a1).self_le _\n#align right_le_opow right_le_opow\n\n",
 "opow_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.pow -/\n@[simp]\ntheorem opow_zero (a : Ordinal) : ordinal.pow a 0 = 1 := by\n  by_cases a = 0 <;> [simp only [opow_def, if_pos h, sub_zero], simp only [opow_def, if_neg h, limit_rec_on_zero]]\n#align opow_zero opow_zero\n\n",
 "opow_succ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.pow -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.pow -/\n@[simp]\ntheorem opow_succ (a b : Ordinal) : ordinal.pow a (succ b) = ordinal.pow a b * a :=\n  if h : a = 0 then by subst a <;> simp only [zero_opow (succ_ne_zero _), MulZeroClass.mul_zero]\n  else by simp only [opow_def, limit_rec_on_succ, if_neg h]\n#align opow_succ opow_succ\n\n",
 "opow_right_inj":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.pow -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.pow -/\ntheorem opow_right_inj {a b c : Ordinal} (a1 : 1 < a) : ordinal.pow a b = ordinal.pow a c ↔ b = c :=\n  (opow_isNormal a1).inj\n#align opow_right_inj opow_right_inj\n\n",
 "opow_pos":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.pow -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.pow -/\ntheorem opow_pos {a : Ordinal} (b) (a0 : 0 < a) : 0 < ordinal.pow a b :=\n  by\n  have h0 : 0 < ordinal.pow a 0 := by simp only [opow_zero, zero_lt_one]\n  apply limit_rec_on b\n  · exact h0\n  · intro b IH\n    rw [opow_succ]\n    exact mul_pos IH a0\n  · exact fun b l _ => (lt_opow_of_limit (Ordinal.pos_iff_ne_zero.1 a0) l).2 ⟨0, l.pos, h0⟩\n#align opow_pos opow_pos\n\n",
 "opow_one_add":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.pow -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.pow -/\ntheorem opow_one_add (a b : Ordinal) : ordinal.pow a (1 + b) = a * ordinal.pow a b := by rw [opow_add, opow_one]\n#align opow_one_add opow_one_add\n\n",
 "opow_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.pow -/\n@[simp]\ntheorem opow_one (a : Ordinal) : ordinal.pow a 1 = a := by\n  rw [← succ_zero, opow_succ] <;> simp only [opow_zero, one_mul]\n#align opow_one opow_one\n\n",
 "opow_ne_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.pow -/\ntheorem opow_ne_zero {a : Ordinal} (b) (a0 : a ≠ 0) : ordinal.pow a b ≠ 0 :=\n  Ordinal.pos_iff_ne_zero.1 <| opow_pos b <| Ordinal.pos_iff_ne_zero.2 a0\n#align opow_ne_zero opow_ne_zero\n\n",
 "opow_mul_add_pos":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.pow -/\ntheorem opow_mul_add_pos {b v : Ordinal} (hb : b ≠ 0) (u) (hv : v ≠ 0) (w) : 0 < ordinal.pow b u * v + w :=\n  (opow_pos u <| Ordinal.pos_iff_ne_zero.2 hb).trans_le <|\n    (le_mul_left _ <| Ordinal.pos_iff_ne_zero.2 hv).trans <| le_add_right _ _\n#align opow_mul_add_pos opow_mul_add_pos\n\n",
 "opow_mul_add_lt_opow_succ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.pow -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.pow -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.pow -/\ntheorem opow_mul_add_lt_opow_succ {b u v w : Ordinal} (hvb : v < b) (hw : w < ordinal.pow b u) :\n    ordinal.pow b u * v + w < ordinal.pow b (succ u) :=\n  by\n  convert(opow_mul_add_lt_opow_mul_succ v hw).trans_le (mul_le_mul_left' (succ_le_of_lt hvb) _)\n  exact opow_succ b u\n#align opow_mul_add_lt_opow_succ opow_mul_add_lt_opow_succ\n\n",
 "opow_mul_add_lt_opow_mul_succ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.pow -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.pow -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.pow -/\ntheorem opow_mul_add_lt_opow_mul_succ {b u w : Ordinal} (v : Ordinal) (hw : w < ordinal.pow b u) :\n    ordinal.pow b u * v + w < ordinal.pow b u * succ v := by rwa [mul_succ, add_lt_add_iff_left]\n#align opow_mul_add_lt_opow_mul_succ opow_mul_add_lt_opow_mul_succ\n\n",
 "opow_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.pow -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.pow -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.pow -/\ntheorem opow_mul (a b c : Ordinal) : ordinal.pow a (b * c) = ordinal.pow (ordinal.pow a b) c :=\n  by\n  by_cases b0 : b = 0; · simp only [b0, MulZeroClass.zero_mul, opow_zero, one_opow]\n  by_cases a0 : a = 0\n  · subst a\n    by_cases c0 : c = 0\n    · simp only [c0, MulZeroClass.mul_zero, opow_zero]\n    simp only [zero_opow b0, zero_opow c0, zero_opow (mul_ne_zero b0 c0)]\n  cases' eq_or_lt_of_le (one_le_iff_ne_zero.2 a0) with a1 a1\n  · subst a1\n    simp only [one_opow]\n  apply limit_rec_on c\n  · simp only [MulZeroClass.mul_zero, opow_zero]\n  · intro c IH\n    rw [mul_succ, opow_add, IH, opow_succ]\n  · intro c l IH\n    refine'\n      eq_of_forall_ge_iff fun d =>\n        (((opow_is_normal a1).trans (mul_is_normal (Ordinal.pos_iff_ne_zero.2 b0))).limit_le l).trans _\n    dsimp only [Function.comp]\n    simp (config := { contextual := true }) only [IH]\n    exact (opow_le_of_limit (opow_ne_zero _ a0) l).symm\n#align opow_mul opow_mul\n\n",
 "opow_lt_opow_left_of_succ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.pow -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.pow -/\ntheorem opow_lt_opow_left_of_succ {a b c : Ordinal} (ab : a < b) : ordinal.pow a (succ c) < ordinal.pow b (succ c) :=\n  by\n  rw [opow_succ, opow_succ]\n  exact\n    (mul_le_mul_right' (opow_le_opow_left c ab.le) a).trans_lt\n      (mul_lt_mul_of_pos_left ab (opow_pos c ((Ordinal.zero_le a).trans_lt ab)))\n#align opow_lt_opow_left_of_succ opow_lt_opow_left_of_succ\n\n",
 "opow_lt_opow_iff_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.pow -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.pow -/\ntheorem opow_lt_opow_iff_right {a b c : Ordinal} (a1 : 1 < a) : ordinal.pow a b < ordinal.pow a c ↔ b < c :=\n  (opow_isNormal a1).lt_iff\n#align opow_lt_opow_iff_right opow_lt_opow_iff_right\n\n",
 "opow_log_le_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.pow -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.pow -/\ntheorem opow_log_le_self (b) {x : Ordinal} (hx : x ≠ 0) : ordinal.pow b (log b x) ≤ x :=\n  by\n  rcases eq_or_ne b 0 with (rfl | b0)\n  · rw [zero_opow']\n    refine' (sub_le_self _ _).trans (one_le_iff_ne_zero.2 hx)\n  rcases lt_or_eq_of_le (one_le_iff_ne_zero.2 b0) with (hb | rfl)\n  · refine' le_of_not_lt fun h => (lt_succ (log b x)).not_le _\n    have := @cinfₛ_le' _ _ { o | x < ordinal.pow b o } _ h\n    rwa [← succ_log_def hb hx] at this\n  · rwa [one_opow, one_le_iff_ne_zero]\n#align opow_log_le_self opow_log_le_self\n\n",
 "opow_limit":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.pow -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.pow -/\ntheorem opow_limit {a b : Ordinal} (a0 : a ≠ 0) (h : IsLimit b) :\n    ordinal.pow a b = bsup.{u, u} b fun c _ => ordinal.pow a c := by\n  simp only [opow_def, if_neg a0] <;> rw [limit_rec_on_limit _ _ _ _ h] <;> rfl\n#align opow_limit opow_limit\n\n",
 "opow_le_opow_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.pow -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.pow -/\ntheorem opow_le_opow_right {a b c : Ordinal} (h₁ : 0 < a) (h₂ : b ≤ c) : ordinal.pow a b ≤ ordinal.pow a c :=\n  by\n  cases' lt_or_eq_of_le (one_le_iff_pos.2 h₁) with h₁ h₁\n  · exact (opow_le_opow_iff_right h₁).2 h₂\n  · subst a\n    simp only [one_opow]\n#align opow_le_opow_right opow_le_opow_right\n\n",
 "opow_le_opow_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.pow -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.pow -/\ntheorem opow_le_opow_left {a b : Ordinal} (c) (ab : a ≤ b) : ordinal.pow a c ≤ ordinal.pow b c :=\n  by\n  by_cases a0 : a = 0\n  · subst a\n    by_cases c0 : c = 0\n    · subst c\n      simp only [opow_zero]\n    · simp only [zero_opow c0, Ordinal.zero_le]\n  · apply limit_rec_on c\n    · simp only [opow_zero]\n    · intro c IH\n      simpa only [opow_succ] using mul_le_mul' IH ab\n    ·\n      exact fun c l IH =>\n        (opow_le_of_limit a0 l).2 fun b' h =>\n          (IH _ h).trans (opow_le_opow_right ((Ordinal.pos_iff_ne_zero.2 a0).trans_le ab) h.le)\n#align opow_le_opow_left opow_le_opow_left\n\n",
 "opow_le_opow_iff_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.pow -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.pow -/\ntheorem opow_le_opow_iff_right {a b c : Ordinal} (a1 : 1 < a) : ordinal.pow a b ≤ ordinal.pow a c ↔ b ≤ c :=\n  (opow_isNormal a1).le_iff\n#align opow_le_opow_iff_right opow_le_opow_iff_right\n\n",
 "opow_le_of_limit":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.pow -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.pow -/\ntheorem opow_le_of_limit {a b c : Ordinal} (a0 : a ≠ 0) (h : IsLimit b) :\n    ordinal.pow a b ≤ c ↔ ∀ b' < b, ordinal.pow a b' ≤ c := by rw [opow_limit a0 h, bsup_le_iff]\n#align opow_le_of_limit opow_le_of_limit\n\n",
 "opow_le_iff_le_log":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.pow -/\n/-- `opow b` and `log b` (almost) form a Galois connection. -/\ntheorem opow_le_iff_le_log {b x c : Ordinal} (hb : 1 < b) (hx : x ≠ 0) : ordinal.pow b c ≤ x ↔ c ≤ log b x :=\n  ⟨fun h =>\n    le_of_not_lt fun hn =>\n      (lt_opow_succ_log_self hb x).not_le <| ((opow_le_opow_iff_right hb).2 (succ_le_of_lt hn)).trans h,\n    fun h => ((opow_le_opow_iff_right hb).2 h).trans (opow_log_le_self b hx)⟩\n#align opow_le_iff_le_log opow_le_iff_le_log\n\n",
 "opow_is_normal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:219:4: warning: unsupported binary notation `ordinal.pow -/\ntheorem opow_is_normal {a : Ordinal} (h : 1 < a) : IsNormal ((ordinal.pow · ·) a) :=\n  have a0 : 0 < a := zero_lt_one.trans h\n  ⟨fun b => by simpa only [mul_one, opow_succ] using (mul_lt_mul_iff_left (opow_pos b a0)).2 h, fun b l c =>\n    opow_le_of_limit (ne_of_gt a0) l⟩\n#align opow_is_normal opow_is_normal\n\n",
 "opow_is_limit_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.pow -/\ntheorem opow_is_limit_left {a b : Ordinal} (l : IsLimit a) (hb : b ≠ 0) : IsLimit (ordinal.pow a b) :=\n  by\n  rcases zero_or_succ_or_limit b with (e | ⟨b, rfl⟩ | l')\n  · exact absurd e hb\n  · rw [opow_succ]\n    exact mul_is_limit (opow_pos _ l.pos) l\n  · exact opow_is_limit l.one_lt l'\n#align opow_is_limit_left opow_is_limit_left\n\n",
 "opow_is_limit":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.pow -/\ntheorem opow_is_limit {a b : Ordinal} (a1 : 1 < a) : IsLimit b → IsLimit (ordinal.pow a b) :=\n  (opow_isNormal a1).is_limit\n#align opow_is_limit opow_is_limit\n\n",
 "opow_dvd_opow_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.pow -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.pow -/\ntheorem opow_dvd_opow_iff {a b c : Ordinal} (a1 : 1 < a) : ordinal.pow a b ∣ ordinal.pow a c ↔ b ≤ c :=\n  ⟨fun h =>\n    le_of_not_lt fun hn =>\n      not_le_of_lt ((opow_lt_opow_iff_right a1).2 hn) <| le_of_dvd (opow_ne_zero _ <| one_le_iff_ne_zero.1 <| a1.le) h,\n    opow_dvd_opow _⟩\n#align opow_dvd_opow_iff opow_dvd_opow_iff\n\n",
 "opow_dvd_opow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.pow -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.pow -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.pow -/\ntheorem opow_dvd_opow (a) {b c : Ordinal} (h : b ≤ c) : ordinal.pow a b ∣ ordinal.pow a c :=\n  ⟨ordinal.pow a (c - b), by rw [← opow_add, Ordinal.add_sub_cancel_of_le h]⟩\n#align opow_dvd_opow opow_dvd_opow\n\n",
 "opow_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.pow -/\n/-\nCopyright (c) 2017 Mario Carneiro. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Mario Carneiro, Floris van Doorn, Violeta Hernández Palacios\n-/\ntheorem opow_def (a b : Ordinal) :\n    ordinal.pow a b = if a = 0 then 1 - b else limitRecOn b 1 (fun _ IH => IH * a) fun b _ => bsup.{u, u} b :=\n  rfl\n#align opow_def opow_def\n\n",
 "opow_add":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.pow -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.pow -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.pow -/\ntheorem opow_add (a b c : Ordinal) : ordinal.pow a (b + c) = ordinal.pow a b * ordinal.pow a c :=\n  by\n  rcases eq_or_ne a 0 with (rfl | a0)\n  · rcases eq_or_ne c 0 with (rfl | c0)\n    · simp\n    have : b + c ≠ 0 := ((Ordinal.pos_iff_ne_zero.2 c0).trans_le (le_add_left _ _)).ne'\n    simp only [zero_opow c0, zero_opow this, MulZeroClass.mul_zero]\n  rcases eq_or_lt_of_le (one_le_iff_ne_zero.2 a0) with (rfl | a1)\n  · simp only [one_opow, mul_one]\n  apply limit_rec_on c\n  · simp\n  · intro c IH\n    rw [add_succ, opow_succ, IH, opow_succ, mul_assoc]\n  · intro c l IH\n    refine' eq_of_forall_ge_iff fun d => (((opow_is_normal a1).trans (add_is_normal b)).limit_le l).trans _\n    dsimp only [Function.comp]\n    simp (config := { contextual := true }) only [IH]\n    exact (((mul_is_normal <| opow_pos b (Ordinal.pos_iff_ne_zero.2 a0)).trans (opow_is_normal a1)).limit_le l).symm\n#align opow_add opow_add\n\n",
 "one_opow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.pow -/\n@[simp]\ntheorem one_opow (a : Ordinal) : ordinal.pow 1 a = 1 :=\n  by\n  apply limit_rec_on a\n  · simp only [opow_zero]\n  · intro _ ih\n    simp only [opow_succ, ih, mul_one]\n  refine' fun b l IH => eq_of_forall_ge_iff fun c => _\n  rw [opow_le_of_limit Ordinal.one_ne_zero l]\n  exact ⟨fun H => by simpa only [opow_zero] using H 0 l.pos, fun H b' h => by rwa [IH _ h]⟩\n#align one_opow one_opow\n\n",
 "nat_cast_opow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.pow -/\n@[simp, norm_cast]\ntheorem nat_cast_opow (m : ℕ) : ∀ n : ℕ, ((pow m n : ℕ) : Ordinal) = ordinal.pow m n\n  | 0 => by simp\n  | n + 1 => by rw [pow_succ', nat_cast_mul, nat_cast_opow, Nat.cast_succ, add_one_eq_succ, opow_succ]\n#align nat_cast_opow nat_cast_opow\n\n",
 "mod_opow_log_lt_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.pow -/\ntheorem mod_opow_log_lt_self (b : Ordinal) {o : Ordinal} (ho : o ≠ 0) : o % ordinal.pow b (log b o) < o :=\n  by\n  rcases eq_or_ne b 0 with (rfl | hb)\n  · simpa using Ordinal.pos_iff_ne_zero.2 ho\n  · exact (mod_lt _ <| opow_ne_zero _ hb).trans_le (opow_log_le_self _ ho)\n#align mod_opow_log_lt_self mod_opow_log_lt_self\n\n",
 "lt_opow_succ_log_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.pow -/\ntheorem lt_opow_succ_log_self {b : Ordinal} (hb : 1 < b) (x : Ordinal) : x < ordinal.pow b (succ (log b x)) :=\n  by\n  rcases eq_or_ne x 0 with (rfl | hx)\n  · apply opow_pos _ (zero_lt_one.trans hb)\n  · rw [succ_log_def hb hx]\n    exact cinfₛ_mem (log_nonempty hb)\n#align lt_opow_succ_log_self lt_opow_succ_log_self\n\n",
 "lt_opow_of_limit":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.pow -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.pow -/\ntheorem lt_opow_of_limit {a b c : Ordinal} (b0 : b ≠ 0) (h : IsLimit c) :\n    a < ordinal.pow b c ↔ ∃ c' < c, a < ordinal.pow b c' := by\n  rw [← not_iff_not, not_exists] <;> simp only [not_lt, opow_le_of_limit b0 h, exists_prop, not_and]\n#align lt_opow_of_limit lt_opow_of_limit\n\n",
 "lt_opow_iff_log_lt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.pow -/\ntheorem lt_opow_iff_log_lt {b x c : Ordinal} (hb : 1 < b) (hx : x ≠ 0) : x < ordinal.pow b c ↔ log b x < c :=\n  lt_iff_lt_of_le_iff_le (opow_le_iff_le_log hb hx)\n#align lt_opow_iff_log_lt lt_opow_iff_log_lt\n\n",
 "log_zero_right":
 "@[simp]\ntheorem log_zero_right (b : Ordinal) : log b 0 = 0 :=\n  if b1 : 1 < b then by\n    rw [log_def b1, ← Ordinal.le_zero, pred_le]\n    apply cinfₛ_le'\n    dsimp\n    rw [succ_zero, opow_one]\n    exact zero_lt_one.trans b1\n  else by simp only [log_of_not_one_lt_left b1]\n#align log_zero_right log_zero_right\n\n",
 "log_zero_left":
 "@[simp]\ntheorem log_zero_left : ∀ b, log 0 b = 0 :=\n  log_of_left_le_one zero_le_one\n#align log_zero_left log_zero_left\n\n",
 "log_pos":
 "theorem log_pos {b o : Ordinal} (hb : 1 < b) (ho : o ≠ 0) (hbo : b ≤ o) : 0 < log b o := by\n  rwa [← succ_le_iff, succ_zero, ← opow_le_iff_le_log hb ho, opow_one]\n#align log_pos log_pos\n\n",
 "log_opow_mul_add":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.pow -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.pow -/\ntheorem log_opow_mul_add {b u v w : Ordinal} (hb : 1 < b) (hv : v ≠ 0) (hvb : v < b) (hw : w < ordinal.pow b u) :\n    log b (ordinal.pow b u * v + w) = u :=\n  by\n  have hne' := (opow_mul_add_pos (zero_lt_one.trans hb).ne' u hv w).ne'\n  by_contra' hne\n  cases' lt_or_gt_of_ne hne with h h\n  · rw [← lt_opow_iff_log_lt hb hne'] at h\n    exact h.not_le ((le_mul_left _ (Ordinal.pos_iff_ne_zero.2 hv)).trans (le_add_right _ _))\n  · change _ < _ at h\n    rw [← succ_le_iff, ← opow_le_iff_le_log hb hne'] at h\n    exact (not_lt_of_le h) (opow_mul_add_lt_opow_succ hvb hw)\n#align log_opow_mul_add log_opow_mul_add\n\n",
 "log_opow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.pow -/\ntheorem log_opow {b : Ordinal} (hb : 1 < b) (x : Ordinal) : log b (ordinal.pow b x) = x :=\n  by\n  convert log_opow_mul_add hb zero_ne_one.symm hb (opow_pos x (zero_lt_one.trans hb))\n  rw [add_zero, mul_one]\n#align log_opow log_opow\n\n",
 "log_one_right":
 "@[simp]\ntheorem log_one_right (b : Ordinal) : log b 1 = 0 :=\n  if hb : 1 < b then log_eq_zero hb else log_of_not_one_lt_left hb 1\n#align log_one_right log_one_right\n\n",
 "log_one_left":
 "@[simp]\ntheorem log_one_left : ∀ b, log 1 b = 0 :=\n  log_of_left_le_one le_rfl\n#align log_one_left log_one_left\n\n",
 "log_of_not_one_lt_left":
 "theorem log_of_not_one_lt_left {b : Ordinal} (h : ¬1 < b) (x : Ordinal) : log b x = 0 := by simp only [log, dif_neg h]\n#align log_of_not_one_lt_left log_of_not_one_lt_left\n\n",
 "log_of_left_le_one":
 "theorem log_of_left_le_one {b : Ordinal} (h : b ≤ 1) : ∀ x, log b x = 0 :=\n  log_of_not_one_lt_left h.not_lt\n#align log_of_left_le_one log_of_left_le_one\n\n",
 "log_nonempty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.pow -/\n/-- The set in the definition of `log` is nonempty. -/\ntheorem log_nonempty {b x : Ordinal} (h : 1 < b) : { o | x < ordinal.pow b o }.nonempty :=\n  ⟨_, succ_le_iff.1 (right_le_opow _ h)⟩\n#align log_nonempty log_nonempty\n\n",
 "log_mono_right":
 "@[mono]\ntheorem log_mono_right (b) {x y : Ordinal} (xy : x ≤ y) : log b x ≤ log b y :=\n  if hx : x = 0 then by simp only [hx, log_zero_right, Ordinal.zero_le]\n  else\n    if hb : 1 < b then\n      (opow_le_iff_le_log hb (lt_of_lt_of_le (Ordinal.pos_iff_ne_zero.2 hx) xy).ne').1 <|\n        (opow_log_le_self _ hx).trans xy\n    else by simp only [log_of_not_one_lt_left hb, Ordinal.zero_le]\n#align log_mono_right log_mono_right\n\n",
 "log_mod_opow_log_lt_log_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.pow -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.pow -/\ntheorem log_mod_opow_log_lt_log_self {b o : Ordinal} (hb : 1 < b) (ho : o ≠ 0) (hbo : b ≤ o) :\n    log b (o % ordinal.pow b (log b o)) < log b o :=\n  by\n  cases eq_or_ne (o % ordinal.pow b (log b o)) 0\n  · rw [h, log_zero_right]\n    apply log_pos hb ho hbo\n  · rw [← succ_le_iff, succ_log_def hb h]\n    apply cinfₛ_le'\n    apply mod_lt\n    rw [← Ordinal.pos_iff_ne_zero]\n    exact opow_pos _ (zero_lt_one.trans hb)\n#align log_mod_opow_log_lt_log_self log_mod_opow_log_lt_log_self\n\n",
 "log_le_self":
 "theorem log_le_self (b x : Ordinal) : log b x ≤ x :=\n  if hx : x = 0 then by simp only [hx, log_zero_right, Ordinal.zero_le]\n  else\n    if hb : 1 < b then (right_le_opow _ hb).trans (opow_log_le_self b hx)\n    else by simp only [log_of_not_one_lt_left hb, Ordinal.zero_le]\n#align log_le_self log_le_self\n\n",
 "log_eq_zero":
 "theorem log_eq_zero {b o : Ordinal} (hbo : o < b) : log b o = 0 :=\n  by\n  rcases eq_or_ne o 0 with (rfl | ho)\n  · exact log_zero_right b\n  cases' le_or_lt b 1 with hb hb\n  · rcases le_one_iff.1 hb with (rfl | rfl)\n    · exact log_zero_left o\n    · exact log_one_left o\n  · rwa [← Ordinal.le_zero, ← lt_succ_iff, succ_zero, ← lt_opow_iff_log_lt hb ho, opow_one]\n#align log_eq_zero log_eq_zero\n\n",
 "log_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.pow -/\ntheorem log_def {b : Ordinal} (h : 1 < b) (x : Ordinal) : log b x = pred (infₛ { o | x < ordinal.pow b o }) := by\n  simp only [log, dif_pos h]\n#align log_def log_def\n\n",
 "left_le_opow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.pow -/\ntheorem left_le_opow (a : Ordinal) {b : Ordinal} (b1 : 0 < b) : a ≤ ordinal.pow a b :=\n  by\n  nth_rw 1 [← opow_one a]\n  cases' le_or_gt a 1 with a1 a1\n  · cases' lt_or_eq_of_le a1 with a0 a1\n    · rw [lt_one_iff_zero] at a0\n      rw [a0, zero_opow Ordinal.one_ne_zero]\n      exact Ordinal.zero_le _\n    rw [a1, one_opow, one_opow]\n  rwa [opow_le_opow_iff_right a1, one_le_iff_pos]\n#align left_le_opow left_le_opow\n\n",
 "div_opow_log_pos":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.pow -/\ntheorem div_opow_log_pos (b : Ordinal) {o : Ordinal} (ho : o ≠ 0) : 0 < o / ordinal.pow b (log b o) :=\n  by\n  rcases eq_zero_or_pos b with (rfl | hb)\n  · simpa using Ordinal.pos_iff_ne_zero.2 ho\n  · rw [div_pos (opow_ne_zero _ hb.ne')]\n    exact opow_log_le_self b ho\n#align div_opow_log_pos div_opow_log_pos\n\n",
 "div_opow_log_lt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.pow -/\ntheorem div_opow_log_lt {b : Ordinal} (o : Ordinal) (hb : 1 < b) : o / ordinal.pow b (log b o) < b :=\n  by\n  rw [div_lt (opow_pos _ (zero_lt_one.trans hb)).ne', ← opow_succ]\n  exact lt_opow_succ_log_self hb o\n#align div_opow_log_lt div_opow_log_lt\n\n",
 "add_log_le_log_mul":
 "theorem add_log_le_log_mul {x y : Ordinal} (b : Ordinal) (hx : x ≠ 0) (hy : y ≠ 0) :\n    log b x + log b y ≤ log b (x * y) := by\n  by_cases hb : 1 < b\n  · rw [← opow_le_iff_le_log hb (mul_ne_zero hx hy), opow_add]\n    exact mul_le_mul' (opow_log_le_self b hx) (opow_log_le_self b hy)\n  simp only [log_of_not_one_lt_left hb, zero_add]\n#align add_log_le_log_mul add_log_le_log_mul\n\n"}