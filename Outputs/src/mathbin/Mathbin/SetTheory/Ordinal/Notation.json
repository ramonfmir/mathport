{"zero_of_zero":
 "theorem NF.zero_of_zero {e n a} (h : NF (oadd e n a)) (e0 : e = 0) : a = 0 := by simpa [e0, NF_below_zero] using h.snd'\n#align NF.zero_of_zero NF.zero_of_zero\n\n",
 "zero_lt_one":
 "#print zero_lt_one /-\nprotected theorem zero_lt_one : (0 : onote) < 1 := by rw [lt_def, repr, repr_one] <;> exact zero_lt_one\n#align zero_lt_one zero_lt_one\n-/\n\n",
 "zero_def":
 "/-\nCopyright (c) 2018 Mario Carneiro. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Mario Carneiro\n-/\n-- get notation for `ω`\n@[simp]\ntheorem zero_def : zero = 0 :=\n  rfl\n#align zero_def zero_def\n\n",
 "zero_add":
 "#print zero_add /-\n@[simp]\ntheorem zero_add (o : onote) : 0 + o = o :=\n  rfl\n#align zero_add zero_add\n-/\n\n",
 "sub_NF_below":
 "theorem sub_NF_below : ∀ {o₁ o₂ b}, NF_below o₁ b → NF o₂ → NF_below (o₁ - o₂) b\n  | 0, o, b, h₁, h₂ => by cases o <;> exact NF_below.zero\n  | oadd e n a, 0, b, h₁, h₂ => h₁\n  | oadd e₁ n₁ a₁, oadd e₂ n₂ a₂, b, h₁, h₂ =>\n    by\n    have h' := sub_NF_below h₁.snd h₂.snd\n    simp [has_sub.sub, sub] at h'⊢\n    have := @cmp_compares _ _ h₁.fst h₂.fst\n    cases cmp e₁ e₂ <;> simp [sub]\n    · apply NF_below.zero\n    · simp at this\n      subst e₂\n      cases mn : (n₁ : ℕ) - n₂ <;> simp [sub]\n      · by_cases en : n₁ = n₂ <;> simp [en]\n        · exact h'.mono (le_of_lt h₁.lt)\n        · exact NF_below.zero\n      · exact NF_below.oadd h₁.fst h₁.snd h₁.lt\n    · exact h₁\n#align sub_NF_below sub_NF_below\n\n",
 "split_eq_scale_split'":
 "theorem split_eq_scale_split' : ∀ {o o' m} [NF o], split' o = (o', m) → split o = (scale 1 o', m)\n  | 0, o', m, h, p => by injection p <;> substs o' m <;> rfl\n  | oadd e n a, o', m, h, p => by\n    by_cases e0 : e = 0 <;> simp [e0, split, split'] at p⊢\n    · rcases p with ⟨rfl, rfl⟩\n      exact ⟨rfl, rfl⟩\n    · revert p\n      cases' h' : split' a with a' m'\n      haveI := h.fst\n      haveI := h.snd\n      simp [split_eq_scale_split' h', split, split']\n      have : 1 + (e - 1) = e := by\n        refine' repr_inj.1 _\n        simp\n        have := mt repr_inj.1 e0\n        exact ordinal.add_sub_cancel_of_le (one_le_iff_ne_zero.2 this)\n      intros\n      substs o' m\n      simp [scale, this]\n#align split_eq_scale_split' split_eq_scale_split'\n\n",
 "split_dvd":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.omega -/\ntheorem split_dvd {o o' m} [NF o] (h : split o = (o', m)) : ordinal.omega ∣ repr o' :=\n  by\n  cases' e : split' o with a n\n  rw [split_eq_scale_split' e] at h\n  injection h; subst o'\n  cases NF_repr_split' e; skip; simp\n#align split_dvd split_dvd\n\n",
 "split_add_lt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.omega -/\ntheorem split_add_lt {o e n a m} [NF o] (h : split o = (oadd e n a, m)) : repr a + m < ordinal.omega ^ repr e :=\n  by\n  cases' NF_repr_split h with h₁ h₂\n  cases' h₁.of_dvd_omega (split_dvd h) with e0 d\n  have := h₁.fst; have := h₁.snd\n  apply principal_add_omega_opow _ h₁.snd'.repr_lt (lt_of_lt_of_le (nat_lt_omega _) _)\n  simpa using opow_le_opow_right omega_pos (one_le_iff_ne_zero.2 e0)\n#align split_add_lt split_add_lt\n\n",
 "snd'":
 "theorem NF.snd' {e n a} : NF (oadd e n a) → NF_below a (repr e)\n  | ⟨⟨b, h⟩⟩ => h.snd\n#align NF.snd' NF.snd'\n\n",
 "snd":
 "theorem NF.snd {e n a} (h : NF (oadd e n a)) : NF a :=\n  ⟨⟨_, h.snd'⟩⟩\n#align NF.snd NF.snd\n\n",
 "scale_opow_aux":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.omega -/\ntheorem scale_opow_aux (e a0 a : onote) [NF e] [NF a0] [NF a] :\n    ∀ k m, repr (opow_aux e a0 a k m) = ordinal.omega ^ repr e * repr (opow_aux 0 a0 a k m)\n  | 0, m => by cases m <;> simp [opow_aux]\n  | k + 1, m => by by_cases m = 0 <;> simp [h, opow_aux, mul_add, opow_add, mul_assoc, scale_opow_aux]\n#align scale_opow_aux scale_opow_aux\n\n",
 "scale_eq_mul":
 "theorem scale_eq_mul (x) [NF x] : ∀ (o) [NF o], scale x o = oadd x 1 0 * o\n  | 0, h => rfl\n  | oadd e n a, h => by\n    simp [(· * ·)]; simp [mul, scale]\n    haveI := h.snd\n    by_cases e0 : e = 0\n    · rw [scale_eq_mul]\n      simp [e0, h.zero_of_zero, show x + 0 = x from repr_inj.1 (by simp)]\n    · simp [e0, scale_eq_mul, (· * ·)]\n#align scale_eq_mul scale_eq_mul\n\n",
 "repr_sub":
 "theorem repr_sub (a b) : repr (a - b) = repr a - repr b :=\n  onote.repr_sub a.1 b.1\n#align repr_sub repr_sub\n\n",
 "repr_scale":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.omega -/\n@[simp]\ntheorem repr_scale (x) [NF x] (o) [NF o] : repr (scale x o) = ordinal.omega ^ repr x * repr o := by simp [scale_eq_mul]\n#align repr_scale repr_scale\n\n",
 "repr_opow_aux₂":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.pow -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.omega -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.pow -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.pow -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.pow -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.pow -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.pow -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.pow -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.omega -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.pow -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.pow -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.pow -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.pow -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.pow -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.pow -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.omega -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.omega -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.pow -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.pow -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.omega -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.pow -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.omega -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ+» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.pow -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.pow -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.omega -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.pow -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.pow -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.omega -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.pow -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.omega -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.pow -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.pow -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.omega -/\ntheorem repr_opow_aux₂ {a0 a'} [N0 : NF a0] [Na' : NF a'] (m : ℕ) (d : ordinal.omega ∣ repr a') (e0 : repr a0 ≠ 0)\n    (h : repr a' + m < ordinal.pow (ordinal.omega) (repr a0)) (n : «exprℕ+») (k : ℕ) :\n    let R := repr (opow_aux 0 a0 (oadd a0 n a' * of_nat m) k m)\n    (k ≠ 0 → R < ordinal.pow (ordinal.pow (ordinal.omega) (repr a0)) (succ k)) ∧\n      ordinal.pow (ordinal.pow (ordinal.omega) (repr a0)) k *\n            (ordinal.pow (ordinal.omega) (repr a0) * (n : ℕ) + repr a') +\n          R =\n        ordinal.pow (ordinal.pow (ordinal.omega) (repr a0) * (n : ℕ) + repr a' + m) (succ k) :=\n  by\n  intro\n  haveI No : NF (oadd a0 n a') := N0.oadd n (Na'.below_of_lt' <| lt_of_le_of_lt (le_add_right _ _) h)\n  induction' k with k IH\n  · cases m <;> simp [opow_aux, R]\n  rename' R => R'\n  let R := repr (opow_aux 0 a0 (oadd a0 n a' * of_nat m) k m)\n  let ω0 := ordinal.pow (ordinal.omega) (repr a0)\n  let α' := ω0 * n + repr a'\n  change (k ≠ 0 → R < ordinal.pow ω0 (succ k)) ∧ ordinal.pow ω0 k * α' + R = ordinal.pow (α' + m) (succ k) at IH\n  have RR : R' = ordinal.pow ω0 k * (α' * m) + R :=\n    by\n    by_cases m = 0 <;> simp [h, R', opow_aux, R, opow_mul]\n    · cases k <;> simp [opow_aux]\n    · rfl\n  have α0 : 0 < α' := by simpa [α', lt_def, repr] using oadd_pos a0 n a'\n  have ω00 : 0 < ordinal.pow ω0 k := opow_pos _ (opow_pos _ omega_pos)\n  have Rl : R < ordinal.pow (ordinal.omega) (repr a0 * succ ↑k) :=\n    by\n    by_cases k0 : k = 0\n    · simp [k0]\n      refine' lt_of_lt_of_le _ (opow_le_opow_right omega_pos (one_le_iff_ne_zero.2 e0))\n      cases' m with m <;> simp [k0, R, opow_aux, omega_pos]\n      rw [← add_one_eq_succ, ← Nat.cast_succ]\n      apply nat_lt_omega\n    · rw [opow_mul]\n      exact IH.1 k0\n  refine' ⟨fun _ => _, _⟩\n  · rw [RR, ← opow_mul _ _ (succ k.succ)]\n    have e0 := ordinal.pos_iff_ne_zero.2 e0\n    have rr0 := lt_of_lt_of_le e0 (le_add_left _ _)\n    apply principal_add_omega_opow\n    · simp [opow_mul, ω0, opow_add, mul_assoc]\n      rw [mul_lt_mul_iff_left ω00, ← ordinal.opow_add]\n      have := (No.below_of_lt _).repr_lt\n      unfold repr at this\n      refine' mul_lt_omega_opow rr0 this (nat_lt_omega _)\n      simpa using (add_lt_add_iff_left (repr a0)).2 e0\n    ·\n      refine'\n        lt_of_lt_of_le Rl\n          (opow_le_opow_right omega_pos <|\n            mul_le_mul_left' (succ_le_succ_iff.2 (nat_cast_le.2 (le_of_lt k.lt_succ_self))) _)\n  calc\n    ordinal.pow ω0 k.succ * α' + R' = ordinal.pow ω0 (succ k) * α' + (ordinal.pow ω0 k * α' * m + R) := by\n      rw [nat_cast_succ, RR, ← mul_assoc]\n    _ = (ordinal.pow ω0 k * α' + R) * α' + (ordinal.pow ω0 k * α' + R) * m := _\n    _ = ordinal.pow (α' + m) (succ k.succ) := by rw [← mul_add, nat_cast_succ, opow_succ, IH.2]\n    \n  congr 1\n  · have αd : ordinal.omega ∣ α' :=\n      dvd_add (dvd_mul_of_dvd_left (by simpa using opow_dvd_opow (ordinal.omega) (one_le_iff_ne_zero.2 e0)) _) d\n    rw [mul_add (ordinal.pow ω0 k), add_assoc, ← mul_assoc, ← opow_succ,\n      add_mul_limit _ (is_limit_iff_omega_dvd.2 ⟨ne_of_gt α0, αd⟩), mul_assoc,\n      @mul_omega_dvd n (nat_cast_pos.2 n.pos) (nat_lt_omega _) _ αd]\n    apply @add_absorp _ (repr a0 * succ k)\n    · refine' principal_add_omega_opow _ _ Rl\n      rw [opow_mul, opow_succ, mul_lt_mul_iff_left ω00]\n      exact No.snd'.repr_lt\n    · have := mul_le_mul_left' (one_le_iff_pos.2 <| nat_cast_pos.2 n.pos) (ordinal.pow ω0 (succ k))\n      rw [opow_mul]\n      simpa [-opow_succ]\n  · cases m\n    · have : R = 0 := by cases k <;> simp [R, opow_aux]\n      simp [this]\n    · rw [nat_cast_succ, add_mul_succ]\n      apply add_absorp Rl\n      rw [opow_mul, opow_succ]\n      apply mul_le_mul_left'\n      simpa [α', repr] using omega_le_oadd a0 n a'\n#align repr_opow_aux₂ repr_opow_aux₂\n\n",
 "repr_opow_aux₁":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.omega -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.omega -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.omega -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ+» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.omega -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.omega -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.omega -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.omega -/\ntheorem repr_opow_aux₁ {e a} [Ne : NF e] [Na : NF a] {a' : ordinal} (e0 : repr e ≠ 0)\n    (h : a' < (ordinal.omega : ordinal.{0}) ^ repr e) (aa : repr a = a') (n : «exprℕ+») :\n    ((ordinal.omega : ordinal.{0}) ^ repr e * (n : ℕ) + a') ^ (ordinal.omega : ordinal.{0}) =\n      (ordinal.omega ^ repr e) ^ (ordinal.omega : ordinal.{0}) :=\n  by\n  subst aa\n  have No := Ne.oadd n (Na.below_of_lt' h)\n  have := omega_le_oadd e n a; unfold repr at this\n  refine' le_antisymm _ (opow_le_opow_left _ this)\n  apply (opow_le_of_limit ((opow_pos _ omega_pos).trans_le this).ne' omega_is_limit).2\n  intro b l\n  have := (No.below_of_lt (lt_succ _)).repr_lt; unfold repr at this\n  apply (opow_le_opow_left b <| this.le).trans\n  rw [← opow_mul, ← opow_mul]\n  apply opow_le_opow_right omega_pos\n  cases' le_or_lt (ordinal.omega) (repr e) with h h\n  · apply (mul_le_mul_left' (le_succ b) _).trans\n    rw [← add_one_eq_succ, add_mul_succ _ (one_add_of_omega_le h), add_one_eq_succ, succ_le_iff,\n      mul_lt_mul_iff_left (ordinal.pos_iff_ne_zero.2 e0)]\n    exact omega_is_limit.2 _ l\n  · apply (principal_mul_omega (omega_is_limit.2 _ h) l).le.trans\n    simpa using mul_le_mul_right' (one_le_iff_ne_zero.2 e0) (ordinal.omega)\n#align repr_opow_aux₁ repr_opow_aux₁\n\n",
 "repr_opow":
 "theorem repr_opow (a b) : repr (opow a b) = repr a ^ repr b :=\n  onote.repr_opow a.1 b.1\n#align repr_opow repr_opow\n\n",
 "repr_one":
 "@[simp]\ntheorem repr_one : repr 1 = 1 := by simpa using repr_of_nat 1\n#align repr_one repr_one\n\n",
 "repr_of_nat":
 "@[simp]\ntheorem repr_of_nat (n : ℕ) : repr (of_nat n) = n := by cases n <;> simp\n#align repr_of_nat repr_of_nat\n\n",
 "repr_mul":
 "theorem repr_mul (a b) : repr (a * b) = repr a * repr b :=\n  onote.repr_mul a.1 b.1\n#align repr_mul repr_mul\n\n",
 "repr_lt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.omega -/\ntheorem NF_below.repr_lt {o b} (h : NF_below o b) : repr o < ordinal.omega ^ b :=\n  by\n  induction' h with _ e n a eb b h₁ h₂ h₃ _ IH\n  · exact opow_pos _ omega_pos\n  · rw [repr]\n    apply ((add_lt_add_iff_left _).2 IH).trans_le\n    rw [← mul_succ]\n    apply (mul_le_mul_left' (succ_le_of_lt (nat_lt_omega _)) _).trans\n    rw [← opow_succ]\n    exact opow_le_opow_right omega_pos (succ_le_of_lt h₃)\n#align NF_below.repr_lt NF_below.repr_lt\n\n",
 "repr_inj":
 "theorem repr_inj {a b} [NF a] [NF b] : repr a = repr b ↔ a = b :=\n  ⟨match cmp a b, cmp_compares a b with\n    | ordering.lt, (h : repr a < repr b), e => (ne_of_lt h e).elim\n    | ordering.gt, (h : repr a > repr b), e => (ne_of_gt h e).elim\n    | ordering.eq, h, e => h,\n    congr_arg _⟩\n#align repr_inj repr_inj\n\n",
 "repr_add":
 "theorem repr_add (a b) : repr (a + b) = repr a + repr b :=\n  onote.repr_add a.1 b.1\n#align repr_add repr_add\n\n",
 "opow_def":
 "theorem opow_def (o₁ o₂ : onote) : o₁ ^ o₂ = opow._match_1 o₂ (split o₁) :=\n  rfl\n#align opow_def opow_def\n\n",
 "omega_le_oadd":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.omega -/\ntheorem omega_le_oadd (e n a) : ordinal.omega ^ repr e ≤ repr (oadd e n a) :=\n  by\n  unfold repr\n  refine' le_trans _ (le_add_right _ _)\n  simpa using (mul_le_mul_iff_left <| opow_pos (repr e) omega_pos).2 (nat_cast_le.2 n.2)\n#align omega_le_oadd omega_le_oadd\n\n",
 "of_nat_one":
 "@[simp]\ntheorem of_nat_one : of_nat 1 = 1 :=\n  rfl\n#align of_nat_one of_nat_one\n\n",
 "of_dvd_omega_opow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.omega -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.omega -/\ntheorem NF.of_dvd_omega_opow {b e n a} (h : NF (oadd e n a)) (d : ordinal.omega ^ b ∣ repr (oadd e n a)) :\n    b ≤ repr e ∧ ordinal.omega ^ b ∣ repr a :=\n  by\n  have := mt repr_inj.1 (fun h => by injection h : oadd e n a ≠ 0)\n  have L := le_of_not_lt fun l => not_le_of_lt (h.below_of_lt l).repr_lt (le_of_dvd this d)\n  simp at d\n  exact ⟨L, (dvd_add_iff <| (opow_dvd_opow _ L).mul_right _).1 d⟩\n#align NF.of_dvd_omega_opow NF.of_dvd_omega_opow\n\n",
 "of_dvd_omega":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.omega -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.omega -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.omega -/\ntheorem NF.of_dvd_omega {e n a} (h : NF (oadd e n a)) :\n    ordinal.omega ∣ repr (oadd e n a) → repr e ≠ 0 ∧ ordinal.omega ∣ repr a := by\n  rw [← opow_one (ordinal.omega), ← one_le_iff_ne_zero] <;> exact h.of_dvd_omega_opow\n#align NF.of_dvd_omega NF.of_dvd_omega\n\n",
 "oadd_pos":
 "theorem oadd_pos (e n a) : 0 < oadd e n a :=\n  @lt_of_lt_of_le _ _ _ _ _ (opow_pos _ omega_pos) (omega_le_oadd _ _ _)\n#align oadd_pos oadd_pos\n\n",
 "oadd_mul_NF_below":
 "theorem oadd_mul_NF_below {e₁ n₁ a₁ b₁} (h₁ : NF_below (oadd e₁ n₁ a₁) b₁) :\n    ∀ {o₂ b₂}, NF_below o₂ b₂ → NF_below (oadd e₁ n₁ a₁ * o₂) (repr e₁ + b₂)\n  | 0, b₂, h₂ => NF_below.zero\n  | oadd e₂ n₂ a₂, b₂, h₂ => by\n    have IH := oadd_mul_NF_below h₂.snd\n    by_cases e0 : e₂ = 0 <;> simp [e0, oadd_mul]\n    · apply NF_below.oadd h₁.fst h₁.snd\n      simpa using (add_lt_add_iff_left (repr e₁)).2 (lt_of_le_of_lt (ordinal.zero_le _) h₂.lt)\n    · haveI := h₁.fst\n      haveI := h₂.fst\n      apply NF_below.oadd\n      infer_instance\n      · rwa [repr_add]\n      · rw [repr_add, add_lt_add_iff_left]\n        exact h₂.lt\n#align oadd_mul_NF_below oadd_mul_NF_below\n\n",
 "oadd_mul":
 "theorem oadd_mul (e₁ n₁ a₁ e₂ n₂ a₂) :\n    oadd e₁ n₁ a₁ * oadd e₂ n₂ a₂ = if e₂ = 0 then oadd e₁ (n₁ * n₂) a₁ else oadd (e₁ + e₂) n₂ (oadd e₁ n₁ a₁ * a₂) :=\n  rfl\n#align oadd_mul oadd_mul\n\n",
 "oadd_lt_oadd_3":
 "theorem oadd_lt_oadd_3 {e n a₁ a₂} (h : a₁ < a₂) : oadd e n a₁ < oadd e n a₂ :=\n  by\n  rw [lt_def]; unfold repr\n  exact add_lt_add_left h _\n#align oadd_lt_oadd_3 oadd_lt_oadd_3\n\n",
 "oadd_lt_oadd_2":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ+» -/\ntheorem oadd_lt_oadd_2 {e o₁ o₂ : onote} {n₁ n₂ : «exprℕ+»} (h₁ : NF (oadd e n₁ o₁)) (h : (n₁ : ℕ) < n₂) :\n    oadd e n₁ o₁ < oadd e n₂ o₂ := by\n  simp [lt_def]\n  refine' lt_of_lt_of_le ((add_lt_add_iff_left _).2 h₁.snd'.repr_lt) (le_trans _ (le_add_right _ _))\n  rwa [← mul_succ, mul_le_mul_iff_left (opow_pos _ omega_pos), succ_le_iff, nat_cast_lt]\n#align oadd_lt_oadd_2 oadd_lt_oadd_2\n\n",
 "oadd_lt_oadd_1":
 "theorem oadd_lt_oadd_1 {e₁ n₁ o₁ e₂ n₂ o₂} (h₁ : NF (oadd e₁ n₁ o₁)) (h : e₁ < e₂) : oadd e₁ n₁ o₁ < oadd e₂ n₂ o₂ :=\n  @lt_of_lt_of_le _ _ _ _ _ (h₁.below_of_lt h).repr_lt (omega_le_oadd _ _ _)\n#align oadd_lt_oadd_1 oadd_lt_oadd_1\n\n",
 "oadd_add":
 "theorem oadd_add (e n a o) : oadd e n a + o = add._match_1 e n (a + o) :=\n  rfl\n#align oadd_add oadd_add\n\n",
 "oadd":
 "theorem NF.oadd {e a} (h₁ : NF e) (n) (h₂ : NF_below a (repr e)) : NF (oadd e n a) :=\n  ⟨⟨_, NF_below.oadd h₁ h₂ (lt_succ _)⟩⟩\n#align NF.oadd NF.oadd\n\n",
 "mul_nat_eq_mul":
 "@[simp]\ntheorem mul_nat_eq_mul (n o) : mul_nat o n = o * of_nat n := by cases o <;> cases n <;> rfl\n#align mul_nat_eq_mul mul_nat_eq_mul\n\n",
 "mono":
 "theorem NF_below.mono {o b₁ b₂} (bb : b₁ ≤ b₂) (h : NF_below o b₁) : NF_below o b₂ :=\n  by\n  induction' h with _ e n a eb b h₁ h₂ h₃ _ IH <;> constructor\n  exacts[h₁, h₂, lt_of_lt_of_le h₃ bb]\n#align NF_below.mono NF_below.mono\n\n",
 "lt_wf":
 "theorem lt_wf : @well_founded nonote (· < ·) :=\n  inv_image.wf repr ordinal.lt_wf\n#align lt_wf lt_wf\n\n",
 "lt_def":
 "theorem lt_def {x y : onote} : x < y ↔ repr x < repr y :=\n  iff.rfl\n#align lt_def lt_def\n\n",
 "lt":
 "theorem NF_below.lt {e n a b} (h : NF_below (oadd e n a) b) : repr e < b := by\n  cases' h with _ _ _ _ eb _ h₁ h₂ h₃ <;> exact h₃\n#align NF_below.lt NF_below.lt\n\n",
 "le_def":
 "theorem le_def {x y : onote} : x ≤ y ↔ repr x ≤ repr y :=\n  iff.rfl\n#align le_def le_def\n\n",
 "fundamental_sequence_has_prop":
 "theorem fundamental_sequence_has_prop (o) : fundamental_sequence_prop o (fundamental_sequence o) :=\n  by\n  induction' o with a m b iha ihb; · exact rfl\n  rw [fundamental_sequence]\n  rcases e : b.fundamental_sequence with (⟨_ | b'⟩ | f) <;>\n      simp only [fundamental_sequence, fundamental_sequence_prop] <;>\n    rw [e, fundamental_sequence_prop] at ihb\n  · rcases e : a.fundamental_sequence with (⟨_ | a'⟩ | f) <;> cases' e' : m.nat_pred with m' <;>\n              simp only [fundamental_sequence, fundamental_sequence_prop] <;>\n            rw [e, fundamental_sequence_prop] at iha <;>\n          try rw [show m = 1 by have := PNat.natPred_add_one m; rw [e'] at this; exact PNat.coe_inj.1 this.symm] <;>\n        try\n          rw [show m = m'.succ.succ_pnat by\n              rw [← e', ← PNat.coe_inj, Nat.succPNat_coe, ← nat.add_one, PNat.natPred_add_one]] <;>\n      simp only [repr, iha, ihb, opow_lt_opow_iff_right one_lt_omega, add_lt_add_iff_left, add_zero, coe_coe,\n        eq_self_iff_true, lt_add_iff_pos_right, lt_def, mul_one, Nat.cast_zero, Nat.cast_succ, Nat.succPNat_coe,\n        opow_succ, opow_zero, mul_add_one, PNat.one_coe, succ_zero, true_and_iff, _root_.zero_add, zero_def]\n    · infer_instance\n    · exact ⟨rfl, infer_instance⟩\n    · have := opow_pos _ omega_pos\n      refine'\n        ⟨mul_is_limit this omega_is_limit, fun i => ⟨this, _, fun H => @NF.oadd_zero _ _ (iha.2 H.fst)⟩,\n          exists_lt_mul_omega'⟩\n      rw [← mul_succ, ← nat_cast_succ, ordinal.mul_lt_mul_iff_left this]\n      apply nat_lt_omega\n    · have := opow_pos _ omega_pos\n      refine'\n        ⟨add_is_limit _ (mul_is_limit this omega_is_limit), fun i => ⟨this, _, _⟩, exists_lt_add exists_lt_mul_omega'⟩\n      · rw [← mul_succ, ← nat_cast_succ, ordinal.mul_lt_mul_iff_left this]\n        apply nat_lt_omega\n      · refine' fun H => H.fst.oadd _ (NF.below_of_lt' _ (@NF.oadd_zero _ _ (iha.2 H.fst)))\n        rw [repr, repr, add_zero, iha.1, opow_succ, ordinal.mul_lt_mul_iff_left this]\n        apply nat_lt_omega\n    · rcases iha with ⟨h1, h2, h3⟩\n      refine' ⟨opow_is_limit one_lt_omega h1, fun i => _, exists_lt_omega_opow' one_lt_omega h1 h3⟩\n      obtain ⟨h4, h5, h6⟩ := h2 i\n      exact ⟨h4, h5, fun H => @NF.oadd_zero _ _ (h6 H.fst)⟩\n    · rcases iha with ⟨h1, h2, h3⟩\n      refine'\n        ⟨add_is_limit _ (opow_is_limit one_lt_omega h1), fun i => _,\n          exists_lt_add (exists_lt_omega_opow' one_lt_omega h1 h3)⟩\n      obtain ⟨h4, h5, h6⟩ := h2 i\n      refine' ⟨h4, h5, fun H => H.fst.oadd _ (NF.below_of_lt' _ (@NF.oadd_zero _ _ (h6 H.fst)))⟩\n      rwa [repr, repr, add_zero, coe_coe, PNat.one_coe, Nat.cast_one, mul_one, opow_lt_opow_iff_right one_lt_omega]\n  · refine' ⟨by rw [repr, ihb.1, add_succ, repr], fun H => H.fst.oadd _ (NF.below_of_lt' _ (ihb.2 H.snd))⟩\n    have := H.snd'.repr_lt\n    rw [ihb.1] at this\n    exact (lt_succ _).trans this\n  · rcases ihb with ⟨h1, h2, h3⟩\n    simp only [repr]\n    exact\n      ⟨ordinal.add_is_limit _ h1, fun i =>\n        ⟨oadd_lt_oadd_3 (h2 i).1, oadd_lt_oadd_3 (h2 i).2.1, fun H =>\n          H.fst.oadd _ (NF.below_of_lt' (lt_trans (h2 i).2.1 H.snd'.repr_lt) ((h2 i).2.2 H.snd))⟩,\n        exists_lt_add h3⟩\n#align fundamental_sequence_has_prop fundamental_sequence_has_prop\n\n",
 "fst":
 "theorem NF.fst {e n a} : NF (oadd e n a) → NF e\n  | ⟨⟨b, h⟩⟩ => h.fst\n#align NF.fst NF.fst\n\n",
 "fast_growing_ε₀_zero":
 "theorem fast_growing_ε₀_zero : fast_growing_ε₀ 0 = 1 := by simp [fast_growing_ε₀]\n#align fast_growing_ε₀_zero fast_growing_ε₀_zero\n\n",
 "fast_growing_ε₀_two":
 "theorem fast_growing_ε₀_two : fast_growing_ε₀ 2 = 2048 := by\n  norm_num [fast_growing_ε₀, show oadd 0 1 0 = 1 from rfl, @fast_growing_limit (oadd 1 1 0) _ rfl,\n    show oadd 0 (2 : nat).succ_pnat 0 = 3 from rfl, @fast_growing_succ 3 2 rfl]\n#align fast_growing_ε₀_two fast_growing_ε₀_two\n\n",
 "fast_growing_ε₀_one":
 "theorem fast_growing_ε₀_one : fast_growing_ε₀ 1 = 2 := by simp [fast_growing_ε₀, show oadd 0 1 0 = 1 from rfl]\n#align fast_growing_ε₀_one fast_growing_ε₀_one\n\n",
 "fast_growing_zero'":
 "theorem fast_growing_zero' (o : onote) (h : fundamental_sequence o = sum.inl none) : fast_growing o = nat.succ :=\n  by\n  rw [fast_growing_def h]\n  rfl\n#align fast_growing_zero' fast_growing_zero'\n\n",
 "fast_growing_zero":
 "@[simp]\ntheorem fast_growing_zero : fast_growing 0 = nat.succ :=\n  fast_growing_zero' _ rfl\n#align fast_growing_zero fast_growing_zero\n\n",
 "fast_growing_two":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `pow -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `pow -/\n@[simp]\ntheorem fast_growing_two : fast_growing 2 = fun n => pow 2 n * n :=\n  by\n  rw [@fast_growing_succ 2 1 rfl]; funext i; rw [fast_growing_one]\n  suffices : ∀ a b, («expr ^[ ]» (fun n : ℕ => 2 * n) a) b = pow 2 a * b; exact this _ _\n  intro a b; induction a <;> simp [*, function.iterate_succ', pow_succ, mul_assoc]\n#align fast_growing_two fast_growing_two\n\n",
 "fast_growing_succ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\ntheorem fast_growing_succ (o) {a} (h : fundamental_sequence o = sum.inl (some a)) :\n    fast_growing o = fun i => («expr ^[ ]» (fast_growing a) i) i :=\n  by\n  rw [fast_growing_def h]\n  rfl\n#align fast_growing_succ fast_growing_succ\n\n",
 "fast_growing_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\n@[simp]\ntheorem fast_growing_one : fast_growing 1 = fun n => 2 * n :=\n  by\n  rw [@fast_growing_succ 1 0 rfl]; funext i; rw [two_mul, fast_growing_zero]\n  suffices : ∀ a b, («expr ^[ ]» nat.succ a) b = b + a; exact this _ _\n  intro a b; induction a <;> simp [*, function.iterate_succ', nat.add_succ]\n#align fast_growing_one fast_growing_one\n\n",
 "fast_growing_limit":
 "theorem fast_growing_limit (o) {f} (h : fundamental_sequence o = sum.inr f) :\n    fast_growing o = fun i => fast_growing (f i) i :=\n  by\n  rw [fast_growing_def h]\n  rfl\n#align fast_growing_limit fast_growing_limit\n\n",
 "fast_growing_def":
 "theorem fast_growing_def {o : onote} {x} (e : fundamental_sequence o = x) :\n    fast_growing o =\n      fast_growing._match_1 o (fun a _ _ => a.fast_growing) (fun f _ i _ => (f i).fast_growing i) x\n        (e ▸ fundamental_sequence_has_prop _) :=\n  by\n  subst x\n  rw [fast_growing]\n#align fast_growing_def fast_growing_def\n\n",
 "exists_lt_omega_opow'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.pow -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.pow -/\nprivate theorem exists_lt_omega_opow' {α} {o b : ordinal} (hb : 1 < b) (ho : o.is_limit) {f : α → ordinal}\n    (H : ∀ ⦃a⦄, a < o → ∃ i, a < f i) ⦃a⦄ (h : a < ordinal.pow b o) : ∃ i, a < ordinal.pow b (f i) :=\n  by\n  obtain ⟨d, hd, h'⟩ := (lt_opow_of_limit (zero_lt_one.trans hb).ne' ho).1 h\n  exact (H hd).imp fun i hi => h'.trans <| (opow_lt_opow_iff_right hb).2 hi\n#align exists_lt_omega_opow' exists_lt_omega_opow'\n\n",
 "exists_lt_mul_omega'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.omega -/\nprivate theorem exists_lt_mul_omega' {o : ordinal} ⦃a⦄ (h : a < o * ordinal.omega) : ∃ i : ℕ, a < o * ↑i + o :=\n  by\n  obtain ⟨i, hi, h'⟩ := (lt_mul_of_limit omega_is_limit).1 h\n  obtain ⟨i, rfl⟩ := lt_omega.1 hi\n  exact ⟨i, h'.trans_le (le_add_right _ _)⟩\n#align exists_lt_mul_omega' exists_lt_mul_omega'\n\n",
 "exists_lt_add":
 "private theorem exists_lt_add {α} [hα : nonempty α] {o : ordinal} {f : α → ordinal} (H : ∀ ⦃a⦄, a < o → ∃ i, a < f i)\n    {b : ordinal} ⦃a⦄ (h : a < b + o) : ∃ i, a < b + f i :=\n  by\n  cases' lt_or_le a b with h h'\n  · obtain ⟨i⟩ := id hα\n    exact ⟨i, h.trans_le (le_add_right _ _)⟩\n  · rw [← ordinal.add_sub_cancel_of_le h', add_lt_add_iff_left] at h\n    refine' (H h).imp fun i H => _\n    rwa [← ordinal.add_sub_cancel_of_le h', add_lt_add_iff_left]\n#align exists_lt_add exists_lt_add\n\n",
 "eq_of_cmp_eq":
 "theorem eq_of_cmp_eq : ∀ {o₁ o₂}, cmp o₁ o₂ = ordering.eq → o₁ = o₂\n  | 0, 0, h => rfl\n  | oadd e n a, 0, h => by injection h\n  | 0, oadd e n a, h => by injection h\n  | o₁@(oadd e₁ n₁ a₁), o₂@(oadd e₂ n₂ a₂), h => by\n    revert h; simp only [cmp]\n    cases h₁ : cmp e₁ e₂ <;> intro h <;> try cases h\n    obtain rfl := eq_of_cmp_eq h₁\n    revert h; cases h₂ : _root_.cmp (n₁ : ℕ) n₂ <;> intro h <;> try cases h\n    obtain rfl := eq_of_cmp_eq h\n    rw [_root_.cmp, cmp_using_eq_eq] at h₂\n    obtain rfl := subtype.eq (eq_of_incomp h₂)\n    simp\n#align eq_of_cmp_eq eq_of_cmp_eq\n\n",
 "cmp_compares":
 "#print cmp_compares /-\ntheorem cmp_compares : ∀ a b : nonote, (cmp a b).compares a b\n  | ⟨a, ha⟩, ⟨b, hb⟩ => by\n    skip\n    dsimp [cmp]; have := onote.cmp_compares a b\n    cases onote.cmp a b <;> try exact this\n    exact subtype.mk_eq_mk.2 this\n#align cmp_compares cmp_compares\n-/\n\n",
 "below_of_lt'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.omega -/\ntheorem NF.below_of_lt' : ∀ {o b}, repr o < ordinal.omega ^ b → NF o → NF_below o b\n  | 0, b, H, _ => NF_below.zero\n  | oadd e n a, b, H, h =>\n    h.below_of_lt <| (opow_lt_opow_iff_right one_lt_omega).1 <| lt_of_le_of_lt (omega_le_oadd _ _ _) H\n#align NF.below_of_lt' NF.below_of_lt'\n\n",
 "below_of_lt":
 "theorem NF.below_of_lt {e n a b} (H : repr e < b) : NF (oadd e n a) → NF_below (oadd e n a) b\n  | ⟨⟨b', h⟩⟩ => by cases' h with _ _ _ _ eb _ h₁ h₂ h₃ <;> exact NF_below.oadd' h₁ h₂ H\n#align NF.below_of_lt NF.below_of_lt\n\n",
 "add_NF_below":
 "theorem add_NF_below {b} : ∀ {o₁ o₂}, NF_below o₁ b → NF_below o₂ b → NF_below (o₁ + o₂) b\n  | 0, o, h₁, h₂ => h₂\n  | oadd e n a, o, h₁, h₂ => by\n    have h' := add_NF_below (h₁.snd.mono <| le_of_lt h₁.lt) h₂\n    simp [oadd_add]; cases' a + o with e' n' a'\n    · exact NF_below.oadd h₁.fst NF_below.zero h₁.lt\n    simp [add]; have := @cmp_compares _ _ h₁.fst h'.fst\n    cases cmp e e' <;> simp [add]\n    · exact h'\n    · simp at this\n      subst e'\n      exact NF_below.oadd h'.fst h'.snd h'.lt\n    · exact NF_below.oadd h₁.fst (NF.below_of_lt this ⟨⟨_, h'⟩⟩) h₁.lt\n#align add_NF_below add_NF_below\n\n",
 "NF_repr_split'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.omega -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.omega -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.omega -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.omega -/\ntheorem NF_repr_split' : ∀ {o o' m} [NF o], split' o = (o', m) → NF o' ∧ repr o = ordinal.omega * repr o' + m\n  | 0, o', m, h, p => by injection p <;> substs o' m <;> simp [NF.zero]\n  | oadd e n a, o', m, h, p => by\n    by_cases e0 : e = 0 <;> simp [e0, split, split'] at p⊢\n    · rcases p with ⟨rfl, rfl⟩\n      simp [h.zero_of_zero e0, NF.zero]\n    · revert p\n      cases' h' : split' a with a' m'\n      haveI := h.fst\n      haveI := h.snd\n      cases' NF_repr_split' h' with IH₁ IH₂\n      simp [IH₂, split']\n      intros\n      substs o' m\n      have :\n        (ordinal.omega : ordinal.{0}) ^ repr e = ordinal.omega ^ (1 : ordinal.{0}) * ordinal.omega ^ (repr e - 1) :=\n        by\n        have := mt repr_inj.1 e0\n        rw [← opow_add, ordinal.add_sub_cancel_of_le (one_le_iff_ne_zero.2 this)]\n      refine' ⟨NF.oadd (by infer_instance) _ _, _⟩\n      · simp at this⊢\n        refine' IH₁.below_of_lt' ((mul_lt_mul_iff_left omega_pos).1 <| lt_of_le_of_lt (le_add_right _ m') _)\n        rw [← this, ← IH₂]\n        exact h.snd'.repr_lt\n      · rw [this]\n        simp [mul_add, mul_assoc, add_assoc]\n#align NF_repr_split' NF_repr_split'\n\n",
 "NF_repr_split":
 "theorem NF_repr_split {o o' m} [NF o] (h : split o = (o', m)) : NF o' ∧ repr o = repr o' + m :=\n  by\n  cases' e : split' o with a n\n  cases' NF_repr_split' e with s₁ s₂; skip\n  rw [split_eq_scale_split' e] at h\n  injection h; substs o' n\n  simp [repr_scale, s₂.symm]\n  infer_instance\n#align NF_repr_split NF_repr_split\n\n",
 "NF_below_zero":
 "theorem NF_below_zero : ∀ {o}, NF_below o 0 ↔ o = 0\n  | 0 => ⟨fun _ => rfl, fun _ => NF_below.zero⟩\n  | oadd e n a => ⟨fun h => (not_le_of_lt h.lt).elim (ordinal.zero_le _), fun e => e.symm ▸ NF_below.zero⟩\n#align NF_below_zero NF_below_zero\n\n",
 "NF_below_of_nat":
 "theorem NF_below_of_nat : ∀ n, NF_below (of_nat n) 1\n  | 0 => NF_below.zero\n  | nat.succ n => NF_below.oadd NF.zero NF_below.zero zero_lt_one\n#align NF_below_of_nat NF_below_of_nat\n\n",
 "NF_below_iff_top_below":
 "theorem NF_below_iff_top_below {b} [NF b] : ∀ {o}, NF_below o (repr b) ↔ NF o ∧ top_below b o\n  | 0 => ⟨fun h => ⟨⟨⟨_, h⟩⟩, trivial⟩, fun _ => NF_below.zero⟩\n  | oadd e n a =>\n    ⟨fun h => ⟨⟨⟨_, h⟩⟩, (@cmp_compares _ b h.fst _).eq_lt.2 h.lt⟩, fun ⟨h₁, h₂⟩ =>\n      h₁.below_of_lt <| (@cmp_compares _ b h₁.fst _).eq_lt.1 h₂⟩\n#align NF_below_iff_top_below NF_below_iff_top_below\n\n"}