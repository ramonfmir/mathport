{"mem_closure_iff_sup":
 "theorem mem_closure_iff_sup :\n    a ∈ closure s ↔ ∃ (ι : Type u)(_ : nonempty ι)(f : ι → ordinal), (∀ i, f i ∈ s) ∧ sup.{u, u} f = a :=\n  by\n  refine' mem_closure_iff.trans ⟨fun h => _, _⟩\n  · by_cases has : a ∈ s\n    · exact ⟨PUnit, by infer_instance, fun _ => a, fun _ => has, sup_const a⟩\n    · have H := fun b (hba : b < a) => h _ (@is_open_Ioo _ _ _ _ b (a + 1)) ⟨hba, lt_succ a⟩\n      let f : a.out.α → ordinal := fun i => Classical.choose (H (typein (· < ·) i) (typein_lt_self i))\n      have hf : ∀ i, f i ∈ Set.Ioo (typein (· < ·) i) (a + 1) ∩ s := fun i => Classical.choose_spec (H _ _)\n      rcases eq_zero_or_pos a with (rfl | ha₀)\n      · rcases h _ (is_open_singleton_iff.2 not_zero_is_limit) rfl with ⟨b, hb, hb'⟩\n        rw [Set.mem_singleton_iff.1 hb] at *\n        exact (has hb').elim\n      refine'\n        ⟨_, out_nonempty_iff_ne_zero.2 (ordinal.pos_iff_ne_zero.1 ha₀), f, fun i => (hf i).2,\n          le_antisymm (sup_le fun i => le_of_lt_succ (hf i).1.2) _⟩\n      by_contra' h\n      cases' H _ h with b hb\n      rcases eq_or_lt_of_le (le_of_lt_succ hb.1.2) with (rfl | hba)\n      · exact has hb.2\n      · have : b < f (enum (· < ·) b (by rwa [type_lt])) :=\n          by\n          have := (hf (enum (· < ·) b (by rwa [type_lt]))).1.1\n          rwa [typein_enum] at this\n        have : b ≤ sup.{u, u} f := this.le.trans (le_sup f _)\n        exact this.not_lt hb.1.1\n  · rintro ⟨ι, ⟨i⟩, f, hf, rfl⟩ t ht hat\n    cases' eq_zero_or_pos (sup.{u, u} f) with ha₀ ha₀\n    · rw [ha₀] at hat\n      use 0, hat\n      convert hf i\n      exact (sup_eq_zero_iff.1 ha₀ i).symm\n    rcases(mem_nhds_iff_exists_Ioo_subset' ⟨0, ha₀⟩ ⟨_, lt_succ _⟩).1 (ht.mem_nhds hat) with ⟨b, c, ⟨hab, hac⟩, hbct⟩\n    cases' lt_sup.1 hab with i hi\n    exact ⟨_, hbct ⟨hi, (le_sup.{u, u} f i).trans_lt hac⟩, hf i⟩\n#align mem_closure_iff_sup mem_closure_iff_sup\n\n",
 "mem_closure_iff_bsup":
 "theorem mem_closure_iff_bsup :\n    a ∈ closure s ↔ ∃ (o : ordinal)(ho : o ≠ 0)(f : ∀ a < o, ordinal), (∀ i hi, f i hi ∈ s) ∧ bsup.{u, u} o f = a :=\n  mem_closure_iff_sup.trans\n    ⟨fun ⟨ι, ⟨i⟩, f, hf, ha⟩ =>\n      ⟨_, fun h => (type_eq_zero_iff_is_empty.1 h).elim i, bfamily_of_family f, fun i hi => hf _, by rwa [bsup_eq_sup]⟩,\n      fun ⟨o, ho, f, hf, ha⟩ =>\n      ⟨_, out_nonempty_iff_ne_zero.2 ho, family_of_bfamily o f, fun i => hf _ _, by rwa [sup_eq_bsup]⟩⟩\n#align mem_closure_iff_bsup mem_closure_iff_bsup\n\n",
 "mem_closed_iff_sup":
 "theorem mem_closed_iff_sup (hs : is_closed s) :\n    a ∈ s ↔ ∃ (ι : Type u)(hι : nonempty ι)(f : ι → ordinal), (∀ i, f i ∈ s) ∧ sup.{u, u} f = a := by\n  rw [← mem_closure_iff_sup, hs.closure_eq]\n#align mem_closed_iff_sup mem_closed_iff_sup\n\n",
 "mem_closed_iff_bsup":
 "theorem mem_closed_iff_bsup (hs : is_closed s) :\n    a ∈ s ↔ ∃ (o : ordinal)(ho : o ≠ 0)(f : ∀ a < o, ordinal), (∀ i hi, f i hi ∈ s) ∧ bsup.{u, u} o f = a := by\n  rw [← mem_closure_iff_bsup, hs.closure_eq]\n#align mem_closed_iff_bsup mem_closed_iff_bsup\n\n",
 "is_open_singleton_iff":
 "/-\nCopyright (c) 2022 Violeta Hernández Palacios. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Violeta Hernández Palacios\n-/\ntheorem is_open_singleton_iff : is_open ({a} : set ordinal) ↔ ¬is_limit a :=\n  by\n  refine' ⟨fun h ha => _, fun ha => _⟩\n  · obtain ⟨b, c, hbc, hbc'⟩ :=\n      (mem_nhds_iff_exists_Ioo_subset' ⟨0, ordinal.pos_iff_ne_zero.2 ha.1⟩ ⟨_, lt_succ a⟩).1 (h.mem_nhds rfl)\n    have hba := ha.2 b hbc.1\n    exact hba.ne (hbc' ⟨lt_succ b, hba.trans hbc.2⟩)\n  · rcases zero_or_succ_or_limit a with (rfl | ⟨b, hb⟩ | ha')\n    · convert is_open_gt' (1 : ordinal)\n      ext\n      exact ordinal.lt_one_iff_zero.symm\n    · convert @is_open_Ioo _ _ _ _ b (a + 1)\n      ext c\n      refine' ⟨fun hc => _, _⟩\n      · rw [Set.mem_singleton_iff.1 hc]\n        refine' ⟨_, lt_succ a⟩\n        rw [hb]\n        exact lt_succ b\n      · rintro ⟨hc, hc'⟩\n        apply le_antisymm (le_of_lt_succ hc')\n        rw [hb]\n        exact succ_le_of_lt hc\n    · exact (ha ha').elim\n#align is_open_singleton_iff is_open_singleton_iff\n\n",
 "is_open_iff":
 "theorem is_open_iff : is_open s ↔ ∀ o ∈ s, is_limit o → ∃ a < o, Set.Ioo a o ⊆ s := by\n  classical\n    refine' ⟨_, fun h => _⟩\n    · rw [is_open_iff_generate_intervals]\n      intro h o hos ho\n      have ho₀ := ordinal.pos_iff_ne_zero.2 ho.1\n      induction' h with t ht t u ht hu ht' hu' t ht H\n      · rcases ht with ⟨a, rfl | rfl⟩\n        · exact ⟨a, hos, fun b hb => hb.1⟩\n        · exact ⟨0, ho₀, fun b hb => hb.2.trans hos⟩\n      · exact ⟨0, ho₀, fun b _ => Set.mem_univ b⟩\n      · rcases ht' hos.1 with ⟨a, ha, ha'⟩\n        rcases hu' hos.2 with ⟨b, hb, hb'⟩\n        exact\n          ⟨_, max_lt ha hb, fun c hc =>\n            ⟨ha' ⟨(le_max_left a b).trans_lt hc.1, hc.2⟩, hb' ⟨(le_max_right a b).trans_lt hc.1, hc.2⟩⟩⟩\n      · rcases hos with ⟨u, hu, hu'⟩\n        rcases H u hu hu' with ⟨a, ha, ha'⟩\n        exact ⟨a, ha, fun b hb => ⟨u, hu, ha' hb⟩⟩\n    · let f : s → set ordinal := fun o =>\n        if ho : is_limit o.val then Set.Ioo (Classical.choose (h o.val o.prop ho)) (o + 1) else {o.val}\n      have : ∀ a, is_open (f a) := fun a => by\n        change is_open (dite _ _ _)\n        split_ifs\n        · exact is_open_Ioo\n        · rwa [is_open_singleton_iff]\n      convert is_open_Union this\n      ext o\n      refine' ⟨fun ho => Set.mem_unionᵢ.2 ⟨⟨o, ho⟩, _⟩, _⟩\n      · split_ifs with ho'\n        · refine' ⟨_, lt_succ o⟩\n          cases' Classical.choose_spec (h o ho ho') with H\n          exact H\n        · exact Set.mem_singleton o\n      · rintro ⟨t, ⟨a, ht⟩, hoa⟩\n        change dite _ _ _ = t at ht\n        split_ifs  at ht with ha <;> subst ht\n        · cases' Classical.choose_spec (h a.val a.prop ha) with H has\n          rcases lt_or_eq_of_le (le_of_lt_succ hoa.2) with (hoa' | rfl)\n          · exact has ⟨hoa.1, hoa'⟩\n          · exact a.prop\n        · convert a.prop\n#align is_open_iff is_open_iff\n\n",
 "is_normal_iff_strict_mono_and_continuous":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem is_normal_iff_strict_mono_and_continuous (f : ordinal.{u} → ordinal.{u}) :\n    is_normal f ↔ strict_mono f ∧ continuous f :=\n  by\n  refine' ⟨fun h => ⟨h.strict_mono, _⟩, _⟩\n  · rw [continuous_def]\n    intro s hs\n    rw [is_open_iff] at *\n    intro o ho ho'\n    rcases hs _ ho (h.is_limit ho') with ⟨a, ha, has⟩\n    rw [← is_normal.bsup_eq.{u, u} h ho', lt_bsup] at ha\n    rcases ha with ⟨b, hb, hab⟩\n    exact ⟨b, hb, fun c hc => Set.mem_preimage.2 (has ⟨hab.trans (h.strict_mono hc.1), h.strict_mono hc.2⟩)⟩\n  · rw [is_normal_iff_strict_mono_limit]\n    rintro ⟨h, h'⟩\n    refine' ⟨h, fun o ho a h => _⟩\n    suffices : o ∈ «expr ⁻¹' » f (Set.Iic a)\n    exact Set.mem_preimage.1 this\n    rw [mem_closed_iff_sup (is_closed.preimage h' (@is_closed_Iic _ _ _ _ a))]\n    exact ⟨_, out_nonempty_iff_ne_zero.2 ho.1, typein (· < ·), fun i => h _ (typein_lt_self i), sup_typein_limit ho.2⟩\n#align is_normal_iff_strict_mono_and_continuous is_normal_iff_strict_mono_and_continuous\n\n",
 "is_limit_of_mem_frontier":
 "theorem is_limit_of_mem_frontier (ha : a ∈ frontier s) : is_limit a :=\n  by\n  simp only [frontier_eq_closure_inter_closure, Set.mem_inter_iff, mem_closure_iff] at ha\n  by_contra h\n  rw [← is_open_singleton_iff] at h\n  rcases ha.1 _ h rfl with ⟨b, hb, hb'⟩\n  rcases ha.2 _ h rfl with ⟨c, hc, hc'⟩\n  rw [Set.mem_singleton_iff] at *\n  subst hb; subst hc\n  exact hc' hb'\n#align is_limit_of_mem_frontier is_limit_of_mem_frontier\n\n",
 "is_closed_iff_sup":
 "theorem is_closed_iff_sup :\n    is_closed s ↔ ∀ {ι : Type u} (hι : nonempty ι) (f : ι → ordinal), (∀ i, f i ∈ s) → sup.{u, u} f ∈ s :=\n  by\n  use fun hs ι hι f hf => (mem_closed_iff_sup hs).2 ⟨ι, hι, f, hf, rfl⟩\n  rw [← closure_subset_iff_is_closed]\n  intro h x hx\n  rcases mem_closure_iff_sup.1 hx with ⟨ι, hι, f, hf, rfl⟩\n  exact h hι f hf\n#align is_closed_iff_sup is_closed_iff_sup\n\n",
 "is_closed_iff_bsup":
 "theorem is_closed_iff_bsup :\n    is_closed s ↔ ∀ {o : ordinal} (ho : o ≠ 0) (f : ∀ a < o, ordinal), (∀ i hi, f i hi ∈ s) → bsup.{u, u} o f ∈ s :=\n  by\n  rw [is_closed_iff_sup]\n  refine' ⟨fun H o ho f hf => H (out_nonempty_iff_ne_zero.2 ho) _ _, fun H ι hι f hf => _⟩\n  · exact fun i => hf _ _\n  · rw [← bsup_eq_sup]\n    apply H (type_ne_zero_iff_nonempty.2 hι)\n    exact fun i hi => hf _\n#align is_closed_iff_bsup is_closed_iff_bsup\n\n",
 "enum_ord_is_normal_iff_is_closed":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:632:2: warning: expanding binder collection (b «expr < » a) -/\ntheorem enum_ord_is_normal_iff_is_closed (hs : s.unbounded (· < ·)) : is_normal (enum_ord s) ↔ is_closed s :=\n  by\n  have Hs := enum_ord_strict_mono hs\n  refine'\n    ⟨fun h => is_closed_iff_sup.2 fun ι hι f hf => _, fun h =>\n      (is_normal_iff_strict_mono_limit _).2 ⟨Hs, fun a ha o H => _⟩⟩\n  · let g : ι → ordinal.{u} := fun i => (enum_ord_order_iso hs).symm ⟨_, hf i⟩\n    suffices enum_ord s (sup.{u, u} g) = sup.{u, u} f by\n      rw [← this]\n      exact enum_ord_mem hs _\n    rw [@is_normal.sup.{u, u, u} _ h ι g hι]\n    congr\n    ext\n    change ((enum_ord_order_iso hs) _).val = f x\n    rw [OrderIso.apply_symm_apply]\n  · rw [is_closed_iff_bsup] at h\n    suffices : enum_ord s a ≤ bsup.{u, u} a fun b (_ : b < a) => enum_ord s b\n    exact this.trans (bsup_le H)\n    cases' enum_ord_surjective hs _ (h ha.1 (fun b hb => enum_ord s b) fun b hb => enum_ord_mem hs b) with b hb\n    rw [← hb]\n    apply Hs.monotone\n    by_contra' hba\n    apply (Hs (lt_succ b)).not_le\n    rw [hb]\n    exact le_bsup.{u, u} _ _ (ha.2 _ hba)\n#align enum_ord_is_normal_iff_is_closed enum_ord_is_normal_iff_is_closed\n\n"}