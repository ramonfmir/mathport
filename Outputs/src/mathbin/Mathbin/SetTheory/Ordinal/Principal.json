{"unbounded_principal":
 "theorem unbounded_principal (op : ordinal → ordinal → ordinal) : set.unbounded (· < ·) { o | principal op o } :=\n  fun o => ⟨_, principal_nfp_blsub₂ op o, (le_nfp _ o).not_lt⟩\n#align unbounded_principal unbounded_principal\n\n",
 "principal_zero":
 "theorem principal_zero {op : ordinal → ordinal → ordinal} : principal op 0 := fun a _ h =>\n  (ordinal.not_lt_zero a h).elim\n#align principal_zero principal_zero\n\n",
 "principal_opow_omega":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:219:4: warning: unsupported binary notation `ordinal.pow -/\ntheorem principal_opow_omega : principal (ordinal.pow · ·) omega := fun a b ha hb =>\n  match a, b, lt_omega.1 ha, lt_omega.1 hb with\n  | _, _, ⟨m, rfl⟩, ⟨n, rfl⟩ => by\n    simp_rw [← nat_cast_opow]\n    apply nat_lt_omega\n#align principal_opow_omega principal_opow_omega\n\n",
 "principal_one_iff":
 "@[simp]\ntheorem principal_one_iff {op : ordinal → ordinal → ordinal} : principal op 1 ↔ op 0 0 = 0 :=\n  by\n  refine' ⟨fun h => _, fun h a b ha hb => _⟩\n  · rwa [← lt_one_iff_zero]\n    exact h zero_lt_one zero_lt_one\n  · rwa [lt_one_iff_zero, ha, hb] at *\n#align principal_one_iff principal_one_iff\n\n",
 "principal_nfp_blsub₂":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\ntheorem principal_nfp_blsub₂ (op : ordinal → ordinal → ordinal) (o : ordinal) :\n    principal op (nfp (blsub₂.{u, u} op) o) := fun a b ha hb =>\n  by\n  rw [lt_nfp] at *\n  cases' ha with m hm\n  cases' hb with n hn\n  cases' le_total ((«expr ^[ ]» (blsub₂.{u, u} op) m) o) ((«expr ^[ ]» (blsub₂.{u, u} op) n) o) with h h\n  · use n + 1\n    rw [function.iterate_succ']\n    exact lt_blsub₂ op (hm.trans_le h) hn\n  · use m + 1\n    rw [function.iterate_succ']\n    exact lt_blsub₂ op hm (hn.trans_le h)\n#align principal_nfp_blsub₂ principal_nfp_blsub₂\n\n",
 "principal_mul_two":
 "theorem principal_mul_two : principal (· * ·) 2 := fun a b ha hb =>\n  by\n  have h₂ : succ (1 : ordinal) = 2 := rfl\n  rw [← h₂, lt_succ_iff] at *\n  convert mul_le_mul' ha hb\n  exact (mul_one 1).symm\n#align principal_mul_two principal_mul_two\n\n",
 "principal_mul_one":
 "theorem principal_mul_one : principal (· * ·) 1 :=\n  by\n  rw [principal_one_iff]\n  exact zero_mul _\n#align principal_mul_one principal_mul_one\n\n",
 "principal_mul_omega_opow_opow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.pow -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.pow -/\ntheorem principal_mul_omega_opow_opow (o : ordinal) : principal (· * ·) (ordinal.pow omega (ordinal.pow omega o)) :=\n  principal_mul_iff_mul_left_eq.2 fun a => mul_omega_opow_opow\n#align principal_mul_omega_opow_opow principal_mul_omega_opow_opow\n\n",
 "principal_mul_omega":
 "theorem principal_mul_omega : principal (· * ·) omega := fun a b ha hb =>\n  match a, b, lt_omega.1 ha, lt_omega.1 hb with\n  | _, _, ⟨m, rfl⟩, ⟨n, rfl⟩ => by\n    rw [← nat_cast_mul]\n    apply nat_lt_omega\n#align principal_mul_omega principal_mul_omega\n\n",
 "principal_mul_of_le_two":
 "theorem principal_mul_of_le_two {o : ordinal} (ho : o ≤ 2) : principal (· * ·) o :=\n  by\n  rcases lt_or_eq_of_le ho with (ho | rfl)\n  · have h₂ : succ (1 : ordinal) = 2 := rfl\n    rw [← h₂, lt_succ_iff] at ho\n    rcases lt_or_eq_of_le ho with (ho | rfl)\n    · rw [lt_one_iff_zero.1 ho]\n      exact principal_zero\n    · exact principal_mul_one\n  · exact principal_mul_two\n#align principal_mul_of_le_two principal_mul_of_le_two\n\n",
 "principal_mul_is_limit":
 "theorem principal_mul_is_limit {o : ordinal.{u}} (ho₂ : 2 < o) (ho : principal (· * ·) o) : o.is_limit :=\n  principal_add_is_limit ((lt_succ 1).trans ho₂) (principal_add_of_principal_mul ho (ne_of_gt ho₂))\n#align principal_mul_is_limit principal_mul_is_limit\n\n",
 "principal_mul_iff_mul_left_eq":
 "theorem principal_mul_iff_mul_left_eq {o : ordinal} : principal (· * ·) o ↔ ∀ a, 0 < a → a < o → a * o = o :=\n  by\n  refine' ⟨fun h a ha₀ hao => _, fun h a b hao hbo => _⟩\n  · cases' le_or_gt o 2 with ho ho\n    · convert one_mul o\n      apply le_antisymm\n      · have : a < succ 1 := hao.trans_le ho\n        rwa [lt_succ_iff] at this\n      · rwa [← succ_le_iff, succ_zero] at ha₀\n    · exact op_eq_self_of_principal hao (mul_is_normal ha₀) h (principal_mul_is_limit ho h)\n  · rcases eq_or_ne a 0 with (rfl | ha)\n    · rwa [zero_mul]\n    rw [← ordinal.pos_iff_ne_zero] at ha\n    rw [← h a ha hao]\n    exact (mul_is_normal ha).strict_mono hbo\n#align principal_mul_iff_mul_left_eq principal_mul_iff_mul_left_eq\n\n",
 "principal_mul_iff_le_two_or_omega_opow_opow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.pow -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.pow -/\n/-- The main characterization theorem for multiplicative principal ordinals. -/\ntheorem principal_mul_iff_le_two_or_omega_opow_opow {o : ordinal} :\n    principal (· * ·) o ↔ o ≤ 2 ∨ ∃ a, o = ordinal.pow omega (ordinal.pow omega a) :=\n  by\n  refine' ⟨fun ho => _, _⟩\n  · cases' le_or_lt o 2 with ho₂ ho₂\n    · exact or.inl ho₂\n    rcases principal_add_iff_zero_or_omega_opow.1 (principal_add_of_principal_mul ho ho₂.ne') with (rfl | ⟨a, rfl⟩)\n    · exact (ordinal.not_lt_zero 2 ho₂).elim\n    rcases principal_add_iff_zero_or_omega_opow.1 (principal_add_of_principal_mul_opow one_lt_omega ho) with\n      (rfl | ⟨b, rfl⟩)\n    · rw [opow_zero] at ho₂\n      exact ((lt_succ 1).not_le ho₂.le).elim\n    exact or.inr ⟨b, rfl⟩\n  · rintro (ho₂ | ⟨a, rfl⟩)\n    · exact principal_mul_of_le_two ho₂\n    · exact principal_mul_omega_opow_opow a\n#align principal_mul_iff_le_two_or_omega_opow_opow principal_mul_iff_le_two_or_omega_opow_opow\n\n",
 "principal_iff_principal_swap":
 "/-\nCopyright (c) 2022 Violeta Hernández Palacios. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Violeta Hernández Palacios\n-/\ntheorem principal_iff_principal_swap {op : ordinal → ordinal → ordinal} {o : ordinal} :\n    principal op o ↔ principal (function.swap op) o := by constructor <;> exact fun h a b ha hb => h hb ha\n#align principal_iff_principal_swap principal_iff_principal_swap\n\n",
 "principal_add_one":
 "theorem principal_add_one : principal (· + ·) 1 :=\n  principal_one_iff.2 <| zero_add 0\n#align principal_add_one principal_add_one\n\n",
 "principal_add_omega_opow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.pow -/\ntheorem principal_add_omega_opow (o : ordinal) : principal (· + ·) (ordinal.pow omega o) :=\n  principal_add_iff_add_left_eq_self.2 fun a => add_omega_opow\n#align principal_add_omega_opow principal_add_omega_opow\n\n",
 "principal_add_omega":
 "theorem principal_add_omega : principal (· + ·) omega :=\n  principal_add_iff_add_left_eq_self.2 fun a => add_omega\n#align principal_add_omega principal_add_omega\n\n",
 "principal_add_of_principal_mul_opow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.pow -/\ntheorem principal_add_of_principal_mul_opow {o b : ordinal} (hb : 1 < b) (ho : principal (· * ·) (ordinal.pow b o)) :\n    principal (· + ·) o := fun x y hx hy =>\n  by\n  have := ho ((opow_lt_opow_iff_right hb).2 hx) ((opow_lt_opow_iff_right hb).2 hy)\n  rwa [← opow_add, opow_lt_opow_iff_right hb] at this\n#align principal_add_of_principal_mul_opow principal_add_of_principal_mul_opow\n\n",
 "principal_add_of_principal_mul":
 "theorem principal_add_of_principal_mul {o : ordinal} (ho : principal (· * ·) o) (ho₂ : o ≠ 2) : principal (· + ·) o :=\n  by\n  cases' lt_or_gt_of_ne ho₂ with ho₁ ho₂\n  · change o < succ 1 at ho₁\n    rw [lt_succ_iff] at ho₁\n    exact principal_add_of_le_one ho₁\n  · refine' fun a b hao hbo => lt_of_le_of_lt _ (ho (max_lt hao hbo) ho₂)\n    rw [mul_two]\n    exact add_le_add (le_max_left a b) (le_max_right a b)\n#align principal_add_of_principal_mul principal_add_of_principal_mul\n\n",
 "principal_add_of_le_one":
 "theorem principal_add_of_le_one {o : ordinal} (ho : o ≤ 1) : principal (· + ·) o :=\n  by\n  rcases le_one_iff.1 ho with (rfl | rfl)\n  · exact principal_zero\n  · exact principal_add_one\n#align principal_add_of_le_one principal_add_of_le_one\n\n",
 "principal_add_is_limit":
 "theorem principal_add_is_limit {o : ordinal} (ho₁ : 1 < o) (ho : principal (· + ·) o) : o.is_limit :=\n  by\n  refine' ⟨fun ho₀ => _, fun a hao => _⟩\n  · rw [ho₀] at ho₁\n    exact not_lt_of_gt zero_lt_one ho₁\n  · cases' eq_or_ne a 0 with ha ha\n    · rw [ha, succ_zero]\n      exact ho₁\n    · refine' lt_of_le_of_lt _ (ho hao hao)\n      rwa [← add_one_eq_succ, add_le_add_iff_left, one_le_iff_ne_zero]\n#align principal_add_is_limit principal_add_is_limit\n\n",
 "principal_add_iff_zero_or_omega_opow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.pow -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.pow -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.pow -/\n/-- The main characterization theorem for additive principal ordinals. -/\ntheorem principal_add_iff_zero_or_omega_opow {o : ordinal} :\n    principal (· + ·) o ↔ o = 0 ∨ ∃ a, o = ordinal.pow omega a :=\n  by\n  rcases eq_or_ne o 0 with (rfl | ho)\n  · simp only [principal_zero, or.inl]\n  · rw [principal_add_iff_add_left_eq_self]\n    simp only [ho, false_or_iff]\n    refine'\n      ⟨fun H => ⟨_, ((lt_or_eq_of_le (opow_log_le_self _ ho)).resolve_left fun h => _).symm⟩, fun ⟨b, e⟩ =>\n        e.symm ▸ fun a => add_omega_opow⟩\n    have := H _ h\n    have := lt_opow_succ_log_self one_lt_omega o\n    rw [opow_succ, lt_mul_of_limit omega_is_limit] at this\n    rcases this with ⟨a, ao, h'⟩\n    rcases lt_omega.1 ao with ⟨n, rfl⟩\n    clear ao\n    revert h'\n    apply not_lt_of_le\n    suffices e : ordinal.pow omega (log omega o) * ↑n + o = o\n    · simpa only [e] using le_add_right (ordinal.pow omega (log omega o) * ↑n) o\n    induction' n with n IH\n    · simp only [Nat.cast_zero, mul_zero, zero_add]\n    simp only [Nat.cast_succ, mul_add_one, add_assoc, this, IH]\n#align principal_add_iff_zero_or_omega_opow principal_add_iff_zero_or_omega_opow\n\n",
 "principal_add_iff_add_lt_ne_self":
 "theorem principal_add_iff_add_lt_ne_self {a} : principal (· + ·) a ↔ ∀ ⦃b c⦄, b < a → c < a → b + c ≠ a :=\n  ⟨fun ha b c hb hc => (ha hb hc).ne, fun H => by\n    by_contra' ha\n    rcases exists_lt_add_of_not_principal_add ha with ⟨b, c, hb, hc, rfl⟩\n    exact (H hb hc).irrefl⟩\n#align principal_add_iff_add_lt_ne_self principal_add_iff_add_lt_ne_self\n\n",
 "principal_add_iff_add_left_eq_self":
 "theorem principal_add_iff_add_left_eq_self {o : ordinal} : principal (· + ·) o ↔ ∀ a < o, a + o = o :=\n  by\n  refine' ⟨fun ho a hao => _, fun h a b hao hbo => _⟩\n  · cases' lt_or_le 1 o with ho₁ ho₁\n    · exact op_eq_self_of_principal hao (add_is_normal a) ho (principal_add_is_limit ho₁ ho)\n    · rcases le_one_iff.1 ho₁ with (rfl | rfl)\n      · exact (ordinal.not_lt_zero a hao).elim\n      · rw [lt_one_iff_zero] at hao\n        rw [hao, zero_add]\n  · rw [← h a hao]\n    exact (add_is_normal a).strict_mono hbo\n#align principal_add_iff_add_left_eq_self principal_add_iff_add_left_eq_self\n\n",
 "opow_principal_add_of_principal_add":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.pow -/\ntheorem opow_principal_add_of_principal_add {a} (ha : principal (· + ·) a) (b : ordinal) :\n    principal (· + ·) (ordinal.pow a b) :=\n  by\n  rcases principal_add_iff_zero_or_omega_opow.1 ha with (rfl | ⟨c, rfl⟩)\n  · rcases eq_or_ne b 0 with (rfl | hb)\n    · rw [opow_zero]\n      exact principal_add_one\n    · rwa [zero_opow hb]\n  · rw [← opow_mul]\n    exact principal_add_omega_opow _\n#align opow_principal_add_of_principal_add opow_principal_add_of_principal_add\n\n",
 "opow_omega":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.pow -/\ntheorem opow_omega {a : ordinal} (a1 : 1 < a) (h : a < omega) : ordinal.pow a omega = omega :=\n  le_antisymm\n    ((opow_le_of_limit (one_le_iff_ne_zero.1 <| le_of_lt a1) omega_is_limit).2 fun b hb =>\n      (principal_opow_omega h hb).le)\n    (right_le_opow _ a1)\n#align opow_omega opow_omega\n\n",
 "op_eq_self_of_principal":
 "theorem op_eq_self_of_principal {op : ordinal → ordinal → ordinal} {a o : ordinal.{u}} (hao : a < o)\n    (H : is_normal (op a)) (ho : principal op o) (ho' : is_limit o) : op a o = o :=\n  by\n  refine' le_antisymm _ (H.self_le _)\n  rw [← is_normal.bsup_eq.{u, u} H ho', bsup_le_iff]\n  exact fun b hbo => (ho hao hbo).le\n#align op_eq_self_of_principal op_eq_self_of_principal\n\n",
 "nfp_le_of_principal":
 "theorem nfp_le_of_principal {op : ordinal → ordinal → ordinal} {a o : ordinal} (hao : a < o) (ho : principal op o) :\n    nfp (op a) a ≤ o :=\n  nfp_le fun n => (ho.iterate_lt hao n).le\n#align nfp_le_of_principal nfp_le_of_principal\n\n",
 "mul_principal_add_is_principal_add":
 "theorem mul_principal_add_is_principal_add (a : ordinal.{u}) {b : ordinal.{u}} (hb₁ : b ≠ 1)\n    (hb : principal (· + ·) b) : principal (· + ·) (a * b) :=\n  by\n  rcases eq_zero_or_pos a with (rfl | ha)\n  · rw [zero_mul]\n    exact principal_zero\n  · rcases eq_zero_or_pos b with (rfl | hb₁')\n    · rw [mul_zero]\n      exact principal_zero\n    · rw [← succ_le_iff, succ_zero] at hb₁'\n      intro c d hc hd\n      rw [lt_mul_of_limit (principal_add_is_limit (lt_of_le_of_ne hb₁' hb₁.symm) hb)] at *\n      · rcases hc with ⟨x, hx, hx'⟩\n        rcases hd with ⟨y, hy, hy'⟩\n        use x + y, hb hx hy\n        rw [mul_add]\n        exact Left.add_lt_add hx' hy'\n      assumption'\n#align mul_principal_add_is_principal_add mul_principal_add_is_principal_add\n\n",
 "mul_omega_opow_opow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.pow -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.pow -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.pow -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.pow -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.pow -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.pow -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.pow -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.pow -/\ntheorem mul_omega_opow_opow {a b : ordinal} (a0 : 0 < a) (h : a < ordinal.pow omega (ordinal.pow omega b)) :\n    a * ordinal.pow omega (ordinal.pow omega b) = ordinal.pow omega (ordinal.pow omega b) :=\n  by\n  by_cases b0 : b = 0;\n  · rw [b0, opow_zero, opow_one] at h⊢\n    exact mul_omega a0 h\n  refine'\n    le_antisymm _\n      (by simpa only [one_mul] using mul_le_mul_right' (one_le_iff_pos.2 a0) (ordinal.pow omega (ordinal.pow omega b)))\n  rcases(lt_opow_of_limit omega_ne_zero (opow_is_limit_left omega_is_limit b0)).1 h with ⟨x, xb, ax⟩\n  apply (mul_le_mul_right' (le_of_lt ax) _).trans\n  rw [← opow_add, add_omega_opow xb]\n#align mul_omega_opow_opow mul_omega_opow_opow\n\n",
 "mul_omega_dvd":
 "theorem mul_omega_dvd {a : ordinal} (a0 : 0 < a) (ha : a < omega) : ∀ {b}, omega ∣ b → a * b = b\n  | _, ⟨b, rfl⟩ => by rw [← mul_assoc, mul_omega a0 ha]\n#align mul_omega_dvd mul_omega_dvd\n\n",
 "mul_omega":
 "theorem mul_omega {a : ordinal} (a0 : 0 < a) (ha : a < omega) : a * omega = omega :=\n  principal_mul_iff_mul_left_eq.1 principal_mul_omega a a0 ha\n#align mul_omega mul_omega\n\n",
 "mul_lt_omega_opow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.pow -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.pow -/\ntheorem mul_lt_omega_opow {a b c : ordinal} (c0 : 0 < c) (ha : a < ordinal.pow omega c) (hb : b < omega) :\n    a * b < ordinal.pow omega c :=\n  by\n  rcases zero_or_succ_or_limit c with (rfl | ⟨c, rfl⟩ | l)\n  · exact (lt_irrefl _).elim c0\n  · rw [opow_succ] at ha\n    rcases((mul_is_normal <| opow_pos _ omega_pos).limit_lt omega_is_limit).1 ha with ⟨n, hn, an⟩\n    apply (mul_le_mul_right' (le_of_lt an) _).trans_lt\n    rw [opow_succ, mul_assoc, mul_lt_mul_iff_left (opow_pos _ omega_pos)]\n    exact principal_mul_omega hn hb\n  · rcases((opow_is_normal one_lt_omega).limit_lt l).1 ha with ⟨x, hx, ax⟩\n    refine' (mul_le_mul' (le_of_lt ax) (le_of_lt hb)).trans_lt _\n    rw [← opow_succ, opow_lt_opow_iff_right one_lt_omega]\n    exact l.2 _ hx\n#align mul_lt_omega_opow mul_lt_omega_opow\n\n",
 "mul_eq_opow_log_succ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.pow -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.pow -/\ntheorem mul_eq_opow_log_succ {a b : ordinal.{u}} (ha : a ≠ 0) (hb : principal (· * ·) b) (hb₂ : 2 < b) :\n    a * b = ordinal.pow b (succ (log b a)) := by\n  apply le_antisymm\n  · have hbl := principal_mul_is_limit hb₂ hb\n    rw [← is_normal.bsup_eq.{u, u} (mul_is_normal (ordinal.pos_iff_ne_zero.2 ha)) hbl, bsup_le_iff]\n    intro c hcb\n    have hb₁ : 1 < b := (lt_succ 1).trans hb₂\n    have hbo₀ : ordinal.pow b (b.log a) ≠ 0 := ordinal.pos_iff_ne_zero.1 (opow_pos _ (zero_lt_one.trans hb₁))\n    apply le_trans (mul_le_mul_right' (le_of_lt (lt_mul_succ_div a hbo₀)) c)\n    rw [mul_assoc, opow_succ]\n    refine' mul_le_mul_left' (le_of_lt (hb (hbl.2 _ _) hcb)) _\n    rw [div_lt hbo₀, ← opow_succ]\n    exact lt_opow_succ_log_self hb₁ _\n  · rw [opow_succ]\n    exact mul_le_mul_right' (opow_log_le_self b ha) b\n#align mul_eq_opow_log_succ mul_eq_opow_log_succ\n\n",
 "lt_blsub₂":
 "theorem lt_blsub₂ (op : ordinal → ordinal → ordinal) {o : ordinal} {a b : ordinal} (ha : a < o) (hb : b < o) :\n    op a b < blsub₂ op o :=\n  by\n  convert lt_lsub _ (prod.mk (enum (· < ·) a (by rwa [type_lt])) (enum (· < ·) b (by rwa [type_lt])))\n  simp only [typein_enum]\n#align lt_blsub₂ lt_blsub₂\n\n",
 "iterate_lt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\ntheorem principal.iterate_lt {op : ordinal → ordinal → ordinal} {a o : ordinal} (hao : a < o) (ho : principal op o)\n    (n : ℕ) : («expr ^[ ]» (op a) n) a < o := by\n  induction' n with n hn\n  · rwa [function.iterate_zero]\n  · rw [function.iterate_succ']\n    exact ho hao hn\n#align principal.iterate_lt principal.iterate_lt\n\n",
 "exists_lt_add_of_not_principal_add":
 "theorem exists_lt_add_of_not_principal_add {a} (ha : ¬principal (· + ·) a) :\n    ∃ (b c : _)(hb : b < a)(hc : c < a), b + c = a :=\n  by\n  unfold principal at ha\n  push_neg  at ha\n  rcases ha with ⟨b, c, hb, hc, H⟩\n  refine' ⟨b, _, hb, lt_of_le_of_ne (sub_le_self a b) fun hab => _, ordinal.add_sub_cancel_of_le hb.le⟩\n  rw [← sub_le, hab] at H\n  exact H.not_lt hc\n#align exists_lt_add_of_not_principal_add exists_lt_add_of_not_principal_add\n\n",
 "add_omega_opow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.pow -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.pow -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.pow -/\ntheorem add_omega_opow {a b : ordinal} (h : a < ordinal.pow omega b) : a + ordinal.pow omega b = ordinal.pow omega b :=\n  by\n  refine' le_antisymm _ (le_add_left _ _)\n  revert h; refine' limit_rec_on b (fun h => _) (fun b _ h => _) fun b l IH h => _\n  · rw [opow_zero, ← succ_zero, lt_succ_iff, ordinal.le_zero] at h\n    rw [h, zero_add]\n  · rw [opow_succ] at h\n    rcases(lt_mul_of_limit omega_is_limit).1 h with ⟨x, xo, ax⟩\n    refine' le_trans (add_le_add_right (le_of_lt ax) _) _\n    rw [opow_succ, ← mul_add, add_omega xo]\n  · rcases(lt_opow_of_limit omega_ne_zero l).1 h with ⟨x, xb, ax⟩\n    exact\n      (((add_is_normal a).trans (opow_is_normal one_lt_omega)).limit_le l).2 fun y yb =>\n        (add_le_add_left (opow_le_opow_right omega_pos (le_max_right _ _)) _).trans\n          (le_trans (IH _ (max_lt xb yb) (ax.trans_le <| opow_le_opow_right omega_pos (le_max_left _ _)))\n            (opow_le_opow_right omega_pos <| le_of_lt <| max_lt xb yb))\n#align add_omega_opow add_omega_opow\n\n",
 "add_omega":
 "theorem add_omega {a : ordinal} (h : a < omega) : a + omega = omega :=\n  by\n  rcases lt_omega.1 h with ⟨n, rfl⟩\n  clear h; induction' n with n IH\n  · rw [Nat.cast_zero, zero_add]\n  · rwa [Nat.cast_succ, add_assoc, one_add_of_omega_le (le_refl _)]\n#align add_omega add_omega\n\n",
 "add_absorp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.pow -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.pow -/\ntheorem add_absorp {a b c : ordinal} (h₁ : a < ordinal.pow omega b) (h₂ : ordinal.pow omega b ≤ c) : a + c = c := by\n  rw [← ordinal.add_sub_cancel_of_le h₂, ← add_assoc, add_omega_opow h₁]\n#align add_absorp add_absorp\n\n"}