{"zero_sub":
 "#print zero_sub /-\n@[simp]\ntheorem zero_sub (a : Ordinal) : 0 - a = 0 := by rw [← Ordinal.le_zero] <;> apply sub_le_self\n#align zero_sub zero_sub\n-/\n\n",
 "zero_or_succ_or_limit":
 "theorem zero_or_succ_or_limit (o : Ordinal) : o = 0 ∨ (∃ a, o = succ a) ∨ IsLimit o :=\n  if o0 : o = 0 then or.inl o0\n  else if h : ∃ a, o = succ a then or.inr (or.inl h) else or.inr <| or.inr ⟨o0, fun a => (succ_lt_of_not_succ h).2⟩\n#align zero_or_succ_or_limit zero_or_succ_or_limit\n\n",
 "zero_mod":
 "@[simp]\ntheorem zero_mod (b : Ordinal) : 0 % b = 0 := by simp only [mod_def, zero_div, MulZeroClass.mul_zero, sub_self]\n#align zero_mod zero_mod\n\n",
 "zero_div":
 "#print zero_div /-\n@[simp]\ntheorem zero_div (a : Ordinal) : 0 / a = 0 :=\n  Ordinal.le_zero.1 <| div_le_of_le_mul <| Ordinal.zero_le _\n#align zero_div zero_div\n-/\n\n",
 "unbounded_range_of_sup_ge":
 "theorem unbounded_range_of_sup_ge {α β : Type u} (r : α → α → Prop) [IsWellOrder α r] (f : β → α)\n    (h : type r ≤ sup.{u, u} (typein r ∘ f)) : Unbounded r (range f) :=\n  (not_bounded_iff _).1 fun ⟨x, hx⟩ =>\n    not_lt_of_le h <|\n      lt_of_le_of_lt (sup_le fun y => le_of_lt <| (typein_lt_typein r).2 <| hx _ <| mem_range_self y)\n        (typein_lt_type r x)\n#align unbounded_range_of_sup_ge unbounded_range_of_sup_ge\n\n",
 "type_subrel_lt":
 "theorem type_subrel_lt (o : Ordinal.{u}) : type (Subrel (· < ·) { o' : Ordinal | o' < o }) = Ordinal.lift.{u + 1} o :=\n  by\n  refine' Quotient.inductionOn o _\n  rintro ⟨α, r, wo⟩; skip; apply quotient.sound\n  constructor; symm; refine' (RelIso.preimage Equiv.ulift r).trans (enum_iso r).symm\n#align type_subrel_lt type_subrel_lt\n\n",
 "type_prod_lex":
 "@[simp]\ntheorem type_prod_lex {α β : Type u} (r : α → α → Prop) (s : β → β → Prop) [IsWellOrder α r] [IsWellOrder β s] :\n    type (prod.lex s r) = type r * type s :=\n  rfl\n#align type_prod_lex type_prod_lex\n\n",
 "trans":
 "theorem is_normal.trans {f g} (H₁ : IsNormal f) (H₂ : IsNormal g) : IsNormal (f ∘ g) :=\n  ⟨fun x => H₁.lt_iff.2 (H₂.1 _), fun o l a => H₁.le_set' (· < o) ⟨_, l.pos⟩ g _ fun c => H₂.2 _ l _⟩\n#align is_normal.trans is_normal.trans\n\n",
 "supr_ord":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\ntheorem supr_ord {ι} {f : ι → Cardinal} (hf : BddAbove (range f)) :\n    (supᵢ f).ord =\n      «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (f i).ord :=\n  by\n  unfold supᵢ\n  convert Sup_ord hf\n  rw [range_comp]\n#align supr_ord supr_ord\n\n",
 "sup_unique":
 "@[simp]\ntheorem sup_unique {ι} [Unique ι] (f : ι → Ordinal) : sup f = f default :=\n  csupᵢ_unique\n#align sup_unique sup_unique\n\n",
 "sup_typein_succ":
 "@[simp]\ntheorem sup_typein_succ {o : Ordinal} : sup.{u, u} (typein ((· < ·) : (succ o).out.α → (succ o).out.α → Prop)) = o :=\n  by\n  cases' sup_eq_lsub_or_sup_succ_eq_lsub.{u, u} (typein ((· < ·) : (succ o).out.α → (succ o).out.α → Prop)) with h h\n  · rw [sup_eq_lsub_iff_succ] at h\n    simp only [lsub_typein] at h\n    exact (h o (lt_succ o)).false.elim\n  rw [← succ_eq_succ_iff, h]\n  apply lsub_typein\n#align sup_typein_succ sup_typein_succ\n\n",
 "sup_typein_limit":
 "theorem sup_typein_limit {o : Ordinal} (ho : ∀ a, a < o → succ a < o) :\n    sup.{u, u} (typein ((· < ·) : o.out.α → o.out.α → Prop)) = o := by\n  rw [(sup_eq_lsub_iff_succ.{u, u} (typein (· < ·))).2] <;> rwa [lsub_typein o]\n#align sup_typein_limit sup_typein_limit\n\n",
 "sup_sum":
 "@[simp]\ntheorem sup_sum {α : Type u} {β : Type v} (f : Sum α β → Ordinal) :\n    sup.{max u v, w} f = max (sup.{u, max v w} fun a => f (Sum.inl a)) (sup.{v, max u w} fun b => f (Sum.inr b)) :=\n  by\n  apply (sup_le_iff.2 _).antisymm (max_le_iff.2 ⟨_, _⟩)\n  · rintro (i | i)\n    · exact le_max_of_le_left (le_sup _ i)\n    · exact le_max_of_le_right (le_sup _ i)\n  all_goals\n    apply sup_le_of_range_subset.{_, max u v, w}\n    rintro i ⟨a, rfl⟩\n    apply mem_range_self\n#align sup_sum sup_sum\n\n",
 "sup_succ_le_lsub":
 "theorem sup_succ_le_lsub {ι} (f : ι → Ordinal) : succ (sup f) ≤ lsub f ↔ ∃ i, f i = sup f :=\n  by\n  refine' ⟨fun h => _, _⟩\n  · by_contra' hf\n    exact (succ_le_iff.1 h).ne ((sup_le_lsub f).antisymm (lsub_le (ne_sup_iff_lt_sup.1 hf)))\n  rintro ⟨_, hf⟩\n  rw [succ_le_iff, ← hf]\n  exact lt_lsub _ _\n#align sup_succ_le_lsub sup_succ_le_lsub\n\n",
 "sup_succ_eq_lsub":
 "theorem sup_succ_eq_lsub {ι} (f : ι → Ordinal) : succ (sup f) = lsub f ↔ ∃ i, f i = sup f :=\n  (lsub_le_sup_succ f).le_iff_eq.symm.trans (sup_succ_le_lsub f)\n#align sup_succ_eq_lsub sup_succ_eq_lsub\n\n",
 "sup_not_succ_of_ne_sup":
 "theorem sup_not_succ_of_ne_sup {ι} {f : ι → Ordinal} (hf : ∀ i, f i ≠ sup f) {a} (hao : a < sup f) : succ a < sup f :=\n  by\n  by_contra' hoa\n  exact hao.not_le (sup_le fun i => le_of_lt_succ <| (lt_of_le_of_ne (le_sup _ _) (hf i)).trans_le hoa)\n#align sup_not_succ_of_ne_sup sup_not_succ_of_ne_sup\n\n",
 "sup_nat_cast":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.omega -/\n@[simp]\ntheorem sup_nat_cast : sup Nat.cast = ordinal.omega :=\n  (sup_le fun n => (nat_lt_omega n).le).antisymm <| omega_le.2 <| le_sup _\n#align sup_nat_cast sup_nat_cast\n\n",
 "sup_mul_nat":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.omega -/\n@[simp]\ntheorem sup_mul_nat (o : Ordinal) : (sup fun n : ℕ => o * n) = o * ordinal.omega :=\n  by\n  rcases eq_zero_or_pos o with (rfl | ho)\n  · rw [MulZeroClass.zero_mul]\n    exact sup_eq_zero_iff.2 fun n => MulZeroClass.zero_mul n\n  · exact (mul_is_normal ho).apply_omega\n#align sup_mul_nat sup_mul_nat\n\n",
 "sup_le_sup":
 "#print sup_le_sup /-\nprivate theorem sup_le_sup {ι ι' : Type u} (r : ι → ι → Prop) (r' : ι' → ι' → Prop) [IsWellOrder ι r]\n    [IsWellOrder ι' r'] {o} (ho : type r = o) (ho' : type r' = o) (f : ∀ a < o, Ordinal) :\n    sup (familyOfBFamily' r ho f) ≤ sup (familyOfBFamily' r' ho' f) :=\n  sup_le fun i =>\n    by\n    cases'\n      typein_surj r'\n        (by\n          rw [ho', ← ho]\n          exact typein_lt_type r i) with\n      j hj\n    simp_rw [family_of_bfamily', ← hj]\n    apply le_sup\n#align sup_le_sup sup_le_sup\n-/\n\n",
 "sup_le_of_range_subset":
 "theorem sup_le_of_range_subset {ι ι'} {f : ι → Ordinal} {g : ι' → Ordinal} (h : Set.range f ⊆ Set.range g) :\n    sup.{u, max v w} f ≤ sup.{v, max u w} g :=\n  sup_le fun i =>\n    match h (mem_range_self i) with\n    | ⟨j, hj⟩ => hj ▸ le_sup _ _\n#align sup_le_of_range_subset sup_le_of_range_subset\n\n",
 "sup_le_lsub":
 "theorem sup_le_lsub {ι} (f : ι → Ordinal) : sup f ≤ lsub f :=\n  sup_le fun i => (lt_lsub f i).le\n#align sup_le_lsub sup_le_lsub\n\n",
 "sup_le_iff":
 "#print sup_le_iff /-\ntheorem sup_le_iff {ι} {f : ι → Ordinal} {a} : sup f ≤ a ↔ ∀ i, f i ≤ a :=\n  (csupₛ_le_iff' (bddAbove_range f)).trans (by simp)\n#align sup_le_iff sup_le_iff\n-/\n\n",
 "sup_le":
 "#print sup_le /-\ntheorem sup_le {ι} {f : ι → Ordinal} {a} : (∀ i, f i ≤ a) → sup f ≤ a :=\n  sup_le_iff.2\n#align sup_le sup_le\n-/\n\n",
 "sup_eq_zero_iff":
 "@[simp]\ntheorem sup_eq_zero_iff {ι} {f : ι → Ordinal} : sup f = 0 ↔ ∀ i, f i = 0 :=\n  by\n  refine' ⟨fun h i => _, fun h => le_antisymm (sup_le fun i => Ordinal.le_zero.2 (h i)) (Ordinal.zero_le _)⟩\n  rw [← Ordinal.le_zero, ← h]\n  exact le_sup f i\n#align sup_eq_zero_iff sup_eq_zero_iff\n\n",
 "sup_eq_sup":
 "theorem sup_eq_sup {ι ι' : Type u} (r : ι → ι → Prop) (r' : ι' → ι' → Prop) [IsWellOrder ι r] [IsWellOrder ι' r']\n    {o : Ordinal.{u}} (ho : type r = o) (ho' : type r' = o) (f : ∀ a < o, Ordinal.{max u v}) :\n    sup (familyOfBFamily' r ho f) = sup (familyOfBFamily' r' ho' f) :=\n  sup_eq_of_range_eq.{u, u, v} (by simp)\n#align sup_eq_sup sup_eq_sup\n\n",
 "sup_eq_of_range_eq":
 "theorem sup_eq_of_range_eq {ι ι'} {f : ι → Ordinal} {g : ι' → Ordinal} (h : Set.range f = Set.range g) :\n    sup.{u, max v w} f = sup.{v, max u w} g :=\n  (sup_le_of_range_subset h.le).antisymm (sup_le_of_range_subset.{v, u, w} h.ge)\n#align sup_eq_of_range_eq sup_eq_of_range_eq\n\n",
 "sup_eq_lsub_or_sup_succ_eq_lsub":
 "theorem sup_eq_lsub_or_sup_succ_eq_lsub {ι} (f : ι → Ordinal) : sup f = lsub f ∨ succ (sup f) = lsub f :=\n  by\n  cases eq_or_lt_of_le (sup_le_lsub f)\n  · exact or.inl h\n  · exact or.inr ((succ_le_of_lt h).antisymm (lsub_le_sup_succ f))\n#align sup_eq_lsub_or_sup_succ_eq_lsub sup_eq_lsub_or_sup_succ_eq_lsub\n\n",
 "sup_eq_lsub_iff_succ":
 "theorem sup_eq_lsub_iff_succ {ι} (f : ι → Ordinal) : sup f = lsub f ↔ ∀ a < lsub f, succ a < lsub f :=\n  by\n  refine' ⟨fun h => _, fun hf => le_antisymm (sup_le_lsub f) (lsub_le fun i => _)⟩\n  · rw [← h]\n    exact fun a => sup_not_succ_of_ne_sup fun i => (lsub_le_iff.1 (le_of_eq h.symm) i).ne\n  by_contra' hle\n  have heq := (sup_succ_eq_lsub f).2 ⟨i, le_antisymm (le_sup _ _) hle⟩\n  have :=\n    hf _\n      (by\n        rw [← HEq]\n        exact lt_succ (sup f))\n  rw [HEq] at this\n  exact this.false\n#align sup_eq_lsub_iff_succ sup_eq_lsub_iff_succ\n\n",
 "sup_eq_lsub_iff_lt_sup":
 "theorem sup_eq_lsub_iff_lt_sup {ι} (f : ι → Ordinal) : sup f = lsub f ↔ ∀ i, f i < sup f :=\n  ⟨fun h i => by\n    rw [h]\n    apply lt_lsub, fun h => le_antisymm (sup_le_lsub f) (lsub_le h)⟩\n#align sup_eq_lsub_iff_lt_sup sup_eq_lsub_iff_lt_sup\n\n",
 "sup_eq_lsub":
 "@[simp]\ntheorem sup_eq_lsub {ι} (f : ι → Ordinal) : sup (succ ∘ f) = lsub f :=\n  rfl\n#align sup_eq_lsub sup_eq_lsub\n\n",
 "sup_eq_bsup'":
 "@[simp]\ntheorem sup_eq_bsup' {o ι} (r : ι → ι → Prop) [IsWellOrder ι r] (ho : type r = o) (f) :\n    sup (familyOfBFamily' r ho f) = bsup o f :=\n  sup_eq_sup r _ ho _ f\n#align sup_eq_bsup' sup_eq_bsup'\n\n",
 "sup_eq_bsup":
 "@[simp]\ntheorem sup_eq_bsup {o} (f : ∀ a < o, Ordinal) : sup (familyOfBFamily o f) = bsup o f :=\n  rfl\n#align sup_eq_bsup sup_eq_bsup\n\n",
 "sup_eq_Sup":
 "theorem sup_eq_Sup {s : Set Ordinal.{u}} (hs : Small.{u} s) :\n    (sup.{u, u} fun x => (@equivShrink s hs).symm x) = supₛ s :=\n  let hs' := bddAbove_iff_small.2 hs\n  ((csupₛ_le_iff' hs').2 (le_sup_shrink_equiv hs)).antisymm' (sup_le fun x => le_csupₛ hs' (Subtype.mem _))\n#align sup_eq_Sup sup_eq_Sup\n\n",
 "sup_empty":
 "@[simp]\ntheorem sup_empty {ι} [IsEmpty ι] (f : ι → Ordinal) : sup f = 0 :=\n  csupᵢ_of_empty f\n#align sup_empty sup_empty\n\n",
 "sup_const":
 "@[simp]\ntheorem sup_const {ι} [hι : Nonempty ι] (o : Ordinal) : (sup fun _ : ι => o) = o :=\n  csupᵢ_const\n#align sup_const sup_const\n\n",
 "sup_add_nat":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.omega -/\n@[simp]\ntheorem sup_add_nat (o : Ordinal) : (sup fun n : ℕ => o + n) = o + ordinal.omega :=\n  (add_isNormal o).apply_omega\n#align sup_add_nat sup_add_nat\n\n",
 "sup":
 "theorem is_normal.sup {f} (H : IsNormal f) {ι} (g : ι → Ordinal) [Nonempty ι] : f (sup g) = sup (f ∘ g) :=\n  eq_of_forall_ge_iff fun a => by rw [sup_le_iff, comp, H.le_set' Set.univ Set.univ_nonempty g] <;> simp [sup_le_iff]\n#align is_normal.sup is_normal.sup\n\n",
 "succ_pred_iff_is_succ":
 "theorem succ_pred_iff_is_succ {o} : succ (pred o) = o ↔ ∃ a, o = succ a :=\n  ⟨fun e => ⟨_, e.symm⟩, fun ⟨a, e⟩ => by simp only [e, pred_succ]⟩\n#align succ_pred_iff_is_succ succ_pred_iff_is_succ\n\n",
 "succ_lt_of_not_succ":
 "theorem succ_lt_of_not_succ {o b : Ordinal} (h : ¬∃ a, o = succ a) : succ b < o ↔ b < o :=\n  ⟨(lt_succ b).trans, fun l => lt_of_le_of_ne (succ_le_of_lt l) fun e => h ⟨_, e.symm⟩⟩\n#align succ_lt_of_not_succ succ_lt_of_not_succ\n\n",
 "succ_lt_of_is_limit":
 "theorem succ_lt_of_is_limit {o a : Ordinal} (h : IsLimit o) : succ a < o ↔ a < o :=\n  ⟨(lt_succ a).trans, h.2 _⟩\n#align succ_lt_of_is_limit succ_lt_of_is_limit\n\n",
 "succ_lt":
 "theorem is_limit.succ_lt {o a : Ordinal} (h : IsLimit o) : a < o → succ a < o :=\n  h.2 a\n#align is_limit.succ_lt is_limit.succ_lt\n\n",
 "sub_zero":
 "#print sub_zero /-\n@[simp]\ntheorem sub_zero (a : Ordinal) : a - 0 = a := by simpa only [zero_add] using add_sub_cancel 0 a\n#align sub_zero sub_zero\n-/\n\n",
 "sub_sub":
 "#print sub_sub /-\ntheorem sub_sub (a b c : Ordinal) : a - b - c = a - (b + c) :=\n  eq_of_forall_ge_iff fun d => by rw [sub_le, sub_le, sub_le, add_assoc]\n#align sub_sub sub_sub\n-/\n\n",
 "sub_self":
 "#print sub_self /-\n@[simp]\ntheorem sub_self (a : Ordinal) : a - a = 0 := by simpa only [add_zero] using add_sub_cancel a 0\n#align sub_self sub_self\n-/\n\n",
 "sub_nonempty":
 "/-- The set in the definition of subtraction is nonempty. -/\ntheorem sub_nonempty {a b : Ordinal} : { o | a ≤ b + o }.nonempty :=\n  ⟨a, le_add_left _ _⟩\n#align sub_nonempty sub_nonempty\n\n",
 "sub_lt_of_le":
 "theorem sub_lt_of_le {a b c : Ordinal} (h : b ≤ a) : a - b < c ↔ a < b + c :=\n  lt_iff_lt_of_le_iff_le (le_sub_of_le h)\n#align sub_lt_of_le sub_lt_of_le\n\n",
 "sub_le_self":
 "#print sub_le_self /-\ntheorem sub_le_self (a b : Ordinal) : a - b ≤ a :=\n  sub_le.2 <| le_add_left _ _\n#align sub_le_self sub_le_self\n-/\n\n",
 "sub_le":
 "theorem sub_le {a b c : Ordinal} : a - b ≤ c ↔ a ≤ b + c :=\n  ⟨fun h => (le_add_sub a b).trans (add_le_add_left h _), fun h => cinfₛ_le' h⟩\n#align sub_le sub_le\n\n",
 "sub_is_limit":
 "theorem sub_is_limit {a b} (l : IsLimit a) (h : b < a) : IsLimit (a - b) :=\n  ⟨ne_of_gt <| lt_sub.2 <| by rwa [add_zero], fun c h => by rw [lt_sub, add_succ] <;> exact l.2 _ (lt_sub.1 h)⟩\n#align sub_is_limit sub_is_limit\n\n",
 "sub_eq_zero_iff_le":
 "protected theorem sub_eq_zero_iff_le {a b : Ordinal} : a - b = 0 ↔ a ≤ b :=\n  ⟨fun h => by simpa only [h, add_zero] using le_add_sub a b, fun h => by rwa [← Ordinal.le_zero, sub_le, add_zero]⟩\n#align sub_eq_zero_iff_le sub_eq_zero_iff_le\n\n",
 "sub_eq_of_add_eq":
 "theorem sub_eq_of_add_eq {a b c : Ordinal} (h : a + b = c) : c - a = b :=\n  h ▸ add_sub_cancel _ _\n#align sub_eq_of_add_eq sub_eq_of_add_eq\n\n",
 "strict_mono":
 "theorem is_normal.strict_mono {f} (H : IsNormal f) : StrictMono f := fun a b =>\n  limitRecOn b (Not.elim (not_lt_of_le <| Ordinal.zero_le _))\n    (fun b IH h => (lt_or_eq_of_le (le_of_lt_succ h)).elim (fun h => (IH h).trans (H.1 _)) fun e => e ▸ H.1 _)\n    fun b l IH h => lt_of_lt_of_le (H.1 a) ((H.2 _ l _).1 le_rfl _ (l.2 _ h))\n#align is_normal.strict_mono is_normal.strict_mono\n\n",
 "smul_eq_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print smul_eq_mul /-\ntheorem smul_eq_mul : ∀ (n : ℕ) (a : Ordinal), «expr • » n a = a * n\n  | 0, a => by rw [zero_smul, Nat.cast_zero, MulZeroClass.mul_zero]\n  | n + 1, a => by rw [succ_nsmul', Nat.cast_add, mul_add, Nat.cast_one, mul_one, smul_eq_mul]\n#align smul_eq_mul smul_eq_mul\n-/\n\n",
 "self_le":
 "theorem is_normal.self_le {f} (H : IsNormal f) (a) : a ≤ f a :=\n  lt_wf.self_le_of_strict_mono H.strict_mono a\n#align is_normal.self_le is_normal.self_le\n\n",
 "right_eq_zero_of_add_eq_zero":
 "theorem right_eq_zero_of_add_eq_zero {a b : Ordinal} (h : a + b = 0) : b = 0 :=\n  (add_eq_zero_iff.1 h).2\n#align right_eq_zero_of_add_eq_zero right_eq_zero_of_add_eq_zero\n\n",
 "refl":
 "theorem is_normal.refl : IsNormal id :=\n  ⟨lt_succ, fun o l a => limit_le l⟩\n#align is_normal.refl is_normal.refl\n\n",
 "rank_strict_mono":
 "theorem rank_strict_mono [preorder α] [WellFoundedLT α] : StrictMono (rank <| @is_well_founded.wf α (· < ·) _) :=\n  fun _ _ => rank_lt_of_rel _\n#align rank_strict_mono rank_strict_mono\n\n",
 "rank_strict_anti":
 "theorem rank_strict_anti [preorder α] [WellFoundedGT α] : StrictAnti (rank <| @is_well_founded.wf α (· > ·) _) :=\n  fun _ _ => rank_lt_of_rel <| @is_well_founded.wf α (· > ·) _\n#align rank_strict_anti rank_strict_anti\n\n",
 "rank_lt_of_rel":
 "theorem rank_lt_of_rel (h : r a b) : hwf.rank a < hwf.rank b :=\n  Acc.rank_lt_of_rel _ h\n#align rank_lt_of_rel rank_lt_of_rel\n\n",
 "rank_eq":
 "theorem rank_eq : hwf.rank a = Ordinal.sup.{u, u} fun b : { b // r b a } => Order.succ <| hwf.rank b :=\n  by\n  rw [rank, Acc.rank_eq]\n  rfl\n#align rank_eq rank_eq\n\n",
 "range_family_of_bfamily'":
 "@[simp]\ntheorem range_family_of_bfamily' {ι : Type u} (r : ι → ι → Prop) [IsWellOrder ι r] {o} (ho : type r = o)\n    (f : ∀ a < o, α) : range (familyOfBFamily' r ho f) = brange o f :=\n  by\n  refine' Set.ext fun a => ⟨_, _⟩\n  · rintro ⟨b, rfl⟩\n    apply mem_brange_self\n  · rintro ⟨i, hi, rfl⟩\n    exact ⟨_, family_of_bfamily'_enum _ _ _ _ _⟩\n#align range_family_of_bfamily' range_family_of_bfamily'\n\n",
 "range_family_of_bfamily":
 "@[simp]\ntheorem range_family_of_bfamily {o} (f : ∀ a < o, α) : range (familyOfBFamily o f) = brange o f :=\n  range_familyOfBFamily' _ _ f\n#align range_family_of_bfamily range_family_of_bfamily\n\n",
 "range_enum_ord":
 "theorem range_enum_ord (hS : Unbounded (· < ·) S) : range (enumOrd S) = S :=\n  by\n  rw [range_eq_iff]\n  exact ⟨enum_ord_mem hS, enum_ord_surjective hS⟩\n#align range_enum_ord range_enum_ord\n\n",
 "pred_zero":
 "@[simp]\ntheorem pred_zero : pred 0 = 0 :=\n  pred_eq_iff_not_succ'.2 fun a => (succ_ne_zero a).symm\n#align pred_zero pred_zero\n\n",
 "pred_succ":
 "@[simp]\ntheorem pred_succ (o) : pred (succ o) = o := by\n  have h : ∃ a, succ o = succ a := ⟨_, rfl⟩ <;>\n    simpa only [pred, dif_pos h] using (succ_injective <| Classical.choose_spec h).symm\n#align pred_succ pred_succ\n\n",
 "pred_lt_iff_is_succ":
 "theorem pred_lt_iff_is_succ {o} : pred o < o ↔ ∃ a, o = succ a :=\n  iff.trans (by simp only [le_antisymm_iff, pred_le_self, true_and_iff, not_le])\n    (iff_not_comm.1 pred_eq_iff_not_succ).symm\n#align pred_lt_iff_is_succ pred_lt_iff_is_succ\n\n",
 "pred_le_self":
 "theorem pred_le_self (o) : pred o ≤ o :=\n  if h : ∃ a, o = succ a then by\n    let ⟨a, e⟩ := h\n    rw [e, pred_succ] <;> exact le_succ a\n  else by rw [pred, dif_neg h]\n#align pred_le_self pred_le_self\n\n",
 "pred_le":
 "theorem pred_le {a b} : pred a ≤ b ↔ a ≤ succ b :=\n  le_iff_le_iff_lt_iff_lt.2 lt_pred\n#align pred_le pred_le\n\n",
 "pred_eq_iff_not_succ'":
 "theorem pred_eq_iff_not_succ' {o} : pred o = o ↔ ∀ a, o ≠ succ a := by simpa using pred_eq_iff_not_succ\n#align pred_eq_iff_not_succ' pred_eq_iff_not_succ'\n\n",
 "pred_eq_iff_not_succ":
 "theorem pred_eq_iff_not_succ {o} : pred o = o ↔ ¬∃ a, o = succ a :=\n  ⟨fun e ⟨a, e'⟩ => by rw [e', pred_succ] at e <;> exact (lt_succ a).ne e, fun h => dif_neg h⟩\n#align pred_eq_iff_not_succ pred_eq_iff_not_succ\n\n",
 "pos":
 "theorem is_limit.pos {o : Ordinal} (h : IsLimit o) : 0 < o :=\n  lt_of_le_of_ne (Ordinal.zero_le _) h.1.symm\n#align is_limit.pos is_limit.pos\n\n",
 "out_no_max_of_succ_lt":
 "theorem out_no_max_of_succ_lt {o : Ordinal} (ho : ∀ a < o, succ a < o) : NoMaxOrder o.out.α :=\n  ⟨has_succ_of_type_succ_lt (by rwa [type_lt])⟩\n#align out_no_max_of_succ_lt out_no_max_of_succ_lt\n\n",
 "ord_aleph_0":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.omega -/\n@[simp]\ntheorem ord_aleph_0 : ord.{u} (cardinal.aleph_0) = ordinal.omega :=\n  le_antisymm (ord_le.2 <| le_rfl) <|\n    le_of_forall_lt fun o h => by\n      rcases Ordinal.lt_lift_iff.1 h with ⟨o, rfl, h'⟩\n      rw [lt_ord, ← lift_card, lift_lt_aleph_0, ← typein_enum (· < ·) h']\n      exact lt_aleph_0_iff_fintype.2 ⟨Set.fintypeLTNat _⟩\n#align ord_aleph_0 ord_aleph_0\n\n",
 "one_lt_omega":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.omega -/\ntheorem one_lt_omega : 1 < ordinal.omega := by simpa only [Nat.cast_one] using nat_lt_omega 1\n#align one_lt_omega one_lt_omega\n\n",
 "one_lt":
 "theorem is_limit.one_lt {o : Ordinal} (h : IsLimit o) : 1 < o := by simpa only [succ_zero] using h.2 _ h.pos\n#align is_limit.one_lt is_limit.one_lt\n\n",
 "one_add_omega":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.omega -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.omega -/\n@[simp]\ntheorem one_add_omega : 1 + ordinal.omega = ordinal.omega :=\n  by\n  refine' le_antisymm _ (le_add_left _ _)\n  rw [omega, ← lift_one.{0}, ← lift_add, lift_le, ← type_unit, ← type_sum_lex]\n  refine' ⟨RelEmbedding.collapse (RelEmbedding.ofMonotone _ _)⟩\n  · apply sum.rec\n    exact fun _ => 0\n    exact nat.succ\n  · intro a b\n    cases a <;> cases b <;> intro H <;> cases' H with _ _ H _ _ H <;> [cases H, exact nat.succ_pos _,\n      exact nat.succ_lt_succ H]\n#align one_add_omega one_add_omega\n\n",
 "one_add_of_omega_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.omega -/\n@[simp]\ntheorem one_add_of_omega_le {o} (h : ordinal.omega ≤ o) : 1 + o = o := by\n  rw [← Ordinal.add_sub_cancel_of_le h, ← add_assoc, one_add_omega]\n#align one_add_of_omega_le one_add_of_omega_le\n\n",
 "one_add_nat_cast":
 "@[simp]\ntheorem one_add_nat_cast (m : ℕ) : 1 + (m : Ordinal) = succ m :=\n  by\n  rw [← Nat.cast_one, ← Nat.cast_add, add_comm]\n  rfl\n#align one_add_nat_cast one_add_nat_cast\n\n",
 "omega_pos":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.omega -/\ntheorem omega_pos : 0 < ordinal.omega :=\n  nat_lt_omega 0\n#align omega_pos omega_pos\n\n",
 "omega_ne_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.omega -/\ntheorem omega_ne_zero : ordinal.omega ≠ 0 :=\n  omega_pos.ne'\n#align omega_ne_zero omega_ne_zero\n\n",
 "omega_le_of_is_limit":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.omega -/\ntheorem omega_le_of_is_limit {o} (h : IsLimit o) : ordinal.omega ≤ o :=\n  omega_le.2 fun n => le_of_lt <| nat_lt_limit h n\n#align omega_le_of_is_limit omega_le_of_is_limit\n\n",
 "omega_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.omega -/\ntheorem omega_le {o : Ordinal} : ordinal.omega ≤ o ↔ ∀ n : ℕ, ↑n ≤ o :=\n  ⟨fun h n => (nat_lt_omega _).le.trans h, fun H =>\n    le_of_forall_lt fun a h => by\n      let ⟨n, e⟩ := lt_omega.1 h\n      rw [e, ← succ_le_iff] <;> exact H (n + 1)⟩\n#align omega_le omega_le\n\n",
 "omega_is_limit":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.omega -/\ntheorem omega_is_limit : IsLimit (ordinal.omega) :=\n  ⟨omega_ne_zero, fun o h => by\n    let ⟨n, e⟩ := lt_omega.1 h\n    rw [e] <;> exact nat_lt_omega (n + 1)⟩\n#align omega_is_limit omega_is_limit\n\n",
 "not_zero_is_limit":
 "theorem not_zero_is_limit : ¬IsLimit 0\n  | ⟨h, _⟩ => h rfl\n#align not_zero_is_limit not_zero_is_limit\n\n",
 "not_surjective_of_ordinal_of_small":
 "#print not_surjective_of_ordinal_of_small /-\ntheorem not_surjective_of_ordinal_of_small {α : Type v} [Small.{u} α] (f : α → Ordinal.{u}) : ¬surjective f := fun h =>\n  not_surjective_of_ordinal _ (h.comp (equivShrink _).symm.surjective)\n#align not_surjective_of_ordinal_of_small not_surjective_of_ordinal_of_small\n-/\n\n",
 "not_surjective_of_ordinal":
 "#print not_surjective_of_ordinal /-\ntheorem not_surjective_of_ordinal {α : Type u} (f : α → Ordinal.{u}) : ¬surjective f := fun h =>\n  Ordinal.lsub_not_mem_range.{u, u} f (h _)\n#align not_surjective_of_ordinal not_surjective_of_ordinal\n-/\n\n",
 "not_succ_of_is_limit":
 "theorem not_succ_of_is_limit {o} (h : IsLimit o) : ¬∃ a, o = succ a\n  | ⟨a, e⟩ => not_succ_isLimit a (e ▸ h)\n#align not_succ_of_is_limit not_succ_of_is_limit\n\n",
 "not_succ_is_limit":
 "theorem not_succ_is_limit (o) : ¬IsLimit (succ o)\n  | ⟨_, h⟩ => lt_irrefl _ (h _ (lt_succ o))\n#align not_succ_is_limit not_succ_is_limit\n\n",
 "not_small_ordinal":
 "#print not_small_ordinal /-\n/-- The type of ordinals in universe `u` is not `small.{u}`. This is the type-theoretic analog of\nthe Burali-Forti paradox. -/\ntheorem not_small_ordinal : ¬Small.{u} Ordinal.{max u v} := fun h =>\n  @not_injective_of_ordinal_of_small _ h _ fun a b => Ordinal.lift_inj.1\n#align not_small_ordinal not_small_ordinal\n-/\n\n",
 "not_injective_of_ordinal_of_small":
 "#print not_injective_of_ordinal_of_small /-\ntheorem not_injective_of_ordinal_of_small {α : Type v} [Small.{u} α] (f : Ordinal.{u} → α) : ¬injective f := fun h =>\n  not_injective_of_ordinal _ ((equivShrink _).injective.comp h)\n#align not_injective_of_ordinal_of_small not_injective_of_ordinal_of_small\n-/\n\n",
 "not_injective_of_ordinal":
 "#print not_injective_of_ordinal /-\ntheorem not_injective_of_ordinal {α : Type u} (f : Ordinal.{u} → α) : ¬injective f := fun h =>\n  not_surjective_of_ordinal _ (invFun_surjective h)\n#align not_injective_of_ordinal not_injective_of_ordinal\n-/\n\n",
 "nonempty_compl_range":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\ntheorem nonempty_compl_range {ι : Type u} (f : ι → Ordinal.{max u v}) : («expr ᶜ» (Set.range f)).nonempty :=\n  ⟨_, lsub_not_mem_range f⟩\n#align nonempty_compl_range nonempty_compl_range\n\n",
 "ne_sup_iff_lt_sup":
 "theorem ne_sup_iff_lt_sup {ι} {f : ι → Ordinal} : (∀ i, f i ≠ sup f) ↔ ∀ i, f i < sup f :=\n  ⟨fun hf _ => lt_of_le_of_ne (le_sup _ _) (hf _), fun hf _ => ne_of_lt (hf _)⟩\n#align ne_sup_iff_lt_sup ne_sup_iff_lt_sup\n\n",
 "ne_mex":
 "theorem ne_mex {ι} (f : ι → Ordinal) : ∀ i, f i ≠ mex f := by simpa using mex_not_mem_range f\n#align ne_mex ne_mex\n\n",
 "ne_bmex":
 "theorem ne_bmex {o : Ordinal} (f : ∀ a < o, Ordinal) {i} (hi) : f i hi ≠ bmex o f :=\n  by\n  convert ne_mex _ (enum (· < ·) i (by rwa [type_lt]))\n  rw [family_of_bfamily_enum]\n#align ne_bmex ne_bmex\n\n",
 "nat_lt_omega":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.omega -/\ntheorem nat_lt_omega (n : ℕ) : ↑n < ordinal.omega :=\n  lt_omega.2 ⟨_, rfl⟩\n#align nat_lt_omega nat_lt_omega\n\n",
 "nat_lt_limit":
 "theorem nat_lt_limit {o} (h : IsLimit o) : ∀ n : ℕ, ↑n < o\n  | 0 => lt_of_le_of_ne (Ordinal.zero_le o) h.1.symm\n  | n + 1 => h.2 _ (nat_lt_limit n)\n#align nat_lt_limit nat_lt_limit\n\n",
 "nat_lt":
 "theorem is_limit.nat_lt {o : Ordinal} (h : IsLimit o) : ∀ n : ℕ, (n : Ordinal) < o\n  | 0 => h.pos\n  | n + 1 => h.2 _ (is_limit.nat_lt n)\n#align is_limit.nat_lt is_limit.nat_lt\n\n",
 "nat_cast_sub":
 "@[simp, norm_cast]\ntheorem nat_cast_sub (m n : ℕ) : ((m - n : ℕ) : Ordinal) = m - n :=\n  by\n  cases' le_total m n with h h\n  · rw [tsub_eq_zero_iff_le.2 h, Ordinal.sub_eq_zero_iff_le.2 (nat_cast_le.2 h)]\n    rfl\n  · apply (add_left_cancel n).1\n    rw [← Nat.cast_add, add_tsub_cancel_of_le h, Ordinal.add_sub_cancel_of_le (nat_cast_le.2 h)]\n#align nat_cast_sub nat_cast_sub\n\n",
 "nat_cast_pos":
 "@[simp, norm_cast]\ntheorem nat_cast_pos {n : ℕ} : (0 : Ordinal) < n ↔ 0 < n :=\n  @nat_cast_lt 0 n\n#align nat_cast_pos nat_cast_pos\n\n",
 "nat_cast_ne_zero":
 "theorem nat_cast_ne_zero {n : ℕ} : (n : Ordinal) ≠ 0 ↔ n ≠ 0 :=\n  not_congr nat_cast_eq_zero\n#align nat_cast_ne_zero nat_cast_ne_zero\n\n",
 "nat_cast_mul":
 "@[simp, norm_cast]\ntheorem nat_cast_mul (m : ℕ) : ∀ n : ℕ, ((m * n : ℕ) : Ordinal) = m * n\n  | 0 => by simp\n  | n + 1 => by rw [nat.mul_succ, Nat.cast_add, nat_cast_mul, Nat.cast_succ, mul_add_one]\n#align nat_cast_mul nat_cast_mul\n\n",
 "nat_cast_mod":
 "@[simp, norm_cast]\ntheorem nat_cast_mod (m n : ℕ) : ((m % n : ℕ) : Ordinal) = m % n := by\n  rw [← add_left_cancel, div_add_mod, ← nat_cast_div, ← nat_cast_mul, ← Nat.cast_add, Nat.div_add_mod]\n#align nat_cast_mod nat_cast_mod\n\n",
 "nat_cast_lt":
 "@[simp, norm_cast]\ntheorem nat_cast_lt {m n : ℕ} : (m : Ordinal) < n ↔ m < n := by simp only [lt_iff_le_not_le, nat_cast_le]\n#align nat_cast_lt nat_cast_lt\n\n",
 "nat_cast_le":
 "@[simp, norm_cast]\ntheorem nat_cast_le {m n : ℕ} : (m : Ordinal) ≤ n ↔ m ≤ n := by\n  rw [← Cardinal.ord_nat, ← Cardinal.ord_nat, Cardinal.ord_le_ord, Cardinal.natCast_le]\n#align nat_cast_le nat_cast_le\n\n",
 "nat_cast_inj":
 "@[simp, norm_cast]\ntheorem nat_cast_inj {m n : ℕ} : (m : Ordinal) = n ↔ m = n := by simp only [le_antisymm_iff, nat_cast_le]\n#align nat_cast_inj nat_cast_inj\n\n",
 "nat_cast_eq_zero":
 "@[simp, norm_cast]\ntheorem nat_cast_eq_zero {n : ℕ} : (n : Ordinal) = 0 ↔ n = 0 :=\n  @nat_cast_inj n 0\n#align nat_cast_eq_zero nat_cast_eq_zero\n\n",
 "nat_cast_div":
 "@[simp, norm_cast]\ntheorem nat_cast_div (m n : ℕ) : ((m / n : ℕ) : Ordinal) = m / n :=\n  by\n  rcases eq_or_ne n 0 with (rfl | hn)\n  · simp\n  · have hn' := nat_cast_ne_zero.2 hn\n    apply le_antisymm\n    · rw [le_div hn', ← nat_cast_mul, nat_cast_le, mul_comm]\n      apply nat.div_mul_le_self\n    · rw [div_le hn', ← add_one_eq_succ, ← Nat.cast_succ, ← nat_cast_mul, nat_cast_lt, mul_comm, ←\n        nat.div_lt_iff_lt_mul (nat.pos_of_ne_zero hn)]\n      apply nat.lt_succ_self\n#align nat_cast_div nat_cast_div\n\n",
 "mul_succ":
 "theorem mul_succ (a b : Ordinal) : a * succ b = a * b + a :=\n  mul_add_one a b\n#align mul_succ mul_succ\n\n",
 "mul_sub":
 "#print mul_sub /-\ntheorem mul_sub (a b c : Ordinal) : a * (b - c) = a * b - a * c :=\n  if a0 : a = 0 then by simp only [a0, MulZeroClass.zero_mul, sub_self]\n  else eq_of_forall_ge_iff fun d => by rw [sub_le, ← le_div a0, sub_le, ← le_div a0, mul_add_div _ a0]\n#align mul_sub mul_sub\n-/\n\n",
 "mul_right_inj":
 "#print mul_right_inj /-\ntheorem mul_right_inj {a b c : Ordinal} (a0 : 0 < a) : a * b = a * c ↔ b = c :=\n  (mul_isNormal a0).inj\n#align mul_right_inj mul_right_inj\n-/\n\n",
 "mul_pos":
 "#print mul_pos /-\ntheorem mul_pos {a b : Ordinal} (h₁ : 0 < a) (h₂ : 0 < b) : 0 < a * b := by\n  simpa only [MulZeroClass.mul_zero] using mul_lt_mul_of_pos_left h₂ h₁\n#align mul_pos mul_pos\n-/\n\n",
 "mul_ne_zero":
 "#print mul_ne_zero /-\ntheorem mul_ne_zero {a b : Ordinal} : a ≠ 0 → b ≠ 0 → a * b ≠ 0 := by simpa only [Ordinal.pos_iff_ne_zero] using mul_pos\n#align mul_ne_zero mul_ne_zero\n-/\n\n",
 "mul_mod":
 "@[simp]\ntheorem mul_mod (x y : Ordinal) : x * y % x = 0 := by simpa using mul_add_mod_self x y 0\n#align mul_mod mul_mod\n\n",
 "mul_lt_of_lt_div":
 "theorem mul_lt_of_lt_div {a b c : Ordinal} : a < b / c → c * a < b :=\n  lt_imp_lt_of_le_imp_le div_le_of_le_mul\n#align mul_lt_of_lt_div mul_lt_of_lt_div\n\n",
 "mul_lt_mul_of_pos_left":
 "#print mul_lt_mul_of_pos_left /-\ntheorem mul_lt_mul_of_pos_left {a b c : Ordinal} (h : a < b) (c0 : 0 < c) : c * a < c * b :=\n  (mul_lt_mul_iff_left c0).2 h\n#align mul_lt_mul_of_pos_left mul_lt_mul_of_pos_left\n-/\n\n",
 "mul_lt_mul_iff_left":
 "#print mul_lt_mul_iff_left /-\ntheorem mul_lt_mul_iff_left {a b c : Ordinal} (a0 : 0 < a) : a * b < a * c ↔ b < c :=\n  (mul_isNormal a0).lt_iff\n#align mul_lt_mul_iff_left mul_lt_mul_iff_left\n-/\n\n",
 "mul_le_of_limit_aux":
 "private theorem mul_le_of_limit_aux {α β r s} [IsWellOrder α r] [IsWellOrder β s] {c} (h : IsLimit (type s))\n    (H : ∀ b' < type s, type r * b' ≤ c) (l : c < type r * type s) : False :=\n  by\n  suffices ∀ a b, prod.lex s r (b, a) (enum _ _ l)\n    by\n    cases' enum _ _ l with b a\n    exact irrefl _ (this _ _)\n  intro a b\n  rw [← typein_lt_typein (prod.lex s r), typein_enum]\n  have := H _ (h.2 _ (typein_lt_type s b))\n  rw [mul_succ] at this\n  have := ((add_lt_add_iff_left _).2 (typein_lt_type _ a)).trans_le this\n  refine' (RelEmbedding.ofMonotone (fun a => _) fun a b => _).ordinal_type_le.trans_lt this\n  · rcases a with ⟨⟨b', a'⟩, h⟩\n    by_cases e : b = b'\n    · refine' Sum.inr ⟨a', _⟩\n      subst e\n      cases' h with _ _ _ _ h _ _ _ h\n      · exact (irrefl _ h).elim\n      · exact h\n    · refine' Sum.inl (⟨b', _⟩, a')\n      cases' h with _ _ _ _ h _ _ _ h\n      · exact h\n      · exact (e rfl).elim\n  · rcases a with ⟨⟨b₁, a₁⟩, h₁⟩\n    rcases b with ⟨⟨b₂, a₂⟩, h₂⟩\n    intro h\n    by_cases e₁ : b = b₁ <;> by_cases e₂ : b = b₂\n    · substs b₁ b₂\n      simpa only [subrel_val, Prod.lex_def, @irrefl _ s _ b, true_and_iff, false_or_iff, eq_self_iff_true, dif_pos,\n        Sum.lex_inr_inr] using h\n    · subst b₁\n      simp only [subrel_val, Prod.lex_def, e₂, Prod.lex_def, dif_pos, subrel_val, eq_self_iff_true, or_false_iff,\n        dif_neg, not_false_iff, Sum.lex_inr_inl, false_and_iff] at h⊢\n      cases h₂ <;> [exact asymm h h₂_h, exact e₂ rfl]\n    · simp [e₂, dif_neg e₁, show b₂ ≠ b₁ by cc]\n    · simpa only [dif_neg e₁, dif_neg e₂, Prod.lex_def, subrel_val, Subtype.mk_eq_mk, Sum.lex_inl_inl] using h\n#align mul_le_of_limit_aux mul_le_of_limit_aux\n\n",
 "mul_le_of_limit":
 "theorem mul_le_of_limit {a b c : Ordinal} (h : IsLimit b) : a * b ≤ c ↔ ∀ b' < b, a * b' ≤ c :=\n  ⟨fun h b' l => (mul_le_mul_left' l.le _).trans h, fun H =>\n    le_of_not_lt <| inductionOn a (fun α r _ => inductionOn b fun β s _ => mul_le_of_limit_aux) h H⟩\n#align mul_le_of_limit mul_le_of_limit\n\n",
 "mul_le_mul_iff_left":
 "#print mul_le_mul_iff_left /-\ntheorem mul_le_mul_iff_left {a b c : Ordinal} (a0 : 0 < a) : a * b ≤ a * c ↔ b ≤ c :=\n  (mul_isNormal a0).le_iff\n#align mul_le_mul_iff_left mul_le_mul_iff_left\n-/\n\n",
 "mul_is_normal":
 "theorem mul_is_normal {a : Ordinal} (h : 0 < a) : IsNormal ((· * ·) a) :=\n  ⟨fun b => by rw [mul_succ] <;> simpa only [add_zero] using (add_lt_add_iff_left (a * b)).2 h, fun b l c =>\n    mul_le_of_limit l⟩\n#align mul_is_normal mul_is_normal\n\n",
 "mul_is_limit_left":
 "theorem mul_is_limit_left {a b : Ordinal} (l : IsLimit a) (b0 : 0 < b) : IsLimit (a * b) :=\n  by\n  rcases zero_or_succ_or_limit b with (rfl | ⟨b, rfl⟩ | lb)\n  · exact b0.false.elim\n  · rw [mul_succ]\n    exact add_is_limit _ l\n  · exact mul_is_limit l.pos lb\n#align mul_is_limit_left mul_is_limit_left\n\n",
 "mul_is_limit":
 "theorem mul_is_limit {a b : Ordinal} (a0 : 0 < a) : IsLimit b → IsLimit (a * b) :=\n  (mul_isNormal a0).is_limit\n#align mul_is_limit mul_is_limit\n\n",
 "mul_eq_zero'":
 "private theorem mul_eq_zero' {a b : Ordinal} : a * b = 0 ↔ a = 0 ∨ b = 0 :=\n  inductionOn a fun α _ _ =>\n    inductionOn b fun β _ _ => by\n      simp_rw [← type_prod_lex, type_eq_zero_iff_is_empty]\n      rw [or_comm']\n      exact isEmpty_prod\n#align mul_eq_zero' mul_eq_zero'\n\n",
 "mul_div_le":
 "theorem mul_div_le (a b : Ordinal) : b * (a / b) ≤ a :=\n  if b0 : b = 0 then by simp only [b0, MulZeroClass.zero_mul, Ordinal.zero_le] else (le_div b0).1 le_rfl\n#align mul_div_le mul_div_le\n\n",
 "mul_div_cancel":
 "#print mul_div_cancel /-\n@[simp]\ntheorem mul_div_cancel (a) {b : Ordinal} (b0 : b ≠ 0) : b * a / b = a := by\n  simpa only [add_zero, zero_div] using mul_add_div a b0 0\n#align mul_div_cancel mul_div_cancel\n-/\n\n",
 "mul_add_mod_self":
 "@[simp]\ntheorem mul_add_mod_self (x y z : Ordinal) : (x * y + z) % x = z % x :=\n  by\n  rcases eq_or_ne x 0 with (rfl | hx)\n  · simp\n  · rwa [mod_def, mul_add_div, mul_add, ← sub_sub, add_sub_cancel, mod_def]\n#align mul_add_mod_self mul_add_mod_self\n\n",
 "mul_add_div":
 "theorem mul_add_div (a) {b : Ordinal} (b0 : b ≠ 0) (c) : (b * a + c) / b = a + c / b :=\n  by\n  apply le_antisymm\n  · apply (div_le b0).2\n    rw [mul_succ, mul_add, add_assoc, add_lt_add_iff_left]\n    apply lt_mul_div_add _ b0\n  · rw [le_div b0, mul_add, add_le_add_iff_left]\n    apply mul_div_le\n#align mul_add_div mul_add_div\n\n",
 "monotone":
 "theorem is_normal.monotone {f} (H : IsNormal f) : Monotone f :=\n  H.strict_mono.monotone\n#align is_normal.monotone is_normal.monotone\n\n",
 "mod_zero":
 "@[simp]\ntheorem mod_zero (a : Ordinal) : a % 0 = a := by simp only [mod_def, div_zero, MulZeroClass.zero_mul, sub_zero]\n#align mod_zero mod_zero\n\n",
 "mod_self":
 "@[simp]\ntheorem mod_self (a : Ordinal) : a % a = 0 :=\n  if a0 : a = 0 then by simp only [a0, zero_mod] else by simp only [mod_def, div_self a0, mul_one, sub_self]\n#align mod_self mod_self\n\n",
 "mod_one":
 "@[simp]\ntheorem mod_one (a : Ordinal) : a % 1 = 0 := by simp only [mod_def, div_one, one_mul, sub_self]\n#align mod_one mod_one\n\n",
 "mod_mod_of_dvd":
 "theorem mod_mod_of_dvd (a : Ordinal) {b c : Ordinal} (h : c ∣ b) : a % b % c = a % c :=\n  by\n  nth_rw_rhs 1 [← div_add_mod a b]\n  rcases h with ⟨d, rfl⟩\n  rw [mul_assoc, mul_add_mod_self]\n#align mod_mod_of_dvd mod_mod_of_dvd\n\n",
 "mod_mod":
 "@[simp]\ntheorem mod_mod (a b : Ordinal) : a % b % b = a % b :=\n  mod_mod_of_dvd a dvd_rfl\n#align mod_mod mod_mod\n\n",
 "mod_lt":
 "theorem mod_lt (a) {b : Ordinal} (h : b ≠ 0) : a % b < b :=\n  (add_lt_add_iff_left (b * (a / b))).1 <| by rw [div_add_mod] <;> exact lt_mul_div_add a h\n#align mod_lt mod_lt\n\n",
 "mod_le":
 "theorem mod_le (a b : Ordinal) : a % b ≤ a :=\n  sub_le_self a _\n#align mod_le mod_le\n\n",
 "mod_eq_zero_of_dvd":
 "theorem mod_eq_zero_of_dvd {a b : Ordinal} (H : b ∣ a) : a % b = 0 :=\n  by\n  rcases H with ⟨c, rfl⟩\n  rcases eq_or_ne b 0 with (rfl | hb)\n  · simp\n  · simp [mod_def, hb]\n#align mod_eq_zero_of_dvd mod_eq_zero_of_dvd\n\n",
 "mod_eq_of_lt":
 "theorem mod_eq_of_lt {a b : Ordinal} (h : a < b) : a % b = a := by\n  simp only [mod_def, div_eq_zero_of_lt h, MulZeroClass.mul_zero, sub_zero]\n#align mod_eq_of_lt mod_eq_of_lt\n\n",
 "mod_def":
 "theorem mod_def (a b : Ordinal) : a % b = a - b * (a / b) :=\n  rfl\n#align mod_def mod_def\n\n",
 "mk_initial_seg":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem mk_initial_seg (o : Ordinal.{u}) : cardinal.mk { o' : Ordinal | o' < o } = Cardinal.lift.{u + 1} o.card := by\n  rw [lift_card, ← type_subrel_lt, card_type]\n#align mk_initial_seg mk_initial_seg\n\n",
 "mex_not_mem_range":
 "theorem mex_not_mem_range {ι : Type u} (f : ι → Ordinal.{max u v}) : mex f ∉ Set.range f :=\n  cinfₛ_mem (nonempty_compl_range f)\n#align mex_not_mem_range mex_not_mem_range\n\n",
 "mex_monotone":
 "theorem mex_monotone {α β} {f : α → Ordinal} {g : β → Ordinal} (h : Set.range f ⊆ Set.range g) : mex f ≤ mex g :=\n  by\n  refine' mex_le_of_ne fun i hi => _\n  cases' h ⟨i, rfl⟩ with j hj\n  rw [← hj] at hi\n  exact ne_mex g j hi\n#align mex_monotone mex_monotone\n\n",
 "mex_lt_ord_succ_mk":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem mex_lt_ord_succ_mk {ι} (f : ι → Ordinal) : mex f < (succ (cardinal.mk ι)).ord :=\n  by\n  by_contra' h\n  apply (lt_succ (cardinal.mk ι)).not_le\n  have H := fun a => exists_of_lt_mex ((typein_lt_self a).trans_le h)\n  let g : (succ (cardinal.mk ι)).ord.out.α → ι := fun a => Classical.choose (H a)\n  have hg : injective g := fun a b h' =>\n    by\n    have Hf : ∀ x, f (g x) = typein (· < ·) x := fun a => Classical.choose_spec (H a)\n    apply_fun f  at h'\n    rwa [Hf, Hf, typein_inj] at h'\n  convert Cardinal.mk_le_of_injective hg\n  rw [Cardinal.mk_ord_out]\n#align mex_lt_ord_succ_mk mex_lt_ord_succ_mk\n\n",
 "mex_le_of_ne":
 "theorem mex_le_of_ne {ι} {f : ι → Ordinal} {a} (ha : ∀ i, f i ≠ a) : mex f ≤ a :=\n  cinfₛ_le' (by simp [ha])\n#align mex_le_of_ne mex_le_of_ne\n\n",
 "mex_le_lsub":
 "theorem mex_le_lsub {ι} (f : ι → Ordinal) : mex f ≤ lsub f :=\n  cinfₛ_le' (lsub_not_mem_range f)\n#align mex_le_lsub mex_le_lsub\n\n",
 "mem_brange_self":
 "theorem mem_brange_self {o} (f : ∀ a < o, α) (i hi) : f i hi ∈ brange o f :=\n  ⟨i, hi, rfl⟩\n#align mem_brange_self mem_brange_self\n\n",
 "mem_brange":
 "theorem mem_brange {o : Ordinal} {f : ∀ a < o, α} {a} : a ∈ brange o f ↔ ∃ i hi, f i hi = a :=\n  iff.rfl\n#align mem_brange mem_brange\n\n",
 "lt_sup":
 "theorem lt_sup {ι} {f : ι → Ordinal} {a} : a < sup f ↔ ∃ i, a < f i := by\n  simpa only [not_forall, not_le] using not_congr (@sup_le_iff _ f a)\n#align lt_sup lt_sup\n\n",
 "lt_sub":
 "theorem lt_sub {a b c : Ordinal} : a < b - c ↔ c + a < b :=\n  lt_iff_lt_of_le_iff_le sub_le\n#align lt_sub lt_sub\n\n",
 "lt_pred":
 "theorem lt_pred {a b} : a < pred b ↔ succ a < b :=\n  if h : ∃ a, b = succ a then by\n    let ⟨c, e⟩ := h\n    rw [e, pred_succ, succ_lt_succ_iff]\n  else by simp only [pred, dif_neg h, succ_lt_of_not_succ h]\n#align lt_pred lt_pred\n\n",
 "lt_omega":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.omega -/\ntheorem lt_omega {o : Ordinal} : o < ordinal.omega ↔ ∃ n : ℕ, o = n := by\n  simp_rw [← Cardinal.ord_aleph0, Cardinal.lt_ord, lt_aleph_0, card_eq_nat]\n#align lt_omega lt_omega\n\n",
 "lt_mul_succ_div":
 "theorem lt_mul_succ_div (a) {b : Ordinal} (h : b ≠ 0) : a < b * succ (a / b) := by\n  rw [div_def a h] <;> exact cinfₛ_mem (div_nonempty h)\n#align lt_mul_succ_div lt_mul_succ_div\n\n",
 "lt_mul_of_limit":
 "theorem lt_mul_of_limit {a b c : Ordinal} (h : IsLimit c) : a < b * c ↔ ∃ c' < c, a < b * c' := by\n  simpa only [not_ball, not_le] using not_congr (@mul_le_of_limit b c a h)\n#align lt_mul_of_limit lt_mul_of_limit\n\n",
 "lt_mul_div_add":
 "theorem lt_mul_div_add (a) {b : Ordinal} (h : b ≠ 0) : a < b * (a / b) + b := by\n  simpa only [mul_succ] using lt_mul_succ_div a h\n#align lt_mul_div_add lt_mul_div_add\n\n",
 "lt_lsub_iff":
 "theorem lt_lsub_iff {ι} {f : ι → Ordinal} {a} : a < lsub f ↔ ∃ i, a ≤ f i := by\n  simpa only [not_forall, not_lt, not_le] using not_congr (@lsub_le_iff _ f a)\n#align lt_lsub_iff lt_lsub_iff\n\n",
 "lt_lsub":
 "theorem lt_lsub {ι} (f : ι → Ordinal) (i) : f i < lsub f :=\n  succ_le_iff.1 (le_sup _ i)\n#align lt_lsub lt_lsub\n\n",
 "lt_limit":
 "theorem lt_limit {o} (h : IsLimit o) {a} : a < o ↔ ∃ x < o, a < x := by\n  simpa only [not_ball, not_le] using not_congr (@limit_le _ h a)\n#align lt_limit lt_limit\n\n",
 "lt_iff":
 "theorem is_normal.lt_iff {f} (H : IsNormal f) {a b} : f a < f b ↔ a < b :=\n  StrictMono.lt_iff_lt <| H.strict_mono\n#align is_normal.lt_iff is_normal.lt_iff\n\n",
 "lt_div":
 "theorem lt_div {a b c : Ordinal} (h : c ≠ 0) : a < b / c ↔ c * succ a ≤ b := by rw [← not_le, div_le h, not_lt]\n#align lt_div lt_div\n\n",
 "lt_bsup_of_ne_bsup":
 "theorem lt_bsup_of_ne_bsup {o : Ordinal} {f : ∀ a < o, Ordinal} : (∀ i h, f i h ≠ o.bsup f) ↔ ∀ i h, f i h < o.bsup f :=\n  ⟨fun hf _ _ => lt_of_le_of_ne (le_bsup _ _ _) (hf _ _), fun hf _ _ => ne_of_lt (hf _ _)⟩\n#align lt_bsup_of_ne_bsup lt_bsup_of_ne_bsup\n\n",
 "lt_bsup_of_limit":
 "theorem lt_bsup_of_limit {o : Ordinal} {f : ∀ a < o, Ordinal}\n    (hf : ∀ {a a'} (ha : a < o) (ha' : a' < o), a < a' → f a ha < f a' ha') (ho : ∀ a < o, succ a < o) (i h) :\n    f i h < bsup o f :=\n  (hf _ _ <| lt_succ i).trans_le (le_bsup f (succ i) <| ho _ h)\n#align lt_bsup_of_limit lt_bsup_of_limit\n\n",
 "lt_bsup":
 "theorem lt_bsup {o} (f : ∀ a < o, Ordinal) {a} : a < bsup o f ↔ ∃ i hi, a < f i hi := by\n  simpa only [not_forall, not_le] using not_congr (@bsup_le_iff _ f a)\n#align lt_bsup lt_bsup\n\n",
 "lt_blsub_iff":
 "theorem lt_blsub_iff {o f a} : a < blsub o f ↔ ∃ i hi, a ≤ f i hi := by\n  simpa only [not_forall, not_lt, not_le] using not_congr (@blsub_le_iff _ f a)\n#align lt_blsub_iff lt_blsub_iff\n\n",
 "lt_blsub":
 "theorem lt_blsub {o} (f : ∀ a < o, Ordinal) (i h) : f i h < blsub o f :=\n  blsub_le_iff.1 le_rfl _ _\n#align lt_blsub lt_blsub\n\n",
 "lt_add_of_limit":
 "theorem lt_add_of_limit {a b c : Ordinal.{u}} (h : IsLimit c) : a < b + c ↔ ∃ c' < c, a < b + c' := by\n  rw [← IsNormal.bsup_eq.{u, u} (add_is_normal b) h, lt_bsup]\n#align lt_add_of_limit lt_add_of_limit\n\n",
 "lsub_unique":
 "@[simp]\ntheorem lsub_unique {ι} [hι : Unique ι] (f : ι → Ordinal) : lsub f = succ (f default) :=\n  sup_unique _\n#align lsub_unique lsub_unique\n\n",
 "lsub_typein":
 "@[simp]\ntheorem lsub_typein (o : Ordinal) : lsub.{u, u} (typein ((· < ·) : o.out.α → o.out.α → Prop)) = o :=\n  (lsub_le.{u, u} typein_lt_self).antisymm\n    (by\n      by_contra' h\n      nth_rw 1 [← type_lt o] at h\n      simpa [typein_enum] using lt_lsub.{u, u} (typein (· < ·)) (enum (· < ·) _ h))\n#align lsub_typein lsub_typein\n\n",
 "lsub_sum":
 "@[simp]\ntheorem lsub_sum {α : Type u} {β : Type v} (f : Sum α β → Ordinal) :\n    lsub.{max u v, w} f = max (lsub.{u, max v w} fun a => f (Sum.inl a)) (lsub.{v, max u w} fun b => f (Sum.inr b)) :=\n  sup_sum _\n#align lsub_sum lsub_sum\n\n",
 "lsub_pos":
 "theorem lsub_pos {ι} [h : Nonempty ι] (f : ι → Ordinal) : 0 < lsub f :=\n  h.elim fun i => (Ordinal.zero_le _).trans_lt (lt_lsub f i)\n#align lsub_pos lsub_pos\n\n",
 "lsub_not_mem_range":
 "theorem lsub_not_mem_range {ι} (f : ι → Ordinal) : lsub f ∉ Set.range f := fun ⟨i, h⟩ => h.not_lt (lt_lsub f i)\n#align lsub_not_mem_range lsub_not_mem_range\n\n",
 "lsub_le_sup_succ":
 "theorem lsub_le_sup_succ {ι} (f : ι → Ordinal) : lsub f ≤ succ (sup f) :=\n  lsub_le fun i => lt_succ_iff.2 (le_sup f i)\n#align lsub_le_sup_succ lsub_le_sup_succ\n\n",
 "lsub_le_of_range_subset":
 "theorem lsub_le_of_range_subset {ι ι'} {f : ι → Ordinal} {g : ι' → Ordinal} (h : Set.range f ⊆ Set.range g) :\n    lsub.{u, max v w} f ≤ lsub.{v, max u w} g :=\n  sup_le_of_range_subset (by convert Set.image_subset _ h <;> apply Set.range_comp)\n#align lsub_le_of_range_subset lsub_le_of_range_subset\n\n",
 "lsub_le_iff":
 "theorem lsub_le_iff {ι} {f : ι → Ordinal} {a} : lsub f ≤ a ↔ ∀ i, f i < a :=\n  by\n  convert sup_le_iff\n  simp only [succ_le_iff]\n#align lsub_le_iff lsub_le_iff\n\n",
 "lsub_le":
 "theorem lsub_le {ι} {f : ι → Ordinal} {a} : (∀ i, f i < a) → lsub f ≤ a :=\n  lsub_le_iff.2\n#align lsub_le lsub_le\n\n",
 "lsub_eq_zero_iff":
 "@[simp]\ntheorem lsub_eq_zero_iff {ι} {f : ι → Ordinal} : lsub f = 0 ↔ IsEmpty ι :=\n  by\n  refine' ⟨fun h => ⟨fun i => _⟩, fun h => @lsub_empty _ h _⟩\n  have := @lsub_pos _ ⟨i⟩ f\n  rw [h] at this\n  exact this.false\n#align lsub_eq_zero_iff lsub_eq_zero_iff\n\n",
 "lsub_eq_of_range_eq":
 "theorem lsub_eq_of_range_eq {ι ι'} {f : ι → Ordinal} {g : ι' → Ordinal} (h : Set.range f = Set.range g) :\n    lsub.{u, max v w} f = lsub.{v, max u w} g :=\n  (lsub_le_of_range_subset h.le).antisymm (lsub_le_of_range_subset.{v, u, w} h.ge)\n#align lsub_eq_of_range_eq lsub_eq_of_range_eq\n\n",
 "lsub_eq_lsub":
 "theorem lsub_eq_lsub {ι ι' : Type u} (r : ι → ι → Prop) (r' : ι' → ι' → Prop) [IsWellOrder ι r] [IsWellOrder ι' r'] {o}\n    (ho : type r = o) (ho' : type r' = o) (f : ∀ a < o, Ordinal) :\n    lsub (familyOfBFamily' r ho f) = lsub (familyOfBFamily' r' ho' f) := by rw [lsub_eq_blsub', lsub_eq_blsub']\n#align lsub_eq_lsub lsub_eq_lsub\n\n",
 "lsub_eq_blsub'":
 "theorem lsub_eq_blsub' {ι} (r : ι → ι → Prop) [IsWellOrder ι r] {o} (ho : type r = o) (f) :\n    lsub (familyOfBFamily' r ho f) = blsub o f :=\n  sup_eq_bsup' r ho fun a ha => succ (f a ha)\n#align lsub_eq_blsub' lsub_eq_blsub'\n\n",
 "lsub_eq_blsub":
 "@[simp]\ntheorem lsub_eq_blsub {o} (f : ∀ a < o, Ordinal) : lsub (familyOfBFamily o f) = blsub o f :=\n  lsub_eq_blsub' _ _ _\n#align lsub_eq_blsub lsub_eq_blsub\n\n",
 "lsub_empty":
 "@[simp]\ntheorem lsub_empty {ι} [h : IsEmpty ι] (f : ι → Ordinal) : lsub f = 0 :=\n  by\n  rw [← Ordinal.le_zero, lsub_le_iff]\n  exact h.elim\n#align lsub_empty lsub_empty\n\n",
 "lsub_const":
 "@[simp]\ntheorem lsub_const {ι} [hι : Nonempty ι] (o : Ordinal) : (lsub fun _ : ι => o) = succ o :=\n  sup_const (succ o)\n#align lsub_const lsub_const\n\n",
 "limit_rec_on_zero":
 "@[simp]\ntheorem limit_rec_on_zero {C} (H₁ H₂ H₃) : @limitRecOn C 0 H₁ H₂ H₃ = H₁ := by\n  rw [limit_rec_on, lt_wf.fix_eq, dif_pos rfl] <;> rfl\n#align limit_rec_on_zero limit_rec_on_zero\n\n",
 "limit_rec_on_succ":
 "@[simp]\ntheorem limit_rec_on_succ {C} (o H₁ H₂ H₃) : @limitRecOn C (succ o) H₁ H₂ H₃ = H₂ o (@limitRecOn C o H₁ H₂ H₃) :=\n  by\n  have h : ∃ a, succ o = succ a := ⟨_, rfl⟩\n  rw [limit_rec_on, lt_wf.fix_eq, dif_neg (succ_ne_zero o), dif_pos h]\n  generalize limit_rec_on._proof_2 (succ o) h = h₂\n  generalize limit_rec_on._proof_3 (succ o) h = h₃\n  revert h₂ h₃; generalize e : pred (succ o) = o'; intros\n  rw [pred_succ] at e; subst o'; rfl\n#align limit_rec_on_succ limit_rec_on_succ\n\n",
 "limit_rec_on_limit":
 "@[simp]\ntheorem limit_rec_on_limit {C} (o H₁ H₂ H₃ h) : @limitRecOn C o H₁ H₂ H₃ = H₃ o h fun x h => @limitRecOn C x H₁ H₂ H₃ :=\n  by rw [limit_rec_on, lt_wf.fix_eq, dif_neg h.1, dif_neg (not_succ_of_is_limit h)] <;> rfl\n#align limit_rec_on_limit limit_rec_on_limit\n\n",
 "limit_lt":
 "theorem is_normal.limit_lt {f} (H : IsNormal f) {o} (h : IsLimit o) {a} : a < f o ↔ ∃ b < o, a < f b :=\n  not_iff_not.1 <| by simpa only [exists_prop, not_exists, not_and, not_lt] using H.2 _ h a\n#align is_normal.limit_lt is_normal.limit_lt\n\n",
 "limit_le":
 "theorem is_normal.limit_le {f} (H : IsNormal f) : ∀ {o}, IsLimit o → ∀ {a}, f o ≤ a ↔ ∀ b < o, f b ≤ a :=\n  H.2\n#align is_normal.limit_le is_normal.limit_le\n\n",
 "lift_succ":
 "@[simp]\ntheorem lift_succ (a) : lift (succ a) = succ (lift a) :=\n  by\n  rw [← add_one_eq_succ, lift_add, lift_one]\n  rfl\n#align lift_succ lift_succ\n\n",
 "lift_pred":
 "@[simp]\ntheorem lift_pred (o) : lift (pred o) = pred (lift o) :=\n  if h : ∃ a, o = succ a then by cases' h with a e <;> simp only [e, pred_succ, lift_succ]\n  else by rw [pred_eq_iff_not_succ.2 h, pred_eq_iff_not_succ.2 (mt lift_is_succ.1 h)]\n#align lift_pred lift_pred\n\n",
 "lift_nat_cast":
 "@[simp]\ntheorem lift_nat_cast : ∀ n : ℕ, lift.{u, v} n = n\n  | 0 => by simp\n  | n + 1 => by simp [lift_nat_cast n]\n#align lift_nat_cast lift_nat_cast\n\n",
 "lift_mul":
 "@[simp]\ntheorem lift_mul (a b) : lift (a * b) = lift a * lift b :=\n  quotient.induction_on₂ a b fun ⟨α, r, _⟩ ⟨β, s, _⟩ =>\n    quotient.sound\n      ⟨(RelIso.preimage Equiv.ulift _).trans\n          (RelIso.prodLexCongr (RelIso.preimage Equiv.ulift _) (RelIso.preimage Equiv.ulift _)).symm⟩\n#align lift_mul lift_mul\n\n",
 "lift_is_succ":
 "@[simp]\ntheorem lift_is_succ {o} : (∃ a, lift o = succ a) ↔ ∃ a, o = succ a :=\n  ⟨fun ⟨a, h⟩ =>\n    let ⟨b, e⟩ := lift_down <| show a ≤ lift o from le_of_lt <| h.symm ▸ lt_succ a\n    ⟨b, lift_inj.1 <| by rw [h, ← e, lift_succ]⟩,\n    fun ⟨a, h⟩ => ⟨lift a, by simp only [h, lift_succ]⟩⟩\n#align lift_is_succ lift_is_succ\n\n",
 "lift_is_limit":
 "@[simp]\ntheorem lift_is_limit (o) : IsLimit (lift o) ↔ IsLimit o :=\n  and_congr (not_congr <| by simpa only [lift_zero] using @lift_inj o 0)\n    ⟨fun H a h => lift_lt.1 <| by simpa only [lift_succ] using H _ (lift_lt.2 h), fun H a h =>\n      by\n      obtain ⟨a', rfl⟩ := lift_down h.le\n      rw [← lift_succ, lift_lt]\n      exact H a' (lift_lt.1 h)⟩\n#align lift_is_limit lift_is_limit\n\n",
 "lift_add":
 "/-\nCopyright (c) 2017 Johannes Hölzl. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Mario Carneiro, Floris van Doorn, Violeta Hernández Palacios\n-/\n@[simp]\ntheorem lift_add (a b) : lift (a + b) = lift a + lift b :=\n  quotient.induction_on₂ a b fun ⟨α, r, _⟩ ⟨β, s, _⟩ =>\n    quotient.sound\n      ⟨(RelIso.preimage Equiv.ulift _).trans\n          (RelIso.sumLexCongr (RelIso.preimage Equiv.ulift _) (RelIso.preimage Equiv.ulift _)).symm⟩\n#align lift_add lift_add\n\n",
 "left_eq_zero_of_add_eq_zero":
 "theorem left_eq_zero_of_add_eq_zero {a b : Ordinal} (h : a + b = 0) : a = 0 :=\n  (add_eq_zero_iff.1 h).1\n#align left_eq_zero_of_add_eq_zero left_eq_zero_of_add_eq_zero\n\n",
 "le_sup_shrink_equiv":
 "theorem le_sup_shrink_equiv {s : Set Ordinal.{u}} (hs : Small.{u} s) (a) (ha : a ∈ s) :\n    a ≤ sup.{u, u} fun x => ((@equivShrink s hs).symm x).val :=\n  by\n  convert le_sup.{u, u} _ ((@equivShrink s hs) ⟨a, ha⟩)\n  rw [symm_apply_apply]\n#align le_sup_shrink_equiv le_sup_shrink_equiv\n\n",
 "le_sup":
 "theorem le_sup {ι} (f : ι → Ordinal) : ∀ i, f i ≤ sup f := fun i => le_csupₛ (bddAbove_range f) (mem_range_self i)\n#align le_sup le_sup\n\n",
 "le_succ_of_is_limit":
 "theorem le_succ_of_is_limit {o} (h : IsLimit o) {a} : o ≤ succ a ↔ o ≤ a :=\n  le_iff_le_iff_lt_iff_lt.2 <| succ_lt_of_isLimit h\n#align le_succ_of_is_limit le_succ_of_is_limit\n\n",
 "le_sub_of_le":
 "theorem le_sub_of_le {a b c : Ordinal} (h : b ≤ a) : c ≤ a - b ↔ b + c ≤ a := by\n  rw [← add_le_add_iff_left b, Ordinal.add_sub_cancel_of_le h]\n#align le_sub_of_le le_sub_of_le\n\n",
 "le_set'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem is_normal.le_set' {f o} (H : IsNormal f) (p : Set α) (p0 : p.nonempty) (g : α → Ordinal) (b)\n    (H₂ : ∀ o, b ≤ o ↔ ∀ a ∈ p, g a ≤ o) : f b ≤ o ↔ ∀ a ∈ p, f (g a) ≤ o := by\n  simpa [H₂] using H.le_set («expr '' » g p) (p0.image g) b\n#align is_normal.le_set' is_normal.le_set'\n\n",
 "le_set":
 "theorem is_normal.le_set {f o} (H : IsNormal f) (p : Set Ordinal) (p0 : p.nonempty) (b)\n    (H₂ : ∀ o, b ≤ o ↔ ∀ a ∈ p, a ≤ o) : f b ≤ o ↔ ∀ a ∈ p, f a ≤ o :=\n  ⟨fun h a pa => (H.le_iff.2 ((H₂ _).1 le_rfl _ pa)).trans h, fun h =>\n    by\n    revert H₂; refine' limit_rec_on b (fun H₂ => _) (fun S _ H₂ => _) fun S L _ H₂ => (H.2 _ L _).2 fun a h' => _\n    · cases' p0 with x px\n      have := Ordinal.le_zero.1 ((H₂ _).1 (Ordinal.zero_le _) _ px)\n      rw [this] at px\n      exact h _ px\n    · rcases not_ball.1 (mt (H₂ S).2 <| (lt_succ S).not_le) with ⟨a, h₁, h₂⟩\n      exact (H.le_iff.2 <| succ_le_of_lt <| not_le.1 h₂).trans (h _ h₁)\n    · rcases not_ball.1 (mt (H₂ a).2 h'.not_le) with ⟨b, h₁, h₂⟩\n      exact (H.le_iff.2 <| (not_le.1 h₂).le).trans (h _ h₁)⟩\n#align is_normal.le_set is_normal.le_set\n\n",
 "le_of_mul_le_mul_left":
 "#print le_of_mul_le_mul_left /-\ntheorem le_of_mul_le_mul_left {a b c : Ordinal} (h : c * a ≤ c * b) (h0 : 0 < c) : a ≤ b :=\n  le_imp_le_of_lt_imp_lt (fun h' => mul_lt_mul_of_pos_left h' h0) h\n#align le_of_mul_le_mul_left le_of_mul_le_mul_left\n-/\n\n",
 "le_of_dvd":
 "theorem le_of_dvd : ∀ {a b : Ordinal}, b ≠ 0 → a ∣ b → a ≤ b\n  | a, _, b0, ⟨b, rfl⟩ => by\n    simpa only [mul_one] using\n      mul_le_mul_left' (one_le_iff_ne_zero.2 fun h : b = 0 => by simpa only [h, MulZeroClass.mul_zero] using b0) a\n#align le_of_dvd le_of_dvd\n\n",
 "le_mul_right":
 "#print le_mul_right /-\ntheorem le_mul_right (a : Ordinal) {b : Ordinal} (hb : 0 < b) : a ≤ b * a :=\n  by\n  convert mul_le_mul_right' (one_le_iff_pos.2 hb) a\n  rw [one_mul a]\n#align le_mul_right le_mul_right\n-/\n\n",
 "le_mul_left":
 "#print le_mul_left /-\ntheorem le_mul_left (a : Ordinal) {b : Ordinal} (hb : 0 < b) : a ≤ a * b :=\n  by\n  convert mul_le_mul_left' (one_le_iff_pos.2 hb) a\n  rw [mul_one a]\n#align le_mul_left le_mul_left\n-/\n\n",
 "le_mex_of_forall":
 "theorem le_mex_of_forall {ι : Type u} {f : ι → Ordinal.{max u v}} {a : Ordinal} (H : ∀ b < a, ∃ i, f i = b) :\n    a ≤ mex f := by\n  by_contra' h\n  exact mex_not_mem_range f (H _ h)\n#align le_mex_of_forall le_mex_of_forall\n\n",
 "le_iff_eq":
 "theorem is_normal.le_iff_eq {f} (H : IsNormal f) {a} : f a ≤ a ↔ f a = a :=\n  (H.self_le a).le_iff_eq\n#align is_normal.le_iff_eq is_normal.le_iff_eq\n\n",
 "le_iff":
 "theorem is_normal.le_iff {f} (H : IsNormal f) {a b} : f a ≤ f b ↔ a ≤ b :=\n  le_iff_le_iff_lt_iff_lt.2 H.lt_iff\n#align is_normal.le_iff is_normal.le_iff\n\n",
 "le_div":
 "theorem le_div {a b c : Ordinal} (c0 : c ≠ 0) : a ≤ b / c ↔ c * a ≤ b :=\n  by\n  apply limit_rec_on a\n  · simp only [MulZeroClass.mul_zero, Ordinal.zero_le]\n  · intros\n    rw [succ_le_iff, lt_div c0]\n  · simp (config := { contextual := true }) only [mul_le_of_limit, limit_le, iff_self_iff, forall_true_iff]\n#align le_div le_div\n\n",
 "le_bsup":
 "theorem le_bsup {o} (f : ∀ a < o, Ordinal) (i h) : f i h ≤ bsup o f :=\n  bsup_le_iff.1 le_rfl _ _\n#align le_bsup le_bsup\n\n",
 "le_bmex_of_forall":
 "theorem le_bmex_of_forall {o : Ordinal} (f : ∀ a < o, Ordinal) {a : Ordinal} (H : ∀ b < a, ∃ i hi, f i hi = b) :\n    a ≤ bmex o f := by\n  by_contra' h\n  exact bmex_not_mem_brange f (H _ h)\n#align le_bmex_of_forall le_bmex_of_forall\n\n",
 "le_add_sub":
 "theorem le_add_sub (a b : Ordinal) : a ≤ b + (a - b) :=\n  cinfₛ_mem sub_nonempty\n#align le_add_sub le_add_sub\n\n",
 "is_normal_iff_strict_mono_limit":
 "theorem is_normal_iff_strict_mono_limit (f : Ordinal → Ordinal) :\n    IsNormal f ↔ StrictMono f ∧ ∀ o, IsLimit o → ∀ a, (∀ b < o, f b ≤ a) → f o ≤ a :=\n  ⟨fun hf => ⟨hf.strict_mono, fun a ha c => (hf.2 a ha c).2⟩, fun ⟨hs, hl⟩ =>\n    ⟨fun a => hs (lt_succ a), fun a ha c => ⟨fun hac b hba => ((hs hba).trans_le hac).le, hl a ha c⟩⟩⟩\n#align is_normal_iff_strict_mono_limit is_normal_iff_strict_mono_limit\n\n",
 "is_normal_iff_lt_succ_and_bsup_eq":
 "theorem is_normal_iff_lt_succ_and_bsup_eq {f} :\n    IsNormal f ↔ (∀ a, f a < f (succ a)) ∧ ∀ o, IsLimit o → (bsup o fun x _ => f x) = f o :=\n  ⟨fun h => ⟨h.1, @IsNormal.bsup_eq f h⟩, fun ⟨h₁, h₂⟩ =>\n    ⟨h₁, fun o ho a => by\n      rw [← h₂ o ho]\n      exact bsup_le_iff⟩⟩\n#align is_normal_iff_lt_succ_and_bsup_eq is_normal_iff_lt_succ_and_bsup_eq\n\n",
 "is_normal_iff_lt_succ_and_blsub_eq":
 "theorem is_normal_iff_lt_succ_and_blsub_eq {f} :\n    IsNormal f ↔ (∀ a, f a < f (succ a)) ∧ ∀ o, IsLimit o → (blsub o fun x _ => f x) = f o :=\n  by\n  rw [is_normal_iff_lt_succ_and_bsup_eq, and_congr_right_iff]\n  intro h\n  constructor <;> intro H o ho <;> have := H o ho <;> rwa [← bsup_eq_blsub_of_lt_succ_limit ho fun a _ => h a] at *\n#align is_normal_iff_lt_succ_and_blsub_eq is_normal_iff_lt_succ_and_blsub_eq\n\n",
 "is_limit_iff_omega_dvd":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.omega -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.omega -/\ntheorem is_limit_iff_omega_dvd {a : Ordinal} : IsLimit a ↔ a ≠ 0 ∧ ordinal.omega ∣ a :=\n  by\n  refine' ⟨fun l => ⟨l.1, ⟨a / ordinal.omega, le_antisymm _ (mul_div_le _ _)⟩⟩, fun h => _⟩\n  · refine' (limit_le l).2 fun x hx => le_of_lt _\n    rw [← div_lt omega_ne_zero, ← succ_le_iff, le_div omega_ne_zero, mul_succ, add_le_of_limit omega_is_limit]\n    intro b hb\n    rcases lt_omega.1 hb with ⟨n, rfl⟩\n    exact (add_le_add_right (mul_div_le _ _) _).trans (lt_sub.1 <| nat_lt_limit (sub_is_limit l hx) _).le\n  · rcases h with ⟨a0, b, rfl⟩\n    refine' mul_is_limit_left omega_is_limit (Ordinal.pos_iff_ne_zero.2 <| mt _ a0)\n    intro e\n    simp only [e, MulZeroClass.mul_zero]\n#align is_limit_iff_omega_dvd is_limit_iff_omega_dvd\n\n",
 "is_limit_add_iff":
 "theorem is_limit_add_iff {a b} : IsLimit (a + b) ↔ IsLimit b ∨ b = 0 ∧ IsLimit a :=\n  by\n  constructor <;> intro h\n  · by_cases h' : b = 0\n    · rw [h', add_zero] at h\n      right\n      exact ⟨h', h⟩\n    left\n    rw [← add_sub_cancel a b]\n    apply sub_is_limit h\n    suffices : a + 0 < a + b\n    simpa only [add_zero]\n    rwa [add_lt_add_iff_left, Ordinal.pos_iff_ne_zero]\n  rcases h with (h | ⟨rfl, h⟩); exact add_is_limit a h; simpa only [add_zero]\n#align is_limit_add_iff is_limit_add_iff\n\n",
 "is_limit":
 "theorem is_normal.is_limit {f} (H : IsNormal f) {o} (l : IsLimit o) : IsLimit (f o) :=\n  ⟨ne_of_gt <| (Ordinal.zero_le _).trans_lt <| H.lt_iff.2 l.pos, fun a h =>\n    let ⟨b, h₁, h₂⟩ := (H.limit_lt l).1 h\n    (succ_le_of_lt h₂).trans_lt (H.lt_iff.2 h₁)⟩\n#align is_normal.is_limit is_normal.is_limit\n\n",
 "inj":
 "theorem is_normal.inj {f} (H : IsNormal f) {a b} : f a = f b ↔ a = b := by simp only [le_antisymm_iff, H.le_iff]\n#align is_normal.inj is_normal.inj\n\n",
 "has_succ_of_type_succ_lt":
 "theorem has_succ_of_type_succ_lt {α} {r : α → α → Prop} [wo : IsWellOrder α r] (h : ∀ a < type r, succ a < type r)\n    (x : α) : ∃ y, r x y := by\n  use enum r (succ (typein r x)) (h _ (typein_lt_type r x))\n  convert(enum_lt_enum (typein_lt_type r x) _).mpr (lt_succ _); rw [enum_typein]\n#align has_succ_of_type_succ_lt has_succ_of_type_succ_lt\n\n",
 "family_of_bfamily_enum":
 "@[simp]\ntheorem family_of_bfamily_enum (o : Ordinal) (f : ∀ a < o, α) (i hi) :\n    familyOfBFamily o f\n        (enum (· < ·) i\n          (by\n            convert hi\n            exact type_lt _)) =\n      f i hi :=\n  familyOfBFamily'_enum _ (type_lt o) f _ _\n#align family_of_bfamily_enum family_of_bfamily_enum\n\n",
 "family_of_bfamily'_enum":
 "@[simp]\ntheorem family_of_bfamily'_enum {ι : Type u} (r : ι → ι → Prop) [IsWellOrder ι r] {o} (ho : type r = o) (f : ∀ a < o, α)\n    (i hi) : familyOfBFamily' r ho f (enum r i (by rwa [ho])) = f i hi := by simp only [family_of_bfamily', typein_enum]\n#align family_of_bfamily'_enum family_of_bfamily'_enum\n\n",
 "exists_of_lt_mex":
 "theorem exists_of_lt_mex {ι} {f : ι → Ordinal} {a} (ha : a < mex f) : ∃ i, f i = a :=\n  by\n  by_contra' ha'\n  exact ha.not_le (mex_le_of_ne ha')\n#align exists_of_lt_mex exists_of_lt_mex\n\n",
 "exists_of_lt_bmex":
 "theorem exists_of_lt_bmex {o : Ordinal} {f : ∀ a < o, Ordinal} {a} (ha : a < bmex o f) : ∃ i hi, f i hi = a :=\n  by\n  cases' exists_of_lt_mex ha with i hi\n  exact ⟨_, typein_lt_self i, hi⟩\n#align exists_of_lt_bmex exists_of_lt_bmex\n\n",
 "eq_iff_zero_and_succ":
 "theorem is_normal.eq_iff_zero_and_succ {f g : Ordinal.{u} → Ordinal.{u}} (hf : IsNormal f) (hg : IsNormal g) :\n    f = g ↔ f 0 = g 0 ∧ ∀ a, f a = g a → f (succ a) = g (succ a) :=\n  ⟨fun h => by simp [h], fun ⟨h₁, h₂⟩ =>\n    funext fun a => by\n      apply a.limit_rec_on\n      assumption'\n      intro o ho H\n      rw [← IsNormal.bsup_eq.{u, u} hf ho, ← IsNormal.bsup_eq.{u, u} hg ho]\n      congr\n      ext (b hb)\n      exact H b hb⟩\n#align is_normal.eq_iff_zero_and_succ is_normal.eq_iff_zero_and_succ\n\n",
 "eq_enum_ord":
 "/-- A characterization of `enum_ord`: it is the unique strict monotonic function with range `S`. -/\ntheorem eq_enum_ord (f : Ordinal → Ordinal) (hS : Unbounded (· < ·) S) : StrictMono f ∧ range f = S ↔ f = enumOrd S :=\n  by\n  constructor\n  · rintro ⟨h₁, h₂⟩\n    rwa [← lt_wf.eq_strict_mono_iff_eq_range h₁ (enum_ord_strict_mono hS), range_enum_ord hS]\n  · rintro rfl\n    exact ⟨enum_ord_strict_mono hS, range_enum_ord hS⟩\n#align eq_enum_ord eq_enum_ord\n\n",
 "enum_succ_eq_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem enum_succ_eq_top {o : Ordinal} :\n    enum (· < ·) o\n        (by\n          rw [type_lt]\n          exact lt_succ o) =\n      («expr⊤» : (succ o).out.α) :=\n  rfl\n#align enum_succ_eq_top enum_succ_eq_top\n\n",
 "enum_ord_zero":
 "@[simp]\ntheorem enum_ord_zero : enumOrd S 0 = infₛ S := by\n  rw [enum_ord_def]\n  simp [Ordinal.not_lt_zero]\n#align enum_ord_zero enum_ord_zero\n\n",
 "enum_ord_univ":
 "@[simp]\ntheorem enum_ord_univ : enumOrd Set.univ = id := by\n  rw [← range_id]\n  exact enum_ord_range strictMono_id\n#align enum_ord_univ enum_ord_univ\n\n",
 "enum_ord_surjective":
 "theorem enum_ord_surjective (hS : Unbounded (· < ·) S) : ∀ s ∈ S, ∃ a, enumOrd S a = s := fun s hs =>\n  ⟨supₛ { a | enumOrd S a ≤ s }, by\n    apply le_antisymm\n    · rw [enum_ord_def]\n      refine' cinfₛ_le' ⟨hs, fun a ha => _⟩\n      have : enum_ord S 0 ≤ s := by\n        rw [enum_ord_zero]\n        exact cinfₛ_le' hs\n      rcases exists_lt_of_lt_csupₛ ⟨0, this⟩ ha with ⟨b, hb, hab⟩\n      exact (enum_ord_strict_mono hS hab).trans_le hb\n    · by_contra' h\n      exact\n        (le_csupₛ ⟨s, fun a => (lt_wf.self_le_of_strict_mono (enum_ord_strict_mono hS) a).trans⟩\n              (enum_ord_succ_le hS hs h)).not_lt\n          (lt_succ _)⟩\n#align enum_ord_surjective enum_ord_surjective\n\n",
 "enum_ord_succ_le":
 "theorem enum_ord_succ_le {a b} (hS : Unbounded (· < ·) S) (ha : a ∈ S) (hb : enumOrd S b < a) :\n    enumOrd S (succ b) ≤ a := by\n  rw [enum_ord_def]\n  exact cinfₛ_le' ⟨ha, fun c hc => ((enum_ord_strict_mono hS).monotone (le_of_lt_succ hc)).trans_lt hb⟩\n#align enum_ord_succ_le enum_ord_succ_le\n\n",
 "enum_ord_strict_mono":
 "theorem enum_ord_strict_mono (hS : Unbounded (· < ·) S) : StrictMono (enumOrd S) := fun _ _ h =>\n  (lt_blsub.{u, u} _ _ h).trans_le (blsub_le_enumOrd hS _)\n#align enum_ord_strict_mono enum_ord_strict_mono\n\n",
 "enum_ord_range":
 "@[simp]\ntheorem enum_ord_range {f : Ordinal → Ordinal} (hf : StrictMono f) : enumOrd (range f) = f :=\n  funext fun o => by\n    apply Ordinal.induction o\n    intro a H\n    rw [enum_ord_def a]\n    have Hfa : f a ∈ range f ∩ { b | ∀ c, c < a → enum_ord (range f) c < b } :=\n      ⟨mem_range_self a, fun b hb => by\n        rw [H b hb]\n        exact hf hb⟩\n    refine' (cinfₛ_le' Hfa).antisymm ((le_cinfₛ_iff'' ⟨_, Hfa⟩).2 _)\n    rintro _ ⟨⟨c, rfl⟩, hc : ∀ b < a, enum_ord (range f) b < f c⟩\n    rw [hf.le_iff_le]\n    contrapose! hc\n    exact ⟨c, hc, (H c hc).ge⟩\n#align enum_ord_range enum_ord_range\n\n",
 "enum_ord_mem_aux":
 "private theorem enum_ord_mem_aux (hS : Unbounded (· < ·) S) (o) :\n    enumOrd S o ∈ S ∩ Set.Ici (blsub.{u, u} o fun c _ => enumOrd S c) :=\n  by\n  rw [enum_ord_def']\n  exact cinfₛ_mem (enum_ord_def'_nonempty hS _)\n#align enum_ord_mem_aux enum_ord_mem_aux\n\n",
 "enum_ord_mem":
 "theorem enum_ord_mem (hS : Unbounded (· < ·) S) (o) : enumOrd S o ∈ S :=\n  (enum_ord_mem_aux hS o).left\n#align enum_ord_mem enum_ord_mem\n\n",
 "enum_ord_le_of_subset":
 "theorem enum_ord_le_of_subset {S T : Set Ordinal} (hS : Unbounded (· < ·) S) (hST : S ⊆ T) (a) :\n    enumOrd T a ≤ enumOrd S a := by\n  apply Ordinal.induction a\n  intro b H\n  rw [enum_ord_def]\n  exact cinfₛ_le' ⟨hST (enum_ord_mem hS b), fun c h => (H c h).trans_lt (enum_ord_strict_mono hS h)⟩\n#align enum_ord_le_of_subset enum_ord_le_of_subset\n\n",
 "enum_ord_def_nonempty":
 "/-- The set in `enum_ord_def` is nonempty. -/\ntheorem enum_ord_def_nonempty (hS : Unbounded (· < ·) S) {o} : { x | x ∈ S ∧ ∀ c, c < o → enumOrd S c < x }.nonempty :=\n  ⟨_, enumOrd_mem hS o, fun _ b => enumOrd_strictMono hS b⟩\n#align enum_ord_def_nonempty enum_ord_def_nonempty\n\n",
 "enum_ord_def'_nonempty":
 "/-- The set in `enum_ord_def'` is nonempty. -/\ntheorem enum_ord_def'_nonempty (hS : Unbounded (· < ·) S) (a) : (S ∩ Set.Ici a).nonempty :=\n  let ⟨b, hb, hb'⟩ := hS a\n  ⟨b, hb, le_of_not_gt hb'⟩\n#align enum_ord_def'_nonempty enum_ord_def'_nonempty\n\n",
 "enum_ord_def'":
 "/-- The equation that characterizes `enum_ord` definitionally. This isn't the nicest expression to\n    work with, so consider using `enum_ord_def` instead. -/\ntheorem enum_ord_def' (o) : enumOrd S o = infₛ (S ∩ Set.Ici (blsub.{u, u} o fun a _ => enumOrd S a)) :=\n  lt_wf.fix_eq _ _\n#align enum_ord_def' enum_ord_def'\n\n",
 "enum_ord_def":
 "/-- A more workable definition for `enum_ord`. -/\ntheorem enum_ord_def (o) : enumOrd S o = infₛ (S ∩ { b | ∀ c, c < o → enumOrd S c < b }) :=\n  by\n  rw [enum_ord_def']\n  congr ; ext\n  exact ⟨fun h a hao => (lt_blsub.{u, u} _ _ hao).trans_le h, blsub_le⟩\n#align enum_ord_def enum_ord_def\n\n",
 "dvd_of_mod_eq_zero":
 "theorem dvd_of_mod_eq_zero {a b : Ordinal} (H : a % b = 0) : b ∣ a :=\n  ⟨a / b, by simpa [H] using (div_add_mod a b).symm⟩\n#align dvd_of_mod_eq_zero dvd_of_mod_eq_zero\n\n",
 "dvd_iff_mod_eq_zero":
 "theorem dvd_iff_mod_eq_zero {a b : Ordinal} : b ∣ a ↔ a % b = 0 :=\n  ⟨mod_eq_zero_of_dvd, dvd_of_mod_eq_zero⟩\n#align dvd_iff_mod_eq_zero dvd_iff_mod_eq_zero\n\n",
 "dvd_antisymm":
 "#print dvd_antisymm /-\ntheorem dvd_antisymm {a b : Ordinal} (h₁ : a ∣ b) (h₂ : b ∣ a) : a = b :=\n  if a0 : a = 0 then by subst a <;> exact (eq_zero_of_zero_dvd h₁).symm\n  else if b0 : b = 0 then by subst b <;> exact eq_zero_of_zero_dvd h₂ else (le_of_dvd b0 h₁).antisymm (le_of_dvd a0 h₂)\n#align dvd_antisymm dvd_antisymm\n-/\n\n",
 "dvd_add_iff":
 "theorem dvd_add_iff : ∀ {a b c : Ordinal}, a ∣ b → (a ∣ b + c ↔ a ∣ c)\n  | a, _, c, ⟨b, rfl⟩ =>\n    ⟨fun ⟨d, e⟩ => ⟨d - b, by rw [mul_sub, ← e, add_sub_cancel]⟩, fun ⟨d, e⟩ =>\n      by\n      rw [e, ← mul_add]\n      apply dvd_mul_right⟩\n#align dvd_add_iff dvd_add_iff\n\n",
 "div_zero":
 "#print div_zero /-\n@[simp]\ntheorem div_zero (a : Ordinal) : a / 0 = 0 :=\n  dif_pos rfl\n#align div_zero div_zero\n-/\n\n",
 "div_self":
 "#print div_self /-\n@[simp]\ntheorem div_self {a : Ordinal} (h : a ≠ 0) : a / a = 1 := by simpa only [mul_one] using mul_div_cancel 1 h\n#align div_self div_self\n-/\n\n",
 "div_pos":
 "#print div_pos /-\ntheorem div_pos {b c : Ordinal} (h : c ≠ 0) : 0 < b / c ↔ c ≤ b := by simp [lt_div h]\n#align div_pos div_pos\n-/\n\n",
 "div_one":
 "#print div_one /-\n@[simp]\ntheorem div_one (a : Ordinal) : a / 1 = a := by simpa only [one_mul] using mul_div_cancel a Ordinal.one_ne_zero\n#align div_one div_one\n-/\n\n",
 "div_nonempty":
 "/-- The set in the definition of division is nonempty. -/\ntheorem div_nonempty {a b : Ordinal} (h : b ≠ 0) : { o | a < b * succ o }.nonempty :=\n  ⟨a,\n    succ_le_iff.1 <| by\n      simpa only [succ_zero, one_mul] using mul_le_mul_right' (succ_le_of_lt (Ordinal.pos_iff_ne_zero.2 h)) (succ a)⟩\n#align div_nonempty div_nonempty\n\n",
 "div_mul_cancel":
 "#print div_mul_cancel /-\ntheorem div_mul_cancel : ∀ {a b : Ordinal}, a ≠ 0 → a ∣ b → a * (b / a) = b\n  | a, _, a0, ⟨b, rfl⟩ => by rw [mul_div_cancel _ a0]\n#align div_mul_cancel div_mul_cancel\n-/\n\n",
 "div_lt":
 "theorem div_lt {a b c : Ordinal} (b0 : b ≠ 0) : a / b < c ↔ a < b * c :=\n  lt_iff_lt_of_le_iff_le <| le_div b0\n#align div_lt div_lt\n\n",
 "div_le_of_le_mul":
 "theorem div_le_of_le_mul {a b c : Ordinal} (h : a ≤ b * c) : a / b ≤ c :=\n  if b0 : b = 0 then by simp only [b0, div_zero, Ordinal.zero_le]\n  else (div_le b0).2 <| h.trans_lt <| mul_lt_mul_of_pos_left (lt_succ c) (Ordinal.pos_iff_ne_zero.2 b0)\n#align div_le_of_le_mul div_le_of_le_mul\n\n",
 "div_le":
 "theorem div_le {a b c : Ordinal} (b0 : b ≠ 0) : a / b ≤ c ↔ a < b * succ c :=\n  ⟨fun h => (lt_mul_succ_div a b0).trans_le (mul_le_mul_left' (succ_le_succ_iff.2 h) _), fun h => by\n    rw [div_def a b0] <;> exact cinfₛ_le' h⟩\n#align div_le div_le\n\n",
 "div_eq_zero_of_lt":
 "theorem div_eq_zero_of_lt {a b : Ordinal} (h : a < b) : a / b = 0 :=\n  by\n  rw [← Ordinal.le_zero, div_le <| Ordinal.pos_iff_ne_zero.1 <| (Ordinal.zero_le _).trans_lt h]\n  simpa only [succ_zero, mul_one] using h\n#align div_eq_zero_of_lt div_eq_zero_of_lt\n\n",
 "div_def":
 "theorem div_def (a) {b : Ordinal} (h : b ≠ 0) : a / b = infₛ { o | a < b * succ o } :=\n  dif_neg h\n#align div_def div_def\n\n",
 "div_add_mod":
 "theorem div_add_mod (a b : Ordinal) : b * (a / b) + a % b = a :=\n  Ordinal.add_sub_cancel_of_le <| mul_div_le _ _\n#align div_add_mod div_add_mod\n\n",
 "comp_family_of_bfamily'":
 "theorem comp_family_of_bfamily' {ι : Type u} (r : ι → ι → Prop) [IsWellOrder ι r] {o} (ho : type r = o) (f : ∀ a < o, α)\n    (g : α → β) : g ∘ familyOfBFamily' r ho f = familyOfBFamily' r ho fun i hi => g (f i hi) :=\n  rfl\n#align comp_family_of_bfamily' comp_family_of_bfamily'\n\n",
 "comp_family_of_bfamily":
 "theorem comp_family_of_bfamily {o} (f : ∀ a < o, α) (g : α → β) :\n    g ∘ familyOfBFamily o f = familyOfBFamily o fun i hi => g (f i hi) :=\n  rfl\n#align comp_family_of_bfamily comp_family_of_bfamily\n\n",
 "comp_bfamily_of_family'":
 "theorem comp_bfamily_of_family' {ι : Type u} (r : ι → ι → Prop) [IsWellOrder ι r] (f : ι → α) (g : α → β) :\n    (fun i hi => g (bfamilyOfFamily' r f i hi)) = bfamilyOfFamily' r (g ∘ f) :=\n  rfl\n#align comp_bfamily_of_family' comp_bfamily_of_family'\n\n",
 "comp_bfamily_of_family":
 "theorem comp_bfamily_of_family {ι : Type u} (f : ι → α) (g : α → β) :\n    (fun i hi => g (bfamilyOfFamily f i hi)) = bfamilyOfFamily (g ∘ f) :=\n  rfl\n#align comp_bfamily_of_family comp_bfamily_of_family\n\n",
 "card_mul":
 "@[simp]\ntheorem card_mul (a b) : card (a * b) = card a * card b :=\n  quotient.induction_on₂ a b fun ⟨α, r, _⟩ ⟨β, s, _⟩ => mul_comm (mk β) (mk α)\n#align card_mul card_mul\n\n",
 "bsup_zero":
 "@[simp]\ntheorem bsup_zero (f : ∀ a < (0 : Ordinal), Ordinal) : bsup 0 f = 0 :=\n  bsup_eq_zero_iff.2 fun i hi => (Ordinal.not_lt_zero i hi).elim\n#align bsup_zero bsup_zero\n\n",
 "bsup_succ_of_mono":
 "theorem bsup_succ_of_mono {o : Ordinal} {f : ∀ a < succ o, Ordinal} (hf : ∀ {i j} (hi hj), i ≤ j → f i hi ≤ f j hj) :\n    bsup _ f = f o (lt_succ o) :=\n  le_antisymm (bsup_le fun i hi => hf _ _ <| le_of_lt_succ hi) (le_bsup _ _ _)\n#align bsup_succ_of_mono bsup_succ_of_mono\n\n",
 "bsup_succ_le_blsub":
 "theorem bsup_succ_le_blsub {o} (f : ∀ a < o, Ordinal) : succ (bsup o f) ≤ blsub o f ↔ ∃ i hi, f i hi = bsup o f :=\n  by\n  refine' ⟨fun h => _, _⟩\n  · by_contra' hf\n    exact ne_of_lt (succ_le_iff.1 h) (le_antisymm (bsup_le_blsub f) (blsub_le (lt_bsup_of_ne_bsup.1 hf)))\n  rintro ⟨_, _, hf⟩\n  rw [succ_le_iff, ← hf]\n  exact lt_blsub _ _ _\n#align bsup_succ_le_blsub bsup_succ_le_blsub\n\n",
 "bsup_succ_eq_blsub":
 "theorem bsup_succ_eq_blsub {o} (f : ∀ a < o, Ordinal) : succ (bsup o f) = blsub o f ↔ ∃ i hi, f i hi = bsup o f :=\n  (blsub_le_bsup_succ f).le_iff_eq.symm.trans (bsup_succ_le_blsub f)\n#align bsup_succ_eq_blsub bsup_succ_eq_blsub\n\n",
 "bsup_one":
 "@[simp]\ntheorem bsup_one (f : ∀ a < (1 : Ordinal), Ordinal) : bsup 1 f = f 0 zero_lt_one := by\n  simp_rw [← sup_eq_bsup, sup_unique, family_of_bfamily, family_of_bfamily', typein_one_out]\n#align bsup_one bsup_one\n\n",
 "bsup_not_succ_of_ne_bsup":
 "theorem bsup_not_succ_of_ne_bsup {o} {f : ∀ a < o, Ordinal} (hf : ∀ {i : Ordinal} (h : i < o), f i h ≠ o.bsup f) (a) :\n    a < bsup o f → succ a < bsup o f := by\n  rw [← sup_eq_bsup] at *\n  exact sup_not_succ_of_ne_sup fun i => hf _\n#align bsup_not_succ_of_ne_bsup bsup_not_succ_of_ne_bsup\n\n",
 "bsup_le_of_brange_subset":
 "theorem bsup_le_of_brange_subset {o o'} {f : ∀ a < o, Ordinal} {g : ∀ a < o', Ordinal} (h : brange o f ⊆ brange o' g) :\n    bsup.{u, max v w} o f ≤ bsup.{v, max u w} o' g :=\n  bsup_le fun i hi => by\n    obtain ⟨j, hj, hj'⟩ := h ⟨i, hi, rfl⟩\n    rw [← hj']\n    apply le_bsup\n#align bsup_le_of_brange_subset bsup_le_of_brange_subset\n\n",
 "bsup_le_iff":
 "theorem bsup_le_iff {o f a} : bsup.{u, v} o f ≤ a ↔ ∀ i h, f i h ≤ a :=\n  sup_le_iff.trans\n    ⟨fun h i hi => by\n      rw [← family_of_bfamily_enum o f]\n      exact h _, fun h i => h _ _⟩\n#align bsup_le_iff bsup_le_iff\n\n",
 "bsup_le_blsub":
 "theorem bsup_le_blsub {o} (f : ∀ a < o, Ordinal) : bsup o f ≤ blsub o f :=\n  bsup_le fun i h => (lt_blsub f i h).le\n#align bsup_le_blsub bsup_le_blsub\n\n",
 "bsup_le":
 "theorem bsup_le {o : Ordinal} {f : ∀ b < o, Ordinal} {a} : (∀ i h, f i h ≤ a) → bsup.{u, v} o f ≤ a :=\n  bsup_le_iff.2\n#align bsup_le bsup_le\n\n",
 "bsup_id_succ":
 "@[simp]\ntheorem bsup_id_succ (o) : (bsup.{u, u} (succ o) fun x _ => x) = o :=\n  sup_typein_succ\n#align bsup_id_succ bsup_id_succ\n\n",
 "bsup_id_limit":
 "theorem bsup_id_limit {o : Ordinal} : (∀ a < o, succ a < o) → (bsup.{u, u} o fun x _ => x) = o :=\n  sup_typein_limit\n#align bsup_id_limit bsup_id_limit\n\n",
 "bsup_eq_zero_iff":
 "@[simp]\ntheorem bsup_eq_zero_iff {o} {f : ∀ a < o, Ordinal} : bsup o f = 0 ↔ ∀ i hi, f i hi = 0 :=\n  by\n  refine' ⟨fun h i hi => _, fun h => le_antisymm (bsup_le fun i hi => Ordinal.le_zero.2 (h i hi)) (Ordinal.zero_le _)⟩\n  rw [← Ordinal.le_zero, ← h]\n  exact le_bsup f i hi\n#align bsup_eq_zero_iff bsup_eq_zero_iff\n\n",
 "bsup_eq_sup'":
 "@[simp]\ntheorem bsup_eq_sup' {ι} (r : ι → ι → Prop) [IsWellOrder ι r] (f : ι → Ordinal) :\n    bsup _ (bfamilyOfFamily' r f) = sup f := by\n  simp only [← sup_eq_bsup' r, enum_typein, family_of_bfamily', bfamily_of_family']\n#align bsup_eq_sup' bsup_eq_sup'\n\n",
 "bsup_eq_sup":
 "@[simp]\ntheorem bsup_eq_sup {ι} (f : ι → Ordinal) : bsup _ (bfamilyOfFamily f) = sup f :=\n  bsup_eq_sup' _ f\n#align bsup_eq_sup bsup_eq_sup\n\n",
 "bsup_eq_of_brange_eq":
 "theorem bsup_eq_of_brange_eq {o o'} {f : ∀ a < o, Ordinal} {g : ∀ a < o', Ordinal} (h : brange o f = brange o' g) :\n    bsup.{u, max v w} o f = bsup.{v, max u w} o' g :=\n  (bsup_le_of_brange_subset h.le).antisymm (bsup_le_of_brange_subset.{v, u, w} h.ge)\n#align bsup_eq_of_brange_eq bsup_eq_of_brange_eq\n\n",
 "bsup_eq_bsup":
 "theorem bsup_eq_bsup {ι : Type u} (r r' : ι → ι → Prop) [IsWellOrder ι r] [IsWellOrder ι r'] (f : ι → Ordinal) :\n    bsup _ (bfamilyOfFamily' r f) = bsup _ (bfamilyOfFamily' r' f) := by rw [bsup_eq_sup', bsup_eq_sup']\n#align bsup_eq_bsup bsup_eq_bsup\n\n",
 "bsup_eq_blsub_or_succ_bsup_eq_blsub":
 "theorem bsup_eq_blsub_or_succ_bsup_eq_blsub {o} (f : ∀ a < o, Ordinal) :\n    bsup o f = blsub o f ∨ succ (bsup o f) = blsub o f :=\n  by\n  rw [← sup_eq_bsup, ← lsub_eq_blsub]\n  exact sup_eq_lsub_or_sup_succ_eq_lsub _\n#align bsup_eq_blsub_or_succ_bsup_eq_blsub bsup_eq_blsub_or_succ_bsup_eq_blsub\n\n",
 "bsup_eq_blsub_of_lt_succ_limit":
 "theorem bsup_eq_blsub_of_lt_succ_limit {o} (ho : IsLimit o) {f : ∀ a < o, Ordinal}\n    (hf : ∀ a ha, f a ha < f (succ a) (ho.2 a ha)) : bsup o f = blsub o f :=\n  by\n  rw [bsup_eq_blsub_iff_lt_bsup]\n  exact fun i hi => (hf i hi).trans_le (le_bsup f _ _)\n#align bsup_eq_blsub_of_lt_succ_limit bsup_eq_blsub_of_lt_succ_limit\n\n",
 "bsup_eq_blsub_iff_succ":
 "theorem bsup_eq_blsub_iff_succ {o} (f : ∀ a < o, Ordinal) :\n    bsup o f = blsub o f ↔ ∀ a < blsub o f, succ a < blsub o f :=\n  by\n  rw [← sup_eq_bsup, ← lsub_eq_blsub]\n  apply sup_eq_lsub_iff_succ\n#align bsup_eq_blsub_iff_succ bsup_eq_blsub_iff_succ\n\n",
 "bsup_eq_blsub_iff_lt_bsup":
 "theorem bsup_eq_blsub_iff_lt_bsup {o} (f : ∀ a < o, Ordinal) : bsup o f = blsub o f ↔ ∀ i hi, f i hi < bsup o f :=\n  ⟨fun h i => by\n    rw [h]\n    apply lt_blsub, fun h => le_antisymm (bsup_le_blsub f) (blsub_le h)⟩\n#align bsup_eq_blsub_iff_lt_bsup bsup_eq_blsub_iff_lt_bsup\n\n",
 "bsup_eq_blsub":
 "@[simp]\ntheorem bsup_eq_blsub (o : Ordinal) (f : ∀ a < o, Ordinal) : (bsup o fun a ha => succ (f a ha)) = blsub o f :=\n  rfl\n#align bsup_eq_blsub bsup_eq_blsub\n\n",
 "bsup_eq":
 "theorem is_normal.bsup_eq {f} (H : IsNormal f) {o : Ordinal} (h : IsLimit o) : (bsup.{u} o fun x _ => f x) = f o := by\n  rw [← IsNormal.bsup.{u, u} H (fun x _ => x) h.1, bsup_id_limit h.2]\n#align is_normal.bsup_eq is_normal.bsup_eq\n\n",
 "bsup_const":
 "theorem bsup_const {o : Ordinal} (ho : o ≠ 0) (a : Ordinal) : (bsup o fun _ _ => a) = a :=\n  le_antisymm (bsup_le fun _ _ => le_rfl) (le_bsup _ 0 (Ordinal.pos_iff_ne_zero.2 ho))\n#align bsup_const bsup_const\n\n",
 "bsup_congr":
 "@[congr]\ntheorem bsup_congr {o₁ o₂ : Ordinal} (f : ∀ a < o₁, Ordinal) (ho : o₁ = o₂) :\n    bsup o₁ f = bsup o₂ fun a h => f a (h.trans_eq ho.symm) := by subst ho\n#align bsup_congr bsup_congr\n\n",
 "bsup_comp":
 "theorem bsup_comp {o o' : Ordinal} {f : ∀ a < o, Ordinal} (hf : ∀ {i j} (hi) (hj), i ≤ j → f i hi ≤ f j hj)\n    {g : ∀ a < o', Ordinal} (hg : blsub o' g = o) :\n    (bsup o' fun a ha =>\n        f (g a ha)\n          (by\n            rw [← hg]\n            apply lt_blsub)) =\n      bsup o f :=\n  by\n  apply le_antisymm <;> refine' bsup_le fun i hi => _\n  · apply le_bsup\n  · rw [← hg, lt_blsub_iff] at hi\n    rcases hi with ⟨j, hj, hj'⟩\n    exact (hf _ _ hj').trans (le_bsup _ _ _)\n#align bsup_comp bsup_comp\n\n",
 "bsup":
 "theorem is_normal.bsup {f} (H : IsNormal f) {o} :\n    ∀ (g : ∀ a < o, Ordinal) (h : o ≠ 0), f (bsup o g) = bsup o fun a h => f (g a h) :=\n  inductionOn o fun α r _ g h => by\n    skip\n    haveI := type_ne_zero_iff_nonempty.1 h\n    rw [← sup_eq_bsup' r, H.sup, ← sup_eq_bsup' r] <;> rfl\n#align is_normal.bsup is_normal.bsup\n\n",
 "brange_const":
 "@[simp]\ntheorem brange_const {o : Ordinal} (ho : o ≠ 0) {c : α} : (brange o fun _ _ => c) = {c} :=\n  by\n  rw [← range_family_of_bfamily]\n  exact @Set.range_const _ o.out.α (out_nonempty_iff_ne_zero.2 ho) c\n#align brange_const brange_const\n\n",
 "brange_bfamily_of_family'":
 "@[simp]\ntheorem brange_bfamily_of_family' {ι : Type u} (r : ι → ι → Prop) [IsWellOrder ι r] (f : ι → α) :\n    brange _ (bfamilyOfFamily' r f) = range f :=\n  by\n  refine' Set.ext fun a => ⟨_, _⟩\n  · rintro ⟨i, hi, rfl⟩\n    apply mem_range_self\n  · rintro ⟨b, rfl⟩\n    exact ⟨_, _, bfamily_of_family'_typein _ _ _⟩\n#align brange_bfamily_of_family' brange_bfamily_of_family'\n\n",
 "brange_bfamily_of_family":
 "@[simp]\ntheorem brange_bfamily_of_family {ι : Type u} (f : ι → α) : brange _ (bfamilyOfFamily f) = range f :=\n  brange_bfamilyOfFamily' _ _\n#align brange_bfamily_of_family brange_bfamily_of_family\n\n",
 "bounded_singleton":
 "theorem bounded_singleton {r : α → α → Prop} [IsWellOrder α r] (hr : (type r).is_limit) (x) : Bounded r {x} :=\n  by\n  refine' ⟨enum r (succ (typein r x)) (hr.2 _ (typein_lt_type r x)), _⟩\n  intro b hb\n  rw [mem_singleton_iff.1 hb]\n  nth_rw 1 [← enum_typein r x]\n  rw [@enum_lt_enum _ r]\n  apply lt_succ\n#align bounded_singleton bounded_singleton\n\n",
 "bmex_not_mem_brange":
 "theorem bmex_not_mem_brange {o : Ordinal} (f : ∀ a < o, Ordinal) : bmex o f ∉ brange o f :=\n  by\n  rw [← range_family_of_bfamily]\n  apply mex_not_mem_range\n#align bmex_not_mem_brange bmex_not_mem_brange\n\n",
 "bmex_monotone":
 "theorem bmex_monotone {o o' : Ordinal} {f : ∀ a < o, Ordinal} {g : ∀ a < o', Ordinal} (h : brange o f ⊆ brange o' g) :\n    bmex o f ≤ bmex o' g :=\n  mex_monotone (by rwa [range_family_of_bfamily, range_family_of_bfamily])\n#align bmex_monotone bmex_monotone\n\n",
 "bmex_lt_ord_succ_card":
 "theorem bmex_lt_ord_succ_card {o : Ordinal} (f : ∀ a < o, Ordinal) : bmex o f < (succ o.card).ord :=\n  by\n  rw [← mk_ordinal_out]\n  exact mex_lt_ord_succ_mk (family_of_bfamily o f)\n#align bmex_lt_ord_succ_card bmex_lt_ord_succ_card\n\n",
 "bmex_le_of_ne":
 "theorem bmex_le_of_ne {o : Ordinal} {f : ∀ a < o, Ordinal} {a} (ha : ∀ i hi, f i hi ≠ a) : bmex o f ≤ a :=\n  mex_le_of_ne fun i => ha _ _\n#align bmex_le_of_ne bmex_le_of_ne\n\n",
 "bmex_le_blsub":
 "theorem bmex_le_blsub {o : Ordinal} (f : ∀ a < o, Ordinal) : bmex o f ≤ blsub o f :=\n  mex_le_lsub _\n#align bmex_le_blsub bmex_le_blsub\n\n",
 "blsub_zero":
 "@[simp]\ntheorem blsub_zero (f : ∀ a < (0 : Ordinal), Ordinal) : blsub 0 f = 0 := by rwa [blsub_eq_zero_iff]\n#align blsub_zero blsub_zero\n\n",
 "blsub_type":
 "theorem blsub_type (r : α → α → Prop) [IsWellOrder α r] (f) :\n    blsub (type r) f = lsub fun a => f (typein r a) (typein_lt_type _ _) :=\n  eq_of_forall_ge_iff fun o => by\n    rw [blsub_le_iff, lsub_le_iff] <;>\n      exact ⟨fun H b => H _ _, fun H i h => by simpa only [typein_enum] using H (enum r i h)⟩\n#align blsub_type blsub_type\n\n",
 "blsub_succ_of_mono":
 "theorem blsub_succ_of_mono {o : Ordinal} {f : ∀ a < succ o, Ordinal} (hf : ∀ {i j} (hi hj), i ≤ j → f i hi ≤ f j hj) :\n    blsub _ f = succ (f o (lt_succ o)) :=\n  bsup_succ_of_mono fun i j hi hj h => succ_le_succ (hf hi hj h)\n#align blsub_succ_of_mono blsub_succ_of_mono\n\n",
 "blsub_pos":
 "theorem blsub_pos {o : Ordinal} (ho : 0 < o) (f : ∀ a < o, Ordinal) : 0 < blsub o f :=\n  (Ordinal.zero_le _).trans_lt (lt_blsub f 0 ho)\n#align blsub_pos blsub_pos\n\n",
 "blsub_one":
 "@[simp]\ntheorem blsub_one (f : ∀ a < (1 : Ordinal), Ordinal) : blsub 1 f = succ (f 0 zero_lt_one) :=\n  bsup_one _\n#align blsub_one blsub_one\n\n",
 "blsub_le_of_brange_subset":
 "theorem blsub_le_of_brange_subset {o o'} {f : ∀ a < o, Ordinal} {g : ∀ a < o', Ordinal} (h : brange o f ⊆ brange o' g) :\n    blsub.{u, max v w} o f ≤ blsub.{v, max u w} o' g :=\n  bsup_le_of_brange_subset fun a ⟨b, hb, hb'⟩ =>\n    by\n    obtain ⟨c, hc, hc'⟩ := h ⟨b, hb, rfl⟩\n    simp_rw [← hc'] at hb'\n    exact ⟨c, hc, hb'⟩\n#align blsub_le_of_brange_subset blsub_le_of_brange_subset\n\n",
 "blsub_le_iff":
 "theorem blsub_le_iff {o f a} : blsub o f ≤ a ↔ ∀ i h, f i h < a :=\n  by\n  convert bsup_le_iff\n  simp [succ_le_iff]\n#align blsub_le_iff blsub_le_iff\n\n",
 "blsub_le_enum_ord":
 "theorem blsub_le_enum_ord (hS : Unbounded (· < ·) S) (o) : (blsub.{u, u} o fun c _ => enumOrd S c) ≤ enumOrd S o :=\n  (enum_ord_mem_aux hS o).right\n#align blsub_le_enum_ord blsub_le_enum_ord\n\n",
 "blsub_le_bsup_succ":
 "theorem blsub_le_bsup_succ {o} (f : ∀ a < o, Ordinal) : blsub o f ≤ succ (bsup o f) :=\n  blsub_le fun i h => lt_succ_iff.2 (le_bsup f i h)\n#align blsub_le_bsup_succ blsub_le_bsup_succ\n\n",
 "blsub_le":
 "theorem blsub_le {o : Ordinal} {f : ∀ b < o, Ordinal} {a} : (∀ i h, f i h < a) → blsub o f ≤ a :=\n  blsub_le_iff.2\n#align blsub_le blsub_le\n\n",
 "blsub_id":
 "@[simp]\ntheorem blsub_id : ∀ o, (blsub.{u, u} o fun x _ => x) = o :=\n  lsub_typein\n#align blsub_id blsub_id\n\n",
 "blsub_eq_zero_iff":
 "@[simp]\ntheorem blsub_eq_zero_iff {o} {f : ∀ a < o, Ordinal} : blsub o f = 0 ↔ o = 0 :=\n  by\n  rw [← lsub_eq_blsub, lsub_eq_zero_iff]\n  exact out_empty_iff_eq_zero\n#align blsub_eq_zero_iff blsub_eq_zero_iff\n\n",
 "blsub_eq_of_brange_eq":
 "theorem blsub_eq_of_brange_eq {o o'} {f : ∀ a < o, Ordinal} {g : ∀ a < o', Ordinal}\n    (h : { o | ∃ i hi, f i hi = o } = { o | ∃ i hi, g i hi = o }) : blsub.{u, max v w} o f = blsub.{v, max u w} o' g :=\n  (blsub_le_of_brange_subset h.le).antisymm (blsub_le_of_brange_subset.{v, u, w} h.ge)\n#align blsub_eq_of_brange_eq blsub_eq_of_brange_eq\n\n",
 "blsub_eq_lsub'":
 "@[simp]\ntheorem blsub_eq_lsub' {ι} (r : ι → ι → Prop) [IsWellOrder ι r] (f : ι → Ordinal) :\n    blsub _ (bfamilyOfFamily' r f) = lsub f :=\n  bsup_eq_sup' r (succ ∘ f)\n#align blsub_eq_lsub' blsub_eq_lsub'\n\n",
 "blsub_eq_lsub":
 "@[simp]\ntheorem blsub_eq_lsub {ι} (f : ι → Ordinal) : blsub _ (bfamilyOfFamily f) = lsub f :=\n  blsub_eq_lsub' _ _\n#align blsub_eq_lsub blsub_eq_lsub\n\n",
 "blsub_eq_blsub":
 "theorem blsub_eq_blsub {ι : Type u} (r r' : ι → ι → Prop) [IsWellOrder ι r] [IsWellOrder ι r'] (f : ι → Ordinal) :\n    blsub _ (bfamilyOfFamily' r f) = blsub _ (bfamilyOfFamily' r' f) := by rw [blsub_eq_lsub', blsub_eq_lsub']\n#align blsub_eq_blsub blsub_eq_blsub\n\n",
 "blsub_eq":
 "theorem is_normal.blsub_eq {f} (H : IsNormal f) {o : Ordinal} (h : IsLimit o) : (blsub.{u} o fun x _ => f x) = f o :=\n  by\n  rw [← H.bsup_eq h, bsup_eq_blsub_of_lt_succ_limit h]\n  exact fun a _ => H.1 a\n#align is_normal.blsub_eq is_normal.blsub_eq\n\n",
 "blsub_const":
 "theorem blsub_const {o : Ordinal} (ho : o ≠ 0) (a : Ordinal) : (blsub.{u, v} o fun _ _ => a) = succ a :=\n  bsup_const.{u, v} ho (succ a)\n#align blsub_const blsub_const\n\n",
 "blsub_congr":
 "@[congr]\ntheorem blsub_congr {o₁ o₂ : Ordinal} (f : ∀ a < o₁, Ordinal) (ho : o₁ = o₂) :\n    blsub o₁ f = blsub o₂ fun a h => f a (h.trans_eq ho.symm) := by subst ho\n#align blsub_congr blsub_congr\n\n",
 "blsub_comp":
 "theorem blsub_comp {o o' : Ordinal} {f : ∀ a < o, Ordinal} (hf : ∀ {i j} (hi) (hj), i ≤ j → f i hi ≤ f j hj)\n    {g : ∀ a < o', Ordinal} (hg : blsub o' g = o) :\n    (blsub o' fun a ha =>\n        f (g a ha)\n          (by\n            rw [← hg]\n            apply lt_blsub)) =\n      blsub o f :=\n  @bsup_comp o _ (fun a ha => succ (f a ha)) (fun i j _ _ h => succ_le_succ_iff.2 (hf _ _ h)) g hg\n#align blsub_comp blsub_comp\n\n",
 "bfamily_of_family_typein":
 "@[simp]\ntheorem bfamily_of_family_typein {ι} (f : ι → α) (i) : bfamilyOfFamily f (typein _ i) (typein_lt_type _ i) = f i :=\n  bfamilyOfFamily'_typein _ f i\n#align bfamily_of_family_typein bfamily_of_family_typein\n\n",
 "bfamily_of_family'_typein":
 "@[simp]\ntheorem bfamily_of_family'_typein {ι} (r : ι → ι → Prop) [IsWellOrder ι r] (f : ι → α) (i) :\n    bfamilyOfFamily' r f (typein r i) (typein_lt_type r i) = f i := by simp only [bfamily_of_family', enum_typein]\n#align bfamily_of_family'_typein bfamily_of_family'_typein\n\n",
 "bdd_above_range":
 "/-- The range of an indexed ordinal function, whose outputs live in a higher universe than the\n    inputs, is always bounded above. See `ordinal.lsub` for an explicit bound. -/\ntheorem bdd_above_range {ι : Type u} (f : ι → Ordinal.{max u v}) : BddAbove (Set.range f) :=\n  ⟨(supᵢ (succ ∘ card ∘ f)).ord, by\n    rintro a ⟨i, rfl⟩\n    exact le_of_lt (Cardinal.lt_ord.2 ((lt_succ _).trans_le (le_csupᵢ (bdd_above_range _) _)))⟩\n#align bdd_above_range bdd_above_range\n\n",
 "bdd_above_of_small":
 "theorem bdd_above_of_small (s : Set Ordinal.{u}) [h : Small.{u} s] : BddAbove s :=\n  bddAbove_iff_small.2 h\n#align bdd_above_of_small bdd_above_of_small\n\n",
 "bdd_above_iff_small":
 "theorem bdd_above_iff_small {s : Set Ordinal.{u}} : BddAbove s ↔ Small.{u} s :=\n  ⟨fun ⟨a, h⟩ => small_subset <| show s ⊆ Iic a from fun x hx => h hx, fun h =>\n    ⟨sup.{u, u} fun x => ((@equivShrink s h).symm x).val, le_sup_shrink_equiv h⟩⟩\n#align bdd_above_iff_small bdd_above_iff_small\n\n",
 "apply_omega":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ordinal.omega -/\ntheorem is_normal.apply_omega {f : Ordinal.{u} → Ordinal.{u}} (hf : IsNormal f) :\n    sup.{0, u} (f ∘ Nat.cast) = f (ordinal.omega) := by rw [← sup_nat_cast, IsNormal.sup.{0, u, u} hf]\n#align is_normal.apply_omega is_normal.apply_omega\n\n",
 "add_sub_cancel_of_le":
 "protected theorem add_sub_cancel_of_le {a b : Ordinal} (h : b ≤ a) : b + (a - b) = a :=\n  (le_add_sub a b).antisymm'\n    (by\n      rcases zero_or_succ_or_limit (a - b) with (e | ⟨c, e⟩ | l)\n      · simp only [e, add_zero, h]\n      · rw [e, add_succ, succ_le_iff, ← lt_sub, e]\n        exact lt_succ c\n      · exact (add_le_of_limit l).2 fun c l => (lt_sub.1 l).le)\n#align add_sub_cancel_of_le add_sub_cancel_of_le\n\n",
 "add_sub_cancel":
 "#print add_sub_cancel /-\ntheorem add_sub_cancel (a b : Ordinal) : a + b - a = b :=\n  le_antisymm (sub_le.2 <| le_rfl) ((add_le_add_iff_left a).1 <| le_add_sub _ _)\n#align add_sub_cancel add_sub_cancel\n-/\n\n",
 "add_sub_add_cancel":
 "@[simp]\ntheorem add_sub_add_cancel (a b c : Ordinal) : a + b - (a + c) = b - c := by rw [← sub_sub, add_sub_cancel]\n#align add_sub_add_cancel add_sub_add_cancel\n\n",
 "add_right_cancel":
 "#print add_right_cancel /-\ntheorem add_right_cancel {a b : Ordinal} (n : ℕ) : a + n = b + n ↔ a = b := by\n  simp only [le_antisymm_iff, add_le_add_iff_right]\n#align add_right_cancel add_right_cancel\n-/\n\n",
 "add_one_of_aleph_0_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n@[simp]\ntheorem add_one_of_aleph_0_le {c} (h : cardinal.aleph_0 ≤ c) : c + 1 = c :=\n  by\n  rw [add_comm, ← card_ord c, ← card_one, ← card_add, one_add_of_omega_le]\n  rwa [← ord_aleph_0, ord_le_ord]\n#align add_one_of_aleph_0_le add_one_of_aleph_0_le\n\n",
 "add_mul_succ":
 "theorem add_mul_succ {a b : Ordinal} (c) (ba : b + a = a) : (a + b) * succ c = a * succ c + b :=\n  by\n  apply limit_rec_on c\n  · simp only [succ_zero, mul_one]\n  · intro c IH\n    rw [mul_succ, IH, ← add_assoc, add_assoc _ b, ba, ← mul_succ]\n  · intro c l IH\n    have := add_mul_limit_aux ba l IH\n    rw [mul_succ, add_mul_limit_aux ba l IH, mul_succ, add_assoc]\n#align add_mul_succ add_mul_succ\n\n",
 "add_mul_limit_aux":
 "theorem add_mul_limit_aux {a b c : Ordinal} (ba : b + a = a) (l : IsLimit c)\n    (IH : ∀ c' < c, (a + b) * succ c' = a * succ c' + b) : (a + b) * c = a * c :=\n  le_antisymm\n    ((mul_le_of_limit l).2 fun c' h => by\n      apply (mul_le_mul_left' (le_succ c') _).trans\n      rw [IH _ h]\n      apply (add_le_add_left _ _).trans\n      · rw [← mul_succ]\n        exact mul_le_mul_left' (succ_le_of_lt <| l.2 _ h) _\n      · infer_instance\n      · rw [← ba]\n        exact le_add_right _ _)\n    (mul_le_mul_right' (le_add_right _ _) _)\n#align add_mul_limit_aux add_mul_limit_aux\n\n",
 "add_mul_limit":
 "theorem add_mul_limit {a b c : Ordinal} (ba : b + a = a) (l : IsLimit c) : (a + b) * c = a * c :=\n  add_mul_limit_aux ba l fun c' _ => add_mul_succ c' ba\n#align add_mul_limit add_mul_limit\n\n",
 "add_lt_add_iff_left'":
 "private theorem add_lt_add_iff_left' (a) {b c : Ordinal} : a + b < a + c ↔ b < c := by\n  rw [← not_le, ← not_le, add_le_add_iff_left]\n#align add_lt_add_iff_left' add_lt_add_iff_left'\n\n",
 "add_left_cancel":
 "#print add_left_cancel /-\ntheorem add_left_cancel (a) {b c : Ordinal} : a + b = a + c ↔ b = c := by\n  simp only [le_antisymm_iff, add_le_add_iff_left]\n#align add_left_cancel add_left_cancel\n-/\n\n",
 "add_le_of_limit":
 "theorem add_le_of_limit {a b c : Ordinal} (h : IsLimit b) : a + b ≤ c ↔ ∀ b' < b, a + b' ≤ c :=\n  ⟨fun h b' l => (add_le_add_left l.le _).trans h, fun H =>\n    le_of_not_lt <|\n      inductionOn a\n        (fun α r _ =>\n          inductionOn b fun β s _ h H l => by\n            skip\n            suffices ∀ x : β, Sum.Lex r s (Sum.inr x) (enum _ _ l)\n              by\n              cases' enum _ _ l with x x\n              · cases this (enum s 0 h.pos)\n              · exact irrefl _ (this _)\n            intro x\n            rw [← typein_lt_typein (Sum.Lex r s), typein_enum]\n            have := H _ (h.2 _ (typein_lt_type s x))\n            rw [add_succ, succ_le_iff] at this\n            refine' (RelEmbedding.ofMonotone (fun a => _) fun a b => _).ordinal_type_le.trans_lt this\n            · rcases a with ⟨a | b, h⟩\n              · exact Sum.inl a\n              · exact Sum.inr ⟨b, by cases h <;> assumption⟩\n            ·\n              rcases a with ⟨a | a, h₁⟩ <;> rcases b with ⟨b | b, h₂⟩ <;> cases h₁ <;> cases h₂ <;> rintro ⟨⟩ <;>\n                  constructor <;>\n                assumption)\n        h H⟩\n#align add_le_of_limit add_le_of_limit\n\n",
 "add_le_of_forall_add_lt":
 "theorem add_le_of_forall_add_lt {a b c : Ordinal} (hb : 0 < b) (h : ∀ d < b, a + d < c) : a + b ≤ c :=\n  by\n  have H : a + (c - a) = c :=\n    Ordinal.add_sub_cancel_of_le\n      (by\n        rw [← add_zero a]\n        exact (h _ hb).le)\n  rw [← H]\n  apply add_le_add_left _ a\n  by_contra' hb\n  exact (h _ hb).ne H\n#align add_le_of_forall_add_lt add_le_of_forall_add_lt\n\n",
 "add_le_add_iff_right":
 "#print add_le_add_iff_right /-\ntheorem add_le_add_iff_right {a b : Ordinal} : ∀ n : ℕ, a + n ≤ b + n ↔ a ≤ b\n  | 0 => by simp\n  | n + 1 => by rw [nat_cast_succ, add_succ, add_succ, succ_le_succ_iff, add_le_add_iff_right]\n#align add_le_add_iff_right add_le_add_iff_right\n-/\n\n",
 "add_is_normal":
 "theorem add_is_normal (a : Ordinal) : IsNormal ((· + ·) a) :=\n  ⟨fun b => (add_lt_add_iff_left a).2 (lt_succ b), fun b l c => add_le_of_limit l⟩\n#align add_is_normal add_is_normal\n\n",
 "add_is_limit":
 "theorem add_is_limit (a) {b} : IsLimit b → IsLimit (a + b) :=\n  (add_isNormal a).is_limit\n#align add_is_limit add_is_limit\n\n",
 "add_eq_zero_iff":
 "#print add_eq_zero_iff /-\ntheorem add_eq_zero_iff {a b : Ordinal} : a + b = 0 ↔ a = 0 ∧ b = 0 :=\n  inductionOn a fun α r _ =>\n    inductionOn b fun β s _ => by\n      simp_rw [← type_sum_lex, type_eq_zero_iff_is_empty]\n      exact isEmpty_sum\n#align add_eq_zero_iff add_eq_zero_iff\n-/\n\n",
 "Sup_ord":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem Sup_ord {s : Set Cardinal.{u}} (hs : BddAbove s) : (supₛ s).ord = supₛ («expr '' » ord s) :=\n  eq_of_forall_ge_iff fun a =>\n    by\n    rw [csupₛ_le_iff' (bdd_above_iff_small.2 (@small_image _ _ _ s (Cardinal.bddAbove_iff_small.1 hs))), ord_le,\n      csupₛ_le_iff' hs]\n    simp [ord_le]\n#align Sup_ord Sup_ord\n\n",
 "Sup_eq_sup":
 "@[simp]\ntheorem Sup_eq_sup {ι : Type u} (f : ι → Ordinal.{max u v}) : supₛ (Set.range f) = sup f :=\n  rfl\n#align Sup_eq_sup Sup_eq_sup\n\n",
 "Sup_eq_bsup":
 "@[simp]\ntheorem Sup_eq_bsup {o} (f : ∀ a < o, Ordinal) : supₛ (brange o f) = bsup o f :=\n  by\n  congr\n  rw [range_family_of_bfamily]\n#align Sup_eq_bsup Sup_eq_bsup\n\n"}