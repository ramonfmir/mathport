{"univ":
 "#print MeasurableSet.univ /-\n@[simp]\ntheorem MeasurableSet.univ : MeasurableSet (univ : Set α) := by simpa using (@MeasurableSet.empty α _).compl\n#align measurable_set.univ MeasurableSet.univ\n-/\n\n",
 "unionₛ":
 "#print MeasurableSet.unionₛ /-\ntheorem MeasurableSet.unionₛ {s : Set (Set α)} (hs : s.countable) (h : ∀ t ∈ s, MeasurableSet t) :\n    MeasurableSet (⋃₀ s) := by\n  rw [sUnion_eq_bUnion]\n  exact MeasurableSet.bunionᵢ hs h\n#align measurable_set.sUnion MeasurableSet.unionₛ\n-/\n\n",
 "unionᵢ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n#print MeasurableSet.unionᵢ /-\ntheorem MeasurableSet.unionᵢ [Countable ι] ⦃f : ι → Set α⦄ (h : ∀ b, MeasurableSet (f b)) :\n    MeasurableSet\n      («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (f b)) :=\n  by\n  cases nonempty_encodable (PLift ι)\n  rw [← Union_plift_down, ← Encodable.unionᵢ_decode₂]\n  exact ‹MeasurableSpace α›.measurable_set_Union _ (MeasurableSet.bunionᵢ_decode₂ fun _ => h _)\n#align measurable_set.Union MeasurableSet.unionᵢ\n-/\n\n",
 "union":
 "#print MeasurableSet.union /-\n@[simp]\ntheorem MeasurableSet.union {s₁ s₂ : Set α} (h₁ : MeasurableSet s₁) (h₂ : MeasurableSet s₂) : MeasurableSet (s₁ ∪ s₂) :=\n  by\n  rw [union_eq_Union]\n  exact MeasurableSet.unionᵢ (Bool.forall_bool.2 ⟨h₂, h₁⟩)\n#align measurable_set.union MeasurableSet.union\n-/\n\n",
 "symmDiff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∆ » -/\n#print MeasurableSet.symmDiff /-\n@[simp]\ntheorem MeasurableSet.symmDiff {s₁ s₂ : Set α} (h₁ : MeasurableSet s₁) (h₂ : MeasurableSet s₂) :\n    MeasurableSet («expr ∆ » s₁ s₂) :=\n  (h₁.diff h₂).union (h₂.diff h₁)\n#align measurable_set.symm_diff MeasurableSet.symmDiff\n-/\n\n",
 "of_compl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n#print MeasurableSet.of_compl /-\ntheorem MeasurableSet.of_compl (h : MeasurableSet («expr ᶜ» s)) : MeasurableSet s :=\n  compl_compl s ▸ h.compl\n#align measurable_set.of_compl MeasurableSet.of_compl\n-/\n\n",
 "nonempty_measurable_superset":
 "#print nonempty_measurable_superset /-\n/-- Every set has a measurable superset. Declare this as local instance as needed. -/\ntheorem nonempty_measurable_superset (s : Set α) : Nonempty { t // s ⊆ t ∧ MeasurableSet t } :=\n  ⟨⟨univ, subset_univ s, MeasurableSet.univ⟩⟩\n#align nonempty_measurable_superset nonempty_measurable_superset\n-/\n\n",
 "mk_of_closure_sets":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\ntheorem mk_of_closure_sets {s : Set (Set α)} {hs : { t | (measurable_set_of (generateFrom s)) t } = s} :\n    MeasurableSpace.mkOfClosure s hs = generateFrom s :=\n  MeasurableSpace.ext fun t =>\n    show t ∈ s ↔ _ by\n      conv_lhs => rw [← hs]\n      rfl\n#align mk_of_closure_sets mk_of_closure_sets\n\n",
 "measurable_space_supr_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\ntheorem measurable_space_supr_eq (m : ι → MeasurableSpace α) :\n    «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (m n) =\n      generateFrom { s | ∃ n, (measurable_set_of (m n)) s } :=\n  by\n  ext s\n  rw [measurable_set_supr]\n  rfl\n#align measurable_space_supr_eq measurable_space_supr_eq\n\n",
 "measurable_set_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem measurable_set_top {s : Set α} : @MeasurableSet _ («expr⊤») s :=\n  trivial\n#align measurable_set_top measurable_set_top\n\n",
 "measurable_set_supr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\ntheorem measurable_set_supr {ι} {m : ι → MeasurableSpace α} {s : Set α} :\n    @MeasurableSet _ (supᵢ m) s ↔ GenerateMeasurable { s : Set α | ∃ i, (measurable_set_of (m i)) s } s := by\n  simp only [supᵢ, measurable_set_Sup, exists_range_iff]\n#align measurable_set_supr measurable_set_supr\n\n",
 "measurable_set_sup":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\ntheorem measurable_set_sup {m₁ m₂ : MeasurableSpace α} {s : Set α} :\n    (measurable_set_of («expr ⊔ » m₁ m₂)) s ↔ GenerateMeasurable (measurable_set_of m₁ ∪ measurable_set_of m₂) s :=\n  iff.refl _\n#align measurable_set_sup measurable_set_sup\n\n",
 "measurable_set_infi":
 "@[simp]\ntheorem measurable_set_infi {ι} {m : ι → MeasurableSpace α} {s : Set α} :\n    @MeasurableSet _ (infᵢ m) s ↔ ∀ i, @MeasurableSet _ (m i) s := by rw [infᵢ, measurable_set_Inf, forall_range_iff]\n#align measurable_set_infi measurable_set_infi\n\n",
 "measurable_set_inf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n@[simp]\ntheorem measurable_set_inf {m₁ m₂ : MeasurableSpace α} {s : Set α} :\n    @MeasurableSet _ («expr ⊓ » m₁ m₂) s ↔ @MeasurableSet _ m₁ s ∧ @MeasurableSet _ m₂ s :=\n  iff.rfl\n#align measurable_set_inf measurable_set_inf\n\n",
 "measurable_set_generate_from":
 "theorem measurable_set_generate_from {s : Set (Set α)} {t : Set α} (ht : t ∈ s) : @MeasurableSet _ (generateFrom s) t :=\n  generate_measurable.basic t ht\n#align measurable_set_generate_from measurable_set_generate_from\n\n",
 "measurable_set_bot_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem measurable_set_bot_iff {s : Set α} : @MeasurableSet α («expr⊥») s ↔ s = ∅ ∨ s = univ :=\n  let b : MeasurableSpace α :=\n    { measurable_set' := fun s => s = ∅ ∨ s = univ\n      measurable_set_empty := or.inl rfl\n      measurable_set_compl := by simp (config := { contextual := true }) [or_imp]\n      measurable_set_Union := fun f hf =>\n        by_cases\n          (fun h : ∃ i, f i = univ =>\n            let ⟨i, hi⟩ := h\n            or.inr <| eq_univ_of_univ_subset <| hi ▸ le_supᵢ f i)\n          fun h : ¬∃ i, f i = univ =>\n          or.inl <|\n            eq_empty_of_subset_empty <|\n              unionᵢ_subset fun i =>\n                (hf i).elim (by simp (config := { contextual := true })) fun hi => false.elim <| h ⟨i, hi⟩ }\n  have : b = «expr⊥» :=\n    bot_unique fun s hs =>\n      hs.elim (fun s => s.symm ▸ @measurable_set_empty _ («expr⊥»)) fun s => s.symm ▸ @MeasurableSet.univ _ («expr⊥»)\n  this ▸ iff.rfl\n#align measurable_set_bot_iff measurable_set_bot_iff\n\n",
 "measurable_set_Sup":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\ntheorem measurable_set_Sup {ms : Set (MeasurableSpace α)} {s : Set α} :\n    (measurable_set_of (supₛ ms)) s ↔ GenerateMeasurable { s : Set α | ∃ m ∈ ms, (measurable_set_of m) s } s :=\n  by\n  change @measurable_set' _ (generate_from <| ⋃₀ _) _ ↔ _\n  simp [generate_from, ← set_of_exists]\n#align measurable_set_Sup measurable_set_Sup\n\n",
 "measurable_set_Inf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂₀ » -/\n@[simp]\ntheorem measurable_set_Inf {ms : Set (MeasurableSpace α)} {s : Set α} :\n    @MeasurableSet _ (infₛ ms) s ↔ ∀ m ∈ ms, @MeasurableSet _ m s :=\n  show s ∈ «expr⋂₀ » _ ↔ _ by simp\n#align measurable_set_Inf measurable_set_Inf\n\n",
 "measurable_id'":
 "#print measurable_id' /-\ntheorem measurable_id' {ma : MeasurableSpace α} : Measurable fun a : α => a :=\n  measurable_id\n#align measurable_id' measurable_id'\n-/\n\n",
 "measurable_id":
 "#print measurable_id /-\ntheorem measurable_id {ma : MeasurableSpace α} : Measurable (@id α) := fun t => id\n#align measurable_id measurable_id\n-/\n\n",
 "measurable_const":
 "#print measurable_const /-\n@[simp]\ntheorem measurable_const {ma : MeasurableSpace α} {mb : MeasurableSpace β} {a : α} : Measurable fun b : β => a :=\n  fun s hs => MeasurableSet.const (a ∈ s)\n#align measurable_const measurable_const\n-/\n\n",
 "measurableSet_unionₛ":
 "#print Set.Finite.measurableSet_unionₛ /-\ntheorem Set.Finite.measurableSet_unionₛ {s : Set (Set α)} (hs : s.finite) (h : ∀ t ∈ s, MeasurableSet t) :\n    MeasurableSet (⋃₀ s) :=\n  MeasurableSet.unionₛ hs.countable h\n#align set.finite.measurable_set_sUnion Set.Finite.measurableSet_unionₛ\n-/\n\n",
 "measurableSet_interₛ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂₀ » -/\n#print Set.Finite.measurableSet_interₛ /-\ntheorem Set.Finite.measurableSet_interₛ {s : Set (Set α)} (hs : s.finite) (h : ∀ t ∈ s, MeasurableSet t) :\n    MeasurableSet («expr⋂₀ » s) :=\n  MeasurableSet.interₛ hs.countable h\n#align set.finite.measurable_set_sInter Set.Finite.measurableSet_interₛ\n-/\n\n",
 "measurableSet_insert":
 "#print measurableSet_insert /-\n@[simp]\ntheorem measurableSet_insert {a : α} {s : Set α} : MeasurableSet (insert a s) ↔ MeasurableSet s :=\n  ⟨fun h =>\n    if ha : a ∈ s then by rwa [← insert_eq_of_mem ha]\n    else insert_diff_self_of_not_mem ha ▸ h.diff (measurable_set_singleton _),\n    fun h => h.insert a⟩\n#align measurable_set_insert measurableSet_insert\n-/\n\n",
 "measurableSet_eq":
 "#print measurableSet_eq /-\ntheorem measurableSet_eq {a : α} : MeasurableSet { x | x = a } :=\n  measurable_set_singleton a\n#align measurable_set_eq measurableSet_eq\n-/\n\n",
 "measurableSet_bunionᵢ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n#print Finset.measurableSet_bunionᵢ /-\ntheorem Finset.measurableSet_bunionᵢ {f : β → Set α} (s : Finset β) (h : ∀ b ∈ s, MeasurableSet (f b)) :\n    MeasurableSet\n      («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (f b)) :=\n  s.finite_to_set.measurable_set_bUnion h\n#align finset.measurable_set_bUnion Finset.measurableSet_bunionᵢ\n-/\n\n",
 "measurableSet_binterᵢ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n#print Finset.measurableSet_binterᵢ /-\ntheorem Finset.measurableSet_binterᵢ {f : β → Set α} (s : Finset β) (h : ∀ b ∈ s, MeasurableSet (f b)) :\n    MeasurableSet\n      («expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (f b)) :=\n  s.finite_to_set.measurable_set_bInter h\n#align finset.measurable_set_bInter Finset.measurableSet_binterᵢ\n-/\n\n",
 "measurableSet":
 "#print Set.Countable.measurableSet /-\ntheorem Set.Countable.measurableSet {s : Set α} (hs : s.countable) : MeasurableSet s :=\n  by\n  rw [← bUnion_of_singleton s]\n  exact MeasurableSet.bunionᵢ hs fun b hb => measurable_set_singleton b\n#align set.countable.measurable_set Set.Countable.measurableSet\n-/\n\n",
 "measurable":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n#print MeasurableSpace.Top.measurable /-\ntheorem MeasurableSpace.Top.measurable {α β : Type _} [MeasurableSpace β] (f : α → β) : @Measurable α β («expr⊤») _ f :=\n  fun s hs => MeasurableSpace.measurableSet_top\n#align measurable_space.top.measurable MeasurableSpace.Top.measurable\n-/\n\n",
 "le_def":
 "theorem le_def {α} {a b : MeasurableSpace α} : a ≤ b ↔ a.measurable_set' ≤ b.measurable_set' :=\n  iff.rfl\n#align le_def le_def\n\n",
 "le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_of -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_of -/\n#print Measurable.le /-\ntheorem Measurable.le {α} {m m0 : MeasurableSpace α} {mb : MeasurableSpace β} (hm : m ≤ m0) {f : α → β}\n    (hf : (measurable_of m) f) : (measurable_of m0) f := fun s hs => hm _ (hf hs)\n#align measurable.le Measurable.le\n-/\n\n",
 "ite'":
 "#print MeasurableSet.ite' /-\ntheorem MeasurableSet.ite' {s t : Set α} {p : Prop} (hs : p → MeasurableSet s) (ht : ¬p → MeasurableSet t) :\n    MeasurableSet (ite p s t) := by\n  split_ifs\n  exacts[hs h, ht h]\n#align measurable_set.ite' MeasurableSet.ite'\n-/\n\n",
 "ite":
 "#print MeasurableSet.ite /-\n@[simp]\ntheorem MeasurableSet.ite {t s₁ s₂ : Set α} (ht : MeasurableSet t) (h₁ : MeasurableSet s₁) (h₂ : MeasurableSet s₂) :\n    MeasurableSet (t.ite s₁ s₂) :=\n  (h₁.inter ht).union (h₂.diff ht)\n#align measurable_set.ite MeasurableSet.ite\n-/\n\n",
 "interₛ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂₀ » -/\n#print MeasurableSet.interₛ /-\ntheorem MeasurableSet.interₛ {s : Set (Set α)} (hs : s.countable) (h : ∀ t ∈ s, MeasurableSet t) :\n    MeasurableSet («expr⋂₀ » s) := by\n  rw [sInter_eq_bInter]\n  exact MeasurableSet.binterᵢ hs h\n#align measurable_set.sInter MeasurableSet.interₛ\n-/\n\n",
 "interᵢ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n#print MeasurableSet.interᵢ /-\ntheorem MeasurableSet.interᵢ [Countable ι] {f : ι → Set α} (h : ∀ b, MeasurableSet (f b)) :\n    MeasurableSet\n      («expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (f b)) :=\n  MeasurableSet.compl_iff.1 <| by\n    rw [compl_Inter]\n    exact MeasurableSet.unionᵢ fun b => (h b).compl\n#align measurable_set.Inter MeasurableSet.interᵢ\n-/\n\n",
 "inter":
 "#print MeasurableSet.inter /-\n@[simp]\ntheorem MeasurableSet.inter {s₁ s₂ : Set α} (h₁ : MeasurableSet s₁) (h₂ : MeasurableSet s₂) : MeasurableSet (s₁ ∩ s₂) :=\n  by\n  rw [inter_eq_compl_compl_union_compl]\n  exact (h₁.compl.union h₂.compl).compl\n#align measurable_set.inter MeasurableSet.inter\n-/\n\n",
 "insert":
 "#print MeasurableSet.insert /-\ntheorem MeasurableSet.insert {s : Set α} (hs : MeasurableSet s) (a : α) : MeasurableSet (insert a s) :=\n  (measurable_set_singleton a).union hs\n#align measurable_set.insert MeasurableSet.insert\n-/\n\n",
 "generate_from_sup_generate_from":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\ntheorem generate_from_sup_generate_from {s t : Set (Set α)} :\n    «expr ⊔ » (generateFrom s) (generateFrom t) = generateFrom (s ∪ t) :=\n  (@giGenerateFrom α).gc.l_sup.symm\n#align generate_from_sup_generate_from generate_from_sup_generate_from\n\n",
 "generate_from_singleton_univ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem generate_from_singleton_univ : generateFrom {Set.univ} = («expr⊥» : MeasurableSpace α) :=\n  by\n  rw [eq_bot_iff, generate_from_le_iff]\n  simp\n#align generate_from_singleton_univ generate_from_singleton_univ\n\n",
 "generate_from_singleton_empty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem generate_from_singleton_empty : generateFrom {∅} = («expr⊥» : MeasurableSpace α) :=\n  by\n  rw [eq_bot_iff, generate_from_le_iff]\n  simp\n#align generate_from_singleton_empty generate_from_singleton_empty\n\n",
 "generate_from_mono":
 "@[mono]\ntheorem generate_from_mono {s t : Set (Set α)} (h : s ⊆ t) : generateFrom s ≤ generateFrom t :=\n  giGenerateFrom.gc.monotone_l h\n#align generate_from_mono generate_from_mono\n\n",
 "generate_from_measurable_set":
 "@[simp]\ntheorem generate_from_measurable_set [MeasurableSpace α] : generateFrom { s : Set α | MeasurableSet s } = ‹_› :=\n  le_antisymm (generateFrom_le fun _ => id) fun s => measurableSet_generateFrom\n#align generate_from_measurable_set generate_from_measurable_set\n\n",
 "generate_from_le_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\ntheorem generate_from_le_iff {s : Set (Set α)} (m : MeasurableSpace α) :\n    generateFrom s ≤ m ↔ s ⊆ { t | (measurable_set_of m) t } :=\n  iff.intro (fun h u hu => h _ <| measurableSet_generateFrom hu) fun h => generateFrom_le h\n#align generate_from_le_iff generate_from_le_iff\n\n",
 "generate_from_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\ntheorem generate_from_le {s : Set (Set α)} {m : MeasurableSpace α} (h : ∀ t ∈ s, (measurable_set_of m) t) :\n    generateFrom s ≤ m := fun t (ht : GenerateMeasurable s t) =>\n  ht.rec_on h (measurable_set_empty m) (fun s _ hs => measurable_set_compl m s hs) fun f _ hf =>\n    measurable_set_Union m f hf\n#align generate_from_le generate_from_le\n\n",
 "generate_from_insert_univ":
 "@[simp]\ntheorem generate_from_insert_univ (S : Set (Set α)) : generateFrom (insert Set.univ S) = generateFrom S :=\n  by\n  refine' le_antisymm _ (generate_from_mono (Set.subset_insert _ _))\n  rw [generate_from_le_iff]\n  intro t ht\n  cases ht\n  · rw [ht]\n    exact MeasurableSet.univ\n  · exact measurable_set_generate_from ht\n#align generate_from_insert_univ generate_from_insert_univ\n\n",
 "generate_from_insert_empty":
 "@[simp]\ntheorem generate_from_insert_empty (S : Set (Set α)) : generateFrom (insert ∅ S) = generateFrom S :=\n  by\n  refine' le_antisymm _ (generate_from_mono (Set.subset_insert _ _))\n  rw [generate_from_le_iff]\n  intro t ht\n  cases ht\n  · rw [ht]\n    exact @MeasurableSet.empty _ (generate_from S)\n  · exact measurable_set_generate_from ht\n#align generate_from_insert_empty generate_from_insert_empty\n\n",
 "generate_from_induction":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\n@[elab_as_elim]\ntheorem generate_from_induction (p : Set α → Prop) (C : Set (Set α)) (hC : ∀ t ∈ C, p t) (h_empty : p ∅)\n    (h_compl : ∀ t, p t → p («expr ᶜ» t))\n    (h_Union :\n      ∀ f : ℕ → Set α,\n        (∀ n, p (f n)) →\n          p («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (f i)))\n    {s : Set α} (hs : (measurable_set_of (generateFrom C)) s) : p s :=\n  by\n  induction hs\n  exacts[hC _ hs_H, h_empty, h_compl _ hs_ih, h_Union hs_f hs_ih]\n#align generate_from_induction generate_from_induction\n\n",
 "generate_from_Union_measurable_set":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\ntheorem generate_from_Union_measurable_set (m : ι → MeasurableSpace α) :\n    generateFrom\n        («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n          { t | (measurable_set_of (m n)) t }) =\n      «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (m n) :=\n  (@giGenerateFrom α).l_supr_u m\n#align generate_from_Union_measurable_set generate_from_Union_measurable_set\n\n",
 "ext_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\n#print MeasurableSpace.ext_iff /-\n@[ext]\ntheorem MeasurableSpace.ext_iff {m₁ m₂ : MeasurableSpace α} :\n    m₁ = m₂ ↔ ∀ s : Set α, (measurable_set_of m₁) s ↔ (measurable_set_of m₂) s :=\n  ⟨by\n    rintro rfl\n    intro s\n    rfl, MeasurableSpace.ext⟩\n#align measurable_space.ext_iff MeasurableSpace.ext_iff\n-/\n\n",
 "ext":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\n#print MeasurableSpace.ext /-\n@[ext]\ntheorem MeasurableSpace.ext :\n    ∀ {m₁ m₂ : MeasurableSpace α}, (∀ s : Set α, (measurable_set_of m₁) s ↔ (measurable_set_of m₂) s) → m₁ = m₂\n  | ⟨s₁, _, _, _⟩, ⟨s₂, _, _, _⟩, h =>\n    by\n    have : s₁ = s₂ := funext fun x => propext <| h x\n    subst this\n#align measurable_space.ext MeasurableSpace.ext\n-/\n\n",
 "empty":
 "#print MeasurableSet.empty /-\n/-\nCopyright (c) 2017 Johannes Hölzl. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johannes Hölzl, Mario Carneiro\n-/\n@[simp]\ntheorem MeasurableSet.empty [MeasurableSpace α] : MeasurableSet (∅ : Set α) :=\n  ‹MeasurableSpace α›.measurable_set_empty\n#align measurable_set.empty MeasurableSet.empty\n-/\n\n",
 "disjointed":
 "#print MeasurableSet.disjointed /-\n@[simp]\ntheorem MeasurableSet.disjointed {f : ℕ → Set α} (h : ∀ i, MeasurableSet (f i)) (n) : MeasurableSet (disjointed f n) :=\n  disjointedRec (fun t i ht => MeasurableSet.diff ht <| h _) (h n)\n#align measurable_set.disjointed MeasurableSet.disjointed\n-/\n\n",
 "diff":
 "#print MeasurableSet.diff /-\n@[simp]\ntheorem MeasurableSet.diff {s₁ s₂ : Set α} (h₁ : MeasurableSet s₁) (h₂ : MeasurableSet s₂) : MeasurableSet (s₁ \\ s₂) :=\n  h₁.inter h₂.compl\n#align measurable_set.diff MeasurableSet.diff\n-/\n\n",
 "const":
 "#print MeasurableSet.const /-\n@[simp]\ntheorem MeasurableSet.const (p : Prop) : MeasurableSet { a : α | p } := by\n  by_cases p <;> simp [h, MeasurableSet.empty] <;> apply MeasurableSet.univ\n#align measurable_set.const MeasurableSet.const\n-/\n\n",
 "congr":
 "#print MeasurableSet.congr /-\ntheorem MeasurableSet.congr {s t : Set α} (hs : MeasurableSet s) (h : s = t) : MeasurableSet t := by rwa [← h]\n#align measurable_set.congr MeasurableSet.congr\n-/\n\n",
 "cond":
 "#print MeasurableSet.cond /-\n@[simp]\ntheorem MeasurableSet.cond {s₁ s₂ : Set α} (h₁ : MeasurableSet s₁) (h₂ : MeasurableSet s₂) {i : Bool} :\n    MeasurableSet (cond i s₁ s₂) := by\n  cases i\n  exacts[h₂, h₁]\n#align measurable_set.cond MeasurableSet.cond\n-/\n\n",
 "compl_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n#print MeasurableSet.compl_iff /-\n@[simp]\ntheorem MeasurableSet.compl_iff : MeasurableSet («expr ᶜ» s) ↔ MeasurableSet s :=\n  ⟨MeasurableSet.of_compl, MeasurableSet.compl⟩\n#align measurable_set.compl_iff MeasurableSet.compl_iff\n-/\n\n",
 "compl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n#print MeasurableSet.compl /-\ntheorem MeasurableSet.compl : MeasurableSet s → MeasurableSet («expr ᶜ» s) :=\n  ‹MeasurableSpace α›.measurable_set_compl s\n#align measurable_set.compl MeasurableSet.compl\n-/\n\n",
 "comp":
 "#print Measurable.comp /-\ntheorem Measurable.comp {mα : MeasurableSpace α} {mβ : MeasurableSpace β} {mγ : MeasurableSpace γ} {g : β → γ}\n    {f : α → β} (hg : Measurable g) (hf : Measurable f) : Measurable (g ∘ f) := fun t ht => hf (hg ht)\n#align measurable.comp Measurable.comp\n-/\n\n",
 "bunionᵢ_decode₂":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n#print MeasurableSet.bunionᵢ_decode₂ /-\ntheorem MeasurableSet.bunionᵢ_decode₂ [Encodable β] ⦃f : β → Set α⦄ (h : ∀ b, MeasurableSet (f b)) (n : ℕ) :\n    MeasurableSet\n      («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (f b)) :=\n  Encodable.unionᵢ_decode₂_cases MeasurableSet.empty h\n#align measurable_set.bUnion_decode₂ MeasurableSet.bunionᵢ_decode₂\n-/\n\n",
 "bunionᵢ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n#print MeasurableSet.bunionᵢ /-\ntheorem MeasurableSet.bunionᵢ {f : β → Set α} {s : Set β} (hs : s.countable) (h : ∀ b ∈ s, MeasurableSet (f b)) :\n    MeasurableSet\n      («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (f b)) :=\n  by\n  rw [bUnion_eq_Union]\n  haveI := hs.to_encodable\n  exact MeasurableSet.unionᵢ (by simpa using h)\n#align measurable_set.bUnion MeasurableSet.bunionᵢ\n-/\n\n",
 "binterᵢ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n#print MeasurableSet.binterᵢ /-\ntheorem MeasurableSet.binterᵢ {f : β → Set α} {s : Set β} (hs : s.countable) (h : ∀ b ∈ s, MeasurableSet (f b)) :\n    MeasurableSet\n      («expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (f b)) :=\n  MeasurableSet.compl_iff.1 <| by\n    rw [compl_Inter₂]\n    exact MeasurableSet.bunionᵢ hs fun b hb => (h b hb).compl\n#align measurable_set.bInter MeasurableSet.binterᵢ\n-/\n\n"}