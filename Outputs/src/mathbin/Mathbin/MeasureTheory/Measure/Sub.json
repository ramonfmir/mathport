{"zero_sub":
 "#print zero_sub /-\n@[simp]\ntheorem zero_sub : 0 - μ = 0 :=\n  sub_eq_zero_of_le μ.zero_le\n#align zero_sub zero_sub\n-/\n\n",
 "sub_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem sub_top : μ - «expr⊤» = 0 :=\n  sub_eq_zero_of_le le_top\n#align sub_top sub_top\n\n",
 "sub_self":
 "#print sub_self /-\n@[simp]\ntheorem sub_self : μ - μ = 0 :=\n  sub_eq_zero_of_le le_rfl\n#align sub_self sub_self\n-/\n\n",
 "sub_le_of_le_add":
 "theorem sub_le_of_le_add {d} (h : μ ≤ d + ν) : μ - ν ≤ d :=\n  infₛ_le h\n#align sub_le_of_le_add sub_le_of_le_add\n\n",
 "sub_le":
 "theorem sub_le : μ - ν ≤ μ :=\n  sub_le_of_le_add <| measure.le_add_right le_rfl\n#align sub_le sub_le\n\n",
 "sub_eq_zero_of_le":
 "theorem sub_eq_zero_of_le (h : μ ≤ ν) : μ - ν = 0 :=\n  nonpos_iff_eq_zero'.1 <| sub_le_of_le_add <| by rwa [zero_add]\n#align sub_eq_zero_of_le sub_eq_zero_of_le\n\n",
 "sub_def":
 "/-\nCopyright (c) 2022 Martin Zinkevich. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Martin Zinkevich\n-/\ntheorem sub_def : μ - ν = infₛ { d | μ ≤ d + ν } :=\n  rfl\n#align sub_def sub_def\n\n",
 "sub_apply_eq_zero_of_restrict_le_restrict":
 "theorem sub_apply_eq_zero_of_restrict_le_restrict (h_le : μ.restrict s ≤ ν.restrict s) (h_meas_s : measurable_set s) :\n    (μ - ν) s = 0 := by\n  rw [← restrict_apply_self, restrict_sub_eq_restrict_sub_restrict, sub_eq_zero_of_le] <;> simp [*]\n#align sub_apply_eq_zero_of_restrict_le_restrict sub_apply_eq_zero_of_restrict_le_restrict\n\n",
 "sub_apply":
 "/-- This application lemma only works in special circumstances. Given knowledge of\nwhen `μ ≤ ν` and `ν ≤ μ`, a more general application lemma can be written. -/\ntheorem sub_apply [is_finite_measure ν] (h₁ : measurable_set s) (h₂ : ν ≤ μ) : (μ - ν) s = μ s - ν s :=\n  by\n  -- We begin by defining `measure_sub`, which will be equal to `(μ - ν)`.\n  let measure_sub : measure α :=\n    @measure_theory.measure.of_measurable α _ (fun (t : set α) (h_t_measurable_set : measurable_set t) => μ t - ν t)\n      (by simp)\n      (by\n        intro g h_meas h_disj; simp only; rw [ennreal.tsum_sub]\n        repeat' rw [← measure_theory.measure_Union h_disj h_meas]\n        exacts[measure_theory.measure_ne_top _ _, fun i => h₂ _ (h_meas _)])\n  -- Now, we demonstrate `μ - ν = measure_sub`, and apply it.\n  · have h_measure_sub_add : ν + measure_sub = μ :=\n      by\n      ext (t h_t_measurable_set)\n      simp only [pi.add_apply, coe_add]\n      rw [measure_theory.measure.of_measurable_apply _ h_t_measurable_set, add_comm,\n        tsub_add_cancel_of_le (h₂ t h_t_measurable_set)]\n    have h_measure_sub_eq : μ - ν = measure_sub :=\n      by\n      rw [measure_theory.measure.sub_def]\n      apply le_antisymm\n      · apply @infₛ_le (measure α) measure.complete_semilattice_Inf\n        simp [le_refl, add_comm, h_measure_sub_add]\n      apply @le_infₛ (measure α) measure.complete_semilattice_Inf\n      intro d h_d\n      rw [← h_measure_sub_add, mem_set_of_eq, add_comm d] at h_d\n      apply measure.le_of_add_le_add_left h_d\n    rw [h_measure_sub_eq]\n    apply measure.of_measurable_apply _ h₁\n#align sub_apply sub_apply\n\n",
 "sub_add_cancel_of_le":
 "theorem sub_add_cancel_of_le [is_finite_measure ν] (h₁ : ν ≤ μ) : μ - ν + ν = μ :=\n  by\n  ext (s h_s_meas)\n  rw [add_apply, sub_apply h_s_meas h₁, tsub_add_cancel_of_le (h₁ s h_s_meas)]\n#align sub_add_cancel_of_le sub_add_cancel_of_le\n\n",
 "restrict_sub_eq_restrict_sub_restrict":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem restrict_sub_eq_restrict_sub_restrict (h_meas_s : measurable_set s) :\n    (μ - ν).restrict s = μ.restrict s - ν.restrict s :=\n  by\n  repeat' rw [sub_def]\n  have h_nonempty : { d | μ ≤ d + ν }.nonempty := ⟨μ, measure.le_add_right le_rfl⟩\n  rw [restrict_Inf_eq_Inf_restrict h_nonempty h_meas_s]\n  apply le_antisymm\n  · refine' infₛ_le_infₛ_of_forall_exists_le _\n    intro ν' h_ν'_in\n    rw [mem_set_of_eq] at h_ν'_in\n    refine' ⟨ν'.restrict s, _, restrict_le_self⟩\n    refine' ⟨ν' + («expr⊤» : measure α).restrict («expr ᶜ» s), _, _⟩\n    · rw [mem_set_of_eq, add_right_comm, measure.le_iff]\n      intro t h_meas_t\n      repeat' rw [← measure_inter_add_diff t h_meas_s]\n      refine' add_le_add _ _\n      · rw [add_apply, add_apply]\n        apply le_add_right _\n        rw [← restrict_eq_self μ (inter_subset_right _ _), ← restrict_eq_self ν (inter_subset_right _ _)]\n        apply h_ν'_in _ (h_meas_t.inter h_meas_s)\n      · rw [add_apply, restrict_apply (h_meas_t.diff h_meas_s), diff_eq, inter_assoc, inter_self, ← add_apply]\n        have h_mu_le_add_top : μ ≤ ν' + ν + «expr⊤» := by simp only [add_top, le_top]\n        exact measure.le_iff'.1 h_mu_le_add_top _\n    · ext1 t h_meas_t\n      simp [restrict_apply h_meas_t, restrict_apply (h_meas_t.inter h_meas_s), inter_assoc]\n  · refine' infₛ_le_infₛ_of_forall_exists_le _\n    refine' ball_image_iff.2 fun t h_t_in => ⟨t.restrict s, _, le_rfl⟩\n    rw [Set.mem_setOf_eq, ← restrict_add]\n    exact restrict_mono subset.rfl h_t_in\n#align restrict_sub_eq_restrict_sub_restrict restrict_sub_eq_restrict_sub_restrict\n\n"}