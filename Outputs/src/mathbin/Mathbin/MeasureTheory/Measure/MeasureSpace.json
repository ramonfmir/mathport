{"zero_trim":
 "@[simp]\ntheorem zero_trim (hm : m ≤ m0) : (0 : Measure α).trim hm = (0 : @Measure α m) := by\n  simp [measure.trim, outer_measure.to_measure_zero]\n#align zero_trim zero_trim\n\n",
 "zero_to_outer_measure":
 "@[simp]\ntheorem zero_to_outer_measure {m : MeasurableSpace α} : (0 : Measure α).to_outer_measure = 0 :=\n  rfl\n#align zero_to_outer_measure zero_to_outer_measure\n\n",
 "zero_le":
 "#print zero_le /-\nprotected theorem zero_le {m0 : MeasurableSpace α} (μ : Measure α) : 0 ≤ μ :=\n  bot_le\n#align zero_le zero_le\n-/\n\n",
 "volume_univ":
 "theorem subtype.volume_univ (hs : NullMeasurableSet s) : volume (univ : Set s) = volume s :=\n  by\n  rw [subtype.volume_def, comap_apply₀ _ _ _ _ measurable_set.univ.null_measurable_set]\n  · congr\n    simp only [subtype.val_eq_coe, image_univ, Subtype.range_coe_subtype, set_of_mem_eq]\n  · exact Subtype.coe_injective\n  · exact fun t => measurable_set.null_measurable_set_subtype_coe hs\n#align subtype.volume_univ subtype.volume_univ\n\n",
 "volume_subtype_coe_le_volume":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem volume_subtype_coe_le_volume (hs : NullMeasurableSet s) (t : Set s) :\n    volume («expr '' » (coe : s → α) t) ≤ volume t :=\n  measure_subtype_coe_le_comap hs t\n#align volume_subtype_coe_le_volume volume_subtype_coe_le_volume\n\n",
 "volume_subtype_coe_eq_zero_of_volume_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem volume_subtype_coe_eq_zero_of_volume_eq_zero (hs : NullMeasurableSet s) {t : Set s} (ht : volume t = 0) :\n    volume («expr '' » (coe : s → α) t) = 0 :=\n  measure_subtype_coe_eq_zero_of_comap_eq_zero hs ht\n#align volume_subtype_coe_eq_zero_of_volume_eq_zero volume_subtype_coe_eq_zero_of_volume_eq_zero\n\n",
 "volume_set_coe_def":
 "#print volume_set_coe_def /-\ntheorem volume_set_coe_def (s : Set α) : (volume : measure s) = comap (coe : s → α) volume :=\n  rfl\n#align volume_set_coe_def volume_set_coe_def\n-/\n\n",
 "volume_preimage_coe":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n#print volume_preimage_coe /-\n@[simp]\ntheorem volume_preimage_coe (hs : NullMeasurableSet s) (ht : MeasurableSet t) :\n    volume («expr ⁻¹' » (coe : s → α) t) = volume (t ∩ s) := by\n  rw [volume_set_coe_def,\n    comap_apply₀ _ _ Subtype.coe_injective (fun h => measurable_set.null_measurable_set_subtype_coe hs)\n      (measurable_subtype_coe ht).null_measurable_set,\n    image_preimage_eq_inter_range, Subtype.range_coe]\n#align volume_preimage_coe volume_preimage_coe\n-/\n\n",
 "volume_image_subtype_coe":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n#print volume_image_subtype_coe /-\ntheorem volume_image_subtype_coe {s : Set α} (hs : MeasurableSet s) (t : Set s) :\n    volume («expr '' » coe t : Set α) = volume t :=\n  (comap_subtype_coe_apply hs volume t).symm\n#align volume_image_subtype_coe volume_image_subtype_coe\n-/\n\n",
 "volume_def":
 "theorem subtype.volume_def : (volume : Measure s) = volume.comap Subtype.val :=\n  rfl\n#align subtype.volume_def subtype.volume_def\n\n",
 "union_ae_eq_right_iff_ae_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≤ᵐ[ ] » -/\n@[simp]\ntheorem union_ae_eq_right_iff_ae_subset : «expr =ᵐ[ ] » (s ∪ t : Set α) μ t ↔ «expr ≤ᵐ[ ] » s μ t := by\n  rw [union_comm, union_ae_eq_left_iff_ae_subset]\n#align union_ae_eq_right_iff_ae_subset union_ae_eq_right_iff_ae_subset\n\n",
 "union_ae_eq_left_iff_ae_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≤ᵐ[ ] » -/\n@[simp]\ntheorem union_ae_eq_left_iff_ae_subset : «expr =ᵐ[ ] » (s ∪ t : Set α) μ s ↔ «expr ≤ᵐ[ ] » t μ s :=\n  by\n  rw [ae_le_set]\n  refine'\n    ⟨fun h => by simpa only [union_diff_left] using (ae_eq_set.mp h).1, fun h =>\n      eventually_le_antisymm_iff.mpr\n        ⟨by rwa [ae_le_set, union_diff_left], HasSubset.Subset.eventuallyLE <| subset_union_left s t⟩⟩\n#align union_ae_eq_left_iff_ae_subset union_ae_eq_left_iff_ae_subset\n\n",
 "uIoc_ae_eq_interval":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprΙ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.uIcc -/\ntheorem uIoc_ae_eq_interval [linear_order α] {a b : α} : «expr =ᵐ[ ] » ((exprΙ) a b) μ (set.uIcc a b) :=\n  Ioc_ae_eq_Icc\n#align uIoc_ae_eq_interval uIoc_ae_eq_interval\n\n",
 "tsum_measure_preimage_singleton":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/-- If `s` is a countable set, then the measure of its preimage can be found as the sum of measures\nof the fibers `f ⁻¹' {y}`. -/\ntheorem tsum_measure_preimage_singleton {s : Set β} (hs : s.countable) {f : α → β}\n    (hf : ∀ y ∈ s, MeasurableSet («expr ⁻¹' » f {y})) :\n    «expr∑' , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , »\"\n        (μ («expr ⁻¹' » f {↑b})) =\n      μ («expr ⁻¹' » f s) :=\n  by rw [← Set.bunionᵢ_preimage_singleton, measure_bUnion hs (pairwise_disjoint_fiber _ _) hf]\n#align tsum_measure_preimage_singleton tsum_measure_preimage_singleton\n\n",
 "tsum_measure_le_measure_univ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr on » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , » -/\ntheorem tsum_measure_le_measure_univ {s : ι → Set α} (hs : ∀ i, MeasurableSet (s i))\n    (H : Pairwise («expr on » Disjoint s)) :\n    «expr∑' , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , »\" (μ (s i)) ≤\n      μ (univ : Set α) :=\n  by\n  rw [ENNReal.tsum_eq_supᵢ_sum]\n  exact supᵢ_le fun s => sum_measure_le_measure_univ (fun i hi => hs i) fun i hi j hj hij => H hij\n#align tsum_measure_le_measure_univ tsum_measure_le_measure_univ\n\n",
 "tsum_meas_le_meas_Union_of_disjoint":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr on » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/-- The measure of a disjoint union (even uncountable) of measurable sets is at least the sum of\nthe measures of the sets. -/\ntheorem tsum_meas_le_meas_Union_of_disjoint {ι : Type _} [MeasurableSpace α] (μ : Measure α) {As : ι → Set α}\n    (As_mble : ∀ i : ι, MeasurableSet (As i)) (As_disj : Pairwise («expr on » Disjoint As)) :\n    «expr∑' , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , »\" (μ (As i)) ≤\n      μ («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (As i)) :=\n  by\n  rcases show Summable fun i => μ (As i) from ENNReal.summable with ⟨S, hS⟩\n  rw [hS.tsum_eq]\n  refine' tendsto_le_of_eventuallyLE hS tendsto_const_nhds (eventually_of_forall _)\n  intro s\n  rw [← measure_bUnion_finset (fun i hi j hj hij => As_disj hij) fun i _ => As_mble i]\n  exact measure_mono (Union₂_subset_Union (fun i : ι => i ∈ s) fun i : ι => As i)\n#align tsum_meas_le_meas_Union_of_disjoint tsum_meas_le_meas_Union_of_disjoint\n\n",
 "tsum_indicator_apply_singleton":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , » -/\n/-- Given that `α` is a countable, measurable space with all singleton sets measurable,\nwrite the measure of a set `s` as the sum of the measure of `{x}` for all `x ∈ s`. -/\ntheorem tsum_indicator_apply_singleton [Countable α] [MeasurableSingletonClass α] (μ : Measure α) (s : Set α)\n    (hs : MeasurableSet s) :\n    «expr∑' , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , »\"\n        (s.indicator (fun x => μ {x}) x) =\n      μ s :=\n  calc\n    «expr∑' , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , »\"\n          (s.indicator (fun x => μ {x}) x) =\n        Measure.sum (fun a => «expr • » (μ {a}) (Measure.dirac a)) s :=\n      by\n      simp only [measure.sum_apply _ hs, measure.smul_apply, smul_eq_mul, measure.dirac_apply, Set.indicator_apply,\n        mul_ite, Pi.one_apply, mul_one, MulZeroClass.mul_zero]\n    _ = μ s := by rw [μ.sum_smul_dirac]\n    \n#align tsum_indicator_apply_singleton tsum_indicator_apply_singleton\n\n",
 "trim_trim":
 "theorem trim_trim {m₁ m₂ : MeasurableSpace α} {hm₁₂ : m₁ ≤ m₂} {hm₂ : m₂ ≤ m0} :\n    (μ.trim hm₂).trim hm₁₂ = μ.trim (hm₁₂.trans hm₂) :=\n  by\n  ext1 t ht\n  rw [trim_measurable_set_eq hm₁₂ ht, trim_measurable_set_eq (hm₁₂.trans hm₂) ht,\n    trim_measurable_set_eq hm₂ (hm₁₂ t ht)]\n#align trim_trim trim_trim\n\n",
 "trim_measurable_set_eq":
 "theorem trim_measurable_set_eq (hm : m ≤ m0) (hs : @MeasurableSet α m s) : μ.trim hm s = μ s := by\n  simp [measure.trim, hs]\n#align trim_measurable_set_eq trim_measurable_set_eq\n\n",
 "trim_eq_self":
 "@[simp]\ntheorem trim_eq_self [MeasurableSpace α] {μ : Measure α} : μ.trim le_rfl = μ := by simp [measure.trim]\n#align trim_eq_self trim_eq_self\n\n",
 "trans":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure.absolutely_continuous -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure.absolutely_continuous -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure.absolutely_continuous -/\n#print trans /-\n@[trans]\nprotected theorem trans (h1 : measure.absolutely_continuous μ₁ μ₂) (h2 : measure.absolutely_continuous μ₂ μ₃) :\n    measure.absolutely_continuous μ₁ μ₃ := fun s hs => h1 <| h2 hs\n#align trans trans\n-/\n\n",
 "top_add":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n#print top_add /-\n/- Adding an explicit `top` makes `leanchecker` fail, see lean#364, disable for now\n\n  top := (⊤ : outer_measure α).to_measure (by rw [outer_measure.top_caratheodory]; exact le_top),\n  le_top := λ a s hs,\n    by cases s.eq_empty_or_nonempty with h  h;\n      simp [h, to_measure_apply ⊤ _ hs, outer_measure.top_apply],\n-/\n@[simp]\ntheorem top_add : «expr⊤» + μ = «expr⊤» :=\n  top_unique <| Measure.le_add_right le_rfl\n#align top_add top_add\n-/\n\n",
 "to_outer_measure_trim_eq_trim_to_outer_measure":
 "theorem to_outer_measure_trim_eq_trim_to_outer_measure (μ : Measure α) (hm : m ≤ m0) :\n    @measure.to_outer_measure _ m (μ.trim hm) = @OuterMeasure.trim _ m μ.to_outer_measure := by\n  rw [measure.trim, to_measure_to_outer_measure]\n#align to_outer_measure_trim_eq_trim_to_outer_measure to_outer_measure_trim_eq_trim_to_outer_measure\n\n",
 "to_outer_measure_to_measure":
 "@[simp]\ntheorem to_outer_measure_to_measure {μ : Measure α} :\n    μ.to_outer_measure.to_measure (le_toOuterMeasure_caratheodory _) = μ :=\n  Measure.ext fun s => μ.to_outer_measure.trim_eq\n#align to_outer_measure_to_measure to_outer_measure_to_measure\n\n",
 "to_outer_measure_le":
 "theorem to_outer_measure_le : μ₁.to_outer_measure ≤ μ₂.to_outer_measure ↔ μ₁ ≤ μ₂ := by\n  rw [← μ₂.trimmed, outer_measure.le_trim_iff] <;> rfl\n#align to_outer_measure_le to_outer_measure_le\n\n",
 "to_measure_zero":
 "theorem outer_measure.to_measure_zero [MeasurableSpace α] :\n    (0 : OuterMeasure α).to_measure (le_top.trans OuterMeasure.zero_caratheodory.symm.le) = 0 := by\n  rw [← measure.measure_univ_eq_zero, to_measure_apply _ _ MeasurableSet.univ, outer_measure.coe_zero, Pi.zero_apply]\n#align outer_measure.to_measure_zero outer_measure.to_measure_zero\n\n",
 "to_measure_to_outer_measure":
 "@[simp]\ntheorem to_measure_to_outer_measure (m : OuterMeasure α) (h : ms ≤ m.caratheodory) :\n    (m.to_measure h).to_outer_measure = m.trim :=\n  rfl\n#align to_measure_to_outer_measure to_measure_to_outer_measure\n\n",
 "to_measure_apply₀":
 "theorem to_measure_apply₀ (m : OuterMeasure α) (h : ms ≤ m.caratheodory) {s : Set α}\n    (hs : NullMeasurableSet s (m.to_measure h)) : m.to_measure h s = m s :=\n  by\n  refine' le_antisymm _ (le_to_measure_apply _ _ _)\n  rcases hs.exists_measurable_subset_ae_eq with ⟨t, hts, htm, heq⟩\n  calc\n    m.to_measure h s = m.to_measure h t := measure_congr heq.symm\n    _ = m t := (to_measure_apply m h htm)\n    _ ≤ m s := m.mono hts\n    \n#align to_measure_apply₀ to_measure_apply₀\n\n",
 "to_measure_apply":
 "@[simp]\ntheorem to_measure_apply (m : OuterMeasure α) (h : ms ≤ m.caratheodory) {s : Set α} (hs : MeasurableSet s) :\n    m.to_measure h s = m s :=\n  m.trim_eq hs\n#align to_measure_apply to_measure_apply\n\n",
 "tendsto_measure_bInter_gt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.gt -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/-- The measure of the intersection of a decreasing sequence of measurable\nsets indexed by a linear order with first countable topology is the limit of the measures. -/\ntheorem tendsto_measure_bInter_gt {ι : Type _} [linear_order ι] [TopologicalSpace ι] [OrderTopology ι]\n    [DenselyOrdered ι] [TopologicalSpace.FirstCountableTopology ι] {s : ι → Set α} {a : ι}\n    (hs : ∀ r > a, MeasurableSet (s r)) (hm : ∀ i j, a < i → i ≤ j → s i ⊆ s j) (hf : ∃ r > a, μ (s r) ≠ ennreal.top) :\n    Tendsto (μ ∘ s) (nhds_within (Ioi a) a)\n      ((nhds)\n        (μ («expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (s r)))) :=\n  by\n  refine' tendsto_order.2 ⟨fun l hl => _, fun L hL => _⟩\n  · filter_upwards [self_mem_nhdsWithin]with r hr using hl.trans_le (measure_mono (bInter_subset_of_mem hr))\n  obtain ⟨u, u_anti, u_pos, u_lim⟩ : ∃ u : ℕ → ι, StrictAnti u ∧ (∀ n : ℕ, a < u n) ∧ tendsto u at_top ((nhds) a) :=\n    by\n    rcases hf with ⟨r, ar, hr⟩\n    rcases exists_seq_strictAnti_tendsto' ar with ⟨w, w_anti, w_mem, w_lim⟩\n    exact ⟨w, w_anti, fun n => (w_mem n).1, w_lim⟩\n  have A :\n    tendsto (μ ∘ s ∘ u) at_top\n      ((nhds)\n        (μ\n          («expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\"\n            (s (u n))))) :=\n    by\n    refine' tendsto_measure_Inter (fun n => hs _ (u_pos n)) _ _\n    · intro m n hmn\n      exact hm _ _ (u_pos n) (u_anti.antitone hmn)\n    · rcases hf with ⟨r, rpos, hr⟩\n      obtain ⟨n, hn⟩ : ∃ n : ℕ, u n < r := ((tendsto_order.1 u_lim).2 r rpos).exists\n      refine' ⟨n, ne_of_lt (lt_of_le_of_lt _ hr.lt_top)⟩\n      exact measure_mono (hm _ _ (u_pos n) hn.le)\n  have B :\n    «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (s (u n)) =\n      «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (s r) :=\n    by\n    apply subset.antisymm\n    · simp only [subset_Inter_iff, gt_iff_lt]\n      intro r rpos\n      obtain ⟨n, hn⟩ : ∃ n, u n < r := ((tendsto_order.1 u_lim).2 _ rpos).exists\n      exact subset.trans (Inter_subset _ n) (hm (u n) r (u_pos n) hn.le)\n    · simp only [subset_Inter_iff, gt_iff_lt]\n      intro n\n      apply bInter_subset_of_mem\n      exact u_pos n\n  rw [B] at A\n  obtain ⟨n, hn⟩ : ∃ n, μ (s (u n)) < L := ((tendsto_order.1 A).2 _ hL).exists\n  have : Ioc a (u n) ∈ nhds_within.gt a := Ioc_mem_nhdsWithin_Ioi ⟨le_rfl, u_pos n⟩\n  filter_upwards [this]with r hr using lt_of_le_of_lt (measure_mono (hm _ _ hr.1 hr.2)) hn\n#align tendsto_measure_bInter_gt tendsto_measure_bInter_gt\n\n",
 "tendsto_measure_Union":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/-- Continuity from below: the measure of the union of an increasing sequence of measurable sets\nis the limit of the measures. -/\ntheorem tendsto_measure_Union [SemilatticeSup ι] [Countable ι] {s : ι → Set α} (hm : Monotone s) :\n    Tendsto (μ ∘ s) atTop\n      ((nhds)\n        (μ («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (s n)))) :=\n  by\n  rw [measure_Union_eq_supr (directed_of_sup hm)]\n  exact tendsto_atTop_supᵢ fun n m hnm => measure_mono <| hm hnm\n#align tendsto_measure_Union tendsto_measure_Union\n\n",
 "tendsto_measure_Inter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/-- Continuity from above: the measure of the intersection of a decreasing sequence of measurable\nsets is the limit of the measures. -/\ntheorem tendsto_measure_Inter [Countable ι] [SemilatticeSup ι] {s : ι → Set α} (hs : ∀ n, MeasurableSet (s n))\n    (hm : Antitone s) (hf : ∃ i, μ (s i) ≠ ennreal.top) :\n    Tendsto (μ ∘ s) atTop\n      ((nhds)\n        (μ («expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (s n)))) :=\n  by\n  rw [measure_Inter_eq_infi hs (directed_of_sup hm) hf]\n  exact tendsto_atTop_infᵢ fun n m hnm => measure_mono <| hm hnm\n#align tendsto_measure_Inter tendsto_measure_Inter\n\n",
 "tendsto_ae_map":
 "theorem tendsto_ae_map {f : α → β} (hf : AEMeasurable f μ) : Tendsto f μ.ae (μ.map f).ae := fun s hs =>\n  preimage_null_of_map_null hf hs\n#align tendsto_ae_map tendsto_ae_map\n\n",
 "tendsto_ae":
 "theorem tendsto_ae (h : QuasiMeasurePreserving f μa μb) : Tendsto f μa.ae μb.ae :=\n  (tendsto_ae_map h.ae_measurable).mono_right h.ae_map_le\n#align tendsto_ae tendsto_ae\n\n",
 "supr_restrict_spanning_sets":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\ntheorem supr_restrict_spanning_sets [SigmaFinite μ] (hs : MeasurableSet s) :\n    «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n        (μ.restrict (spanningSets μ i) s) =\n      μ s :=\n  calc\n    «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n          (μ.restrict (spanningSets μ i) s) =\n        μ.restrict\n          («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n            (spanningSets μ i))\n          s :=\n      (restrict_unionᵢ_apply_eq_supᵢ (directed_of_sup (monotone_spanningSets μ)) hs).symm\n    _ = μ s := by rw [Union_spanning_sets, restrict_univ]\n    \n#align supr_restrict_spanning_sets supr_restrict_spanning_sets\n\n",
 "summable_measure_to_real":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr on » -/\ntheorem summable_measure_to_real [hμ : FiniteMeasure μ] {f : ℕ → Set α} (hf₁ : ∀ i : ℕ, MeasurableSet (f i))\n    (hf₂ : Pairwise («expr on » Disjoint f)) : Summable fun x => (μ (f x)).to_real :=\n  by\n  apply ENNReal.summable_toReal\n  rw [← MeasureTheory.measure_unionᵢ hf₂ hf₁]\n  exact ne_of_lt (measure_lt_top _ _)\n#align summable_measure_to_real summable_measure_to_real\n\n",
 "sum_smul_dirac":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- A measure on a countable type is a sum of Dirac measures. -/\n@[simp]\ntheorem sum_smul_dirac [Countable α] [MeasurableSingletonClass α] (μ : Measure α) :\n    (sum fun a => «expr • » (μ {a}) (dirac a)) = μ := by simpa using (map_eq_sum μ id measurable_id).symm\n#align sum_smul_dirac sum_smul_dirac\n\n",
 "sum_of_empty":
 "@[simp]\ntheorem sum_of_empty [IsEmpty ι] (μ : ι → Measure α) : sum μ = 0 := by\n  rw [← measure_univ_eq_zero, sum_apply _ MeasurableSet.univ, tsum_empty]\n#align sum_of_empty sum_of_empty\n\n",
 "sum_measure_preimage_singleton":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/-- If `s` is a `finset`, then the measure of its preimage can be found as the sum of measures\nof the fibers `f ⁻¹' {y}`. -/\ntheorem sum_measure_preimage_singleton (s : Finset β) {f : α → β} (hf : ∀ y ∈ s, MeasurableSet («expr ⁻¹' » f {y})) :\n    finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s\n        (μ («expr ⁻¹' » f {b})) =\n      μ («expr ⁻¹' » f ↑s) :=\n  by simp only [← measure_bUnion_finset (pairwise_disjoint_fiber _ _) hf, Finset.set_bunionᵢ_preimage_singleton]\n#align sum_measure_preimage_singleton sum_measure_preimage_singleton\n\n",
 "sum_measure_le_measure_univ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem sum_measure_le_measure_univ {s : Finset ι} {t : ι → Set α} (h : ∀ i ∈ s, MeasurableSet (t i))\n    (H : Set.PairwiseDisjoint (↑s) t) :\n    finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s (μ (t i)) ≤\n      μ (univ : Set α) :=\n  by\n  rw [← measure_bUnion_finset H h]\n  exact measure_mono (subset_univ _)\n#align sum_measure_le_measure_univ sum_measure_le_measure_univ\n\n",
 "sum_fintype":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n@[simp]\ntheorem sum_fintype [Fintype ι] (μ : ι → Measure α) :\n    sum μ =\n      finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\" (μ i) :=\n  by\n  ext1 s hs\n  simp only [sum_apply, finset_sum_apply, hs, tsum_fintype]\n#align sum_fintype sum_fintype\n\n",
 "sum_congr":
 "theorem sum_congr {μ ν : ℕ → Measure α} (h : ∀ n, μ n = ν n) : sum μ = sum ν :=\n  congr_arg sum (funext h)\n#align sum_congr sum_congr\n\n",
 "sum_cond":
 "@[simp]\ntheorem sum_cond (μ ν : Measure α) : (sum fun b => cond b μ ν) = μ + ν :=\n  sum_bool _\n#align sum_cond sum_cond\n\n",
 "sum_comm":
 "theorem sum_comm {ι' : Type _} (μ : ι → ι' → Measure α) : (sum fun n => sum (μ n)) = sum fun m => sum fun n => μ n m :=\n  by\n  ext1 s hs\n  simp_rw [sum_apply _ hs]\n  rw [ENNReal.tsum_comm]\n#align sum_comm sum_comm\n\n",
 "sum_coe_finset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n@[simp]\ntheorem sum_coe_finset (s : Finset ι) (μ : ι → Measure α) :\n    (sum fun i : s => μ i) =\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s (μ i) :=\n  by rw [sum_fintype, Finset.sum_coe_sort s μ]\n#align sum_coe_finset sum_coe_finset\n\n",
 "sum_bool":
 "@[simp]\ntheorem sum_bool (f : Bool → Measure α) : sum f = f true + f false := by rw [sum_fintype, Fintype.sum_bool]\n#align sum_bool sum_bool\n\n",
 "sum_apply_eq_zero'":
 "theorem sum_apply_eq_zero' {μ : ι → Measure α} {s : Set α} (hs : MeasurableSet s) : sum μ s = 0 ↔ ∀ i, μ i s = 0 := by\n  simp [hs]\n#align sum_apply_eq_zero' sum_apply_eq_zero'\n\n",
 "sum_apply_eq_zero":
 "@[simp]\ntheorem sum_apply_eq_zero [Countable ι] {μ : ι → Measure α} {s : Set α} : sum μ s = 0 ↔ ∀ i, μ i s = 0 :=\n  by\n  refine' ⟨fun h i => nonpos_iff_eq_zero.1 <| h ▸ le_iff'.1 (le_sum μ i) _, fun h => nonpos_iff_eq_zero.1 _⟩\n  rcases exists_measurable_superset_forall_eq μ s with ⟨t, hst, htm, ht⟩\n  calc\n    Sum μ s ≤ Sum μ t := measure_mono hst\n    _ = 0 := by simp [*]\n    \n#align sum_apply_eq_zero sum_apply_eq_zero\n\n",
 "sum_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , » -/\n@[simp]\ntheorem sum_apply (f : ι → Measure α) {s : Set α} (hs : MeasurableSet s) :\n    sum f s =\n      «expr∑' , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , »\" (f i s) :=\n  toMeasure_apply _ _ hs\n#align sum_apply sum_apply\n\n",
 "sum_add_sum_compl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\ntheorem sum_add_sum_compl (s : Set ι) (μ : ι → Measure α) :\n    ((sum fun i : s => μ i) + sum fun i : «expr ᶜ» s => μ i) = sum μ :=\n  by\n  ext1 t ht\n  simp only [add_apply, sum_apply _ ht]\n  exact @tsum_add_tsum_compl (ennreal) ι _ _ _ (fun i => μ i t) _ s ENNReal.summable ENNReal.summable\n#align sum_add_sum_compl sum_add_sum_compl\n\n",
 "sum_add_sum":
 "theorem sum_add_sum (μ ν : ℕ → Measure α) : sum μ + sum ν = sum fun n => μ n + ν n :=\n  by\n  ext1 s hs\n  simp only [add_apply, sum_apply _ hs, Pi.add_apply, coe_add, tsum_add ENNReal.summable ENNReal.summable]\n#align sum_add_sum sum_add_sum\n\n",
 "subtype_coe":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem null_measurable_set.subtype_coe {t : Set s} (hs : NullMeasurableSet s μ)\n    (ht : NullMeasurableSet t (μ.comap Subtype.val)) : NullMeasurableSet («expr '' » (coe : s → α) t) μ :=\n  NullMeasurableSet.image coe μ Subtype.coe_injective (fun t => MeasurableSet.nullMeasurableSet_subtype_coe hs) ht\n#align null_measurable_set.subtype_coe null_measurable_set.subtype_coe\n\n",
 "sub_ae_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\ntheorem sub_ae_eq_zero {β} [AddGroup β] (f g : α → β) : «expr =ᵐ[ ] » (f - g) μ 0 ↔ «expr =ᵐ[ ] » f μ g :=\n  by\n  refine' ⟨fun h => h.mono fun x hx => _, fun h => h.mono fun x hx => _⟩\n  · rwa [Pi.sub_apply, Pi.zero_apply, sub_eq_zero] at hx\n  · rwa [Pi.sub_apply, Pi.zero_apply, sub_eq_zero]\n#align sub_ae_eq_zero sub_ae_eq_zero\n\n",
 "spanning_sets_index_eq_iff":
 "theorem spanning_sets_index_eq_iff (μ : Measure α) [SigmaFinite μ] {x : α} {n : ℕ} :\n    spanningSetsIndex μ x = n ↔ x ∈ disjointed (spanningSets μ) n := by\n  convert Set.ext_iff.1 (preimage_spanning_sets_index_singleton μ n) x\n#align spanning_sets_index_eq_iff spanning_sets_index_eq_iff\n\n",
 "smul_to_outer_measure":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem smul_to_outer_measure {m : MeasurableSpace α} (c : R) (μ : Measure α) :\n    («expr • » c μ).to_outer_measure = «expr • » c μ.to_outer_measure :=\n  rfl\n#align smul_to_outer_measure smul_to_outer_measure\n\n",
 "smul_finite":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem measure.smul_finite (μ : Measure α) [FiniteMeasure μ] {c : ennreal} (hc : c ≠ ennreal.top) :\n    FiniteMeasure («expr • » c μ) := by\n  lift c to nnreal using hc\n  exact MeasureTheory.finiteMeasureSmulNNReal\n#align measure.smul_finite measure.smul_finite\n\n",
 "smul_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem smul_apply {m : MeasurableSpace α} (c : R) (μ : Measure α) (s : Set α) :\n    («expr • » c μ) s = «expr • » c (μ s) :=\n  rfl\n#align smul_apply smul_apply\n\n",
 "smul_ae_eq_of_ae_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:219:4: warning: unsupported binary notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[to_additive]\ntheorem smul_ae_eq_of_ae_eq {G α : Type _} [Group G] [MulAction G α] [MeasurableSpace α] {s t : Set α} {μ : Measure α}\n    (g : G) (h_qmp : QuasiMeasurePreserving ((«expr • » · ·) g⁻¹ : α → α) μ μ) (h_ae_eq : «expr =ᵐ[ ] » s μ t) :\n    «expr =ᵐ[ ] » («expr • » g s : Set α) μ («expr • » g t : Set α) := by\n  simpa only [← preimage_smul_inv] using h_qmp.ae_eq h_ae_eq\n#align smul_ae_eq_of_ae_eq smul_ae_eq_of_ae_eq\n\n",
 "smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\nprotected theorem is_finite_measure_on_compacts.smul [TopologicalSpace α] (μ : Measure α) [FiniteMeasureOnCompacts μ]\n    {c : ennreal} (hc : c ≠ ennreal.top) : FiniteMeasureOnCompacts («expr • » c μ) :=\n  ⟨fun K hK => ENNReal.mul_lt_top hc hK.measure_lt_top.ne⟩\n#align is_finite_measure_on_compacts.smul is_finite_measure_on_compacts.smul\n\n",
 "sigma_finite_trim_mono":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\ntheorem sigma_finite_trim_mono {m m₂ m0 : MeasurableSpace α} {μ : Measure α} (hm : m ≤ m0) (hm₂ : m₂ ≤ m)\n    [SigmaFinite (μ.trim (hm₂.trans hm))] : SigmaFinite (μ.trim hm) :=\n  by\n  have h := measure.finite_spanning_sets_in (μ.trim (hm₂.trans hm)) Set.univ\n  refine' measure.finite_spanning_sets_in.sigma_finite _\n  · use Set.univ\n  · refine'\n      { set := spanning_sets (μ.trim (hm₂.trans hm))\n        set_mem := fun _ => Set.mem_univ _\n        finite := fun i => _\n        -- This is the only one left to prove\n        spanning := Union_spanning_sets _ }\n    calc\n      (μ.trim hm) (spanning_sets (μ.trim (hm₂.trans hm)) i) =\n          ((μ.trim hm).trim hm₂) (spanning_sets (μ.trim (hm₂.trans hm)) i) :=\n        by rw [@trim_measurable_set_eq α m₂ m (μ.trim hm) _ hm₂ (measurable_spanning_sets _ _)]\n      _ = (μ.trim (hm₂.trans hm)) (spanning_sets (μ.trim (hm₂.trans hm)) i) := by rw [@trim_trim _ _ μ _ _ hm₂ hm]\n      _ < ennreal.top := measure_spanning_sets_lt_top _ _\n      \n#align sigma_finite_trim_mono sigma_finite_trim_mono\n\n",
 "sigma_finite_trim_bot_iff":
 "theorem sigma_finite_trim_bot_iff : SigmaFinite (μ.trim bot_le) ↔ FiniteMeasure μ :=\n  by\n  rw [sigma_finite_bot_iff]\n  refine' ⟨fun h => ⟨_⟩, fun h => ⟨_⟩⟩ <;> have h_univ := h.measure_univ_lt_top\n  · rwa [trim_measurable_set_eq bot_le MeasurableSet.univ] at h_univ\n  · rwa [trim_measurable_set_eq bot_le MeasurableSet.univ]\n#align sigma_finite_trim_bot_iff sigma_finite_trim_bot_iff\n\n",
 "sigma_finite_of_le":
 "theorem sigma_finite_of_le (μ : Measure α) [hs : SigmaFinite μ] (h : ν ≤ μ) : SigmaFinite ν :=\n  ⟨hs.out.map <| FiniteSpanningSetsIn.ofLE h⟩\n#align sigma_finite_of_le sigma_finite_of_le\n\n",
 "sigma_finite_of_countable":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\ntheorem sigma_finite_of_countable {S : Set (Set α)} (hc : S.countable) (hμ : ∀ s ∈ S, μ s < ennreal.top)\n    (hU : ⋃₀ S = univ) : SigmaFinite μ :=\n  by\n  obtain ⟨s, hμ, hs⟩ :\n    ∃ s : ℕ → Set α,\n      (∀ n, μ (s n) < ennreal.top) ∧\n        «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (s n) = univ\n  exact (@exists_seq_cover_iff_countable _ (fun x => μ x < «expr⊤») ⟨∅, by simp⟩).2 ⟨S, hc, hμ, hU⟩\n  exact ⟨⟨⟨fun n => s n, fun n => trivial, hμ, hs⟩⟩⟩\n#align sigma_finite_of_countable sigma_finite_of_countable\n\n",
 "sigma_finite_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ᵐ » -/\n#print MeasurableEquiv.sigmaFinite_map /-\ntheorem MeasurableEquiv.sigmaFinite_map {μ : Measure α} (f : «expr ≃ᵐ » α β) (h : SigmaFinite μ) :\n    SigmaFinite (μ.map f) :=\n  by\n  refine' sigma_finite.of_map _ f.symm.measurable.ae_measurable _\n  rwa [map_map f.symm.measurable f.measurable, f.symm_comp_self, measure.map_id]\n#align measurable_equiv.sigma_finite_map MeasurableEquiv.sigmaFinite_map\n-/\n\n",
 "sigma_finite_iff":
 "theorem sigma_finite_iff : SigmaFinite μ ↔ Nonempty (μ.finite_spanning_sets_in univ) :=\n  ⟨fun h => h.1, fun h => ⟨h⟩⟩\n#align sigma_finite_iff sigma_finite_iff\n\n",
 "sigma_finite_bot_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem sigma_finite_bot_iff (μ : @Measure α («expr⊥»)) : SigmaFinite μ ↔ FiniteMeasure μ :=\n  by\n  refine'\n    ⟨fun h => ⟨_⟩, fun h => by\n      haveI := h\n      infer_instance⟩\n  haveI : sigma_finite μ := h\n  let s := spanning_sets μ\n  have hs_univ :\n    «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (s i) = Set.univ :=\n    Union_spanning_sets μ\n  have hs_meas : ∀ i, (measurable_set_of («expr⊥»)) (s i) := measurable_spanning_sets μ\n  simp_rw [MeasurableSpace.measurableSet_bot_iff] at hs_meas\n  by_cases h_univ_empty : Set.univ = ∅\n  · rw [h_univ_empty, measure_empty]\n    exact ennreal.zero_ne_top.lt_top\n  obtain ⟨i, hsi⟩ : ∃ i, s i = Set.univ := by\n    by_contra h_not_univ\n    push_neg  at h_not_univ\n    have h_empty : ∀ i, s i = ∅ := by simpa [h_not_univ] using hs_meas\n    simp [h_empty] at hs_univ\n    exact h_univ_empty hs_univ.symm\n  rw [← hsi]\n  exact measure_spanning_sets_lt_top μ i\n#align sigma_finite_bot_iff sigma_finite_bot_iff\n\n",
 "sigma_finite":
 "/-- If `μ` has finite spanning sets in the collection of measurable sets `C`, then `μ` is σ-finite.\n-/\nprotected theorem sigma_finite (h : μ.finite_spanning_sets_in C) : SigmaFinite μ :=\n  ⟨⟨h.mono <| subset_univ C⟩⟩\n#align sigma_finite sigma_finite\n\n",
 "self_mem_ae_restrict":
 "theorem self_mem_ae_restrict {s} (hs : MeasurableSet s) : s ∈ (μ.restrict s).ae := by\n  simp only [ae_restrict_eq hs, exists_prop, mem_principal, mem_inf_iff] <;>\n    exact ⟨_, univ_mem, s, subset.rfl, (univ_inter s).symm⟩\n#align self_mem_ae_restrict self_mem_ae_restrict\n\n",
 "rfl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure.absolutely_continuous -/\n#print rfl /-\nprotected theorem rfl : measure.absolutely_continuous μ μ := fun s hs => hs\n#align rfl rfl\n-/\n\n",
 "restrictₗ_apply":
 "@[simp]\ntheorem restrictₗ_apply {m0 : MeasurableSpace α} (s : Set α) (μ : Measure α) : restrictₗ s μ = μ.restrict s :=\n  rfl\n#align restrictₗ_apply restrictₗ_apply\n\n",
 "restrict_zero_set":
 "theorem restrict_zero_set {s : Set α} (h : μ s = 0) : μ.restrict s = 0 :=\n  restrict_eq_zero.2 h\n#align restrict_zero_set restrict_zero_set\n\n",
 "restrict_zero":
 "@[simp]\ntheorem restrict_zero {m0 : MeasurableSpace α} (s : Set α) : (0 : Measure α).restrict s = 0 :=\n  (restrictₗ s).map_zero\n#align restrict_zero restrict_zero\n\n",
 "restrict_univ":
 "@[simp]\ntheorem restrict_univ : μ.restrict univ = μ :=\n  ext fun s hs => by simp [hs]\n#align restrict_univ restrict_univ\n\n",
 "restrict_union₀":
 "theorem restrict_union₀ (h : AEDisjoint μ s t) (ht : NullMeasurableSet t μ) :\n    μ.restrict (s ∪ t) = μ.restrict s + μ.restrict t := by simp [← restrict_union_add_inter₀ s ht, restrict_zero_set h]\n#align restrict_union₀ restrict_union₀\n\n",
 "restrict_union_le":
 "theorem restrict_union_le (s s' : Set α) : μ.restrict (s ∪ s') ≤ μ.restrict s + μ.restrict s' :=\n  by\n  intro t ht\n  suffices μ (t ∩ s ∪ t ∩ s') ≤ μ (t ∩ s) + μ (t ∩ s') by simpa [ht, inter_union_distrib_left]\n  apply measure_union_le\n#align restrict_union_le restrict_union_le\n\n",
 "restrict_union_congr":
 "/-- If two measures agree on all measurable subsets of `s` and `t`, then they agree on all\nmeasurable subsets of `s ∪ t`. -/\ntheorem restrict_union_congr :\n    μ.restrict (s ∪ t) = ν.restrict (s ∪ t) ↔ μ.restrict s = ν.restrict s ∧ μ.restrict t = ν.restrict t :=\n  by\n  refine' ⟨fun h => ⟨restrict_congr_mono (subset_union_left _ _) h, restrict_congr_mono (subset_union_right _ _) h⟩, _⟩\n  rintro ⟨hs, ht⟩\n  ext1 u hu\n  simp only [restrict_apply hu, inter_union_distrib_left]\n  rcases exists_measurable_superset₂ μ ν (u ∩ s) with ⟨US, hsub, hm, hμ, hν⟩\n  calc\n    μ (u ∩ s ∪ u ∩ t) = μ (US ∪ u ∩ t) := measure_union_congr_of_subset hsub hμ.le subset.rfl le_rfl\n    _ = μ US + μ ((u ∩ t) \\ US) := (measure_add_diff hm _).symm\n    _ = restrict μ s u + restrict μ t (u \\ US) := by\n      simp only [restrict_apply, hu, hu.diff hm, hμ, ← inter_comm t, inter_diff_assoc]\n    _ = restrict ν s u + restrict ν t (u \\ US) := by rw [hs, ht]\n    _ = ν US + ν ((u ∩ t) \\ US) := by simp only [restrict_apply, hu, hu.diff hm, hν, ← inter_comm t, inter_diff_assoc]\n    _ = ν (US ∪ u ∩ t) := (measure_add_diff hm _)\n    _ = ν (u ∩ s ∪ u ∩ t) := Eq.symm <| measure_union_congr_of_subset hsub hν.le subset.rfl le_rfl\n    \n#align restrict_union_congr restrict_union_congr\n\n",
 "restrict_union_add_inter₀":
 "theorem restrict_union_add_inter₀ (s : Set α) (ht : NullMeasurableSet t μ) :\n    μ.restrict (s ∪ t) + μ.restrict (s ∩ t) = μ.restrict s + μ.restrict t := by\n  rw [← restrict_inter_add_diff₀ (s ∪ t) ht, union_inter_cancel_right, union_diff_right, ←\n    restrict_inter_add_diff₀ s ht, add_comm, ← add_assoc, add_right_comm]\n#align restrict_union_add_inter₀ restrict_union_add_inter₀\n\n",
 "restrict_union_add_inter'":
 "theorem restrict_union_add_inter' (hs : MeasurableSet s) (t : Set α) :\n    μ.restrict (s ∪ t) + μ.restrict (s ∩ t) = μ.restrict s + μ.restrict t := by\n  simpa only [union_comm, inter_comm, add_comm] using restrict_union_add_inter t hs\n#align restrict_union_add_inter' restrict_union_add_inter'\n\n",
 "restrict_union_add_inter":
 "theorem restrict_union_add_inter (s : Set α) (ht : MeasurableSet t) :\n    μ.restrict (s ∪ t) + μ.restrict (s ∩ t) = μ.restrict s + μ.restrict t :=\n  restrict_union_add_inter₀ s ht.null_measurable_set\n#align restrict_union_add_inter restrict_union_add_inter\n\n",
 "restrict_union'":
 "theorem restrict_union' (h : Disjoint s t) (hs : MeasurableSet s) : μ.restrict (s ∪ t) = μ.restrict s + μ.restrict t :=\n  by rw [union_comm, restrict_union h.symm hs, add_comm]\n#align restrict_union' restrict_union'\n\n",
 "restrict_union":
 "theorem restrict_union (h : Disjoint s t) (ht : MeasurableSet t) : μ.restrict (s ∪ t) = μ.restrict s + μ.restrict t :=\n  restrict_union₀ h.ae_disjoint ht.null_measurable_set\n#align restrict_union restrict_union\n\n",
 "restrict_trim":
 "theorem restrict_trim (hm : m ≤ m0) (μ : Measure α) (hs : @MeasurableSet α m s) :\n    @Measure.restrict α m (μ.trim hm) s = (μ.restrict s).trim hm :=\n  by\n  ext1 t ht\n  rw [@measure.restrict_apply α m _ _ _ ht, trim_measurable_set_eq hm ht, measure.restrict_apply (hm t ht),\n    trim_measurable_set_eq hm (@MeasurableSet.inter α m t s ht hs)]\n#align restrict_trim restrict_trim\n\n",
 "restrict_to_outer_measure_eq_to_outer_measure_restrict":
 "/-- This lemma shows that `restrict` and `to_outer_measure` commute. Note that the LHS has a\nrestrict on measures and the RHS has a restrict on outer measures. -/\ntheorem restrict_to_outer_measure_eq_to_outer_measure_restrict (h : MeasurableSet s) :\n    (μ.restrict s).to_outer_measure = OuterMeasure.restrict s μ.to_outer_measure := by\n  simp_rw [restrict, restrictₗ, lift_linear, LinearMap.coe_mk, to_measure_to_outer_measure,\n    outer_measure.restrict_trim h, μ.trimmed]\n#align restrict_to_outer_measure_eq_to_outer_measure_restrict restrict_to_outer_measure_eq_to_outer_measure_restrict\n\n",
 "restrict_to_measurable_of_sigma_finite":
 "@[simp]\ntheorem restrict_to_measurable_of_sigma_finite [SigmaFinite μ] (s : Set α) :\n    μ.restrict (toMeasurable μ s) = μ.restrict s :=\n  ext fun t ht => by simp only [restrict_apply ht, inter_comm t, measure_to_measurable_inter_of_sigma_finite ht]\n#align restrict_to_measurable_of_sigma_finite restrict_to_measurable_of_sigma_finite\n\n",
 "restrict_to_measurable_of_cover":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\ntheorem restrict_to_measurable_of_cover {s : Set α} {v : ℕ → Set α}\n    (hv : s ⊆ «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (v n))\n    (h'v : ∀ n, μ (s ∩ v n) ≠ ennreal.top) : μ.restrict (toMeasurable μ s) = μ.restrict s :=\n  ext fun t ht => by simp only [restrict_apply ht, inter_comm t, measure_to_measurable_inter_of_cover ht hv h'v]\n#align restrict_to_measurable_of_cover restrict_to_measurable_of_cover\n\n",
 "restrict_to_measurable":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\ntheorem restrict_to_measurable (h : μ s ≠ ennreal.top) : μ.restrict (toMeasurable μ s) = μ.restrict s :=\n  ext fun t ht => by rw [restrict_apply ht, restrict_apply ht, inter_comm, measure_to_measurable_inter ht h, inter_comm]\n#align restrict_to_measurable restrict_to_measurable\n\n",
 "restrict_sum":
 "@[simp]\ntheorem restrict_sum (μ : ι → Measure α) {s : Set α} (hs : MeasurableSet s) :\n    (sum μ).restrict s = sum fun i => (μ i).restrict s :=\n  ext fun t ht => by simp only [sum_apply, restrict_apply, ht, ht.inter hs]\n#align restrict_sum restrict_sum\n\n",
 "restrict_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem restrict_smul {m0 : MeasurableSpace α} (c : ennreal) (μ : Measure α) (s : Set α) :\n    («expr • » c μ).restrict s = «expr • » c (μ.restrict s) :=\n  (restrictₗ s).map_smul c μ\n#align restrict_smul restrict_smul\n\n",
 "restrict_singleton'":
 "theorem measure.restrict_singleton' {a : α} : μ.restrict {a} = 0 := by\n  simp only [measure_singleton, measure.restrict_eq_zero]\n#align measure.restrict_singleton' measure.restrict_singleton'\n\n",
 "restrict_singleton":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem restrict_singleton (μ : Measure α) (a : α) : μ.restrict {a} = «expr • » (μ {a}) (dirac a) :=\n  by\n  ext1 s hs\n  by_cases ha : a ∈ s\n  · have : s ∩ {a} = {a} := by simpa\n    simp [*]\n  · have : s ∩ {a} = ∅ := inter_singleton_eq_empty.2 ha\n    simp [*]\n#align restrict_singleton restrict_singleton\n\n",
 "restrict_sUnion_congr":
 "theorem restrict_sUnion_congr {S : Set (Set α)} (hc : S.countable) :\n    μ.restrict (⋃₀ S) = ν.restrict (⋃₀ S) ↔ ∀ s ∈ S, μ.restrict s = ν.restrict s := by\n  rw [sUnion_eq_bUnion, restrict_bUnion_congr hc]\n#align restrict_sUnion_congr restrict_sUnion_congr\n\n",
 "restrict_restrict₀'":
 "theorem restrict_restrict₀' (ht : NullMeasurableSet t μ) : (μ.restrict t).restrict s = μ.restrict (s ∩ t) :=\n  ext fun u hu => by simp only [restrict_apply hu, restrict_apply₀' ht, inter_assoc]\n#align restrict_restrict₀' restrict_restrict₀'\n\n",
 "restrict_restrict₀":
 "theorem restrict_restrict₀ (hs : NullMeasurableSet s (μ.restrict t)) : (μ.restrict t).restrict s = μ.restrict (s ∩ t) :=\n  ext fun u hu => by simp only [Set.inter_assoc, restrict_apply hu, restrict_apply₀ (hu.null_measurable_set.inter hs)]\n#align restrict_restrict₀ restrict_restrict₀\n\n",
 "restrict_restrict_of_subset":
 "theorem restrict_restrict_of_subset (h : s ⊆ t) : (μ.restrict t).restrict s = μ.restrict s :=\n  by\n  ext1 u hu\n  rw [restrict_apply hu, restrict_apply hu, restrict_eq_self]\n  exact (inter_subset_right _ _).trans h\n#align restrict_restrict_of_subset restrict_restrict_of_subset\n\n",
 "restrict_restrict'":
 "theorem restrict_restrict' (ht : MeasurableSet t) : (μ.restrict t).restrict s = μ.restrict (s ∩ t) :=\n  restrict_restrict₀' ht.null_measurable_set\n#align restrict_restrict' restrict_restrict'\n\n",
 "restrict_restrict":
 "@[simp]\ntheorem restrict_restrict (hs : MeasurableSet s) : (μ.restrict t).restrict s = μ.restrict (s ∩ t) :=\n  restrict_restrict₀ hs.null_measurable_set\n#align restrict_restrict restrict_restrict\n\n",
 "restrict_mono_ae":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≤ᵐ[ ] » -/\ntheorem restrict_mono_ae (h : «expr ≤ᵐ[ ] » s μ t) : μ.restrict s ≤ μ.restrict t :=\n  restrict_mono' h (le_refl μ)\n#align restrict_mono_ae restrict_mono_ae\n\n",
 "restrict_mono'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≤ᵐ[ ] » -/\n/-- Restriction of a measure to a subset is monotone both in set and in measure. -/\ntheorem restrict_mono' {m0 : MeasurableSpace α} ⦃s s' : Set α⦄ ⦃μ ν : Measure α⦄ (hs : «expr ≤ᵐ[ ] » s μ s')\n    (hμν : μ ≤ ν) : μ.restrict s ≤ ν.restrict s' := fun t ht =>\n  calc\n    μ.restrict s t = μ (t ∩ s) := restrict_apply ht\n    _ ≤ μ (t ∩ s') := (measure_mono_ae <| hs.mono fun x hx ⟨hxt, hxs⟩ => ⟨hxt, hx hxs⟩)\n    _ ≤ ν (t ∩ s') := (le_iff'.1 hμν (t ∩ s'))\n    _ = ν.restrict s' t := (restrict_apply ht).symm\n    \n#align restrict_mono' restrict_mono'\n\n",
 "restrict_mono":
 "/-- Restriction of a measure to a subset is monotone both in set and in measure. -/\n@[mono]\ntheorem restrict_mono {m0 : MeasurableSpace α} ⦃s s' : Set α⦄ (hs : s ⊆ s') ⦃μ ν : Measure α⦄ (hμν : μ ≤ ν) :\n    μ.restrict s ≤ ν.restrict s' :=\n  restrict_mono' (ae_of_all _ hs) hμν\n#align restrict_mono restrict_mono\n\n",
 "restrict_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ᵐ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem restrict_map (e : «expr ≃ᵐ » α β) (s : Set β) : (μ.map e).restrict s = (μ.restrict <| «expr ⁻¹' » e s).map e :=\n  e.measurable_embedding.restrict_map _ _\n#align restrict_map restrict_map\n\n",
 "restrict_le_self":
 "theorem restrict_le_self : μ.restrict s ≤ μ := fun t ht =>\n  calc\n    μ.restrict s t = μ (t ∩ s) := restrict_apply ht\n    _ ≤ μ t := measure_mono <| inter_subset_left t s\n    \n#align restrict_le_self restrict_le_self\n\n",
 "restrict_inter_add_diff₀":
 "theorem restrict_inter_add_diff₀ (s : Set α) (ht : NullMeasurableSet t μ) :\n    μ.restrict (s ∩ t) + μ.restrict (s \\ t) = μ.restrict s :=\n  by\n  ext1 u hu\n  simp only [add_apply, restrict_apply hu, ← inter_assoc, diff_eq]\n  exact measure_inter_add_diff₀ (u ∩ s) ht\n#align restrict_inter_add_diff₀ restrict_inter_add_diff₀\n\n",
 "restrict_inter_add_diff":
 "theorem restrict_inter_add_diff (s : Set α) (ht : MeasurableSet t) :\n    μ.restrict (s ∩ t) + μ.restrict (s \\ t) = μ.restrict s :=\n  restrict_inter_add_diff₀ s ht.null_measurable_set\n#align restrict_inter_add_diff restrict_inter_add_diff\n\n",
 "restrict_finset_bUnion_congr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\ntheorem restrict_finset_bUnion_congr {s : Finset ι} {t : ι → Set α} :\n    μ.restrict («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (t i)) =\n        ν.restrict\n          («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (t i)) ↔\n      ∀ i ∈ s, μ.restrict (t i) = ν.restrict (t i) :=\n  by\n  induction' s using Finset.induction_on with i s hi hs; · simp\n  simp only [forall_eq_or_imp, Union_Union_eq_or_left, Finset.mem_insert]\n  rw [restrict_union_congr, ← hs]\n#align restrict_finset_bUnion_congr restrict_finset_bUnion_congr\n\n",
 "restrict_eq_zero":
 "@[simp]\ntheorem restrict_eq_zero : μ.restrict s = 0 ↔ μ s = 0 := by rw [← measure_univ_eq_zero, restrict_apply_univ]\n#align restrict_eq_zero restrict_eq_zero\n\n",
 "restrict_eq_self_of_ae_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\ntheorem restrict_eq_self_of_ae_mem {m0 : MeasurableSpace α} ⦃s : Set α⦄ ⦃μ : Measure α⦄\n    (hs :\n      «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\" μ (x ∈ s)) :\n    μ.restrict s = μ :=\n  calc\n    μ.restrict s = μ.restrict univ := restrict_congr_set (eventuallyEq_univ.mpr hs)\n    _ = μ := restrict_univ\n    \n#align restrict_eq_self_of_ae_mem restrict_eq_self_of_ae_mem\n\n",
 "restrict_eq_self":
 "theorem restrict_eq_self (h : s ⊆ t) : μ.restrict t s = μ s :=\n  (le_iff'.1 restrict_le_self s).antisymm <|\n    calc\n      μ s ≤ μ (toMeasurable (μ.restrict t) s ∩ t) := measure_mono (subset_inter (subset_toMeasurable _ _) h)\n      _ = μ.restrict t s := by rw [← restrict_apply (measurable_set_to_measurable _ _), measure_to_measurable]\n      \n#align restrict_eq_self restrict_eq_self\n\n",
 "restrict_empty":
 "@[simp]\ntheorem restrict_empty : μ.restrict ∅ = 0 :=\n  restrict_zero_set measure_empty\n#align restrict_empty restrict_empty\n\n",
 "restrict_congr_set":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\ntheorem restrict_congr_set (h : «expr =ᵐ[ ] » s μ t) : μ.restrict s = μ.restrict t :=\n  le_antisymm (restrict_mono_ae h.le) (restrict_mono_ae h.symm.le)\n#align restrict_congr_set restrict_congr_set\n\n",
 "restrict_congr_mono":
 "theorem restrict_congr_mono (hs : s ⊆ t) (h : μ.restrict t = ν.restrict t) : μ.restrict s = ν.restrict s := by\n  rw [← restrict_restrict_of_subset hs, h, restrict_restrict_of_subset hs]\n#align restrict_congr_mono restrict_congr_mono\n\n",
 "restrict_congr_meas":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (t «expr ⊆ » s) -/\ntheorem restrict_congr_meas (hs : MeasurableSet s) :\n    μ.restrict s = ν.restrict s ↔ ∀ (t) (_ : t ⊆ s), MeasurableSet t → μ t = ν t :=\n  ⟨fun H t hts ht => by rw [← inter_eq_self_of_subset_left hts, ← restrict_apply ht, H, restrict_apply ht], fun H =>\n    ext fun t ht => by rw [restrict_apply ht, restrict_apply ht, H _ (inter_subset_right _ _) (ht.inter hs)]⟩\n#align restrict_congr_meas restrict_congr_meas\n\n",
 "restrict_compl_add_restrict":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n@[simp]\ntheorem restrict_compl_add_restrict (hs : MeasurableSet s) : μ.restrict («expr ᶜ» s) + μ.restrict s = μ := by\n  rw [add_comm, restrict_add_restrict_compl hs]\n#align restrict_compl_add_restrict restrict_compl_add_restrict\n\n",
 "restrict_comm":
 "theorem restrict_comm (hs : MeasurableSet s) : (μ.restrict t).restrict s = (μ.restrict s).restrict t := by\n  rw [restrict_restrict hs, restrict_restrict' hs, inter_comm]\n#align restrict_comm restrict_comm\n\n",
 "restrict_bUnion_congr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\ntheorem restrict_bUnion_congr {s : Set ι} {t : ι → Set α} (hc : s.countable) :\n    μ.restrict («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (t i)) =\n        ν.restrict\n          («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (t i)) ↔\n      ∀ i ∈ s, μ.restrict (t i) = ν.restrict (t i) :=\n  by\n  haveI := hc.to_encodable\n  simp only [bUnion_eq_Union, SetCoe.forall', restrict_Union_congr]\n#align restrict_bUnion_congr restrict_bUnion_congr\n\n",
 "restrict_apply₀'":
 "theorem restrict_apply₀' (hs : NullMeasurableSet s μ) : μ.restrict s t = μ (t ∩ s) := by\n  rw [← restrict_congr_set hs.to_measurable_ae_eq, restrict_apply' (measurable_set_to_measurable _ _),\n    measure_congr ((ae_eq_refl t).inter hs.to_measurable_ae_eq)]\n#align restrict_apply₀' restrict_apply₀'\n\n",
 "restrict_apply₀":
 "theorem restrict_apply₀ (ht : NullMeasurableSet t (μ.restrict s)) : μ.restrict s t = μ (t ∩ s) :=\n  (toMeasure_apply₀ _ _ ht).trans <| by simp only [coe_to_outer_measure, outer_measure.restrict_apply]\n#align restrict_apply₀ restrict_apply₀\n\n",
 "restrict_apply_univ":
 "theorem restrict_apply_univ (s : Set α) : μ.restrict s univ = μ s := by\n  rw [restrict_apply MeasurableSet.univ, Set.univ_inter]\n#align restrict_apply_univ restrict_apply_univ\n\n",
 "restrict_apply_superset":
 "theorem restrict_apply_superset (h : s ⊆ t) : μ.restrict s t = μ s :=\n  ((measure_mono (subset_univ _)).trans_eq <| restrict_apply_univ _).antisymm\n    ((restrict_apply_self μ s).symm.trans_le <| measure_mono h)\n#align restrict_apply_superset restrict_apply_superset\n\n",
 "restrict_apply_self":
 "@[simp]\ntheorem restrict_apply_self (s : Set α) : (μ.restrict s) s = μ s :=\n  restrict_eq_self μ Subset.rfl\n#align restrict_apply_self restrict_apply_self\n\n",
 "restrict_apply_eq_zero'":
 "theorem restrict_apply_eq_zero' (hs : MeasurableSet s) : μ.restrict s t = 0 ↔ μ (t ∩ s) = 0 := by\n  rw [restrict_apply' hs]\n#align restrict_apply_eq_zero' restrict_apply_eq_zero'\n\n",
 "restrict_apply_eq_zero":
 "theorem restrict_apply_eq_zero (ht : MeasurableSet t) : μ.restrict s t = 0 ↔ μ (t ∩ s) = 0 := by rw [restrict_apply ht]\n#align restrict_apply_eq_zero restrict_apply_eq_zero\n\n",
 "restrict_apply'":
 "/-- If `s` is a measurable set, then the outer measure of `t` with respect to the restriction of\nthe measure to `s` equals the outer measure of `t ∩ s`. This is an alternate version of\n`measure.restrict_apply`, requiring that `s` is measurable instead of `t`. -/\n@[simp]\ntheorem restrict_apply' (hs : MeasurableSet s) : μ.restrict s t = μ (t ∩ s) := by\n  rw [← coe_to_outer_measure, measure.restrict_to_outer_measure_eq_to_outer_measure_restrict hs,\n    outer_measure.restrict_apply s t _, coe_to_outer_measure]\n#align restrict_apply' restrict_apply'\n\n",
 "restrict_apply":
 "/-- If `t` is a measurable set, then the measure of `t` with respect to the restriction of\n  the measure to `s` equals the outer measure of `t ∩ s`. An alternate version requiring that `s`\n  be measurable instead of `t` exists as `measure.restrict_apply'`. -/\n@[simp]\ntheorem restrict_apply (ht : MeasurableSet t) : μ.restrict s t = μ (t ∩ s) :=\n  restrict_apply₀ ht.null_measurable_set\n#align restrict_apply restrict_apply\n\n",
 "restrict_add_restrict_compl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n@[simp]\ntheorem restrict_add_restrict_compl (hs : MeasurableSet s) : μ.restrict s + μ.restrict («expr ᶜ» s) = μ := by\n  rw [← restrict_union (@disjoint_compl_right (Set α) _ _) hs.compl, union_compl_self, restrict_univ]\n#align restrict_add_restrict_compl restrict_add_restrict_compl\n\n",
 "restrict_add":
 "@[simp]\ntheorem restrict_add {m0 : MeasurableSpace α} (μ ν : Measure α) (s : Set α) :\n    (μ + ν).restrict s = μ.restrict s + ν.restrict s :=\n  (restrictₗ s).map_add μ ν\n#align restrict_add restrict_add\n\n",
 "restrict_Union_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\ntheorem restrict_Union_le [Countable ι] {s : ι → Set α} :\n    μ.restrict («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (s i)) ≤\n      sum fun i => μ.restrict (s i) :=\n  by\n  intro t ht\n  suffices\n    μ («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (t ∩ s i)) ≤\n      «expr∑' , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , »\" (μ (t ∩ s i))\n    by simpa [ht, inter_Union]\n  apply measure_Union_le\n#align restrict_Union_le restrict_Union_le\n\n",
 "restrict_Union_congr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\ntheorem restrict_Union_congr [Countable ι] {s : ι → Set α} :\n    μ.restrict («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (s i)) =\n        ν.restrict\n          («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (s i)) ↔\n      ∀ i, μ.restrict (s i) = ν.restrict (s i) :=\n  by\n  refine' ⟨fun h i => restrict_congr_mono (subset_Union _ _) h, fun h => _⟩\n  ext1 t ht\n  have D :\n    Directed (· ⊆ ·) fun t : Finset ι =>\n      «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (s i) :=\n    directed_of_sup fun t₁ t₂ ht => bUnion_subset_bUnion_left ht\n  rw [Union_eq_Union_finset]\n  simp only [restrict_Union_apply_eq_supr D ht, restrict_finset_bUnion_congr.2 fun i hi => h i]\n#align restrict_Union_congr restrict_Union_congr\n\n",
 "restrict_Union_apply_eq_supr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\ntheorem restrict_Union_apply_eq_supr [Countable ι] {s : ι → Set α} (hd : Directed (· ⊆ ·) s) {t : Set α}\n    (ht : MeasurableSet t) :\n    μ.restrict («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (s i))\n        t =\n      «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n        (μ.restrict (s i) t) :=\n  by\n  simp only [restrict_apply ht, inter_Union]\n  rw [measure_Union_eq_supr]\n  exacts[hd.mono_comp _ fun s₁ s₂ => inter_subset_inter_right _]\n#align restrict_Union_apply_eq_supr restrict_Union_apply_eq_supr\n\n",
 "restrict_Union_apply_ae":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr on » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , » -/\ntheorem restrict_Union_apply_ae [Countable ι] {s : ι → Set α} (hd : Pairwise («expr on » (AEDisjoint μ) s))\n    (hm : ∀ i, NullMeasurableSet (s i) μ) {t : Set α} (ht : MeasurableSet t) :\n    μ.restrict («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (s i))\n        t =\n      «expr∑' , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , »\"\n        (μ.restrict (s i) t) :=\n  by\n  simp only [restrict_apply, ht, inter_Union]\n  exact\n    measure_Union₀ (hd.mono fun i j h => h.mono (inter_subset_right _ _) (inter_subset_right _ _)) fun i =>\n      ht.null_measurable_set.inter (hm i)\n#align restrict_Union_apply_ae restrict_Union_apply_ae\n\n",
 "restrict_Union_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr on » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , » -/\ntheorem restrict_Union_apply [Countable ι] {s : ι → Set α} (hd : Pairwise («expr on » Disjoint s))\n    (hm : ∀ i, MeasurableSet (s i)) {t : Set α} (ht : MeasurableSet t) :\n    μ.restrict («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (s i))\n        t =\n      «expr∑' , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , »\"\n        (μ.restrict (s i) t) :=\n  restrict_unionᵢ_apply_ae hd.ae_disjoint (fun i => (hm i).null_measurable_set) ht\n#align restrict_Union_apply restrict_Union_apply\n\n",
 "restrict_Union_ae":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr on » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\ntheorem restrict_Union_ae [Countable ι] {s : ι → Set α} (hd : Pairwise («expr on » (AEDisjoint μ) s))\n    (hm : ∀ i, NullMeasurableSet (s i) μ) :\n    μ.restrict («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (s i)) =\n      sum fun i => μ.restrict (s i) :=\n  ext fun t ht => by simp only [sum_apply _ ht, restrict_Union_apply_ae hd hm ht]\n#align restrict_Union_ae restrict_Union_ae\n\n",
 "restrict_Union":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr on » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\ntheorem restrict_Union [Countable ι] {s : ι → Set α} (hd : Pairwise («expr on » Disjoint s))\n    (hm : ∀ i, MeasurableSet (s i)) :\n    μ.restrict («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (s i)) =\n      sum fun i => μ.restrict (s i) :=\n  restrict_unionᵢ_ae hd.ae_disjoint fun i => (hm i).null_measurable_set\n#align restrict_Union restrict_Union\n\n",
 "restrict_Inf_eq_Inf_restrict":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/-- This lemma shows that `Inf` and `restrict` commute for measures. -/\ntheorem restrict_Inf_eq_Inf_restrict {m0 : MeasurableSpace α} {m : Set (Measure α)} (hm : m.nonempty)\n    (ht : MeasurableSet t) : (infₛ m).restrict t = infₛ («expr '' » (fun μ : Measure α => μ.restrict t) m) :=\n  by\n  ext1 s hs\n  simp_rw [infₛ_apply hs, restrict_apply hs, infₛ_apply (MeasurableSet.inter hs ht), Set.image_image,\n    restrict_to_outer_measure_eq_to_outer_measure_restrict ht, ← Set.image_image _ to_outer_measure, ←\n    outer_measure.restrict_Inf_eq_Inf_restrict _ (hm.image _), outer_measure.restrict_apply]\n#align restrict_Inf_eq_Inf_restrict restrict_Inf_eq_Inf_restrict\n\n",
 "restrict":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\n#print Filter.EventuallyEq.restrict /-\ntheorem Filter.EventuallyEq.restrict {f g : α → δ} {s : Set α} (hfg : «expr =ᵐ[ ] » f μ g) :\n    «expr =ᵐ[ ] » f (μ.restrict s) g :=\n  by\n  -- note that we cannot use `ae_restrict_iff` since we do not require measurability\n  refine' hfg.filter_mono _\n  rw [measure.ae_le_iff_absolutely_continuous]\n  exact measure.absolutely_continuous_of_le measure.restrict_le_self\n#align filter.eventually_eq.restrict Filter.EventuallyEq.restrict\n-/\n\n",
 "refl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure.absolutely_continuous -/\n#print refl /-\n@[refl]\nprotected theorem refl {m0 : MeasurableSpace α} (μ : Measure α) : measure.absolutely_continuous μ μ :=\n  rfl.absolutely_continuous\n#align refl refl\n-/\n\n",
 "quasi_measure_preserving_symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ᵐ » -/\ntheorem quasi_measure_preserving_symm (μ : measure α) (e : «expr ≃ᵐ » α β) :\n    QuasiMeasurePreserving e.symm (map e μ) μ :=\n  ⟨e.symm.measurable, by rw [measure.map_map, e.symm_comp_self, measure.map_id] <;> measurability⟩\n#align quasi_measure_preserving_symm quasi_measure_preserving_symm\n\n",
 "quasi_measure_preserving":
 "#print Measurable.quasiMeasurePreserving /-\nprotected theorem Measurable.quasiMeasurePreserving {m0 : MeasurableSpace α} (hf : Measurable f) (μ : Measure α) :\n    QuasiMeasurePreserving f μ (μ.map f) :=\n  ⟨hf, AbsolutelyContinuous.rfl⟩\n#align measurable.quasi_measure_preserving Measurable.quasiMeasurePreserving\n-/\n\n",
 "prob_le_one":
 "theorem prob_le_one [ProbabilityMeasure μ] : μ s ≤ 1 :=\n  (measure_mono <| Set.subset_univ _).trans_eq measure_univ\n#align prob_le_one prob_le_one\n\n",
 "prob_compl_eq_zero_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n@[simp]\ntheorem prob_compl_eq_zero_iff [ProbabilityMeasure μ] (hs : MeasurableSet s) : μ («expr ᶜ» s) = 0 ↔ μ s = 1 := by\n  simp only [prob_compl_eq_one_sub hs, tsub_eq_zero_iff_le, one_le_prob_iff]\n#align prob_compl_eq_zero_iff prob_compl_eq_zero_iff\n\n",
 "prob_compl_eq_one_sub":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/-- Note that this is not quite as useful as it looks because the measure takes values in `ℝ≥0∞`.\nThus the subtraction appearing is the truncated subtraction of `ℝ≥0∞`, rather than the\nbetter-behaved subtraction of `ℝ`. -/\ntheorem prob_compl_eq_one_sub [ProbabilityMeasure μ] (hs : MeasurableSet s) : μ («expr ᶜ» s) = 1 - μ s := by\n  simpa only [measure_univ] using measure_compl hs (measure_lt_top μ s).ne\n#align prob_compl_eq_one_sub prob_compl_eq_one_sub\n\n",
 "prob_compl_eq_one_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n@[simp]\ntheorem prob_compl_eq_one_iff [ProbabilityMeasure μ] (hs : MeasurableSet s) : μ («expr ᶜ» s) = 1 ↔ μ s = 0 := by\n  rwa [← prob_compl_eq_zero_iff hs.compl, compl_compl]\n#align prob_compl_eq_one_iff prob_compl_eq_one_iff\n\n",
 "prob_add_prob_compl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\ntheorem prob_add_prob_compl [ProbabilityMeasure μ] (h : MeasurableSet s) : μ s + μ («expr ᶜ» s) = 1 :=\n  (measure_add_measure_compl h).trans measure_univ\n#align prob_add_prob_compl prob_add_prob_compl\n\n",
 "preimage_spanning_sets_index_singleton":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem preimage_spanning_sets_index_singleton (μ : Measure α) [SigmaFinite μ] (n : ℕ) :\n    «expr ⁻¹' » (spanningSetsIndex μ) {n} = disjointed (spanningSets μ) n :=\n  preimage_find_eq_disjointed _ _ _\n#align preimage_spanning_sets_index_singleton preimage_spanning_sets_index_singleton\n\n",
 "preimage_null_of_map_null":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/-- Even if `s` is not measurable, `map f μ s = 0` implies that `μ (f ⁻¹' s) = 0`. -/\ntheorem preimage_null_of_map_null {f : α → β} (hf : AEMeasurable f μ) {s : Set β} (hs : μ.map f s = 0) :\n    μ («expr ⁻¹' » f s) = 0 :=\n  nonpos_iff_eq_zero.mp <| (le_map_apply hf s).trans_eq hs\n#align preimage_null_of_map_null preimage_null_of_map_null\n\n",
 "preimage_null":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem preimage_null (h : QuasiMeasurePreserving f μa μb) {s : Set β} (hs : μb s = 0) : μa («expr ⁻¹' » f s) = 0 :=\n  preimage_null_of_map_null h.ae_measurable (h.2 hs)\n#align preimage_null preimage_null\n\n",
 "preimage_mono_ae":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≤ᵐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≤ᵐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem preimage_mono_ae {s t : Set β} (hf : QuasiMeasurePreserving f μa μb) (h : «expr ≤ᵐ[ ] » s μb t) :\n    «expr ≤ᵐ[ ] » («expr ⁻¹' » f s) μa («expr ⁻¹' » f t) :=\n  eventually_map.mp <| Eventually.filter_mono (tendsto_ae_map hf.ae_measurable) (Eventually.filter_mono hf.ae_map_le h)\n#align preimage_mono_ae preimage_mono_ae\n\n",
 "preimage_iterate_ae_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\ntheorem preimage_iterate_ae_eq {s : Set α} {f : α → α} (hf : QuasiMeasurePreserving f μ μ) (k : ℕ)\n    (hs : «expr =ᵐ[ ] » («expr ⁻¹' » f s) μ s) : «expr =ᵐ[ ] » («expr ⁻¹' » («expr ^[ ]» f k) s) μ s :=\n  by\n  induction' k with k ih; · simp\n  rw [iterate_succ, preimage_comp]\n  exact eventually_eq.trans (hf.preimage_ae_eq ih) hs\n#align preimage_iterate_ae_eq preimage_iterate_ae_eq\n\n",
 "preimage_ae_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem preimage_ae_eq {s t : Set β} (hf : QuasiMeasurePreserving f μa μb) (h : «expr =ᵐ[ ] » s μb t) :\n    «expr =ᵐ[ ] » («expr ⁻¹' » f s) μa («expr ⁻¹' » f t) :=\n  EventuallyLE.antisymm (hf.preimage_mono_ae h.le) (hf.preimage_mono_ae h.symm.le)\n#align preimage_ae_eq preimage_ae_eq\n\n",
 "preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem ae_disjoint.preimage {ν : Measure β} {f : α → β} {s t : Set β} (ht : AEDisjoint ν s t)\n    (hf : QuasiMeasurePreserving f μ ν) : AEDisjoint μ («expr ⁻¹' » f s) («expr ⁻¹' » f t) :=\n  hf.preimage_null ht\n#align ae_disjoint.preimage ae_disjoint.preimage\n\n",
 "piecewise_ae_eq_restrict_compl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n#print piecewise_ae_eq_restrict_compl /-\ntheorem piecewise_ae_eq_restrict_compl (hs : MeasurableSet s) :\n    «expr =ᵐ[ ] » (piecewise s f g) (μ.restrict («expr ᶜ» s)) g :=\n  by\n  rw [ae_restrict_eq hs.compl]\n  exact (piecewise_eq_on_compl s f g).eventually_eq.filter_mono inf_le_right\n#align piecewise_ae_eq_restrict_compl piecewise_ae_eq_restrict_compl\n-/\n\n",
 "piecewise_ae_eq_restrict":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\n#print piecewise_ae_eq_restrict /-\ntheorem piecewise_ae_eq_restrict (hs : MeasurableSet s) : «expr =ᵐ[ ] » (piecewise s f g) (μ.restrict s) f :=\n  by\n  rw [ae_restrict_eq hs]\n  exact (piecewise_eq_on s f g).eventually_eq.filter_mono inf_le_right\n#align piecewise_ae_eq_restrict piecewise_ae_eq_restrict\n-/\n\n",
 "piecewise_ae_eq_of_ae_eq_set":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\n#print piecewise_ae_eq_of_ae_eq_set /-\ntheorem piecewise_ae_eq_of_ae_eq_set (hst : «expr =ᵐ[ ] » s μ t) :\n    «expr =ᵐ[ ] » (s.piecewise f g) μ (t.piecewise f g) :=\n  hst.mem_iff.mono fun x hx => by simp [piecewise, hx]\n#align piecewise_ae_eq_of_ae_eq_set piecewise_ae_eq_of_ae_eq_set\n-/\n\n",
 "pairwise_ae_disjoint_of_ae_disjoint_forall_ne_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:219:4: warning: unsupported binary notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (g «expr ≠ » (1 : G)) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:219:4: warning: unsupported binary notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr on » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[to_additive]\ntheorem pairwise_ae_disjoint_of_ae_disjoint_forall_ne_one {G α : Type _} [Group G] [MulAction G α] [MeasurableSpace α]\n    {μ : Measure α} {s : Set α} (h_ae_disjoint : ∀ (g) (_ : g ≠ (1 : G)), AEDisjoint μ («expr • » g s) s)\n    (h_qmp : ∀ g : G, QuasiMeasurePreserving ((«expr • » · ·) g : α → α) μ μ) :\n    Pairwise («expr on » (AEDisjoint μ) fun g : G => «expr • » g s) :=\n  by\n  intro g₁ g₂ hg\n  let g := g₂⁻¹ * g₁\n  replace hg : g ≠ 1\n  · rw [ne.def, inv_mul_eq_one]\n    exact hg.symm\n  have : «expr ⁻¹' » ((«expr • » · ·) g₂⁻¹) («expr • » g s ∩ s) = «expr • » g₁ s ∩ «expr • » g₂ s := by\n    rw [preimage_eq_iff_eq_image (MulAction.bijective g₂⁻¹), image_smul, smul_set_inter, smul_smul, smul_smul,\n      inv_mul_self, one_smul]\n  change μ («expr • » g₁ s ∩ «expr • » g₂ s) = 0\n  exact this ▸ (h_qmp g₂⁻¹).preimage_null (h_ae_disjoint g hg)\n#align pairwise_ae_disjoint_of_ae_disjoint_forall_ne_one pairwise_ae_disjoint_of_ae_disjoint_forall_ne_one\n\n",
 "out":
 "theorem sigma_finite.out (h : SigmaFinite μ) : Nonempty (μ.finite_spanning_sets_in univ) :=\n  h.1\n#align sigma_finite.out sigma_finite.out\n\n",
 "one_le_prob_iff":
 "@[simp]\ntheorem one_le_prob_iff [ProbabilityMeasure μ] : 1 ≤ μ s ↔ μ s = 1 :=\n  ⟨fun h => le_antisymm prob_le_one h, fun h => h ▸ le_refl _⟩\n#align one_le_prob_iff one_le_prob_iff\n\n",
 "of_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem sigma_finite.of_map (μ : Measure α) {f : α → β} (hf : AEMeasurable f μ) (h : SigmaFinite (μ.map f)) :\n    SigmaFinite μ :=\n  ⟨⟨⟨fun n => «expr ⁻¹' » f (spanningSets (μ.map f) n), fun n => trivial, fun n => by\n        simp only [← map_apply_of_ae_measurable hf, measurable_spanning_sets, measure_spanning_sets_lt_top], by\n        rw [← preimage_Union, Union_spanning_sets, preimage_univ]⟩⟩⟩\n#align sigma_finite.of_map sigma_finite.of_map\n\n",
 "null_of_locally_null":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/-- If a set has zero measure in a neighborhood of each of its points, then it has zero measure\nin a second-countable space. -/\ntheorem null_of_locally_null [TopologicalSpace α] [SecondCountableTopology α] (s : Set α)\n    (hs : ∀ x ∈ s, ∃ u ∈ nhds_within s x, μ u = 0) : μ s = 0 :=\n  μ.to_outer_measure.null_of_locally_null s hs\n#align null_of_locally_null null_of_locally_null\n\n",
 "null_measurable_set_subtype_coe":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem measurable_set.null_measurable_set_subtype_coe {t : Set s} (hs : NullMeasurableSet s μ) (ht : MeasurableSet t) :\n    NullMeasurableSet («expr '' » (coe : s → α) t) μ :=\n  by\n  rw [Subtype.instMeasurableSpace, comap_eq_generate_from] at ht\n  refine'\n    generate_from_induction (fun t : Set s => null_measurable_set («expr '' » coe t) μ)\n      { t : Set s | ∃ s' : Set α, MeasurableSet s' ∧ «expr ⁻¹' » coe s' = t } _ _ _ _ ht\n  · rintro t' ⟨s', hs', rfl⟩\n    rw [Subtype.image_preimage_coe]\n    exact hs'.null_measurable_set.inter hs\n  · simp only [image_empty, null_measurable_set_empty]\n  · intro t'\n    simp only [← range_diff_image Subtype.coe_injective, Subtype.range_coe_subtype, set_of_mem_eq]\n    exact hs.diff\n  · intro f\n    rw [image_Union]\n    exact null_measurable_set.Union\n#align measurable_set.null_measurable_set_subtype_coe measurable_set.null_measurable_set_subtype_coe\n\n",
 "not_is_finite_measure_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\ntheorem not_is_finite_measure_iff : ¬FiniteMeasure μ ↔ μ Set.univ = ennreal.top :=\n  by\n  refine' ⟨fun h => _, fun h => fun h' => h'.measure_univ_lt_top.ne h⟩\n  by_contra h'\n  exact h ⟨lt_top_iff_ne_top.mpr h'⟩\n#align not_is_finite_measure_iff not_is_finite_measure_iff\n\n",
 "nonpos_iff_eq_zero'":
 "theorem nonpos_iff_eq_zero' : μ ≤ 0 ↔ μ = 0 :=\n  μ.zero_le.le_iff_eq\n#align nonpos_iff_eq_zero' nonpos_iff_eq_zero'\n\n",
 "nonempty_inter_of_measure_lt_add'":
 "/-- If two sets `s` and `t` are included in a set `u`, and `μ s + μ t > μ u`,\nthen `s` intersects `t`. Version assuming that `s` is measurable. -/\ntheorem nonempty_inter_of_measure_lt_add' {m : MeasurableSpace α} (μ : Measure α) {s t u : Set α} (hs : MeasurableSet s)\n    (h's : s ⊆ u) (h't : t ⊆ u) (h : μ u < μ s + μ t) : (s ∩ t).nonempty :=\n  by\n  rw [add_comm] at h\n  rw [inter_comm]\n  exact nonempty_inter_of_measure_lt_add μ hs h't h's h\n#align nonempty_inter_of_measure_lt_add' nonempty_inter_of_measure_lt_add'\n\n",
 "nonempty_inter_of_measure_lt_add":
 "/-- If two sets `s` and `t` are included in a set `u`, and `μ s + μ t > μ u`,\nthen `s` intersects `t`. Version assuming that `t` is measurable. -/\ntheorem nonempty_inter_of_measure_lt_add {m : MeasurableSpace α} (μ : Measure α) {s t u : Set α} (ht : MeasurableSet t)\n    (h's : s ⊆ u) (h't : t ⊆ u) (h : μ u < μ s + μ t) : (s ∩ t).nonempty :=\n  by\n  rw [← Set.not_disjoint_iff_nonempty_inter]\n  contrapose! h\n  calc\n    μ s + μ t = μ (s ∪ t) := (measure_union h ht).symm\n    _ ≤ μ u := measure_mono (union_subset h's h't)\n    \n#align nonempty_inter_of_measure_lt_add nonempty_inter_of_measure_lt_add\n\n",
 "ne_zero":
 "theorem is_probability_measure.ne_zero (μ : Measure α) [ProbabilityMeasure μ] : μ ≠ 0 :=\n  mt measure_univ_eq_zero.2 <| by simp [measure_univ]\n#align is_probability_measure.ne_zero is_probability_measure.ne_zero\n\n",
 "monotone_spanning_sets":
 "theorem monotone_spanning_sets (μ : Measure α) [SigmaFinite μ] : Monotone (spanningSets μ) :=\n  monotone_accumulate\n#align monotone_spanning_sets monotone_spanning_sets\n\n",
 "mono_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure.absolutely_continuous -/\ntheorem mono_right (h : QuasiMeasurePreserving f μa μb) (ha : measure.absolutely_continuous μb μb') :\n    QuasiMeasurePreserving f μa μb' :=\n  ⟨h.1, h.2.trans ha⟩\n#align mono_right mono_right\n\n",
 "mono_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure.absolutely_continuous -/\ntheorem mono_left (h : QuasiMeasurePreserving f μa μb) (ha : measure.absolutely_continuous μa' μa) :\n    QuasiMeasurePreserving f μa' μb :=\n  ⟨h.1, (ha.map h.1).trans h.2⟩\n#align mono_left mono_left\n\n",
 "mono_ac":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure.absolutely_continuous -/\ntheorem null_measurable_set.mono_ac (h : NullMeasurableSet s μ) (hle : measure.absolutely_continuous ν μ) :\n    NullMeasurableSet s ν :=\n  h.preimage <| (QuasiMeasurePreserving.id μ).mono_left hle\n#align null_measurable_set.mono_ac null_measurable_set.mono_ac\n\n",
 "mono":
 "@[mono]\nprotected theorem mono (hf : f ≤ g) (hμ : μ ≤ ν) : ν.finite_at_filter g → μ.finite_at_filter f := fun h =>\n  (h.filter_mono hf).measure_mono hμ\n#align mono mono\n\n",
 "mk":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure.absolutely_continuous -/\ntheorem mk (h : ∀ ⦃s : Set α⦄, MeasurableSet s → ν s = 0 → μ s = 0) : measure.absolutely_continuous μ ν :=\n  by\n  intro s hs\n  rcases exists_measurable_superset_of_null hs with ⟨t, h1t, h2t, h3t⟩\n  exact measure_mono_null h1t (h h2t h3t)\n#align mk mk\n\n",
 "mem_spanning_sets_of_index_le":
 "theorem mem_spanning_sets_of_index_le (μ : Measure α) [SigmaFinite μ] (x : α) {n : ℕ} (hn : spanningSetsIndex μ x ≤ n) :\n    x ∈ spanningSets μ n :=\n  monotone_spanningSets μ hn (mem_spanningSetsIndex μ x)\n#align mem_spanning_sets_of_index_le mem_spanning_sets_of_index_le\n\n",
 "mem_spanning_sets_index":
 "theorem mem_spanning_sets_index (μ : Measure α) [SigmaFinite μ] (x : α) : x ∈ spanningSets μ (spanningSetsIndex μ x) :=\n  disjointed_subset _ _ (mem_disjointed_spanningSetsIndex μ x)\n#align mem_spanning_sets_index mem_spanning_sets_index\n\n",
 "mem_map_restrict_ae_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem mem_map_restrict_ae_iff {β} {s : Set α} {t : Set β} {f : α → β} (hs : MeasurableSet s) :\n    t ∈ Filter.map f (μ.restrict s).ae ↔ μ («expr ᶜ» («expr ⁻¹' » f t) ∩ s) = 0 := by\n  rw [mem_map, mem_ae_iff, measure.restrict_apply' hs]\n#align mem_map_restrict_ae_iff mem_map_restrict_ae_iff\n\n",
 "mem_map_indicator_ae_iff_of_zero_nmem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n#print mem_map_indicator_ae_iff_of_zero_nmem /-\ntheorem mem_map_indicator_ae_iff_of_zero_nmem [Zero β] {t : Set β} (ht : (0 : β) ∉ t) :\n    t ∈ Filter.map (s.indicator f) μ.ae ↔ μ («expr ᶜ» («expr ⁻¹' » f t) ∪ «expr ᶜ» s) = 0 :=\n  by\n  rw [mem_map, mem_ae_iff, Set.indicator_preimage, Set.ite, Set.compl_union, Set.compl_inter]\n  change\n    μ ((«expr ᶜ» («expr ⁻¹' » f t) ∪ «expr ᶜ» s) ∩ «expr ᶜ» («expr ⁻¹' » (fun x => (0 : β)) t \\ s)) = 0 ↔\n      μ («expr ᶜ» («expr ⁻¹' » f t) ∪ «expr ᶜ» s) = 0\n  simp only [ht, if_false, Set.compl_empty, Set.empty_diff, Set.inter_univ, Set.preimage_const]\n#align mem_map_indicator_ae_iff_of_zero_nmem mem_map_indicator_ae_iff_of_zero_nmem\n-/\n\n",
 "mem_map_indicator_ae_iff_mem_map_restrict_ae_of_zero_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n#print mem_map_indicator_ae_iff_mem_map_restrict_ae_of_zero_mem /-\ntheorem mem_map_indicator_ae_iff_mem_map_restrict_ae_of_zero_mem [Zero β] {t : Set β} (ht : (0 : β) ∈ t)\n    (hs : MeasurableSet s) : t ∈ Filter.map (s.indicator f) μ.ae ↔ t ∈ Filter.map f (μ.restrict s).ae :=\n  by\n  simp_rw [mem_map, mem_ae_iff]\n  rw [measure.restrict_apply' hs, Set.indicator_preimage, Set.ite]\n  simp_rw [Set.compl_union, Set.compl_inter]\n  change\n    μ ((«expr ᶜ» («expr ⁻¹' » f t) ∪ «expr ᶜ» s) ∩ «expr ᶜ» («expr ⁻¹' » (fun x => (0 : β)) t \\ s)) = 0 ↔\n      μ («expr ᶜ» («expr ⁻¹' » f t) ∩ s) = 0\n  simp only [ht, ← Set.compl_eq_univ_diff, compl_compl, Set.compl_union, if_true, Set.preimage_const]\n  simp_rw [Set.union_inter_distrib_right, Set.compl_inter_self s, Set.union_empty]\n#align mem_map_indicator_ae_iff_mem_map_restrict_ae_of_zero_mem mem_map_indicator_ae_iff_mem_map_restrict_ae_of_zero_mem\n-/\n\n",
 "mem_disjointed_spanning_sets_index":
 "theorem mem_disjointed_spanning_sets_index (μ : Measure α) [SigmaFinite μ] (x : α) :\n    x ∈ disjointed (spanningSets μ) (spanningSetsIndex μ x) :=\n  (spanningSetsIndex_eq_iff μ).1 rfl\n#align mem_disjointed_spanning_sets_index mem_disjointed_spanning_sets_index\n\n",
 "mem_cofinite":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\ntheorem mem_cofinite : s ∈ μ.cofinite ↔ μ («expr ᶜ» s) < ennreal.top :=\n  iff.rfl\n#align mem_cofinite mem_cofinite\n\n",
 "mem_ae_of_mem_ae_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem mem_ae_of_mem_ae_map {f : α → β} (hf : AEMeasurable f μ) {s : Set β} (hs : s ∈ (μ.map f).ae) :\n    «expr ⁻¹' » f s ∈ μ.ae :=\n  (tendsto_ae_map hf).eventually hs\n#align mem_ae_of_mem_ae_map mem_ae_of_mem_ae_map\n\n",
 "mem_ae_map_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem mem_ae_map_iff {f : α → β} (hf : AEMeasurable f μ) {s : Set β} (hs : MeasurableSet s) :\n    s ∈ (μ.map f).ae ↔ «expr ⁻¹' » f s ∈ μ.ae := by\n  simp only [mem_ae_iff, map_apply_of_ae_measurable hf hs.compl, preimage_compl]\n#align mem_ae_map_iff mem_ae_map_iff\n\n",
 "mem_ae_dirac_iff":
 "theorem mem_ae_dirac_iff {a : α} (hs : MeasurableSet s) : s ∈ (dirac a).ae ↔ a ∈ s := by\n  by_cases a ∈ s <;> simp [mem_ae_iff, dirac_apply', hs.compl, indicator_apply, *]\n#align mem_ae_dirac_iff mem_ae_dirac_iff\n\n",
 "measure_zero_of_nhds_within":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\ntheorem measure_zero_of_nhds_within (hs : IsCompact s) : (∀ a ∈ s, ∃ t ∈ nhds_within s a, μ t = 0) → μ s = 0 := by\n  simpa only [← compl_mem_ae_iff] using hs.compl_mem_sets_of_nhds_within\n#align measure_zero_of_nhds_within measure_zero_of_nhds_within\n\n",
 "measure_zero":
 "#print Finset.measure_zero /-\ntheorem Finset.measure_zero {α : Type _} {m : MeasurableSpace α} (s : Finset α) (μ : Measure α) [NoAtoms μ] : μ s = 0 :=\n  s.finite_to_set.measure_zero μ\n#align finset.measure_zero Finset.measure_zero\n-/\n\n",
 "measure_univ_pos":
 "@[simp]\ntheorem measure_univ_pos : 0 < μ univ ↔ μ ≠ 0 :=\n  pos_iff_ne_zero.trans measure_univ_ne_zero\n#align measure_univ_pos measure_univ_pos\n\n",
 "measure_univ_nnreal_zero":
 "@[simp]\ntheorem measure_univ_nnreal_zero : measureUnivNNReal (0 : Measure α) = 0 :=\n  rfl\n#align measure_univ_nnreal_zero measure_univ_nnreal_zero\n\n",
 "measure_univ_nnreal_pos":
 "theorem measure_univ_nnreal_pos [FiniteMeasure μ] (hμ : μ ≠ 0) : 0 < measureUnivNNReal μ :=\n  by\n  contrapose! hμ\n  simpa [measure_univ_nnreal_eq_zero, le_zero_iff] using hμ\n#align measure_univ_nnreal_pos measure_univ_nnreal_pos\n\n",
 "measure_univ_nnreal_eq_zero":
 "@[simp]\ntheorem measure_univ_nnreal_eq_zero [FiniteMeasure μ] : measureUnivNNReal μ = 0 ↔ μ = 0 :=\n  by\n  rw [← MeasureTheory.Measure.measure_univ_eq_zero, ← coe_measure_univ_nnreal]\n  norm_cast\n#align measure_univ_nnreal_eq_zero measure_univ_nnreal_eq_zero\n\n",
 "measure_univ_ne_zero":
 "theorem measure_univ_ne_zero : μ univ ≠ 0 ↔ μ ≠ 0 :=\n  measure_univ_eq_zero.not\n#align measure_univ_ne_zero measure_univ_ne_zero\n\n",
 "measure_univ_eq_zero":
 "@[simp]\ntheorem measure_univ_eq_zero : μ univ = 0 ↔ μ = 0 :=\n  ⟨fun h => bot_unique fun s hs => trans_rel_left (· ≤ ·) (measure_mono (subset_univ s)) h, fun h => h.symm ▸ rfl⟩\n#align measure_univ_eq_zero measure_univ_eq_zero\n\n",
 "measure_union_to_measurable":
 "@[simp]\ntheorem measure_union_to_measurable : μ (s ∪ toMeasurable μ t) = μ (s ∪ t) :=\n  Eq.symm <| measure_union_congr_of_subset Subset.rfl le_rfl (subset_toMeasurable _ _) (measure_toMeasurable _).le\n#align measure_union_to_measurable measure_union_to_measurable\n\n",
 "measure_union_congr_of_subset":
 "theorem measure_union_congr_of_subset {t₁ t₂ : Set α} (hs : s₁ ⊆ s₂) (hsμ : μ s₂ ≤ μ s₁) (ht : t₁ ⊆ t₂)\n    (htμ : μ t₂ ≤ μ t₁) : μ (s₁ ∪ t₁) = μ (s₂ ∪ t₂) :=\n  by\n  rw [union_eq_Union, union_eq_Union]\n  exact measure_Union_congr_of_subset (Bool.forall_bool.2 ⟨ht, hs⟩) (Bool.forall_bool.2 ⟨htμ, hsμ⟩)\n#align measure_union_congr_of_subset measure_union_congr_of_subset\n\n",
 "measure_union_add_inter'":
 "theorem measure_union_add_inter' (hs : MeasurableSet s) (t : Set α) : μ (s ∪ t) + μ (s ∩ t) = μ s + μ t := by\n  rw [union_comm, inter_comm, measure_union_add_inter t hs, add_comm]\n#align measure_union_add_inter' measure_union_add_inter'\n\n",
 "measure_union_add_inter":
 "theorem measure_union_add_inter (s : Set α) (ht : MeasurableSet t) : μ (s ∪ t) + μ (s ∩ t) = μ s + μ t :=\n  by\n  rw [← measure_inter_add_diff (s ∪ t) ht, Set.union_inter_cancel_right, union_diff_right, ←\n    measure_inter_add_diff s ht]\n  ac_rfl\n#align measure_union_add_inter measure_union_add_inter\n\n",
 "measure_union'":
 "theorem measure_union' (hd : Disjoint s₁ s₂) (h : MeasurableSet s₁) : μ (s₁ ∪ s₂) = μ s₁ + μ s₂ :=\n  measure_union₀' h.null_measurable_set hd.ae_disjoint\n#align measure_union' measure_union'\n\n",
 "measure_union":
 "theorem measure_union (hd : Disjoint s₁ s₂) (h : MeasurableSet s₂) : μ (s₁ ∪ s₂) = μ s₁ + μ s₂ :=\n  measure_union₀ h.null_measurable_set hd.ae_disjoint\n#align measure_union measure_union\n\n",
 "measure_trim_to_measurable_eq_zero":
 "theorem measure_trim_to_measurable_eq_zero {hm : m ≤ m0} (hs : μ.trim hm s = 0) :\n    μ (@toMeasurable α m (μ.trim hm) s) = 0 :=\n  measure_eq_zero_of_trim_eq_zero hm (by rwa [measure_to_measurable])\n#align measure_trim_to_measurable_eq_zero measure_trim_to_measurable_eq_zero\n\n",
 "measure_to_measurable_union":
 "@[simp]\ntheorem measure_to_measurable_union : μ (toMeasurable μ s ∪ t) = μ (s ∪ t) :=\n  Eq.symm <| measure_union_congr_of_subset (subset_toMeasurable _ _) (measure_toMeasurable _).le Subset.rfl le_rfl\n#align measure_to_measurable_union measure_to_measurable_union\n\n",
 "measure_to_measurable_inter_of_sigma_finite":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/-- The measurable superset `to_measurable μ t` of `t` (which has the same measure as `t`)\nsatisfies, for any measurable set `s`, the equality `μ (to_measurable μ t ∩ s) = μ (t ∩ s)`.\nThis only holds when `μ` is σ-finite. For a version without this assumption (but requiring\nthat `t` has finite measure), see `measure_to_measurable_inter`. -/\ntheorem measure_to_measurable_inter_of_sigma_finite [SigmaFinite μ] {s : Set α} (hs : MeasurableSet s) (t : Set α) :\n    μ (toMeasurable μ t ∩ s) = μ (t ∩ s) :=\n  by\n  have :\n    t ⊆\n      «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n        (spanning_sets μ n) :=\n    by\n    rw [Union_spanning_sets]\n    exact subset_univ _\n  apply measure_to_measurable_inter_of_cover hs this fun n => ne_of_lt _\n  calc\n    μ (t ∩ spanning_sets μ n) ≤ μ (spanning_sets μ n) := measure_mono (inter_subset_right _ _)\n    _ < ennreal.top := measure_spanning_sets_lt_top μ n\n    \n#align measure_to_measurable_inter_of_sigma_finite measure_to_measurable_inter_of_sigma_finite\n\n",
 "measure_to_measurable_inter_of_cover":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (t' «expr ⊇ » t) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊇ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/-- If a set `t` is covered by a countable family of finite measure sets, then its measurable\nsuperset `to_measurable μ t` (which has the same measure as `t`) satisfies,\nfor any measurable set `s`, the equality `μ (to_measurable μ t ∩ s) = μ (t ∩ s)`. -/\ntheorem measure_to_measurable_inter_of_cover {s : Set α} (hs : MeasurableSet s) {t : Set α} {v : ℕ → Set α}\n    (hv : t ⊆ «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (v n))\n    (h'v : ∀ n, μ (t ∩ v n) ≠ ennreal.top) : μ (toMeasurable μ t ∩ s) = μ (t ∩ s) :=\n  by\n  -- we show that there is a measurable superset of `t` satisfying the conclusion for any\n  -- measurable set `s`. It is built on each member of a spanning family using `to_measurable`\n  -- (which is well behaved for finite measure sets thanks to `measure_to_measurable_inter`), and\n  -- the desired property passes to the union.\n  have A : ∃ (t' : _)(_ : «expr ⊇ » t' t), MeasurableSet t' ∧ ∀ u, MeasurableSet u → μ (t' ∩ u) = μ (t ∩ u) :=\n    by\n    let w n := to_measurable μ (t ∩ v n)\n    have hw : ∀ n, μ (w n) < ennreal.top := by\n      intro n\n      simp_rw [w, measure_to_measurable]\n      exact (h'v n).lt_top\n    set t' :=\n      «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n        (to_measurable μ (t ∩ disjointed w n)) with\n      ht'\n    have tt' : t ⊆ t' :=\n      calc\n        t ⊆\n            «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n              (t ∩ disjointed w n) :=\n          by\n          rw [← inter_Union, unionᵢ_disjointed, inter_Union]\n          intro x hx\n          rcases mem_Union.1 (hv hx) with ⟨n, hn⟩\n          refine' mem_Union.2 ⟨n, _⟩\n          have : x ∈ t ∩ v n := ⟨hx, hn⟩\n          exact ⟨hx, subset_to_measurable μ _ this⟩\n        _ ⊆\n            «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n              (to_measurable μ (t ∩ disjointed w n)) :=\n          Union_mono fun n => subset_to_measurable _ _\n        \n    refine' ⟨t', tt', MeasurableSet.unionᵢ fun n => measurable_set_to_measurable μ _, fun u hu => _⟩\n    apply le_antisymm _ (measure_mono (inter_subset_inter tt' subset.rfl))\n    calc\n      μ (t' ∩ u) ≤\n          «expr∑' , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , »\"\n            (μ (to_measurable μ (t ∩ disjointed w n) ∩ u)) :=\n        by\n        rw [ht', Union_inter]\n        exact measure_Union_le _\n      _ =\n          «expr∑' , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , »\"\n            (μ (t ∩ disjointed w n ∩ u)) :=\n        by\n        congr 1\n        ext1 n\n        apply measure_to_measurable_inter hu\n        apply ne_of_lt\n        calc\n          μ (t ∩ disjointed w n) ≤ μ (t ∩ w n) := measure_mono (inter_subset_inter_right _ (disjointed_le w n))\n          _ ≤ μ (w n) := (measure_mono (inter_subset_right _ _))\n          _ < ennreal.top := hw n\n          \n      _ =\n          «expr∑' , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , »\"\n            (μ.restrict (t ∩ u) (disjointed w n)) :=\n        by\n        congr 1\n        ext1 n\n        rw [restrict_apply, inter_comm t _, inter_assoc]\n        apply MeasurableSet.disjointed fun n => _\n        exact measurable_set_to_measurable _ _\n      _ =\n          μ.restrict (t ∩ u)\n            («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n              (disjointed w n)) :=\n        by\n        rw [measure_Union]\n        · exact disjoint_disjointed _\n        · intro i\n          apply MeasurableSet.disjointed fun n => _\n          exact measurable_set_to_measurable _ _\n      _ ≤ μ.restrict (t ∩ u) univ := (measure_mono (subset_univ _))\n      _ = μ (t ∩ u) := by rw [restrict_apply MeasurableSet.univ, univ_inter]\n      \n  -- thanks to the definition of `to_measurable`, the previous property will also be shared\n  -- by `to_measurable μ t`, which is enough to conclude the proof.\n  rw [to_measurable]\n  split_ifs with ht\n  · apply measure_congr\n    exact ae_eq_set_inter ht.some_spec.snd.2 (ae_eq_refl _)\n  · exact A.some_spec.snd.2 s hs\n#align measure_to_measurable_inter_of_cover measure_to_measurable_inter_of_cover\n\n",
 "measure_to_measurable_inter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/-- The measurable superset `to_measurable μ t` of `t` (which has the same measure as `t`)\nsatisfies, for any measurable set `s`, the equality `μ (to_measurable μ t ∩ s) = μ (u ∩ s)`.\nHere, we require that the measure of `t` is finite. The conclusion holds without this assumption\nwhen the measure is sigma_finite, see `measure_to_measurable_inter_of_sigma_finite`. -/\ntheorem measure_to_measurable_inter {s t : Set α} (hs : MeasurableSet s) (ht : μ t ≠ ennreal.top) :\n    μ (toMeasurable μ t ∩ s) = μ (t ∩ s) :=\n  (measure_inter_eq_of_measure_eq hs (measure_toMeasurable t).symm (subset_toMeasurable μ t) ht).symm\n#align measure_to_measurable_inter measure_to_measurable_inter\n\n",
 "measure_to_measurable_add_inter_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\ntheorem measure_to_measurable_add_inter_right {s t : Set α} (hs : MeasurableSet s) (ht : (μ + ν) t ≠ ennreal.top) :\n    ν (toMeasurable (μ + ν) t ∩ s) = ν (t ∩ s) :=\n  by\n  rw [add_comm] at ht⊢\n  exact measure_to_measurable_add_inter_left hs ht\n#align measure_to_measurable_add_inter_right measure_to_measurable_add_inter_right\n\n",
 "measure_to_measurable_add_inter_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\ntheorem measure_to_measurable_add_inter_left {s t : Set α} (hs : MeasurableSet s) (ht : (μ + ν) t ≠ ennreal.top) :\n    μ (toMeasurable (μ + ν) t ∩ s) = μ (t ∩ s) :=\n  by\n  refine' (measure_inter_eq_of_measure_eq hs _ (subset_to_measurable _ _) _).symm\n  · refine' measure_eq_left_of_subset_of_measure_add_eq _ (subset_to_measurable _ _) (measure_to_measurable t).symm\n    rwa [measure_to_measurable t]\n  · simp only [not_or, ENNReal.add_eq_top, Pi.add_apply, ne.def, coe_add] at ht\n    exact ht.1\n#align measure_to_measurable_add_inter_left measure_to_measurable_add_inter_left\n\n",
 "measure_subtype_coe_le_comap":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem measure_subtype_coe_le_comap (hs : NullMeasurableSet s μ) (t : Set s) :\n    μ («expr '' » (coe : s → α) t) ≤ μ.comap Subtype.val t :=\n  le_comap_apply _ _ Subtype.coe_injective (fun t => MeasurableSet.nullMeasurableSet_subtype_coe hs) _\n#align measure_subtype_coe_le_comap measure_subtype_coe_le_comap\n\n",
 "measure_subtype_coe_eq_zero_of_comap_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem measure_subtype_coe_eq_zero_of_comap_eq_zero (hs : NullMeasurableSet s μ) {t : Set s}\n    (ht : μ.comap Subtype.val t = 0) : μ («expr '' » (coe : s → α) t) = 0 :=\n  eq_bot_iff.mpr <| (measure_subtype_coe_le_comap hs t).trans ht.le\n#align measure_subtype_coe_eq_zero_of_comap_eq_zero measure_subtype_coe_eq_zero_of_comap_eq_zero\n\n",
 "measure_spanning_sets_lt_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\ntheorem measure_spanning_sets_lt_top (μ : Measure α) [SigmaFinite μ] (i : ℕ) : μ (spanningSets μ i) < ennreal.top :=\n  measure_bunionᵢ_lt_top (finite_le_nat i) fun j _ => (μ.to_finite_spanning_sets_in.finite j).ne\n#align measure_spanning_sets_lt_top measure_spanning_sets_lt_top\n\n",
 "measure_set_of_frequently_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , » -/\n/-- A version of the **Borel-Cantelli lemma**: if `pᵢ` is a sequence of predicates such that\n`∑ μ {x | pᵢ x}` is finite, then the measure of `x` such that `pᵢ x` holds frequently as `i → ∞` (or\nequivalently, `pᵢ x` holds for infinitely many `i`) is equal to zero. -/\ntheorem measure_set_of_frequently_eq_zero {p : ℕ → α → Prop}\n    (hp :\n      «expr∑' , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , »\"\n          (μ { x | p i x }) ≠\n        ennreal.top) :\n    μ\n        { x |\n          «expr∃ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , »\" atTop\n            (p n x) } =\n      0 :=\n  by\n  simpa only [limsup_eq_infi_supr_of_nat, frequently_at_top, set_of_forall, set_of_exists] using\n    measure_limsup_eq_zero hp\n#align measure_set_of_frequently_eq_zero measure_set_of_frequently_eq_zero\n\n",
 "measure_sUnion₀":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , » -/\ntheorem measure_sUnion₀ {S : Set (Set α)} (hs : S.countable) (hd : S.pairwise (AEDisjoint μ))\n    (h : ∀ s ∈ S, NullMeasurableSet s μ) :\n    μ (⋃₀ S) =\n      «expr∑' , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , »\" (μ s) :=\n  by rw [sUnion_eq_bUnion, measure_bUnion₀ hs hd h]\n#align measure_sUnion₀ measure_sUnion₀\n\n",
 "measure_sUnion":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , » -/\ntheorem measure_sUnion {S : Set (Set α)} (hs : S.countable) (hd : S.pairwise Disjoint) (h : ∀ s ∈ S, MeasurableSet s) :\n    μ (⋃₀ S) =\n      «expr∑' , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , »\" (μ s) :=\n  by rw [sUnion_eq_bUnion, measure_bUnion hs hd h]\n#align measure_sUnion measure_sUnion\n\n",
 "measure_ne_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\ntheorem measure_ne_top (μ : Measure α) [FiniteMeasure μ] (s : Set α) : μ s ≠ ennreal.top :=\n  ne_of_lt (measure_lt_top μ s)\n#align measure_ne_top measure_ne_top\n\n",
 "measure_mono":
 "protected theorem measure_mono (h : μ ≤ ν) : ν.finite_at_filter f → μ.finite_at_filter f := fun ⟨s, hs, hν⟩ =>\n  ⟨s, hs, (Measure.le_iff'.1 h s).trans_lt hν⟩\n#align measure_mono measure_mono\n\n",
 "measure_lt_top_of_nhds_within":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\ntheorem measure_lt_top_of_nhds_within (h : IsCompact s) (hμ : ∀ x ∈ s, μ.finite_at_filter (nhds_within s x)) :\n    μ s < ennreal.top :=\n  IsCompact.induction_on h (by simp) (fun s t hst ht => (measure_mono hst).trans_lt ht)\n    (fun s t hs ht => (measure_union_le s t).trans_lt (ENNReal.add_lt_top.2 ⟨hs, ht⟩)) hμ\n#align measure_lt_top_of_nhds_within measure_lt_top_of_nhds_within\n\n",
 "measure_lt_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n#print Metric.Bounded.measure_lt_top /-\n/-- A bounded subset has finite measure for a measure which is finite on compact sets, in a\nproper space. -/\ntheorem Metric.Bounded.measure_lt_top [PseudoMetricSpace α] [ProperSpace α] {μ : Measure α} [FiniteMeasureOnCompacts μ]\n    ⦃s : Set α⦄ (hs : Metric.Bounded s) : μ s < ennreal.top :=\n  calc\n    μ s ≤ μ (closure s) := measure_mono subset_closure\n    _ < ennreal.top := (Metric.isCompact_of_isClosed_bounded isClosed_closure hs.closure).measure_lt_top\n    \n#align metric.bounded.measure_lt_top Metric.Bounded.measure_lt_top\n-/\n\n",
 "measure_limsup_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/-- One direction of the **Borel-Cantelli lemma**: if (sᵢ) is a sequence of sets such\nthat `∑ μ sᵢ` is finite, then the limit superior of the `sᵢ` is a null set. -/\ntheorem measure_limsup_eq_zero {s : ℕ → Set α}\n    (hs :\n      «expr∑' , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , »\" (μ (s i)) ≠\n        ennreal.top) :\n    μ (limsup s atTop) = 0 :=\n  by\n  -- First we replace the sequence `sₙ` with a sequence of measurable sets `tₙ ⊇ sₙ` of the same\n  -- measure.\n  set t : ℕ → Set α := fun n => to_measurable μ (s n)\n  have ht :\n    «expr∑' , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , »\" (μ (t i)) ≠\n      ennreal.top :=\n    by simpa only [t, measure_to_measurable] using hs\n  suffices μ (limsup t at_top) = 0\n    by\n    have A : s ≤ t := fun n => subset_to_measurable μ (s n)\n    -- TODO default args fail\n    exact\n      measure_mono_null\n        (limsup_le_limsup (eventually_of_forall (pi.le_def.mp A)) is_cobounded_le_of_bot is_bounded_le_of_top) this\n  -- Next we unfold `limsup` for sets and replace equality with an inequality\n  simp only [limsup_eq_infi_supr_of_nat', Set.infᵢ_eq_interᵢ, Set.supᵢ_eq_unionᵢ, ← nonpos_iff_eq_zero]\n  -- Finally, we estimate `μ (⋃ i, t (i + n))` by `∑ i', μ (t (i + n))`\n  refine'\n    le_of_tendsto_of_tendsto'\n      (tendsto_measure_Inter (fun i => MeasurableSet.unionᵢ fun b => measurable_set_to_measurable _ _) _\n        ⟨0, ne_top_of_le_ne_top ht (measure_Union_le t)⟩)\n      (ENNReal.tendsto_sum_nat_add (μ ∘ t) ht) fun n => measure_Union_le _\n  intro n m hnm x\n  simp only [Set.mem_unionᵢ]\n  exact fun ⟨i, hi⟩ => ⟨i + (m - n), by simpa only [add_assoc, tsub_add_cancel_of_le hnm] using hi⟩\n#align measure_limsup_eq_zero measure_limsup_eq_zero\n\n",
 "measure_liminf_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:69:18: unsupported non-interactive tactic filter.is_bounded_default -/\n/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:69:18: unsupported non-interactive tactic filter.is_bounded_default -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem measure_liminf_eq_zero {s : ℕ → Set α}\n    (h :\n      «expr∑' , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , »\" (μ (s i)) ≠\n        «expr⊤») :\n    μ (liminf s atTop) = 0 := by\n  rw [← le_zero_iff]\n  have : liminf s at_top ≤ limsup s at_top :=\n    liminf_le_limsup\n      (by\n        run_tac\n          is_bounded_default)\n      (by\n        run_tac\n          is_bounded_default)\n  exact (μ.mono this).trans (by simp [measure_limsup_eq_zero h])\n#align measure_liminf_eq_zero measure_liminf_eq_zero\n\n",
 "measure_le_Inf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\nprivate theorem measure_le_Inf (h : ∀ μ' ∈ m, μ ≤ μ') : μ ≤ infₛ m :=\n  have : μ.to_outer_measure ≤ infₛ («expr '' » to_outer_measure m) :=\n    le_infₛ <| ball_image_of_ball fun μ hμ => toOuterMeasure_le.2 <| h _ hμ\n  fun s hs => by rw [infₛ_apply hs, ← to_outer_measure_apply] <;> exact this s\n#align measure_le_Inf measure_le_Inf\n\n",
 "measure_inter_eq_zero_of_restrict":
 "theorem measure_inter_eq_zero_of_restrict (h : μ.restrict s t = 0) : μ (t ∩ s) = 0 :=\n  nonpos_iff_eq_zero.1 (h ▸ le_restrict_apply _ _)\n#align measure_inter_eq_zero_of_restrict measure_inter_eq_zero_of_restrict\n\n",
 "measure_inter_eq_of_measure_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/-- If `u` is a superset of `t` with the same (finite) measure (both sets possibly non-measurable),\nthen for any measurable set `s` one also has `μ (t ∩ s) = μ (u ∩ s)`. -/\ntheorem measure_inter_eq_of_measure_eq {s t u : Set α} (hs : MeasurableSet s) (h : μ t = μ u) (htu : t ⊆ u)\n    (ht_ne_top : μ t ≠ ennreal.top) : μ (t ∩ s) = μ (u ∩ s) :=\n  by\n  rw [h] at ht_ne_top\n  refine' le_antisymm (measure_mono (inter_subset_inter_left _ htu)) _\n  have A : μ (u ∩ s) + μ (u \\ s) ≤ μ (t ∩ s) + μ (u \\ s) :=\n    calc\n      μ (u ∩ s) + μ (u \\ s) = μ u := measure_inter_add_diff _ hs\n      _ = μ t := h.symm\n      _ = μ (t ∩ s) + μ (t \\ s) := (measure_inter_add_diff _ hs).symm\n      _ ≤ μ (t ∩ s) + μ (u \\ s) := add_le_add le_rfl (measure_mono (diff_subset_diff htu subset.rfl))\n      \n  have B : μ (u \\ s) ≠ ennreal.top := (lt_of_le_of_lt (measure_mono (diff_subset _ _)) ht_ne_top.lt_top).ne\n  exact ENNReal.le_of_add_le_add_right B A\n#align measure_inter_eq_of_measure_eq measure_inter_eq_of_measure_eq\n\n",
 "measure_inter_add_diff":
 "theorem measure_inter_add_diff (s : Set α) (ht : MeasurableSet t) : μ (s ∩ t) + μ (s \\ t) = μ s :=\n  measure_inter_add_diff₀ _ ht.null_measurable_set\n#align measure_inter_add_diff measure_inter_add_diff\n\n",
 "measure_image_eq_zero_of_comap_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem measure_image_eq_zero_of_comap_eq_zero {β} [MeasurableSpace α] {mβ : MeasurableSpace β} (f : α → β)\n    (μ : Measure β) (hfi : injective f) (hf : ∀ s, MeasurableSet s → NullMeasurableSet («expr '' » f s) μ) {s : Set α}\n    (hs : comap f μ s = 0) : μ («expr '' » f s) = 0 :=\n  le_antisymm ((le_comap_apply f μ hfi hf s).trans hs.le) (zero_le _)\n#align measure_image_eq_zero_of_comap_eq_zero measure_image_eq_zero_of_comap_eq_zero\n\n",
 "measure_if":
 "theorem measure_if {x : β} {t : Set β} {s : Set α} : μ (if x ∈ t then s else ∅) = indicator t (fun _ => μ s) x := by\n  split_ifs <;> simp [h]\n#align measure_if measure_if\n\n",
 "measure_eq_zero_of_trim_eq_zero":
 "theorem measure_eq_zero_of_trim_eq_zero (hm : m ≤ m0) (h : μ.trim hm s = 0) : μ s = 0 :=\n  le_antisymm ((le_trim hm).trans (le_of_eq h)) (zero_le _)\n#align measure_eq_zero_of_trim_eq_zero measure_eq_zero_of_trim_eq_zero\n\n",
 "measure_eq_right_of_subset_of_measure_add_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\ntheorem measure_eq_right_of_subset_of_measure_add_eq {s t : Set α} (h : (μ + ν) t ≠ ennreal.top) (h' : s ⊆ t)\n    (h'' : (μ + ν) s = (μ + ν) t) : ν s = ν t :=\n  by\n  rw [add_comm] at h'' h\n  exact measure_eq_left_of_subset_of_measure_add_eq h h' h''\n#align measure_eq_right_of_subset_of_measure_add_eq measure_eq_right_of_subset_of_measure_add_eq\n\n",
 "measure_eq_measure_smaller_of_between_null_diff":
 "theorem measure_eq_measure_smaller_of_between_null_diff {s₁ s₂ s₃ : Set α} (h12 : s₁ ⊆ s₂) (h23 : s₂ ⊆ s₃)\n    (h_nulldiff : μ (s₃ \\ s₁) = 0) : μ s₁ = μ s₂ :=\n  (measure_eq_measure_of_between_null_diff h12 h23 h_nulldiff).1\n#align measure_eq_measure_smaller_of_between_null_diff measure_eq_measure_smaller_of_between_null_diff\n\n",
 "measure_eq_measure_of_null_diff":
 "theorem measure_eq_measure_of_null_diff {s t : Set α} (hst : s ⊆ t) (h_nulldiff : μ (t \\ s) = 0) : μ s = μ t :=\n  measure_congr (hst.eventually_le.antisymm <| ae_le_set.mpr h_nulldiff)\n#align measure_eq_measure_of_null_diff measure_eq_measure_of_null_diff\n\n",
 "measure_eq_measure_of_between_null_diff":
 "theorem measure_eq_measure_of_between_null_diff {s₁ s₂ s₃ : Set α} (h12 : s₁ ⊆ s₂) (h23 : s₂ ⊆ s₃)\n    (h_nulldiff : μ (s₃ \\ s₁) = 0) : μ s₁ = μ s₂ ∧ μ s₂ = μ s₃ :=\n  by\n  have le12 : μ s₁ ≤ μ s₂ := measure_mono h12\n  have le23 : μ s₂ ≤ μ s₃ := measure_mono h23\n  have key : μ s₃ ≤ μ s₁ :=\n    calc\n      μ s₃ = μ (s₃ \\ s₁ ∪ s₁) := by rw [diff_union_of_subset (h12.trans h23)]\n      _ ≤ μ (s₃ \\ s₁) + μ s₁ := (measure_union_le _ _)\n      _ = μ s₁ := by simp only [h_nulldiff, zero_add]\n      \n  exact ⟨le12.antisymm (le23.trans key), le23.antisymm (key.trans le12)⟩\n#align measure_eq_measure_of_between_null_diff measure_eq_measure_of_between_null_diff\n\n",
 "measure_eq_measure_larger_of_between_null_diff":
 "theorem measure_eq_measure_larger_of_between_null_diff {s₁ s₂ s₃ : Set α} (h12 : s₁ ⊆ s₂) (h23 : s₂ ⊆ s₃)\n    (h_nulldiff : μ (s₃ \\ s₁) = 0) : μ s₂ = μ s₃ :=\n  (measure_eq_measure_of_between_null_diff h12 h23 h_nulldiff).2\n#align measure_eq_measure_larger_of_between_null_diff measure_eq_measure_larger_of_between_null_diff\n\n",
 "measure_eq_left_of_subset_of_measure_add_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\ntheorem measure_eq_left_of_subset_of_measure_add_eq {s t : Set α} (h : (μ + ν) t ≠ ennreal.top) (h' : s ⊆ t)\n    (h'' : (μ + ν) s = (μ + ν) t) : μ s = μ t :=\n  by\n  refine' le_antisymm (measure_mono h') _\n  have : μ t + ν t ≤ μ s + ν t :=\n    calc\n      μ t + ν t = μ s + ν s := h''.symm\n      _ ≤ μ s + ν t := add_le_add le_rfl (measure_mono h')\n      \n  apply ENNReal.le_of_add_le_add_right _ this\n  simp only [not_or, ENNReal.add_eq_top, Pi.add_apply, ne.def, coe_add] at h\n  exact h.2\n#align measure_eq_left_of_subset_of_measure_add_eq measure_eq_left_of_subset_of_measure_add_eq\n\n",
 "measure_diff_null'":
 "theorem measure_diff_null' (h : μ (s₁ ∩ s₂) = 0) : μ (s₁ \\ s₂) = μ s₁ :=\n  measure_congr <| diff_ae_eq_self.2 h\n#align measure_diff_null' measure_diff_null'\n\n",
 "measure_diff_null":
 "theorem measure_diff_null (h : μ s₂ = 0) : μ (s₁ \\ s₂) = μ s₁ :=\n  measure_diff_null' <| measure_mono_null (inter_subset_right _ _) h\n#align measure_diff_null measure_diff_null\n\n",
 "measure_diff_lt_of_lt_add":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\ntheorem measure_diff_lt_of_lt_add (hs : MeasurableSet s) (hst : s ⊆ t) (hs' : μ s ≠ ennreal.top) {ε : ennreal}\n    (h : μ t < μ s + ε) : μ (t \\ s) < ε := by\n  rw [measure_diff hst hs hs']; rw [add_comm] at h\n  exact ENNReal.sub_lt_of_lt_add (measure_mono hst) h\n#align measure_diff_lt_of_lt_add measure_diff_lt_of_lt_add\n\n",
 "measure_diff_le_iff_le_add":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\ntheorem measure_diff_le_iff_le_add (hs : MeasurableSet s) (hst : s ⊆ t) (hs' : μ s ≠ ennreal.top) {ε : ennreal} :\n    μ (t \\ s) ≤ ε ↔ μ t ≤ μ s + ε := by rwa [measure_diff hst hs hs', tsub_le_iff_left]\n#align measure_diff_le_iff_le_add measure_diff_le_iff_le_add\n\n",
 "measure_diff_add_inter":
 "theorem measure_diff_add_inter (s : Set α) (ht : MeasurableSet t) : μ (s \\ t) + μ (s ∩ t) = μ s :=\n  (add_comm _ _).trans (measure_inter_add_diff s ht)\n#align measure_diff_add_inter measure_diff_add_inter\n\n",
 "measure_diff'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\ntheorem measure_diff' (s : Set α) (hm : MeasurableSet t) (h_fin : μ t ≠ ennreal.top) : μ (s \\ t) = μ (s ∪ t) - μ t :=\n  Eq.symm <| ENNReal.sub_eq_of_add_eq h_fin <| by rw [add_comm, measure_add_diff hm, union_comm]\n#align measure_diff' measure_diff'\n\n",
 "measure_diff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\ntheorem measure_diff (h : s₂ ⊆ s₁) (h₂ : MeasurableSet s₂) (h_fin : μ s₂ ≠ ennreal.top) : μ (s₁ \\ s₂) = μ s₁ - μ s₂ :=\n  by rw [measure_diff' _ h₂ h_fin, union_eq_self_of_subset_right h]\n#align measure_diff measure_diff\n\n",
 "measure_compl_le_add_of_le_add":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\ntheorem measure_compl_le_add_of_le_add [FiniteMeasure μ] (hs : MeasurableSet s) (ht : MeasurableSet t) {ε : ennreal}\n    (h : μ s ≤ μ t + ε) : μ («expr ᶜ» t) ≤ μ («expr ᶜ» s) + ε :=\n  by\n  rw [measure_compl ht (measure_ne_top μ _), measure_compl hs (measure_ne_top μ _), tsub_le_iff_right]\n  calc\n    μ univ = μ univ - μ s + μ s := (tsub_add_cancel_of_le <| measure_mono s.subset_univ).symm\n    _ ≤ μ univ - μ s + (μ t + ε) := (add_le_add_left h _)\n    _ = _ := by rw [add_right_comm, add_assoc]\n    \n#align measure_compl_le_add_of_le_add measure_compl_le_add_of_le_add\n\n",
 "measure_compl_le_add_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\ntheorem measure_compl_le_add_iff [FiniteMeasure μ] (hs : MeasurableSet s) (ht : MeasurableSet t) {ε : ennreal} :\n    μ («expr ᶜ» s) ≤ μ («expr ᶜ» t) + ε ↔ μ t ≤ μ s + ε :=\n  ⟨fun h => compl_compl s ▸ compl_compl t ▸ measure_compl_le_add_of_le_add hs.compl ht.compl h,\n    measure_compl_le_add_of_le_add ht hs⟩\n#align measure_compl_le_add_iff measure_compl_le_add_iff\n\n",
 "measure_compl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\ntheorem measure_compl (h₁ : MeasurableSet s) (h_fin : μ s ≠ ennreal.top) : μ («expr ᶜ» s) = μ univ - μ s :=\n  by\n  rw [compl_eq_univ_diff]\n  exact measure_diff (subset_univ s) h₁ h_fin\n#align measure_compl measure_compl\n\n",
 "measure_closed_ball_lt_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\ntheorem measure_closed_ball_lt_top [PseudoMetricSpace α] [ProperSpace α] {μ : Measure α} [FiniteMeasureOnCompacts μ]\n    {x : α} {r : exprℝ} : μ (Metric.closedBall x r) < ennreal.top :=\n  Metric.bounded_closedBall.measure_lt_top\n#align measure_closed_ball_lt_top measure_closed_ball_lt_top\n\n",
 "measure_ball_lt_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\ntheorem measure_ball_lt_top [PseudoMetricSpace α] [ProperSpace α] {μ : Measure α} [FiniteMeasureOnCompacts μ] {x : α}\n    {r : exprℝ} : μ (Metric.ball x r) < ennreal.top :=\n  Metric.bounded_ball.measure_lt_top\n#align measure_ball_lt_top measure_ball_lt_top\n\n",
 "measure_bUnion₀":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr on » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , » -/\ntheorem measure_bUnion₀ {s : Set β} {f : β → Set α} (hs : s.countable) (hd : s.pairwise («expr on » (AEDisjoint μ) f))\n    (h : ∀ b ∈ s, NullMeasurableSet (f b) μ) :\n    μ («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (f b)) =\n      «expr∑' , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , »\" (μ (f p)) :=\n  by\n  haveI := hs.to_encodable\n  rw [bUnion_eq_Union]\n  exact measure_Union₀ (hd.on_injective Subtype.coe_injective fun x => x.2) fun x => h x x.2\n#align measure_bUnion₀ measure_bUnion₀\n\n",
 "measure_bUnion_to_measurable":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\ntheorem measure_bUnion_to_measurable {I : Set β} (hc : I.countable) (s : β → Set α) :\n    μ\n        («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n          (toMeasurable μ (s b))) =\n      μ («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (s b)) :=\n  by\n  haveI := hc.to_encodable\n  simp only [bUnion_eq_Union, measure_Union_to_measurable]\n#align measure_bUnion_to_measurable measure_bUnion_to_measurable\n\n",
 "measure_bUnion_finset₀":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr on » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem measure_bUnion_finset₀ {s : Finset ι} {f : ι → Set α} (hd : Set.Pairwise (↑s) («expr on » (AEDisjoint μ) f))\n    (hm : ∀ b ∈ s, NullMeasurableSet (f b) μ) :\n    μ («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (f b)) =\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s (μ (f p)) :=\n  by\n  rw [← Finset.sum_attach, Finset.attach_eq_univ, ← tsum_fintype]\n  exact measure_bUnion₀ s.countable_to_set hd hm\n#align measure_bUnion_finset₀ measure_bUnion_finset₀\n\n",
 "measure_bUnion_finset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem measure_bUnion_finset {s : Finset ι} {f : ι → Set α} (hd : PairwiseDisjoint (↑s) f)\n    (hm : ∀ b ∈ s, MeasurableSet (f b)) :\n    μ («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (f b)) =\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s (μ (f p)) :=\n  measure_bunionᵢ_finset₀ hd.ae_disjoint fun b hb => (hm b hb).null_measurable_set\n#align measure_bUnion_finset measure_bUnion_finset\n\n",
 "measure_bUnion_eq_supr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr on » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\ntheorem measure_bUnion_eq_supr {s : ι → Set α} {t : Set ι} (ht : t.countable)\n    (hd : DirectedOn («expr on » (· ⊆ ·) s) t) :\n    μ («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (s i)) =\n      «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (μ (s i)) :=\n  by\n  haveI := ht.to_encodable\n  rw [bUnion_eq_Union, measure_Union_eq_supr hd.directed_coe, ← supᵢ_subtype'']\n#align measure_bUnion_eq_supr measure_bUnion_eq_supr\n\n",
 "measure_bUnion":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , » -/\ntheorem measure_bUnion {s : Set β} {f : β → Set α} (hs : s.countable) (hd : s.pairwise_disjoint f)\n    (h : ∀ b ∈ s, MeasurableSet (f b)) :\n    μ («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (f b)) =\n      «expr∑' , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , »\" (μ (f p)) :=\n  measure_bunionᵢ₀ hs hd.ae_disjoint fun b hb => (h b hb).null_measurable_set\n#align measure_bUnion measure_bUnion\n\n",
 "measure_add_measure_compl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\ntheorem measure_add_measure_compl (h : MeasurableSet s) : μ s + μ («expr ᶜ» s) = μ univ :=\n  measure_add_measure_compl₀ h.null_measurable_set\n#align measure_add_measure_compl measure_add_measure_compl\n\n",
 "measure_add_diff":
 "theorem measure_add_diff (hs : MeasurableSet s) (t : Set α) : μ s + μ (t \\ s) = μ (s ∪ t) := by\n  rw [← measure_union' disjoint_sdiff_right hs, union_diff_self]\n#align measure_add_diff measure_add_diff\n\n",
 "measure_Union_to_measurable":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n@[simp]\ntheorem measure_Union_to_measurable [Countable β] (s : β → Set α) :\n    μ\n        («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n          (toMeasurable μ (s b))) =\n      μ («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (s b)) :=\n  Eq.symm <| measure_unionᵢ_congr_of_subset (fun b => subset_toMeasurable _ _) fun b => (measure_toMeasurable _).le\n#align measure_Union_to_measurable measure_Union_to_measurable\n\n",
 "measure_Union_eq_supr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/-- Continuity from below: the measure of the union of a directed sequence of (not necessarily\n-measurable) sets is the supremum of the measures. -/\ntheorem measure_Union_eq_supr [Countable ι] {s : ι → Set α} (hd : Directed (· ⊆ ·) s) :\n    μ («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (s i)) =\n      «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (μ (s i)) :=\n  by\n  cases nonempty_encodable ι\n  -- WLOG, `ι = ℕ`\n  generalize ht : Function.extend encodable.encode s («expr⊥») = t\n  replace hd : Directed (· ⊆ ·) t := ht ▸ hd.extend_bot Encodable.encode_injective\n  suffices\n    μ («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (t n)) =\n      «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (μ (t n))\n    by\n    simp only [← ht, encodable.encode_injective.apply_extend μ, ← supr_eq_Union,\n      supᵢ_extend_bot Encodable.encode_injective, (· ∘ ·), Pi.bot_apply, bot_eq_empty, measure_empty] at this\n    exact this.trans (supᵢ_extend_bot Encodable.encode_injective _)\n  clear! ι\n  -- The `≥` inequality is trivial\n  refine' le_antisymm _ (supᵢ_le fun i => measure_mono <| subset_Union _ _)\n  -- Choose `T n ⊇ t n` of the same measure, put `Td n = disjointed T`\n  set T : ℕ → Set α := fun n => to_measurable μ (t n)\n  set Td : ℕ → Set α := disjointed T\n  have hm : ∀ n, MeasurableSet (Td n) := MeasurableSet.disjointed fun n => measurable_set_to_measurable _ _\n  calc\n    μ («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (t n)) ≤\n        μ («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (T n)) :=\n      measure_mono (Union_mono fun i => subset_to_measurable _ _)\n    _ = μ («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (Td n)) := by\n      rw [unionᵢ_disjointed]\n    _ ≤ «expr∑' , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , »\" (μ (Td n)) :=\n      (measure_Union_le _)\n    _ =\n        «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n          (finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" I\n            (μ (Td n))) :=\n      ENNReal.tsum_eq_supᵢ_sum\n    _ ≤ «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (μ (t n)) :=\n      supᵢ_le fun I => _\n    \n  rcases hd.finset_le I with ⟨N, hN⟩\n  calc\n    finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" I (μ (Td n)) =\n        μ («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (Td n)) :=\n      (measure_bUnion_finset ((disjoint_disjointed T).set_pairwise I) fun n _ => hm n).symm\n    _ ≤ μ («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (T n)) :=\n      (measure_mono (Union₂_mono fun n hn => disjointed_subset _ _))\n    _ = μ («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (t n)) :=\n      (measure_bUnion_to_measurable I.countable_to_set _)\n    _ ≤ μ (t N) := (measure_mono (Union₂_subset hN))\n    _ ≤ «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (μ (t n)) :=\n      le_supᵢ (μ ∘ t) N\n    \n#align measure_Union_eq_supr measure_Union_eq_supr\n\n",
 "measure_Union_congr_of_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\ntheorem measure_Union_congr_of_subset [Countable β] {s : β → Set α} {t : β → Set α} (hsub : ∀ b, s b ⊆ t b)\n    (h_le : ∀ b, μ (t b) ≤ μ (s b)) :\n    μ («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (s b)) =\n      μ («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (t b)) :=\n  by\n  rcases em (∃ b, μ (t b) = ennreal.top) with (⟨b, hb⟩ | htop)\n  ·\n    calc\n      μ («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (s b)) =\n          ennreal.top :=\n        top_unique (hb ▸ (h_le b).trans <| measure_mono <| subset_Union _ _)\n      _ = μ («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (t b)) :=\n        Eq.symm <| top_unique <| hb ▸ measure_mono <| subset_Union _ _\n      \n  push_neg  at htop\n  refine' le_antisymm (measure_mono (Union_mono hsub)) _\n  set M := to_measurable μ\n  have H :\n    ∀ b,\n      «expr =ᵐ[ ] »\n        (M (t b) ∩\n            M («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (s b)) :\n          Set α)\n        μ (M (t b)) :=\n    by\n    refine' fun b => ae_eq_of_subset_of_measure_ge (inter_subset_left _ _) _ _ _\n    ·\n      calc\n        μ (M (t b)) = μ (t b) := measure_to_measurable _\n        _ ≤ μ (s b) := (h_le b)\n        _ ≤\n            μ\n              (M (t b) ∩\n                M\n                  («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n                    (s b))) :=\n          measure_mono <|\n            subset_inter ((hsub b).trans <| subset_to_measurable _ _)\n              ((subset_Union _ _).trans <| subset_to_measurable _ _)\n        \n    · exact (measurable_set_to_measurable _ _).inter (measurable_set_to_measurable _ _)\n    · rw [measure_to_measurable]\n      exact htop b\n  calc\n    μ («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (t b)) ≤\n        μ («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (M (t b))) :=\n      measure_mono (Union_mono fun b => subset_to_measurable _ _)\n    _ =\n        μ\n          («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n            (M (t b) ∩\n              M\n                («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n                  (s b)))) :=\n      (measure_congr (EventuallyEq.countable_unionᵢ H).symm)\n    _ ≤ μ (M («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (s b))) :=\n      (measure_mono (Union_subset fun b => inter_subset_right _ _))\n    _ = μ («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (s b)) :=\n      measure_to_measurable _\n    \n#align measure_Union_congr_of_subset measure_Union_congr_of_subset\n\n",
 "measure_Ioo_lt_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n#print measure_Ioo_lt_top /-\ntheorem measure_Ioo_lt_top : μ (Ioo a b) < ennreal.top :=\n  (measure_mono Ioo_subset_Icc_self).trans_lt measure_Icc_lt_top\n#align measure_Ioo_lt_top measure_Ioo_lt_top\n-/\n\n",
 "measure_Ioc_lt_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n#print measure_Ioc_lt_top /-\ntheorem measure_Ioc_lt_top : μ (Ioc a b) < ennreal.top :=\n  (measure_mono Ioc_subset_Icc_self).trans_lt measure_Icc_lt_top\n#align measure_Ioc_lt_top measure_Ioc_lt_top\n-/\n\n",
 "measure_Inter_eq_infi":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (t «expr ⊆ » s k) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:219:4: warning: unsupported binary notation `«expr ⊇ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/-- Continuity from above: the measure of the intersection of a decreasing sequence of measurable\nsets is the infimum of the measures. -/\ntheorem measure_Inter_eq_infi [Countable ι] {s : ι → Set α} (h : ∀ i, MeasurableSet (s i))\n    (hd : Directed («expr ⊇ » · ·) s) (hfin : ∃ i, μ (s i) ≠ ennreal.top) :\n    μ («expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (s i)) =\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (μ (s i)) :=\n  by\n  rcases hfin with ⟨k, hk⟩\n  have : ∀ (t) (_ : t ⊆ s k), μ t ≠ ennreal.top := fun t ht => ne_top_of_le_ne_top hk (measure_mono ht)\n  rw [← ENNReal.sub_sub_cancel hk (infᵢ_le _ k), ENNReal.sub_infᵢ, ←\n    ENNReal.sub_sub_cancel hk (measure_mono (Inter_subset _ k)), ←\n    measure_diff (Inter_subset _ k) (MeasurableSet.interᵢ h) (this _ (Inter_subset _ k)), diff_Inter,\n    measure_Union_eq_supr]\n  · congr 1\n    refine' le_antisymm (supᵢ_mono' fun i => _) (supᵢ_mono fun i => _)\n    · rcases hd i k with ⟨j, hji, hjk⟩\n      use j\n      rw [← measure_diff hjk (h _) (this _ hjk)]\n      exact measure_mono (diff_subset_diff_right hji)\n    · rw [tsub_le_iff_right, ← measure_union disjoint_sdiff_left (h i), Set.union_comm]\n      exact measure_mono (diff_subset_iff.1 <| subset.refl _)\n  · exact hd.mono_comp _ fun _ _ => diff_subset_diff_right\n#align measure_Inter_eq_infi measure_Inter_eq_infi\n\n",
 "measure_Inf_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\nprivate theorem measure_Inf_le (h : μ ∈ m) : infₛ m ≤ μ :=\n  have : infₛ («expr '' » to_outer_measure m) ≤ μ.to_outer_measure := infₛ_le (mem_image_of_mem _ h)\n  fun s hs => by rw [infₛ_apply hs, ← to_outer_measure_apply] <;> exact this s\n#align measure_Inf_le measure_Inf_le\n\n",
 "measure_Ico_lt_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n#print measure_Ico_lt_top /-\ntheorem measure_Ico_lt_top : μ (Ico a b) < ennreal.top :=\n  (measure_mono Ico_subset_Icc_self).trans_lt measure_Icc_lt_top\n#align measure_Ico_lt_top measure_Ico_lt_top\n-/\n\n",
 "measure_Icc_lt_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n#print measure_Icc_lt_top /-\ntheorem measure_Icc_lt_top : μ (Icc a b) < ennreal.top :=\n  is_compact_Icc.measure_lt_top\n#align measure_Icc_lt_top measure_Icc_lt_top\n-/\n\n",
 "measurable_spanning_sets_index":
 "theorem measurable_spanning_sets_index (μ : Measure α) [SigmaFinite μ] : Measurable (spanningSetsIndex μ) :=\n  measurable_find _ <| measurable_spanningSets μ\n#align measurable_spanning_sets_index measurable_spanning_sets_index\n\n",
 "measurable_spanning_sets":
 "theorem measurable_spanning_sets (μ : Measure α) [SigmaFinite μ] (i : ℕ) : MeasurableSet (spanningSets μ i) :=\n  MeasurableSet.unionᵢ fun j => MeasurableSet.unionᵢ fun hij => μ.to_finite_spanning_sets_in.set_mem j\n#align measurable_spanning_sets measurable_spanning_sets\n\n",
 "mapₗ_mk_apply_of_ae_measurable":
 "theorem mapₗ_mk_apply_of_ae_measurable {f : α → β} (hf : AEMeasurable f μ) : mapₗ (hf.mk f) μ = map f μ := by\n  simp [map, hf]\n#align mapₗ_mk_apply_of_ae_measurable mapₗ_mk_apply_of_ae_measurable\n\n",
 "mapₗ_congr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\ntheorem mapₗ_congr {f g : α → β} (hf : Measurable f) (hg : Measurable g) (h : «expr =ᵐ[ ] » f μ g) :\n    mapₗ f μ = mapₗ g μ := by\n  ext1 s hs\n  simpa only [mapₗ, hf, hg, hs, dif_pos, lift_linear_apply, outer_measure.map_apply, coe_to_outer_measure] using\n    measure_congr (h.preimage s)\n#align mapₗ_congr mapₗ_congr\n\n",
 "mapₗ_apply_of_measurable":
 "theorem mapₗ_apply_of_measurable {f : α → β} (hf : Measurable f) (μ : Measure α) : mapₗ f μ = map f μ :=\n  by\n  simp only [← mapₗ_mk_apply_of_ae_measurable hf.ae_measurable]\n  exact mapₗ_congr hf hf.ae_measurable.measurable_mk hf.ae_measurable.ae_eq_mk\n#align mapₗ_apply_of_measurable mapₗ_apply_of_measurable\n\n",
 "map_zero":
 "#print map_zero /-\n@[simp]\ntheorem map_zero (f : α → β) : (0 : Measure α).map f = 0 := by\n  by_cases hf : AEMeasurable f (0 : measure α) <;> simp [map, hf]\n#align map_zero map_zero\n-/\n\n",
 "map_to_outer_measure":
 "theorem map_to_outer_measure {f : α → β} (hf : AEMeasurable f μ) :\n    (μ.map f).to_outer_measure = (OuterMeasure.map f μ.to_outer_measure).trim :=\n  by\n  rw [← trimmed, outer_measure.trim_eq_trim_iff]\n  intro s hs\n  rw [coe_to_outer_measure, map_apply_of_ae_measurable hf hs, outer_measure.map_apply, coe_to_outer_measure]\n#align map_to_outer_measure map_to_outer_measure\n\n",
 "map_symm_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ᵐ » -/\n@[simp]\ntheorem map_symm_map (e : «expr ≃ᵐ » α β) : (μ.map e).map e.symm = μ := by simp [map_map e.symm.measurable e.measurable]\n#align map_symm_map map_symm_map\n\n",
 "map_smul_nnreal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\nprotected theorem map_smul_nnreal (c : nnreal) (μ : Measure α) (f : α → β) :\n    («expr • » c μ).map f = «expr • » c (μ.map f) :=\n  μ.map_smul (c : ennreal) f\n#align map_smul_nnreal map_smul_nnreal\n\n",
 "map_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\nprotected theorem map_smul (c : ennreal) (μ : Measure α) (f : α → β) : («expr • » c μ).map f = «expr • » c (μ.map f) :=\n  by\n  rcases eq_or_ne c 0 with (rfl | hc); · simp\n  by_cases hf : AEMeasurable f μ\n  · have hfc : AEMeasurable f («expr • » c μ) := ⟨hf.mk f, hf.measurable_mk, (ae_smul_measure_iff hc).2 hf.ae_eq_mk⟩\n    simp only [← mapₗ_mk_apply_of_ae_measurable hf, ← mapₗ_mk_apply_of_ae_measurable hfc, LinearMap.map_smulₛₗ,\n      RingHom.id_apply]\n    congr 1\n    apply mapₗ_congr hfc.measurable_mk hf.measurable_mk\n    exact eventually_eq.trans ((ae_smul_measure_iff hc).1 hfc.ae_eq_mk.symm) hf.ae_eq_mk\n  · have hfc : ¬AEMeasurable f («expr • » c μ) := by\n      intro hfc\n      exact hf ⟨hfc.mk f, hfc.measurable_mk, (ae_smul_measure_iff hc).1 hfc.ae_eq_mk⟩\n    simp [map_of_not_ae_measurable hf, map_of_not_ae_measurable hfc]\n#align map_smul map_smul\n\n",
 "map_restrict_ae_le_map_indicator_ae":
 "#print map_restrict_ae_le_map_indicator_ae /-\ntheorem map_restrict_ae_le_map_indicator_ae [Zero β] (hs : MeasurableSet s) :\n    Filter.map f (μ.restrict s).ae ≤ Filter.map (s.indicator f) μ.ae :=\n  by\n  intro t\n  by_cases ht : (0 : β) ∈ t\n  · rw [mem_map_indicator_ae_iff_mem_map_restrict_ae_of_zero_mem ht hs]\n    exact id\n  rw [mem_map_indicator_ae_iff_of_zero_nmem ht, mem_map_restrict_ae_iff hs]\n  exact fun h => measure_mono_null ((Set.inter_subset_left _ _).trans (Set.subset_union_left _ _)) h\n#align map_restrict_ae_le_map_indicator_ae map_restrict_ae_le_map_indicator_ae\n-/\n\n",
 "map_of_not_ae_measurable":
 "theorem map_of_not_ae_measurable {f : α → β} {μ : Measure α} (hf : ¬AEMeasurable f μ) : μ.map f = 0 := by simp [map, hf]\n#align map_of_not_ae_measurable map_of_not_ae_measurable\n\n",
 "map_mono":
 "@[mono]\ntheorem map_mono {f : α → β} (h : μ ≤ ν) (hf : Measurable f) : μ.map f ≤ ν.map f := fun s hs => by\n  simp [hf.ae_measurable, hs, h _ (hf hs)]\n#align map_mono map_mono\n\n",
 "map_measurable_equiv_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ᵐ » -/\ntheorem map_measurable_equiv_injective (e : «expr ≃ᵐ » α β) : injective (map e) :=\n  by\n  intro μ₁ μ₂ hμ\n  apply_fun map e.symm  at hμ\n  simpa [map_symm_map e] using hμ\n#align map_measurable_equiv_injective map_measurable_equiv_injective\n\n",
 "map_map_symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ᵐ » -/\n@[simp]\ntheorem map_map_symm (e : «expr ≃ᵐ » α β) : (ν.map e.symm).map e = ν := by simp [map_map e.measurable e.symm.measurable]\n#align map_map_symm map_map_symm\n\n",
 "map_map":
 "theorem map_map {g : β → γ} {f : α → β} (hg : Measurable g) (hf : Measurable f) : (μ.map f).map g = μ.map (g ∘ f) :=\n  ext fun s hs => by simp [hf, hg, hs, hg hs, hg.comp hf, ← preimage_comp]\n#align map_map map_map\n\n",
 "map_id'":
 "@[simp]\ntheorem map_id' : map (fun x => x) μ = μ :=\n  map_id\n#align map_id' map_id'\n\n",
 "map_id":
 "@[simp]\ntheorem map_id : map id μ = μ :=\n  ext fun s => map_apply measurable_id\n#align map_id map_id\n\n",
 "map_eq_sum":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/-- If `f` is a map with countable codomain, then `μ.map f` is a sum of Dirac measures. -/\ntheorem map_eq_sum [Countable β] [MeasurableSingletonClass β] (μ : Measure α) (f : α → β) (hf : Measurable f) :\n    μ.map f = sum fun b : β => «expr • » (μ («expr ⁻¹' » f {b})) (dirac b) :=\n  by\n  ext1 s hs\n  have : ∀ y ∈ s, MeasurableSet («expr ⁻¹' » f {y}) := fun y _ => hf (measurable_set_singleton _)\n  simp [← tsum_measure_preimage_singleton (to_countable s) this, *, tsum_subtype s fun b => μ («expr ⁻¹' » f {b}), ←\n    indicator_mul_right s fun b => μ («expr ⁻¹' » f {b})]\n#align map_eq_sum map_eq_sum\n\n",
 "map_dirac":
 "theorem map_dirac {f : α → β} (hf : Measurable f) (a : α) : (dirac a).map f = dirac (f a) :=\n  ext fun s hs => by simp [hs, map_apply hf hs, hf hs, indicator_apply]\n#align map_dirac map_dirac\n\n",
 "map_congr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\n#print map_congr /-\ntheorem map_congr {f g : α → β} (h : «expr =ᵐ[ ] » f μ g) : Measure.map f μ = Measure.map g μ :=\n  by\n  by_cases hf : AEMeasurable f μ\n  · have hg : AEMeasurable g μ := hf.congr h\n    simp only [← mapₗ_mk_apply_of_ae_measurable hf, ← mapₗ_mk_apply_of_ae_measurable hg]\n    exact mapₗ_congr hf.measurable_mk hg.measurable_mk (hf.ae_eq_mk.symm.trans (h.trans hg.ae_eq_mk))\n  · have hg : ¬AEMeasurable g μ := by simpa [← aemeasurable_congr h] using hf\n    simp [map_of_not_ae_measurable, hf, hg]\n#align map_congr map_congr\n-/\n\n",
 "map_comap_subtype_coe":
 "#print map_comap_subtype_coe /-\ntheorem map_comap_subtype_coe {m0 : MeasurableSpace α} {s : Set α} (hs : MeasurableSet s) (μ : measure α) :\n    (comap coe μ).map (coe : s → α) = μ.restrict s := by\n  rw [(MeasurableEmbedding.subtype_coe hs).map_comap, Subtype.range_coe]\n#align map_comap_subtype_coe map_comap_subtype_coe\n-/\n\n",
 "map_comap":
 "theorem map_comap (μ : measure β) : (comap f μ).map f = μ.restrict (range f) :=\n  by\n  ext1 t ht\n  rw [hf.map_apply, comap_apply f hf.injective hf.measurable_set_image' _ (hf.measurable ht),\n    image_preimage_eq_inter_range, restrict_apply ht]\n#align map_comap map_comap\n\n",
 "map_coe_volume":
 "#print MeasurableSet.map_coe_volume /-\ntheorem MeasurableSet.map_coe_volume {s : Set α} (hs : MeasurableSet s) :\n    volume.map (coe : s → α) = restrict volume s := by\n  rw [volume_set_coe_def, (MeasurableEmbedding.subtype_coe hs).map_comap volume, Subtype.range_coe]\n#align measurable_set.map_coe_volume MeasurableSet.map_coe_volume\n-/\n\n",
 "map_apply_of_ae_measurable":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/-- We can evaluate the pushforward on measurable sets. For non-measurable sets, see\n  `measure_theory.measure.le_map_apply` and `measurable_equiv.map_apply`. -/\n@[simp]\ntheorem map_apply_of_ae_measurable {f : α → β} (hf : AEMeasurable f μ) {s : Set β} (hs : MeasurableSet s) :\n    μ.map f s = μ («expr ⁻¹' » f s) := by\n  simpa only [mapₗ, hf.measurable_mk, hs, dif_pos, lift_linear_apply, outer_measure.map_apply, coe_to_outer_measure, ←\n    mapₗ_mk_apply_of_ae_measurable hf] using measure_congr (hf.ae_eq_mk.symm.preimage s)\n#align map_apply_of_ae_measurable map_apply_of_ae_measurable\n\n",
 "map_apply_eq_iff_map_symm_apply_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ᵐ » -/\ntheorem map_apply_eq_iff_map_symm_apply_eq (e : «expr ≃ᵐ » α β) : μ.map e = ν ↔ ν.map e.symm = μ := by\n  rw [← (map_measurable_equiv_injective e).eq_iff, map_map_symm, eq_comm]\n#align map_apply_eq_iff_map_symm_apply_eq map_apply_eq_iff_map_symm_apply_eq\n\n",
 "map_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ᵐ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/-- If we map a measure along a measurable equivalence, we can compute the measure on all sets\n  (not just the measurable ones). -/\nprotected theorem map_apply (f : «expr ≃ᵐ » α β) (s : Set β) : μ.map f s = μ («expr ⁻¹' » f s) :=\n  f.measurable_embedding.map_apply _ _\n#align map_apply map_apply\n\n",
 "map_ae":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ᵐ » -/\ntheorem map_ae (f : «expr ≃ᵐ » α β) (μ : measure α) : Filter.map f μ.ae = (map f μ).ae :=\n  by\n  ext s\n  simp_rw [mem_map, mem_ae_iff, ← preimage_compl, f.map_apply]\n#align map_ae map_ae\n\n",
 "map_add":
 "#print map_add /-\n@[simp]\ntheorem map_add (μ ν : Measure α) {f : α → β} (hf : Measurable f) : (μ + ν).map f = μ.map f + ν.map f := by\n  simp [← mapₗ_apply_of_measurable hf]\n#align map_add map_add\n-/\n\n",
 "map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure.absolutely_continuous -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure.absolutely_continuous -/\n@[mono]\nprotected theorem map (h : measure.absolutely_continuous μ ν) {f : α → β} (hf : Measurable f) :\n    measure.absolutely_continuous (μ.map f) (ν.map f) :=\n  AbsolutelyContinuous.mk fun s hs => by simpa [hf, hs] using @h _\n#align map map\n\n",
 "lt_iff'":
 "theorem lt_iff' : μ < ν ↔ μ ≤ ν ∧ ∃ s, μ s < ν s :=\n  lt_iff_le_not_le.trans <| and_congr iff.rfl <| by simp only [le_iff', not_forall, not_le]\n#align lt_iff' lt_iff'\n\n",
 "lt_iff":
 "theorem lt_iff : μ < ν ↔ μ ≤ ν ∧ ∃ s, MeasurableSet s ∧ μ s < ν s :=\n  lt_iff_le_not_le.trans <| and_congr iff.rfl <| by simp only [le_iff, not_forall, not_le, exists_prop]\n#align lt_iff lt_iff\n\n",
 "limsup_preimage_iterate_ae_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\ntheorem limsup_preimage_iterate_ae_eq {f : α → α} (hf : QuasiMeasurePreserving f μ μ)\n    (hs : «expr =ᵐ[ ] » («expr ⁻¹' » f s) μ s) :-- Need `@` below because of diamond; see gh issue #16932\n      «expr =ᵐ[ ] »\n      (@limsup (Set α) ℕ _ (fun n => («expr ^[ ]» (preimage f) n) s) atTop) μ s :=\n  haveI : ∀ n, «expr =ᵐ[ ] » ((«expr ^[ ]» (preimage f) n) s) μ s :=\n    by\n    intro n\n    induction' n with n ih\n    · simp\n    simpa only [iterate_succ', comp_app] using ae_eq_trans (hf.ae_eq ih) hs\n  (limsup_ae_eq_of_forall_ae_eq (fun n => («expr ^[ ]» (preimage f) n) s) this).trans (ae_eq_refl _)\n#align limsup_preimage_iterate_ae_eq limsup_preimage_iterate_ae_eq\n\n",
 "limsup_ae_eq_of_forall_ae_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\ntheorem limsup_ae_eq_of_forall_ae_eq (s : ℕ → Set α) {t : Set α}\n    (h : ∀ n, «expr =ᵐ[ ] » (s n) μ t) :-- Need `@` below because of diamond; see gh issue #16932\n      «expr =ᵐ[ ] »\n      (@limsup (Set α) ℕ _ s atTop) μ t :=\n  by\n  simp_rw [ae_eq_set] at h⊢\n  constructor\n  · rw [at_top.limsup_sdiff s t]\n    apply measure_limsup_eq_zero\n    simp [h]\n  · rw [at_top.sdiff_limsup s t]\n    apply measure_liminf_eq_zero\n    simp [h]\n#align limsup_ae_eq_of_forall_ae_eq limsup_ae_eq_of_forall_ae_eq\n\n",
 "liminf_preimage_iterate_ae_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\ntheorem liminf_preimage_iterate_ae_eq {f : α → α} (hf : QuasiMeasurePreserving f μ μ)\n    (hs : «expr =ᵐ[ ] » («expr ⁻¹' » f s) μ s) :-- Need `@` below because of diamond; see gh issue #16932\n      «expr =ᵐ[ ] »\n      (@liminf (Set α) ℕ _ (fun n => («expr ^[ ]» (preimage f) n) s) atTop) μ s :=\n  by\n  -- Need `@` below because of diamond; see gh issue #16932\n  rw [← ae_eq_set_compl_compl, @Filter.liminf_compl (Set α)]\n  rw [← ae_eq_set_compl_compl, ← preimage_compl] at hs\n  convert hf.limsup_preimage_iterate_ae_eq hs\n  ext1 n\n  simp only [← Set.preimage_iterate_eq, comp_app, preimage_compl]\n#align liminf_preimage_iterate_ae_eq liminf_preimage_iterate_ae_eq\n\n",
 "liminf_ae_eq_of_forall_ae_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\ntheorem liminf_ae_eq_of_forall_ae_eq (s : ℕ → Set α) {t : Set α}\n    (h : ∀ n, «expr =ᵐ[ ] » (s n) μ t) :-- Need `@` below because of diamond; see gh issue #16932\n      «expr =ᵐ[ ] »\n      (@liminf (Set α) ℕ _ s atTop) μ t :=\n  by\n  simp_rw [ae_eq_set] at h⊢\n  constructor\n  · rw [at_top.liminf_sdiff s t]\n    apply measure_liminf_eq_zero\n    simp [h]\n  · rw [at_top.sdiff_liminf s t]\n    apply measure_limsup_eq_zero\n    simp [h]\n#align liminf_ae_eq_of_forall_ae_eq liminf_ae_eq_of_forall_ae_eq\n\n",
 "lift_linear_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n@[simp]\ntheorem lift_linear_apply {f : «expr →ₗ[ ] » (OuterMeasure α) (ennreal) (OuterMeasure β)} (hf) {s : Set β}\n    (hs : MeasurableSet s) : liftLinear f hf μ s = f μ.to_outer_measure s :=\n  toMeasure_apply _ _ hs\n#align lift_linear_apply lift_linear_apply\n\n",
 "le_trim":
 "theorem le_trim (hm : m ≤ m0) : μ s ≤ μ.trim hm s :=\n  by\n  simp_rw [measure.trim]\n  exact @le_to_measure_apply _ m _ _ _\n#align le_trim le_trim\n\n",
 "le_to_outer_measure_caratheodory":
 "theorem le_to_outer_measure_caratheodory (μ : Measure α) : ms ≤ μ.to_outer_measure.caratheodory := fun s hs t =>\n  (measure_inter_add_diff _ hs).symm\n#align le_to_outer_measure_caratheodory le_to_outer_measure_caratheodory\n\n",
 "le_to_measure_apply":
 "theorem le_to_measure_apply (m : OuterMeasure α) (h : ms ≤ m.caratheodory) (s : Set α) : m s ≤ m.to_measure h s :=\n  m.le_trim s\n#align le_to_measure_apply le_to_measure_apply\n\n",
 "le_sum_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , » -/\ntheorem le_sum_apply (f : ι → Measure α) (s : Set α) :\n    «expr∑' , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , »\" (f i s) ≤\n      sum f s :=\n  le_toMeasure_apply _ _ _\n#align le_sum_apply le_sum_apply\n\n",
 "le_sum":
 "theorem le_sum (μ : ι → Measure α) (i : ι) : μ i ≤ sum μ := fun s hs => by simp only [sum_apply μ hs, ENNReal.le_tsum i]\n#align le_sum le_sum\n\n",
 "le_restrict_apply":
 "theorem le_restrict_apply (s t : Set α) : μ (t ∩ s) ≤ μ.restrict s t :=\n  calc\n    μ (t ∩ s) = μ.restrict s (t ∩ s) := (restrict_eq_self μ (inter_subset_right _ _)).symm\n    _ ≤ μ.restrict s t := measure_mono (inter_subset_left _ _)\n    \n#align le_restrict_apply le_restrict_apply\n\n",
 "le_of_add_le_add_left":
 "/-- `le_of_add_le_add_left` is normally applicable to `ordered_cancel_add_comm_monoid`,\nbut it holds for measures with the additional assumption that μ is finite. -/\ntheorem measure.le_of_add_le_add_left [FiniteMeasure μ] (A2 : μ + ν₁ ≤ μ + ν₂) : ν₁ ≤ ν₂ := fun S B1 =>\n  ENNReal.le_of_add_le_add_left (MeasureTheory.measure_ne_top μ S) (A2 S B1)\n#align measure.le_of_add_le_add_left measure.le_of_add_le_add_left\n\n",
 "le_measure_diff":
 "theorem le_measure_diff : μ s₁ - μ s₂ ≤ μ (s₁ \\ s₂) :=\n  tsub_le_iff_left.2 <|\n    calc\n      μ s₁ ≤ μ (s₂ ∪ s₁) := measure_mono (subset_union_right _ _)\n      _ = μ (s₂ ∪ s₁ \\ s₂) := (congr_arg μ union_diff_self.symm)\n      _ ≤ μ s₂ + μ (s₁ \\ s₂) := measure_union_le _ _\n      \n#align le_measure_diff le_measure_diff\n\n",
 "le_map_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/-- Even if `s` is not measurable, we can bound `map f μ s` from below.\n  See also `measurable_equiv.map_apply`. -/\ntheorem le_map_apply {f : α → β} (hf : AEMeasurable f μ) (s : Set β) : μ («expr ⁻¹' » f s) ≤ μ.map f s :=\n  calc\n    μ («expr ⁻¹' » f s) ≤ μ («expr ⁻¹' » f (toMeasurable (μ.map f) s)) :=\n      measure_mono <| preimage_mono <| subset_toMeasurable _ _\n    _ = μ.map f (toMeasurable (μ.map f) s) := (map_apply_of_aemeasurable hf <| measurableSet_toMeasurable _ _).symm\n    _ = μ.map f s := measure_toMeasurable _\n    \n#align le_map_apply le_map_apply\n\n",
 "le_lift_linear_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\ntheorem le_lift_linear_apply {f : «expr →ₗ[ ] » (OuterMeasure α) (ennreal) (OuterMeasure β)} (hf) (s : Set β) :\n    f μ.to_outer_measure s ≤ liftLinear f hf μ s :=\n  le_toMeasure_apply _ _ s\n#align le_lift_linear_apply le_lift_linear_apply\n\n",
 "le_iff'":
 "theorem le_iff' : μ₁ ≤ μ₂ ↔ ∀ s, μ₁ s ≤ μ₂ s :=\n  toOuterMeasure_le.symm\n#align le_iff' le_iff'\n\n",
 "le_iff":
 "theorem le_iff : μ₁ ≤ μ₂ ↔ ∀ s, MeasurableSet s → μ₁ s ≤ μ₂ s :=\n  iff.rfl\n#align le_iff le_iff\n\n",
 "le_dirac_apply":
 "theorem le_dirac_apply {a} : s.indicator 1 a ≤ dirac a s :=\n  OuterMeasure.dirac_apply a s ▸ le_toMeasure_apply _ _ _\n#align le_dirac_apply le_dirac_apply\n\n",
 "le_count_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\ntheorem le_count_apply :\n    («expr∑' , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , »\" 1 : ennreal) ≤\n      count s :=\n  calc\n    («expr∑' , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , »\" 1 : ennreal) =\n        «expr∑' , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , »\"\n          (indicator s 1 i) :=\n      tsum_subtype s 1\n    _ ≤ «expr∑' , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , »\" (dirac i s) :=\n      (ENNReal.tsum_le_tsum fun x => le_dirac_apply)\n    _ ≤ count s := le_sum_apply _ _\n    \n#align le_count_apply le_count_apply\n\n",
 "le_comap_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem le_comap_apply {β} [MeasurableSpace α] {mβ : MeasurableSpace β} (f : α → β) (μ : Measure β) (hfi : injective f)\n    (hf : ∀ s, MeasurableSet s → NullMeasurableSet («expr '' » f s) μ) (s : Set α) : μ («expr '' » f s) ≤ comap f μ s :=\n  by\n  rw [comap, dif_pos (and.intro hfi hf)]\n  exact le_to_measure_apply _ _ _\n#align le_comap_apply le_comap_apply\n\n",
 "le_ae_restrict":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\ntheorem le_ae_restrict : «expr ⊓ » μ.ae ((filter.principal) s) ≤ (μ.restrict s).ae := fun s hs =>\n  eventually_inf_principal.2 (ae_imp_of_ae_restrict hs)\n#align le_ae_restrict le_ae_restrict\n\n",
 "le_add_right":
 "#print le_add_right /-\nprotected theorem le_add_right (h : μ ≤ ν) : μ ≤ ν + ν' := fun s hs => le_add_right (h s hs)\n#align le_add_right le_add_right\n-/\n\n",
 "le_add_left":
 "#print le_add_left /-\nprotected theorem le_add_left (h : μ ≤ ν) : μ ≤ ν' + ν := fun s hs => le_add_left (h s hs)\n#align le_add_left le_add_left\n-/\n\n",
 "iterate":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\nprotected theorem iterate {f : α → α} (hf : QuasiMeasurePreserving f μa μa) :\n    ∀ n, QuasiMeasurePreserving («expr ^[ ]» f n) μa μa\n  | 0 => QuasiMeasurePreserving.id μa\n  | n + 1 => (iterate n).comp hf\n#align iterate iterate\n\n",
 "ite_ae_eq_of_measure_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\ntheorem ite_ae_eq_of_measure_zero {γ} (f : α → γ) (g : α → γ) (s : Set α) (hs_zero : μ s = 0) :\n    «expr =ᵐ[ ] » (fun x => ite (x ∈ s) (f x) (g x)) μ g :=\n  by\n  have h_ss : «expr ᶜ» s ⊆ { a : α | ite (a ∈ s) (f a) (g a) = g a } := fun x hx => by\n    simp [(Set.mem_compl_iff _ _).mp hx]\n  refine' measure_mono_null _ hs_zero\n  nth_rw 1 [← compl_compl s]\n  rwa [Set.compl_subset_compl]\n#align ite_ae_eq_of_measure_zero ite_ae_eq_of_measure_zero\n\n",
 "ite_ae_eq_of_measure_compl_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\ntheorem ite_ae_eq_of_measure_compl_zero {γ} (f : α → γ) (g : α → γ) (s : Set α) (hs_zero : μ («expr ᶜ» s) = 0) :\n    «expr =ᵐ[ ] » (fun x => ite (x ∈ s) (f x) (g x)) μ f :=\n  by\n  filter_upwards [hs_zero]\n  intros\n  split_ifs\n  rfl\n#align ite_ae_eq_of_measure_compl_zero ite_ae_eq_of_measure_compl_zero\n\n",
 "is_topological_basis_is_open_lt_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\nprotected theorem measure.is_topological_basis_is_open_lt_top [TopologicalSpace α] (μ : Measure α)\n    [LocallyFiniteMeasure μ] : TopologicalSpace.IsTopologicalBasis { s | IsOpen s ∧ μ s < ennreal.top } :=\n  by\n  refine' TopologicalSpace.isTopologicalBasis_of_open_of_nhds (fun s hs => hs.1) _\n  intro x s xs hs\n  rcases μ.exists_is_open_measure_lt_top x with ⟨v, xv, hv, μv⟩\n  refine' ⟨v ∩ s, ⟨hv.inter hs, lt_of_le_of_lt _ μv⟩, ⟨xv, xs⟩, inter_subset_right _ _⟩\n  exact measure_mono (inter_subset_left _ _)\n#align measure.is_topological_basis_is_open_lt_top measure.is_topological_basis_is_open_lt_top\n\n",
 "is_probability_measure_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem is_probability_measure_smul [FiniteMeasure μ] (h : μ ≠ 0) : ProbabilityMeasure («expr • » (μ univ)⁻¹ μ) :=\n  by\n  constructor\n  rw [smul_apply, smul_eq_mul, ENNReal.inv_mul_cancel]\n  · rwa [ne, measure_univ_eq_zero]\n  · exact measure_ne_top _ _\n#align is_probability_measure_smul is_probability_measure_smul\n\n",
 "is_probability_measure_map":
 "theorem is_probability_measure_map [ProbabilityMeasure μ] {f : α → β} (hf : AEMeasurable f μ) :\n    ProbabilityMeasure (map f μ) :=\n  ⟨by simp [map_apply_of_ae_measurable, hf]⟩\n#align is_probability_measure_map is_probability_measure_map\n\n",
 "is_locally_finite_measure_of_le":
 "theorem is_locally_finite_measure_of_le [TopologicalSpace α] {m : MeasurableSpace α} {μ ν : Measure α}\n    [H : LocallyFiniteMeasure μ] (h : ν ≤ μ) : LocallyFiniteMeasure ν :=\n  let F := H.finite_at_nhds\n  ⟨fun x => (F x).measure_mono h⟩\n#align is_locally_finite_measure_of_le is_locally_finite_measure_of_le\n\n",
 "is_locally_finite_measure_of_is_finite_measure_on_compacts":
 "-- see Note [lower instance priority]\n/-- A measure which is finite on compact sets in a locally compact space is locally finite.\nNot registered as an instance to avoid a loop with the other direction. -/\ntheorem is_locally_finite_measure_of_is_finite_measure_on_compacts [TopologicalSpace α] [LocallyCompactSpace α]\n    [FiniteMeasureOnCompacts μ] : LocallyFiniteMeasure μ :=\n  ⟨by\n    intro x\n    rcases exists_compact_mem_nhds x with ⟨K, K_compact, K_mem⟩\n    exact ⟨K, K_mem, K_compact.measure_lt_top⟩⟩\n#align is_locally_finite_measure_of_is_finite_measure_on_compacts is_locally_finite_measure_of_is_finite_measure_on_compacts\n\n",
 "is_finite_measure_of_le":
 "theorem is_finite_measure_of_le (μ : Measure α) [FiniteMeasure μ] (h : ν ≤ μ) : FiniteMeasure ν :=\n  { measure_univ_lt_top := lt_of_le_of_lt (h Set.univ MeasurableSet.univ) (measure_lt_top _ _) }\n#align is_finite_measure_of_le is_finite_measure_of_le\n\n",
 "is_finite_measure_map":
 "@[instance]\ntheorem measure.is_finite_measure_map {m : MeasurableSpace α} (μ : Measure α) [FiniteMeasure μ] (f : α → β) :\n    FiniteMeasure (μ.map f) := by\n  by_cases hf : AEMeasurable f μ\n  · constructor\n    rw [map_apply_of_ae_measurable hf MeasurableSet.univ]\n    exact measure_lt_top μ _\n  · rw [map_of_not_ae_measurable hf]\n    exact MeasureTheory.finiteMeasureZero\n#align measure.is_finite_measure_map measure.is_finite_measure_map\n\n",
 "is_finite_measure":
 "/-- Note this cannot be an instance because it would form a typeclass loop with\n`is_finite_measure_on_compacts_of_is_locally_finite_measure`. -/\ntheorem compact_space.is_finite_measure [TopologicalSpace α] [CompactSpace α] [FiniteMeasureOnCompacts μ] :\n    FiniteMeasure μ :=\n  ⟨is_finite_measure_on_compacts.lt_top_of_is_compact isCompact_univ⟩\n#align compact_space.is_finite_measure compact_space.is_finite_measure\n\n",
 "is_countably_spanning_spanning_sets":
 "theorem is_countably_spanning_spanning_sets (μ : Measure α) [SigmaFinite μ] :\n    IsCountablySpanning (range (spanningSets μ)) :=\n  ⟨spanningSets μ, mem_range_self, unionᵢ_spanningSets μ⟩\n#align is_countably_spanning_spanning_sets is_countably_spanning_spanning_sets\n\n",
 "insert_ae_eq_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\ntheorem insert_ae_eq_self (a : α) (s : Set α) : «expr =ᵐ[ ] » (insert a s : Set α) μ s :=\n  union_ae_eq_right.2 <| measure_mono_null (diff_subset _ _) (measure_singleton _)\n#align insert_ae_eq_self insert_ae_eq_self\n\n",
 "infₛ_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n#print infₛ_apply /-\ntheorem infₛ_apply (hs : MeasurableSet s) : infₛ m s = infₛ («expr '' » to_outer_measure m) s :=\n  toMeasure_apply _ _ hs\n#align Inf_apply infₛ_apply\n-/\n\n",
 "inf_of_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\ntheorem inf_of_right (h : μ.finite_at_filter g) : μ.finite_at_filter («expr ⊓ » f g) :=\n  h.filter_mono inf_le_right\n#align inf_of_right inf_of_right\n\n",
 "inf_of_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\ntheorem inf_of_left (h : μ.finite_at_filter f) : μ.finite_at_filter («expr ⊓ » f g) :=\n  h.filter_mono inf_le_left\n#align inf_of_left inf_of_left\n\n",
 "inf_ae_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n@[simp]\ntheorem inf_ae_iff : μ.finite_at_filter («expr ⊓ » f μ.ae) ↔ μ.finite_at_filter f :=\n  by\n  refine' ⟨_, fun h => h.filter_mono inf_le_left⟩\n  rintro ⟨s, ⟨t, ht, u, hu, rfl⟩, hμ⟩\n  suffices : μ t ≤ μ (t ∩ u); exact ⟨t, ht, this.trans_lt hμ⟩\n  exact measure_mono_ae (mem_of_superset hu fun x hu ht => ⟨ht, hu⟩)\n#align inf_ae_iff inf_ae_iff\n\n",
 "indicator_meas_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\n#print indicator_meas_zero /-\ntheorem indicator_meas_zero (hs : μ s = 0) : «expr =ᵐ[ ] » (indicator s f) μ 0 :=\n  indicator_empty' f ▸ indicator_ae_eq_of_ae_eq_set (ae_eq_empty.2 hs)\n#align indicator_meas_zero indicator_meas_zero\n-/\n\n",
 "indicator_ae_eq_zero_of_restrict_ae_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\n#print indicator_ae_eq_zero_of_restrict_ae_eq_zero /-\ntheorem indicator_ae_eq_zero_of_restrict_ae_eq_zero (hs : MeasurableSet s) (hf : «expr =ᵐ[ ] » f (μ.restrict s) 0) :\n    «expr =ᵐ[ ] » (s.indicator f) μ 0 :=\n  by\n  rw [Filter.EventuallyEq, ae_restrict_iff' hs] at hf\n  filter_upwards [hf]with x hx\n  by_cases hxs : x ∈ s\n  · simp only [hxs, hx hxs, Set.indicator_of_mem]\n  · simp [hx, hxs]\n#align indicator_ae_eq_zero_of_restrict_ae_eq_zero indicator_ae_eq_zero_of_restrict_ae_eq_zero\n-/\n\n",
 "indicator_ae_eq_restrict_compl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n#print indicator_ae_eq_restrict_compl /-\ntheorem indicator_ae_eq_restrict_compl (hs : MeasurableSet s) :\n    «expr =ᵐ[ ] » (indicator s f) (μ.restrict («expr ᶜ» s)) 0 :=\n  piecewise_ae_eq_restrict_compl hs\n#align indicator_ae_eq_restrict_compl indicator_ae_eq_restrict_compl\n-/\n\n",
 "indicator_ae_eq_restrict":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\n#print indicator_ae_eq_restrict /-\ntheorem indicator_ae_eq_restrict (hs : MeasurableSet s) : «expr =ᵐ[ ] » (indicator s f) (μ.restrict s) f :=\n  piecewise_ae_eq_restrict hs\n#align indicator_ae_eq_restrict indicator_ae_eq_restrict\n-/\n\n",
 "indicator_ae_eq_of_restrict_compl_ae_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\n#print indicator_ae_eq_of_restrict_compl_ae_eq_zero /-\ntheorem indicator_ae_eq_of_restrict_compl_ae_eq_zero (hs : MeasurableSet s)\n    (hf : «expr =ᵐ[ ] » f (μ.restrict («expr ᶜ» s)) 0) : «expr =ᵐ[ ] » (s.indicator f) μ f :=\n  by\n  rw [Filter.EventuallyEq, ae_restrict_iff' hs.compl] at hf\n  filter_upwards [hf]with x hx\n  by_cases hxs : x ∈ s\n  · simp only [hxs, Set.indicator_of_mem]\n  · simp only [hx hxs, Pi.zero_apply, Set.indicator_apply_eq_zero, eq_self_iff_true, imp_true_iff]\n#align indicator_ae_eq_of_restrict_compl_ae_eq_zero indicator_ae_eq_of_restrict_compl_ae_eq_zero\n-/\n\n",
 "indicator_ae_eq_of_ae_eq_set":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\n#print indicator_ae_eq_of_ae_eq_set /-\ntheorem indicator_ae_eq_of_ae_eq_set (hst : «expr =ᵐ[ ] » s μ t) : «expr =ᵐ[ ] » (s.indicator f) μ (t.indicator f) :=\n  piecewise_ae_eq_of_ae_eq_set hst\n#align indicator_ae_eq_of_ae_eq_set indicator_ae_eq_of_ae_eq_set\n-/\n\n",
 "image_zpow_ae_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\ntheorem image_zpow_ae_eq {s : Set α} {e : «expr ≃ » α α} (he : QuasiMeasurePreserving e μ μ)\n    (he' : QuasiMeasurePreserving e.symm μ μ) (k : ℤ) (hs : «expr =ᵐ[ ] » («expr '' » e s) μ s) :\n    «expr =ᵐ[ ] » («expr '' » («expr⇑ » (e ^ k)) s) μ s :=\n  by\n  rw [Equiv.image_eq_preimage]\n  obtain ⟨k, rfl | rfl⟩ := k.eq_coe_or_neg\n  · replace hs : «expr =ᵐ[ ] » («expr ⁻¹' » («expr⇑ » e⁻¹) s) μ s\n    · rwa [Equiv.image_eq_preimage] at hs\n    replace he' : «expr =ᵐ[ ] » («expr ⁻¹' » («expr ^[ ]» («expr⇑ » e⁻¹) k) s) μ s := he'.preimage_iterate_ae_eq k hs\n    rwa [Equiv.Perm.iterate_eq_pow e⁻¹ k, inv_pow e k] at he'\n  · rw [zpow_neg, zpow_ofNat]\n    replace hs : «expr =ᵐ[ ] » («expr ⁻¹' » e s) μ s\n    · convert he.preimage_ae_eq hs.symm\n      rw [Equiv.preimage_image]\n    replace he : «expr =ᵐ[ ] » («expr ⁻¹' » («expr ^[ ]» («expr⇑ » e) k) s) μ s := he.preimage_iterate_ae_eq k hs\n    rwa [Equiv.Perm.iterate_eq_pow e k] at he\n#align image_zpow_ae_eq image_zpow_ae_eq\n\n",
 "image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem null_measurable_set.image {β} [MeasurableSpace α] {mβ : MeasurableSpace β} (f : α → β) (μ : Measure β)\n    (hfi : injective f) (hf : ∀ s, MeasurableSet s → NullMeasurableSet («expr '' » f s) μ) {s : Set α}\n    (hs : NullMeasurableSet s (μ.comap f)) : NullMeasurableSet («expr '' » f s) μ :=\n  by\n  refine' ⟨to_measurable μ («expr '' » f (to_measurable (μ.comap f) s)), measurable_set_to_measurable _ _, _⟩\n  refine' eventually_eq.trans _ (null_measurable_set.to_measurable_ae_eq _).symm\n  swap\n  · exact hf _ (measurable_set_to_measurable _ _)\n  have h : «expr =ᵐ[ ] » (to_measurable (comap f μ) s) (comap f μ) s :=\n    @null_measurable_set.to_measurable_ae_eq _ _ (μ.comap f : measure α) s hs\n  exact ae_eq_image_of_ae_eq_comap f μ hfi hf h.symm\n#align null_measurable_set.image null_measurable_set.image\n\n",
 "id":
 "#print id /-\nprotected theorem id {m0 : MeasurableSpace α} (μ : Measure α) : QuasiMeasurePreserving id μ μ :=\n  ⟨measurable_id, map_id.absolutely_continuous⟩\n#align id id\n-/\n\n",
 "forall_measure_inter_spanning_sets_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/-- A set in a σ-finite space has zero measure if and only if its intersection with\nall members of the countable family of finite measure spanning sets has zero measure. -/\ntheorem forall_measure_inter_spanning_sets_eq_zero [MeasurableSpace α] {μ : Measure α} [SigmaFinite μ] (s : Set α) :\n    (∀ n, μ (s ∩ spanningSets μ n) = 0) ↔ μ s = 0 :=\n  by\n  nth_rw 1 [show\n      s =\n        «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n          (s ∩ spanning_sets μ n)\n      by rw [← inter_Union, Union_spanning_sets, inter_univ]]\n  rw [measure_Union_null_iff]\n#align forall_measure_inter_spanning_sets_eq_zero forall_measure_inter_spanning_sets_eq_zero\n\n",
 "finset_sum_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem finset_sum_apply {m : MeasurableSpace α} (I : Finset ι) (μ : ι → Measure α) (s : Set α) :\n    (finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" I (μ i)) s =\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" I (μ i s) :=\n  by rw [coe_finset_sum, Finset.sum_apply]\n#align finset_sum_apply finset_sum_apply\n\n",
 "finite_const_le_meas_of_disjoint_Union":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr on » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/-- If the union of disjoint measurable sets has finite measure, then there are only\nfinitely many members of the union whose measure exceeds any given positive number. -/\ntheorem finite_const_le_meas_of_disjoint_Union {ι : Type _} [MeasurableSpace α] (μ : Measure α) {ε : ennreal}\n    (ε_pos : 0 < ε) {As : ι → Set α} (As_mble : ∀ i : ι, MeasurableSet (As i))\n    (As_disj : Pairwise («expr on » Disjoint As))\n    (Union_As_finite :\n      μ («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (As i)) ≠\n        ennreal.top) :\n    Set.Finite { i : ι | ε ≤ μ (As i) } := by\n  by_contra con\n  have aux :=\n    lt_of_le_of_lt (tsum_meas_le_meas_Union_of_disjoint μ As_mble As_disj) (lt_top_iff_ne_top.mpr Union_As_finite)\n  exact Con (ENNReal.finite_const_le_of_tsum_ne_top aux.ne ε_pos.ne.symm)\n#align finite_const_le_meas_of_disjoint_Union finite_const_le_meas_of_disjoint_Union\n\n",
 "finite_at_principal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n@[simp]\ntheorem finite_at_principal : μ.finite_at_filter ((filter.principal) s) ↔ μ s < ennreal.top :=\n  ⟨fun ⟨t, ht, hμ⟩ => (measure_mono ht).trans_lt hμ, fun h => ⟨s, mem_principal_self s, h⟩⟩\n#align finite_at_principal finite_at_principal\n\n",
 "finite_at_nhds_within":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\ntheorem finite_at_nhds_within [TopologicalSpace α] {m0 : MeasurableSpace α} (μ : Measure α) [LocallyFiniteMeasure μ]\n    (x : α) (s : Set α) : μ.finite_at_filter (nhds_within s x) :=\n  (finiteAt_nhds μ x).inf_of_left\n#align finite_at_nhds_within finite_at_nhds_within\n\n",
 "finite_at_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n-- see Note [lower instance priority]\ntheorem measure.finite_at_nhds [TopologicalSpace α] (μ : Measure α) [LocallyFiniteMeasure μ] (x : α) :\n    μ.finite_at_filter ((nhds) x) :=\n  is_locally_finite_measure.finite_at_nhds x\n#align measure.finite_at_nhds measure.finite_at_nhds\n\n",
 "finite_at_filter_of_finite":
 "theorem finite_at_filter_of_finite {m0 : MeasurableSpace α} (μ : Measure α) [FiniteMeasure μ] (f : Filter α) :\n    μ.finite_at_filter f :=\n  ⟨univ, univ_mem, measure_lt_top μ univ⟩\n#align finite_at_filter_of_finite finite_at_filter_of_finite\n\n",
 "finite_at_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem finite_at_bot {m0 : MeasurableSpace α} (μ : Measure α) : μ.finite_at_filter («expr⊥») :=\n  ⟨∅, mem_bot, by simp only [measure_empty, WithTop.zero_lt_top]⟩\n#align finite_at_bot finite_at_bot\n\n",
 "finiteMeasure_iff_finiteMeasureOnCompacts_of_compactSpace":
 "#print finiteMeasure_iff_finiteMeasureOnCompacts_of_compactSpace /-\n-- see Note [lower instance priority]\ntheorem finiteMeasure_iff_finiteMeasureOnCompacts_of_compactSpace [TopologicalSpace α] [MeasurableSpace α]\n    {μ : measure α} [CompactSpace α] : FiniteMeasure μ ↔ FiniteMeasureOnCompacts μ :=\n  by\n  constructor <;> intros\n  · infer_instance\n  · exact compact_space.is_finite_measure\n#align is_finite_measure_iff_is_finite_measure_on_compacts_of_compact_space finiteMeasure_iff_finiteMeasureOnCompacts_of_compactSpace\n-/\n\n",
 "filter_sup":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\ntheorem filter_sup : μ.finite_at_filter f → μ.finite_at_filter g → μ.finite_at_filter («expr ⊔ » f g) :=\n  fun ⟨s, hsf, hsμ⟩ ⟨t, htg, htμ⟩ =>\n  ⟨s ∪ t, union_mem_sup hsf htg, (measure_union_le s t).trans_lt (ENNReal.add_lt_top.2 ⟨hsμ, htμ⟩)⟩\n#align filter_sup filter_sup\n\n",
 "filter_mono_ae":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\ntheorem filter_mono_ae (h : «expr ⊓ » f μ.ae ≤ g) (hg : μ.finite_at_filter g) : μ.finite_at_filter f :=\n  inf_ae_iff.1 (hg.filter_mono h)\n#align filter_mono_ae filter_mono_ae\n\n",
 "filter_mono":
 "theorem filter_mono (h : f ≤ g) : μ.finite_at_filter g → μ.finite_at_filter f := fun ⟨s, hs, hμ⟩ => ⟨s, h hs, hμ⟩\n#align filter_mono filter_mono\n\n",
 "ext_on_measurable_space_of_generate_finite":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\n/-- If two finite measures give the same mass to the whole space and coincide on a π-system made\nof measurable sets, then they coincide on all sets in the σ-algebra generated by the π-system. -/\ntheorem ext_on_measurable_space_of_generate_finite {α} (m₀ : MeasurableSpace α) {μ ν : Measure α} [FiniteMeasure μ]\n    (C : Set (Set α)) (hμν : ∀ s ∈ C, μ s = ν s) {m : MeasurableSpace α} (h : m ≤ m₀)\n    (hA : m = MeasurableSpace.generateFrom C) (hC : IsPiSystem C) (h_univ : μ Set.univ = ν Set.univ) {s : Set α}\n    (hs : (measurable_set_of m) s) : μ s = ν s :=\n  by\n  haveI : is_finite_measure ν := by\n    constructor\n    rw [← h_univ]\n    apply is_finite_measure.measure_univ_lt_top\n  refine' induction_on_inter hA hC (by simp) hμν _ _ hs\n  · intro t h1t h2t\n    have h1t_ : @MeasurableSet α m₀ t := h _ h1t\n    rw [@measure_compl α m₀ μ t h1t_ (@measure_ne_top α m₀ μ _ t),\n      @measure_compl α m₀ ν t h1t_ (@measure_ne_top α m₀ ν _ t), h_univ, h2t]\n  · intro f h1f h2f h3f\n    have h2f_ : ∀ i : ℕ, @MeasurableSet α m₀ (f i) := fun i => h _ (h2f i)\n    have h_Union :\n      @MeasurableSet α m₀\n        («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (f i)) :=\n      @MeasurableSet.unionᵢ α ℕ m₀ _ f h2f_\n    simp [measure_Union, h_Union, h1f, h3f, h2f_]\n#align ext_on_measurable_space_of_generate_finite ext_on_measurable_space_of_generate_finite\n\n",
 "ext_of_generate_from_of_cover_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/-- Two measures are equal if they are equal on the π-system generating the σ-algebra,\n  and they are both finite on a increasing spanning sequence of sets in the π-system.\n  This lemma is formulated using `sUnion`. -/\ntheorem ext_of_generate_from_of_cover_subset {S T : Set (Set α)} (h_gen : ‹_› = generateFrom S) (h_inter : IsPiSystem S)\n    (h_sub : T ⊆ S) (hc : T.countable) (hU : ⋃₀ T = univ) (htop : ∀ s ∈ T, μ s ≠ ennreal.top)\n    (h_eq : ∀ s ∈ S, μ s = ν s) : μ = ν :=\n  by\n  refine' ext_of_generate_from_of_cover h_gen hc h_inter hU htop _ fun t ht => h_eq t (h_sub ht)\n  intro t ht s hs; cases' (s ∩ t).eq_empty_or_nonempty with H H\n  · simp only [H, measure_empty]\n  · exact h_eq _ (h_inter _ hs _ (h_sub ht) H)\n#align ext_of_generate_from_of_cover_subset ext_of_generate_from_of_cover_subset\n\n",
 "ext_of_generate_from_of_cover":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\ntheorem ext_of_generate_from_of_cover {S T : Set (Set α)} (h_gen : ‹_› = generateFrom S) (hc : T.countable)\n    (h_inter : IsPiSystem S) (hU : ⋃₀ T = univ) (htop : ∀ t ∈ T, μ t ≠ ennreal.top)\n    (ST_eq : ∀ t ∈ T, ∀ s ∈ S, μ (s ∩ t) = ν (s ∩ t)) (T_eq : ∀ t ∈ T, μ t = ν t) : μ = ν :=\n  by\n  refine' ext_of_sUnion_eq_univ hc hU fun t ht => _\n  ext1 u hu\n  simp only [restrict_apply hu]\n  refine' induction_on_inter h_gen h_inter _ (ST_eq t ht) _ _ hu\n  · simp only [Set.empty_inter, measure_empty]\n  · intro v hv hvt\n    have := T_eq t ht\n    rw [Set.inter_comm] at hvt⊢\n    rwa [← measure_inter_add_diff t hv, ← measure_inter_add_diff t hv, ← hvt, ENNReal.add_right_inj] at this\n    exact ne_top_of_le_ne_top (htop t ht) (measure_mono <| Set.inter_subset_left _ _)\n  · intro f hfd hfm h_eq\n    simp only [← restrict_apply (hfm _), ← restrict_apply (MeasurableSet.unionᵢ hfm)] at h_eq⊢\n    simp only [measure_Union hfd hfm, h_eq]\n#align ext_of_generate_from_of_cover ext_of_generate_from_of_cover\n\n",
 "ext_of_generate_from_of_Union":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/-- Two measures are equal if they are equal on the π-system generating the σ-algebra,\n  and they are both finite on a increasing spanning sequence of sets in the π-system.\n  This lemma is formulated using `Union`.\n  `finite_spanning_sets_in.ext` is a reformulation of this lemma. -/\ntheorem ext_of_generate_from_of_Union (C : Set (Set α)) (B : ℕ → Set α) (hA : ‹_› = generateFrom C) (hC : IsPiSystem C)\n    (h1B : «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (B i) = univ)\n    (h2B : ∀ i, B i ∈ C) (hμB : ∀ i, μ (B i) ≠ ennreal.top) (h_eq : ∀ s ∈ C, μ s = ν s) : μ = ν :=\n  by\n  refine' ext_of_generate_from_of_cover_subset hA hC _ (countable_range B) h1B _ h_eq\n  · rintro _ ⟨i, rfl⟩\n    apply h2B\n  · rintro _ ⟨i, rfl⟩\n    apply hμB\n#align ext_of_generate_from_of_Union ext_of_generate_from_of_Union\n\n",
 "ext_of_generate_finite":
 "/-- Two finite measures are equal if they are equal on the π-system generating the σ-algebra\n  (and `univ`). -/\ntheorem ext_of_generate_finite (C : Set (Set α)) (hA : m0 = generateFrom C) (hC : IsPiSystem C) [FiniteMeasure μ]\n    (hμν : ∀ s ∈ C, μ s = ν s) (h_univ : μ univ = ν univ) : μ = ν :=\n  Measure.ext fun s hs => ext_on_measurableSpace_of_generate_finite m0 C hμν le_rfl hA hC h_univ hs\n#align ext_of_generate_finite ext_of_generate_finite\n\n",
 "ext_iff_of_sUnion_eq_univ":
 "/-- Two measures are equal if they have equal restrictions on a spanning collection of sets\n  (formulated using `sUnion`). -/\ntheorem ext_iff_of_sUnion_eq_univ {S : Set (Set α)} (hc : S.countable) (hs : ⋃₀ S = univ) :\n    μ = ν ↔ ∀ s ∈ S, μ.restrict s = ν.restrict s :=\n  ext_iff_of_bunionᵢ_eq_univ hc <| by rwa [← sUnion_eq_bUnion]\n#align ext_iff_of_sUnion_eq_univ ext_iff_of_sUnion_eq_univ\n\n",
 "ext_iff_of_bUnion_eq_univ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/-- Two measures are equal if they have equal restrictions on a spanning collection of sets\n  (formulated using `bUnion`). -/\ntheorem ext_iff_of_bUnion_eq_univ {S : Set ι} {s : ι → Set α} (hc : S.countable)\n    (hs :\n      «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (s i) = univ) :\n    μ = ν ↔ ∀ i ∈ S, μ.restrict (s i) = ν.restrict (s i) := by\n  rw [← restrict_bUnion_congr hc, hs, restrict_univ, restrict_univ]\n#align ext_iff_of_bUnion_eq_univ ext_iff_of_bUnion_eq_univ\n\n",
 "ext_iff_of_Union_eq_univ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/-- Two measures are equal if they have equal restrictions on a spanning collection of sets\n  (formulated using `Union`). -/\ntheorem ext_iff_of_Union_eq_univ [Countable ι] {s : ι → Set α}\n    (hs :\n      «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (s i) = univ) :\n    μ = ν ↔ ∀ i, μ.restrict (s i) = ν.restrict (s i) := by rw [← restrict_Union_congr, hs, restrict_univ, restrict_univ]\n#align ext_iff_of_Union_eq_univ ext_iff_of_Union_eq_univ\n\n",
 "ext":
 "/-- An extensionality for measures. It is `ext_of_generate_from_of_Union` formulated in terms of\n`finite_spanning_sets_in`. -/\nprotected theorem ext {ν : Measure α} {C : Set (Set α)} (hA : ‹_› = generateFrom C) (hC : IsPiSystem C)\n    (h : μ.finite_spanning_sets_in C) (h_eq : ∀ s ∈ C, μ s = ν s) : μ = ν :=\n  ext_of_generateFrom_of_unionᵢ C _ hA hC h.spanning h.set_mem (fun i => (h.finite i).ne) h_eq\n#align ext ext\n\n",
 "exists_subset_measure_lt_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/-- In a σ-finite space, any measurable set of measure `> r` contains a measurable subset of\nfinite measure `> r`. -/\ntheorem exists_subset_measure_lt_top [SigmaFinite μ] {r : ennreal} (hs : MeasurableSet s) (h's : r < μ s) :\n    ∃ t, MeasurableSet t ∧ t ⊆ s ∧ r < μ t ∧ μ t < ennreal.top :=\n  by\n  rw [← supr_restrict_spanning_sets hs, @lt_supᵢ_iff _ _ _ r fun i : ℕ => μ.restrict (spanning_sets μ i) s] at h's\n  rcases h's with ⟨n, hn⟩\n  simp only [restrict_apply hs] at hn\n  refine' ⟨s ∩ spanning_sets μ n, hs.inter (measurable_spanning_sets _ _), inter_subset_left _ _, hn, _⟩\n  exact (measure_mono (inter_subset_right _ _)).trans_lt (measure_spanning_sets_lt_top _ _)\n#align exists_subset_measure_lt_top exists_subset_measure_lt_top\n\n",
 "exists_preimage_eq_of_preimage_ae":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/-- By replacing a measurable set that is almost invariant with the `limsup` of its preimages, we\nobtain a measurable set that is almost equal and strictly invariant.\n\n(The `liminf` would work just as well.) -/\ntheorem exists_preimage_eq_of_preimage_ae {f : α → α} (h : QuasiMeasurePreserving f μ μ) (hs : MeasurableSet s)\n    (hs' : «expr =ᵐ[ ] » («expr ⁻¹' » f s) μ s) :\n    ∃ t : Set α, MeasurableSet t ∧ «expr =ᵐ[ ] » t μ s ∧ «expr ⁻¹' » f t = t :=\n  ⟨limsup (fun n => («expr ^[ ]» (preimage f) n) s) atTop,\n    MeasurableSet.measurableSet_limsup fun n => @preimage_iterate_eq α f n ▸ h.measurable.iterate n hs,\n    h.limsup_preimage_iterate_ae_eq hs', (CompleteLatticeHom.setPreimage f).apply_limsup_iterate s⟩\n#align exists_preimage_eq_of_preimage_ae exists_preimage_eq_of_preimage_ae\n\n",
 "exists_pos_preimage_ball":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem exists_pos_preimage_ball [PseudoMetricSpace δ] (f : α → δ) (x : δ) (hμ : μ ≠ 0) :\n    ∃ n : ℕ, 0 < μ («expr ⁻¹' » f (Metric.ball x n)) :=\n  exists_pos_measure_of_cover (by rw [← preimage_Union, Metric.unionᵢ_ball_nat, preimage_univ]) hμ\n#align exists_pos_preimage_ball exists_pos_preimage_ball\n\n",
 "exists_pos_measure_of_cover":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\ntheorem exists_pos_measure_of_cover [Countable ι] {U : ι → Set α}\n    (hU : «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (U i) = univ)\n    (hμ : μ ≠ 0) : ∃ i, 0 < μ (U i) := by\n  contrapose! hμ with H\n  rw [← measure_univ_eq_zero, ← hU]\n  exact measure_Union_null fun i => nonpos_iff_eq_zero.1 (H i)\n#align exists_pos_measure_of_cover exists_pos_measure_of_cover\n\n",
 "exists_pos_ball":
 "theorem exists_pos_ball [PseudoMetricSpace α] (x : α) (hμ : μ ≠ 0) : ∃ n : ℕ, 0 < μ (Metric.ball x n) :=\n  exists_pos_preimage_ball id x hμ\n#align exists_pos_ball exists_pos_ball\n\n",
 "exists_open_superset_measure_lt_top'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (U «expr ⊇ » s) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊇ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/-- If `s` is a compact set and `μ` is finite at `𝓝 x` for every `x ∈ s`, then `s` admits an open\nsuperset of finite measure. -/\ntheorem exists_open_superset_measure_lt_top' (h : IsCompact s) (hμ : ∀ x ∈ s, μ.finite_at_filter ((nhds) x)) :\n    ∃ (U : _)(_ : «expr ⊇ » U s), IsOpen U ∧ μ U < ennreal.top :=\n  by\n  refine' IsCompact.induction_on h _ _ _ _\n  · use ∅\n    simp [superset]\n  · rintro s t hst ⟨U, htU, hUo, hU⟩\n    exact ⟨U, hst.trans htU, hUo, hU⟩\n  · rintro s t ⟨U, hsU, hUo, hU⟩ ⟨V, htV, hVo, hV⟩\n    refine'\n      ⟨U ∪ V, union_subset_union hsU htV, hUo.union hVo,\n        (measure_union_le _ _).trans_lt <| ENNReal.add_lt_top.2 ⟨hU, hV⟩⟩\n  · intro x hx\n    rcases(hμ x hx).exists_mem_basis (nhds_basis_opens _) with ⟨U, ⟨hx, hUo⟩, hU⟩\n    exact ⟨U, nhdsWithin_le_nhds (hUo.mem_nhds hx), U, subset.rfl, hUo, hU⟩\n#align exists_open_superset_measure_lt_top' exists_open_superset_measure_lt_top'\n\n",
 "exists_open_superset_measure_lt_top":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (U «expr ⊇ » s) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊇ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/-- If `s` is a compact set and `μ` is a locally finite measure, then `s` admits an open superset of\nfinite measure. -/\ntheorem exists_open_superset_measure_lt_top (h : IsCompact s) (μ : measure α) [LocallyFiniteMeasure μ] :\n    ∃ (U : _)(_ : «expr ⊇ » U s), IsOpen U ∧ μ U < ennreal.top :=\n  h.exists_open_superset_measure_lt_top' fun x hx => μ.finite_at_nhds x\n#align exists_open_superset_measure_lt_top exists_open_superset_measure_lt_top\n\n",
 "exists_nonempty_inter_of_measure_univ_lt_tsum_measure":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , » -/\n/-- Pigeonhole principle for measure spaces: if `∑' i, μ (s i) > μ univ`, then\none of the intersections `s i ∩ s j` is not empty. -/\ntheorem exists_nonempty_inter_of_measure_univ_lt_tsum_measure {m : MeasurableSpace α} (μ : Measure α) {s : ι → Set α}\n    (hs : ∀ i, MeasurableSet (s i))\n    (H :\n      μ (univ : Set α) <\n        «expr∑' , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , »\" (μ (s i))) :\n    ∃ (i j : _)(h : i ≠ j), (s i ∩ s j).nonempty := by\n  contrapose! H\n  apply tsum_measure_le_measure_univ hs\n  intro i j hij\n  rw [function.on_fun, disjoint_iff_inf_le]\n  exact fun x hx => H i j hij ⟨x, hx⟩\n#align exists_nonempty_inter_of_measure_univ_lt_tsum_measure exists_nonempty_inter_of_measure_univ_lt_tsum_measure\n\n",
 "exists_nonempty_inter_of_measure_univ_lt_sum_measure":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/-- Pigeonhole principle for measure spaces: if `s` is a `finset` and\n`∑ i in s, μ (t i) > μ univ`, then one of the intersections `t i ∩ t j` is not empty. -/\ntheorem exists_nonempty_inter_of_measure_univ_lt_sum_measure {m : MeasurableSpace α} (μ : Measure α) {s : Finset ι}\n    {t : ι → Set α} (h : ∀ i ∈ s, MeasurableSet (t i))\n    (H :\n      μ (univ : Set α) <\n        finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s (μ (t i))) :\n    ∃ i ∈ s, ∃ j ∈ s, ∃ h : i ≠ j, (t i ∩ t j).nonempty :=\n  by\n  contrapose! H\n  apply sum_measure_le_measure_univ h\n  intro i hi j hj hij\n  rw [function.on_fun, disjoint_iff_inf_le]\n  exact fun x hx => H i hi j hj hij ⟨x, hx⟩\n#align exists_nonempty_inter_of_measure_univ_lt_sum_measure exists_nonempty_inter_of_measure_univ_lt_sum_measure\n\n",
 "exists_ne_forall_mem_nhds_pos_measure_preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∃ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem exists_ne_forall_mem_nhds_pos_measure_preimage {β} [TopologicalSpace β] [T1Space β] [SecondCountableTopology β]\n    [Nonempty β] {f : α → β}\n    (h :\n      ∀ b,\n        «expr∃ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᵐ ∂ , »\" μ\n          (f x ≠ b)) :\n    ∃ a b : β, a ≠ b ∧ (∀ s ∈ (nhds) a, 0 < μ («expr ⁻¹' » f s)) ∧ ∀ t ∈ (nhds) b, 0 < μ («expr ⁻¹' » f t) :=\n  by\n  -- We use an `outer_measure` so that the proof works without `measurable f`\n  set m : outer_measure β := outer_measure.map f μ.to_outer_measure\n  replace h : ∀ b : β, m («expr ᶜ» {b}) ≠ 0 := fun b => not_eventually.mpr (h b)\n  inhabit β\n  have : m univ ≠ 0 := ne_bot_of_le_ne_bot (h default) (m.mono' <| subset_univ _)\n  rcases m.exists_mem_forall_mem_nhds_within_pos this with ⟨b, -, hb⟩\n  simp only [nhdsWithin_univ] at hb\n  rcases m.exists_mem_forall_mem_nhds_within_pos (h b) with ⟨a, hab : a ≠ b, ha⟩\n  simp only [is_open_compl_singleton.nhds_within_eq hab] at ha\n  exact ⟨a, b, hab, ha, hb⟩\n#align exists_ne_forall_mem_nhds_pos_measure_preimage exists_ne_forall_mem_nhds_pos_measure_preimage\n\n",
 "exists_mem_of_measure_ne_zero_of_ae":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\ntheorem exists_mem_of_measure_ne_zero_of_ae (hs : μ s ≠ 0) {p : α → Prop}\n    (hp :\n      «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\"\n        (μ.restrict s) (p x)) :\n    ∃ x, x ∈ s ∧ p x := by\n  rw [← μ.restrict_apply_self, ← frequently_ae_mem_iff] at hs\n  exact (hs.and_eventually hp).exists\n#align exists_mem_of_measure_ne_zero_of_ae exists_mem_of_measure_ne_zero_of_ae\n\n",
 "exists_mem_forall_mem_nhds_within_pos_measure":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\ntheorem exists_mem_forall_mem_nhds_within_pos_measure [TopologicalSpace α] [SecondCountableTopology α] {s : Set α}\n    (hs : μ s ≠ 0) : ∃ x ∈ s, ∀ t ∈ nhds_within s x, 0 < μ t :=\n  μ.to_outer_measure.exists_mem_forall_mem_nhds_within_pos hs\n#align exists_mem_forall_mem_nhds_within_pos_measure exists_mem_forall_mem_nhds_within_pos_measure\n\n",
 "exists_mem_basis":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\ntheorem finite_at_filter.exists_mem_basis {f : Filter α} (hμ : FiniteAtFilter μ f) {p : ι → Prop} {s : ι → Set α}\n    (hf : f.has_basis p s) : ∃ (i : _)(hi : p i), μ (s i) < ennreal.top :=\n  (hf.exists_iff fun s t hst ht => (measure_mono hst).trans_lt ht).1 hμ\n#align finite_at_filter.exists_mem_basis finite_at_filter.exists_mem_basis\n\n",
 "exists_measure_inter_spanning_sets_pos":
 "/-- A set in a σ-finite space has positive measure if and only if its intersection with\nsome member of the countable family of finite measure spanning sets has positive measure. -/\ntheorem exists_measure_inter_spanning_sets_pos [MeasurableSpace α] {μ : Measure α} [SigmaFinite μ] (s : Set α) :\n    (∃ n, 0 < μ (s ∩ spanningSets μ n)) ↔ 0 < μ s :=\n  by\n  rw [← not_iff_not]\n  simp only [not_exists, not_lt, nonpos_iff_eq_zero]\n  exact forall_measure_inter_spanning_sets_eq_zero s\n#align exists_measure_inter_spanning_sets_pos exists_measure_inter_spanning_sets_pos\n\n",
 "exists_is_open_measure_lt_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\ntheorem measure.exists_is_open_measure_lt_top [TopologicalSpace α] (μ : Measure α) [LocallyFiniteMeasure μ] (x : α) :\n    ∃ s : Set α, x ∈ s ∧ IsOpen s ∧ μ s < ennreal.top := by\n  simpa only [exists_prop, and_assoc] using (μ.finite_at_nhds x).exists_mem_basis (nhds_basis_opens x)\n#align measure.exists_is_open_measure_lt_top measure.exists_is_open_measure_lt_top\n\n",
 "exists_eq_disjoint_finite_spanning_sets_in":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr on » -/\ntheorem exists_eq_disjoint_finite_spanning_sets_in (μ ν : Measure α) [SigmaFinite μ] [SigmaFinite ν] :\n    ∃ (S : μ.finite_spanning_sets_in { s | MeasurableSet s })(T : ν.finite_spanning_sets_in { s | MeasurableSet s }),\n      S.set = T.set ∧ Pairwise («expr on » Disjoint S.set) :=\n  let S := (μ + ν).to_finite_spanning_sets_in.disjointed\n  ⟨S.of_le (Measure.le_add_right le_rfl), S.of_le (Measure.le_add_left le_rfl), rfl, disjoint_disjointed _⟩\n#align exists_eq_disjoint_finite_spanning_sets_in exists_eq_disjoint_finite_spanning_sets_in\n\n",
 "eventually_mem_spanning_sets":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\ntheorem eventually_mem_spanning_sets (μ : Measure α) [SigmaFinite μ] (x : α) :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" atTop\n      (x ∈ spanningSets μ n) :=\n  eventually_atTop.2 ⟨spanningSetsIndex μ x, fun b => mem_spanningSets_of_index_le μ x⟩\n#align eventually_mem_spanning_sets eventually_mem_spanning_sets\n\n",
 "eventually_cofinite":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\ntheorem eventually_cofinite {p : α → Prop} :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" μ.cofinite\n        (p x) ↔\n      μ { x | ¬p x } < ennreal.top :=\n  iff.rfl\n#align eventually_cofinite eventually_cofinite\n\n",
 "eventually":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\nprotected theorem eventually (h : μ.finite_at_filter f) :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" f.small_sets\n      (μ s < ennreal.top) :=\n  (eventually_small_sets' fun s t hst ht => (measure_mono hst).trans_lt ht).2 h\n#align eventually eventually\n\n",
 "eq_zero_of_is_empty":
 "theorem eq_zero_of_is_empty [IsEmpty α] {m : MeasurableSpace α} (μ : Measure α) : μ = 0 :=\n  subsingleton.elim μ 0\n#align eq_zero_of_is_empty eq_zero_of_is_empty\n\n",
 "empty_of_count_eq_zero'":
 "theorem empty_of_count_eq_zero' (s_mble : MeasurableSet s) (hsc : count s = 0) : s = ∅ :=\n  by\n  have hs : s.finite := by\n    rw [← count_apply_lt_top' s_mble, hsc]\n    exact WithTop.zero_lt_top\n  simpa [count_apply_finite' hs s_mble] using hsc\n#align empty_of_count_eq_zero' empty_of_count_eq_zero'\n\n",
 "empty_of_count_eq_zero":
 "theorem empty_of_count_eq_zero [MeasurableSingletonClass α] (hsc : count s = 0) : s = ∅ :=\n  by\n  have hs : s.finite := by\n    rw [← count_apply_lt_top, hsc]\n    exact WithTop.zero_lt_top\n  simpa [count_apply_finite _ hs] using hsc\n#align empty_of_count_eq_zero empty_of_count_eq_zero\n\n",
 "disjointed_set_eq":
 "theorem finite_spanning_sets_in.disjointed_set_eq {μ : Measure α}\n    (S : μ.finite_spanning_sets_in { s | MeasurableSet s }) : S.disjointed.set = disjointed S.set :=\n  rfl\n#align finite_spanning_sets_in.disjointed_set_eq finite_spanning_sets_in.disjointed_set_eq\n\n",
 "dirac_apply_of_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n@[simp]\ntheorem dirac_apply_of_mem {a : α} (h : a ∈ s) : dirac a s = 1 :=\n  by\n  have : ∀ t : Set α, a ∈ t → t.indicator (1 : α → ennreal) a = 1 := fun t ht => indicator_of_mem ht 1\n  refine' le_antisymm (this univ trivial ▸ _) (this s h ▸ le_dirac_apply)\n  rw [← dirac_apply' a MeasurableSet.univ]\n  exact measure_mono (subset_univ s)\n#align dirac_apply_of_mem dirac_apply_of_mem\n\n",
 "dirac_apply'":
 "@[simp]\ntheorem dirac_apply' (a : α) (hs : MeasurableSet s) : dirac a s = s.indicator 1 a :=\n  toMeasure_apply _ _ hs\n#align dirac_apply' dirac_apply'\n\n",
 "dirac_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n@[simp]\ntheorem dirac_apply [MeasurableSingletonClass α] (a : α) (s : Set α) : dirac a s = s.indicator 1 a :=\n  by\n  by_cases h : a ∈ s; · rw [dirac_apply_of_mem h, indicator_of_mem h, Pi.one_apply]\n  rw [indicator_of_not_mem h, ← nonpos_iff_eq_zero]\n  calc\n    dirac a s ≤ dirac a («expr ᶜ» {a}) := measure_mono (subset_compl_comm.1 <| singleton_subset_iff.2 h)\n    _ = 0 := by simp [dirac_apply' _ (measurable_set_singleton _).compl]\n    \n#align dirac_apply dirac_apply\n\n",
 "countable_meas_pos_of_disjoint_of_meas_Union_ne_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr on » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/-- If the union of disjoint measurable sets has finite measure, then there are only\ncountably many members of the union whose measure is positive. -/\ntheorem countable_meas_pos_of_disjoint_of_meas_Union_ne_top {ι : Type _} [MeasurableSpace α] (μ : Measure α)\n    {As : ι → Set α} (As_mble : ∀ i : ι, MeasurableSet (As i)) (As_disj : Pairwise («expr on » Disjoint As))\n    (Union_As_finite :\n      μ («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (As i)) ≠\n        ennreal.top) :\n    Set.Countable { i : ι | 0 < μ (As i) } :=\n  by\n  set posmeas := { i : ι | 0 < μ (As i) } with posmeas_def\n  rcases exists_seq_strictAnti_tendsto' (zero_lt_one : (0 : ennreal) < 1) with ⟨as, as_decr, as_mem, as_lim⟩\n  set fairmeas := fun n : ℕ => { i : ι | as n ≤ μ (As i) } with fairmeas_def\n  have countable_union :\n    posmeas =\n      «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (fairmeas n) :=\n    by\n    have fairmeas_eq : ∀ n, fairmeas n = «expr ⁻¹' » (fun i => μ (As i)) (Ici (as n)) := fun n => by\n      simpa only [fairmeas_def]\n    simpa only [fairmeas_eq, posmeas_def, ← preimage_Union,\n      unionᵢ_Ici_eq_Ioi_of_lt_of_tendsto (0 : ennreal) (fun n => (as_mem n).1) as_lim]\n  rw [countable_union]\n  refine' countable_Union fun n => finite.countable _\n  refine' finite_const_le_meas_of_disjoint_Union μ (as_mem n).1 As_mble As_disj Union_As_finite\n#align countable_meas_pos_of_disjoint_of_meas_Union_ne_top countable_meas_pos_of_disjoint_of_meas_Union_ne_top\n\n",
 "countable_meas_pos_of_disjoint_Union":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr on » -/\n/-- In a σ-finite space, among disjoint measurable sets, only countably many can have positive\nmeasure. -/\ntheorem countable_meas_pos_of_disjoint_Union {ι : Type _} [MeasurableSpace α] {μ : Measure α} [SigmaFinite μ]\n    {As : ι → Set α} (As_mble : ∀ i : ι, MeasurableSet (As i)) (As_disj : Pairwise («expr on » Disjoint As)) :\n    Set.Countable { i : ι | 0 < μ (As i) } :=\n  by\n  have obs :\n    { i : ι | 0 < μ (As i) } ⊆\n      «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n        { i : ι | 0 < μ (As i ∩ spanning_sets μ n) } :=\n    by\n    intro i i_in_nonzeroes\n    by_contra con\n    simp only [mem_Union, mem_set_of_eq, not_exists, not_lt, nonpos_iff_eq_zero] at *\n    simpa [(forall_measure_inter_spanning_sets_eq_zero _).mp Con] using i_in_nonzeroes\n  apply countable.mono obs\n  refine' countable_Union fun n => countable_meas_pos_of_disjoint_of_meas_Union_ne_top μ _ _ _\n  · exact fun i => MeasurableSet.inter (As_mble i) (measurable_spanning_sets μ n)\n  ·\n    exact fun i j i_ne_j b hbi hbj =>\n      As_disj i_ne_j (hbi.trans (inter_subset_left _ _)) (hbj.trans (inter_subset_left _ _))\n  · refine' (lt_of_le_of_lt (measure_mono _) (measure_spanning_sets_lt_top μ n)).ne\n    exact Union_subset fun i => inter_subset_right _ _\n#align countable_meas_pos_of_disjoint_Union countable_meas_pos_of_disjoint_Union\n\n",
 "countable_meas_level_set_pos":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr on » -/\ntheorem countable_meas_level_set_pos {α β : Type _} [MeasurableSpace α] {μ : Measure α} [SigmaFinite μ]\n    [MeasurableSpace β] [MeasurableSingletonClass β] {g : α → β} (g_mble : Measurable g) :\n    Set.Countable { t : β | 0 < μ { a : α | g a = t } } :=\n  haveI level_sets_disjoint : Pairwise («expr on » Disjoint fun t : β => { a : α | g a = t }) := fun s t hst =>\n    Disjoint.preimage g (disjoint_singleton.mpr hst)\n  measure.countable_meas_pos_of_disjoint_Union\n    (fun b => g_mble (‹MeasurableSingletonClass β›.measurable_set_singleton b)) level_sets_disjoint\n#align countable_meas_level_set_pos countable_meas_level_set_pos\n\n",
 "count_singleton'":
 "@[simp]\ntheorem count_singleton' {a : α} (ha : MeasurableSet ({a} : Set α)) : count ({a} : Set α) = 1 :=\n  by\n  rw [count_apply_finite' (Set.finite_singleton a) ha, Set.Finite.toFinset]\n  simp\n#align count_singleton' count_singleton'\n\n",
 "count_singleton":
 "@[simp]\ntheorem count_singleton [MeasurableSingletonClass α] (a : α) : count ({a} : Set α) = 1 :=\n  count_singleton' (measurable_set_singleton a)\n#align count_singleton count_singleton\n\n",
 "count_ne_zero'":
 "theorem count_ne_zero' (hs' : s.nonempty) (s_mble : MeasurableSet s) : count s ≠ 0 :=\n  by\n  rw [ne.def, count_eq_zero_iff' s_mble]\n  exact hs'.ne_empty\n#align count_ne_zero' count_ne_zero'\n\n",
 "count_ne_zero":
 "theorem count_ne_zero [MeasurableSingletonClass α] (hs' : s.nonempty) : count s ≠ 0 :=\n  by\n  rw [ne.def, count_eq_zero_iff]\n  exact hs'.ne_empty\n#align count_ne_zero count_ne_zero\n\n",
 "count_injective_image'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem count_injective_image' {f : β → α} (hf : function.injective f) {s : Set β} (s_mble : MeasurableSet s)\n    (fs_mble : MeasurableSet («expr '' » f s)) : count («expr '' » f s) = count s :=\n  by\n  by_cases hs : s.finite\n  · lift s to Finset β using hs\n    rw [← Finset.coe_image, count_apply_finset' _, count_apply_finset' s_mble, s.card_image_of_injective hf]\n    simpa only [Finset.coe_image] using fs_mble\n  rw [count_apply_infinite hs]\n  rw [← finite_image_iff <| hf.inj_on _] at hs\n  rw [count_apply_infinite hs]\n#align count_injective_image' count_injective_image'\n\n",
 "count_injective_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem count_injective_image [MeasurableSingletonClass α] [MeasurableSingletonClass β] {f : β → α}\n    (hf : function.injective f) (s : Set β) : count («expr '' » f s) = count s :=\n  by\n  by_cases hs : s.finite\n  · exact count_injective_image' hf hs.measurable_set (finite.image f hs).measurable_set\n  rw [count_apply_infinite hs]\n  rw [← finite_image_iff <| hf.inj_on _] at hs\n  rw [count_apply_infinite hs]\n#align count_injective_image count_injective_image\n\n",
 "count_eq_zero_iff'":
 "@[simp]\ntheorem count_eq_zero_iff' (s_mble : MeasurableSet s) : count s = 0 ↔ s = ∅ :=\n  ⟨empty_of_count_eq_zero' s_mble, fun h => h.symm ▸ count_empty⟩\n#align count_eq_zero_iff' count_eq_zero_iff'\n\n",
 "count_eq_zero_iff":
 "@[simp]\ntheorem count_eq_zero_iff [MeasurableSingletonClass α] : count s = 0 ↔ s = ∅ :=\n  ⟨empty_of_count_eq_zero, fun h => h.symm ▸ count_empty⟩\n#align count_eq_zero_iff count_eq_zero_iff\n\n",
 "count_empty":
 "@[simp]\ntheorem count_empty : count (∅ : Set α) = 0 := by rw [count_apply MeasurableSet.empty, tsum_empty]\n#align count_empty count_empty\n\n",
 "count_apply_lt_top'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n@[simp]\ntheorem count_apply_lt_top' (s_mble : MeasurableSet s) : count s < ennreal.top ↔ s.finite :=\n  calc\n    count s < ennreal.top ↔ count s ≠ ennreal.top := lt_top_iff_ne_top\n    _ ↔ ¬s.infinite := (not_congr (count_apply_eq_top' s_mble))\n    _ ↔ s.finite := Classical.not_not\n    \n#align count_apply_lt_top' count_apply_lt_top'\n\n",
 "count_apply_lt_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n@[simp]\ntheorem count_apply_lt_top [MeasurableSingletonClass α] : count s < ennreal.top ↔ s.finite :=\n  calc\n    count s < ennreal.top ↔ count s ≠ ennreal.top := lt_top_iff_ne_top\n    _ ↔ ¬s.infinite := (not_congr count_apply_eq_top)\n    _ ↔ s.finite := Classical.not_not\n    \n#align count_apply_lt_top count_apply_lt_top\n\n",
 "count_apply_infinite":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/-- `count` measure evaluates to infinity at infinite sets. -/\ntheorem count_apply_infinite (hs : s.infinite) : count s = ennreal.top :=\n  by\n  refine' top_unique (le_of_tendsto' ENNReal.tendsto_nat_nhds_top fun n => _)\n  rcases hs.exists_subset_card_eq n with ⟨t, ht, rfl⟩\n  calc\n    (t.card : ennreal) =\n        finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" t 1 :=\n      by simp\n    _ = «expr∑' , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , »\" 1 :=\n      (t.tsum_subtype 1).symm\n    _ ≤ count (t : Set α) := le_count_apply\n    _ ≤ count s := measure_mono ht\n    \n#align count_apply_infinite count_apply_infinite\n\n",
 "count_apply_finset'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , » -/\n@[simp]\ntheorem count_apply_finset' {s : Finset α} (s_mble : MeasurableSet (s : Set α)) : count (↑s : Set α) = s.card :=\n  calc\n    count (↑s : Set α) =\n        «expr∑' , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , »\" 1 :=\n      count_apply s_mble\n    _ = finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s 1 :=\n      (s.tsum_subtype 1)\n    _ = s.card := by simp\n    \n#align count_apply_finset' count_apply_finset'\n\n",
 "count_apply_finset":
 "@[simp]\ntheorem count_apply_finset [MeasurableSingletonClass α] (s : Finset α) : count (↑s : Set α) = s.card :=\n  count_apply_finset' s.measurable_set\n#align count_apply_finset count_apply_finset\n\n",
 "count_apply_finite'":
 "theorem count_apply_finite' {s : Set α} (s_fin : s.finite) (s_mble : MeasurableSet s) :\n    count s = s_fin.to_finset.card := by\n  simp [← @count_apply_finset' _ _ s_fin.to_finset (by simpa only [finite.coe_to_finset] using s_mble)]\n#align count_apply_finite' count_apply_finite'\n\n",
 "count_apply_finite":
 "theorem count_apply_finite [MeasurableSingletonClass α] (s : Set α) (hs : s.finite) : count s = hs.to_finset.card := by\n  rw [← count_apply_finset, finite.coe_to_finset]\n#align count_apply_finite count_apply_finite\n\n",
 "count_apply_eq_top'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n@[simp]\ntheorem count_apply_eq_top' (s_mble : MeasurableSet s) : count s = ennreal.top ↔ s.infinite :=\n  by\n  by_cases hs : s.finite\n  · simp [Set.Infinite, hs, count_apply_finite' hs s_mble]\n  · change s.infinite at hs\n    simp [hs, count_apply_infinite]\n#align count_apply_eq_top' count_apply_eq_top'\n\n",
 "count_apply_eq_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n@[simp]\ntheorem count_apply_eq_top [MeasurableSingletonClass α] : count s = ennreal.top ↔ s.infinite :=\n  by\n  by_cases hs : s.finite\n  · exact count_apply_eq_top' hs.measurable_set\n  · change s.infinite at hs\n    simp [hs, count_apply_infinite]\n#align count_apply_eq_top count_apply_eq_top\n\n",
 "count_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , » -/\ntheorem count_apply (hs : MeasurableSet s) :\n    count s = «expr∑' , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , »\" 1 := by\n  simp only [count, sum_apply, hs, dirac_apply', ← tsum_subtype s 1, Pi.one_apply]\n#align count_apply count_apply\n\n",
 "compl_mem_cofinite":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\ntheorem compl_mem_cofinite : «expr ᶜ» s ∈ μ.cofinite ↔ μ s < ennreal.top := by rw [mem_cofinite, compl_compl]\n#align compl_mem_cofinite compl_mem_cofinite\n\n",
 "comp":
 "protected theorem comp {g : β → γ} {f : α → β} (hg : QuasiMeasurePreserving g μb μc)\n    (hf : QuasiMeasurePreserving f μa μb) : QuasiMeasurePreserving (g ∘ f) μa μc :=\n  ⟨hg.measurable.comp hf.measurable, by\n    rw [← map_map hg.1 hf.1]\n    exact (hf.2.map hg.1).trans hg.2⟩\n#align comp comp\n\n",
 "comapₗ_eq_comap":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem comapₗ_eq_comap {β} [MeasurableSpace α] {mβ : MeasurableSpace β} (f : α → β) (hfi : injective f)\n    (hf : ∀ s, MeasurableSet s → MeasurableSet («expr '' » f s)) (μ : Measure β) (hs : MeasurableSet s) :\n    comapₗ f μ s = comap f μ s :=\n  (comapₗ_apply f hfi hf μ hs).trans (comap_apply f hfi hf μ hs).symm\n#align comapₗ_eq_comap comapₗ_eq_comap\n\n",
 "comapₗ_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem comapₗ_apply {β} [MeasurableSpace α] {mβ : MeasurableSpace β} (f : α → β) (hfi : injective f)\n    (hf : ∀ s, MeasurableSet s → MeasurableSet («expr '' » f s)) (μ : Measure β) (hs : MeasurableSet s) :\n    comapₗ f μ s = μ («expr '' » f s) :=\n  by\n  rw [comapₗ, dif_pos, lift_linear_apply _ hs, outer_measure.comap_apply, coe_to_outer_measure]\n  exact ⟨hfi, hf⟩\n#align comapₗ_apply comapₗ_apply\n\n",
 "comap_subtype_coe_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n#print comap_subtype_coe_apply /-\ntheorem comap_subtype_coe_apply {m0 : MeasurableSpace α} {s : Set α} (hs : MeasurableSet s) (μ : measure α)\n    (t : Set s) : comap coe μ t = μ («expr '' » coe t) :=\n  (MeasurableEmbedding.subtype_coe hs).comap_apply _ _\n#align comap_subtype_coe_apply comap_subtype_coe_apply\n-/\n\n",
 "comap_preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\nprotected theorem comap_preimage (μ : measure β) {s : Set β} (hs : MeasurableSet s) :\n    μ.comap f («expr ⁻¹' » f s) = μ (s ∩ range f) :=\n  comap_preimage _ _ hf.injective hf.measurable (fun t ht => (hf.measurable_set_image' ht).null_measurable_set) hs\n#align comap_preimage comap_preimage\n\n",
 "comap_apply₀":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem comap_apply₀ [MeasurableSpace α] (f : α → β) (μ : Measure β) (hfi : injective f)\n    (hf : ∀ s, MeasurableSet s → NullMeasurableSet («expr '' » f s) μ) (hs : NullMeasurableSet s (comap f μ)) :\n    comap f μ s = μ («expr '' » f s) :=\n  by\n  rw [comap, dif_pos (and.intro hfi hf)] at hs⊢\n  rw [to_measure_apply₀ _ _ hs, outer_measure.comap_apply, coe_to_outer_measure]\n#align comap_apply₀ comap_apply₀\n\n",
 "comap_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem comap_apply (μ : measure β) (s : Set α) : comap f μ s = μ («expr '' » f s) :=\n  calc\n    comap f μ s = comap f μ («expr ⁻¹' » f («expr '' » f s)) := by rw [hf.injective.preimage_image]\n    _ = (comap f μ).map f («expr '' » f s) := (hf.map_apply _ _).symm\n    _ = μ («expr '' » f s) := by\n      rw [hf.map_comap, restrict_apply' hf.measurable_set_range, inter_eq_self_of_subset_left (image_subset_range _ _)]\n    \n#align comap_apply comap_apply\n\n",
 "coe_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n@[simp, norm_cast]\ntheorem coe_zero {m : MeasurableSpace α} : «expr⇑ » (0 : Measure α) = 0 :=\n  rfl\n#align coe_zero coe_zero\n\n",
 "coe_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp, norm_cast]\ntheorem coe_smul {m : MeasurableSpace α} (c : R) (μ : Measure α) : «expr⇑ » («expr • » c μ) = «expr • » c μ :=\n  rfl\n#align coe_smul coe_smul\n\n",
 "coe_nnreal_smul_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem coe_nnreal_smul_apply {m : MeasurableSpace α} (c : nnreal) (μ : Measure α) (s : Set α) :\n    («expr • » c μ) s = c * μ s :=\n  rfl\n#align coe_nnreal_smul_apply coe_nnreal_smul_apply\n\n",
 "coe_measure_univ_nnreal":
 "@[simp]\ntheorem coe_measure_univ_nnreal (μ : Measure α) [FiniteMeasure μ] : ↑(measureUnivNNReal μ) = μ univ :=\n  ENNReal.coe_toNNReal (measure_ne_top μ univ)\n#align coe_measure_univ_nnreal coe_measure_univ_nnreal\n\n",
 "coe_finset_sum":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n@[simp]\ntheorem coe_finset_sum {m : MeasurableSpace α} (I : Finset ι) (μ : ι → Measure α) :\n    «expr⇑ » (finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" I (μ i)) =\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" I (μ i) :=\n  (@coeAddHom α m).map_sum _ _\n#align coe_finset_sum coe_finset_sum\n\n",
 "coe_add":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n@[simp, norm_cast]\ntheorem coe_add {m : MeasurableSpace α} (μ₁ μ₂ : Measure α) : «expr⇑ » (μ₁ + μ₂) = μ₁ + μ₂ :=\n  rfl\n#align coe_add coe_add\n\n",
 "bsupr_measure_Iic":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\ntheorem bsupr_measure_Iic [preorder α] {s : Set α} (hsc : s.countable) (hst : ∀ x : α, ∃ y ∈ s, x ≤ y)\n    (hdir : DirectedOn (· ≤ ·) s) :\n    «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (μ (Iic x)) =\n      μ univ :=\n  by\n  rw [← measure_bUnion_eq_supr hsc]\n  · congr\n    exact Union₂_eq_univ_iff.2 hst\n  · exact directedOn_iff_directed.2 (hdir.directed_coe.mono_comp _ fun x y => Iic_subset_Iic.2)\n#align bsupr_measure_Iic bsupr_measure_Iic\n\n",
 "bounded_by_measure":
 "@[simp]\ntheorem bounded_by_measure (μ : Measure α) : OuterMeasure.boundedBy μ = μ.to_outer_measure :=\n  μ.to_outer_measure.bounded_by_eq_self\n#align bounded_by_measure bounded_by_measure\n\n",
 "ae_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem ae_zero {m0 : MeasurableSpace α} : (0 : Measure α).ae = «expr⊥» :=\n  ae_eq_bot.2 rfl\n#align ae_zero ae_zero\n\n",
 "ae_uIoc_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprΙ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\n/-\nCopyright (c) 2017 Johannes Hölzl. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johannes Hölzl, Mario Carneiro\n-/\n/-- See also `measure_theory.ae_restrict_uIoc_iff`. -/\ntheorem ae_uIoc_iff [linear_order α] {a b : α} {P : α → Prop} :\n    «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\" μ\n        (x ∈ (exprΙ) a b → P x) ↔\n      «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\" μ\n          (x ∈ Ioc a b → P x) ∧\n        «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\" μ\n          (x ∈ Ioc b a → P x) :=\n  by simp only [uIoc_eq_union, mem_union, or_imp, eventually_and]\n#align ae_uIoc_iff ae_uIoc_iff\n\n",
 "ae_sum_iff'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\ntheorem ae_sum_iff' {μ : ι → Measure α} {p : α → Prop} (h : MeasurableSet { x | p x }) :\n    «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\" (sum μ)\n        (p x) ↔\n      ∀ i,\n        «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\" (μ i)\n          (p x) :=\n  sum_apply_eq_zero' h.compl\n#align ae_sum_iff' ae_sum_iff'\n\n",
 "ae_sum_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\ntheorem ae_sum_iff [Countable ι] {μ : ι → Measure α} {p : α → Prop} :\n    «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\" (sum μ)\n        (p x) ↔\n      ∀ i,\n        «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\" (μ i)\n          (p x) :=\n  sum_apply_eq_zero\n#align ae_sum_iff ae_sum_iff\n\n",
 "ae_sum_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n@[simp]\ntheorem ae_sum_eq [Countable ι] (μ : ι → Measure α) :\n    (sum μ).ae =\n      «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (μ i).ae :=\n  Filter.ext fun s => ae_sum_iff.trans mem_supᵢ.symm\n#align ae_sum_eq ae_sum_eq\n\n",
 "ae_smul_measure_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\ntheorem ae_smul_measure_iff {p : α → Prop} {c : ennreal} (hc : c ≠ 0) :\n    «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\"\n        («expr • » c μ) (p x) ↔\n      «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\" μ (p x) :=\n  by simp [ae_iff, hc]\n#align ae_smul_measure_iff ae_smul_measure_iff\n\n",
 "ae_smul_measure":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem ae_smul_measure {p : α → Prop} [Monoid R] [DistribMulAction R (ennreal)] [IsScalarTower R (ennreal) (ennreal)]\n    (h : «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\" μ (p x))\n    (c : R) :\n    «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\"\n      («expr • » c μ) (p x) :=\n  ae_iff.2 <| by rw [smul_apply, ae_iff.1 h, smul_zero]\n#align ae_smul_measure ae_smul_measure\n\n",
 "ae_restrict_union_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\ntheorem ae_restrict_union_iff (s t : Set α) (p : α → Prop) :\n    «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\"\n        (μ.restrict (s ∪ t)) (p x) ↔\n      «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\"\n          (μ.restrict s) (p x) ∧\n        «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\"\n          (μ.restrict t) (p x) :=\n  by simp\n#align ae_restrict_union_iff ae_restrict_union_iff\n\n",
 "ae_restrict_union_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n@[simp]\ntheorem ae_restrict_union_eq (s t : Set α) : (μ.restrict (s ∪ t)).ae = «expr ⊔ » (μ.restrict s).ae (μ.restrict t).ae :=\n  by simp [union_eq_Union, supᵢ_bool_eq]\n#align ae_restrict_union_eq ae_restrict_union_eq\n\n",
 "ae_restrict_uIoc_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprΙ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\n/-- See also `measure_theory.ae_uIoc_iff`. -/\ntheorem ae_restrict_uIoc_iff [linear_order α] {a b : α} {P : α → Prop} :\n    «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\"\n        (μ.restrict ((exprΙ) a b)) (P x) ↔\n      «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\"\n          (μ.restrict (Ioc a b)) (P x) ∧\n        «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\"\n          (μ.restrict (Ioc b a)) (P x) :=\n  by rw [ae_restrict_uIoc_eq, eventually_sup]\n#align ae_restrict_uIoc_iff ae_restrict_uIoc_iff\n\n",
 "ae_restrict_uIoc_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprΙ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\ntheorem ae_restrict_uIoc_eq [linear_order α] (a b : α) :\n    (μ.restrict ((exprΙ) a b)).ae = «expr ⊔ » (μ.restrict (Ioc a b)).ae (μ.restrict (Ioc b a)).ae := by\n  simp only [uIoc_eq_union, ae_restrict_union_eq]\n#align ae_restrict_uIoc_eq ae_restrict_uIoc_eq\n\n",
 "ae_restrict_of_ae_restrict_of_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\ntheorem ae_restrict_of_ae_restrict_of_subset {s t : Set α} {p : α → Prop} (hst : s ⊆ t)\n    (h :\n      «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\"\n        (μ.restrict t) (p x)) :\n    «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\" (μ.restrict s)\n      (p x) :=\n  h.filter_mono (ae_mono <| Measure.restrict_mono hst (le_refl μ))\n#align ae_restrict_of_ae_restrict_of_subset ae_restrict_of_ae_restrict_of_subset\n\n",
 "ae_restrict_of_ae_eq_of_ae_restrict":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\n/-- If two measurable sets are ae_eq then any proposition that is almost everywhere true on one\nis almost everywhere true on the other -/\ntheorem ae_restrict_of_ae_eq_of_ae_restrict {s t} (hst : «expr =ᵐ[ ] » s μ t) {p : α → Prop} :\n    «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\" (μ.restrict s)\n        (p x) →\n      «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\"\n        (μ.restrict t) (p x) :=\n  by simp [measure.restrict_congr_set hst]\n#align ae_restrict_of_ae_eq_of_ae_restrict ae_restrict_of_ae_eq_of_ae_restrict\n\n",
 "ae_restrict_of_ae":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\ntheorem ae_restrict_of_ae {s : Set α} {p : α → Prop}\n    (h :\n      «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\" μ (p x)) :\n    «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\" (μ.restrict s)\n      (p x) :=\n  Eventually.filter_mono (ae_mono Measure.restrict_le_self) h\n#align ae_restrict_of_ae ae_restrict_of_ae\n\n",
 "ae_restrict_ne_bot":
 "@[simp]\ntheorem ae_restrict_ne_bot {s} : (μ.restrict s).ae.ne_bot ↔ 0 < μ s :=\n  neBot_iff.trans <| (not_congr ae_restrict_eq_bot).trans pos_iff_ne_zero.symm\n#align ae_restrict_ne_bot ae_restrict_ne_bot\n\n",
 "ae_restrict_mem₀":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\ntheorem ae_restrict_mem₀ (hs : NullMeasurableSet s μ) :\n    «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\" (μ.restrict s)\n      (x ∈ s) :=\n  by\n  rcases hs.exists_measurable_subset_ae_eq with ⟨t, hts, htm, ht_eq⟩\n  rw [← restrict_congr_set ht_eq]\n  exact (ae_restrict_mem htm).mono hts\n#align ae_restrict_mem₀ ae_restrict_mem₀\n\n",
 "ae_restrict_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\ntheorem ae_restrict_mem (hs : MeasurableSet s) :\n    «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\" (μ.restrict s)\n      (x ∈ s) :=\n  (ae_restrict_iff' hs).2 (Filter.eventually_of_forall fun x => id)\n#align ae_restrict_mem ae_restrict_mem\n\n",
 "ae_restrict_iff_subtype":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\n#print ae_restrict_iff_subtype /-\ntheorem ae_restrict_iff_subtype {m0 : MeasurableSpace α} {μ : measure α} {s : Set α} (hs : MeasurableSet s)\n    {p : α → Prop} :\n    «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\" (μ.restrict s)\n        (p x) ↔\n      «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\"\n        (comap (coe : s → α) μ) (p ↑x) :=\n  by rw [← map_comap_subtype_coe hs, (MeasurableEmbedding.subtype_coe hs).ae_map_iff]\n#align ae_restrict_iff_subtype ae_restrict_iff_subtype\n-/\n\n",
 "ae_restrict_iff'₀":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\ntheorem ae_restrict_iff'₀ {p : α → Prop} (hs : NullMeasurableSet s μ) :\n    «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\" (μ.restrict s)\n        (p x) ↔\n      «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\" μ\n        (x ∈ s → p x) :=\n  by\n  refine' ⟨fun h => ae_imp_of_ae_restrict h, fun h => _⟩\n  filter_upwards [ae_restrict_mem₀ hs, ae_restrict_of_ae h]with x hx h'x using h'x hx\n#align ae_restrict_iff'₀ ae_restrict_iff'₀\n\n",
 "ae_restrict_iff'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\ntheorem ae_restrict_iff' {p : α → Prop} (hs : MeasurableSet s) :\n    «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\" (μ.restrict s)\n        (p x) ↔\n      «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\" μ\n        (x ∈ s → p x) :=\n  by\n  simp only [ae_iff, ← compl_set_of, restrict_apply_eq_zero' hs]\n  congr with x; simp [and_comm']\n#align ae_restrict_iff' ae_restrict_iff'\n\n",
 "ae_restrict_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\ntheorem ae_restrict_iff {p : α → Prop} (hp : MeasurableSet { x | p x }) :\n    «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\" (μ.restrict s)\n        (p x) ↔\n      «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\" μ\n        (x ∈ s → p x) :=\n  by\n  simp only [ae_iff, ← compl_set_of, restrict_apply hp.compl]\n  congr with x; simp [and_comm']\n#align ae_restrict_iff ae_restrict_iff\n\n",
 "ae_restrict_eq_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem ae_restrict_eq_bot {s} : (μ.restrict s).ae = «expr⊥» ↔ μ s = 0 :=\n  ae_eq_bot.trans restrict_eq_zero\n#align ae_restrict_eq_bot ae_restrict_eq_bot\n\n",
 "ae_restrict_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n@[simp]\ntheorem ae_restrict_eq (hs : MeasurableSet s) : (μ.restrict s).ae = «expr ⊓ » μ.ae ((filter.principal) s) :=\n  by\n  ext t\n  simp only [mem_inf_principal, mem_ae_iff, restrict_apply_eq_zero' hs, compl_set_of, not_imp, and_comm' (_ ∈ s)]\n  rfl\n#align ae_restrict_eq ae_restrict_eq\n\n",
 "ae_restrict_congr_set":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\n/-- If two measurable sets are ae_eq then any proposition that is almost everywhere true on one\nis almost everywhere true on the other -/\ntheorem ae_restrict_congr_set {s t} (hst : «expr =ᵐ[ ] » s μ t) {p : α → Prop} :\n    «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\" (μ.restrict s)\n        (p x) ↔\n      «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\"\n        (μ.restrict t) (p x) :=\n  ⟨ae_restrict_of_ae_eq_of_ae_restrict hst, ae_restrict_of_ae_eq_of_ae_restrict hst.symm⟩\n#align ae_restrict_congr_set ae_restrict_congr_set\n\n",
 "ae_restrict_bUnion_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\ntheorem ae_restrict_bUnion_iff (s : ι → Set α) {t : Set ι} (ht : t.countable) (p : α → Prop) :\n    «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\"\n        (μ.restrict\n          («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (s i)))\n        (p x) ↔\n      ∀ i ∈ t,\n        «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\"\n          (μ.restrict (s i)) (p x) :=\n  by simp_rw [Filter.Eventually, ae_restrict_bUnion_eq s ht, mem_supr]\n#align ae_restrict_bUnion_iff ae_restrict_bUnion_iff\n\n",
 "ae_restrict_bUnion_finset_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\n@[simp]\ntheorem ae_restrict_bUnion_finset_iff (s : ι → Set α) (t : Finset ι) (p : α → Prop) :\n    «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\"\n        (μ.restrict\n          («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (s i)))\n        (p x) ↔\n      ∀ i ∈ t,\n        «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\"\n          (μ.restrict (s i)) (p x) :=\n  by simp_rw [Filter.Eventually, ae_restrict_bUnion_finset_eq s, mem_supr]\n#align ae_restrict_bUnion_finset_iff ae_restrict_bUnion_finset_iff\n\n",
 "ae_restrict_bUnion_finset_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\ntheorem ae_restrict_bUnion_finset_eq (s : ι → Set α) (t : Finset ι) :\n    (μ.restrict\n          («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (s i))).ae =\n      «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n        (μ.restrict (s i)).ae :=\n  ae_restrict_bunionᵢ_eq s t.countable_to_set\n#align ae_restrict_bUnion_finset_eq ae_restrict_bUnion_finset_eq\n\n",
 "ae_restrict_bUnion_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\ntheorem ae_restrict_bUnion_eq (s : ι → Set α) {t : Set ι} (ht : t.countable) :\n    (μ.restrict\n          («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (s i))).ae =\n      «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n        (μ.restrict (s i)).ae :=\n  by\n  haveI := ht.to_subtype\n  rw [bUnion_eq_Union, ae_restrict_Union_eq, ← supᵢ_subtype'']\n#align ae_restrict_bUnion_eq ae_restrict_bUnion_eq\n\n",
 "ae_restrict_Union_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\ntheorem ae_restrict_Union_iff [Countable ι] (s : ι → Set α) (p : α → Prop) :\n    «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\"\n        (μ.restrict\n          («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (s i)))\n        (p x) ↔\n      ∀ i,\n        «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\"\n          (μ.restrict (s i)) (p x) :=\n  by simp\n#align ae_restrict_Union_iff ae_restrict_Union_iff\n\n",
 "ae_restrict_Union_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n@[simp]\ntheorem ae_restrict_Union_eq [Countable ι] (s : ι → Set α) :\n    (μ.restrict\n          («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (s i))).ae =\n      «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n        (μ.restrict (s i)).ae :=\n  le_antisymm ((ae_sum_eq fun i => μ.restrict (s i)) ▸ ae_mono restrict_unionᵢ_le) <|\n    supᵢ_le fun i => ae_mono <| restrict_mono (subset_unionᵢ s i) le_rfl\n#align ae_restrict_Union_eq ae_restrict_Union_eq\n\n",
 "ae_of_forall_measure_lt_top_ae_restrict'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\n/-- Similar to `ae_of_forall_measure_lt_top_ae_restrict`, but where you additionally get the\n  hypothesis that another σ-finite measure has finite values on `s`. -/\ntheorem ae_of_forall_measure_lt_top_ae_restrict' {μ : Measure α} (ν : Measure α) [SigmaFinite μ] [SigmaFinite ν]\n    (P : α → Prop)\n    (h :\n      ∀ s,\n        MeasurableSet s →\n          μ s < ennreal.top →\n            ν s < ennreal.top →\n              «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\"\n                (μ.restrict s) (P x)) :\n    «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\" μ (P x) :=\n  by\n  have :\n    ∀ n,\n      «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\" μ\n        (x ∈ spanning_sets (μ + ν) n → P x) :=\n    by\n    intro n\n    have := h (spanning_sets (μ + ν) n) (measurable_spanning_sets _ _) _ _\n    exacts[(ae_restrict_iff' (measurable_spanning_sets _ _)).mp this,\n      (self_le_add_right _ _).trans_lt (measure_spanning_sets_lt_top (μ + ν) _),\n      (self_le_add_left _ _).trans_lt (measure_spanning_sets_lt_top (μ + ν) _)]\n  filter_upwards [ae_all_iff.2 this]with _ hx using hx _ (mem_spanning_sets_index _ _)\n#align ae_of_forall_measure_lt_top_ae_restrict' ae_of_forall_measure_lt_top_ae_restrict'\n\n",
 "ae_of_forall_measure_lt_top_ae_restrict":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\n/-- To prove something for almost all `x` w.r.t. a σ-finite measure, it is sufficient to show that\n  this holds almost everywhere in sets where the measure has finite value. -/\ntheorem ae_of_forall_measure_lt_top_ae_restrict {μ : Measure α} [SigmaFinite μ] (P : α → Prop)\n    (h :\n      ∀ s,\n        MeasurableSet s →\n          μ s < ennreal.top →\n            «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\"\n              (μ.restrict s) (P x)) :\n    «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\" μ (P x) :=\n  ae_of_forall_measure_lt_top_ae_restrict' μ P fun s hs h2s _ => h s hs h2s\n#align ae_of_forall_measure_lt_top_ae_restrict ae_of_forall_measure_lt_top_ae_restrict\n\n",
 "ae_of_ae_trim":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\ntheorem ae_of_ae_trim (hm : m ≤ m0) {μ : Measure α} {P : α → Prop}\n    (h :\n      «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\" (μ.trim hm)\n        (P x)) :\n    «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\" μ (P x) :=\n  measure_eq_zero_of_trim_eq_zero hm h\n#align ae_of_ae_trim ae_of_ae_trim\n\n",
 "ae_of_ae_restrict_of_ae_restrict_compl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\ntheorem ae_of_ae_restrict_of_ae_restrict_compl (t : Set α) {p : α → Prop}\n    (ht :\n      «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\"\n        (μ.restrict t) (p x))\n    (htc :\n      «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\"\n        (μ.restrict («expr ᶜ» t)) (p x)) :\n    «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\" μ (p x) :=\n  nonpos_iff_eq_zero.1 <|\n    calc\n      μ { x | ¬p x } = μ ({ x | ¬p x } ∩ t ∪ { x | ¬p x } ∩ «expr ᶜ» t) := by\n        rw [← inter_union_distrib_left, union_compl_self, inter_univ]\n      _ ≤ μ ({ x | ¬p x } ∩ t) + μ ({ x | ¬p x } ∩ «expr ᶜ» t) := (measure_union_le _ _)\n      _ ≤ μ.restrict t { x | ¬p x } + μ.restrict («expr ᶜ» t) { x | ¬p x } :=\n        (add_le_add (le_restrict_apply _ _) (le_restrict_apply _ _))\n      _ = 0 := by rw [ae_iff.1 ht, ae_iff.1 htc, zero_add]\n      \n#align ae_of_ae_restrict_of_ae_restrict_compl ae_of_ae_restrict_of_ae_restrict_compl\n\n",
 "ae_of_ae_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\ntheorem ae_of_ae_map {f : α → β} (hf : AEMeasurable f μ) {p : β → Prop}\n    (h :\n      «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\" (μ.map f)\n        (p y)) :\n    «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\" μ (p (f x)) :=\n  mem_ae_of_mem_ae_map hf h\n#align ae_of_ae_map ae_of_ae_map\n\n",
 "ae_not_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\n#print Set.Countable.ae_not_mem /-\ntheorem Set.Countable.ae_not_mem {α : Type _} {m : MeasurableSpace α} {s : Set α} (h : s.countable) (μ : Measure α)\n    [NoAtoms μ] :\n    «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\" μ (x ∉ s) :=\n  by simpa only [ae_iff, Classical.not_not] using h.measure_zero μ\n#align set.countable.ae_not_mem Set.Countable.ae_not_mem\n-/\n\n",
 "ae_ne_bot":
 "@[simp]\ntheorem ae_ne_bot : μ.ae.ne_bot ↔ μ ≠ 0 :=\n  neBot_iff.trans (not_congr ae_eq_bot)\n#align ae_ne_bot ae_ne_bot\n\n",
 "ae_mono":
 "@[mono]\ntheorem ae_mono (h : μ ≤ ν) : μ.ae ≤ ν.ae :=\n  h.absolutely_continuous.ae_le\n#align ae_mono ae_mono\n\n",
 "ae_mem_iff_measure_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\ntheorem ae_mem_iff_measure_eq [FiniteMeasure μ] {s : Set α} (hs : NullMeasurableSet s μ) :\n    «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\" μ (a ∈ s) ↔\n      μ s = μ univ :=\n  ae_iff_measure_eq hs\n#align ae_mem_iff_measure_eq ae_mem_iff_measure_eq\n\n",
 "ae_map_mem_range":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\ntheorem ae_map_mem_range {m0 : MeasurableSpace α} (f : α → β) (hf : MeasurableSet (range f)) (μ : Measure α) :\n    «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\" (μ.map f)\n      (x ∈ range f) :=\n  by\n  by_cases h : AEMeasurable f μ\n  · change range f ∈ (μ.map f).ae\n    rw [mem_ae_map_iff h hf]\n    apply eventually_of_forall\n    exact mem_range_self\n  · simp [map_of_not_ae_measurable h]\n#align ae_map_mem_range ae_map_mem_range\n\n",
 "ae_map_le":
 "theorem ae_map_le (h : QuasiMeasurePreserving f μa μb) : (μa.map f).ae ≤ μb.ae :=\n  h.2.ae_le\n#align ae_map_le ae_map_le\n\n",
 "ae_map_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\ntheorem ae_map_iff {p : β → Prop} {μ : measure α} :\n    «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\" (μ.map f)\n        (p x) ↔\n      «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\" μ\n        (p (f x)) :=\n  by simp only [ae_iff, hf.map_apply, preimage_set_of_eq]\n#align ae_map_iff ae_map_iff\n\n",
 "ae_le_of_ae_le_trim":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≤ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≤ᵐ[ ] » -/\ntheorem ae_le_of_ae_le_trim {E} [LE E] {hm : m ≤ m0} {f₁ f₂ : α → E}\n    (h12 : «expr ≤ᶠ[ ] » f₁ (@Measure.ae α m (μ.trim hm)) f₂) : «expr ≤ᵐ[ ] » f₁ μ f₂ :=\n  measure_eq_zero_of_trim_eq_zero hm h12\n#align ae_le_of_ae_le_trim ae_le_of_ae_le_trim\n\n",
 "ae_le_iff_absolutely_continuous":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure.absolutely_continuous -/\ntheorem ae_le_iff_absolutely_continuous : μ.ae ≤ ν.ae ↔ measure.absolutely_continuous μ ν :=\n  ⟨fun h s => by\n    rw [measure_zero_iff_ae_nmem, measure_zero_iff_ae_nmem]\n    exact fun hs => h hs, fun h s hs => h hs⟩\n#align ae_le_iff_absolutely_continuous ae_le_iff_absolutely_continuous\n\n",
 "ae_imp_of_ae_restrict":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\ntheorem ae_imp_of_ae_restrict {s : Set α} {p : α → Prop}\n    (h :\n      «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\"\n        (μ.restrict s) (p x)) :\n    «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\" μ\n      (x ∈ s → p x) :=\n  by\n  simp only [ae_iff] at h⊢\n  simpa [set_of_and, inter_comm] using measure_inter_eq_zero_of_restrict h\n#align ae_imp_of_ae_restrict ae_imp_of_ae_restrict\n\n",
 "ae_iff_measure_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\ntheorem ae_iff_measure_eq [FiniteMeasure μ] {p : α → Prop} (hp : NullMeasurableSet { a | p a } μ) :\n    «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\" μ (p a) ↔\n      μ { a | p a } = μ univ :=\n  by rw [← ae_eq_univ_iff_measure_eq hp, eventually_eq_univ, eventually_iff]\n#align ae_iff_measure_eq ae_iff_measure_eq\n\n",
 "ae_eventually_not_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/-- A version of the **Borel-Cantelli lemma**: if `sᵢ` is a sequence of sets such that\n`∑ μ sᵢ` exists, then for almost all `x`, `x` does not belong to almost all `sᵢ`. -/\ntheorem ae_eventually_not_mem {s : ℕ → Set α}\n    (hs :\n      «expr∑' , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , »\" (μ (s i)) ≠\n        ennreal.top) :\n    «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\" μ\n      («expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" atTop\n        (x ∉ s n)) :=\n  measure_setOf_frequently_eq_zero hs\n#align ae_eventually_not_mem ae_eventually_not_mem\n\n",
 "ae_eq_univ_iff_measure_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\ntheorem ae_eq_univ_iff_measure_eq [FiniteMeasure μ] (hs : NullMeasurableSet s μ) :\n    «expr =ᵐ[ ] » s μ univ ↔ μ s = μ univ :=\n  by\n  refine' ⟨measure_congr, fun h => _⟩\n  obtain ⟨t, -, ht₁, ht₂⟩ := hs.exists_measurable_subset_ae_eq\n  exact\n    ht₂.symm.trans\n      (ae_eq_of_subset_of_measure_ge (subset_univ t) (Eq.le ((measure_congr ht₂).trans h).symm) ht₁\n        (measure_ne_top μ univ))\n#align ae_eq_univ_iff_measure_eq ae_eq_univ_iff_measure_eq\n\n",
 "ae_eq_restrict_iff_indicator_ae_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\n#print ae_eq_restrict_iff_indicator_ae_eq /-\ntheorem ae_eq_restrict_iff_indicator_ae_eq {g : α → β} (hs : MeasurableSet s) :\n    «expr =ᵐ[ ] » f (μ.restrict s) g ↔ «expr =ᵐ[ ] » (s.indicator f) μ (s.indicator g) :=\n  by\n  rw [Filter.EventuallyEq, ae_restrict_iff' hs]\n  refine' ⟨fun h => _, fun h => _⟩ <;> filter_upwards [h]with x hx\n  · by_cases hxs : x ∈ s\n    · simp [hxs, hx hxs]\n    · simp [hxs]\n  · intro hxs\n    simpa [hxs] using hx\n#align ae_eq_restrict_iff_indicator_ae_eq ae_eq_restrict_iff_indicator_ae_eq\n-/\n\n",
 "ae_eq_restrict_bUnion_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\ntheorem ae_eq_restrict_bUnion_iff (s : ι → Set α) {t : Set ι} (ht : t.countable) (f g : α → δ) :\n    «expr =ᵐ[ ] » f\n        (μ.restrict\n          («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (s i)))\n        g ↔\n      ∀ i ∈ t, «expr =ᵐ[ ] » f (μ.restrict (s i)) g :=\n  by simp_rw [ae_restrict_bUnion_eq s ht, eventually_eq, eventually_supr]\n#align ae_eq_restrict_bUnion_iff ae_eq_restrict_bUnion_iff\n\n",
 "ae_eq_restrict_bUnion_finset_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\ntheorem ae_eq_restrict_bUnion_finset_iff (s : ι → Set α) (t : Finset ι) (f g : α → δ) :\n    «expr =ᵐ[ ] » f\n        (μ.restrict\n          («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (s i)))\n        g ↔\n      ∀ i ∈ t, «expr =ᵐ[ ] » f (μ.restrict (s i)) g :=\n  ae_eq_restrict_bunionᵢ_iff s t.countable_to_set f g\n#align ae_eq_restrict_bUnion_finset_iff ae_eq_restrict_bUnion_finset_iff\n\n",
 "ae_eq_restrict_Union_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\ntheorem ae_eq_restrict_Union_iff [Countable ι] (s : ι → Set α) (f g : α → δ) :\n    «expr =ᵐ[ ] » f\n        (μ.restrict\n          («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (s i)))\n        g ↔\n      ∀ i, «expr =ᵐ[ ] » f (μ.restrict (s i)) g :=\n  by simp_rw [eventually_eq, ae_restrict_Union_eq, eventually_supr]\n#align ae_eq_restrict_Union_iff ae_eq_restrict_Union_iff\n\n",
 "ae_eq_of_subset_of_measure_ge":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\n/-- If `s ⊆ t`, `μ t ≤ μ s`, `μ t ≠ ∞`, and `s` is measurable, then `s =ᵐ[μ] t`. -/\ntheorem ae_eq_of_subset_of_measure_ge (h₁ : s ⊆ t) (h₂ : μ t ≤ μ s) (hsm : MeasurableSet s) (ht : μ t ≠ ennreal.top) :\n    «expr =ᵐ[ ] » s μ t :=\n  ae_eq_of_ae_subset_of_measure_ge (HasSubset.Subset.eventuallyLE h₁) h₂ hsm ht\n#align ae_eq_of_subset_of_measure_ge ae_eq_of_subset_of_measure_ge\n\n",
 "ae_eq_of_ae_subset_of_measure_ge":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≤ᵐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\ntheorem ae_eq_of_ae_subset_of_measure_ge (h₁ : «expr ≤ᵐ[ ] » s μ t) (h₂ : μ t ≤ μ s) (hsm : MeasurableSet s)\n    (ht : μ t ≠ ennreal.top) : «expr =ᵐ[ ] » s μ t :=\n  by\n  refine' eventually_le_antisymm_iff.mpr ⟨h₁, ae_le_set.mpr _⟩\n  replace h₂ : μ t = μ s; exact h₂.antisymm (measure_mono_ae h₁)\n  replace ht : μ s ≠ ennreal.top; exact h₂ ▸ ht\n  rw [measure_diff' t hsm ht, measure_congr (union_ae_eq_left_iff_ae_subset.mpr h₁), h₂, tsub_self]\n#align ae_eq_of_ae_subset_of_measure_ge ae_eq_of_ae_subset_of_measure_ge\n\n",
 "ae_eq_of_ae_eq_trim":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\ntheorem ae_eq_of_ae_eq_trim {E} {hm : m ≤ m0} {f₁ f₂ : α → E}\n    (h12 : «expr =ᶠ[ ] » f₁ (@Measure.ae α m (μ.trim hm)) f₂) : «expr =ᵐ[ ] » f₁ μ f₂ :=\n  measure_eq_zero_of_trim_eq_zero hm h12\n#align ae_eq_of_ae_eq_trim ae_eq_of_ae_eq_trim\n\n",
 "ae_eq_image_of_ae_eq_comap":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem ae_eq_image_of_ae_eq_comap {β} [MeasurableSpace α] {mβ : MeasurableSpace β} (f : α → β) (μ : Measure β)\n    (hfi : injective f) (hf : ∀ s, MeasurableSet s → NullMeasurableSet («expr '' » f s) μ) {s t : Set α}\n    (hst : «expr =ᵐ[ ] » s (comap f μ) t) : «expr =ᵐ[ ] » («expr '' » f s) μ («expr '' » f t) :=\n  by\n  rw [eventually_eq, ae_iff] at hst⊢\n  have h_eq_α : { a : α | ¬s a = t a } = s \\ t ∪ t \\ s :=\n    by\n    ext1 x\n    simp only [eq_iff_iff, mem_set_of_eq, mem_union, mem_diff]\n    tauto\n  have h_eq_β :\n    { a : β | ¬(«expr '' » f s) a = («expr '' » f t) a } =\n      «expr '' » f s \\ «expr '' » f t ∪ «expr '' » f t \\ «expr '' » f s :=\n    by\n    ext1 x\n    simp only [eq_iff_iff, mem_set_of_eq, mem_union, mem_diff]\n    tauto\n  rw [← Set.image_diff hfi, ← Set.image_diff hfi, ← Set.image_union] at h_eq_β\n  rw [h_eq_β]\n  rw [h_eq_α] at hst\n  exact measure_image_eq_zero_of_comap_eq_zero f μ hfi hf hst\n#align ae_eq_image_of_ae_eq_comap ae_eq_image_of_ae_eq_comap\n\n",
 "ae_eq_dirac'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\ntheorem ae_eq_dirac' [MeasurableSingletonClass β] {a : α} {f : α → β} (hf : Measurable f) :\n    «expr =ᵐ[ ] » f (dirac a) (const α (f a)) :=\n  (ae_dirac_iff <| show MeasurableSet («expr ⁻¹' » f {f a}) from hf <| measurable_set_singleton _).2 rfl\n#align ae_eq_dirac' ae_eq_dirac'\n\n",
 "ae_eq_dirac":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\ntheorem ae_eq_dirac [MeasurableSingletonClass α] {a : α} (f : α → δ) : «expr =ᵐ[ ] » f (dirac a) (const α (f a)) := by\n  simp [Filter.EventuallyEq]\n#align ae_eq_dirac ae_eq_dirac\n\n",
 "ae_eq_comp'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure.absolutely_continuous -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\ntheorem ae_eq_comp' {ν : Measure β} {f : α → β} {g g' : β → δ} (hf : AEMeasurable f μ) (h : «expr =ᵐ[ ] » g ν g')\n    (h2 : measure.absolutely_continuous (μ.map f) ν) : «expr =ᵐ[ ] » (g ∘ f) μ (g' ∘ f) :=\n  (tendsto_ae_map hf).mono_right h2.ae_le h\n#align ae_eq_comp' ae_eq_comp'\n\n",
 "ae_eq_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\ntheorem ae_eq_comp {f : α → β} {g g' : β → δ} (hf : AEMeasurable f μ) (h : «expr =ᵐ[ ] » g (μ.map f) g') :\n    «expr =ᵐ[ ] » (g ∘ f) μ (g' ∘ f) :=\n  ae_eq_comp' hf h AbsolutelyContinuous.rfl\n#align ae_eq_comp ae_eq_comp\n\n",
 "ae_eq_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem ae_eq_bot : μ.ae = «expr⊥» ↔ μ = 0 := by rw [← empty_mem_iff_bot, mem_ae_iff, compl_empty, measure_univ_eq_zero]\n#align ae_eq_bot ae_eq_bot\n\n",
 "ae_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\ntheorem ae_eq (h : QuasiMeasurePreserving f μa μb) {g₁ g₂ : β → δ} (hg : «expr =ᵐ[ ] » g₁ μb g₂) :\n    «expr =ᵐ[ ] » (g₁ ∘ f) μa (g₂ ∘ f) :=\n  h.ae hg\n#align ae_eq ae_eq\n\n",
 "ae_dirac_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\ntheorem ae_dirac_iff {a : α} {p : α → Prop} (hp : MeasurableSet { x | p x }) :\n    «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\" (dirac a)\n        (p x) ↔\n      p a :=\n  mem_ae_dirac_iff hp\n#align ae_dirac_iff ae_dirac_iff\n\n",
 "ae_dirac_eq":
 "@[simp]\ntheorem ae_dirac_eq [MeasurableSingletonClass α] (a : α) : (dirac a).ae = pure a :=\n  by\n  ext s\n  simp [mem_ae_iff, imp_false]\n#align ae_dirac_eq ae_dirac_eq\n\n",
 "ae_add_measure_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\ntheorem ae_add_measure_iff {p : α → Prop} {ν} :\n    «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\" (μ + ν)\n        (p x) ↔\n      «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\" μ (p x) ∧\n        «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\" ν (p x) :=\n  add_eq_zero_iff\n#align ae_add_measure_iff ae_add_measure_iff\n\n",
 "ae":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\ntheorem ae (h : QuasiMeasurePreserving f μa μb) {p : β → Prop}\n    (hg :\n      «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\" μb (p x)) :\n    «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\" μa\n      (p (f x)) :=\n  h.tendsto_ae hg\n#align ae ae\n\n",
 "add_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n#print add_top /-\n@[simp]\ntheorem add_top : μ + «expr⊤» = «expr⊤» :=\n  top_unique <| Measure.le_add_left le_rfl\n#align add_top add_top\n-/\n\n",
 "add_to_outer_measure":
 "@[simp]\ntheorem add_to_outer_measure {m : MeasurableSpace α} (μ₁ μ₂ : Measure α) :\n    (μ₁ + μ₂).to_outer_measure = μ₁.to_outer_measure + μ₂.to_outer_measure :=\n  rfl\n#align add_to_outer_measure add_to_outer_measure\n\n",
 "add_apply":
 "theorem add_apply {m : MeasurableSpace α} (μ₁ μ₂ : Measure α) (s : Set α) : (μ₁ + μ₂) s = μ₁ s + μ₂ s :=\n  rfl\n#align add_apply add_apply\n\n",
 "absolutely_continuous_of_le_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure.absolutely_continuous -/\ntheorem absolutely_continuous_of_le_smul {μ' : Measure α} {c : ennreal} (hμ'_le : μ' ≤ «expr • » c μ) :\n    measure.absolutely_continuous μ' μ :=\n  (Measure.absolutelyContinuous_of_le hμ'_le).trans (Measure.AbsolutelyContinuous.rfl.smul c)\n#align absolutely_continuous_of_le_smul absolutely_continuous_of_le_smul\n\n",
 "absolutely_continuous_of_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure.absolutely_continuous -/\ntheorem absolutely_continuous_of_le (h : μ ≤ ν) : measure.absolutely_continuous μ ν := fun s hs =>\n  nonpos_iff_eq_zero.1 <| hs ▸ le_iff'.1 h s\n#align absolutely_continuous_of_le absolutely_continuous_of_le\n\n",
 "absolutely_continuous_of_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure.absolutely_continuous -/\ntheorem absolutely_continuous_of_eq (h : μ = ν) : measure.absolutely_continuous μ ν :=\n  h.le.absolutely_continuous\n#align absolutely_continuous_of_eq absolutely_continuous_of_eq\n\n",
 "Union_spanning_sets":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\ntheorem Union_spanning_sets (μ : Measure α) [SigmaFinite μ] :\n    «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (spanningSets μ i) =\n      univ :=\n  by simp_rw [spanning_sets, Union_accumulate, μ.to_finite_spanning_sets_in.spanning]\n#align Union_spanning_sets Union_spanning_sets\n\n",
 "IsCountablySpanning":
 "#print IsCountablySpanning /-\nprotected theorem IsCountablySpanning (h : μ.finite_spanning_sets_in C) : IsCountablySpanning C :=\n  ⟨h.set, h.set_mem, h.spanning⟩\n#align is_countably_spanning IsCountablySpanning\n-/\n\n",
 "Ioo_ae_eq_Ioc'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\ntheorem Ioo_ae_eq_Ioc' (hb : μ {b} = 0) : «expr =ᵐ[ ] » (Ioo a b) μ (Ioc a b) :=\n  (ae_eq_refl _).inter (Iio_ae_eq_Iic' hb)\n#align Ioo_ae_eq_Ioc' Ioo_ae_eq_Ioc'\n\n",
 "Ioo_ae_eq_Ioc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\ntheorem Ioo_ae_eq_Ioc : «expr =ᵐ[ ] » (Ioo a b) μ (Ioc a b) :=\n  Ioo_ae_eq_Ioc' (measure_singleton b)\n#align Ioo_ae_eq_Ioc Ioo_ae_eq_Ioc\n\n",
 "Ioo_ae_eq_Ico'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\ntheorem Ioo_ae_eq_Ico' (ha : μ {a} = 0) : «expr =ᵐ[ ] » (Ioo a b) μ (Ico a b) :=\n  (Ioi_ae_eq_Ici' ha).inter (ae_eq_refl _)\n#align Ioo_ae_eq_Ico' Ioo_ae_eq_Ico'\n\n",
 "Ioo_ae_eq_Ico":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\ntheorem Ioo_ae_eq_Ico : «expr =ᵐ[ ] » (Ioo a b) μ (Ico a b) :=\n  Ioo_ae_eq_Ico' (measure_singleton a)\n#align Ioo_ae_eq_Ico Ioo_ae_eq_Ico\n\n",
 "Ioo_ae_eq_Icc'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\ntheorem Ioo_ae_eq_Icc' (ha : μ {a} = 0) (hb : μ {b} = 0) : «expr =ᵐ[ ] » (Ioo a b) μ (Icc a b) :=\n  (Ioi_ae_eq_Ici' ha).inter (Iio_ae_eq_Iic' hb)\n#align Ioo_ae_eq_Icc' Ioo_ae_eq_Icc'\n\n",
 "Ioo_ae_eq_Icc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\ntheorem Ioo_ae_eq_Icc : «expr =ᵐ[ ] » (Ioo a b) μ (Icc a b) :=\n  Ioo_ae_eq_Icc' (measure_singleton a) (measure_singleton b)\n#align Ioo_ae_eq_Icc Ioo_ae_eq_Icc\n\n",
 "Ioi_ae_eq_Ici'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\ntheorem Ioi_ae_eq_Ici' (ha : μ {a} = 0) : «expr =ᵐ[ ] » (Ioi a) μ (Ici a) :=\n  @Iio_ae_eq_Iic' («expr ᵒᵈ» α) ‹_› ‹_› _ _ ha\n#align Ioi_ae_eq_Ici' Ioi_ae_eq_Ici'\n\n",
 "Ioi_ae_eq_Ici":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\ntheorem Ioi_ae_eq_Ici : «expr =ᵐ[ ] » (Ioi a) μ (Ici a) :=\n  Ioi_ae_eq_Ici' (measure_singleton a)\n#align Ioi_ae_eq_Ici Ioi_ae_eq_Ici\n\n",
 "Ioc_ae_eq_Icc'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\ntheorem Ioc_ae_eq_Icc' (ha : μ {a} = 0) : «expr =ᵐ[ ] » (Ioc a b) μ (Icc a b) :=\n  (Ioi_ae_eq_Ici' ha).inter (ae_eq_refl _)\n#align Ioc_ae_eq_Icc' Ioc_ae_eq_Icc'\n\n",
 "Ioc_ae_eq_Icc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\ntheorem Ioc_ae_eq_Icc : «expr =ᵐ[ ] » (Ioc a b) μ (Icc a b) :=\n  Ioc_ae_eq_Icc' (measure_singleton a)\n#align Ioc_ae_eq_Icc Ioc_ae_eq_Icc\n\n",
 "Inf_caratheodory":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem Inf_caratheodory (s : Set α) (hs : MeasurableSet s) :\n    (measurable_set_of (infₛ («expr '' » to_outer_measure m)).caratheodory) s :=\n  by\n  rw [outer_measure.Inf_eq_bounded_by_Inf_gen]\n  refine' outer_measure.bounded_by_caratheodory fun t => _\n  simp only [outer_measure.Inf_gen, le_infᵢ_iff, ball_image_iff, coe_to_outer_measure, measure_eq_infi t]\n  intro μ hμ u htu hu\n  have hm : ∀ {s t}, s ⊆ t → outer_measure.Inf_gen («expr '' » to_outer_measure m) s ≤ μ t :=\n    by\n    intro s t hst\n    rw [outer_measure.Inf_gen_def]\n    refine' infᵢ_le_of_le μ.to_outer_measure (infᵢ_le_of_le (mem_image_of_mem _ hμ) _)\n    rw [to_outer_measure_apply]\n    refine' measure_mono hst\n  rw [← measure_inter_add_diff u hs]\n  refine' add_le_add (hm <| inter_subset_inter_left _ htu) (hm <| diff_subset_diff_left htu)\n#align Inf_caratheodory Inf_caratheodory\n\n",
 "Iio_ae_eq_Iic'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\ntheorem Iio_ae_eq_Iic' (ha : μ {a} = 0) : «expr =ᵐ[ ] » (Iio a) μ (Iic a) := by\n  rw [← Iic_diff_right, diff_ae_eq_self, measure_mono_null (Set.inter_subset_right _ _) ha]\n#align Iio_ae_eq_Iic' Iio_ae_eq_Iic'\n\n",
 "Iio_ae_eq_Iic":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\ntheorem Iio_ae_eq_Iic : «expr =ᵐ[ ] » (Iio a) μ (Iic a) :=\n  Iio_ae_eq_Iic' (measure_singleton a)\n#align Iio_ae_eq_Iic Iio_ae_eq_Iic\n\n",
 "Ico_ae_eq_Ioc'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\ntheorem Ico_ae_eq_Ioc' (ha : μ {a} = 0) (hb : μ {b} = 0) : «expr =ᵐ[ ] » (Ico a b) μ (Ioc a b) :=\n  (Ioo_ae_eq_Ico' ha).symm.trans (Ioo_ae_eq_Ioc' hb)\n#align Ico_ae_eq_Ioc' Ico_ae_eq_Ioc'\n\n",
 "Ico_ae_eq_Ioc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\ntheorem Ico_ae_eq_Ioc : «expr =ᵐ[ ] » (Ico a b) μ (Ioc a b) :=\n  Ico_ae_eq_Ioc' (measure_singleton a) (measure_singleton b)\n#align Ico_ae_eq_Ioc Ico_ae_eq_Ioc\n\n",
 "Ico_ae_eq_Icc'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\ntheorem Ico_ae_eq_Icc' (hb : μ {b} = 0) : «expr =ᵐ[ ] » (Ico a b) μ (Icc a b) :=\n  (ae_eq_refl _).inter (Iio_ae_eq_Iic' hb)\n#align Ico_ae_eq_Icc' Ico_ae_eq_Icc'\n\n",
 "Ico_ae_eq_Icc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\ntheorem Ico_ae_eq_Icc : «expr =ᵐ[ ] » (Ico a b) μ (Icc a b) :=\n  Ico_ae_eq_Icc' (measure_singleton b)\n#align Ico_ae_eq_Icc Ico_ae_eq_Icc\n\n",
 "AEMeasurable":
 "#print AEMeasurable /-\nprotected theorem AEMeasurable (hf : QuasiMeasurePreserving f μa μb) : AEMeasurable f μa :=\n  hf.1.ae_measurable\n#align ae_measurable AEMeasurable\n-/\n\n"}