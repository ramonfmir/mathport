{"zero_caratheodory":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem zero_caratheodory : (0 : outer_measure α).caratheodory = «expr⊤» :=\n  top_unique fun s _ t => (add_zero _).symm\n#align zero_caratheodory zero_caratheodory\n\n",
 "univ_eq_zero_iff":
 "theorem univ_eq_zero_iff (m : outer_measure α) : m univ = 0 ↔ m = 0 :=\n  ⟨fun h => bot_unique fun s => (m.mono' <| subset_univ s).trans_eq h, fun h => h.symm ▸ rfl⟩\n#align univ_eq_zero_iff univ_eq_zero_iff\n\n",
 "union_null":
 "theorem union_null (m : outer_measure α) {s₁ s₂ : set α} (h₁ : m s₁ = 0) (h₂ : m s₂ = 0) : m (s₁ ∪ s₂) = 0 := by\n  simpa [h₁, h₂] using m.union s₁ s₂\n#align union_null union_null\n\n",
 "union":
 "protected theorem union (m : outer_measure α) (s₁ s₂ : set α) : m (s₁ ∪ s₂) ≤ m s₁ + m s₂ :=\n  rel_sup_add m m.empty (· ≤ ·) m.Union_nat s₁ s₂\n#align union union\n\n",
 "trim_zero":
 "@[simp]\ntheorem trim_zero : (0 : outer_measure α).trim = 0 :=\n  ext fun s =>\n    le_antisymm (le_trans ((trim 0).mono (subset_univ s)) <| le_of_eq <| trim_eq _ measurable_set.univ) (zero_le _)\n#align trim_zero trim_zero\n\n",
 "trim_trim":
 "theorem trim_trim (m : outer_measure α) : m.trim.trim = m.trim :=\n  trim_eq_trim_iff.2 fun s => m.trim_eq\n#align trim_trim trim_trim\n\n",
 "trim_supr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/-- `trim` sends the supremum of a countable family of outer measures to the supremum\nof the trimmed measures. -/\ntheorem trim_supr {ι} [countable ι] (μ : ι → outer_measure α) :\n    trim («expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (μ i)) =\n      «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (trim (μ i)) :=\n  by\n  simp_rw [← @supᵢ_plift_down _ ι]\n  ext1 s\n  haveI : countable (option <| PLift ι) := @option.countable (PLift ι) _\n  obtain ⟨t, hst, ht, hμt⟩ :=\n    exists_measurable_superset_forall_eq_trim\n      (Option.elim'\n        («expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n          (μ (plift.down i)))\n        (μ ∘ plift.down))\n      s\n  simp only [option.forall, Option.elim'] at hμt\n  simp only [supᵢ_apply, ← hμt.1, ← hμt.2]\n#align trim_supr trim_supr\n\n",
 "trim_sup":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/-- `trim` sends the supremum of two outer measures to the supremum of the trimmed measures. -/\ntheorem trim_sup (m₁ m₂ : outer_measure α) : («expr ⊔ » m₁ m₂).trim = «expr ⊔ » m₁.trim m₂.trim :=\n  ext fun s => (trim_binop (sup_apply m₁ m₂) s).trans (sup_apply _ _ _).symm\n#align trim_sup trim_sup\n\n",
 "trim_sum_ge":
 "theorem trim_sum_ge {ι} (m : ι → outer_measure α) : (sum fun i => (m i).trim) ≤ (sum m).trim := fun s => by\n  simp [trim_eq_infi] <;>\n    exact fun t st ht => ennreal.tsum_le_tsum fun i => infᵢ_le_of_le t <| infᵢ_le_of_le st <| infᵢ_le _ ht\n#align trim_sum_ge trim_sum_ge\n\n",
 "trim_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- `trim` respects scalar multiplication. -/\ntheorem trim_smul {R : Type _} [SMul R (ennreal)] [IsScalarTower R (ennreal) (ennreal)] (c : R) (m : outer_measure α) :\n    («expr • » c m).trim = «expr • » c m.trim :=\n  ext <| trim_op (smul_apply c m)\n#align trim_smul trim_smul\n\n",
 "trim_op":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/-- If `m₁ s = op (m₂ s)` for all `s`, then the same is true for `m₁.trim` and `m₂.trim`. -/\ntheorem trim_op {m₁ m₂ : outer_measure α} {op : ennreal → ennreal} (h : ∀ s, m₁ s = op (m₂ s)) (s : set α) :\n    m₁.trim s = op (m₂.trim s) :=\n  @trim_binop α _ m₁ m₂ 0 (fun a b => op a) h s\n#align trim_op trim_op\n\n",
 "trim_mono":
 "@[mono]\ntheorem trim_mono : monotone (trim : outer_measure α → outer_measure α) := fun m₁ m₂ H s =>\n  infᵢ₂_mono fun f hs => ennreal.tsum_le_tsum fun b => infᵢ_mono fun hf => H _\n#align trim_mono trim_mono\n\n",
 "trim_le_trim_iff":
 "theorem trim_le_trim_iff {m₁ m₂ : outer_measure α} : m₁.trim ≤ m₂.trim ↔ ∀ s, measurable_set s → m₁ s ≤ m₂ s :=\n  le_trim_iff.trans <| forall₂_congr fun s hs => by rw [trim_eq _ hs]\n#align trim_le_trim_iff trim_le_trim_iff\n\n",
 "trim_eq_trim_iff":
 "theorem trim_eq_trim_iff {m₁ m₂ : outer_measure α} : m₁.trim = m₂.trim ↔ ∀ s, measurable_set s → m₁ s = m₂ s := by\n  simp only [le_antisymm_iff, trim_le_trim_iff, forall_and]\n#align trim_eq_trim_iff trim_eq_trim_iff\n\n",
 "trim_eq_infi'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\ntheorem trim_eq_infi' (s : set α) :\n    m.trim s = «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (m t) :=\n  by simp [infᵢ_subtype, infᵢ_and, trim_eq_infi]\n#align trim_eq_infi' trim_eq_infi'\n\n",
 "trim_eq_infi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\ntheorem trim_eq_infi (s : set α) :\n    m.trim s = «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (m t) :=\n  by\n  simp (config := { singlePass := true }) only [infᵢ_comm]\n  exact induced_outer_measure_eq_infi measurable_set.Union (fun f _ => m.Union_nat f) (fun _ _ _ _ h => m.mono h) s\n#align trim_eq_infi trim_eq_infi\n\n",
 "trim_eq":
 "theorem trim_eq {s : set α} (hs : measurable_set s) : m.trim s = m s :=\n  induced_outer_measure_eq' measurable_set.Union (fun f hf => m.Union_nat f) (fun _ _ _ _ h => m.mono h) hs\n#align trim_eq trim_eq\n\n",
 "trim_congr":
 "theorem trim_congr {m₁ m₂ : outer_measure α} (H : ∀ {s : set α}, measurable_set s → m₁ s = m₂ s) : m₁.trim = m₂.trim :=\n  by\n  unfold trim\n  congr\n  funext s hs\n  exact H hs\n#align trim_congr trim_congr\n\n",
 "trim_binop":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr![ ,]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr![ ,]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/-- If `m₁ s = op (m₂ s) (m₃ s)` for all `s`, then the same is true for `m₁.trim`, `m₂.trim`,\nand `m₃ s`. -/\ntheorem trim_binop {m₁ m₂ m₃ : outer_measure α} {op : ennreal → ennreal → ennreal} (h : ∀ s, m₁ s = op (m₂ s) (m₃ s))\n    (s : set α) : m₁.trim s = op (m₂.trim s) (m₃.trim s) :=\n  by\n  rcases exists_measurable_superset_forall_eq_trim\n      («expr![ ,]» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr![ ,]»\") s with\n    ⟨t, hst, ht, htm⟩\n  simp only [Fin.forall_fin_succ, matrix.cons_val_zero, matrix.cons_val_succ] at htm\n  rw [← htm.1, ← htm.2.1, ← htm.2.2.1, h]\n#align trim_binop trim_binop\n\n",
 "trim_add":
 "/-- `trim` is additive. -/\ntheorem trim_add (m₁ m₂ : outer_measure α) : (m₁ + m₂).trim = m₁.trim + m₂.trim :=\n  ext <| trim_binop (add_apply m₁ m₂)\n#align trim_add trim_add\n\n",
 "top_caratheodory":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem top_caratheodory : («expr⊤» : outer_measure α).caratheodory = «expr⊤» :=\n  top_unique fun s hs =>\n    (is_caratheodory_iff_le _).2 fun t =>\n      t.eq_empty_or_nonempty.elim (fun ht => by simp [ht]) fun ht => by simp only [ht, top_apply, le_top]\n#align top_caratheodory top_caratheodory\n\n",
 "top_apply'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\ntheorem top_apply' (s : set α) :\n    («expr⊤» : outer_measure α) s =\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" 0 :=\n  s.eq_empty_or_nonempty.elim (fun h => by simp [h]) fun h => by simp [h, h.ne_empty]\n#align top_apply' top_apply'\n\n",
 "top_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n@[simp]\ntheorem top_apply {s : set α} (h : s.nonempty) : («expr⊤» : outer_measure α) s = ennreal.top :=\n  let ⟨a, as⟩ := h\n  top_unique <| le_trans (by simp [smul_dirac_apply, as]) (le_supᵢ₂ («expr • » (ennreal.top) (dirac a)) trivial)\n#align top_apply top_apply\n\n",
 "supₛ_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n#print supₛ_apply /-\n@[simp]\ntheorem supₛ_apply (ms : set (outer_measure α)) (s : set α) :\n    (supₛ ms) s =\n      «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n        ((m : outer_measure α) s) :=\n  rfl\n#align Sup_apply supₛ_apply\n-/\n\n",
 "supᵢ_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n#print supᵢ_apply /-\n@[simp]\ntheorem supᵢ_apply {ι} (f : ι → outer_measure α) (s : set α) :\n    («expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (f i)) s =\n      «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (f i s) :=\n  by rw [supᵢ, supₛ_apply, supᵢ_range, supᵢ]\n#align supr_apply supᵢ_apply\n-/\n\n",
 "supr_Inf_gen_nonempty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\ntheorem supr_Inf_gen_nonempty {m : set (outer_measure α)} (h : m.nonempty) (t : set α) :\n    «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (Inf_gen m t) =\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (μ t) :=\n  by\n  rcases t.eq_empty_or_nonempty with (rfl | ht)\n  · rcases h with ⟨μ, hμ⟩\n    rw [eq_false not_nonempty_empty, supᵢ_false, eq_comm]\n    simp_rw [empty']\n    apply bot_unique\n    refine' infᵢ_le_of_le μ (infᵢ_le _ hμ)\n  · simp [ht, Inf_gen_def]\n#align supr_Inf_gen_nonempty supr_Inf_gen_nonempty\n\n",
 "sup_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n@[simp]\ntheorem sup_apply (m₁ m₂ : outer_measure α) (s : set α) : («expr ⊔ » m₁ m₂) s = «expr ⊔ » (m₁ s) (m₂ s) := by\n  have := supᵢ_apply (fun b => cond b m₁ m₂) s <;> rwa [supᵢ_bool_eq, supᵢ_bool_eq] at this\n#align sup_apply sup_apply\n\n",
 "sum_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , » -/\n@[simp]\ntheorem sum_apply {ι} (f : ι → outer_measure α) (s : set α) :\n    sum f s =\n      «expr∑' , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , »\" (f i s) :=\n  rfl\n#align sum_apply sum_apply\n\n",
 "smul_supr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem smul_supr [SMul R (ennreal)] [IsScalarTower R (ennreal) (ennreal)] {ι} (f : ι → outer_measure α) (c : R) :\n    «expr • » c\n        («expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (f i)) =\n      «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n        («expr • » c (f i)) :=\n  ext fun s => by\n    simp only [smul_apply, supᵢ_apply, ← smul_one_mul c (f _ _), ← smul_one_mul c (supᵢ _), ennreal.mul_supr]\n#align smul_supr smul_supr\n\n",
 "smul_of_function":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem smul_of_function {c : ennreal} (hc : c ≠ ennreal.top) :\n    «expr • » c (outer_measure.of_function m m_empty) = outer_measure.of_function («expr • » c m) (by simp [m_empty]) :=\n  by\n  ext1 s\n  haveI :\n    nonempty\n      { t : ℕ → set α //\n        s ⊆ «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (t i) } :=\n    ⟨⟨fun _ => s, subset_Union (fun _ => s) 0⟩⟩\n  simp only [smul_apply, of_function_apply, ennreal.tsum_mul_left, pi.smul_apply, smul_eq_mul, infᵢ_subtype',\n    ennreal.infi_mul_left fun h => (hc h).elim]\n#align smul_of_function smul_of_function\n\n",
 "smul_dirac_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem smul_dirac_apply (a : ennreal) (b : α) (s : set α) : («expr • » a (dirac b)) s = indicator s (fun _ => a) b :=\n  by simp only [smul_apply, smul_eq_mul, dirac_apply, ← indicator_mul_right _ fun _ => a, mul_one]\n#align smul_dirac_apply smul_dirac_apply\n\n",
 "smul_bounded_by":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem smul_bounded_by {c : ennreal} (hc : c ≠ ennreal.top) :\n    «expr • » c (bounded_by m) = bounded_by («expr • » c m) :=\n  by\n  simp only [bounded_by, smul_of_function hc]\n  congr 1 with s : 1\n  rcases s.eq_empty_or_nonempty with (rfl | hs) <;> simp [*]\n#align smul_bounded_by smul_bounded_by\n\n",
 "smul_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem smul_apply (c : R) (m : outer_measure α) (s : set α) : («expr • » c m) s = «expr • » c (m s) :=\n  rfl\n#align smul_apply smul_apply\n\n",
 "sUnion_null_iff":
 "theorem sUnion_null_iff (m : outer_measure α) {S : set (set α)} (hS : S.countable) : m (⋃₀ S) = 0 ↔ ∀ s ∈ S, m s = 0 :=\n  by rw [sUnion_eq_bUnion, m.bUnion_null_iff hS]\n#align sUnion_null_iff sUnion_null_iff\n\n",
 "restrict_univ":
 "@[simp]\ntheorem restrict_univ (m : outer_measure α) : restrict univ m = m :=\n  ext fun s => by simp\n#align restrict_univ restrict_univ\n\n",
 "restrict_trim":
 "/-- The trimmed property of a measure μ states that `μ.to_outer_measure.trim = μ.to_outer_measure`.\nThis theorem shows that a restricted trimmed outer measure is a trimmed outer measure. -/\ntheorem restrict_trim {μ : outer_measure α} {s : set α} (hs : measurable_set s) :\n    (restrict s μ).trim = restrict s μ.trim :=\n  by\n  refine' le_antisymm (fun t => _) (le_trim_iff.2 fun t ht => _)\n  · rw [restrict_apply]\n    rcases μ.exists_measurable_superset_eq_trim (t ∩ s) with ⟨t', htt', ht', hμt'⟩\n    rw [← hμt']\n    rw [inter_subset] at htt'\n    refine' (mono' _ htt').trans _\n    rw [trim_eq _ (hs.compl.union ht'), restrict_apply, union_inter_distrib_right, compl_inter_self, Set.empty_union]\n    exact μ.mono' (inter_subset_left _ _)\n  · rw [restrict_apply, trim_eq _ (ht.inter hs), restrict_apply]\n    exact le_rfl\n#align restrict_trim restrict_trim\n\n",
 "restrict_supr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n@[simp]\ntheorem restrict_supr {ι} (s : set α) (m : ι → outer_measure α) :\n    restrict s («expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (m i)) =\n      «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n        (restrict s (m i)) :=\n  by simp [restrict]\n#align restrict_supr restrict_supr\n\n",
 "restrict_of_function":
 "theorem restrict_of_function (s : set α) (hm : monotone m) :\n    restrict s (outer_measure.of_function m m_empty) =\n      outer_measure.of_function (fun t => m (t ∩ s)) (by rwa [Set.empty_inter]) :=\n  by\n  simp only [restrict, linear_map.comp_apply, comap_of_function _ (or.inl hm), map_of_function subtype.coe_injective,\n    Subtype.image_preimage_coe]\n#align restrict_of_function restrict_of_function\n\n",
 "restrict_mono":
 "@[mono]\ntheorem restrict_mono {s t : set α} (h : s ⊆ t) {m m' : outer_measure α} (hm : m ≤ m') : restrict s m ≤ restrict t m' :=\n  fun u => by\n  simp only [restrict_apply]\n  exact (hm _).trans (m'.mono <| inter_subset_inter_right _ h)\n#align restrict_mono restrict_mono\n\n",
 "restrict_le_self":
 "theorem restrict_le_self (m : outer_measure α) (s : set α) : restrict s m ≤ m :=\n  map_comap_le _ _\n#align restrict_le_self restrict_le_self\n\n",
 "restrict_infi_restrict":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\ntheorem restrict_infi_restrict {ι} (s : set α) (m : ι → outer_measure α) :\n    restrict s\n        («expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n          (restrict s (m i))) =\n      restrict s\n        («expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (m i)) :=\n  calc\n    restrict s\n          («expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n            (restrict s (m i))) =\n        restrict (range (coe : s → α))\n          («expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n            (restrict s (m i))) :=\n      by rw [Subtype.range_coe]\n    _ =\n        map (coe : s → α)\n          («expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n            (comap coe (m i))) :=\n      (map_infi subtype.coe_injective _).symm\n    _ =\n        restrict s\n          («expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (m i)) :=\n      congr_arg (map coe) (comap_infi _ _).symm\n    \n#align restrict_infi_restrict restrict_infi_restrict\n\n",
 "restrict_infi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\ntheorem restrict_infi {ι} [nonempty ι] (s : set α) (m : ι → outer_measure α) :\n    restrict s («expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (m i)) =\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n        (restrict s (m i)) :=\n  (congr_arg (map coe) (comap_infi _ _)).trans (map_infi_comap _)\n#align restrict_infi restrict_infi\n\n",
 "restrict_empty":
 "@[simp]\ntheorem restrict_empty (m : outer_measure α) : restrict ∅ m = 0 :=\n  ext fun s => by simp\n#align restrict_empty restrict_empty\n\n",
 "restrict_binfi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\ntheorem restrict_binfi {ι} {I : set ι} (hI : I.nonempty) (s : set α) (m : ι → outer_measure α) :\n    restrict s («expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (m i)) =\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n        (restrict s (m i)) :=\n  by\n  haveI := hI.to_subtype\n  rw [← infᵢ_subtype'', ← infᵢ_subtype'']\n  exact restrict_infi _ _\n#align restrict_binfi restrict_binfi\n\n",
 "restrict_apply":
 "@[simp]\ntheorem restrict_apply (s t : set α) (m : outer_measure α) : restrict s m t = m (t ∩ s) := by simp [restrict]\n#align restrict_apply restrict_apply\n\n",
 "restrict_Inf_eq_Inf_restrict":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/-- This proves that Inf and restrict commute for outer measures, so long as the set of\nouter measures is nonempty. -/\ntheorem restrict_Inf_eq_Inf_restrict (m : set (outer_measure α)) {s : set α} (hm : m.nonempty) :\n    restrict s (infₛ m) = infₛ («expr '' » (restrict s) m) := by\n  simp only [infₛ_eq_infᵢ, restrict_binfi, hm, infᵢ_image]\n#align restrict_Inf_eq_Inf_restrict restrict_Inf_eq_Inf_restrict\n\n",
 "pos_of_subset_ne_zero":
 "theorem pos_of_subset_ne_zero (m : outer_measure α) {a b : set α} (hs : a ⊆ b) (hnz : m a ≠ 0) : 0 < m b :=\n  lt_of_lt_of_le (pos_iff_ne_zero.mpr hnz) (m.mono hs)\n#align pos_of_subset_ne_zero pos_of_subset_ne_zero\n\n",
 "of_function_union_of_top_of_nonempty_inter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Basic.lean:632:2: warning: expanding binder collection (u «expr ⊆ » «expr ∪ »(s, t)) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/-- If `m u = ∞` for any set `u` that has nonempty intersection both with `s` and `t`, then\n`μ (s ∪ t) = μ s + μ t`, where `μ = measure_theory.outer_measure.of_function m m_empty`.\n\nE.g., if `α` is an (e)metric space and `m u = ∞` on any set of diameter `≥ r`, then this lemma\nimplies that `μ (s ∪ t) = μ s + μ t` on any two sets such that `r ≤ edist x y` for all `x ∈ s`\nand `y ∈ t`.  -/\ntheorem of_function_union_of_top_of_nonempty_inter {s t : set α}\n    (h : ∀ u, (s ∩ u).nonempty → (t ∩ u).nonempty → m u = ennreal.top) :\n    outer_measure.of_function m m_empty (s ∪ t) =\n      outer_measure.of_function m m_empty s + outer_measure.of_function m m_empty t :=\n  by\n  refine' le_antisymm (outer_measure.union _ _ _) (le_infᵢ fun f => le_infᵢ fun hf => _)\n  set μ := outer_measure.of_function m m_empty\n  rcases em (∃ i, (s ∩ f i).nonempty ∧ (t ∩ f i).nonempty) with (⟨i, hs, ht⟩ | he)\n  ·\n    calc\n      μ s + μ t ≤ ennreal.top := le_top\n      _ = m (f i) := (h (f i) hs ht).symm\n      _ ≤ «expr∑' , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , »\" (m (f i)) :=\n        ennreal.le_tsum i\n      \n  set I := fun s => { i : ℕ | (s ∩ f i).nonempty }\n  have hd : Disjoint (I s) (I t) := disjoint_iff_inf_le.mpr fun i hi => he ⟨i, hi⟩\n  have hI :\n    ∀ (u) (_ : u ⊆ s ∪ t),\n      μ u ≤\n        «expr∑' , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , »\" (μ (f i)) :=\n    fun u hu =>\n    calc\n      μ u ≤ μ («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (f i)) :=\n        μ.mono fun x hx =>\n          let ⟨i, hi⟩ := mem_Union.1 (hf (hu hx))\n          mem_Union.2 ⟨⟨i, ⟨x, hx, hi⟩⟩, hi⟩\n      _ ≤ «expr∑' , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , »\" (μ (f i)) :=\n        μ.Union _\n      \n  calc\n    μ s + μ t ≤\n        «expr∑' , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , »\" (μ (f i)) +\n          «expr∑' , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , »\" (μ (f i)) :=\n      add_le_add (hI _ <| subset_union_left _ _) (hI _ <| subset_union_right _ _)\n    _ = «expr∑' , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , »\" (μ (f i)) :=\n      (@tsum_union_disjoint _ _ _ _ _ (fun i => μ (f i)) _ _ _ hd ennreal.summable ennreal.summable).symm\n    _ ≤ «expr∑' , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , »\" (μ (f i)) :=\n      tsum_le_tsum_of_inj coe subtype.coe_injective (fun _ _ => zero_le _) (fun _ => le_rfl) ennreal.summable\n        ennreal.summable\n    _ ≤ «expr∑' , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , »\" (m (f i)) :=\n      ennreal.tsum_le_tsum fun i => of_function_le _\n    \n#align of_function_union_of_top_of_nonempty_inter of_function_union_of_top_of_nonempty_inter\n\n",
 "of_function_le":
 "theorem of_function_le (s : set α) : outer_measure.of_function m m_empty s ≤ m s :=\n  let f : ℕ → set α := fun i => nat.cases_on i s fun _ => ∅\n  infᵢ_le_of_le f <|\n    infᵢ_le_of_le (subset_unionᵢ f 0) <| le_of_eq <| tsum_eq_single 0 <| by rintro (_ | i) <;> simp [f, m_empty]\n#align of_function_le of_function_le\n\n",
 "of_function_eq_Sup":
 "theorem of_function_eq_Sup : outer_measure.of_function m m_empty = supₛ { μ | ∀ s, μ s ≤ m s } :=\n  (@is_greatest_of_function α m m_empty).is_lub.Sup_eq.symm\n#align of_function_eq_Sup of_function_eq_Sup\n\n",
 "of_function_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , » -/\ntheorem of_function_eq (s : set α) (m_mono : ∀ ⦃t : set α⦄, s ⊆ t → m s ≤ m t)\n    (m_subadd :\n      ∀ s : ℕ → set α,\n        m («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (s i)) ≤\n          «expr∑' , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , »\" (m (s i))) :\n    outer_measure.of_function m m_empty s = m s :=\n  le_antisymm (of_function_le s) <| le_infᵢ fun f => le_infᵢ fun hf => le_trans (m_mono hf) (m_subadd f)\n#align of_function_eq of_function_eq\n\n",
 "of_function_caratheodory":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\ntheorem of_function_caratheodory {m : set α → ennreal} {s : set α} {h₀ : m ∅ = 0}\n    (hs : ∀ t, m (t ∩ s) + m (t \\ s) ≤ m t) : (measurable_set_of (outer_measure.of_function m h₀).caratheodory) s :=\n  by\n  apply (is_caratheodory_iff_le _).mpr\n  refine' fun t => le_infᵢ fun f => le_infᵢ fun hf => _\n  refine'\n    le_trans\n      (add_le_add ((infᵢ_le_of_le fun i => f i ∩ s) <| infᵢ_le _ _) ((infᵢ_le_of_le fun i => f i \\ s) <| infᵢ_le _ _)) _\n  · rw [← Union_inter]\n    exact inter_subset_inter_left _ hf\n  · rw [← Union_diff]\n    exact diff_subset_diff_left hf\n  · rw [← ennreal.tsum_add]\n    exact ennreal.tsum_le_tsum fun i => hs _\n#align of_function_caratheodory of_function_caratheodory\n\n",
 "of_function_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , » -/\ntheorem of_function_apply (s : set α) :\n    outer_measure.of_function m m_empty s =\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n        («expr∑' , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , »\" (m (t n))) :=\n  rfl\n#align of_function_apply of_function_apply\n\n",
 "null_of_locally_null":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:632:2: warning: expanding binder collection (t «expr ⊆ » s) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/-- If a set has zero measure in a neighborhood of each of its points, then it has zero measure\nin a second-countable space. -/\ntheorem null_of_locally_null [topological_space α] [second_countable_topology α] (m : outer_measure α) (s : set α)\n    (hs : ∀ x ∈ s, ∃ u ∈ nhds_within s x, m u = 0) : m s = 0 :=\n  by\n  choose! u hxu hu₀ using hs\n  obtain ⟨t, ts, t_count, ht⟩ :\n    ∃ (t : _)(_ : t ⊆ s),\n      t.countable ∧\n        s ⊆ «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (u x) :=\n    topological_space.countable_cover_nhds_within hxu\n  apply m.mono_null ht\n  exact (m.bUnion_null_iff t_count).2 fun x hx => hu₀ x (ts hx)\n#align null_of_locally_null null_of_locally_null\n\n",
 "mono_null":
 "theorem mono_null (m : outer_measure α) {s t} (h : s ⊆ t) (ht : m t = 0) : m s = 0 :=\n  nonpos_iff_eq_zero.mp <| ht ▸ m.mono' h\n#align mono_null mono_null\n\n",
 "mono''":
 "@[mono]\ntheorem mono'' {m₁ m₂ : outer_measure α} {s₁ s₂ : set α} (hm : m₁ ≤ m₂) (hs : s₁ ⊆ s₂) : m₁ s₁ ≤ m₂ s₂ :=\n  (hm s₁).trans (m₂.mono hs)\n#align mono'' mono''\n\n",
 "mono'":
 "theorem mono' (m : outer_measure α) {s₁ s₂} (h : s₁ ⊆ s₂) : m s₁ ≤ m s₂ :=\n  m.mono h\n#align mono' mono'\n\n",
 "measure_of_eq_coe":
 "/-\nCopyright (c) 2017 Johannes Hölzl. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johannes Hölzl, Mario Carneiro\n-/\n@[simp]\ntheorem measure_of_eq_coe (m : outer_measure α) : m.measure_of = m :=\n  rfl\n#align measure_of_eq_coe measure_of_eq_coe\n\n",
 "measure_inter_union":
 "theorem measure_inter_union (h : s₁ ∩ s₂ ⊆ ∅) (h₁ : is_caratheodory s₁) {t : set α} :\n    m (t ∩ (s₁ ∪ s₂)) = m (t ∩ s₁) + m (t ∩ s₂) := by\n  rw [h₁, Set.inter_assoc, Set.union_inter_cancel_left, inter_diff_assoc, union_diff_cancel_left h]\n#align measure_inter_union measure_inter_union\n\n",
 "map_top_of_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem map_top_of_surjective (f : α → β) (hf : surjective f) : map f («expr⊤») = «expr⊤» := by\n  rw [map_top, hf.range_eq, restrict_univ]\n#align map_top_of_surjective map_top_of_surjective\n\n",
 "map_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem map_top (f : α → β) : map f («expr⊤») = restrict (range f) («expr⊤») :=\n  ext fun s => by\n    rw [map_apply, restrict_apply, ← image_preimage_eq_inter_range, top_apply', top_apply', Set.image_eq_empty]\n#align map_top map_top\n\n",
 "map_supr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n@[simp]\ntheorem map_supr {β ι} (f : α → β) (m : ι → outer_measure α) :\n    map f («expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (m i)) =\n      «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (map f (m i)) :=\n  ext fun s => by simp only [map_apply, supᵢ_apply]\n#align map_supr map_supr\n\n",
 "map_sup":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n@[simp]\ntheorem map_sup {β} (f : α → β) (m m' : outer_measure α) : map f («expr ⊔ » m m') = «expr ⊔ » (map f m) (map f m') :=\n  ext fun s => by simp only [map_apply, sup_apply]\n#align map_sup map_sup\n\n",
 "map_of_function_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem map_of_function_le {β} (f : α → β) :\n    map f (outer_measure.of_function m m_empty) ≤ outer_measure.of_function (fun s => m («expr ⁻¹' » f s)) m_empty :=\n  le_of_function.2 fun s => by\n    rw [map_apply]\n    apply of_function_le\n#align map_of_function_le map_of_function_le\n\n",
 "map_of_function":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem map_of_function {β} {f : α → β} (hf : injective f) :\n    map f (outer_measure.of_function m m_empty) = outer_measure.of_function (fun s => m («expr ⁻¹' » f s)) m_empty :=\n  by\n  refine' (map_of_function_le _).antisymm fun s => _\n  simp only [of_function_apply, map_apply, le_infᵢ_iff]\n  intro t ht\n  refine' infᵢ_le_of_le (fun n => «expr ᶜ» (range f) ∪ «expr '' » f (t n)) (infᵢ_le_of_le _ _)\n  · rw [← union_Union, ← inter_subset, ← image_preimage_eq_inter_range, ← image_Union]\n    exact image_subset _ ht\n  · refine' ennreal.tsum_le_tsum fun n => le_of_eq _\n    simp [hf.preimage_image]\n#align map_of_function map_of_function\n\n",
 "map_mono":
 "@[mono]\ntheorem map_mono {β} (f : α → β) : monotone (map f) := fun m m' h s => h _\n#align map_mono map_mono\n\n",
 "map_map":
 "@[simp]\ntheorem map_map {β γ} (f : α → β) (g : β → γ) (m : outer_measure α) : map g (map f m) = map (g ∘ f) m :=\n  ext fun s => rfl\n#align map_map map_map\n\n",
 "map_le_restrict_range":
 "@[simp]\ntheorem map_le_restrict_range {β} {ma : outer_measure α} {mb : outer_measure β} {f : α → β} :\n    map f ma ≤ restrict (range f) mb ↔ map f ma ≤ mb :=\n  ⟨fun h => h.trans (restrict_le_self _ _), fun h s => by simpa using h (s ∩ range f)⟩\n#align map_le_restrict_range map_le_restrict_range\n\n",
 "map_infi_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\ntheorem map_infi_le {ι β} (f : α → β) (m : ι → outer_measure α) :\n    map f («expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (m i)) ≤\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (map f (m i)) :=\n  (map_mono f).map_infi_le\n#align map_infi_le map_infi_le\n\n",
 "map_infi_comap":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\ntheorem map_infi_comap {ι β} [nonempty ι] {f : α → β} (m : ι → outer_measure β) :\n    map f\n        («expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n          (comap f (m i))) =\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n        (map f (comap f (m i))) :=\n  by\n  refine' (map_infi_le _ _).antisymm fun s => _\n  simp only [map_apply, comap_apply, infᵢ_apply, le_infᵢ_iff]\n  refine' fun t ht => infᵢ_le_of_le (fun n => «expr '' » f (t n) ∪ «expr ᶜ» (range f)) (infᵢ_le_of_le _ _)\n  · rw [← Union_union, Set.union_comm, ← inter_subset, ← image_Union, ← image_preimage_eq_inter_range]\n    exact image_subset _ ht\n  · refine' ennreal.tsum_le_tsum fun n => infᵢ_mono fun i => (m i).mono _\n    simp\n#align map_infi_comap map_infi_comap\n\n",
 "map_infi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\ntheorem map_infi {ι β} {f : α → β} (hf : injective f) (m : ι → outer_measure α) :\n    map f («expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (m i)) =\n      restrict (range f)\n        («expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n          (map f (m i))) :=\n  by\n  refine' eq.trans _ (map_comap _ _)\n  simp only [comap_infi, comap_map hf]\n#align map_infi map_infi\n\n",
 "map_id":
 "@[simp]\ntheorem map_id (m : outer_measure α) : map id m = m :=\n  ext fun s => rfl\n#align map_id map_id\n\n",
 "map_comap_of_surjective":
 "theorem map_comap_of_surjective {β} {f : α → β} (hf : surjective f) (m : outer_measure β) : map f (comap f m) = m :=\n  ext fun s => by rw [map_apply, comap_apply, hf.image_preimage]\n#align map_comap_of_surjective map_comap_of_surjective\n\n",
 "map_comap_le":
 "theorem map_comap_le {β} (f : α → β) (m : outer_measure β) : map f (comap f m) ≤ m := fun s =>\n  m.mono <| image_preimage_subset _ _\n#align map_comap_le map_comap_le\n\n",
 "map_comap":
 "theorem map_comap {β} (f : α → β) (m : outer_measure β) : map f (comap f m) = restrict (range f) m :=\n  ext fun s => congr_arg m <| by simp only [image_preimage_eq_inter_range, Subtype.range_coe]\n#align map_comap map_comap\n\n",
 "map_binfi_comap":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\ntheorem map_binfi_comap {ι β} {I : set ι} (hI : I.nonempty) {f : α → β} (m : ι → outer_measure β) :\n    map f\n        («expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n          (comap f (m i))) =\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n        (map f (comap f (m i))) :=\n  by\n  haveI := hI.to_subtype\n  rw [← infᵢ_subtype'', ← infᵢ_subtype'']\n  exact map_infi_comap _\n#align map_binfi_comap map_binfi_comap\n\n",
 "map_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n@[simp]\ntheorem map_apply {β} (f : α → β) (m : outer_measure α) (s : set β) : map f m s = m («expr ⁻¹' » f s) :=\n  rfl\n#align map_apply map_apply\n\n",
 "le_trim_iff":
 "theorem le_trim_iff {m₁ m₂ : outer_measure α} : m₁ ≤ m₂.trim ↔ ∀ s, measurable_set s → m₁ s ≤ m₂ s :=\n  le_of_function.trans <| forall_congr' fun s => le_infᵢ_iff\n#align le_trim_iff le_trim_iff\n\n",
 "le_trim":
 "theorem le_trim : m ≤ m.trim :=\n  le_of_function.mpr fun s => le_infᵢ fun _ => le_rfl\n#align le_trim le_trim\n\n",
 "le_sum_caratheodory":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\ntheorem le_sum_caratheodory {ι} (m : ι → outer_measure α) :\n    «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (m i).caratheodory ≤\n      (sum m).caratheodory :=\n  fun s h t => by simp [fun i => measurable_space.measurable_set_infi.1 h i t, ennreal.tsum_add]\n#align le_sum_caratheodory le_sum_caratheodory\n\n",
 "le_smul_caratheodory":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem le_smul_caratheodory (a : ennreal) (m : outer_measure α) : m.caratheodory ≤ («expr • » a m).caratheodory :=\n  fun s h t => by simp [h t, mul_add]\n#align le_smul_caratheodory le_smul_caratheodory\n\n",
 "le_of_function":
 "theorem le_of_function {μ : outer_measure α} : μ ≤ outer_measure.of_function m m_empty ↔ ∀ s, μ s ≤ m s :=\n  ⟨fun H s => le_trans (H s) (of_function_le s), fun H s =>\n    le_infᵢ fun f =>\n      le_infᵢ fun hs => le_trans (μ.mono hs) <| le_trans (μ.Union f) <| ennreal.tsum_le_tsum fun i => H _⟩\n#align le_of_function le_of_function\n\n",
 "le_inter_add_diff":
 "theorem le_inter_add_diff {m : outer_measure α} {t : set α} (s : set α) : m t ≤ m (t ∩ s) + m (t \\ s) :=\n  by\n  convert m.union _ _\n  rw [inter_union_diff t s]\n#align le_inter_add_diff le_inter_add_diff\n\n",
 "le_induced_outer_measure":
 "theorem le_induced_outer_measure {μ : outer_measure α} :\n    μ ≤ induced_outer_measure m P0 m0 ↔ ∀ (s) (hs : P s), μ s ≤ m s hs :=\n  le_of_function.trans <| forall_congr' fun s => le_infᵢ_iff\n#align le_induced_outer_measure le_induced_outer_measure\n\n",
 "le_extend":
 "theorem le_extend {s : α} (h : P s) : m s h ≤ extend m s :=\n  by\n  simp only [extend, le_infᵢ_iff]\n  intro\n  rfl\n#align le_extend le_extend\n\n",
 "le_comap_map":
 "theorem le_comap_map {β} (f : α → β) (m : outer_measure α) : m ≤ comap f (map f m) := fun s =>\n  m.mono <| subset_preimage_image _ _\n#align le_comap_map le_comap_map\n\n",
 "le_bounded_by'":
 "theorem le_bounded_by' {μ : outer_measure α} : μ ≤ bounded_by m ↔ ∀ s : set α, s.nonempty → μ s ≤ m s :=\n  by\n  rw [le_bounded_by, forall_congr']\n  intro s\n  cases' s.eq_empty_or_nonempty with h h <;> simp [h]\n#align le_bounded_by' le_bounded_by'\n\n",
 "le_bounded_by":
 "theorem le_bounded_by {μ : outer_measure α} : μ ≤ bounded_by m ↔ ∀ s, μ s ≤ m s :=\n  by\n  rw [bounded_by, le_of_function, forall_congr']; intro s\n  cases' s.eq_empty_or_nonempty with h h <;> simp [h, not_nonempty_empty]\n#align le_bounded_by le_bounded_by\n\n",
 "le_add_caratheodory":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\ntheorem le_add_caratheodory (m₁ m₂ : outer_measure α) :\n    «expr ⊓ » m₁.caratheodory m₂.caratheodory ≤ (m₁ + m₂ : outer_measure α).caratheodory := fun s ⟨hs₁, hs₂⟩ t => by\n  simp [hs₁ t, hs₂ t, add_left_comm, add_assoc]\n#align le_add_caratheodory le_add_caratheodory\n\n",
 "is_greatest_of_function":
 "theorem is_greatest_of_function :\n    IsGreatest { μ : outer_measure α | ∀ s, μ s ≤ m s } (outer_measure.of_function m m_empty) :=\n  ⟨fun s => of_function_le _, fun μ => le_of_function.2⟩\n#align is_greatest_of_function is_greatest_of_function\n\n",
 "is_caratheodory_union":
 "theorem is_caratheodory_union (h₁ : is_caratheodory s₁) (h₂ : is_caratheodory s₂) : is_caratheodory (s₁ ∪ s₂) :=\n  fun t =>\n  by\n  rw [h₁ t, h₂ (t ∩ s₁), h₂ (t \\ s₁), h₁ (t ∩ (s₁ ∪ s₂)), inter_diff_assoc _ _ s₁, Set.inter_assoc _ _ s₁,\n    inter_eq_self_of_subset_right (Set.subset_union_left _ _), union_diff_left, h₂ (t ∩ s₁)]\n  simp [diff_eq, add_assoc]\n#align is_caratheodory_union is_caratheodory_union\n\n",
 "is_caratheodory_sum":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr on » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\ntheorem is_caratheodory_sum {s : ℕ → set α} (h : ∀ i, is_caratheodory (s i)) (hd : Pairwise («expr on » Disjoint s))\n    {t : set α} :\n    ∀ {n},\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (Finset.range n)\n          (m (t ∩ s i)) =\n        m (t ∩ «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (s i))\n  | 0 => by simp [nat.not_lt_zero, m.empty]\n  | nat.succ n =>\n    by\n    rw [bUnion_lt_succ, finset.sum_range_succ, Set.union_comm, is_caratheodory_sum, m.measure_inter_union _ (h n),\n      add_comm]\n    intro a\n    simpa using fun (h₁ : a ∈ s n) i (hi : i < n) h₂ => (hd (ne_of_gt hi)).le_bot ⟨h₁, h₂⟩\n#align is_caratheodory_sum is_caratheodory_sum\n\n",
 "is_caratheodory_inter":
 "theorem is_caratheodory_inter (h₁ : is_caratheodory s₁) (h₂ : is_caratheodory s₂) : is_caratheodory (s₁ ∩ s₂) :=\n  by\n  rw [← is_caratheodory_compl_iff, Set.compl_inter]\n  exact is_caratheodory_union _ (is_caratheodory_compl _ h₁) (is_caratheodory_compl _ h₂)\n#align is_caratheodory_inter is_caratheodory_inter\n\n",
 "is_caratheodory_iff_le'":
 "theorem is_caratheodory_iff_le' {s : set α} : is_caratheodory s ↔ ∀ t, m (t ∩ s) + m (t \\ s) ≤ m t :=\n  forall_congr' fun t => le_antisymm_iff.trans <| and_iff_right <| le_inter_add_diff _\n#align is_caratheodory_iff_le' is_caratheodory_iff_le'\n\n",
 "is_caratheodory_iff_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\ntheorem is_caratheodory_iff_le {s : set α} : (measurable_set_of caratheodory) s ↔ ∀ t, m (t ∩ s) + m (t \\ s) ≤ m t :=\n  is_caratheodory_iff_le'\n#align is_caratheodory_iff_le is_caratheodory_iff_le\n\n",
 "is_caratheodory_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\ntheorem is_caratheodory_iff {s : set α} : (measurable_set_of caratheodory) s ↔ ∀ t, m t = m (t ∩ s) + m (t \\ s) :=\n  iff.rfl\n#align is_caratheodory_iff is_caratheodory_iff\n\n",
 "is_caratheodory_empty":
 "@[simp]\ntheorem is_caratheodory_empty : is_caratheodory ∅ := by simp [is_caratheodory, m.empty, diff_empty]\n#align is_caratheodory_empty is_caratheodory_empty\n\n",
 "is_caratheodory_compl_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n@[simp]\ntheorem is_caratheodory_compl_iff : is_caratheodory («expr ᶜ» s) ↔ is_caratheodory s :=\n  ⟨fun h => by simpa using is_caratheodory_compl m h, is_caratheodory_compl⟩\n#align is_caratheodory_compl_iff is_caratheodory_compl_iff\n\n",
 "is_caratheodory_compl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\ntheorem is_caratheodory_compl : is_caratheodory s₁ → is_caratheodory («expr ᶜ» s₁) := by\n  simp [is_caratheodory, diff_eq, add_comm]\n#align is_caratheodory_compl is_caratheodory_compl\n\n",
 "is_caratheodory_Union_nat":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr on » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\ntheorem is_caratheodory_Union_nat {s : ℕ → set α} (h : ∀ i, is_caratheodory (s i))\n    (hd : Pairwise («expr on » Disjoint s)) :\n    is_caratheodory\n      («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (s i)) :=\n  is_caratheodory_iff_le'.2 fun t =>\n    by\n    have hp :\n      m (t ∩ «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (s i)) ≤\n        «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n          (m\n            (t ∩\n              «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (s i))) :=\n      by\n      convert m.Union fun i => t ∩ s i\n      · rw [inter_Union]\n      · simp [ennreal.tsum_eq_supr_nat, is_caratheodory_sum m h hd]\n    refine' le_trans (add_le_add_right hp _) _\n    rw [ennreal.supr_add]\n    refine' supᵢ_le fun n => le_trans (add_le_add_left _ _) (ge_of_eq (is_caratheodory_Union_lt m (fun i _ => h i) _))\n    refine' m.mono (diff_subset_diff_right _)\n    exact Union₂_subset fun i _ => subset_Union _ i\n#align is_caratheodory_Union_nat is_caratheodory_Union_nat\n\n",
 "is_caratheodory_Union_lt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\ntheorem is_caratheodory_Union_lt {s : ℕ → set α} :\n    ∀ {n : ℕ},\n      (∀ i < n, is_caratheodory (s i)) →\n        is_caratheodory\n          («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (s i))\n  | 0, h => by simp [nat.not_lt_zero]\n  | n + 1, h => by\n    rw [bUnion_lt_succ] <;>\n      exact\n        is_caratheodory_union m (is_caratheodory_Union_lt fun i hi => h i <| lt_of_lt_of_le hi <| nat.le_succ _)\n          (h n (le_refl (n + 1)))\n#align is_caratheodory_Union_lt is_caratheodory_Union_lt\n\n",
 "infₛ_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n#print infₛ_apply /-\n/-- The value of the Infimum of a nonempty set of outer measures on a set is not simply\nthe minimum value of a measure on that set: it is the infimum sum of measures of countable set of\nsets that covers that set, where a different measure can be used for each set in the cover. -/\ntheorem infₛ_apply {m : set (outer_measure α)} {s : set α} (h : m.nonempty) :\n    infₛ m s =\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n        («expr∑' , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , »\"\n          («expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n            (μ (t n)))) :=\n  by simp_rw [Inf_eq_bounded_by_Inf_gen, bounded_by_apply, supr_Inf_gen_nonempty h]\n#align Inf_apply infₛ_apply\n-/\n\n",
 "infᵢ_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n#print infᵢ_apply /-\n/-- The value of the Infimum of a nonempty family of outer measures on a set is not simply\nthe minimum value of a measure on that set: it is the infimum sum of measures of countable set of\nsets that covers that set, where a different measure can be used for each set in the cover. -/\ntheorem infᵢ_apply {ι} [nonempty ι] (m : ι → outer_measure α) (s : set α) :\n    («expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (m i)) s =\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n        («expr∑' , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , »\"\n          («expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n            (m i (t n)))) :=\n  by\n  rw [infᵢ, infₛ_apply (range_nonempty m)]\n  simp only [infᵢ_range]\n#align infi_apply infᵢ_apply\n-/\n\n",
 "infi_apply'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/-- The value of the Infimum of a family of outer measures on a nonempty set is not simply\nthe minimum value of a measure on that set: it is the infimum sum of measures of countable set of\nsets that covers that set, where a different measure can be used for each set in the cover. -/\ntheorem infi_apply' {ι} (m : ι → outer_measure α) {s : set α} (hs : s.nonempty) :\n    («expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (m i)) s =\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n        («expr∑' , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , »\"\n          («expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n            (m i (t n)))) :=\n  by\n  rw [infᵢ, Inf_apply' hs]\n  simp only [infᵢ_range]\n#align infi_apply' infi_apply'\n\n",
 "induced_outer_measure_union_of_false_of_nonempty_inter":
 "/-- If `P u` is `false` for any set `u` that has nonempty intersection both with `s` and `t`, then\n`μ (s ∪ t) = μ s + μ t`, where `μ = induced_outer_measure m P0 m0`.\n\nE.g., if `α` is an (e)metric space and `P u = diam u < r`, then this lemma implies that\n`μ (s ∪ t) = μ s + μ t` on any two sets such that `r ≤ edist x y` for all `x ∈ s` and `y ∈ t`. -/\ntheorem induced_outer_measure_union_of_false_of_nonempty_inter {s t : set α}\n    (h : ∀ u, (s ∩ u).nonempty → (t ∩ u).nonempty → ¬P u) :\n    induced_outer_measure m P0 m0 (s ∪ t) = induced_outer_measure m P0 m0 s + induced_outer_measure m P0 m0 t :=\n  of_function_union_of_top_of_nonempty_inter fun u hsu htu => @infᵢ_of_empty _ _ _ ⟨h u hsu htu⟩ _\n#align induced_outer_measure_union_of_false_of_nonempty_inter induced_outer_measure_union_of_false_of_nonempty_inter\n\n",
 "induced_outer_measure_preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem induced_outer_measure_preimage (f : «expr ≃ » α α) (Pm : ∀ s : set α, P («expr ⁻¹' » f s) ↔ P s)\n    (mm : ∀ (s : set α) (hs : P s), m («expr ⁻¹' » f s) ((Pm _).mpr hs) = m s hs) {A : set α} :\n    induced_outer_measure m P0 m0 («expr ⁻¹' » f A) = induced_outer_measure m P0 m0 A :=\n  by\n  simp only [induced_outer_measure_eq_infi _ msU m_mono]; symm\n  refine' f.injective.preimage_surjective.infi_congr (preimage f) fun s => _\n  refine' infᵢ_congr_Prop (Pm s) _; intro hs\n  refine' infᵢ_congr_Prop f.surjective.preimage_subset_preimage_iff _\n  intro h2s; exact mm s hs\n#align induced_outer_measure_preimage induced_outer_measure_preimage\n\n",
 "induced_outer_measure_exists_set":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\ntheorem induced_outer_measure_exists_set {s : set α} (hs : induced_outer_measure m P0 m0 s ≠ ennreal.top) {ε : ennreal}\n    (hε : ε ≠ 0) :\n    ∃ (t : set α)(ht : P t), s ⊆ t ∧ induced_outer_measure m P0 m0 t ≤ induced_outer_measure m P0 m0 s + ε :=\n  by\n  have := ennreal.lt_add_right hs hε\n  conv at this =>\n    lhs\n    rw [induced_outer_measure_eq_infi _ msU m_mono]\n  simp only [infᵢ_lt_iff] at this\n  rcases this with ⟨t, h1t, h2t, h3t⟩\n  exact ⟨t, h1t, h2t, le_trans (le_of_eq <| induced_outer_measure_eq' _ msU m_mono h1t) (le_of_lt h3t)⟩\n#align induced_outer_measure_exists_set induced_outer_measure_exists_set\n\n",
 "induced_outer_measure_eq_infi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\ntheorem induced_outer_measure_eq_infi (s : set α) :\n    induced_outer_measure m P0 m0 s =\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (m t ht) :=\n  by\n  apply le_antisymm\n  · simp only [le_infᵢ_iff]\n    intro t ht hs\n    refine' le_trans (mono' _ hs) _\n    exact le_of_eq (induced_outer_measure_eq' _ msU m_mono _)\n  · refine' le_infᵢ _\n    intro f\n    refine' le_infᵢ _\n    intro hf\n    refine' le_trans _ (extend_Union_le_tsum_nat' _ msU _)\n    refine' le_infᵢ _\n    intro h2f\n    refine' infᵢ_le_of_le _ (infᵢ_le_of_le h2f <| infᵢ_le _ hf)\n#align induced_outer_measure_eq_infi induced_outer_measure_eq_infi\n\n",
 "induced_outer_measure_eq_extend'":
 "theorem induced_outer_measure_eq_extend' {s : set α} (hs : P s) : induced_outer_measure m P0 m0 s = extend m s :=\n  of_function_eq s (fun t => extend_mono' m_mono hs) (extend_Union_le_tsum_nat' PU msU)\n#align induced_outer_measure_eq_extend' induced_outer_measure_eq_extend'\n\n",
 "induced_outer_measure_eq_extend":
 "theorem induced_outer_measure_eq_extend {s : set α} (hs : measurable_set s) :\n    induced_outer_measure m measurable_set.empty m0 s = extend m s :=\n  of_function_eq s (fun t => extend_mono m0 mU hs) (extend_Union_le_tsum_nat m0 mU)\n#align induced_outer_measure_eq_extend induced_outer_measure_eq_extend\n\n",
 "induced_outer_measure_eq'":
 "theorem induced_outer_measure_eq' {s : set α} (hs : P s) : induced_outer_measure m P0 m0 s = m s hs :=\n  (induced_outer_measure_eq_extend' PU msU m_mono hs).trans <| extend_eq _ _\n#align induced_outer_measure_eq' induced_outer_measure_eq'\n\n",
 "induced_outer_measure_eq":
 "theorem induced_outer_measure_eq {s : set α} (hs : measurable_set s) :\n    induced_outer_measure m measurable_set.empty m0 s = m s hs :=\n  (induced_outer_measure_eq_extend m0 mU hs).trans <| extend_eq _ _\n#align induced_outer_measure_eq induced_outer_measure_eq\n\n",
 "induced_outer_measure_caratheodory":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\n/-- To test whether `s` is Carathéodory-measurable we only need to check the sets `t` for which\n  `P t` holds. See `of_function_caratheodory` for another way to show the Carathéodory-measurability\n  of `s`.\n-/\ntheorem induced_outer_measure_caratheodory (s : set α) :\n    (measurable_set_of (induced_outer_measure m P0 m0).caratheodory) s ↔\n      ∀ t : set α,\n        P t →\n          induced_outer_measure m P0 m0 (t ∩ s) + induced_outer_measure m P0 m0 (t \\ s) ≤\n            induced_outer_measure m P0 m0 t :=\n  by\n  rw [is_caratheodory_iff_le]\n  constructor\n  · intro h t ht\n    exact h t\n  · intro h u\n    conv_rhs => rw [induced_outer_measure_eq_infi _ msU m_mono]\n    refine' le_infᵢ _\n    intro t\n    refine' le_infᵢ _\n    intro ht\n    refine' le_infᵢ _\n    intro h2t\n    refine' le_trans _ (le_trans (h t ht) <| le_of_eq <| induced_outer_measure_eq' _ msU m_mono ht)\n    refine' add_le_add (mono' _ <| Set.inter_subset_inter_left _ h2t) (mono' _ <| diff_subset_diff_left h2t)\n#align induced_outer_measure_caratheodory induced_outer_measure_caratheodory\n\n",
 "f_Union":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr on » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , » -/\ntheorem f_Union {s : ℕ → set α} (h : ∀ i, is_caratheodory (s i)) (hd : Pairwise («expr on » Disjoint s)) :\n    m («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (s i)) =\n      «expr∑' , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , »\" (m (s i)) :=\n  by\n  refine' le_antisymm (m.Union_nat s) _\n  rw [ennreal.tsum_eq_supr_nat]\n  refine' supᵢ_le fun n => _\n  have := @is_caratheodory_sum _ m _ h hd univ n\n  simp at this; simp [this]\n  exact m.mono (Union₂_subset fun i _ => subset_Union _ i)\n#align f_Union f_Union\n\n",
 "extend_union":
 "theorem extend_union {s₁ s₂ : set α} (hd : Disjoint s₁ s₂) (h₁ : P s₁) (h₂ : P s₂) :\n    extend m (s₁ ∪ s₂) = extend m s₁ + extend m s₂ :=\n  by\n  rw [union_eq_Union, extend_Union P0 m0 PU mU (pairwise_disjoint_on_bool.2 hd) (bool.forall_bool.2 ⟨h₂, h₁⟩),\n    tsum_fintype]\n  simp\n#align extend_union extend_union\n\n",
 "extend_mono'":
 "theorem extend_mono' ⦃s₁ s₂ : set α⦄ (h₁ : P s₁) (hs : s₁ ⊆ s₂) : extend m s₁ ≤ extend m s₂ :=\n  by\n  refine' le_infᵢ _\n  intro h₂\n  rw [extend_eq m h₁]\n  exact m_mono h₁ h₂ hs\n#align extend_mono' extend_mono'\n\n",
 "extend_mono":
 "theorem extend_mono {s₁ s₂ : set α} (h₁ : measurable_set s₁) (hs : s₁ ⊆ s₂) : extend m s₁ ≤ extend m s₂ :=\n  by\n  refine' le_infᵢ _; intro h₂\n  have := extend_union measurable_set.empty m0 measurable_set.Union mU disjoint_sdiff_self_right h₁ (h₂.diff h₁)\n  rw [union_diff_cancel hs] at this\n  rw [← extend_eq m]\n  exact le_iff_exists_add.2 ⟨_, this⟩\n#align extend_mono extend_mono\n\n",
 "extend_eq_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\ntheorem extend_eq_top {s : α} (h : ¬P s) : extend m s = ennreal.top := by simp [extend, h]\n#align extend_eq_top extend_eq_top\n\n",
 "extend_eq":
 "theorem extend_eq {s : α} (h : P s) : extend m s = m s h := by simp [extend, h]\n#align extend_eq extend_eq\n\n",
 "extend_empty":
 "theorem extend_empty : extend m ∅ = 0 :=\n  (extend_eq _ P0).trans m0\n#align extend_empty extend_empty\n\n",
 "extend_congr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n-- TODO: why this is a bad `congr` lemma?\ntheorem extend_congr {β : Type _} {Pb : β → Prop} {mb : ∀ s : β, Pb s → ennreal} {sa : α} {sb : β} (hP : P sa ↔ Pb sb)\n    (hm : ∀ (ha : P sa) (hb : Pb sb), m sa ha = mb sb hb) : extend m sa = extend mb sb :=\n  infᵢ_congr_Prop hP fun h => hm _ _\n#align extend_congr extend_congr\n\n",
 "extend_Union_nat":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , » -/\ntheorem extend_Union_nat {f : ℕ → set α} (hm : ∀ i, P (f i))\n    (mU :\n      m («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (f i))\n          (PU hm) =\n        «expr∑' , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , »\"\n          (m (f i) (hm i))) :\n    extend m («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (f i)) =\n      «expr∑' , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , »\"\n        (extend m (f i)) :=\n  (extend_eq _ _).trans <|\n    mU.trans <| by\n      congr with i\n      rw [extend_eq]\n#align extend_Union_nat extend_Union_nat\n\n",
 "extend_Union_le_tsum_nat'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , » -/\ntheorem extend_Union_le_tsum_nat' (s : ℕ → set α) :\n    extend m («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (s i)) ≤\n      «expr∑' , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , »\"\n        (extend m (s i)) :=\n  by\n  by_cases h : ∀ i, P (s i)\n  · rw [extend_eq _ (PU h), congr_arg tsum _]\n    · apply msU h\n    funext i\n    apply extend_eq _ (h i)\n  · cases' not_forall.1 h with i hi\n    exact le_trans (le_infᵢ fun h => hi.elim h) (ennreal.le_tsum i)\n#align extend_Union_le_tsum_nat' extend_Union_le_tsum_nat'\n\n",
 "extend_Union_le_tsum_nat":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , » -/\ntheorem extend_Union_le_tsum_nat :\n    ∀ s : ℕ → set α,\n      extend m («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (s i)) ≤\n        «expr∑' , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , »\"\n          (extend m (s i)) :=\n  by\n  refine' extend_Union_le_tsum_nat' measurable_set.Union _; intro f h\n  simp (config := { singlePass := true }) [Union_disjointed.symm]\n  rw [mU (measurable_set.disjointed h) (disjoint_disjointed _)]\n  refine' ennreal.tsum_le_tsum fun i => _\n  rw [← extend_eq m, ← extend_eq m]\n  exact extend_mono m0 mU (measurable_set.disjointed h _) (disjointed_le f _)\n#align extend_Union_le_tsum_nat extend_Union_le_tsum_nat\n\n",
 "extend_Union":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr on » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , » -/\ntheorem extend_Union {β} [countable β] {f : β → set α} (hd : Pairwise («expr on » Disjoint f)) (hm : ∀ i, P (f i)) :\n    extend m («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (f i)) =\n      «expr∑' , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , »\"\n        (extend m (f i)) :=\n  by\n  cases nonempty_encodable β\n  rw [← Encodable.unionᵢ_decode₂, ← tsum_Union_decode₂]\n  ·\n    exact\n      extend_Union_nat PU (fun n => Encodable.unionᵢ_decode₂_cases P0 hm)\n        (mU _ (Encodable.unionᵢ_decode₂_disjoint_on hd))\n  · exact extend_empty P0 m0\n#align extend_Union extend_Union\n\n",
 "ext_nonempty":
 "/-- A version of `measure_theory.outer_measure.ext` that assumes `μ₁ s = μ₂ s` on all *nonempty*\nsets `s`, and gets `μ₁ ∅ = μ₂ ∅` from `measure_theory.outer_measure.empty'`. -/\ntheorem ext_nonempty {μ₁ μ₂ : outer_measure α} (h : ∀ s : set α, s.nonempty → μ₁ s = μ₂ s) : μ₁ = μ₂ :=\n  ext fun s => s.eq_empty_or_nonempty.elim (fun he => by rw [he, empty', empty']) (h s)\n#align ext_nonempty ext_nonempty\n\n",
 "ext":
 "@[ext]\ntheorem ext {μ₁ μ₂ : outer_measure α} (h : ∀ s, μ₁ s = μ₂ s) : μ₁ = μ₂ :=\n  coe_fn_injective <| funext h\n#align ext ext\n\n",
 "exists_mem_forall_mem_nhds_within_pos":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/-- If `m s ≠ 0`, then for some point `x ∈ s` and any `t ∈ 𝓝[s] x` we have `0 < m t`. -/\ntheorem exists_mem_forall_mem_nhds_within_pos [topological_space α] [second_countable_topology α] (m : outer_measure α)\n    {s : set α} (hs : m s ≠ 0) : ∃ x ∈ s, ∀ t ∈ nhds_within s x, 0 < m t :=\n  by\n  contrapose! hs\n  simp only [nonpos_iff_eq_zero, ← exists_prop] at hs\n  exact m.null_of_locally_null s hs\n#align exists_mem_forall_mem_nhds_within_pos exists_mem_forall_mem_nhds_within_pos\n\n",
 "exists_measurable_superset_of_trim_eq_zero":
 "theorem exists_measurable_superset_of_trim_eq_zero {m : outer_measure α} {s : set α} (h : m.trim s = 0) :\n    ∃ t, s ⊆ t ∧ measurable_set t ∧ m t = 0 :=\n  by\n  rcases exists_measurable_superset_eq_trim m s with ⟨t, hst, ht, hm⟩\n  exact ⟨t, hst, ht, h ▸ hm⟩\n#align exists_measurable_superset_of_trim_eq_zero exists_measurable_superset_of_trim_eq_zero\n\n",
 "exists_measurable_superset_forall_eq_trim":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/-- If `μ i` is a countable family of outer measures, then for every set `s` there exists\na measurable set `t ⊇ s` such that `μ i t = (μ i).trim s` for all `i`. -/\ntheorem exists_measurable_superset_forall_eq_trim {ι} [countable ι] (μ : ι → outer_measure α) (s : set α) :\n    ∃ t, s ⊆ t ∧ measurable_set t ∧ ∀ i, μ i t = (μ i).trim s :=\n  by\n  choose t hst ht hμt using fun i => (μ i).exists_measurable_superset_eq_trim s\n  replace hst := subset_Inter hst\n  replace ht := measurable_set.Inter ht\n  refine'\n    ⟨«expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (t i), hst, ht,\n      fun i => le_antisymm _ _⟩\n  exacts[hμt i ▸ (μ i).mono (Inter_subset _ _), (mono' _ hst).trans_eq ((μ i).trim_eq ht)]\n#align exists_measurable_superset_forall_eq_trim exists_measurable_superset_forall_eq_trim\n\n",
 "exists_measurable_superset_eq_trim":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\ntheorem exists_measurable_superset_eq_trim (m : outer_measure α) (s : set α) :\n    ∃ t, s ⊆ t ∧ measurable_set t ∧ m t = m.trim s :=\n  by\n  simp only [trim_eq_infi];\n  set ms := «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (m t)\n  by_cases hs : ms = ennreal.top\n  · simp only [hs]\n    simp only [infᵢ_eq_top] at hs\n    exact ⟨univ, subset_univ s, measurable_set.univ, hs _ (subset_univ s) measurable_set.univ⟩\n  · have : ∀ r > ms, ∃ t, s ⊆ t ∧ measurable_set t ∧ m t < r :=\n      by\n      intro r hs\n      simpa [infᵢ_lt_iff] using hs\n    have : ∀ n : ℕ, ∃ t, s ⊆ t ∧ measurable_set t ∧ m t < ms + n⁻¹ :=\n      by\n      intro n\n      refine' this _ (ennreal.lt_add_right hs _)\n      simp\n    choose t hsub hm hm'\n    refine'\n      ⟨«expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (t n),\n        subset_Inter hsub, measurable_set.Inter hm, _⟩\n    have : tendsto (fun n : ℕ => ms + n⁻¹) at_top ((nhds) (ms + 0)) :=\n      tendsto_const_nhds.add ennreal.tendsto_inv_nat_nhds_zero\n    rw [add_zero] at this\n    refine' le_antisymm (ge_of_tendsto' this fun n => _) _\n    · exact le_trans (m.mono' <| Inter_subset t n) (hm' n).le\n    · refine'\n        infᵢ_le_of_le\n          («expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (t n)) _\n      refine' infᵢ_le_of_le (subset_Inter hsub) _\n      refine' infᵢ_le _ (measurable_set.Inter hm)\n#align exists_measurable_superset_eq_trim exists_measurable_superset_eq_trim\n\n",
 "empty'":
 "@[simp]\ntheorem empty' (m : outer_measure α) : m ∅ = 0 :=\n  m.empty\n#align empty' empty'\n\n",
 "dirac_caratheodory":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem dirac_caratheodory (a : α) : (dirac a).caratheodory = «expr⊤» :=\n  top_unique fun s _ t => by\n    by_cases ht : a ∈ t; swap; · simp [ht]\n    by_cases hs : a ∈ s <;> simp [*]\n#align dirac_caratheodory dirac_caratheodory\n\n",
 "dirac_apply":
 "@[simp]\ntheorem dirac_apply (a : α) (s : set α) : dirac a s = indicator s (fun _ => 1) a :=\n  rfl\n#align dirac_apply dirac_apply\n\n",
 "diff_null":
 "theorem diff_null (m : outer_measure α) (s : set α) {t : set α} (ht : m t = 0) : m (s \\ t) = m s :=\n  by\n  refine' le_antisymm (m.mono <| diff_subset _ _) _\n  calc\n    m s ≤ m (s ∩ t) + m (s \\ t) := le_inter_add_diff _\n    _ ≤ m t + m (s \\ t) := add_le_add_right (m.mono <| inter_subset_right _ _) _\n    _ = m (s \\ t) := by rw [ht, zero_add]\n    \n#align diff_null diff_null\n\n",
 "comap_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem comap_top (f : α → β) : comap f («expr⊤») = «expr⊤» :=\n  ext_nonempty fun s hs => by rw [comap_apply, top_apply hs, top_apply (hs.image _)]\n#align comap_top comap_top\n\n",
 "comap_supr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n@[simp]\ntheorem comap_supr {β ι} (f : α → β) (m : ι → outer_measure β) :\n    comap f («expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (m i)) =\n      «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (comap f (m i)) :=\n  ext fun s => by simp only [comap_apply, supᵢ_apply]\n#align comap_supr comap_supr\n\n",
 "comap_of_function":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem comap_of_function {β} (f : β → α) (h : monotone m ∨ surjective f) :\n    comap f (outer_measure.of_function m m_empty) =\n      outer_measure.of_function (fun s => m («expr '' » f s)) (by rwa [Set.image_empty]) :=\n  by\n  refine' le_antisymm (le_of_function.2 fun s => _) fun s => _\n  · rw [comap_apply]\n    apply of_function_le\n  · rw [comap_apply, of_function_apply, of_function_apply]\n    refine' infᵢ_mono' fun t => ⟨fun k => «expr ⁻¹' » f (t k), _⟩\n    refine' infᵢ_mono' fun ht => _\n    rw [Set.image_subset_iff, preimage_Union] at ht\n    refine' ⟨ht, ennreal.tsum_le_tsum fun n => _⟩\n    cases h\n    exacts[h (image_preimage_subset _ _), (congr_arg m (h.image_preimage (t n))).le]\n#align comap_of_function comap_of_function\n\n",
 "comap_mono":
 "@[mono]\ntheorem comap_mono {β} (f : α → β) : monotone (comap f) := fun m m' h s => h _\n#align comap_mono comap_mono\n\n",
 "comap_map":
 "theorem comap_map {β} {f : α → β} (hf : injective f) (m : outer_measure α) : comap f (map f m) = m :=\n  ext fun s => by rw [comap_apply, map_apply, hf.preimage_image]\n#align comap_map comap_map\n\n",
 "comap_infi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\ntheorem comap_infi {ι β} (f : α → β) (m : ι → outer_measure β) :\n    comap f («expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (m i)) =\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (comap f (m i)) :=\n  by\n  refine' ext_nonempty fun s hs => _\n  refine' ((comap_mono f).map_infi_le s).antisymm _\n  simp only [comap_apply, infi_apply' _ hs, infi_apply' _ (hs.image _), le_infᵢ_iff, Set.image_subset_iff,\n    preimage_Union]\n  refine' fun t ht => infᵢ_le_of_le _ (infᵢ_le_of_le ht <| ennreal.tsum_le_tsum fun k => _)\n  exact infᵢ_mono fun i => (m i).mono (image_preimage_subset _ _)\n#align comap_infi comap_infi\n\n",
 "comap_bounded_by":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem comap_bounded_by {β} (f : β → α) (h : (monotone fun s : { s : set α // s.nonempty } => m s) ∨ surjective f) :\n    comap f (bounded_by m) = bounded_by fun s => m («expr '' » f s) :=\n  by\n  refine' (comap_of_function _ _).trans _\n  · refine' h.imp (fun H s t hst => supᵢ_le fun hs => _) id\n    have ht : t.nonempty := hs.mono hst\n    exact (@H ⟨s, hs⟩ ⟨t, ht⟩ hst).trans (le_supᵢ (fun h : t.nonempty => m t) ht)\n  · dsimp only [bounded_by]\n    congr with s : 1\n    rw [nonempty_image_iff]\n#align comap_bounded_by comap_bounded_by\n\n",
 "comap_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n@[simp]\ntheorem comap_apply {β} (f : α → β) (m : outer_measure β) (s : set α) : comap f m s = m («expr '' » f s) :=\n  rfl\n#align comap_apply comap_apply\n\n",
 "coe_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n@[simp]\ntheorem coe_zero : «expr⇑ » (0 : outer_measure α) = 0 :=\n  rfl\n#align coe_zero coe_zero\n\n",
 "coe_supr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n@[norm_cast]\ntheorem coe_supr {ι} (f : ι → outer_measure α) :\n    «expr⇑ » («expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (f i)) =\n      «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (f i) :=\n  funext fun s => by rw [supᵢ_apply, _root_.supr_apply]\n#align coe_supr coe_supr\n\n",
 "coe_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem coe_smul (c : R) (m : outer_measure α) : «expr⇑ » («expr • » c m) = «expr • » c m :=\n  rfl\n#align coe_smul coe_smul\n\n",
 "coe_fn_injective":
 "theorem coe_fn_injective : injective fun (μ : outer_measure α) (s : set α) => μ s := fun μ₁ μ₂ h =>\n  by\n  cases μ₁\n  cases μ₂\n  congr\n  exact h\n#align coe_fn_injective coe_fn_injective\n\n",
 "coe_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem coe_bot : («expr⊥» : outer_measure α) = 0 :=\n  rfl\n#align coe_bot coe_bot\n\n",
 "coe_add":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n@[simp]\ntheorem coe_add (m₁ m₂ : outer_measure α) : «expr⇑ » (m₁ + m₂) = m₁ + m₂ :=\n  rfl\n#align coe_add coe_add\n\n",
 "bounded_by_union_of_top_of_nonempty_inter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/-- If `m u = ∞` for any set `u` that has nonempty intersection both with `s` and `t`, then\n`μ (s ∪ t) = μ s + μ t`, where `μ = measure_theory.outer_measure.bounded_by m`.\n\nE.g., if `α` is an (e)metric space and `m u = ∞` on any set of diameter `≥ r`, then this lemma\nimplies that `μ (s ∪ t) = μ s + μ t` on any two sets such that `r ≤ edist x y` for all `x ∈ s`\nand `y ∈ t`.  -/\ntheorem bounded_by_union_of_top_of_nonempty_inter {s t : set α}\n    (h : ∀ u, (s ∩ u).nonempty → (t ∩ u).nonempty → m u = ennreal.top) :\n    bounded_by m (s ∪ t) = bounded_by m s + bounded_by m t :=\n  of_function_union_of_top_of_nonempty_inter fun u hs ht =>\n    top_unique <| (h u hs ht).ge.trans <| le_supᵢ (fun h => m u) (hs.mono <| inter_subset_right s u)\n#align bounded_by_union_of_top_of_nonempty_inter bounded_by_union_of_top_of_nonempty_inter\n\n",
 "bounded_by_le":
 "theorem bounded_by_le (s : set α) : bounded_by m s ≤ m s :=\n  (of_function_le _).trans supᵢ_const_le\n#align bounded_by_le bounded_by_le\n\n",
 "bounded_by_eq_self":
 "@[simp]\ntheorem bounded_by_eq_self (m : outer_measure α) : bounded_by m = m :=\n  ext fun s => bounded_by_eq _ m.empty' (fun t ht => m.mono' ht) m.Union\n#align bounded_by_eq_self bounded_by_eq_self\n\n",
 "bounded_by_eq_of_function":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\ntheorem bounded_by_eq_of_function (m_empty : m ∅ = 0) (s : set α) :\n    bounded_by m s = outer_measure.of_function m m_empty s :=\n  by\n  have :\n    (fun s : set α =>\n        «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (m s)) =\n      m :=\n    by\n    ext1 t\n    cases' t.eq_empty_or_nonempty with h h <;> simp [h, not_nonempty_empty, m_empty]\n  simp [bounded_by, this]\n#align bounded_by_eq_of_function bounded_by_eq_of_function\n\n",
 "bounded_by_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , » -/\ntheorem bounded_by_eq (s : set α) (m_empty : m ∅ = 0) (m_mono : ∀ ⦃t : set α⦄, s ⊆ t → m s ≤ m t)\n    (m_subadd :\n      ∀ s : ℕ → set α,\n        m («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (s i)) ≤\n          «expr∑' , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , »\" (m (s i))) :\n    bounded_by m s = m s := by rw [bounded_by_eq_of_function m_empty, of_function_eq s m_mono m_subadd]\n#align bounded_by_eq bounded_by_eq\n\n",
 "bounded_by_caratheodory":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\ntheorem bounded_by_caratheodory {m : set α → ennreal} {s : set α} (hs : ∀ t, m (t ∩ s) + m (t \\ s) ≤ m t) :\n    (measurable_set_of (bounded_by m).caratheodory) s :=\n  by\n  apply of_function_caratheodory; intro t\n  cases' t.eq_empty_or_nonempty with h h\n  · simp [h, not_nonempty_empty]\n  · convert le_trans _ (hs t)\n    · simp [h]\n    exact add_le_add supᵢ_const_le supᵢ_const_le\n#align bounded_by_caratheodory bounded_by_caratheodory\n\n",
 "bounded_by_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\ntheorem bounded_by_apply (s : set α) :\n    bounded_by m s =\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n        («expr∑' , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , »\"\n          («expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n            (m (t n)))) :=\n  by simp [bounded_by, of_function_apply]\n#align bounded_by_apply bounded_by_apply\n\n",
 "binfi_apply'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/-- The value of the Infimum of a nonempty family of outer measures on a set is not simply\nthe minimum value of a measure on that set: it is the infimum sum of measures of countable set of\nsets that covers that set, where a different measure can be used for each set in the cover. -/\ntheorem binfi_apply' {ι} (I : set ι) (m : ι → outer_measure α) {s : set α} (hs : s.nonempty) :\n    («expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (m i)) s =\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n        («expr∑' , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , »\"\n          («expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n            (m i (t n)))) :=\n  by simp only [← infᵢ_subtype'', infi_apply' _ hs]\n#align binfi_apply' binfi_apply'\n\n",
 "binfi_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/-- The value of the Infimum of a nonempty family of outer measures on a set is not simply\nthe minimum value of a measure on that set: it is the infimum sum of measures of countable set of\nsets that covers that set, where a different measure can be used for each set in the cover. -/\ntheorem binfi_apply {ι} {I : set ι} (hI : I.nonempty) (m : ι → outer_measure α) (s : set α) :\n    («expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (m i)) s =\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n        («expr∑' , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , »\"\n          («expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n            (m i (t n)))) :=\n  by\n  haveI := hI.to_subtype\n  simp only [← infᵢ_subtype'', infᵢ_apply]\n#align binfi_apply binfi_apply\n\n",
 "bUnion_null_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\ntheorem bUnion_null_iff (m : outer_measure α) {s : set β} (hs : s.countable) {t : β → set α} :\n    m («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (t i)) = 0 ↔\n      ∀ i ∈ s, m (t i) = 0 :=\n  by\n  haveI := hs.to_encodable\n  rw [bUnion_eq_Union, Union_null_iff, SetCoe.forall']\n#align bUnion_null_iff bUnion_null_iff\n\n",
 "add_apply":
 "theorem add_apply (m₁ m₂ : outer_measure α) (s : set α) : (m₁ + m₂) s = m₁ s + m₂ s :=\n  rfl\n#align add_apply add_apply\n\n",
 "Union_of_tendsto_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/-- If `s : ι → set α` is a sequence of sets, `S = ⋃ n, s n`, and `m (S \\ s n)` tends to zero along\nsome nontrivial filter (usually `at_top` on `ι = ℕ`), then `m S = ⨆ n, m (s n)`. -/\ntheorem Union_of_tendsto_zero {ι} (m : outer_measure α) {s : ι → set α} (l : filter ι) [ne_bot l]\n    (h0 :\n      tendsto\n        (fun k =>\n          m\n            («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (s n) \\\n              s k))\n        l ((nhds) 0)) :\n    m («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (s n)) =\n      «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (m (s n)) :=\n  by\n  set S := «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (s n)\n  set M := «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (m (s n))\n  have hsS : ∀ {k}, s k ⊆ S := fun k => subset_Union _ _\n  refine' le_antisymm _ (supᵢ_le fun n => m.mono hsS)\n  have A : ∀ k, m S ≤ M + m (S \\ s k) := fun k =>\n    calc\n      m S = m (s k ∪ S \\ s k) := by rw [union_diff_self, union_eq_self_of_subset_left hsS]\n      _ ≤ m (s k) + m (S \\ s k) := m.union _ _\n      _ ≤ M + m (S \\ s k) := add_le_add_right (le_supᵢ _ k) _\n      \n  have B : tendsto (fun k => M + m (S \\ s k)) l ((nhds) (M + 0)) := tendsto_const_nhds.add h0\n  rw [add_zero] at B\n  exact ge_of_tendsto' B A\n#align Union_of_tendsto_zero Union_of_tendsto_zero\n\n",
 "Union_null_iff'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/-- A version of `Union_null_iff` for unions indexed by Props.\nTODO: in the long run it would be better to combine this with `Union_null_iff` by\ngeneralising to `Sort`. -/\n@[simp]\ntheorem Union_null_iff' (m : outer_measure α) {ι : Prop} {s : ι → set α} :\n    m («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (s i)) = 0 ↔\n      ∀ i, m (s i) = 0 :=\n  by by_cases i : ι <;> simp [i]\n#align Union_null_iff' Union_null_iff'\n\n",
 "Union_null_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n@[simp]\ntheorem Union_null_iff [countable β] (m : outer_measure α) {s : β → set α} :\n    m («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (s i)) = 0 ↔\n      ∀ i, m (s i) = 0 :=\n  ⟨fun h i => m.mono_null (subset_unionᵢ _ _) h, m.Union_null⟩\n#align Union_null_iff Union_null_iff\n\n",
 "Union_null":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\ntheorem Union_null [countable β] (m : outer_measure α) {s : β → set α} (h : ∀ i, m (s i) = 0) :\n    m («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (s i)) = 0 := by\n  simpa [h] using m.Union s\n#align Union_null Union_null\n\n",
 "Union_nat_of_monotone_of_tsum_ne_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/-- If `s : ℕ → set α` is a monotone sequence of sets such that `∑' k, m (s (k + 1) \\ s k) ≠ ∞`,\nthen `m (⋃ n, s n) = ⨆ n, m (s n)`. -/\ntheorem Union_nat_of_monotone_of_tsum_ne_top (m : outer_measure α) {s : ℕ → set α} (h_mono : ∀ n, s n ⊆ s (n + 1))\n    (h0 :\n      «expr∑' , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , »\"\n          (m (s (k + 1) \\ s k)) ≠\n        ennreal.top) :\n    m («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (s n)) =\n      «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (m (s n)) :=\n  by\n  refine' m.Union_of_tendsto_zero at_top _\n  refine' tendsto_nhds_bot_mono' (ennreal.tendsto_sum_nat_add _ h0) fun n => _\n  refine' (m.mono _).trans (m.Union _)\n  -- Current goal: `(⋃ k, s k) \\ s n ⊆ ⋃ k, s (k + n + 1) \\ s (k + n)`\n  have h' : monotone s := @monotone_nat_of_le_succ (set α) _ _ h_mono\n  simp only [diff_subset_iff, Union_subset_iff]\n  intro i x hx\n  rcases nat.find_x ⟨i, hx⟩ with ⟨j, hj, hlt⟩\n  clear hx i\n  cases' le_or_lt j n with hjn hnj\n  · exact or.inl (h' hjn hj)\n  have : j - (n + 1) + n + 1 = j := by rw [add_assoc, tsub_add_cancel_of_le hnj.nat_succ_le]\n  refine' or.inr (mem_Union.2 ⟨j - (n + 1), _, hlt _ _⟩)\n  · rwa [this]\n  · rw [← Nat.succ_le_iff, nat.succ_eq_add_one, this]\n#align Union_nat_of_monotone_of_tsum_ne_top Union_nat_of_monotone_of_tsum_ne_top\n\n",
 "Union_finset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\nprotected theorem Union_finset (m : outer_measure α) (s : β → set α) (t : Finset β) :\n    m («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (s i)) ≤\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" t (m (s i)) :=\n  rel_supr_sum m m.empty (· ≤ ·) m.Union_nat s t\n#align Union_finset Union_finset\n\n",
 "Union_eq_of_caratheodory":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr on » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , » -/\nprotected theorem Union_eq_of_caratheodory {s : ℕ → set α} (h : ∀ i, (measurable_set_of caratheodory) (s i))\n    (hd : Pairwise («expr on » Disjoint s)) :\n    m («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (s i)) =\n      «expr∑' , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , »\" (m (s i)) :=\n  f_Union h hd\n#align Union_eq_of_caratheodory Union_eq_of_caratheodory\n\n",
 "Union":
 "/- warning: Union clashes with has_union -> Union\nCase conversion may be inaccurate. Consider using '#align Union Unionₓ'. -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , » -/\n#print Union /-\nprotected theorem Union (m : outer_measure α) {β} [countable β] (s : β → set α) :\n    m («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (s i)) ≤\n      «expr∑' , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , »\" (m (s i)) :=\n  rel_supr_tsum m m.empty (· ≤ ·) m.Union_nat s\n#align Union Union\n-/\n\n",
 "Inf_gen_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\ntheorem Inf_gen_def (m : set (outer_measure α)) (t : set α) :\n    Inf_gen m t =\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (μ t) :=\n  rfl\n#align Inf_gen_def Inf_gen_def\n\n",
 "Inf_eq_bounded_by_Inf_gen":
 "theorem Inf_eq_bounded_by_Inf_gen (m : set (outer_measure α)) : infₛ m = outer_measure.bounded_by (Inf_gen m) :=\n  by\n  refine' le_antisymm _ _\n  · refine' le_bounded_by.2 fun s => le_infᵢ₂ fun μ hμ => _\n    exact (show Inf m ≤ μ from infₛ_le hμ) s\n  · refine' le_infₛ _\n    intro μ hμ t\n    refine' le_trans (bounded_by_le t) (infᵢ₂_le μ hμ)\n#align Inf_eq_bounded_by_Inf_gen Inf_eq_bounded_by_Inf_gen\n\n",
 "Inf_apply'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/-- The value of the Infimum of a set of outer measures on a nonempty set is not simply\nthe minimum value of a measure on that set: it is the infimum sum of measures of countable set of\nsets that covers that set, where a different measure can be used for each set in the cover. -/\ntheorem Inf_apply' {m : set (outer_measure α)} {s : set α} (h : s.nonempty) :\n    infₛ m s =\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n        («expr∑' , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , »\"\n          («expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n            (μ (t n)))) :=\n  m.eq_empty_or_nonempty.elim (fun hm => by simp [hm, h]) Inf_apply\n#align Inf_apply' Inf_apply'\n\n"}