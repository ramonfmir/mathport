{"sum_measure":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n@[measurability]\ntheorem sum_measure [Countable ι] {μ : ι → measure α} (h : ∀ i, AEMeasurable f (μ i)) : AEMeasurable f (Sum μ) :=\n  by\n  nontriviality β\n  inhabit β\n  set s : ι → Set α := fun i => to_measurable (μ i) { x | f x ≠ (h i).mk f x }\n  have hsμ : ∀ i, μ i (s i) = 0 := by\n    intro i\n    rw [measure_to_measurable]\n    exact (h i).ae_eq_mk\n  have hsm :\n    MeasurableSet\n      («expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (s i)) :=\n    MeasurableSet.interᵢ fun i => measurable_set_to_measurable _ _\n  have hs : ∀ i x, x ∉ s i → f x = (h i).mk f x := by\n    intro i x hx\n    contrapose! hx\n    exact subset_to_measurable _ _ hx\n  set g : α → β :=\n    («expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (s i)).piecewise\n      (const α default) f\n  refine' ⟨g, measurable_of_restrict_of_restrict_compl hsm _ _, ae_sum_iff.mpr fun i => _⟩\n  · rw [restrict_piecewise]\n    simp only [Set.restrict, const]\n    exact measurable_const\n  · rw [restrict_piecewise_compl, compl_Inter]\n    intro t ht\n    refine'\n      ⟨«expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n          («expr ⁻¹' » ((h i).mk f) t ∩ «expr ᶜ» (s i)),\n        MeasurableSet.unionᵢ fun i => (measurable_mk _ ht).inter (measurable_set_to_measurable _ _).compl, _⟩\n    ext ⟨x, hx⟩\n    simp only [mem_preimage, mem_Union, Subtype.coe_mk, Set.restrict, mem_inter_iff, mem_compl_iff] at hx⊢\n    constructor\n    · rintro ⟨i, hxt, hxs⟩\n      rwa [hs _ _ hxs]\n    · rcases hx with ⟨i, hi⟩\n      rw [hs _ _ hi]\n      exact fun h => ⟨i, h, hi⟩\n  · refine' measure_mono_null (fun x (hx : f x ≠ g x) => _) (hsμ i)\n    contrapose! hx\n    refine' (piecewise_eq_of_not_mem _ _ _ _).symm\n    exact fun h => hx (mem_Inter.1 h i)\n#align sum_measure sum_measure\n\n",
 "subtype_mk":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\ntheorem subtype_mk (h : AEMeasurable f μ) {s : Set β} {hfs : ∀ x, f x ∈ s} : AEMeasurable (codRestrict f s hfs) μ :=\n  by\n  nontriviality α; inhabit α\n  obtain ⟨g, g_meas, hg, fg⟩ : ∃ g : α → β, Measurable g ∧ range g ⊆ s ∧ «expr =ᵐ[ ] » f μ g :=\n    h.exists_ae_eq_range_subset (eventually_of_forall hfs) ⟨_, hfs default⟩\n  refine' ⟨cod_restrict g s fun x => hg (mem_range_self _), Measurable.subtype_mk g_meas, _⟩\n  filter_upwards [fg]with x hx\n  simpa [Subtype.ext_iff]\n#align subtype_mk subtype_mk\n\n",
 "smul_measure":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[measurability]\ntheorem smul_measure [Monoid R] [DistribMulAction R (ennreal)] [IsScalarTower R (ennreal) (ennreal)]\n    (h : AEMeasurable f μ) (c : R) : AEMeasurable f («expr • » c μ) :=\n  ⟨h.mk f, h.measurable_mk, ae_smul_measure h.ae_eq_mk c⟩\n#align smul_measure smul_measure\n\n",
 "restrict_map_of_aemeasurable":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n#print MeasureTheory.Measure.restrict_map_of_aemeasurable /-\ntheorem MeasureTheory.Measure.restrict_map_of_aemeasurable {f : α → δ} (hf : AEMeasurable f μ) {s : Set δ}\n    (hs : MeasurableSet s) : (μ.map f).restrict s = (μ.restrict <| «expr ⁻¹' » f s).map f :=\n  calc\n    (μ.map f).restrict s = (μ.map (hf.mk f)).restrict s :=\n      by\n      congr 1\n      apply measure.map_congr hf.ae_eq_mk\n    _ = (μ.restrict <| «expr ⁻¹' » (hf.mk f) s).map (hf.mk f) := (Measure.restrict_map hf.measurable_mk hs)\n    _ = (μ.restrict <| «expr ⁻¹' » (hf.mk f) s).map f := (Measure.map_congr (ae_restrict_of_ae hf.ae_eq_mk.symm))\n    _ = (μ.restrict <| «expr ⁻¹' » f s).map f := by\n      apply congr_arg\n      ext1 t ht\n      simp only [ht, measure.restrict_apply]\n      apply measure_congr\n      apply (eventually_eq.refl _ _).inter (hf.ae_eq_mk.symm.preimage s)\n    \n#align measure_theory.measure.restrict_map_of_ae_measurable MeasureTheory.Measure.restrict_map_of_aemeasurable\n-/\n\n",
 "restrict":
 "#print AEMeasurable.restrict /-\ntheorem AEMeasurable.restrict (hfm : AEMeasurable f μ) {s} : AEMeasurable f (μ.restrict s) :=\n  ⟨AEMeasurable.mk f hfm, hfm.measurable_mk, ae_restrict_of_ae hfm.ae_eq_mk⟩\n#align ae_measurable.restrict AEMeasurable.restrict\n-/\n\n",
 "prod_mk":
 "@[measurability]\ntheorem prod_mk {f : α → β} {g : α → γ} (hf : AEMeasurable f μ) (hg : AEMeasurable g μ) :\n    AEMeasurable (fun x => (f x, g x)) μ :=\n  ⟨fun a => (hf.mk f a, hg.mk g a), hf.measurable_mk.prod_mk hg.measurable_mk,\n    EventuallyEq.prod_mk hf.ae_eq_mk hg.ae_eq_mk⟩\n#align prod_mk prod_mk\n\n",
 "null_measurable":
 "protected theorem null_measurable (h : AEMeasurable f μ) : NullMeasurable f μ :=\n  let ⟨g, hgm, hg⟩ := h\n  hgm.null_measurable.congr hg.symm\n#align null_measurable null_measurable\n\n",
 "mono_set":
 "theorem mono_set {s t} (h : s ⊆ t) (ht : AEMeasurable f (μ.restrict t)) : AEMeasurable f (μ.restrict s) :=\n  ht.mono_measure (restrict_mono h le_rfl)\n#align mono_set mono_set\n\n",
 "mono_measure":
 "theorem mono_measure (h : AEMeasurable f μ) (h' : ν ≤ μ) : AEMeasurable f ν :=\n  ⟨h.mk f, h.measurable_mk, Eventually.filter_mono (ae_mono h') h.ae_eq_mk⟩\n#align mono_measure mono_measure\n\n",
 "mono'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure.absolutely_continuous -/\nprotected theorem mono' (h : AEMeasurable f μ) (h' : measure.absolutely_continuous ν μ) : AEMeasurable f ν :=\n  ⟨h.mk f, h.measurable_mk, h' h.ae_eq_mk⟩\n#align mono' mono'\n\n",
 "map_mono_of_aemeasurable":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n#print MeasureTheory.Measure.map_mono_of_aemeasurable /-\ntheorem MeasureTheory.Measure.map_mono_of_aemeasurable {f : α → δ} (h : μ ≤ ν) (hf : AEMeasurable f ν) :\n    μ.map f ≤ ν.map f := fun s hs => by simpa [hf, hs, hf.mono_measure h] using measure.le_iff'.1 h («expr ⁻¹' » f s)\n#align measure_theory.measure.map_mono_of_ae_measurable MeasureTheory.Measure.map_mono_of_aemeasurable\n-/\n\n",
 "map_map_of_ae_measurable":
 "theorem map_map_of_ae_measurable {g : β → γ} {f : α → β} (hg : AEMeasurable g (Measure.map f μ))\n    (hf : AEMeasurable f μ) : (μ.map f).map g = μ.map (g ∘ f) :=\n  by\n  ext1 s hs\n  let g' := hg.mk g\n  have A : map g (map f μ) = map g' (map f μ) :=\n    by\n    apply MeasureTheory.Measure.map_congr\n    exact hg.ae_eq_mk\n  have B : map (g ∘ f) μ = map (g' ∘ f) μ :=\n    by\n    apply MeasureTheory.Measure.map_congr\n    exact ae_of_ae_map hf hg.ae_eq_mk\n  simp only [A, B, hs, hg.measurable_mk.ae_measurable.comp_ae_measurable hf, hg.measurable_mk, hg.measurable_mk hs, hf,\n    map_apply, map_apply_of_ae_measurable]\n  rfl\n#align map_map_of_ae_measurable map_map_of_ae_measurable\n\n",
 "indicator":
 "#print AEMeasurable.indicator /-\n@[measurability]\ntheorem AEMeasurable.indicator (hfm : AEMeasurable f μ) {s} (hs : MeasurableSet s) : AEMeasurable (s.indicator f) μ :=\n  (aemeasurable_indicator_iff hs).mpr hfm.restrict\n#align ae_measurable.indicator AEMeasurable.indicator\n-/\n\n",
 "exists_measurable_nonneg":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\ntheorem exists_measurable_nonneg {β} [preorder β] [Zero β] {mβ : MeasurableSpace β} {f : α → β} (hf : AEMeasurable f μ)\n    (f_nn :\n      «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\" μ\n        (0 ≤ f t)) :\n    ∃ g, Measurable g ∧ 0 ≤ g ∧ «expr =ᵐ[ ] » f μ g :=\n  by\n  obtain ⟨G, hG_meas, hG_mem, hG_ae_eq⟩ := hf.exists_ae_eq_range_subset f_nn ⟨0, le_rfl⟩\n  exact ⟨G, hG_meas, fun x => hG_mem (mem_range_self x), hG_ae_eq⟩\n#align exists_measurable_nonneg exists_measurable_nonneg\n\n",
 "exists_ae_eq_range_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\ntheorem exists_ae_eq_range_subset (H : AEMeasurable f μ) {t : Set β}\n    (ht :\n      «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\" μ (f x ∈ t))\n    (h₀ : t.nonempty) : ∃ g, Measurable g ∧ range g ⊆ t ∧ «expr =ᵐ[ ] » f μ g :=\n  by\n  let s : Set α := to_measurable μ («expr ᶜ» { x | f x = H.mk f x ∧ f x ∈ t })\n  let g : α → β := piecewise s (fun x => h₀.some) (H.mk f)\n  refine' ⟨g, _, _, _⟩\n  · exact Measurable.piecewise (measurable_set_to_measurable _ _) measurable_const H.measurable_mk\n  · rintro _ ⟨x, rfl⟩\n    by_cases hx : x ∈ s\n    · simpa [g, hx] using h₀.some_mem\n    · simp only [g, hx, piecewise_eq_of_not_mem, not_false_iff]\n      contrapose! hx\n      apply subset_to_measurable\n      simp (config := { contextual := true }) only [hx, mem_compl_iff, mem_set_of_eq, not_and, not_false_iff,\n        imp_true_iff]\n  · have A : μ (to_measurable μ («expr ᶜ» { x | f x = H.mk f x ∧ f x ∈ t })) = 0 :=\n      by\n      rw [measure_to_measurable, ← compl_mem_ae_iff, compl_compl]\n      exact H.ae_eq_mk.and ht\n    filter_upwards [compl_mem_ae_iff.2 A]with x hx\n    rw [mem_compl_iff] at hx\n    simp only [g, hx, piecewise_eq_of_not_mem, not_false_iff]\n    contrapose! hx\n    apply subset_to_measurable\n    simp only [hx, mem_compl_iff, mem_set_of_eq, false_and_iff, not_false_iff]\n#align exists_ae_eq_range_subset exists_ae_eq_range_subset\n\n",
 "comp_quasi_measure_preserving":
 "theorem comp_quasi_measure_preserving {ν : measure δ} {f : α → δ} {g : δ → β} (hg : AEMeasurable g ν)\n    (hf : QuasiMeasurePreserving f μ ν) : AEMeasurable (g ∘ f) μ :=\n  (hg.mono' hf.absolutely_continuous).comp_measurable hf.measurable\n#align comp_quasi_measure_preserving comp_quasi_measure_preserving\n\n",
 "comp_measurable":
 "theorem comp_measurable {f : α → δ} {g : δ → β} (hg : AEMeasurable g (μ.map f)) (hf : Measurable f) :\n    AEMeasurable (g ∘ f) μ :=\n  hg.comp_ae_measurable hf.ae_measurable\n#align comp_measurable comp_measurable\n\n",
 "comp_ae_measurable":
 "theorem comp_ae_measurable {f : α → δ} {g : δ → β} (hg : AEMeasurable g (μ.map f)) (hf : AEMeasurable f μ) :\n    AEMeasurable (g ∘ f) μ :=\n  ⟨hg.mk g ∘ hf.mk f, hg.measurable_mk.comp hf.measurable_mk,\n    (ae_eq_comp hf hg.ae_eq_mk).trans (hf.ae_eq_mk.fun_comp (mk g hg))⟩\n#align comp_ae_measurable comp_ae_measurable\n\n",
 "aemeasurable_zero_measure":
 "#print aemeasurable_zero_measure /-\n@[simp, measurability]\ntheorem aemeasurable_zero_measure : AEMeasurable f (0 : measure α) :=\n  by\n  nontriviality α; inhabit α\n  exact ⟨fun x => f default, measurable_const, rfl⟩\n#align ae_measurable_zero_measure aemeasurable_zero_measure\n-/\n\n",
 "aemeasurable_uIoc_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprΙ -/\n#print aemeasurable_uIoc_iff /-\ntheorem aemeasurable_uIoc_iff [linear_order α] {f : α → β} {a b : α} :\n    (AEMeasurable f <| μ.restrict <| (exprΙ) a b) ↔\n      (AEMeasurable f <| μ.restrict <| Ioc a b) ∧ (AEMeasurable f <| μ.restrict <| Ioc b a) :=\n  by rw [uIoc_eq_union, aemeasurable_union_iff]\n#align ae_measurable_uIoc_iff aemeasurable_uIoc_iff\n-/\n\n",
 "aemeasurable_smul_measure_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print aemeasurable_smul_measure_iff /-\n@[simp]\ntheorem aemeasurable_smul_measure_iff {c : ennreal} (hc : c ≠ 0) : AEMeasurable f («expr • » c μ) ↔ AEMeasurable f μ :=\n  ⟨fun h => ⟨h.mk f, h.measurable_mk, (ae_smul_measure_iff hc).1 h.ae_eq_mk⟩, fun h =>\n    ⟨h.mk f, h.measurable_mk, (ae_smul_measure_iff hc).2 h.ae_eq_mk⟩⟩\n#align ae_measurable_smul_measure_iff aemeasurable_smul_measure_iff\n-/\n\n",
 "aemeasurable_restrict_of_measurable_subtype":
 "#print aemeasurable_restrict_of_measurable_subtype /-\ntheorem aemeasurable_restrict_of_measurable_subtype {s : Set α} (hs : MeasurableSet s)\n    (hf : Measurable fun x : s => f x) : AEMeasurable f (μ.restrict s) :=\n  (aemeasurable_restrict_iff_comap_subtype hs).2 hf.ae_measurable\n#align ae_measurable_restrict_of_measurable_subtype aemeasurable_restrict_of_measurable_subtype\n-/\n\n",
 "aemeasurable_restrict_iff_comap_subtype":
 "#print aemeasurable_restrict_iff_comap_subtype /-\ntheorem aemeasurable_restrict_iff_comap_subtype {s : Set α} (hs : MeasurableSet s) {μ : measure α} {f : α → β} :\n    AEMeasurable f (μ.restrict s) ↔ AEMeasurable (f ∘ coe : s → β) (comap coe μ) := by\n  rw [← map_comap_subtype_coe hs, (MeasurableEmbedding.subtype_coe hs).ae_measurable_map_iff]\n#align ae_measurable_restrict_iff_comap_subtype aemeasurable_restrict_iff_comap_subtype\n-/\n\n",
 "aemeasurable_one":
 "#print aemeasurable_one /-\n@[simp, to_additive]\ntheorem aemeasurable_one [One β] : AEMeasurable (fun a : α => (1 : β)) μ :=\n  measurable_one.ae_measurable\n#align ae_measurable_one aemeasurable_one\n#align ae_measurable_zero aemeasurable_zero\n-/\n\n",
 "aemeasurable_of_subsingleton_codomain":
 "#print aemeasurable_of_subsingleton_codomain /-\n@[nontriviality, measurability]\ntheorem aemeasurable_of_subsingleton_codomain [subsingleton β] : AEMeasurable f μ :=\n  (measurable_of_subsingleton_codomain f).ae_measurable\n#align ae_measurable_of_subsingleton_codomain aemeasurable_of_subsingleton_codomain\n-/\n\n",
 "aemeasurable_of_aemeasurable_trim":
 "#print aemeasurable_of_aemeasurable_trim /-\ntheorem aemeasurable_of_aemeasurable_trim {α} {m m0 : MeasurableSpace α} {μ : measure α} (hm : m ≤ m0) {f : α → β}\n    (hf : AEMeasurable f (μ.trim hm)) : AEMeasurable f μ :=\n  ⟨hf.mk f, Measurable.mono hf.measurable_mk hm le_rfl, ae_eq_of_ae_eq_trim hf.ae_eq_mk⟩\n#align ae_measurable_of_ae_measurable_trim aemeasurable_of_aemeasurable_trim\n-/\n\n",
 "aemeasurable_map_iff":
 "#print MeasurableEmbedding.aemeasurable_map_iff /-\ntheorem MeasurableEmbedding.aemeasurable_map_iff {g : β → γ} (hf : MeasurableEmbedding f) :\n    AEMeasurable g (μ.map f) ↔ AEMeasurable (g ∘ f) μ :=\n  by\n  refine' ⟨fun H => H.comp_measurable hf.measurable, _⟩\n  rintro ⟨g₁, hgm₁, heq⟩\n  rcases hf.exists_measurable_extend hgm₁ fun x => ⟨g x⟩ with ⟨g₂, hgm₂, rfl⟩\n  exact ⟨g₂, hgm₂, hf.ae_map_iff.2 HEq⟩\n#align measurable_embedding.ae_measurable_map_iff MeasurableEmbedding.aemeasurable_map_iff\n-/\n\n",
 "aemeasurable_map_equiv_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ᵐ » -/\n#print aemeasurable_map_equiv_iff /-\ntheorem aemeasurable_map_equiv_iff (e : «expr ≃ᵐ » α β) {f : β → γ} :\n    AEMeasurable f (μ.map e) ↔ AEMeasurable (f ∘ e) μ :=\n  e.measurable_embedding.ae_measurable_map_iff\n#align ae_measurable_map_equiv_iff aemeasurable_map_equiv_iff\n-/\n\n",
 "aemeasurable_indicator_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n#print aemeasurable_indicator_iff /-\ntheorem aemeasurable_indicator_iff {s} (hs : MeasurableSet s) :\n    AEMeasurable (indicator s f) μ ↔ AEMeasurable f (μ.restrict s) :=\n  by\n  constructor\n  · intro h\n    exact (h.mono_measure measure.restrict_le_self).congr (indicator_ae_eq_restrict hs)\n  · intro h\n    refine' ⟨indicator s (h.mk f), h.measurable_mk.indicator hs, _⟩\n    have A : «expr =ᵐ[ ] » (s.indicator f) (μ.restrict s) (s.indicator (AEMeasurable.mk f h)) :=\n      (indicator_ae_eq_restrict hs).trans (h.ae_eq_mk.trans <| (indicator_ae_eq_restrict hs).symm)\n    have B : «expr =ᵐ[ ] » (s.indicator f) (μ.restrict («expr ᶜ» s)) (s.indicator (AEMeasurable.mk f h)) :=\n      (indicator_ae_eq_restrict_compl hs).trans (indicator_ae_eq_restrict_compl hs).symm\n    exact ae_of_ae_restrict_of_ae_restrict_compl _ A B\n#align ae_measurable_indicator_iff aemeasurable_indicator_iff\n-/\n\n",
 "aemeasurable_iff_measurable":
 "#print aemeasurable_iff_measurable /-\ntheorem aemeasurable_iff_measurable [μ.is_complete] : AEMeasurable f μ ↔ Measurable f :=\n  ⟨fun h => h.null_measurable.measurable_of_complete, fun h => h.ae_measurable⟩\n#align ae_measurable_iff_measurable aemeasurable_iff_measurable\n-/\n\n",
 "aemeasurable_const'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\n#print aemeasurable_const' /-\ntheorem aemeasurable_const'\n    (h :\n      «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\" μ\n        (f x = f y)) :\n    AEMeasurable f μ := by\n  rcases eq_or_ne μ 0 with (rfl | hμ)\n  · exact aemeasurable_zero_measure\n  · haveI := ae_ne_bot.2 hμ\n    rcases h.exists with ⟨x, hx⟩\n    exact ⟨const α (f x), measurable_const, eventually_eq.symm hx⟩\n#align ae_measurable_const' aemeasurable_const'\n-/\n\n",
 "aemeasurable_comp_iff":
 "#print MeasurableEmbedding.aemeasurable_comp_iff /-\ntheorem MeasurableEmbedding.aemeasurable_comp_iff {g : β → γ} (hg : MeasurableEmbedding g) {μ : measure α} :\n    AEMeasurable (g ∘ f) μ ↔ AEMeasurable f μ :=\n  by\n  refine' ⟨fun H => _, hg.measurable.comp_ae_measurable⟩\n  suffices AEMeasurable ((range_splitting g ∘ range_factorization g) ∘ f) μ by\n    rwa [(right_inverse_range_splitting hg.injective).comp_eq_id] at this\n  exact hg.measurable_range_splitting.comp_ae_measurable H.subtype_mk\n#align measurable_embedding.ae_measurable_comp_iff MeasurableEmbedding.aemeasurable_comp_iff\n-/\n\n",
 "aemeasurable_Ioi_of_forall_Ioc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n#print aemeasurable_Ioi_of_forall_Ioc /-\ntheorem aemeasurable_Ioi_of_forall_Ioc {β} {mβ : MeasurableSpace β} [linear_order α]\n    [(atTop : Filter α).is_countably_generated] {x : α} {g : α → β}\n    (g_meas : ∀ t > x, AEMeasurable g (μ.restrict (Ioc x t))) : AEMeasurable g (μ.restrict (Ioi x)) :=\n  by\n  haveI : Nonempty α := ⟨x⟩\n  obtain ⟨u, hu_tendsto⟩ := exists_seq_tendsto (at_top : Filter α)\n  have Ioi_eq_Union :\n    Ioi x =\n      «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (Ioc x (u n)) :=\n    by\n    rw [Union_Ioc_eq_Ioi_self_iff.mpr _]\n    exact fun y _ => (hu_tendsto.eventually (eventually_ge_at_top y)).exists\n  rw [Ioi_eq_Union, aemeasurable_unionᵢ_iff]\n  intro n\n  cases lt_or_le x (u n)\n  · exact g_meas (u n) h\n  · rw [Ioc_eq_empty (not_lt.mpr h), measure.restrict_empty]\n    exact aemeasurable_zero_measure\n#align ae_measurable_Ioi_of_forall_Ioc aemeasurable_Ioi_of_forall_Ioc\n-/\n\n",
 "aemeasurable":
 "#print Subsingleton.aemeasurable /-\n/-\nCopyright (c) 2021 Sébastien Gouëzel. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Sébastien Gouëzel\n-/\n@[nontriviality, measurability]\ntheorem Subsingleton.aemeasurable [subsingleton α] : AEMeasurable f μ :=\n  Subsingleton.measurable.ae_measurable\n#align subsingleton.ae_measurable Subsingleton.aemeasurable\n-/\n\n",
 "ae_mem_imp_eq_mk":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\ntheorem ae_mem_imp_eq_mk {s} (h : AEMeasurable f (μ.restrict s)) :\n    «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\" μ\n      (x ∈ s → f x = h.mk f x) :=\n  ae_imp_of_ae_restrict h.ae_eq_mk\n#align ae_mem_imp_eq_mk ae_mem_imp_eq_mk\n\n",
 "ae_measurable_union_iff":
 "#print aemeasurable_union_iff /-\n@[simp]\ntheorem aemeasurable_union_iff {s t : Set α} :\n    AEMeasurable f (μ.restrict (s ∪ t)) ↔ AEMeasurable f (μ.restrict s) ∧ AEMeasurable f (μ.restrict t) := by\n  simp only [union_eq_Union, aemeasurable_unionᵢ_iff, Bool.forall_bool, cond, and_comm]\n#align ae_measurable_union_iff aemeasurable_union_iff\n-/\n\n",
 "ae_measurable_sum_measure_iff":
 "#print aemeasurable_sum_measure_iff /-\n@[simp]\ntheorem aemeasurable_sum_measure_iff [Countable ι] {μ : ι → measure α} :\n    AEMeasurable f (Sum μ) ↔ ∀ i, AEMeasurable f (μ i) :=\n  ⟨fun h i => h.mono_measure (le_sum _ _), sum_measure⟩\n#align ae_measurable_sum_measure_iff aemeasurable_sum_measure_iff\n-/\n\n",
 "ae_measurable_add_measure_iff":
 "#print aemeasurable_add_measure_iff /-\n@[simp]\ntheorem aemeasurable_add_measure_iff : AEMeasurable f (μ + ν) ↔ AEMeasurable f μ ∧ AEMeasurable f ν :=\n  by\n  rw [← sum_cond, aemeasurable_sum_measure_iff, Bool.forall_bool, and_comm]\n  rfl\n#align ae_measurable_add_measure_iff aemeasurable_add_measure_iff\n-/\n\n",
 "ae_measurable_Union_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n#print aemeasurable_unionᵢ_iff /-\n@[simp]\ntheorem aemeasurable_unionᵢ_iff [Countable ι] {s : ι → Set α} :\n    AEMeasurable f\n        (μ.restrict\n          («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (s i))) ↔\n      ∀ i, AEMeasurable f (μ.restrict (s i)) :=\n  ⟨fun h i => h.mono_measure <| restrict_mono (subset_unionᵢ _ _) le_rfl, AEMeasurable.unionᵢ⟩\n#align ae_measurable_Union_iff aemeasurable_unionᵢ_iff\n-/\n\n",
 "ae_inf_principal_eq_mk":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\ntheorem ae_inf_principal_eq_mk {s} (h : AEMeasurable f (μ.restrict s)) :\n    «expr =ᶠ[ ] » f («expr ⊓ » μ.ae ((filter.principal) s)) (h.mk f) :=\n  le_ae_restrict h.ae_eq_mk\n#align ae_inf_principal_eq_mk ae_inf_principal_eq_mk\n\n",
 "add_measure":
 "@[measurability]\ntheorem add_measure {f : α → β} (hμ : AEMeasurable f μ) (hν : AEMeasurable f ν) : AEMeasurable f (μ + ν) :=\n  aemeasurable_add_measure_iff.2 ⟨hμ, hν⟩\n#align add_measure add_measure\n\n",
 "Union":
 "/- warning: Union clashes with has_union -> Union\nCase conversion may be inaccurate. Consider using '#align Union Unionₓ'. -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n#print Union /-\n@[measurability]\nprotected theorem Union [Countable ι] {s : ι → Set α} (h : ∀ i, AEMeasurable f (μ.restrict (s i))) :\n    AEMeasurable f\n      (μ.restrict\n        («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (s i))) :=\n  (sum_measure h).mono_measure <| restrict_unionᵢ_le\n#align Union Union\n-/\n\n"}