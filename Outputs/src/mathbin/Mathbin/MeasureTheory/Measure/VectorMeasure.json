{"zero_trim":
 "@[simp]\ntheorem zero_trim (hle : m ≤ n) : (0 : vector_measure α M).trim hle = 0 :=\n  by\n  ext1 i hi\n  exact if_pos hi\n#align zero_trim zero_trim\n\n",
 "zero_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `vector_measure.mutually_singular -/\ntheorem zero_right : vector_measure.mutually_singular v (0 : vector_measure α N) :=\n  ⟨∅, measurable_set.empty, fun t ht => (subset_empty_iff.1 ht).symm ▸ v.empty, fun _ _ => zero_apply _⟩\n#align zero_right zero_right\n\n",
 "zero_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `vector_measure.mutually_singular -/\ntheorem zero_left : vector_measure.mutually_singular (0 : vector_measure α M) w :=\n  zero_right.symm\n#align zero_left zero_left\n\n",
 "zero_le_to_signed_measure":
 "theorem zero_le_to_signed_measure : 0 ≤ μ.to_signed_measure :=\n  by\n  rw [← le_restrict_univ_iff_le]\n  refine' restrict_le_restrict_of_subset_le _ _ fun j hj₁ _ => _\n  simp only [measure.to_signed_measure_apply_measurable hj₁, coe_zero, pi.zero_apply, ennreal.to_real_nonneg,\n    vector_measure.coe_zero]\n#align zero_le_to_signed_measure zero_le_to_signed_measure\n\n",
 "zero_le_restrict_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `vector_measure.restrict -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `vector_measure.restrict -/\ntheorem zero_le_restrict_subset (hi₁ : measurable_set i) (hij : j ⊆ i) (hi₂ : vector_measure.restrict 0 i v) :\n    vector_measure.restrict 0 j v :=\n  restrict_le_restrict_of_subset_le _ _ fun k hk₁ hk₂ =>\n    (restrict_le_restrict_iff _ _ hi₁).1 hi₂ hk₁ (Set.Subset.trans hk₂ hij)\n#align zero_le_restrict_subset zero_le_restrict_subset\n\n",
 "zero_le_restrict_not_measurable":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `vector_measure.restrict -/\ntheorem zero_le_restrict_not_measurable (hi : ¬measurable_set i) : vector_measure.restrict 0 i v :=\n  by\n  rw [restrict_zero, restrict_not_measurable _ hi]\n  exact le_rfl\n#align zero_le_restrict_not_measurable zero_le_restrict_not_measurable\n\n",
 "zero_apply":
 "theorem zero_apply (i : set α) : (0 : vector_measure α M) i = 0 :=\n  rfl\n#align zero_apply zero_apply\n\n",
 "zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `vector_measure.absolutely_continuous -/\ntheorem zero (v : vector_measure α N) : vector_measure.absolutely_continuous (0 : vector_measure α M) v := fun s _ =>\n  vector_measure.zero_apply s\n#align zero zero\n\n",
 "trim_measurable_set_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\ntheorem trim_measurable_set_eq (hle : m ≤ n) {i : set α} (hi : (measurable_set_of m) i) : v.trim hle i = v i :=\n  if_pos hi\n#align trim_measurable_set_eq trim_measurable_set_eq\n\n",
 "trim_eq_self":
 "theorem trim_eq_self : v.trim le_rfl = v := by\n  ext1 i hi\n  exact if_pos hi\n#align trim_eq_self trim_eq_self\n\n",
 "trans":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `vector_measure.absolutely_continuous -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `vector_measure.absolutely_continuous -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `vector_measure.absolutely_continuous -/\n#print trans /-\n@[trans]\ntheorem trans {u : vector_measure α L} {v : vector_measure α M} {w : vector_measure α N}\n    (huv : vector_measure.absolutely_continuous u v) (hvw : vector_measure.absolutely_continuous v w) :\n    vector_measure.absolutely_continuous u w := fun _ hs => huv <| hvw hs\n#align trans trans\n-/\n\n",
 "to_signed_measure_zero":
 "@[simp]\ntheorem to_signed_measure_zero : (0 : measure α).to_signed_measure = 0 :=\n  by\n  ext (i hi)\n  simp\n#align to_signed_measure_zero to_signed_measure_zero\n\n",
 "to_signed_measure_to_measure_of_zero_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\ntheorem to_signed_measure_to_measure_of_zero_le :\n    μ.to_signed_measure.to_measure_of_zero_le univ measurable_set.univ\n        ((le_restrict_univ_iff_le _ _).2 (zero_le_to_signed_measure μ)) =\n      μ :=\n  by\n  refine' measure.ext fun i hi => _\n  lift μ i to nnreal using (measure_lt_top _ _).ne with m hm\n  simp [signed_measure.to_measure_of_zero_le_apply _ _ _ hi, measure.to_signed_measure_apply_measurable hi, ← hm]\n#align to_signed_measure_to_measure_of_zero_le to_signed_measure_to_measure_of_zero_le\n\n",
 "to_signed_measure_sub_apply":
 "theorem to_signed_measure_sub_apply {μ ν : measure α} [is_finite_measure μ] [is_finite_measure ν] {i : set α}\n    (hi : measurable_set i) : (μ.to_signed_measure - ν.to_signed_measure) i = (μ i).to_real - (ν i).to_real := by\n  rw [vector_measure.sub_apply, to_signed_measure_apply_measurable hi, measure.to_signed_measure_apply_measurable hi,\n    sub_eq_add_neg]\n#align to_signed_measure_sub_apply to_signed_measure_sub_apply\n\n",
 "to_signed_measure_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem to_signed_measure_smul (μ : measure α) [is_finite_measure μ] (r : nnreal) :\n    («expr • » r μ).to_signed_measure = «expr • » r μ.to_signed_measure :=\n  by\n  ext (i hi)\n  rw [to_signed_measure_apply_measurable hi, vector_measure.smul_apply, to_signed_measure_apply_measurable hi, coe_smul,\n    pi.smul_apply, ennreal.to_real_smul]\n#align to_signed_measure_smul to_signed_measure_smul\n\n",
 "to_signed_measure_eq_to_signed_measure_iff":
 "theorem to_signed_measure_eq_to_signed_measure_iff {μ ν : measure α} [is_finite_measure μ] [is_finite_measure ν] :\n    μ.to_signed_measure = ν.to_signed_measure ↔ μ = ν :=\n  by\n  refine' ⟨fun h => _, fun h => _⟩\n  · ext1 i hi\n    have : μ.to_signed_measure i = ν.to_signed_measure i := by rw [h]\n    rwa [to_signed_measure_apply_measurable hi, to_signed_measure_apply_measurable hi, ennreal.to_real_eq_to_real] at\n        this <;>\n      · exact measure_ne_top _ _\n  · congr\n    assumption\n#align to_signed_measure_eq_to_signed_measure_iff to_signed_measure_eq_to_signed_measure_iff\n\n",
 "to_signed_measure_congr":
 "-- Without this lemma, `singular_part_neg` in `measure_theory.decomposition.lebesgue` is\n-- extremely slow\ntheorem to_signed_measure_congr {μ ν : measure α} [is_finite_measure μ] [is_finite_measure ν] (h : μ = ν) :\n    μ.to_signed_measure = ν.to_signed_measure := by\n  congr\n  exact h\n#align to_signed_measure_congr to_signed_measure_congr\n\n",
 "to_signed_measure_apply_measurable":
 "theorem to_signed_measure_apply_measurable {μ : measure α} [is_finite_measure μ] {i : set α} (hi : measurable_set i) :\n    μ.to_signed_measure i = (μ i).to_real :=\n  if_pos hi\n#align to_signed_measure_apply_measurable to_signed_measure_apply_measurable\n\n",
 "to_signed_measure_add":
 "@[simp]\ntheorem to_signed_measure_add (μ ν : measure α) [is_finite_measure μ] [is_finite_measure ν] :\n    (μ + ν).to_signed_measure = μ.to_signed_measure + ν.to_signed_measure :=\n  by\n  ext (i hi)\n  rw [to_signed_measure_apply_measurable hi, add_apply,\n    ennreal.to_real_add (ne_of_lt (measure_lt_top _ _)) (ne_of_lt (measure_lt_top _ _)), vector_measure.add_apply,\n    to_signed_measure_apply_measurable hi, to_signed_measure_apply_measurable hi]\n  all_goals infer_instance\n#align to_signed_measure_add to_signed_measure_add\n\n",
 "to_measure_of_zero_le_to_signed_measure":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `vector_measure.restrict -/\ntheorem to_measure_of_zero_le_to_signed_measure (hs : vector_measure.restrict 0 univ s) :\n    (s.to_measure_of_zero_le univ measurable_set.univ hs).to_signed_measure = s :=\n  by\n  ext (i hi)\n  simp [measure.to_signed_measure_apply_measurable hi, to_measure_of_zero_le_apply _ _ _ hi]\n#align to_measure_of_zero_le_to_signed_measure to_measure_of_zero_le_to_signed_measure\n\n",
 "to_measure_of_zero_le_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `vector_measure.restrict -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\ntheorem to_measure_of_zero_le_apply (hi : vector_measure.restrict 0 i s) (hi₁ : measurable_set i)\n    (hj₁ : measurable_set j) :\n    s.to_measure_of_zero_le i hi₁ hi j =\n      @coe (nnreal) (ennreal) _\n        ⟨s (i ∩ j), nonneg_of_zero_le_restrict s (zero_le_restrict_subset s hi₁ (Set.inter_subset_left _ _) hi)⟩ :=\n  by\n  simp_rw [to_measure_of_zero_le, measure.of_measurable_apply _ hj₁, to_measure_of_zero_le', s.restrict_apply hi₁ hj₁,\n    Set.inter_comm]\n#align to_measure_of_zero_le_apply to_measure_of_zero_le_apply\n\n",
 "to_measure_of_le_zero_to_signed_measure":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `vector_measure.restrict -/\ntheorem to_measure_of_le_zero_to_signed_measure (hs : vector_measure.restrict s univ 0) :\n    (s.to_measure_of_le_zero univ measurable_set.univ hs).to_signed_measure = -s :=\n  by\n  ext (i hi)\n  simp [measure.to_signed_measure_apply_measurable hi, to_measure_of_le_zero_apply _ _ _ hi]\n#align to_measure_of_le_zero_to_signed_measure to_measure_of_le_zero_to_signed_measure\n\n",
 "to_measure_of_le_zero_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `vector_measure.restrict -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem to_measure_of_le_zero_apply (hi : vector_measure.restrict s i 0) (hi₁ : measurable_set i)\n    (hj₁ : measurable_set j) :\n    s.to_measure_of_le_zero i hi₁ hi j =\n      @coe (nnreal) (ennreal) _\n        ⟨-s (i ∩ j),\n          neg_apply s (i ∩ j) ▸\n            nonneg_of_zero_le_restrict _\n              (zero_le_restrict_subset _ hi₁ (Set.inter_subset_left _ _)\n                (@neg_zero (vector_measure α (exprℝ)) _ ▸ neg_le_neg _ _ hi₁ hi))⟩ :=\n  by\n  erw [to_measure_of_zero_le_apply]\n  · simp\n  · assumption\n#align to_measure_of_le_zero_apply to_measure_of_le_zero_apply\n\n",
 "to_ennreal_vector_measure_zero":
 "@[simp]\ntheorem to_ennreal_vector_measure_zero : (0 : measure α).to_ennreal_vector_measure = 0 :=\n  by\n  ext (i hi)\n  simp\n#align to_ennreal_vector_measure_zero to_ennreal_vector_measure_zero\n\n",
 "to_ennreal_vector_measure_apply_measurable":
 "theorem to_ennreal_vector_measure_apply_measurable {μ : measure α} {i : set α} (hi : measurable_set i) :\n    μ.to_ennreal_vector_measure i = μ i :=\n  if_pos hi\n#align to_ennreal_vector_measure_apply_measurable to_ennreal_vector_measure_apply_measurable\n\n",
 "to_ennreal_vector_measure_add":
 "@[simp]\ntheorem to_ennreal_vector_measure_add (μ ν : measure α) :\n    (μ + ν).to_ennreal_vector_measure = μ.to_ennreal_vector_measure + ν.to_ennreal_vector_measure :=\n  by\n  refine' measure_theory.vector_measure.ext fun i hi => _\n  rw [to_ennreal_vector_measure_apply_measurable hi, add_apply, vector_measure.add_apply,\n    to_ennreal_vector_measure_apply_measurable hi, to_ennreal_vector_measure_apply_measurable hi]\n#align to_ennreal_vector_measure_add to_ennreal_vector_measure_add\n\n",
 "symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `vector_measure.mutually_singular -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `vector_measure.mutually_singular -/\n#print symm /-\ntheorem symm (h : vector_measure.mutually_singular v w) : vector_measure.mutually_singular w v :=\n  let ⟨s, hmeas, hs₁, hs₂⟩ := h\n  ⟨«expr ᶜ» s, hmeas.compl, hs₂, fun t ht => hs₁ _ (compl_compl s ▸ ht : t ⊆ s)⟩\n#align symm symm\n-/\n\n",
 "subset_le_of_restrict_le_restrict":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `vector_measure.restrict -/\ntheorem subset_le_of_restrict_le_restrict {i : set α} (hi : measurable_set i) (hi₂ : vector_measure.restrict v i w)\n    {j : set α} (hj : j ⊆ i) : v j ≤ w j := by\n  by_cases hj₁ : measurable_set j\n  · exact (restrict_le_restrict_iff _ _ hi).1 hi₂ hj₁ hj\n  · rw [v.not_measurable hj₁, w.not_measurable hj₁]\n#align subset_le_of_restrict_le_restrict subset_le_of_restrict_le_restrict\n\n",
 "sub_apply":
 "theorem sub_apply (v w : vector_measure α M) (i : set α) : (v - w) i = v i - w i :=\n  rfl\n#align sub_apply sub_apply\n\n",
 "sub":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `vector_measure.absolutely_continuous -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `vector_measure.absolutely_continuous -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `vector_measure.absolutely_continuous -/\ntheorem sub {M : Type _} [add_comm_group M] [topological_space M] [topological_add_group M] {v₁ v₂ : vector_measure α M}\n    {w : vector_measure α N} (hv₁ : vector_measure.absolutely_continuous v₁ w)\n    (hv₂ : vector_measure.absolutely_continuous v₂ w) : vector_measure.absolutely_continuous (v₁ - v₂) w := fun s hs =>\n  by rw [sub_apply, hv₁ hs, hv₂ hs, zero_sub, neg_zero]\n#align sub sub\n\n",
 "smul_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `vector_measure.mutually_singular -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `vector_measure.mutually_singular -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem smul_right {R : Type _} [Semiring R] [DistribMulAction R N] [has_continuous_const_smul R N] (r : R)\n    (h : vector_measure.mutually_singular v w) : vector_measure.mutually_singular v («expr • » r w) :=\n  let ⟨s, hmeas, hs₁, hs₂⟩ := h\n  ⟨s, hmeas, hs₁, fun t ht => by simp only [coe_smul, pi.smul_apply, hs₂ t ht, smul_zero]⟩\n#align smul_right smul_right\n\n",
 "smul_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `vector_measure.mutually_singular -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `vector_measure.mutually_singular -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem smul_left {R : Type _} [Semiring R] [DistribMulAction R M] [has_continuous_const_smul R M] (r : R)\n    (h : vector_measure.mutually_singular v w) : vector_measure.mutually_singular («expr • » r v) w :=\n  (smul_right r h.symm).symm\n#align smul_left smul_left\n\n",
 "smul_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem smul_apply (r : R) (v : vector_measure α M) (i : set α) : («expr • » r v) i = «expr • » r (v i) :=\n  rfl\n#align smul_apply smul_apply\n\n",
 "smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `vector_measure.absolutely_continuous -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `vector_measure.absolutely_continuous -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem smul {R : Type _} [Semiring R] [DistribMulAction R M] [has_continuous_const_smul R M] {r : R}\n    {v : vector_measure α M} {w : vector_measure α N} (h : vector_measure.absolutely_continuous v w) :\n    vector_measure.absolutely_continuous («expr • » r v) w := fun s hs => by rw [smul_apply, h hs, smul_zero]\n#align smul smul\n\n",
 "restrict_zero":
 "@[simp]\ntheorem restrict_zero {i : set α} : (0 : vector_measure α M).restrict i = 0 :=\n  by\n  by_cases hi : measurable_set i\n  · ext (j hj)\n    rw [restrict_apply 0 hi hj]\n    rfl\n  · exact dif_neg hi\n#align restrict_zero restrict_zero\n\n",
 "restrict_univ":
 "@[simp]\ntheorem restrict_univ : v.restrict univ = v :=\n  ext fun i hi => by rw [restrict_apply v measurable_set.univ hi, inter_univ]\n#align restrict_univ restrict_univ\n\n",
 "restrict_trim":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\ntheorem restrict_trim (hle : m ≤ n) {i : set α} (hi : (measurable_set_of m) i) :\n    @vector_measure.restrict α m M _ _ (v.trim hle) i = (v.restrict i).trim hle :=\n  by\n  ext (j hj)\n  rw [restrict_apply, trim_measurable_set_eq hle hj, restrict_apply, trim_measurable_set_eq]\n  all_goals measurability\n#align restrict_trim restrict_trim\n\n",
 "restrict_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem restrict_smul {v : vector_measure α M} {i : set α} (c : R) :\n    («expr • » c v).restrict i = «expr • » c (v.restrict i) :=\n  by\n  by_cases hi : measurable_set i\n  · ext (j hj)\n    simp [restrict_apply _ hi hj]\n  · simp only [restrict_not_measurable _ hi]\n    -- `smul_zero` does not work since we do not require `has_continuous_add`\n    ext (j hj)\n    simp\n#align restrict_smul restrict_smul\n\n",
 "restrict_not_measurable":
 "theorem restrict_not_measurable {i : set α} (hi : ¬measurable_set i) : v.restrict i = 0 :=\n  dif_neg hi\n#align restrict_not_measurable restrict_not_measurable\n\n",
 "restrict_le_zero_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `vector_measure.restrict -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `vector_measure.restrict -/\ntheorem restrict_le_zero_subset (hi₁ : measurable_set i) (hij : j ⊆ i) (hi₂ : vector_measure.restrict v i 0) :\n    vector_measure.restrict v j 0 :=\n  restrict_le_restrict_of_subset_le _ _ fun k hk₁ hk₂ =>\n    (restrict_le_restrict_iff _ _ hi₁).1 hi₂ hk₁ (Set.Subset.trans hk₂ hij)\n#align restrict_le_zero_subset restrict_le_zero_subset\n\n",
 "restrict_le_zero_of_not_measurable":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `vector_measure.restrict -/\ntheorem restrict_le_zero_of_not_measurable (hi : ¬measurable_set i) : vector_measure.restrict v i 0 :=\n  by\n  rw [restrict_zero, restrict_not_measurable _ hi]\n  exact le_rfl\n#align restrict_le_zero_of_not_measurable restrict_le_zero_of_not_measurable\n\n",
 "restrict_le_restrict_union":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `vector_measure.restrict -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `vector_measure.restrict -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `vector_measure.restrict -/\ntheorem restrict_le_restrict_union (hi₁ : measurable_set i) (hi₂ : vector_measure.restrict v i w)\n    (hj₁ : measurable_set j) (hj₂ : vector_measure.restrict v j w) : vector_measure.restrict v (i ∪ j) w :=\n  by\n  rw [union_eq_Union]\n  refine' restrict_le_restrict_countable_Union v w _ _\n  · measurability\n  · rintro (_ | _) <;> simpa\n#align restrict_le_restrict_union restrict_le_restrict_union\n\n",
 "restrict_le_restrict_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `vector_measure.restrict -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `vector_measure.restrict -/\ntheorem restrict_le_restrict_subset {i j : set α} (hi₁ : measurable_set i) (hi₂ : vector_measure.restrict v i w)\n    (hij : j ⊆ i) : vector_measure.restrict v j w :=\n  restrict_le_restrict_of_subset_le v w fun k hk₁ hk₂ =>\n    subset_le_of_restrict_le_restrict v w hi₁ hi₂ (Set.Subset.trans hk₂ hij)\n#align restrict_le_restrict_subset restrict_le_restrict_subset\n\n",
 "restrict_le_restrict_of_subset_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `vector_measure.restrict -/\ntheorem restrict_le_restrict_of_subset_le {i : set α} (h : ∀ ⦃j⦄, measurable_set j → j ⊆ i → v j ≤ w j) :\n    vector_measure.restrict v i w := by\n  by_cases hi : measurable_set i\n  · exact (restrict_le_restrict_iff _ _ hi).2 h\n  · rw [restrict_not_measurable v hi, restrict_not_measurable w hi]\n    exact le_rfl\n#align restrict_le_restrict_of_subset_le restrict_le_restrict_of_subset_le\n\n",
 "restrict_le_restrict_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `vector_measure.restrict -/\ntheorem restrict_le_restrict_iff {i : set α} (hi : measurable_set i) :\n    vector_measure.restrict v i w ↔ ∀ ⦃j⦄, measurable_set j → j ⊆ i → v j ≤ w j :=\n  ⟨fun h j hj₁ hj₂ => restrict_eq_self v hi hj₁ hj₂ ▸ restrict_eq_self w hi hj₁ hj₂ ▸ h j hj₁, fun h =>\n    le_iff.1 fun j hj =>\n      (restrict_apply v hi hj).symm ▸ (restrict_apply w hi hj).symm ▸ h (hj.inter hi) (Set.inter_subset_right j i)⟩\n#align restrict_le_restrict_iff restrict_le_restrict_iff\n\n",
 "restrict_le_restrict_countable_Union":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `vector_measure.restrict -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `vector_measure.restrict -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\ntheorem restrict_le_restrict_countable_Union [countable β] {f : β → set α} (hf₁ : ∀ b, measurable_set (f b))\n    (hf₂ : ∀ b, vector_measure.restrict v (f b) w) :\n    vector_measure.restrict v\n      («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (f b)) w :=\n  by\n  cases nonempty_encodable β\n  rw [← Encodable.unionᵢ_decode₂]\n  refine' restrict_le_restrict_Union v w _ _\n  · intro n\n    measurability\n  · intro n\n    cases' Encodable.decode₂ β n with b\n    · simp\n    · simp [hf₂ b]\n#align restrict_le_restrict_countable_Union restrict_le_restrict_countable_Union\n\n",
 "restrict_le_restrict_Union":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr on » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `vector_measure.restrict -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `vector_measure.restrict -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\ntheorem restrict_le_restrict_Union {f : ℕ → set α} (hf₁ : ∀ n, measurable_set (f n))\n    (hf₂ : ∀ n, vector_measure.restrict v (f n) w) :\n    vector_measure.restrict v\n      («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (f n)) w :=\n  by\n  refine' restrict_le_restrict_of_subset_le v w fun a ha₁ ha₂ => _\n  have ha₃ :\n    «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n        (a ∩ disjointed f n) =\n      a :=\n    by rwa [← inter_Union, Union_disjointed, inter_eq_left_iff_subset]\n  have ha₄ : Pairwise («expr on » Disjoint fun n => a ∩ disjointed f n) :=\n    (disjoint_disjointed _).mono fun i j => Disjoint.mono inf_le_right inf_le_right\n  rw [← ha₃, v.of_disjoint_Union_nat _ ha₄, w.of_disjoint_Union_nat _ ha₄]\n  refine' tsum_le_tsum (fun n => (restrict_le_restrict_iff v w (hf₁ n)).1 (hf₂ n) _ _) _ _\n  · exact ha₁.inter (measurable_set.disjointed hf₁ n)\n  · exact Set.Subset.trans (Set.inter_subset_right _ _) (disjointed_subset _ _)\n  · refine' (v.m_Union (fun n => _) _).summable\n    · exact ha₁.inter (measurable_set.disjointed hf₁ n)\n    · exact (disjoint_disjointed _).mono fun i j => Disjoint.mono inf_le_right inf_le_right\n  · refine' (w.m_Union (fun n => _) _).summable\n    · exact ha₁.inter (measurable_set.disjointed hf₁ n)\n    · exact (disjoint_disjointed _).mono fun i j => Disjoint.mono inf_le_right inf_le_right\n  · intro n\n    exact ha₁.inter (measurable_set.disjointed hf₁ n)\n  · exact fun n => ha₁.inter (measurable_set.disjointed hf₁ n)\n#align restrict_le_restrict_Union restrict_le_restrict_Union\n\n",
 "restrict_eq_self":
 "theorem restrict_eq_self {i : set α} (hi : measurable_set i) {j : set α} (hj : measurable_set j) (hij : j ⊆ i) :\n    v.restrict i j = v j := by rw [restrict_apply v hi hj, inter_eq_left_iff_subset.2 hij]\n#align restrict_eq_self restrict_eq_self\n\n",
 "restrict_empty":
 "@[simp]\ntheorem restrict_empty : v.restrict ∅ = 0 :=\n  ext fun i hi => by rw [restrict_apply v measurable_set.empty hi, inter_empty, v.empty, zero_apply]\n#align restrict_empty restrict_empty\n\n",
 "restrict_apply":
 "theorem restrict_apply {i : set α} (hi : measurable_set i) {j : set α} (hj : measurable_set j) :\n    v.restrict i j = v (j ∩ i) := by\n  rw [restrict, dif_pos hi]\n  exact if_pos hj\n#align restrict_apply restrict_apply\n\n",
 "restrict_add":
 "theorem restrict_add (v w : vector_measure α M) (i : set α) : (v + w).restrict i = v.restrict i + w.restrict i :=\n  by\n  by_cases hi : measurable_set i\n  · ext (j hj)\n    simp [restrict_apply _ hi hj]\n  · simp [restrict_not_measurable _ hi]\n#align restrict_add restrict_add\n\n",
 "refl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `vector_measure.absolutely_continuous -/\n#print refl /-\n@[refl]\ntheorem refl (v : vector_measure α M) : vector_measure.absolutely_continuous v v :=\n  eq rfl\n#align refl refl\n-/\n\n",
 "of_union":
 "theorem of_union {A B : set α} (h : Disjoint A B) (hA : measurable_set A) (hB : measurable_set B) :\n    v (A ∪ B) = v A + v B :=\n  by\n  rw [union_eq_Union, of_disjoint_Union, tsum_fintype, fintype.sum_bool, cond, cond]\n  exacts[fun b => bool.cases_on b hB hA, pairwise_disjoint_on_bool.2 h]\n#align of_union of_union\n\n",
 "of_nonpos_disjoint_union_eq_zero":
 "theorem of_nonpos_disjoint_union_eq_zero {s : signed_measure α} {A B : set α} (h : Disjoint A B)\n    (hA₁ : measurable_set A) (hB₁ : measurable_set B) (hA₂ : s A ≤ 0) (hB₂ : s B ≤ 0) (hAB : s (A ∪ B) = 0) : s A = 0 :=\n  by\n  rw [of_union h hA₁ hB₁] at hAB\n  linarith\n  infer_instance\n#align of_nonpos_disjoint_union_eq_zero of_nonpos_disjoint_union_eq_zero\n\n",
 "of_nonneg_disjoint_union_eq_zero":
 "theorem of_nonneg_disjoint_union_eq_zero {s : signed_measure α} {A B : set α} (h : Disjoint A B)\n    (hA₁ : measurable_set A) (hB₁ : measurable_set B) (hA₂ : 0 ≤ s A) (hB₂ : 0 ≤ s B) (hAB : s (A ∪ B) = 0) : s A = 0 :=\n  by\n  rw [of_union h hA₁ hB₁] at hAB\n  linarith\n  infer_instance\n#align of_nonneg_disjoint_union_eq_zero of_nonneg_disjoint_union_eq_zero\n\n",
 "of_disjoint_Union_nat":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr on » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , » -/\ntheorem of_disjoint_Union_nat [t2_space M] (v : vector_measure α M) {f : ℕ → set α} (hf₁ : ∀ i, measurable_set (f i))\n    (hf₂ : Pairwise («expr on » Disjoint f)) :\n    v («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (f i)) =\n      «expr∑' , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , »\" (v (f i)) :=\n  (v.m_Union hf₁ hf₂).tsum_eq.symm\n#align of_disjoint_Union_nat of_disjoint_Union_nat\n\n",
 "of_disjoint_Union":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr on » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , » -/\ntheorem of_disjoint_Union [countable β] {f : β → set α} (hf₁ : ∀ i, measurable_set (f i))\n    (hf₂ : Pairwise («expr on » Disjoint f)) :\n    v («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (f i)) =\n      «expr∑' , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , »\" (v (f i)) :=\n  (has_sum_of_disjoint_Union hf₁ hf₂).tsum_eq.symm\n#align of_disjoint_Union of_disjoint_Union\n\n",
 "of_diff_of_diff_eq_zero":
 "theorem of_diff_of_diff_eq_zero {A B : set α} (hA : measurable_set A) (hB : measurable_set B) (h' : v (B \\ A) = 0) :\n    v (A \\ B) + v B = v A := by\n  symm\n  calc\n    v A = v (A \\ B ∪ A ∩ B) := by simp only [Set.diff_union_inter]\n    _ = v (A \\ B) + v (A ∩ B) := by\n      rw [of_union]\n      · rw [disjoint_comm]\n        exact Set.disjoint_of_subset_left (A.inter_subset_right B) disjoint_sdiff_self_right\n      · exact hA.diff hB\n      · exact hA.inter hB\n    _ = v (A \\ B) + v (A ∩ B ∪ B \\ A) := by\n      rw [of_union, h', add_zero]\n      · exact Set.disjoint_of_subset_left (A.inter_subset_left B) disjoint_sdiff_self_right\n      · exact hA.inter hB\n      · exact hB.diff hA\n    _ = v (A \\ B) + v B := by rw [Set.union_comm, Set.inter_comm, Set.diff_union_inter]\n    \n#align of_diff_of_diff_eq_zero of_diff_of_diff_eq_zero\n\n",
 "of_diff":
 "theorem of_diff {M : Type _} [add_comm_group M] [topological_space M] [t2_space M] {v : vector_measure α M}\n    {A B : set α} (hA : measurable_set A) (hB : measurable_set B) (h : A ⊆ B) : v (B \\ A) = v B - v A :=\n  by\n  rw [← of_add_of_diff hA hB h, add_sub_cancel']\n  infer_instance\n#align of_diff of_diff\n\n",
 "of_add_of_diff":
 "theorem of_add_of_diff {A B : set α} (hA : measurable_set A) (hB : measurable_set B) (h : A ⊆ B) :\n    v A + v (B \\ A) = v B :=\n  by\n  rw [← of_union disjoint_sdiff_right hA (hB.diff hA), union_diff_cancel h]\n  infer_instance\n#align of_add_of_diff of_add_of_diff\n\n",
 "of_Union_nonpos":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr on » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\ntheorem of_Union_nonpos {M : Type _} [topological_space M] [OrderedAddCommMonoid M] [order_closed_topology M]\n    {v : vector_measure α M} (hf₁ : ∀ i, measurable_set (f i)) (hf₂ : Pairwise («expr on » Disjoint f))\n    (hf₃ : ∀ i, v (f i) ≤ 0) :\n    v («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (f i)) ≤ 0 :=\n  (v.of_disjoint_Union_nat hf₁ hf₂).symm ▸ tsum_nonpos hf₃\n#align of_Union_nonpos of_Union_nonpos\n\n",
 "of_Union_nonneg":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr on » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\ntheorem of_Union_nonneg {M : Type _} [topological_space M] [OrderedAddCommMonoid M] [order_closed_topology M]\n    {v : vector_measure α M} (hf₁ : ∀ i, measurable_set (f i)) (hf₂ : Pairwise («expr on » Disjoint f))\n    (hf₃ : ∀ i, 0 ≤ v (f i)) :\n    0 ≤ v («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (f i)) :=\n  (v.of_disjoint_Union_nat hf₁ hf₂).symm ▸ tsum_nonneg hf₃\n#align of_Union_nonneg of_Union_nonneg\n\n",
 "not_measurable":
 "theorem not_measurable (v : vector_measure α M) {i : set α} (hi : ¬measurable_set i) : v i = 0 :=\n  v.not_measurable' hi\n#align not_measurable not_measurable\n\n",
 "nonpos_of_restrict_le_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `vector_measure.restrict -/\ntheorem nonpos_of_restrict_le_zero (hi₂ : vector_measure.restrict v i 0) : v i ≤ 0 :=\n  by\n  by_cases hi₁ : measurable_set i\n  · exact (restrict_le_restrict_iff _ _ hi₁).1 hi₂ hi₁ Set.Subset.rfl\n  · rw [v.not_measurable hi₁]\n#align nonpos_of_restrict_le_zero nonpos_of_restrict_le_zero\n\n",
 "nonneg_of_zero_le_restrict":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `vector_measure.restrict -/\ntheorem nonneg_of_zero_le_restrict (hi₂ : vector_measure.restrict 0 i v) : 0 ≤ v i :=\n  by\n  by_cases hi₁ : measurable_set i\n  · exact (restrict_le_restrict_iff _ _ hi₁).1 hi₂ hi₁ Set.Subset.rfl\n  · rw [v.not_measurable hi₁]\n#align nonneg_of_zero_le_restrict nonneg_of_zero_le_restrict\n\n",
 "neg_right_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `vector_measure.mutually_singular -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `vector_measure.mutually_singular -/\n@[simp]\ntheorem neg_right_iff {N : Type _} [add_comm_group N] [topological_space N] [topological_add_group N]\n    {v : vector_measure α M} {w : vector_measure α N} :\n    vector_measure.mutually_singular v (-w) ↔ vector_measure.mutually_singular v w :=\n  ⟨fun h => neg_neg w ▸ h.neg_right, neg_right⟩\n#align neg_right_iff neg_right_iff\n\n",
 "neg_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `vector_measure.mutually_singular -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `vector_measure.mutually_singular -/\ntheorem neg_right {N : Type _} [add_comm_group N] [topological_space N] [topological_add_group N]\n    {v : vector_measure α M} {w : vector_measure α N} (h : vector_measure.mutually_singular v w) :\n    vector_measure.mutually_singular v (-w) :=\n  h.symm.neg_left.symm\n#align neg_right neg_right\n\n",
 "neg_left_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `vector_measure.mutually_singular -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `vector_measure.mutually_singular -/\n@[simp]\ntheorem neg_left_iff {M : Type _} [add_comm_group M] [topological_space M] [topological_add_group M]\n    {v : vector_measure α M} {w : vector_measure α N} :\n    vector_measure.mutually_singular (-v) w ↔ vector_measure.mutually_singular v w :=\n  ⟨fun h => neg_neg v ▸ h.neg_left, neg_left⟩\n#align neg_left_iff neg_left_iff\n\n",
 "neg_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `vector_measure.mutually_singular -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `vector_measure.mutually_singular -/\ntheorem neg_left {M : Type _} [add_comm_group M] [topological_space M] [topological_add_group M]\n    {v : vector_measure α M} {w : vector_measure α N} (h : vector_measure.mutually_singular v w) :\n    vector_measure.mutually_singular (-v) w :=\n  by\n  obtain ⟨u, hmu, hu₁, hu₂⟩ := h\n  refine' ⟨u, hmu, fun s hs => _, hu₂⟩\n  rw [neg_apply v s, neg_eq_zero]\n  exact hu₁ s hs\n#align neg_left neg_left\n\n",
 "neg_le_neg_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `vector_measure.restrict -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `vector_measure.restrict -/\n#print neg_le_neg_iff /-\n@[simp]\ntheorem neg_le_neg_iff {i : set α} (hi : measurable_set i) :\n    vector_measure.restrict (-w) i (-v) ↔ vector_measure.restrict v i w :=\n  ⟨fun h => neg_neg v ▸ neg_neg w ▸ neg_le_neg _ _ hi h, fun h => neg_le_neg _ _ hi h⟩\n#align neg_le_neg_iff neg_le_neg_iff\n-/\n\n",
 "neg_le_neg":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `vector_measure.restrict -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `vector_measure.restrict -/\n#print neg_le_neg /-\ntheorem neg_le_neg {i : set α} (hi : measurable_set i) (h : vector_measure.restrict v i w) :\n    vector_measure.restrict (-w) i (-v) := by\n  intro j hj₁\n  rw [restrict_apply _ hi hj₁, restrict_apply _ hi hj₁, neg_apply, neg_apply]\n  refine' neg_le_neg _\n  rw [← restrict_apply _ hi hj₁, ← restrict_apply _ hi hj₁]\n  exact h j hj₁\n#align neg_le_neg neg_le_neg\n-/\n\n",
 "neg_apply":
 "theorem neg_apply (v : vector_measure α M) (i : set α) : (-v) i = -v i :=\n  rfl\n#align neg_apply neg_apply\n\n",
 "mk":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:632:2: warning: expanding binder collection (t «expr ⊆ » s) -/\n/- ./././Mathport/Syntax/Translate/Basic.lean:632:2: warning: expanding binder collection (t «expr ⊆ » «expr ᶜ»(s)) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `vector_measure.mutually_singular -/\ntheorem mk (s : set α) (hs : measurable_set s) (h₁ : ∀ (t) (_ : t ⊆ s), measurable_set t → v t = 0)\n    (h₂ : ∀ (t) (_ : t ⊆ «expr ᶜ» s), measurable_set t → w t = 0) : vector_measure.mutually_singular v w :=\n  by\n  refine' ⟨s, hs, fun t hst => _, fun t hst => _⟩ <;> by_cases ht : measurable_set t\n  · exact h₁ t hst ht\n  · exact not_measurable v ht\n  · exact h₂ t hst ht\n  · exact not_measurable w ht\n#align mk mk\n\n",
 "measure_of_eq_coe":
 "/-\nCopyright (c) 2021 Kexing Ying. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Kexing Ying\n-/\n@[simp]\ntheorem measure_of_eq_coe (v : vector_measure α M) : v.measure_of' = v :=\n  rfl\n#align measure_of_eq_coe measure_of_eq_coe\n\n",
 "measurable_of_not_zero_le_restrict":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `vector_measure.restrict -/\ntheorem measurable_of_not_zero_le_restrict (hi : ¬vector_measure.restrict 0 i v) : measurable_set i :=\n  not.imp_symm (zero_le_restrict_not_measurable _) hi\n#align measurable_of_not_zero_le_restrict measurable_of_not_zero_le_restrict\n\n",
 "measurable_of_not_restrict_le_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `vector_measure.restrict -/\ntheorem measurable_of_not_restrict_le_zero (hi : ¬vector_measure.restrict v i 0) : measurable_set i :=\n  not.imp_symm (restrict_le_zero_of_not_measurable _) hi\n#align measurable_of_not_restrict_le_zero measurable_of_not_restrict_le_zero\n\n",
 "map_zero":
 "#print map_zero /-\n@[simp]\ntheorem map_zero (f : α → β) : (0 : vector_measure α M).map f = 0 :=\n  by\n  by_cases hf : measurable f\n  · ext (i hi)\n    rw [map_apply _ hf hi, zero_apply, zero_apply]\n  · exact dif_neg hf\n#align map_zero map_zero\n-/\n\n",
 "map_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem map_smul {v : vector_measure α M} {f : α → β} (c : R) : («expr • » c v).map f = «expr • » c (v.map f) :=\n  by\n  by_cases hf : measurable f\n  · ext (i hi)\n    simp [map_apply _ hf hi]\n  · simp only [map, dif_neg hf]\n    -- `smul_zero` does not work since we do not require `has_continuous_add`\n    ext (i hi)\n    simp\n#align map_smul map_smul\n\n",
 "map_range_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+ » -/\n@[simp]\ntheorem map_range_zero {f : «expr →+ » M N} (hf : continuous f) : map_range (0 : vector_measure α M) f hf = 0 :=\n  by\n  ext\n  simp\n#align map_range_zero map_range_zero\n\n",
 "map_range_id":
 "@[simp]\ntheorem map_range_id : v.map_range (AddMonoidHom.id M) continuous_id = v :=\n  by\n  ext\n  rfl\n#align map_range_id map_range_id\n\n",
 "map_range_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+ » -/\n@[simp]\ntheorem map_range_apply {f : «expr →+ » M N} (hf : continuous f) {s : set α} : v.map_range f hf s = f (v s) :=\n  rfl\n#align map_range_apply map_range_apply\n\n",
 "map_range_add":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+ » -/\n@[simp]\ntheorem map_range_add {v w : vector_measure α M} {f : «expr →+ » M N} (hf : continuous f) :\n    (v + w).map_range f hf = v.map_range f hf + w.map_range f hf :=\n  by\n  ext\n  simp\n#align map_range_add map_range_add\n\n",
 "map_not_measurable":
 "theorem map_not_measurable {f : α → β} (hf : ¬measurable f) : v.map f = 0 :=\n  dif_neg hf\n#align map_not_measurable map_not_measurable\n\n",
 "map_id":
 "@[simp]\ntheorem map_id : v.map id = v :=\n  ext fun i hi => by rw [map_apply v measurable_id hi, preimage_id]\n#align map_id map_id\n\n",
 "map_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem map_apply {f : α → β} (hf : measurable f) {s : set β} (hs : measurable_set s) :\n    v.map f s = v («expr ⁻¹' » f s) := by\n  rw [map, dif_pos hf]\n  exact if_pos hs\n#align map_apply map_apply\n\n",
 "map_add":
 "#print map_add /-\ntheorem map_add (v w : vector_measure α M) (f : α → β) : (v + w).map f = v.map f + w.map f :=\n  by\n  by_cases hf : measurable f\n  · ext (i hi)\n    simp [map_apply _ hf hi]\n  · simp [map, dif_neg hf]\n#align map_add map_add\n-/\n\n",
 "map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `vector_measure.absolutely_continuous -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `vector_measure.absolutely_continuous -/\ntheorem map [measure_space β] (h : vector_measure.absolutely_continuous v w) (f : α → β) :\n    vector_measure.absolutely_continuous (v.map f) (w.map f) :=\n  by\n  by_cases hf : measurable f\n  · refine' mk fun s hs hws => _\n    rw [map_apply _ hf hs] at hws⊢\n    exact h hws\n  · intro s hs\n    rw [map_not_measurable v hf, zero_apply]\n#align map map\n\n",
 "m_Union":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr on » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\ntheorem m_Union (v : vector_measure α M) {f : ℕ → set α} (hf₁ : ∀ i, measurable_set (f i))\n    (hf₂ : Pairwise («expr on » Disjoint f)) :\n    has_sum (fun i => v (f i))\n      (v («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (f i))) :=\n  v.m_Union' hf₁ hf₂\n#align m_Union m_Union\n\n",
 "le_restrict_univ_iff_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `vector_measure.restrict -/\ntheorem le_restrict_univ_iff_le : vector_measure.restrict v univ w ↔ v ≤ w :=\n  by\n  constructor\n  · intro h s hs\n    have := h s hs\n    rwa [restrict_apply _ measurable_set.univ hs, inter_univ, restrict_apply _ measurable_set.univ hs, inter_univ] at\n      this\n  · intro h s hs\n    rw [restrict_apply _ measurable_set.univ hs, inter_univ, restrict_apply _ measurable_set.univ hs, inter_univ]\n    exact h s hs\n#align le_restrict_univ_iff_le le_restrict_univ_iff_le\n\n",
 "le_restrict_empty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `vector_measure.restrict -/\ntheorem le_restrict_empty : vector_measure.restrict v ∅ w :=\n  by\n  intro j hj\n  rw [restrict_empty, restrict_empty]\n#align le_restrict_empty le_restrict_empty\n\n",
 "le_iff'":
 "theorem le_iff' : v ≤ w ↔ ∀ i, v i ≤ w i :=\n  by\n  refine' ⟨fun h i => _, fun h i hi => h i⟩\n  by_cases hi : measurable_set i\n  · exact h i hi\n  · rw [v.not_measurable hi, w.not_measurable hi]\n#align le_iff' le_iff'\n\n",
 "le_iff":
 "theorem le_iff : v ≤ w ↔ ∀ i, measurable_set i → v i ≤ w i :=\n  iff.rfl\n#align le_iff le_iff\n\n",
 "has_sum_of_disjoint_Union":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr on » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr on » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\ntheorem has_sum_of_disjoint_Union [countable β] {f : β → set α} (hf₁ : ∀ i, measurable_set (f i))\n    (hf₂ : Pairwise («expr on » Disjoint f)) :\n    has_sum (fun i => v (f i))\n      (v («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (f i))) :=\n  by\n  cases nonempty_encodable β\n  set g := fun i : ℕ =>\n    «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (f b) with hg\n  have hg₁ : ∀ i, measurable_set (g i) := fun _ => measurable_set.Union fun b => measurable_set.Union fun _ => hf₁ b\n  have hg₂ : Pairwise («expr on » Disjoint g) := Encodable.unionᵢ_decode₂_disjoint_on hf₂\n  have := v.of_disjoint_Union_nat hg₁ hg₂\n  rw [hg, Encodable.unionᵢ_decode₂] at this\n  have hg₃ : (fun i : β => v (f i)) = fun i => v (g (encodable.encode i)) :=\n    by\n    ext\n    rw [hg]\n    simp only\n    congr\n    ext y\n    simp only [exists_prop, mem_Union, option.mem_def]\n    constructor\n    · intro hy\n      refine' ⟨x, (Encodable.decode₂_is_partial_inv _ _).2 rfl, hy⟩\n    · rintro ⟨b, hb₁, hb₂⟩\n      rw [Encodable.decode₂_is_partial_inv _ _] at hb₁\n      rwa [← Encodable.encode_injective hb₁]\n  rw [summable.has_sum_iff, this, ← tsum_Union_decode₂]\n  · exact v.empty\n  · rw [hg₃]\n    change summable ((fun i => v (g i)) ∘ encodable.encode)\n    rw [function.injective.summable_iff Encodable.encode_injective]\n    · exact (v.m_Union hg₁ hg₂).summable\n    · intro x hx\n      convert v.empty\n      simp only [Union_eq_empty, option.mem_def, not_exists, mem_range] at hx⊢\n      intro i hi\n      exact false.elim ((hx i) ((Encodable.decode₂_is_partial_inv _ _).1 hi))\n#align has_sum_of_disjoint_Union has_sum_of_disjoint_Union\n\n",
 "ext_iff'":
 "theorem ext_iff' (v w : vector_measure α M) : v = w ↔ ∀ i : set α, v i = w i := by\n  rw [← coe_injective.eq_iff, function.funext_iff]\n#align ext_iff' ext_iff'\n\n",
 "ext_iff":
 "theorem ext_iff (v w : vector_measure α M) : v = w ↔ ∀ i : set α, measurable_set i → v i = w i :=\n  by\n  constructor\n  · rintro rfl _ _\n    rfl\n  · rw [ext_iff']\n    intro h i\n    by_cases hi : measurable_set i\n    · exact h i hi\n    · simp_rw [not_measurable _ hi]\n#align ext_iff ext_iff\n\n",
 "ext":
 "@[ext]\ntheorem ext {s t : vector_measure α M} (h : ∀ i : set α, measurable_set i → s i = t i) : s = t :=\n  (ext_iff s t).2 h\n#align ext ext\n\n",
 "exists_pos_measure_of_not_restrict_le_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `vector_measure.restrict -/\ntheorem exists_pos_measure_of_not_restrict_le_zero (hi : ¬vector_measure.restrict v i 0) :\n    ∃ j : set α, measurable_set j ∧ j ⊆ i ∧ 0 < v j :=\n  by\n  have hi₁ : measurable_set i := measurable_of_not_restrict_le_zero _ hi\n  rw [restrict_le_restrict_iff _ _ hi₁] at hi\n  push_neg  at hi\n  obtain ⟨j, hj₁, hj₂, hj⟩ := hi\n  exact ⟨j, hj₁, hj₂, hj⟩\n#align exists_pos_measure_of_not_restrict_le_zero exists_pos_measure_of_not_restrict_le_zero\n\n",
 "eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `vector_measure.absolutely_continuous -/\ntheorem eq {w : vector_measure α M} (h : v = w) : vector_measure.absolutely_continuous v w := fun s hs => h.symm ▸ hs\n#align eq eq\n\n",
 "ennreal_to_measure_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\ntheorem ennreal_to_measure_apply {m : measurable_space α} {v : vector_measure α (ennreal)} {s : set α}\n    (hs : measurable_set s) : ennreal_to_measure v s = v s := by rw [ennreal_to_measure, of_measurable_apply _ hs]\n#align ennreal_to_measure_apply ennreal_to_measure_apply\n\n",
 "ennreal_to_measure":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `vector_measure.absolutely_continuous -/\ntheorem ennreal_to_measure {μ : vector_measure α (ennreal)} :\n    (∀ ⦃s : set α⦄, μ.ennreal_to_measure s = 0 → v s = 0) ↔ vector_measure.absolutely_continuous v μ :=\n  by\n  constructor <;> intro h\n  · refine' mk fun s hmeas hs => h _\n    rw [← hs, ennreal_to_measure_apply hmeas]\n  · intro s hs\n    by_cases hmeas : measurable_set s\n    · rw [ennreal_to_measure_apply hmeas] at hs\n      exact h hs\n    · exact not_measurable v hmeas\n#align ennreal_to_measure ennreal_to_measure\n\n",
 "empty":
 "@[simp]\ntheorem empty (v : vector_measure α M) : v ∅ = 0 :=\n  v.empty'\n#align empty empty\n\n",
 "coe_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n@[simp]\ntheorem coe_zero : «expr⇑ » (0 : vector_measure α M) = 0 :=\n  rfl\n#align coe_zero coe_zero\n\n",
 "coe_sub":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n@[simp]\ntheorem coe_sub (v w : vector_measure α M) : «expr⇑ » (v - w) = v - w :=\n  rfl\n#align coe_sub coe_sub\n\n",
 "coe_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem coe_smul (r : R) (v : vector_measure α M) : «expr⇑ » («expr • » r v) = «expr • » r v :=\n  rfl\n#align coe_smul coe_smul\n\n",
 "coe_neg":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n@[simp]\ntheorem coe_neg (v : vector_measure α M) : «expr⇑ » (-v) = -v :=\n  rfl\n#align coe_neg coe_neg\n\n",
 "coe_injective":
 "theorem coe_injective : @function.injective (vector_measure α M) (set α → M) coe_fn := fun v w h =>\n  by\n  cases v\n  cases w\n  congr\n#align coe_injective coe_injective\n\n",
 "coe_add":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n@[simp]\ntheorem coe_add (v w : vector_measure α M) : «expr⇑ » (v + w) = v + w :=\n  rfl\n#align coe_add coe_add\n\n",
 "add_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `vector_measure.mutually_singular -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `vector_measure.mutually_singular -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `vector_measure.mutually_singular -/\ntheorem add_right [t2_space M] [has_continuous_add N] (h₁ : vector_measure.mutually_singular v w₁)\n    (h₂ : vector_measure.mutually_singular v w₂) : vector_measure.mutually_singular v (w₁ + w₂) :=\n  (add_left h₁.symm h₂.symm).symm\n#align add_right add_right\n\n",
 "add_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `vector_measure.mutually_singular -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `vector_measure.mutually_singular -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `vector_measure.mutually_singular -/\ntheorem add_left [t2_space N] [has_continuous_add M] (h₁ : vector_measure.mutually_singular v₁ w)\n    (h₂ : vector_measure.mutually_singular v₂ w) : vector_measure.mutually_singular (v₁ + v₂) w :=\n  by\n  obtain ⟨u, hmu, hu₁, hu₂⟩ := h₁\n  obtain ⟨v, hmv, hv₁, hv₂⟩ := h₂\n  refine' mk (u ∩ v) (hmu.inter hmv) (fun t ht hmt => _) fun t ht hmt => _\n  · rw [add_apply, hu₁ _ (subset_inter_iff.1 ht).1, hv₁ _ (subset_inter_iff.1 ht).2, zero_add]\n  · rw [compl_inter] at ht\n    rw [(_ : t = «expr ᶜ» u ∩ t ∪ «expr ᶜ» v \\ «expr ᶜ» u ∩ t),\n      of_union _ (hmu.compl.inter hmt) ((hmv.compl.diff hmu.compl).inter hmt), hu₂, hv₂, add_zero]\n    · exact subset.trans (inter_subset_left _ _) (diff_subset _ _)\n    · exact inter_subset_left _ _\n    · infer_instance\n    · exact disjoint_sdiff_self_right.mono (inter_subset_left _ _) (inter_subset_left _ _)\n    · apply subset.antisymm <;> intro x hx\n      · by_cases hxu' : x ∈ «expr ᶜ» u\n        · exact or.inl ⟨hxu', hx⟩\n        rcases ht hx with (hxu | hxv)\n        exacts[false.elim (hxu' hxu), or.inr ⟨⟨hxv, hxu'⟩, hx⟩]\n      · rcases hx with ⟨⟩ <;> exact hx.2\n#align add_left add_left\n\n",
 "add_apply":
 "theorem add_apply (v w : vector_measure α M) (i : set α) : (v + w) i = v i + w i :=\n  rfl\n#align add_apply add_apply\n\n",
 "add":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `vector_measure.absolutely_continuous -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `vector_measure.absolutely_continuous -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `vector_measure.absolutely_continuous -/\ntheorem add [has_continuous_add M] {v₁ v₂ : vector_measure α M} {w : vector_measure α N}\n    (hv₁ : vector_measure.absolutely_continuous v₁ w) (hv₂ : vector_measure.absolutely_continuous v₂ w) :\n    vector_measure.absolutely_continuous (v₁ + v₂) w := fun s hs => by rw [add_apply, hv₁ hs, hv₂ hs, zero_add]\n#align add add\n\n"}