{"volume_val":
 "theorem volume_val (s) : volume s = stieltjes_function.id.measure s := by simp [volume_eq_stieltjes_id]\n#align volume_val volume_val\n\n",
 "volume_univ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n@[simp]\ntheorem volume_univ : volume (univ : set (exprℝ)) = ennreal.top :=\n  ennreal.eq_top_of_forall_nnreal_le fun r =>\n    calc\n      (r : ennreal) = volume (Icc (0 : exprℝ) r) := by simp\n      _ ≤ volume univ := measure_mono (subset_univ _)\n      \n#align volume_univ volume_univ\n\n",
 "volume_singleton":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n@[simp]\ntheorem volume_singleton {a : exprℝ} : volume ({a} : set (exprℝ)) = 0 := by simp [volume_val]\n#align volume_singleton volume_singleton\n\n",
 "volume_region_between_eq_lintegral'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫⁻ in , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ in , ∂ » -/\ntheorem volume_region_between_eq_lintegral' (hf : measurable f) (hg : measurable g) (hs : measurable_set s) :\n    μ.prod volume (region_between f g s) =\n      «expr∫⁻ in , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ in , ∂ »\" s\n        (ennreal.of_real ((g - f) y)) μ :=\n  by\n  classical\n    rw [measure.prod_apply]\n    · have h :\n        (fun x => volume { a | x ∈ s ∧ a ∈ Ioo (f x) (g x) }) = s.indicator fun x => ennreal.of_real (g x - f x) :=\n        by\n        funext x\n        rw [indicator_apply]\n        split_ifs\n        · have hx : { a | x ∈ s ∧ a ∈ Ioo (f x) (g x) } = Ioo (f x) (g x) := by simp [h, Ioo]\n          simp only [hx, real.volume_Ioo, sub_zero]\n        · have hx : { a | x ∈ s ∧ a ∈ Ioo (f x) (g x) } = ∅ := by simp [h]\n          simp only [hx, measure_empty]\n      dsimp only [region_between, preimage_set_of_eq]\n      rw [h, lintegral_indicator] <;> simp only [hs, pi.sub_apply]\n    · exact measurable_set_region_between hf hg hs\n#align volume_region_between_eq_lintegral' volume_region_between_eq_lintegral'\n\n",
 "volume_region_between_eq_lintegral":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫⁻ in , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ in , ∂ » -/\n/-- The volume of the region between two almost everywhere measurable functions on a measurable set\n    can be represented as a Lebesgue integral. -/\ntheorem volume_region_between_eq_lintegral [sigma_finite μ] (hf : ae_measurable f (μ.restrict s))\n    (hg : ae_measurable g (μ.restrict s)) (hs : measurable_set s) :\n    μ.prod volume (region_between f g s) =\n      «expr∫⁻ in , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ in , ∂ »\" s\n        (ennreal.of_real ((g - f) y)) μ :=\n  by\n  have h₁ :\n    «expr =ᵐ[ ] » (fun y => ennreal.of_real ((g - f) y)) (μ.restrict s) fun y =>\n      ennreal.of_real ((ae_measurable.mk g hg - ae_measurable.mk f hf) y) :=\n    (hg.ae_eq_mk.sub hf.ae_eq_mk).fun_comp _\n  have h₂ :\n    (μ.restrict s).prod volume (region_between f g s) =\n      (μ.restrict s).prod volume (region_between (ae_measurable.mk f hf) (ae_measurable.mk g hg) s) :=\n    by\n    apply measure_congr\n    apply eventually_eq.rfl.inter\n    exact\n      ((quasi_measure_preserving_fst.ae_eq_comp hf.ae_eq_mk).comp₂ _ eventually_eq.rfl).inter\n        (eventually_eq.rfl.comp₂ _ <| quasi_measure_preserving_fst.ae_eq_comp hg.ae_eq_mk)\n  rw [lintegral_congr_ae h₁, ← volume_region_between_eq_lintegral' hf.measurable_mk hg.measurable_mk hs]\n  convert h₂ using 1\n  · rw [measure.restrict_prod_eq_prod_univ]\n    exact (measure.restrict_eq_self _ (region_between_subset f g s)).symm\n  · rw [measure.restrict_prod_eq_prod_univ]\n    exact (measure.restrict_eq_self _ (region_between_subset (ae_measurable.mk f hf) (ae_measurable.mk g hg) s)).symm\n#align volume_region_between_eq_lintegral volume_region_between_eq_lintegral\n\n",
 "volume_region_between_eq_integral'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≤ᵐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ in , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ in , ∂ » -/\ntheorem volume_region_between_eq_integral' [sigma_finite μ] (f_int : integrable_on f s μ) (g_int : integrable_on g s μ)\n    (hs : measurable_set s) (hfg : «expr ≤ᵐ[ ] » f (μ.restrict s) g) :\n    μ.prod volume (region_between f g s) =\n      ennreal.of_real\n        («expr∫ in , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ in , ∂ »\" s\n          ((g - f) y) μ) :=\n  by\n  have h : «expr =ᵐ[ ] » (g - f) (μ.restrict s) fun x => real.to_nnreal (g x - f x) :=\n    hfg.mono fun x hx => (real.coe_to_nnreal _ <| sub_nonneg.2 hx).symm\n  rw [volume_region_between_eq_lintegral f_int.ae_measurable g_int.ae_measurable hs, integral_congr_ae h,\n    lintegral_congr_ae, lintegral_coe_eq_integral _ ((integrable_congr h).mp (g_int.sub f_int))]\n  simpa only\n#align volume_region_between_eq_integral' volume_region_between_eq_integral'\n\n",
 "volume_region_between_eq_integral":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ in , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ in , ∂ » -/\n/-- If two functions are integrable on a measurable set, and one function is less than\n    or equal to the other on that set, then the volume of the region\n    between the two functions can be represented as an integral. -/\ntheorem volume_region_between_eq_integral [sigma_finite μ] (f_int : integrable_on f s μ) (g_int : integrable_on g s μ)\n    (hs : measurable_set s) (hfg : ∀ x ∈ s, f x ≤ g x) :\n    μ.prod volume (region_between f g s) =\n      ennreal.of_real\n        («expr∫ in , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ in , ∂ »\" s\n          ((g - f) y) μ) :=\n  volume_region_between_eq_integral' f_int g_int hs ((ae_restrict_iff' hs).mpr (eventually_of_forall hfg))\n#align volume_region_between_eq_integral volume_region_between_eq_integral\n\n",
 "volume_preserving_transvection_struct":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ᵐ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- A transvection preserves Lebesgue measure. -/\ntheorem volume_preserving_transvection_struct [decidable_eq ι] (t : transvection_struct ι (exprℝ)) :\n    measure_preserving t.to_matrix.to_lin' :=\n  by\n  /- We separate the coordinate along which there is a shearing from the other ones, and apply\n    Fubini. Along this coordinate (and when all the other coordinates are fixed), it acts like a\n    translation, and therefore preserves Lebesgue. -/\n  let p : ι → Prop := fun i => i ≠ t.i\n  let α : Type _ := { x // p x }\n  let β : Type _ := { x // ¬p x }\n  let g : (α → exprℝ) → (β → exprℝ) → β → exprℝ := fun a b => (fun x => t.c * a ⟨t.j, t.hij.symm⟩) + b\n  let F : (α → exprℝ) × (β → exprℝ) → (α → exprℝ) × (β → exprℝ) := fun p => (id p.1, g p.1 p.2)\n  let e : «expr ≃ᵐ » (ι → exprℝ) ((α → exprℝ) × (β → exprℝ)) :=\n    measurable_equiv.pi_equiv_pi_subtype_prod (fun i : ι => exprℝ) p\n  have : (t.to_matrix.to_lin' : (ι → exprℝ) → ι → exprℝ) = e.symm ∘ F ∘ e :=\n    by\n    cases t\n    ext (f k)\n    simp only [linear_equiv.map_smul, dite_eq_ite, linear_map.id_coe, p, ite_not, algebra.id.smul_eq_mul, one_mul,\n      dot_product, std_basis_matrix, measurable_equiv.pi_equiv_pi_subtype_prod_symm_apply, id.def, transvection,\n      pi.add_apply, zero_mul, linear_map.smul_apply, Function.comp_apply,\n      measurable_equiv.pi_equiv_pi_subtype_prod_apply, matrix.transvection_struct.to_matrix_mk, matrix.mul_vec,\n      linear_equiv.map_add, ite_mul, e, matrix.to_lin'_apply, pi.smul_apply, subtype.coe_mk, g, linear_map.add_apply,\n      finset.sum_congr, matrix.to_lin'_one]\n    by_cases h : t_i = k\n    ·\n      simp only [h, true_and_iff, finset.mem_univ, if_true, eq_self_iff_true, finset.sum_ite_eq, one_apply, boole_mul,\n        add_comm]\n    · simp only [h, ne.symm h, add_zero, if_false, finset.sum_const_zero, false_and_iff, mul_zero]\n  rw [this]\n  have A : measure_preserving e := by convert volume_preserving_pi_equiv_pi_subtype_prod (fun i : ι => exprℝ) p\n  have B : measure_preserving F :=\n    haveI g_meas : measurable (function.uncurry g) :=\n      by\n      have : measurable fun c : α → exprℝ => c ⟨t.j, t.hij.symm⟩ := measurable_pi_apply ⟨t.j, t.hij.symm⟩\n      refine' (measurable_pi_lambda _ fun i => measurable.const_mul _ _).add measurable_snd\n      exact this.comp measurable_fst\n    (measure_preserving.id _).skew_product g_meas (eventually_of_forall fun a => map_add_left_eq_self _ _)\n  exact ((A.symm e).comp B).comp A\n#align volume_preserving_transvection_struct volume_preserving_transvection_struct\n\n",
 "volume_preimage_mul_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n@[simp]\ntheorem volume_preimage_mul_right {a : exprℝ} (h : a ≠ 0) (s : set (exprℝ)) :\n    volume («expr ⁻¹' » (· * a) s) = ennreal.of_real (abs a⁻¹) * volume s :=\n  calc\n    volume («expr ⁻¹' » (· * a) s) = measure.map (· * a) volume s :=\n      ((homeomorph.mul_right₀ a h).to_measurable_equiv.map_apply s).symm\n    _ = ennreal.of_real (abs a⁻¹) * volume s := by\n      rw [map_volume_mul_right h]\n      rfl\n    \n#align volume_preimage_mul_right volume_preimage_mul_right\n\n",
 "volume_preimage_mul_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n@[simp]\ntheorem volume_preimage_mul_left {a : exprℝ} (h : a ≠ 0) (s : set (exprℝ)) :\n    volume («expr ⁻¹' » ((· * ·) a) s) = ennreal.of_real (abs a⁻¹) * volume s :=\n  calc\n    volume («expr ⁻¹' » ((· * ·) a) s) = measure.map ((· * ·) a) volume s :=\n      ((homeomorph.mul_left₀ a h).to_measurable_equiv.map_apply s).symm\n    _ = ennreal.of_real (abs a⁻¹) * volume s := by\n      rw [map_volume_mul_left h]\n      rfl\n    \n#align volume_preimage_mul_left volume_preimage_mul_left\n\n",
 "volume_pos_of_nhds_real":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\ntheorem _root_.filter.eventually.volume_pos_of_nhds_real {p : exprℝ → Prop} {a : exprℝ}\n    (h :\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" ((nhds) a)\n        (p x)) :\n    (0 : ennreal) < volume { x | p x } :=\n  by\n  rcases h.exists_Ioo_subset with ⟨l, u, hx, hs⟩\n  refine' lt_of_lt_of_le _ (measure_mono hs)\n  simpa [-mem_Ioo] using hx.1.trans hx.2\n#align filter.eventually.volume_pos_of_nhds_real filter.eventually.volume_pos_of_nhds_real\n\n",
 "volume_pi_le_prod_diam":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem volume_pi_le_prod_diam (s : set (ι → exprℝ)) :\n    volume s ≤\n      finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n        (emetric.diam («expr '' » (function.eval i) s)) :=\n  calc\n    volume s ≤ volume (pi univ fun i => closure («expr '' » (function.eval i) s)) :=\n      volume.mono <| Subset.trans (subset_pi_eval_image univ s) <| pi_mono fun i hi => subset_closure\n    _ =\n        finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n          (volume (closure <| «expr '' » (function.eval i) s)) :=\n      volume_pi_pi _\n    _ ≤\n        finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n          (emetric.diam («expr '' » (function.eval i) s)) :=\n      finset.prod_le_prod' fun i hi => (volume_le_diam _).trans_eq (emetric.diam_closure _)\n    \n#align volume_pi_le_prod_diam volume_pi_le_prod_diam\n\n",
 "volume_pi_le_diam_pow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem volume_pi_le_diam_pow (s : set (ι → exprℝ)) : volume s ≤ emetric.diam s ^ fintype.card ι :=\n  calc\n    volume s ≤\n        finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n          (emetric.diam («expr '' » (function.eval i) s)) :=\n      volume_pi_le_prod_diam s\n    _ ≤\n        finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n          ((1 : nnreal) * emetric.diam s) :=\n      finset.prod_le_prod' fun i hi => (lipschitz_with.eval i).ediam_image_le s\n    _ = emetric.diam s ^ fintype.card ι := by simp only [ennreal.coe_one, one_mul, finset.prod_const, fintype.card]\n    \n#align volume_pi_le_diam_pow volume_pi_le_diam_pow\n\n",
 "volume_pi_closed_ball":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n@[simp]\ntheorem volume_pi_closed_ball (a : ι → exprℝ) {r : exprℝ} (hr : 0 ≤ r) :\n    volume (metric.closed_ball a r) = ennreal.of_real ((2 * r) ^ fintype.card ι) :=\n  by\n  simp only [volume_pi_closed_ball a hr, volume_closed_ball, finset.prod_const]\n  exact (ennreal.of_real_pow (mul_nonneg zero_le_two hr) _).symm\n#align volume_pi_closed_ball volume_pi_closed_ball\n\n",
 "volume_pi_ball":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n@[simp]\ntheorem volume_pi_ball (a : ι → exprℝ) {r : exprℝ} (hr : 0 < r) :\n    volume (metric.ball a r) = ennreal.of_real ((2 * r) ^ fintype.card ι) :=\n  by\n  simp only [volume_pi_ball a hr, volume_ball, finset.prod_const]\n  exact (ennreal.of_real_pow (mul_nonneg zero_le_two hr.le) _).symm\n#align volume_pi_ball volume_pi_ball\n\n",
 "volume_pi_Ioo_to_real":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\n@[simp]\ntheorem volume_pi_Ioo_to_real {a b : ι → exprℝ} (h : a ≤ b) :\n    (volume (pi univ fun i => Ioo (a i) (b i))).to_real =\n      finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n        (b i - a i) :=\n  by simp only [volume_pi_Ioo, ennreal.to_real_prod, ennreal.to_real_of_real (sub_nonneg.2 (h _))]\n#align volume_pi_Ioo_to_real volume_pi_Ioo_to_real\n\n",
 "volume_pi_Ioo":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\ntheorem volume_pi_Ioo {a b : ι → exprℝ} :\n    volume (pi univ fun i => Ioo (a i) (b i)) =\n      finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n        (ennreal.of_real (b i - a i)) :=\n  (measure_congr measure.univ_pi_Ioo_ae_eq_Icc).trans volume_Icc_pi\n#align volume_pi_Ioo volume_pi_Ioo\n\n",
 "volume_pi_Ioc_to_real":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\n@[simp]\ntheorem volume_pi_Ioc_to_real {a b : ι → exprℝ} (h : a ≤ b) :\n    (volume (pi univ fun i => Ioc (a i) (b i))).to_real =\n      finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n        (b i - a i) :=\n  by simp only [volume_pi_Ioc, ennreal.to_real_prod, ennreal.to_real_of_real (sub_nonneg.2 (h _))]\n#align volume_pi_Ioc_to_real volume_pi_Ioc_to_real\n\n",
 "volume_pi_Ioc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\ntheorem volume_pi_Ioc {a b : ι → exprℝ} :\n    volume (pi univ fun i => Ioc (a i) (b i)) =\n      finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n        (ennreal.of_real (b i - a i)) :=\n  (measure_congr measure.univ_pi_Ioc_ae_eq_Icc).trans volume_Icc_pi\n#align volume_pi_Ioc volume_pi_Ioc\n\n",
 "volume_pi_Ico_to_real":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\n@[simp]\ntheorem volume_pi_Ico_to_real {a b : ι → exprℝ} (h : a ≤ b) :\n    (volume (pi univ fun i => Ico (a i) (b i))).to_real =\n      finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n        (b i - a i) :=\n  by simp only [volume_pi_Ico, ennreal.to_real_prod, ennreal.to_real_of_real (sub_nonneg.2 (h _))]\n#align volume_pi_Ico_to_real volume_pi_Ico_to_real\n\n",
 "volume_pi_Ico":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\ntheorem volume_pi_Ico {a b : ι → exprℝ} :\n    volume (pi univ fun i => Ico (a i) (b i)) =\n      finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n        (ennreal.of_real (b i - a i)) :=\n  (measure_congr measure.univ_pi_Ico_ae_eq_Icc).trans volume_Icc_pi\n#align volume_pi_Ico volume_pi_Ico\n\n",
 "volume_le_diam":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem volume_le_diam (s : set (exprℝ)) : volume s ≤ emetric.diam s :=\n  by\n  by_cases hs : metric.bounded s\n  · rw [real.ediam_eq hs, ← volume_Icc]\n    exact volume.mono (real.subset_Icc_Inf_Sup_of_bounded hs)\n  · rw [metric.ediam_of_unbounded hs]\n    exact le_top\n#align volume_le_diam volume_le_diam\n\n",
 "volume_interval":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n@[simp]\ntheorem volume_interval {a b : exprℝ} : volume (uIcc a b) = of_real (|b - a|) := by\n  rw [← Icc_min_max, volume_Icc, max_sub_min_eq_abs]\n#align volume_interval volume_interval\n\n",
 "volume_eq_stieltjes_id":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-\nCopyright (c) 2017 Johannes Hölzl. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johannes Hölzl, Sébastien Gouëzel, Yury Kudryashov\n-/\n/-- The volume on the real line (as a particular case of the volume on a finite-dimensional\ninner product space) coincides with the Stieltjes measure coming from the identity function. -/\ntheorem volume_eq_stieltjes_id : (volume : measure (exprℝ)) = stieltjes_function.id.measure :=\n  by\n  haveI : is_add_left_invariant stieltjes_function.id.measure :=\n    ⟨fun a =>\n      eq.symm <|\n        real.measure_ext_Ioo_rat fun p q => by\n          simp only [measure.map_apply (measurable_const_add a) measurable_set_Ioo, sub_sub_sub_cancel_right,\n            stieltjes_function.measure_Ioo, stieltjes_function.id_left_lim, stieltjes_function.id_apply, id.def,\n            preimage_const_add_Ioo]⟩\n  have A : stieltjes_function.id.measure (std_orthonormal_basis (exprℝ) (exprℝ)).to_basis.parallelepiped = 1 :=\n    by\n    change stieltjes_function.id.measure (parallelepiped (std_orthonormal_basis (exprℝ) (exprℝ))) = 1\n    rcases parallelepiped_orthonormal_basis_one_dim (std_orthonormal_basis (exprℝ) (exprℝ)) with (H | H) <;>\n      simp only [H, stieltjes_function.measure_Icc, stieltjes_function.id_apply, id.def, tsub_zero,\n        stieltjes_function.id_left_lim, sub_neg_eq_add, zero_add, ennreal.of_real_one]\n  conv_rhs =>\n    rw [add_haar_measure_unique stieltjes_function.id.measure\n        (std_orthonormal_basis (exprℝ) (exprℝ)).to_basis.parallelepiped,\n      A]\n  simp only [volume, basis.add_haar, one_smul]\n#align volume_eq_stieltjes_id volume_eq_stieltjes_id\n\n",
 "volume_emetric_closed_ball":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n@[simp]\ntheorem volume_emetric_closed_ball (a : exprℝ) (r : ennreal) : volume (emetric.closed_ball a r) = 2 * r :=\n  by\n  rcases eq_or_ne r (ennreal.top) with (rfl | hr)\n  · rw [emetric.closed_ball_top, volume_univ, two_mul, ennreal.top_add]\n  · lift r to nnreal using hr\n    rw [metric.emetric_closed_ball_nnreal, volume_closed_ball, two_mul, ← nnreal.coe_add, ennreal.of_real_coe_nnreal,\n      ennreal.coe_add, two_mul]\n#align volume_emetric_closed_ball volume_emetric_closed_ball\n\n",
 "volume_emetric_ball":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n@[simp]\ntheorem volume_emetric_ball (a : exprℝ) (r : ennreal) : volume (emetric.ball a r) = 2 * r :=\n  by\n  rcases eq_or_ne r (ennreal.top) with (rfl | hr)\n  · rw [metric.emetric_ball_top, volume_univ, two_mul, ennreal.top_add]\n  · lift r to nnreal using hr\n    rw [metric.emetric_ball_nnreal, volume_ball, two_mul, ← nnreal.coe_add, ennreal.of_real_coe_nnreal, ennreal.coe_add,\n      two_mul]\n#align volume_emetric_ball volume_emetric_ball\n\n",
 "volume_closed_ball":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n@[simp]\ntheorem volume_closed_ball (a r : exprℝ) : volume (metric.closed_ball a r) = of_real (2 * r) := by\n  rw [closed_ball_eq_Icc, volume_Icc, ← sub_add, add_sub_cancel', two_mul]\n#align volume_closed_ball volume_closed_ball\n\n",
 "volume_ball":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n@[simp]\ntheorem volume_ball (a r : exprℝ) : volume (metric.ball a r) = of_real (2 * r) := by\n  rw [ball_eq_Ioo, volume_Ioo, ← sub_add, add_sub_cancel', two_mul]\n#align volume_ball volume_ball\n\n",
 "volume_Ioo":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n@[simp]\ntheorem volume_Ioo {a b : exprℝ} : volume (Ioo a b) = of_real (b - a) := by simp [volume_val]\n#align volume_Ioo volume_Ioo\n\n",
 "volume_Ioi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n@[simp]\ntheorem volume_Ioi {a : exprℝ} : volume (Ioi a) = ennreal.top :=\n  top_unique <|\n    le_of_tendsto' ennreal.tendsto_nat_nhds_top fun n =>\n      calc\n        (n : ennreal) = volume (Ioo a (a + n)) := by simp\n        _ ≤ volume (Ioi a) := measure_mono Ioo_subset_Ioi_self\n        \n#align volume_Ioi volume_Ioi\n\n",
 "volume_Ioc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n@[simp]\ntheorem volume_Ioc {a b : exprℝ} : volume (Ioc a b) = of_real (b - a) := by simp [volume_val]\n#align volume_Ioc volume_Ioc\n\n",
 "volume_Iio":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n@[simp]\ntheorem volume_Iio {a : exprℝ} : volume (Iio a) = ennreal.top :=\n  top_unique <|\n    le_of_tendsto' ennreal.tendsto_nat_nhds_top fun n =>\n      calc\n        (n : ennreal) = volume (Ioo (a - n) a) := by simp\n        _ ≤ volume (Iio a) := measure_mono Ioo_subset_Iio_self\n        \n#align volume_Iio volume_Iio\n\n",
 "volume_Iic":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n@[simp]\ntheorem volume_Iic {a : exprℝ} : volume (Iic a) = ennreal.top := by simp [← measure_congr Iio_ae_eq_Iic]\n#align volume_Iic volume_Iic\n\n",
 "volume_Ico":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n@[simp]\ntheorem volume_Ico {a b : exprℝ} : volume (Ico a b) = of_real (b - a) := by simp [volume_val]\n#align volume_Ico volume_Ico\n\n",
 "volume_Ici":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n@[simp]\ntheorem volume_Ici {a : exprℝ} : volume (Ici a) = ennreal.top := by simp [← measure_congr Ioi_ae_eq_Ici]\n#align volume_Ici volume_Ici\n\n",
 "volume_Icc_pi_to_real":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\n@[simp]\ntheorem volume_Icc_pi_to_real {a b : ι → exprℝ} (h : a ≤ b) :\n    (volume (Icc a b)).to_real =\n      finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n        (b i - a i) :=\n  by simp only [volume_Icc_pi, ennreal.to_real_prod, ennreal.to_real_of_real (sub_nonneg.2 (h _))]\n#align volume_Icc_pi_to_real volume_Icc_pi_to_real\n\n",
 "volume_Icc_pi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\ntheorem volume_Icc_pi {a b : ι → exprℝ} :\n    volume (Icc a b) =\n      finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n        (ennreal.of_real (b i - a i)) :=\n  by\n  rw [← pi_univ_Icc, volume_pi_pi]\n  simp only [real.volume_Icc]\n#align volume_Icc_pi volume_Icc_pi\n\n",
 "volume_Icc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n@[simp]\ntheorem volume_Icc {a b : exprℝ} : volume (Icc a b) = of_real (b - a) := by simp [volume_val]\n#align volume_Icc volume_Icc\n\n",
 "smul_map_volume_mul_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem smul_map_volume_mul_right {a : exprℝ} (h : a ≠ 0) :\n    «expr • » (ennreal.of_real (|a|)) (measure.map (· * a) volume) = volume := by\n  simpa only [mul_comm] using real.smul_map_volume_mul_left h\n#align smul_map_volume_mul_right smul_map_volume_mul_right\n\n",
 "smul_map_volume_mul_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem smul_map_volume_mul_left {a : exprℝ} (h : a ≠ 0) :\n    «expr • » (ennreal.of_real (|a|)) (measure.map ((· * ·) a) volume) = volume :=\n  by\n  refine' (real.measure_ext_Ioo_rat fun p q => _).symm\n  cases' lt_or_gt_of_ne h with h h\n  ·\n    simp only [real.volume_Ioo, measure.smul_apply, ← ennreal.of_real_mul (le_of_lt <| neg_pos.2 h),\n      measure.map_apply (measurable_const_mul a) measurable_set_Ioo, neg_sub_neg, neg_mul,\n      preimage_const_mul_Ioo_of_neg _ _ h, abs_of_neg h, mul_sub, smul_eq_mul, mul_div_cancel' _ (ne_of_lt h)]\n  ·\n    simp only [real.volume_Ioo, measure.smul_apply, ← ennreal.of_real_mul (le_of_lt h),\n      measure.map_apply (measurable_const_mul a) measurable_set_Ioo, preimage_const_mul_Ioo _ _ h, abs_of_pos h,\n      mul_sub, mul_div_cancel' _ (ne_of_gt h), smul_eq_mul]\n#align smul_map_volume_mul_left smul_map_volume_mul_left\n\n",
 "smul_map_diagonal_volume_pi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- A diagonal matrix rescales Lebesgue according to its determinant. This is a special case of\n`real.map_matrix_volume_pi_eq_smul_volume_pi`, that one should use instead (and whose proof\nuses this particular case). -/\ntheorem smul_map_diagonal_volume_pi [decidable_eq ι] {D : ι → exprℝ} (h : det (diagonal D) ≠ 0) :\n    «expr • » (ennreal.of_real (abs (det (diagonal D)))) (measure.map (diagonal D).to_lin' volume) = volume :=\n  by\n  refine' (measure.pi_eq fun s hs => _).symm\n  simp only [det_diagonal, measure.coe_smul, algebra.id.smul_eq_mul, pi.smul_apply]\n  rw [measure.map_apply _ (measurable_set.univ_pi hs)]\n  swap\n  · exact continuous.measurable (linear_map.continuous_on_pi _)\n  have :\n    «expr ⁻¹' » (matrix.to_lin' (diagonal D)) (Set.pi Set.univ fun i : ι => s i) =\n      Set.pi Set.univ fun i : ι => «expr ⁻¹' » ((· * ·) (D i)) (s i) :=\n    by\n    ext f\n    simp only [linear_map.coe_proj, algebra.id.smul_eq_mul, linear_map.smul_apply, mem_univ_pi, mem_preimage,\n      linear_map.pi_apply, diagonal_to_lin']\n  have B : ∀ i, of_real (abs (D i)) * volume («expr ⁻¹' » (has_mul.mul (D i)) (s i)) = volume (s i) :=\n    by\n    intro i\n    have A : D i ≠ 0 := by\n      simp only [det_diagonal, ne.def] at h\n      exact finset.prod_ne_zero_iff.1 h i (finset.mem_univ i)\n    rw [volume_preimage_mul_left A, ← mul_assoc, ← ennreal.of_real_mul (abs_nonneg _), ← abs_mul, mul_inv_cancel A,\n      abs_one, ennreal.of_real_one, one_mul]\n  rw [this, volume_pi_pi, finset.abs_prod, ennreal.of_real_prod_of_nonneg fun i hi => abs_nonneg (D i), ←\n    finset.prod_mul_distrib]\n  simp only [B]\n#align smul_map_diagonal_volume_pi smul_map_diagonal_volume_pi\n\n",
 "region_between_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\ntheorem region_between_subset (f g : α → exprℝ) (s : set α) : region_between f g s ⊆ lower_set.prod s univ := by\n  simpa only [prod_univ, region_between, Set.preimage, set_of_subset_set_of] using fun a => And.left\n#align region_between_subset region_between_subset\n\n",
 "measurable_set_region_between_oc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- The region between two measurable functions on a measurable set is measurable;\na version for the region together with the graph of the upper function. -/\ntheorem measurable_set_region_between_oc (hf : measurable f) (hg : measurable g) (hs : measurable_set s) :\n    measurable_set { p : α × exprℝ | p.fst ∈ s ∧ p.snd ∈ Ioc (f p.fst) (g p.fst) } :=\n  by\n  dsimp only [region_between, Ioc, mem_set_of_eq, set_of_and]\n  refine'\n    measurable_set.inter _\n      ((measurable_set_lt (hf.comp measurable_fst) measurable_snd).inter\n        (measurable_set_le measurable_snd (hg.comp measurable_fst)))\n  exact measurable_fst hs\n#align measurable_set_region_between_oc measurable_set_region_between_oc\n\n",
 "measurable_set_region_between_co":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- The region between two measurable functions on a measurable set is measurable;\na version for the region together with the graph of the lower function. -/\ntheorem measurable_set_region_between_co (hf : measurable f) (hg : measurable g) (hs : measurable_set s) :\n    measurable_set { p : α × exprℝ | p.fst ∈ s ∧ p.snd ∈ Ico (f p.fst) (g p.fst) } :=\n  by\n  dsimp only [region_between, Ico, mem_set_of_eq, set_of_and]\n  refine'\n    measurable_set.inter _\n      ((measurable_set_le (hf.comp measurable_fst) measurable_snd).inter\n        (measurable_set_lt measurable_snd (hg.comp measurable_fst)))\n  exact measurable_fst hs\n#align measurable_set_region_between_co measurable_set_region_between_co\n\n",
 "measurable_set_region_between_cc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- The region between two measurable functions on a measurable set is measurable;\na version for the region together with the graphs of both functions. -/\ntheorem measurable_set_region_between_cc (hf : measurable f) (hg : measurable g) (hs : measurable_set s) :\n    measurable_set { p : α × exprℝ | p.fst ∈ s ∧ p.snd ∈ Icc (f p.fst) (g p.fst) } :=\n  by\n  dsimp only [region_between, Icc, mem_set_of_eq, set_of_and]\n  refine'\n    measurable_set.inter _\n      ((measurable_set_le (hf.comp measurable_fst) measurable_snd).inter\n        (measurable_set_le measurable_snd (hg.comp measurable_fst)))\n  exact measurable_fst hs\n#align measurable_set_region_between_cc measurable_set_region_between_cc\n\n",
 "measurable_set_region_between":
 "/-- The region between two measurable functions on a measurable set is measurable. -/\ntheorem measurable_set_region_between (hf : measurable f) (hg : measurable g) (hs : measurable_set s) :\n    measurable_set (region_between f g s) :=\n  by\n  dsimp only [region_between, Ioo, mem_set_of_eq, set_of_and]\n  refine'\n    measurable_set.inter _\n      ((measurable_set_lt (hf.comp measurable_fst) measurable_snd).inter\n        (measurable_set_lt measurable_snd (hg.comp measurable_fst)))\n  exact measurable_fst hs\n#align measurable_set_region_between measurable_set_region_between\n\n",
 "measurable_set_graph":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- The graph of a measurable function is a measurable set. -/\ntheorem measurable_set_graph (hf : measurable f) : measurable_set { p : α × exprℝ | p.snd = f p.fst } := by\n  simpa using measurable_set_region_between_cc hf hf measurable_set.univ\n#align measurable_set_graph measurable_set_graph\n\n",
 "map_volume_mul_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem map_volume_mul_right {a : exprℝ} (h : a ≠ 0) :\n    measure.map (· * a) volume = «expr • » (ennreal.of_real (|a⁻¹|)) volume := by\n  simpa only [mul_comm] using real.map_volume_mul_left h\n#align map_volume_mul_right map_volume_mul_right\n\n",
 "map_volume_mul_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem map_volume_mul_left {a : exprℝ} (h : a ≠ 0) :\n    measure.map ((· * ·) a) volume = «expr • » (ennreal.of_real (|a⁻¹|)) volume := by\n  conv_rhs =>\n    rw [← real.smul_map_volume_mul_left h, smul_smul, ← ennreal.of_real_mul (abs_nonneg _), ← abs_mul, inv_mul_cancel h,\n      abs_one, ennreal.of_real_one, one_smul]\n#align map_volume_mul_left map_volume_mul_left\n\n",
 "map_matrix_volume_pi_eq_smul_volume_pi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- Any invertible matrix rescales Lebesgue measure through the absolute value of its\ndeterminant. -/\ntheorem map_matrix_volume_pi_eq_smul_volume_pi [decidable_eq ι] {M : matrix ι ι (exprℝ)} (hM : det M ≠ 0) :\n    measure.map M.to_lin' volume = «expr • » (ennreal.of_real (abs (det M)⁻¹)) volume :=\n  by\n  -- This follows from the cases we have already proved, of diagonal matrices and transvections,\n  -- as these matrices generate all invertible matrices.\n  apply diagonal_transvection_induction_of_det_ne_zero _ M hM (fun D hD => _) (fun t => _) fun A B hA hB IHA IHB => _\n  · conv_rhs => rw [← smul_map_diagonal_volume_pi hD]\n    rw [smul_smul, ← ennreal.of_real_mul (abs_nonneg _), ← abs_mul, inv_mul_cancel hD, abs_one, ennreal.of_real_one,\n      one_smul]\n  ·\n    simp only [matrix.transvection_struct.det, ennreal.of_real_one, (volume_preserving_transvection_struct _).map_eq,\n      one_smul, _root_.inv_one, abs_one]\n  · rw [to_lin'_mul, det_mul, linear_map.coe_comp, ← measure.map_map, IHB, measure.map_smul, IHA, smul_smul, ←\n      ennreal.of_real_mul (abs_nonneg _), ← abs_mul, mul_comm, mul_inv]\n    · apply continuous.measurable\n      apply linear_map.continuous_on_pi\n    · apply continuous.measurable\n      apply linear_map.continuous_on_pi\n#align map_matrix_volume_pi_eq_smul_volume_pi map_matrix_volume_pi_eq_smul_volume_pi\n\n",
 "map_linear_map_volume_pi_eq_smul_volume_pi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- Any invertible linear map rescales Lebesgue measure through the absolute value of its\ndeterminant. -/\ntheorem map_linear_map_volume_pi_eq_smul_volume_pi {f : «expr →ₗ[ ] » (ι → exprℝ) (exprℝ) (ι → exprℝ)}\n    (hf : f.det ≠ 0) : measure.map f volume = «expr • » (ennreal.of_real (abs f.det⁻¹)) volume := by\n  classical\n    -- this is deduced from the matrix case\n    let M := f.to_matrix'\n    have A : f.det = det M := by simp only [linear_map.det_to_matrix']\n    have B : f = M.to_lin' := by simp only [to_lin'_to_matrix']\n    rw [A, B]\n    apply map_matrix_volume_pi_eq_smul_volume_pi\n    rwa [A] at hf\n#align map_linear_map_volume_pi_eq_smul_volume_pi map_linear_map_volume_pi_eq_smul_volume_pi\n\n",
 "ae_restrict_of_ae_restrict_inter_Ioo":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\n/-- Consider a real set `s`. If a property is true almost everywhere in `s ∩ (a, b)` for\nall `a, b ∈ s`, then it is true almost everywhere in `s`. Formulated with `μ.restrict`.\nSee also `ae_of_mem_of_ae_of_mem_inter_Ioo`. -/\ntheorem ae_restrict_of_ae_restrict_inter_Ioo {μ : measure (exprℝ)} [has_no_atoms μ] {s : set (exprℝ)} {p : exprℝ → Prop}\n    (h :\n      ∀ a b,\n        a ∈ s →\n          b ∈ s →\n            a < b →\n              «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\"\n                (μ.restrict (s ∩ Ioo a b)) (p x)) :\n    «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\" (μ.restrict s)\n      (p x) :=\n  by\n  /- By second-countability, we cover `s` by countably many intervals `(a, b)` (except maybe for\n    two endpoints, which don't matter since `μ` does not have any atom). -/\n  let T : s × s → set (exprℝ) := fun p => Ioo p.1 p.2\n  let u := «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (T i)\n  have hfinite : (s \\ u).finite :=\n    by\n    refine' set.finite_of_forall_between_eq_endpoints (s \\ u) fun x hx y hy z hz hxy hyz => _\n    by_contra' h\n    apply hy.2\n    exact mem_Union_of_mem (⟨x, hx.1⟩, ⟨z, hz.1⟩) ⟨lt_of_le_of_ne hxy h.1, lt_of_le_of_ne hyz h.2⟩\n  obtain ⟨A, A_count, hA⟩ :\n    ∃ A : set («expr↥ » s × «expr↥ » s),\n      A.countable ∧\n        «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (T i) =\n          «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (T i) :=\n    is_open_Union_countable _ fun p => is_open_Ioo\n  have :\n    s ⊆\n      s \\ u ∪\n        «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (s ∩ T p) :=\n    by\n    intro x hx\n    by_cases h'x :\n      x ∈ «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (T i)\n    · rw [← hA] at h'x\n      obtain ⟨p, pA, xp⟩ : ∃ p : «expr↥ » s × «expr↥ » s, p ∈ A ∧ x ∈ T p := by\n        simpa only [mem_Union, exists_prop, SetCoe.exists, exists_and_right] using h'x\n      right\n      exact mem_bUnion pA ⟨hx, xp⟩\n    · exact or.inl ⟨hx, h'x⟩\n  apply ae_restrict_of_ae_restrict_of_subset this\n  rw [ae_restrict_union_iff, ae_restrict_bUnion_iff _ A_count]\n  constructor\n  · have : μ.restrict (s \\ u) = 0 := by simp only [restrict_eq_zero, hfinite.measure_zero]\n    simp only [this, ae_zero]\n  · rintro ⟨⟨a, as⟩, ⟨b, bs⟩⟩ -\n    dsimp [T]\n    rcases le_or_lt b a with (hba | hab)\n    · simp only [Ioo_eq_empty_of_le hba, inter_empty, restrict_empty, ae_zero]\n    · exact h a b as bs hab\n#align ae_restrict_of_ae_restrict_inter_Ioo ae_restrict_of_ae_restrict_inter_Ioo\n\n",
 "ae_of_mem_of_ae_of_mem_inter_Ioo":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\n/-- Consider a real set `s`. If a property is true almost everywhere in `s ∩ (a, b)` for\nall `a, b ∈ s`, then it is true almost everywhere in `s`. Formulated with bare membership.\nSee also `ae_restrict_of_ae_restrict_inter_Ioo`. -/\ntheorem ae_of_mem_of_ae_of_mem_inter_Ioo {μ : measure (exprℝ)} [has_no_atoms μ] {s : set (exprℝ)} {p : exprℝ → Prop}\n    (h :\n      ∀ a b,\n        a ∈ s →\n          b ∈ s →\n            a < b →\n              «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\" μ\n                (x ∈ s ∩ Ioo a b → p x)) :\n    «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\" μ\n      (x ∈ s → p x) :=\n  by\n  /- By second-countability, we cover `s` by countably many intervals `(a, b)` (except maybe for\n    two endpoints, which don't matter since `μ` does not have any atom). -/\n  let T : s × s → set (exprℝ) := fun p => Ioo p.1 p.2\n  let u := «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (T i)\n  have hfinite : (s \\ u).finite :=\n    by\n    refine' set.finite_of_forall_between_eq_endpoints (s \\ u) fun x hx y hy z hz hxy hyz => _\n    by_contra' h\n    apply hy.2\n    exact mem_Union_of_mem (⟨x, hx.1⟩, ⟨z, hz.1⟩) ⟨lt_of_le_of_ne hxy h.1, lt_of_le_of_ne hyz h.2⟩\n  obtain ⟨A, A_count, hA⟩ :\n    ∃ A : set («expr↥ » s × «expr↥ » s),\n      A.countable ∧\n        «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (T i) =\n          «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (T i) :=\n    is_open_Union_countable _ fun p => is_open_Ioo\n  have M :\n    «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\" μ\n      (x ∉ s \\ u) :=\n    hfinite.countable.ae_not_mem _\n  have M' :\n    «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\" μ\n      (∀ (i : «expr↥ » s × «expr↥ » s) (H : i ∈ A), x ∈ s ∩ T i → p x) :=\n    by\n    rw [ae_ball_iff A_count]\n    rintro ⟨⟨a, as⟩, ⟨b, bs⟩⟩ -\n    change\n      «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\" μ\n        (x ∈ s ∩ Ioo a b → p x)\n    rcases le_or_lt b a with (hba | hab)\n    · simp only [Ioo_eq_empty_of_le hba, inter_empty, is_empty.forall_iff, eventually_true, mem_empty_iff_false]\n    · exact h a b as bs hab\n  filter_upwards [M, M'] with x hx h'x\n  intro xs\n  by_cases Hx :\n    x ∈ «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (T i)\n  · rw [← hA] at Hx\n    obtain ⟨p, pA, xp⟩ : ∃ p : «expr↥ » s × «expr↥ » s, p ∈ A ∧ x ∈ T p := by\n      simpa only [mem_Union, exists_prop, SetCoe.exists, exists_and_right] using Hx\n    apply h'x p pA ⟨xs, xp⟩\n  · exact false.elim (hx ⟨xs, Hx⟩)\n#align ae_of_mem_of_ae_of_mem_inter_Ioo ae_of_mem_of_ae_of_mem_inter_Ioo\n\n"}