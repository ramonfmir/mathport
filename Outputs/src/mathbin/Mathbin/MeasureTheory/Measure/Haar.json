{"zpow":
 "@[to_additive]\ntheorem measure_preserving.zpow [CompactSpace G] [RootableBy G ℤ] {n : ℤ} (hn : n ≠ 0) {X : Type _} [MeasurableSpace X]\n    {μ' : Measure X} {f : X → G} (hf : MeasurePreserving f μ' μ) : MeasurePreserving (fun x => f x ^ n) μ' μ :=\n  (measure_preserving_zpow μ hn).comp hf\n#align measure_preserving.zpow measure_preserving.zpow\n\n",
 "regular_of_is_mul_left_invariant":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/-- To show that an invariant σ-finite measure is regular it is sufficient to show that it is finite\n  on some compact set with non-empty interior. -/\n@[to_additive\n      \"To show that an invariant σ-finite measure is regular it is sufficient to show that\\nit is finite on some compact set with non-empty interior.\"]\ntheorem regular_of_is_mul_left_invariant {μ : Measure G} [SigmaFinite μ] [is_mul_left_invariant μ] {K : Set G}\n    (hK : IsCompact K) (h2K : (interior K).nonempty) (hμK : μ K ≠ ennreal.top) : regular μ :=\n  by\n  rw [haar_measure_unique μ ⟨⟨K, hK⟩, h2K⟩]\n  exact regular.smul hμK\n#align regular_of_is_mul_left_invariant regular_of_is_mul_left_invariant\n\n",
 "prehaar_sup_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n@[to_additive]\ntheorem prehaar_sup_le {K₀ : PositiveCompacts G} {U : Set G} (K₁ K₂ : Compacts G) (hU : (interior U).nonempty) :\n    prehaar (K₀ : Set G) U («expr ⊔ » K₁ K₂) ≤ prehaar (K₀ : Set G) U K₁ + prehaar (K₀ : Set G) U K₂ :=\n  by\n  simp only [prehaar]; rw [div_add_div_same, div_le_div_right]\n  exact_mod_cast index_union_le K₁ K₂ hU; exact_mod_cast index_pos K₀ hU\n#align prehaar_sup_le prehaar_sup_le\n\n",
 "prehaar_sup_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n@[to_additive]\ntheorem prehaar_sup_eq {K₀ : PositiveCompacts G} {U : Set G} {K₁ K₂ : Compacts G} (hU : (interior U).nonempty)\n    (h : Disjoint (K₁.1 * U⁻¹) (K₂.1 * U⁻¹)) :\n    prehaar (K₀ : Set G) U («expr ⊔ » K₁ K₂) = prehaar (K₀ : Set G) U K₁ + prehaar (K₀ : Set G) U K₂ :=\n  by\n  simp only [prehaar]\n  rw [div_add_div_same]\n  congr\n  exact_mod_cast index_union_eq K₁ K₂ hU h\n#align prehaar_sup_eq prehaar_sup_eq\n\n",
 "prehaar_self":
 "@[to_additive]\ntheorem prehaar_self {K₀ : PositiveCompacts G} {U : Set G} (hU : (interior U).nonempty) :\n    prehaar (K₀ : Set G) U K₀.to_compacts = 1 :=\n  div_self <| ne_of_gt <| by exact_mod_cast index_pos K₀ hU\n#align prehaar_self prehaar_self\n\n",
 "prehaar_pos":
 "@[to_additive]\ntheorem prehaar_pos (K₀ : PositiveCompacts G) {U : Set G} (hU : (interior U).nonempty) {K : Set G} (h1K : IsCompact K)\n    (h2K : (interior K).nonempty) : 0 < prehaar (K₀ : Set G) U ⟨K, h1K⟩ :=\n  by\n  apply div_pos <;> norm_cast\n  apply index_pos ⟨⟨K, h1K⟩, h2K⟩ hU\n  exact index_pos K₀ hU\n#align prehaar_pos prehaar_pos\n\n",
 "prehaar_nonneg":
 "@[to_additive]\ntheorem prehaar_nonneg (K₀ : PositiveCompacts G) {U : Set G} (K : Compacts G) : 0 ≤ prehaar (K₀ : Set G) U K := by\n  apply div_nonneg <;> norm_cast <;> apply zero_le\n#align prehaar_nonneg prehaar_nonneg\n\n",
 "prehaar_mono":
 "@[to_additive]\ntheorem prehaar_mono {K₀ : PositiveCompacts G} {U : Set G} (hU : (interior U).nonempty) {K₁ K₂ : Compacts G}\n    (h : (K₁ : Set G) ⊆ K₂.1) : prehaar (K₀ : Set G) U K₁ ≤ prehaar (K₀ : Set G) U K₂ :=\n  by\n  simp only [prehaar]; rw [div_le_div_right]; exact_mod_cast index_mono K₂.2 h hU\n  exact_mod_cast index_pos K₀ hU\n#align prehaar_mono prehaar_mono\n\n",
 "prehaar_mem_haar_product":
 "@[to_additive]\ntheorem prehaar_mem_haar_product (K₀ : PositiveCompacts G) {U : Set G} (hU : (interior U).nonempty) :\n    prehaar (K₀ : Set G) U ∈ haar_product (K₀ : Set G) :=\n  by\n  rintro ⟨K, hK⟩ h2K\n  rw [mem_Icc]\n  exact ⟨prehaar_nonneg K₀ _, prehaar_le_index K₀ _ hU⟩\n#align prehaar_mem_haar_product prehaar_mem_haar_product\n\n",
 "prehaar_le_index":
 "@[to_additive add_prehaar_le_add_index]\ntheorem prehaar_le_index (K₀ : PositiveCompacts G) {U : Set G} (K : Compacts G) (hU : (interior U).nonempty) :\n    prehaar (K₀ : Set G) U K ≤ index (K : Set G) K₀ :=\n  by\n  unfold prehaar; rw [div_le_iff] <;> norm_cast\n  · apply le_index_mul K₀ K hU\n  · exact index_pos K₀ hU\n#align prehaar_le_index prehaar_le_index\n\n",
 "prehaar_empty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[to_additive]\ntheorem prehaar_empty (K₀ : PositiveCompacts G) {U : Set G} : prehaar (K₀ : Set G) U («expr⊥») = 0 := by\n  rw [prehaar, compacts.coe_bot, index_empty, Nat.cast_zero, zero_div]\n#align prehaar_empty prehaar_empty\n\n",
 "nonempty_Inter_cl_prehaar":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n@[to_additive]\ntheorem nonempty_Inter_cl_prehaar (K₀ : PositiveCompacts G) :\n    (haar_product (K₀ : Set G) ∩\n        «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\"\n          (cl_prehaar K₀ V)).nonempty :=\n  by\n  have : IsCompact (haar_product (K₀ : Set G)) :=\n    by\n    apply isCompact_univ_pi\n    intro K\n    apply is_compact_Icc\n  refine' this.inter_Inter_nonempty (cl_prehaar K₀) (fun s => isClosed_closure) fun t => _\n  let V₀ :=\n    «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\"\n      (V : open_nhds_of 1).carrier\n  have h1V₀ : IsOpen V₀ := by\n    apply isOpen_binterᵢ\n    apply Finset.finite_toSet\n    rintro ⟨⟨V, hV₁⟩, hV₂⟩ h2V\n    exact hV₁\n  have h2V₀ : (1 : G) ∈ V₀ := by\n    simp only [mem_Inter]\n    rintro ⟨⟨V, hV₁⟩, hV₂⟩ h2V\n    exact hV₂\n  refine' ⟨prehaar K₀ V₀, _⟩\n  constructor\n  · apply prehaar_mem_haar_product K₀\n    use 1\n    rwa [h1V₀.interior_eq]\n  · simp only [mem_Inter]\n    rintro ⟨V, hV⟩ h2V\n    apply subset_closure\n    apply mem_image_of_mem\n    rw [mem_set_of_eq]\n    exact ⟨subset.trans (Inter_subset _ ⟨V, hV⟩) (Inter_subset _ h2V), h1V₀, h2V₀⟩\n#align nonempty_Inter_cl_prehaar nonempty_Inter_cl_prehaar\n\n",
 "mul_left_index_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n@[to_additive add_left_add_index_le]\ntheorem mul_left_index_le {K : Set G} (hK : IsCompact K) {V : Set G} (hV : (interior V).nonempty) (g : G) :\n    index («expr '' » (fun h => g * h) K) V ≤ index K V :=\n  by\n  rcases index_elim hK hV with ⟨s, h1s, h2s⟩; rw [← h2s]\n  apply Nat.infₛ_le; rw [mem_image]\n  refine' ⟨s.map (Equiv.mulRight g⁻¹).to_embedding, _, Finset.card_map _⟩\n  · simp only [mem_set_of_eq]\n    refine' subset.trans (image_subset _ h1s) _\n    rintro _ ⟨g₁, ⟨_, ⟨g₂, rfl⟩, ⟨_, ⟨hg₂, rfl⟩, hg₁⟩⟩, rfl⟩\n    simp only [mem_preimage] at hg₁\n    simp only [exists_prop, mem_Union, Finset.mem_map, Equiv.coe_mulRight, exists_exists_and_eq_and, mem_preimage,\n      Equiv.toEmbedding_apply]\n    refine' ⟨_, hg₂, _⟩\n    simp only [mul_assoc, hg₁, inv_mul_cancel_left]\n#align mul_left_index_le mul_left_index_le\n\n",
 "mem_prehaar_empty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n@[simp, to_additive]\ntheorem mem_prehaar_empty {K₀ : Set G} {f : Compacts G → exprℝ} :\n    f ∈ haar_product K₀ ↔ ∀ K : Compacts G, f K ∈ Icc (0 : exprℝ) (index (K : Set G) K₀) := by\n  simp only [haar_product, pi, forall_prop_of_true, mem_univ, mem_set_of_eq]\n#align mem_prehaar_empty mem_prehaar_empty\n\n",
 "measure_preserving_zpow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n-- the image measure is a Haar measure. By uniqueness up to multiplication, it is of the form\n-- `c μ`. Applying again inversion, one gets the measure `c^2 μ`. But since inversion is an\n-- involution, this is also `μ`. Hence, `c^2 = 1`, which implies `c = 1`.\n@[to_additive]\ntheorem measure_preserving_zpow [CompactSpace G] [RootableBy G ℤ] {n : ℤ} (hn : n ≠ 0) :\n    MeasurePreserving (fun g : G => g ^ n) μ μ :=\n  { measurable := (continuous_zpow n).measurable\n    map_eq := by\n      let f := @zpowGroupHom G _ n\n      have hf : Continuous f := continuous_zpow n\n      haveI : (μ.map f).is_haar_measure := is_haar_measure_map μ f hf (RootableBy.surjective_pow G ℤ hn) (by simp)\n      obtain ⟨C, -, -, hC⟩ := is_haar_measure_eq_smul_is_haar_measure (μ.map f) μ\n      suffices C = 1 by rwa [this, one_smul] at hC\n      have h_univ : (μ.map f) univ = μ univ := by\n        rw [map_apply_of_ae_measurable hf.measurable.ae_measurable MeasurableSet.univ, preimage_univ]\n      have hμ₀ : μ univ ≠ 0 := is_open_pos_measure.open_pos univ isOpen_univ univ_nonempty\n      have hμ₁ : μ univ ≠ ennreal.top := compact_space.is_finite_measure.measure_univ_lt_top.ne\n      rwa [hC, smul_apply, Algebra.id.smul_eq_mul, mul_comm, ← ENNReal.eq_div_iff hμ₀ hμ₁, ENNReal.div_self hμ₀ hμ₁] at\n        h_univ }\n#align measure_preserving_zpow measure_preserving_zpow\n\n",
 "le_index_mul":
 "@[to_additive le_add_index_mul]\ntheorem le_index_mul (K₀ : PositiveCompacts G) (K : Compacts G) {V : Set G} (hV : (interior V).nonempty) :\n    index (K : Set G) V ≤ index (K : Set G) K₀ * index (K₀ : Set G) V :=\n  by\n  obtain ⟨s, h1s, h2s⟩ := index_elim K.is_compact K₀.interior_nonempty\n  obtain ⟨t, h1t, h2t⟩ := index_elim K₀.is_compact hV\n  rw [← h2s, ← h2t, mul_comm]\n  refine' le_trans _ Finset.card_mul_le\n  apply Nat.infₛ_le; refine' ⟨_, _, rfl⟩; rw [mem_set_of_eq]; refine' subset.trans h1s _\n  apply Union₂_subset; intro g₁ hg₁; rw [preimage_subset_iff]; intro g₂ hg₂\n  have := h1t hg₂\n  rcases this with ⟨_, ⟨g₃, rfl⟩, A, ⟨hg₃, rfl⟩, h2V⟩; rw [mem_preimage, ← mul_assoc] at h2V\n  exact mem_bUnion (Finset.mul_mem_mul hg₃ hg₁) h2V\n#align le_index_mul le_index_mul\n\n",
 "is_left_invariant_prehaar":
 "@[to_additive]\ntheorem is_left_invariant_prehaar {K₀ : PositiveCompacts G} {U : Set G} (hU : (interior U).nonempty) (g : G)\n    (K : Compacts G) : prehaar (K₀ : Set G) U (K.map _ <| continuous_mul_left g) = prehaar (K₀ : Set G) U K := by\n  simp only [prehaar, compacts.coe_map, is_left_invariant_index K.is_compact _ hU]\n#align is_left_invariant_prehaar is_left_invariant_prehaar\n\n",
 "is_left_invariant_index":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n@[to_additive is_left_invariant_add_index]\ntheorem is_left_invariant_index {K : Set G} (hK : IsCompact K) (g : G) {V : Set G} (hV : (interior V).nonempty) :\n    index («expr '' » (fun h => g * h) K) V = index K V :=\n  by\n  refine' le_antisymm (mul_left_index_le hK hV g) _\n  convert mul_left_index_le (hK.image <| continuous_mul_left g) hV g⁻¹\n  rw [image_image]; symm; convert image_id' _; ext h; apply inv_mul_cancel_left\n#align is_left_invariant_index is_left_invariant_index\n\n",
 "is_left_invariant_haar_content":
 "/-- The variant of `is_left_invariant_chaar` for `haar_content` -/\n@[to_additive \"The variant of `is_left_invariant_add_chaar` for `add_haar_content`\"]\ntheorem is_left_invariant_haar_content {K₀ : PositiveCompacts G} (g : G) (K : Compacts G) :\n    haar_content K₀ (K.map _ <| continuous_mul_left g) = haar_content K₀ K := by\n  simpa only [ENNReal.coe_eq_coe, ← NNReal.coe_eq, haar_content_apply] using is_left_invariant_chaar g K\n#align is_left_invariant_haar_content is_left_invariant_haar_content\n\n",
 "is_left_invariant_chaar":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[to_additive is_left_invariant_add_chaar]\ntheorem is_left_invariant_chaar {K₀ : PositiveCompacts G} (g : G) (K : Compacts G) :\n    chaar K₀ (K.map _ <| continuous_mul_left g) = chaar K₀ K :=\n  by\n  let eval : (compacts G → exprℝ) → exprℝ := fun f => f (K.map _ <| continuous_mul_left g) - f K\n  have : Continuous eval := (continuous_apply (K.map _ _)).sub (continuous_apply K)\n  rw [← sub_eq_zero]; show chaar K₀ ∈ «expr ⁻¹' » eval {(0 : exprℝ)}\n  apply mem_of_subset_of_mem _ (chaar_mem_cl_prehaar K₀ («expr⊤»))\n  unfold cl_prehaar; rw [IsClosed.closure_subset_iff]\n  · rintro _ ⟨U, ⟨h1U, h2U, h3U⟩, rfl⟩\n    simp only [mem_singleton_iff, mem_preimage, eval, sub_eq_zero]\n    apply is_left_invariant_prehaar\n    rw [h2U.interior_eq]\n    exact ⟨1, h3U⟩\n  · apply continuous_iff_is_closed.mp this\n    exact isClosed_singleton\n#align is_left_invariant_chaar is_left_invariant_chaar\n\n",
 "is_haar_measure_eq_smul_is_haar_measure":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[to_additive is_add_haar_measure_eq_smul_is_add_haar_measure]\ntheorem is_haar_measure_eq_smul_is_haar_measure [LocallyCompactSpace G] (μ ν : Measure G) [is_haar_measure μ]\n    [is_haar_measure ν] : ∃ c : ennreal, c ≠ 0 ∧ c ≠ ennreal.top ∧ μ = «expr • » c ν :=\n  by\n  have K : positive_compacts G := Classical.arbitrary _\n  have νpos : 0 < ν K := measure_pos_of_nonempty_interior _ K.interior_nonempty\n  have νne : ν K ≠ ennreal.top := K.is_compact.measure_lt_top.ne\n  refine' ⟨μ K / ν K, _, _, _⟩\n  ·\n    simp only [νne, (μ.measure_pos_of_nonempty_interior K.interior_nonempty).ne', ne.def, ENNReal.div_eq_zero_iff,\n      not_false_iff, or_self_iff]\n  ·\n    simp only [div_eq_mul_inv, νpos.ne', K.is_compact.measure_lt_top.ne, or_self_iff, ENNReal.inv_eq_top,\n      WithTop.mul_eq_top_iff, ne.def, not_false_iff, and_false_iff, false_and_iff]\n  ·\n    calc\n      μ = «expr • » (μ K) (haar_measure K) := haar_measure_unique μ K\n      _ = «expr • » (μ K / ν K) («expr • » (ν K) (haar_measure K)) := by\n        rw [smul_smul, div_eq_mul_inv, mul_assoc, ENNReal.inv_mul_cancel νpos.ne' νne, mul_one]\n      _ = «expr • » (μ K / ν K) ν := by rw [← haar_measure_unique ν K]\n      \n#align is_haar_measure_eq_smul_is_haar_measure is_haar_measure_eq_smul_is_haar_measure\n\n",
 "index_union_le":
 "@[to_additive add_index_union_le]\ntheorem index_union_le (K₁ K₂ : Compacts G) {V : Set G} (hV : (interior V).nonempty) :\n    index (K₁.1 ∪ K₂.1) V ≤ index K₁.1 V + index K₂.1 V :=\n  by\n  rcases index_elim K₁.2 hV with ⟨s, h1s, h2s⟩\n  rcases index_elim K₂.2 hV with ⟨t, h1t, h2t⟩\n  rw [← h2s, ← h2t]\n  refine' le_trans _ (Finset.card_union_le _ _)\n  apply Nat.infₛ_le; refine' ⟨_, _, rfl⟩; rw [mem_set_of_eq]\n  apply union_subset <;> refine' subset.trans (by assumption) _ <;> apply bUnion_subset_bUnion_left <;> intro g hg <;>\n      simp only [mem_def] at hg <;>\n    simp only [mem_def, Multiset.mem_union, Finset.union_val, hg, or_true_iff, true_or_iff]\n#align index_union_le index_union_le\n\n",
 "index_union_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n@[to_additive add_index_union_eq]\ntheorem index_union_eq (K₁ K₂ : Compacts G) {V : Set G} (hV : (interior V).nonempty)\n    (h : Disjoint (K₁.1 * V⁻¹) (K₂.1 * V⁻¹)) : index (K₁.1 ∪ K₂.1) V = index K₁.1 V + index K₂.1 V :=\n  by\n  apply le_antisymm (index_union_le K₁ K₂ hV)\n  rcases index_elim (K₁.2.union K₂.2) hV with ⟨s, h1s, h2s⟩\n  rw [← h2s]\n  have :\n    ∀ K : Set G,\n      K ⊆\n          «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n            («expr ⁻¹' » (fun h => g * h) V) →\n        index K V ≤ (s.filter fun g => («expr ⁻¹' » (fun h : G => g * h) V ∩ K).nonempty).card :=\n    by\n    intro K hK\n    apply Nat.infₛ_le\n    refine' ⟨_, _, rfl⟩\n    rw [mem_set_of_eq]\n    intro g hg\n    rcases hK hg with ⟨_, ⟨g₀, rfl⟩, _, ⟨h1g₀, rfl⟩, h2g₀⟩\n    simp only [mem_preimage] at h2g₀\n    simp only [mem_Union]\n    use g₀\n    constructor\n    · simp only [Finset.mem_filter, h1g₀, true_and_iff]\n      use g\n      simp only [hg, h2g₀, mem_inter_iff, mem_preimage, and_self_iff]\n    exact h2g₀\n  refine'\n    le_trans\n      (add_le_add (this K₁.1 <| subset.trans (subset_union_left _ _) h1s)\n        (this K₂.1 <| subset.trans (subset_union_right _ _) h1s))\n      _\n  rw [← Finset.card_union_eq, Finset.filter_union_right]\n  exact s.card_filter_le _\n  apply finset.disjoint_filter.mpr\n  rintro g₁ h1g₁ ⟨g₂, h1g₂, h2g₂⟩ ⟨g₃, h1g₃, h2g₃⟩\n  simp only [mem_preimage] at h1g₃ h1g₂\n  refine' h.le_bot (_ : g₁⁻¹ ∈ _)\n  constructor <;> simp only [Set.mem_inv, Set.mem_mul, exists_exists_and_eq_and, exists_and_left]\n  · refine' ⟨_, h2g₂, (g₁ * g₂)⁻¹, _, _⟩\n    simp only [inv_inv, h1g₂]\n    simp only [mul_inv_rev, mul_inv_cancel_left]\n  · refine' ⟨_, h2g₃, (g₁ * g₃)⁻¹, _, _⟩\n    simp only [inv_inv, h1g₃]\n    simp only [mul_inv_rev, mul_inv_cancel_left]\n#align index_union_eq index_union_eq\n\n",
 "index_pos":
 "@[to_additive add_index_pos]\ntheorem index_pos (K : PositiveCompacts G) {V : Set G} (hV : (interior V).nonempty) : 0 < index (K : Set G) V :=\n  by\n  unfold index; rw [Nat.infₛ_def, Nat.find_pos, mem_image]\n  · rintro ⟨t, h1t, h2t⟩\n    rw [Finset.card_eq_zero] at h2t\n    subst h2t\n    obtain ⟨g, hg⟩ := K.interior_nonempty\n    show g ∈ (∅ : Set G)\n    convert h1t (interior_subset hg)\n    symm\n    apply bUnion_empty\n  · exact index_defined K.is_compact hV\n#align index_pos index_pos\n\n",
 "index_mono":
 "@[to_additive add_index_mono]\ntheorem index_mono {K K' V : Set G} (hK' : IsCompact K') (h : K ⊆ K') (hV : (interior V).nonempty) :\n    index K V ≤ index K' V := by\n  rcases index_elim hK' hV with ⟨s, h1s, h2s⟩\n  apply Nat.infₛ_le; rw [mem_image]; refine' ⟨s, subset.trans h h1s, h2s⟩\n#align index_mono index_mono\n\n",
 "index_empty":
 "/-\nCopyright (c) 2020 Floris van Doorn. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Floris van Doorn\n-/\n@[to_additive add_index_empty]\ntheorem index_empty {V : Set G} : index ∅ V = 0 :=\n  by\n  simp only [index, Nat.infₛ_eq_zero]; left; use ∅\n  simp only [Finset.card_empty, empty_subset, mem_set_of_eq, eq_self_iff_true, and_self_iff]\n#align index_empty index_empty\n\n",
 "index_elim":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n@[to_additive add_index_elim]\ntheorem index_elim {K V : Set G} (hK : IsCompact K) (hV : (interior V).nonempty) :\n    ∃ t : Finset G,\n      K ⊆\n          «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n            («expr ⁻¹' » (fun h => g * h) V) ∧\n        Finset.card t = index K V :=\n  by\n  have := Nat.infₛ_mem (index_defined hK hV)\n  rwa [mem_image] at this\n#align index_elim index_elim\n\n",
 "index_defined":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/-- If `K` is compact and `V` has nonempty interior, then the index `(K : V)` is well-defined,\n  there is a finite set `t` satisfying the desired properties. -/\n@[to_additive add_index_defined\n      \"If `K` is compact and `V` has nonempty interior, then the index\\n`(K : V)` is well-defined, there is a finite set `t` satisfying the desired properties.\"]\ntheorem index_defined {K V : Set G} (hK : IsCompact K) (hV : (interior V).nonempty) :\n    ∃ n : ℕ,\n      n ∈\n        «expr '' » Finset.card\n          { t : Finset G |\n            K ⊆\n              «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n                («expr ⁻¹' » (fun h => g * h) V) } :=\n  by\n  rcases compact_covered_by_mul_left_translates hK hV with ⟨t, ht⟩\n  exact ⟨t.card, t, ht, rfl⟩\n#align index_defined index_defined\n\n",
 "haar_measure_unique":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- The Haar measure is unique up to scaling. More precisely: every σ-finite left invariant measure\n  is a scalar multiple of the Haar measure.\n  This is slightly weaker than assuming that `μ` is a Haar measure (in particular we don't require\n  `μ ≠ 0`). -/\n@[to_additive\n      \"The additive Haar measure is unique up to scaling. More precisely: every σ-finite\\nleft invariant measure is a scalar multiple of the additive Haar measure. This is slightly weaker\\nthan assuming that `μ` is an additive Haar measure (in particular we don't require `μ ≠ 0`).\"]\ntheorem haar_measure_unique (μ : Measure G) [SigmaFinite μ] [is_mul_left_invariant μ] (K₀ : PositiveCompacts G) :\n    μ = «expr • » (μ K₀) (haar_measure K₀) :=\n  (measure_eq_div_smul μ (haar_measure K₀) K₀.is_compact.measurable_set\n        (measure_pos_of_nonempty_interior _ K₀.interior_nonempty).ne' K₀.is_compact.measure_lt_top.ne).trans\n    (by rw [haar_measure_self, div_one])\n#align haar_measure_unique haar_measure_unique\n\n",
 "haar_measure_self":
 "@[to_additive]\ntheorem haar_measure_self {K₀ : PositiveCompacts G} : haar_measure K₀ K₀ = 1 :=\n  by\n  haveI : LocallyCompactSpace G := K₀.locally_compact_space_of_group\n  rw [haar_measure_apply K₀.is_compact.measurable_set, ENNReal.div_self]\n  · rw [← pos_iff_ne_zero]\n    exact haar_content_outer_measure_self_pos\n  · exact (content.outer_measure_lt_top_of_is_compact _ K₀.is_compact).ne\n#align haar_measure_self haar_measure_self\n\n",
 "haar_measure_apply":
 "@[to_additive]\ntheorem haar_measure_apply {K₀ : PositiveCompacts G} {s : Set G} (hs : MeasurableSet s) :\n    haar_measure K₀ s = (haar_content K₀).outer_measure s / (haar_content K₀).outer_measure K₀ :=\n  by\n  change ((haar_content K₀).outer_measure K₀)⁻¹ * (haar_content K₀).measure s = _\n  simp only [hs, div_eq_mul_inv, mul_comm, content.measure_apply]\n#align haar_measure_apply haar_measure_apply\n\n",
 "haar_content_self":
 "/-- The variant of `chaar_self` for `haar_content` -/\n@[to_additive \"The variant of `add_chaar_self` for `add_haar_content`.\"]\ntheorem haar_content_self {K₀ : PositiveCompacts G} : haar_content K₀ K₀.to_compacts = 1 :=\n  by\n  simp_rw [← ENNReal.coe_one, haar_content_apply, ENNReal.coe_eq_coe, chaar_self]\n  rfl\n#align haar_content_self haar_content_self\n\n",
 "haar_content_outer_measure_self_pos":
 "@[to_additive]\ntheorem haar_content_outer_measure_self_pos {K₀ : PositiveCompacts G} : 0 < (haar_content K₀).outer_measure K₀ :=\n  by\n  refine' zero_lt_one.trans_le _\n  rw [content.outer_measure_eq_infi]\n  refine' le_infᵢ₂ fun U hU => le_infᵢ fun hK₀ => le_trans _ <| le_supᵢ₂ K₀.to_compacts hK₀\n  exact haar_content_self.ge\n#align haar_content_outer_measure_self_pos haar_content_outer_measure_self_pos\n\n",
 "haar_content_apply":
 "@[to_additive]\ntheorem haar_content_apply (K₀ : PositiveCompacts G) (K : Compacts G) :\n    haar_content K₀ K = show NNReal from ⟨chaar K₀ K, chaar_nonneg _ _⟩ :=\n  rfl\n#align haar_content_apply haar_content_apply\n\n",
 "div_mem_nhds_one_of_haar_pos":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊇ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n-- see Note [lower instance priority]\n/-- **Steinhaus Theorem** In any locally compact group `G` with a haar measure `μ`, for any\n  measurable set `E` of positive measure, the set `E / E` is a neighbourhood of `1`. -/\n@[to_additive\n      \"**Steinhaus Theorem** In any locally compact group `G` with a haar measure `μ`,\\n  for any measurable set `E` of positive measure, the set `E - E` is a neighbourhood of `0`.\"]\ntheorem div_mem_nhds_one_of_haar_pos (μ : Measure G) [is_haar_measure μ] [LocallyCompactSpace G] (E : Set G)\n    (hE : MeasurableSet E) (hEpos : 0 < μ E) : E / E ∈ (nhds) (1 : G) :=\n  by\n  /- For any regular measure `μ` and set `E` of positive measure, we can find a compact set `K` of\n       positive measure inside `E`. Further, for any outer regular measure `μ` there exists an open\n       set `U` containing `K` with measure arbitrarily close to `K` (here `μ U < 2 * μ K` suffices).\n       Then, we can pick an open neighborhood of `1`, say `V` such that such that `V * K` is contained\n       in `U`. Now note that for any `v` in `V`, the sets `K` and `{v} * K` can not be disjoint\n       because they are both of measure `μ K` (since `μ` is left regular) and also contained in `U`,\n       yet we have that `μ U < 2 * μ K`. This show that `K / K` contains the neighborhood `V` of `1`,\n       and therefore that it is itself such a neighborhood. -/\n  obtain ⟨L, hL, hLE, hLpos, hLtop⟩ : ∃ L : Set G, MeasurableSet L ∧ L ⊆ E ∧ 0 < μ L ∧ μ L < ennreal.top\n  exact exists_subset_measure_lt_top hE hEpos\n  obtain ⟨K, hKL, hK, hKpos⟩ : ∃ (K : Set G)(H : K ⊆ L), IsCompact K ∧ 0 < μ K\n  exact measurable_set.exists_lt_is_compact_of_ne_top hL (ne_of_lt hLtop) hLpos\n  have hKtop : μ K ≠ ennreal.top := by\n    apply ne_top_of_le_ne_top (ne_of_lt hLtop)\n    apply measure_mono hKL\n  obtain ⟨U, hUK, hU, hμUK⟩ : ∃ (U : Set G)(H : «expr ⊇ » U K), IsOpen U ∧ μ U < μ K + μ K\n  exact set.exists_is_open_lt_add K hKtop hKpos.ne'\n  obtain ⟨V, hV1, hVKU⟩ : ∃ V ∈ (nhds) (1 : G), V * K ⊆ U\n  exact compact_open_separated_mul_left hK hU hUK\n  have hv : ∀ v : G, v ∈ V → ¬Disjoint ({v} * K) K :=\n    by\n    intro v hv hKv\n    have hKvsub : {v} * K ∪ K ⊆ U := by\n      apply Set.union_subset _ hUK\n      apply subset_trans _ hVKU\n      apply Set.mul_subset_mul _ (Set.Subset.refl K)\n      simp only [Set.singleton_subset_iff, hv]\n    replace hKvsub := @measure_mono _ _ μ _ _ hKvsub\n    have hcontr := lt_of_le_of_lt hKvsub hμUK\n    rw [measure_union hKv (is_compact.measurable_set hK)] at hcontr\n    have hKtranslate : μ ({v} * K) = μ K := by simp only [singleton_mul, image_mul_left, measure_preimage_mul]\n    rw [hKtranslate, lt_self_iff_false] at hcontr\n    assumption\n  suffices : V ⊆ E / E\n  exact Filter.mem_of_superset hV1 this\n  intro v hvV\n  obtain ⟨x, hxK, hxvK⟩ : ∃ x : G, x ∈ {v} * K ∧ x ∈ K\n  exact Set.not_disjoint_iff.1 (hv v hvV)\n  refine' ⟨x, v⁻¹ * x, hLE (hKL hxvK), _, _⟩\n  · apply hKL.trans hLE\n    simpa only [singleton_mul, image_mul_left, mem_preimage] using hxK\n  · simp only [div_eq_iff_eq_mul, ← mul_assoc, mul_right_inv, one_mul]\n#align div_mem_nhds_one_of_haar_pos div_mem_nhds_one_of_haar_pos\n\n",
 "chaar_sup_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n@[to_additive add_chaar_sup_le]\ntheorem chaar_sup_le {K₀ : PositiveCompacts G} (K₁ K₂ : Compacts G) :\n    chaar K₀ («expr ⊔ » K₁ K₂) ≤ chaar K₀ K₁ + chaar K₀ K₂ :=\n  by\n  let eval : (compacts G → exprℝ) → exprℝ := fun f => f K₁ + f K₂ - f («expr ⊔ » K₁ K₂)\n  have : Continuous eval :=\n    ((@continuous_add (exprℝ) _ _ _).comp ((continuous_apply K₁).prod_mk (continuous_apply K₂))).sub\n      (continuous_apply («expr ⊔ » K₁ K₂))\n  rw [← sub_nonneg]; show chaar K₀ ∈ «expr ⁻¹' » eval (Ici (0 : exprℝ))\n  apply mem_of_subset_of_mem _ (chaar_mem_cl_prehaar K₀ («expr⊤»))\n  unfold cl_prehaar; rw [IsClosed.closure_subset_iff]\n  · rintro _ ⟨U, ⟨h1U, h2U, h3U⟩, rfl⟩\n    simp only [mem_preimage, mem_Ici, eval, sub_nonneg]\n    apply prehaar_sup_le\n    rw [h2U.interior_eq]\n    exact ⟨1, h3U⟩\n  · apply continuous_iff_is_closed.mp this\n    exact isClosed_Ici\n#align chaar_sup_le chaar_sup_le\n\n",
 "chaar_sup_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n@[to_additive add_chaar_sup_eq]\ntheorem chaar_sup_eq [T2Space G] {K₀ : PositiveCompacts G} {K₁ K₂ : Compacts G} (h : Disjoint K₁.1 K₂.1) :\n    chaar K₀ («expr ⊔ » K₁ K₂) = chaar K₀ K₁ + chaar K₀ K₂ :=\n  by\n  rcases isCompact_isCompact_separated K₁.2 K₂.2 h with ⟨U₁, U₂, h1U₁, h1U₂, h2U₁, h2U₂, hU⟩\n  rcases compact_open_separated_mul_right K₁.2 h1U₁ h2U₁ with ⟨L₁, h1L₁, h2L₁⟩\n  rcases mem_nhds_iff.mp h1L₁ with ⟨V₁, h1V₁, h2V₁, h3V₁⟩\n  replace h2L₁ := subset.trans (mul_subset_mul_left h1V₁) h2L₁\n  rcases compact_open_separated_mul_right K₂.2 h1U₂ h2U₂ with ⟨L₂, h1L₂, h2L₂⟩\n  rcases mem_nhds_iff.mp h1L₂ with ⟨V₂, h1V₂, h2V₂, h3V₂⟩\n  replace h2L₂ := subset.trans (mul_subset_mul_left h1V₂) h2L₂\n  let eval : (compacts G → exprℝ) → exprℝ := fun f => f K₁ + f K₂ - f («expr ⊔ » K₁ K₂)\n  have : Continuous eval :=\n    ((@continuous_add (exprℝ) _ _ _).comp ((continuous_apply K₁).prod_mk (continuous_apply K₂))).sub\n      (continuous_apply («expr ⊔ » K₁ K₂))\n  rw [eq_comm, ← sub_eq_zero]; show chaar K₀ ∈ «expr ⁻¹' » eval {(0 : exprℝ)}\n  let V := V₁ ∩ V₂\n  apply\n    mem_of_subset_of_mem _\n      (chaar_mem_cl_prehaar K₀\n        ⟨⟨V⁻¹, (h2V₁.inter h2V₂).preimage continuous_inv⟩, by\n          simp only [mem_inv, inv_one, h3V₁, h3V₂, V, mem_inter_iff, true_and_iff]⟩)\n  unfold cl_prehaar; rw [IsClosed.closure_subset_iff]\n  · rintro _ ⟨U, ⟨h1U, h2U, h3U⟩, rfl⟩\n    simp only [mem_preimage, eval, sub_eq_zero, mem_singleton_iff]\n    rw [eq_comm]\n    apply prehaar_sup_eq\n    · rw [h2U.interior_eq]\n      exact ⟨1, h3U⟩\n    · refine' disjoint_of_subset _ _ hU\n      · refine' subset.trans (mul_subset_mul subset.rfl _) h2L₁\n        exact subset.trans (inv_subset.mpr h1U) (inter_subset_left _ _)\n      · refine' subset.trans (mul_subset_mul subset.rfl _) h2L₂\n        exact subset.trans (inv_subset.mpr h1U) (inter_subset_right _ _)\n  · apply continuous_iff_is_closed.mp this\n    exact isClosed_singleton\n#align chaar_sup_eq chaar_sup_eq\n\n",
 "chaar_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[to_additive add_chaar_self]\ntheorem chaar_self (K₀ : PositiveCompacts G) : chaar K₀ K₀.to_compacts = 1 :=\n  by\n  let eval : (compacts G → exprℝ) → exprℝ := fun f => f K₀.to_compacts\n  have : Continuous eval := continuous_apply _\n  show chaar K₀ ∈ «expr ⁻¹' » eval {(1 : exprℝ)}\n  apply mem_of_subset_of_mem _ (chaar_mem_cl_prehaar K₀ («expr⊤»))\n  unfold cl_prehaar; rw [IsClosed.closure_subset_iff]\n  · rintro _ ⟨U, ⟨h1U, h2U, h3U⟩, rfl⟩\n    apply prehaar_self\n    rw [h2U.interior_eq]\n    exact ⟨1, h3U⟩\n  · apply continuous_iff_is_closed.mp this\n    exact isClosed_singleton\n#align chaar_self chaar_self\n\n",
 "chaar_nonneg":
 "@[to_additive add_chaar_nonneg]\ntheorem chaar_nonneg (K₀ : PositiveCompacts G) (K : Compacts G) : 0 ≤ chaar K₀ K :=\n  by\n  have := chaar_mem_haar_product K₀ K (mem_univ _)\n  rw [mem_Icc] at this\n  exact this.1\n#align chaar_nonneg chaar_nonneg\n\n",
 "chaar_mono":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[to_additive add_chaar_mono]\ntheorem chaar_mono {K₀ : PositiveCompacts G} {K₁ K₂ : Compacts G} (h : (K₁ : Set G) ⊆ K₂) : chaar K₀ K₁ ≤ chaar K₀ K₂ :=\n  by\n  let eval : (compacts G → exprℝ) → exprℝ := fun f => f K₂ - f K₁\n  have : Continuous eval := (continuous_apply K₂).sub (continuous_apply K₁)\n  rw [← sub_nonneg]; show chaar K₀ ∈ «expr ⁻¹' » eval (Ici (0 : exprℝ))\n  apply mem_of_subset_of_mem _ (chaar_mem_cl_prehaar K₀ («expr⊤»))\n  unfold cl_prehaar; rw [IsClosed.closure_subset_iff]\n  · rintro _ ⟨U, ⟨h1U, h2U, h3U⟩, rfl⟩\n    simp only [mem_preimage, mem_Ici, eval, sub_nonneg]\n    apply prehaar_mono _ h\n    rw [h2U.interior_eq]\n    exact ⟨1, h3U⟩\n  · apply continuous_iff_is_closed.mp this\n    exact isClosed_Ici\n#align chaar_mono chaar_mono\n\n",
 "chaar_mem_haar_product":
 "@[to_additive add_chaar_mem_add_haar_product]\ntheorem chaar_mem_haar_product (K₀ : PositiveCompacts G) : chaar K₀ ∈ haar_product (K₀ : Set G) :=\n  (Classical.choose_spec (nonempty_Inter_cl_prehaar K₀)).1\n#align chaar_mem_haar_product chaar_mem_haar_product\n\n",
 "chaar_mem_cl_prehaar":
 "@[to_additive add_chaar_mem_cl_add_prehaar]\ntheorem chaar_mem_cl_prehaar (K₀ : PositiveCompacts G) (V : OpenNhdsOf (1 : G)) :\n    chaar K₀ ∈ cl_prehaar (K₀ : Set G) V :=\n  by\n  have := (Classical.choose_spec (nonempty_Inter_cl_prehaar K₀)).2\n  rw [mem_Inter] at this\n  exact this V\n#align chaar_mem_cl_prehaar chaar_mem_cl_prehaar\n\n",
 "chaar_empty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[to_additive add_chaar_empty]\ntheorem chaar_empty (K₀ : PositiveCompacts G) : chaar K₀ («expr⊥») = 0 :=\n  by\n  let eval : (compacts G → exprℝ) → exprℝ := fun f => f («expr⊥»)\n  have : Continuous eval := continuous_apply («expr⊥»)\n  show chaar K₀ ∈ «expr ⁻¹' » eval {(0 : exprℝ)}\n  apply mem_of_subset_of_mem _ (chaar_mem_cl_prehaar K₀ («expr⊤»))\n  unfold cl_prehaar; rw [IsClosed.closure_subset_iff]\n  · rintro _ ⟨U, ⟨h1U, h2U, h3U⟩, rfl⟩\n    apply prehaar_empty\n  · apply continuous_iff_is_closed.mp this\n    exact isClosed_singleton\n#align chaar_empty chaar_empty\n\n"}