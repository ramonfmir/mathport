{"sup_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n#print sup_le /-\ntheorem sup_le (K₁ K₂ : compacts G) : μ («expr ⊔ » K₁ K₂) ≤ μ K₁ + μ K₂ :=\n  by\n  simp only [apply_eq_coe_to_fun]\n  norm_cast\n  exact μ.sup_le' _ _\n#align sup_le sup_le\n-/\n\n",
 "sup_disjoint":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\ntheorem sup_disjoint (K₁ K₂ : compacts G) (h : Disjoint (K₁ : set G) K₂) : μ («expr ⊔ » K₁ K₂) = μ K₁ + μ K₂ := by\n  simp [apply_eq_coe_to_fun, μ.sup_disjoint' _ _ h]\n#align sup_disjoint sup_disjoint\n\n",
 "outer_measure_preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₜ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem outer_measure_preimage (f : «expr ≃ₜ » G G) (h : ∀ ⦃K : compacts G⦄, μ (K.map f f.continuous) = μ K)\n    (A : set G) : μ.outer_measure («expr ⁻¹' » f A) = μ.outer_measure A :=\n  by\n  refine'\n    induced_outer_measure_preimage _ μ.inner_content_Union_nat μ.inner_content_mono _ (fun s => f.is_open_preimage) _\n  intro s hs; convert μ.inner_content_comap f h ⟨s, hs⟩\n#align outer_measure_preimage outer_measure_preimage\n\n",
 "outer_measure_pos_of_is_mul_left_invariant":
 "@[to_additive]\ntheorem outer_measure_pos_of_is_mul_left_invariant [group G] [topological_group G]\n    (h3 : ∀ (g : G) {K : compacts G}, μ (K.map _ <| continuous_mul_left g) = μ K) (K : compacts G) (hK : μ K ≠ 0)\n    {U : set G} (h1U : is_open U) (h2U : U.nonempty) : 0 < μ.outer_measure U :=\n  by\n  convert μ.inner_content_pos_of_is_mul_left_invariant h3 K hK ⟨U, h1U⟩ h2U\n  exact μ.outer_measure_opens ⟨U, h1U⟩\n#align outer_measure_pos_of_is_mul_left_invariant outer_measure_pos_of_is_mul_left_invariant\n\n",
 "outer_measure_opens":
 "theorem outer_measure_opens (U : opens G) : μ.outer_measure U = μ.inner_content U :=\n  induced_outer_measure_eq' (fun _ => is_open_Union) μ.inner_content_Union_nat μ.inner_content_mono U.2\n#align outer_measure_opens outer_measure_opens\n\n",
 "outer_measure_of_is_open":
 "theorem outer_measure_of_is_open (U : set G) (hU : is_open U) : μ.outer_measure U = μ.inner_content ⟨U, hU⟩ :=\n  μ.outer_measure_opens ⟨U, hU⟩\n#align outer_measure_of_is_open outer_measure_of_is_open\n\n",
 "outer_measure_lt_top_of_is_compact":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\ntheorem outer_measure_lt_top_of_is_compact [locally_compact_space G] {K : set G} (hK : is_compact K) :\n    μ.outer_measure K < ennreal.top :=\n  by\n  rcases exists_compact_superset hK with ⟨F, h1F, h2F⟩\n  calc\n    μ.outer_measure K ≤ μ.outer_measure (interior F) := outer_measure.mono' _ h2F\n    _ ≤ μ ⟨F, h1F⟩ := by apply μ.outer_measure_le ⟨interior F, is_open_interior⟩ ⟨F, h1F⟩ interior_subset\n    _ < «expr⊤» := μ.lt_top _\n    \n#align outer_measure_lt_top_of_is_compact outer_measure_lt_top_of_is_compact\n\n",
 "outer_measure_le":
 "theorem outer_measure_le (U : opens G) (K : compacts G) (hUK : (U : set G) ⊆ K) : μ.outer_measure U ≤ μ K :=\n  (μ.outer_measure_opens U).le.trans <| μ.inner_content_le U K hUK\n#align outer_measure_le outer_measure_le\n\n",
 "outer_measure_interior_compacts":
 "theorem outer_measure_interior_compacts (K : compacts G) : μ.outer_measure (interior K) ≤ μ K :=\n  (μ.outer_measure_opens <| opens.interior K).le.trans <| μ.inner_content_le _ _ interior_subset\n#align outer_measure_interior_compacts outer_measure_interior_compacts\n\n",
 "outer_measure_exists_open":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\ntheorem outer_measure_exists_open {A : set G} (hA : μ.outer_measure A ≠ ennreal.top) {ε : nnreal} (hε : ε ≠ 0) :\n    ∃ U : opens G, A ⊆ U ∧ μ.outer_measure U ≤ μ.outer_measure A + ε :=\n  by\n  rcases induced_outer_measure_exists_set _ _ μ.inner_content_mono hA (ennreal.coe_ne_zero.2 hε) with ⟨U, hU, h2U, h3U⟩\n  exact ⟨⟨U, hU⟩, h2U, h3U⟩; swap; exact μ.inner_content_Union_nat\n#align outer_measure_exists_open outer_measure_exists_open\n\n",
 "outer_measure_exists_compact":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\ntheorem outer_measure_exists_compact {U : opens G} (hU : μ.outer_measure U ≠ ennreal.top) {ε : nnreal} (hε : ε ≠ 0) :\n    ∃ K : compacts G, (K : set G) ⊆ U ∧ μ.outer_measure U ≤ μ.outer_measure K + ε :=\n  by\n  rw [μ.outer_measure_opens] at hU⊢\n  rcases μ.inner_content_exists_compact hU hε with ⟨K, h1K, h2K⟩\n  exact ⟨K, h1K, le_trans h2K <| add_le_add_right (μ.le_outer_measure_compacts K) _⟩\n#align outer_measure_exists_compact outer_measure_exists_compact\n\n",
 "outer_measure_eq_infi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\ntheorem outer_measure_eq_infi (A : set G) :\n    μ.outer_measure A =\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n        (μ.inner_content ⟨U, hU⟩) :=\n  induced_outer_measure_eq_infi _ μ.inner_content_Union_nat μ.inner_content_mono A\n#align outer_measure_eq_infi outer_measure_eq_infi\n\n",
 "outer_measure_caratheodory":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\ntheorem outer_measure_caratheodory (A : set G) :\n    (measurable_set_of μ.outer_measure.caratheodory) A ↔\n      ∀ U : opens G, μ.outer_measure (U ∩ A) + μ.outer_measure (U \\ A) ≤ μ.outer_measure U :=\n  by\n  dsimp [opens]; rw [subtype.forall]\n  apply induced_outer_measure_caratheodory\n  apply inner_content_Union_nat\n  apply inner_content_mono'\n#align outer_measure_caratheodory outer_measure_caratheodory\n\n",
 "mono":
 "theorem mono (K₁ K₂ : compacts G) (h : (K₁ : set G) ⊆ K₂) : μ K₁ ≤ μ K₂ := by simp [apply_eq_coe_to_fun, μ.mono' _ _ h]\n#align mono mono\n\n",
 "measure_eq_content_of_regular":
 "/-- If `μ` is a regular content, then the measure induced by `μ` will agree with `μ`\n  on compact sets.-/\ntheorem measure_eq_content_of_regular (H : measure_theory.content.content_regular μ)\n    (K : topological_space.compacts G) : μ.measure ↑K = μ K :=\n  by\n  refine' le_antisymm _ _\n  · apply ennreal.le_of_forall_pos_le_add\n    intro ε εpos content_K_finite\n    obtain ⟨K', K'_hyp⟩ := content_regular_exists_compact μ H K (ne_bot_of_gt εpos)\n    calc\n      μ.measure ↑K ≤ μ.measure (interior ↑K') := _\n      _ ≤ μ K' := _\n      _ ≤ μ K + ε := K'_hyp.right\n      \n    · rw [μ.measure_apply is_open_interior.measurable_set, μ.measure_apply K.is_compact.measurable_set]\n      exact μ.outer_measure.mono K'_hyp.left\n    · rw [μ.measure_apply (is_open.measurable_set is_open_interior)]\n      exact μ.outer_measure_interior_compacts K'\n  · rw [μ.measure_apply (is_compact.measurable_set K.is_compact)]\n    exact μ.le_outer_measure_compacts K\n#align measure_eq_content_of_regular measure_eq_content_of_regular\n\n",
 "measure_apply":
 "theorem measure_apply {s : set G} (hs : measurable_set s) : μ.measure s = μ.outer_measure s :=\n  to_measure_apply _ _ hs\n#align measure_apply measure_apply\n\n",
 "lt_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\ntheorem lt_top (K : compacts G) : μ K < ennreal.top :=\n  ennreal.coe_lt_top\n#align lt_top lt_top\n\n",
 "le_outer_measure_compacts":
 "theorem le_outer_measure_compacts (K : compacts G) : μ K ≤ μ.outer_measure K :=\n  by\n  rw [content.outer_measure, induced_outer_measure_eq_infi]\n  · exact le_infᵢ fun U => le_infᵢ fun hU => le_infᵢ <| μ.le_inner_content K ⟨U, hU⟩\n  · exact μ.inner_content_Union_nat\n  · exact μ.inner_content_mono\n#align le_outer_measure_compacts le_outer_measure_compacts\n\n",
 "le_inner_content":
 "theorem le_inner_content (K : compacts G) (U : opens G) (h2 : (K : set G) ⊆ U) : μ K ≤ μ.inner_content U :=\n  le_supᵢ_of_le K <| le_supᵢ _ h2\n#align le_inner_content le_inner_content\n\n",
 "is_mul_left_invariant_outer_measure":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n@[to_additive]\ntheorem is_mul_left_invariant_outer_measure [group G] [topological_group G]\n    (h : ∀ (g : G) {K : compacts G}, μ (K.map _ <| continuous_mul_left g) = μ K) (g : G) (A : set G) :\n    μ.outer_measure («expr ⁻¹' » (fun h => g * h) A) = μ.outer_measure A := by\n  convert μ.outer_measure_preimage (homeomorph.mul_left g) (fun K => h g) A\n#align is_mul_left_invariant_outer_measure is_mul_left_invariant_outer_measure\n\n",
 "is_mul_left_invariant_inner_content":
 "@[to_additive]\ntheorem is_mul_left_invariant_inner_content [group G] [topological_group G]\n    (h : ∀ (g : G) {K : compacts G}, μ (K.map _ <| continuous_mul_left g) = μ K) (g : G) (U : opens G) :\n    μ.inner_content (opens.comap (homeomorph.mul_left g).to_continuous_map U) = μ.inner_content U := by\n  convert μ.inner_content_comap (homeomorph.mul_left g) (fun K => h g) U\n#align is_mul_left_invariant_inner_content is_mul_left_invariant_inner_content\n\n",
 "inner_content_pos_of_is_mul_left_invariant":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n@[to_additive]\ntheorem inner_content_pos_of_is_mul_left_invariant [t2_space G] [group G] [topological_group G]\n    (h3 : ∀ (g : G) {K : compacts G}, μ (K.map _ <| continuous_mul_left g) = μ K) (K : compacts G) (hK : μ K ≠ 0)\n    (U : opens G) (hU : (U : set G).nonempty) : 0 < μ.inner_content U :=\n  by\n  have : (interior (U : set G)).nonempty\n  rwa [U.prop.interior_eq]\n  rcases compact_covered_by_mul_left_translates K.2 this with ⟨s, hs⟩\n  suffices μ K ≤ s.card * μ.inner_content U by exact (ennreal.mul_pos_iff.mp <| hK.bot_lt.trans_le this).2\n  have :\n    (K : set G) ⊆\n      ↑(«expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n          (opens.comap (homeomorph.mul_left g).to_continuous_map U)) :=\n    by simpa only [opens.supr_def, opens.coe_comap, subtype.coe_mk]\n  refine' (μ.le_inner_content _ _ this).trans _\n  refine' (rel_supr_sum μ.inner_content μ.inner_content_empty (· ≤ ·) μ.inner_content_Sup_nat _ _).trans _\n  simp only [μ.is_mul_left_invariant_inner_content h3, finset.sum_const, nsmul_eq_mul, le_refl]\n#align inner_content_pos_of_is_mul_left_invariant inner_content_pos_of_is_mul_left_invariant\n\n",
 "inner_content_of_is_compact":
 "theorem inner_content_of_is_compact {K : set G} (h1K : is_compact K) (h2K : is_open K) :\n    μ.inner_content ⟨K, h2K⟩ = μ ⟨K, h1K⟩ :=\n  le_antisymm (supᵢ₂_le fun K' hK' => μ.mono _ ⟨K, h1K⟩ hK') (μ.le_inner_content _ _ Subset.rfl)\n#align inner_content_of_is_compact inner_content_of_is_compact\n\n",
 "inner_content_mono'":
 "theorem inner_content_mono' ⦃U V : set G⦄ (hU : is_open U) (hV : is_open V) (h2 : U ⊆ V) :\n    μ.inner_content ⟨U, hU⟩ ≤ μ.inner_content ⟨V, hV⟩ :=\n  bsupᵢ_mono fun K hK => hK.trans h2\n#align inner_content_mono' inner_content_mono'\n\n",
 "inner_content_mono":
 "/-- This is \"unbundled\", because that it required for the API of `induced_outer_measure`. -/\ntheorem inner_content_mono ⦃U V : set G⦄ (hU : is_open U) (hV : is_open V) (h2 : U ⊆ V) :\n    μ.inner_content ⟨U, hU⟩ ≤ μ.inner_content ⟨V, hV⟩ :=\n  bsupᵢ_mono fun K hK => hK.trans h2\n#align inner_content_mono inner_content_mono\n\n",
 "inner_content_le":
 "theorem inner_content_le (U : opens G) (K : compacts G) (h2 : (U : set G) ⊆ K) : μ.inner_content U ≤ μ K :=\n  supᵢ₂_le fun K' hK' => μ.mono _ _ (Subset.trans hK' h2)\n#align inner_content_le inner_content_le\n\n",
 "inner_content_exists_compact":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\ntheorem inner_content_exists_compact {U : opens G} (hU : μ.inner_content U ≠ ennreal.top) {ε : nnreal} (hε : ε ≠ 0) :\n    ∃ K : compacts G, (K : set G) ⊆ U ∧ μ.inner_content U ≤ μ K + ε :=\n  by\n  have h'ε := ennreal.coe_ne_zero.2 hε\n  cases le_or_lt (μ.inner_content U) ε\n  · exact ⟨«expr⊥», empty_subset _, le_add_left h⟩\n  have := ennreal.sub_lt_self hU h.ne_bot h'ε\n  conv at this =>\n    rhs\n    rw [inner_content];\n  simp only [lt_supᵢ_iff] at this\n  rcases this with ⟨U, h1U, h2U⟩; refine' ⟨U, h1U, _⟩\n  rw [← tsub_le_iff_right]; exact le_of_lt h2U\n#align inner_content_exists_compact inner_content_exists_compact\n\n",
 "inner_content_empty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem inner_content_empty : μ.inner_content ∅ = 0 :=\n  by\n  refine' le_antisymm _ (zero_le _)\n  rw [← μ.empty]\n  refine' supᵢ₂_le fun K hK => _\n  have : K = «expr⊥» := by\n    ext1\n    rw [subset_empty_iff.mp hK, compacts.coe_bot]\n  rw [this]\n  rfl\n#align inner_content_empty inner_content_empty\n\n",
 "inner_content_comap":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₜ » -/\ntheorem inner_content_comap (f : «expr ≃ₜ » G G) (h : ∀ ⦃K : compacts G⦄, μ (K.map f f.continuous) = μ K)\n    (U : opens G) : μ.inner_content (opens.comap f.to_continuous_map U) = μ.inner_content U :=\n  by\n  refine' (compacts.equiv f).surjective.supr_congr _ fun K => supᵢ_congr_Prop image_subset_iff _\n  intro hK; simp only [equiv.coe_fn_mk, subtype.mk_eq_mk, ennreal.coe_eq_coe, compacts.equiv]\n  apply h\n#align inner_content_comap inner_content_comap\n\n",
 "inner_content_Union_nat":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , » -/\n/-- The inner content of a union of sets is at most the sum of the individual inner contents.\n  This is the \"unbundled\" version of `inner_content_Sup_nat`.\n  It required for the API of `induced_outer_measure`. -/\ntheorem inner_content_Union_nat [t2_space G] ⦃U : ℕ → set G⦄ (hU : ∀ i : ℕ, is_open (U i)) :\n    μ.inner_content\n        ⟨«expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (U i),\n          is_open_Union hU⟩ ≤\n      «expr∑' , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , »\"\n        (μ.inner_content ⟨U i, hU i⟩) :=\n  by\n  have := μ.inner_content_Sup_nat fun i => ⟨U i, hU i⟩\n  rwa [opens.supr_def] at this\n#align inner_content_Union_nat inner_content_Union_nat\n\n",
 "inner_content_Sup_nat":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , » -/\n/-- The inner content of a supremum of opens is at most the sum of the individual inner\ncontents. -/\ntheorem inner_content_Sup_nat [t2_space G] (U : ℕ → opens G) :\n    μ.inner_content\n        («expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (U i)) ≤\n      «expr∑' , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , »\"\n        (μ.inner_content (U i)) :=\n  by\n  have h3 : ∀ (t : Finset ℕ) (K : ℕ → compacts G), μ (t.sup K) ≤ t.sum fun i => μ (K i) :=\n    by\n    intro t K\n    refine' Finset.induction_on t _ _\n    · simp only [μ.empty, nonpos_iff_eq_zero, finset.sum_empty, finset.sup_empty]\n    · intro n s hn ih\n      rw [finset.sup_insert, finset.sum_insert hn]\n      exact le_trans (μ.sup_le _ _) (add_le_add_left ih _)\n  refine' supᵢ₂_le fun K hK => _\n  obtain ⟨t, ht⟩ := K.is_compact.elim_finite_subcover _ (fun i => (U i).prop) _\n  swap\n  · convert hK\n    rw [opens.supr_def, subtype.coe_mk]\n  rcases K.is_compact.finite_compact_cover t (coe ∘ U) (fun i _ => (U _).prop) (by simp only [ht]) with\n    ⟨K', h1K', h2K', h3K'⟩\n  let L : ℕ → compacts G := fun n => ⟨K' n, h1K' n⟩\n  convert le_trans (h3 t L) _\n  · ext1\n    rw [compacts.coe_finset_sup, finset.sup_eq_supr]\n    exact h3K'\n  refine' le_trans (finset.sum_le_sum _) (ennreal.sum_le_tsum t)\n  intro i hi\n  refine' le_trans _ (le_supᵢ _ (L i))\n  refine' le_trans _ (le_supᵢ _ (h2K' i))\n  rfl\n#align inner_content_Sup_nat inner_content_Sup_nat\n\n",
 "empty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem empty : μ («expr⊥») = 0 := by\n  have := μ.sup_disjoint' («expr⊥») («expr⊥»)\n  simpa [apply_eq_coe_to_fun] using this\n#align empty empty\n\n",
 "content_regular_exists_compact":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\ntheorem content_regular_exists_compact (H : content_regular μ) (K : topological_space.compacts G) {ε : nnreal}\n    (hε : ε ≠ 0) : ∃ K' : topological_space.compacts G, K.carrier ⊆ interior K'.carrier ∧ μ K' ≤ μ K + ε :=\n  by\n  by_contra hc\n  simp only [not_exists, not_and, not_le] at hc\n  have lower_bound_infi :\n    μ K + ε ≤ «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (μ K') :=\n    le_infᵢ fun K' => le_infᵢ fun K'_hyp => le_of_lt (hc K' K'_hyp)\n  rw [← H] at lower_bound_infi\n  exact\n    (lt_self_iff_false (μ K)).mp\n      (lt_of_le_of_lt' lower_bound_infi (ennreal.lt_add_right (ne_top_of_lt (μ.lt_top K)) (ennreal.coe_ne_zero.mpr hε)))\n#align content_regular_exists_compact content_regular_exists_compact\n\n",
 "borel_le_caratheodory":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/-- For the outer measure coming from a content, all Borel sets are measurable. -/\ntheorem borel_le_caratheodory : S ≤ μ.outer_measure.caratheodory :=\n  by\n  rw [@borel_space.measurable_eq G _ _]\n  refine' measurable_space.generate_from_le _\n  intro U hU\n  rw [μ.outer_measure_caratheodory]\n  intro U'\n  rw [μ.outer_measure_of_is_open ((U' : set G) ∩ U) (is_open.inter U'.prop hU)]\n  simp only [inner_content, supᵢ_subtype']\n  rw [opens.coe_mk]\n  haveI : nonempty { L : compacts G // (L : set G) ⊆ U' ∩ U } := ⟨⟨«expr⊥», empty_subset _⟩⟩\n  rw [ennreal.supr_add]\n  refine' supᵢ_le _\n  rintro ⟨L, hL⟩\n  simp only [subset_inter_iff] at hL\n  have : ↑U' \\ U ⊆ U' \\ L := diff_subset_diff_right hL.2\n  refine' le_trans (add_le_add_left (μ.outer_measure.mono' this) _) _\n  rw [μ.outer_measure_of_is_open (↑U' \\ L) (is_open.sdiff U'.2 L.2.is_closed)]\n  simp only [inner_content, supᵢ_subtype']\n  rw [opens.coe_mk]\n  haveI : nonempty { M : compacts G // (M : set G) ⊆ ↑U' \\ L } := ⟨⟨«expr⊥», empty_subset _⟩⟩\n  rw [ennreal.add_supr]\n  refine' supᵢ_le _\n  rintro ⟨M, hM⟩\n  simp only [subset_diff] at hM\n  have : (↑(«expr ⊔ » L M) : set G) ⊆ U' := by simp only [union_subset_iff, compacts.coe_sup, hM, hL, and_self_iff]\n  rw [μ.outer_measure_of_is_open (↑U') U'.2]\n  refine' le_trans (ge_of_eq _) (μ.le_inner_content _ _ this)\n  exact μ.sup_disjoint _ _ hM.2.symm\n#align borel_le_caratheodory borel_le_caratheodory\n\n",
 "apply_eq_coe_to_fun":
 "/-\nCopyright (c) 2020 Floris van Doorn. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Floris van Doorn\n-/\ntheorem apply_eq_coe_to_fun (K : compacts G) : μ K = μ.to_fun K :=\n  rfl\n#align apply_eq_coe_to_fun apply_eq_coe_to_fun\n\n"}