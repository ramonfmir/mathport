{"tendsto_add_haar_inter_smul_zero_of_density_zero_aux2":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.gt -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.gt -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.gt -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.gt -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.gt -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem tendsto_add_haar_inter_smul_zero_of_density_zero_aux2 (s : set E) (x : E)\n    (h : tendsto (fun r => μ (s ∩ closed_ball x r) / μ (closed_ball x r)) (nhds_within.gt 0) ((nhds) 0)) (t : set E)\n    (u : set E) (h'u : μ u ≠ 0) (R : exprℝ) (Rpos : 0 < R) (t_bound : t ⊆ closed_ball 0 R) :\n    tendsto (fun r : exprℝ => μ (s ∩ ({x} + «expr • » r t)) / μ ({x} + «expr • » r u)) (nhds_within.gt 0) ((nhds) 0) :=\n  by\n  set t' := «expr • » R⁻¹ t with ht'\n  set u' := «expr • » R⁻¹ u with hu'\n  have A :\n    tendsto (fun r : exprℝ => μ (s ∩ ({x} + «expr • » r t')) / μ ({x} + «expr • » r u')) (nhds_within.gt 0)\n      ((nhds) 0) :=\n    by\n    apply tendsto_add_haar_inter_smul_zero_of_density_zero_aux1 μ s x h t' u'\n    ·\n      simp only [h'u, (pow_pos Rpos _).ne', abs_nonpos_iff, add_haar_smul, not_false_iff, ennreal.of_real_eq_zero,\n        inv_eq_zero, inv_pow, ne.def, or_self_iff, mul_eq_zero]\n    · convert smul_set_mono t_bound\n      rw [smul_closed_ball _ _ Rpos.le, smul_zero, real.norm_of_nonneg (inv_nonneg.2 Rpos.le), inv_mul_cancel Rpos.ne']\n  have B : tendsto (fun r : exprℝ => R * r) (nhds_within.gt 0) (nhds_within.gt (R * 0)) :=\n    by\n    apply tendsto_nhds_within_of_tendsto_nhds_of_eventually_within\n    · exact (tendsto_const_nhds.mul tendsto_id).mono_left nhds_within_le_nhds\n    · filter_upwards [self_mem_nhds_within]\n      intro r rpos\n      rw [mul_zero]\n      exact mul_pos Rpos rpos\n  rw [mul_zero] at B\n  apply (A.comp B).congr' _\n  filter_upwards [self_mem_nhds_within]\n  rintro r (rpos : 0 < r)\n  have T : «expr • » (R * r) t' = «expr • » r t := by\n    rw [mul_comm, ht', smul_smul, mul_assoc, mul_inv_cancel Rpos.ne', mul_one]\n  have U : «expr • » (R * r) u' = «expr • » r u := by\n    rw [mul_comm, hu', smul_smul, mul_assoc, mul_inv_cancel Rpos.ne', mul_one]\n  dsimp\n  rw [T, U]\n#align tendsto_add_haar_inter_smul_zero_of_density_zero_aux2 tendsto_add_haar_inter_smul_zero_of_density_zero_aux2\n\n",
 "tendsto_add_haar_inter_smul_zero_of_density_zero_aux1":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.gt -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.gt -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.gt -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.gt -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.gt -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem tendsto_add_haar_inter_smul_zero_of_density_zero_aux1 (s : set E) (x : E)\n    (h : tendsto (fun r => μ (s ∩ closed_ball x r) / μ (closed_ball x r)) (nhds_within.gt 0) ((nhds) 0)) (t : set E)\n    (u : set E) (h'u : μ u ≠ 0) (t_bound : t ⊆ closed_ball 0 1) :\n    tendsto (fun r : exprℝ => μ (s ∩ ({x} + «expr • » r t)) / μ ({x} + «expr • » r u)) (nhds_within.gt 0) ((nhds) 0) :=\n  by\n  have A :\n    tendsto (fun r : exprℝ => μ (s ∩ ({x} + «expr • » r t)) / μ (closed_ball x r)) (nhds_within.gt 0) ((nhds) 0) :=\n    by\n    apply tendsto_of_tendsto_of_tendsto_of_le_of_le' tendsto_const_nhds h (eventually_of_forall fun b => zero_le _)\n    filter_upwards [self_mem_nhds_within]\n    rintro r (rpos : 0 < r)\n    apply ennreal.mul_le_mul (measure_mono (inter_subset_inter_right _ _)) le_rfl\n    intro y hy\n    have : y - x ∈ «expr • » r (closed_ball (0 : E) 1) :=\n      by\n      apply smul_set_mono t_bound\n      simpa [neg_add_eq_sub] using hy\n    simpa only [smul_closed_ball _ _ zero_le_one, real.norm_of_nonneg rpos.le, mem_closed_ball_iff_norm, mul_one,\n      sub_zero, smul_zero]\n  have B :\n    tendsto (fun r : exprℝ => μ (closed_ball x r) / μ ({x} + «expr • » r u)) (nhds_within.gt 0)\n      ((nhds) (μ (closed_ball x 1) / μ ({x} + u))) :=\n    by\n    apply tendsto_const_nhds.congr' _\n    filter_upwards [self_mem_nhds_within]\n    rintro r (rpos : 0 < r)\n    have : closed_ball x r = {x} + «expr • » r (closed_ball 0 1) := by\n      simp only [smul_closed_ball, real.norm_of_nonneg rpos.le, zero_le_one, add_zero, mul_one,\n        singleton_add_closed_ball, smul_zero]\n    simp only [this, add_haar_singleton_add_smul_div_singleton_add_smul μ rpos.ne']\n    simp only [add_haar_closed_ball_center, image_add_left, measure_preimage_add, singleton_add]\n  have C :\n    tendsto\n      (fun r : exprℝ =>\n        μ (s ∩ ({x} + «expr • » r t)) / μ (closed_ball x r) * (μ (closed_ball x r) / μ ({x} + «expr • » r u)))\n      (nhds_within.gt 0) ((nhds) (0 * (μ (closed_ball x 1) / μ ({x} + u)))) :=\n    by\n    apply ennreal.tendsto.mul A _ B (or.inr ennreal.zero_ne_top)\n    simp only [ennreal.div_eq_top, h'u, measure_closed_ball_lt_top.ne, false_or_iff, image_add_left, eq_self_iff_true,\n      not_true, ne.def, not_false_iff, measure_preimage_add, singleton_add, and_false_iff, false_and_iff]\n  simp only [zero_mul] at C\n  apply C.congr' _\n  filter_upwards [self_mem_nhds_within]\n  rintro r (rpos : 0 < r)\n  calc\n    μ (s ∩ ({x} + «expr • » r t)) / μ (closed_ball x r) * (μ (closed_ball x r) / μ ({x} + «expr • » r u)) =\n        μ (closed_ball x r) * (μ (closed_ball x r))⁻¹ * (μ (s ∩ ({x} + «expr • » r t)) / μ ({x} + «expr • » r u)) :=\n      by\n      simp only [div_eq_mul_inv]\n      ring\n    _ = μ (s ∩ ({x} + «expr • » r t)) / μ ({x} + «expr • » r u) := by\n      rw [ennreal.mul_inv_cancel (measure_closed_ball_pos μ x rpos).ne' measure_closed_ball_lt_top.ne, one_mul]\n    \n#align tendsto_add_haar_inter_smul_zero_of_density_zero_aux1 tendsto_add_haar_inter_smul_zero_of_density_zero_aux1\n\n",
 "tendsto_add_haar_inter_smul_zero_of_density_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.gt -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.gt -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.gt -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- Consider a point `x` at which a set `s` has density zero, with respect to closed balls. Then it\nalso has density zero with respect to any measurable set `t`: the proportion of points in `s`\nbelonging to a rescaled copy `{x} + r • t` of `t` tends to zero as `r` tends to zero. -/\ntheorem tendsto_add_haar_inter_smul_zero_of_density_zero (s : set E) (x : E)\n    (h : tendsto (fun r => μ (s ∩ closed_ball x r) / μ (closed_ball x r)) (nhds_within.gt 0) ((nhds) 0)) (t : set E)\n    (ht : measurable_set t) (h''t : μ t ≠ ennreal.top) :\n    tendsto (fun r : exprℝ => μ (s ∩ ({x} + «expr • » r t)) / μ ({x} + «expr • » r t)) (nhds_within.gt 0) ((nhds) 0) :=\n  by\n  refine' tendsto_order.2 ⟨fun a' ha' => (ennreal.not_lt_zero ha').elim, fun ε (εpos : 0 < ε) => _⟩\n  rcases eq_or_ne (μ t) 0 with (h't | h't)\n  · apply eventually_of_forall fun r => _\n    suffices H : μ (s ∩ ({x} + «expr • » r t)) = 0\n    · rw [H]\n      simpa only [ennreal.zero_div] using εpos\n    apply le_antisymm _ (zero_le _)\n    calc\n      μ (s ∩ ({x} + «expr • » r t)) ≤ μ ({x} + «expr • » r t) := measure_mono (inter_subset_right _ _)\n      _ = 0 := by simp only [h't, add_haar_smul, image_add_left, measure_preimage_add, singleton_add, mul_zero]\n      \n  obtain ⟨n, npos, hn⟩ : ∃ n : ℕ, 0 < n ∧ μ (t \\ closed_ball 0 n) < ε / 2 * μ t :=\n    by\n    have A :\n      tendsto (fun n : ℕ => μ (t \\ closed_ball 0 n)) at_top\n        ((nhds)\n          (μ\n            («expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\"\n              (t \\ closed_ball 0 n)))) :=\n      by\n      have N : ∃ n : ℕ, μ (t \\ closed_ball 0 n) ≠ ennreal.top :=\n        ⟨0, ((measure_mono (diff_subset t _)).trans_lt h''t.lt_top).ne⟩\n      refine' tendsto_measure_Inter (fun n => ht.diff measurable_set_closed_ball) (fun m n hmn => _) N\n      exact diff_subset_diff subset.rfl (closed_ball_subset_closed_ball (nat.cast_le.2 hmn))\n    have :\n      «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\"\n          (t \\ closed_ball 0 n) =\n        ∅ :=\n      by\n      simp_rw [diff_eq, ← inter_Inter, Inter_eq_compl_Union_compl, compl_compl, Union_closed_ball_nat, compl_univ,\n        inter_empty]\n    simp only [this, measure_empty] at A\n    have I : 0 < ε / 2 * μ t := ennreal.mul_pos (ennreal.half_pos εpos.ne').ne' h't\n    exact (eventually.and (Ioi_mem_at_top 0) ((tendsto_order.1 A).2 _ I)).exists\n  have L :\n    tendsto (fun r : exprℝ => μ (s ∩ ({x} + «expr • » r (t ∩ closed_ball 0 n))) / μ ({x} + «expr • » r t))\n      (nhds_within.gt 0) ((nhds) 0) :=\n    tendsto_add_haar_inter_smul_zero_of_density_zero_aux2 μ s x h _ t h't n (nat.cast_pos.2 npos)\n      (inter_subset_right _ _)\n  filter_upwards [(tendsto_order.1 L).2 _ (ennreal.half_pos εpos.ne'), self_mem_nhds_within]\n  rintro r hr (rpos : 0 < r)\n  have I :\n    μ (s ∩ ({x} + «expr • » r t)) ≤\n      μ (s ∩ ({x} + «expr • » r (t ∩ closed_ball 0 n))) + μ ({x} + «expr • » r (t \\ closed_ball 0 n)) :=\n    calc\n      μ (s ∩ ({x} + «expr • » r t)) =\n          μ (s ∩ ({x} + «expr • » r (t ∩ closed_ball 0 n)) ∪ s ∩ ({x} + «expr • » r (t \\ closed_ball 0 n))) :=\n        by rw [← inter_union_distrib_left, ← add_union, ← smul_set_union, inter_union_diff]\n      _ ≤ μ (s ∩ ({x} + «expr • » r (t ∩ closed_ball 0 n))) + μ (s ∩ ({x} + «expr • » r (t \\ closed_ball 0 n))) :=\n        measure_union_le _ _\n      _ ≤ μ (s ∩ ({x} + «expr • » r (t ∩ closed_ball 0 n))) + μ ({x} + «expr • » r (t \\ closed_ball 0 n)) :=\n        add_le_add le_rfl (measure_mono (inter_subset_right _ _))\n      \n  calc\n    μ (s ∩ ({x} + «expr • » r t)) / μ ({x} + «expr • » r t) ≤\n        (μ (s ∩ ({x} + «expr • » r (t ∩ closed_ball 0 n))) + μ ({x} + «expr • » r (t \\ closed_ball 0 n))) /\n          μ ({x} + «expr • » r t) :=\n      ennreal.mul_le_mul I le_rfl\n    _ < ε / 2 + ε / 2 := by\n      rw [ennreal.add_div]\n      apply ennreal.add_lt_add hr _\n      rwa [add_haar_singleton_add_smul_div_singleton_add_smul μ rpos.ne', ennreal.div_lt_iff (or.inl h't) (or.inl h''t)]\n    _ = ε := ennreal.add_halves _\n    \n#align tendsto_add_haar_inter_smul_zero_of_density_zero tendsto_add_haar_inter_smul_zero_of_density_zero\n\n",
 "tendsto_add_haar_inter_smul_one_of_density_one_aux":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.gt -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.gt -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.gt -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.gt -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.gt -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.gt -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem tendsto_add_haar_inter_smul_one_of_density_one_aux (s : set E) (hs : measurable_set s) (x : E)\n    (h : tendsto (fun r => μ (s ∩ closed_ball x r) / μ (closed_ball x r)) (nhds_within.gt 0) ((nhds) 1)) (t : set E)\n    (ht : measurable_set t) (h't : μ t ≠ 0) (h''t : μ t ≠ ennreal.top) :\n    tendsto (fun r : exprℝ => μ (s ∩ ({x} + «expr • » r t)) / μ ({x} + «expr • » r t)) (nhds_within.gt 0) ((nhds) 1) :=\n  by\n  have I :\n    ∀ u v, μ u ≠ 0 → μ u ≠ ennreal.top → measurable_set v → μ u / μ u - μ («expr ᶜ» v ∩ u) / μ u = μ (v ∩ u) / μ u :=\n    by\n    intro u v uzero utop vmeas\n    simp_rw [div_eq_mul_inv]\n    rw [← ennreal.sub_mul]\n    swap\n    · simp only [uzero, ennreal.inv_eq_top, imp_true_iff, ne.def, not_false_iff]\n    congr 1\n    apply ennreal.sub_eq_of_add_eq (ne_top_of_le_ne_top utop (measure_mono (inter_subset_right _ _)))\n    rw [inter_comm _ u, inter_comm _ u]\n    exact measure_inter_add_diff u vmeas\n  have L : tendsto (fun r => μ («expr ᶜ» s ∩ closed_ball x r) / μ (closed_ball x r)) (nhds_within.gt 0) ((nhds) 0) :=\n    by\n    have A : tendsto (fun r => μ (closed_ball x r) / μ (closed_ball x r)) (nhds_within.gt 0) ((nhds) 1) :=\n      by\n      apply tendsto_const_nhds.congr' _\n      filter_upwards [self_mem_nhds_within]\n      intro r hr\n      rw [div_eq_mul_inv, ennreal.mul_inv_cancel]\n      · exact (measure_closed_ball_pos μ _ hr).ne'\n      · exact measure_closed_ball_lt_top.ne\n    have B := ennreal.tendsto.sub A h (or.inl ennreal.one_ne_top)\n    simp only [tsub_self] at B\n    apply B.congr' _\n    filter_upwards [self_mem_nhds_within]\n    rintro r (rpos : 0 < r)\n    convert\n      I (closed_ball x r) («expr ᶜ» s) (measure_closed_ball_pos μ _ rpos).ne' measure_closed_ball_lt_top.ne hs.compl\n    rw [compl_compl]\n  have L' :\n    tendsto (fun r : exprℝ => μ («expr ᶜ» s ∩ ({x} + «expr • » r t)) / μ ({x} + «expr • » r t)) (nhds_within.gt 0)\n      ((nhds) 0) :=\n    tendsto_add_haar_inter_smul_zero_of_density_zero μ («expr ᶜ» s) x L t ht h''t\n  have L'' :\n    tendsto (fun r : exprℝ => μ ({x} + «expr • » r t) / μ ({x} + «expr • » r t)) (nhds_within.gt 0) ((nhds) 1) :=\n    by\n    apply tendsto_const_nhds.congr' _\n    filter_upwards [self_mem_nhds_within]\n    rintro r (rpos : 0 < r)\n    rw [add_haar_singleton_add_smul_div_singleton_add_smul μ rpos.ne', ennreal.div_self h't h''t]\n  have := ennreal.tendsto.sub L'' L' (or.inl ennreal.one_ne_top)\n  simp only [tsub_zero] at this\n  apply this.congr' _\n  filter_upwards [self_mem_nhds_within]\n  rintro r (rpos : 0 < r)\n  refine' I ({x} + «expr • » r t) s _ _ hs\n  ·\n    simp only [h't, abs_of_nonneg rpos.le, pow_pos rpos, add_haar_smul, image_add_left, ennreal.of_real_eq_zero, not_le,\n      or_false_iff, ne.def, measure_preimage_add, abs_pow, singleton_add, mul_eq_zero]\n  ·\n    simp only [h''t, ennreal.of_real_ne_top, add_haar_smul, image_add_left, WithTop.mul_eq_top_iff, ne.def,\n      not_false_iff, measure_preimage_add, singleton_add, and_false_iff, false_and_iff, or_self_iff]\n#align tendsto_add_haar_inter_smul_one_of_density_one_aux tendsto_add_haar_inter_smul_one_of_density_one_aux\n\n",
 "tendsto_add_haar_inter_smul_one_of_density_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.gt -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.gt -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.gt -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- Consider a point `x` at which a set `s` has density one, with respect to closed balls (i.e.,\na Lebesgue density point of `s`). Then `s` has also density one at `x` with respect to any\nmeasurable set `t`: the proportion of points in `s` belonging to a rescaled copy `{x} + r • t`\nof `t` tends to one as `r` tends to zero. -/\ntheorem tendsto_add_haar_inter_smul_one_of_density_one (s : set E) (x : E)\n    (h : tendsto (fun r => μ (s ∩ closed_ball x r) / μ (closed_ball x r)) (nhds_within.gt 0) ((nhds) 1)) (t : set E)\n    (ht : measurable_set t) (h't : μ t ≠ 0) (h''t : μ t ≠ ennreal.top) :\n    tendsto (fun r : exprℝ => μ (s ∩ ({x} + «expr • » r t)) / μ ({x} + «expr • » r t)) (nhds_within.gt 0) ((nhds) 1) :=\n  by\n  have :\n    tendsto (fun r : exprℝ => μ (to_measurable μ s ∩ ({x} + «expr • » r t)) / μ ({x} + «expr • » r t))\n      (nhds_within.gt 0) ((nhds) 1) :=\n    by\n    apply tendsto_add_haar_inter_smul_one_of_density_one_aux μ _ (measurable_set_to_measurable _ _) _ _ t ht h't h''t\n    apply tendsto_of_tendsto_of_tendsto_of_le_of_le' h tendsto_const_nhds\n    · apply eventually_of_forall fun r => _\n      apply ennreal.mul_le_mul _ le_rfl\n      exact measure_mono (inter_subset_inter_left _ (subset_to_measurable _ _))\n    · filter_upwards [self_mem_nhds_within]\n      rintro r (rpos : 0 < r)\n      apply ennreal.div_le_of_le_mul\n      rw [one_mul]\n      exact measure_mono (inter_subset_right _ _)\n  apply this.congr fun r => _\n  congr 1\n  apply measure_to_measurable_inter_of_sigma_finite\n  simp only [image_add_left, singleton_add]\n  apply (continuous_add_left (-x)).measurable (ht.const_smul₀ r)\n#align tendsto_add_haar_inter_smul_one_of_density_one tendsto_add_haar_inter_smul_one_of_density_one\n\n",
 "measure_parallelepiped":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem _root_.alternating_map.measure_parallelepiped (ω : alternating_map (exprℝ) G (exprℝ) (fin n)) (v : fin n → G) :\n    ω.measure (parallelepiped v) = ennreal.of_real (|ω v|) :=\n  by\n  conv_rhs => rw [ω.eq_smul_basis_det (fin_basis_of_finrank_eq (exprℝ) G _i.out)]\n  simp only [add_haar_parallelepiped, alternating_map.measure, coe_nnreal_smul_apply, alternating_map.smul_apply,\n    algebra.id.smul_eq_mul, abs_mul, ennreal.of_real_mul (abs_nonneg _), real.ennnorm_eq_of_real_abs]\n#align alternating_map.measure_parallelepiped alternating_map.measure_parallelepiped\n\n",
 "map_linear_map_add_haar_pi_eq_smul_add_haar":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem map_linear_map_add_haar_pi_eq_smul_add_haar {ι : Type _} [Finite ι]\n    {f : «expr →ₗ[ ] » (ι → exprℝ) (exprℝ) (ι → exprℝ)} (hf : f.det ≠ 0) (μ : measure (ι → exprℝ))\n    [is_add_haar_measure μ] : measure.map f μ = «expr • » (ennreal.of_real (abs f.det⁻¹)) μ :=\n  by\n  cases nonempty_fintype ι\n  /- We have already proved the result for the Lebesgue product measure, using matrices.\n    We deduce it for any Haar measure by uniqueness (up to scalar multiplication). -/\n  have := add_haar_measure_unique μ (pi_Icc01 ι)\n  rw [this, add_haar_measure_eq_volume_pi, measure.map_smul, real.map_linear_map_volume_pi_eq_smul_volume_pi hf,\n    smul_comm]\n#align map_linear_map_add_haar_pi_eq_smul_add_haar map_linear_map_add_haar_pi_eq_smul_add_haar\n\n",
 "map_linear_map_add_haar_eq_smul_add_haar":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃+ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem map_linear_map_add_haar_eq_smul_add_haar {f : «expr →ₗ[ ] » E (exprℝ) E} (hf : f.det ≠ 0) :\n    measure.map f μ = «expr • » (ennreal.of_real (abs f.det⁻¹)) μ :=\n  by\n  -- we reduce to the case of `E = ι → ℝ`, for which we have already proved the result using\n  -- matrices in `map_linear_map_add_haar_pi_eq_smul_add_haar`.\n  let ι := fin (finrank (exprℝ) E)\n  haveI : finite_dimensional (exprℝ) (ι → exprℝ) := by infer_instance\n  have : finrank (exprℝ) E = finrank (exprℝ) (ι → exprℝ) := by simp\n  have e : «expr ≃ₗ[ ] » E (exprℝ) (ι → exprℝ) := linear_equiv.of_finrank_eq E (ι → exprℝ) this\n  -- next line is to avoid `g` getting reduced by `simp`.\n  obtain ⟨g, hg⟩ :\n    ∃ g, g = (e : «expr →ₗ[ ] » E (exprℝ) (ι → exprℝ)).comp (f.comp (e.symm : «expr →ₗ[ ] » (ι → exprℝ) (exprℝ) E)) :=\n    ⟨_, rfl⟩\n  have gdet : g.det = f.det := by\n    rw [hg]\n    exact linear_map.det_conj f e\n  rw [← gdet] at hf⊢\n  have fg :\n    f = (e.symm : «expr →ₗ[ ] » (ι → exprℝ) (exprℝ) E).comp (g.comp (e : «expr →ₗ[ ] » E (exprℝ) (ι → exprℝ))) :=\n    by\n    ext x\n    simp only [linear_equiv.coe_coe, Function.comp_apply, linear_map.coe_comp, linear_equiv.symm_apply_apply, hg]\n  simp only [fg, linear_equiv.coe_coe, linear_map.coe_comp]\n  have Ce : continuous e := (e : «expr →ₗ[ ] » E (exprℝ) (ι → exprℝ)).continuous_of_finite_dimensional\n  have Cg : continuous g := linear_map.continuous_of_finite_dimensional g\n  have Cesymm : continuous e.symm := (e.symm : «expr →ₗ[ ] » (ι → exprℝ) (exprℝ) E).continuous_of_finite_dimensional\n  rw [← map_map Cesymm.measurable (Cg.comp Ce).measurable, ← map_map Cg.measurable Ce.measurable]\n  haveI : is_add_haar_measure (map e μ) := (e : «expr ≃+ » E (ι → exprℝ)).is_add_haar_measure_map μ Ce Cesymm\n  have ecomp : e.symm ∘ e = id := by\n    ext x\n    simp only [id.def, Function.comp_apply, linear_equiv.symm_apply_apply]\n  rw [map_linear_map_add_haar_pi_eq_smul_add_haar hf (map e μ), measure.map_smul,\n    map_map Cesymm.measurable Ce.measurable, ecomp, measure.map_id]\n#align map_linear_map_add_haar_eq_smul_add_haar map_linear_map_add_haar_eq_smul_add_haar\n\n",
 "map_add_haar_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:219:4: warning: unsupported binary notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem map_add_haar_smul {r : exprℝ} (hr : r ≠ 0) :\n    measure.map ((«expr • » · ·) r) μ = «expr • » (ennreal.of_real (abs (r ^ finrank (exprℝ) E)⁻¹)) μ :=\n  by\n  let f : «expr →ₗ[ ] » E (exprℝ) E := «expr • » r 1\n  change measure.map f μ = _\n  have hf : f.det ≠ 0 := by\n    simp only [mul_one, linear_map.det_smul, ne.def, MonoidHom.map_one]\n    intro h\n    exact hr (pow_eq_zero h)\n  simp only [map_linear_map_add_haar_eq_smul_add_haar μ hf, mul_one, linear_map.det_smul, MonoidHom.map_one]\n#align map_add_haar_smul map_add_haar_smul\n\n",
 "integral_comp_smul_of_nonneg":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ » -/\n/-- The integral of `f (R • x)` with respect to an additive Haar measure is a multiple of the\nintegral of `f`. The formula we give works even when `f` is not integrable or `R = 0`\nthanks to the convention that a non-integrable function has integral zero. -/\ntheorem integral_comp_smul_of_nonneg (f : E → F) (R : exprℝ) {hR : 0 ≤ R} :\n    «expr∫ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ »\"\n        (f («expr • » R x)) μ =\n      «expr • » (R ^ finrank (exprℝ) E)⁻¹\n        («expr∫ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ »\" (f x) μ) :=\n  by rw [integral_comp_smul μ f R, abs_of_nonneg (inv_nonneg.2 (pow_nonneg hR _))]\n#align integral_comp_smul_of_nonneg integral_comp_smul_of_nonneg\n\n",
 "integral_comp_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ » -/\n/-- The integral of `f (R • x)` with respect to an additive Haar measure is a multiple of the\nintegral of `f`. The formula we give works even when `f` is not integrable or `R = 0`\nthanks to the convention that a non-integrable function has integral zero. -/\ntheorem integral_comp_smul (f : E → F) (R : exprℝ) :\n    «expr∫ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ »\"\n        (f («expr • » R x)) μ =\n      «expr • » (|(R ^ finrank (exprℝ) E)⁻¹|)\n        («expr∫ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ »\" (f x) μ) :=\n  by\n  rcases eq_or_ne R 0 with (rfl | hR)\n  · simp only [zero_smul, integral_const]\n    rcases nat.eq_zero_or_pos (finrank (exprℝ) E) with (hE | hE)\n    · have : subsingleton E := finrank_zero_iff.1 hE\n      have : f = fun x => f 0 := by\n        ext x\n        rw [subsingleton.elim x 0]\n      conv_rhs => rw [this]\n      simp only [hE, pow_zero, inv_one, abs_one, one_smul, integral_const]\n    · have : nontrivial E := finrank_pos_iff.1 hE\n      simp only [zero_pow hE, measure_univ_of_is_add_left_invariant, ennreal.top_to_real, zero_smul, inv_zero, abs_zero]\n  ·\n    calc\n      «expr∫ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ »\"\n            (f («expr • » R x)) μ =\n          «expr∫ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ »\" (f y)\n            (measure.map (fun x => «expr • » R x) μ) :=\n        (integral_map_equiv (homeomorph.smul (isUnit_iff_ne_zero.2 hR).unit).to_measurable_equiv f).symm\n      _ =\n          «expr • » (|(R ^ finrank (exprℝ) E)⁻¹|)\n            («expr∫ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ »\" (f x)\n              μ) :=\n        by simp only [map_add_haar_smul μ hR, integral_smul_measure, ennreal.to_real_of_real, abs_nonneg]\n      \n#align integral_comp_smul integral_comp_smul\n\n",
 "integral_comp_inv_smul_of_nonneg":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ » -/\n/-- The integral of `f (R⁻¹ • x)` with respect to an additive Haar measure is a multiple of the\nintegral of `f`. The formula we give works even when `f` is not integrable or `R = 0`\nthanks to the convention that a non-integrable function has integral zero. -/\ntheorem integral_comp_inv_smul_of_nonneg (f : E → F) {R : exprℝ} (hR : 0 ≤ R) :\n    «expr∫ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ »\"\n        (f («expr • » R⁻¹ x)) μ =\n      «expr • » (R ^ finrank (exprℝ) E)\n        («expr∫ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ »\" (f x) μ) :=\n  by rw [integral_comp_inv_smul μ f R, abs_of_nonneg (pow_nonneg hR _)]\n#align integral_comp_inv_smul_of_nonneg integral_comp_inv_smul_of_nonneg\n\n",
 "integral_comp_inv_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ » -/\n/-- The integral of `f (R⁻¹ • x)` with respect to an additive Haar measure is a multiple of the\nintegral of `f`. The formula we give works even when `f` is not integrable or `R = 0`\nthanks to the convention that a non-integrable function has integral zero. -/\ntheorem integral_comp_inv_smul (f : E → F) (R : exprℝ) :\n    «expr∫ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ »\"\n        (f («expr • » R⁻¹ x)) μ =\n      «expr • » (|R ^ finrank (exprℝ) E|)\n        («expr∫ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ »\" (f x) μ) :=\n  by rw [integral_comp_smul μ f R⁻¹, inv_pow, inv_inv]\n#align integral_comp_inv_smul integral_comp_inv_smul\n\n",
 "eventually_nonempty_inter_smul_of_density_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.gt -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.gt -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- Consider a point `x` at which a set `s` has density one, with respect to closed balls (i.e.,\na Lebesgue density point of `s`). Then `s` intersects the rescaled copies `{x} + r • t` of a given\nset `t` with positive measure, for any small enough `r`. -/\ntheorem eventually_nonempty_inter_smul_of_density_one (s : set E) (x : E)\n    (h : tendsto (fun r => μ (s ∩ closed_ball x r) / μ (closed_ball x r)) (nhds_within.gt 0) ((nhds) 1)) (t : set E)\n    (ht : measurable_set t) (h't : μ t ≠ 0) :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\"\n      (nhds_within.gt (0 : exprℝ)) (s ∩ ({x} + «expr • » r t)).nonempty :=\n  by\n  obtain ⟨t', t'_meas, t't, t'pos, t'top⟩ : ∃ t', measurable_set t' ∧ t' ⊆ t ∧ 0 < μ t' ∧ μ t' < «expr⊤» :=\n    exists_subset_measure_lt_top ht h't.bot_lt\n  filter_upwards [(tendsto_order.1\n          (tendsto_add_haar_inter_smul_one_of_density_one μ s x h t' t'_meas t'pos.ne' t'top.ne)).1\n      0 ennreal.zero_lt_one]\n  intro r hr\n  have : μ (s ∩ ({x} + «expr • » r t')) ≠ 0 := fun h' => by\n    simpa only [ennreal.not_lt_zero, ennreal.zero_div, h'] using hr\n  have : (s ∩ ({x} + «expr • » r t')).nonempty := nonempty_of_measure_ne_zero this\n  apply this.mono (inter_subset_inter subset.rfl _)\n  exact add_subset_add subset.rfl (smul_set_mono t't)\n#align eventually_nonempty_inter_smul_of_density_one eventually_nonempty_inter_smul_of_density_one\n\n",
 "add_haar_submodule":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/-- A strict vector subspace has measure zero. -/\ntheorem add_haar_submodule {E : Type _} [normed_add_comm_group E] [normed_space (exprℝ) E] [measurable_space E]\n    [borel_space E] [finite_dimensional (exprℝ) E] (μ : measure E) [is_add_haar_measure μ] (s : submodule (exprℝ) E)\n    (hs : s ≠ «expr⊤») : μ s = 0 :=\n  by\n  obtain ⟨x, hx⟩ : ∃ x, x ∉ s := by simpa only [submodule.eq_top_iff', not_exists, ne.def, not_forall] using hs\n  obtain ⟨c, cpos, cone⟩ : ∃ c : exprℝ, 0 < c ∧ c < 1 := ⟨1 / 2, by norm_num, by norm_num⟩\n  have A : bounded (range fun n : ℕ => «expr • » (c ^ n) x) :=\n    haveI : tendsto (fun n : ℕ => «expr • » (c ^ n) x) at_top ((nhds) («expr • » (0 : exprℝ) x)) :=\n      (tendsto_pow_at_top_nhds_0_of_lt_1 cpos.le cone).smul_const x\n    bounded_range_of_tendsto _ this\n  apply add_haar_eq_zero_of_disjoint_translates μ _ A _ (submodule.closed_of_finite_dimensional s).measurable_set\n  intro m n hmn\n  simp only [function.on_fun, image_add_left, singleton_add, disjoint_left, mem_preimage, SetLike.mem_coe]\n  intro y hym hyn\n  have A : «expr • » (c ^ n - c ^ m) x ∈ s := by\n    convert s.sub_mem hym hyn\n    simp only [sub_smul, neg_sub_neg, add_sub_add_right_eq_sub]\n  have H : c ^ n - c ^ m ≠ 0 := by\n    simpa only [sub_eq_zero, ne.def] using (strictAnti_pow cpos cone).injective.ne hmn.symm\n  have : x ∈ s := by\n    convert s.smul_mem (c ^ n - c ^ m)⁻¹ A\n    rw [smul_smul, inv_mul_cancel H, one_smul]\n  exact hx this\n#align add_haar_submodule add_haar_submodule\n\n",
 "add_haar_sphere_of_ne_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem add_haar_sphere_of_ne_zero (x : E) {r : exprℝ} (hr : r ≠ 0) : μ (sphere x r) = 0 :=\n  by\n  rcases hr.lt_or_lt with (h | h)\n  · simp only [empty_diff, measure_empty, ← closed_ball_diff_ball, closed_ball_eq_empty.2 h]\n  ·\n    rw [← closed_ball_diff_ball, measure_diff ball_subset_closed_ball measurable_set_ball measure_ball_lt_top.ne,\n        add_haar_ball_of_pos μ _ h, add_haar_closed_ball μ _ h.le, tsub_self] <;>\n      infer_instance\n#align add_haar_sphere_of_ne_zero add_haar_sphere_of_ne_zero\n\n",
 "add_haar_sphere":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem add_haar_sphere [nontrivial E] (x : E) (r : exprℝ) : μ (sphere x r) = 0 :=\n  by\n  rcases eq_or_ne r 0 with (rfl | h)\n  · rw [sphere_zero, measure_singleton]\n  · exact add_haar_sphere_of_ne_zero μ x h\n#align add_haar_sphere add_haar_sphere\n\n",
 "add_haar_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- Rescaling a set by a factor `r` multiplies its measure by `abs (r ^ dim)`. -/\n@[simp]\ntheorem add_haar_smul (r : exprℝ) (s : set E) :\n    μ («expr • » r s) = ennreal.of_real (abs (r ^ finrank (exprℝ) E)) * μ s :=\n  by\n  rcases ne_or_eq r 0 with (h | rfl)\n  · rw [← preimage_smul_inv₀ h, add_haar_preimage_smul μ (inv_ne_zero h), inv_pow, inv_inv]\n  rcases eq_empty_or_nonempty s with (rfl | hs)\n  · simp only [measure_empty, mul_zero, smul_set_empty]\n  rw [zero_smul_set hs, ← singleton_zero]\n  by_cases h : finrank (exprℝ) E = 0\n  · haveI : subsingleton E := finrank_zero_iff.1 h\n    simp only [h, one_mul, ennreal.of_real_one, abs_one, Subsingleton.eq_univ_of_nonempty hs, pow_zero,\n      Subsingleton.eq_univ_of_nonempty (singleton_nonempty (0 : E))]\n  · haveI : nontrivial E := nontrivial_of_finrank_pos (bot_lt_iff_ne_bot.2 h)\n    simp only [h, zero_mul, ennreal.of_real_zero, abs_zero, ne.def, not_false_iff, zero_pow', measure_singleton]\n#align add_haar_smul add_haar_smul\n\n",
 "add_haar_singleton_add_smul_div_singleton_add_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem add_haar_singleton_add_smul_div_singleton_add_smul {r : exprℝ} (hr : r ≠ 0) (x y : E) (s t : set E) :\n    μ ({x} + «expr • » r s) / μ ({y} + «expr • » r t) = μ s / μ t :=\n  calc\n    μ ({x} + «expr • » r s) / μ ({y} + «expr • » r t) =\n        ennreal.of_real (|r| ^ finrank (exprℝ) E) * μ s * (ennreal.of_real (|r| ^ finrank (exprℝ) E) * μ t)⁻¹ :=\n      by simp only [div_eq_mul_inv, add_haar_smul, image_add_left, measure_preimage_add, abs_pow, singleton_add]\n    _ = ennreal.of_real (|r| ^ finrank (exprℝ) E) * (ennreal.of_real (|r| ^ finrank (exprℝ) E))⁻¹ * (μ s * (μ t)⁻¹) :=\n      by\n      rw [ennreal.mul_inv]\n      · ring\n      · simp only [pow_pos (abs_pos.mpr hr), ennreal.of_real_eq_zero, not_le, ne.def, true_or_iff]\n      · simp only [ennreal.of_real_ne_top, true_or_iff, ne.def, not_false_iff]\n    _ = μ s / μ t := by\n      rw [ennreal.mul_inv_cancel, one_mul, div_eq_mul_inv]\n      · simp only [pow_pos (abs_pos.mpr hr), ennreal.of_real_eq_zero, not_le, ne.def]\n      · simp only [ennreal.of_real_ne_top, ne.def, not_false_iff]\n    \n#align add_haar_singleton_add_smul_div_singleton_add_smul add_haar_singleton_add_smul_div_singleton_add_smul\n\n",
 "add_haar_preimage_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:219:4: warning: unsupported binary notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:219:4: warning: unsupported binary notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:219:4: warning: unsupported binary notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n@[simp]\ntheorem add_haar_preimage_smul {r : exprℝ} (hr : r ≠ 0) (s : set E) :\n    μ («expr ⁻¹' » ((«expr • » · ·) r) s) = ennreal.of_real (abs (r ^ finrank (exprℝ) E)⁻¹) * μ s :=\n  calc\n    μ («expr ⁻¹' » ((«expr • » · ·) r) s) = measure.map ((«expr • » · ·) r) μ s :=\n      ((homeomorph.smul (isUnit_iff_ne_zero.2 hr).unit).to_measurable_equiv.map_apply s).symm\n    _ = ennreal.of_real (abs (r ^ finrank (exprℝ) E)⁻¹) * μ s :=\n      by\n      rw [map_add_haar_smul μ hr]\n      rfl\n    \n#align add_haar_preimage_smul add_haar_preimage_smul\n\n",
 "add_haar_preimage_linear_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/-- The preimage of a set `s` under a linear map `f` with nonzero determinant has measure\nequal to `μ s` times the absolute value of the inverse of the determinant of `f`. -/\n@[simp]\ntheorem add_haar_preimage_linear_map {f : «expr →ₗ[ ] » E (exprℝ) E} (hf : f.det ≠ 0) (s : set E) :\n    μ («expr ⁻¹' » f s) = ennreal.of_real (abs f.det⁻¹) * μ s :=\n  calc\n    μ («expr ⁻¹' » f s) = measure.map f μ s :=\n      ((f.equiv_of_det_ne_zero hf).to_continuous_linear_equiv.to_homeomorph.to_measurable_equiv.map_apply s).symm\n    _ = ennreal.of_real (abs f.det⁻¹) * μ s :=\n      by\n      rw [map_linear_map_add_haar_eq_smul_add_haar μ hf]\n      rfl\n    \n#align add_haar_preimage_linear_map add_haar_preimage_linear_map\n\n",
 "add_haar_preimage_linear_equiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- The preimage of a set `s` under a linear equiv `f` has measure\nequal to `μ s` times the absolute value of the inverse of the determinant of `f`. -/\n@[simp]\ntheorem add_haar_preimage_linear_equiv (f : «expr ≃ₗ[ ] » E (exprℝ) E) (s : set E) :\n    μ («expr ⁻¹' » f s) = ennreal.of_real (abs (f.symm : «expr →ₗ[ ] » E (exprℝ) E).det) * μ s :=\n  by\n  have A : (f : «expr →ₗ[ ] » E (exprℝ) E).det ≠ 0 := (linear_equiv.is_unit_det' f).ne_zero\n  convert add_haar_preimage_linear_map μ A s\n  simp only [linear_equiv.det_coe_symm]\n#align add_haar_preimage_linear_equiv add_haar_preimage_linear_equiv\n\n",
 "add_haar_preimage_continuous_linear_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- The preimage of a set `s` under a continuous linear map `f` with nonzero determinant has measure\nequal to `μ s` times the absolute value of the inverse of the determinant of `f`. -/\n@[simp]\ntheorem add_haar_preimage_continuous_linear_map {f : «expr →L[ ] » E (exprℝ) E}\n    (hf : linear_map.det (f : «expr →ₗ[ ] » E (exprℝ) E) ≠ 0) (s : set E) :\n    μ («expr ⁻¹' » f s) = ennreal.of_real (abs (linear_map.det (f : «expr →ₗ[ ] » E (exprℝ) E))⁻¹) * μ s :=\n  add_haar_preimage_linear_map μ hf s\n#align add_haar_preimage_continuous_linear_map add_haar_preimage_continuous_linear_map\n\n",
 "add_haar_preimage_continuous_linear_equiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- The preimage of a set `s` under a continuous linear equiv `f` has measure\nequal to `μ s` times the absolute value of the inverse of the determinant of `f`. -/\n@[simp]\ntheorem add_haar_preimage_continuous_linear_equiv (f : «expr ≃L[ ] » E (exprℝ) E) (s : set E) :\n    μ («expr ⁻¹' » f s) = ennreal.of_real (abs (f.symm : «expr →ₗ[ ] » E (exprℝ) E).det) * μ s :=\n  add_haar_preimage_linear_equiv μ _ s\n#align add_haar_preimage_continuous_linear_equiv add_haar_preimage_continuous_linear_equiv\n\n",
 "add_haar_parallelepiped":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem add_haar_parallelepiped (b : basis ι (exprℝ) G) (v : ι → G) :\n    b.add_haar (parallelepiped v) = ennreal.of_real (|b.det v|) :=\n  by\n  have : finite_dimensional (exprℝ) G := finite_dimensional.of_fintype_basis b\n  have A : parallelepiped v = «expr '' » (b.constr ℕ v) (parallelepiped b) :=\n    by\n    rw [image_parallelepiped]\n    congr 1 with i\n    exact (b.constr_basis ℕ v i).symm\n  rw [A, add_haar_image_linear_map, basis.add_haar_self, mul_one, ← linear_map.det_to_matrix b, ←\n    basis.to_matrix_eq_to_matrix_constr]\n  rfl\n#align add_haar_parallelepiped add_haar_parallelepiped\n\n",
 "add_haar_measure_eq_volume_pi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- The Haar measure equals the Lebesgue measure on `ℝ^ι`. -/\ntheorem add_haar_measure_eq_volume_pi (ι : Type _) [fintype ι] : add_haar_measure (pi_Icc01 ι) = volume :=\n  by\n  convert (add_haar_measure_unique volume (pi_Icc01 ι)).symm\n  simp only [pi_Icc01, volume_pi_pi fun i => Icc (0 : exprℝ) 1, positive_compacts.coe_mk, compacts.coe_mk,\n    finset.prod_const_one, ennreal.of_real_one, real.volume_Icc, one_smul, sub_zero]\n#align add_haar_measure_eq_volume_pi add_haar_measure_eq_volume_pi\n\n",
 "add_haar_measure_eq_volume":
 "/-\nCopyright (c) 2021 Floris van Doorn. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Floris van Doorn, Sébastien Gouëzel\n-/\n/-- The Haar measure equals the Lebesgue measure on `ℝ`. -/\ntheorem add_haar_measure_eq_volume : add_haar_measure Icc01 = volume :=\n  by\n  convert (add_haar_measure_unique volume Icc01).symm\n  simp [Icc01]\n#align add_haar_measure_eq_volume add_haar_measure_eq_volume\n\n",
 "add_haar_image_linear_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/-- The image of a set `s` under a linear map `f` has measure\nequal to `μ s` times the absolute value of the determinant of `f`. -/\n@[simp]\ntheorem add_haar_image_linear_map (f : «expr →ₗ[ ] » E (exprℝ) E) (s : set E) :\n    μ («expr '' » f s) = ennreal.of_real (abs f.det) * μ s :=\n  by\n  rcases ne_or_eq f.det 0 with (hf | hf)\n  · let g := (f.equiv_of_det_ne_zero hf).to_continuous_linear_equiv\n    change μ («expr '' » g s) = _\n    rw [continuous_linear_equiv.image_eq_preimage g s, add_haar_preimage_continuous_linear_equiv]\n    congr\n    ext x\n    simp only [linear_equiv.coe_to_continuous_linear_equiv, linear_equiv.of_is_unit_det_apply, linear_equiv.coe_coe,\n      continuous_linear_equiv.symm_symm]\n  · simp only [hf, zero_mul, ennreal.of_real_zero, abs_zero]\n    have : μ f.range = 0 := add_haar_submodule μ _ (linear_map.range_lt_top_of_det_eq_zero hf).ne\n    exact le_antisymm (le_trans (measure_mono (image_subset_range _ _)) this.le) (zero_le _)\n#align add_haar_image_linear_map add_haar_image_linear_map\n\n",
 "add_haar_image_homothety":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n@[simp]\ntheorem add_haar_image_homothety (x : E) (r : exprℝ) (s : set E) :\n    μ («expr '' » (affine_map.homothety x r) s) = ennreal.of_real (abs (r ^ finrank (exprℝ) E)) * μ s :=\n  calc\n    μ («expr '' » (affine_map.homothety x r) s) =\n        μ («expr '' » (fun y => y + x) («expr • » r («expr '' » (fun y => y + -x) s))) :=\n      by\n      simp only [← image_smul, image_image, ← sub_eq_add_neg]\n      rfl\n    _ = ennreal.of_real (abs (r ^ finrank (exprℝ) E)) * μ s := by\n      simp only [image_add_right, measure_preimage_add_right, add_haar_smul]\n    \n#align add_haar_image_homothety add_haar_image_homothety\n\n",
 "add_haar_image_continuous_linear_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- The image of a set `s` under a continuous linear map `f` has measure\nequal to `μ s` times the absolute value of the determinant of `f`. -/\n@[simp]\ntheorem add_haar_image_continuous_linear_map (f : «expr →L[ ] » E (exprℝ) E) (s : set E) :\n    μ («expr '' » f s) = ennreal.of_real (abs (f : «expr →ₗ[ ] » E (exprℝ) E).det) * μ s :=\n  add_haar_image_linear_map μ _ s\n#align add_haar_image_continuous_linear_map add_haar_image_continuous_linear_map\n\n",
 "add_haar_image_continuous_linear_equiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- The image of a set `s` under a continuous linear equiv `f` has measure\nequal to `μ s` times the absolute value of the determinant of `f`. -/\n@[simp]\ntheorem add_haar_image_continuous_linear_equiv (f : «expr ≃L[ ] » E (exprℝ) E) (s : set E) :\n    μ («expr '' » f s) = ennreal.of_real (abs (f : «expr →ₗ[ ] » E (exprℝ) E).det) * μ s :=\n  μ.add_haar_image_linear_map (f : «expr →ₗ[ ] » E (exprℝ) E) s\n#align add_haar_image_continuous_linear_equiv add_haar_image_continuous_linear_equiv\n\n",
 "add_haar_eq_zero_of_disjoint_translates_aux":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr on » -/\n/-- If a set is disjoint of its translates by infinitely many bounded vectors, then it has measure\nzero. This auxiliary lemma proves this assuming additionally that the set is bounded. -/\ntheorem add_haar_eq_zero_of_disjoint_translates_aux {E : Type _} [normed_add_comm_group E] [normed_space (exprℝ) E]\n    [measurable_space E] [borel_space E] [finite_dimensional (exprℝ) E] (μ : measure E) [is_add_haar_measure μ]\n    {s : set E} (u : ℕ → E) (sb : bounded s) (hu : bounded (range u))\n    (hs : Pairwise («expr on » Disjoint fun n => {u n} + s)) (h's : measurable_set s) : μ s = 0 :=\n  by\n  by_contra h\n  apply lt_irrefl (ennreal.top)\n  calc\n    ennreal.top =\n        «expr∑' , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , »\" (μ s) :=\n      (ennreal.tsum_const_eq_top_of_ne_zero h).symm\n    _ =\n        «expr∑' , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , »\"\n          (μ ({u n} + s)) :=\n      by\n      congr 1\n      ext1 n\n      simp only [image_add_left, measure_preimage_add, singleton_add]\n    _ =\n        μ\n          («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n            ({u n} + s)) :=\n      by\n      rw [measure_Union hs fun n => by simpa only [image_add_left, singleton_add] using measurable_id.const_add _ h's]\n    _ = μ (range u + s) := by rw [← Union_add, Union_singleton_eq_range]\n    _ < ennreal.top := bounded.measure_lt_top (hu.add sb)\n    \n#align add_haar_eq_zero_of_disjoint_translates_aux add_haar_eq_zero_of_disjoint_translates_aux\n\n",
 "add_haar_eq_zero_of_disjoint_translates":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr on » -/\n/-- If a set is disjoint of its translates by infinitely many bounded vectors, then it has measure\nzero. -/\ntheorem add_haar_eq_zero_of_disjoint_translates {E : Type _} [normed_add_comm_group E] [normed_space (exprℝ) E]\n    [measurable_space E] [borel_space E] [finite_dimensional (exprℝ) E] (μ : measure E) [is_add_haar_measure μ]\n    {s : set E} (u : ℕ → E) (hu : bounded (range u)) (hs : Pairwise («expr on » Disjoint fun n => {u n} + s))\n    (h's : measurable_set s) : μ s = 0 :=\n  by\n  suffices H : ∀ R, μ (s ∩ closed_ball 0 R) = 0\n  · apply le_antisymm _ (zero_le _)\n    calc\n      μ s ≤\n          «expr∑' , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , »\"\n            (μ (s ∩ closed_ball 0 n)) :=\n        by\n        conv_lhs => rw [← Union_inter_closed_ball_nat s 0]\n        exact measure_Union_le _\n      _ = 0 := by simp only [H, tsum_zero]\n      \n  intro R\n  apply\n    add_haar_eq_zero_of_disjoint_translates_aux μ u (bounded.mono (inter_subset_right _ _) bounded_closed_ball) hu _\n      (h's.inter measurable_set_closed_ball)\n  apply pairwise_disjoint_mono hs fun n => _\n  exact add_subset_add (subset.refl _) (inter_subset_left _ _)\n#align add_haar_eq_zero_of_disjoint_translates add_haar_eq_zero_of_disjoint_translates\n\n",
 "add_haar_closed_unit_ball_eq_add_haar_unit_ball":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.lt -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem add_haar_closed_unit_ball_eq_add_haar_unit_ball : μ (closed_ball (0 : E) 1) = μ (ball 0 1) :=\n  by\n  apply le_antisymm _ (measure_mono ball_subset_closed_ball)\n  have A :\n    tendsto (fun r : exprℝ => ennreal.of_real (r ^ finrank (exprℝ) E) * μ (closed_ball (0 : E) 1)) (nhds_within.lt 1)\n      ((nhds) (ennreal.of_real (1 ^ finrank (exprℝ) E) * μ (closed_ball (0 : E) 1))) :=\n    by\n    refine' ennreal.tendsto.mul _ (by simp) tendsto_const_nhds (by simp)\n    exact ennreal.tendsto_of_real ((tendsto_id'.2 nhds_within_le_nhds).pow _)\n  simp only [one_pow, one_mul, ennreal.of_real_one] at A\n  refine' le_of_tendsto A _\n  refine' mem_nhds_within_Iio_iff_exists_Ioo_subset.2 ⟨(0 : exprℝ), by simp, fun r hr => _⟩\n  dsimp\n  rw [← add_haar_closed_ball' μ (0 : E) hr.1.le]\n  exact measure_mono (closed_ball_subset_ball hr.2)\n#align add_haar_closed_unit_ball_eq_add_haar_unit_ball add_haar_closed_unit_ball_eq_add_haar_unit_ball\n\n",
 "add_haar_closed_ball_mul_of_pos":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem add_haar_closed_ball_mul_of_pos (x : E) {r : exprℝ} (hr : 0 < r) (s : exprℝ) :\n    μ (closed_ball x (r * s)) = ennreal.of_real (r ^ finrank (exprℝ) E) * μ (closed_ball 0 s) :=\n  by\n  have : closed_ball (0 : E) (r * s) = «expr • » r (closed_ball 0 s) := by\n    simp [smul_closed_ball' hr.ne' (0 : E), abs_of_nonneg hr.le]\n  simp only [this, add_haar_smul, abs_of_nonneg hr.le, add_haar_closed_ball_center, abs_pow]\n#align add_haar_closed_ball_mul_of_pos add_haar_closed_ball_mul_of_pos\n\n",
 "add_haar_closed_ball_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem add_haar_closed_ball_mul (x : E) {r : exprℝ} (hr : 0 ≤ r) {s : exprℝ} (hs : 0 ≤ s) :\n    μ (closed_ball x (r * s)) = ennreal.of_real (r ^ finrank (exprℝ) E) * μ (closed_ball 0 s) :=\n  by\n  have : closed_ball (0 : E) (r * s) = «expr • » r (closed_ball 0 s) := by\n    simp [smul_closed_ball r (0 : E) hs, abs_of_nonneg hr]\n  simp only [this, add_haar_smul, abs_of_nonneg hr, add_haar_closed_ball_center, abs_pow]\n#align add_haar_closed_ball_mul add_haar_closed_ball_mul\n\n",
 "add_haar_closed_ball_eq_add_haar_ball":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem add_haar_closed_ball_eq_add_haar_ball [nontrivial E] (x : E) (r : exprℝ) : μ (closed_ball x r) = μ (ball x r) :=\n  by\n  by_cases h : r < 0\n  · rw [metric.closed_ball_eq_empty.mpr h, metric.ball_eq_empty.mpr h.le]\n  push_neg  at h\n  rw [add_haar_closed_ball μ x h, add_haar_ball μ x h]\n#align add_haar_closed_ball_eq_add_haar_ball add_haar_closed_ball_eq_add_haar_ball\n\n",
 "add_haar_closed_ball_center":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem add_haar_closed_ball_center {E : Type _} [normed_add_comm_group E] [measurable_space E] [borel_space E]\n    (μ : measure E) [is_add_haar_measure μ] (x : E) (r : exprℝ) : μ (closed_ball x r) = μ (closed_ball (0 : E) r) :=\n  by\n  have : closed_ball (0 : E) r = «expr ⁻¹' » ((· + ·) x) (closed_ball x r) := by simp [preimage_add_closed_ball]\n  rw [this, measure_preimage_add]\n#align add_haar_closed_ball_center add_haar_closed_ball_center\n\n",
 "add_haar_closed_ball'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- The measure of a closed ball can be expressed in terms of the measure of the closed unit ball.\nUse instead `add_haar_closed_ball`, which uses the measure of the open unit ball as a standard\nform. -/\ntheorem add_haar_closed_ball' (x : E) {r : exprℝ} (hr : 0 ≤ r) :\n    μ (closed_ball x r) = ennreal.of_real (r ^ finrank (exprℝ) E) * μ (closed_ball 0 1) := by\n  rw [← add_haar_closed_ball_mul μ x hr zero_le_one, mul_one]\n#align add_haar_closed_ball' add_haar_closed_ball'\n\n",
 "add_haar_closed_ball":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem add_haar_closed_ball (x : E) {r : exprℝ} (hr : 0 ≤ r) :\n    μ (closed_ball x r) = ennreal.of_real (r ^ finrank (exprℝ) E) * μ (ball 0 1) := by\n  rw [add_haar_closed_ball' μ x hr, add_haar_closed_unit_ball_eq_add_haar_unit_ball]\n#align add_haar_closed_ball add_haar_closed_ball\n\n",
 "add_haar_ball_of_pos":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem add_haar_ball_of_pos (x : E) {r : exprℝ} (hr : 0 < r) :\n    μ (ball x r) = ennreal.of_real (r ^ finrank (exprℝ) E) * μ (ball 0 1) := by\n  rw [← add_haar_ball_mul_of_pos μ x hr, mul_one]\n#align add_haar_ball_of_pos add_haar_ball_of_pos\n\n",
 "add_haar_ball_mul_of_pos":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem add_haar_ball_mul_of_pos (x : E) {r : exprℝ} (hr : 0 < r) (s : exprℝ) :\n    μ (ball x (r * s)) = ennreal.of_real (r ^ finrank (exprℝ) E) * μ (ball 0 s) :=\n  by\n  have : ball (0 : E) (r * s) = «expr • » r (ball 0 s) := by\n    simp only [smul_ball hr.ne' (0 : E) s, real.norm_eq_abs, abs_of_nonneg hr.le, smul_zero]\n  simp only [this, add_haar_smul, abs_of_nonneg hr.le, add_haar_ball_center, abs_pow]\n#align add_haar_ball_mul_of_pos add_haar_ball_mul_of_pos\n\n",
 "add_haar_ball_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem add_haar_ball_mul [nontrivial E] (x : E) {r : exprℝ} (hr : 0 ≤ r) (s : exprℝ) :\n    μ (ball x (r * s)) = ennreal.of_real (r ^ finrank (exprℝ) E) * μ (ball 0 s) :=\n  by\n  rcases has_le.le.eq_or_lt hr with (h | h)\n  · simp only [← h, zero_pow finrank_pos, measure_empty, zero_mul, ennreal.of_real_zero, ball_zero]\n  · exact add_haar_ball_mul_of_pos μ x h s\n#align add_haar_ball_mul add_haar_ball_mul\n\n",
 "add_haar_ball_center":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem add_haar_ball_center {E : Type _} [normed_add_comm_group E] [measurable_space E] [borel_space E] (μ : measure E)\n    [is_add_haar_measure μ] (x : E) (r : exprℝ) : μ (ball x r) = μ (ball (0 : E) r) :=\n  by\n  have : ball (0 : E) r = «expr ⁻¹' » ((· + ·) x) (ball x r) := by simp [preimage_add_ball]\n  rw [this, measure_preimage_add]\n#align add_haar_ball_center add_haar_ball_center\n\n",
 "add_haar_ball":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem add_haar_ball [nontrivial E] (x : E) {r : exprℝ} (hr : 0 ≤ r) :\n    μ (ball x r) = ennreal.of_real (r ^ finrank (exprℝ) E) * μ (ball 0 1) := by rw [← add_haar_ball_mul μ x hr, mul_one]\n#align add_haar_ball add_haar_ball\n\n",
 "add_haar_affine_subspace":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/-- A strict affine subspace has measure zero. -/\ntheorem add_haar_affine_subspace {E : Type _} [normed_add_comm_group E] [normed_space (exprℝ) E] [measurable_space E]\n    [borel_space E] [finite_dimensional (exprℝ) E] (μ : measure E) [is_add_haar_measure μ]\n    (s : affine_subspace (exprℝ) E) (hs : s ≠ «expr⊤») : μ s = 0 :=\n  by\n  rcases s.eq_bot_or_nonempty with (rfl | hne)\n  · rw [affine_subspace.bot_coe, measure_empty]\n  rw [ne.def, ← affine_subspace.direction_eq_top_iff_of_nonempty hne] at hs\n  rcases hne with ⟨x, hx : x ∈ s⟩\n  simpa only [affine_subspace.coe_direction_eq_vsub_set_right hx, vsub_eq_sub, sub_eq_add_neg, image_add_right, neg_neg,\n    measure_preimage_add_right] using add_haar_submodule μ s.direction hs\n#align add_haar_affine_subspace add_haar_affine_subspace\n\n"}