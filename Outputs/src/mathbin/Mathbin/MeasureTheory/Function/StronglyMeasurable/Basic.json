{"tendsto_approx_bounded_of_norm_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `strongly_measurable_of -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem tendsto_approx_bounded_of_norm_le {β} {f : α → β} [NormedAddCommGroup β] [NormedSpace (exprℝ) β]\n    {m : MeasurableSpace α} (hf : (strongly_measurable_of m) f) {c : exprℝ} {x : α} (hfx : «expr‖ ‖» (f x) ≤ c) :\n    Tendsto (fun n => hf.approx_bounded c n x) atTop ((nhds) (f x)) :=\n  by\n  have h_tendsto := hf.tendsto_approx x\n  simp only [strongly_measurable.approx_bounded, simple_func.coe_map, Function.comp_apply]\n  by_cases hfx0 : «expr‖ ‖» (f x) = 0\n  · rw [norm_eq_zero] at hfx0\n    rw [hfx0] at h_tendsto⊢\n    have h_tendsto_norm : tendsto (fun n => «expr‖ ‖» (hf.approx n x)) at_top ((nhds) 0) :=\n      by\n      convert h_tendsto.norm\n      rw [norm_zero]\n    refine' squeeze_zero_norm (fun n => _) h_tendsto_norm\n    calc\n      «expr‖ ‖» («expr • » (min 1 (c / «expr‖ ‖» (hf.approx n x))) (hf.approx n x)) =\n          «expr‖ ‖» (min 1 (c / «expr‖ ‖» (hf.approx n x))) * «expr‖ ‖» (hf.approx n x) :=\n        norm_smul _ _\n      _ ≤ «expr‖ ‖» (1 : exprℝ) * «expr‖ ‖» (hf.approx n x) :=\n        by\n        refine' mul_le_mul_of_nonneg_right _ (norm_nonneg _)\n        rw [norm_one, Real.norm_of_nonneg]\n        · exact min_le_left _ _\n        · exact le_min zero_le_one (div_nonneg ((norm_nonneg _).trans hfx) (norm_nonneg _))\n      _ = «expr‖ ‖» (hf.approx n x) := by rw [norm_one, one_mul]\n      \n  rw [← one_smul (exprℝ) (f x)]\n  refine' tendsto.smul _ h_tendsto\n  have : min 1 (c / «expr‖ ‖» (f x)) = 1 :=\n    by\n    rw [min_eq_left_iff, one_le_div (lt_of_le_of_ne (norm_nonneg _) (ne.symm hfx0))]\n    exact hfx\n  nth_rw 1 [this.symm]\n  refine' tendsto.min tendsto_const_nhds _\n  refine' tendsto.div tendsto_const_nhds h_tendsto.norm hfx0\n#align tendsto_approx_bounded_of_norm_le tendsto_approx_bounded_of_norm_le\n\n",
 "tendsto_approx_bounded_ae":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `strongly_measurable_of -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem tendsto_approx_bounded_ae {β} {f : α → β} [NormedAddCommGroup β] [NormedSpace (exprℝ) β]\n    {m m0 : MeasurableSpace α} {μ : Measure α} (hf : (strongly_measurable_of m) f) {c : exprℝ}\n    (hf_bound :\n      «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\" μ\n        («expr‖ ‖» (f x) ≤ c)) :\n    «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\" μ\n      (Tendsto (fun n => hf.approx_bounded c n x) atTop ((nhds) (f x))) :=\n  by filter_upwards [hf_bound]with x hfx using tendsto_approx_bounded_of_norm_le hf hfx\n#align tendsto_approx_bounded_ae tendsto_approx_bounded_ae\n\n",
 "tendsto_approx":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\nprotected theorem tendsto_approx : ∀ x, Tendsto (fun n => hf.approx n x) atTop ((nhds) (f x)) :=\n  hf.some_spec.2\n#align tendsto_approx tendsto_approx\n\n",
 "sup":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\nprotected theorem sup [SemilatticeSup β] [ContinuousSup β] (hf : ae_fin_strongly_measurable f μ)\n    (hg : ae_fin_strongly_measurable g μ) : ae_fin_strongly_measurable («expr ⊔ » f g) μ :=\n  ⟨«expr ⊔ » (hf.mk f) (hg.mk g), hf.fin_strongly_measurable_mk.sup hg.fin_strongly_measurable_mk,\n    hf.ae_eq_mk.sup hg.ae_eq_mk⟩\n#align sup sup\n\n",
 "sum_measure":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\ntheorem sum_measure [pseudo_metrizable_space β] {m : MeasurableSpace α} {μ : ι → Measure α}\n    (h : ∀ i, ae_strongly_measurable f (μ i)) : ae_strongly_measurable f (Measure.sum μ) :=\n  by\n  borelize β\n  refine'\n    ae_strongly_measurable_iff_ae_measurable_separable.2 ⟨AEMeasurable.sum_measure fun i => (h i).ae_measurable, _⟩\n  have A : ∀ i : ι, ∃ t : Set β, is_separable t ∧ «expr ⁻¹' » f t ∈ (μ i).ae := fun i =>\n    (ae_strongly_measurable_iff_ae_measurable_separable.1 (h i)).2\n  choose t t_sep ht using A\n  refine'\n    ⟨«expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (t i),\n      is_separable_Union t_sep, _⟩\n  simp only [measure.ae_sum_eq, mem_Union, eventually_supr]\n  intro i\n  filter_upwards [ht i]with x hx\n  exact ⟨i, hx⟩\n#align sum_measure sum_measure\n\n",
 "sub":
 "protected theorem sub [AddGroup β] [ContinuousSub β] (hf : ae_fin_strongly_measurable f μ)\n    (hg : ae_fin_strongly_measurable g μ) : ae_fin_strongly_measurable (f - g) μ :=\n  ⟨hf.mk f - hg.mk g, hf.fin_strongly_measurable_mk.sub hg.fin_strongly_measurable_mk, hf.ae_eq_mk.sub hg.ae_eq_mk⟩\n#align sub sub\n\n",
 "strongly_measurable_uncurry_of_continuous_of_strongly_measurable":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↥ » -/\ntheorem strongly_measurable_uncurry_of_continuous_of_strongly_measurable {α β ι : Type _} [TopologicalSpace ι]\n    [metrizable_space ι] [MeasurableSpace ι] [SecondCountableTopology ι] [opens_measurable_space ι] [TopologicalSpace β]\n    [pseudo_metrizable_space β] [MeasurableSpace α] {u : ι → α → β} (hu_cont : ∀ x, Continuous fun i => u i x)\n    (h : ∀ i, strongly_measurable (u i)) : strongly_measurable (function.uncurry u) :=\n  by\n  borelize β\n  obtain ⟨t_sf, ht_sf⟩ : ∃ t : ℕ → simple_func ι ι, ∀ j x, tendsto (fun n => u (t n j) x) at_top (nhds <| u j x) :=\n    by\n    have h_str_meas : strongly_measurable (id : ι → ι) := strongly_measurable_id\n    refine' ⟨h_str_meas.approx, fun j x => _⟩\n    exact ((hu_cont x).tendsto j).comp (h_str_meas.tendsto_approx j)\n  let U (n : ℕ) (p : ι × α) := u (t_sf n p.fst) p.snd\n  have h_tendsto : tendsto U at_top ((nhds) fun p => u p.fst p.snd) :=\n    by\n    rw [tendsto_pi_nhds]\n    exact fun p => ht_sf p.fst p.snd\n  refine' strongly_measurable_of_tendsto _ (fun n => _) h_tendsto\n  have h_str_meas : strongly_measurable fun p : (t_sf n).range × α => u (↑p.fst) p.snd :=\n    by\n    refine' strongly_measurable_iff_measurable_separable.2 ⟨_, _⟩\n    · have :\n        (fun p : «expr↥ » (t_sf n).range × α => u (↑p.fst) p.snd) =\n          (fun p : α × (t_sf n).range => u (↑p.snd) p.fst) ∘ Prod.swap :=\n        rfl\n      rw [this, measurable_swap_iff]\n      exact measurable_from_prod_countable fun j => (h j).measurable\n    · have :\n        is_separable\n          («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n            (range (u i))) :=\n        is_separable_Union fun i => (h i).is_separable_range\n      apply this.mono\n      rintro _ ⟨⟨i, x⟩, rfl⟩\n      simp only [mem_Union, mem_range]\n      exact ⟨i, x, rfl⟩\n  have :\n    (fun p : ι × α => u (t_sf n p.fst) p.snd) =\n      (fun p : «expr↥ » (t_sf n).range × α => u p.fst p.snd) ∘ fun p : ι × α =>\n        (⟨t_sf n p.fst, simple_func.mem_range_self _ _⟩, p.snd) :=\n    rfl\n  simp_rw [U, this]\n  refine' h_str_meas.comp_measurable (Measurable.prod_mk _ measurable_snd)\n  exact ((t_sf n).measurable.comp measurable_fst).subtype_mk\n#align strongly_measurable_uncurry_of_continuous_of_strongly_measurable strongly_measurable_uncurry_of_continuous_of_strongly_measurable\n\n",
 "strongly_measurable_prod'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n@[to_additive]\ntheorem _root_.finset.strongly_measurable_prod' {ι : Type _} {f : ι → α → M} (s : Finset ι)\n    (hf : ∀ i ∈ s, strongly_measurable (f i)) :\n    strongly_measurable\n      (finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f i)) :=\n  Finset.prod_induction _ _ (fun a b ha hb => ha.mul hb) (@strongly_measurable_one α M _ _ _) hf\n#align finset.strongly_measurable_prod' finset.strongly_measurable_prod'\n\n",
 "strongly_measurable_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n@[to_additive]\ntheorem _root_.finset.strongly_measurable_prod {ι : Type _} {f : ι → α → M} (s : Finset ι)\n    (hf : ∀ i ∈ s, strongly_measurable (f i)) :\n    strongly_measurable fun a =>\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f i a) :=\n  by simpa only [← Finset.prod_apply] using s.strongly_measurable_prod' hf\n#align finset.strongly_measurable_prod finset.strongly_measurable_prod\n\n",
 "strongly_measurable_one":
 "@[to_additive]\ntheorem strongly_measurable_one {α β} {m : MeasurableSpace α} [TopologicalSpace β] [One β] :\n    strongly_measurable (1 : α → β) :=\n  @strongly_measurable_const _ _ _ _ 1\n#align strongly_measurable_one strongly_measurable_one\n\n",
 "strongly_measurable_of_tendsto":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- A sequential limit of strongly measurable functions is strongly measurable. -/\ntheorem _root_.strongly_measurable_of_tendsto {ι : Type _} {m : MeasurableSpace α} [TopologicalSpace β]\n    [pseudo_metrizable_space β] (u : Filter ι) [NeBot u] [IsCountablyGenerated u] {f : ι → α → β} {g : α → β}\n    (hf : ∀ i, strongly_measurable (f i)) (lim : Tendsto f u ((nhds) g)) : strongly_measurable g :=\n  by\n  borelize β\n  refine' strongly_measurable_iff_measurable_separable.2 ⟨_, _⟩\n  · exact measurable_of_tendsto_metrizable' u (fun i => (hf i).measurable) limUnder\n  · rcases u.exists_seq_tendsto with ⟨v, hv⟩\n    have :\n      is_separable\n        (closure\n          («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n            (range (f (v i))))) :=\n      (is_separable_Union fun i => (hf (v i)).is_separable_range).closure\n    apply this.mono\n    rintro _ ⟨x, rfl⟩\n    rw [tendsto_pi_nhds] at lim\n    apply mem_closure_of_tendsto ((limUnder x).comp hv)\n    apply eventually_of_forall fun n => _\n    apply mem_Union_of_mem n\n    exact mem_range_self _\n#align strongly_measurable_of_tendsto strongly_measurable_of_tendsto\n\n",
 "strongly_measurable_of_strongly_measurable_union_cover":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛ » -/\ntheorem _root_.strongly_measurable_of_strongly_measurable_union_cover {m : MeasurableSpace α} [TopologicalSpace β]\n    {f : α → β} (s t : Set α) (hs : MeasurableSet s) (ht : MeasurableSet t) (h : univ ⊆ s ∪ t)\n    (hc : strongly_measurable fun a : s => f a) (hd : strongly_measurable fun a : t => f a) : strongly_measurable f :=\n  by\n  classical\n    let f : ℕ → «expr →ₛ » α β := fun n =>\n      { to_fun := fun x =>\n          if hx : x ∈ s then hc.approx n ⟨x, hx⟩ else hd.approx n ⟨x, by simpa [hx] using h (mem_univ x)⟩\n        measurable_set_fiber' := by\n          intro x\n          convert(hs.subtype_image ((hc.approx n).measurable_set_fiber x)).union\n              ((ht.subtype_image ((hd.approx n).measurable_set_fiber x)).diff hs)\n          ext1 y\n          simp only [mem_union, mem_preimage, mem_singleton_iff, mem_image, SetCoe.exists, Subtype.coe_mk,\n            exists_and_right, exists_eq_right, mem_diff]\n          by_cases hy : y ∈ s\n          · rw [dif_pos hy]\n            simp only [hy, exists_true_left, not_true, and_false_iff, or_false_iff]\n          · rw [dif_neg hy]\n            have A : y ∈ t := by simpa [hy] using h (mem_univ y)\n            simp only [A, hy, false_or_iff, IsEmpty.exists_iff, not_false_iff, and_true_iff, exists_true_left]\n        finite_range' := by\n          apply ((hc.approx n).finite_range.union (hd.approx n).finite_range).subset\n          rintro - ⟨y, rfl⟩\n          dsimp\n          by_cases hy : y ∈ s\n          · left\n            rw [dif_pos hy]\n            exact mem_range_self _\n          · right\n            rw [dif_neg hy]\n            exact mem_range_self _ }\n    refine' ⟨f, fun y => _⟩\n    by_cases hy : y ∈ s\n    · convert hc.tendsto_approx ⟨y, hy⟩ using 1\n      ext1 n\n      simp only [dif_pos hy, simple_func.apply_mk]\n    · have A : y ∈ t := by simpa [hy] using h (mem_univ y)\n      convert hd.tendsto_approx ⟨y, A⟩ using 1\n      ext1 n\n      simp only [dif_neg hy, simple_func.apply_mk]\n#align strongly_measurable_of_strongly_measurable_union_cover strongly_measurable_of_strongly_measurable_union_cover\n\n",
 "strongly_measurable_of_restrict_of_restrict_compl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\ntheorem _root_.strongly_measurable_of_restrict_of_restrict_compl {m : MeasurableSpace α} [TopologicalSpace β]\n    {f : α → β} {s : Set α} (hs : MeasurableSet s) (h₁ : strongly_measurable (s.restrict f))\n    (h₂ : strongly_measurable ((«expr ᶜ» s).restrict f)) : strongly_measurable f :=\n  strongly_measurable_of_strongly_measurable_union_cover s («expr ᶜ» s) hs hs.compl (union_compl_self s).ge h₁ h₂\n#align strongly_measurable_of_restrict_of_restrict_compl strongly_measurable_of_restrict_of_restrict_compl\n\n",
 "strongly_measurable_of_measurable_space_le_on":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `strongly_measurable_of -/\n/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (x «expr ∉ » s) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `strongly_measurable_of -/\n/-- If the restriction to a set `s` of a σ-algebra `m` is included in the restriction to `s` of\nanother σ-algebra `m₂` (hypothesis `hs`), the set `s` is `m` measurable and a function `f` supported\non `s` is `m`-strongly-measurable, then `f` is also `m₂`-strongly-measurable. -/\ntheorem strongly_measurable_of_measurable_space_le_on {α E} {m m₂ : MeasurableSpace α} [TopologicalSpace E] [Zero E]\n    {s : Set α} {f : α → E} (hs_m : (measurable_set_of m) s)\n    (hs : ∀ t, (measurable_set_of m) (s ∩ t) → (measurable_set_of m₂) (s ∩ t)) (hf : (strongly_measurable_of m) f)\n    (hf_zero : ∀ (x) (_ : x ∉ s), f x = 0) : (strongly_measurable_of m₂) f :=\n  by\n  have hs_m₂ : (measurable_set_of m₂) s := by\n    rw [← Set.inter_univ s]\n    refine' hs Set.univ _\n    rwa [Set.inter_univ]\n  obtain ⟨g_seq_s, hg_seq_tendsto, hg_seq_zero⟩ := strongly_measurable_in_set hs_m hf hf_zero\n  let g_seq_s₂ : ℕ → @simple_func α m₂ E := fun n =>\n    { to_fun := g_seq_s n\n      measurable_set_fiber' := fun x =>\n        by\n        rw [← Set.inter_univ («expr ⁻¹' » (g_seq_s n) {x}), ← Set.union_compl_self s, Set.inter_union_distrib_left,\n          Set.inter_comm («expr ⁻¹' » (g_seq_s n) {x})]\n        refine' MeasurableSet.union (hs _ (hs_m.inter _)) _\n        · exact @simple_func.measurable_set_fiber _ _ m _ _\n        by_cases hx : x = 0\n        · suffices «expr ⁻¹' » (g_seq_s n) {x} ∩ «expr ᶜ» s = «expr ᶜ» s\n            by\n            rw [this]\n            exact hs_m₂.compl\n          ext1 y\n          rw [hx, Set.mem_inter_iff, Set.mem_preimage, Set.mem_singleton_iff]\n          exact ⟨fun h => h.2, fun h => ⟨hg_seq_zero y h n, h⟩⟩\n        · suffices «expr ⁻¹' » (g_seq_s n) {x} ∩ «expr ᶜ» s = ∅\n            by\n            rw [this]\n            exact MeasurableSet.empty\n          ext1 y\n          simp only [mem_inter_iff, mem_preimage, mem_singleton_iff, mem_compl_iff, mem_empty_iff_false, iff_false_iff,\n            not_and, not_not_mem]\n          refine' imp_of_not_imp_not _ _ fun hys => _\n          rw [hg_seq_zero y hys n]\n          exact ne.symm hx\n      finite_range' := @simple_func.finite_range _ _ m (g_seq_s n) }\n  have hg_eq : ∀ x n, g_seq_s₂ n x = g_seq_s n x := fun x n => rfl\n  refine' ⟨g_seq_s₂, fun x => _⟩\n  simp_rw [hg_eq]\n  exact hg_seq_tendsto x\n#align strongly_measurable_of_measurable_space_le_on strongly_measurable_of_measurable_space_le_on\n\n",
 "strongly_measurable_of_is_empty":
 "theorem strongly_measurable_of_is_empty [IsEmpty α] {m : MeasurableSpace α} [TopologicalSpace β] (f : α → β) :\n    strongly_measurable f :=\n  ⟨fun n => simple_func.of_is_empty, isEmptyElim⟩\n#align strongly_measurable_of_is_empty strongly_measurable_of_is_empty\n\n",
 "strongly_measurable_mk":
 "theorem strongly_measurable_mk (hf : ae_strongly_measurable f μ) : strongly_measurable (hf.mk f) :=\n  hf.some_spec.1\n#align strongly_measurable_mk strongly_measurable_mk\n\n",
 "strongly_measurable_in_set":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (x «expr ∉ » s) -/\n/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (x «expr ∉ » s) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (x «expr ∉ » s) -/\ntheorem strongly_measurable_in_set {m : MeasurableSpace α} [TopologicalSpace β] [Zero β] {s : Set α} {f : α → β}\n    (hs : MeasurableSet s) (hf : strongly_measurable f) (hf_zero : ∀ (x) (_ : x ∉ s), f x = 0) :\n    ∃ fs : ℕ → «expr →ₛ » α β,\n      (∀ x, Tendsto (fun n => fs n x) atTop ((nhds) (f x))) ∧ ∀ (x) (_ : x ∉ s) (n), fs n x = 0 :=\n  by\n  let g_seq_s : ℕ → @simple_func α m β := fun n => (hf.approx n).restrict s\n  have hg_eq : ∀ x ∈ s, ∀ n, g_seq_s n x = hf.approx n x :=\n    by\n    intro x hx n\n    rw [simple_func.coe_restrict _ hs, Set.indicator_of_mem hx]\n  have hg_zero : ∀ (x) (_ : x ∉ s), ∀ n, g_seq_s n x = 0 :=\n    by\n    intro x hx n\n    rw [simple_func.coe_restrict _ hs, Set.indicator_of_not_mem hx]\n  refine' ⟨g_seq_s, fun x => _, hg_zero⟩\n  by_cases hx : x ∈ s\n  · simp_rw [hg_eq x hx]\n    exact hf.tendsto_approx x\n  · simp_rw [hg_zero x hx, hf_zero x hx]\n    exact tendsto_const_nhds\n#align strongly_measurable_in_set strongly_measurable_in_set\n\n",
 "strongly_measurable_iff_measurable_separable":
 "/-- A function is strongly measurable if and only if it is measurable and has separable\nrange. -/\ntheorem _root_.strongly_measurable_iff_measurable_separable {m : MeasurableSpace α} [TopologicalSpace β]\n    [pseudo_metrizable_space β] [MeasurableSpace β] [borel_space β] :\n    strongly_measurable f ↔ Measurable f ∧ IsSeparable (range f) :=\n  by\n  refine' ⟨fun H => ⟨H.measurable, H.is_separable_range⟩, _⟩\n  rintro ⟨H, H'⟩\n  letI := pseudo_metrizable_space_pseudo_metric β\n  let g := cod_restrict f (closure (range f)) fun x => subset_closure (mem_range_self x)\n  have fg : f = (coe : closure (range f) → β) ∘ g := by\n    ext x\n    rfl\n  have T : MeasurableEmbedding (coe : closure (range f) → β) :=\n    by\n    apply closed_embedding.measurable_embedding\n    exact closedEmbedding_subtype_val isClosed_closure\n  have g_meas : Measurable g := by\n    rw [fg] at H\n    exact T.measurable_comp_iff.1 H\n  have : second_countable_topology (closure (range f)) :=\n    by\n    suffices separable_space (closure (range f)) by exact UniformSpace.secondCountable_of_separable _\n    exact (is_separable.closure H').separable_space\n  have g_smeas : strongly_measurable g := measurable.strongly_measurable g_meas\n  rw [fg]\n  exact continuous_subtype_coe.comp_strongly_measurable g_smeas\n#align strongly_measurable_iff_measurable_separable strongly_measurable_iff_measurable_separable\n\n",
 "strongly_measurable_iff_measurable":
 "/-- In a space with second countable topology, strongly measurable and measurable are equivalent. -/\ntheorem _root_.strongly_measurable_iff_measurable [TopologicalSpace β] [metrizable_space β] [borel_space β]\n    [SecondCountableTopology β] : strongly_measurable f ↔ Measurable f :=\n  ⟨fun h => h.measurable, fun h => measurable.strongly_measurable h⟩\n#align strongly_measurable_iff_measurable strongly_measurable_iff_measurable\n\n",
 "strongly_measurable_id":
 "theorem _root_.strongly_measurable_id [TopologicalSpace α] [pseudo_metrizable_space α] [opens_measurable_space α]\n    [SecondCountableTopology α] : strongly_measurable (id : α → α) :=\n  measurable_id.strongly_measurable\n#align strongly_measurable_id strongly_measurable_id\n\n",
 "strongly_measurable_extend":
 "theorem _root_.measurable_embedding.strongly_measurable_extend {f : α → β} {g : α → γ} {g' : γ → β}\n    {mα : MeasurableSpace α} {mγ : MeasurableSpace γ} [TopologicalSpace β] (hg : MeasurableEmbedding g)\n    (hf : strongly_measurable f) (hg' : strongly_measurable g') : strongly_measurable (Function.extend g f g') :=\n  by\n  refine' ⟨fun n => simple_func.extend (hf.approx n) g hg (hg'.approx n), _⟩\n  intro x\n  by_cases hx : ∃ y, g y = x\n  · rcases hx with ⟨y, rfl⟩\n    simpa only [simple_func.extend_apply, hg.injective, injective.extend_apply] using hf.tendsto_approx y\n  · simpa only [hx, simple_func.extend_apply', not_false_iff, extend_apply'] using hg'.tendsto_approx x\n#align measurable_embedding.strongly_measurable_extend measurable_embedding.strongly_measurable_extend\n\n",
 "strongly_measurable_const_smul_iff₀":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem _root_.strongly_measurable_const_smul_iff₀ {m : MeasurableSpace α} {c : G₀} (hc : c ≠ 0) :\n    (strongly_measurable fun x => «expr • » c (f x)) ↔ strongly_measurable f :=\n  by\n  refine' ⟨fun h => _, fun h => h.const_smul c⟩\n  convert h.const_smul' c⁻¹\n  simp [smul_smul, inv_mul_cancel hc]\n#align strongly_measurable_const_smul_iff₀ strongly_measurable_const_smul_iff₀\n\n",
 "strongly_measurable_const_smul_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem _root_.strongly_measurable_const_smul_iff {m : MeasurableSpace α} (c : G) :\n    (strongly_measurable fun x => «expr • » c (f x)) ↔ strongly_measurable f :=\n  ⟨fun h => by simpa only [inv_smul_smul] using h.const_smul' c⁻¹, fun h => h.const_smul c⟩\n#align strongly_measurable_const_smul_iff strongly_measurable_const_smul_iff\n\n",
 "strongly_measurable_const'":
 "/-- A version of `strongly_measurable_const` that assumes `f x = f y` for all `x, y`.\nThis version works for functions between empty types. -/\ntheorem strongly_measurable_const' {α β} {m : MeasurableSpace α} [TopologicalSpace β] {f : α → β}\n    (hf : ∀ x y, f x = f y) : strongly_measurable f :=\n  by\n  cases isEmpty_or_nonempty α\n  · exact strongly_measurable_of_is_empty f\n  · convert strongly_measurable_const\n    exact funext fun x => hf x h.some\n#align strongly_measurable_const' strongly_measurable_const'\n\n",
 "strongly_measurable_const":
 "theorem strongly_measurable_const {α β} {m : MeasurableSpace α} [TopologicalSpace β] {b : β} :\n    strongly_measurable fun a : α => b :=\n  ⟨fun n => simple_func.const α b, fun a => tendsto_const_nhds⟩\n#align strongly_measurable_const strongly_measurable_const\n\n",
 "strongly_measurable_bot_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `strongly_measurable_of -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem _root_.strongly_measurable_bot_iff [Nonempty β] [T2Space β] :\n    (strongly_measurable_of («expr⊥»)) f ↔ ∃ c, f = fun _ => c :=\n  by\n  cases' isEmpty_or_nonempty α with hα hα\n  · simp only [subsingleton.strongly_measurable', eq_iff_true_of_subsingleton, exists_const]\n  refine' ⟨fun hf => _, fun hf_eq => _⟩\n  · refine' ⟨f hα.some, _⟩\n    let fs := hf.approx\n    have h_fs_tendsto : ∀ x, tendsto (fun n => fs n x) at_top ((nhds) (f x)) := hf.tendsto_approx\n    have : ∀ n, ∃ c, ∀ x, fs n x = c := fun n => simple_func.simple_func_bot (fs n)\n    let cs n := (this n).some\n    have h_cs_eq : ∀ n, «expr⇑ » (fs n) = fun x => cs n := fun n => funext (this n).some_spec\n    simp_rw [h_cs_eq] at h_fs_tendsto\n    have h_tendsto : tendsto cs at_top ((nhds) (f hα.some)) := h_fs_tendsto hα.some\n    ext1 x\n    exact tendsto_nhds_unique (h_fs_tendsto x) h_tendsto\n  · obtain ⟨c, rfl⟩ := hf_eq\n    exact strongly_measurable_const\n#align strongly_measurable_bot_iff strongly_measurable_bot_iff\n\n",
 "strongly_measurable'":
 "@[simp]\ntheorem subsingleton.strongly_measurable' {α β} [MeasurableSpace α] [TopologicalSpace β] [subsingleton α] (f : α → β) :\n    strongly_measurable f :=\n  strongly_measurable_const' fun x y => by rw [subsingleton.elim x y]\n#align subsingleton.strongly_measurable' subsingleton.strongly_measurable'\n\n",
 "strongly_measurable":
 "protected theorem strongly_measurable [Zero β] [TopologicalSpace β] (hf : fin_strongly_measurable f μ) :\n    strongly_measurable f :=\n  ⟨hf.approx, hf.tendsto_approx⟩\n#align strongly_measurable strongly_measurable\n\n",
 "smul_measure":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem smul_measure {R : Type _} [Monoid R] [DistribMulAction R (ennreal)] [IsScalarTower R (ennreal) (ennreal)]\n    (h : ae_strongly_measurable f μ) (c : R) : ae_strongly_measurable f («expr • » c μ) :=\n  ⟨h.mk f, h.strongly_measurable_mk, ae_smul_measure h.ae_eq_mk c⟩\n#align smul_measure smul_measure\n\n",
 "smul_const":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[to_additive]\nprotected theorem smul_const {𝕜} [TopologicalSpace 𝕜] [SMul 𝕜 β] [ContinuousSMul 𝕜 β] {f : α → 𝕜}\n    (hf : ae_strongly_measurable f μ) (c : β) : ae_strongly_measurable (fun x => «expr • » (f x) c) μ :=\n  continuous_smul.comp_ae_strongly_measurable (hf.prod_mk ae_strongly_measurable_const)\n#align smul_const smul_const\n\n",
 "smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[to_additive]\nprotected theorem smul {𝕜} [TopologicalSpace 𝕜] [SMul 𝕜 β] [ContinuousSMul 𝕜 β] {f : α → 𝕜} {g : α → β}\n    (hf : ae_strongly_measurable f μ) (hg : ae_strongly_measurable g μ) :\n    ae_strongly_measurable (fun x => «expr • » (f x) (g x)) μ :=\n  continuous_smul.comp_ae_strongly_measurable (hf.prod_mk hg)\n#align smul smul\n\n",
 "separable_space_range_union_singleton":
 "theorem separable_space_range_union_singleton {m : MeasurableSpace α} [TopologicalSpace β] [pseudo_metrizable_space β]\n    (hf : strongly_measurable f) {b : β} : SeparableSpace (range f ∪ {b} : Set β) :=\n  letI := pseudo_metrizable_space_pseudo_metric β\n  (hf.is_separable_range.union (finite_singleton _).is_separable).separable_space\n#align separable_space_range_union_singleton separable_space_range_union_singleton\n\n",
 "restrict":
 "protected theorem restrict (hfm : ae_strongly_measurable f μ) {s} : ae_strongly_measurable f (μ.restrict s) :=\n  hfm.mono_measure Measure.restrict_le_self\n#align restrict restrict\n\n",
 "real_to_nnreal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\nprotected theorem real_to_nnreal {f : α → exprℝ} (hf : ae_strongly_measurable f μ) :\n    ae_strongly_measurable (fun x => (f x).to_nnreal) μ :=\n  continuous_real_toNNReal.comp_ae_strongly_measurable hf\n#align real_to_nnreal real_to_nnreal\n\n",
 "prod_mk":
 "protected theorem prod_mk {f : α → β} {g : α → γ} (hf : ae_strongly_measurable f μ) (hg : ae_strongly_measurable g μ) :\n    ae_strongly_measurable (fun x => (f x, g x)) μ :=\n  ⟨fun x => (hf.mk f x, hg.mk g x), hf.strongly_measurable_mk.prod_mk hg.strongly_measurable_mk,\n    hf.ae_eq_mk.prod_mk hg.ae_eq_mk⟩\n#align prod_mk prod_mk\n\n",
 "piecewise":
 "protected theorem piecewise {m : MeasurableSpace α} [TopologicalSpace β] {s : Set α} {_ : DecidablePred (· ∈ s)}\n    (hs : MeasurableSet s) (hf : strongly_measurable f) (hg : strongly_measurable g) :\n    strongly_measurable (Set.piecewise s f g) :=\n  by\n  refine' ⟨fun n => simple_func.piecewise s hs (hf.approx n) (hg.approx n), fun x => _⟩\n  by_cases hx : x ∈ s\n  · simpa [hx] using hf.tendsto_approx x\n  · simpa [hx] using hg.tendsto_approx x\n#align piecewise piecewise\n\n",
 "of_uncurry_right":
 "theorem of_uncurry_right [TopologicalSpace β] {mα : MeasurableSpace α} {mγ : MeasurableSpace γ} {f : α → γ → β}\n    (hf : strongly_measurable (uncurry f)) {y : γ} : strongly_measurable fun x => f x y :=\n  hf.comp_measurable measurable_prod_mk_right\n#align of_uncurry_right of_uncurry_right\n\n",
 "of_uncurry_left":
 "theorem of_uncurry_left [TopologicalSpace β] {mα : MeasurableSpace α} {mγ : MeasurableSpace γ} {f : α → γ → β}\n    (hf : strongly_measurable (uncurry f)) {x : α} : strongly_measurable (f x) :=\n  hf.comp_measurable measurable_prod_mk_left\n#align of_uncurry_left of_uncurry_left\n\n",
 "null_measurable_set_lt":
 "theorem null_measurable_set_lt [linear_order β] [OrderClosedTopology β] [pseudo_metrizable_space β] {f g : α → β}\n    (hf : ae_strongly_measurable f μ) (hg : ae_strongly_measurable g μ) : NullMeasurableSet { a | f a < g a } μ :=\n  by\n  apply (hf.strongly_measurable_mk.measurable_set_lt hg.strongly_measurable_mk).null_measurable_set.congr\n  filter_upwards [hf.ae_eq_mk, hg.ae_eq_mk]with x hfx hgx\n  change (hf.mk f x < hg.mk g x) = (f x < g x)\n  simp only [hfx, hgx]\n#align null_measurable_set_lt null_measurable_set_lt\n\n",
 "null_measurable_set_le":
 "theorem null_measurable_set_le [preorder β] [OrderClosedTopology β] [pseudo_metrizable_space β] {f g : α → β}\n    (hf : ae_strongly_measurable f μ) (hg : ae_strongly_measurable g μ) : NullMeasurableSet { a | f a ≤ g a } μ :=\n  by\n  apply (hf.strongly_measurable_mk.measurable_set_le hg.strongly_measurable_mk).null_measurable_set.congr\n  filter_upwards [hf.ae_eq_mk, hg.ae_eq_mk]with x hfx hgx\n  change (hf.mk f x ≤ hg.mk g x) = (f x ≤ g x)\n  simp only [hfx, hgx]\n#align null_measurable_set_le null_measurable_set_le\n\n",
 "nullMeasurableSet_eq_fun":
 "#print nullMeasurableSet_eq_fun /-\ntheorem nullMeasurableSet_eq_fun {E} [TopologicalSpace E] [metrizable_space E] {f g : α → E}\n    (hf : ae_strongly_measurable f μ) (hg : ae_strongly_measurable g μ) : NullMeasurableSet { x | f x = g x } μ :=\n  by\n  apply (hf.strongly_measurable_mk.measurable_set_eq_fun hg.strongly_measurable_mk).null_measurable_set.congr\n  filter_upwards [hf.ae_eq_mk, hg.ae_eq_mk]with x hfx hgx\n  change (hf.mk f x = hg.mk g x) = (f x = g x)\n  simp only [hfx, hgx]\n#align null_measurable_set_eq_fun nullMeasurableSet_eq_fun\n-/\n\n",
 "norm_approx_bounded_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `strongly_measurable_of -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem norm_approx_bounded_le {β} {f : α → β} [SeminormedAddCommGroup β] [NormedSpace (exprℝ) β]\n    {m : MeasurableSpace α} {c : exprℝ} (hf : (strongly_measurable_of m) f) (hc : 0 ≤ c) (n : ℕ) (x : α) :\n    «expr‖ ‖» (hf.approx_bounded c n x) ≤ c :=\n  by\n  simp only [strongly_measurable.approx_bounded, simple_func.coe_map, Function.comp_apply]\n  refine' (norm_smul_le _ _).trans _\n  by_cases h0 : «expr‖ ‖» (hf.approx n x) = 0\n  · simp only [h0, div_zero, min_eq_right, zero_le_one, norm_zero, MulZeroClass.mul_zero]\n    exact hc\n  cases le_total («expr‖ ‖» (hf.approx n x)) c\n  · rw [min_eq_left _]\n    · simpa only [norm_one, one_mul] using h\n    · rwa [one_le_div (lt_of_le_of_ne (norm_nonneg _) (ne.symm h0))]\n  · rw [min_eq_right _]\n    ·\n      rw [norm_div, norm_norm, mul_comm, mul_div, div_eq_mul_inv, mul_comm, ← mul_assoc, inv_mul_cancel h0, one_mul,\n        Real.norm_of_nonneg hc]\n    · rwa [div_le_one (lt_of_le_of_ne (norm_nonneg _) (ne.symm h0))]\n#align norm_approx_bounded_le norm_approx_bounded_le\n\n",
 "norm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\nprotected theorem norm {β : Type _} [SeminormedAddCommGroup β] {f : α → β} (hf : ae_strongly_measurable f μ) :\n    ae_strongly_measurable (fun x => «expr‖ ‖» (f x)) μ :=\n  continuous_norm.comp_ae_strongly_measurable hf\n#align norm norm\n\n",
 "nnnorm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\nprotected theorem nnnorm {β : Type _} [SeminormedAddCommGroup β] {f : α → β} (hf : ae_strongly_measurable f μ) :\n    ae_strongly_measurable (fun x => «expr‖ ‖₊» (f x)) μ :=\n  continuous_nnnorm.comp_ae_strongly_measurable hf\n#align nnnorm nnnorm\n\n",
 "neg":
 "protected theorem neg [AddGroup β] [TopologicalAddGroup β] (hf : ae_fin_strongly_measurable f μ) :\n    ae_fin_strongly_measurable (-f) μ :=\n  ⟨-hf.mk f, hf.fin_strongly_measurable_mk.neg, hf.ae_eq_mk.neg⟩\n#align neg neg\n\n",
 "mul_const":
 "@[to_additive]\nprotected theorem mul_const [Mul β] [ContinuousMul β] (hf : ae_strongly_measurable f μ) (c : β) :\n    ae_strongly_measurable (fun x => f x * c) μ :=\n  hf.mul ae_strongly_measurable_const\n#align mul_const mul_const\n\n",
 "mul":
 "protected theorem mul [MonoidWithZero β] [ContinuousMul β] (hf : ae_fin_strongly_measurable f μ)\n    (hg : ae_fin_strongly_measurable g μ) : ae_fin_strongly_measurable (f * g) μ :=\n  ⟨hf.mk f * hg.mk g, hf.fin_strongly_measurable_mk.mul hg.fin_strongly_measurable_mk, hf.ae_eq_mk.mul hg.ae_eq_mk⟩\n#align mul mul\n\n",
 "mono_set":
 "theorem mono_set {s t} (h : s ⊆ t) (ht : ae_strongly_measurable f (μ.restrict t)) :\n    ae_strongly_measurable f (μ.restrict s) :=\n  ht.mono_measure (restrict_mono h le_rfl)\n#align mono_set mono_set\n\n",
 "mono_measure":
 "theorem mono_measure {ν : Measure α} (hf : ae_strongly_measurable f μ) (h : ν ≤ μ) : ae_strongly_measurable f ν :=\n  ⟨hf.mk f, hf.strongly_measurable_mk, Eventually.filter_mono (ae_mono h) hf.ae_eq_mk⟩\n#align mono_measure mono_measure\n\n",
 "mono'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure.absolutely_continuous -/\nprotected theorem mono' {ν : Measure α} (h : ae_strongly_measurable f μ) (h' : measure.absolutely_continuous ν μ) :\n    ae_strongly_measurable f ν :=\n  ⟨h.mk f, h.strongly_measurable_mk, h' h.ae_eq_mk⟩\n#align mono' mono'\n\n",
 "mono":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `strongly_measurable_of -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `strongly_measurable_of -/\nprotected theorem mono {m m' : MeasurableSpace α} [TopologicalSpace β] (hf : (strongly_measurable_of m') f)\n    (h_mono : m' ≤ m) : (strongly_measurable_of m) f :=\n  by\n  let f_approx : ℕ → @simple_func α m β := fun n =>\n    { to_fun := hf.approx n\n      measurable_set_fiber' := fun x => h_mono _ (simple_func.measurable_set_fiber' _ x)\n      finite_range' := simple_func.finite_range (hf.approx n) }\n  exact ⟨f_approx, hf.tendsto_approx⟩\n#align mono mono\n\n",
 "measurable_uncurry_of_continuous_of_measurable":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↥ » -/\ntheorem measurable_uncurry_of_continuous_of_measurable {α β ι : Type _} [TopologicalSpace ι] [metrizable_space ι]\n    [MeasurableSpace ι] [SecondCountableTopology ι] [opens_measurable_space ι] {mβ : MeasurableSpace β}\n    [TopologicalSpace β] [pseudo_metrizable_space β] [borel_space β] {m : MeasurableSpace α} {u : ι → α → β}\n    (hu_cont : ∀ x, Continuous fun i => u i x) (h : ∀ i, Measurable (u i)) : Measurable (function.uncurry u) :=\n  by\n  obtain ⟨t_sf, ht_sf⟩ : ∃ t : ℕ → simple_func ι ι, ∀ j x, tendsto (fun n => u (t n j) x) at_top (nhds <| u j x) :=\n    by\n    have h_str_meas : strongly_measurable (id : ι → ι) := strongly_measurable_id\n    refine' ⟨h_str_meas.approx, fun j x => _⟩\n    exact ((hu_cont x).tendsto j).comp (h_str_meas.tendsto_approx j)\n  let U (n : ℕ) (p : ι × α) := u (t_sf n p.fst) p.snd\n  have h_tendsto : tendsto U at_top ((nhds) fun p => u p.fst p.snd) :=\n    by\n    rw [tendsto_pi_nhds]\n    exact fun p => ht_sf p.fst p.snd\n  refine' measurable_of_tendsto_metrizable (fun n => _) h_tendsto\n  have h_meas : Measurable fun p : (t_sf n).range × α => u (↑p.fst) p.snd :=\n    by\n    have :\n      (fun p : «expr↥ » (t_sf n).range × α => u (↑p.fst) p.snd) =\n        (fun p : α × (t_sf n).range => u (↑p.snd) p.fst) ∘ Prod.swap :=\n      rfl\n    rw [this, @measurable_swap_iff α («expr↥ » (t_sf n).range) β m]\n    exact measurable_from_prod_countable fun j => h j\n  have :\n    (fun p : ι × α => u (t_sf n p.fst) p.snd) =\n      (fun p : «expr↥ » (t_sf n).range × α => u p.fst p.snd) ∘ fun p : ι × α =>\n        (⟨t_sf n p.fst, simple_func.mem_range_self _ _⟩, p.snd) :=\n    rfl\n  simp_rw [U, this]\n  refine' h_meas.comp (Measurable.prod_mk _ measurable_snd)\n  exact ((t_sf n).measurable.comp measurable_fst).subtype_mk\n#align measurable_uncurry_of_continuous_of_measurable measurable_uncurry_of_continuous_of_measurable\n\n",
 "measurable_set_lt":
 "theorem measurable_set_lt {m : MeasurableSpace α} [TopologicalSpace β] [linear_order β] [OrderClosedTopology β]\n    [pseudo_metrizable_space β] {f g : α → β} (hf : strongly_measurable f) (hg : strongly_measurable g) :\n    MeasurableSet { a | f a < g a } := by\n  borelize (β × β)\n  exact (hf.prod_mk hg).measurable is_open_lt_prod.measurable_set\n#align measurable_set_lt measurable_set_lt\n\n",
 "measurable_set_le":
 "theorem measurable_set_le {m : MeasurableSpace α} [TopologicalSpace β] [preorder β] [OrderClosedTopology β]\n    [pseudo_metrizable_space β] {f g : α → β} (hf : strongly_measurable f) (hg : strongly_measurable g) :\n    MeasurableSet { a | f a ≤ g a } := by\n  borelize (β × β)\n  exact (hf.prod_mk hg).measurable is_closed_le_prod.measurable_set\n#align measurable_set_le measurable_set_le\n\n",
 "measurable_mk":
 "theorem measurable_mk [pseudo_metrizable_space β] [MeasurableSpace β] [borel_space β]\n    (hf : ae_strongly_measurable f μ) : Measurable (hf.mk f) :=\n  hf.strongly_measurable_mk.measurable\n#align measurable_mk measurable_mk\n\n",
 "measurableSet_mulSupport":
 "#print measurableSet_mulSupport /-\n@[to_additive]\ntheorem measurableSet_mulSupport {m : MeasurableSpace α} [One β] [TopologicalSpace β] [metrizable_space β]\n    (hf : strongly_measurable f) : MeasurableSet (mulSupport f) :=\n  by\n  borelize β\n  exact measurableSet_mulSupport hf.measurable\n#align measurable_set_mul_support measurableSet_mulSupport\n#align measurable_set_support measurableSet_support\n-/\n\n",
 "measurableSet_eq_fun":
 "#print measurableSet_eq_fun /-\ntheorem measurableSet_eq_fun {m : MeasurableSpace α} {E} [TopologicalSpace E] [metrizable_space E] {f g : α → E}\n    (hf : strongly_measurable f) (hg : strongly_measurable g) : MeasurableSet { x | f x = g x } :=\n  by\n  borelize (E × E)\n  exact (hf.prod_mk hg).measurable is_closed_diagonal.measurable_set\n#align measurable_set_eq_fun measurableSet_eq_fun\n-/\n\n",
 "ite":
 "#print ite /-\n/-- this is slightly different from `strongly_measurable.piecewise`. It can be used to show\n`strongly_measurable (ite (x=0) 0 1)` by\n`exact strongly_measurable.ite (measurable_set_singleton 0) strongly_measurable_const\nstrongly_measurable_const`, but replacing `strongly_measurable.ite` by\n`strongly_measurable.piecewise` in that example proof does not work. -/\nprotected theorem ite {m : MeasurableSpace α} [TopologicalSpace β] {p : α → Prop} {_ : DecidablePred p}\n    (hp : MeasurableSet { a : α | p a }) (hf : strongly_measurable f) (hg : strongly_measurable g) :\n    strongly_measurable fun x => ite (p x) (f x) (g x) :=\n  strongly_measurable.piecewise hp hf hg\n#align ite ite\n-/\n\n",
 "is_separable_range":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/-- The range of a strongly measurable function is separable. -/\ntheorem is_separable_range {m : MeasurableSpace α} [TopologicalSpace β] (hf : strongly_measurable f) :\n    TopologicalSpace.IsSeparable (range f) :=\n  by\n  have :\n    is_separable\n      (closure\n        («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n          (range (hf.approx n)))) :=\n    (is_separable_Union fun n => (simple_func.finite_range (hf.approx n)).is_separable).closure\n  apply this.mono\n  rintro _ ⟨x, rfl⟩\n  apply mem_closure_of_tendsto (hf.tendsto_approx x)\n  apply eventually_of_forall fun n => _\n  apply mem_Union_of_mem n\n  exact mem_range_self _\n#align is_separable_range is_separable_range\n\n",
 "is_separable_ae_range":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\ntheorem is_separable_ae_range (hf : ae_strongly_measurable f μ) :\n    ∃ t : Set β,\n      IsSeparable t ∧\n        «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\" μ\n          (f x ∈ t) :=\n  by\n  refine' ⟨range (hf.mk f), hf.strongly_measurable_mk.is_separable_range, _⟩\n  filter_upwards [hf.ae_eq_mk]with x hx\n  simp [hx]\n#align is_separable_ae_range is_separable_ae_range\n\n",
 "inv":
 "@[to_additive]\nprotected theorem inv [Group β] [TopologicalGroup β] (hf : ae_strongly_measurable f μ) : ae_strongly_measurable f⁻¹ μ :=\n  ⟨(hf.mk f)⁻¹, hf.strongly_measurable_mk.inv, hf.ae_eq_mk.inv⟩\n#align inv inv\n\n",
 "inf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\nprotected theorem inf [SemilatticeInf β] [ContinuousInf β] (hf : ae_fin_strongly_measurable f μ)\n    (hg : ae_fin_strongly_measurable g μ) : ae_fin_strongly_measurable («expr ⊓ » f g) μ :=\n  ⟨«expr ⊓ » (hf.mk f) (hg.mk g), hf.fin_strongly_measurable_mk.inf hg.fin_strongly_measurable_mk,\n    hf.ae_eq_mk.inf hg.ae_eq_mk⟩\n#align inf inf\n\n",
 "indicator":
 "protected theorem indicator [Zero β] (hfm : ae_strongly_measurable f μ) {s : Set α} (hs : MeasurableSet s) :\n    ae_strongly_measurable (s.indicator f) μ :=\n  (ae_strongly_measurable_indicator_iff hs).mpr hfm.restrict\n#align indicator indicator\n\n",
 "fin_support_approx":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\nprotected theorem fin_support_approx : ∀ n, μ (support (hf.approx n)) < ennreal.top :=\n  hf.some_spec.1\n#align fin_support_approx fin_support_approx\n\n",
 "fin_strongly_measurable_zero":
 "theorem fin_strongly_measurable_zero {α β} {m : MeasurableSpace α} {μ : Measure α} [Zero β] [TopologicalSpace β] :\n    fin_strongly_measurable (0 : α → β) μ :=\n  ⟨0, by\n    simp only [Pi.zero_apply, simple_func.coe_zero, support_zero', measure_empty, WithTop.zero_lt_top, forall_const],\n    fun n => tendsto_const_nhds⟩\n#align fin_strongly_measurable_zero fin_strongly_measurable_zero\n\n",
 "fin_strongly_measurable_of_set_sigma_finite":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (x «expr ∉ » t) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\ntheorem fin_strongly_measurable_of_set_sigma_finite [TopologicalSpace β] [Zero β] {m : MeasurableSpace α}\n    {μ : Measure α} (hf_meas : strongly_measurable f) {t : Set α} (ht : MeasurableSet t)\n    (hft_zero : ∀ x ∈ «expr ᶜ» t, f x = 0) (htμ : SigmaFinite (μ.restrict t)) : fin_strongly_measurable f μ :=\n  by\n  haveI : sigma_finite (μ.restrict t) := htμ\n  let S := spanning_sets (μ.restrict t)\n  have hS_meas : ∀ n, MeasurableSet (S n) := measurable_spanning_sets (μ.restrict t)\n  let f_approx := hf_meas.approx\n  let fs n := simple_func.restrict (f_approx n) (S n ∩ t)\n  have h_fs_t_compl : ∀ n, ∀ (x) (_ : x ∉ t), fs n x = 0 :=\n    by\n    intro n x hxt\n    rw [simple_func.restrict_apply _ ((hS_meas n).inter ht)]\n    refine' Set.indicator_of_not_mem _ _\n    simp [hxt]\n  refine' ⟨fs, _, fun x => _⟩\n  · simp_rw [simple_func.support_eq]\n    refine' fun n => (measure_bUnion_finset_le _ _).trans_lt _\n    refine' ennreal.sum_lt_top_iff.mpr fun y hy => _\n    rw [simple_func.restrict_preimage_singleton _ ((hS_meas n).inter ht)]\n    swap\n    · rw [Finset.mem_filter] at hy\n      exact hy.2\n    refine' (measure_mono (Set.inter_subset_left _ _)).trans_lt _\n    have h_lt_top := measure_spanning_sets_lt_top (μ.restrict t) n\n    rwa [measure.restrict_apply' ht] at h_lt_top\n  · by_cases hxt : x ∈ t\n    swap\n    · rw [funext fun n => h_fs_t_compl n x hxt, hft_zero x hxt]\n      exact tendsto_const_nhds\n    have h : tendsto (fun n => (f_approx n) x) at_top ((nhds) (f x)) := hf_meas.tendsto_approx x\n    obtain ⟨n₁, hn₁⟩ : ∃ n, ∀ m, n ≤ m → fs m x = f_approx m x :=\n      by\n      obtain ⟨n, hn⟩ : ∃ n, ∀ m, n ≤ m → x ∈ S m ∩ t :=\n        by\n        rsuffices ⟨n, hn⟩ : ∃ n, ∀ m, n ≤ m → x ∈ S m\n        · exact ⟨n, fun m hnm => Set.mem_inter (hn m hnm) hxt⟩\n        rsuffices ⟨n, hn⟩ : ∃ n, x ∈ S n\n        · exact ⟨n, fun m hnm => monotone_spanning_sets (μ.restrict t) hnm hn⟩\n        rw [← Set.mem_unionᵢ, Union_spanning_sets (μ.restrict t)]\n        trivial\n      refine' ⟨n, fun m hnm => _⟩\n      simp_rw [fs, simple_func.restrict_apply _ ((hS_meas m).inter ht), Set.indicator_of_mem (hn m hnm)]\n    rw [tendsto_at_top'] at h⊢\n    intro s hs\n    obtain ⟨n₂, hn₂⟩ := h s hs\n    refine' ⟨max n₁ n₂, fun m hm => _⟩\n    rw [hn₁ m ((le_max_left _ _).trans hm.le)]\n    exact hn₂ m ((le_max_right _ _).trans hm.le)\n#align fin_strongly_measurable_of_set_sigma_finite fin_strongly_measurable_of_set_sigma_finite\n\n",
 "fin_strongly_measurable_mk":
 "theorem fin_strongly_measurable_mk (hf : ae_fin_strongly_measurable f μ) : fin_strongly_measurable (hf.mk f) μ :=\n  hf.some_spec.1\n#align fin_strongly_measurable_mk fin_strongly_measurable_mk\n\n",
 "fin_strongly_measurable_iff_strongly_measurable_and_exists_set_sigma_finite":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\ntheorem fin_strongly_measurable_iff_strongly_measurable_and_exists_set_sigma_finite {α β} {f : α → β}\n    [TopologicalSpace β] [T2Space β] [Zero β] {m : MeasurableSpace α} {μ : Measure α} :\n    fin_strongly_measurable f μ ↔\n      strongly_measurable f ∧ ∃ t, MeasurableSet t ∧ (∀ x ∈ «expr ᶜ» t, f x = 0) ∧ SigmaFinite (μ.restrict t) :=\n  ⟨fun hf => ⟨hf.strongly_measurable, hf.exists_set_sigma_finite⟩, fun hf =>\n    hf.1.fin_strongly_measurable_of_set_sigma_finite hf.2.some_spec.1 hf.2.some_spec.2.1 hf.2.some_spec.2.2⟩\n#align fin_strongly_measurable_iff_strongly_measurable_and_exists_set_sigma_finite fin_strongly_measurable_iff_strongly_measurable_and_exists_set_sigma_finite\n\n",
 "fin_strongly_measurable_iff_measurable":
 "/-- In a space with second countable topology and a sigma-finite measure, `fin_strongly_measurable`\n  and `measurable` are equivalent. -/\ntheorem fin_strongly_measurable_iff_measurable {m0 : MeasurableSpace α} (μ : Measure α) [SigmaFinite μ] :\n    fin_strongly_measurable f μ ↔ Measurable f :=\n  ⟨fun h => h.measurable, fun h => (measurable.strongly_measurable h).fin_strongly_measurable μ⟩\n#align fin_strongly_measurable_iff_measurable fin_strongly_measurable_iff_measurable\n\n",
 "fin_strongly_measurable":
 "/-- If the measure is sigma-finite, all strongly measurable functions are\n  `fin_strongly_measurable`. -/\nprotected theorem fin_strongly_measurable [TopologicalSpace β] [Zero β] {m0 : MeasurableSpace α}\n    (hf : strongly_measurable f) (μ : Measure α) [SigmaFinite μ] : fin_strongly_measurable f μ :=\n  hf.fin_strongly_measurable_of_set_sigma_finite MeasurableSet.univ (by simp) (by rwa [measure.restrict_univ])\n#align fin_strongly_measurable fin_strongly_measurable\n\n",
 "exists_strongly_measurable_limit_of_tendsto_ae":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- If a sequence of almost everywhere strongly measurable functions converges almost everywhere,\none can select a strongly measurable function as the almost everywhere limit. -/\ntheorem _root_.exists_strongly_measurable_limit_of_tendsto_ae [pseudo_metrizable_space β] {f : ℕ → α → β}\n    (hf : ∀ n, ae_strongly_measurable (f n) μ)\n    (h_ae_tendsto :\n      «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\" μ\n        (∃ l : β, Tendsto (fun n => f n x) atTop ((nhds) l))) :\n    ∃ (f_lim : α → β)(hf_lim_meas : strongly_measurable f_lim),\n      «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\" μ\n        (Tendsto (fun n => f n x) atTop ((nhds) (f_lim x))) :=\n  by\n  borelize β\n  obtain ⟨g, g_meas, hg⟩ :\n    ∃ (g : α → β)(g_meas : Measurable g),\n      «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\" μ\n        (tendsto (fun n => f n x) at_top ((nhds) (g x))) :=\n    measurable_limit_of_tendsto_metrizable_ae (fun n => (hf n).ae_measurable) h_ae_tendsto\n  have Hg : ae_strongly_measurable g μ := ae_strongly_measurable_of_tendsto_ae _ hf hg\n  refine' ⟨Hg.mk g, Hg.strongly_measurable_mk, _⟩\n  filter_upwards [hg, Hg.ae_eq_mk]with x hx h'x\n  rwa [h'x] at hx\n#align exists_strongly_measurable_limit_of_tendsto_ae exists_strongly_measurable_limit_of_tendsto_ae\n\n",
 "exists_strongly_measurable_extend":
 "theorem _root_.measurable_embedding.exists_strongly_measurable_extend {f : α → β} {g : α → γ} {mα : MeasurableSpace α}\n    {mγ : MeasurableSpace γ} [TopologicalSpace β] (hg : MeasurableEmbedding g) (hf : strongly_measurable f)\n    (hne : γ → Nonempty β) : ∃ f' : γ → β, strongly_measurable f' ∧ f' ∘ g = f :=\n  ⟨Function.extend g f fun x => Classical.choice (hne x),\n    hg.strongly_measurable_extend hf (strongly_measurable_const' fun _ _ => rfl),\n    funext fun x => hg.injective.extend_apply _ _ _⟩\n#align measurable_embedding.exists_strongly_measurable_extend measurable_embedding.exists_strongly_measurable_extend\n\n",
 "exists_spanning_measurable_set_norm_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⌈ ⌉₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `strongly_measurable_of -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/-- If a function `f` is strongly measurable w.r.t. a sub-σ-algebra `m` and the measure is σ-finite\non `m`, then there exists spanning measurable sets with finite measure on which `f` has bounded\nnorm. In particular, `f` is integrable on each of those sets. -/\ntheorem exists_spanning_measurable_set_norm_le [SeminormedAddCommGroup β] {m m0 : MeasurableSpace α} (hm : m ≤ m0)\n    (hf : (strongly_measurable_of m) f) (μ : Measure α) [SigmaFinite (μ.trim hm)] :\n    ∃ s : ℕ → Set α,\n      (∀ n, (measurable_set_of m) (s n) ∧ μ (s n) < ennreal.top ∧ ∀ x ∈ s n, «expr‖ ‖» (f x) ≤ n) ∧\n        «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (s i) =\n          Set.univ :=\n  by\n  let sigma_finite_sets := spanning_sets (μ.trim hm)\n  let norm_sets := fun n : ℕ => { x | «expr‖ ‖» (f x) ≤ n }\n  have norm_sets_spanning :\n    «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (norm_sets n) =\n      Set.univ :=\n    by\n    ext1 x\n    simp only [Set.mem_unionᵢ, Set.mem_setOf_eq, Set.mem_univ, iff_true_iff]\n    exact ⟨«expr⌈ ⌉₊» («expr‖ ‖» (f x)), Nat.le_ceil («expr‖ ‖» (f x))⟩\n  let sets n := sigma_finite_sets n ∩ norm_sets n\n  have h_meas : ∀ n, (measurable_set_of m) (sets n) :=\n    by\n    refine' fun n => MeasurableSet.inter _ _\n    · exact measurable_spanning_sets (μ.trim hm) n\n    · exact hf.norm.measurable_set_le strongly_measurable_const\n  have h_finite : ∀ n, μ (sets n) < ennreal.top :=\n    by\n    refine' fun n => (measure_mono (Set.inter_subset_left _ _)).trans_lt _\n    exact (le_trim hm).trans_lt (measure_spanning_sets_lt_top (μ.trim hm) n)\n  refine' ⟨sets, fun n => ⟨h_meas n, h_finite n, _⟩, _⟩\n  · exact fun x hx => hx.2\n  · have :\n      «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n          (sigma_finite_sets i ∩ norm_sets i) =\n        «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n            (sigma_finite_sets i) ∩\n          «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n            (norm_sets i) :=\n      by\n      refine' Set.unionᵢ_inter_of_monotone (monotone_spanning_sets (μ.trim hm)) fun i j hij x => _\n      simp only [norm_sets, Set.mem_setOf_eq]\n      refine' fun hif => hif.trans _\n      exact_mod_cast hij\n    rw [this, norm_sets_spanning, Union_spanning_sets (μ.trim hm), Set.inter_univ]\n#align exists_spanning_measurable_set_norm_le exists_spanning_measurable_set_norm_le\n\n",
 "exists_set_sigma_finite":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\ntheorem exists_set_sigma_finite (hf : ae_fin_strongly_measurable f μ) :\n    ∃ t, MeasurableSet t ∧ «expr =ᵐ[ ] » f (μ.restrict («expr ᶜ» t)) 0 ∧ SigmaFinite (μ.restrict t) :=\n  by\n  rcases hf with ⟨g, hg, hfg⟩\n  obtain ⟨t, ht, hgt_zero, htμ⟩ := hg.exists_set_sigma_finite\n  refine' ⟨t, ht, _, htμ⟩\n  refine' eventually_eq.trans (ae_restrict_of_ae hfg) _\n  rw [eventually_eq, ae_restrict_iff' ht.compl]\n  exact eventually_of_forall hgt_zero\n#align exists_set_sigma_finite exists_set_sigma_finite\n\n",
 "ennnorm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\nprotected theorem ennnorm {β : Type _} [SeminormedAddCommGroup β] {f : α → β} (hf : ae_strongly_measurable f μ) :\n    AEMeasurable (fun a => («expr‖ ‖₊» (f a) : ennreal)) μ :=\n  (ENNReal.continuous_coe.comp_ae_strongly_measurable hf.nnnorm).ae_measurable\n#align ennnorm ennnorm\n\n",
 "edist":
 "protected theorem edist {β : Type _} [SeminormedAddCommGroup β] {f g : α → β} (hf : ae_strongly_measurable f μ)\n    (hg : ae_strongly_measurable g μ) : AEMeasurable (fun a => edist (f a) (g a)) μ :=\n  (continuous_edist.comp_ae_strongly_measurable (hf.prod_mk hg)).ae_measurable\n#align edist edist\n\n",
 "div":
 "@[to_additive]\nprotected theorem div [Group β] [TopologicalGroup β] (hf : ae_strongly_measurable f μ)\n    (hg : ae_strongly_measurable g μ) : ae_strongly_measurable (f / g) μ :=\n  ⟨hf.mk f / hg.mk g, hf.strongly_measurable_mk.div hg.strongly_measurable_mk, hf.ae_eq_mk.div hg.ae_eq_mk⟩\n#align div div\n\n",
 "dist":
 "protected theorem dist {β : Type _} [PseudoMetricSpace β] {f g : α → β} (hf : ae_strongly_measurable f μ)\n    (hg : ae_strongly_measurable g μ) : ae_strongly_measurable (fun x => dist (f x) (g x)) μ :=\n  continuous_dist.comp_ae_strongly_measurable (hf.prod_mk hg)\n#align dist dist\n\n",
 "const_smul'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\nprotected theorem const_smul' {𝕜} [SMul 𝕜 β] [ContinuousConstSMul 𝕜 β] (hf : ae_strongly_measurable f μ) (c : 𝕜) :\n    ae_strongly_measurable (fun x => «expr • » c (f x)) μ :=\n  hf.const_smul c\n#align const_smul' const_smul'\n\n",
 "const_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\nprotected theorem const_smul {𝕜} [TopologicalSpace 𝕜] [AddMonoid β] [Monoid 𝕜] [DistribMulAction 𝕜 β]\n    [ContinuousSMul 𝕜 β] (hf : ae_fin_strongly_measurable f μ) (c : 𝕜) : ae_fin_strongly_measurable («expr • » c f) μ :=\n  ⟨«expr • » c (hf.mk f), hf.fin_strongly_measurable_mk.const_smul c, hf.ae_eq_mk.const_smul c⟩\n#align const_smul const_smul\n\n",
 "const_mul":
 "@[to_additive]\nprotected theorem const_mul [Mul β] [ContinuousMul β] (hf : ae_strongly_measurable f μ) (c : β) :\n    ae_strongly_measurable (fun x => c * f x) μ :=\n  ae_strongly_measurable_const.mul hf\n#align const_mul const_mul\n\n",
 "congr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\n#print congr /-\ntheorem congr (hf : ae_strongly_measurable f μ) (h : «expr =ᵐ[ ] » f μ g) : ae_strongly_measurable g μ :=\n  ⟨hf.mk f, hf.strongly_measurable_mk, h.symm.trans hf.ae_eq_mk⟩\n#align congr congr\n-/\n\n",
 "comp_strongly_measurable_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/-- If `g` is a topological embedding, then `f` is strongly measurable iff `g ∘ f` is. -/\ntheorem _root_.embedding.comp_strongly_measurable_iff {m : MeasurableSpace α} [TopologicalSpace β]\n    [pseudo_metrizable_space β] [TopologicalSpace γ] [pseudo_metrizable_space γ] {g : β → γ} {f : α → β}\n    (hg : Embedding g) : (strongly_measurable fun x => g (f x)) ↔ strongly_measurable f :=\n  by\n  letI := pseudo_metrizable_space_pseudo_metric γ\n  borelize β γ\n  refine'\n    ⟨fun H => strongly_measurable_iff_measurable_separable.2 ⟨_, _⟩, fun H => hg.continuous.comp_strongly_measurable H⟩\n  · let G : β → range g := cod_restrict g (range g) mem_range_self\n    have hG : ClosedEmbedding G :=\n      { hg.cod_restrict _ _ with\n        closed_range := by\n          convert isClosed_univ\n          apply eq_univ_of_forall\n          rintro ⟨-, ⟨x, rfl⟩⟩\n          exact mem_range_self x }\n    have : Measurable (G ∘ f) := Measurable.subtype_mk H.measurable\n    exact hG.measurable_embedding.measurable_comp_iff.1 this\n  · have : is_separable («expr ⁻¹' » g (range (g ∘ f))) := hg.is_separable_preimage H.is_separable_range\n    convert this\n    ext x\n    simp [hg.inj.eq_iff]\n#align embedding.comp_strongly_measurable_iff embedding.comp_strongly_measurable_iff\n\n",
 "comp_strongly_measurable":
 "theorem _root_.continuous.comp_strongly_measurable {m : MeasurableSpace α} [TopologicalSpace β] [TopologicalSpace γ]\n    {g : β → γ} {f : α → β} (hg : Continuous g) (hf : strongly_measurable f) : strongly_measurable fun x => g (f x) :=\n  ⟨fun n => simple_func.map g (hf.approx n), fun x => (hg.tendsto _).comp (hf.tendsto_approx x)⟩\n#align continuous.comp_strongly_measurable continuous.comp_strongly_measurable\n\n",
 "comp_quasi_measure_preserving":
 "theorem comp_quasi_measure_preserving {γ : Type _} {mγ : MeasurableSpace γ} {mα : MeasurableSpace α} {f : γ → α}\n    {μ : Measure γ} {ν : Measure α} (hg : ae_strongly_measurable g ν) (hf : QuasiMeasurePreserving f μ ν) :\n    ae_strongly_measurable (g ∘ f) μ :=\n  (hg.mono' hf.absolutely_continuous).comp_measurable hf.measurable\n#align comp_quasi_measure_preserving comp_quasi_measure_preserving\n\n",
 "comp_measurable":
 "theorem comp_measurable {γ : Type _} {mγ : MeasurableSpace γ} {mα : MeasurableSpace α} {f : γ → α} {μ : Measure γ}\n    (hg : ae_strongly_measurable g (Measure.map f μ)) (hf : Measurable f) : ae_strongly_measurable (g ∘ f) μ :=\n  hg.comp_ae_measurable hf.ae_measurable\n#align comp_measurable comp_measurable\n\n",
 "comp_ae_strongly_measurable":
 "/-- The composition of a continuous function and an ae strongly measurable function is ae strongly\nmeasurable. -/\ntheorem _root_.continuous.comp_ae_strongly_measurable {g : β → γ} {f : α → β} (hg : Continuous g)\n    (hf : ae_strongly_measurable f μ) : ae_strongly_measurable (fun x => g (f x)) μ :=\n  ⟨_, hg.comp_strongly_measurable hf.strongly_measurable_mk, EventuallyEq.fun_comp hf.ae_eq_mk g⟩\n#align continuous.comp_ae_strongly_measurable continuous.comp_ae_strongly_measurable\n\n",
 "comp_ae_measurable":
 "theorem comp_ae_measurable {γ : Type _} {mγ : MeasurableSpace γ} {mα : MeasurableSpace α} {f : γ → α} {μ : Measure γ}\n    (hg : ae_strongly_measurable g (Measure.map f μ)) (hf : AEMeasurable f μ) : ae_strongly_measurable (g ∘ f) μ :=\n  ⟨hg.mk g ∘ hf.mk f, hg.strongly_measurable_mk.comp_measurable hf.measurable_mk,\n    (ae_eq_comp hf hg.ae_eq_mk).trans (hf.ae_eq_mk.fun_comp (hg.mk g))⟩\n#align comp_ae_measurable comp_ae_measurable\n\n",
 "apply_continuous_linear_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\ntheorem apply_continuous_linear_map {φ : α → «expr →L[ ] » F 𝕜 E} (hφ : ae_strongly_measurable φ μ) (v : F) :\n    ae_strongly_measurable (fun a => φ a v) μ :=\n  (continuous_linear_map.apply 𝕜 E v).continuous.comp_ae_strongly_measurable hφ\n#align apply_continuous_linear_map apply_continuous_linear_map\n\n",
 "ae_strongly_measurable_zero_measure":
 "@[simp]\ntheorem ae_strongly_measurable_zero_measure [MeasurableSpace α] [TopologicalSpace β] (f : α → β) :\n    ae_strongly_measurable f (0 : Measure α) := by\n  nontriviality α\n  inhabit α\n  exact ⟨fun x => f default, strongly_measurable_const, rfl⟩\n#align ae_strongly_measurable_zero_measure ae_strongly_measurable_zero_measure\n\n",
 "ae_strongly_measurable_with_density_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem _root_.ae_strongly_measurable_with_density_iff {E : Type _} [NormedAddCommGroup E] [NormedSpace (exprℝ) E]\n    {f : α → nnreal} (hf : Measurable f) {g : α → E} :\n    ae_strongly_measurable g (μ.with_density fun x => (f x : ennreal)) ↔\n      ae_strongly_measurable (fun x => «expr • » (f x : exprℝ) (g x)) μ :=\n  by\n  constructor\n  · rintro ⟨g', g'meas, hg'⟩\n    have A : MeasurableSet { x : α | f x ≠ 0 } := (hf (measurable_set_singleton 0)).compl\n    refine' ⟨fun x => «expr • » (f x : exprℝ) (g' x), hf.coe_nnreal_real.strongly_measurable.smul g'meas, _⟩\n    apply @ae_of_ae_restrict_of_ae_restrict_compl _ _ _ { x | f x ≠ 0 }\n    · rw [eventually_eq, ae_with_density_iff hf.coe_nnreal_ennreal] at hg'\n      rw [ae_restrict_iff' A]\n      filter_upwards [hg']with a ha h'a\n      have : (f a : ennreal) ≠ 0 := by simpa only [ne.def, ENNReal.coe_eq_zero] using h'a\n      rw [ha this]\n    · filter_upwards [ae_restrict_mem A.compl]with x hx\n      simp only [Classical.not_not, mem_set_of_eq, mem_compl_iff] at hx\n      simp [hx]\n  · rintro ⟨g', g'meas, hg'⟩\n    refine' ⟨fun x => «expr • » (f x : exprℝ)⁻¹ (g' x), hf.coe_nnreal_real.inv.strongly_measurable.smul g'meas, _⟩\n    rw [eventually_eq, ae_with_density_iff hf.coe_nnreal_ennreal]\n    filter_upwards [hg']with x hx h'x\n    rw [← hx, smul_smul, _root_.inv_mul_cancel, one_smul]\n    simp only [ne.def, ENNReal.coe_eq_zero] at h'x\n    simpa only [NNReal.coe_eq_zero, ne.def] using h'x\n#align ae_strongly_measurable_with_density_iff ae_strongly_measurable_with_density_iff\n\n",
 "ae_strongly_measurable_union_iff":
 "@[simp]\ntheorem _root_.ae_strongly_measurable_union_iff [pseudo_metrizable_space β] {s t : Set α} :\n    ae_strongly_measurable f (μ.restrict (s ∪ t)) ↔\n      ae_strongly_measurable f (μ.restrict s) ∧ ae_strongly_measurable f (μ.restrict t) :=\n  by simp only [union_eq_Union, ae_strongly_measurable_Union_iff, Bool.forall_bool, cond, and_comm]\n#align ae_strongly_measurable_union_iff ae_strongly_measurable_union_iff\n\n",
 "ae_strongly_measurable_uIoc_iff":
 "theorem ae_strongly_measurable_uIoc_iff [linear_order α] [pseudo_metrizable_space β] {f : α → β} {a b : α} :\n    ae_strongly_measurable f (μ.restrict <| uIoc a b) ↔\n      ae_strongly_measurable f (μ.restrict <| Ioc a b) ∧ ae_strongly_measurable f (μ.restrict <| Ioc b a) :=\n  by rw [uIoc_eq_union, ae_strongly_measurable_union_iff]\n#align ae_strongly_measurable_uIoc_iff ae_strongly_measurable_uIoc_iff\n\n",
 "ae_strongly_measurable_sum_measure_iff":
 "@[simp]\ntheorem _root_.ae_strongly_measurable_sum_measure_iff [pseudo_metrizable_space β] {m : MeasurableSpace α}\n    {μ : ι → Measure α} : ae_strongly_measurable f (Sum μ) ↔ ∀ i, ae_strongly_measurable f (μ i) :=\n  ⟨fun h i => h.mono_measure (Measure.le_sum _ _), sum_measure⟩\n#align ae_strongly_measurable_sum_measure_iff ae_strongly_measurable_sum_measure_iff\n\n",
 "ae_strongly_measurable_smul_const_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem _root_.ae_strongly_measurable_smul_const_iff {f : α → 𝕜} {c : E} (hc : c ≠ 0) :\n    ae_strongly_measurable (fun x => «expr • » (f x) c) μ ↔ ae_strongly_measurable f μ :=\n  (closed_embedding_smul_left hc).to_embedding.ae_strongly_measurable_comp_iff\n#align ae_strongly_measurable_smul_const_iff ae_strongly_measurable_smul_const_iff\n\n",
 "ae_strongly_measurable_prod'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n@[to_additive]\ntheorem _root_.finset.ae_strongly_measurable_prod' {ι : Type _} {f : ι → α → M} (s : Finset ι)\n    (hf : ∀ i ∈ s, ae_strongly_measurable (f i) μ) :\n    ae_strongly_measurable\n      (finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f i)) μ :=\n  multiset.ae_strongly_measurable_prod' _ fun g hg =>\n    let ⟨i, hi, hg⟩ := Multiset.mem_map.1 hg\n    hg ▸ hf _ hi\n#align finset.ae_strongly_measurable_prod' finset.ae_strongly_measurable_prod'\n\n",
 "ae_strongly_measurable_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n@[to_additive]\ntheorem _root_.finset.ae_strongly_measurable_prod {ι : Type _} {f : ι → α → M} (s : Finset ι)\n    (hf : ∀ i ∈ s, ae_strongly_measurable (f i) μ) :\n    ae_strongly_measurable\n      (fun a =>\n        finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f i a))\n      μ :=\n  by simpa only [← Finset.prod_apply] using s.ae_strongly_measurable_prod' hf\n#align finset.ae_strongly_measurable_prod finset.ae_strongly_measurable_prod\n\n",
 "ae_strongly_measurable_one":
 "@[to_additive]\ntheorem ae_strongly_measurable_one {α β} {m : MeasurableSpace α} {μ : Measure α} [TopologicalSpace β] [One β] :\n    ae_strongly_measurable (1 : α → β) μ :=\n  strongly_measurable_one.ae_strongly_measurable\n#align ae_strongly_measurable_one ae_strongly_measurable_one\n\n",
 "ae_strongly_measurable_of_tendsto_ae":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- An almost everywhere sequential limit of almost everywhere strongly measurable functions is\nalmost everywhere strongly measurable. -/\ntheorem _root_.ae_strongly_measurable_of_tendsto_ae {ι : Type _} [pseudo_metrizable_space β] (u : Filter ι) [NeBot u]\n    [IsCountablyGenerated u] {f : ι → α → β} {g : α → β} (hf : ∀ i, ae_strongly_measurable (f i) μ)\n    (lim :\n      «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\" μ\n        (Tendsto (fun n => f n x) u ((nhds) (g x)))) :\n    ae_strongly_measurable g μ := by\n  borelize β\n  refine' ae_strongly_measurable_iff_ae_measurable_separable.2 ⟨_, _⟩\n  · exact ae_measurable_of_tendsto_metrizable_ae _ (fun n => (hf n).ae_measurable) limUnder\n  · rcases u.exists_seq_tendsto with ⟨v, hv⟩\n    have : ∀ n : ℕ, ∃ t : Set β, is_separable t ∧ «expr ⁻¹' » (f (v n)) t ∈ μ.ae := fun n =>\n      (ae_strongly_measurable_iff_ae_measurable_separable.1 (hf (v n))).2\n    choose t t_sep ht using this\n    refine'\n      ⟨closure («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (t i)),\n        (is_separable_Union fun i => t_sep i).closure, _⟩\n    filter_upwards [ae_all_iff.2 ht, limUnder]with x hx h'x\n    apply mem_closure_of_tendsto (h'x.comp hv)\n    apply eventually_of_forall fun n => _\n    apply mem_Union_of_mem n\n    exact hx n\n#align ae_strongly_measurable_of_tendsto_ae ae_strongly_measurable_of_tendsto_ae\n\n",
 "ae_strongly_measurable_of_ae_strongly_measurable_trim":
 "theorem _root_.ae_strongly_measurable_of_ae_strongly_measurable_trim {α} {m m0 : MeasurableSpace α} {μ : Measure α}\n    (hm : m ≤ m0) {f : α → β} (hf : ae_strongly_measurable f (μ.trim hm)) : ae_strongly_measurable f μ :=\n  ⟨hf.mk f, strongly_measurable.mono hf.strongly_measurable_mk hm, ae_eq_of_ae_eq_trim hf.ae_eq_mk⟩\n#align ae_strongly_measurable_of_ae_strongly_measurable_trim ae_strongly_measurable_of_ae_strongly_measurable_trim\n\n",
 "ae_strongly_measurable_map_iff":
 "theorem _root_.measurable_embedding.ae_strongly_measurable_map_iff {γ : Type _} {mγ : MeasurableSpace γ}\n    {mα : MeasurableSpace α} {f : γ → α} {μ : Measure γ} (hf : MeasurableEmbedding f) {g : α → β} :\n    ae_strongly_measurable g (Measure.map f μ) ↔ ae_strongly_measurable (g ∘ f) μ :=\n  by\n  refine' ⟨fun H => H.comp_measurable hf.measurable, _⟩\n  rintro ⟨g₁, hgm₁, heq⟩\n  rcases hf.exists_strongly_measurable_extend hgm₁ fun x => ⟨g x⟩ with ⟨g₂, hgm₂, rfl⟩\n  exact ⟨g₂, hgm₂, hf.ae_map_iff.2 HEq⟩\n#align measurable_embedding.ae_strongly_measurable_map_iff measurable_embedding.ae_strongly_measurable_map_iff\n\n",
 "ae_strongly_measurable_indicator_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\ntheorem _root_.ae_strongly_measurable_indicator_iff [Zero β] {s : Set α} (hs : MeasurableSet s) :\n    ae_strongly_measurable (indicator s f) μ ↔ ae_strongly_measurable f (μ.restrict s) :=\n  by\n  constructor\n  · intro h\n    exact (h.mono_measure measure.restrict_le_self).congr (indicator_ae_eq_restrict hs)\n  · intro h\n    refine' ⟨indicator s (h.mk f), h.strongly_measurable_mk.indicator hs, _⟩\n    have A : «expr =ᵐ[ ] » (s.indicator f) (μ.restrict s) (s.indicator (h.mk f)) :=\n      (indicator_ae_eq_restrict hs).trans (h.ae_eq_mk.trans <| (indicator_ae_eq_restrict hs).symm)\n    have B : «expr =ᵐ[ ] » (s.indicator f) (μ.restrict («expr ᶜ» s)) (s.indicator (h.mk f)) :=\n      (indicator_ae_eq_restrict_compl hs).trans (indicator_ae_eq_restrict_compl hs).symm\n    exact ae_of_ae_restrict_of_ae_restrict_compl _ A B\n#align ae_strongly_measurable_indicator_iff ae_strongly_measurable_indicator_iff\n\n",
 "ae_strongly_measurable_iff_ae_measurable_separable":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\n/-- A function is almost everywhere strongly measurable if and only if it is almost everywhere\nmeasurable, and up to a zero measure set its range is contained in a separable set. -/\ntheorem _root_.ae_strongly_measurable_iff_ae_measurable_separable [pseudo_metrizable_space β] [MeasurableSpace β]\n    [borel_space β] :\n    ae_strongly_measurable f μ ↔\n      AEMeasurable f μ ∧\n        ∃ t : Set β,\n          IsSeparable t ∧\n            «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\" μ\n              (f x ∈ t) :=\n  by\n  refine' ⟨fun H => ⟨H.ae_measurable, H.is_separable_ae_range⟩, _⟩\n  rintro ⟨H, ⟨t, t_sep, ht⟩⟩\n  rcases eq_empty_or_nonempty t with (rfl | h₀)\n  · simp only [mem_empty_iff_false, eventually_false_iff_eq_bot, ae_eq_bot] at ht\n    rw [ht]\n    exact ae_strongly_measurable_zero_measure f\n  · obtain ⟨g, g_meas, gt, fg⟩ : ∃ g : α → β, Measurable g ∧ range g ⊆ t ∧ «expr =ᵐ[ ] » f μ g :=\n      H.exists_ae_eq_range_subset ht h₀\n    refine' ⟨g, _, fg⟩\n    exact strongly_measurable_iff_measurable_separable.2 ⟨g_meas, t_sep.mono GT.gt⟩\n#align ae_strongly_measurable_iff_ae_measurable_separable ae_strongly_measurable_iff_ae_measurable_separable\n\n",
 "ae_strongly_measurable_iff_ae_measurable":
 "/-- In a space with second countable topology, strongly measurable and measurable are equivalent. -/\ntheorem _root_.ae_strongly_measurable_iff_ae_measurable [pseudo_metrizable_space β] [borel_space β]\n    [SecondCountableTopology β] : ae_strongly_measurable f μ ↔ AEMeasurable f μ :=\n  ⟨fun h => h.ae_measurable, fun h => h.ae_strongly_measurable⟩\n#align ae_strongly_measurable_iff_ae_measurable ae_strongly_measurable_iff_ae_measurable\n\n",
 "ae_strongly_measurable_id":
 "theorem _root_.ae_strongly_measurable_id {α : Type _} [TopologicalSpace α] [pseudo_metrizable_space α]\n    {m : MeasurableSpace α} [opens_measurable_space α] [SecondCountableTopology α] {μ : Measure α} :\n    ae_strongly_measurable (id : α → α) μ :=\n  aemeasurable_id.ae_strongly_measurable\n#align ae_strongly_measurable_id ae_strongly_measurable_id\n\n",
 "ae_strongly_measurable_const_smul_iff₀":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem _root_.ae_strongly_measurable_const_smul_iff₀ {c : G₀} (hc : c ≠ 0) :\n    ae_strongly_measurable (fun x => «expr • » c (f x)) μ ↔ ae_strongly_measurable f μ :=\n  by\n  refine' ⟨fun h => _, fun h => h.const_smul c⟩\n  convert h.const_smul' c⁻¹\n  simp [smul_smul, inv_mul_cancel hc]\n#align ae_strongly_measurable_const_smul_iff₀ ae_strongly_measurable_const_smul_iff₀\n\n",
 "ae_strongly_measurable_const_smul_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem _root_.ae_strongly_measurable_const_smul_iff (c : G) :\n    ae_strongly_measurable (fun x => «expr • » c (f x)) μ ↔ ae_strongly_measurable f μ :=\n  ⟨fun h => by simpa only [inv_smul_smul] using h.const_smul' c⁻¹, fun h => h.const_smul c⟩\n#align ae_strongly_measurable_const_smul_iff ae_strongly_measurable_const_smul_iff\n\n",
 "ae_strongly_measurable_const":
 "theorem ae_strongly_measurable_const {α β} {m : MeasurableSpace α} {μ : Measure α} [TopologicalSpace β] {b : β} :\n    ae_strongly_measurable (fun a : α => b) μ :=\n  strongly_measurable_const.ae_strongly_measurable\n#align ae_strongly_measurable_const ae_strongly_measurable_const\n\n",
 "ae_strongly_measurable_congr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\ntheorem _root_.ae_strongly_measurable_congr (h : «expr =ᵐ[ ] » f μ g) :\n    ae_strongly_measurable f μ ↔ ae_strongly_measurable g μ :=\n  ⟨fun hf => hf.congr h, fun hg => hg.congr h.symm⟩\n#align ae_strongly_measurable_congr ae_strongly_measurable_congr\n\n",
 "ae_strongly_measurable_comp₂":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\ntheorem _root_.continuous_linear_map.ae_strongly_measurable_comp₂ (L : «expr →L[ ] » E 𝕜 («expr →L[ ] » F 𝕜 G))\n    {f : α → E} {g : α → F} (hf : ae_strongly_measurable f μ) (hg : ae_strongly_measurable g μ) :\n    ae_strongly_measurable (fun x => L (f x) (g x)) μ :=\n  L.continuous₂.comp_ae_strongly_measurable <| hf.prod_mk hg\n#align continuous_linear_map.ae_strongly_measurable_comp₂ continuous_linear_map.ae_strongly_measurable_comp₂\n\n",
 "ae_strongly_measurable_comp_iff":
 "theorem _root_.measure_theory.measure_preserving.ae_strongly_measurable_comp_iff {β : Type _} {f : α → β}\n    {mα : MeasurableSpace α} {μa : Measure α} {mβ : MeasurableSpace β} {μb : Measure β} (hf : MeasurePreserving f μa μb)\n    (h₂ : MeasurableEmbedding f) {g : β → γ} : ae_strongly_measurable (g ∘ f) μa ↔ ae_strongly_measurable g μb := by\n  rw [← hf.map_eq, h₂.ae_strongly_measurable_map_iff]\n#align measure_theory.measure_preserving.ae_strongly_measurable_comp_iff measure_theory.measure_preserving.ae_strongly_measurable_comp_iff\n\n",
 "ae_strongly_measurable_add_measure_iff":
 "@[simp]\ntheorem _root_.ae_strongly_measurable_add_measure_iff [pseudo_metrizable_space β] {ν : Measure α} :\n    ae_strongly_measurable f (μ + ν) ↔ ae_strongly_measurable f μ ∧ ae_strongly_measurable f ν :=\n  by\n  rw [← sum_cond, ae_strongly_measurable_sum_measure_iff, Bool.forall_bool, and_comm]\n  rfl\n#align ae_strongly_measurable_add_measure_iff ae_strongly_measurable_add_measure_iff\n\n",
 "ae_strongly_measurable_Union_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n@[simp]\ntheorem _root_.ae_strongly_measurable_Union_iff [pseudo_metrizable_space β] {s : ι → Set α} :\n    ae_strongly_measurable f\n        (μ.restrict\n          («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (s i))) ↔\n      ∀ i, ae_strongly_measurable f (μ.restrict (s i)) :=\n  ⟨fun h i => h.mono_measure <| restrict_mono (subset_unionᵢ _ _) le_rfl, ae_strongly_measurable.Union⟩\n#align ae_strongly_measurable_Union_iff ae_strongly_measurable_Union_iff\n\n",
 "ae_strongly_measurable'":
 "@[simp]\ntheorem subsingleton.ae_strongly_measurable' {m : MeasurableSpace α} [TopologicalSpace β] [subsingleton α]\n    {μ : Measure α} (f : α → β) : ae_strongly_measurable f μ :=\n  (subsingleton.strongly_measurable' f).ae_strongly_measurable\n#align subsingleton.ae_strongly_measurable' subsingleton.ae_strongly_measurable'\n\n",
 "ae_strongly_measurable":
 "/-- In a space with second countable topology, measurable implies strongly measurable. -/\ntheorem _root_.ae_measurable.ae_strongly_measurable [pseudo_metrizable_space β] [opens_measurable_space β]\n    [SecondCountableTopology β] (hf : AEMeasurable f μ) : ae_strongly_measurable f μ :=\n  ⟨hf.mk f, hf.measurable_mk.strongly_measurable, hf.ae_eq_mk⟩\n#align ae_measurable.ae_strongly_measurable ae_measurable.ae_strongly_measurable\n\n",
 "ae_mem_imp_eq_mk":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\ntheorem ae_mem_imp_eq_mk {s} (h : ae_strongly_measurable f (μ.restrict s)) :\n    «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\" μ\n      (x ∈ s → f x = h.mk f x) :=\n  ae_imp_of_ae_restrict h.ae_eq_mk\n#align ae_mem_imp_eq_mk ae_mem_imp_eq_mk\n\n",
 "ae_fin_strongly_measurable_zero":
 "theorem ae_fin_strongly_measurable_zero {α β} {m : MeasurableSpace α} (μ : Measure α) [Zero β] [TopologicalSpace β] :\n    ae_fin_strongly_measurable (0 : α → β) μ :=\n  ⟨0, fin_strongly_measurable_zero, EventuallyEq.rfl⟩\n#align ae_fin_strongly_measurable_zero ae_fin_strongly_measurable_zero\n\n",
 "ae_fin_strongly_measurable_iff_ae_measurable":
 "/-- In a space with second countable topology and a sigma-finite measure,\n  `ae_fin_strongly_measurable` and `ae_measurable` are equivalent. -/\ntheorem ae_fin_strongly_measurable_iff_ae_measurable {m0 : MeasurableSpace α} (μ : Measure α) [SigmaFinite μ] :\n    ae_fin_strongly_measurable f μ ↔ AEMeasurable f μ := by\n  simp_rw [ae_fin_strongly_measurable, AEMeasurable, fin_strongly_measurable_iff_measurable]\n#align ae_fin_strongly_measurable_iff_ae_measurable ae_fin_strongly_measurable_iff_ae_measurable\n\n",
 "ae_fin_strongly_measurable":
 "theorem ae_fin_strongly_measurable [Zero β] [TopologicalSpace β] (hf : fin_strongly_measurable f μ) :\n    ae_fin_strongly_measurable f μ :=\n  ⟨f, hf, ae_eq_refl f⟩\n#align ae_fin_strongly_measurable ae_fin_strongly_measurable\n\n",
 "ae_eq_zero_compl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\ntheorem ae_eq_zero_compl (hf : ae_fin_strongly_measurable f μ) :\n    «expr =ᵐ[ ] » f (μ.restrict («expr ᶜ» hf.sigma_finite_set)) 0 :=\n  hf.exists_set_sigma_finite.some_spec.2.1\n#align ae_eq_zero_compl ae_eq_zero_compl\n\n",
 "ae_eq_mk":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\ntheorem ae_eq_mk (hf : ae_fin_strongly_measurable f μ) : «expr =ᵐ[ ] » f μ (hf.mk f) :=\n  hf.some_spec.2\n#align ae_eq_mk ae_eq_mk\n\n",
 "add_measure":
 "theorem add_measure [pseudo_metrizable_space β] {ν : Measure α} {f : α → β} (hμ : ae_strongly_measurable f μ)\n    (hν : ae_strongly_measurable f ν) : ae_strongly_measurable f (μ + ν) :=\n  ae_strongly_measurable_add_measure_iff.2 ⟨hμ, hν⟩\n#align add_measure add_measure\n\n",
 "add":
 "protected theorem add [AddMonoid β] [ContinuousAdd β] (hf : ae_fin_strongly_measurable f μ)\n    (hg : ae_fin_strongly_measurable g μ) : ae_fin_strongly_measurable (f + g) μ :=\n  ⟨hf.mk f + hg.mk g, hf.fin_strongly_measurable_mk.add hg.fin_strongly_measurable_mk, hf.ae_eq_mk.add hg.ae_eq_mk⟩\n#align add add\n\n",
 "Union":
 "/- warning: Union clashes with has_union -> Union\nCase conversion may be inaccurate. Consider using '#align Union Unionₓ'. -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n#print Union /-\nprotected theorem Union [pseudo_metrizable_space β] {s : ι → Set α}\n    (h : ∀ i, ae_strongly_measurable f (μ.restrict (s i))) :\n    ae_strongly_measurable f\n      (μ.restrict\n        («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (s i))) :=\n  (sum_measure h).mono_measure <| restrict_unionᵢ_le\n#align Union Union\n-/\n\n",
 "MeasurableSet":
 "#print MeasurableSet /-\nprotected theorem MeasurableSet (hf : ae_fin_strongly_measurable f μ) : MeasurableSet hf.sigma_finite_set :=\n  hf.exists_set_sigma_finite.some_spec.1\n#align measurable_set MeasurableSet\n-/\n\n",
 "Measurable":
 "#print Measurable /-\n/-- A finitely strongly measurable function is measurable. -/\nprotected theorem Measurable [Zero β] [TopologicalSpace β] [pseudo_metrizable_space β] [MeasurableSpace β]\n    [borel_space β] (hf : fin_strongly_measurable f μ) : Measurable f :=\n  hf.strongly_measurable.measurable\n#align measurable Measurable\n-/\n\n",
 "AEMeasurable":
 "#print AEMeasurable /-\nprotected theorem AEMeasurable {β} [Zero β] [MeasurableSpace β] [TopologicalSpace β] [pseudo_metrizable_space β]\n    [borel_space β] {f : α → β} (hf : ae_fin_strongly_measurable f μ) : AEMeasurable f μ :=\n  ⟨hf.mk f, hf.fin_strongly_measurable_mk.measurable, hf.ae_eq_mk⟩\n#align ae_measurable AEMeasurable\n-/\n\n"}