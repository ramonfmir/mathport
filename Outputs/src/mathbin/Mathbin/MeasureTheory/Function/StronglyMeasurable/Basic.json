{"tendsto_approx_bounded_of_norm_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `strongly_measurable_of -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem tendsto_approx_bounded_of_norm_le {Î²} {f : Î± â†’ Î²} [NormedAddCommGroup Î²] [NormedSpace (exprâ„) Î²]\n    {m : MeasurableSpace Î±} (hf : (strongly_measurable_of m) f) {c : exprâ„} {x : Î±} (hfx : Â«exprâ€– â€–Â» (f x) â‰¤ c) :\n    Tendsto (fun n => hf.approx_bounded c n x) atTop ((nhds) (f x)) :=\n  by\n  have h_tendsto := hf.tendsto_approx x\n  simp only [strongly_measurable.approx_bounded, simple_func.coe_map, Function.comp_apply]\n  by_cases hfx0 : Â«exprâ€– â€–Â» (f x) = 0\n  Â· rw [norm_eq_zero] at hfx0\n    rw [hfx0] at h_tendstoâŠ¢\n    have h_tendsto_norm : tendsto (fun n => Â«exprâ€– â€–Â» (hf.approx n x)) at_top ((nhds) 0) :=\n      by\n      convert h_tendsto.norm\n      rw [norm_zero]\n    refine' squeeze_zero_norm (fun n => _) h_tendsto_norm\n    calc\n      Â«exprâ€– â€–Â» (Â«expr â€¢ Â» (min 1 (c / Â«exprâ€– â€–Â» (hf.approx n x))) (hf.approx n x)) =\n          Â«exprâ€– â€–Â» (min 1 (c / Â«exprâ€– â€–Â» (hf.approx n x))) * Â«exprâ€– â€–Â» (hf.approx n x) :=\n        norm_smul _ _\n      _ â‰¤ Â«exprâ€– â€–Â» (1 : exprâ„) * Â«exprâ€– â€–Â» (hf.approx n x) :=\n        by\n        refine' mul_le_mul_of_nonneg_right _ (norm_nonneg _)\n        rw [norm_one, Real.norm_of_nonneg]\n        Â· exact min_le_left _ _\n        Â· exact le_min zero_le_one (div_nonneg ((norm_nonneg _).trans hfx) (norm_nonneg _))\n      _ = Â«exprâ€– â€–Â» (hf.approx n x) := by rw [norm_one, one_mul]\n      \n  rw [â† one_smul (exprâ„) (f x)]\n  refine' tendsto.smul _ h_tendsto\n  have : min 1 (c / Â«exprâ€– â€–Â» (f x)) = 1 :=\n    by\n    rw [min_eq_left_iff, one_le_div (lt_of_le_of_ne (norm_nonneg _) (ne.symm hfx0))]\n    exact hfx\n  nth_rw 1 [this.symm]\n  refine' tendsto.min tendsto_const_nhds _\n  refine' tendsto.div tendsto_const_nhds h_tendsto.norm hfx0\n#align tendsto_approx_bounded_of_norm_le tendsto_approx_bounded_of_norm_le\n\n",
 "tendsto_approx_bounded_ae":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `strongly_measurable_of -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€áµ âˆ‚ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€áµ âˆ‚ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€áµ âˆ‚ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€áµ âˆ‚ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem tendsto_approx_bounded_ae {Î²} {f : Î± â†’ Î²} [NormedAddCommGroup Î²] [NormedSpace (exprâ„) Î²]\n    {m m0 : MeasurableSpace Î±} {Î¼ : Measure Î±} (hf : (strongly_measurable_of m) f) {c : exprâ„}\n    (hf_bound :\n      Â«exprâˆ€áµ âˆ‚ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€áµ âˆ‚ , Â»\" Î¼\n        (Â«exprâ€– â€–Â» (f x) â‰¤ c)) :\n    Â«exprâˆ€áµ âˆ‚ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€áµ âˆ‚ , Â»\" Î¼\n      (Tendsto (fun n => hf.approx_bounded c n x) atTop ((nhds) (f x))) :=\n  by filter_upwards [hf_bound]with x hfx using tendsto_approx_bounded_of_norm_le hf hfx\n#align tendsto_approx_bounded_ae tendsto_approx_bounded_ae\n\n",
 "tendsto_approx":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\nprotected theorem tendsto_approx : âˆ€ x, Tendsto (fun n => hf.approx n x) atTop ((nhds) (f x)) :=\n  hf.some_spec.2\n#align tendsto_approx tendsto_approx\n\n",
 "sup":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŠ” Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŠ” Â» -/\nprotected theorem sup [SemilatticeSup Î²] [ContinuousSup Î²] (hf : ae_fin_strongly_measurable f Î¼)\n    (hg : ae_fin_strongly_measurable g Î¼) : ae_fin_strongly_measurable (Â«expr âŠ” Â» f g) Î¼ :=\n  âŸ¨Â«expr âŠ” Â» (hf.mk f) (hg.mk g), hf.fin_strongly_measurable_mk.sup hg.fin_strongly_measurable_mk,\n    hf.ae_eq_mk.sup hg.ae_eq_mkâŸ©\n#align sup sup\n\n",
 "sum_measure":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â» -/\ntheorem sum_measure [pseudo_metrizable_space Î²] {m : MeasurableSpace Î±} {Î¼ : Î¹ â†’ Measure Î±}\n    (h : âˆ€ i, ae_strongly_measurable f (Î¼ i)) : ae_strongly_measurable f (Measure.sum Î¼) :=\n  by\n  borelize Î²\n  refine'\n    ae_strongly_measurable_iff_ae_measurable_separable.2 âŸ¨AEMeasurable.sum_measure fun i => (h i).ae_measurable, _âŸ©\n  have A : âˆ€ i : Î¹, âˆƒ t : Set Î², is_separable t âˆ§ Â«expr â»Â¹' Â» f t âˆˆ (Î¼ i).ae := fun i =>\n    (ae_strongly_measurable_iff_ae_measurable_separable.1 (h i)).2\n  choose t t_sep ht using A\n  refine'\n    âŸ¨Â«exprâ‹ƒ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â»\" (t i),\n      is_separable_Union t_sep, _âŸ©\n  simp only [measure.ae_sum_eq, mem_Union, eventually_supr]\n  intro i\n  filter_upwards [ht i]with x hx\n  exact âŸ¨i, hxâŸ©\n#align sum_measure sum_measure\n\n",
 "sub":
 "protected theorem sub [AddGroup Î²] [ContinuousSub Î²] (hf : ae_fin_strongly_measurable f Î¼)\n    (hg : ae_fin_strongly_measurable g Î¼) : ae_fin_strongly_measurable (f - g) Î¼ :=\n  âŸ¨hf.mk f - hg.mk g, hf.fin_strongly_measurable_mk.sub hg.fin_strongly_measurable_mk, hf.ae_eq_mk.sub hg.ae_eq_mkâŸ©\n#align sub sub\n\n",
 "strongly_measurable_uncurry_of_continuous_of_strongly_measurable":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ†¥ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ†¥ Â» -/\ntheorem strongly_measurable_uncurry_of_continuous_of_strongly_measurable {Î± Î² Î¹ : Type _} [TopologicalSpace Î¹]\n    [metrizable_space Î¹] [MeasurableSpace Î¹] [SecondCountableTopology Î¹] [opens_measurable_space Î¹] [TopologicalSpace Î²]\n    [pseudo_metrizable_space Î²] [MeasurableSpace Î±] {u : Î¹ â†’ Î± â†’ Î²} (hu_cont : âˆ€ x, Continuous fun i => u i x)\n    (h : âˆ€ i, strongly_measurable (u i)) : strongly_measurable (function.uncurry u) :=\n  by\n  borelize Î²\n  obtain âŸ¨t_sf, ht_sfâŸ© : âˆƒ t : â„• â†’ simple_func Î¹ Î¹, âˆ€ j x, tendsto (fun n => u (t n j) x) at_top (nhds <| u j x) :=\n    by\n    have h_str_meas : strongly_measurable (id : Î¹ â†’ Î¹) := strongly_measurable_id\n    refine' âŸ¨h_str_meas.approx, fun j x => _âŸ©\n    exact ((hu_cont x).tendsto j).comp (h_str_meas.tendsto_approx j)\n  let U (n : â„•) (p : Î¹ Ã— Î±) := u (t_sf n p.fst) p.snd\n  have h_tendsto : tendsto U at_top ((nhds) fun p => u p.fst p.snd) :=\n    by\n    rw [tendsto_pi_nhds]\n    exact fun p => ht_sf p.fst p.snd\n  refine' strongly_measurable_of_tendsto _ (fun n => _) h_tendsto\n  have h_str_meas : strongly_measurable fun p : (t_sf n).range Ã— Î± => u (â†‘p.fst) p.snd :=\n    by\n    refine' strongly_measurable_iff_measurable_separable.2 âŸ¨_, _âŸ©\n    Â· have :\n        (fun p : Â«exprâ†¥ Â» (t_sf n).range Ã— Î± => u (â†‘p.fst) p.snd) =\n          (fun p : Î± Ã— (t_sf n).range => u (â†‘p.snd) p.fst) âˆ˜ Prod.swap :=\n        rfl\n      rw [this, measurable_swap_iff]\n      exact measurable_from_prod_countable fun j => (h j).measurable\n    Â· have :\n        is_separable\n          (Â«exprâ‹ƒ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â»\"\n            (range (u i))) :=\n        is_separable_Union fun i => (h i).is_separable_range\n      apply this.mono\n      rintro _ âŸ¨âŸ¨i, xâŸ©, rflâŸ©\n      simp only [mem_Union, mem_range]\n      exact âŸ¨i, x, rflâŸ©\n  have :\n    (fun p : Î¹ Ã— Î± => u (t_sf n p.fst) p.snd) =\n      (fun p : Â«exprâ†¥ Â» (t_sf n).range Ã— Î± => u p.fst p.snd) âˆ˜ fun p : Î¹ Ã— Î± =>\n        (âŸ¨t_sf n p.fst, simple_func.mem_range_self _ _âŸ©, p.snd) :=\n    rfl\n  simp_rw [U, this]\n  refine' h_str_meas.comp_measurable (Measurable.prod_mk _ measurable_snd)\n  exact ((t_sf n).measurable.comp measurable_fst).subtype_mk\n#align strongly_measurable_uncurry_of_continuous_of_strongly_measurable strongly_measurable_uncurry_of_continuous_of_strongly_measurable\n\n",
 "strongly_measurable_prod'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n@[to_additive]\ntheorem _root_.finset.strongly_measurable_prod' {Î¹ : Type _} {f : Î¹ â†’ Î± â†’ M} (s : Finset Î¹)\n    (hf : âˆ€ i âˆˆ s, strongly_measurable (f i)) :\n    strongly_measurable\n      (finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f i)) :=\n  Finset.prod_induction _ _ (fun a b ha hb => ha.mul hb) (@strongly_measurable_one Î± M _ _ _) hf\n#align finset.strongly_measurable_prod' finset.strongly_measurable_prod'\n\n",
 "strongly_measurable_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n@[to_additive]\ntheorem _root_.finset.strongly_measurable_prod {Î¹ : Type _} {f : Î¹ â†’ Î± â†’ M} (s : Finset Î¹)\n    (hf : âˆ€ i âˆˆ s, strongly_measurable (f i)) :\n    strongly_measurable fun a =>\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f i a) :=\n  by simpa only [â† Finset.prod_apply] using s.strongly_measurable_prod' hf\n#align finset.strongly_measurable_prod finset.strongly_measurable_prod\n\n",
 "strongly_measurable_one":
 "@[to_additive]\ntheorem strongly_measurable_one {Î± Î²} {m : MeasurableSpace Î±} [TopologicalSpace Î²] [One Î²] :\n    strongly_measurable (1 : Î± â†’ Î²) :=\n  @strongly_measurable_const _ _ _ _ 1\n#align strongly_measurable_one strongly_measurable_one\n\n",
 "strongly_measurable_of_tendsto":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- A sequential limit of strongly measurable functions is strongly measurable. -/\ntheorem _root_.strongly_measurable_of_tendsto {Î¹ : Type _} {m : MeasurableSpace Î±} [TopologicalSpace Î²]\n    [pseudo_metrizable_space Î²] (u : Filter Î¹) [NeBot u] [IsCountablyGenerated u] {f : Î¹ â†’ Î± â†’ Î²} {g : Î± â†’ Î²}\n    (hf : âˆ€ i, strongly_measurable (f i)) (lim : Tendsto f u ((nhds) g)) : strongly_measurable g :=\n  by\n  borelize Î²\n  refine' strongly_measurable_iff_measurable_separable.2 âŸ¨_, _âŸ©\n  Â· exact measurable_of_tendsto_metrizable' u (fun i => (hf i).measurable) limUnder\n  Â· rcases u.exists_seq_tendsto with âŸ¨v, hvâŸ©\n    have :\n      is_separable\n        (closure\n          (Â«exprâ‹ƒ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â»\"\n            (range (f (v i))))) :=\n      (is_separable_Union fun i => (hf (v i)).is_separable_range).closure\n    apply this.mono\n    rintro _ âŸ¨x, rflâŸ©\n    rw [tendsto_pi_nhds] at lim\n    apply mem_closure_of_tendsto ((limUnder x).comp hv)\n    apply eventually_of_forall fun n => _\n    apply mem_Union_of_mem n\n    exact mem_range_self _\n#align strongly_measurable_of_tendsto strongly_measurable_of_tendsto\n\n",
 "strongly_measurable_of_strongly_measurable_union_cover":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚› Â» -/\ntheorem _root_.strongly_measurable_of_strongly_measurable_union_cover {m : MeasurableSpace Î±} [TopologicalSpace Î²]\n    {f : Î± â†’ Î²} (s t : Set Î±) (hs : MeasurableSet s) (ht : MeasurableSet t) (h : univ âŠ† s âˆª t)\n    (hc : strongly_measurable fun a : s => f a) (hd : strongly_measurable fun a : t => f a) : strongly_measurable f :=\n  by\n  classical\n    let f : â„• â†’ Â«expr â†’â‚› Â» Î± Î² := fun n =>\n      { to_fun := fun x =>\n          if hx : x âˆˆ s then hc.approx n âŸ¨x, hxâŸ© else hd.approx n âŸ¨x, by simpa [hx] using h (mem_univ x)âŸ©\n        measurable_set_fiber' := by\n          intro x\n          convert(hs.subtype_image ((hc.approx n).measurable_set_fiber x)).union\n              ((ht.subtype_image ((hd.approx n).measurable_set_fiber x)).diff hs)\n          ext1 y\n          simp only [mem_union, mem_preimage, mem_singleton_iff, mem_image, SetCoe.exists, Subtype.coe_mk,\n            exists_and_right, exists_eq_right, mem_diff]\n          by_cases hy : y âˆˆ s\n          Â· rw [dif_pos hy]\n            simp only [hy, exists_true_left, not_true, and_false_iff, or_false_iff]\n          Â· rw [dif_neg hy]\n            have A : y âˆˆ t := by simpa [hy] using h (mem_univ y)\n            simp only [A, hy, false_or_iff, IsEmpty.exists_iff, not_false_iff, and_true_iff, exists_true_left]\n        finite_range' := by\n          apply ((hc.approx n).finite_range.union (hd.approx n).finite_range).subset\n          rintro - âŸ¨y, rflâŸ©\n          dsimp\n          by_cases hy : y âˆˆ s\n          Â· left\n            rw [dif_pos hy]\n            exact mem_range_self _\n          Â· right\n            rw [dif_neg hy]\n            exact mem_range_self _ }\n    refine' âŸ¨f, fun y => _âŸ©\n    by_cases hy : y âˆˆ s\n    Â· convert hc.tendsto_approx âŸ¨y, hyâŸ© using 1\n      ext1 n\n      simp only [dif_pos hy, simple_func.apply_mk]\n    Â· have A : y âˆˆ t := by simpa [hy] using h (mem_univ y)\n      convert hd.tendsto_approx âŸ¨y, AâŸ© using 1\n      ext1 n\n      simp only [dif_neg hy, simple_func.apply_mk]\n#align strongly_measurable_of_strongly_measurable_union_cover strongly_measurable_of_strongly_measurable_union_cover\n\n",
 "strongly_measurable_of_restrict_of_restrict_compl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á¶œÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á¶œÂ» -/\ntheorem _root_.strongly_measurable_of_restrict_of_restrict_compl {m : MeasurableSpace Î±} [TopologicalSpace Î²]\n    {f : Î± â†’ Î²} {s : Set Î±} (hs : MeasurableSet s) (hâ‚ : strongly_measurable (s.restrict f))\n    (hâ‚‚ : strongly_measurable ((Â«expr á¶œÂ» s).restrict f)) : strongly_measurable f :=\n  strongly_measurable_of_strongly_measurable_union_cover s (Â«expr á¶œÂ» s) hs hs.compl (union_compl_self s).ge hâ‚ hâ‚‚\n#align strongly_measurable_of_restrict_of_restrict_compl strongly_measurable_of_restrict_of_restrict_compl\n\n",
 "strongly_measurable_of_measurable_space_le_on":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á¶œÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á¶œÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á¶œÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `strongly_measurable_of -/\n/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (x Â«expr âˆ‰ Â» s) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `strongly_measurable_of -/\n/-- If the restriction to a set `s` of a Ïƒ-algebra `m` is included in the restriction to `s` of\nanother Ïƒ-algebra `mâ‚‚` (hypothesis `hs`), the set `s` is `m` measurable and a function `f` supported\non `s` is `m`-strongly-measurable, then `f` is also `mâ‚‚`-strongly-measurable. -/\ntheorem strongly_measurable_of_measurable_space_le_on {Î± E} {m mâ‚‚ : MeasurableSpace Î±} [TopologicalSpace E] [Zero E]\n    {s : Set Î±} {f : Î± â†’ E} (hs_m : (measurable_set_of m) s)\n    (hs : âˆ€ t, (measurable_set_of m) (s âˆ© t) â†’ (measurable_set_of mâ‚‚) (s âˆ© t)) (hf : (strongly_measurable_of m) f)\n    (hf_zero : âˆ€ (x) (_ : x âˆ‰ s), f x = 0) : (strongly_measurable_of mâ‚‚) f :=\n  by\n  have hs_mâ‚‚ : (measurable_set_of mâ‚‚) s := by\n    rw [â† Set.inter_univ s]\n    refine' hs Set.univ _\n    rwa [Set.inter_univ]\n  obtain âŸ¨g_seq_s, hg_seq_tendsto, hg_seq_zeroâŸ© := strongly_measurable_in_set hs_m hf hf_zero\n  let g_seq_sâ‚‚ : â„• â†’ @simple_func Î± mâ‚‚ E := fun n =>\n    { to_fun := g_seq_s n\n      measurable_set_fiber' := fun x =>\n        by\n        rw [â† Set.inter_univ (Â«expr â»Â¹' Â» (g_seq_s n) {x}), â† Set.union_compl_self s, Set.inter_union_distrib_left,\n          Set.inter_comm (Â«expr â»Â¹' Â» (g_seq_s n) {x})]\n        refine' MeasurableSet.union (hs _ (hs_m.inter _)) _\n        Â· exact @simple_func.measurable_set_fiber _ _ m _ _\n        by_cases hx : x = 0\n        Â· suffices Â«expr â»Â¹' Â» (g_seq_s n) {x} âˆ© Â«expr á¶œÂ» s = Â«expr á¶œÂ» s\n            by\n            rw [this]\n            exact hs_mâ‚‚.compl\n          ext1 y\n          rw [hx, Set.mem_inter_iff, Set.mem_preimage, Set.mem_singleton_iff]\n          exact âŸ¨fun h => h.2, fun h => âŸ¨hg_seq_zero y h n, hâŸ©âŸ©\n        Â· suffices Â«expr â»Â¹' Â» (g_seq_s n) {x} âˆ© Â«expr á¶œÂ» s = âˆ…\n            by\n            rw [this]\n            exact MeasurableSet.empty\n          ext1 y\n          simp only [mem_inter_iff, mem_preimage, mem_singleton_iff, mem_compl_iff, mem_empty_iff_false, iff_false_iff,\n            not_and, not_not_mem]\n          refine' imp_of_not_imp_not _ _ fun hys => _\n          rw [hg_seq_zero y hys n]\n          exact ne.symm hx\n      finite_range' := @simple_func.finite_range _ _ m (g_seq_s n) }\n  have hg_eq : âˆ€ x n, g_seq_sâ‚‚ n x = g_seq_s n x := fun x n => rfl\n  refine' âŸ¨g_seq_sâ‚‚, fun x => _âŸ©\n  simp_rw [hg_eq]\n  exact hg_seq_tendsto x\n#align strongly_measurable_of_measurable_space_le_on strongly_measurable_of_measurable_space_le_on\n\n",
 "strongly_measurable_of_is_empty":
 "theorem strongly_measurable_of_is_empty [IsEmpty Î±] {m : MeasurableSpace Î±} [TopologicalSpace Î²] (f : Î± â†’ Î²) :\n    strongly_measurable f :=\n  âŸ¨fun n => simple_func.of_is_empty, isEmptyElimâŸ©\n#align strongly_measurable_of_is_empty strongly_measurable_of_is_empty\n\n",
 "strongly_measurable_mk":
 "theorem strongly_measurable_mk (hf : ae_strongly_measurable f Î¼) : strongly_measurable (hf.mk f) :=\n  hf.some_spec.1\n#align strongly_measurable_mk strongly_measurable_mk\n\n",
 "strongly_measurable_in_set":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (x Â«expr âˆ‰ Â» s) -/\n/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (x Â«expr âˆ‰ Â» s) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚› Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (x Â«expr âˆ‰ Â» s) -/\ntheorem strongly_measurable_in_set {m : MeasurableSpace Î±} [TopologicalSpace Î²] [Zero Î²] {s : Set Î±} {f : Î± â†’ Î²}\n    (hs : MeasurableSet s) (hf : strongly_measurable f) (hf_zero : âˆ€ (x) (_ : x âˆ‰ s), f x = 0) :\n    âˆƒ fs : â„• â†’ Â«expr â†’â‚› Â» Î± Î²,\n      (âˆ€ x, Tendsto (fun n => fs n x) atTop ((nhds) (f x))) âˆ§ âˆ€ (x) (_ : x âˆ‰ s) (n), fs n x = 0 :=\n  by\n  let g_seq_s : â„• â†’ @simple_func Î± m Î² := fun n => (hf.approx n).restrict s\n  have hg_eq : âˆ€ x âˆˆ s, âˆ€ n, g_seq_s n x = hf.approx n x :=\n    by\n    intro x hx n\n    rw [simple_func.coe_restrict _ hs, Set.indicator_of_mem hx]\n  have hg_zero : âˆ€ (x) (_ : x âˆ‰ s), âˆ€ n, g_seq_s n x = 0 :=\n    by\n    intro x hx n\n    rw [simple_func.coe_restrict _ hs, Set.indicator_of_not_mem hx]\n  refine' âŸ¨g_seq_s, fun x => _, hg_zeroâŸ©\n  by_cases hx : x âˆˆ s\n  Â· simp_rw [hg_eq x hx]\n    exact hf.tendsto_approx x\n  Â· simp_rw [hg_zero x hx, hf_zero x hx]\n    exact tendsto_const_nhds\n#align strongly_measurable_in_set strongly_measurable_in_set\n\n",
 "strongly_measurable_iff_measurable_separable":
 "/-- A function is strongly measurable if and only if it is measurable and has separable\nrange. -/\ntheorem _root_.strongly_measurable_iff_measurable_separable {m : MeasurableSpace Î±} [TopologicalSpace Î²]\n    [pseudo_metrizable_space Î²] [MeasurableSpace Î²] [borel_space Î²] :\n    strongly_measurable f â†” Measurable f âˆ§ IsSeparable (range f) :=\n  by\n  refine' âŸ¨fun H => âŸ¨H.measurable, H.is_separable_rangeâŸ©, _âŸ©\n  rintro âŸ¨H, H'âŸ©\n  letI := pseudo_metrizable_space_pseudo_metric Î²\n  let g := cod_restrict f (closure (range f)) fun x => subset_closure (mem_range_self x)\n  have fg : f = (coe : closure (range f) â†’ Î²) âˆ˜ g := by\n    ext x\n    rfl\n  have T : MeasurableEmbedding (coe : closure (range f) â†’ Î²) :=\n    by\n    apply closed_embedding.measurable_embedding\n    exact closedEmbedding_subtype_val isClosed_closure\n  have g_meas : Measurable g := by\n    rw [fg] at H\n    exact T.measurable_comp_iff.1 H\n  have : second_countable_topology (closure (range f)) :=\n    by\n    suffices separable_space (closure (range f)) by exact UniformSpace.secondCountable_of_separable _\n    exact (is_separable.closure H').separable_space\n  have g_smeas : strongly_measurable g := measurable.strongly_measurable g_meas\n  rw [fg]\n  exact continuous_subtype_coe.comp_strongly_measurable g_smeas\n#align strongly_measurable_iff_measurable_separable strongly_measurable_iff_measurable_separable\n\n",
 "strongly_measurable_iff_measurable":
 "/-- In a space with second countable topology, strongly measurable and measurable are equivalent. -/\ntheorem _root_.strongly_measurable_iff_measurable [TopologicalSpace Î²] [metrizable_space Î²] [borel_space Î²]\n    [SecondCountableTopology Î²] : strongly_measurable f â†” Measurable f :=\n  âŸ¨fun h => h.measurable, fun h => measurable.strongly_measurable hâŸ©\n#align strongly_measurable_iff_measurable strongly_measurable_iff_measurable\n\n",
 "strongly_measurable_id":
 "theorem _root_.strongly_measurable_id [TopologicalSpace Î±] [pseudo_metrizable_space Î±] [opens_measurable_space Î±]\n    [SecondCountableTopology Î±] : strongly_measurable (id : Î± â†’ Î±) :=\n  measurable_id.strongly_measurable\n#align strongly_measurable_id strongly_measurable_id\n\n",
 "strongly_measurable_extend":
 "theorem _root_.measurable_embedding.strongly_measurable_extend {f : Î± â†’ Î²} {g : Î± â†’ Î³} {g' : Î³ â†’ Î²}\n    {mÎ± : MeasurableSpace Î±} {mÎ³ : MeasurableSpace Î³} [TopologicalSpace Î²] (hg : MeasurableEmbedding g)\n    (hf : strongly_measurable f) (hg' : strongly_measurable g') : strongly_measurable (Function.extend g f g') :=\n  by\n  refine' âŸ¨fun n => simple_func.extend (hf.approx n) g hg (hg'.approx n), _âŸ©\n  intro x\n  by_cases hx : âˆƒ y, g y = x\n  Â· rcases hx with âŸ¨y, rflâŸ©\n    simpa only [simple_func.extend_apply, hg.injective, injective.extend_apply] using hf.tendsto_approx y\n  Â· simpa only [hx, simple_func.extend_apply', not_false_iff, extend_apply'] using hg'.tendsto_approx x\n#align measurable_embedding.strongly_measurable_extend measurable_embedding.strongly_measurable_extend\n\n",
 "strongly_measurable_const_smul_iffâ‚€":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\ntheorem _root_.strongly_measurable_const_smul_iffâ‚€ {m : MeasurableSpace Î±} {c : Gâ‚€} (hc : c â‰  0) :\n    (strongly_measurable fun x => Â«expr â€¢ Â» c (f x)) â†” strongly_measurable f :=\n  by\n  refine' âŸ¨fun h => _, fun h => h.const_smul câŸ©\n  convert h.const_smul' câ»Â¹\n  simp [smul_smul, inv_mul_cancel hc]\n#align strongly_measurable_const_smul_iffâ‚€ strongly_measurable_const_smul_iffâ‚€\n\n",
 "strongly_measurable_const_smul_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\ntheorem _root_.strongly_measurable_const_smul_iff {m : MeasurableSpace Î±} (c : G) :\n    (strongly_measurable fun x => Â«expr â€¢ Â» c (f x)) â†” strongly_measurable f :=\n  âŸ¨fun h => by simpa only [inv_smul_smul] using h.const_smul' câ»Â¹, fun h => h.const_smul câŸ©\n#align strongly_measurable_const_smul_iff strongly_measurable_const_smul_iff\n\n",
 "strongly_measurable_const'":
 "/-- A version of `strongly_measurable_const` that assumes `f x = f y` for all `x, y`.\nThis version works for functions between empty types. -/\ntheorem strongly_measurable_const' {Î± Î²} {m : MeasurableSpace Î±} [TopologicalSpace Î²] {f : Î± â†’ Î²}\n    (hf : âˆ€ x y, f x = f y) : strongly_measurable f :=\n  by\n  cases isEmpty_or_nonempty Î±\n  Â· exact strongly_measurable_of_is_empty f\n  Â· convert strongly_measurable_const\n    exact funext fun x => hf x h.some\n#align strongly_measurable_const' strongly_measurable_const'\n\n",
 "strongly_measurable_const":
 "theorem strongly_measurable_const {Î± Î²} {m : MeasurableSpace Î±} [TopologicalSpace Î²] {b : Î²} :\n    strongly_measurable fun a : Î± => b :=\n  âŸ¨fun n => simple_func.const Î± b, fun a => tendsto_const_nhdsâŸ©\n#align strongly_measurable_const strongly_measurable_const\n\n",
 "strongly_measurable_bot_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‡‘ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `strongly_measurable_of -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¥Â» -/\ntheorem _root_.strongly_measurable_bot_iff [Nonempty Î²] [T2Space Î²] :\n    (strongly_measurable_of (Â«exprâŠ¥Â»)) f â†” âˆƒ c, f = fun _ => c :=\n  by\n  cases' isEmpty_or_nonempty Î± with hÎ± hÎ±\n  Â· simp only [subsingleton.strongly_measurable', eq_iff_true_of_subsingleton, exists_const]\n  refine' âŸ¨fun hf => _, fun hf_eq => _âŸ©\n  Â· refine' âŸ¨f hÎ±.some, _âŸ©\n    let fs := hf.approx\n    have h_fs_tendsto : âˆ€ x, tendsto (fun n => fs n x) at_top ((nhds) (f x)) := hf.tendsto_approx\n    have : âˆ€ n, âˆƒ c, âˆ€ x, fs n x = c := fun n => simple_func.simple_func_bot (fs n)\n    let cs n := (this n).some\n    have h_cs_eq : âˆ€ n, Â«exprâ‡‘ Â» (fs n) = fun x => cs n := fun n => funext (this n).some_spec\n    simp_rw [h_cs_eq] at h_fs_tendsto\n    have h_tendsto : tendsto cs at_top ((nhds) (f hÎ±.some)) := h_fs_tendsto hÎ±.some\n    ext1 x\n    exact tendsto_nhds_unique (h_fs_tendsto x) h_tendsto\n  Â· obtain âŸ¨c, rflâŸ© := hf_eq\n    exact strongly_measurable_const\n#align strongly_measurable_bot_iff strongly_measurable_bot_iff\n\n",
 "strongly_measurable'":
 "@[simp]\ntheorem subsingleton.strongly_measurable' {Î± Î²} [MeasurableSpace Î±] [TopologicalSpace Î²] [subsingleton Î±] (f : Î± â†’ Î²) :\n    strongly_measurable f :=\n  strongly_measurable_const' fun x y => by rw [subsingleton.elim x y]\n#align subsingleton.strongly_measurable' subsingleton.strongly_measurable'\n\n",
 "strongly_measurable":
 "protected theorem strongly_measurable [Zero Î²] [TopologicalSpace Î²] (hf : fin_strongly_measurable f Î¼) :\n    strongly_measurable f :=\n  âŸ¨hf.approx, hf.tendsto_approxâŸ©\n#align strongly_measurable strongly_measurable\n\n",
 "smul_measure":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\ntheorem smul_measure {R : Type _} [Monoid R] [DistribMulAction R (ennreal)] [IsScalarTower R (ennreal) (ennreal)]\n    (h : ae_strongly_measurable f Î¼) (c : R) : ae_strongly_measurable f (Â«expr â€¢ Â» c Î¼) :=\n  âŸ¨h.mk f, h.strongly_measurable_mk, ae_smul_measure h.ae_eq_mk câŸ©\n#align smul_measure smul_measure\n\n",
 "smul_const":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n@[to_additive]\nprotected theorem smul_const {ğ•œ} [TopologicalSpace ğ•œ] [SMul ğ•œ Î²] [ContinuousSMul ğ•œ Î²] {f : Î± â†’ ğ•œ}\n    (hf : ae_strongly_measurable f Î¼) (c : Î²) : ae_strongly_measurable (fun x => Â«expr â€¢ Â» (f x) c) Î¼ :=\n  continuous_smul.comp_ae_strongly_measurable (hf.prod_mk ae_strongly_measurable_const)\n#align smul_const smul_const\n\n",
 "smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n@[to_additive]\nprotected theorem smul {ğ•œ} [TopologicalSpace ğ•œ] [SMul ğ•œ Î²] [ContinuousSMul ğ•œ Î²] {f : Î± â†’ ğ•œ} {g : Î± â†’ Î²}\n    (hf : ae_strongly_measurable f Î¼) (hg : ae_strongly_measurable g Î¼) :\n    ae_strongly_measurable (fun x => Â«expr â€¢ Â» (f x) (g x)) Î¼ :=\n  continuous_smul.comp_ae_strongly_measurable (hf.prod_mk hg)\n#align smul smul\n\n",
 "separable_space_range_union_singleton":
 "theorem separable_space_range_union_singleton {m : MeasurableSpace Î±} [TopologicalSpace Î²] [pseudo_metrizable_space Î²]\n    (hf : strongly_measurable f) {b : Î²} : SeparableSpace (range f âˆª {b} : Set Î²) :=\n  letI := pseudo_metrizable_space_pseudo_metric Î²\n  (hf.is_separable_range.union (finite_singleton _).is_separable).separable_space\n#align separable_space_range_union_singleton separable_space_range_union_singleton\n\n",
 "restrict":
 "protected theorem restrict (hfm : ae_strongly_measurable f Î¼) {s} : ae_strongly_measurable f (Î¼.restrict s) :=\n  hfm.mono_measure Measure.restrict_le_self\n#align restrict restrict\n\n",
 "real_to_nnreal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\nprotected theorem real_to_nnreal {f : Î± â†’ exprâ„} (hf : ae_strongly_measurable f Î¼) :\n    ae_strongly_measurable (fun x => (f x).to_nnreal) Î¼ :=\n  continuous_real_toNNReal.comp_ae_strongly_measurable hf\n#align real_to_nnreal real_to_nnreal\n\n",
 "prod_mk":
 "protected theorem prod_mk {f : Î± â†’ Î²} {g : Î± â†’ Î³} (hf : ae_strongly_measurable f Î¼) (hg : ae_strongly_measurable g Î¼) :\n    ae_strongly_measurable (fun x => (f x, g x)) Î¼ :=\n  âŸ¨fun x => (hf.mk f x, hg.mk g x), hf.strongly_measurable_mk.prod_mk hg.strongly_measurable_mk,\n    hf.ae_eq_mk.prod_mk hg.ae_eq_mkâŸ©\n#align prod_mk prod_mk\n\n",
 "piecewise":
 "protected theorem piecewise {m : MeasurableSpace Î±} [TopologicalSpace Î²] {s : Set Î±} {_ : DecidablePred (Â· âˆˆ s)}\n    (hs : MeasurableSet s) (hf : strongly_measurable f) (hg : strongly_measurable g) :\n    strongly_measurable (Set.piecewise s f g) :=\n  by\n  refine' âŸ¨fun n => simple_func.piecewise s hs (hf.approx n) (hg.approx n), fun x => _âŸ©\n  by_cases hx : x âˆˆ s\n  Â· simpa [hx] using hf.tendsto_approx x\n  Â· simpa [hx] using hg.tendsto_approx x\n#align piecewise piecewise\n\n",
 "of_uncurry_right":
 "theorem of_uncurry_right [TopologicalSpace Î²] {mÎ± : MeasurableSpace Î±} {mÎ³ : MeasurableSpace Î³} {f : Î± â†’ Î³ â†’ Î²}\n    (hf : strongly_measurable (uncurry f)) {y : Î³} : strongly_measurable fun x => f x y :=\n  hf.comp_measurable measurable_prod_mk_right\n#align of_uncurry_right of_uncurry_right\n\n",
 "of_uncurry_left":
 "theorem of_uncurry_left [TopologicalSpace Î²] {mÎ± : MeasurableSpace Î±} {mÎ³ : MeasurableSpace Î³} {f : Î± â†’ Î³ â†’ Î²}\n    (hf : strongly_measurable (uncurry f)) {x : Î±} : strongly_measurable (f x) :=\n  hf.comp_measurable measurable_prod_mk_left\n#align of_uncurry_left of_uncurry_left\n\n",
 "null_measurable_set_lt":
 "theorem null_measurable_set_lt [linear_order Î²] [OrderClosedTopology Î²] [pseudo_metrizable_space Î²] {f g : Î± â†’ Î²}\n    (hf : ae_strongly_measurable f Î¼) (hg : ae_strongly_measurable g Î¼) : NullMeasurableSet { a | f a < g a } Î¼ :=\n  by\n  apply (hf.strongly_measurable_mk.measurable_set_lt hg.strongly_measurable_mk).null_measurable_set.congr\n  filter_upwards [hf.ae_eq_mk, hg.ae_eq_mk]with x hfx hgx\n  change (hf.mk f x < hg.mk g x) = (f x < g x)\n  simp only [hfx, hgx]\n#align null_measurable_set_lt null_measurable_set_lt\n\n",
 "null_measurable_set_le":
 "theorem null_measurable_set_le [preorder Î²] [OrderClosedTopology Î²] [pseudo_metrizable_space Î²] {f g : Î± â†’ Î²}\n    (hf : ae_strongly_measurable f Î¼) (hg : ae_strongly_measurable g Î¼) : NullMeasurableSet { a | f a â‰¤ g a } Î¼ :=\n  by\n  apply (hf.strongly_measurable_mk.measurable_set_le hg.strongly_measurable_mk).null_measurable_set.congr\n  filter_upwards [hf.ae_eq_mk, hg.ae_eq_mk]with x hfx hgx\n  change (hf.mk f x â‰¤ hg.mk g x) = (f x â‰¤ g x)\n  simp only [hfx, hgx]\n#align null_measurable_set_le null_measurable_set_le\n\n",
 "nullMeasurableSet_eq_fun":
 "#print nullMeasurableSet_eq_fun /-\ntheorem nullMeasurableSet_eq_fun {E} [TopologicalSpace E] [metrizable_space E] {f g : Î± â†’ E}\n    (hf : ae_strongly_measurable f Î¼) (hg : ae_strongly_measurable g Î¼) : NullMeasurableSet { x | f x = g x } Î¼ :=\n  by\n  apply (hf.strongly_measurable_mk.measurable_set_eq_fun hg.strongly_measurable_mk).null_measurable_set.congr\n  filter_upwards [hf.ae_eq_mk, hg.ae_eq_mk]with x hfx hgx\n  change (hf.mk f x = hg.mk g x) = (f x = g x)\n  simp only [hfx, hgx]\n#align null_measurable_set_eq_fun nullMeasurableSet_eq_fun\n-/\n\n",
 "norm_approx_bounded_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `strongly_measurable_of -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\ntheorem norm_approx_bounded_le {Î²} {f : Î± â†’ Î²} [SeminormedAddCommGroup Î²] [NormedSpace (exprâ„) Î²]\n    {m : MeasurableSpace Î±} {c : exprâ„} (hf : (strongly_measurable_of m) f) (hc : 0 â‰¤ c) (n : â„•) (x : Î±) :\n    Â«exprâ€– â€–Â» (hf.approx_bounded c n x) â‰¤ c :=\n  by\n  simp only [strongly_measurable.approx_bounded, simple_func.coe_map, Function.comp_apply]\n  refine' (norm_smul_le _ _).trans _\n  by_cases h0 : Â«exprâ€– â€–Â» (hf.approx n x) = 0\n  Â· simp only [h0, div_zero, min_eq_right, zero_le_one, norm_zero, MulZeroClass.mul_zero]\n    exact hc\n  cases le_total (Â«exprâ€– â€–Â» (hf.approx n x)) c\n  Â· rw [min_eq_left _]\n    Â· simpa only [norm_one, one_mul] using h\n    Â· rwa [one_le_div (lt_of_le_of_ne (norm_nonneg _) (ne.symm h0))]\n  Â· rw [min_eq_right _]\n    Â·\n      rw [norm_div, norm_norm, mul_comm, mul_div, div_eq_mul_inv, mul_comm, â† mul_assoc, inv_mul_cancel h0, one_mul,\n        Real.norm_of_nonneg hc]\n    Â· rwa [div_le_one (lt_of_le_of_ne (norm_nonneg _) (ne.symm h0))]\n#align norm_approx_bounded_le norm_approx_bounded_le\n\n",
 "norm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\nprotected theorem norm {Î² : Type _} [SeminormedAddCommGroup Î²] {f : Î± â†’ Î²} (hf : ae_strongly_measurable f Î¼) :\n    ae_strongly_measurable (fun x => Â«exprâ€– â€–Â» (f x)) Î¼ :=\n  continuous_norm.comp_ae_strongly_measurable hf\n#align norm norm\n\n",
 "nnnorm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–â‚ŠÂ» -/\nprotected theorem nnnorm {Î² : Type _} [SeminormedAddCommGroup Î²] {f : Î± â†’ Î²} (hf : ae_strongly_measurable f Î¼) :\n    ae_strongly_measurable (fun x => Â«exprâ€– â€–â‚ŠÂ» (f x)) Î¼ :=\n  continuous_nnnorm.comp_ae_strongly_measurable hf\n#align nnnorm nnnorm\n\n",
 "neg":
 "protected theorem neg [AddGroup Î²] [TopologicalAddGroup Î²] (hf : ae_fin_strongly_measurable f Î¼) :\n    ae_fin_strongly_measurable (-f) Î¼ :=\n  âŸ¨-hf.mk f, hf.fin_strongly_measurable_mk.neg, hf.ae_eq_mk.negâŸ©\n#align neg neg\n\n",
 "mul_const":
 "@[to_additive]\nprotected theorem mul_const [Mul Î²] [ContinuousMul Î²] (hf : ae_strongly_measurable f Î¼) (c : Î²) :\n    ae_strongly_measurable (fun x => f x * c) Î¼ :=\n  hf.mul ae_strongly_measurable_const\n#align mul_const mul_const\n\n",
 "mul":
 "protected theorem mul [MonoidWithZero Î²] [ContinuousMul Î²] (hf : ae_fin_strongly_measurable f Î¼)\n    (hg : ae_fin_strongly_measurable g Î¼) : ae_fin_strongly_measurable (f * g) Î¼ :=\n  âŸ¨hf.mk f * hg.mk g, hf.fin_strongly_measurable_mk.mul hg.fin_strongly_measurable_mk, hf.ae_eq_mk.mul hg.ae_eq_mkâŸ©\n#align mul mul\n\n",
 "mono_set":
 "theorem mono_set {s t} (h : s âŠ† t) (ht : ae_strongly_measurable f (Î¼.restrict t)) :\n    ae_strongly_measurable f (Î¼.restrict s) :=\n  ht.mono_measure (restrict_mono h le_rfl)\n#align mono_set mono_set\n\n",
 "mono_measure":
 "theorem mono_measure {Î½ : Measure Î±} (hf : ae_strongly_measurable f Î¼) (h : Î½ â‰¤ Î¼) : ae_strongly_measurable f Î½ :=\n  âŸ¨hf.mk f, hf.strongly_measurable_mk, Eventually.filter_mono (ae_mono h) hf.ae_eq_mkâŸ©\n#align mono_measure mono_measure\n\n",
 "mono'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure.absolutely_continuous -/\nprotected theorem mono' {Î½ : Measure Î±} (h : ae_strongly_measurable f Î¼) (h' : measure.absolutely_continuous Î½ Î¼) :\n    ae_strongly_measurable f Î½ :=\n  âŸ¨h.mk f, h.strongly_measurable_mk, h' h.ae_eq_mkâŸ©\n#align mono' mono'\n\n",
 "mono":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `strongly_measurable_of -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `strongly_measurable_of -/\nprotected theorem mono {m m' : MeasurableSpace Î±} [TopologicalSpace Î²] (hf : (strongly_measurable_of m') f)\n    (h_mono : m' â‰¤ m) : (strongly_measurable_of m) f :=\n  by\n  let f_approx : â„• â†’ @simple_func Î± m Î² := fun n =>\n    { to_fun := hf.approx n\n      measurable_set_fiber' := fun x => h_mono _ (simple_func.measurable_set_fiber' _ x)\n      finite_range' := simple_func.finite_range (hf.approx n) }\n  exact âŸ¨f_approx, hf.tendsto_approxâŸ©\n#align mono mono\n\n",
 "measurable_uncurry_of_continuous_of_measurable":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ†¥ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ†¥ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ†¥ Â» -/\ntheorem measurable_uncurry_of_continuous_of_measurable {Î± Î² Î¹ : Type _} [TopologicalSpace Î¹] [metrizable_space Î¹]\n    [MeasurableSpace Î¹] [SecondCountableTopology Î¹] [opens_measurable_space Î¹] {mÎ² : MeasurableSpace Î²}\n    [TopologicalSpace Î²] [pseudo_metrizable_space Î²] [borel_space Î²] {m : MeasurableSpace Î±} {u : Î¹ â†’ Î± â†’ Î²}\n    (hu_cont : âˆ€ x, Continuous fun i => u i x) (h : âˆ€ i, Measurable (u i)) : Measurable (function.uncurry u) :=\n  by\n  obtain âŸ¨t_sf, ht_sfâŸ© : âˆƒ t : â„• â†’ simple_func Î¹ Î¹, âˆ€ j x, tendsto (fun n => u (t n j) x) at_top (nhds <| u j x) :=\n    by\n    have h_str_meas : strongly_measurable (id : Î¹ â†’ Î¹) := strongly_measurable_id\n    refine' âŸ¨h_str_meas.approx, fun j x => _âŸ©\n    exact ((hu_cont x).tendsto j).comp (h_str_meas.tendsto_approx j)\n  let U (n : â„•) (p : Î¹ Ã— Î±) := u (t_sf n p.fst) p.snd\n  have h_tendsto : tendsto U at_top ((nhds) fun p => u p.fst p.snd) :=\n    by\n    rw [tendsto_pi_nhds]\n    exact fun p => ht_sf p.fst p.snd\n  refine' measurable_of_tendsto_metrizable (fun n => _) h_tendsto\n  have h_meas : Measurable fun p : (t_sf n).range Ã— Î± => u (â†‘p.fst) p.snd :=\n    by\n    have :\n      (fun p : Â«exprâ†¥ Â» (t_sf n).range Ã— Î± => u (â†‘p.fst) p.snd) =\n        (fun p : Î± Ã— (t_sf n).range => u (â†‘p.snd) p.fst) âˆ˜ Prod.swap :=\n      rfl\n    rw [this, @measurable_swap_iff Î± (Â«exprâ†¥ Â» (t_sf n).range) Î² m]\n    exact measurable_from_prod_countable fun j => h j\n  have :\n    (fun p : Î¹ Ã— Î± => u (t_sf n p.fst) p.snd) =\n      (fun p : Â«exprâ†¥ Â» (t_sf n).range Ã— Î± => u p.fst p.snd) âˆ˜ fun p : Î¹ Ã— Î± =>\n        (âŸ¨t_sf n p.fst, simple_func.mem_range_self _ _âŸ©, p.snd) :=\n    rfl\n  simp_rw [U, this]\n  refine' h_meas.comp (Measurable.prod_mk _ measurable_snd)\n  exact ((t_sf n).measurable.comp measurable_fst).subtype_mk\n#align measurable_uncurry_of_continuous_of_measurable measurable_uncurry_of_continuous_of_measurable\n\n",
 "measurable_set_lt":
 "theorem measurable_set_lt {m : MeasurableSpace Î±} [TopologicalSpace Î²] [linear_order Î²] [OrderClosedTopology Î²]\n    [pseudo_metrizable_space Î²] {f g : Î± â†’ Î²} (hf : strongly_measurable f) (hg : strongly_measurable g) :\n    MeasurableSet { a | f a < g a } := by\n  borelize (Î² Ã— Î²)\n  exact (hf.prod_mk hg).measurable is_open_lt_prod.measurable_set\n#align measurable_set_lt measurable_set_lt\n\n",
 "measurable_set_le":
 "theorem measurable_set_le {m : MeasurableSpace Î±} [TopologicalSpace Î²] [preorder Î²] [OrderClosedTopology Î²]\n    [pseudo_metrizable_space Î²] {f g : Î± â†’ Î²} (hf : strongly_measurable f) (hg : strongly_measurable g) :\n    MeasurableSet { a | f a â‰¤ g a } := by\n  borelize (Î² Ã— Î²)\n  exact (hf.prod_mk hg).measurable is_closed_le_prod.measurable_set\n#align measurable_set_le measurable_set_le\n\n",
 "measurable_mk":
 "theorem measurable_mk [pseudo_metrizable_space Î²] [MeasurableSpace Î²] [borel_space Î²]\n    (hf : ae_strongly_measurable f Î¼) : Measurable (hf.mk f) :=\n  hf.strongly_measurable_mk.measurable\n#align measurable_mk measurable_mk\n\n",
 "measurableSet_mulSupport":
 "#print measurableSet_mulSupport /-\n@[to_additive]\ntheorem measurableSet_mulSupport {m : MeasurableSpace Î±} [One Î²] [TopologicalSpace Î²] [metrizable_space Î²]\n    (hf : strongly_measurable f) : MeasurableSet (mulSupport f) :=\n  by\n  borelize Î²\n  exact measurableSet_mulSupport hf.measurable\n#align measurable_set_mul_support measurableSet_mulSupport\n#align measurable_set_support measurableSet_support\n-/\n\n",
 "measurableSet_eq_fun":
 "#print measurableSet_eq_fun /-\ntheorem measurableSet_eq_fun {m : MeasurableSpace Î±} {E} [TopologicalSpace E] [metrizable_space E] {f g : Î± â†’ E}\n    (hf : strongly_measurable f) (hg : strongly_measurable g) : MeasurableSet { x | f x = g x } :=\n  by\n  borelize (E Ã— E)\n  exact (hf.prod_mk hg).measurable is_closed_diagonal.measurable_set\n#align measurable_set_eq_fun measurableSet_eq_fun\n-/\n\n",
 "ite":
 "#print ite /-\n/-- this is slightly different from `strongly_measurable.piecewise`. It can be used to show\n`strongly_measurable (ite (x=0) 0 1)` by\n`exact strongly_measurable.ite (measurable_set_singleton 0) strongly_measurable_const\nstrongly_measurable_const`, but replacing `strongly_measurable.ite` by\n`strongly_measurable.piecewise` in that example proof does not work. -/\nprotected theorem ite {m : MeasurableSpace Î±} [TopologicalSpace Î²] {p : Î± â†’ Prop} {_ : DecidablePred p}\n    (hp : MeasurableSet { a : Î± | p a }) (hf : strongly_measurable f) (hg : strongly_measurable g) :\n    strongly_measurable fun x => ite (p x) (f x) (g x) :=\n  strongly_measurable.piecewise hp hf hg\n#align ite ite\n-/\n\n",
 "is_separable_range":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/-- The range of a strongly measurable function is separable. -/\ntheorem is_separable_range {m : MeasurableSpace Î±} [TopologicalSpace Î²] (hf : strongly_measurable f) :\n    TopologicalSpace.IsSeparable (range f) :=\n  by\n  have :\n    is_separable\n      (closure\n        (Â«exprâ‹ƒ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â»\"\n          (range (hf.approx n)))) :=\n    (is_separable_Union fun n => (simple_func.finite_range (hf.approx n)).is_separable).closure\n  apply this.mono\n  rintro _ âŸ¨x, rflâŸ©\n  apply mem_closure_of_tendsto (hf.tendsto_approx x)\n  apply eventually_of_forall fun n => _\n  apply mem_Union_of_mem n\n  exact mem_range_self _\n#align is_separable_range is_separable_range\n\n",
 "is_separable_ae_range":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€áµ âˆ‚ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€áµ âˆ‚ , Â» -/\ntheorem is_separable_ae_range (hf : ae_strongly_measurable f Î¼) :\n    âˆƒ t : Set Î²,\n      IsSeparable t âˆ§\n        Â«exprâˆ€áµ âˆ‚ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€áµ âˆ‚ , Â»\" Î¼\n          (f x âˆˆ t) :=\n  by\n  refine' âŸ¨range (hf.mk f), hf.strongly_measurable_mk.is_separable_range, _âŸ©\n  filter_upwards [hf.ae_eq_mk]with x hx\n  simp [hx]\n#align is_separable_ae_range is_separable_ae_range\n\n",
 "inv":
 "@[to_additive]\nprotected theorem inv [Group Î²] [TopologicalGroup Î²] (hf : ae_strongly_measurable f Î¼) : ae_strongly_measurable fâ»Â¹ Î¼ :=\n  âŸ¨(hf.mk f)â»Â¹, hf.strongly_measurable_mk.inv, hf.ae_eq_mk.invâŸ©\n#align inv inv\n\n",
 "inf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŠ“ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŠ“ Â» -/\nprotected theorem inf [SemilatticeInf Î²] [ContinuousInf Î²] (hf : ae_fin_strongly_measurable f Î¼)\n    (hg : ae_fin_strongly_measurable g Î¼) : ae_fin_strongly_measurable (Â«expr âŠ“ Â» f g) Î¼ :=\n  âŸ¨Â«expr âŠ“ Â» (hf.mk f) (hg.mk g), hf.fin_strongly_measurable_mk.inf hg.fin_strongly_measurable_mk,\n    hf.ae_eq_mk.inf hg.ae_eq_mkâŸ©\n#align inf inf\n\n",
 "indicator":
 "protected theorem indicator [Zero Î²] (hfm : ae_strongly_measurable f Î¼) {s : Set Î±} (hs : MeasurableSet s) :\n    ae_strongly_measurable (s.indicator f) Î¼ :=\n  (ae_strongly_measurable_indicator_iff hs).mpr hfm.restrict\n#align indicator indicator\n\n",
 "fin_support_approx":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\nprotected theorem fin_support_approx : âˆ€ n, Î¼ (support (hf.approx n)) < ennreal.top :=\n  hf.some_spec.1\n#align fin_support_approx fin_support_approx\n\n",
 "fin_strongly_measurable_zero":
 "theorem fin_strongly_measurable_zero {Î± Î²} {m : MeasurableSpace Î±} {Î¼ : Measure Î±} [Zero Î²] [TopologicalSpace Î²] :\n    fin_strongly_measurable (0 : Î± â†’ Î²) Î¼ :=\n  âŸ¨0, by\n    simp only [Pi.zero_apply, simple_func.coe_zero, support_zero', measure_empty, WithTop.zero_lt_top, forall_const],\n    fun n => tendsto_const_nhdsâŸ©\n#align fin_strongly_measurable_zero fin_strongly_measurable_zero\n\n",
 "fin_strongly_measurable_of_set_sigma_finite":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (x Â«expr âˆ‰ Â» t) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á¶œÂ» -/\ntheorem fin_strongly_measurable_of_set_sigma_finite [TopologicalSpace Î²] [Zero Î²] {m : MeasurableSpace Î±}\n    {Î¼ : Measure Î±} (hf_meas : strongly_measurable f) {t : Set Î±} (ht : MeasurableSet t)\n    (hft_zero : âˆ€ x âˆˆ Â«expr á¶œÂ» t, f x = 0) (htÎ¼ : SigmaFinite (Î¼.restrict t)) : fin_strongly_measurable f Î¼ :=\n  by\n  haveI : sigma_finite (Î¼.restrict t) := htÎ¼\n  let S := spanning_sets (Î¼.restrict t)\n  have hS_meas : âˆ€ n, MeasurableSet (S n) := measurable_spanning_sets (Î¼.restrict t)\n  let f_approx := hf_meas.approx\n  let fs n := simple_func.restrict (f_approx n) (S n âˆ© t)\n  have h_fs_t_compl : âˆ€ n, âˆ€ (x) (_ : x âˆ‰ t), fs n x = 0 :=\n    by\n    intro n x hxt\n    rw [simple_func.restrict_apply _ ((hS_meas n).inter ht)]\n    refine' Set.indicator_of_not_mem _ _\n    simp [hxt]\n  refine' âŸ¨fs, _, fun x => _âŸ©\n  Â· simp_rw [simple_func.support_eq]\n    refine' fun n => (measure_bUnion_finset_le _ _).trans_lt _\n    refine' ennreal.sum_lt_top_iff.mpr fun y hy => _\n    rw [simple_func.restrict_preimage_singleton _ ((hS_meas n).inter ht)]\n    swap\n    Â· rw [Finset.mem_filter] at hy\n      exact hy.2\n    refine' (measure_mono (Set.inter_subset_left _ _)).trans_lt _\n    have h_lt_top := measure_spanning_sets_lt_top (Î¼.restrict t) n\n    rwa [measure.restrict_apply' ht] at h_lt_top\n  Â· by_cases hxt : x âˆˆ t\n    swap\n    Â· rw [funext fun n => h_fs_t_compl n x hxt, hft_zero x hxt]\n      exact tendsto_const_nhds\n    have h : tendsto (fun n => (f_approx n) x) at_top ((nhds) (f x)) := hf_meas.tendsto_approx x\n    obtain âŸ¨nâ‚, hnâ‚âŸ© : âˆƒ n, âˆ€ m, n â‰¤ m â†’ fs m x = f_approx m x :=\n      by\n      obtain âŸ¨n, hnâŸ© : âˆƒ n, âˆ€ m, n â‰¤ m â†’ x âˆˆ S m âˆ© t :=\n        by\n        rsuffices âŸ¨n, hnâŸ© : âˆƒ n, âˆ€ m, n â‰¤ m â†’ x âˆˆ S m\n        Â· exact âŸ¨n, fun m hnm => Set.mem_inter (hn m hnm) hxtâŸ©\n        rsuffices âŸ¨n, hnâŸ© : âˆƒ n, x âˆˆ S n\n        Â· exact âŸ¨n, fun m hnm => monotone_spanning_sets (Î¼.restrict t) hnm hnâŸ©\n        rw [â† Set.mem_unionáµ¢, Union_spanning_sets (Î¼.restrict t)]\n        trivial\n      refine' âŸ¨n, fun m hnm => _âŸ©\n      simp_rw [fs, simple_func.restrict_apply _ ((hS_meas m).inter ht), Set.indicator_of_mem (hn m hnm)]\n    rw [tendsto_at_top'] at hâŠ¢\n    intro s hs\n    obtain âŸ¨nâ‚‚, hnâ‚‚âŸ© := h s hs\n    refine' âŸ¨max nâ‚ nâ‚‚, fun m hm => _âŸ©\n    rw [hnâ‚ m ((le_max_left _ _).trans hm.le)]\n    exact hnâ‚‚ m ((le_max_right _ _).trans hm.le)\n#align fin_strongly_measurable_of_set_sigma_finite fin_strongly_measurable_of_set_sigma_finite\n\n",
 "fin_strongly_measurable_mk":
 "theorem fin_strongly_measurable_mk (hf : ae_fin_strongly_measurable f Î¼) : fin_strongly_measurable (hf.mk f) Î¼ :=\n  hf.some_spec.1\n#align fin_strongly_measurable_mk fin_strongly_measurable_mk\n\n",
 "fin_strongly_measurable_iff_strongly_measurable_and_exists_set_sigma_finite":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á¶œÂ» -/\ntheorem fin_strongly_measurable_iff_strongly_measurable_and_exists_set_sigma_finite {Î± Î²} {f : Î± â†’ Î²}\n    [TopologicalSpace Î²] [T2Space Î²] [Zero Î²] {m : MeasurableSpace Î±} {Î¼ : Measure Î±} :\n    fin_strongly_measurable f Î¼ â†”\n      strongly_measurable f âˆ§ âˆƒ t, MeasurableSet t âˆ§ (âˆ€ x âˆˆ Â«expr á¶œÂ» t, f x = 0) âˆ§ SigmaFinite (Î¼.restrict t) :=\n  âŸ¨fun hf => âŸ¨hf.strongly_measurable, hf.exists_set_sigma_finiteâŸ©, fun hf =>\n    hf.1.fin_strongly_measurable_of_set_sigma_finite hf.2.some_spec.1 hf.2.some_spec.2.1 hf.2.some_spec.2.2âŸ©\n#align fin_strongly_measurable_iff_strongly_measurable_and_exists_set_sigma_finite fin_strongly_measurable_iff_strongly_measurable_and_exists_set_sigma_finite\n\n",
 "fin_strongly_measurable_iff_measurable":
 "/-- In a space with second countable topology and a sigma-finite measure, `fin_strongly_measurable`\n  and `measurable` are equivalent. -/\ntheorem fin_strongly_measurable_iff_measurable {m0 : MeasurableSpace Î±} (Î¼ : Measure Î±) [SigmaFinite Î¼] :\n    fin_strongly_measurable f Î¼ â†” Measurable f :=\n  âŸ¨fun h => h.measurable, fun h => (measurable.strongly_measurable h).fin_strongly_measurable Î¼âŸ©\n#align fin_strongly_measurable_iff_measurable fin_strongly_measurable_iff_measurable\n\n",
 "fin_strongly_measurable":
 "/-- If the measure is sigma-finite, all strongly measurable functions are\n  `fin_strongly_measurable`. -/\nprotected theorem fin_strongly_measurable [TopologicalSpace Î²] [Zero Î²] {m0 : MeasurableSpace Î±}\n    (hf : strongly_measurable f) (Î¼ : Measure Î±) [SigmaFinite Î¼] : fin_strongly_measurable f Î¼ :=\n  hf.fin_strongly_measurable_of_set_sigma_finite MeasurableSet.univ (by simp) (by rwa [measure.restrict_univ])\n#align fin_strongly_measurable fin_strongly_measurable\n\n",
 "exists_strongly_measurable_limit_of_tendsto_ae":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€áµ âˆ‚ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€áµ âˆ‚ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€áµ âˆ‚ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€áµ âˆ‚ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€áµ âˆ‚ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€áµ âˆ‚ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- If a sequence of almost everywhere strongly measurable functions converges almost everywhere,\none can select a strongly measurable function as the almost everywhere limit. -/\ntheorem _root_.exists_strongly_measurable_limit_of_tendsto_ae [pseudo_metrizable_space Î²] {f : â„• â†’ Î± â†’ Î²}\n    (hf : âˆ€ n, ae_strongly_measurable (f n) Î¼)\n    (h_ae_tendsto :\n      Â«exprâˆ€áµ âˆ‚ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€áµ âˆ‚ , Â»\" Î¼\n        (âˆƒ l : Î², Tendsto (fun n => f n x) atTop ((nhds) l))) :\n    âˆƒ (f_lim : Î± â†’ Î²)(hf_lim_meas : strongly_measurable f_lim),\n      Â«exprâˆ€áµ âˆ‚ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€áµ âˆ‚ , Â»\" Î¼\n        (Tendsto (fun n => f n x) atTop ((nhds) (f_lim x))) :=\n  by\n  borelize Î²\n  obtain âŸ¨g, g_meas, hgâŸ© :\n    âˆƒ (g : Î± â†’ Î²)(g_meas : Measurable g),\n      Â«exprâˆ€áµ âˆ‚ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€áµ âˆ‚ , Â»\" Î¼\n        (tendsto (fun n => f n x) at_top ((nhds) (g x))) :=\n    measurable_limit_of_tendsto_metrizable_ae (fun n => (hf n).ae_measurable) h_ae_tendsto\n  have Hg : ae_strongly_measurable g Î¼ := ae_strongly_measurable_of_tendsto_ae _ hf hg\n  refine' âŸ¨Hg.mk g, Hg.strongly_measurable_mk, _âŸ©\n  filter_upwards [hg, Hg.ae_eq_mk]with x hx h'x\n  rwa [h'x] at hx\n#align exists_strongly_measurable_limit_of_tendsto_ae exists_strongly_measurable_limit_of_tendsto_ae\n\n",
 "exists_strongly_measurable_extend":
 "theorem _root_.measurable_embedding.exists_strongly_measurable_extend {f : Î± â†’ Î²} {g : Î± â†’ Î³} {mÎ± : MeasurableSpace Î±}\n    {mÎ³ : MeasurableSpace Î³} [TopologicalSpace Î²] (hg : MeasurableEmbedding g) (hf : strongly_measurable f)\n    (hne : Î³ â†’ Nonempty Î²) : âˆƒ f' : Î³ â†’ Î², strongly_measurable f' âˆ§ f' âˆ˜ g = f :=\n  âŸ¨Function.extend g f fun x => Classical.choice (hne x),\n    hg.strongly_measurable_extend hf (strongly_measurable_const' fun _ _ => rfl),\n    funext fun x => hg.injective.extend_apply _ _ _âŸ©\n#align measurable_embedding.exists_strongly_measurable_extend measurable_embedding.exists_strongly_measurable_extend\n\n",
 "exists_spanning_measurable_set_norm_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŒˆ âŒ‰â‚ŠÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `strongly_measurable_of -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/-- If a function `f` is strongly measurable w.r.t. a sub-Ïƒ-algebra `m` and the measure is Ïƒ-finite\non `m`, then there exists spanning measurable sets with finite measure on which `f` has bounded\nnorm. In particular, `f` is integrable on each of those sets. -/\ntheorem exists_spanning_measurable_set_norm_le [SeminormedAddCommGroup Î²] {m m0 : MeasurableSpace Î±} (hm : m â‰¤ m0)\n    (hf : (strongly_measurable_of m) f) (Î¼ : Measure Î±) [SigmaFinite (Î¼.trim hm)] :\n    âˆƒ s : â„• â†’ Set Î±,\n      (âˆ€ n, (measurable_set_of m) (s n) âˆ§ Î¼ (s n) < ennreal.top âˆ§ âˆ€ x âˆˆ s n, Â«exprâ€– â€–Â» (f x) â‰¤ n) âˆ§\n        Â«exprâ‹ƒ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â»\" (s i) =\n          Set.univ :=\n  by\n  let sigma_finite_sets := spanning_sets (Î¼.trim hm)\n  let norm_sets := fun n : â„• => { x | Â«exprâ€– â€–Â» (f x) â‰¤ n }\n  have norm_sets_spanning :\n    Â«exprâ‹ƒ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â»\" (norm_sets n) =\n      Set.univ :=\n    by\n    ext1 x\n    simp only [Set.mem_unionáµ¢, Set.mem_setOf_eq, Set.mem_univ, iff_true_iff]\n    exact âŸ¨Â«exprâŒˆ âŒ‰â‚ŠÂ» (Â«exprâ€– â€–Â» (f x)), Nat.le_ceil (Â«exprâ€– â€–Â» (f x))âŸ©\n  let sets n := sigma_finite_sets n âˆ© norm_sets n\n  have h_meas : âˆ€ n, (measurable_set_of m) (sets n) :=\n    by\n    refine' fun n => MeasurableSet.inter _ _\n    Â· exact measurable_spanning_sets (Î¼.trim hm) n\n    Â· exact hf.norm.measurable_set_le strongly_measurable_const\n  have h_finite : âˆ€ n, Î¼ (sets n) < ennreal.top :=\n    by\n    refine' fun n => (measure_mono (Set.inter_subset_left _ _)).trans_lt _\n    exact (le_trim hm).trans_lt (measure_spanning_sets_lt_top (Î¼.trim hm) n)\n  refine' âŸ¨sets, fun n => âŸ¨h_meas n, h_finite n, _âŸ©, _âŸ©\n  Â· exact fun x hx => hx.2\n  Â· have :\n      Â«exprâ‹ƒ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â»\"\n          (sigma_finite_sets i âˆ© norm_sets i) =\n        Â«exprâ‹ƒ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â»\"\n            (sigma_finite_sets i) âˆ©\n          Â«exprâ‹ƒ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â»\"\n            (norm_sets i) :=\n      by\n      refine' Set.unionáµ¢_inter_of_monotone (monotone_spanning_sets (Î¼.trim hm)) fun i j hij x => _\n      simp only [norm_sets, Set.mem_setOf_eq]\n      refine' fun hif => hif.trans _\n      exact_mod_cast hij\n    rw [this, norm_sets_spanning, Union_spanning_sets (Î¼.trim hm), Set.inter_univ]\n#align exists_spanning_measurable_set_norm_le exists_spanning_measurable_set_norm_le\n\n",
 "exists_set_sigma_finite":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr =áµ[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á¶œÂ» -/\ntheorem exists_set_sigma_finite (hf : ae_fin_strongly_measurable f Î¼) :\n    âˆƒ t, MeasurableSet t âˆ§ Â«expr =áµ[ ] Â» f (Î¼.restrict (Â«expr á¶œÂ» t)) 0 âˆ§ SigmaFinite (Î¼.restrict t) :=\n  by\n  rcases hf with âŸ¨g, hg, hfgâŸ©\n  obtain âŸ¨t, ht, hgt_zero, htÎ¼âŸ© := hg.exists_set_sigma_finite\n  refine' âŸ¨t, ht, _, htÎ¼âŸ©\n  refine' eventually_eq.trans (ae_restrict_of_ae hfg) _\n  rw [eventually_eq, ae_restrict_iff' ht.compl]\n  exact eventually_of_forall hgt_zero\n#align exists_set_sigma_finite exists_set_sigma_finite\n\n",
 "ennnorm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–â‚ŠÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\nprotected theorem ennnorm {Î² : Type _} [SeminormedAddCommGroup Î²] {f : Î± â†’ Î²} (hf : ae_strongly_measurable f Î¼) :\n    AEMeasurable (fun a => (Â«exprâ€– â€–â‚ŠÂ» (f a) : ennreal)) Î¼ :=\n  (ENNReal.continuous_coe.comp_ae_strongly_measurable hf.nnnorm).ae_measurable\n#align ennnorm ennnorm\n\n",
 "edist":
 "protected theorem edist {Î² : Type _} [SeminormedAddCommGroup Î²] {f g : Î± â†’ Î²} (hf : ae_strongly_measurable f Î¼)\n    (hg : ae_strongly_measurable g Î¼) : AEMeasurable (fun a => edist (f a) (g a)) Î¼ :=\n  (continuous_edist.comp_ae_strongly_measurable (hf.prod_mk hg)).ae_measurable\n#align edist edist\n\n",
 "div":
 "@[to_additive]\nprotected theorem div [Group Î²] [TopologicalGroup Î²] (hf : ae_strongly_measurable f Î¼)\n    (hg : ae_strongly_measurable g Î¼) : ae_strongly_measurable (f / g) Î¼ :=\n  âŸ¨hf.mk f / hg.mk g, hf.strongly_measurable_mk.div hg.strongly_measurable_mk, hf.ae_eq_mk.div hg.ae_eq_mkâŸ©\n#align div div\n\n",
 "dist":
 "protected theorem dist {Î² : Type _} [PseudoMetricSpace Î²] {f g : Î± â†’ Î²} (hf : ae_strongly_measurable f Î¼)\n    (hg : ae_strongly_measurable g Î¼) : ae_strongly_measurable (fun x => dist (f x) (g x)) Î¼ :=\n  continuous_dist.comp_ae_strongly_measurable (hf.prod_mk hg)\n#align dist dist\n\n",
 "const_smul'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\nprotected theorem const_smul' {ğ•œ} [SMul ğ•œ Î²] [ContinuousConstSMul ğ•œ Î²] (hf : ae_strongly_measurable f Î¼) (c : ğ•œ) :\n    ae_strongly_measurable (fun x => Â«expr â€¢ Â» c (f x)) Î¼ :=\n  hf.const_smul c\n#align const_smul' const_smul'\n\n",
 "const_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\nprotected theorem const_smul {ğ•œ} [TopologicalSpace ğ•œ] [AddMonoid Î²] [Monoid ğ•œ] [DistribMulAction ğ•œ Î²]\n    [ContinuousSMul ğ•œ Î²] (hf : ae_fin_strongly_measurable f Î¼) (c : ğ•œ) : ae_fin_strongly_measurable (Â«expr â€¢ Â» c f) Î¼ :=\n  âŸ¨Â«expr â€¢ Â» c (hf.mk f), hf.fin_strongly_measurable_mk.const_smul c, hf.ae_eq_mk.const_smul câŸ©\n#align const_smul const_smul\n\n",
 "const_mul":
 "@[to_additive]\nprotected theorem const_mul [Mul Î²] [ContinuousMul Î²] (hf : ae_strongly_measurable f Î¼) (c : Î²) :\n    ae_strongly_measurable (fun x => c * f x) Î¼ :=\n  ae_strongly_measurable_const.mul hf\n#align const_mul const_mul\n\n",
 "congr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr =áµ[ ] Â» -/\n#print congr /-\ntheorem congr (hf : ae_strongly_measurable f Î¼) (h : Â«expr =áµ[ ] Â» f Î¼ g) : ae_strongly_measurable g Î¼ :=\n  âŸ¨hf.mk f, hf.strongly_measurable_mk, h.symm.trans hf.ae_eq_mkâŸ©\n#align congr congr\n-/\n\n",
 "comp_strongly_measurable_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/-- If `g` is a topological embedding, then `f` is strongly measurable iff `g âˆ˜ f` is. -/\ntheorem _root_.embedding.comp_strongly_measurable_iff {m : MeasurableSpace Î±} [TopologicalSpace Î²]\n    [pseudo_metrizable_space Î²] [TopologicalSpace Î³] [pseudo_metrizable_space Î³] {g : Î² â†’ Î³} {f : Î± â†’ Î²}\n    (hg : Embedding g) : (strongly_measurable fun x => g (f x)) â†” strongly_measurable f :=\n  by\n  letI := pseudo_metrizable_space_pseudo_metric Î³\n  borelize Î² Î³\n  refine'\n    âŸ¨fun H => strongly_measurable_iff_measurable_separable.2 âŸ¨_, _âŸ©, fun H => hg.continuous.comp_strongly_measurable HâŸ©\n  Â· let G : Î² â†’ range g := cod_restrict g (range g) mem_range_self\n    have hG : ClosedEmbedding G :=\n      { hg.cod_restrict _ _ with\n        closed_range := by\n          convert isClosed_univ\n          apply eq_univ_of_forall\n          rintro âŸ¨-, âŸ¨x, rflâŸ©âŸ©\n          exact mem_range_self x }\n    have : Measurable (G âˆ˜ f) := Measurable.subtype_mk H.measurable\n    exact hG.measurable_embedding.measurable_comp_iff.1 this\n  Â· have : is_separable (Â«expr â»Â¹' Â» g (range (g âˆ˜ f))) := hg.is_separable_preimage H.is_separable_range\n    convert this\n    ext x\n    simp [hg.inj.eq_iff]\n#align embedding.comp_strongly_measurable_iff embedding.comp_strongly_measurable_iff\n\n",
 "comp_strongly_measurable":
 "theorem _root_.continuous.comp_strongly_measurable {m : MeasurableSpace Î±} [TopologicalSpace Î²] [TopologicalSpace Î³]\n    {g : Î² â†’ Î³} {f : Î± â†’ Î²} (hg : Continuous g) (hf : strongly_measurable f) : strongly_measurable fun x => g (f x) :=\n  âŸ¨fun n => simple_func.map g (hf.approx n), fun x => (hg.tendsto _).comp (hf.tendsto_approx x)âŸ©\n#align continuous.comp_strongly_measurable continuous.comp_strongly_measurable\n\n",
 "comp_quasi_measure_preserving":
 "theorem comp_quasi_measure_preserving {Î³ : Type _} {mÎ³ : MeasurableSpace Î³} {mÎ± : MeasurableSpace Î±} {f : Î³ â†’ Î±}\n    {Î¼ : Measure Î³} {Î½ : Measure Î±} (hg : ae_strongly_measurable g Î½) (hf : QuasiMeasurePreserving f Î¼ Î½) :\n    ae_strongly_measurable (g âˆ˜ f) Î¼ :=\n  (hg.mono' hf.absolutely_continuous).comp_measurable hf.measurable\n#align comp_quasi_measure_preserving comp_quasi_measure_preserving\n\n",
 "comp_measurable":
 "theorem comp_measurable {Î³ : Type _} {mÎ³ : MeasurableSpace Î³} {mÎ± : MeasurableSpace Î±} {f : Î³ â†’ Î±} {Î¼ : Measure Î³}\n    (hg : ae_strongly_measurable g (Measure.map f Î¼)) (hf : Measurable f) : ae_strongly_measurable (g âˆ˜ f) Î¼ :=\n  hg.comp_ae_measurable hf.ae_measurable\n#align comp_measurable comp_measurable\n\n",
 "comp_ae_strongly_measurable":
 "/-- The composition of a continuous function and an ae strongly measurable function is ae strongly\nmeasurable. -/\ntheorem _root_.continuous.comp_ae_strongly_measurable {g : Î² â†’ Î³} {f : Î± â†’ Î²} (hg : Continuous g)\n    (hf : ae_strongly_measurable f Î¼) : ae_strongly_measurable (fun x => g (f x)) Î¼ :=\n  âŸ¨_, hg.comp_strongly_measurable hf.strongly_measurable_mk, EventuallyEq.fun_comp hf.ae_eq_mk gâŸ©\n#align continuous.comp_ae_strongly_measurable continuous.comp_ae_strongly_measurable\n\n",
 "comp_ae_measurable":
 "theorem comp_ae_measurable {Î³ : Type _} {mÎ³ : MeasurableSpace Î³} {mÎ± : MeasurableSpace Î±} {f : Î³ â†’ Î±} {Î¼ : Measure Î³}\n    (hg : ae_strongly_measurable g (Measure.map f Î¼)) (hf : AEMeasurable f Î¼) : ae_strongly_measurable (g âˆ˜ f) Î¼ :=\n  âŸ¨hg.mk g âˆ˜ hf.mk f, hg.strongly_measurable_mk.comp_measurable hf.measurable_mk,\n    (ae_eq_comp hf hg.ae_eq_mk).trans (hf.ae_eq_mk.fun_comp (hg.mk g))âŸ©\n#align comp_ae_measurable comp_ae_measurable\n\n",
 "apply_continuous_linear_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\ntheorem apply_continuous_linear_map {Ï† : Î± â†’ Â«expr â†’L[ ] Â» F ğ•œ E} (hÏ† : ae_strongly_measurable Ï† Î¼) (v : F) :\n    ae_strongly_measurable (fun a => Ï† a v) Î¼ :=\n  (continuous_linear_map.apply ğ•œ E v).continuous.comp_ae_strongly_measurable hÏ†\n#align apply_continuous_linear_map apply_continuous_linear_map\n\n",
 "ae_strongly_measurable_zero_measure":
 "@[simp]\ntheorem ae_strongly_measurable_zero_measure [MeasurableSpace Î±] [TopologicalSpace Î²] (f : Î± â†’ Î²) :\n    ae_strongly_measurable f (0 : Measure Î±) := by\n  nontriviality Î±\n  inhabit Î±\n  exact âŸ¨fun x => f default, strongly_measurable_const, rflâŸ©\n#align ae_strongly_measurable_zero_measure ae_strongly_measurable_zero_measure\n\n",
 "ae_strongly_measurable_with_density_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\ntheorem _root_.ae_strongly_measurable_with_density_iff {E : Type _} [NormedAddCommGroup E] [NormedSpace (exprâ„) E]\n    {f : Î± â†’ nnreal} (hf : Measurable f) {g : Î± â†’ E} :\n    ae_strongly_measurable g (Î¼.with_density fun x => (f x : ennreal)) â†”\n      ae_strongly_measurable (fun x => Â«expr â€¢ Â» (f x : exprâ„) (g x)) Î¼ :=\n  by\n  constructor\n  Â· rintro âŸ¨g', g'meas, hg'âŸ©\n    have A : MeasurableSet { x : Î± | f x â‰  0 } := (hf (measurable_set_singleton 0)).compl\n    refine' âŸ¨fun x => Â«expr â€¢ Â» (f x : exprâ„) (g' x), hf.coe_nnreal_real.strongly_measurable.smul g'meas, _âŸ©\n    apply @ae_of_ae_restrict_of_ae_restrict_compl _ _ _ { x | f x â‰  0 }\n    Â· rw [eventually_eq, ae_with_density_iff hf.coe_nnreal_ennreal] at hg'\n      rw [ae_restrict_iff' A]\n      filter_upwards [hg']with a ha h'a\n      have : (f a : ennreal) â‰  0 := by simpa only [ne.def, ENNReal.coe_eq_zero] using h'a\n      rw [ha this]\n    Â· filter_upwards [ae_restrict_mem A.compl]with x hx\n      simp only [Classical.not_not, mem_set_of_eq, mem_compl_iff] at hx\n      simp [hx]\n  Â· rintro âŸ¨g', g'meas, hg'âŸ©\n    refine' âŸ¨fun x => Â«expr â€¢ Â» (f x : exprâ„)â»Â¹ (g' x), hf.coe_nnreal_real.inv.strongly_measurable.smul g'meas, _âŸ©\n    rw [eventually_eq, ae_with_density_iff hf.coe_nnreal_ennreal]\n    filter_upwards [hg']with x hx h'x\n    rw [â† hx, smul_smul, _root_.inv_mul_cancel, one_smul]\n    simp only [ne.def, ENNReal.coe_eq_zero] at h'x\n    simpa only [NNReal.coe_eq_zero, ne.def] using h'x\n#align ae_strongly_measurable_with_density_iff ae_strongly_measurable_with_density_iff\n\n",
 "ae_strongly_measurable_union_iff":
 "@[simp]\ntheorem _root_.ae_strongly_measurable_union_iff [pseudo_metrizable_space Î²] {s t : Set Î±} :\n    ae_strongly_measurable f (Î¼.restrict (s âˆª t)) â†”\n      ae_strongly_measurable f (Î¼.restrict s) âˆ§ ae_strongly_measurable f (Î¼.restrict t) :=\n  by simp only [union_eq_Union, ae_strongly_measurable_Union_iff, Bool.forall_bool, cond, and_comm]\n#align ae_strongly_measurable_union_iff ae_strongly_measurable_union_iff\n\n",
 "ae_strongly_measurable_uIoc_iff":
 "theorem ae_strongly_measurable_uIoc_iff [linear_order Î±] [pseudo_metrizable_space Î²] {f : Î± â†’ Î²} {a b : Î±} :\n    ae_strongly_measurable f (Î¼.restrict <| uIoc a b) â†”\n      ae_strongly_measurable f (Î¼.restrict <| Ioc a b) âˆ§ ae_strongly_measurable f (Î¼.restrict <| Ioc b a) :=\n  by rw [uIoc_eq_union, ae_strongly_measurable_union_iff]\n#align ae_strongly_measurable_uIoc_iff ae_strongly_measurable_uIoc_iff\n\n",
 "ae_strongly_measurable_sum_measure_iff":
 "@[simp]\ntheorem _root_.ae_strongly_measurable_sum_measure_iff [pseudo_metrizable_space Î²] {m : MeasurableSpace Î±}\n    {Î¼ : Î¹ â†’ Measure Î±} : ae_strongly_measurable f (Sum Î¼) â†” âˆ€ i, ae_strongly_measurable f (Î¼ i) :=\n  âŸ¨fun h i => h.mono_measure (Measure.le_sum _ _), sum_measureâŸ©\n#align ae_strongly_measurable_sum_measure_iff ae_strongly_measurable_sum_measure_iff\n\n",
 "ae_strongly_measurable_smul_const_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\ntheorem _root_.ae_strongly_measurable_smul_const_iff {f : Î± â†’ ğ•œ} {c : E} (hc : c â‰  0) :\n    ae_strongly_measurable (fun x => Â«expr â€¢ Â» (f x) c) Î¼ â†” ae_strongly_measurable f Î¼ :=\n  (closed_embedding_smul_left hc).to_embedding.ae_strongly_measurable_comp_iff\n#align ae_strongly_measurable_smul_const_iff ae_strongly_measurable_smul_const_iff\n\n",
 "ae_strongly_measurable_prod'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n@[to_additive]\ntheorem _root_.finset.ae_strongly_measurable_prod' {Î¹ : Type _} {f : Î¹ â†’ Î± â†’ M} (s : Finset Î¹)\n    (hf : âˆ€ i âˆˆ s, ae_strongly_measurable (f i) Î¼) :\n    ae_strongly_measurable\n      (finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f i)) Î¼ :=\n  multiset.ae_strongly_measurable_prod' _ fun g hg =>\n    let âŸ¨i, hi, hgâŸ© := Multiset.mem_map.1 hg\n    hg â–¸ hf _ hi\n#align finset.ae_strongly_measurable_prod' finset.ae_strongly_measurable_prod'\n\n",
 "ae_strongly_measurable_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n@[to_additive]\ntheorem _root_.finset.ae_strongly_measurable_prod {Î¹ : Type _} {f : Î¹ â†’ Î± â†’ M} (s : Finset Î¹)\n    (hf : âˆ€ i âˆˆ s, ae_strongly_measurable (f i) Î¼) :\n    ae_strongly_measurable\n      (fun a =>\n        finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f i a))\n      Î¼ :=\n  by simpa only [â† Finset.prod_apply] using s.ae_strongly_measurable_prod' hf\n#align finset.ae_strongly_measurable_prod finset.ae_strongly_measurable_prod\n\n",
 "ae_strongly_measurable_one":
 "@[to_additive]\ntheorem ae_strongly_measurable_one {Î± Î²} {m : MeasurableSpace Î±} {Î¼ : Measure Î±} [TopologicalSpace Î²] [One Î²] :\n    ae_strongly_measurable (1 : Î± â†’ Î²) Î¼ :=\n  strongly_measurable_one.ae_strongly_measurable\n#align ae_strongly_measurable_one ae_strongly_measurable_one\n\n",
 "ae_strongly_measurable_of_tendsto_ae":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€áµ âˆ‚ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€áµ âˆ‚ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- An almost everywhere sequential limit of almost everywhere strongly measurable functions is\nalmost everywhere strongly measurable. -/\ntheorem _root_.ae_strongly_measurable_of_tendsto_ae {Î¹ : Type _} [pseudo_metrizable_space Î²] (u : Filter Î¹) [NeBot u]\n    [IsCountablyGenerated u] {f : Î¹ â†’ Î± â†’ Î²} {g : Î± â†’ Î²} (hf : âˆ€ i, ae_strongly_measurable (f i) Î¼)\n    (lim :\n      Â«exprâˆ€áµ âˆ‚ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€áµ âˆ‚ , Â»\" Î¼\n        (Tendsto (fun n => f n x) u ((nhds) (g x)))) :\n    ae_strongly_measurable g Î¼ := by\n  borelize Î²\n  refine' ae_strongly_measurable_iff_ae_measurable_separable.2 âŸ¨_, _âŸ©\n  Â· exact ae_measurable_of_tendsto_metrizable_ae _ (fun n => (hf n).ae_measurable) limUnder\n  Â· rcases u.exists_seq_tendsto with âŸ¨v, hvâŸ©\n    have : âˆ€ n : â„•, âˆƒ t : Set Î², is_separable t âˆ§ Â«expr â»Â¹' Â» (f (v n)) t âˆˆ Î¼.ae := fun n =>\n      (ae_strongly_measurable_iff_ae_measurable_separable.1 (hf (v n))).2\n    choose t t_sep ht using this\n    refine'\n      âŸ¨closure (Â«exprâ‹ƒ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â»\" (t i)),\n        (is_separable_Union fun i => t_sep i).closure, _âŸ©\n    filter_upwards [ae_all_iff.2 ht, limUnder]with x hx h'x\n    apply mem_closure_of_tendsto (h'x.comp hv)\n    apply eventually_of_forall fun n => _\n    apply mem_Union_of_mem n\n    exact hx n\n#align ae_strongly_measurable_of_tendsto_ae ae_strongly_measurable_of_tendsto_ae\n\n",
 "ae_strongly_measurable_of_ae_strongly_measurable_trim":
 "theorem _root_.ae_strongly_measurable_of_ae_strongly_measurable_trim {Î±} {m m0 : MeasurableSpace Î±} {Î¼ : Measure Î±}\n    (hm : m â‰¤ m0) {f : Î± â†’ Î²} (hf : ae_strongly_measurable f (Î¼.trim hm)) : ae_strongly_measurable f Î¼ :=\n  âŸ¨hf.mk f, strongly_measurable.mono hf.strongly_measurable_mk hm, ae_eq_of_ae_eq_trim hf.ae_eq_mkâŸ©\n#align ae_strongly_measurable_of_ae_strongly_measurable_trim ae_strongly_measurable_of_ae_strongly_measurable_trim\n\n",
 "ae_strongly_measurable_map_iff":
 "theorem _root_.measurable_embedding.ae_strongly_measurable_map_iff {Î³ : Type _} {mÎ³ : MeasurableSpace Î³}\n    {mÎ± : MeasurableSpace Î±} {f : Î³ â†’ Î±} {Î¼ : Measure Î³} (hf : MeasurableEmbedding f) {g : Î± â†’ Î²} :\n    ae_strongly_measurable g (Measure.map f Î¼) â†” ae_strongly_measurable (g âˆ˜ f) Î¼ :=\n  by\n  refine' âŸ¨fun H => H.comp_measurable hf.measurable, _âŸ©\n  rintro âŸ¨gâ‚, hgmâ‚, heqâŸ©\n  rcases hf.exists_strongly_measurable_extend hgmâ‚ fun x => âŸ¨g xâŸ© with âŸ¨gâ‚‚, hgmâ‚‚, rflâŸ©\n  exact âŸ¨gâ‚‚, hgmâ‚‚, hf.ae_map_iff.2 HEqâŸ©\n#align measurable_embedding.ae_strongly_measurable_map_iff measurable_embedding.ae_strongly_measurable_map_iff\n\n",
 "ae_strongly_measurable_indicator_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr =áµ[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr =áµ[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á¶œÂ» -/\ntheorem _root_.ae_strongly_measurable_indicator_iff [Zero Î²] {s : Set Î±} (hs : MeasurableSet s) :\n    ae_strongly_measurable (indicator s f) Î¼ â†” ae_strongly_measurable f (Î¼.restrict s) :=\n  by\n  constructor\n  Â· intro h\n    exact (h.mono_measure measure.restrict_le_self).congr (indicator_ae_eq_restrict hs)\n  Â· intro h\n    refine' âŸ¨indicator s (h.mk f), h.strongly_measurable_mk.indicator hs, _âŸ©\n    have A : Â«expr =áµ[ ] Â» (s.indicator f) (Î¼.restrict s) (s.indicator (h.mk f)) :=\n      (indicator_ae_eq_restrict hs).trans (h.ae_eq_mk.trans <| (indicator_ae_eq_restrict hs).symm)\n    have B : Â«expr =áµ[ ] Â» (s.indicator f) (Î¼.restrict (Â«expr á¶œÂ» s)) (s.indicator (h.mk f)) :=\n      (indicator_ae_eq_restrict_compl hs).trans (indicator_ae_eq_restrict_compl hs).symm\n    exact ae_of_ae_restrict_of_ae_restrict_compl _ A B\n#align ae_strongly_measurable_indicator_iff ae_strongly_measurable_indicator_iff\n\n",
 "ae_strongly_measurable_iff_ae_measurable_separable":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr =áµ[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€áµ âˆ‚ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€áµ âˆ‚ , Â» -/\n/-- A function is almost everywhere strongly measurable if and only if it is almost everywhere\nmeasurable, and up to a zero measure set its range is contained in a separable set. -/\ntheorem _root_.ae_strongly_measurable_iff_ae_measurable_separable [pseudo_metrizable_space Î²] [MeasurableSpace Î²]\n    [borel_space Î²] :\n    ae_strongly_measurable f Î¼ â†”\n      AEMeasurable f Î¼ âˆ§\n        âˆƒ t : Set Î²,\n          IsSeparable t âˆ§\n            Â«exprâˆ€áµ âˆ‚ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€áµ âˆ‚ , Â»\" Î¼\n              (f x âˆˆ t) :=\n  by\n  refine' âŸ¨fun H => âŸ¨H.ae_measurable, H.is_separable_ae_rangeâŸ©, _âŸ©\n  rintro âŸ¨H, âŸ¨t, t_sep, htâŸ©âŸ©\n  rcases eq_empty_or_nonempty t with (rfl | hâ‚€)\n  Â· simp only [mem_empty_iff_false, eventually_false_iff_eq_bot, ae_eq_bot] at ht\n    rw [ht]\n    exact ae_strongly_measurable_zero_measure f\n  Â· obtain âŸ¨g, g_meas, gt, fgâŸ© : âˆƒ g : Î± â†’ Î², Measurable g âˆ§ range g âŠ† t âˆ§ Â«expr =áµ[ ] Â» f Î¼ g :=\n      H.exists_ae_eq_range_subset ht hâ‚€\n    refine' âŸ¨g, _, fgâŸ©\n    exact strongly_measurable_iff_measurable_separable.2 âŸ¨g_meas, t_sep.mono GT.gtâŸ©\n#align ae_strongly_measurable_iff_ae_measurable_separable ae_strongly_measurable_iff_ae_measurable_separable\n\n",
 "ae_strongly_measurable_iff_ae_measurable":
 "/-- In a space with second countable topology, strongly measurable and measurable are equivalent. -/\ntheorem _root_.ae_strongly_measurable_iff_ae_measurable [pseudo_metrizable_space Î²] [borel_space Î²]\n    [SecondCountableTopology Î²] : ae_strongly_measurable f Î¼ â†” AEMeasurable f Î¼ :=\n  âŸ¨fun h => h.ae_measurable, fun h => h.ae_strongly_measurableâŸ©\n#align ae_strongly_measurable_iff_ae_measurable ae_strongly_measurable_iff_ae_measurable\n\n",
 "ae_strongly_measurable_id":
 "theorem _root_.ae_strongly_measurable_id {Î± : Type _} [TopologicalSpace Î±] [pseudo_metrizable_space Î±]\n    {m : MeasurableSpace Î±} [opens_measurable_space Î±] [SecondCountableTopology Î±] {Î¼ : Measure Î±} :\n    ae_strongly_measurable (id : Î± â†’ Î±) Î¼ :=\n  aemeasurable_id.ae_strongly_measurable\n#align ae_strongly_measurable_id ae_strongly_measurable_id\n\n",
 "ae_strongly_measurable_const_smul_iffâ‚€":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\ntheorem _root_.ae_strongly_measurable_const_smul_iffâ‚€ {c : Gâ‚€} (hc : c â‰  0) :\n    ae_strongly_measurable (fun x => Â«expr â€¢ Â» c (f x)) Î¼ â†” ae_strongly_measurable f Î¼ :=\n  by\n  refine' âŸ¨fun h => _, fun h => h.const_smul câŸ©\n  convert h.const_smul' câ»Â¹\n  simp [smul_smul, inv_mul_cancel hc]\n#align ae_strongly_measurable_const_smul_iffâ‚€ ae_strongly_measurable_const_smul_iffâ‚€\n\n",
 "ae_strongly_measurable_const_smul_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\ntheorem _root_.ae_strongly_measurable_const_smul_iff (c : G) :\n    ae_strongly_measurable (fun x => Â«expr â€¢ Â» c (f x)) Î¼ â†” ae_strongly_measurable f Î¼ :=\n  âŸ¨fun h => by simpa only [inv_smul_smul] using h.const_smul' câ»Â¹, fun h => h.const_smul câŸ©\n#align ae_strongly_measurable_const_smul_iff ae_strongly_measurable_const_smul_iff\n\n",
 "ae_strongly_measurable_const":
 "theorem ae_strongly_measurable_const {Î± Î²} {m : MeasurableSpace Î±} {Î¼ : Measure Î±} [TopologicalSpace Î²] {b : Î²} :\n    ae_strongly_measurable (fun a : Î± => b) Î¼ :=\n  strongly_measurable_const.ae_strongly_measurable\n#align ae_strongly_measurable_const ae_strongly_measurable_const\n\n",
 "ae_strongly_measurable_congr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr =áµ[ ] Â» -/\ntheorem _root_.ae_strongly_measurable_congr (h : Â«expr =áµ[ ] Â» f Î¼ g) :\n    ae_strongly_measurable f Î¼ â†” ae_strongly_measurable g Î¼ :=\n  âŸ¨fun hf => hf.congr h, fun hg => hg.congr h.symmâŸ©\n#align ae_strongly_measurable_congr ae_strongly_measurable_congr\n\n",
 "ae_strongly_measurable_compâ‚‚":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\ntheorem _root_.continuous_linear_map.ae_strongly_measurable_compâ‚‚ (L : Â«expr â†’L[ ] Â» E ğ•œ (Â«expr â†’L[ ] Â» F ğ•œ G))\n    {f : Î± â†’ E} {g : Î± â†’ F} (hf : ae_strongly_measurable f Î¼) (hg : ae_strongly_measurable g Î¼) :\n    ae_strongly_measurable (fun x => L (f x) (g x)) Î¼ :=\n  L.continuousâ‚‚.comp_ae_strongly_measurable <| hf.prod_mk hg\n#align continuous_linear_map.ae_strongly_measurable_compâ‚‚ continuous_linear_map.ae_strongly_measurable_compâ‚‚\n\n",
 "ae_strongly_measurable_comp_iff":
 "theorem _root_.measure_theory.measure_preserving.ae_strongly_measurable_comp_iff {Î² : Type _} {f : Î± â†’ Î²}\n    {mÎ± : MeasurableSpace Î±} {Î¼a : Measure Î±} {mÎ² : MeasurableSpace Î²} {Î¼b : Measure Î²} (hf : MeasurePreserving f Î¼a Î¼b)\n    (hâ‚‚ : MeasurableEmbedding f) {g : Î² â†’ Î³} : ae_strongly_measurable (g âˆ˜ f) Î¼a â†” ae_strongly_measurable g Î¼b := by\n  rw [â† hf.map_eq, hâ‚‚.ae_strongly_measurable_map_iff]\n#align measure_theory.measure_preserving.ae_strongly_measurable_comp_iff measure_theory.measure_preserving.ae_strongly_measurable_comp_iff\n\n",
 "ae_strongly_measurable_add_measure_iff":
 "@[simp]\ntheorem _root_.ae_strongly_measurable_add_measure_iff [pseudo_metrizable_space Î²] {Î½ : Measure Î±} :\n    ae_strongly_measurable f (Î¼ + Î½) â†” ae_strongly_measurable f Î¼ âˆ§ ae_strongly_measurable f Î½ :=\n  by\n  rw [â† sum_cond, ae_strongly_measurable_sum_measure_iff, Bool.forall_bool, and_comm]\n  rfl\n#align ae_strongly_measurable_add_measure_iff ae_strongly_measurable_add_measure_iff\n\n",
 "ae_strongly_measurable_Union_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â» -/\n@[simp]\ntheorem _root_.ae_strongly_measurable_Union_iff [pseudo_metrizable_space Î²] {s : Î¹ â†’ Set Î±} :\n    ae_strongly_measurable f\n        (Î¼.restrict\n          (Â«exprâ‹ƒ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â»\" (s i))) â†”\n      âˆ€ i, ae_strongly_measurable f (Î¼.restrict (s i)) :=\n  âŸ¨fun h i => h.mono_measure <| restrict_mono (subset_unionáµ¢ _ _) le_rfl, ae_strongly_measurable.UnionâŸ©\n#align ae_strongly_measurable_Union_iff ae_strongly_measurable_Union_iff\n\n",
 "ae_strongly_measurable'":
 "@[simp]\ntheorem subsingleton.ae_strongly_measurable' {m : MeasurableSpace Î±} [TopologicalSpace Î²] [subsingleton Î±]\n    {Î¼ : Measure Î±} (f : Î± â†’ Î²) : ae_strongly_measurable f Î¼ :=\n  (subsingleton.strongly_measurable' f).ae_strongly_measurable\n#align subsingleton.ae_strongly_measurable' subsingleton.ae_strongly_measurable'\n\n",
 "ae_strongly_measurable":
 "/-- In a space with second countable topology, measurable implies strongly measurable. -/\ntheorem _root_.ae_measurable.ae_strongly_measurable [pseudo_metrizable_space Î²] [opens_measurable_space Î²]\n    [SecondCountableTopology Î²] (hf : AEMeasurable f Î¼) : ae_strongly_measurable f Î¼ :=\n  âŸ¨hf.mk f, hf.measurable_mk.strongly_measurable, hf.ae_eq_mkâŸ©\n#align ae_measurable.ae_strongly_measurable ae_measurable.ae_strongly_measurable\n\n",
 "ae_mem_imp_eq_mk":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€áµ âˆ‚ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€áµ âˆ‚ , Â» -/\ntheorem ae_mem_imp_eq_mk {s} (h : ae_strongly_measurable f (Î¼.restrict s)) :\n    Â«exprâˆ€áµ âˆ‚ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€áµ âˆ‚ , Â»\" Î¼\n      (x âˆˆ s â†’ f x = h.mk f x) :=\n  ae_imp_of_ae_restrict h.ae_eq_mk\n#align ae_mem_imp_eq_mk ae_mem_imp_eq_mk\n\n",
 "ae_fin_strongly_measurable_zero":
 "theorem ae_fin_strongly_measurable_zero {Î± Î²} {m : MeasurableSpace Î±} (Î¼ : Measure Î±) [Zero Î²] [TopologicalSpace Î²] :\n    ae_fin_strongly_measurable (0 : Î± â†’ Î²) Î¼ :=\n  âŸ¨0, fin_strongly_measurable_zero, EventuallyEq.rflâŸ©\n#align ae_fin_strongly_measurable_zero ae_fin_strongly_measurable_zero\n\n",
 "ae_fin_strongly_measurable_iff_ae_measurable":
 "/-- In a space with second countable topology and a sigma-finite measure,\n  `ae_fin_strongly_measurable` and `ae_measurable` are equivalent. -/\ntheorem ae_fin_strongly_measurable_iff_ae_measurable {m0 : MeasurableSpace Î±} (Î¼ : Measure Î±) [SigmaFinite Î¼] :\n    ae_fin_strongly_measurable f Î¼ â†” AEMeasurable f Î¼ := by\n  simp_rw [ae_fin_strongly_measurable, AEMeasurable, fin_strongly_measurable_iff_measurable]\n#align ae_fin_strongly_measurable_iff_ae_measurable ae_fin_strongly_measurable_iff_ae_measurable\n\n",
 "ae_fin_strongly_measurable":
 "theorem ae_fin_strongly_measurable [Zero Î²] [TopologicalSpace Î²] (hf : fin_strongly_measurable f Î¼) :\n    ae_fin_strongly_measurable f Î¼ :=\n  âŸ¨f, hf, ae_eq_refl fâŸ©\n#align ae_fin_strongly_measurable ae_fin_strongly_measurable\n\n",
 "ae_eq_zero_compl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr =áµ[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á¶œÂ» -/\ntheorem ae_eq_zero_compl (hf : ae_fin_strongly_measurable f Î¼) :\n    Â«expr =áµ[ ] Â» f (Î¼.restrict (Â«expr á¶œÂ» hf.sigma_finite_set)) 0 :=\n  hf.exists_set_sigma_finite.some_spec.2.1\n#align ae_eq_zero_compl ae_eq_zero_compl\n\n",
 "ae_eq_mk":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr =áµ[ ] Â» -/\ntheorem ae_eq_mk (hf : ae_fin_strongly_measurable f Î¼) : Â«expr =áµ[ ] Â» f Î¼ (hf.mk f) :=\n  hf.some_spec.2\n#align ae_eq_mk ae_eq_mk\n\n",
 "add_measure":
 "theorem add_measure [pseudo_metrizable_space Î²] {Î½ : Measure Î±} {f : Î± â†’ Î²} (hÎ¼ : ae_strongly_measurable f Î¼)\n    (hÎ½ : ae_strongly_measurable f Î½) : ae_strongly_measurable f (Î¼ + Î½) :=\n  ae_strongly_measurable_add_measure_iff.2 âŸ¨hÎ¼, hÎ½âŸ©\n#align add_measure add_measure\n\n",
 "add":
 "protected theorem add [AddMonoid Î²] [ContinuousAdd Î²] (hf : ae_fin_strongly_measurable f Î¼)\n    (hg : ae_fin_strongly_measurable g Î¼) : ae_fin_strongly_measurable (f + g) Î¼ :=\n  âŸ¨hf.mk f + hg.mk g, hf.fin_strongly_measurable_mk.add hg.fin_strongly_measurable_mk, hf.ae_eq_mk.add hg.ae_eq_mkâŸ©\n#align add add\n\n",
 "Union":
 "/- warning: Union clashes with has_union -> Union\nCase conversion may be inaccurate. Consider using '#align Union Unionâ‚“'. -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â» -/\n#print Union /-\nprotected theorem Union [pseudo_metrizable_space Î²] {s : Î¹ â†’ Set Î±}\n    (h : âˆ€ i, ae_strongly_measurable f (Î¼.restrict (s i))) :\n    ae_strongly_measurable f\n      (Î¼.restrict\n        (Â«exprâ‹ƒ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â»\" (s i))) :=\n  (sum_measure h).mono_measure <| restrict_unionáµ¢_le\n#align Union Union\n-/\n\n",
 "MeasurableSet":
 "#print MeasurableSet /-\nprotected theorem MeasurableSet (hf : ae_fin_strongly_measurable f Î¼) : MeasurableSet hf.sigma_finite_set :=\n  hf.exists_set_sigma_finite.some_spec.1\n#align measurable_set MeasurableSet\n-/\n\n",
 "Measurable":
 "#print Measurable /-\n/-- A finitely strongly measurable function is measurable. -/\nprotected theorem Measurable [Zero Î²] [TopologicalSpace Î²] [pseudo_metrizable_space Î²] [MeasurableSpace Î²]\n    [borel_space Î²] (hf : fin_strongly_measurable f Î¼) : Measurable f :=\n  hf.strongly_measurable.measurable\n#align measurable Measurable\n-/\n\n",
 "AEMeasurable":
 "#print AEMeasurable /-\nprotected theorem AEMeasurable {Î²} [Zero Î²] [MeasurableSpace Î²] [TopologicalSpace Î²] [pseudo_metrizable_space Î²]\n    [borel_space Î²] {f : Î± â†’ Î²} (hf : ae_fin_strongly_measurable f Î¼) : AEMeasurable f Î¼ :=\n  âŸ¨hf.mk f, hf.fin_strongly_measurable_mk.measurable, hf.ae_eq_mkâŸ©\n#align ae_measurable AEMeasurable\n-/\n\n"}