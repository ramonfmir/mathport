{"zero_to_simple_func":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\ntheorem zero_to_simple_func : «expr =ᵐ[ ] » (to_simple_func (0 : Lp.simple_func E p μ)) μ 0 :=\n  by\n  filter_upwards [to_simple_func_eq_to_fun (0 : Lp.simple_func E p μ), Lp.coe_fn_zero E 1 μ] with _ h₁ _\n  rwa [h₁]\n#align zero_to_simple_func zero_to_simple_func\n\n",
 "uniform_inducing":
 "protected theorem uniform_inducing : uniform_inducing (coe : Lp.simple_func E p μ → Lp E p μ) :=\n  simple_func.uniform_embedding.to_uniform_inducing\n#align uniform_inducing uniform_inducing\n\n",
 "uniform_embedding":
 "protected theorem uniform_embedding : uniform_embedding (coe : Lp.simple_func E p μ → Lp E p μ) :=\n  uniform_embedding_comap subtype.val_injective\n#align uniform_embedding uniform_embedding\n\n",
 "uniform_continuous":
 "protected theorem uniform_continuous : uniform_continuous (coe : Lp.simple_func E p μ → Lp E p μ) :=\n  uniform_continuous_comap\n#align uniform_continuous uniform_continuous\n\n",
 "to_simple_func_to_Lp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\ntheorem to_simple_func_to_Lp (f : «expr →ₛ » α E) (hfi : mem_ℒp f p μ) :\n    «expr =ᵐ[ ] » (to_simple_func (to_Lp f hfi)) μ f :=\n  by\n  rw [← ae_eq_fun.mk_eq_mk]\n  exact Classical.choose_spec (to_Lp f hfi).2\n#align to_simple_func_to_Lp to_simple_func_to_Lp\n\n",
 "to_simple_func_indicator_const":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\ntheorem to_simple_func_indicator_const {s : set α} (hs : measurable_set s) (hμs : μ s ≠ ennreal.top) (c : E) :\n    «expr =ᵐ[ ] » (to_simple_func (indicator_const p hs hμs c)) μ\n      ((simple_func.const _ c).piecewise s hs (simple_func.const _ 0)) :=\n  Lp.simple_func.to_simple_func_to_Lp _ _\n#align to_simple_func_indicator_const to_simple_func_indicator_const\n\n",
 "to_simple_func_eq_to_fun":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₘ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\ntheorem to_simple_func_eq_to_fun (f : Lp.simple_func E p μ) : «expr =ᵐ[ ] » (to_simple_func f) μ f :=\n  show «expr =ᵐ[ ] » («expr⇑ » (to_simple_func f)) μ («expr⇑ » (f : «expr →ₘ[ ] » α μ E))\n    by\n    convert (ae_eq_fun.coe_fn_mk (to_simple_func f) (to_simple_func f).ae_strongly_measurable).symm using 2\n    exact (Classical.choose_spec f.2).symm\n#align to_simple_func_eq_to_fun to_simple_func_eq_to_fun\n\n",
 "to_Lp_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛ » -/\ntheorem to_Lp_zero : to_Lp (0 : «expr →ₛ » α E) zero_mem_ℒp = (0 : Lp.simple_func E p μ) :=\n  rfl\n#align to_Lp_zero to_Lp_zero\n\n",
 "to_Lp_to_simple_func":
 "theorem to_Lp_to_simple_func (f : Lp.simple_func E p μ) : to_Lp (to_simple_func f) (simple_func.mem_ℒp f) = f :=\n  simple_func.eq' (Classical.choose_spec f.2)\n#align to_Lp_to_simple_func to_Lp_to_simple_func\n\n",
 "to_Lp_sub":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛ » -/\ntheorem to_Lp_sub (f g : «expr →ₛ » α E) (hf : mem_ℒp f p μ) (hg : mem_ℒp g p μ) :\n    to_Lp (f - g) (hf.sub hg) = to_Lp f hf - to_Lp g hg :=\n  by\n  simp only [sub_eq_add_neg, ← to_Lp_neg, ← to_Lp_add]\n  rfl\n#align to_Lp_sub to_Lp_sub\n\n",
 "to_Lp_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem to_Lp_smul (f : «expr →ₛ » α E) (hf : mem_ℒp f p μ) (c : 𝕜) :\n    to_Lp («expr • » c f) (hf.const_smul c) = «expr • » c (to_Lp f hf) :=\n  rfl\n#align to_Lp_smul to_Lp_smul\n\n",
 "to_Lp_one_eq_to_L1":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure_theory.L1 -/\ntheorem L1.simple_func.to_Lp_one_eq_to_L1 (f : «expr →ₛ » α E) (hf : integrable f μ) :\n    (Lp.simple_func.to_Lp f (mem_ℒp_one_iff_integrable.2 hf) : measure_theory.L1 α μ E) = hf.to_L1 f :=\n  rfl\n#align L1.simple_func.to_Lp_one_eq_to_L1 L1.simple_func.to_Lp_one_eq_to_L1\n\n",
 "to_Lp_neg":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛ » -/\ntheorem to_Lp_neg (f : «expr →ₛ » α E) (hf : mem_ℒp f p μ) : to_Lp (-f) hf.neg = -to_Lp f hf :=\n  rfl\n#align to_Lp_neg to_Lp_neg\n\n",
 "to_Lp_eq_to_Lp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛ » -/\ntheorem to_Lp_eq_to_Lp (f : «expr →ₛ » α E) (hf : mem_ℒp f p μ) : (to_Lp f hf : Lp E p μ) = hf.to_Lp f :=\n  rfl\n#align to_Lp_eq_to_Lp to_Lp_eq_to_Lp\n\n",
 "to_Lp_eq_mk":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₘ[ ] » -/\ntheorem to_Lp_eq_mk (f : «expr →ₛ » α E) (hf : mem_ℒp f p μ) :\n    (to_Lp f hf : «expr →ₘ[ ] » α μ E) = ae_eq_fun.mk f f.ae_strongly_measurable :=\n  rfl\n#align to_Lp_eq_mk to_Lp_eq_mk\n\n",
 "to_Lp_add":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛ » -/\ntheorem to_Lp_add (f g : «expr →ₛ » α E) (hf : mem_ℒp f p μ) (hg : mem_ℒp g p μ) :\n    to_Lp (f + g) (hf.add hg) = to_Lp f hf + to_Lp g hg :=\n  rfl\n#align to_Lp_add to_Lp_add\n\n",
 "tendsto_approx_on_range_Lp_snorm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem tendsto_approx_on_range_Lp_snorm [borel_space E] {f : β → E} (hp_ne_top : p ≠ ennreal.top) {μ : measure β}\n    (fmeas : measurable f) [separable_space (range f ∪ {0} : set E)] (hf : snorm f p μ < ennreal.top) :\n    tendsto (fun n => snorm (approx_on f fmeas (range f ∪ {0}) 0 (by simp) n - f) p μ) at_top ((nhds) 0) :=\n  by\n  refine' tendsto_approx_on_Lp_snorm fmeas _ hp_ne_top _ _\n  · apply eventually_of_forall\n    intro x\n    apply subset_closure\n    simp\n  · simpa using hf\n#align tendsto_approx_on_range_Lp_snorm tendsto_approx_on_range_Lp_snorm\n\n",
 "tendsto_approx_on_range_Lp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem tendsto_approx_on_range_Lp [borel_space E] {f : β → E} [hp : fact (1 ≤ p)] (hp_ne_top : p ≠ ennreal.top)\n    {μ : measure β} (fmeas : measurable f) [separable_space (range f ∪ {0} : set E)] (hf : mem_ℒp f p μ) :\n    tendsto (fun n => (mem_ℒp_approx_on_range fmeas hf n).to_Lp (approx_on f fmeas (range f ∪ {0}) 0 (by simp) n))\n      at_top ((nhds) (hf.to_Lp f)) :=\n  by simpa only [Lp.tendsto_Lp_iff_tendsto_ℒp''] using tendsto_approx_on_range_Lp_snorm hp_ne_top fmeas hf.2\n#align tendsto_approx_on_range_Lp tendsto_approx_on_range_Lp\n\n",
 "tendsto_approx_on_range_L1_nnnorm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫⁻ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem tendsto_approx_on_range_L1_nnnorm [opens_measurable_space E] {f : β → E} {μ : measure β}\n    [separable_space (range f ∪ {0} : set E)] (fmeas : measurable f) (hf : integrable f μ) :\n    tendsto\n      (fun n =>\n        «expr∫⁻ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ , ∂ »\"\n          («expr‖ ‖₊» (approx_on f fmeas (range f ∪ {0}) 0 (by simp) n x - f x)) μ)\n      at_top ((nhds) 0) :=\n  by\n  apply tendsto_approx_on_L1_nnnorm fmeas\n  · apply eventually_of_forall\n    intro x\n    apply subset_closure\n    simp\n  · simpa using hf.2\n#align tendsto_approx_on_range_L1_nnnorm tendsto_approx_on_range_L1_nnnorm\n\n",
 "tendsto_approx_on_Lp_snorm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫⁻ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≤ᵐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫⁻ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem tendsto_approx_on_Lp_snorm [opens_measurable_space E] {f : β → E} (hf : measurable f) {s : set E} {y₀ : E}\n    (h₀ : y₀ ∈ s) [separable_space s] (hp_ne_top : p ≠ ennreal.top) {μ : measure β}\n    (hμ :\n      «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\" μ\n        (f x ∈ closure s))\n    (hi : snorm (fun x => f x - y₀) p μ < ennreal.top) :\n    tendsto (fun n => snorm (approx_on f hf s y₀ h₀ n - f) p μ) at_top ((nhds) 0) :=\n  by\n  by_cases hp_zero : p = 0\n  · simpa only [hp_zero, snorm_exponent_zero] using tendsto_const_nhds\n  have hp : 0 < p.to_real := to_real_pos hp_zero hp_ne_top\n  suffices\n    tendsto\n      (fun n =>\n        «expr∫⁻ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ , ∂ »\"\n          («expr‖ ‖₊» (approx_on f hf s y₀ h₀ n x - f x) ^ p.to_real) μ)\n      at_top ((nhds) 0)\n    by\n    simp only [snorm_eq_lintegral_rpow_nnnorm hp_zero hp_ne_top]\n    convert continuous_rpow_const.continuous_at.tendsto.comp this <;> simp [_root_.inv_pos.mpr hp]\n  -- We simply check the conditions of the Dominated Convergence Theorem:\n  -- (1) The function \"`p`-th power of distance between `f` and the approximation\" is measurable\n  have hF_meas : ∀ n, measurable fun x => («expr‖ ‖₊» (approx_on f hf s y₀ h₀ n x - f x) : ennreal) ^ p.to_real := by\n    simpa only [← edist_eq_coe_nnnorm_sub] using fun n =>\n      (approx_on f hf s y₀ h₀ n).measurable_bind (fun y x => edist y (f x) ^ p.to_real) fun y =>\n        (measurable_edist_right.comp hf).pow_const p.to_real\n  -- (2) The functions \"`p`-th power of distance between `f` and the approximation\" are uniformly\n  -- bounded, at any given point, by `λ x, ‖f x - y₀‖ ^ p.to_real`\n  have h_bound :\n    ∀ n,\n      «expr ≤ᵐ[ ] » (fun x => («expr‖ ‖₊» (approx_on f hf s y₀ h₀ n x - f x) : ennreal) ^ p.to_real) μ fun x =>\n        «expr‖ ‖₊» (f x - y₀) ^ p.to_real :=\n    fun n => eventually_of_forall fun x => rpow_le_rpow (coe_mono (nnnorm_approx_on_le hf h₀ x n)) to_real_nonneg\n  -- (3) The bounding function `λ x, ‖f x - y₀‖ ^ p.to_real` has finite integral\n  have h_fin :\n    «expr∫⁻ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ , ∂ »\"\n        («expr‖ ‖₊» (f a - y₀) ^ p.to_real) μ ≠\n      «expr⊤» :=\n    (lintegral_rpow_nnnorm_lt_top_of_snorm_lt_top hp_zero hp_ne_top hi).ne\n  -- (4) The functions \"`p`-th power of distance between `f` and the approximation\" tend pointwise\n  -- to zero\n  have h_lim :\n    «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\" μ\n      (tendsto (fun n => («expr‖ ‖₊» (approx_on f hf s y₀ h₀ n a - f a) : ennreal) ^ p.to_real) at_top ((nhds) 0)) :=\n    by\n    filter_upwards [hμ] with a ha\n    have : tendsto (fun n => (approx_on f hf s y₀ h₀ n) a - f a) at_top ((nhds) (f a - f a)) :=\n      (tendsto_approx_on hf h₀ ha).sub tendsto_const_nhds\n    convert continuous_rpow_const.continuous_at.tendsto.comp (tendsto_coe.mpr this.nnnorm)\n    simp [zero_rpow_of_pos hp]\n  -- Then we apply the Dominated Convergence Theorem\n  simpa using tendsto_lintegral_of_dominated_convergence _ hF_meas h_bound h_fin h_lim\n#align tendsto_approx_on_Lp_snorm tendsto_approx_on_Lp_snorm\n\n",
 "tendsto_approx_on_L1_nnnorm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫⁻ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem tendsto_approx_on_L1_nnnorm [opens_measurable_space E] {f : β → E} (hf : measurable f) {s : set E} {y₀ : E}\n    (h₀ : y₀ ∈ s) [separable_space s] {μ : measure β}\n    (hμ :\n      «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\" μ\n        (f x ∈ closure s))\n    (hi : has_finite_integral (fun x => f x - y₀) μ) :\n    tendsto\n      (fun n =>\n        «expr∫⁻ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ , ∂ »\"\n          («expr‖ ‖₊» (approx_on f hf s y₀ h₀ n x - f x)) μ)\n      at_top ((nhds) 0) :=\n  by\n  simpa [snorm_one_eq_lintegral_nnnorm] using\n    tendsto_approx_on_Lp_snorm hf h₀ one_ne_top hμ (by simpa [snorm_one_eq_lintegral_nnnorm] using hi)\n#align tendsto_approx_on_L1_nnnorm tendsto_approx_on_L1_nnnorm\n\n",
 "sub_to_simple_func":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\ntheorem sub_to_simple_func (f g : Lp.simple_func E p μ) :\n    «expr =ᵐ[ ] » (to_simple_func (f - g)) μ (to_simple_func f - to_simple_func g) :=\n  by\n  filter_upwards [to_simple_func_eq_to_fun (f - g), to_simple_func_eq_to_fun f, to_simple_func_eq_to_fun g,\n    Lp.coe_fn_sub (f : Lp E p μ) g] with _\n  simp only [add_subgroup.coe_sub, pi.sub_apply, ← coe_coe]\n  repeat' intro h; rw [h]\n#align sub_to_simple_func sub_to_simple_func\n\n",
 "strongly_measurable":
 "protected theorem strongly_measurable (f : Lp.simple_func E p μ) : strongly_measurable (to_simple_func f) :=\n  (to_simple_func f).strongly_measurable\n#align strongly_measurable strongly_measurable\n\n",
 "snorm'_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\nprotected theorem snorm'_eq {p : exprℝ} (f : «expr →ₛ » α F) (μ : measure α) :\n    snorm' f p μ =\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" f.range\n          ((«expr‖ ‖₊» y : ennreal) ^ p * μ («expr ⁻¹' » f {y})) ^\n        (1 / p) :=\n  by\n  have h_map : (fun a => («expr‖ ‖₊» (f a) : ennreal) ^ p) = f.map fun a : F => («expr‖ ‖₊» a : ennreal) ^ p := by simp\n  rw [snorm', h_map, lintegral_eq_lintegral, map_lintegral]\n#align snorm'_eq snorm'_eq\n\n",
 "smul_to_simple_func":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem smul_to_simple_func (k : 𝕜) (f : Lp.simple_func E p μ) :\n    «expr =ᵐ[ ] » (to_simple_func («expr • » k f)) μ («expr • » k (to_simple_func f)) :=\n  by\n  filter_upwards [to_simple_func_eq_to_fun («expr • » k f), to_simple_func_eq_to_fun f,\n    Lp.coe_fn_smul k (f : Lp E p μ)] with _\n  simp only [pi.smul_apply, coe_smul, ← coe_coe]\n  repeat' intro h; rw [h]\n#align smul_to_simple_func smul_to_simple_func\n\n",
 "norm_to_simple_func":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem norm_to_simple_func [fact (1 ≤ p)] (f : Lp.simple_func E p μ) :\n    «expr‖ ‖» f = ennreal.to_real (snorm (to_simple_func f) p μ) := by\n  simpa [to_Lp_to_simple_func] using norm_to_Lp (to_simple_func f) (simple_func.mem_ℒp f)\n#align norm_to_simple_func norm_to_simple_func\n\n",
 "norm_to_Lp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem norm_to_Lp [fact (1 ≤ p)] (f : «expr →ₛ » α E) (hf : mem_ℒp f p μ) :\n    «expr‖ ‖» (to_Lp f hf) = ennreal.to_real (snorm f p μ) :=\n  norm_to_Lp f hf\n#align norm_to_Lp norm_to_Lp\n\n",
 "norm_approx_on_zero_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem norm_approx_on_zero_le [opens_measurable_space E] {f : β → E} (hf : measurable f) {s : set E} (h₀ : (0 : E) ∈ s)\n    [separable_space s] (x : β) (n : ℕ) : «expr‖ ‖» (approx_on f hf s 0 h₀ n x) ≤ «expr‖ ‖» (f x) + «expr‖ ‖» (f x) :=\n  by\n  have := edist_approx_on_y0_le hf h₀ x n\n  simp [edist_comm (0 : E), edist_eq_coe_nnnorm] at this\n  exact_mod_cast this\n#align norm_approx_on_zero_le norm_approx_on_zero_le\n\n",
 "norm_approx_on_y₀_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem norm_approx_on_y₀_le [opens_measurable_space E] {f : β → E} (hf : measurable f) {s : set E} {y₀ : E}\n    (h₀ : y₀ ∈ s) [separable_space s] (x : β) (n : ℕ) :\n    «expr‖ ‖» (approx_on f hf s y₀ h₀ n x - y₀) ≤ «expr‖ ‖» (f x - y₀) + «expr‖ ‖» (f x - y₀) :=\n  by\n  have := edist_approx_on_y0_le hf h₀ x n\n  repeat' rw [edist_comm y₀, edist_eq_coe_nnnorm_sub] at this\n  exact_mod_cast this\n#align norm_approx_on_y₀_le norm_approx_on_y₀_le\n\n",
 "nnnorm_approx_on_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/-\nCopyright (c) 2022 Zhouhang Zhou. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Zhouhang Zhou, Yury Kudryashov, Heather Macbeth\n-/\ntheorem nnnorm_approx_on_le [opens_measurable_space E] {f : β → E} (hf : measurable f) {s : set E} {y₀ : E}\n    (h₀ : y₀ ∈ s) [separable_space s] (x : β) (n : ℕ) :\n    «expr‖ ‖₊» (approx_on f hf s y₀ h₀ n x - f x) ≤ «expr‖ ‖₊» (f x - y₀) :=\n  by\n  have := edist_approx_on_le hf h₀ x n\n  rw [edist_comm y₀] at this\n  simp only [edist_nndist, nndist_eq_nnnorm] at this\n  exact_mod_cast this\n#align nnnorm_approx_on_le nnnorm_approx_on_le\n\n",
 "neg_to_simple_func":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\ntheorem neg_to_simple_func (f : Lp.simple_func E p μ) : «expr =ᵐ[ ] » (to_simple_func (-f)) μ (-to_simple_func f) :=\n  by\n  filter_upwards [to_simple_func_eq_to_fun (-f), to_simple_func_eq_to_fun f, Lp.coe_fn_neg (f : Lp E p μ)] with _\n  simp only [pi.neg_apply, add_subgroup.coe_neg, ← coe_coe]\n  repeat' intro h; rw [h]\n#align neg_to_simple_func neg_to_simple_func\n\n",
 "mem_ℒp_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛ » -/\ntheorem mem_ℒp_zero (f : «expr →ₛ » α E) (μ : measure α) : mem_ℒp f 0 μ :=\n  mem_ℒp_zero_iff_ae_strongly_measurable.mpr f.ae_strongly_measurable\n#align mem_ℒp_zero mem_ℒp_zero\n\n",
 "mem_ℒp_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\ntheorem mem_ℒp_top (f : «expr →ₛ » α E) (μ : measure α) : mem_ℒp f (ennreal.top) μ :=\n  let ⟨C, hfC⟩ := f.exists_forall_norm_le\n  mem_ℒp_top_of_bound f.ae_strongly_measurable C <| eventually_of_forall hfC\n#align mem_ℒp_top mem_ℒp_top\n\n",
 "mem_ℒp_of_is_finite_measure":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\ntheorem mem_ℒp_of_is_finite_measure (f : «expr →ₛ » α E) (p : ennreal) (μ : measure α) [is_finite_measure μ] :\n    mem_ℒp f p μ :=\n  let ⟨C, hfC⟩ := f.exists_forall_norm_le\n  mem_ℒp.of_bound f.ae_strongly_measurable C <| eventually_of_forall hfC\n#align mem_ℒp_of_is_finite_measure mem_ℒp_of_is_finite_measure\n\n",
 "mem_ℒp_of_finite_measure_preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛ » -/\n/- ./././Mathport/Syntax/Translate/Basic.lean:632:2: warning: expanding binder collection (y «expr ≠ » 0) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\ntheorem mem_ℒp_of_finite_measure_preimage (p : ennreal) {f : «expr →ₛ » α E}\n    (hf : ∀ (y) (_ : y ≠ 0), μ («expr ⁻¹' » f {y}) < ennreal.top) : mem_ℒp f p μ :=\n  by\n  by_cases hp0 : p = 0\n  · rw [hp0, mem_ℒp_zero_iff_ae_strongly_measurable]\n    exact f.ae_strongly_measurable\n  by_cases hp_top : p = ennreal.top\n  · rw [hp_top]\n    exact mem_ℒp_top f μ\n  refine' ⟨f.ae_strongly_measurable, _⟩\n  rw [snorm_eq_snorm' hp0 hp_top, f.snorm'_eq]\n  refine' ennreal.rpow_lt_top_of_nonneg (by simp) (ennreal.sum_lt_top_iff.mpr fun y hy => _).ne\n  by_cases hy0 : y = 0\n  · simp [hy0, ennreal.to_real_pos hp0 hp_top]\n  · refine' ennreal.mul_lt_top _ (hf y hy0).ne\n    exact (ennreal.rpow_lt_top_of_nonneg ennreal.to_real_nonneg ennreal.coe_ne_top).ne\n#align mem_ℒp_of_finite_measure_preimage mem_ℒp_of_finite_measure_preimage\n\n",
 "mem_ℒp_iff_integrable":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\ntheorem mem_ℒp_iff_integrable {f : «expr →ₛ » α E} (hp_pos : p ≠ 0) (hp_ne_top : p ≠ ennreal.top) :\n    mem_ℒp f p μ ↔ integrable f μ :=\n  (mem_ℒp_iff hp_pos hp_ne_top).trans integrable_iff.symm\n#align mem_ℒp_iff_integrable mem_ℒp_iff_integrable\n\n",
 "mem_ℒp_iff_fin_meas_supp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\ntheorem mem_ℒp_iff_fin_meas_supp {f : «expr →ₛ » α E} (hp_pos : p ≠ 0) (hp_ne_top : p ≠ ennreal.top) :\n    mem_ℒp f p μ ↔ f.fin_meas_supp μ :=\n  (mem_ℒp_iff hp_pos hp_ne_top).trans fin_meas_supp_iff.symm\n#align mem_ℒp_iff_fin_meas_supp mem_ℒp_iff_fin_meas_supp\n\n",
 "mem_ℒp_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Basic.lean:632:2: warning: expanding binder collection (y «expr ≠ » 0) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\ntheorem mem_ℒp_iff {f : «expr →ₛ » α E} (hp_pos : p ≠ 0) (hp_ne_top : p ≠ ennreal.top) :\n    mem_ℒp f p μ ↔ ∀ (y) (_ : y ≠ 0), μ («expr ⁻¹' » f {y}) < ennreal.top :=\n  ⟨fun h => measure_preimage_lt_top_of_mem_ℒp hp_pos hp_ne_top f h, fun h => mem_ℒp_of_finite_measure_preimage p h⟩\n#align mem_ℒp_iff mem_ℒp_iff\n\n",
 "mem_ℒp_approx_on_range":
 "theorem mem_ℒp_approx_on_range [borel_space E] {f : β → E} {μ : measure β} (fmeas : measurable f)\n    [separable_space (range f ∪ {0} : set E)] (hf : mem_ℒp f p μ) (n : ℕ) :\n    mem_ℒp (approx_on f fmeas (range f ∪ {0}) 0 (by simp) n) p μ :=\n  mem_ℒp_approx_on fmeas hf (by simp) zero_mem_ℒp n\n#align mem_ℒp_approx_on_range mem_ℒp_approx_on_range\n\n",
 "mem_ℒp_approx_on":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem mem_ℒp_approx_on [borel_space E] {f : β → E} {μ : measure β} (fmeas : measurable f) (hf : mem_ℒp f p μ)\n    {s : set E} {y₀ : E} (h₀ : y₀ ∈ s) [separable_space s] (hi₀ : mem_ℒp (fun x => y₀) p μ) (n : ℕ) :\n    mem_ℒp (approx_on f fmeas s y₀ h₀ n) p μ :=\n  by\n  refine' ⟨(approx_on f fmeas s y₀ h₀ n).ae_strongly_measurable, _⟩\n  suffices snorm (fun x => approx_on f fmeas s y₀ h₀ n x - y₀) p μ < «expr⊤»\n    by\n    have : mem_ℒp (fun x => approx_on f fmeas s y₀ h₀ n x - y₀) p μ :=\n      ⟨(approx_on f fmeas s y₀ h₀ n - const β y₀).ae_strongly_measurable, this⟩\n    convert snorm_add_lt_top this hi₀\n    ext x\n    simp\n  have hf' : mem_ℒp (fun x => «expr‖ ‖» (f x - y₀)) p μ :=\n    by\n    have h_meas : measurable fun x => «expr‖ ‖» (f x - y₀) :=\n      by\n      simp only [← dist_eq_norm]\n      exact (continuous_id.dist continuous_const).measurable.comp fmeas\n    refine' ⟨h_meas.ae_measurable.ae_strongly_measurable, _⟩\n    rw [snorm_norm]\n    convert snorm_add_lt_top hf hi₀.neg\n    ext x\n    simp [sub_eq_add_neg]\n  have :\n    «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\" μ\n      («expr‖ ‖» (approx_on f fmeas s y₀ h₀ n x - y₀) ≤ «expr‖ ‖» («expr‖ ‖» (f x - y₀) + «expr‖ ‖» (f x - y₀))) :=\n    by\n    refine' eventually_of_forall _\n    intro x\n    convert norm_approx_on_y₀_le fmeas h₀ x n\n    rw [real.norm_eq_abs, abs_of_nonneg]\n    exact add_nonneg (norm_nonneg _) (norm_nonneg _)\n  calc\n    snorm (fun x => approx_on f fmeas s y₀ h₀ n x - y₀) p μ ≤\n        snorm (fun x => «expr‖ ‖» (f x - y₀) + «expr‖ ‖» (f x - y₀)) p μ :=\n      snorm_mono_ae this\n    _ < «expr⊤» := snorm_add_lt_top hf' hf'\n    \n#align mem_ℒp_approx_on mem_ℒp_approx_on\n\n",
 "mem_ℒp":
 "/-- `to_simple_func f` satisfies the predicate `mem_ℒp`. -/\nprotected theorem mem_ℒp (f : Lp.simple_func E p μ) : mem_ℒp (to_simple_func f) p μ :=\n  mem_ℒp.ae_eq (to_simple_func_eq_to_fun f).symm <| mem_Lp_iff_mem_ℒp.mp (f : Lp E p μ).2\n#align mem_ℒp mem_ℒp\n\n",
 "measure_support_lt_top_of_mem_ℒp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\ntheorem measure_support_lt_top_of_mem_ℒp (f : «expr →ₛ » α E) (hf : mem_ℒp f p μ) (hp_ne_zero : p ≠ 0)\n    (hp_ne_top : p ≠ ennreal.top) : μ (support f) < ennreal.top :=\n  f.measure_support_lt_top ((mem_ℒp_iff hp_ne_zero hp_ne_top).mp hf)\n#align measure_support_lt_top_of_mem_ℒp measure_support_lt_top_of_mem_ℒp\n\n",
 "measure_support_lt_top_of_integrable":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\ntheorem measure_support_lt_top_of_integrable (f : «expr →ₛ » α E) (hf : integrable f μ) : μ (support f) < ennreal.top :=\n  f.measure_support_lt_top (integrable_iff.mp hf)\n#align measure_support_lt_top_of_integrable measure_support_lt_top_of_integrable\n\n",
 "measure_support_lt_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛ » -/\n/- ./././Mathport/Syntax/Translate/Basic.lean:632:2: warning: expanding binder collection (y «expr ≠ » 0) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\ntheorem measure_support_lt_top [Zero β] (f : «expr →ₛ » α β)\n    (hf : ∀ (y) (_ : y ≠ 0), μ («expr ⁻¹' » f {y}) < ennreal.top) : μ (support f) < ennreal.top :=\n  by\n  rw [support_eq]\n  refine' (measure_bUnion_finset_le _ _).trans_lt (ennreal.sum_lt_top_iff.mpr fun y hy => _)\n  rw [Finset.mem_filter] at hy\n  exact hf y hy.2\n#align measure_support_lt_top measure_support_lt_top\n\n",
 "measure_preimage_lt_top_of_mem_ℒp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\ntheorem measure_preimage_lt_top_of_mem_ℒp (hp_pos : p ≠ 0) (hp_ne_top : p ≠ ennreal.top) (f : «expr →ₛ » α E)\n    (hf : mem_ℒp f p μ) (y : E) (hy_ne : y ≠ 0) : μ («expr ⁻¹' » f {y}) < ennreal.top :=\n  by\n  have hp_pos_real : 0 < p.to_real := ennreal.to_real_pos hp_pos hp_ne_top\n  have hf_snorm := mem_ℒp.snorm_lt_top hf\n  rw [snorm_eq_snorm' hp_pos hp_ne_top, f.snorm'_eq, ←\n    @ennreal.lt_rpow_one_div_iff _ _ (1 / p.to_real) (by simp [hp_pos_real]),\n    @ennreal.top_rpow_of_pos (1 / (1 / p.to_real)) (by simp [hp_pos_real]), ennreal.sum_lt_top_iff] at hf_snorm\n  by_cases hyf : y ∈ f.range\n  swap\n  · suffices h_empty : «expr ⁻¹' » f {y} = ∅\n    · rw [h_empty, measure_empty]\n      exact ennreal.coe_lt_top\n    ext1 x\n    rw [Set.mem_preimage, Set.mem_singleton_iff, mem_empty_iff_false, iff_false_iff]\n    refine' fun hxy => hyf _\n    rw [mem_range, Set.mem_range]\n    exact ⟨x, hxy⟩\n  specialize hf_snorm y hyf\n  rw [ennreal.mul_lt_top_iff] at hf_snorm\n  cases hf_snorm\n  · exact hf_snorm.2\n  cases hf_snorm\n  · refine' absurd _ hy_ne\n    simpa [hp_pos_real] using hf_snorm\n  · simp [hf_snorm]\n#align measure_preimage_lt_top_of_mem_ℒp measure_preimage_lt_top_of_mem_ℒp\n\n",
 "measure_preimage_lt_top_of_integrable":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\ntheorem measure_preimage_lt_top_of_integrable (f : «expr →ₛ » α E) (hf : integrable f μ) {x : E} (hx : x ≠ 0) :\n    μ («expr ⁻¹' » f {x}) < ennreal.top :=\n  integrable_iff.mp hf x hx\n#align measure_preimage_lt_top_of_integrable measure_preimage_lt_top_of_integrable\n\n",
 "measure_lt_top_of_mem_ℒp_indicator":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem measure_lt_top_of_mem_ℒp_indicator (hp_pos : p ≠ 0) (hp_ne_top : p ≠ ennreal.top) {c : E} (hc : c ≠ 0)\n    {s : set α} (hs : measurable_set s) (hcs : mem_ℒp ((const α c).piecewise s hs (const α 0)) p μ) : μ s < «expr⊤» :=\n  by\n  have : function.support (const α c) = Set.univ := function.support_const hc\n  simpa only [mem_ℒp_iff_fin_meas_supp hp_pos hp_ne_top, fin_meas_supp_iff_support, support_indicator, Set.inter_univ,\n    this] using hcs\n#align measure_lt_top_of_mem_ℒp_indicator measure_lt_top_of_mem_ℒp_indicator\n\n",
 "measurable":
 "/-- `(to_simple_func f)` is measurable. -/\n@[measurability]\nprotected theorem measurable [measurable_space E] (f : Lp.simple_func E p μ) : measurable (to_simple_func f) :=\n  (to_simple_func f).measurable\n#align measurable measurable\n\n",
 "integrable_pair":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛ » -/\ntheorem integrable_pair {f : «expr →ₛ » α E} {g : «expr →ₛ » α F} :\n    integrable f μ → integrable g μ → integrable (pair f g) μ := by\n  simpa only [integrable_iff_fin_meas_supp] using fin_meas_supp.pair\n#align integrable_pair integrable_pair\n\n",
 "integrable_of_is_finite_measure":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛ » -/\ntheorem integrable_of_is_finite_measure [is_finite_measure μ] (f : «expr →ₛ » α E) : integrable f μ :=\n  mem_ℒp_one_iff_integrable.mp (f.mem_ℒp_of_is_finite_measure 1 μ)\n#align integrable_of_is_finite_measure integrable_of_is_finite_measure\n\n",
 "integrable_iff_fin_meas_supp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛ » -/\ntheorem integrable_iff_fin_meas_supp {f : «expr →ₛ » α E} : integrable f μ ↔ f.fin_meas_supp μ :=\n  integrable_iff.trans fin_meas_supp_iff.symm\n#align integrable_iff_fin_meas_supp integrable_iff_fin_meas_supp\n\n",
 "integrable_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛ » -/\n/- ./././Mathport/Syntax/Translate/Basic.lean:632:2: warning: expanding binder collection (y «expr ≠ » 0) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\ntheorem integrable_iff {f : «expr →ₛ » α E} : integrable f μ ↔ ∀ (y) (_ : y ≠ 0), μ («expr ⁻¹' » f {y}) < ennreal.top :=\n  mem_ℒp_one_iff_integrable.symm.trans <| mem_ℒp_iff ennreal.zero_lt_one.ne' ennreal.coe_ne_top\n#align integrable_iff integrable_iff\n\n",
 "integrable_approx_on_range":
 "theorem integrable_approx_on_range [borel_space E] {f : β → E} {μ : measure β} (fmeas : measurable f)\n    [separable_space (range f ∪ {0} : set E)] (hf : integrable f μ) (n : ℕ) :\n    integrable (approx_on f fmeas (range f ∪ {0}) 0 (by simp) n) μ :=\n  integrable_approx_on fmeas hf _ (integrable_zero _ _ _) n\n#align integrable_approx_on_range integrable_approx_on_range\n\n",
 "integrable_approx_on":
 "theorem integrable_approx_on [borel_space E] {f : β → E} {μ : measure β} (fmeas : measurable f) (hf : integrable f μ)\n    {s : set E} {y₀ : E} (h₀ : y₀ ∈ s) [separable_space s] (hi₀ : integrable (fun x => y₀) μ) (n : ℕ) :\n    integrable (approx_on f fmeas s y₀ h₀ n) μ :=\n  by\n  rw [← mem_ℒp_one_iff_integrable] at hf hi₀⊢\n  exact mem_ℒp_approx_on fmeas hf h₀ hi₀ n\n#align integrable_approx_on integrable_approx_on\n\n",
 "integrable":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₁ₛ[ ] » -/\nprotected theorem L1.simple_func.integrable (f : «expr →₁ₛ[ ] » α μ E) :\n    integrable (Lp.simple_func.to_simple_func f) μ :=\n  by\n  rw [← mem_ℒp_one_iff_integrable]\n  exact Lp.simple_func.mem_ℒp f\n#align L1.simple_func.integrable L1.simple_func.integrable\n\n",
 "induction":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure_theory.L1 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\n/-- To prove something for an arbitrary integrable function in a normed group,\nit suffices to show that\n* the property holds for (multiples of) characteristic functions;\n* is closed under addition;\n* the set of functions in the `L¹` space for which the property holds is closed.\n* the property is closed under the almost-everywhere equal relation.\n\nIt is possible to make the hypotheses in the induction steps a bit stronger, and such conditions\ncan be added once we need them (for example in `h_add` it is only necessary to consider the sum of\na simple function with a multiple of a characteristic function and that the intersection\nof their images is a subset of `{0}`).\n-/\n@[elab_as_elim]\ntheorem integrable.induction (P : (α → E) → Prop)\n    (h_ind : ∀ (c : E) ⦃s⦄, measurable_set s → μ s < ennreal.top → P (s.indicator fun _ => c))\n    (h_add :\n      ∀ ⦃f g : α → E⦄, Disjoint (support f) (support g) → integrable f μ → integrable g μ → P f → P g → P (f + g))\n    (h_closed : is_closed { f : measure_theory.L1 α μ E | P f })\n    (h_ae : ∀ ⦃f g⦄, «expr =ᵐ[ ] » f μ g → integrable f μ → P f → P g) : ∀ ⦃f : α → E⦄ (hf : integrable f μ), P f :=\n  by\n  simp only [← mem_ℒp_one_iff_integrable] at *\n  exact mem_ℒp.induction one_ne_top P h_ind h_add h_closed h_ae\n#align integrable.induction integrable.induction\n\n",
 "exists_simple_func_nonneg_ae_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≤ᵐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\ntheorem exists_simple_func_nonneg_ae_eq {f : Lp.simple_func G p μ} (hf : 0 ≤ f) :\n    ∃ f' : «expr →ₛ » α G, 0 ≤ f' ∧ «expr =ᵐ[ ] » f μ f' :=\n  by\n  rw [← Lp.simple_func.coe_fn_nonneg] at hf\n  have hf_ae : «expr ≤ᵐ[ ] » 0 μ (simple_func.to_simple_func f) :=\n    by\n    filter_upwards [to_simple_func_eq_to_fun f, hf] with _ h1 _\n    rwa [h1]\n  let s := «expr ᶜ» (to_measurable μ { x | ¬0 ≤ simple_func.to_simple_func f x })\n  have hs_zero : μ («expr ᶜ» s) = 0 := by\n    rw [compl_compl, measure_to_measurable]\n    rwa [eventually_le, ae_iff] at hf_ae\n  have hfs_nonneg : ∀ x ∈ s, 0 ≤ simple_func.to_simple_func f x :=\n    by\n    intro x hxs\n    rw [mem_compl_iff] at hxs\n    have hx' : x ∉ { a : α | ¬0 ≤ simple_func.to_simple_func f a } := fun h => hxs (subset_to_measurable μ _ h)\n    rwa [Set.nmem_setOf_iff, not_not] at hx'\n  let f' :=\n    simple_func.piecewise s (measurable_set_to_measurable μ _).compl (simple_func.to_simple_func f)\n      (simple_func.const α (0 : G))\n  refine' ⟨f', fun x => _, _⟩\n  · rw [simple_func.piecewise_apply]\n    by_cases hxs : x ∈ s\n    · simp only [hxs, hfs_nonneg x hxs, if_true, pi.zero_apply, simple_func.coe_zero]\n    · simp only [hxs, simple_func.const_zero, if_false]\n  · rw [simple_func.coe_piecewise]\n    have : «expr =ᵐ[ ] » s μ univ := by\n      rw [ae_eq_set]\n      simp only [true_and_iff, measure_empty, eq_self_iff_true, diff_univ, ← compl_eq_univ_diff]\n      exact hs_zero\n    refine' eventually_eq.trans (to_simple_func_eq_to_fun f).symm _\n    refine' eventually_eq.trans _ (piecewise_ae_eq_of_ae_eq_set this.symm)\n    simp only [simple_func.const_zero, indicator_univ, piecewise_eq_indicator, simple_func.coe_zero]\n#align exists_simple_func_nonneg_ae_eq exists_simple_func_nonneg_ae_eq\n\n",
 "exists_forall_norm_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem exists_forall_norm_le (f : «expr →ₛ » α F) : ∃ C, ∀ x, «expr‖ ‖» (f x) ≤ C :=\n  exists_forall_le (f.map fun x => «expr‖ ‖» x)\n#align exists_forall_norm_le exists_forall_norm_le\n\n",
 "eq'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₘ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₘ[ ] » -/\nprotected theorem eq' {f g : Lp.simple_func E p μ} : (f : «expr →ₘ[ ] » α μ E) = (g : «expr →ₘ[ ] » α μ E) → f = g :=\n  subtype.eq ∘ subtype.eq\n#align eq' eq'\n\n",
 "dense_range_coe_simple_func_nonneg_to_Lp_nonneg":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≤ᵐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\ntheorem dense_range_coe_simple_func_nonneg_to_Lp_nonneg [hp : fact (1 ≤ p)] (hp_ne_top : p ≠ ennreal.top) :\n    dense_range (coe_simple_func_nonneg_to_Lp_nonneg p μ G) :=\n  by\n  borelize G\n  intro g\n  rw [mem_closure_iff_seq_limit]\n  have hg_mem_ℒp : mem_ℒp g p μ := Lp.mem_ℒp g\n  have zero_mem : (0 : G) ∈ (range g ∪ {0} : set G) ∩ { y | 0 ≤ y } := by\n    simp only [union_singleton, mem_inter_iff, mem_insert_iff, eq_self_iff_true, true_or_iff, mem_set_of_eq, le_refl,\n      and_self_iff]\n  have : separable_space ((range g ∪ {0}) ∩ { y | 0 ≤ y } : set G) :=\n    by\n    apply is_separable.separable_space\n    apply is_separable.mono _ (Set.inter_subset_left _ _)\n    exact (Lp.strongly_measurable (g : Lp G p μ)).is_separable_range.union (finite_singleton _).is_separable\n  have g_meas : measurable g := (Lp.strongly_measurable (g : Lp G p μ)).measurable\n  let x n := simple_func.approx_on g g_meas ((range g ∪ {0}) ∩ { y | 0 ≤ y }) 0 zero_mem n\n  have hx_nonneg : ∀ n, 0 ≤ x n := by\n    intro n a\n    change x n a ∈ { y : G | 0 ≤ y }\n    have A : (range g ∪ {0} : set G) ∩ { y | 0 ≤ y } ⊆ { y | 0 ≤ y } := inter_subset_right _ _\n    apply A\n    exact simple_func.approx_on_mem g_meas _ n a\n  have hx_mem_ℒp : ∀ n, mem_ℒp (x n) p μ :=\n    simple_func.mem_ℒp_approx_on _ hg_mem_ℒp _ ⟨ae_strongly_measurable_const, by simp⟩\n  have h_to_Lp := fun n => mem_ℒp.coe_fn_to_Lp (hx_mem_ℒp n)\n  have hx_nonneg_Lp : ∀ n, 0 ≤ to_Lp (x n) (hx_mem_ℒp n) :=\n    by\n    intro n\n    rw [← Lp.simple_func.coe_fn_le, coe_fn_coe_base' (simple_func.to_Lp (x n) _), Lp.simple_func.to_Lp_eq_to_Lp]\n    have h0 := Lp.simple_func.coe_fn_zero p μ G\n    filter_upwards [Lp.simple_func.coe_fn_zero p μ G, h_to_Lp n] with a ha0 ha_to_Lp\n    rw [ha0, ha_to_Lp]\n    exact hx_nonneg n a\n  have hx_tendsto : tendsto (fun n : ℕ => snorm (x n - g) p μ) at_top ((nhds) 0) :=\n    by\n    apply simple_func.tendsto_approx_on_Lp_snorm g_meas zero_mem hp_ne_top\n    · have hg_nonneg : «expr ≤ᵐ[ ] » 0 μ g := (Lp.coe_fn_nonneg _).mpr g.2\n      refine' hg_nonneg.mono fun a ha => subset_closure _\n      simpa using ha\n    · simp_rw [sub_zero]\n      exact hg_mem_ℒp.snorm_lt_top\n  refine'\n    ⟨fun n => (coe_simple_func_nonneg_to_Lp_nonneg p μ G) ⟨to_Lp (x n) (hx_mem_ℒp n), hx_nonneg_Lp n⟩, fun n =>\n      mem_range_self _, _⟩\n  suffices tendsto (fun n : ℕ => ↑(to_Lp (x n) (hx_mem_ℒp n))) at_top ((nhds) (g : Lp G p μ))\n    by\n    rw [tendsto_iff_dist_tendsto_zero] at this⊢\n    simp_rw [subtype.dist_eq]\n    convert this\n  rw [Lp.tendsto_Lp_iff_tendsto_ℒp']\n  convert hx_tendsto\n  refine' funext fun n => snorm_congr_ae (eventually_eq.sub _ _)\n  · rw [Lp.simple_func.to_Lp_eq_to_Lp]\n    exact h_to_Lp n\n  · rw [← coe_fn_coe_base]\n#align dense_range_coe_simple_func_nonneg_to_Lp_nonneg dense_range_coe_simple_func_nonneg_to_Lp_nonneg\n\n",
 "dense_range":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\nprotected theorem dense_range (hp_ne_top : p ≠ ennreal.top) : dense_range (coe : Lp.simple_func E p μ → Lp E p μ) :=\n  (simple_func.dense_inducing hp_ne_top).dense\n#align dense_range dense_range\n\n",
 "dense_inducing":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\nprotected theorem dense_inducing (hp_ne_top : p ≠ ennreal.top) :\n    dense_inducing (coe : Lp.simple_func E p μ → Lp E p μ) :=\n  (simple_func.dense_embedding hp_ne_top).to_dense_inducing\n#align dense_inducing dense_inducing\n\n",
 "dense_embedding":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\nprotected theorem dense_embedding (hp_ne_top : p ≠ ennreal.top) :\n    dense_embedding (coe : Lp.simple_func E p μ → Lp E p μ) :=\n  by\n  borelize E\n  apply simple_func.uniform_embedding.dense_embedding\n  intro f\n  rw [mem_closure_iff_seq_limit]\n  have hfi' : mem_ℒp f p μ := Lp.mem_ℒp f\n  haveI : separable_space (range f ∪ {0} : set E) := (Lp.strongly_measurable f).separable_space_range_union_singleton\n  refine'\n    ⟨fun n =>\n      ↑(to_Lp (simple_func.approx_on f (Lp.strongly_measurable f).measurable (range f ∪ {0}) 0 (by simp) n)\n          (simple_func.mem_ℒp_approx_on_range (Lp.strongly_measurable f).measurable hfi' n)),\n      fun n => mem_range_self _, _⟩\n  convert simple_func.tendsto_approx_on_range_Lp hp_ne_top (Lp.strongly_measurable f).measurable hfi'\n  rw [to_Lp_coe_fn f (Lp.mem_ℒp f)]\n#align dense_embedding dense_embedding\n\n",
 "coe_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp, norm_cast]\ntheorem coe_smul (c : 𝕜) (f : Lp.simple_func E p μ) :\n    ((«expr • » c f : Lp.simple_func E p μ) : Lp E p μ) = «expr • » c (f : Lp E p μ) :=\n  rfl\n#align coe_smul coe_smul\n\n",
 "coe_indicator_const":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n@[simp]\ntheorem coe_indicator_const {s : set α} (hs : measurable_set s) (hμs : μ s ≠ ennreal.top) (c : E) :\n    (↑(indicator_const p hs hμs c) : Lp E p μ) = indicator_const_Lp p hs hμs c :=\n  rfl\n#align coe_indicator_const coe_indicator_const\n\n",
 "coe_fn_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\ntheorem coe_fn_zero : «expr =ᵐ[ ] » (0 : Lp.simple_func G p μ) μ (0 : α → G) :=\n  Lp.coe_fn_zero _ _ _\n#align coe_fn_zero coe_fn_zero\n\n",
 "coe_fn_nonneg":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≤ᵐ[ ] » -/\ntheorem coe_fn_nonneg (f : Lp.simple_func G p μ) : «expr ≤ᵐ[ ] » 0 μ f ↔ 0 ≤ f :=\n  by\n  rw [← Lp.simple_func.coe_fn_le]\n  have h0 : «expr =ᵐ[ ] » (0 : Lp.simple_func G p μ) μ (0 : α → G) := Lp.simple_func.coe_fn_zero p μ G\n  constructor <;> intro h <;> filter_upwards [h, h0] with _ _ h2\n  · rwa [h2]\n  · rwa [← h2]\n#align coe_fn_nonneg coe_fn_nonneg\n\n",
 "coe_fn_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≤ᵐ[ ] » -/\ntheorem coe_fn_le (f g : Lp.simple_func G p μ) : «expr ≤ᵐ[ ] » f μ g ↔ f ≤ g := by\n  rw [← Subtype.coe_le_coe, ← Lp.coe_fn_le, coe_fn_coe_base', coe_fn_coe_base' g]\n#align coe_fn_le coe_fn_le\n\n",
 "coe_coe":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n@[norm_cast]\ntheorem coe_coe (f : Lp.simple_func E p μ) : «expr⇑ » (f : Lp E p μ) = f :=\n  rfl\n#align coe_coe coe_coe\n\n",
 "ae_strongly_measurable":
 "protected theorem ae_strongly_measurable (f : Lp.simple_func E p μ) : ae_strongly_measurable (to_simple_func f) μ :=\n  (simple_func.strongly_measurable f).ae_strongly_measurable\n#align ae_strongly_measurable ae_strongly_measurable\n\n",
 "ae_measurable":
 "@[measurability]\nprotected theorem ae_measurable [measurable_space E] (f : Lp.simple_func E p μ) : ae_measurable (to_simple_func f) μ :=\n  (simple_func.measurable f).ae_measurable\n#align ae_measurable ae_measurable\n\n",
 "add_to_simple_func":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\ntheorem add_to_simple_func (f g : Lp.simple_func E p μ) :\n    «expr =ᵐ[ ] » (to_simple_func (f + g)) μ (to_simple_func f + to_simple_func g) :=\n  by\n  filter_upwards [to_simple_func_eq_to_fun (f + g), to_simple_func_eq_to_fun f, to_simple_func_eq_to_fun g,\n    Lp.coe_fn_add (f : Lp E p μ) g] with _\n  simp only [← coe_coe, add_subgroup.coe_add, pi.add_apply]\n  iterate 4 intro h; rw [h]\n#align add_to_simple_func add_to_simple_func\n\n"}