{"zero_to_simple_func":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr =áµ[ ] Â» -/\ntheorem zero_to_simple_func : Â«expr =áµ[ ] Â» (to_simple_func (0 : Lp.simple_func E p Î¼)) Î¼ 0 :=\n  by\n  filter_upwards [to_simple_func_eq_to_fun (0 : Lp.simple_func E p Î¼), Lp.coe_fn_zero E 1 Î¼] with _ hâ‚ _\n  rwa [hâ‚]\n#align zero_to_simple_func zero_to_simple_func\n\n",
 "uniform_inducing":
 "protected theorem uniform_inducing : uniform_inducing (coe : Lp.simple_func E p Î¼ â†’ Lp E p Î¼) :=\n  simple_func.uniform_embedding.to_uniform_inducing\n#align uniform_inducing uniform_inducing\n\n",
 "uniform_embedding":
 "protected theorem uniform_embedding : uniform_embedding (coe : Lp.simple_func E p Î¼ â†’ Lp E p Î¼) :=\n  uniform_embedding_comap subtype.val_injective\n#align uniform_embedding uniform_embedding\n\n",
 "uniform_continuous":
 "protected theorem uniform_continuous : uniform_continuous (coe : Lp.simple_func E p Î¼ â†’ Lp E p Î¼) :=\n  uniform_continuous_comap\n#align uniform_continuous uniform_continuous\n\n",
 "to_simple_func_to_Lp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚› Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr =áµ[ ] Â» -/\ntheorem to_simple_func_to_Lp (f : Â«expr â†’â‚› Â» Î± E) (hfi : mem_â„’p f p Î¼) :\n    Â«expr =áµ[ ] Â» (to_simple_func (to_Lp f hfi)) Î¼ f :=\n  by\n  rw [â† ae_eq_fun.mk_eq_mk]\n  exact Classical.choose_spec (to_Lp f hfi).2\n#align to_simple_func_to_Lp to_simple_func_to_Lp\n\n",
 "to_simple_func_indicator_const":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr =áµ[ ] Â» -/\ntheorem to_simple_func_indicator_const {s : set Î±} (hs : measurable_set s) (hÎ¼s : Î¼ s â‰  ennreal.top) (c : E) :\n    Â«expr =áµ[ ] Â» (to_simple_func (indicator_const p hs hÎ¼s c)) Î¼\n      ((simple_func.const _ c).piecewise s hs (simple_func.const _ 0)) :=\n  Lp.simple_func.to_simple_func_to_Lp _ _\n#align to_simple_func_indicator_const to_simple_func_indicator_const\n\n",
 "to_simple_func_eq_to_fun":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr =áµ[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‡‘ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‡‘ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚˜[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr =áµ[ ] Â» -/\ntheorem to_simple_func_eq_to_fun (f : Lp.simple_func E p Î¼) : Â«expr =áµ[ ] Â» (to_simple_func f) Î¼ f :=\n  show Â«expr =áµ[ ] Â» (Â«exprâ‡‘ Â» (to_simple_func f)) Î¼ (Â«exprâ‡‘ Â» (f : Â«expr â†’â‚˜[ ] Â» Î± Î¼ E))\n    by\n    convert (ae_eq_fun.coe_fn_mk (to_simple_func f) (to_simple_func f).ae_strongly_measurable).symm using 2\n    exact (Classical.choose_spec f.2).symm\n#align to_simple_func_eq_to_fun to_simple_func_eq_to_fun\n\n",
 "to_Lp_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚› Â» -/\ntheorem to_Lp_zero : to_Lp (0 : Â«expr â†’â‚› Â» Î± E) zero_mem_â„’p = (0 : Lp.simple_func E p Î¼) :=\n  rfl\n#align to_Lp_zero to_Lp_zero\n\n",
 "to_Lp_to_simple_func":
 "theorem to_Lp_to_simple_func (f : Lp.simple_func E p Î¼) : to_Lp (to_simple_func f) (simple_func.mem_â„’p f) = f :=\n  simple_func.eq' (Classical.choose_spec f.2)\n#align to_Lp_to_simple_func to_Lp_to_simple_func\n\n",
 "to_Lp_sub":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚› Â» -/\ntheorem to_Lp_sub (f g : Â«expr â†’â‚› Â» Î± E) (hf : mem_â„’p f p Î¼) (hg : mem_â„’p g p Î¼) :\n    to_Lp (f - g) (hf.sub hg) = to_Lp f hf - to_Lp g hg :=\n  by\n  simp only [sub_eq_add_neg, â† to_Lp_neg, â† to_Lp_add]\n  rfl\n#align to_Lp_sub to_Lp_sub\n\n",
 "to_Lp_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚› Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\ntheorem to_Lp_smul (f : Â«expr â†’â‚› Â» Î± E) (hf : mem_â„’p f p Î¼) (c : ğ•œ) :\n    to_Lp (Â«expr â€¢ Â» c f) (hf.const_smul c) = Â«expr â€¢ Â» c (to_Lp f hf) :=\n  rfl\n#align to_Lp_smul to_Lp_smul\n\n",
 "to_Lp_one_eq_to_L1":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚› Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure_theory.L1 -/\ntheorem L1.simple_func.to_Lp_one_eq_to_L1 (f : Â«expr â†’â‚› Â» Î± E) (hf : integrable f Î¼) :\n    (Lp.simple_func.to_Lp f (mem_â„’p_one_iff_integrable.2 hf) : measure_theory.L1 Î± Î¼ E) = hf.to_L1 f :=\n  rfl\n#align L1.simple_func.to_Lp_one_eq_to_L1 L1.simple_func.to_Lp_one_eq_to_L1\n\n",
 "to_Lp_neg":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚› Â» -/\ntheorem to_Lp_neg (f : Â«expr â†’â‚› Â» Î± E) (hf : mem_â„’p f p Î¼) : to_Lp (-f) hf.neg = -to_Lp f hf :=\n  rfl\n#align to_Lp_neg to_Lp_neg\n\n",
 "to_Lp_eq_to_Lp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚› Â» -/\ntheorem to_Lp_eq_to_Lp (f : Â«expr â†’â‚› Â» Î± E) (hf : mem_â„’p f p Î¼) : (to_Lp f hf : Lp E p Î¼) = hf.to_Lp f :=\n  rfl\n#align to_Lp_eq_to_Lp to_Lp_eq_to_Lp\n\n",
 "to_Lp_eq_mk":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚› Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚˜[ ] Â» -/\ntheorem to_Lp_eq_mk (f : Â«expr â†’â‚› Â» Î± E) (hf : mem_â„’p f p Î¼) :\n    (to_Lp f hf : Â«expr â†’â‚˜[ ] Â» Î± Î¼ E) = ae_eq_fun.mk f f.ae_strongly_measurable :=\n  rfl\n#align to_Lp_eq_mk to_Lp_eq_mk\n\n",
 "to_Lp_add":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚› Â» -/\ntheorem to_Lp_add (f g : Â«expr â†’â‚› Â» Î± E) (hf : mem_â„’p f p Î¼) (hg : mem_â„’p g p Î¼) :\n    to_Lp (f + g) (hf.add hg) = to_Lp f hf + to_Lp g hg :=\n  rfl\n#align to_Lp_add to_Lp_add\n\n",
 "tendsto_approx_on_range_Lp_snorm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem tendsto_approx_on_range_Lp_snorm [borel_space E] {f : Î² â†’ E} (hp_ne_top : p â‰  ennreal.top) {Î¼ : measure Î²}\n    (fmeas : measurable f) [separable_space (range f âˆª {0} : set E)] (hf : snorm f p Î¼ < ennreal.top) :\n    tendsto (fun n => snorm (approx_on f fmeas (range f âˆª {0}) 0 (by simp) n - f) p Î¼) at_top ((nhds) 0) :=\n  by\n  refine' tendsto_approx_on_Lp_snorm fmeas _ hp_ne_top _ _\n  Â· apply eventually_of_forall\n    intro x\n    apply subset_closure\n    simp\n  Â· simpa using hf\n#align tendsto_approx_on_range_Lp_snorm tendsto_approx_on_range_Lp_snorm\n\n",
 "tendsto_approx_on_range_Lp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem tendsto_approx_on_range_Lp [borel_space E] {f : Î² â†’ E} [hp : fact (1 â‰¤ p)] (hp_ne_top : p â‰  ennreal.top)\n    {Î¼ : measure Î²} (fmeas : measurable f) [separable_space (range f âˆª {0} : set E)] (hf : mem_â„’p f p Î¼) :\n    tendsto (fun n => (mem_â„’p_approx_on_range fmeas hf n).to_Lp (approx_on f fmeas (range f âˆª {0}) 0 (by simp) n))\n      at_top ((nhds) (hf.to_Lp f)) :=\n  by simpa only [Lp.tendsto_Lp_iff_tendsto_â„’p''] using tendsto_approx_on_range_Lp_snorm hp_ne_top fmeas hf.2\n#align tendsto_approx_on_range_Lp tendsto_approx_on_range_Lp\n\n",
 "tendsto_approx_on_range_L1_nnnorm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ«â» , âˆ‚ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ«â» , âˆ‚ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–â‚ŠÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem tendsto_approx_on_range_L1_nnnorm [opens_measurable_space E] {f : Î² â†’ E} {Î¼ : measure Î²}\n    [separable_space (range f âˆª {0} : set E)] (fmeas : measurable f) (hf : integrable f Î¼) :\n    tendsto\n      (fun n =>\n        Â«exprâˆ«â» , âˆ‚ Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ«â» , âˆ‚ Â»\"\n          (Â«exprâ€– â€–â‚ŠÂ» (approx_on f fmeas (range f âˆª {0}) 0 (by simp) n x - f x)) Î¼)\n      at_top ((nhds) 0) :=\n  by\n  apply tendsto_approx_on_L1_nnnorm fmeas\n  Â· apply eventually_of_forall\n    intro x\n    apply subset_closure\n    simp\n  Â· simpa using hf.2\n#align tendsto_approx_on_range_L1_nnnorm tendsto_approx_on_range_L1_nnnorm\n\n",
 "tendsto_approx_on_Lp_snorm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ«â» , âˆ‚ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ«â» , âˆ‚ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–â‚ŠÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–â‚ŠÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰¤áµ[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–â‚ŠÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–â‚ŠÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ«â» , âˆ‚ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ«â» , âˆ‚ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–â‚ŠÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€áµ âˆ‚ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€áµ âˆ‚ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–â‚ŠÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€áµ âˆ‚ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€áµ âˆ‚ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem tendsto_approx_on_Lp_snorm [opens_measurable_space E] {f : Î² â†’ E} (hf : measurable f) {s : set E} {yâ‚€ : E}\n    (hâ‚€ : yâ‚€ âˆˆ s) [separable_space s] (hp_ne_top : p â‰  ennreal.top) {Î¼ : measure Î²}\n    (hÎ¼ :\n      Â«exprâˆ€áµ âˆ‚ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€áµ âˆ‚ , Â»\" Î¼\n        (f x âˆˆ closure s))\n    (hi : snorm (fun x => f x - yâ‚€) p Î¼ < ennreal.top) :\n    tendsto (fun n => snorm (approx_on f hf s yâ‚€ hâ‚€ n - f) p Î¼) at_top ((nhds) 0) :=\n  by\n  by_cases hp_zero : p = 0\n  Â· simpa only [hp_zero, snorm_exponent_zero] using tendsto_const_nhds\n  have hp : 0 < p.to_real := to_real_pos hp_zero hp_ne_top\n  suffices\n    tendsto\n      (fun n =>\n        Â«exprâˆ«â» , âˆ‚ Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ«â» , âˆ‚ Â»\"\n          (Â«exprâ€– â€–â‚ŠÂ» (approx_on f hf s yâ‚€ hâ‚€ n x - f x) ^ p.to_real) Î¼)\n      at_top ((nhds) 0)\n    by\n    simp only [snorm_eq_lintegral_rpow_nnnorm hp_zero hp_ne_top]\n    convert continuous_rpow_const.continuous_at.tendsto.comp this <;> simp [_root_.inv_pos.mpr hp]\n  -- We simply check the conditions of the Dominated Convergence Theorem:\n  -- (1) The function \"`p`-th power of distance between `f` and the approximation\" is measurable\n  have hF_meas : âˆ€ n, measurable fun x => (Â«exprâ€– â€–â‚ŠÂ» (approx_on f hf s yâ‚€ hâ‚€ n x - f x) : ennreal) ^ p.to_real := by\n    simpa only [â† edist_eq_coe_nnnorm_sub] using fun n =>\n      (approx_on f hf s yâ‚€ hâ‚€ n).measurable_bind (fun y x => edist y (f x) ^ p.to_real) fun y =>\n        (measurable_edist_right.comp hf).pow_const p.to_real\n  -- (2) The functions \"`p`-th power of distance between `f` and the approximation\" are uniformly\n  -- bounded, at any given point, by `Î» x, â€–f x - yâ‚€â€– ^ p.to_real`\n  have h_bound :\n    âˆ€ n,\n      Â«expr â‰¤áµ[ ] Â» (fun x => (Â«exprâ€– â€–â‚ŠÂ» (approx_on f hf s yâ‚€ hâ‚€ n x - f x) : ennreal) ^ p.to_real) Î¼ fun x =>\n        Â«exprâ€– â€–â‚ŠÂ» (f x - yâ‚€) ^ p.to_real :=\n    fun n => eventually_of_forall fun x => rpow_le_rpow (coe_mono (nnnorm_approx_on_le hf hâ‚€ x n)) to_real_nonneg\n  -- (3) The bounding function `Î» x, â€–f x - yâ‚€â€– ^ p.to_real` has finite integral\n  have h_fin :\n    Â«exprâˆ«â» , âˆ‚ Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ«â» , âˆ‚ Â»\"\n        (Â«exprâ€– â€–â‚ŠÂ» (f a - yâ‚€) ^ p.to_real) Î¼ â‰ \n      Â«exprâŠ¤Â» :=\n    (lintegral_rpow_nnnorm_lt_top_of_snorm_lt_top hp_zero hp_ne_top hi).ne\n  -- (4) The functions \"`p`-th power of distance between `f` and the approximation\" tend pointwise\n  -- to zero\n  have h_lim :\n    Â«exprâˆ€áµ âˆ‚ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€áµ âˆ‚ , Â»\" Î¼\n      (tendsto (fun n => (Â«exprâ€– â€–â‚ŠÂ» (approx_on f hf s yâ‚€ hâ‚€ n a - f a) : ennreal) ^ p.to_real) at_top ((nhds) 0)) :=\n    by\n    filter_upwards [hÎ¼] with a ha\n    have : tendsto (fun n => (approx_on f hf s yâ‚€ hâ‚€ n) a - f a) at_top ((nhds) (f a - f a)) :=\n      (tendsto_approx_on hf hâ‚€ ha).sub tendsto_const_nhds\n    convert continuous_rpow_const.continuous_at.tendsto.comp (tendsto_coe.mpr this.nnnorm)\n    simp [zero_rpow_of_pos hp]\n  -- Then we apply the Dominated Convergence Theorem\n  simpa using tendsto_lintegral_of_dominated_convergence _ hF_meas h_bound h_fin h_lim\n#align tendsto_approx_on_Lp_snorm tendsto_approx_on_Lp_snorm\n\n",
 "tendsto_approx_on_L1_nnnorm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€áµ âˆ‚ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€áµ âˆ‚ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ«â» , âˆ‚ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ«â» , âˆ‚ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–â‚ŠÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem tendsto_approx_on_L1_nnnorm [opens_measurable_space E] {f : Î² â†’ E} (hf : measurable f) {s : set E} {yâ‚€ : E}\n    (hâ‚€ : yâ‚€ âˆˆ s) [separable_space s] {Î¼ : measure Î²}\n    (hÎ¼ :\n      Â«exprâˆ€áµ âˆ‚ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€áµ âˆ‚ , Â»\" Î¼\n        (f x âˆˆ closure s))\n    (hi : has_finite_integral (fun x => f x - yâ‚€) Î¼) :\n    tendsto\n      (fun n =>\n        Â«exprâˆ«â» , âˆ‚ Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ«â» , âˆ‚ Â»\"\n          (Â«exprâ€– â€–â‚ŠÂ» (approx_on f hf s yâ‚€ hâ‚€ n x - f x)) Î¼)\n      at_top ((nhds) 0) :=\n  by\n  simpa [snorm_one_eq_lintegral_nnnorm] using\n    tendsto_approx_on_Lp_snorm hf hâ‚€ one_ne_top hÎ¼ (by simpa [snorm_one_eq_lintegral_nnnorm] using hi)\n#align tendsto_approx_on_L1_nnnorm tendsto_approx_on_L1_nnnorm\n\n",
 "sub_to_simple_func":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr =áµ[ ] Â» -/\ntheorem sub_to_simple_func (f g : Lp.simple_func E p Î¼) :\n    Â«expr =áµ[ ] Â» (to_simple_func (f - g)) Î¼ (to_simple_func f - to_simple_func g) :=\n  by\n  filter_upwards [to_simple_func_eq_to_fun (f - g), to_simple_func_eq_to_fun f, to_simple_func_eq_to_fun g,\n    Lp.coe_fn_sub (f : Lp E p Î¼) g] with _\n  simp only [add_subgroup.coe_sub, pi.sub_apply, â† coe_coe]\n  repeat' intro h; rw [h]\n#align sub_to_simple_func sub_to_simple_func\n\n",
 "strongly_measurable":
 "protected theorem strongly_measurable (f : Lp.simple_func E p Î¼) : strongly_measurable (to_simple_func f) :=\n  (to_simple_func f).strongly_measurable\n#align strongly_measurable strongly_measurable\n\n",
 "snorm'_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–â‚ŠÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–â‚ŠÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚› Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–â‚ŠÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\nprotected theorem snorm'_eq {p : exprâ„} (f : Â«expr â†’â‚› Â» Î± F) (Î¼ : measure Î±) :\n    snorm' f p Î¼ =\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" f.range\n          ((Â«exprâ€– â€–â‚ŠÂ» y : ennreal) ^ p * Î¼ (Â«expr â»Â¹' Â» f {y})) ^\n        (1 / p) :=\n  by\n  have h_map : (fun a => (Â«exprâ€– â€–â‚ŠÂ» (f a) : ennreal) ^ p) = f.map fun a : F => (Â«exprâ€– â€–â‚ŠÂ» a : ennreal) ^ p := by simp\n  rw [snorm', h_map, lintegral_eq_lintegral, map_lintegral]\n#align snorm'_eq snorm'_eq\n\n",
 "smul_to_simple_func":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr =áµ[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\ntheorem smul_to_simple_func (k : ğ•œ) (f : Lp.simple_func E p Î¼) :\n    Â«expr =áµ[ ] Â» (to_simple_func (Â«expr â€¢ Â» k f)) Î¼ (Â«expr â€¢ Â» k (to_simple_func f)) :=\n  by\n  filter_upwards [to_simple_func_eq_to_fun (Â«expr â€¢ Â» k f), to_simple_func_eq_to_fun f,\n    Lp.coe_fn_smul k (f : Lp E p Î¼)] with _\n  simp only [pi.smul_apply, coe_smul, â† coe_coe]\n  repeat' intro h; rw [h]\n#align smul_to_simple_func smul_to_simple_func\n\n",
 "norm_to_simple_func":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\ntheorem norm_to_simple_func [fact (1 â‰¤ p)] (f : Lp.simple_func E p Î¼) :\n    Â«exprâ€– â€–Â» f = ennreal.to_real (snorm (to_simple_func f) p Î¼) := by\n  simpa [to_Lp_to_simple_func] using norm_to_Lp (to_simple_func f) (simple_func.mem_â„’p f)\n#align norm_to_simple_func norm_to_simple_func\n\n",
 "norm_to_Lp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚› Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\ntheorem norm_to_Lp [fact (1 â‰¤ p)] (f : Â«expr â†’â‚› Â» Î± E) (hf : mem_â„’p f p Î¼) :\n    Â«exprâ€– â€–Â» (to_Lp f hf) = ennreal.to_real (snorm f p Î¼) :=\n  norm_to_Lp f hf\n#align norm_to_Lp norm_to_Lp\n\n",
 "norm_approx_on_zero_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\ntheorem norm_approx_on_zero_le [opens_measurable_space E] {f : Î² â†’ E} (hf : measurable f) {s : set E} (hâ‚€ : (0 : E) âˆˆ s)\n    [separable_space s] (x : Î²) (n : â„•) : Â«exprâ€– â€–Â» (approx_on f hf s 0 hâ‚€ n x) â‰¤ Â«exprâ€– â€–Â» (f x) + Â«exprâ€– â€–Â» (f x) :=\n  by\n  have := edist_approx_on_y0_le hf hâ‚€ x n\n  simp [edist_comm (0 : E), edist_eq_coe_nnnorm] at this\n  exact_mod_cast this\n#align norm_approx_on_zero_le norm_approx_on_zero_le\n\n",
 "norm_approx_on_yâ‚€_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\ntheorem norm_approx_on_yâ‚€_le [opens_measurable_space E] {f : Î² â†’ E} (hf : measurable f) {s : set E} {yâ‚€ : E}\n    (hâ‚€ : yâ‚€ âˆˆ s) [separable_space s] (x : Î²) (n : â„•) :\n    Â«exprâ€– â€–Â» (approx_on f hf s yâ‚€ hâ‚€ n x - yâ‚€) â‰¤ Â«exprâ€– â€–Â» (f x - yâ‚€) + Â«exprâ€– â€–Â» (f x - yâ‚€) :=\n  by\n  have := edist_approx_on_y0_le hf hâ‚€ x n\n  repeat' rw [edist_comm yâ‚€, edist_eq_coe_nnnorm_sub] at this\n  exact_mod_cast this\n#align norm_approx_on_yâ‚€_le norm_approx_on_yâ‚€_le\n\n",
 "nnnorm_approx_on_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–â‚ŠÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–â‚ŠÂ» -/\n/-\nCopyright (c) 2022 Zhouhang Zhou. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Zhouhang Zhou, Yury Kudryashov, Heather Macbeth\n-/\ntheorem nnnorm_approx_on_le [opens_measurable_space E] {f : Î² â†’ E} (hf : measurable f) {s : set E} {yâ‚€ : E}\n    (hâ‚€ : yâ‚€ âˆˆ s) [separable_space s] (x : Î²) (n : â„•) :\n    Â«exprâ€– â€–â‚ŠÂ» (approx_on f hf s yâ‚€ hâ‚€ n x - f x) â‰¤ Â«exprâ€– â€–â‚ŠÂ» (f x - yâ‚€) :=\n  by\n  have := edist_approx_on_le hf hâ‚€ x n\n  rw [edist_comm yâ‚€] at this\n  simp only [edist_nndist, nndist_eq_nnnorm] at this\n  exact_mod_cast this\n#align nnnorm_approx_on_le nnnorm_approx_on_le\n\n",
 "neg_to_simple_func":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr =áµ[ ] Â» -/\ntheorem neg_to_simple_func (f : Lp.simple_func E p Î¼) : Â«expr =áµ[ ] Â» (to_simple_func (-f)) Î¼ (-to_simple_func f) :=\n  by\n  filter_upwards [to_simple_func_eq_to_fun (-f), to_simple_func_eq_to_fun f, Lp.coe_fn_neg (f : Lp E p Î¼)] with _\n  simp only [pi.neg_apply, add_subgroup.coe_neg, â† coe_coe]\n  repeat' intro h; rw [h]\n#align neg_to_simple_func neg_to_simple_func\n\n",
 "mem_â„’p_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚› Â» -/\ntheorem mem_â„’p_zero (f : Â«expr â†’â‚› Â» Î± E) (Î¼ : measure Î±) : mem_â„’p f 0 Î¼ :=\n  mem_â„’p_zero_iff_ae_strongly_measurable.mpr f.ae_strongly_measurable\n#align mem_â„’p_zero mem_â„’p_zero\n\n",
 "mem_â„’p_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚› Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\ntheorem mem_â„’p_top (f : Â«expr â†’â‚› Â» Î± E) (Î¼ : measure Î±) : mem_â„’p f (ennreal.top) Î¼ :=\n  let âŸ¨C, hfCâŸ© := f.exists_forall_norm_le\n  mem_â„’p_top_of_bound f.ae_strongly_measurable C <| eventually_of_forall hfC\n#align mem_â„’p_top mem_â„’p_top\n\n",
 "mem_â„’p_of_is_finite_measure":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚› Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\ntheorem mem_â„’p_of_is_finite_measure (f : Â«expr â†’â‚› Â» Î± E) (p : ennreal) (Î¼ : measure Î±) [is_finite_measure Î¼] :\n    mem_â„’p f p Î¼ :=\n  let âŸ¨C, hfCâŸ© := f.exists_forall_norm_le\n  mem_â„’p.of_bound f.ae_strongly_measurable C <| eventually_of_forall hfC\n#align mem_â„’p_of_is_finite_measure mem_â„’p_of_is_finite_measure\n\n",
 "mem_â„’p_of_finite_measure_preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚› Â» -/\n/- ./././Mathport/Syntax/Translate/Basic.lean:632:2: warning: expanding binder collection (y Â«expr â‰  Â» 0) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\ntheorem mem_â„’p_of_finite_measure_preimage (p : ennreal) {f : Â«expr â†’â‚› Â» Î± E}\n    (hf : âˆ€ (y) (_ : y â‰  0), Î¼ (Â«expr â»Â¹' Â» f {y}) < ennreal.top) : mem_â„’p f p Î¼ :=\n  by\n  by_cases hp0 : p = 0\n  Â· rw [hp0, mem_â„’p_zero_iff_ae_strongly_measurable]\n    exact f.ae_strongly_measurable\n  by_cases hp_top : p = ennreal.top\n  Â· rw [hp_top]\n    exact mem_â„’p_top f Î¼\n  refine' âŸ¨f.ae_strongly_measurable, _âŸ©\n  rw [snorm_eq_snorm' hp0 hp_top, f.snorm'_eq]\n  refine' ennreal.rpow_lt_top_of_nonneg (by simp) (ennreal.sum_lt_top_iff.mpr fun y hy => _).ne\n  by_cases hy0 : y = 0\n  Â· simp [hy0, ennreal.to_real_pos hp0 hp_top]\n  Â· refine' ennreal.mul_lt_top _ (hf y hy0).ne\n    exact (ennreal.rpow_lt_top_of_nonneg ennreal.to_real_nonneg ennreal.coe_ne_top).ne\n#align mem_â„’p_of_finite_measure_preimage mem_â„’p_of_finite_measure_preimage\n\n",
 "mem_â„’p_iff_integrable":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚› Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\ntheorem mem_â„’p_iff_integrable {f : Â«expr â†’â‚› Â» Î± E} (hp_pos : p â‰  0) (hp_ne_top : p â‰  ennreal.top) :\n    mem_â„’p f p Î¼ â†” integrable f Î¼ :=\n  (mem_â„’p_iff hp_pos hp_ne_top).trans integrable_iff.symm\n#align mem_â„’p_iff_integrable mem_â„’p_iff_integrable\n\n",
 "mem_â„’p_iff_fin_meas_supp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚› Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\ntheorem mem_â„’p_iff_fin_meas_supp {f : Â«expr â†’â‚› Â» Î± E} (hp_pos : p â‰  0) (hp_ne_top : p â‰  ennreal.top) :\n    mem_â„’p f p Î¼ â†” f.fin_meas_supp Î¼ :=\n  (mem_â„’p_iff hp_pos hp_ne_top).trans fin_meas_supp_iff.symm\n#align mem_â„’p_iff_fin_meas_supp mem_â„’p_iff_fin_meas_supp\n\n",
 "mem_â„’p_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚› Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Basic.lean:632:2: warning: expanding binder collection (y Â«expr â‰  Â» 0) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\ntheorem mem_â„’p_iff {f : Â«expr â†’â‚› Â» Î± E} (hp_pos : p â‰  0) (hp_ne_top : p â‰  ennreal.top) :\n    mem_â„’p f p Î¼ â†” âˆ€ (y) (_ : y â‰  0), Î¼ (Â«expr â»Â¹' Â» f {y}) < ennreal.top :=\n  âŸ¨fun h => measure_preimage_lt_top_of_mem_â„’p hp_pos hp_ne_top f h, fun h => mem_â„’p_of_finite_measure_preimage p hâŸ©\n#align mem_â„’p_iff mem_â„’p_iff\n\n",
 "mem_â„’p_approx_on_range":
 "theorem mem_â„’p_approx_on_range [borel_space E] {f : Î² â†’ E} {Î¼ : measure Î²} (fmeas : measurable f)\n    [separable_space (range f âˆª {0} : set E)] (hf : mem_â„’p f p Î¼) (n : â„•) :\n    mem_â„’p (approx_on f fmeas (range f âˆª {0}) 0 (by simp) n) p Î¼ :=\n  mem_â„’p_approx_on fmeas hf (by simp) zero_mem_â„’p n\n#align mem_â„’p_approx_on_range mem_â„’p_approx_on_range\n\n",
 "mem_â„’p_approx_on":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€áµ âˆ‚ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€áµ âˆ‚ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\ntheorem mem_â„’p_approx_on [borel_space E] {f : Î² â†’ E} {Î¼ : measure Î²} (fmeas : measurable f) (hf : mem_â„’p f p Î¼)\n    {s : set E} {yâ‚€ : E} (hâ‚€ : yâ‚€ âˆˆ s) [separable_space s] (hiâ‚€ : mem_â„’p (fun x => yâ‚€) p Î¼) (n : â„•) :\n    mem_â„’p (approx_on f fmeas s yâ‚€ hâ‚€ n) p Î¼ :=\n  by\n  refine' âŸ¨(approx_on f fmeas s yâ‚€ hâ‚€ n).ae_strongly_measurable, _âŸ©\n  suffices snorm (fun x => approx_on f fmeas s yâ‚€ hâ‚€ n x - yâ‚€) p Î¼ < Â«exprâŠ¤Â»\n    by\n    have : mem_â„’p (fun x => approx_on f fmeas s yâ‚€ hâ‚€ n x - yâ‚€) p Î¼ :=\n      âŸ¨(approx_on f fmeas s yâ‚€ hâ‚€ n - const Î² yâ‚€).ae_strongly_measurable, thisâŸ©\n    convert snorm_add_lt_top this hiâ‚€\n    ext x\n    simp\n  have hf' : mem_â„’p (fun x => Â«exprâ€– â€–Â» (f x - yâ‚€)) p Î¼ :=\n    by\n    have h_meas : measurable fun x => Â«exprâ€– â€–Â» (f x - yâ‚€) :=\n      by\n      simp only [â† dist_eq_norm]\n      exact (continuous_id.dist continuous_const).measurable.comp fmeas\n    refine' âŸ¨h_meas.ae_measurable.ae_strongly_measurable, _âŸ©\n    rw [snorm_norm]\n    convert snorm_add_lt_top hf hiâ‚€.neg\n    ext x\n    simp [sub_eq_add_neg]\n  have :\n    Â«exprâˆ€áµ âˆ‚ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€áµ âˆ‚ , Â»\" Î¼\n      (Â«exprâ€– â€–Â» (approx_on f fmeas s yâ‚€ hâ‚€ n x - yâ‚€) â‰¤ Â«exprâ€– â€–Â» (Â«exprâ€– â€–Â» (f x - yâ‚€) + Â«exprâ€– â€–Â» (f x - yâ‚€))) :=\n    by\n    refine' eventually_of_forall _\n    intro x\n    convert norm_approx_on_yâ‚€_le fmeas hâ‚€ x n\n    rw [real.norm_eq_abs, abs_of_nonneg]\n    exact add_nonneg (norm_nonneg _) (norm_nonneg _)\n  calc\n    snorm (fun x => approx_on f fmeas s yâ‚€ hâ‚€ n x - yâ‚€) p Î¼ â‰¤\n        snorm (fun x => Â«exprâ€– â€–Â» (f x - yâ‚€) + Â«exprâ€– â€–Â» (f x - yâ‚€)) p Î¼ :=\n      snorm_mono_ae this\n    _ < Â«exprâŠ¤Â» := snorm_add_lt_top hf' hf'\n    \n#align mem_â„’p_approx_on mem_â„’p_approx_on\n\n",
 "mem_â„’p":
 "/-- `to_simple_func f` satisfies the predicate `mem_â„’p`. -/\nprotected theorem mem_â„’p (f : Lp.simple_func E p Î¼) : mem_â„’p (to_simple_func f) p Î¼ :=\n  mem_â„’p.ae_eq (to_simple_func_eq_to_fun f).symm <| mem_Lp_iff_mem_â„’p.mp (f : Lp E p Î¼).2\n#align mem_â„’p mem_â„’p\n\n",
 "measure_support_lt_top_of_mem_â„’p":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚› Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\ntheorem measure_support_lt_top_of_mem_â„’p (f : Â«expr â†’â‚› Â» Î± E) (hf : mem_â„’p f p Î¼) (hp_ne_zero : p â‰  0)\n    (hp_ne_top : p â‰  ennreal.top) : Î¼ (support f) < ennreal.top :=\n  f.measure_support_lt_top ((mem_â„’p_iff hp_ne_zero hp_ne_top).mp hf)\n#align measure_support_lt_top_of_mem_â„’p measure_support_lt_top_of_mem_â„’p\n\n",
 "measure_support_lt_top_of_integrable":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚› Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\ntheorem measure_support_lt_top_of_integrable (f : Â«expr â†’â‚› Â» Î± E) (hf : integrable f Î¼) : Î¼ (support f) < ennreal.top :=\n  f.measure_support_lt_top (integrable_iff.mp hf)\n#align measure_support_lt_top_of_integrable measure_support_lt_top_of_integrable\n\n",
 "measure_support_lt_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚› Â» -/\n/- ./././Mathport/Syntax/Translate/Basic.lean:632:2: warning: expanding binder collection (y Â«expr â‰  Â» 0) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\ntheorem measure_support_lt_top [Zero Î²] (f : Â«expr â†’â‚› Â» Î± Î²)\n    (hf : âˆ€ (y) (_ : y â‰  0), Î¼ (Â«expr â»Â¹' Â» f {y}) < ennreal.top) : Î¼ (support f) < ennreal.top :=\n  by\n  rw [support_eq]\n  refine' (measure_bUnion_finset_le _ _).trans_lt (ennreal.sum_lt_top_iff.mpr fun y hy => _)\n  rw [Finset.mem_filter] at hy\n  exact hf y hy.2\n#align measure_support_lt_top measure_support_lt_top\n\n",
 "measure_preimage_lt_top_of_mem_â„’p":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚› Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\ntheorem measure_preimage_lt_top_of_mem_â„’p (hp_pos : p â‰  0) (hp_ne_top : p â‰  ennreal.top) (f : Â«expr â†’â‚› Â» Î± E)\n    (hf : mem_â„’p f p Î¼) (y : E) (hy_ne : y â‰  0) : Î¼ (Â«expr â»Â¹' Â» f {y}) < ennreal.top :=\n  by\n  have hp_pos_real : 0 < p.to_real := ennreal.to_real_pos hp_pos hp_ne_top\n  have hf_snorm := mem_â„’p.snorm_lt_top hf\n  rw [snorm_eq_snorm' hp_pos hp_ne_top, f.snorm'_eq, â†\n    @ennreal.lt_rpow_one_div_iff _ _ (1 / p.to_real) (by simp [hp_pos_real]),\n    @ennreal.top_rpow_of_pos (1 / (1 / p.to_real)) (by simp [hp_pos_real]), ennreal.sum_lt_top_iff] at hf_snorm\n  by_cases hyf : y âˆˆ f.range\n  swap\n  Â· suffices h_empty : Â«expr â»Â¹' Â» f {y} = âˆ…\n    Â· rw [h_empty, measure_empty]\n      exact ennreal.coe_lt_top\n    ext1 x\n    rw [Set.mem_preimage, Set.mem_singleton_iff, mem_empty_iff_false, iff_false_iff]\n    refine' fun hxy => hyf _\n    rw [mem_range, Set.mem_range]\n    exact âŸ¨x, hxyâŸ©\n  specialize hf_snorm y hyf\n  rw [ennreal.mul_lt_top_iff] at hf_snorm\n  cases hf_snorm\n  Â· exact hf_snorm.2\n  cases hf_snorm\n  Â· refine' absurd _ hy_ne\n    simpa [hp_pos_real] using hf_snorm\n  Â· simp [hf_snorm]\n#align measure_preimage_lt_top_of_mem_â„’p measure_preimage_lt_top_of_mem_â„’p\n\n",
 "measure_preimage_lt_top_of_integrable":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚› Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\ntheorem measure_preimage_lt_top_of_integrable (f : Â«expr â†’â‚› Â» Î± E) (hf : integrable f Î¼) {x : E} (hx : x â‰  0) :\n    Î¼ (Â«expr â»Â¹' Â» f {x}) < ennreal.top :=\n  integrable_iff.mp hf x hx\n#align measure_preimage_lt_top_of_integrable measure_preimage_lt_top_of_integrable\n\n",
 "measure_lt_top_of_mem_â„’p_indicator":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\ntheorem measure_lt_top_of_mem_â„’p_indicator (hp_pos : p â‰  0) (hp_ne_top : p â‰  ennreal.top) {c : E} (hc : c â‰  0)\n    {s : set Î±} (hs : measurable_set s) (hcs : mem_â„’p ((const Î± c).piecewise s hs (const Î± 0)) p Î¼) : Î¼ s < Â«exprâŠ¤Â» :=\n  by\n  have : function.support (const Î± c) = Set.univ := function.support_const hc\n  simpa only [mem_â„’p_iff_fin_meas_supp hp_pos hp_ne_top, fin_meas_supp_iff_support, support_indicator, Set.inter_univ,\n    this] using hcs\n#align measure_lt_top_of_mem_â„’p_indicator measure_lt_top_of_mem_â„’p_indicator\n\n",
 "measurable":
 "/-- `(to_simple_func f)` is measurable. -/\n@[measurability]\nprotected theorem measurable [measurable_space E] (f : Lp.simple_func E p Î¼) : measurable (to_simple_func f) :=\n  (to_simple_func f).measurable\n#align measurable measurable\n\n",
 "integrable_pair":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚› Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚› Â» -/\ntheorem integrable_pair {f : Â«expr â†’â‚› Â» Î± E} {g : Â«expr â†’â‚› Â» Î± F} :\n    integrable f Î¼ â†’ integrable g Î¼ â†’ integrable (pair f g) Î¼ := by\n  simpa only [integrable_iff_fin_meas_supp] using fin_meas_supp.pair\n#align integrable_pair integrable_pair\n\n",
 "integrable_of_is_finite_measure":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚› Â» -/\ntheorem integrable_of_is_finite_measure [is_finite_measure Î¼] (f : Â«expr â†’â‚› Â» Î± E) : integrable f Î¼ :=\n  mem_â„’p_one_iff_integrable.mp (f.mem_â„’p_of_is_finite_measure 1 Î¼)\n#align integrable_of_is_finite_measure integrable_of_is_finite_measure\n\n",
 "integrable_iff_fin_meas_supp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚› Â» -/\ntheorem integrable_iff_fin_meas_supp {f : Â«expr â†’â‚› Â» Î± E} : integrable f Î¼ â†” f.fin_meas_supp Î¼ :=\n  integrable_iff.trans fin_meas_supp_iff.symm\n#align integrable_iff_fin_meas_supp integrable_iff_fin_meas_supp\n\n",
 "integrable_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚› Â» -/\n/- ./././Mathport/Syntax/Translate/Basic.lean:632:2: warning: expanding binder collection (y Â«expr â‰  Â» 0) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\ntheorem integrable_iff {f : Â«expr â†’â‚› Â» Î± E} : integrable f Î¼ â†” âˆ€ (y) (_ : y â‰  0), Î¼ (Â«expr â»Â¹' Â» f {y}) < ennreal.top :=\n  mem_â„’p_one_iff_integrable.symm.trans <| mem_â„’p_iff ennreal.zero_lt_one.ne' ennreal.coe_ne_top\n#align integrable_iff integrable_iff\n\n",
 "integrable_approx_on_range":
 "theorem integrable_approx_on_range [borel_space E] {f : Î² â†’ E} {Î¼ : measure Î²} (fmeas : measurable f)\n    [separable_space (range f âˆª {0} : set E)] (hf : integrable f Î¼) (n : â„•) :\n    integrable (approx_on f fmeas (range f âˆª {0}) 0 (by simp) n) Î¼ :=\n  integrable_approx_on fmeas hf _ (integrable_zero _ _ _) n\n#align integrable_approx_on_range integrable_approx_on_range\n\n",
 "integrable_approx_on":
 "theorem integrable_approx_on [borel_space E] {f : Î² â†’ E} {Î¼ : measure Î²} (fmeas : measurable f) (hf : integrable f Î¼)\n    {s : set E} {yâ‚€ : E} (hâ‚€ : yâ‚€ âˆˆ s) [separable_space s] (hiâ‚€ : integrable (fun x => yâ‚€) Î¼) (n : â„•) :\n    integrable (approx_on f fmeas s yâ‚€ hâ‚€ n) Î¼ :=\n  by\n  rw [â† mem_â„’p_one_iff_integrable] at hf hiâ‚€âŠ¢\n  exact mem_â„’p_approx_on fmeas hf hâ‚€ hiâ‚€ n\n#align integrable_approx_on integrable_approx_on\n\n",
 "integrable":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚â‚›[ ] Â» -/\nprotected theorem L1.simple_func.integrable (f : Â«expr â†’â‚â‚›[ ] Â» Î± Î¼ E) :\n    integrable (Lp.simple_func.to_simple_func f) Î¼ :=\n  by\n  rw [â† mem_â„’p_one_iff_integrable]\n  exact Lp.simple_func.mem_â„’p f\n#align L1.simple_func.integrable L1.simple_func.integrable\n\n",
 "induction":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure_theory.L1 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr =áµ[ ] Â» -/\n/-- To prove something for an arbitrary integrable function in a normed group,\nit suffices to show that\n* the property holds for (multiples of) characteristic functions;\n* is closed under addition;\n* the set of functions in the `LÂ¹` space for which the property holds is closed.\n* the property is closed under the almost-everywhere equal relation.\n\nIt is possible to make the hypotheses in the induction steps a bit stronger, and such conditions\ncan be added once we need them (for example in `h_add` it is only necessary to consider the sum of\na simple function with a multiple of a characteristic function and that the intersection\nof their images is a subset of `{0}`).\n-/\n@[elab_as_elim]\ntheorem integrable.induction (P : (Î± â†’ E) â†’ Prop)\n    (h_ind : âˆ€ (c : E) â¦ƒsâ¦„, measurable_set s â†’ Î¼ s < ennreal.top â†’ P (s.indicator fun _ => c))\n    (h_add :\n      âˆ€ â¦ƒf g : Î± â†’ Eâ¦„, Disjoint (support f) (support g) â†’ integrable f Î¼ â†’ integrable g Î¼ â†’ P f â†’ P g â†’ P (f + g))\n    (h_closed : is_closed { f : measure_theory.L1 Î± Î¼ E | P f })\n    (h_ae : âˆ€ â¦ƒf gâ¦„, Â«expr =áµ[ ] Â» f Î¼ g â†’ integrable f Î¼ â†’ P f â†’ P g) : âˆ€ â¦ƒf : Î± â†’ Eâ¦„ (hf : integrable f Î¼), P f :=\n  by\n  simp only [â† mem_â„’p_one_iff_integrable] at *\n  exact mem_â„’p.induction one_ne_top P h_ind h_add h_closed h_ae\n#align integrable.induction integrable.induction\n\n",
 "exists_simple_func_nonneg_ae_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰¤áµ[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á¶œÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á¶œÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr =áµ[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚› Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr =áµ[ ] Â» -/\ntheorem exists_simple_func_nonneg_ae_eq {f : Lp.simple_func G p Î¼} (hf : 0 â‰¤ f) :\n    âˆƒ f' : Â«expr â†’â‚› Â» Î± G, 0 â‰¤ f' âˆ§ Â«expr =áµ[ ] Â» f Î¼ f' :=\n  by\n  rw [â† Lp.simple_func.coe_fn_nonneg] at hf\n  have hf_ae : Â«expr â‰¤áµ[ ] Â» 0 Î¼ (simple_func.to_simple_func f) :=\n    by\n    filter_upwards [to_simple_func_eq_to_fun f, hf] with _ h1 _\n    rwa [h1]\n  let s := Â«expr á¶œÂ» (to_measurable Î¼ { x | Â¬0 â‰¤ simple_func.to_simple_func f x })\n  have hs_zero : Î¼ (Â«expr á¶œÂ» s) = 0 := by\n    rw [compl_compl, measure_to_measurable]\n    rwa [eventually_le, ae_iff] at hf_ae\n  have hfs_nonneg : âˆ€ x âˆˆ s, 0 â‰¤ simple_func.to_simple_func f x :=\n    by\n    intro x hxs\n    rw [mem_compl_iff] at hxs\n    have hx' : x âˆ‰ { a : Î± | Â¬0 â‰¤ simple_func.to_simple_func f a } := fun h => hxs (subset_to_measurable Î¼ _ h)\n    rwa [Set.nmem_setOf_iff, not_not] at hx'\n  let f' :=\n    simple_func.piecewise s (measurable_set_to_measurable Î¼ _).compl (simple_func.to_simple_func f)\n      (simple_func.const Î± (0 : G))\n  refine' âŸ¨f', fun x => _, _âŸ©\n  Â· rw [simple_func.piecewise_apply]\n    by_cases hxs : x âˆˆ s\n    Â· simp only [hxs, hfs_nonneg x hxs, if_true, pi.zero_apply, simple_func.coe_zero]\n    Â· simp only [hxs, simple_func.const_zero, if_false]\n  Â· rw [simple_func.coe_piecewise]\n    have : Â«expr =áµ[ ] Â» s Î¼ univ := by\n      rw [ae_eq_set]\n      simp only [true_and_iff, measure_empty, eq_self_iff_true, diff_univ, â† compl_eq_univ_diff]\n      exact hs_zero\n    refine' eventually_eq.trans (to_simple_func_eq_to_fun f).symm _\n    refine' eventually_eq.trans _ (piecewise_ae_eq_of_ae_eq_set this.symm)\n    simp only [simple_func.const_zero, indicator_univ, piecewise_eq_indicator, simple_func.coe_zero]\n#align exists_simple_func_nonneg_ae_eq exists_simple_func_nonneg_ae_eq\n\n",
 "exists_forall_norm_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚› Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\ntheorem exists_forall_norm_le (f : Â«expr â†’â‚› Â» Î± F) : âˆƒ C, âˆ€ x, Â«exprâ€– â€–Â» (f x) â‰¤ C :=\n  exists_forall_le (f.map fun x => Â«exprâ€– â€–Â» x)\n#align exists_forall_norm_le exists_forall_norm_le\n\n",
 "eq'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚˜[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚˜[ ] Â» -/\nprotected theorem eq' {f g : Lp.simple_func E p Î¼} : (f : Â«expr â†’â‚˜[ ] Â» Î± Î¼ E) = (g : Â«expr â†’â‚˜[ ] Â» Î± Î¼ E) â†’ f = g :=\n  subtype.eq âˆ˜ subtype.eq\n#align eq' eq'\n\n",
 "dense_range_coe_simple_func_nonneg_to_Lp_nonneg":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰¤áµ[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\ntheorem dense_range_coe_simple_func_nonneg_to_Lp_nonneg [hp : fact (1 â‰¤ p)] (hp_ne_top : p â‰  ennreal.top) :\n    dense_range (coe_simple_func_nonneg_to_Lp_nonneg p Î¼ G) :=\n  by\n  borelize G\n  intro g\n  rw [mem_closure_iff_seq_limit]\n  have hg_mem_â„’p : mem_â„’p g p Î¼ := Lp.mem_â„’p g\n  have zero_mem : (0 : G) âˆˆ (range g âˆª {0} : set G) âˆ© { y | 0 â‰¤ y } := by\n    simp only [union_singleton, mem_inter_iff, mem_insert_iff, eq_self_iff_true, true_or_iff, mem_set_of_eq, le_refl,\n      and_self_iff]\n  have : separable_space ((range g âˆª {0}) âˆ© { y | 0 â‰¤ y } : set G) :=\n    by\n    apply is_separable.separable_space\n    apply is_separable.mono _ (Set.inter_subset_left _ _)\n    exact (Lp.strongly_measurable (g : Lp G p Î¼)).is_separable_range.union (finite_singleton _).is_separable\n  have g_meas : measurable g := (Lp.strongly_measurable (g : Lp G p Î¼)).measurable\n  let x n := simple_func.approx_on g g_meas ((range g âˆª {0}) âˆ© { y | 0 â‰¤ y }) 0 zero_mem n\n  have hx_nonneg : âˆ€ n, 0 â‰¤ x n := by\n    intro n a\n    change x n a âˆˆ { y : G | 0 â‰¤ y }\n    have A : (range g âˆª {0} : set G) âˆ© { y | 0 â‰¤ y } âŠ† { y | 0 â‰¤ y } := inter_subset_right _ _\n    apply A\n    exact simple_func.approx_on_mem g_meas _ n a\n  have hx_mem_â„’p : âˆ€ n, mem_â„’p (x n) p Î¼ :=\n    simple_func.mem_â„’p_approx_on _ hg_mem_â„’p _ âŸ¨ae_strongly_measurable_const, by simpâŸ©\n  have h_to_Lp := fun n => mem_â„’p.coe_fn_to_Lp (hx_mem_â„’p n)\n  have hx_nonneg_Lp : âˆ€ n, 0 â‰¤ to_Lp (x n) (hx_mem_â„’p n) :=\n    by\n    intro n\n    rw [â† Lp.simple_func.coe_fn_le, coe_fn_coe_base' (simple_func.to_Lp (x n) _), Lp.simple_func.to_Lp_eq_to_Lp]\n    have h0 := Lp.simple_func.coe_fn_zero p Î¼ G\n    filter_upwards [Lp.simple_func.coe_fn_zero p Î¼ G, h_to_Lp n] with a ha0 ha_to_Lp\n    rw [ha0, ha_to_Lp]\n    exact hx_nonneg n a\n  have hx_tendsto : tendsto (fun n : â„• => snorm (x n - g) p Î¼) at_top ((nhds) 0) :=\n    by\n    apply simple_func.tendsto_approx_on_Lp_snorm g_meas zero_mem hp_ne_top\n    Â· have hg_nonneg : Â«expr â‰¤áµ[ ] Â» 0 Î¼ g := (Lp.coe_fn_nonneg _).mpr g.2\n      refine' hg_nonneg.mono fun a ha => subset_closure _\n      simpa using ha\n    Â· simp_rw [sub_zero]\n      exact hg_mem_â„’p.snorm_lt_top\n  refine'\n    âŸ¨fun n => (coe_simple_func_nonneg_to_Lp_nonneg p Î¼ G) âŸ¨to_Lp (x n) (hx_mem_â„’p n), hx_nonneg_Lp nâŸ©, fun n =>\n      mem_range_self _, _âŸ©\n  suffices tendsto (fun n : â„• => â†‘(to_Lp (x n) (hx_mem_â„’p n))) at_top ((nhds) (g : Lp G p Î¼))\n    by\n    rw [tendsto_iff_dist_tendsto_zero] at thisâŠ¢\n    simp_rw [subtype.dist_eq]\n    convert this\n  rw [Lp.tendsto_Lp_iff_tendsto_â„’p']\n  convert hx_tendsto\n  refine' funext fun n => snorm_congr_ae (eventually_eq.sub _ _)\n  Â· rw [Lp.simple_func.to_Lp_eq_to_Lp]\n    exact h_to_Lp n\n  Â· rw [â† coe_fn_coe_base]\n#align dense_range_coe_simple_func_nonneg_to_Lp_nonneg dense_range_coe_simple_func_nonneg_to_Lp_nonneg\n\n",
 "dense_range":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\nprotected theorem dense_range (hp_ne_top : p â‰  ennreal.top) : dense_range (coe : Lp.simple_func E p Î¼ â†’ Lp E p Î¼) :=\n  (simple_func.dense_inducing hp_ne_top).dense\n#align dense_range dense_range\n\n",
 "dense_inducing":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\nprotected theorem dense_inducing (hp_ne_top : p â‰  ennreal.top) :\n    dense_inducing (coe : Lp.simple_func E p Î¼ â†’ Lp E p Î¼) :=\n  (simple_func.dense_embedding hp_ne_top).to_dense_inducing\n#align dense_inducing dense_inducing\n\n",
 "dense_embedding":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\nprotected theorem dense_embedding (hp_ne_top : p â‰  ennreal.top) :\n    dense_embedding (coe : Lp.simple_func E p Î¼ â†’ Lp E p Î¼) :=\n  by\n  borelize E\n  apply simple_func.uniform_embedding.dense_embedding\n  intro f\n  rw [mem_closure_iff_seq_limit]\n  have hfi' : mem_â„’p f p Î¼ := Lp.mem_â„’p f\n  haveI : separable_space (range f âˆª {0} : set E) := (Lp.strongly_measurable f).separable_space_range_union_singleton\n  refine'\n    âŸ¨fun n =>\n      â†‘(to_Lp (simple_func.approx_on f (Lp.strongly_measurable f).measurable (range f âˆª {0}) 0 (by simp) n)\n          (simple_func.mem_â„’p_approx_on_range (Lp.strongly_measurable f).measurable hfi' n)),\n      fun n => mem_range_self _, _âŸ©\n  convert simple_func.tendsto_approx_on_range_Lp hp_ne_top (Lp.strongly_measurable f).measurable hfi'\n  rw [to_Lp_coe_fn f (Lp.mem_â„’p f)]\n#align dense_embedding dense_embedding\n\n",
 "coe_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n@[simp, norm_cast]\ntheorem coe_smul (c : ğ•œ) (f : Lp.simple_func E p Î¼) :\n    ((Â«expr â€¢ Â» c f : Lp.simple_func E p Î¼) : Lp E p Î¼) = Â«expr â€¢ Â» c (f : Lp E p Î¼) :=\n  rfl\n#align coe_smul coe_smul\n\n",
 "coe_indicator_const":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n@[simp]\ntheorem coe_indicator_const {s : set Î±} (hs : measurable_set s) (hÎ¼s : Î¼ s â‰  ennreal.top) (c : E) :\n    (â†‘(indicator_const p hs hÎ¼s c) : Lp E p Î¼) = indicator_const_Lp p hs hÎ¼s c :=\n  rfl\n#align coe_indicator_const coe_indicator_const\n\n",
 "coe_fn_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr =áµ[ ] Â» -/\ntheorem coe_fn_zero : Â«expr =áµ[ ] Â» (0 : Lp.simple_func G p Î¼) Î¼ (0 : Î± â†’ G) :=\n  Lp.coe_fn_zero _ _ _\n#align coe_fn_zero coe_fn_zero\n\n",
 "coe_fn_nonneg":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr =áµ[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰¤áµ[ ] Â» -/\ntheorem coe_fn_nonneg (f : Lp.simple_func G p Î¼) : Â«expr â‰¤áµ[ ] Â» 0 Î¼ f â†” 0 â‰¤ f :=\n  by\n  rw [â† Lp.simple_func.coe_fn_le]\n  have h0 : Â«expr =áµ[ ] Â» (0 : Lp.simple_func G p Î¼) Î¼ (0 : Î± â†’ G) := Lp.simple_func.coe_fn_zero p Î¼ G\n  constructor <;> intro h <;> filter_upwards [h, h0] with _ _ h2\n  Â· rwa [h2]\n  Â· rwa [â† h2]\n#align coe_fn_nonneg coe_fn_nonneg\n\n",
 "coe_fn_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰¤áµ[ ] Â» -/\ntheorem coe_fn_le (f g : Lp.simple_func G p Î¼) : Â«expr â‰¤áµ[ ] Â» f Î¼ g â†” f â‰¤ g := by\n  rw [â† Subtype.coe_le_coe, â† Lp.coe_fn_le, coe_fn_coe_base', coe_fn_coe_base' g]\n#align coe_fn_le coe_fn_le\n\n",
 "coe_coe":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‡‘ Â» -/\n@[norm_cast]\ntheorem coe_coe (f : Lp.simple_func E p Î¼) : Â«exprâ‡‘ Â» (f : Lp E p Î¼) = f :=\n  rfl\n#align coe_coe coe_coe\n\n",
 "ae_strongly_measurable":
 "protected theorem ae_strongly_measurable (f : Lp.simple_func E p Î¼) : ae_strongly_measurable (to_simple_func f) Î¼ :=\n  (simple_func.strongly_measurable f).ae_strongly_measurable\n#align ae_strongly_measurable ae_strongly_measurable\n\n",
 "ae_measurable":
 "@[measurability]\nprotected theorem ae_measurable [measurable_space E] (f : Lp.simple_func E p Î¼) : ae_measurable (to_simple_func f) Î¼ :=\n  (simple_func.measurable f).ae_measurable\n#align ae_measurable ae_measurable\n\n",
 "add_to_simple_func":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr =áµ[ ] Â» -/\ntheorem add_to_simple_func (f g : Lp.simple_func E p Î¼) :\n    Â«expr =áµ[ ] Â» (to_simple_func (f + g)) Î¼ (to_simple_func f + to_simple_func g) :=\n  by\n  filter_upwards [to_simple_func_eq_to_fun (f + g), to_simple_func_eq_to_fun f, to_simple_func_eq_to_fun g,\n    Lp.coe_fn_add (f : Lp E p Î¼) g] with _\n  simp only [â† coe_coe, add_subgroup.coe_add, pi.add_apply]\n  iterate 4 intro h; rw [h]\n#align add_to_simple_func add_to_simple_func\n\n"}