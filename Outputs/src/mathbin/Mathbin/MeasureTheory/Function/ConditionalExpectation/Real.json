{"uniform_integrable_condexp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure_theory.condexp -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure_theory.condexp -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure_theory.condexp -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure_theory.condexp -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure_theory.condexp -/\n/-- Given a integrable function `g`, the conditional expectations of `g` with respect to\na sequence of sub-σ-algebras is uniformly integrable. -/\ntheorem integrable.uniform_integrable_condexp {ι : Type _} [FiniteMeasure μ] {g : α → exprℝ} (hint : integrable g μ)\n    {ℱ : ι → MeasurableSpace α} (hℱ : ∀ i, ℱ i ≤ m0) :\n    uniform_integrable (fun i => measure_theory.condexp μ g (ℱ i)) 1 μ :=\n  by\n  have hmeas : ∀ n, ∀ C, MeasurableSet { x | C ≤ «expr‖ ‖₊» ((measure_theory.condexp μ g (ℱ n)) x) } := fun n C =>\n    measurable_set_le measurable_const (strongly_measurable_condexp.mono (hℱ n)).measurable.nnnorm\n  have hg : mem_ℒp g 1 μ := mem_ℒp_one_iff_integrable.2 hint\n  refine'\n    uniform_integrable_of le_rfl ENNReal.one_ne_top\n      (fun n => (strongly_measurable_condexp.mono (hℱ n)).ae_strongly_measurable) fun ε hε => _\n  by_cases hne : snorm g 1 μ = 0\n  · rw [snorm_eq_zero_iff hg.1 one_ne_zero] at hne\n    refine'\n      ⟨0, fun n =>\n        (le_of_eq <|\n              (snorm_eq_zero_iff\n                    ((strongly_measurable_condexp.mono (hℱ n)).ae_strongly_measurable.indicator (hmeas n 0))\n                    one_ne_zero).2\n                _).trans\n          (zero_le _)⟩\n    filter_upwards [@condexp_congr_ae _ _ _ _ _ (ℱ n) m0 μ _ _ hne]with x hx\n    simp only [zero_le', Set.setOf_true, Set.indicator_univ, Pi.zero_apply, hx, condexp_zero]\n  obtain ⟨δ, hδ, h⟩ := hg.snorm_indicator_le μ le_rfl ENNReal.one_ne_top hε\n  set C : nnreal := ⟨δ, hδ.le⟩⁻¹ * (snorm g 1 μ).to_nnreal with hC\n  have hCpos : 0 < C := mul_pos (inv_pos.2 hδ) (ENNReal.toNNReal_pos hne hg.snorm_lt_top.ne)\n  have : ∀ n, μ { x : α | C ≤ «expr‖ ‖₊» ((measure_theory.condexp μ g (ℱ n)) x) } ≤ ENNReal.ofReal δ :=\n    by\n    intro n\n    have :=\n      mul_meas_ge_le_pow_snorm' μ one_ne_zero ENNReal.one_ne_top\n        ((@strongly_measurable_condexp _ _ _ _ _ (ℱ n) _ μ g).mono (hℱ n)).ae_strongly_measurable C\n    rw [ENNReal.one_toReal, ennreal.rpow_one, ennreal.rpow_one, mul_comm, ←\n      ENNReal.le_div_iff_mul_le (or.inl (ENNReal.coe_ne_zero.2 hCpos.ne.symm)) (or.inl ennreal.coe_lt_top.ne)] at this\n    simp_rw [ENNReal.coe_le_coe] at this\n    refine' this.trans _\n    rw [ENNReal.div_le_iff_le_mul (or.inl (ENNReal.coe_ne_zero.2 hCpos.ne.symm)) (or.inl ennreal.coe_lt_top.ne), hC,\n      Nonneg.inv_mk, ENNReal.coe_mul, ENNReal.coe_toNNReal hg.snorm_lt_top.ne, ← mul_assoc, ←\n      ENNReal.ofReal_eq_coe_nnreal, ← ENNReal.ofReal_mul hδ.le, mul_inv_cancel hδ.ne.symm, ENNReal.ofReal_one, one_mul]\n    exact snorm_one_condexp_le_snorm _\n  refine'\n    ⟨C, fun n => le_trans _ (h { x : α | C ≤ «expr‖ ‖₊» ((measure_theory.condexp μ g (ℱ n)) x) } (hmeas n C) (this n))⟩\n  have hmeasℱ : (measurable_set_of (ℱ n)) { x : α | C ≤ «expr‖ ‖₊» ((measure_theory.condexp μ g (ℱ n)) x) } :=\n    @measurable_set_le _ _ _ _ _ (ℱ n) _ _ _ _ _ measurable_const\n      (@measurable.nnnorm _ _ _ _ _ (ℱ n) _ strongly_measurable_condexp.measurable)\n  rw [← snorm_congr_ae (condexp_indicator hint hmeasℱ)]\n  exact snorm_one_condexp_le_snorm _\n#align integrable.uniform_integrable_condexp integrable.uniform_integrable_condexp\n\n",
 "snorm_one_condexp_le_snorm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≤ᵐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure_theory.condexp -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure_theory.condexp -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure_theory.condexp -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure_theory.condexp -/\n-- TODO: the following couple of lemmas should be generalized and proved using Jensen's inequality\n-- for the conditional expectation (not in mathlib yet) .\ntheorem snorm_one_condexp_le_snorm (f : α → exprℝ) : snorm (measure_theory.condexp μ f m) 1 μ ≤ snorm f 1 μ :=\n  by\n  by_cases hf : integrable f μ\n  swap;\n  · rw [condexp_undef hf, snorm_zero]\n    exact zero_le _\n  by_cases hm : m ≤ m0\n  swap;\n  · rw [condexp_of_not_le hm, snorm_zero]\n    exact zero_le _\n  by_cases hsig : sigma_finite (μ.trim hm)\n  swap;\n  · rw [condexp_of_not_sigma_finite hm hsig, snorm_zero]\n    exact zero_le _\n  calc\n    snorm (measure_theory.condexp μ f m) 1 μ ≤ snorm (measure_theory.condexp μ (|f|) m) 1 μ :=\n      by\n      refine' snorm_mono_ae _\n      filter_upwards [@condexp_mono _ m m0 _ _ _ _ _ _ _ _ hf hf.abs\n          (@ae_of_all _ m0 _ μ (fun x => le_abs_self (f x) : ∀ x, f x ≤ |f x|)),\n        eventually_le.trans (condexp_neg f).symm.le\n          (@condexp_mono _ m m0 _ _ _ _ _ _ _ _ hf.neg hf.abs\n            (@ae_of_all _ m0 _ μ (fun x => neg_le_abs_self (f x) : ∀ x, -f x ≤ |f x|)))]with x hx₁ hx₂\n      exact abs_le_abs hx₁ hx₂\n    _ = snorm f 1 μ :=\n      by\n      rw [snorm_one_eq_lintegral_nnnorm, snorm_one_eq_lintegral_nnnorm, ←\n        ENNReal.toReal_eq_toReal (ne_of_lt integrable_condexp.2) (ne_of_lt hf.2), ←\n        integral_norm_eq_lintegral_nnnorm (strongly_measurable_condexp.mono hm).ae_strongly_measurable, ←\n        integral_norm_eq_lintegral_nnnorm hf.1]\n      simp_rw [Real.norm_eq_abs]\n      rw [← @integral_condexp _ _ _ _ _ m m0 μ _ hm hsig hf.abs]\n      refine' integral_congr_ae _\n      have : «expr ≤ᵐ[ ] » 0 μ (measure_theory.condexp μ (|f|) m) :=\n        by\n        rw [← @condexp_zero α (exprℝ) _ _ _ m m0 μ]\n        exact\n          condexp_mono (integrable_zero _ _ _) hf.abs (@ae_of_all _ m0 _ μ (fun x => abs_nonneg (f x) : ∀ x, 0 ≤ |f x|))\n      filter_upwards [this]with x hx\n      exact abs_eq_self.2 hx\n    \n#align snorm_one_condexp_le_snorm snorm_one_condexp_le_snorm\n\n",
 "set_integral_abs_condexp_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ in , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ in , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure_theory.condexp -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure_theory.condexp -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure_theory.condexp -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure_theory.condexp -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ in , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ in , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure_theory.condexp -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ in , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ in , ∂ » -/\ntheorem set_integral_abs_condexp_le {s : Set α} (hs : (measurable_set_of m) s) (f : α → exprℝ) :\n    «expr∫ in , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ in , ∂ »\" s\n        (|(measure_theory.condexp μ f m) x|) μ ≤\n      «expr∫ in , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ in , ∂ »\" s\n        (|f x|) μ :=\n  by\n  by_cases hnm : m ≤ m0\n  swap\n  · simp_rw [condexp_of_not_le hnm, Pi.zero_apply, abs_zero, integral_zero]\n    exact integral_nonneg fun x => abs_nonneg _\n  by_cases hfint : integrable f μ\n  swap\n  · simp only [condexp_undef hfint, Pi.zero_apply, abs_zero, integral_const, Algebra.id.smul_eq_mul,\n      MulZeroClass.mul_zero]\n    exact integral_nonneg fun x => abs_nonneg _\n  have :\n    «expr∫ in , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ in , ∂ »\" s\n        (|(measure_theory.condexp μ f m) x|) μ =\n      «expr∫ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ »\"\n        (|(measure_theory.condexp μ (s.indicator f) m) x|) μ :=\n    by\n    rw [← integral_indicator]\n    swap\n    · exact hnm _ hs\n    refine' integral_congr_ae _\n    have :\n      «expr =ᵐ[ ] » (fun x => |(measure_theory.condexp μ (s.indicator f) m) x|) μ fun x =>\n        |s.indicator (measure_theory.condexp μ f m) x| :=\n      eventually_eq.fun_comp (condexp_indicator hfint hs) _\n    refine' eventually_eq.trans (eventually_of_forall fun x => _) this.symm\n    rw [← Real.norm_eq_abs, norm_indicator_eq_indicator_norm]\n    rfl\n  rw [this, ← integral_indicator]\n  swap\n  · exact hnm _ hs\n  refine' (integral_abs_condexp_le _).trans (le_of_eq <| integral_congr_ae <| eventually_of_forall fun x => _)\n  rw [← Real.norm_eq_abs, norm_indicator_eq_indicator_norm]\n  rfl\n#align set_integral_abs_condexp_le set_integral_abs_condexp_le\n\n",
 "rn_deriv_ae_eq_condexp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure_theory.condexp -/\n/-\nCopyright (c) 2022 Rémy Degenne. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Rémy Degenne, Kexing Ying\n-/\ntheorem rn_deriv_ae_eq_condexp {hm : m ≤ m0} [hμm : SigmaFinite (μ.trim hm)] {f : α → exprℝ} (hf : integrable f μ) :\n    «expr =ᵐ[ ] » (signed_measure.rn_deriv ((μ.with_densityᵥ f).trim hm) (μ.trim hm)) μ\n      (measure_theory.condexp μ f m) :=\n  by\n  refine' ae_eq_condexp_of_forall_set_integral_eq hm hf _ _ _\n  ·\n    exact fun _ _ _ =>\n      (integrable_of_integrable_trim hm\n          (signed_measure.integrable_rn_deriv ((μ.with_densityᵥ f).trim hm) (μ.trim hm))).integrable_on\n  · intro s hs hlt\n    conv_rhs =>\n      rw [← hf.with_densityᵥ_trim_eq_integral hm hs, ←\n        signed_measure.with_densityᵥ_rn_deriv_eq ((μ.with_densityᵥ f).trim hm) (μ.trim hm)\n          (hf.with_densityᵥ_trim_absolutely_continuous hm)]\n    rw [with_densityᵥ_apply (signed_measure.integrable_rn_deriv ((μ.with_densityᵥ f).trim hm) (μ.trim hm)) hs, ←\n      set_integral_trim hm _ hs]\n    exact (signed_measure.measurable_rn_deriv _ _).strongly_measurable\n  · exact strongly_measurable.ae_strongly_measurable' (signed_measure.measurable_rn_deriv _ _).strongly_measurable\n#align rn_deriv_ae_eq_condexp rn_deriv_ae_eq_condexp\n\n",
 "integral_abs_condexp_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure_theory.condexp -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ » -/\ntheorem integral_abs_condexp_le (f : α → exprℝ) :\n    «expr∫ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ »\"\n        (|(measure_theory.condexp μ f m) x|) μ ≤\n      «expr∫ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ »\" (|f x|) μ :=\n  by\n  by_cases hm : m ≤ m0\n  swap\n  · simp_rw [condexp_of_not_le hm, Pi.zero_apply, abs_zero, integral_zero]\n    exact integral_nonneg fun x => abs_nonneg _\n  by_cases hfint : integrable f μ\n  swap\n  · simp only [condexp_undef hfint, Pi.zero_apply, abs_zero, integral_const, Algebra.id.smul_eq_mul,\n      MulZeroClass.mul_zero]\n    exact integral_nonneg fun x => abs_nonneg _\n  rw [integral_eq_lintegral_of_nonneg_ae, integral_eq_lintegral_of_nonneg_ae]\n  · rw [ENNReal.toReal_le_toReal] <;> simp_rw [← Real.norm_eq_abs, ofReal_norm_eq_coe_nnnorm]\n    · rw [← snorm_one_eq_lintegral_nnnorm, ← snorm_one_eq_lintegral_nnnorm]\n      exact snorm_one_condexp_le_snorm _\n    · exact ne_of_lt integrable_condexp.2\n    · exact ne_of_lt hfint.2\n  · exact eventually_of_forall fun x => abs_nonneg _\n  · simp_rw [← Real.norm_eq_abs]\n    exact hfint.1.norm\n  · exact eventually_of_forall fun x => abs_nonneg _\n  · simp_rw [← Real.norm_eq_abs]\n    exact (strongly_measurable_condexp.mono hm).ae_strongly_measurable.norm\n#align integral_abs_condexp_le integral_abs_condexp_le\n\n",
 "condexp_strongly_measurable_simple_func_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure_theory.condexp -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure_theory.condexp -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure_theory.condexp -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure_theory.condexp -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure_theory.condexp -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure_theory.condexp -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure_theory.condexp -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure_theory.condexp -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure_theory.condexp -/\n-- TODO: this section could be generalized beyond multiplication, to any bounded bilinear map.\n/-- Auxiliary lemma for `condexp_measurable_mul`. -/\ntheorem condexp_strongly_measurable_simple_func_mul (hm : m ≤ m0) (f : @simple_func α m (exprℝ)) {g : α → exprℝ}\n    (hg : integrable g μ) : «expr =ᵐ[ ] » (measure_theory.condexp μ (f * g) m) μ (f * measure_theory.condexp μ g m) :=\n  by\n  have : ∀ (s c) (f : α → exprℝ), Set.indicator s (Function.const α c) * f = s.indicator («expr • » c f) :=\n    by\n    intro s c f\n    ext1 x\n    by_cases hx : x ∈ s\n    · simp only [hx, Pi.mul_apply, Set.indicator_of_mem, Pi.smul_apply, Algebra.id.smul_eq_mul]\n    · simp only [hx, Pi.mul_apply, Set.indicator_of_not_mem, not_false_iff, MulZeroClass.zero_mul]\n  refine' @simple_func.induction _ _ m _ _ (fun c s hs => _) (fun g₁ g₂ h_disj h_eq₁ h_eq₂ => _) f\n  · simp only [simple_func.const_zero, simple_func.coe_piecewise, simple_func.coe_const, simple_func.coe_zero,\n      Set.piecewise_eq_indicator]\n    rw [this, this]\n    refine' (condexp_indicator (hg.smul c) hs).trans _\n    filter_upwards [@condexp_smul α (exprℝ) (exprℝ) _ _ _ _ _ m m0 μ c g]with x hx\n    classical simp_rw [Set.indicator_apply, hx]\n  · have h_add := @simple_func.coe_add _ _ m _ g₁ g₂\n    calc\n      «expr =ᵐ[ ] » (measure_theory.condexp μ («expr⇑ » (g₁ + g₂) * g) m) μ\n          (measure_theory.condexp μ ((«expr⇑ » g₁ + «expr⇑ » g₂) * g) m) :=\n        by\n        refine' condexp_congr_ae (eventually_eq.mul _ eventually_eq.rfl)\n        rw [h_add]\n      «expr =ᵐ[ ] » _ μ (measure_theory.condexp μ («expr⇑ » g₁ * g) m + measure_theory.condexp μ («expr⇑ » g₂ * g) m) :=\n        by\n        rw [add_mul]\n        exact condexp_add (hg.simple_func_mul' hm _) (hg.simple_func_mul' hm _)\n      «expr =ᵐ[ ] » _ μ («expr⇑ » g₁ * measure_theory.condexp μ g m + «expr⇑ » g₂ * measure_theory.condexp μ g m) :=\n        (eventually_eq.add h_eq₁ h_eq₂)\n      «expr =ᵐ[ ] » _ μ («expr⇑ » (g₁ + g₂) * measure_theory.condexp μ g m) := by rw [h_add, add_mul]\n      \n#align condexp_strongly_measurable_simple_func_mul condexp_strongly_measurable_simple_func_mul\n\n",
 "condexp_strongly_measurable_mul₀":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure_theory.condexp -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure_theory.condexp -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure_theory.condexp -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure_theory.condexp -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure_theory.condexp -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure_theory.condexp -/\n/-- Pull-out property of the conditional expectation. -/\ntheorem condexp_strongly_measurable_mul₀ {f g : α → exprℝ} (hf : ae_strongly_measurable' m f μ)\n    (hfg : integrable (f * g) μ) (hg : integrable g μ) :\n    «expr =ᵐ[ ] » (measure_theory.condexp μ (f * g) m) μ (f * measure_theory.condexp μ g m) :=\n  by\n  have : «expr =ᵐ[ ] » (measure_theory.condexp μ (f * g) m) μ (measure_theory.condexp μ (hf.mk f * g) m) :=\n    condexp_congr_ae (eventually_eq.mul hf.ae_eq_mk eventually_eq.rfl)\n  refine' this.trans _\n  have : «expr =ᵐ[ ] » (f * measure_theory.condexp μ g m) μ (hf.mk f * measure_theory.condexp μ g m) :=\n    eventually_eq.mul hf.ae_eq_mk eventually_eq.rfl\n  refine' eventually_eq.trans _ this.symm\n  refine' condexp_strongly_measurable_mul hf.strongly_measurable_mk _ hg\n  refine' (integrable_congr _).mp hfg\n  exact eventually_eq.mul hf.ae_eq_mk eventually_eq.rfl\n#align condexp_strongly_measurable_mul₀ condexp_strongly_measurable_mul₀\n\n",
 "condexp_strongly_measurable_mul_of_bound₀":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure_theory.condexp -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure_theory.condexp -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure_theory.condexp -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure_theory.condexp -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure_theory.condexp -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure_theory.condexp -/\ntheorem condexp_strongly_measurable_mul_of_bound₀ (hm : m ≤ m0) [FiniteMeasure μ] {f g : α → exprℝ}\n    (hf : ae_strongly_measurable' m f μ) (hg : integrable g μ) (c : exprℝ)\n    (hf_bound :\n      «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\" μ\n        («expr‖ ‖» (f x) ≤ c)) :\n    «expr =ᵐ[ ] » (measure_theory.condexp μ (f * g) m) μ (f * measure_theory.condexp μ g m) :=\n  by\n  have : «expr =ᵐ[ ] » (measure_theory.condexp μ (f * g) m) μ (measure_theory.condexp μ (hf.mk f * g) m) :=\n    condexp_congr_ae (eventually_eq.mul hf.ae_eq_mk eventually_eq.rfl)\n  refine' this.trans _\n  have : «expr =ᵐ[ ] » (f * measure_theory.condexp μ g m) μ (hf.mk f * measure_theory.condexp μ g m) :=\n    eventually_eq.mul hf.ae_eq_mk eventually_eq.rfl\n  refine' eventually_eq.trans _ this.symm\n  refine' condexp_strongly_measurable_mul_of_bound hm hf.strongly_measurable_mk hg c _\n  filter_upwards [hf_bound, hf.ae_eq_mk]with x hxc hx_eq\n  rw [← hx_eq]\n  exact hxc\n#align condexp_strongly_measurable_mul_of_bound₀ condexp_strongly_measurable_mul_of_bound₀\n\n",
 "condexp_strongly_measurable_mul_of_bound":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure_theory.condexp -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure_theory.condexp -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure_theory.condexp -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure_theory.condexp -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure_theory.condexp -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure_theory.condexp -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure_theory.condexp -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure_theory.condexp -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `strongly_measurable_of -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure_theory.condexp -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure_theory.condexp -/\ntheorem condexp_strongly_measurable_mul_of_bound (hm : m ≤ m0) [FiniteMeasure μ] {f g : α → exprℝ}\n    (hf : (strongly_measurable_of m) f) (hg : integrable g μ) (c : exprℝ)\n    (hf_bound :\n      «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\" μ\n        («expr‖ ‖» (f x) ≤ c)) :\n    «expr =ᵐ[ ] » (measure_theory.condexp μ (f * g) m) μ (f * measure_theory.condexp μ g m) :=\n  by\n  let fs := hf.approx_bounded c\n  have hfs_tendsto :\n    «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\" μ\n      (tendsto (fun n => fs n x) at_top ((nhds) (f x))) :=\n    hf.tendsto_approx_bounded_ae hf_bound\n  by_cases hμ : μ = 0\n  · simp only [hμ, ae_zero]\n  have : μ.ae.ne_bot := by simp only [hμ, ae_ne_bot, ne.def, not_false_iff]\n  have hc : 0 ≤ c :=\n    haveI h_exists : ∃ x, «expr‖ ‖» (f x) ≤ c := eventually.exists hf_bound\n    (norm_nonneg _).trans h_exists.some_spec\n  have hfs_bound : ∀ n x, «expr‖ ‖» (fs n x) ≤ c := hf.norm_approx_bounded_le hc\n  have hn_eq : ∀ n, «expr =ᵐ[ ] » (measure_theory.condexp μ (fs n * g) m) μ (fs n * measure_theory.condexp μ g m) :=\n    fun n => condexp_strongly_measurable_simple_func_mul hm _ hg\n  have : measure_theory.condexp μ (f * measure_theory.condexp μ g m) m = f * measure_theory.condexp μ g m :=\n    by\n    refine' condexp_of_strongly_measurable hm (hf.mul strongly_measurable_condexp) _\n    exact integrable_condexp.bdd_mul' (hf.mono hm).ae_strongly_measurable hf_bound\n  rw [← this]\n  refine'\n    tendsto_condexp_unique (fun n x => fs n x * g x) (fun n x => fs n x * (measure_theory.condexp μ g m) x) (f * g)\n      (f * measure_theory.condexp μ g m) _ _ _ _ (fun x => c * «expr‖ ‖» (g x)) _\n      (fun x => c * «expr‖ ‖» ((measure_theory.condexp μ g m) x)) _ _ _ _\n  ·\n    exact fun n =>\n      hg.bdd_mul' ((simple_func.strongly_measurable (fs n)).mono hm).ae_strongly_measurable\n        (eventually_of_forall (hfs_bound n))\n  ·\n    exact fun n =>\n      integrable_condexp.bdd_mul' ((simple_func.strongly_measurable (fs n)).mono hm).ae_strongly_measurable\n        (eventually_of_forall (hfs_bound n))\n  · filter_upwards [hfs_tendsto]with x hx\n    rw [Pi.mul_apply]\n    exact tendsto.mul hx tendsto_const_nhds\n  · filter_upwards [hfs_tendsto]with x hx\n    rw [Pi.mul_apply]\n    exact tendsto.mul hx tendsto_const_nhds\n  · exact hg.norm.const_mul c\n  · exact integrable_condexp.norm.const_mul c\n  · refine' fun n => eventually_of_forall fun x => _\n    exact (norm_mul_le _ _).trans (mul_le_mul_of_nonneg_right (hfs_bound n x) (norm_nonneg _))\n  · refine' fun n => eventually_of_forall fun x => _\n    exact (norm_mul_le _ _).trans (mul_le_mul_of_nonneg_right (hfs_bound n x) (norm_nonneg _))\n  · intro n\n    simp_rw [← Pi.mul_apply]\n    refine' (condexp_strongly_measurable_simple_func_mul hm _ hg).trans _\n    rw [condexp_of_strongly_measurable hm ((simple_func.strongly_measurable _).mul strongly_measurable_condexp) _]\n    · infer_instance\n    · infer_instance\n    exact\n      integrable_condexp.bdd_mul' ((simple_func.strongly_measurable (fs n)).mono hm).ae_strongly_measurable\n        (eventually_of_forall (hfs_bound n))\n#align condexp_strongly_measurable_mul_of_bound condexp_strongly_measurable_mul_of_bound\n\n",
 "condexp_strongly_measurable_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure_theory.condexp -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure_theory.condexp -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure_theory.condexp -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure_theory.condexp -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure_theory.condexp -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure_theory.condexp -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `strongly_measurable_of -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure_theory.condexp -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure_theory.condexp -/\n/-- Pull-out property of the conditional expectation. -/\ntheorem condexp_strongly_measurable_mul {f g : α → exprℝ} (hf : (strongly_measurable_of m) f)\n    (hfg : integrable (f * g) μ) (hg : integrable g μ) :\n    «expr =ᵐ[ ] » (measure_theory.condexp μ (f * g) m) μ (f * measure_theory.condexp μ g m) :=\n  by\n  by_cases hm : m ≤ m0\n  swap\n  · simp_rw [condexp_of_not_le hm]\n    rw [MulZeroClass.mul_zero]\n  by_cases hμm : sigma_finite (μ.trim hm)\n  swap\n  · simp_rw [condexp_of_not_sigma_finite hm hμm]\n    rw [MulZeroClass.mul_zero]\n  haveI : sigma_finite (μ.trim hm) := hμm\n  obtain ⟨sets, sets_prop, h_univ⟩ := hf.exists_spanning_measurable_set_norm_le hm μ\n  simp_rw [forall_and] at sets_prop\n  obtain ⟨h_meas, h_finite, h_norm⟩ := sets_prop\n  suffices\n    ∀ n,\n      «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\" μ\n        (x ∈ sets n → (measure_theory.condexp μ (f * g) m) x = f x * (measure_theory.condexp μ g m) x)\n    by\n    rw [← ae_all_iff] at this\n    filter_upwards [this]with x hx\n    rw [Pi.mul_apply]\n    obtain ⟨i, hi⟩ : ∃ i, x ∈ sets i :=\n      by\n      have h_mem :\n        x ∈ «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (sets i) :=\n        by\n        rw [h_univ]\n        exact Set.mem_univ _\n      simpa using h_mem\n    exact hx i hi\n  refine' fun n => ae_imp_of_ae_restrict _\n  suffices\n    «expr =ᵐ[ ] » (measure_theory.condexp (μ.restrict (sets n)) (f * g) m) (μ.restrict (sets n))\n      (f * measure_theory.condexp (μ.restrict (sets n)) g m)\n    by\n    simp_rw [← Pi.mul_apply]\n    refine' (condexp_restrict_ae_eq_restrict hm (h_meas n) hfg).symm.trans _\n    exact this.trans (eventually_eq.rfl.mul (condexp_restrict_ae_eq_restrict hm (h_meas n) hg))\n  suffices\n    «expr =ᵐ[ ] » (measure_theory.condexp (μ.restrict (sets n)) ((sets n).indicator f * g) m) (μ.restrict (sets n))\n      ((sets n).indicator f * measure_theory.condexp (μ.restrict (sets n)) g m)\n    by\n    refine' eventually_eq.trans _ (this.trans _)\n    · exact condexp_congr_ae ((indicator_ae_eq_restrict (hm _ (h_meas n))).symm.mul eventually_eq.rfl)\n    · exact (indicator_ae_eq_restrict (hm _ (h_meas n))).mul eventually_eq.rfl\n  have : is_finite_measure (μ.restrict (sets n)) := by\n    constructor\n    rw [measure.restrict_apply_univ]\n    exact h_finite n\n  refine' condexp_strongly_measurable_mul_of_bound hm (hf.indicator (h_meas n)) hg.integrable_on n _\n  refine' eventually_of_forall fun x => _\n  by_cases hxs : x ∈ sets n\n  · simp only [hxs, Set.indicator_of_mem]\n    exact h_norm n x hxs\n  · simp only [hxs, Set.indicator_of_not_mem, not_false_iff, _root_.norm_zero, Nat.cast_nonneg]\n#align condexp_strongly_measurable_mul condexp_strongly_measurable_mul\n\n",
 "ae_bdd_condexp_of_ae_bdd":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure_theory.condexp -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure_theory.condexp -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure_theory.condexp -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure_theory.condexp -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure_theory.condexp -/\n/-- If the real valued function `f` is bounded almost everywhere by `R`, then so is its conditional\nexpectation. -/\ntheorem ae_bdd_condexp_of_ae_bdd {R : nnreal} {f : α → exprℝ}\n    (hbdd :\n      «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\" μ\n        (|f x| ≤ R)) :\n    «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\" μ\n      (|(measure_theory.condexp μ f m) x| ≤ R) :=\n  by\n  by_cases hnm : m ≤ m0\n  swap\n  · simp_rw [condexp_of_not_le hnm, Pi.zero_apply, abs_zero]\n    refine' eventually_of_forall fun x => R.coe_nonneg\n  by_cases hfint : integrable f μ\n  swap\n  · simp_rw [condexp_undef hfint]\n    filter_upwards [hbdd]with x hx\n    rw [Pi.zero_apply, abs_zero]\n    exact (abs_nonneg _).trans hx\n  by_contra h\n  change μ _ ≠ 0 at h\n  simp only [← zero_lt_iff, Set.compl_def, Set.mem_setOf_eq, not_le] at h\n  suffices\n    (μ { x | ↑R < |(measure_theory.condexp μ f m) x| }).to_real * ↑R <\n      (μ { x | ↑R < |(measure_theory.condexp μ f m) x| }).to_real * ↑R\n    by exact this.ne rfl\n  refine' lt_of_lt_of_le (set_integral_gt_gt R.coe_nonneg _ _ h.ne.symm) _\n  · simp_rw [← Real.norm_eq_abs]\n    exact (strongly_measurable_condexp.mono hnm).measurable.norm\n  · exact integrable_condexp.abs.integrable_on\n  refine' (set_integral_abs_condexp_le _ _).trans _\n  · simp_rw [← Real.norm_eq_abs]\n    exact @measurable_set_lt _ _ _ _ _ m _ _ _ _ _ measurable_const strongly_measurable_condexp.norm.measurable\n  simp only [← smul_eq_mul, ← set_integral_const, NNReal.val_eq_coe, IsROrC.ofReal_real_eq_id, id.def]\n  refine' set_integral_mono_ae hfint.abs.integrable_on _ _\n  · refine'\n      ⟨ae_strongly_measurable_const,\n        lt_of_le_of_lt _\n          (integrable_condexp.integrable_on :\n              integrable_on (measure_theory.condexp μ f m) { x | ↑R < |(measure_theory.condexp μ f m) x| } μ).2⟩\n    refine'\n      set_lintegral_mono (measurable.nnnorm _).coe_nnreal_ennreal\n        (strongly_measurable_condexp.mono hnm).measurable.nnnorm.coe_nnreal_ennreal fun x hx => _\n    · exact measurable_const\n    · rw [ENNReal.coe_le_coe, Real.nnnorm_of_nonneg R.coe_nonneg]\n      exact Subtype.mk_le_mk.2 (le_of_lt hx)\n  · exact hbdd\n#align ae_bdd_condexp_of_ae_bdd ae_bdd_condexp_of_ae_bdd\n\n"}