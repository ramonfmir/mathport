{"condexp_restrict_ae_eq_restrict":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure_theory.condexp -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ in , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ in , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure_theory.condexp -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ in , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ in , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure_theory.condexp -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ in , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ in , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ in , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ in , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure_theory.condexp -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure_theory.condexp -/\ntheorem condexp_restrict_ae_eq_restrict (hm : m ≤ m0) [sigma_finite (μ.trim hm)] (hs_m : (measurable_set_of m) s)\n    (hf_int : integrable f μ) :\n    «expr =ᵐ[ ] » (measure_theory.condexp (μ.restrict s) f m) (μ.restrict s) (measure_theory.condexp μ f m) :=\n  by\n  have : sigma_finite ((μ.restrict s).trim hm) :=\n    by\n    rw [← restrict_trim hm _ hs_m]\n    infer_instance\n  rw [ae_eq_restrict_iff_indicator_ae_eq (hm _ hs_m)]\n  swap\n  · infer_instance\n  refine' eventually_eq.trans _ (condexp_indicator hf_int hs_m)\n  refine' ae_eq_condexp_of_forall_set_integral_eq hm (hf_int.indicator (hm _ hs_m)) _ _ _\n  · intro t ht hμt\n    rw [← integrable_indicator_iff (hm _ ht), set.indicator_indicator, Set.inter_comm, ← set.indicator_indicator]\n    suffices h_int_restrict : integrable (t.indicator (measure_theory.condexp (μ.restrict s) f m)) (μ.restrict s)\n    · rw [integrable_indicator_iff (hm _ hs_m), integrable_on]\n      rw [integrable_indicator_iff (hm _ ht), integrable_on] at h_int_restrict⊢\n      exact h_int_restrict\n    exact integrable_condexp.indicator (hm _ ht)\n  · intro t ht hμt\n    calc\n      «expr∫ in , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ in , ∂ »\" t\n            (s.indicator (measure_theory.condexp (μ.restrict s) f m) x) μ =\n          «expr∫ in , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ in , ∂ »\" t\n            ((measure_theory.condexp (μ.restrict s) f m) x) (μ.restrict s) :=\n        by\n        rw [integral_indicator (hm _ hs_m), measure.restrict_restrict (hm _ hs_m), measure.restrict_restrict (hm _ ht),\n          Set.inter_comm]\n      _ =\n          «expr∫ in , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ in , ∂ »\" t\n            (f x) (μ.restrict s) :=\n        set_integral_condexp hm hf_int.integrable_on ht\n      _ =\n          «expr∫ in , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ in , ∂ »\" t\n            (s.indicator f x) μ :=\n        by\n        rw [integral_indicator (hm _ hs_m), measure.restrict_restrict (hm _ hs_m), measure.restrict_restrict (hm _ ht),\n          Set.inter_comm]\n      \n  · exact (strongly_measurable_condexp.indicator hs_m).ae_strongly_measurable'\n#align condexp_restrict_ae_eq_restrict condexp_restrict_ae_eq_restrict\n\n",
 "condexp_indicator_aux":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure_theory.condexp -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure_theory.condexp -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure_theory.condexp -/\n/-- Auxiliary lemma for `condexp_indicator`. -/\ntheorem condexp_indicator_aux (hs : (measurable_set_of m) s) (hf : «expr =ᵐ[ ] » f (μ.restrict («expr ᶜ» s)) 0) :\n    «expr =ᵐ[ ] » (measure_theory.condexp μ (s.indicator f) m) μ (s.indicator (measure_theory.condexp μ f m)) :=\n  by\n  by_cases hm : m ≤ m0\n  swap\n  · simp_rw [condexp_of_not_le hm, set.indicator_zero']\n  have hsf_zero : ∀ g : α → E, «expr =ᵐ[ ] » g (μ.restrict («expr ᶜ» s)) 0 → «expr =ᵐ[ ] » (s.indicator g) μ g :=\n    fun g => indicator_ae_eq_of_restrict_compl_ae_eq_zero (hm _ hs)\n  refine' ((hsf_zero (measure_theory.condexp μ f m) (condexp_ae_eq_restrict_zero hs.compl hf)).trans _).symm\n  exact condexp_congr_ae (hsf_zero f hf).symm\n#align condexp_indicator_aux condexp_indicator_aux\n\n",
 "condexp_indicator":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure_theory.condexp -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure_theory.condexp -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure_theory.condexp -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure_theory.condexp -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure_theory.condexp -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure_theory.condexp -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure_theory.condexp -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure_theory.condexp -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure_theory.condexp -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure_theory.condexp -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure_theory.condexp -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure_theory.condexp -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure_theory.condexp -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure_theory.condexp -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure_theory.condexp -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure_theory.condexp -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure_theory.condexp -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure_theory.condexp -/\n/-- The conditional expectation of the indicator of a function over an `m`-measurable set with\nrespect to the σ-algebra `m` is a.e. equal to the indicator of the conditional expectation. -/\ntheorem condexp_indicator (hf_int : integrable f μ) (hs : (measurable_set_of m) s) :\n    «expr =ᵐ[ ] » (measure_theory.condexp μ (s.indicator f) m) μ (s.indicator (measure_theory.condexp μ f m)) :=\n  by\n  by_cases hm : m ≤ m0\n  swap\n  · simp_rw [condexp_of_not_le hm, set.indicator_zero']\n  by_cases hμm : sigma_finite (μ.trim hm)\n  swap\n  · simp_rw [condexp_of_not_sigma_finite hm hμm, set.indicator_zero']\n  haveI : sigma_finite (μ.trim hm) := hμm\n  -- use `have` to perform what should be the first calc step because of an error I don't\n  -- understand\n  have :\n    «expr =ᵐ[ ] » (s.indicator (measure_theory.condexp μ f m)) μ\n      (s.indicator (measure_theory.condexp μ (s.indicator f + («expr ᶜ» s).indicator f) m)) :=\n    by rw [set.indicator_self_add_compl s f]\n  refine' (this.trans _).symm\n  calc\n    «expr =ᵐ[ ] » (s.indicator (measure_theory.condexp μ (s.indicator f + («expr ᶜ» s).indicator f) m)) μ\n        (s.indicator\n          (measure_theory.condexp μ (s.indicator f) m + measure_theory.condexp μ ((«expr ᶜ» s).indicator f) m)) :=\n      by\n      have :\n        «expr =ᵐ[ ] » (measure_theory.condexp μ (s.indicator f + («expr ᶜ» s).indicator f) m) μ\n          (measure_theory.condexp μ (s.indicator f) m + measure_theory.condexp μ ((«expr ᶜ» s).indicator f) m) :=\n        condexp_add (hf_int.indicator (hm _ hs)) (hf_int.indicator (hm _ hs.compl))\n      filter_upwards [this] with x hx\n      classical rw [set.indicator_apply, set.indicator_apply, hx]\n    _ =\n        s.indicator (measure_theory.condexp μ (s.indicator f) m) +\n          s.indicator (measure_theory.condexp μ ((«expr ᶜ» s).indicator f) m) :=\n      s.indicator_add' _ _\n    «expr =ᵐ[ ] » _ μ\n        (s.indicator (measure_theory.condexp μ (s.indicator f) m) +\n          s.indicator ((«expr ᶜ» s).indicator (measure_theory.condexp μ ((«expr ᶜ» s).indicator f) m))) :=\n      by\n      refine' filter.eventually_eq.rfl.add _\n      have :\n        «expr =ᵐ[ ] » ((«expr ᶜ» s).indicator (measure_theory.condexp μ ((«expr ᶜ» s).indicator f) m)) μ\n          (measure_theory.condexp μ ((«expr ᶜ» s).indicator f) m) :=\n        by\n        refine' (condexp_indicator_aux hs.compl _).symm.trans _\n        · exact indicator_ae_eq_restrict_compl (hm _ hs.compl)\n        · rw [set.indicator_indicator, Set.inter_self]\n      filter_upwards [this] with x hx\n      by_cases hxs : x ∈ s\n      · simp only [hx, hxs, set.indicator_of_mem]\n      · simp only [hxs, set.indicator_of_not_mem, not_false_iff]\n    «expr =ᵐ[ ] » _ μ (s.indicator (measure_theory.condexp μ (s.indicator f) m)) := by\n      rw [set.indicator_indicator, Set.inter_compl_self, set.indicator_empty', add_zero]\n    «expr =ᵐ[ ] » _ μ (measure_theory.condexp μ (s.indicator f) m) :=\n      by\n      refine' (condexp_indicator_aux hs _).symm.trans _\n      · exact indicator_ae_eq_restrict_compl (hm _ hs)\n      · rw [set.indicator_indicator, Set.inter_self]\n    \n#align condexp_indicator condexp_indicator\n\n",
 "condexp_ae_eq_restrict_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure_theory.condexp -/\n/-\nCopyright (c) 2022 Rémy Degenne. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Rémy Degenne\n-/\ntheorem condexp_ae_eq_restrict_zero (hs : (measurable_set_of m) s) (hf : «expr =ᵐ[ ] » f (μ.restrict s) 0) :\n    «expr =ᵐ[ ] » (measure_theory.condexp μ f m) (μ.restrict s) 0 :=\n  by\n  by_cases hm : m ≤ m0\n  swap\n  · simp_rw [condexp_of_not_le hm]\n  by_cases hμm : sigma_finite (μ.trim hm)\n  swap\n  · simp_rw [condexp_of_not_sigma_finite hm hμm]\n  haveI : sigma_finite (μ.trim hm) := hμm\n  have : sigma_finite ((μ.restrict s).trim hm) :=\n    by\n    rw [← restrict_trim hm _ hs]\n    exact restrict.sigma_finite _ s\n  by_cases hf_int : integrable f μ\n  swap\n  · rw [condexp_undef hf_int]\n  refine' ae_eq_of_forall_set_integral_eq_of_sigma_finite' hm _ _ _ _ _\n  · exact fun t ht hμt => integrable_condexp.integrable_on.integrable_on\n  · exact fun t ht hμt => (integrable_zero _ _ _).integrable_on\n  · intro t ht hμt\n    rw [measure.restrict_restrict (hm _ ht), set_integral_condexp hm hf_int (ht.inter hs), ←\n      measure.restrict_restrict (hm _ ht)]\n    refine' set_integral_congr_ae (hm _ ht) _\n    filter_upwards [hf] with x hx h using hx\n  · exact strongly_measurable_condexp.ae_strongly_measurable'\n  · exact strongly_measurable_zero.ae_strongly_measurable'\n#align condexp_ae_eq_restrict_zero condexp_ae_eq_restrict_zero\n\n",
 "condexp_ae_eq_restrict_of_measurable_space_eq_on":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `strongly_measurable_of -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure_theory.condexp -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ in , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ in , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure_theory.condexp -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ in , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ in , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure_theory.condexp -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ in , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ in , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure_theory.condexp -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure_theory.condexp -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ in , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ in , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure_theory.condexp -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ in , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ in , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure_theory.condexp -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure_theory.condexp -/\n/-- If the restriction to a `m`-measurable set `s` of a σ-algebra `m` is equal to the restriction\nto `s` of another σ-algebra `m₂` (hypothesis `hs`), then `μ[f | m] =ᵐ[μ.restrict s] μ[f | m₂]`. -/\ntheorem condexp_ae_eq_restrict_of_measurable_space_eq_on {m m₂ m0 : measurable_space α} {μ : measure α} (hm : m ≤ m0)\n    (hm₂ : m₂ ≤ m0) [sigma_finite (μ.trim hm)] [sigma_finite (μ.trim hm₂)] (hs_m : (measurable_set_of m) s)\n    (hs : ∀ t, (measurable_set_of m) (s ∩ t) ↔ (measurable_set_of m₂) (s ∩ t)) :\n    «expr =ᵐ[ ] » (measure_theory.condexp μ f m) (μ.restrict s) (measure_theory.condexp μ f m₂) :=\n  by\n  rw [ae_eq_restrict_iff_indicator_ae_eq (hm _ hs_m)]\n  have hs_m₂ : (measurable_set_of m₂) s := by rwa [← Set.inter_univ s, ← hs Set.univ, Set.inter_univ]\n  by_cases hf_int : integrable f μ\n  swap\n  · simp_rw [condexp_undef hf_int]\n  refine' ((condexp_indicator hf_int hs_m).symm.trans _).trans (condexp_indicator hf_int hs_m₂)\n  refine'\n    ae_eq_of_forall_set_integral_eq_of_sigma_finite' hm₂ (fun s hs hμs => integrable_condexp.integrable_on)\n      (fun s hs hμs => integrable_condexp.integrable_on) _ _ strongly_measurable_condexp.ae_strongly_measurable'\n  swap\n  · have : (strongly_measurable_of m) (measure_theory.condexp μ (s.indicator f) m) := strongly_measurable_condexp\n    refine'\n      this.ae_strongly_measurable'.ae_strongly_measurable'_of_measurable_space_le_on hm hs_m (fun t => (hs t).mp) _\n    exact condexp_ae_eq_restrict_zero hs_m.compl (indicator_ae_eq_restrict_compl (hm _ hs_m))\n  intro t ht hμt\n  have :\n    «expr∫ in , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ in , ∂ »\" t\n        ((measure_theory.condexp μ (s.indicator f) m) x) μ =\n      «expr∫ in , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ in , ∂ »\" (s ∩ t)\n        ((measure_theory.condexp μ (s.indicator f) m) x) μ :=\n    by\n    rw [← integral_add_compl (hm _ hs_m) integrable_condexp.integrable_on]\n    suffices\n      «expr∫ in , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ in , ∂ »\"\n          («expr ᶜ» s) ((measure_theory.condexp μ (s.indicator f) m) x) (μ.restrict t) =\n        0\n      by rw [this, add_zero, measure.restrict_restrict (hm _ hs_m)]\n    rw [measure.restrict_restrict (measurable_set.compl (hm _ hs_m))]\n    suffices «expr =ᵐ[ ] » (measure_theory.condexp μ (s.indicator f) m) (μ.restrict («expr ᶜ» s)) 0\n      by\n      rw [Set.inter_comm, ← measure.restrict_restrict (hm₂ _ ht)]\n      calc\n        «expr∫ in , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ in , ∂ »\" t\n              ((measure_theory.condexp μ (s.indicator f) m) x) (μ.restrict («expr ᶜ» s)) =\n            «expr∫ in , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ in , ∂ »\" t\n              0 (μ.restrict («expr ᶜ» s)) :=\n          by\n          refine' set_integral_congr_ae (hm₂ _ ht) _\n          filter_upwards [this] with x hx h using hx\n        _ = 0 := integral_zero _ _\n        \n    refine' condexp_ae_eq_restrict_zero hs_m.compl _\n    exact indicator_ae_eq_restrict_compl (hm _ hs_m)\n  have hst_m : (measurable_set_of m) (s ∩ t) := (hs _).mpr (hs_m₂.inter ht)\n  simp_rw [this, set_integral_condexp hm₂ (hf_int.indicator (hm _ hs_m)) ht,\n    set_integral_condexp hm (hf_int.indicator (hm _ hs_m)) hst_m, integral_indicator (hm _ hs_m),\n    measure.restrict_restrict (hm _ hs_m), ← Set.inter_assoc, Set.inter_self]\n#align condexp_ae_eq_restrict_of_measurable_space_eq_on condexp_ae_eq_restrict_of_measurable_space_eq_on\n\n"}