{"uniform_integrable_zero_meas":
 "theorem uniform_integrable_zero_meas [MeasurableSpace α] : uniform_integrable f p (0 : Measure α) :=\n  ⟨fun n => ae_strongly_measurable_zero_measure _, unif_integrable_zero_meas, 0, fun i => snorm_measure_zero.le⟩\n#align uniform_integrable_zero_meas uniform_integrable_zero_meas\n\n",
 "uniform_integrable_subsingleton":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/-- A single function is uniformly integrable in the probability sense. -/\ntheorem uniform_integrable_subsingleton [subsingleton ι] (hp_one : 1 ≤ p) (hp_top : p ≠ ennreal.top)\n    (hf : ∀ i, mem_ℒp (f i) p μ) : uniform_integrable f p μ :=\n  uniform_integrable_finite hp_one hp_top hf\n#align uniform_integrable_subsingleton uniform_integrable_subsingleton\n\n",
 "uniform_integrable_of'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/-- This lemma is superceded by `uniform_integrable_of` which only requires\n`ae_strongly_measurable`. -/\ntheorem uniform_integrable_of' [FiniteMeasure μ] (hp : 1 ≤ p) (hp' : p ≠ ennreal.top)\n    (hf : ∀ i, strongly_measurable (f i))\n    (h :\n      ∀ ε : exprℝ,\n        0 < ε → ∃ C : nnreal, ∀ i, snorm ({ x | C ≤ «expr‖ ‖₊» (f i x) }.indicator (f i)) p μ ≤ ENNReal.ofReal ε) :\n    uniform_integrable f p μ :=\n  by\n  refine'\n    ⟨fun i => (hf i).ae_strongly_measurable, unif_integrable_of μ hp hp' (fun i => (hf i).ae_strongly_measurable) h, _⟩\n  obtain ⟨C, hC⟩ := h 1 one_pos\n  refine' ⟨(C * μ univ ^ p.to_real⁻¹ + 1 : ennreal).to_nnreal, fun i => _⟩\n  calc\n    snorm (f i) p μ ≤\n        snorm ({ x : α | «expr‖ ‖₊» (f i x) < C }.indicator (f i)) p μ +\n          snorm ({ x : α | C ≤ «expr‖ ‖₊» (f i x) }.indicator (f i)) p μ :=\n      by\n      refine'\n        le_trans (snorm_mono fun x => _)\n          (snorm_add_le\n            (strongly_measurable.ae_strongly_measurable\n              ((hf i).indicator ((hf i).nnnorm.measurable_set_lt strongly_measurable_const)))\n            (strongly_measurable.ae_strongly_measurable\n              ((hf i).indicator (strongly_measurable_const.measurable_set_le (hf i).nnnorm)))\n            hp)\n      · rw [Pi.add_apply, indicator_apply]\n        split_ifs with hx\n        · rw [indicator_of_not_mem, add_zero]\n          simpa using hx\n        · rw [indicator_of_mem, zero_add]\n          simpa using hx\n    _ ≤ C * μ univ ^ p.to_real⁻¹ + 1 :=\n      by\n      have :\n        «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\" μ\n          («expr‖ ‖₊» ({ x : α | «expr‖ ‖₊» (f i x) < C }.indicator (f i) x) ≤ C) :=\n        by\n        refine' eventually_of_forall _\n        simp_rw [nnnorm_indicator_eq_indicator_nnnorm]\n        exact indicator_le fun x (hx : _ < _) => hx.le\n      refine' add_le_add (le_trans (snorm_le_of_ae_bound this) _) (ENNReal.ofReal_one ▸ hC i)\n      rw [ENNReal.ofReal_coe_nnreal, mul_comm]\n      exact le_rfl\n    _ = (C * μ univ ^ p.to_real⁻¹ + 1 : ennreal).to_nnreal :=\n      by\n      rw [ENNReal.coe_toNNReal]\n      exact\n        ENNReal.add_ne_top.2\n          ⟨ENNReal.mul_ne_top ENNReal.coe_ne_top\n              (ennreal.rpow_ne_top_of_nonneg (inv_nonneg.2 ENNReal.toReal_nonneg) (measure_lt_top _ _).ne),\n            ENNReal.one_ne_top⟩\n    \n#align uniform_integrable_of' uniform_integrable_of'\n\n",
 "uniform_integrable_of":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/-- A sequene of functions `(fₙ)` is uniformly integrable in the probability sense if for all\n`ε > 0`, there exists some `C` such that `∫ x in {|fₙ| ≥ C}, fₙ x ∂μ ≤ ε` for all `n`. -/\ntheorem uniform_integrable_of [FiniteMeasure μ] (hp : 1 ≤ p) (hp' : p ≠ ennreal.top)\n    (hf : ∀ i, ae_strongly_measurable (f i) μ)\n    (h :\n      ∀ ε : exprℝ,\n        0 < ε → ∃ C : nnreal, ∀ i, snorm ({ x | C ≤ «expr‖ ‖₊» (f i x) }.indicator (f i)) p μ ≤ ENNReal.ofReal ε) :\n    uniform_integrable f p μ := by\n  set g : ι → α → β := fun i => (hf i).some\n  have hgmeas : ∀ i, strongly_measurable (g i) := fun i => (Exists.choose_spec <| hf i).1\n  have hgeq : ∀ i, «expr =ᵐ[ ] » (g i) μ (f i) := fun i => (Exists.choose_spec <| hf i).2.symm\n  refine' (uniform_integrable_of' hp hp' hgmeas fun ε hε => _).ae_eq hgeq\n  obtain ⟨C, hC⟩ := h ε hε\n  refine' ⟨C, fun i => le_trans (le_of_eq <| snorm_congr_ae _) (hC i)⟩\n  filter_upwards [(Exists.choose_spec <| hf i).2]with x hx\n  by_cases hfx : x ∈ { x | C ≤ «expr‖ ‖₊» (f i x) }\n  · rw [indicator_of_mem hfx, indicator_of_mem, hx]\n    rwa [mem_set_of, hx] at hfx\n  · rw [indicator_of_not_mem hfx, indicator_of_not_mem]\n    rwa [mem_set_of, hx] at hfx\n#align uniform_integrable_of uniform_integrable_of\n\n",
 "uniform_integrable_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/-- The definition of uniform integrable in mathlib is equivalent to the definition commonly\nfound in literature. -/\ntheorem uniform_integrable_iff [FiniteMeasure μ] (hp : 1 ≤ p) (hp' : p ≠ ennreal.top) :\n    uniform_integrable f p μ ↔\n      (∀ i, ae_strongly_measurable (f i) μ) ∧\n        ∀ ε : exprℝ,\n          0 < ε → ∃ C : nnreal, ∀ i, snorm ({ x | C ≤ «expr‖ ‖₊» (f i x) }.indicator (f i)) p μ ≤ ENNReal.ofReal ε :=\n  ⟨fun h => ⟨h.1, fun ε => h.spec (lt_of_lt_of_le zero_lt_one hp).ne.symm hp'⟩, fun h =>\n    uniform_integrable_of hp hp' h.1 h.2⟩\n#align uniform_integrable_iff uniform_integrable_iff\n\n",
 "uniform_integrable_finite":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/-- A finite sequence of Lp functions is uniformly integrable in the probability sense. -/\ntheorem uniform_integrable_finite [Finite ι] (hp_one : 1 ≤ p) (hp_top : p ≠ ennreal.top) (hf : ∀ i, mem_ℒp (f i) p μ) :\n    uniform_integrable f p μ := by\n  cases nonempty_fintype ι\n  refine' ⟨fun n => (hf n).1, unif_integrable_finite μ hp_one hp_top hf, _⟩\n  by_cases hι : Nonempty ι\n  · choose ae_meas hf using hf\n    set C :=\n      (finset.univ.image fun i : ι => snorm (f i) p μ).max'\n        ⟨snorm (f hι.some) p μ, Finset.mem_image.2 ⟨hι.some, Finset.mem_univ _, rfl⟩⟩\n    refine' ⟨C.to_nnreal, fun i => _⟩\n    rw [ENNReal.coe_toNNReal]\n    · exact Finset.le_max' _ _ (Finset.mem_image.2 ⟨i, Finset.mem_univ _, rfl⟩)\n    · refine' ne_of_lt ((Finset.max'_lt_iff _ _).2 fun y hy => _)\n      rw [Finset.mem_image] at hy\n      obtain ⟨i, -, rfl⟩ := hy\n      exact hf i\n  · exact ⟨0, fun i => false.elim <| hι <| nonempty.intro i⟩\n#align uniform_integrable_finite uniform_integrable_finite\n\n",
 "uniform_integrable_const":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/-- A constant sequence of functions is uniformly integrable in the probability sense. -/\ntheorem uniform_integrable_const {g : α → β} (hp : 1 ≤ p) (hp_ne_top : p ≠ ennreal.top) (hg : mem_ℒp g p μ) :\n    uniform_integrable (fun n : ι => g) p μ :=\n  ⟨fun i => hg.1, unif_integrable_const μ hp hp_ne_top hg,\n    ⟨(snorm g p μ).to_nnreal, fun i => le_of_eq (ENNReal.coe_toNNReal hg.2.ne).symm⟩⟩\n#align uniform_integrable_const uniform_integrable_const\n\n",
 "uniform_integrable_congr_ae":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\ntheorem uniform_integrable_congr_ae {g : ι → α → β} (hfg : ∀ n, «expr =ᵐ[ ] » (f n) μ (g n)) :\n    uniform_integrable f p μ ↔ uniform_integrable g p μ :=\n  ⟨fun h => h.ae_eq hfg, fun h => h.ae_eq fun i => (hfg i).symm⟩\n#align uniform_integrable_congr_ae uniform_integrable_congr_ae\n\n",
 "uniform_integrable_average":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/-- The averaging of a uniformly integrable sequence is also uniformly integrable. -/\ntheorem uniform_integrable_average (hp : 1 ≤ p) {f : ℕ → α → exprℝ} (hf : uniform_integrable f p μ) :\n    uniform_integrable\n      (fun n =>\n        finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (Finset.range n)\n            (f i) /\n          n)\n      p μ :=\n  by\n  obtain ⟨hf₁, hf₂, hf₃⟩ := hf\n  refine' ⟨fun n => _, fun ε hε => _, _⟩\n  · simp_rw [div_eq_mul_inv]\n    exact\n      (finset.ae_strongly_measurable_sum' _ fun i _ => hf₁ i).mul\n        (ae_strongly_measurable_const : ae_strongly_measurable (fun x => (↑n : exprℝ)⁻¹) μ)\n  · obtain ⟨δ, hδ₁, hδ₂⟩ := hf₂ hε\n    refine' ⟨δ, hδ₁, fun n s hs hle => _⟩\n    simp_rw [div_eq_mul_inv, Finset.sum_mul, Set.indicator_finset_sum]\n    refine' le_trans (snorm_sum_le (fun i hi => ((hf₁ i).mul_const (↑n)⁻¹).indicator hs) hp) _\n    have : ∀ i, s.indicator (f i * (↑n)⁻¹) = «expr • » (↑n : exprℝ)⁻¹ (s.indicator (f i)) :=\n      by\n      intro i\n      rw [mul_comm, (_ : (↑n)⁻¹ * f i = fun ω => «expr • » (↑n : exprℝ)⁻¹ (f i ω))]\n      · rw [Set.indicator_const_smul s (↑n)⁻¹ (f i)]\n        rfl\n      · rfl\n    simp_rw [this, snorm_const_smul, ← Finset.mul_sum, nnnorm_inv, Real.nnnorm_coe_nat]\n    by_cases hn : (↑(↑n : nnreal)⁻¹ : ennreal) = 0\n    · simp only [hn, MulZeroClass.zero_mul, zero_le]\n    refine' le_trans _ (_ : ↑(↑n : nnreal)⁻¹ * «expr • » n (ENNReal.ofReal ε) ≤ ENNReal.ofReal ε)\n    · refine' (ENNReal.mul_le_mul_left hn ENNReal.coe_ne_top).2 _\n      conv_rhs => rw [← Finset.card_range n]\n      exact Finset.sum_le_card_nsmul _ _ _ fun i hi => hδ₂ _ _ hs hle\n    · simp only [ENNReal.coe_eq_zero, inv_eq_zero, Nat.cast_eq_zero] at hn\n      rw [nsmul_eq_mul, ← mul_assoc, ENNReal.coe_inv, ENNReal.coe_nat, ENNReal.inv_mul_cancel _ (ENNReal.nat_ne_top _),\n        one_mul]\n      · exact le_rfl\n      all_goals simpa only [ne.def, Nat.cast_eq_zero]\n  · obtain ⟨C, hC⟩ := hf₃\n    simp_rw [div_eq_mul_inv, Finset.sum_mul]\n    refine' ⟨C, fun n => (snorm_sum_le (fun i hi => (hf₁ i).mul_const (↑n)⁻¹) hp).trans _⟩\n    have : ∀ i, (fun ω => f i ω * (↑n)⁻¹) = «expr • » (↑n : exprℝ)⁻¹ fun ω => f i ω :=\n      by\n      intro i\n      ext ω\n      simp only [mul_comm, Pi.smul_apply, Algebra.id.smul_eq_mul]\n    simp_rw [this, snorm_const_smul, ← Finset.mul_sum, nnnorm_inv, Real.nnnorm_coe_nat]\n    by_cases hn : (↑(↑n : nnreal)⁻¹ : ennreal) = 0\n    · simp only [hn, MulZeroClass.zero_mul, zero_le]\n    refine' le_trans _ (_ : ↑(↑n : nnreal)⁻¹ * («expr • » n C : ennreal) ≤ C)\n    · refine' (ENNReal.mul_le_mul_left hn ENNReal.coe_ne_top).2 _\n      conv_rhs => rw [← Finset.card_range n]\n      exact Finset.sum_le_card_nsmul _ _ _ fun i hi => hC i\n    · simp only [ENNReal.coe_eq_zero, inv_eq_zero, Nat.cast_eq_zero] at hn\n      rw [nsmul_eq_mul, ← mul_assoc, ENNReal.coe_inv, ENNReal.coe_nat, ENNReal.inv_mul_cancel _ (ENNReal.nat_ne_top _),\n        one_mul]\n      · exact le_rfl\n      all_goals simpa only [ne.def, Nat.cast_eq_zero]\n#align uniform_integrable_average uniform_integrable_average\n\n",
 "unif_integrable_zero_meas":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\ntheorem unif_integrable_zero_meas [MeasurableSpace α] {p : ennreal} {f : ι → α → β} :\n    unif_integrable f p (0 : Measure α) := fun ε hε => ⟨1, one_pos, fun i s hs hμs => by simp⟩\n#align unif_integrable_zero_meas unif_integrable_zero_meas\n\n",
 "unif_integrable_subsingleton":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/-- A single function is uniformly integrable. -/\ntheorem unif_integrable_subsingleton [subsingleton ι] (hp_one : 1 ≤ p) (hp_top : p ≠ ennreal.top) {f : ι → α → β}\n    (hf : ∀ i, mem_ℒp (f i) p μ) : unif_integrable f p μ :=\n  by\n  intro ε hε\n  by_cases hι : Nonempty ι\n  · cases' hι with i\n    obtain ⟨δ, hδpos, hδ⟩ := (hf i).snorm_indicator_le μ hp_one hp_top hε\n    refine' ⟨δ, hδpos, fun j s hs hμs => _⟩\n    convert hδ s hs hμs\n  · exact ⟨1, zero_lt_one, fun i => false.elim <| hι <| nonempty.intro i⟩\n#align unif_integrable_subsingleton unif_integrable_subsingleton\n\n",
 "unif_integrable_of_tendsto_Lp_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem unif_integrable_of_tendsto_Lp_zero (hp : 1 ≤ p) (hp' : p ≠ ennreal.top) (hf : ∀ n, mem_ℒp (f n) p μ)\n    (hf_tendsto : Tendsto (fun n => snorm (f n) p μ) atTop ((nhds) 0)) : unif_integrable f p μ :=\n  by\n  intro ε hε\n  rw [ENNReal.tendsto_atTop_zero] at hf_tendsto\n  obtain ⟨N, hN⟩ := hf_tendsto (ENNReal.ofReal ε) (by simpa)\n  set F : Fin N → α → β := fun n => f n\n  have hF : ∀ n, mem_ℒp (F n) p μ := fun n => hf n\n  obtain ⟨δ₁, hδpos₁, hδ₁⟩ := unif_integrable_fin μ hp hp' hF hε\n  refine' ⟨δ₁, hδpos₁, fun n s hs hμs => _⟩\n  by_cases hn : n < N\n  · exact hδ₁ ⟨n, hn⟩ s hs hμs\n  · exact (snorm_indicator_le _).trans (hN n (not_lt.1 hn))\n#align unif_integrable_of_tendsto_Lp_zero unif_integrable_of_tendsto_Lp_zero\n\n",
 "unif_integrable_of_tendsto_Lp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- Convergence in Lp implies uniform integrability. -/\ntheorem unif_integrable_of_tendsto_Lp (hp : 1 ≤ p) (hp' : p ≠ ennreal.top) (hf : ∀ n, mem_ℒp (f n) p μ)\n    (hg : mem_ℒp g p μ) (hfg : Tendsto (fun n => snorm (f n - g) p μ) atTop ((nhds) 0)) : unif_integrable f p μ :=\n  by\n  have : f = (fun n => g) + fun n => f n - g := by\n    ext1 n\n    simp\n  rw [this]\n  refine'\n    unif_integrable.add _ _ hp (fun _ => hg.ae_strongly_measurable) fun n => (hf n).1.sub hg.ae_strongly_measurable\n  · exact unif_integrable_const μ hp hp' hg\n  · exact unif_integrable_of_tendsto_Lp_zero μ hp hp' (fun n => (hf n).sub hg) hfg\n#align unif_integrable_of_tendsto_Lp unif_integrable_of_tendsto_Lp\n\n",
 "unif_integrable_of'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/-- This lemma is superceded by `unif_integrable_of` which do not require `C` to be positive. -/\ntheorem unif_integrable_of' (hp : 1 ≤ p) (hp' : p ≠ ennreal.top) {f : ι → α → β} (hf : ∀ i, strongly_measurable (f i))\n    (h :\n      ∀ ε : exprℝ,\n        0 < ε →\n          ∃ C : nnreal, 0 < C ∧ ∀ i, snorm ({ x | C ≤ «expr‖ ‖₊» (f i x) }.indicator (f i)) p μ ≤ ENNReal.ofReal ε) :\n    unif_integrable f p μ := by\n  have hpzero := (lt_of_lt_of_le zero_lt_one hp).ne.symm\n  by_cases hμ : μ Set.univ = 0\n  · rw [measure.measure_univ_eq_zero] at hμ\n    exact hμ.symm ▸ unif_integrable_zero_meas\n  intro ε hε\n  obtain ⟨C, hCpos, hC⟩ := h (ε / 2) (half_pos hε)\n  refine'\n    ⟨(ε / (2 * C)) ^ ENNReal.toReal p, real.rpow_pos_of_pos (div_pos hε (mul_pos two_pos (NNReal.coe_pos.2 hCpos))) _,\n      fun i s hs hμs => _⟩\n  by_cases hμs' : μ s = 0\n  · rw [(snorm_eq_zero_iff ((hf i).indicator hs).ae_strongly_measurable hpzero).2 (indicator_meas_zero hμs')]\n    norm_num\n  calc\n    snorm (indicator s (f i)) p μ ≤\n        snorm (indicator (s ∩ { x | C ≤ «expr‖ ‖₊» (f i x) }) (f i)) p μ +\n          snorm (indicator (s ∩ { x | «expr‖ ‖₊» (f i x) < C }) (f i)) p μ :=\n      by\n      refine'\n        le_trans (Eq.le _)\n          (snorm_add_le\n            (strongly_measurable.ae_strongly_measurable\n              ((hf i).indicator (hs.inter (strongly_measurable_const.measurable_set_le (hf i).nnnorm))))\n            (strongly_measurable.ae_strongly_measurable\n              ((hf i).indicator (hs.inter ((hf i).nnnorm.measurable_set_lt strongly_measurable_const))))\n            hp)\n      congr\n      change\n        _ = fun x =>\n          (s ∩ { x : α | C ≤ «expr‖ ‖₊» (f i x) }).indicator (f i) x +\n            (s ∩ { x : α | «expr‖ ‖₊» (f i x) < C }).indicator (f i) x\n      rw [← Set.indicator_union_of_disjoint]\n      · congr\n        rw [← inter_union_distrib_left,\n          (by\n            ext\n            simp [le_or_lt] : { x : α | C ≤ «expr‖ ‖₊» (f i x) } ∪ { x : α | «expr‖ ‖₊» (f i x) < C } = Set.univ),\n          inter_univ]\n      · refine' (Disjoint.inf_right' _ _).inf_left' _\n        rw [disjoint_iff_inf_le]\n        rintro x ⟨hx₁ : _ ≤ _, hx₂ : _ < _⟩\n        exact false.elim (hx₂.ne (eq_of_le_of_not_lt hx₁ (not_lt.2 hx₂.le)).symm)\n    _ ≤ snorm (indicator { x | C ≤ «expr‖ ‖₊» (f i x) } (f i)) p μ + C * μ s ^ (1 / ENNReal.toReal p) :=\n      by\n      refine' add_le_add (snorm_mono fun x => norm_indicator_le_of_subset (inter_subset_right _ _) _ _) _\n      rw [← indicator_indicator]\n      rw [snorm_indicator_eq_snorm_restrict]\n      have :\n        «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\"\n          (μ.restrict s) («expr‖ ‖» ({ x : α | «expr‖ ‖₊» (f i x) < C }.indicator (f i) x) ≤ C) :=\n        by\n        refine' ae_of_all _ _\n        simp_rw [norm_indicator_eq_indicator_norm]\n        exact indicator_le' (fun x (hx : _ < _) => hx.le) fun _ _ => NNReal.coe_nonneg _\n      refine' le_trans (snorm_le_of_ae_bound this) _\n      rw [mul_comm, measure.restrict_apply' hs, univ_inter, ENNReal.ofReal_coe_nnreal, one_div]\n      exacts[le_rfl, hs]\n    _ ≤ ENNReal.ofReal (ε / 2) + C * ENNReal.ofReal (ε / (2 * C)) :=\n      by\n      refine' add_le_add (hC i) (mul_le_mul_left' _ _)\n      rwa [ennreal.rpow_one_div_le_iff (ENNReal.toReal_pos hpzero hp'),\n        ennreal.of_real_rpow_of_pos (div_pos hε (mul_pos two_pos (NNReal.coe_pos.2 hCpos)))]\n    _ ≤ ENNReal.ofReal (ε / 2) + ENNReal.ofReal (ε / 2) :=\n      by\n      refine' add_le_add_left _ _\n      rw [← ENNReal.ofReal_coe_nnreal, ← ENNReal.ofReal_mul (NNReal.coe_nonneg _), ← div_div,\n        mul_div_cancel' _ (NNReal.coe_pos.2 hCpos).ne.symm]\n      exact le_rfl\n    _ ≤ ENNReal.ofReal ε :=\n      by\n      rw [← ENNReal.ofReal_add (half_pos hε).le (half_pos hε).le, add_halves]\n      exact le_rfl\n    \n#align unif_integrable_of' unif_integrable_of'\n\n",
 "unif_integrable_of":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\ntheorem unif_integrable_of (hp : 1 ≤ p) (hp' : p ≠ ennreal.top) {f : ι → α → β}\n    (hf : ∀ i, ae_strongly_measurable (f i) μ)\n    (h :\n      ∀ ε : exprℝ,\n        0 < ε → ∃ C : nnreal, ∀ i, snorm ({ x | C ≤ «expr‖ ‖₊» (f i x) }.indicator (f i)) p μ ≤ ENNReal.ofReal ε) :\n    unif_integrable f p μ := by\n  set g : ι → α → β := fun i => (hf i).some\n  refine'\n    (unif_integrable_of' μ hp hp' (fun i => (Exists.choose_spec <| hf i).1) fun ε hε => _).ae_eq fun i =>\n      (Exists.choose_spec <| hf i).2.symm\n  obtain ⟨C, hC⟩ := h ε hε\n  have hCg : ∀ i, snorm ({ x | C ≤ «expr‖ ‖₊» (g i x) }.indicator (g i)) p μ ≤ ENNReal.ofReal ε :=\n    by\n    intro i\n    refine' le_trans (le_of_eq <| snorm_congr_ae _) (hC i)\n    filter_upwards [(Exists.choose_spec <| hf i).2]with x hx\n    by_cases hfx : x ∈ { x | C ≤ «expr‖ ‖₊» (f i x) }\n    · rw [indicator_of_mem hfx, indicator_of_mem, hx]\n      rwa [mem_set_of, hx] at hfx\n    · rw [indicator_of_not_mem hfx, indicator_of_not_mem]\n      rwa [mem_set_of, hx] at hfx\n  refine' ⟨max C 1, lt_max_of_lt_right one_pos, fun i => le_trans (snorm_mono fun x => _) (hCg i)⟩\n  rw [norm_indicator_eq_indicator_norm, norm_indicator_eq_indicator_norm]\n  exact indicator_le_indicator_of_subset (fun x hx => le_trans (le_max_left _ _) hx) (fun _ => norm_nonneg _) _\n#align unif_integrable_of unif_integrable_of\n\n",
 "unif_integrable_finite":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/-- A finite sequence of Lp functions is uniformly integrable. -/\ntheorem unif_integrable_finite [Finite ι] (hp_one : 1 ≤ p) (hp_top : p ≠ ennreal.top) {f : ι → α → β}\n    (hf : ∀ i, mem_ℒp (f i) p μ) : unif_integrable f p μ :=\n  by\n  obtain ⟨n, hn⟩ := Finite.exists_equiv_fin ι\n  intro ε hε\n  set g : Fin n → α → β := f ∘ hn.some.symm with hgeq\n  have hg : ∀ i, mem_ℒp (g i) p μ := fun _ => hf _\n  obtain ⟨δ, hδpos, hδ⟩ := unif_integrable_fin μ hp_one hp_top hg hε\n  refine' ⟨δ, hδpos, fun i s hs hμs => _⟩\n  specialize hδ (hn.some i) s hs hμs\n  simp_rw [hgeq, Function.comp_apply, Equiv.symm_apply_apply] at hδ\n  assumption\n#align unif_integrable_finite unif_integrable_finite\n\n",
 "unif_integrable_fin":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/-- This lemma is less general than `measure_theory.unif_integrable_fintype` which applies to\nall sequences indexed by a finite type. -/\ntheorem unif_integrable_fin (hp_one : 1 ≤ p) (hp_top : p ≠ ennreal.top) {n : ℕ} {f : Fin n → α → β}\n    (hf : ∀ i, mem_ℒp (f i) p μ) : unif_integrable f p μ :=\n  by\n  revert f\n  induction' n with n h\n  · exact fun f hf => unif_integrable_subsingleton μ hp_one hp_top hf\n  intro f hfLp ε hε\n  set g : Fin n → α → β := fun k => f k with hg\n  have hgLp : ∀ i, mem_ℒp (g i) p μ := fun i => hfLp i\n  obtain ⟨δ₁, hδ₁pos, hδ₁⟩ := h hgLp hε\n  obtain ⟨δ₂, hδ₂pos, hδ₂⟩ := (hfLp n).snorm_indicator_le μ hp_one hp_top hε\n  refine' ⟨min δ₁ δ₂, lt_min hδ₁pos hδ₂pos, fun i s hs hμs => _⟩\n  by_cases hi : i.val < n\n  · rw [(_ : f i = g ⟨i.val, hi⟩)]\n    · exact hδ₁ _ s hs (le_trans hμs <| ENNReal.ofReal_le_ofReal <| min_le_left _ _)\n    · rw [hg]\n      simp\n  · rw [(_ : i = n)]\n    · exact hδ₂ _ hs (le_trans hμs <| ENNReal.ofReal_le_ofReal <| min_le_right _ _)\n    · have hi' := Fin.is_lt i\n      rw [Nat.lt_succ_iff] at hi'\n      rw [not_lt] at hi\n      simp [← le_antisymm hi' hi]\n#align unif_integrable_fin unif_integrable_fin\n\n",
 "unif_integrable_const":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/-- A constant function is uniformly integrable. -/\ntheorem unif_integrable_const {g : α → β} (hp : 1 ≤ p) (hp_ne_top : p ≠ ennreal.top) (hg : mem_ℒp g p μ) :\n    unif_integrable (fun n : ι => g) p μ := by\n  intro ε hε\n  obtain ⟨δ, hδ_pos, hgδ⟩ := hg.snorm_indicator_le μ hp hp_ne_top hε\n  exact ⟨δ, hδ_pos, fun i => hgδ⟩\n#align unif_integrable_const unif_integrable_const\n\n",
 "unif_integrable_congr_ae":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\ntheorem unif_integrable_congr_ae {p : ennreal} {f g : ι → α → β} (hfg : ∀ n, «expr =ᵐ[ ] » (f n) μ (g n)) :\n    unif_integrable f p μ ↔ unif_integrable g p μ :=\n  ⟨fun hf => hf.ae_eq hfg, fun hg => hg.ae_eq fun n => (hfg n).symm⟩\n#align unif_integrable_congr_ae unif_integrable_congr_ae\n\n",
 "unif_integrable":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\nprotected theorem unif_integrable {f : ι → α → β} {p : ennreal} (hf : uniform_integrable f p μ) :\n    unif_integrable f p μ :=\n  hf.2.1\n#align unif_integrable unif_integrable\n\n",
 "tendsto_indicator_ge":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem tendsto_indicator_ge (f : α → β) (x : α) :\n    Tendsto (fun M : ℕ => { x | (M : exprℝ) ≤ «expr‖ ‖₊» (f x) }.indicator f x) atTop ((nhds) 0) :=\n  by\n  refine' @tendsto_atTop_of_eventually_const _ _ _ _ _ _ _ (Nat.ceil («expr‖ ‖₊» (f x) : exprℝ) + 1) fun n hn => _\n  rw [indicator_of_not_mem]\n  simp only [not_le, mem_set_of_eq]\n  refine' lt_of_le_of_lt (Nat.le_ceil _) _\n  refine' lt_of_lt_of_le (lt_add_one _) _\n  norm_cast\n  rwa [ge_iff_le, coe_nnnorm] at hn\n#align tendsto_indicator_ge tendsto_indicator_ge\n\n",
 "tendsto_in_measure_iff_tendsto_Lp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- **Vitali's convergence theorem**: A sequence of functions `f` converges to `g` in Lp if and\nonly if it is uniformly integrable and converges to `g` in measure. -/\ntheorem tendsto_in_measure_iff_tendsto_Lp [FiniteMeasure μ] (hp : 1 ≤ p) (hp' : p ≠ ennreal.top)\n    (hf : ∀ n, mem_ℒp (f n) p μ) (hg : mem_ℒp g p μ) :\n    tendsto_in_measure μ f atTop g ∧ unif_integrable f p μ ↔ Tendsto (fun n => snorm (f n - g) p μ) atTop ((nhds) 0) :=\n  ⟨fun h => tendsto_Lp_of_tendsto_in_measure μ hp hp' (fun n => (hf n).1) hg h.2 h.1, fun h =>\n    ⟨tendsto_in_measure_of_tendsto_snorm (lt_of_lt_of_le zero_lt_one hp).ne.symm\n        (fun n => (hf n).ae_strongly_measurable) hg.ae_strongly_measurable h,\n      unif_integrable_of_tendsto_Lp μ hp hp' hf hg h⟩⟩\n#align tendsto_in_measure_iff_tendsto_Lp tendsto_in_measure_iff_tendsto_Lp\n\n",
 "tendsto_Lp_of_tendsto_in_measure":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- Forward direction of Vitali's convergence theorem: if `f` is a sequence of uniformly integrable\nfunctions that converge in measure to some function `g` in a finite measure space, then `f`\nconverge in Lp to `g`. -/\ntheorem tendsto_Lp_of_tendsto_in_measure [FiniteMeasure μ] (hp : 1 ≤ p) (hp' : p ≠ ennreal.top)\n    (hf : ∀ n, ae_strongly_measurable (f n) μ) (hg : mem_ℒp g p μ) (hui : unif_integrable f p μ)\n    (hfg : tendsto_in_measure μ f atTop g) : Tendsto (fun n => snorm (f n - g) p μ) atTop ((nhds) 0) :=\n  by\n  refine' tendsto_of_subseq_tendsto fun ns hns => _\n  obtain ⟨ms, hms, hms'⟩ := tendsto_in_measure.exists_seq_tendsto_ae fun ε hε => (hfg ε hε).comp hns\n  exact\n    ⟨ms,\n      tendsto_Lp_of_tendsto_ae μ hp hp' (fun _ => hf _) hg\n        (fun ε hε =>\n          let ⟨δ, hδ, hδ'⟩ := hui hε\n          ⟨δ, hδ, fun i s hs hμs => hδ' _ s hs hμs⟩)\n        hms'⟩\n#align tendsto_Lp_of_tendsto_in_measure tendsto_Lp_of_tendsto_in_measure\n\n",
 "tendsto_Lp_of_tendsto_ae_of_meas":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- A sequence of uniformly integrable functions which converges μ-a.e. converges in Lp. -/\ntheorem tendsto_Lp_of_tendsto_ae_of_meas [FiniteMeasure μ] (hp : 1 ≤ p) (hp' : p ≠ ennreal.top) {f : ℕ → α → β}\n    {g : α → β} (hf : ∀ n, strongly_measurable (f n)) (hg : strongly_measurable g) (hg' : mem_ℒp g p μ)\n    (hui : unif_integrable f p μ)\n    (hfg :\n      «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\" μ\n        (Tendsto (fun n => f n x) atTop ((nhds) (g x)))) :\n    Tendsto (fun n => snorm (f n - g) p μ) atTop ((nhds) 0) :=\n  by\n  rw [ENNReal.tendsto_atTop_zero]\n  intro ε hε\n  by_cases ε < ennreal.top\n  swap\n  · rw [not_lt, top_le_iff] at h\n    exact ⟨0, fun n hn => by simp [h]⟩\n  by_cases hμ : μ = 0\n  · exact ⟨0, fun n hn => by simp [hμ]⟩\n  have hε' : 0 < ε.to_real / 3 := div_pos (ENNReal.toReal_pos (gt_iff_lt.1 hε).ne.symm h.ne) (by norm_num)\n  have hdivp : 0 ≤ 1 / p.to_real := by\n    refine' one_div_nonneg.2 _\n    rw [← ENNReal.zero_toReal, ENNReal.toReal_le_toReal ENNReal.zero_ne_top hp']\n    exact le_trans (zero_le _) hp\n  have hpow : 0 < measure_univ_nnreal μ ^ (1 / p.to_real) := real.rpow_pos_of_pos (measure_univ_nnreal_pos hμ) _\n  obtain ⟨δ₁, hδ₁, hsnorm₁⟩ := hui hε'\n  obtain ⟨δ₂, hδ₂, hsnorm₂⟩ := hg'.snorm_indicator_le μ hp hp' hε'\n  obtain ⟨t, htm, ht₁, ht₂⟩ := tendsto_uniformly_on_of_ae_tendsto' hf hg hfg (lt_min hδ₁ hδ₂)\n  rw [Metric.tendstoUniformlyOn_iff] at ht₂\n  specialize\n    ht₂ (ε.to_real / (3 * measure_univ_nnreal μ ^ (1 / p.to_real)))\n      (div_pos (ENNReal.toReal_pos (gt_iff_lt.1 hε).ne.symm h.ne) (mul_pos (by norm_num) hpow))\n  obtain ⟨N, hN⟩ := eventually_at_top.1 ht₂\n  clear ht₂\n  refine' ⟨N, fun n hn => _⟩\n  rw [← t.indicator_self_add_compl (f n - g)]\n  refine'\n    le_trans\n      (snorm_add_le (((hf n).sub hg).indicator htm).ae_strongly_measurable\n        (((hf n).sub hg).indicator htm.compl).ae_strongly_measurable hp)\n      _\n  rw [sub_eq_add_neg, indicator_add' t, indicator_neg']\n  refine'\n    le_trans\n      (add_le_add_right\n        (snorm_add_le ((hf n).indicator htm).ae_strongly_measurable (hg.indicator htm).neg.ae_strongly_measurable hp) _)\n      _\n  have hnf : snorm (t.indicator (f n)) p μ ≤ ENNReal.ofReal (ε.to_real / 3) :=\n    by\n    refine' hsnorm₁ n t htm (le_trans ht₁ _)\n    rw [ENNReal.ofReal_le_ofReal_iff hδ₁.le]\n    exact min_le_left _ _\n  have hng : snorm (t.indicator g) p μ ≤ ENNReal.ofReal (ε.to_real / 3) :=\n    by\n    refine' hsnorm₂ t htm (le_trans ht₁ _)\n    rw [ENNReal.ofReal_le_ofReal_iff hδ₂.le]\n    exact min_le_right _ _\n  have hlt : snorm ((«expr ᶜ» t).indicator (f n - g)) p μ ≤ ENNReal.ofReal (ε.to_real / 3) :=\n    by\n    specialize hN n hn\n    have :=\n      snorm_sub_le_of_dist_bdd μ hp' htm.compl _ fun x hx =>\n        (dist_comm (g x) (f n x) ▸ (hN x hx).le :\n          dist (f n x) (g x) ≤ ε.to_real / (3 * measure_univ_nnreal μ ^ (1 / p.to_real)))\n    refine' le_trans this _\n    rw [div_mul_eq_div_mul_one_div, ← ENNReal.ofReal_toReal (measure_lt_top μ («expr ᶜ» t)).ne,\n      ennreal.of_real_rpow_of_nonneg ENNReal.toReal_nonneg hdivp, ← ENNReal.ofReal_mul, mul_assoc]\n    · refine' ENNReal.ofReal_le_ofReal (mul_le_of_le_one_right hε'.le _)\n      rw [mul_comm, mul_one_div, div_le_one]\n      · refine'\n          real.rpow_le_rpow ENNReal.toReal_nonneg (ENNReal.toReal_le_of_le_ofReal (measure_univ_nnreal_pos hμ).le _)\n            hdivp\n        rw [ENNReal.ofReal_coe_nnreal, coe_measure_univ_nnreal]\n        exact measure_mono (subset_univ _)\n      · exact real.rpow_pos_of_pos (measure_univ_nnreal_pos hμ) _\n    · refine' mul_nonneg hε'.le (one_div_nonneg.2 hpow.le)\n    · rw [div_mul_eq_div_mul_one_div]\n      exact mul_nonneg hε'.le (one_div_nonneg.2 hpow.le)\n  have : ENNReal.ofReal (ε.to_real / 3) = ε / 3 :=\n    by\n    rw [ENNReal.ofReal_div_of_pos (show (0 : exprℝ) < 3 by norm_num), ENNReal.ofReal_toReal h.ne]\n    simp\n  rw [this] at hnf hng hlt\n  rw [snorm_neg, ← ENNReal.add_thirds ε, ← sub_eq_add_neg]\n  exact add_le_add_three hnf hng hlt\n#align tendsto_Lp_of_tendsto_ae_of_meas tendsto_Lp_of_tendsto_ae_of_meas\n\n",
 "tendsto_Lp_of_tendsto_ae":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- A sequence of uniformly integrable functions which converges μ-a.e. converges in Lp. -/\ntheorem tendsto_Lp_of_tendsto_ae [FiniteMeasure μ] (hp : 1 ≤ p) (hp' : p ≠ ennreal.top) {f : ℕ → α → β} {g : α → β}\n    (hf : ∀ n, ae_strongly_measurable (f n) μ) (hg : mem_ℒp g p μ) (hui : unif_integrable f p μ)\n    (hfg :\n      «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\" μ\n        (Tendsto (fun n => f n x) atTop ((nhds) (g x)))) :\n    Tendsto (fun n => snorm (f n - g) p μ) atTop ((nhds) 0) :=\n  by\n  suffices tendsto (fun n : ℕ => snorm ((hf n).mk (f n) - hg.1.mk g) p μ) at_top ((nhds) 0)\n    by\n    convert this\n    exact funext fun n => snorm_congr_ae ((hf n).ae_eq_mk.sub hg.1.ae_eq_mk)\n  refine'\n    tendsto_Lp_of_tendsto_ae_of_meas μ hp hp' (fun n => (hf n).strongly_measurable_mk) hg.1.strongly_measurable_mk\n      (hg.ae_eq hg.1.ae_eq_mk) (hui.ae_eq fun n => (hf n).ae_eq_mk) _\n  have h_ae_forall_eq :\n    «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\" μ\n      (∀ n, f n x = (hf n).mk (f n) x) :=\n    by\n    rw [ae_all_iff]\n    exact fun n => (hf n).ae_eq_mk\n  filter_upwards [hfg, h_ae_forall_eq, hg.1.ae_eq_mk]with x hx_tendsto hxf_eq hxg_eq\n  rw [← hxg_eq]\n  convert hx_tendsto\n  ext1 n\n  exact (hxf_eq n).symm\n#align tendsto_Lp_of_tendsto_ae tendsto_Lp_of_tendsto_ae\n\n",
 "sub":
 "protected theorem sub (hf : unif_integrable f p μ) (hg : unif_integrable g p μ) (hp : 1 ≤ p)\n    (hf_meas : ∀ i, ae_strongly_measurable (f i) μ) (hg_meas : ∀ i, ae_strongly_measurable (g i) μ) :\n    unif_integrable (f - g) p μ := by\n  rw [sub_eq_add_neg]\n  exact hf.add hg.neg hp hf_meas fun i => (hg_meas i).neg\n#align sub sub\n\n",
 "spec'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/-- This lemma is superceded by `uniform_integrable.spec` which does not require measurability. -/\ntheorem uniform_integrable.spec' (hp : p ≠ 0) (hp' : p ≠ ennreal.top) (hf : ∀ i, strongly_measurable (f i))\n    (hfu : uniform_integrable f p μ) {ε : exprℝ} (hε : 0 < ε) :\n    ∃ C : nnreal, ∀ i, snorm ({ x | C ≤ «expr‖ ‖₊» (f i x) }.indicator (f i)) p μ ≤ ENNReal.ofReal ε :=\n  by\n  obtain ⟨-, hfu, M, hM⟩ := hfu\n  obtain ⟨δ, hδpos, hδ⟩ := hfu hε\n  obtain ⟨C, hC⟩ : ∃ C : nnreal, ∀ i, μ { x | C ≤ «expr‖ ‖₊» (f i x) } ≤ ENNReal.ofReal δ :=\n    by\n    by_contra hcon\n    push_neg  at hcon\n    choose ℐ hℐ using hcon\n    lift δ to nnreal using hδpos.le\n    have : ∀ C : nnreal, «expr • » C ((δ : ennreal) ^ (1 / p.to_real)) ≤ snorm (f (ℐ C)) p μ :=\n      by\n      intro C\n      calc\n        «expr • » C ((δ : ennreal) ^ (1 / p.to_real)) ≤\n            «expr • » C (μ { x | C ≤ «expr‖ ‖₊» (f (ℐ C) x) } ^ (1 / p.to_real)) :=\n          by\n          rw [ENNReal.smul_def, ENNReal.smul_def, smul_eq_mul, smul_eq_mul]\n          simp_rw [ENNReal.ofReal_coe_nnreal] at hℐ\n          refine' mul_le_mul' le_rfl (ennreal.rpow_le_rpow (hℐ C).le (one_div_nonneg.2 ENNReal.toReal_nonneg))\n        _ ≤ snorm ({ x | C ≤ «expr‖ ‖₊» (f (ℐ C) x) }.indicator (f (ℐ C))) p μ :=\n          by\n          refine'\n            snorm_indicator_ge_of_bdd_below hp hp' _ (measurable_set_le measurable_const (hf _).nnnorm.measurable)\n              (eventually_of_forall fun x hx => _)\n          rwa [nnnorm_indicator_eq_indicator_nnnorm, indicator_of_mem hx]\n        _ ≤ snorm (f (ℐ C)) p μ := snorm_indicator_le _\n        \n    specialize this (2 * max M 1 * δ⁻¹ ^ (1 / p.to_real))\n    rw [ennreal.coe_rpow_of_nonneg _ (one_div_nonneg.2 ENNReal.toReal_nonneg), ← ENNReal.coe_smul, smul_eq_mul,\n      mul_assoc, nnreal.inv_rpow, inv_mul_cancel (nnreal.rpow_pos (NNReal.coe_pos.1 hδpos)).ne.symm, mul_one,\n      ENNReal.coe_mul, ← nnreal.inv_rpow] at this\n    refine'\n      (lt_of_le_of_lt (le_trans (hM <| ℐ <| 2 * max M 1 * δ⁻¹ ^ (1 / p.to_real)) (le_max_left M 1))\n            (lt_of_lt_of_le _ this)).ne\n        rfl\n    rw [← ENNReal.coe_one, ← WithTop.coe_max, ← ENNReal.coe_mul, ENNReal.coe_lt_coe]\n    exact lt_two_mul_self (lt_max_of_lt_right one_pos)\n  exact ⟨C, fun i => hδ i _ (measurable_set_le measurable_const (hf i).nnnorm.measurable) (hC i)⟩\n#align uniform_integrable.spec' uniform_integrable.spec'\n\n",
 "spec":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\ntheorem uniform_integrable.spec (hp : p ≠ 0) (hp' : p ≠ ennreal.top) (hfu : uniform_integrable f p μ) {ε : exprℝ}\n    (hε : 0 < ε) : ∃ C : nnreal, ∀ i, snorm ({ x | C ≤ «expr‖ ‖₊» (f i x) }.indicator (f i)) p μ ≤ ENNReal.ofReal ε :=\n  by\n  set g : ι → α → β := fun i => (hfu.1 i).some\n  have hgmeas : ∀ i, strongly_measurable (g i) := fun i => (Exists.choose_spec <| hfu.1 i).1\n  have hgunif : uniform_integrable g p μ := hfu.ae_eq fun i => (Exists.choose_spec <| hfu.1 i).2\n  obtain ⟨C, hC⟩ := hgunif.spec' hp hp' hgmeas hε\n  refine' ⟨C, fun i => le_trans (le_of_eq <| snorm_congr_ae _) (hC i)⟩\n  filter_upwards [(Exists.choose_spec <| hfu.1 i).2]with x hx\n  by_cases hfx : x ∈ { x | C ≤ «expr‖ ‖₊» (f i x) }\n  · rw [indicator_of_mem hfx, indicator_of_mem, hx]\n    rwa [mem_set_of, hx] at hfx\n  · rw [indicator_of_not_mem hfx, indicator_of_not_mem]\n    rwa [mem_set_of, hx] at hfx\n#align uniform_integrable.spec uniform_integrable.spec\n\n",
 "snorm_sub_le_of_dist_bdd":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem snorm_sub_le_of_dist_bdd {p : ennreal} (hp' : p ≠ ennreal.top) {s : Set α} (hs : (measurable_set_of m) s)\n    {f g : α → β} {c : exprℝ} (hc : 0 ≤ c) (hf : ∀ x ∈ s, dist (f x) (g x) ≤ c) :\n    snorm (s.indicator (f - g)) p μ ≤ ENNReal.ofReal c * μ s ^ (1 / p.to_real) :=\n  by\n  by_cases hp : p = 0\n  · simp [hp]\n  have : ∀ x, «expr‖ ‖» (s.indicator (f - g) x) ≤ «expr‖ ‖» (s.indicator (fun x => c) x) :=\n    by\n    intro x\n    by_cases hx : x ∈ s\n    · rw [indicator_of_mem hx, indicator_of_mem hx, Pi.sub_apply, ← dist_eq_norm, Real.norm_eq_abs, abs_of_nonneg hc]\n      exact hf x hx\n    · simp [indicator_of_not_mem hx]\n  refine' le_trans (snorm_mono this) _\n  rw [snorm_indicator_const hs hp hp']\n  refine' mul_le_mul_right' (le_of_eq _) _\n  rw [← ofReal_norm_eq_coe_nnnorm, Real.norm_eq_abs, abs_of_nonneg hc]\n#align snorm_sub_le_of_dist_bdd snorm_sub_le_of_dist_bdd\n\n",
 "snorm_indicator_norm_ge_pos_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/-- This lemma implies that a single function is uniformly integrable (in the probability sense). -/\ntheorem mem_ℒp.snorm_indicator_norm_ge_pos_le (hf : mem_ℒp f p μ) (hmeas : strongly_measurable f) {ε : exprℝ}\n    (hε : 0 < ε) : ∃ M : exprℝ, 0 < M ∧ snorm ({ x | M ≤ «expr‖ ‖₊» (f x) }.indicator f) p μ ≤ ENNReal.ofReal ε :=\n  by\n  obtain ⟨M, hM⟩ := hf.snorm_indicator_norm_ge_le μ hmeas hε\n  refine' ⟨max M 1, lt_of_lt_of_le zero_lt_one (le_max_right _ _), le_trans (snorm_mono fun x => _) hM⟩\n  rw [norm_indicator_eq_indicator_norm, norm_indicator_eq_indicator_norm]\n  refine' indicator_le_indicator_of_subset (fun x hx => _) (fun x => norm_nonneg _) x\n  change max _ _ ≤ _ at hx\n  -- removing the `change` breaks the proof!\n  exact (max_le_iff.1 hx).1\n#align mem_ℒp.snorm_indicator_norm_ge_pos_le mem_ℒp.snorm_indicator_norm_ge_pos_le\n\n",
 "snorm_indicator_norm_ge_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- This lemma is slightly weaker than `measure_theory.mem_ℒp.snorm_indicator_norm_ge_pos_le` as the\nlatter provides `0 < M`. -/\ntheorem mem_ℒp.snorm_indicator_norm_ge_le (hf : mem_ℒp f p μ) (hmeas : strongly_measurable f) {ε : exprℝ} (hε : 0 < ε) :\n    ∃ M : exprℝ, snorm ({ x | M ≤ «expr‖ ‖₊» (f x) }.indicator f) p μ ≤ ENNReal.ofReal ε :=\n  by\n  by_cases hp_ne_zero : p = 0\n  · refine' ⟨1, hp_ne_zero.symm ▸ _⟩\n    simp [snorm_exponent_zero]\n  by_cases hp_ne_top : p = ennreal.top\n  · subst hp_ne_top\n    obtain ⟨M, hM⟩ := hf.snorm_ess_sup_indicator_norm_ge_eq_zero μ hmeas\n    refine' ⟨M, _⟩\n    simp only [snorm_exponent_top, hM, zero_le]\n  obtain ⟨M, hM', hM⟩ :=\n    @mem_ℒp.integral_indicator_norm_ge_nonneg_le _ _ _ μ _ (fun x => «expr‖ ‖» (f x) ^ p.to_real)\n      (hf.norm_rpow hp_ne_zero hp_ne_top) _ (real.rpow_pos_of_pos hε p.to_real)\n  refine' ⟨M ^ (1 / p.to_real), _⟩\n  rw [snorm_eq_lintegral_rpow_nnnorm hp_ne_zero hp_ne_top, ← ennreal.rpow_one (ENNReal.ofReal ε)]\n  conv_rhs => rw [← mul_one_div_cancel (ENNReal.toReal_pos hp_ne_zero hp_ne_top).ne.symm]\n  rw [ennreal.rpow_mul, ennreal.rpow_le_rpow_iff (one_div_pos.2 <| ENNReal.toReal_pos hp_ne_zero hp_ne_top),\n    ennreal.of_real_rpow_of_pos hε]\n  convert hM\n  ext1 x\n  rw [ennreal.coe_rpow_of_nonneg _ ENNReal.toReal_nonneg, nnnorm_indicator_eq_indicator_nnnorm,\n    nnnorm_indicator_eq_indicator_nnnorm]\n  have hiff : M ^ (1 / p.to_real) ≤ «expr‖ ‖₊» (f x) ↔ M ≤ «expr‖ ‖₊» («expr‖ ‖» (f x) ^ p.to_real) := by\n    rw [coe_nnnorm, coe_nnnorm, real.norm_rpow_of_nonneg (norm_nonneg _), norm_norm, ←\n      real.rpow_le_rpow_iff hM' (real.rpow_nonneg_of_nonneg (norm_nonneg _) _)\n        (one_div_pos.2 <| ENNReal.toReal_pos hp_ne_zero hp_ne_top),\n      ← real.rpow_mul (norm_nonneg _), mul_one_div_cancel (ENNReal.toReal_pos hp_ne_zero hp_ne_top).ne.symm,\n      real.rpow_one]\n  by_cases hx : x ∈ { x : α | M ^ (1 / p.to_real) ≤ «expr‖ ‖₊» (f x) }\n  · rw [Set.indicator_of_mem hx, Set.indicator_of_mem, Real.nnnorm_of_nonneg]\n    rfl\n    change _ ≤ _\n    rwa [← hiff]\n  · rw [Set.indicator_of_not_mem hx, Set.indicator_of_not_mem]\n    · simp [(ENNReal.toReal_pos hp_ne_zero hp_ne_top).ne.symm]\n    · change ¬_ ≤ _\n      rwa [← hiff]\n#align mem_ℒp.snorm_indicator_norm_ge_le mem_ℒp.snorm_indicator_norm_ge_le\n\n",
 "snorm_indicator_le_of_meas":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- This lemma is superceded by `measure_theory.mem_ℒp.snorm_indicator_le` which does not require\nmeasurability on `f`. -/\ntheorem mem_ℒp.snorm_indicator_le_of_meas (hp_one : 1 ≤ p) (hp_top : p ≠ ennreal.top) (hf : mem_ℒp f p μ)\n    (hmeas : strongly_measurable f) {ε : exprℝ} (hε : 0 < ε) :\n    ∃ (δ : exprℝ)(hδ : 0 < δ),\n      ∀ s, MeasurableSet s → μ s ≤ ENNReal.ofReal δ → snorm (s.indicator f) p μ ≤ ENNReal.ofReal ε :=\n  by\n  obtain ⟨δ, hδpos, hδ⟩ := hf.snorm_indicator_le' μ hp_one hp_top hmeas (half_pos hε)\n  refine' ⟨δ, hδpos, fun s hs hμs => le_trans (hδ s hs hμs) _⟩\n  rw [ENNReal.ofReal_div_of_pos zero_lt_two, (by norm_num : ENNReal.ofReal 2 = 2), ENNReal.mul_div_cancel'] <;> norm_num\n#align mem_ℒp.snorm_indicator_le_of_meas mem_ℒp.snorm_indicator_le_of_meas\n\n",
 "snorm_indicator_le_of_bound":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:72:38: in filter_upwards #[[], [], []]: ./././Mathport/Syntax/Translate/Basic.lean:349:22: unsupported: parse error @ arg 0: next failed, no more args -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem snorm_indicator_le_of_bound {f : α → β} (hp_top : p ≠ ennreal.top) {ε : exprℝ} (hε : 0 < ε) {M : exprℝ}\n    (hf : ∀ x, «expr‖ ‖» (f x) < M) :\n    ∃ (δ : exprℝ)(hδ : 0 < δ),\n      ∀ s, MeasurableSet s → μ s ≤ ENNReal.ofReal δ → snorm (s.indicator f) p μ ≤ ENNReal.ofReal ε :=\n  by\n  by_cases hM : M ≤ 0\n  · refine' ⟨1, zero_lt_one, fun s hs hμ => _⟩\n    rw [(_ : f = 0)]\n    · simp [hε.le]\n    · ext x\n      rw [Pi.zero_apply, ← norm_le_zero_iff]\n      exact (lt_of_lt_of_le (hf x) hM).le\n  rw [not_le] at hM\n  refine' ⟨(ε / M) ^ p.to_real, real.rpow_pos_of_pos (div_pos hε hM) _, fun s hs hμ => _⟩\n  by_cases hp : p = 0\n  · simp [hp]\n  rw [snorm_indicator_eq_snorm_restrict hs]\n  have haebdd :\n    «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\" (μ.restrict s)\n      («expr‖ ‖» (f x) ≤ M) :=\n    by\n    trace\n      \"./././Mathport/Syntax/Translate/Tactic/Builtin.lean:72:38: in filter_upwards #[[], [], []]: ./././Mathport/Syntax/Translate/Basic.lean:349:22: unsupported: parse error @ arg 0: next failed, no more args\"\n    exact fun x => (hf x).le\n  refine' le_trans (snorm_le_of_ae_bound haebdd) _\n  rw [measure.restrict_apply MeasurableSet.univ, univ_inter, ←\n    ENNReal.le_div_iff_mul_le (or.inl _) (or.inl ENNReal.ofReal_ne_top)]\n  · rw [← one_div, ennreal.rpow_one_div_le_iff (ENNReal.toReal_pos hp hp_top)]\n    refine' le_trans hμ _\n    rw [← ennreal.of_real_rpow_of_pos (div_pos hε hM), ennreal.rpow_le_rpow_iff (ENNReal.toReal_pos hp hp_top),\n      ENNReal.ofReal_div_of_pos hM]\n    exact le_rfl\n  · simpa only [ENNReal.ofReal_eq_zero, not_le, ne.def]\n#align snorm_indicator_le_of_bound snorm_indicator_le_of_bound\n\n",
 "snorm_indicator_le'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- Auxiliary lemma for `measure_theory.mem_ℒp.snorm_indicator_le`. -/\ntheorem mem_ℒp.snorm_indicator_le' (hp_one : 1 ≤ p) (hp_top : p ≠ ennreal.top) (hf : mem_ℒp f p μ)\n    (hmeas : strongly_measurable f) {ε : exprℝ} (hε : 0 < ε) :\n    ∃ (δ : exprℝ)(hδ : 0 < δ),\n      ∀ s, MeasurableSet s → μ s ≤ ENNReal.ofReal δ → snorm (s.indicator f) p μ ≤ 2 * ENNReal.ofReal ε :=\n  by\n  obtain ⟨M, hMpos, hM⟩ := hf.snorm_indicator_norm_ge_pos_le μ hmeas hε\n  obtain ⟨δ, hδpos, hδ⟩ :=\n    @snorm_indicator_le_of_bound _ _ _ μ _ _ ({ x | «expr‖ ‖» (f x) < M }.indicator f) hp_top _ hε M _\n  · refine' ⟨δ, hδpos, fun s hs hμs => _⟩\n    rw [(_ : f = { x : α | M ≤ «expr‖ ‖₊» (f x) }.indicator f + { x : α | «expr‖ ‖» (f x) < M }.indicator f)]\n    · rw [snorm_indicator_eq_snorm_restrict hs]\n      refine' le_trans (snorm_add_le _ _ hp_one) _\n      ·\n        exact\n          strongly_measurable.ae_strongly_measurable\n            (hmeas.indicator (measurable_set_le measurable_const hmeas.nnnorm.measurable.subtype_coe))\n      ·\n        exact\n          strongly_measurable.ae_strongly_measurable\n            (hmeas.indicator (measurable_set_lt hmeas.nnnorm.measurable.subtype_coe measurable_const))\n      · rw [two_mul]\n        refine' add_le_add (le_trans (snorm_mono_measure _ measure.restrict_le_self) hM) _\n        rw [← snorm_indicator_eq_snorm_restrict hs]\n        exact hδ s hs hμs\n    · ext x\n      by_cases hx : M ≤ «expr‖ ‖» (f x)\n      · rw [Pi.add_apply, indicator_of_mem, indicator_of_not_mem, add_zero] <;> simpa\n      · rw [Pi.add_apply, indicator_of_not_mem, indicator_of_mem, zero_add] <;> simpa using hx\n  · intro x\n    rw [norm_indicator_eq_indicator_norm, indicator_apply]\n    split_ifs\n    exacts[h, hMpos]\n#align mem_ℒp.snorm_indicator_le' mem_ℒp.snorm_indicator_le'\n\n",
 "snorm_indicator_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem mem_ℒp.snorm_indicator_le (hp_one : 1 ≤ p) (hp_top : p ≠ ennreal.top) (hf : mem_ℒp f p μ) {ε : exprℝ}\n    (hε : 0 < ε) :\n    ∃ (δ : exprℝ)(hδ : 0 < δ),\n      ∀ s, MeasurableSet s → μ s ≤ ENNReal.ofReal δ → snorm (s.indicator f) p μ ≤ ENNReal.ofReal ε :=\n  by\n  have hℒp := hf\n  obtain ⟨⟨f', hf', heq⟩, hnorm⟩ := hf\n  obtain ⟨δ, hδpos, hδ⟩ := (hℒp.ae_eq HEq).snorm_indicator_le_of_meas μ hp_one hp_top hf' hε\n  refine' ⟨δ, hδpos, fun s hs hμs => _⟩\n  convert hδ s hs hμs using 1\n  rw [snorm_indicator_eq_snorm_restrict hs, snorm_indicator_eq_snorm_restrict hs]\n  refine' snorm_congr_ae heq.restrict\n#align mem_ℒp.snorm_indicator_le mem_ℒp.snorm_indicator_le\n\n",
 "snorm_ess_sup_indicator_norm_ge_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\ntheorem mem_ℒp.snorm_ess_sup_indicator_norm_ge_eq_zero (hf : mem_ℒp f (ennreal.top) μ) (hmeas : strongly_measurable f) :\n    ∃ M : exprℝ, snorm_ess_sup ({ x | M ≤ «expr‖ ‖₊» (f x) }.indicator f) μ = 0 :=\n  by\n  have hbdd : snorm_ess_sup f μ < ennreal.top := hf.snorm_lt_top\n  refine' ⟨(snorm f (ennreal.top) μ + 1).to_real, _⟩\n  rw [snorm_ess_sup_indicator_eq_snorm_ess_sup_restrict]\n  have : μ.restrict { x : α | (snorm f («expr⊤») μ + 1).to_real ≤ «expr‖ ‖₊» (f x) } = 0 :=\n    by\n    simp only [coe_nnnorm, snorm_exponent_top, measure.restrict_eq_zero]\n    have :\n      { x : α | (snorm_ess_sup f μ + 1).to_real ≤ «expr‖ ‖» (f x) } ⊆\n        { x : α | snorm_ess_sup f μ < «expr‖ ‖₊» (f x) } :=\n      by\n      intro x hx\n      rw [mem_set_of_eq, ← ENNReal.toReal_lt_toReal hbdd.ne ennreal.coe_lt_top.ne, ENNReal.coe_toReal, coe_nnnorm]\n      refine' lt_of_lt_of_le _ hx\n      rw [ENNReal.toReal_lt_toReal hbdd.ne]\n      · exact ENNReal.lt_add_right hbdd.ne one_ne_zero\n      · exact (ENNReal.add_lt_top.2 ⟨hbdd, ENNReal.one_lt_top⟩).ne\n    rw [← nonpos_iff_eq_zero]\n    refine' (measure_mono this).trans _\n    have hle := coe_nnnorm_ae_le_snorm_ess_sup f μ\n    simp_rw [ae_iff, not_le] at hle\n    exact nonpos_iff_eq_zero.2 hle\n  rw [this, snorm_ess_sup_measure_zero]\n  exact measurable_set_le measurable_const hmeas.nnnorm.measurable.subtype_coe\n#align mem_ℒp.snorm_ess_sup_indicator_norm_ge_eq_zero mem_ℒp.snorm_ess_sup_indicator_norm_ge_eq_zero\n\n",
 "neg":
 "protected theorem neg (hf : unif_integrable f p μ) : unif_integrable (-f) p μ :=\n  by\n  simp_rw [unif_integrable, Pi.neg_apply, indicator_neg', snorm_neg]\n  exact hf\n#align neg neg\n\n",
 "mem_ℒp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\nprotected theorem mem_ℒp {f : ι → α → β} {p : ennreal} (hf : uniform_integrable f p μ) (i : ι) : mem_ℒp (f i) p μ :=\n  ⟨hf.1 i,\n    let ⟨_, _, hC⟩ := hf.2\n    lt_of_le_of_lt (hC i) ENNReal.coe_lt_top⟩\n#align mem_ℒp mem_ℒp\n\n",
 "integral_indicator_norm_ge_nonneg_le_of_meas":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫⁻ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/-- This lemma is superceded by `measure_theory.mem_ℒp.integral_indicator_norm_ge_nonneg_le`\nwhich does not require measurability. -/\ntheorem mem_ℒp.integral_indicator_norm_ge_nonneg_le_of_meas (hf : mem_ℒp f 1 μ) (hmeas : strongly_measurable f)\n    {ε : exprℝ} (hε : 0 < ε) :\n    ∃ M : exprℝ,\n      0 ≤ M ∧\n        «expr∫⁻ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ , ∂ »\"\n            («expr‖ ‖₊» ({ x | M ≤ «expr‖ ‖₊» (f x) }.indicator f x)) μ ≤\n          ENNReal.ofReal ε :=\n  let ⟨M, hM⟩ := hf.integral_indicator_norm_ge_le μ hmeas hε\n  ⟨max M 0, le_max_right _ _, by simpa⟩\n#align mem_ℒp.integral_indicator_norm_ge_nonneg_le_of_meas mem_ℒp.integral_indicator_norm_ge_nonneg_le_of_meas\n\n",
 "integral_indicator_norm_ge_nonneg_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫⁻ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\ntheorem mem_ℒp.integral_indicator_norm_ge_nonneg_le (hf : mem_ℒp f 1 μ) {ε : exprℝ} (hε : 0 < ε) :\n    ∃ M : exprℝ,\n      0 ≤ M ∧\n        «expr∫⁻ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ , ∂ »\"\n            («expr‖ ‖₊» ({ x | M ≤ «expr‖ ‖₊» (f x) }.indicator f x)) μ ≤\n          ENNReal.ofReal ε :=\n  by\n  have hf_mk : mem_ℒp (hf.1.mk f) 1 μ := (mem_ℒp_congr_ae hf.1.ae_eq_mk).mp hf\n  obtain ⟨M, hM_pos, hfM⟩ := hf_mk.integral_indicator_norm_ge_nonneg_le_of_meas μ hf.1.strongly_measurable_mk hε\n  refine' ⟨M, hM_pos, (le_of_eq _).trans hfM⟩\n  refine' lintegral_congr_ae _\n  filter_upwards [hf.1.ae_eq_mk]with x hx\n  simp only [indicator_apply, coe_nnnorm, mem_set_of_eq, ENNReal.coe_eq_coe, hx.symm]\n#align mem_ℒp.integral_indicator_norm_ge_nonneg_le mem_ℒp.integral_indicator_norm_ge_nonneg_le\n\n",
 "integral_indicator_norm_ge_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫⁻ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/-- This lemma is weaker than `measure_theory.mem_ℒp.integral_indicator_norm_ge_nonneg_le`\nas the latter provides `0 ≤ M` and does not require the measurability of `f`. -/\ntheorem mem_ℒp.integral_indicator_norm_ge_le (hf : mem_ℒp f 1 μ) (hmeas : strongly_measurable f) {ε : exprℝ}\n    (hε : 0 < ε) :\n    ∃ M : exprℝ,\n      «expr∫⁻ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ , ∂ »\"\n          («expr‖ ‖₊» ({ x | M ≤ «expr‖ ‖₊» (f x) }.indicator f x)) μ ≤\n        ENNReal.ofReal ε :=\n  by\n  have htendsto :\n    «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\" μ\n      (tendsto (fun M : ℕ => { x | (M : exprℝ) ≤ «expr‖ ‖₊» (f x) }.indicator f x) at_top ((nhds) 0)) :=\n    univ_mem' (id fun x => tendsto_indicator_ge f x)\n  have hmeas : ∀ M : ℕ, ae_strongly_measurable ({ x | (M : exprℝ) ≤ «expr‖ ‖₊» (f x) }.indicator f) μ :=\n    by\n    intro M\n    apply hf.1.indicator\n    apply\n      strongly_measurable.measurable_set_le strongly_measurable_const\n        hmeas.nnnorm.measurable.coe_nnreal_real.strongly_measurable\n  have hbound : has_finite_integral (fun x => «expr‖ ‖» (f x)) μ :=\n    by\n    rw [mem_ℒp_one_iff_integrable] at hf\n    exact hf.norm.2\n  have := tendsto_lintegral_norm_of_dominated_convergence hmeas hbound _ htendsto\n  · rw [ENNReal.tendsto_atTop_zero] at this\n    obtain ⟨M, hM⟩ := this (ENNReal.ofReal ε) (ENNReal.ofReal_pos.2 hε)\n    simp only [true_and_iff, ge_iff_le, zero_tsub, zero_le, sub_zero, zero_add, coe_nnnorm, mem_Icc] at hM\n    refine' ⟨M, _⟩\n    convert hM M le_rfl\n    ext1 x\n    simp only [coe_nnnorm, ENNReal.ofReal_eq_coe_nnreal (norm_nonneg _)]\n    rfl\n  · refine' fun n => univ_mem' (id fun x => _)\n    by_cases hx : (n : exprℝ) ≤ «expr‖ ‖» (f x)\n    · dsimp\n      rwa [indicator_of_mem]\n    · dsimp\n      rw [indicator_of_not_mem, norm_zero]\n      · exact norm_nonneg _\n      · assumption\n#align mem_ℒp.integral_indicator_norm_ge_le mem_ℒp.integral_indicator_norm_ge_le\n\n",
 "ae_strongly_measurable":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/-\nCopyright (c) 2022 Kexing Ying. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Kexing Ying\n-/\nprotected theorem ae_strongly_measurable {f : ι → α → β} {p : ennreal} (hf : uniform_integrable f p μ) (i : ι) :\n    ae_strongly_measurable (f i) μ :=\n  hf.1 i\n#align ae_strongly_measurable ae_strongly_measurable\n\n",
 "ae_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\ntheorem uniform_integrable.ae_eq {g : ι → α → β} (hf : uniform_integrable f p μ)\n    (hfg : ∀ n, «expr =ᵐ[ ] » (f n) μ (g n)) : uniform_integrable g p μ :=\n  by\n  obtain ⟨hfm, hunif, C, hC⟩ := hf\n  refine' ⟨fun i => (hfm i).congr (hfg i), (unif_integrable_congr_ae hfg).1 hunif, C, fun i => _⟩\n  rw [← snorm_congr_ae (hfg i)]\n  exact hC i\n#align uniform_integrable.ae_eq uniform_integrable.ae_eq\n\n",
 "add":
 "protected theorem add (hf : unif_integrable f p μ) (hg : unif_integrable g p μ) (hp : 1 ≤ p)\n    (hf_meas : ∀ i, ae_strongly_measurable (f i) μ) (hg_meas : ∀ i, ae_strongly_measurable (g i) μ) :\n    unif_integrable (f + g) p μ := by\n  intro ε hε\n  have hε2 : 0 < ε / 2 := half_pos hε\n  obtain ⟨δ₁, hδ₁_pos, hfδ₁⟩ := hf hε2\n  obtain ⟨δ₂, hδ₂_pos, hgδ₂⟩ := hg hε2\n  refine' ⟨min δ₁ δ₂, lt_min hδ₁_pos hδ₂_pos, fun i s hs hμs => _⟩\n  simp_rw [Pi.add_apply, indicator_add']\n  refine' (snorm_add_le ((hf_meas i).indicator hs) ((hg_meas i).indicator hs) hp).trans _\n  have hε_halves : ENNReal.ofReal ε = ENNReal.ofReal (ε / 2) + ENNReal.ofReal (ε / 2) := by\n    rw [← ENNReal.ofReal_add hε2.le hε2.le, add_halves]\n  rw [hε_halves]\n  exact\n    add_le_add (hfδ₁ i s hs (hμs.trans (ENNReal.ofReal_le_ofReal (min_le_left _ _))))\n      (hgδ₂ i s hs (hμs.trans (ENNReal.ofReal_le_ofReal (min_le_right _ _))))\n#align add add\n\n"}