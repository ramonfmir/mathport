{"to_Lp_dense_range":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‡‘ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\ntheorem to_Lp_dense_range [CompactSpace Î±] [Î¼.weakly_regular] [FiniteMeasure Î¼] :\n    DenseRange (Â«exprâ‡‘ Â» (to_Lp p Î¼ ğ•œ : Â«expr â†’L[ ] Â» (Â«exprC( , )Â» Î± E) ğ•œ (Lp E p Î¼))) :=\n  by\n  haveI : NormedSpace (exprâ„) E := restrict_scalars.normed_space (exprâ„) ğ•œ E\n  rw [denseRange_iff_closure_range]\n  suffices (LinearMap.range (to_Lp p Î¼ ğ•œ : Â«expr â†’L[ ] Â» _ ğ•œ (Lp E p Î¼))).to_add_subgroup.topological_closure = Â«exprâŠ¤Â»\n    by exact congr_arg coe this\n  simp [range_to_Lp p Î¼, measure_theory.Lp.bounded_continuous_function_dense E hp]\n#align to_Lp_dense_range to_Lp_dense_range\n\n",
 "exists_has_compact_support_snorm_sub_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (s Â«expr âŠ† Â» t) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/-- In a locally compact space, any function in `â„’p` can be approximated by compactly supported\ncontinuous functions when `p < âˆ`, version in terms of `snorm`. -/\ntheorem mem_â„’p.exists_has_compact_support_snorm_sub_le [LocallyCompactSpace Î±] [Î¼.regular] (hp : p â‰  ennreal.top)\n    {f : Î± â†’ E} (hf : mem_â„’p f p Î¼) {Îµ : ennreal} (hÎµ : Îµ â‰  0) :\n    âˆƒ g : Î± â†’ E, HasCompactSupport g âˆ§ snorm (f - g) p Î¼ â‰¤ Îµ âˆ§ Continuous g âˆ§ mem_â„’p g p Î¼ :=\n  by\n  suffices H : âˆƒ g : Î± â†’ E, snorm (f - g) p Î¼ â‰¤ Îµ âˆ§ Continuous g âˆ§ mem_â„’p g p Î¼ âˆ§ HasCompactSupport g\n  Â· rcases H with âŸ¨g, hg, g_cont, g_mem, g_supportâŸ©\n    exact âŸ¨g, g_support, hg, g_cont, g_memâŸ©\n  -- It suffices to check that the set of functions we consider approximates characteristic\n  -- functions, is stable under addition and consists of ae strongly measurable functions.\n  -- First check the latter easy facts.\n  apply hf.induction_dense hp _ _ _ _ hÎµ\n  rotate_left\n  -- stability under addition\n  Â· rintro f g âŸ¨f_cont, f_mem, hfâŸ© âŸ¨g_cont, g_mem, hgâŸ©\n    exact âŸ¨f_cont.add g_cont, f_mem.add g_mem, hf.add hgâŸ©\n  -- ae strong measurability\n  Â· rintro f âŸ¨f_cont, f_mem, hfâŸ©\n    exact f_mem.ae_strongly_measurable\n  -- We are left with approximating characteristic functions.\n  -- This follows from `exists_continuous_snorm_sub_le_of_closed`.\n  intro c t ht htÎ¼ Îµ hÎµ\n  rcases exists_Lp_half E Î¼ p hÎµ with âŸ¨Î´, Î´pos, hÎ´âŸ©\n  obtain âŸ¨Î·, Î·pos, hÎ·âŸ© : âˆƒ Î· : nnreal, 0 < Î· âˆ§ âˆ€ s : Set Î±, Î¼ s â‰¤ Î· â†’ snorm (s.indicator fun x => c) p Î¼ â‰¤ Î´\n  exact exists_snorm_indicator_le hp c Î´pos.ne'\n  have hÎ·_pos' : (0 : ennreal) < Î· := ENNReal.coe_pos.2 Î·pos\n  obtain âŸ¨s, st, s_compact, Î¼sâŸ© : âˆƒ (s : _)(_ : s âŠ† t), IsCompact s âˆ§ Î¼ (t \\ s) < Î·\n  exact ht.exists_is_compact_diff_lt htÎ¼.ne hÎ·_pos'.ne'\n  have hsÎ¼ : Î¼ s < ennreal.top := (measure_mono st).trans_lt htÎ¼\n  have I1 : snorm ((s.indicator fun y => c) - t.indicator fun y => c) p Î¼ â‰¤ Î´ :=\n    by\n    rw [â† snorm_neg, neg_sub, â† indicator_diff st]\n    exact hÎ· _ Î¼s.le\n  obtain âŸ¨k, k_compact, sk, -âŸ© : âˆƒ k : Set Î±, IsCompact k âˆ§ s âŠ† interior k âˆ§ k âŠ† univ\n  exact exists_compact_between s_compact isOpen_univ (subset_univ _)\n  rcases exists_continuous_snorm_sub_le_of_closed hp s_compact.is_closed isOpen_interior sk hsÎ¼.ne c Î´pos.ne' with\n    âŸ¨f, f_cont, I2, f_bound, f_support, f_memâŸ©\n  have I3 : snorm (f - t.indicator fun y => c) p Î¼ â‰¤ Îµ :=\n    by\n    convert(hÎ´ _ _ (f_mem.ae_strongly_measurable.sub (ae_strongly_measurable_const.indicator s_compact.measurable_set))\n          ((ae_strongly_measurable_const.indicator s_compact.measurable_set).sub\n            (ae_strongly_measurable_const.indicator ht))\n          I2 I1).le\n    simp only [sub_add_sub_cancel]\n  refine' âŸ¨f, I3, f_cont, f_mem, HasCompactSupport.intro k_compact fun x hx => _âŸ©\n  rw [â† Function.nmem_support]\n  contrapose! hx\n  exact interior_subset (f_support hx)\n#align mem_â„’p.exists_has_compact_support_snorm_sub_le mem_â„’p.exists_has_compact_support_snorm_sub_le\n\n",
 "exists_has_compact_support_lintegral_sub_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ«â» , âˆ‚ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ«â» , âˆ‚ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–â‚ŠÂ» -/\n/-- In a locally compact space, any integrable function can be approximated by compactly supported\ncontinuous functions, version in terms of `âˆ«â»`. -/\ntheorem integrable.exists_has_compact_support_lintegral_sub_le [LocallyCompactSpace Î±] [Î¼.regular] {f : Î± â†’ E}\n    (hf : integrable f Î¼) {Îµ : ennreal} (hÎµ : Îµ â‰  0) :\n    âˆƒ g : Î± â†’ E,\n      HasCompactSupport g âˆ§\n        Â«exprâˆ«â» , âˆ‚ Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ«â» , âˆ‚ Â»\"\n              (Â«exprâ€– â€–â‚ŠÂ» (f x - g x)) Î¼ â‰¤\n            Îµ âˆ§\n          Continuous g âˆ§ integrable g Î¼ :=\n  by\n  simp only [â† mem_â„’p_one_iff_integrable, â† snorm_one_eq_lintegral_nnnorm] at hfâŠ¢\n  exact hf.exists_has_compact_support_snorm_sub_le ENNReal.one_ne_top hÎµ\n#align integrable.exists_has_compact_support_lintegral_sub_le integrable.exists_has_compact_support_lintegral_sub_le\n\n",
 "exists_has_compact_support_integral_sub_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ« , âˆ‚ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ« , âˆ‚ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/-- In a locally compact space, any integrable function can be approximated by compactly supported\ncontinuous functions, version in terms of `âˆ«`. -/\ntheorem integrable.exists_has_compact_support_integral_sub_le [LocallyCompactSpace Î±] [Î¼.regular] {f : Î± â†’ E}\n    (hf : integrable f Î¼) {Îµ : exprâ„} (hÎµ : 0 < Îµ) :\n    âˆƒ g : Î± â†’ E,\n      HasCompactSupport g âˆ§\n        Â«exprâˆ« , âˆ‚ Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ« , âˆ‚ Â»\"\n              (Â«exprâ€– â€–Â» (f x - g x)) Î¼ â‰¤\n            Îµ âˆ§\n          Continuous g âˆ§ integrable g Î¼ :=\n  by\n  simp only [â† mem_â„’p_one_iff_integrable, â† snorm_one_eq_lintegral_nnnorm, â† ENNReal.ofReal_one] at hfâŠ¢\n  simpa using hf.exists_has_compact_support_integral_rpow_sub_le zero_lt_one hÎµ\n#align integrable.exists_has_compact_support_integral_sub_le integrable.exists_has_compact_support_integral_sub_le\n\n",
 "exists_has_compact_support_integral_rpow_sub_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ« , âˆ‚ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ« , âˆ‚ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/-- In a locally compact space, any function in `â„’p` can be approximated by compactly supported\ncontinuous functions when `0 < p < âˆ`, version in terms of `âˆ«`. -/\ntheorem mem_â„’p.exists_has_compact_support_integral_rpow_sub_le [LocallyCompactSpace Î±] [Î¼.regular] {p : exprâ„}\n    (hp : 0 < p) {f : Î± â†’ E} (hf : mem_â„’p f (ENNReal.ofReal p) Î¼) {Îµ : exprâ„} (hÎµ : 0 < Îµ) :\n    âˆƒ g : Î± â†’ E,\n      HasCompactSupport g âˆ§\n        Â«exprâˆ« , âˆ‚ Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ« , âˆ‚ Â»\"\n              (Â«exprâ€– â€–Â» (f x - g x) ^ p) Î¼ â‰¤\n            Îµ âˆ§\n          Continuous g âˆ§ mem_â„’p g (ENNReal.ofReal p) Î¼ :=\n  by\n  have I : 0 < Îµ ^ (1 / p) := real.rpow_pos_of_pos hÎµ _\n  have A : ENNReal.ofReal (Îµ ^ (1 / p)) â‰  0 := by simp only [ne.def, ENNReal.ofReal_eq_zero, not_le, I]\n  have B : ENNReal.ofReal p â‰  0 := by simpa only [ne.def, ENNReal.ofReal_eq_zero, not_le] using hp\n  rcases hf.exists_has_compact_support_snorm_sub_le ENNReal.coe_ne_top A with âŸ¨g, g_support, hg, g_cont, g_memâŸ©\n  change snorm _ (ENNReal.ofReal p) _ â‰¤ _ at hg\n  refine' âŸ¨g, g_support, _, g_cont, g_memâŸ©\n  rwa [(hf.sub g_mem).snorm_eq_integral_rpow_norm B ENNReal.coe_ne_top, ENNReal.ofReal_le_ofReal_iff I.le, one_div,\n    ENNReal.toReal_ofReal hp.le, real.rpow_le_rpow_iff _ hÎµ.le (inv_pos.2 hp)] at hg\n  exact integral_nonneg fun x => real.rpow_nonneg_of_nonneg (norm_nonneg _) _\n#align mem_â„’p.exists_has_compact_support_integral_rpow_sub_le mem_â„’p.exists_has_compact_support_integral_rpow_sub_le\n\n",
 "exists_continuous_snorm_sub_le_of_closed":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŠ‡ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/-\nCopyright (c) 2021 Heather Macbeth. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Heather Macbeth\n-/\n/-- A variant of Urysohn's lemma, `â„’^p` version, for an outer regular measure `Î¼`:\nconsider two sets `s âŠ† u` which are respectively closed and open with `Î¼ s < âˆ`, and a vector `c`.\nThen one may find a continuous function `f` equal to `c` on `s` and to `0` outside of `u`,\nbounded by `â€–câ€–` everywhere, and such that the `â„’^p` norm of `f - s.indicator (Î» y, c)` is\narbitrarily small. Additionally, this function `f` belongs to `â„’^p`. -/\ntheorem exists_continuous_snorm_sub_le_of_closed [Î¼.outer_regular] (hp : p â‰  ennreal.top) {s u : Set Î±}\n    (s_closed : IsClosed s) (u_open : IsOpen u) (hsu : s âŠ† u) (hs : Î¼ s â‰  ennreal.top) (c : E) {Îµ : ennreal}\n    (hÎµ : Îµ â‰  0) :\n    âˆƒ f : Î± â†’ E,\n      Continuous f âˆ§\n        snorm (fun x => f x - s.indicator (fun y => c) x) p Î¼ â‰¤ Îµ âˆ§\n          (âˆ€ x, Â«exprâ€– â€–Â» (f x) â‰¤ Â«exprâ€– â€–Â» c) âˆ§ Function.support f âŠ† u âˆ§ mem_â„’p f p Î¼ :=\n  by\n  obtain âŸ¨Î·, Î·_pos, hÎ·âŸ© : âˆƒ Î· : nnreal, 0 < Î· âˆ§ âˆ€ s : Set Î±, Î¼ s â‰¤ Î· â†’ snorm (s.indicator fun x => c) p Î¼ â‰¤ Îµ\n  exact exists_snorm_indicator_le hp c hÎµ\n  have Î·pos : (0 : ennreal) < Î· := ENNReal.coe_lt_coe.2 Î·_pos\n  obtain âŸ¨V, sV, V_open, h'V, hVâŸ© : âˆƒ (V : Set Î±)(H : Â«expr âŠ‡ Â» V s), IsOpen V âˆ§ Î¼ V < ennreal.top âˆ§ Î¼ (V \\ s) < Î·\n  exact s_closed.measurable_set.exists_is_open_diff_lt hs Î·pos.ne'\n  let v := u âˆ© V\n  have hsv : s âŠ† v := subset_inter hsu sV\n  have hÎ¼v : Î¼ v < ennreal.top := (measure_mono (inter_subset_right _ _)).trans_lt h'V\n  obtain âŸ¨g, hgv, hgs, hg_rangeâŸ© :=\n    exists_continuous_zero_one_of_closed (u_open.inter V_open).is_closed_compl s_closed (disjoint_compl_left_iff.2 hsv)\n  -- Multiply this by `c` to get a continuous approximation to the function `f`; the key point is\n  -- that this is pointwise bounded by the indicator of the set `v \\ s`, which has small measure.\n  have g_norm : âˆ€ x, Â«exprâ€– â€–Â» (g x) = g x := fun x => by rw [Real.norm_eq_abs, abs_of_nonneg (hg_range x).1]\n  have gc_bd0 : âˆ€ x, Â«exprâ€– â€–Â» (Â«expr â€¢ Â» (g x) c) â‰¤ Â«exprâ€– â€–Â» c :=\n    by\n    intro x\n    simp only [norm_smul, g_norm x]\n    apply mul_le_of_le_one_left (norm_nonneg _)\n    exact (hg_range x).2\n  have gc_bd :\n    âˆ€ x, Â«exprâ€– â€–Â» (Â«expr â€¢ Â» (g x) c - s.indicator (fun x => c) x) â‰¤ Â«exprâ€– â€–Â» ((v \\ s).indicator (fun x => c) x) :=\n    by\n    intro x\n    by_cases hv : x âˆˆ v\n    Â· rw [â† Set.diff_union_of_subset hsv] at hv\n      cases' hv with hsv hs\n      Â· simpa only [hsv.2, Set.indicator_of_not_mem, not_false_iff, sub_zero, hsv, Set.indicator_of_mem] using gc_bd0 x\n      Â· simp [hgs hs, hs]\n    Â· simp [hgv hv, (fun h => hv (hsv h) : x âˆ‰ s)]\n  have gc_support : (Function.support fun x : Î± => Â«expr â€¢ Â» (g x) c) âŠ† v :=\n    by\n    refine' Function.support_subset_iff'.2 fun x hx => _\n    simp only [hgv hx, Pi.zero_apply, zero_smul]\n  have gc_mem : mem_â„’p (fun x => Â«expr â€¢ Â» (g x) c) p Î¼ :=\n    by\n    apply mem_â„’p.smul_of_top_left (mem_â„’p_top_const _)\n    refine' âŸ¨g.continuous.ae_strongly_measurable, _âŸ©\n    have : snorm (v.indicator fun x => (1 : exprâ„)) p Î¼ < Â«exprâŠ¤Â» :=\n      by\n      refine' (snorm_indicator_const_le _ _).trans_lt _\n      simp only [lt_top_iff_ne_top, hÎ¼v.ne, nnnorm_one, ENNReal.coe_one, one_div, one_mul, ne.def,\n        ennreal.rpow_eq_top_iff, inv_lt_zero, false_and_iff, or_false_iff, not_and, not_lt, ENNReal.toReal_nonneg,\n        imp_true_iff]\n    refine' (snorm_mono fun x => _).trans_lt this\n    by_cases hx : x âˆˆ v\n    Â·\n      simp only [hx, abs_of_nonneg (hg_range x).1, (hg_range x).2, Real.norm_eq_abs, indicator_of_mem,\n        CstarRing.norm_one]\n    Â· simp only [hgv hx, Pi.zero_apply, Real.norm_eq_abs, abs_zero, abs_nonneg]\n  refine'\n    âŸ¨fun x => Â«expr â€¢ Â» (g x) c, g.continuous.smul continuous_const, (snorm_mono gc_bd).trans _, gc_bd0,\n      gc_support.trans (inter_subset_left _ _), gc_memâŸ©\n  exact hÎ· _ ((measure_mono (diff_subset_diff (inter_subset_right _ _) subset.rfl)).trans hV.le)\n#align exists_continuous_snorm_sub_le_of_closed exists_continuous_snorm_sub_le_of_closed\n\n",
 "exists_bounded_continuous_snorm_sub_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `bounded_continuous_function -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `bounded_continuous_function -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (s Â«expr âŠ† Â» t) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `bounded_continuous_function -/\n/-- Any function in `â„’p` can be approximated by bounded continuous functions when `p < âˆ`,\nversion in terms of `snorm`. -/\ntheorem mem_â„’p.exists_bounded_continuous_snorm_sub_le [Î¼.weakly_regular] (hp : p â‰  ennreal.top) {f : Î± â†’ E}\n    (hf : mem_â„’p f p Î¼) {Îµ : ennreal} (hÎµ : Îµ â‰  0) :\n    âˆƒ g : bounded_continuous_function Î± E, snorm (f - g) p Î¼ â‰¤ Îµ âˆ§ mem_â„’p g p Î¼ :=\n  by\n  suffices H : âˆƒ g : Î± â†’ E, snorm (f - g) p Î¼ â‰¤ Îµ âˆ§ Continuous g âˆ§ mem_â„’p g p Î¼ âˆ§ Metric.Bounded (range g)\n  Â· rcases H with âŸ¨g, hg, g_cont, g_mem, g_bdâŸ©\n    exact âŸ¨âŸ¨âŸ¨g, g_contâŸ©, Metric.bounded_range_iff.1 g_bdâŸ©, hg, g_memâŸ©\n  -- It suffices to check that the set of functions we consider approximates characteristic\n  -- functions, is stable under addition and made of ae strongly measurable functions.\n  -- First check the latter easy facts.\n  apply hf.induction_dense hp _ _ _ _ hÎµ\n  rotate_left\n  -- stability under addition\n  Â· rintro f g âŸ¨f_cont, f_mem, f_bdâŸ© âŸ¨g_cont, g_mem, g_bdâŸ©\n    refine' âŸ¨f_cont.add g_cont, f_mem.add g_mem, _âŸ©\n    let f' : bounded_continuous_function Î± E := âŸ¨âŸ¨f, f_contâŸ©, Metric.bounded_range_iff.1 f_bdâŸ©\n    let g' : bounded_continuous_function Î± E := âŸ¨âŸ¨g, g_contâŸ©, Metric.bounded_range_iff.1 g_bdâŸ©\n    exact (f' + g').bounded_range\n  -- ae strong measurability\n  Â· exact fun f âŸ¨_, h, _âŸ© => h.ae_strongly_measurable\n  -- We are left with approximating characteristic functions.\n  -- This follows from `exists_continuous_snorm_sub_le_of_closed`.\n  intro c t ht htÎ¼ Îµ hÎµ\n  rcases exists_Lp_half E Î¼ p hÎµ with âŸ¨Î´, Î´pos, hÎ´âŸ©\n  obtain âŸ¨Î·, Î·pos, hÎ·âŸ© : âˆƒ Î· : nnreal, 0 < Î· âˆ§ âˆ€ s : Set Î±, Î¼ s â‰¤ Î· â†’ snorm (s.indicator fun x => c) p Î¼ â‰¤ Î´\n  exact exists_snorm_indicator_le hp c Î´pos.ne'\n  have hÎ·_pos' : (0 : ennreal) < Î· := ENNReal.coe_pos.2 Î·pos\n  obtain âŸ¨s, st, s_closed, Î¼sâŸ© : âˆƒ (s : _)(_ : s âŠ† t), IsClosed s âˆ§ Î¼ (t \\ s) < Î·\n  exact ht.exists_is_closed_diff_lt htÎ¼.ne hÎ·_pos'.ne'\n  have hsÎ¼ : Î¼ s < ennreal.top := (measure_mono st).trans_lt htÎ¼\n  have I1 : snorm ((s.indicator fun y => c) - t.indicator fun y => c) p Î¼ â‰¤ Î´ :=\n    by\n    rw [â† snorm_neg, neg_sub, â† indicator_diff st]\n    exact hÎ· _ Î¼s.le\n  rcases exists_continuous_snorm_sub_le_of_closed hp s_closed isOpen_univ (subset_univ _) hsÎ¼.ne c Î´pos.ne' with\n    âŸ¨f, f_cont, I2, f_bound, -, f_memâŸ©\n  have I3 : snorm (f - t.indicator fun y => c) p Î¼ â‰¤ Îµ :=\n    by\n    convert(hÎ´ _ _ (f_mem.ae_strongly_measurable.sub (ae_strongly_measurable_const.indicator s_closed.measurable_set))\n          ((ae_strongly_measurable_const.indicator s_closed.measurable_set).sub\n            (ae_strongly_measurable_const.indicator ht))\n          I2 I1).le\n    simp only [sub_add_sub_cancel]\n  refine' âŸ¨f, I3, f_cont, f_mem, _âŸ©\n  exact (bounded_continuous_function.of_normed_add_comm_group f f_cont _ f_bound).bounded_range\n#align mem_â„’p.exists_bounded_continuous_snorm_sub_le mem_â„’p.exists_bounded_continuous_snorm_sub_le\n\n",
 "exists_bounded_continuous_lintegral_sub_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `bounded_continuous_function -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ«â» , âˆ‚ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ«â» , âˆ‚ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–â‚ŠÂ» -/\n/-- Any integrable function can be approximated by bounded continuous functions,\nversion in terms of `âˆ«â»`. -/\ntheorem integrable.exists_bounded_continuous_lintegral_sub_le [Î¼.weakly_regular] {f : Î± â†’ E} (hf : integrable f Î¼)\n    {Îµ : ennreal} (hÎµ : Îµ â‰  0) :\n    âˆƒ g : bounded_continuous_function Î± E,\n      Â«exprâˆ«â» , âˆ‚ Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ«â» , âˆ‚ Â»\"\n            (Â«exprâ€– â€–â‚ŠÂ» (f x - g x)) Î¼ â‰¤\n          Îµ âˆ§\n        integrable g Î¼ :=\n  by\n  simp only [â† mem_â„’p_one_iff_integrable, â† snorm_one_eq_lintegral_nnnorm] at hfâŠ¢\n  exact hf.exists_bounded_continuous_snorm_sub_le ENNReal.one_ne_top hÎµ\n#align integrable.exists_bounded_continuous_lintegral_sub_le integrable.exists_bounded_continuous_lintegral_sub_le\n\n",
 "exists_bounded_continuous_integral_sub_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `bounded_continuous_function -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ« , âˆ‚ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ« , âˆ‚ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/-- Any integrable function can be approximated by bounded continuous functions,\nversion in terms of `âˆ«`. -/\ntheorem integrable.exists_bounded_continuous_integral_sub_le [Î¼.weakly_regular] {f : Î± â†’ E} (hf : integrable f Î¼)\n    {Îµ : exprâ„} (hÎµ : 0 < Îµ) :\n    âˆƒ g : bounded_continuous_function Î± E,\n      Â«exprâˆ« , âˆ‚ Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ« , âˆ‚ Â»\"\n            (Â«exprâ€– â€–Â» (f x - g x)) Î¼ â‰¤\n          Îµ âˆ§\n        integrable g Î¼ :=\n  by\n  simp only [â† mem_â„’p_one_iff_integrable, â† snorm_one_eq_lintegral_nnnorm, â† ENNReal.ofReal_one] at hfâŠ¢\n  simpa using hf.exists_bounded_continuous_integral_rpow_sub_le zero_lt_one hÎµ\n#align integrable.exists_bounded_continuous_integral_sub_le integrable.exists_bounded_continuous_integral_sub_le\n\n",
 "exists_bounded_continuous_integral_rpow_sub_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `bounded_continuous_function -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ« , âˆ‚ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ« , âˆ‚ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/-- Any function in `â„’p` can be approximated by bounded continuous functions when `0 < p < âˆ`,\nversion in terms of `âˆ«`. -/\ntheorem mem_â„’p.exists_bounded_continuous_integral_rpow_sub_le [Î¼.weakly_regular] {p : exprâ„} (hp : 0 < p) {f : Î± â†’ E}\n    (hf : mem_â„’p f (ENNReal.ofReal p) Î¼) {Îµ : exprâ„} (hÎµ : 0 < Îµ) :\n    âˆƒ g : bounded_continuous_function Î± E,\n      Â«exprâˆ« , âˆ‚ Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ« , âˆ‚ Â»\"\n            (Â«exprâ€– â€–Â» (f x - g x) ^ p) Î¼ â‰¤\n          Îµ âˆ§\n        mem_â„’p g (ENNReal.ofReal p) Î¼ :=\n  by\n  have I : 0 < Îµ ^ (1 / p) := real.rpow_pos_of_pos hÎµ _\n  have A : ENNReal.ofReal (Îµ ^ (1 / p)) â‰  0 := by simp only [ne.def, ENNReal.ofReal_eq_zero, not_le, I]\n  have B : ENNReal.ofReal p â‰  0 := by simpa only [ne.def, ENNReal.ofReal_eq_zero, not_le] using hp\n  rcases hf.exists_bounded_continuous_snorm_sub_le ENNReal.coe_ne_top A with âŸ¨g, hg, g_memâŸ©\n  change snorm _ (ENNReal.ofReal p) _ â‰¤ _ at hg\n  refine' âŸ¨g, _, g_memâŸ©\n  rwa [(hf.sub g_mem).snorm_eq_integral_rpow_norm B ENNReal.coe_ne_top, ENNReal.ofReal_le_ofReal_iff I.le, one_div,\n    ENNReal.toReal_ofReal hp.le, real.rpow_le_rpow_iff _ hÎµ.le (inv_pos.2 hp)] at hg\n  exact integral_nonneg fun x => real.rpow_nonneg_of_nonneg (norm_nonneg _) _\n#align mem_â„’p.exists_bounded_continuous_integral_rpow_sub_le mem_â„’p.exists_bounded_continuous_integral_rpow_sub_le\n\n",
 "bounded_continuous_function_dense":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `bounded_continuous_function -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\n/-- A function in `Lp` can be approximated in `Lp` by continuous functions. -/\ntheorem bounded_continuous_function_dense [second_countable_topology_either Î± E] [_i : Fact (1 â‰¤ p)]\n    (hp : p â‰  ennreal.top) [Î¼.weakly_regular] : (bounded_continuous_function E p Î¼).topological_closure = Â«exprâŠ¤Â» :=\n  by\n  rw [AddSubgroup.eq_top_iff']\n  intro f\n  refine' mem_closure_iff_frequently.mpr _\n  rw [metric.nhds_basis_closed_ball.frequently_iff]\n  intro Îµ hÎµ\n  have A : ENNReal.ofReal Îµ â‰  0 := by simp only [ne.def, ENNReal.ofReal_eq_zero, not_le, hÎµ]\n  obtain âŸ¨g, hg, g_memâŸ© : âˆƒ g : bounded_continuous_function Î± E, snorm (f - g) p Î¼ â‰¤ ENNReal.ofReal Îµ âˆ§ mem_â„’p g p Î¼\n  exact (Lp.mem_â„’p f).exists_bounded_continuous_snorm_sub_le hp A\n  refine' âŸ¨g_mem.to_Lp _, _, âŸ¨g, rflâŸ©âŸ©\n  simp only [dist_eq_norm, Metric.mem_closedBall']\n  rw [Lp.norm_def]\n  convert ENNReal.toReal_le_of_le_ofReal hÎµ.le hg using 2\n  apply snorm_congr_ae\n  filter_upwards [coe_fn_sub f (g_mem.to_Lp g), g_mem.coe_fn_to_Lp]with x hx h'x\n  simp only [hx, Pi.sub_apply, sub_right_inj, h'x]\n#align bounded_continuous_function_dense bounded_continuous_function_dense\n\n"}