{"to_Lp_dense_range":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\ntheorem to_Lp_dense_range [CompactSpace α] [μ.weakly_regular] [FiniteMeasure μ] :\n    DenseRange («expr⇑ » (to_Lp p μ 𝕜 : «expr →L[ ] » («exprC( , )» α E) 𝕜 (Lp E p μ))) :=\n  by\n  haveI : NormedSpace (exprℝ) E := restrict_scalars.normed_space (exprℝ) 𝕜 E\n  rw [denseRange_iff_closure_range]\n  suffices (LinearMap.range (to_Lp p μ 𝕜 : «expr →L[ ] » _ 𝕜 (Lp E p μ))).to_add_subgroup.topological_closure = «expr⊤»\n    by exact congr_arg coe this\n  simp [range_to_Lp p μ, measure_theory.Lp.bounded_continuous_function_dense E hp]\n#align to_Lp_dense_range to_Lp_dense_range\n\n",
 "exists_has_compact_support_snorm_sub_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (s «expr ⊆ » t) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/-- In a locally compact space, any function in `ℒp` can be approximated by compactly supported\ncontinuous functions when `p < ∞`, version in terms of `snorm`. -/\ntheorem mem_ℒp.exists_has_compact_support_snorm_sub_le [LocallyCompactSpace α] [μ.regular] (hp : p ≠ ennreal.top)\n    {f : α → E} (hf : mem_ℒp f p μ) {ε : ennreal} (hε : ε ≠ 0) :\n    ∃ g : α → E, HasCompactSupport g ∧ snorm (f - g) p μ ≤ ε ∧ Continuous g ∧ mem_ℒp g p μ :=\n  by\n  suffices H : ∃ g : α → E, snorm (f - g) p μ ≤ ε ∧ Continuous g ∧ mem_ℒp g p μ ∧ HasCompactSupport g\n  · rcases H with ⟨g, hg, g_cont, g_mem, g_support⟩\n    exact ⟨g, g_support, hg, g_cont, g_mem⟩\n  -- It suffices to check that the set of functions we consider approximates characteristic\n  -- functions, is stable under addition and consists of ae strongly measurable functions.\n  -- First check the latter easy facts.\n  apply hf.induction_dense hp _ _ _ _ hε\n  rotate_left\n  -- stability under addition\n  · rintro f g ⟨f_cont, f_mem, hf⟩ ⟨g_cont, g_mem, hg⟩\n    exact ⟨f_cont.add g_cont, f_mem.add g_mem, hf.add hg⟩\n  -- ae strong measurability\n  · rintro f ⟨f_cont, f_mem, hf⟩\n    exact f_mem.ae_strongly_measurable\n  -- We are left with approximating characteristic functions.\n  -- This follows from `exists_continuous_snorm_sub_le_of_closed`.\n  intro c t ht htμ ε hε\n  rcases exists_Lp_half E μ p hε with ⟨δ, δpos, hδ⟩\n  obtain ⟨η, ηpos, hη⟩ : ∃ η : nnreal, 0 < η ∧ ∀ s : Set α, μ s ≤ η → snorm (s.indicator fun x => c) p μ ≤ δ\n  exact exists_snorm_indicator_le hp c δpos.ne'\n  have hη_pos' : (0 : ennreal) < η := ENNReal.coe_pos.2 ηpos\n  obtain ⟨s, st, s_compact, μs⟩ : ∃ (s : _)(_ : s ⊆ t), IsCompact s ∧ μ (t \\ s) < η\n  exact ht.exists_is_compact_diff_lt htμ.ne hη_pos'.ne'\n  have hsμ : μ s < ennreal.top := (measure_mono st).trans_lt htμ\n  have I1 : snorm ((s.indicator fun y => c) - t.indicator fun y => c) p μ ≤ δ :=\n    by\n    rw [← snorm_neg, neg_sub, ← indicator_diff st]\n    exact hη _ μs.le\n  obtain ⟨k, k_compact, sk, -⟩ : ∃ k : Set α, IsCompact k ∧ s ⊆ interior k ∧ k ⊆ univ\n  exact exists_compact_between s_compact isOpen_univ (subset_univ _)\n  rcases exists_continuous_snorm_sub_le_of_closed hp s_compact.is_closed isOpen_interior sk hsμ.ne c δpos.ne' with\n    ⟨f, f_cont, I2, f_bound, f_support, f_mem⟩\n  have I3 : snorm (f - t.indicator fun y => c) p μ ≤ ε :=\n    by\n    convert(hδ _ _ (f_mem.ae_strongly_measurable.sub (ae_strongly_measurable_const.indicator s_compact.measurable_set))\n          ((ae_strongly_measurable_const.indicator s_compact.measurable_set).sub\n            (ae_strongly_measurable_const.indicator ht))\n          I2 I1).le\n    simp only [sub_add_sub_cancel]\n  refine' ⟨f, I3, f_cont, f_mem, HasCompactSupport.intro k_compact fun x hx => _⟩\n  rw [← Function.nmem_support]\n  contrapose! hx\n  exact interior_subset (f_support hx)\n#align mem_ℒp.exists_has_compact_support_snorm_sub_le mem_ℒp.exists_has_compact_support_snorm_sub_le\n\n",
 "exists_has_compact_support_lintegral_sub_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫⁻ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/-- In a locally compact space, any integrable function can be approximated by compactly supported\ncontinuous functions, version in terms of `∫⁻`. -/\ntheorem integrable.exists_has_compact_support_lintegral_sub_le [LocallyCompactSpace α] [μ.regular] {f : α → E}\n    (hf : integrable f μ) {ε : ennreal} (hε : ε ≠ 0) :\n    ∃ g : α → E,\n      HasCompactSupport g ∧\n        «expr∫⁻ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ , ∂ »\"\n              («expr‖ ‖₊» (f x - g x)) μ ≤\n            ε ∧\n          Continuous g ∧ integrable g μ :=\n  by\n  simp only [← mem_ℒp_one_iff_integrable, ← snorm_one_eq_lintegral_nnnorm] at hf⊢\n  exact hf.exists_has_compact_support_snorm_sub_le ENNReal.one_ne_top hε\n#align integrable.exists_has_compact_support_lintegral_sub_le integrable.exists_has_compact_support_lintegral_sub_le\n\n",
 "exists_has_compact_support_integral_sub_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/-- In a locally compact space, any integrable function can be approximated by compactly supported\ncontinuous functions, version in terms of `∫`. -/\ntheorem integrable.exists_has_compact_support_integral_sub_le [LocallyCompactSpace α] [μ.regular] {f : α → E}\n    (hf : integrable f μ) {ε : exprℝ} (hε : 0 < ε) :\n    ∃ g : α → E,\n      HasCompactSupport g ∧\n        «expr∫ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ »\"\n              («expr‖ ‖» (f x - g x)) μ ≤\n            ε ∧\n          Continuous g ∧ integrable g μ :=\n  by\n  simp only [← mem_ℒp_one_iff_integrable, ← snorm_one_eq_lintegral_nnnorm, ← ENNReal.ofReal_one] at hf⊢\n  simpa using hf.exists_has_compact_support_integral_rpow_sub_le zero_lt_one hε\n#align integrable.exists_has_compact_support_integral_sub_le integrable.exists_has_compact_support_integral_sub_le\n\n",
 "exists_has_compact_support_integral_rpow_sub_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/-- In a locally compact space, any function in `ℒp` can be approximated by compactly supported\ncontinuous functions when `0 < p < ∞`, version in terms of `∫`. -/\ntheorem mem_ℒp.exists_has_compact_support_integral_rpow_sub_le [LocallyCompactSpace α] [μ.regular] {p : exprℝ}\n    (hp : 0 < p) {f : α → E} (hf : mem_ℒp f (ENNReal.ofReal p) μ) {ε : exprℝ} (hε : 0 < ε) :\n    ∃ g : α → E,\n      HasCompactSupport g ∧\n        «expr∫ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ »\"\n              («expr‖ ‖» (f x - g x) ^ p) μ ≤\n            ε ∧\n          Continuous g ∧ mem_ℒp g (ENNReal.ofReal p) μ :=\n  by\n  have I : 0 < ε ^ (1 / p) := real.rpow_pos_of_pos hε _\n  have A : ENNReal.ofReal (ε ^ (1 / p)) ≠ 0 := by simp only [ne.def, ENNReal.ofReal_eq_zero, not_le, I]\n  have B : ENNReal.ofReal p ≠ 0 := by simpa only [ne.def, ENNReal.ofReal_eq_zero, not_le] using hp\n  rcases hf.exists_has_compact_support_snorm_sub_le ENNReal.coe_ne_top A with ⟨g, g_support, hg, g_cont, g_mem⟩\n  change snorm _ (ENNReal.ofReal p) _ ≤ _ at hg\n  refine' ⟨g, g_support, _, g_cont, g_mem⟩\n  rwa [(hf.sub g_mem).snorm_eq_integral_rpow_norm B ENNReal.coe_ne_top, ENNReal.ofReal_le_ofReal_iff I.le, one_div,\n    ENNReal.toReal_ofReal hp.le, real.rpow_le_rpow_iff _ hε.le (inv_pos.2 hp)] at hg\n  exact integral_nonneg fun x => real.rpow_nonneg_of_nonneg (norm_nonneg _) _\n#align mem_ℒp.exists_has_compact_support_integral_rpow_sub_le mem_ℒp.exists_has_compact_support_integral_rpow_sub_le\n\n",
 "exists_continuous_snorm_sub_le_of_closed":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊇ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/-\nCopyright (c) 2021 Heather Macbeth. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Heather Macbeth\n-/\n/-- A variant of Urysohn's lemma, `ℒ^p` version, for an outer regular measure `μ`:\nconsider two sets `s ⊆ u` which are respectively closed and open with `μ s < ∞`, and a vector `c`.\nThen one may find a continuous function `f` equal to `c` on `s` and to `0` outside of `u`,\nbounded by `‖c‖` everywhere, and such that the `ℒ^p` norm of `f - s.indicator (λ y, c)` is\narbitrarily small. Additionally, this function `f` belongs to `ℒ^p`. -/\ntheorem exists_continuous_snorm_sub_le_of_closed [μ.outer_regular] (hp : p ≠ ennreal.top) {s u : Set α}\n    (s_closed : IsClosed s) (u_open : IsOpen u) (hsu : s ⊆ u) (hs : μ s ≠ ennreal.top) (c : E) {ε : ennreal}\n    (hε : ε ≠ 0) :\n    ∃ f : α → E,\n      Continuous f ∧\n        snorm (fun x => f x - s.indicator (fun y => c) x) p μ ≤ ε ∧\n          (∀ x, «expr‖ ‖» (f x) ≤ «expr‖ ‖» c) ∧ Function.support f ⊆ u ∧ mem_ℒp f p μ :=\n  by\n  obtain ⟨η, η_pos, hη⟩ : ∃ η : nnreal, 0 < η ∧ ∀ s : Set α, μ s ≤ η → snorm (s.indicator fun x => c) p μ ≤ ε\n  exact exists_snorm_indicator_le hp c hε\n  have ηpos : (0 : ennreal) < η := ENNReal.coe_lt_coe.2 η_pos\n  obtain ⟨V, sV, V_open, h'V, hV⟩ : ∃ (V : Set α)(H : «expr ⊇ » V s), IsOpen V ∧ μ V < ennreal.top ∧ μ (V \\ s) < η\n  exact s_closed.measurable_set.exists_is_open_diff_lt hs ηpos.ne'\n  let v := u ∩ V\n  have hsv : s ⊆ v := subset_inter hsu sV\n  have hμv : μ v < ennreal.top := (measure_mono (inter_subset_right _ _)).trans_lt h'V\n  obtain ⟨g, hgv, hgs, hg_range⟩ :=\n    exists_continuous_zero_one_of_closed (u_open.inter V_open).is_closed_compl s_closed (disjoint_compl_left_iff.2 hsv)\n  -- Multiply this by `c` to get a continuous approximation to the function `f`; the key point is\n  -- that this is pointwise bounded by the indicator of the set `v \\ s`, which has small measure.\n  have g_norm : ∀ x, «expr‖ ‖» (g x) = g x := fun x => by rw [Real.norm_eq_abs, abs_of_nonneg (hg_range x).1]\n  have gc_bd0 : ∀ x, «expr‖ ‖» («expr • » (g x) c) ≤ «expr‖ ‖» c :=\n    by\n    intro x\n    simp only [norm_smul, g_norm x]\n    apply mul_le_of_le_one_left (norm_nonneg _)\n    exact (hg_range x).2\n  have gc_bd :\n    ∀ x, «expr‖ ‖» («expr • » (g x) c - s.indicator (fun x => c) x) ≤ «expr‖ ‖» ((v \\ s).indicator (fun x => c) x) :=\n    by\n    intro x\n    by_cases hv : x ∈ v\n    · rw [← Set.diff_union_of_subset hsv] at hv\n      cases' hv with hsv hs\n      · simpa only [hsv.2, Set.indicator_of_not_mem, not_false_iff, sub_zero, hsv, Set.indicator_of_mem] using gc_bd0 x\n      · simp [hgs hs, hs]\n    · simp [hgv hv, (fun h => hv (hsv h) : x ∉ s)]\n  have gc_support : (Function.support fun x : α => «expr • » (g x) c) ⊆ v :=\n    by\n    refine' Function.support_subset_iff'.2 fun x hx => _\n    simp only [hgv hx, Pi.zero_apply, zero_smul]\n  have gc_mem : mem_ℒp (fun x => «expr • » (g x) c) p μ :=\n    by\n    apply mem_ℒp.smul_of_top_left (mem_ℒp_top_const _)\n    refine' ⟨g.continuous.ae_strongly_measurable, _⟩\n    have : snorm (v.indicator fun x => (1 : exprℝ)) p μ < «expr⊤» :=\n      by\n      refine' (snorm_indicator_const_le _ _).trans_lt _\n      simp only [lt_top_iff_ne_top, hμv.ne, nnnorm_one, ENNReal.coe_one, one_div, one_mul, ne.def,\n        ennreal.rpow_eq_top_iff, inv_lt_zero, false_and_iff, or_false_iff, not_and, not_lt, ENNReal.toReal_nonneg,\n        imp_true_iff]\n    refine' (snorm_mono fun x => _).trans_lt this\n    by_cases hx : x ∈ v\n    ·\n      simp only [hx, abs_of_nonneg (hg_range x).1, (hg_range x).2, Real.norm_eq_abs, indicator_of_mem,\n        CstarRing.norm_one]\n    · simp only [hgv hx, Pi.zero_apply, Real.norm_eq_abs, abs_zero, abs_nonneg]\n  refine'\n    ⟨fun x => «expr • » (g x) c, g.continuous.smul continuous_const, (snorm_mono gc_bd).trans _, gc_bd0,\n      gc_support.trans (inter_subset_left _ _), gc_mem⟩\n  exact hη _ ((measure_mono (diff_subset_diff (inter_subset_right _ _) subset.rfl)).trans hV.le)\n#align exists_continuous_snorm_sub_le_of_closed exists_continuous_snorm_sub_le_of_closed\n\n",
 "exists_bounded_continuous_snorm_sub_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `bounded_continuous_function -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `bounded_continuous_function -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (s «expr ⊆ » t) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `bounded_continuous_function -/\n/-- Any function in `ℒp` can be approximated by bounded continuous functions when `p < ∞`,\nversion in terms of `snorm`. -/\ntheorem mem_ℒp.exists_bounded_continuous_snorm_sub_le [μ.weakly_regular] (hp : p ≠ ennreal.top) {f : α → E}\n    (hf : mem_ℒp f p μ) {ε : ennreal} (hε : ε ≠ 0) :\n    ∃ g : bounded_continuous_function α E, snorm (f - g) p μ ≤ ε ∧ mem_ℒp g p μ :=\n  by\n  suffices H : ∃ g : α → E, snorm (f - g) p μ ≤ ε ∧ Continuous g ∧ mem_ℒp g p μ ∧ Metric.Bounded (range g)\n  · rcases H with ⟨g, hg, g_cont, g_mem, g_bd⟩\n    exact ⟨⟨⟨g, g_cont⟩, Metric.bounded_range_iff.1 g_bd⟩, hg, g_mem⟩\n  -- It suffices to check that the set of functions we consider approximates characteristic\n  -- functions, is stable under addition and made of ae strongly measurable functions.\n  -- First check the latter easy facts.\n  apply hf.induction_dense hp _ _ _ _ hε\n  rotate_left\n  -- stability under addition\n  · rintro f g ⟨f_cont, f_mem, f_bd⟩ ⟨g_cont, g_mem, g_bd⟩\n    refine' ⟨f_cont.add g_cont, f_mem.add g_mem, _⟩\n    let f' : bounded_continuous_function α E := ⟨⟨f, f_cont⟩, Metric.bounded_range_iff.1 f_bd⟩\n    let g' : bounded_continuous_function α E := ⟨⟨g, g_cont⟩, Metric.bounded_range_iff.1 g_bd⟩\n    exact (f' + g').bounded_range\n  -- ae strong measurability\n  · exact fun f ⟨_, h, _⟩ => h.ae_strongly_measurable\n  -- We are left with approximating characteristic functions.\n  -- This follows from `exists_continuous_snorm_sub_le_of_closed`.\n  intro c t ht htμ ε hε\n  rcases exists_Lp_half E μ p hε with ⟨δ, δpos, hδ⟩\n  obtain ⟨η, ηpos, hη⟩ : ∃ η : nnreal, 0 < η ∧ ∀ s : Set α, μ s ≤ η → snorm (s.indicator fun x => c) p μ ≤ δ\n  exact exists_snorm_indicator_le hp c δpos.ne'\n  have hη_pos' : (0 : ennreal) < η := ENNReal.coe_pos.2 ηpos\n  obtain ⟨s, st, s_closed, μs⟩ : ∃ (s : _)(_ : s ⊆ t), IsClosed s ∧ μ (t \\ s) < η\n  exact ht.exists_is_closed_diff_lt htμ.ne hη_pos'.ne'\n  have hsμ : μ s < ennreal.top := (measure_mono st).trans_lt htμ\n  have I1 : snorm ((s.indicator fun y => c) - t.indicator fun y => c) p μ ≤ δ :=\n    by\n    rw [← snorm_neg, neg_sub, ← indicator_diff st]\n    exact hη _ μs.le\n  rcases exists_continuous_snorm_sub_le_of_closed hp s_closed isOpen_univ (subset_univ _) hsμ.ne c δpos.ne' with\n    ⟨f, f_cont, I2, f_bound, -, f_mem⟩\n  have I3 : snorm (f - t.indicator fun y => c) p μ ≤ ε :=\n    by\n    convert(hδ _ _ (f_mem.ae_strongly_measurable.sub (ae_strongly_measurable_const.indicator s_closed.measurable_set))\n          ((ae_strongly_measurable_const.indicator s_closed.measurable_set).sub\n            (ae_strongly_measurable_const.indicator ht))\n          I2 I1).le\n    simp only [sub_add_sub_cancel]\n  refine' ⟨f, I3, f_cont, f_mem, _⟩\n  exact (bounded_continuous_function.of_normed_add_comm_group f f_cont _ f_bound).bounded_range\n#align mem_ℒp.exists_bounded_continuous_snorm_sub_le mem_ℒp.exists_bounded_continuous_snorm_sub_le\n\n",
 "exists_bounded_continuous_lintegral_sub_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `bounded_continuous_function -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫⁻ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/-- Any integrable function can be approximated by bounded continuous functions,\nversion in terms of `∫⁻`. -/\ntheorem integrable.exists_bounded_continuous_lintegral_sub_le [μ.weakly_regular] {f : α → E} (hf : integrable f μ)\n    {ε : ennreal} (hε : ε ≠ 0) :\n    ∃ g : bounded_continuous_function α E,\n      «expr∫⁻ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ , ∂ »\"\n            («expr‖ ‖₊» (f x - g x)) μ ≤\n          ε ∧\n        integrable g μ :=\n  by\n  simp only [← mem_ℒp_one_iff_integrable, ← snorm_one_eq_lintegral_nnnorm] at hf⊢\n  exact hf.exists_bounded_continuous_snorm_sub_le ENNReal.one_ne_top hε\n#align integrable.exists_bounded_continuous_lintegral_sub_le integrable.exists_bounded_continuous_lintegral_sub_le\n\n",
 "exists_bounded_continuous_integral_sub_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `bounded_continuous_function -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/-- Any integrable function can be approximated by bounded continuous functions,\nversion in terms of `∫`. -/\ntheorem integrable.exists_bounded_continuous_integral_sub_le [μ.weakly_regular] {f : α → E} (hf : integrable f μ)\n    {ε : exprℝ} (hε : 0 < ε) :\n    ∃ g : bounded_continuous_function α E,\n      «expr∫ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ »\"\n            («expr‖ ‖» (f x - g x)) μ ≤\n          ε ∧\n        integrable g μ :=\n  by\n  simp only [← mem_ℒp_one_iff_integrable, ← snorm_one_eq_lintegral_nnnorm, ← ENNReal.ofReal_one] at hf⊢\n  simpa using hf.exists_bounded_continuous_integral_rpow_sub_le zero_lt_one hε\n#align integrable.exists_bounded_continuous_integral_sub_le integrable.exists_bounded_continuous_integral_sub_le\n\n",
 "exists_bounded_continuous_integral_rpow_sub_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `bounded_continuous_function -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/-- Any function in `ℒp` can be approximated by bounded continuous functions when `0 < p < ∞`,\nversion in terms of `∫`. -/\ntheorem mem_ℒp.exists_bounded_continuous_integral_rpow_sub_le [μ.weakly_regular] {p : exprℝ} (hp : 0 < p) {f : α → E}\n    (hf : mem_ℒp f (ENNReal.ofReal p) μ) {ε : exprℝ} (hε : 0 < ε) :\n    ∃ g : bounded_continuous_function α E,\n      «expr∫ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ »\"\n            («expr‖ ‖» (f x - g x) ^ p) μ ≤\n          ε ∧\n        mem_ℒp g (ENNReal.ofReal p) μ :=\n  by\n  have I : 0 < ε ^ (1 / p) := real.rpow_pos_of_pos hε _\n  have A : ENNReal.ofReal (ε ^ (1 / p)) ≠ 0 := by simp only [ne.def, ENNReal.ofReal_eq_zero, not_le, I]\n  have B : ENNReal.ofReal p ≠ 0 := by simpa only [ne.def, ENNReal.ofReal_eq_zero, not_le] using hp\n  rcases hf.exists_bounded_continuous_snorm_sub_le ENNReal.coe_ne_top A with ⟨g, hg, g_mem⟩\n  change snorm _ (ENNReal.ofReal p) _ ≤ _ at hg\n  refine' ⟨g, _, g_mem⟩\n  rwa [(hf.sub g_mem).snorm_eq_integral_rpow_norm B ENNReal.coe_ne_top, ENNReal.ofReal_le_ofReal_iff I.le, one_div,\n    ENNReal.toReal_ofReal hp.le, real.rpow_le_rpow_iff _ hε.le (inv_pos.2 hp)] at hg\n  exact integral_nonneg fun x => real.rpow_nonneg_of_nonneg (norm_nonneg _) _\n#align mem_ℒp.exists_bounded_continuous_integral_rpow_sub_le mem_ℒp.exists_bounded_continuous_integral_rpow_sub_le\n\n",
 "bounded_continuous_function_dense":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `bounded_continuous_function -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/-- A function in `Lp` can be approximated in `Lp` by continuous functions. -/\ntheorem bounded_continuous_function_dense [second_countable_topology_either α E] [_i : Fact (1 ≤ p)]\n    (hp : p ≠ ennreal.top) [μ.weakly_regular] : (bounded_continuous_function E p μ).topological_closure = «expr⊤» :=\n  by\n  rw [AddSubgroup.eq_top_iff']\n  intro f\n  refine' mem_closure_iff_frequently.mpr _\n  rw [metric.nhds_basis_closed_ball.frequently_iff]\n  intro ε hε\n  have A : ENNReal.ofReal ε ≠ 0 := by simp only [ne.def, ENNReal.ofReal_eq_zero, not_le, hε]\n  obtain ⟨g, hg, g_mem⟩ : ∃ g : bounded_continuous_function α E, snorm (f - g) p μ ≤ ENNReal.ofReal ε ∧ mem_ℒp g p μ\n  exact (Lp.mem_ℒp f).exists_bounded_continuous_snorm_sub_le hp A\n  refine' ⟨g_mem.to_Lp _, _, ⟨g, rfl⟩⟩\n  simp only [dist_eq_norm, Metric.mem_closedBall']\n  rw [Lp.norm_def]\n  convert ENNReal.toReal_le_of_le_ofReal hε.le hg using 2\n  apply snorm_congr_ae\n  filter_upwards [coe_fn_sub f (g_mem.to_Lp g), g_mem.coe_fn_to_Lp]with x hx h'x\n  simp only [hx, Pi.sub_apply, sub_right_inj, h'x]\n#align bounded_continuous_function_dense bounded_continuous_function_dense\n\n"}