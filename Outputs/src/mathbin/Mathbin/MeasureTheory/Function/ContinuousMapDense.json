{"to_Lp_dense_range":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‡‘ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\ntheorem to_Lp_dense_range [compact_space Î±] [Î¼.weakly_regular] [is_finite_measure Î¼] :\n    dense_range (Â«exprâ‡‘ Â» (to_Lp p Î¼ ğ•œ : Â«expr â†’L[ ] Â» (Â«exprC( , )Â» Î± E) ğ•œ (Lp E p Î¼))) :=\n  by\n  haveI : normed_space (exprâ„) E := restrict_scalars.normed_space (exprâ„) ğ•œ E\n  rw [dense_range_iff_closure_range]\n  suffices (range (to_Lp p Î¼ ğ•œ : Â«expr â†’L[ ] Â» _ ğ•œ (Lp E p Î¼))).to_add_subgroup.topological_closure = Â«exprâŠ¤Â» by\n    exact congr_arg coe this\n  simp [range_to_Lp p Î¼, measure_theory.Lp.bounded_continuous_function_dense E hp]\n#align to_Lp_dense_range to_Lp_dense_range\n\n",
 "bounded_continuous_function_dense":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–â‚ŠÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–â‚ŠÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Basic.lean:632:2: warning: expanding binder collection (u Â«expr âŠ‡ Â» s) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŠ‡ Â» -/\n/- ./././Mathport/Syntax/Translate/Basic.lean:632:2: warning: expanding binder collection (F Â«expr âŠ† Â» s) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á¶œÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–â‚ŠÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\n/-\nCopyright (c) 2021 Heather Macbeth. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Heather Macbeth\n-/\n/-- A function in `Lp` can be approximated in `Lp` by continuous functions. -/\ntheorem bounded_continuous_function_dense [Î¼.weakly_regular] :\n    (bounded_continuous_function E p Î¼).topological_closure = Â«exprâŠ¤Â» :=\n  by\n  have hpâ‚€ : 0 < p := lt_of_lt_of_le ennreal.zero_lt_one _i.elim\n  have hpâ‚€' : 0 â‰¤ 1 / p.to_real := div_nonneg zero_le_one ennreal.to_real_nonneg\n  have hpâ‚€'' : 0 < p.to_real := by simpa [â† ennreal.to_real_lt_to_real ennreal.zero_ne_top hp] using hpâ‚€\n  -- It suffices to prove that scalar multiples of the indicator function of a finite-measure\n  -- measurable set can be approximated by continuous functions\n  suffices\n    âˆ€ (c : E) {s : set Î±} (hs : measurable_set s) (hÎ¼s : Î¼ s < Â«exprâŠ¤Â»),\n      (Lp.simple_func.indicator_const p hs hÎ¼s.ne c : Lp E p Î¼) âˆˆ\n        (bounded_continuous_function E p Î¼).topological_closure\n    by\n    rw [add_subgroup.eq_top_iff']\n    refine' Lp.induction hp _ _ _ _\n    Â· exact this\n    Â· exact fun f g hf hg hfg' => add_subgroup.add_mem _\n    Â· exact add_subgroup.is_closed_topological_closure _\n  -- Let `s` be a finite-measure measurable set, let's approximate `c` times its indicator function\n  intro c s hs hsÎ¼\n  refine' mem_closure_iff_frequently.mpr _\n  rw [metric.nhds_basis_closed_ball.frequently_iff]\n  intro Îµ hÎµ\n  -- A little bit of pre-emptive work, to find `Î· : â„â‰¥0` which will be a margin small enough for\n  -- our purposes\n  obtain âŸ¨Î·, hÎ·_pos, hÎ·_leâŸ© :\n    âˆƒ Î·, 0 < Î· âˆ§ (â†‘(Â«exprâ€– â€–â‚ŠÂ» (bit0 (Â«exprâ€– â€–Â» c)) * (2 * Î·) ^ (1 / p.to_real)) : exprâ„) â‰¤ Îµ :=\n    by\n    have :\n      filter.tendsto (fun x : nnreal => Â«exprâ€– â€–â‚ŠÂ» (bit0 (Â«exprâ€– â€–Â» c)) * (2 * x) ^ (1 / p.to_real)) ((nhds) 0)\n        ((nhds) 0) :=\n      by\n      have : filter.tendsto (fun x : nnreal => 2 * x) ((nhds) 0) ((nhds) (2 * 0)) := filter.tendsto_id.const_mul 2\n      convert ((nnreal.continuous_at_rpow_const (or.inr hpâ‚€')).tendsto.comp this).const_mul _\n      simp [hpâ‚€''.ne']\n    let Îµ' : nnreal := âŸ¨Îµ, hÎµ.leâŸ©\n    have hÎµ' : 0 < Îµ' := by exact_mod_cast hÎµ\n    obtain âŸ¨Î´, hÎ´, hÎ´Îµ'âŸ© := nnreal.nhds_zero_basis.eventually_iff.mp (eventually_le_of_tendsto_lt hÎµ' this)\n    obtain âŸ¨Î·, hÎ·, hÎ·Î´âŸ© := exists_between hÎ´\n    refine' âŸ¨Î·, hÎ·, _âŸ©\n    exact_mod_cast hÎ´Îµ' hÎ·Î´\n  have hÎ·_pos' : (0 : ennreal) < Î· := ennreal.coe_pos.2 hÎ·_pos\n  -- Use the regularity of the measure to `Î·`-approximate `s` by an open superset and a closed\n  -- subset\n  obtain âŸ¨u, su, u_open, Î¼uâŸ© : âˆƒ (u : _)(_ : Â«expr âŠ‡ Â» u s), is_open u âˆ§ Î¼ u < Î¼ s + â†‘Î· :=\n    by\n    refine' s.exists_is_open_lt_of_lt _ _\n    simpa using ennreal.add_lt_add_left hsÎ¼.ne hÎ·_pos'\n  obtain âŸ¨F, Fs, F_closed, Î¼FâŸ© : âˆƒ (F : _)(_ : F âŠ† s), is_closed F âˆ§ Î¼ s < Î¼ F + â†‘Î· :=\n    hs.exists_is_closed_lt_add hsÎ¼.ne hÎ·_pos'.ne'\n  have : Disjoint (Â«expr á¶œÂ» u) F := (Fs.trans su).disjoint_compl_left\n  have h_Î¼_sdiff : Î¼ (u \\ F) â‰¤ 2 * Î· :=\n    by\n    have hFÎ¼ : Î¼ F < Â«exprâŠ¤Â» := (measure_mono Fs).trans_lt hsÎ¼\n    refine' ennreal.le_of_add_le_add_left hFÎ¼.ne _\n    have : Î¼ u < Î¼ F + â†‘Î· + â†‘Î· := Î¼u.trans (ennreal.add_lt_add_right ennreal.coe_ne_top Î¼F)\n    convert this.le using 1\n    Â· rw [add_comm, â† measure_union, Set.diff_union_of_subset (Fs.trans su)]\n      exacts[disjoint_sdiff_self_left, F_closed.measurable_set]\n    have : (2 : ennreal) * Î· = Î· + Î· := by simpa using add_mul (1 : ennreal) 1 Î·\n    rw [this]\n    abel\n  -- Apply Urysohn's lemma to get a continuous approximation to the characteristic function of\n  -- the set `s`\n  obtain âŸ¨g, hgu, hgF, hg_rangeâŸ© := exists_continuous_zero_one_of_closed u_open.is_closed_compl F_closed this\n  -- Multiply this by `c` to get a continuous approximation to the function `f`; the key point is\n  -- that this is pointwise bounded by the indicator of the set `u \\ F`\n  have g_norm : âˆ€ x, Â«exprâ€– â€–Â» (g x) = g x := fun x => by rw [real.norm_eq_abs, abs_of_nonneg (hg_range x).1]\n  have gc_bd :\n    âˆ€ x,\n      Â«exprâ€– â€–Â» (Â«expr â€¢ Â» (g x) c - s.indicator (fun x => c) x) â‰¤\n        Â«exprâ€– â€–Â» ((u \\ F).indicator (fun x => bit0 (Â«exprâ€– â€–Â» c)) x) :=\n    by\n    intro x\n    by_cases hu : x âˆˆ u\n    Â· rw [â† Set.diff_union_of_subset (Fs.trans su)] at hu\n      cases' hu with hFu hF\n      Â· refine' (norm_sub_le _ _).trans _\n        refine' (add_le_add_left (norm_indicator_le_norm_self (fun x => c) x) _).trans _\n        have hâ‚€ : g x * Â«exprâ€– â€–Â» c + Â«exprâ€– â€–Â» c â‰¤ 2 * Â«exprâ€– â€–Â» c := by\n          nlinarith [(hg_range x).1, (hg_range x).2, norm_nonneg c]\n        have hâ‚ : (2 : exprâ„) * Â«exprâ€– â€–Â» c = bit0 (Â«exprâ€– â€–Â» c) := by simpa using add_mul (1 : exprâ„) 1 (Â«exprâ€– â€–Â» c)\n        simp [hFu, norm_smul, hâ‚€, â† hâ‚, g_norm x]\n      Â· simp [hgF hF, Fs hF]\n    Â· have : x âˆ‰ s := fun h => hu (su h)\n      simp [hgu hu, this]\n  -- The rest is basically just `ennreal`-arithmetic\n  have gc_snorm :\n    snorm ((fun x => Â«expr â€¢ Â» (g x) c) - s.indicator fun x => c) p Î¼ â‰¤\n      (â†‘(Â«exprâ€– â€–â‚ŠÂ» (bit0 (Â«exprâ€– â€–Â» c)) * (2 * Î·) ^ (1 / p.to_real)) : ennreal) :=\n    by\n    refine' (snorm_mono_ae (filter.eventually_of_forall gc_bd)).trans _\n    rw [snorm_indicator_const (u_open.sdiff F_closed).measurable_set hpâ‚€.ne' hp]\n    push_cast [â† ennreal.coe_rpow_of_nonneg _ hpâ‚€']\n    exact ennreal.mul_left_mono (ennreal.monotone_rpow_of_nonneg hpâ‚€' h_Î¼_sdiff)\n  have gc_cont : continuous fun x => Â«expr â€¢ Â» (g x) c := g.continuous.smul continuous_const\n  have gc_mem_â„’p : mem_â„’p (fun x => Â«expr â€¢ Â» (g x) c) p Î¼ :=\n    by\n    have : mem_â„’p ((fun x => Â«expr â€¢ Â» (g x) c) - s.indicator fun x => c) p Î¼ :=\n      âŸ¨gc_cont.ae_strongly_measurable.sub (strongly_measurable_const.indicator hs).ae_strongly_measurable,\n        gc_snorm.trans_lt ennreal.coe_lt_topâŸ©\n    simpa using this.add (mem_â„’p_indicator_const p hs c (or.inr hsÎ¼.ne))\n  refine' âŸ¨gc_mem_â„’p.to_Lp _, _, _âŸ©\n  Â· rw [mem_closed_ball_iff_norm]\n    refine' le_trans _ hÎ·_le\n    rw [simple_func.coe_indicator_const, indicator_const_Lp, â† mem_â„’p.to_Lp_sub, Lp.norm_to_Lp]\n    exact ennreal.to_real_le_coe_of_le_coe gc_snorm\n  Â· rw [SetLike.mem_coe, mem_bounded_continuous_function_iff]\n    refine' âŸ¨bounded_continuous_function.of_normed_add_comm_group _ gc_cont (Â«exprâ€– â€–Â» c) _, rflâŸ©\n    intro x\n    have hâ‚€ : g x * Â«exprâ€– â€–Â» c â‰¤ Â«exprâ€– â€–Â» c := by nlinarith [(hg_range x).1, (hg_range x).2, norm_nonneg c]\n    simp [norm_smul, g_norm x, hâ‚€]\n#align bounded_continuous_function_dense bounded_continuous_function_dense\n\n"}