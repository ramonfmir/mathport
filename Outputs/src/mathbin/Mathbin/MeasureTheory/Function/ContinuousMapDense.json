{"to_Lp_dense_range":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\ntheorem to_Lp_dense_range [compact_space α] [μ.weakly_regular] [is_finite_measure μ] :\n    dense_range («expr⇑ » (to_Lp p μ 𝕜 : «expr →L[ ] » («exprC( , )» α E) 𝕜 (Lp E p μ))) :=\n  by\n  haveI : normed_space (exprℝ) E := restrict_scalars.normed_space (exprℝ) 𝕜 E\n  rw [dense_range_iff_closure_range]\n  suffices (range (to_Lp p μ 𝕜 : «expr →L[ ] » _ 𝕜 (Lp E p μ))).to_add_subgroup.topological_closure = «expr⊤» by\n    exact congr_arg coe this\n  simp [range_to_Lp p μ, measure_theory.Lp.bounded_continuous_function_dense E hp]\n#align to_Lp_dense_range to_Lp_dense_range\n\n",
 "bounded_continuous_function_dense":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Basic.lean:632:2: warning: expanding binder collection (u «expr ⊇ » s) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊇ » -/\n/- ./././Mathport/Syntax/Translate/Basic.lean:632:2: warning: expanding binder collection (F «expr ⊆ » s) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/-\nCopyright (c) 2021 Heather Macbeth. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Heather Macbeth\n-/\n/-- A function in `Lp` can be approximated in `Lp` by continuous functions. -/\ntheorem bounded_continuous_function_dense [μ.weakly_regular] :\n    (bounded_continuous_function E p μ).topological_closure = «expr⊤» :=\n  by\n  have hp₀ : 0 < p := lt_of_lt_of_le ennreal.zero_lt_one _i.elim\n  have hp₀' : 0 ≤ 1 / p.to_real := div_nonneg zero_le_one ennreal.to_real_nonneg\n  have hp₀'' : 0 < p.to_real := by simpa [← ennreal.to_real_lt_to_real ennreal.zero_ne_top hp] using hp₀\n  -- It suffices to prove that scalar multiples of the indicator function of a finite-measure\n  -- measurable set can be approximated by continuous functions\n  suffices\n    ∀ (c : E) {s : set α} (hs : measurable_set s) (hμs : μ s < «expr⊤»),\n      (Lp.simple_func.indicator_const p hs hμs.ne c : Lp E p μ) ∈\n        (bounded_continuous_function E p μ).topological_closure\n    by\n    rw [add_subgroup.eq_top_iff']\n    refine' Lp.induction hp _ _ _ _\n    · exact this\n    · exact fun f g hf hg hfg' => add_subgroup.add_mem _\n    · exact add_subgroup.is_closed_topological_closure _\n  -- Let `s` be a finite-measure measurable set, let's approximate `c` times its indicator function\n  intro c s hs hsμ\n  refine' mem_closure_iff_frequently.mpr _\n  rw [metric.nhds_basis_closed_ball.frequently_iff]\n  intro ε hε\n  -- A little bit of pre-emptive work, to find `η : ℝ≥0` which will be a margin small enough for\n  -- our purposes\n  obtain ⟨η, hη_pos, hη_le⟩ :\n    ∃ η, 0 < η ∧ (↑(«expr‖ ‖₊» (bit0 («expr‖ ‖» c)) * (2 * η) ^ (1 / p.to_real)) : exprℝ) ≤ ε :=\n    by\n    have :\n      filter.tendsto (fun x : nnreal => «expr‖ ‖₊» (bit0 («expr‖ ‖» c)) * (2 * x) ^ (1 / p.to_real)) ((nhds) 0)\n        ((nhds) 0) :=\n      by\n      have : filter.tendsto (fun x : nnreal => 2 * x) ((nhds) 0) ((nhds) (2 * 0)) := filter.tendsto_id.const_mul 2\n      convert ((nnreal.continuous_at_rpow_const (or.inr hp₀')).tendsto.comp this).const_mul _\n      simp [hp₀''.ne']\n    let ε' : nnreal := ⟨ε, hε.le⟩\n    have hε' : 0 < ε' := by exact_mod_cast hε\n    obtain ⟨δ, hδ, hδε'⟩ := nnreal.nhds_zero_basis.eventually_iff.mp (eventually_le_of_tendsto_lt hε' this)\n    obtain ⟨η, hη, hηδ⟩ := exists_between hδ\n    refine' ⟨η, hη, _⟩\n    exact_mod_cast hδε' hηδ\n  have hη_pos' : (0 : ennreal) < η := ennreal.coe_pos.2 hη_pos\n  -- Use the regularity of the measure to `η`-approximate `s` by an open superset and a closed\n  -- subset\n  obtain ⟨u, su, u_open, μu⟩ : ∃ (u : _)(_ : «expr ⊇ » u s), is_open u ∧ μ u < μ s + ↑η :=\n    by\n    refine' s.exists_is_open_lt_of_lt _ _\n    simpa using ennreal.add_lt_add_left hsμ.ne hη_pos'\n  obtain ⟨F, Fs, F_closed, μF⟩ : ∃ (F : _)(_ : F ⊆ s), is_closed F ∧ μ s < μ F + ↑η :=\n    hs.exists_is_closed_lt_add hsμ.ne hη_pos'.ne'\n  have : Disjoint («expr ᶜ» u) F := (Fs.trans su).disjoint_compl_left\n  have h_μ_sdiff : μ (u \\ F) ≤ 2 * η :=\n    by\n    have hFμ : μ F < «expr⊤» := (measure_mono Fs).trans_lt hsμ\n    refine' ennreal.le_of_add_le_add_left hFμ.ne _\n    have : μ u < μ F + ↑η + ↑η := μu.trans (ennreal.add_lt_add_right ennreal.coe_ne_top μF)\n    convert this.le using 1\n    · rw [add_comm, ← measure_union, Set.diff_union_of_subset (Fs.trans su)]\n      exacts[disjoint_sdiff_self_left, F_closed.measurable_set]\n    have : (2 : ennreal) * η = η + η := by simpa using add_mul (1 : ennreal) 1 η\n    rw [this]\n    abel\n  -- Apply Urysohn's lemma to get a continuous approximation to the characteristic function of\n  -- the set `s`\n  obtain ⟨g, hgu, hgF, hg_range⟩ := exists_continuous_zero_one_of_closed u_open.is_closed_compl F_closed this\n  -- Multiply this by `c` to get a continuous approximation to the function `f`; the key point is\n  -- that this is pointwise bounded by the indicator of the set `u \\ F`\n  have g_norm : ∀ x, «expr‖ ‖» (g x) = g x := fun x => by rw [real.norm_eq_abs, abs_of_nonneg (hg_range x).1]\n  have gc_bd :\n    ∀ x,\n      «expr‖ ‖» («expr • » (g x) c - s.indicator (fun x => c) x) ≤\n        «expr‖ ‖» ((u \\ F).indicator (fun x => bit0 («expr‖ ‖» c)) x) :=\n    by\n    intro x\n    by_cases hu : x ∈ u\n    · rw [← Set.diff_union_of_subset (Fs.trans su)] at hu\n      cases' hu with hFu hF\n      · refine' (norm_sub_le _ _).trans _\n        refine' (add_le_add_left (norm_indicator_le_norm_self (fun x => c) x) _).trans _\n        have h₀ : g x * «expr‖ ‖» c + «expr‖ ‖» c ≤ 2 * «expr‖ ‖» c := by\n          nlinarith [(hg_range x).1, (hg_range x).2, norm_nonneg c]\n        have h₁ : (2 : exprℝ) * «expr‖ ‖» c = bit0 («expr‖ ‖» c) := by simpa using add_mul (1 : exprℝ) 1 («expr‖ ‖» c)\n        simp [hFu, norm_smul, h₀, ← h₁, g_norm x]\n      · simp [hgF hF, Fs hF]\n    · have : x ∉ s := fun h => hu (su h)\n      simp [hgu hu, this]\n  -- The rest is basically just `ennreal`-arithmetic\n  have gc_snorm :\n    snorm ((fun x => «expr • » (g x) c) - s.indicator fun x => c) p μ ≤\n      (↑(«expr‖ ‖₊» (bit0 («expr‖ ‖» c)) * (2 * η) ^ (1 / p.to_real)) : ennreal) :=\n    by\n    refine' (snorm_mono_ae (filter.eventually_of_forall gc_bd)).trans _\n    rw [snorm_indicator_const (u_open.sdiff F_closed).measurable_set hp₀.ne' hp]\n    push_cast [← ennreal.coe_rpow_of_nonneg _ hp₀']\n    exact ennreal.mul_left_mono (ennreal.monotone_rpow_of_nonneg hp₀' h_μ_sdiff)\n  have gc_cont : continuous fun x => «expr • » (g x) c := g.continuous.smul continuous_const\n  have gc_mem_ℒp : mem_ℒp (fun x => «expr • » (g x) c) p μ :=\n    by\n    have : mem_ℒp ((fun x => «expr • » (g x) c) - s.indicator fun x => c) p μ :=\n      ⟨gc_cont.ae_strongly_measurable.sub (strongly_measurable_const.indicator hs).ae_strongly_measurable,\n        gc_snorm.trans_lt ennreal.coe_lt_top⟩\n    simpa using this.add (mem_ℒp_indicator_const p hs c (or.inr hsμ.ne))\n  refine' ⟨gc_mem_ℒp.to_Lp _, _, _⟩\n  · rw [mem_closed_ball_iff_norm]\n    refine' le_trans _ hη_le\n    rw [simple_func.coe_indicator_const, indicator_const_Lp, ← mem_ℒp.to_Lp_sub, Lp.norm_to_Lp]\n    exact ennreal.to_real_le_coe_of_le_coe gc_snorm\n  · rw [SetLike.mem_coe, mem_bounded_continuous_function_iff]\n    refine' ⟨bounded_continuous_function.of_normed_add_comm_group _ gc_cont («expr‖ ‖» c) _, rfl⟩\n    intro x\n    have h₀ : g x * «expr‖ ‖» c ≤ «expr‖ ‖» c := by nlinarith [(hg_range x).1, (hg_range x).2, norm_nonneg c]\n    simp [norm_smul, g_norm x, h₀]\n#align bounded_continuous_function_dense bounded_continuous_function_dense\n\n"}