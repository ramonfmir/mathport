{"zpow_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛ » -/\ntheorem zpow_apply [DivInvMonoid β] (z : ℤ) (f : «expr →ₛ » α β) (a : α) : (f ^ z) a = f a ^ z :=\n  rfl\n#align zpow_apply zpow_apply\n\n",
 "zero_lintegral":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n@[simp]\ntheorem zero_lintegral : (0 : «expr →ₛ » α (ennreal)).lintegral μ = 0 :=\n  LinearMap.ext_iff.1 lintegralₗ.map_zero μ\n#align zero_lintegral zero_lintegral\n\n",
 "tsum_eapprox_diff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\ntheorem tsum_eapprox_diff (f : α → ennreal) (hf : Measurable f) (a : α) :\n    «expr∑' , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , »\"\n        (eapprox_diff f n a : ennreal) =\n      f a :=\n  by simp_rw [ENNReal.tsum_eq_supᵢ_nat' (tendsto_add_at_top_nat 1), sum_eapprox_diff, supr_eapprox_apply f hf a]\n#align tsum_eapprox_diff tsum_eapprox_diff\n\n",
 "supr_eapprox_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\ntheorem supr_eapprox_apply (f : α → ennreal) (hf : Measurable f) (a : α) :\n    «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n        ((eapprox f n : «expr →ₛ » α (ennreal)) a) =\n      f a :=\n  by\n  rw [eapprox, supr_approx_apply ennreal_rat_embed f a hf rfl]\n  refine' le_antisymm (supᵢ_le fun i => supᵢ_le fun hi => hi) (le_of_not_gt _)\n  intro h\n  rcases ENNReal.lt_iff_exists_rat_btwn.1 h with ⟨q, hq, lt_q, q_lt⟩\n  have :\n    (Real.toNNReal q : ennreal) ≤\n      «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n        (ennreal_rat_embed k) :=\n    by\n    refine' le_supᵢ_of_le (encodable.encode q) _\n    rw [ennreal_rat_embed_encode q]\n    refine' le_supᵢ_of_le (le_of_lt q_lt) _\n    exact le_rfl\n  exact lt_irrefl _ (lt_of_le_of_lt this lt_q)\n#align supr_eapprox_apply supr_eapprox_apply\n\n",
 "supr_approx_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\ntheorem supr_approx_apply [TopologicalSpace β] [CompleteLattice β] [OrderClosedTopology β] [Zero β] [MeasurableSpace β]\n    [opens_measurable_space β] (i : ℕ → β) (f : α → β) (a : α) (hf : Measurable f) (h_zero : (0 : β) = «expr⊥») :\n    «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n        ((approx i f n : «expr →ₛ » α β) a) =\n      «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (i k) :=\n  by\n  refine' le_antisymm (supᵢ_le fun n => _) (supᵢ_le fun k => supᵢ_le fun hk => _)\n  · rw [approx_apply a hf, h_zero]\n    refine' Finset.sup_le fun k hk => _\n    split_ifs\n    exact le_supᵢ_of_le k (le_supᵢ _ h)\n    exact bot_le\n  · refine' le_supᵢ_of_le (k + 1) _\n    rw [approx_apply a hf]\n    have : k ∈ Finset.range (k + 1) := Finset.mem_range.2 (nat.lt_succ_self _)\n    refine' le_trans (le_of_eq _) (Finset.le_sup this)\n    rw [if_pos hk]\n#align supr_approx_apply supr_approx_apply\n\n",
 "support_indicator":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛ » -/\ntheorem support_indicator [Zero β] {s : Set α} (hs : MeasurableSet s) (f : «expr →ₛ » α β) :\n    Function.support (f.piecewise s hs (simple_func.const α 0)) = s ∩ Function.support f :=\n  Set.support_indicator\n#align support_indicator support_indicator\n\n",
 "support_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem support_eq [MeasurableSpace α] [Zero β] (f : «expr →ₛ » α β) :\n    support f =\n      «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n        («expr ⁻¹' » f {y}) :=\n  Set.ext fun x => by\n    simp only [mem_support, Set.mem_preimage, mem_filter, mem_range_self, true_and_iff, exists_prop, mem_Union,\n      Set.mem_range, mem_singleton_iff, exists_eq_right']\n#align support_eq support_eq\n\n",
 "sup_eq_map₂":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\ntheorem sup_eq_map₂ [Sup β] (f g : «expr →ₛ » α β) :\n    «expr ⊔ » f g = (pair f g).map fun p : β × β => «expr ⊔ » p.1 p.2 :=\n  rfl\n#align sup_eq_map₂ sup_eq_map₂\n\n",
 "sup_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\ntheorem sup_apply [Sup β] (f g : «expr →ₛ » α β) (a : α) : («expr ⊔ » f g) a = «expr ⊔ » (f a) (g a) :=\n  rfl\n#align sup_apply sup_apply\n\n",
 "sum_range_measure_preimage_singleton":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem sum_range_measure_preimage_singleton (f : «expr →ₛ » α β) (μ : Measure α) :\n    finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" f.range\n        (μ («expr ⁻¹' » f {y})) =\n      μ univ :=\n  by rw [f.sum_measure_preimage_singleton, coe_range, preimage_range]\n#align sum_range_measure_preimage_singleton sum_range_measure_preimage_singleton\n\n",
 "sum_measure_preimage_singleton":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\nprotected theorem sum_measure_preimage_singleton (f : «expr →ₛ » α β) {μ : Measure α} (s : Finset β) :\n    finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s\n        (μ («expr ⁻¹' » f {y})) =\n      μ («expr ⁻¹' » f ↑s) :=\n  sum_measure_preimage_singleton _ fun _ _ => f.measurable_set_fiber _\n#align sum_measure_preimage_singleton sum_measure_preimage_singleton\n\n",
 "sum_eapprox_diff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\ntheorem sum_eapprox_diff (f : α → ennreal) (n : ℕ) (a : α) :\n    finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n        (Finset.range (n + 1)) (eapprox_diff f k a : ennreal) =\n      eapprox f n a :=\n  by\n  induction' n with n IH\n  · simp only [Nat.zero_eq, Finset.sum_singleton, Finset.range_one]\n    rfl\n  · rw [Finset.sum_range_succ, nat.succ_eq_add_one, IH, eapprox_diff, coe_map, Function.comp_apply, coe_sub,\n      Pi.sub_apply, ENNReal.coe_toNNReal, add_tsub_cancel_of_le (monotone_eapprox f (nat.le_succ _) _)]\n    apply (lt_of_le_of_lt _ (eapprox_lt_top f (n + 1) a)).ne\n    rw [tsub_le_iff_right]\n    exact le_self_add\n#align sum_eapprox_diff sum_eapprox_diff\n\n",
 "smul_eq_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:219:4: warning: unsupported binary notation `«expr • » -/\n-- TODO: work out how to generate these instances with `to_additive`, which gets confused by the\n-- argument order swap between `coe_smul` and `coe_pow`.\ntheorem smul_eq_map [SMul K β] (k : K) (f : «expr →ₛ » α β) : «expr • » k f = f.map ((«expr • » · ·) k) :=\n  rfl\n#align smul_eq_map smul_eq_map\n\n",
 "smul_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem smul_apply [SMul K β] (k : K) (f : «expr →ₛ » α β) (a : α) : («expr • » k f) a = «expr • » k (f a) :=\n  rfl\n#align smul_apply smul_apply\n\n",
 "simple_func_bot'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem simple_func_bot' {α} [Nonempty β] (f : @simple_func α («expr⊥») β) :\n    ∃ c, f = @simple_func.const α _ («expr⊥») c :=\n  by\n  obtain ⟨c, h_eq⟩ := simple_func_bot f\n  refine' ⟨c, _⟩\n  ext1 x\n  rw [h_eq x, simple_func.coe_const]\n#align simple_func_bot' simple_func_bot'\n\n",
 "simple_func_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem simple_func_bot {α} (f : @simple_func α («expr⊥») β) [Nonempty β] : ∃ c, ∀ x, f x = c :=\n  by\n  have hf_meas := @simple_func.measurable_set_fiber α _ («expr⊥») f\n  simp_rw [MeasurableSpace.measurableSet_bot_iff] at hf_meas\n  cases isEmpty_or_nonempty α\n  · simp only [IsEmpty.forall_iff, exists_const]\n  · specialize hf_meas (f h.some)\n    cases hf_meas\n    · exfalso\n      refine' Set.not_mem_empty h.some _\n      rw [← hf_meas, Set.mem_preimage]\n      exact Set.mem_singleton _\n    · refine' ⟨f h.some, fun x => _⟩\n      have : x ∈ «expr ⁻¹' » f {f h.some} := by\n        rw [hf_meas]\n        exact Set.mem_univ x\n      rwa [Set.mem_preimage, Set.mem_singleton_iff] at this\n#align simple_func_bot simple_func_bot\n\n",
 "seq_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛ » -/\n@[simp]\ntheorem seq_apply (f : «expr →ₛ » α (β → γ)) (g : «expr →ₛ » α β) (a : α) : f.seq g a = f a (g a) :=\n  rfl\n#align seq_apply seq_apply\n\n",
 "restrict_univ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛ » -/\n@[simp]\ntheorem restrict_univ (f : «expr →ₛ » α β) : restrict f univ = f := by simp [restrict]\n#align restrict_univ restrict_univ\n\n",
 "restrict_preimage_singleton":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem restrict_preimage_singleton (f : «expr →ₛ » α β) {s : Set α} (hs : MeasurableSet s) {r : β} (hr : r ≠ 0) :\n    «expr ⁻¹' » (restrict f s) {r} = s ∩ «expr ⁻¹' » f {r} :=\n  f.restrict_preimage hs hr.symm\n#align restrict_preimage_singleton restrict_preimage_singleton\n\n",
 "restrict_preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem restrict_preimage (f : «expr →ₛ » α β) {s : Set α} (hs : MeasurableSet s) {t : Set β} (ht : (0 : β) ∉ t) :\n    «expr ⁻¹' » (restrict f s) t = s ∩ «expr ⁻¹' » f t := by simp [hs, indicator_preimage_of_not_mem _ _ ht, inter_comm]\n#align restrict_preimage restrict_preimage\n\n",
 "restrict_of_not_measurable":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛ » -/\ntheorem restrict_of_not_measurable {f : «expr →ₛ » α β} {s : Set α} (hs : ¬MeasurableSet s) : restrict f s = 0 :=\n  dif_neg hs\n#align restrict_of_not_measurable restrict_of_not_measurable\n\n",
 "restrict_mono":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛ » -/\n@[mono]\ntheorem restrict_mono [preorder β] (s : Set α) {f g : «expr →ₛ » α β} (H : f ≤ g) : f.restrict s ≤ g.restrict s :=\n  if hs : MeasurableSet s then fun x => by simp only [coe_restrict _ hs, indicator_le_indicator (H x)]\n  else by simp only [restrict_of_not_measurable hs, le_refl]\n#align restrict_mono restrict_mono\n\n",
 "restrict_lintegral_eq_lintegral_restrict":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\ntheorem restrict_lintegral_eq_lintegral_restrict (f : «expr →ₛ » α (ennreal)) {s : Set α} (hs : MeasurableSet s) :\n    (restrict f s).lintegral μ = f.lintegral (μ.restrict s) := by rw [f.restrict_lintegral hs, lintegral_restrict]\n#align restrict_lintegral_eq_lintegral_restrict restrict_lintegral_eq_lintegral_restrict\n\n",
 "restrict_lintegral":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem restrict_lintegral (f : «expr →ₛ » α (ennreal)) {s : Set α} (hs : MeasurableSet s) :\n    (restrict f s).lintegral μ =\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" f.range\n        (r * μ («expr ⁻¹' » f {r} ∩ s)) :=\n  calc\n    (restrict f s).lintegral μ =\n        finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" f.range\n          (r * μ («expr ⁻¹' » (restrict f s) {r})) :=\n      lintegral_eq_of_subset _ fun x hx =>\n        if hxs : x ∈ s then fun _ => by simp only [f.restrict_apply hs, indicator_of_mem hxs, mem_range_self]\n        else false.elim <| hx <| by simp [*]\n    _ =\n        finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" f.range\n          (r * μ («expr ⁻¹' » f {r} ∩ s)) :=\n      Finset.sum_congr rfl <|\n        forall_range_iff.2 fun b =>\n          if hb : f b = 0 then by simp only [hb, MulZeroClass.zero_mul]\n          else by rw [restrict_preimage_singleton _ hs hb, inter_comm]\n    \n#align restrict_lintegral restrict_lintegral\n\n",
 "restrict_empty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛ » -/\n@[simp]\ntheorem restrict_empty (f : «expr →ₛ » α β) : restrict f ∅ = 0 := by simp [restrict]\n#align restrict_empty restrict_empty\n\n",
 "restrict_const_lintegral":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\ntheorem restrict_const_lintegral (c : ennreal) {s : Set α} (hs : MeasurableSet s) :\n    ((const α c).restrict s).lintegral μ = c * μ s := by\n  rw [restrict_lintegral_eq_lintegral_restrict _ hs, const_lintegral_restrict]\n#align restrict_const_lintegral restrict_const_lintegral\n\n",
 "restrict_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛ » -/\ntheorem restrict_apply (f : «expr →ₛ » α β) {s : Set α} (hs : MeasurableSet s) (a) : restrict f s a = indicator s f a :=\n  by simp only [f.coe_restrict hs]\n#align restrict_apply restrict_apply\n\n",
 "range_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛ » -/\n@[simp, to_additive]\ntheorem range_one [Nonempty α] [One β] : (1 : «expr →ₛ » α β).range = {1} :=\n  Finset.ext fun x => by simp [eq_comm]\n#align range_one range_one\n\n",
 "range_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛ » -/\n@[simp]\ntheorem range_map [DecidableEq γ] (g : β → γ) (f : «expr →ₛ » α β) : (f.map g).range = f.range.image g :=\n  Finset.coe_injective <| by simp only [coe_range, coe_map, Finset.coe_image, range_comp]\n#align range_map range_map\n\n",
 "range_indicator":
 "theorem range_indicator {s : Set α} (hs : MeasurableSet s) (hs_nonempty : s.nonempty) (hs_ne_univ : s ≠ univ)\n    (x y : β) : (piecewise s hs (const α x) (const α y)).range = {x, y} := by\n  simp only [← Finset.coe_inj, coe_range, coe_piecewise, range_piecewise, coe_const, Finset.coe_insert,\n    Finset.coe_singleton, hs_nonempty.image_const, (nonempty_compl.2 hs_ne_univ).image_const, singleton_union]\n#align range_indicator range_indicator\n\n",
 "range_eq_empty_of_is_empty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛ » -/\n@[simp]\ntheorem range_eq_empty_of_is_empty {β} [hα : IsEmpty α] (f : «expr →ₛ » α β) : f.range = ∅ :=\n  by\n  rw [← Finset.not_nonempty_iff_eq_empty]\n  by_contra\n  obtain ⟨y, hy_mem⟩ := h\n  rw [simple_func.mem_range, Set.mem_range] at hy_mem\n  obtain ⟨x, hxy⟩ := hy_mem\n  rw [isEmpty_iff] at hα\n  exact hα x\n#align range_eq_empty_of_is_empty range_eq_empty_of_is_empty\n\n",
 "range_const_subset":
 "theorem range_const_subset (α) [MeasurableSpace α] (b : β) : (const α b).range ⊆ {b} :=\n  Finset.coe_subset.1 <| by simp\n#align range_const_subset range_const_subset\n\n",
 "range_const":
 "@[simp]\ntheorem range_const (α) [MeasurableSpace α] [Nonempty α] (b : β) : (const α b).range = {b} :=\n  Finset.coe_injective <| by simp\n#align range_const range_const\n\n",
 "range_comp_subset_range":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛ » -/\ntheorem range_comp_subset_range [MeasurableSpace β] (f : «expr →ₛ » β γ) {g : α → β} (hgm : Measurable g) :\n    (f.comp g hgm).range ⊆ f.range :=\n  Finset.coe_subset.1 <| by simp only [coe_range, coe_comp, Set.range_comp_subset_range]\n#align range_comp_subset_range range_comp_subset_range\n\n",
 "preimage_eq_empty_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem preimage_eq_empty_iff (f : «expr →ₛ » α β) (b : β) : «expr ⁻¹' » f {b} = ∅ ↔ b ∉ f.range :=\n  preimage_singleton_eq_empty.trans <| not_congr mem_range.symm\n#align preimage_eq_empty_iff preimage_eq_empty_iff\n\n",
 "pow_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛ » -/\ntheorem pow_apply [Monoid β] (n : ℕ) (f : «expr →ₛ » α β) (a : α) : (f ^ n) a = f a ^ n :=\n  rfl\n#align pow_apply pow_apply\n\n",
 "piecewise_univ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛ » -/\n@[simp]\ntheorem piecewise_univ (f g : «expr →ₛ » α β) : piecewise univ MeasurableSet.univ f g = f :=\n  coe_injective <| by simp\n#align piecewise_univ piecewise_univ\n\n",
 "piecewise_empty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛ » -/\n@[simp]\ntheorem piecewise_empty (f g : «expr →ₛ » α β) : piecewise ∅ MeasurableSet.empty f g = g :=\n  coe_injective <| by simp\n#align piecewise_empty piecewise_empty\n\n",
 "piecewise_compl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n@[simp]\ntheorem piecewise_compl {s : Set α} (hs : MeasurableSet («expr ᶜ» s)) (f g : «expr →ₛ » α β) :\n    piecewise («expr ᶜ» s) hs f g = piecewise s hs.of_compl g f :=\n  coe_injective <| by simp [hs]\n#align piecewise_compl piecewise_compl\n\n",
 "piecewise_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛ » -/\ntheorem piecewise_apply {s : Set α} (hs : MeasurableSet s) (f g : «expr →ₛ » α β) (a) :\n    piecewise s hs f g a = if a ∈ s then f a else g a :=\n  rfl\n#align piecewise_apply piecewise_apply\n\n",
 "pair_preimage_singleton":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n-- A special form of `pair_preimage`\ntheorem pair_preimage_singleton (f : «expr →ₛ » α β) (g : «expr →ₛ » α γ) (b : β) (c : γ) :\n    «expr ⁻¹' » (pair f g) {(b, c)} = «expr ⁻¹' » f {b} ∩ «expr ⁻¹' » g {c} :=\n  by\n  rw [← singleton_prod_singleton]\n  exact pair_preimage _ _ _ _\n#align pair_preimage_singleton pair_preimage_singleton\n\n",
 "pair_preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem pair_preimage (f : «expr →ₛ » α β) (g : «expr →ₛ » α γ) (s : Set β) (t : Set γ) :\n    «expr ⁻¹' » (pair f g) (lower_set.prod s t) = «expr ⁻¹' » f s ∩ «expr ⁻¹' » g t :=\n  rfl\n#align pair_preimage pair_preimage\n\n",
 "pair_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛ » -/\n@[simp]\ntheorem pair_apply (f : «expr →ₛ » α β) (g : «expr →ₛ » α γ) (a) : pair f g a = (f a, g a) :=\n  rfl\n#align pair_apply pair_apply\n\n",
 "pair":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛ » -/\nprotected theorem pair {g : «expr →ₛ » α γ} (hf : f.fin_meas_supp μ) (hg : g.fin_meas_supp μ) :\n    (pair f g).fin_meas_supp μ :=\n  calc\n    μ (support <| pair f g) = μ (support f ∪ support g) := congr_arg μ <| support_prod_mk f g\n    _ ≤ μ (support f) + μ (support g) := (measure_union_le _ _)\n    _ < _ := add_lt_top.2 ⟨hf, hg⟩\n    \n#align pair pair\n\n",
 "of_map":
 "theorem of_map {g : β → γ} (h : (f.map g).fin_meas_supp μ) (hg : ∀ b, g b = 0 → b = 0) : f.fin_meas_supp μ :=\n  flip lt_of_le_of_lt h <| measure_mono <| support_subset_comp hg _\n#align of_map of_map\n\n",
 "of_lintegral_ne_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\ntheorem of_lintegral_ne_top {f : «expr →ₛ » α (ennreal)} (h : f.lintegral μ ≠ ennreal.top) : f.fin_meas_supp μ :=\n  by\n  refine' fin_meas_supp_iff.2 fun b hb => _\n  rw [f.lintegral_eq_of_subset' (Finset.subset_insert b _)] at h\n  refine' ENNReal.lt_top_of_mul_ne_top_right _ hb\n  exact (lt_top_of_sum_ne_top h (Finset.mem_insert_self _ _)).ne\n#align of_lintegral_ne_top of_lintegral_ne_top\n\n",
 "mul_eq_map₂":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛ » -/\n@[to_additive]\ntheorem mul_eq_map₂ [Mul β] (f g : «expr →ₛ » α β) : f * g = (pair f g).map fun p : β × β => p.1 * p.2 :=\n  rfl\n#align mul_eq_map₂ mul_eq_map₂\n\n",
 "mul_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛ » -/\n@[to_additive]\ntheorem mul_apply [Mul β] (f g : «expr →ₛ » α β) (a : α) : (f * g) a = f a * g a :=\n  rfl\n#align mul_apply mul_apply\n\n",
 "mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛ » -/\nprotected theorem mul {β} [MonoidWithZero β] {f g : «expr →ₛ » α β} (hf : f.fin_meas_supp μ) (hg : g.fin_meas_supp μ) :\n    (f * g).fin_meas_supp μ := by\n  rw [mul_eq_map₂]\n  exact hf.map₂ hg (MulZeroClass.zero_mul 0)\n#align mul mul\n\n",
 "monotone_eapprox":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n@[mono]\ntheorem monotone_eapprox (f : α → ennreal) : Monotone (eapprox f) :=\n  monotone_approx _ f\n#align monotone_eapprox monotone_eapprox\n\n",
 "monotone_approx":
 "theorem monotone_approx (i : ℕ → β) (f : α → β) : Monotone (approx i f) := fun n m h =>\n  Finset.sup_mono <| Finset.range_subset.2 h\n#align monotone_approx monotone_approx\n\n",
 "mem_restrict_range":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem mem_restrict_range {r : β} {s : Set α} {f : «expr →ₛ » α β} (hs : MeasurableSet s) :\n    r ∈ (restrict f s).range ↔ r = 0 ∧ s ≠ univ ∨ r ∈ «expr '' » f s := by\n  rw [← Finset.mem_coe, coe_range, coe_restrict _ hs, mem_range_indicator]\n#align mem_restrict_range mem_restrict_range\n\n",
 "mem_range_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛ » -/\ntheorem mem_range_self (f : «expr →ₛ » α β) (x : α) : f x ∈ f.range :=\n  mem_range.2 ⟨x, rfl⟩\n#align mem_range_self mem_range_self\n\n",
 "mem_range_of_measure_ne_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem mem_range_of_measure_ne_zero {f : «expr →ₛ » α β} {x : β} {μ : Measure α} (H : μ («expr ⁻¹' » f {x}) ≠ 0) :\n    x ∈ f.range :=\n  let ⟨a, ha⟩ := nonempty_of_measure_ne_zero H\n  mem_range.2 ⟨a, ha⟩\n#align mem_range_of_measure_ne_zero mem_range_of_measure_ne_zero\n\n",
 "mem_range":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛ » -/\n@[simp]\ntheorem mem_range {f : «expr →ₛ » α β} {b} : b ∈ f.range ↔ b ∈ range f :=\n  Finite.mem_toFinset _\n#align mem_range mem_range\n\n",
 "mem_image_of_mem_range_restrict":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem mem_image_of_mem_range_restrict {r : β} {s : Set α} {f : «expr →ₛ » α β} (hr : r ∈ (restrict f s).range)\n    (h0 : r ≠ 0) : r ∈ «expr '' » f s :=\n  if hs : MeasurableSet s then by simpa [mem_restrict_range hs, h0] using hr\n  else by\n    rw [restrict_of_not_measurable hs] at hr\n    exact (h0 <| eq_zero_of_mem_range_zero hr).elim\n#align mem_image_of_mem_range_restrict mem_image_of_mem_range_restrict\n\n",
 "measurable_set_fiber":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem measurable_set_fiber (f : «expr →ₛ » α β) (x : β) : MeasurableSet («expr ⁻¹' » f {x}) :=\n  f.measurable_set_fiber' x\n#align measurable_set_fiber measurable_set_fiber\n\n",
 "measurable_set_cut":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛ » -/\ntheorem measurable_set_cut (r : α → β → Prop) (f : «expr →ₛ » α β) (h : ∀ b, MeasurableSet { a | r a b }) :\n    MeasurableSet { a | r a (f a) } :=\n  by\n  have :\n    { a | r a (f a) } =\n      «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n        ({ a | r a b } ∩ «expr ⁻¹' » f {b}) :=\n    by\n    ext a\n    suffices r a (f a) ↔ ∃ i, r a (f i) ∧ f a = f i by simpa\n    exact ⟨fun h => ⟨a, ⟨h, rfl⟩⟩, fun ⟨a', ⟨h', e⟩⟩ => e.symm ▸ h'⟩\n  rw [this]\n  exact MeasurableSet.bunionᵢ f.finite_range.countable fun b _ => MeasurableSet.inter (h b) (f.measurable_set_fiber _)\n#align measurable_set_cut measurable_set_cut\n\n",
 "measurable_bind":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛ » -/\ntheorem measurable_bind [MeasurableSpace γ] (f : «expr →ₛ » α β) (g : β → α → γ) (hg : ∀ b, Measurable (g b)) :\n    Measurable fun a => g (f a) a := fun s hs => f.measurable_set_cut (fun a b => g b a ∈ s) fun b => hg b hs\n#align measurable_bind measurable_bind\n\n",
 "measurableSet_support":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛ » -/\n#print measurableSet_support /-\ntheorem measurableSet_support [MeasurableSpace α] (f : «expr →ₛ » α β) : MeasurableSet (support f) :=\n  by\n  rw [f.support_eq]\n  exact Finset.measurableSet_bunionᵢ _ fun y hy => measurable_set_fiber _ _\n#align measurable_set_support measurableSet_support\n-/\n\n",
 "measurableSet_preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n#print measurableSet_preimage /-\n@[measurability]\ntheorem measurableSet_preimage (f : «expr →ₛ » α β) (s) : MeasurableSet («expr ⁻¹' » f s) :=\n  measurable_set_cut (fun _ b => b ∈ s) f fun b => MeasurableSet.const (b ∈ s)\n#align measurable_set_preimage measurableSet_preimage\n-/\n\n",
 "meas_preimage_singleton_ne_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\ntheorem meas_preimage_singleton_ne_zero (h : f.fin_meas_supp μ) {y : β} (hy : y ≠ 0) :\n    μ («expr ⁻¹' » f {y}) < ennreal.top :=\n  fin_meas_supp_iff.1 h y hy\n#align meas_preimage_singleton_ne_zero meas_preimage_singleton_ne_zero\n\n",
 "map₂":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛ » -/\nprotected theorem map₂ [Zero δ] (hf : f.fin_meas_supp μ) {g : «expr →ₛ » α γ} (hg : g.fin_meas_supp μ) {op : β → γ → δ}\n    (H : op 0 0 = 0) : ((pair f g).map (function.uncurry op)).fin_meas_supp μ :=\n  (hf.pair hg).map H\n#align map₂ map₂\n\n",
 "map_restrict_of_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛ » -/\ntheorem map_restrict_of_zero [Zero γ] {g : β → γ} (hg : g 0 = 0) (f : «expr →ₛ » α β) (s : Set α) :\n    (f.restrict s).map g = (f.map g).restrict s :=\n  ext fun x =>\n    if hs : MeasurableSet s then by simp [hs, Set.indicator_comp_of_zero hg]\n    else by simp [restrict_of_not_measurable hs, hg]\n#align map_restrict_of_zero map_restrict_of_zero\n\n",
 "map_preimage_singleton":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem map_preimage_singleton (f : «expr →ₛ » α β) (g : β → γ) (c : γ) :\n    «expr ⁻¹' » (f.map g) {c} = «expr ⁻¹' » f ↑(f.range.filter fun b => g b = c) :=\n  map_preimage _ _ _\n#align map_preimage_singleton map_preimage_singleton\n\n",
 "map_preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem map_preimage (f : «expr →ₛ » α β) (g : β → γ) (s : Set γ) :\n    «expr ⁻¹' » (f.map g) s = «expr ⁻¹' » f ↑(f.range.filter fun b => g b ∈ s) :=\n  by\n  simp only [coe_range, sep_mem_eq, Set.mem_range, Function.comp_apply, coe_map, Finset.coe_filter, ← mem_preimage,\n    inter_comm, preimage_inter_range]\n  apply preimage_comp\n#align map_preimage map_preimage\n\n",
 "map_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛ » -/\n#print map_mul /-\n@[to_additive]\ntheorem map_mul [Mul β] [Mul γ] {g : β → γ} (hg : ∀ x y, g (x * y) = g x * g y) (f₁ f₂ : «expr →ₛ » α β) :\n    (f₁ * f₂).map g = f₁.map g * f₂.map g :=\n  ext fun x => hg _ _\n#align map_mul map_mul\n#align map_add map_add\n-/\n\n",
 "map_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛ » -/\ntheorem map_map (g : β → γ) (h : γ → δ) (f : «expr →ₛ » α β) : (f.map g).map h = f.map (h ∘ g) :=\n  rfl\n#align map_map map_map\n\n",
 "map_lintegral":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/-- Calculate the integral of `(g ∘ f)`, where `g : β → ℝ≥0∞` and `f : α →ₛ β`.  -/\ntheorem map_lintegral (g : β → ennreal) (f : «expr →ₛ » α β) :\n    (f.map g).lintegral μ =\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" f.range\n        (g x * μ («expr ⁻¹' » f {x})) :=\n  by\n  simp only [lintegral, range_map]\n  refine' Finset.sum_image' _ fun b hb => _\n  rcases mem_range.1 hb with ⟨a, rfl⟩\n  rw [map_preimage_singleton, ← f.sum_measure_preimage_singleton, Finset.mul_sum]\n  refine' Finset.sum_congr _ _\n  · congr\n  · intro x\n    simp only [Finset.mem_filter]\n    rintro ⟨_, h⟩\n    rw [h]\n#align map_lintegral map_lintegral\n\n",
 "map_iff":
 "theorem map_iff {g : β → γ} (hg : ∀ {b}, g b = 0 ↔ b = 0) : (f.map g).fin_meas_supp μ ↔ f.fin_meas_supp μ :=\n  ⟨fun h => h.of_map fun b => hg.1, fun h => h.map <| hg.2 rfl⟩\n#align map_iff map_iff\n\n",
 "map_const":
 "@[simp]\ntheorem map_const (g : β → γ) (b : β) : (const α b).map g = const α (g b) :=\n  rfl\n#align map_const map_const\n\n",
 "map_coe_nnreal_restrict":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem map_coe_nnreal_restrict (f : «expr →ₛ » α (nnreal)) (s : Set α) :\n    (f.restrict s).map (coe : nnreal → exprℝ) = (f.map coe).restrict s :=\n  map_restrict_of_zero NNReal.coe_zero _ _\n#align map_coe_nnreal_restrict map_coe_nnreal_restrict\n\n",
 "map_coe_ennreal_restrict":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\ntheorem map_coe_ennreal_restrict (f : «expr →ₛ » α (nnreal)) (s : Set α) :\n    (f.restrict s).map (coe : nnreal → ennreal) = (f.map coe).restrict s :=\n  map_restrict_of_zero ENNReal.coe_zero _ _\n#align map_coe_ennreal_restrict map_coe_ennreal_restrict\n\n",
 "map_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛ » -/\ntheorem map_apply (g : β → γ) (f : «expr →ₛ » α β) (a) : f.map g a = g (f a) :=\n  rfl\n#align map_apply map_apply\n\n",
 "map":
 "protected theorem map {g : β → γ} (hf : f.fin_meas_supp μ) (hg : g 0 = 0) : (f.map g).fin_meas_supp μ :=\n  flip lt_of_le_of_lt hf (measure_mono <| support_comp_subset hg f)\n#align map map\n\n",
 "lintegral_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n@[simp]\ntheorem lintegral_zero [MeasurableSpace α] (f : «expr →ₛ » α (ennreal)) : f.lintegral 0 = 0 :=\n  (lintegralₗ f).map_zero\n#align lintegral_zero lintegral_zero\n\n",
 "lintegral_sum":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , » -/\ntheorem lintegral_sum {m : MeasurableSpace α} {ι} (f : «expr →ₛ » α (ennreal)) (μ : ι → Measure α) :\n    f.lintegral (Measure.sum μ) =\n      «expr∑' , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , »\"\n        (f.lintegral (μ i)) :=\n  by\n  simp only [lintegral, measure.sum_apply, f.measurable_set_preimage, ← Finset.tsum_subtype, ← ENNReal.tsum_mul_left]\n  apply ENNReal.tsum_comm\n#align lintegral_sum lintegral_sum\n\n",
 "lintegral_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem lintegral_smul (f : «expr →ₛ » α (ennreal)) (c : ennreal) :\n    f.lintegral («expr • » c μ) = «expr • » c (f.lintegral μ) :=\n  (lintegralₗ f).map_smul c μ\n#align lintegral_smul lintegral_smul\n\n",
 "lintegral_restrict":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem lintegral_restrict {m : MeasurableSpace α} (f : «expr →ₛ » α (ennreal)) (s : Set α) (μ : Measure α) :\n    f.lintegral (μ.restrict s) =\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" f.range\n        (y * μ («expr ⁻¹' » f {y} ∩ s)) :=\n  by simp only [lintegral, measure.restrict_apply, f.measurable_set_preimage]\n#align lintegral_restrict lintegral_restrict\n\n",
 "lintegral_mono":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/-- `simple_func.lintegral` is monotone both in function and in measure. -/\n@[mono]\ntheorem lintegral_mono {f g : «expr →ₛ » α (ennreal)} (hfg : f ≤ g) (hμν : μ ≤ ν) : f.lintegral μ ≤ g.lintegral ν :=\n  calc\n    f.lintegral μ ≤ «expr ⊔ » (f.lintegral μ) (g.lintegral μ) := le_sup_left\n    _ ≤ («expr ⊔ » f g).lintegral μ := (le_sup_lintegral _ _)\n    _ = g.lintegral μ := by rw [sup_of_le_right hfg]\n    _ ≤ g.lintegral ν := Finset.sum_le_sum fun y hy => ENNReal.mul_left_mono <| hμν _ (g.measurable_set_preimage _)\n    \n#align lintegral_mono lintegral_mono\n\n",
 "lintegral_map'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem lintegral_map' {β} [MeasurableSpace β] {μ' : Measure β} (f : «expr →ₛ » α (ennreal))\n    (g : «expr →ₛ » β (ennreal)) (m' : α → β) (eq : ∀ a, f a = g (m' a))\n    (h : ∀ s, MeasurableSet s → μ' s = μ («expr ⁻¹' » m' s)) : f.lintegral μ = g.lintegral μ' :=\n  lintegral_eq_of_measure_preimage fun y => by\n    simp only [preimage, Eq]\n    exact (h («expr ⁻¹' » g {y}) (g.measurable_set_preimage _)).symm\n#align lintegral_map' lintegral_map'\n\n",
 "lintegral_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\ntheorem lintegral_map {β} [MeasurableSpace β] (g : «expr →ₛ » β (ennreal)) {f : α → β} (hf : Measurable f) :\n    g.lintegral (Measure.map f μ) = (g.comp f hf).lintegral μ :=\n  Eq.symm <| lintegral_map' _ _ f (fun a => rfl) fun s hs => Measure.map_apply hf hs\n#align lintegral_map lintegral_map\n\n",
 "lintegral_lt_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\ntheorem lintegral_lt_top {f : «expr →ₛ » α (ennreal)} (hm : f.fin_meas_supp μ)\n    (hf :\n      «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\" μ\n        (f a ≠ ennreal.top)) :\n    f.lintegral μ < ennreal.top := by\n  refine' sum_lt_top fun a ha => _\n  rcases eq_or_ne a (ennreal.top) with (rfl | ha)\n  · simp only [ae_iff, ne.def, Classical.not_not] at hf\n    simp [Set.preimage, hf]\n  · by_cases ha0 : a = 0\n    · subst a\n      rwa [MulZeroClass.zero_mul]\n    · exact mul_ne_top ha (fin_meas_supp_iff.1 hm _ ha0).ne\n#align lintegral_lt_top lintegral_lt_top\n\n",
 "lintegral_eq_of_subset'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem lintegral_eq_of_subset' (f : «expr →ₛ » α (ennreal)) {s : Finset (ennreal)} (hs : f.range \\ {0} ⊆ s) :\n    f.lintegral μ =\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s\n        (x * μ («expr ⁻¹' » f {x})) :=\n  f.lintegral_eq_of_subset fun x hfx _ => hs <| Finset.mem_sdiff.2 ⟨f.mem_range_self x, mt Finset.mem_singleton.1 hfx⟩\n#align lintegral_eq_of_subset' lintegral_eq_of_subset'\n\n",
 "lintegral_eq_of_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem lintegral_eq_of_subset (f : «expr →ₛ » α (ennreal)) {s : Finset (ennreal)}\n    (hs : ∀ x, f x ≠ 0 → μ («expr ⁻¹' » f {f x}) ≠ 0 → f x ∈ s) :\n    f.lintegral μ =\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s\n        (x * μ («expr ⁻¹' » f {x})) :=\n  by\n  refine' Finset.sum_bij_ne_zero (fun r _ _ => r) _ _ _ _\n  · simpa only [forall_range_iff, mul_ne_zero_iff, and_imp]\n  · intros\n    assumption\n  · intro b _ hb\n    refine' ⟨b, _, hb, rfl⟩\n    rw [mem_range, ← preimage_singleton_nonempty]\n    exact nonempty_of_measure_ne_zero (mul_ne_zero_iff.1 hb).2\n  · intros\n    rfl\n#align lintegral_eq_of_subset lintegral_eq_of_subset\n\n",
 "lintegral_eq_of_measure_preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/-- `simple_func.lintegral` depends only on the measures of `f ⁻¹' {y}`. -/\ntheorem lintegral_eq_of_measure_preimage [MeasurableSpace β] {f : «expr →ₛ » α (ennreal)} {g : «expr →ₛ » β (ennreal)}\n    {ν : Measure β} (H : ∀ y, μ («expr ⁻¹' » f {y}) = ν («expr ⁻¹' » g {y})) : f.lintegral μ = g.lintegral ν :=\n  by\n  simp only [lintegral, ← H]\n  apply lintegral_eq_of_subset\n  simp only [H]\n  intros\n  exact mem_range_of_measure_ne_zero ‹_›\n#align lintegral_eq_of_measure_preimage lintegral_eq_of_measure_preimage\n\n",
 "lintegral_congr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\n/-- If two simple functions are equal a.e., then their `lintegral`s are equal. -/\ntheorem lintegral_congr {f g : «expr →ₛ » α (ennreal)} (h : «expr =ᵐ[ ] » f μ g) : f.lintegral μ = g.lintegral μ :=\n  lintegral_eq_of_measure_preimage fun y => measure_congr <| Eventually.set_eq <| h.mono fun x hx => by simp [hx]\n#align lintegral_congr lintegral_congr\n\n",
 "lintegral_add":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\ntheorem lintegral_add {ν} (f : «expr →ₛ » α (ennreal)) : f.lintegral (μ + ν) = f.lintegral μ + f.lintegral ν :=\n  (lintegralₗ f).map_add μ ν\n#align lintegral_add lintegral_add\n\n",
 "le_sup_lintegral":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\ntheorem le_sup_lintegral (f g : «expr →ₛ » α (ennreal)) :\n    «expr ⊔ » (f.lintegral μ) (g.lintegral μ) ≤ («expr ⊔ » f g).lintegral μ :=\n  calc\n    «expr ⊔ » (f.lintegral μ) (g.lintegral μ) =\n        «expr ⊔ » (((pair f g).map Prod.fst).lintegral μ) (((pair f g).map Prod.snd).lintegral μ) :=\n      rfl\n    _ ≤\n        finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (pair f g).range\n          («expr ⊔ » x.1 x.2 * μ («expr ⁻¹' » (pair f g) {x})) :=\n      by\n      rw [map_lintegral, map_lintegral]\n      refine' sup_le _ _ <;> refine' Finset.sum_le_sum fun a _ => mul_le_mul_right' _ _\n      exact le_sup_left\n      exact le_sup_right\n    _ = («expr ⊔ » f g).lintegral μ := by rw [sup_eq_map₂, map_lintegral]\n    \n#align le_sup_lintegral le_sup_lintegral\n\n",
 "inv_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛ » -/\n@[to_additive]\ntheorem inv_apply [Inv β] (f : «expr →ₛ » α β) (x : α) : f⁻¹ x = (f x)⁻¹ :=\n  rfl\n#align inv_apply inv_apply\n\n",
 "inf_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\ntheorem inf_apply [Inf β] (f g : «expr →ₛ » α β) (a : α) : («expr ⊓ » f g) a = «expr ⊓ » (f a) (g a) :=\n  rfl\n#align inf_apply inf_apply\n\n",
 "induction":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/-- To prove something for an arbitrary simple function, it suffices to show\nthat the property holds for (multiples of) characteristic functions and is closed under\naddition (of functions with disjoint support).\n\nIt is possible to make the hypotheses in `h_add` a bit stronger, and such conditions can be added\nonce we need them (for example it is only necessary to consider the case where `g` is a multiple\nof a characteristic function, and that this multiple doesn't appear in the image of `f`) -/\n@[elab_as_elim]\nprotected theorem induction {α γ} [MeasurableSpace α] [AddMonoid γ] {P : simple_func α γ → Prop}\n    (h_ind :\n      ∀ (c) {s} (hs : MeasurableSet s), P (simple_func.piecewise s hs (simple_func.const _ c) (simple_func.const _ 0)))\n    (h_add : ∀ ⦃f g : simple_func α γ⦄, Disjoint (support f) (support g) → P f → P g → P (f + g))\n    (f : simple_func α γ) : P f := by\n  generalize h : f.range \\ {0} = s\n  rw [← Finset.coe_inj, Finset.coe_sdiff, Finset.coe_singleton, simple_func.coe_range] at h\n  revert s f h; refine' Finset.induction _ _\n  · intro f hf\n    rw [Finset.coe_empty, diff_eq_empty, range_subset_singleton] at hf\n    convert h_ind 0 MeasurableSet.univ\n    ext x\n    simp [hf]\n  · intro x s hxs ih f hf\n    have mx := f.measurable_set_preimage {x}\n    let g := simple_func.piecewise («expr ⁻¹' » f {x}) mx 0 f\n    have Pg : P g := by\n      apply ih\n      simp only [g, simple_func.coe_piecewise, range_piecewise]\n      rw [image_compl_preimage, union_diff_distrib, diff_diff_comm, hf, Finset.coe_insert, insert_diff_self_of_not_mem,\n        diff_eq_empty.mpr, Set.empty_union]\n      · rw [Set.image_subset_iff]\n        convert Set.subset_univ _\n        exact preimage_const_of_mem (mem_singleton _)\n      · rwa [Finset.mem_coe]\n    convert h_add _ Pg (h_ind x mx)\n    · ext1 y\n      by_cases hy : y ∈ «expr ⁻¹' » f {x} <;> [simpa [hy] , simp [hy]]\n    rw [disjoint_iff_inf_le]\n    rintro y\n    by_cases hy : y ∈ «expr ⁻¹' » f {x} <;> simp [hy]\n#align induction induction\n\n",
 "iff_lintegral_lt_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\ntheorem iff_lintegral_lt_top {f : «expr →ₛ » α (ennreal)}\n    (hf :\n      «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\" μ\n        (f a ≠ ennreal.top)) :\n    f.fin_meas_supp μ ↔ f.lintegral μ < ennreal.top :=\n  ⟨fun h => h.lintegral_lt_top hf, fun h => of_lintegral_ne_top h.ne⟩\n#align iff_lintegral_lt_top iff_lintegral_lt_top\n\n",
 "forall_range_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛ » -/\ntheorem forall_range_iff {f : «expr →ₛ » α β} {p : β → Prop} : (∀ y ∈ f.range, p y) ↔ ∀ x, p (f x) := by\n  simp only [mem_range, Set.forall_range_iff]\n#align forall_range_iff forall_range_iff\n\n",
 "finset_sup_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛ » -/\ntheorem finset_sup_apply [SemilatticeSup β] [OrderBot β] {f : γ → «expr →ₛ » α β} (s : Finset γ) (a : α) :\n    s.sup f a = s.sup fun c => f c a := by\n  refine' Finset.induction_on s rfl _\n  intro a s hs ih\n  rw [Finset.sup_insert, Finset.sup_insert, sup_apply, ih]\n#align finset_sup_apply finset_sup_apply\n\n",
 "finite_range":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛ » -/\ntheorem finite_range (f : «expr →ₛ » α β) : (Set.range f).finite :=\n  f.finite_range'\n#align finite_range finite_range\n\n",
 "fin_meas_supp_iff_support":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\ntheorem fin_meas_supp_iff_support : f.fin_meas_supp μ ↔ μ (support f) < ennreal.top :=\n  iff.rfl\n#align fin_meas_supp_iff_support fin_meas_supp_iff_support\n\n",
 "fin_meas_supp_iff":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (y «expr ≠ » 0) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\ntheorem fin_meas_supp_iff : f.fin_meas_supp μ ↔ ∀ (y) (_ : y ≠ 0), μ («expr ⁻¹' » f {y}) < ennreal.top :=\n  by\n  constructor\n  · refine' fun h y hy => lt_of_le_of_lt (measure_mono _) h\n    exact fun x hx (H : f x = 0) => hy <| H ▸ Eq.symm hx\n  · intro H\n    rw [fin_meas_supp_iff_support, support_eq]\n    refine' lt_of_le_of_lt (measure_bUnion_finset_le _ _) (sum_lt_top _)\n    exact fun y hy => (H y (Finset.mem_filter.1 hy).2).ne\n#align fin_meas_supp_iff fin_meas_supp_iff\n\n",
 "extend_comp_eq'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛ » -/\n@[simp]\ntheorem extend_comp_eq' [MeasurableSpace β] (f₁ : «expr →ₛ » α γ) {g : α → β} (hg : MeasurableEmbedding g)\n    (f₂ : «expr →ₛ » β γ) : f₁.extend g hg f₂ ∘ g = f₁ :=\n  funext fun x => extend_apply _ _ _ _\n#align extend_comp_eq' extend_comp_eq'\n\n",
 "extend_comp_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛ » -/\n@[simp]\ntheorem extend_comp_eq [MeasurableSpace β] (f₁ : «expr →ₛ » α γ) {g : α → β} (hg : MeasurableEmbedding g)\n    (f₂ : «expr →ₛ » β γ) : (f₁.extend g hg f₂).comp g hg.measurable = f₁ :=\n  coe_injective <| extend_comp_eq' _ _ _\n#align extend_comp_eq extend_comp_eq\n\n",
 "extend_apply'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛ » -/\n@[simp]\ntheorem extend_apply' [MeasurableSpace β] (f₁ : «expr →ₛ » α γ) {g : α → β} (hg : MeasurableEmbedding g)\n    (f₂ : «expr →ₛ » β γ) {y : β} (h : ¬∃ x, g x = y) : (f₁.extend g hg f₂) y = f₂ y :=\n  Function.extend_apply' _ _ _ h\n#align extend_apply' extend_apply'\n\n",
 "extend_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛ » -/\n@[simp]\ntheorem extend_apply [MeasurableSpace β] (f₁ : «expr →ₛ » α γ) {g : α → β} (hg : MeasurableEmbedding g)\n    (f₂ : «expr →ₛ » β γ) (x : α) : (f₁.extend g hg f₂) (g x) = f₁ x :=\n  hg.injective.extend_apply _ _ _\n#align extend_apply extend_apply\n\n",
 "ext":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛ » -/\n@[ext]\ntheorem ext {f g : «expr →ₛ » α β} (H : ∀ a, f a = g a) : f = g :=\n  coe_injective <| funext H\n#align ext ext\n\n",
 "exists_range_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛ » -/\ntheorem exists_range_iff {f : «expr →ₛ » α β} {p : β → Prop} : (∃ y ∈ f.range, p y) ↔ ∃ x, p (f x) := by\n  simpa only [mem_range, exists_prop] using Set.exists_range_iff\n#align exists_range_iff exists_range_iff\n\n",
 "exists_forall_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛ » -/\ntheorem exists_forall_le [Nonempty β] [preorder β] [IsDirected β (· ≤ ·)] (f : «expr →ₛ » α β) : ∃ C, ∀ x, f x ≤ C :=\n  f.range.exists_le.imp fun C => forall_range_iff.1\n#align exists_forall_le exists_forall_le\n\n",
 "eq_zero_of_mem_range_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛ » -/\ntheorem eq_zero_of_mem_range_zero [Zero β] : ∀ {y : β}, y ∈ (0 : «expr →ₛ » α β).range → y = 0 :=\n  forall_range_iff.2 fun x => rfl\n#align eq_zero_of_mem_range_zero eq_zero_of_mem_range_zero\n\n",
 "ennreal_rat_embed_encode":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\ntheorem ennreal_rat_embed_encode (q : exprℚ) : ennreal_rat_embed (encodable.encode q) = Real.toNNReal q := by\n  rw [ennreal_rat_embed, encodable.encodek] <;> rfl\n#align ennreal_rat_embed_encode ennreal_rat_embed_encode\n\n",
 "ennreal_induction":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/-- To prove something for an arbitrary measurable function into `ℝ≥0∞`, it suffices to show\nthat the property holds for (multiples of) characteristic functions and is closed under addition\nand supremum of increasing sequences of functions.\n\nIt is possible to make the hypotheses in the induction steps a bit stronger, and such conditions\ncan be added once we need them (for example in `h_add` it is only necessary to consider the sum of\na simple function with a multiple of a characteristic function and that the intersection\nof their images is a subset of `{0}`. -/\n@[elab_as_elim]\ntheorem measurable.ennreal_induction {α} [MeasurableSpace α] {P : (α → ennreal) → Prop}\n    (h_ind : ∀ (c : ennreal) ⦃s⦄, MeasurableSet s → P (indicator s fun _ => c))\n    (h_add :\n      ∀ ⦃f g : α → ennreal⦄, Disjoint (support f) (support g) → Measurable f → Measurable g → P f → P g → P (f + g))\n    (h_supr :\n      ∀ ⦃f : ℕ → α → ennreal⦄ (hf : ∀ n, Measurable (f n)) (h_mono : Monotone f) (hP : ∀ n, P (f n)),\n        P fun x =>\n          «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (f n x))\n    ⦃f : α → ennreal⦄ (hf : Measurable f) : P f :=\n  by\n  convert h_supr (fun n => (eapprox f n).measurable) (monotone_eapprox f) _\n  · ext1 x\n    rw [supr_eapprox_apply f hf]\n  ·\n    exact fun n =>\n      simple_func.induction (fun c s hs => h_ind c hs) (fun f g hfg hf hg => h_add hfg f.measurable g.measurable hf hg)\n        (eapprox f n)\n#align measurable.ennreal_induction measurable.ennreal_induction\n\n",
 "eapprox_lt_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\ntheorem eapprox_lt_top (f : α → ennreal) (n : ℕ) (a : α) : eapprox f n a < ennreal.top :=\n  by\n  simp only [eapprox, approx, finset_sup_apply, Finset.sup_lt_iff, WithTop.zero_lt_top, Finset.mem_range,\n    ENNReal.bot_eq_zero, restrict]\n  intro b hb\n  split_ifs\n  · simp only [coe_zero, coe_piecewise, piecewise_eq_indicator, coe_const]\n    calc\n      { a : α | ennreal_rat_embed b ≤ f a }.indicator (fun x => ennreal_rat_embed b) a ≤ ennreal_rat_embed b :=\n        indicator_le_self _ _ a\n      _ < «expr⊤» := ENNReal.coe_lt_top\n      \n  · exact WithTop.zero_lt_top\n#align eapprox_lt_top eapprox_lt_top\n\n",
 "eapprox_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\ntheorem eapprox_comp [MeasurableSpace γ] {f : γ → ennreal} {g : α → γ} {n : ℕ} (hf : Measurable f) (hg : Measurable g) :\n    (eapprox (f ∘ g) n : α → ennreal) = (eapprox f n : «expr →ₛ » γ (ennreal)) ∘ g :=\n  funext fun a => approx_comp a hf hg\n#align eapprox_comp eapprox_comp\n\n",
 "div_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛ » -/\n@[to_additive]\ntheorem div_apply [Div β] (f g : «expr →ₛ » α β) (x : α) : (f / g) x = f x / g x :=\n  rfl\n#align div_apply div_apply\n\n",
 "const_one":
 "@[simp, to_additive]\ntheorem const_one [One β] : const α (1 : β) = 1 :=\n  rfl\n#align const_one const_one\n\n",
 "const_mul_lintegral":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\ntheorem const_mul_lintegral (f : «expr →ₛ » α (ennreal)) (x : ennreal) :\n    (const α x * f).lintegral μ = x * f.lintegral μ :=\n  calc\n    (f.map fun a => x * a).lintegral μ =\n        finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" f.range\n          (x * r * μ («expr ⁻¹' » f {r})) :=\n      map_lintegral _ _\n    _ =\n        finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" f.range\n          (x * (r * μ («expr ⁻¹' » f {r}))) :=\n      (Finset.sum_congr rfl fun a ha => mul_assoc _ _ _)\n    _ = x * f.lintegral μ := Finset.mul_sum.symm\n    \n#align const_mul_lintegral const_mul_lintegral\n\n",
 "const_mul_eq_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛ » -/\n@[to_additive]\ntheorem const_mul_eq_map [Mul β] (f : «expr →ₛ » α β) (b : β) : const α b * f = f.map fun a => b * a :=\n  rfl\n#align const_mul_eq_map const_mul_eq_map\n\n",
 "const_lintegral_restrict":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\ntheorem const_lintegral_restrict (c : ennreal) (s : Set α) : (const α c).lintegral (μ.restrict s) = c * μ s := by\n  rw [const_lintegral, measure.restrict_apply MeasurableSet.univ, univ_inter]\n#align const_lintegral_restrict const_lintegral_restrict\n\n",
 "const_lintegral":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\ntheorem const_lintegral (c : ennreal) : (const α c).lintegral μ = c * μ univ :=\n  by\n  rw [lintegral]\n  cases isEmpty_or_nonempty α\n  · simp [μ.eq_zero_of_is_empty]\n  · simp [preimage_const_of_mem]\n#align const_lintegral const_lintegral\n\n",
 "const_apply":
 "theorem const_apply (a : α) (b : β) : (const α b) a = b :=\n  rfl\n#align const_apply const_apply\n\n",
 "coe_zpow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n@[simp]\ntheorem coe_zpow [DivInvMonoid β] (f : «expr →ₛ » α β) (z : ℤ) : «expr⇑ » (f ^ z) = f ^ z :=\n  rfl\n#align coe_zpow coe_zpow\n\n",
 "coe_sup":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n@[simp, norm_cast]\ntheorem coe_sup [Sup β] (f g : «expr →ₛ » α β) : «expr⇑ » («expr ⊔ » f g) = «expr ⊔ » f g :=\n  rfl\n#align coe_sup coe_sup\n\n",
 "coe_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem coe_smul [SMul K β] (c : K) (f : «expr →ₛ » α β) : «expr⇑ » («expr • » c f) = «expr • » c f :=\n  rfl\n#align coe_smul coe_smul\n\n",
 "coe_restrict":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n@[simp]\ntheorem coe_restrict (f : «expr →ₛ » α β) {s : Set α} (hs : MeasurableSet s) :\n    «expr⇑ » (restrict f s) = indicator s f := by\n  rw [restrict, dif_pos hs]\n  rfl\n#align coe_restrict coe_restrict\n\n",
 "coe_range":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛ » -/\n@[simp]\ntheorem coe_range (f : «expr →ₛ » α β) : (↑f.range : Set β) = Set.range f :=\n  f.finite_range.coe_to_finset\n#align coe_range coe_range\n\n",
 "coe_pow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n@[simp]\ntheorem coe_pow [Monoid β] (f : «expr →ₛ » α β) (n : ℕ) : «expr⇑ » (f ^ n) = f ^ n :=\n  rfl\n#align coe_pow coe_pow\n\n",
 "coe_piecewise":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n@[simp]\ntheorem coe_piecewise {s : Set α} (hs : MeasurableSet s) (f g : «expr →ₛ » α β) :\n    «expr⇑ » (piecewise s hs f g) = s.piecewise f g :=\n  rfl\n#align coe_piecewise coe_piecewise\n\n",
 "coe_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛ » -/\n@[simp, norm_cast, to_additive]\ntheorem coe_one [One β] : «expr⇑ » (1 : «expr →ₛ » α β) = 1 :=\n  rfl\n#align coe_one coe_one\n\n",
 "coe_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n@[simp, norm_cast, to_additive]\ntheorem coe_mul [Mul β] (f g : «expr →ₛ » α β) : «expr⇑ » (f * g) = f * g :=\n  rfl\n#align coe_mul coe_mul\n\n",
 "coe_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛ » -/\n@[simp]\ntheorem coe_map (g : β → γ) (f : «expr →ₛ » α β) : (f.map g : α → γ) = g ∘ f :=\n  rfl\n#align coe_map coe_map\n\n",
 "coe_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛ » -/\n@[simp, norm_cast]\ntheorem coe_le [preorder β] {f g : «expr →ₛ » α β} : (f : α → β) ≤ g ↔ f ≤ g :=\n  iff.rfl\n#align coe_le coe_le\n\n",
 "coe_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n@[simp, norm_cast, to_additive]\ntheorem coe_inv [Inv β] (f : «expr →ₛ » α β) : «expr⇑ » f⁻¹ = f⁻¹ :=\n  rfl\n#align coe_inv coe_inv\n\n",
 "coe_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛ » -/\n/-\nCopyright (c) 2018 Mario Carneiro. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Mario Carneiro, Johannes Hölzl\n-/\ntheorem coe_injective ⦃f g : «expr →ₛ » α β⦄ (H : (f : α → β) = g) : f = g := by\n  cases f <;> cases g <;> congr <;> exact H\n#align coe_injective coe_injective\n\n",
 "coe_inf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n@[simp, norm_cast]\ntheorem coe_inf [Inf β] (f g : «expr →ₛ » α β) : «expr⇑ » («expr ⊓ » f g) = «expr ⊓ » f g :=\n  rfl\n#align coe_inf coe_inf\n\n",
 "coe_div":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n@[simp, norm_cast, to_additive]\ntheorem coe_div [Div β] (f g : «expr →ₛ » α β) : «expr⇑ » (f / g) = f / g :=\n  rfl\n#align coe_div coe_div\n\n",
 "coe_const":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n@[simp]\ntheorem coe_const (b : β) : «expr⇑ » (const α b) = Function.const α b :=\n  rfl\n#align coe_const coe_const\n\n",
 "coe_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n@[simp]\ntheorem coe_comp [MeasurableSpace β] (f : «expr →ₛ » β γ) {g : α → β} (hgm : Measurable g) :\n    «expr⇑ » (f.comp g hgm) = f ∘ g :=\n  rfl\n#align coe_comp coe_comp\n\n",
 "bind_const":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛ » -/\ntheorem bind_const (f : «expr →ₛ » α β) : f.bind (const α) = f := by ext <;> simp\n#align bind_const bind_const\n\n",
 "bind_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛ » -/\n@[simp]\ntheorem bind_apply (f : «expr →ₛ » α β) (g : β → «expr →ₛ » α γ) (a) : f.bind g a = g (f a) a :=\n  rfl\n#align bind_apply bind_apply\n\n",
 "approx_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛ » -/\ntheorem approx_comp [TopologicalSpace β] [OrderClosedTopology β] [MeasurableSpace β] [opens_measurable_space β]\n    [MeasurableSpace γ] {i : ℕ → β} {f : γ → β} {g : α → γ} {n : ℕ} (a : α) (hf : Measurable f) (hg : Measurable g) :\n    (approx i (f ∘ g) n : «expr →ₛ » α β) a = (approx i f n : «expr →ₛ » γ β) (g a) := by\n  rw [approx_apply _ hf, approx_apply _ (hf.comp hg)]\n#align approx_comp approx_comp\n\n",
 "approx_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛ » -/\ntheorem approx_apply [TopologicalSpace β] [OrderClosedTopology β] [MeasurableSpace β] [opens_measurable_space β]\n    {i : ℕ → β} {f : α → β} {n : ℕ} (a : α) (hf : Measurable f) :\n    (approx i f n : «expr →ₛ » α β) a = (Finset.range n).sup fun k => if i k ≤ f a then i k else 0 :=\n  by\n  dsimp only [approx]\n  rw [finset_sup_apply]\n  congr\n  funext k\n  rw [restrict_apply]\n  rfl\n  exact hf measurable_set_Ici\n#align approx_apply approx_apply\n\n",
 "apply_mk":
 "@[simp]\ntheorem apply_mk (f : α → β) (h h') (x : α) : simple_func.mk f h h' x = f x :=\n  rfl\n#align apply_mk apply_mk\n\n",
 "add_lintegral":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\ntheorem add_lintegral (f g : «expr →ₛ » α (ennreal)) : (f + g).lintegral μ = f.lintegral μ + g.lintegral μ :=\n  calc\n    (f + g).lintegral μ =\n        finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (pair f g).range\n          (x.1 * μ («expr ⁻¹' » (pair f g) {x}) + x.2 * μ («expr ⁻¹' » (pair f g) {x})) :=\n      by rw [add_eq_map₂, map_lintegral] <;> exact Finset.sum_congr rfl fun a ha => add_mul _ _ _\n    _ =\n        finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (pair f g).range\n            (x.1 * μ («expr ⁻¹' » (pair f g) {x})) +\n          finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n            (pair f g).range (x.2 * μ («expr ⁻¹' » (pair f g) {x})) :=\n      by rw [Finset.sum_add_distrib]\n    _ = ((pair f g).map Prod.fst).lintegral μ + ((pair f g).map Prod.snd).lintegral μ := by\n      rw [map_lintegral, map_lintegral]\n    _ = lintegral f μ + lintegral g μ := rfl\n    \n#align add_lintegral add_lintegral\n\n",
 "add":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛ » -/\nprotected theorem add {β} [AddMonoid β] {f g : «expr →ₛ » α β} (hf : f.fin_meas_supp μ) (hg : g.fin_meas_supp μ) :\n    (f + g).fin_meas_supp μ := by\n  rw [add_eq_map₂]\n  exact hf.map₂ hg (zero_add 0)\n#align add add\n\n",
 "Measurable":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛ » -/\n#print Measurable /-\n/-- A simple function is measurable -/\n@[measurability]\nprotected theorem Measurable [MeasurableSpace β] (f : «expr →ₛ » α β) : Measurable f := fun s _ =>\n  measurable_set_preimage f s\n#align measurable Measurable\n-/\n\n",
 "AEMeasurable":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛ » -/\n#print AEMeasurable /-\n@[measurability]\nprotected theorem AEMeasurable [MeasurableSpace β] {μ : Measure α} (f : «expr →ₛ » α β) : AEMeasurable f μ :=\n  f.measurable.ae_measurable\n#align ae_measurable AEMeasurable\n-/\n\n"}