{"restrict_map_with_density_abs_det_fderiv_eq_add_haar":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/-- Change of variable formula for differentiable functions, set version: if a function `f` is\ninjective and differentiable on a measurable set `s`, then the pushforward of the measure with\ndensity `|(f' x).det|` on `s` is the Lebesgue measure on the image set. This version is expressed\nin terms of the restricted function `s.restrict f`.\nFor a version for the original function, but with a measurability assumption,\nsee `map_with_density_abs_det_fderiv_eq_add_haar`.\n-/\ntheorem restrict_map_with_density_abs_det_fderiv_eq_add_haar (hs : MeasurableSet s)\n    (hf' : ∀ x ∈ s, has_fderiv_within_at f (f' x) s x) (hf : InjOn f s) :\n    Measure.map (s.restrict f) (comap coe (μ.with_density fun x => ENNReal.ofReal (|(f' x).det|))) =\n      μ.restrict («expr '' » f s) :=\n  by\n  obtain ⟨u, u_meas, uf⟩ : ∃ u, Measurable u ∧ eq_on u f s := by\n    classical\n      refine' ⟨piecewise s f 0, _, piecewise_eq_on _ _ _⟩\n      refine' continuous_on.measurable_piecewise _ continuous_zero.continuous_on hs\n      have : differentiable_on (exprℝ) f s := fun x hx => (hf' x hx).differentiable_within_at\n      exact this.continuous_on\n  have u' : ∀ x ∈ s, has_fderiv_within_at u (f' x) s x := fun x hx => (hf' x hx).congr (fun y hy => uf hy) (uf hx)\n  set F : s → E := u ∘ coe with hF\n  have A :\n    measure.map F (comap coe (μ.with_density fun x => ENNReal.ofReal (|(f' x).det|))) = μ.restrict («expr '' » u s) :=\n    by\n    rw [hF, ← measure.map_map u_meas measurable_subtype_coe, map_comap_subtype_coe hs, restrict_with_density hs]\n    exact map_with_density_abs_det_fderiv_eq_add_haar μ hs u' (hf.congr uf.symm) u_meas\n  rw [uf.image_eq] at A\n  have : F = s.restrict f := by\n    ext x\n    exact uf x.2\n  rwa [this] at A\n#align restrict_map_with_density_abs_det_fderiv_eq_add_haar restrict_map_with_density_abs_det_fderiv_eq_add_haar\n\n",
 "norm_fderiv_sub_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.gt -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.gt -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.gt -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/-- If a differentiable function `f` is approximated by a linear map `A` on a set `s`, up to `δ`,\nthen at almost every `x` in `s` one has `‖f' x - A‖ ≤ δ`. -/\ntheorem _root_.approximates_linear_on.norm_fderiv_sub_le {A : «expr →L[ ] » E (exprℝ) E} {δ : nnreal}\n    (hf : approximates_linear_on f A s δ) (hs : MeasurableSet s) (f' : E → «expr →L[ ] » E (exprℝ) E)\n    (hf' : ∀ x ∈ s, has_fderiv_within_at f (f' x) s x) :\n    «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\" (μ.restrict s)\n      («expr‖ ‖₊» (f' x - A) ≤ δ) :=\n  by\n  /- The conclusion will hold at the Lebesgue density points of `s` (which have full measure).\n    At such a point `x`, for any `z` and any `ε > 0` one has for small `r`\n    that `{x} + r • closed_ball z ε` intersects `s`. At a point `y` in the intersection,\n    `f y - f x` is close both to `f' x (r z)` (by differentiability) and to `A (r z)`\n    (by linear approximation), so these two quantities are close, i.e., `(f' x - A) z` is small. -/\n  filter_upwards [besicovitch.ae_tendsto_measure_inter_div μ s, ae_restrict_mem hs]\n  -- start from a Lebesgue density point `x`, belonging to `s`.\n  intro x hx xs\n  -- consider an arbitrary vector `z`.\n  apply continuous_linear_map.op_norm_le_bound _ δ.2 fun z => _\n  -- to show that `‖(f' x - A) z‖ ≤ δ ‖z‖`, it suffices to do it up to some error that vanishes\n  -- asymptotically in terms of `ε > 0`.\n  suffices H : ∀ ε, 0 < ε → «expr‖ ‖» ((f' x - A) z) ≤ (δ + ε) * («expr‖ ‖» z + ε) + «expr‖ ‖» (f' x - A) * ε\n  · have :\n      tendsto (fun ε : exprℝ => ((δ : exprℝ) + ε) * («expr‖ ‖» z + ε) + «expr‖ ‖» (f' x - A) * ε) (nhds_within.gt 0)\n        ((nhds) ((δ + 0) * («expr‖ ‖» z + 0) + «expr‖ ‖» (f' x - A) * 0)) :=\n      tendsto.mono_left (Continuous.tendsto (by continuity) 0) nhdsWithin_le_nhds\n    simp only [add_zero, MulZeroClass.mul_zero] at this\n    apply le_of_tendsto_of_tendsto tendsto_const_nhds this\n    filter_upwards [self_mem_nhdsWithin]\n    exact H\n  -- fix a positive `ε`.\n  intro ε εpos\n  -- for small enough `r`, the rescaled ball `r • closed_ball z ε` intersects `s`, as `x` is a\n  -- density point\n  have B₁ :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\"\n      (nhds_within.gt (0 : exprℝ)) (s ∩ ({x} + «expr • » r (closed_ball z ε))).nonempty :=\n    eventually_nonempty_inter_smul_of_density_one μ s x hx _ measurable_set_closed_ball\n      (measure_closed_ball_pos μ z εpos).ne'\n  obtain ⟨ρ, ρpos, hρ⟩ :\n    ∃ ρ > 0, ball x ρ ∩ s ⊆ { y : E | «expr‖ ‖» (f y - f x - (f' x) (y - x)) ≤ ε * «expr‖ ‖» (y - x) } :=\n    mem_nhds_within_iff.1 (is_o.def (hf' x xs) εpos)\n  -- for small enough `r`, the rescaled ball `r • closed_ball z ε` is included in the set where\n  -- `f y - f x` is well approximated by `f' x (y - x)`.\n  have B₂ :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\"\n      (nhds_within.gt (0 : exprℝ)) ({x} + «expr • » r (closed_ball z ε) ⊆ ball x ρ) :=\n    nhdsWithin_le_nhds (eventually_singleton_add_smul_subset bounded_closed_ball (ball_mem_nhds x ρpos))\n  -- fix a small positive `r` satisfying the above properties, as well as a corresponding `y`.\n  obtain ⟨r, ⟨y, ⟨ys, hy⟩⟩, rρ, rpos⟩ :\n    ∃ r : exprℝ,\n      (s ∩ ({x} + «expr • » r (closed_ball z ε))).nonempty ∧ {x} + «expr • » r (closed_ball z ε) ⊆ ball x ρ ∧ 0 < r :=\n    (B₁.and (B₂.and self_mem_nhdsWithin)).exists\n  -- write `y = x + r a` with `a ∈ closed_ball z ε`.\n  obtain ⟨a, az, ya⟩ : ∃ a, a ∈ closed_ball z ε ∧ y = x + «expr • » r a :=\n    by\n    simp only [mem_smul_set, image_add_left, mem_preimage, singleton_add] at hy\n    rcases hy with ⟨a, az, ha⟩\n    exact ⟨a, az, by simp only [ha, add_neg_cancel_left]⟩\n  have norm_a : «expr‖ ‖» a ≤ «expr‖ ‖» z + ε :=\n    calc\n      «expr‖ ‖» a = «expr‖ ‖» (z + (a - z)) := by simp only [add_sub_cancel'_right]\n      _ ≤ «expr‖ ‖» z + «expr‖ ‖» (a - z) := (norm_add_le _ _)\n      _ ≤ «expr‖ ‖» z + ε := add_le_add_left (mem_closedBall_iff_norm.1 az) _\n      \n  -- use the approximation properties to control `(f' x - A) a`, and then `(f' x - A) z` as `z` is\n  -- close to `a`.\n  have I : r * «expr‖ ‖» ((f' x - A) a) ≤ r * (δ + ε) * («expr‖ ‖» z + ε) :=\n    calc\n      r * «expr‖ ‖» ((f' x - A) a) = «expr‖ ‖» ((f' x - A) («expr • » r a)) := by\n        simp only [ContinuousLinearMap.map_smul, norm_smul, Real.norm_eq_abs, abs_of_nonneg rpos.le]\n      _ = «expr‖ ‖» (f y - f x - A (y - x) - (f y - f x - (f' x) (y - x))) :=\n        by\n        congr 1\n        simp only [ya, add_sub_cancel', sub_sub_sub_cancel_left, ContinuousLinearMap.coe_sub', eq_self_iff_true,\n          sub_left_inj, Pi.sub_apply, ContinuousLinearMap.map_smul, smul_sub]\n      _ ≤ «expr‖ ‖» (f y - f x - A (y - x)) + «expr‖ ‖» (f y - f x - (f' x) (y - x)) := (norm_sub_le _ _)\n      _ ≤ δ * «expr‖ ‖» (y - x) + ε * «expr‖ ‖» (y - x) := (add_le_add (hf _ ys _ xs) (hρ ⟨rρ hy, ys⟩))\n      _ = r * (δ + ε) * «expr‖ ‖» a :=\n        by\n        simp only [ya, add_sub_cancel', norm_smul, Real.norm_eq_abs, abs_of_nonneg rpos.le]\n        ring\n      _ ≤ r * (δ + ε) * («expr‖ ‖» z + ε) :=\n        mul_le_mul_of_nonneg_left norm_a (mul_nonneg rpos.le (add_nonneg δ.2 εpos.le))\n      \n  show «expr‖ ‖» ((f' x - A) z) ≤ (δ + ε) * («expr‖ ‖» z + ε) + «expr‖ ‖» (f' x - A) * ε\n  exact\n    calc\n      «expr‖ ‖» ((f' x - A) z) = «expr‖ ‖» ((f' x - A) a + (f' x - A) (z - a)) :=\n        by\n        congr 1\n        simp only [ContinuousLinearMap.coe_sub', map_sub, Pi.sub_apply]\n        abel\n      _ ≤ «expr‖ ‖» ((f' x - A) a) + «expr‖ ‖» ((f' x - A) (z - a)) := (norm_add_le _ _)\n      _ ≤ (δ + ε) * («expr‖ ‖» z + ε) + «expr‖ ‖» (f' x - A) * «expr‖ ‖» (z - a) :=\n        by\n        apply add_le_add\n        · rw [mul_assoc] at I\n          exact (mul_le_mul_left rpos).1 I\n        · apply continuous_linear_map.le_op_norm\n      _ ≤ (δ + ε) * («expr‖ ‖» z + ε) + «expr‖ ‖» (f' x - A) * ε :=\n        add_le_add le_rfl (mul_le_mul_of_nonneg_left (mem_closedBall_iff_norm'.1 az) (norm_nonneg _))\n      \n#align approximates_linear_on.norm_fderiv_sub_le approximates_linear_on.norm_fderiv_sub_le\n\n",
 "mul_le_add_haar_image_of_lt_det":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.gt -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.gt -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/-- Let `f` be a function which is sufficiently close (in the Lipschitz sense) to a given linear\nmap `A`. Then it expands the volume of any set by at least `m` for any `m < det A`. -/\ntheorem mul_le_add_haar_image_of_lt_det (A : «expr →L[ ] » E (exprℝ) E) {m : nnreal}\n    (hm : (m : ennreal) < ENNReal.ofReal (|A.det|)) :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\"\n      (nhds_within.gt (0 : nnreal))\n      (∀ (s : Set E) (f : E → E) (hf : approximates_linear_on f A s δ), (m : ennreal) * μ s ≤ μ («expr '' » f s)) :=\n  by\n  apply nhdsWithin_le_nhds\n  -- The assumption `hm` implies that `A` is invertible. If `f` is close enough to `A`, it is also\n  -- invertible. One can then pass to the inverses, and deduce the estimate from\n  -- `add_haar_image_le_mul_of_det_lt` applied to `f⁻¹` and `A⁻¹`.\n  -- exclude first the trivial case where `m = 0`.\n  rcases eq_or_lt_of_le (zero_le m) with (rfl | mpos)\n  · apply eventually_of_forall\n    simp only [forall_const, MulZeroClass.zero_mul, imp_true_iff, zero_le, ENNReal.coe_zero]\n  have hA : A.det ≠ 0 := by\n    intro h\n    simpa only [h, ENNReal.not_lt_zero, ENNReal.ofReal_zero, abs_zero] using hm\n  -- let `B` be the continuous linear equiv version of `A`.\n  let B := A.to_continuous_linear_equiv_of_det_ne_zero hA\n  -- the determinant of `B.symm` is bounded by `m⁻¹`\n  have I : ENNReal.ofReal (|(B.symm : «expr →L[ ] » E (exprℝ) E).det|) < (m⁻¹ : nnreal) :=\n    by\n    simp only [ENNReal.ofReal, abs_inv, Real.toNNReal_inv, ContinuousLinearEquiv.det_coe_symm,\n      continuous_linear_map.coe_to_continuous_linear_equiv_of_det_ne_zero, ENNReal.coe_lt_coe] at hm⊢\n    exact NNReal.inv_lt_inv mpos.ne' hm\n  -- therefore, we may apply `add_haar_image_le_mul_of_det_lt` to `B.symm` and `m⁻¹`.\n  obtain ⟨δ₀, δ₀pos, hδ₀⟩ :\n    ∃ δ : nnreal,\n      0 < δ ∧\n        ∀ (t : Set E) (g : E → E),\n          approximates_linear_on g (B.symm : «expr →L[ ] » E (exprℝ) E) t δ → μ («expr '' » g t) ≤ ↑m⁻¹ * μ t :=\n    by\n    have :\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\"\n        (nhds_within.gt 0)\n        (∀ (t : Set E) (g : E → E),\n          approximates_linear_on g (B.symm : «expr →L[ ] » E (exprℝ) E) t δ → μ («expr '' » g t) ≤ ↑m⁻¹ * μ t) :=\n      add_haar_image_le_mul_of_det_lt μ B.symm I\n    rcases(this.and self_mem_nhdsWithin).exists with ⟨δ₀, h, h'⟩\n    exact ⟨δ₀, h', h⟩\n  -- record smallness conditions for `δ` that will be needed to apply `hδ₀` below.\n  have L1 :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\"\n      ((nhds) (0 : nnreal)) (subsingleton E ∨ δ < («expr‖ ‖₊» (B.symm : «expr →L[ ] » E (exprℝ) E))⁻¹) :=\n    by\n    by_cases subsingleton E\n    · simp only [h, true_or_iff, eventually_const]\n    simp only [h, false_or_iff]\n    apply Iio_mem_nhds\n    simpa only [h, false_or_iff, inv_pos] using B.subsingleton_or_nnnorm_symm_pos\n  have L2 :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\"\n      ((nhds) (0 : nnreal))\n      («expr‖ ‖₊» (B.symm : «expr →L[ ] » E (exprℝ) E) * ((«expr‖ ‖₊» (B.symm : «expr →L[ ] » E (exprℝ) E))⁻¹ - δ)⁻¹ *\n          δ <\n        δ₀) :=\n    by\n    have :\n      tendsto\n        (fun δ =>\n          «expr‖ ‖₊» (B.symm : «expr →L[ ] » E (exprℝ) E) *\n              ((«expr‖ ‖₊» (B.symm : «expr →L[ ] » E (exprℝ) E))⁻¹ - δ)⁻¹ *\n            δ)\n        ((nhds) 0)\n        ((nhds)\n          («expr‖ ‖₊» (B.symm : «expr →L[ ] » E (exprℝ) E) *\n              ((«expr‖ ‖₊» (B.symm : «expr →L[ ] » E (exprℝ) E))⁻¹ - 0)⁻¹ *\n            0)) :=\n      by\n      rcases eq_or_ne («expr‖ ‖₊» (B.symm : «expr →L[ ] » E (exprℝ) E)) 0 with (H | H)\n      · simpa only [H, MulZeroClass.zero_mul] using tendsto_const_nhds\n      refine' tendsto.mul (tendsto_const_nhds.mul _) tendsto_id\n      refine' (tendsto.sub tendsto_const_nhds tendsto_id).inv₀ _\n      simpa only [tsub_zero, inv_eq_zero, ne.def] using H\n    simp only [MulZeroClass.mul_zero] at this\n    exact (tendsto_order.1 this).2 δ₀ δ₀pos\n  -- let `δ` be small enough, and `f` approximated by `B` up to `δ`.\n  filter_upwards [L1, L2]\n  intro δ h1δ h2δ s f hf\n  have hf' : approximates_linear_on f (B : «expr →L[ ] » E (exprℝ) E) s δ :=\n    by\n    convert hf\n    exact A.coe_to_continuous_linear_equiv_of_det_ne_zero _\n  let F := hf'.to_local_equiv h1δ\n  -- the condition to be checked can be reformulated in terms of the inverse maps\n  suffices H : μ («expr '' » F.symm F.target) ≤ (m⁻¹ : nnreal) * μ F.target\n  · change (m : ennreal) * μ F.source ≤ μ F.target\n    rwa [← F.symm_image_target_eq_source, mul_comm, ← ENNReal.le_div_iff_mul_le, div_eq_mul_inv, mul_comm, ←\n      ENNReal.coe_inv mpos.ne']\n    · apply or.inl\n      simpa only [ENNReal.coe_eq_zero, ne.def] using mpos.ne'\n    · simp only [ENNReal.coe_ne_top, true_or_iff, ne.def, not_false_iff]\n  -- as `f⁻¹` is well approximated by `B⁻¹`, the conclusion follows from `hδ₀`\n  -- and our choice of `δ`.\n  exact hδ₀ _ _ ((hf'.to_inv h1δ).mono_num h2δ.le)\n#align mul_le_add_haar_image_of_lt_det mul_le_add_haar_image_of_lt_det\n\n",
 "measurable_image_of_fderiv_within":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/-- If a function is differentiable and injective on a measurable set,\nthen the image is measurable.-/\ntheorem measurable_image_of_fderiv_within (hs : MeasurableSet s) (hf' : ∀ x ∈ s, has_fderiv_within_at f (f' x) s x)\n    (hf : InjOn f s) : MeasurableSet («expr '' » f s) :=\n  haveI : differentiable_on (exprℝ) f s := fun x hx => (hf' x hx).differentiable_within_at\n  hs.image_of_continuous_on_inj_on (differentiable_on.continuous_on this) hf\n#align measurable_image_of_fderiv_within measurable_image_of_fderiv_within\n\n",
 "measurable_embedding_of_fderiv_within":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- If a function is differentiable and injective on a measurable set `s`, then its restriction\nto `s` is a measurable embedding. -/\ntheorem measurable_embedding_of_fderiv_within (hs : MeasurableSet s) (hf' : ∀ x ∈ s, has_fderiv_within_at f (f' x) s x)\n    (hf : InjOn f s) : MeasurableEmbedding (s.restrict f) :=\n  haveI : differentiable_on (exprℝ) f s := fun x hx => (hf' x hx).differentiable_within_at\n  this.continuous_on.measurable_embedding hs hf\n#align measurable_embedding_of_fderiv_within measurable_embedding_of_fderiv_within\n\n",
 "map_with_density_abs_det_fderiv_eq_add_haar":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/-- Change of variable formula for differentiable functions, set version: if a function `f` is\ninjective and differentiable on a measurable set `s`, then the pushforward of the measure with\ndensity `|(f' x).det|` on `s` is the Lebesgue measure on the image set. This version requires\nthat `f` is measurable, as otherwise `measure.map f` is zero per our definitions.\nFor a version without measurability assumption but dealing with the restricted\nfunction `s.restrict f`, see `restrict_map_with_density_abs_det_fderiv_eq_add_haar`.\n-/\ntheorem map_with_density_abs_det_fderiv_eq_add_haar (hs : MeasurableSet s)\n    (hf' : ∀ x ∈ s, has_fderiv_within_at f (f' x) s x) (hf : InjOn f s) (h'f : Measurable f) :\n    Measure.map f ((μ.restrict s).with_density fun x => ENNReal.ofReal (|(f' x).det|)) = μ.restrict («expr '' » f s) :=\n  by\n  apply measure.ext fun t ht => _\n  rw [map_apply h'f ht, with_density_apply _ (h'f ht), measure.restrict_apply ht, restrict_restrict (h'f ht),\n    lintegral_abs_det_fderiv_eq_add_haar_image μ ((h'f ht).inter hs)\n      (fun x hx => (hf' x hx.2).mono (inter_subset_right _ _)) (hf.mono (inter_subset_right _ _)),\n    image_preimage_inter]\n#align map_with_density_abs_det_fderiv_eq_add_haar map_with_density_abs_det_fderiv_eq_add_haar\n\n",
 "lintegral_image_eq_lintegral_abs_det_fderiv_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫⁻ in , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ in , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫⁻ in , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ in , ∂ » -/\n/- Change of variable formula for differentiable functions: if a function `f` is\ninjective and differentiable on a measurable set `s`, then the Lebesgue integral of a function\n`g : E → ℝ≥0∞` on `f '' s` coincides with the integral of `|(f' x).det| * g ∘ f` on `s`.\nNote that the measurability of `f '' s` is given by `measurable_image_of_fderiv_within`. -/\ntheorem lintegral_image_eq_lintegral_abs_det_fderiv_mul (hs : MeasurableSet s)\n    (hf' : ∀ x ∈ s, has_fderiv_within_at f (f' x) s x) (hf : InjOn f s) (g : E → ennreal) :\n    «expr∫⁻ in , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ in , ∂ »\"\n        («expr '' » f s) (g x) μ =\n      «expr∫⁻ in , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ in , ∂ »\" s\n        (ENNReal.ofReal (|(f' x).det|) * g (f x)) μ :=\n  by\n  rw [← restrict_map_with_density_abs_det_fderiv_eq_add_haar μ hs hf' hf,\n    (measurable_embedding_of_fderiv_within hs hf' hf).lintegral_map]\n  have : ∀ x : s, g (s.restrict f x) = (g ∘ f) x := fun x => rfl\n  simp only [this]\n  rw [← (MeasurableEmbedding.subtype_coe hs).lintegral_map, map_comap_subtype_coe hs,\n    set_lintegral_with_density_eq_set_lintegral_mul_non_measurable₀ _ _ _ hs]\n  · rfl\n  · simp only [eventually_true, ENNReal.ofReal_lt_top]\n  · exact ae_measurable_of_real_abs_det_fderiv_within μ hs hf'\n#align lintegral_image_eq_lintegral_abs_det_fderiv_mul lintegral_image_eq_lintegral_abs_det_fderiv_mul\n\n",
 "lintegral_abs_det_fderiv_le_add_haar_image_aux2":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.gt -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫⁻ in , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ in , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem lintegral_abs_det_fderiv_le_add_haar_image_aux2 (hs : MeasurableSet s) (h's : μ s ≠ ennreal.top)\n    (hf' : ∀ x ∈ s, has_fderiv_within_at f (f' x) s x) (hf : InjOn f s) :\n    «expr∫⁻ in , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ in , ∂ »\" s\n        (ENNReal.ofReal (|(f' x).det|)) μ ≤\n      μ («expr '' » f s) :=\n  by\n  -- We just need to let the error tend to `0` in the previous lemma.\n  have :\n    tendsto (fun ε : nnreal => μ («expr '' » f s) + 2 * ε * μ s) (nhds_within.gt 0)\n      ((nhds) (μ («expr '' » f s) + 2 * (0 : nnreal) * μ s)) :=\n    by\n    apply tendsto.mono_left _ nhdsWithin_le_nhds\n    refine' tendsto_const_nhds.add _\n    refine' ENNReal.Tendsto.mul_const _ (or.inr h's)\n    exact ENNReal.Tendsto.const_mul (ENNReal.tendsto_coe.2 tendsto_id) (or.inr ENNReal.coe_ne_top)\n  simp only [add_zero, MulZeroClass.zero_mul, MulZeroClass.mul_zero, ENNReal.coe_zero] at this\n  apply ge_of_tendsto this\n  filter_upwards [self_mem_nhdsWithin]\n  rintro ε (εpos : 0 < ε)\n  exact lintegral_abs_det_fderiv_le_add_haar_image_aux1 μ hs hf' hf εpos\n#align lintegral_abs_det_fderiv_le_add_haar_image_aux2 lintegral_abs_det_fderiv_le_add_haar_image_aux2\n\n",
 "lintegral_abs_det_fderiv_le_add_haar_image_aux1":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr on » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫⁻ in , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ in , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫⁻ in , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ in , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫⁻ in , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ in , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫⁻ in , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ in , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem lintegral_abs_det_fderiv_le_add_haar_image_aux1 (hs : MeasurableSet s)\n    (hf' : ∀ x ∈ s, has_fderiv_within_at f (f' x) s x) (hf : InjOn f s) {ε : nnreal} (εpos : 0 < ε) :\n    «expr∫⁻ in , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ in , ∂ »\" s\n        (ENNReal.ofReal (|(f' x).det|)) μ ≤\n      μ («expr '' » f s) + 2 * ε * μ s :=\n  by\n  /- To bound `∫⁻ x in s, ennreal.of_real (|(f' x).det|) ∂μ`, we cover `s` by sets where `f` is\n    well-approximated by linear maps `A n` (and where `f'` is almost everywhere close to `A n`),\n    and then use that `f` expands the measure of such a set by at least `(A n).det - ε`. -/\n  have :\n    ∀ A : «expr →L[ ] » E (exprℝ) E,\n      ∃ δ : nnreal,\n        0 < δ ∧\n          (∀ B : «expr →L[ ] » E (exprℝ) E, «expr‖ ‖» (B - A) ≤ δ → |B.det - A.det| ≤ ε) ∧\n            ∀ (t : Set E) (g : E → E) (hf : approximates_linear_on g A t δ),\n              ENNReal.ofReal (|A.det|) * μ t ≤ μ («expr '' » g t) + ε * μ t :=\n    by\n    intro A\n    obtain ⟨δ', δ'pos, hδ'⟩ : ∃ (δ' : exprℝ)(H : 0 < δ'), ∀ B, dist B A < δ' → dist B.det A.det < ↑ε :=\n      continuous_at_iff.1 continuous_linear_map.continuous_det.continuous_at ε εpos\n    let δ'' : nnreal := ⟨δ' / 2, (half_pos δ'pos).le⟩\n    have I'' : ∀ B : «expr →L[ ] » E (exprℝ) E, «expr‖ ‖» (B - A) ≤ ↑δ'' → |B.det - A.det| ≤ ↑ε :=\n      by\n      intro B hB\n      rw [← Real.dist_eq]\n      apply (hδ' B _).le\n      rw [dist_eq_norm]\n      exact hB.trans_lt (half_lt_self δ'pos)\n    rcases eq_or_ne A.det 0 with (hA | hA)\n    · refine' ⟨δ'', half_pos δ'pos, I'', _⟩\n      simp only [hA, forall_const, MulZeroClass.zero_mul, ENNReal.ofReal_zero, imp_true_iff, zero_le, abs_zero]\n    let m : nnreal := Real.toNNReal (|A.det|) - ε\n    have I : (m : ennreal) < ENNReal.ofReal (|A.det|) :=\n      by\n      simp only [ENNReal.ofReal, WithTop.coe_sub]\n      apply ENNReal.sub_lt_self ENNReal.coe_ne_top\n      · simpa only [abs_nonpos_iff, Real.toNNReal_eq_zero, ENNReal.coe_eq_zero, ne.def] using hA\n      · simp only [εpos.ne', ENNReal.coe_eq_zero, ne.def, not_false_iff]\n    rcases((mul_le_add_haar_image_of_lt_det μ A I).and self_mem_nhdsWithin).exists with ⟨δ, h, δpos⟩\n    refine' ⟨min δ δ'', lt_min δpos (half_pos δ'pos), _, _⟩\n    · intro B hB\n      apply I'' _ (hB.trans _)\n      simp only [le_refl, NNReal.coe_min, min_le_iff, or_true_iff]\n    · intro t g htg\n      rcases eq_or_ne (μ t) (ennreal.top) with (ht | ht)\n      · simp only [ht, εpos.ne', WithTop.mul_top, ENNReal.coe_eq_zero, le_top, ne.def, not_false_iff, _root_.add_top]\n      have := h t g (htg.mono_num (min_le_left _ _))\n      rwa [WithTop.coe_sub, ENNReal.sub_mul, tsub_le_iff_right] at this\n      simp only [ht, imp_true_iff, ne.def, not_false_iff]\n  choose δ hδ using this\n  obtain ⟨t, A, t_disj, t_meas, t_cover, ht, -⟩ :\n    ∃ (t : ℕ → Set E)(A : ℕ → «expr →L[ ] » E (exprℝ) E),\n      Pairwise («expr on » Disjoint t) ∧\n        (∀ n : ℕ, MeasurableSet (t n)) ∧\n          s ⊆ «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (t n) ∧\n            (∀ n : ℕ, approximates_linear_on f (A n) (s ∩ t n) (δ (A n))) ∧ (s.nonempty → ∀ n, ∃ y ∈ s, A n = f' y) :=\n    exists_partition_approximates_linear_on_of_has_fderiv_within_at f s f' hf' δ fun A => (hδ A).1.ne'\n  have s_eq :\n    s = «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (s ∩ t n) :=\n    by\n    rw [← inter_Union]\n    exact subset.antisymm (subset_inter subset.rfl t_cover) (inter_subset_left _ _)\n  calc\n    «expr∫⁻ in , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ in , ∂ »\" s\n          (ENNReal.ofReal (|(f' x).det|)) μ =\n        «expr∑' , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , »\"\n          («expr∫⁻ in , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ in , ∂ »\"\n            (s ∩ t n) (ENNReal.ofReal (|(f' x).det|)) μ) :=\n      by\n      conv_lhs => rw [s_eq]\n      rw [lintegral_Union]\n      · exact fun n => hs.inter (t_meas n)\n      · exact pairwise_disjoint_mono t_disj fun n => inter_subset_right _ _\n    _ ≤\n        «expr∑' , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , »\"\n          («expr∫⁻ in , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ in , ∂ »\"\n            (s ∩ t n) (ENNReal.ofReal (|(A n).det|) + ε) μ) :=\n      by\n      apply ENNReal.tsum_le_tsum fun n => _\n      apply lintegral_mono_ae\n      filter_upwards [(ht n).norm_fderiv_sub_le μ (hs.inter (t_meas n)) f' fun x hx =>\n          (hf' x hx.1).mono (inter_subset_left _ _)]\n      intro x hx\n      have I : |(f' x).det| ≤ |(A n).det| + ε :=\n        calc\n          |(f' x).det| = |(A n).det + ((f' x).det - (A n).det)| :=\n            by\n            congr 1\n            abel\n          _ ≤ |(A n).det| + |(f' x).det - (A n).det| := (abs_add _ _)\n          _ ≤ |(A n).det| + ε := add_le_add le_rfl ((hδ (A n)).2.1 _ hx)\n          \n      calc\n        ENNReal.ofReal (|(f' x).det|) ≤ ENNReal.ofReal (|(A n).det| + ε) := ENNReal.ofReal_le_ofReal I\n        _ = ENNReal.ofReal (|(A n).det|) + ε := by\n          simp only [ENNReal.ofReal_add, abs_nonneg, NNReal.zero_le_coe, ENNReal.ofReal_coe_nnreal]\n        \n    _ =\n        «expr∑' , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , »\"\n          (ENNReal.ofReal (|(A n).det|) * μ (s ∩ t n) + ε * μ (s ∩ t n)) :=\n      by simp only [set_lintegral_const, lintegral_add_right _ measurable_const]\n    _ ≤\n        «expr∑' , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , »\"\n          (μ («expr '' » f (s ∩ t n)) + ε * μ (s ∩ t n) + ε * μ (s ∩ t n)) :=\n      by\n      refine' ENNReal.tsum_le_tsum fun n => add_le_add_right _ _\n      exact (hδ (A n)).2.2 _ _ (ht n)\n    _ = μ («expr '' » f s) + 2 * ε * μ s := by\n      conv_rhs => rw [s_eq]\n      rw [image_Union, measure_Union]; rotate_left\n      · intro i j hij\n        apply Disjoint.image _ hf (inter_subset_left _ _) (inter_subset_left _ _)\n        exact Disjoint.mono (inter_subset_right _ _) (inter_subset_right _ _) (t_disj hij)\n      · intro i\n        exact\n          measurable_image_of_fderiv_within (hs.inter (t_meas i))\n            (fun x hx => (hf' x hx.1).mono (inter_subset_left _ _)) (hf.mono (inter_subset_left _ _))\n      rw [measure_Union]; rotate_left\n      · exact pairwise_disjoint_mono t_disj fun i => inter_subset_right _ _\n      · exact fun i => hs.inter (t_meas i)\n      rw [← ENNReal.tsum_mul_left, ← ENNReal.tsum_add]\n      congr 1\n      ext1 i\n      rw [mul_assoc, two_mul, add_assoc]\n    \n#align lintegral_abs_det_fderiv_le_add_haar_image_aux1 lintegral_abs_det_fderiv_le_add_haar_image_aux1\n\n",
 "lintegral_abs_det_fderiv_le_add_haar_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫⁻ in , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ in , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫⁻ in , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ in , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫⁻ in , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ in , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem lintegral_abs_det_fderiv_le_add_haar_image (hs : MeasurableSet s)\n    (hf' : ∀ x ∈ s, has_fderiv_within_at f (f' x) s x) (hf : InjOn f s) :\n    «expr∫⁻ in , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ in , ∂ »\" s\n        (ENNReal.ofReal (|(f' x).det|)) μ ≤\n      μ («expr '' » f s) :=\n  by\n  /- We already know the result for finite-measure sets. We cover `s` by finite-measure sets using\n    `spanning_sets μ`, and apply the previous result to each of these parts. -/\n  let u n := disjointed (spanning_sets μ) n\n  have u_meas : ∀ n, MeasurableSet (u n) := by\n    intro n\n    apply MeasurableSet.disjointed fun i => _\n    exact measurable_spanning_sets μ i\n  have A :\n    s = «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (s ∩ u n) := by\n    rw [← inter_Union, unionᵢ_disjointed, Union_spanning_sets, inter_univ]\n  calc\n    «expr∫⁻ in , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ in , ∂ »\" s\n          (ENNReal.ofReal (|(f' x).det|)) μ =\n        «expr∑' , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , »\"\n          («expr∫⁻ in , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ in , ∂ »\"\n            (s ∩ u n) (ENNReal.ofReal (|(f' x).det|)) μ) :=\n      by\n      conv_lhs => rw [A]\n      rw [lintegral_Union]\n      · intro n\n        exact hs.inter (u_meas n)\n      · exact pairwise_disjoint_mono (disjoint_disjointed _) fun n => inter_subset_right _ _\n    _ ≤\n        «expr∑' , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , »\"\n          (μ («expr '' » f (s ∩ u n))) :=\n      by\n      apply ENNReal.tsum_le_tsum fun n => _\n      apply\n        lintegral_abs_det_fderiv_le_add_haar_image_aux2 μ (hs.inter (u_meas n)) _\n          (fun x hx => (hf' x hx.1).mono (inter_subset_left _ _)) (hf.mono (inter_subset_left _ _))\n      have : μ (u n) < ennreal.top :=\n        lt_of_le_of_lt (measure_mono (disjointed_subset _ _)) (measure_spanning_sets_lt_top μ n)\n      exact ne_of_lt (lt_of_le_of_lt (measure_mono (inter_subset_right _ _)) this)\n    _ = μ («expr '' » f s) := by\n      conv_rhs => rw [A, image_Union]\n      rw [measure_Union]\n      · intro i j hij\n        apply Disjoint.image _ hf (inter_subset_left _ _) (inter_subset_left _ _)\n        exact Disjoint.mono (inter_subset_right _ _) (inter_subset_right _ _) (disjoint_disjointed _ hij)\n      · intro i\n        exact\n          measurable_image_of_fderiv_within (hs.inter (u_meas i))\n            (fun x hx => (hf' x hx.1).mono (inter_subset_left _ _)) (hf.mono (inter_subset_left _ _))\n    \n#align lintegral_abs_det_fderiv_le_add_haar_image lintegral_abs_det_fderiv_le_add_haar_image\n\n",
 "lintegral_abs_det_fderiv_eq_add_haar_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫⁻ in , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ in , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/-- Change of variable formula for differentiable functions, set version: if a function `f` is\ninjective and differentiable on a measurable set `s`, then the measure of `f '' s` is given by the\nintegral of `|(f' x).det|` on `s`.\nNote that the measurability of `f '' s` is given by `measurable_image_of_fderiv_within`. -/\ntheorem lintegral_abs_det_fderiv_eq_add_haar_image (hs : MeasurableSet s)\n    (hf' : ∀ x ∈ s, has_fderiv_within_at f (f' x) s x) (hf : InjOn f s) :\n    «expr∫⁻ in , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ in , ∂ »\" s\n        (ENNReal.ofReal (|(f' x).det|)) μ =\n      μ («expr '' » f s) :=\n  le_antisymm (lintegral_abs_det_fderiv_le_add_haar_image μ hs hf' hf)\n    (add_haar_image_le_lintegral_abs_det_fderiv μ hs hf')\n#align lintegral_abs_det_fderiv_eq_add_haar_image lintegral_abs_det_fderiv_eq_add_haar_image\n\n",
 "integral_target_eq_integral_abs_det_fderiv_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ in , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ in , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ in , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ in , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem integral_target_eq_integral_abs_det_fderiv_smul [CompleteSpace F] {f : LocalHomeomorph E E}\n    (hf' : ∀ x ∈ f.source, has_fderiv_at f (f' x) x) (g : E → F) :\n    «expr∫ in , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ in , ∂ »\" f.target\n        (g x) μ =\n      «expr∫ in , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ in , ∂ »\" f.source\n        («expr • » (|(f' x).det|) (g (f x))) μ :=\n  by\n  have : «expr '' » f f.source = f.target := LocalEquiv.image_source_eq_target f.to_local_equiv\n  rw [← this]\n  apply integral_image_eq_integral_abs_det_fderiv_smul μ f.open_source.measurable_set _ f.inj_on\n  intro x hx\n  exact (hf' x hx).has_fderiv_within_at\n#align integral_target_eq_integral_abs_det_fderiv_smul integral_target_eq_integral_abs_det_fderiv_smul\n\n",
 "integral_image_eq_integral_abs_det_fderiv_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ in , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ in , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ in , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ in , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- Change of variable formula for differentiable functions: if a function `f` is\ninjective and differentiable on a measurable set `s`, then the Bochner integral of a function\n`g : E → F` on `f '' s` coincides with the integral of `|(f' x).det| • g ∘ f` on `s`. -/\ntheorem integral_image_eq_integral_abs_det_fderiv_smul [CompleteSpace F] (hs : MeasurableSet s)\n    (hf' : ∀ x ∈ s, has_fderiv_within_at f (f' x) s x) (hf : InjOn f s) (g : E → F) :\n    «expr∫ in , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ in , ∂ »\"\n        («expr '' » f s) (g x) μ =\n      «expr∫ in , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ in , ∂ »\" s\n        («expr • » (|(f' x).det|) (g (f x))) μ :=\n  by\n  rw [← restrict_map_with_density_abs_det_fderiv_eq_add_haar μ hs hf' hf,\n    (measurable_embedding_of_fderiv_within hs hf' hf).integral_map]\n  have : ∀ x : s, g (s.restrict f x) = (g ∘ f) x := fun x => rfl\n  simp only [this, ENNReal.ofReal]\n  rw [← (MeasurableEmbedding.subtype_coe hs).integral_map, map_comap_subtype_coe hs,\n    set_integral_with_density_eq_set_integral_smul₀ (ae_measurable_to_nnreal_abs_det_fderiv_within μ hs hf') _ hs]\n  congr with x\n  conv_rhs => rw [← Real.coe_toNNReal _ (abs_nonneg (f' x).det)]\n  rfl\n#align integral_image_eq_integral_abs_det_fderiv_smul integral_image_eq_integral_abs_det_fderiv_smul\n\n",
 "integral_image_eq_integral_abs_deriv_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- Change of variable formula for differentiable functions (one-variable version): if a function\n`f` is injective and differentiable on a measurable set `s ⊆ ℝ`, then the Bochner integral of a\nfunction `g : ℝ → F` on `f '' s` coincides with the integral of `|(f' x).det| • g ∘ f` on `s`. -/\ntheorem integral_image_eq_integral_abs_deriv_smul {s : Set (exprℝ)} {f : exprℝ → exprℝ} {f' : exprℝ → exprℝ}\n    [CompleteSpace F] (hs : MeasurableSet s) (hf' : ∀ x ∈ s, has_deriv_within_at f (f' x) s x) (hf : InjOn f s)\n    (g : exprℝ → F) :\n    «expr∫ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ in , »\"\n        («expr '' » f s) (g x) =\n      «expr∫ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ in , »\" s\n        («expr • » (|f' x|) (g (f x))) :=\n  by\n  convert integral_image_eq_integral_abs_det_fderiv_smul volume hs (fun x hx => (hf' x hx).has_fderiv_within_at) hf g\n  ext1 x\n  rw [(by\n      ext\n      simp :\n      (1 : «expr →L[ ] » (exprℝ) (exprℝ) (exprℝ)).smul_right (f' x) =\n        «expr • » (f' x) (1 : «expr →L[ ] » (exprℝ) (exprℝ) (exprℝ)))]\n  rw [ContinuousLinearMap.det, ContinuousLinearMap.coe_smul]\n  have :\n    ((1 : «expr →L[ ] » (exprℝ) (exprℝ) (exprℝ)) : «expr →ₗ[ ] » (exprℝ) (exprℝ) (exprℝ)) =\n      (1 : «expr →ₗ[ ] » (exprℝ) (exprℝ) (exprℝ)) :=\n    by rfl\n  rw [this, LinearMap.det_smul, FiniteDimensional.finrank_self]\n  suffices (1 : «expr →ₗ[ ] » (exprℝ) (exprℝ) (exprℝ)).det = 1\n    by\n    rw [this]\n    simp\n  exact LinearMap.det_id\n#align integral_image_eq_integral_abs_deriv_smul integral_image_eq_integral_abs_deriv_smul\n\n",
 "integrable_on_image_iff_integrable_on_abs_det_fderiv_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- Integrability in the change of variable formula for differentiable functions: if a\nfunction `f` is injective and differentiable on a measurable set `s`, then a function\n`g : E → F` is integrable on `f '' s` if and only if `|(f' x).det| • g ∘ f` is\nintegrable on `s`. -/\ntheorem integrable_on_image_iff_integrable_on_abs_det_fderiv_smul (hs : MeasurableSet s)\n    (hf' : ∀ x ∈ s, has_fderiv_within_at f (f' x) s x) (hf : InjOn f s) (g : E → F) :\n    integrable_on g («expr '' » f s) μ ↔ integrable_on (fun x => «expr • » (|(f' x).det|) (g (f x))) s μ :=\n  by\n  rw [integrable_on, ← restrict_map_with_density_abs_det_fderiv_eq_add_haar μ hs hf' hf,\n    (measurable_embedding_of_fderiv_within hs hf' hf).integrable_map_iff]\n  change integrable ((g ∘ f) ∘ (coe : s → E)) _ ↔ _\n  rw [← (MeasurableEmbedding.subtype_coe hs).integrable_map_iff, map_comap_subtype_coe hs]\n  simp only [ENNReal.ofReal]\n  rw [restrict_with_density hs, integrable_with_density_iff_integrable_coe_smul₀, integrable_on]\n  · congr 2 with x\n    rw [Real.coe_toNNReal]\n    exact abs_nonneg _\n  · exact ae_measurable_to_nnreal_abs_det_fderiv_within μ hs hf'\n#align integrable_on_image_iff_integrable_on_abs_det_fderiv_smul integrable_on_image_iff_integrable_on_abs_det_fderiv_smul\n\n",
 "exists_partition_approximates_linear_on_of_has_fderiv_within_at":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr on » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/-- Assume that a function `f` has a derivative at every point of a set `s`. Then one may\npartition `s` into countably many disjoint relatively measurable sets (i.e., intersections\nof `s` with measurable sets `t n`) on which `f` is well approximated by linear maps `A n`. -/\ntheorem exists_partition_approximates_linear_on_of_has_fderiv_within_at [SecondCountableTopology F] (f : E → F)\n    (s : Set E) (f' : E → «expr →L[ ] » E (exprℝ) F) (hf' : ∀ x ∈ s, has_fderiv_within_at f (f' x) s x)\n    (r : «expr →L[ ] » E (exprℝ) F → nnreal) (rpos : ∀ A, r A ≠ 0) :\n    ∃ (t : ℕ → Set E)(A : ℕ → «expr →L[ ] » E (exprℝ) F),\n      Pairwise («expr on » Disjoint t) ∧\n        (∀ n, MeasurableSet (t n)) ∧\n          s ⊆ «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (t n) ∧\n            (∀ n, approximates_linear_on f (A n) (s ∩ t n) (r (A n))) ∧ (s.nonempty → ∀ n, ∃ y ∈ s, A n = f' y) :=\n  by\n  rcases exists_closed_cover_approximates_linear_on_of_has_fderiv_within_at f s f' hf' r rpos with\n    ⟨t, A, t_closed, st, t_approx, ht⟩\n  refine'\n    ⟨disjointed t, A, disjoint_disjointed _, MeasurableSet.disjointed fun n => (t_closed n).measurable_set, _, _, ht⟩\n  · rw [unionᵢ_disjointed]\n    exact st\n  · intro n\n    exact (t_approx n).mono_set (inter_subset_inter_right _ (disjointed_subset _ _))\n#align exists_partition_approximates_linear_on_of_has_fderiv_within_at exists_partition_approximates_linear_on_of_has_fderiv_within_at\n\n",
 "exists_closed_cover_approximates_linear_on_of_has_fderiv_within_at":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/-\nCopyright (c) 2022 Sébastien Gouëzel. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Sébastien Gouëzel\n-/\n/-- Assume that a function `f` has a derivative at every point of a set `s`. Then one may cover `s`\nwith countably many closed sets `t n` on which `f` is well approximated by linear maps `A n`. -/\ntheorem exists_closed_cover_approximates_linear_on_of_has_fderiv_within_at [SecondCountableTopology F] (f : E → F)\n    (s : Set E) (f' : E → «expr →L[ ] » E (exprℝ) F) (hf' : ∀ x ∈ s, has_fderiv_within_at f (f' x) s x)\n    (r : «expr →L[ ] » E (exprℝ) F → nnreal) (rpos : ∀ A, r A ≠ 0) :\n    ∃ (t : ℕ → Set E)(A : ℕ → «expr →L[ ] » E (exprℝ) F),\n      (∀ n, IsClosed (t n)) ∧\n        s ⊆ «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (t n) ∧\n          (∀ n, approximates_linear_on f (A n) (s ∩ t n) (r (A n))) ∧ (s.nonempty → ∀ n, ∃ y ∈ s, A n = f' y) :=\n  by\n  /- Choose countably many linear maps `f' z`. For every such map, if `f` has a derivative at `x`\n    close enough to `f' z`, then `f y - f x` is well approximated by `f' z (y - x)` for `y` close\n    enough to `x`, say on a ball of radius `r` (or even `u n` for some `n`, where `u` is a fixed\n    sequence tending to `0`).\n    Let `M n z` be the points where this happens. Then this set is relatively closed inside `s`,\n    and moreover in every closed ball of radius `u n / 3` inside it the map is well approximated by\n    `f' z`. Using countably many closed balls to split `M n z` into small diameter subsets `K n z p`,\n    one obtains the desired sets `t q` after reindexing.\n    -/\n  -- exclude the trivial case where `s` is empty\n  rcases eq_empty_or_nonempty s with (rfl | hs)\n  · refine' ⟨fun n => ∅, fun n => 0, _, _, _, _⟩ <;> simp\n  -- we will use countably many linear maps. Select these from all the derivatives since the\n  -- space of linear maps is second-countable\n  obtain ⟨T, T_count, hT⟩ :\n    ∃ T : Set s,\n      T.countable ∧\n        «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n            (ball (f' (x : E)) (r (f' x))) =\n          «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n            (ball (f' x) (r (f' x))) :=\n    TopologicalSpace.isOpen_unionᵢ_countable _ fun x => is_open_ball\n  -- fix a sequence `u` of positive reals tending to zero.\n  obtain ⟨u, u_anti, u_pos, u_lim⟩ : ∃ u : ℕ → exprℝ, StrictAnti u ∧ (∀ n : ℕ, 0 < u n) ∧ tendsto u at_top ((nhds) 0) :=\n    exists_seq_strictAnti_tendsto (0 : exprℝ)\n  -- `M n z` is the set of points `x` such that `f y - f x` is close to `f' z (y - x)` for `y`\n  -- in the ball of radius `u n` around `x`.\n  let M : ℕ → T → Set E := fun n z =>\n    { x | x ∈ s ∧ ∀ y ∈ s ∩ ball x (u n), «expr‖ ‖» (f y - f x - f' z (y - x)) ≤ r (f' z) * «expr‖ ‖» (y - x) }\n  -- As `f` is differentiable everywhere on `s`, the sets `M n z` cover `s` by design.\n  have s_subset : ∀ x ∈ s, ∃ (n : ℕ)(z : T), x ∈ M n z :=\n    by\n    intro x xs\n    obtain ⟨z, zT, hz⟩ : ∃ z ∈ T, f' x ∈ ball (f' (z : E)) (r (f' z)) :=\n      by\n      have :\n        f' x ∈\n          «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n            (ball (f' (z : E)) (r (f' z))) :=\n        by\n        rw [hT]\n        refine' mem_Union.2 ⟨⟨x, xs⟩, _⟩\n        simpa only [mem_ball, Subtype.coe_mk, dist_self] using (rpos (f' x)).bot_lt\n      rwa [mem_Union₂] at this\n    obtain ⟨ε, εpos, hε⟩ : ∃ ε : exprℝ, 0 < ε ∧ «expr‖ ‖» (f' x - f' z) + ε ≤ r (f' z) :=\n      by\n      refine' ⟨r (f' z) - «expr‖ ‖» (f' x - f' z), _, le_of_eq (by abel)⟩\n      simpa only [sub_pos] using mem_ball_iff_norm.mp hz\n    obtain ⟨δ, δpos, hδ⟩ :\n      ∃ (δ : exprℝ)(H : 0 < δ), ball x δ ∩ s ⊆ { y | «expr‖ ‖» (f y - f x - (f' x) (y - x)) ≤ ε * «expr‖ ‖» (y - x) } :=\n      Metric.mem_nhdsWithin_iff.1 (is_o.def (hf' x xs) εpos)\n    obtain ⟨n, hn⟩ : ∃ n, u n < δ := ((tendsto_order.1 u_lim).2 _ δpos).exists\n    refine' ⟨n, ⟨z, zT⟩, ⟨xs, _⟩⟩\n    intro y hy\n    calc\n      «expr‖ ‖» (f y - f x - (f' z) (y - x)) = «expr‖ ‖» (f y - f x - (f' x) (y - x) + (f' x - f' z) (y - x)) :=\n        by\n        congr 1\n        simp only [ContinuousLinearMap.coe_sub', map_sub, Pi.sub_apply]\n        abel\n      _ ≤ «expr‖ ‖» (f y - f x - (f' x) (y - x)) + «expr‖ ‖» ((f' x - f' z) (y - x)) := (norm_add_le _ _)\n      _ ≤ ε * «expr‖ ‖» (y - x) + «expr‖ ‖» (f' x - f' z) * «expr‖ ‖» (y - x) :=\n        by\n        refine' add_le_add (hδ _) (continuous_linear_map.le_op_norm _ _)\n        rw [inter_comm]\n        exact inter_subset_inter_right _ (ball_subset_ball hn.le) hy\n      _ ≤ r (f' z) * «expr‖ ‖» (y - x) := by\n        rw [← add_mul, add_comm]\n        exact mul_le_mul_of_nonneg_right hε (norm_nonneg _)\n      \n  -- the sets `M n z` are relatively closed in `s`, as all the conditions defining it are clearly\n  -- closed\n  have closure_M_subset : ∀ n z, s ∩ closure (M n z) ⊆ M n z :=\n    by\n    rintro n z x ⟨xs, hx⟩\n    refine' ⟨xs, fun y hy => _⟩\n    obtain ⟨a, aM, a_lim⟩ : ∃ a : ℕ → E, (∀ k, a k ∈ M n z) ∧ tendsto a at_top ((nhds) x) :=\n      mem_closure_iff_seq_limit.1 hx\n    have L1 :\n      tendsto (fun k : ℕ => «expr‖ ‖» (f y - f (a k) - (f' z) (y - a k))) at_top\n        ((nhds) («expr‖ ‖» (f y - f x - (f' z) (y - x)))) :=\n      by\n      apply tendsto.norm\n      have L : tendsto (fun k => f (a k)) at_top ((nhds) (f x)) :=\n        by\n        apply (hf' x xs).continuous_within_at.tendsto.comp\n        apply tendsto_nhdsWithin_of_tendsto_nhds_of_eventually_within _ a_lim\n        exact eventually_of_forall fun k => (aM k).1\n      apply tendsto.sub (tendsto_const_nhds.sub L)\n      exact ((f' z).continuous.tendsto _).comp (tendsto_const_nhds.sub a_lim)\n    have L2 :\n      tendsto (fun k : ℕ => (r (f' z) : exprℝ) * «expr‖ ‖» (y - a k)) at_top ((nhds) (r (f' z) * «expr‖ ‖» (y - x))) :=\n      (tendsto_const_nhds.sub a_lim).norm.const_mul _\n    have I :\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" at_top\n        («expr‖ ‖» (f y - f (a k) - (f' z) (y - a k)) ≤ r (f' z) * «expr‖ ‖» (y - a k)) :=\n      by\n      have L : tendsto (fun k => dist y (a k)) at_top ((nhds) (dist y x)) := tendsto_const_nhds.dist a_lim\n      filter_upwards [(tendsto_order.1 L).2 _ hy.2]\n      intro k hk\n      exact (aM k).2 y ⟨hy.1, hk⟩\n    exact le_of_tendsto_of_tendsto L1 L2 I\n  -- choose a dense sequence `d p`\n  rcases TopologicalSpace.exists_dense_seq E with ⟨d, hd⟩\n  -- split `M n z` into subsets `K n z p` of small diameters by intersecting with the ball\n  -- `closed_ball (d p) (u n / 3)`.\n  let K : ℕ → T → ℕ → Set E := fun n z p => closure (M n z) ∩ closed_ball (d p) (u n / 3)\n  -- on the sets `K n z p`, the map `f` is well approximated by `f' z` by design.\n  have K_approx : ∀ (n) (z : T) (p), approximates_linear_on f (f' z) (s ∩ K n z p) (r (f' z)) :=\n    by\n    intro n z p x hx y hy\n    have yM : y ∈ M n z := closure_M_subset _ _ ⟨hy.1, hy.2.1⟩\n    refine' yM.2 _ ⟨hx.1, _⟩\n    calc\n      dist x y ≤ dist x (d p) + dist y (d p) := dist_triangle_right _ _ _\n      _ ≤ u n / 3 + u n / 3 := (add_le_add hx.2.2 hy.2.2)\n      _ < u n := by linarith [u_pos n]\n      \n  -- the sets `K n z p` are also closed, again by design.\n  have K_closed : ∀ (n) (z : T) (p), IsClosed (K n z p) := fun n z p => is_closed_closure.inter is_closed_ball\n  -- reindex the sets `K n z p`, to let them only depend on an integer parameter `q`.\n  obtain ⟨F, hF⟩ : ∃ F : ℕ → ℕ × T × ℕ, function.surjective F :=\n    by\n    haveI : Encodable T := T_count.to_encodable\n    have : Nonempty T := by\n      rcases eq_empty_or_nonempty T with (rfl | hT)\n      · rcases hs with ⟨x, xs⟩\n        rcases s_subset x xs with ⟨n, z, hnz⟩\n        exact false.elim z.2\n      · exact hT.coe_sort\n    inhabit ℕ × T × ℕ\n    exact ⟨_, Encodable.surjective_decode_iget _⟩\n  -- these sets `t q = K n z p` will do\n  refine'\n    ⟨fun q => K (F q).1 (F q).2.1 (F q).2.2, fun q => f' (F q).2.1, fun n => K_closed _ _ _, fun x xs => _, fun q =>\n      K_approx _ _ _, fun h's q => ⟨(F q).2.1, (F q).2.1.1.2, rfl⟩⟩\n  -- the only fact that needs further checking is that they cover `s`.\n  -- we already know that any point `x ∈ s` belongs to a set `M n z`.\n  obtain ⟨n, z, hnz⟩ : ∃ (n : ℕ)(z : T), x ∈ M n z := s_subset x xs\n  -- by density, it also belongs to a ball `closed_ball (d p) (u n / 3)`.\n  obtain ⟨p, hp⟩ : ∃ p : ℕ, x ∈ closed_ball (d p) (u n / 3) :=\n    by\n    have : Set.Nonempty (ball x (u n / 3)) := by\n      simp only [nonempty_ball]\n      linarith [u_pos n]\n    obtain ⟨p, hp⟩ : ∃ p : ℕ, d p ∈ ball x (u n / 3) := hd.exists_mem_open is_open_ball this\n    exact ⟨p, (mem_ball'.1 hp).le⟩\n  -- choose `q` for which `t q = K n z p`.\n  obtain ⟨q, hq⟩ : ∃ q, F q = (n, z, p) := hF _\n  -- then `x` belongs to `t q`.\n  apply mem_Union.2 ⟨q, _⟩\n  simp only [hq, subset_closure hnz, hp, mem_inter_iff, and_self_iff]\n#align exists_closed_cover_approximates_linear_on_of_has_fderiv_within_at exists_closed_cover_approximates_linear_on_of_has_fderiv_within_at\n\n",
 "ae_measurable_to_nnreal_abs_det_fderiv_within":
 "theorem ae_measurable_to_nnreal_abs_det_fderiv_within (hs : MeasurableSet s)\n    (hf' : ∀ x ∈ s, has_fderiv_within_at f (f' x) s x) :\n    AEMeasurable (fun x => |(f' x).det|.to_nnreal) (μ.restrict s) :=\n  by\n  apply measurable_real_to_nnreal.comp_ae_measurable\n  refine' continuous_abs.measurable.comp_ae_measurable _\n  refine' continuous_linear_map.continuous_det.measurable.comp_ae_measurable _\n  exact ae_measurable_fderiv_within μ hs hf'\n#align ae_measurable_to_nnreal_abs_det_fderiv_within ae_measurable_to_nnreal_abs_det_fderiv_within\n\n",
 "ae_measurable_of_real_abs_det_fderiv_within":
 "theorem ae_measurable_of_real_abs_det_fderiv_within (hs : MeasurableSet s)\n    (hf' : ∀ x ∈ s, has_fderiv_within_at f (f' x) s x) :\n    AEMeasurable (fun x => ENNReal.ofReal (|(f' x).det|)) (μ.restrict s) :=\n  by\n  apply ennreal.measurable_of_real.comp_ae_measurable\n  refine' continuous_abs.measurable.comp_ae_measurable _\n  refine' continuous_linear_map.continuous_det.measurable.comp_ae_measurable _\n  exact ae_measurable_fderiv_within μ hs hf'\n#align ae_measurable_of_real_abs_det_fderiv_within ae_measurable_of_real_abs_det_fderiv_within\n\n",
 "ae_measurable_fderiv_within":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr on » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\n/-- The derivative of a function on a measurable set is almost everywhere measurable on this set\nwith respect to Lebesgue measure. Note that, in general, it is not genuinely measurable there,\nas `f'` is not unique (but only on a set of measure `0`, as the argument shows). -/\ntheorem ae_measurable_fderiv_within (hs : MeasurableSet s) (hf' : ∀ x ∈ s, has_fderiv_within_at f (f' x) s x) :\n    AEMeasurable f' (μ.restrict s) :=\n  by\n  /- It suffices to show that `f'` can be uniformly approximated by a measurable function.\n    Fix `ε > 0`. Thanks to `exists_partition_approximates_linear_on_of_has_fderiv_within_at`, one\n    can find a countable measurable partition of `s` into sets `s ∩ t n` on which `f` is well\n    approximated by linear maps `A n`. On almost all of `s ∩ t n`, it follows from\n    `approximates_linear_on.norm_fderiv_sub_le` that `f'` is uniformly approximated by `A n`, which\n    gives the conclusion. -/\n  -- fix a precision `ε`\n  refine' ae_measurable_of_unif_approx fun ε εpos => _\n  let δ : nnreal := ⟨ε, le_of_lt εpos⟩\n  have δpos : 0 < δ := εpos\n  -- partition `s` into sets `s ∩ t n` on which `f` is approximated by linear maps `A n`.\n  obtain ⟨t, A, t_disj, t_meas, t_cover, ht, Af'⟩ :\n    ∃ (t : ℕ → Set E)(A : ℕ → «expr →L[ ] » E (exprℝ) E),\n      Pairwise («expr on » Disjoint t) ∧\n        (∀ n : ℕ, MeasurableSet (t n)) ∧\n          s ⊆ «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (t n) ∧\n            (∀ n : ℕ, approximates_linear_on f (A n) (s ∩ t n) δ) ∧ (s.nonempty → ∀ n, ∃ y ∈ s, A n = f' y) :=\n    exists_partition_approximates_linear_on_of_has_fderiv_within_at f s f' hf' (fun A => δ) fun A => δpos.ne'\n  -- define a measurable function `g` which coincides with `A n` on `t n`.\n  obtain ⟨g, g_meas, hg⟩ : ∃ g : E → «expr →L[ ] » E (exprℝ) E, Measurable g ∧ ∀ (n : ℕ) (x : E), x ∈ t n → g x = A n :=\n    exists_measurable_piecewise_nat t t_meas t_disj (fun n x => A n) fun n => measurable_const\n  refine' ⟨g, g_meas.ae_measurable, _⟩\n  -- reduce to checking that `f'` and `g` are close on almost all of `s ∩ t n`, for all `n`.\n  suffices H :\n    «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\"\n      (Sum fun n => μ.restrict (s ∩ t n)) (dist (g x) (f' x) ≤ ε)\n  · have : μ.restrict s ≤ Sum fun n => μ.restrict (s ∩ t n) :=\n      by\n      have :\n        s = «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (s ∩ t n) :=\n        by\n        rw [← inter_Union]\n        exact subset.antisymm (subset_inter subset.rfl t_cover) (inter_subset_left _ _)\n      conv_lhs => rw [this]\n      exact restrict_Union_le\n    exact ae_mono this H\n  -- fix such an `n`.\n  refine' ae_sum_iff.2 fun n => _\n  -- on almost all `s ∩ t n`, `f' x` is close to `A n` thanks to\n  -- `approximates_linear_on.norm_fderiv_sub_le`.\n  have E₁ :\n    «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\"\n      (μ.restrict (s ∩ t n)) («expr‖ ‖₊» (f' x - A n) ≤ δ) :=\n    (ht n).norm_fderiv_sub_le μ (hs.inter (t_meas n)) f' fun x hx => (hf' x hx.1).mono (inter_subset_left _ _)\n  -- moreover, `g x` is equal to `A n` there.\n  have E₂ :\n    «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\"\n      (μ.restrict (s ∩ t n)) (g x = A n) :=\n    by\n    suffices H :\n      «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\"\n        (μ.restrict (t n)) (g x = A n)\n    exact ae_mono (restrict_mono (inter_subset_right _ _) le_rfl) H\n    filter_upwards [ae_restrict_mem (t_meas n)]\n    exact hg n\n  -- putting these two properties together gives the conclusion.\n  filter_upwards [E₁, E₂]with x hx1 hx2\n  rw [← nndist_eq_nnnorm] at hx1\n  rw [hx2, dist_comm]\n  exact hx1\n#align ae_measurable_fderiv_within ae_measurable_fderiv_within\n\n",
 "add_haar_image_le_mul_of_det_lt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.gt -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.gt -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.gt -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.gt -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.gt -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.gt -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.gt -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/-- Let `f` be a function which is sufficiently close (in the Lipschitz sense) to a given linear\nmap `A`. Then it expands the volume of any set by at most `m` for any `m > det A`. -/\ntheorem add_haar_image_le_mul_of_det_lt (A : «expr →L[ ] » E (exprℝ) E) {m : nnreal}\n    (hm : ENNReal.ofReal (|A.det|) < m) :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\"\n      (nhds_within.gt (0 : nnreal))\n      (∀ (s : Set E) (f : E → E) (hf : approximates_linear_on f A s δ), μ («expr '' » f s) ≤ m * μ s) :=\n  by\n  apply nhdsWithin_le_nhds\n  let d := ENNReal.ofReal (|A.det|)\n  -- construct a small neighborhood of `A '' (closed_ball 0 1)` with measure comparable to\n  -- the determinant of `A`.\n  obtain ⟨ε, hε, εpos⟩ :\n    ∃ ε : exprℝ, μ (closed_ball 0 ε + «expr '' » A (closed_ball 0 1)) < m * μ (closed_ball 0 1) ∧ 0 < ε :=\n    by\n    have HC : IsCompact («expr '' » A (closed_ball 0 1)) := (proper_space.is_compact_closed_ball _ _).image A.continuous\n    have L0 :\n      tendsto (fun ε => μ (cthickening ε («expr '' » A (closed_ball 0 1)))) (nhds_within.gt 0)\n        ((nhds) (μ («expr '' » A (closed_ball 0 1)))) :=\n      by\n      apply tendsto.mono_left _ nhdsWithin_le_nhds\n      exact tendsto_measure_cthickening_of_is_compact HC\n    have L1 :\n      tendsto (fun ε => μ (closed_ball 0 ε + «expr '' » A (closed_ball 0 1))) (nhds_within.gt 0)\n        ((nhds) (μ («expr '' » A (closed_ball 0 1)))) :=\n      by\n      apply L0.congr' _\n      filter_upwards [self_mem_nhdsWithin]with r hr\n      rw [← HC.add_closed_ball_zero (le_of_lt hr), add_comm]\n    have L2 :\n      tendsto (fun ε => μ (closed_ball 0 ε + «expr '' » A (closed_ball 0 1))) (nhds_within.gt 0)\n        ((nhds) (d * μ (closed_ball 0 1))) :=\n      by\n      convert L1\n      exact (add_haar_image_continuous_linear_map _ _ _).symm\n    have I : d * μ (closed_ball 0 1) < m * μ (closed_ball 0 1) :=\n      (ENNReal.mul_lt_mul_right (measure_closed_ball_pos μ _ zero_lt_one).ne' measure_closed_ball_lt_top.ne).2 hm\n    have H :\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\"\n        (nhds_within.gt 0) (μ (closed_ball 0 b + «expr '' » A (closed_ball 0 1)) < m * μ (closed_ball 0 1)) :=\n      (tendsto_order.1 L2).2 _ I\n    exact (H.and self_mem_nhdsWithin).exists\n  have : Iio (⟨ε, εpos.le⟩ : nnreal) ∈ (nhds) (0 : nnreal) :=\n    by\n    apply Iio_mem_nhds\n    exact εpos\n  filter_upwards [this]\n  -- fix a function `f` which is close enough to `A`.\n  intro δ hδ s f hf\n  -- This function expands the volume of any ball by at most `m`\n  have I : ∀ x r, x ∈ s → 0 ≤ r → μ («expr '' » f (s ∩ closed_ball x r)) ≤ m * μ (closed_ball x r) :=\n    by\n    intro x r xs r0\n    have K : «expr '' » f (s ∩ closed_ball x r) ⊆ «expr '' » A (closed_ball 0 r) + closed_ball (f x) (ε * r) :=\n      by\n      rintro y ⟨z, ⟨zs, zr⟩, rfl⟩\n      apply Set.mem_add.2 ⟨A (z - x), f z - f x - A (z - x) + f x, _, _, _⟩\n      · apply mem_image_of_mem\n        simpa only [dist_eq_norm, mem_closed_ball, mem_closedBall_zero_iff] using zr\n      · rw [mem_closedBall_iff_norm, add_sub_cancel]\n        calc\n          «expr‖ ‖» (f z - f x - A (z - x)) ≤ δ * «expr‖ ‖» (z - x) := hf _ zs _ xs\n          _ ≤ ε * r := mul_le_mul (le_of_lt hδ) (mem_closedBall_iff_norm.1 zr) (norm_nonneg _) εpos.le\n          \n      · simp only [map_sub, Pi.sub_apply]\n        abel\n    have :\n      «expr '' » A (closed_ball 0 r) + closed_ball (f x) (ε * r) =\n        {f x} + «expr • » r («expr '' » A (closed_ball 0 1) + closed_ball 0 ε) :=\n      by\n      rw [smul_add, ← add_assoc, add_comm {f x}, add_assoc, smul_closedBall _ _ εpos.le, smul_zero,\n        singleton_add_closedBall_zero, ← image_smul_set (exprℝ) E E A, smul_closedBall _ _ zero_le_one, smul_zero,\n        Real.norm_eq_abs, abs_of_nonneg r0, mul_one, mul_comm]\n    rw [this] at K\n    calc\n      μ («expr '' » f (s ∩ closed_ball x r)) ≤\n          μ ({f x} + «expr • » r («expr '' » A (closed_ball 0 1) + closed_ball 0 ε)) :=\n        measure_mono K\n      _ = ENNReal.ofReal (r ^ finrank (exprℝ) E) * μ («expr '' » A (closed_ball 0 1) + closed_ball 0 ε) := by\n        simp only [abs_of_nonneg r0, add_haar_smul, image_add_left, abs_pow, singleton_add, measure_preimage_add]\n      _ ≤ ENNReal.ofReal (r ^ finrank (exprℝ) E) * (m * μ (closed_ball 0 1)) :=\n        by\n        rw [add_comm]\n        exact mul_le_mul_left' hε.le _\n      _ = m * μ (closed_ball x r) := by\n        simp only [add_haar_closed_ball' _ _ r0]\n        ring\n      \n  -- covering `s` by closed balls with total measure very close to `μ s`, one deduces that the\n  -- measure of `f '' s` is at most `m * (μ s + a)` for any positive `a`.\n  have J :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\"\n      (nhds_within.gt (0 : ennreal)) (μ («expr '' » f s) ≤ m * (μ s + a)) :=\n    by\n    filter_upwards [self_mem_nhdsWithin]with a ha\n    change 0 < a at ha\n    obtain ⟨t, r, t_count, ts, rpos, st, μt⟩ :\n      ∃ (t : Set E)(r : E → exprℝ),\n        t.countable ∧\n          t ⊆ s ∧\n            (∀ x : E, x ∈ t → 0 < r x) ∧\n              s ⊆\n                  «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n                    (closed_ball x (r x)) ∧\n                «expr∑' , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , »\"\n                    (μ (closed_ball (↑x) (r ↑x))) ≤\n                  μ s + a :=\n      besicovitch.exists_closed_ball_covering_tsum_measure_le μ ha.ne' (fun x => Ioi 0) s fun x xs δ δpos =>\n        ⟨δ / 2, by simp [half_pos δpos, half_lt_self δpos]⟩\n    haveI : Encodable t := t_count.to_encodable\n    calc\n      μ («expr '' » f s) ≤\n          μ\n            («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n              («expr '' » f (s ∩ closed_ball x (r x)))) :=\n        by\n        rw [bUnion_eq_Union] at st\n        apply measure_mono\n        rw [← image_Union, ← inter_Union]\n        exact image_subset _ (subset_inter (subset.refl _) st)\n      _ ≤\n          «expr∑' , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , »\"\n            (μ («expr '' » f (s ∩ closed_ball x (r x)))) :=\n        (measure_Union_le _)\n      _ ≤\n          «expr∑' , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , »\"\n            (m * μ (closed_ball x (r x))) :=\n        (ENNReal.tsum_le_tsum fun x => I x (r x) (ts x.2) (rpos x x.2).le)\n      _ ≤ m * (μ s + a) := by\n        rw [ENNReal.tsum_mul_left]\n        exact mul_le_mul_left' μt _\n      \n  -- taking the limit in `a`, one obtains the conclusion\n  have L : tendsto (fun a => (m : ennreal) * (μ s + a)) (nhds_within.gt 0) ((nhds) (m * (μ s + 0))) :=\n    by\n    apply tendsto.mono_left _ nhdsWithin_le_nhds\n    apply ENNReal.Tendsto.const_mul (tendsto_const_nhds.add tendsto_id)\n    simp only [ENNReal.coe_ne_top, ne.def, or_true_iff, not_false_iff]\n  rw [add_zero] at L\n  exact ge_of_tendsto L J\n#align add_haar_image_le_mul_of_det_lt add_haar_image_le_mul_of_det_lt\n\n",
 "add_haar_image_le_lintegral_abs_det_fderiv_aux2":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫⁻ in , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ in , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.gt -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫⁻ in , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ in , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫⁻ in , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ in , ∂ » -/\ntheorem add_haar_image_le_lintegral_abs_det_fderiv_aux2 (hs : MeasurableSet s) (h's : μ s ≠ ennreal.top)\n    (hf' : ∀ x ∈ s, has_fderiv_within_at f (f' x) s x) :\n    μ («expr '' » f s) ≤\n      «expr∫⁻ in , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ in , ∂ »\" s\n        (ENNReal.ofReal (|(f' x).det|)) μ :=\n  by\n  -- We just need to let the error tend to `0` in the previous lemma.\n  have :\n    tendsto\n      (fun ε : nnreal =>\n        «expr∫⁻ in , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ in , ∂ »\" s\n            (ENNReal.ofReal (|(f' x).det|)) μ +\n          2 * ε * μ s)\n      (nhds_within.gt 0)\n      ((nhds)\n        («expr∫⁻ in , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ in , ∂ »\" s\n            (ENNReal.ofReal (|(f' x).det|)) μ +\n          2 * (0 : nnreal) * μ s)) :=\n    by\n    apply tendsto.mono_left _ nhdsWithin_le_nhds\n    refine' tendsto_const_nhds.add _\n    refine' ENNReal.Tendsto.mul_const _ (or.inr h's)\n    exact ENNReal.Tendsto.const_mul (ENNReal.tendsto_coe.2 tendsto_id) (or.inr ENNReal.coe_ne_top)\n  simp only [add_zero, MulZeroClass.zero_mul, MulZeroClass.mul_zero, ENNReal.coe_zero] at this\n  apply ge_of_tendsto this\n  filter_upwards [self_mem_nhdsWithin]\n  rintro ε (εpos : 0 < ε)\n  exact add_haar_image_le_lintegral_abs_det_fderiv_aux1 μ hs hf' εpos\n#align add_haar_image_le_lintegral_abs_det_fderiv_aux2 add_haar_image_le_lintegral_abs_det_fderiv_aux2\n\n",
 "add_haar_image_le_lintegral_abs_det_fderiv_aux1":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr on » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫⁻ in , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ in , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫⁻ in , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ in , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫⁻ in , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ in , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫⁻ in , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ in , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫⁻ in , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ in , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫⁻ in , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ in , ∂ » -/\ntheorem add_haar_image_le_lintegral_abs_det_fderiv_aux1 (hs : MeasurableSet s)\n    (hf' : ∀ x ∈ s, has_fderiv_within_at f (f' x) s x) {ε : nnreal} (εpos : 0 < ε) :\n    μ («expr '' » f s) ≤\n      «expr∫⁻ in , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ in , ∂ »\" s\n          (ENNReal.ofReal (|(f' x).det|)) μ +\n        2 * ε * μ s :=\n  by\n  /- To bound `μ (f '' s)`, we cover `s` by sets where `f` is well-approximated by linear maps\n    `A n` (and where `f'` is almost everywhere close to `A n`), and then use that `f` expands the\n    measure of such a set by at most `(A n).det + ε`. -/\n  have :\n    ∀ A : «expr →L[ ] » E (exprℝ) E,\n      ∃ δ : nnreal,\n        0 < δ ∧\n          (∀ B : «expr →L[ ] » E (exprℝ) E, «expr‖ ‖» (B - A) ≤ δ → |B.det - A.det| ≤ ε) ∧\n            ∀ (t : Set E) (g : E → E) (hf : approximates_linear_on g A t δ),\n              μ («expr '' » g t) ≤ (ENNReal.ofReal (|A.det|) + ε) * μ t :=\n    by\n    intro A\n    let m : nnreal := Real.toNNReal (|A.det|) + ε\n    have I : ENNReal.ofReal (|A.det|) < m := by\n      simp only [ENNReal.ofReal, m, lt_add_iff_pos_right, εpos, ENNReal.coe_lt_coe]\n    rcases((add_haar_image_le_mul_of_det_lt μ A I).and self_mem_nhdsWithin).exists with ⟨δ, h, δpos⟩\n    obtain ⟨δ', δ'pos, hδ'⟩ : ∃ (δ' : exprℝ)(H : 0 < δ'), ∀ B, dist B A < δ' → dist B.det A.det < ↑ε :=\n      continuous_at_iff.1 continuous_linear_map.continuous_det.continuous_at ε εpos\n    let δ'' : nnreal := ⟨δ' / 2, (half_pos δ'pos).le⟩\n    refine' ⟨min δ δ'', lt_min δpos (half_pos δ'pos), _, _⟩\n    · intro B hB\n      rw [← Real.dist_eq]\n      apply (hδ' B _).le\n      rw [dist_eq_norm]\n      calc\n        «expr‖ ‖» (B - A) ≤ (min δ δ'' : nnreal) := hB\n        _ ≤ δ'' := by simp only [le_refl, NNReal.coe_min, min_le_iff, or_true_iff]\n        _ < δ' := half_lt_self δ'pos\n        \n    · intro t g htg\n      exact h t g (htg.mono_num (min_le_left _ _))\n  choose δ hδ using this\n  obtain ⟨t, A, t_disj, t_meas, t_cover, ht, -⟩ :\n    ∃ (t : ℕ → Set E)(A : ℕ → «expr →L[ ] » E (exprℝ) E),\n      Pairwise («expr on » Disjoint t) ∧\n        (∀ n : ℕ, MeasurableSet (t n)) ∧\n          s ⊆ «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (t n) ∧\n            (∀ n : ℕ, approximates_linear_on f (A n) (s ∩ t n) (δ (A n))) ∧ (s.nonempty → ∀ n, ∃ y ∈ s, A n = f' y) :=\n    exists_partition_approximates_linear_on_of_has_fderiv_within_at f s f' hf' δ fun A => (hδ A).1.ne'\n  calc\n    μ («expr '' » f s) ≤\n        μ\n          («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n            («expr '' » f (s ∩ t n))) :=\n      by\n      apply measure_mono\n      rw [← image_Union, ← inter_Union]\n      exact image_subset f (subset_inter subset.rfl t_cover)\n    _ ≤\n        «expr∑' , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , »\"\n          (μ («expr '' » f (s ∩ t n))) :=\n      (measure_Union_le _)\n    _ ≤\n        «expr∑' , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , »\"\n          ((ENNReal.ofReal (|(A n).det|) + ε) * μ (s ∩ t n)) :=\n      by\n      apply ENNReal.tsum_le_tsum fun n => _\n      apply (hδ (A n)).2.2\n      exact ht n\n    _ =\n        «expr∑' , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , »\"\n          («expr∫⁻ in , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ in , ∂ »\"\n            (s ∩ t n) (ENNReal.ofReal (|(A n).det|) + ε) μ) :=\n      by simp only [lintegral_const, MeasurableSet.univ, measure.restrict_apply, univ_inter]\n    _ ≤\n        «expr∑' , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , »\"\n          («expr∫⁻ in , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ in , ∂ »\"\n            (s ∩ t n) (ENNReal.ofReal (|(f' x).det|) + 2 * ε) μ) :=\n      by\n      apply ENNReal.tsum_le_tsum fun n => _\n      apply lintegral_mono_ae\n      filter_upwards [(ht n).norm_fderiv_sub_le μ (hs.inter (t_meas n)) f' fun x hx =>\n          (hf' x hx.1).mono (inter_subset_left _ _)]\n      intro x hx\n      have I : |(A n).det| ≤ |(f' x).det| + ε :=\n        calc\n          |(A n).det| = |(f' x).det - ((f' x).det - (A n).det)| :=\n            by\n            congr 1\n            abel\n          _ ≤ |(f' x).det| + |(f' x).det - (A n).det| := (abs_sub _ _)\n          _ ≤ |(f' x).det| + ε := add_le_add le_rfl ((hδ (A n)).2.1 _ hx)\n          \n      calc\n        ENNReal.ofReal (|(A n).det|) + ε ≤ ENNReal.ofReal (|(f' x).det| + ε) + ε :=\n          add_le_add (ENNReal.ofReal_le_ofReal I) le_rfl\n        _ = ENNReal.ofReal (|(f' x).det|) + 2 * ε := by\n          simp only [ENNReal.ofReal_add, abs_nonneg, two_mul, add_assoc, NNReal.zero_le_coe, ENNReal.ofReal_coe_nnreal]\n        \n    _ =\n        «expr∫⁻ in , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ in , ∂ »\"\n          («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (s ∩ t n))\n          (ENNReal.ofReal (|(f' x).det|) + 2 * ε) μ :=\n      by\n      have M : ∀ n : ℕ, MeasurableSet (s ∩ t n) := fun n => hs.inter (t_meas n)\n      rw [lintegral_Union M]\n      exact pairwise_disjoint_mono t_disj fun n => inter_subset_right _ _\n    _ =\n        «expr∫⁻ in , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ in , ∂ »\" s\n          (ENNReal.ofReal (|(f' x).det|) + 2 * ε) μ :=\n      by\n      have :\n        s = «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (s ∩ t n) :=\n        by\n        rw [← inter_Union]\n        exact subset.antisymm (subset_inter subset.rfl t_cover) (inter_subset_left _ _)\n      rw [← this]\n    _ =\n        «expr∫⁻ in , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ in , ∂ »\" s\n            (ENNReal.ofReal (|(f' x).det|)) μ +\n          2 * ε * μ s :=\n      by simp only [lintegral_add_right' _ aemeasurable_const, set_lintegral_const]\n    \n#align add_haar_image_le_lintegral_abs_det_fderiv_aux1 add_haar_image_le_lintegral_abs_det_fderiv_aux1\n\n",
 "add_haar_image_le_lintegral_abs_det_fderiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫⁻ in , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ in , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫⁻ in , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ in , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫⁻ in , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ in , ∂ » -/\ntheorem add_haar_image_le_lintegral_abs_det_fderiv (hs : MeasurableSet s)\n    (hf' : ∀ x ∈ s, has_fderiv_within_at f (f' x) s x) :\n    μ («expr '' » f s) ≤\n      «expr∫⁻ in , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ in , ∂ »\" s\n        (ENNReal.ofReal (|(f' x).det|)) μ :=\n  by\n  /- We already know the result for finite-measure sets. We cover `s` by finite-measure sets using\n    `spanning_sets μ`, and apply the previous result to each of these parts. -/\n  let u n := disjointed (spanning_sets μ) n\n  have u_meas : ∀ n, MeasurableSet (u n) := by\n    intro n\n    apply MeasurableSet.disjointed fun i => _\n    exact measurable_spanning_sets μ i\n  have A :\n    s = «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (s ∩ u n) := by\n    rw [← inter_Union, unionᵢ_disjointed, Union_spanning_sets, inter_univ]\n  calc\n    μ («expr '' » f s) ≤\n        «expr∑' , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , »\"\n          (μ («expr '' » f (s ∩ u n))) :=\n      by\n      conv_lhs => rw [A, image_Union]\n      exact measure_Union_le _\n    _ ≤\n        «expr∑' , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , »\"\n          («expr∫⁻ in , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ in , ∂ »\"\n            (s ∩ u n) (ENNReal.ofReal (|(f' x).det|)) μ) :=\n      by\n      apply ENNReal.tsum_le_tsum fun n => _\n      apply\n        add_haar_image_le_lintegral_abs_det_fderiv_aux2 μ (hs.inter (u_meas n)) _ fun x hx =>\n          (hf' x hx.1).mono (inter_subset_left _ _)\n      have : μ (u n) < ennreal.top :=\n        lt_of_le_of_lt (measure_mono (disjointed_subset _ _)) (measure_spanning_sets_lt_top μ n)\n      exact ne_of_lt (lt_of_le_of_lt (measure_mono (inter_subset_right _ _)) this)\n    _ =\n        «expr∫⁻ in , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ in , ∂ »\" s\n          (ENNReal.ofReal (|(f' x).det|)) μ :=\n      by\n      conv_rhs => rw [A]\n      rw [lintegral_Union]\n      · intro n\n        exact hs.inter (u_meas n)\n      · exact pairwise_disjoint_mono (disjoint_disjointed _) fun n => inter_subset_right _ _\n    \n#align add_haar_image_le_lintegral_abs_det_fderiv add_haar_image_le_lintegral_abs_det_fderiv\n\n",
 "add_haar_image_eq_zero_of_differentiable_on_of_add_haar_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr on » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/-- A differentiable function maps sets of measure zero to sets of measure zero. -/\ntheorem add_haar_image_eq_zero_of_differentiable_on_of_add_haar_eq_zero (hf : differentiable_on (exprℝ) f s)\n    (hs : μ s = 0) : μ («expr '' » f s) = 0 :=\n  by\n  refine' le_antisymm _ (zero_le _)\n  have :\n    ∀ A : «expr →L[ ] » E (exprℝ) E,\n      ∃ δ : nnreal,\n        0 < δ ∧\n          ∀ (t : Set E) (hf : approximates_linear_on f A t δ),\n            μ («expr '' » f t) ≤ (Real.toNNReal (|A.det|) + 1 : nnreal) * μ t :=\n    by\n    intro A\n    let m : nnreal := Real.toNNReal (|A.det|) + 1\n    have I : ENNReal.ofReal (|A.det|) < m := by\n      simp only [ENNReal.ofReal, m, lt_add_iff_pos_right, zero_lt_one, ENNReal.coe_lt_coe]\n    rcases((add_haar_image_le_mul_of_det_lt μ A I).and self_mem_nhdsWithin).exists with ⟨δ, h, h'⟩\n    exact ⟨δ, h', fun t ht => h t f ht⟩\n  choose δ hδ using this\n  obtain ⟨t, A, t_disj, t_meas, t_cover, ht, -⟩ :\n    ∃ (t : ℕ → Set E)(A : ℕ → «expr →L[ ] » E (exprℝ) E),\n      Pairwise («expr on » Disjoint t) ∧\n        (∀ n : ℕ, MeasurableSet (t n)) ∧\n          s ⊆ «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (t n) ∧\n            (∀ n : ℕ, approximates_linear_on f (A n) (s ∩ t n) (δ (A n))) ∧\n              (s.nonempty → ∀ n, ∃ y ∈ s, A n = fderiv_within (exprℝ) f s y) :=\n    exists_partition_approximates_linear_on_of_has_fderiv_within_at f s (fderiv_within (exprℝ) f s)\n      (fun x xs => (hf x xs).has_fderiv_within_at) δ fun A => (hδ A).1.ne'\n  calc\n    μ («expr '' » f s) ≤\n        μ\n          («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n            («expr '' » f (s ∩ t n))) :=\n      by\n      apply measure_mono\n      rw [← image_Union, ← inter_Union]\n      exact image_subset f (subset_inter subset.rfl t_cover)\n    _ ≤\n        «expr∑' , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , »\"\n          (μ («expr '' » f (s ∩ t n))) :=\n      (measure_Union_le _)\n    _ ≤\n        «expr∑' , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , »\"\n          ((Real.toNNReal (|(A n).det|) + 1 : nnreal) * μ (s ∩ t n)) :=\n      by\n      apply ENNReal.tsum_le_tsum fun n => _\n      apply (hδ (A n)).2\n      exact ht n\n    _ ≤\n        «expr∑' , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , »\"\n          ((Real.toNNReal (|(A n).det|) + 1 : nnreal) * 0) :=\n      by\n      refine' ENNReal.tsum_le_tsum fun n => mul_le_mul_left' _ _\n      exact le_trans (measure_mono (inter_subset_left _ _)) (le_of_eq hs)\n    _ = 0 := by simp only [tsum_zero, MulZeroClass.mul_zero]\n    \n#align add_haar_image_eq_zero_of_differentiable_on_of_add_haar_eq_zero add_haar_image_eq_zero_of_differentiable_on_of_add_haar_eq_zero\n\n",
 "add_haar_image_eq_zero_of_det_fderiv_within_eq_zero_aux":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr on » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/-- A version of Sard lemma in fixed dimension: given a differentiable function from `E` to `E` and\na set where the differential is not invertible, then the image of this set has zero measure.\nHere, we give an auxiliary statement towards this result. -/\ntheorem add_haar_image_eq_zero_of_det_fderiv_within_eq_zero_aux (hf' : ∀ x ∈ s, has_fderiv_within_at f (f' x) s x)\n    (R : exprℝ) (hs : s ⊆ closedBall 0 R) (ε : nnreal) (εpos : 0 < ε) (h'f' : ∀ x ∈ s, (f' x).det = 0) :\n    μ («expr '' » f s) ≤ ε * μ (closedBall 0 R) :=\n  by\n  rcases eq_empty_or_nonempty s with (rfl | h's)\n  · simp only [measure_empty, zero_le, image_empty]\n  have :\n    ∀ A : «expr →L[ ] » E (exprℝ) E,\n      ∃ δ : nnreal,\n        0 < δ ∧\n          ∀ (t : Set E) (hf : approximates_linear_on f A t δ),\n            μ («expr '' » f t) ≤ (Real.toNNReal (|A.det|) + ε : nnreal) * μ t :=\n    by\n    intro A\n    let m : nnreal := Real.toNNReal (|A.det|) + ε\n    have I : ENNReal.ofReal (|A.det|) < m := by\n      simp only [ENNReal.ofReal, m, lt_add_iff_pos_right, εpos, ENNReal.coe_lt_coe]\n    rcases((add_haar_image_le_mul_of_det_lt μ A I).and self_mem_nhdsWithin).exists with ⟨δ, h, h'⟩\n    exact ⟨δ, h', fun t ht => h t f ht⟩\n  choose δ hδ using this\n  obtain ⟨t, A, t_disj, t_meas, t_cover, ht, Af'⟩ :\n    ∃ (t : ℕ → Set E)(A : ℕ → «expr →L[ ] » E (exprℝ) E),\n      Pairwise («expr on » Disjoint t) ∧\n        (∀ n : ℕ, MeasurableSet (t n)) ∧\n          s ⊆ «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (t n) ∧\n            (∀ n : ℕ, approximates_linear_on f (A n) (s ∩ t n) (δ (A n))) ∧ (s.nonempty → ∀ n, ∃ y ∈ s, A n = f' y) :=\n    exists_partition_approximates_linear_on_of_has_fderiv_within_at f s f' hf' δ fun A => (hδ A).1.ne'\n  calc\n    μ («expr '' » f s) ≤\n        μ\n          («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n            («expr '' » f (s ∩ t n))) :=\n      by\n      apply measure_mono\n      rw [← image_Union, ← inter_Union]\n      exact image_subset f (subset_inter subset.rfl t_cover)\n    _ ≤\n        «expr∑' , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , »\"\n          (μ («expr '' » f (s ∩ t n))) :=\n      (measure_Union_le _)\n    _ ≤\n        «expr∑' , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , »\"\n          ((Real.toNNReal (|(A n).det|) + ε : nnreal) * μ (s ∩ t n)) :=\n      by\n      apply ENNReal.tsum_le_tsum fun n => _\n      apply (hδ (A n)).2\n      exact ht n\n    _ =\n        «expr∑' , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , »\"\n          (ε * μ (s ∩ t n)) :=\n      by\n      congr with n\n      rcases Af' h's n with ⟨y, ys, hy⟩\n      simp only [hy, h'f' y ys, Real.toNNReal_zero, abs_zero, zero_add]\n    _ ≤\n        ε *\n          «expr∑' , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , »\"\n            (μ (closed_ball 0 R ∩ t n)) :=\n      by\n      rw [ENNReal.tsum_mul_left]\n      refine' mul_le_mul_left' (ENNReal.tsum_le_tsum fun n => measure_mono _) _\n      exact inter_subset_inter_left _ hs\n    _ =\n        ε *\n          μ\n            («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n              (closed_ball 0 R ∩ t n)) :=\n      by\n      rw [measure_Union]\n      · exact pairwise_disjoint_mono t_disj fun n => inter_subset_right _ _\n      · intro n\n        exact measurable_set_closed_ball.inter (t_meas n)\n    _ ≤ ε * μ (closed_ball 0 R) := by\n      rw [← inter_Union]\n      exact mul_le_mul_left' (measure_mono (inter_subset_left _ _)) _\n    \n#align add_haar_image_eq_zero_of_det_fderiv_within_eq_zero_aux add_haar_image_eq_zero_of_det_fderiv_within_eq_zero_aux\n\n",
 "add_haar_image_eq_zero_of_det_fderiv_within_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.gt -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/-- A version of Sard lemma in fixed dimension: given a differentiable function from `E` to `E` and\na set where the differential is not invertible, then the image of this set has zero measure. -/\ntheorem add_haar_image_eq_zero_of_det_fderiv_within_eq_zero (hf' : ∀ x ∈ s, has_fderiv_within_at f (f' x) s x)\n    (h'f' : ∀ x ∈ s, (f' x).det = 0) : μ («expr '' » f s) = 0 :=\n  by\n  suffices H : ∀ R, μ («expr '' » f (s ∩ closed_ball 0 R)) = 0\n  · apply le_antisymm _ (zero_le _)\n    rw [← Union_inter_closed_ball_nat s 0]\n    calc\n      μ\n            («expr '' » f\n              («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n                (s ∩ closed_ball 0 n))) ≤\n          «expr∑' , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , »\"\n            (μ («expr '' » f (s ∩ closed_ball 0 n))) :=\n        by\n        rw [image_Union]\n        exact measure_Union_le _\n      _ ≤ 0 := by simp only [H, tsum_zero, nonpos_iff_eq_zero]\n      \n  intro R\n  have A : ∀ (ε : nnreal) (εpos : 0 < ε), μ («expr '' » f (s ∩ closed_ball 0 R)) ≤ ε * μ (closed_ball 0 R) :=\n    fun ε εpos =>\n    add_haar_image_eq_zero_of_det_fderiv_within_eq_zero_aux μ (fun x hx => (hf' x hx.1).mono (inter_subset_left _ _)) R\n      (inter_subset_right _ _) ε εpos fun x hx => h'f' x hx.1\n  have B : tendsto (fun ε : nnreal => (ε : ennreal) * μ (closed_ball 0 R)) (nhds_within.gt 0) ((nhds) 0) :=\n    by\n    have :\n      tendsto (fun ε : nnreal => (ε : ennreal) * μ (closed_ball 0 R)) ((nhds) 0)\n        ((nhds) (((0 : nnreal) : ennreal) * μ (closed_ball 0 R))) :=\n      ENNReal.Tendsto.mul_const (ENNReal.tendsto_coe.2 tendsto_id) (or.inr measure_closed_ball_lt_top.ne)\n    simp only [MulZeroClass.zero_mul, ENNReal.coe_zero] at this\n    exact tendsto.mono_left this nhdsWithin_le_nhds\n  apply le_antisymm _ (zero_le _)\n  apply ge_of_tendsto B\n  filter_upwards [self_mem_nhdsWithin]\n  exact A\n#align add_haar_image_eq_zero_of_det_fderiv_within_eq_zero add_haar_image_eq_zero_of_det_fderiv_within_eq_zero\n\n"}