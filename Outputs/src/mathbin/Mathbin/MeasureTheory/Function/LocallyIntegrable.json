{"mul_continuous_on_of_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€áµ âˆ‚ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€áµ âˆ‚ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\ntheorem integrable_on.mul_continuous_on_of_subset (hg : integrable_on g A Î¼) (hg' : continuous_on g' K)\n    (hA : measurable_set A) (hK : is_compact K) (hAK : A âŠ† K) : integrable_on (fun x => g x * g' x) A Î¼ :=\n  by\n  rcases is_compact.exists_bound_of_continuous_on hK hg' with âŸ¨C, hCâŸ©\n  rw [integrable_on, â† mem_â„’p_one_iff_integrable] at hgâŠ¢\n  have :\n    Â«exprâˆ€áµ âˆ‚ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€áµ âˆ‚ , Â»\" (Î¼.restrict A)\n      (Â«exprâ€– â€–Â» (g x * g' x) â‰¤ C * Â«exprâ€– â€–Â» (g x)) :=\n    by\n    filter_upwards [ae_restrict_mem hA] with x hx\n    refine' (norm_mul_le _ _).trans _\n    rw [mul_comm]\n    apply mul_le_mul_of_nonneg_right (hC x (hAK hx)) (norm_nonneg _)\n  exact mem_â„’p.of_le_mul hg (hg.ae_strongly_measurable.mul <| (hg'.mono hAK).ae_strongly_measurable hA) this\n#align integrable_on.mul_continuous_on_of_subset integrable_on.mul_continuous_on_of_subset\n\n",
 "mul_continuous_on":
 "theorem integrable_on.mul_continuous_on [t2_space X] (hg : integrable_on g K Î¼) (hg' : continuous_on g' K)\n    (hK : is_compact K) : integrable_on (fun x => g x * g' x) K Î¼ :=\n  hg.mul_continuous_on_of_subset hg' hK.measurable_set hK (Subset.refl _)\n#align integrable_on.mul_continuous_on integrable_on.mul_continuous_on\n\n",
 "locally_integrable_map_homeomorph":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰ƒâ‚œ Â» -/\ntheorem locally_integrable_map_homeomorph [borel_space X] [borel_space Y] (e : Â«expr â‰ƒâ‚œ Â» X Y) {f : Y â†’ E}\n    {Î¼ : measure X} : locally_integrable f (measure.map e Î¼) â†” locally_integrable (f âˆ˜ e) Î¼ :=\n  by\n  refine' âŸ¨fun h x => _, fun h x => _âŸ©\n  Â· rcases h (e x) with âŸ¨U, hU, h'UâŸ©\n    refine' âŸ¨Â«expr â»Â¹' Â» e U, e.continuous.continuous_at.preimage_mem_nhds hU, _âŸ©\n    exact (integrable_on_map_equiv e.to_measurable_equiv).1 h'U\n  Â· rcases h (e.symm x) with âŸ¨U, hU, h'UâŸ©\n    refine' âŸ¨Â«expr â»Â¹' Â» e.symm U, e.symm.continuous.continuous_at.preimage_mem_nhds hU, _âŸ©\n    apply (integrable_on_map_equiv e.to_measurable_equiv).2\n    simp only [homeomorph.to_measurable_equiv_coe]\n    convert h'U\n    ext x\n    simp only [mem_preimage, homeomorph.symm_apply_apply]\n#align locally_integrable_map_homeomorph locally_integrable_map_homeomorph\n\n",
 "locally_integrable_iff":
 "theorem locally_integrable_iff [locally_compact_space X] :\n    locally_integrable f Î¼ â†” âˆ€ k : set X, is_compact k â†’ integrable_on f k Î¼ :=\n  by\n  refine' âŸ¨fun hf k hk => hf.integrable_on_is_compact hk, fun hf x => _âŸ©\n  obtain âŸ¨K, hK, h2KâŸ© := exists_compact_mem_nhds x\n  exact âŸ¨K, h2K, hf K hKâŸ©\n#align locally_integrable_iff locally_integrable_iff\n\n",
 "locally_integrable_const":
 "theorem locally_integrable_const [is_locally_finite_measure Î¼] (c : E) : locally_integrable (fun x => c) Î¼ :=\n  by\n  intro x\n  rcases Î¼.finite_at_nhds x with âŸ¨U, hU, h'UâŸ©\n  refine' âŸ¨U, hU, _âŸ©\n  simp only [h'U, integrable_on_const, or_true_iff]\n#align locally_integrable_const locally_integrable_const\n\n",
 "locally_integrable":
 "theorem antitone.locally_integrable [is_locally_finite_measure Î¼] (hanti : antitone f) : locally_integrable f Î¼ :=\n  hanti.dual_right.locally_integrable\n#align antitone.locally_integrable antitone.locally_integrable\n\n",
 "integrable_on_uIoc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprÎ™ -/\ntheorem continuous.integrable_on_uIoc [linear_order X] [compact_Icc_space X] (hf : continuous f) :\n    integrable_on f ((exprÎ™) a b) Î¼ :=\n  hf.integrable_on_Ioc\n#align continuous.integrable_on_uIoc continuous.integrable_on_uIoc\n\n",
 "integrable_on_uIcc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.uIcc -/\ntheorem continuous.integrable_on_uIcc [linear_order X] [compact_Icc_space X] (hf : continuous f) :\n    integrable_on f (set.uIcc a b) Î¼ :=\n  hf.integrable_on_Icc\n#align continuous.integrable_on_uIcc continuous.integrable_on_uIcc\n\n",
 "integrable_on_of_nhds_within":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/-- If a function is integrable at `ğ“[s] x` for each point `x` of a compact set `s`, then it is\nintegrable on `s`. -/\ntheorem is_compact.integrable_on_of_nhds_within {K : set X} (hK : is_compact K)\n    (hf : âˆ€ x âˆˆ K, integrable_at_filter f (nhds_within K x) Î¼) : integrable_on f K Î¼ :=\n  is_compact.induction_on hK integrable_on_empty (fun s t hst ht => ht.mono_set hst) (fun s t hs ht => hs.union ht) hf\n#align is_compact.integrable_on_of_nhds_within is_compact.integrable_on_of_nhds_within\n\n",
 "integrable_on_of_measure_ne_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\ntheorem antitone_on.integrable_on_of_measure_ne_top (hanti : antitone_on f s) {a b : X} (ha : IsLeast s a)\n    (hb : IsGreatest s b) (hs : Î¼ s â‰  ennreal.top) (h's : measurable_set s) : integrable_on f s Î¼ :=\n  hanti.dual_right.integrable_on_of_measure_ne_top ha hb hs h's\n#align antitone_on.integrable_on_of_measure_ne_top antitone_on.integrable_on_of_measure_ne_top\n\n",
 "integrable_on_nhds_is_compact":
 "/-- If a function is locally integrable, then it is integrable on an open neighborhood of any\ncompact set. -/\ntheorem locally_integrable.integrable_on_nhds_is_compact (hf : locally_integrable f Î¼) {k : set X} (hk : is_compact k) :\n    âˆƒ u, is_open u âˆ§ k âŠ† u âˆ§ integrable_on f u Î¼ :=\n  by\n  refine' is_compact.induction_on hk _ _ _ _\n  Â· refine' âŸ¨âˆ…, is_open_empty, subset.rfl, integrable_on_emptyâŸ©\n  Â· rintro s t hst âŸ¨u, u_open, tu, huâŸ©\n    exact âŸ¨u, u_open, hst.trans tu, huâŸ©\n  Â· rintro s t âŸ¨u, u_open, su, huâŸ© âŸ¨v, v_open, tv, hvâŸ©\n    exact âŸ¨u âˆª v, u_open.union v_open, union_subset_union su tv, hu.union hvâŸ©\n  Â· intro x hx\n    rcases hf x with âŸ¨u, ux, huâŸ©\n    rcases mem_nhds_iff.1 ux with âŸ¨v, vu, v_open, xvâŸ©\n    exact âŸ¨v, nhds_within_le_nhds (v_open.mem_nhds xv), v, v_open, subset.rfl, hu.mono_set vuâŸ©\n#align locally_integrable.integrable_on_nhds_is_compact locally_integrable.integrable_on_nhds_is_compact\n\n",
 "integrable_on_is_compact":
 "theorem antione_on.integrable_on_is_compact [is_finite_measure_on_compacts Î¼] (hs : is_compact s)\n    (hanti : antitone_on f s) : integrable_on f s Î¼ :=\n  hanti.dual_right.integrable_on_is_compact hs\n#align antione_on.integrable_on_is_compact antione_on.integrable_on_is_compact\n\n",
 "integrable_on_compact":
 "/-- A function `f` continuous on a compact set `K` is integrable on this set with respect to any\nlocally finite measure. -/\ntheorem continuous_on.integrable_on_compact (hK : is_compact K) (hf : continuous_on f K) : integrable_on f K Î¼ :=\n  by\n  letI := metrizable_space_metric X\n  apply hK.integrable_on_of_nhds_within fun x hx => _\n  exact hf.integrable_at_nhds_within_of_is_separable hK.measurable_set hK.is_separable hx\n#align continuous_on.integrable_on_compact continuous_on.integrable_on_compact\n\n",
 "integrable_on_Ioc":
 "theorem continuous.integrable_on_Ioc [preorder X] [compact_Icc_space X] (hf : continuous f) :\n    integrable_on f (Ioc a b) Î¼ :=\n  hf.integrable_on_Icc.mono_set Ioc_subset_Icc_self\n#align continuous.integrable_on_Ioc continuous.integrable_on_Ioc\n\n",
 "integrable_on_Icc":
 "theorem continuous.integrable_on_Icc [preorder X] [compact_Icc_space X] (hf : continuous f) :\n    integrable_on f (Icc a b) Î¼ :=\n  hf.continuous_on.integrable_on_Icc\n#align continuous.integrable_on_Icc continuous.integrable_on_Icc\n\n",
 "integrable_of_has_compact_support":
 "/-- A continuous function with compact support is integrable on the whole space. -/\ntheorem continuous.integrable_of_has_compact_support (hf : continuous f) (hcf : has_compact_support f) :\n    integrable f Î¼ :=\n  (integrable_on_iff_integrable_of_support_subset (subset_tsupport f) measurable_set_closure).mp <|\n    hf.continuous_on.integrable_on_compact hcf\n#align continuous.integrable_of_has_compact_support continuous.integrable_of_has_compact_support\n\n",
 "indicator":
 "theorem locally_integrable.indicator (hf : locally_integrable f Î¼) {s : set X} (hs : measurable_set s) :\n    locally_integrable (s.indicator f) Î¼ := by\n  intro x\n  rcases hf x with âŸ¨U, hU, h'UâŸ©\n  exact âŸ¨U, hU, h'U.indicator hsâŸ©\n#align locally_integrable.indicator locally_integrable.indicator\n\n",
 "continuous_on_mul_of_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€áµ âˆ‚ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€áµ âˆ‚ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\ntheorem integrable_on.continuous_on_mul_of_subset (hg : continuous_on g K) (hg' : integrable_on g' A Î¼)\n    (hK : is_compact K) (hA : measurable_set A) (hAK : A âŠ† K) : integrable_on (fun x => g x * g' x) A Î¼ :=\n  by\n  rcases is_compact.exists_bound_of_continuous_on hK hg with âŸ¨C, hCâŸ©\n  rw [integrable_on, â† mem_â„’p_one_iff_integrable] at hg'âŠ¢\n  have :\n    Â«exprâˆ€áµ âˆ‚ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€áµ âˆ‚ , Â»\" (Î¼.restrict A)\n      (Â«exprâ€– â€–Â» (g x * g' x) â‰¤ C * Â«exprâ€– â€–Â» (g' x)) :=\n    by\n    filter_upwards [ae_restrict_mem hA] with x hx\n    refine' (norm_mul_le _ _).trans _\n    apply mul_le_mul_of_nonneg_right (hC x (hAK hx)) (norm_nonneg _)\n  exact mem_â„’p.of_le_mul hg' (((hg.mono hAK).ae_strongly_measurable hA).mul hg'.ae_strongly_measurable) this\n#align integrable_on.continuous_on_mul_of_subset integrable_on.continuous_on_mul_of_subset\n\n",
 "continuous_on_mul":
 "theorem integrable_on.continuous_on_mul [t2_space X] (hg : continuous_on g K) (hg' : integrable_on g' K Î¼)\n    (hK : is_compact K) : integrable_on (fun x => g x * g' x) K Î¼ :=\n  hg'.continuous_on_mul_of_subset hg hK hK.measurable_set Subset.rfl\n#align integrable_on.continuous_on_mul integrable_on.continuous_on_mul\n\n",
 "ae_strongly_measurable":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â» -/\ntheorem locally_integrable.ae_strongly_measurable [second_countable_topology X] (hf : locally_integrable f Î¼) :\n    ae_strongly_measurable f Î¼ :=\n  by\n  have : âˆ€ x, âˆƒ u, is_open u âˆ§ x âˆˆ u âˆ§ integrable_on f u Î¼ :=\n    by\n    intro x\n    rcases hf x with âŸ¨s, hs, h'sâŸ©\n    rcases mem_nhds_iff.1 hs with âŸ¨u, us, u_open, xuâŸ©\n    exact âŸ¨u, u_open, xu, h's.mono_set usâŸ©\n  choose u u_open xu hu using this\n  obtain âŸ¨T, T_count, hTâŸ© :\n    âˆƒ T : set X,\n      T.countable âˆ§\n        Â«exprâ‹ƒ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â»\" (u i) = univ :=\n    by\n    have :\n      Â«exprâ‹ƒ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â»\" (u x) = univ :=\n      eq_univ_of_forall fun x => mem_Union_of_mem x (xu x)\n    rw [â† this]\n    simp only [Union_coe_set, subtype.coe_mk]\n    exact is_open_Union_countable u u_open\n  have : countable T := countable_coe_iff.mpr T_count\n  rw [â† @restrict_univ _ _ Î¼, â† hT, ae_strongly_measurable_Union_iff]\n  exact fun i => (hu i).ae_strongly_measurable\n#align locally_integrable.ae_strongly_measurable locally_integrable.ae_strongly_measurable\n\n"}