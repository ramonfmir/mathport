{"univ_pi":
 "theorem measurable_set.univ_pi [countable δ] {t : ∀ i : δ, set (π i)} (ht : ∀ i, measurable_set (t i)) :\n    measurable_set (pi univ t) :=\n  measurable_set.pi (to_countable _) fun i _ => ht i\n#align measurable_set.univ_pi measurable_set.univ_pi\n\n",
 "tprod":
 "theorem measurable_set.tprod (l : list δ) {s : ∀ i, set (π i)} (hs : ∀ i, measurable_set (s i)) :\n    measurable_set (set.tprod l s) := by\n  induction' l with i l ih\n  exact measurable_set.univ\n  exact (hs i).prod ih\n#align measurable_set.tprod measurable_set.tprod\n\n",
 "to_equiv_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ᵐ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\ntheorem to_equiv_injective : injective (to_equiv : «expr ≃ᵐ » α β → «expr ≃ » α β) :=\n  by\n  rintro ⟨e₁, _, _⟩ ⟨e₂, _, _⟩ (rfl : e₁ = e₂)\n  rfl\n#align to_equiv_injective to_equiv_injective\n\n",
 "symm_trans_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ᵐ » -/\n@[simp]\ntheorem symm_trans_self (e : «expr ≃ᵐ » α β) : e.symm.trans e = refl β :=\n  ext e.self_comp_symm\n#align symm_trans_self symm_trans_self\n\n",
 "symm_refl":
 "@[simp]\ntheorem symm_refl (α : Type _) [measurable_space α] : (refl α).symm = refl α :=\n  rfl\n#align symm_refl symm_refl\n\n",
 "symm_preimage_preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ᵐ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n@[simp]\ntheorem symm_preimage_preimage (e : «expr ≃ᵐ » α β) (s : set β) : «expr ⁻¹' » e.symm («expr ⁻¹' » e s) = s :=\n  e.to_equiv.symm_preimage_preimage s\n#align symm_preimage_preimage symm_preimage_preimage\n\n",
 "symm_mk":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ᵐ » -/\n@[simp]\ntheorem symm_mk (e : «expr ≃ » α β) (h1 : measurable e) (h2 : measurable e.symm) :\n    (⟨e, h1, h2⟩ : «expr ≃ᵐ » α β).symm = ⟨e.symm, h2, h1⟩ :=\n  rfl\n#align symm_mk symm_mk\n\n",
 "symm_comp_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ᵐ » -/\n@[simp]\ntheorem symm_comp_self (e : «expr ≃ᵐ » α β) : e.symm ∘ e = id :=\n  funext e.left_inv\n#align symm_comp_self symm_comp_self\n\n",
 "symm_apply_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ᵐ » -/\n@[simp]\ntheorem symm_apply_apply (e : «expr ≃ᵐ » α β) (x : α) : e.symm (e x) = x :=\n  e.left_inv x\n#align symm_apply_apply symm_apply_apply\n\n",
 "surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ᵐ » -/\nprotected theorem surjective (e : «expr ≃ᵐ » α β) : surjective e :=\n  e.to_equiv.surjective\n#align surjective surjective\n\n",
 "sum_elim":
 "@[measurability]\ntheorem measurable.sum_elim {mγ : measurable_space γ} {f : α → γ} {g : β → γ} (hf : measurable f) (hg : measurable g) :\n    measurable (sum.elim f g) :=\n  measurable_sum hf hg\n#align measurable.sum_elim measurable.sum_elim\n\n",
 "subtype_mk":
 "@[measurability]\ntheorem measurable.subtype_mk {p : β → Prop} {f : α → β} (hf : measurable f) {h : ∀ x, p (f x)} :\n    measurable fun x => (⟨f x, h x⟩ : subtype p) := fun t ⟨s, hs⟩ =>\n  hs.2 ▸ by simp only [← preimage_comp, (· ∘ ·), subtype.coe_mk, hf hs.1]\n#align measurable.subtype_mk measurable.subtype_mk\n\n",
 "subtype_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem measurable_set.subtype_image {s : set α} {t : set s} (hs : measurable_set s) :\n    measurable_set t → measurable_set («expr '' » (coe : s → α) t)\n  | ⟨u, (hu : measurable_set u), (eq : «expr ⁻¹' » coe u = t)⟩ =>\n    by\n    rw [← eq, Subtype.image_preimage_coe]\n    exact hu.inter hs\n#align measurable_set.subtype_image measurable_set.subtype_image\n\n",
 "subtype_coe":
 "theorem subtype_coe {s : set α} (hs : measurable_set s) : measurable_embedding (coe : s → α) :=\n  { injective := subtype.coe_injective\n    measurable := measurable_subtype_coe\n    measurable_set_image' := fun _ => measurable_set.subtype_image hs }\n#align subtype_coe subtype_coe\n\n",
 "snd":
 "theorem measurable.snd {f : α → β × γ} (hf : measurable f) : measurable fun a : α => (f a).2 :=\n  measurable_snd.comp hf\n#align measurable.snd measurable.snd\n\n",
 "self_trans_symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ᵐ » -/\n@[simp]\ntheorem self_trans_symm (e : «expr ≃ᵐ » α β) : e.trans e.symm = refl α :=\n  ext e.symm_comp_self\n#align self_trans_symm self_trans_symm\n\n",
 "self_comp_symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ᵐ » -/\n@[simp]\ntheorem self_comp_symm (e : «expr ≃ᵐ » α β) : e ∘ e.symm = id :=\n  funext e.right_inv\n#align self_comp_symm self_comp_symm\n\n",
 "prod_mk":
 "theorem measurable.prod_mk {β γ} {mβ : measurable_space β} {mγ : measurable_space γ} {f : α → β} {g : α → γ}\n    (hf : measurable f) (hg : measurable g) : measurable fun a : α => (f a, g a) :=\n  measurable.prod hf hg\n#align measurable.prod_mk measurable.prod_mk\n\n",
 "prod_map":
 "theorem measurable.prod_map [measurable_space δ] {f : α → β} {g : γ → δ} (hf : measurable f) (hg : measurable g) :\n    measurable (prod.map f g) :=\n  (hf.comp measurable_fst).prod_mk (hg.comp measurable_snd)\n#align measurable.prod_map measurable.prod_map\n\n",
 "prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n@[measurability]\ntheorem measurable_set.prod {s : set α} {t : set β} (hs : measurable_set s) (ht : measurable_set t) :\n    measurable_set (lower_set.prod s t) :=\n  measurable_set.inter (measurable_fst hs) (measurable_snd ht)\n#align measurable_set.prod measurable_set.prod\n\n",
 "principal_is_measurably_generated_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\ntheorem principal_is_measurably_generated_iff {s : set α} :\n    is_measurably_generated ((filter.principal) s) ↔ measurable_set s :=\n  by\n  refine' ⟨_, fun hs => ⟨fun t ht => ⟨s, mem_principal_self s, hs, ht⟩⟩⟩\n  rintro ⟨hs⟩\n  rcases hs (mem_principal_self s) with ⟨t, ht, htm, hts⟩\n  have : t = s := subset.antisymm hts ht\n  rwa [← this]\n#align principal_is_measurably_generated_iff principal_is_measurably_generated_iff\n\n",
 "piecewise":
 "@[measurability]\ntheorem measurable.piecewise {_ : decidable_pred (· ∈ s)} (hs : measurable_set s) (hf : measurable f)\n    (hg : measurable g) : measurable (piecewise s f g) :=\n  by\n  intro t ht\n  rw [piecewise_preimage]\n  exact hs.ite (hf ht) (hg ht)\n#align measurable.piecewise measurable.piecewise\n\n",
 "pi":
 "/- Even though we cannot use projection notation, we still keep a dot to be consistent with similar\n  lemmas, like `measurable_set.prod`. -/\n@[measurability]\ntheorem measurable_set.pi {s : set δ} {t : ∀ i : δ, set (π i)} (hs : s.countable) (ht : ∀ i ∈ s, measurable_set (t i)) :\n    measurable_set (s.pi t) := by\n  rw [pi_def]\n  exact measurable_set.bInter hs fun i hi => measurable_pi_apply _ (ht i hi)\n#align measurable_set.pi measurable_set.pi\n\n",
 "of_uncurry_right":
 "theorem measurable.of_uncurry_right {f : α → β → γ} (hf : measurable (uncurry f)) {y : β} : measurable fun x => f x y :=\n  hf.comp measurable_prod_mk_right\n#align measurable.of_uncurry_right measurable.of_uncurry_right\n\n",
 "of_uncurry_left":
 "theorem measurable.of_uncurry_left {f : α → β → γ} (hf : measurable (uncurry f)) {x : α} : measurable (f x) :=\n  hf.comp measurable_prod_mk_left\n#align measurable.of_uncurry_left measurable.of_uncurry_left\n\n",
 "of_measurable_inverse_on_range":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ᵐ » -/\ntheorem of_measurable_inverse_on_range {g : range f → α} (hf₁ : measurable f) (hf₂ : measurable_set (range f))\n    (hg : measurable g) (H : left_inverse g (rangeFactorization f)) : measurable_embedding f :=\n  by\n  set e : «expr ≃ᵐ » α (range f) :=\n    ⟨⟨range_factorization f, g, H, H.right_inverse_of_surjective surjective_onto_range⟩, hf₁.subtype_mk, hg⟩\n  exact (measurable_embedding.subtype_coe hf₂).comp e.measurable_embedding\n#align of_measurable_inverse_on_range of_measurable_inverse_on_range\n\n",
 "of_measurable_inverse":
 "theorem of_measurable_inverse (hf₁ : measurable f) (hf₂ : measurable_set (range f)) (hg : measurable g)\n    (H : left_inverse g f) : measurable_embedding f :=\n  of_measurable_inverse_on_range hf₁ hf₂ (hg.comp measurable_subtype_coe) H\n#align of_measurable_inverse of_measurable_inverse\n\n",
 "monotone_map":
 "theorem monotone_map : monotone (measurable_space.map f) := fun a b h => map_mono h\n#align monotone_map monotone_map\n\n",
 "monotone_comap":
 "theorem monotone_comap : monotone (measurable_space.comap g) := fun a b h => comap_mono h\n#align monotone_comap monotone_comap\n\n",
 "mono":
 "theorem measurable.mono {ma ma' : measurable_space α} {mb mb' : measurable_space β} {f : α → β}\n    (hf : @measurable α β ma mb f) (ha : ma ≤ ma') (hb : mb' ≤ mb) : @measurable α β ma' mb' f := fun t ht =>\n  ha _ <| hf <| hb _ ht\n#align measurable.mono measurable.mono\n\n",
 "mem_coe":
 "@[simp]\ntheorem mem_coe (a : α) (s : subtype (measurable_set : set α → Prop)) : a ∈ (s : set α) ↔ a ∈ s :=\n  iff.rfl\n#align mem_coe mem_coe\n\n",
 "measurable_update":
 "/-- The function `update f a : π a → Π a, π a` is always measurable.\n  This doesn't require `f` to be measurable.\n  This should not be confused with the statement that `update f a x` is measurable. -/\n@[measurability]\ntheorem measurable_update (f : ∀ a : δ, π a) {a : δ} [decidable_eq δ] : measurable (update f a) :=\n  by\n  apply measurable_pi_lambda\n  intro x; by_cases hx : x = a\n  · cases hx\n    convert measurable_id\n    ext\n    simp\n  simp_rw [update_noteq hx]; apply measurable_const\n#align measurable_update measurable_update\n\n",
 "measurable_unit":
 "@[measurability]\ntheorem measurable_unit [measurable_space α] (f : unit → α) : measurable f :=\n  measurable_from_top\n#align measurable_unit measurable_unit\n\n",
 "measurable_tprod_mk":
 "theorem measurable_tprod_mk (l : list δ) : measurable (@tprod.mk δ π l) :=\n  by\n  induction' l with i l ih\n  · exact measurable_const\n  · exact (measurable_pi_apply i).prod_mk ih\n#align measurable_tprod_mk measurable_tprod_mk\n\n",
 "measurable_tprod_elim'":
 "theorem measurable_tprod_elim' [decidable_eq δ] {l : list δ} (h : ∀ i, i ∈ l) :\n    measurable (tprod.elim' h : tprod π l → ∀ i, π i) :=\n  measurable_pi_lambda _ fun i => measurable_tprod_elim (h i)\n#align measurable_tprod_elim' measurable_tprod_elim'\n\n",
 "measurable_tprod_elim":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `sym.cons' -/\ntheorem measurable_tprod_elim [decidable_eq δ] :\n    ∀ {l : list δ} {i : δ} (hi : i ∈ l), measurable fun v : tprod π l => v.elim hi\n  | sym.cons' i is, j, hj => by\n    by_cases hji : j = i\n    · subst hji\n      simp [measurable_fst]\n    · rw [funext <| tprod.elim_of_ne _ hji]\n      exact (measurable_tprod_elim (hj.resolve_left hji)).comp measurable_snd\n#align measurable_tprod_elim measurable_tprod_elim\n\n",
 "measurable_to_nat":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem measurable_to_nat {f : α → ℕ} : (∀ y, measurable_set («expr ⁻¹' » f {f y})) → measurable f :=\n  measurable_to_countable\n#align measurable_to_nat measurable_to_nat\n\n",
 "measurable_to_countable":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n-- this also works for `unit`\ntheorem measurable_to_countable [measurable_space α] [countable α] [measurable_space β] {f : β → α}\n    (h : ∀ y, measurable_set («expr ⁻¹' » f {f y})) : measurable f :=\n  by\n  intro s hs\n  rw [← bUnion_preimage_singleton]\n  refine' measurable_set.Union fun y => measurable_set.Union fun hy => _\n  by_cases hyf : y ∈ range f\n  · rcases hyf with ⟨y, rfl⟩\n    apply h\n  · simp only [preimage_singleton_eq_empty.2 hyf, measurable_set.empty]\n#align measurable_to_countable measurable_to_countable\n\n",
 "measurable_swap_iff":
 "theorem measurable_swap_iff {mγ : measurable_space γ} {f : α × β → γ} : measurable (f ∘ prod.swap) ↔ measurable f :=\n  ⟨fun hf => by\n    convert hf.comp measurable_swap\n    ext ⟨x, y⟩\n    rfl, fun hf => hf.comp measurable_swap⟩\n#align measurable_swap_iff measurable_swap_iff\n\n",
 "measurable_swap":
 "@[measurability]\ntheorem measurable_swap : measurable (prod.swap : α × β → β × α) :=\n  measurable.prod measurable_snd measurable_fst\n#align measurable_swap measurable_swap\n\n",
 "measurable_sum":
 "theorem measurable_sum {mγ : measurable_space γ} {f : Sum α β → γ} (hl : measurable (f ∘ sum.inl))\n    (hr : measurable (f ∘ sum.inr)) : measurable f :=\n  measurable.of_comap_le <|\n    le_inf (measurable_space.comap_le_iff_le_map.2 <| hl) (measurable_space.comap_le_iff_le_map.2 <| hr)\n#align measurable_sum measurable_sum\n\n",
 "measurable_subtype_coe":
 "@[measurability]\ntheorem measurable_subtype_coe {p : α → Prop} : measurable (coe : subtype p → α) :=\n  measurable_space.le_map_comap\n#align measurable_subtype_coe measurable_subtype_coe\n\n",
 "measurable_snd":
 "@[measurability]\ntheorem measurable_snd {ma : measurable_space α} {mb : measurable_space β} : measurable (prod.snd : α × β → β) :=\n  measurable.of_comap_le le_sup_right\n#align measurable_snd measurable_snd\n\n",
 "measurable_set_swap_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem measurable_set_swap_iff {s : set (α × β)} : measurable_set («expr ⁻¹' » prod.swap s) ↔ measurable_set s :=\n  ⟨fun hs => by\n    convert measurable_swap hs\n    ext ⟨x, y⟩\n    rfl, fun hs => measurable_swap hs⟩\n#align measurable_set_swap_iff measurable_set_swap_iff\n\n",
 "measurable_set_range_inr":
 "theorem measurable_set_range_inr [measurable_space α] : measurable_set (range sum.inr : set (Sum α β)) :=\n  by\n  rw [← image_univ]\n  exact measurable_set_inr_image measurable_set.univ\n#align measurable_set_range_inr measurable_set_range_inr\n\n",
 "measurable_set_range_inl":
 "theorem measurable_set_range_inl [measurable_space α] : measurable_set (range sum.inl : set (Sum α β)) :=\n  by\n  rw [← image_univ]\n  exact measurable_set.univ.inl_image\n#align measurable_set_range_inl measurable_set_range_inl\n\n",
 "measurable_set_range":
 "theorem measurable_set_range (hf : measurable_embedding f) : measurable_set (range f) :=\n  by\n  rw [← image_univ]\n  exact hf.measurable_set_image' measurable_set.univ\n#align measurable_set_range measurable_set_range\n\n",
 "measurable_set_quotient":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem measurable_set_quotient {s : setoid α} {t : set (quotient s)} :\n    measurable_set t ↔ measurable_set («expr ⁻¹' » quotient.mk' t) :=\n  iff.rfl\n#align measurable_set_quotient measurable_set_quotient\n\n",
 "measurable_set_prod_of_nonempty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\ntheorem measurable_set_prod_of_nonempty {s : set α} {t : set β} (h : (lower_set.prod s t).nonempty) :\n    measurable_set (lower_set.prod s t) ↔ measurable_set s ∧ measurable_set t :=\n  by\n  rcases h with ⟨⟨x, y⟩, hx, hy⟩\n  refine' ⟨fun hst => _, fun h => h.1.prod h.2⟩\n  have : measurable_set («expr ⁻¹' » (fun x => (x, y)) (lower_set.prod s t)) := measurable_prod_mk_right hst\n  have : measurable_set («expr ⁻¹' » (prod.mk x) (lower_set.prod s t)) := measurable_prod_mk_left hst\n  simp_all\n#align measurable_set_prod_of_nonempty measurable_set_prod_of_nonempty\n\n",
 "measurable_set_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\ntheorem measurable_set_prod {s : set α} {t : set β} :\n    measurable_set (lower_set.prod s t) ↔ measurable_set s ∧ measurable_set t ∨ s = ∅ ∨ t = ∅ :=\n  by\n  cases' (lower_set.prod s t).eq_empty_or_nonempty with h h\n  · simp [h, prod_eq_empty_iff.mp h]\n  · simp [← not_nonempty_iff_eq_empty, prod_nonempty_iff.mp h, measurable_set_prod_of_nonempty h]\n#align measurable_set_prod measurable_set_prod\n\n",
 "measurable_set_preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ᵐ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n@[simp]\ntheorem measurable_set_preimage (e : «expr ≃ᵐ » α β) {s : set β} :\n    measurable_set («expr ⁻¹' » e s) ↔ measurable_set s :=\n  ⟨fun h => by simpa only [symm_preimage_preimage] using e.symm.measurable h, fun h => e.measurable h⟩\n#align measurable_set_preimage measurable_set_preimage\n\n",
 "measurable_set_pi_of_nonempty":
 "theorem measurable_set_pi_of_nonempty {s : set δ} {t : ∀ i, set (π i)} (hs : s.countable) (h : (pi s t).nonempty) :\n    measurable_set (pi s t) ↔ ∀ i ∈ s, measurable_set (t i) := by\n  classical\n    rcases h with ⟨f, hf⟩\n    refine' ⟨fun hst i hi => _, measurable_set.pi hs⟩\n    convert measurable_update f hst\n    rw [update_preimage_pi hi]\n    exact fun j hj _ => hf j hj\n#align measurable_set_pi_of_nonempty measurable_set_pi_of_nonempty\n\n",
 "measurable_set_pi":
 "theorem measurable_set_pi {s : set δ} {t : ∀ i, set (π i)} (hs : s.countable) :\n    measurable_set (pi s t) ↔ (∀ i ∈ s, measurable_set (t i)) ∨ pi s t = ∅ :=\n  by\n  cases' (pi s t).eq_empty_or_nonempty with h h\n  · simp [h]\n  · simp [measurable_set_pi_of_nonempty hs, h, ← not_nonempty_iff_eq_empty]\n#align measurable_set_pi measurable_set_pi\n\n",
 "measurable_set_mul_support":
 "@[measurability, to_additive]\ntheorem measurable_set_mul_support [One β] [measurable_singleton_class β] (hf : measurable f) :\n    measurable_set (mul_support f) :=\n  hf (measurable_set_singleton 1).compl\n#align measurable_set_mul_support measurable_set_mul_support\n\n",
 "measurable_set_limsup":
 "@[measurability]\ntheorem measurable_set_limsup {s : ℕ → set α} (hs : ∀ n, measurable_set <| s n) :\n    measurable_set <| filter.limsup s filter.at_top :=\n  by\n  convert measurable_set_blimsup (fun n h => hs n : ∀ n, true → measurable_set (s n))\n  simp\n#align measurable_set_limsup measurable_set_limsup\n\n",
 "measurable_set_liminf":
 "@[measurability]\ntheorem measurable_set_liminf {s : ℕ → set α} (hs : ∀ n, measurable_set <| s n) :\n    measurable_set <| filter.liminf s filter.at_top :=\n  by\n  convert measurable_set_bliminf (fun n h => hs n : ∀ n, true → measurable_set (s n))\n  simp\n#align measurable_set_liminf measurable_set_liminf\n\n",
 "measurable_set_inr_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem measurable_set_inr_image {s : set β} (hs : measurable_set s) :\n    measurable_set («expr '' » sum.inr s : set (Sum α β)) :=\n  ⟨have : «expr ⁻¹' » sum.inl («expr '' » sum.inr s : set (Sum α β)) = ∅ :=\n      eq_empty_of_subset_empty fun x ⟨y, hy, eq⟩ => by contradiction\n    show measurable_set («expr ⁻¹' » sum.inl _) by\n      rw [this]\n      exact measurable_set.empty,\n    show measurable_set («expr ⁻¹' » sum.inr _) by\n      rwa [preimage_image_eq]\n      exact fun a b => sum.inr.inj⟩\n#align measurable_set_inr_image measurable_set_inr_image\n\n",
 "measurable_set_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ᵐ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n@[simp]\ntheorem measurable_set_image (e : «expr ≃ᵐ » α β) {s : set α} : measurable_set («expr '' » e s) ↔ measurable_set s := by\n  rw [image_eq_preimage, measurable_set_preimage]\n#align measurable_set_image measurable_set_image\n\n",
 "measurable_set_blimsup":
 "@[measurability]\ntheorem measurable_set_blimsup {s : ℕ → set α} {p : ℕ → Prop} (h : ∀ n, p n → measurable_set (s n)) :\n    measurable_set <| filter.blimsup s filter.at_top p :=\n  by\n  simp only [filter.blimsup_eq_infi_bsupr_of_nat, supr_eq_Union, infi_eq_Inter]\n  exact measurable_set.Inter fun n => measurable_set.Union fun m => measurable_set.Union fun hm => h m hm.1\n#align measurable_set_blimsup measurable_set_blimsup\n\n",
 "measurable_set_bliminf":
 "@[measurability]\ntheorem measurable_set_bliminf {s : ℕ → set α} {p : ℕ → Prop} (h : ∀ n, p n → measurable_set (s n)) :\n    measurable_set <| filter.bliminf s filter.at_top p :=\n  by\n  simp only [filter.bliminf_eq_supr_binfi_of_nat, infi_eq_Inter, supr_eq_Union]\n  exact measurable_set.Union fun n => measurable_set.Inter fun m => measurable_set.Inter fun hm => h m hm.1\n#align measurable_set_bliminf measurable_set_bliminf\n\n",
 "measurable_range_splitting":
 "theorem measurable_range_splitting (hf : measurable_embedding f) : measurable (rangeSplitting f) := fun s hs => by\n  rwa [preimage_range_splitting hf.injective, ← (subtype_coe hf.measurable_set_range).measurable_set_image, ←\n    image_comp, coe_comp_range_factorization, hf.measurable_set_image]\n#align measurable_range_splitting measurable_range_splitting\n\n",
 "measurable_quotient_mk'":
 "@[measurability]\ntheorem measurable_quotient_mk' {s : setoid α} : measurable (quotient.mk' : α → quotient s) := fun s => id\n#align measurable_quotient_mk' measurable_quotient_mk'\n\n",
 "measurable_quotient_mk":
 "@[measurability]\ntheorem measurable_quotient_mk [s : setoid α] : measurable (Quotient.mk'' : α → quotient s) := fun s => id\n#align measurable_quotient_mk measurable_quotient_mk\n\n",
 "measurable_quot_mk":
 "@[measurability]\ntheorem measurable_quot_mk {r : α → α → Prop} : measurable (Quot.mk r) := fun s => id\n#align measurable_quot_mk measurable_quot_mk\n\n",
 "measurable_prod_mk_right":
 "theorem measurable_prod_mk_right {y : β} : measurable fun x : α => (x, y) :=\n  measurable_id.prod_mk measurable_const\n#align measurable_prod_mk_right measurable_prod_mk_right\n\n",
 "measurable_prod_mk_left":
 "theorem measurable_prod_mk_left {x : α} : measurable (@prod.mk _ β x) :=\n  measurable_const.prod_mk measurable_id\n#align measurable_prod_mk_left measurable_prod_mk_left\n\n",
 "measurable_prod":
 "theorem measurable_prod {f : α → β × γ} : measurable f ↔ (measurable fun a => (f a).1) ∧ measurable fun a => (f a).2 :=\n  ⟨fun hf => ⟨measurable_fst.comp hf, measurable_snd.comp hf⟩, fun h => measurable.prod h.1 h.2⟩\n#align measurable_prod measurable_prod\n\n",
 "measurable_pi_lambda":
 "@[measurability]\ntheorem measurable_pi_lambda (f : α → ∀ a, π a) (hf : ∀ a, measurable fun c => f c a) : measurable f :=\n  measurable_pi_iff.mpr hf\n#align measurable_pi_lambda measurable_pi_lambda\n\n",
 "measurable_pi_iff":
 "theorem measurable_pi_iff {g : α → ∀ a, π a} : measurable g ↔ ∀ a, measurable fun x => g x a := by\n  simp_rw [measurable_iff_comap_le, measurable_space.pi, measurable_space.comap_supr, measurable_space.comap_comp,\n    function.comp, supᵢ_le_iff]\n#align measurable_pi_iff measurable_pi_iff\n\n",
 "measurable_pi_equiv_pi_subtype_prod_symm":
 "@[measurability]\ntheorem measurable_pi_equiv_pi_subtype_prod_symm (p : δ → Prop) [decidable_pred p] :\n    measurable (Equiv.piEquivPiSubtypeProd p π).symm :=\n  by\n  apply measurable_pi_iff.2 fun j => _\n  by_cases hj : p j\n  · simp only [hj, dif_pos, equiv.pi_equiv_pi_subtype_prod_symm_apply]\n    have : measurable fun f : ∀ i : { x // p x }, π ↑i => f ⟨j, hj⟩ := measurable_pi_apply ⟨j, hj⟩\n    exact measurable.comp this measurable_fst\n  · simp only [hj, equiv.pi_equiv_pi_subtype_prod_symm_apply, dif_neg, not_false_iff]\n    have : measurable fun f : ∀ i : { x // ¬p x }, π ↑i => f ⟨j, hj⟩ := measurable_pi_apply ⟨j, hj⟩\n    exact measurable.comp this measurable_snd\n#align measurable_pi_equiv_pi_subtype_prod_symm measurable_pi_equiv_pi_subtype_prod_symm\n\n",
 "measurable_pi_equiv_pi_subtype_prod":
 "@[measurability]\ntheorem measurable_pi_equiv_pi_subtype_prod (p : δ → Prop) [decidable_pred p] :\n    measurable (Equiv.piEquivPiSubtypeProd p π) :=\n  by\n  refine' measurable_prod.2 _\n  constructor <;>\n    · apply measurable_pi_iff.2 fun j => _\n      simp only [pi_equiv_pi_subtype_prod_apply, measurable_pi_apply]\n#align measurable_pi_equiv_pi_subtype_prod measurable_pi_equiv_pi_subtype_prod\n\n",
 "measurable_pi_apply":
 "@[measurability]\ntheorem measurable_pi_apply (a : δ) : measurable fun f : ∀ a, π a => f a :=\n  measurable.of_comap_le <| le_supᵢ _ a\n#align measurable_pi_apply measurable_pi_apply\n\n",
 "measurable_one":
 "@[to_additive]\ntheorem measurable_one [One α] : measurable (1 : β → α) :=\n  @measurable_const _ _ _ _ 1\n#align measurable_one measurable_one\n\n",
 "measurable_of_subsingleton_codomain":
 "@[nontriviality, measurability]\ntheorem measurable_of_subsingleton_codomain [subsingleton β] (f : α → β) : measurable f := fun s hs =>\n  Subsingleton.set_cases measurable_set.empty measurable_set.univ s\n#align measurable_of_subsingleton_codomain measurable_of_subsingleton_codomain\n\n",
 "measurable_of_restrict_of_restrict_compl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\ntheorem measurable_of_restrict_of_restrict_compl {f : α → β} {s : set α} (hs : measurable_set s)\n    (h₁ : measurable (s.restrict f)) (h₂ : measurable ((«expr ᶜ» s).restrict f)) : measurable f :=\n  measurable_of_measurable_union_cover s («expr ᶜ» s) hs hs.compl (union_compl_self s).ge h₁ h₂\n#align measurable_of_restrict_of_restrict_compl measurable_of_restrict_of_restrict_compl\n\n",
 "measurable_of_measurable_union_cover":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem measurable_of_measurable_union_cover {f : α → β} (s t : set α) (hs : measurable_set s) (ht : measurable_set t)\n    (h : univ ⊆ s ∪ t) (hc : measurable fun a : s => f a) (hd : measurable fun a : t => f a) : measurable f :=\n  by\n  intro u hu\n  convert (hs.subtype_image (hc hu)).union (ht.subtype_image (hd hu))\n  change\n    «expr ⁻¹' » f u =\n      «expr '' » coe («expr ⁻¹' » coe («expr ⁻¹' » f u) : set s) ∪\n        «expr '' » coe («expr ⁻¹' » coe («expr ⁻¹' » f u) : set t)\n  rw [image_preimage_eq_inter_range, image_preimage_eq_inter_range, Subtype.range_coe, Subtype.range_coe, ←\n    inter_distrib_left, univ_subset_iff.1 h, inter_univ]\n#align measurable_of_measurable_union_cover measurable_of_measurable_union_cover\n\n",
 "measurable_of_measurable_on_compl_singleton":
 "theorem measurable_of_measurable_on_compl_singleton [measurable_singleton_class α] {f : α → β} (a : α)\n    (hf : measurable ({ x | x ≠ a }.restrict f)) : measurable f :=\n  measurable_of_measurable_on_compl_finite {a} (finite_singleton a) hf\n#align measurable_of_measurable_on_compl_singleton measurable_of_measurable_on_compl_singleton\n\n",
 "measurable_of_measurable_on_compl_finite":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\ntheorem measurable_of_measurable_on_compl_finite [measurable_singleton_class α] {f : α → β} (s : set α) (hs : s.finite)\n    (hf : measurable ((«expr ᶜ» s).restrict f)) : measurable f :=\n  letI : fintype s := finite.fintype hs\n  measurable_of_restrict_of_restrict_compl hs.measurable_set (measurable_of_finite _) hf\n#align measurable_of_measurable_on_compl_finite measurable_of_measurable_on_compl_finite\n\n",
 "measurable_of_finite":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem measurable_of_finite [Finite α] [measurable_singleton_class α] (f : α → β) : measurable f := fun s hs =>\n  («expr ⁻¹' » f s).to_finite.measurable_set\n#align measurable_of_finite measurable_of_finite\n\n",
 "measurable_of_empty_codomain":
 "theorem measurable_of_empty_codomain [is_empty β] (f : α → β) : measurable f :=\n  haveI := Function.isEmpty f\n  measurable_of_empty f\n#align measurable_of_empty_codomain measurable_of_empty_codomain\n\n",
 "measurable_of_empty":
 "theorem measurable_of_empty [is_empty α] (f : α → β) : measurable f :=\n  subsingleton.measurable\n#align measurable_of_empty measurable_of_empty\n\n",
 "measurable_of_countable_ne":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/-- If a function coincides with a measurable function outside of a countable set, it is\nmeasurable. -/\ntheorem measurable.measurable_of_countable_ne [measurable_singleton_class α] (hf : measurable f)\n    (h : set.countable { x | f x ≠ g x }) : measurable g :=\n  by\n  intro t ht\n  have : «expr ⁻¹' » g t = «expr ⁻¹' » g t ∩ «expr ᶜ» { x | f x = g x } ∪ «expr ⁻¹' » g t ∩ { x | f x = g x } := by\n    simp [← inter_union_distrib_left]\n  rw [this]\n  apply measurable_set.union (h.mono (inter_subset_right _ _)).measurable_set\n  have : «expr ⁻¹' » g t ∩ { x : α | f x = g x } = «expr ⁻¹' » f t ∩ { x : α | f x = g x } :=\n    by\n    ext x\n    simp (config := { contextual := true })\n  rw [this]\n  exact (hf ht).inter h.measurable_set.of_compl\n#align measurable.measurable_of_countable_ne measurable.measurable_of_countable_ne\n\n",
 "measurable_of_countable":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem measurable_of_countable [countable α] [measurable_singleton_class α] (f : α → β) : measurable f := fun s hs =>\n  («expr ⁻¹' » f s).to_countable.measurable_set\n#align measurable_of_countable measurable_of_countable\n\n",
 "measurable_inr":
 "@[measurability]\ntheorem measurable_inr [measurable_space α] [measurable_space β] : measurable (@sum.inr α β) :=\n  measurable.of_le_map inf_le_right\n#align measurable_inr measurable_inr\n\n",
 "measurable_inl":
 "@[measurability]\ntheorem measurable_inl [measurable_space α] [measurable_space β] : measurable (@sum.inl α β) :=\n  measurable.of_le_map inf_le_left\n#align measurable_inl measurable_inl\n\n",
 "measurable_iff_le_map":
 "theorem measurable_iff_le_map {m₁ : measurable_space α} {m₂ : measurable_space β} {f : α → β} :\n    measurable f ↔ m₂ ≤ m₁.map f :=\n  iff.rfl\n#align measurable_iff_le_map measurable_iff_le_map\n\n",
 "measurable_iff_comap_le":
 "theorem measurable_iff_comap_le {m₁ : measurable_space α} {m₂ : measurable_space β} {f : α → β} :\n    measurable f ↔ m₂.comap f ≤ m₁ :=\n  comap_le_iff_le_map.symm\n#align measurable_iff_comap_le measurable_iff_comap_le\n\n",
 "measurable_generate_from":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem measurable_generate_from [measurable_space α] {s : set (set β)} {f : α → β}\n    (h : ∀ t ∈ s, measurable_set («expr ⁻¹' » f t)) : @measurable _ _ _ (generate_from s) f :=\n  measurable.of_le_map <| generate_from_le h\n#align measurable_generate_from measurable_generate_from\n\n",
 "measurable_fst":
 "@[measurability]\ntheorem measurable_fst {ma : measurable_space α} {mb : measurable_space β} : measurable (prod.fst : α × β → α) :=\n  measurable.of_comap_le le_sup_left\n#align measurable_fst measurable_fst\n\n",
 "measurable_from_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_of -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[measurability]\ntheorem measurable_from_top [measurable_space β] {f : α → β} : (measurable_of («expr⊤»)) f := fun s hs => trivial\n#align measurable_from_top measurable_from_top\n\n",
 "measurable_from_quotient":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n@[to_additive]\ntheorem quotient_group.measurable_from_quotient {G} [group G] [measurable_space G] {S : subgroup G}\n    {f : «expr ⧸ » G S → α} : measurable f ↔ measurable (f ∘ (coe : G → «expr ⧸ » G S)) :=\n  measurable_from_quotient\n#align quotient_group.measurable_from_quotient quotient_group.measurable_from_quotient\n\n",
 "measurable_from_prod_countable":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem measurable_from_prod_countable [countable β] [measurable_singleton_class β] {mγ : measurable_space γ}\n    {f : α × β → γ} (hf : ∀ y, measurable fun x => f (x, y)) : measurable f :=\n  by\n  intro s hs\n  have :\n    «expr ⁻¹' » f s =\n      «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n        (lower_set.prod («expr ⁻¹' » (fun x => f (x, y)) s) ({y} : set β)) :=\n    by\n    ext1 ⟨x, y⟩\n    simp [and_assoc', and_left_comm]\n  rw [this]\n  exact measurable_set.Union fun y => (hf y hs).prod (measurable_set_singleton y)\n#align measurable_from_prod_countable measurable_from_prod_countable\n\n",
 "measurable_from_nat":
 "@[measurability]\ntheorem measurable_from_nat {f : ℕ → α} : measurable f :=\n  measurable_from_top\n#align measurable_from_nat measurable_from_nat\n\n",
 "measurable_find_greatest'":
 "theorem measurable_find_greatest' {p : α → ℕ → Prop} [∀ x, decidable_pred (p x)] {N : ℕ}\n    (hN : ∀ k ≤ N, measurable_set { x | Nat.findGreatest (p x) N = k }) :\n    measurable fun x => Nat.findGreatest (p x) N :=\n  measurable_to_nat fun x => hN _ N.find_greatest_le\n#align measurable_find_greatest' measurable_find_greatest'\n\n",
 "measurable_find_greatest":
 "/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:75:38: in apply_rules #[[\"[\", expr measurable_set.inter, \",\", expr measurable_set.const, \",\", expr measurable_set.Inter, \",\", expr measurable_set.compl, \",\", expr hN, \"]\"],\n  []]: ./././Mathport/Syntax/Translate/Basic.lean:349:22: unsupported: parse error -/\ntheorem measurable_find_greatest {p : α → ℕ → Prop} [∀ x, decidable_pred (p x)] {N}\n    (hN : ∀ k ≤ N, measurable_set { x | p x k }) : measurable fun x => Nat.findGreatest (p x) N :=\n  by\n  refine' measurable_find_greatest' fun k hk => _\n  simp only [Nat.findGreatest_eq_iff, set_of_and, set_of_forall, ← compl_set_of]\n  repeat'\n    trace\n        \"./././Mathport/Syntax/Translate/Tactic/Builtin.lean:75:38: in apply_rules #[[\\\"[\\\", expr measurable_set.inter, \\\",\\\", expr measurable_set.const, \\\",\\\", expr measurable_set.Inter, \\\",\\\", expr measurable_set.compl, \\\",\\\", expr hN, \\\"]\\\"],\\n  []]: ./././Mathport/Syntax/Translate/Basic.lean:349:22: unsupported: parse error\" <;>\n      try intros\n#align measurable_find_greatest measurable_find_greatest\n\n",
 "measurable_find":
 "theorem measurable_find {p : α → ℕ → Prop} [∀ x, decidable_pred (p x)] (hp : ∀ x, ∃ N, p x N)\n    (hm : ∀ k, measurable_set { x | p x k }) : measurable fun x => nat.find (hp x) :=\n  by\n  refine' measurable_to_nat fun x => _\n  rw [preimage_find_eq_disjointed]\n  exact measurable_set.disjointed hm _\n#align measurable_find measurable_find\n\n",
 "measurable_extend":
 "theorem measurable_extend (hf : measurable_embedding f) {g : α → γ} {g' : β → γ} (hg : measurable g)\n    (hg' : measurable g') : measurable (extend f g g') :=\n  by\n  refine' measurable_of_restrict_of_restrict_compl hf.measurable_set_range _ _\n  · rw [restrict_extend_range]\n    simpa only [range_splitting] using hg.comp hf.measurable_range_splitting\n  · rw [restrict_extend_compl_range]\n    exact hg'.comp measurable_subtype_coe\n#align measurable_extend measurable_extend\n\n",
 "measurable_embedding":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ᵐ » -/\n/-- A measurable equivalence is a measurable embedding. -/\nprotected theorem measurable_embedding (e : «expr ≃ᵐ » α β) : measurable_embedding e :=\n  { injective := e.injective\n    measurable := e.measurable\n    measurable_set_image' := fun s => e.measurable_set_image.2 }\n#align measurable_embedding measurable_embedding\n\n",
 "measurable_const'":
 "/-- A version of `measurable_const` that assumes `f x = f y` for all `x, y`. This version works\nfor functions between empty types. -/\ntheorem measurable_const' {f : β → α} (hf : ∀ x y, f x = f y) : measurable f :=\n  by\n  cases isEmpty_or_nonempty β\n  · exact measurable_of_empty f\n  · convert measurable_const\n    exact funext fun x => hf x h.some\n#align measurable_const' measurable_const'\n\n",
 "measurable_comp_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ᵐ » -/\nprotected theorem measurable_comp_iff {f : β → γ} (e : «expr ≃ᵐ » α β) : measurable (f ∘ e) ↔ measurable f :=\n  iff.intro\n    (fun hfe => by\n      have : measurable (f ∘ (e.symm.trans e).to_equiv) := hfe.comp e.symm.measurable\n      rwa [coe_to_equiv, symm_trans_self] at this)\n    fun h => h.comp e.measurable\n#align measurable_comp_iff measurable_comp_iff\n\n",
 "measurable_coe":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n@[to_additive]\ntheorem quotient_group.measurable_coe {G} [group G] [measurable_space G] {S : subgroup G} :\n    measurable (coe : G → «expr ⧸ » G S) :=\n  measurable_quotient_mk'\n#align quotient_group.measurable_coe quotient_group.measurable_coe\n\n",
 "measurable":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ᵐ » -/\n@[measurability]\nprotected theorem measurable (e : «expr ≃ᵐ » α β) : measurable (e : α → β) :=\n  e.measurable_to_fun\n#align measurable measurable\n\n",
 "map_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem map_top : («expr⊤» : measurable_space α).map f = «expr⊤» :=\n  (gc_comap_map f).u_top\n#align map_top map_top\n\n",
 "map_mono":
 "theorem map_mono (h : m₁ ≤ m₂) : m₁.map f ≤ m₂.map f :=\n  (gc_comap_map f).monotone_u h\n#align map_mono map_mono\n\n",
 "map_infi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n@[simp]\ntheorem map_infi {m : ι → measurable_space α} :\n    («expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (m i)).map f =\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" ((m i).map f) :=\n  (gc_comap_map f).u_infi\n#align map_infi map_infi\n\n",
 "map_inf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n@[simp]\ntheorem map_inf : («expr ⊓ » m₁ m₂).map f = «expr ⊓ » (m₁.map f) (m₂.map f) :=\n  (gc_comap_map f).u_inf\n#align map_inf map_inf\n\n",
 "map_id":
 "/-\nCopyright (c) 2017 Johannes Hölzl. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johannes Hölzl, Mario Carneiro\n-/\n@[simp]\ntheorem map_id : m.map id = m :=\n  measurable_space.ext fun s => iff.rfl\n#align map_id map_id\n\n",
 "map_comp":
 "@[simp]\ntheorem map_comp {f : α → β} {g : β → γ} : (m.map f).map g = m.map (g ∘ f) :=\n  measurable_space.ext fun s => iff.rfl\n#align map_comp map_comp\n\n",
 "le_map_comap":
 "theorem le_map_comap : m ≤ (m.comap g).map g :=\n  (gc_comap_map g).le_u_l _\n#align le_map_comap le_map_comap\n\n",
 "iterate":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\n@[measurability]\ntheorem measurable.iterate {f : α → α} (hf : measurable f) : ∀ n, measurable («expr ^[ ]» f n)\n  | 0 => measurable_id\n  | n + 1 => (measurable.iterate n).comp hf\n#align measurable.iterate measurable.iterate\n\n",
 "ite":
 "/-- this is slightly different from `measurable.piecewise`. It can be used to show\n`measurable (ite (x=0) 0 1)` by\n`exact measurable.ite (measurable_set_singleton 0) measurable_const measurable_const`,\nbut replacing `measurable.ite` by `measurable.piecewise` in that example proof does not work. -/\ntheorem measurable.ite {p : α → Prop} {_ : decidable_pred p} (hp : measurable_set { a : α | p a }) (hf : measurable f)\n    (hg : measurable g) : measurable fun x => ite (p x) (f x) (g x) :=\n  measurable.piecewise hp hf hg\n#align measurable.ite measurable.ite\n\n",
 "is_countably_spanning_measurable_set":
 "theorem is_countably_spanning_measurable_set [measurable_space α] :\n    is_countably_spanning { s : set α | measurable_set s } :=\n  ⟨fun _ => univ, fun _ => measurable_set.univ, unionᵢ_const _⟩\n#align is_countably_spanning_measurable_set is_countably_spanning_measurable_set\n\n",
 "inl_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem measurable_set.inl_image {s : set α} (hs : measurable_set s) :\n    measurable_set («expr '' » sum.inl s : set (Sum α β)) :=\n  ⟨show measurable_set («expr ⁻¹' » sum.inl _) by\n      rwa [preimage_image_eq]\n      exact fun a b => sum.inl.inj,\n    have : «expr ⁻¹' » sum.inr («expr '' » sum.inl s : set (Sum α β)) = ∅ :=\n      eq_empty_of_subset_empty fun x ⟨y, hy, eq⟩ => by contradiction\n    show measurable_set («expr ⁻¹' » sum.inr _) by\n      rw [this]\n      exact measurable_set.empty⟩\n#align measurable_set.inl_image measurable_set.inl_image\n\n",
 "injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ᵐ » -/\nprotected theorem injective (e : «expr ≃ᵐ » α β) : injective e :=\n  e.to_equiv.injective\n#align injective injective\n\n",
 "indicator":
 "@[measurability]\ntheorem measurable.indicator [Zero β] (hf : measurable f) (hs : measurable_set s) : measurable (s.indicator f) :=\n  hf.piecewise hs measurable_const\n#align measurable.indicator measurable.indicator\n\n",
 "image_eq_preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ᵐ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem image_eq_preimage (e : «expr ≃ᵐ » α β) (s : set α) : «expr '' » e s = «expr ⁻¹' » e.symm s :=\n  e.to_equiv.image_eq_preimage s\n#align image_eq_preimage image_eq_preimage\n\n",
 "id":
 "#print id /-\ntheorem id : measurable_embedding (id : α → α) :=\n  ⟨injective_id, measurable_id, fun s hs => by rwa [image_id]⟩\n#align id id\n-/\n\n",
 "gc_comap_map":
 "theorem gc_comap_map (f : α → β) : GaloisConnection (measurable_space.comap f) (measurable_space.map f) := fun f g =>\n  comap_le_iff_le_map\n#align gc_comap_map gc_comap_map\n\n",
 "fst":
 "theorem measurable.fst {f : α → β × γ} (hf : measurable f) : measurable fun a : α => (f a).1 :=\n  measurable_fst.comp hf\n#align measurable.fst measurable.fst\n\n",
 "find":
 "/-- A piecewise function on countably many pieces is measurable if all the data is measurable. -/\n@[measurability]\ntheorem measurable.find {m : measurable_space α} {f : ℕ → α → β} {p : ℕ → α → Prop} [∀ n, decidable_pred (p n)]\n    (hf : ∀ n, measurable (f n)) (hp : ∀ n, measurable_set { x | p n x }) (h : ∀ x, ∃ n, p n x) :\n    measurable fun x => f (nat.find (h x)) x :=\n  haveI : measurable fun p : α × ℕ => f p.2 p.1 := measurable_from_prod_countable fun n => hf n\n  this.comp (measurable.prod_mk measurable_id (measurable_find h hp))\n#align measurable.find measurable.find\n\n",
 "ext":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ᵐ » -/\n@[ext]\ntheorem ext {e₁ e₂ : «expr ≃ᵐ » α β} (h : (e₁ : α → β) = e₂) : e₁ = e₂ :=\n  to_equiv_injective <| equiv.coe_fn_injective h\n#align ext ext\n\n",
 "exists_measurable_proj":
 "theorem measurable_set.exists_measurable_proj {m : measurable_space α} {s : set α} (hs : measurable_set s)\n    (hne : s.nonempty) : ∃ f : α → s, measurable f ∧ ∀ x : s, f x = x :=\n  let ⟨f, hfm, hf⟩ :=\n    (measurable_embedding.subtype_coe hs).exists_measurable_extend measurable_id fun _ => hne.to_subtype\n  ⟨f, hfm, congr_fun hf⟩\n#align measurable_set.exists_measurable_proj measurable_set.exists_measurable_proj\n\n",
 "exists_measurable_piecewise_nat":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr on » -/\n/-- Given countably many disjoint measurable sets `t n` and countably many measurable\nfunctions `g n`, one can construct a measurable function that coincides with `g n` on `t n`. -/\ntheorem exists_measurable_piecewise_nat {m : measurable_space α} (t : ℕ → set β) (t_meas : ∀ n, measurable_set (t n))\n    (t_disj : Pairwise («expr on » Disjoint t)) (g : ℕ → β → α) (hg : ∀ n, measurable (g n)) :\n    ∃ f : β → α, measurable f ∧ ∀ n x, x ∈ t n → f x = g n x := by\n  classical\n    let p : ℕ → β → Prop := fun n x =>\n      x ∈\n        t n ∪\n          «expr ᶜ»\n            («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (t k))\n    have M : ∀ n, measurable_set { x | p n x } := fun n =>\n      (t_meas n).union (measurable_set.compl (measurable_set.Union t_meas))\n    have P : ∀ x, ∃ n, p n x := by\n      intro x\n      by_cases H : ∀ i : ℕ, x ∉ t i\n      · exact ⟨0, or.inr (by simpa only [mem_Inter, compl_Union] using H)⟩\n      · simp only [not_forall, not_not_mem] at H\n        rcases H with ⟨n, hn⟩\n        exact ⟨n, or.inl hn⟩\n    refine' ⟨fun x => g (nat.find (P x)) x, measurable.find hg M P, _⟩\n    intro n x hx\n    have : x ∈ t (nat.find (P x)) :=\n      by\n      have B :\n        x ∈\n          t (nat.find (P x)) ∪\n            «expr ᶜ»\n              («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (t k)) :=\n        nat.find_spec (P x)\n      have B' : (∀ i : ℕ, x ∉ t i) ↔ false :=\n        by\n        simp only [iff_false_iff, not_forall, not_not_mem]\n        exact ⟨n, hx⟩\n      simpa only [B', mem_union, mem_Inter, or_false_iff, compl_Union, mem_compl_iff] using B\n    congr\n    by_contra h\n    exact (t_disj (ne.symm h)).le_bot ⟨hx, this⟩\n#align exists_measurable_piecewise_nat exists_measurable_piecewise_nat\n\n",
 "exists_measurable_mem_of_small_sets":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\ntheorem eventually.exists_measurable_mem_of_small_sets {f : filter α} [is_measurably_generated f] {p : set α → Prop}\n    (h :\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\"\n        f.small_sets (p s)) :\n    ∃ s ∈ f, measurable_set s ∧ p s :=\n  let ⟨s, hsf, hs⟩ := eventually_small_sets.1 h\n  let ⟨t, htf, htm, hts⟩ := is_measurably_generated.exists_measurable_subset hsf\n  ⟨t, htf, htm, hs t hts⟩\n#align eventually.exists_measurable_mem_of_small_sets eventually.exists_measurable_mem_of_small_sets\n\n",
 "exists_measurable_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n-- We follow the proof of the usual SB theorem in mathlib,\n-- the crux of which is finding a fixed point of this F.\n-- However, we must find this fixed point manually instead of invoking Knaster-Tarski\n-- in order to make sure it is measurable.\ntheorem eventually.exists_measurable_mem {f : filter α} [is_measurably_generated f] {p : α → Prop}\n    (h :\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" f (p x)) :\n    ∃ s ∈ f, measurable_set s ∧ ∀ x ∈ s, p x :=\n  is_measurably_generated.exists_measurable_subset h\n#align eventually.exists_measurable_mem eventually.exists_measurable_mem\n\n",
 "exists_measurable_extend":
 "theorem exists_measurable_extend (hf : measurable_embedding f) {g : α → γ} (hg : measurable g) (hne : β → nonempty γ) :\n    ∃ g' : β → γ, measurable g' ∧ g' ∘ f = g :=\n  ⟨extend f g fun x => classical.choice (hne x), hf.measurable_extend hg (measurable_const' fun _ _ => rfl),\n    funext fun x => hf.injective.extend_apply _ _ _⟩\n#align exists_measurable_extend exists_measurable_extend\n\n",
 "eval":
 "@[measurability]\ntheorem measurable.eval {a : δ} {g : α → ∀ a, π a} (hg : measurable g) : measurable fun x => g x a :=\n  (measurable_pi_apply a).comp hg\n#align measurable.eval measurable.eval\n\n",
 "dite":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\ntheorem measurable.dite [∀ x, decidable (x ∈ s)] {f : s → β} (hf : measurable f) {g : «expr ᶜ» s → β}\n    (hg : measurable g) (hs : measurable_set s) : measurable fun x => if hx : x ∈ s then f ⟨x, hx⟩ else g ⟨x, hx⟩ :=\n  measurable_of_restrict_of_restrict_compl hs (by simpa) (by simpa)\n#align measurable.dite measurable.dite\n\n",
 "comp":
 "theorem comp (hg : measurable_embedding g) (hf : measurable_embedding f) : measurable_embedding (g ∘ f) :=\n  ⟨hg.injective.comp hf.injective, hg.measurable.comp hf.measurable, fun s hs => by\n    rwa [← image_image, hg.measurable_set_image, hf.measurable_set_image]⟩\n#align comp comp\n\n",
 "comap_supr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n@[simp]\ntheorem comap_supr {m : ι → measurable_space α} :\n    («expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (m i)).comap g =\n      «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" ((m i).comap g) :=\n  (gc_comap_map g).l_supr\n#align comap_supr comap_supr\n\n",
 "comap_sup":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n@[simp]\ntheorem comap_sup : («expr ⊔ » m₁ m₂).comap g = «expr ⊔ » (m₁.comap g) (m₂.comap g) :=\n  (gc_comap_map g).l_sup\n#align comap_sup comap_sup\n\n",
 "comap_mono":
 "theorem comap_mono (h : m₁ ≤ m₂) : m₁.comap g ≤ m₂.comap g :=\n  (gc_comap_map g).monotone_l h\n#align comap_mono comap_mono\n\n",
 "comap_measurable":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_of -/\ntheorem comap_measurable {m : measurable_space β} (f : α → β) : (measurable_of (m.comap f)) f := fun s hs =>\n  ⟨s, hs, rfl⟩\n#align comap_measurable comap_measurable\n\n",
 "comap_map_le":
 "theorem comap_map_le : (m.map f).comap f ≤ m :=\n  (gc_comap_map f).l_u_le _\n#align comap_map_le comap_map_le\n\n",
 "comap_le_iff_le_map":
 "theorem comap_le_iff_le_map {f : α → β} : m'.comap f ≤ m ↔ m' ≤ m.map f :=\n  ⟨fun h s hs => h _ ⟨_, hs, rfl⟩, fun h s ⟨t, ht, HEq⟩ => HEq ▸ h _ ht⟩\n#align comap_le_iff_le_map comap_le_iff_le_map\n\n",
 "comap_id":
 "@[simp]\ntheorem comap_id : m.comap id = m :=\n  measurable_space.ext fun s => ⟨fun ⟨s', hs', h⟩ => h ▸ hs', fun h => ⟨s, h, rfl⟩⟩\n#align comap_id comap_id\n\n",
 "comap_generate_from":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem comap_generate_from {f : α → β} {s : set (set β)} :\n    (generate_from s).comap f = generate_from («expr '' » (preimage f) s) :=\n  le_antisymm\n    (comap_le_iff_le_map.2 <| generate_from_le fun t hts => generate_measurable.basic _ <| mem_image_of_mem _ <| hts)\n    (generate_from_le fun t ⟨u, hu, eq⟩ => eq ▸ ⟨u, generate_measurable.basic _ hu, rfl⟩)\n#align comap_generate_from comap_generate_from\n\n",
 "comap_eq_generate_from":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem comap_eq_generate_from (m : measurable_space β) (f : α → β) :\n    m.comap f = generate_from { t | ∃ s, measurable_set s ∧ «expr ⁻¹' » f s = t } := by\n  convert generate_from_measurable_set.symm\n#align comap_eq_generate_from comap_eq_generate_from\n\n",
 "comap_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n@[simp]\ntheorem comap_comp {f : β → α} {g : γ → β} : (m.comap f).comap g = m.comap (f ∘ g) :=\n  measurable_space.ext fun s =>\n    ⟨fun ⟨t, ⟨u, h, hu⟩, ht⟩ => ⟨u, h, ht ▸ hu ▸ rfl⟩, fun ⟨t, h, ht⟩ => ⟨«expr ⁻¹' » f t, ⟨_, h, rfl⟩, ht⟩⟩\n#align comap_comp comap_comp\n\n",
 "comap_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem comap_bot : («expr⊥» : measurable_space α).comap g = «expr⊥» :=\n  (gc_comap_map g).l_bot\n#align comap_bot comap_bot\n\n",
 "coe_union":
 "@[simp]\ntheorem coe_union (s t : subtype (measurable_set : set α → Prop)) : ↑(s ∪ t) = (s ∪ t : set α) :=\n  rfl\n#align coe_union coe_union\n\n",
 "coe_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem coe_top : ↑(«expr⊤» : subtype (measurable_set : set α → Prop)) = («expr⊤» : set α) :=\n  rfl\n#align coe_top coe_top\n\n",
 "coe_to_equiv_symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ᵐ » -/\n@[simp]\ntheorem coe_to_equiv_symm (e : «expr ≃ᵐ » α β) : (e.to_equiv.symm : β → α) = e.symm :=\n  rfl\n#align coe_to_equiv_symm coe_to_equiv_symm\n\n",
 "coe_to_equiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ᵐ » -/\n@[simp]\ntheorem coe_to_equiv (e : «expr ≃ᵐ » α β) : (e.to_equiv : α → β) = e :=\n  rfl\n#align coe_to_equiv coe_to_equiv\n\n",
 "coe_sdiff":
 "@[simp]\ntheorem coe_sdiff (s t : subtype (measurable_set : set α → Prop)) : ↑(s \\ t) = (s \\ t : set α) :=\n  rfl\n#align coe_sdiff coe_sdiff\n\n",
 "coe_mk":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ᵐ » -/\n@[simp]\ntheorem coe_mk (e : «expr ≃ » α β) (h1 : measurable e) (h2 : measurable e.symm) :\n    ((⟨e, h1, h2⟩ : «expr ≃ᵐ » α β) : α → β) = e :=\n  rfl\n#align coe_mk coe_mk\n\n",
 "coe_inter":
 "@[simp]\ntheorem coe_inter (s t : subtype (measurable_set : set α → Prop)) : ↑(s ∩ t) = (s ∩ t : set α) :=\n  rfl\n#align coe_inter coe_inter\n\n",
 "coe_insert":
 "@[simp]\ntheorem coe_insert [measurable_singleton_class α] (a : α) (s : subtype (measurable_set : set α → Prop)) :\n    ↑(has_insert.insert a s) = (has_insert.insert a s : set α) :=\n  rfl\n#align coe_insert coe_insert\n\n",
 "coe_empty":
 "@[simp]\ntheorem coe_empty : ↑(∅ : subtype (measurable_set : set α → Prop)) = (∅ : set α) :=\n  rfl\n#align coe_empty coe_empty\n\n",
 "coe_compl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n@[simp]\ntheorem coe_compl (s : subtype (measurable_set : set α → Prop)) : ↑(«expr ᶜ» s) = («expr ᶜ» s : set α) :=\n  rfl\n#align coe_compl coe_compl\n\n",
 "coe_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem coe_bot : ↑(«expr⊥» : subtype (measurable_set : set α → Prop)) = («expr⊥» : set α) :=\n  rfl\n#align coe_bot coe_bot\n\n",
 "bijective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ᵐ » -/\nprotected theorem bijective (e : «expr ≃ᵐ » α β) : bijective e :=\n  e.to_equiv.bijective\n#align bijective bijective\n\n",
 "apply_symm_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ᵐ » -/\n@[simp]\ntheorem apply_symm_apply (e : «expr ≃ᵐ » α β) (y : β) : e (e.symm y) = y :=\n  e.right_inv y\n#align apply_symm_apply apply_symm_apply\n\n"}