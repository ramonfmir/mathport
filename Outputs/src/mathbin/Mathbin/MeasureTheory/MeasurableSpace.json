{"univ_pi":
 "#print MeasurableSet.univ_pi /-\ntheorem MeasurableSet.univ_pi [Countable δ] {t : ∀ i : δ, Set (π i)} (ht : ∀ i, MeasurableSet (t i)) :\n    MeasurableSet (pi univ t) :=\n  MeasurableSet.pi (to_countable _) fun i _ => ht i\n#align measurable_set.univ_pi MeasurableSet.univ_pi\n-/\n\n",
 "to_equiv_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ᵐ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\ntheorem to_equiv_injective : injective (to_equiv : «expr ≃ᵐ » α β → «expr ≃ » α β) :=\n  by\n  rintro ⟨e₁, _, _⟩ ⟨e₂, _, _⟩ (rfl : e₁ = e₂)\n  rfl\n#align to_equiv_injective to_equiv_injective\n\n",
 "tProd":
 "#print MeasurableSet.tProd /-\ntheorem MeasurableSet.tProd (l : List δ) {s : ∀ i, Set (π i)} (hs : ∀ i, MeasurableSet (s i)) :\n    MeasurableSet (Set.tprod l s) := by\n  induction' l with i l ih\n  exact MeasurableSet.univ\n  exact (hs i).prod ih\n#align measurable_set.tprod MeasurableSet.tProd\n-/\n\n",
 "symm_trans_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ᵐ » -/\n@[simp]\ntheorem symm_trans_self (e : «expr ≃ᵐ » α β) : e.symm.trans e = refl β :=\n  ext e.self_comp_symm\n#align symm_trans_self symm_trans_self\n\n",
 "symm_refl":
 "@[simp]\ntheorem symm_refl (α : Type _) [MeasurableSpace α] : (refl α).symm = refl α :=\n  rfl\n#align symm_refl symm_refl\n\n",
 "symm_preimage_preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ᵐ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n@[simp]\ntheorem symm_preimage_preimage (e : «expr ≃ᵐ » α β) (s : Set β) : «expr ⁻¹' » e.symm («expr ⁻¹' » e s) = s :=\n  e.to_equiv.symm_preimage_preimage s\n#align symm_preimage_preimage symm_preimage_preimage\n\n",
 "symm_mk":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ᵐ » -/\n@[simp]\ntheorem symm_mk (e : «expr ≃ » α β) (h1 : Measurable e) (h2 : Measurable e.symm) :\n    (⟨e, h1, h2⟩ : «expr ≃ᵐ » α β).symm = ⟨e.symm, h2, h1⟩ :=\n  rfl\n#align symm_mk symm_mk\n\n",
 "symm_comp_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ᵐ » -/\n@[simp]\ntheorem symm_comp_self (e : «expr ≃ᵐ » α β) : e.symm ∘ e = id :=\n  funext e.left_inv\n#align symm_comp_self symm_comp_self\n\n",
 "symm_apply_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ᵐ » -/\n@[simp]\ntheorem symm_apply_apply (e : «expr ≃ᵐ » α β) (x : α) : e.symm (e x) = x :=\n  e.left_inv x\n#align symm_apply_apply symm_apply_apply\n\n",
 "surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ᵐ » -/\nprotected theorem surjective (e : «expr ≃ᵐ » α β) : surjective e :=\n  e.to_equiv.surjective\n#align surjective surjective\n\n",
 "sumElim":
 "#print Measurable.sumElim /-\n@[measurability]\ntheorem Measurable.sumElim {mγ : MeasurableSpace γ} {f : α → γ} {g : β → γ} (hf : Measurable f) (hg : Measurable g) :\n    Measurable (Sum.elim f g) :=\n  measurable_sum hf hg\n#align measurable.sum_elim Measurable.sumElim\n-/\n\n",
 "subtype_mk":
 "#print Measurable.subtype_mk /-\n@[measurability]\ntheorem Measurable.subtype_mk {p : β → Prop} {f : α → β} (hf : Measurable f) {h : ∀ x, p (f x)} :\n    Measurable fun x => (⟨f x, h x⟩ : Subtype p) := fun t ⟨s, hs⟩ =>\n  hs.2 ▸ by simp only [← preimage_comp, (· ∘ ·), Subtype.coe_mk, hf hs.1]\n#align measurable.subtype_mk Measurable.subtype_mk\n-/\n\n",
 "subtype_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n#print MeasurableSet.subtype_image /-\ntheorem MeasurableSet.subtype_image {s : Set α} {t : Set s} (hs : MeasurableSet s) :\n    MeasurableSet t → MeasurableSet («expr '' » (coe : s → α) t)\n  | ⟨u, (hu : MeasurableSet u), (Eq : «expr ⁻¹' » coe u = t)⟩ =>\n    by\n    rw [← Eq, Subtype.image_preimage_coe]\n    exact hu.inter hs\n#align measurable_set.subtype_image MeasurableSet.subtype_image\n-/\n\n",
 "subtype_coe":
 "theorem subtype_coe {s : Set α} (hs : MeasurableSet s) : MeasurableEmbedding (coe : s → α) :=\n  { injective := Subtype.coe_injective\n    measurable := measurable_subtype_coe\n    measurable_set_image' := fun _ => MeasurableSet.subtype_image hs }\n#align subtype_coe subtype_coe\n\n",
 "snd":
 "#print Measurable.snd /-\ntheorem Measurable.snd {f : α → β × γ} (hf : Measurable f) : Measurable fun a : α => (f a).2 :=\n  measurable_snd.comp hf\n#align measurable.snd Measurable.snd\n-/\n\n",
 "self_trans_symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ᵐ » -/\n@[simp]\ntheorem self_trans_symm (e : «expr ≃ᵐ » α β) : e.trans e.symm = refl α :=\n  ext e.symm_comp_self\n#align self_trans_symm self_trans_symm\n\n",
 "self_comp_symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ᵐ » -/\n@[simp]\ntheorem self_comp_symm (e : «expr ≃ᵐ » α β) : e ∘ e.symm = id :=\n  funext e.right_inv\n#align self_comp_symm self_comp_symm\n\n",
 "prod_mk":
 "#print Measurable.prod_mk /-\ntheorem Measurable.prod_mk {β γ} {mβ : MeasurableSpace β} {mγ : MeasurableSpace γ} {f : α → β} {g : α → γ}\n    (hf : Measurable f) (hg : Measurable g) : Measurable fun a : α => (f a, g a) :=\n  Measurable.prod hf hg\n#align measurable.prod_mk Measurable.prod_mk\n-/\n\n",
 "prod_map":
 "#print Measurable.prod_map /-\ntheorem Measurable.prod_map [MeasurableSpace δ] {f : α → β} {g : γ → δ} (hf : Measurable f) (hg : Measurable g) :\n    Measurable (prod.map f g) :=\n  (hf.comp measurable_fst).prod_mk (hg.comp measurable_snd)\n#align measurable.prod_map Measurable.prod_map\n-/\n\n",
 "prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n#print MeasurableSet.prod /-\n@[measurability]\ntheorem MeasurableSet.prod {s : Set α} {t : Set β} (hs : MeasurableSet s) (ht : MeasurableSet t) :\n    MeasurableSet (lower_set.prod s t) :=\n  MeasurableSet.inter (measurable_fst hs) (measurable_snd ht)\n#align measurable_set.prod MeasurableSet.prod\n-/\n\n",
 "principal_is_measurably_generated_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\ntheorem principal_is_measurably_generated_iff {s : Set α} :\n    IsMeasurablyGenerated ((filter.principal) s) ↔ MeasurableSet s :=\n  by\n  refine' ⟨_, fun hs => ⟨fun t ht => ⟨s, mem_principal_self s, hs, ht⟩⟩⟩\n  rintro ⟨hs⟩\n  rcases hs (mem_principal_self s) with ⟨t, ht, htm, hts⟩\n  have : t = s := subset.antisymm hts ht\n  rwa [← this]\n#align principal_is_measurably_generated_iff principal_is_measurably_generated_iff\n\n",
 "piecewise":
 "#print Measurable.piecewise /-\n@[measurability]\ntheorem Measurable.piecewise {_ : DecidablePred (· ∈ s)} (hs : MeasurableSet s) (hf : Measurable f)\n    (hg : Measurable g) : Measurable (piecewise s f g) :=\n  by\n  intro t ht\n  rw [piecewise_preimage]\n  exact hs.ite (hf ht) (hg ht)\n#align measurable.piecewise Measurable.piecewise\n-/\n\n",
 "pi":
 "#print MeasurableSet.pi /-\n/- Even though we cannot use projection notation, we still keep a dot to be consistent with similar\n  lemmas, like `measurable_set.prod`. -/\n@[measurability]\ntheorem MeasurableSet.pi {s : Set δ} {t : ∀ i : δ, Set (π i)} (hs : s.countable) (ht : ∀ i ∈ s, MeasurableSet (t i)) :\n    MeasurableSet (s.pi t) := by\n  rw [pi_def]\n  exact MeasurableSet.binterᵢ hs fun i hi => measurable_pi_apply _ (ht i hi)\n#align measurable_set.pi MeasurableSet.pi\n-/\n\n",
 "of_uncurry_right":
 "#print Measurable.of_uncurry_right /-\ntheorem Measurable.of_uncurry_right {f : α → β → γ} (hf : Measurable (uncurry f)) {y : β} : Measurable fun x => f x y :=\n  hf.comp measurable_prod_mk_right\n#align measurable.of_uncurry_right Measurable.of_uncurry_right\n-/\n\n",
 "of_uncurry_left":
 "#print Measurable.of_uncurry_left /-\ntheorem Measurable.of_uncurry_left {f : α → β → γ} (hf : Measurable (uncurry f)) {x : α} : Measurable (f x) :=\n  hf.comp measurable_prod_mk_left\n#align measurable.of_uncurry_left Measurable.of_uncurry_left\n-/\n\n",
 "of_measurable_inverse_on_range":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ᵐ » -/\ntheorem of_measurable_inverse_on_range {g : range f → α} (hf₁ : Measurable f) (hf₂ : MeasurableSet (range f))\n    (hg : Measurable g) (H : left_inverse g (rangeFactorization f)) : MeasurableEmbedding f :=\n  by\n  set e : «expr ≃ᵐ » α (range f) :=\n    ⟨⟨range_factorization f, g, H, H.right_inverse_of_surjective surjective_onto_range⟩, hf₁.subtype_mk, hg⟩\n  exact (MeasurableEmbedding.subtype_coe hf₂).comp e.measurable_embedding\n#align of_measurable_inverse_on_range of_measurable_inverse_on_range\n\n",
 "of_measurable_inverse":
 "theorem of_measurable_inverse (hf₁ : Measurable f) (hf₂ : MeasurableSet (range f)) (hg : Measurable g)\n    (H : left_inverse g f) : MeasurableEmbedding f :=\n  of_measurable_inverse_on_range hf₁ hf₂ (hg.comp measurable_subtype_coe) H\n#align of_measurable_inverse of_measurable_inverse\n\n",
 "monotone_map":
 "theorem monotone_map : Monotone (MeasurableSpace.map f) := fun a b h => map_mono h\n#align monotone_map monotone_map\n\n",
 "monotone_comap":
 "theorem monotone_comap : Monotone (MeasurableSpace.comap g) := fun a b h => comap_mono h\n#align monotone_comap monotone_comap\n\n",
 "mono":
 "#print Measurable.mono /-\ntheorem Measurable.mono {ma ma' : MeasurableSpace α} {mb mb' : MeasurableSpace β} {f : α → β}\n    (hf : @Measurable α β ma mb f) (ha : ma ≤ ma') (hb : mb' ≤ mb) : @Measurable α β ma' mb' f := fun t ht =>\n  ha _ <| hf <| hb _ ht\n#align measurable.mono Measurable.mono\n-/\n\n",
 "mem_coe":
 "@[simp]\ntheorem mem_coe (a : α) (s : Subtype (MeasurableSet : Set α → Prop)) : a ∈ (s : Set α) ↔ a ∈ s :=\n  iff.rfl\n#align mem_coe mem_coe\n\n",
 "measurable_update":
 "#print measurable_update /-\n/-- The function `update f a : π a → Π a, π a` is always measurable.\n  This doesn't require `f` to be measurable.\n  This should not be confused with the statement that `update f a x` is measurable. -/\n@[measurability]\ntheorem measurable_update (f : ∀ a : δ, π a) {a : δ} [DecidableEq δ] : Measurable (update f a) :=\n  by\n  apply measurable_pi_lambda\n  intro x; by_cases hx : x = a\n  · cases hx\n    convert measurable_id\n    ext\n    simp\n  simp_rw [update_noteq hx]; apply measurable_const\n#align measurable_update measurable_update\n-/\n\n",
 "measurable_unit":
 "#print measurable_unit /-\n@[measurability]\ntheorem measurable_unit [MeasurableSpace α] (f : Unit → α) : Measurable f :=\n  measurable_from_top\n#align measurable_unit measurable_unit\n-/\n\n",
 "measurable_to_nat":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n#print measurable_to_nat /-\ntheorem measurable_to_nat {f : α → ℕ} : (∀ y, MeasurableSet («expr ⁻¹' » f {f y})) → Measurable f :=\n  measurable_to_countable\n#align measurable_to_nat measurable_to_nat\n-/\n\n",
 "measurable_to_countable'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n#print measurable_to_countable' /-\ntheorem measurable_to_countable' [MeasurableSpace α] [Countable α] [MeasurableSpace β] {f : β → α}\n    (h : ∀ x, MeasurableSet («expr ⁻¹' » f {x})) : Measurable f :=\n  measurable_to_countable fun y => h (f y)\n#align measurable_to_countable' measurable_to_countable'\n-/\n\n",
 "measurable_to_countable":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n#print measurable_to_countable /-\n-- this also works for `unit`\ntheorem measurable_to_countable [MeasurableSpace α] [Countable α] [MeasurableSpace β] {f : β → α}\n    (h : ∀ y, MeasurableSet («expr ⁻¹' » f {f y})) : Measurable f :=\n  by\n  intro s hs\n  rw [← bUnion_preimage_singleton]\n  refine' MeasurableSet.unionᵢ fun y => MeasurableSet.unionᵢ fun hy => _\n  by_cases hyf : y ∈ range f\n  · rcases hyf with ⟨y, rfl⟩\n    apply h\n  · simp only [preimage_singleton_eq_empty.2 hyf, MeasurableSet.empty]\n#align measurable_to_countable measurable_to_countable\n-/\n\n",
 "measurable_to_bool":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n#print measurable_to_bool /-\ntheorem measurable_to_bool {f : α → Bool} (h : MeasurableSet («expr ⁻¹' » f {true})) : Measurable f :=\n  by\n  apply measurable_to_countable'\n  rintro (- | -)\n  · convert h.compl\n    rw [← preimage_compl, Bool.compl_singleton, Bool.not_true]\n  exact h\n#align measurable_to_bool measurable_to_bool\n-/\n\n",
 "measurable_tProd_mk":
 "#print measurable_tProd_mk /-\ntheorem measurable_tProd_mk (l : List δ) : Measurable (@TProd.mk δ π l) :=\n  by\n  induction' l with i l ih\n  · exact measurable_const\n  · exact (measurable_pi_apply i).prod_mk ih\n#align measurable_tprod_mk measurable_tProd_mk\n-/\n\n",
 "measurable_tProd_elim'":
 "#print measurable_tProd_elim' /-\ntheorem measurable_tProd_elim' [DecidableEq δ] {l : List δ} (h : ∀ i, i ∈ l) :\n    Measurable (TProd.elim' h : TProd π l → ∀ i, π i) :=\n  measurable_pi_lambda _ fun i => measurable_tProd_elim (h i)\n#align measurable_tprod_elim' measurable_tProd_elim'\n-/\n\n",
 "measurable_tProd_elim":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `sym.cons' -/\n#print measurable_tProd_elim /-\ntheorem measurable_tProd_elim [DecidableEq δ] :\n    ∀ {l : List δ} {i : δ} (hi : i ∈ l), Measurable fun v : TProd π l => v.elim hi\n  | sym.cons' i is, j, hj => by\n    by_cases hji : j = i\n    · subst hji\n      simp [measurable_fst]\n    · rw [funext <| tprod.elim_of_ne _ hji]\n      exact (measurable_tProd_elim (hj.resolve_left hji)).comp measurable_snd\n#align measurable_tprod_elim measurable_tProd_elim\n-/\n\n",
 "measurable_swap_iff":
 "#print measurable_swap_iff /-\ntheorem measurable_swap_iff {mγ : MeasurableSpace γ} {f : α × β → γ} : Measurable (f ∘ Prod.swap) ↔ Measurable f :=\n  ⟨fun hf => by\n    convert hf.comp measurable_swap\n    ext ⟨x, y⟩\n    rfl, fun hf => hf.comp measurable_swap⟩\n#align measurable_swap_iff measurable_swap_iff\n-/\n\n",
 "measurable_swap":
 "#print measurable_swap /-\n@[measurability]\ntheorem measurable_swap : Measurable (Prod.swap : α × β → β × α) :=\n  Measurable.prod measurable_snd measurable_fst\n#align measurable_swap measurable_swap\n-/\n\n",
 "measurable_sum":
 "#print measurable_sum /-\ntheorem measurable_sum {mγ : MeasurableSpace γ} {f : Sum α β → γ} (hl : Measurable (f ∘ Sum.inl))\n    (hr : Measurable (f ∘ Sum.inr)) : Measurable f :=\n  Measurable.of_comap_le <|\n    le_inf (MeasurableSpace.comap_le_iff_le_map.2 <| hl) (MeasurableSpace.comap_le_iff_le_map.2 <| hr)\n#align measurable_sum measurable_sum\n-/\n\n",
 "measurable_subtype_coe":
 "#print measurable_subtype_coe /-\n@[measurability]\ntheorem measurable_subtype_coe {p : α → Prop} : Measurable (coe : Subtype p → α) :=\n  MeasurableSpace.le_map_comap\n#align measurable_subtype_coe measurable_subtype_coe\n-/\n\n",
 "measurable_snd":
 "#print measurable_snd /-\n@[measurability]\ntheorem measurable_snd {ma : MeasurableSpace α} {mb : MeasurableSpace β} : Measurable (Prod.snd : α × β → β) :=\n  Measurable.of_comap_le le_sup_right\n#align measurable_snd measurable_snd\n-/\n\n",
 "measurable_set_range":
 "theorem measurable_set_range (hf : MeasurableEmbedding f) : MeasurableSet (range f) :=\n  by\n  rw [← image_univ]\n  exact hf.measurable_set_image' MeasurableSet.univ\n#align measurable_set_range measurable_set_range\n\n",
 "measurable_set_limsup":
 "@[measurability]\ntheorem measurable_set_limsup {s : ℕ → Set α} (hs : ∀ n, MeasurableSet <| s n) :\n    MeasurableSet <| Filter.limsup s Filter.atTop :=\n  by\n  convert measurable_set_blimsup (fun n h => hs n : ∀ n, True → MeasurableSet (s n))\n  simp\n#align measurable_set_limsup measurable_set_limsup\n\n",
 "measurable_set_liminf":
 "@[measurability]\ntheorem measurable_set_liminf {s : ℕ → Set α} (hs : ∀ n, MeasurableSet <| s n) :\n    MeasurableSet <| Filter.liminf s Filter.atTop :=\n  by\n  convert measurable_set_bliminf (fun n h => hs n : ∀ n, True → MeasurableSet (s n))\n  simp\n#align measurable_set_liminf measurable_set_liminf\n\n",
 "measurable_set_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ᵐ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n@[simp]\ntheorem measurable_set_image (e : «expr ≃ᵐ » α β) {s : Set α} : MeasurableSet («expr '' » e s) ↔ MeasurableSet s := by\n  rw [image_eq_preimage, measurableSet_preimage]\n#align measurable_set_image measurable_set_image\n\n",
 "measurable_set_blimsup":
 "@[measurability]\ntheorem measurable_set_blimsup {s : ℕ → Set α} {p : ℕ → Prop} (h : ∀ n, p n → MeasurableSet (s n)) :\n    MeasurableSet <| Filter.blimsup s Filter.atTop p :=\n  by\n  simp only [Filter.blimsup_eq_infᵢ_bsupᵢ_of_nat, supr_eq_Union, infi_eq_Inter]\n  exact MeasurableSet.interᵢ fun n => MeasurableSet.unionᵢ fun m => MeasurableSet.unionᵢ fun hm => h m hm.1\n#align measurable_set_blimsup measurable_set_blimsup\n\n",
 "measurable_set_bliminf":
 "@[measurability]\ntheorem measurable_set_bliminf {s : ℕ → Set α} {p : ℕ → Prop} (h : ∀ n, p n → MeasurableSet (s n)) :\n    MeasurableSet <| Filter.bliminf s Filter.atTop p :=\n  by\n  simp only [Filter.bliminf_eq_supᵢ_binfᵢ_of_nat, infi_eq_Inter, supr_eq_Union]\n  exact MeasurableSet.unionᵢ fun n => MeasurableSet.interᵢ fun m => MeasurableSet.interᵢ fun hm => h m hm.1\n#align measurable_set_bliminf measurable_set_bliminf\n\n",
 "measurable_range_splitting":
 "theorem measurable_range_splitting (hf : MeasurableEmbedding f) : Measurable (rangeSplitting f) := fun s hs => by\n  rwa [preimage_range_splitting hf.injective, ← (subtype_coe hf.measurable_set_range).measurable_set_image, ←\n    image_comp, coe_comp_range_factorization, hf.measurable_set_image]\n#align measurable_range_splitting measurable_range_splitting\n\n",
 "measurable_quotient_mk''":
 "#print measurable_quotient_mk'' /-\n@[measurability]\ntheorem measurable_quotient_mk'' {s : setoid α} : Measurable (Quotient.mk'' : α → quotient s) := fun s => id\n#align measurable_quotient_mk' measurable_quotient_mk''\n-/\n\n",
 "measurable_quotient_mk'":
 "#print measurable_quotient_mk' /-\n@[measurability]\ntheorem measurable_quotient_mk' [s : setoid α] : Measurable (Quotient.mk' : α → quotient s) := fun s => id\n#align measurable_quotient_mk measurable_quotient_mk'\n-/\n\n",
 "measurable_quot_mk":
 "#print measurable_quot_mk /-\n@[measurability]\ntheorem measurable_quot_mk {r : α → α → Prop} : Measurable (Quot.mk r) := fun s => id\n#align measurable_quot_mk measurable_quot_mk\n-/\n\n",
 "measurable_prod_mk_right":
 "#print measurable_prod_mk_right /-\ntheorem measurable_prod_mk_right {y : β} : Measurable fun x : α => (x, y) :=\n  measurable_id.prod_mk measurable_const\n#align measurable_prod_mk_right measurable_prod_mk_right\n-/\n\n",
 "measurable_prod_mk_left":
 "#print measurable_prod_mk_left /-\ntheorem measurable_prod_mk_left {x : α} : Measurable (@prod.mk _ β x) :=\n  measurable_const.prod_mk measurable_id\n#align measurable_prod_mk_left measurable_prod_mk_left\n-/\n\n",
 "measurable_prod":
 "#print measurable_prod /-\ntheorem measurable_prod {f : α → β × γ} : Measurable f ↔ (Measurable fun a => (f a).1) ∧ Measurable fun a => (f a).2 :=\n  ⟨fun hf => ⟨measurable_fst.comp hf, measurable_snd.comp hf⟩, fun h => Measurable.prod h.1 h.2⟩\n#align measurable_prod measurable_prod\n-/\n\n",
 "measurable_pi_lambda":
 "#print measurable_pi_lambda /-\n@[measurability]\ntheorem measurable_pi_lambda (f : α → ∀ a, π a) (hf : ∀ a, Measurable fun c => f c a) : Measurable f :=\n  measurable_pi_iff.mpr hf\n#align measurable_pi_lambda measurable_pi_lambda\n-/\n\n",
 "measurable_pi_iff":
 "#print measurable_pi_iff /-\ntheorem measurable_pi_iff {g : α → ∀ a, π a} : Measurable g ↔ ∀ a, Measurable fun x => g x a := by\n  simp_rw [measurable_iff_comap_le, MeasurableSpace.pi, MeasurableSpace.comap_supᵢ, MeasurableSpace.comap_comp,\n    Function.comp, supᵢ_le_iff]\n#align measurable_pi_iff measurable_pi_iff\n-/\n\n",
 "measurable_pi_apply":
 "#print measurable_pi_apply /-\n@[measurability]\ntheorem measurable_pi_apply (a : δ) : Measurable fun f : ∀ a, π a => f a :=\n  Measurable.of_comap_le <| le_supᵢ _ a\n#align measurable_pi_apply measurable_pi_apply\n-/\n\n",
 "measurable_piEquivPiSubtypeProd_symm":
 "#print measurable_piEquivPiSubtypeProd_symm /-\n@[measurability]\ntheorem measurable_piEquivPiSubtypeProd_symm (p : δ → Prop) [DecidablePred p] :\n    Measurable (Equiv.piEquivPiSubtypeProd p π).symm :=\n  by\n  apply measurable_pi_iff.2 fun j => _\n  by_cases hj : p j\n  · simp only [hj, dif_pos, Equiv.piEquivPiSubtypeProd_symm_apply]\n    have : Measurable fun f : ∀ i : { x // p x }, π ↑i => f ⟨j, hj⟩ := measurable_pi_apply ⟨j, hj⟩\n    exact Measurable.comp this measurable_fst\n  · simp only [hj, Equiv.piEquivPiSubtypeProd_symm_apply, dif_neg, not_false_iff]\n    have : Measurable fun f : ∀ i : { x // ¬p x }, π ↑i => f ⟨j, hj⟩ := measurable_pi_apply ⟨j, hj⟩\n    exact Measurable.comp this measurable_snd\n#align measurable_pi_equiv_pi_subtype_prod_symm measurable_piEquivPiSubtypeProd_symm\n-/\n\n",
 "measurable_piEquivPiSubtypeProd":
 "#print measurable_piEquivPiSubtypeProd /-\n@[measurability]\ntheorem measurable_piEquivPiSubtypeProd (p : δ → Prop) [DecidablePred p] :\n    Measurable (Equiv.piEquivPiSubtypeProd p π) :=\n  by\n  refine' measurable_prod.2 _\n  constructor <;>\n    · apply measurable_pi_iff.2 fun j => _\n      simp only [pi_equiv_pi_subtype_prod_apply, measurable_pi_apply]\n#align measurable_pi_equiv_pi_subtype_prod measurable_piEquivPiSubtypeProd\n-/\n\n",
 "measurable_one":
 "#print measurable_one /-\n@[to_additive]\ntheorem measurable_one [One α] : Measurable (1 : β → α) :=\n  @measurable_const _ _ _ _ 1\n#align measurable_one measurable_one\n#align measurable_zero measurable_zero\n-/\n\n",
 "measurable_of_subsingleton_codomain":
 "#print measurable_of_subsingleton_codomain /-\n@[nontriviality, measurability]\ntheorem measurable_of_subsingleton_codomain [subsingleton β] (f : α → β) : Measurable f := fun s hs =>\n  Subsingleton.set_cases MeasurableSet.empty MeasurableSet.univ s\n#align measurable_of_subsingleton_codomain measurable_of_subsingleton_codomain\n-/\n\n",
 "measurable_of_restrict_of_restrict_compl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n#print measurable_of_restrict_of_restrict_compl /-\ntheorem measurable_of_restrict_of_restrict_compl {f : α → β} {s : Set α} (hs : MeasurableSet s)\n    (h₁ : Measurable (s.restrict f)) (h₂ : Measurable ((«expr ᶜ» s).restrict f)) : Measurable f :=\n  measurable_of_measurable_union_cover s («expr ᶜ» s) hs hs.compl (union_compl_self s).ge h₁ h₂\n#align measurable_of_restrict_of_restrict_compl measurable_of_restrict_of_restrict_compl\n-/\n\n",
 "measurable_of_measurable_union_cover":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n#print measurable_of_measurable_union_cover /-\ntheorem measurable_of_measurable_union_cover {f : α → β} (s t : Set α) (hs : MeasurableSet s) (ht : MeasurableSet t)\n    (h : univ ⊆ s ∪ t) (hc : Measurable fun a : s => f a) (hd : Measurable fun a : t => f a) : Measurable f :=\n  by\n  intro u hu\n  convert(hs.subtype_image (hc hu)).union (ht.subtype_image (hd hu))\n  change\n    «expr ⁻¹' » f u =\n      «expr '' » coe («expr ⁻¹' » coe («expr ⁻¹' » f u) : Set s) ∪\n        «expr '' » coe («expr ⁻¹' » coe («expr ⁻¹' » f u) : Set t)\n  rw [image_preimage_eq_inter_range, image_preimage_eq_inter_range, Subtype.range_coe, Subtype.range_coe, ←\n    inter_distrib_left, univ_subset_iff.1 h, inter_univ]\n#align measurable_of_measurable_union_cover measurable_of_measurable_union_cover\n-/\n\n",
 "measurable_of_measurable_on_compl_singleton":
 "#print measurable_of_measurable_on_compl_singleton /-\ntheorem measurable_of_measurable_on_compl_singleton [MeasurableSingletonClass α] {f : α → β} (a : α)\n    (hf : Measurable ({ x | x ≠ a }.restrict f)) : Measurable f :=\n  measurable_of_measurable_on_compl_finite {a} (finite_singleton a) hf\n#align measurable_of_measurable_on_compl_singleton measurable_of_measurable_on_compl_singleton\n-/\n\n",
 "measurable_of_measurable_on_compl_finite":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n#print measurable_of_measurable_on_compl_finite /-\ntheorem measurable_of_measurable_on_compl_finite [MeasurableSingletonClass α] {f : α → β} (s : Set α) (hs : s.finite)\n    (hf : Measurable ((«expr ᶜ» s).restrict f)) : Measurable f :=\n  letI : Fintype s := finite.fintype hs\n  measurable_of_restrict_of_restrict_compl hs.measurable_set (measurable_of_finite _) hf\n#align measurable_of_measurable_on_compl_finite measurable_of_measurable_on_compl_finite\n-/\n\n",
 "measurable_of_finite":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n#print measurable_of_finite /-\ntheorem measurable_of_finite [Finite α] [MeasurableSingletonClass α] (f : α → β) : Measurable f := fun s hs =>\n  («expr ⁻¹' » f s).to_finite.measurable_set\n#align measurable_of_finite measurable_of_finite\n-/\n\n",
 "measurable_of_empty_codomain":
 "#print measurable_of_empty_codomain /-\ntheorem measurable_of_empty_codomain [IsEmpty β] (f : α → β) : Measurable f :=\n  haveI := Function.isEmpty f\n  measurable_of_empty f\n#align measurable_of_empty_codomain measurable_of_empty_codomain\n-/\n\n",
 "measurable_of_empty":
 "#print measurable_of_empty /-\ntheorem measurable_of_empty [IsEmpty α] (f : α → β) : Measurable f :=\n  Subsingleton.measurable\n#align measurable_of_empty measurable_of_empty\n-/\n\n",
 "measurable_of_countable_ne":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n#print Measurable.measurable_of_countable_ne /-\n/-- If a function coincides with a measurable function outside of a countable set, it is\nmeasurable. -/\ntheorem Measurable.measurable_of_countable_ne [MeasurableSingletonClass α] (hf : Measurable f)\n    (h : Set.Countable { x | f x ≠ g x }) : Measurable g :=\n  by\n  intro t ht\n  have : «expr ⁻¹' » g t = «expr ⁻¹' » g t ∩ «expr ᶜ» { x | f x = g x } ∪ «expr ⁻¹' » g t ∩ { x | f x = g x } := by\n    simp [← inter_union_distrib_left]\n  rw [this]\n  apply MeasurableSet.union (h.mono (inter_subset_right _ _)).measurable_set\n  have : «expr ⁻¹' » g t ∩ { x : α | f x = g x } = «expr ⁻¹' » f t ∩ { x : α | f x = g x } :=\n    by\n    ext x\n    simp (config := { contextual := true })\n  rw [this]\n  exact (hf ht).inter h.measurable_set.of_compl\n#align measurable.measurable_of_countable_ne Measurable.measurable_of_countable_ne\n-/\n\n",
 "measurable_of_countable":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n#print measurable_of_countable /-\ntheorem measurable_of_countable [Countable α] [MeasurableSingletonClass α] (f : α → β) : Measurable f := fun s hs =>\n  («expr ⁻¹' » f s).to_countable.measurable_set\n#align measurable_of_countable measurable_of_countable\n-/\n\n",
 "measurable_natCast":
 "#print measurable_natCast /-\n@[measurability]\ntheorem measurable_natCast [NatCast α] (n : ℕ) : Measurable (n : β → α) :=\n  @measurable_const α _ _ _ n\n#align measurable_nat_cast measurable_natCast\n-/\n\n",
 "measurable_intCast":
 "#print measurable_intCast /-\n@[measurability]\ntheorem measurable_intCast [IntCast α] (n : ℤ) : Measurable (n : β → α) :=\n  @measurable_const α _ _ _ n\n#align measurable_int_cast measurable_intCast\n-/\n\n",
 "measurable_inr":
 "#print measurable_inr /-\n@[measurability]\ntheorem measurable_inr [MeasurableSpace α] [MeasurableSpace β] : Measurable (@Sum.inr α β) :=\n  Measurable.of_le_map inf_le_right\n#align measurable_inr measurable_inr\n-/\n\n",
 "measurable_inl":
 "#print measurable_inl /-\n@[measurability]\ntheorem measurable_inl [MeasurableSpace α] [MeasurableSpace β] : Measurable (@Sum.inl α β) :=\n  Measurable.of_le_map inf_le_left\n#align measurable_inl measurable_inl\n-/\n\n",
 "measurable_injection_nat_bool_of_countably_generated":
 "-- We follow the proof of the usual SB theorem in mathlib,\n-- the crux of which is finding a fixed point of this F.\n-- However, we must find this fixed point manually instead of invoking Knaster-Tarski\n-- in order to make sure it is measurable.\n/-- If a measurable space is countably generated, it admits a measurable injection\ninto the Cantor space `ℕ → bool` (equipped with the product sigma algebra). -/\ntheorem measurable_injection_nat_bool_of_countably_generated [MeasurableSpace α] [h : CountablyGenerated α]\n    [MeasurableSingletonClass α] : ∃ f : α → ℕ → Bool, Measurable f ∧ function.injective f :=\n  by\n  obtain ⟨b, bct, hb⟩ := h.is_countably_generated\n  obtain ⟨e, he⟩ := Set.Countable.exists_eq_range (bct.insert ∅) (insert_nonempty _ _)\n  rw [← generate_from_insert_empty, he] at hb\n  refine' ⟨fun x n => to_bool (x ∈ e n), _, _⟩\n  · rw [measurable_pi_iff]\n    intro n\n    apply measurable_to_bool\n    simp only [preimage, mem_singleton_iff, Bool.decide_iff, set_of_mem_eq]\n    rw [hb]\n    apply measurable_set_generate_from\n    use n\n  intro x y hxy\n  have : ∀ s : Set α, MeasurableSet s → (x ∈ s ↔ y ∈ s) := fun s =>\n    by\n    rw [hb]\n    apply generate_from_induction\n    · rintro - ⟨n, rfl⟩\n      rw [← decide_eq_decide]\n      rw [funext_iff] at hxy\n      exact hxy n\n    · tauto\n    · intro t\n      tauto\n    intro t ht\n    simp_rw [mem_Union, ht]\n  specialize this {y} measurableSet_eq\n  simpa only [mem_singleton, iff_true_iff]\n#align measurable_injection_nat_bool_of_countably_generated measurable_injection_nat_bool_of_countably_generated\n\n",
 "measurable_iff_le_map":
 "#print measurable_iff_le_map /-\ntheorem measurable_iff_le_map {m₁ : MeasurableSpace α} {m₂ : MeasurableSpace β} {f : α → β} :\n    Measurable f ↔ m₂ ≤ m₁.map f :=\n  iff.rfl\n#align measurable_iff_le_map measurable_iff_le_map\n-/\n\n",
 "measurable_iff_comap_le":
 "#print measurable_iff_comap_le /-\ntheorem measurable_iff_comap_le {m₁ : MeasurableSpace α} {m₂ : MeasurableSpace β} {f : α → β} :\n    Measurable f ↔ m₂.comap f ≤ m₁ :=\n  comap_le_iff_le_map.symm\n#align measurable_iff_comap_le measurable_iff_comap_le\n-/\n\n",
 "measurable_generateFrom":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n#print measurable_generateFrom /-\ntheorem measurable_generateFrom [MeasurableSpace α] {s : Set (Set β)} {f : α → β}\n    (h : ∀ t ∈ s, MeasurableSet («expr ⁻¹' » f t)) : @Measurable _ _ _ (generateFrom s) f :=\n  Measurable.of_le_map <| generateFrom_le h\n#align measurable_generate_from measurable_generateFrom\n-/\n\n",
 "measurable_fst":
 "#print measurable_fst /-\n@[measurability]\ntheorem measurable_fst {ma : MeasurableSpace α} {mb : MeasurableSpace β} : Measurable (Prod.fst : α × β → α) :=\n  Measurable.of_comap_le le_sup_left\n#align measurable_fst measurable_fst\n-/\n\n",
 "measurable_from_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_of -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n#print measurable_from_top /-\n@[measurability]\ntheorem measurable_from_top [MeasurableSpace β] {f : α → β} : (measurable_of («expr⊤»)) f := fun s hs => trivial\n#align measurable_from_top measurable_from_top\n-/\n\n",
 "measurable_from_quotient":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n#print QuotientGroup.measurable_from_quotient /-\n@[to_additive]\ntheorem QuotientGroup.measurable_from_quotient {G} [Group G] [MeasurableSpace G] {S : Subgroup G}\n    {f : «expr ⧸ » G S → α} : Measurable f ↔ Measurable (f ∘ (coe : G → «expr ⧸ » G S)) :=\n  measurable_from_quotient\n#align quotient_group.measurable_from_quotient QuotientGroup.measurable_from_quotient\n#align quotient_add_group.measurable_from_quotient QuotientAddGroup.measurable_from_quotient\n-/\n\n",
 "measurable_from_prod_countable":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n#print measurable_from_prod_countable /-\ntheorem measurable_from_prod_countable [Countable β] [MeasurableSingletonClass β] {mγ : MeasurableSpace γ}\n    {f : α × β → γ} (hf : ∀ y, Measurable fun x => f (x, y)) : Measurable f :=\n  by\n  intro s hs\n  have :\n    «expr ⁻¹' » f s =\n      «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n        (lower_set.prod («expr ⁻¹' » (fun x => f (x, y)) s) ({y} : Set β)) :=\n    by\n    ext1 ⟨x, y⟩\n    simp [and_assoc', and_left_comm]\n  rw [this]\n  exact MeasurableSet.unionᵢ fun y => (hf y hs).prod (measurable_set_singleton y)\n#align measurable_from_prod_countable measurable_from_prod_countable\n-/\n\n",
 "measurable_from_nat":
 "#print measurable_from_nat /-\n@[measurability]\ntheorem measurable_from_nat {f : ℕ → α} : Measurable f :=\n  measurable_from_top\n#align measurable_from_nat measurable_from_nat\n-/\n\n",
 "measurable_findGreatest'":
 "#print measurable_findGreatest' /-\ntheorem measurable_findGreatest' {p : α → ℕ → Prop} [∀ x, DecidablePred (p x)] {N : ℕ}\n    (hN : ∀ k ≤ N, MeasurableSet { x | Nat.findGreatest (p x) N = k }) : Measurable fun x => Nat.findGreatest (p x) N :=\n  measurable_to_nat fun x => hN _ N.find_greatest_le\n#align measurable_find_greatest' measurable_findGreatest'\n-/\n\n",
 "measurable_findGreatest":
 "#print measurable_findGreatest /-\ntheorem measurable_findGreatest {p : α → ℕ → Prop} [∀ x, DecidablePred (p x)] {N}\n    (hN : ∀ k ≤ N, MeasurableSet { x | p x k }) : Measurable fun x => Nat.findGreatest (p x) N :=\n  by\n  refine' measurable_findGreatest' fun k hk => _\n  simp only [Nat.findGreatest_eq_iff, set_of_and, set_of_forall, ← compl_set_of]\n  repeat'\n    apply_rules [MeasurableSet.inter, MeasurableSet.const, MeasurableSet.interᵢ, MeasurableSet.compl, hN] <;> try intros\n#align measurable_find_greatest measurable_findGreatest\n-/\n\n",
 "measurable_find":
 "#print measurable_find /-\ntheorem measurable_find {p : α → ℕ → Prop} [∀ x, DecidablePred (p x)] (hp : ∀ x, ∃ N, p x N)\n    (hm : ∀ k, MeasurableSet { x | p x k }) : Measurable fun x => nat.find (hp x) :=\n  by\n  refine' measurable_to_nat fun x => _\n  rw [preimage_find_eq_disjointed]\n  exact MeasurableSet.disjointed hm _\n#align measurable_find measurable_find\n-/\n\n",
 "measurable_extend":
 "theorem measurable_extend (hf : MeasurableEmbedding f) {g : α → γ} {g' : β → γ} (hg : Measurable g)\n    (hg' : Measurable g') : Measurable (extend f g g') :=\n  by\n  refine' measurable_of_restrict_of_restrict_compl hf.measurable_set_range _ _\n  · rw [restrict_extend_range]\n    simpa only [range_splitting] using hg.comp hf.measurable_range_splitting\n  · rw [restrict_extend_compl_range]\n    exact hg'.comp measurable_subtype_coe\n#align measurable_extend measurable_extend\n\n",
 "measurable_const'":
 "#print measurable_const' /-\n/-- A version of `measurable_const` that assumes `f x = f y` for all `x, y`. This version works\nfor functions between empty types. -/\ntheorem measurable_const' {f : β → α} (hf : ∀ x y, f x = f y) : Measurable f :=\n  by\n  cases isEmpty_or_nonempty β\n  · exact measurable_of_empty f\n  · convert measurable_const\n    exact funext fun x => hf x h.some\n#align measurable_const' measurable_const'\n-/\n\n",
 "measurable_comp_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ᵐ » -/\nprotected theorem measurable_comp_iff {f : β → γ} (e : «expr ≃ᵐ » α β) : Measurable (f ∘ e) ↔ Measurable f :=\n  iff.intro\n    (fun hfe => by\n      have : Measurable (f ∘ (e.symm.trans e).to_equiv) := hfe.comp e.symm.measurable\n      rwa [coe_to_equiv, symm_trans_self] at this)\n    fun h => h.comp e.measurable\n#align measurable_comp_iff measurable_comp_iff\n\n",
 "measurable_coe":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n#print QuotientGroup.measurable_coe /-\n@[to_additive]\ntheorem QuotientGroup.measurable_coe {G} [Group G] [MeasurableSpace G] {S : Subgroup G} :\n    Measurable (coe : G → «expr ⧸ » G S) :=\n  measurable_quotient_mk''\n#align quotient_group.measurable_coe QuotientGroup.measurable_coe\n#align quotient_add_group.measurable_coe QuotientAddGroup.measurable_coe\n-/\n\n",
 "measurableSet_swap_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n#print measurableSet_swap_iff /-\ntheorem measurableSet_swap_iff {s : Set (α × β)} : MeasurableSet («expr ⁻¹' » Prod.swap s) ↔ MeasurableSet s :=\n  ⟨fun hs => by\n    convert measurable_swap hs\n    ext ⟨x, y⟩\n    rfl, fun hs => measurable_swap hs⟩\n#align measurable_set_swap_iff measurableSet_swap_iff\n-/\n\n",
 "measurableSet_range_inr":
 "#print measurableSet_range_inr /-\ntheorem measurableSet_range_inr [MeasurableSpace α] : MeasurableSet (range Sum.inr : Set (Sum α β)) :=\n  by\n  rw [← image_univ]\n  exact measurableSet_inr_image MeasurableSet.univ\n#align measurable_set_range_inr measurableSet_range_inr\n-/\n\n",
 "measurableSet_range_inl":
 "#print measurableSet_range_inl /-\ntheorem measurableSet_range_inl [MeasurableSpace α] : MeasurableSet (range Sum.inl : Set (Sum α β)) :=\n  by\n  rw [← image_univ]\n  exact measurable_set.univ.inl_image\n#align measurable_set_range_inl measurableSet_range_inl\n-/\n\n",
 "measurableSet_quotient":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n#print measurableSet_quotient /-\ntheorem measurableSet_quotient {s : setoid α} {t : Set (quotient s)} :\n    MeasurableSet t ↔ MeasurableSet («expr ⁻¹' » Quotient.mk'' t) :=\n  iff.rfl\n#align measurable_set_quotient measurableSet_quotient\n-/\n\n",
 "measurableSet_prod_of_nonempty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n#print measurableSet_prod_of_nonempty /-\ntheorem measurableSet_prod_of_nonempty {s : Set α} {t : Set β} (h : (lower_set.prod s t).nonempty) :\n    MeasurableSet (lower_set.prod s t) ↔ MeasurableSet s ∧ MeasurableSet t :=\n  by\n  rcases h with ⟨⟨x, y⟩, hx, hy⟩\n  refine' ⟨fun hst => _, fun h => h.1.prod h.2⟩\n  have : MeasurableSet («expr ⁻¹' » (fun x => (x, y)) (lower_set.prod s t)) := measurable_prod_mk_right hst\n  have : MeasurableSet («expr ⁻¹' » (prod.mk x) (lower_set.prod s t)) := measurable_prod_mk_left hst\n  simp_all\n#align measurable_set_prod_of_nonempty measurableSet_prod_of_nonempty\n-/\n\n",
 "measurableSet_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n#print measurableSet_prod /-\ntheorem measurableSet_prod {s : Set α} {t : Set β} :\n    MeasurableSet (lower_set.prod s t) ↔ MeasurableSet s ∧ MeasurableSet t ∨ s = ∅ ∨ t = ∅ :=\n  by\n  cases' (lower_set.prod s t).eq_empty_or_nonempty with h h\n  · simp [h, prod_eq_empty_iff.mp h]\n  · simp [← not_nonempty_iff_eq_empty, prod_nonempty_iff.mp h, measurableSet_prod_of_nonempty h]\n#align measurable_set_prod measurableSet_prod\n-/\n\n",
 "measurableSet_preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ᵐ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n#print measurableSet_preimage /-\n@[simp]\ntheorem measurableSet_preimage (e : «expr ≃ᵐ » α β) {s : Set β} : MeasurableSet («expr ⁻¹' » e s) ↔ MeasurableSet s :=\n  ⟨fun h => by simpa only [symm_preimage_preimage] using e.symm.measurable h, fun h => e.measurable h⟩\n#align measurable_set_preimage measurableSet_preimage\n-/\n\n",
 "measurableSet_pi_of_nonempty":
 "#print measurableSet_pi_of_nonempty /-\ntheorem measurableSet_pi_of_nonempty {s : Set δ} {t : ∀ i, Set (π i)} (hs : s.countable) (h : (pi s t).nonempty) :\n    MeasurableSet (pi s t) ↔ ∀ i ∈ s, MeasurableSet (t i) := by\n  classical\n    rcases h with ⟨f, hf⟩\n    refine' ⟨fun hst i hi => _, MeasurableSet.pi hs⟩\n    convert measurable_update f hst\n    rw [update_preimage_pi hi]\n    exact fun j hj _ => hf j hj\n#align measurable_set_pi_of_nonempty measurableSet_pi_of_nonempty\n-/\n\n",
 "measurableSet_pi":
 "#print measurableSet_pi /-\ntheorem measurableSet_pi {s : Set δ} {t : ∀ i, Set (π i)} (hs : s.countable) :\n    MeasurableSet (pi s t) ↔ (∀ i ∈ s, MeasurableSet (t i)) ∨ pi s t = ∅ :=\n  by\n  cases' (pi s t).eq_empty_or_nonempty with h h\n  · simp [h]\n  · simp [measurableSet_pi_of_nonempty hs, h, ← not_nonempty_iff_eq_empty]\n#align measurable_set_pi measurableSet_pi\n-/\n\n",
 "measurableSet_mulSupport":
 "#print measurableSet_mulSupport /-\n@[measurability, to_additive]\ntheorem measurableSet_mulSupport [One β] [MeasurableSingletonClass β] (hf : Measurable f) :\n    MeasurableSet (mulSupport f) :=\n  hf (measurable_set_singleton 1).compl\n#align measurable_set_mul_support measurableSet_mulSupport\n#align measurable_set_support measurableSet_support\n-/\n\n",
 "measurableSet_inr_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n#print measurableSet_inr_image /-\ntheorem measurableSet_inr_image {s : Set β} (hs : MeasurableSet s) :\n    MeasurableSet («expr '' » Sum.inr s : Set (Sum α β)) :=\n  ⟨have : «expr ⁻¹' » Sum.inl («expr '' » Sum.inr s : Set (Sum α β)) = ∅ :=\n      eq_empty_of_subset_empty fun x ⟨y, hy, Eq⟩ => by contradiction\n    show MeasurableSet («expr ⁻¹' » Sum.inl _) by\n      rw [this]\n      exact MeasurableSet.empty,\n    show MeasurableSet («expr ⁻¹' » Sum.inr _) by\n      rwa [preimage_image_eq]\n      exact fun a b => sum.inr.inj⟩\n#align measurable_set_inr_image measurableSet_inr_image\n-/\n\n",
 "measurable":
 "#print Subsingleton.measurable /-\n@[nontriviality, measurability]\ntheorem Subsingleton.measurable [subsingleton α] : Measurable f := fun s hs => @Subsingleton.measurableSet α _ _ _\n#align subsingleton.measurable Subsingleton.measurable\n-/\n\n",
 "map_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem map_top : («expr⊤» : MeasurableSpace α).map f = «expr⊤» :=\n  (gc_comap_map f).u_top\n#align map_top map_top\n\n",
 "map_mono":
 "theorem map_mono (h : m₁ ≤ m₂) : m₁.map f ≤ m₂.map f :=\n  (gc_comap_map f).monotone_u h\n#align map_mono map_mono\n\n",
 "map_infᵢ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n#print map_infᵢ /-\n@[simp]\ntheorem map_infᵢ {m : ι → MeasurableSpace α} :\n    («expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (m i)).map f =\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" ((m i).map f) :=\n  (gc_comap_map f).u_infi\n#align map_infi map_infᵢ\n-/\n\n",
 "map_inf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n@[simp]\ntheorem map_inf : («expr ⊓ » m₁ m₂).map f = «expr ⊓ » (m₁.map f) (m₂.map f) :=\n  (gc_comap_map f).u_inf\n#align map_inf map_inf\n\n",
 "map_id":
 "/-\nCopyright (c) 2017 Johannes Hölzl. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johannes Hölzl, Mario Carneiro\n-/\n@[simp]\ntheorem map_id : m.map id = m :=\n  MeasurableSpace.ext fun s => iff.rfl\n#align map_id map_id\n\n",
 "map_comp":
 "@[simp]\ntheorem map_comp {f : α → β} {g : β → γ} : (m.map f).map g = m.map (g ∘ f) :=\n  MeasurableSpace.ext fun s => iff.rfl\n#align map_comp map_comp\n\n",
 "le_map_comap":
 "theorem le_map_comap : m ≤ (m.comap g).map g :=\n  (gc_comap_map g).le_u_l _\n#align le_map_comap le_map_comap\n\n",
 "iterate":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\n#print Measurable.iterate /-\n@[measurability]\ntheorem Measurable.iterate {f : α → α} (hf : Measurable f) : ∀ n, Measurable («expr ^[ ]» f n)\n  | 0 => measurable_id\n  | n + 1 => (Measurable.iterate n).comp hf\n#align measurable.iterate Measurable.iterate\n-/\n\n",
 "ite":
 "#print Measurable.ite /-\n/-- this is slightly different from `measurable.piecewise`. It can be used to show\n`measurable (ite (x=0) 0 1)` by\n`exact measurable.ite (measurable_set_singleton 0) measurable_const measurable_const`,\nbut replacing `measurable.ite` by `measurable.piecewise` in that example proof does not work. -/\ntheorem Measurable.ite {p : α → Prop} {_ : DecidablePred p} (hp : MeasurableSet { a : α | p a }) (hf : Measurable f)\n    (hg : Measurable g) : Measurable fun x => ite (p x) (f x) (g x) :=\n  Measurable.piecewise hp hf hg\n#align measurable.ite Measurable.ite\n-/\n\n",
 "isCountablySpanning_measurableSet":
 "#print isCountablySpanning_measurableSet /-\ntheorem isCountablySpanning_measurableSet [MeasurableSpace α] : IsCountablySpanning { s : Set α | MeasurableSet s } :=\n  ⟨fun _ => univ, fun _ => MeasurableSet.univ, unionᵢ_const _⟩\n#align is_countably_spanning_measurable_set isCountablySpanning_measurableSet\n-/\n\n",
 "inl_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n#print MeasurableSet.inl_image /-\ntheorem MeasurableSet.inl_image {s : Set α} (hs : MeasurableSet s) :\n    MeasurableSet («expr '' » Sum.inl s : Set (Sum α β)) :=\n  ⟨show MeasurableSet («expr ⁻¹' » Sum.inl _) by\n      rwa [preimage_image_eq]\n      exact fun a b => sum.inl.inj,\n    have : «expr ⁻¹' » Sum.inr («expr '' » Sum.inl s : Set (Sum α β)) = ∅ :=\n      eq_empty_of_subset_empty fun x ⟨y, hy, Eq⟩ => by contradiction\n    show MeasurableSet («expr ⁻¹' » Sum.inr _) by\n      rw [this]\n      exact MeasurableSet.empty⟩\n#align measurable_set.inl_image MeasurableSet.inl_image\n-/\n\n",
 "injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ᵐ » -/\nprotected theorem injective (e : «expr ≃ᵐ » α β) : injective e :=\n  e.to_equiv.injective\n#align injective injective\n\n",
 "indicator":
 "#print Measurable.indicator /-\n@[measurability]\ntheorem Measurable.indicator [Zero β] (hf : Measurable f) (hs : MeasurableSet s) : Measurable (s.indicator f) :=\n  hf.piecewise hs measurable_const\n#align measurable.indicator Measurable.indicator\n-/\n\n",
 "image_eq_preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ᵐ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem image_eq_preimage (e : «expr ≃ᵐ » α β) (s : Set α) : «expr '' » e s = «expr ⁻¹' » e.symm s :=\n  e.to_equiv.image_eq_preimage s\n#align image_eq_preimage image_eq_preimage\n\n",
 "id":
 "#print id /-\ntheorem id : MeasurableEmbedding (id : α → α) :=\n  ⟨injective_id, measurable_id, fun s hs => by rwa [image_id]⟩\n#align id id\n-/\n\n",
 "gc_comap_map":
 "theorem gc_comap_map (f : α → β) : GaloisConnection (MeasurableSpace.comap f) (MeasurableSpace.map f) := fun f g =>\n  comap_le_iff_le_map\n#align gc_comap_map gc_comap_map\n\n",
 "fst":
 "#print Measurable.fst /-\ntheorem Measurable.fst {f : α → β × γ} (hf : Measurable f) : Measurable fun a : α => (f a).1 :=\n  measurable_fst.comp hf\n#align measurable.fst Measurable.fst\n-/\n\n",
 "find":
 "#print Measurable.find /-\n/-- A piecewise function on countably many pieces is measurable if all the data is measurable. -/\n@[measurability]\ntheorem Measurable.find {m : MeasurableSpace α} {f : ℕ → α → β} {p : ℕ → α → Prop} [∀ n, DecidablePred (p n)]\n    (hf : ∀ n, Measurable (f n)) (hp : ∀ n, MeasurableSet { x | p n x }) (h : ∀ x, ∃ n, p n x) :\n    Measurable fun x => f (nat.find (h x)) x :=\n  haveI : Measurable fun p : α × ℕ => f p.2 p.1 := measurable_from_prod_countable fun n => hf n\n  this.comp (Measurable.prod_mk measurable_id (measurable_find h hp))\n#align measurable.find Measurable.find\n-/\n\n",
 "ext":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ᵐ » -/\n@[ext]\ntheorem ext {e₁ e₂ : «expr ≃ᵐ » α β} (h : (e₁ : α → β) = e₂) : e₁ = e₂ :=\n  toEquiv_injective <| Equiv.coe_fn_injective h\n#align ext ext\n\n",
 "exists_measurable_proj":
 "#print MeasurableSet.exists_measurable_proj /-\ntheorem MeasurableSet.exists_measurable_proj {m : MeasurableSpace α} {s : Set α} (hs : MeasurableSet s)\n    (hne : s.nonempty) : ∃ f : α → s, Measurable f ∧ ∀ x : s, f x = x :=\n  let ⟨f, hfm, hf⟩ :=\n    (MeasurableEmbedding.subtype_coe hs).exists_measurable_extend measurable_id fun _ => hne.to_subtype\n  ⟨f, hfm, congr_fun hf⟩\n#align measurable_set.exists_measurable_proj MeasurableSet.exists_measurable_proj\n-/\n\n",
 "exists_measurable_piecewise_nat":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr on » -/\n#print exists_measurable_piecewise_nat /-\n/-- Given countably many disjoint measurable sets `t n` and countably many measurable\nfunctions `g n`, one can construct a measurable function that coincides with `g n` on `t n`. -/\ntheorem exists_measurable_piecewise_nat {m : MeasurableSpace α} (t : ℕ → Set β) (t_meas : ∀ n, MeasurableSet (t n))\n    (t_disj : Pairwise («expr on » Disjoint t)) (g : ℕ → β → α) (hg : ∀ n, Measurable (g n)) :\n    ∃ f : β → α, Measurable f ∧ ∀ n x, x ∈ t n → f x = g n x := by\n  classical\n    let p : ℕ → β → Prop := fun n x =>\n      x ∈\n        t n ∪\n          «expr ᶜ»\n            («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (t k))\n    have M : ∀ n, MeasurableSet { x | p n x } := fun n =>\n      (t_meas n).union (MeasurableSet.compl (MeasurableSet.unionᵢ t_meas))\n    have P : ∀ x, ∃ n, p n x := by\n      intro x\n      by_cases H : ∀ i : ℕ, x ∉ t i\n      · exact ⟨0, or.inr (by simpa only [mem_Inter, compl_Union] using H)⟩\n      · simp only [not_forall, not_not_mem] at H\n        rcases H with ⟨n, hn⟩\n        exact ⟨n, or.inl hn⟩\n    refine' ⟨fun x => g (nat.find (P x)) x, Measurable.find hg M P, _⟩\n    intro n x hx\n    have : x ∈ t (nat.find (P x)) :=\n      by\n      have B :\n        x ∈\n          t (nat.find (P x)) ∪\n            «expr ᶜ»\n              («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (t k)) :=\n        nat.find_spec (P x)\n      have B' : (∀ i : ℕ, x ∉ t i) ↔ False :=\n        by\n        simp only [iff_false_iff, not_forall, not_not_mem]\n        exact ⟨n, hx⟩\n      simpa only [B', mem_union, mem_Inter, or_false_iff, compl_Union, mem_compl_iff] using B\n    congr\n    by_contra h\n    exact (t_disj (ne.symm h)).le_bot ⟨hx, this⟩\n#align exists_measurable_piecewise_nat exists_measurable_piecewise_nat\n-/\n\n",
 "exists_measurable_mem_of_small_sets":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\ntheorem eventually.exists_measurable_mem_of_small_sets {f : Filter α} [IsMeasurablyGenerated f] {p : Set α → Prop}\n    (h :\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\"\n        f.small_sets (p s)) :\n    ∃ s ∈ f, MeasurableSet s ∧ p s :=\n  let ⟨s, hsf, hs⟩ := eventually_smallSets.1 h\n  let ⟨t, htf, htm, hts⟩ := is_measurably_generated.exists_measurable_subset hsf\n  ⟨t, htf, htm, hs t hts⟩\n#align eventually.exists_measurable_mem_of_small_sets eventually.exists_measurable_mem_of_small_sets\n\n",
 "exists_measurable_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\ntheorem eventually.exists_measurable_mem {f : Filter α} [IsMeasurablyGenerated f] {p : α → Prop}\n    (h :\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" f (p x)) :\n    ∃ s ∈ f, MeasurableSet s ∧ ∀ x ∈ s, p x :=\n  is_measurably_generated.exists_measurable_subset h\n#align eventually.exists_measurable_mem eventually.exists_measurable_mem\n\n",
 "exists_measurable_extend":
 "theorem exists_measurable_extend (hf : MeasurableEmbedding f) {g : α → γ} (hg : Measurable g) (hne : β → Nonempty γ) :\n    ∃ g' : β → γ, Measurable g' ∧ g' ∘ f = g :=\n  ⟨extend f g fun x => Classical.choice (hne x), hf.measurable_extend hg (measurable_const' fun _ _ => rfl),\n    funext fun x => hf.injective.extend_apply _ _ _⟩\n#align exists_measurable_extend exists_measurable_extend\n\n",
 "eval":
 "#print Measurable.eval /-\n@[measurability]\ntheorem Measurable.eval {a : δ} {g : α → ∀ a, π a} (hg : Measurable g) : Measurable fun x => g x a :=\n  (measurable_pi_apply a).comp hg\n#align measurable.eval Measurable.eval\n-/\n\n",
 "dite":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n#print Measurable.dite /-\ntheorem Measurable.dite [∀ x, Decidable (x ∈ s)] {f : s → β} (hf : Measurable f) {g : «expr ᶜ» s → β}\n    (hg : Measurable g) (hs : MeasurableSet s) : Measurable fun x => if hx : x ∈ s then f ⟨x, hx⟩ else g ⟨x, hx⟩ :=\n  measurable_of_restrict_of_restrict_compl hs (by simpa) (by simpa)\n#align measurable.dite Measurable.dite\n-/\n\n",
 "comp":
 "theorem comp (hg : MeasurableEmbedding g) (hf : MeasurableEmbedding f) : MeasurableEmbedding (g ∘ f) :=\n  ⟨hg.injective.comp hf.injective, hg.measurable.comp hf.measurable, fun s hs => by\n    rwa [← image_image, hg.measurable_set_image, hf.measurable_set_image]⟩\n#align comp comp\n\n",
 "comap_supr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n@[simp]\ntheorem comap_supr {m : ι → MeasurableSpace α} :\n    («expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (m i)).comap g =\n      «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" ((m i).comap g) :=\n  (gc_comap_map g).l_supr\n#align comap_supr comap_supr\n\n",
 "comap_sup":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n@[simp]\ntheorem comap_sup : («expr ⊔ » m₁ m₂).comap g = «expr ⊔ » (m₁.comap g) (m₂.comap g) :=\n  (gc_comap_map g).l_sup\n#align comap_sup comap_sup\n\n",
 "comap_mono":
 "theorem comap_mono (h : m₁ ≤ m₂) : m₁.comap g ≤ m₂.comap g :=\n  (gc_comap_map g).monotone_l h\n#align comap_mono comap_mono\n\n",
 "comap_measurable":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_of -/\n#print comap_measurable /-\ntheorem comap_measurable {m : MeasurableSpace β} (f : α → β) : (measurable_of (m.comap f)) f := fun s hs => ⟨s, hs, rfl⟩\n#align comap_measurable comap_measurable\n-/\n\n",
 "comap_map_le":
 "theorem comap_map_le : (m.map f).comap f ≤ m :=\n  (gc_comap_map f).l_u_le _\n#align comap_map_le comap_map_le\n\n",
 "comap_le_iff_le_map":
 "theorem comap_le_iff_le_map {f : α → β} : m'.comap f ≤ m ↔ m' ≤ m.map f :=\n  ⟨fun h s hs => h _ ⟨_, hs, rfl⟩, fun h s ⟨t, ht, HEq⟩ => HEq ▸ h _ ht⟩\n#align comap_le_iff_le_map comap_le_iff_le_map\n\n",
 "comap_id":
 "@[simp]\ntheorem comap_id : m.comap id = m :=\n  MeasurableSpace.ext fun s => ⟨fun ⟨s', hs', h⟩ => h ▸ hs', fun h => ⟨s, h, rfl⟩⟩\n#align comap_id comap_id\n\n",
 "comap_generate_from":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem comap_generate_from {f : α → β} {s : Set (Set β)} :\n    (generateFrom s).comap f = generateFrom («expr '' » (preimage f) s) :=\n  le_antisymm\n    (comap_le_iff_le_map.2 <| generateFrom_le fun t hts => generate_measurable.basic _ <| mem_image_of_mem _ <| hts)\n    (generateFrom_le fun t ⟨u, hu, Eq⟩ => Eq ▸ ⟨u, generate_measurable.basic _ hu, rfl⟩)\n#align comap_generate_from comap_generate_from\n\n",
 "comap_eq_generate_from":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem comap_eq_generate_from (m : MeasurableSpace β) (f : α → β) :\n    m.comap f = generateFrom { t | ∃ s, MeasurableSet s ∧ «expr ⁻¹' » f s = t } := by\n  convert generate_from_measurable_set.symm\n#align comap_eq_generate_from comap_eq_generate_from\n\n",
 "comap_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n@[simp]\ntheorem comap_comp {f : β → α} {g : γ → β} : (m.comap f).comap g = m.comap (f ∘ g) :=\n  MeasurableSpace.ext fun s =>\n    ⟨fun ⟨t, ⟨u, h, hu⟩, ht⟩ => ⟨u, h, ht ▸ hu ▸ rfl⟩, fun ⟨t, h, ht⟩ => ⟨«expr ⁻¹' » f t, ⟨_, h, rfl⟩, ht⟩⟩\n#align comap_comp comap_comp\n\n",
 "comap_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem comap_bot : («expr⊥» : MeasurableSpace α).comap g = «expr⊥» :=\n  (gc_comap_map g).l_bot\n#align comap_bot comap_bot\n\n",
 "coe_union":
 "@[simp]\ntheorem coe_union (s t : Subtype (MeasurableSet : Set α → Prop)) : ↑(s ∪ t) = (s ∪ t : Set α) :=\n  rfl\n#align coe_union coe_union\n\n",
 "coe_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem coe_top : ↑(«expr⊤» : Subtype (MeasurableSet : Set α → Prop)) = («expr⊤» : Set α) :=\n  rfl\n#align coe_top coe_top\n\n",
 "coe_to_equiv_symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ᵐ » -/\n@[simp]\ntheorem coe_to_equiv_symm (e : «expr ≃ᵐ » α β) : (e.to_equiv.symm : β → α) = e.symm :=\n  rfl\n#align coe_to_equiv_symm coe_to_equiv_symm\n\n",
 "coe_to_equiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ᵐ » -/\n@[simp]\ntheorem coe_to_equiv (e : «expr ≃ᵐ » α β) : (e.to_equiv : α → β) = e :=\n  rfl\n#align coe_to_equiv coe_to_equiv\n\n",
 "coe_sdiff":
 "@[simp]\ntheorem coe_sdiff (s t : Subtype (MeasurableSet : Set α → Prop)) : ↑(s \\ t) = (s \\ t : Set α) :=\n  rfl\n#align coe_sdiff coe_sdiff\n\n",
 "coe_mk":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ᵐ » -/\n@[simp]\ntheorem coe_mk (e : «expr ≃ » α β) (h1 : Measurable e) (h2 : Measurable e.symm) :\n    ((⟨e, h1, h2⟩ : «expr ≃ᵐ » α β) : α → β) = e :=\n  rfl\n#align coe_mk coe_mk\n\n",
 "coe_inter":
 "@[simp]\ntheorem coe_inter (s t : Subtype (MeasurableSet : Set α → Prop)) : ↑(s ∩ t) = (s ∩ t : Set α) :=\n  rfl\n#align coe_inter coe_inter\n\n",
 "coe_insert":
 "@[simp]\ntheorem coe_insert [MeasurableSingletonClass α] (a : α) (s : Subtype (MeasurableSet : Set α → Prop)) :\n    ↑(has_insert.insert a s) = (has_insert.insert a s : Set α) :=\n  rfl\n#align coe_insert coe_insert\n\n",
 "coe_empty":
 "@[simp]\ntheorem coe_empty : ↑(∅ : Subtype (MeasurableSet : Set α → Prop)) = (∅ : Set α) :=\n  rfl\n#align coe_empty coe_empty\n\n",
 "coe_compl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n@[simp]\ntheorem coe_compl (s : Subtype (MeasurableSet : Set α → Prop)) : ↑(«expr ᶜ» s) = («expr ᶜ» s : Set α) :=\n  rfl\n#align coe_compl coe_compl\n\n",
 "coe_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem coe_bot : ↑(«expr⊥» : Subtype (MeasurableSet : Set α → Prop)) = («expr⊥» : Set α) :=\n  rfl\n#align coe_bot coe_bot\n\n",
 "bijective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ᵐ » -/\nprotected theorem bijective (e : «expr ≃ᵐ » α β) : bijective e :=\n  e.to_equiv.bijective\n#align bijective bijective\n\n",
 "apply_symm_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ᵐ » -/\n@[simp]\ntheorem apply_symm_apply (e : «expr ≃ᵐ » α β) (y : β) : e (e.symm y) = y :=\n  e.right_inv y\n#align apply_symm_apply apply_symm_apply\n\n",
 "MeasurableEmbedding":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ᵐ » -/\n#print MeasurableEmbedding /-\n/-- A measurable equivalence is a measurable embedding. -/\nprotected theorem MeasurableEmbedding (e : «expr ≃ᵐ » α β) : MeasurableEmbedding e :=\n  { injective := e.injective\n    measurable := e.measurable\n    measurable_set_image' := fun s => e.measurable_set_image.2 }\n#align measurable_embedding MeasurableEmbedding\n-/\n\n",
 "Measurable":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ᵐ » -/\n#print Measurable /-\n@[measurability]\nprotected theorem Measurable (e : «expr ≃ᵐ » α β) : Measurable (e : α → β) :=\n  e.measurable_to_fun\n#align measurable Measurable\n-/\n\n"}