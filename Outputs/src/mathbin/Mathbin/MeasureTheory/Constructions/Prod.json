{"zero_prod":
 "@[simp]\ntheorem zero_prod (ν : measure β) : (0 : measure α).prod ν = 0 :=\n  by\n  rw [measure.prod]\n  exact bind_zero_left _\n#align zero_prod zero_prod\n\n",
 "volume_eq_prod":
 "theorem volume_eq_prod (α β) [measure_space α] [measure_space β] :\n    (volume : measure (α × β)) = (volume : measure α).prod (volume : measure β) :=\n  rfl\n#align volume_eq_prod volume_eq_prod\n\n",
 "swap":
 "theorem integrable.swap [sigma_finite μ] ⦃f : α × β → E⦄ (hf : integrable f (μ.prod ν)) :\n    integrable (f ∘ prod.swap) (ν.prod μ) :=\n  ⟨hf.ae_strongly_measurable.prod_swap,\n    (lintegral_prod_swap _ hf.ae_strongly_measurable.ennnorm : _).le.trans_lt hf.has_finite_integral⟩\n#align integrable.swap integrable.swap\n\n",
 "sum_prod":
 "theorem sum_prod {ι : Type _} [Finite ι] (μ : ι → measure α) [∀ i, sigma_finite (μ i)] :\n    (sum μ).prod ν = sum fun i => (μ i).prod ν :=\n  by\n  refine' prod_eq fun s t hs ht => _\n  simp_rw [sum_apply _ (hs.prod ht), sum_apply _ hs, prod_prod, ennreal.tsum_mul_right]\n#align sum_prod sum_prod\n\n",
 "snd":
 "theorem measure_theory.ae_strongly_measurable.snd {γ} [topological_space γ] [sigma_finite ν] {f : β → γ}\n    (hf : ae_strongly_measurable f ν) : ae_strongly_measurable (fun z : α × β => f z.2) (μ.prod ν) :=\n  hf.comp_quasi_measure_preserving quasi_measure_preserving_snd\n#align measure_theory.ae_strongly_measurable.snd measure_theory.ae_strongly_measurable.snd\n\n",
 "skew_product":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\ntheorem skew_product [sigma_finite μb] [sigma_finite μd] {f : α → β} (hf : measure_preserving f μa μb) {g : α → γ → δ}\n    (hgm : measurable (uncurry g))\n    (hg :\n      «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\" μa\n        (map (g x) μc = μd)) :\n    measure_preserving (fun p : α × γ => (f p.1, g p.1 p.2)) (μa.prod μc) (μb.prod μd) := by\n  classical\n    have : measurable fun p : α × γ => (f p.1, g p.1 p.2) := (hf.1.comp measurable_fst).prod_mk hgm\n    /- if `μa = 0`, then the lemma is trivial, otherwise we can use `hg`\n      to deduce `sigma_finite μc`. -/\n    rcases eq_or_ne μa 0 with (rfl | ha)\n    · rw [← hf.map_eq, zero_prod, measure.map_zero, zero_prod]\n      exact ⟨this, by simp only [measure.map_zero]⟩\n    have : sigma_finite μc :=\n      by\n      rcases(ae_ne_bot.2 ha).nonempty_of_mem hg with ⟨x, hx : map (g x) μc = μd⟩\n      exact sigma_finite.of_map _ hgm.of_uncurry_left.ae_measurable (by rwa [hx])\n    -- Thus we can apply `measure.prod_eq` to prove equality of measures.\n    refine' ⟨this, (prod_eq fun s t hs ht => _).symm⟩\n    rw [map_apply this (hs.prod ht)]\n    refine' (prod_apply (this <| hs.prod ht)).trans _\n    have :\n      «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\" μa\n        (μc («expr ⁻¹' » (fun y => (f x, g x y)) (lower_set.prod s t)) =\n          indicator («expr ⁻¹' » f s) (fun y => μd t) x) :=\n      by\n      refine' hg.mono fun x hx => _\n      subst hx\n      simp only [mk_preimage_prod_right_fn_eq_if, indicator_apply, mem_preimage]\n      split_ifs\n      exacts[(map_apply hgm.of_uncurry_left ht).symm, measure_empty]\n    simp only [preimage_preimage]\n    rw [lintegral_congr_ae this, lintegral_indicator _ (hf.1 hs), set_lintegral_const, hf.measure_preimage hs, mul_comm]\n#align skew_product skew_product\n\n",
 "set_integral_prod_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ in , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ in , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ in , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ in , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ in , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ in , ∂ » -/\ntheorem set_integral_prod_mul {L : Type _} [is_R_or_C L] (f : α → L) (g : β → L) (s : set α) (t : set β) :\n    «expr∫ in , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ in , ∂ »\"\n        (lower_set.prod s t) (f z.1 * g z.2) (μ.prod ν) =\n      «expr∫ in , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ in , ∂ »\" s (f x)\n          μ *\n        «expr∫ in , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ in , ∂ »\" t\n          (g y) ν :=\n  by simp only [← measure.prod_restrict s t, integrable_on, integral_prod_mul]\n#align set_integral_prod_mul set_integral_prod_mul\n\n",
 "set_integral_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ in , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ in , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ in , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ in , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ in , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ in , ∂ » -/\n/-- **Fubini's Theorem** for set integrals. -/\ntheorem set_integral_prod (f : α × β → E) {s : set α} {t : set β}\n    (hf : integrable_on f (lower_set.prod s t) (μ.prod ν)) :\n    «expr∫ in , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ in , ∂ »\"\n        (lower_set.prod s t) (f z) (μ.prod ν) =\n      «expr∫ in , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ in , ∂ »\" s\n        («expr∫ in , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ in , ∂ »\" t\n          (f (x, y)) ν)\n        μ :=\n  by\n  simp only [← measure.prod_restrict s t, integrable_on] at hf⊢\n  exact integral_prod f hf\n#align set_integral_prod set_integral_prod\n\n",
 "restrict_prod_eq_prod_univ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\ntheorem restrict_prod_eq_prod_univ (s : set α) :\n    (μ.restrict s).prod ν = (μ.prod ν).restrict (lower_set.prod s (univ : set β)) :=\n  by\n  have : ν = ν.restrict Set.univ := measure.restrict_univ.symm\n  rwa [this, measure.prod_restrict, ← this]\n#align restrict_prod_eq_prod_univ restrict_prod_eq_prod_univ\n\n",
 "quasi_measure_preserving_snd":
 "theorem quasi_measure_preserving_snd : quasi_measure_preserving prod.snd (μ.prod ν) ν :=\n  by\n  refine' ⟨measurable_snd, absolutely_continuous.mk fun s hs h2s => _⟩\n  rw [map_apply measurable_snd hs, ← univ_prod, prod_prod, h2s, mul_zero]\n#align quasi_measure_preserving_snd quasi_measure_preserving_snd\n\n",
 "quasi_measure_preserving_fst":
 "theorem quasi_measure_preserving_fst : quasi_measure_preserving prod.fst (μ.prod ν) μ :=\n  by\n  refine' ⟨measurable_fst, absolutely_continuous.mk fun s hs h2s => _⟩\n  rw [map_apply measurable_fst hs, ← prod_univ, prod_prod, h2s, zero_mul]\n#align quasi_measure_preserving_fst quasi_measure_preserving_fst\n\n",
 "prod_zero":
 "@[simp]\ntheorem prod_zero (μ : measure α) : μ.prod (0 : measure β) = 0 := by simp [measure.prod]\n#align prod_zero prod_zero\n\n",
 "prod_swap":
 "theorem measure_theory.ae_strongly_measurable.prod_swap {γ : Type _} [topological_space γ] [sigma_finite μ]\n    [sigma_finite ν] {f : β × α → γ} (hf : ae_strongly_measurable f (ν.prod μ)) :\n    ae_strongly_measurable (fun z : α × β => f z.swap) (μ.prod ν) :=\n  by\n  rw [← prod_swap] at hf\n  exact hf.comp_measurable measurable_swap\n#align measure_theory.ae_strongly_measurable.prod_swap measure_theory.ae_strongly_measurable.prod_swap\n\n",
 "prod_sum":
 "theorem prod_sum {ι : Type _} [Finite ι] (ν : ι → measure β) [∀ i, sigma_finite (ν i)] :\n    μ.prod (sum ν) = sum fun i => μ.prod (ν i) :=\n  by\n  refine' prod_eq fun s t hs ht => _\n  simp_rw [sum_apply _ (hs.prod ht), sum_apply _ ht, prod_prod, ennreal.tsum_mul_left]\n#align prod_sum prod_sum\n\n",
 "prod_right_ae":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\ntheorem integrable.prod_right_ae [sigma_finite μ] ⦃f : α × β → E⦄ (hf : integrable f (μ.prod ν)) :\n    «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\" μ\n      (integrable (fun y => f (x, y)) ν) :=\n  hf.swap.prod_left_ae\n#align integrable.prod_right_ae integrable.prod_right_ae\n\n",
 "prod_restrict":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\ntheorem prod_restrict (s : set α) (t : set β) :\n    (μ.restrict s).prod (ν.restrict t) = (μ.prod ν).restrict (lower_set.prod s t) :=\n  by\n  refine' prod_eq fun s' t' hs' ht' => _\n  rw [restrict_apply (hs'.prod ht'), prod_inter_prod, prod_prod, restrict_apply hs', restrict_apply ht']\n#align prod_restrict prod_restrict\n\n",
 "prod_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫⁻ in , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ in , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫⁻ in , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ in , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫⁻ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n/-- The product measure of the product of two sets is the product of their measures. Note that we\ndo not need the sets to be measurable. -/\n@[simp]\ntheorem prod_prod (s : set α) (t : set β) : μ.prod ν (lower_set.prod s t) = μ s * ν t :=\n  by\n  apply le_antisymm\n  · set ST := lower_set.prod (to_measurable μ s) (to_measurable ν t)\n    have hSTm : measurable_set ST := (measurable_set_to_measurable _ _).prod (measurable_set_to_measurable _ _)\n    calc\n      μ.prod ν (lower_set.prod s t) ≤ μ.prod ν ST :=\n        measure_mono <| Set.prod_mono (subset_to_measurable _ _) (subset_to_measurable _ _)\n      _ = μ (to_measurable μ s) * ν (to_measurable ν t) := by\n        simp_rw [prod_apply hSTm, mk_preimage_prod_right_eq_if, measure_if,\n          lintegral_indicator _ (measurable_set_to_measurable _ _), lintegral_const, restrict_apply_univ, mul_comm]\n      _ = μ s * ν t := by rw [measure_to_measurable, measure_to_measurable]\n      \n  · -- Formalization is based on https://mathoverflow.net/a/254134/136589\n    set ST := to_measurable (μ.prod ν) (lower_set.prod s t)\n    have hSTm : measurable_set ST := measurable_set_to_measurable _ _\n    have hST : lower_set.prod s t ⊆ ST := subset_to_measurable _ _\n    set f : α → ennreal := fun x => ν («expr ⁻¹' » (prod.mk x) ST)\n    have hfm : measurable f := measurable_measure_prod_mk_left hSTm\n    set s' : set α := { x | ν t ≤ f x }\n    have hss' : s ⊆ s' := fun x hx => measure_mono fun y hy => hST <| mk_mem_prod hx hy\n    calc\n      μ s * ν t ≤ μ s' * ν t := mul_le_mul_right' (measure_mono hss') _\n      _ =\n          «expr∫⁻ in , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ in , ∂ »\" s'\n            (ν t) μ :=\n        by rw [set_lintegral_const, mul_comm]\n      _ ≤\n          «expr∫⁻ in , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ in , ∂ »\" s'\n            (f x) μ :=\n        set_lintegral_mono measurable_const hfm fun x => id\n      _ ≤\n          «expr∫⁻ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ , ∂ »\" (f x)\n            μ :=\n        lintegral_mono' restrict_le_self le_rfl\n      _ = μ.prod ν ST := (prod_apply hSTm).symm\n      _ = μ.prod ν (lower_set.prod s t) := measure_to_measurable _\n      \n#align prod_prod prod_prod\n\n",
 "prod_of_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\ntheorem prod_of_right {f : α × β → γ} {μ : measure α} {ν : measure β} {τ : measure γ} (hf : measurable f)\n    [sigma_finite ν]\n    (h2f :\n      «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\" μ\n        (quasi_measure_preserving (fun y => f (x, y)) ν τ)) :\n    quasi_measure_preserving f (μ.prod ν) τ := by\n  refine' ⟨hf, _⟩\n  refine' absolutely_continuous.mk fun s hs h2s => _\n  simp_rw [map_apply hf hs, prod_apply (hf hs), preimage_preimage,\n    lintegral_congr_ae (h2f.mono fun x hx => hx.preimage_null h2s), lintegral_zero]\n#align prod_of_right prod_of_right\n\n",
 "prod_of_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\ntheorem prod_of_left {α β γ} [measurable_space α] [measurable_space β] [measurable_space γ] {f : α × β → γ}\n    {μ : measure α} {ν : measure β} {τ : measure γ} (hf : measurable f) [sigma_finite μ] [sigma_finite ν]\n    (h2f :\n      «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\" ν\n        (quasi_measure_preserving (fun x => f (x, y)) μ τ)) :\n    quasi_measure_preserving f (μ.prod ν) τ := by\n  rw [← prod_swap]\n  convert\n    (quasi_measure_preserving.prod_of_right (hf.comp measurable_swap) h2f).comp\n      ((measurable_swap.measure_preserving (ν.prod μ)).symm measurable_equiv.prod_comm).quasi_measure_preserving\n  ext ⟨x, y⟩; rfl\n#align prod_of_left prod_of_left\n\n",
 "prod_mk_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\ntheorem measure_theory.ae_strongly_measurable.prod_mk_left {γ : Type _} [sigma_finite ν] [topological_space γ]\n    {f : α × β → γ} (hf : ae_strongly_measurable f (μ.prod ν)) :\n    «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\" μ\n      (ae_strongly_measurable (fun y => f (x, y)) ν) :=\n  by\n  filter_upwards [ae_ae_of_ae_prod hf.ae_eq_mk] with x hx\n  exact ⟨fun y => hf.mk f (x, y), hf.strongly_measurable_mk.comp_measurable measurable_prod_mk_left, hx⟩\n#align measure_theory.ae_strongly_measurable.prod_mk_left measure_theory.ae_strongly_measurable.prod_mk_left\n\n",
 "prod_left_ae":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\ntheorem integrable.prod_left_ae [sigma_finite μ] ⦃f : α × β → E⦄ (hf : integrable f (μ.prod ν)) :\n    «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\" ν\n      (integrable (fun x => f (x, y)) μ) :=\n  ((integrable_prod_iff' hf.ae_strongly_measurable).mp hf).1\n#align integrable.prod_left_ae integrable.prod_left_ae\n\n",
 "prod_eq_generate_from":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n/-- A measure on a product space equals the product measure if they are equal on rectangles\n  with as sides sets that generate the corresponding σ-algebras. -/\ntheorem prod_eq_generate_from {μ : measure α} {ν : measure β} {C : set (set α)} {D : set (set β)}\n    (hC : generate_from C = ‹_›) (hD : generate_from D = ‹_›) (h2C : is_pi_system C) (h2D : is_pi_system D)\n    (h3C : μ.finite_spanning_sets_in C) (h3D : ν.finite_spanning_sets_in D) {μν : measure (α × β)}\n    (h₁ : ∀ s ∈ C, ∀ t ∈ D, μν (lower_set.prod s t) = μ s * ν t) : μ.prod ν = μν :=\n  by\n  refine'\n    (h3C.prod h3D).ext (generate_from_eq_prod hC hD h3C.is_countably_spanning h3D.is_countably_spanning).symm\n      (h2C.prod h2D) _\n  · rintro _ ⟨s, t, hs, ht, rfl⟩\n    haveI := h3D.sigma_finite\n    rw [h₁ s hs t ht, prod_prod]\n#align prod_eq_generate_from prod_eq_generate_from\n\n",
 "prod_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n/-- A measure on a product space equals the product measure if they are equal on rectangles. -/\ntheorem prod_eq {μν : measure (α × β)}\n    (h : ∀ s t, measurable_set s → measurable_set t → μν (lower_set.prod s t) = μ s * ν t) : μ.prod ν = μν :=\n  prod_eq_generate_from generate_from_measurable_set generate_from_measurable_set is_pi_system_measurable_set\n    is_pi_system_measurable_set μ.to_finite_spanning_sets_in ν.to_finite_spanning_sets_in fun s hs t ht => h s t hs ht\n#align prod_eq prod_eq\n\n",
 "prod_dirac":
 "theorem prod_dirac (y : β) : μ.prod (dirac y) = map (fun x => (x, y)) μ :=\n  by\n  refine' prod_eq fun s t hs ht => _\n  simp_rw [map_apply measurable_prod_mk_right (hs.prod ht), mk_preimage_prod_left_eq_if, measure_if, dirac_apply' _ ht,\n    ← indicator_mul_right _ fun x => μ s, pi.one_apply, mul_one]\n#align prod_dirac prod_dirac\n\n",
 "prod_assoc_prod":
 "theorem prod_assoc_prod [sigma_finite τ] : map measurable_equiv.prod_assoc ((μ.prod ν).prod τ) = μ.prod (ν.prod τ) :=\n  by\n  refine'\n    (prod_eq_generate_from generate_from_measurable_set generate_from_prod is_pi_system_measurable_set is_pi_system_prod\n        μ.to_finite_spanning_sets_in (ν.to_finite_spanning_sets_in.prod τ.to_finite_spanning_sets_in) _).symm\n  rintro s hs _ ⟨t, u, ht, hu, rfl⟩; rw [mem_set_of_eq] at hs ht hu\n  simp_rw [map_apply (measurable_equiv.measurable _) (hs.prod (ht.prod hu)), measurable_equiv.prod_assoc,\n    measurable_equiv.coe_mk, Equiv.prod_assoc_preimage, prod_prod, mul_assoc]\n#align prod_assoc_prod prod_assoc_prod\n\n",
 "prod_apply_symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫⁻ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem prod_apply_symm {s : set (α × β)} (hs : measurable_set s) :\n    μ.prod ν s =\n      «expr∫⁻ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ , ∂ »\"\n        (μ («expr ⁻¹' » (fun x => (x, y)) s)) ν :=\n  by\n  rw [← prod_swap, map_apply measurable_swap hs]\n  simp only [prod_apply (measurable_swap hs)]\n  rfl\n#align prod_apply_symm prod_apply_symm\n\n",
 "prod_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫⁻ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem prod_apply {s : set (α × β)} (hs : measurable_set s) :\n    μ.prod ν s =\n      «expr∫⁻ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ , ∂ »\"\n        (ν («expr ⁻¹' » (prod.mk x) s)) μ :=\n  by simp_rw [measure.prod, bind_apply hs measurable.map_prod_mk_left, map_apply measurable_prod_mk_left hs]\n#align prod_apply prod_apply\n\n",
 "prod_add":
 "theorem prod_add (ν' : measure β) [sigma_finite ν'] : μ.prod (ν + ν') = μ.prod ν + μ.prod ν' :=\n  by\n  refine' prod_eq fun s t hs ht => _\n  simp_rw [add_apply, prod_prod, left_distrib]\n#align prod_add prod_add\n\n",
 "prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure.absolutely_continuous -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure.absolutely_continuous -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure.absolutely_continuous -/\ntheorem absolutely_continuous.prod [sigma_finite ν'] (h1 : measure.absolutely_continuous μ μ')\n    (h2 : measure.absolutely_continuous ν ν') : measure.absolutely_continuous (μ.prod ν) (μ'.prod ν') :=\n  by\n  refine' absolutely_continuous.mk fun s hs h2s => _\n  simp_rw [measure_prod_null hs] at h2s⊢\n  exact (h2s.filter_mono h1.ae_le).mono fun _ h => h2 h\n#align absolutely_continuous.prod absolutely_continuous.prod\n\n",
 "measure_prod_null":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/-- Note: the assumption `hs` cannot be dropped. For a counterexample, see\n  Walter Rudin *Real and Complex Analysis*, example (c) in section 8.9. -/\ntheorem measure_prod_null {s : set (α × β)} (hs : measurable_set s) :\n    μ.prod ν s = 0 ↔ «expr =ᵐ[ ] » (fun x => ν («expr ⁻¹' » (prod.mk x) s)) μ 0 := by\n  simp_rw [prod_apply hs, lintegral_eq_zero_iff (measurable_measure_prod_mk_left hs)]\n#align measure_prod_null measure_prod_null\n\n",
 "measure_preserving_swap":
 "theorem measure_preserving_swap : measure_preserving prod.swap (μ.prod ν) (ν.prod μ) :=\n  ⟨measurable_swap, prod_swap⟩\n#align measure_preserving_swap measure_preserving_swap\n\n",
 "measure_ae_null_of_prod_null":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/-- Note: the converse is not true without assuming that `s` is measurable. For a counterexample,\n  see Walter Rudin *Real and Complex Analysis*, example (c) in section 8.9. -/\ntheorem measure_ae_null_of_prod_null {s : set (α × β)} (h : μ.prod ν s = 0) :\n    «expr =ᵐ[ ] » (fun x => ν («expr ⁻¹' » (prod.mk x) s)) μ 0 :=\n  by\n  obtain ⟨t, hst, mt, ht⟩ := exists_measurable_superset_of_null h\n  simp_rw [measure_prod_null mt] at ht\n  rw [eventually_le_antisymm_iff]\n  exact\n    ⟨eventually_le.trans_eq (eventually_of_forall fun x => (measure_mono (preimage_mono hst) : _)) ht,\n      eventually_of_forall fun x => zero_le _⟩\n#align measure_ae_null_of_prod_null measure_ae_null_of_prod_null\n\n",
 "measurable_set_integrable":
 "theorem measurable_set_integrable [sigma_finite ν] ⦃f : α → β → E⦄ (hf : strongly_measurable (uncurry f)) :\n    measurable_set { x | integrable (f x) ν } :=\n  by\n  simp_rw [integrable, hf.of_uncurry_left.ae_strongly_measurable, true_and_iff]\n  exact measurable_set_lt (measurable.lintegral_prod_right hf.ennnorm) measurable_const\n#align measurable_set_integrable measurable_set_integrable\n\n",
 "measurable_measure_prod_mk_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/-- If `μ` is a σ-finite measure, and `s ⊆ α × β` is measurable, then `y ↦ μ { x | (x, y) ∈ s }` is\n  a measurable function. -/\ntheorem measurable_measure_prod_mk_right {μ : measure α} [sigma_finite μ] {s : set (α × β)} (hs : measurable_set s) :\n    measurable fun y => μ («expr ⁻¹' » (fun x => (x, y)) s) :=\n  measurable_measure_prod_mk_left (measurable_set_swap_iff.mpr hs)\n#align measurable_measure_prod_mk_right measurable_measure_prod_mk_right\n\n",
 "measurable_measure_prod_mk_left_finite":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/-- If `ν` is a finite measure, and `s ⊆ α × β` is measurable, then `x ↦ ν { y | (x, y) ∈ s }` is\n  a measurable function. `measurable_measure_prod_mk_left` is strictly more general. -/\ntheorem measurable_measure_prod_mk_left_finite [is_finite_measure ν] {s : set (α × β)} (hs : measurable_set s) :\n    measurable fun x => ν («expr ⁻¹' » (prod.mk x) s) :=\n  by\n  refine' induction_on_inter generate_from_prod.symm is_pi_system_prod _ _ _ _ hs\n  · simp [measurable_zero, const_def]\n  · rintro _ ⟨s, t, hs, ht, rfl⟩\n    simp only [mk_preimage_prod_right_eq_if, measure_if]\n    exact measurable_const.indicator hs\n  · intro t ht h2t\n    simp_rw [preimage_compl, measure_compl (measurable_prod_mk_left ht) (measure_ne_top ν _)]\n    exact h2t.const_sub _\n  · intro f h1f h2f h3f\n    simp_rw [preimage_Union]\n    have :\n      ∀ b,\n        ν\n            («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n              («expr ⁻¹' » (prod.mk b) (f i))) =\n          «expr∑' , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , »\"\n            (ν («expr ⁻¹' » (prod.mk b) (f i))) :=\n      fun b => measure_Union (fun i j hij => Disjoint.preimage _ (h1f hij)) fun i => measurable_prod_mk_left (h2f i)\n    simp_rw [this]\n    apply measurable.ennreal_tsum h3f\n#align measurable_measure_prod_mk_left_finite measurable_measure_prod_mk_left_finite\n\n",
 "measurable_measure_prod_mk_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/-- If `ν` is a σ-finite measure, and `s ⊆ α × β` is measurable, then `x ↦ ν { y | (x, y) ∈ s }` is\n  a measurable function. -/\ntheorem measurable_measure_prod_mk_left [sigma_finite ν] {s : set (α × β)} (hs : measurable_set s) :\n    measurable fun x => ν («expr ⁻¹' » (prod.mk x) s) :=\n  by\n  have : ∀ x, measurable_set («expr ⁻¹' » (prod.mk x) s) := fun x => measurable_prod_mk_left hs\n  simp only [← @supr_restrict_spanning_sets _ _ ν, this]\n  apply measurable_supr; intro i\n  haveI := fact.mk (measure_spanning_sets_lt_top ν i)\n  exact measurable_measure_prod_mk_left_finite hs\n#align measurable_measure_prod_mk_left measurable_measure_prod_mk_left\n\n",
 "map_prod_mk_right":
 "theorem measurable.map_prod_mk_right {μ : measure α} [sigma_finite μ] :\n    measurable fun y : β => map (fun x : α => (x, y)) μ :=\n  by\n  apply measurable_of_measurable_coe; intro s hs\n  simp_rw [map_apply measurable_prod_mk_right hs]\n  exact measurable_measure_prod_mk_right hs\n#align measurable.map_prod_mk_right measurable.map_prod_mk_right\n\n",
 "map_prod_mk_left":
 "theorem measurable.map_prod_mk_left [sigma_finite ν] : measurable fun x : α => map (prod.mk x) ν :=\n  by\n  apply measurable_of_measurable_coe; intro s hs\n  simp_rw [map_apply measurable_prod_mk_left hs]\n  exact measurable_measure_prod_mk_left hs\n#align measurable.map_prod_mk_left measurable.map_prod_mk_left\n\n",
 "map_prod_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem map_prod_map {δ} [measurable_space δ] {f : α → β} {g : γ → δ} {μa : measure α} {μc : measure γ}\n    (hfa : sigma_finite (map f μa)) (hgc : sigma_finite (map g μc)) (hf : measurable f) (hg : measurable g) :\n    (map f μa).prod (map g μc) = map (prod.map f g) (μa.prod μc) :=\n  by\n  haveI := hgc.of_map μc hg.ae_measurable\n  refine' prod_eq fun s t hs ht => _\n  rw [map_apply (hf.prod_map hg) (hs.prod ht), map_apply hf hs, map_apply hg ht]\n  exact prod_prod («expr ⁻¹' » f s) («expr ⁻¹' » g t)\n#align map_prod_map map_prod_map\n\n",
 "lintegral_prod_symm'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫⁻ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫⁻ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫⁻ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ , ∂ » -/\n/-- The symmetric verion of Tonelli's Theorem: For `ℝ≥0∞`-valued measurable\nfunctions on `α × β`,  the integral of `f` is equal to the iterated integral, in reverse order. -/\ntheorem lintegral_prod_symm' [sigma_finite μ] (f : α × β → ennreal) (hf : measurable f) :\n    «expr∫⁻ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ , ∂ »\" (f z)\n        (μ.prod ν) =\n      «expr∫⁻ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ , ∂ »\"\n        («expr∫⁻ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ , ∂ »\"\n          (f (x, y)) μ)\n        ν :=\n  lintegral_prod_symm f hf.ae_measurable\n#align lintegral_prod_symm' lintegral_prod_symm'\n\n",
 "lintegral_prod_symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫⁻ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫⁻ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫⁻ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ , ∂ » -/\n/-- The symmetric verion of Tonelli's Theorem: For `ℝ≥0∞`-valued almost everywhere measurable\nfunctions on `α × β`,  the integral of `f` is equal to the iterated integral, in reverse order. -/\ntheorem lintegral_prod_symm [sigma_finite μ] (f : α × β → ennreal) (hf : ae_measurable f (μ.prod ν)) :\n    «expr∫⁻ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ , ∂ »\" (f z)\n        (μ.prod ν) =\n      «expr∫⁻ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ , ∂ »\"\n        («expr∫⁻ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ , ∂ »\"\n          (f (x, y)) μ)\n        ν :=\n  by\n  simp_rw [← lintegral_prod_swap f hf]\n  exact lintegral_prod _ hf.prod_swap\n#align lintegral_prod_symm lintegral_prod_symm\n\n",
 "lintegral_prod_swap":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫⁻ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫⁻ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ , ∂ » -/\ntheorem lintegral_prod_swap [sigma_finite μ] (f : α × β → ennreal) (hf : ae_measurable f (μ.prod ν)) :\n    «expr∫⁻ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ , ∂ »\" (f z.swap)\n        (ν.prod μ) =\n      «expr∫⁻ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ , ∂ »\" (f z)\n        (μ.prod ν) :=\n  by\n  rw [← prod_swap] at hf\n  rw [← lintegral_map' hf measurable_swap.ae_measurable, prod_swap]\n#align lintegral_prod_swap lintegral_prod_swap\n\n",
 "lintegral_prod_right'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫⁻ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ , ∂ » -/\n/-- The Lebesgue integral is measurable. This shows that the integrand of (the right-hand-side of)\n  Tonelli's theorem is measurable. -/\ntheorem measurable.lintegral_prod_right' [sigma_finite ν] :\n    ∀ {f : α × β → ennreal} (hf : measurable f),\n      measurable fun x =>\n        «expr∫⁻ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ , ∂ »\" (f (x, y))\n          ν :=\n  by\n  have m := @measurable_prod_mk_left\n  refine' measurable.ennreal_induction _ _ _\n  · intro c s hs\n    simp only [← indicator_comp_right]\n    suffices measurable fun x => c * ν («expr ⁻¹' » (prod.mk x) s) by simpa [lintegral_indicator _ (m hs)]\n    exact (measurable_measure_prod_mk_left hs).const_mul _\n  · rintro f g - hf hg h2f h2g\n    simp_rw [pi.add_apply, lintegral_add_left (hf.comp m)]\n    exact h2f.add h2g\n  · intro f hf h2f h3f\n    have := measurable_supr h3f\n    have : ∀ x, monotone fun n y => f n (x, y) := fun x i j hij y => h2f hij (x, y)\n    simpa [lintegral_supr fun n => (hf n).comp m, this]\n#align measurable.lintegral_prod_right' measurable.lintegral_prod_right'\n\n",
 "lintegral_prod_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫⁻ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ , ∂ » -/\n/-- The Lebesgue integral is measurable. This shows that the integrand of (the right-hand-side of)\n  Tonelli's theorem is measurable.\n  This version has the argument `f` in curried form. -/\ntheorem measurable.lintegral_prod_right [sigma_finite ν] {f : α → β → ennreal} (hf : measurable (uncurry f)) :\n    measurable fun x =>\n      «expr∫⁻ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ , ∂ »\" (f x y) ν :=\n  hf.lintegral_prod_right'\n#align measurable.lintegral_prod_right measurable.lintegral_prod_right\n\n",
 "lintegral_prod_of_measurable":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫⁻ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫⁻ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫⁻ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫⁻ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫⁻ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ , ∂ » -/\n/-- **Tonelli's Theorem**: For `ℝ≥0∞`-valued measurable functions on `α × β`,\n  the integral of `f` is equal to the iterated integral. -/\ntheorem lintegral_prod_of_measurable :\n    ∀ (f : α × β → ennreal) (hf : measurable f),\n      «expr∫⁻ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ , ∂ »\" (f z)\n          (μ.prod ν) =\n        «expr∫⁻ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ , ∂ »\"\n          («expr∫⁻ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ , ∂ »\"\n            (f (x, y)) ν)\n          μ :=\n  by\n  have m := @measurable_prod_mk_left\n  refine' measurable.ennreal_induction _ _ _\n  · intro c s hs\n    simp only [← indicator_comp_right]\n    simp [lintegral_indicator, m hs, hs, lintegral_const_mul, measurable_measure_prod_mk_left hs, prod_apply]\n  · rintro f g - hf hg h2f h2g\n    simp [lintegral_add_left, measurable.lintegral_prod_right', hf.comp m, hf, h2f, h2g]\n  · intro f hf h2f h3f\n    have kf : ∀ x n, measurable fun y => f n (x, y) := fun x n => (hf n).comp m\n    have k2f : ∀ x, monotone fun n y => f n (x, y) := fun x i j hij y => h2f hij (x, y)\n    have lf :\n      ∀ n,\n        measurable fun x =>\n          «expr∫⁻ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ , ∂ »\"\n            (f n (x, y)) ν :=\n      fun n => (hf n).lintegral_prod_right'\n    have l2f :\n      monotone fun n x =>\n        «expr∫⁻ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ , ∂ »\"\n          (f n (x, y)) ν :=\n      fun i j hij x => lintegral_mono (k2f x hij)\n    simp only [lintegral_supr hf h2f, lintegral_supr (kf _), k2f, lintegral_supr lf l2f, h3f]\n#align lintegral_prod_of_measurable lintegral_prod_of_measurable\n\n",
 "lintegral_prod_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫⁻ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫⁻ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫⁻ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ , ∂ » -/\ntheorem lintegral_prod_mul {f : α → ennreal} {g : β → ennreal} (hf : ae_measurable f μ) (hg : ae_measurable g ν) :\n    «expr∫⁻ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ , ∂ »\"\n        (f z.1 * g z.2) (μ.prod ν) =\n      «expr∫⁻ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ , ∂ »\" (f x) μ *\n        «expr∫⁻ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ , ∂ »\" (g y) ν :=\n  by simp [lintegral_prod _ (hf.fst.mul hg.snd), lintegral_lintegral_mul hf hg]\n#align lintegral_prod_mul lintegral_prod_mul\n\n",
 "lintegral_prod_left'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫⁻ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ , ∂ » -/\n/-- The Lebesgue integral is measurable. This shows that the integrand of (the right-hand-side of)\n  the symmetric version of Tonelli's theorem is measurable. -/\ntheorem measurable.lintegral_prod_left' [sigma_finite μ] {f : α × β → ennreal} (hf : measurable f) :\n    measurable fun y =>\n      «expr∫⁻ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ , ∂ »\" (f (x, y))\n        μ :=\n  (measurable_swap_iff.mpr hf).lintegral_prod_right'\n#align measurable.lintegral_prod_left' measurable.lintegral_prod_left'\n\n",
 "lintegral_prod_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫⁻ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ , ∂ » -/\n/-- The Lebesgue integral is measurable. This shows that the integrand of (the right-hand-side of)\n  the symmetric version of Tonelli's theorem is measurable.\n  This version has the argument `f` in curried form. -/\ntheorem measurable.lintegral_prod_left [sigma_finite μ] {f : α → β → ennreal} (hf : measurable (uncurry f)) :\n    measurable fun y =>\n      «expr∫⁻ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ , ∂ »\" (f x y) μ :=\n  hf.lintegral_prod_left'\n#align measurable.lintegral_prod_left measurable.lintegral_prod_left\n\n",
 "lintegral_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫⁻ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫⁻ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫⁻ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫⁻ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫⁻ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫⁻ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫⁻ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫⁻ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫⁻ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ , ∂ » -/\n/-- **Tonelli's Theorem**: For `ℝ≥0∞`-valued almost everywhere measurable functions on `α × β`,\n  the integral of `f` is equal to the iterated integral. -/\ntheorem lintegral_prod (f : α × β → ennreal) (hf : ae_measurable f (μ.prod ν)) :\n    «expr∫⁻ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ , ∂ »\" (f z)\n        (μ.prod ν) =\n      «expr∫⁻ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ , ∂ »\"\n        («expr∫⁻ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ , ∂ »\"\n          (f (x, y)) ν)\n        μ :=\n  by\n  have A :\n    «expr∫⁻ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ , ∂ »\" (f z)\n        (μ.prod ν) =\n      «expr∫⁻ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ , ∂ »\" (hf.mk f z)\n        (μ.prod ν) :=\n    lintegral_congr_ae hf.ae_eq_mk\n  have B :\n    «expr∫⁻ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ , ∂ »\"\n        («expr∫⁻ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ , ∂ »\"\n          (f (x, y)) ν)\n        μ =\n      «expr∫⁻ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ , ∂ »\"\n        («expr∫⁻ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ , ∂ »\"\n          (hf.mk f (x, y)) ν)\n        μ :=\n    by\n    apply lintegral_congr_ae\n    filter_upwards [ae_ae_of_ae_prod hf.ae_eq_mk] with _ ha using lintegral_congr_ae ha\n  rw [A, B, lintegral_prod_of_measurable _ hf.measurable_mk]\n  infer_instance\n#align lintegral_prod lintegral_prod\n\n",
 "lintegral_lintegral_symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫⁻ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫⁻ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫⁻ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ , ∂ » -/\n/-- The reversed version of **Tonelli's Theorem** (symmetric version). In this version `f` is in\ncurried form, which makes it easier for the elaborator to figure out `f` automatically. -/\ntheorem lintegral_lintegral_symm [sigma_finite μ] ⦃f : α → β → ennreal⦄ (hf : ae_measurable (uncurry f) (μ.prod ν)) :\n    «expr∫⁻ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ , ∂ »\"\n        («expr∫⁻ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ , ∂ »\" (f x y)\n          ν)\n        μ =\n      «expr∫⁻ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ , ∂ »\" (f z.2 z.1)\n        (ν.prod μ) :=\n  (lintegral_prod_symm _ hf.prod_swap).symm\n#align lintegral_lintegral_symm lintegral_lintegral_symm\n\n",
 "lintegral_lintegral_swap":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫⁻ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫⁻ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫⁻ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫⁻ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ , ∂ » -/\n/-- Change the order of Lebesgue integration. -/\ntheorem lintegral_lintegral_swap [sigma_finite μ] ⦃f : α → β → ennreal⦄ (hf : ae_measurable (uncurry f) (μ.prod ν)) :\n    «expr∫⁻ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ , ∂ »\"\n        («expr∫⁻ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ , ∂ »\" (f x y)\n          ν)\n        μ =\n      «expr∫⁻ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ , ∂ »\"\n        («expr∫⁻ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ , ∂ »\" (f x y)\n          μ)\n        ν :=\n  (lintegral_lintegral hf).trans (lintegral_prod_symm _ hf)\n#align lintegral_lintegral_swap lintegral_lintegral_swap\n\n",
 "lintegral_lintegral":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫⁻ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫⁻ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫⁻ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ , ∂ » -/\n/-- The reversed version of **Tonelli's Theorem**. In this version `f` is in curried form, which\nmakes it easier for the elaborator to figure out `f` automatically. -/\ntheorem lintegral_lintegral ⦃f : α → β → ennreal⦄ (hf : ae_measurable (uncurry f) (μ.prod ν)) :\n    «expr∫⁻ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ , ∂ »\"\n        («expr∫⁻ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ , ∂ »\" (f x y)\n          ν)\n        μ =\n      «expr∫⁻ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ , ∂ »\" (f z.1 z.2)\n        (μ.prod ν) :=\n  (lintegral_prod _ hf).symm\n#align lintegral_lintegral lintegral_lintegral\n\n",
 "lintegral_fn_integral_sub":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫⁻ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫⁻ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ » -/\n/-- Integrals commute with subtraction inside a lower Lebesgue integral.\n  `F` can be any function. -/\ntheorem lintegral_fn_integral_sub ⦃f g : α × β → E⦄ (F : E → ennreal) (hf : integrable f (μ.prod ν))\n    (hg : integrable g (μ.prod ν)) :\n    «expr∫⁻ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ , ∂ »\"\n        (F\n          («expr∫ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ »\"\n            (f (x, y) - g (x, y)) ν))\n        μ =\n      «expr∫⁻ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ , ∂ »\"\n        (F\n          («expr∫ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ »\"\n              (f (x, y)) ν -\n            «expr∫ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ »\"\n              (g (x, y)) ν))\n        μ :=\n  by\n  refine' lintegral_congr_ae _\n  filter_upwards [hf.prod_right_ae, hg.prod_right_ae] with _ h2f h2g\n  simp [integral_sub h2f h2g]\n#align lintegral_fn_integral_sub lintegral_fn_integral_sub\n\n",
 "is_pi_system_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:228:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:219:4: warning: unsupported binary notation `lower_set.prod -/\n/-- Rectangles form a π-system. -/\ntheorem is_pi_system_prod :\n    is_pi_system (image2 (lower_set.prod · ·) { s : set α | measurable_set s } { t : set β | measurable_set t }) :=\n  is_pi_system_measurable_set.prod is_pi_system_measurable_set\n#align is_pi_system_prod is_pi_system_prod\n\n",
 "integral_prod_symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ » -/\n/-- Symmetric version of **Fubini's Theorem**: For integrable functions on `α × β`,\n  the Bochner integral of `f` is equal to the iterated Bochner integral.\n  This version has the integrals on the right-hand side in the other order. -/\ntheorem integral_prod_symm (f : α × β → E) (hf : integrable f (μ.prod ν)) :\n    «expr∫ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ »\" (f z)\n        (μ.prod ν) =\n      «expr∫ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ »\"\n        («expr∫ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ »\" (f (x, y))\n          μ)\n        ν :=\n  by\n  simp_rw [← integral_prod_swap f hf.ae_strongly_measurable]\n  exact integral_prod _ hf.swap\n#align integral_prod_symm integral_prod_symm\n\n",
 "integral_prod_swap":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ » -/\ntheorem integral_prod_swap (f : α × β → E) (hf : ae_strongly_measurable f (μ.prod ν)) :\n    «expr∫ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ »\" (f z.swap)\n        (ν.prod μ) =\n      «expr∫ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ »\" (f z)\n        (μ.prod ν) :=\n  by\n  rw [← prod_swap] at hf\n  rw [← integral_map measurable_swap.ae_measurable hf, prod_swap]\n#align integral_prod_swap integral_prod_swap\n\n",
 "integral_prod_right'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ » -/\n/-- The Bochner integral is a.e.-measurable.\n  This shows that the integrand of (the right-hand-side of) Fubini's theorem is a.e.-measurable. -/\ntheorem measure_theory.ae_strongly_measurable.integral_prod_right' [sigma_finite ν] [normed_space (exprℝ) E]\n    [complete_space E] ⦃f : α × β → E⦄ (hf : ae_strongly_measurable f (μ.prod ν)) :\n    ae_strongly_measurable\n      (fun x =>\n        «expr∫ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ »\" (f (x, y))\n          ν)\n      μ :=\n  ⟨fun x =>\n    «expr∫ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ »\" (hf.mk f (x, y))\n      ν,\n    hf.strongly_measurable_mk.integral_prod_right', by\n    filter_upwards [ae_ae_of_ae_prod hf.ae_eq_mk] with _ hx using integral_congr_ae hx⟩\n#align\n  measure_theory.ae_strongly_measurable.integral_prod_right' measure_theory.ae_strongly_measurable.integral_prod_right'\n\n",
 "integral_prod_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ » -/\ntheorem integrable.integral_prod_right [sigma_finite μ] ⦃f : α × β → E⦄ (hf : integrable f (μ.prod ν)) :\n    integrable\n      (fun y =>\n        «expr∫ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ »\" (f (x, y))\n          μ)\n      ν :=\n  hf.swap.integral_prod_left\n#align integrable.integral_prod_right integrable.integral_prod_right\n\n",
 "integral_prod_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ » -/\ntheorem integral_prod_mul {L : Type _} [is_R_or_C L] (f : α → L) (g : β → L) :\n    «expr∫ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ »\" (f z.1 * g z.2)\n        (μ.prod ν) =\n      «expr∫ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ »\" (f x) μ *\n        «expr∫ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ »\" (g y) ν :=\n  by\n  by_cases h : integrable (fun z : α × β => f z.1 * g z.2) (μ.prod ν)\n  · rw [integral_prod _ h]\n    simp_rw [integral_mul_left, integral_mul_right]\n  have H : ¬integrable f μ ∨ ¬integrable g ν := by\n    contrapose! h\n    exact integrable_prod_mul h.1 h.2\n  cases H <;> simp [integral_undef h, integral_undef H]\n#align integral_prod_mul integral_prod_mul\n\n",
 "integral_prod_left'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ » -/\n/-- The Bochner integral is measurable. This shows that the integrand of (the right-hand-side of)\n  the symmetric version of Fubini's theorem is measurable. -/\ntheorem measure_theory.strongly_measurable.integral_prod_left' [sigma_finite μ] ⦃f : α × β → E⦄\n    (hf : strongly_measurable f) :\n    strongly_measurable fun y =>\n      «expr∫ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ »\" (f (x, y))\n        μ :=\n  (hf.comp_measurable measurable_swap).integral_prod_right'\n#align measure_theory.strongly_measurable.integral_prod_left' measure_theory.strongly_measurable.integral_prod_left'\n\n",
 "integral_prod_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ » -/\ntheorem integrable.integral_prod_left ⦃f : α × β → E⦄ (hf : integrable f (μ.prod ν)) :\n    integrable\n      (fun x =>\n        «expr∫ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ »\" (f (x, y))\n          ν)\n      μ :=\n  integrable.mono hf.integral_norm_prod_left hf.ae_strongly_measurable.integral_prod_right' <|\n    eventually_of_forall fun x =>\n      (norm_integral_le_integral_norm _).trans_eq <|\n        (norm_of_nonneg <| integral_nonneg_of_ae <| eventually_of_forall fun y => (norm_nonneg (f (x, y)) : _)).symm\n#align integrable.integral_prod_left integrable.integral_prod_left\n\n",
 "integral_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ » -/\n/-- **Fubini's Theorem**: For integrable functions on `α × β`,\n  the Bochner integral of `f` is equal to the iterated Bochner integral.\n  `integrable_prod_iff` can be useful to show that the function in question in integrable.\n  `measure_theory.integrable.integral_prod_right` is useful to show that the inner integral\n  of the right-hand side is integrable. -/\ntheorem integral_prod :\n    ∀ (f : α × β → E) (hf : integrable f (μ.prod ν)),\n      «expr∫ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ »\" (f z)\n          (μ.prod ν) =\n        «expr∫ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ »\"\n          («expr∫ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ »\"\n            (f (x, y)) ν)\n          μ :=\n  by\n  apply integrable.induction\n  · intro c s hs h2s\n    simp_rw [integral_indicator hs, ← indicator_comp_right, function.comp,\n      integral_indicator (measurable_prod_mk_left hs), set_integral_const, integral_smul_const,\n      integral_to_real (measurable_measure_prod_mk_left hs).ae_measurable (ae_measure_lt_top hs h2s.ne), prod_apply hs]\n  · intro f g hfg i_f i_g hf hg\n    simp_rw [integral_add' i_f i_g, integral_integral_add' i_f i_g, hf, hg]\n  · exact is_closed_eq continuous_integral continuous_integral_integral\n  · intro f g hfg i_f hf\n    convert hf using 1\n    · exact integral_congr_ae hfg.symm\n    · refine' integral_congr_ae _\n      refine' (ae_ae_of_ae_prod hfg).mp _\n      apply eventually_of_forall\n      intro x hfgx\n      exact integral_congr_ae (ae_eq_symm hfgx)\n#align integral_prod integral_prod\n\n",
 "integral_norm_prod_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem integrable.integral_norm_prod_right [sigma_finite μ] ⦃f : α × β → E⦄ (hf : integrable f (μ.prod ν)) :\n    integrable\n      (fun y =>\n        «expr∫ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ »\"\n          («expr‖ ‖» (f (x, y))) μ)\n      ν :=\n  hf.swap.integral_norm_prod_left\n#align integrable.integral_norm_prod_right integrable.integral_norm_prod_right\n\n",
 "integral_norm_prod_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem integrable.integral_norm_prod_left ⦃f : α × β → E⦄ (hf : integrable f (μ.prod ν)) :\n    integrable\n      (fun x =>\n        «expr∫ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ »\"\n          («expr‖ ‖» (f (x, y))) ν)\n      μ :=\n  ((integrable_prod_iff hf.ae_strongly_measurable).mp hf).2\n#align integrable.integral_norm_prod_left integrable.integral_norm_prod_left\n\n",
 "integral_integral_symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ » -/\n/-- Reversed version of **Fubini's Theorem** (symmetric version). -/\ntheorem integral_integral_symm {f : α → β → E} (hf : integrable (uncurry f) (μ.prod ν)) :\n    «expr∫ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ »\"\n        («expr∫ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ »\" (f x y) ν)\n        μ =\n      «expr∫ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ »\" (f z.2 z.1)\n        (ν.prod μ) :=\n  (integral_prod_symm _ hf.swap).symm\n#align integral_integral_symm integral_integral_symm\n\n",
 "integral_integral_swap":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ » -/\n/-- Change the order of Bochner integration. -/\ntheorem integral_integral_swap ⦃f : α → β → E⦄ (hf : integrable (uncurry f) (μ.prod ν)) :\n    «expr∫ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ »\"\n        («expr∫ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ »\" (f x y) ν)\n        μ =\n      «expr∫ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ »\"\n        («expr∫ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ »\" (f x y) μ)\n        ν :=\n  (integral_integral hf).trans (integral_prod_symm _ hf)\n#align integral_integral_swap integral_integral_swap\n\n",
 "integral_integral_sub'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ » -/\n/-- Double integrals commute with subtraction. This is the version with `(f - g) (x, y)`\n  (instead of `f (x, y) - g (x, y)`) in the LHS. -/\ntheorem integral_integral_sub' ⦃f g : α × β → E⦄ (hf : integrable f (μ.prod ν)) (hg : integrable g (μ.prod ν)) :\n    «expr∫ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ »\"\n        («expr∫ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ »\"\n          ((f - g) (x, y)) ν)\n        μ =\n      «expr∫ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ »\"\n          («expr∫ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ »\"\n            (f (x, y)) ν)\n          μ -\n        «expr∫ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ »\"\n          («expr∫ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ »\"\n            (g (x, y)) ν)\n          μ :=\n  integral_integral_sub hf hg\n#align integral_integral_sub' integral_integral_sub'\n\n",
 "integral_integral_sub":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ » -/\n/-- Double integrals commute with subtraction. -/\ntheorem integral_integral_sub ⦃f g : α × β → E⦄ (hf : integrable f (μ.prod ν)) (hg : integrable g (μ.prod ν)) :\n    «expr∫ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ »\"\n        («expr∫ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ »\"\n          (f (x, y) - g (x, y)) ν)\n        μ =\n      «expr∫ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ »\"\n          («expr∫ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ »\"\n            (f (x, y)) ν)\n          μ -\n        «expr∫ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ »\"\n          («expr∫ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ »\"\n            (g (x, y)) ν)\n          μ :=\n  (integral_fn_integral_sub id hf hg).trans <| integral_sub hf.integral_prod_left hg.integral_prod_left\n#align integral_integral_sub integral_integral_sub\n\n",
 "integral_integral_add'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ » -/\n/-- Double integrals commute with addition. This is the version with `(f + g) (x, y)`\n  (instead of `f (x, y) + g (x, y)`) in the LHS. -/\ntheorem integral_integral_add' ⦃f g : α × β → E⦄ (hf : integrable f (μ.prod ν)) (hg : integrable g (μ.prod ν)) :\n    «expr∫ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ »\"\n        («expr∫ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ »\"\n          ((f + g) (x, y)) ν)\n        μ =\n      «expr∫ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ »\"\n          («expr∫ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ »\"\n            (f (x, y)) ν)\n          μ +\n        «expr∫ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ »\"\n          («expr∫ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ »\"\n            (g (x, y)) ν)\n          μ :=\n  integral_integral_add hf hg\n#align integral_integral_add' integral_integral_add'\n\n",
 "integral_integral_add":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ » -/\n/-- Double integrals commute with addition. -/\ntheorem integral_integral_add ⦃f g : α × β → E⦄ (hf : integrable f (μ.prod ν)) (hg : integrable g (μ.prod ν)) :\n    «expr∫ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ »\"\n        («expr∫ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ »\"\n          (f (x, y) + g (x, y)) ν)\n        μ =\n      «expr∫ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ »\"\n          («expr∫ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ »\"\n            (f (x, y)) ν)\n          μ +\n        «expr∫ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ »\"\n          («expr∫ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ »\"\n            (g (x, y)) ν)\n          μ :=\n  (integral_fn_integral_add id hf hg).trans <| integral_add hf.integral_prod_left hg.integral_prod_left\n#align integral_integral_add integral_integral_add\n\n",
 "integral_integral":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ » -/\n/-- Reversed version of **Fubini's Theorem**. -/\ntheorem integral_integral {f : α → β → E} (hf : integrable (uncurry f) (μ.prod ν)) :\n    «expr∫ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ »\"\n        («expr∫ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ »\" (f x y) ν)\n        μ =\n      «expr∫ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ »\" (f z.1 z.2)\n        (μ.prod ν) :=\n  (integral_prod _ hf).symm\n#align integral_integral integral_integral\n\n",
 "integral_fn_integral_sub":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ » -/\n/-- Integrals commute with subtraction inside another integral.\n  `F` can be any measurable function. -/\ntheorem integral_fn_integral_sub ⦃f g : α × β → E⦄ (F : E → E') (hf : integrable f (μ.prod ν))\n    (hg : integrable g (μ.prod ν)) :\n    «expr∫ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ »\"\n        (F\n          («expr∫ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ »\"\n            (f (x, y) - g (x, y)) ν))\n        μ =\n      «expr∫ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ »\"\n        (F\n          («expr∫ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ »\"\n              (f (x, y)) ν -\n            «expr∫ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ »\"\n              (g (x, y)) ν))\n        μ :=\n  by\n  refine' integral_congr_ae _\n  filter_upwards [hf.prod_right_ae, hg.prod_right_ae] with _ h2f h2g\n  simp [integral_sub h2f h2g]\n#align integral_fn_integral_sub integral_fn_integral_sub\n\n",
 "integral_fn_integral_add":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ » -/\n/-- Integrals commute with addition inside another integral. `F` can be any function. -/\ntheorem integral_fn_integral_add ⦃f g : α × β → E⦄ (F : E → E') (hf : integrable f (μ.prod ν))\n    (hg : integrable g (μ.prod ν)) :\n    «expr∫ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ »\"\n        (F\n          («expr∫ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ »\"\n            (f (x, y) + g (x, y)) ν))\n        μ =\n      «expr∫ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ »\"\n        (F\n          («expr∫ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ »\"\n              (f (x, y)) ν +\n            «expr∫ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ »\"\n              (g (x, y)) ν))\n        μ :=\n  by\n  refine' integral_congr_ae _\n  filter_upwards [hf.prod_right_ae, hg.prod_right_ae] with _ h2f h2g\n  simp [integral_add h2f h2g]\n#align integral_fn_integral_add integral_fn_integral_add\n\n",
 "integrable_swap_iff":
 "theorem integrable_swap_iff [sigma_finite μ] ⦃f : α × β → E⦄ :\n    integrable (f ∘ prod.swap) (ν.prod μ) ↔ integrable f (μ.prod ν) :=\n  ⟨fun hf => by\n    convert hf.swap\n    ext ⟨x, y⟩\n    rfl, fun hf => hf.swap⟩\n#align integrable_swap_iff integrable_swap_iff\n\n",
 "integrable_prod_mul":
 "theorem integrable_prod_mul {L : Type _} [is_R_or_C L] {f : α → L} {g : β → L} (hf : integrable f μ)\n    (hg : integrable g ν) : integrable (fun z : α × β => f z.1 * g z.2) (μ.prod ν) :=\n  by\n  refine' (integrable_prod_iff _).2 ⟨_, _⟩\n  · exact hf.1.fst.mul hg.1.snd\n  · exact eventually_of_forall fun x => hg.const_mul (f x)\n  · simpa only [norm_mul, integral_mul_left] using hf.norm.mul_const _\n#align integrable_prod_mul integrable_prod_mul\n\n",
 "integrable_prod_iff'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/-- A binary function is integrable if the function `x ↦ f (x, y)` is integrable for almost every\n  `y` and the function `y ↦ ∫ ‖f (x, y)‖ dx` is integrable. -/\ntheorem integrable_prod_iff' [sigma_finite μ] ⦃f : α × β → E⦄ (h1f : ae_strongly_measurable f (μ.prod ν)) :\n    integrable f (μ.prod ν) ↔\n      «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\" ν\n          (integrable (fun x => f (x, y)) μ) ∧\n        integrable\n          (fun y =>\n            «expr∫ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ »\"\n              («expr‖ ‖» (f (x, y))) μ)\n          ν :=\n  by\n  convert integrable_prod_iff h1f.prod_swap using 1\n  rw [integrable_swap_iff]\n#align integrable_prod_iff' integrable_prod_iff'\n\n",
 "integrable_prod_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/-- A binary function is integrable if the function `y ↦ f (x, y)` is integrable for almost every\n  `x` and the function `x ↦ ∫ ‖f (x, y)‖ dy` is integrable. -/\ntheorem integrable_prod_iff ⦃f : α × β → E⦄ (h1f : ae_strongly_measurable f (μ.prod ν)) :\n    integrable f (μ.prod ν) ↔\n      «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\" μ\n          (integrable (fun y => f (x, y)) ν) ∧\n        integrable\n          (fun x =>\n            «expr∫ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ »\"\n              («expr‖ ‖» (f (x, y))) ν)\n          μ :=\n  by simp [integrable, h1f, has_finite_integral_prod_iff', h1f.norm.integral_prod_right', h1f.prod_mk_left]\n#align integrable_prod_iff integrable_prod_iff\n\n",
 "integrable_measure_prod_mk_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem integrable_measure_prod_mk_left {s : set (α × β)} (hs : measurable_set s) (h2s : (μ.prod ν) s ≠ ennreal.top) :\n    integrable (fun x => (ν («expr ⁻¹' » (prod.mk x) s)).to_real) μ :=\n  by\n  refine' ⟨(measurable_measure_prod_mk_left hs).ennreal_to_real.ae_measurable.ae_strongly_measurable, _⟩\n  simp_rw [has_finite_integral, ennnorm_eq_of_real to_real_nonneg]\n  convert h2s.lt_top using 1; simp_rw [prod_apply hs]; apply lintegral_congr_ae\n  refine' (ae_measure_lt_top hs h2s).mp _; apply eventually_of_forall; intro x hx\n  rw [lt_top_iff_ne_top] at hx; simp [of_real_to_real, hx]\n#align integrable_measure_prod_mk_left integrable_measure_prod_mk_left\n\n",
 "has_finite_integral_prod_iff'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem has_finite_integral_prod_iff' ⦃f : α × β → E⦄ (h1f : ae_strongly_measurable f (μ.prod ν)) :\n    has_finite_integral f (μ.prod ν) ↔\n      «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\" μ\n          (has_finite_integral (fun y => f (x, y)) ν) ∧\n        has_finite_integral\n          (fun x =>\n            «expr∫ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ »\"\n              («expr‖ ‖» (f (x, y))) ν)\n          μ :=\n  by\n  rw [has_finite_integral_congr h1f.ae_eq_mk, has_finite_integral_prod_iff h1f.strongly_measurable_mk]\n  apply and_congr\n  · apply eventually_congr\n    filter_upwards [ae_ae_of_ae_prod h1f.ae_eq_mk.symm]\n    intro x hx\n    exact has_finite_integral_congr hx\n  · apply has_finite_integral_congr\n    filter_upwards [ae_ae_of_ae_prod h1f.ae_eq_mk.symm] with _ hx using integral_congr_ae (eventually_eq.fun_comp hx _)\n  · infer_instance\n#align has_finite_integral_prod_iff' has_finite_integral_prod_iff'\n\n",
 "has_finite_integral_prod_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem has_finite_integral_prod_iff ⦃f : α × β → E⦄ (h1f : strongly_measurable f) :\n    has_finite_integral f (μ.prod ν) ↔\n      «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\" μ\n          (has_finite_integral (fun y => f (x, y)) ν) ∧\n        has_finite_integral\n          (fun x =>\n            «expr∫ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ »\"\n              («expr‖ ‖» (f (x, y))) ν)\n          μ :=\n  by\n  simp only [has_finite_integral, lintegral_prod_of_measurable _ h1f.ennnorm]\n  have :\n    ∀ x,\n      «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\" ν\n        (0 ≤ «expr‖ ‖» (f (x, y))) :=\n    fun x => eventually_of_forall fun y => norm_nonneg _\n  simp_rw [integral_eq_lintegral_of_nonneg_ae (this _)\n      (h1f.norm.comp_measurable measurable_prod_mk_left).ae_strongly_measurable,\n    ennnorm_eq_of_real to_real_nonneg, of_real_norm_eq_coe_nnnorm]\n  -- this fact is probably too specialized to be its own lemma\n  have : ∀ {p q r : Prop} (h1 : r → p), (r ↔ p ∧ q) ↔ p → (r ↔ q) := fun p q r h1 => by\n    rw [← and_congr_right_iff, and_iff_right_of_imp h1]\n  rw [this]\n  · intro h2f\n    rw [lintegral_congr_ae]\n    refine' h2f.mp _\n    apply eventually_of_forall\n    intro x hx\n    dsimp only\n    rw [of_real_to_real]\n    rw [← lt_top_iff_ne_top]\n    exact hx\n  · intro h2f\n    refine' ae_lt_top _ h2f.ne\n    exact h1f.ennnorm.lintegral_prod_right'\n#align has_finite_integral_prod_iff has_finite_integral_prod_iff\n\n",
 "generate_from_prod_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:228:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:219:4: warning: unsupported binary notation `lower_set.prod -/\n/-- The product of generated σ-algebras is the one generated by rectangles, if both generating sets\n  are countably spanning. -/\ntheorem generate_from_prod_eq {α β} {C : set (set α)} {D : set (set β)} (hC : is_countably_spanning C)\n    (hD : is_countably_spanning D) :\n    @prod.measurable_space _ _ (generate_from C) (generate_from D) = generate_from (image2 (lower_set.prod · ·) C D) :=\n  by\n  apply le_antisymm\n  · refine' sup_le _ _ <;> rw [comap_generate_from] <;> apply generate_from_le <;> rintro _ ⟨s, hs, rfl⟩\n    · rcases hD with ⟨t, h1t, h2t⟩\n      rw [← prod_univ, ← h2t, prod_Union]\n      apply measurable_set.Union\n      intro n\n      apply measurable_set_generate_from\n      exact ⟨s, t n, hs, h1t n, rfl⟩\n    · rcases hC with ⟨t, h1t, h2t⟩\n      rw [← univ_prod, ← h2t, Union_prod_const]\n      apply measurable_set.Union\n      rintro n\n      apply measurable_set_generate_from\n      exact mem_image2_of_mem (h1t n) hs\n  · apply generate_from_le\n    rintro _ ⟨s, t, hs, ht, rfl⟩\n    rw [prod_eq]\n    apply (measurable_fst _).inter (measurable_snd _)\n    · exact measurable_set_generate_from hs\n    · exact measurable_set_generate_from ht\n#align generate_from_prod_eq generate_from_prod_eq\n\n",
 "generate_from_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:228:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:219:4: warning: unsupported binary notation `lower_set.prod -/\n/-- The product σ-algebra is generated from boxes, i.e. `s ×ˢ t` for sets `s : set α` and\n  `t : set β`. -/\ntheorem generate_from_prod :\n    generate_from (image2 (lower_set.prod · ·) { s : set α | measurable_set s } { t : set β | measurable_set t }) =\n      prod.measurable_space :=\n  generate_from_eq_prod generate_from_measurable_set generate_from_measurable_set is_countably_spanning_measurable_set\n    is_countably_spanning_measurable_set\n#align generate_from_prod generate_from_prod\n\n",
 "generate_from_eq_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:228:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:219:4: warning: unsupported binary notation `lower_set.prod -/\n/-- If `C` and `D` generate the σ-algebras on `α` resp. `β`, then rectangles formed by `C` and `D`\n  generate the σ-algebra on `α × β`. -/\ntheorem generate_from_eq_prod {C : set (set α)} {D : set (set β)} (hC : generate_from C = ‹_›)\n    (hD : generate_from D = ‹_›) (h2C : is_countably_spanning C) (h2D : is_countably_spanning D) :\n    generate_from (image2 (lower_set.prod · ·) C D) = prod.measurable_space := by\n  rw [← hC, ← hD, generate_from_prod_eq h2C h2D]\n#align generate_from_eq_prod generate_from_eq_prod\n\n",
 "fst":
 "theorem measure_theory.ae_strongly_measurable.fst {γ} [topological_space γ] [sigma_finite ν] {f : α → γ}\n    (hf : ae_strongly_measurable f μ) : ae_strongly_measurable (fun z : α × β => f z.1) (μ.prod ν) :=\n  hf.comp_quasi_measure_preserving quasi_measure_preserving_fst\n#align measure_theory.ae_strongly_measurable.fst measure_theory.ae_strongly_measurable.fst\n\n",
 "dirac_prod_dirac":
 "theorem dirac_prod_dirac {x : α} {y : β} : (dirac x).prod (dirac y) = dirac (x, y) := by\n  rw [prod_dirac, map_dirac measurable_prod_mk_right]\n#align dirac_prod_dirac dirac_prod_dirac\n\n",
 "dirac_prod":
 "theorem dirac_prod (x : α) : (dirac x).prod ν = map (prod.mk x) ν :=\n  by\n  refine' prod_eq fun s t hs ht => _\n  simp_rw [map_apply measurable_prod_mk_left (hs.prod ht), mk_preimage_prod_right_eq_if, measure_if, dirac_apply' _ hs,\n    ← indicator_mul_left _ _ fun x => ν t, pi.one_apply, one_mul]\n#align dirac_prod dirac_prod\n\n",
 "continuous_integral_integral":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫⁻ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫⁻ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure_theory.L1 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫⁻ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫⁻ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure_theory.L1 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure_theory.L1 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ » -/\n/-- The map that sends an L¹-function `f : α × β → E` to `∫∫f` is continuous. -/\ntheorem continuous_integral_integral :\n    continuous fun f : measure_theory.L1 (α × β) (μ.prod ν) E =>\n      «expr∫ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ »\"\n        («expr∫ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ »\" (f (x, y))\n          ν)\n        μ :=\n  by\n  rw [continuous_iff_continuous_at]; intro g\n  refine'\n    tendsto_integral_of_L1 _ (L1.integrable_coe_fn g).integral_prod_left\n      (eventually_of_forall fun h => (L1.integrable_coe_fn h).integral_prod_left) _\n  simp_rw [←\n    lintegral_fn_integral_sub (fun x => («expr‖ ‖₊» x : ennreal)) (L1.integrable_coe_fn _) (L1.integrable_coe_fn g)]\n  refine' tendsto_of_tendsto_of_tendsto_of_le_of_le tendsto_const_nhds _ (fun i => zero_le _) _\n  ·\n    exact fun i =>\n      «expr∫⁻ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ , ∂ »\"\n        («expr∫⁻ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ , ∂ »\"\n          («expr‖ ‖₊» (i (x, y) - g (x, y))) ν)\n        μ\n  swap; · exact fun i => lintegral_mono fun x => ennnorm_integral_le_lintegral_ennnorm _\n  show\n    tendsto\n      (fun i : measure_theory.L1 (α × β) (μ.prod ν) E =>\n        «expr∫⁻ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ , ∂ »\"\n          («expr∫⁻ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ , ∂ »\"\n            («expr‖ ‖₊» (i (x, y) - g (x, y))) ν)\n          μ)\n      ((nhds) g) ((nhds) 0)\n  have : ∀ i : measure_theory.L1 (α × β) (μ.prod ν) E, measurable fun z => («expr‖ ‖₊» (i z - g z) : ennreal) :=\n    fun i => ((Lp.strongly_measurable i).sub (Lp.strongly_measurable g)).ennnorm\n  simp_rw [← lintegral_prod_of_measurable _ (this _), ← L1.of_real_norm_sub_eq_lintegral, ← of_real_zero]\n  refine' (continuous_of_real.tendsto 0).comp _\n  rw [← tendsto_iff_norm_tendsto_zero]; exact tendsto_id\n#align continuous_integral_integral continuous_integral_integral\n\n",
 "ae_measure_lt_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\ntheorem ae_measure_lt_top {s : set (α × β)} (hs : measurable_set s) (h2s : (μ.prod ν) s ≠ ennreal.top) :\n    «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\" μ\n      (ν («expr ⁻¹' » (prod.mk x) s) < ennreal.top) :=\n  by\n  simp_rw [prod_apply hs] at h2s\n  refine' ae_lt_top (measurable_measure_prod_mk_left hs) h2s\n#align ae_measure_lt_top ae_measure_lt_top\n\n",
 "ae_ae_of_ae_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\n/-- Note: the converse is not true. For a counterexample, see\n  Walter Rudin *Real and Complex Analysis*, example (c) in section 8.9. -/\ntheorem ae_ae_of_ae_prod {p : α × β → Prop}\n    (h :\n      «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\" (μ.prod ν)\n        (p z)) :\n    «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\" μ\n      («expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\" ν\n        (p (x, y))) :=\n  measure_ae_null_of_prod_null h\n#align ae_ae_of_ae_prod ae_ae_of_ae_prod\n\n",
 "add_prod":
 "theorem add_prod (μ' : measure α) [sigma_finite μ'] : (μ + μ').prod ν = μ.prod ν + μ'.prod ν :=\n  by\n  refine' prod_eq fun s t hs ht => _\n  simp_rw [add_apply, prod_prod, right_distrib]\n#align add_prod add_prod\n\n",
 "Prod":
 "#print Prod /-\n/-- If `f : α → β` sends the measure `μa` to `μb` and `g : γ → δ` sends the measure `μc` to `μd`,\nthen `prod.map f g` sends `μa.prod μc` to `μb.prod μd`. -/\nprotected theorem Prod [sigma_finite μb] [sigma_finite μd] {f : α → β} {g : γ → δ} (hf : measure_preserving f μa μb)\n    (hg : measure_preserving g μc μd) : measure_preserving (prod.map f g) (μa.prod μc) (μb.prod μd) :=\n  have : measurable (uncurry fun _ : α => g) := hg.1.comp measurable_snd\n  hf.skew_product this <| filter.eventually_of_forall fun _ => hg.map_eq\n#align prod Prod\n-/\n\n"}