{"to_measurable_equiv_symm_coe":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚âÉ‚Çú ¬ª -/\n@[simp]\ntheorem homeomorph.to_measurable_equiv_symm_coe (h : ¬´expr ‚âÉ‚Çú ¬ª Œ≥ Œ≥‚ÇÇ) :\n    (h.to_measurable_equiv.symm : Œ≥‚ÇÇ ‚Üí Œ≥) = h.symm :=\n  rfl\n#align homeomorph.to_measurable_equiv_symm_coe homeomorph.to_measurable_equiv_symm_coe\n\n",
 "to_measurable_equiv_coe":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚âÉ‚Çú ¬ª -/\n@[simp]\ntheorem homeomorph.to_measurable_equiv_coe (h : ¬´expr ‚âÉ‚Çú ¬ª Œ≥ Œ≥‚ÇÇ) : (h.to_measurable_equiv : Œ≥ ‚Üí Œ≥‚ÇÇ) = h :=\n  rfl\n#align homeomorph.to_measurable_equiv_coe homeomorph.to_measurable_equiv_coe\n\n",
 "tendsto_measure_cthickening_of_is_compact":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- Given a compact set in a proper space, the measure of its `r`-closed thickenings converges to\nits measure as `r` tends to `0`. -/\ntheorem tendsto_measure_cthickening_of_is_compact [metric_space Œ±] [measurable_space Œ±] [opens_measurable_space Œ±]\n    [proper_space Œ±] {Œº : measure Œ±} [is_finite_measure_on_compacts Œº] {s : set Œ±} (hs : is_compact s) :\n    tendsto (fun r => Œº (metric.cthickening r s)) ((nhds) 0) ((nhds) (Œº s)) :=\n  tendsto_measure_cthickening_of_is_closed ‚ü®1, zero_lt_one, hs.bounded.cthickening.measure_lt_top.ne‚ü© hs.is_closed\n#align tendsto_measure_cthickening_of_is_compact tendsto_measure_cthickening_of_is_compact\n\n",
 "tendsto_measure_cthickening_of_is_closed":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- If a closed set has a closed thickening with finite measure, then the measure of its `r`-closed\nthickenings converges to its measure as `r` tends to `0`. -/\ntheorem tendsto_measure_cthickening_of_is_closed {Œº : measure Œ±} {s : set Œ±}\n    (hs : ‚àÉ R > 0, Œº (cthickening R s) ‚â† ennreal.top) (h's : is_closed s) :\n    tendsto (fun r => Œº (cthickening r s)) ((nhds) 0) ((nhds) (Œº s)) :=\n  by\n  convert tendsto_measure_cthickening hs\n  exact h's.closure_eq.symm\n#align tendsto_measure_cthickening_of_is_closed tendsto_measure_cthickening_of_is_closed\n\n",
 "tendsto_measure_cthickening":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- If a set has a closed thickening with finite measure, then the measure of its `r`-closed\nthickenings converges to the measure of its closure as `r` tends to `0`. -/\ntheorem tendsto_measure_cthickening {Œº : measure Œ±} {s : set Œ±} (hs : ‚àÉ R > 0, Œº (cthickening R s) ‚â† ennreal.top) :\n    tendsto (fun r => Œº (cthickening r s)) ((nhds) 0) ((nhds) (Œº (closure s))) :=\n  by\n  have A : tendsto (fun r => Œº (cthickening r s)) (nhds_within (Ioi 0) 0) ((nhds) (Œº (closure s))) :=\n    by\n    rw [closure_eq_Inter_cthickening]\n    exact\n      tendsto_measure_bInter_gt (fun r hr => is_closed_cthickening.measurable_set)\n        (fun i j ipos ij => cthickening_mono ij _) hs\n  have B : tendsto (fun r => Œº (cthickening r s)) (nhds_within (Iic 0) 0) ((nhds) (Œº (closure s))) :=\n    by\n    apply tendsto.congr' _ tendsto_const_nhds\n    filter_upwards [self_mem_nhds_within] with _ hr\n    rw [cthickening_of_nonpos hr]\n  convert B.sup A\n  exact (nhds_left_sup_nhds_right' 0).symm\n#align tendsto_measure_cthickening tendsto_measure_cthickening\n\n",
 "supr_Prop":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚®Ü , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚®Ü , ¬ª -/\n@[measurability]\ntheorem measurable.supr_Prop {Œ±} [measurable_space Œ±] [CompleteLattice Œ±] (p : Prop) {f : Œ¥ ‚Üí Œ±} (hf : measurable f) :\n    measurable fun b =>\n      ¬´expr‚®Ü , ¬ª \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚®Ü , ¬ª\" (f b) :=\n  by_cases (fun h : p => by convert hf; funext ; exact sup·µ¢_pos h) fun h : ¬¨p => by convert measurable_const; funext ;\n    exact sup·µ¢_neg h\n#align measurable.supr_Prop measurable.supr_Prop\n\n",
 "real_to_nnreal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expr‚Ñù -/\n@[measurability]\ntheorem ae_measurable.real_to_nnreal {f : Œ± ‚Üí expr‚Ñù} {Œº : measure Œ±} (hf : ae_measurable f Œº) :\n    ae_measurable (fun x => real.to_nnreal (f x)) Œº :=\n  measurable_real_to_nnreal.comp_ae_measurable hf\n#align ae_measurable.real_to_nnreal ae_measurable.real_to_nnreal\n\n",
 "prod_le_borel_prod":
 "theorem prod_le_borel_prod : prod.measurable_space ‚â§ borel (Œ± √ó Œ≤) :=\n  by\n  rw [‚Äπborel_space Œ±‚Ä∫.measurable_eq, ‚Äπborel_space Œ≤‚Ä∫.measurable_eq]\n  refine' sup_le _ _\n  ¬∑ exact comap_le_iff_le_map.mpr continuous_fst.borel_measurable\n  ¬∑ exact comap_le_iff_le_map.mpr continuous_snd.borel_measurable\n#align prod_le_borel_prod prod_le_borel_prod\n\n",
 "pi_le_borel_pi":
 "theorem pi_le_borel_pi {Œπ : Type _} {œÄ : Œπ ‚Üí Type _} [‚àÄ i, topological_space (œÄ i)] [‚àÄ i, measurable_space (œÄ i)]\n    [‚àÄ i, borel_space (œÄ i)] : measurable_space.pi ‚â§ borel (‚àÄ i, œÄ i) :=\n  by\n  have : ‚Äπ‚àÄ i, measurable_space (œÄ i)‚Ä∫ = fun i => borel (œÄ i) := funext fun i => borel_space.measurable_eq\n  rw [this]\n  exact sup·µ¢_le fun i => comap_le_iff_le_map.2 <| (continuous_apply i).borel_measurable\n#align pi_le_borel_pi pi_le_borel_pi\n\n",
 "null_measurable_set_of_null_frontier":
 "theorem null_measurable_set_of_null_frontier {s : set Œ±} {Œº : measure Œ±} (h : Œº (frontier s) = 0) :\n    null_measurable_set s Œº :=\n  ‚ü®interior s, is_open_interior.measurable_set, (interior_ae_eq_of_null_frontier h).symm‚ü©\n#align null_measurable_set_of_null_frontier null_measurable_set_of_null_frontier\n\n",
 "norm":
 "@[measurability]\ntheorem ae_measurable.norm {f : Œ≤ ‚Üí Œ±} {Œº : measure Œ≤} (hf : ae_measurable f Œº) :\n    ae_measurable (fun a => norm (f a)) Œº :=\n  measurable_norm.comp_ae_measurable hf\n#align ae_measurable.norm ae_measurable.norm\n\n",
 "nnreal_tsum":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚àë' , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚àë' , ¬ª -/\n@[measurability]\ntheorem measurable.nnreal_tsum {Œπ} [countable Œπ] {f : Œπ ‚Üí Œ± ‚Üí nnreal} (h : ‚àÄ i, measurable (f i)) :\n    measurable fun x =>\n      ¬´expr‚àë' , ¬ª \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚àë' , ¬ª\" (f i x) :=\n  by\n  simp_rw [nnreal.tsum_eq_to_nnreal_tsum]\n  exact (measurable.ennreal_tsum fun i => (h i).coe_nnreal_ennreal).ennreal_to_nnreal\n#align measurable.nnreal_tsum measurable.nnreal_tsum\n\n",
 "nnnorm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚Äñ ‚Äñ‚Çä¬ª -/\n@[measurability]\ntheorem ae_measurable.nnnorm {f : Œ≤ ‚Üí Œ±} {Œº : measure Œ≤} (hf : ae_measurable f Œº) :\n    ae_measurable (fun a => ¬´expr‚Äñ ‚Äñ‚Çä¬ª (f a)) Œº :=\n  measurable_nnnorm.comp_ae_measurable hf\n#align ae_measurable.nnnorm ae_measurable.nnnorm\n\n",
 "nndist":
 "@[measurability]\ntheorem measurable.nndist {f g : Œ≤ ‚Üí Œ±} (hf : measurable f) (hg : measurable g) :\n    measurable fun b => nndist (f b) (g b) :=\n  (@continuous_nndist Œ± _).measurable2 hf hg\n#align measurable.nndist measurable.nndist\n\n",
 "nhds_within_is_measurably_generated":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/-- If `s` is a measurable set, then `ùìù[s] a` is a measurably generated filter for\neach `a`. This cannot be an `instance` because it depends on a non-instance `hs : measurable_set s`.\n-/\ntheorem measurable_set.nhds_within_is_measurably_generated {s : set Œ±} (hs : measurable_set s) (a : Œ±) :\n    (nhds_within s a).is_measurably_generated :=\n  haveI := hs.principal_is_measurably_generated\n  filter.inf_is_measurably_generated _ _\n#align measurable_set.nhds_within_is_measurably_generated measurable_set.nhds_within_is_measurably_generated\n\n",
 "min":
 "@[measurability]\ntheorem ae_measurable.min {f g : Œ¥ ‚Üí Œ±} {Œº : measure Œ¥} (hf : ae_measurable f Œº) (hg : ae_measurable g Œº) :\n    ae_measurable (fun a => min (f a) (g a)) Œº :=\n  ‚ü®fun a => min (hf.mk f a) (hg.mk g a), hf.measurable_mk.min hg.measurable_mk,\n    eventually_eq.comp‚ÇÇ hf.ae_eq_mk _ hg.ae_eq_mk‚ü©\n#align ae_measurable.min ae_measurable.min\n\n",
 "measure_interior_of_null_frontier":
 "theorem measure_interior_of_null_frontier {Œº : measure Œ±'} {s : set Œ±'} (h : Œº (frontier s) = 0) :\n    Œº (interior s) = Œº s :=\n  measure_congr (interior_ae_eq_of_null_frontier h)\n#align measure_interior_of_null_frontier measure_interior_of_null_frontier\n\n",
 "measure_ext_Ioo_rat":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expr‚Ñù -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expr‚Ñö -/\n-- TODO: norm_cast fails here?\ntheorem measure_ext_Ioo_rat {Œº ŒΩ : measure (expr‚Ñù)} [is_locally_finite_measure Œº]\n    (h : ‚àÄ a b : expr‚Ñö, Œº (Ioo a b) = ŒΩ (Ioo a b)) : Œº = ŒΩ :=\n  (finite_spanning_sets_in_Ioo_rat Œº).ext borel_eq_generate_from_Ioo_rat is_pi_system_Ioo_rat <|\n    by\n    simp only [mem_Union, mem_singleton_iff]\n    rintro _ ‚ü®a, b, -, rfl‚ü©\n    apply h\n#align measure_ext_Ioo_rat measure_ext_Ioo_rat\n\n",
 "measure_eq_measure_preimage_add_measure_tsum_Ico_zpow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚Åª¬π' ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚Åª¬π' ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚Åª¬π' ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚Åª¬π' ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚Åª¬π' ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚Åª¬π' ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚àë' , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚àë' , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚Åª¬π' ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚Åª¬π' ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚Åª¬π' ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚àë' , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚àë' , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚Åª¬π' ¬ª -/\n/-- One can cut out `‚Ñù‚â•0‚àû` into the sets `{0}`, `Ico (t^n) (t^(n+1))` for `n : ‚Ñ§` and `{‚àû}`. This\ngives a way to compute the measure of a set in terms of sets on which a given function `f` does not\nfluctuate by more than `t`. -/\ntheorem measure_eq_measure_preimage_add_measure_tsum_Ico_zpow [measurable_space Œ±] (Œº : measure Œ±) {f : Œ± ‚Üí ennreal}\n    (hf : measurable f) {s : set Œ±} (hs : measurable_set s) {t : nnreal} (ht : 1 < t) :\n    Œº s =\n      Œº (s ‚à© ¬´expr ‚Åª¬π' ¬ª f {0}) + Œº (s ‚à© ¬´expr ‚Åª¬π' ¬ª f {ennreal.top}) +\n        ¬´expr‚àë' , ¬ª \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚àë' , ¬ª\"\n          (Œº (s ‚à© ¬´expr ‚Åª¬π' ¬ª f (Ico (t ^ n) (t ^ (n + 1))))) :=\n  by\n  have A : Œº s = Œº (s ‚à© ¬´expr ‚Åª¬π' ¬ª f {0}) + Œº (s ‚à© ¬´expr ‚Åª¬π' ¬ª f (Ioi 0)) :=\n    by\n    rw [‚Üê measure_union]\n    ¬∑ congr 1\n      ext x\n      have : 0 = f x ‚à® 0 < f x := eq_or_lt_of_le bot_le\n      rw [eq_comm] at this\n      simp only [‚Üê and_or_left, this, mem_singleton_iff, mem_inter_iff, and_true_iff, mem_union, mem_Ioi, mem_preimage]\n    ¬∑ apply disjoint_left.2 fun x hx h'x => _\n      have : 0 < f x := h'x.2\n      exact lt_irrefl 0 (this.trans_le hx.2.le)\n    ¬∑ exact hs.inter (hf measurable_set_Ioi)\n  have B :\n    Œº (s ‚à© ¬´expr ‚Åª¬π' ¬ª f (Ioi 0)) = Œº (s ‚à© ¬´expr ‚Åª¬π' ¬ª f {ennreal.top}) + Œº (s ‚à© ¬´expr ‚Åª¬π' ¬ª f (Ioo 0 (ennreal.top))) :=\n    by\n    rw [‚Üê measure_union]\n    ¬∑ rw [‚Üê inter_union_distrib_left]\n      congr\n      ext x\n      simp only [mem_singleton_iff, mem_union, mem_Ioo, mem_Ioi, mem_preimage]\n      have H : f x = ennreal.top ‚à® f x < ennreal.top := eq_or_lt_of_le le_top\n      cases H\n      ¬∑ simp only [H, eq_self_iff_true, or_false_iff, WithTop.zero_lt_top, not_top_lt, and_false_iff]\n      ¬∑ simp only [H, H.ne, and_true_iff, false_or_iff]\n    ¬∑ apply disjoint_left.2 fun x hx h'x => _\n      have : f x < ennreal.top := h'x.2.2\n      exact lt_irrefl _ (this.trans_le (le_of_eq hx.2.symm))\n    ¬∑ exact hs.inter (hf measurable_set_Ioo)\n  have C :\n    Œº (s ‚à© ¬´expr ‚Åª¬π' ¬ª f (Ioo 0 (ennreal.top))) =\n      ¬´expr‚àë' , ¬ª \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚àë' , ¬ª\"\n        (Œº (s ‚à© ¬´expr ‚Åª¬π' ¬ª f (Ico (t ^ n) (t ^ (n + 1))))) :=\n    by\n    rw [‚Üê measure_Union, ennreal.Ioo_zero_top_eq_Union_Ico_zpow (ennreal.one_lt_coe_iff.2 ht) ennreal.coe_ne_top,\n      preimage_Union, inter_Union]\n    ¬∑ intro i j\n      simp only [function.on_fun]\n      wlog (discharger := tactic.skip) h : i ‚â§ j := le_total i j using i j, j i\n      ¬∑ intro hij\n        replace hij : i + 1 ‚â§ j := lt_of_le_of_ne h hij\n        apply disjoint_left.2 fun x hx h'x => lt_irrefl (f x) _\n        calc\n          f x < t ^ (i + 1) := hx.2.2\n          _ ‚â§ t ^ j := ennreal.zpow_le_of_le (ennreal.one_le_coe_iff.2 ht.le) hij\n          _ ‚â§ f x := h'x.2.1\n          \n      ¬∑ intro hij\n        rw [disjoint_comm]\n        exact this hij.symm\n    ¬∑ intro n\n      exact hs.inter (hf measurable_set_Ico)\n  rw [A, B, C, add_assoc]\n#align measure_eq_measure_preimage_add_measure_tsum_Ico_zpow measure_eq_measure_preimage_add_measure_tsum_Ico_zpow\n\n",
 "measure_closure_of_null_frontier":
 "theorem measure_closure_of_null_frontier {Œº : measure Œ±'} {s : set Œ±'} (h : Œº (frontier s) = 0) : Œº (closure s) = Œº s :=\n  measure_congr (closure_ae_eq_of_null_frontier h)\n#align measure_closure_of_null_frontier measure_closure_of_null_frontier\n\n",
 "measurable_to_real":
 "@[measurability]\ntheorem measurable_to_real : measurable ennreal.to_real :=\n  ennreal.measurable_of_measurable_nnreal measurable_coe_nnreal_real\n#align measurable_to_real measurable_to_real\n\n",
 "measurable_to_nnreal":
 "@[measurability]\ntheorem measurable_to_nnreal : measurable ennreal.to_nnreal :=\n  ennreal.measurable_of_measurable_nnreal measurable_id\n#align measurable_to_nnreal measurable_to_nnreal\n\n",
 "measurable_supr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚®Ü , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚®Ü , ¬ª -/\n@[measurability]\ntheorem measurable_supr {Œπ} [countable Œπ] {f : Œπ ‚Üí Œ¥ ‚Üí Œ±} (hf : ‚àÄ i, measurable (f i)) :\n    measurable fun b =>\n      ¬´expr‚®Ü , ¬ª \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚®Ü , ¬ª\" (f i b) :=\n  measurable.is_lub hf fun b => isLUB_sup·µ¢\n#align measurable_supr measurable_supr\n\n",
 "measurable_smul_const":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚Ä¢ ¬ª -/\ntheorem measurable_smul_const {f : Œ± ‚Üí ùïú} {c : E} (hc : c ‚â† 0) :\n    (measurable fun x => ¬´expr ‚Ä¢ ¬ª (f x) c) ‚Üî measurable f :=\n  (closed_embedding_smul_left hc).measurable_embedding.measurable_comp_iff\n#align measurable_smul_const measurable_smul_const\n\n",
 "measurable_set_uIoc":
 "@[measurability]\ntheorem measurable_set_uIoc : measurable_set (uIoc a b) :=\n  measurable_set_Ioc\n#align measurable_set_uIoc measurable_set_uIoc\n\n",
 "measurable_set_uIcc":
 "@[measurability]\ntheorem measurable_set_uIcc : measurable_set (uIcc a b) :=\n  measurable_set_Icc\n#align measurable_set_uIcc measurable_set_uIcc\n\n",
 "measurable_set_of_mem_nhds_within_Ioi_aux":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.gt -/\ntheorem measurable_set_of_mem_nhds_within_Ioi_aux {s : set Œ±} (h : ‚àÄ x ‚àà s, s ‚àà nhds_within.gt x)\n    (h' : ‚àÄ x ‚àà s, ‚àÉ y, x < y) : measurable_set s :=\n  by\n  choose! M hM using h'\n  suffices H : (s \\ interior s).countable\n  ¬∑ have : s = interior s ‚à™ s \\ interior s := by rw [union_diff_cancel interior_subset]\n    rw [this]\n    exact is_open_interior.measurable_set.union H.measurable_set\n  have A : ‚àÄ x ‚àà s, ‚àÉ y ‚àà Ioi x, Ioo x y ‚äÜ s := fun x hx =>\n    (mem_nhds_within_Ioi_iff_exists_Ioo_subset' (hM x hx)).1 (h x hx)\n  choose! y hy h'y using A\n  have B : Set.PairwiseDisjoint (s \\ interior s) fun x => Ioo x (y x) :=\n    by\n    intro x hx x' hx' hxx'\n    rcases lt_or_gt_of_ne hxx' with (h' | h')\n    ¬∑ apply disjoint_left.2 fun z hz h'z => _\n      have : x' ‚àà interior s := mem_interior.2 ‚ü®Ioo x (y x), h'y _ hx.1, is_open_Ioo, ‚ü®h', h'z.1.trans hz.2‚ü©‚ü©\n      exact false.elim (hx'.2 this)\n    ¬∑ apply disjoint_left.2 fun z hz h'z => _\n      have : x ‚àà interior s := mem_interior.2 ‚ü®Ioo x' (y x'), h'y _ hx'.1, is_open_Ioo, ‚ü®h', hz.1.trans h'z.2‚ü©‚ü©\n      exact false.elim (hx.2 this)\n  exact B.countable_of_Ioo fun x hx => hy x hx.1\n#align measurable_set_of_mem_nhds_within_Ioi_aux measurable_set_of_mem_nhds_within_Ioi_aux\n\n",
 "measurable_set_of_mem_nhds_within_Ioi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.gt -/\n/-- If a set is a right-neighborhood of all of its points, then it is measurable. -/\ntheorem measurable_set_of_mem_nhds_within_Ioi {s : set Œ±} (h : ‚àÄ x ‚àà s, s ‚àà nhds_within.gt x) : measurable_set s :=\n  by\n  by_cases H : ‚àÉ x ‚àà s, is_top x\n  ¬∑ rcases H with ‚ü®x‚ÇÄ, x‚ÇÄs, h‚ÇÄ‚ü©\n    have : s = {x‚ÇÄ} ‚à™ s \\ {x‚ÇÄ} := by rw [union_diff_cancel (singleton_subset_iff.2 x‚ÇÄs)]\n    rw [this]\n    refine' (measurable_set_singleton _).union _\n    have A : ‚àÄ x ‚àà s \\ {x‚ÇÄ}, x < x‚ÇÄ := fun x hx => lt_of_le_of_ne (h‚ÇÄ _) (by simpa using hx.2)\n    refine' measurable_set_of_mem_nhds_within_Ioi_aux (fun x hx => _) fun x hx => ‚ü®x‚ÇÄ, A x hx‚ü©\n    obtain ‚ü®u, hu, us‚ü© : ‚àÉ (u : Œ±)(H : u ‚àà Ioi x), Ioo x u ‚äÜ s :=\n      (mem_nhds_within_Ioi_iff_exists_Ioo_subset' (A x hx)).1 (h x hx.1)\n    refine' (mem_nhds_within_Ioi_iff_exists_Ioo_subset' (A x hx)).2 ‚ü®u, hu, fun y hy => ‚ü®us hy, _‚ü©‚ü©\n    exact ne_of_lt (hy.2.trans_le (h‚ÇÄ _))\n  ¬∑ apply measurable_set_of_mem_nhds_within_Ioi_aux h\n    simp only [is_top] at H\n    push_neg  at H\n    exact H\n#align measurable_set_of_mem_nhds_within_Ioi measurable_set_of_mem_nhds_within_Ioi\n\n",
 "measurable_set_of_continuous_at":
 "theorem measurable_set_of_continuous_at {Œ≤} [emetric_space Œ≤] (f : Œ± ‚Üí Œ≤) : measurable_set { x | continuous_at f x } :=\n  (is_GŒ¥_set_of_continuous_at f).measurable_set\n#align measurable_set_of_continuous_at measurable_set_of_continuous_at\n\n",
 "measurable_set_lt'":
 "@[measurability]\ntheorem measurable_set_lt' [second_countable_topology Œ±] : measurable_set { p : Œ± √ó Œ± | p.1 < p.2 } :=\n  (is_open_lt continuous_fst continuous_snd).measurable_set\n#align measurable_set_lt' measurable_set_lt'\n\n",
 "measurable_set_lt":
 "@[measurability]\ntheorem measurable_set_lt [second_countable_topology Œ±] {f g : Œ¥ ‚Üí Œ±} (hf : measurable f) (hg : measurable g) :\n    measurable_set { a | f a < g a } :=\n  hf.prod_mk hg measurable_set_lt'\n#align measurable_set_lt measurable_set_lt\n\n",
 "measurable_set_le'":
 "@[measurability]\ntheorem measurable_set_le' : measurable_set { p : Œ± √ó Œ± | p.1 ‚â§ p.2 } :=\n  order_closed_topology.is_closed_le'.measurable_set\n#align measurable_set_le' measurable_set_le'\n\n",
 "measurable_set_le":
 "@[measurability]\ntheorem measurable_set_le {f g : Œ¥ ‚Üí Œ±} (hf : measurable f) (hg : measurable g) : measurable_set { a | f a ‚â§ g a } :=\n  hf.prod_mk hg measurable_set_le'\n#align measurable_set_le measurable_set_le\n\n",
 "measurable_set_interior":
 "@[measurability]\ntheorem measurable_set_interior : measurable_set (interior s) :=\n  is_open_interior.measurable_set\n#align measurable_set_interior measurable_set_interior\n\n",
 "measurable_set_eball":
 "@[measurability]\ntheorem measurable_set_eball : measurable_set (emetric.ball x Œµ) :=\n  emetric.is_open_ball.measurable_set\n#align measurable_set_eball measurable_set_eball\n\n",
 "measurable_set_closure":
 "@[measurability]\ntheorem measurable_set_closure : measurable_set (closure s) :=\n  is_closed_closure.measurable_set\n#align measurable_set_closure measurable_set_closure\n\n",
 "measurable_set_closed_ball":
 "@[measurability]\ntheorem measurable_set_closed_ball : measurable_set (metric.closed_ball x Œµ) :=\n  metric.is_closed_ball.measurable_set\n#align measurable_set_closed_ball measurable_set_closed_ball\n\n",
 "measurable_set_ball":
 "@[measurability]\ntheorem measurable_set_ball : measurable_set (metric.ball x Œµ) :=\n  metric.is_open_ball.measurable_set\n#align measurable_set_ball measurable_set_ball\n\n",
 "measurable_set_Ioo":
 "@[simp, measurability]\ntheorem measurable_set_Ioo : measurable_set (Ioo a b) :=\n  is_open_Ioo.measurable_set\n#align measurable_set_Ioo measurable_set_Ioo\n\n",
 "measurable_set_Ioi":
 "@[simp, measurability]\ntheorem measurable_set_Ioi : measurable_set (Ioi a) :=\n  is_open_Ioi.measurable_set\n#align measurable_set_Ioi measurable_set_Ioi\n\n",
 "measurable_set_Ioc":
 "@[simp, measurability]\ntheorem measurable_set_Ioc : measurable_set (Ioc a b) :=\n  measurable_set_Ioi.inter measurable_set_Iic\n#align measurable_set_Ioc measurable_set_Ioc\n\n",
 "measurable_set_Iio":
 "-- we open this locale only here to avoid issues with list being treated as intervals above\n@[simp, measurability]\ntheorem measurable_set_Iio : measurable_set (Iio a) :=\n  is_open_Iio.measurable_set\n#align measurable_set_Iio measurable_set_Iio\n\n",
 "measurable_set_Iic":
 "@[simp, measurability]\ntheorem measurable_set_Iic : measurable_set (Iic a) :=\n  is_closed_Iic.measurable_set\n#align measurable_set_Iic measurable_set_Iic\n\n",
 "measurable_set_Ico":
 "@[simp, measurability]\ntheorem measurable_set_Ico : measurable_set (Ico a b) :=\n  measurable_set_Ici.inter measurable_set_Iio\n#align measurable_set_Ico measurable_set_Ico\n\n",
 "measurable_set_Ici":
 "@[simp, measurability]\ntheorem measurable_set_Ici : measurable_set (Ici a) :=\n  is_closed_Ici.measurable_set\n#align measurable_set_Ici measurable_set_Ici\n\n",
 "measurable_set_Icc":
 "@[simp, measurability]\ntheorem measurable_set_Icc : measurable_set (Icc a b) :=\n  is_closed_Icc.measurable_set\n#align measurable_set_Icc measurable_set_Icc\n\n",
 "measurable_set":
 "theorem is_preconnected.measurable_set (h : is_preconnected s) : measurable_set s :=\n  h.ord_connected.measurable_set\n#align is_preconnected.measurable_set is_preconnected.measurable_set\n\n",
 "measurable_real_to_nnreal":
 "@[measurability]\ntheorem measurable_real_to_nnreal : measurable real.to_nnreal :=\n  continuous_real_to_nnreal.measurable\n#align measurable_real_to_nnreal measurable_real_to_nnreal\n\n",
 "measurable_piecewise":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ·∂ú¬ª -/\n/-- If a function is defined piecewise in terms of functions which are continuous on their\nrespective pieces, then it is measurable. -/\ntheorem continuous_on.measurable_piecewise {f g : Œ± ‚Üí Œ≥} {s : set Œ±} [‚àÄ j : Œ±, decidable (j ‚àà s)]\n    (hf : continuous_on f s) (hg : continuous_on g (¬´expr ·∂ú¬ª s)) (hs : measurable_set s) :\n    measurable (s.piecewise f g) := by\n  refine' measurable_of_is_open fun t ht => _\n  rw [piecewise_preimage, Set.ite]\n  apply measurable_set.union\n  ¬∑ rcases _root_.continuous_on_iff'.1 hf t ht with ‚ü®u, u_open, hu‚ü©\n    rw [hu]\n    exact u_open.measurable_set.inter hs\n  ¬∑ rcases _root_.continuous_on_iff'.1 hg t ht with ‚ü®u, u_open, hu‚ü©\n    rw [diff_eq_compl_inter, inter_comm, hu]\n    exact u_open.measurable_set.inter hs.compl\n#align continuous_on.measurable_piecewise continuous_on.measurable_piecewise\n\n",
 "measurable_of_tendsto_nnreal'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- A limit (over a general filter) of measurable `‚Ñù‚â•0` valued functions is measurable. -/\ntheorem measurable_of_tendsto_nnreal' {Œπ} {f : Œπ ‚Üí Œ± ‚Üí nnreal} {g : Œ± ‚Üí nnreal} (u : filter Œπ) [ne_bot u]\n    [is_countably_generated u] (hf : ‚àÄ i, measurable (f i)) (lim : tendsto f u ((nhds) g)) : measurable g :=\n  by\n  simp_rw [‚Üê measurable_coe_nnreal_ennreal_iff] at hf‚ä¢\n  refine' measurable_of_tendsto_ennreal' u hf _\n  rw [tendsto_pi_nhds] at lim‚ä¢\n  exact fun x => (ennreal.continuous_coe.tendsto (g x)).comp (lim x)\n#align measurable_of_tendsto_nnreal' measurable_of_tendsto_nnreal'\n\n",
 "measurable_of_tendsto_nnreal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- A sequential limit of measurable `‚Ñù‚â•0` valued functions is measurable. -/\ntheorem measurable_of_tendsto_nnreal {f : ‚Ñï ‚Üí Œ± ‚Üí nnreal} {g : Œ± ‚Üí nnreal} (hf : ‚àÄ i, measurable (f i))\n    (lim : tendsto f at_top ((nhds) g)) : measurable g :=\n  measurable_of_tendsto_nnreal' at_top hf lim\n#align measurable_of_tendsto_nnreal measurable_of_tendsto_nnreal\n\n",
 "measurable_of_tendsto_metrizable_ae":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚àÄ·µê ‚àÇ , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚àÄ·µê ‚àÇ , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem measurable_of_tendsto_metrizable_ae {Œº : measure Œ±} [Œº.is_complete] {f : ‚Ñï ‚Üí Œ± ‚Üí Œ≤} {g : Œ± ‚Üí Œ≤}\n    (hf : ‚àÄ n, measurable (f n))\n    (h_ae_tendsto :\n      ¬´expr‚àÄ·µê ‚àÇ , ¬ª \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚àÄ·µê ‚àÇ , ¬ª\" Œº\n        (tendsto (fun n => f n x) at_top ((nhds) (g x)))) :\n    measurable g :=\n  ae_measurable_iff_measurable.mp (ae_measurable_of_tendsto_metrizable_ae' (fun i => (hf i).ae_measurable) h_ae_tendsto)\n#align measurable_of_tendsto_metrizable_ae measurable_of_tendsto_metrizable_ae\n\n",
 "measurable_of_tendsto_metrizable'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚Åª¬π' ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚Åª¬π' ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- A limit (over a general filter) of measurable functions valued in a (pseudo) metrizable space is\nmeasurable. -/\ntheorem measurable_of_tendsto_metrizable' {Œπ} {f : Œπ ‚Üí Œ± ‚Üí Œ≤} {g : Œ± ‚Üí Œ≤} (u : filter Œπ) [ne_bot u]\n    [is_countably_generated u] (hf : ‚àÄ i, measurable (f i)) (lim : tendsto f u ((nhds) g)) : measurable g :=\n  by\n  letI : pseudo_metric_space Œ≤ := pseudo_metrizable_space_pseudo_metric Œ≤\n  apply measurable_of_is_closed'\n  intro s h1s h2s h3s\n  have : measurable fun x => inf_nndist (g x) s :=\n    by\n    suffices : tendsto (fun i x => inf_nndist (f i x) s) u ((nhds) fun x => inf_nndist (g x) s)\n    exact measurable_of_tendsto_nnreal' u (fun i => (hf i).inf_nndist) this\n    rw [tendsto_pi_nhds] at lim‚ä¢\n    intro x\n    exact ((continuous_inf_nndist_pt s).tendsto (g x)).comp (lim x)\n  have h4s : ¬´expr ‚Åª¬π' ¬ª g s = ¬´expr ‚Åª¬π' ¬ª (fun x => inf_nndist (g x) s) {0} :=\n    by\n    ext x\n    simp [h1s, ‚Üê h1s.mem_iff_inf_dist_zero h2s, ‚Üê nnreal.coe_eq_zero]\n  rw [h4s]\n  exact this (measurable_set_singleton 0)\n#align measurable_of_tendsto_metrizable' measurable_of_tendsto_metrizable'\n\n",
 "measurable_of_tendsto_metrizable":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- A sequential limit of measurable functions valued in a (pseudo) metrizable space is\nmeasurable. -/\ntheorem measurable_of_tendsto_metrizable {f : ‚Ñï ‚Üí Œ± ‚Üí Œ≤} {g : Œ± ‚Üí Œ≤} (hf : ‚àÄ i, measurable (f i))\n    (lim : tendsto f at_top ((nhds) g)) : measurable g :=\n  measurable_of_tendsto_metrizable' at_top hf lim\n#align measurable_of_tendsto_metrizable measurable_of_tendsto_metrizable\n\n",
 "measurable_of_tendsto_ennreal'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- A limit (over a general filter) of measurable `‚Ñù‚â•0‚àû` valued functions is measurable. -/\ntheorem measurable_of_tendsto_ennreal' {Œπ} {f : Œπ ‚Üí Œ± ‚Üí ennreal} {g : Œ± ‚Üí ennreal} (u : filter Œπ) [ne_bot u]\n    [is_countably_generated u] (hf : ‚àÄ i, measurable (f i)) (lim : tendsto f u ((nhds) g)) : measurable g :=\n  by\n  rcases u.exists_seq_tendsto with ‚ü®x, hx‚ü©\n  rw [tendsto_pi_nhds] at lim\n  have : (fun y => liminf (fun n => (f (x n) y : ennreal)) at_top) = g :=\n    by\n    ext1 y\n    exact ((lim y).comp hx).liminf_eq\n  rw [‚Üê this]\n  show measurable fun y => liminf (fun n => (f (x n) y : ennreal)) at_top\n  exact measurable_liminf fun n => hf (x n)\n#align measurable_of_tendsto_ennreal' measurable_of_tendsto_ennreal'\n\n",
 "measurable_of_tendsto_ennreal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- A sequential limit of measurable `‚Ñù‚â•0‚àû` valued functions is measurable. -/\ntheorem measurable_of_tendsto_ennreal {f : ‚Ñï ‚Üí Œ± ‚Üí ennreal} {g : Œ± ‚Üí ennreal} (hf : ‚àÄ i, measurable (f i))\n    (lim : tendsto f at_top ((nhds) g)) : measurable g :=\n  measurable_of_tendsto_ennreal' at_top hf lim\n#align measurable_of_tendsto_ennreal measurable_of_tendsto_ennreal\n\n",
 "measurable_of_real":
 "@[measurability]\ntheorem measurable_of_real : measurable ennreal.of_real :=\n  ennreal.continuous_of_real.measurable\n#align measurable_of_real measurable_of_real\n\n",
 "measurable_of_measurable_real":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚ä•¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚ä§¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expr‚Ñù -/\ntheorem ereal.measurable_of_measurable_real {f : ereal ‚Üí Œ±} (h : measurable fun p : expr‚Ñù => f p) : measurable f :=\n  measurable_of_measurable_on_compl_finite {¬´expr‚ä•¬ª, ¬´expr‚ä§¬ª} (by simp)\n    (measurable_equiv.ereal_equiv_real.symm.measurable_comp_iff.1 h)\n#align ereal.measurable_of_measurable_real ereal.measurable_of_measurable_real\n\n",
 "measurable_of_measurable_nnreal_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚âÉ·µê ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\ntheorem measurable_of_measurable_nnreal_prod [measurable_space Œ≤] [measurable_space Œ≥] {f : ennreal √ó Œ≤ ‚Üí Œ≥}\n    (H‚ÇÅ : measurable fun p : nnreal √ó Œ≤ => f (p.1, p.2)) (H‚ÇÇ : measurable fun x => f (ennreal.top, x)) : measurable f :=\n  let e : ¬´expr ‚âÉ·µê ¬ª (ennreal √ó Œ≤) (Sum (nnreal √ó Œ≤) (unit √ó Œ≤)) :=\n    (ennreal_equiv_sum.prod_congr (measurable_equiv.refl Œ≤)).trans (measurable_equiv.sum_prod_distrib _ _ _)\n  e.symm.measurable_comp_iff.1 <| measurable_sum H‚ÇÅ (H‚ÇÇ.comp measurable_id.snd)\n#align measurable_of_measurable_nnreal_prod measurable_of_measurable_nnreal_prod\n\n",
 "measurable_of_measurable_nnreal_nnreal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\ntheorem measurable_of_measurable_nnreal_nnreal [measurable_space Œ≤] {f : ennreal √ó ennreal ‚Üí Œ≤}\n    (h‚ÇÅ : measurable fun p : nnreal √ó nnreal => f (p.1, p.2)) (h‚ÇÇ : measurable fun r : nnreal => f (ennreal.top, r))\n    (h‚ÇÉ : measurable fun r : nnreal => f (r, ennreal.top)) : measurable f :=\n  measurable_of_measurable_nnreal_prod\n    (measurable_swap_iff.1 <| measurable_of_measurable_nnreal_prod (h‚ÇÅ.comp measurable_swap) h‚ÇÉ)\n    (measurable_of_measurable_nnreal h‚ÇÇ)\n#align measurable_of_measurable_nnreal_nnreal measurable_of_measurable_nnreal_nnreal\n\n",
 "measurable_of_measurable_nnreal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\ntheorem measurable_of_measurable_nnreal {f : ennreal ‚Üí Œ±} (h : measurable fun p : nnreal => f p) : measurable f :=\n  measurable_of_measurable_on_compl_singleton (ennreal.top)\n    (measurable_equiv.ennreal_equiv_nnreal.symm.measurable_comp_iff.1 h)\n#align measurable_of_measurable_nnreal measurable_of_measurable_nnreal\n\n",
 "measurable_of_is_open":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚Åª¬π' ¬ª -/\ntheorem measurable_of_is_open {f : Œ¥ ‚Üí Œ≥} (hf : ‚àÄ s, is_open s ‚Üí measurable_set (¬´expr ‚Åª¬π' ¬ª f s)) : measurable f :=\n  by\n  rw [‚Äπborel_space Œ≥‚Ä∫.measurable_eq]\n  exact measurable_generate_from hf\n#align measurable_of_is_open measurable_of_is_open\n\n",
 "measurable_of_is_closed'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚Åª¬π' ¬ª -/\ntheorem measurable_of_is_closed' {f : Œ¥ ‚Üí Œ≥}\n    (hf : ‚àÄ s, is_closed s ‚Üí s.nonempty ‚Üí s ‚â† univ ‚Üí measurable_set (¬´expr ‚Åª¬π' ¬ª f s)) : measurable f :=\n  by\n  apply measurable_of_is_closed; intro s hs\n  cases' eq_empty_or_nonempty s with h1 h1; ¬∑ simp [h1]\n  by_cases h2 : s = univ; ¬∑ simp [h2]\n  exact hf s hs h1 h2\n#align measurable_of_is_closed' measurable_of_is_closed'\n\n",
 "measurable_of_is_closed":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚Åª¬π' ¬ª -/\ntheorem measurable_of_is_closed {f : Œ¥ ‚Üí Œ≥} (hf : ‚àÄ s, is_closed s ‚Üí measurable_set (¬´expr ‚Åª¬π' ¬ª f s)) : measurable f :=\n  by\n  apply measurable_of_is_open; intro s hs\n  rw [‚Üê measurable_set.compl_iff, ‚Üê preimage_compl]; apply hf; rw [is_closed_compl_iff]; exact hs\n#align measurable_of_is_closed measurable_of_is_closed\n\n",
 "measurable_of_continuous_on_compl_singleton":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ·∂ú¬ª -/\ntheorem measurable_of_continuous_on_compl_singleton [t1_space Œ±] {f : Œ± ‚Üí Œ≥} (a : Œ±)\n    (hf : continuous_on f (¬´expr ·∂ú¬ª {a})) : measurable f :=\n  measurable_of_measurable_on_compl_singleton a (continuous_on_iff_continuous_restrict.1 hf).measurable\n#align measurable_of_continuous_on_compl_singleton measurable_of_continuous_on_compl_singleton\n\n",
 "measurable_of_Ioi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚Åª¬π' ¬ª -/\ntheorem measurable_of_Ioi {f : Œ¥ ‚Üí Œ±} (hf : ‚àÄ x, measurable_set (¬´expr ‚Åª¬π' ¬ª f (Ioi x))) : measurable f :=\n  by\n  convert measurable_generate_from _\n  exact borel_space.measurable_eq.trans (borel_eq_generate_from_Ioi _)\n  rintro _ ‚ü®x, rfl‚ü©; exact hf x\n#align measurable_of_Ioi measurable_of_Ioi\n\n",
 "measurable_of_Iio":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚Åª¬π' ¬ª -/\ntheorem measurable_of_Iio {f : Œ¥ ‚Üí Œ±} (hf : ‚àÄ x, measurable_set (¬´expr ‚Åª¬π' ¬ª f (Iio x))) : measurable f :=\n  by\n  convert measurable_generate_from _\n  exact borel_space.measurable_eq.trans (borel_eq_generate_from_Iio _)\n  rintro _ ‚ü®x, rfl‚ü©; exact hf x\n#align measurable_of_Iio measurable_of_Iio\n\n",
 "measurable_of_Iic":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚Åª¬π' ¬ª -/\ntheorem measurable_of_Iic {f : Œ¥ ‚Üí Œ±} (hf : ‚àÄ x, measurable_set (¬´expr ‚Åª¬π' ¬ª f (Iic x))) : measurable f :=\n  by\n  apply measurable_of_Ioi\n  simp_rw [‚Üê compl_Iic, preimage_compl, measurable_set.compl_iff]\n  assumption\n#align measurable_of_Iic measurable_of_Iic\n\n",
 "measurable_of_Ici":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚Åª¬π' ¬ª -/\ntheorem measurable_of_Ici {f : Œ¥ ‚Üí Œ±} (hf : ‚àÄ x, measurable_set (¬´expr ‚Åª¬π' ¬ª f (Ici x))) : measurable f :=\n  by\n  apply measurable_of_Iio\n  simp_rw [‚Üê compl_Ici, preimage_compl, measurable_set.compl_iff]\n  assumption\n#align measurable_of_Ici measurable_of_Ici\n\n",
 "measurable_norm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expr‚Ñù -/\n@[measurability]\ntheorem measurable_norm : measurable (norm : Œ± ‚Üí expr‚Ñù) :=\n  continuous_norm.measurable\n#align measurable_norm measurable_norm\n\n",
 "measurable_nnnorm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n@[measurability]\ntheorem measurable_nnnorm : measurable (nnnorm : Œ± ‚Üí nnreal) :=\n  continuous_nnnorm.measurable\n#align measurable_nnnorm measurable_nnnorm\n\n",
 "measurable_nndist":
 "@[measurability]\ntheorem measurable_nndist : measurable fun p : Œ± √ó Œ± => nndist p.1 p.2 :=\n  continuous_nndist.measurable\n#align measurable_nndist measurable_nndist\n\n",
 "measurable_mk'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expr‚Ñù -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expr‚Ñù -/\n/- Instances on `real` and `complex` are special cases of `is_R_or_C` but without these instances,\nLean fails to prove `borel_space (Œπ ‚Üí ‚Ñù)`, so we leave them here. -/\n@[measurability]\nprotected theorem add_circle.measurable_mk' {a : expr‚Ñù} : measurable (coe : expr‚Ñù ‚Üí add_circle a) :=\n  continuous.measurable <| add_circle.continuous_mk' a\n#align add_circle.measurable_mk' add_circle.measurable_mk'\n\n",
 "measurable_limsup'":
 "/-- `limsup` over a general filter is measurable. See `measurable_limsup` for the version over `‚Ñï`.\n-/\ntheorem measurable_limsup' {Œπ Œπ'} {f : Œπ ‚Üí Œ¥ ‚Üí Œ±} {u : filter Œπ} (hf : ‚àÄ i, measurable (f i)) {p : Œπ' ‚Üí Prop}\n    {s : Œπ' ‚Üí set Œπ} (hu : u.has_countable_basis p s) (hs : ‚àÄ i, (s i).countable) :\n    measurable fun x => limsup (fun i => f i x) u :=\n  by\n  simp_rw [hu.to_has_basis.limsup_eq_infi_supr]\n  refine' measurable_binfi _ hu.countable _\n  exact fun i => measurable_bsupr _ (hs i) hf\n#align measurable_limsup' measurable_limsup'\n\n",
 "measurable_limsup":
 "/-- `limsup` over `‚Ñï` is measurable. See `measurable_limsup'` for a version with a general filter.\n-/\n@[measurability]\ntheorem measurable_limsup {f : ‚Ñï ‚Üí Œ¥ ‚Üí Œ±} (hf : ‚àÄ i, measurable (f i)) :\n    measurable fun x => limsup (fun i => f i x) at_top :=\n  measurable_limsup' hf at_top_countable_basis fun i => to_countable _\n#align measurable_limsup measurable_limsup\n\n",
 "measurable_limit_of_tendsto_metrizable_ae":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚ä•¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚àÄ·µê ‚àÇ , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚àÄ·µê ‚àÇ , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚àÄ·µê ‚àÇ , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚àÄ·µê ‚àÇ , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚àÄ·µê ‚àÇ , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚àÄ·µê ‚àÇ , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚àÄ·µê ‚àÇ , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚àÄ·µê ‚àÇ , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem measurable_limit_of_tendsto_metrizable_ae {Œπ} [countable Œπ] [nonempty Œπ] {Œº : measure Œ±} {f : Œπ ‚Üí Œ± ‚Üí Œ≤}\n    {L : filter Œπ} [L.is_countably_generated] (hf : ‚àÄ n, ae_measurable (f n) Œº)\n    (h_ae_tendsto :\n      ¬´expr‚àÄ·µê ‚àÇ , ¬ª \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚àÄ·µê ‚àÇ , ¬ª\" Œº\n        (‚àÉ l : Œ≤, tendsto (fun n => f n x) L ((nhds) l))) :\n    ‚àÉ (f_lim : Œ± ‚Üí Œ≤)(hf_lim_meas : measurable f_lim),\n      ¬´expr‚àÄ·µê ‚àÇ , ¬ª \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚àÄ·µê ‚àÇ , ¬ª\" Œº\n        (tendsto (fun n => f n x) L ((nhds) (f_lim x))) :=\n  by\n  inhabit Œπ\n  rcases eq_or_ne L (¬´expr‚ä•¬ª) with (rfl | hL)\n  ¬∑ exact ‚ü®(hf default).mk _, (hf default).measurable_mk, eventually_of_forall fun x => tendsto_bot‚ü©\n  haveI : ne_bot L := ‚ü®hL‚ü©\n  let p : Œ± ‚Üí (Œπ ‚Üí Œ≤) ‚Üí Prop := fun x f' => ‚àÉ l : Œ≤, tendsto (fun n => f' n) L ((nhds) l)\n  have hp_mem : ‚àÄ x ‚àà ae_seq_set hf p, p x fun n => f n x := fun x hx => ae_seq.fun_prop_of_mem_ae_seq_set hf hx\n  have h_ae_eq :\n    ¬´expr‚àÄ·µê ‚àÇ , ¬ª \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚àÄ·µê ‚àÇ , ¬ª\" Œº\n      (‚àÄ n, ae_seq hf p n x = f n x) :=\n    ae_seq.ae_seq_eq_fun_ae hf h_ae_tendsto\n  let f_lim : Œ± ‚Üí Œ≤ := fun x =>\n    dite (x ‚àà ae_seq_set hf p) (fun h => (hp_mem x h).some) fun h => (‚ü®f default x‚ü© : nonempty Œ≤).some\n  have hf_lim : ‚àÄ x, tendsto (fun n => ae_seq hf p n x) L ((nhds) (f_lim x)) :=\n    by\n    intro x\n    simp only [f_lim, ae_seq]\n    split_ifs\n    ¬∑ refine' (hp_mem x h).some_spec.congr fun n => _\n      exact (ae_seq.mk_eq_fun_of_mem_ae_seq_set hf h n).symm\n    ¬∑ exact tendsto_const_nhds\n  have h_ae_tendsto_f_lim :\n    ¬´expr‚àÄ·µê ‚àÇ , ¬ª \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚àÄ·µê ‚àÇ , ¬ª\" Œº\n      (tendsto (fun n => f n x) L ((nhds) (f_lim x))) :=\n    h_ae_eq.mono fun x hx => (hf_lim x).congr hx\n  have h_f_lim_meas : measurable f_lim :=\n    measurable_of_tendsto_metrizable' L (ae_seq.measurable hf p) (tendsto_pi_nhds.mpr fun x => hf_lim x)\n  exact ‚ü®f_lim, h_f_lim_meas, h_ae_tendsto_f_lim‚ü©\n#align measurable_limit_of_tendsto_metrizable_ae measurable_limit_of_tendsto_metrizable_ae\n\n",
 "measurable_liminf'":
 "/-- `liminf` over a general filter is measurable. See `measurable_liminf` for the version over `‚Ñï`.\n-/\ntheorem measurable_liminf' {Œπ Œπ'} {f : Œπ ‚Üí Œ¥ ‚Üí Œ±} {u : filter Œπ} (hf : ‚àÄ i, measurable (f i)) {p : Œπ' ‚Üí Prop}\n    {s : Œπ' ‚Üí set Œπ} (hu : u.has_countable_basis p s) (hs : ‚àÄ i, (s i).countable) :\n    measurable fun x => liminf (fun i => f i x) u :=\n  by\n  simp_rw [hu.to_has_basis.liminf_eq_supr_infi]\n  refine' measurable_bsupr _ hu.countable _\n  exact fun i => measurable_binfi _ (hs i) hf\n#align measurable_liminf' measurable_liminf'\n\n",
 "measurable_liminf":
 "/-- `liminf` over `‚Ñï` is measurable. See `measurable_liminf'` for a version with a general filter.\n-/\n@[measurability]\ntheorem measurable_liminf {f : ‚Ñï ‚Üí Œ¥ ‚Üí Œ±} (hf : ‚àÄ i, measurable (f i)) :\n    measurable fun x => liminf (fun i => f i x) at_top :=\n  measurable_liminf' hf at_top_countable_basis fun i => to_countable _\n#align measurable_liminf measurable_liminf\n\n",
 "measurable_infi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚®Ö , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚®Ö , ¬ª -/\n@[measurability]\ntheorem measurable_infi {Œπ} [countable Œπ] {f : Œπ ‚Üí Œ¥ ‚Üí Œ±} (hf : ‚àÄ i, measurable (f i)) :\n    measurable fun b =>\n      ¬´expr‚®Ö , ¬ª \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚®Ö , ¬ª\" (f i b) :=\n  measurable.is_glb hf fun b => isGLB_inf·µ¢\n#align measurable_infi measurable_infi\n\n",
 "measurable_inf_nndist":
 "@[measurability]\ntheorem measurable_inf_nndist {s : set Œ±} : measurable fun x => inf_nndist x s :=\n  (continuous_inf_nndist_pt s).measurable\n#align measurable_inf_nndist measurable_inf_nndist\n\n",
 "measurable_inf_edist":
 "@[measurability]\ntheorem measurable_inf_edist {s : set Œ±} : measurable fun x => inf_edist x s :=\n  continuous_inf_edist.measurable\n#align measurable_inf_edist measurable_inf_edist\n\n",
 "measurable_inf_dist":
 "@[measurability]\ntheorem measurable_inf_dist {s : set Œ±} : measurable fun x => inf_dist x s :=\n  (continuous_inf_dist_pt s).measurable\n#align measurable_inf_dist measurable_inf_dist\n\n",
 "measurable_ereal_to_real":
 "@[measurability]\ntheorem measurable_ereal_to_real : measurable ereal.to_real :=\n  ereal.measurable_of_measurable_real (by simpa using measurable_id)\n#align measurable_ereal_to_real measurable_ereal_to_real\n\n",
 "measurable_ennnorm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚Äñ ‚Äñ‚Çä¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n@[measurability]\ntheorem measurable_ennnorm : measurable fun x : Œ± => (¬´expr‚Äñ ‚Äñ‚Çä¬ª x : ennreal) :=\n  measurable_nnnorm.coe_nnreal_ennreal\n#align measurable_ennnorm measurable_ennnorm\n\n",
 "measurable_embedding":
 "protected theorem open_embedding.measurable_embedding {f : Œ± ‚Üí Œ≤} (h : open_embedding f) : measurable_embedding f :=\n  h.to_embedding.measurable_embedding h.open_range.measurable_set\n#align open_embedding.measurable_embedding open_embedding.measurable_embedding\n\n",
 "measurable_edist_right":
 "@[measurability]\ntheorem measurable_edist_right : measurable (edist x) :=\n  (continuous_const.edist continuous_id).measurable\n#align measurable_edist_right measurable_edist_right\n\n",
 "measurable_edist_left":
 "@[measurability]\ntheorem measurable_edist_left : measurable fun y => edist y x :=\n  (continuous_id.edist continuous_const).measurable\n#align measurable_edist_left measurable_edist_left\n\n",
 "measurable_edist":
 "@[measurability]\ntheorem measurable_edist : measurable fun p : Œ± √ó Œ± => edist p.1 p.2 :=\n  continuous_edist.measurable\n#align measurable_edist measurable_edist\n\n",
 "measurable_dist":
 "@[measurability]\ntheorem measurable_dist : measurable fun p : Œ± √ó Œ± => dist p.1 p.2 :=\n  continuous_dist.measurable\n#align measurable_dist measurable_dist\n\n",
 "measurable_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚ÜíL[ ] ¬ª -/\ntheorem measurable_comp (L : ¬´expr ‚ÜíL[ ] ¬ª E ùïú F) {œÜ : Œ± ‚Üí E} (œÜ_meas : measurable œÜ) :\n    measurable fun a : Œ± => L (œÜ a) :=\n  L.measurable.comp œÜ_meas\n#align measurable_comp measurable_comp\n\n",
 "measurable_coe_real_ereal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expr‚Ñù -/\n@[measurability]\ntheorem measurable_coe_real_ereal : measurable (coe : expr‚Ñù ‚Üí ereal) :=\n  continuous_coe_real_ereal.measurable\n#align measurable_coe_real_ereal measurable_coe_real_ereal\n\n",
 "measurable_coe_nnreal_real_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expr‚Ñù -/\n@[simp, norm_cast]\ntheorem measurable_coe_nnreal_real_iff {f : Œ± ‚Üí nnreal} : measurable (fun x => f x : Œ± ‚Üí expr‚Ñù) ‚Üî measurable f :=\n  ‚ü®fun h => by simpa only [real.to_nnreal_coe] using h.real_to_nnreal, measurable.coe_nnreal_real‚ü©\n#align measurable_coe_nnreal_real_iff measurable_coe_nnreal_real_iff\n\n",
 "measurable_coe_nnreal_real":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expr‚Ñù -/\n@[measurability]\ntheorem measurable_coe_nnreal_real : measurable (coe : nnreal ‚Üí expr‚Ñù) :=\n  nnreal.continuous_coe.measurable\n#align measurable_coe_nnreal_real measurable_coe_nnreal_real\n\n",
 "measurable_coe_nnreal_ennreal_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n@[simp, norm_cast]\ntheorem measurable_coe_nnreal_ennreal_iff {f : Œ± ‚Üí nnreal} : (measurable fun x => (f x : ennreal)) ‚Üî measurable f :=\n  ‚ü®fun h => h.ennreal_to_nnreal, fun h => h.coe_nnreal_ennreal‚ü©\n#align measurable_coe_nnreal_ennreal_iff measurable_coe_nnreal_ennreal_iff\n\n",
 "measurable_coe_nnreal_ennreal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n@[measurability]\ntheorem measurable_coe_nnreal_ennreal : measurable (coe : nnreal ‚Üí ennreal) :=\n  ennreal.continuous_coe.measurable\n#align measurable_coe_nnreal_ennreal measurable_coe_nnreal_ennreal\n\n",
 "measurable_coe_ennreal_ereal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n@[measurability]\ntheorem measurable_coe_ennreal_ereal : measurable (coe : ennreal ‚Üí ereal) :=\n  continuous_coe_ennreal_ereal.measurable\n#align measurable_coe_ennreal_ereal measurable_coe_ennreal_ereal\n\n",
 "measurable_coe":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚ÜíL[ ] ¬ª -/\n@[measurability]\ntheorem measurable_coe [measurable_space F] [borel_space F] : measurable fun (f : ¬´expr ‚ÜíL[ ] ¬ª E ùïú F) (x : E) => f x :=\n  measurable_pi_lambda _ measurable_apply\n#align measurable_coe measurable_coe\n\n",
 "measurable_cSup":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr '' ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr '' ¬ª -/\ntheorem measurable_cSup {Œπ} {f : Œπ ‚Üí Œ¥ ‚Üí Œ±} {s : set Œπ} (hs : s.countable) (hf : ‚àÄ i, measurable (f i))\n    (bdd : ‚àÄ x, BddAbove (¬´expr '' ¬ª (fun i => f i x) s)) : measurable fun x => sup‚Çõ (¬´expr '' ¬ª (fun i => f i x) s) :=\n  by\n  cases' eq_empty_or_nonempty s with h2s h2s\n  ¬∑ simp [h2s, measurable_const]\n  ¬∑ apply measurable_of_Iic\n    intro y\n    simp_rw [preimage, mem_Iic, csup‚Çõ_le_iff (bdd _) (h2s.image _), ball_image_iff, set_of_forall]\n    exact measurable_set.bInter hs fun i hi => measurable_set_le (hf i) measurable_const\n#align measurable_cSup measurable_cSup\n\n",
 "measurable_bsupr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚®Ü , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚®Ü , ¬ª -/\ntheorem measurable_bsupr {Œπ} (s : set Œπ) {f : Œπ ‚Üí Œ¥ ‚Üí Œ±} (hs : s.countable) (hf : ‚àÄ i, measurable (f i)) :\n    measurable fun b =>\n      ¬´expr‚®Ü , ¬ª \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚®Ü , ¬ª\" (f i b) :=\n  by\n  haveI : Encodable s := hs.to_encodable\n  simp only [sup·µ¢_subtype']\n  exact measurable_supr fun i => hf i\n#align measurable_bsupr measurable_bsupr\n\n",
 "measurable_binfi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚®Ö , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚®Ö , ¬ª -/\ntheorem measurable_binfi {Œπ} (s : set Œπ) {f : Œπ ‚Üí Œ¥ ‚Üí Œ±} (hs : s.countable) (hf : ‚àÄ i, measurable (f i)) :\n    measurable fun b =>\n      ¬´expr‚®Ö , ¬ª \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚®Ö , ¬ª\" (f i b) :=\n  by\n  haveI : Encodable s := hs.to_encodable\n  simp only [inf·µ¢_subtype']\n  exact measurable_infi fun i => hf i\n#align measurable_binfi measurable_binfi\n\n",
 "measurable_apply'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚ÜíL[ ] ¬ª -/\n@[measurability]\ntheorem measurable_apply' [measurable_space E] [opens_measurable_space E] [measurable_space F] [borel_space F] :\n    measurable fun (x : E) (f : ¬´expr ‚ÜíL[ ] ¬ª E ùïú F) => f x :=\n  measurable_pi_lambda _ fun f => f.measurable\n#align measurable_apply' measurable_apply'\n\n",
 "measurable_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚ÜíL[ ] ¬ª -/\n@[measurability]\ntheorem measurable_apply [measurable_space F] [borel_space F] (x : E) : measurable fun f : ¬´expr ‚ÜíL[ ] ¬ª E ùïú F => f x :=\n  (apply ùïú F x).continuous.measurable\n#align measurable_apply measurable_apply\n\n",
 "measurable2":
 "theorem continuous.measurable2 [second_countable_topology Œ±] [second_countable_topology Œ≤] {f : Œ¥ ‚Üí Œ±} {g : Œ¥ ‚Üí Œ≤}\n    {c : Œ± ‚Üí Œ≤ ‚Üí Œ≥} (h : continuous fun p : Œ± √ó Œ≤ => c p.1 p.2) (hf : measurable f) (hg : measurable g) :\n    measurable fun a => c (f a) (g a) :=\n  h.measurable.comp (hf.prod_mk hg)\n#align continuous.measurable2 continuous.measurable2\n\n",
 "measurable":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚ÜíL[ ] ¬ª -/\n@[measurability]\nprotected theorem measurable (L : ¬´expr ‚ÜíL[ ] ¬ª E ùïú F) : measurable L :=\n  L.continuous.measurable\n#align measurable measurable\n\n",
 "max":
 "@[measurability]\ntheorem ae_measurable.max {f g : Œ¥ ‚Üí Œ±} {Œº : measure Œ¥} (hf : ae_measurable f Œº) (hg : ae_measurable g Œº) :\n    ae_measurable (fun a => max (f a) (g a)) Œº :=\n  ‚ü®fun a => max (hf.mk f a) (hg.mk g a), hf.measurable_mk.max hg.measurable_mk,\n    eventually_eq.comp‚ÇÇ hf.ae_eq_mk _ hg.ae_eq_mk‚ü©\n#align ae_measurable.max ae_measurable.max\n\n",
 "map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚âÉ‚Çú ¬ª -/\nprotected theorem is_finite_measure_on_compacts.map {Œ± : Type _} {m0 : measurable_space Œ±} [topological_space Œ±]\n    [opens_measurable_space Œ±] {Œ≤ : Type _} [measurable_space Œ≤] [topological_space Œ≤] [borel_space Œ≤] [t2_space Œ≤]\n    (Œº : measure Œ±) [is_finite_measure_on_compacts Œº] (f : ¬´expr ‚âÉ‚Çú ¬ª Œ± Œ≤) :\n    is_finite_measure_on_compacts (measure.map f Œº) :=\n  ‚ü®by\n    intro K hK\n    rw [measure.map_apply f.measurable hK.measurable_set]\n    apply is_compact.measure_lt_top\n    rwa [f.is_compact_preimage]‚ü©\n#align is_finite_measure_on_compacts.map is_finite_measure_on_compacts.map\n\n",
 "is_pi_system_is_open":
 "theorem is_pi_system_is_open [topological_space Œ±] : is_pi_system (is_open : set Œ± ‚Üí Prop) := fun s hs t ht hst =>\n  is_open.inter hs ht\n#align is_pi_system_is_open is_pi_system_is_open\n\n",
 "is_pi_system_Ioo_rat":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expr‚Ñö -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expr‚Ñù -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expr‚Ñö -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expr‚Ñù -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expr‚Ñù -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚ãÉ , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚ãÉ , ¬ª -/\ntheorem is_pi_system_Ioo_rat :\n    @is_pi_system (expr‚Ñù)\n      (¬´expr‚ãÉ , ¬ª \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚ãÉ , ¬ª\" {Ioo a b}) :=\n  by\n  convert is_pi_system_Ioo (coe : expr‚Ñö ‚Üí expr‚Ñù) (coe : expr‚Ñö ‚Üí expr‚Ñù)\n  ext x\n  simp [eq_comm]\n#align is_pi_system_Ioo_rat is_pi_system_Ioo_rat\n\n",
 "is_open_pos_measure_map":
 "theorem continuous.is_open_pos_measure_map {f : Œ≤ ‚Üí Œ≥} (hf : continuous f) (hf_surj : function.surjective f)\n    {Œº : measure Œ≤} [Œº.is_open_pos_measure] : (measure.map f Œº).is_open_pos_measure :=\n  by\n  refine' ‚ü®fun U hUo hUne => _‚ü©\n  rw [measure.map_apply hf.measurable hUo.measurable_set]\n  exact (hUo.preimage hf).measure_ne_zero Œº (hf_surj.nonempty_preimage.mpr hUne)\n#align continuous.is_open_pos_measure_map continuous.is_open_pos_measure_map\n\n",
 "is_lub_of_nonempty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚àÄ·µê ‚àÇ , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚àÄ·µê ‚àÇ , ¬ª -/\nprivate theorem ae_measurable.is_lub_of_nonempty {Œπ} (hŒπ : nonempty Œπ) {Œº : measure Œ¥} [countable Œπ] {f : Œπ ‚Üí Œ¥ ‚Üí Œ±}\n    {g : Œ¥ ‚Üí Œ±} (hf : ‚àÄ i, ae_measurable (f i) Œº)\n    (hg :\n      ¬´expr‚àÄ·µê ‚àÇ , ¬ª \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚àÄ·µê ‚àÇ , ¬ª\" Œº\n        (IsLUB { a | ‚àÉ i, f i b = a } (g b))) :\n    ae_measurable g Œº :=\n  by\n  let p : Œ¥ ‚Üí (Œπ ‚Üí Œ±) ‚Üí Prop := fun x f' => IsLUB { a | ‚àÉ i, f' i = a } (g x)\n  let g_seq x := ite (x ‚àà ae_seq_set hf p) (g x) (‚ü®g x‚ü© : nonempty Œ±).some\n  have hg_seq : ‚àÄ b, IsLUB { a | ‚àÉ i, ae_seq hf p i b = a } (g_seq b) :=\n    by\n    intro b\n    haveI hŒ± : nonempty Œ± := nonempty.map g ‚ü®b‚ü©\n    simp only [ae_seq, g_seq]\n    split_ifs\n    ¬∑ have h_set_eq : { a : Œ± | ‚àÉ i : Œπ, (hf i).mk (f i) b = a } = { a : Œ± | ‚àÉ i : Œπ, f i b = a } :=\n        by\n        ext x\n        simp_rw [Set.mem_setOf_eq, ae_seq.mk_eq_fun_of_mem_ae_seq_set hf h]\n      rw [h_set_eq]\n      exact ae_seq.fun_prop_of_mem_ae_seq_set hf h\n    ¬∑ have h_singleton : { a : Œ± | ‚àÉ i : Œπ, hŒ±.some = a } = {hŒ±.some} :=\n        by\n        ext1 x\n        exact ‚ü®fun hx => hx.some_spec.symm, fun hx => ‚ü®hŒπ.some, hx.symm‚ü©‚ü©\n      rw [h_singleton]\n      exact isLUB_singleton\n  refine' ‚ü®g_seq, measurable.is_lub (ae_seq.measurable hf p) hg_seq, _‚ü©\n  exact\n    (ite_ae_eq_of_measure_compl_zero g (fun x => (‚ü®g x‚ü© : nonempty Œ±).some) (ae_seq_set hf p)\n        (ae_seq.measure_compl_ae_seq_set_eq_zero hf hg)).symm\n#align ae_measurable.is_lub_of_nonempty ae_measurable.is_lub_of_nonempty\n\n",
 "is_lub":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr =·µê[ ] ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚àÄ·µê ‚àÇ , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚àÄ·µê ‚àÇ , ¬ª -/\ntheorem ae_measurable.is_lub {Œπ} {Œº : measure Œ¥} [countable Œπ] {f : Œπ ‚Üí Œ¥ ‚Üí Œ±} {g : Œ¥ ‚Üí Œ±}\n    (hf : ‚àÄ i, ae_measurable (f i) Œº)\n    (hg :\n      ¬´expr‚àÄ·µê ‚àÇ , ¬ª \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚àÄ·µê ‚àÇ , ¬ª\" Œº\n        (IsLUB { a | ‚àÉ i, f i b = a } (g b))) :\n    ae_measurable g Œº := by\n  by_cases hŒº : Œº = 0\n  ¬∑ rw [hŒº]\n    exact ae_measurable_zero_measure\n  have : Œº.ae.ne_bot := by simpa [ne_bot_iff]\n  by_cases hŒπ : nonempty Œπ\n  ¬∑ exact ae_measurable.is_lub_of_nonempty hŒπ hf hg\n  suffices ‚àÉ x, ¬´expr =·µê[ ] ¬ª g Œº fun y => g x by exact ‚ü®fun y => g this.some, measurable_const, this.some_spec‚ü©\n  have h_empty : ‚àÄ x, { a : Œ± | ‚àÉ i : Œπ, f i x = a } = ‚àÖ :=\n    by\n    intro x\n    ext1 y\n    rw [Set.mem_setOf_eq, Set.mem_empty_iff_false, iff_false_iff]\n    exact fun hi => hŒπ (nonempty_of_exists hi)\n  simp_rw [h_empty] at hg\n  exact ‚ü®hg.exists.some, hg.mono fun y hy => IsLUB.unique hy hg.exists.some_spec‚ü©\n#align ae_measurable.is_lub ae_measurable.is_lub\n\n",
 "is_glb":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚àÄ·µê ‚àÇ , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚àÄ·µê ‚àÇ , ¬ª -/\ntheorem ae_measurable.is_glb {Œπ} {Œº : measure Œ¥} [countable Œπ] {f : Œπ ‚Üí Œ¥ ‚Üí Œ±} {g : Œ¥ ‚Üí Œ±}\n    (hf : ‚àÄ i, ae_measurable (f i) Œº)\n    (hg :\n      ¬´expr‚àÄ·µê ‚àÇ , ¬ª \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚àÄ·µê ‚àÇ , ¬ª\" Œº\n        (IsGLB { a | ‚àÉ i, f i b = a } (g b))) :\n    ae_measurable g Œº := by\n  nontriviality Œ±\n  haveI hŒ± : nonempty Œ± := infer_instance\n  cases' isEmpty_or_nonempty Œπ with hŒπ hŒπ\n  ¬∑ simp only [is_empty.exists_iff, set_of_false, is_glb_empty_iff] at hg\n    exact ae_measurable_const' (hg.mono fun a ha => hg.mono fun b hb => (hb _).antisymm (ha _))\n  let p : Œ¥ ‚Üí (Œπ ‚Üí Œ±) ‚Üí Prop := fun x f' => IsGLB { a | ‚àÉ i, f' i = a } (g x)\n  let g_seq := (ae_seq_set hf p).piecewise g fun _ => hŒ±.some\n  have hg_seq : ‚àÄ b, IsGLB { a | ‚àÉ i, ae_seq hf p i b = a } (g_seq b) :=\n    by\n    intro b\n    simp only [ae_seq, g_seq, set.piecewise]\n    split_ifs\n    ¬∑ have h_set_eq : { a : Œ± | ‚àÉ i : Œπ, (hf i).mk (f i) b = a } = { a : Œ± | ‚àÉ i : Œπ, f i b = a } :=\n        by\n        ext x\n        simp_rw [Set.mem_setOf_eq, ae_seq.mk_eq_fun_of_mem_ae_seq_set hf h]\n      rw [h_set_eq]\n      exact ae_seq.fun_prop_of_mem_ae_seq_set hf h\n    ¬∑ exact IsLeast.isGLB ‚ü®(@exists_const (hŒ±.some = hŒ±.some) Œπ _).2 rfl, fun x ‚ü®i, hi‚ü© => hi.le‚ü©\n  refine' ‚ü®g_seq, measurable.is_glb (ae_seq.measurable hf p) hg_seq, _‚ü©\n  exact\n    (ite_ae_eq_of_measure_compl_zero g (fun x => hŒ±.some) (ae_seq_set hf p)\n        (ae_seq.measure_compl_ae_seq_set_eq_zero hf hg)).symm\n#align ae_measurable.is_glb ae_measurable.is_glb\n\n",
 "interior_ae_eq_of_null_frontier":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr =·µê[ ] ¬ª -/\n-- see Note [lower instance priority]\ntheorem interior_ae_eq_of_null_frontier {Œº : measure Œ±'} {s : set Œ±'} (h : Œº (frontier s) = 0) :\n    ¬´expr =·µê[ ] ¬ª (interior s) Œº s :=\n  interior_subset.eventually_le.antisymm <| subset_closure.eventually_le.trans (ae_le_set.2 h)\n#align interior_ae_eq_of_null_frontier interior_ae_eq_of_null_frontier\n\n",
 "infi_Prop":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚®Ö , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚®Ö , ¬ª -/\n@[measurability]\ntheorem measurable.infi_Prop {Œ±} [measurable_space Œ±] [CompleteLattice Œ±] (p : Prop) {f : Œ¥ ‚Üí Œ±} (hf : measurable f) :\n    measurable fun b =>\n      ¬´expr‚®Ö , ¬ª \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚®Ö , ¬ª\" (f b) :=\n  by_cases (fun h : p => by convert hf; funext ; exact inf·µ¢_pos h) fun h : ¬¨p => by convert measurable_const; funext ;\n    exact inf·µ¢_neg h\n#align measurable.infi_Prop measurable.infi_Prop\n\n",
 "inf_nndist":
 "@[measurability]\ntheorem measurable.inf_nndist {f : Œ≤ ‚Üí Œ±} (hf : measurable f) {s : set Œ±} : measurable fun x => inf_nndist (f x) s :=\n  measurable_inf_nndist.comp hf\n#align measurable.inf_nndist measurable.inf_nndist\n\n",
 "inf_edist":
 "@[measurability]\ntheorem measurable.inf_edist {f : Œ≤ ‚Üí Œ±} (hf : measurable f) {s : set Œ±} : measurable fun x => inf_edist (f x) s :=\n  measurable_inf_edist.comp hf\n#align measurable.inf_edist measurable.inf_edist\n\n",
 "inf_dist":
 "@[measurability]\ntheorem measurable.inf_dist {f : Œ≤ ‚Üí Œ±} (hf : measurable f) {s : set Œ±} : measurable fun x => inf_dist (f x) s :=\n  measurable_inf_dist.comp hf\n#align measurable.inf_dist measurable.inf_dist\n\n",
 "induction_on_open":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ·∂ú¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr on ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚ãÉ , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚ãÉ , ¬ª -/\ntheorem _root_.measurable_set.induction_on_open [topological_space Œ±] [measurable_space Œ±] [borel_space Œ±]\n    {C : set Œ± ‚Üí Prop} (h_open : ‚àÄ U, is_open U ‚Üí C U) (h_compl : ‚àÄ t, measurable_set t ‚Üí C t ‚Üí C (¬´expr ·∂ú¬ª t))\n    (h_union :\n      ‚àÄ f : ‚Ñï ‚Üí set Œ±,\n        Pairwise (¬´expr on ¬ª Disjoint f) ‚Üí\n          (‚àÄ i, measurable_set (f i)) ‚Üí\n            (‚àÄ i, C (f i)) ‚Üí\n              C\n                (¬´expr‚ãÉ , ¬ª \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚ãÉ , ¬ª\"\n                  (f i))) :\n    ‚àÄ ‚¶Ét‚¶Ñ, measurable_set t ‚Üí C t :=\n  measurable_space.induction_on_inter borel_space.measurable_eq is_pi_system_is_open (h_open _ is_open_empty) h_open\n    h_compl h_union\n#align measurable_set.induction_on_open measurable_set.induction_on_open\n\n",
 "generate_from_Ico_mem_le_borel":
 "theorem generate_from_Ico_mem_le_borel {Œ± : Type _} [topological_space Œ±] [linear_order Œ±] [order_closed_topology Œ±]\n    (s t : set Œ±) : measurable_space.generate_from { S | ‚àÉ l ‚àà s, ‚àÉ u ‚àà t, ‚àÉ h : l < u, Ico l u = S } ‚â§ borel Œ± :=\n  by\n  apply generate_from_le\n  borelize Œ±\n  rintro _ ‚ü®a, -, b, -, -, rfl‚ü©\n  exact measurable_set_Ico\n#align generate_from_Ico_mem_le_borel generate_from_Ico_mem_le_borel\n\n",
 "ext_of_Ioc_finite":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ·µí·µà¬ª -/\n/-- Two finite measures on a Borel space are equal if they agree on all open-closed intervals.  If\n`Œ±` is a conditionally complete linear order with no top element,\n`measure_theory.measure..ext_of_Ioc` is an extensionality lemma with weaker assumptions on `Œº` and\n`ŒΩ`. -/\ntheorem ext_of_Ioc_finite {Œ± : Type _} [topological_space Œ±] {m : measurable_space Œ±} [second_countable_topology Œ±]\n    [linear_order Œ±] [order_topology Œ±] [borel_space Œ±] (Œº ŒΩ : measure Œ±) [is_finite_measure Œº] (hŒºŒΩ : Œº univ = ŒΩ univ)\n    (h : ‚àÄ ‚¶Éa b‚¶Ñ, a < b ‚Üí Œº (Ioc a b) = ŒΩ (Ioc a b)) : Œº = ŒΩ :=\n  by\n  refine' @ext_of_Ico_finite (¬´expr ·µí·µà¬ª Œ±) _ _ _ _ _ ‚Äπ_‚Ä∫ Œº ŒΩ _ hŒºŒΩ fun a b hab => _\n  erw [dual_Ico]\n  exact h hab\n#align ext_of_Ioc_finite ext_of_Ioc_finite\n\n",
 "ext_of_Ioc'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ·µí·µà¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/-- Two measures which are finite on closed-open intervals are equal if the agree on all\nopen-closed intervals. -/\ntheorem ext_of_Ioc' {Œ± : Type _} [topological_space Œ±] {m : measurable_space Œ±} [second_countable_topology Œ±]\n    [linear_order Œ±] [order_topology Œ±] [borel_space Œ±] [NoMinOrder Œ±] (Œº ŒΩ : measure Œ±)\n    (hŒº : ‚àÄ ‚¶Éa b‚¶Ñ, a < b ‚Üí Œº (Ioc a b) ‚â† ennreal.top) (h : ‚àÄ ‚¶Éa b‚¶Ñ, a < b ‚Üí Œº (Ioc a b) = ŒΩ (Ioc a b)) : Œº = ŒΩ :=\n  by\n  refine' @ext_of_Ico' (¬´expr ·µí·µà¬ª Œ±) _ _ _ _ _ ‚Äπ_‚Ä∫ _ Œº ŒΩ _ _ <;> intro a b hab <;> erw [dual_Ico]\n  exacts[hŒº hab, h hab]\n#align ext_of_Ioc' ext_of_Ioc'\n\n",
 "ext_of_Ioc":
 "/-- Two measures which are finite on closed-open intervals are equal if the agree on all\nopen-closed intervals. -/\ntheorem ext_of_Ioc {Œ± : Type _} [topological_space Œ±] {m : measurable_space Œ±} [second_countable_topology Œ±]\n    [ConditionallyCompleteLinearOrder Œ±] [order_topology Œ±] [borel_space Œ±] [NoMinOrder Œ±] (Œº ŒΩ : measure Œ±)\n    [is_locally_finite_measure Œº] (h : ‚àÄ ‚¶Éa b‚¶Ñ, a < b ‚Üí Œº (Ioc a b) = ŒΩ (Ioc a b)) : Œº = ŒΩ :=\n  Œº.ext_of_Ioc' ŒΩ (fun a b hab => measure_Ioc_lt_top.ne) h\n#align ext_of_Ioc ext_of_Ioc\n\n",
 "ext_of_Iic":
 "/-- Two finite measures on a Borel space are equal if they agree on all left-infinite right-closed\nintervals. -/\ntheorem ext_of_Iic {Œ± : Type _} [topological_space Œ±] {m : measurable_space Œ±} [second_countable_topology Œ±]\n    [linear_order Œ±] [order_topology Œ±] [borel_space Œ±] (Œº ŒΩ : measure Œ±) [is_finite_measure Œº]\n    (h : ‚àÄ a, Œº (Iic a) = ŒΩ (Iic a)) : Œº = ŒΩ :=\n  by\n  refine' ext_of_Ioc_finite Œº ŒΩ _ fun a b hlt => _\n  ¬∑ rcases exists_countable_dense_bot_top Œ± with ‚ü®s, hsc, hsd, -, hst‚ü©\n    have : DirectedOn (¬∑ ‚â§ ¬∑) s := directedOn_iff_directed.2 (directed_of_sup fun _ _ => id)\n    simp only [‚Üê bsupr_measure_Iic hsc (hsd.exists_ge' hst) this, h]\n  rw [‚Üê Iic_diff_Iic, measure_diff (Iic_subset_Iic.2 hlt.le) measurable_set_Iic,\n    measure_diff (Iic_subset_Iic.2 hlt.le) measurable_set_Iic, h a, h b]\n  ¬∑ rw [‚Üê h a]\n    exact (measure_lt_top Œº _).ne\n  ¬∑ exact (measure_lt_top Œº _).ne\n#align ext_of_Iic ext_of_Iic\n\n",
 "ext_of_Ico_finite":
 "/-- Two finite measures on a Borel space are equal if they agree on all closed-open intervals.  If\n`Œ±` is a conditionally complete linear order with no top element,\n`measure_theory.measure..ext_of_Ico` is an extensionality lemma with weaker assumptions on `Œº` and\n`ŒΩ`. -/\ntheorem ext_of_Ico_finite {Œ± : Type _} [topological_space Œ±] {m : measurable_space Œ±} [second_countable_topology Œ±]\n    [linear_order Œ±] [order_topology Œ±] [borel_space Œ±] (Œº ŒΩ : measure Œ±) [is_finite_measure Œº] (hŒºŒΩ : Œº univ = ŒΩ univ)\n    (h : ‚àÄ ‚¶Éa b‚¶Ñ, a < b ‚Üí Œº (Ico a b) = ŒΩ (Ico a b)) : Œº = ŒΩ :=\n  by\n  refine'\n    ext_of_generate_finite _ (borel_space.measurable_eq.trans (borel_eq_generate_from_Ico Œ±))\n      (is_pi_system_Ico (id : Œ± ‚Üí Œ±) id) _ hŒºŒΩ\n  ¬∑ rintro - ‚ü®a, b, hlt, rfl‚ü©\n    exact h hlt\n#align ext_of_Ico_finite ext_of_Ico_finite\n\n",
 "ext_of_Ico'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚ãÉ , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚ãÉ , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/-- Two measures which are finite on closed-open intervals are equal if the agree on all\nclosed-open intervals. -/\ntheorem ext_of_Ico' {Œ± : Type _} [topological_space Œ±] {m : measurable_space Œ±} [second_countable_topology Œ±]\n    [linear_order Œ±] [order_topology Œ±] [borel_space Œ±] [NoMaxOrder Œ±] (Œº ŒΩ : measure Œ±)\n    (hŒº : ‚àÄ ‚¶Éa b‚¶Ñ, a < b ‚Üí Œº (Ico a b) ‚â† ennreal.top) (h : ‚àÄ ‚¶Éa b‚¶Ñ, a < b ‚Üí Œº (Ico a b) = ŒΩ (Ico a b)) : Œº = ŒΩ :=\n  by\n  rcases exists_countable_dense_bot_top Œ± with ‚ü®s, hsc, hsd, hsb, hst‚ü©\n  have :\n    (¬´expr‚ãÉ , ¬ª \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚ãÉ , ¬ª\" {Ico l u} :\n        set (set Œ±)).countable :=\n    hsc.bUnion fun l hl => hsc.bUnion fun u hu => countable_Union fun _ => countable_singleton _\n  simp only [‚Üê set_of_eq_eq_singleton, ‚Üê set_of_exists] at this\n  refine'\n    measure.ext_of_generate_from_of_cover_subset (borel_space.measurable_eq.trans (borel_eq_generate_from_Ico Œ±))\n      (is_pi_system_Ico id id) _ this _ _ _\n  ¬∑ rintro _ ‚ü®l, -, u, -, h, rfl‚ü©\n    exact ‚ü®l, u, h, rfl‚ü©\n  ¬∑ refine' sUnion_eq_univ_iff.2 fun x => _\n    rcases hsd.exists_le' hsb x with ‚ü®l, hls, hlx‚ü©\n    rcases hsd.exists_gt x with ‚ü®u, hus, hxu‚ü©\n    exact ‚ü®_, ‚ü®l, hls, u, hus, hlx.trans_lt hxu, rfl‚ü©, hlx, hxu‚ü©\n  ¬∑ rintro _ ‚ü®l, -, u, -, hlt, rfl‚ü©\n    exact hŒº hlt\n  ¬∑ rintro _ ‚ü®l, u, hlt, rfl‚ü©\n    exact h hlt\n#align ext_of_Ico' ext_of_Ico'\n\n",
 "ext_of_Ico":
 "/-- Two measures which are finite on closed-open intervals are equal if the agree on all\nclosed-open intervals. -/\ntheorem ext_of_Ico {Œ± : Type _} [topological_space Œ±] {m : measurable_space Œ±} [second_countable_topology Œ±]\n    [ConditionallyCompleteLinearOrder Œ±] [order_topology Œ±] [borel_space Œ±] [NoMaxOrder Œ±] (Œº ŒΩ : measure Œ±)\n    [is_locally_finite_measure Œº] (h : ‚àÄ ‚¶Éa b‚¶Ñ, a < b ‚Üí Œº (Ico a b) = ŒΩ (Ico a b)) : Œº = ŒΩ :=\n  Œº.ext_of_Ico' ŒΩ (fun a b hab => measure_Ico_lt_top.ne) h\n#align ext_of_Ico ext_of_Ico\n\n",
 "ext_of_Ici":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ·µí·µà¬ª -/\n/-- Two finite measures on a Borel space are equal if they agree on all left-closed right-infinite\nintervals. -/\ntheorem ext_of_Ici {Œ± : Type _} [topological_space Œ±] {m : measurable_space Œ±} [second_countable_topology Œ±]\n    [linear_order Œ±] [order_topology Œ±] [borel_space Œ±] (Œº ŒΩ : measure Œ±) [is_finite_measure Œº]\n    (h : ‚àÄ a, Œº (Ici a) = ŒΩ (Ici a)) : Œº = ŒΩ :=\n  @ext_of_Iic (¬´expr ·µí·µà¬ª Œ±) _ _ _ _ _ ‚Äπ_‚Ä∫ _ _ _ h\n#align ext_of_Ici ext_of_Ici\n\n",
 "ereal_to_real":
 "@[measurability]\ntheorem ae_measurable.ereal_to_real {f : Œ± ‚Üí ereal} {Œº : measure Œ±} (hf : ae_measurable f Œº) :\n    ae_measurable (fun x => (f x).to_real) Œº :=\n  measurable_ereal_to_real.comp_ae_measurable hf\n#align ae_measurable.ereal_to_real ae_measurable.ereal_to_real\n\n",
 "ennreal_tsum'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚àë' , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚àë' , ¬ª -/\n@[measurability]\ntheorem measurable.ennreal_tsum' {Œπ} [countable Œπ] {f : Œπ ‚Üí Œ± ‚Üí ennreal} (h : ‚àÄ i, measurable (f i)) :\n    measurable\n      (¬´expr‚àë' , ¬ª \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚àë' , ¬ª\" (f i)) :=\n  by\n  convert measurable.ennreal_tsum h\n  ext1 x\n  exact tsum_apply (pi.summable.2 fun _ => ennreal.summable)\n#align measurable.ennreal_tsum' measurable.ennreal_tsum'\n\n",
 "ennreal_tsum":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚àë' , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚àë' , ¬ª -/\n@[measurability]\ntheorem ae_measurable.ennreal_tsum {Œπ} [countable Œπ] {f : Œπ ‚Üí Œ± ‚Üí ennreal} {Œº : measure Œ±}\n    (h : ‚àÄ i, ae_measurable (f i) Œº) :\n    ae_measurable\n      (fun x =>\n        ¬´expr‚àë' , ¬ª \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚àë' , ¬ª\" (f i x))\n      Œº :=\n  by\n  simp_rw [ennreal.tsum_eq_supr_sum]\n  apply ae_measurable_supr\n  exact fun s => finset.ae_measurable_sum s fun i _ => h i\n#align ae_measurable.ennreal_tsum ae_measurable.ennreal_tsum\n\n",
 "ennreal_to_real":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n@[measurability]\ntheorem ae_measurable.ennreal_to_real {f : Œ± ‚Üí ennreal} {Œº : measure Œ±} (hf : ae_measurable f Œº) :\n    ae_measurable (fun x => ennreal.to_real (f x)) Œº :=\n  ennreal.measurable_to_real.comp_ae_measurable hf\n#align ae_measurable.ennreal_to_real ae_measurable.ennreal_to_real\n\n",
 "ennreal_to_nnreal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n@[measurability]\ntheorem ae_measurable.ennreal_to_nnreal {f : Œ± ‚Üí ennreal} {Œº : measure Œ±} (hf : ae_measurable f Œº) :\n    ae_measurable (fun x => (f x).to_nnreal) Œº :=\n  ennreal.measurable_to_nnreal.comp_ae_measurable hf\n#align ae_measurable.ennreal_to_nnreal ae_measurable.ennreal_to_nnreal\n\n",
 "ennreal_of_real":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expr‚Ñù -/\n@[measurability]\ntheorem measurable.ennreal_of_real {f : Œ± ‚Üí expr‚Ñù} (hf : measurable f) : measurable fun x => ennreal.of_real (f x) :=\n  ennreal.continuous_of_real.measurable.comp hf\n#align measurable.ennreal_of_real measurable.ennreal_of_real\n\n",
 "ennnorm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚Äñ ‚Äñ‚Çä¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n@[measurability]\ntheorem ae_measurable.ennnorm {f : Œ≤ ‚Üí Œ±} {Œº : measure Œ≤} (hf : ae_measurable f Œº) :\n    ae_measurable (fun a => (¬´expr‚Äñ ‚Äñ‚Çä¬ª (f a) : ennreal)) Œº :=\n  measurable_ennnorm.comp_ae_measurable hf\n#align ae_measurable.ennnorm ae_measurable.ennnorm\n\n",
 "edist":
 "@[measurability]\ntheorem ae_measurable.edist {f g : Œ≤ ‚Üí Œ±} {Œº : measure Œ≤} (hf : ae_measurable f Œº) (hg : ae_measurable g Œº) :\n    ae_measurable (fun a => edist (f a) (g a)) Œº :=\n  (@continuous_edist Œ± _).ae_measurable2 hf hg\n#align ae_measurable.edist ae_measurable.edist\n\n",
 "dist":
 "@[measurability]\ntheorem measurable.dist {f g : Œ≤ ‚Üí Œ±} (hf : measurable f) (hg : measurable g) : measurable fun b => dist (f b) (g b) :=\n  (@continuous_dist Œ± _).measurable2 hf hg\n#align measurable.dist measurable.dist\n\n",
 "coe_real_ereal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expr‚Ñù -/\n@[measurability]\ntheorem ae_measurable.coe_real_ereal {f : Œ± ‚Üí expr‚Ñù} {Œº : measure Œ±} (hf : ae_measurable f Œº) :\n    ae_measurable (fun x => (f x : ereal)) Œº :=\n  measurable_coe_real_ereal.comp_ae_measurable hf\n#align ae_measurable.coe_real_ereal ae_measurable.coe_real_ereal\n\n",
 "coe_nnreal_real":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expr‚Ñù -/\n@[measurability]\ntheorem ae_measurable.coe_nnreal_real {f : Œ± ‚Üí nnreal} {Œº : measure Œ±} (hf : ae_measurable f Œº) :\n    ae_measurable (fun x => (f x : expr‚Ñù)) Œº :=\n  measurable_coe_nnreal_real.comp_ae_measurable hf\n#align ae_measurable.coe_nnreal_real ae_measurable.coe_nnreal_real\n\n",
 "coe_nnreal_ennreal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n@[measurability]\ntheorem ae_measurable.coe_nnreal_ennreal {f : Œ± ‚Üí nnreal} {Œº : measure Œ±} (hf : ae_measurable f Œº) :\n    ae_measurable (fun x => (f x : ennreal)) Œº :=\n  ennreal.continuous_coe.measurable.comp_ae_measurable hf\n#align ae_measurable.coe_nnreal_ennreal ae_measurable.coe_nnreal_ennreal\n\n",
 "coe_ereal_ennreal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n@[measurability]\ntheorem ae_measurable.coe_ereal_ennreal {f : Œ± ‚Üí ennreal} {Œº : measure Œ±} (hf : ae_measurable f Œº) :\n    ae_measurable (fun x => (f x : ereal)) Œº :=\n  measurable_coe_ennreal_ereal.comp_ae_measurable hf\n#align ae_measurable.coe_ereal_ennreal ae_measurable.coe_ereal_ennreal\n\n",
 "closure_ae_eq_of_null_frontier":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr =·µê[ ] ¬ª -/\ntheorem closure_ae_eq_of_null_frontier {Œº : measure Œ±'} {s : set Œ±'} (h : Œº (frontier s) = 0) :\n    ¬´expr =·µê[ ] ¬ª (closure s) Œº s :=\n  ((ae_le_set.2 h).trans interior_subset.eventually_le).antisymm <| subset_closure.eventually_le\n#align closure_ae_eq_of_null_frontier closure_ae_eq_of_null_frontier\n\n",
 "borel_measurable":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚Åª¬π' ¬ª -/\ntheorem continuous.borel_measurable [topological_space Œ±] [topological_space Œ≤] {f : Œ± ‚Üí Œ≤} (hf : continuous f) :\n    @measurable Œ± Œ≤ (borel Œ±) (borel Œ≤) f :=\n  measurable.of_le_map <| generate_from_le fun s hs => generate_measurable.basic (¬´expr ‚Åª¬π' ¬ª f s) (hs.preimage hf)\n#align continuous.borel_measurable continuous.borel_measurable\n\n",
 "borel_eq_top_of_discrete":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚ä§¬ª -/\n/-\nCopyright (c) 2017 Johannes H√∂lzl. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johannes H√∂lzl, Yury Kudryashov\n-/\ntheorem borel_eq_top_of_discrete [topological_space Œ±] [discrete_topology Œ±] : borel Œ± = ¬´expr‚ä§¬ª :=\n  top_le_iff.1 fun s hs => generate_measurable.basic s (is_open_discrete s)\n#align borel_eq_top_of_discrete borel_eq_top_of_discrete\n\n",
 "borel_eq_top_of_countable":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚ä§¬ª -/\ntheorem borel_eq_top_of_countable [topological_space Œ±] [t1_space Œ±] [countable Œ±] : borel Œ± = ¬´expr‚ä§¬ª :=\n  by\n  refine' top_le_iff.1 fun s hs => bUnion_of_singleton s ‚ñ∏ _\n  apply measurable_set.bUnion s.to_countable\n  intro x hx\n  apply measurable_set.of_compl\n  apply generate_measurable.basic\n  exact is_closed_singleton.is_open_compl\n#align borel_eq_top_of_countable borel_eq_top_of_countable\n\n",
 "borel_eq_generate_from_of_subbasis":
 "theorem borel_eq_generate_from_of_subbasis {s : set (set Œ±)} [t : topological_space Œ±] [second_countable_topology Œ±]\n    (hs : t = generate_from s) : borel Œ± = generate_from s :=\n  le_antisymm\n    (generate_from_le fun u (hu : t.is_open u) => by\n      rw [hs] at hu\n      induction hu\n      case basic u hu => exact generate_measurable.basic u hu\n      case univ => exact @measurable_set.univ Œ± (generate_from s)\n      case inter s‚ÇÅ s‚ÇÇ _ _ hs‚ÇÅ hs‚ÇÇ => exact @measurable_set.inter Œ± (generate_from s) _ _ hs‚ÇÅ hs‚ÇÇ\n      case sUnion f hf ih =>\n        rcases is_open_sUnion_countable f (by rwa [hs]) with ‚ü®v, hv, vf, vu‚ü©\n        rw [‚Üê vu]\n        exact @measurable_set.sUnion Œ± (generate_from s) _ hv fun x xv => ih _ (vf xv))\n    (generate_from_le fun u hu =>\n      generate_measurable.basic _ <| show t.is_open u by rw [hs] <;> exact generate_open.basic _ hu)\n#align borel_eq_generate_from_of_subbasis borel_eq_generate_from_of_subbasis\n\n",
 "borel_eq_generate_from_is_closed":
 "theorem borel_eq_generate_from_is_closed [topological_space Œ±] : borel Œ± = generate_from { s | is_closed s } :=\n  le_antisymm\n    (generate_from_le fun t ht =>\n      @measurable_set.of_compl Œ± _ (generate_from { s | is_closed s })\n        (generate_measurable.basic _ <| is_closed_compl_iff.2 ht))\n    (generate_from_le fun t ht =>\n      @measurable_set.of_compl Œ± _ (borel Œ±) (generate_measurable.basic _ <| is_open_compl_iff.2 ht))\n#align borel_eq_generate_from_is_closed borel_eq_generate_from_is_closed\n\n",
 "borel_eq_generate_from_Ioo_rat":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expr‚Ñù -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚ãÉ , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚ãÉ , ¬ª -/\ntheorem borel_eq_generate_from_Ioo_rat :\n    borel (expr‚Ñù) =\n      generate_from\n        (¬´expr‚ãÉ , ¬ª \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚ãÉ , ¬ª\" {Ioo a b}) :=\n  is_topological_basis_Ioo_rat.borel_eq_generate_from\n#align borel_eq_generate_from_Ioo_rat borel_eq_generate_from_Ioo_rat\n\n",
 "borel_eq_generate_from_Ioi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ·µí·µà¬ª -/\ntheorem borel_eq_generate_from_Ioi : borel Œ± = generate_from (range Ioi) :=\n  @borel_eq_generate_from_Iio (¬´expr ·µí·µà¬ª Œ±) _ (by infer_instance : second_countable_topology Œ±) _ _\n#align borel_eq_generate_from_Ioi borel_eq_generate_from_Ioi\n\n",
 "borel_eq_generate_from_Ioc_mem_aux":
 "theorem dense.borel_eq_generate_from_Ioc_mem_aux {Œ± : Type _} [topological_space Œ±] [linear_order Œ±] [order_topology Œ±]\n    [second_countable_topology Œ±] {s : set Œ±} (hd : dense s) (hbot : ‚àÄ x, is_top x ‚Üí x ‚àà s)\n    (hIoo : ‚àÄ x y : Œ±, x < y ‚Üí Ioo x y = ‚àÖ ‚Üí x ‚àà s) :\n    borel Œ± = generate_from { S : set Œ± | ‚àÉ l ‚àà s, ‚àÉ u ‚àà s, ‚àÉ h : l < u, Ioc l u = S } :=\n  by\n  convert hd.order_dual.borel_eq_generate_from_Ico_mem_aux hbot fun x y hlt he => hIoo y x hlt _\n  ¬∑ ext s\n    constructor <;> rintro ‚ü®l, hl, u, hu, hlt, rfl‚ü©\n    exacts[‚ü®u, hu, l, hl, hlt, dual_Ico‚ü©, ‚ü®u, hu, l, hl, hlt, dual_Ioc‚ü©]\n  ¬∑ erw [dual_Ioo]\n    exact he\n#align dense.borel_eq_generate_from_Ioc_mem_aux dense.borel_eq_generate_from_Ioc_mem_aux\n\n",
 "borel_eq_generate_from_Ioc_mem":
 "theorem dense.borel_eq_generate_from_Ioc_mem {Œ± : Type _} [topological_space Œ±] [linear_order Œ±] [order_topology Œ±]\n    [second_countable_topology Œ±] [DenselyOrdered Œ±] [NoMaxOrder Œ±] {s : set Œ±} (hd : dense s) :\n    borel Œ± = generate_from { S : set Œ± | ‚àÉ l ‚àà s, ‚àÉ u ‚àà s, ‚àÉ h : l < u, Ioc l u = S } :=\n  hd.borel_eq_generate_from_Ioc_mem_aux (by simp) fun x y hxy H => ((nonempty_Ioo.2 hxy).ne_empty H).elim\n#align dense.borel_eq_generate_from_Ioc_mem dense.borel_eq_generate_from_Ioc_mem\n\n",
 "borel_eq_generate_from_Ioc":
 "theorem borel_eq_generate_from_Ioc (Œ± : Type _) [topological_space Œ±] [second_countable_topology Œ±] [linear_order Œ±]\n    [order_topology Œ±] : borel Œ± = generate_from { S : set Œ± | ‚àÉ (l u : _)(h : l < u), Ioc l u = S } := by\n  simpa only [exists_prop, mem_univ, true_and_iff] using\n    (@dense_univ Œ± _).borel_eq_generate_from_Ioc_mem_aux (fun _ _ => mem_univ _) fun _ _ _ _ => mem_univ _\n#align borel_eq_generate_from_Ioc borel_eq_generate_from_Ioc\n\n",
 "borel_eq_generate_from_Iio_rat":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expr‚Ñù -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚ãÉ , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚ãÉ , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expr‚Ñù -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚ãÉ , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚ãÉ , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ·∂ú¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expr‚Ñö -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expr‚Ñö -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expr‚Ñù -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚ãÉ , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚ãÉ , ¬ª -/\ntheorem borel_eq_generate_from_Iio_rat :\n    borel (expr‚Ñù) =\n      generate_from\n        (¬´expr‚ãÉ , ¬ª \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚ãÉ , ¬ª\" {Iio a}) :=\n  by\n  let g : measurable_space (expr‚Ñù) :=\n    generate_from\n      (¬´expr‚ãÉ , ¬ª \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚ãÉ , ¬ª\" {Iio a})\n  refine' le_antisymm _ _\n  ¬∑ rw [borel_eq_generate_from_Ioo_rat]\n    refine' generate_from_le fun t => _\n    simp only [mem_Union, mem_singleton_iff]\n    rintro ‚ü®a, b, h, rfl‚ü©\n    rw [(Set.ext fun x => _ :\n        Ioo (a : expr‚Ñù) b =\n          ¬´expr‚ãÉ , ¬ª \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚ãÉ , ¬ª\"\n              (¬´expr ·∂ú¬ª (Iio c)) ‚à©\n            Iio b)]\n    ¬∑ have hg : ‚àÄ q : expr‚Ñö, (measurable_set_of g) (Iio q) := fun q => generate_measurable.basic (Iio q) (by simp)\n      refine' @measurable_set.inter _ g _ _ _ (hg _)\n      refine' @measurable_set.bUnion _ _ g _ _ (to_countable _) fun c h => _\n      exact @measurable_set.compl _ _ g (hg _)\n    ¬∑ suffices x < ‚Üëb ‚Üí (‚Üëa < x ‚Üî ‚àÉ i : expr‚Ñö, a < i ‚àß ‚Üëi ‚â§ x) by simpa\n      refine' fun _ => ‚ü®fun h => _, fun ‚ü®i, hai, hix‚ü© => (Rat.cast_lt.2 hai).trans_le hix‚ü©\n      rcases exists_rat_btwn h with ‚ü®c, ac, cx‚ü©\n      exact ‚ü®c, Rat.cast_lt.1 ac, cx.le‚ü©\n  ¬∑ refine' measurable_space.generate_from_le fun _ => _\n    simp only [mem_Union, mem_singleton_iff]\n    rintro ‚ü®r, rfl‚ü©\n    exact measurable_set_Iio\n#align borel_eq_generate_from_Iio_rat borel_eq_generate_from_Iio_rat\n\n",
 "borel_eq_generate_from_Iio":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ·∂ú¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚ãÉ , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚ãÉ , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ·∂ú¬ª -/\ntheorem borel_eq_generate_from_Iio : borel Œ± = generate_from (range Iio) :=\n  by\n  refine' le_antisymm _ (generate_from_le _)\n  ¬∑ rw [borel_eq_generate_from_of_subbasis (@order_topology.topology_eq_generate_intervals Œ± _ _ _)]\n    letI : measurable_space Œ± := measurable_space.generate_from (range Iio)\n    have H : ‚àÄ a : Œ±, measurable_set (Iio a) := fun a => generate_measurable.basic _ ‚ü®_, rfl‚ü©\n    refine' generate_from_le _\n    rintro _ ‚ü®a, rfl | rfl‚ü© <;> [skip, apply H]\n    by_cases h : ‚àÉ a', ‚àÄ b, a < b ‚Üî a' ‚â§ b\n    ¬∑ rcases h with ‚ü®a', ha'‚ü©\n      rw [(_ : Ioi a = ¬´expr ·∂ú¬ª (Iio a'))]\n      ¬∑ exact (H _).compl\n      simp [Set.ext_iff, ha']\n    ¬∑ rcases is_open_Union_countable (fun a' : { a' : Œ± // a < a' } => { b | a'.1 < b }) fun a' => is_open_lt' _ with\n        ‚ü®v, ‚ü®hv‚ü©, vu‚ü©\n      simp [Set.ext_iff] at vu\n      have :\n        Ioi a =\n          ¬´expr‚ãÉ , ¬ª \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚ãÉ , ¬ª\"\n            (¬´expr ·∂ú¬ª (Iio x.1.1)) :=\n        by\n        simp [Set.ext_iff]\n        refine' fun x => ‚ü®fun ax => _, fun ‚ü®a', ‚ü®h, av‚ü©, ax‚ü© => lt_of_lt_of_le h ax‚ü©\n        rcases(vu x).2 _ with ‚ü®a', h‚ÇÅ, h‚ÇÇ‚ü©\n        ¬∑ exact ‚ü®a', h‚ÇÅ, le_of_lt h‚ÇÇ‚ü©\n        refine' not_imp_comm.1 (fun h => _) h\n        exact ‚ü®x, fun b => ‚ü®fun ab => le_of_not_lt fun h' => h ‚ü®b, ab, h'‚ü©, lt_of_lt_of_le ax‚ü©‚ü©\n      rw [this]\n      skip\n      apply measurable_set.Union\n      exact fun _ => (H _).compl\n  ¬∑ rw [forall_range_iff]\n    intro a\n    exact generate_measurable.basic _ is_open_Iio\n#align borel_eq_generate_from_Iio borel_eq_generate_from_Iio\n\n",
 "borel_eq_generate_from_Ico_mem_aux":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚ãÉ , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚ãÉ , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚ãÉ , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚ãÉ , ¬ª -/\ntheorem dense.borel_eq_generate_from_Ico_mem_aux {Œ± : Type _} [topological_space Œ±] [linear_order Œ±] [order_topology Œ±]\n    [second_countable_topology Œ±] {s : set Œ±} (hd : dense s) (hbot : ‚àÄ x, is_bot x ‚Üí x ‚àà s)\n    (hIoo : ‚àÄ x y : Œ±, x < y ‚Üí Ioo x y = ‚àÖ ‚Üí y ‚àà s) :\n    borel Œ± = generate_from { S : set Œ± | ‚àÉ l ‚àà s, ‚àÉ u ‚àà s, ‚àÉ h : l < u, Ico l u = S } :=\n  by\n  set S : set (set Œ±) := { S | ‚àÉ l ‚àà s, ‚àÉ u ‚àà s, ‚àÉ h : l < u, Ico l u = S }\n  refine' le_antisymm _ (generate_from_Ico_mem_le_borel _ _)\n  letI : measurable_space Œ± := generate_from S\n  rw [borel_eq_generate_from_Iio]\n  refine' generate_from_le (forall_range_iff.2 fun a => _)\n  rcases hd.exists_countable_dense_subset_bot_top with ‚ü®t, hts, hc, htd, htb, htt‚ü©\n  by_cases ha : ‚àÄ b < a, (Ioo b a).nonempty\n  ¬∑ convert_to\n      measurable_set\n        (¬´expr‚ãÉ , ¬ª \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚ãÉ , ¬ª\" (Ico l u))\n    ¬∑ ext y\n      simp only [mem_Union, mem_Iio, mem_Ico]\n      constructor\n      ¬∑ intro hy\n        rcases htd.exists_le' (fun b hb => htb _ hb (hbot b hb)) y with ‚ü®l, hlt, hly‚ü©\n        rcases htd.exists_mem_open is_open_Ioo (ha y hy) with ‚ü®u, hut, hyu, hua‚ü©\n        exact ‚ü®l, hlt, u, hut, hly.trans_lt hyu, hua.le, hly, hyu‚ü©\n      ¬∑ rintro ‚ü®l, -, u, -, -, hua, -, hyu‚ü©\n        exact hyu.trans_le hua\n    ¬∑ refine' measurable_set.bUnion hc fun a ha => measurable_set.bUnion hc fun b hb => _\n      refine' measurable_set.Union fun hab => measurable_set.Union fun hb' => _\n      exact generate_measurable.basic _ ‚ü®a, hts ha, b, hts hb, hab, mem_singleton _‚ü©\n  ¬∑ simp only [not_forall, not_nonempty_iff_eq_empty] at ha\n    replace ha : a ‚àà s := hIoo ha.some a ha.some_spec.fst ha.some_spec.snd\n    convert_to\n      measurable_set\n        (¬´expr‚ãÉ , ¬ª \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚ãÉ , ¬ª\" (Ico l a))\n    ¬∑ symm\n      simp only [‚Üê Ici_inter_Iio, ‚Üê Union_inter, inter_eq_right_iff_subset, subset_def, mem_Union, mem_Ici, mem_Iio]\n      intro x hx\n      rcases htd.exists_le' (fun b hb => htb _ hb (hbot b hb)) x with ‚ü®z, hzt, hzx‚ü©\n      exact ‚ü®z, hzt, hzx.trans_lt hx, hzx‚ü©\n    ¬∑ refine' measurable_set.bUnion hc fun x hx => measurable_set.Union fun hlt => _\n      exact generate_measurable.basic _ ‚ü®x, hts hx, a, ha, hlt, mem_singleton _‚ü©\n#align dense.borel_eq_generate_from_Ico_mem_aux dense.borel_eq_generate_from_Ico_mem_aux\n\n",
 "borel_eq_generate_from_Ico_mem":
 "theorem dense.borel_eq_generate_from_Ico_mem {Œ± : Type _} [topological_space Œ±] [linear_order Œ±] [order_topology Œ±]\n    [second_countable_topology Œ±] [DenselyOrdered Œ±] [NoMinOrder Œ±] {s : set Œ±} (hd : dense s) :\n    borel Œ± = generate_from { S : set Œ± | ‚àÉ l ‚àà s, ‚àÉ u ‚àà s, ‚àÉ h : l < u, Ico l u = S } :=\n  hd.borel_eq_generate_from_Ico_mem_aux (by simp) fun x y hxy H => ((nonempty_Ioo.2 hxy).ne_empty H).elim\n#align dense.borel_eq_generate_from_Ico_mem dense.borel_eq_generate_from_Ico_mem\n\n",
 "borel_eq_generate_from_Ico":
 "theorem borel_eq_generate_from_Ico (Œ± : Type _) [topological_space Œ±] [second_countable_topology Œ±] [linear_order Œ±]\n    [order_topology Œ±] : borel Œ± = generate_from { S : set Œ± | ‚àÉ (l u : _)(h : l < u), Ico l u = S } := by\n  simpa only [exists_prop, mem_univ, true_and_iff] using\n    (@dense_univ Œ± _).borel_eq_generate_from_Ico_mem_aux (fun _ _ => mem_univ _) fun _ _ _ _ => mem_univ _\n#align borel_eq_generate_from_Ico borel_eq_generate_from_Ico\n\n",
 "borel_eq_generate_from":
 "theorem topological_space.is_topological_basis.borel_eq_generate_from [topological_space Œ±]\n    [second_countable_topology Œ±] {s : set (set Œ±)} (hs : is_topological_basis s) : borel Œ± = generate_from s :=\n  borel_eq_generate_from_of_subbasis hs.eq_generate_from\n#align\n  topological_space.is_topological_basis.borel_eq_generate_from topological_space.is_topological_basis.borel_eq_generate_from\n\n",
 "borel_comap":
 "theorem borel_comap {f : Œ± ‚Üí Œ≤} {t : topological_space Œ≤} : @borel Œ± (t.induced f) = (@borel Œ≤ t).comap f :=\n  comap_generate_from.symm\n#align borel_comap borel_comap\n\n",
 "apply_continuous_linear_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚ÜíL[ ] ¬ª -/\n@[measurability]\ntheorem ae_measurable.apply_continuous_linear_map {œÜ : Œ± ‚Üí ¬´expr ‚ÜíL[ ] ¬ª F ùïú E} {Œº : measure Œ±} (hœÜ : ae_measurable œÜ Œº)\n    (v : F) : ae_measurable (fun a => œÜ a v) Œº :=\n  (continuous_linear_map.apply ùïú E v).measurable.comp_ae_measurable hœÜ\n#align ae_measurable.apply_continuous_linear_map ae_measurable.apply_continuous_linear_map\n\n",
 "ae_measurable_supr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚®Ü , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚®Ü , ¬ª -/\n@[measurability]\ntheorem ae_measurable_supr {Œπ} {Œº : measure Œ¥} [countable Œπ] {f : Œπ ‚Üí Œ¥ ‚Üí Œ±} (hf : ‚àÄ i, ae_measurable (f i) Œº) :\n    ae_measurable\n      (fun b => ¬´expr‚®Ü , ¬ª \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚®Ü , ¬ª\" (f i b))\n      Œº :=\n  ae_measurable.is_lub hf <| ae_of_all Œº fun b => isLUB_sup·µ¢\n#align ae_measurable_supr ae_measurable_supr\n\n",
 "ae_measurable_smul_const":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚Ä¢ ¬ª -/\ntheorem ae_measurable_smul_const {f : Œ± ‚Üí ùïú} {Œº : measure Œ±} {c : E} (hc : c ‚â† 0) :\n    ae_measurable (fun x => ¬´expr ‚Ä¢ ¬ª (f x) c) Œº ‚Üî ae_measurable f Œº :=\n  (closed_embedding_smul_left hc).measurable_embedding.ae_measurable_comp_iff\n#align ae_measurable_smul_const ae_measurable_smul_const\n\n",
 "ae_measurable_restrict_of_monotone_on":
 "theorem ae_measurable_restrict_of_monotone_on [linear_order Œ≤] [order_closed_topology Œ≤] {Œº : measure Œ≤} {s : set Œ≤}\n    (hs : measurable_set s) {f : Œ≤ ‚Üí Œ±} (hf : monotone_on f s) : ae_measurable f (Œº.restrict s) :=\n  have this : monotone (f ‚àò coe : s ‚Üí Œ±) := fun ‚ü®x, hx‚ü© ‚ü®y, hy‚ü© (hxy : x ‚â§ y) => hf hx hy hxy\n  ae_measurable_restrict_of_measurable_subtype hs this.measurable\n#align ae_measurable_restrict_of_monotone_on ae_measurable_restrict_of_monotone_on\n\n",
 "ae_measurable_restrict_of_antitone_on":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ·µí·µà¬ª -/\ntheorem ae_measurable_restrict_of_antitone_on [linear_order Œ≤] [order_closed_topology Œ≤] {Œº : measure Œ≤} {s : set Œ≤}\n    (hs : measurable_set s) {f : Œ≤ ‚Üí Œ±} (hf : antitone_on f s) : ae_measurable f (Œº.restrict s) :=\n  @ae_measurable_restrict_of_monotone_on (¬´expr ·µí·µà¬ª Œ±) Œ≤ _ _ ‚Äπ_‚Ä∫ _ _ _ _ _ ‚Äπ_‚Ä∫ _ _ _ _ hs _ hf\n#align ae_measurable_restrict_of_antitone_on ae_measurable_restrict_of_antitone_on\n\n",
 "ae_measurable_of_unif_approx":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expr‚Ñù -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expr‚Ñù -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚àÄ·µê ‚àÇ , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚àÄ·µê ‚àÇ , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚àÄ·µê ‚àÇ , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚àÄ·µê ‚àÇ , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expr‚Ñù -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚àÄ·µê ‚àÇ , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚àÄ·µê ‚àÇ , ¬ª -/\ntheorem ae_measurable_of_unif_approx {Œ≤} [measurable_space Œ≤] [pseudo_metric_space Œ≤] [borel_space Œ≤] {Œº : measure Œ±}\n    {g : Œ± ‚Üí Œ≤}\n    (hf :\n      ‚àÄ Œµ > (0 : expr‚Ñù),\n        ‚àÉ f : Œ± ‚Üí Œ≤,\n          ae_measurable f Œº ‚àß\n            ¬´expr‚àÄ·µê ‚àÇ , ¬ª \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚àÄ·µê ‚àÇ , ¬ª\" Œº\n              (dist (f x) (g x) ‚â§ Œµ)) :\n    ae_measurable g Œº :=\n  by\n  obtain ‚ü®u, u_anti, u_pos, u_lim‚ü© :\n    ‚àÉ u : ‚Ñï ‚Üí expr‚Ñù, strict_anti u ‚àß (‚àÄ n : ‚Ñï, 0 < u n) ‚àß tendsto u at_top ((nhds) 0) :=\n    exists_seq_strict_anti_tendsto (0 : expr‚Ñù)\n  choose f Hf using fun n : ‚Ñï => hf (u n) (u_pos n)\n  have :\n    ¬´expr‚àÄ·µê ‚àÇ , ¬ª \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚àÄ·µê ‚àÇ , ¬ª\" Œº\n      (tendsto (fun n => f n x) at_top ((nhds) (g x))) :=\n    by\n    have :\n      ¬´expr‚àÄ·µê ‚àÇ , ¬ª \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚àÄ·µê ‚àÇ , ¬ª\" Œº\n        (‚àÄ n, dist (f n x) (g x) ‚â§ u n) :=\n      ae_all_iff.2 fun n => (Hf n).2\n    filter_upwards [this]\n    intro x hx\n    rw [tendsto_iff_dist_tendsto_zero]\n    exact squeeze_zero (fun n => dist_nonneg) hx u_lim\n  exact ae_measurable_of_tendsto_metrizable_ae' (fun n => (Hf n).1) this\n#align ae_measurable_of_unif_approx ae_measurable_of_unif_approx\n\n",
 "ae_measurable_of_tendsto_metrizable_ae'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚àÄ·µê ‚àÇ , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚àÄ·µê ‚àÇ , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem ae_measurable_of_tendsto_metrizable_ae' {Œº : measure Œ±} {f : ‚Ñï ‚Üí Œ± ‚Üí Œ≤} {g : Œ± ‚Üí Œ≤}\n    (hf : ‚àÄ n, ae_measurable (f n) Œº)\n    (h_ae_tendsto :\n      ¬´expr‚àÄ·µê ‚àÇ , ¬ª \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚àÄ·µê ‚àÇ , ¬ª\" Œº\n        (tendsto (fun n => f n x) at_top ((nhds) (g x)))) :\n    ae_measurable g Œº :=\n  ae_measurable_of_tendsto_metrizable_ae at_top hf h_ae_tendsto\n#align ae_measurable_of_tendsto_metrizable_ae' ae_measurable_of_tendsto_metrizable_ae'\n\n",
 "ae_measurable_of_tendsto_metrizable_ae":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚àÄ·µê ‚àÇ , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚àÄ·µê ‚àÇ , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚àÄ·µê ‚àÇ , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚àÄ·µê ‚àÇ , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem ae_measurable_of_tendsto_metrizable_ae {Œπ} {Œº : measure Œ±} {f : Œπ ‚Üí Œ± ‚Üí Œ≤} {g : Œ± ‚Üí Œ≤} (u : filter Œπ)\n    [hu : ne_bot u] [is_countably_generated u] (hf : ‚àÄ n, ae_measurable (f n) Œº)\n    (h_tendsto :\n      ¬´expr‚àÄ·µê ‚àÇ , ¬ª \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚àÄ·µê ‚àÇ , ¬ª\" Œº\n        (tendsto (fun n => f n x) u ((nhds) (g x)))) :\n    ae_measurable g Œº := by\n  rcases u.exists_seq_tendsto with ‚ü®v, hv‚ü©\n  have h'f : ‚àÄ n, ae_measurable (f (v n)) Œº := fun n => hf (v n)\n  set p : Œ± ‚Üí (‚Ñï ‚Üí Œ≤) ‚Üí Prop := fun x f' => tendsto (fun n => f' n) at_top ((nhds) (g x))\n  have hp :\n    ¬´expr‚àÄ·µê ‚àÇ , ¬ª \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚àÄ·µê ‚àÇ , ¬ª\" Œº\n      (p x fun n => f (v n) x) :=\n    by filter_upwards [h_tendsto] with x hx using hx.comp hv\n  set ae_seq_lim := fun x => ite (x ‚àà ae_seq_set h'f p) (g x) (‚ü®f (v 0) x‚ü© : nonempty Œ≤).some with hs\n  refine'\n    ‚ü®ae_seq_lim, measurable_of_tendsto_metrizable' at_top (ae_seq.measurable h'f p) (tendsto_pi_nhds.mpr fun x => _), _‚ü©\n  ¬∑ simp_rw [ae_seq, ae_seq_lim]\n    split_ifs with hx\n    ¬∑ simp_rw [ae_seq.mk_eq_fun_of_mem_ae_seq_set h'f hx]\n      exact @ae_seq.fun_prop_of_mem_ae_seq_set _ Œ± Œ≤ _ _ _ _ _ h'f x hx\n    ¬∑ exact tendsto_const_nhds\n  ¬∑\n    exact\n      (ite_ae_eq_of_measure_compl_zero g (fun x => (‚ü®f (v 0) x‚ü© : nonempty Œ≤).some) (ae_seq_set h'f p)\n          (ae_seq.measure_compl_ae_seq_set_eq_zero h'f hp)).symm\n#align ae_measurable_of_tendsto_metrizable_ae ae_measurable_of_tendsto_metrizable_ae\n\n",
 "ae_measurable_infi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚®Ö , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚®Ö , ¬ª -/\n@[measurability]\ntheorem ae_measurable_infi {Œπ} {Œº : measure Œ¥} [countable Œπ] {f : Œπ ‚Üí Œ¥ ‚Üí Œ±} (hf : ‚àÄ i, ae_measurable (f i) Œº) :\n    ae_measurable\n      (fun b => ¬´expr‚®Ö , ¬ª \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚®Ö , ¬ª\" (f i b))\n      Œº :=\n  ae_measurable.is_glb hf <| ae_of_all Œº fun b => isGLB_inf·µ¢\n#align ae_measurable_infi ae_measurable_infi\n\n",
 "ae_measurable_coe_nnreal_real_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expr‚Ñù -/\n@[simp, norm_cast]\ntheorem ae_measurable_coe_nnreal_real_iff {f : Œ± ‚Üí nnreal} {Œº : measure Œ±} :\n    ae_measurable (fun x => f x : Œ± ‚Üí expr‚Ñù) Œº ‚Üî ae_measurable f Œº :=\n  ‚ü®fun h => by simpa only [real.to_nnreal_coe] using h.real_to_nnreal, ae_measurable.coe_nnreal_real‚ü©\n#align ae_measurable_coe_nnreal_real_iff ae_measurable_coe_nnreal_real_iff\n\n",
 "ae_measurable_coe_nnreal_ennreal_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n@[simp, norm_cast]\ntheorem ae_measurable_coe_nnreal_ennreal_iff {f : Œ± ‚Üí nnreal} {Œº : measure Œ±} :\n    ae_measurable (fun x => (f x : ennreal)) Œº ‚Üî ae_measurable f Œº :=\n  ‚ü®fun h => h.ennreal_to_nnreal, fun h => h.coe_nnreal_ennreal‚ü©\n#align ae_measurable_coe_nnreal_ennreal_iff ae_measurable_coe_nnreal_ennreal_iff\n\n",
 "ae_measurable_bsupr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚®Ü , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚®Ü , ¬ª -/\ntheorem ae_measurable_bsupr {Œπ} {Œº : measure Œ¥} (s : set Œπ) {f : Œπ ‚Üí Œ¥ ‚Üí Œ±} (hs : s.countable)\n    (hf : ‚àÄ i, ae_measurable (f i) Œº) :\n    ae_measurable\n      (fun b => ¬´expr‚®Ü , ¬ª \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚®Ü , ¬ª\" (f i b))\n      Œº :=\n  by\n  haveI : Encodable s := hs.to_encodable\n  simp only [sup·µ¢_subtype']\n  exact ae_measurable_supr fun i => hf i\n#align ae_measurable_bsupr ae_measurable_bsupr\n\n",
 "ae_measurable_binfi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚®Ö , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚®Ö , ¬ª -/\ntheorem ae_measurable_binfi {Œπ} {Œº : measure Œ¥} (s : set Œπ) {f : Œπ ‚Üí Œ¥ ‚Üí Œ±} (hs : s.countable)\n    (hf : ‚àÄ i, ae_measurable (f i) Œº) :\n    ae_measurable\n      (fun b => ¬´expr‚®Ö , ¬ª \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚®Ö , ¬ª\" (f i b))\n      Œº :=\n  by\n  haveI : Encodable s := hs.to_encodable\n  simp only [inf·µ¢_subtype']\n  exact ae_measurable_infi fun i => hf i\n#align ae_measurable_binfi ae_measurable_binfi\n\n",
 "ae_measurable2":
 "theorem continuous.ae_measurable2 [second_countable_topology Œ±] [second_countable_topology Œ≤] {f : Œ¥ ‚Üí Œ±} {g : Œ¥ ‚Üí Œ≤}\n    {c : Œ± ‚Üí Œ≤ ‚Üí Œ≥} {Œº : measure Œ¥} (h : continuous fun p : Œ± √ó Œ≤ => c p.1 p.2) (hf : ae_measurable f Œº)\n    (hg : ae_measurable g Œº) : ae_measurable (fun a => c (f a) (g a)) Œº :=\n  h.measurable.comp_ae_measurable (hf.prod_mk hg)\n#align continuous.ae_measurable2 continuous.ae_measurable2\n\n",
 "ae_measurable":
 "/-- A continuous function from an `opens_measurable_space` to a `borel_space`\nis ae-measurable. -/\ntheorem continuous.ae_measurable {f : Œ± ‚Üí Œ≥} (h : continuous f) {Œº : measure Œ±} : ae_measurable f Œº :=\n  h.measurable.ae_measurable\n#align continuous.ae_measurable continuous.ae_measurable\n\n"}