{"to_measurable_equiv_symm_coe":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰ƒâ‚œ Â» -/\n@[simp]\ntheorem homeomorph.to_measurable_equiv_symm_coe (h : Â«expr â‰ƒâ‚œ Â» Î³ Î³â‚‚) :\n    (h.to_measurable_equiv.symm : Î³â‚‚ â†’ Î³) = h.symm :=\n  rfl\n#align homeomorph.to_measurable_equiv_symm_coe homeomorph.to_measurable_equiv_symm_coe\n\n",
 "to_measurable_equiv_coe":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰ƒâ‚œ Â» -/\n@[simp]\ntheorem homeomorph.to_measurable_equiv_coe (h : Â«expr â‰ƒâ‚œ Â» Î³ Î³â‚‚) : (h.to_measurable_equiv : Î³ â†’ Î³â‚‚) = h :=\n  rfl\n#align homeomorph.to_measurable_equiv_coe homeomorph.to_measurable_equiv_coe\n\n",
 "tendsto_measure_cthickening_of_is_compact":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- Given a compact set in a proper space, the measure of its `r`-closed thickenings converges to\nits measure as `r` tends to `0`. -/\ntheorem tendsto_measure_cthickening_of_is_compact [metric_space Î±] [measurable_space Î±] [opens_measurable_space Î±]\n    [proper_space Î±] {Î¼ : measure Î±} [is_finite_measure_on_compacts Î¼] {s : set Î±} (hs : is_compact s) :\n    tendsto (fun r => Î¼ (metric.cthickening r s)) ((nhds) 0) ((nhds) (Î¼ s)) :=\n  tendsto_measure_cthickening_of_is_closed âŸ¨1, zero_lt_one, hs.bounded.cthickening.measure_lt_top.neâŸ© hs.is_closed\n#align tendsto_measure_cthickening_of_is_compact tendsto_measure_cthickening_of_is_compact\n\n",
 "tendsto_measure_cthickening_of_is_closed":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- If a closed set has a closed thickening with finite measure, then the measure of its `r`-closed\nthickenings converges to its measure as `r` tends to `0`. -/\ntheorem tendsto_measure_cthickening_of_is_closed {Î¼ : measure Î±} {s : set Î±}\n    (hs : âˆƒ R > 0, Î¼ (cthickening R s) â‰  ennreal.top) (h's : is_closed s) :\n    tendsto (fun r => Î¼ (cthickening r s)) ((nhds) 0) ((nhds) (Î¼ s)) :=\n  by\n  convert tendsto_measure_cthickening hs\n  exact h's.closure_eq.symm\n#align tendsto_measure_cthickening_of_is_closed tendsto_measure_cthickening_of_is_closed\n\n",
 "tendsto_measure_cthickening":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- If a set has a closed thickening with finite measure, then the measure of its `r`-closed\nthickenings converges to the measure of its closure as `r` tends to `0`. -/\ntheorem tendsto_measure_cthickening {Î¼ : measure Î±} {s : set Î±} (hs : âˆƒ R > 0, Î¼ (cthickening R s) â‰  ennreal.top) :\n    tendsto (fun r => Î¼ (cthickening r s)) ((nhds) 0) ((nhds) (Î¼ (closure s))) :=\n  by\n  have A : tendsto (fun r => Î¼ (cthickening r s)) (nhds_within (Ioi 0) 0) ((nhds) (Î¼ (closure s))) :=\n    by\n    rw [closure_eq_Inter_cthickening]\n    exact\n      tendsto_measure_bInter_gt (fun r hr => is_closed_cthickening.measurable_set)\n        (fun i j ipos ij => cthickening_mono ij _) hs\n  have B : tendsto (fun r => Î¼ (cthickening r s)) (nhds_within (Iic 0) 0) ((nhds) (Î¼ (closure s))) :=\n    by\n    apply tendsto.congr' _ tendsto_const_nhds\n    filter_upwards [self_mem_nhds_within] with _ hr\n    rw [cthickening_of_nonpos hr]\n  convert B.sup A\n  exact (nhds_left_sup_nhds_right' 0).symm\n#align tendsto_measure_cthickening tendsto_measure_cthickening\n\n",
 "supr_Prop":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ¨† , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨† , Â» -/\n@[measurability]\ntheorem measurable.supr_Prop {Î±} [measurable_space Î±] [CompleteLattice Î±] (p : Prop) {f : Î´ â†’ Î±} (hf : measurable f) :\n    measurable fun b =>\n      Â«exprâ¨† , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨† , Â»\" (f b) :=\n  by_cases (fun h : p => by convert hf; funext ; exact supáµ¢_pos h) fun h : Â¬p => by convert measurable_const; funext ;\n    exact supáµ¢_neg h\n#align measurable.supr_Prop measurable.supr_Prop\n\n",
 "real_to_nnreal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n@[measurability]\ntheorem ae_measurable.real_to_nnreal {f : Î± â†’ exprâ„} {Î¼ : measure Î±} (hf : ae_measurable f Î¼) :\n    ae_measurable (fun x => real.to_nnreal (f x)) Î¼ :=\n  measurable_real_to_nnreal.comp_ae_measurable hf\n#align ae_measurable.real_to_nnreal ae_measurable.real_to_nnreal\n\n",
 "prod_le_borel_prod":
 "theorem prod_le_borel_prod : prod.measurable_space â‰¤ borel (Î± Ã— Î²) :=\n  by\n  rw [â€¹borel_space Î±â€º.measurable_eq, â€¹borel_space Î²â€º.measurable_eq]\n  refine' sup_le _ _\n  Â· exact comap_le_iff_le_map.mpr continuous_fst.borel_measurable\n  Â· exact comap_le_iff_le_map.mpr continuous_snd.borel_measurable\n#align prod_le_borel_prod prod_le_borel_prod\n\n",
 "pi_le_borel_pi":
 "theorem pi_le_borel_pi {Î¹ : Type _} {Ï€ : Î¹ â†’ Type _} [âˆ€ i, topological_space (Ï€ i)] [âˆ€ i, measurable_space (Ï€ i)]\n    [âˆ€ i, borel_space (Ï€ i)] : measurable_space.pi â‰¤ borel (âˆ€ i, Ï€ i) :=\n  by\n  have : â€¹âˆ€ i, measurable_space (Ï€ i)â€º = fun i => borel (Ï€ i) := funext fun i => borel_space.measurable_eq\n  rw [this]\n  exact supáµ¢_le fun i => comap_le_iff_le_map.2 <| (continuous_apply i).borel_measurable\n#align pi_le_borel_pi pi_le_borel_pi\n\n",
 "null_measurable_set_of_null_frontier":
 "theorem null_measurable_set_of_null_frontier {s : set Î±} {Î¼ : measure Î±} (h : Î¼ (frontier s) = 0) :\n    null_measurable_set s Î¼ :=\n  âŸ¨interior s, is_open_interior.measurable_set, (interior_ae_eq_of_null_frontier h).symmâŸ©\n#align null_measurable_set_of_null_frontier null_measurable_set_of_null_frontier\n\n",
 "norm":
 "@[measurability]\ntheorem ae_measurable.norm {f : Î² â†’ Î±} {Î¼ : measure Î²} (hf : ae_measurable f Î¼) :\n    ae_measurable (fun a => norm (f a)) Î¼ :=\n  measurable_norm.comp_ae_measurable hf\n#align ae_measurable.norm ae_measurable.norm\n\n",
 "nnreal_tsum":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ‘' , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ‘' , Â» -/\n@[measurability]\ntheorem measurable.nnreal_tsum {Î¹} [countable Î¹] {f : Î¹ â†’ Î± â†’ nnreal} (h : âˆ€ i, measurable (f i)) :\n    measurable fun x =>\n      Â«exprâˆ‘' , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ‘' , Â»\" (f i x) :=\n  by\n  simp_rw [nnreal.tsum_eq_to_nnreal_tsum]\n  exact (measurable.ennreal_tsum fun i => (h i).coe_nnreal_ennreal).ennreal_to_nnreal\n#align measurable.nnreal_tsum measurable.nnreal_tsum\n\n",
 "nnnorm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–â‚ŠÂ» -/\n@[measurability]\ntheorem ae_measurable.nnnorm {f : Î² â†’ Î±} {Î¼ : measure Î²} (hf : ae_measurable f Î¼) :\n    ae_measurable (fun a => Â«exprâ€– â€–â‚ŠÂ» (f a)) Î¼ :=\n  measurable_nnnorm.comp_ae_measurable hf\n#align ae_measurable.nnnorm ae_measurable.nnnorm\n\n",
 "nndist":
 "@[measurability]\ntheorem measurable.nndist {f g : Î² â†’ Î±} (hf : measurable f) (hg : measurable g) :\n    measurable fun b => nndist (f b) (g b) :=\n  (@continuous_nndist Î± _).measurable2 hf hg\n#align measurable.nndist measurable.nndist\n\n",
 "nhds_within_is_measurably_generated":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/-- If `s` is a measurable set, then `ğ“[s] a` is a measurably generated filter for\neach `a`. This cannot be an `instance` because it depends on a non-instance `hs : measurable_set s`.\n-/\ntheorem measurable_set.nhds_within_is_measurably_generated {s : set Î±} (hs : measurable_set s) (a : Î±) :\n    (nhds_within s a).is_measurably_generated :=\n  haveI := hs.principal_is_measurably_generated\n  filter.inf_is_measurably_generated _ _\n#align measurable_set.nhds_within_is_measurably_generated measurable_set.nhds_within_is_measurably_generated\n\n",
 "min":
 "@[measurability]\ntheorem ae_measurable.min {f g : Î´ â†’ Î±} {Î¼ : measure Î´} (hf : ae_measurable f Î¼) (hg : ae_measurable g Î¼) :\n    ae_measurable (fun a => min (f a) (g a)) Î¼ :=\n  âŸ¨fun a => min (hf.mk f a) (hg.mk g a), hf.measurable_mk.min hg.measurable_mk,\n    eventually_eq.compâ‚‚ hf.ae_eq_mk _ hg.ae_eq_mkâŸ©\n#align ae_measurable.min ae_measurable.min\n\n",
 "measure_interior_of_null_frontier":
 "theorem measure_interior_of_null_frontier {Î¼ : measure Î±'} {s : set Î±'} (h : Î¼ (frontier s) = 0) :\n    Î¼ (interior s) = Î¼ s :=\n  measure_congr (interior_ae_eq_of_null_frontier h)\n#align measure_interior_of_null_frontier measure_interior_of_null_frontier\n\n",
 "measure_ext_Ioo_rat":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„š -/\n-- TODO: norm_cast fails here?\ntheorem measure_ext_Ioo_rat {Î¼ Î½ : measure (exprâ„)} [is_locally_finite_measure Î¼]\n    (h : âˆ€ a b : exprâ„š, Î¼ (Ioo a b) = Î½ (Ioo a b)) : Î¼ = Î½ :=\n  (finite_spanning_sets_in_Ioo_rat Î¼).ext borel_eq_generate_from_Ioo_rat is_pi_system_Ioo_rat <|\n    by\n    simp only [mem_Union, mem_singleton_iff]\n    rintro _ âŸ¨a, b, -, rflâŸ©\n    apply h\n#align measure_ext_Ioo_rat measure_ext_Ioo_rat\n\n",
 "measure_eq_measure_preimage_add_measure_tsum_Ico_zpow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ‘' , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ‘' , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ‘' , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ‘' , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/-- One can cut out `â„â‰¥0âˆ` into the sets `{0}`, `Ico (t^n) (t^(n+1))` for `n : â„¤` and `{âˆ}`. This\ngives a way to compute the measure of a set in terms of sets on which a given function `f` does not\nfluctuate by more than `t`. -/\ntheorem measure_eq_measure_preimage_add_measure_tsum_Ico_zpow [measurable_space Î±] (Î¼ : measure Î±) {f : Î± â†’ ennreal}\n    (hf : measurable f) {s : set Î±} (hs : measurable_set s) {t : nnreal} (ht : 1 < t) :\n    Î¼ s =\n      Î¼ (s âˆ© Â«expr â»Â¹' Â» f {0}) + Î¼ (s âˆ© Â«expr â»Â¹' Â» f {ennreal.top}) +\n        Â«exprâˆ‘' , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ‘' , Â»\"\n          (Î¼ (s âˆ© Â«expr â»Â¹' Â» f (Ico (t ^ n) (t ^ (n + 1))))) :=\n  by\n  have A : Î¼ s = Î¼ (s âˆ© Â«expr â»Â¹' Â» f {0}) + Î¼ (s âˆ© Â«expr â»Â¹' Â» f (Ioi 0)) :=\n    by\n    rw [â† measure_union]\n    Â· congr 1\n      ext x\n      have : 0 = f x âˆ¨ 0 < f x := eq_or_lt_of_le bot_le\n      rw [eq_comm] at this\n      simp only [â† and_or_left, this, mem_singleton_iff, mem_inter_iff, and_true_iff, mem_union, mem_Ioi, mem_preimage]\n    Â· apply disjoint_left.2 fun x hx h'x => _\n      have : 0 < f x := h'x.2\n      exact lt_irrefl 0 (this.trans_le hx.2.le)\n    Â· exact hs.inter (hf measurable_set_Ioi)\n  have B :\n    Î¼ (s âˆ© Â«expr â»Â¹' Â» f (Ioi 0)) = Î¼ (s âˆ© Â«expr â»Â¹' Â» f {ennreal.top}) + Î¼ (s âˆ© Â«expr â»Â¹' Â» f (Ioo 0 (ennreal.top))) :=\n    by\n    rw [â† measure_union]\n    Â· rw [â† inter_union_distrib_left]\n      congr\n      ext x\n      simp only [mem_singleton_iff, mem_union, mem_Ioo, mem_Ioi, mem_preimage]\n      have H : f x = ennreal.top âˆ¨ f x < ennreal.top := eq_or_lt_of_le le_top\n      cases H\n      Â· simp only [H, eq_self_iff_true, or_false_iff, WithTop.zero_lt_top, not_top_lt, and_false_iff]\n      Â· simp only [H, H.ne, and_true_iff, false_or_iff]\n    Â· apply disjoint_left.2 fun x hx h'x => _\n      have : f x < ennreal.top := h'x.2.2\n      exact lt_irrefl _ (this.trans_le (le_of_eq hx.2.symm))\n    Â· exact hs.inter (hf measurable_set_Ioo)\n  have C :\n    Î¼ (s âˆ© Â«expr â»Â¹' Â» f (Ioo 0 (ennreal.top))) =\n      Â«exprâˆ‘' , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ‘' , Â»\"\n        (Î¼ (s âˆ© Â«expr â»Â¹' Â» f (Ico (t ^ n) (t ^ (n + 1))))) :=\n    by\n    rw [â† measure_Union, ennreal.Ioo_zero_top_eq_Union_Ico_zpow (ennreal.one_lt_coe_iff.2 ht) ennreal.coe_ne_top,\n      preimage_Union, inter_Union]\n    Â· intro i j\n      simp only [function.on_fun]\n      wlog (discharger := tactic.skip) h : i â‰¤ j := le_total i j using i j, j i\n      Â· intro hij\n        replace hij : i + 1 â‰¤ j := lt_of_le_of_ne h hij\n        apply disjoint_left.2 fun x hx h'x => lt_irrefl (f x) _\n        calc\n          f x < t ^ (i + 1) := hx.2.2\n          _ â‰¤ t ^ j := ennreal.zpow_le_of_le (ennreal.one_le_coe_iff.2 ht.le) hij\n          _ â‰¤ f x := h'x.2.1\n          \n      Â· intro hij\n        rw [disjoint_comm]\n        exact this hij.symm\n    Â· intro n\n      exact hs.inter (hf measurable_set_Ico)\n  rw [A, B, C, add_assoc]\n#align measure_eq_measure_preimage_add_measure_tsum_Ico_zpow measure_eq_measure_preimage_add_measure_tsum_Ico_zpow\n\n",
 "measure_closure_of_null_frontier":
 "theorem measure_closure_of_null_frontier {Î¼ : measure Î±'} {s : set Î±'} (h : Î¼ (frontier s) = 0) : Î¼ (closure s) = Î¼ s :=\n  measure_congr (closure_ae_eq_of_null_frontier h)\n#align measure_closure_of_null_frontier measure_closure_of_null_frontier\n\n",
 "measurable_to_real":
 "@[measurability]\ntheorem measurable_to_real : measurable ennreal.to_real :=\n  ennreal.measurable_of_measurable_nnreal measurable_coe_nnreal_real\n#align measurable_to_real measurable_to_real\n\n",
 "measurable_to_nnreal":
 "@[measurability]\ntheorem measurable_to_nnreal : measurable ennreal.to_nnreal :=\n  ennreal.measurable_of_measurable_nnreal measurable_id\n#align measurable_to_nnreal measurable_to_nnreal\n\n",
 "measurable_supr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ¨† , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨† , Â» -/\n@[measurability]\ntheorem measurable_supr {Î¹} [countable Î¹] {f : Î¹ â†’ Î´ â†’ Î±} (hf : âˆ€ i, measurable (f i)) :\n    measurable fun b =>\n      Â«exprâ¨† , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨† , Â»\" (f i b) :=\n  measurable.is_lub hf fun b => isLUB_supáµ¢\n#align measurable_supr measurable_supr\n\n",
 "measurable_smul_const":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\ntheorem measurable_smul_const {f : Î± â†’ ğ•œ} {c : E} (hc : c â‰  0) :\n    (measurable fun x => Â«expr â€¢ Â» (f x) c) â†” measurable f :=\n  (closed_embedding_smul_left hc).measurable_embedding.measurable_comp_iff\n#align measurable_smul_const measurable_smul_const\n\n",
 "measurable_set_uIoc":
 "@[measurability]\ntheorem measurable_set_uIoc : measurable_set (uIoc a b) :=\n  measurable_set_Ioc\n#align measurable_set_uIoc measurable_set_uIoc\n\n",
 "measurable_set_uIcc":
 "@[measurability]\ntheorem measurable_set_uIcc : measurable_set (uIcc a b) :=\n  measurable_set_Icc\n#align measurable_set_uIcc measurable_set_uIcc\n\n",
 "measurable_set_of_mem_nhds_within_Ioi_aux":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.gt -/\ntheorem measurable_set_of_mem_nhds_within_Ioi_aux {s : set Î±} (h : âˆ€ x âˆˆ s, s âˆˆ nhds_within.gt x)\n    (h' : âˆ€ x âˆˆ s, âˆƒ y, x < y) : measurable_set s :=\n  by\n  choose! M hM using h'\n  suffices H : (s \\ interior s).countable\n  Â· have : s = interior s âˆª s \\ interior s := by rw [union_diff_cancel interior_subset]\n    rw [this]\n    exact is_open_interior.measurable_set.union H.measurable_set\n  have A : âˆ€ x âˆˆ s, âˆƒ y âˆˆ Ioi x, Ioo x y âŠ† s := fun x hx =>\n    (mem_nhds_within_Ioi_iff_exists_Ioo_subset' (hM x hx)).1 (h x hx)\n  choose! y hy h'y using A\n  have B : Set.PairwiseDisjoint (s \\ interior s) fun x => Ioo x (y x) :=\n    by\n    intro x hx x' hx' hxx'\n    rcases lt_or_gt_of_ne hxx' with (h' | h')\n    Â· apply disjoint_left.2 fun z hz h'z => _\n      have : x' âˆˆ interior s := mem_interior.2 âŸ¨Ioo x (y x), h'y _ hx.1, is_open_Ioo, âŸ¨h', h'z.1.trans hz.2âŸ©âŸ©\n      exact false.elim (hx'.2 this)\n    Â· apply disjoint_left.2 fun z hz h'z => _\n      have : x âˆˆ interior s := mem_interior.2 âŸ¨Ioo x' (y x'), h'y _ hx'.1, is_open_Ioo, âŸ¨h', hz.1.trans h'z.2âŸ©âŸ©\n      exact false.elim (hx.2 this)\n  exact B.countable_of_Ioo fun x hx => hy x hx.1\n#align measurable_set_of_mem_nhds_within_Ioi_aux measurable_set_of_mem_nhds_within_Ioi_aux\n\n",
 "measurable_set_of_mem_nhds_within_Ioi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.gt -/\n/-- If a set is a right-neighborhood of all of its points, then it is measurable. -/\ntheorem measurable_set_of_mem_nhds_within_Ioi {s : set Î±} (h : âˆ€ x âˆˆ s, s âˆˆ nhds_within.gt x) : measurable_set s :=\n  by\n  by_cases H : âˆƒ x âˆˆ s, is_top x\n  Â· rcases H with âŸ¨xâ‚€, xâ‚€s, hâ‚€âŸ©\n    have : s = {xâ‚€} âˆª s \\ {xâ‚€} := by rw [union_diff_cancel (singleton_subset_iff.2 xâ‚€s)]\n    rw [this]\n    refine' (measurable_set_singleton _).union _\n    have A : âˆ€ x âˆˆ s \\ {xâ‚€}, x < xâ‚€ := fun x hx => lt_of_le_of_ne (hâ‚€ _) (by simpa using hx.2)\n    refine' measurable_set_of_mem_nhds_within_Ioi_aux (fun x hx => _) fun x hx => âŸ¨xâ‚€, A x hxâŸ©\n    obtain âŸ¨u, hu, usâŸ© : âˆƒ (u : Î±)(H : u âˆˆ Ioi x), Ioo x u âŠ† s :=\n      (mem_nhds_within_Ioi_iff_exists_Ioo_subset' (A x hx)).1 (h x hx.1)\n    refine' (mem_nhds_within_Ioi_iff_exists_Ioo_subset' (A x hx)).2 âŸ¨u, hu, fun y hy => âŸ¨us hy, _âŸ©âŸ©\n    exact ne_of_lt (hy.2.trans_le (hâ‚€ _))\n  Â· apply measurable_set_of_mem_nhds_within_Ioi_aux h\n    simp only [is_top] at H\n    push_neg  at H\n    exact H\n#align measurable_set_of_mem_nhds_within_Ioi measurable_set_of_mem_nhds_within_Ioi\n\n",
 "measurable_set_of_continuous_at":
 "theorem measurable_set_of_continuous_at {Î²} [emetric_space Î²] (f : Î± â†’ Î²) : measurable_set { x | continuous_at f x } :=\n  (is_GÎ´_set_of_continuous_at f).measurable_set\n#align measurable_set_of_continuous_at measurable_set_of_continuous_at\n\n",
 "measurable_set_lt'":
 "@[measurability]\ntheorem measurable_set_lt' [second_countable_topology Î±] : measurable_set { p : Î± Ã— Î± | p.1 < p.2 } :=\n  (is_open_lt continuous_fst continuous_snd).measurable_set\n#align measurable_set_lt' measurable_set_lt'\n\n",
 "measurable_set_lt":
 "@[measurability]\ntheorem measurable_set_lt [second_countable_topology Î±] {f g : Î´ â†’ Î±} (hf : measurable f) (hg : measurable g) :\n    measurable_set { a | f a < g a } :=\n  hf.prod_mk hg measurable_set_lt'\n#align measurable_set_lt measurable_set_lt\n\n",
 "measurable_set_le'":
 "@[measurability]\ntheorem measurable_set_le' : measurable_set { p : Î± Ã— Î± | p.1 â‰¤ p.2 } :=\n  order_closed_topology.is_closed_le'.measurable_set\n#align measurable_set_le' measurable_set_le'\n\n",
 "measurable_set_le":
 "@[measurability]\ntheorem measurable_set_le {f g : Î´ â†’ Î±} (hf : measurable f) (hg : measurable g) : measurable_set { a | f a â‰¤ g a } :=\n  hf.prod_mk hg measurable_set_le'\n#align measurable_set_le measurable_set_le\n\n",
 "measurable_set_interior":
 "@[measurability]\ntheorem measurable_set_interior : measurable_set (interior s) :=\n  is_open_interior.measurable_set\n#align measurable_set_interior measurable_set_interior\n\n",
 "measurable_set_eball":
 "@[measurability]\ntheorem measurable_set_eball : measurable_set (emetric.ball x Îµ) :=\n  emetric.is_open_ball.measurable_set\n#align measurable_set_eball measurable_set_eball\n\n",
 "measurable_set_closure":
 "@[measurability]\ntheorem measurable_set_closure : measurable_set (closure s) :=\n  is_closed_closure.measurable_set\n#align measurable_set_closure measurable_set_closure\n\n",
 "measurable_set_closed_ball":
 "@[measurability]\ntheorem measurable_set_closed_ball : measurable_set (metric.closed_ball x Îµ) :=\n  metric.is_closed_ball.measurable_set\n#align measurable_set_closed_ball measurable_set_closed_ball\n\n",
 "measurable_set_ball":
 "@[measurability]\ntheorem measurable_set_ball : measurable_set (metric.ball x Îµ) :=\n  metric.is_open_ball.measurable_set\n#align measurable_set_ball measurable_set_ball\n\n",
 "measurable_set_Ioo":
 "@[simp, measurability]\ntheorem measurable_set_Ioo : measurable_set (Ioo a b) :=\n  is_open_Ioo.measurable_set\n#align measurable_set_Ioo measurable_set_Ioo\n\n",
 "measurable_set_Ioi":
 "@[simp, measurability]\ntheorem measurable_set_Ioi : measurable_set (Ioi a) :=\n  is_open_Ioi.measurable_set\n#align measurable_set_Ioi measurable_set_Ioi\n\n",
 "measurable_set_Ioc":
 "@[simp, measurability]\ntheorem measurable_set_Ioc : measurable_set (Ioc a b) :=\n  measurable_set_Ioi.inter measurable_set_Iic\n#align measurable_set_Ioc measurable_set_Ioc\n\n",
 "measurable_set_Iio":
 "-- we open this locale only here to avoid issues with list being treated as intervals above\n@[simp, measurability]\ntheorem measurable_set_Iio : measurable_set (Iio a) :=\n  is_open_Iio.measurable_set\n#align measurable_set_Iio measurable_set_Iio\n\n",
 "measurable_set_Iic":
 "@[simp, measurability]\ntheorem measurable_set_Iic : measurable_set (Iic a) :=\n  is_closed_Iic.measurable_set\n#align measurable_set_Iic measurable_set_Iic\n\n",
 "measurable_set_Ico":
 "@[simp, measurability]\ntheorem measurable_set_Ico : measurable_set (Ico a b) :=\n  measurable_set_Ici.inter measurable_set_Iio\n#align measurable_set_Ico measurable_set_Ico\n\n",
 "measurable_set_Ici":
 "@[simp, measurability]\ntheorem measurable_set_Ici : measurable_set (Ici a) :=\n  is_closed_Ici.measurable_set\n#align measurable_set_Ici measurable_set_Ici\n\n",
 "measurable_set_Icc":
 "@[simp, measurability]\ntheorem measurable_set_Icc : measurable_set (Icc a b) :=\n  is_closed_Icc.measurable_set\n#align measurable_set_Icc measurable_set_Icc\n\n",
 "measurable_set":
 "theorem is_preconnected.measurable_set (h : is_preconnected s) : measurable_set s :=\n  h.ord_connected.measurable_set\n#align is_preconnected.measurable_set is_preconnected.measurable_set\n\n",
 "measurable_real_to_nnreal":
 "@[measurability]\ntheorem measurable_real_to_nnreal : measurable real.to_nnreal :=\n  continuous_real_to_nnreal.measurable\n#align measurable_real_to_nnreal measurable_real_to_nnreal\n\n",
 "measurable_piecewise":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á¶œÂ» -/\n/-- If a function is defined piecewise in terms of functions which are continuous on their\nrespective pieces, then it is measurable. -/\ntheorem continuous_on.measurable_piecewise {f g : Î± â†’ Î³} {s : set Î±} [âˆ€ j : Î±, decidable (j âˆˆ s)]\n    (hf : continuous_on f s) (hg : continuous_on g (Â«expr á¶œÂ» s)) (hs : measurable_set s) :\n    measurable (s.piecewise f g) := by\n  refine' measurable_of_is_open fun t ht => _\n  rw [piecewise_preimage, Set.ite]\n  apply measurable_set.union\n  Â· rcases _root_.continuous_on_iff'.1 hf t ht with âŸ¨u, u_open, huâŸ©\n    rw [hu]\n    exact u_open.measurable_set.inter hs\n  Â· rcases _root_.continuous_on_iff'.1 hg t ht with âŸ¨u, u_open, huâŸ©\n    rw [diff_eq_compl_inter, inter_comm, hu]\n    exact u_open.measurable_set.inter hs.compl\n#align continuous_on.measurable_piecewise continuous_on.measurable_piecewise\n\n",
 "measurable_of_tendsto_nnreal'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- A limit (over a general filter) of measurable `â„â‰¥0` valued functions is measurable. -/\ntheorem measurable_of_tendsto_nnreal' {Î¹} {f : Î¹ â†’ Î± â†’ nnreal} {g : Î± â†’ nnreal} (u : filter Î¹) [ne_bot u]\n    [is_countably_generated u] (hf : âˆ€ i, measurable (f i)) (lim : tendsto f u ((nhds) g)) : measurable g :=\n  by\n  simp_rw [â† measurable_coe_nnreal_ennreal_iff] at hfâŠ¢\n  refine' measurable_of_tendsto_ennreal' u hf _\n  rw [tendsto_pi_nhds] at limâŠ¢\n  exact fun x => (ennreal.continuous_coe.tendsto (g x)).comp (lim x)\n#align measurable_of_tendsto_nnreal' measurable_of_tendsto_nnreal'\n\n",
 "measurable_of_tendsto_nnreal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- A sequential limit of measurable `â„â‰¥0` valued functions is measurable. -/\ntheorem measurable_of_tendsto_nnreal {f : â„• â†’ Î± â†’ nnreal} {g : Î± â†’ nnreal} (hf : âˆ€ i, measurable (f i))\n    (lim : tendsto f at_top ((nhds) g)) : measurable g :=\n  measurable_of_tendsto_nnreal' at_top hf lim\n#align measurable_of_tendsto_nnreal measurable_of_tendsto_nnreal\n\n",
 "measurable_of_tendsto_metrizable_ae":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€áµ âˆ‚ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€áµ âˆ‚ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem measurable_of_tendsto_metrizable_ae {Î¼ : measure Î±} [Î¼.is_complete] {f : â„• â†’ Î± â†’ Î²} {g : Î± â†’ Î²}\n    (hf : âˆ€ n, measurable (f n))\n    (h_ae_tendsto :\n      Â«exprâˆ€áµ âˆ‚ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€áµ âˆ‚ , Â»\" Î¼\n        (tendsto (fun n => f n x) at_top ((nhds) (g x)))) :\n    measurable g :=\n  ae_measurable_iff_measurable.mp (ae_measurable_of_tendsto_metrizable_ae' (fun i => (hf i).ae_measurable) h_ae_tendsto)\n#align measurable_of_tendsto_metrizable_ae measurable_of_tendsto_metrizable_ae\n\n",
 "measurable_of_tendsto_metrizable'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- A limit (over a general filter) of measurable functions valued in a (pseudo) metrizable space is\nmeasurable. -/\ntheorem measurable_of_tendsto_metrizable' {Î¹} {f : Î¹ â†’ Î± â†’ Î²} {g : Î± â†’ Î²} (u : filter Î¹) [ne_bot u]\n    [is_countably_generated u] (hf : âˆ€ i, measurable (f i)) (lim : tendsto f u ((nhds) g)) : measurable g :=\n  by\n  letI : pseudo_metric_space Î² := pseudo_metrizable_space_pseudo_metric Î²\n  apply measurable_of_is_closed'\n  intro s h1s h2s h3s\n  have : measurable fun x => inf_nndist (g x) s :=\n    by\n    suffices : tendsto (fun i x => inf_nndist (f i x) s) u ((nhds) fun x => inf_nndist (g x) s)\n    exact measurable_of_tendsto_nnreal' u (fun i => (hf i).inf_nndist) this\n    rw [tendsto_pi_nhds] at limâŠ¢\n    intro x\n    exact ((continuous_inf_nndist_pt s).tendsto (g x)).comp (lim x)\n  have h4s : Â«expr â»Â¹' Â» g s = Â«expr â»Â¹' Â» (fun x => inf_nndist (g x) s) {0} :=\n    by\n    ext x\n    simp [h1s, â† h1s.mem_iff_inf_dist_zero h2s, â† nnreal.coe_eq_zero]\n  rw [h4s]\n  exact this (measurable_set_singleton 0)\n#align measurable_of_tendsto_metrizable' measurable_of_tendsto_metrizable'\n\n",
 "measurable_of_tendsto_metrizable":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- A sequential limit of measurable functions valued in a (pseudo) metrizable space is\nmeasurable. -/\ntheorem measurable_of_tendsto_metrizable {f : â„• â†’ Î± â†’ Î²} {g : Î± â†’ Î²} (hf : âˆ€ i, measurable (f i))\n    (lim : tendsto f at_top ((nhds) g)) : measurable g :=\n  measurable_of_tendsto_metrizable' at_top hf lim\n#align measurable_of_tendsto_metrizable measurable_of_tendsto_metrizable\n\n",
 "measurable_of_tendsto_ennreal'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- A limit (over a general filter) of measurable `â„â‰¥0âˆ` valued functions is measurable. -/\ntheorem measurable_of_tendsto_ennreal' {Î¹} {f : Î¹ â†’ Î± â†’ ennreal} {g : Î± â†’ ennreal} (u : filter Î¹) [ne_bot u]\n    [is_countably_generated u] (hf : âˆ€ i, measurable (f i)) (lim : tendsto f u ((nhds) g)) : measurable g :=\n  by\n  rcases u.exists_seq_tendsto with âŸ¨x, hxâŸ©\n  rw [tendsto_pi_nhds] at lim\n  have : (fun y => liminf (fun n => (f (x n) y : ennreal)) at_top) = g :=\n    by\n    ext1 y\n    exact ((lim y).comp hx).liminf_eq\n  rw [â† this]\n  show measurable fun y => liminf (fun n => (f (x n) y : ennreal)) at_top\n  exact measurable_liminf fun n => hf (x n)\n#align measurable_of_tendsto_ennreal' measurable_of_tendsto_ennreal'\n\n",
 "measurable_of_tendsto_ennreal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- A sequential limit of measurable `â„â‰¥0âˆ` valued functions is measurable. -/\ntheorem measurable_of_tendsto_ennreal {f : â„• â†’ Î± â†’ ennreal} {g : Î± â†’ ennreal} (hf : âˆ€ i, measurable (f i))\n    (lim : tendsto f at_top ((nhds) g)) : measurable g :=\n  measurable_of_tendsto_ennreal' at_top hf lim\n#align measurable_of_tendsto_ennreal measurable_of_tendsto_ennreal\n\n",
 "measurable_of_real":
 "@[measurability]\ntheorem measurable_of_real : measurable ennreal.of_real :=\n  ennreal.continuous_of_real.measurable\n#align measurable_of_real measurable_of_real\n\n",
 "measurable_of_measurable_real":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¥Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\ntheorem ereal.measurable_of_measurable_real {f : ereal â†’ Î±} (h : measurable fun p : exprâ„ => f p) : measurable f :=\n  measurable_of_measurable_on_compl_finite {Â«exprâŠ¥Â», Â«exprâŠ¤Â»} (by simp)\n    (measurable_equiv.ereal_equiv_real.symm.measurable_comp_iff.1 h)\n#align ereal.measurable_of_measurable_real ereal.measurable_of_measurable_real\n\n",
 "measurable_of_measurable_nnreal_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰ƒáµ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\ntheorem measurable_of_measurable_nnreal_prod [measurable_space Î²] [measurable_space Î³] {f : ennreal Ã— Î² â†’ Î³}\n    (Hâ‚ : measurable fun p : nnreal Ã— Î² => f (p.1, p.2)) (Hâ‚‚ : measurable fun x => f (ennreal.top, x)) : measurable f :=\n  let e : Â«expr â‰ƒáµ Â» (ennreal Ã— Î²) (Sum (nnreal Ã— Î²) (unit Ã— Î²)) :=\n    (ennreal_equiv_sum.prod_congr (measurable_equiv.refl Î²)).trans (measurable_equiv.sum_prod_distrib _ _ _)\n  e.symm.measurable_comp_iff.1 <| measurable_sum Hâ‚ (Hâ‚‚.comp measurable_id.snd)\n#align measurable_of_measurable_nnreal_prod measurable_of_measurable_nnreal_prod\n\n",
 "measurable_of_measurable_nnreal_nnreal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\ntheorem measurable_of_measurable_nnreal_nnreal [measurable_space Î²] {f : ennreal Ã— ennreal â†’ Î²}\n    (hâ‚ : measurable fun p : nnreal Ã— nnreal => f (p.1, p.2)) (hâ‚‚ : measurable fun r : nnreal => f (ennreal.top, r))\n    (hâ‚ƒ : measurable fun r : nnreal => f (r, ennreal.top)) : measurable f :=\n  measurable_of_measurable_nnreal_prod\n    (measurable_swap_iff.1 <| measurable_of_measurable_nnreal_prod (hâ‚.comp measurable_swap) hâ‚ƒ)\n    (measurable_of_measurable_nnreal hâ‚‚)\n#align measurable_of_measurable_nnreal_nnreal measurable_of_measurable_nnreal_nnreal\n\n",
 "measurable_of_measurable_nnreal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\ntheorem measurable_of_measurable_nnreal {f : ennreal â†’ Î±} (h : measurable fun p : nnreal => f p) : measurable f :=\n  measurable_of_measurable_on_compl_singleton (ennreal.top)\n    (measurable_equiv.ennreal_equiv_nnreal.symm.measurable_comp_iff.1 h)\n#align measurable_of_measurable_nnreal measurable_of_measurable_nnreal\n\n",
 "measurable_of_is_open":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\ntheorem measurable_of_is_open {f : Î´ â†’ Î³} (hf : âˆ€ s, is_open s â†’ measurable_set (Â«expr â»Â¹' Â» f s)) : measurable f :=\n  by\n  rw [â€¹borel_space Î³â€º.measurable_eq]\n  exact measurable_generate_from hf\n#align measurable_of_is_open measurable_of_is_open\n\n",
 "measurable_of_is_closed'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\ntheorem measurable_of_is_closed' {f : Î´ â†’ Î³}\n    (hf : âˆ€ s, is_closed s â†’ s.nonempty â†’ s â‰  univ â†’ measurable_set (Â«expr â»Â¹' Â» f s)) : measurable f :=\n  by\n  apply measurable_of_is_closed; intro s hs\n  cases' eq_empty_or_nonempty s with h1 h1; Â· simp [h1]\n  by_cases h2 : s = univ; Â· simp [h2]\n  exact hf s hs h1 h2\n#align measurable_of_is_closed' measurable_of_is_closed'\n\n",
 "measurable_of_is_closed":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\ntheorem measurable_of_is_closed {f : Î´ â†’ Î³} (hf : âˆ€ s, is_closed s â†’ measurable_set (Â«expr â»Â¹' Â» f s)) : measurable f :=\n  by\n  apply measurable_of_is_open; intro s hs\n  rw [â† measurable_set.compl_iff, â† preimage_compl]; apply hf; rw [is_closed_compl_iff]; exact hs\n#align measurable_of_is_closed measurable_of_is_closed\n\n",
 "measurable_of_continuous_on_compl_singleton":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á¶œÂ» -/\ntheorem measurable_of_continuous_on_compl_singleton [t1_space Î±] {f : Î± â†’ Î³} (a : Î±)\n    (hf : continuous_on f (Â«expr á¶œÂ» {a})) : measurable f :=\n  measurable_of_measurable_on_compl_singleton a (continuous_on_iff_continuous_restrict.1 hf).measurable\n#align measurable_of_continuous_on_compl_singleton measurable_of_continuous_on_compl_singleton\n\n",
 "measurable_of_Ioi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\ntheorem measurable_of_Ioi {f : Î´ â†’ Î±} (hf : âˆ€ x, measurable_set (Â«expr â»Â¹' Â» f (Ioi x))) : measurable f :=\n  by\n  convert measurable_generate_from _\n  exact borel_space.measurable_eq.trans (borel_eq_generate_from_Ioi _)\n  rintro _ âŸ¨x, rflâŸ©; exact hf x\n#align measurable_of_Ioi measurable_of_Ioi\n\n",
 "measurable_of_Iio":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\ntheorem measurable_of_Iio {f : Î´ â†’ Î±} (hf : âˆ€ x, measurable_set (Â«expr â»Â¹' Â» f (Iio x))) : measurable f :=\n  by\n  convert measurable_generate_from _\n  exact borel_space.measurable_eq.trans (borel_eq_generate_from_Iio _)\n  rintro _ âŸ¨x, rflâŸ©; exact hf x\n#align measurable_of_Iio measurable_of_Iio\n\n",
 "measurable_of_Iic":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\ntheorem measurable_of_Iic {f : Î´ â†’ Î±} (hf : âˆ€ x, measurable_set (Â«expr â»Â¹' Â» f (Iic x))) : measurable f :=\n  by\n  apply measurable_of_Ioi\n  simp_rw [â† compl_Iic, preimage_compl, measurable_set.compl_iff]\n  assumption\n#align measurable_of_Iic measurable_of_Iic\n\n",
 "measurable_of_Ici":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\ntheorem measurable_of_Ici {f : Î´ â†’ Î±} (hf : âˆ€ x, measurable_set (Â«expr â»Â¹' Â» f (Ici x))) : measurable f :=\n  by\n  apply measurable_of_Iio\n  simp_rw [â† compl_Ici, preimage_compl, measurable_set.compl_iff]\n  assumption\n#align measurable_of_Ici measurable_of_Ici\n\n",
 "measurable_norm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n@[measurability]\ntheorem measurable_norm : measurable (norm : Î± â†’ exprâ„) :=\n  continuous_norm.measurable\n#align measurable_norm measurable_norm\n\n",
 "measurable_nnnorm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n@[measurability]\ntheorem measurable_nnnorm : measurable (nnnorm : Î± â†’ nnreal) :=\n  continuous_nnnorm.measurable\n#align measurable_nnnorm measurable_nnnorm\n\n",
 "measurable_nndist":
 "@[measurability]\ntheorem measurable_nndist : measurable fun p : Î± Ã— Î± => nndist p.1 p.2 :=\n  continuous_nndist.measurable\n#align measurable_nndist measurable_nndist\n\n",
 "measurable_mk'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- Instances on `real` and `complex` are special cases of `is_R_or_C` but without these instances,\nLean fails to prove `borel_space (Î¹ â†’ â„)`, so we leave them here. -/\n@[measurability]\nprotected theorem add_circle.measurable_mk' {a : exprâ„} : measurable (coe : exprâ„ â†’ add_circle a) :=\n  continuous.measurable <| add_circle.continuous_mk' a\n#align add_circle.measurable_mk' add_circle.measurable_mk'\n\n",
 "measurable_limsup'":
 "/-- `limsup` over a general filter is measurable. See `measurable_limsup` for the version over `â„•`.\n-/\ntheorem measurable_limsup' {Î¹ Î¹'} {f : Î¹ â†’ Î´ â†’ Î±} {u : filter Î¹} (hf : âˆ€ i, measurable (f i)) {p : Î¹' â†’ Prop}\n    {s : Î¹' â†’ set Î¹} (hu : u.has_countable_basis p s) (hs : âˆ€ i, (s i).countable) :\n    measurable fun x => limsup (fun i => f i x) u :=\n  by\n  simp_rw [hu.to_has_basis.limsup_eq_infi_supr]\n  refine' measurable_binfi _ hu.countable _\n  exact fun i => measurable_bsupr _ (hs i) hf\n#align measurable_limsup' measurable_limsup'\n\n",
 "measurable_limsup":
 "/-- `limsup` over `â„•` is measurable. See `measurable_limsup'` for a version with a general filter.\n-/\n@[measurability]\ntheorem measurable_limsup {f : â„• â†’ Î´ â†’ Î±} (hf : âˆ€ i, measurable (f i)) :\n    measurable fun x => limsup (fun i => f i x) at_top :=\n  measurable_limsup' hf at_top_countable_basis fun i => to_countable _\n#align measurable_limsup measurable_limsup\n\n",
 "measurable_limit_of_tendsto_metrizable_ae":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¥Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€áµ âˆ‚ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€áµ âˆ‚ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€áµ âˆ‚ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€áµ âˆ‚ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€áµ âˆ‚ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€áµ âˆ‚ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€áµ âˆ‚ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€áµ âˆ‚ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem measurable_limit_of_tendsto_metrizable_ae {Î¹} [countable Î¹] [nonempty Î¹] {Î¼ : measure Î±} {f : Î¹ â†’ Î± â†’ Î²}\n    {L : filter Î¹} [L.is_countably_generated] (hf : âˆ€ n, ae_measurable (f n) Î¼)\n    (h_ae_tendsto :\n      Â«exprâˆ€áµ âˆ‚ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€áµ âˆ‚ , Â»\" Î¼\n        (âˆƒ l : Î², tendsto (fun n => f n x) L ((nhds) l))) :\n    âˆƒ (f_lim : Î± â†’ Î²)(hf_lim_meas : measurable f_lim),\n      Â«exprâˆ€áµ âˆ‚ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€áµ âˆ‚ , Â»\" Î¼\n        (tendsto (fun n => f n x) L ((nhds) (f_lim x))) :=\n  by\n  inhabit Î¹\n  rcases eq_or_ne L (Â«exprâŠ¥Â») with (rfl | hL)\n  Â· exact âŸ¨(hf default).mk _, (hf default).measurable_mk, eventually_of_forall fun x => tendsto_botâŸ©\n  haveI : ne_bot L := âŸ¨hLâŸ©\n  let p : Î± â†’ (Î¹ â†’ Î²) â†’ Prop := fun x f' => âˆƒ l : Î², tendsto (fun n => f' n) L ((nhds) l)\n  have hp_mem : âˆ€ x âˆˆ ae_seq_set hf p, p x fun n => f n x := fun x hx => ae_seq.fun_prop_of_mem_ae_seq_set hf hx\n  have h_ae_eq :\n    Â«exprâˆ€áµ âˆ‚ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€áµ âˆ‚ , Â»\" Î¼\n      (âˆ€ n, ae_seq hf p n x = f n x) :=\n    ae_seq.ae_seq_eq_fun_ae hf h_ae_tendsto\n  let f_lim : Î± â†’ Î² := fun x =>\n    dite (x âˆˆ ae_seq_set hf p) (fun h => (hp_mem x h).some) fun h => (âŸ¨f default xâŸ© : nonempty Î²).some\n  have hf_lim : âˆ€ x, tendsto (fun n => ae_seq hf p n x) L ((nhds) (f_lim x)) :=\n    by\n    intro x\n    simp only [f_lim, ae_seq]\n    split_ifs\n    Â· refine' (hp_mem x h).some_spec.congr fun n => _\n      exact (ae_seq.mk_eq_fun_of_mem_ae_seq_set hf h n).symm\n    Â· exact tendsto_const_nhds\n  have h_ae_tendsto_f_lim :\n    Â«exprâˆ€áµ âˆ‚ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€áµ âˆ‚ , Â»\" Î¼\n      (tendsto (fun n => f n x) L ((nhds) (f_lim x))) :=\n    h_ae_eq.mono fun x hx => (hf_lim x).congr hx\n  have h_f_lim_meas : measurable f_lim :=\n    measurable_of_tendsto_metrizable' L (ae_seq.measurable hf p) (tendsto_pi_nhds.mpr fun x => hf_lim x)\n  exact âŸ¨f_lim, h_f_lim_meas, h_ae_tendsto_f_limâŸ©\n#align measurable_limit_of_tendsto_metrizable_ae measurable_limit_of_tendsto_metrizable_ae\n\n",
 "measurable_liminf'":
 "/-- `liminf` over a general filter is measurable. See `measurable_liminf` for the version over `â„•`.\n-/\ntheorem measurable_liminf' {Î¹ Î¹'} {f : Î¹ â†’ Î´ â†’ Î±} {u : filter Î¹} (hf : âˆ€ i, measurable (f i)) {p : Î¹' â†’ Prop}\n    {s : Î¹' â†’ set Î¹} (hu : u.has_countable_basis p s) (hs : âˆ€ i, (s i).countable) :\n    measurable fun x => liminf (fun i => f i x) u :=\n  by\n  simp_rw [hu.to_has_basis.liminf_eq_supr_infi]\n  refine' measurable_bsupr _ hu.countable _\n  exact fun i => measurable_binfi _ (hs i) hf\n#align measurable_liminf' measurable_liminf'\n\n",
 "measurable_liminf":
 "/-- `liminf` over `â„•` is measurable. See `measurable_liminf'` for a version with a general filter.\n-/\n@[measurability]\ntheorem measurable_liminf {f : â„• â†’ Î´ â†’ Î±} (hf : âˆ€ i, measurable (f i)) :\n    measurable fun x => liminf (fun i => f i x) at_top :=\n  measurable_liminf' hf at_top_countable_basis fun i => to_countable _\n#align measurable_liminf measurable_liminf\n\n",
 "measurable_infi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ¨… , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨… , Â» -/\n@[measurability]\ntheorem measurable_infi {Î¹} [countable Î¹] {f : Î¹ â†’ Î´ â†’ Î±} (hf : âˆ€ i, measurable (f i)) :\n    measurable fun b =>\n      Â«exprâ¨… , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨… , Â»\" (f i b) :=\n  measurable.is_glb hf fun b => isGLB_infáµ¢\n#align measurable_infi measurable_infi\n\n",
 "measurable_inf_nndist":
 "@[measurability]\ntheorem measurable_inf_nndist {s : set Î±} : measurable fun x => inf_nndist x s :=\n  (continuous_inf_nndist_pt s).measurable\n#align measurable_inf_nndist measurable_inf_nndist\n\n",
 "measurable_inf_edist":
 "@[measurability]\ntheorem measurable_inf_edist {s : set Î±} : measurable fun x => inf_edist x s :=\n  continuous_inf_edist.measurable\n#align measurable_inf_edist measurable_inf_edist\n\n",
 "measurable_inf_dist":
 "@[measurability]\ntheorem measurable_inf_dist {s : set Î±} : measurable fun x => inf_dist x s :=\n  (continuous_inf_dist_pt s).measurable\n#align measurable_inf_dist measurable_inf_dist\n\n",
 "measurable_ereal_to_real":
 "@[measurability]\ntheorem measurable_ereal_to_real : measurable ereal.to_real :=\n  ereal.measurable_of_measurable_real (by simpa using measurable_id)\n#align measurable_ereal_to_real measurable_ereal_to_real\n\n",
 "measurable_ennnorm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–â‚ŠÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n@[measurability]\ntheorem measurable_ennnorm : measurable fun x : Î± => (Â«exprâ€– â€–â‚ŠÂ» x : ennreal) :=\n  measurable_nnnorm.coe_nnreal_ennreal\n#align measurable_ennnorm measurable_ennnorm\n\n",
 "measurable_embedding":
 "protected theorem open_embedding.measurable_embedding {f : Î± â†’ Î²} (h : open_embedding f) : measurable_embedding f :=\n  h.to_embedding.measurable_embedding h.open_range.measurable_set\n#align open_embedding.measurable_embedding open_embedding.measurable_embedding\n\n",
 "measurable_edist_right":
 "@[measurability]\ntheorem measurable_edist_right : measurable (edist x) :=\n  (continuous_const.edist continuous_id).measurable\n#align measurable_edist_right measurable_edist_right\n\n",
 "measurable_edist_left":
 "@[measurability]\ntheorem measurable_edist_left : measurable fun y => edist y x :=\n  (continuous_id.edist continuous_const).measurable\n#align measurable_edist_left measurable_edist_left\n\n",
 "measurable_edist":
 "@[measurability]\ntheorem measurable_edist : measurable fun p : Î± Ã— Î± => edist p.1 p.2 :=\n  continuous_edist.measurable\n#align measurable_edist measurable_edist\n\n",
 "measurable_dist":
 "@[measurability]\ntheorem measurable_dist : measurable fun p : Î± Ã— Î± => dist p.1 p.2 :=\n  continuous_dist.measurable\n#align measurable_dist measurable_dist\n\n",
 "measurable_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\ntheorem measurable_comp (L : Â«expr â†’L[ ] Â» E ğ•œ F) {Ï† : Î± â†’ E} (Ï†_meas : measurable Ï†) :\n    measurable fun a : Î± => L (Ï† a) :=\n  L.measurable.comp Ï†_meas\n#align measurable_comp measurable_comp\n\n",
 "measurable_coe_real_ereal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n@[measurability]\ntheorem measurable_coe_real_ereal : measurable (coe : exprâ„ â†’ ereal) :=\n  continuous_coe_real_ereal.measurable\n#align measurable_coe_real_ereal measurable_coe_real_ereal\n\n",
 "measurable_coe_nnreal_real_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n@[simp, norm_cast]\ntheorem measurable_coe_nnreal_real_iff {f : Î± â†’ nnreal} : measurable (fun x => f x : Î± â†’ exprâ„) â†” measurable f :=\n  âŸ¨fun h => by simpa only [real.to_nnreal_coe] using h.real_to_nnreal, measurable.coe_nnreal_realâŸ©\n#align measurable_coe_nnreal_real_iff measurable_coe_nnreal_real_iff\n\n",
 "measurable_coe_nnreal_real":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n@[measurability]\ntheorem measurable_coe_nnreal_real : measurable (coe : nnreal â†’ exprâ„) :=\n  nnreal.continuous_coe.measurable\n#align measurable_coe_nnreal_real measurable_coe_nnreal_real\n\n",
 "measurable_coe_nnreal_ennreal_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n@[simp, norm_cast]\ntheorem measurable_coe_nnreal_ennreal_iff {f : Î± â†’ nnreal} : (measurable fun x => (f x : ennreal)) â†” measurable f :=\n  âŸ¨fun h => h.ennreal_to_nnreal, fun h => h.coe_nnreal_ennrealâŸ©\n#align measurable_coe_nnreal_ennreal_iff measurable_coe_nnreal_ennreal_iff\n\n",
 "measurable_coe_nnreal_ennreal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n@[measurability]\ntheorem measurable_coe_nnreal_ennreal : measurable (coe : nnreal â†’ ennreal) :=\n  ennreal.continuous_coe.measurable\n#align measurable_coe_nnreal_ennreal measurable_coe_nnreal_ennreal\n\n",
 "measurable_coe_ennreal_ereal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n@[measurability]\ntheorem measurable_coe_ennreal_ereal : measurable (coe : ennreal â†’ ereal) :=\n  continuous_coe_ennreal_ereal.measurable\n#align measurable_coe_ennreal_ereal measurable_coe_ennreal_ereal\n\n",
 "measurable_coe":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n@[measurability]\ntheorem measurable_coe [measurable_space F] [borel_space F] : measurable fun (f : Â«expr â†’L[ ] Â» E ğ•œ F) (x : E) => f x :=\n  measurable_pi_lambda _ measurable_apply\n#align measurable_coe measurable_coe\n\n",
 "measurable_cSup":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\ntheorem measurable_cSup {Î¹} {f : Î¹ â†’ Î´ â†’ Î±} {s : set Î¹} (hs : s.countable) (hf : âˆ€ i, measurable (f i))\n    (bdd : âˆ€ x, BddAbove (Â«expr '' Â» (fun i => f i x) s)) : measurable fun x => supâ‚› (Â«expr '' Â» (fun i => f i x) s) :=\n  by\n  cases' eq_empty_or_nonempty s with h2s h2s\n  Â· simp [h2s, measurable_const]\n  Â· apply measurable_of_Iic\n    intro y\n    simp_rw [preimage, mem_Iic, csupâ‚›_le_iff (bdd _) (h2s.image _), ball_image_iff, set_of_forall]\n    exact measurable_set.bInter hs fun i hi => measurable_set_le (hf i) measurable_const\n#align measurable_cSup measurable_cSup\n\n",
 "measurable_bsupr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ¨† , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨† , Â» -/\ntheorem measurable_bsupr {Î¹} (s : set Î¹) {f : Î¹ â†’ Î´ â†’ Î±} (hs : s.countable) (hf : âˆ€ i, measurable (f i)) :\n    measurable fun b =>\n      Â«exprâ¨† , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨† , Â»\" (f i b) :=\n  by\n  haveI : Encodable s := hs.to_encodable\n  simp only [supáµ¢_subtype']\n  exact measurable_supr fun i => hf i\n#align measurable_bsupr measurable_bsupr\n\n",
 "measurable_binfi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ¨… , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨… , Â» -/\ntheorem measurable_binfi {Î¹} (s : set Î¹) {f : Î¹ â†’ Î´ â†’ Î±} (hs : s.countable) (hf : âˆ€ i, measurable (f i)) :\n    measurable fun b =>\n      Â«exprâ¨… , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨… , Â»\" (f i b) :=\n  by\n  haveI : Encodable s := hs.to_encodable\n  simp only [infáµ¢_subtype']\n  exact measurable_infi fun i => hf i\n#align measurable_binfi measurable_binfi\n\n",
 "measurable_apply'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n@[measurability]\ntheorem measurable_apply' [measurable_space E] [opens_measurable_space E] [measurable_space F] [borel_space F] :\n    measurable fun (x : E) (f : Â«expr â†’L[ ] Â» E ğ•œ F) => f x :=\n  measurable_pi_lambda _ fun f => f.measurable\n#align measurable_apply' measurable_apply'\n\n",
 "measurable_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n@[measurability]\ntheorem measurable_apply [measurable_space F] [borel_space F] (x : E) : measurable fun f : Â«expr â†’L[ ] Â» E ğ•œ F => f x :=\n  (apply ğ•œ F x).continuous.measurable\n#align measurable_apply measurable_apply\n\n",
 "measurable2":
 "theorem continuous.measurable2 [second_countable_topology Î±] [second_countable_topology Î²] {f : Î´ â†’ Î±} {g : Î´ â†’ Î²}\n    {c : Î± â†’ Î² â†’ Î³} (h : continuous fun p : Î± Ã— Î² => c p.1 p.2) (hf : measurable f) (hg : measurable g) :\n    measurable fun a => c (f a) (g a) :=\n  h.measurable.comp (hf.prod_mk hg)\n#align continuous.measurable2 continuous.measurable2\n\n",
 "measurable":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n@[measurability]\nprotected theorem measurable (L : Â«expr â†’L[ ] Â» E ğ•œ F) : measurable L :=\n  L.continuous.measurable\n#align measurable measurable\n\n",
 "max":
 "@[measurability]\ntheorem ae_measurable.max {f g : Î´ â†’ Î±} {Î¼ : measure Î´} (hf : ae_measurable f Î¼) (hg : ae_measurable g Î¼) :\n    ae_measurable (fun a => max (f a) (g a)) Î¼ :=\n  âŸ¨fun a => max (hf.mk f a) (hg.mk g a), hf.measurable_mk.max hg.measurable_mk,\n    eventually_eq.compâ‚‚ hf.ae_eq_mk _ hg.ae_eq_mkâŸ©\n#align ae_measurable.max ae_measurable.max\n\n",
 "map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰ƒâ‚œ Â» -/\nprotected theorem is_finite_measure_on_compacts.map {Î± : Type _} {m0 : measurable_space Î±} [topological_space Î±]\n    [opens_measurable_space Î±] {Î² : Type _} [measurable_space Î²] [topological_space Î²] [borel_space Î²] [t2_space Î²]\n    (Î¼ : measure Î±) [is_finite_measure_on_compacts Î¼] (f : Â«expr â‰ƒâ‚œ Â» Î± Î²) :\n    is_finite_measure_on_compacts (measure.map f Î¼) :=\n  âŸ¨by\n    intro K hK\n    rw [measure.map_apply f.measurable hK.measurable_set]\n    apply is_compact.measure_lt_top\n    rwa [f.is_compact_preimage]âŸ©\n#align is_finite_measure_on_compacts.map is_finite_measure_on_compacts.map\n\n",
 "is_pi_system_is_open":
 "theorem is_pi_system_is_open [topological_space Î±] : is_pi_system (is_open : set Î± â†’ Prop) := fun s hs t ht hst =>\n  is_open.inter hs ht\n#align is_pi_system_is_open is_pi_system_is_open\n\n",
 "is_pi_system_Ioo_rat":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„š -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„š -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â» -/\ntheorem is_pi_system_Ioo_rat :\n    @is_pi_system (exprâ„)\n      (Â«exprâ‹ƒ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â»\" {Ioo a b}) :=\n  by\n  convert is_pi_system_Ioo (coe : exprâ„š â†’ exprâ„) (coe : exprâ„š â†’ exprâ„)\n  ext x\n  simp [eq_comm]\n#align is_pi_system_Ioo_rat is_pi_system_Ioo_rat\n\n",
 "is_open_pos_measure_map":
 "theorem continuous.is_open_pos_measure_map {f : Î² â†’ Î³} (hf : continuous f) (hf_surj : function.surjective f)\n    {Î¼ : measure Î²} [Î¼.is_open_pos_measure] : (measure.map f Î¼).is_open_pos_measure :=\n  by\n  refine' âŸ¨fun U hUo hUne => _âŸ©\n  rw [measure.map_apply hf.measurable hUo.measurable_set]\n  exact (hUo.preimage hf).measure_ne_zero Î¼ (hf_surj.nonempty_preimage.mpr hUne)\n#align continuous.is_open_pos_measure_map continuous.is_open_pos_measure_map\n\n",
 "is_lub_of_nonempty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€áµ âˆ‚ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€áµ âˆ‚ , Â» -/\nprivate theorem ae_measurable.is_lub_of_nonempty {Î¹} (hÎ¹ : nonempty Î¹) {Î¼ : measure Î´} [countable Î¹] {f : Î¹ â†’ Î´ â†’ Î±}\n    {g : Î´ â†’ Î±} (hf : âˆ€ i, ae_measurable (f i) Î¼)\n    (hg :\n      Â«exprâˆ€áµ âˆ‚ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€áµ âˆ‚ , Â»\" Î¼\n        (IsLUB { a | âˆƒ i, f i b = a } (g b))) :\n    ae_measurable g Î¼ :=\n  by\n  let p : Î´ â†’ (Î¹ â†’ Î±) â†’ Prop := fun x f' => IsLUB { a | âˆƒ i, f' i = a } (g x)\n  let g_seq x := ite (x âˆˆ ae_seq_set hf p) (g x) (âŸ¨g xâŸ© : nonempty Î±).some\n  have hg_seq : âˆ€ b, IsLUB { a | âˆƒ i, ae_seq hf p i b = a } (g_seq b) :=\n    by\n    intro b\n    haveI hÎ± : nonempty Î± := nonempty.map g âŸ¨bâŸ©\n    simp only [ae_seq, g_seq]\n    split_ifs\n    Â· have h_set_eq : { a : Î± | âˆƒ i : Î¹, (hf i).mk (f i) b = a } = { a : Î± | âˆƒ i : Î¹, f i b = a } :=\n        by\n        ext x\n        simp_rw [Set.mem_setOf_eq, ae_seq.mk_eq_fun_of_mem_ae_seq_set hf h]\n      rw [h_set_eq]\n      exact ae_seq.fun_prop_of_mem_ae_seq_set hf h\n    Â· have h_singleton : { a : Î± | âˆƒ i : Î¹, hÎ±.some = a } = {hÎ±.some} :=\n        by\n        ext1 x\n        exact âŸ¨fun hx => hx.some_spec.symm, fun hx => âŸ¨hÎ¹.some, hx.symmâŸ©âŸ©\n      rw [h_singleton]\n      exact isLUB_singleton\n  refine' âŸ¨g_seq, measurable.is_lub (ae_seq.measurable hf p) hg_seq, _âŸ©\n  exact\n    (ite_ae_eq_of_measure_compl_zero g (fun x => (âŸ¨g xâŸ© : nonempty Î±).some) (ae_seq_set hf p)\n        (ae_seq.measure_compl_ae_seq_set_eq_zero hf hg)).symm\n#align ae_measurable.is_lub_of_nonempty ae_measurable.is_lub_of_nonempty\n\n",
 "is_lub":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr =áµ[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€áµ âˆ‚ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€áµ âˆ‚ , Â» -/\ntheorem ae_measurable.is_lub {Î¹} {Î¼ : measure Î´} [countable Î¹] {f : Î¹ â†’ Î´ â†’ Î±} {g : Î´ â†’ Î±}\n    (hf : âˆ€ i, ae_measurable (f i) Î¼)\n    (hg :\n      Â«exprâˆ€áµ âˆ‚ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€áµ âˆ‚ , Â»\" Î¼\n        (IsLUB { a | âˆƒ i, f i b = a } (g b))) :\n    ae_measurable g Î¼ := by\n  by_cases hÎ¼ : Î¼ = 0\n  Â· rw [hÎ¼]\n    exact ae_measurable_zero_measure\n  have : Î¼.ae.ne_bot := by simpa [ne_bot_iff]\n  by_cases hÎ¹ : nonempty Î¹\n  Â· exact ae_measurable.is_lub_of_nonempty hÎ¹ hf hg\n  suffices âˆƒ x, Â«expr =áµ[ ] Â» g Î¼ fun y => g x by exact âŸ¨fun y => g this.some, measurable_const, this.some_specâŸ©\n  have h_empty : âˆ€ x, { a : Î± | âˆƒ i : Î¹, f i x = a } = âˆ… :=\n    by\n    intro x\n    ext1 y\n    rw [Set.mem_setOf_eq, Set.mem_empty_iff_false, iff_false_iff]\n    exact fun hi => hÎ¹ (nonempty_of_exists hi)\n  simp_rw [h_empty] at hg\n  exact âŸ¨hg.exists.some, hg.mono fun y hy => IsLUB.unique hy hg.exists.some_specâŸ©\n#align ae_measurable.is_lub ae_measurable.is_lub\n\n",
 "is_glb":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€áµ âˆ‚ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€áµ âˆ‚ , Â» -/\ntheorem ae_measurable.is_glb {Î¹} {Î¼ : measure Î´} [countable Î¹] {f : Î¹ â†’ Î´ â†’ Î±} {g : Î´ â†’ Î±}\n    (hf : âˆ€ i, ae_measurable (f i) Î¼)\n    (hg :\n      Â«exprâˆ€áµ âˆ‚ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€áµ âˆ‚ , Â»\" Î¼\n        (IsGLB { a | âˆƒ i, f i b = a } (g b))) :\n    ae_measurable g Î¼ := by\n  nontriviality Î±\n  haveI hÎ± : nonempty Î± := infer_instance\n  cases' isEmpty_or_nonempty Î¹ with hÎ¹ hÎ¹\n  Â· simp only [is_empty.exists_iff, set_of_false, is_glb_empty_iff] at hg\n    exact ae_measurable_const' (hg.mono fun a ha => hg.mono fun b hb => (hb _).antisymm (ha _))\n  let p : Î´ â†’ (Î¹ â†’ Î±) â†’ Prop := fun x f' => IsGLB { a | âˆƒ i, f' i = a } (g x)\n  let g_seq := (ae_seq_set hf p).piecewise g fun _ => hÎ±.some\n  have hg_seq : âˆ€ b, IsGLB { a | âˆƒ i, ae_seq hf p i b = a } (g_seq b) :=\n    by\n    intro b\n    simp only [ae_seq, g_seq, set.piecewise]\n    split_ifs\n    Â· have h_set_eq : { a : Î± | âˆƒ i : Î¹, (hf i).mk (f i) b = a } = { a : Î± | âˆƒ i : Î¹, f i b = a } :=\n        by\n        ext x\n        simp_rw [Set.mem_setOf_eq, ae_seq.mk_eq_fun_of_mem_ae_seq_set hf h]\n      rw [h_set_eq]\n      exact ae_seq.fun_prop_of_mem_ae_seq_set hf h\n    Â· exact IsLeast.isGLB âŸ¨(@exists_const (hÎ±.some = hÎ±.some) Î¹ _).2 rfl, fun x âŸ¨i, hiâŸ© => hi.leâŸ©\n  refine' âŸ¨g_seq, measurable.is_glb (ae_seq.measurable hf p) hg_seq, _âŸ©\n  exact\n    (ite_ae_eq_of_measure_compl_zero g (fun x => hÎ±.some) (ae_seq_set hf p)\n        (ae_seq.measure_compl_ae_seq_set_eq_zero hf hg)).symm\n#align ae_measurable.is_glb ae_measurable.is_glb\n\n",
 "interior_ae_eq_of_null_frontier":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr =áµ[ ] Â» -/\n-- see Note [lower instance priority]\ntheorem interior_ae_eq_of_null_frontier {Î¼ : measure Î±'} {s : set Î±'} (h : Î¼ (frontier s) = 0) :\n    Â«expr =áµ[ ] Â» (interior s) Î¼ s :=\n  interior_subset.eventually_le.antisymm <| subset_closure.eventually_le.trans (ae_le_set.2 h)\n#align interior_ae_eq_of_null_frontier interior_ae_eq_of_null_frontier\n\n",
 "infi_Prop":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ¨… , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨… , Â» -/\n@[measurability]\ntheorem measurable.infi_Prop {Î±} [measurable_space Î±] [CompleteLattice Î±] (p : Prop) {f : Î´ â†’ Î±} (hf : measurable f) :\n    measurable fun b =>\n      Â«exprâ¨… , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨… , Â»\" (f b) :=\n  by_cases (fun h : p => by convert hf; funext ; exact infáµ¢_pos h) fun h : Â¬p => by convert measurable_const; funext ;\n    exact infáµ¢_neg h\n#align measurable.infi_Prop measurable.infi_Prop\n\n",
 "inf_nndist":
 "@[measurability]\ntheorem measurable.inf_nndist {f : Î² â†’ Î±} (hf : measurable f) {s : set Î±} : measurable fun x => inf_nndist (f x) s :=\n  measurable_inf_nndist.comp hf\n#align measurable.inf_nndist measurable.inf_nndist\n\n",
 "inf_edist":
 "@[measurability]\ntheorem measurable.inf_edist {f : Î² â†’ Î±} (hf : measurable f) {s : set Î±} : measurable fun x => inf_edist (f x) s :=\n  measurable_inf_edist.comp hf\n#align measurable.inf_edist measurable.inf_edist\n\n",
 "inf_dist":
 "@[measurability]\ntheorem measurable.inf_dist {f : Î² â†’ Î±} (hf : measurable f) {s : set Î±} : measurable fun x => inf_dist (f x) s :=\n  measurable_inf_dist.comp hf\n#align measurable.inf_dist measurable.inf_dist\n\n",
 "induction_on_open":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á¶œÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr on Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â» -/\ntheorem _root_.measurable_set.induction_on_open [topological_space Î±] [measurable_space Î±] [borel_space Î±]\n    {C : set Î± â†’ Prop} (h_open : âˆ€ U, is_open U â†’ C U) (h_compl : âˆ€ t, measurable_set t â†’ C t â†’ C (Â«expr á¶œÂ» t))\n    (h_union :\n      âˆ€ f : â„• â†’ set Î±,\n        Pairwise (Â«expr on Â» Disjoint f) â†’\n          (âˆ€ i, measurable_set (f i)) â†’\n            (âˆ€ i, C (f i)) â†’\n              C\n                (Â«exprâ‹ƒ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â»\"\n                  (f i))) :\n    âˆ€ â¦ƒtâ¦„, measurable_set t â†’ C t :=\n  measurable_space.induction_on_inter borel_space.measurable_eq is_pi_system_is_open (h_open _ is_open_empty) h_open\n    h_compl h_union\n#align measurable_set.induction_on_open measurable_set.induction_on_open\n\n",
 "generate_from_Ico_mem_le_borel":
 "theorem generate_from_Ico_mem_le_borel {Î± : Type _} [topological_space Î±] [linear_order Î±] [order_closed_topology Î±]\n    (s t : set Î±) : measurable_space.generate_from { S | âˆƒ l âˆˆ s, âˆƒ u âˆˆ t, âˆƒ h : l < u, Ico l u = S } â‰¤ borel Î± :=\n  by\n  apply generate_from_le\n  borelize Î±\n  rintro _ âŸ¨a, -, b, -, -, rflâŸ©\n  exact measurable_set_Ico\n#align generate_from_Ico_mem_le_borel generate_from_Ico_mem_le_borel\n\n",
 "ext_of_Ioc_finite":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr áµ’áµˆÂ» -/\n/-- Two finite measures on a Borel space are equal if they agree on all open-closed intervals.  If\n`Î±` is a conditionally complete linear order with no top element,\n`measure_theory.measure..ext_of_Ioc` is an extensionality lemma with weaker assumptions on `Î¼` and\n`Î½`. -/\ntheorem ext_of_Ioc_finite {Î± : Type _} [topological_space Î±] {m : measurable_space Î±} [second_countable_topology Î±]\n    [linear_order Î±] [order_topology Î±] [borel_space Î±] (Î¼ Î½ : measure Î±) [is_finite_measure Î¼] (hÎ¼Î½ : Î¼ univ = Î½ univ)\n    (h : âˆ€ â¦ƒa bâ¦„, a < b â†’ Î¼ (Ioc a b) = Î½ (Ioc a b)) : Î¼ = Î½ :=\n  by\n  refine' @ext_of_Ico_finite (Â«expr áµ’áµˆÂ» Î±) _ _ _ _ _ â€¹_â€º Î¼ Î½ _ hÎ¼Î½ fun a b hab => _\n  erw [dual_Ico]\n  exact h hab\n#align ext_of_Ioc_finite ext_of_Ioc_finite\n\n",
 "ext_of_Ioc'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr áµ’áµˆÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/-- Two measures which are finite on closed-open intervals are equal if the agree on all\nopen-closed intervals. -/\ntheorem ext_of_Ioc' {Î± : Type _} [topological_space Î±] {m : measurable_space Î±} [second_countable_topology Î±]\n    [linear_order Î±] [order_topology Î±] [borel_space Î±] [NoMinOrder Î±] (Î¼ Î½ : measure Î±)\n    (hÎ¼ : âˆ€ â¦ƒa bâ¦„, a < b â†’ Î¼ (Ioc a b) â‰  ennreal.top) (h : âˆ€ â¦ƒa bâ¦„, a < b â†’ Î¼ (Ioc a b) = Î½ (Ioc a b)) : Î¼ = Î½ :=\n  by\n  refine' @ext_of_Ico' (Â«expr áµ’áµˆÂ» Î±) _ _ _ _ _ â€¹_â€º _ Î¼ Î½ _ _ <;> intro a b hab <;> erw [dual_Ico]\n  exacts[hÎ¼ hab, h hab]\n#align ext_of_Ioc' ext_of_Ioc'\n\n",
 "ext_of_Ioc":
 "/-- Two measures which are finite on closed-open intervals are equal if the agree on all\nopen-closed intervals. -/\ntheorem ext_of_Ioc {Î± : Type _} [topological_space Î±] {m : measurable_space Î±} [second_countable_topology Î±]\n    [ConditionallyCompleteLinearOrder Î±] [order_topology Î±] [borel_space Î±] [NoMinOrder Î±] (Î¼ Î½ : measure Î±)\n    [is_locally_finite_measure Î¼] (h : âˆ€ â¦ƒa bâ¦„, a < b â†’ Î¼ (Ioc a b) = Î½ (Ioc a b)) : Î¼ = Î½ :=\n  Î¼.ext_of_Ioc' Î½ (fun a b hab => measure_Ioc_lt_top.ne) h\n#align ext_of_Ioc ext_of_Ioc\n\n",
 "ext_of_Iic":
 "/-- Two finite measures on a Borel space are equal if they agree on all left-infinite right-closed\nintervals. -/\ntheorem ext_of_Iic {Î± : Type _} [topological_space Î±] {m : measurable_space Î±} [second_countable_topology Î±]\n    [linear_order Î±] [order_topology Î±] [borel_space Î±] (Î¼ Î½ : measure Î±) [is_finite_measure Î¼]\n    (h : âˆ€ a, Î¼ (Iic a) = Î½ (Iic a)) : Î¼ = Î½ :=\n  by\n  refine' ext_of_Ioc_finite Î¼ Î½ _ fun a b hlt => _\n  Â· rcases exists_countable_dense_bot_top Î± with âŸ¨s, hsc, hsd, -, hstâŸ©\n    have : DirectedOn (Â· â‰¤ Â·) s := directedOn_iff_directed.2 (directed_of_sup fun _ _ => id)\n    simp only [â† bsupr_measure_Iic hsc (hsd.exists_ge' hst) this, h]\n  rw [â† Iic_diff_Iic, measure_diff (Iic_subset_Iic.2 hlt.le) measurable_set_Iic,\n    measure_diff (Iic_subset_Iic.2 hlt.le) measurable_set_Iic, h a, h b]\n  Â· rw [â† h a]\n    exact (measure_lt_top Î¼ _).ne\n  Â· exact (measure_lt_top Î¼ _).ne\n#align ext_of_Iic ext_of_Iic\n\n",
 "ext_of_Ico_finite":
 "/-- Two finite measures on a Borel space are equal if they agree on all closed-open intervals.  If\n`Î±` is a conditionally complete linear order with no top element,\n`measure_theory.measure..ext_of_Ico` is an extensionality lemma with weaker assumptions on `Î¼` and\n`Î½`. -/\ntheorem ext_of_Ico_finite {Î± : Type _} [topological_space Î±] {m : measurable_space Î±} [second_countable_topology Î±]\n    [linear_order Î±] [order_topology Î±] [borel_space Î±] (Î¼ Î½ : measure Î±) [is_finite_measure Î¼] (hÎ¼Î½ : Î¼ univ = Î½ univ)\n    (h : âˆ€ â¦ƒa bâ¦„, a < b â†’ Î¼ (Ico a b) = Î½ (Ico a b)) : Î¼ = Î½ :=\n  by\n  refine'\n    ext_of_generate_finite _ (borel_space.measurable_eq.trans (borel_eq_generate_from_Ico Î±))\n      (is_pi_system_Ico (id : Î± â†’ Î±) id) _ hÎ¼Î½\n  Â· rintro - âŸ¨a, b, hlt, rflâŸ©\n    exact h hlt\n#align ext_of_Ico_finite ext_of_Ico_finite\n\n",
 "ext_of_Ico'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/-- Two measures which are finite on closed-open intervals are equal if the agree on all\nclosed-open intervals. -/\ntheorem ext_of_Ico' {Î± : Type _} [topological_space Î±] {m : measurable_space Î±} [second_countable_topology Î±]\n    [linear_order Î±] [order_topology Î±] [borel_space Î±] [NoMaxOrder Î±] (Î¼ Î½ : measure Î±)\n    (hÎ¼ : âˆ€ â¦ƒa bâ¦„, a < b â†’ Î¼ (Ico a b) â‰  ennreal.top) (h : âˆ€ â¦ƒa bâ¦„, a < b â†’ Î¼ (Ico a b) = Î½ (Ico a b)) : Î¼ = Î½ :=\n  by\n  rcases exists_countable_dense_bot_top Î± with âŸ¨s, hsc, hsd, hsb, hstâŸ©\n  have :\n    (Â«exprâ‹ƒ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â»\" {Ico l u} :\n        set (set Î±)).countable :=\n    hsc.bUnion fun l hl => hsc.bUnion fun u hu => countable_Union fun _ => countable_singleton _\n  simp only [â† set_of_eq_eq_singleton, â† set_of_exists] at this\n  refine'\n    measure.ext_of_generate_from_of_cover_subset (borel_space.measurable_eq.trans (borel_eq_generate_from_Ico Î±))\n      (is_pi_system_Ico id id) _ this _ _ _\n  Â· rintro _ âŸ¨l, -, u, -, h, rflâŸ©\n    exact âŸ¨l, u, h, rflâŸ©\n  Â· refine' sUnion_eq_univ_iff.2 fun x => _\n    rcases hsd.exists_le' hsb x with âŸ¨l, hls, hlxâŸ©\n    rcases hsd.exists_gt x with âŸ¨u, hus, hxuâŸ©\n    exact âŸ¨_, âŸ¨l, hls, u, hus, hlx.trans_lt hxu, rflâŸ©, hlx, hxuâŸ©\n  Â· rintro _ âŸ¨l, -, u, -, hlt, rflâŸ©\n    exact hÎ¼ hlt\n  Â· rintro _ âŸ¨l, u, hlt, rflâŸ©\n    exact h hlt\n#align ext_of_Ico' ext_of_Ico'\n\n",
 "ext_of_Ico":
 "/-- Two measures which are finite on closed-open intervals are equal if the agree on all\nclosed-open intervals. -/\ntheorem ext_of_Ico {Î± : Type _} [topological_space Î±] {m : measurable_space Î±} [second_countable_topology Î±]\n    [ConditionallyCompleteLinearOrder Î±] [order_topology Î±] [borel_space Î±] [NoMaxOrder Î±] (Î¼ Î½ : measure Î±)\n    [is_locally_finite_measure Î¼] (h : âˆ€ â¦ƒa bâ¦„, a < b â†’ Î¼ (Ico a b) = Î½ (Ico a b)) : Î¼ = Î½ :=\n  Î¼.ext_of_Ico' Î½ (fun a b hab => measure_Ico_lt_top.ne) h\n#align ext_of_Ico ext_of_Ico\n\n",
 "ext_of_Ici":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr áµ’áµˆÂ» -/\n/-- Two finite measures on a Borel space are equal if they agree on all left-closed right-infinite\nintervals. -/\ntheorem ext_of_Ici {Î± : Type _} [topological_space Î±] {m : measurable_space Î±} [second_countable_topology Î±]\n    [linear_order Î±] [order_topology Î±] [borel_space Î±] (Î¼ Î½ : measure Î±) [is_finite_measure Î¼]\n    (h : âˆ€ a, Î¼ (Ici a) = Î½ (Ici a)) : Î¼ = Î½ :=\n  @ext_of_Iic (Â«expr áµ’áµˆÂ» Î±) _ _ _ _ _ â€¹_â€º _ _ _ h\n#align ext_of_Ici ext_of_Ici\n\n",
 "ereal_to_real":
 "@[measurability]\ntheorem ae_measurable.ereal_to_real {f : Î± â†’ ereal} {Î¼ : measure Î±} (hf : ae_measurable f Î¼) :\n    ae_measurable (fun x => (f x).to_real) Î¼ :=\n  measurable_ereal_to_real.comp_ae_measurable hf\n#align ae_measurable.ereal_to_real ae_measurable.ereal_to_real\n\n",
 "ennreal_tsum'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ‘' , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ‘' , Â» -/\n@[measurability]\ntheorem measurable.ennreal_tsum' {Î¹} [countable Î¹] {f : Î¹ â†’ Î± â†’ ennreal} (h : âˆ€ i, measurable (f i)) :\n    measurable\n      (Â«exprâˆ‘' , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ‘' , Â»\" (f i)) :=\n  by\n  convert measurable.ennreal_tsum h\n  ext1 x\n  exact tsum_apply (pi.summable.2 fun _ => ennreal.summable)\n#align measurable.ennreal_tsum' measurable.ennreal_tsum'\n\n",
 "ennreal_tsum":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ‘' , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ‘' , Â» -/\n@[measurability]\ntheorem ae_measurable.ennreal_tsum {Î¹} [countable Î¹] {f : Î¹ â†’ Î± â†’ ennreal} {Î¼ : measure Î±}\n    (h : âˆ€ i, ae_measurable (f i) Î¼) :\n    ae_measurable\n      (fun x =>\n        Â«exprâˆ‘' , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ‘' , Â»\" (f i x))\n      Î¼ :=\n  by\n  simp_rw [ennreal.tsum_eq_supr_sum]\n  apply ae_measurable_supr\n  exact fun s => finset.ae_measurable_sum s fun i _ => h i\n#align ae_measurable.ennreal_tsum ae_measurable.ennreal_tsum\n\n",
 "ennreal_to_real":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n@[measurability]\ntheorem ae_measurable.ennreal_to_real {f : Î± â†’ ennreal} {Î¼ : measure Î±} (hf : ae_measurable f Î¼) :\n    ae_measurable (fun x => ennreal.to_real (f x)) Î¼ :=\n  ennreal.measurable_to_real.comp_ae_measurable hf\n#align ae_measurable.ennreal_to_real ae_measurable.ennreal_to_real\n\n",
 "ennreal_to_nnreal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n@[measurability]\ntheorem ae_measurable.ennreal_to_nnreal {f : Î± â†’ ennreal} {Î¼ : measure Î±} (hf : ae_measurable f Î¼) :\n    ae_measurable (fun x => (f x).to_nnreal) Î¼ :=\n  ennreal.measurable_to_nnreal.comp_ae_measurable hf\n#align ae_measurable.ennreal_to_nnreal ae_measurable.ennreal_to_nnreal\n\n",
 "ennreal_of_real":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n@[measurability]\ntheorem measurable.ennreal_of_real {f : Î± â†’ exprâ„} (hf : measurable f) : measurable fun x => ennreal.of_real (f x) :=\n  ennreal.continuous_of_real.measurable.comp hf\n#align measurable.ennreal_of_real measurable.ennreal_of_real\n\n",
 "ennnorm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–â‚ŠÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n@[measurability]\ntheorem ae_measurable.ennnorm {f : Î² â†’ Î±} {Î¼ : measure Î²} (hf : ae_measurable f Î¼) :\n    ae_measurable (fun a => (Â«exprâ€– â€–â‚ŠÂ» (f a) : ennreal)) Î¼ :=\n  measurable_ennnorm.comp_ae_measurable hf\n#align ae_measurable.ennnorm ae_measurable.ennnorm\n\n",
 "edist":
 "@[measurability]\ntheorem ae_measurable.edist {f g : Î² â†’ Î±} {Î¼ : measure Î²} (hf : ae_measurable f Î¼) (hg : ae_measurable g Î¼) :\n    ae_measurable (fun a => edist (f a) (g a)) Î¼ :=\n  (@continuous_edist Î± _).ae_measurable2 hf hg\n#align ae_measurable.edist ae_measurable.edist\n\n",
 "dist":
 "@[measurability]\ntheorem measurable.dist {f g : Î² â†’ Î±} (hf : measurable f) (hg : measurable g) : measurable fun b => dist (f b) (g b) :=\n  (@continuous_dist Î± _).measurable2 hf hg\n#align measurable.dist measurable.dist\n\n",
 "coe_real_ereal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n@[measurability]\ntheorem ae_measurable.coe_real_ereal {f : Î± â†’ exprâ„} {Î¼ : measure Î±} (hf : ae_measurable f Î¼) :\n    ae_measurable (fun x => (f x : ereal)) Î¼ :=\n  measurable_coe_real_ereal.comp_ae_measurable hf\n#align ae_measurable.coe_real_ereal ae_measurable.coe_real_ereal\n\n",
 "coe_nnreal_real":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n@[measurability]\ntheorem ae_measurable.coe_nnreal_real {f : Î± â†’ nnreal} {Î¼ : measure Î±} (hf : ae_measurable f Î¼) :\n    ae_measurable (fun x => (f x : exprâ„)) Î¼ :=\n  measurable_coe_nnreal_real.comp_ae_measurable hf\n#align ae_measurable.coe_nnreal_real ae_measurable.coe_nnreal_real\n\n",
 "coe_nnreal_ennreal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n@[measurability]\ntheorem ae_measurable.coe_nnreal_ennreal {f : Î± â†’ nnreal} {Î¼ : measure Î±} (hf : ae_measurable f Î¼) :\n    ae_measurable (fun x => (f x : ennreal)) Î¼ :=\n  ennreal.continuous_coe.measurable.comp_ae_measurable hf\n#align ae_measurable.coe_nnreal_ennreal ae_measurable.coe_nnreal_ennreal\n\n",
 "coe_ereal_ennreal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n@[measurability]\ntheorem ae_measurable.coe_ereal_ennreal {f : Î± â†’ ennreal} {Î¼ : measure Î±} (hf : ae_measurable f Î¼) :\n    ae_measurable (fun x => (f x : ereal)) Î¼ :=\n  measurable_coe_ennreal_ereal.comp_ae_measurable hf\n#align ae_measurable.coe_ereal_ennreal ae_measurable.coe_ereal_ennreal\n\n",
 "closure_ae_eq_of_null_frontier":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr =áµ[ ] Â» -/\ntheorem closure_ae_eq_of_null_frontier {Î¼ : measure Î±'} {s : set Î±'} (h : Î¼ (frontier s) = 0) :\n    Â«expr =áµ[ ] Â» (closure s) Î¼ s :=\n  ((ae_le_set.2 h).trans interior_subset.eventually_le).antisymm <| subset_closure.eventually_le\n#align closure_ae_eq_of_null_frontier closure_ae_eq_of_null_frontier\n\n",
 "borel_measurable":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\ntheorem continuous.borel_measurable [topological_space Î±] [topological_space Î²] {f : Î± â†’ Î²} (hf : continuous f) :\n    @measurable Î± Î² (borel Î±) (borel Î²) f :=\n  measurable.of_le_map <| generate_from_le fun s hs => generate_measurable.basic (Â«expr â»Â¹' Â» f s) (hs.preimage hf)\n#align continuous.borel_measurable continuous.borel_measurable\n\n",
 "borel_eq_top_of_discrete":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\n/-\nCopyright (c) 2017 Johannes HÃ¶lzl. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johannes HÃ¶lzl, Yury Kudryashov\n-/\ntheorem borel_eq_top_of_discrete [topological_space Î±] [discrete_topology Î±] : borel Î± = Â«exprâŠ¤Â» :=\n  top_le_iff.1 fun s hs => generate_measurable.basic s (is_open_discrete s)\n#align borel_eq_top_of_discrete borel_eq_top_of_discrete\n\n",
 "borel_eq_top_of_countable":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\ntheorem borel_eq_top_of_countable [topological_space Î±] [t1_space Î±] [countable Î±] : borel Î± = Â«exprâŠ¤Â» :=\n  by\n  refine' top_le_iff.1 fun s hs => bUnion_of_singleton s â–¸ _\n  apply measurable_set.bUnion s.to_countable\n  intro x hx\n  apply measurable_set.of_compl\n  apply generate_measurable.basic\n  exact is_closed_singleton.is_open_compl\n#align borel_eq_top_of_countable borel_eq_top_of_countable\n\n",
 "borel_eq_generate_from_of_subbasis":
 "theorem borel_eq_generate_from_of_subbasis {s : set (set Î±)} [t : topological_space Î±] [second_countable_topology Î±]\n    (hs : t = generate_from s) : borel Î± = generate_from s :=\n  le_antisymm\n    (generate_from_le fun u (hu : t.is_open u) => by\n      rw [hs] at hu\n      induction hu\n      case basic u hu => exact generate_measurable.basic u hu\n      case univ => exact @measurable_set.univ Î± (generate_from s)\n      case inter sâ‚ sâ‚‚ _ _ hsâ‚ hsâ‚‚ => exact @measurable_set.inter Î± (generate_from s) _ _ hsâ‚ hsâ‚‚\n      case sUnion f hf ih =>\n        rcases is_open_sUnion_countable f (by rwa [hs]) with âŸ¨v, hv, vf, vuâŸ©\n        rw [â† vu]\n        exact @measurable_set.sUnion Î± (generate_from s) _ hv fun x xv => ih _ (vf xv))\n    (generate_from_le fun u hu =>\n      generate_measurable.basic _ <| show t.is_open u by rw [hs] <;> exact generate_open.basic _ hu)\n#align borel_eq_generate_from_of_subbasis borel_eq_generate_from_of_subbasis\n\n",
 "borel_eq_generate_from_is_closed":
 "theorem borel_eq_generate_from_is_closed [topological_space Î±] : borel Î± = generate_from { s | is_closed s } :=\n  le_antisymm\n    (generate_from_le fun t ht =>\n      @measurable_set.of_compl Î± _ (generate_from { s | is_closed s })\n        (generate_measurable.basic _ <| is_closed_compl_iff.2 ht))\n    (generate_from_le fun t ht =>\n      @measurable_set.of_compl Î± _ (borel Î±) (generate_measurable.basic _ <| is_open_compl_iff.2 ht))\n#align borel_eq_generate_from_is_closed borel_eq_generate_from_is_closed\n\n",
 "borel_eq_generate_from_Ioo_rat":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â» -/\ntheorem borel_eq_generate_from_Ioo_rat :\n    borel (exprâ„) =\n      generate_from\n        (Â«exprâ‹ƒ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â»\" {Ioo a b}) :=\n  is_topological_basis_Ioo_rat.borel_eq_generate_from\n#align borel_eq_generate_from_Ioo_rat borel_eq_generate_from_Ioo_rat\n\n",
 "borel_eq_generate_from_Ioi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr áµ’áµˆÂ» -/\ntheorem borel_eq_generate_from_Ioi : borel Î± = generate_from (range Ioi) :=\n  @borel_eq_generate_from_Iio (Â«expr áµ’áµˆÂ» Î±) _ (by infer_instance : second_countable_topology Î±) _ _\n#align borel_eq_generate_from_Ioi borel_eq_generate_from_Ioi\n\n",
 "borel_eq_generate_from_Ioc_mem_aux":
 "theorem dense.borel_eq_generate_from_Ioc_mem_aux {Î± : Type _} [topological_space Î±] [linear_order Î±] [order_topology Î±]\n    [second_countable_topology Î±] {s : set Î±} (hd : dense s) (hbot : âˆ€ x, is_top x â†’ x âˆˆ s)\n    (hIoo : âˆ€ x y : Î±, x < y â†’ Ioo x y = âˆ… â†’ x âˆˆ s) :\n    borel Î± = generate_from { S : set Î± | âˆƒ l âˆˆ s, âˆƒ u âˆˆ s, âˆƒ h : l < u, Ioc l u = S } :=\n  by\n  convert hd.order_dual.borel_eq_generate_from_Ico_mem_aux hbot fun x y hlt he => hIoo y x hlt _\n  Â· ext s\n    constructor <;> rintro âŸ¨l, hl, u, hu, hlt, rflâŸ©\n    exacts[âŸ¨u, hu, l, hl, hlt, dual_IcoâŸ©, âŸ¨u, hu, l, hl, hlt, dual_IocâŸ©]\n  Â· erw [dual_Ioo]\n    exact he\n#align dense.borel_eq_generate_from_Ioc_mem_aux dense.borel_eq_generate_from_Ioc_mem_aux\n\n",
 "borel_eq_generate_from_Ioc_mem":
 "theorem dense.borel_eq_generate_from_Ioc_mem {Î± : Type _} [topological_space Î±] [linear_order Î±] [order_topology Î±]\n    [second_countable_topology Î±] [DenselyOrdered Î±] [NoMaxOrder Î±] {s : set Î±} (hd : dense s) :\n    borel Î± = generate_from { S : set Î± | âˆƒ l âˆˆ s, âˆƒ u âˆˆ s, âˆƒ h : l < u, Ioc l u = S } :=\n  hd.borel_eq_generate_from_Ioc_mem_aux (by simp) fun x y hxy H => ((nonempty_Ioo.2 hxy).ne_empty H).elim\n#align dense.borel_eq_generate_from_Ioc_mem dense.borel_eq_generate_from_Ioc_mem\n\n",
 "borel_eq_generate_from_Ioc":
 "theorem borel_eq_generate_from_Ioc (Î± : Type _) [topological_space Î±] [second_countable_topology Î±] [linear_order Î±]\n    [order_topology Î±] : borel Î± = generate_from { S : set Î± | âˆƒ (l u : _)(h : l < u), Ioc l u = S } := by\n  simpa only [exists_prop, mem_univ, true_and_iff] using\n    (@dense_univ Î± _).borel_eq_generate_from_Ioc_mem_aux (fun _ _ => mem_univ _) fun _ _ _ _ => mem_univ _\n#align borel_eq_generate_from_Ioc borel_eq_generate_from_Ioc\n\n",
 "borel_eq_generate_from_Iio_rat":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á¶œÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„š -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„š -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â» -/\ntheorem borel_eq_generate_from_Iio_rat :\n    borel (exprâ„) =\n      generate_from\n        (Â«exprâ‹ƒ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â»\" {Iio a}) :=\n  by\n  let g : measurable_space (exprâ„) :=\n    generate_from\n      (Â«exprâ‹ƒ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â»\" {Iio a})\n  refine' le_antisymm _ _\n  Â· rw [borel_eq_generate_from_Ioo_rat]\n    refine' generate_from_le fun t => _\n    simp only [mem_Union, mem_singleton_iff]\n    rintro âŸ¨a, b, h, rflâŸ©\n    rw [(Set.ext fun x => _ :\n        Ioo (a : exprâ„) b =\n          Â«exprâ‹ƒ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â»\"\n              (Â«expr á¶œÂ» (Iio c)) âˆ©\n            Iio b)]\n    Â· have hg : âˆ€ q : exprâ„š, (measurable_set_of g) (Iio q) := fun q => generate_measurable.basic (Iio q) (by simp)\n      refine' @measurable_set.inter _ g _ _ _ (hg _)\n      refine' @measurable_set.bUnion _ _ g _ _ (to_countable _) fun c h => _\n      exact @measurable_set.compl _ _ g (hg _)\n    Â· suffices x < â†‘b â†’ (â†‘a < x â†” âˆƒ i : exprâ„š, a < i âˆ§ â†‘i â‰¤ x) by simpa\n      refine' fun _ => âŸ¨fun h => _, fun âŸ¨i, hai, hixâŸ© => (Rat.cast_lt.2 hai).trans_le hixâŸ©\n      rcases exists_rat_btwn h with âŸ¨c, ac, cxâŸ©\n      exact âŸ¨c, Rat.cast_lt.1 ac, cx.leâŸ©\n  Â· refine' measurable_space.generate_from_le fun _ => _\n    simp only [mem_Union, mem_singleton_iff]\n    rintro âŸ¨r, rflâŸ©\n    exact measurable_set_Iio\n#align borel_eq_generate_from_Iio_rat borel_eq_generate_from_Iio_rat\n\n",
 "borel_eq_generate_from_Iio":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á¶œÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á¶œÂ» -/\ntheorem borel_eq_generate_from_Iio : borel Î± = generate_from (range Iio) :=\n  by\n  refine' le_antisymm _ (generate_from_le _)\n  Â· rw [borel_eq_generate_from_of_subbasis (@order_topology.topology_eq_generate_intervals Î± _ _ _)]\n    letI : measurable_space Î± := measurable_space.generate_from (range Iio)\n    have H : âˆ€ a : Î±, measurable_set (Iio a) := fun a => generate_measurable.basic _ âŸ¨_, rflâŸ©\n    refine' generate_from_le _\n    rintro _ âŸ¨a, rfl | rflâŸ© <;> [skip, apply H]\n    by_cases h : âˆƒ a', âˆ€ b, a < b â†” a' â‰¤ b\n    Â· rcases h with âŸ¨a', ha'âŸ©\n      rw [(_ : Ioi a = Â«expr á¶œÂ» (Iio a'))]\n      Â· exact (H _).compl\n      simp [Set.ext_iff, ha']\n    Â· rcases is_open_Union_countable (fun a' : { a' : Î± // a < a' } => { b | a'.1 < b }) fun a' => is_open_lt' _ with\n        âŸ¨v, âŸ¨hvâŸ©, vuâŸ©\n      simp [Set.ext_iff] at vu\n      have :\n        Ioi a =\n          Â«exprâ‹ƒ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â»\"\n            (Â«expr á¶œÂ» (Iio x.1.1)) :=\n        by\n        simp [Set.ext_iff]\n        refine' fun x => âŸ¨fun ax => _, fun âŸ¨a', âŸ¨h, avâŸ©, axâŸ© => lt_of_lt_of_le h axâŸ©\n        rcases(vu x).2 _ with âŸ¨a', hâ‚, hâ‚‚âŸ©\n        Â· exact âŸ¨a', hâ‚, le_of_lt hâ‚‚âŸ©\n        refine' not_imp_comm.1 (fun h => _) h\n        exact âŸ¨x, fun b => âŸ¨fun ab => le_of_not_lt fun h' => h âŸ¨b, ab, h'âŸ©, lt_of_lt_of_le axâŸ©âŸ©\n      rw [this]\n      skip\n      apply measurable_set.Union\n      exact fun _ => (H _).compl\n  Â· rw [forall_range_iff]\n    intro a\n    exact generate_measurable.basic _ is_open_Iio\n#align borel_eq_generate_from_Iio borel_eq_generate_from_Iio\n\n",
 "borel_eq_generate_from_Ico_mem_aux":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â» -/\ntheorem dense.borel_eq_generate_from_Ico_mem_aux {Î± : Type _} [topological_space Î±] [linear_order Î±] [order_topology Î±]\n    [second_countable_topology Î±] {s : set Î±} (hd : dense s) (hbot : âˆ€ x, is_bot x â†’ x âˆˆ s)\n    (hIoo : âˆ€ x y : Î±, x < y â†’ Ioo x y = âˆ… â†’ y âˆˆ s) :\n    borel Î± = generate_from { S : set Î± | âˆƒ l âˆˆ s, âˆƒ u âˆˆ s, âˆƒ h : l < u, Ico l u = S } :=\n  by\n  set S : set (set Î±) := { S | âˆƒ l âˆˆ s, âˆƒ u âˆˆ s, âˆƒ h : l < u, Ico l u = S }\n  refine' le_antisymm _ (generate_from_Ico_mem_le_borel _ _)\n  letI : measurable_space Î± := generate_from S\n  rw [borel_eq_generate_from_Iio]\n  refine' generate_from_le (forall_range_iff.2 fun a => _)\n  rcases hd.exists_countable_dense_subset_bot_top with âŸ¨t, hts, hc, htd, htb, httâŸ©\n  by_cases ha : âˆ€ b < a, (Ioo b a).nonempty\n  Â· convert_to\n      measurable_set\n        (Â«exprâ‹ƒ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â»\" (Ico l u))\n    Â· ext y\n      simp only [mem_Union, mem_Iio, mem_Ico]\n      constructor\n      Â· intro hy\n        rcases htd.exists_le' (fun b hb => htb _ hb (hbot b hb)) y with âŸ¨l, hlt, hlyâŸ©\n        rcases htd.exists_mem_open is_open_Ioo (ha y hy) with âŸ¨u, hut, hyu, huaâŸ©\n        exact âŸ¨l, hlt, u, hut, hly.trans_lt hyu, hua.le, hly, hyuâŸ©\n      Â· rintro âŸ¨l, -, u, -, -, hua, -, hyuâŸ©\n        exact hyu.trans_le hua\n    Â· refine' measurable_set.bUnion hc fun a ha => measurable_set.bUnion hc fun b hb => _\n      refine' measurable_set.Union fun hab => measurable_set.Union fun hb' => _\n      exact generate_measurable.basic _ âŸ¨a, hts ha, b, hts hb, hab, mem_singleton _âŸ©\n  Â· simp only [not_forall, not_nonempty_iff_eq_empty] at ha\n    replace ha : a âˆˆ s := hIoo ha.some a ha.some_spec.fst ha.some_spec.snd\n    convert_to\n      measurable_set\n        (Â«exprâ‹ƒ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â»\" (Ico l a))\n    Â· symm\n      simp only [â† Ici_inter_Iio, â† Union_inter, inter_eq_right_iff_subset, subset_def, mem_Union, mem_Ici, mem_Iio]\n      intro x hx\n      rcases htd.exists_le' (fun b hb => htb _ hb (hbot b hb)) x with âŸ¨z, hzt, hzxâŸ©\n      exact âŸ¨z, hzt, hzx.trans_lt hx, hzxâŸ©\n    Â· refine' measurable_set.bUnion hc fun x hx => measurable_set.Union fun hlt => _\n      exact generate_measurable.basic _ âŸ¨x, hts hx, a, ha, hlt, mem_singleton _âŸ©\n#align dense.borel_eq_generate_from_Ico_mem_aux dense.borel_eq_generate_from_Ico_mem_aux\n\n",
 "borel_eq_generate_from_Ico_mem":
 "theorem dense.borel_eq_generate_from_Ico_mem {Î± : Type _} [topological_space Î±] [linear_order Î±] [order_topology Î±]\n    [second_countable_topology Î±] [DenselyOrdered Î±] [NoMinOrder Î±] {s : set Î±} (hd : dense s) :\n    borel Î± = generate_from { S : set Î± | âˆƒ l âˆˆ s, âˆƒ u âˆˆ s, âˆƒ h : l < u, Ico l u = S } :=\n  hd.borel_eq_generate_from_Ico_mem_aux (by simp) fun x y hxy H => ((nonempty_Ioo.2 hxy).ne_empty H).elim\n#align dense.borel_eq_generate_from_Ico_mem dense.borel_eq_generate_from_Ico_mem\n\n",
 "borel_eq_generate_from_Ico":
 "theorem borel_eq_generate_from_Ico (Î± : Type _) [topological_space Î±] [second_countable_topology Î±] [linear_order Î±]\n    [order_topology Î±] : borel Î± = generate_from { S : set Î± | âˆƒ (l u : _)(h : l < u), Ico l u = S } := by\n  simpa only [exists_prop, mem_univ, true_and_iff] using\n    (@dense_univ Î± _).borel_eq_generate_from_Ico_mem_aux (fun _ _ => mem_univ _) fun _ _ _ _ => mem_univ _\n#align borel_eq_generate_from_Ico borel_eq_generate_from_Ico\n\n",
 "borel_eq_generate_from":
 "theorem topological_space.is_topological_basis.borel_eq_generate_from [topological_space Î±]\n    [second_countable_topology Î±] {s : set (set Î±)} (hs : is_topological_basis s) : borel Î± = generate_from s :=\n  borel_eq_generate_from_of_subbasis hs.eq_generate_from\n#align\n  topological_space.is_topological_basis.borel_eq_generate_from topological_space.is_topological_basis.borel_eq_generate_from\n\n",
 "borel_comap":
 "theorem borel_comap {f : Î± â†’ Î²} {t : topological_space Î²} : @borel Î± (t.induced f) = (@borel Î² t).comap f :=\n  comap_generate_from.symm\n#align borel_comap borel_comap\n\n",
 "apply_continuous_linear_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n@[measurability]\ntheorem ae_measurable.apply_continuous_linear_map {Ï† : Î± â†’ Â«expr â†’L[ ] Â» F ğ•œ E} {Î¼ : measure Î±} (hÏ† : ae_measurable Ï† Î¼)\n    (v : F) : ae_measurable (fun a => Ï† a v) Î¼ :=\n  (continuous_linear_map.apply ğ•œ E v).measurable.comp_ae_measurable hÏ†\n#align ae_measurable.apply_continuous_linear_map ae_measurable.apply_continuous_linear_map\n\n",
 "ae_measurable_supr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ¨† , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨† , Â» -/\n@[measurability]\ntheorem ae_measurable_supr {Î¹} {Î¼ : measure Î´} [countable Î¹] {f : Î¹ â†’ Î´ â†’ Î±} (hf : âˆ€ i, ae_measurable (f i) Î¼) :\n    ae_measurable\n      (fun b => Â«exprâ¨† , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨† , Â»\" (f i b))\n      Î¼ :=\n  ae_measurable.is_lub hf <| ae_of_all Î¼ fun b => isLUB_supáµ¢\n#align ae_measurable_supr ae_measurable_supr\n\n",
 "ae_measurable_smul_const":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\ntheorem ae_measurable_smul_const {f : Î± â†’ ğ•œ} {Î¼ : measure Î±} {c : E} (hc : c â‰  0) :\n    ae_measurable (fun x => Â«expr â€¢ Â» (f x) c) Î¼ â†” ae_measurable f Î¼ :=\n  (closed_embedding_smul_left hc).measurable_embedding.ae_measurable_comp_iff\n#align ae_measurable_smul_const ae_measurable_smul_const\n\n",
 "ae_measurable_restrict_of_monotone_on":
 "theorem ae_measurable_restrict_of_monotone_on [linear_order Î²] [order_closed_topology Î²] {Î¼ : measure Î²} {s : set Î²}\n    (hs : measurable_set s) {f : Î² â†’ Î±} (hf : monotone_on f s) : ae_measurable f (Î¼.restrict s) :=\n  have this : monotone (f âˆ˜ coe : s â†’ Î±) := fun âŸ¨x, hxâŸ© âŸ¨y, hyâŸ© (hxy : x â‰¤ y) => hf hx hy hxy\n  ae_measurable_restrict_of_measurable_subtype hs this.measurable\n#align ae_measurable_restrict_of_monotone_on ae_measurable_restrict_of_monotone_on\n\n",
 "ae_measurable_restrict_of_antitone_on":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr áµ’áµˆÂ» -/\ntheorem ae_measurable_restrict_of_antitone_on [linear_order Î²] [order_closed_topology Î²] {Î¼ : measure Î²} {s : set Î²}\n    (hs : measurable_set s) {f : Î² â†’ Î±} (hf : antitone_on f s) : ae_measurable f (Î¼.restrict s) :=\n  @ae_measurable_restrict_of_monotone_on (Â«expr áµ’áµˆÂ» Î±) Î² _ _ â€¹_â€º _ _ _ _ _ â€¹_â€º _ _ _ _ hs _ hf\n#align ae_measurable_restrict_of_antitone_on ae_measurable_restrict_of_antitone_on\n\n",
 "ae_measurable_of_unif_approx":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€áµ âˆ‚ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€áµ âˆ‚ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€áµ âˆ‚ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€áµ âˆ‚ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€áµ âˆ‚ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€áµ âˆ‚ , Â» -/\ntheorem ae_measurable_of_unif_approx {Î²} [measurable_space Î²] [pseudo_metric_space Î²] [borel_space Î²] {Î¼ : measure Î±}\n    {g : Î± â†’ Î²}\n    (hf :\n      âˆ€ Îµ > (0 : exprâ„),\n        âˆƒ f : Î± â†’ Î²,\n          ae_measurable f Î¼ âˆ§\n            Â«exprâˆ€áµ âˆ‚ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€áµ âˆ‚ , Â»\" Î¼\n              (dist (f x) (g x) â‰¤ Îµ)) :\n    ae_measurable g Î¼ :=\n  by\n  obtain âŸ¨u, u_anti, u_pos, u_limâŸ© :\n    âˆƒ u : â„• â†’ exprâ„, strict_anti u âˆ§ (âˆ€ n : â„•, 0 < u n) âˆ§ tendsto u at_top ((nhds) 0) :=\n    exists_seq_strict_anti_tendsto (0 : exprâ„)\n  choose f Hf using fun n : â„• => hf (u n) (u_pos n)\n  have :\n    Â«exprâˆ€áµ âˆ‚ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€áµ âˆ‚ , Â»\" Î¼\n      (tendsto (fun n => f n x) at_top ((nhds) (g x))) :=\n    by\n    have :\n      Â«exprâˆ€áµ âˆ‚ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€áµ âˆ‚ , Â»\" Î¼\n        (âˆ€ n, dist (f n x) (g x) â‰¤ u n) :=\n      ae_all_iff.2 fun n => (Hf n).2\n    filter_upwards [this]\n    intro x hx\n    rw [tendsto_iff_dist_tendsto_zero]\n    exact squeeze_zero (fun n => dist_nonneg) hx u_lim\n  exact ae_measurable_of_tendsto_metrizable_ae' (fun n => (Hf n).1) this\n#align ae_measurable_of_unif_approx ae_measurable_of_unif_approx\n\n",
 "ae_measurable_of_tendsto_metrizable_ae'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€áµ âˆ‚ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€áµ âˆ‚ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem ae_measurable_of_tendsto_metrizable_ae' {Î¼ : measure Î±} {f : â„• â†’ Î± â†’ Î²} {g : Î± â†’ Î²}\n    (hf : âˆ€ n, ae_measurable (f n) Î¼)\n    (h_ae_tendsto :\n      Â«exprâˆ€áµ âˆ‚ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€áµ âˆ‚ , Â»\" Î¼\n        (tendsto (fun n => f n x) at_top ((nhds) (g x)))) :\n    ae_measurable g Î¼ :=\n  ae_measurable_of_tendsto_metrizable_ae at_top hf h_ae_tendsto\n#align ae_measurable_of_tendsto_metrizable_ae' ae_measurable_of_tendsto_metrizable_ae'\n\n",
 "ae_measurable_of_tendsto_metrizable_ae":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€áµ âˆ‚ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€áµ âˆ‚ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€áµ âˆ‚ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€áµ âˆ‚ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem ae_measurable_of_tendsto_metrizable_ae {Î¹} {Î¼ : measure Î±} {f : Î¹ â†’ Î± â†’ Î²} {g : Î± â†’ Î²} (u : filter Î¹)\n    [hu : ne_bot u] [is_countably_generated u] (hf : âˆ€ n, ae_measurable (f n) Î¼)\n    (h_tendsto :\n      Â«exprâˆ€áµ âˆ‚ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€áµ âˆ‚ , Â»\" Î¼\n        (tendsto (fun n => f n x) u ((nhds) (g x)))) :\n    ae_measurable g Î¼ := by\n  rcases u.exists_seq_tendsto with âŸ¨v, hvâŸ©\n  have h'f : âˆ€ n, ae_measurable (f (v n)) Î¼ := fun n => hf (v n)\n  set p : Î± â†’ (â„• â†’ Î²) â†’ Prop := fun x f' => tendsto (fun n => f' n) at_top ((nhds) (g x))\n  have hp :\n    Â«exprâˆ€áµ âˆ‚ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€áµ âˆ‚ , Â»\" Î¼\n      (p x fun n => f (v n) x) :=\n    by filter_upwards [h_tendsto] with x hx using hx.comp hv\n  set ae_seq_lim := fun x => ite (x âˆˆ ae_seq_set h'f p) (g x) (âŸ¨f (v 0) xâŸ© : nonempty Î²).some with hs\n  refine'\n    âŸ¨ae_seq_lim, measurable_of_tendsto_metrizable' at_top (ae_seq.measurable h'f p) (tendsto_pi_nhds.mpr fun x => _), _âŸ©\n  Â· simp_rw [ae_seq, ae_seq_lim]\n    split_ifs with hx\n    Â· simp_rw [ae_seq.mk_eq_fun_of_mem_ae_seq_set h'f hx]\n      exact @ae_seq.fun_prop_of_mem_ae_seq_set _ Î± Î² _ _ _ _ _ h'f x hx\n    Â· exact tendsto_const_nhds\n  Â·\n    exact\n      (ite_ae_eq_of_measure_compl_zero g (fun x => (âŸ¨f (v 0) xâŸ© : nonempty Î²).some) (ae_seq_set h'f p)\n          (ae_seq.measure_compl_ae_seq_set_eq_zero h'f hp)).symm\n#align ae_measurable_of_tendsto_metrizable_ae ae_measurable_of_tendsto_metrizable_ae\n\n",
 "ae_measurable_infi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ¨… , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨… , Â» -/\n@[measurability]\ntheorem ae_measurable_infi {Î¹} {Î¼ : measure Î´} [countable Î¹] {f : Î¹ â†’ Î´ â†’ Î±} (hf : âˆ€ i, ae_measurable (f i) Î¼) :\n    ae_measurable\n      (fun b => Â«exprâ¨… , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨… , Â»\" (f i b))\n      Î¼ :=\n  ae_measurable.is_glb hf <| ae_of_all Î¼ fun b => isGLB_infáµ¢\n#align ae_measurable_infi ae_measurable_infi\n\n",
 "ae_measurable_coe_nnreal_real_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n@[simp, norm_cast]\ntheorem ae_measurable_coe_nnreal_real_iff {f : Î± â†’ nnreal} {Î¼ : measure Î±} :\n    ae_measurable (fun x => f x : Î± â†’ exprâ„) Î¼ â†” ae_measurable f Î¼ :=\n  âŸ¨fun h => by simpa only [real.to_nnreal_coe] using h.real_to_nnreal, ae_measurable.coe_nnreal_realâŸ©\n#align ae_measurable_coe_nnreal_real_iff ae_measurable_coe_nnreal_real_iff\n\n",
 "ae_measurable_coe_nnreal_ennreal_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n@[simp, norm_cast]\ntheorem ae_measurable_coe_nnreal_ennreal_iff {f : Î± â†’ nnreal} {Î¼ : measure Î±} :\n    ae_measurable (fun x => (f x : ennreal)) Î¼ â†” ae_measurable f Î¼ :=\n  âŸ¨fun h => h.ennreal_to_nnreal, fun h => h.coe_nnreal_ennrealâŸ©\n#align ae_measurable_coe_nnreal_ennreal_iff ae_measurable_coe_nnreal_ennreal_iff\n\n",
 "ae_measurable_bsupr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ¨† , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨† , Â» -/\ntheorem ae_measurable_bsupr {Î¹} {Î¼ : measure Î´} (s : set Î¹) {f : Î¹ â†’ Î´ â†’ Î±} (hs : s.countable)\n    (hf : âˆ€ i, ae_measurable (f i) Î¼) :\n    ae_measurable\n      (fun b => Â«exprâ¨† , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨† , Â»\" (f i b))\n      Î¼ :=\n  by\n  haveI : Encodable s := hs.to_encodable\n  simp only [supáµ¢_subtype']\n  exact ae_measurable_supr fun i => hf i\n#align ae_measurable_bsupr ae_measurable_bsupr\n\n",
 "ae_measurable_binfi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ¨… , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨… , Â» -/\ntheorem ae_measurable_binfi {Î¹} {Î¼ : measure Î´} (s : set Î¹) {f : Î¹ â†’ Î´ â†’ Î±} (hs : s.countable)\n    (hf : âˆ€ i, ae_measurable (f i) Î¼) :\n    ae_measurable\n      (fun b => Â«exprâ¨… , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨… , Â»\" (f i b))\n      Î¼ :=\n  by\n  haveI : Encodable s := hs.to_encodable\n  simp only [infáµ¢_subtype']\n  exact ae_measurable_infi fun i => hf i\n#align ae_measurable_binfi ae_measurable_binfi\n\n",
 "ae_measurable2":
 "theorem continuous.ae_measurable2 [second_countable_topology Î±] [second_countable_topology Î²] {f : Î´ â†’ Î±} {g : Î´ â†’ Î²}\n    {c : Î± â†’ Î² â†’ Î³} {Î¼ : measure Î´} (h : continuous fun p : Î± Ã— Î² => c p.1 p.2) (hf : ae_measurable f Î¼)\n    (hg : ae_measurable g Î¼) : ae_measurable (fun a => c (f a) (g a)) Î¼ :=\n  h.measurable.comp_ae_measurable (hf.prod_mk hg)\n#align continuous.ae_measurable2 continuous.ae_measurable2\n\n",
 "ae_measurable":
 "/-- A continuous function from an `opens_measurable_space` to a `borel_space`\nis ae-measurable. -/\ntheorem continuous.ae_measurable {f : Î± â†’ Î³} (h : continuous f) {Î¼ : measure Î±} : ae_measurable f Î¼ :=\n  h.measurable.ae_measurable\n#align continuous.ae_measurable continuous.ae_measurable\n\n"}