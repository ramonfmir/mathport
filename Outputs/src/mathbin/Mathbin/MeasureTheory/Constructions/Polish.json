{"second_countable_of_polish":
 "--Note: Move to topology/metric_space/polish when porting. \n/-Note: This is to avoid a loop in TC inference. When ported to Lean 4, this will not\nbe necessary, and `second_countable_of_polish` should probably\njust be added as an instance soon after the definition of `polish_space`.-/\nprivate theorem second_countable_of_polish [h : PolishSpace α] : SecondCountableTopology α :=\n  h.second_countable\n#align second_countable_of_polish second_countable_of_polish\n\n",
 "measurably_separable_range_of_disjoint":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/-- The hard part of the Lusin separation theorem saying that two disjoint analytic sets are\ncontained in disjoint Borel sets (see the full statement in `analytic_set.measurably_separable`).\nHere, we prove this when our analytic sets are the ranges of functions from `ℕ → ℕ`.\n-/\ntheorem measurably_separable_range_of_disjoint [T2Space α] [MeasurableSpace α] [borel_space α] {f g : (ℕ → ℕ) → α}\n    (hf : Continuous f) (hg : Continuous g) (h : Disjoint (range f) (range g)) :\n    measurably_separable (range f) (range g) :=\n  by\n  /- We follow [Kechris, *Classical Descriptive Set Theory* (Theorem 14.7)][kechris1995].\n    If the ranges are not Borel-separated, then one can find two cylinders of length one whose images\n    are not Borel-separated, and then two smaller cylinders of length two whose images are not\n    Borel-separated, and so on. One thus gets two sequences of cylinders, that decrease to two\n    points `x` and `y`. Their images are different by the disjointness assumption, hence contained\n    in two disjoint open sets by the T2 property. By continuity, long enough cylinders around `x`\n    and `y` have images which are separated by these two disjoint open sets, a contradiction.\n    -/\n  by_contra hfg\n  have I :\n    ∀ n x y,\n      ¬measurably_separable («expr '' » f (cylinder x n)) («expr '' » g (cylinder y n)) →\n        ∃ x' y',\n          x' ∈ cylinder x n ∧\n            y' ∈ cylinder y n ∧\n              ¬measurably_separable («expr '' » f (cylinder x' (n + 1))) («expr '' » g (cylinder y' (n + 1))) :=\n    by\n    intro n x y\n    contrapose!\n    intro H\n    rw [← Union_cylinder_update x n, ← Union_cylinder_update y n, image_Union, image_Union]\n    refine' measurably_separable.Union fun i j => _\n    exact H _ _ (update_mem_cylinder _ _ _) (update_mem_cylinder _ _ _)\n  -- consider the set of pairs of cylinders of some length whose images are not Borel-separated\n  let A :=\n    { p : ℕ × (ℕ → ℕ) × (ℕ → ℕ) //\n      ¬measurably_separable («expr '' » f (cylinder p.2.1 p.1)) («expr '' » g (cylinder p.2.2 p.1)) }\n  -- for each such pair, one can find longer cylinders whose images are not Borel-separated either\n  have : ∀ p : A, ∃ q : A, q.1.1 = p.1.1 + 1 ∧ q.1.2.1 ∈ cylinder p.1.2.1 p.1.1 ∧ q.1.2.2 ∈ cylinder p.1.2.2 p.1.1 :=\n    by\n    rintro ⟨⟨n, x, y⟩, hp⟩\n    rcases I n x y hp with ⟨x', y', hx', hy', h'⟩\n    exact ⟨⟨⟨n + 1, x', y'⟩, h'⟩, rfl, hx', hy'⟩\n  choose F hFn hFx hFy using this\n  let p0 : A := ⟨⟨0, fun n => 0, fun n => 0⟩, by simp [hfg]⟩\n  -- construct inductively decreasing sequences of cylinders whose images are not separated\n  let p : ℕ → A := fun n => («expr ^[ ]» F n) p0\n  have prec : ∀ n, p (n + 1) = F (p n) := fun n => by simp only [p, iterate_succ']\n  -- check that at the `n`-th step we deal with cylinders of length `n`\n  have pn_fst : ∀ n, (p n).1.1 = n := by\n    intro n\n    induction' n with n IH\n    · rfl\n    · simp only [prec, hFn, IH]\n  -- check that the cylinders we construct are indeed decreasing, by checking that the coordinates\n  -- are stationary.\n  have Ix : ∀ m n, m + 1 ≤ n → (p n).1.2.1 m = (p (m + 1)).1.2.1 m :=\n    by\n    intro m\n    apply Nat.le_induction\n    · rfl\n    intro n hmn IH\n    have I : (F (p n)).val.snd.fst m = (p n).val.snd.fst m :=\n      by\n      apply hFx (p n) m\n      rw [pn_fst]\n      exact hmn\n    rw [prec, I, IH]\n  have Iy : ∀ m n, m + 1 ≤ n → (p n).1.2.2 m = (p (m + 1)).1.2.2 m :=\n    by\n    intro m\n    apply Nat.le_induction\n    · rfl\n    intro n hmn IH\n    have I : (F (p n)).val.snd.snd m = (p n).val.snd.snd m :=\n      by\n      apply hFy (p n) m\n      rw [pn_fst]\n      exact hmn\n    rw [prec, I, IH]\n  -- denote by `x` and `y` the limit points of these two sequences of cylinders.\n  set x : ℕ → ℕ := fun n => (p (n + 1)).1.2.1 n with hx\n  set y : ℕ → ℕ := fun n => (p (n + 1)).1.2.2 n with hy\n  -- by design, the cylinders around these points have images which are not Borel-separable.\n  have M : ∀ n, ¬measurably_separable («expr '' » f (cylinder x n)) («expr '' » g (cylinder y n)) :=\n    by\n    intro n\n    convert(p n).2 using 3\n    · rw [pn_fst, ← mem_cylinder_iff_eq, mem_cylinder_iff]\n      intro i hi\n      rw [hx]\n      exact (Ix i n hi).symm\n    · rw [pn_fst, ← mem_cylinder_iff_eq, mem_cylinder_iff]\n      intro i hi\n      rw [hy]\n      exact (Iy i n hi).symm\n  -- consider two open sets separating `f x` and `g y`.\n  obtain ⟨u, v, u_open, v_open, xu, yv, huv⟩ : ∃ u v : Set α, IsOpen u ∧ IsOpen v ∧ f x ∈ u ∧ g y ∈ v ∧ Disjoint u v :=\n    by\n    apply t2_separation\n    exact disjoint_iff_forall_ne.1 h _ (mem_range_self _) _ (mem_range_self _)\n  letI : MetricSpace (ℕ → ℕ) := metric_space_nat_nat\n  obtain ⟨εx, εxpos, hεx⟩ : ∃ (εx : exprℝ)(H : εx > 0), Metric.ball x εx ⊆ «expr ⁻¹' » f u :=\n    by\n    apply Metric.mem_nhds_iff.1\n    exact hf.continuous_at.preimage_mem_nhds (u_open.mem_nhds xu)\n  obtain ⟨εy, εypos, hεy⟩ : ∃ (εy : exprℝ)(H : εy > 0), Metric.ball y εy ⊆ «expr ⁻¹' » g v :=\n    by\n    apply Metric.mem_nhds_iff.1\n    exact hg.continuous_at.preimage_mem_nhds (v_open.mem_nhds yv)\n  obtain ⟨n, hn⟩ : ∃ n : ℕ, (1 / 2 : exprℝ) ^ n < min εx εy :=\n    exists_pow_lt_of_lt_one (lt_min εxpos εypos) (by norm_num)\n  -- for large enough `n`, these open sets separate the images of long cylinders around `x` and `y`\n  have B : measurably_separable («expr '' » f (cylinder x n)) («expr '' » g (cylinder y n)) :=\n    by\n    refine' ⟨u, _, _, u_open.measurable_set⟩\n    · rw [image_subset_iff]\n      apply subset.trans _ hεx\n      intro z hz\n      rw [mem_cylinder_iff_dist_le] at hz\n      exact hz.trans_lt (hn.trans_le (min_le_left _ _))\n    · refine' Disjoint.mono_left _ huv.symm\n      change «expr '' » g (cylinder y n) ⊆ v\n      rw [image_subset_iff]\n      apply subset.trans _ hεy\n      intro z hz\n      rw [mem_cylinder_iff_dist_le] at hz\n      exact hz.trans_lt (hn.trans_le (min_le_right _ _))\n  -- this is a contradiction.\n  exact M n B\n#align measurably_separable_range_of_disjoint measurably_separable_range_of_disjoint\n\n",
 "measurably_separable":
 "/-- The Lusin separation theorem: if two analytic sets are disjoint, then they are contained in\ndisjoint Borel sets. -/\ntheorem analytic_set.measurably_separable [T2Space α] [MeasurableSpace α] [borel_space α] {s t : Set α}\n    (hs : analytic_set s) (ht : analytic_set t) (h : Disjoint s t) : measurably_separable s t :=\n  by\n  rw [analytic_set] at hs ht\n  rcases hs with (rfl | ⟨f, f_cont, rfl⟩)\n  · refine' ⟨∅, subset.refl _, by simp, MeasurableSet.empty⟩\n  rcases ht with (rfl | ⟨g, g_cont, rfl⟩)\n  · exact ⟨univ, subset_univ _, by simp, MeasurableSet.univ⟩\n  exact measurably_separable_range_of_disjoint f_cont g_cont h\n#align analytic_set.measurably_separable analytic_set.measurably_separable\n\n",
 "measurable_set_range_of_continuous_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/-- The Lusin-Souslin theorem: the range of a continuous injective function defined on a Polish\nspace is Borel-measurable. -/\ntheorem measurable_set_range_of_continuous_injective {β : Type _} [TopologicalSpace β] [T2Space β] [MeasurableSpace β]\n    [borel_space β] {f : γ → β} (f_cont : Continuous f) (f_inj : injective f) : MeasurableSet (range f) :=\n  by\n  /- We follow [Fremlin, *Measure Theory* (volume 4, 423I)][fremlin_vol4].\n    Let `b = {s i}` be a countable basis for `α`. When `s i` and `s j` are disjoint, their images are\n    disjoint analytic sets, hence by the separation theorem one can find a Borel-measurable set\n    `q i j` separating them.\n    Let `E i = closure (f '' s i) ∩ ⋂ j, q i j \\ q j i`. It contains `f '' (s i)` and it is\n    measurable. Let `F n = ⋃ E i`, where the union is taken over those `i` for which `diam (s i)`\n    is bounded by some number `u n` tending to `0` with `n`.\n    We claim that `range f = ⋂ F n`, from which the measurability is obvious. The inclusion `⊆` is\n    straightforward. To show `⊇`, consider a point `x` in the intersection. For each `n`, it belongs\n    to some `E i` with `diam (s i) ≤ u n`. Pick a point `y i ∈ s i`. We claim that for such `i`\n    and `j`, the intersection `s i ∩ s j` is nonempty: if it were empty, then thanks to the\n    separating set `q i j` in the definition of `E i` one could not have `x ∈ E i ∩ E j`.\n    Since these two sets have small diameter, it follows that `y i` and `y j` are close.\n    Thus, `y` is a Cauchy sequence, converging to a limit `z`. We claim that `f z = x`, completing\n    the proof.\n    Otherwise, one could find open sets `v` and `w` separating `f z` from `x`. Then, for large `n`,\n    the image `f '' (s i)` would be included in `v` by continuity of `f`, so its closure would be\n    contained in the closure of `v`, and therefore it would be disjoint from `w`. This is a\n    contradiction since `x` belongs both to this closure and to `w`. -/\n  letI := upgradePolishSpace γ\n  obtain ⟨b, b_count, b_nonempty, hb⟩ : ∃ b : Set (Set γ), b.countable ∧ ∅ ∉ b ∧ is_topological_basis b :=\n    exists_countable_basis γ\n  haveI : Encodable b := b_count.to_encodable\n  let A := { p : b × b // Disjoint (p.1 : Set γ) p.2 }\n  -- for each pair of disjoint sets in the topological basis `b`, consider Borel sets separating\n  -- their images, by injectivity of `f` and the Lusin separation theorem.\n  have :\n    ∀ p : A,\n      ∃ q : Set β, «expr '' » f (p.1.1 : Set γ) ⊆ q ∧ Disjoint («expr '' » f (p.1.2 : Set γ)) q ∧ MeasurableSet q :=\n    by\n    intro p\n    apply\n      analytic_set.measurably_separable ((hb.is_open p.1.1.2).analytic_set_image f_cont)\n        ((hb.is_open p.1.2.2).analytic_set_image f_cont)\n    exact Disjoint.image p.2 (f_inj.inj_on univ) (subset_univ _) (subset_univ _)\n  choose q hq1 hq2 q_meas using this\n  -- define sets `E i` and `F n` as in the proof sketch above\n  let E : b → Set β := fun s =>\n    closure («expr '' » f s) ∩\n      «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\"\n        (q ⟨(s, t), ht⟩ \\ q ⟨(t, s), ht.symm⟩)\n  obtain ⟨u, u_anti, u_pos, u_lim⟩ : ∃ u : ℕ → exprℝ, StrictAnti u ∧ (∀ n : ℕ, 0 < u n) ∧ tendsto u at_top ((nhds) 0) :=\n    exists_seq_strictAnti_tendsto (0 : exprℝ)\n  let F : ℕ → Set β := fun n =>\n    «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (E s)\n  -- it is enough to show that `range f = ⋂ F n`, as the latter set is obviously measurable.\n  suffices\n    range f = «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (F n)\n    by\n    have E_meas : ∀ s : b, MeasurableSet (E s) := by\n      intro b\n      refine' is_closed_closure.measurable_set.inter _\n      refine' MeasurableSet.interᵢ fun s => _\n      exact MeasurableSet.interᵢ fun hs => (q_meas _).diff (q_meas _)\n    have F_meas : ∀ n, MeasurableSet (F n) := by\n      intro n\n      refine' MeasurableSet.unionᵢ fun s => _\n      exact MeasurableSet.unionᵢ fun hs => E_meas _\n    rw [this]\n    exact MeasurableSet.interᵢ fun n => F_meas n\n  -- we check both inclusions.\n  apply subset.antisymm\n  -- we start with the easy inclusion `range f ⊆ ⋂ F n`. One just needs to unfold the definitions.\n  · rintro x ⟨y, rfl⟩\n    apply mem_Inter.2 fun n => _\n    obtain ⟨s, sb, ys, hs⟩ : ∃ (s : Set γ)(H : s ∈ b), y ∈ s ∧ s ⊆ ball y (u n / 2) :=\n      by\n      apply hb.mem_nhds_iff.1\n      exact ball_mem_nhds _ (half_pos (u_pos n))\n    have diam_s : diam s ≤ u n := by\n      apply (diam_mono hs bounded_ball).trans\n      convert diam_ball (half_pos (u_pos n)).le\n      ring\n    refine' mem_Union.2 ⟨⟨s, sb⟩, _⟩\n    refine' mem_Union.2 ⟨⟨Metric.Bounded.mono hs bounded_ball, diam_s⟩, _⟩\n    apply mem_inter (subset_closure (mem_image_of_mem _ ys))\n    refine' mem_Inter.2 fun t => mem_Inter.2 fun ht => ⟨_, _⟩\n    · apply hq1\n      exact mem_image_of_mem _ ys\n    · apply disjoint_left.1 (hq2 ⟨(t, ⟨s, sb⟩), ht.symm⟩)\n      exact mem_image_of_mem _ ys\n  -- Now, let us prove the harder inclusion `⋂ F n ⊆ range f`.\n  · intro x hx\n    -- pick for each `n` a good set `s n` of small diameter for which `x ∈ E (s n)`.\n    have C1 : ∀ n, ∃ (s : b)(hs : bounded s.1 ∧ diam s.1 ≤ u n), x ∈ E s := fun n => by\n      simpa only [mem_Union] using mem_Inter.1 hx n\n    choose s hs hxs using C1\n    have C2 : ∀ n, (s n).1.nonempty := by\n      intro n\n      rw [nonempty_iff_ne_empty]\n      intro hn\n      have := (s n).2\n      rw [hn] at this\n      exact b_nonempty this\n    -- choose a point `y n ∈ s n`.\n    choose y hy using C2\n    have I : ∀ m n, ((s m).1 ∩ (s n).1).nonempty := by\n      intro m n\n      rw [← not_disjoint_iff_nonempty_inter]\n      by_contra' h\n      have A : x ∈ q ⟨(s m, s n), h⟩ \\ q ⟨(s n, s m), h.symm⟩ :=\n        haveI := mem_Inter.1 (hxs m).2 (s n)\n        (mem_Inter.1 this h : _)\n      have B : x ∈ q ⟨(s n, s m), h.symm⟩ \\ q ⟨(s m, s n), h⟩ :=\n        haveI := mem_Inter.1 (hxs n).2 (s m)\n        (mem_Inter.1 this h.symm : _)\n      exact A.2 B.1\n    -- the points `y n` are nearby, and therefore they form a Cauchy sequence.\n    have cauchy_y : CauchySeq y :=\n      by\n      have : tendsto (fun n => 2 * u n) at_top ((nhds) 0) := by\n        simpa only [MulZeroClass.mul_zero] using u_lim.const_mul 2\n      apply cauchySeq_of_le_tendsto_0' (fun n => 2 * u n) (fun m n hmn => _) this\n      rcases I m n with ⟨z, zsm, zsn⟩\n      calc\n        dist (y m) (y n) ≤ dist (y m) z + dist z (y n) := dist_triangle _ _ _\n        _ ≤ u m + u n :=\n          (add_le_add ((dist_le_diam_of_mem (hs m).1 (hy m) zsm).trans (hs m).2)\n            ((dist_le_diam_of_mem (hs n).1 zsn (hy n)).trans (hs n).2))\n        _ ≤ 2 * u m := by linarith [u_anti.antitone hmn]\n        \n    haveI : Nonempty γ := ⟨y 0⟩\n    -- let `z` be its limit.\n    let z := limUnder at_top y\n    have y_lim : tendsto y at_top ((nhds) z) := cauchy_y.tendsto_lim\n    suffices f z = x by\n      rw [← this]\n      exact mem_range_self _\n    -- assume for a contradiction that `f z ≠ x`.\n    by_contra' hne\n    -- introduce disjoint open sets `v` and `w` separating `f z` from `x`.\n    obtain ⟨v, w, v_open, w_open, fzv, xw, hvw⟩ := t2_separation hne\n    obtain ⟨δ, δpos, hδ⟩ : ∃ δ > (0 : exprℝ), ball z δ ⊆ «expr ⁻¹' » f v :=\n      by\n      apply Metric.mem_nhds_iff.1\n      exact f_cont.continuous_at.preimage_mem_nhds (v_open.mem_nhds fzv)\n    obtain ⟨n, hn⟩ : ∃ n, u n + dist (y n) z < δ :=\n      haveI : tendsto (fun n => u n + dist (y n) z) at_top ((nhds) 0) := by\n        simpa only [add_zero] using u_lim.add (tendsto_iff_dist_tendsto_zero.1 y_lim)\n      ((tendsto_order.1 this).2 _ δpos).exists\n    -- for large enough `n`, the image of `s n` is contained in `v`, by continuity of `f`.\n    have fsnv : «expr '' » f (s n) ⊆ v := by\n      rw [image_subset_iff]\n      apply subset.trans _ hδ\n      intro a ha\n      calc\n        dist a z ≤ dist a (y n) + dist (y n) z := dist_triangle _ _ _\n        _ ≤ u n + dist (y n) z := (add_le_add_right ((dist_le_diam_of_mem (hs n).1 ha (hy n)).trans (hs n).2) _)\n        _ < δ := hn\n        \n    -- as `x` belongs to the closure of `f '' (s n)`, it belongs to the closure of `v`.\n    have : x ∈ closure v := closure_mono fsnv (hxs n).1\n    -- this is a contradiction, as `x` is supposed to belong to `w`, which is disjoint from\n    -- the closure of `v`.\n    exact disjoint_left.1 (hvw.closure_left w_open) this xw\n#align measurable_set_range_of_continuous_injective measurable_set_range_of_continuous_injective\n\n",
 "measurable_set_image_of_continuous_on_inj_on":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem _root_.is_closed.measurable_set_image_of_continuous_on_inj_on {β : Type _} [TopologicalSpace β] [T2Space β]\n    [MeasurableSpace β] [borel_space β] {s : Set γ} (hs : IsClosed s) {f : γ → β} (f_cont : ContinuousOn f s)\n    (f_inj : InjOn f s) : MeasurableSet («expr '' » f s) :=\n  by\n  rw [image_eq_range]\n  haveI : PolishSpace s := IsClosed.polishSpace hs\n  apply measurable_set_range_of_continuous_injective\n  · rwa [continuousOn_iff_continuous_restrict] at f_cont\n  · rwa [inj_on_iff_injective] at f_inj\n#align is_closed.measurable_set_image_of_continuous_on_inj_on is_closed.measurable_set_image_of_continuous_on_inj_on\n\n",
 "measurable_set_exists_tendsto":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- The set of points for which a measurable sequence of functions converges is measurable. -/\n@[measurability]\ntheorem measurable_set_exists_tendsto [hγ : opens_measurable_space γ] [Countable ι] {l : Filter ι}\n    [l.is_countably_generated] {f : ι → β → γ} (hf : ∀ i, Measurable (f i)) :\n    MeasurableSet { x | ∃ c, Tendsto (fun n => f n x) l ((nhds) c) } :=\n  by\n  by_cases hl : l.ne_bot\n  swap;\n  · rw [not_ne_bot] at hl\n    simp [hl]\n  letI := upgradePolishSpace γ\n  rcases l.exists_antitone_basis with ⟨u, hu⟩\n  simp_rw [← cauchy_map_iff_exists_tendsto]\n  change MeasurableSet { x | _ ∧ _ }\n  have :\n    ∀ x,\n      (filter.prod (map (fun i => f i x) l) (map (fun i => f i x) l)).has_antitone_basis fun n =>\n        lower_set.prod («expr '' » (fun i => f i x) (u n)) («expr '' » (fun i => f i x) (u n)) :=\n    fun x => hu.map.prod hu.map\n  simp_rw [and_iff_right (hl.map _),\n    Filter.HasBasis.le_basis_iff (this _).to_has_basis Metric.uniformity_basis_dist_inv_nat_succ, Set.setOf_forall]\n  refine' MeasurableSet.binterᵢ Set.countable_univ fun K _ => _\n  simp_rw [Set.setOf_exists]\n  refine' MeasurableSet.bunionᵢ Set.countable_univ fun N hN => _\n  simp_rw [prod_image_image_eq, image_subset_iff, prod_subset_iff, Set.setOf_forall]\n  exact\n    MeasurableSet.binterᵢ (to_countable (u N)) fun i _ =>\n      MeasurableSet.binterᵢ (to_countable (u N)) fun j _ =>\n        measurable_set_lt (measurable.dist (hf i) (hf j)) measurable_const\n#align measurable_set_exists_tendsto measurable_set_exists_tendsto\n\n",
 "measurable_equiv_range_coe_nat_of_infinite_of_countable":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ᵐ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem measurable_equiv_range_coe_nat_of_infinite_of_countable [Infinite α] [Countable α] :\n    Nonempty («expr ≃ᵐ » α (range (coe : ℕ → exprℝ))) :=\n  by\n  have : PolishSpace (range (coe : ℕ → exprℝ)) := nat.closed_embedding_coe_real.is_closed_map.closed_range.polish_space\n  refine' ⟨polish_space.equiv.measurable_equiv _⟩\n  refine' (nonempty_equiv_of_countable.some : «expr ≃ » α ℕ).trans _\n  exact Equiv.ofInjective coe Nat.cast_injective\n#align measurable_equiv_range_coe_nat_of_infinite_of_countable measurable_equiv_range_coe_nat_of_infinite_of_countable\n\n",
 "measurable_embedding":
 "/-- An injective measurable function from a Polish space to a second-countable topological space\nis a measurable embedding. -/\ntheorem _root_.measurable.measurable_embedding [SecondCountableTopology β] (f_meas : Measurable f)\n    (f_inj : injective f) : MeasurableEmbedding f :=\n  { injective := f_inj\n    measurable := f_meas\n    measurable_set_image' := fun u hu => hu.image_of_measurable_inj_on f_meas (f_inj.inj_on _) }\n#align measurable.measurable_embedding measurable.measurable_embedding\n\n",
 "is_clopenable_iff_measurable_set":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `is_closed_of -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `is_open_of -/\n/-- In a Polish space, a set is clopenable if and only if it is Borel-measurable. -/\ntheorem is_clopenable_iff_measurable_set : IsClopenable s ↔ MeasurableSet s :=\n  by\n  -- we already know that a measurable set is clopenable. Conversely, assume that `s` is clopenable.\n  refine' ⟨fun hs => _, fun hs => hs.is_clopenable⟩\n  -- consider a finer topology `t'` in which `s` is open and closed.\n  obtain ⟨t', t't, t'_polish, s_closed, s_open⟩ :\n    ∃ t' : TopologicalSpace γ, t' ≤ tγ ∧ @PolishSpace γ t' ∧ (is_closed_of t') s ∧ (is_open_of t') s := hs\n  -- the identity is continuous from `t'` to `tγ`.\n  have C : @Continuous γ γ t' tγ id := continuous_id_of_le t't\n  -- therefore, it is also a measurable embedding, by the Lusin-Souslin theorem\n  have E :=\n    @continuous.measurable_embedding γ t' t'_polish (@borel γ t')\n      (by\n        constructor\n        rfl)\n      γ tγ (PolishSpace.t2Space γ) _ _ id C injective_id\n  -- the set `s` is measurable for `t'` as it is closed.\n  have M : @MeasurableSet γ (@borel γ t') s :=\n    @is_closed.measurable_set γ s t' (@borel γ t')\n      (@borel_space.opens_measurable γ t' (@borel γ t')\n        (by\n          constructor\n          rfl))\n      s_closed\n  -- therefore, its image under the measurable embedding `id` is also measurable for `tγ`.\n  convert E.measurable_set_image.2 M\n  simp only [id.def, image_id']\n#align is_clopenable_iff_measurable_set is_clopenable_iff_measurable_set\n\n",
 "is_clopenable":
 "/-- Given a Borel-measurable set in a Polish space, there exists a finer Polish topology making\nit clopen. This is in fact an equivalence, see `is_clopenable_iff_measurable_set`. -/\ntheorem _root_.measurable_set.is_clopenable [PolishSpace α] [MeasurableSpace α] [borel_space α] {s : Set α}\n    (hs : MeasurableSet s) : IsClopenable s := by\n  revert s\n  apply measurable_set.induction_on_open\n  · exact fun u hu => hu.is_clopenable\n  · exact fun u hu h'u => h'u.compl\n  · exact fun f f_disj f_meas hf => is_clopenable.Union hf\n#align measurable_set.is_clopenable measurable_set.is_clopenable\n\n",
 "image_of_measurable_inj_on":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/-- The Lusin-Souslin theorem: if `s` is Borel-measurable in a Polish space, then its image under\na measurable injective map taking values in a second-countable topological space\nis also Borel-measurable. -/\ntheorem _root_.measurable_set.image_of_measurable_inj_on [SecondCountableTopology β] (hs : MeasurableSet s)\n    (f_meas : Measurable f) (f_inj : InjOn f s) : MeasurableSet («expr '' » f s) :=\n  by\n  -- for a finer Polish topology, `f` is continuous. Therefore, one may apply the corresponding\n  -- result for continuous maps.\n  obtain ⟨t', t't, f_cont, t'_polish⟩ :\n    ∃ t' : TopologicalSpace γ, t' ≤ tγ ∧ @Continuous γ β t' tβ f ∧ @PolishSpace γ t' := f_meas.exists_continuous\n  have M : (measurable_set_of (@borel γ t')) s :=\n    @continuous.measurable γ γ t' (@borel γ t')\n      (@borel_space.opens_measurable γ t' (@borel γ t')\n        (by\n          constructor\n          rfl))\n      tγ _ _ _ (continuous_id_of_le t't) s hs\n  exact\n    @measurable_set.image_of_continuous_on_inj_on γ t' t'_polish (@borel γ t')\n      (by\n        constructor\n        rfl)\n      β _ _ _ _ s f M (@Continuous.continuousOn γ β t' tβ f s f_cont) f_inj\n#align measurable_set.image_of_measurable_inj_on measurable_set.image_of_measurable_inj_on\n\n",
 "image_of_continuous_on_inj_on":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `is_closed_of -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `is_open_of -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/-- The Lusin-Souslin theorem: if `s` is Borel-measurable in a Polish space, then its image under\na continuous injective map is also Borel-measurable. -/\ntheorem _root_.measurable_set.image_of_continuous_on_inj_on (hs : MeasurableSet s) (f_cont : ContinuousOn f s)\n    (f_inj : InjOn f s) : MeasurableSet («expr '' » f s) :=\n  by\n  obtain ⟨t', t't, t'_polish, s_closed, s_open⟩ :\n    ∃ t' : TopologicalSpace γ, t' ≤ tγ ∧ @PolishSpace γ t' ∧ (is_closed_of t') s ∧ (is_open_of t') s := hs.is_clopenable\n  exact\n    @is_closed.measurable_set_image_of_continuous_on_inj_on γ t' t'_polish β _ _ _ _ s s_closed f (f_cont.mono_dom t't)\n      f_inj\n#align measurable_set.image_of_continuous_on_inj_on measurable_set.image_of_continuous_on_inj_on\n\n",
 "image_of_continuous_on":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/-- The continuous image of an analytic set is analytic -/\ntheorem analytic_set.image_of_continuous_on {β : Type _} [TopologicalSpace β] {s : Set α} (hs : analytic_set s)\n    {f : α → β} (hf : ContinuousOn f s) : analytic_set («expr '' » f s) :=\n  by\n  rcases analytic_set_iff_exists_polish_space_range.1 hs with ⟨γ, γtop, γpolish, g, g_cont, gs⟩\n  skip\n  have : «expr '' » f s = range (f ∘ g) := by rw [range_comp, gs]\n  rw [this]\n  apply analytic_set_range_of_polish_space\n  apply hf.comp_continuous g_cont fun x => _\n  rw [← gs]\n  exact mem_range_self _\n#align analytic_set.image_of_continuous_on analytic_set.image_of_continuous_on\n\n",
 "image_of_continuous":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem analytic_set.image_of_continuous {β : Type _} [TopologicalSpace β] {s : Set α} (hs : analytic_set s) {f : α → β}\n    (hf : Continuous f) : analytic_set («expr '' » f s) :=\n  hs.image_of_continuous_on hf.continuous_on\n#align analytic_set.image_of_continuous analytic_set.image_of_continuous\n\n",
 "exists_subset_real_measurable_equiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ᵐ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ᵐ » -/\n/-- Any Polish Borel space is measurably equivalent to a subset of the reals. -/\ntheorem exists_subset_real_measurable_equiv : ∃ s : Set (exprℝ), MeasurableSet s ∧ Nonempty («expr ≃ᵐ » α s) :=\n  by\n  by_cases hα : Countable α\n  · cases finite_or_infinite α\n    · obtain ⟨n, h_nonempty_equiv⟩ := exists_nat_measurable_equiv_range_coe_fin_of_finite α\n      refine' ⟨_, _, h_nonempty_equiv⟩\n      letI : MeasurableSpace (Fin n) := borel (Fin n)\n      haveI : borel_space (Fin n) := ⟨rfl⟩\n      refine' MeasurableEmbedding.measurableSet_range _\n      · infer_instance\n      · exact continuous_of_discrete_topology.measurable_embedding (nat.cast_injective.comp Fin.val_injective)\n    · refine' ⟨_, _, measurable_equiv_range_coe_nat_of_infinite_of_countable α⟩\n      refine' MeasurableEmbedding.measurableSet_range _\n      · infer_instance\n      · exact continuous_of_discrete_topology.measurable_embedding Nat.cast_injective\n  · refine'\n      ⟨univ, MeasurableSet.univ,\n        ⟨(polish_space.measurable_equiv_of_not_countable hα _ : «expr ≃ᵐ » α (univ : Set (exprℝ)))⟩⟩\n    rw [countable_coe_iff]\n    exact Cardinal.not_countable_real\n#align exists_subset_real_measurable_equiv exists_subset_real_measurable_equiv\n\n",
 "exists_nat_measurable_equiv_range_coe_fin_of_finite":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ᵐ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n-- todo after the port: move to topology/metric_space/polish\ntheorem exists_nat_measurable_equiv_range_coe_fin_of_finite [Finite α] :\n    ∃ n : ℕ, Nonempty («expr ≃ᵐ » α (range (coe : Fin n → exprℝ))) :=\n  by\n  obtain ⟨n, ⟨n_equiv⟩⟩ := Finite.exists_equiv_fin α\n  refine' ⟨n, ⟨polish_space.equiv.measurable_equiv (n_equiv.trans _)⟩⟩\n  exact Equiv.ofInjective _ (nat.cast_injective.comp Fin.val_injective)\n#align exists_nat_measurable_equiv_range_coe_fin_of_finite exists_nat_measurable_equiv_range_coe_fin_of_finite\n\n",
 "exists_measurable_embedding_real":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- Any Polish Borel space embeds measurably into the reals. -/\ntheorem exists_measurable_embedding_real : ∃ f : α → exprℝ, MeasurableEmbedding f :=\n  by\n  obtain ⟨s, hs, ⟨e⟩⟩ := exists_subset_real_measurable_equiv α\n  exact ⟨coe ∘ e, (MeasurableEmbedding.subtype_coe hs).comp e.measurable_embedding⟩\n#align exists_measurable_embedding_real exists_measurable_embedding_real\n\n",
 "exists_continuous":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/-- Given a Borel-measurable function from a Polish space to a second-countable space, there exists\na finer Polish topology on the source space for which the function is continuous. -/\ntheorem _root_.measurable.exists_continuous {α β : Type _} [t : TopologicalSpace α] [PolishSpace α] [MeasurableSpace α]\n    [borel_space α] [tβ : TopologicalSpace β] [SecondCountableTopology β] [MeasurableSpace β] [borel_space β]\n    {f : α → β} (hf : Measurable f) : ∃ t' : TopologicalSpace α, t' ≤ t ∧ @Continuous α β t' tβ f ∧ @PolishSpace α t' :=\n  by\n  obtain ⟨b, b_count, -, hb⟩ : ∃ b : Set (Set β), b.countable ∧ ∅ ∉ b ∧ is_topological_basis b :=\n    exists_countable_basis β\n  haveI : Encodable b := b_count.to_encodable\n  have : ∀ s : b, is_clopenable («expr ⁻¹' » f s) := by\n    intro s\n    apply measurable_set.is_clopenable\n    exact hf (hb.is_open s.2).measurable_set\n  choose T Tt Tpolish Tclosed Topen using this\n  obtain ⟨t', t'T, t't, t'_polish⟩ : ∃ t' : TopologicalSpace α, (∀ i, t' ≤ T i) ∧ t' ≤ t ∧ @PolishSpace α t' :=\n    exists_polish_space_forall_le T Tt Tpolish\n  refine' ⟨t', t't, _, t'_polish⟩\n  apply hb.continuous _ fun s hs => _\n  exact t'T ⟨s, hs⟩ _ (Topen ⟨s, hs⟩)\n#align measurable.exists_continuous measurable.exists_continuous\n\n",
 "analytic_set_range_of_polish_space":
 "theorem analytic_set_range_of_polish_space {β : Type _} [TopologicalSpace β] [PolishSpace β] {f : β → α}\n    (f_cont : Continuous f) : analytic_set (range f) :=\n  by\n  cases isEmpty_or_nonempty β\n  · rw [range_eq_empty]\n    exact analytic_set_empty\n  · rw [analytic_set]\n    obtain ⟨g, g_cont, hg⟩ : ∃ g : (ℕ → ℕ) → β, Continuous g ∧ surjective g := exists_nat_nat_continuous_surjective β\n    refine' or.inr ⟨f ∘ g, f_cont.comp g_cont, _⟩\n    rwa [hg.range_comp]\n#align analytic_set_range_of_polish_space analytic_set_range_of_polish_space\n\n",
 "analytic_set_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/-- The image of an open set under a continuous map is analytic. -/\ntheorem _root_.is_open.analytic_set_image {β : Type _} [TopologicalSpace β] [PolishSpace β] {s : Set β} (hs : IsOpen s)\n    {f : β → α} (f_cont : Continuous f) : analytic_set («expr '' » f s) :=\n  by\n  rw [image_eq_range]\n  haveI : PolishSpace s := hs.polish_space\n  exact analytic_set_range_of_polish_space (f_cont.comp continuous_subtype_val)\n#align is_open.analytic_set_image is_open.analytic_set_image\n\n",
 "analytic_set_iff_exists_polish_space_range":
 "/-- A set is analytic if and only if it is the continuous image of some Polish space. -/\ntheorem analytic_set_iff_exists_polish_space_range {s : Set α} :\n    analytic_set s ↔\n      ∃ (β : Type)(h : TopologicalSpace β)(h' : @PolishSpace β h)(f : β → α), @Continuous _ _ h _ f ∧ range f = s :=\n  by\n  constructor\n  · intro h\n    rw [analytic_set] at h\n    cases h\n    · refine' ⟨Empty, by infer_instance, by infer_instance, Empty.elim, continuous_bot, _⟩\n      rw [h]\n      exact range_eq_empty _\n    · exact ⟨ℕ → ℕ, by infer_instance, by infer_instance, h⟩\n  · rintro ⟨β, h, h', f, f_cont, f_range⟩\n    skip\n    rw [← f_range]\n    exact analytic_set_range_of_polish_space f_cont\n#align analytic_set_iff_exists_polish_space_range analytic_set_iff_exists_polish_space_range\n\n",
 "analytic_set_empty":
 "/-\nCopyright (c) 2022 Sébastien Gouëzel. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Sébastien Gouëzel, Felix Weilacher\n-/\ntheorem analytic_set_empty : analytic_set (∅ : Set α) :=\n  by\n  rw [analytic_set]\n  exact or.inl rfl\n#align analytic_set_empty analytic_set_empty\n\n",
 "analytic_set":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `is_closed_of -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `is_open_of -/\ntheorem _root_.measurable_set.analytic_set {α : Type _} [t : TopologicalSpace α] [PolishSpace α] [MeasurableSpace α]\n    [borel_space α] {s : Set α} (hs : MeasurableSet s) : analytic_set s :=\n  by\n  /- For a short proof (avoiding measurable induction), one sees `s` as a closed set for a finer\n    topology `t'`. It is analytic for this topology. As the identity from `t'` to `t` is continuous\n    and the image of an analytic set is analytic, it follows that `s` is also analytic for `t`. -/\n  obtain ⟨t', t't, t'_polish, s_closed, s_open⟩ :\n    ∃ t' : TopologicalSpace α, t' ≤ t ∧ @PolishSpace α t' ∧ (is_closed_of t') s ∧ (is_open_of t') s := hs.is_clopenable\n  have A := @is_closed.analytic_set α t' t'_polish s s_closed\n  convert@analytic_set.image_of_continuous α t' α t s A id (continuous_id_of_le t't)\n  simp only [id.def, image_id']\n#align measurable_set.analytic_set measurable_set.analytic_set\n\n",
 "Union":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\ntheorem measurably_separable.Union [Countable ι] {α : Type _} [MeasurableSpace α] {s t : ι → Set α}\n    (h : ∀ m n, measurably_separable (s m) (t n)) :\n    measurably_separable\n      («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (s n))\n      («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (t m)) :=\n  by\n  choose u hsu htu hu using h\n  refine'\n    ⟨«expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n        («expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (u m n)),\n      _, _, _⟩\n  · refine' Union_subset fun m => subset_Union_of_subset m _\n    exact subset_Inter fun n => hsu m n\n  · simp_rw [disjoint_Union_left, disjoint_Union_right]\n    intro n m\n    apply Disjoint.mono_right _ (htu m n)\n    apply Inter_subset\n  · refine' MeasurableSet.unionᵢ fun m => _\n    exact MeasurableSet.interᵢ fun n => hu m n\n#align measurably_separable.Union measurably_separable.Union\n\n",
 "Inter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/-- A countable intersection of analytic sets is analytic. -/\ntheorem analytic_set.Inter [hι : Nonempty ι] [Countable ι] [T2Space α] {s : ι → Set α} (hs : ∀ n, analytic_set (s n)) :\n    analytic_set\n      («expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (s n)) :=\n  by\n  rcases hι with ⟨i₀⟩\n  /- For the proof, write each `s n` as the continuous image under a map `f n` of a\n    Polish space `β n`. The product space `γ = Π n, β n` is also Polish, and so is the subset\n    `t` of sequences `x n` for which `f n (x n)` is independent of `n`. The set `t` is Polish, and the\n    range of `x ↦ f 0 (x 0)` on `t` is exactly `⋂ n, s n`, so this set is analytic. -/\n  choose β hβ h'β f f_cont f_range using fun n => analytic_set_iff_exists_polish_space_range.1 (hs n)\n  skip\n  let γ := ∀ n, β n\n  let t : Set γ :=\n    «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\"\n      { x | f n (x n) = f i₀ (x i₀) }\n  have t_closed : IsClosed t := by\n    apply isClosed_interᵢ\n    intro n\n    exact isClosed_eq ((f_cont n).comp (continuous_apply n)) ((f_cont i₀).comp (continuous_apply i₀))\n  haveI : PolishSpace t := t_closed.polish_space\n  let F : t → α := fun x => f i₀ ((x : γ) i₀)\n  have F_cont : Continuous F := (f_cont i₀).comp ((continuous_apply i₀).comp continuous_subtype_val)\n  have F_range :\n    range F = «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (s n) :=\n    by\n    apply subset.antisymm\n    · rintro y ⟨x, rfl⟩\n      apply mem_Inter.2 fun n => _\n      have : f n ((x : γ) n) = F x := (mem_Inter.1 x.2 n : _)\n      rw [← this, ← f_range n]\n      exact mem_range_self _\n    · intro y hy\n      have A : ∀ n, ∃ x : β n, f n x = y := by\n        intro n\n        rw [← mem_range, f_range n]\n        exact mem_Inter.1 hy n\n      choose x hx using A\n      have xt : x ∈ t := by\n        apply mem_Inter.2 fun n => _\n        simp [hx]\n      refine' ⟨⟨x, xt⟩, _⟩\n      exact hx i₀\n  rw [← F_range]\n  exact analytic_set_range_of_polish_space F_cont\n#align analytic_set.Inter analytic_set.Inter\n\n"}