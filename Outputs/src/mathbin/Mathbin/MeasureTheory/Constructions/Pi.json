{"volume_preserving_pi_fin_two":
 "theorem volume_preserving_pi_fin_two (α : fin 2 → Type u) [∀ i, measure_space (α i)]\n    [∀ i, sigma_finite (volume : measure (α i))] : measure_preserving (measurable_equiv.pi_fin_two α) volume volume :=\n  measure_preserving_pi_fin_two _\n#align volume_preserving_pi_fin_two volume_preserving_pi_fin_two\n\n",
 "volume_preserving_pi_fin_succ_above_equiv":
 "theorem volume_preserving_pi_fin_succ_above_equiv {n : ℕ} (α : fin (n + 1) → Type u) [∀ i, measure_space (α i)]\n    [∀ i, sigma_finite (volume : measure (α i))] (i : fin (n + 1)) :\n    measure_preserving (measurable_equiv.pi_fin_succ_above_equiv α i) :=\n  measure_preserving_pi_fin_succ_above_equiv (fun _ => volume) i\n#align volume_preserving_pi_fin_succ_above_equiv volume_preserving_pi_fin_succ_above_equiv\n\n",
 "volume_preserving_pi_equiv_pi_subtype_prod":
 "theorem volume_preserving_pi_equiv_pi_subtype_prod {ι : Type _} (α : ι → Type _) [fintype ι] [∀ i, measure_space (α i)]\n    [∀ i, sigma_finite (volume : measure (α i))] (p : ι → Prop) [decidable_pred p] :\n    measure_preserving (measurable_equiv.pi_equiv_pi_subtype_prod α p) :=\n  measure_preserving_pi_equiv_pi_subtype_prod (fun i => volume) p\n#align volume_preserving_pi_equiv_pi_subtype_prod volume_preserving_pi_equiv_pi_subtype_prod\n\n",
 "volume_preserving_pi_empty":
 "theorem volume_preserving_pi_empty {ι : Type u} (α : ι → Type v) [is_empty ι] [∀ i, measure_space (α i)] :\n    measure_preserving (measurable_equiv.of_unique_of_unique (∀ i, α i) unit) volume volume :=\n  measure_preserving_pi_empty fun _ => volume\n#align volume_preserving_pi_empty volume_preserving_pi_empty\n\n",
 "volume_preserving_fun_unique":
 "theorem volume_preserving_fun_unique (α : Type u) (β : Type v) [unique α] [measure_space β] :\n    measure_preserving (measurable_equiv.fun_unique α β) volume volume :=\n  measure_preserving_fun_unique volume α\n#align volume_preserving_fun_unique volume_preserving_fun_unique\n\n",
 "volume_preserving_fin_two_arrow":
 "theorem volume_preserving_fin_two_arrow (α : Type u) [measure_space α] [sigma_finite (volume : measure α)] :\n    measure_preserving (@measurable_equiv.fin_two_arrow α _) volume volume :=\n  measure_preserving_fin_two_arrow volume\n#align volume_preserving_fin_two_arrow volume_preserving_fin_two_arrow\n\n",
 "volume_pi_pi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\ntheorem volume_pi_pi [∀ i, measure_space (α i)] [∀ i, sigma_finite (volume : measure (α i))] (s : ∀ i, set (α i)) :\n    volume (pi univ s) =\n      finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n        (volume (s i)) :=\n  measure.pi_pi (fun i => volume) s\n#align volume_pi_pi volume_pi_pi\n\n",
 "volume_pi_closed_ball":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\ntheorem volume_pi_closed_ball [∀ i, measure_space (α i)] [∀ i, sigma_finite (volume : measure (α i))]\n    [∀ i, metric_space (α i)] (x : ∀ i, α i) {r : exprℝ} (hr : 0 ≤ r) :\n    volume (metric.closed_ball x r) =\n      finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n        (volume (metric.closed_ball (x i) r)) :=\n  measure.pi_closed_ball _ _ hr\n#align volume_pi_closed_ball volume_pi_closed_ball\n\n",
 "volume_pi_ball":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\ntheorem volume_pi_ball [∀ i, measure_space (α i)] [∀ i, sigma_finite (volume : measure (α i))] [∀ i, metric_space (α i)]\n    (x : ∀ i, α i) {r : exprℝ} (hr : 0 < r) :\n    volume (metric.ball x r) =\n      finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n        (volume (metric.ball (x i) r)) :=\n  measure.pi_ball _ _ hr\n#align volume_pi_ball volume_pi_ball\n\n",
 "volume_pi":
 "theorem volume_pi [∀ i, measure_space (α i)] : (volume : measure (∀ i, α i)) = measure.pi fun i => volume :=\n  rfl\n#align volume_pi volume_pi\n\n",
 "univ_pi_Ioo_ae_eq_Icc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\ntheorem univ_pi_Ioo_ae_eq_Icc {f g : ∀ i, α i} :\n    «expr =ᵐ[ ] » (pi univ fun i => Ioo (f i) (g i)) (measure.pi μ) (Icc f g) :=\n  by\n  rw [← pi_univ_Icc]\n  exact pi_Ioo_ae_eq_pi_Icc\n#align univ_pi_Ioo_ae_eq_Icc univ_pi_Ioo_ae_eq_Icc\n\n",
 "univ_pi_Ioi_ae_eq_Ici":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\ntheorem univ_pi_Ioi_ae_eq_Ici {f : ∀ i, α i} : «expr =ᵐ[ ] » (pi univ fun i => Ioi (f i)) (measure.pi μ) (Ici f) :=\n  by\n  rw [← pi_univ_Ici]\n  exact pi_Ioi_ae_eq_pi_Ici\n#align univ_pi_Ioi_ae_eq_Ici univ_pi_Ioi_ae_eq_Ici\n\n",
 "univ_pi_Ioc_ae_eq_Icc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\ntheorem univ_pi_Ioc_ae_eq_Icc {f g : ∀ i, α i} :\n    «expr =ᵐ[ ] » (pi univ fun i => Ioc (f i) (g i)) (measure.pi μ) (Icc f g) :=\n  by\n  rw [← pi_univ_Icc]\n  exact pi_Ioc_ae_eq_pi_Icc\n#align univ_pi_Ioc_ae_eq_Icc univ_pi_Ioc_ae_eq_Icc\n\n",
 "univ_pi_Iio_ae_eq_Iic":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\ntheorem univ_pi_Iio_ae_eq_Iic {f : ∀ i, α i} : «expr =ᵐ[ ] » (pi univ fun i => Iio (f i)) (measure.pi μ) (Iic f) :=\n  by\n  rw [← pi_univ_Iic]\n  exact pi_Iio_ae_eq_pi_Iic\n#align univ_pi_Iio_ae_eq_Iic univ_pi_Iio_ae_eq_Iic\n\n",
 "univ_pi_Ico_ae_eq_Icc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\ntheorem univ_pi_Ico_ae_eq_Icc {f g : ∀ i, α i} :\n    «expr =ᵐ[ ] » (pi univ fun i => Ico (f i) (g i)) (measure.pi μ) (Icc f g) :=\n  by\n  rw [← pi_univ_Icc]\n  exact pi_Ico_ae_eq_pi_Icc\n#align univ_pi_Ico_ae_eq_Icc univ_pi_Ico_ae_eq_Icc\n\n",
 "tprod_tprod":
 "theorem tprod_tprod (l : list δ) (μ : ∀ i, measure (π i)) [∀ i, sigma_finite (μ i)] (s : ∀ i, set (π i)) :\n    measure.tprod l μ (set.tprod l s) = (l.map fun i => (μ i) (s i)).prod :=\n  by\n  induction' l with i l ih; · simp\n  rw [tprod_cons, set.tprod, prod_prod, map_cons, prod_cons, ih]\n#align tprod_tprod tprod_tprod\n\n",
 "tprod_nil":
 "-- for some reason the equation compiler doesn't like this definition\n@[simp]\ntheorem tprod_nil (μ : ∀ i, measure (π i)) : measure.tprod [] μ = dirac PUnit.unit :=\n  rfl\n#align tprod_nil tprod_nil\n\n",
 "tprod_cons":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `sym.cons' -/\n@[simp]\ntheorem tprod_cons (i : δ) (l : list δ) (μ : ∀ i, measure (π i)) :\n    measure.tprod (sym.cons' i l) μ = (μ i).prod (measure.tprod l μ) :=\n  rfl\n#align tprod_cons tprod_cons\n\n",
 "tendsto_eval_ae_ae":
 "theorem tendsto_eval_ae_ae {i : ι} : tendsto (eval i) (measure.pi μ).ae (μ i).ae := fun s hs =>\n  pi_eval_preimage_null μ hs\n#align tendsto_eval_ae_ae tendsto_eval_ae_ae\n\n",
 "pi_univ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\ntheorem pi_univ :\n    measure.pi μ univ =\n      finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n        (μ i univ) :=\n  by rw [← pi_univ, pi_pi μ]\n#align pi_univ pi_univ\n\n",
 "pi_premeasure_pi_mono":
 "theorem pi_premeasure_pi_mono {s t : set (∀ i, α i)} (h : s ⊆ t) : pi_premeasure m s ≤ pi_premeasure m t :=\n  finset.prod_le_prod' fun i _ => (m i).mono' (image_subset _ h)\n#align pi_premeasure_pi_mono pi_premeasure_pi_mono\n\n",
 "pi_premeasure_pi_eval":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem pi_premeasure_pi_eval {s : set (∀ i, α i)} :\n    pi_premeasure m (pi univ fun i => «expr '' » (eval i) s) = pi_premeasure m s := by simp [pi_premeasure_pi']\n#align pi_premeasure_pi_eval pi_premeasure_pi_eval\n\n",
 "pi_premeasure_pi'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\ntheorem pi_premeasure_pi' {s : ∀ i, set (α i)} :\n    pi_premeasure m (pi univ s) =\n      finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n        (m i (s i)) :=\n  by\n  cases isEmpty_or_nonempty ι\n  · simp\n  cases' (pi univ s).eq_empty_or_nonempty with h h\n  · rcases univ_pi_eq_empty_iff.mp h with ⟨i, hi⟩\n    have : ∃ i, m i (s i) = 0 := ⟨i, by simp [hi]⟩\n    simpa [h, finset.card_univ, zero_pow (fintype.card_pos_iff.mpr ‹_›), @eq_comm _ (0 : ennreal),\n      finset.prod_eq_zero_iff]\n  · simp [h]\n#align pi_premeasure_pi' pi_premeasure_pi'\n\n",
 "pi_premeasure_pi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\ntheorem pi_premeasure_pi {s : ∀ i, set (α i)} (hs : (pi univ s).nonempty) :\n    pi_premeasure m (pi univ s) =\n      finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n        (m i (s i)) :=\n  by simp [hs]\n#align pi_premeasure_pi pi_premeasure_pi\n\n",
 "pi_pi_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\ntheorem pi_pi_le (m : ∀ i, outer_measure (α i)) (s : ∀ i, set (α i)) :\n    outer_measure.pi m (pi univ s) ≤\n      finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n        (m i (s i)) :=\n  by\n  cases' (pi univ s).eq_empty_or_nonempty with h h\n  simp [h]\n  exact (bounded_by_le _).trans_eq (pi_premeasure_pi h)\n#align pi_pi_le pi_pi_le\n\n",
 "pi_pi_aux":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\ntheorem pi_pi_aux [∀ i, sigma_finite (μ i)] (s : ∀ i, set (α i)) (hs : ∀ i, measurable_set (s i)) :\n    measure.pi μ (pi univ s) =\n      finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n        (μ i (s i)) :=\n  by\n  refine' le_antisymm _ _\n  · rw [measure.pi, to_measure_apply _ _ (measurable_set.pi countable_univ fun i _ => hs i)]\n    apply outer_measure.pi_pi_le\n  · haveI : Encodable ι := fintype.to_encodable ι\n    rw [← pi'_pi μ s]\n    simp_rw [← pi'_pi μ s, measure.pi, to_measure_apply _ _ (measurable_set.pi countable_univ fun i _ => hs i), ←\n      to_outer_measure_apply]\n    suffices (pi' μ).to_outer_measure ≤ outer_measure.pi fun i => (μ i).to_outer_measure by exact this _\n    clear hs s\n    rw [outer_measure.le_pi]\n    intro s hs\n    simp_rw [to_outer_measure_apply]\n    exact (pi'_pi μ s).le\n#align pi_pi_aux pi_pi_aux\n\n",
 "pi_pi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\n@[simp]\ntheorem pi_pi (s : ∀ i, set (α i)) :\n    measure.pi μ (pi univ s) =\n      finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n        (μ i (s i)) :=\n  by\n  haveI : Encodable ι := fintype.to_encodable ι\n  rw [← pi'_eq_pi, pi'_pi]\n#align pi_pi pi_pi\n\n",
 "pi_of_empty":
 "theorem pi_of_empty {α : Type _} [is_empty α] {β : α → Type _} {m : ∀ a, measurable_space (β a)}\n    (μ : ∀ a : α, measure (β a)) (x : ∀ a, β a := is_empty_elim) : measure.pi μ = dirac x :=\n  by\n  haveI : ∀ a, sigma_finite (μ a) := is_empty_elim\n  refine' pi_eq fun s hs => _\n  rw [fintype.prod_empty, dirac_apply_of_mem]\n  exact is_empty_elim\n#align pi_of_empty pi_of_empty\n\n",
 "pi_hyperplane":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem pi_hyperplane (i : ι) [has_no_atoms (μ i)] (x : α i) : measure.pi μ { f : ∀ i, α i | f i = x } = 0 :=\n  show measure.pi μ («expr ⁻¹' » (eval i) {x}) = 0 from pi_eval_preimage_null _ (measure_singleton x)\n#align pi_hyperplane pi_hyperplane\n\n",
 "pi_has_no_atoms":
 "/-- If one of the measures `μ i` has no atoms, them `measure.pi µ`\nhas no atoms. The instance below assumes that all `μ i` have no atoms. -/\ntheorem pi_has_no_atoms (i : ι) [has_no_atoms (μ i)] : has_no_atoms (measure.pi μ) :=\n  ⟨fun x => flip measure_mono_null (pi_hyperplane μ i (x i)) (singleton_subset_iff.2 rfl)⟩\n#align pi_has_no_atoms pi_has_no_atoms\n\n",
 "pi_eval_preimage_null":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem pi_eval_preimage_null {i : ι} {s : set (α i)} (hs : μ i s = 0) : measure.pi μ («expr ⁻¹' » (eval i) s) = 0 :=\n  by\n  -- WLOG, `s` is measurable\n  rcases exists_measurable_superset_of_null hs with ⟨t, hst, htm, hμt⟩\n  suffices : measure.pi μ («expr ⁻¹' » (eval i) t) = 0\n  exact measure_mono_null (preimage_mono hst) this\n  clear! s\n  -- Now rewrite it as `set.pi`, and apply `pi_pi`\n  rw [← univ_pi_update_univ, pi_pi]\n  apply finset.prod_eq_zero (finset.mem_univ i)\n  simp [hμt]\n#align pi_eval_preimage_null pi_eval_preimage_null\n\n",
 "pi_eq_generate_from":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\n-- TODO (kmill) If this let comes before the refine, while the noncomputability checker\n-- correctly sees this definition is computable, the Lean VM fails to see the binding is\n-- computationally irrelevant. The `noncomputable theory` doesn't help because all it does\n-- is insert `noncomputable` for you when necessary.\n/-- A measure on a finite product space equals the product measure if they are equal on rectangles\n  with as sides sets that generate the corresponding σ-algebras. -/\ntheorem pi_eq_generate_from {C : ∀ i, set (set (α i))} (hC : ∀ i, generate_from (C i) = by apply_assumption)\n    (h2C : ∀ i, is_pi_system (C i)) (h3C : ∀ i, (μ i).finite_spanning_sets_in (C i)) {μν : measure (∀ i, α i)}\n    (h₁ :\n      ∀ s : ∀ i, set (α i),\n        (∀ i, s i ∈ C i) →\n          μν (pi univ s) =\n            finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n              (μ i (s i))) :\n    measure.pi μ = μν :=\n  by\n  have h4C : ∀ (i) (s : set (α i)), s ∈ C i → measurable_set s :=\n    by\n    intro i s hs\n    rw [← hC]\n    exact measurable_set_generate_from hs\n  refine'\n    (finite_spanning_sets_in.pi h3C).ext (generate_from_eq_pi hC fun i => (h3C i).is_countably_spanning).symm\n      (is_pi_system.pi h2C) _\n  rintro _ ⟨s, hs, rfl⟩\n  rw [mem_univ_pi] at hs\n  haveI := fun i => (h3C i).sigma_finite\n  simp_rw [h₁ s hs, pi_pi_aux μ s fun i => h4C i _ (hs i)]\n#align pi_eq_generate_from pi_eq_generate_from\n\n",
 "pi_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\n/-- A measure on a finite product space equals the product measure if they are equal on\n  rectangles. -/\ntheorem pi_eq {μ' : measure (∀ i, α i)}\n    (h :\n      ∀ s : ∀ i, set (α i),\n        (∀ i, measurable_set (s i)) →\n          μ' (pi univ s) =\n            finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n              (μ i (s i))) :\n    measure.pi μ = μ' :=\n  pi_eq_generate_from (fun i => generate_from_measurable_set) (fun i => is_pi_system_measurable_set)\n    (fun i => (μ i).to_finite_spanning_sets_in) h\n#align pi_eq pi_eq\n\n",
 "pi_closed_ball":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\ntheorem pi_closed_ball [∀ i, metric_space (α i)] (x : ∀ i, α i) {r : exprℝ} (hr : 0 ≤ r) :\n    measure.pi μ (metric.closed_ball x r) =\n      finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n        (μ i (metric.closed_ball (x i) r)) :=\n  by rw [closed_ball_pi _ hr, pi_pi]\n#align pi_closed_ball pi_closed_ball\n\n",
 "pi_caratheodory":
 "theorem pi_caratheodory : measurable_space.pi ≤ (outer_measure.pi fun i => (μ i).to_outer_measure).caratheodory :=\n  by\n  refine' supᵢ_le _\n  intro i s hs\n  rw [measurable_space.comap] at hs\n  rcases hs with ⟨s, hs, rfl⟩\n  apply bounded_by_caratheodory\n  intro t\n  simp_rw [pi_premeasure]\n  refine' finset.prod_add_prod_le' (finset.mem_univ i) _ _ _\n  · simp [image_inter_preimage, image_diff_preimage, measure_inter_add_diff _ hs, le_refl]\n  · rintro j - hj\n    apply mono'\n    apply image_subset\n    apply inter_subset_left\n  · rintro j - hj\n    apply mono'\n    apply image_subset\n    apply diff_subset\n#align pi_caratheodory pi_caratheodory\n\n",
 "pi_ball":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\ntheorem pi_ball [∀ i, metric_space (α i)] (x : ∀ i, α i) {r : exprℝ} (hr : 0 < r) :\n    measure.pi μ (metric.ball x r) =\n      finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n        (μ i (metric.ball (x i) r)) :=\n  by rw [ball_pi _ hr, pi_pi]\n#align pi_ball pi_ball\n\n",
 "pi_Ioo_ae_eq_pi_Ioc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\ntheorem pi_Ioo_ae_eq_pi_Ioc {s : set ι} {f g : ∀ i, α i} :\n    «expr =ᵐ[ ] » (pi s fun i => Ioo (f i) (g i)) (measure.pi μ) (pi s fun i => Ioc (f i) (g i)) :=\n  ae_eq_set_pi fun i hi => Ioo_ae_eq_Ioc\n#align pi_Ioo_ae_eq_pi_Ioc pi_Ioo_ae_eq_pi_Ioc\n\n",
 "pi_Ioo_ae_eq_pi_Icc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\ntheorem pi_Ioo_ae_eq_pi_Icc {s : set ι} {f g : ∀ i, α i} :\n    «expr =ᵐ[ ] » (pi s fun i => Ioo (f i) (g i)) (measure.pi μ) (pi s fun i => Icc (f i) (g i)) :=\n  ae_eq_set_pi fun i hi => Ioo_ae_eq_Icc\n#align pi_Ioo_ae_eq_pi_Icc pi_Ioo_ae_eq_pi_Icc\n\n",
 "pi_Ioi_ae_eq_pi_Ici":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\ntheorem pi_Ioi_ae_eq_pi_Ici {s : set ι} {f : ∀ i, α i} :\n    «expr =ᵐ[ ] » (pi s fun i => Ioi (f i)) (measure.pi μ) (pi s fun i => Ici (f i)) :=\n  ae_eq_set_pi fun i hi => Ioi_ae_eq_Ici\n#align pi_Ioi_ae_eq_pi_Ici pi_Ioi_ae_eq_pi_Ici\n\n",
 "pi_Ioc_ae_eq_pi_Icc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\ntheorem pi_Ioc_ae_eq_pi_Icc {s : set ι} {f g : ∀ i, α i} :\n    «expr =ᵐ[ ] » (pi s fun i => Ioc (f i) (g i)) (measure.pi μ) (pi s fun i => Icc (f i) (g i)) :=\n  ae_eq_set_pi fun i hi => Ioc_ae_eq_Icc\n#align pi_Ioc_ae_eq_pi_Icc pi_Ioc_ae_eq_pi_Icc\n\n",
 "pi_Iio_ae_eq_pi_Iic":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\ntheorem pi_Iio_ae_eq_pi_Iic {s : set ι} {f : ∀ i, α i} :\n    «expr =ᵐ[ ] » (pi s fun i => Iio (f i)) (measure.pi μ) (pi s fun i => Iic (f i)) :=\n  ae_eq_set_pi fun i hi => Iio_ae_eq_Iic\n#align pi_Iio_ae_eq_pi_Iic pi_Iio_ae_eq_pi_Iic\n\n",
 "pi_Ico_ae_eq_pi_Icc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\ntheorem pi_Ico_ae_eq_pi_Icc {s : set ι} {f g : ∀ i, α i} :\n    «expr =ᵐ[ ] » (pi s fun i => Ico (f i) (g i)) (measure.pi μ) (pi s fun i => Icc (f i) (g i)) :=\n  ae_eq_set_pi fun i hi => Ico_ae_eq_Icc\n#align pi_Ico_ae_eq_pi_Icc pi_Ico_ae_eq_pi_Icc\n\n",
 "pi'_pi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\ntheorem pi'_pi [∀ i, sigma_finite (μ i)] (s : ∀ i, set (α i)) :\n    pi' μ (pi univ s) =\n      finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n        (μ i (s i)) :=\n  by\n  rw [pi', ← measurable_equiv.pi_measurable_equiv_tprod_symm_apply, measurable_equiv.map_apply,\n      measurable_equiv.pi_measurable_equiv_tprod_symm_apply, elim_preimage_pi, tprod_tprod _ μ, ← list.prod_to_finset,\n      sorted_univ_to_finset] <;>\n    exact sorted_univ_nodup ι\n#align pi'_pi pi'_pi\n\n",
 "pi'_eq_pi":
 "theorem pi'_eq_pi [Encodable ι] : pi' μ = measure.pi μ :=\n  eq.symm <| pi_eq fun s hs => pi'_pi μ s\n#align pi'_eq_pi pi'_eq_pi\n\n",
 "pi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/-- Boxes of countably spanning sets are countably spanning. -/\ntheorem is_countably_spanning.pi {C : ∀ i, set (set (α i))} (hC : ∀ i, is_countably_spanning (C i)) :\n    is_countably_spanning («expr '' » (pi univ) (pi univ C)) :=\n  by\n  choose s h1s h2s using hC\n  cases nonempty_encodable (ι → ℕ)\n  let e : ℕ → ι → ℕ := fun n => (decode (ι → ℕ) n).iget\n  refine' ⟨fun n => pi univ fun i => s i (e n i), fun n => mem_image_of_mem _ fun i _ => h1s i _, _⟩\n  simp_rw [(surjective_decode_iget (ι → ℕ)).Union_comp fun x => pi univ fun i => s i (x i), Union_univ_pi s, h2s,\n    pi_univ]\n#align is_countably_spanning.pi is_countably_spanning.pi\n\n",
 "measure_preserving_pi_fin_two":
 "theorem measure_preserving_pi_fin_two {α : fin 2 → Type u} {m : ∀ i, measurable_space (α i)} (μ : ∀ i, measure (α i))\n    [∀ i, sigma_finite (μ i)] : measure_preserving (measurable_equiv.pi_fin_two α) (measure.pi μ) ((μ 0).prod (μ 1)) :=\n  by\n  refine' ⟨measurable_equiv.measurable _, (measure.prod_eq fun s t hs ht => _).symm⟩\n  rw [measurable_equiv.map_apply, measurable_equiv.pi_fin_two_apply, fin.preimage_apply_01_prod, measure.pi_pi,\n    fin.prod_univ_two]\n  rfl\n#align measure_preserving_pi_fin_two measure_preserving_pi_fin_two\n\n",
 "measure_preserving_pi_fin_succ_above_equiv":
 "theorem measure_preserving_pi_fin_succ_above_equiv {n : ℕ} {α : fin (n + 1) → Type u} {m : ∀ i, measurable_space (α i)}\n    (μ : ∀ i, measure (α i)) [∀ i, sigma_finite (μ i)] (i : fin (n + 1)) :\n    measure_preserving (measurable_equiv.pi_fin_succ_above_equiv α i) (measure.pi μ)\n      ((μ i).prod <| measure.pi fun j => μ (i.succ_above j)) :=\n  by\n  set e := (measurable_equiv.pi_fin_succ_above_equiv α i).symm\n  refine' measure_preserving.symm e _\n  refine' ⟨e.measurable, (pi_eq fun s hs => _).symm⟩\n  rw [e.map_apply, i.prod_univ_succ_above _, ← pi_pi, ← prod_prod]\n  congr 1 with ⟨x, f⟩\n  simp [i.forall_iff_succ_above]\n#align measure_preserving_pi_fin_succ_above_equiv measure_preserving_pi_fin_succ_above_equiv\n\n",
 "measure_preserving_pi_equiv_pi_subtype_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\ntheorem measure_preserving_pi_equiv_pi_subtype_prod {ι : Type u} {α : ι → Type v} [fintype ι]\n    {m : ∀ i, measurable_space (α i)} (μ : ∀ i, measure (α i)) [∀ i, sigma_finite (μ i)] (p : ι → Prop)\n    [decidable_pred p] :\n    measure_preserving (measurable_equiv.pi_equiv_pi_subtype_prod α p) (measure.pi μ)\n      ((measure.pi fun i : subtype p => μ i).prod (measure.pi fun i => μ i)) :=\n  by\n  set e := (measurable_equiv.pi_equiv_pi_subtype_prod α p).symm\n  refine' measure_preserving.symm e _\n  refine' ⟨e.measurable, (pi_eq fun s hs => _).symm⟩\n  have :\n    «expr ⁻¹' » e (pi univ s) =\n      lower_set.prod (pi univ fun i : { i // p i } => s i) (pi univ fun i : { i // ¬p i } => s i) :=\n    Equiv.preimage_piEquivPiSubtypeProd_symm_pi p s\n  rw [e.map_apply, this, prod_prod, pi_pi, pi_pi]\n  exact fintype.prod_subtype_mul_prod_subtype p fun i => μ i (s i)\n#align measure_preserving_pi_equiv_pi_subtype_prod measure_preserving_pi_equiv_pi_subtype_prod\n\n",
 "measure_preserving_pi_empty":
 "theorem measure_preserving_pi_empty {ι : Type u} {α : ι → Type v} [is_empty ι] {m : ∀ i, measurable_space (α i)}\n    (μ : ∀ i, measure (α i)) :\n    measure_preserving (measurable_equiv.of_unique_of_unique (∀ i, α i) unit) (measure.pi μ) (measure.dirac ()) :=\n  by\n  set e := measurable_equiv.of_unique_of_unique (∀ i, α i) unit\n  refine' ⟨e.measurable, _⟩\n  rw [measure.pi_of_empty, measure.map_dirac e.measurable]; rfl\n#align measure_preserving_pi_empty measure_preserving_pi_empty\n\n",
 "measure_preserving_fun_unique":
 "theorem measure_preserving_fun_unique {β : Type u} {m : measurable_space β} (μ : measure β) (α : Type v) [unique α] :\n    measure_preserving (measurable_equiv.fun_unique α β) (measure.pi fun a : α => μ) μ :=\n  by\n  set e := measurable_equiv.fun_unique α β\n  have : (pi_premeasure fun _ : α => μ.to_outer_measure) = measure.map e.symm μ :=\n    by\n    ext1 s\n    rw [pi_premeasure, fintype.prod_unique, to_outer_measure_apply, e.symm.map_apply]\n    congr 1\n    exact e.to_equiv.image_eq_preimage s\n  simp only [measure.pi, outer_measure.pi, this, bounded_by_measure, to_outer_measure_to_measure]\n  exact (e.symm.measurable.measure_preserving _).symm e.symm\n#align measure_preserving_fun_unique measure_preserving_fun_unique\n\n",
 "measure_preserving_fin_two_arrow_vec":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr![ ,]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr![ ,]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr![ ,]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr![ ,]» -/\ntheorem measure_preserving_fin_two_arrow_vec {α : Type u} {m : measurable_space α} (μ ν : measure α) [sigma_finite μ]\n    [sigma_finite ν] :\n    measure_preserving measurable_equiv.fin_two_arrow\n      (measure.pi («expr![ ,]» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr![ ,]»\"))\n      (μ.prod ν) :=\n  haveI :\n    ∀ i,\n      sigma_finite\n        ((«expr![ ,]» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr![ ,]»\") i) :=\n    Fin.forall_fin_two.2 ⟨‹_›, ‹_›⟩\n  measure_preserving_pi_fin_two _\n#align measure_preserving_fin_two_arrow_vec measure_preserving_fin_two_arrow_vec\n\n",
 "measure_preserving_fin_two_arrow":
 "theorem measure_preserving_fin_two_arrow {α : Type u} {m : measurable_space α} (μ : measure α) [sigma_finite μ] :\n    measure_preserving measurable_equiv.fin_two_arrow (measure.pi fun _ => μ) (μ.prod μ) := by\n  simpa only [matrix.vec_single_eq_const, matrix.vec_cons_const] using measure_preserving_fin_two_arrow_vec μ μ\n#align measure_preserving_fin_two_arrow measure_preserving_fin_two_arrow\n\n",
 "le_pi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\ntheorem le_pi {m : ∀ i, outer_measure (α i)} {n : outer_measure (∀ i, α i)} :\n    n ≤ outer_measure.pi m ↔\n      ∀ s : ∀ i, set (α i),\n        (pi univ s).nonempty →\n          n (pi univ s) ≤\n            finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n              (m i (s i)) :=\n  by\n  rw [outer_measure.pi, le_bounded_by']; constructor\n  · intro h s hs\n    refine' (h _ hs).trans_eq (pi_premeasure_pi hs)\n  · intro h s hs\n    refine' le_trans (n.mono <| subset_pi_eval_image univ s) (h _ _)\n    simp [univ_pi_nonempty_iff, hs]\n#align le_pi le_pi\n\n",
 "is_pi_system_pi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/-- Boxes form a π-system. -/\ntheorem is_pi_system_pi [∀ i, measurable_space (α i)] :\n    is_pi_system («expr '' » (pi univ) (pi univ fun i => { s : set (α i) | measurable_set s })) :=\n  is_pi_system.pi fun i => is_pi_system_measurable_set\n#align is_pi_system_pi is_pi_system_pi\n\n",
 "generate_from_pi_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/-- The product of generated σ-algebras is the one generated by boxes, if both generating sets\n  are countably spanning. -/\ntheorem generate_from_pi_eq {C : ∀ i, set (set (α i))} (hC : ∀ i, is_countably_spanning (C i)) :\n    (@measurable_space.pi _ _ fun i => generate_from (C i)) = generate_from («expr '' » (pi univ) (pi univ C)) :=\n  by\n  cases nonempty_encodable ι\n  apply le_antisymm\n  · refine' supᵢ_le _\n    intro i\n    rw [comap_generate_from]\n    apply generate_from_le\n    rintro _ ⟨s, hs, rfl⟩\n    dsimp\n    choose t h1t h2t using hC\n    simp_rw [eval_preimage, ← h2t]\n    rw [← @Union_const _ ℕ _ s]\n    have :\n      pi univ\n          (update (fun i' : ι => Union (t i')) i\n            («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" s)) =\n        pi univ fun k =>\n          «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n            (@update ι (fun i' => set (α i')) _ (fun i' => t i' j) i s k) :=\n      by\n      ext\n      simp_rw [mem_univ_pi]\n      apply forall_congr'\n      intro i'\n      by_cases i' = i\n      · subst h\n        simp\n      · rw [← ne.def] at h\n        simp [h]\n    rw [this, ← Union_univ_pi]\n    apply measurable_set.Union\n    intro n\n    apply measurable_set_generate_from\n    apply mem_image_of_mem\n    intro j _\n    dsimp only\n    by_cases h : j = i\n    subst h\n    rwa [update_same]\n    rw [update_noteq h]\n    apply h1t\n  · apply generate_from_le\n    rintro _ ⟨s, hs, rfl⟩\n    rw [univ_pi_eq_Inter]\n    apply measurable_set.Inter\n    intro i\n    apply measurable_pi_apply\n    exact measurable_set_generate_from (hs i (mem_univ i))\n#align generate_from_pi_eq generate_from_pi_eq\n\n",
 "generate_from_pi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/-- The product σ-algebra is generated from boxes, i.e. `s ×ˢ t` for sets `s : set α` and\n  `t : set β`. -/\ntheorem generate_from_pi [∀ i, measurable_space (α i)] :\n    generate_from («expr '' » (pi univ) (pi univ fun i => { s : set (α i) | measurable_set s })) =\n      measurable_space.pi :=\n  generate_from_eq_pi (fun i => generate_from_measurable_set) fun i => is_countably_spanning_measurable_set\n#align generate_from_pi generate_from_pi\n\n",
 "generate_from_eq_pi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/-- If `C` and `D` generate the σ-algebras on `α` resp. `β`, then rectangles formed by `C` and `D`\n  generate the σ-algebra on `α × β`. -/\ntheorem generate_from_eq_pi [h : ∀ i, measurable_space (α i)] {C : ∀ i, set (set (α i))}\n    (hC : ∀ i, generate_from (C i) = h i) (h2C : ∀ i, is_countably_spanning (C i)) :\n    generate_from («expr '' » (pi univ) (pi univ C)) = measurable_space.pi := by\n  rw [← funext hC, generate_from_pi_eq h2C]\n#align generate_from_eq_pi generate_from_eq_pi\n\n",
 "ae_pi_le_pi":
 "theorem ae_pi_le_pi : (measure.pi μ).ae ≤ filter.pi fun i => (μ i).ae :=\n  le_infᵢ fun i => tendsto_eval_ae_ae.le_comap\n#align ae_pi_le_pi ae_pi_le_pi\n\n",
 "ae_le_set_pi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≤ᵐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≤ᵐ[ ] » -/\ntheorem ae_le_set_pi {I : set ι} {s t : ∀ i, set (α i)} (h : ∀ i ∈ I, «expr ≤ᵐ[ ] » (s i) (μ i) (t i)) :\n    «expr ≤ᵐ[ ] » (Set.pi I s) (measure.pi μ) (Set.pi I t) :=\n  ((eventually_all_finite I.to_finite).2 fun i hi => tendsto_eval_ae_ae.eventually (h i hi)).mono fun x hst hx i hi =>\n    hst i hi <| hx i hi\n#align ae_le_set_pi ae_le_set_pi\n\n",
 "ae_le_pi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≤ᵐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≤ᵐ[ ] » -/\ntheorem ae_le_pi {β : ι → Type _} [∀ i, preorder (β i)] {f f' : ∀ i, α i → β i}\n    (h : ∀ i, «expr ≤ᵐ[ ] » (f i) (μ i) (f' i)) :\n    «expr ≤ᵐ[ ] » (fun (x : ∀ i, α i) i => f i (x i)) (measure.pi μ) fun x i => f' i (x i) :=\n  (eventually_all.2 fun i => tendsto_eval_ae_ae.eventually (h i)).mono fun x hx => hx\n#align ae_le_pi ae_le_pi\n\n",
 "ae_eval_ne":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\ntheorem ae_eval_ne (i : ι) [has_no_atoms (μ i)] (x : α i) :\n    «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\" (measure.pi μ)\n      (y i ≠ x) :=\n  compl_mem_ae_iff.2 (pi_hyperplane μ i x)\n#align ae_eval_ne ae_eval_ne\n\n",
 "ae_eq_set_pi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\ntheorem ae_eq_set_pi {I : set ι} {s t : ∀ i, set (α i)} (h : ∀ i ∈ I, «expr =ᵐ[ ] » (s i) (μ i) (t i)) :\n    «expr =ᵐ[ ] » (Set.pi I s) (measure.pi μ) (Set.pi I t) :=\n  (ae_le_set_pi fun i hi => (h i hi).le).antisymm (ae_le_set_pi fun i hi => (h i hi).symm.le)\n#align ae_eq_set_pi ae_eq_set_pi\n\n",
 "ae_eq_pi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\ntheorem ae_eq_pi {β : ι → Type _} {f f' : ∀ i, α i → β i} (h : ∀ i, «expr =ᵐ[ ] » (f i) (μ i) (f' i)) :\n    «expr =ᵐ[ ] » (fun (x : ∀ i, α i) i => f i (x i)) (measure.pi μ) fun x i => f' i (x i) :=\n  (eventually_all.2 fun i => tendsto_eval_ae_ae.eventually (h i)).mono fun x hx => funext hx\n#align ae_eq_pi ae_eq_pi\n\n"}