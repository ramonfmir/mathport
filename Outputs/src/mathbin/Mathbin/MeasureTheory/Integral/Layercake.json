{"meas_le_ne_meas_lt_subset_meas_pos":
 "theorem meas_le_ne_meas_lt_subset_meas_pos {R : Type _} [linear_order R] [MeasurableSpace R]\n    [MeasurableSingletonClass R] {g : α → R} (g_mble : Measurable g) {t : R}\n    (ht : μ { a : α | t ≤ g a } ≠ μ { a : α | t < g a }) : 0 < μ { a : α | g a = t } :=\n  by\n  have uni : { a : α | t ≤ g a } = { a : α | t < g a } ∪ { a : α | t = g a } :=\n    by\n    ext a\n    simp only [mem_set_of_eq, mem_union]\n    apply le_iff_lt_or_eq\n  rw [show { a : α | t = g a } = { a : α | g a = t } by simp_rw [eq_comm]] at uni\n  have disj : { a : α | t < g a } ∩ { a : α | g a = t } = ∅ :=\n    by\n    ext a\n    simp only [mem_inter_iff, mem_set_of_eq, mem_empty_iff_false, iff_false_iff, not_and]\n    exact ne_of_gt\n  have μ_add : μ { a : α | t ≤ g a } = μ { a : α | t < g a } + μ { a : α | g a = t } := by\n    rw [uni, measure_union (disjoint_iff_inter_eq_empty.mpr disj) (g_mble (finite.measurable_set (finite_singleton t)))]\n  by_contra con\n  rw [not_lt, nonpos_iff_eq_zero] at con\n  rw [Con, add_zero] at μ_add\n  exact ht μ_add\n#align meas_le_ne_meas_lt_subset_meas_pos meas_le_ne_meas_lt_subset_meas_pos\n\n",
 "meas_le_ae_eq_meas_lt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\ntheorem meas_le_ae_eq_meas_lt [SigmaFinite μ] {R : Type _} [linear_order R] [MeasurableSpace R]\n    [MeasurableSingletonClass R] (ν : measure R) [NoAtoms ν] {g : α → R} (g_mble : Measurable g) :\n    «expr =ᵐ[ ] » (fun t => μ { a : α | t ≤ g a }) ν fun t => μ { a : α | t < g a } :=\n  Set.Countable.measure_zero (measure.countable_meas_le_ne_meas_lt μ g_mble) _\n#align meas_le_ae_eq_meas_lt meas_le_ae_eq_meas_lt\n\n",
 "lintegral_rpow_eq_lintegral_meas_lt_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫⁻ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫⁻ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ in , » -/\n/-- An application of the layer cake formula / Cavalieri's principle / tail probability formula:\n\nFor a nonnegative function `f` on a sigma-finite measure space, the Lebesgue integral of `f` can\nbe written (roughly speaking) as: `∫⁻ f^p ∂μ = p * ∫⁻ t in 0 .. ∞, t^(p-1) * μ {ω | f(ω) > t}`.\n\nSee `lintegral_rpow_eq_lintegral_meas_le_mul` for a version with sets of the form `{ω | f(ω) ≥ t}`\ninstead. -/\ntheorem lintegral_rpow_eq_lintegral_meas_lt_mul (μ : measure α) [SigmaFinite μ] (f_nn : 0 ≤ f) (f_mble : Measurable f)\n    {p : exprℝ} (p_pos : 0 < p) :\n    «expr∫⁻ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ , ∂ »\"\n        (ENNReal.ofReal (f ω ^ p)) μ =\n      ENNReal.ofReal p *\n        «expr∫⁻ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ in , »\" (Ioi 0)\n          (μ { a : α | t < f a } * ENNReal.ofReal (t ^ (p - 1))) :=\n  by\n  rw [lintegral_rpow_eq_lintegral_meas_le_mul μ f_nn f_mble p_pos]\n  apply congr_arg fun z => ENNReal.ofReal p * z\n  apply lintegral_congr_ae\n  filter_upwards [measure.meas_le_ae_eq_meas_lt μ (volume.restrict (Ioi 0)) f_mble]with t ht\n  rw [ht]\n#align lintegral_rpow_eq_lintegral_meas_lt_mul lintegral_rpow_eq_lintegral_meas_lt_mul\n\n",
 "lintegral_rpow_eq_lintegral_meas_le_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ in .. , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ in .. , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫⁻ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫⁻ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ in , » -/\n/-- An application of the layer cake formula / Cavalieri's principle / tail probability formula:\n\nFor a nonnegative function `f` on a sigma-finite measure space, the Lebesgue integral of `f` can\nbe written (roughly speaking) as: `∫⁻ f^p ∂μ = p * ∫⁻ t in 0 .. ∞, t^(p-1) * μ {ω | f(ω) ≥ t}`.\n\nSee `lintegral_rpow_eq_lintegral_meas_lt_mul` for a version with sets of the form `{ω | f(ω) > t}`\ninstead. -/\ntheorem lintegral_rpow_eq_lintegral_meas_le_mul (μ : Measure α) [SigmaFinite μ] (f_nn : 0 ≤ f) (f_mble : Measurable f)\n    {p : exprℝ} (p_pos : 0 < p) :\n    «expr∫⁻ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ , ∂ »\"\n        (ENNReal.ofReal (f ω ^ p)) μ =\n      ENNReal.ofReal p *\n        «expr∫⁻ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ in , »\" (Ioi 0)\n          (μ { a : α | t ≤ f a } * ENNReal.ofReal (t ^ (p - 1))) :=\n  by\n  have one_lt_p : -1 < p - 1 := by linarith\n  have obs :\n    ∀ x : exprℝ,\n      «expr∫ in .. , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ in .. , »\" 0 x\n          (t ^ (p - 1)) =\n        x ^ p / p :=\n    by\n    intro x\n    rw [integral_rpow (or.inl one_lt_p)]\n    simp [real.zero_rpow p_pos.ne.symm]\n  set g := fun t : exprℝ => t ^ (p - 1) with g_def\n  have g_nn :\n    «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\"\n      (volume.restrict (Ioi (0 : exprℝ))) (0 ≤ g t) :=\n    by\n    filter_upwards [self_mem_ae_restrict (measurable_set_Ioi : MeasurableSet (Ioi (0 : exprℝ)))]\n    intro t t_pos\n    rw [g_def]\n    exact real.rpow_nonneg_of_nonneg (mem_Ioi.mp t_pos).le (p - 1)\n  have g_intble : ∀ t > 0, interval_integrable g volume 0 t := fun _ _ =>\n    interval_integral.interval_integrable_rpow' one_lt_p\n  have key := lintegral_comp_eq_lintegral_meas_le_mul μ f_nn f_mble g_intble g_nn\n  simp_rw [g_def] at key\n  rw [← key, ← lintegral_const_mul (ENNReal.ofReal p)] <;> simp_rw [obs]\n  · congr with ω\n    rw [← ENNReal.ofReal_mul p_pos.le, mul_div_cancel' (f ω ^ p) p_pos.ne.symm]\n  · exact ((f_mble.pow measurable_const).div_const p).ennreal_of_real\n#align lintegral_rpow_eq_lintegral_meas_le_mul lintegral_rpow_eq_lintegral_meas_le_mul\n\n",
 "lintegral_eq_lintegral_meas_lt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫⁻ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫⁻ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ in , » -/\n/-- The standard case of the layer cake formula / Cavalieri's principle / tail probability formula:\n\nFor a nonnegative function `f` on a sigma-finite measure space, the Lebesgue integral of `f` can\nbe written (roughly speaking) as: `∫⁻ f ∂μ = ∫⁻ t in 0 .. ∞, μ {ω | f(ω) > t}`.\n\nSee `lintegral_eq_lintegral_meas_le` for a version with sets of the form `{ω | f(ω) ≥ t}`\ninstead. -/\ntheorem lintegral_eq_lintegral_meas_lt (μ : measure α) [SigmaFinite μ] (f_nn : 0 ≤ f) (f_mble : Measurable f) :\n    «expr∫⁻ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ , ∂ »\"\n        (ENNReal.ofReal (f ω)) μ =\n      «expr∫⁻ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ in , »\" (Ioi 0)\n        (μ { a : α | t < f a }) :=\n  by\n  rw [lintegral_eq_lintegral_meas_le μ f_nn f_mble]\n  apply lintegral_congr_ae\n  filter_upwards [measure.meas_le_ae_eq_meas_lt μ (volume.restrict (Ioi 0)) f_mble]with t ht\n  rw [ht]\n#align lintegral_eq_lintegral_meas_lt lintegral_eq_lintegral_meas_lt\n\n",
 "lintegral_eq_lintegral_meas_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫⁻ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫⁻ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ in , » -/\n/-- The standard case of the layer cake formula / Cavalieri's principle / tail probability formula:\n\nFor a nonnegative function `f` on a sigma-finite measure space, the Lebesgue integral of `f` can\nbe written (roughly speaking) as: `∫⁻ f ∂μ = ∫⁻ t in 0 .. ∞, μ {ω | f(ω) ≥ t}`.\n\nSee `lintegral_eq_lintegral_meas_lt` for a version with sets of the form `{ω | f(ω) > t}`\ninstead. -/\ntheorem lintegral_eq_lintegral_meas_le (μ : Measure α) [SigmaFinite μ] (f_nn : 0 ≤ f) (f_mble : Measurable f) :\n    «expr∫⁻ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ , ∂ »\"\n        (ENNReal.ofReal (f ω)) μ =\n      «expr∫⁻ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ in , »\" (Ioi 0)\n        (μ { a : α | t ≤ f a }) :=\n  by\n  set cst := fun t : exprℝ => (1 : exprℝ) with def_cst\n  have cst_intble : ∀ t > 0, interval_integrable cst volume 0 t := fun _ _ => interval_integrable_const\n  have key :=\n    lintegral_comp_eq_lintegral_meas_le_mul μ f_nn f_mble cst_intble (eventually_of_forall fun t => zero_le_one)\n  simp_rw [def_cst, ENNReal.ofReal_one, mul_one] at key\n  rw [← key]\n  congr with ω\n  simp only [interval_integral.integral_const, sub_zero, Algebra.id.smul_eq_mul, mul_one]\n#align lintegral_eq_lintegral_meas_le lintegral_eq_lintegral_meas_le\n\n",
 "lintegral_comp_eq_lintegral_meas_lt_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫⁻ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ in .. , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ in .. , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫⁻ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ in , » -/\n/-- The layer cake formula / Cavalieri's principle / tail probability formula:\n\nLet `f` be a non-negative measurable function on a sigma-finite measure space. Let `G` be an\nincreasing absolutely continuous function on the positive real line, vanishing at the origin,\nwith derivative `G' = g`. Then the integral of the composition `G ∘ f` can be written as\nthe integral over the positive real line of the \"tail measures\" `μ {ω | f(ω) > t}` of `f`\nweighted by `g`.\n\nRoughly speaking, the statement is: `∫⁻ (G ∘ f) ∂μ = ∫⁻ t in 0 .. ∞, g(t) * μ {ω | f(ω) > t}`.\n\nSee `lintegral_comp_eq_lintegral_meas_le_mul` for a version with sets of the form `{ω | f(ω) ≥ t}`\ninstead. -/\ntheorem lintegral_comp_eq_lintegral_meas_lt_mul (μ : measure α) [SigmaFinite μ] (f_nn : 0 ≤ f) (f_mble : Measurable f)\n    (g_intble : ∀ t > 0, interval_integrable g volume 0 t)\n    (g_nn :\n      «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\"\n        (volume.restrict (Ioi 0)) (0 ≤ g t)) :\n    «expr∫⁻ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ , ∂ »\"\n        (ENNReal.ofReal\n          («expr∫ in .. , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ in .. , »\" 0\n            (f ω) (g t)))\n        μ =\n      «expr∫⁻ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ in , »\" (Ioi 0)\n        (μ { a : α | t < f a } * ENNReal.ofReal (g t)) :=\n  by\n  rw [lintegral_comp_eq_lintegral_meas_le_mul μ f_nn f_mble g_intble g_nn]\n  apply lintegral_congr_ae\n  filter_upwards [measure.meas_le_ae_eq_meas_lt μ (volume.restrict (Ioi 0)) f_mble]with t ht\n  rw [ht]\n#align lintegral_comp_eq_lintegral_meas_lt_mul lintegral_comp_eq_lintegral_meas_lt_mul\n\n",
 "lintegral_comp_eq_lintegral_meas_le_mul_of_measurable":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ in .. , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ in .. , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫⁻ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≤ᵐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫⁻ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ in .. , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ in .. , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫⁻ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ in , » -/\n/-\nCopyright (c) 2022 Kalle Kytölä. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Kalle Kytölä\n-/\n/-- An auxiliary version of the layer cake formula (Cavalieri's principle, tail probability\nformula), with a measurability assumption that would also essentially follow from the\nintegrability assumptions.\n\nSee `measure_theory.lintegral_comp_eq_lintegral_meas_le_mul` and\n`measure_theory.lintegral_comp_eq_lintegral_meas_lt_mul` for the main formulations of the layer\ncake formula. -/\ntheorem lintegral_comp_eq_lintegral_meas_le_mul_of_measurable (μ : Measure α) [SigmaFinite μ] (f_nn : 0 ≤ f)\n    (f_mble : Measurable f) (g_intble : ∀ t > 0, interval_integrable g volume 0 t) (g_mble : Measurable g)\n    (g_nn : ∀ t > 0, 0 ≤ g t) :\n    «expr∫⁻ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ , ∂ »\"\n        (ENNReal.ofReal\n          («expr∫ in .. , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ in .. , »\" 0\n            (f ω) (g t)))\n        μ =\n      «expr∫⁻ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ in , »\" (Ioi 0)\n        (μ { a : α | t ≤ f a } * ENNReal.ofReal (g t)) :=\n  by\n  have g_intble' : ∀ t : exprℝ, 0 ≤ t → interval_integrable g volume 0 t :=\n    by\n    intro t ht\n    cases eq_or_lt_of_le ht\n    · simp [← h]\n    · exact g_intble t h\n  have integrand_eq :\n    ∀ ω,\n      ENNReal.ofReal\n          («expr∫ in .. , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ in .. , »\" 0\n            (f ω) (g t)) =\n        «expr∫⁻ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ in , »\"\n          (Ioc 0 (f ω)) (ENNReal.ofReal (g t)) :=\n    by\n    intro ω\n    have g_ae_nn : «expr ≤ᵐ[ ] » 0 (volume.restrict (Ioc 0 (f ω))) g := by\n      filter_upwards [self_mem_ae_restrict\n          (measurable_set_Ioc : MeasurableSet (Ioc 0 (f ω)))]with x hx using g_nn x hx.1\n    rw [← of_real_integral_eq_lintegral_of_real (g_intble' (f ω) (f_nn ω)).1 g_ae_nn]\n    congr\n    exact interval_integral.integral_of_le (f_nn ω)\n  simp_rw [integrand_eq, ← lintegral_indicator (fun t => ENNReal.ofReal (g t)) measurable_set_Ioc, ←\n    lintegral_indicator _ measurable_set_Ioi]\n  rw [lintegral_lintegral_swap]\n  · apply congr_arg\n    funext s\n    have aux₁ :\n      (fun x => (Ioc 0 (f x)).indicator (fun t : exprℝ => ENNReal.ofReal (g t)) s) = fun x =>\n        ENNReal.ofReal (g s) * (Ioi (0 : exprℝ)).indicator (fun _ => 1) s *\n          (Ici s).indicator (fun t : exprℝ => (1 : ennreal)) (f x) :=\n      by\n      funext a\n      by_cases s ∈ Ioc (0 : exprℝ) (f a)\n      · simp only [h, show s ∈ Ioi (0 : exprℝ) from h.1, show f a ∈ Ici s from h.2, indicator_of_mem, mul_one]\n      · have h_copy := h\n        simp only [mem_Ioc, not_and, not_le] at h\n        by_cases h' : 0 < s\n        · simp only [h_copy, h h', indicator_of_not_mem, not_false_iff, mem_Ici, not_le, MulZeroClass.mul_zero]\n        · have : s ∉ Ioi (0 : exprℝ) := h'\n          simp only [this, h', indicator_of_not_mem, not_false_iff, MulZeroClass.mul_zero, MulZeroClass.zero_mul,\n            mem_Ioc, false_and_iff]\n    simp_rw [aux₁]\n    rw [lintegral_const_mul']\n    swap\n    · apply ENNReal.mul_ne_top ENNReal.ofReal_ne_top\n      by_cases s ∈ Ioi (0 : exprℝ) <;> · simp [h]\n    simp_rw [show\n        (fun a => (Ici s).indicator (fun t : exprℝ => (1 : ennreal)) (f a)) = fun a =>\n          { a : α | s ≤ f a }.indicator (fun _ => 1) a\n        by\n        funext a\n        by_cases s ≤ f a <;> simp [h]]\n    rw [lintegral_indicator]\n    swap\n    · exact f_mble measurable_set_Ici\n    rw [lintegral_one, measure.restrict_apply MeasurableSet.univ, univ_inter, indicator_mul_left, mul_assoc,\n      show\n        (Ioi 0).indicator (fun _x : exprℝ => (1 : ennreal)) s * μ { a : α | s ≤ f a } =\n          (Ioi 0).indicator (fun _x : exprℝ => 1 * μ { a : α | s ≤ f a }) s\n        by by_cases 0 < s <;> simp [h]]\n    simp_rw [mul_comm _ (ENNReal.ofReal _), one_mul]\n    rfl\n  have aux₂ :\n    (function.uncurry fun (x : α) (y : exprℝ) => (Ioc 0 (f x)).indicator (fun t : exprℝ => ENNReal.ofReal (g t)) y) =\n      { p : α × exprℝ | p.2 ∈ Ioc 0 (f p.1) }.indicator fun p => ENNReal.ofReal (g p.2) :=\n    by\n    funext p\n    cases p\n    rw [Function.uncurry_apply_pair]\n    by_cases p_snd ∈ Ioc 0 (f p_fst)\n    · have h' : (p_fst, p_snd) ∈ { p : α × exprℝ | p.snd ∈ Ioc 0 (f p.fst) } := h\n      rw [Set.indicator_of_mem h', Set.indicator_of_mem h]\n    · have h' : (p_fst, p_snd) ∉ { p : α × exprℝ | p.snd ∈ Ioc 0 (f p.fst) } := h\n      rw [Set.indicator_of_not_mem h', Set.indicator_of_not_mem h]\n  rw [aux₂]\n  have mble := measurable_set_region_between_oc measurable_zero f_mble MeasurableSet.univ\n  simp_rw [mem_univ, Pi.zero_apply, true_and_iff] at mble\n  exact (ennreal.measurable_of_real.comp (g_mble.comp measurable_snd)).ae_measurable.indicator mble\n#align lintegral_comp_eq_lintegral_meas_le_mul_of_measurable lintegral_comp_eq_lintegral_meas_le_mul_of_measurable\n\n",
 "lintegral_comp_eq_lintegral_meas_le_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫⁻ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫⁻ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ in .. , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ in .. , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ in .. , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ in .. , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫⁻ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ in .. , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ in .. , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫⁻ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ in , » -/\n/-- The layer cake formula / Cavalieri's principle / tail probability formula:\n\nLet `f` be a non-negative measurable function on a sigma-finite measure space. Let `G` be an\nincreasing absolutely continuous function on the positive real line, vanishing at the origin,\nwith derivative `G' = g`. Then the integral of the composition `G ∘ f` can be written as\nthe integral over the positive real line of the \"tail measures\" `μ {ω | f(ω) ≥ t}` of `f`\nweighted by `g`.\n\nRoughly speaking, the statement is: `∫⁻ (G ∘ f) ∂μ = ∫⁻ t in 0 .. ∞, g(t) * μ {ω | f(ω) ≥ t}`.\n\nSee `lintegral_comp_eq_lintegral_meas_lt_mul` for a version with sets of the form `{ω | f(ω) > t}`\ninstead. -/\ntheorem lintegral_comp_eq_lintegral_meas_le_mul (μ : Measure α) [SigmaFinite μ] (f_nn : 0 ≤ f) (f_mble : Measurable f)\n    (g_intble : ∀ t > 0, interval_integrable g volume 0 t)\n    (g_nn :\n      «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\"\n        (volume.restrict (Ioi 0)) (0 ≤ g t)) :\n    «expr∫⁻ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ , ∂ »\"\n        (ENNReal.ofReal\n          («expr∫ in .. , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ in .. , »\" 0\n            (f ω) (g t)))\n        μ =\n      «expr∫⁻ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ in , »\" (Ioi 0)\n        (μ { a : α | t ≤ f a } * ENNReal.ofReal (g t)) :=\n  by\n  have ex_G : ∃ G : exprℝ → exprℝ, Measurable G ∧ 0 ≤ G ∧ «expr =ᵐ[ ] » g (volume.restrict (Ioi 0)) G :=\n    by\n    refine' AEMeasurable.exists_measurable_nonneg _ g_nn\n    exact aemeasurable_Ioi_of_forall_Ioc fun t ht => (g_intble t ht).1.1.ae_measurable\n  rcases ex_G with ⟨G, G_mble, G_nn, g_eq_G⟩\n  have g_eq_G_on : ∀ t, «expr =ᵐ[ ] » g (volume.restrict (Ioc 0 t)) G := fun t =>\n    ae_mono (measure.restrict_mono Ioc_subset_Ioi_self le_rfl) g_eq_G\n  have G_intble : ∀ t > 0, interval_integrable G volume 0 t :=\n    by\n    refine' fun t t_pos => ⟨(g_intble t t_pos).1.congr_fun_ae (g_eq_G_on t), _⟩\n    rw [Ioc_eq_empty_of_le t_pos.lt.le]\n    exact integrable_on_empty\n  have eq₁ :\n    «expr∫⁻ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ in , »\" (Ioi 0)\n        (μ { a : α | t ≤ f a } * ENNReal.ofReal (g t)) =\n      «expr∫⁻ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ in , »\" (Ioi 0)\n        (μ { a : α | t ≤ f a } * ENNReal.ofReal (G t)) :=\n    by\n    apply lintegral_congr_ae\n    filter_upwards [g_eq_G]with a ha\n    rw [ha]\n  have eq₂ :\n    ∀ ω,\n      «expr∫ in .. , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ in .. , »\" 0\n          (f ω) (g t) =\n        «expr∫ in .. , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ in .. , »\" 0\n          (f ω) (G t) :=\n    by\n    refine' fun ω => interval_integral.integral_congr_ae _\n    have fω_nn : 0 ≤ f ω := f_nn ω\n    rw [uIoc_of_le fω_nn, ← ae_restrict_iff' (measurable_set_Ioc : MeasurableSet (Ioc (0 : exprℝ) (f ω)))]\n    exact g_eq_G_on (f ω)\n  simp_rw [eq₁, eq₂]\n  exact lintegral_comp_eq_lintegral_meas_le_mul_of_measurable μ f_nn f_mble G_intble G_mble fun t t_pos => G_nn t\n#align lintegral_comp_eq_lintegral_meas_le_mul lintegral_comp_eq_lintegral_meas_le_mul\n\n",
 "countable_meas_le_ne_meas_lt":
 "theorem countable_meas_le_ne_meas_lt [SigmaFinite μ] {R : Type _} [linear_order R] [MeasurableSpace R]\n    [MeasurableSingletonClass R] {g : α → R} (g_mble : Measurable g) :\n    { t : R | μ { a : α | t ≤ g a } ≠ μ { a : α | t < g a } }.countable :=\n  Countable.mono (show _ from fun t ht => meas_le_ne_meas_lt_subset_meas_pos μ g_mble ht)\n    (Measure.countable_meas_level_set_pos g_mble)\n#align countable_meas_le_ne_meas_lt countable_meas_le_ne_meas_lt\n\n"}