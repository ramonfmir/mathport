{"smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[to_additive measure_theory.measure.is_add_haar_measure.smul]\ntheorem is_haar_measure.smul {c : ennreal} (cpos : c ≠ 0) (ctop : c ≠ ennreal.top) : is_haar_measure («expr • » c μ) :=\n  { lt_top_of_is_compact := fun K hK => ENNReal.mul_lt_top Ctop hK.measure_lt_top.ne\n    to_is_open_pos_measure := openPosMeasure_smul μ cpos }\n#align is_haar_measure.smul is_haar_measure.smul\n\n",
 "regular_inv_iff":
 "@[to_additive]\ntheorem regular_inv_iff [T2Space G] : μ.inv.regular ↔ μ.regular :=\n  by\n  constructor\n  · intro h\n    rw [← μ.inv_inv]\n    exact measure.regular.inv\n  · intro h\n    exact measure.regular.inv\n#align regular_inv_iff regular_inv_iff\n\n",
 "null_iff_of_is_mul_left_invariant":
 "@[to_additive]\ntheorem null_iff_of_is_mul_left_invariant [regular μ] {s : Set G} (hs : IsOpen s) : μ s = 0 ↔ s = ∅ ∨ μ = 0 :=\n  by\n  by_cases h3μ : μ = 0; · simp [h3μ]\n  · haveI := is_open_pos_measure_of_mul_left_invariant_of_regular h3μ\n    simp only [h3μ, or_false_iff, hs.measure_eq_zero_iff μ]\n#align null_iff_of_is_mul_left_invariant null_iff_of_is_mul_left_invariant\n\n",
 "mul_right":
 "@[to_additive]\ntheorem measure_preserving.mul_right (μ : Measure G) [is_mul_right_invariant μ] (g : G) {X : Type _} [MeasurableSpace X]\n    {μ' : Measure X} {f : X → G} (hf : MeasurePreserving f μ' μ) : MeasurePreserving (fun x => f x * g) μ' μ :=\n  (measure_preserving_mul_right μ g).comp hf\n#align measure_preserving.mul_right measure_preserving.mul_right\n\n",
 "mul_left":
 "@[to_additive]\ntheorem measure_preserving.mul_left (μ : Measure G) [is_mul_left_invariant μ] (g : G) {X : Type _} [MeasurableSpace X]\n    {μ' : Measure X} {f : X → G} (hf : MeasurePreserving f μ' μ) : MeasurePreserving (fun x => g * f x) μ' μ :=\n  (measure_preserving_mul_left μ g).comp hf\n#align measure_preserving.mul_left measure_preserving.mul_left\n\n",
 "measure_univ_of_is_mul_left_invariant":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/-- In a noncompact locally compact group, a left-invariant measure which is positive\non open sets has infinite mass. -/\n@[simp,\n  to_additive\n      \"In a noncompact locally compact additive group, a left-invariant measure which\\nis positive on open sets has infinite mass.\"]\ntheorem measure_univ_of_is_mul_left_invariant [LocallyCompactSpace G] [NoncompactSpace G] (μ : Measure G)\n    [OpenPosMeasure μ] [μ.is_mul_left_invariant] : μ univ = ennreal.top :=\n  by\n  /- Consider a closed compact set `K` with nonempty interior. For any compact set `L`, one may\n    find `g = g (L)` such that `L` is disjoint from `g • K`. Iterating this, one finds\n    infinitely many translates of `K` which are disjoint from each other. As they all have the\n    same positive mass, it follows that the space has infinite measure. -/\n  obtain ⟨K, hK, Kclosed, Kint⟩ : ∃ K : Set G, IsCompact K ∧ IsClosed K ∧ (1 : G) ∈ interior K :=\n    by\n    rcases local_isCompact_isClosed_nhds_of_group (is_open_univ.mem_nhds (mem_univ (1 : G))) with ⟨K, hK⟩\n    exact ⟨K, hK.1, hK.2.1, hK.2.2.2⟩\n  have K_pos : 0 < μ K := measure_pos_of_nonempty_interior _ ⟨_, Kint⟩\n  have A : ∀ L : Set G, IsCompact L → ∃ g : G, Disjoint L («expr • » g K) := fun L hL =>\n    exists_disjoint_smul_of_isCompact hL hK\n  choose! g hg using A\n  set L : ℕ → Set G := fun n => («expr ^[ ]» (fun T => T ∪ «expr • » (g T) K) n) K with hL\n  have Lcompact : ∀ n, IsCompact (L n) := by\n    intro n\n    induction' n with n IH\n    · exact hK\n    · simp_rw [hL, iterate_succ']\n      apply IsCompact.union IH (hK.smul (g (L n)))\n  have Lclosed : ∀ n, IsClosed (L n) := by\n    intro n\n    induction' n with n IH\n    · exact Kclosed\n    · simp_rw [hL, iterate_succ']\n      apply IsClosed.union IH (Kclosed.smul (g (L n)))\n  have M : ∀ n, μ (L n) = (n + 1 : ℕ) * μ K := by\n    intro n\n    induction' n with n IH\n    · simp only [L, one_mul, algebraMap.coe_one, iterate_zero, id.def]\n    ·\n      calc\n        μ (L (n + 1)) = μ (L n) + μ («expr • » (g (L n)) K) :=\n          by\n          simp_rw [hL, iterate_succ']\n          exact measure_union' (hg _ (Lcompact _)) (Lclosed _).measurable_set\n        _ = (n + 1 + 1 : ℕ) * μ K := by simp only [IH, measure_smul, add_mul, Nat.cast_add, algebraMap.coe_one, one_mul]\n        \n  have N : tendsto (fun n => μ (L n)) at_top ((nhds) (ennreal.top * μ K)) :=\n    by\n    simp_rw [M]\n    apply ENNReal.Tendsto.mul_const _ (or.inl ENNReal.top_ne_zero)\n    exact ennreal.tendsto_nat_nhds_top.comp (tendsto_add_at_top_nat _)\n  simp only [ENNReal.top_mul', K_pos.ne', if_false] at N\n  apply top_le_iff.1\n  exact le_of_tendsto' N fun n => measure_mono (subset_univ _)\n#align measure_univ_of_is_mul_left_invariant measure_univ_of_is_mul_left_invariant\n\n",
 "measure_preserving_mul_right_inv":
 "@[to_additive]\ntheorem measure_preserving_mul_right_inv (μ : Measure G) [is_inv_invariant μ] [is_mul_left_invariant μ] (g : G) :\n    MeasurePreserving (fun t => (g * t)⁻¹) μ μ :=\n  (measure_preserving_inv μ).comp <| measure_preserving_mul_left μ g\n#align measure_preserving_mul_right_inv measure_preserving_mul_right_inv\n\n",
 "measure_preserving_mul_right":
 "@[to_additive]\ntheorem measure_preserving_mul_right (μ : Measure G) [is_mul_right_invariant μ] (g : G) :\n    MeasurePreserving (· * g) μ μ :=\n  ⟨measurable_mul_const g, map_mul_right_eq_self μ g⟩\n#align measure_preserving_mul_right measure_preserving_mul_right\n\n",
 "measure_preserving_mul_left":
 "@[to_additive]\ntheorem measure_preserving_mul_left (μ : Measure G) [is_mul_left_invariant μ] (g : G) :\n    MeasurePreserving ((· * ·) g) μ μ :=\n  ⟨measurable_const_mul g, map_mul_left_eq_self μ g⟩\n#align measure_preserving_mul_left measure_preserving_mul_left\n\n",
 "measure_preserving_inv":
 "@[to_additive]\ntheorem measure_preserving_inv (μ : Measure G) [is_inv_invariant μ] : MeasurePreserving has_inv.inv μ μ :=\n  ⟨measurable_inv, map_inv_eq_self μ⟩\n#align measure_preserving_inv measure_preserving_inv\n\n",
 "measure_preserving_div_right":
 "@[to_additive]\ntheorem measure_preserving_div_right (μ : Measure G) [is_mul_right_invariant μ] (g : G) :\n    MeasurePreserving (· / g) μ μ := by simp_rw [div_eq_mul_inv, measure_preserving_mul_right μ g⁻¹]\n#align measure_preserving_div_right measure_preserving_div_right\n\n",
 "measure_preserving_div_left":
 "@[to_additive]\ntheorem measure_preserving_div_left (μ : Measure G) [is_inv_invariant μ] [is_mul_left_invariant μ] (g : G) :\n    MeasurePreserving (fun t => g / t) μ μ := by\n  simp_rw [div_eq_mul_inv]\n  exact (measure_preserving_mul_left μ g).comp (measure_preserving_inv μ)\n#align measure_preserving_div_left measure_preserving_div_left\n\n",
 "measure_preimage_mul_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n@[simp, to_additive]\ntheorem measure_preimage_mul_right (μ : Measure G) [is_mul_right_invariant μ] (g : G) (A : Set G) :\n    μ («expr ⁻¹' » (fun h => h * g) A) = μ A :=\n  calc\n    μ («expr ⁻¹' » (fun h => h * g) A) = map (fun h => h * g) μ A := ((MeasurableEquiv.mulRight g).map_apply A).symm\n    _ = μ A := by rw [map_mul_right_eq_self μ g]\n    \n#align measure_preimage_mul_right measure_preimage_mul_right\n\n",
 "measure_preimage_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/-- We shorten this from `measure_preimage_mul_left`, since left invariant is the preferred option\n  for measures in this formalization. -/\n@[simp,\n  to_additive\n      \"We shorten this from `measure_preimage_add_left`, since left invariant is the\\npreferred option for measures in this formalization.\"]\ntheorem measure_preimage_mul (μ : Measure G) [is_mul_left_invariant μ] (g : G) (A : Set G) :\n    μ («expr ⁻¹' » (fun h => g * h) A) = μ A :=\n  calc\n    μ («expr ⁻¹' » (fun h => g * h) A) = map (fun h => g * h) μ A := ((MeasurableEquiv.mulLeft g).map_apply A).symm\n    _ = μ A := by rw [map_mul_left_eq_self μ g]\n    \n#align measure_preimage_mul measure_preimage_mul\n\n",
 "measure_preimage_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n@[to_additive]\ntheorem measure_preimage_inv (μ : Measure G) [is_inv_invariant μ] (A : Set G) : μ («expr ⁻¹' » has_inv.inv A) = μ A :=\n  μ.measure_inv A\n#align measure_preimage_inv measure_preimage_inv\n\n",
 "measure_pos_iff_nonempty_of_is_mul_left_invariant":
 "@[to_additive]\ntheorem measure_pos_iff_nonempty_of_is_mul_left_invariant [regular μ] (h3μ : μ ≠ 0) {s : Set G} (hs : IsOpen s) :\n    0 < μ s ↔ s.nonempty :=\n  pos_iff_ne_zero.trans <| measure_ne_zero_iff_nonempty_of_is_mul_left_invariant h3μ hs\n#align measure_pos_iff_nonempty_of_is_mul_left_invariant measure_pos_iff_nonempty_of_is_mul_left_invariant\n\n",
 "measure_ne_zero_iff_nonempty_of_is_mul_left_invariant":
 "@[to_additive]\ntheorem measure_ne_zero_iff_nonempty_of_is_mul_left_invariant [regular μ] (hμ : μ ≠ 0) {s : Set G} (hs : IsOpen s) :\n    μ s ≠ 0 ↔ s.nonempty := by simpa [null_iff_of_is_mul_left_invariant hs, hμ] using nonempty_iff_ne_empty.symm\n#align measure_ne_zero_iff_nonempty_of_is_mul_left_invariant measure_ne_zero_iff_nonempty_of_is_mul_left_invariant\n\n",
 "measure_lt_top_of_is_compact_of_is_mul_left_invariant'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/-- If a left-invariant measure gives finite mass to a set with nonempty interior, then\nit gives finite mass to any compact set. -/\n@[to_additive\n      \"If a left-invariant measure gives finite mass to a set with nonempty interior, then\\nit gives finite mass to any compact set.\"]\ntheorem measure_lt_top_of_is_compact_of_is_mul_left_invariant' {U : Set G} (hU : (interior U).nonempty)\n    (h : μ U ≠ ennreal.top) {K : Set G} (hK : IsCompact K) : μ K < ennreal.top :=\n  measure_lt_top_of_is_compact_of_is_mul_left_invariant (interior U) isOpen_interior hU\n    ((measure_mono interior_subset).trans_lt (lt_top_iff_ne_top.2 h)).ne hK\n#align measure_lt_top_of_is_compact_of_is_mul_left_invariant' measure_lt_top_of_is_compact_of_is_mul_left_invariant'\n\n",
 "measure_lt_top_of_is_compact_of_is_mul_left_invariant":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/-- If a left-invariant measure gives finite mass to a nonempty open set, then it gives finite mass\nto any compact set. -/\n@[to_additive\n      \"If a left-invariant measure gives finite mass to a nonempty open set, then it gives\\nfinite mass to any compact set.\"]\ntheorem measure_lt_top_of_is_compact_of_is_mul_left_invariant (U : Set G) (hU : IsOpen U) (h'U : U.nonempty)\n    (h : μ U ≠ ennreal.top) {K : Set G} (hK : IsCompact K) : μ K < ennreal.top :=\n  by\n  rw [← hU.interior_eq] at h'U\n  obtain ⟨t, hKt⟩ :\n    ∃ t : Finset G,\n      K ⊆\n        «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n          («expr ⁻¹' » (fun h : G => g * h) U) :=\n    compact_covered_by_mul_left_translates hK h'U\n  calc\n    μ K ≤\n        μ\n          («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n            («expr ⁻¹' » (fun h : G => g * h) U)) :=\n      measure_mono hKt\n    _ ≤\n        finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" t\n          (μ («expr ⁻¹' » (fun h : G => g * h) U)) :=\n      (measure_bUnion_finset_le _ _)\n    _ = Finset.card t * μ U := by simp only [measure_preimage_mul, Finset.sum_const, nsmul_eq_mul]\n    _ < ennreal.top := ENNReal.mul_lt_top (ENNReal.nat_ne_top _) h\n    \n#align measure_lt_top_of_is_compact_of_is_mul_left_invariant measure_lt_top_of_is_compact_of_is_mul_left_invariant\n\n",
 "measure_inv":
 "@[simp, to_additive]\ntheorem measure_inv (μ : Measure G) [is_inv_invariant μ] (A : Set G) : μ A⁻¹ = μ A := by rw [← inv_apply, inv_eq_self]\n#align measure_inv measure_inv\n\n",
 "map_mul_right_inv_eq_self":
 "@[to_additive]\ntheorem map_mul_right_inv_eq_self (μ : Measure G) [is_inv_invariant μ] [is_mul_left_invariant μ] (g : G) :\n    map (fun t => (g * t)⁻¹) μ = μ :=\n  (measure_preserving_mul_right_inv μ g).map_eq\n#align map_mul_right_inv_eq_self map_mul_right_inv_eq_self\n\n",
 "map_mul_right_eq_self":
 "@[to_additive]\ntheorem map_mul_right_eq_self (μ : Measure G) [is_mul_right_invariant μ] (g : G) : map (· * g) μ = μ :=\n  is_mul_right_invariant.map_mul_right_eq_self g\n#align map_mul_right_eq_self map_mul_right_eq_self\n\n",
 "map_mul_right_ae":
 "@[to_additive]\ntheorem map_mul_right_ae (μ : Measure G) [is_mul_right_invariant μ] (x : G) : Filter.map (fun h => h * x) μ.ae = μ.ae :=\n  ((MeasurableEquiv.mulRight x).map_ae μ).trans <| congr_arg ae <| map_mul_right_eq_self μ x\n#align map_mul_right_ae map_mul_right_ae\n\n",
 "map_mul_left_eq_self":
 "/-\nCopyright (c) 2020 Floris van Doorn. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Floris van Doorn\n-/\n@[to_additive]\ntheorem map_mul_left_eq_self (μ : Measure G) [is_mul_left_invariant μ] (g : G) : map ((· * ·) g) μ = μ :=\n  is_mul_left_invariant.map_mul_left_eq_self g\n#align map_mul_left_eq_self map_mul_left_eq_self\n\n",
 "map_mul_left_ae":
 "@[to_additive]\ntheorem map_mul_left_ae (μ : Measure G) [is_mul_left_invariant μ] (x : G) : Filter.map (fun h => x * h) μ.ae = μ.ae :=\n  ((MeasurableEquiv.mulLeft x).map_ae μ).trans <| congr_arg ae <| map_mul_left_eq_self μ x\n#align map_mul_left_ae map_mul_left_ae\n\n",
 "map_inv_eq_self":
 "@[simp, to_additive]\ntheorem map_inv_eq_self (μ : Measure G) [is_inv_invariant μ] : map has_inv.inv μ = μ :=\n  is_inv_invariant.inv_eq_self\n#align map_inv_eq_self map_inv_eq_self\n\n",
 "map_div_right_eq_self":
 "@[to_additive]\ntheorem map_div_right_eq_self (μ : Measure G) [is_mul_right_invariant μ] (g : G) : map (· / g) μ = μ := by\n  simp_rw [div_eq_mul_inv, map_mul_right_eq_self μ g⁻¹]\n#align map_div_right_eq_self map_div_right_eq_self\n\n",
 "map_div_right_ae":
 "@[to_additive]\ntheorem map_div_right_ae (μ : Measure G) [is_mul_right_invariant μ] (x : G) : Filter.map (fun t => t / x) μ.ae = μ.ae :=\n  ((MeasurableEquiv.divRight x).map_ae μ).trans <| congr_arg ae <| map_div_right_eq_self μ x\n#align map_div_right_ae map_div_right_ae\n\n",
 "map_div_left_eq_self":
 "@[to_additive]\ntheorem map_div_left_eq_self (μ : Measure G) [is_inv_invariant μ] [is_mul_left_invariant μ] (g : G) :\n    map (fun t => g / t) μ = μ :=\n  (measure_preserving_div_left μ g).map_eq\n#align map_div_left_eq_self map_div_left_eq_self\n\n",
 "map_div_left_ae":
 "@[to_additive]\ntheorem map_div_left_ae (μ : Measure G) [is_mul_left_invariant μ] [is_inv_invariant μ] (x : G) :\n    Filter.map (fun t => x / t) μ.ae = μ.ae :=\n  ((MeasurableEquiv.divLeft x).map_ae μ).trans <| congr_arg ae <| map_div_left_eq_self μ x\n#align map_div_left_ae map_div_left_ae\n\n",
 "is_open_pos_measure_of_mul_left_invariant_of_regular":
 "/-- A nonzero left-invariant regular measure gives positive mass to any open set. -/\n@[to_additive \"A nonzero left-invariant regular measure gives positive mass to any open set.\"]\ntheorem is_open_pos_measure_of_mul_left_invariant_of_regular [regular μ] (h₀ : μ ≠ 0) : OpenPosMeasure μ :=\n  let ⟨K, hK, h2K⟩ := regular.exists_compact_not_null.mpr h₀\n  is_open_pos_measure_of_mul_left_invariant_of_compact K hK h2K\n#align is_open_pos_measure_of_mul_left_invariant_of_regular is_open_pos_measure_of_mul_left_invariant_of_regular\n\n",
 "is_open_pos_measure_of_mul_left_invariant_of_compact":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/-- If a left-invariant measure gives positive mass to a compact set, then it gives positive mass to\nany open set. -/\n@[to_additive\n      \"If a left-invariant measure gives positive mass to a compact set, then it gives\\npositive mass to any open set.\"]\ntheorem is_open_pos_measure_of_mul_left_invariant_of_compact (K : Set G) (hK : IsCompact K) (h : μ K ≠ 0) :\n    OpenPosMeasure μ := by\n  refine' ⟨fun U hU hne => _⟩\n  contrapose! h\n  rw [← nonpos_iff_eq_zero]\n  rw [← hU.interior_eq] at hne\n  obtain ⟨t, hKt⟩ :\n    ∃ t : Finset G,\n      K ⊆\n        «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n          («expr ⁻¹' » (fun h : G => g * h) U) :=\n    compact_covered_by_mul_left_translates hK hne\n  calc\n    μ K ≤\n        μ\n          («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n            («expr ⁻¹' » (fun h : G => g * h) U)) :=\n      measure_mono hKt\n    _ ≤\n        finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" t\n          (μ («expr ⁻¹' » (fun h : G => g * h) U)) :=\n      (measure_bUnion_finset_le _ _)\n    _ = 0 := by simp [measure_preimage_mul, h]\n    \n#align is_open_pos_measure_of_mul_left_invariant_of_compact is_open_pos_measure_of_mul_left_invariant_of_compact\n\n",
 "is_mul_left_invariant_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₙ* » -/\n@[to_additive]\ntheorem is_mul_left_invariant_map {H : Type _} [MeasurableSpace H] [Mul H] [MeasurableMul H] [is_mul_left_invariant μ]\n    (f : «expr →ₙ* » G H) (hf : Measurable f) (h_surj : surjective f) : is_mul_left_invariant (Measure.map f μ) :=\n  by\n  refine' ⟨fun h => _⟩\n  rw [map_map (measurable_const_mul _) hf]\n  obtain ⟨g, rfl⟩ := h_surj h\n  conv_rhs => rw [← map_mul_left_eq_self μ g]\n  rw [map_map hf (measurable_const_mul _)]\n  congr 2\n  ext y\n  simp only [comp_app, map_mul]\n#align is_mul_left_invariant_map is_mul_left_invariant_map\n\n",
 "is_haar_measure_of_is_compact_nonempty_interior":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/-- If a left-invariant measure gives positive mass to some compact set with nonempty interior, then\nit is a Haar measure. -/\n@[to_additive\n      \"If a left-invariant measure gives positive mass to some compact set with nonempty\\ninterior, then it is an additive Haar measure.\"]\ntheorem is_haar_measure_of_is_compact_nonempty_interior [TopologicalGroup G] [borel_space G] (μ : Measure G)\n    [is_mul_left_invariant μ] (K : Set G) (hK : IsCompact K) (h'K : (interior K).nonempty) (h : μ K ≠ 0)\n    (h' : μ K ≠ ennreal.top) : is_haar_measure μ :=\n  { lt_top_of_is_compact := fun L hL => measure_lt_top_of_is_compact_of_is_mul_left_invariant' h'K h' hL\n    to_is_open_pos_measure := is_open_pos_measure_of_mul_left_invariant_of_compact K hK h }\n#align is_haar_measure_of_is_compact_nonempty_interior is_haar_measure_of_is_compact_nonempty_interior\n\n",
 "is_haar_measure_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₜ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃* » -/\n/-- A convenience wrapper for `measure_theory.measure.is_haar_measure_map`. -/\n@[to_additive \"A convenience wrapper for `measure_theory.measure.is_add_haar_measure_map`.\"]\ntheorem _root_.mul_equiv.is_haar_measure_map [borel_space G] [TopologicalGroup G] {H : Type _} [Group H]\n    [TopologicalSpace H] [MeasurableSpace H] [borel_space H] [T2Space H] [TopologicalGroup H] (e : «expr ≃* » G H)\n    (he : Continuous e) (hesymm : Continuous e.symm) : is_haar_measure (Measure.map e μ) :=\n  is_haar_measure_map μ (e : «expr →* » G H) he e.surjective\n    ({ e with } : «expr ≃ₜ » G H).to_cocompact_map.cocompact_tendsto'\n#align mul_equiv.is_haar_measure_map mul_equiv.is_haar_measure_map\n\n",
 "inv_inv":
 "#print inv_inv /-\n@[simp, to_additive]\nprotected theorem inv_inv (μ : Measure G) : μ.inv.inv = μ :=\n  (MeasurableEquiv.inv G).map_symm_map\n#align inv_inv inv_inv\n#align neg_neg neg_neg\n-/\n\n",
 "inv_eq_self":
 "@[simp, to_additive]\ntheorem inv_eq_self (μ : Measure G) [is_inv_invariant μ] : μ.inv = μ :=\n  is_inv_invariant.inv_eq_self\n#align inv_eq_self inv_eq_self\n\n",
 "inv_apply":
 "@[simp, to_additive]\ntheorem inv_apply (μ : Measure G) (s : Set G) : μ.inv s = μ s⁻¹ :=\n  (MeasurableEquiv.inv G).map_apply s\n#align inv_apply inv_apply\n\n",
 "haar_singleton":
 "@[simp, to_additive]\ntheorem haar_singleton [TopologicalGroup G] [borel_space G] (g : G) : μ {g} = μ {(1 : G)} :=\n  by\n  convert measure_preimage_mul μ g⁻¹ _\n  simp only [mul_one, preimage_mul_left_singleton, inv_inv]\n#align haar_singleton haar_singleton\n\n",
 "forall_measure_preimage_mul_right_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/-- An alternative way to prove that `μ` is right invariant under multiplication. -/\n@[to_additive \" An alternative way to prove that `μ` is right invariant under addition. \"]\ntheorem forall_measure_preimage_mul_right_iff (μ : Measure G) :\n    (∀ (g : G) (A : Set G), MeasurableSet A → μ («expr ⁻¹' » (fun h => h * g) A) = μ A) ↔ is_mul_right_invariant μ :=\n  by\n  trans ∀ g, map (· * g) μ = μ\n  · simp_rw [measure.ext_iff]\n    refine' forall_congr' fun g => forall_congr' fun A => forall_congr' fun hA => _\n    rw [map_apply (measurable_mul_const g) hA]\n  exact ⟨fun h => ⟨h⟩, fun h => h.1⟩\n#align forall_measure_preimage_mul_right_iff forall_measure_preimage_mul_right_iff\n\n",
 "forall_measure_preimage_mul_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/-- An alternative way to prove that `μ` is left invariant under multiplication. -/\n@[to_additive \" An alternative way to prove that `μ` is left invariant under addition. \"]\ntheorem forall_measure_preimage_mul_iff (μ : Measure G) :\n    (∀ (g : G) (A : Set G), MeasurableSet A → μ («expr ⁻¹' » (fun h => g * h) A) = μ A) ↔ is_mul_left_invariant μ :=\n  by\n  trans ∀ g, map ((· * ·) g) μ = μ\n  · simp_rw [measure.ext_iff]\n    refine' forall_congr' fun g => forall_congr' fun A => forall_congr' fun hA => _\n    rw [map_apply (measurable_const_mul g) hA]\n  exact ⟨fun h => ⟨h⟩, fun h => h.1⟩\n#align forall_measure_preimage_mul_iff forall_measure_preimage_mul_iff\n\n",
 "eventually_mul_right_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\n@[to_additive]\ntheorem eventually_mul_right_iff (μ : Measure G) [is_mul_right_invariant μ] (t : G) {p : G → Prop} :\n    «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\" μ\n        (p (x * t)) ↔\n      «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\" μ (p x) :=\n  by\n  conv_rhs => rw [Filter.Eventually, ← map_mul_right_ae μ t]\n  rfl\n#align eventually_mul_right_iff eventually_mul_right_iff\n\n",
 "eventually_mul_left_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\n@[to_additive]\ntheorem eventually_mul_left_iff (μ : Measure G) [is_mul_left_invariant μ] (t : G) {p : G → Prop} :\n    «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\" μ\n        (p (t * x)) ↔\n      «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\" μ (p x) :=\n  by\n  conv_rhs => rw [Filter.Eventually, ← map_mul_left_ae μ t]\n  rfl\n#align eventually_mul_left_iff eventually_mul_left_iff\n\n",
 "eventually_div_right_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\n@[to_additive]\ntheorem eventually_div_right_iff (μ : Measure G) [is_mul_right_invariant μ] (t : G) {p : G → Prop} :\n    «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\" μ\n        (p (x / t)) ↔\n      «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\" μ (p x) :=\n  by\n  conv_rhs => rw [Filter.Eventually, ← map_div_right_ae μ t]\n  rfl\n#align eventually_div_right_iff eventually_div_right_iff\n\n"}