{"vadd_ae_eq_self_of_mem_zmultiples":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr +ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr +ᵥ » -/\ntheorem vadd_ae_eq_self_of_mem_zmultiples {G : Type _} [measurable_space G] [add_group G] [AddAction G α]\n    [vadd_invariant_measure G α μ] [has_measurable_vadd G α] {x y : G} (hs : «expr =ᵐ[ ] » («expr +ᵥ » x s : set α) μ s)\n    (hy : y ∈ add_subgroup.zmultiples x) : «expr =ᵐ[ ] » («expr +ᵥ » y s : set α) μ s :=\n  by\n  letI : measurable_space (Multiplicative G) := (by infer_instance : measurable_space G)\n  letI : smul_invariant_measure (Multiplicative G) α μ :=\n    ⟨fun g => vadd_invariant_measure.measure_preimage_vadd μ (Multiplicative.toAdd g)⟩\n  letI : has_measurable_smul (Multiplicative G) α :=\n    { measurable_const_smul := fun g => measurable_const_vadd (Multiplicative.toAdd g)\n      measurable_smul_const := fun a =>\n        @measurable_vadd_const (Multiplicative G) α (by infer_instance : VAdd G α) _ _\n          (by infer_instance : has_measurable_vadd G α) a }\n  exact @smul_ae_eq_self_of_mem_zpowers (Multiplicative G) α _ _ _ _ _ _ _ _ _ _ hs hy\n#align vadd_ae_eq_self_of_mem_zmultiples vadd_ae_eq_self_of_mem_zmultiples\n\n",
 "smul_invariant_measure_tfae":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:219:4: warning: unsupported binary notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:219:4: warning: unsupported binary notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:219:4: warning: unsupported binary notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:219:4: warning: unsupported binary notation `«expr • » -/\n/- failed to parenthesize: parenthesize: uncaught backtrack exception\n[PrettyPrinter.parenthesize.input] (Command.declaration\n     (Command.declModifiers\n      [(Command.docComment\n        \"/--\"\n        \"Equivalent definitions of a measure invariant under a multiplicative action of a group.\\n\\n- 0: `smul_invariant_measure G α μ`;\\n\\n- 1: for every `c : G` and a measurable set `s`, the measure of the preimage of `s` under scalar\\n     multiplication by `c` is equal to the measure of `s`;\\n\\n- 2: for every `c : G` and a measurable set `s`, the measure of the image `c • s` of `s` under\\n     scalar multiplication by `c` is equal to the measure of `s`;\\n\\n- 3, 4: properties 2, 3 for any set, including non-measurable ones;\\n\\n- 5: for any `c : G`, scalar multiplication by `c` maps `μ` to `μ`;\\n\\n- 6: for any `c : G`, scalar multiplication by `c` is a measure preserving map. -/\")]\n      [(Term.attributes\n        \"@[\"\n        [(Term.attrInstance (Term.attrKind []) (to_additive \"to_additive\" [] [] (to_additiveRest [] [] [] [])))]\n        \"]\")]\n      []\n      []\n      []\n      [])\n     (Command.theorem\n      \"theorem\"\n      (Command.declId `smul_invariant_measure_tfae [])\n      (Command.declSig\n       []\n       (Term.typeSpec\n        \":\"\n        (Term.app\n         `TFAE\n         [(«term[_]»\n           \"[\"\n           [(Term.app `smul_invariant_measure [`G `α `μ])\n            \",\"\n            (Term.forall\n             \"∀\"\n             [(Term.explicitBinder \"(\" [`c] [\":\" `G] [] \")\") (Term.explicitBinder \"(\" [`s] [] [] \")\")]\n             []\n             \",\"\n             (Term.arrow\n              (Term.app `measurable_set [`s])\n              \"→\"\n              («term_=_»\n               (Term.app\n                `μ\n                [(Term.app\n                  `«expr ⁻¹' »\n                  [(Term.app (Term.paren \"(\" (Term.app `«expr • » [(Term.cdot \"·\") (Term.cdot \"·\")]) \")\") [`c]) `s])])\n               \"=\"\n               (Term.app `μ [`s]))))\n            \",\"\n            (Term.forall\n             \"∀\"\n             [(Term.explicitBinder \"(\" [`c] [\":\" `G] [] \")\") (Term.explicitBinder \"(\" [`s] [] [] \")\")]\n             []\n             \",\"\n             (Term.arrow\n              (Term.app `measurable_set [`s])\n              \"→\"\n              («term_=_» (Term.app `μ [(Term.app `«expr • » [`c `s])]) \"=\" (Term.app `μ [`s]))))\n            \",\"\n            (Term.forall\n             \"∀\"\n             [(Term.explicitBinder \"(\" [`c] [\":\" `G] [] \")\") (Term.explicitBinder \"(\" [`s] [] [] \")\")]\n             []\n             \",\"\n             («term_=_»\n              (Term.app\n               `μ\n               [(Term.app\n                 `«expr ⁻¹' »\n                 [(Term.app (Term.paren \"(\" (Term.app `«expr • » [(Term.cdot \"·\") (Term.cdot \"·\")]) \")\") [`c]) `s])])\n              \"=\"\n              (Term.app `μ [`s])))\n            \",\"\n            (Term.forall\n             \"∀\"\n             [(Term.explicitBinder \"(\" [`c] [\":\" `G] [] \")\") (Term.explicitBinder \"(\" [`s] [] [] \")\")]\n             []\n             \",\"\n             («term_=_» (Term.app `μ [(Term.app `«expr • » [`c `s])]) \"=\" (Term.app `μ [`s])))\n            \",\"\n            (Term.forall\n             \"∀\"\n             [`c]\n             [(Term.typeSpec \":\" `G)]\n             \",\"\n             («term_=_»\n              (Term.app\n               `measure.map\n               [(Term.app (Term.paren \"(\" (Term.app `«expr • » [(Term.cdot \"·\") (Term.cdot \"·\")]) \")\") [`c]) `μ])\n              \"=\"\n              `μ))\n            \",\"\n            (Term.forall\n             \"∀\"\n             [`c]\n             [(Term.typeSpec \":\" `G)]\n             \",\"\n             (Term.app\n              `measure_preserving\n              [(Term.app (Term.paren \"(\" (Term.app `«expr • » [(Term.cdot \"·\") (Term.cdot \"·\")]) \")\") [`c]) `μ `μ]))]\n           \"]\")])))\n      (Command.declValSimple\n       \":=\"\n       (Term.byTactic\n        \"by\"\n        (Tactic.tacticSeq\n         (Tactic.tacticSeq1Indented\n          [(Tactic.tfaeHave \"tfae_have\" [] (num \"1\") \"↔\" (num \"2\"))\n           \";\"\n           (Tactic.exact\n            \"exact\"\n            (Term.anonymousCtor\n             \"⟨\"\n             [(Term.fun \"fun\" (Term.basicFun [`h] [] \"=>\" (Term.proj `h \".\" (fieldIdx \"1\"))))\n              \",\"\n              (Term.fun \"fun\" (Term.basicFun [`h] [] \"=>\" (Term.anonymousCtor \"⟨\" [`h] \"⟩\")))]\n             \"⟩\"))\n           []\n           (Tactic.tfaeHave \"tfae_have\" [] (num \"1\") \"→\" (num \"6\"))\n           \";\"\n           (tactic__\n            (cdotTk (patternIgnore (token.«· » \"·\")))\n            [(Tactic.intro \"intro\" [`h `c])\n             []\n             (Tactic.exact \"exact\" (Term.proj (Term.app `measure_preserving_smul [`c `μ]) \".\" `map_eq))])\n           []\n           (Tactic.tfaeHave \"tfae_have\" [] (num \"6\") \"→\" (num \"7\"))\n           \";\"\n           (Tactic.exact\n            \"exact\"\n            (Term.fun\n             \"fun\"\n             (Term.basicFun\n              [`H `c]\n              []\n              \"=>\"\n              (Term.anonymousCtor \"⟨\" [(Term.app `measurable_const_smul [`c]) \",\" (Term.app `H [`c])] \"⟩\"))))\n           []\n           (Tactic.tfaeHave \"tfae_have\" [] (num \"7\") \"→\" (num \"4\"))\n           \";\"\n           (Tactic.exact\n            \"exact\"\n            (Term.fun\n             \"fun\"\n             (Term.basicFun\n              [`H `c]\n              []\n              \"=>\"\n              (Term.app\n               (Term.proj (Term.app `H [`c]) \".\" `measure_preimage_emb)\n               [(Term.app `measurable_embedding_const_smul [`c])]))))\n           []\n           (Tactic.tfaeHave \"tfae_have\" [] (num \"4\") \"→\" (num \"5\"))\n           \";\"\n           (Tactic.exact\n            \"exact\"\n            (Term.fun\n             \"fun\"\n             (Term.basicFun\n              [`H `c `s]\n              []\n              \"=>\"\n              (Term.byTactic\n               \"by\"\n               (Tactic.tacticSeq\n                (Tactic.tacticSeq1Indented\n                 [(Tactic.rwSeq\n                   \"rw\"\n                   []\n                   (Tactic.rwRuleSeq \"[\" [(Tactic.rwRule [(patternIgnore (token.«← » \"←\"))] `preimage_smul_inv)] \"]\")\n                   [])\n                  []\n                  (Tactic.apply \"apply\" `H)]))))))\n           []\n           (Tactic.tfaeHave \"tfae_have\" [] (num \"5\") \"→\" (num \"3\"))\n           \";\"\n           (Tactic.exact \"exact\" (Term.fun \"fun\" (Term.basicFun [`H `c `s `hs] [] \"=>\" (Term.app `H [`c `s]))))\n           []\n           (Tactic.tfaeHave \"tfae_have\" [] (num \"3\") \"→\" (num \"2\"))\n           \";\"\n           (tactic__\n            (cdotTk (patternIgnore (token.«· » \"·\")))\n            [(Tactic.intro \"intro\" [`H `c `s `hs])\n             []\n             (Tactic.rwSeq \"rw\" [] (Tactic.rwRuleSeq \"[\" [(Tactic.rwRule [] `preimage_smul)] \"]\") [])\n             []\n             (Tactic.exact \"exact\" (Term.app `H [(«term_⁻¹» `c \"⁻¹\") `s `hs]))])\n           []\n           (Tactic.tfaeFinish \"tfae_finish\")])))\n       [])\n      []\n      []))\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.byTactic\n       \"by\"\n       (Tactic.tacticSeq\n        (Tactic.tacticSeq1Indented\n         [(Tactic.tfaeHave \"tfae_have\" [] (num \"1\") \"↔\" (num \"2\"))\n          \";\"\n          (Tactic.exact\n           \"exact\"\n           (Term.anonymousCtor\n            \"⟨\"\n            [(Term.fun \"fun\" (Term.basicFun [`h] [] \"=>\" (Term.proj `h \".\" (fieldIdx \"1\"))))\n             \",\"\n             (Term.fun \"fun\" (Term.basicFun [`h] [] \"=>\" (Term.anonymousCtor \"⟨\" [`h] \"⟩\")))]\n            \"⟩\"))\n          []\n          (Tactic.tfaeHave \"tfae_have\" [] (num \"1\") \"→\" (num \"6\"))\n          \";\"\n          (tactic__\n           (cdotTk (patternIgnore (token.«· » \"·\")))\n           [(Tactic.intro \"intro\" [`h `c])\n            []\n            (Tactic.exact \"exact\" (Term.proj (Term.app `measure_preserving_smul [`c `μ]) \".\" `map_eq))])\n          []\n          (Tactic.tfaeHave \"tfae_have\" [] (num \"6\") \"→\" (num \"7\"))\n          \";\"\n          (Tactic.exact\n           \"exact\"\n           (Term.fun\n            \"fun\"\n            (Term.basicFun\n             [`H `c]\n             []\n             \"=>\"\n             (Term.anonymousCtor \"⟨\" [(Term.app `measurable_const_smul [`c]) \",\" (Term.app `H [`c])] \"⟩\"))))\n          []\n          (Tactic.tfaeHave \"tfae_have\" [] (num \"7\") \"→\" (num \"4\"))\n          \";\"\n          (Tactic.exact\n           \"exact\"\n           (Term.fun\n            \"fun\"\n            (Term.basicFun\n             [`H `c]\n             []\n             \"=>\"\n             (Term.app\n              (Term.proj (Term.app `H [`c]) \".\" `measure_preimage_emb)\n              [(Term.app `measurable_embedding_const_smul [`c])]))))\n          []\n          (Tactic.tfaeHave \"tfae_have\" [] (num \"4\") \"→\" (num \"5\"))\n          \";\"\n          (Tactic.exact\n           \"exact\"\n           (Term.fun\n            \"fun\"\n            (Term.basicFun\n             [`H `c `s]\n             []\n             \"=>\"\n             (Term.byTactic\n              \"by\"\n              (Tactic.tacticSeq\n               (Tactic.tacticSeq1Indented\n                [(Tactic.rwSeq\n                  \"rw\"\n                  []\n                  (Tactic.rwRuleSeq \"[\" [(Tactic.rwRule [(patternIgnore (token.«← » \"←\"))] `preimage_smul_inv)] \"]\")\n                  [])\n                 []\n                 (Tactic.apply \"apply\" `H)]))))))\n          []\n          (Tactic.tfaeHave \"tfae_have\" [] (num \"5\") \"→\" (num \"3\"))\n          \";\"\n          (Tactic.exact \"exact\" (Term.fun \"fun\" (Term.basicFun [`H `c `s `hs] [] \"=>\" (Term.app `H [`c `s]))))\n          []\n          (Tactic.tfaeHave \"tfae_have\" [] (num \"3\") \"→\" (num \"2\"))\n          \";\"\n          (tactic__\n           (cdotTk (patternIgnore (token.«· » \"·\")))\n           [(Tactic.intro \"intro\" [`H `c `s `hs])\n            []\n            (Tactic.rwSeq \"rw\" [] (Tactic.rwRuleSeq \"[\" [(Tactic.rwRule [] `preimage_smul)] \"]\") [])\n            []\n            (Tactic.exact \"exact\" (Term.app `H [(«term_⁻¹» `c \"⁻¹\") `s `hs]))])\n          []\n          (Tactic.tfaeFinish \"tfae_finish\")])))\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.tfaeFinish \"tfae_finish\")\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (tactic__\n       (cdotTk (patternIgnore (token.«· » \"·\")))\n       [(Tactic.intro \"intro\" [`H `c `s `hs])\n        []\n        (Tactic.rwSeq \"rw\" [] (Tactic.rwRuleSeq \"[\" [(Tactic.rwRule [] `preimage_smul)] \"]\") [])\n        []\n        (Tactic.exact \"exact\" (Term.app `H [(«term_⁻¹» `c \"⁻¹\") `s `hs]))])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.exact \"exact\" (Term.app `H [(«term_⁻¹» `c \"⁻¹\") `s `hs]))\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.app `H [(«term_⁻¹» `c \"⁻¹\") `s `hs])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `hs\n[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))\n      `s\n[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (some 1024, term)\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind '«term_⁻¹»', expected 'Lean.Parser.Term.namedArgument'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind '«term_⁻¹»', expected 'Lean.Parser.Term.ellipsis'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))\n      («term_⁻¹» `c \"⁻¹\")\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))\n      `c\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1024, term)\n[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (some 1024, term)\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))\n      `H\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1022, term)\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.rwSeq \"rw\" [] (Tactic.rwRuleSeq \"[\" [(Tactic.rwRule [] `preimage_smul)] \"]\") [])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `preimage_smul\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.intro \"intro\" [`H `c `s `hs])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `hs\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))\n      `s\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1024, term)\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))\n      `c\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1024, term)\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))\n      `H\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1024, term)\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.tfaeHave \"tfae_have\" [] (num \"3\") \"→\" (num \"2\"))\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind '«→»', expected 'token.« → »'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind '«→»', expected 'token.« ↔ »'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind '«→»', expected 'token.« ← »'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.declValEqns'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.whereStructInst'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception\n/--\n      Equivalent definitions of a measure invariant under a multiplicative action of a group.\n      \n      - 0: `smul_invariant_measure G α μ`;\n      \n      - 1: for every `c : G` and a measurable set `s`, the measure of the preimage of `s` under scalar\n           multiplication by `c` is equal to the measure of `s`;\n      \n      - 2: for every `c : G` and a measurable set `s`, the measure of the image `c • s` of `s` under\n           scalar multiplication by `c` is equal to the measure of `s`;\n      \n      - 3, 4: properties 2, 3 for any set, including non-measurable ones;\n      \n      - 5: for any `c : G`, scalar multiplication by `c` maps `μ` to `μ`;\n      \n      - 6: for any `c : G`, scalar multiplication by `c` is a measure preserving map. -/\n    @[ to_additive ]\n  theorem\n    smul_invariant_measure_tfae\n    :\n      TFAE\n        [\n          smul_invariant_measure G α μ\n            ,\n            ∀ ( c : G ) ( s ) , measurable_set s → μ «expr ⁻¹' » ( «expr • » · · ) c s = μ s\n            ,\n            ∀ ( c : G ) ( s ) , measurable_set s → μ «expr • » c s = μ s\n            ,\n            ∀ ( c : G ) ( s ) , μ «expr ⁻¹' » ( «expr • » · · ) c s = μ s\n            ,\n            ∀ ( c : G ) ( s ) , μ «expr • » c s = μ s\n            ,\n            ∀ c : G , measure.map ( «expr • » · · ) c μ = μ\n            ,\n            ∀ c : G , measure_preserving ( «expr • » · · ) c μ μ\n          ]\n    :=\n      by\n        tfae_have 1 ↔ 2\n          ;\n          exact ⟨ fun h => h . 1 , fun h => ⟨ h ⟩ ⟩\n          tfae_have 1 → 6\n          ;\n          · intro h c exact measure_preserving_smul c μ . map_eq\n          tfae_have 6 → 7\n          ;\n          exact fun H c => ⟨ measurable_const_smul c , H c ⟩\n          tfae_have 7 → 4\n          ;\n          exact fun H c => H c . measure_preimage_emb measurable_embedding_const_smul c\n          tfae_have 4 → 5\n          ;\n          exact fun H c s => by rw [ ← preimage_smul_inv ] apply H\n          tfae_have 5 → 3\n          ;\n          exact fun H c s hs => H c s\n          tfae_have 3 → 2\n          ;\n          · intro H c s hs rw [ preimage_smul ] exact H c ⁻¹ s hs\n          tfae_finish\n#align smul_invariant_measure_tfae smul_invariant_measure_tfae\n\n",
 "smul_ae_eq_self_of_mem_zpowers":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem smul_ae_eq_self_of_mem_zpowers {x y : G} (hs : «expr =ᵐ[ ] » («expr • » x s : set α) μ s)\n    (hy : y ∈ subgroup.zpowers x) : «expr =ᵐ[ ] » («expr • » y s : set α) μ s :=\n  by\n  obtain ⟨k, rfl⟩ := subgroup.mem_zpowers_iff.mp hy\n  let e : «expr ≃ » α α := MulAction.toPermHom G α x\n  have he : quasi_measure_preserving e μ μ := (measure_preserving_smul x μ).quasi_measure_preserving\n  have he' : quasi_measure_preserving e.symm μ μ := (measure_preserving_smul x⁻¹ μ).quasi_measure_preserving\n  simpa only [mul_action.to_perm_hom_apply, mul_action.to_perm_apply, image_smul, ← MonoidHom.map_zpow] using\n    he.image_zpow_ae_eq he' k hs\n#align smul_ae_eq_self_of_mem_zpowers smul_ae_eq_self_of_mem_zpowers\n\n",
 "smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[to_additive]\ntheorem null_measurable_set.smul {s} (hs : null_measurable_set s μ) (c : G) : null_measurable_set («expr • » c s) μ :=\n  by simpa only [← preimage_smul_inv] using hs.preimage (measure_preserving_smul _ _).quasi_measure_preserving\n#align null_measurable_set.smul null_measurable_set.smul\n\n",
 "measure_smul_null":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem measure_smul_null {s} (h : μ s = 0) (c : G) : μ («expr • » c s) = 0 := by rwa [measure_smul]\n#align measure_smul_null measure_smul_null\n\n",
 "measure_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp, to_additive]\ntheorem measure_smul (s : set α) : μ («expr • » c s) = μ s :=\n  ((smul_invariant_measure_tfae G μ).out 0 4).mp ‹_› c s\n#align measure_smul measure_smul\n\n",
 "measure_preserving_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:219:4: warning: unsupported binary notation `«expr • » -/\n/-\nCopyright (c) 2021 Yury G. Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury G. Kudryashov\n-/\n@[simp, to_additive]\ntheorem measure_preserving_smul : measure_preserving ((«expr • » · ·) c) μ μ :=\n  { measurable := measurable_const_smul c\n    map_eq := by\n      ext1 s hs\n      rw [map_apply (measurable_const_smul c) hs]\n      exact smul_invariant_measure.measure_preimage_smul μ c hs }\n#align measure_preserving_smul measure_preserving_smul\n\n",
 "measure_preimage_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:219:4: warning: unsupported binary notation `«expr • » -/\n@[simp, to_additive]\ntheorem measure_preimage_smul (s : set α) : μ («expr ⁻¹' » ((«expr • » · ·) c) s) = μ s :=\n  ((smul_invariant_measure_tfae G μ).out 0 3).mp ‹_› c s\n#align measure_preimage_smul measure_preimage_smul\n\n",
 "measure_pos_iff_nonempty_of_smul_invariant":
 "@[to_additive]\ntheorem measure_pos_iff_nonempty_of_smul_invariant (hμ : μ ≠ 0) (hU : is_open U) : 0 < μ U ↔ U.nonempty :=\n  ⟨fun h => nonempty_of_measure_ne_zero h.ne', measure_is_open_pos_of_smul_invariant_of_ne_zero G hμ hU⟩\n#align measure_pos_iff_nonempty_of_smul_invariant measure_pos_iff_nonempty_of_smul_invariant\n\n",
 "measure_is_open_pos_of_smul_invariant_of_ne_zero":
 "@[to_additive]\ntheorem measure_is_open_pos_of_smul_invariant_of_ne_zero (hμ : μ ≠ 0) (hU : is_open U) (hne : U.nonempty) : 0 < μ U :=\n  let ⟨K, hK, hμK⟩ := regular.exists_compact_not_null.mpr hμ\n  measure_is_open_pos_of_smul_invariant_of_compact_ne_zero G hK hμK hU hne\n#align measure_is_open_pos_of_smul_invariant_of_ne_zero measure_is_open_pos_of_smul_invariant_of_ne_zero\n\n",
 "measure_is_open_pos_of_smul_invariant_of_compact_ne_zero":
 "/-- If measure `μ` is invariant under a group action and is nonzero on a compact set `K`, then it is\npositive on any nonempty open set. In case of a regular measure, one can assume `μ ≠ 0` instead of\n`μ K ≠ 0`, see `measure_theory.measure_is_open_pos_of_smul_invariant_of_ne_zero`. -/\n@[to_additive]\ntheorem measure_is_open_pos_of_smul_invariant_of_compact_ne_zero (hK : is_compact K) (hμK : μ K ≠ 0) (hU : is_open U)\n    (hne : U.nonempty) : 0 < μ U :=\n  let ⟨t, ht⟩ := hK.exists_finite_cover_smul G hU hne\n  pos_iff_ne_zero.2 fun hμU =>\n    hμK <| measure_mono_null ht <| (measure_bUnion_null_iff t.countable_to_set).2 fun _ _ => by rwa [measure_smul]\n#align measure_is_open_pos_of_smul_invariant_of_compact_ne_zero measure_is_open_pos_of_smul_invariant_of_compact_ne_zero\n\n",
 "measure_eq_zero_iff_eq_empty_of_smul_invariant":
 "@[to_additive]\ntheorem measure_eq_zero_iff_eq_empty_of_smul_invariant (hμ : μ ≠ 0) (hU : is_open U) : μ U = 0 ↔ U = ∅ := by\n  rw [← not_iff_not, ← ne.def, ← pos_iff_ne_zero, measure_pos_iff_nonempty_of_smul_invariant G hμ hU,\n    nonempty_iff_ne_empty]\n#align measure_eq_zero_iff_eq_empty_of_smul_invariant measure_eq_zero_iff_eq_empty_of_smul_invariant\n\n",
 "map_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:219:4: warning: unsupported binary notation `«expr • » -/\n@[simp, to_additive]\ntheorem map_smul : map ((«expr • » · ·) c) μ = μ :=\n  (measure_preserving_smul c μ).map_eq\n#align map_smul map_smul\n\n",
 "is_locally_finite_measure_of_smul_invariant":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:219:4: warning: unsupported binary notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n@[to_additive]\ntheorem is_locally_finite_measure_of_smul_invariant (hU : is_open U) (hne : U.nonempty) (hμU : μ U ≠ ennreal.top) :\n    is_locally_finite_measure μ :=\n  ⟨fun x =>\n    let ⟨g, hg⟩ := hU.exists_smul_mem G x hne\n    ⟨«expr ⁻¹' » ((«expr • » · ·) g) U, (hU.preimage (continuous_id.const_smul _)).mem_nhds hg,\n      Ne.lt_top <| by rwa [measure_preimage_smul]⟩⟩\n#align is_locally_finite_measure_of_smul_invariant is_locally_finite_measure_of_smul_invariant\n\n"}