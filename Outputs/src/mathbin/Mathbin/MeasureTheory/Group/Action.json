{"vadd_ae_eq_self_of_mem_zmultiples":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr +ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr +ᵥ » -/\ntheorem vadd_ae_eq_self_of_mem_zmultiples {G : Type _} [MeasurableSpace G] [AddGroup G] [AddAction G α]\n    [vadd_invariant_measure G α μ] [MeasurableVAdd G α] {x y : G} (hs : «expr =ᵐ[ ] » («expr +ᵥ » x s : Set α) μ s)\n    (hy : y ∈ AddSubgroup.zmultiples x) : «expr =ᵐ[ ] » («expr +ᵥ » y s : Set α) μ s :=\n  by\n  letI : MeasurableSpace (Multiplicative G) := (by infer_instance : MeasurableSpace G)\n  letI : smul_invariant_measure (Multiplicative G) α μ :=\n    ⟨fun g => vadd_invariant_measure.measure_preimage_vadd μ (Multiplicative.toAdd g)⟩\n  letI : MeasurableSMul (Multiplicative G) α :=\n    { measurable_const_smul := fun g => measurable_const_vadd (Multiplicative.toAdd g)\n      measurable_smul_const := fun a =>\n        @measurable_vadd_const (Multiplicative G) α (by infer_instance : VAdd G α) _ _\n          (by infer_instance : MeasurableVAdd G α) a }\n  exact @smul_ae_eq_self_of_mem_zpowers (Multiplicative G) α _ _ _ _ _ _ _ _ _ _ hs hy\n#align vadd_ae_eq_self_of_mem_zmultiples vadd_ae_eq_self_of_mem_zmultiples\n\n",
 "smul_invariant_measure_tfae":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:219:4: warning: unsupported binary notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:219:4: warning: unsupported binary notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:219:4: warning: unsupported binary notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:219:4: warning: unsupported binary notation `«expr • » -/\n/-- Equivalent definitions of a measure invariant under a multiplicative action of a group.\n\n- 0: `smul_invariant_measure G α μ`;\n\n- 1: for every `c : G` and a measurable set `s`, the measure of the preimage of `s` under scalar\n     multiplication by `c` is equal to the measure of `s`;\n\n- 2: for every `c : G` and a measurable set `s`, the measure of the image `c • s` of `s` under\n     scalar multiplication by `c` is equal to the measure of `s`;\n\n- 3, 4: properties 2, 3 for any set, including non-measurable ones;\n\n- 5: for any `c : G`, scalar multiplication by `c` maps `μ` to `μ`;\n\n- 6: for any `c : G`, scalar multiplication by `c` is a measure preserving map. -/\n@[to_additive]\ntheorem smul_invariant_measure_tfae :\n    TFAE\n      [smul_invariant_measure G α μ, ∀ (c : G) (s), MeasurableSet s → μ («expr ⁻¹' » ((«expr • » · ·) c) s) = μ s,\n        ∀ (c : G) (s), MeasurableSet s → μ («expr • » c s) = μ s,\n        ∀ (c : G) (s), μ («expr ⁻¹' » ((«expr • » · ·) c) s) = μ s, ∀ (c : G) (s), μ («expr • » c s) = μ s,\n        ∀ c : G, Measure.map ((«expr • » · ·) c) μ = μ, ∀ c : G, MeasurePreserving ((«expr • » · ·) c) μ μ] :=\n  by\n  tfae_have 1 ↔ 2; exact ⟨fun h => h.1, fun h => ⟨h⟩⟩\n  tfae_have 1 → 6;\n  · intro h c\n    exact (measure_preserving_smul c μ).map_eq\n  tfae_have 6 → 7; exact fun H c => ⟨measurable_const_smul c, H c⟩\n  tfae_have 7 → 4; exact fun H c => (H c).measure_preimage_emb (measurableEmbedding_const_smul c)\n  tfae_have 4 → 5;\n  exact fun H c s => by\n    rw [← preimage_smul_inv]\n    apply H\n  tfae_have 5 → 3; exact fun H c s hs => H c s\n  tfae_have 3 → 2;\n  · intro H c s hs\n    rw [preimage_smul]\n    exact H c⁻¹ s hs\n  tfae_finish\n#align smul_invariant_measure_tfae smul_invariant_measure_tfae\n\n",
 "smul_ae_eq_self_of_mem_zpowers":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem smul_ae_eq_self_of_mem_zpowers {x y : G} (hs : «expr =ᵐ[ ] » («expr • » x s : Set α) μ s)\n    (hy : y ∈ Subgroup.zpowers x) : «expr =ᵐ[ ] » («expr • » y s : Set α) μ s :=\n  by\n  obtain ⟨k, rfl⟩ := subgroup.mem_zpowers_iff.mp hy\n  let e : «expr ≃ » α α := MulAction.toPermHom G α x\n  have he : quasi_measure_preserving e μ μ := (measure_preserving_smul x μ).quasi_measure_preserving\n  have he' : quasi_measure_preserving e.symm μ μ := (measure_preserving_smul x⁻¹ μ).quasi_measure_preserving\n  simpa only [MulAction.toPermHom_apply, MulAction.toPerm_apply, image_smul, ← MonoidHom.map_zpow] using\n    he.image_zpow_ae_eq he' k hs\n#align smul_ae_eq_self_of_mem_zpowers smul_ae_eq_self_of_mem_zpowers\n\n",
 "smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[to_additive]\ntheorem null_measurable_set.smul {s} (hs : NullMeasurableSet s μ) (c : G) : NullMeasurableSet («expr • » c s) μ := by\n  simpa only [← preimage_smul_inv] using hs.preimage (measure_preserving_smul _ _).quasi_measure_preserving\n#align null_measurable_set.smul null_measurable_set.smul\n\n",
 "measure_smul_null":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem measure_smul_null {s} (h : μ s = 0) (c : G) : μ («expr • » c s) = 0 := by rwa [measure_smul]\n#align measure_smul_null measure_smul_null\n\n",
 "measure_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp, to_additive]\ntheorem measure_smul (s : Set α) : μ («expr • » c s) = μ s :=\n  ((smul_invariant_measure_tfae G μ).out 0 4).mp ‹_› c s\n#align measure_smul measure_smul\n\n",
 "measure_preserving_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:219:4: warning: unsupported binary notation `«expr • » -/\n/-\nCopyright (c) 2021 Yury G. Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury G. Kudryashov\n-/\n@[simp, to_additive]\ntheorem measure_preserving_smul : MeasurePreserving ((«expr • » · ·) c) μ μ :=\n  { measurable := measurable_const_smul c\n    map_eq := by\n      ext1 s hs\n      rw [map_apply (measurable_const_smul c) hs]\n      exact smul_invariant_measure.measure_preimage_smul μ c hs }\n#align measure_preserving_smul measure_preserving_smul\n\n",
 "measure_preimage_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:219:4: warning: unsupported binary notation `«expr • » -/\n@[simp, to_additive]\ntheorem measure_preimage_smul (s : Set α) : μ («expr ⁻¹' » ((«expr • » · ·) c) s) = μ s :=\n  ((smul_invariant_measure_tfae G μ).out 0 3).mp ‹_› c s\n#align measure_preimage_smul measure_preimage_smul\n\n",
 "measure_pos_iff_nonempty_of_smul_invariant":
 "@[to_additive]\ntheorem measure_pos_iff_nonempty_of_smul_invariant (hμ : μ ≠ 0) (hU : IsOpen U) : 0 < μ U ↔ U.nonempty :=\n  ⟨fun h => nonempty_of_measure_ne_zero h.ne', measure_is_open_pos_of_smul_invariant_of_ne_zero G hμ hU⟩\n#align measure_pos_iff_nonempty_of_smul_invariant measure_pos_iff_nonempty_of_smul_invariant\n\n",
 "measure_is_open_pos_of_smul_invariant_of_ne_zero":
 "@[to_additive]\ntheorem measure_is_open_pos_of_smul_invariant_of_ne_zero (hμ : μ ≠ 0) (hU : IsOpen U) (hne : U.nonempty) : 0 < μ U :=\n  let ⟨K, hK, hμK⟩ := regular.exists_compact_not_null.mpr hμ\n  measure_is_open_pos_of_smul_invariant_of_compact_ne_zero G hK hμK hU hne\n#align measure_is_open_pos_of_smul_invariant_of_ne_zero measure_is_open_pos_of_smul_invariant_of_ne_zero\n\n",
 "measure_is_open_pos_of_smul_invariant_of_compact_ne_zero":
 "/-- If measure `μ` is invariant under a group action and is nonzero on a compact set `K`, then it is\npositive on any nonempty open set. In case of a regular measure, one can assume `μ ≠ 0` instead of\n`μ K ≠ 0`, see `measure_theory.measure_is_open_pos_of_smul_invariant_of_ne_zero`. -/\n@[to_additive]\ntheorem measure_is_open_pos_of_smul_invariant_of_compact_ne_zero (hK : IsCompact K) (hμK : μ K ≠ 0) (hU : IsOpen U)\n    (hne : U.nonempty) : 0 < μ U :=\n  let ⟨t, ht⟩ := hK.exists_finite_cover_smul G hU hne\n  pos_iff_ne_zero.2 fun hμU =>\n    hμK <| measure_mono_null ht <| (measure_bunionᵢ_null_iff t.countable_to_set).2 fun _ _ => by rwa [measure_smul]\n#align measure_is_open_pos_of_smul_invariant_of_compact_ne_zero measure_is_open_pos_of_smul_invariant_of_compact_ne_zero\n\n",
 "measure_eq_zero_iff_eq_empty_of_smul_invariant":
 "@[to_additive]\ntheorem measure_eq_zero_iff_eq_empty_of_smul_invariant (hμ : μ ≠ 0) (hU : IsOpen U) : μ U = 0 ↔ U = ∅ := by\n  rw [← not_iff_not, ← ne.def, ← pos_iff_ne_zero, measure_pos_iff_nonempty_of_smul_invariant G hμ hU,\n    nonempty_iff_ne_empty]\n#align measure_eq_zero_iff_eq_empty_of_smul_invariant measure_eq_zero_iff_eq_empty_of_smul_invariant\n\n",
 "map_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:219:4: warning: unsupported binary notation `«expr • » -/\n@[simp, to_additive]\ntheorem map_smul : map ((«expr • » · ·) c) μ = μ :=\n  (measure_preserving_smul c μ).map_eq\n#align map_smul map_smul\n\n",
 "is_locally_finite_measure_of_smul_invariant":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:219:4: warning: unsupported binary notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n@[to_additive]\ntheorem is_locally_finite_measure_of_smul_invariant (hU : IsOpen U) (hne : U.nonempty) (hμU : μ U ≠ ennreal.top) :\n    LocallyFiniteMeasure μ :=\n  ⟨fun x =>\n    let ⟨g, hg⟩ := hU.exists_smul_mem G x hne\n    ⟨«expr ⁻¹' » ((«expr • » · ·) g) U, (hU.preimage (continuous_id.const_smul _)).mem_nhds hg,\n      Ne.lt_top <| by rwa [measure_preimage_smul]⟩⟩\n#align is_locally_finite_measure_of_smul_invariant is_locally_finite_measure_of_smul_invariant\n\n"}