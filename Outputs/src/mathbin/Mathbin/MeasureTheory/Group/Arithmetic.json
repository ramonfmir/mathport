{"smul_const":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print AEMeasurable.smul_const /-\n@[measurability, to_additive]\ntheorem AEMeasurable.smul_const (hf : AEMeasurable f μ) (y : β) : AEMeasurable (fun x => «expr • » (f x) y) μ :=\n  (MeasurableSMul.measurable_smul_const y).comp_ae_measurable hf\n#align ae_measurable.smul_const AEMeasurable.smul_const\n#align ae_measurable.vadd_const AEMeasurable.vadd_const\n-/\n\n",
 "smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print AEMeasurable.smul /-\n@[measurability, to_additive]\ntheorem AEMeasurable.smul [MeasurableSMul₂ M β] {μ : measure α} (hf : AEMeasurable f μ) (hg : AEMeasurable g μ) :\n    AEMeasurable (fun x => «expr • » (f x) (g x)) μ :=\n  MeasurableSMul₂.measurable_smul.comp_ae_measurable (hf.prod_mk hg)\n#align ae_measurable.smul AEMeasurable.smul\n#align ae_measurable.vadd AEMeasurable.vadd\n-/\n\n",
 "pow_const":
 "#print AEMeasurable.pow_const /-\n@[measurability]\ntheorem AEMeasurable.pow_const (hf : AEMeasurable f μ) (c : γ) : AEMeasurable (fun x => f x ^ c) μ :=\n  hf.pow aemeasurable_const\n#align ae_measurable.pow_const AEMeasurable.pow_const\n-/\n\n",
 "pow":
 "#print AEMeasurable.pow /-\n@[measurability]\ntheorem AEMeasurable.pow (hf : AEMeasurable f μ) (hg : AEMeasurable g μ) : AEMeasurable (fun x => f x ^ g x) μ :=\n  measurable_pow.comp_ae_measurable (hf.prod_mk hg)\n#align ae_measurable.pow AEMeasurable.pow\n-/\n\n",
 "nullMeasurableSet_eq_fun":
 "#print nullMeasurableSet_eq_fun /-\ntheorem nullMeasurableSet_eq_fun {E} [MeasurableSpace E] [AddGroup E] [MeasurableSingletonClass E] [MeasurableSub₂ E]\n    {f g : α → E} (hf : AEMeasurable f μ) (hg : AEMeasurable g μ) : NullMeasurableSet { x | f x = g x } μ :=\n  by\n  apply (measurableSet_eq_fun hf.measurable_mk hg.measurable_mk).null_measurable_set.congr\n  filter_upwards [hf.ae_eq_mk, hg.ae_eq_mk]with x hfx hgx\n  change (hf.mk f x = hg.mk g x) = (f x = g x)\n  simp only [hfx, hgx]\n#align null_measurable_set_eq_fun nullMeasurableSet_eq_fun\n-/\n\n",
 "mul_const":
 "#print AEMeasurable.mul_const /-\n@[measurability, to_additive]\ntheorem AEMeasurable.mul_const [MeasurableMul M] (hf : AEMeasurable f μ) (c : M) : AEMeasurable (fun x => f x * c) μ :=\n  (measurable_mul_const c).comp_ae_measurable hf\n#align ae_measurable.mul_const AEMeasurable.mul_const\n#align ae_measurable.add_const AEMeasurable.add_const\n-/\n\n",
 "mul'":
 "#print AEMeasurable.mul' /-\n@[measurability, to_additive]\ntheorem AEMeasurable.mul' [MeasurableMul₂ M] (hf : AEMeasurable f μ) (hg : AEMeasurable g μ) : AEMeasurable (f * g) μ :=\n  measurable_mul.comp_ae_measurable (hf.prod_mk hg)\n#align ae_measurable.mul' AEMeasurable.mul'\n#align ae_measurable.add' AEMeasurable.add'\n-/\n\n",
 "mul":
 "#print AEMeasurable.mul /-\n@[measurability, to_additive]\ntheorem AEMeasurable.mul [MeasurableMul₂ M] (hf : AEMeasurable f μ) (hg : AEMeasurable g μ) :\n    AEMeasurable (fun a => f a * g a) μ :=\n  measurable_mul.comp_ae_measurable (hf.prod_mk hg)\n#align ae_measurable.mul AEMeasurable.mul\n#align ae_measurable.add AEMeasurable.add\n-/\n\n",
 "measurable_prod'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n#print Finset.measurable_prod' /-\n@[measurability, to_additive]\ntheorem Finset.measurable_prod' (s : Finset ι) (hf : ∀ i ∈ s, Measurable (f i)) :\n    Measurable\n      (finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f i)) :=\n  Finset.prod_induction _ _ (fun _ _ => Measurable.mul) (@measurable_one M _ _ _ _) hf\n#align finset.measurable_prod' Finset.measurable_prod'\n#align finset.measurable_sum' Finset.measurable_sum'\n-/\n\n",
 "measurable_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n#print Finset.measurable_prod /-\n@[measurability, to_additive]\ntheorem Finset.measurable_prod (s : Finset ι) (hf : ∀ i ∈ s, Measurable (f i)) :\n    Measurable fun a =>\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f i a) :=\n  by simpa only [← Finset.prod_apply] using s.measurable_prod' hf\n#align finset.measurable_prod Finset.measurable_prod\n#align finset.measurable_sum Finset.measurable_sum\n-/\n\n",
 "measurable_mul_unop":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵐᵒᵖ» -/\n#print measurable_mul_unop /-\n@[to_additive]\ntheorem measurable_mul_unop {α : Type _} [MeasurableSpace α] : Measurable (unop : «expr ᵐᵒᵖ» α → α) := fun s => id\n#align measurable_mul_unop measurable_mul_unop\n#align measurable_add_unop measurable_add_unop\n-/\n\n",
 "measurable_mul_op":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵐᵒᵖ» -/\n#print measurable_mul_op /-\n@[to_additive]\ntheorem measurable_mul_op {α : Type _} [MeasurableSpace α] : Measurable (op : α → «expr ᵐᵒᵖ» α) := fun s => id\n#align measurable_mul_op measurable_mul_op\n#align measurable_add_op measurable_add_op\n-/\n\n",
 "measurable_inv_iff₀":
 "#print measurable_inv_iff₀ /-\n@[simp]\ntheorem measurable_inv_iff₀ {G₀ : Type _} [GroupWithZero G₀] [MeasurableSpace G₀] [MeasurableInv G₀] {f : α → G₀} :\n    (Measurable fun x => (f x)⁻¹) ↔ Measurable f :=\n  ⟨fun h => by simpa only [inv_inv] using h.inv, fun h => h.inv⟩\n#align measurable_inv_iff₀ measurable_inv_iff₀\n-/\n\n",
 "measurable_inv_iff":
 "#print measurable_inv_iff /-\n@[simp, to_additive]\ntheorem measurable_inv_iff {G : Type _} [Group G] [MeasurableSpace G] [MeasurableInv G] {f : α → G} :\n    (Measurable fun x => (f x)⁻¹) ↔ Measurable f :=\n  ⟨fun h => by simpa only [inv_inv] using h.inv, fun h => h.inv⟩\n#align measurable_inv_iff measurable_inv_iff\n#align measurable_neg_iff measurable_neg_iff\n-/\n\n",
 "measurable_div_const'":
 "#print measurable_div_const' /-\n/-- A version of `measurable_div_const` that assumes `has_measurable_mul` instead of\n  `has_measurable_div`. This can be nice to avoid unnecessary type-class assumptions. -/\n@[to_additive\n      \" A version of `measurable_sub_const` that assumes `has_measurable_add` instead of\\n  `has_measurable_sub`. This can be nice to avoid unnecessary type-class assumptions. \"]\ntheorem measurable_div_const' {G : Type _} [DivInvMonoid G] [MeasurableSpace G] [MeasurableMul G] (g : G) :\n    Measurable fun h => h / g := by simp_rw [div_eq_mul_inv, measurable_mul_const]\n#align measurable_div_const' measurable_div_const'\n#align measurable_sub_const' measurable_sub_const'\n-/\n\n",
 "measurable_const_smul_iff₀":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print measurable_const_smul_iff₀ /-\ntheorem measurable_const_smul_iff₀ {c : G₀} (hc : c ≠ 0) : (Measurable fun x => «expr • » c (f x)) ↔ Measurable f :=\n  (IsUnit.mk0 c hc).measurable_const_smul_iff\n#align measurable_const_smul_iff₀ measurable_const_smul_iff₀\n-/\n\n",
 "measurable_const_smul_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print IsUnit.measurable_const_smul_iff /-\n@[to_additive]\ntheorem IsUnit.measurable_const_smul_iff {c : M} (hc : IsUnit c) :\n    (Measurable fun x => «expr • » c (f x)) ↔ Measurable f :=\n  let ⟨u, hu⟩ := hc\n  hu ▸ measurable_const_smul_iff u\n#align is_unit.measurable_const_smul_iff IsUnit.measurable_const_smul_iff\n#align is_add_unit.measurable_const_vadd_iff IsAddUnit.measurable_const_vadd_iff\n-/\n\n",
 "measurableSet_eq_fun_of_countable":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n#print measurableSet_eq_fun_of_countable /-\ntheorem measurableSet_eq_fun_of_countable {m : MeasurableSpace α} {E} [MeasurableSpace E] [MeasurableSingletonClass E]\n    [Countable E] {f g : α → E} (hf : Measurable f) (hg : Measurable g) : MeasurableSet { x | f x = g x } :=\n  by\n  have :\n    { x | f x = g x } =\n      «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n        ({ x | f x = j } ∩ { x | g x = j }) :=\n    by\n    ext1 x\n    simp only [Set.mem_setOf_eq, Set.mem_unionᵢ, Set.mem_inter_iff, exists_eq_right']\n  rw [this]\n  refine' MeasurableSet.unionᵢ fun j => MeasurableSet.inter _ _\n  · exact hf (measurable_set_singleton j)\n  · exact hg (measurable_set_singleton j)\n#align measurable_set_eq_fun_of_countable measurableSet_eq_fun_of_countable\n-/\n\n",
 "measurableSet_eq_fun":
 "#print measurableSet_eq_fun /-\n@[measurability]\ntheorem measurableSet_eq_fun {m : MeasurableSpace α} {E} [MeasurableSpace E] [AddGroup E] [MeasurableSingletonClass E]\n    [MeasurableSub₂ E] {f g : α → E} (hf : Measurable f) (hg : Measurable g) : MeasurableSet { x | f x = g x } :=\n  by\n  suffices h_set_eq : { x : α | f x = g x } = { x | (f - g) x = (0 : E) }\n  · rw [h_set_eq]\n    exact (hf.sub hg) measurableSet_eq\n  ext\n  simp_rw [Set.mem_setOf_eq, Pi.sub_apply, sub_eq_zero]\n#align measurable_set_eq_fun measurableSet_eq_fun\n-/\n\n",
 "inv":
 "#print MeasurableSet.inv /-\n@[to_additive]\ntheorem MeasurableSet.inv {s : Set G} (hs : MeasurableSet s) : MeasurableSet s⁻¹ :=\n  measurable_inv hs\n#align measurable_set.inv MeasurableSet.inv\n#align measurable_set.neg MeasurableSet.neg\n-/\n\n",
 "div_const":
 "#print AEMeasurable.div_const /-\n@[measurability, to_additive]\ntheorem AEMeasurable.div_const [MeasurableDiv G] (hf : AEMeasurable f μ) (c : G) : AEMeasurable (fun x => f x / c) μ :=\n  (MeasurableDiv.measurable_div_const c).comp_ae_measurable hf\n#align ae_measurable.div_const AEMeasurable.div_const\n#align ae_measurable.sub_const AEMeasurable.sub_const\n-/\n\n",
 "div'":
 "#print AEMeasurable.div' /-\n@[measurability, to_additive]\ntheorem AEMeasurable.div' [MeasurableDiv₂ G] (hf : AEMeasurable f μ) (hg : AEMeasurable g μ) : AEMeasurable (f / g) μ :=\n  measurable_div.comp_ae_measurable (hf.prod_mk hg)\n#align ae_measurable.div' AEMeasurable.div'\n#align ae_measurable.sub' AEMeasurable.sub'\n-/\n\n",
 "div":
 "#print AEMeasurable.div /-\n@[measurability, to_additive]\ntheorem AEMeasurable.div [MeasurableDiv₂ G] (hf : AEMeasurable f μ) (hg : AEMeasurable g μ) :\n    AEMeasurable (fun a => f a / g a) μ :=\n  measurable_div.comp_ae_measurable (hf.prod_mk hg)\n#align ae_measurable.div AEMeasurable.div\n#align ae_measurable.sub AEMeasurable.sub\n-/\n\n",
 "const_smul'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print AEMeasurable.const_smul' /-\n@[measurability, to_additive]\ntheorem AEMeasurable.const_smul' (hg : AEMeasurable g μ) (c : M) : AEMeasurable (fun x => «expr • » c (g x)) μ :=\n  (MeasurableSMul.measurable_const_smul c).comp_ae_measurable hg\n#align ae_measurable.const_smul' AEMeasurable.const_smul'\n#align ae_measurable.const_vadd' AEMeasurable.const_vadd'\n-/\n\n",
 "const_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print AEMeasurable.const_smul /-\n@[measurability, to_additive]\ntheorem AEMeasurable.const_smul (hf : AEMeasurable g μ) (c : M) : AEMeasurable («expr • » c g) μ :=\n  hf.const_smul' c\n#align ae_measurable.const_smul AEMeasurable.const_smul\n#align ae_measurable.const_vadd AEMeasurable.const_vadd\n-/\n\n",
 "const_pow":
 "#print AEMeasurable.const_pow /-\n@[measurability]\ntheorem AEMeasurable.const_pow (hg : AEMeasurable g μ) (c : β) : AEMeasurable (fun x => c ^ g x) μ :=\n  aemeasurable_const.pow hg\n#align ae_measurable.const_pow AEMeasurable.const_pow\n-/\n\n",
 "const_mul":
 "#print AEMeasurable.const_mul /-\n@[measurability, to_additive]\ntheorem AEMeasurable.const_mul [MeasurableMul M] (hf : AEMeasurable f μ) (c : M) : AEMeasurable (fun x => c * f x) μ :=\n  (MeasurableMul.measurable_const_mul c).comp_ae_measurable hf\n#align ae_measurable.const_mul AEMeasurable.const_mul\n#align ae_measurable.const_add AEMeasurable.const_add\n-/\n\n",
 "const_div":
 "#print AEMeasurable.const_div /-\n@[measurability, to_additive]\ntheorem AEMeasurable.const_div [MeasurableDiv G] (hf : AEMeasurable f μ) (c : G) : AEMeasurable (fun x => c / f x) μ :=\n  (MeasurableDiv.measurable_div_const c).comp_ae_measurable hf\n#align ae_measurable.const_div AEMeasurable.const_div\n#align ae_measurable.const_sub AEMeasurable.const_sub\n-/\n\n",
 "aemeasurable_prod'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n#print Finset.aemeasurable_prod' /-\n@[measurability, to_additive]\ntheorem Finset.aemeasurable_prod' (s : Finset ι) (hf : ∀ i ∈ s, AEMeasurable (f i) μ) :\n    AEMeasurable\n      (finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f i)) μ :=\n  Multiset.aemeasurable_prod' _ fun g hg =>\n    let ⟨i, hi, hg⟩ := Multiset.mem_map.1 hg\n    hg ▸ hf _ hi\n#align finset.ae_measurable_prod' Finset.aemeasurable_prod'\n#align finset.ae_measurable_sum' Finset.aemeasurable_sum'\n-/\n\n",
 "aemeasurable_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n#print Finset.aemeasurable_prod /-\n@[measurability, to_additive]\ntheorem Finset.aemeasurable_prod (s : Finset ι) (hf : ∀ i ∈ s, AEMeasurable (f i) μ) :\n    AEMeasurable\n      (fun a =>\n        finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f i a))\n      μ :=\n  by simpa only [← Finset.prod_apply] using s.ae_measurable_prod' hf\n#align finset.ae_measurable_prod Finset.aemeasurable_prod\n#align finset.ae_measurable_sum Finset.aemeasurable_sum\n-/\n\n",
 "aemeasurable_inv_iff₀":
 "#print aemeasurable_inv_iff₀ /-\n@[simp]\ntheorem aemeasurable_inv_iff₀ {G₀ : Type _} [GroupWithZero G₀] [MeasurableSpace G₀] [MeasurableInv G₀] {f : α → G₀} :\n    AEMeasurable (fun x => (f x)⁻¹) μ ↔ AEMeasurable f μ :=\n  ⟨fun h => by simpa only [inv_inv] using h.inv, fun h => h.inv⟩\n#align ae_measurable_inv_iff₀ aemeasurable_inv_iff₀\n-/\n\n",
 "aemeasurable_inv_iff":
 "#print aemeasurable_inv_iff /-\n@[simp, to_additive]\ntheorem aemeasurable_inv_iff {G : Type _} [Group G] [MeasurableSpace G] [MeasurableInv G] {f : α → G} :\n    AEMeasurable (fun x => (f x)⁻¹) μ ↔ AEMeasurable f μ :=\n  ⟨fun h => by simpa only [inv_inv] using h.inv, fun h => h.inv⟩\n#align ae_measurable_inv_iff aemeasurable_inv_iff\n#align ae_measurable_neg_iff aemeasurable_neg_iff\n-/\n\n",
 "aemeasurable_const_smul_iff₀":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print aemeasurable_const_smul_iff₀ /-\ntheorem aemeasurable_const_smul_iff₀ {c : G₀} (hc : c ≠ 0) :\n    AEMeasurable (fun x => «expr • » c (f x)) μ ↔ AEMeasurable f μ :=\n  (IsUnit.mk0 c hc).ae_measurable_const_smul_iff\n#align ae_measurable_const_smul_iff₀ aemeasurable_const_smul_iff₀\n-/\n\n",
 "aemeasurable_const_smul_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print IsUnit.aemeasurable_const_smul_iff /-\n@[to_additive]\ntheorem IsUnit.aemeasurable_const_smul_iff {c : M} (hc : IsUnit c) :\n    AEMeasurable (fun x => «expr • » c (f x)) μ ↔ AEMeasurable f μ :=\n  let ⟨u, hu⟩ := hc\n  hu ▸ aemeasurable_const_smul_iff u\n#align is_unit.ae_measurable_const_smul_iff IsUnit.aemeasurable_const_smul_iff\n#align is_add_unit.ae_measurable_const_vadd_iff IsAddUnit.aemeasurable_const_vadd_iff\n-/\n\n",
 "ae_eq_trim_of_measurable":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_of -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_of -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\n#print ae_eq_trim_of_measurable /-\ntheorem ae_eq_trim_of_measurable {α E} {m m0 : MeasurableSpace α} {μ : measure α} [MeasurableSpace E] [AddGroup E]\n    [MeasurableSingletonClass E] [MeasurableSub₂ E] (hm : m ≤ m0) {f g : α → E} (hf : (measurable_of m) f)\n    (hg : (measurable_of m) g) (hfg : «expr =ᵐ[ ] » f μ g) : «expr =ᶠ[ ] » f (@Measure.ae α m (μ.trim hm)) g :=\n  by\n  rwa [Filter.EventuallyEq, ae_iff, trim_measurable_set_eq hm _]\n  exact @MeasurableSet.compl α _ m (@measurableSet_eq_fun α m E _ _ _ _ _ _ hf hg)\n#align ae_eq_trim_of_measurable ae_eq_trim_of_measurable\n-/\n\n"}