{"smul_const":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[measurability, to_additive]\ntheorem ae_measurable.smul_const (hf : ae_measurable f μ) (y : β) : ae_measurable (fun x => «expr • » (f x) y) μ :=\n  (has_measurable_smul.measurable_smul_const y).comp_ae_measurable hf\n#align ae_measurable.smul_const ae_measurable.smul_const\n\n",
 "smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[measurability, to_additive]\ntheorem ae_measurable.smul [has_measurable_smul₂ M β] {μ : measure α} (hf : ae_measurable f μ)\n    (hg : ae_measurable g μ) : ae_measurable (fun x => «expr • » (f x) (g x)) μ :=\n  has_measurable_smul₂.measurable_smul.comp_ae_measurable (hf.prod_mk hg)\n#align ae_measurable.smul ae_measurable.smul\n\n",
 "pow_const":
 "@[measurability]\ntheorem ae_measurable.pow_const (hf : ae_measurable f μ) (c : γ) : ae_measurable (fun x => f x ^ c) μ :=\n  hf.pow ae_measurable_const\n#align ae_measurable.pow_const ae_measurable.pow_const\n\n",
 "pow":
 "@[measurability]\ntheorem ae_measurable.pow (hf : ae_measurable f μ) (hg : ae_measurable g μ) : ae_measurable (fun x => f x ^ g x) μ :=\n  measurable_pow.comp_ae_measurable (hf.prod_mk hg)\n#align ae_measurable.pow ae_measurable.pow\n\n",
 "mul_const":
 "@[measurability, to_additive]\ntheorem ae_measurable.mul_const [has_measurable_mul M] (hf : ae_measurable f μ) (c : M) :\n    ae_measurable (fun x => f x * c) μ :=\n  (measurable_mul_const c).comp_ae_measurable hf\n#align ae_measurable.mul_const ae_measurable.mul_const\n\n",
 "mul'":
 "@[measurability, to_additive]\ntheorem ae_measurable.mul' [has_measurable_mul₂ M] (hf : ae_measurable f μ) (hg : ae_measurable g μ) :\n    ae_measurable (f * g) μ :=\n  measurable_mul.comp_ae_measurable (hf.prod_mk hg)\n#align ae_measurable.mul' ae_measurable.mul'\n\n",
 "mul":
 "@[measurability, to_additive]\ntheorem ae_measurable.mul [has_measurable_mul₂ M] (hf : ae_measurable f μ) (hg : ae_measurable g μ) :\n    ae_measurable (fun a => f a * g a) μ :=\n  measurable_mul.comp_ae_measurable (hf.prod_mk hg)\n#align ae_measurable.mul ae_measurable.mul\n\n",
 "measurable_set_eq_fun_of_countable":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\ntheorem measurable_set_eq_fun_of_countable {m : measurable_space α} {E} [measurable_space E]\n    [measurable_singleton_class E] [countable E] {f g : α → E} (hf : measurable f) (hg : measurable g) :\n    measurable_set { x | f x = g x } :=\n  by\n  have :\n    { x | f x = g x } =\n      «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n        ({ x | f x = j } ∩ { x | g x = j }) :=\n    by\n    ext1 x\n    simp only [Set.mem_setOf_eq, Set.mem_unionᵢ, Set.mem_inter_iff, exists_eq_right']\n  rw [this]\n  refine' measurable_set.Union fun j => measurable_set.inter _ _\n  · exact hf (measurable_set_singleton j)\n  · exact hg (measurable_set_singleton j)\n#align measurable_set_eq_fun_of_countable measurable_set_eq_fun_of_countable\n\n",
 "measurable_set_eq_fun":
 "@[measurability]\ntheorem measurable_set_eq_fun {m : measurable_space α} {E} [measurable_space E] [add_group E]\n    [measurable_singleton_class E] [has_measurable_sub₂ E] {f g : α → E} (hf : measurable f) (hg : measurable g) :\n    measurable_set { x | f x = g x } :=\n  by\n  suffices h_set_eq : { x : α | f x = g x } = { x | (f - g) x = (0 : E) }\n  · rw [h_set_eq]\n    exact (hf.sub hg) measurable_set_eq\n  ext\n  simp_rw [Set.mem_setOf_eq, pi.sub_apply, sub_eq_zero]\n#align measurable_set_eq_fun measurable_set_eq_fun\n\n",
 "measurable_prod'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n@[measurability, to_additive]\ntheorem finset.measurable_prod' (s : Finset ι) (hf : ∀ i ∈ s, measurable (f i)) :\n    measurable\n      (finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f i)) :=\n  finset.prod_induction _ _ (fun _ _ => measurable.mul) (@measurable_one M _ _ _ _) hf\n#align finset.measurable_prod' finset.measurable_prod'\n\n",
 "measurable_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n@[measurability, to_additive]\ntheorem finset.measurable_prod (s : Finset ι) (hf : ∀ i ∈ s, measurable (f i)) :\n    measurable fun a =>\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f i a) :=\n  by simpa only [← finset.prod_apply] using s.measurable_prod' hf\n#align finset.measurable_prod finset.measurable_prod\n\n",
 "measurable_mul_unop":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵐᵒᵖ» -/\n@[to_additive]\ntheorem measurable_mul_unop {α : Type _} [measurable_space α] : measurable (unop : «expr ᵐᵒᵖ» α → α) := fun s => id\n#align measurable_mul_unop measurable_mul_unop\n\n",
 "measurable_mul_op":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵐᵒᵖ» -/\n@[to_additive]\ntheorem measurable_mul_op {α : Type _} [measurable_space α] : measurable (op : α → «expr ᵐᵒᵖ» α) := fun s => id\n#align measurable_mul_op measurable_mul_op\n\n",
 "measurable_inv_iff₀":
 "@[simp]\ntheorem measurable_inv_iff₀ {G₀ : Type _} [group_with_zero G₀] [measurable_space G₀] [has_measurable_inv G₀]\n    {f : α → G₀} : (measurable fun x => (f x)⁻¹) ↔ measurable f :=\n  ⟨fun h => by simpa only [inv_inv] using h.inv, fun h => h.inv⟩\n#align measurable_inv_iff₀ measurable_inv_iff₀\n\n",
 "measurable_inv_iff":
 "@[simp, to_additive]\ntheorem measurable_inv_iff {G : Type _} [group G] [measurable_space G] [has_measurable_inv G] {f : α → G} :\n    (measurable fun x => (f x)⁻¹) ↔ measurable f :=\n  ⟨fun h => by simpa only [inv_inv] using h.inv, fun h => h.inv⟩\n#align measurable_inv_iff measurable_inv_iff\n\n",
 "measurable_div_const'":
 "/-- A version of `measurable_div_const` that assumes `has_measurable_mul` instead of\n  `has_measurable_div`. This can be nice to avoid unnecessary type-class assumptions. -/\n@[to_additive\n      \" A version of `measurable_sub_const` that assumes `has_measurable_add` instead of\\n  `has_measurable_sub`. This can be nice to avoid unnecessary type-class assumptions. \"]\ntheorem measurable_div_const' {G : Type _} [div_inv_monoid G] [measurable_space G] [has_measurable_mul G] (g : G) :\n    measurable fun h => h / g := by simp_rw [div_eq_mul_inv, measurable_mul_const]\n#align measurable_div_const' measurable_div_const'\n\n",
 "measurable_const_smul_iff₀":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem measurable_const_smul_iff₀ {c : G₀} (hc : c ≠ 0) : (measurable fun x => «expr • » c (f x)) ↔ measurable f :=\n  (IsUnit.mk0 c hc).measurable_const_smul_iff\n#align measurable_const_smul_iff₀ measurable_const_smul_iff₀\n\n",
 "measurable_const_smul_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[to_additive]\ntheorem is_unit.measurable_const_smul_iff {c : M} (hc : is_unit c) :\n    (measurable fun x => «expr • » c (f x)) ↔ measurable f :=\n  let ⟨u, hu⟩ := hc\n  hu ▸ measurable_const_smul_iff u\n#align is_unit.measurable_const_smul_iff is_unit.measurable_const_smul_iff\n\n",
 "inv":
 "@[to_additive]\ntheorem measurable_set.inv {s : set G} (hs : measurable_set s) : measurable_set s⁻¹ :=\n  measurable_inv hs\n#align measurable_set.inv measurable_set.inv\n\n",
 "div_const":
 "@[measurability, to_additive]\ntheorem ae_measurable.div_const [has_measurable_div G] (hf : ae_measurable f μ) (c : G) :\n    ae_measurable (fun x => f x / c) μ :=\n  (has_measurable_div.measurable_div_const c).comp_ae_measurable hf\n#align ae_measurable.div_const ae_measurable.div_const\n\n",
 "div'":
 "@[measurability, to_additive]\ntheorem ae_measurable.div' [has_measurable_div₂ G] (hf : ae_measurable f μ) (hg : ae_measurable g μ) :\n    ae_measurable (f / g) μ :=\n  measurable_div.comp_ae_measurable (hf.prod_mk hg)\n#align ae_measurable.div' ae_measurable.div'\n\n",
 "div":
 "@[measurability, to_additive]\ntheorem ae_measurable.div [has_measurable_div₂ G] (hf : ae_measurable f μ) (hg : ae_measurable g μ) :\n    ae_measurable (fun a => f a / g a) μ :=\n  measurable_div.comp_ae_measurable (hf.prod_mk hg)\n#align ae_measurable.div ae_measurable.div\n\n",
 "const_smul'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[measurability, to_additive]\ntheorem ae_measurable.const_smul' (hg : ae_measurable g μ) (c : M) : ae_measurable (fun x => «expr • » c (g x)) μ :=\n  (has_measurable_smul.measurable_const_smul c).comp_ae_measurable hg\n#align ae_measurable.const_smul' ae_measurable.const_smul'\n\n",
 "const_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[measurability, to_additive]\ntheorem ae_measurable.const_smul (hf : ae_measurable g μ) (c : M) : ae_measurable («expr • » c g) μ :=\n  hf.const_smul' c\n#align ae_measurable.const_smul ae_measurable.const_smul\n\n",
 "const_pow":
 "@[measurability]\ntheorem ae_measurable.const_pow (hg : ae_measurable g μ) (c : β) : ae_measurable (fun x => c ^ g x) μ :=\n  ae_measurable_const.pow hg\n#align ae_measurable.const_pow ae_measurable.const_pow\n\n",
 "const_mul":
 "@[measurability, to_additive]\ntheorem ae_measurable.const_mul [has_measurable_mul M] (hf : ae_measurable f μ) (c : M) :\n    ae_measurable (fun x => c * f x) μ :=\n  (has_measurable_mul.measurable_const_mul c).comp_ae_measurable hf\n#align ae_measurable.const_mul ae_measurable.const_mul\n\n",
 "const_div":
 "@[measurability, to_additive]\ntheorem ae_measurable.const_div [has_measurable_div G] (hf : ae_measurable f μ) (c : G) :\n    ae_measurable (fun x => c / f x) μ :=\n  (has_measurable_div.measurable_const_div c).comp_ae_measurable hf\n#align ae_measurable.const_div ae_measurable.const_div\n\n",
 "ae_measurable_prod'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n@[measurability, to_additive]\ntheorem finset.ae_measurable_prod' (s : Finset ι) (hf : ∀ i ∈ s, ae_measurable (f i) μ) :\n    ae_measurable\n      (finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f i)) μ :=\n  multiset.ae_measurable_prod' _ fun g hg =>\n    let ⟨i, hi, hg⟩ := Multiset.mem_map.1 hg\n    hg ▸ hf _ hi\n#align finset.ae_measurable_prod' finset.ae_measurable_prod'\n\n",
 "ae_measurable_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n@[measurability, to_additive]\ntheorem finset.ae_measurable_prod (s : Finset ι) (hf : ∀ i ∈ s, ae_measurable (f i) μ) :\n    ae_measurable\n      (fun a =>\n        finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f i a))\n      μ :=\n  by simpa only [← finset.prod_apply] using s.ae_measurable_prod' hf\n#align finset.ae_measurable_prod finset.ae_measurable_prod\n\n",
 "ae_measurable_inv_iff₀":
 "@[simp]\ntheorem ae_measurable_inv_iff₀ {G₀ : Type _} [group_with_zero G₀] [measurable_space G₀] [has_measurable_inv G₀]\n    {f : α → G₀} : ae_measurable (fun x => (f x)⁻¹) μ ↔ ae_measurable f μ :=\n  ⟨fun h => by simpa only [inv_inv] using h.inv, fun h => h.inv⟩\n#align ae_measurable_inv_iff₀ ae_measurable_inv_iff₀\n\n",
 "ae_measurable_inv_iff":
 "@[simp, to_additive]\ntheorem ae_measurable_inv_iff {G : Type _} [group G] [measurable_space G] [has_measurable_inv G] {f : α → G} :\n    ae_measurable (fun x => (f x)⁻¹) μ ↔ ae_measurable f μ :=\n  ⟨fun h => by simpa only [inv_inv] using h.inv, fun h => h.inv⟩\n#align ae_measurable_inv_iff ae_measurable_inv_iff\n\n",
 "ae_measurable_const_smul_iff₀":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem ae_measurable_const_smul_iff₀ {c : G₀} (hc : c ≠ 0) :\n    ae_measurable (fun x => «expr • » c (f x)) μ ↔ ae_measurable f μ :=\n  (IsUnit.mk0 c hc).ae_measurable_const_smul_iff\n#align ae_measurable_const_smul_iff₀ ae_measurable_const_smul_iff₀\n\n",
 "ae_measurable_const_smul_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[to_additive]\ntheorem is_unit.ae_measurable_const_smul_iff {c : M} (hc : is_unit c) :\n    ae_measurable (fun x => «expr • » c (f x)) μ ↔ ae_measurable f μ :=\n  let ⟨u, hu⟩ := hc\n  hu ▸ ae_measurable_const_smul_iff u\n#align is_unit.ae_measurable_const_smul_iff is_unit.ae_measurable_const_smul_iff\n\n",
 "ae_eq_trim_of_measurable":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_of -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_of -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\ntheorem ae_eq_trim_of_measurable {α E} {m m0 : measurable_space α} {μ : measure α} [measurable_space E] [add_group E]\n    [measurable_singleton_class E] [has_measurable_sub₂ E] (hm : m ≤ m0) {f g : α → E} (hf : (measurable_of m) f)\n    (hg : (measurable_of m) g) (hfg : «expr =ᵐ[ ] » f μ g) : «expr =ᶠ[ ] » f (@measure.ae α m (μ.trim hm)) g :=\n  by\n  rwa [filter.eventually_eq, ae_iff, trim_measurable_set_eq hm _]\n  exact @measurable_set.compl α _ m (@measurable_set_eq_fun α m E _ _ _ _ _ _ hf hg)\n#align ae_eq_trim_of_measurable ae_eq_trim_of_measurable\n\n"}