{"quasi_measure_preserving_mul_right":
 "/-- A *left*-invariant measure is quasi-preserved by *right*-multiplication.\nThis should not be confused with `(measure_preserving_mul_right μ g).quasi_measure_preserving`. -/\n@[to_additive\n      \"A *left*-invariant measure is quasi-preserved by *right*-addition.\\nThis should not be confused with `(measure_preserving_add_right μ g).quasi_measure_preserving`. \"]\ntheorem quasi_measure_preserving_mul_right [is_mul_left_invariant μ] (g : G) :\n    QuasiMeasurePreserving (fun h : G => h * g) μ μ :=\n  by\n  refine' ⟨measurable_mul_const g, absolutely_continuous.mk fun s hs => _⟩\n  rw [map_apply (measurable_mul_const g) hs, measure_mul_right_null]; exact id\n#align quasi_measure_preserving_mul_right quasi_measure_preserving_mul_right\n\n",
 "quasi_measure_preserving_mul_left":
 "/-- A *right*-invariant measure is quasi-preserved by *left*-multiplication.\nThis should not be confused with `(measure_preserving_mul_left μ g).quasi_measure_preserving`. -/\n@[to_additive\n      \"A *right*-invariant measure is quasi-preserved by *left*-addition.\\nThis should not be confused with `(measure_preserving_add_left μ g).quasi_measure_preserving`. \"]\ntheorem quasi_measure_preserving_mul_left [is_mul_right_invariant μ] (g : G) :\n    QuasiMeasurePreserving (fun h : G => g * h) μ μ :=\n  by\n  have :=\n    (quasi_measure_preserving_mul_right μ.inv g⁻¹).mono (inv_absolutely_continuous μ.inv)\n      (absolutely_continuous_inv μ.inv)\n  rw [μ.inv_inv] at this\n  have :=\n    (quasi_measure_preserving_inv_of_right_invariant μ).comp\n      (this.comp (quasi_measure_preserving_inv_of_right_invariant μ))\n  simp_rw [Function.comp, mul_inv_rev, inv_inv] at this\n  exact this\n#align quasi_measure_preserving_mul_left quasi_measure_preserving_mul_left\n\n",
 "quasi_measure_preserving_inv_of_right_invariant":
 "@[to_additive]\ntheorem quasi_measure_preserving_inv_of_right_invariant [is_mul_right_invariant μ] :\n    QuasiMeasurePreserving (has_inv.inv : G → G) μ μ :=\n  by\n  rw [← μ.inv_inv]\n  exact (quasi_measure_preserving_inv μ.inv).mono (inv_absolutely_continuous μ.inv) (absolutely_continuous_inv μ.inv)\n#align quasi_measure_preserving_inv_of_right_invariant quasi_measure_preserving_inv_of_right_invariant\n\n",
 "quasi_measure_preserving_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n@[to_additive]\ntheorem quasi_measure_preserving_inv : QuasiMeasurePreserving (has_inv.inv : G → G) μ μ :=\n  by\n  refine' ⟨measurable_inv, absolutely_continuous.mk fun s hsm hμs => _⟩\n  rw [map_apply measurable_inv hsm, inv_preimage]\n  have hf : Measurable fun z : G × G => (z.2 * z.1, z.1⁻¹) :=\n    (measurable_snd.mul measurable_fst).prod_mk measurable_fst.inv\n  suffices map (fun z : G × G => (z.2 * z.1, z.1⁻¹)) (μ.prod μ) (lower_set.prod s⁻¹ s⁻¹) = 0 by\n    simpa only [(measure_preserving_mul_prod_inv μ μ).map_eq, prod_prod, mul_eq_zero, or_self_iff] using this\n  have hsm' : MeasurableSet (lower_set.prod s⁻¹ s⁻¹) := hsm.inv.prod hsm.inv\n  simp_rw [map_apply hf hsm', prod_apply_symm (hf hsm'), preimage_preimage, mk_preimage_prod, inv_preimage, inv_inv,\n    measure_mono_null (inter_subset_right _ _) hμs, lintegral_zero]\n#align quasi_measure_preserving_inv quasi_measure_preserving_inv\n\n",
 "quasi_measure_preserving_div_of_right_invariant":
 "@[to_additive]\ntheorem quasi_measure_preserving_div_of_right_invariant [is_mul_right_invariant μ] :\n    QuasiMeasurePreserving (fun p : G × G => p.1 / p.2) (μ.prod ν) μ :=\n  by\n  refine' quasi_measure_preserving.prod_of_left measurable_div (eventually_of_forall fun y => _)\n  exact (measure_preserving_div_right μ y).quasi_measure_preserving\n#align quasi_measure_preserving_div_of_right_invariant quasi_measure_preserving_div_of_right_invariant\n\n",
 "quasi_measure_preserving_div_left_of_right_invariant":
 "@[to_additive]\ntheorem quasi_measure_preserving_div_left_of_right_invariant [is_mul_right_invariant μ] (g : G) :\n    QuasiMeasurePreserving (fun h : G => g / h) μ μ :=\n  by\n  rw [← μ.inv_inv]\n  exact\n    (quasi_measure_preserving_div_left μ.inv g).mono (inv_absolutely_continuous μ.inv) (absolutely_continuous_inv μ.inv)\n#align quasi_measure_preserving_div_left_of_right_invariant quasi_measure_preserving_div_left_of_right_invariant\n\n",
 "quasi_measure_preserving_div_left":
 "@[to_additive]\ntheorem quasi_measure_preserving_div_left [is_mul_left_invariant μ] (g : G) :\n    QuasiMeasurePreserving (fun h : G => g / h) μ μ :=\n  by\n  simp_rw [div_eq_mul_inv]\n  exact (measure_preserving_mul_left μ g).quasi_measure_preserving.comp (quasi_measure_preserving_inv μ)\n#align quasi_measure_preserving_div_left quasi_measure_preserving_div_left\n\n",
 "quasi_measure_preserving_div":
 "@[to_additive]\ntheorem quasi_measure_preserving_div [is_mul_left_invariant μ] :\n    QuasiMeasurePreserving (fun p : G × G => p.1 / p.2) (μ.prod ν) μ :=\n  (quasi_measure_preserving_div_of_right_invariant μ.inv ν).mono\n    ((absolutely_continuous_inv μ).prod AbsolutelyContinuous.rfl) (inv_absolutely_continuous μ)\n#align quasi_measure_preserving_div quasi_measure_preserving_div\n\n",
 "measure_preserving_prod_mul_swap_right":
 "/-- The map `(x, y) ↦ (y, xy)` sends the measure `μ × ν` to `ν × μ`. -/\n@[to_additive measure_preserving_prod_add_swap_right\n      \" The map `(x, y) ↦ (y, x + y)` sends the measure `μ × ν` to `ν × μ`. \"]\ntheorem measure_preserving_prod_mul_swap_right [is_mul_right_invariant μ] :\n    MeasurePreserving (fun z : G × G => (z.2, z.1 * z.2)) (μ.prod ν) (ν.prod μ) :=\n  (measure_preserving_prod_mul_right ν μ).comp measure_preserving_swap\n#align measure_preserving_prod_mul_swap_right measure_preserving_prod_mul_swap_right\n\n",
 "measure_preserving_prod_mul_swap":
 "/-- The map `(x, y) ↦ (y, yx)` sends the measure `μ × ν` to `ν × μ`.\nThis is the map `SR` in [Halmos, §59].\n`S` is the map `(x, y) ↦ (x, xy)` and `R` is `prod.swap`. -/\n@[to_additive measure_preserving_prod_add_swap \" The map `(x, y) ↦ (y, y + x)` sends the measure `μ × ν` to `ν × μ`. \"]\ntheorem measure_preserving_prod_mul_swap [is_mul_left_invariant μ] :\n    MeasurePreserving (fun z : G × G => (z.2, z.2 * z.1)) (μ.prod ν) (ν.prod μ) :=\n  (measure_preserving_prod_mul ν μ).comp measure_preserving_swap\n#align measure_preserving_prod_mul_swap measure_preserving_prod_mul_swap\n\n",
 "measure_preserving_prod_mul_right":
 "@[to_additive measure_preserving_prod_add_right]\ntheorem measure_preserving_prod_mul_right [is_mul_right_invariant ν] :\n    MeasurePreserving (fun z : G × G => (z.1, z.2 * z.1)) (μ.prod ν) (μ.prod ν) :=\n  (MeasurePreserving.id μ).skew_product (measurable_snd.mul measurable_fst) <|\n    Filter.eventually_of_forall <| map_mul_right_eq_self ν\n#align measure_preserving_prod_mul_right measure_preserving_prod_mul_right\n\n",
 "measure_preserving_prod_mul":
 "/-\nCopyright (c) 2021 Floris van Doorn. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Floris van Doorn\n-/\n/-- The multiplicative shear mapping `(x, y) ↦ (x, xy)` preserves the measure `μ × ν`.\nThis condition is part of the definition of a measurable group in [Halmos, §59].\nThere, the map in this lemma is called `S`. -/\n@[to_additive measure_preserving_prod_add \" The shear mapping `(x, y) ↦ (x, x + y)` preserves the measure `μ × ν`. \"]\ntheorem measure_preserving_prod_mul [is_mul_left_invariant ν] :\n    MeasurePreserving (fun z : G × G => (z.1, z.1 * z.2)) (μ.prod ν) (μ.prod ν) :=\n  (MeasurePreserving.id μ).skew_product measurable_mul <| Filter.eventually_of_forall <| map_mul_left_eq_self ν\n#align measure_preserving_prod_mul measure_preserving_prod_mul\n\n",
 "measure_preserving_prod_inv_mul_swap":
 "/-- The map `(x, y) ↦ (y, y⁻¹x)` sends `μ × ν` to `ν × μ`.\nThis is the function `S⁻¹R` in [Halmos, §59],\nwhere `S` is the map `(x, y) ↦ (x, xy)` and `R` is `prod.swap`. -/\n@[to_additive measure_preserving_prod_neg_add_swap \"The map `(x, y) ↦ (y, - y + x)` sends `μ × ν` to `ν × μ`.\"]\ntheorem measure_preserving_prod_inv_mul_swap :\n    MeasurePreserving (fun z : G × G => (z.2, z.2⁻¹ * z.1)) (μ.prod ν) (ν.prod μ) :=\n  (measure_preserving_prod_inv_mul ν μ).comp measure_preserving_swap\n#align measure_preserving_prod_inv_mul_swap measure_preserving_prod_inv_mul_swap\n\n",
 "measure_preserving_prod_inv_mul":
 "/-- The map `(x, y) ↦ (x, x⁻¹y)` is measure-preserving.\nThis is the function `S⁻¹` in [Halmos, §59],\nwhere `S` is the map `(x, y) ↦ (x, xy)`. -/\n@[to_additive measure_preserving_prod_neg_add \"The map `(x, y) ↦ (x, - x + y)` is measure-preserving.\"]\ntheorem measure_preserving_prod_inv_mul [is_mul_left_invariant ν] :\n    MeasurePreserving (fun z : G × G => (z.1, z.1⁻¹ * z.2)) (μ.prod ν) (μ.prod ν) :=\n  (measure_preserving_prod_mul μ ν).symm <| measurable_equiv.shear_mul_right G\n#align measure_preserving_prod_inv_mul measure_preserving_prod_inv_mul\n\n",
 "measure_preserving_prod_div_swap":
 "/-- The map `(x, y) ↦ (y, x / y)` sends `μ × ν` to `ν × μ`. -/\n@[to_additive measure_preserving_prod_sub_swap \"The map `(x, y) ↦ (y, x - y)` sends `μ × ν` to `ν × μ`.\"]\ntheorem measure_preserving_prod_div_swap [is_mul_right_invariant μ] :\n    MeasurePreserving (fun z : G × G => (z.2, z.1 / z.2)) (μ.prod ν) (ν.prod μ) :=\n  (measure_preserving_prod_div ν μ).comp measure_preserving_swap\n#align measure_preserving_prod_div_swap measure_preserving_prod_div_swap\n\n",
 "measure_preserving_prod_div":
 "/-- The map `(x, y) ↦ (x, y / x)` is measure-preserving. -/\n@[to_additive measure_preserving_prod_sub \"The map `(x, y) ↦ (x, y - x)` is measure-preserving.\"]\ntheorem measure_preserving_prod_div [is_mul_right_invariant ν] :\n    MeasurePreserving (fun z : G × G => (z.1, z.2 / z.1)) (μ.prod ν) (μ.prod ν) :=\n  (measure_preserving_prod_mul_right μ ν).symm (measurable_equiv.shear_div_right G).symm\n#align measure_preserving_prod_div measure_preserving_prod_div\n\n",
 "measure_preserving_mul_prod_inv_right":
 "/-- The map `(x, y) ↦ (xy, x⁻¹)` is measure-preserving. -/\n@[to_additive measure_preserving_add_prod_neg_right \"The map `(x, y) ↦ (x + y, - x)` is measure-preserving.\"]\ntheorem measure_preserving_mul_prod_inv_right [is_mul_right_invariant μ] [is_mul_right_invariant ν] :\n    MeasurePreserving (fun z : G × G => (z.1 * z.2, z.1⁻¹)) (μ.prod ν) (μ.prod ν) :=\n  by\n  convert(measure_preserving_prod_div_swap ν μ).comp (measure_preserving_prod_mul_swap_right μ ν)\n  ext1 ⟨x, y⟩\n  simp_rw [Function.comp_apply, div_mul_eq_div_div_swap, div_self', one_div]\n#align measure_preserving_mul_prod_inv_right measure_preserving_mul_prod_inv_right\n\n",
 "measure_preserving_mul_prod_inv":
 "/-- The map `(x, y) ↦ (yx, x⁻¹)` is measure-preserving.\nThis is the function `S⁻¹RSR` in [Halmos, §59],\nwhere `S` is the map `(x, y) ↦ (x, xy)` and `R` is `prod.swap`. -/\n@[to_additive measure_preserving_add_prod_neg \"The map `(x, y) ↦ (y + x, - x)` is measure-preserving.\"]\ntheorem measure_preserving_mul_prod_inv [is_mul_left_invariant ν] :\n    MeasurePreserving (fun z : G × G => (z.2 * z.1, z.1⁻¹)) (μ.prod ν) (μ.prod ν) :=\n  by\n  convert(measure_preserving_prod_inv_mul_swap ν μ).comp (measure_preserving_prod_mul_swap μ ν)\n  ext1 ⟨x, y⟩\n  simp_rw [Function.comp_apply, mul_inv_rev, inv_mul_cancel_right]\n#align measure_preserving_mul_prod_inv measure_preserving_mul_prod_inv\n\n",
 "measure_preserving_mul_prod":
 "/-- The map `(x, y) ↦ (xy, y)` preserves the measure `μ × ν`. -/\n@[to_additive measure_preserving_add_prod \" The map `(x, y) ↦ (x + y, y)` preserves the measure `μ × ν`. \"]\ntheorem measure_preserving_mul_prod [is_mul_right_invariant μ] :\n    MeasurePreserving (fun z : G × G => (z.1 * z.2, z.2)) (μ.prod ν) (μ.prod ν) :=\n  measure_preserving_swap.comp <| by apply measure_preserving_prod_mul_swap_right μ ν\n#align measure_preserving_mul_prod measure_preserving_mul_prod\n\n",
 "measure_preserving_div_prod":
 "/-- The map `(x, y) ↦ (x / y, y)` preserves the measure `μ × ν`. -/\n@[to_additive measure_preserving_sub_prod \" The map `(x, y) ↦ (x - y, y)` preserves the measure `μ × ν`. \"]\ntheorem measure_preserving_div_prod [is_mul_right_invariant μ] :\n    MeasurePreserving (fun z : G × G => (z.1 / z.2, z.2)) (μ.prod ν) (μ.prod ν) :=\n  measure_preserving_swap.comp <| by apply measure_preserving_prod_div_swap μ ν\n#align measure_preserving_div_prod measure_preserving_div_prod\n\n",
 "measure_mul_right_null":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n@[to_additive]\ntheorem measure_mul_right_null (y : G) : μ («expr ⁻¹' » (fun x => x * y) s) = 0 ↔ μ s = 0 :=\n  calc\n    μ («expr ⁻¹' » (fun x => x * y) s) = 0 ↔ μ («expr ⁻¹' » (fun x => y⁻¹ * x) s⁻¹)⁻¹ = 0 := by\n      simp_rw [← inv_preimage, preimage_preimage, mul_inv_rev, inv_inv]\n    _ ↔ μ s = 0 := by simp only [measure_inv_null μ, measure_preimage_mul]\n    \n#align measure_mul_right_null measure_mul_right_null\n\n",
 "measure_mul_right_ne_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n@[to_additive]\ntheorem measure_mul_right_ne_zero (h2s : μ s ≠ 0) (y : G) : μ («expr ⁻¹' » (fun x => x * y) s) ≠ 0 :=\n  (not_congr (measure_mul_right_null μ y)).mpr h2s\n#align measure_mul_right_ne_zero measure_mul_right_ne_zero\n\n",
 "measure_mul_measure_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n@[to_additive]\ntheorem measure_mul_measure_eq [is_mul_left_invariant ν] {s t : Set G} (hs : MeasurableSet s) (ht : MeasurableSet t)\n    (h2s : ν s ≠ 0) (h3s : ν s ≠ ennreal.top) : μ s * ν t = ν s * μ t :=\n  by\n  have h1 := measure_lintegral_div_measure ν ν hs h2s h3s (t.indicator fun x => 1) (measurable_const.indicator ht)\n  have h2 := measure_lintegral_div_measure μ ν hs h2s h3s (t.indicator fun x => 1) (measurable_const.indicator ht)\n  rw [lintegral_indicator _ ht, set_lintegral_one] at h1 h2\n  rw [← h1, mul_left_comm, h2]\n#align measure_mul_measure_eq measure_mul_measure_eq\n\n",
 "measure_mul_lintegral_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫⁻ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫⁻ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/-- This is the computation performed in the proof of [Halmos, §60 Th. A]. -/\n@[to_additive \"This is the computation performed in the proof of [Halmos, §60 Th. A].\"]\ntheorem measure_mul_lintegral_eq [is_mul_left_invariant ν] (sm : MeasurableSet s) (f : G → ennreal)\n    (hf : Measurable f) :\n    μ s *\n        «expr∫⁻ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ , ∂ »\" (f y) ν =\n      «expr∫⁻ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ , ∂ »\"\n        (ν («expr ⁻¹' » (fun z => z * x) s) * f x⁻¹) μ :=\n  by\n  rw [← set_lintegral_one, ← lintegral_indicator _ sm, ←\n    lintegral_lintegral_mul (measurable_const.indicator sm).ae_measurable hf.ae_measurable, ←\n    lintegral_lintegral_mul_inv μ ν]\n  swap\n  · exact (((measurable_const.indicator sm).comp measurable_fst).mul (hf.comp measurable_snd)).ae_measurable\n  have ms : ∀ x : G, Measurable fun y => («expr ⁻¹' » (fun z => z * x) s).indicator (fun z => (1 : ennreal)) y :=\n    fun x => measurable_const.indicator (measurable_mul_const _ sm)\n  have :\n    ∀ x y,\n      s.indicator (fun z : G => (1 : ennreal)) (y * x) =\n        («expr ⁻¹' » (fun z => z * x) s).indicator (fun b : G => 1) y :=\n    by\n    intro x y\n    symm\n    convert indicator_comp_right fun y => y * x\n    ext1 z\n    rfl\n  simp_rw [this, lintegral_mul_const _ (ms _), lintegral_indicator _ (measurable_mul_const _ sm), set_lintegral_one]\n#align measure_mul_lintegral_eq measure_mul_lintegral_eq\n\n",
 "measure_lintegral_div_measure":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫⁻ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫⁻ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ , ∂ » -/\n/-- A technical lemma relating two different measures. This is basically [Halmos, §60 Th. A].\n  Note that if `f` is the characteristic function of a measurable set `t` this states that\n  `μ t = c * μ s` for a constant `c` that does not depend on `μ`.\n\n  Note: There is a gap in the last step of the proof in [Halmos].\n  In the last line, the equality `g(x⁻¹)ν(sx⁻¹) = f(x)` holds if we can prove that\n  `0 < ν(sx⁻¹) < ∞`. The first inequality follows from §59, Th. D, but the second inequality is\n  not justified. We prove this inequality for almost all `x` in\n  `measure_theory.ae_measure_preimage_mul_right_lt_top_of_ne_zero`. -/\n@[to_additive\n      \"A technical lemma relating two different measures. This is basically\\n[Halmos, §60 Th. A]. Note that if `f` is the characteristic function of a measurable set `t` this\\nstates that `μ t = c * μ s` for a constant `c` that does not depend on `μ`.\\n\\nNote: There is a gap in the last step of the proof in [Halmos]. In the last line, the equality\\n`g(-x) + ν(s - x) = f(x)` holds if we can prove that `0 < ν(s - x) < ∞`. The first inequality\\nfollows from §59, Th. D, but the second inequality is not justified. We prove this inequality for\\nalmost all `x` in `measure_theory.ae_measure_preimage_add_right_lt_top_of_ne_zero`.\"]\ntheorem measure_lintegral_div_measure [is_mul_left_invariant ν] (sm : MeasurableSet s) (h2s : ν s ≠ 0)\n    (h3s : ν s ≠ ennreal.top) (f : G → ennreal) (hf : Measurable f) :\n    μ s *\n        «expr∫⁻ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ , ∂ »\"\n          (f y⁻¹ / ν («expr ⁻¹' » (fun x => x * y⁻¹) s)) ν =\n      «expr∫⁻ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ , ∂ »\" (f x) μ :=\n  by\n  set g := fun y => f y⁻¹ / ν («expr ⁻¹' » (fun x => x * y⁻¹) s)\n  have hg : Measurable g := (hf.comp measurable_inv).div ((measurable_measure_mul_right ν sm).comp measurable_inv)\n  simp_rw [measure_mul_lintegral_eq μ ν sm g hg, g, inv_inv]\n  refine' lintegral_congr_ae _\n  refine' (ae_measure_preimage_mul_right_lt_top_of_ne_zero μ ν sm h2s h3s).mono fun x hx => _\n  simp_rw [ENNReal.mul_div_cancel' (measure_mul_right_ne_zero ν h2s _) hx.ne]\n#align measure_lintegral_div_measure measure_lintegral_div_measure\n\n",
 "measure_inv_null":
 "@[to_additive]\ntheorem measure_inv_null : μ s⁻¹ = 0 ↔ μ s = 0 :=\n  by\n  refine' ⟨fun hs => _, (quasi_measure_preserving_inv μ).preimage_null⟩\n  rw [← inv_inv s]\n  exact (quasi_measure_preserving_inv μ).preimage_null hs\n#align measure_inv_null measure_inv_null\n\n",
 "measure_eq_div_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- Left invariant Borel measures on a measurable group are unique (up to a scalar). -/\n@[to_additive \" Left invariant Borel measures on an additive measurable group are unique\\n  (up to a scalar). \"]\ntheorem measure_eq_div_smul [is_mul_left_invariant ν] (hs : MeasurableSet s) (h2s : ν s ≠ 0) (h3s : ν s ≠ ennreal.top) :\n    μ = «expr • » (μ s / ν s) ν := by\n  ext1 t ht\n  rw [smul_apply, smul_eq_mul, mul_comm, ← mul_div_assoc, mul_comm, measure_mul_measure_eq μ ν hs ht h2s h3s,\n    mul_div_assoc, ENNReal.mul_div_cancel' h2s h3s]\n#align measure_eq_div_smul measure_eq_div_smul\n\n",
 "measurable_measure_mul_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n@[to_additive]\ntheorem measurable_measure_mul_right (hs : MeasurableSet s) : Measurable fun x => μ («expr ⁻¹' » (fun y => y * x) s) :=\n  by\n  suffices\n    Measurable fun y =>\n      μ («expr ⁻¹' » (fun x => (x, y)) («expr ⁻¹' » (fun z : G × G => ((1 : G), z.1 * z.2)) (lower_set.prod univ s)))\n    by\n    convert this\n    ext1 x\n    congr 1 with y : 1\n    simp\n  apply measurable_measure_prod_mk_right\n  exact measurable_const.prod_mk measurable_mul (measurable_set.univ.prod hs)\n#align measurable_measure_mul_right measurable_measure_mul_right\n\n",
 "lintegral_lintegral_mul_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫⁻ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫⁻ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫⁻ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫⁻ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ , ∂ » -/\n@[to_additive]\ntheorem lintegral_lintegral_mul_inv [is_mul_left_invariant ν] (f : G → G → ennreal)\n    (hf : AEMeasurable (uncurry f) (μ.prod ν)) :\n    «expr∫⁻ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ , ∂ »\"\n        («expr∫⁻ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ , ∂ »\"\n          (f (y * x) x⁻¹) ν)\n        μ =\n      «expr∫⁻ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ , ∂ »\"\n        («expr∫⁻ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ , ∂ »\" (f x y)\n          ν)\n        μ :=\n  by\n  have h : Measurable fun z : G × G => (z.2 * z.1, z.1⁻¹) :=\n    (measurable_snd.mul measurable_fst).prod_mk measurable_fst.inv\n  have h2f : AEMeasurable (uncurry fun x y => f (y * x) x⁻¹) (μ.prod ν) :=\n    hf.comp_quasi_measure_preserving (measure_preserving_mul_prod_inv μ ν).quasi_measure_preserving\n  simp_rw [lintegral_lintegral h2f, lintegral_lintegral hf]\n  conv_rhs => rw [← (measure_preserving_mul_prod_inv μ ν).map_eq]\n  symm\n  exact lintegral_map' (hf.mono' (measure_preserving_mul_prod_inv μ ν).map_eq.absolutely_continuous) h.ae_measurable\n#align lintegral_lintegral_mul_inv lintegral_lintegral_mul_inv\n\n",
 "inv_absolutely_continuous":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure.absolutely_continuous -/\n@[to_additive]\ntheorem inv_absolutely_continuous : measure.absolutely_continuous μ.inv μ :=\n  (quasi_measure_preserving_inv μ).absolutely_continuous\n#align inv_absolutely_continuous inv_absolutely_continuous\n\n",
 "ae_measure_preimage_mul_right_lt_top_of_ne_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n@[to_additive]\ntheorem ae_measure_preimage_mul_right_lt_top_of_ne_zero [is_mul_left_invariant ν] (sm : MeasurableSet s) (h2s : ν s ≠ 0)\n    (h3s : ν s ≠ ennreal.top) :\n    «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\" μ\n      (ν («expr ⁻¹' » (fun y => y * x) s) < ennreal.top) :=\n  by\n  refine' (ae_measure_preimage_mul_right_lt_top ν ν sm h3s).filter_mono _\n  refine' (absolutely_continuous_of_is_mul_left_invariant μ ν _).ae_le\n  refine' mt _ h2s\n  intro hν\n  rw [hν, measure.coe_zero, Pi.zero_apply]\n#align ae_measure_preimage_mul_right_lt_top_of_ne_zero ae_measure_preimage_mul_right_lt_top_of_ne_zero\n\n",
 "ae_measure_preimage_mul_right_lt_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n@[to_additive]\ntheorem ae_measure_preimage_mul_right_lt_top [is_mul_left_invariant ν] (sm : MeasurableSet s)\n    (hμs : μ s ≠ ennreal.top) :\n    «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\" μ\n      (ν («expr ⁻¹' » (fun y => y * x) s) < ennreal.top) :=\n  by\n  refine' ae_of_forall_measure_lt_top_ae_restrict' ν.inv _ _\n  intro A hA h2A h3A\n  simp only [ν.inv_apply] at h3A\n  apply ae_lt_top (measurable_measure_mul_right ν sm)\n  have h1 := measure_mul_lintegral_eq μ ν sm (A⁻¹.indicator 1) (measurable_one.indicator hA.inv)\n  rw [lintegral_indicator _ hA.inv] at h1\n  simp_rw [Pi.one_apply, set_lintegral_one, ← image_inv, indicator_image inv_injective, image_inv, ←\n    indicator_mul_right _ fun x => ν («expr ⁻¹' » (fun y => y * x) s), Function.comp, Pi.one_apply, mul_one] at h1\n  rw [← lintegral_indicator _ hA, ← h1]\n  exact ENNReal.mul_ne_top hμs h3A.ne\n#align ae_measure_preimage_mul_right_lt_top ae_measure_preimage_mul_right_lt_top\n\n",
 "absolutely_continuous_of_is_mul_left_invariant":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure.absolutely_continuous -/\n/-- Any two nonzero left-invariant measures are absolutely continuous w.r.t. each other. -/\n@[to_additive \" Any two nonzero left-invariant measures are absolutely continuous w.r.t. each\\nother. \"]\ntheorem absolutely_continuous_of_is_mul_left_invariant [is_mul_left_invariant ν] (hν : ν ≠ 0) :\n    measure.absolutely_continuous μ ν :=\n  by\n  refine' absolutely_continuous.mk fun s sm hνs => _\n  have h1 := measure_mul_lintegral_eq μ ν sm 1 measurable_one\n  simp_rw [Pi.one_apply, lintegral_one, mul_one, (measure_mul_right_null ν _).mpr hνs, lintegral_zero, mul_eq_zero,\n    measure_univ_eq_zero.not.mpr hν, or_false_iff] at h1\n  exact h1\n#align absolutely_continuous_of_is_mul_left_invariant absolutely_continuous_of_is_mul_left_invariant\n\n",
 "absolutely_continuous_map_mul_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure.absolutely_continuous -/\n@[to_additive]\ntheorem absolutely_continuous_map_mul_right (g : G) : measure.absolutely_continuous μ (map (· * g) μ) :=\n  by\n  refine' absolutely_continuous.mk fun s hs => _\n  rw [map_apply (measurable_mul_const g) hs, measure_mul_right_null]; exact id\n#align absolutely_continuous_map_mul_right absolutely_continuous_map_mul_right\n\n",
 "absolutely_continuous_map_div_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure.absolutely_continuous -/\n@[to_additive]\ntheorem absolutely_continuous_map_div_left (g : G) : measure.absolutely_continuous μ (map (fun h => g / h) μ) :=\n  by\n  simp_rw [div_eq_mul_inv]\n  rw [← map_map (measurable_const_mul g) measurable_inv]\n  conv_lhs => rw [← map_mul_left_eq_self μ g]\n  exact (absolutely_continuous_inv μ).map (measurable_const_mul g)\n#align absolutely_continuous_map_div_left absolutely_continuous_map_div_left\n\n",
 "absolutely_continuous_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure.absolutely_continuous -/\n@[to_additive]\ntheorem absolutely_continuous_inv : measure.absolutely_continuous μ μ.inv :=\n  by\n  refine' absolutely_continuous.mk fun s hs => _\n  simp_rw [inv_apply μ s, measure_inv_null, imp_self]\n#align absolutely_continuous_inv absolutely_continuous_inv\n\n"}