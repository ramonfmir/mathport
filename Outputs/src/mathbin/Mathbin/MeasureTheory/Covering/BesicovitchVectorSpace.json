{"one_lt_good_τ":
 "theorem one_lt_good_τ : 1 < good_τ E := by\n  dsimp [good_τ, good_δ]\n  linarith [(exists_good_δ E).some_spec.1]\n#align one_lt_good_τ one_lt_good_τ\n\n",
 "multiplicity_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem multiplicity_le : multiplicity E ≤ 5 ^ finrank (exprℝ) E :=\n  by\n  apply csupₛ_le\n  · refine' ⟨0, ⟨∅, by simp⟩⟩\n  · rintro _ ⟨s, ⟨rfl, h⟩⟩\n    exact besicovitch.card_le_of_separated s h.1 h.2\n#align multiplicity_le multiplicity_le\n\n",
 "le_multiplicity_of_δ_of_fin":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem le_multiplicity_of_δ_of_fin {n : ℕ} (f : fin n → E) (h : ∀ i, «expr‖ ‖» (f i) ≤ 2)\n    (h' : ∀ i j, i ≠ j → 1 - good_δ E ≤ «expr‖ ‖» (f i - f j)) : n ≤ multiplicity E := by\n  classical\n    have finj : function.injective f := by\n      intro i j hij\n      by_contra\n      have : 1 - good_δ E ≤ «expr‖ ‖» (f i - f j) := h' i j h\n      simp only [hij, norm_zero, sub_self] at this\n      linarith [good_δ_lt_one E]\n    let s := Finset.image f finset.univ\n    have s_card : s.card = n := by\n      rw [finset.card_image_of_injective _ finj]\n      exact finset.card_fin n\n    have hs : ∀ c ∈ s, «expr‖ ‖» c ≤ 2 := by\n      simp only [h, forall_apply_eq_imp_iff', forall_const, forall_exists_index, finset.mem_univ, Finset.mem_image,\n        imp_true_iff]\n    have h's : ∀ c ∈ s, ∀ d ∈ s, c ≠ d → 1 - good_δ E ≤ «expr‖ ‖» (c - d) :=\n      by\n      simp only [s, forall_apply_eq_imp_iff', forall_exists_index, finset.mem_univ, Finset.mem_image, ne.def,\n        exists_true_left, forall_apply_eq_imp_iff', forall_true_left]\n      intro i j hij\n      have : i ≠ j := fun h => by\n        rw [h] at hij\n        exact hij rfl\n      exact h' i j this\n    have : s.card ≤ multiplicity E := card_le_multiplicity_of_δ hs h's\n    rwa [s_card] at this\n#align le_multiplicity_of_δ_of_fin le_multiplicity_of_δ_of_fin\n\n",
 "is_empty_satellite_config_multiplicity":
 "/-- In a normed vector space `E`, there can be no satellite configuration with `multiplicity E + 1`\npoints and the parameter `good_τ E`. This will ensure that in the inductive construction to get\nthe Besicovitch covering families, there will never be more than `multiplicity E` nonempty\nfamilies. -/\ntheorem is_empty_satellite_config_multiplicity : is_empty (satellite_config E (multiplicity E) (good_τ E)) :=\n  ⟨by\n    intro a\n    let b := a.center_and_rescale\n    rcases b.exists_normalized a.center_and_rescale_center a.center_and_rescale_radius (one_lt_good_τ E).le (good_δ E)\n        le_rfl (good_δ_lt_one E).le with\n      ⟨c', c'_le_two, hc'⟩\n    exact lt_irrefl _ ((nat.lt_succ_self _).trans_le (le_multiplicity_of_δ_of_fin c' c'_le_two hc'))⟩\n#align is_empty_satellite_config_multiplicity is_empty_satellite_config_multiplicity\n\n",
 "good_δ_lt_one":
 "theorem good_δ_lt_one : good_δ E < 1 :=\n  (exists_good_δ E).some_spec.2.1\n#align good_δ_lt_one good_δ_lt_one\n\n",
 "exists_normalized_aux3":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem exists_normalized_aux3 {N : ℕ} {τ : exprℝ} (a : satellite_config E N τ) (lastc : a.c (last N) = 0)\n    (lastr : a.r (last N) = 1) (hτ : 1 ≤ τ) (δ : exprℝ) (hδ1 : τ ≤ 1 + δ / 4) (i j : fin N.succ) (inej : i ≠ j)\n    (hi : 2 < «expr‖ ‖» (a.c i)) (hij : «expr‖ ‖» (a.c i) ≤ «expr‖ ‖» (a.c j)) :\n    1 - δ ≤ «expr‖ ‖» («expr • » (2 / «expr‖ ‖» (a.c i)) (a.c i) - «expr • » (2 / «expr‖ ‖» (a.c j)) (a.c j)) :=\n  by\n  have ah :\n    ∀ i j,\n      i ≠ j →\n        a.r i ≤ «expr‖ ‖» (a.c i - a.c j) ∧ a.r j ≤ τ * a.r i ∨ a.r j ≤ «expr‖ ‖» (a.c j - a.c i) ∧ a.r i ≤ τ * a.r j :=\n    by simpa only [dist_eq_norm] using a.h\n  have δnonneg : 0 ≤ δ := by linarith only [hτ, hδ1]\n  have τpos : 0 < τ := _root_.zero_lt_one.trans_le hτ\n  have hcrj : «expr‖ ‖» (a.c j) ≤ a.r j + 1 := by simpa only [lastc, lastr, dist_zero_right] using a.inter' j\n  have A : a.r i ≤ «expr‖ ‖» (a.c i) :=\n    by\n    have : i < last N := by\n      apply lt_top_iff_ne_top.2\n      intro iN\n      change i = last N at iN\n      rw [iN, lastc, norm_zero] at hi\n      exact lt_irrefl _ (zero_le_two.trans_lt hi)\n    convert (a.hlast i this).1\n    rw [dist_eq_norm, lastc, sub_zero]\n  have hj : 2 < «expr‖ ‖» (a.c j) := hi.trans_le hij\n  set s := «expr‖ ‖» (a.c i) with hs\n  have spos : 0 < s := zero_lt_two.trans hi\n  set d := «expr • » (s / «expr‖ ‖» (a.c j)) (a.c j) with hd\n  have I : «expr‖ ‖» (a.c j - a.c i) ≤ «expr‖ ‖» (a.c j) - s + «expr‖ ‖» (d - a.c i) :=\n    calc\n      «expr‖ ‖» (a.c j - a.c i) ≤ «expr‖ ‖» (a.c j - d) + «expr‖ ‖» (d - a.c i) := by\n        simp [← dist_eq_norm, dist_triangle]\n      _ = «expr‖ ‖» (a.c j) - «expr‖ ‖» (a.c i) + «expr‖ ‖» (d - a.c i) :=\n        by\n        nth_rw 1 [← one_smul (exprℝ) (a.c j)]\n        rw [add_left_inj, hd, ← sub_smul, norm_smul, real.norm_eq_abs, abs_of_nonneg, sub_mul, one_mul,\n          div_mul_cancel _ (zero_le_two.trans_lt hj).ne']\n        rwa [sub_nonneg, div_le_iff (zero_lt_two.trans hj), one_mul]\n      \n  have J : a.r j - «expr‖ ‖» (a.c j - a.c i) ≤ s / 2 * δ :=\n    calc\n      a.r j - «expr‖ ‖» (a.c j - a.c i) ≤ s * (τ - 1) :=\n        by\n        rcases ah j i inej.symm with (H | H)\n        ·\n          calc\n            a.r j - «expr‖ ‖» (a.c j - a.c i) ≤ 0 := sub_nonpos.2 H.1\n            _ ≤ s * (τ - 1) := mul_nonneg spos.le (sub_nonneg.2 hτ)\n            \n        · rw [norm_sub_rev] at H\n          calc\n            a.r j - «expr‖ ‖» (a.c j - a.c i) ≤ τ * a.r i - a.r i := sub_le_sub H.2 H.1\n            _ = a.r i * (τ - 1) := by ring\n            _ ≤ s * (τ - 1) := mul_le_mul_of_nonneg_right A (sub_nonneg.2 hτ)\n            \n      _ ≤ s * (δ / 2) := mul_le_mul_of_nonneg_left (by linarith only [δnonneg, hδ1]) spos.le\n      _ = s / 2 * δ := by ring\n      \n  have invs_nonneg : 0 ≤ 2 / s := div_nonneg zero_le_two (zero_le_two.trans hi.le)\n  calc\n    1 - δ = 2 / s * (s / 2 - s / 2 * δ) := by\n      field_simp [spos.ne']\n      ring\n    _ ≤ 2 / s * «expr‖ ‖» (d - a.c i) := mul_le_mul_of_nonneg_left (by linarith only [hcrj, I, J, hi]) invs_nonneg\n    _ = «expr‖ ‖» («expr • » (2 / s) (a.c i) - «expr • » (2 / «expr‖ ‖» (a.c j)) (a.c j)) :=\n      by\n      conv_lhs => rw [norm_sub_rev, ← abs_of_nonneg invs_nonneg]\n      rw [← real.norm_eq_abs, ← norm_smul, smul_sub, hd, smul_smul]\n      congr 3\n      field_simp [spos.ne']\n    \n#align exists_normalized_aux3 exists_normalized_aux3\n\n",
 "exists_normalized_aux2":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem exists_normalized_aux2 {N : ℕ} {τ : exprℝ} (a : satellite_config E N τ) (lastc : a.c (last N) = 0)\n    (lastr : a.r (last N) = 1) (hτ : 1 ≤ τ) (δ : exprℝ) (hδ1 : τ ≤ 1 + δ / 4) (hδ2 : δ ≤ 1) (i j : fin N.succ)\n    (inej : i ≠ j) (hi : «expr‖ ‖» (a.c i) ≤ 2) (hj : 2 < «expr‖ ‖» (a.c j)) :\n    1 - δ ≤ «expr‖ ‖» (a.c i - «expr • » (2 / «expr‖ ‖» (a.c j)) (a.c j)) :=\n  by\n  have ah :\n    ∀ i j,\n      i ≠ j →\n        a.r i ≤ «expr‖ ‖» (a.c i - a.c j) ∧ a.r j ≤ τ * a.r i ∨ a.r j ≤ «expr‖ ‖» (a.c j - a.c i) ∧ a.r i ≤ τ * a.r j :=\n    by simpa only [dist_eq_norm] using a.h\n  have δnonneg : 0 ≤ δ := by linarith only [hτ, hδ1]\n  have D : 0 ≤ 1 - δ / 4 := by linarith only [hδ2]\n  have τpos : 0 < τ := _root_.zero_lt_one.trans_le hτ\n  have hcrj : «expr‖ ‖» (a.c j) ≤ a.r j + 1 := by simpa only [lastc, lastr, dist_zero_right] using a.inter' j\n  have I : a.r i ≤ 2 := by\n    rcases lt_or_le i (last N) with (H | H)\n    · apply (a.hlast i H).1.trans\n      simpa only [dist_eq_norm, lastc, sub_zero] using hi\n    · have : i = last N := top_le_iff.1 H\n      rw [this, lastr]\n      exact one_le_two\n  have J : (1 - δ / 4) * τ ≤ 1 :=\n    calc\n      (1 - δ / 4) * τ ≤ (1 - δ / 4) * (1 + δ / 4) := mul_le_mul_of_nonneg_left hδ1 D\n      _ = 1 - δ ^ 2 / 16 := by ring\n      _ ≤ 1 := by linarith only [sq_nonneg δ]\n      \n  have A : a.r j - δ ≤ «expr‖ ‖» (a.c i - a.c j) :=\n    by\n    rcases ah j i inej.symm with (H | H)\n    · rw [norm_sub_rev]\n      linarith [H.1]\n    have C : a.r j ≤ 4 :=\n      calc\n        a.r j ≤ τ * a.r i := H.2\n        _ ≤ τ * 2 := mul_le_mul_of_nonneg_left I τpos.le\n        _ ≤ 5 / 4 * 2 := mul_le_mul_of_nonneg_right (by linarith only [hδ1, hδ2]) zero_le_two\n        _ ≤ 4 := by norm_num\n        \n    calc\n      a.r j - δ ≤ a.r j - a.r j / 4 * δ := by\n        refine' sub_le_sub le_rfl _\n        refine' mul_le_of_le_one_left δnonneg _\n        linarith only [C]\n      _ = (1 - δ / 4) * a.r j := by ring\n      _ ≤ (1 - δ / 4) * (τ * a.r i) := mul_le_mul_of_nonneg_left H.2 D\n      _ ≤ 1 * a.r i := by\n        rw [← mul_assoc]\n        apply mul_le_mul_of_nonneg_right J (a.rpos _).le\n      _ ≤ «expr‖ ‖» (a.c i - a.c j) := by\n        rw [one_mul]\n        exact H.1\n      \n  set d := «expr • » (2 / «expr‖ ‖» (a.c j)) (a.c j) with hd\n  have : a.r j - δ ≤ «expr‖ ‖» (a.c i - d) + (a.r j - 1) :=\n    calc\n      a.r j - δ ≤ «expr‖ ‖» (a.c i - a.c j) := A\n      _ ≤ «expr‖ ‖» (a.c i - d) + «expr‖ ‖» (d - a.c j) := by simp only [← dist_eq_norm, dist_triangle]\n      _ ≤ «expr‖ ‖» (a.c i - d) + (a.r j - 1) := by\n        apply add_le_add_left\n        have A : 0 ≤ 1 - 2 / «expr‖ ‖» (a.c j) := by simpa [div_le_iff (zero_le_two.trans_lt hj)] using hj.le\n        rw [← one_smul (exprℝ) (a.c j), hd, ← sub_smul, norm_smul, norm_sub_rev, real.norm_eq_abs, abs_of_nonneg A,\n          sub_mul]\n        field_simp [(zero_le_two.trans_lt hj).ne']\n        linarith only [hcrj]\n      \n  linarith only [this]\n#align exists_normalized_aux2 exists_normalized_aux2\n\n",
 "exists_normalized_aux1":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem exists_normalized_aux1 {N : ℕ} {τ : exprℝ} (a : satellite_config E N τ) (lastr : a.r (last N) = 1) (hτ : 1 ≤ τ)\n    (δ : exprℝ) (hδ1 : τ ≤ 1 + δ / 4) (hδ2 : δ ≤ 1) (i j : fin N.succ) (inej : i ≠ j) :\n    1 - δ ≤ «expr‖ ‖» (a.c i - a.c j) :=\n  by\n  have ah :\n    ∀ i j,\n      i ≠ j →\n        a.r i ≤ «expr‖ ‖» (a.c i - a.c j) ∧ a.r j ≤ τ * a.r i ∨ a.r j ≤ «expr‖ ‖» (a.c j - a.c i) ∧ a.r i ≤ τ * a.r j :=\n    by simpa only [dist_eq_norm] using a.h\n  have δnonneg : 0 ≤ δ := by linarith only [hτ, hδ1]\n  have D : 0 ≤ 1 - δ / 4 := by linarith only [hδ2]\n  have τpos : 0 < τ := _root_.zero_lt_one.trans_le hτ\n  have I : (1 - δ / 4) * τ ≤ 1 :=\n    calc\n      (1 - δ / 4) * τ ≤ (1 - δ / 4) * (1 + δ / 4) := mul_le_mul_of_nonneg_left hδ1 D\n      _ = 1 - δ ^ 2 / 16 := by ring\n      _ ≤ 1 := by linarith only [sq_nonneg δ]\n      \n  have J : 1 - δ ≤ 1 - δ / 4 := by linarith only [δnonneg]\n  have K : 1 - δ / 4 ≤ τ⁻¹ := by\n    rw [inv_eq_one_div, le_div_iff τpos]\n    exact I\n  suffices L : τ⁻¹ ≤ «expr‖ ‖» (a.c i - a.c j)\n  · linarith only [J, K, L]\n  have hτ' : ∀ k, τ⁻¹ ≤ a.r k := by\n    intro k\n    rw [inv_eq_one_div, div_le_iff τpos, ← lastr, mul_comm]\n    exact a.hlast' k hτ\n  rcases ah i j inej with (H | H)\n  · apply le_trans _ H.1\n    exact hτ' i\n  · rw [norm_sub_rev]\n    apply le_trans _ H.1\n    exact hτ' j\n#align exists_normalized_aux1 exists_normalized_aux1\n\n",
 "exists_normalized":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem exists_normalized {N : ℕ} {τ : exprℝ} (a : satellite_config E N τ) (lastc : a.c (last N) = 0)\n    (lastr : a.r (last N) = 1) (hτ : 1 ≤ τ) (δ : exprℝ) (hδ1 : τ ≤ 1 + δ / 4) (hδ2 : δ ≤ 1) :\n    ∃ c' : fin N.succ → E, (∀ n, «expr‖ ‖» (c' n) ≤ 2) ∧ ∀ i j, i ≠ j → 1 - δ ≤ «expr‖ ‖» (c' i - c' j) :=\n  by\n  let c' : fin N.succ → E := fun i => if «expr‖ ‖» (a.c i) ≤ 2 then a.c i else «expr • » (2 / «expr‖ ‖» (a.c i)) (a.c i)\n  have norm_c'_le : ∀ i, «expr‖ ‖» (c' i) ≤ 2 := by\n    intro i\n    simp only [c']\n    split_ifs\n    · exact h\n    by_cases hi : «expr‖ ‖» (a.c i) = 0 <;> field_simp [norm_smul, hi]\n  refine' ⟨c', fun n => norm_c'_le n, fun i j inej => _⟩\n  -- up to exchanging `i` and `j`, one can assume `‖c i‖ ≤ ‖c j‖`.\n  wlog (discharger := tactic.skip) hij : «expr‖ ‖» (a.c i) ≤ «expr‖ ‖» (a.c j) :=\n    le_total («expr‖ ‖» (a.c i)) («expr‖ ‖» (a.c j)) using i j, j i\n  swap\n  · intro i_ne_j\n    rw [norm_sub_rev]\n    exact this i_ne_j.symm\n  rcases le_or_lt («expr‖ ‖» (a.c j)) 2 with (Hj | Hj)\n  -- case `‖c j‖ ≤ 2` (and therefore also `‖c i‖ ≤ 2`)\n  · simp_rw [c', Hj, hij.trans Hj, if_true]\n    exact exists_normalized_aux1 a lastr hτ δ hδ1 hδ2 i j inej\n  -- case `2 < ‖c j‖`\n  · have H'j : «expr‖ ‖» (a.c j) ≤ 2 ↔ false := by simpa only [not_le, iff_false_iff] using Hj\n    rcases le_or_lt («expr‖ ‖» (a.c i)) 2 with (Hi | Hi)\n    · -- case `‖c i‖ ≤ 2`\n      simp_rw [c', Hi, if_true, H'j, if_false]\n      exact exists_normalized_aux2 a lastc lastr hτ δ hδ1 hδ2 i j inej Hi Hj\n    · -- case `2 < ‖c i‖`\n      have H'i : «expr‖ ‖» (a.c i) ≤ 2 ↔ false := by simpa only [not_le, iff_false_iff] using Hi\n      simp_rw [c', H'i, if_false, H'j, if_false]\n      exact exists_normalized_aux3 a lastc lastr hτ δ hδ1 i j inej Hi hij\n#align exists_normalized exists_normalized\n\n",
 "exists_good_δ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/-- If `δ` is small enough, a `(1-δ)`-separated set in the ball of radius `2` also has cardinality\nat most `multiplicity E`. -/\ntheorem exists_good_δ :\n    ∃ δ : exprℝ,\n      0 < δ ∧\n        δ < 1 ∧\n          ∀ s : Finset E,\n            (∀ c ∈ s, «expr‖ ‖» c ≤ 2) →\n              (∀ c ∈ s, ∀ d ∈ s, c ≠ d → 1 - δ ≤ «expr‖ ‖» (c - d)) → s.card ≤ multiplicity E :=\n  by\n  classical\n    /- This follows from a compactness argument: otherwise, one could extract a converging\n      subsequence, to obtain a `1`-separated set in the ball of radius `2` with cardinality\n      `N = multiplicity E + 1`. To formalize this, we work with functions `fin N → E`.\n       -/\n    by_contra' h\n    set N := multiplicity E + 1 with hN\n    have :\n      ∀ δ : exprℝ,\n        0 < δ → ∃ f : fin N → E, (∀ i : fin N, «expr‖ ‖» (f i) ≤ 2) ∧ ∀ i j, i ≠ j → 1 - δ ≤ «expr‖ ‖» (f i - f j) :=\n      by\n      intro δ hδ\n      rcases lt_or_le δ 1 with (hδ' | hδ')\n      · rcases h δ hδ hδ' with ⟨s, hs, h's, s_card⟩\n        obtain ⟨f, f_inj, hfs⟩ : ∃ f : fin N → E, function.injective f ∧ range f ⊆ ↑s :=\n          by\n          have : fintype.card (fin N) ≤ s.card := by\n            simp only [fintype.card_fin]\n            exact s_card\n          rcases function.embedding.exists_of_card_le_finset this with ⟨f, hf⟩\n          exact ⟨f, f.injective, hf⟩\n        simp only [range_subset_iff, Finset.mem_coe] at hfs\n        refine' ⟨f, fun i => hs _ (hfs i), fun i j hij => h's _ (hfs i) _ (hfs j) (f_inj.ne hij)⟩\n      · exact ⟨fun i => 0, fun i => by simp, fun i j hij => by simpa only [norm_zero, sub_nonpos, sub_self] ⟩\n    -- For `δ > 0`, `F δ` is a function from `fin N` to the ball of radius `2` for which two points\n    -- in the image are separated by `1 - δ`.\n    choose! F hF using this\n    -- Choose a converging subsequence when `δ → 0`.\n    have : ∃ f : fin N → E, (∀ i : fin N, «expr‖ ‖» (f i) ≤ 2) ∧ ∀ i j, i ≠ j → 1 ≤ «expr‖ ‖» (f i - f j) :=\n      by\n      obtain ⟨u, u_mono, zero_lt_u, hu⟩ :\n        ∃ u : ℕ → exprℝ,\n          (∀ m n : ℕ, m < n → u n < u m) ∧ (∀ n : ℕ, 0 < u n) ∧ filter.tendsto u filter.at_top ((nhds) 0) :=\n        exists_seq_strict_anti_tendsto (0 : exprℝ)\n      have A : ∀ n, F (u n) ∈ closed_ball (0 : fin N → E) 2 :=\n        by\n        intro n\n        simp only [pi_norm_le_iff_of_nonneg zero_le_two, mem_closed_ball, dist_zero_right,\n          (hF (u n) (zero_lt_u n)).left, forall_const]\n      obtain ⟨f, fmem, φ, φ_mono, hf⟩ :\n        ∃ f ∈ closed_ball (0 : fin N → E) 2, ∃ φ : ℕ → ℕ, strict_mono φ ∧ tendsto ((F ∘ u) ∘ φ) at_top ((nhds) f) :=\n        is_compact.tendsto_subseq (is_compact_closed_ball _ _) A\n      refine' ⟨f, fun i => _, fun i j hij => _⟩\n      · simp only [pi_norm_le_iff_of_nonneg zero_le_two, mem_closed_ball, dist_zero_right] at fmem\n        exact fmem i\n      · have A : tendsto (fun n => «expr‖ ‖» (F (u (φ n)) i - F (u (φ n)) j)) at_top ((nhds) («expr‖ ‖» (f i - f j))) :=\n          ((hf.apply i).sub (hf.apply j)).norm\n        have B : tendsto (fun n => 1 - u (φ n)) at_top ((nhds) (1 - 0)) :=\n          tendsto_const_nhds.sub (hu.comp φ_mono.tendsto_at_top)\n        rw [sub_zero] at B\n        exact le_of_tendsto_of_tendsto' B A fun n => (hF (u (φ n)) (zero_lt_u _)).2 i j hij\n    rcases this with ⟨f, hf, h'f⟩\n    -- the range of `f` contradicts the definition of `multiplicity E`.\n    have finj : function.injective f := by\n      intro i j hij\n      by_contra\n      have : 1 ≤ «expr‖ ‖» (f i - f j) := h'f i j h\n      simp only [hij, norm_zero, sub_self] at this\n      exact lt_irrefl _ (this.trans_lt zero_lt_one)\n    let s := Finset.image f finset.univ\n    have s_card : s.card = N := by\n      rw [finset.card_image_of_injective _ finj]\n      exact finset.card_fin N\n    have hs : ∀ c ∈ s, «expr‖ ‖» c ≤ 2 := by\n      simp only [hf, forall_apply_eq_imp_iff', forall_const, forall_exists_index, finset.mem_univ, Finset.mem_image]\n    have h's : ∀ c ∈ s, ∀ d ∈ s, c ≠ d → 1 ≤ «expr‖ ‖» (c - d) :=\n      by\n      simp only [s, forall_apply_eq_imp_iff', forall_exists_index, finset.mem_univ, Finset.mem_image, ne.def,\n        exists_true_left, forall_apply_eq_imp_iff', forall_true_left]\n      intro i j hij\n      have : i ≠ j := fun h => by\n        rw [h] at hij\n        exact hij rfl\n      exact h'f i j this\n    have : s.card ≤ multiplicity E := card_le_multiplicity hs h's\n    rw [s_card, hN] at this\n    exact lt_irrefl _ ((nat.lt_succ_self (multiplicity E)).trans_le this)\n#align exists_good_δ exists_good_δ\n\n",
 "center_and_rescale_radius":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem center_and_rescale_radius {N : ℕ} {τ : exprℝ} (a : satellite_config E N τ) :\n    a.center_and_rescale.r (last N) = 1 := by simp [satellite_config.center_and_rescale, inv_mul_cancel (a.rpos _).ne']\n#align center_and_rescale_radius center_and_rescale_radius\n\n",
 "center_and_rescale_center":
 "/-\nCopyright (c) 2021 Sébastien Gouëzel. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Sébastien Gouëzel\n-/\ntheorem center_and_rescale_center : a.center_and_rescale.c (last N) = 0 := by simp [satellite_config.center_and_rescale]\n#align center_and_rescale_center center_and_rescale_center\n\n",
 "card_le_of_separated":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr on » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- Any `1`-separated set in the ball of radius `2` has cardinality at most `5 ^ dim`. This is\nuseful to show that the supremum in the definition of `besicovitch.multiplicity E` is\nwell behaved. -/\ntheorem card_le_of_separated (s : Finset E) (hs : ∀ c ∈ s, «expr‖ ‖» c ≤ 2)\n    (h : ∀ c ∈ s, ∀ d ∈ s, c ≠ d → 1 ≤ «expr‖ ‖» (c - d)) : s.card ≤ 5 ^ finrank (exprℝ) E :=\n  by\n  /- We consider balls of radius `1/2` around the points in `s`. They are disjoint, and all\n    contained in the ball of radius `5/2`. A volume argument gives `s.card * (1/2)^dim ≤ (5/2)^dim`,\n    i.e., `s.card ≤ 5^dim`. -/\n  borelize E\n  let μ : measure E := measure.add_haar\n  let δ : exprℝ := (1 : exprℝ) / 2\n  let ρ : exprℝ := (5 : exprℝ) / 2\n  have ρpos : 0 < ρ := by norm_num [ρ]\n  set A :=\n    «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n      (ball (c : E) δ) with\n    hA\n  have D : Set.Pairwise (s : set E) («expr on » Disjoint fun c => ball (c : E) δ) :=\n    by\n    rintro c hc d hd hcd\n    apply ball_disjoint_ball\n    rw [dist_eq_norm]\n    convert h c hc d hd hcd\n    norm_num\n  have A_subset : A ⊆ ball (0 : E) ρ := by\n    refine' Union₂_subset fun x hx => _\n    apply ball_subset_ball'\n    calc\n      δ + dist x 0 ≤ δ + 2 := by\n        rw [dist_zero_right]\n        exact add_le_add le_rfl (hs x hx)\n      _ = 5 / 2 := by norm_num [δ]\n      \n  have I :\n    (s.card : ennreal) * ennreal.of_real (δ ^ finrank (exprℝ) E) * μ (ball 0 1) ≤\n      ennreal.of_real (ρ ^ finrank (exprℝ) E) * μ (ball 0 1) :=\n    calc\n      (s.card : ennreal) * ennreal.of_real (δ ^ finrank (exprℝ) E) * μ (ball 0 1) = μ A :=\n        by\n        rw [hA, measure_bUnion_finset D fun c hc => measurable_set_ball]\n        have I : 0 < δ := by norm_num [δ]\n        simp only [μ.add_haar_ball_of_pos _ I, one_div, one_pow, finset.sum_const, nsmul_eq_mul, div_pow, mul_assoc]\n      _ ≤ μ (ball (0 : E) ρ) := measure_mono A_subset\n      _ = ennreal.of_real (ρ ^ finrank (exprℝ) E) * μ (ball 0 1) := by simp only [μ.add_haar_ball_of_pos _ ρpos]\n      \n  have J : (s.card : ennreal) * ennreal.of_real (δ ^ finrank (exprℝ) E) ≤ ennreal.of_real (ρ ^ finrank (exprℝ) E) :=\n    (ennreal.mul_le_mul_right (measure_ball_pos _ _ zero_lt_one).ne' measure_ball_lt_top.ne).1 I\n  have K : (s.card : exprℝ) ≤ (5 : exprℝ) ^ finrank (exprℝ) E := by\n    simpa [ennreal.to_real_mul, div_eq_mul_inv] using ennreal.to_real_le_of_le_of_real (pow_nonneg ρpos.le _) J\n  exact_mod_cast K\n#align card_le_of_separated card_le_of_separated\n\n",
 "card_le_multiplicity_of_δ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem card_le_multiplicity_of_δ {s : Finset E} (hs : ∀ c ∈ s, «expr‖ ‖» c ≤ 2)\n    (h's : ∀ c ∈ s, ∀ d ∈ s, c ≠ d → 1 - good_δ E ≤ «expr‖ ‖» (c - d)) : s.card ≤ multiplicity E :=\n  (Classical.choose_spec (exists_good_δ E)).2.2 s hs h's\n#align card_le_multiplicity_of_δ card_le_multiplicity_of_δ\n\n",
 "card_le_multiplicity":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem card_le_multiplicity {s : Finset E} (hs : ∀ c ∈ s, «expr‖ ‖» c ≤ 2)\n    (h's : ∀ c ∈ s, ∀ d ∈ s, c ≠ d → 1 ≤ «expr‖ ‖» (c - d)) : s.card ≤ multiplicity E :=\n  by\n  apply le_csupₛ\n  · refine' ⟨5 ^ finrank (exprℝ) E, _⟩\n    rintro _ ⟨s, ⟨rfl, h⟩⟩\n    exact besicovitch.card_le_of_separated s h.1 h.2\n  · simp only [mem_set_of_eq, ne.def]\n    exact ⟨s, rfl, hs, h's⟩\n#align card_le_multiplicity card_le_multiplicity\n\n"}