{"blimsup_thickening_mul_ae_eq_aux":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\n/-- An auxiliary result en route to `blimsup_thickening_mul_ae_eq`. -/\ntheorem blimsup_thickening_mul_ae_eq_aux (p : ℕ → Prop) (s : ℕ → set α) {M : exprℝ} (hM : 0 < M) (r : ℕ → exprℝ)\n    (hr : tendsto r at_top ((nhds) 0))\n    (hr' :\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" at_top\n        (p i → 0 < r i)) :\n    «expr =ᵐ[ ] » (blimsup (fun i => thickening (M * r i) (s i)) at_top p : set α) μ\n      (blimsup (fun i => thickening (r i) (s i)) at_top p : set α) :=\n  by\n  have h₁ := blimsup_cthickening_ae_eq_blimsup_thickening μ hr hr'\n  have h₂ := blimsup_cthickening_mul_ae_eq μ p s hM r hr\n  replace hr : tendsto (fun i => M * r i) at_top ((nhds) 0);\n  · convert hr.const_mul M\n    simp\n  replace hr' :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" at_top\n      (p i → 0 < M * r i) :=\n    hr'.mono fun i hi hip => mul_pos hM (hi hip)\n  have h₃ := blimsup_cthickening_ae_eq_blimsup_thickening μ hr hr'\n  exact h₃.symm.trans (h₂.trans h₁)\n#align blimsup_thickening_mul_ae_eq_aux blimsup_thickening_mul_ae_eq_aux\n\n",
 "blimsup_thickening_mul_ae_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\n/-- Given a sequence of subsets `sᵢ` of a metric space, together with a sequence of radii `rᵢ`\nsuch that `rᵢ → 0`, the set of points which belong to infinitely many of the\n`rᵢ`-thickenings of `sᵢ` is unchanged almost everywhere for a doubling measure if the `rᵢ` are all\nscaled by a positive constant.\n\nThis lemma is a generalisation of Lemma 9 appearing on page 217 of\n[J.W.S. Cassels, *Some metrical theorems in Diophantine approximation. I*](cassels1950).\n\nSee also `blimsup_cthickening_mul_ae_eq`.\n\nNB: The `set : α` type ascription is present because of issue #16932 on GitHub. -/\ntheorem blimsup_thickening_mul_ae_eq (p : ℕ → Prop) (s : ℕ → set α) {M : exprℝ} (hM : 0 < M) (r : ℕ → exprℝ)\n    (hr : tendsto r at_top ((nhds) 0)) :\n    «expr =ᵐ[ ] » (blimsup (fun i => thickening (M * r i) (s i)) at_top p : set α) μ\n      (blimsup (fun i => thickening (r i) (s i)) at_top p : set α) :=\n  by\n  let q : ℕ → Prop := fun i => p i ∧ 0 < r i\n  have h₁ : blimsup (fun i => thickening (r i) (s i)) at_top p = blimsup (fun i => thickening (r i) (s i)) at_top q :=\n    by\n    refine' blimsup_congr' (eventually_of_forall fun i h => _)\n    replace hi : 0 < r i\n    · contrapose! h\n      apply thickening_of_nonpos h\n    simp only [hi, iff_self_and, imp_true_iff]\n  have h₂ :\n    blimsup (fun i => thickening (M * r i) (s i)) at_top p = blimsup (fun i => thickening (M * r i) (s i)) at_top q :=\n    by\n    refine' blimsup_congr' (eventually_of_forall fun i h => _)\n    replace h : 0 < r i\n    · rw [← zero_lt_mul_left hM]\n      contrapose! h\n      apply thickening_of_nonpos h\n    simp only [h, iff_self_and, imp_true_iff]\n  rw [h₁, h₂]\n  exact blimsup_thickening_mul_ae_eq_aux μ q s hM r hr (eventually_of_forall fun i hi => hi.2)\n#align blimsup_thickening_mul_ae_eq blimsup_thickening_mul_ae_eq\n\n",
 "blimsup_cthickening_mul_ae_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.gt -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.gt -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.gt -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\n/-- Given a sequence of subsets `sᵢ` of a metric space, together with a sequence of radii `rᵢ`\nsuch that `rᵢ → 0`, the set of points which belong to infinitely many of the closed\n`rᵢ`-thickenings of `sᵢ` is unchanged almost everywhere for a doubling measure if the `rᵢ` are all\nscaled by a positive constant.\n\nThis lemma is a generalisation of Lemma 9 appearing on page 217 of\n[J.W.S. Cassels, *Some metrical theorems in Diophantine approximation. I*](cassels1950).\n\nSee also `blimsup_thickening_mul_ae_eq`.\n\nNB: The `set : α` type ascription is present because of issue #16932 on GitHub. -/\ntheorem blimsup_cthickening_mul_ae_eq (p : ℕ → Prop) (s : ℕ → set α) {M : exprℝ} (hM : 0 < M) (r : ℕ → exprℝ)\n    (hr : tendsto r at_top ((nhds) 0)) :\n    «expr =ᵐ[ ] » (blimsup (fun i => cthickening (M * r i) (s i)) at_top p : set α) μ\n      (blimsup (fun i => cthickening (r i) (s i)) at_top p : set α) :=\n  by\n  have :\n    ∀ (p : ℕ → Prop) {r : ℕ → exprℝ} (hr : tendsto r at_top (nhds_within.gt 0)),\n      «expr =ᵐ[ ] » (blimsup (fun i => cthickening (M * r i) (s i)) at_top p : set α) μ\n        (blimsup (fun i => cthickening (r i) (s i)) at_top p : set α) :=\n    by\n    clear p hr r\n    intro p r hr\n    have hr' : tendsto (fun i => M * r i) at_top (nhds_within.gt 0) := by\n      convert tendsto_nhds_within_Ioi.const_mul hM hr <;> simp only [mul_zero]\n    refine' eventually_le_antisymm_iff.mpr ⟨_, _⟩\n    ·\n      exact\n        blimsup_cthickening_ae_le_of_eventually_mul_le μ p (inv_pos.mpr hM) hr'\n          (eventually_of_forall fun i => by rw [inv_mul_cancel_left₀ hM.ne' (r i)])\n    · exact blimsup_cthickening_ae_le_of_eventually_mul_le μ p hM hr (eventually_of_forall fun i => le_refl _)\n  let r' : ℕ → exprℝ := fun i => if 0 < r i then r i else 1 / ((i : exprℝ) + 1)\n  have hr' : tendsto r' at_top (nhds_within.gt 0) :=\n    by\n    refine'\n      tendsto_nhds_within_iff.mpr\n        ⟨tendsto.if' hr tendsto_one_div_add_at_top_nhds_0_nat, eventually_of_forall fun i => _⟩\n    by_cases hi : 0 < r i\n    · simp [hi, r']\n    · simp only [hi, r', one_div, mem_Ioi, if_false, inv_pos]\n      positivity\n  have h₀ : ∀ i, p i ∧ 0 < r i → cthickening (r i) (s i) = cthickening (r' i) (s i) :=\n    by\n    rintro i ⟨-, hi⟩\n    congr\n    change r i = ite (0 < r i) (r i) _\n    simp [hi]\n  have h₁ : ∀ i, p i ∧ 0 < r i → cthickening (M * r i) (s i) = cthickening (M * r' i) (s i) :=\n    by\n    rintro i ⟨-, hi⟩\n    simp only [hi, mul_ite, if_true]\n  have h₂ : ∀ i, p i ∧ r i ≤ 0 → cthickening (M * r i) (s i) = cthickening (r i) (s i) :=\n    by\n    rintro i ⟨-, hi⟩\n    have hi' : M * r i ≤ 0 := mul_nonpos_of_nonneg_of_nonpos hM.le hi\n    rw [cthickening_of_nonpos hi, cthickening_of_nonpos hi']\n  have hp : p = fun i => p i ∧ 0 < r i ∨ p i ∧ r i ≤ 0 := by\n    ext i\n    simp [← and_or_left, lt_or_le 0 (r i)]\n  rw [hp, blimsup_or_eq_sup, blimsup_or_eq_sup, sup_eq_union, blimsup_congr (eventually_of_forall h₀),\n    blimsup_congr (eventually_of_forall h₁), blimsup_congr (eventually_of_forall h₂)]\n  exact ae_eq_set_union (this (fun i => p i ∧ 0 < r i) hr') (ae_eq_refl _)\n#align blimsup_cthickening_mul_ae_eq blimsup_cthickening_mul_ae_eq\n\n",
 "blimsup_cthickening_ae_le_of_eventually_mul_le_aux":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.gt -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.gt -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.gt -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≤ᵐ[ ] » -/\n/-\nCopyright (c) 2022 Oliver Nash. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Oliver Nash\n-/\n/-- This is really an auxiliary result en route to `blimsup_cthickening_ae_le_of_eventually_mul_le`\n(which is itself an auxiliary result en route to `blimsup_cthickening_mul_ae_eq`).\n\nNB: The `set : α` type ascription is present because of issue #16932 on GitHub. -/\ntheorem blimsup_cthickening_ae_le_of_eventually_mul_le_aux (p : ℕ → Prop) {s : ℕ → set α} (hs : ∀ i, is_closed (s i))\n    {r₁ r₂ : ℕ → exprℝ} (hr : tendsto r₁ at_top (nhds_within.gt 0)) (hrp : 0 ≤ r₁) {M : exprℝ} (hM : 0 < M)\n    (hM' : M < 1)\n    (hMr :\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" at_top\n        (M * r₁ i ≤ r₂ i)) :\n    «expr ≤ᵐ[ ] » (blimsup (fun i => cthickening (r₁ i) (s i)) at_top p : set α) μ\n      (blimsup (fun i => cthickening (r₂ i) (s i)) at_top p : set α) :=\n  by\n  /- Sketch of proof:\n  \n    Assume that `p` is identically true for simplicity. Let `Y₁ i = cthickening (r₁ i) (s i)`, define\n    `Y₂` similarly except using `r₂`, and let `(Z i) = ⋃_{j ≥ i} (Y₂ j)`. Our goal is equivalent to\n    showing that `μ ((limsup Y₁) \\ (Z i)) = 0` for all `i`.\n  \n    Assume for contradiction that `μ ((limsup Y₁) \\ (Z i)) ≠ 0` for some `i` and let\n    `W = (limsup Y₁) \\ (Z i)`. Apply Lebesgue's density theorem to obtain a point `d` in `W` of\n    density `1`. Since `d ∈ limsup Y₁`, there is a subsequence of `j ↦ Y₁ j`, indexed by\n    `f 0 < f 1 < ...`, such that `d ∈ Y₁ (f j)` for all `j`. For each `j`, we may thus choose\n    `w j ∈ s (f j)` such that `d ∈ B j`, where `B j = closed_ball (w j) (r₁ (f j))`. Note that\n    since `d` has density one, `μ (W ∩ (B j)) / μ (B j) → 1`.\n  \n    We obtain our contradiction by showing that there exists `η < 1` such that\n    `μ (W ∩ (B j)) / μ (B j) ≤ η` for sufficiently large `j`. In fact we claim that `η = 1 - C⁻¹`\n    is such a value where `C` is the scaling constant of `M⁻¹` for the doubling measure `μ`.\n  \n    To prove the claim, let `b j = closed_ball (w j) (M * r₁ (f j))` and for given `j` consider the\n    sets `b j` and `W ∩ (B j)`. These are both subsets of `B j` and are disjoint for large enough `j`\n    since `M * r₁ j ≤ r₂ j` and thus `b j ⊆ Z i ⊆ Wᶜ`. We thus have:\n    `μ (b j) + μ (W ∩ (B j)) ≤ μ (B j)`. Combining this with `μ (B j) ≤ C * μ (b j)` we obtain\n    the required inequality. -/\n  set Y₁ : ℕ → set α := fun i => cthickening (r₁ i) (s i)\n  set Y₂ : ℕ → set α := fun i => cthickening (r₂ i) (s i)\n  let Z : ℕ → set α := fun i =>\n    «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (Y₂ j)\n  suffices ∀ i, μ (at_top.blimsup Y₁ p \\ Z i) = 0 by\n    rwa [ae_le_set, @blimsup_eq_infi_bsupr_of_nat _ _ _ Y₂, infi_eq_Inter, diff_Inter, measure_Union_null_iff]\n  intros\n  set W := at_top.blimsup Y₁ p \\ Z i\n  by_contra contra\n  obtain ⟨d, hd, hd'⟩ :\n    ∃ d,\n      d ∈ W ∧\n        ∀ {ι : Type _} {l : filter ι} (w : ι → α) (δ : ι → exprℝ),\n          tendsto δ l (nhds_within.gt 0) →\n            «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" l\n                (d ∈ closed_ball (w j) (2 * δ j)) →\n              tendsto (fun j => μ (W ∩ closed_ball (w j) (δ j)) / μ (closed_ball (w j) (δ j))) l ((nhds) 1) :=\n    measure.exists_mem_of_measure_ne_zero_of_ae contra (is_doubling_measure.ae_tendsto_measure_inter_div μ W 2)\n  replace hd : d ∈ blimsup Y₁ at_top p := ((mem_diff _).mp hd).1\n  obtain ⟨f : ℕ → ℕ, hf⟩ := exists_forall_mem_of_has_basis_mem_blimsup' at_top_basis hd\n  simp only [forall_and] at hf\n  obtain ⟨hf₀ : ∀ j, d ∈ cthickening (r₁ (f j)) (s (f j)), hf₁, hf₂ : ∀ j, j ≤ f j⟩ := hf\n  have hf₃ : tendsto f at_top at_top :=\n    tendsto_at_top_at_top.mpr fun j => ⟨f j, fun i hi => (hf₂ j).trans (hi.trans <| hf₂ i)⟩\n  replace hr : tendsto (r₁ ∘ f) at_top (nhds_within.gt 0) := hr.comp hf₃\n  replace hMr :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" at_top\n      (M * r₁ (f j) ≤ r₂ (f j)) :=\n    hf₃.eventually hMr\n  replace hf₀ : ∀ j, ∃ w ∈ s (f j), d ∈ closed_ball w (2 * r₁ (f j))\n  · intro j\n    specialize hrp (f j)\n    rw [pi.zero_apply] at hrp\n    rcases eq_or_lt_of_le hrp with (hr0 | hrp')\n    · specialize hf₀ j\n      rw [← hr0, cthickening_zero, (hs (f j)).closure_eq] at hf₀\n      exact ⟨d, hf₀, by simp [← hr0]⟩\n    ·\n      exact\n        mem_Union₂.mp\n          (cthickening_subset_Union_closed_ball_of_lt (s (f j)) (by positivity) (lt_two_mul_self hrp') (hf₀ j))\n  choose w hw hw' using hf₀\n  let C := is_doubling_measure.scaling_constant_of μ M⁻¹\n  have hC : 0 < C := lt_of_lt_of_le zero_lt_one (is_doubling_measure.one_le_scaling_constant_of μ M⁻¹)\n  suffices\n    ∃ η < (1 : nnreal),\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" at_top\n        (μ (W ∩ closed_ball (w j) (r₁ (f j))) / μ (closed_ball (w j) (r₁ (f j))) ≤ η)\n    by\n    obtain ⟨η, hη, hη'⟩ := this\n    replace hη' : 1 ≤ η := by\n      simpa only [ennreal.one_le_coe_iff] using\n        le_of_tendsto (hd' w (fun j => r₁ (f j)) hr <| eventually_of_forall hw') hη'\n    exact (lt_self_iff_false _).mp (lt_of_lt_of_le hη hη')\n  refine' ⟨1 - C⁻¹, tsub_lt_self zero_lt_one (nnreal.inv_pos.mpr hC), _⟩\n  replace hC : C ≠ 0 := ne_of_gt hC\n  let b : ℕ → set α := fun j => closed_ball (w j) (M * r₁ (f j))\n  let B : ℕ → set α := fun j => closed_ball (w j) (r₁ (f j))\n  have h₁ : ∀ j, b j ⊆ B j := fun j => closed_ball_subset_closed_ball (mul_le_of_le_one_left (hrp (f j)) hM'.le)\n  have h₂ : ∀ j, W ∩ B j ⊆ B j := fun j => inter_subset_right W (B j)\n  have h₃ :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" at_top\n      (Disjoint (b j) (W ∩ B j)) :=\n    by\n    apply hMr.mp\n    rw [eventually_at_top]\n    refine' ⟨i, fun j hj hj' => Disjoint.inf_right (B j) <| Disjoint.inf_right' (blimsup Y₁ at_top p) _⟩\n    change Disjoint (b j) («expr ᶜ» (Z i))\n    rw [disjoint_compl_right_iff_subset]\n    refine' (closed_ball_subset_cthickening (hw j) (M * r₁ (f j))).trans ((cthickening_mono hj' _).trans fun a ha => _)\n    simp only [mem_Union, exists_prop]\n    exact ⟨f j, ⟨hf₁ j, hj.le.trans (hf₂ j)⟩, ha⟩\n  have h₄ :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" at_top\n      (μ (B j) ≤ C * μ (b j)) :=\n    (hr.eventually (is_doubling_measure.eventually_measure_le_scaling_constant_mul' μ M hM)).mono fun j hj => hj (w j)\n  refine' (h₃.and h₄).mono fun j hj₀ => _\n  change μ (W ∩ B j) / μ (B j) ≤ ↑(1 - C⁻¹)\n  rcases eq_or_ne (μ (B j)) (ennreal.top) with (hB | hB)\n  · simp [hB]\n  apply ennreal.div_le_of_le_mul\n  rw [WithTop.coe_sub, ennreal.coe_one, ennreal.sub_mul fun _ _ => hB, one_mul]\n  replace hB : ↑C⁻¹ * μ (B j) ≠ ennreal.top\n  · refine' ennreal.mul_ne_top _ hB\n    rwa [ennreal.coe_inv hC, ne.def, ennreal.inv_eq_top, ennreal.coe_eq_zero]\n  obtain ⟨hj₁ : Disjoint (b j) (W ∩ B j), hj₂ : μ (B j) ≤ C * μ (b j)⟩ := hj₀\n  replace hj₂ : ↑C⁻¹ * μ (B j) ≤ μ (b j)\n  · rw [ennreal.coe_inv hC, ← ennreal.div_eq_inv_mul]\n    exact ennreal.div_le_of_le_mul' hj₂\n  have hj₃ : ↑C⁻¹ * μ (B j) + μ (W ∩ B j) ≤ μ (B j) :=\n    by\n    refine' le_trans (add_le_add_right hj₂ _) _\n    rw [← measure_union' hj₁ measurable_set_closed_ball]\n    exact measure_mono (union_subset (h₁ j) (h₂ j))\n  replace hj₃ := tsub_le_tsub_right hj₃ (↑C⁻¹ * μ (B j))\n  rwa [ennreal.add_sub_cancel_left hB] at hj₃\n#align blimsup_cthickening_ae_le_of_eventually_mul_le_aux blimsup_cthickening_ae_le_of_eventually_mul_le_aux\n\n",
 "blimsup_cthickening_ae_le_of_eventually_mul_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.gt -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≤ᵐ[ ] » -/\n/-- This is really an auxiliary result en route to `blimsup_cthickening_mul_ae_eq`.\n\nNB: The `set : α` type ascription is present because of issue #16932 on GitHub. -/\ntheorem blimsup_cthickening_ae_le_of_eventually_mul_le (p : ℕ → Prop) {s : ℕ → set α} {M : exprℝ} (hM : 0 < M)\n    {r₁ r₂ : ℕ → exprℝ} (hr : tendsto r₁ at_top (nhds_within.gt 0))\n    (hMr :\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" at_top\n        (M * r₁ i ≤ r₂ i)) :\n    «expr ≤ᵐ[ ] » (blimsup (fun i => cthickening (r₁ i) (s i)) at_top p : set α) μ\n      (blimsup (fun i => cthickening (r₂ i) (s i)) at_top p : set α) :=\n  by\n  let R₁ i := max 0 (r₁ i)\n  let R₂ i := max 0 (r₂ i)\n  have hRp : 0 ≤ R₁ := fun i => le_max_left 0 (r₁ i)\n  replace hMr :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" at_top\n      (M * R₁ i ≤ R₂ i)\n  · refine' hMr.mono fun i hi => _\n    rw [mul_max_of_nonneg _ _ hM.le, mul_zero]\n    exact max_le_max (le_refl 0) hi\n  simp_rw [← cthickening_max_zero (r₁ _), ← cthickening_max_zero (r₂ _)]\n  cases' le_or_lt 1 M with hM' hM'\n  · apply has_subset.subset.eventually_le\n    change _ ≤ _\n    refine' mono_blimsup' (hMr.mono fun i hi hp => cthickening_mono _ (s i))\n    exact (le_mul_of_one_le_left (hRp i) hM').trans hi\n  · simp only [← @cthickening_closure _ _ _ (s _)]\n    have hs : ∀ i, is_closed (closure (s i)) := fun i => is_closed_closure\n    exact blimsup_cthickening_ae_le_of_eventually_mul_le_aux μ p hs (tendsto_nhds_max_right hr) hRp hM hM' hMr\n#align blimsup_cthickening_ae_le_of_eventually_mul_le blimsup_cthickening_ae_le_of_eventually_mul_le\n\n",
 "blimsup_cthickening_ae_eq_blimsup_thickening":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\ntheorem blimsup_cthickening_ae_eq_blimsup_thickening {p : ℕ → Prop} {s : ℕ → set α} {r : ℕ → exprℝ}\n    (hr : tendsto r at_top ((nhds) 0))\n    (hr' :\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" at_top\n        (p i → 0 < r i)) :\n    «expr =ᵐ[ ] » (blimsup (fun i => cthickening (r i) (s i)) at_top p : set α) μ\n      (blimsup (fun i => thickening (r i) (s i)) at_top p : set α) :=\n  by\n  refine' eventually_le_antisymm_iff.mpr ⟨_, has_subset.subset.eventually_le (_ : _ ≤ _)⟩\n  · rw [eventually_le_congr (blimsup_cthickening_mul_ae_eq μ p s (@one_half_pos (exprℝ) _) r hr).symm eventually_eq.rfl]\n    apply has_subset.subset.eventually_le\n    change _ ≤ _\n    refine' mono_blimsup' (hr'.mono fun i hi pi => cthickening_subset_thickening' (hi pi) _ (s i))\n    nlinarith [hi pi]\n  · exact mono_blimsup fun i pi => thickening_subset_cthickening _ _\n#align blimsup_cthickening_ae_eq_blimsup_thickening blimsup_cthickening_ae_eq_blimsup_thickening\n\n"}