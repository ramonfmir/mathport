{"subset_piUnionᵢInter":
 "#print subset_piUnionᵢInter /-\ntheorem subset_piUnionᵢInter {π : ι → Set (Set α)} {S : Set ι} {i : ι} (his : i ∈ S) : π i ⊆ piUnionᵢInter π S :=\n  by\n  have h_ss : {i} ⊆ S := by\n    intro j hj\n    rw [mem_singleton_iff] at hj\n    rwa [hj]\n  refine' subset.trans _ (piUnionᵢInter_mono_right h_ss)\n  rw [piUnionᵢInter_singleton]\n  exact subset_union_left _ _\n#align subset_pi_Union_Inter subset_piUnionᵢInter\n-/\n\n",
 "subset_generatePiSystem_self":
 "#print subset_generatePiSystem_self /-\ntheorem subset_generatePiSystem_self {α} (S : Set (Set α)) : S ⊆ generatePiSystem S := fun s => generate_pi_system.base\n#align subset_generate_pi_system_self subset_generatePiSystem_self\n-/\n\n",
 "singleton":
 "#print IsPiSystem.singleton /-\ntheorem IsPiSystem.singleton {α} (S : Set α) : IsPiSystem ({S} : Set (Set α)) :=\n  by\n  intro s h_s t h_t h_ne\n  rw [Set.mem_singleton_iff.1 h_s, Set.mem_singleton_iff.1 h_t, Set.inter_self, Set.mem_singleton_iff]\n#align is_pi_system.singleton IsPiSystem.singleton\n-/\n\n",
 "piUnionᵢInter_singleton_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n#print piUnionᵢInter_singleton_left /-\ntheorem piUnionᵢInter_singleton_left (s : ι → Set α) (S : Set ι) :\n    piUnionᵢInter (fun i => ({s i} : Set (Set α))) S =\n      { s' : Set α |\n        ∃ (t : Finset ι)(htS : ↑t ⊆ S),\n          s' =\n            «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (s i) } :=\n  by\n  ext1 s'\n  simp_rw [piUnionᵢInter, Set.mem_singleton_iff, exists_prop, Set.mem_setOf_eq]\n  refine' ⟨fun h => _, fun ⟨t, htS, h_eq⟩ => ⟨t, htS, s, fun _ _ => rfl, h_eq⟩⟩\n  obtain ⟨t, htS, f, hft_eq, rfl⟩ := h\n  refine' ⟨t, htS, _⟩\n  congr with (i x)\n  simp_rw [Set.mem_interᵢ]\n  exact\n    ⟨fun h hit => by\n      rw [← hft_eq i hit]\n      exact h hit, fun h hit => by\n      rw [hft_eq i hit]\n      exact h hit⟩\n#align pi_Union_Inter_singleton_left piUnionᵢInter_singleton_left\n-/\n\n",
 "piUnionᵢInter_singleton":
 "#print piUnionᵢInter_singleton /-\ntheorem piUnionᵢInter_singleton (π : ι → Set (Set α)) (i : ι) : piUnionᵢInter π {i} = π i ∪ {univ} :=\n  by\n  ext1 s\n  simp only [piUnionᵢInter, exists_prop, mem_union]\n  refine' ⟨_, fun h => _⟩\n  · rintro ⟨t, hti, f, hfπ, rfl⟩\n    simp only [subset_singleton_iff, Finset.mem_coe] at hti\n    by_cases hi : i ∈ t\n    · have ht_eq_i : t = {i} := by\n        ext1 x\n        rw [Finset.mem_singleton]\n        exact ⟨fun h => hti x h, fun h => h.symm ▸ hi⟩\n      simp only [ht_eq_i, Finset.mem_singleton, Inter_Inter_eq_left]\n      exact or.inl (hfπ i hi)\n    · have ht_empty : t = ∅ := by\n        ext1 x\n        simp only [Finset.not_mem_empty, iff_false_iff]\n        exact fun hx => hi (hti x hx ▸ hx)\n      simp only [ht_empty, Inter_false, Inter_univ, Set.mem_singleton univ, or_true_iff]\n  · cases' h with hs hs\n    · refine' ⟨{i}, _, fun _ => s, ⟨fun x hx => _, _⟩⟩\n      · rw [Finset.coe_singleton]\n      · rw [Finset.mem_singleton] at hx\n        rwa [hx]\n      · simp only [Finset.mem_singleton, Inter_Inter_eq_left]\n    · refine' ⟨∅, _⟩\n      simpa only [Finset.coe_empty, subset_singleton_iff, mem_empty_iff_false, IsEmpty.forall_iff, imp_true_iff,\n        Finset.not_mem_empty, Inter_false, Inter_univ, true_and_iff, exists_const] using hs\n#align pi_Union_Inter_singleton piUnionᵢInter_singleton\n-/\n\n",
 "piUnionᵢInter_mono_right":
 "#print piUnionᵢInter_mono_right /-\ntheorem piUnionᵢInter_mono_right {π : ι → Set (Set α)} {S T : Set ι} (hST : S ⊆ T) :\n    piUnionᵢInter π S ⊆ piUnionᵢInter π T := fun s ⟨t, ht_mem, ft, hft_mem_pi, h_eq⟩ =>\n  ⟨t, ht_mem.trans hST, ft, hft_mem_pi, h_eq⟩\n#align pi_Union_Inter_mono_right piUnionᵢInter_mono_right\n-/\n\n",
 "piUnionᵢInter_mono_left":
 "#print piUnionᵢInter_mono_left /-\ntheorem piUnionᵢInter_mono_left {π π' : ι → Set (Set α)} (h_le : ∀ i, π i ⊆ π' i) (S : Set ι) :\n    piUnionᵢInter π S ⊆ piUnionᵢInter π' S := fun s ⟨t, ht_mem, ft, hft_mem_pi, h_eq⟩ =>\n  ⟨t, ht_mem, ft, fun x hxt => h_le x (hft_mem_pi x hxt), h_eq⟩\n#align pi_Union_Inter_mono_left piUnionᵢInter_mono_left\n-/\n\n",
 "of_measurable_space_to_measurable_space":
 "theorem of_measurable_space_to_measurable_space (h_inter : ∀ s₁ s₂, d.has s₁ → d.has s₂ → d.has (s₁ ∩ s₂)) :\n    ofMeasurableSpace (d.to_measurable_space h_inter) = d :=\n  ext fun s => iff.rfl\n#align of_measurable_space_to_measurable_space of_measurable_space_to_measurable_space\n\n",
 "of_measurable_space_le_of_measurable_space_iff":
 "theorem of_measurable_space_le_of_measurable_space_iff {m₁ m₂ : MeasurableSpace α} :\n    ofMeasurableSpace m₁ ≤ ofMeasurableSpace m₂ ↔ m₁ ≤ m₂ :=\n  iff.rfl\n#align of_measurable_space_le_of_measurable_space_iff of_measurable_space_le_of_measurable_space_iff\n\n",
 "mem_piUnionᵢInter_of_measurableSet":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\n#print mem_piUnionᵢInter_of_measurableSet /-\ntheorem mem_piUnionᵢInter_of_measurableSet (m : ι → MeasurableSpace α) {S : Set ι} {i : ι} (hiS : i ∈ S) (s : Set α)\n    (hs : (measurable_set_of (m i)) s) : s ∈ piUnionᵢInter (fun n => { s | (measurable_set_of (m n)) s }) S :=\n  subset_piUnionᵢInter hiS hs\n#align mem_pi_Union_Inter_of_measurable_set mem_piUnionᵢInter_of_measurableSet\n-/\n\n",
 "mem_generatePiSystem_unionᵢ_elim'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n#print mem_generatePiSystem_unionᵢ_elim' /-\n/- Every element of the π-system generated by an indexed union of a family of π-systems\nis a finite intersection of elements from the π-systems.\nFor a total union version, see `mem_generate_pi_system_Union_elim`. -/\ntheorem mem_generatePiSystem_unionᵢ_elim' {α β} {g : β → Set (Set α)} {s : Set β} (h_pi : ∀ b ∈ s, IsPiSystem (g b))\n    (t : Set α)\n    (h_t :\n      t ∈\n        generatePiSystem\n          («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (g b))) :\n    ∃ (T : Finset β)(f : β → Set α),\n      ↑T ⊆ s ∧\n        t = «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (f b) ∧\n          ∀ b ∈ T, f b ∈ g b :=\n  by\n  have :\n    t ∈\n      generatePiSystem\n        («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n          ((g ∘ Subtype.val) b)) :=\n    by\n    suffices h1 :\n      «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n          ((g ∘ Subtype.val) b) =\n        «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (g b)\n    · rwa [h1]\n    ext x\n    simp only [exists_prop, Set.mem_unionᵢ, Function.comp_apply, Subtype.exists, Subtype.coe_mk]\n    rfl\n  rcases@mem_generatePiSystem_unionᵢ_elim α (Subtype s) (g ∘ Subtype.val) (fun b => h_pi b.val b.property) t this with\n    ⟨T, ⟨f, ⟨rfl, h_t'⟩⟩⟩\n  refine' ⟨T.image Subtype.val, Function.extend Subtype.val f fun b : β => (∅ : Set α), by simp, _, _⟩\n  · ext a\n    constructor <;>\n      · simp only [Set.mem_interᵢ, Subtype.forall, Finset.set_binterᵢ_finset_image]\n        intro h1 b h_b h_b_in_T\n        have h2 := h1 b h_b h_b_in_T\n        revert h2\n        rw [subtype.val_injective.extend_apply]\n        apply id\n  · intro b h_b\n    simp_rw [Finset.mem_image, exists_prop, Subtype.exists, exists_and_right, exists_eq_right] at h_b\n    cases h_b\n    have h_b_alt : b = (subtype.mk b h_b_w).val := rfl\n    rw [h_b_alt, subtype.val_injective.extend_apply]\n    apply h_t'\n    apply h_b_h\n#align mem_generate_pi_system_Union_elim' mem_generatePiSystem_unionᵢ_elim'\n-/\n\n",
 "mem_generatePiSystem_unionᵢ_elim":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n#print mem_generatePiSystem_unionᵢ_elim /-\n/- Every element of the π-system generated by the union of a family of π-systems\nis a finite intersection of elements from the π-systems.\nFor an indexed union version, see `mem_generate_pi_system_Union_elim'`. -/\ntheorem mem_generatePiSystem_unionᵢ_elim {α β} {g : β → Set (Set α)} (h_pi : ∀ b, IsPiSystem (g b)) (t : Set α)\n    (h_t :\n      t ∈\n        generatePiSystem\n          («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (g b))) :\n    ∃ (T : Finset β)(f : β → Set α),\n      t = «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (f b) ∧\n        ∀ b ∈ T, f b ∈ g b :=\n  by\n  induction' h_t with s h_s s t' h_gen_s h_gen_t' h_nonempty h_s h_t'\n  · rcases h_s with ⟨t', ⟨⟨b, rfl⟩, h_s_in_t'⟩⟩\n    refine' ⟨{b}, fun _ => s, _⟩\n    simpa using h_s_in_t'\n  · rcases h_t' with ⟨T_t', ⟨f_t', ⟨rfl, h_t'⟩⟩⟩\n    rcases h_s with ⟨T_s, ⟨f_s, ⟨rfl, h_s⟩⟩⟩\n    use T_s ∪ T_t', fun b : β =>\n      if b ∈ T_s then if b ∈ T_t' then f_s b ∩ f_t' b else f_s b else if b ∈ T_t' then f_t' b else (∅ : Set α)\n    constructor\n    · ext a\n      simp_rw [Set.mem_inter_iff, Set.mem_interᵢ, Finset.mem_union, or_imp]\n      rw [← forall_and]\n      constructor <;> intro h1 b <;> by_cases hbs : b ∈ T_s <;> by_cases hbt : b ∈ T_t' <;> specialize h1 b <;>\n        simp only [hbs, hbt, if_true, if_false, true_imp_iff, and_self_iff, false_imp_iff, and_true_iff,\n          true_and_iff] at h1⊢\n      all_goals exact h1\n    intro b h_b\n    split_ifs with hbs hbt hbt\n    · refine' h_pi b (f_s b) (h_s b hbs) (f_t' b) (h_t' b hbt) (Set.Nonempty.mono _ h_nonempty)\n      exact Set.inter_subset_inter (Set.binterᵢ_subset_of_mem hbs) (Set.binterᵢ_subset_of_mem hbt)\n    · exact h_s b hbs\n    · exact h_t' b hbt\n    · rw [Finset.mem_union] at h_b\n      apply false.elim (h_b.elim hbs hbt)\n#align mem_generate_pi_system_Union_elim mem_generatePiSystem_unionᵢ_elim\n-/\n\n",
 "measurableSet_supᵢ_of_mem_piUnionᵢInter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n#print measurableSet_supᵢ_of_mem_piUnionᵢInter /-\ntheorem measurableSet_supᵢ_of_mem_piUnionᵢInter (m : ι → MeasurableSpace α) (S : Set ι) (t : Set α)\n    (ht : t ∈ piUnionᵢInter (fun n => { s | (measurable_set_of (m n)) s }) S) :\n    (measurable_set_of\n        («expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (m i)))\n      t :=\n  by\n  rcases ht with ⟨pt, hpt, ft, ht_m, rfl⟩\n  refine' pt.measurable_set_bInter fun i hi => _\n  suffices h_le :\n    m i ≤ «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (m i);\n  exact h_le (ft i) (ht_m i hi)\n  have hi' : i ∈ S := hpt hi\n  exact le_supᵢ₂ i hi'\n#align measurable_set_supr_of_mem_pi_Union_Inter measurableSet_supᵢ_of_mem_piUnionᵢInter\n-/\n\n",
 "le_generateFrom_piUnionᵢInter":
 "#print le_generateFrom_piUnionᵢInter /-\ntheorem le_generateFrom_piUnionᵢInter {π : ι → Set (Set α)} (S : Set ι) {x : ι} (hxS : x ∈ S) :\n    generateFrom (π x) ≤ generateFrom (piUnionᵢInter π S) :=\n  generateFrom_mono (subset_piUnionᵢInter hxS)\n#align le_generate_from_pi_Union_Inter le_generateFrom_piUnionᵢInter\n-/\n\n",
 "le_def":
 "theorem le_def {α} {a b : DynkinSystem α} : a ≤ b ↔ a.has ≤ b.has :=\n  iff.rfl\n#align le_def le_def\n\n",
 "is_pi_system_measurable_set":
 "/-\nCopyright (c) 2021 Martin Zinkevich. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johannes Hölzl, Martin Zinkevich, Rémy Degenne\n-/\ntheorem is_pi_system_measurable_set {α : Type _} [MeasurableSpace α] : IsPiSystem { s : Set α | MeasurableSet s } :=\n  fun s hs t ht _ => hs.inter ht\n#align is_pi_system_measurable_set is_pi_system_measurable_set\n\n",
 "isPiSystem_unionᵢ_of_monotone":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n#print isPiSystem_unionᵢ_of_monotone /-\ntheorem isPiSystem_unionᵢ_of_monotone {α ι} [SemilatticeSup ι] (p : ι → Set (Set α)) (hp_pi : ∀ n, IsPiSystem (p n))\n    (hp_mono : Monotone p) :\n    IsPiSystem\n      («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (p n)) :=\n  isPiSystem_unionᵢ_of_directed_le p hp_pi (Monotone.directed_le hp_mono)\n#align is_pi_system_Union_of_monotone isPiSystem_unionᵢ_of_monotone\n-/\n\n",
 "isPiSystem_unionᵢ_of_directed_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n#print isPiSystem_unionᵢ_of_directed_le /-\ntheorem isPiSystem_unionᵢ_of_directed_le {α ι} (p : ι → Set (Set α)) (hp_pi : ∀ n, IsPiSystem (p n))\n    (hp_directed : Directed (· ≤ ·) p) :\n    IsPiSystem\n      («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (p n)) :=\n  by\n  intro t1 ht1 t2 ht2 h\n  rw [Set.mem_unionᵢ] at ht1 ht2⊢\n  cases' ht1 with n ht1\n  cases' ht2 with m ht2\n  obtain ⟨k, hpnk, hpmk⟩ : ∃ k, p n ≤ p k ∧ p m ≤ p k := hp_directed n m\n  exact ⟨k, hp_pi k t1 (hpnk ht1) t2 (hpmk ht2) h⟩\n#align is_pi_system_Union_of_directed_le isPiSystem_unionᵢ_of_directed_le\n-/\n\n",
 "isPiSystem_piUnionᵢInter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n#print isPiSystem_piUnionᵢInter /-\n/-- If `π` is a family of π-systems, then `pi_Union_Inter π S` is a π-system. -/\ntheorem isPiSystem_piUnionᵢInter (π : ι → Set (Set α)) (hpi : ∀ x, IsPiSystem (π x)) (S : Set ι) :\n    IsPiSystem (piUnionᵢInter π S) :=\n  by\n  rintro t1 ⟨p1, hp1S, f1, hf1m, ht1_eq⟩ t2 ⟨p2, hp2S, f2, hf2m, ht2_eq⟩ h_nonempty\n  simp_rw [piUnionᵢInter, Set.mem_setOf_eq]\n  let g n := ite (n ∈ p1) (f1 n) Set.univ ∩ ite (n ∈ p2) (f2 n) Set.univ\n  have hp_union_ss : ↑(p1 ∪ p2) ⊆ S := by simp only [hp1S, hp2S, Finset.coe_union, union_subset_iff, and_self_iff]\n  use p1 ∪ p2, hp_union_ss, g\n  have h_inter_eq :\n    t1 ∩ t2 = «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (g i) :=\n    by\n    rw [ht1_eq, ht2_eq]\n    simp_rw [← Set.inf_eq_inter, g]\n    ext1 x\n    simp only [inf_eq_inter, mem_inter_iff, mem_Inter, Finset.mem_union]\n    refine' ⟨fun h i hi_mem_union => _, fun h => ⟨fun i hi1 => _, fun i hi2 => _⟩⟩\n    · split_ifs\n      exacts[⟨h.1 i h_1, h.2 i h_2⟩, ⟨h.1 i h_1, Set.mem_univ _⟩, ⟨Set.mem_univ _, h.2 i h_2⟩,\n        ⟨Set.mem_univ _, Set.mem_univ _⟩]\n    · specialize h i (or.inl hi1)\n      rw [if_pos hi1] at h\n      exact h.1\n    · specialize h i (or.inr hi2)\n      rw [if_pos hi2] at h\n      exact h.2\n  refine' ⟨fun n hn => _, h_inter_eq⟩\n  simp_rw [g]\n  split_ifs with hn1 hn2\n  · refine' hpi n (f1 n) (hf1m n hn1) (f2 n) (hf2m n hn2) (Set.nonempty_iff_ne_empty.2 fun h => _)\n    rw [h_inter_eq] at h_nonempty\n    suffices h_empty :\n      «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (g i) = ∅\n    exact (set.not_nonempty_iff_eq_empty.mpr h_empty) h_nonempty\n    refine' le_antisymm (Set.interᵢ_subset_of_subset n _) (Set.empty_subset _)\n    refine' Set.interᵢ_subset_of_subset hn _\n    simp_rw [g, if_pos hn1, if_pos hn2]\n    exact h.subset\n  · simp [hf1m n hn1]\n  · simp [hf2m n h]\n  · exact absurd hn (by simp [hn1, h])\n#align is_pi_system_pi_Union_Inter isPiSystem_piUnionᵢInter\n-/\n\n",
 "isPiSystem_image_Ioi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n#print isPiSystem_image_Ioi /-\ntheorem isPiSystem_image_Ioi (s : Set α) : IsPiSystem («expr '' » Ioi s) :=\n  @isPiSystem_image_Iio («expr ᵒᵈ» α) _ s\n#align is_pi_system_image_Ioi isPiSystem_image_Ioi\n-/\n\n",
 "isPiSystem_image_Iio":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n#print isPiSystem_image_Iio /-\ntheorem isPiSystem_image_Iio (s : Set α) : IsPiSystem («expr '' » Iio s) :=\n  by\n  rintro _ ⟨a, ha, rfl⟩ _ ⟨b, hb, rfl⟩ -\n  exact ⟨«expr ⊓ » a b, inf_ind a b ha hb, Iio_inter_Iio.symm⟩\n#align is_pi_system_image_Iio isPiSystem_image_Iio\n-/\n\n",
 "isPiSystem_generatePiSystem":
 "#print isPiSystem_generatePiSystem /-\ntheorem isPiSystem_generatePiSystem {α} (S : Set (Set α)) : IsPiSystem (generatePiSystem S) :=\n  fun s h_s t h_t h_nonempty => generate_pi_system.inter h_s h_t h_nonempty\n#align is_pi_system_generate_pi_system isPiSystem_generatePiSystem\n-/\n\n",
 "isPiSystem_Ixx_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n#print isPiSystem_Ixx_mem /-\ntheorem isPiSystem_Ixx_mem {Ixx : α → α → Set α} {p : α → α → Prop} (Hne : ∀ {a b}, (Ixx a b).nonempty → p a b)\n    (Hi : ∀ {a₁ b₁ a₂ b₂}, Ixx a₁ b₁ ∩ Ixx a₂ b₂ = Ixx (max a₁ a₂) (min b₁ b₂)) (s t : Set α) :\n    IsPiSystem { S | ∃ l ∈ s, ∃ u ∈ t, ∃ hlu : p l u, Ixx l u = S } :=\n  by\n  rintro _ ⟨l₁, hls₁, u₁, hut₁, hlu₁, rfl⟩ _ ⟨l₂, hls₂, u₂, hut₂, hlu₂, rfl⟩\n  simp only [Hi, ← sup_eq_max, ← inf_eq_min]\n  exact fun H => ⟨«expr ⊔ » l₁ l₂, sup_ind l₁ l₂ hls₁ hls₂, «expr ⊓ » u₁ u₂, inf_ind u₁ u₂ hut₁ hut₂, Hne H, rfl⟩\n#align is_pi_system_Ixx_mem isPiSystem_Ixx_mem\n-/\n\n",
 "isPiSystem_Ixx":
 "#print isPiSystem_Ixx /-\ntheorem isPiSystem_Ixx {Ixx : α → α → Set α} {p : α → α → Prop} (Hne : ∀ {a b}, (Ixx a b).nonempty → p a b)\n    (Hi : ∀ {a₁ b₁ a₂ b₂}, Ixx a₁ b₁ ∩ Ixx a₂ b₂ = Ixx (max a₁ a₂) (min b₁ b₂)) (f : ι → α) (g : ι' → α) :\n    @IsPiSystem α { S | ∃ (i j : _)(h : p (f i) (g j)), Ixx (f i) (g j) = S } := by\n  simpa only [exists_range_iff] using isPiSystem_Ixx_mem (@Hne) (@Hi) (range f) (range g)\n#align is_pi_system_Ixx isPiSystem_Ixx\n-/\n\n",
 "isPiSystem_Ioo_mem":
 "#print isPiSystem_Ioo_mem /-\ntheorem isPiSystem_Ioo_mem (s t : Set α) : IsPiSystem { S | ∃ l ∈ s, ∃ u ∈ t, ∃ h : l < u, Ioo l u = S } :=\n  isPiSystem_Ixx_mem (fun a b ⟨x, hax, hxb⟩ => hax.trans hxb) (fun _ _ _ _ => Ioo_inter_Ioo) s t\n#align is_pi_system_Ioo_mem isPiSystem_Ioo_mem\n-/\n\n",
 "isPiSystem_Ioo":
 "#print isPiSystem_Ioo /-\ntheorem isPiSystem_Ioo (f : ι → α) (g : ι' → α) :\n    @IsPiSystem α { S | ∃ (l u : _)(h : f l < g u), Ioo (f l) (g u) = S } :=\n  isPiSystem_Ixx (fun a b ⟨x, hax, hxb⟩ => hax.trans hxb) (fun _ _ _ _ => Ioo_inter_Ioo) f g\n#align is_pi_system_Ioo isPiSystem_Ioo\n-/\n\n",
 "isPiSystem_Ioi":
 "#print isPiSystem_Ioi /-\ntheorem isPiSystem_Ioi : IsPiSystem (range Ioi : Set (Set α)) :=\n  @image_univ α _ Ioi ▸ isPiSystem_image_Ioi univ\n#align is_pi_system_Ioi isPiSystem_Ioi\n-/\n\n",
 "isPiSystem_Ioc_mem":
 "#print isPiSystem_Ioc_mem /-\ntheorem isPiSystem_Ioc_mem (s t : Set α) : IsPiSystem { S | ∃ l ∈ s, ∃ u ∈ t, ∃ h : l < u, Ioc l u = S } :=\n  isPiSystem_Ixx_mem (fun a b ⟨x, hax, hxb⟩ => hax.trans_le hxb) (fun _ _ _ _ => Ioc_inter_Ioc) s t\n#align is_pi_system_Ioc_mem isPiSystem_Ioc_mem\n-/\n\n",
 "isPiSystem_Ioc":
 "#print isPiSystem_Ioc /-\ntheorem isPiSystem_Ioc (f : ι → α) (g : ι' → α) :\n    @IsPiSystem α { S | ∃ (i j : _)(h : f i < g j), Ioc (f i) (g j) = S } :=\n  isPiSystem_Ixx (fun a b ⟨x, hax, hxb⟩ => hax.trans_le hxb) (fun _ _ _ _ => Ioc_inter_Ioc) f g\n#align is_pi_system_Ioc isPiSystem_Ioc\n-/\n\n",
 "isPiSystem_Iio":
 "#print isPiSystem_Iio /-\ntheorem isPiSystem_Iio : IsPiSystem (range Iio : Set (Set α)) :=\n  @image_univ α _ Iio ▸ isPiSystem_image_Iio univ\n#align is_pi_system_Iio isPiSystem_Iio\n-/\n\n",
 "isPiSystem_Ico_mem":
 "#print isPiSystem_Ico_mem /-\ntheorem isPiSystem_Ico_mem (s t : Set α) : IsPiSystem { S | ∃ l ∈ s, ∃ u ∈ t, ∃ h : l < u, Ico l u = S } :=\n  isPiSystem_Ixx_mem (fun a b ⟨x, hax, hxb⟩ => hax.trans_lt hxb) (fun _ _ _ _ => Ico_inter_Ico) s t\n#align is_pi_system_Ico_mem isPiSystem_Ico_mem\n-/\n\n",
 "isPiSystem_Ico":
 "#print isPiSystem_Ico /-\ntheorem isPiSystem_Ico (f : ι → α) (g : ι' → α) :\n    @IsPiSystem α { S | ∃ (i j : _)(h : f i < g j), Ico (f i) (g j) = S } :=\n  isPiSystem_Ixx (fun a b ⟨x, hax, hxb⟩ => hax.trans_lt hxb) (fun _ _ _ _ => Ico_inter_Ico) f g\n#align is_pi_system_Ico isPiSystem_Ico\n-/\n\n",
 "isPiSystem_Icc_mem":
 "#print isPiSystem_Icc_mem /-\ntheorem isPiSystem_Icc_mem (s t : Set α) : IsPiSystem { S | ∃ l ∈ s, ∃ u ∈ t, ∃ h : l ≤ u, Icc l u = S } :=\n  isPiSystem_Ixx_mem (fun a b => nonempty_Icc.1) (fun _ _ _ _ => Icc_inter_Icc) s t\n#align is_pi_system_Icc_mem isPiSystem_Icc_mem\n-/\n\n",
 "isPiSystem_Icc":
 "#print isPiSystem_Icc /-\ntheorem isPiSystem_Icc (f : ι → α) (g : ι' → α) :\n    @IsPiSystem α { S | ∃ (i j : _)(h : f i ≤ g j), Icc (f i) (g j) = S } :=\n  isPiSystem_Ixx (fun a b => nonempty_Icc.1) (fun _ _ _ _ => Icc_inter_Icc) f g\n#align is_pi_system_Icc isPiSystem_Icc\n-/\n\n",
 "insert_univ":
 "#print IsPiSystem.insert_univ /-\ntheorem IsPiSystem.insert_univ {α} {S : Set (Set α)} (h_pi : IsPiSystem S) : IsPiSystem (insert Set.univ S) :=\n  by\n  intro s hs t ht hst\n  cases hs\n  · cases ht <;> simp [hs, ht]\n  · cases ht\n    · simp [hs, ht]\n    · exact Set.mem_insert_of_mem _ (h_pi s hs t ht hst)\n#align is_pi_system.insert_univ IsPiSystem.insert_univ\n-/\n\n",
 "insert_empty":
 "#print IsPiSystem.insert_empty /-\ntheorem IsPiSystem.insert_empty {α} {S : Set (Set α)} (h_pi : IsPiSystem S) : IsPiSystem (insert ∅ S) :=\n  by\n  intro s hs t ht hst\n  cases hs\n  · simp [hs]\n  · cases ht\n    · simp [ht]\n    · exact Set.mem_insert_of_mem _ (h_pi s hs t ht hst)\n#align is_pi_system.insert_empty IsPiSystem.insert_empty\n-/\n\n",
 "induction_on_inter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr on » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\ntheorem induction_on_inter {C : Set α → Prop} {s : Set (Set α)} [m : MeasurableSpace α] (h_eq : m = generateFrom s)\n    (h_inter : IsPiSystem s) (h_empty : C ∅) (h_basic : ∀ t ∈ s, C t)\n    (h_compl : ∀ t, MeasurableSet t → C t → C («expr ᶜ» t))\n    (h_union :\n      ∀ f : ℕ → Set α,\n        Pairwise («expr on » Disjoint f) →\n          (∀ i, MeasurableSet (f i)) →\n            (∀ i, C (f i)) →\n              C\n                («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n                  (f i))) :\n    ∀ ⦃t⦄, MeasurableSet t → C t :=\n  have eq : MeasurableSet = DynkinSystem.GenerateHas s :=\n    by\n    rw [h_eq, dynkin_system.generate_from_eq h_inter]\n    rfl\n  fun t ht =>\n  have : DynkinSystem.GenerateHas s t := by rwa [Eq] at ht\n  this.rec_on h_basic h_empty\n    (fun t ht =>\n      h_compl t <| by\n        rw [Eq]\n        exact ht)\n    fun f hf ht =>\n    h_union f hf fun i => by\n      rw [Eq]\n      exact ht _\n#align induction_on_inter induction_on_inter\n\n",
 "has_univ":
 "theorem has_univ : d.has univ := by simpa using d.has_compl d.has_empty\n#align has_univ has_univ\n\n",
 "has_diff":
 "theorem has_diff {s₁ s₂ : Set α} (h₁ : d.has s₁) (h₂ : d.has s₂) (h : s₂ ⊆ s₁) : d.has (s₁ \\ s₂) :=\n  by\n  apply d.has_compl_iff.1\n  simp [diff_eq, compl_inter]\n  exact d.has_union (d.has_compl h₁) h₂ (disjoint_compl_left.mono_right h)\n#align has_diff has_diff\n\n",
 "has_compl_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\ntheorem has_compl_iff {a} : d.has («expr ᶜ» a) ↔ d.has a :=\n  ⟨fun h => by simpa using d.has_compl h, fun h => d.has_compl h⟩\n#align has_compl_iff has_compl_iff\n\n",
 "has_Union":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr on » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\ntheorem has_Union {β} [Countable β] {f : β → Set α} (hd : Pairwise («expr on » Disjoint f)) (h : ∀ i, d.has (f i)) :\n    d.has («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (f i)) :=\n  by\n  cases nonempty_encodable β\n  rw [← Encodable.unionᵢ_decode₂]\n  exact d.has_Union_nat (Encodable.unionᵢ_decode₂_disjoint_on hd) fun n => Encodable.unionᵢ_decode₂_cases d.has_empty h\n#align has_Union has_Union\n\n",
 "generate_le":
 "theorem generate_le {s : Set (Set α)} (h : ∀ t ∈ s, d.has t) : generate s ≤ d := fun t ht =>\n  ht.rec_on h d.has_empty (fun a _ h => d.has_compl h) fun f hd _ hf => d.has_Union hd hf\n#align generate_le generate_le\n\n",
 "generate_inter":
 "theorem generate_inter {s : Set (Set α)} (hs : IsPiSystem s) {t₁ t₂ : Set α} (ht₁ : (generate s).has t₁)\n    (ht₂ : (generate s).has t₂) : (generate s).has (t₁ ∩ t₂) :=\n  have : generate s ≤ (generate s).restrict_on ht₂ :=\n    generate_le _ fun s₁ hs₁ =>\n      have : (generate s).has s₁ := generate_has.basic s₁ hs₁\n      have : generate s ≤ (generate s).restrict_on this :=\n        generate_le _ fun s₂ hs₂ =>\n          show (generate s).has (s₂ ∩ s₁) from\n            (s₂ ∩ s₁).eq_empty_or_nonempty.elim (fun h => h.symm ▸ generate_has.empty) fun h =>\n              generate_has.basic _ <| hs _ hs₂ _ hs₁ h\n      have : (generate s).has (t₂ ∩ s₁) := this _ ht₂\n      show (generate s).has (s₁ ∩ t₂) by rwa [inter_comm]\n  this _ ht₁\n#align generate_inter generate_inter\n\n",
 "generate_has_subset_generate_measurable":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\ntheorem generate_has_subset_generate_measurable {C : Set (Set α)} {s : Set α} (hs : (generate C).has s) :\n    (measurable_set_of (generateFrom C)) s :=\n  generate_le (ofMeasurableSpace (generateFrom C)) (fun t => measurableSet_generateFrom) s hs\n#align generate_has_subset_generate_measurable generate_has_subset_generate_measurable\n\n",
 "generate_has_def":
 "theorem generate_has_def {C : Set (Set α)} : (generate C).has = GenerateHas C :=\n  rfl\n#align generate_has_def generate_has_def\n\n",
 "generate_has_compl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\ntheorem generate_has_compl {C : Set (Set α)} {s : Set α} : GenerateHas C («expr ᶜ» s) ↔ GenerateHas C s :=\n  by\n  refine' ⟨_, generate_has.compl⟩\n  intro h\n  convert generate_has.compl h\n  simp\n#align generate_has_compl generate_has_compl\n\n",
 "generate_from_eq":
 "/-- **Dynkin's π-λ theorem**:\n  Given a collection of sets closed under binary intersections, then the Dynkin system it\n  generates is equal to the σ-algebra it generates.\n  This result is known as the π-λ theorem.\n  A collection of sets closed under binary intersection is called a π-system (often requiring\n  additionnally that is is non-empty, but we drop this condition in the formalization).\n-/\ntheorem generate_from_eq {s : Set (Set α)} (hs : IsPiSystem s) :\n    generateFrom s = (generate s).to_measurable_space fun t₁ t₂ => generate_inter hs :=\n  le_antisymm (generateFrom_le fun t ht => generate_has.basic t ht)\n    (ofMeasurableSpace_le_ofMeasurableSpace_iff.mp <|\n      by\n      rw [of_measurable_space_to_measurable_space]\n      exact generate_le _ fun t ht => measurable_set_generate_from ht)\n#align generate_from_eq generate_from_eq\n\n",
 "generatePiSystem_subset_self":
 "#print generatePiSystem_subset_self /-\ntheorem generatePiSystem_subset_self {α} {S : Set (Set α)} (h_S : IsPiSystem S) : generatePiSystem S ⊆ S :=\n  by\n  intro x h\n  induction' h with s h_s s u h_gen_s h_gen_u h_nonempty h_s h_u\n  · exact h_s\n  · exact h_S _ h_s _ h_u h_nonempty\n#align generate_pi_system_subset_self generatePiSystem_subset_self\n-/\n\n",
 "generatePiSystem_mono":
 "#print generatePiSystem_mono /-\ntheorem generatePiSystem_mono {α} {S T : Set (Set α)} (hST : S ⊆ T) : generatePiSystem S ⊆ generatePiSystem T :=\n  by\n  intro t ht\n  induction' ht with s h_s s u h_gen_s h_gen_u h_nonempty h_s h_u\n  · exact generate_pi_system.base (Set.mem_of_subset_of_mem hST h_s)\n  · exact isPiSystem_generatePiSystem T _ h_s _ h_u h_nonempty\n#align generate_pi_system_mono generatePiSystem_mono\n-/\n\n",
 "generatePiSystem_measurableSet":
 "#print generatePiSystem_measurableSet /-\ntheorem generatePiSystem_measurableSet {α} [M : MeasurableSpace α] {S : Set (Set α)}\n    (h_meas_S : ∀ s ∈ S, MeasurableSet s) (t : Set α) (h_in_pi : t ∈ generatePiSystem S) : MeasurableSet t :=\n  by\n  induction' h_in_pi with s h_s s u h_gen_s h_gen_u h_nonempty h_s h_u\n  · apply h_meas_S _ h_s\n  · apply MeasurableSet.inter h_s h_u\n#align generate_pi_system_measurable_set generatePiSystem_measurableSet\n-/\n\n",
 "generatePiSystem_eq":
 "#print generatePiSystem_eq /-\ntheorem generatePiSystem_eq {α} {S : Set (Set α)} (h_pi : IsPiSystem S) : generatePiSystem S = S :=\n  Set.Subset.antisymm (generatePiSystem_subset_self h_pi) (subset_generatePiSystem_self S)\n#align generate_pi_system_eq generatePiSystem_eq\n-/\n\n",
 "generateFrom_piUnionᵢInter_singleton_left":
 "#print generateFrom_piUnionᵢInter_singleton_left /-\ntheorem generateFrom_piUnionᵢInter_singleton_left (s : ι → Set α) (S : Set ι) :\n    generateFrom (piUnionᵢInter (fun k => {s k}) S) = generateFrom { t | ∃ k ∈ S, s k = t } :=\n  by\n  refine' le_antisymm (generate_from_le _) (generate_from_mono _)\n  · rintro _ ⟨I, hI, f, hf, rfl⟩\n    refine' Finset.measurableSet_binterᵢ _ fun m hm => measurable_set_generate_from _\n    exact ⟨m, hI hm, (hf m hm).symm⟩\n  · rintro _ ⟨k, hk, rfl⟩\n    refine' ⟨{k}, fun m hm => _, s, fun i hi => _, _⟩\n    · rw [Finset.mem_coe, Finset.mem_singleton] at hm\n      rwa [hm]\n    · exact Set.mem_singleton _\n    · simp only [Finset.mem_singleton, Set.interᵢ_interᵢ_eq_left]\n#align generate_from_pi_Union_Inter_singleton_left generateFrom_piUnionᵢInter_singleton_left\n-/\n\n",
 "generateFrom_piUnionᵢInter_measurableSet":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n#print generateFrom_piUnionᵢInter_measurableSet /-\ntheorem generateFrom_piUnionᵢInter_measurableSet (m : ι → MeasurableSpace α) (S : Set ι) :\n    generateFrom (piUnionᵢInter (fun n => { s | (measurable_set_of (m n)) s }) S) =\n      «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (m i) :=\n  by\n  refine' le_antisymm _ _\n  · rw [←\n      @generate_from_measurable_set α\n        («expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (m i))]\n    exact generate_from_mono (measurableSet_supᵢ_of_mem_piUnionᵢInter m S)\n  · refine' supᵢ₂_le fun i hi => _\n    rw [← @generate_from_measurable_set α (m i)]\n    exact generate_from_mono (mem_piUnionᵢInter_of_measurableSet m hi)\n#align generate_from_pi_Union_Inter_measurable_set generateFrom_piUnionᵢInter_measurableSet\n-/\n\n",
 "generateFrom_piUnionᵢInter_le":
 "#print generateFrom_piUnionᵢInter_le /-\ntheorem generateFrom_piUnionᵢInter_le {m : MeasurableSpace α} (π : ι → Set (Set α)) (h : ∀ n, generateFrom (π n) ≤ m)\n    (S : Set ι) : generateFrom (piUnionᵢInter π S) ≤ m :=\n  by\n  refine' generate_from_le _\n  rintro t ⟨ht_p, ht_p_mem, ft, hft_mem_pi, rfl⟩\n  refine' Finset.measurableSet_binterᵢ _ fun x hx_mem => (h x) _ _\n  exact measurable_set_generate_from (hft_mem_pi x hx_mem)\n#align generate_from_pi_Union_Inter_le generateFrom_piUnionᵢInter_le\n-/\n\n",
 "generateFrom_measurableSet_of_generatePiSystem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\n#print generateFrom_measurableSet_of_generatePiSystem /-\ntheorem generateFrom_measurableSet_of_generatePiSystem {α} {g : Set (Set α)} (t : Set α) (ht : t ∈ generatePiSystem g) :\n    (measurable_set_of (generateFrom g)) t :=\n  @generatePiSystem_measurableSet α (generateFrom g) g (fun s h_s_in_g => measurableSet_generateFrom h_s_in_g) t ht\n#align generate_from_measurable_set_of_generate_pi_system generateFrom_measurableSet_of_generatePiSystem\n-/\n\n",
 "generateFrom_generatePiSystem_eq":
 "#print generateFrom_generatePiSystem_eq /-\ntheorem generateFrom_generatePiSystem_eq {α} {g : Set (Set α)} : generateFrom (generatePiSystem g) = generateFrom g :=\n  by\n  apply le_antisymm <;> apply generate_from_le\n  · exact fun t h_t => generateFrom_measurableSet_of_generatePiSystem t h_t\n  · exact fun t h_t => measurable_set_generate_from (generate_pi_system.base h_t)\n#align generate_from_generate_pi_system_eq generateFrom_generatePiSystem_eq\n-/\n\n",
 "ext":
 "@[ext]\ntheorem ext : ∀ {d₁ d₂ : DynkinSystem α}, (∀ s : Set α, d₁.has s ↔ d₂.has s) → d₁ = d₂\n  | ⟨s₁, _, _, _⟩, ⟨s₂, _, _, _⟩, h =>\n    by\n    have : s₁ = s₂ := funext fun x => propext <| h x\n    subst this\n#align ext ext\n\n",
 "comap":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n#print IsPiSystem.comap /-\ntheorem IsPiSystem.comap {α β} {S : Set (Set β)} (h_pi : IsPiSystem S) (f : α → β) :\n    IsPiSystem { s : Set α | ∃ t ∈ S, «expr ⁻¹' » f t = s } :=\n  by\n  rintro _ ⟨s, hs_mem, rfl⟩ _ ⟨t, ht_mem, rfl⟩ hst\n  rw [← Set.preimage_inter] at hst⊢\n  refine' ⟨s ∩ t, h_pi s hs_mem t ht_mem _, rfl⟩\n  by_contra\n  rw [Set.not_nonempty_iff_eq_empty] at h\n  rw [h] at hst\n  simpa using hst\n#align is_pi_system.comap IsPiSystem.comap\n-/\n\n",
 "Union":
 "#print Union /-\ntheorem Union {s₁ s₂ : Set α} (h₁ : d.has s₁) (h₂ : d.has s₂) (h : Disjoint s₁ s₂) : d.has (s₁ ∪ s₂) :=\n  by\n  rw [union_eq_Union]\n  exact d.has_Union (pairwise_disjoint_on_bool.2 h) (Bool.forall_bool.2 ⟨h₂, h₁⟩)\n#align has_union Union\n-/\n\n"}