{"zero_pos_part":
 "/-\nCopyright (c) 2021 Kexing Ying. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Kexing Ying\n-/\n@[simp]\ntheorem zero_pos_part : (0 : jordan_decomposition α).pos_part = 0 :=\n  rfl\n#align zero_pos_part zero_pos_part\n\n",
 "zero_neg_part":
 "@[simp]\ntheorem zero_neg_part : (0 : jordan_decomposition α).neg_part = 0 :=\n  rfl\n#align zero_neg_part zero_neg_part\n\n",
 "total_variation_zero":
 "theorem total_variation_zero : (0 : signed_measure α).total_variation = 0 := by\n  simp [total_variation, to_jordan_decomposition_zero]\n#align total_variation_zero total_variation_zero\n\n",
 "total_variation_neg":
 "theorem total_variation_neg (s : signed_measure α) : (-s).total_variation = s.total_variation := by\n  simp [total_variation, to_jordan_decomposition_neg, add_comm]\n#align total_variation_neg total_variation_neg\n\n",
 "total_variation_mutually_singular_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure.mutually_singular -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure.mutually_singular -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure.mutually_singular -/\ntheorem total_variation_mutually_singular_iff (s : signed_measure α) (μ : measure α) :\n    measure.mutually_singular s.total_variation μ ↔\n      measure.mutually_singular s.to_jordan_decomposition.pos_part μ ∧\n        measure.mutually_singular s.to_jordan_decomposition.neg_part μ :=\n  measure.mutually_singular.add_left_iff\n#align total_variation_mutually_singular_iff total_variation_mutually_singular_iff\n\n",
 "total_variation_absolutely_continuous_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure.absolutely_continuous -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure.absolutely_continuous -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure.absolutely_continuous -/\ntheorem total_variation_absolutely_continuous_iff (s : signed_measure α) (μ : measure α) :\n    measure.absolutely_continuous s.total_variation μ ↔\n      measure.absolutely_continuous s.to_jordan_decomposition.pos_part μ ∧\n        measure.absolutely_continuous s.to_jordan_decomposition.neg_part μ :=\n  by\n  constructor <;> intro h\n  · constructor\n    all_goals\n      refine' measure.absolutely_continuous.mk fun S hS₁ hS₂ => _\n      have := h hS₂\n      rw [total_variation, measure.add_apply, add_eq_zero_iff] at this\n    exacts[this.1, this.2]\n  · refine' measure.absolutely_continuous.mk fun S hS₁ hS₂ => _\n    rw [total_variation, measure.add_apply, h.1 hS₂, h.2 hS₂, add_zero]\n#align total_variation_absolutely_continuous_iff total_variation_absolutely_continuous_iff\n\n",
 "to_signed_measure_zero":
 "theorem to_signed_measure_zero : (0 : jordan_decomposition α).to_signed_measure = 0 :=\n  by\n  ext1 i hi\n  erw [to_signed_measure, to_signed_measure_sub_apply hi, sub_self, zero_apply]\n#align to_signed_measure_zero to_signed_measure_zero\n\n",
 "to_signed_measure_to_jordan_decomposition":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/-- **The Jordan decomposition theorem**: Given a signed measure `s`, there exists a pair of\nmutually singular measures `μ` and `ν` such that `s = μ - ν`. In this case, the measures `μ`\nand `ν` are given by `s.to_jordan_decomposition.pos_part` and\n`s.to_jordan_decomposition.neg_part` respectively.\n\nNote that we use `measure_theory.jordan_decomposition.to_signed_measure` to represent the\nsigned measure corresponding to\n`s.to_jordan_decomposition.pos_part - s.to_jordan_decomposition.neg_part`. -/\n@[simp]\ntheorem to_signed_measure_to_jordan_decomposition (s : signed_measure α) :\n    s.to_jordan_decomposition.to_signed_measure = s :=\n  by\n  obtain ⟨i, hi₁, hi₂, hi₃, hμ, hν⟩ := s.to_jordan_decomposition_spec\n  simp only [jordan_decomposition.to_signed_measure, hμ, hν]\n  ext (k hk)\n  rw [to_signed_measure_sub_apply hk, to_measure_of_zero_le_apply _ hi₂ hi₁ hk,\n    to_measure_of_le_zero_apply _ hi₃ hi₁.compl hk]\n  simp only [ennreal.coe_to_real, subtype.coe_mk, ennreal.some_eq_coe, sub_neg_eq_add]\n  rw [← of_union _ (measurable_set.inter hi₁ hk) (measurable_set.inter hi₁.compl hk), Set.inter_comm i,\n    Set.inter_comm («expr ᶜ» i), Set.inter_union_compl _ _]\n  · infer_instance\n  · exact (disjoint_compl_right.inf_left _).inf_right _\n#align to_signed_measure_to_jordan_decomposition to_signed_measure_to_jordan_decomposition\n\n",
 "to_signed_measure_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem to_signed_measure_smul (r : nnreal) : («expr • » r j).to_signed_measure = «expr • » r j.to_signed_measure :=\n  by\n  ext1 i hi\n  rw [vector_measure.smul_apply, to_signed_measure, to_signed_measure, to_signed_measure_sub_apply hi,\n    to_signed_measure_sub_apply hi, smul_sub, smul_pos_part, smul_neg_part, ← ennreal.to_real_smul, ←\n    ennreal.to_real_smul]\n  rfl\n#align to_signed_measure_smul to_signed_measure_smul\n\n",
 "to_signed_measure_neg":
 "theorem to_signed_measure_neg : (-j).to_signed_measure = -j.to_signed_measure :=\n  by\n  ext1 i hi\n  rw [neg_apply, to_signed_measure, to_signed_measure, to_signed_measure_sub_apply hi, to_signed_measure_sub_apply hi,\n    neg_sub]\n  rfl\n#align to_signed_measure_neg to_signed_measure_neg\n\n",
 "to_signed_measure_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/-- The Jordan decomposition of a signed measure is unique. -/\ntheorem to_signed_measure_injective : injective <| @jordan_decomposition.to_signed_measure α _ :=\n  by\n  /- The main idea is that two Jordan decompositions of a signed measure provide two\n    Hahn decompositions for that measure. Then, from `of_symm_diff_compl_positive_negative`,\n    the symmetric difference of the two Hahn decompositions has measure zero, thus, allowing us to\n    show the equality of the underlying measures of the Jordan decompositions. -/\n  intro j₁ j₂ hj\n  -- obtain the two Hahn decompositions from the Jordan decompositions\n  obtain ⟨S, hS₁, hS₂, hS₃, hS₄, hS₅⟩ := j₁.exists_compl_positive_negative\n  obtain ⟨T, hT₁, hT₂, hT₃, hT₄, hT₅⟩ := j₂.exists_compl_positive_negative\n  rw [← hj] at hT₂ hT₃\n  -- the symmetric differences of the two Hahn decompositions have measure zero\n  obtain ⟨hST₁, -⟩ :=\n    of_symm_diff_compl_positive_negative hS₁.compl hT₁.compl ⟨hS₃, (compl_compl S).symm ▸ hS₂⟩\n      ⟨hT₃, (compl_compl T).symm ▸ hT₂⟩\n  -- it suffices to show the Jordan decompositions have the same positive parts\n  refine' eq_of_pos_part_eq_pos_part _ hj\n  ext1 i hi\n  -- we see that the positive parts of the two Jordan decompositions are equal to their\n  -- associated signed measures restricted on their associated Hahn decompositions\n  have hμ₁ : (j₁.pos_part i).to_real = j₁.to_signed_measure (i ∩ «expr ᶜ» S) :=\n    by\n    rw [to_signed_measure, to_signed_measure_sub_apply (hi.inter hS₁.compl),\n      show j₁.neg_part (i ∩ «expr ᶜ» S) = 0 from nonpos_iff_eq_zero.1 (hS₅ ▸ measure_mono (Set.inter_subset_right _ _)),\n      ennreal.zero_to_real, sub_zero]\n    conv_lhs => rw [← Set.inter_union_compl i S]\n    rw [measure_union,\n      show j₁.pos_part (i ∩ S) = 0 from nonpos_iff_eq_zero.1 (hS₄ ▸ measure_mono (Set.inter_subset_right _ _)),\n      zero_add]\n    ·\n      refine'\n        Set.disjoint_of_subset_left (Set.inter_subset_right _ _)\n          (Set.disjoint_of_subset_right (Set.inter_subset_right _ _) disjoint_compl_right)\n    · exact hi.inter hS₁.compl\n  have hμ₂ : (j₂.pos_part i).to_real = j₂.to_signed_measure (i ∩ «expr ᶜ» T) :=\n    by\n    rw [to_signed_measure, to_signed_measure_sub_apply (hi.inter hT₁.compl),\n      show j₂.neg_part (i ∩ «expr ᶜ» T) = 0 from nonpos_iff_eq_zero.1 (hT₅ ▸ measure_mono (Set.inter_subset_right _ _)),\n      ennreal.zero_to_real, sub_zero]\n    conv_lhs => rw [← Set.inter_union_compl i T]\n    rw [measure_union,\n      show j₂.pos_part (i ∩ T) = 0 from nonpos_iff_eq_zero.1 (hT₄ ▸ measure_mono (Set.inter_subset_right _ _)),\n      zero_add]\n    ·\n      exact\n        Set.disjoint_of_subset_left (Set.inter_subset_right _ _)\n          (Set.disjoint_of_subset_right (Set.inter_subset_right _ _) disjoint_compl_right)\n    · exact hi.inter hT₁.compl\n  -- since the two signed measures associated with the Jordan decompositions are the same,\n  -- and the symmetric difference of the Hahn decompositions have measure zero, the result follows\n  rw [← ennreal.to_real_eq_to_real (measure_ne_top _ _) (measure_ne_top _ _), hμ₁, hμ₂, ← hj]\n  exact of_inter_eq_of_symm_diff_eq_zero_positive hS₁.compl hT₁.compl hi hS₃ hT₃ hST₁\n  all_goals infer_instance\n#align to_signed_measure_injective to_signed_measure_injective\n\n",
 "to_jordan_decomposition_zero":
 "theorem to_jordan_decomposition_zero : (0 : signed_measure α).to_jordan_decomposition = 0 :=\n  by\n  apply to_signed_measure_injective\n  simp [to_signed_measure_zero]\n#align to_jordan_decomposition_zero to_jordan_decomposition_zero\n\n",
 "to_jordan_decomposition_to_signed_measure":
 "@[simp]\ntheorem to_jordan_decomposition_to_signed_measure (j : jordan_decomposition α) :\n    j.to_signed_measure.to_jordan_decomposition = j :=\n  (@to_signed_measure_injective _ _ j j.to_signed_measure.to_jordan_decomposition (by simp)).symm\n#align to_jordan_decomposition_to_signed_measure to_jordan_decomposition_to_signed_measure\n\n",
 "to_jordan_decomposition_spec":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `vector_measure.restrict -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `vector_measure.restrict -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\ntheorem to_jordan_decomposition_spec (s : signed_measure α) :\n    ∃ (i : set α)(hi₁ : measurable_set i)(hi₂ : vector_measure.restrict 0 i s)(hi₃ :\n      vector_measure.restrict s («expr ᶜ» i) 0),\n      s.to_jordan_decomposition.pos_part = s.to_measure_of_zero_le i hi₁ hi₂ ∧\n        s.to_jordan_decomposition.neg_part = s.to_measure_of_le_zero («expr ᶜ» i) hi₁.compl hi₃ :=\n  by\n  set i := some s.exists_compl_positive_negative\n  obtain ⟨hi₁, hi₂, hi₃⟩ := some_spec s.exists_compl_positive_negative\n  exact ⟨i, hi₁, hi₂, hi₃, rfl, rfl⟩\n#align to_jordan_decomposition_spec to_jordan_decomposition_spec\n\n",
 "to_jordan_decomposition_smul_real_nonneg":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\nprivate theorem to_jordan_decomposition_smul_real_nonneg (s : signed_measure α) (r : exprℝ) (hr : 0 ≤ r) :\n    («expr • » r s).to_jordan_decomposition = «expr • » r s.to_jordan_decomposition :=\n  by\n  lift r to nnreal using hr\n  rw [jordan_decomposition.coe_smul, ← to_jordan_decomposition_smul]\n  rfl\n#align to_jordan_decomposition_smul_real_nonneg to_jordan_decomposition_smul_real_nonneg\n\n",
 "to_jordan_decomposition_smul_real":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem to_jordan_decomposition_smul_real (s : signed_measure α) (r : exprℝ) :\n    («expr • » r s).to_jordan_decomposition = «expr • » r s.to_jordan_decomposition :=\n  by\n  by_cases hr : 0 ≤ r\n  · exact to_jordan_decomposition_smul_real_nonneg s r hr\n  · ext1\n    · rw [real_smul_pos_part_neg _ _ (not_le.1 hr), show «expr • » r s = -«expr • » (-r) s by rw [neg_smul, neg_neg],\n        to_jordan_decomposition_neg, neg_pos_part, to_jordan_decomposition_smul_real_nonneg, ← smul_neg_part,\n        real_smul_nonneg]\n      all_goals exact left.nonneg_neg_iff.2 (le_of_lt (not_le.1 hr))\n    · rw [real_smul_neg_part_neg _ _ (not_le.1 hr), show «expr • » r s = -«expr • » (-r) s by rw [neg_smul, neg_neg],\n        to_jordan_decomposition_neg, neg_neg_part, to_jordan_decomposition_smul_real_nonneg, ← smul_pos_part,\n        real_smul_nonneg]\n      all_goals exact left.nonneg_neg_iff.2 (le_of_lt (not_le.1 hr))\n#align to_jordan_decomposition_smul_real to_jordan_decomposition_smul_real\n\n",
 "to_jordan_decomposition_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem to_jordan_decomposition_smul (s : signed_measure α) (r : nnreal) :\n    («expr • » r s).to_jordan_decomposition = «expr • » r s.to_jordan_decomposition :=\n  by\n  apply to_signed_measure_injective\n  simp [to_signed_measure_smul]\n#align to_jordan_decomposition_smul to_jordan_decomposition_smul\n\n",
 "to_jordan_decomposition_neg":
 "theorem to_jordan_decomposition_neg (s : signed_measure α) :\n    (-s).to_jordan_decomposition = -s.to_jordan_decomposition :=\n  by\n  apply to_signed_measure_injective\n  simp [to_signed_measure_neg]\n#align to_jordan_decomposition_neg to_jordan_decomposition_neg\n\n",
 "to_jordan_decomposition_eq":
 "theorem to_jordan_decomposition_eq {s : signed_measure α} {j : jordan_decomposition α} (h : s = j.to_signed_measure) :\n    s.to_jordan_decomposition = j := by rw [h, to_jordan_decomposition_to_signed_measure]\n#align to_jordan_decomposition_eq to_jordan_decomposition_eq\n\n",
 "subset_positive_null_set":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `vector_measure.restrict -/\n/-- A subset `v` of a null-set `w` has zero measure if `w` is a subset of a positive set `u`. -/\ntheorem subset_positive_null_set (hu : measurable_set u) (hv : measurable_set v) (hw : measurable_set w)\n    (hsu : vector_measure.restrict 0 u s) (hw₁ : s w = 0) (hw₂ : w ⊆ u) (hwt : v ⊆ w) : s v = 0 :=\n  by\n  have : s v + s (w \\ v) = 0 :=\n    by\n    rw [← hw₁, ← of_union set.disjoint_sdiff_right hv (hw.diff hv), Set.union_diff_self,\n      Set.union_eq_self_of_subset_left hwt]\n    infer_instance\n  have h₁ := nonneg_of_zero_le_restrict _ (restrict_le_restrict_subset _ _ hu hsu (hwt.trans hw₂))\n  have h₂ := nonneg_of_zero_le_restrict _ (restrict_le_restrict_subset _ _ hu hsu ((w.diff_subset v).trans hw₂))\n  linarith\n#align subset_positive_null_set subset_positive_null_set\n\n",
 "subset_negative_null_set":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `vector_measure.restrict -/\n/-- A subset `v` of a null-set `w` has zero measure if `w` is a subset of a negative set `u`. -/\ntheorem subset_negative_null_set (hu : measurable_set u) (hv : measurable_set v) (hw : measurable_set w)\n    (hsu : vector_measure.restrict s u 0) (hw₁ : s w = 0) (hw₂ : w ⊆ u) (hwt : v ⊆ w) : s v = 0 :=\n  by\n  rw [← s.neg_le_neg_iff _ hu, neg_zero] at hsu\n  have := subset_positive_null_set hu hv hw hsu\n  simp only [pi.neg_apply, neg_eq_zero, coe_neg] at this\n  exact this hw₁ hw₂ hwt\n#align subset_negative_null_set subset_negative_null_set\n\n",
 "smul_pos_part":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem smul_pos_part (r : nnreal) : («expr • » r j).pos_part = «expr • » r j.pos_part :=\n  rfl\n#align smul_pos_part smul_pos_part\n\n",
 "smul_neg_part":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem smul_neg_part (r : nnreal) : («expr • » r j).neg_part = «expr • » r j.neg_part :=\n  rfl\n#align smul_neg_part smul_neg_part\n\n",
 "real_smul_pos_part_nonneg":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem real_smul_pos_part_nonneg (r : exprℝ) (hr : 0 ≤ r) :\n    («expr • » r j).pos_part = «expr • » r.to_nnreal j.pos_part := by rw [real_smul_def, ← smul_pos_part, dif_pos hr]\n#align real_smul_pos_part_nonneg real_smul_pos_part_nonneg\n\n",
 "real_smul_pos_part_neg":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem real_smul_pos_part_neg (r : exprℝ) (hr : r < 0) :\n    («expr • » r j).pos_part = «expr • » (-r).to_nnreal j.neg_part := by\n  rw [real_smul_def, ← smul_neg_part, dif_neg (not_le.2 hr), neg_pos_part]\n#align real_smul_pos_part_neg real_smul_pos_part_neg\n\n",
 "real_smul_nonneg":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem real_smul_nonneg (r : exprℝ) (hr : 0 ≤ r) : «expr • » r j = «expr • » r.to_nnreal j :=\n  dif_pos hr\n#align real_smul_nonneg real_smul_nonneg\n\n",
 "real_smul_neg_part_nonneg":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem real_smul_neg_part_nonneg (r : exprℝ) (hr : 0 ≤ r) :\n    («expr • » r j).neg_part = «expr • » r.to_nnreal j.neg_part := by rw [real_smul_def, ← smul_neg_part, dif_pos hr]\n#align real_smul_neg_part_nonneg real_smul_neg_part_nonneg\n\n",
 "real_smul_neg_part_neg":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem real_smul_neg_part_neg (r : exprℝ) (hr : r < 0) :\n    («expr • » r j).neg_part = «expr • » (-r).to_nnreal j.pos_part := by\n  rw [real_smul_def, ← smul_pos_part, dif_neg (not_le.2 hr), neg_neg_part]\n#align real_smul_neg_part_neg real_smul_neg_part_neg\n\n",
 "real_smul_neg":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem real_smul_neg (r : exprℝ) (hr : r < 0) : «expr • » r j = -«expr • » (-r).to_nnreal j :=\n  dif_neg (not_le.2 hr)\n#align real_smul_neg real_smul_neg\n\n",
 "real_smul_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem real_smul_def (r : exprℝ) (j : jordan_decomposition α) :\n    «expr • » r j = if hr : 0 ≤ r then «expr • » r.to_nnreal j else -«expr • » (-r).to_nnreal j :=\n  rfl\n#align real_smul_def real_smul_def\n\n",
 "of_inter_eq_of_symm_diff_eq_zero_positive":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∆ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `vector_measure.restrict -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `vector_measure.restrict -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∆ » -/\ntheorem of_inter_eq_of_symm_diff_eq_zero_positive (hu : measurable_set u) (hv : measurable_set v)\n    (hw : measurable_set w) (hsu : vector_measure.restrict 0 u s) (hsv : vector_measure.restrict 0 v s)\n    (hs : s («expr ∆ » u v) = 0) : s (w ∩ u) = s (w ∩ v) :=\n  by\n  have hwuv : s («expr ∆ » (w ∩ u) (w ∩ v)) = 0 :=\n    by\n    refine'\n      subset_positive_null_set (hu.union hv) ((hw.inter hu).symm_diff (hw.inter hv)) (hu.symm_diff hv)\n        (restrict_le_restrict_union _ _ hu hsu hv hsv) hs symm_diff_subset_union _\n    rw [← inter_symm_diff_distrib_left]\n    exact inter_subset_right _ _\n  obtain ⟨huv, hvu⟩ :=\n    of_diff_eq_zero_of_symm_diff_eq_zero_positive (hw.inter hu) (hw.inter hv)\n      (restrict_le_restrict_subset _ _ hu hsu (w.inter_subset_right u))\n      (restrict_le_restrict_subset _ _ hv hsv (w.inter_subset_right v)) hwuv\n  rw [← of_diff_of_diff_eq_zero (hw.inter hu) (hw.inter hv) hvu, huv, zero_add]\n#align of_inter_eq_of_symm_diff_eq_zero_positive of_inter_eq_of_symm_diff_eq_zero_positive\n\n",
 "of_inter_eq_of_symm_diff_eq_zero_negative":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `vector_measure.restrict -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `vector_measure.restrict -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∆ » -/\ntheorem of_inter_eq_of_symm_diff_eq_zero_negative (hu : measurable_set u) (hv : measurable_set v)\n    (hw : measurable_set w) (hsu : vector_measure.restrict s u 0) (hsv : vector_measure.restrict s v 0)\n    (hs : s («expr ∆ » u v) = 0) : s (w ∩ u) = s (w ∩ v) :=\n  by\n  rw [← s.neg_le_neg_iff _ hu, neg_zero] at hsu\n  rw [← s.neg_le_neg_iff _ hv, neg_zero] at hsv\n  have := of_inter_eq_of_symm_diff_eq_zero_positive hu hv hw hsu hsv\n  simp only [pi.neg_apply, neg_inj, neg_eq_zero, coe_neg] at this\n  exact this hs\n#align of_inter_eq_of_symm_diff_eq_zero_negative of_inter_eq_of_symm_diff_eq_zero_negative\n\n",
 "of_diff_eq_zero_of_symm_diff_eq_zero_positive":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `vector_measure.restrict -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `vector_measure.restrict -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∆ » -/\n/-- If the symmetric difference of two positive sets is a null-set, then so are the differences\nbetween the two sets. -/\ntheorem of_diff_eq_zero_of_symm_diff_eq_zero_positive (hu : measurable_set u) (hv : measurable_set v)\n    (hsu : vector_measure.restrict 0 u s) (hsv : vector_measure.restrict 0 v s) (hs : s («expr ∆ » u v) = 0) :\n    s (u \\ v) = 0 ∧ s (v \\ u) = 0 := by\n  rw [restrict_le_restrict_iff] at hsu hsv\n  have a := hsu (hu.diff hv) (u.diff_subset v)\n  have b := hsv (hv.diff hu) (v.diff_subset u)\n  erw [of_union (Set.disjoint_of_subset_left (u.diff_subset v) disjoint_sdiff_self_right) (hu.diff hv) (hv.diff hu)] at\n    hs\n  rw [zero_apply] at a b\n  constructor\n  all_goals first |linarith|infer_instance|assumption\n#align of_diff_eq_zero_of_symm_diff_eq_zero_positive of_diff_eq_zero_of_symm_diff_eq_zero_positive\n\n",
 "of_diff_eq_zero_of_symm_diff_eq_zero_negative":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `vector_measure.restrict -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `vector_measure.restrict -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∆ » -/\n/-- If the symmetric difference of two negative sets is a null-set, then so are the differences\nbetween the two sets. -/\ntheorem of_diff_eq_zero_of_symm_diff_eq_zero_negative (hu : measurable_set u) (hv : measurable_set v)\n    (hsu : vector_measure.restrict s u 0) (hsv : vector_measure.restrict s v 0) (hs : s («expr ∆ » u v) = 0) :\n    s (u \\ v) = 0 ∧ s (v \\ u) = 0 := by\n  rw [← s.neg_le_neg_iff _ hu, neg_zero] at hsu\n  rw [← s.neg_le_neg_iff _ hv, neg_zero] at hsv\n  have := of_diff_eq_zero_of_symm_diff_eq_zero_positive hu hv hsu hsv\n  simp only [pi.neg_apply, neg_eq_zero, coe_neg] at this\n  exact this hs\n#align of_diff_eq_zero_of_symm_diff_eq_zero_negative of_diff_eq_zero_of_symm_diff_eq_zero_negative\n\n",
 "null_of_total_variation_zero":
 "theorem null_of_total_variation_zero (s : signed_measure α) {i : set α} (hs : s.total_variation i = 0) : s i = 0 :=\n  by\n  rw [total_variation, measure.coe_add, pi.add_apply, add_eq_zero_iff] at hs\n  rw [← to_signed_measure_to_jordan_decomposition s, to_signed_measure, vector_measure.coe_sub, pi.sub_apply,\n    measure.to_signed_measure_apply, measure.to_signed_measure_apply]\n  by_cases hi : measurable_set i\n  · rw [if_pos hi, if_pos hi]\n    simp [hs.1, hs.2]\n  · simp [if_neg hi]\n#align null_of_total_variation_zero null_of_total_variation_zero\n\n",
 "neg_pos_part":
 "@[simp]\ntheorem neg_pos_part : (-j).pos_part = j.neg_part :=\n  rfl\n#align neg_pos_part neg_pos_part\n\n",
 "neg_neg_part":
 "@[simp]\ntheorem neg_neg_part : (-j).neg_part = j.pos_part :=\n  rfl\n#align neg_neg_part neg_neg_part\n\n",
 "mutually_singular_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `vector_measure.mutually_singular -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure.mutually_singular -/\n-- TODO: Generalize to vector measures once total variation on vector measures is defined\ntheorem mutually_singular_iff (s t : signed_measure α) :\n    vector_measure.mutually_singular s t ↔ measure.mutually_singular s.total_variation t.total_variation :=\n  by\n  constructor\n  · rintro ⟨u, hmeas, hu₁, hu₂⟩\n    obtain ⟨i, hi₁, hi₂, hi₃, hipos, hineg⟩ := s.to_jordan_decomposition_spec\n    obtain ⟨j, hj₁, hj₂, hj₃, hjpos, hjneg⟩ := t.to_jordan_decomposition_spec\n    refine' ⟨u, hmeas, _, _⟩\n    · rw [total_variation, measure.add_apply, hipos, hineg, to_measure_of_zero_le_apply _ _ _ hmeas,\n        to_measure_of_le_zero_apply _ _ _ hmeas]\n      simp [hu₁ _ (Set.inter_subset_right _ _)]\n    · rw [total_variation, measure.add_apply, hjpos, hjneg, to_measure_of_zero_le_apply _ _ _ hmeas.compl,\n        to_measure_of_le_zero_apply _ _ _ hmeas.compl]\n      simp [hu₂ _ (Set.inter_subset_right _ _)]\n  · rintro ⟨u, hmeas, hu₁, hu₂⟩\n    exact\n      ⟨u, hmeas, fun t htu => null_of_total_variation_zero _ (measure_mono_null htu hu₁), fun t htv =>\n        null_of_total_variation_zero _ (measure_mono_null htv hu₂)⟩\n#align mutually_singular_iff mutually_singular_iff\n\n",
 "mutually_singular_ennreal_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `vector_measure.mutually_singular -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure.mutually_singular -/\ntheorem mutually_singular_ennreal_iff (s : signed_measure α) (μ : vector_measure α (ennreal)) :\n    vector_measure.mutually_singular s μ ↔ measure.mutually_singular s.total_variation μ.ennreal_to_measure :=\n  by\n  constructor\n  · rintro ⟨u, hmeas, hu₁, hu₂⟩\n    obtain ⟨i, hi₁, hi₂, hi₃, hpos, hneg⟩ := s.to_jordan_decomposition_spec\n    refine' ⟨u, hmeas, _, _⟩\n    · rw [total_variation, measure.add_apply, hpos, hneg, to_measure_of_zero_le_apply _ _ _ hmeas,\n        to_measure_of_le_zero_apply _ _ _ hmeas]\n      simp [hu₁ _ (Set.inter_subset_right _ _)]\n    · rw [vector_measure.ennreal_to_measure_apply hmeas.compl]\n      exact hu₂ _ (Set.Subset.refl _)\n  · rintro ⟨u, hmeas, hu₁, hu₂⟩\n    refine'\n      vector_measure.mutually_singular.mk u hmeas\n        (fun t htu _ => null_of_total_variation_zero _ (measure_mono_null htu hu₁)) fun t htv hmt => _\n    rw [← vector_measure.ennreal_to_measure_apply hmt]\n    exact measure_mono_null htv hu₂\n#align mutually_singular_ennreal_iff mutually_singular_ennreal_iff\n\n",
 "exists_compl_positive_negative":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `vector_measure.restrict -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `vector_measure.restrict -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/-- A Jordan decomposition provides a Hahn decomposition. -/\ntheorem exists_compl_positive_negative :\n    ∃ S : set α,\n      measurable_set S ∧\n        vector_measure.restrict j.to_signed_measure S 0 ∧\n          vector_measure.restrict 0 («expr ᶜ» S) j.to_signed_measure ∧ j.pos_part S = 0 ∧ j.neg_part («expr ᶜ» S) = 0 :=\n  by\n  obtain ⟨S, hS₁, hS₂, hS₃⟩ := j.mutually_singular\n  refine' ⟨S, hS₁, _, _, hS₂, hS₃⟩\n  · refine' restrict_le_restrict_of_subset_le _ _ fun A hA hA₁ => _\n    rw [to_signed_measure, to_signed_measure_sub_apply hA,\n      show j.pos_part A = 0 from nonpos_iff_eq_zero.1 (hS₂ ▸ measure_mono hA₁), ennreal.zero_to_real, zero_sub, neg_le,\n      zero_apply, neg_zero]\n    exact ennreal.to_real_nonneg\n  · refine' restrict_le_restrict_of_subset_le _ _ fun A hA hA₁ => _\n    rw [to_signed_measure, to_signed_measure_sub_apply hA,\n      show j.neg_part A = 0 from nonpos_iff_eq_zero.1 (hS₃ ▸ measure_mono hA₁), ennreal.zero_to_real, sub_zero]\n    exact ennreal.to_real_nonneg\n#align exists_compl_positive_negative exists_compl_positive_negative\n\n",
 "eq_of_pos_part_eq_pos_part":
 "private theorem eq_of_pos_part_eq_pos_part {j₁ j₂ : jordan_decomposition α} (hj : j₁.pos_part = j₂.pos_part)\n    (hj' : j₁.to_signed_measure = j₂.to_signed_measure) : j₁ = j₂ :=\n  by\n  ext1\n  · exact hj\n  · rw [← to_signed_measure_eq_to_signed_measure_iff]\n    suffices\n      j₁.pos_part.to_signed_measure - j₁.neg_part.to_signed_measure =\n        j₁.pos_part.to_signed_measure - j₂.neg_part.to_signed_measure\n      by exact sub_right_inj.mp this\n    convert hj'\n#align eq_of_pos_part_eq_pos_part eq_of_pos_part_eq_pos_part\n\n",
 "coe_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem coe_smul (r : nnreal) : «expr • » (r : exprℝ) j = «expr • » r j :=\n  show dite _ _ _ = _ by rw [dif_pos (nnreal.coe_nonneg r), real.to_nnreal_coe]\n#align coe_smul coe_smul\n\n",
 "absolutely_continuous_ennreal_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `vector_measure.absolutely_continuous -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure.absolutely_continuous -/\ntheorem absolutely_continuous_ennreal_iff (s : signed_measure α) (μ : vector_measure α (ennreal)) :\n    vector_measure.absolutely_continuous s μ ↔ measure.absolutely_continuous s.total_variation μ.ennreal_to_measure :=\n  by\n  constructor <;> intro h\n  · refine' measure.absolutely_continuous.mk fun S hS₁ hS₂ => _\n    obtain ⟨i, hi₁, hi₂, hi₃, hpos, hneg⟩ := s.to_jordan_decomposition_spec\n    rw [total_variation, measure.add_apply, hpos, hneg, to_measure_of_zero_le_apply _ _ _ hS₁,\n      to_measure_of_le_zero_apply _ _ _ hS₁]\n    rw [← vector_measure.absolutely_continuous.ennreal_to_measure] at h\n    simp [h (measure_mono_null (i.inter_subset_right S) hS₂),\n      h (measure_mono_null ((«expr ᶜ» i).inter_subset_right S) hS₂)]\n  · refine' vector_measure.absolutely_continuous.mk fun S hS₁ hS₂ => _\n    rw [← vector_measure.ennreal_to_measure_apply hS₁] at hS₂\n    exact null_of_total_variation_zero s (h hS₂)\n#align absolutely_continuous_ennreal_iff absolutely_continuous_ennreal_iff\n\n"}