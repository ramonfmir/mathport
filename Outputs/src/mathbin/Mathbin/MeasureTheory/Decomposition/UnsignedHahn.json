{"hahn_decomposition":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/-\nCopyright (c) 2019 Johannes Hölzl. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johannes Hölzl\n-/\n/-- **Hahn decomposition theorem** -/\ntheorem hahn_decomposition [FiniteMeasure μ] [FiniteMeasure ν] :\n    ∃ s,\n      MeasurableSet s ∧\n        (∀ t, MeasurableSet t → t ⊆ s → ν t ≤ μ t) ∧ ∀ t, MeasurableSet t → t ⊆ «expr ᶜ» s → μ t ≤ ν t :=\n  by\n  let d : Set α → exprℝ := fun s => ((μ s).to_nnreal : exprℝ) - (ν s).to_nnreal\n  let c : Set (exprℝ) := «expr '' » d { s | MeasurableSet s }\n  let γ : exprℝ := Sup c\n  have hμ : ∀ s, μ s ≠ ennreal.top := measure_ne_top μ\n  have hν : ∀ s, ν s ≠ ennreal.top := measure_ne_top ν\n  have to_nnreal_μ : ∀ s, ((μ s).to_nnreal : ennreal) = μ s := fun s => ENNReal.coe_toNNReal <| hμ _\n  have to_nnreal_ν : ∀ s, ((ν s).to_nnreal : ennreal) = ν s := fun s => ENNReal.coe_toNNReal <| hν _\n  have d_empty : d ∅ = 0 := by\n    change _ - _ = _\n    rw [measure_empty, measure_empty, sub_self]\n  have d_split : ∀ s t, MeasurableSet s → MeasurableSet t → d s = d (s \\ t) + d (s ∩ t) :=\n    by\n    intro s t hs ht\n    simp only [d]\n    rw [← measure_inter_add_diff s ht, ← measure_inter_add_diff s ht, ENNReal.toNNReal_add (hμ _) (hμ _),\n      ENNReal.toNNReal_add (hν _) (hν _), NNReal.coe_add, NNReal.coe_add]\n    simp only [sub_eq_add_neg, neg_add]\n    abel\n  have d_Union :\n    ∀ s : ℕ → Set α,\n      Monotone s →\n        tendsto (fun n => d (s n)) at_top\n          ((nhds)\n            (d\n              («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n                (s n)))) :=\n    by\n    intro s hm\n    refine' tendsto.sub _ _ <;>\n      refine' NNReal.tendsto_coe.2 <| (ENNReal.tendsto_toNNReal _).comp <| tendsto_measure_Union hm\n    exact hμ _\n    exact hν _\n  have d_Inter :\n    ∀ s : ℕ → Set α,\n      (∀ n, MeasurableSet (s n)) →\n        (∀ n m, n ≤ m → s m ⊆ s n) →\n          tendsto (fun n => d (s n)) at_top\n            ((nhds)\n              (d\n                («expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\"\n                  (s n)))) :=\n    by\n    intro s hs hm\n    refine' tendsto.sub _ _ <;>\n      refine' NNReal.tendsto_coe.2 <| (ENNReal.tendsto_toNNReal <| _).comp <| tendsto_measure_Inter hs hm _\n    exacts[hμ _, ⟨0, hμ _⟩, hν _, ⟨0, hν _⟩]\n  have bdd_c : BddAbove c := by\n    use (μ univ).to_nnreal\n    rintro r ⟨s, hs, rfl⟩\n    refine' le_trans (sub_le_self _ <| NNReal.coe_nonneg _) _\n    rw [NNReal.coe_le_coe, ← ENNReal.coe_le_coe, to_nnreal_μ, to_nnreal_μ]\n    exact measure_mono (subset_univ _)\n  have c_nonempty : c.nonempty := nonempty.image _ ⟨_, MeasurableSet.empty⟩\n  have d_le_γ : ∀ s, MeasurableSet s → d s ≤ γ := fun s hs => le_csupₛ bdd_c ⟨s, hs, rfl⟩\n  have : ∀ n : ℕ, ∃ s : Set α, MeasurableSet s ∧ γ - (1 / 2) ^ n < d s :=\n    by\n    intro n\n    have : γ - (1 / 2) ^ n < γ := sub_lt_self γ (pow_pos (half_pos zero_lt_one) n)\n    rcases exists_lt_of_lt_csupₛ c_nonempty this with ⟨r, ⟨s, hs, rfl⟩, hlt⟩\n    exact ⟨s, hs, hlt⟩\n  rcases classical.axiom_of_choice this with ⟨e, he⟩\n  change ℕ → Set α at e\n  have he₁ : ∀ n, MeasurableSet (e n) := fun n => (he n).1\n  have he₂ : ∀ n, γ - (1 / 2) ^ n < d (e n) := fun n => (he n).2\n  let f : ℕ → ℕ → Set α := fun n m => (Finset.Ico n (m + 1)).inf e\n  have hf : ∀ n m, MeasurableSet (f n m) := by\n    intro n m\n    simp only [f, Finset.inf_eq_infᵢ]\n    exact MeasurableSet.binterᵢ (to_countable _) fun i _ => he₁ _\n  have f_subset_f : ∀ {a b c d}, a ≤ b → c ≤ d → f a d ⊆ f b c :=\n    by\n    intro a b c d hab hcd\n    dsimp only [f]\n    rw [Finset.inf_eq_infᵢ, Finset.inf_eq_infᵢ]\n    exact bInter_subset_bInter_left (Finset.Ico_subset_Ico hab <| nat.succ_le_succ hcd)\n  have f_succ : ∀ n m, n ≤ m → f n (m + 1) = f n m ∩ e (m + 1) :=\n    by\n    intro n m hnm\n    have : n ≤ m + 1 := le_of_lt (nat.succ_le_succ hnm)\n    simp only [f]\n    rw [Nat.Ico_succ_right_eq_insert_Ico this, Finset.inf_insert, Set.inter_comm]\n    rfl\n  have le_d_f : ∀ n m, m ≤ n → γ - 2 * (1 / 2) ^ m + (1 / 2) ^ n ≤ d (f m n) :=\n    by\n    intro n m h\n    refine' Nat.le_induction _ _ n h\n    · have := he₂ m\n      simp only [f]\n      rw [Nat.Ico_succ_singleton, Finset.inf_singleton]\n      linarith\n    · intro n(hmn : m ≤ n)ih\n      have : γ + (γ - 2 * (1 / 2) ^ m + (1 / 2) ^ (n + 1)) ≤ γ + d (f m (n + 1)) := by\n        calc\n          γ + (γ - 2 * (1 / 2) ^ m + (1 / 2) ^ (n + 1)) ≤\n              γ + (γ - 2 * (1 / 2) ^ m + ((1 / 2) ^ n - (1 / 2) ^ (n + 1))) :=\n            by\n            refine' add_le_add_left (add_le_add_left _ _) γ\n            simp only [pow_add, pow_one, le_sub_iff_add_le]\n            linarith\n          _ = γ - (1 / 2) ^ (n + 1) + (γ - 2 * (1 / 2) ^ m + (1 / 2) ^ n) := by simp only [sub_eq_add_neg] <;> abel\n          _ ≤ d (e (n + 1)) + d (f m n) := (add_le_add (le_of_lt <| he₂ _) ih)\n          _ ≤ d (e (n + 1)) + d (f m n \\ e (n + 1)) + d (f m (n + 1)) := by\n            rw [f_succ _ _ hmn, d_split (f m n) (e (n + 1)) (hf _ _) (he₁ _), add_assoc]\n          _ = d (e (n + 1) ∪ f m n) + d (f m (n + 1)) :=\n            by\n            rw [d_split (e (n + 1) ∪ f m n) (e (n + 1)), union_diff_left, union_inter_cancel_left]\n            abel\n            exact (he₁ _).union (hf _ _)\n            exact he₁ _\n          _ ≤ γ + d (f m (n + 1)) := add_le_add_right (d_le_γ _ <| (he₁ _).union (hf _ _)) _\n          \n      exact (add_le_add_iff_left γ).1 this\n  let s :=\n    «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n      («expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (f m n))\n  have γ_le_d_s : γ ≤ d s :=\n    by\n    have hγ : tendsto (fun m : ℕ => γ - 2 * (1 / 2) ^ m) at_top ((nhds) γ) :=\n      by\n      suffices tendsto (fun m : ℕ => γ - 2 * (1 / 2) ^ m) at_top ((nhds) (γ - 2 * 0)) by\n        simpa only [MulZeroClass.mul_zero, tsub_zero]\n      exact\n        tendsto_const_nhds.sub <|\n          tendsto_const_nhds.mul <|\n            tendsto_pow_atTop_nhds_0_of_lt_1 (le_of_lt <| half_pos <| zero_lt_one) (half_lt_self zero_lt_one)\n    have hd :\n      tendsto\n        (fun m =>\n          d («expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (f m n)))\n        at_top\n        ((nhds)\n          (d\n            («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n              («expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\"\n                (f m n))))) :=\n      by\n      refine' d_Union _ _\n      exact fun n m hnm => subset_Inter fun i => subset.trans (Inter_subset (f n) i) <| f_subset_f hnm <| le_rfl\n    refine' le_of_tendsto_of_tendsto' hγ hd fun m => _\n    have :\n      tendsto (fun n => d (f m n)) at_top\n        ((nhds)\n          (d\n            («expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\"\n              (f m n)))) :=\n      by\n      refine' d_Inter _ _ _\n      · intro n\n        exact hf _ _\n      · intro n m hnm\n        exact f_subset_f le_rfl hnm\n    refine' ge_of_tendsto this (eventually_at_top.2 ⟨m, fun n hmn => _⟩)\n    change γ - 2 * (1 / 2) ^ m ≤ d (f m n)\n    refine' le_trans _ (le_d_f _ _ hmn)\n    exact le_add_of_le_of_nonneg le_rfl (pow_nonneg (le_of_lt <| half_pos <| zero_lt_one) _)\n  have hs : MeasurableSet s := MeasurableSet.unionᵢ fun n => MeasurableSet.interᵢ fun m => hf _ _\n  refine' ⟨s, hs, _, _⟩\n  · intro t ht hts\n    have : 0 ≤ d t :=\n      (add_le_add_iff_left γ).1 <|\n        calc\n          γ + 0 ≤ d s := by rw [add_zero] <;> exact γ_le_d_s\n          _ = d (s \\ t) + d t := by rw [d_split _ _ hs ht, inter_eq_self_of_subset_right hts]\n          _ ≤ γ + d t := add_le_add (d_le_γ _ (hs.diff ht)) le_rfl\n          \n    rw [← to_nnreal_μ, ← to_nnreal_ν, ENNReal.coe_le_coe, ← NNReal.coe_le_coe]\n    simpa only [d, le_sub_iff_add_le, zero_add] using this\n  · intro t ht hts\n    have : d t ≤ 0 :=\n      (add_le_add_iff_left γ).1 <|\n        calc\n          γ + d t ≤ d s + d t := add_le_add γ_le_d_s le_rfl\n          _ = d (s ∪ t) := by\n            rw [d_split _ _ (hs.union ht) ht, union_diff_right, union_inter_cancel_right,\n              (subset_compl_iff_disjoint_left.1 hts).sdiff_eq_left]\n          _ ≤ γ + 0 := by rw [add_zero] <;> exact d_le_γ _ (hs.union ht)\n          \n    rw [← to_nnreal_μ, ← to_nnreal_ν, ENNReal.coe_le_coe, ← NNReal.coe_le_coe]\n    simpa only [d, sub_le_iff_le_add, zero_add] using this\n#align hahn_decomposition hahn_decomposition\n\n"}