{"zero_mem_measurable_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\ntheorem zero_mem_measurable_le : (0 : α → ennreal) ∈ measurable_le μ ν :=\n  ⟨measurable_zero, fun A hA => by simp⟩\n#align zero_mem_measurable_le zero_mem_measurable_le\n\n",
 "with_density_rn_deriv_le":
 "theorem with_density_rn_deriv_le (μ ν : Measure α) : ν.with_density (μ.rn_deriv ν) ≤ μ :=\n  by\n  by_cases hl : have_lebesgue_decomposition μ ν\n  · cases' (have_lebesgue_decomposition_spec μ ν).2 with _ h\n    conv_rhs => rw [h]\n    exact measure.le_add_left le_rfl\n  · rw [rn_deriv, dif_neg hl, with_density_zero]\n    exact measure.zero_le μ\n#align with_density_rn_deriv_le with_density_rn_deriv_le\n\n",
 "to_jordan_decomposition_eq_of_eq_add_with_density":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `vector_measure.mutually_singular -/\ntheorem to_jordan_decomposition_eq_of_eq_add_with_density {f : α → exprℝ} (hf : Measurable f) (hfi : integrable f μ)\n    (htμ : vector_measure.mutually_singular t μ.to_ennreal_vector_measure) (hadd : s = t + μ.with_densityᵥ f) :\n    s.to_jordan_decomposition =\n      @jordan_decomposition.mk α _ (t.to_jordan_decomposition.pos_part + μ.with_density fun x => ENNReal.ofReal (f x))\n        (t.to_jordan_decomposition.neg_part + μ.with_density fun x => ENNReal.ofReal (-f x))\n        (by\n          haveI := is_finite_measure_with_density_of_real hfi.2\n          infer_instance)\n        (by\n          haveI := is_finite_measure_with_density_of_real hfi.neg.2\n          infer_instance)\n        (jordan_decomposition_add_with_density_mutually_singular hf htμ) :=\n  by\n  haveI := is_finite_measure_with_density_of_real hfi.2\n  haveI := is_finite_measure_with_density_of_real hfi.neg.2\n  refine' to_jordan_decomposition_eq _\n  simp_rw [jordan_decomposition.to_signed_measure, hadd]\n  ext (i hi)\n  rw [vector_measure.sub_apply, to_signed_measure_apply_measurable hi, to_signed_measure_apply_measurable hi, add_apply,\n      add_apply, ENNReal.toReal_add, ENNReal.toReal_add, add_sub_add_comm, ← to_signed_measure_apply_measurable hi, ←\n      to_signed_measure_apply_measurable hi, ← vector_measure.sub_apply, ← jordan_decomposition.to_signed_measure,\n      to_signed_measure_to_jordan_decomposition, vector_measure.add_apply, ← to_signed_measure_apply_measurable hi, ←\n      to_signed_measure_apply_measurable hi, with_densityᵥ_eq_with_density_pos_part_sub_with_density_neg_part hfi,\n      vector_measure.sub_apply] <;>\n    exact (measure_lt_top _ _).ne\n#align to_jordan_decomposition_eq_of_eq_add_with_density to_jordan_decomposition_eq_of_eq_add_with_density\n\n",
 "supr_succ_eq_sup":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\ntheorem supr_succ_eq_sup {α} (f : ℕ → α → ennreal) (m : ℕ) (a : α) :\n    «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (f k a) =\n      «expr ⊔ » (f m.succ a)\n        («expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (f k a)) :=\n  by\n  ext x\n  simp only [Option.mem_def, ENNReal.some_eq_coe]\n  constructor <;> intro h <;> rw [← h]; symm\n  all_goals\n    set c :=\n      «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (f k a) with hc\n    set d :=\n      «expr ⊔ » (f m.succ a)\n        («expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (f k a)) with\n      hd\n    rw [@le_antisymm_iff (ennreal), hc, hd]\n    -- Specifying the type is weirdly necessary\n    refine' ⟨_, _⟩\n    · refine' supᵢ₂_le fun n hn => _\n      rcases Nat.of_le_succ hn with (h | h)\n      · exact le_sup_of_le_right (le_supᵢ₂ n h)\n      · exact h ▸ le_sup_left\n    · refine' sup_le _ (bsupᵢ_mono fun n hn => hn.trans m.le_succ)\n      convert@le_supᵢ₂ _ _ (fun i => i ≤ m + 1) _ _ m.succ le_rfl\n      rfl\n#align supr_succ_eq_sup supr_succ_eq_sup\n\n",
 "supr_monotone'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\ntheorem supr_monotone' {α : Type _} (f : ℕ → α → ennreal) (x : α) :\n    Monotone fun n =>\n      «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (f k x) :=\n  fun n m hnm => supr_monotone f hnm x\n#align supr_monotone' supr_monotone'\n\n",
 "supr_monotone":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n--TODO: these statements should be moved elsewhere\ntheorem supr_monotone {α : Type _} (f : ℕ → α → ennreal) :\n    Monotone fun n x =>\n      «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (f k x) :=\n  fun n m hnm x => bsupᵢ_mono fun i => ge_trans hnm\n#align supr_monotone supr_monotone\n\n",
 "supr_mem_measurable_le'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\ntheorem supr_mem_measurable_le' (f : ℕ → α → ennreal) (hf : ∀ n, f n ∈ measurable_le μ ν) (n : ℕ) :\n    «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (f k) ∈\n      measurable_le μ ν :=\n  by\n  convert supr_mem_measurable_le f hf n\n  ext; simp\n#align supr_mem_measurable_le' supr_mem_measurable_le'\n\n",
 "supr_mem_measurable_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\ntheorem supr_mem_measurable_le (f : ℕ → α → ennreal) (hf : ∀ n, f n ∈ measurable_le μ ν) (n : ℕ) :\n    (fun x => «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (f k x)) ∈\n      measurable_le μ ν :=\n  by\n  induction' n with m hm\n  · refine' ⟨_, _⟩\n    · simp [(hf 0).1]\n    · intro A hA\n      simp [(hf 0).2 A hA]\n  · have :\n      (fun a : α =>\n          «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (f k a)) =\n        fun a =>\n        «expr ⊔ » (f m.succ a)\n          («expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (f k a)) :=\n      funext fun _ => supr_succ_eq_sup _ _ _\n    refine' ⟨measurable_supr fun n => measurable.supr_Prop _ (hf n).1, fun A hA => _⟩\n    rw [this]\n    exact (sup_mem_measurable_le (hf m.succ) hm).2 A hA\n#align supr_mem_measurable_le supr_mem_measurable_le\n\n",
 "supr_le_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\ntheorem supr_le_le {α : Type _} (f : ℕ → α → ennreal) (n k : ℕ) (hk : k ≤ n) :\n    f k ≤ fun x =>\n      «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (f k x) :=\n  fun x => le_supᵢ₂ k hk\n#align supr_le_le supr_le_le\n\n",
 "sup_mem_measurable_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\ntheorem sup_mem_measurable_le {f g : α → ennreal} (hf : f ∈ measurable_le μ ν) (hg : g ∈ measurable_le μ ν) :\n    (fun a => «expr ⊔ » (f a) (g a)) ∈ measurable_le μ ν :=\n  by\n  simp_rw [ENNReal.sup_eq_max]\n  refine' ⟨measurable.max hf.1 hg.1, fun A hA => _⟩\n  have h₁ := hA.inter (measurable_set_le hf.1 hg.1)\n  have h₂ := hA.inter (measurable_set_lt hg.1 hf.1)\n  rw [set_lintegral_max hf.1 hg.1]\n  refine' (add_le_add (hg.2 _ h₁) (hf.2 _ h₂)).trans_eq _\n  · simp only [← not_le, ← compl_set_of, ← diff_eq]\n    exact measure_inter_add_diff _ (measurable_set_le hf.1 hg.1)\n#align sup_mem_measurable_le sup_mem_measurable_le\n\n",
 "singular_part_zero":
 "theorem singular_part_zero (μ : Measure α) : (0 : signed_measure α).singular_part μ = 0 :=\n  by\n  refine' (eq_singular_part 0 0 vector_measure.mutually_singular.zero_left _).symm\n  rw [zero_add, with_densityᵥ_zero]\n#align singular_part_zero singular_part_zero\n\n",
 "singular_part_with_density":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\ntheorem singular_part_with_density (ν : Measure α) {f : α → ennreal} (hf : Measurable f) :\n    (ν.with_density f).singular_part ν = 0 :=\n  haveI : ν.with_density f = 0 + ν.with_density f := by rw [zero_add]\n  (eq_singular_part hf mutually_singular.zero_left this).symm\n#align singular_part_with_density singular_part_with_density\n\n",
 "singular_part_total_variation":
 "theorem singular_part_total_variation (s : signed_measure α) (μ : Measure α) :\n    (s.singular_part μ).total_variation =\n      s.to_jordan_decomposition.pos_part.singular_part μ + s.to_jordan_decomposition.neg_part.singular_part μ :=\n  by\n  have :\n    (s.singular_part μ).to_jordan_decomposition =\n      ⟨s.to_jordan_decomposition.pos_part.singular_part μ, s.to_jordan_decomposition.neg_part.singular_part μ,\n        singular_part_mutually_singular s μ⟩ :=\n    by\n    refine' jordan_decomposition.to_signed_measure_injective _\n    rw [to_signed_measure_to_jordan_decomposition]\n    rfl\n  · rw [total_variation, this]\n#align singular_part_total_variation singular_part_total_variation\n\n",
 "singular_part_sub":
 "theorem singular_part_sub (s t : signed_measure α) (μ : Measure α) [s.have_lebesgue_decomposition μ]\n    [t.have_lebesgue_decomposition μ] : (s - t).singular_part μ = s.singular_part μ - t.singular_part μ := by\n  rw [sub_eq_add_neg, sub_eq_add_neg, singular_part_add, singular_part_neg]\n#align singular_part_sub singular_part_sub\n\n",
 "singular_part_smul_nnreal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem singular_part_smul_nnreal (s : signed_measure α) (μ : Measure α) (r : nnreal) :\n    («expr • » r s).singular_part μ = «expr • » r (s.singular_part μ) :=\n  by\n  rw [singular_part, singular_part, smul_sub, ← to_signed_measure_smul, ← to_signed_measure_smul]\n  conv_lhs =>\n    congr\n    congr\n    rw [to_jordan_decomposition_smul, jordan_decomposition.smul_pos_part, singular_part_smul]\n    skip\n    congr\n    rw [to_jordan_decomposition_smul, jordan_decomposition.smul_neg_part, singular_part_smul]\n#align singular_part_smul_nnreal singular_part_smul_nnreal\n\n",
 "singular_part_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem singular_part_smul (s : signed_measure α) (μ : Measure α) (r : exprℝ) :\n    («expr • » r s).singular_part μ = «expr • » r (s.singular_part μ) :=\n  by\n  by_cases hr : 0 ≤ r\n  · lift r to nnreal using hr\n    exact singular_part_smul_nnreal s μ r\n  · rw [singular_part, singular_part]\n    conv_lhs =>\n      congr\n      congr\n      rw [to_jordan_decomposition_smul_real, jordan_decomposition.real_smul_pos_part_neg _ _ (not_le.1 hr),\n        singular_part_smul]\n      skip\n      congr\n      rw [to_jordan_decomposition_smul_real, jordan_decomposition.real_smul_neg_part_neg _ _ (not_le.1 hr),\n        singular_part_smul]\n    rw [to_signed_measure_smul, to_signed_measure_smul, ← neg_sub, ← smul_sub]\n    change -«expr • » ((-r).to_nnreal : exprℝ) _ = _\n    rw [← neg_smul, Real.coe_toNNReal _ (le_of_lt (neg_pos.mpr (not_le.1 hr))), neg_neg]\n#align singular_part_smul singular_part_smul\n\n",
 "singular_part_neg":
 "theorem singular_part_neg (s : signed_measure α) (μ : Measure α) : (-s).singular_part μ = -s.singular_part μ :=\n  by\n  have h₁ :\n    ((-s).to_jordan_decomposition.pos_part.singular_part μ).to_signed_measure =\n      (s.to_jordan_decomposition.neg_part.singular_part μ).to_signed_measure :=\n    by\n    refine' to_signed_measure_congr _\n    rw [to_jordan_decomposition_neg, jordan_decomposition.neg_pos_part]\n  have h₂ :\n    ((-s).to_jordan_decomposition.neg_part.singular_part μ).to_signed_measure =\n      (s.to_jordan_decomposition.pos_part.singular_part μ).to_signed_measure :=\n    by\n    refine' to_signed_measure_congr _\n    rw [to_jordan_decomposition_neg, jordan_decomposition.neg_neg_part]\n  rw [singular_part, singular_part, neg_sub, h₁, h₂]\n#align singular_part_neg singular_part_neg\n\n",
 "singular_part_mutually_singular":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure.mutually_singular -/\n-- `infer_instance` directly does not work\n-- see Note [lower instance priority]\ntheorem singular_part_mutually_singular (s : signed_measure α) (μ : Measure α) :\n    measure.mutually_singular (s.to_jordan_decomposition.pos_part.singular_part μ)\n      (s.to_jordan_decomposition.neg_part.singular_part μ) :=\n  by\n  by_cases hl : s.have_lebesgue_decomposition μ\n  · haveI := hl\n    obtain ⟨i, hi, hpos, hneg⟩ := s.to_jordan_decomposition.mutually_singular\n    rw [s.to_jordan_decomposition.pos_part.have_lebesgue_decomposition_add μ] at hpos\n    rw [s.to_jordan_decomposition.neg_part.have_lebesgue_decomposition_add μ] at hneg\n    rw [add_apply, add_eq_zero_iff] at hpos hneg\n    exact ⟨i, hi, hpos.1, hneg.1⟩\n  · rw [not_have_lebesgue_decomposition_iff] at hl\n    cases' hl with hp hn\n    · rw [measure.singular_part, dif_neg hp]\n      exact mutually_singular.zero_left\n    · rw [measure.singular_part, measure.singular_part, dif_neg hn]\n      exact mutually_singular.zero_right\n#align singular_part_mutually_singular singular_part_mutually_singular\n\n",
 "singular_part_le":
 "theorem singular_part_le (μ ν : Measure α) : μ.singular_part ν ≤ μ :=\n  by\n  by_cases hl : have_lebesgue_decomposition μ ν\n  · cases' (have_lebesgue_decomposition_spec μ ν).2 with _ h\n    conv_rhs => rw [h]\n    exact measure.le_add_right le_rfl\n  · rw [singular_part, dif_neg hl]\n    exact measure.zero_le μ\n#align singular_part_le singular_part_le\n\n",
 "singular_part_add_with_density_rn_deriv_eq":
 "theorem singular_part_add_with_density_rn_deriv_eq [c.have_lebesgue_decomposition μ] :\n    c.singular_part μ + μ.with_densityᵥ (c.rn_deriv μ) = c :=\n  by\n  conv_rhs => rw [← c.to_complex_measure_to_signed_measure]\n  ext (i hi) : 1\n  rw [vector_measure.add_apply, signed_measure.to_complex_measure_apply]\n  ext\n  · rw [Complex.add_re, with_densityᵥ_apply (c.integrable_rn_deriv μ) hi, ← is_R_or_C.re_eq_complex_re, ←\n      integral_re (c.integrable_rn_deriv μ).integrable_on, is_R_or_C.re_eq_complex_re, ← with_densityᵥ_apply _ hi]\n    · change (c.re.singular_part μ + μ.with_densityᵥ (c.re.rn_deriv μ)) i = _\n      rw [c.re.singular_part_add_with_density_rn_deriv_eq μ]\n    · exact signed_measure.integrable_rn_deriv _ _\n  · rw [Complex.add_im, with_densityᵥ_apply (c.integrable_rn_deriv μ) hi, ← is_R_or_C.im_eq_complex_im, ←\n      integral_im (c.integrable_rn_deriv μ).integrable_on, is_R_or_C.im_eq_complex_im, ← with_densityᵥ_apply _ hi]\n    · change (c.im.singular_part μ + μ.with_densityᵥ (c.im.rn_deriv μ)) i = _\n      rw [c.im.singular_part_add_with_density_rn_deriv_eq μ]\n    · exact signed_measure.integrable_rn_deriv _ _\n#align singular_part_add_with_density_rn_deriv_eq singular_part_add_with_density_rn_deriv_eq\n\n",
 "singular_part_add":
 "theorem singular_part_add (s t : signed_measure α) (μ : Measure α) [s.have_lebesgue_decomposition μ]\n    [t.have_lebesgue_decomposition μ] : (s + t).singular_part μ = s.singular_part μ + t.singular_part μ :=\n  by\n  refine'\n    (eq_singular_part _ (s.rn_deriv μ + t.rn_deriv μ)\n        ((mutually_singular_singular_part s μ).add_left (mutually_singular_singular_part t μ)) _).symm\n  erw [with_densityᵥ_add (integrable_rn_deriv s μ) (integrable_rn_deriv t μ)]\n  rw [add_assoc, add_comm (t.singular_part μ), add_assoc, add_comm _ (t.singular_part μ),\n    singular_part_add_with_density_rn_deriv_eq, ← add_assoc, singular_part_add_with_density_rn_deriv_eq]\n#align singular_part_add singular_part_add\n\n",
 "rn_deriv_with_density":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\n/-- The Radon-Nikodym derivative of `f ν` with respect to `ν` is `f`. -/\ntheorem rn_deriv_with_density (ν : Measure α) [SigmaFinite ν] {f : α → ennreal} (hf : Measurable f) :\n    «expr =ᵐ[ ] » ((ν.with_density f).rn_deriv ν) ν f :=\n  haveI : ν.with_density f = 0 + ν.with_density f := by rw [zero_add]\n  (eq_rn_deriv hf mutually_singular.zero_left this).symm\n#align rn_deriv_with_density rn_deriv_with_density\n\n",
 "rn_deriv_sub":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\ntheorem rn_deriv_sub (s t : signed_measure α) (μ : Measure α) [s.have_lebesgue_decomposition μ]\n    [t.have_lebesgue_decomposition μ] [hst : (s - t).have_lebesgue_decomposition μ] :\n    «expr =ᵐ[ ] » ((s - t).rn_deriv μ) μ (s.rn_deriv μ - t.rn_deriv μ) :=\n  by\n  rw [sub_eq_add_neg] at hst\n  rw [sub_eq_add_neg, sub_eq_add_neg]\n  exact ae_eq_trans (rn_deriv_add _ _ _) (Filter.EventuallyEq.add (ae_eq_refl _) (rn_deriv_neg _ _))\n#align rn_deriv_sub rn_deriv_sub\n\n",
 "rn_deriv_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem rn_deriv_smul (s : signed_measure α) (μ : Measure α) [s.have_lebesgue_decomposition μ] (r : exprℝ) :\n    «expr =ᵐ[ ] » ((«expr • » r s).rn_deriv μ) μ («expr • » r (s.rn_deriv μ)) :=\n  by\n  refine' integrable.ae_eq_of_with_densityᵥ_eq (integrable_rn_deriv _ _) ((integrable_rn_deriv _ _).smul r) _\n  change _ = μ.with_densityᵥ («expr • » (r : exprℝ) (s.rn_deriv μ))\n  rw [with_densityᵥ_smul (rn_deriv s μ) (r : exprℝ), ← add_right_inj ((«expr • » r s).singular_part μ),\n    singular_part_add_with_density_rn_deriv_eq, singular_part_smul]\n  change _ = _ + «expr • » r _\n  rw [← smul_add, singular_part_add_with_density_rn_deriv_eq]\n#align rn_deriv_smul rn_deriv_smul\n\n",
 "rn_deriv_restrict":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\n/-- The Radon-Nikodym derivative of the restriction of a measure to a measurable set is the\nindicator function of this set. -/\ntheorem rn_deriv_restrict (ν : Measure α) [SigmaFinite ν] {s : Set α} (hs : MeasurableSet s) :\n    «expr =ᵐ[ ] » ((ν.restrict s).rn_deriv ν) ν (s.indicator 1) :=\n  by\n  rw [← with_density_indicator_one hs]\n  exact rn_deriv_with_density _ (measurable_one.indicator hs)\n#align rn_deriv_restrict rn_deriv_restrict\n\n",
 "rn_deriv_neg":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\ntheorem rn_deriv_neg (s : signed_measure α) (μ : Measure α) [s.have_lebesgue_decomposition μ] :\n    «expr =ᵐ[ ] » ((-s).rn_deriv μ) μ (-s.rn_deriv μ) :=\n  by\n  refine' integrable.ae_eq_of_with_densityᵥ_eq (integrable_rn_deriv _ _) (integrable_rn_deriv _ _).neg _\n  rw [with_densityᵥ_neg, ← add_right_inj ((-s).singular_part μ), singular_part_add_with_density_rn_deriv_eq,\n    singular_part_neg, ← neg_add, singular_part_add_with_density_rn_deriv_eq]\n#align rn_deriv_neg rn_deriv_neg\n\n",
 "rn_deriv_lt_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/-- The Radon-Nikodym derivative of a sigma-finite measure `μ` with respect to another\nmeasure `ν` is `ν`-almost everywhere finite. -/\ntheorem rn_deriv_lt_top (μ ν : Measure α) [SigmaFinite μ] :\n    «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\" ν\n      (μ.rn_deriv ν x < ennreal.top) :=\n  by\n  suffices\n    ∀ n,\n      «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\" ν\n        (x ∈ spanning_sets μ n → μ.rn_deriv ν x < ennreal.top)\n    by filter_upwards [ae_all_iff.2 this]with _ hx using hx _ (mem_spanning_sets_index _ _)\n  intro n\n  rw [← ae_restrict_iff' (measurable_spanning_sets _ _)]\n  apply ae_lt_top (measurable_rn_deriv _ _)\n  refine' (lintegral_rn_deriv_lt_top_of_measure_ne_top _ _).ne\n  exact (measure_spanning_sets_lt_top _ _).ne\n#align rn_deriv_lt_top rn_deriv_lt_top\n\n",
 "rn_deriv_add":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\ntheorem rn_deriv_add (s t : signed_measure α) (μ : Measure α) [s.have_lebesgue_decomposition μ]\n    [t.have_lebesgue_decomposition μ] [(s + t).have_lebesgue_decomposition μ] :\n    «expr =ᵐ[ ] » ((s + t).rn_deriv μ) μ (s.rn_deriv μ + t.rn_deriv μ) :=\n  by\n  refine'\n    integrable.ae_eq_of_with_densityᵥ_eq (integrable_rn_deriv _ _)\n      ((integrable_rn_deriv _ _).add (integrable_rn_deriv _ _)) _\n  rw [← add_right_inj ((s + t).singular_part μ), singular_part_add_with_density_rn_deriv_eq,\n    with_densityᵥ_add (integrable_rn_deriv _ _) (integrable_rn_deriv _ _), singular_part_add, add_assoc,\n    add_comm (t.singular_part μ), add_assoc, add_comm _ (t.singular_part μ), singular_part_add_with_density_rn_deriv_eq,\n    ← add_assoc, singular_part_add_with_density_rn_deriv_eq]\n#align rn_deriv_add rn_deriv_add\n\n",
 "not_have_lebesgue_decomposition_iff":
 "-- see Note [lower instance priority]\n-- Since `μ` and `ν` are both σ-finite, there exists a sequence of pairwise disjoint spanning\n-- sets which are finite with respect to both `μ` and `ν`\n-- We define `μn` and `νn` as sequences of measures such that `μn n = μ ∩ S n` and\n-- `νn n = ν ∩ S n` where `S` is the aforementioned finite spanning set sequence.\n-- Since `S` is spanning, it is clear that `sum μn = μ` and `sum νn = ν`\n-- As `S` is finite with respect to both `μ` and `ν`, it is clear that `μn n` and `νn n` are\n-- finite measures for all `n : ℕ`. Thus, we may apply the finite Lebesgue decomposition theorem\n-- to `μn n` and `νn n`. We define `ξ` as the sum of the singular part of the Lebesgue\n-- decompositions of `μn n` and `νn n`, and `f` as the sum of the Radon-Nikodym derviatives of\n-- `μn n` and `νn n` restricted on `S n`\n-- I claim `ξ` and `f` form a Lebesgue decomposition of `μ` and `ν`\n-- We show that `ξ` is mutually singular with respect to `ν`\n-- We use the set `B := ⋃ j, (S.set j) ∩ A j` where `A n` is the set provided as\n-- `singular_part (μn n) (νn n) ⟂ₘ νn n`\n-- `ξ B = 0` since `ξ B = ∑ i j, singular_part (μn j) (νn j) (S.set i ∩ A i)`\n--                     `= ∑ i, singular_part (μn i) (νn i) (S.set i ∩ A i)`\n--                     `≤ ∑ i, singular_part (μn i) (νn i) (A i) = 0`\n-- where the second equality follows as `singular_part (μn j) (νn j) (S.set i ∩ A i)` vanishes\n-- for all `i ≠ j`\n-- We will now show `ν Bᶜ = 0`. This follows since `Bᶜ = ⋃ n, S.set n ∩ (A n)ᶜ` and thus,\n-- `ν Bᶜ = ∑ i, ν (S.set i ∩ (A i)ᶜ) = ∑ i, (νn i) (A i)ᶜ = 0`\n-- Finally, it remains to show `μ = ξ + ν.with_density f`. Since `μ = sum μn`, and\n-- `ξ + ν.with_density f = ∑ n, singular_part (μn n) (νn n)`\n--                        `+ ν.with_density (rn_deriv (μn n) (νn n)) ∩ (S.set n)`,\n-- it suffices to show that the individual summands are equal. This follows by the\n-- Lebesgue decomposition properties on the individual `μn n` and `νn n`\ntheorem not_have_lebesgue_decomposition_iff (s : signed_measure α) (μ : Measure α) :\n    ¬s.have_lebesgue_decomposition μ ↔\n      ¬s.to_jordan_decomposition.pos_part.have_lebesgue_decomposition μ ∨\n        ¬s.to_jordan_decomposition.neg_part.have_lebesgue_decomposition μ :=\n  ⟨fun h => not_or_of_imp fun hp hn => h ⟨hp, hn⟩, fun h hl => (not_and_or.2 h) ⟨hl.1, hl.2⟩⟩\n#align not_have_lebesgue_decomposition_iff not_have_lebesgue_decomposition_iff\n\n",
 "mutually_singular_singular_part":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure.mutually_singular -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `vector_measure.mutually_singular -/\ntheorem mutually_singular_singular_part (s : signed_measure α) (μ : Measure α) :\n    vector_measure.mutually_singular (singular_part s μ) μ.to_ennreal_vector_measure :=\n  by\n  rw [mutually_singular_ennreal_iff, singular_part_total_variation]\n  change measure.mutually_singular _ (vector_measure.equiv_measure.to_fun (vector_measure.equiv_measure.inv_fun μ))\n  rw [vector_measure.equiv_measure.right_inv μ]\n  exact (mutually_singular_singular_part _ _).add_left (mutually_singular_singular_part _ _)\n#align mutually_singular_singular_part mutually_singular_singular_part\n\n",
 "measurable_rn_deriv":
 "@[measurability]\ntheorem measurable_rn_deriv (s : signed_measure α) (μ : Measure α) : Measurable (rn_deriv s μ) :=\n  by\n  rw [rn_deriv]\n  measurability\n#align measurable_rn_deriv measurable_rn_deriv\n\n",
 "lintegral_rn_deriv_lt_top_of_measure_ne_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫⁻ in , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ in , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫⁻ in , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ in , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\ntheorem lintegral_rn_deriv_lt_top_of_measure_ne_top {μ : Measure α} (ν : Measure α) {s : Set α}\n    (hs : μ s ≠ ennreal.top) :\n    «expr∫⁻ in , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ in , ∂ »\" s\n        (μ.rn_deriv ν x) ν <\n      ennreal.top :=\n  by\n  by_cases hl : have_lebesgue_decomposition μ ν\n  · haveI := hl\n    obtain ⟨-, -, hadd⟩ := have_lebesgue_decomposition_spec μ ν\n    suffices :\n      «expr∫⁻ in , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ in , ∂ »\"\n          (to_measurable μ s) (μ.rn_deriv ν x) ν <\n        ennreal.top\n    exact lt_of_le_of_lt (lintegral_mono_set (subset_to_measurable _ _)) this\n    rw [← with_density_apply _ (measurable_set_to_measurable _ _)]\n    refine'\n      lt_of_le_of_lt\n        (le_add_left le_rfl :\n          _ ≤ μ.singular_part ν (to_measurable μ s) + ν.with_density (μ.rn_deriv ν) (to_measurable μ s))\n        _\n    rw [← measure.add_apply, ← hadd, measure_to_measurable]\n    exact hs.lt_top\n  · erw [measure.rn_deriv, dif_neg hl, lintegral_zero]\n    exact WithTop.zero_lt_top\n#align lintegral_rn_deriv_lt_top_of_measure_ne_top lintegral_rn_deriv_lt_top_of_measure_ne_top\n\n",
 "lintegral_rn_deriv_lt_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫⁻ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\ntheorem lintegral_rn_deriv_lt_top (μ ν : Measure α) [FiniteMeasure μ] :\n    «expr∫⁻ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ , ∂ »\"\n        (μ.rn_deriv ν x) ν <\n      ennreal.top :=\n  by\n  rw [← set_lintegral_univ]\n  exact lintegral_rn_deriv_lt_top_of_measure_ne_top _ (measure_lt_top _ _).ne\n#align lintegral_rn_deriv_lt_top lintegral_rn_deriv_lt_top\n\n",
 "jordan_decomposition_add_with_density_mutually_singular":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure.mutually_singular -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure.mutually_singular -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `vector_measure.mutually_singular -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure.mutually_singular -/\ntheorem jordan_decomposition_add_with_density_mutually_singular {f : α → exprℝ} (hf : Measurable f)\n    (htμ : vector_measure.mutually_singular t μ.to_ennreal_vector_measure) :\n    measure.mutually_singular (t.to_jordan_decomposition.pos_part + μ.with_density fun x : α => ENNReal.ofReal (f x))\n      (t.to_jordan_decomposition.neg_part + μ.with_density fun x : α => ENNReal.ofReal (-f x)) :=\n  by\n  rw [mutually_singular_ennreal_iff, total_variation_mutually_singular_iff] at htμ\n  change\n    measure.mutually_singular _ (vector_measure.equiv_measure.to_fun (vector_measure.equiv_measure.inv_fun μ)) ∧\n      measure.mutually_singular _ (vector_measure.equiv_measure.to_fun (vector_measure.equiv_measure.inv_fun μ)) at\n    htμ\n  rw [vector_measure.equiv_measure.right_inv] at htμ\n  exact\n    ((jordan_decomposition.mutually_singular _).add_right\n          (htμ.1.mono_ac (refl _) (with_density_absolutely_continuous _ _))).add_left\n      ((htμ.2.symm.mono_ac (with_density_absolutely_continuous _ _) (refl _)).add_right\n        (with_density_of_real_mutually_singular hf))\n#align jordan_decomposition_add_with_density_mutually_singular jordan_decomposition_add_with_density_mutually_singular\n\n",
 "integrable_rn_deriv":
 "theorem integrable_rn_deriv (c : complex_measure α) (μ : Measure α) : integrable (c.rn_deriv μ) μ :=\n  by\n  rw [← mem_ℒp_one_iff_integrable, ← mem_ℒp_re_im_iff]\n  exact\n    ⟨mem_ℒp_one_iff_integrable.2 (signed_measure.integrable_rn_deriv _ _),\n      mem_ℒp_one_iff_integrable.2 (signed_measure.integrable_rn_deriv _ _)⟩\n#align integrable_rn_deriv integrable_rn_deriv\n\n",
 "have_lebesgue_decomposition_spec":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure.mutually_singular -/\n/-\nCopyright (c) 2021 Kexing Ying. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Kexing Ying\n-/\ntheorem have_lebesgue_decomposition_spec (μ ν : Measure α) [h : have_lebesgue_decomposition μ ν] :\n    Measurable (μ.rn_deriv ν) ∧\n      measure.mutually_singular (μ.singular_part ν) ν ∧ μ = μ.singular_part ν + ν.with_density (μ.rn_deriv ν) :=\n  by\n  rw [singular_part, rn_deriv, dif_pos h, dif_pos h]\n  exact Classical.choose_spec h.lebesgue_decomposition\n#align have_lebesgue_decomposition_spec have_lebesgue_decomposition_spec\n\n",
 "have_lebesgue_decomposition_of_finite_measure":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫⁻ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫⁻ in , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ in , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫⁻ in , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ in , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫⁻ in , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ in , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫⁻ in , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ in , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫⁻ in , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ in , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫⁻ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ , ∂ » -/\n/-- Any pair of finite measures `μ` and `ν`, `have_lebesgue_decomposition`. That is to say,\nthere exist a measure `ξ` and a measurable function `f`, such that `ξ` is mutually singular\nwith respect to `ν` and `μ = ξ + ν.with_density f`.\n\nThis is not an instance since this is also shown for the more general σ-finite measures with\n`measure_theory.measure.have_lebesgue_decomposition_of_sigma_finite`. -/\ntheorem have_lebesgue_decomposition_of_finite_measure [FiniteMeasure μ] [FiniteMeasure ν] :\n    have_lebesgue_decomposition μ ν :=\n  ⟨by\n    have h :=\n      @exists_seq_tendsto_supₛ _ _ _ _ _ (measurable_le_eval ν μ) ⟨0, 0, zero_mem_measurable_le, by simp⟩\n        (OrderTop.bddAbove _)\n    choose g hmono hg₂ f hf₁ hf₂ using h\n    -- we set `ξ` to be the supremum of an increasing sequence of functions obtained from above\n    set ξ := «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (f k) with\n      hξ\n    -- we see that `ξ` has the largest integral among all functions in `measurable_le`\n    have hξ₁ :\n      Sup (measurable_le_eval ν μ) =\n        «expr∫⁻ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ , ∂ »\" (ξ a) ν :=\n      by\n      have :=\n        @lintegral_tendsto_of_tendsto_of_monotone _ _ ν\n          (fun n =>\n            «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (f k))\n          («expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (f k)) _ _ _\n      · refine' tendsto_nhds_unique _ this\n        refine' tendsto_of_tendsto_of_tendsto_of_le_of_le hg₂ tendsto_const_nhds _ _\n        · intro n\n          rw [← hf₂ n]\n          apply lintegral_mono\n          simp only [supᵢ_apply, supr_le_le f n n le_rfl]\n        · intro n\n          exact\n            le_supₛ\n              ⟨«expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (f k),\n                supr_mem_measurable_le' _ hf₁ _, rfl⟩\n      · intro n\n        refine' Measurable.aemeasurable _\n        convert(supr_mem_measurable_le _ hf₁ n).1\n        ext\n        simp\n      · refine' Filter.eventually_of_forall fun a => _\n        simp [supr_monotone' f _]\n      · refine' Filter.eventually_of_forall fun a => _\n        simp [tendsto_atTop_supᵢ (supr_monotone' f a)]\n    have hξm : Measurable ξ :=\n      by\n      convert measurable_supr fun n => (supr_mem_measurable_le _ hf₁ n).1\n      ext\n      simp [hξ]\n    -- `ξ` is the `f` in the theorem statement and we set `μ₁` to be `μ - ν.with_density ξ`\n    -- since we need `μ₁ + ν.with_density ξ = μ`\n    set μ₁ := μ - ν.with_density ξ with hμ₁\n    have hle : ν.with_density ξ ≤ μ := by\n      intro B hB\n      rw [hξ, with_density_apply _ hB]\n      simp_rw [supᵢ_apply]\n      rw [lintegral_supr (fun i => (supr_mem_measurable_le _ hf₁ i).1) (supr_monotone _)]\n      exact supᵢ_le fun i => (supr_mem_measurable_le _ hf₁ i).2 B hB\n    have : is_finite_measure (ν.with_density ξ) :=\n      by\n      refine' is_finite_measure_with_density _\n      have hle' := hle univ MeasurableSet.univ\n      rw [with_density_apply _ MeasurableSet.univ, measure.restrict_univ] at hle'\n      exact ne_top_of_le_ne_top (measure_ne_top _ _) hle'\n    refine' ⟨⟨μ₁, ξ⟩, hξm, _, _⟩\n    · by_contra\n      -- if they are not mutually singular, then from `exists_positive_of_not_mutually_singular`,\n      -- there exists some `ε > 0` and a measurable set `E`, such that `μ(E) > 0` and `E` is\n      -- positive with respect to `ν - εμ`\n      obtain ⟨ε, hε₁, E, hE₁, hE₂, hE₃⟩ := exists_positive_of_not_mutually_singular μ₁ ν h\n      simp_rw [hμ₁] at hE₃\n      have hξle :\n        ∀ A,\n          MeasurableSet A →\n            «expr∫⁻ in , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ in , ∂ »\"\n                A (ξ a) ν ≤\n              μ A :=\n        by\n        intro A hA\n        rw [hξ]\n        simp_rw [supᵢ_apply]\n        rw [lintegral_supr (fun n => (supr_mem_measurable_le _ hf₁ n).1) (supr_monotone _)]\n        exact supᵢ_le fun n => (supr_mem_measurable_le _ hf₁ n).2 A hA\n      -- since `E` is positive, we have `∫⁻ a in A ∩ E, ε + ξ a ∂ν ≤ μ (A ∩ E)` for all `A`\n      have hε₂ :\n        ∀ A : Set α,\n          MeasurableSet A →\n            «expr∫⁻ in , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ in , ∂ »\"\n                (A ∩ E) (ε + ξ a) ν ≤\n              μ (A ∩ E) :=\n        by\n        intro A hA\n        have := subset_le_of_restrict_le_restrict _ _ hE₁ hE₃ (inter_subset_right A E)\n        rwa [zero_apply, to_signed_measure_sub_apply (hA.inter hE₁), measure.sub_apply (hA.inter hE₁) hle,\n          ENNReal.toReal_sub_of_le _ (ne_of_lt (measure_lt_top _ _)), sub_nonneg, le_sub_iff_add_le, ←\n          ENNReal.toReal_add, ENNReal.toReal_le_toReal, measure.coe_smul, Pi.smul_apply,\n          with_density_apply _ (hA.inter hE₁), show «expr • » ε (ν (A ∩ E)) = (ε : ennreal) * ν (A ∩ E) by rfl, ←\n          set_lintegral_const, ← lintegral_add_left measurable_const] at this\n        · rw [ne.def, ENNReal.add_eq_top, not_or]\n          exact ⟨ne_of_lt (measure_lt_top _ _), ne_of_lt (measure_lt_top _ _)⟩\n        · exact ne_of_lt (measure_lt_top _ _)\n        · exact ne_of_lt (measure_lt_top _ _)\n        · exact ne_of_lt (measure_lt_top _ _)\n        · rw [with_density_apply _ (hA.inter hE₁)]\n          exact hξle (A ∩ E) (hA.inter hE₁)\n        · infer_instance\n      -- from this, we can show `ξ + ε * E.indicator` is a function in `measurable_le` with\n      -- integral greater than `ξ`\n      have hξε : (ξ + E.indicator fun _ => ε) ∈ measurable_le ν μ :=\n        by\n        refine' ⟨Measurable.add hξm (Measurable.indicator measurable_const hE₁), fun A hA => _⟩\n        have :\n          «expr∫⁻ in , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ in , ∂ »\" A\n              ((ξ + E.indicator fun _ => ε) a) ν =\n            «expr∫⁻ in , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ in , ∂ »\"\n                (A ∩ E) (ε + ξ a) ν +\n              «expr∫⁻ in , ∂ »\n                \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ in , ∂ »\" (A \\ E) (ξ a)\n                ν :=\n          by\n          simp only [lintegral_add_left measurable_const, lintegral_add_left hξm, set_lintegral_const, add_assoc,\n            lintegral_inter_add_diff _ _ hE₁, Pi.add_apply, lintegral_indicator _ hE₁, restrict_apply hE₁]\n          rw [inter_comm, add_comm]\n        rw [this, ← measure_inter_add_diff A hE₁]\n        exact add_le_add (hε₂ A hA) (hξle (A \\ E) (hA.diff hE₁))\n      have :\n        «expr∫⁻ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ , ∂ »\"\n            (ξ a + E.indicator (fun _ => ε) a) ν ≤\n          Sup (measurable_le_eval ν μ) :=\n        le_supₛ ⟨ξ + E.indicator fun _ => ε, hξε, rfl⟩\n      -- but this contradicts the maximality of `∫⁻ x, ξ x ∂ν`\n      refine' not_lt.2 this _\n      rw [hξ₁, lintegral_add_left hξm, lintegral_indicator _ hE₁, set_lintegral_const]\n      refine' ENNReal.lt_add_right _ (ENNReal.mul_pos_iff.2 ⟨ENNReal.coe_pos.2 hε₁, hE₂⟩).ne'\n      have := measure_ne_top (ν.with_density ξ) univ\n      rwa [with_density_apply _ MeasurableSet.univ, measure.restrict_univ] at this\n    -- since `ν.with_density ξ ≤ μ`, it is clear that `μ = μ₁ + ν.with_density ξ`\n    · rw [hμ₁]\n      ext1 A hA\n      rw [measure.coe_add, Pi.add_apply, measure.sub_apply hA hle, add_comm, add_tsub_cancel_of_le (hle A hA)]⟩\n#align have_lebesgue_decomposition_of_finite_measure have_lebesgue_decomposition_of_finite_measure\n\n",
 "have_lebesgue_decomposition_mk'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure.mutually_singular -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `vector_measure.mutually_singular -/\nprivate theorem have_lebesgue_decomposition_mk' (μ : Measure α) {f : α → exprℝ} (hf : Measurable f)\n    (hfi : integrable f μ) (htμ : vector_measure.mutually_singular t μ.to_ennreal_vector_measure)\n    (hadd : s = t + μ.with_densityᵥ f) : s.have_lebesgue_decomposition μ :=\n  by\n  have htμ' := htμ\n  rw [mutually_singular_ennreal_iff] at htμ\n  change measure.mutually_singular _ (vector_measure.equiv_measure.to_fun (vector_measure.equiv_measure.inv_fun μ)) at\n    htμ\n  rw [vector_measure.equiv_measure.right_inv, total_variation_mutually_singular_iff] at htμ\n  refine'\n    { pos_part := by\n        use ⟨t.to_jordan_decomposition.pos_part, fun x => ENNReal.ofReal (f x)⟩\n        refine' ⟨hf.ennreal_of_real, htμ.1, _⟩\n        rw [to_jordan_decomposition_eq_of_eq_add_with_density hf hfi htμ' hadd]\n      neg_part := by\n        use ⟨t.to_jordan_decomposition.neg_part, fun x => ENNReal.ofReal (-f x)⟩\n        refine' ⟨hf.neg.ennreal_of_real, htμ.2, _⟩\n        rw [to_jordan_decomposition_eq_of_eq_add_with_density hf hfi htμ' hadd] }\n#align have_lebesgue_decomposition_mk' have_lebesgue_decomposition_mk'\n\n",
 "have_lebesgue_decomposition_mk":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `vector_measure.mutually_singular -/\ntheorem have_lebesgue_decomposition_mk (μ : Measure α) {f : α → exprℝ} (hf : Measurable f)\n    (htμ : vector_measure.mutually_singular t μ.to_ennreal_vector_measure) (hadd : s = t + μ.with_densityᵥ f) :\n    s.have_lebesgue_decomposition μ := by\n  by_cases hfi : integrable f μ\n  · exact have_lebesgue_decomposition_mk' μ hf hfi htμ hadd\n  · rw [with_densityᵥ, dif_neg hfi, add_zero] at hadd\n    refine' have_lebesgue_decomposition_mk' μ measurable_zero (integrable_zero _ _ μ) htμ _\n    rwa [with_densityᵥ_zero, add_zero]\n#align have_lebesgue_decomposition_mk have_lebesgue_decomposition_mk\n\n",
 "have_lebesgue_decomposition_add":
 "theorem have_lebesgue_decomposition_add (μ ν : Measure α) [have_lebesgue_decomposition μ ν] :\n    μ = μ.singular_part ν + ν.with_density (μ.rn_deriv ν) :=\n  (have_lebesgue_decomposition_spec μ ν).2.2\n#align have_lebesgue_decomposition_add have_lebesgue_decomposition_add\n\n",
 "exists_positive_of_not_mutually_singular":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `vector_measure.restrict -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `vector_measure.restrict -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `vector_measure.restrict -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure.mutually_singular -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `vector_measure.restrict -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- If two finite measures `μ` and `ν` are not mutually singular, there exists some `ε > 0` and\na measurable set `E`, such that `ν(E) > 0` and `E` is positive with respect to `μ - εν`.\n\nThis lemma is useful for the Lebesgue decomposition theorem. -/\ntheorem exists_positive_of_not_mutually_singular (μ ν : Measure α) [FiniteMeasure μ] [FiniteMeasure ν]\n    (h : ¬measure.mutually_singular μ ν) :\n    ∃ ε : nnreal,\n      0 < ε ∧\n        ∃ E : Set α,\n          MeasurableSet E ∧\n            0 < ν E ∧ vector_measure.restrict 0 E (μ.to_signed_measure - («expr • » ε ν).to_signed_measure) :=\n  by\n  -- for all `n : ℕ`, obtain the Hahn decomposition for `μ - (1 / n) ν`\n  have :\n    ∀ n : ℕ,\n      ∃ i : Set α,\n        MeasurableSet i ∧\n          vector_measure.restrict 0 i (μ.to_signed_measure - («expr • » (1 / (n + 1) : nnreal) ν).to_signed_measure) ∧\n            vector_measure.restrict (μ.to_signed_measure - («expr • » (1 / (n + 1) : nnreal) ν).to_signed_measure)\n              («expr ᶜ» i) 0 :=\n    by\n    intro\n    exact exists_compl_positive_negative _\n  choose f hf₁ hf₂ hf₃ using this\n  -- set `A` to be the intersection of all the negative parts of obtained Hahn decompositions\n  -- and we show that `μ A = 0`\n  set A :=\n    «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\"\n      («expr ᶜ» (f n)) with\n    hA₁\n  have hAmeas : MeasurableSet A := MeasurableSet.interᵢ fun n => (hf₁ n).compl\n  have hA₂ :\n    ∀ n : ℕ,\n      vector_measure.restrict (μ.to_signed_measure - («expr • » (1 / (n + 1) : nnreal) ν).to_signed_measure) A 0 :=\n    by\n    intro n\n    exact restrict_le_restrict_subset _ _ (hf₁ n).compl (hf₃ n) (Inter_subset _ _)\n  have hA₃ : ∀ n : ℕ, μ A ≤ (1 / (n + 1) : nnreal) * ν A :=\n    by\n    intro n\n    have := nonpos_of_restrict_le_zero _ (hA₂ n)\n    rwa [to_signed_measure_sub_apply hAmeas, sub_nonpos, ENNReal.toReal_le_toReal] at this\n    exacts[ne_of_lt (measure_lt_top _ _), ne_of_lt (measure_lt_top _ _)]\n  have hμ : μ A = 0 := by\n    lift μ A to nnreal using ne_of_lt (measure_lt_top _ _) with μA\n    lift ν A to nnreal using ne_of_lt (measure_lt_top _ _) with νA\n    rw [ENNReal.coe_eq_zero]\n    by_cases hb : 0 < νA\n    · suffices ∀ b, 0 < b → μA ≤ b by\n        by_contra\n        have h' := this (μA / 2) (half_pos (zero_lt_iff.2 h))\n        rw [← @Classical.not_not (μA ≤ μA / 2)] at h'\n        exact h' (not_le.2 (NNReal.half_lt_self h))\n      intro c hc\n      have : ∃ n : ℕ, 1 / (n + 1 : exprℝ) < c * νA⁻¹\n      refine' exists_nat_one_div_lt _\n      · refine' mul_pos hc _\n        rw [_root_.inv_pos]\n        exact hb\n      rcases this with ⟨n, hn⟩\n      have hb₁ : (0 : exprℝ) < νA⁻¹ := by\n        rw [_root_.inv_pos]\n        exact hb\n      have h' : 1 / (↑n + 1) * νA < c :=\n        by\n        rw [← NNReal.coe_lt_coe, ← mul_lt_mul_right hb₁, NNReal.coe_mul, mul_assoc, ← NNReal.coe_inv, ← NNReal.coe_mul,\n          _root_.mul_inv_cancel, ← NNReal.coe_mul, mul_one, NNReal.coe_inv]\n        · exact hn\n        · exact ne.symm (ne_of_lt hb)\n      refine' le_trans _ (le_of_lt h')\n      rw [← ENNReal.coe_le_coe, ENNReal.coe_mul]\n      exact hA₃ n\n    · rw [not_lt, le_zero_iff] at hb\n      specialize hA₃ 0\n      simp [hb, le_zero_iff] at hA₃\n      assumption\n  -- since `μ` and `ν` are not mutually singular, `μ A = 0` implies `ν Aᶜ > 0`\n  rw [mutually_singular] at h\n  push_neg  at h\n  have := h _ hAmeas hμ\n  simp_rw [hA₁, compl_Inter, compl_compl] at this\n  -- as `Aᶜ = ⋃ n, f n`, `ν Aᶜ > 0` implies there exists some `n` such that `ν (f n) > 0`\n  obtain ⟨n, hn⟩ := exists_measure_pos_of_not_measure_Union_null this\n  -- thus, choosing `f n` as the set `E` suffices\n  exact ⟨1 / (n + 1), by simp, f n, hf₁ n, hn, hf₂ n⟩\n#align exists_positive_of_not_mutually_singular exists_positive_of_not_mutually_singular\n\n",
 "eq_with_density_rn_deriv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure.mutually_singular -/\n/-- Given measures `μ` and `ν`, if `s` is a measure mutually singular to `ν` and `f` is a\nmeasurable function such that `μ = s + fν`, then `f = μ.rn_deriv ν`.\n\nThis theorem provides the uniqueness of the `rn_deriv` in the Lebesgue decomposition\ntheorem, while `measure_theory.measure.eq_singular_part` provides the uniqueness of the\n`singular_part`. Here, the uniqueness is given in terms of the measures, while the uniqueness in\nterms of the functions is given in `eq_rn_deriv`. -/\ntheorem eq_with_density_rn_deriv {s : Measure α} {f : α → ennreal} (hf : Measurable f)\n    (hs : measure.mutually_singular s ν) (hadd : μ = s + ν.with_density f) :\n    ν.with_density f = ν.with_density (μ.rn_deriv ν) :=\n  by\n  haveI : have_lebesgue_decomposition μ ν := ⟨⟨⟨s, f⟩, hf, hs, hadd⟩⟩\n  obtain ⟨hmeas, hsing, hadd'⟩ := have_lebesgue_decomposition_spec μ ν\n  obtain ⟨⟨S, hS₁, hS₂, hS₃⟩, ⟨T, hT₁, hT₂, hT₃⟩⟩ := hs, hsing\n  rw [hadd'] at hadd\n  have hνinter : ν («expr ᶜ» (S ∩ T)) = 0 := by\n    rw [compl_inter]\n    refine' nonpos_iff_eq_zero.1 (le_trans (measure_union_le _ _) _)\n    rw [hT₃, hS₃, add_zero]\n    exact le_rfl\n  have heq : (ν.with_density f).restrict (S ∩ T) = (ν.with_density (μ.rn_deriv ν)).restrict (S ∩ T) :=\n    by\n    ext1 A hA\n    have hs : s (A ∩ (S ∩ T)) = 0 := by\n      rw [← nonpos_iff_eq_zero]\n      exact hS₂ ▸ measure_mono ((inter_subset_right _ _).trans (inter_subset_left _ _))\n    have hsing : μ.singular_part ν (A ∩ (S ∩ T)) = 0 :=\n      by\n      rw [← nonpos_iff_eq_zero]\n      exact hT₂ ▸ measure_mono ((inter_subset_right _ _).trans (inter_subset_right _ _))\n    rw [restrict_apply hA, restrict_apply hA, ← add_zero (ν.with_density f (A ∩ (S ∩ T))), ← hs, ← add_apply, add_comm,\n      ← hadd, add_apply, hsing, zero_add]\n  have heq' : ∀ A : Set α, MeasurableSet A → ν.with_density f A = (ν.with_density f).restrict (S ∩ T) A :=\n    by\n    intro A hA\n    have hνfinter : ν.with_density f (A ∩ «expr ᶜ» (S ∩ T)) = 0 :=\n      by\n      rw [← nonpos_iff_eq_zero]\n      exact with_density_absolutely_continuous ν f hνinter ▸ measure_mono (inter_subset_right _ _)\n    rw [restrict_apply hA, ← add_zero (ν.with_density f (A ∩ (S ∩ T))), ← hνfinter, ← diff_eq,\n      measure_inter_add_diff _ (hS₁.inter hT₁)]\n  ext1 A hA\n  have hνrn : ν.with_density (μ.rn_deriv ν) (A ∩ «expr ᶜ» (S ∩ T)) = 0 :=\n    by\n    rw [← nonpos_iff_eq_zero]\n    exact with_density_absolutely_continuous ν (μ.rn_deriv ν) hνinter ▸ measure_mono (inter_subset_right _ _)\n  rw [heq' A hA, HEq, ← add_zero ((ν.with_density (μ.rn_deriv ν)).restrict (S ∩ T) A), ← hνrn, restrict_apply hA, ←\n    diff_eq, measure_inter_add_diff _ (hS₁.inter hT₁)]\n#align eq_with_density_rn_deriv eq_with_density_rn_deriv\n\n",
 "eq_singular_part'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure.mutually_singular -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure.mutually_singular -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `vector_measure.mutually_singular -/\nprivate theorem eq_singular_part' (t : signed_measure α) {f : α → exprℝ} (hf : Measurable f) (hfi : integrable f μ)\n    (htμ : vector_measure.mutually_singular t μ.to_ennreal_vector_measure) (hadd : s = t + μ.with_densityᵥ f) :\n    t = s.singular_part μ := by\n  have htμ' := htμ\n  rw [mutually_singular_ennreal_iff, total_variation_mutually_singular_iff] at htμ\n  change\n    measure.mutually_singular _ (vector_measure.equiv_measure.to_fun (vector_measure.equiv_measure.inv_fun μ)) ∧\n      measure.mutually_singular _ (vector_measure.equiv_measure.to_fun (vector_measure.equiv_measure.inv_fun μ)) at\n    htμ\n  rw [vector_measure.equiv_measure.right_inv] at htμ\n  · rw [singular_part, ← t.to_signed_measure_to_jordan_decomposition, jordan_decomposition.to_signed_measure]\n    congr\n    · have hfpos : Measurable fun x => ENNReal.ofReal (f x) := by measurability\n      refine' eq_singular_part hfpos htμ.1 _\n      rw [to_jordan_decomposition_eq_of_eq_add_with_density hf hfi htμ' hadd]\n    · have hfneg : Measurable fun x => ENNReal.ofReal (-f x) := by measurability\n      refine' eq_singular_part hfneg htμ.2 _\n      rw [to_jordan_decomposition_eq_of_eq_add_with_density hf hfi htμ' hadd]\n#align eq_singular_part' eq_singular_part'\n\n",
 "eq_singular_part":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `vector_measure.mutually_singular -/\n/-- Given a measure `μ`, signed measures `s` and `t`, and a function `f` such that `t` is\nmutually singular with respect to `μ` and `s = t + μ.with_densityᵥ f`, we have\n`t = singular_part s μ`, i.e. `t` is the singular part of the Lebesgue decomposition between\n`s` and `μ`. -/\ntheorem eq_singular_part (t : signed_measure α) (f : α → exprℝ)\n    (htμ : vector_measure.mutually_singular t μ.to_ennreal_vector_measure) (hadd : s = t + μ.with_densityᵥ f) :\n    t = s.singular_part μ := by\n  by_cases hfi : integrable f μ\n  · refine' eq_singular_part' t hfi.1.measurable_mk (hfi.congr hfi.1.ae_eq_mk) htμ _\n    convert hadd using 2\n    exact with_densityᵥ_eq.congr_ae hfi.1.ae_eq_mk.symm\n  · rw [with_densityᵥ, dif_neg hfi, add_zero] at hadd\n    refine' eq_singular_part' t measurable_zero (integrable_zero _ _ μ) htμ _\n    rwa [with_densityᵥ_zero, add_zero]\n#align eq_singular_part eq_singular_part\n\n",
 "eq_rn_deriv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `vector_measure.mutually_singular -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\n/-- Given a measure `μ`, signed measures `s` and `t`, and a function `f` such that `t` is\nmutually singular with respect to `μ` and `s = t + μ.with_densityᵥ f`, we have\n`f = rn_deriv s μ`, i.e. `f` is the Radon-Nikodym derivative of `s` and `μ`. -/\ntheorem eq_rn_deriv (t : signed_measure α) (f : α → exprℝ) (hfi : integrable f μ)\n    (htμ : vector_measure.mutually_singular t μ.to_ennreal_vector_measure) (hadd : s = t + μ.with_densityᵥ f) :\n    «expr =ᵐ[ ] » f μ (s.rn_deriv μ) := by\n  set f' := hfi.1.mk f\n  have hadd' : s = t + μ.with_densityᵥ f' := by\n    convert hadd using 2\n    exact with_densityᵥ_eq.congr_ae hfi.1.ae_eq_mk.symm\n  haveI := have_lebesgue_decomposition_mk μ hfi.1.measurable_mk htμ hadd'\n  refine' (integrable.ae_eq_of_with_densityᵥ_eq (integrable_rn_deriv _ _) hfi _).symm\n  rw [← add_right_inj t, ← hadd, eq_singular_part _ f htμ hadd, singular_part_add_with_density_rn_deriv_eq]\n#align eq_rn_deriv eq_rn_deriv\n\n"}