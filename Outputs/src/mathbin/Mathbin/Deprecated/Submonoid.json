{"subset_closure":
 "/-- A subset of a monoid is contained in the submonoid it generates. -/\n@[to_additive \"A subset of an `add_monoid` is contained in the `add_submonoid` it generates.\"]\ntheorem subset_closure {s : set M} : s ⊆ closure s := fun a => in_closure.basic\n#align subset_closure subset_closure\n\n",
 "self_mem":
 "/-- An element of a monoid is in the set of that element's natural number powers. -/\n@[to_additive \"An element of an `add_monoid` is in the set of that element's natural number multiples.\"]\ntheorem powers.self_mem {x : M} : x ∈ powers x :=\n  ⟨1, pow_one _⟩\n#align powers.self_mem powers.self_mem\n\n",
 "preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/-- The preimage of a submonoid under a monoid hom is a submonoid of the domain. -/\n@[to_additive \"The preimage of an `add_submonoid` under an `add_monoid` hom is\\nan `add_submonoid` of the domain.\"]\ntheorem is_submonoid.preimage {N : Type _} [monoid N] {f : M → N} (hf : is_monoid_hom f) {s : set N}\n    (hs : is_submonoid s) : is_submonoid («expr ⁻¹' » f s) :=\n  { one_mem := show f 1 ∈ s by rw [is_monoid_hom.map_one hf] <;> exact hs.one_mem\n    mul_mem := fun a b (ha : f a ∈ s) (hb : f b ∈ s) =>\n      show f (a * b) ∈ s by rw [is_monoid_hom.map_mul hf] <;> exact hs.mul_mem ha hb }\n#align is_submonoid.preimage is_submonoid.preimage\n\n",
 "power_subset":
 "/-- The set of natural number powers of an element of a submonoid is a subset of the submonoid. -/\n@[to_additive is_add_submonoid.multiples_subset\n      \"The set of natural number multiples of an element\\nof an `add_submonoid` is a subset of the `add_submonoid`.\"]\ntheorem is_submonoid.power_subset {a : M} (hs : is_submonoid s) (h : a ∈ s) : powers a ⊆ s := fun x ⟨n, hx⟩ =>\n  hx ▸ hs.pow_mem h\n#align is_submonoid.power_subset is_submonoid.power_subset\n\n",
 "pow_mem":
 "/-- Submonoids are closed under natural powers. -/\n@[to_additive is_add_submonoid.smul_mem \"An `add_submonoid` is closed under multiplication by naturals.\"]\ntheorem is_submonoid.pow_mem {a : M} (hs : is_submonoid s) (h : a ∈ s) : ∀ {n : ℕ}, a ^ n ∈ s\n  | 0 => by\n    rw [pow_zero]\n    exact hs.one_mem\n  | n + 1 => by\n    rw [pow_succ]\n    exact hs.mul_mem h is_submonoid.pow_mem\n#align is_submonoid.pow_mem is_submonoid.pow_mem\n\n",
 "one_mem":
 "/-- 1 is in the set of natural number powers of an element of a monoid. -/\n@[to_additive \"0 is in the set of natural number multiples of an element of an `add_monoid`.\"]\ntheorem powers.one_mem {x : M} : (1 : M) ∈ powers x :=\n  ⟨0, pow_zero _⟩\n#align powers.one_mem powers.one_mem\n\n",
 "multiset_prod_mem":
 "/-- The product of a multiset of elements of a submonoid of a `comm_monoid` is an element of\nthe submonoid. -/\n@[to_additive\n      \"The sum of a multiset of elements of an `add_submonoid` of an `add_comm_monoid`\\nis an element of the `add_submonoid`. \"]\ntheorem multiset_prod_mem {M} [comm_monoid M] {s : set M} (hs : is_submonoid s) (m : Multiset M) :\n    (∀ a ∈ m, a ∈ s) → m.prod ∈ s := by\n  refine' Quotient.inductionOn m fun l hl => _\n  rw [Multiset.quot_mk_to_coe, Multiset.coe_prod]\n  exact list_prod_mem hs hl\n#align multiset_prod_mem multiset_prod_mem\n\n",
 "mul_mem":
 "/-- The set of natural number powers of an element of a monoid is closed under multiplication. -/\n@[to_additive \"The set of natural number multiples of an element of an `add_monoid` is closed under addition.\"]\ntheorem powers.mul_mem {x y z : M} : y ∈ powers x → z ∈ powers x → y * z ∈ powers x := fun ⟨n₁, h₁⟩ ⟨n₂, h₂⟩ =>\n  ⟨n₁ + n₂, by simp only [pow_add, *]⟩\n#align powers.mul_mem powers.mul_mem\n\n",
 "mem_closure_union_iff":
 "/-- Given sets `s, t` of a commutative monoid `M`, `x ∈ M` is in the submonoid of `M` generated by\n    `s ∪ t` iff there exists an element of the submonoid generated by `s` and an element of the\n    submonoid generated by `t` whose product is `x`. -/\n@[to_additive\n      \"Given sets `s, t` of a commutative `add_monoid M`, `x ∈ M` is in the `add_submonoid`\\nof `M` generated by `s ∪ t` iff there exists an element of the `add_submonoid` generated by `s`\\nand an element of the `add_submonoid` generated by `t` whose sum is `x`.\"]\ntheorem mem_closure_union_iff {M : Type _} [comm_monoid M] {s t : set M} {x : M} :\n    x ∈ closure (s ∪ t) ↔ ∃ y ∈ closure s, ∃ z ∈ closure t, y * z = x :=\n  ⟨fun hx =>\n    let ⟨L, HL1, HL2⟩ := exists_list_of_mem_closure hx\n    HL2 ▸\n      list.rec_on L (fun _ => ⟨1, (closure.is_submonoid _).one_mem, 1, (closure.is_submonoid _).one_mem, mul_one _⟩)\n        (fun hd tl ih HL1 =>\n          let ⟨y, hy, z, hz, hyzx⟩ := ih (List.forall_mem_of_forall_mem_cons HL1)\n          or.cases_on (HL1 hd <| list.mem_cons_self _ _)\n            (fun hs =>\n              ⟨hd * y, (closure.is_submonoid _).mul_mem (subset_closure hs) hy, z, hz, by\n                rw [mul_assoc, List.prod_cons, ← hyzx] <;> rfl⟩)\n            fun ht =>\n            ⟨y, hy, z * hd, (closure.is_submonoid _).mul_mem hz (subset_closure ht), by\n              rw [← mul_assoc, List.prod_cons, ← hyzx, mul_comm hd] <;> rfl⟩)\n        HL1,\n    fun ⟨y, hy, z, hz, hyzx⟩ =>\n    hyzx ▸\n      (closure.is_submonoid _).mul_mem (closure_mono (Set.subset_union_left _ _) hy)\n        (closure_mono (Set.subset_union_right _ _) hz)⟩\n#align mem_closure_union_iff mem_closure_union_iff\n\n",
 "list_prod_mem":
 "/-- The product of a list of elements of a submonoid is an element of the submonoid. -/\n@[to_additive \"The sum of a list of elements of an `add_submonoid` is an element of the\\n`add_submonoid`.\"]\ntheorem list_prod_mem (hs : is_submonoid s) : ∀ {l : list M}, (∀ x ∈ l, x ∈ s) → l.prod ∈ s\n  | [], h => hs.one_mem\n  | a :: l, h =>\n    suffices a * l.prod ∈ s by simpa\n    have : a ∈ s ∧ ∀ x ∈ l, x ∈ s := by simpa using h\n    hs.mul_mem this.1 (list_prod_mem this.2)\n#align list_prod_mem list_prod_mem\n\n",
 "is_submonoid_iff":
 "theorem multiplicative.is_submonoid_iff {s : set A} : @is_submonoid (Multiplicative A) _ s ↔ is_add_submonoid s :=\n  ⟨fun ⟨h₁, h₂⟩ => ⟨h₁, @h₂⟩, multiplicative.is_submonoid⟩\n#align multiplicative.is_submonoid_iff multiplicative.is_submonoid_iff\n\n",
 "is_submonoid_Union_of_directed":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/-- The union of an indexed, directed, nonempty set of submonoids of a monoid `M` is a submonoid\n    of `M`. -/\n@[to_additive\n      \"The union of an indexed, directed, nonempty set\\nof `add_submonoid`s of an `add_monoid` `M` is an `add_submonoid` of `M`. \"]\ntheorem is_submonoid_Union_of_directed {ι : Type _} [hι : nonempty ι] {s : ι → set M} (hs : ∀ i, is_submonoid (s i))\n    (directed : ∀ i j, ∃ k, s i ⊆ s k ∧ s j ⊆ s k) :\n    is_submonoid\n      («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (s i)) :=\n  { one_mem :=\n      let ⟨i⟩ := hι\n      Set.mem_unionᵢ.2 ⟨i, (hs i).one_mem⟩\n    mul_mem := fun a b ha hb =>\n      let ⟨i, hi⟩ := Set.mem_unionᵢ.1 ha\n      let ⟨j, hj⟩ := Set.mem_unionᵢ.1 hb\n      let ⟨k, hk⟩ := Directed i j\n      Set.mem_unionᵢ.2 ⟨k, (hs k).mul_mem (hk.1 hi) (hk.2 hj)⟩ }\n#align is_submonoid_Union_of_directed is_submonoid_Union_of_directed\n\n",
 "is_submonoid":
 "@[to_additive]\ntheorem submonoid.is_submonoid (S : Submonoid M) : is_submonoid (S : set M) :=\n  ⟨S.3, fun _ _ => S.2⟩\n#align submonoid.is_submonoid submonoid.is_submonoid\n\n",
 "is_add_submonoid_iff":
 "theorem additive.is_add_submonoid_iff {s : set M} : @is_add_submonoid (Additive M) _ s ↔ is_submonoid s :=\n  ⟨fun ⟨h₁, h₂⟩ => ⟨h₁, @h₂⟩, additive.is_add_submonoid⟩\n#align additive.is_add_submonoid_iff additive.is_add_submonoid_iff\n\n",
 "is_add_submonoid":
 "/-\nCopyright (c) 2018 Johannes Hölzl. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johannes Hölzl, Kenny Lau, Johan Commelin, Mario Carneiro, Kevin Buzzard\n-/\ntheorem additive.is_add_submonoid {s : set M} : ∀ is : is_submonoid s, @is_add_submonoid (Additive M) _ s\n  | ⟨h₁, h₂⟩ => ⟨h₁, @h₂⟩\n#align additive.is_add_submonoid additive.is_add_submonoid\n\n",
 "inter":
 "/-- The intersection of two submonoids of a monoid `M` is a submonoid of `M`. -/\n@[to_additive \"The intersection of two `add_submonoid`s of an `add_monoid` `M` is\\nan `add_submonoid` of M.\"]\ntheorem is_submonoid.inter {s₁ s₂ : set M} (is₁ : is_submonoid s₁) (is₂ : is_submonoid s₂) : is_submonoid (s₁ ∩ s₂) :=\n  { one_mem := ⟨is₁.one_mem, is₂.one_mem⟩\n    mul_mem := fun x y hx hy => ⟨is₁.mul_mem hx.1 hy.1, is₂.mul_mem hx.2 hy.2⟩ }\n#align is_submonoid.inter is_submonoid.inter\n\n",
 "image_closure":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/-- The image under a monoid hom of the submonoid generated by a set equals the submonoid generated\n    by the image of the set under the monoid hom. -/\n@[to_additive\n      \"The image under an `add_monoid` hom of the `add_submonoid` generated by a set equals\\nthe `add_submonoid` generated by the image of the set under the `add_monoid` hom.\"]\ntheorem image_closure {A : Type _} [monoid A] {f : M → A} (hf : is_monoid_hom f) (s : set M) :\n    «expr '' » f (closure s) = closure («expr '' » f s) :=\n  le_antisymm\n    (by\n      rintro _ ⟨x, hx, rfl⟩\n      apply in_closure.rec_on hx <;> intros\n      · solve_by_elim [subset_closure, Set.mem_image_of_mem]\n      · rw [hf.map_one]\n        apply is_submonoid.one_mem (closure.is_submonoid («expr '' » f s))\n      · rw [hf.map_mul]\n        solve_by_elim [(closure.is_submonoid _).mul_mem] )\n    (closure_subset (is_submonoid.image hf (closure.is_submonoid _)) <| Set.image_subset _ subset_closure)\n#align image_closure image_closure\n\n",
 "image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/-- The image of a submonoid under a monoid hom is a submonoid of the codomain. -/\n@[to_additive \"The image of an `add_submonoid` under an `add_monoid`\\nhom is an `add_submonoid` of the codomain.\"]\ntheorem is_submonoid.image {γ : Type _} [monoid γ] {f : M → γ} (hf : is_monoid_hom f) {s : set M}\n    (hs : is_submonoid s) : is_submonoid («expr '' » f s) :=\n  { one_mem := ⟨1, hs.one_mem, hf.map_one⟩\n    mul_mem := fun a b ⟨x, hx⟩ ⟨y, hy⟩ => ⟨x * y, hs.mul_mem hx.1 hy.1, by rw [hf.map_mul, hx.2, hy.2]⟩ }\n#align is_submonoid.image is_submonoid.image\n\n",
 "finset_prod_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/-- The product of elements of a submonoid of a `comm_monoid` indexed by a `finset` is an element\nof the submonoid. -/\n@[to_additive\n      \"The sum of elements of an `add_submonoid` of an `add_comm_monoid` indexed by\\na `finset` is an element of the `add_submonoid`.\"]\ntheorem finset_prod_mem {M A} [comm_monoid M] {s : set M} (hs : is_submonoid s) (f : A → M) :\n    ∀ t : Finset A,\n      (∀ b ∈ t, f b ∈ s) →\n        finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" t (f b) ∈ s\n  | ⟨m, hm⟩, _ => multiset_prod_mem hs _ (by simpa)\n#align finset_prod_mem finset_prod_mem\n\n",
 "exists_list_of_mem_closure":
 "/-- Given an element `a` of the submonoid of a monoid `M` generated by a set `s`, there exists\na list of elements of `s` whose product is `a`. -/\n@[to_additive\n      \"Given an element `a` of the `add_submonoid` of an `add_monoid M` generated by\\na set `s`, there exists a list of elements of `s` whose sum is `a`.\"]\ntheorem exists_list_of_mem_closure {s : set M} {a : M} (h : a ∈ closure s) :\n    ∃ l : list M, (∀ x ∈ l, x ∈ s) ∧ l.prod = a := by\n  induction h\n  case basic a ha => exists [a]; simp [ha]\n  case one => exists []; simp\n  case mul a b _ _ ha hb =>\n    rcases ha with ⟨la, ha, eqa⟩\n    rcases hb with ⟨lb, hb, eqb⟩\n    exists la ++ lb\n    simp [eqa.symm, eqb.symm, or_imp]\n    exact fun a => ⟨ha a, hb a⟩\n#align exists_list_of_mem_closure exists_list_of_mem_closure\n\n",
 "closure_subset":
 "/-- The submonoid generated by a set is contained in any submonoid that contains the set. -/\n@[to_additive \"The `add_submonoid` generated by a set is contained in any `add_submonoid` that\\ncontains the set.\"]\ntheorem closure_subset {s t : set M} (ht : is_submonoid t) (h : s ⊆ t) : closure s ⊆ t := fun a ha => by\n  induction ha <;> simp [h _, *, is_submonoid.one_mem, is_submonoid.mul_mem]\n#align closure_subset closure_subset\n\n",
 "closure_singleton":
 "/-- The submonoid generated by an element of a monoid equals the set of natural number powers of\n    the element. -/\n@[to_additive\n      \"The `add_submonoid` generated by an element of an `add_monoid` equals the set of\\nnatural number multiples of the element.\"]\ntheorem closure_singleton {x : M} : closure ({x} : set M) = powers x :=\n  Set.eq_of_subset_of_subset\n      (closure_subset (powers.is_submonoid x) <| Set.singleton_subset_iff.2 <| powers.self_mem) <|\n    is_submonoid.power_subset (closure.is_submonoid _) <| Set.singleton_subset_iff.1 <| subset_closure\n#align closure_singleton closure_singleton\n\n",
 "closure_mono":
 "/-- Given subsets `t` and `s` of a monoid `M`, if `s ⊆ t`, the submonoid of `M` generated by `s` is\n    contained in the submonoid generated by `t`. -/\n@[to_additive\n      \"Given subsets `t` and `s` of an `add_monoid M`, if `s ⊆ t`, the `add_submonoid`\\nof `M` generated by `s` is contained in the `add_submonoid` generated by `t`.\"]\ntheorem closure_mono {s t : set M} (h : s ⊆ t) : closure s ⊆ closure t :=\n  closure_subset (closure.is_submonoid t) <| Set.Subset.trans h subset_closure\n#align closure_mono closure_mono\n\n",
 "Inter":
 "/-- The intersection of an indexed set of submonoids of a monoid `M` is a submonoid of `M`. -/\n@[to_additive\n      \"The intersection of an indexed set of `add_submonoid`s of an `add_monoid` `M` is\\nan `add_submonoid` of `M`.\"]\ntheorem is_submonoid.Inter {ι : Sort _} {s : ι → set M} (h : ∀ y : ι, is_submonoid (s y)) :\n    is_submonoid (Set.interᵢ s) :=\n  { one_mem := Set.mem_interᵢ.2 fun y => (h y).one_mem\n    mul_mem := fun x₁ x₂ h₁ h₂ =>\n      Set.mem_interᵢ.2 fun y => (h y).mul_mem (Set.mem_interᵢ.1 h₁ y) (Set.mem_interᵢ.1 h₂ y) }\n#align is_submonoid.Inter is_submonoid.Inter\n\n"}