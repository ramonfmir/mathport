{"subset_closure":
 "#print subset_closure /-\n/-- A subset of a monoid is contained in the submonoid it generates. -/\n@[to_additive \"A subset of an `add_monoid` is contained in the `add_submonoid` it generates.\"]\ntheorem subset_closure {s : Set M} : s ⊆ Closure s := fun a => in_closure.basic\n#align subset_closure subset_closure\n-/\n\n",
 "self_mem":
 "#print powers.self_mem /-\n/-- An element of a monoid is in the set of that element's natural number powers. -/\n@[to_additive \"An element of an `add_monoid` is in the set of that element's natural number multiples.\"]\ntheorem powers.self_mem {x : M} : x ∈ powers x :=\n  ⟨1, pow_one _⟩\n#align powers.self_mem powers.self_mem\n#align multiples.self_mem multiples.self_mem\n-/\n\n",
 "preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n#print IsSubmonoid.preimage /-\n/-- The preimage of a submonoid under a monoid hom is a submonoid of the domain. -/\n@[to_additive \"The preimage of an `add_submonoid` under an `add_monoid` hom is\\nan `add_submonoid` of the domain.\"]\ntheorem IsSubmonoid.preimage {N : Type _} [Monoid N] {f : M → N} (hf : IsMonoidHom f) {s : Set N} (hs : IsSubmonoid s) :\n    IsSubmonoid («expr ⁻¹' » f s) :=\n  { one_mem := show f 1 ∈ s by rw [is_monoid_hom.map_one hf] <;> exact hs.one_mem\n    mul_mem := fun a b (ha : f a ∈ s) (hb : f b ∈ s) =>\n      show f (a * b) ∈ s by rw [IsMonoidHom.map_mul' hf] <;> exact hs.mul_mem ha hb }\n#align is_submonoid.preimage IsSubmonoid.preimage\n#align is_add_submonoid.preimage IsAddSubmonoid.preimage\n-/\n\n",
 "power_subset":
 "#print IsSubmonoid.power_subset /-\n/-- The set of natural number powers of an element of a submonoid is a subset of the submonoid. -/\n@[to_additive IsAddSubmonoid.multiples_subset\n      \"The set of natural number multiples of an element\\nof an `add_submonoid` is a subset of the `add_submonoid`.\"]\ntheorem IsSubmonoid.power_subset {a : M} (hs : IsSubmonoid s) (h : a ∈ s) : powers a ⊆ s := fun x ⟨n, hx⟩ =>\n  hx ▸ hs.pow_mem h\n#align is_submonoid.power_subset IsSubmonoid.power_subset\n#align is_add_submonoid.multiples_subset IsAddSubmonoid.multiples_subset\n-/\n\n",
 "pow_mem":
 "#print IsSubmonoid.pow_mem /-\n/-- Submonoids are closed under natural powers. -/\n@[to_additive is_add_submonoid.smul_mem \"An `add_submonoid` is closed under multiplication by naturals.\"]\ntheorem IsSubmonoid.pow_mem {a : M} (hs : IsSubmonoid s) (h : a ∈ s) : ∀ {n : ℕ}, a ^ n ∈ s\n  | 0 => by\n    rw [pow_zero]\n    exact hs.one_mem\n  | n + 1 => by\n    rw [pow_succ]\n    exact hs.mul_mem h IsSubmonoid.pow_mem\n#align is_submonoid.pow_mem IsSubmonoid.pow_mem\n-/\n\n",
 "one_mem":
 "#print powers.one_mem /-\n/-- 1 is in the set of natural number powers of an element of a monoid. -/\n@[to_additive \"0 is in the set of natural number multiples of an element of an `add_monoid`.\"]\ntheorem powers.one_mem {x : M} : (1 : M) ∈ powers x :=\n  ⟨0, pow_zero _⟩\n#align powers.one_mem powers.one_mem\n#align multiples.zero_mem multiples.zero_mem\n-/\n\n",
 "multiset_prod_mem":
 "#print multiset_prod_mem /-\n/-- The product of a multiset of elements of a submonoid of a `comm_monoid` is an element of\nthe submonoid. -/\n@[to_additive\n      \"The sum of a multiset of elements of an `add_submonoid` of an `add_comm_monoid`\\nis an element of the `add_submonoid`. \"]\ntheorem multiset_prod_mem {M} [CommMonoid M] {s : Set M} (hs : IsSubmonoid s) (m : Multiset M) :\n    (∀ a ∈ m, a ∈ s) → m.prod ∈ s := by\n  refine' Quotient.inductionOn m fun l hl => _\n  rw [Multiset.quot_mk_to_coe, Multiset.coe_prod]\n  exact list_prod_mem hs hl\n#align multiset_prod_mem multiset_prod_mem\n#align multiset_sum_mem multiset_sum_mem\n-/\n\n",
 "mul_mem":
 "#print powers.mul_mem /-\n/-- The set of natural number powers of an element of a monoid is closed under multiplication. -/\n@[to_additive \"The set of natural number multiples of an element of an `add_monoid` is closed under addition.\"]\ntheorem powers.mul_mem {x y z : M} : y ∈ powers x → z ∈ powers x → y * z ∈ powers x := fun ⟨n₁, h₁⟩ ⟨n₂, h₂⟩ =>\n  ⟨n₁ + n₂, by simp only [pow_add, *]⟩\n#align powers.mul_mem powers.mul_mem\n#align multiples.add_mem multiples.add_mem\n-/\n\n",
 "mem_closure_union_iff":
 "/-- Given sets `s, t` of a commutative monoid `M`, `x ∈ M` is in the submonoid of `M` generated by\n    `s ∪ t` iff there exists an element of the submonoid generated by `s` and an element of the\n    submonoid generated by `t` whose product is `x`. -/\n@[to_additive\n      \"Given sets `s, t` of a commutative `add_monoid M`, `x ∈ M` is in the `add_submonoid`\\nof `M` generated by `s ∪ t` iff there exists an element of the `add_submonoid` generated by `s`\\nand an element of the `add_submonoid` generated by `t` whose sum is `x`.\"]\ntheorem mem_closure_union_iff {M : Type _} [CommMonoid M] {s t : Set M} {x : M} :\n    x ∈ Closure (s ∪ t) ↔ ∃ y ∈ Closure s, ∃ z ∈ Closure t, y * z = x :=\n  ⟨fun hx =>\n    let ⟨L, HL1, HL2⟩ := exists_list_of_mem_closure hx\n    HL2 ▸\n      list.rec_on L (fun _ => ⟨1, (closure.isSubmonoid _).one_mem, 1, (closure.isSubmonoid _).one_mem, mul_one _⟩)\n        (fun hd tl ih HL1 =>\n          let ⟨y, hy, z, hz, hyzx⟩ := ih (List.forall_mem_of_forall_mem_cons HL1)\n          or.cases_on (HL1 hd <| list.mem_cons_self _ _)\n            (fun hs =>\n              ⟨hd * y, (closure.isSubmonoid _).mul_mem (subset_closure hs) hy, z, hz, by\n                rw [mul_assoc, List.prod_cons, ← hyzx] <;> rfl⟩)\n            fun ht =>\n            ⟨y, hy, z * hd, (closure.isSubmonoid _).mul_mem hz (subset_closure ht), by\n              rw [← mul_assoc, List.prod_cons, ← hyzx, mul_comm hd] <;> rfl⟩)\n        HL1,\n    fun ⟨y, hy, z, hz, hyzx⟩ =>\n    hyzx ▸\n      (closure.isSubmonoid _).mul_mem (closure_mono (Set.subset_union_left _ _) hy)\n        (closure_mono (Set.subset_union_right _ _) hz)⟩\n#align mem_closure_union_iff mem_closure_union_iff\n\n",
 "list_prod_mem":
 "#print list_prod_mem /-\n/-- The product of a list of elements of a submonoid is an element of the submonoid. -/\n@[to_additive \"The sum of a list of elements of an `add_submonoid` is an element of the\\n`add_submonoid`.\"]\ntheorem list_prod_mem (hs : IsSubmonoid s) : ∀ {l : List M}, (∀ x ∈ l, x ∈ s) → l.prod ∈ s\n  | [], h => hs.one_mem\n  | a :: l, h =>\n    suffices a * l.prod ∈ s by simpa\n    have : a ∈ s ∧ ∀ x ∈ l, x ∈ s := by simpa using h\n    hs.mul_mem this.1 (list_prod_mem this.2)\n#align list_prod_mem list_prod_mem\n#align list_sum_mem list_sum_mem\n-/\n\n",
 "is_submonoid":
 "@[to_additive]\ntheorem closure.is_submonoid (s : Set M) : IsSubmonoid (Closure s) :=\n  { one_mem := in_closure.one\n    mul_mem := fun a b => in_closure.mul }\n#align closure.is_submonoid closure.is_submonoid\n\n",
 "isSubmonoid_unionᵢ_of_directed":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n#print isSubmonoid_unionᵢ_of_directed /-\n/-- The union of an indexed, directed, nonempty set of submonoids of a monoid `M` is a submonoid\n    of `M`. -/\n@[to_additive\n      \"The union of an indexed, directed, nonempty set\\nof `add_submonoid`s of an `add_monoid` `M` is an `add_submonoid` of `M`. \"]\ntheorem isSubmonoid_unionᵢ_of_directed {ι : Type _} [hι : Nonempty ι] {s : ι → Set M} (hs : ∀ i, IsSubmonoid (s i))\n    (directed : ∀ i j, ∃ k, s i ⊆ s k ∧ s j ⊆ s k) :\n    IsSubmonoid\n      («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (s i)) :=\n  { one_mem :=\n      let ⟨i⟩ := hι\n      Set.mem_unionᵢ.2 ⟨i, (hs i).one_mem⟩\n    mul_mem := fun a b ha hb =>\n      let ⟨i, hi⟩ := Set.mem_unionᵢ.1 ha\n      let ⟨j, hj⟩ := Set.mem_unionᵢ.1 hb\n      let ⟨k, hk⟩ := Directed i j\n      Set.mem_unionᵢ.2 ⟨k, (hs k).mul_mem (hk.1 hi) (hk.2 hj)⟩ }\n#align is_submonoid_Union_of_directed isSubmonoid_unionᵢ_of_directed\n#align is_add_submonoid_Union_of_directed isAddSubmonoid_unionᵢ_of_directed\n-/\n\n",
 "isSubmonoid_iff":
 "#print Multiplicative.isSubmonoid_iff /-\ntheorem Multiplicative.isSubmonoid_iff {s : Set A} : @IsSubmonoid (Multiplicative A) _ s ↔ IsAddSubmonoid s :=\n  ⟨fun ⟨h₁, h₂⟩ => ⟨h₁, @h₂⟩, Multiplicative.isSubmonoid⟩\n#align multiplicative.is_submonoid_iff Multiplicative.isSubmonoid_iff\n-/\n\n",
 "isSubmonoid":
 "#print Submonoid.isSubmonoid /-\n@[to_additive]\ntheorem Submonoid.isSubmonoid (S : Submonoid M) : IsSubmonoid (S : Set M) :=\n  ⟨S.3, fun _ _ => S.2⟩\n#align submonoid.is_submonoid Submonoid.isSubmonoid\n#align add_submonoid.is_add_submonoid AddSubmonoid.isAddSubmonoid\n-/\n\n",
 "isAddSubmonoid_iff":
 "#print Additive.isAddSubmonoid_iff /-\ntheorem Additive.isAddSubmonoid_iff {s : Set M} : @IsAddSubmonoid (Additive M) _ s ↔ IsSubmonoid s :=\n  ⟨fun ⟨h₁, h₂⟩ => ⟨h₁, @h₂⟩, Additive.isAddSubmonoid⟩\n#align additive.is_add_submonoid_iff Additive.isAddSubmonoid_iff\n-/\n\n",
 "isAddSubmonoid":
 "#print Additive.isAddSubmonoid /-\n/-\nCopyright (c) 2018 Johannes Hölzl. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johannes Hölzl, Kenny Lau, Johan Commelin, Mario Carneiro, Kevin Buzzard\n-/\ntheorem Additive.isAddSubmonoid {s : Set M} : ∀ is : IsSubmonoid s, @IsAddSubmonoid (Additive M) _ s\n  | ⟨h₁, h₂⟩ => ⟨h₁, @h₂⟩\n#align additive.is_add_submonoid Additive.isAddSubmonoid\n-/\n\n",
 "interᵢ":
 "#print IsSubmonoid.interᵢ /-\n/-- The intersection of an indexed set of submonoids of a monoid `M` is a submonoid of `M`. -/\n@[to_additive\n      \"The intersection of an indexed set of `add_submonoid`s of an `add_monoid` `M` is\\nan `add_submonoid` of `M`.\"]\ntheorem IsSubmonoid.interᵢ {ι : Sort _} {s : ι → Set M} (h : ∀ y : ι, IsSubmonoid (s y)) : IsSubmonoid (Set.interᵢ s) :=\n  { one_mem := Set.mem_interᵢ.2 fun y => (h y).one_mem\n    mul_mem := fun x₁ x₂ h₁ h₂ =>\n      Set.mem_interᵢ.2 fun y => (h y).mul_mem (Set.mem_interᵢ.1 h₁ y) (Set.mem_interᵢ.1 h₂ y) }\n#align is_submonoid.Inter IsSubmonoid.interᵢ\n#align is_add_submonoid.Inter IsAddSubmonoid.interᵢ\n-/\n\n",
 "inter":
 "#print IsSubmonoid.inter /-\n/-- The intersection of two submonoids of a monoid `M` is a submonoid of `M`. -/\n@[to_additive \"The intersection of two `add_submonoid`s of an `add_monoid` `M` is\\nan `add_submonoid` of M.\"]\ntheorem IsSubmonoid.inter {s₁ s₂ : Set M} (is₁ : IsSubmonoid s₁) (is₂ : IsSubmonoid s₂) : IsSubmonoid (s₁ ∩ s₂) :=\n  { one_mem := ⟨is₁.one_mem, is₂.one_mem⟩\n    mul_mem := fun x y hx hy => ⟨is₁.mul_mem hx.1 hy.1, is₂.mul_mem hx.2 hy.2⟩ }\n#align is_submonoid.inter IsSubmonoid.inter\n#align is_add_submonoid.inter IsAddSubmonoid.inter\n-/\n\n",
 "image_closure":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/-- The image under a monoid hom of the submonoid generated by a set equals the submonoid generated\n    by the image of the set under the monoid hom. -/\n@[to_additive\n      \"The image under an `add_monoid` hom of the `add_submonoid` generated by a set equals\\nthe `add_submonoid` generated by the image of the set under the `add_monoid` hom.\"]\ntheorem image_closure {A : Type _} [Monoid A] {f : M → A} (hf : IsMonoidHom f) (s : Set M) :\n    «expr '' » f (Closure s) = Closure («expr '' » f s) :=\n  le_antisymm\n    (by\n      rintro _ ⟨x, hx, rfl⟩\n      apply in_closure.rec_on hx <;> intros\n      · solve_by_elim [subset_closure, Set.mem_image_of_mem]\n      · rw [hf.map_one]\n        apply is_submonoid.one_mem (closure.is_submonoid («expr '' » f s))\n      · rw [hf.map_mul]\n        solve_by_elim [(closure.is_submonoid _).mul_mem] )\n    (closure_subset (IsSubmonoid.image hf (closure.isSubmonoid _)) <| Set.image_subset _ subset_closure)\n#align image_closure image_closure\n\n",
 "image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n#print IsSubmonoid.image /-\n/-- The image of a submonoid under a monoid hom is a submonoid of the codomain. -/\n@[to_additive \"The image of an `add_submonoid` under an `add_monoid`\\nhom is an `add_submonoid` of the codomain.\"]\ntheorem IsSubmonoid.image {γ : Type _} [Monoid γ] {f : M → γ} (hf : IsMonoidHom f) {s : Set M} (hs : IsSubmonoid s) :\n    IsSubmonoid («expr '' » f s) :=\n  { one_mem := ⟨1, hs.one_mem, hf.map_one⟩\n    mul_mem := fun a b ⟨x, hx⟩ ⟨y, hy⟩ => ⟨x * y, hs.mul_mem hx.1 hy.1, by rw [hf.map_mul, hx.2, hy.2]⟩ }\n#align is_submonoid.image IsSubmonoid.image\n#align is_add_submonoid.image IsAddSubmonoid.image\n-/\n\n",
 "finset_prod_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/-- The product of elements of a submonoid of a `comm_monoid` indexed by a `finset` is an element\nof the submonoid. -/\n@[to_additive\n      \"The sum of elements of an `add_submonoid` of an `add_comm_monoid` indexed by\\na `finset` is an element of the `add_submonoid`.\"]\ntheorem finset_prod_mem {M A} [CommMonoid M] {s : Set M} (hs : IsSubmonoid s) (f : A → M) :\n    ∀ t : Finset A,\n      (∀ b ∈ t, f b ∈ s) →\n        finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" t (f b) ∈ s\n  | ⟨m, hm⟩, _ => multiset_prod_mem hs _ (by simpa)\n#align finset_prod_mem finset_prod_mem\n\n",
 "exists_list_of_mem_closure":
 "/-- Given an element `a` of the submonoid of a monoid `M` generated by a set `s`, there exists\na list of elements of `s` whose product is `a`. -/\n@[to_additive\n      \"Given an element `a` of the `add_submonoid` of an `add_monoid M` generated by\\na set `s`, there exists a list of elements of `s` whose sum is `a`.\"]\ntheorem exists_list_of_mem_closure {s : Set M} {a : M} (h : a ∈ Closure s) :\n    ∃ l : List M, (∀ x ∈ l, x ∈ s) ∧ l.prod = a := by\n  induction h\n  case basic a ha => exists [a]; simp [ha]\n  case one => exists []; simp\n  case mul a b _ _ ha hb =>\n    rcases ha with ⟨la, ha, eqa⟩\n    rcases hb with ⟨lb, hb, eqb⟩\n    exists la ++ lb\n    simp [eqa.symm, eqb.symm, or_imp]\n    exact fun a => ⟨ha a, hb a⟩\n#align exists_list_of_mem_closure exists_list_of_mem_closure\n\n",
 "closure_subset":
 "/-- The submonoid generated by a set is contained in any submonoid that contains the set. -/\n@[to_additive \"The `add_submonoid` generated by a set is contained in any `add_submonoid` that\\ncontains the set.\"]\ntheorem closure_subset {s t : Set M} (ht : IsSubmonoid t) (h : s ⊆ t) : Closure s ⊆ t := fun a ha => by\n  induction ha <;> simp [h _, *, is_submonoid.one_mem, is_submonoid.mul_mem]\n#align closure_subset closure_subset\n\n",
 "closure_singleton":
 "#print closure_singleton /-\n/-- The submonoid generated by an element of a monoid equals the set of natural number powers of\n    the element. -/\n@[to_additive\n      \"The `add_submonoid` generated by an element of an `add_monoid` equals the set of\\nnatural number multiples of the element.\"]\ntheorem closure_singleton {x : M} : Closure ({x} : Set M) = powers x :=\n  Set.eq_of_subset_of_subset (closure_subset (powers.isSubmonoid x) <| Set.singleton_subset_iff.2 <| powers.self_mem) <|\n    IsSubmonoid.power_subset (closure.isSubmonoid _) <| Set.singleton_subset_iff.1 <| subset_closure\n#align closure_singleton closure_singleton\n-/\n\n",
 "closure_mono":
 "#print closure_mono /-\n/-- Given subsets `t` and `s` of a monoid `M`, if `s ⊆ t`, the submonoid of `M` generated by `s` is\n    contained in the submonoid generated by `t`. -/\n@[to_additive\n      \"Given subsets `t` and `s` of an `add_monoid M`, if `s ⊆ t`, the `add_submonoid`\\nof `M` generated by `s` is contained in the `add_submonoid` generated by `t`.\"]\ntheorem closure_mono {s t : Set M} (h : s ⊆ t) : Closure s ⊆ Closure t :=\n  closure_subset (closure.isSubmonoid t) <| Set.Subset.trans h subset_closure\n#align closure_mono closure_mono\n-/\n\n"}