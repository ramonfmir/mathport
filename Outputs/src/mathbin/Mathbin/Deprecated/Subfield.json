{"subset_closure":
 "theorem subset_closure : S ⊆ closure S := fun _ => mem_closure\n#align subset_closure subset_closure\n\n",
 "ring_closure_subset":
 "theorem ring_closure_subset : ring.closure S ⊆ closure S := fun x hx =>\n  ⟨x, hx, 1, ring.closure.is_subring.to_is_submonoid.one_mem, div_one x⟩\n#align ring_closure_subset ring_closure_subset\n\n",
 "pow_mem":
 "theorem is_subfield.pow_mem {a : F} {n : ℤ} {s : set F} (hs : is_subfield s) (h : a ∈ s) : a ^ n ∈ s :=\n  by\n  cases n\n  · rw [zpow_ofNat]\n    exact hs.to_is_subring.to_is_submonoid.pow_mem h\n  · rw [zpow_negSucc]\n    exact hs.inv_mem (hs.to_is_subring.to_is_submonoid.pow_mem h)\n#align is_subfield.pow_mem is_subfield.pow_mem\n\n",
 "mem_closure":
 "theorem mem_closure {a : F} (ha : a ∈ S) : a ∈ closure S :=\n  ring_closure_subset <| ring.mem_closure ha\n#align mem_closure mem_closure\n\n",
 "is_submonoid":
 "theorem closure.is_submonoid : is_submonoid (closure S) :=\n  { mul_mem := by\n      rintro _ _ ⟨p, hp, q, hq, hq0, rfl⟩ ⟨r, hr, s, hs, hs0, rfl⟩ <;>\n        exact\n          ⟨p * r, is_submonoid.mul_mem ring.closure.is_subring.to_is_submonoid hp hr, q * s,\n            is_submonoid.mul_mem ring.closure.is_subring.to_is_submonoid hq hs, (div_mul_div_comm _ _ _ _).symm⟩\n    one_mem := ring_closure_subset <| is_submonoid.one_mem ring.closure.is_subring.to_is_submonoid }\n#align closure.is_submonoid closure.is_submonoid\n\n",
 "is_subfield_Union_of_directed":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\ntheorem is_subfield_Union_of_directed {ι : Type _} [hι : nonempty ι] {s : ι → set F} (hs : ∀ i, is_subfield (s i))\n    (directed : ∀ i j, ∃ k, s i ⊆ s k ∧ s j ⊆ s k) :\n    is_subfield\n      («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (s i)) :=\n  { inv_mem := fun x hx =>\n      let ⟨i, hi⟩ := Set.mem_unionᵢ.1 hx\n      Set.mem_unionᵢ.2 ⟨i, (hs i).inv_mem hi⟩\n    to_is_subring := is_subring_Union_of_directed (fun i => (hs i).to_is_subring) Directed }\n#align is_subfield_Union_of_directed is_subfield_Union_of_directed\n\n",
 "is_subfield":
 "theorem closure.is_subfield : is_subfield (closure S) :=\n  have h0 : (0 : F) ∈ closure S :=\n    ring_closure_subset <| ring.closure.is_subring.to_is_add_subgroup.to_is_add_submonoid.zero_mem\n  {\n    closure.is_submonoid with\n    add_mem := by\n      intro a b ha hb\n      rcases id ha with ⟨p, hp, q, hq, rfl⟩\n      rcases id hb with ⟨r, hr, s, hs, rfl⟩\n      classical\n        by_cases hq0 : q = 0\n        · simp [hb, hq0]\n        by_cases hs0 : s = 0\n        · simp [ha, hs0]\n        exact\n          ⟨p * s + q * r,\n            is_add_submonoid.add_mem ring.closure.is_subring.to_is_add_subgroup.to_is_add_submonoid\n              (ring.closure.is_subring.to_is_submonoid.mul_mem hp hs)\n              (ring.closure.is_subring.to_is_submonoid.mul_mem hq hr),\n            q * s, ring.closure.is_subring.to_is_submonoid.mul_mem hq hs, (div_add_div p r hq0 hs0).symm⟩\n    zero_mem := h0\n    neg_mem := by\n      rintro _ ⟨p, hp, q, hq, rfl⟩\n      exact ⟨-p, ring.closure.is_subring.to_is_add_subgroup.neg_mem hp, q, hq, neg_div q p⟩\n    inv_mem := by\n      rintro _ ⟨p, hp, q, hq, rfl⟩\n      exact ⟨q, hq, p, hp, (inv_div _ _).symm⟩ }\n#align closure.is_subfield closure.is_subfield\n\n",
 "inter":
 "theorem is_subfield.inter {S₁ S₂ : set F} (hS₁ : is_subfield S₁) (hS₂ : is_subfield S₂) : is_subfield (S₁ ∩ S₂) :=\n  { is_subring.inter hS₁.to_is_subring hS₂.to_is_subring with\n    inv_mem := fun x hx => ⟨hS₁.inv_mem hx.1, hS₂.inv_mem hx.2⟩ }\n#align is_subfield.inter is_subfield.inter\n\n",
 "div_mem":
 "/-\nCopyright (c) 2018 Andreas Swerdlow. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Andreas Swerdlow\n-/\ntheorem is_subfield.div_mem {S : set F} (hS : is_subfield S) {x y : F} (hx : x ∈ S) (hy : y ∈ S) : x / y ∈ S :=\n  by\n  rw [div_eq_mul_inv]\n  exact hS.to_is_subring.to_is_submonoid.mul_mem hx (hS.inv_mem hy)\n#align is_subfield.div_mem is_subfield.div_mem\n\n",
 "closure_subset_iff":
 "theorem closure_subset_iff {s t : set F} (ht : is_subfield t) : closure s ⊆ t ↔ s ⊆ t :=\n  ⟨Set.Subset.trans subset_closure, closure_subset ht⟩\n#align closure_subset_iff closure_subset_iff\n\n",
 "closure_subset":
 "theorem closure_subset {T : set F} (hT : is_subfield T) (H : S ⊆ T) : closure S ⊆ T := by\n  rintro _ ⟨p, hp, q, hq, hq0, rfl⟩ <;>\n    exact hT.div_mem (ring.closure_subset hT.to_is_subring H hp) (ring.closure_subset hT.to_is_subring H hq)\n#align closure_subset closure_subset\n\n",
 "closure_mono":
 "theorem closure_mono {s t : set F} (H : s ⊆ t) : closure s ⊆ closure t :=\n  closure_subset closure.is_subfield <| Set.Subset.trans H subset_closure\n#align closure_mono closure_mono\n\n",
 "Inter":
 "theorem is_subfield.Inter {ι : Sort _} {S : ι → set F} (h : ∀ y : ι, is_subfield (S y)) : is_subfield (Set.interᵢ S) :=\n  { is_subring.Inter fun y => (h y).to_is_subring with\n    inv_mem := fun x hx => Set.mem_interᵢ.2 fun y => (h y).inv_mem <| Set.mem_interᵢ.1 hx y }\n#align is_subfield.Inter is_subfield.Inter\n\n"}