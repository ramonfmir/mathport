{"subset_closure":
 "#print subset_closure /-\ntheorem subset_closure : S ⊆ closure S := fun _ => mem_closure\n#align subset_closure subset_closure\n-/\n\n",
 "ring_closure_subset":
 "theorem ring_closure_subset : Ring.closure S ⊆ closure S := fun x hx =>\n  ⟨x, hx, 1, Ring.closure.isSubring.to_is_submonoid.one_mem, div_one x⟩\n#align ring_closure_subset ring_closure_subset\n\n",
 "pow_mem":
 "#print IsSubfield.pow_mem /-\ntheorem IsSubfield.pow_mem {a : F} {n : ℤ} {s : Set F} (hs : IsSubfield s) (h : a ∈ s) : a ^ n ∈ s :=\n  by\n  cases n\n  · rw [zpow_ofNat]\n    exact hs.to_is_subring.to_is_submonoid.pow_mem h\n  · rw [zpow_negSucc]\n    exact hs.inv_mem (hs.to_is_subring.to_is_submonoid.pow_mem h)\n#align is_subfield.pow_mem IsSubfield.pow_mem\n-/\n\n",
 "mem_closure":
 "theorem mem_closure {a : F} (ha : a ∈ S) : a ∈ closure S :=\n  ring_closure_subset <| Ring.mem_closure ha\n#align mem_closure mem_closure\n\n",
 "is_submonoid":
 "theorem closure.is_submonoid : IsSubmonoid (closure S) :=\n  { mul_mem := by\n      rintro _ _ ⟨p, hp, q, hq, hq0, rfl⟩ ⟨r, hr, s, hs, hs0, rfl⟩ <;>\n        exact\n          ⟨p * r, is_submonoid.mul_mem ring.closure.is_subring.to_is_submonoid hp hr, q * s,\n            is_submonoid.mul_mem ring.closure.is_subring.to_is_submonoid hq hs, (div_mul_div_comm _ _ _ _).symm⟩\n    one_mem := ring_closure_subset <| is_submonoid.one_mem Ring.closure.isSubring.to_is_submonoid }\n#align closure.is_submonoid closure.is_submonoid\n\n",
 "is_subfield":
 "theorem closure.is_subfield : IsSubfield (closure S) :=\n  have h0 : (0 : F) ∈ closure S :=\n    ring_closure_subset <| Ring.closure.isSubring.to_is_add_subgroup.to_is_add_submonoid.zero_mem\n  {\n    closure.isSubmonoid with\n    add_mem := by\n      intro a b ha hb\n      rcases id ha with ⟨p, hp, q, hq, rfl⟩\n      rcases id hb with ⟨r, hr, s, hs, rfl⟩\n      classical\n        by_cases hq0 : q = 0\n        · simp [hb, hq0]\n        by_cases hs0 : s = 0\n        · simp [ha, hs0]\n        exact\n          ⟨p * s + q * r,\n            is_add_submonoid.add_mem ring.closure.is_subring.to_is_add_subgroup.to_is_add_submonoid\n              (ring.closure.is_subring.to_is_submonoid.mul_mem hp hs)\n              (ring.closure.is_subring.to_is_submonoid.mul_mem hq hr),\n            q * s, ring.closure.is_subring.to_is_submonoid.mul_mem hq hs, (div_add_div p r hq0 hs0).symm⟩\n    zero_mem := h0\n    neg_mem := by\n      rintro _ ⟨p, hp, q, hq, rfl⟩\n      exact ⟨-p, ring.closure.is_subring.to_is_add_subgroup.neg_mem hp, q, hq, neg_div q p⟩\n    inv_mem := by\n      rintro _ ⟨p, hp, q, hq, rfl⟩\n      exact ⟨q, hq, p, hp, (inv_div _ _).symm⟩ }\n#align closure.is_subfield closure.is_subfield\n\n",
 "isSubfield_unionᵢ_of_directed":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n#print isSubfield_unionᵢ_of_directed /-\ntheorem isSubfield_unionᵢ_of_directed {ι : Type _} [hι : Nonempty ι] {s : ι → Set F} (hs : ∀ i, IsSubfield (s i))\n    (directed : ∀ i j, ∃ k, s i ⊆ s k ∧ s j ⊆ s k) :\n    IsSubfield\n      («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (s i)) :=\n  { inv_mem := fun x hx =>\n      let ⟨i, hi⟩ := Set.mem_unionᵢ.1 hx\n      Set.mem_unionᵢ.2 ⟨i, (hs i).inv_mem hi⟩\n    to_is_subring := isSubring_unionᵢ_of_directed (fun i => (hs i).to_is_subring) Directed }\n#align is_subfield_Union_of_directed isSubfield_unionᵢ_of_directed\n-/\n\n",
 "isSubfield":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n#print Range.isSubfield /-\ntheorem Range.isSubfield {K : Type _} [Field K] (f : «expr →+* » F K) : IsSubfield (Set.range f) :=\n  by\n  rw [← Set.image_univ]\n  apply Image.isSubfield _ Univ.isSubfield\n#align range.is_subfield Range.isSubfield\n-/\n\n",
 "interᵢ":
 "#print IsSubfield.interᵢ /-\ntheorem IsSubfield.interᵢ {ι : Sort _} {S : ι → Set F} (h : ∀ y : ι, IsSubfield (S y)) : IsSubfield (Set.interᵢ S) :=\n  { IsSubring.interᵢ fun y => (h y).to_is_subring with\n    inv_mem := fun x hx => Set.mem_interᵢ.2 fun y => (h y).inv_mem <| Set.mem_interᵢ.1 hx y }\n#align is_subfield.Inter IsSubfield.interᵢ\n-/\n\n",
 "inter":
 "#print IsSubfield.inter /-\ntheorem IsSubfield.inter {S₁ S₂ : Set F} (hS₁ : IsSubfield S₁) (hS₂ : IsSubfield S₂) : IsSubfield (S₁ ∩ S₂) :=\n  { IsSubring.inter hS₁.to_is_subring hS₂.to_is_subring with\n    inv_mem := fun x hx => ⟨hS₁.inv_mem hx.1, hS₂.inv_mem hx.2⟩ }\n#align is_subfield.inter IsSubfield.inter\n-/\n\n",
 "div_mem":
 "#print IsSubfield.div_mem /-\n/-\nCopyright (c) 2018 Andreas Swerdlow. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Andreas Swerdlow\n-/\ntheorem IsSubfield.div_mem {S : Set F} (hS : IsSubfield S) {x y : F} (hx : x ∈ S) (hy : y ∈ S) : x / y ∈ S :=\n  by\n  rw [div_eq_mul_inv]\n  exact hS.to_is_subring.to_is_submonoid.mul_mem hx (hS.inv_mem hy)\n#align is_subfield.div_mem IsSubfield.div_mem\n-/\n\n",
 "closure_subset_iff":
 "theorem closure_subset_iff {s t : Set F} (ht : IsSubfield t) : closure s ⊆ t ↔ s ⊆ t :=\n  ⟨Set.Subset.trans subset_closure, closure_subset ht⟩\n#align closure_subset_iff closure_subset_iff\n\n",
 "closure_subset":
 "theorem closure_subset {T : Set F} (hT : IsSubfield T) (H : S ⊆ T) : closure S ⊆ T := by\n  rintro _ ⟨p, hp, q, hq, hq0, rfl⟩ <;>\n    exact hT.div_mem (Ring.closure_subset hT.to_is_subring H hp) (Ring.closure_subset hT.to_is_subring H hq)\n#align closure_subset closure_subset\n\n",
 "closure_mono":
 "#print closure_mono /-\ntheorem closure_mono {s t : Set F} (H : s ⊆ t) : closure s ⊆ closure t :=\n  closure_subset closure.isSubfield <| Set.Subset.trans H subset_closure\n#align closure_mono closure_mono\n-/\n\n"}