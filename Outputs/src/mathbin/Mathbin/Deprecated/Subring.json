{"subset_closure":
 "#print subset_closure /-\ntheorem subset_closure : s ⊆ closure s := fun _ => mem_closure\n#align subset_closure subset_closure\n-/\n\n",
 "rec_on":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `sym.cons' -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `sym.cons' -/\n@[elab_as_elim]\nprotected theorem in_closure.rec_on {C : R → Prop} {x : R} (hx : x ∈ closure s) (h1 : C 1) (hneg1 : C (-1))\n    (hs : ∀ z ∈ s, ∀ n, C n → C (z * n)) (ha : ∀ {x y}, C x → C y → C (x + y)) : C x :=\n  by\n  have h0 : C 0 := add_neg_self (1 : R) ▸ ha h1 hneg1\n  rcases exists_list_of_mem_closure hx with ⟨L, HL, rfl⟩\n  clear hx\n  induction' L with hd tl ih\n  · exact h0\n  rw [List.forall_mem_cons] at HL\n  suffices C (List.prod hd) by\n    rw [list.map_cons, List.sum_cons]\n    exact ha this (ih HL.2)\n  replace HL := HL.1\n  clear ih tl\n  rsuffices ⟨L, HL', HP | HP⟩ :\n    ∃ L : List R, (∀ x ∈ L, x ∈ s) ∧ (List.prod hd = List.prod L ∨ List.prod hd = -List.prod L)\n  · rw [HP]\n    clear HP HL hd\n    induction' L with hd tl ih\n    · exact h1\n    rw [List.forall_mem_cons] at HL'\n    rw [List.prod_cons]\n    exact hs _ HL'.1 _ (ih HL'.2)\n  · rw [HP]\n    clear HP HL hd\n    induction' L with hd tl ih\n    · exact hneg1\n    rw [List.prod_cons, neg_mul_eq_mul_neg]\n    rw [List.forall_mem_cons] at HL'\n    exact hs _ HL'.1 _ (ih HL'.2)\n  induction' hd with hd tl ih\n  · exact ⟨[], List.forall_mem_nil _, or.inl rfl⟩\n  rw [List.forall_mem_cons] at HL\n  rcases ih HL.2 with ⟨L, HL', HP | HP⟩ <;> cases' HL.1 with hhd hhd\n  · exact ⟨sym.cons' hd L, List.forall_mem_cons.2 ⟨hhd, HL'⟩, or.inl <| by rw [List.prod_cons, List.prod_cons, HP]⟩\n  · exact ⟨L, HL', or.inr <| by rw [List.prod_cons, hhd, neg_one_mul, HP]⟩\n  ·\n    exact\n      ⟨sym.cons' hd L, List.forall_mem_cons.2 ⟨hhd, HL'⟩,\n        or.inr <| by rw [List.prod_cons, List.prod_cons, HP, neg_mul_eq_mul_neg]⟩\n  · exact ⟨L, HL', or.inl <| by rw [List.prod_cons, hhd, HP, neg_one_mul, neg_neg]⟩\n#align in_closure.rec_on in_closure.rec_on\n\n",
 "mem_closure":
 "theorem mem_closure {a : R} : a ∈ s → a ∈ closure s :=\n  AddGroup.mem_closure ∘ @Monoid.subset_closure _ _ _ _\n#align mem_closure mem_closure\n\n",
 "is_subring_set_range":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem is_subring_set_range {R : Type u} {S : Type v} [Ring R] [Ring S] (f : «expr →+* » R S) :\n    IsSubring (Set.range f) :=\n  { IsAddGroupHom.range_addSubgroup f.to_is_add_group_hom, Range.isSubmonoid f.to_is_monoid_hom with }\n#align is_subring_set_range is_subring_set_range\n\n",
 "is_subring_preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/-\nCopyright (c) 2018 Johan Commelin. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johan Commelin\n-/\ntheorem is_subring_preimage {R : Type u} {S : Type v} [Ring R] [Ring S] (f : «expr →+* » R S) {s : Set S}\n    (hs : IsSubring s) : IsSubring («expr ⁻¹' » f s) :=\n  { IsAddGroupHom.preimage f.to_is_add_group_hom hs.to_is_add_subgroup,\n    IsSubmonoid.preimage f.to_is_monoid_hom hs.to_is_submonoid with }\n#align is_subring_preimage is_subring_preimage\n\n",
 "is_subring_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem is_subring_image {R : Type u} {S : Type v} [Ring R] [Ring S] (f : «expr →+* » R S) {s : Set R}\n    (hs : IsSubring s) : IsSubring («expr '' » f s) :=\n  { IsAddGroupHom.image_addSubgroup f.to_is_add_group_hom hs.to_is_add_subgroup,\n    IsSubmonoid.image f.to_is_monoid_hom hs.to_is_submonoid with }\n#align is_subring_image is_subring_image\n\n",
 "is_subring":
 "theorem closure.is_subring : IsSubring (closure s) :=\n  {\n    AddGroup.closure.isAddSubgroup\n      _ with\n    one_mem := AddGroup.mem_closure <| is_submonoid.one_mem <| Monoid.closure.isSubmonoid _\n    mul_mem := fun a b ha hb =>\n      add_group.in_closure.rec_on hb\n        (fun c hc =>\n          add_group.in_closure.rec_on ha\n            (fun d hd => AddGroup.subset_closure ((Monoid.closure.isSubmonoid _).mul_mem hd hc))\n            ((MulZeroClass.zero_mul c).symm ▸ (AddGroup.closure.isAddSubgroup _).zero_mem)\n            (fun d hd hdc => neg_mul_eq_neg_mul d c ▸ (AddGroup.closure.isAddSubgroup _).neg_mem hdc)\n            fun d e hd he hdc hec => (add_mul d e c).symm ▸ (AddGroup.closure.isAddSubgroup _).add_mem hdc hec)\n        ((MulZeroClass.mul_zero a).symm ▸ (AddGroup.closure.isAddSubgroup _).zero_mem)\n        (fun c hc hac => neg_mul_eq_mul_neg a c ▸ (AddGroup.closure.isAddSubgroup _).neg_mem hac)\n        fun c d hc hd hac had => (mul_add a c d).symm ▸ (AddGroup.closure.isAddSubgroup _).add_mem hac had }\n#align closure.is_subring closure.is_subring\n\n",
 "isSubring_unionᵢ_of_directed":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n#print isSubring_unionᵢ_of_directed /-\ntheorem isSubring_unionᵢ_of_directed {ι : Type _} [hι : Nonempty ι] {s : ι → Set R} (h : ∀ i, IsSubring (s i))\n    (directed : ∀ i j, ∃ k, s i ⊆ s k ∧ s j ⊆ s k) :\n    IsSubring («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (s i)) :=\n  { to_is_add_subgroup := isAddSubgroup_unionᵢ_of_directed (fun i => (h i).to_is_add_subgroup) Directed\n    to_is_submonoid := isSubmonoid_unionᵢ_of_directed (fun i => (h i).to_is_submonoid) Directed }\n#align is_subring_Union_of_directed isSubring_unionᵢ_of_directed\n-/\n\n",
 "interᵢ":
 "#print IsSubring.interᵢ /-\ntheorem IsSubring.interᵢ {ι : Sort _} {S : ι → Set R} (h : ∀ y : ι, IsSubring (S y)) : IsSubring (Set.interᵢ S) :=\n  { IsAddSubgroup.interᵢ fun i => (h i).to_is_add_subgroup, IsSubmonoid.interᵢ fun i => (h i).to_is_submonoid with }\n#align is_subring.Inter IsSubring.interᵢ\n-/\n\n",
 "inter":
 "#print IsSubring.inter /-\ntheorem IsSubring.inter {S₁ S₂ : Set R} (hS₁ : IsSubring S₁) (hS₂ : IsSubring S₂) : IsSubring (S₁ ∩ S₂) :=\n  { IsAddSubgroup.inter hS₁.to_is_add_subgroup hS₂.to_is_add_subgroup,\n    IsSubmonoid.inter hS₁.to_is_submonoid hS₂.to_is_submonoid with }\n#align is_subring.inter IsSubring.inter\n-/\n\n",
 "image_closure":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem image_closure {S : Type _} [Ring S] (f : «expr →+* » R S) (s : Set R) :\n    «expr '' » f (closure s) = closure («expr '' » f s) :=\n  le_antisymm\n    (by\n      rintro _ ⟨x, hx, rfl⟩\n      apply in_closure.rec_on hx <;> intros\n      · rw [f.map_one]\n        apply closure.is_subring.to_is_submonoid.one_mem\n      · rw [f.map_neg, f.map_one]\n        apply closure.is_subring.to_is_add_subgroup.neg_mem\n        apply closure.is_subring.to_is_submonoid.one_mem\n      · rw [f.map_mul]\n        apply closure.is_subring.to_is_submonoid.mul_mem <;> solve_by_elim [subset_closure, Set.mem_image_of_mem]\n      · rw [f.map_add]\n        apply closure.is_subring.to_is_add_submonoid.add_mem\n        assumption')\n    (closure_subset (RingHom.isSubring_image _ closure.isSubring) <| Set.image_subset _ subset_closure)\n#align image_closure image_closure\n\n",
 "exists_list_of_mem_closure":
 "theorem exists_list_of_mem_closure {a : R} (h : a ∈ closure s) :\n    ∃ L : List (List R), (∀ l ∈ L, ∀ x ∈ l, x ∈ s ∨ x = (-1 : R)) ∧ (L.map List.prod).sum = a :=\n  add_group.in_closure.rec_on h\n    (fun x hx =>\n      match x, Monoid.exists_list_of_mem_closure hx with\n      | _, ⟨L, h1, rfl⟩ => ⟨[L], List.forall_mem_singleton.2 fun r hr => or.inl (h1 r hr), zero_add _⟩)\n    ⟨[], List.forall_mem_nil _, rfl⟩\n    (fun b _ ih =>\n      match b, ih with\n      | _, ⟨L1, h1, rfl⟩ =>\n        ⟨L1.map (List.cons (-1)), fun L2 h2 =>\n          match L2, List.mem_map.1 h2 with\n          | _, ⟨L3, h3, rfl⟩ => List.forall_mem_cons.2 ⟨or.inr rfl, h1 L3 h3⟩,\n          by\n          simp only [list.map_map, (· ∘ ·), List.prod_cons, neg_one_mul] <;>\n            exact\n              list.rec_on L1 neg_zero.symm fun hd tl ih => by\n                rw [list.map_cons, List.sum_cons, ih, list.map_cons, List.sum_cons, neg_add]⟩)\n    fun r1 r2 hr1 hr2 ih1 ih2 =>\n    match r1, r2, ih1, ih2 with\n    | _, _, ⟨L1, h1, rfl⟩, ⟨L2, h2, rfl⟩ =>\n      ⟨L1 ++ L2, List.forall_mem_append.2 ⟨h1, h2⟩, by rw [list.map_append, List.sum_append]⟩\n#align exists_list_of_mem_closure exists_list_of_mem_closure\n\n",
 "closure_subset_iff":
 "theorem closure_subset_iff {s t : Set R} (ht : IsSubring t) : closure s ⊆ t ↔ s ⊆ t :=\n  (AddGroup.closure_subset_iff ht.to_is_add_subgroup).trans\n    ⟨Set.Subset.trans Monoid.subset_closure, Monoid.closure_subset ht.to_is_submonoid⟩\n#align closure_subset_iff closure_subset_iff\n\n",
 "closure_subset":
 "theorem closure_subset {t : Set R} (ht : IsSubring t) : s ⊆ t → closure s ⊆ t :=\n  AddGroup.closure_subset ht.to_is_add_subgroup ∘ Monoid.closure_subset ht.to_is_submonoid\n#align closure_subset closure_subset\n\n",
 "closure_mono":
 "#print closure_mono /-\ntheorem closure_mono {s t : Set R} (H : s ⊆ t) : closure s ⊆ closure t :=\n  closure_subset closure.isSubring <| Set.Subset.trans H subset_closure\n#align closure_mono closure_mono\n-/\n\n"}