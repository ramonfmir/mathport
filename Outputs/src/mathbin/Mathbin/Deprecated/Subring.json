{"subset_closure":
 "theorem subset_closure : s ⊆ closure s := fun _ => mem_closure\n#align subset_closure subset_closure\n\n",
 "rec_on":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `sym.cons' -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `sym.cons' -/\n@[elab_as_elim]\nprotected theorem in_closure.rec_on {C : R → Prop} {x : R} (hx : x ∈ closure s) (h1 : C 1) (hneg1 : C (-1))\n    (hs : ∀ z ∈ s, ∀ n, C n → C (z * n)) (ha : ∀ {x y}, C x → C y → C (x + y)) : C x :=\n  by\n  have h0 : C 0 := add_neg_self (1 : R) ▸ ha h1 hneg1\n  rcases exists_list_of_mem_closure hx with ⟨L, HL, rfl⟩\n  clear hx\n  induction' L with hd tl ih\n  · exact h0\n  rw [List.forall_mem_cons] at HL\n  suffices C (List.prod hd) by\n    rw [list.map_cons, list.sum_cons]\n    exact ha this (ih HL.2)\n  replace HL := HL.1\n  clear ih tl\n  rsuffices ⟨L, HL', HP | HP⟩ :\n    ∃ L : list R, (∀ x ∈ L, x ∈ s) ∧ (List.prod hd = List.prod L ∨ List.prod hd = -List.prod L)\n  · rw [HP]\n    clear HP HL hd\n    induction' L with hd tl ih\n    · exact h1\n    rw [List.forall_mem_cons] at HL'\n    rw [List.prod_cons]\n    exact hs _ HL'.1 _ (ih HL'.2)\n  · rw [HP]\n    clear HP HL hd\n    induction' L with hd tl ih\n    · exact hneg1\n    rw [List.prod_cons, neg_mul_eq_mul_neg]\n    rw [List.forall_mem_cons] at HL'\n    exact hs _ HL'.1 _ (ih HL'.2)\n  induction' hd with hd tl ih\n  · exact ⟨[], List.forall_mem_nil _, or.inl rfl⟩\n  rw [List.forall_mem_cons] at HL\n  rcases ih HL.2 with ⟨L, HL', HP | HP⟩ <;> cases' HL.1 with hhd hhd\n  · exact ⟨sym.cons' hd L, List.forall_mem_cons.2 ⟨hhd, HL'⟩, or.inl <| by rw [List.prod_cons, List.prod_cons, HP]⟩\n  · exact ⟨L, HL', or.inr <| by rw [List.prod_cons, hhd, neg_one_mul, HP]⟩\n  ·\n    exact\n      ⟨sym.cons' hd L, List.forall_mem_cons.2 ⟨hhd, HL'⟩,\n        or.inr <| by rw [List.prod_cons, List.prod_cons, HP, neg_mul_eq_mul_neg]⟩\n  · exact ⟨L, HL', or.inl <| by rw [List.prod_cons, hhd, HP, neg_one_mul, neg_neg]⟩\n#align in_closure.rec_on in_closure.rec_on\n\n",
 "mem_closure":
 "theorem mem_closure {a : R} : a ∈ s → a ∈ closure s :=\n  add_group.mem_closure ∘ @monoid.subset_closure _ _ _ _\n#align mem_closure mem_closure\n\n",
 "is_subring_set_range":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem is_subring_set_range {R : Type u} {S : Type v} [Ring R] [Ring S] (f : «expr →+* » R S) :\n    is_subring (Set.range f) :=\n  { is_add_group_hom.range_add_subgroup f.to_is_add_group_hom, range.is_submonoid f.to_is_monoid_hom with }\n#align is_subring_set_range is_subring_set_range\n\n",
 "is_subring_preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/-\nCopyright (c) 2018 Johan Commelin. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johan Commelin\n-/\ntheorem is_subring_preimage {R : Type u} {S : Type v} [Ring R] [Ring S] (f : «expr →+* » R S) {s : set S}\n    (hs : is_subring s) : is_subring («expr ⁻¹' » f s) :=\n  { is_add_group_hom.preimage f.to_is_add_group_hom hs.to_is_add_subgroup,\n    is_submonoid.preimage f.to_is_monoid_hom hs.to_is_submonoid with }\n#align is_subring_preimage is_subring_preimage\n\n",
 "is_subring_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem is_subring_image {R : Type u} {S : Type v} [Ring R] [Ring S] (f : «expr →+* » R S) {s : set R}\n    (hs : is_subring s) : is_subring («expr '' » f s) :=\n  { is_add_group_hom.image_add_subgroup f.to_is_add_group_hom hs.to_is_add_subgroup,\n    is_submonoid.image f.to_is_monoid_hom hs.to_is_submonoid with }\n#align is_subring_image is_subring_image\n\n",
 "is_subring_Union_of_directed":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\ntheorem is_subring_Union_of_directed {ι : Type _} [hι : nonempty ι] {s : ι → set R} (h : ∀ i, is_subring (s i))\n    (directed : ∀ i j, ∃ k, s i ⊆ s k ∧ s j ⊆ s k) :\n    is_subring\n      («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (s i)) :=\n  { to_is_add_subgroup := is_add_subgroup_Union_of_directed (fun i => (h i).to_is_add_subgroup) Directed\n    to_is_submonoid := is_submonoid_Union_of_directed (fun i => (h i).to_is_submonoid) Directed }\n#align is_subring_Union_of_directed is_subring_Union_of_directed\n\n",
 "is_subring":
 "theorem closure.is_subring : is_subring (closure s) :=\n  {\n    add_group.closure.is_add_subgroup\n      _ with\n    one_mem := add_group.mem_closure <| is_submonoid.one_mem <| monoid.closure.is_submonoid _\n    mul_mem := fun a b ha hb =>\n      add_group.in_closure.rec_on hb\n        (fun c hc =>\n          add_group.in_closure.rec_on ha\n            (fun d hd => add_group.subset_closure ((monoid.closure.is_submonoid _).mul_mem hd hc))\n            ((zero_mul c).symm ▸ (add_group.closure.is_add_subgroup _).zero_mem)\n            (fun d hd hdc => neg_mul_eq_neg_mul d c ▸ (add_group.closure.is_add_subgroup _).neg_mem hdc)\n            fun d e hd he hdc hec => (add_mul d e c).symm ▸ (add_group.closure.is_add_subgroup _).add_mem hdc hec)\n        ((mul_zero a).symm ▸ (add_group.closure.is_add_subgroup _).zero_mem)\n        (fun c hc hac => neg_mul_eq_mul_neg a c ▸ (add_group.closure.is_add_subgroup _).neg_mem hac)\n        fun c d hc hd hac had => (mul_add a c d).symm ▸ (add_group.closure.is_add_subgroup _).add_mem hac had }\n#align closure.is_subring closure.is_subring\n\n",
 "inter":
 "theorem is_subring.inter {S₁ S₂ : set R} (hS₁ : is_subring S₁) (hS₂ : is_subring S₂) : is_subring (S₁ ∩ S₂) :=\n  { is_add_subgroup.inter hS₁.to_is_add_subgroup hS₂.to_is_add_subgroup,\n    is_submonoid.inter hS₁.to_is_submonoid hS₂.to_is_submonoid with }\n#align is_subring.inter is_subring.inter\n\n",
 "image_closure":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem image_closure {S : Type _} [Ring S] (f : «expr →+* » R S) (s : set R) :\n    «expr '' » f (closure s) = closure («expr '' » f s) :=\n  le_antisymm\n    (by\n      rintro _ ⟨x, hx, rfl⟩\n      apply in_closure.rec_on hx <;> intros\n      · rw [f.map_one]\n        apply closure.is_subring.to_is_submonoid.one_mem\n      · rw [f.map_neg, f.map_one]\n        apply closure.is_subring.to_is_add_subgroup.neg_mem\n        apply closure.is_subring.to_is_submonoid.one_mem\n      · rw [f.map_mul]\n        apply closure.is_subring.to_is_submonoid.mul_mem <;> solve_by_elim [subset_closure, Set.mem_image_of_mem]\n      · rw [f.map_add]\n        apply closure.is_subring.to_is_add_submonoid.add_mem\n        assumption')\n    (closure_subset (ring_hom.is_subring_image _ closure.is_subring) <| Set.image_subset _ subset_closure)\n#align image_closure image_closure\n\n",
 "exists_list_of_mem_closure":
 "theorem exists_list_of_mem_closure {a : R} (h : a ∈ closure s) :\n    ∃ L : list (list R), (∀ l ∈ L, ∀ x ∈ l, x ∈ s ∨ x = (-1 : R)) ∧ (L.map List.prod).sum = a :=\n  add_group.in_closure.rec_on h\n    (fun x hx =>\n      match x, monoid.exists_list_of_mem_closure hx with\n      | _, ⟨L, h1, rfl⟩ => ⟨[L], List.forall_mem_singleton.2 fun r hr => or.inl (h1 r hr), zero_add _⟩)\n    ⟨[], List.forall_mem_nil _, rfl⟩\n    (fun b _ ih =>\n      match b, ih with\n      | _, ⟨L1, h1, rfl⟩ =>\n        ⟨L1.map (list.cons (-1)), fun L2 h2 =>\n          match L2, List.mem_map'.1 h2 with\n          | _, ⟨L3, h3, rfl⟩ => List.forall_mem_cons.2 ⟨or.inr rfl, h1 L3 h3⟩,\n          by\n          simp only [list.map_map, (· ∘ ·), List.prod_cons, neg_one_mul] <;>\n            exact\n              list.rec_on L1 neg_zero.symm fun hd tl ih => by\n                rw [list.map_cons, list.sum_cons, ih, list.map_cons, list.sum_cons, neg_add]⟩)\n    fun r1 r2 hr1 hr2 ih1 ih2 =>\n    match r1, r2, ih1, ih2 with\n    | _, _, ⟨L1, h1, rfl⟩, ⟨L2, h2, rfl⟩ =>\n      ⟨L1 ++ L2, List.forall_mem_append.2 ⟨h1, h2⟩, by rw [list.map_append, list.sum_append]⟩\n#align exists_list_of_mem_closure exists_list_of_mem_closure\n\n",
 "closure_subset_iff":
 "theorem closure_subset_iff {s t : set R} (ht : is_subring t) : closure s ⊆ t ↔ s ⊆ t :=\n  (add_group.closure_subset_iff ht.to_is_add_subgroup).trans\n    ⟨Set.Subset.trans monoid.subset_closure, monoid.closure_subset ht.to_is_submonoid⟩\n#align closure_subset_iff closure_subset_iff\n\n",
 "closure_subset":
 "theorem closure_subset {t : set R} (ht : is_subring t) : s ⊆ t → closure s ⊆ t :=\n  add_group.closure_subset ht.to_is_add_subgroup ∘ monoid.closure_subset ht.to_is_submonoid\n#align closure_subset closure_subset\n\n",
 "closure_mono":
 "theorem closure_mono {s t : set R} (H : s ⊆ t) : closure s ⊆ closure t :=\n  closure_subset closure.is_subring <| Set.Subset.trans H subset_closure\n#align closure_mono closure_mono\n\n",
 "Inter":
 "theorem is_subring.Inter {ι : Sort _} {S : ι → set R} (h : ∀ y : ι, is_subring (S y)) : is_subring (Set.interᵢ S) :=\n  { is_add_subgroup.Inter fun i => (h i).to_is_add_subgroup, is_submonoid.Inter fun i => (h i).to_is_submonoid with }\n#align is_subring.Inter is_subring.Inter\n\n"}