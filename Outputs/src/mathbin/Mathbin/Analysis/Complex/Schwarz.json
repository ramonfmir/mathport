{"schwarz_aux":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.lt -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/-\nCopyright (c) 2022 Yury G. Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury G. Kudryashov\n-/\n/-- An auxiliary lemma for `complex.norm_dslope_le_div_of_maps_to_ball`. -/\ntheorem schwarz_aux {f : exprℂ → exprℂ} (hd : differentiable_on (exprℂ) f (ball c R₁))\n    (h_maps : MapsTo f (ball c R₁) (ball (f c) R₂)) (hz : z ∈ ball c R₁) : «expr‖ ‖» (dslope f c z) ≤ R₂ / R₁ :=\n  by\n  have hR₁ : 0 < R₁ := nonempty_ball.1 ⟨z, hz⟩\n  suffices\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\"\n      (nhds_within.lt R₁) («expr‖ ‖» (dslope f c z) ≤ R₂ / r)\n    by\n    refine' ge_of_tendsto _ this\n    exact (tendsto_const_nhds.div tendsto_id hR₁.ne').mono_left nhds_within_le_nhds\n  rw [mem_ball] at hz\n  filter_upwards [Ioo_mem_nhds_within_Iio ⟨hz, le_rfl⟩] with r hr\n  have hr₀ : 0 < r := dist_nonneg.trans_lt hr.1\n  replace hd : diff_cont_on_cl (exprℂ) (dslope f c) (ball c r)\n  · refine' differentiable_on.diff_cont_on_cl _\n    rw [closure_ball c hr₀.ne']\n    exact ((differentiable_on_dslope <| ball_mem_nhds _ hR₁).mpr hd).mono (closed_ball_subset_ball hr.2)\n  refine' norm_le_of_forall_mem_frontier_norm_le bounded_ball hd _ _\n  · rw [frontier_ball c hr₀.ne']\n    intro z hz\n    have hz' : z ≠ c := ne_of_mem_sphere hz hr₀.ne'\n    rw [dslope_of_ne _ hz', slope_def_module, norm_smul, norm_inv, mem_sphere_iff_norm.1 hz, ← div_eq_inv_mul,\n      div_le_div_right hr₀, ← dist_eq_norm]\n    exact\n      le_of_lt\n        (h_maps\n          (mem_ball.2\n            (by\n              rw [mem_sphere.1 hz]\n              exact hr.2)))\n  · rw [closure_ball c hr₀.ne', mem_closed_ball]\n    exact hr.1.le\n#align schwarz_aux schwarz_aux\n\n",
 "norm_dslope_le_div_of_maps_to_ball":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/-- Two cases of the **Schwarz Lemma** (derivative and distance), merged together. -/\ntheorem norm_dslope_le_div_of_maps_to_ball (hd : differentiable_on (exprℂ) f (ball c R₁))\n    (h_maps : MapsTo f (ball c R₁) (ball (f c) R₂)) (hz : z ∈ ball c R₁) : «expr‖ ‖» (dslope f c z) ≤ R₂ / R₁ :=\n  by\n  have hR₁ : 0 < R₁ := nonempty_ball.1 ⟨z, hz⟩\n  have hR₂ : 0 < R₂ := nonempty_ball.1 ⟨f z, h_maps hz⟩\n  cases' eq_or_ne (dslope f c z) 0 with hc hc\n  · rw [hc, norm_zero]\n    exact div_nonneg hR₂.le hR₁.le\n  rcases exists_dual_vector (exprℂ) _ hc with ⟨g, hg, hgf⟩\n  have hg' : «expr‖ ‖₊» g = 1 := nnreal.eq hg\n  have hg₀ : «expr‖ ‖₊» g ≠ 0 := by simpa only [hg'] using one_ne_zero\n  calc\n    «expr‖ ‖» (dslope f c z) = «expr‖ ‖» (dslope (g ∘ f) c z) :=\n      by\n      rw [g.dslope_comp, hgf, is_R_or_C.norm_of_real, norm_norm]\n      exact fun _ => hd.differentiable_at (ball_mem_nhds _ hR₁)\n    _ ≤ R₂ / R₁ :=\n      by\n      refine' schwarz_aux (g.differentiable.comp_differentiable_on hd) (maps_to.comp _ h_maps) hz\n      simpa only [hg', nnreal.coe_one, one_mul] using g.lipschitz.maps_to_ball hg₀ (f c) R₂\n    \n#align norm_dslope_le_div_of_maps_to_ball norm_dslope_le_div_of_maps_to_ball\n\n",
 "norm_deriv_le_div_of_maps_to_ball":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/-- The **Schwarz Lemma**: if `f : ℂ → E` sends an open disk with center `c` and a positive radius\n`R₁` to an open ball with center `f c` and radius `R₂`, then the absolute value of the derivative of\n`f` at `c` is at most the ratio `R₂ / R₁`. -/\ntheorem norm_deriv_le_div_of_maps_to_ball (hd : differentiable_on (exprℂ) f (ball c R₁))\n    (h_maps : MapsTo f (ball c R₁) (ball (f c) R₂)) (h₀ : 0 < R₁) : «expr‖ ‖» (deriv f c) ≤ R₂ / R₁ := by\n  simpa only [dslope_same] using norm_dslope_le_div_of_maps_to_ball hd h_maps (mem_ball_self h₀)\n#align norm_deriv_le_div_of_maps_to_ball norm_deriv_le_div_of_maps_to_ball\n\n",
 "dist_le_div_mul_dist_of_maps_to_ball":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/-- The **Schwarz Lemma**: if `f : ℂ → E` sends an open disk with center `c` and radius `R₁` to an\nopen ball with center `f c` and radius `R₂`, then for any `z` in the former disk we have\n`dist (f z) (f c) ≤ (R₂ / R₁) * dist z c`. -/\ntheorem dist_le_div_mul_dist_of_maps_to_ball (hd : differentiable_on (exprℂ) f (ball c R₁))\n    (h_maps : MapsTo f (ball c R₁) (ball (f c) R₂)) (hz : z ∈ ball c R₁) : dist (f z) (f c) ≤ R₂ / R₁ * dist z c :=\n  by\n  rcases eq_or_ne z c with (rfl | hne); · simp only [dist_self, mul_zero]\n  simpa only [dslope_of_ne _ hne, slope_def_module, norm_smul, norm_inv, ← div_eq_inv_mul, ← dist_eq_norm,\n    div_le_iff (dist_pos.2 hne)] using norm_dslope_le_div_of_maps_to_ball hd h_maps hz\n#align dist_le_div_mul_dist_of_maps_to_ball dist_le_div_mul_dist_of_maps_to_ball\n\n",
 "dist_le_dist_of_maps_to_ball_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/-- The **Schwarz Lemma**: if `f : ℂ → ℂ` sends an open disk to itself and the center `c` of this\ndisk to itself, then for any point `z` of this disk we have `dist (f z) c ≤ dist z c`. -/\ntheorem dist_le_dist_of_maps_to_ball_self (hd : differentiable_on (exprℂ) f (ball c R))\n    (h_maps : MapsTo f (ball c R) (ball c R)) (hc : f c = c) (hz : z ∈ ball c R) : dist (f z) c ≤ dist z c :=\n  by\n  have hR : 0 < R := nonempty_ball.1 ⟨z, hz⟩\n  simpa only [hc, div_self hR.ne', one_mul] using dist_le_div_mul_dist_of_maps_to_ball hd (by rwa [hc]) hz\n#align dist_le_dist_of_maps_to_ball_self dist_le_dist_of_maps_to_ball_self\n\n",
 "affine_of_maps_to_ball_of_exists_norm_dslope_eq_div'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem affine_of_maps_to_ball_of_exists_norm_dslope_eq_div' [complete_space E] [strict_convex_space (exprℝ) E]\n    (hd : differentiable_on (exprℂ) f (ball c R₁)) (h_maps : Set.MapsTo f (ball c R₁) (ball (f c) R₂))\n    (h_z₀ : ∃ z₀ ∈ ball c R₁, «expr‖ ‖» (dslope f c z₀) = R₂ / R₁) :\n    ∃ C : E, «expr‖ ‖» C = R₂ / R₁ ∧ Set.EqOn f (fun z => f c + «expr • » (z - c) C) (ball c R₁) :=\n  let ⟨z₀, h_z₀, h_eq⟩ := h_z₀\n  ⟨dslope f c z₀, h_eq, affine_of_maps_to_ball_of_exists_norm_dslope_eq_div hd h_maps h_z₀ h_eq⟩\n#align affine_of_maps_to_ball_of_exists_norm_dslope_eq_div' affine_of_maps_to_ball_of_exists_norm_dslope_eq_div'\n\n",
 "affine_of_maps_to_ball_of_exists_norm_dslope_eq_div":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- Equality case in the **Schwarz Lemma**: in the setup of `norm_dslope_le_div_of_maps_to_ball`, if\n`‖dslope f c z₀‖ = R₂ / R₁` holds at a point in the ball then the map `f` is affine. -/\ntheorem affine_of_maps_to_ball_of_exists_norm_dslope_eq_div [complete_space E] [strict_convex_space (exprℝ) E]\n    (hd : differentiable_on (exprℂ) f (ball c R₁)) (h_maps : Set.MapsTo f (ball c R₁) (ball (f c) R₂))\n    (h_z₀ : z₀ ∈ ball c R₁) (h_eq : «expr‖ ‖» (dslope f c z₀) = R₂ / R₁) :\n    Set.EqOn f (fun z => f c + «expr • » (z - c) (dslope f c z₀)) (ball c R₁) :=\n  by\n  set g := dslope f c\n  rintro z hz\n  by_cases z = c\n  · simp [h]\n  have h_R₁ : 0 < R₁ := nonempty_ball.mp ⟨_, h_z₀⟩\n  have g_le_div : ∀ z ∈ ball c R₁, «expr‖ ‖» (g z) ≤ R₂ / R₁ := fun z hz =>\n    norm_dslope_le_div_of_maps_to_ball hd h_maps hz\n  have g_max : is_max_on (norm ∘ g) (ball c R₁) z₀ := is_max_on_iff.mpr fun z hz => by simpa [h_eq] using g_le_div z hz\n  have g_diff : differentiable_on (exprℂ) g (ball c R₁) :=\n    (differentiable_on_dslope (is_open_ball.mem_nhds (mem_ball_self h_R₁))).mpr hd\n  have : g z = g z₀ :=\n    eq_on_of_is_preconnected_of_is_max_on_norm (convex_ball c R₁).is_preconnected is_open_ball g_diff h_z₀ g_max hz\n  simp [← this]\n#align affine_of_maps_to_ball_of_exists_norm_dslope_eq_div affine_of_maps_to_ball_of_exists_norm_dslope_eq_div\n\n",
 "abs_le_abs_of_maps_to_ball_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/-- The **Schwarz Lemma**: if `f : ℂ → ℂ` sends an open disk with center `0` to itself, the for any\npoint `z` of this disk we have `abs (f z) ≤ abs z`. -/\ntheorem abs_le_abs_of_maps_to_ball_self (hd : differentiable_on (exprℂ) f (ball 0 R))\n    (h_maps : MapsTo f (ball 0 R) (ball 0 R)) (h₀ : f 0 = 0) (hz : abs z < R) : abs (f z) ≤ abs z :=\n  by\n  replace hz : z ∈ ball (0 : exprℂ) R; exact mem_ball_zero_iff.2 hz\n  simpa only [dist_zero_right] using dist_le_dist_of_maps_to_ball_self hd h_maps h₀ hz\n#align abs_le_abs_of_maps_to_ball_self abs_le_abs_of_maps_to_ball_self\n\n",
 "abs_deriv_le_one_of_maps_to_ball":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/-- The **Schwarz Lemma**: if `f : ℂ → ℂ` sends an open disk of positive radius to itself and the\ncenter of this disk to itself, then the absolute value of the derivative of `f` at the center of\nthis disk is at most `1`. -/\ntheorem abs_deriv_le_one_of_maps_to_ball (hd : differentiable_on (exprℂ) f (ball c R))\n    (h_maps : MapsTo f (ball c R) (ball c R)) (hc : f c = c) (h₀ : 0 < R) : abs (deriv f c) ≤ 1 :=\n  (norm_deriv_le_div_of_maps_to_ball hd (by rwa [hc]) h₀).trans_eq (div_self h₀.ne')\n#align abs_deriv_le_one_of_maps_to_ball abs_deriv_le_one_of_maps_to_ball\n\n",
 "abs_deriv_le_div_of_maps_to_ball":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/-- The **Schwarz Lemma**: if `f : ℂ → ℂ` sends an open disk with center `c` and a positive radius\n`R₁` to an open disk with center `f c` and radius `R₂`, then the absolute value of the derivative of\n`f` at `c` is at most the ratio `R₂ / R₁`. -/\ntheorem abs_deriv_le_div_of_maps_to_ball (hd : differentiable_on (exprℂ) f (ball c R₁))\n    (h_maps : MapsTo f (ball c R₁) (ball (f c) R₂)) (h₀ : 0 < R₁) : abs (deriv f c) ≤ R₂ / R₁ :=\n  norm_deriv_le_div_of_maps_to_ball hd h_maps h₀\n#align abs_deriv_le_div_of_maps_to_ball abs_deriv_le_div_of_maps_to_ball\n\n"}