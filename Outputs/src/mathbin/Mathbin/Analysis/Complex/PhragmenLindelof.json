{"vertical_strip":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `real.pi -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =O[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprexpR -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprexpR -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/-- **Phragmen-Lindelöf principle** in a strip `U = {z : ℂ | a < re z < b}`.\nLet `f : ℂ → E` be a function such that\n\n* `f` is differentiable on `U` and is continuous on its closure;\n* `‖f z‖` is bounded from above by `A * exp(B * exp(c * |im z|))` on `U` for some `c < π / (b - a)`;\n* `‖f z‖` is bounded from above by a constant `C` on the boundary of `U`.\n\nThen `‖f z‖` is bounded by the same constant on the closed strip\n`{z : ℂ | a ≤ re z ≤ b}`. Moreover, it suffices to verify the second assumption\nonly for sufficiently large values of `|im z|`.\n-/\ntheorem vertical_strip (hfd : diff_cont_on_cl (exprℂ) f («expr ⁻¹' » re (Ioo a b)))\n    (hB :\n      ∃ c < real.pi / (b - a),\n        ∃ B,\n          «expr =O[ ] » f («expr ⊓ » (comap (has_abs.abs ∘ im) atTop) ((filter.principal) («expr ⁻¹' » re (Ioo a b))))\n            fun z => (exprexpR) (B * (exprexpR) (c * |z.im|)))\n    (hle_a : ∀ z : exprℂ, re z = a → «expr‖ ‖» (f z) ≤ C) (hle_b : ∀ z, re z = b → «expr‖ ‖» (f z) ≤ C) (hza : a ≤ re z)\n    (hzb : re z ≤ b) : «expr‖ ‖» (f z) ≤ C :=\n  by\n  suffices «expr‖ ‖» ((fun z => f (z * -I)) (z * I)) ≤ C by simpa [mul_assoc] using this\n  have H : maps_to (fun z => z * -I) («expr ⁻¹' » im (Ioo a b)) («expr ⁻¹' » re (Ioo a b)) :=\n    by\n    intro z hz\n    simpa using hz\n  refine'\n    horizontal_strip (hfd.comp (differentiable_id.mul_const _).diff_cont_on_cl H) _ (fun z hz => hle_a _ _)\n      (fun z hz => hle_b _ _) _ _\n  · refine' Exists₃.imp (fun c hc B hO => _) hB\n    have :\n      tendsto (fun z => z * -I)\n        («expr ⊓ » (comap (has_abs.abs ∘ re) at_top) ((filter.principal) («expr ⁻¹' » im (Ioo a b))))\n        («expr ⊓ » (comap (has_abs.abs ∘ im) at_top) ((filter.principal) («expr ⁻¹' » re (Ioo a b)))) :=\n      by\n      refine' (tendsto_comap_iff.2 _).inf H.tendsto\n      simpa [(· ∘ ·)] using tendsto_comap\n    simpa [(· ∘ ·)] using hO.comp_tendsto this\n  all_goals simpa\n#align vertical_strip vertical_strip\n\n",
 "right_half_plane_of_tendsto_zero_on_real":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =O[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprexpR -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/-- **Phragmen-Lindelöf principle** in the right half-plane. Let `f : ℂ → E` be a function such that\n\n* `f` is differentiable in the open right half-plane and is continuous on its closure;\n* `‖f z‖` is bounded from above by `A * exp(B * (abs z) ^ c)` on the open right half-plane\n  for some `c < 2`;\n* `‖f z‖` is bounded from above by a constant `C` on the imaginary axis;\n* `f x → 0` as `x : ℝ` tends to infinity.\n\nThen `‖f z‖` is bounded from above by the same constant on the closed right half-plane.\nSee also `phragmen_lindelof.right_half_plane_of_bounded_on_real` for a stronger version. -/\ntheorem right_half_plane_of_tendsto_zero_on_real (hd : diff_cont_on_cl (exprℂ) f { z | 0 < z.re })\n    (hexp :\n      ∃ c < (2 : exprℝ),\n        ∃ B,\n          «expr =O[ ] » f («expr ⊓ » (comap Complex.abs atTop) ((filter.principal) { z | 0 < z.re })) fun z =>\n            (exprexpR) (B * abs z ^ c))\n    (hre : Tendsto (fun x : exprℝ => f x) atTop ((nhds) 0)) (him : ∀ x : exprℝ, «expr‖ ‖» (f (x * I)) ≤ C)\n    (hz : 0 ≤ z.re) : «expr‖ ‖» (f z) ≤ C :=\n  by\n  /- We are going to apply the Phragmen-Lindelöf principle in the first and fourth quadrants.\n    The lemmas immediately imply that for any upper estimate `C'` on `‖f x‖`, `x : ℝ`, `0 ≤ x`,\n    the number `max C C'` is an upper estimate on `f` in the whole right half-plane. -/\n  revert z\n  have hle : ∀ C', (∀ x : exprℝ, 0 ≤ x → «expr‖ ‖» (f x) ≤ C') → ∀ z : exprℂ, 0 ≤ z.re → «expr‖ ‖» (f z) ≤ max C C' :=\n    by\n    intro C' hC' z hz\n    cases le_total z.im 0\n    · refine'\n        quadrant_IV (hd.mono fun _ => And.left) (Exists₃.imp (fun c hc B hO => _) hexp)\n          (fun x hx => (hC' x hx).trans <| le_max_right _ _) (fun x hx => (him x).trans (le_max_left _ _)) hz h\n      exact hO.mono (inf_le_inf_left _ <| principal_mono.2 fun _ => And.left)\n    · refine'\n        quadrant_I (hd.mono fun _ => And.left) (Exists₃.imp (fun c hc B hO => _) hexp)\n          (fun x hx => (hC' x hx).trans <| le_max_right _ _) (fun x hx => (him x).trans (le_max_left _ _)) hz h\n      exact hO.mono (inf_le_inf_left _ <| principal_mono.2 fun _ => And.left)\n  -- Since `f` is continuous on `Ici 0` and `‖f x‖` tends to zero as `x → ∞`,\n  -- the norm `‖f x‖` takes its maximum value at some `x₀ : ℝ`.\n  obtain ⟨x₀, hx₀, hmax⟩ : ∃ x : exprℝ, 0 ≤ x ∧ ∀ y : exprℝ, 0 ≤ y → «expr‖ ‖» (f y) ≤ «expr‖ ‖» (f x) :=\n    by\n    have hfc : ContinuousOn (fun x : exprℝ => f x) (Ici 0) :=\n      by\n      refine' hd.continuous_on.comp continuous_of_real.continuous_on fun x hx => _\n      rwa [closure_set_of_lt_re]\n    by_cases h₀ : ∀ x : exprℝ, 0 ≤ x → f x = 0\n    · refine' ⟨0, le_rfl, fun y hy => _⟩\n      rw [h₀ y hy, h₀ 0 le_rfl]\n    push_neg  at h₀\n    rcases h₀ with ⟨x₀, hx₀, hne⟩\n    have hlt : «expr‖ ‖» (0 : E) < «expr‖ ‖» (f x₀) := by rwa [norm_zero, norm_pos_iff]\n    suffices\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\"\n        («expr ⊓ » (cocompact (exprℝ)) ((filter.principal) (Ici 0))) («expr‖ ‖» (f x) ≤ «expr‖ ‖» (f x₀))\n      by simpa only [exists_prop] using hfc.norm.exists_forall_ge' isClosed_Ici hx₀ this\n    rw [Real.cocompact_eq, inf_sup_right, (disjoint_at_bot_principal_Ici (0 : exprℝ)).eq_bot, bot_sup_eq]\n    exact (hre.norm.eventually <| ge_mem_nhds hlt).filter_mono inf_le_left\n  cases le_or_lt («expr‖ ‖» (f x₀)) C\n  ·-- If `‖f x₀‖ ≤ C`, then `hle` implies the required estimate\n    simpa only [max_eq_left h] using hle _ hmax\n  · -- Otherwise, `‖f z‖ ≤ ‖f x₀‖` for all `z` in the right half-plane due to `hle`.\n    replace hmax : IsMaxOn (norm ∘ f) { z | 0 < z.re } x₀\n    · rintro z (hz : 0 < z.re)\n      simpa [max_eq_right h.le] using hle _ hmax _ hz.le\n    -- Due to the maximum modulus principle applied to the closed ball of radius `x₀.re`,\n    -- `‖f 0‖ = ‖f x₀‖`.\n    have : «expr‖ ‖» (f 0) = «expr‖ ‖» (f x₀) :=\n      by\n      apply norm_eq_norm_of_is_max_on_of_ball_subset hd hmax\n      -- move to a lemma?\n      intro z hz\n      rw [mem_ball, dist_zero_left, dist_eq, norm_eq_abs, Complex.abs_of_nonneg hx₀] at hz\n      rw [mem_set_of_eq]\n      contrapose! hz\n      calc\n        x₀ ≤ x₀ - z.re := (le_sub_self_iff _).2 hz\n        _ ≤ |x₀ - z.re| := (le_abs_self _)\n        _ = |(z - x₀).re| := by rw [sub_re, of_real_re, _root_.abs_sub_comm]\n        _ ≤ abs (z - x₀) := abs_re_le_abs _\n        \n    -- Thus we have `C < ‖f x₀‖ = ‖f 0‖ ≤ C`. Contradiction completes the proof.\n    refine' (h.not_le <| this ▸ _).elim\n    simpa using him 0\n#align right_half_plane_of_tendsto_zero_on_real right_half_plane_of_tendsto_zero_on_real\n\n",
 "right_half_plane_of_bounded_on_real":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.lt -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprexpR -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprexpR -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =O[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprexpR -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/-- **Phragmen-Lindelöf principle** in the right half-plane. Let `f : ℂ → E` be a function such that\n\n* `f` is differentiable in the open right half-plane and is continuous on its closure;\n* `‖f z‖` is bounded from above by `A * exp(B * (abs z) ^ c)` on the open right half-plane\n  for some `c < 2`;\n* `‖f z‖` is bounded from above by a constant `C` on the imaginary axis;\n* `‖f x‖` is bounded from above by a constant for large real values of `x`.\n\nThen `‖f z‖` is bounded from above by `C` on the closed right half-plane.\nSee also `phragmen_lindelof.right_half_plane_of_tendsto_zero_on_real` for a weaker version. -/\ntheorem right_half_plane_of_bounded_on_real (hd : diff_cont_on_cl (exprℂ) f { z | 0 < z.re })\n    (hexp :\n      ∃ c < (2 : exprℝ),\n        ∃ B,\n          «expr =O[ ] » f («expr ⊓ » (comap Complex.abs atTop) ((filter.principal) { z | 0 < z.re })) fun z =>\n            (exprexpR) (B * abs z ^ c))\n    (hre : IsBoundedUnder (· ≤ ·) atTop fun x : exprℝ => «expr‖ ‖» (f x)) (him : ∀ x : exprℝ, «expr‖ ‖» (f (x * I)) ≤ C)\n    (hz : 0 ≤ z.re) : «expr‖ ‖» (f z) ≤ C :=\n  by\n  -- For each `ε < 0`, the function `λ z, exp (ε * z) • f z` satisfies assumptions of\n  -- `right_half_plane_of_tendsto_zero_on_real`, hence `‖exp (ε * z) • f z‖ ≤ C` for all `ε < 0`.\n  -- Taking the limit as `ε → 0`, we obtain the required inequality.\n  suffices\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\"\n      (nhds_within.lt 0) («expr‖ ‖» («expr • » (exp (ε * z)) (f z)) ≤ C)\n    by\n    refine' le_of_tendsto (tendsto.mono_left _ nhdsWithin_le_nhds) this\n    apply ((continuous_of_real.mul continuous_const).cexp.smul continuous_const).norm.tendsto'\n    simp\n    infer_instance\n  filter_upwards [self_mem_nhdsWithin]with ε ε₀\n  change ε < 0 at ε₀\n  set g : exprℂ → E := fun z => «expr • » (exp (ε * z)) (f z)\n  change «expr‖ ‖» (g z) ≤ C\n  replace hd : diff_cont_on_cl (exprℂ) g { z : exprℂ | 0 < z.re }\n  exact (differentiable_id.const_mul _).cexp.diff_cont_on_cl.smul hd\n  have hgn : ∀ z, «expr‖ ‖» (g z) = (exprexpR) (ε * z.re) * «expr‖ ‖» (f z) :=\n    by\n    intro z\n    rw [norm_smul, norm_eq_abs, abs_exp, of_real_mul_re]\n  refine' right_half_plane_of_tendsto_zero_on_real hd _ _ (fun y => _) hz\n  · refine' Exists₃.imp (fun c hc B hO => (is_O.of_bound 1 _).trans hO) hexp\n    refine' eventually_inf_principal.2 <| eventually_of_forall fun z hz => _\n    rw [hgn, one_mul]\n    refine' mul_le_of_le_one_left (norm_nonneg _) (Real.exp_le_one_iff.2 _)\n    exact mul_nonpos_of_nonpos_of_nonneg ε₀.le (le_of_lt hz)\n  · simp_rw [g, ← of_real_mul, ← of_real_exp, coe_smul]\n    have h₀ : tendsto (fun x : exprℝ => (exprexpR) (ε * x)) at_top ((nhds) 0) :=\n      real.tendsto_exp_at_bot.comp (tendsto_const_nhds.neg_mul_at_top ε₀ tendsto_id)\n    exact h₀.zero_smul_is_bounded_under_le hre\n  · rw [hgn, of_real_mul_re, I_re, MulZeroClass.mul_zero, MulZeroClass.mul_zero, Real.exp_zero, one_mul]\n    exact him y\n#align right_half_plane_of_bounded_on_real right_half_plane_of_bounded_on_real\n\n",
 "quadrant_IV":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ×ℂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ×ℂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ×ℂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =O[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ×ℂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprexpR -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/-- **Phragmen-Lindelöf principle** in the fourth quadrant. Let `f : ℂ → E` be a function such that\n\n* `f` is differentiable in the open fourth quadrant and is continuous on its closure;\n* `‖f z‖` is bounded from above by `A * exp(B * (abs z) ^ c)` on the open fourth quadrant\n  for some `c < 2`;\n* `‖f z‖` is bounded from above by a constant `C` on the boundary of the fourth quadrant.\n\nThen `‖f z‖` is bounded from above by the same constant on the closed fourth quadrant. -/\ntheorem quadrant_IV (hd : diff_cont_on_cl (exprℂ) f («expr ×ℂ » (Ioi 0) (Iio 0)))\n    (hB :\n      ∃ c < (2 : exprℝ),\n        ∃ B,\n          «expr =O[ ] » f («expr ⊓ » (comap Complex.abs atTop) ((filter.principal) («expr ×ℂ » (Ioi 0) (Iio 0))))\n            fun z => (exprexpR) (B * abs z ^ c))\n    (hre : ∀ x : exprℝ, 0 ≤ x → «expr‖ ‖» (f x) ≤ C) (him : ∀ x : exprℝ, x ≤ 0 → «expr‖ ‖» (f (x * I)) ≤ C)\n    (hz_re : 0 ≤ z.re) (hz_im : z.im ≤ 0) : «expr‖ ‖» (f z) ≤ C :=\n  by\n  obtain ⟨z, rfl⟩ : ∃ z', -z' = z\n  exact ⟨-z, neg_neg z⟩\n  simp only [neg_re, neg_im, neg_nonpos, neg_nonneg] at hz_re hz_im\n  change «expr‖ ‖» ((f ∘ has_neg.neg) z) ≤ C\n  have H : maps_to has_neg.neg («expr ×ℂ » (Iio 0) (Ioi 0)) («expr ×ℂ » (Ioi 0) (Iio 0)) :=\n    by\n    intro w hw\n    simpa only [mem_re_prod_im, neg_re, neg_im, neg_lt_zero, neg_pos, mem_Ioi, mem_Iio] using hw\n  refine' quadrant_II (hd.comp differentiable_neg.diff_cont_on_cl H) _ (fun x hx => _) (fun x hx => _) hz_re hz_im\n  · refine' Exists₃.imp (fun c hc B hO => _) hB\n    simpa only [(· ∘ ·), complex.abs.map_neg] using hO.comp_tendsto (tendsto_neg_cobounded.inf H.tendsto)\n  · rw [comp_app, ← of_real_neg]\n    exact hre (-x) (neg_nonneg.2 hx)\n  · rw [comp_app, ← neg_mul, ← of_real_neg]\n    exact him (-x) (neg_nonpos.2 hx)\n#align quadrant_IV quadrant_IV\n\n",
 "quadrant_III":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ×ℂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ×ℂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ×ℂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =O[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ×ℂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprexpR -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/-- **Phragmen-Lindelöf principle** in the third quadrant. Let `f : ℂ → E` be a function such that\n\n* `f` is differentiable in the open third quadrant and is continuous on its closure;\n* `‖f z‖` is bounded from above by `A * exp (B * (abs z) ^ c)` on the open third quadrant\n  for some `c < 2`;\n* `‖f z‖` is bounded from above by a constant `C` on the boundary of the third quadrant.\n\nThen `‖f z‖` is bounded from above by the same constant on the closed third quadrant. -/\ntheorem quadrant_III (hd : diff_cont_on_cl (exprℂ) f («expr ×ℂ » (Iio 0) (Iio 0)))\n    (hB :\n      ∃ c < (2 : exprℝ),\n        ∃ B,\n          «expr =O[ ] » f («expr ⊓ » (comap Complex.abs atTop) ((filter.principal) («expr ×ℂ » (Iio 0) (Iio 0))))\n            fun z => (exprexpR) (B * abs z ^ c))\n    (hre : ∀ x : exprℝ, x ≤ 0 → «expr‖ ‖» (f x) ≤ C) (him : ∀ x : exprℝ, x ≤ 0 → «expr‖ ‖» (f (x * I)) ≤ C)\n    (hz_re : z.re ≤ 0) (hz_im : z.im ≤ 0) : «expr‖ ‖» (f z) ≤ C :=\n  by\n  obtain ⟨z, rfl⟩ : ∃ z', -z' = z\n  exact ⟨-z, neg_neg z⟩\n  simp only [neg_re, neg_im, neg_nonpos] at hz_re hz_im\n  change «expr‖ ‖» ((f ∘ has_neg.neg) z) ≤ C\n  have H : maps_to has_neg.neg («expr ×ℂ » (Ioi 0) (Ioi 0)) («expr ×ℂ » (Iio 0) (Iio 0)) :=\n    by\n    intro w hw\n    simpa only [mem_re_prod_im, neg_re, neg_im, neg_lt_zero, mem_Iio] using hw\n  refine' quadrant_I (hd.comp differentiable_neg.diff_cont_on_cl H) _ (fun x hx => _) (fun x hx => _) hz_re hz_im\n  · refine' Exists₃.imp (fun c hc B hO => _) hB\n    simpa only [(· ∘ ·), complex.abs.map_neg] using hO.comp_tendsto (tendsto_neg_cobounded.inf H.tendsto)\n  · rw [comp_app, ← of_real_neg]\n    exact hre (-x) (neg_nonpos.2 hx)\n  · rw [comp_app, ← neg_mul, ← of_real_neg]\n    exact him (-x) (neg_nonpos.2 hx)\n#align quadrant_III quadrant_III\n\n",
 "quadrant_II":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ×ℂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ×ℂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ×ℂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =O[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ×ℂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprexpR -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/-- **Phragmen-Lindelöf principle** in the second quadrant. Let `f : ℂ → E` be a function such that\n\n* `f` is differentiable in the open second quadrant and is continuous on its closure;\n* `‖f z‖` is bounded from above by `A * exp(B * (abs z) ^ c)` on the open second quadrant\n  for some `c < 2`;\n* `‖f z‖` is bounded from above by a constant `C` on the boundary of the second quadrant.\n\nThen `‖f z‖` is bounded from above by the same constant on the closed second quadrant. -/\ntheorem quadrant_II (hd : diff_cont_on_cl (exprℂ) f («expr ×ℂ » (Iio 0) (Ioi 0)))\n    (hB :\n      ∃ c < (2 : exprℝ),\n        ∃ B,\n          «expr =O[ ] » f («expr ⊓ » (comap Complex.abs atTop) ((filter.principal) («expr ×ℂ » (Iio 0) (Ioi 0))))\n            fun z => (exprexpR) (B * abs z ^ c))\n    (hre : ∀ x : exprℝ, x ≤ 0 → «expr‖ ‖» (f x) ≤ C) (him : ∀ x : exprℝ, 0 ≤ x → «expr‖ ‖» (f (x * I)) ≤ C)\n    (hz_re : z.re ≤ 0) (hz_im : 0 ≤ z.im) : «expr‖ ‖» (f z) ≤ C :=\n  by\n  obtain ⟨z, rfl⟩ : ∃ z', z' * I = z\n  exact ⟨z / I, div_mul_cancel _ I_ne_zero⟩\n  simp only [mul_I_re, mul_I_im, neg_nonpos] at hz_re hz_im\n  change «expr‖ ‖» ((f ∘ (· * I)) z) ≤ C\n  have H : maps_to (· * I) («expr ×ℂ » (Ioi 0) (Ioi 0)) («expr ×ℂ » (Iio 0) (Ioi 0)) :=\n    by\n    intro w hw\n    simpa only [mem_re_prod_im, mul_I_re, mul_I_im, neg_lt_zero, mem_Iio] using hw.symm\n  refine'\n    quadrant_I (hd.comp (differentiable_id.mul_const _).diff_cont_on_cl H) (Exists₃.imp (fun c hc B hO => _) hB) him\n      (fun x hx => _) hz_im hz_re\n  ·\n    simpa only [(· ∘ ·), map_mul, abs_I, mul_one] using\n      hO.comp_tendsto ((tendsto_mul_right_cobounded I_ne_zero).inf H.tendsto)\n  · rw [comp_app, mul_assoc, I_mul_I, mul_neg_one, ← of_real_neg]\n    exact hre _ (neg_nonpos.2 hx)\n#align quadrant_II quadrant_II\n\n",
 "quadrant_I":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `real.pi -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `real.pi -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ×ℂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ×ℂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ×ℂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =O[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ×ℂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprexpR -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/-- **Phragmen-Lindelöf principle** in the first quadrant. Let `f : ℂ → E` be a function such that\n\n* `f` is differentiable in the open first quadrant and is continuous on its closure;\n* `‖f z‖` is bounded from above by `A * exp(B * (abs z) ^ c)` on the open first quadrant\n  for some `c < 2`;\n* `‖f z‖` is bounded from above by a constant `C` on the boundary of the first quadrant.\n\nThen `‖f z‖` is bounded from above by the same constant on the closed first quadrant. -/\ntheorem quadrant_I (hd : diff_cont_on_cl (exprℂ) f («expr ×ℂ » (Ioi 0) (Ioi 0)))\n    (hB :\n      ∃ c < (2 : exprℝ),\n        ∃ B,\n          «expr =O[ ] » f («expr ⊓ » (comap Complex.abs atTop) ((filter.principal) («expr ×ℂ » (Ioi 0) (Ioi 0))))\n            fun z => (exprexpR) (B * abs z ^ c))\n    (hre : ∀ x : exprℝ, 0 ≤ x → «expr‖ ‖» (f x) ≤ C) (him : ∀ x : exprℝ, 0 ≤ x → «expr‖ ‖» (f (x * I)) ≤ C)\n    (hz_re : 0 ≤ z.re) (hz_im : 0 ≤ z.im) : «expr‖ ‖» (f z) ≤ C :=\n  by\n  -- The case `z = 0` is trivial.\n  rcases eq_or_ne z 0 with (rfl | hzne)\n  · exact hre 0 le_rfl\n  -- Otherwise, `z = e ^ ζ` for some `ζ : ℂ`, `0 < Im ζ < π / 2`.\n  obtain ⟨ζ, hζ, rfl⟩ : ∃ ζ : exprℂ, ζ.im ∈ Icc 0 (real.pi / 2) ∧ exp ζ = z :=\n    by\n    refine' ⟨log z, _, exp_log hzne⟩\n    rw [log_im]\n    exact ⟨arg_nonneg_iff.2 hz_im, arg_le_pi_div_two_iff.2 (or.inl hz_re)⟩\n  clear hz_re hz_im hzne\n  -- We are going to apply `phragmen_lindelof.horizontal_strip` to `f ∘ complex.exp` and `ζ`.\n  change «expr‖ ‖» ((f ∘ exp) ζ) ≤ C\n  have H : maps_to exp («expr ⁻¹' » im (Ioo 0 (real.pi / 2))) («expr ×ℂ » (Ioi 0) (Ioi 0)) :=\n    by\n    intro z hz\n    rw [mem_re_prod_im, exp_re, exp_im, mem_Ioi, mem_Ioi]\n    refine'\n      ⟨mul_pos (Real.exp_pos _)\n          (real.cos_pos_of_mem_Ioo ⟨(neg_lt_zero.2 <| div_pos real.pi_pos two_pos).trans hz.1, hz.2⟩),\n        mul_pos (Real.exp_pos _) (real.sin_pos_of_mem_Ioo ⟨hz.1, hz.2.trans (half_lt_self real.pi_pos)⟩)⟩\n  refine' horizontal_strip (hd.comp differentiable_exp.diff_cont_on_cl H) _ _ _ hζ.1 hζ.2 <;> clear hζ ζ\n  · -- The estimate `hB` on `f` implies the required estimate on\n    -- `f ∘ exp` with the same `c` and `B' = max B 0`.\n    rw [sub_zero, div_div_cancel' real.pi_pos.ne']\n    rcases hB with ⟨c, hc, B, hO⟩\n    refine' ⟨c, hc, max B 0, _⟩\n    rw [← comap_comap, comap_abs_at_top, comap_sup, inf_sup_right]\n    -- We prove separately the estimates as `ζ.re → ∞` and as `ζ.re → -∞`\n    refine' is_O.sup _ ((hO.comp_tendsto <| tendsto_exp_comap_re_at_top.inf H.tendsto).trans <| is_O.of_bound 1 _)\n    · -- For the estimate as `ζ.re → -∞`, note that `f` is continuous within the first quadrant at\n      -- zero, hence `f (exp ζ)` has a limit as `ζ.re → -∞`, `0 < ζ.im < π / 2`.\n      have hc : ContinuousWithinAt f («expr ×ℂ » (Ioi 0) (Ioi 0)) 0 :=\n        by\n        refine' (hd.continuous_on _ _).mono subset_closure\n        simp [closure_re_prod_im, mem_re_prod_im]\n      refine'\n        ((hc.tendsto.comp <| tendsto_exp_comap_re_at_bot.inf H.tendsto).is_O_one (exprℝ)).trans\n          (is_O_of_le _ fun w => _)\n      rw [norm_one, Real.norm_of_nonneg (Real.exp_pos _).le, Real.one_le_exp_iff]\n      exact mul_nonneg (le_max_right _ _) (Real.exp_pos _).le\n    · -- For the estimate as `ζ.re → ∞`, we reuse the uppoer estimate on `f`\n      simp only [eventually_inf_principal, eventually_comap, comp_app, one_mul, Real.norm_of_nonneg (Real.exp_pos _).le,\n        abs_exp, ← real.exp_mul, Real.exp_le_exp]\n      refine' (eventually_ge_at_top 0).mono fun x hx z hz hz' => _\n      rw [hz, _root_.abs_of_nonneg hx, mul_comm _ c]\n      exact mul_le_mul_of_nonneg_right (le_max_left _ _) (Real.exp_pos _).le\n  · -- If `ζ.im = 0`, then `complex.exp ζ` is a positive real number\n    intro ζ hζ\n    lift ζ to exprℝ using hζ\n    rw [comp_app, ← of_real_exp]\n    exact hre _ (Real.exp_pos _).le\n  · -- If `ζ.im = π / 2`, then `complex.exp ζ` is a purely imaginary number with positive `im`\n    intro ζ hζ\n    rw [← re_add_im ζ, hζ, comp_app, exp_add_mul_I, ← of_real_cos, ← of_real_sin, real.cos_pi_div_two,\n      real.sin_pi_div_two, of_real_zero, of_real_one, one_mul, zero_add, ← of_real_exp]\n    exact him _ (Real.exp_pos _).le\n#align quadrant_I quadrant_I\n\n",
 "is_O_sub_exp_rpow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =O[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprexpR -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprexpR -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =O[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprexpR -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =O[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprexpR -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =O[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprexpR -/\n/-- An auxiliary lemma that combines two “exponential of a power” estimates into a similar estimate\non the difference of the functions. -/\ntheorem is_O_sub_exp_rpow {a : exprℝ} {f g : exprℂ → E} {l : Filter (exprℂ)}\n    (hBf : ∃ c < a, ∃ B, «expr =O[ ] » f («expr ⊓ » (comap Complex.abs atTop) l) fun z => (exprexpR) (B * abs z ^ c))\n    (hBg : ∃ c < a, ∃ B, «expr =O[ ] » g («expr ⊓ » (comap Complex.abs atTop) l) fun z => (exprexpR) (B * abs z ^ c)) :\n    ∃ c < a, ∃ B, «expr =O[ ] » (f - g) («expr ⊓ » (comap Complex.abs atTop) l) fun z => (exprexpR) (B * abs z ^ c) :=\n  by\n  have :\n    ∀ {c₁ c₂ B₁ B₂ : exprℝ},\n      c₁ ≤ c₂ →\n        0 ≤ B₂ →\n          B₁ ≤ B₂ →\n            «expr =O[ ] » (fun z : exprℂ => (exprexpR) (B₁ * abs z ^ c₁)) («expr ⊓ » (comap Complex.abs at_top) l)\n              fun z => (exprexpR) (B₂ * abs z ^ c₂) :=\n    by\n    have :\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\"\n        («expr ⊓ » (comap Complex.abs at_top) l) (1 ≤ abs z) :=\n      ((eventually_ge_at_top 1).comap _).filter_mono inf_le_left\n    refine' fun c₁ c₂ B₁ B₂ hc hB₀ hB => is_O.of_bound 1 (this.mono fun z hz => _)\n    rw [one_mul, Real.norm_eq_abs, Real.norm_eq_abs, Real.abs_exp, Real.abs_exp, Real.exp_le_exp]\n    exact\n      mul_le_mul hB (real.rpow_le_rpow_of_exponent_le hz hc) (real.rpow_nonneg_of_nonneg (complex.abs.nonneg _) _) hB₀\n  rcases hBf with ⟨cf, hcf, Bf, hOf⟩\n  rcases hBg with ⟨cg, hcg, Bg, hOg⟩\n  refine' ⟨max cf cg, max_lt hcf hcg, max 0 (max Bf Bg), _⟩\n  refine' (hOf.trans <| this _ _ _).sub (hOg.trans <| this _ _ _)\n  exacts[le_max_left _ _, le_max_left _ _, (le_max_left _ _).trans (le_max_right _ _), le_max_right _ _,\n    le_max_left _ _, (le_max_right _ _).trans (le_max_right _ _)]\n#align is_O_sub_exp_rpow is_O_sub_exp_rpow\n\n",
 "is_O_sub_exp_exp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprexpR -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprexpR -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprexpR -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprexpR -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =O[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprexpR -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprexpR -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =O[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprexpR -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprexpR -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =O[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprexpR -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprexpR -/\n/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-/\n/-- An auxiliary lemma that combines two double exponential estimates into a similar estimate\non the difference of the functions. -/\ntheorem is_O_sub_exp_exp {a : exprℝ} {f g : exprℂ → E} {l : Filter (exprℂ)} {u : exprℂ → exprℝ}\n    (hBf : ∃ c < a, ∃ B, «expr =O[ ] » f l fun z => (exprexpR) (B * (exprexpR) (c * |u z|)))\n    (hBg : ∃ c < a, ∃ B, «expr =O[ ] » g l fun z => (exprexpR) (B * (exprexpR) (c * |u z|))) :\n    ∃ c < a, ∃ B, «expr =O[ ] » (f - g) l fun z => (exprexpR) (B * (exprexpR) (c * |u z|)) :=\n  by\n  have :\n    ∀ {c₁ c₂ B₁ B₂},\n      c₁ ≤ c₂ →\n        0 ≤ B₂ →\n          B₁ ≤ B₂ →\n            ∀ z,\n              «expr‖ ‖» ((exprexpR) (B₁ * (exprexpR) (c₁ * |u z|))) ≤\n                «expr‖ ‖» ((exprexpR) (B₂ * (exprexpR) (c₂ * |u z|))) :=\n    by\n    intro c₁ c₂ B₁ B₂ hc hB₀ hB z\n    rw [Real.norm_eq_abs, Real.norm_eq_abs, Real.abs_exp, Real.abs_exp, Real.exp_le_exp]\n    exact mul_le_mul hB (Real.exp_le_exp.2 <| mul_le_mul_of_nonneg_right hc <| abs_nonneg _) (Real.exp_pos _).le hB₀\n  rcases hBf with ⟨cf, hcf, Bf, hOf⟩\n  rcases hBg with ⟨cg, hcg, Bg, hOg⟩\n  refine' ⟨max cf cg, max_lt hcf hcg, max 0 (max Bf Bg), _⟩\n  refine' (hOf.trans_le <| this _ _ _).sub (hOg.trans_le <| this _ _ _)\n  exacts[le_max_left _ _, le_max_left _ _, (le_max_left _ _).trans (le_max_right _ _), le_max_right _ _,\n    le_max_left _ _, (le_max_right _ _).trans (le_max_right _ _)]\n#align is_O_sub_exp_exp is_O_sub_exp_exp\n\n",
 "horizontal_strip":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `real.pi -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `real.pi -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `real.pi -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.lt -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprexpR -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprexpR -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprexpR -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprexpR -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprexpR -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprexpR -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprexpR -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprexpR -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprexpR -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ×ℂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ×ℂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `real.pi -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =O[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprexpR -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprexpR -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/-- **Phragmen-Lindelöf principle** in a strip `U = {z : ℂ | a < im z < b}`.\nLet `f : ℂ → E` be a function such that\n\n* `f` is differentiable on `U` and is continuous on its closure;\n* `‖f z‖` is bounded from above by `A * exp(B * exp(c * |re z|))` on `U` for some `c < π / (b - a)`;\n* `‖f z‖` is bounded from above by a constant `C` on the boundary of `U`.\n\nThen `‖f z‖` is bounded by the same constant on the closed strip\n`{z : ℂ | a ≤ im z ≤ b}`. Moreover, it suffices to verify the second assumption\nonly for sufficiently large values of `|re z|`.\n-/\ntheorem horizontal_strip (hfd : diff_cont_on_cl (exprℂ) f («expr ⁻¹' » im (Ioo a b)))\n    (hB :\n      ∃ c < real.pi / (b - a),\n        ∃ B,\n          «expr =O[ ] » f («expr ⊓ » (comap (has_abs.abs ∘ re) atTop) ((filter.principal) («expr ⁻¹' » im (Ioo a b))))\n            fun z => (exprexpR) (B * (exprexpR) (c * |z.re|)))\n    (hle_a : ∀ z : exprℂ, im z = a → «expr‖ ‖» (f z) ≤ C) (hle_b : ∀ z, im z = b → «expr‖ ‖» (f z) ≤ C) (hza : a ≤ im z)\n    (hzb : im z ≤ b) : «expr‖ ‖» (f z) ≤ C :=\n  by\n  -- If `im z = a` or `im z = b`, then we apply `hle_a` or `hle_b`, otherwise `im z ∈ Ioo a b`.\n  rw [le_iff_eq_or_lt] at hza hzb\n  cases' hza with hza hza\n  · exact hle_a _ hza.symm\n  cases' hzb with hzb hzb\n  · exact hle_b _ hzb\n  -- WLOG, `0 < C`.\n  suffices\n    ∀ C' : exprℝ,\n      0 < C' →\n        (∀ w : exprℂ, im w = a → «expr‖ ‖» (f w) ≤ C') →\n          (∀ w : exprℂ, im w = b → «expr‖ ‖» (f w) ≤ C') → «expr‖ ‖» (f z) ≤ C'\n    by\n    refine' le_of_forall_le_of_dense fun C' hC' => this C' _ (fun w hw => _) fun w hw => _\n    · refine' ((norm_nonneg (f (a * I))).trans (hle_a _ _)).trans_lt hC'\n      rw [mul_I_im, of_real_re]\n    exacts[(hle_a _ hw).trans hC'.le, (hle_b _ hw).trans hC'.le]\n  clear! C\n  intro C hC₀ hle_a hle_b\n  -- After a change of variables, we deal with the strip `a - b < im z < a + b` instead\n  -- of `a < im z < b`\n  obtain ⟨a, b, rfl, rfl⟩ : ∃ a' b', a = a' - b' ∧ b = a' + b' := ⟨(a + b) / 2, (b - a) / 2, by ring, by ring⟩\n  have hab : a - b < a + b := hza.trans hzb\n  have hb : 0 < b := by simpa only [sub_eq_add_neg, add_lt_add_iff_left, neg_lt_self_iff] using hab\n  rw [add_sub_sub_cancel, ← two_mul, div_mul_eq_div_div] at hB\n  have hπb : 0 < real.pi / 2 / b := div_pos real.pi_div_two_pos hb\n  -- Choose some `c B : ℝ` satisfying `hB`, then choose `max c 0 < d < π / 2 / b`.\n  rcases hB with ⟨c, hc, B, hO⟩\n  obtain ⟨d, ⟨hcd, hd₀⟩, hd⟩ : ∃ d, (c < d ∧ 0 < d) ∧ d < real.pi / 2 / b := by\n    simpa only [max_lt_iff] using exists_between (max_lt hc hπb)\n  have hb' : d * b < real.pi / 2 := (lt_div_iff hb).1 hd\n  set aff : exprℂ → exprℂ := fun w => d * (w - a * I)\n  set g : exprℝ → exprℂ → exprℂ := fun ε w => exp (ε * (exp (aff w) + exp (-aff w)))\n  /- Since `g ε z → 1` as `ε → 0⁻`, it suffices to prove that `‖g ε z • f z‖ ≤ C`\n    for all negative `ε`. -/\n  suffices\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\"\n      (nhds_within.lt 0) («expr‖ ‖» («expr • » (g ε z) (f z)) ≤ C)\n    by\n    refine' le_of_tendsto (tendsto.mono_left _ nhdsWithin_le_nhds) this\n    apply ((continuous_of_real.mul continuous_const).cexp.smul continuous_const).norm.tendsto'\n    simp\n    infer_instance\n  filter_upwards [self_mem_nhdsWithin]with ε ε₀\n  change ε < 0 at ε₀\n  -- An upper estimate on `‖g ε w‖` that will be used in two branches of the proof.\n  obtain ⟨δ, δ₀, hδ⟩ :\n    ∃ δ : exprℝ, δ < 0 ∧ ∀ ⦃w⦄, im w ∈ Icc (a - b) (a + b) → abs (g ε w) ≤ (exprexpR) (δ * (exprexpR) (d * |re w|)) :=\n    by\n    refine'\n      ⟨ε * Real.cos (d * b),\n        mul_neg_of_neg_of_pos ε₀ (real.cos_pos_of_mem_Ioo <| abs_lt.1 <| (abs_of_pos (mul_pos hd₀ hb)).symm ▸ hb'),\n        fun w hw => _⟩\n    replace hw : |im (aff w)| ≤ d * b\n    · rw [← Real.closedBall_eq_Icc] at hw\n      rwa [of_real_mul_im, sub_im, mul_I_im, of_real_re, _root_.abs_mul, abs_of_pos hd₀, mul_le_mul_left hd₀]\n    simpa only [of_real_mul_re, _root_.abs_mul, abs_of_pos hd₀, sub_re, mul_I_re, of_real_im, MulZeroClass.zero_mul,\n      neg_zero, sub_zero] using abs_exp_mul_exp_add_exp_neg_le_of_abs_im_le ε₀.le hw hb'.le\n  -- `abs (g ε w) ≤ 1` on the lines `w.im = a ± b` (actually, it holds everywhere in the strip)\n  have hg₁ : ∀ w, im w = a - b ∨ im w = a + b → abs (g ε w) ≤ 1 :=\n    by\n    refine' fun w hw => (hδ <| hw.by_cases _ _).trans (Real.exp_le_one_iff.2 _)\n    exacts[fun h => h.symm ▸ left_mem_Icc.2 hab.le, fun h => h.symm ▸ right_mem_Icc.2 hab.le,\n      mul_nonpos_of_nonpos_of_nonneg δ₀.le (Real.exp_pos _).le]\n  /- Our apriori estimate on `f` implies that `g ε w • f w → 0` as `|w.re| → ∞` along the strip. In\n    particular, its norm is less than or equal to `C` for sufficiently large `|w.re|`. -/\n  obtain ⟨R, hzR, hR⟩ :\n    ∃ R : exprℝ, |z.re| < R ∧ ∀ w, |re w| = R → im w ∈ Ioo (a - b) (a + b) → «expr‖ ‖» («expr • » (g ε w) (f w)) ≤ C :=\n    by\n    refine' ((eventually_gt_at_top _).and _).exists\n    rcases hO.exists_pos with ⟨A, hA₀, hA⟩\n    simp only [is_O_with_iff, eventually_inf_principal, eventually_comap, mem_Ioo, ← abs_lt, mem_preimage, (· ∘ ·),\n      Real.norm_eq_abs, abs_of_pos (Real.exp_pos _)] at hA\n    suffices\n      tendsto (fun R => (exprexpR) (δ * (exprexpR) (d * R) + B * (exprexpR) (c * R) + real.log A)) at_top ((nhds) 0)\n      by\n      filter_upwards [this.eventually (ge_mem_nhds hC₀), hA]with R hR Hle w hre him\n      calc\n        «expr‖ ‖» («expr • » (g ε w) (f w)) ≤\n            (exprexpR) (δ * (exprexpR) (d * R) + B * (exprexpR) (c * R) + real.log A) :=\n          _\n        _ ≤ C := hR\n        \n      rw [norm_smul, Real.exp_add, ← hre, Real.exp_add, real.exp_log hA₀, mul_assoc, mul_comm _ A]\n      exact mul_le_mul (hδ <| Ioo_subset_Icc_self him) (Hle _ hre him) (norm_nonneg _) (Real.exp_pos _).le\n    refine' real.tendsto_exp_at_bot.comp _\n    suffices H : tendsto (fun R => δ + B * ((exprexpR) ((d - c) * R))⁻¹) at_top ((nhds) (δ + B * 0))\n    · rw [MulZeroClass.mul_zero, add_zero] at H\n      refine' tendsto.at_bot_add _ tendsto_const_nhds\n      simpa only [id, (· ∘ ·), add_mul, mul_assoc, ← div_eq_inv_mul, ← Real.exp_sub, ← sub_mul, sub_sub_cancel] using\n        H.neg_mul_at_top δ₀ (real.tendsto_exp_at_top.comp <| tendsto_const_nhds.mul_at_top hd₀ tendsto_id)\n    refine' tendsto_const_nhds.add (tendsto_const_nhds.mul _)\n    exact\n      tendsto_inv_at_top_zero.comp\n        (real.tendsto_exp_at_top.comp <| tendsto_const_nhds.mul_at_top (sub_pos.2 hcd) tendsto_id)\n  have hR₀ : 0 < R := (_root_.abs_nonneg _).trans_lt hzR\n  /- Finally, we apply the bounded version of the maximum modulus principle to the rectangle\n    `(-R, R) × (a - b, a + b)`. The function is bounded by `C` on the horizontal sides by assumption\n    (and because `‖g ε w‖ ≤ 1`) and on the vertical sides by the choice of `R`. -/\n  have hgd : differentiable (exprℂ) (g ε) :=\n    ((((differentiable_id.sub_const _).const_mul _).cexp.add\n            ((differentiable_id.sub_const _).const_mul _).neg.cexp).const_mul\n        _).cexp\n  replace hd :\n    diff_cont_on_cl (exprℂ) (fun w => «expr • » (g ε w) (f w)) («expr ×ℂ » (Ioo (-R) R) (Ioo (a - b) (a + b)))\n  exact (hgd.diff_cont_on_cl.smul hfd).mono (inter_subset_right _ _)\n  convert norm_le_of_forall_mem_frontier_norm_le ((bounded_Ioo _ _).re_prod_im (bounded_Ioo _ _)) hd (fun w hw => _) _\n  · have hwc := frontier_subset_closure hw\n    rw [frontier_re_prod_im, closure_Ioo (neg_lt_self hR₀).ne, frontier_Ioo hab, closure_Ioo hab.ne,\n      frontier_Ioo (neg_lt_self hR₀)] at hw\n    by_cases him : w.im = a - b ∨ w.im = a + b\n    · rw [closure_re_prod_im, closure_Ioo (neg_lt_self hR₀).ne] at hwc\n      rw [norm_smul, ← one_mul C]\n      exact mul_le_mul (hg₁ _ him) (him.by_cases (hle_a _) (hle_b _)) (norm_nonneg _) zero_le_one\n    · replace hw : w ∈ «expr ×ℂ » {-R, R} (Icc (a - b) (a + b))\n      exact hw.resolve_left fun h => him h.2\n      have hw' := eq_endpoints_or_mem_Ioo_of_mem_Icc hw.2\n      rw [← or_assoc] at hw'\n      exact hR _ ((abs_eq hR₀.le).2 hw.1.symm) (hw'.resolve_left him)\n  · rw [closure_re_prod_im, closure_Ioo hab.ne, closure_Ioo (neg_lt_self hR₀).ne]\n    exact ⟨abs_le.1 hzR.le, ⟨hza.le, hzb.le⟩⟩\n#align horizontal_strip horizontal_strip\n\n",
 "eq_zero_on_vertical_strip":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `real.pi -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =O[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprexpR -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprexpR -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/-- **Phragmen-Lindelöf principle** in a strip `U = {z : ℂ | a < re z < b}`.\nLet `f : ℂ → E` be a function such that\n\n* `f` is differentiable on `U` and is continuous on its closure;\n* `‖f z‖` is bounded from above by `A * exp(B * exp(c * |im z|))` on `U` for some `c < π / (b - a)`;\n* `f z = 0` on the boundary of `U`.\n\nThen `f` is equal to zero on the closed strip `{z : ℂ | a ≤ re z ≤ b}`.\n-/\ntheorem eq_zero_on_vertical_strip (hd : diff_cont_on_cl (exprℂ) f («expr ⁻¹' » re (Ioo a b)))\n    (hB :\n      ∃ c < real.pi / (b - a),\n        ∃ B,\n          «expr =O[ ] » f («expr ⊓ » (comap (has_abs.abs ∘ im) atTop) ((filter.principal) («expr ⁻¹' » re (Ioo a b))))\n            fun z => (exprexpR) (B * (exprexpR) (c * |z.im|)))\n    (ha : ∀ z : exprℂ, re z = a → f z = 0) (hb : ∀ z : exprℂ, re z = b → f z = 0) :\n    EqOn f 0 («expr ⁻¹' » re (Icc a b)) := fun z hz =>\n  norm_le_zero_iff.1 <|\n    vertical_strip hd hB (fun z hz => (ha z hz).symm ▸ norm_zero.le) (fun z hz => (hb z hz).symm ▸ norm_zero.le) hz.1\n      hz.2\n#align eq_zero_on_vertical_strip eq_zero_on_vertical_strip\n\n",
 "eq_zero_on_right_half_plane_of_superexponential_decay":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprexpR -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprexpR -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =O[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprexpR -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprexpR -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/-- **Phragmen-Lindelöf principle** in the right half-plane. Let `f : ℂ → E` be a function such that\n\n* `f` is differentiable in the open right half-plane and is continuous on its closure;\n* `‖f z‖` is bounded from above by `A * exp(B * (abs z) ^ c)` on the open right half-plane\n  for some `c < 2`;\n* `‖f z‖` is bounded from above by a constant on the imaginary axis;\n* `f x`, `x : ℝ`, tends to zero superexponentially fast as `x → ∞`:\n  for any natural `n`, `exp (n * x) * ‖f x‖` tends to zero as `x → ∞`.\n\nThen `f` is equal to zero on the closed right half-plane. -/\ntheorem eq_zero_on_right_half_plane_of_superexponential_decay (hd : diff_cont_on_cl (exprℂ) f { z | 0 < z.re })\n    (hexp :\n      ∃ c < (2 : exprℝ),\n        ∃ B,\n          «expr =O[ ] » f («expr ⊓ » (comap Complex.abs atTop) ((filter.principal) { z | 0 < z.re })) fun z =>\n            (exprexpR) (B * abs z ^ c))\n    (hre : SuperpolynomialDecay atTop (exprexpR) fun x => «expr‖ ‖» (f x))\n    (him : ∃ C, ∀ x : exprℝ, «expr‖ ‖» (f (x * I)) ≤ C) : EqOn f 0 { z : exprℂ | 0 ≤ z.re } :=\n  by\n  rcases him with ⟨C, hC⟩\n  -- Due to continuity, it suffices to prove the equality on the open right half-plane.\n  suffices ∀ z : exprℂ, 0 < z.re → f z = 0 by\n    simpa only [closure_set_of_lt_re] using\n      eq_on.of_subset_closure this hd.continuous_on continuousOn_const subset_closure subset.rfl\n  -- Consider $g_n(z)=e^{nz}f(z)$.\n  set g : ℕ → exprℂ → E := fun n z => «expr • » (exp z ^ n) (f z)\n  have hg : ∀ n z, «expr‖ ‖» (g n z) = (exprexpR) z.re ^ n * «expr‖ ‖» (f z) :=\n    by\n    intro n z\n    simp only [norm_smul, norm_eq_abs, Complex.abs_pow, abs_exp]\n  intro z hz\n  -- Since `e^{nz} → ∞` as `n → ∞`, it suffices to show that each `g_n` is bounded from above by `C`\n  suffices H : ∀ n : ℕ, «expr‖ ‖» (g n z) ≤ C\n  · contrapose! H\n    simp only [hg]\n    exact\n      (((tendsto_pow_atTop_atTop_of_one_lt (Real.one_lt_exp_iff.2 hz)).at_top_mul (norm_pos_iff.2 H)\n              tendsto_const_nhds).eventually\n          (eventually_gt_at_top C)).exists\n  intro n\n  -- This estimate follows from the Phragmen-Lindelöf principle in the right half-plane.\n  refine'\n    right_half_plane_of_tendsto_zero_on_real ((differentiable_exp.pow n).diff_cont_on_cl.smul hd) _ _ (fun y => _) hz.le\n  · rcases hexp with ⟨c, hc, B, hO⟩\n    refine' ⟨max c 1, max_lt hc one_lt_two, n + max B 0, is_O.of_norm_left _⟩\n    simp only [hg]\n    refine' ((is_O_refl (fun z : exprℂ => (exprexpR) z.re ^ n) _).mul hO.norm_left).trans (is_O.of_bound 1 _)\n    simp only [← Real.exp_nat_mul, ← Real.exp_add, Real.norm_of_nonneg (Real.exp_pos _).le, Real.exp_le_exp, add_mul,\n      eventually_inf_principal, eventually_comap, one_mul]\n    filter_upwards [eventually_ge_at_top (1 : exprℝ)]with r hr z hzr hre\n    subst r\n    refine' add_le_add (mul_le_mul_of_nonneg_left _ n.cast_nonneg) _\n    ·\n      calc\n        z.re ≤ abs z := re_le_abs _\n        _ = abs z ^ (1 : exprℝ) := (real.rpow_one _).symm\n        _ ≤ abs z ^ max c 1 := real.rpow_le_rpow_of_exponent_le hr (le_max_right _ _)\n        \n    ·\n      exact\n        mul_le_mul (le_max_left _ _) (real.rpow_le_rpow_of_exponent_le hr (le_max_left _ _))\n          (real.rpow_nonneg_of_nonneg (complex.abs.nonneg _) _) (le_max_right _ _)\n  · rw [tendsto_zero_iff_norm_tendsto_zero]\n    simp only [hg]\n    exact hre n\n  · rw [hg, of_real_mul_re, I_re, MulZeroClass.mul_zero, Real.exp_zero, one_pow, one_mul]\n    exact hC y\n#align eq_zero_on_right_half_plane_of_superexponential_decay eq_zero_on_right_half_plane_of_superexponential_decay\n\n",
 "eq_zero_on_quadrant_IV":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ×ℂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =O[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ×ℂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprexpR -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- **Phragmen-Lindelöf principle** in the fourth quadrant. Let `f : ℂ → E` be a function such that\n\n* `f` is differentiable in the open fourth quadrant and is continuous on its closure;\n* `‖f z‖` is bounded from above by `A * exp(B * (abs z) ^ c)` on the open fourth quadrant\n  for some `A`, `B`, and `c < 2`;\n* `f` is equal to zero on the boundary of the fourth quadrant.\n\nThen `f` is equal to zero on the closed fourth quadrant. -/\ntheorem eq_zero_on_quadrant_IV (hd : diff_cont_on_cl (exprℂ) f («expr ×ℂ » (Ioi 0) (Iio 0)))\n    (hB :\n      ∃ c < (2 : exprℝ),\n        ∃ B,\n          «expr =O[ ] » f («expr ⊓ » (comap Complex.abs atTop) ((filter.principal) («expr ×ℂ » (Ioi 0) (Iio 0))))\n            fun z => (exprexpR) (B * abs z ^ c))\n    (hre : ∀ x : exprℝ, 0 ≤ x → f x = 0) (him : ∀ x : exprℝ, x ≤ 0 → f (x * I) = 0) :\n    EqOn f 0 { z | 0 ≤ z.re ∧ z.im ≤ 0 } := fun z hz =>\n  norm_le_zero_iff.1 <|\n    quadrant_IV hd hB (fun x hx => norm_le_zero_iff.2 <| hre x hx) (fun x hx => norm_le_zero_iff.2 <| him x hx) hz.1\n      hz.2\n#align eq_zero_on_quadrant_IV eq_zero_on_quadrant_IV\n\n",
 "eq_zero_on_quadrant_III":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ×ℂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =O[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ×ℂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprexpR -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- **Phragmen-Lindelöf principle** in the third quadrant. Let `f : ℂ → E` be a function such that\n\n* `f` is differentiable in the open third quadrant and is continuous on its closure;\n* `‖f z‖` is bounded from above by `A * exp(B * (abs z) ^ c)` on the open third quadrant\n  for some `A`, `B`, and `c < 2`;\n* `f` is equal to zero on the boundary of the third quadrant.\n\nThen `f` is equal to zero on the closed third quadrant. -/\ntheorem eq_zero_on_quadrant_III (hd : diff_cont_on_cl (exprℂ) f («expr ×ℂ » (Iio 0) (Iio 0)))\n    (hB :\n      ∃ c < (2 : exprℝ),\n        ∃ B,\n          «expr =O[ ] » f («expr ⊓ » (comap Complex.abs atTop) ((filter.principal) («expr ×ℂ » (Iio 0) (Iio 0))))\n            fun z => (exprexpR) (B * abs z ^ c))\n    (hre : ∀ x : exprℝ, x ≤ 0 → f x = 0) (him : ∀ x : exprℝ, x ≤ 0 → f (x * I) = 0) :\n    EqOn f 0 { z | z.re ≤ 0 ∧ z.im ≤ 0 } := fun z hz =>\n  norm_le_zero_iff.1 <|\n    quadrant_III hd hB (fun x hx => norm_le_zero_iff.2 <| hre x hx) (fun x hx => norm_le_zero_iff.2 <| him x hx) hz.1\n      hz.2\n#align eq_zero_on_quadrant_III eq_zero_on_quadrant_III\n\n",
 "eq_zero_on_quadrant_II":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ×ℂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =O[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ×ℂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprexpR -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- **Phragmen-Lindelöf principle** in the second quadrant. Let `f : ℂ → E` be a function such that\n\n* `f` is differentiable in the open second quadrant and is continuous on its closure;\n* `‖f z‖` is bounded from above by `A * exp(B * (abs z) ^ c)` on the open second quadrant\n  for some `A`, `B`, and `c < 2`;\n* `f` is equal to zero on the boundary of the second quadrant.\n\nThen `f` is equal to zero on the closed second quadrant. -/\ntheorem eq_zero_on_quadrant_II (hd : diff_cont_on_cl (exprℂ) f («expr ×ℂ » (Iio 0) (Ioi 0)))\n    (hB :\n      ∃ c < (2 : exprℝ),\n        ∃ B,\n          «expr =O[ ] » f («expr ⊓ » (comap Complex.abs atTop) ((filter.principal) («expr ×ℂ » (Iio 0) (Ioi 0))))\n            fun z => (exprexpR) (B * abs z ^ c))\n    (hre : ∀ x : exprℝ, x ≤ 0 → f x = 0) (him : ∀ x : exprℝ, 0 ≤ x → f (x * I) = 0) :\n    EqOn f 0 { z | z.re ≤ 0 ∧ 0 ≤ z.im } := fun z hz =>\n  norm_le_zero_iff.1 <|\n    quadrant_II hd hB (fun x hx => norm_le_zero_iff.2 <| hre x hx) (fun x hx => norm_le_zero_iff.2 <| him x hx) hz.1\n      hz.2\n#align eq_zero_on_quadrant_II eq_zero_on_quadrant_II\n\n",
 "eq_zero_on_quadrant_I":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ×ℂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =O[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ×ℂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprexpR -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- **Phragmen-Lindelöf principle** in the first quadrant. Let `f : ℂ → E` be a function such that\n\n* `f` is differentiable in the open first quadrant and is continuous on its closure;\n* `‖f z‖` is bounded from above by `A * exp(B * (abs z) ^ c)` on the open first quadrant\n  for some `A`, `B`, and `c < 2`;\n* `f` is equal to zero on the boundary of the first quadrant.\n\nThen `f` is equal to zero on the closed first quadrant. -/\ntheorem eq_zero_on_quadrant_I (hd : diff_cont_on_cl (exprℂ) f («expr ×ℂ » (Ioi 0) (Ioi 0)))\n    (hB :\n      ∃ c < (2 : exprℝ),\n        ∃ B,\n          «expr =O[ ] » f («expr ⊓ » (comap Complex.abs atTop) ((filter.principal) («expr ×ℂ » (Ioi 0) (Ioi 0))))\n            fun z => (exprexpR) (B * abs z ^ c))\n    (hre : ∀ x : exprℝ, 0 ≤ x → f x = 0) (him : ∀ x : exprℝ, 0 ≤ x → f (x * I) = 0) :\n    EqOn f 0 { z | 0 ≤ z.re ∧ 0 ≤ z.im } := fun z hz =>\n  norm_le_zero_iff.1 <|\n    quadrant_I hd hB (fun x hx => norm_le_zero_iff.2 <| hre x hx) (fun x hx => norm_le_zero_iff.2 <| him x hx) hz.1 hz.2\n#align eq_zero_on_quadrant_I eq_zero_on_quadrant_I\n\n",
 "eq_zero_on_horizontal_strip":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `real.pi -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =O[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprexpR -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprexpR -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/-- **Phragmen-Lindelöf principle** in a strip `U = {z : ℂ | a < im z < b}`.\nLet `f : ℂ → E` be a function such that\n\n* `f` is differentiable on `U` and is continuous on its closure;\n* `‖f z‖` is bounded from above by `A * exp(B * exp(c * |re z|))` on `U` for some `c < π / (b - a)`;\n* `f z = 0` on the boundary of `U`.\n\nThen `f` is equal to zero on the closed strip `{z : ℂ | a ≤ im z ≤ b}`.\n-/\ntheorem eq_zero_on_horizontal_strip (hd : diff_cont_on_cl (exprℂ) f («expr ⁻¹' » im (Ioo a b)))\n    (hB :\n      ∃ c < real.pi / (b - a),\n        ∃ B,\n          «expr =O[ ] » f («expr ⊓ » (comap (has_abs.abs ∘ re) atTop) ((filter.principal) («expr ⁻¹' » im (Ioo a b))))\n            fun z => (exprexpR) (B * (exprexpR) (c * |z.re|)))\n    (ha : ∀ z : exprℂ, z.im = a → f z = 0) (hb : ∀ z : exprℂ, z.im = b → f z = 0) :\n    EqOn f 0 («expr ⁻¹' » im (Icc a b)) := fun z hz =>\n  norm_le_zero_iff.1 <|\n    horizontal_strip hd hB (fun z hz => (ha z hz).symm ▸ norm_zero.le) (fun z hz => (hb z hz).symm ▸ norm_zero.le) hz.1\n      hz.2\n#align eq_zero_on_horizontal_strip eq_zero_on_horizontal_strip\n\n",
 "eq_on_vertical_strip":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `real.pi -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =O[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprexpR -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprexpR -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `real.pi -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =O[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprexpR -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprexpR -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/-- **Phragmen-Lindelöf principle** in a strip `U = {z : ℂ | a < re z < b}`.\nLet `f g : ℂ → E` be functions such that\n\n* `f` and `g` are differentiable on `U` and are continuous on its closure;\n* `‖f z‖` and `‖g z‖` are bounded from above by `A * exp(B * exp(c * |im z|))` on `U` for some\n  `c < π / (b - a)`;\n* `f z = g z` on the boundary of `U`.\n\nThen `f` is equal to `g` on the closed strip `{z : ℂ | a ≤ re z ≤ b}`.\n-/\ntheorem eq_on_vertical_strip {g : exprℂ → E} (hdf : diff_cont_on_cl (exprℂ) f («expr ⁻¹' » re (Ioo a b)))\n    (hBf :\n      ∃ c < real.pi / (b - a),\n        ∃ B,\n          «expr =O[ ] » f («expr ⊓ » (comap (has_abs.abs ∘ im) atTop) ((filter.principal) («expr ⁻¹' » re (Ioo a b))))\n            fun z => (exprexpR) (B * (exprexpR) (c * |z.im|)))\n    (hdg : diff_cont_on_cl (exprℂ) g («expr ⁻¹' » re (Ioo a b)))\n    (hBg :\n      ∃ c < real.pi / (b - a),\n        ∃ B,\n          «expr =O[ ] » g («expr ⊓ » (comap (has_abs.abs ∘ im) atTop) ((filter.principal) («expr ⁻¹' » re (Ioo a b))))\n            fun z => (exprexpR) (B * (exprexpR) (c * |z.im|)))\n    (ha : ∀ z : exprℂ, re z = a → f z = g z) (hb : ∀ z : exprℂ, re z = b → f z = g z) :\n    EqOn f g («expr ⁻¹' » re (Icc a b)) := fun z hz =>\n  sub_eq_zero.1\n    (eq_zero_on_vertical_strip (hdf.sub hdg) (is_O_sub_exp_exp hBf hBg) (fun w hw => sub_eq_zero.2 (ha w hw))\n      (fun w hw => sub_eq_zero.2 (hb w hw)) hz)\n#align eq_on_vertical_strip eq_on_vertical_strip\n\n",
 "eq_on_right_half_plane_of_superexponential_decay":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =O[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprexpR -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprexpR -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =O[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprexpR -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =O[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprexpR -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprexpR -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/-- **Phragmen-Lindelöf principle** in the right half-plane. Let `f g : ℂ → E` be functions such\nthat\n\n* `f` and `g` are differentiable in the open right half-plane and are continuous on its closure;\n* `‖f z‖` and `‖g z‖` are bounded from above by `A * exp(B * (abs z) ^ c)` on the open right\n  half-plane for some `c < 2`;\n* `‖f z‖` and `‖g z‖` are bounded from above by constants on the imaginary axis;\n* `f x - g x`, `x : ℝ`, tends to zero superexponentially fast as `x → ∞`:\n  for any natural `n`, `exp (n * x) * ‖f x - g x‖` tends to zero as `x → ∞`.\n\nThen `f` is equal to `g` on the closed right half-plane. -/\ntheorem eq_on_right_half_plane_of_superexponential_decay {g : exprℂ → E}\n    (hfd : diff_cont_on_cl (exprℂ) f { z | 0 < z.re }) (hgd : diff_cont_on_cl (exprℂ) g { z | 0 < z.re })\n    (hfexp :\n      ∃ c < (2 : exprℝ),\n        ∃ B,\n          «expr =O[ ] » f («expr ⊓ » (comap Complex.abs atTop) ((filter.principal) { z | 0 < z.re })) fun z =>\n            (exprexpR) (B * abs z ^ c))\n    (hgexp :\n      ∃ c < (2 : exprℝ),\n        ∃ B,\n          «expr =O[ ] » g («expr ⊓ » (comap Complex.abs atTop) ((filter.principal) { z | 0 < z.re })) fun z =>\n            (exprexpR) (B * abs z ^ c))\n    (hre : SuperpolynomialDecay atTop (exprexpR) fun x => «expr‖ ‖» (f x - g x))\n    (hfim : ∃ C, ∀ x : exprℝ, «expr‖ ‖» (f (x * I)) ≤ C) (hgim : ∃ C, ∀ x : exprℝ, «expr‖ ‖» (g (x * I)) ≤ C) :\n    EqOn f g { z : exprℂ | 0 ≤ z.re } :=\n  by\n  suffices eq_on (f - g) 0 { z : exprℂ | 0 ≤ z.re } by\n    simpa only [eq_on, Pi.sub_apply, Pi.zero_apply, sub_eq_zero] using this\n  refine' eq_zero_on_right_half_plane_of_superexponential_decay (hfd.sub hgd) _ hre _\n  · set l : Filter (exprℂ) := «expr ⊓ » (comap Complex.abs at_top) ((filter.principal) { z : exprℂ | 0 < z.re })\n    suffices\n      ∀ {c₁ c₂ B₁ B₂ : exprℝ},\n        c₁ ≤ c₂ →\n          B₁ ≤ B₂ →\n            0 ≤ B₂ → «expr =O[ ] » (fun z => (exprexpR) (B₁ * abs z ^ c₁)) l fun z => (exprexpR) (B₂ * abs z ^ c₂)\n      by\n      rcases hfexp with ⟨cf, hcf, Bf, hOf⟩\n      rcases hgexp with ⟨cg, hcg, Bg, hOg⟩\n      refine' ⟨max cf cg, max_lt hcf hcg, max 0 (max Bf Bg), _⟩\n      refine' is_O.sub (hOf.trans <| this _ _ _) (hOg.trans <| this _ _ _) <;> simp\n    intro c₁ c₂ B₁ B₂ hc hB hB₂\n    have :\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" l\n        (1 ≤ abs z) :=\n      ((eventually_ge_at_top 1).comap _).filter_mono inf_le_left\n    refine' is_O.of_bound 1 (this.mono fun z hz => _)\n    simp only [Real.norm_of_nonneg (Real.exp_pos _).le, Real.exp_le_exp, one_mul]\n    exact\n      mul_le_mul hB (real.rpow_le_rpow_of_exponent_le hz hc) (real.rpow_nonneg_of_nonneg (complex.abs.nonneg _) _) hB₂\n  · rcases hfim with ⟨Cf, hCf⟩\n    rcases hgim with ⟨Cg, hCg⟩\n    exact ⟨Cf + Cg, fun x => norm_sub_le_of_le (hCf x) (hCg x)⟩\n#align eq_on_right_half_plane_of_superexponential_decay eq_on_right_half_plane_of_superexponential_decay\n\n",
 "eq_on_quadrant_IV":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ×ℂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =O[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ×ℂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprexpR -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ×ℂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =O[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ×ℂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprexpR -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- **Phragmen-Lindelöf principle** in the fourth quadrant. Let `f g : ℂ → E` be functions such that\n\n* `f` and `g` are differentiable in the open fourth quadrant and are continuous on its closure;\n* `‖f z‖` and `‖g z‖` are bounded from above by `A * exp(B * (abs z) ^ c)` on the open fourth\n  quadrant for some `A`, `B`, and `c < 2`;\n* `f` is equal to `g` on the boundary of the fourth quadrant.\n\nThen `f` is equal to `g` on the closed fourth quadrant. -/\ntheorem eq_on_quadrant_IV (hdf : diff_cont_on_cl (exprℂ) f («expr ×ℂ » (Ioi 0) (Iio 0)))\n    (hBf :\n      ∃ c < (2 : exprℝ),\n        ∃ B,\n          «expr =O[ ] » f («expr ⊓ » (comap Complex.abs atTop) ((filter.principal) («expr ×ℂ » (Ioi 0) (Iio 0))))\n            fun z => (exprexpR) (B * abs z ^ c))\n    (hdg : diff_cont_on_cl (exprℂ) g («expr ×ℂ » (Ioi 0) (Iio 0)))\n    (hBg :\n      ∃ c < (2 : exprℝ),\n        ∃ B,\n          «expr =O[ ] » g («expr ⊓ » (comap Complex.abs atTop) ((filter.principal) («expr ×ℂ » (Ioi 0) (Iio 0))))\n            fun z => (exprexpR) (B * abs z ^ c))\n    (hre : ∀ x : exprℝ, 0 ≤ x → f x = g x) (him : ∀ x : exprℝ, x ≤ 0 → f (x * I) = g (x * I)) :\n    EqOn f g { z | 0 ≤ z.re ∧ z.im ≤ 0 } := fun z hz =>\n  sub_eq_zero.1 <|\n    eq_zero_on_quadrant_IV (hdf.sub hdg) (is_O_sub_exp_rpow hBf hBg) (fun x hx => sub_eq_zero.2 <| hre x hx)\n      (fun x hx => sub_eq_zero.2 <| him x hx) hz\n#align eq_on_quadrant_IV eq_on_quadrant_IV\n\n",
 "eq_on_quadrant_III":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ×ℂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =O[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ×ℂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprexpR -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ×ℂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =O[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ×ℂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprexpR -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- **Phragmen-Lindelöf principle** in the third quadrant. Let `f g : ℂ → E` be functions such that\n\n* `f` and `g` are differentiable in the open third quadrant and are continuous on its closure;\n* `‖f z‖` and `‖g z‖` are bounded from above by `A * exp(B * (abs z) ^ c)` on the open third\n  quadrant for some `A`, `B`, and `c < 2`;\n* `f` is equal to `g` on the boundary of the third quadrant.\n\nThen `f` is equal to `g` on the closed third quadrant. -/\ntheorem eq_on_quadrant_III (hdf : diff_cont_on_cl (exprℂ) f («expr ×ℂ » (Iio 0) (Iio 0)))\n    (hBf :\n      ∃ c < (2 : exprℝ),\n        ∃ B,\n          «expr =O[ ] » f («expr ⊓ » (comap Complex.abs atTop) ((filter.principal) («expr ×ℂ » (Iio 0) (Iio 0))))\n            fun z => (exprexpR) (B * abs z ^ c))\n    (hdg : diff_cont_on_cl (exprℂ) g («expr ×ℂ » (Iio 0) (Iio 0)))\n    (hBg :\n      ∃ c < (2 : exprℝ),\n        ∃ B,\n          «expr =O[ ] » g («expr ⊓ » (comap Complex.abs atTop) ((filter.principal) («expr ×ℂ » (Iio 0) (Iio 0))))\n            fun z => (exprexpR) (B * abs z ^ c))\n    (hre : ∀ x : exprℝ, x ≤ 0 → f x = g x) (him : ∀ x : exprℝ, x ≤ 0 → f (x * I) = g (x * I)) :\n    EqOn f g { z | z.re ≤ 0 ∧ z.im ≤ 0 } := fun z hz =>\n  sub_eq_zero.1 <|\n    eq_zero_on_quadrant_III (hdf.sub hdg) (is_O_sub_exp_rpow hBf hBg) (fun x hx => sub_eq_zero.2 <| hre x hx)\n      (fun x hx => sub_eq_zero.2 <| him x hx) hz\n#align eq_on_quadrant_III eq_on_quadrant_III\n\n",
 "eq_on_quadrant_II":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ×ℂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =O[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ×ℂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprexpR -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ×ℂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =O[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ×ℂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprexpR -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- **Phragmen-Lindelöf principle** in the second quadrant. Let `f g : ℂ → E` be functions such that\n\n* `f` and `g` are differentiable in the open second quadrant and are continuous on its closure;\n* `‖f z‖` and `‖g z‖` are bounded from above by `A * exp(B * (abs z) ^ c)` on the open second\n  quadrant for some `A`, `B`, and `c < 2`;\n* `f` is equal to `g` on the boundary of the second quadrant.\n\nThen `f` is equal to `g` on the closed second quadrant. -/\ntheorem eq_on_quadrant_II (hdf : diff_cont_on_cl (exprℂ) f («expr ×ℂ » (Iio 0) (Ioi 0)))\n    (hBf :\n      ∃ c < (2 : exprℝ),\n        ∃ B,\n          «expr =O[ ] » f («expr ⊓ » (comap Complex.abs atTop) ((filter.principal) («expr ×ℂ » (Iio 0) (Ioi 0))))\n            fun z => (exprexpR) (B * abs z ^ c))\n    (hdg : diff_cont_on_cl (exprℂ) g («expr ×ℂ » (Iio 0) (Ioi 0)))\n    (hBg :\n      ∃ c < (2 : exprℝ),\n        ∃ B,\n          «expr =O[ ] » g («expr ⊓ » (comap Complex.abs atTop) ((filter.principal) («expr ×ℂ » (Iio 0) (Ioi 0))))\n            fun z => (exprexpR) (B * abs z ^ c))\n    (hre : ∀ x : exprℝ, x ≤ 0 → f x = g x) (him : ∀ x : exprℝ, 0 ≤ x → f (x * I) = g (x * I)) :\n    EqOn f g { z | z.re ≤ 0 ∧ 0 ≤ z.im } := fun z hz =>\n  sub_eq_zero.1 <|\n    eq_zero_on_quadrant_II (hdf.sub hdg) (is_O_sub_exp_rpow hBf hBg) (fun x hx => sub_eq_zero.2 <| hre x hx)\n      (fun x hx => sub_eq_zero.2 <| him x hx) hz\n#align eq_on_quadrant_II eq_on_quadrant_II\n\n",
 "eq_on_quadrant_I":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ×ℂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =O[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ×ℂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprexpR -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ×ℂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =O[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ×ℂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprexpR -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- **Phragmen-Lindelöf principle** in the first quadrant. Let `f g : ℂ → E` be functions such that\n\n* `f` and `g` are differentiable in the open first quadrant and are continuous on its closure;\n* `‖f z‖` and `‖g z‖` are bounded from above by `A * exp(B * (abs z) ^ c)` on the open first\n  quadrant for some `A`, `B`, and `c < 2`;\n* `f` is equal to `g` on the boundary of the first quadrant.\n\nThen `f` is equal to `g` on the closed first quadrant. -/\ntheorem eq_on_quadrant_I (hdf : diff_cont_on_cl (exprℂ) f («expr ×ℂ » (Ioi 0) (Ioi 0)))\n    (hBf :\n      ∃ c < (2 : exprℝ),\n        ∃ B,\n          «expr =O[ ] » f («expr ⊓ » (comap Complex.abs atTop) ((filter.principal) («expr ×ℂ » (Ioi 0) (Ioi 0))))\n            fun z => (exprexpR) (B * abs z ^ c))\n    (hdg : diff_cont_on_cl (exprℂ) g («expr ×ℂ » (Ioi 0) (Ioi 0)))\n    (hBg :\n      ∃ c < (2 : exprℝ),\n        ∃ B,\n          «expr =O[ ] » g («expr ⊓ » (comap Complex.abs atTop) ((filter.principal) («expr ×ℂ » (Ioi 0) (Ioi 0))))\n            fun z => (exprexpR) (B * abs z ^ c))\n    (hre : ∀ x : exprℝ, 0 ≤ x → f x = g x) (him : ∀ x : exprℝ, 0 ≤ x → f (x * I) = g (x * I)) :\n    EqOn f g { z | 0 ≤ z.re ∧ 0 ≤ z.im } := fun z hz =>\n  sub_eq_zero.1 <|\n    eq_zero_on_quadrant_I (hdf.sub hdg) (is_O_sub_exp_rpow hBf hBg) (fun x hx => sub_eq_zero.2 <| hre x hx)\n      (fun x hx => sub_eq_zero.2 <| him x hx) hz\n#align eq_on_quadrant_I eq_on_quadrant_I\n\n",
 "eq_on_horizontal_strip":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `real.pi -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =O[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprexpR -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprexpR -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `real.pi -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =O[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprexpR -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprexpR -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/-- **Phragmen-Lindelöf principle** in a strip `U = {z : ℂ | a < im z < b}`.\nLet `f g : ℂ → E` be functions such that\n\n* `f` and `g` are differentiable on `U` and are continuous on its closure;\n* `‖f z‖` and `‖g z‖` are bounded from above by `A * exp(B * exp(c * |re z|))` on `U` for some\n  `c < π / (b - a)`;\n* `f z = g z` on the boundary of `U`.\n\nThen `f` is equal to `g` on the closed strip `{z : ℂ | a ≤ im z ≤ b}`.\n-/\ntheorem eq_on_horizontal_strip {g : exprℂ → E} (hdf : diff_cont_on_cl (exprℂ) f («expr ⁻¹' » im (Ioo a b)))\n    (hBf :\n      ∃ c < real.pi / (b - a),\n        ∃ B,\n          «expr =O[ ] » f («expr ⊓ » (comap (has_abs.abs ∘ re) atTop) ((filter.principal) («expr ⁻¹' » im (Ioo a b))))\n            fun z => (exprexpR) (B * (exprexpR) (c * |z.re|)))\n    (hdg : diff_cont_on_cl (exprℂ) g («expr ⁻¹' » im (Ioo a b)))\n    (hBg :\n      ∃ c < real.pi / (b - a),\n        ∃ B,\n          «expr =O[ ] » g («expr ⊓ » (comap (has_abs.abs ∘ re) atTop) ((filter.principal) («expr ⁻¹' » im (Ioo a b))))\n            fun z => (exprexpR) (B * (exprexpR) (c * |z.re|)))\n    (ha : ∀ z : exprℂ, z.im = a → f z = g z) (hb : ∀ z : exprℂ, z.im = b → f z = g z) :\n    EqOn f g («expr ⁻¹' » im (Icc a b)) := fun z hz =>\n  sub_eq_zero.1\n    (eq_zero_on_horizontal_strip (hdf.sub hdg) (is_O_sub_exp_exp hBf hBg) (fun w hw => sub_eq_zero.2 (ha w hw))\n      (fun w hw => sub_eq_zero.2 (hb w hw)) hz)\n#align eq_on_horizontal_strip eq_on_horizontal_strip\n\n"}