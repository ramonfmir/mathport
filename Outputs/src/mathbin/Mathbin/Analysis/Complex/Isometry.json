{"to_matrix_rotation":
 "/-- The matrix representation of `rotation a` is equal to the conformal matrix\n`!![re a, -im a; im a, re a]`. -/\ntheorem to_matrix_rotation (a : circle) :\n    LinearMap.toMatrix basisOneI basisOneI (rotation a).to_linear_equiv =\n      matrix.plane_conformal_matrix (re a) (im a) (by simp [pow_two, ← norm_sq_apply]) :=\n  by\n  ext (i j)\n  simp [LinearMap.toMatrix_apply]\n  fin_cases i <;> fin_cases j <;> simp\n#align to_matrix_rotation to_matrix_rotation\n\n",
 "rotation_trans":
 "@[simp]\ntheorem rotation_trans (a b : circle) : (rotation a).trans (rotation b) = rotation (b * a) :=\n  by\n  ext1\n  simp\n#align rotation_trans rotation_trans\n\n",
 "rotation_symm":
 "@[simp]\ntheorem rotation_symm (a : circle) : (rotation a).symm = rotation a⁻¹ :=\n  LinearIsometryEquiv.ext fun x => rfl\n#align rotation_symm rotation_symm\n\n",
 "rotation_of_rotation":
 "@[simp]\ntheorem rotation_of_rotation (a : circle) : rotation_of (rotation a) = a :=\n  Subtype.ext <| by simp\n#align rotation_of_rotation rotation_of_rotation\n\n",
 "rotation_ne_conj_lie":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `star_ring_end -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `star_ring_end -/\ntheorem rotation_ne_conj_lie (a : circle) : rotation a ≠ conj_lie :=\n  by\n  intro h\n  have h1 : rotation a 1 = (star_ring_end) 1 := LinearIsometryEquiv.congr_fun h 1\n  have hI : rotation a I = (star_ring_end) I := LinearIsometryEquiv.congr_fun h I\n  rw [rotation_apply, RingHom.map_one, mul_one] at h1\n  rw [rotation_apply, conj_I, ← neg_one_mul, mul_left_inj' I_ne_zero, h1, eq_neg_self_iff] at hI\n  exact one_ne_zero hI\n#align rotation_ne_conj_lie rotation_ne_conj_lie\n\n",
 "rotation_injective":
 "theorem rotation_injective : function.injective rotation :=\n  function.left_inverse.injective rotation_of_rotation\n#align rotation_injective rotation_injective\n\n",
 "rotation_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/-\nCopyright (c) 2021 François Sunatori. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: François Sunatori\n-/\n@[simp]\ntheorem rotation_apply (a : circle) (z : exprℂ) : rotation a z = a * z :=\n  rfl\n#align rotation_apply rotation_apply\n\n",
 "re_apply_eq_re_of_add_conj_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗᵢ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `star_ring_end -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `star_ring_end -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\ntheorem linear_isometry.re_apply_eq_re_of_add_conj_eq (f : «expr →ₗᵢ[ ] » (exprℂ) (exprℝ) (exprℂ))\n    (h₃ : ∀ z, z + (star_ring_end) z = f z + (star_ring_end) (f z)) (z : exprℂ) : (f z).re = z.re := by\n  simpa [ext_iff, add_re, add_im, conj_re, conj_im, ← two_mul, show (2 : exprℝ) ≠ 0 by simp [two_ne_zero]] using\n    (h₃ z).symm\n#align linear_isometry.re_apply_eq_re_of_add_conj_eq linear_isometry.re_apply_eq_re_of_add_conj_eq\n\n",
 "re_apply_eq_re":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗᵢ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\ntheorem linear_isometry.re_apply_eq_re {f : «expr →ₗᵢ[ ] » (exprℂ) (exprℝ) (exprℂ)} (h : f 1 = 1) (z : exprℂ) :\n    (f z).re = z.re := by\n  apply linear_isometry.re_apply_eq_re_of_add_conj_eq\n  intro z\n  apply linear_isometry.im_apply_eq_im h\n#align linear_isometry.re_apply_eq_re linear_isometry.re_apply_eq_re\n\n",
 "linear_isometry_complex_aux":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `complex.abs -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗᵢ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\ntheorem linear_isometry_complex_aux {f : «expr ≃ₗᵢ[ ] » (exprℂ) (exprℝ) (exprℂ)} (h : f 1 = 1) :\n    f = LinearIsometryEquiv.refl (exprℝ) (exprℂ) ∨ f = conj_lie :=\n  by\n  have h0 : f I = I ∨ f I = -I :=\n    by\n    have : complex.abs (f I) = 1 := by simpa using f.norm_map Complex.I\n    simp only [ext_iff, ← and_or_left, neg_re, I_re, neg_im, neg_zero]\n    constructor\n    · rw [← I_re]\n      exact @linear_isometry.re_apply_eq_re f.to_linear_isometry h I\n    · apply @linear_isometry.im_apply_eq_im_or_neg_of_re_apply_eq_re f.to_linear_isometry\n      intro z\n      rw [@linear_isometry.re_apply_eq_re f.to_linear_isometry h]\n  refine' h0.imp (fun h' : f I = I => _) fun h' : f I = -I => _ <;>\n    · apply LinearIsometryEquiv.toLinearEquiv_injective\n      apply complex.basis_one_I.ext'\n      intro i\n      fin_cases i <;> simp [h, h']\n#align linear_isometry_complex_aux linear_isometry_complex_aux\n\n",
 "linear_isometry_complex":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗᵢ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\ntheorem linear_isometry_complex (f : «expr ≃ₗᵢ[ ] » (exprℂ) (exprℝ) (exprℂ)) :\n    ∃ a : circle, f = rotation a ∨ f = conj_lie.trans (rotation a) :=\n  by\n  let a : circle := ⟨f 1, by simpa using f.norm_map 1⟩\n  use a\n  have : (f.trans (rotation a).symm) 1 = 1 := by simpa using rotation_apply a⁻¹ (f 1)\n  refine' (linear_isometry_complex_aux this).imp (fun h₁ => _) fun h₂ => _\n  · simpa using eq_mul_of_inv_mul_eq h₁\n  · exact eq_mul_of_inv_mul_eq h₂\n#align linear_isometry_complex linear_isometry_complex\n\n",
 "linear_equiv_det_rotation":
 "/-- The determinant of `rotation` (as a linear equiv) is equal to `1`. -/\n@[simp]\ntheorem linear_equiv_det_rotation (a : circle) : (rotation a).to_linear_equiv.det = 1 := by\n  rw [← Units.eq_iff, LinearEquiv.coe_det, det_rotation, Units.val_one]\n#align linear_equiv_det_rotation linear_equiv_det_rotation\n\n",
 "im_apply_eq_im_or_neg_of_re_apply_eq_re":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗᵢ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\ntheorem linear_isometry.im_apply_eq_im_or_neg_of_re_apply_eq_re {f : «expr →ₗᵢ[ ] » (exprℂ) (exprℝ) (exprℂ)}\n    (h₂ : ∀ z, (f z).re = z.re) (z : exprℂ) : (f z).im = z.im ∨ (f z).im = -z.im :=\n  by\n  have h₁ := f.norm_map z\n  simp only [Complex.abs_def, norm_eq_abs] at h₁\n  rwa [Real.sqrt_inj (norm_sq_nonneg _) (norm_sq_nonneg _), norm_sq_apply (f z), norm_sq_apply z, h₂,\n    add_left_cancel_iff, mul_self_eq_mul_self_iff] at h₁\n#align linear_isometry.im_apply_eq_im_or_neg_of_re_apply_eq_re linear_isometry.im_apply_eq_im_or_neg_of_re_apply_eq_re\n\n",
 "im_apply_eq_im":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗᵢ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `star_ring_end -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `star_ring_end -/\ntheorem linear_isometry.im_apply_eq_im {f : «expr →ₗᵢ[ ] » (exprℂ) (exprℝ) (exprℂ)} (h : f 1 = 1) (z : exprℂ) :\n    z + (star_ring_end) z = f z + (star_ring_end) (f z) :=\n  by\n  have : «expr‖ ‖» (f z - 1) = «expr‖ ‖» (z - 1) := by rw [← f.norm_map (z - 1), f.map_sub, h]\n  apply_fun fun x => x ^ 2  at this\n  simp only [norm_eq_abs, ← norm_sq_eq_abs] at this\n  rw [← of_real_inj, ← mul_conj, ← mul_conj] at this\n  rw [RingHom.map_sub, RingHom.map_sub] at this\n  simp only [sub_mul, mul_sub, one_mul, mul_one] at this\n  rw [mul_conj, norm_sq_eq_abs, ← norm_eq_abs, LinearIsometry.norm_map] at this\n  rw [mul_conj, norm_sq_eq_abs, ← norm_eq_abs] at this\n  simp only [sub_sub, sub_right_inj, mul_one, of_real_pow, RingHom.map_one, norm_eq_abs] at this\n  simp only [add_sub, sub_left_inj] at this\n  rw [add_comm, ← this, add_comm]\n#align linear_isometry.im_apply_eq_im linear_isometry.im_apply_eq_im\n\n",
 "det_rotation":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/-- The determinant of `rotation` (as a linear map) is equal to `1`. -/\n@[simp]\ntheorem det_rotation (a : circle) : ((rotation a).to_linear_equiv : «expr →ₗ[ ] » (exprℂ) (exprℝ) (exprℂ)).det = 1 :=\n  by\n  rw [← LinearMap.det_toMatrix basis_one_I, to_matrix_rotation, Matrix.det_fin_two]\n  simp [← norm_sq_apply]\n#align det_rotation det_rotation\n\n"}