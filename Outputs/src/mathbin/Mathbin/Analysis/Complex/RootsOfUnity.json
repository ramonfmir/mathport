{"norm'_eq_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem is_primitive_root.norm'_eq_one {ζ : exprℂ} {n : ℕ} (h : is_primitive_root ζ n) (hn : n ≠ 0) : «expr‖ ‖» ζ = 1 :=\n  complex.norm_eq_one_of_pow_eq_one h.pow_eq_one hn\n#align is_primitive_root.norm'_eq_one is_primitive_root.norm'_eq_one\n\n",
 "nnnorm_eq_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\ntheorem is_primitive_root.nnnorm_eq_one {ζ : exprℂ} {n : ℕ} (h : is_primitive_root ζ n) (hn : n ≠ 0) :\n    «expr‖ ‖₊» ζ = 1 :=\n  subtype.ext <| h.norm'_eq_one hn\n#align is_primitive_root.nnnorm_eq_one is_primitive_root.nnnorm_eq_one\n\n",
 "mem_roots_of_unity":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `real.pi -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ+» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `real.pi -/\n/-- The complex `n`-th roots of unity are exactly the\ncomplex numbers of the form `e ^ (2 * real.pi * complex.I * (i / n))` for some `i < n`. -/\ntheorem mem_roots_of_unity (n : «exprℕ+») (x : Units (exprℂ)) :\n    x ∈ roots_of_unity n (exprℂ) ↔ ∃ i < (n : ℕ), exp (2 * real.pi * I * (i / n)) = x :=\n  by\n  rw [mem_roots_of_unity, Units.ext_iff, Units.val_pow_eq_pow_val, Units.val_one]\n  have hn0 : (n : exprℂ) ≠ 0 := by exact_mod_cast n.ne_zero\n  constructor\n  · intro h\n    obtain ⟨i, hi, H⟩ : ∃ i < (n : ℕ), exp (2 * real.pi * I / n) ^ i = x := by\n      simpa only using (is_primitive_root_exp n n.ne_zero).eq_pow_of_pow_eq_one h n.pos\n    refine' ⟨i, hi, _⟩\n    rw [← H, ← exp_nat_mul]\n    congr 1\n    field_simp [hn0, mul_comm (i : exprℂ)]\n  · rintro ⟨i, hi, H⟩\n    rw [← H, ← exp_nat_mul, exp_eq_one_iff]\n    use i\n    field_simp [hn0, mul_comm ((n : ℕ) : exprℂ), mul_comm (i : exprℂ)]\n#align mem_roots_of_unity mem_roots_of_unity\n\n",
 "is_primitive_root_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `real.pi -/\ntheorem is_primitive_root_iff (ζ : exprℂ) (n : ℕ) (hn : n ≠ 0) :\n    is_primitive_root ζ n ↔ ∃ i < (n : ℕ), ∃ hi : i.coprime n, exp (2 * real.pi * I * (i / n)) = ζ :=\n  by\n  have hn0 : (n : exprℂ) ≠ 0 := by exact_mod_cast hn\n  constructor; swap\n  · rintro ⟨i, -, hi, rfl⟩\n    exact is_primitive_root_exp_of_coprime i n hn hi\n  intro h\n  obtain ⟨i, hi, rfl⟩ := (is_primitive_root_exp n hn).eq_pow_of_pow_eq_one h.pow_eq_one (nat.pos_of_ne_zero hn)\n  refine' ⟨i, hi, ((is_primitive_root_exp n hn).pow_iff_coprime (nat.pos_of_ne_zero hn) i).mp h, _⟩\n  rw [← exp_nat_mul]\n  congr 1\n  field_simp [hn0, mul_comm (i : exprℂ)]\n#align is_primitive_root_iff is_primitive_root_iff\n\n",
 "is_primitive_root_exp_of_coprime":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `real.pi -/\n/-\nCopyright (c) 2020 Johan Commelin. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johan Commelin\n-/\ntheorem is_primitive_root_exp_of_coprime (i n : ℕ) (h0 : n ≠ 0) (hi : i.coprime n) :\n    is_primitive_root (exp (2 * real.pi * I * (i / n))) n :=\n  by\n  rw [is_primitive_root.iff_def]\n  simp only [← exp_nat_mul, exp_eq_one_iff]\n  have hn0 : (n : exprℂ) ≠ 0 := by exact_mod_cast h0\n  constructor\n  · use i\n    field_simp [hn0, mul_comm (i : exprℂ), mul_comm (n : exprℂ)]\n  · simp only [hn0, mul_right_comm _ _ ↑n, mul_left_inj' two_pi_I_ne_zero, ne.def, not_false_iff,\n      mul_comm _ (i : exprℂ), ← mul_assoc _ (i : exprℂ), exists_imp, field_simps]\n    norm_cast\n    rintro l k hk\n    have : n ∣ i * l := by\n      rw [← Int.coe_nat_dvd, hk]\n      apply dvd_mul_left\n    exact hi.symm.dvd_of_dvd_mul_left this\n#align is_primitive_root_exp_of_coprime is_primitive_root_exp_of_coprime\n\n",
 "is_primitive_root_exp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `real.pi -/\ntheorem is_primitive_root_exp (n : ℕ) (h0 : n ≠ 0) : is_primitive_root (exp (2 * real.pi * I / n)) n := by\n  simpa only [Nat.cast_one, one_div] using is_primitive_root_exp_of_coprime 1 n h0 n.coprime_one_left\n#align is_primitive_root_exp is_primitive_root_exp\n\n",
 "card_roots_of_unity":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ+» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\ntheorem card_roots_of_unity (n : «exprℕ+») : fintype.card (roots_of_unity n (exprℂ)) = n :=\n  (is_primitive_root_exp n n.ne_zero).card_roots_of_unity\n#align card_roots_of_unity card_roots_of_unity\n\n",
 "card_primitive_roots":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.totient -/\ntheorem card_primitive_roots (k : ℕ) : (primitive_roots k (exprℂ)).card = (nat.totient) k :=\n  by\n  by_cases h : k = 0\n  · simp [h]\n  exact (is_primitive_root_exp k h).card_primitive_roots\n#align card_primitive_roots card_primitive_roots\n\n",
 "arg_ext":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\ntheorem is_primitive_root.arg_ext {n m : ℕ} {ζ μ : exprℂ} (hζ : is_primitive_root ζ n) (hμ : is_primitive_root μ m)\n    (hn : n ≠ 0) (hm : m ≠ 0) (h : ζ.arg = μ.arg) : ζ = μ :=\n  complex.ext_abs_arg ((hζ.norm'_eq_one hn).trans (hμ.norm'_eq_one hm).symm) h\n#align is_primitive_root.arg_ext is_primitive_root.arg_ext\n\n",
 "arg_eq_zero_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\ntheorem is_primitive_root.arg_eq_zero_iff {n : ℕ} {ζ : exprℂ} (hζ : is_primitive_root ζ n) (hn : n ≠ 0) :\n    ζ.arg = 0 ↔ ζ = 1 :=\n  ⟨fun h => hζ.arg_ext is_primitive_root.one hn one_ne_zero (h.trans complex.arg_one.symm), fun h =>\n    h.symm ▸ complex.arg_one⟩\n#align is_primitive_root.arg_eq_zero_iff is_primitive_root.arg_eq_zero_iff\n\n",
 "arg_eq_pi_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\ntheorem is_primitive_root.arg_eq_pi_iff {n : ℕ} {ζ : exprℂ} (hζ : is_primitive_root ζ n) (hn : n ≠ 0) :\n    ζ.arg = real.pi ↔ ζ = -1 :=\n  ⟨fun h => hζ.arg_ext (is_primitive_root.neg_one 0 two_ne_zero.symm) hn two_ne_zero (h.trans complex.arg_neg_one.symm),\n    fun h => h.symm ▸ complex.arg_neg_one⟩\n#align is_primitive_root.arg_eq_pi_iff is_primitive_root.arg_eq_pi_iff\n\n",
 "arg":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\ntheorem is_primitive_root.arg {n : ℕ} {ζ : exprℂ} (h : is_primitive_root ζ n) (hn : n ≠ 0) :\n    ∃ i : ℤ, ζ.arg = i / n * (2 * real.pi) ∧ IsCoprime i n ∧ i.nat_abs < n :=\n  by\n  rw [complex.is_primitive_root_iff _ _ hn] at h\n  obtain ⟨i, h, hin, rfl⟩ := h\n  rw [mul_comm, ← mul_assoc, complex.exp_mul_I]\n  refine' ⟨if i * 2 ≤ n then i else i - n, _, _, _⟩\n  on_goal 2 =>\n    replace hin := nat.is_coprime_iff_coprime.mpr hin\n    split_ifs with _\n    · exact hin\n    · convert hin.add_mul_left_left (-1)\n      rw [mul_neg_one, sub_eq_add_neg]\n  on_goal 2 =>\n    split_ifs with h₂\n    · exact_mod_cast h\n    suffices (i - n : ℤ).nat_abs = n - i by\n      rw [this]\n      apply tsub_lt_self hn.bot_lt\n      contrapose! h₂\n      rw [nat.eq_zero_of_le_zero h₂, zero_mul]\n      exact zero_le _\n    rw [← Int.natAbs_neg, neg_sub, Int.natAbs_eq_iff]\n    exact or.inl (Int.ofNat_sub h.le).symm\n  split_ifs with h₂\n  · convert complex.arg_cos_add_sin_mul_I _\n    · push_cast\n    · push_cast\n    field_simp [hn]\n    refine' ⟨(neg_lt_neg real.pi_pos).trans_le _, _⟩\n    · rw [neg_zero]\n      exact mul_nonneg (mul_nonneg i.cast_nonneg <| by simp [real.pi_pos.le]) (by simp)\n    rw [← mul_rotate', mul_div_assoc]\n    rw [← mul_one n] at h₂\n    exact\n      mul_le_of_le_one_right real.pi_pos.le ((div_le_iff' <| by exact_mod_cast pos_of_gt h).mpr <| by exact_mod_cast h₂)\n  rw [← complex.cos_sub_two_pi, ← complex.sin_sub_two_pi]\n  convert complex.arg_cos_add_sin_mul_I _\n  · push_cast\n    rw [← sub_one_mul, sub_div, div_self]\n    exact_mod_cast hn\n  · push_cast\n    rw [← sub_one_mul, sub_div, div_self]\n    exact_mod_cast hn\n  field_simp [hn]\n  refine' ⟨_, le_trans _ real.pi_pos.le⟩\n  on_goal 2 =>\n    rw [mul_div_assoc]\n    exact\n      mul_nonpos_of_nonpos_of_nonneg (sub_nonpos.mpr <| by exact_mod_cast h.le)\n        (div_nonneg (by simp [real.pi_pos.le]) <| by simp)\n  rw [← mul_rotate', mul_div_assoc, neg_lt, ← mul_neg, mul_lt_iff_lt_one_right real.pi_pos, ← neg_div, ← neg_mul,\n    neg_sub, div_lt_iff, one_mul, sub_mul, sub_lt_comm, ← mul_sub_one]\n  norm_num\n  exact_mod_cast not_le.mp h₂\n  · exact nat.cast_pos.mpr hn.bot_lt\n#align is_primitive_root.arg is_primitive_root.arg\n\n"}