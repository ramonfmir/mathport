{"norm_max_aux₃":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem norm_max_aux₃ {f : exprℂ → F} {z w : exprℂ} {r : exprℝ} (hr : dist w z = r)\n    (hd : diff_cont_on_cl (exprℂ) f (ball z r)) (hz : is_max_on (norm ∘ f) (ball z r) z) :\n    «expr‖ ‖» (f w) = «expr‖ ‖» (f z) := by\n  subst r\n  rcases eq_or_ne w z with (rfl | hne); · rfl\n  rw [← dist_ne_zero] at hne\n  exact norm_max_aux₂ hd (closure_ball z hne ▸ hz.closure hd.continuous_on.norm)\n#align norm_max_aux₃ norm_max_aux₃\n\n",
 "norm_max_aux₂":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ̂» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem norm_max_aux₂ {f : exprℂ → F} {z w : exprℂ} (hd : diff_cont_on_cl (exprℂ) f (ball z (dist w z)))\n    (hz : is_max_on (norm ∘ f) (closed_ball z (dist w z)) z) : «expr‖ ‖» (f w) = «expr‖ ‖» (f z) :=\n  by\n  set e : «expr →L[ ] » F (exprℂ) («expr ̂» F) := uniform_space.completion.to_complL\n  have he : ∀ x, «expr‖ ‖» (e x) = «expr‖ ‖» x := uniform_space.completion.norm_coe\n  replace hz : is_max_on (norm ∘ e ∘ f) (closed_ball z (dist w z)) z\n  · simpa only [is_max_on, (· ∘ ·), he] using hz\n  simpa only [he] using norm_max_aux₁ (e.differentiable.comp_diff_cont_on_cl hd) hz\n#align norm_max_aux₂ norm_max_aux₂\n\n",
 "norm_max_aux₁":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∮ inC( , ), » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∮ inC( , ), » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `real.pi -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∮ inC( , ), » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∮ inC( , ), » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `real.pi -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∮ inC( , ), » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∮ inC( , ), » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `real.pi -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/-\nCopyright (c) 2022 Yury G. Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury G. Kudryashov\n-/\ntheorem norm_max_aux₁ [complete_space F] {f : exprℂ → F} {z w : exprℂ}\n    (hd : diff_cont_on_cl (exprℂ) f (ball z (dist w z))) (hz : is_max_on (norm ∘ f) (closed_ball z (dist w z)) z) :\n    «expr‖ ‖» (f w) = «expr‖ ‖» (f z) :=\n  by\n  -- Consider a circle of radius `r = dist w z`.\n  set r : exprℝ := dist w z\n  have hw : w ∈ closed_ball z r := mem_closed_ball.2 le_rfl\n  -- Assume the converse. Since `‖f w‖ ≤ ‖f z‖`, we have `‖f w‖ < ‖f z‖`.\n  refine' (is_max_on_iff.1 hz _ hw).antisymm (not_lt.1 _)\n  rintro hw_lt : «expr‖ ‖» (f w) < «expr‖ ‖» (f z)\n  have hr : 0 < r := dist_pos.2 (ne_of_apply_ne (norm ∘ f) hw_lt.ne)\n  -- Due to Cauchy integral formula, it suffices to prove the following inequality.\n  suffices\n    «expr‖ ‖»\n        («expr∮ inC( , ), » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∮ inC( , ), »\"\n          z r («expr • » (ζ - z)⁻¹ (f ζ))) <\n      2 * real.pi * «expr‖ ‖» (f z)\n    by\n    refine' this.ne _\n    have A :\n      «expr∮ inC( , ), » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∮ inC( , ), »\" z\n          r («expr • » (ζ - z)⁻¹ (f ζ)) =\n        «expr • » (2 * real.pi * I : exprℂ) (f z) :=\n      hd.circle_integral_sub_inv_smul (mem_ball_self hr)\n    simp [A, norm_smul, real.pi_pos.le]\n  suffices\n    «expr‖ ‖»\n        («expr∮ inC( , ), » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∮ inC( , ), »\"\n          z r («expr • » (ζ - z)⁻¹ (f ζ))) <\n      2 * real.pi * r * («expr‖ ‖» (f z) / r)\n    by rwa [mul_assoc, mul_div_cancel' _ hr.ne'] at this\n  /- This inequality is true because `‖(ζ - z)⁻¹ • f ζ‖ ≤ ‖f z‖ / r` for all `ζ` on the circle and\n    this inequality is strict at `ζ = w`. -/\n  have hsub : sphere z r ⊆ closed_ball z r := sphere_subset_closed_ball\n  refine' circle_integral.norm_integral_lt_of_norm_le_const_of_lt hr _ _ ⟨w, rfl, _⟩\n  show continuous_on (fun ζ : exprℂ => «expr • » (ζ - z)⁻¹ (f ζ)) (sphere z r)\n  · refine' ((continuous_on_id.sub continuous_on_const).inv₀ _).smul (hd.continuous_on_ball.mono hsub)\n    exact fun ζ hζ => sub_ne_zero.2 (ne_of_mem_sphere hζ hr.ne')\n  show ∀ ζ ∈ sphere z r, «expr‖ ‖» («expr • » (ζ - z)⁻¹ (f ζ)) ≤ «expr‖ ‖» (f z) / r\n  · rintro ζ (hζ : abs (ζ - z) = r)\n    rw [le_div_iff hr, norm_smul, norm_inv, norm_eq_abs, hζ, mul_comm, mul_inv_cancel_left₀ hr.ne']\n    exact hz (hsub hζ)\n  show «expr‖ ‖» («expr • » (w - z)⁻¹ (f w)) < «expr‖ ‖» (f z) / r\n  · rw [norm_smul, norm_inv, norm_eq_abs, ← div_eq_inv_mul]\n    exact (div_lt_div_right hr).2 hw_lt\n#align norm_max_aux₁ norm_max_aux₁\n\n",
 "norm_le_of_forall_mem_frontier_norm_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/-- **Maximum modulus principle**: if `f : E → F` is complex differentiable on a bounded set `U` and\n`‖f z‖ ≤ C` for any `z ∈ frontier U`, then the same is true for any `z ∈ closure U`. -/\ntheorem norm_le_of_forall_mem_frontier_norm_le {f : E → F} {U : set E} (hU : bounded U)\n    (hd : diff_cont_on_cl (exprℂ) f U) {C : exprℝ} (hC : ∀ z ∈ frontier U, «expr‖ ‖» (f z) ≤ C) {z : E}\n    (hz : z ∈ closure U) : «expr‖ ‖» (f z) ≤ C :=\n  by\n  rw [closure_eq_self_union_frontier, union_comm, mem_union] at hz\n  cases hz\n  · exact hC z hz\n  /- In case of a finite dimensional domain, one can just apply\n    `complex.exists_mem_frontier_is_max_on_norm`. To make it work in any Banach space, we restrict\n    the function to a line first. -/\n  rcases exists_ne z with ⟨w, hne⟩\n  set e : exprℂ → E := line_map z w\n  have hde : differentiable (exprℂ) e := (differentiable_id.smul_const (w - z)).add_const z\n  have hL : antilipschitz_with (nndist z w)⁻¹ e := antilipschitz_with_line_map hne.symm\n  replace hd : diff_cont_on_cl (exprℂ) (f ∘ e) («expr ⁻¹' » e U)\n  exact hd.comp hde.diff_cont_on_cl (maps_to_preimage _ _)\n  have h₀ : (0 : exprℂ) ∈ «expr ⁻¹' » e U := by simpa only [e, mem_preimage, line_map_apply_zero]\n  rcases exists_mem_frontier_is_max_on_norm (hL.bounded_preimage hU) ⟨0, h₀⟩ hd with ⟨ζ, hζU, hζ⟩\n  calc\n    «expr‖ ‖» (f z) = «expr‖ ‖» (f (e 0)) := by simp only [e, line_map_apply_zero]\n    _ ≤ «expr‖ ‖» (f (e ζ)) := hζ (subset_closure h₀)\n    _ ≤ C := hC _ (hde.continuous.frontier_preimage_subset _ hζU)\n    \n#align norm_le_of_forall_mem_frontier_norm_le norm_le_of_forall_mem_frontier_norm_le\n\n",
 "norm_eventually_eq_of_is_local_max":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/-- **Maximum modulus principle**: if `f : E → F` is complex differentiable in a neighborhood of `c`\nand the norm `‖f z‖` has a local maximum at `c`, then `‖f z‖` is locally constant in a neighborhood\nof `c`. -/\ntheorem norm_eventually_eq_of_is_local_max {f : E → F} {c : E}\n    (hd :\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" ((nhds) c)\n        (differentiable_at (exprℂ) f z))\n    (hc : is_local_max (norm ∘ f) c) :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" ((nhds) c)\n      («expr‖ ‖» (f y) = «expr‖ ‖» (f c)) :=\n  by\n  rcases nhds_basis_closed_ball.eventually_iff.1 (hd.and hc) with ⟨r, hr₀, hr⟩\n  exact\n    nhds_basis_closed_ball.eventually_iff.2\n      ⟨r, hr₀,\n        norm_eq_on_closed_ball_of_is_max_on\n          (differentiable_on.diff_cont_on_cl fun x hx =>\n            (hr <| closure_ball_subset_closed_ball hx).1.differentiable_within_at)\n          fun x hx => (hr <| ball_subset_closed_ball hx).2⟩\n#align norm_eventually_eq_of_is_local_max norm_eventually_eq_of_is_local_max\n\n",
 "norm_eq_on_of_is_preconnected_of_is_max_on":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/-- **Maximum modulus principle** on a connected set. Let `U` be a (pre)connected open set in a\ncomplex normed space. Let `f : E → F` be a function that is complex differentiable on `U`. Suppose\nthat `‖f x‖` takes its maximum value on `U` at `c ∈ U`. Then `‖f x‖ = ‖f c‖` for all `x ∈ U`. -/\ntheorem norm_eq_on_of_is_preconnected_of_is_max_on {f : E → F} {U : set E} {c : E} (hc : is_preconnected U)\n    (ho : is_open U) (hd : differentiable_on (exprℂ) f U) (hcU : c ∈ U) (hm : is_max_on (norm ∘ f) U c) :\n    EqOn (norm ∘ f) (const E («expr‖ ‖» (f c))) U :=\n  by\n  set V := U ∩ { z | is_max_on (norm ∘ f) U z }\n  have hV : ∀ x ∈ V, «expr‖ ‖» (f x) = «expr‖ ‖» (f c) := fun x hx => le_antisymm (hm hx.1) (hx.2 hcU)\n  suffices : U ⊆ V\n  exact fun x hx => hV x (this hx)\n  have hVo : is_open V := by\n    simpa only [ho.mem_nhds_iff, set_of_and, set_of_mem_eq] using is_open_set_of_mem_nhds_and_is_max_on_norm hd\n  have hVne : (U ∩ V).nonempty := ⟨c, hcU, hcU, hm⟩\n  set W := U ∩ { z | «expr‖ ‖» (f z) ≠ «expr‖ ‖» (f c) }\n  have hWo : is_open W := hd.continuous_on.norm.preimage_open_of_open ho is_open_ne\n  have hdVW : Disjoint V W := disjoint_left.mpr fun x hxV hxW => hxW.2 (hV x hxV)\n  have hUVW : U ⊆ V ∪ W := fun x hx =>\n    (eq_or_ne («expr‖ ‖» (f x)) («expr‖ ‖» (f c))).imp (fun h => ⟨hx, fun y hy => (hm hy).out.trans_eq h.symm⟩)\n      (and.intro hx)\n  exact hc.subset_left_of_subset_union hVo hWo hdVW hUVW hVne\n#align norm_eq_on_of_is_preconnected_of_is_max_on norm_eq_on_of_is_preconnected_of_is_max_on\n\n",
 "norm_eq_on_closure_of_is_preconnected_of_is_max_on":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/-- **Maximum modulus principle** on a connected set. Let `U` be a (pre)connected open set in a\ncomplex normed space.  Let `f : E → F` be a function that is complex differentiable on `U` and is\ncontinuous on its closure. Suppose that `‖f x‖` takes its maximum value on `U` at `c ∈ U`. Then\n`‖f x‖ = ‖f c‖` for all `x ∈ closure U`. -/\ntheorem norm_eq_on_closure_of_is_preconnected_of_is_max_on {f : E → F} {U : set E} {c : E} (hc : is_preconnected U)\n    (ho : is_open U) (hd : diff_cont_on_cl (exprℂ) f U) (hcU : c ∈ U) (hm : is_max_on (norm ∘ f) U c) :\n    EqOn (norm ∘ f) (const E («expr‖ ‖» (f c))) (closure U) :=\n  (norm_eq_on_of_is_preconnected_of_is_max_on hc ho hd.differentiable_on hcU hm).of_subset_closure hd.continuous_on.norm\n    continuous_on_const subset_closure Subset.rfl\n#align norm_eq_on_closure_of_is_preconnected_of_is_max_on norm_eq_on_closure_of_is_preconnected_of_is_max_on\n\n",
 "norm_eq_on_closed_ball_of_is_max_on":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/-- **Maximum modulus principle** on a closed ball: if `f : E → F` is continuous on a closed ball,\nis complex differentiable on the corresponding open ball, and the norm `‖f w‖` takes its maximum\nvalue on the open ball at its center, then the norm `‖f w‖` is constant on the closed ball.  -/\ntheorem norm_eq_on_closed_ball_of_is_max_on {f : E → F} {z : E} {r : exprℝ} (hd : diff_cont_on_cl (exprℂ) f (ball z r))\n    (hz : is_max_on (norm ∘ f) (ball z r) z) : EqOn (norm ∘ f) (const E («expr‖ ‖» (f z))) (closed_ball z r) :=\n  by\n  intro w hw\n  rw [mem_closed_ball, dist_comm] at hw\n  rcases eq_or_ne z w with (rfl | hne)\n  · rfl\n  set e : exprℂ → E := line_map z w\n  have hde : differentiable (exprℂ) e := (differentiable_id.smul_const (w - z)).add_const z\n  suffices «expr‖ ‖» ((f ∘ e) (1 : exprℂ)) = «expr‖ ‖» ((f ∘ e) (0 : exprℂ)) by simpa [e]\n  have hr : dist (1 : exprℂ) 0 = 1 := by simp\n  have hball : maps_to e (ball 0 1) (ball z r) :=\n    by\n    refine' ((lipschitz_with_line_map z w).maps_to_ball (mt nndist_eq_zero.1 hne) 0 1).mono subset.rfl _\n    simpa only [line_map_apply_zero, mul_one, coe_nndist] using ball_subset_ball hw\n  exact norm_max_aux₃ hr (hd.comp hde.diff_cont_on_cl hball) (hz.comp_maps_to hball (line_map_apply_zero z w))\n#align norm_eq_on_closed_ball_of_is_max_on norm_eq_on_closed_ball_of_is_max_on\n\n",
 "norm_eq_norm_of_is_max_on_of_ball_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/-- **Maximum modulus principle**: if `f : E → F` is complex differentiable on a set `s`, the norm\nof `f` takes it maximum on `s` at `z`, and `w` is a point such that the closed ball with center `z`\nand radius `dist w z` is included in `s`, then `‖f w‖ = ‖f z‖`. -/\ntheorem norm_eq_norm_of_is_max_on_of_ball_subset {f : E → F} {s : set E} {z w : E} (hd : diff_cont_on_cl (exprℂ) f s)\n    (hz : is_max_on (norm ∘ f) s z) (hsub : ball z (dist w z) ⊆ s) : «expr‖ ‖» (f w) = «expr‖ ‖» (f z) :=\n  norm_eq_on_closed_ball_of_is_max_on (hd.mono hsub) (hz.on_subset hsub) (mem_closed_ball.2 le_rfl)\n#align norm_eq_norm_of_is_max_on_of_ball_subset norm_eq_norm_of_is_max_on_of_ball_subset\n\n",
 "is_open_set_of_mem_nhds_and_is_max_on_norm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem is_open_set_of_mem_nhds_and_is_max_on_norm {f : E → F} {s : set E} (hd : differentiable_on (exprℂ) f s) :\n    is_open { z | s ∈ (nhds) z ∧ is_max_on (norm ∘ f) s z } :=\n  by\n  refine' is_open_iff_mem_nhds.2 fun z hz => (eventually_eventually_nhds.2 hz.1).and _\n  replace hd :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" ((nhds) z)\n      (differentiable_at (exprℂ) f w);\n  exact hd.eventually_differentiable_at hz.1\n  exact (norm_eventually_eq_of_is_local_max hd <| hz.2.is_local_max hz.1).mono fun x hx y hy => le_trans (hz.2 hy) hx.ge\n#align is_open_set_of_mem_nhds_and_is_max_on_norm is_open_set_of_mem_nhds_and_is_max_on_norm\n\n",
 "exists_mem_frontier_is_max_on_norm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/-- **Maximum modulus principle**: if `f : E → F` is complex differentiable on a nonempty bounded\nset `U` and is continuous on its closure, then there exists a point `z ∈ frontier U` such that\n`λ z, ‖f z‖` takes it maximum value on `closure U` at `z`. -/\ntheorem exists_mem_frontier_is_max_on_norm [finite_dimensional (exprℂ) E] {f : E → F} {U : set E} (hb : bounded U)\n    (hne : U.nonempty) (hd : diff_cont_on_cl (exprℂ) f U) : ∃ z ∈ frontier U, is_max_on (norm ∘ f) (closure U) z :=\n  by\n  have hc : is_compact (closure U) := hb.is_compact_closure\n  obtain ⟨w, hwU, hle⟩ : ∃ w ∈ closure U, is_max_on (norm ∘ f) (closure U) w\n  exact hc.exists_forall_ge hne.closure hd.continuous_on.norm\n  rw [closure_eq_interior_union_frontier, mem_union] at hwU\n  cases hwU\n  rotate_left\n  · exact ⟨w, hwU, hle⟩\n  have : interior U ≠ univ := ne_top_of_le_ne_top hc.ne_univ interior_subset_closure\n  rcases exists_mem_frontier_inf_dist_compl_eq_dist hwU this with ⟨z, hzU, hzw⟩\n  refine' ⟨z, frontier_interior_subset hzU, fun x hx => (mem_set_of_eq.mp <| hle hx).trans_eq _⟩\n  refine' (norm_eq_norm_of_is_max_on_of_ball_subset hd (hle.on_subset subset_closure) _).symm\n  rw [dist_comm, ← hzw]\n  exact ball_inf_dist_compl_subset.trans interior_subset\n#align exists_mem_frontier_is_max_on_norm exists_mem_frontier_is_max_on_norm\n\n",
 "eventually_eq_or_eq_zero_of_is_local_min_norm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem eventually_eq_or_eq_zero_of_is_local_min_norm {f : E → exprℂ} {c : E}\n    (hf :\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" ((nhds) c)\n        (differentiable_at (exprℂ) f z))\n    (hc : is_local_min (norm ∘ f) c) :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" ((nhds) c)\n        (f z = f c) ∨\n      f c = 0 :=\n  by\n  refine' or_iff_not_imp_right.mpr fun h => _\n  have h1 :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" ((nhds) c)\n      (f z ≠ 0) :=\n    hf.self_of_nhds.continuous_at.eventually_ne h\n  have h2 : is_local_max (norm ∘ f)⁻¹ c := hc.inv (h1.mono fun z => norm_pos_iff.mpr)\n  have h3 : is_local_max (norm ∘ f⁻¹) c := by refine' h2.congr (eventually_of_forall _) <;> simp\n  have h4 :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" ((nhds) c)\n      (differentiable_at (exprℂ) f⁻¹ z) :=\n    by filter_upwards [hf, h1] with z h using h.inv\n  filter_upwards [eventually_eq_of_is_local_max_norm h4 h3] with z using inv_inj.mp\n#align eventually_eq_or_eq_zero_of_is_local_min_norm eventually_eq_or_eq_zero_of_is_local_min_norm\n\n",
 "eventually_eq_of_is_local_max_norm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- **Maximum modulus principle**: if `f : E → F` is complex differentiable in a neighborhood of `c`\nand the norm `‖f z‖` has a local maximum at `c`, then `f` is locally constant in a neighborhood\nof `c`. -/\ntheorem eventually_eq_of_is_local_max_norm {f : E → F} {c : E}\n    (hd :\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" ((nhds) c)\n        (differentiable_at (exprℂ) f z))\n    (hc : is_local_max (norm ∘ f) c) :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" ((nhds) c)\n      (f y = f c) :=\n  by\n  rcases nhds_basis_closed_ball.eventually_iff.1 (hd.and hc) with ⟨r, hr₀, hr⟩\n  exact\n    nhds_basis_closed_ball.eventually_iff.2\n      ⟨r, hr₀,\n        eq_on_closed_ball_of_is_max_on_norm\n          (differentiable_on.diff_cont_on_cl fun x hx =>\n            (hr <| closure_ball_subset_closed_ball hx).1.differentiable_within_at)\n          fun x hx => (hr <| ball_subset_closed_ball hx).2⟩\n#align eventually_eq_of_is_local_max_norm eventually_eq_of_is_local_max_norm\n\n",
 "eq_on_of_is_preconnected_of_is_max_on_norm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/-- **Maximum modulus principle** on a connected set. Let `U` be a (pre)connected open set in a\ncomplex normed space.  Let `f : E → F` be a function that is complex differentiable on `U`. Suppose\nthat `‖f x‖` takes its maximum value on `U` at `c ∈ U`. Then `f x = f c` for all `x ∈ U`.\n\nTODO: change assumption from `is_max_on` to `is_local_max`. -/\ntheorem eq_on_of_is_preconnected_of_is_max_on_norm {f : E → F} {U : set E} {c : E} (hc : is_preconnected U)\n    (ho : is_open U) (hd : differentiable_on (exprℂ) f U) (hcU : c ∈ U) (hm : is_max_on (norm ∘ f) U c) :\n    EqOn f (const E (f c)) U := fun x hx =>\n  have H₁ : «expr‖ ‖» (f x) = «expr‖ ‖» (f c) := norm_eq_on_of_is_preconnected_of_is_max_on hc ho hd hcU hm hx\n  have H₂ : «expr‖ ‖» (f x + f c) = «expr‖ ‖» (f c + f c) :=\n    norm_eq_on_of_is_preconnected_of_is_max_on hc ho (hd.add_const _) hcU hm.norm_add_self hx\n  eq_of_norm_eq_of_norm_add_eq H₁ <| by simp only [H₂, same_ray.rfl.norm_add, H₁]\n#align eq_on_of_is_preconnected_of_is_max_on_norm eq_on_of_is_preconnected_of_is_max_on_norm\n\n",
 "eq_on_of_eq_on_frontier":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/-- If two complex differentiable functions `f g : E → F` are equal on the boundary of a bounded set\n`U`, then they are equal on `U`. -/\ntheorem eq_on_of_eq_on_frontier {f g : E → F} {U : set E} (hU : bounded U) (hf : diff_cont_on_cl (exprℂ) f U)\n    (hg : diff_cont_on_cl (exprℂ) g U) (hfg : EqOn f g (frontier U)) : EqOn f g U :=\n  (eq_on_closure_of_eq_on_frontier hU hf hg hfg).mono subset_closure\n#align eq_on_of_eq_on_frontier eq_on_of_eq_on_frontier\n\n",
 "eq_on_closure_of_is_preconnected_of_is_max_on_norm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/-- **Maximum modulus principle** on a connected set. Let `U` be a (pre)connected open set in a\ncomplex normed space.  Let `f : E → F` be a function that is complex differentiable on `U` and is\ncontinuous on its closure. Suppose that `‖f x‖` takes its maximum value on `U` at `c ∈ U`. Then\n`f x = f c` for all `x ∈ closure U`. -/\ntheorem eq_on_closure_of_is_preconnected_of_is_max_on_norm {f : E → F} {U : set E} {c : E} (hc : is_preconnected U)\n    (ho : is_open U) (hd : diff_cont_on_cl (exprℂ) f U) (hcU : c ∈ U) (hm : is_max_on (norm ∘ f) U c) :\n    EqOn f (const E (f c)) (closure U) :=\n  (eq_on_of_is_preconnected_of_is_max_on_norm hc ho hd.differentiable_on hcU hm).of_subset_closure hd.continuous_on\n    continuous_on_const subset_closure Subset.rfl\n#align eq_on_closure_of_is_preconnected_of_is_max_on_norm eq_on_closure_of_is_preconnected_of_is_max_on_norm\n\n",
 "eq_on_closure_of_eq_on_frontier":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/-- If two complex differentiable functions `f g : E → F` are equal on the boundary of a bounded set\n`U`, then they are equal on `closure U`. -/\ntheorem eq_on_closure_of_eq_on_frontier {f g : E → F} {U : set E} (hU : bounded U) (hf : diff_cont_on_cl (exprℂ) f U)\n    (hg : diff_cont_on_cl (exprℂ) g U) (hfg : EqOn f g (frontier U)) : EqOn f g (closure U) :=\n  by\n  suffices H : ∀ z ∈ closure U, «expr‖ ‖» ((f - g) z) ≤ 0; · simpa [sub_eq_zero] using H\n  refine' fun z hz => norm_le_of_forall_mem_frontier_norm_le hU (hf.sub hg) (fun w hw => _) hz\n  simp [hfg hw]\n#align eq_on_closure_of_eq_on_frontier eq_on_closure_of_eq_on_frontier\n\n",
 "eq_on_closed_ball_of_is_max_on_norm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/-- **Maximum modulus principle** on a closed ball. Suppose that a function `f : E → F` from a\nnormed complex space to a strictly convex normed complex space has the following properties:\n\n- it is continuous on a closed ball `metric.closed_ball z r`,\n- it is complex differentiable on the corresponding open ball;\n- the norm `‖f w‖` takes its maximum value on the open ball at its center.\n\nThen `f` is a constant on the closed ball.  -/\ntheorem eq_on_closed_ball_of_is_max_on_norm {f : E → F} {z : E} {r : exprℝ} (hd : diff_cont_on_cl (exprℂ) f (ball z r))\n    (hz : is_max_on (norm ∘ f) (ball z r) z) : EqOn f (const E (f z)) (closed_ball z r) := fun x hx =>\n  eq_of_is_max_on_of_ball_subset hd hz <| ball_subset_ball hx\n#align eq_on_closed_ball_of_is_max_on_norm eq_on_closed_ball_of_is_max_on_norm\n\n",
 "eq_of_is_max_on_of_ball_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/-- **Maximum modulus principle**. Let `f : E → F` be a function between complex normed spaces.\nSuppose that the codomain `F` is a strictly convex space, `f` is complex differentiable on a set\n`s`, `f` is continuous on the closure of `s`, the norm of `f` takes it maximum on `s` at `z`, and\n`w` is a point such that the closed ball with center `z` and radius `dist w z` is included in `s`,\nthen `f w = f z`. -/\ntheorem eq_of_is_max_on_of_ball_subset {f : E → F} {s : set E} {z w : E} (hd : diff_cont_on_cl (exprℂ) f s)\n    (hz : is_max_on (norm ∘ f) s z) (hsub : ball z (dist w z) ⊆ s) : f w = f z :=\n  have H₁ : «expr‖ ‖» (f w) = «expr‖ ‖» (f z) := norm_eq_norm_of_is_max_on_of_ball_subset hd hz hsub\n  have H₂ : «expr‖ ‖» (f w + f z) = «expr‖ ‖» (f z + f z) :=\n    norm_eq_norm_of_is_max_on_of_ball_subset (hd.add_const _) hz.norm_add_self hsub\n  eq_of_norm_eq_of_norm_add_eq H₁ <| by simp only [H₂, same_ray.rfl.norm_add, H₁]\n#align eq_of_is_max_on_of_ball_subset eq_of_is_max_on_of_ball_subset\n\n"}