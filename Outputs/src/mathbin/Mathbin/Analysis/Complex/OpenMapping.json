{"is_constant_or_is_open":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Basic.lean:632:2: warning: expanding binder collection (s «expr ⊆ » U) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/-- The *open mapping theorem* for holomorphic functions, global version: if a function `g : E → ℂ`\nis analytic on a connected set `U`, then either it is constant on `U`, or it is open on `U` (in the\nsense that it maps any open set contained in `U` to an open set in `ℂ`). -/\ntheorem analytic_on.is_constant_or_is_open (hg : analytic_on (exprℂ) g U) (hU : is_preconnected U) :\n    (∃ w, ∀ z ∈ U, g z = w) ∨ ∀ (s) (_ : s ⊆ U), is_open s → is_open («expr '' » g s) :=\n  by\n  by_cases\n    ∃ z₀ ∈ U,\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\"\n        ((nhds) z₀) (g z = g z₀)\n  · obtain ⟨z₀, hz₀, h⟩ := h\n    exact or.inl ⟨g z₀, hg.eq_on_of_preconnected_of_eventually_eq analytic_on_const hU hz₀ h⟩\n  · push_neg  at h\n    refine' or.inr fun s hs1 hs2 => is_open_iff_mem_nhds.mpr _\n    rintro z ⟨w, hw1, rfl⟩\n    exact\n      (hg w (hs1 hw1)).eventually_constant_or_nhds_le_map_nhds.resolve_left (h w (hs1 hw1))\n        (image_mem_map (hs2.mem_nhds hw1))\n#align analytic_on.is_constant_or_is_open analytic_on.is_constant_or_is_open\n\n",
 "eventually_constant_or_nhds_le_map_nhds_aux":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- A function `f : ℂ → ℂ` which is analytic at a point `z₀` is either constant in a neighborhood\nof `z₀`, or behaves locally like an open function (in the sense that the image of every neighborhood\nof `z₀` is a neighborhood of `f z₀`, as in `is_open_map_iff_nhds_le`). For a function `f : E → ℂ`\nthe same result holds, see `analytic_at.eventually_constant_or_nhds_le_map_nhds`. -/\ntheorem analytic_at.eventually_constant_or_nhds_le_map_nhds_aux (hf : analytic_at (exprℂ) f z₀) :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" ((nhds) z₀)\n        (f z = f z₀) ∨\n      (nhds) (f z₀) ≤ map f ((nhds) z₀) :=\n  by\n  /- The function `f` is analytic in a neighborhood of `z₀`; by the isolated zeros principle, if `f`\n    is not constant in a neighborhood of `z₀`, then it is nonzero, and therefore bounded below, on\n    every small enough circle around `z₀` and then `diff_cont_on_cl.ball_subset_image_closed_ball`\n    provides an explicit ball centered at `f z₀` contained in the range of `f`. -/\n  refine' or_iff_not_imp_left.mpr fun h => _\n  refine' (nhds_basis_ball.le_basis_iff (nhds_basis_closed_ball.map f)).mpr fun R hR => _\n  have h1 := (hf.eventually_eq_or_eventually_ne analytic_at_const).resolve_left h\n  have h2 :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" ((nhds) z₀)\n      (analytic_at (exprℂ) f z) :=\n    (is_open_analytic_at (exprℂ) f).eventually_mem hf\n  obtain ⟨ρ, hρ, h3, h4⟩ :\n    ∃ ρ > 0, analytic_on (exprℂ) f (closed_ball z₀ ρ) ∧ ∀ z ∈ closed_ball z₀ ρ, z ≠ z₀ → f z ≠ f z₀ := by\n    simpa only [set_of_and, subset_inter_iff] using\n      nhds_basis_closed_ball.mem_iff.mp (h2.and (eventually_nhds_within_iff.mp h1))\n  replace h3 : diff_cont_on_cl (exprℂ) f (ball z₀ ρ)\n  exact ⟨h3.differentiable_on.mono ball_subset_closed_ball, (closure_ball z₀ hρ.lt.ne.symm).symm ▸ h3.continuous_on⟩\n  let r := «expr ⊓ » ρ R\n  have hr : 0 < r := lt_inf_iff.mpr ⟨hρ, hR⟩\n  have h5 : closed_ball z₀ r ⊆ closed_ball z₀ ρ := closed_ball_subset_closed_ball inf_le_left\n  have h6 : diff_cont_on_cl (exprℂ) f (ball z₀ r) := h3.mono (ball_subset_ball inf_le_left)\n  have h7 : ∀ z ∈ sphere z₀ r, f z ≠ f z₀ := fun z hz =>\n    h4 z (h5 (sphere_subset_closed_ball hz)) (ne_of_mem_sphere hz hr.ne.symm)\n  have h8 : (sphere z₀ r).nonempty := normed_space.sphere_nonempty.mpr hr.le\n  have h9 : continuous_on (fun x => «expr‖ ‖» (f x - f z₀)) (sphere z₀ r) :=\n    continuous_norm.comp_continuous_on ((h6.sub_const (f z₀)).continuous_on_ball.mono sphere_subset_closed_ball)\n  obtain ⟨x, hx, hfx⟩ := (is_compact_sphere z₀ r).exists_forall_le h8 h9\n  refine' ⟨«expr‖ ‖» (f x - f z₀) / 2, half_pos (norm_sub_pos_iff.mpr (h7 x hx)), _⟩\n  exact\n    (h6.ball_subset_image_closed_ball hr (fun z hz => hfx z hz) (not_eventually.mp h)).trans\n      (image_subset f (closed_ball_subset_closed_ball inf_le_right))\n#align analytic_at.eventually_constant_or_nhds_le_map_nhds_aux analytic_at.eventually_constant_or_nhds_le_map_nhds_aux\n\n",
 "eventually_constant_or_nhds_le_map_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- The *open mapping theorem* for holomorphic functions, local version: is a function `g : E → ℂ`\nis analytic at a point `z₀`, then either it is constant in a neighborhood of `z₀`, or it maps every\nneighborhood of `z₀` to a neighborhood of `z₀`. For the particular case of a holomorphic function on\n`ℂ`, see `analytic_at.eventually_constant_or_nhds_le_map_nhds_aux`. -/\ntheorem analytic_at.eventually_constant_or_nhds_le_map_nhds {z₀ : E} (hg : analytic_at (exprℂ) g z₀) :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" ((nhds) z₀)\n        (g z = g z₀) ∨\n      (nhds) (g z₀) ≤ map g ((nhds) z₀) :=\n  by\n  /- The idea of the proof is to use the one-dimensional version applied to the restriction of `g`\n    to lines going through `z₀` (indexed by `sphere (0 : E) 1`). If the restriction is eventually\n    constant along each of these lines, then the identity theorem implies that `g` is constant on any\n    ball centered at `z₀` on which it is analytic, and in particular `g` is eventually constant. If on\n    the other hand there is one line along which `g` is not eventually constant, then the\n    one-dimensional version of the open mapping theorem can be used to conclude. -/\n  let ray : E → exprℂ → E := fun z t => z₀ + «expr • » t z\n  let gray : E → exprℂ → exprℂ := fun z => g ∘ ray z\n  obtain ⟨r, hr, hgr⟩ := is_open_iff.mp (is_open_analytic_at (exprℂ) g) z₀ hg\n  have h1 : ∀ z ∈ sphere (0 : E) 1, analytic_on (exprℂ) (gray z) (ball 0 r) :=\n    by\n    refine' fun z hz t ht => analytic_at.comp _ _\n    · exact hgr (by simpa [ray, norm_smul, mem_sphere_zero_iff_norm.mp hz] using ht)\n    ·\n      exact\n        analytic_at_const.add\n          ((continuous_linear_map.smul_right (continuous_linear_map.id (exprℂ) (exprℂ)) z).analytic_at t)\n  by_cases\n    ∀ z ∈ sphere (0 : E) 1,\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" ((nhds) 0)\n        (gray z t = gray z 0)\n  · left\n    -- If g is eventually constant along every direction, then it is eventually constant\n    refine' eventually_of_mem (ball_mem_nhds z₀ hr) fun z hz => _\n    refine' (eq_or_ne z z₀).cases_on (congr_arg g) fun h' => _\n    replace h' : «expr‖ ‖» (z - z₀) ≠ 0 := by simpa only [ne.def, norm_eq_zero, sub_eq_zero]\n    let w : E := «expr • » («expr‖ ‖» (z - z₀))⁻¹ (z - z₀)\n    have h3 : ∀ t ∈ ball (0 : exprℂ) r, gray w t = g z₀ :=\n      by\n      have e1 : is_preconnected (ball (0 : exprℂ) r) := (convex_ball 0 r).is_preconnected\n      have e2 : w ∈ sphere (0 : E) 1 := by simp [w, norm_smul, h']\n      specialize h1 w e2\n      apply h1.eq_on_of_preconnected_of_eventually_eq analytic_on_const e1 (mem_ball_self hr)\n      simpa [gray, ray] using h w e2\n    have h4 : «expr‖ ‖» (z - z₀) < r := by simpa [dist_eq_norm] using mem_ball.mp hz\n    replace h4 : ↑(«expr‖ ‖» (z - z₀)) ∈ ball (0 : exprℂ) r := by\n      simpa only [mem_ball_zero_iff, norm_eq_abs, abs_of_real, abs_norm_eq_norm]\n    simpa only [gray, ray, smul_smul, mul_inv_cancel h', one_smul, add_sub_cancel'_right, Function.comp_apply,\n      coe_smul] using h3 (↑(«expr‖ ‖» (z - z₀))) h4\n  · right\n    -- Otherwise, it is open along at least one direction and that implies the result\n    push_neg  at h\n    obtain ⟨z, hz, hrz⟩ := h\n    specialize h1 z hz 0 (mem_ball_self hr)\n    have h7 := h1.eventually_constant_or_nhds_le_map_nhds_aux.resolve_left hrz\n    rw [show gray z 0 = g z₀ by simp [gray, ray], ← map_compose] at h7\n    refine' h7.trans (map_mono _)\n    have h10 : continuous fun t : exprℂ => z₀ + «expr • » t z :=\n      continuous_const.add (continuous_id'.smul continuous_const)\n    simpa using h10.tendsto 0\n#align analytic_at.eventually_constant_or_nhds_le_map_nhds analytic_at.eventually_constant_or_nhds_le_map_nhds\n\n",
 "ball_subset_image_closed_ball":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.ne -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/-\nCopyright (c) 2022 Vincent Beffara. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Vincent Beffara\n-/\n/-- If the modulus of a holomorphic function `f` is bounded below by `ε` on a circle, then its range\ncontains a disk of radius `ε / 2`. -/\ntheorem diff_cont_on_cl.ball_subset_image_closed_ball (h : diff_cont_on_cl (exprℂ) f (ball z₀ r)) (hr : 0 < r)\n    (hf : ∀ z ∈ sphere z₀ r, ε ≤ «expr‖ ‖» (f z - f z₀))\n    (hz₀ :\n      «expr∃ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , »\"\n        ((nhds) z₀) (f z ≠ f z₀)) :\n    ball (f z₀) (ε / 2) ⊆ «expr '' » f (closed_ball z₀ r) :=\n  by\n  /- This is a direct application of the maximum principle. Pick `v` close to `f z₀`, and look at\n    the function `λ z, ‖f z - v‖`: it is bounded below on the circle, and takes a small value at `z₀`\n    so it is not constant on the disk, which implies that its infimum is equal to `0` and hence that\n    `v` is in the range of `f`. -/\n  rintro v hv\n  have h1 : diff_cont_on_cl (exprℂ) (fun z => f z - v) (ball z₀ r) := h.sub_const v\n  have h2 : continuous_on (fun z => «expr‖ ‖» (f z - v)) (closed_ball z₀ r) :=\n    continuous_norm.comp_continuous_on (closure_ball z₀ hr.ne.symm ▸ h1.continuous_on)\n  have h3 : analytic_on (exprℂ) f (ball z₀ r) := h.differentiable_on.analytic_on is_open_ball\n  have h4 : ∀ z ∈ sphere z₀ r, ε / 2 ≤ «expr‖ ‖» (f z - v) := fun z hz => by\n    linarith [hf z hz, show «expr‖ ‖» (v - f z₀) < ε / 2 from mem_ball.mp hv,\n      norm_sub_sub_norm_sub_le_norm_sub (f z) v (f z₀)]\n  have h5 : «expr‖ ‖» (f z₀ - v) < ε / 2 := by simpa [← dist_eq_norm, dist_comm] using mem_ball.mp hv\n  obtain ⟨z, hz1, hz2⟩ : ∃ z ∈ ball z₀ r, is_local_min (fun z => «expr‖ ‖» (f z - v)) z\n  exact exists_local_min_mem_ball h2 (mem_closed_ball_self hr.le) fun z hz => h5.trans_le (h4 z hz)\n  refine' ⟨z, ball_subset_closed_ball hz1, sub_eq_zero.mp _⟩\n  have h6 := h1.differentiable_on.eventually_differentiable_at (is_open_ball.mem_nhds hz1)\n  refine' (eventually_eq_or_eq_zero_of_is_local_min_norm h6 hz2).resolve_left fun key => _\n  have h7 :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" ((nhds) z)\n      (f w = f z) :=\n    by filter_upwards [key] with h <;> field_simp\n  replace h7 :\n    «expr∃ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , »\"\n      (nhds_within.ne z) (f w = f z) :=\n    (h7.filter_mono nhds_within_le_nhds).frequently\n  have h8 : is_preconnected (ball z₀ r) := (convex_ball z₀ r).is_preconnected\n  have h9 := h3.eq_on_of_preconnected_of_frequently_eq analytic_on_const h8 hz1 h7\n  have h10 : f z = f z₀ := (h9 (mem_ball_self hr)).symm\n  exact not_eventually.mpr hz₀ (mem_of_superset (ball_mem_nhds z₀ hr) (h10 ▸ h9))\n#align diff_cont_on_cl.ball_subset_image_closed_ball diff_cont_on_cl.ball_subset_image_closed_ball\n\n"}