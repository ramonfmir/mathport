{"norm_deriv_le_of_forall_mem_sphere_norm_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ̂» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/-- If `f` is complex differentiable on an open disc of radius `R > 0`, is continuous on its\nclosure, and its values on the boundary circle of this disc are bounded from above by `C`, then the\nnorm of its derivative at the center is at most `C / R`. -/\ntheorem norm_deriv_le_of_forall_mem_sphere_norm_le {c : exprℂ} {R C : exprℝ} {f : exprℂ → F} (hR : 0 < R)\n    (hd : diff_cont_on_cl (exprℂ) f (ball c R)) (hC : ∀ z ∈ sphere c R, «expr‖ ‖» (f z) ≤ C) :\n    «expr‖ ‖» (deriv f c) ≤ C / R :=\n  by\n  set e : «expr →L[ ] » F (exprℂ) («expr ̂» F) := uniform_space.completion.to_complL\n  have : has_deriv_at (e ∘ f) (e (deriv f c)) c :=\n    e.has_fderiv_at.comp_has_deriv_at c (hd.differentiable_at is_open_ball <| mem_ball_self hR).has_deriv_at\n  calc\n    «expr‖ ‖» (deriv f c) = «expr‖ ‖» (deriv (e ∘ f) c) :=\n      by\n      rw [this.deriv]\n      exact (uniform_space.completion.norm_coe _).symm\n    _ ≤ C / R :=\n      norm_deriv_le_aux hR (e.differentiable.comp_diff_cont_on_cl hd) fun z hz =>\n        (uniform_space.completion.norm_coe _).trans_le (hC z hz)\n    \n#align norm_deriv_le_of_forall_mem_sphere_norm_le norm_deriv_le_of_forall_mem_sphere_norm_le\n\n",
 "norm_deriv_le_aux":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `real.pi -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∮ inC( , ), » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∮ inC( , ), » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem norm_deriv_le_aux [complete_space F] {c : exprℂ} {R C : exprℝ} {f : exprℂ → F} (hR : 0 < R)\n    (hf : diff_cont_on_cl (exprℂ) f (ball c R)) (hC : ∀ z ∈ sphere c R, «expr‖ ‖» (f z) ≤ C) :\n    «expr‖ ‖» (deriv f c) ≤ C / R :=\n  by\n  have : ∀ z ∈ sphere c R, «expr‖ ‖» («expr • » ((z - c) ^ (-2 : ℤ)) (f z)) ≤ C / (R * R) :=\n    fun z (hz : abs (z - c) = R) => by\n    simpa [-mul_inv_rev, norm_smul, hz, zpow_two, ← div_eq_inv_mul] using (div_le_div_right (mul_pos hR hR)).2 (hC z hz)\n  calc\n    «expr‖ ‖» (deriv f c) =\n        «expr‖ ‖»\n          («expr • » (2 * real.pi * I : exprℂ)⁻¹\n            («expr∮ inC( , ), »\n              \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∮ inC( , ), »\" c R\n              («expr • » ((z - c) ^ (-2 : ℤ)) (f z)))) :=\n      congr_arg norm (deriv_eq_smul_circle_integral hR hf)\n    _ ≤ R * (C / (R * R)) := circle_integral.norm_two_pi_I_inv_smul_integral_le_of_norm_le_const hR.le this\n    _ = C / R := by rw [mul_div_left_comm, div_self_mul_self', div_eq_mul_inv]\n    \n#align norm_deriv_le_aux norm_deriv_le_aux\n\n",
 "liouville_theorem_aux":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/-- An auxiliary lemma for Liouville's theorem `differentiable.apply_eq_apply_of_bounded`. -/\ntheorem liouville_theorem_aux {f : exprℂ → F} (hf : differentiable (exprℂ) f) (hb : bounded (range f)) (z w : exprℂ) :\n    f z = f w := by\n  suffices : ∀ c, deriv f c = 0\n  exact is_const_of_deriv_eq_zero hf this z w\n  clear z w\n  intro c\n  obtain ⟨C, C₀, hC⟩ : ∃ C > (0 : exprℝ), ∀ z, «expr‖ ‖» (f z) ≤ C :=\n    by\n    rcases bounded_iff_forall_norm_le.1 hb with ⟨C, hC⟩\n    exact ⟨max C 1, lt_max_iff.2 (or.inr zero_lt_one), fun z => (hC (f z) (mem_range_self _)).trans (le_max_left _ _)⟩\n  refine' norm_le_zero_iff.1 (le_of_forall_le_of_dense fun ε ε₀ => _)\n  calc\n    «expr‖ ‖» (deriv f c) ≤ C / (C / ε) :=\n      norm_deriv_le_of_forall_mem_sphere_norm_le (div_pos C₀ ε₀) hf.diff_cont_on_cl fun z _ => hC z\n    _ = ε := div_div_cancel' C₀.lt.ne'\n    \n#align liouville_theorem_aux liouville_theorem_aux\n\n",
 "exists_eq_const_of_bounded":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/-- **Liouville's theorem**: a complex differentiable bounded function is a constant. -/\ntheorem exists_eq_const_of_bounded {f : E → F} (hf : differentiable (exprℂ) f) (hb : bounded (range f)) :\n    ∃ c, f = const E c :=\n  (hf.exists_const_forall_eq_of_bounded hb).imp fun c => funext\n#align exists_eq_const_of_bounded exists_eq_const_of_bounded\n\n",
 "exists_const_forall_eq_of_bounded":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/-- **Liouville's theorem**: a complex differentiable bounded function is a constant. -/\ntheorem exists_const_forall_eq_of_bounded {f : E → F} (hf : differentiable (exprℂ) f) (hb : bounded (range f)) :\n    ∃ c, ∀ z, f z = c :=\n  ⟨f 0, fun z => hf.apply_eq_apply_of_bounded hb _ _⟩\n#align exists_const_forall_eq_of_bounded exists_const_forall_eq_of_bounded\n\n",
 "deriv_eq_smul_circle_integral":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `real.pi -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∮ inC( , ), » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∮ inC( , ), » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-\nCopyright (c) 2022 Yury G. Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury G. Kudryashov\n-/\n/-- If `f` is complex differentiable on an open disc with center `c` and radius `R > 0` and is\ncontinuous on its closure, then `f' c` can be represented as an integral over the corresponding\ncircle.\n\nTODO: add a version for `w ∈ metric.ball c R`.\n\nTODO: add a version for higher derivatives. -/\ntheorem deriv_eq_smul_circle_integral [complete_space F] {R : exprℝ} {c : exprℂ} {f : exprℂ → F} (hR : 0 < R)\n    (hf : diff_cont_on_cl (exprℂ) f (ball c R)) :\n    deriv f c =\n      «expr • » (2 * real.pi * I : exprℂ)⁻¹\n        («expr∮ inC( , ), » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∮ inC( , ), »\"\n          c R («expr • » ((z - c) ^ (-2 : ℤ)) (f z))) :=\n  by\n  lift R to nnreal using hR.le\n  refine' (hf.has_fpower_series_on_ball hR).has_fpower_series_at.deriv.trans _\n  simp only [cauchy_power_series_apply, one_div, zpow_neg, pow_one, smul_smul, zpow_two, mul_inv]\n#align deriv_eq_smul_circle_integral deriv_eq_smul_circle_integral\n\n",
 "apply_eq_apply_of_bounded":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/-- **Liouville's theorem**: a complex differentiable bounded function `f : E → F` is a constant. -/\ntheorem apply_eq_apply_of_bounded {f : E → F} (hf : differentiable (exprℂ) f) (hb : bounded (range f)) (z w : E) :\n    f z = f w := by\n  set g : exprℂ → F := f ∘ fun t : exprℂ => «expr • » t (w - z) + z\n  suffices g 0 = g 1 by simpa [g]\n  apply liouville_theorem_aux\n  exacts[hf.comp ((differentiable_id.smul_const (w - z)).add_const z), hb.mono (range_comp_subset_range _ _)]\n#align apply_eq_apply_of_bounded apply_eq_apply_of_bounded\n\n"}