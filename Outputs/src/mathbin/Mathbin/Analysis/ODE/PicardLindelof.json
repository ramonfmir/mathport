{"v_comp_apply_coe":
 "theorem v_comp_apply_coe (t : Icc v.t_min v.t_max) : f.v_comp t = v t (f t) := by simp only [v_comp, proj_coe]\n#align v_comp_apply_coe v_comp_apply_coe\n\n",
 "uniform_inducing_to_continuous_map":
 "theorem uniform_inducing_to_continuous_map : UniformInducing (@to_continuous_map _ _ _ v) :=\n  ⟨rfl⟩\n#align uniform_inducing_to_continuous_map uniform_inducing_to_continuous_map\n\n",
 "t_min_le_t_max":
 "/-\nCopyright (c) 2021 Yury G. Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury G. Kudryashov, Winston Yin\n-/\ntheorem t_min_le_t_max : v.t_min ≤ v.t_max :=\n  v.t₀.2.1.trans v.t₀.2.2\n#align t_min_le_t_max t_min_le_t_max\n\n",
 "t_dist_nonneg":
 "theorem t_dist_nonneg : 0 ≤ v.t_dist :=\n  le_max_iff.2 <| or.inl <| sub_nonneg.2 v.t₀.2.2\n#align t_dist_nonneg t_dist_nonneg\n\n",
 "range_to_continuous_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\ntheorem range_to_continuous_map :\n    range to_continuous_map = { f : «exprC( , )» (Icc v.t_min v.t_max) E | f v.t₀ = v.x₀ ∧ LipschitzWith v.C f } :=\n  by\n  ext f; constructor\n  · rintro ⟨⟨f, hf₀, hf_lip⟩, rfl⟩\n    exact ⟨hf₀, hf_lip⟩\n  · rcases f with ⟨f, hf⟩\n    rintro ⟨hf₀, hf_lip⟩\n    exact ⟨⟨f, hf₀, hf_lip⟩, rfl⟩\n#align range_to_continuous_map range_to_continuous_map\n\n",
 "proj_of_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem proj_of_mem {t : exprℝ} (ht : t ∈ Icc v.t_min v.t_max) : ↑(v.proj t) = t := by\n  simp only [proj, proj_Icc_of_mem _ ht, Subtype.coe_mk]\n#align proj_of_mem proj_of_mem\n\n",
 "proj_coe":
 "theorem proj_coe (t : Icc v.t_min v.t_max) : v.proj t = t :=\n  projIcc_val _ _\n#align proj_coe proj_coe\n\n",
 "norm_v_comp_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem norm_v_comp_le (t : exprℝ) : «expr‖ ‖» (f.v_comp t) ≤ v.C :=\n  v.norm_le (v.proj t).2 <| f.mem_closed_ball _\n#align norm_v_comp_le norm_v_comp_le\n\n",
 "norm_le₀":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem is_picard_lindelof.norm_le₀ {E : Type _} [NormedAddCommGroup E] {v : exprℝ → E → E} {t_min t₀ t_max : exprℝ}\n    {x₀ : E} {C R : exprℝ} {L : nnreal} (hpl : is_picard_lindelof v t_min t₀ t_max x₀ L R C) :\n    «expr‖ ‖» (v t₀ x₀) ≤ C :=\n  hpl.norm_le t₀ hpl.ht₀ x₀ <| mem_closedBall_self hpl.hR\n#align is_picard_lindelof.norm_le₀ is_picard_lindelof.norm_le₀\n\n",
 "norm_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem norm_le {t : exprℝ} (ht : t ∈ Icc v.t_min v.t_max) {x : E} (hx : x ∈ closedBall v.x₀ v.R) :\n    «expr‖ ‖» (v t x) ≤ v.C :=\n  v.is_pl.norm_le _ ht _ hx\n#align norm_le norm_le\n\n",
 "nonempty_Icc":
 "protected theorem nonempty_Icc : (Icc v.t_min v.t_max).nonempty :=\n  nonempty_Icc.2 v.t_min_le_t_max\n#align nonempty_Icc nonempty_Icc\n\n",
 "next_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ in .. , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ in .. , » -/\ntheorem next_apply (t : Icc v.t_min v.t_max) :\n    f.next t =\n      v.x₀ +\n        «expr∫ in .. , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ in .. , »\" v.t₀\n          t (f.v_comp τ) :=\n  rfl\n#align next_apply next_apply\n\n",
 "mem_closed_ball":
 "protected theorem mem_closed_ball (t : Icc v.t_min v.t_max) : f t ∈ closedBall v.x₀ v.R :=\n  calc\n    dist (f t) v.x₀ = dist (f t) (f.to_fun v.t₀) := by rw [f.map_t₀']\n    _ ≤ v.C * dist t v.t₀ := (f.lipschitz.dist_le_mul _ _)\n    _ ≤ v.C * v.t_dist := (mul_le_mul_of_nonneg_left (v.dist_t₀_le _) v.C.2)\n    _ ≤ v.R := v.is_pl.C_mul_le_R\n    \n#align mem_closed_ball mem_closed_ball\n\n",
 "map_t₀":
 "theorem map_t₀ : f v.t₀ = v.x₀ :=\n  f.map_t₀'\n#align map_t₀ map_t₀\n\n",
 "lipschitz":
 "protected theorem lipschitz : LipschitzWith v.C f :=\n  f.lipschitz'\n#align lipschitz lipschitz\n\n",
 "interval_integrable_v_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem interval_integrable_v_comp (t₁ t₂ : exprℝ) : interval_integrable f.v_comp volume t₁ t₂ :=\n  f.continuous_v_comp.interval_integrable _ _\n#align interval_integrable_v_comp interval_integrable_v_comp\n\n",
 "has_deriv_within_at_next":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ in .. , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ in .. , » -/\ntheorem has_deriv_within_at_next (t : Icc v.t_min v.t_max) :\n    has_deriv_within_at (f.next ∘ v.proj) (v t (f t)) (Icc v.t_min v.t_max) t :=\n  by\n  haveI : Fact ((t : exprℝ) ∈ Icc v.t_min v.t_max) := ⟨t.2⟩\n  simp only [(· ∘ ·), next_apply]\n  refine' has_deriv_within_at.const_add _ _\n  have :\n    has_deriv_within_at\n      (fun t : exprℝ =>\n        «expr∫ in .. , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ in .. , »\" v.t₀\n          t (f.v_comp τ))\n      (f.v_comp t) (Icc v.t_min v.t_max) t :=\n    integral_has_deriv_within_at_right (f.interval_integrable_v_comp _ _)\n      (f.continuous_v_comp.strongly_measurable_at_filter _ _) f.continuous_v_comp.continuous_within_at\n  rw [v_comp_apply_coe] at this\n  refine' this.congr_of_eventually_eq_of_mem _ t.coe_prop\n  filter_upwards [self_mem_nhdsWithin]with _ ht'\n  rw [v.proj_of_mem ht']\n#align has_deriv_within_at_next has_deriv_within_at_next\n\n",
 "exists_solution":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- Picard-Lindelöf (Cauchy-Lipschitz) theorem. Use\n`exists_forall_deriv_within_Icc_eq_of_is_picard_lindelof` instead for the public API. -/\ntheorem exists_solution :\n    ∃ f : exprℝ → E,\n      f v.t₀ = v.x₀ ∧ ∀ t ∈ Icc v.t_min v.t_max, has_deriv_within_at f (v t (f t)) (Icc v.t_min v.t_max) t :=\n  by\n  rcases v.exists_fixed with ⟨f, hf⟩\n  refine' ⟨f ∘ v.proj, _, fun t ht => _⟩\n  · simp only [(· ∘ ·), proj_coe, f.map_t₀]\n  · simp only [(· ∘ ·), v.proj_of_mem ht]\n    lift t to Icc v.t_min v.t_max using ht\n    simpa only [hf, v.proj_coe] using f.has_deriv_within_at_next t\n#align exists_solution exists_solution\n\n",
 "exists_is_picard_lindelof_const_of_cont_diff_on_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- A time-independent, locally continuously differentiable ODE satisfies the hypotheses of the\n  Picard-Lindelöf theorem. -/\ntheorem exists_is_picard_lindelof_const_of_cont_diff_on_nhds {s : Set E} (hv : cont_diff_on (exprℝ) 1 v s)\n    (hs : s ∈ (nhds) x₀) : ∃ ε > (0 : exprℝ), ∃ L R C, is_picard_lindelof (fun t => v) (t₀ - ε) t₀ (t₀ + ε) x₀ L R C :=\n  by\n  -- extract Lipschitz constant\n  obtain ⟨L, s', hs', hlip⟩ :=\n    cont_diff_at.exists_lipschitz_on_with ((hv.cont_diff_within_at (mem_of_mem_nhds hs)).cont_diff_at hs)\n  -- radius of closed ball in which v is bounded\n  obtain ⟨r, hr : 0 < r, hball⟩ := metric.mem_nhds_iff.mp (inter_sets ((nhds) x₀) hs hs')\n  have hr' := (half_pos hr).le\n  obtain ⟨C, hC⟩ :=\n    (is_compact_closed_ball x₀ (r / 2)).bdd_above_image\n      (-- uses proper_space E\n        hv.continuous_on.norm.mono\n        (subset_inter_iff.mp ((closed_ball_subset_ball (half_lt_self hr)).trans hball)).left)\n  have hC' : 0 ≤ C := by\n    apply (norm_nonneg (v x₀)).trans\n    apply hC\n    exact ⟨x₀, ⟨mem_closed_ball_self hr', rfl⟩⟩\n  set ε := if C = 0 then 1 else r / 2 / C with hε\n  have hε0 : 0 < ε := by\n    rw [hε]\n    split_ifs\n    · exact zero_lt_one\n    · exact div_pos (half_pos hr) (lt_of_le_of_ne hC' (ne.symm h))\n  refine' ⟨ε, hε0, L, r / 2, C, _⟩\n  exact\n    { ht₀ := by\n        rw [← Real.closedBall_eq_Icc]\n        exact mem_closed_ball_self hε0.le\n      hR := (half_pos hr).le\n      lipschitz := fun t ht =>\n        hlip.mono (subset_inter_iff.mp (subset_trans (closed_ball_subset_ball (half_lt_self hr)) hball)).2\n      cont := fun x hx => continuousOn_const\n      norm_le := fun t ht x hx => hC ⟨x, hx, rfl⟩\n      C_mul_le_R := by\n        rw [add_sub_cancel', sub_sub_cancel, max_self, mul_ite, mul_one]\n        split_ifs\n        · rwa [← h] at hr'\n        · exact (mul_div_cancel' (r / 2) h).le }\n#align exists_is_picard_lindelof_const_of_cont_diff_on_nhds exists_is_picard_lindelof_const_of_cont_diff_on_nhds\n\n",
 "exists_forall_deriv_within_Icc_eq_of_is_picard_lindelof":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- Picard-Lindelöf (Cauchy-Lipschitz) theorem. -/\ntheorem exists_forall_deriv_within_Icc_eq_of_is_picard_lindelof [CompleteSpace E] {v : exprℝ → E → E}\n    {t_min t₀ t_max : exprℝ} (x₀ : E) {C R : exprℝ} {L : nnreal} (hpl : is_picard_lindelof v t_min t₀ t_max x₀ L R C) :\n    ∃ f : exprℝ → E, f t₀ = x₀ ∧ ∀ t ∈ Icc t_min t_max, has_deriv_within_at f (v t (f t)) (Icc t_min t_max) t :=\n  by\n  lift C to nnreal using (norm_nonneg _).trans hpl.norm_le₀\n  lift t₀ to Icc t_min t_max using hpl.ht₀\n  exact picard_lindelof.exists_solution ⟨v, t_min, t_max, t₀, x₀, C, ⟨R, hpl.hR⟩, L, { hpl with ht₀ := t₀.property }⟩\n#align exists_forall_deriv_within_Icc_eq_of_is_picard_lindelof exists_forall_deriv_within_Icc_eq_of_is_picard_lindelof\n\n",
 "exists_forall_deriv_at_Ioo_eq_of_cont_diff_on_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- A time-independent, locally continuously differentiable ODE admits a solution in some open\ninterval. -/\ntheorem exists_forall_deriv_at_Ioo_eq_of_cont_diff_on_nhds {s : Set E} (hv : cont_diff_on (exprℝ) 1 v s)\n    (hs : s ∈ (nhds) x₀) :\n    ∃ ε > (0 : exprℝ), ∃ f : exprℝ → E, f t₀ = x₀ ∧ ∀ t ∈ Ioo (t₀ - ε) (t₀ + ε), f t ∈ s ∧ has_deriv_at f (v (f t)) t :=\n  by\n  obtain ⟨ε, hε, L, R, C, hpl⟩ := exists_is_picard_lindelof_const_of_cont_diff_on_nhds t₀ x₀ hv hs\n  obtain ⟨f, hf1, hf2⟩ := exists_forall_deriv_within_Icc_eq_of_is_picard_lindelof x₀ hpl\n  have hf2' : ∀ t ∈ Ioo (t₀ - ε) (t₀ + ε), has_deriv_at f (v (f t)) t := fun t ht =>\n    (hf2 t (Ioo_subset_Icc_self ht)).has_deriv_at (Icc_mem_nhds ht.1 ht.2)\n  have h : «expr ⁻¹' » f s ∈ (nhds) t₀ :=\n    by\n    have := hf2' t₀ (mem_Ioo.mpr ⟨sub_lt_self _ hε, lt_add_of_pos_right _ hε⟩)\n    apply ContinuousAt.preimage_mem_nhds this.continuous_at\n    rw [hf1]\n    exact hs\n  rw [Metric.mem_nhds_iff] at h\n  obtain ⟨r, hr1, hr2⟩ := h\n  refine'\n    ⟨min r ε, lt_min hr1 hε, f, hf1, fun t ht =>\n      ⟨_,\n        hf2' t\n          (mem_of_mem_of_subset ht\n            (Ioo_subset_Ioo (sub_le_sub_left (min_le_right _ _) _) (add_le_add_left (min_le_right _ _) _)))⟩⟩\n  rw [← Set.mem_preimage]\n  apply Set.mem_of_mem_of_subset _ hr2\n  apply Set.mem_of_mem_of_subset ht\n  rw [← Real.ball_eq_Ioo]\n  exact Metric.ball_subset_ball (min_le_left _ _)\n#align exists_forall_deriv_at_Ioo_eq_of_cont_diff_on_nhds exists_forall_deriv_at_Ioo_eq_of_cont_diff_on_nhds\n\n",
 "exists_forall_deriv_at_Ioo_eq_of_cont_diff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- A time-independent, continuously differentiable ODE admits a solution in some open interval. -/\ntheorem exists_forall_deriv_at_Ioo_eq_of_cont_diff (hv : cont_diff (exprℝ) 1 v) :\n    ∃ ε > (0 : exprℝ), ∃ f : exprℝ → E, f t₀ = x₀ ∧ ∀ t ∈ Ioo (t₀ - ε) (t₀ + ε), has_deriv_at f (v (f t)) t :=\n  let ⟨ε, hε, f, hf1, hf2⟩ :=\n    exists_forall_deriv_at_Ioo_eq_of_cont_diff_on_nhds t₀ x₀ hv.cont_diff_on (IsOpen.mem_nhds isOpen_univ (mem_univ _))\n  ⟨ε, hε, f, hf1, fun t ht => (hf2 t ht).2⟩\n#align exists_forall_deriv_at_Ioo_eq_of_cont_diff exists_forall_deriv_at_Ioo_eq_of_cont_diff\n\n",
 "exists_fixed":
 "theorem exists_fixed : ∃ f : v.fun_space, f.next = f :=\n  let ⟨N, K, hK⟩ := exists_contracting_iterate v\n  ⟨_, hK.is_fixed_pt_fixed_point_iterate⟩\n#align exists_fixed exists_fixed\n\n",
 "exists_contracting_iterate":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\ntheorem exists_contracting_iterate :\n    ∃ (N : ℕ)(K : _), ContractingWith K («expr ^[ ]» (fun_space.next : v.fun_space → v.fun_space) N) :=\n  by\n  rcases((Real.tendsto_pow_div_factorial_atTop (v.L * v.t_dist)).eventually (gt_mem_nhds zero_lt_one)).exists with\n    ⟨N, hN⟩\n  have : (0 : exprℝ) ≤ (v.L * v.t_dist) ^ N / nat.factorial N :=\n    div_nonneg (pow_nonneg (mul_nonneg v.L.2 v.t_dist_nonneg) _) (Nat.cast_nonneg _)\n  exact ⟨N, ⟨_, this⟩, hN, LipschitzWith.of_dist_le_mul fun f g => fun_space.dist_iterate_next_le f g N⟩\n#align exists_contracting_iterate exists_contracting_iterate\n\n",
 "dist_t₀_le":
 "theorem dist_t₀_le (t : Icc v.t_min v.t_max) : dist t v.t₀ ≤ v.t_dist :=\n  by\n  rw [Subtype.dist_eq, Real.dist_eq]\n  cases' le_total t v.t₀ with ht ht\n  · rw [abs_of_nonpos (sub_nonpos.2 <| Subtype.coe_le_coe.2 ht), neg_sub]\n    exact (sub_le_sub_left t.2.1 _).trans (le_max_right _ _)\n  · rw [abs_of_nonneg (sub_nonneg.2 <| Subtype.coe_le_coe.2 ht)]\n    exact (sub_le_sub_right t.2.2 _).trans (le_max_left _ _)\n#align dist_t₀_le dist_t₀_le\n\n",
 "dist_next_apply_le_of_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprΙ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprΙ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\ntheorem dist_next_apply_le_of_le {f₁ f₂ : fun_space v} {n : ℕ} {d : exprℝ}\n    (h : ∀ t, dist (f₁ t) (f₂ t) ≤ (v.L * |t - v.t₀|) ^ n / nat.factorial n * d) (t : Icc v.t_min v.t_max) :\n    dist (next f₁ t) (next f₂ t) ≤ (v.L * |t - v.t₀|) ^ (n + 1) / nat.factorial (n + 1) * d :=\n  by\n  simp only [dist_eq_norm, next_apply, add_sub_add_left_eq_sub, ←\n    interval_integral.integral_sub (interval_integrable_v_comp _ _ _) (interval_integrable_v_comp _ _ _),\n    norm_integral_eq_norm_integral_Ioc] at *\n  calc\n    «expr‖ ‖»\n          («expr∫ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ in , »\"\n            ((exprΙ) (v.t₀ : exprℝ) t) (f₁.v_comp τ - f₂.v_comp τ)) ≤\n        «expr∫ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ in , »\"\n          ((exprΙ) (v.t₀ : exprℝ) t) (v.L * ((v.L * |τ - v.t₀|) ^ n / nat.factorial n * d)) :=\n      by\n      refine' norm_integral_le_of_norm_le (continuous.integrable_on_uIoc _) _\n      · continuity\n      · refine' (ae_restrict_mem measurable_set_Ioc).mono fun τ hτ => _\n        refine'\n          (v.lipschitz_on_with (v.proj τ).2).norm_sub_le_of_le (f₁.mem_closed_ball _) (f₂.mem_closed_ball _)\n            ((h _).trans_eq _)\n        rw [v.proj_of_mem]\n        exact uIcc_subset_Icc v.t₀.2 t.2 <| Ioc_subset_Icc_self hτ\n    _ = (v.L * |t - v.t₀|) ^ (n + 1) / nat.factorial (n + 1) * d := _\n    \n  simp_rw [mul_pow, div_eq_mul_inv, mul_assoc, measure_theory.integral_mul_left, measure_theory.integral_mul_right,\n    integral_pow_abs_sub_uIoc, div_eq_mul_inv, pow_succ (v.L : exprℝ), Nat.factorial_succ, Nat.cast_mul, Nat.cast_succ,\n    mul_inv, mul_assoc]\n#align dist_next_apply_le_of_le dist_next_apply_le_of_le\n\n",
 "dist_le_of_forall":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem dist_le_of_forall {f₁ f₂ : fun_space v} {d : exprℝ} (h : ∀ t, dist (f₁ t) (f₂ t) ≤ d) : dist f₁ f₂ ≤ d :=\n  (@continuous_map.dist_le_iff_of_nonempty _ _ _ _ _ f₁.to_continuous_map f₂.to_continuous_map _\n        v.nonempty_Icc.to_subtype).2\n    h\n#align dist_le_of_forall dist_le_of_forall\n\n",
 "dist_iterate_next_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\ntheorem dist_iterate_next_le (f₁ f₂ : fun_space v) (n : ℕ) :\n    dist ((«expr ^[ ]» next n) f₁) ((«expr ^[ ]» next n) f₂) ≤ (v.L * v.t_dist) ^ n / nat.factorial n * dist f₁ f₂ :=\n  by\n  refine' dist_le_of_forall fun t => (dist_iterate_next_apply_le _ _ _ _).trans _\n  have : 0 ≤ dist f₁ f₂ := dist_nonneg\n  have : |(t - v.t₀ : exprℝ)| ≤ v.t_dist := v.dist_t₀_le t\n  mono* <;> simp only [Nat.cast_nonneg, mul_nonneg, NNReal.coe_nonneg, abs_nonneg, *]\n#align dist_iterate_next_le dist_iterate_next_le\n\n",
 "dist_iterate_next_apply_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\ntheorem dist_iterate_next_apply_le (f₁ f₂ : fun_space v) (n : ℕ) (t : Icc v.t_min v.t_max) :\n    dist ((«expr ^[ ]» next n) f₁ t) ((«expr ^[ ]» next n) f₂ t) ≤\n      (v.L * |t - v.t₀|) ^ n / nat.factorial n * dist f₁ f₂ :=\n  by\n  induction' n with n ihn generalizing t\n  · rw [pow_zero, Nat.factorial_zero, Nat.cast_one, div_one, one_mul]\n    exact dist_apply_le_dist f₁ f₂ t\n  · rw [iterate_succ_apply', iterate_succ_apply']\n    exact dist_next_apply_le_of_le ihn _\n#align dist_iterate_next_apply_le dist_iterate_next_apply_le\n\n",
 "dist_apply_le_dist":
 "theorem dist_apply_le_dist (f₁ f₂ : fun_space v) (t : Icc v.t_min v.t_max) : dist (f₁ t) (f₂ t) ≤ dist f₁ f₂ :=\n  @continuous_map.dist_apply_le_dist _ _ _ _ _ f₁.to_continuous_map f₂.to_continuous_map _\n#align dist_apply_le_dist dist_apply_le_dist\n\n",
 "continuous_v_comp":
 "theorem continuous_v_comp : Continuous f.v_comp :=\n  by\n  have := (continuous_subtype_coe.prod_mk f.continuous).comp v.continuous_proj\n  refine' ContinuousOn.comp_continuous v.continuous_on this fun x => _\n  exact ⟨(v.proj x).2, f.mem_closed_ball _⟩\n#align continuous_v_comp continuous_v_comp\n\n",
 "continuous_proj":
 "@[continuity]\ntheorem continuous_proj : Continuous v.proj :=\n  continuous_projIcc\n#align continuous_proj continuous_proj\n\n",
 "LipschitzOnWith":
 "#print LipschitzOnWith /-\nprotected theorem LipschitzOnWith {t} (ht : t ∈ Icc v.t_min v.t_max) :\n    LipschitzOnWith v.L (v t) (closedBall v.x₀ v.R) :=\n  v.is_pl.lipschitz t ht\n#align lipschitz_on_with LipschitzOnWith\n-/\n\n",
 "ContinuousOn":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n#print ContinuousOn /-\nprotected theorem ContinuousOn :\n    ContinuousOn (uncurry v) (lower_set.prod (Icc v.t_min v.t_max) (closedBall v.x₀ v.R)) :=\n  have : ContinuousOn (uncurry (flip v)) (lower_set.prod (closedBall v.x₀ v.R) (Icc v.t_min v.t_max)) :=\n    continuousOn_prod_of_continuousOn_lipschitz_on _ v.L v.is_pl.cont v.is_pl.lipschitz\n  this.comp continuous_swap.continuous_on (preimage_swap_prod _ _).symm.subset\n#align continuous_on ContinuousOn\n-/\n\n",
 "Continuous":
 "#print Continuous /-\nprotected theorem Continuous : Continuous f :=\n  f.lipschitz.continuous\n#align continuous Continuous\n-/\n\n"}