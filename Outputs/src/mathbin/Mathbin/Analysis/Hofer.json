{"pos_div_pow_pos":
 "#print pos_div_pow_pos /-\n/-\nCopyright (c) 2020 Patrick Massot. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Patrick Massot\n-/\n@[simp]\ntheorem pos_div_pow_pos {α : Type _} [LinearOrderedSemifield α] {a b : α} (ha : 0 < a) (hb : 0 < b) (k : ℕ) :\n    0 < a / b ^ k :=\n  div_pos ha (pow_pos hb k)\n#align pos_div_pow_pos pos_div_pow_pos\n-/\n\n",
 "hofer":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprd -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprd -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprd -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprd -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprd -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprd -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprd -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprd -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprd -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprd -/\n#print hofer /-\ntheorem hofer {X : Type _} [MetricSpace X] [CompleteSpace X] (x : X) (ε : exprℝ) (ε_pos : 0 < ε) {ϕ : X → exprℝ}\n    (cont : Continuous ϕ) (nonneg : ∀ y, 0 ≤ ϕ y) :\n    ∃ ε' > 0, ∃ x' : X, ε' ≤ ε ∧ (exprd) x' x ≤ 2 * ε ∧ ε * ϕ x ≤ ε' * ϕ x' ∧ ∀ y, (exprd) x' y ≤ ε' → ϕ y ≤ 2 * ϕ x' :=\n  by\n  by_contra H\n  have reformulation : ∀ (x') (k : ℕ), ε * ϕ x ≤ ε / 2 ^ k * ϕ x' ↔ 2 ^ k * ϕ x ≤ ϕ x' :=\n    by\n    intro x' k\n    rw [div_mul_eq_mul_div, le_div_iff, mul_assoc, mul_le_mul_left ε_pos, mul_comm]\n    positivity\n  -- Now let's specialize to `ε/2^k`\n  replace H : ∀ k : ℕ, ∀ x', (exprd) x' x ≤ 2 * ε ∧ 2 ^ k * ϕ x ≤ ϕ x' → ∃ y, (exprd) x' y ≤ ε / 2 ^ k ∧ 2 * ϕ x' < ϕ y\n  · intro k x'\n    push_neg  at H\n    simpa [reformulation] using H (ε / 2 ^ k) (by simp [ε_pos]) x' (by simp [ε_pos.le, one_le_two])\n  clear reformulation\n  haveI : Nonempty X := ⟨x⟩\n  choose! F hF using H\n  -- Use the axiom of choice\n  -- Now define u by induction starting at x, with u_{n+1} = F(n, u_n)\n  let u : ℕ → X := fun n => nat.rec_on n x F\n  have hu0 : u 0 = x := rfl\n  -- The properties of F translate to properties of u\n  have hu :\n    ∀ n,\n      (exprd) (u n) x ≤ 2 * ε ∧ 2 ^ n * ϕ x ≤ ϕ (u n) →\n        (exprd) (u n) (u <| n + 1) ≤ ε / 2 ^ n ∧ 2 * ϕ (u n) < ϕ (u <| n + 1) :=\n    by\n    intro n\n    exact hF n (u n)\n  clear hF\n  -- Key properties of u, to be proven by induction\n  have key : ∀ n, (exprd) (u n) (u (n + 1)) ≤ ε / 2 ^ n ∧ 2 * ϕ (u n) < ϕ (u (n + 1)) :=\n    by\n    intro n\n    induction' n using nat.case_strong_induction_on with n IH\n    · specialize hu 0\n      simpa [hu0, mul_nonneg_iff, zero_le_one, ε_pos.le, le_refl] using hu\n    have A : (exprd) (u (n + 1)) x ≤ 2 * ε := by\n      rw [dist_comm]\n      let r := range (n + 1)\n      -- range (n+1) = {0, ..., n}\n      calc\n        (exprd) (u 0) (u (n + 1)) ≤\n            finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" r\n              ((exprd) (u i) (u <| i + 1)) :=\n          dist_le_range_sum_dist u (n + 1)\n        _ ≤\n            finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" r\n              (ε / 2 ^ i) :=\n          (sum_le_sum fun i i_in => (IH i <| nat.lt_succ_iff.mp <| finset.mem_range.mp i_in).1)\n        _ =\n            finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" r\n              ((1 / 2) ^ i * ε) :=\n          by\n          congr with i\n          field_simp\n        _ =\n            finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" r\n                ((1 / 2) ^ i) *\n              ε :=\n          finset.sum_mul.symm\n        _ ≤ 2 * ε := mul_le_mul_of_nonneg_right (sum_geometric_two_le _) (le_of_lt ε_pos)\n        \n    have B : 2 ^ (n + 1) * ϕ x ≤ ϕ (u (n + 1)) :=\n      by\n      refine' @geom_le (ϕ ∘ u) _ zero_le_two (n + 1) fun m hm => _\n      exact (IH _ <| Nat.lt_add_one_iff.1 hm).2.le\n    exact hu (n + 1) ⟨A, B⟩\n  cases' forall_and_distrib.mp key with key₁ key₂\n  clear hu key\n  -- Hence u is Cauchy\n  have cauchy_u : CauchySeq u :=\n    by\n    refine' cauchySeq_of_le_geometric _ ε one_half_lt_one fun n => _\n    simpa only [one_div, inv_pow] using key₁ n\n  -- So u converges to some y\n  obtain ⟨y, limy⟩ : ∃ y, tendsto u at_top ((nhds) y)\n  exact complete_space.complete cauchy_u\n  -- And ϕ ∘ u goes to +∞\n  have lim_top : tendsto (ϕ ∘ u) at_top at_top :=\n    by\n    let v n := (ϕ ∘ u) (n + 1)\n    suffices tendsto v at_top at_top by rwa [tendsto_add_at_top_iff_nat] at this\n    have hv₀ : 0 < v 0 := by\n      have : 0 ≤ ϕ (u 0) := nonneg x\n      calc\n        0 ≤ 2 * ϕ (u 0) := by linarith\n        _ < ϕ (u (0 + 1)) := key₂ 0\n        \n    apply tendsto_atTop_of_geom_le hv₀ one_lt_two\n    exact fun n => (key₂ (n + 1)).le\n  -- But ϕ ∘ u also needs to go to ϕ(y)\n  have lim : tendsto (ϕ ∘ u) at_top ((nhds) (ϕ y)) := tendsto.comp cont.continuous_at limy\n  -- So we have our contradiction!\n  exact not_tendsto_atTop_of_tendsto_nhds limUnder lim_top\n#align hofer hofer\n-/\n\n"}