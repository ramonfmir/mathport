{"uniform_geometric_approx'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/-- If a function admits a power series expansion, then it is exponentially close to the partial\nsums of this power series on strict subdisks of the disk of convergence.\n\nThis version provides an upper estimate that decreases both in `â€–yâ€–` and `n`. See also\n`has_fpower_series_on_ball.uniform_geometric_approx` for a weaker version. -/\ntheorem has_fpower_series_on_ball.uniform_geometric_approx' {r' : nnreal} (hf : has_fpower_series_on_ball f p x r)\n    (h : (r' : ennreal) < r) :\n    âˆƒ a âˆˆ Ioo (0 : exprâ„) 1,\n      âˆƒ C > 0,\n        âˆ€ y âˆˆ Metric.ball (0 : E) r',\n          âˆ€ n, Â«exprâ€– â€–Â» (f (x + y) - p.partial_sum n y) â‰¤ C * (a * (Â«exprâ€– â€–Â» y / r')) ^ n :=\n  by\n  obtain âŸ¨a, ha, C, hC, hpâŸ© : âˆƒ a âˆˆ Ioo (0 : exprâ„) 1, âˆƒ C > 0, âˆ€ n, Â«exprâ€– â€–Â» (p n) * r' ^ n â‰¤ C * a ^ n :=\n    p.norm_mul_pow_le_mul_pow_of_lt_radius (h.trans_le hf.r_le)\n  refine' âŸ¨a, ha, C / (1 - a), div_pos hC (sub_pos.2 ha.2), fun y hy n => _âŸ©\n  have yr' : Â«exprâ€– â€–Â» y < r' := by\n    rw [ball_zero_eq] at hy\n    exact hy\n  have hr'0 : 0 < (r' : exprâ„) := (norm_nonneg _).trans_lt yr'\n  have : y âˆˆ EMetric.ball (0 : E) r :=\n    by\n    refine' mem_emetric_ball_zero_iff.2 (lt_trans _ h)\n    exact_mod_cast yr'\n  rw [norm_sub_rev, â† mul_div_right_comm]\n  have ya : a * (Â«exprâ€– â€–Â» y / â†‘r') â‰¤ a := mul_le_of_le_one_right ha.1.le (div_le_one_of_le yr'.le r'.coe_nonneg)\n  suffices Â«exprâ€– â€–Â» (p.partial_sum n y - f (x + y)) â‰¤ C * (a * (Â«exprâ€– â€–Â» y / r')) ^ n / (1 - a * (Â«exprâ€– â€–Â» y / r'))\n    by\n    refine' this.trans _\n    apply_rules [div_le_div_of_le_left, sub_pos.2, div_nonneg, mul_nonneg, pow_nonneg, hC.lt.le, ha.1.le, norm_nonneg,\n        NNReal.coe_nonneg, ha.2, (sub_le_sub_iff_left _).2] <;>\n      infer_instance\n  apply norm_sub_le_of_geometric_bound_of_hasSum (ya.trans_lt ha.2) _ (hf.has_sum this)\n  intro n\n  calc\n    Â«exprâ€– â€–Â» ((p n) fun i : Fin n => y) â‰¤\n        Â«exprâ€– â€–Â» (p n) *\n          finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n            (Â«exprâ€– â€–Â» y) :=\n      continuous_multilinear_map.le_op_norm _ _\n    _ = Â«exprâ€– â€–Â» (p n) * r' ^ n * (Â«exprâ€– â€–Â» y / r') ^ n := by field_simp [hr'0.ne', mul_right_comm]\n    _ â‰¤ C * a ^ n * (Â«exprâ€– â€–Â» y / r') ^ n :=\n      (mul_le_mul_of_nonneg_right (hp n) (pow_nonneg (div_nonneg (norm_nonneg _) r'.coe_nonneg) _))\n    _ â‰¤ C * (a * (Â«exprâ€– â€–Â» y / r')) ^ n := by rw [mul_pow, mul_assoc]\n    \n#align has_fpower_series_on_ball.uniform_geometric_approx' has_fpower_series_on_ball.uniform_geometric_approx'\n\n",
 "uniform_geometric_approx":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/-- If a function admits a power series expansion, then it is exponentially close to the partial\nsums of this power series on strict subdisks of the disk of convergence. -/\ntheorem has_fpower_series_on_ball.uniform_geometric_approx {r' : nnreal} (hf : has_fpower_series_on_ball f p x r)\n    (h : (r' : ennreal) < r) :\n    âˆƒ a âˆˆ Ioo (0 : exprâ„) 1,\n      âˆƒ C > 0, âˆ€ y âˆˆ Metric.ball (0 : E) r', âˆ€ n, Â«exprâ€– â€–Â» (f (x + y) - p.partial_sum n y) â‰¤ C * a ^ n :=\n  by\n  obtain âŸ¨a, ha, C, hC, hpâŸ© :\n    âˆƒ a âˆˆ Ioo (0 : exprâ„) 1,\n      âˆƒ C > 0,\n        âˆ€ y âˆˆ Metric.ball (0 : E) r', âˆ€ n, Â«exprâ€– â€–Â» (f (x + y) - p.partial_sum n y) â‰¤ C * (a * (Â«exprâ€– â€–Â» y / r')) ^ n\n  exact hf.uniform_geometric_approx' h\n  refine' âŸ¨a, ha, C, hC, fun y hy n => (hp y hy n).trans _âŸ©\n  have yr' : Â«exprâ€– â€–Â» y < r' := by rwa [ball_zero_eq] at hy\n  refine' mul_le_mul_of_nonneg_left (pow_le_pow_of_le_left _ _ _) hC.lt.le\n  exacts[mul_nonneg ha.1.le (div_nonneg (norm_nonneg y) r'.coe_nonneg),\n    mul_le_of_le_one_right ha.1.le (div_le_one_of_le yr'.le r'.coe_nonneg)]\n#align has_fpower_series_on_ball.uniform_geometric_approx has_fpower_series_on_ball.uniform_geometric_approx\n\n",
 "tendsto_uniformly_on'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/-- If a function admits a power series expansion at `x`, then it is the uniform limit of the\npartial sums of this power series on strict subdisks of the disk of convergence, i.e., `f y`\nis the uniform limit of `p.partial_sum n (y - x)` there. -/\ntheorem has_fpower_series_on_ball.tendsto_uniformly_on' {r' : nnreal} (hf : has_fpower_series_on_ball f p x r)\n    (h : (r' : ennreal) < r) :\n    TendstoUniformlyOn (fun n y => p.partial_sum n (y - x)) f atTop (Metric.ball (x : E) r') :=\n  by\n  convert(hf.tendsto_uniformly_on h).comp fun y => y - x\n  Â· simp [(Â· âˆ˜ Â·)]\n  Â· ext z\n    simp [dist_eq_norm]\n#align has_fpower_series_on_ball.tendsto_uniformly_on' has_fpower_series_on_ball.tendsto_uniformly_on'\n\n",
 "tendsto_uniformly_on":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/-- If a function admits a power series expansion at `x`, then it is the uniform limit of the\npartial sums of this power series on strict subdisks of the disk of convergence, i.e., `f (x + y)`\nis the uniform limit of `p.partial_sum n y` there. -/\ntheorem has_fpower_series_on_ball.tendsto_uniformly_on {r' : nnreal} (hf : has_fpower_series_on_ball f p x r)\n    (h : (r' : ennreal) < r) :\n    TendstoUniformlyOn (fun n y => p.partial_sum n y) (fun y => f (x + y)) atTop (Metric.ball (0 : E) r') :=\n  by\n  obtain âŸ¨a, ha, C, hC, hpâŸ© :\n    âˆƒ a âˆˆ Ioo (0 : exprâ„) 1,\n      âˆƒ C > 0, âˆ€ y âˆˆ Metric.ball (0 : E) r', âˆ€ n, Â«exprâ€– â€–Â» (f (x + y) - p.partial_sum n y) â‰¤ C * a ^ n\n  exact hf.uniform_geometric_approx h\n  refine' Metric.tendstoUniformlyOn_iff.2 fun Îµ Îµpos => _\n  have L : tendsto (fun n => (C : exprâ„) * a ^ n) at_top ((nhds) ((C : exprâ„) * 0)) :=\n    tendsto_const_nhds.mul (tendsto_pow_atTop_nhds_0_of_lt_1 ha.1.le ha.2)\n  rw [MulZeroClass.mul_zero] at L\n  refine' (L.eventually (gt_mem_nhds Îµpos)).mono fun n hn y hy => _\n  rw [dist_eq_norm]\n  exact (hp y hy n).trans_lt hn\n#align has_fpower_series_on_ball.tendsto_uniformly_on has_fpower_series_on_ball.tendsto_uniformly_on\n\n",
 "tendsto_locally_uniformly_on'":
 "/-- If a function admits a power series expansion at `x`, then it is the locally uniform limit of\nthe  partial sums of this power series on the disk of convergence, i.e., `f y`\nis the locally uniform limit of `p.partial_sum n (y - x)` there. -/\ntheorem has_fpower_series_on_ball.tendsto_locally_uniformly_on' (hf : has_fpower_series_on_ball f p x r) :\n    TendstoLocallyUniformlyOn (fun n y => p.partial_sum n (y - x)) f atTop (EMetric.ball (x : E) r) :=\n  by\n  have A : ContinuousOn (fun y : E => y - x) (EMetric.ball (x : E) r) :=\n    (continuous_id.sub continuous_const).continuous_on\n  convert hf.tendsto_locally_uniformly_on.comp (fun y : E => y - x) _ A\n  Â· ext z\n    simp\n  Â· intro z\n    simp [edist_eq_coe_nnnorm, edist_eq_coe_nnnorm_sub]\n#align has_fpower_series_on_ball.tendsto_locally_uniformly_on' has_fpower_series_on_ball.tendsto_locally_uniformly_on'\n\n",
 "tendsto_locally_uniformly_on":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- If a function admits a power series expansion at `x`, then it is the locally uniform limit of\nthe partial sums of this power series on the disk of convergence, i.e., `f (x + y)`\nis the locally uniform limit of `p.partial_sum n y` there. -/\ntheorem has_fpower_series_on_ball.tendsto_locally_uniformly_on (hf : has_fpower_series_on_ball f p x r) :\n    TendstoLocallyUniformlyOn (fun n y => p.partial_sum n y) (fun y => f (x + y)) atTop (EMetric.ball (0 : E) r) :=\n  by\n  intro u hu x hx\n  rcases ENNReal.lt_iff_exists_nnreal_btwn.1 hx with âŸ¨r', xr', hr'âŸ©\n  have : EMetric.ball (0 : E) r' âˆˆ (nhds) x := IsOpen.mem_nhds EMetric.isOpen_ball xr'\n  refine' âŸ¨EMetric.ball (0 : E) r', mem_nhdsWithin_of_mem_nhds this, _âŸ©\n  simpa [Metric.emetric_ball_nnreal] using hf.tendsto_uniformly_on hr' u hu\n#align has_fpower_series_on_ball.tendsto_locally_uniformly_on has_fpower_series_on_ball.tendsto_locally_uniformly_on\n\n",
 "summable_norm_mul_pow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\ntheorem summable_norm_mul_pow (p : formal_multilinear_series ğ•œ E F) {r : nnreal} (h : â†‘r < p.radius) :\n    Summable fun n : â„• => Â«exprâ€– â€–Â» (p n) * r ^ n :=\n  by\n  obtain âŸ¨a, ha : a âˆˆ Ioo (0 : exprâ„) 1, C, hC : 0 < C, hpâŸ© := p.norm_mul_pow_le_mul_pow_of_lt_radius h\n  exact\n    summable_of_nonneg_of_le (fun n => mul_nonneg (norm_nonneg _) (pow_nonneg r.coe_nonneg _)) hp\n      ((summable_geometric_of_lt_1 ha.1.le ha.2).mul_left _)\n#align summable_norm_mul_pow summable_norm_mul_pow\n\n",
 "summable_norm_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\ntheorem summable_norm_apply (p : formal_multilinear_series ğ•œ E F) {x : E} (hx : x âˆˆ EMetric.ball (0 : E) p.radius) :\n    Summable fun n : â„• => Â«exprâ€– â€–Â» (p n fun _ => x) :=\n  by\n  rw [mem_emetric_ball_zero_iff] at hx\n  refine'\n    summable_of_nonneg_of_le (fun _ => norm_nonneg _) (fun n => ((p n).le_op_norm _).trans_eq _)\n      (p.summable_norm_mul_pow hx)\n  simp\n#align summable_norm_apply summable_norm_apply\n\n",
 "summable_nnnorm_mul_pow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–â‚ŠÂ» -/\ntheorem summable_nnnorm_mul_pow (p : formal_multilinear_series ğ•œ E F) {r : nnreal} (h : â†‘r < p.radius) :\n    Summable fun n : â„• => Â«exprâ€– â€–â‚ŠÂ» (p n) * r ^ n :=\n  by\n  rw [â† NNReal.summable_coe]\n  push_cast\n  exact p.summable_norm_mul_pow h\n#align summable_nnnorm_mul_pow summable_nnnorm_mul_pow\n\n",
 "sum":
 "theorem has_fpower_series_on_ball.sum (h : has_fpower_series_on_ball f p x r) {y : E}\n    (hy : y âˆˆ EMetric.ball (0 : E) r) : f (x + y) = p.sum y :=\n  (h.has_sum hy).tsum_eq.symm\n#align has_fpower_series_on_ball.sum has_fpower_series_on_ball.sum\n\n",
 "sub":
 "theorem analytic_on.sub {s : Set E} (hf : analytic_on ğ•œ f s) (hg : analytic_on ğ•œ g s) : analytic_on ğ•œ (f - g) s :=\n  fun z hz => (hf z hz).sub (hg z hz)\n#align analytic_on.sub analytic_on.sub\n\n",
 "radius_pos":
 "theorem has_fpower_series_at.radius_pos (hf : has_fpower_series_at f p x) : 0 < p.radius :=\n  let âŸ¨r, hrâŸ© := hf\n  hr.radius_pos\n#align has_fpower_series_at.radius_pos has_fpower_series_at.radius_pos\n\n",
 "radius_neg":
 "@[simp]\ntheorem radius_neg (p : formal_multilinear_series ğ•œ E F) : (-p).radius = p.radius := by simp [radius]\n#align radius_neg radius_neg\n\n",
 "radius_le_radius_continuous_linear_map_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\ntheorem radius_le_radius_continuous_linear_map_comp (p : formal_multilinear_series ğ•œ E F) (f : Â«expr â†’L[ ] Â» F ğ•œ G) :\n    p.radius â‰¤ (f.comp_formal_multilinear_series p).radius :=\n  by\n  refine' ENNReal.le_of_forall_nnreal_lt fun r hr => _\n  apply le_radius_of_is_O\n  apply (is_O.trans_is_o _ (p.is_o_one_of_lt_radius hr)).is_O\n  refine' is_O.mul (@is_O_with.is_O _ _ _ _ _ (Â«exprâ€– â€–Â» f) _ _ _ _) (is_O_refl _ _)\n  apply is_O_with.of_bound (eventually_of_forall fun n => _)\n  simpa only [norm_norm] using f.norm_comp_continuous_multilinear_map_le (p n)\n#align radius_le_radius_continuous_linear_map_comp radius_le_radius_continuous_linear_map_comp\n\n",
 "radius_eq_top_of_summable_norm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\ntheorem radius_eq_top_of_summable_norm (p : formal_multilinear_series ğ•œ E F)\n    (hs : âˆ€ r : nnreal, Summable fun n => Â«exprâ€– â€–Â» (p n) * r ^ n) : p.radius = ennreal.top :=\n  ENNReal.eq_top_of_forall_nnreal_le fun r => p.le_radius_of_summable_norm (hs r)\n#align radius_eq_top_of_summable_norm radius_eq_top_of_summable_norm\n\n",
 "radius_eq_top_of_forall_nnreal_is_O":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr =O[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\ntheorem radius_eq_top_of_forall_nnreal_is_O\n    (h : âˆ€ r : nnreal, Â«expr =O[ ] Â» (fun n => Â«exprâ€– â€–Â» (p n) * r ^ n) atTop fun n => (1 : exprâ„)) :\n    p.radius = ennreal.top :=\n  ENNReal.eq_top_of_forall_nnreal_le fun r => p.le_radius_of_is_O (h r)\n#align radius_eq_top_of_forall_nnreal_is_O radius_eq_top_of_forall_nnreal_is_O\n\n",
 "radius_eq_top_of_forall_image_add_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\ntheorem radius_eq_top_of_forall_image_add_eq_zero (n : â„•) (hn : âˆ€ m, p (m + n) = 0) : p.radius = ennreal.top :=\n  p.radius_eq_top_of_eventually_eq_zero <| mem_atTop_sets.2 âŸ¨n, fun k hk => tsub_add_cancel_of_le hk â–¸ hn _âŸ©\n#align radius_eq_top_of_forall_image_add_eq_zero radius_eq_top_of_forall_image_add_eq_zero\n\n",
 "radius_eq_top_of_eventually_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\ntheorem radius_eq_top_of_eventually_eq_zero\n    (h :\n      Â«exprâˆ€á¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â»\" atTop\n        (p n = 0)) :\n    p.radius = ennreal.top :=\n  p.radius_eq_top_of_forall_nnreal_is_O fun r =>\n    (isBigO_zero _ _).congr' (h.mono fun n hn => by simp [hn]) EventuallyEq.rfl\n#align radius_eq_top_of_eventually_eq_zero radius_eq_top_of_eventually_eq_zero\n\n",
 "radius_eq_top_iff_summable_norm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\ntheorem radius_eq_top_iff_summable_norm (p : formal_multilinear_series ğ•œ E F) :\n    p.radius = ennreal.top â†” âˆ€ r : nnreal, Summable fun n => Â«exprâ€– â€–Â» (p n) * r ^ n :=\n  by\n  constructor\n  Â· intro h r\n    obtain âŸ¨a, ha : a âˆˆ Ioo (0 : exprâ„) 1, C, hC : 0 < C, hpâŸ© :=\n      p.norm_mul_pow_le_mul_pow_of_lt_radius (show (r : ennreal) < p.radius from h.symm â–¸ ENNReal.coe_lt_top)\n    refine'\n      summable_of_norm_bounded (fun n => (C : exprâ„) * a ^ n) ((summable_geometric_of_lt_1 ha.1.le ha.2).mul_left _)\n        fun n => _\n    specialize hp n\n    rwa [Real.norm_of_nonneg (mul_nonneg (norm_nonneg _) (pow_nonneg r.coe_nonneg n))]\n  Â· exact p.radius_eq_top_of_summable_norm\n#align radius_eq_top_iff_summable_norm radius_eq_top_iff_summable_norm\n\n",
 "r_eq_top_of_exists":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–â‚ŠÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/-- If a function `f : ğ•œ â†’ E` has power series representation `p` on a ball of some radius and for\neach positive radius it has some power series representation, then `p` converges to `f` on the whole\n`ğ•œ`. -/\ntheorem has_fpower_series_on_ball.r_eq_top_of_exists {f : ğ•œ â†’ E} {r : ennreal} {x : ğ•œ}\n    {p : formal_multilinear_series ğ•œ ğ•œ E} (h : has_fpower_series_on_ball f p x r)\n    (h' : âˆ€ (r' : nnreal) (hr : 0 < r'), âˆƒ p' : formal_multilinear_series ğ•œ ğ•œ E, has_fpower_series_on_ball f p' x r') :\n    has_fpower_series_on_ball f p x (ennreal.top) :=\n  { r_le :=\n      ENNReal.le_of_forall_pos_nnreal_lt fun r hr hr' =>\n        let âŸ¨p', hp'âŸ© := h' r hr\n        (h.exchange_radius hp').r_le\n    r_pos := ENNReal.coe_lt_top\n    has_sum := fun y hy =>\n      let âŸ¨r', hr'âŸ© := exists_gt (Â«exprâ€– â€–â‚ŠÂ» y)\n      let âŸ¨p', hp'âŸ© := h' r' hr'.ne_bot.bot_lt\n      (h.exchange_radius hp').has_sum <| mem_emetric_ball_zero_iff.mpr (ENNReal.coe_lt_coe.2 hr') }\n#align has_fpower_series_on_ball.r_eq_top_of_exists has_fpower_series_on_ball.r_eq_top_of_exists\n\n",
 "partial_sum_continuous":
 "/-\nCopyright (c) 2020 SÃ©bastien GouÃ«zel. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: SÃ©bastien GouÃ«zel, Yury Kudryashov\n-/\n/-- The partial sums of a formal multilinear series are continuous. -/\ntheorem partial_sum_continuous (p : formal_multilinear_series ğ•œ E F) (n : â„•) : Continuous (p.partial_sum n) := by\n  continuity\n#align partial_sum_continuous partial_sum_continuous\n\n",
 "not_summable_norm_of_radius_lt_nnnorm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–â‚ŠÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\ntheorem not_summable_norm_of_radius_lt_nnnorm (p : formal_multilinear_series ğ•œ E F) {x : E}\n    (h : p.radius < Â«exprâ€– â€–â‚ŠÂ» x) : Â¬Summable fun n => Â«exprâ€– â€–Â» (p n) * Â«exprâ€– â€–Â» x ^ n := fun hs =>\n  not_le_of_lt h (p.le_radius_of_summable_norm hs)\n#align not_summable_norm_of_radius_lt_nnnorm not_summable_norm_of_radius_lt_nnnorm\n\n",
 "norm_mul_pow_le_of_lt_radius":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/-- For `r` strictly smaller than the radius of `p`, then `â€–pâ‚™â€– râ¿` is bounded. -/\ntheorem norm_mul_pow_le_of_lt_radius (p : formal_multilinear_series ğ•œ E F) {r : nnreal} (h : (r : ennreal) < p.radius) :\n    âˆƒ C > 0, âˆ€ n, Â«exprâ€– â€–Â» (p n) * r ^ n â‰¤ C :=\n  let âŸ¨a, ha, C, hC, hâŸ© := p.norm_mul_pow_le_mul_pow_of_lt_radius h\n  âŸ¨C, hC, fun n => (h n).trans <| mul_le_of_le_one_right hC.lt.le (pow_le_one _ ha.1.le ha.2.le)âŸ©\n#align norm_mul_pow_le_of_lt_radius norm_mul_pow_le_of_lt_radius\n\n",
 "norm_mul_pow_le_mul_pow_of_lt_radius":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/-- For `r` strictly smaller than the radius of `p`, then `â€–pâ‚™â€– râ¿` tends to zero exponentially:\nfor some `0 < a < 1` and `C > 0`,  `â€–p nâ€– * r ^ n â‰¤ C * a ^ n`. -/\ntheorem norm_mul_pow_le_mul_pow_of_lt_radius (h : â†‘r < p.radius) :\n    âˆƒ a âˆˆ Ioo (0 : exprâ„) 1, âˆƒ C > 0, âˆ€ n, Â«exprâ€– â€–Â» (p n) * r ^ n â‰¤ C * a ^ n :=\n  by\n  rcases((TFAE_exists_lt_isLittleO_pow (fun n => Â«exprâ€– â€–Â» (p n) * r ^ n) 1).out 1 5).mp (p.is_o_of_lt_radius h) with\n    âŸ¨a, ha, C, hC, HâŸ©\n  exact âŸ¨a, ha, C, hC, fun n => (le_abs_self _).trans (H n)âŸ©\n#align norm_mul_pow_le_mul_pow_of_lt_radius norm_mul_pow_le_mul_pow_of_lt_radius\n\n",
 "norm_le_div_pow_of_pos_of_lt_radius":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/-- For `r` strictly smaller than the radius of `p`, then `â€–pâ‚™â€– râ¿` is bounded. -/\ntheorem norm_le_div_pow_of_pos_of_lt_radius (p : formal_multilinear_series ğ•œ E F) {r : nnreal} (h0 : 0 < r)\n    (h : (r : ennreal) < p.radius) : âˆƒ C > 0, âˆ€ n, Â«exprâ€– â€–Â» (p n) â‰¤ C / r ^ n :=\n  let âŸ¨C, hC, hpâŸ© := p.norm_mul_pow_le_of_lt_radius h\n  âŸ¨C, hC, fun n => Iff.mpr (le_div_iff (pow_pos h0 _)) (hp n)âŸ©\n#align norm_le_div_pow_of_pos_of_lt_radius norm_le_div_pow_of_pos_of_lt_radius\n\n",
 "norm_change_origin_series_term":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n@[simp]\ntheorem norm_change_origin_series_term (k l : â„•) (s : Finset (Fin (k + l))) (hs : s.card = l) :\n    Â«exprâ€– â€–Â» (p.change_origin_series_term k l s hs) = Â«exprâ€– â€–Â» (p (k + l)) := by\n  simp only [change_origin_series_term, LinearIsometryEquiv.norm_map]\n#align norm_change_origin_series_term norm_change_origin_series_term\n\n",
 "nnnorm_mul_pow_le_of_lt_radius":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–â‚ŠÂ» -/\n/-- For `r` strictly smaller than the radius of `p`, then `â€–pâ‚™â€– râ¿` is bounded. -/\ntheorem nnnorm_mul_pow_le_of_lt_radius (p : formal_multilinear_series ğ•œ E F) {r : nnreal}\n    (h : (r : ennreal) < p.radius) : âˆƒ C > 0, âˆ€ n, Â«exprâ€– â€–â‚ŠÂ» (p n) * r ^ n â‰¤ C :=\n  let âŸ¨C, hC, hpâŸ© := p.norm_mul_pow_le_of_lt_radius h\n  âŸ¨âŸ¨C, hC.lt.leâŸ©, hC, by exact_mod_cast hpâŸ©\n#align nnnorm_mul_pow_le_of_lt_radius nnnorm_mul_pow_le_of_lt_radius\n\n",
 "nnnorm_change_origin_series_term_apply_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–â‚ŠÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–â‚ŠÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–â‚ŠÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–â‚ŠÂ» -/\ntheorem nnnorm_change_origin_series_term_apply_le (k l : â„•) (s : Finset (Fin (k + l))) (hs : s.card = l) (x y : E) :\n    Â«exprâ€– â€–â‚ŠÂ» (p.change_origin_series_term k l s hs (fun _ => x) fun _ => y) â‰¤\n      Â«exprâ€– â€–â‚ŠÂ» (p (k + l)) * Â«exprâ€– â€–â‚ŠÂ» x ^ l * Â«exprâ€– â€–â‚ŠÂ» y ^ k :=\n  by\n  rw [â† p.nnnorm_change_origin_series_term k l s hs, â† Fin.prod_const, â† Fin.prod_const]\n  apply continuous_multilinear_map.le_of_op_nnnorm_le\n  apply continuous_multilinear_map.le_op_nnnorm\n#align nnnorm_change_origin_series_term_apply_le nnnorm_change_origin_series_term_apply_le\n\n",
 "nnnorm_change_origin_series_term":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–â‚ŠÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–â‚ŠÂ» -/\n@[simp]\ntheorem nnnorm_change_origin_series_term (k l : â„•) (s : Finset (Fin (k + l))) (hs : s.card = l) :\n    Â«exprâ€– â€–â‚ŠÂ» (p.change_origin_series_term k l s hs) = Â«exprâ€– â€–â‚ŠÂ» (p (k + l)) := by\n  simp only [change_origin_series_term, LinearIsometryEquiv.nnnorm_map]\n#align nnnorm_change_origin_series_term nnnorm_change_origin_series_term\n\n",
 "nnnorm_change_origin_series_le_tsum":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–â‚ŠÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ‘' , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ‘' , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–â‚ŠÂ» -/\ntheorem nnnorm_change_origin_series_le_tsum (k l : â„•) :\n    Â«exprâ€– â€–â‚ŠÂ» (p.change_origin_series k l) â‰¤\n      Â«exprâˆ‘' , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ‘' , Â»\"\n        (Â«exprâ€– â€–â‚ŠÂ» (p (k + l))) :=\n  (nnnorm_sum_le _ _).trans_eq <| by simp only [tsum_fintype, nnnorm_change_origin_series_term]\n#align nnnorm_change_origin_series_le_tsum nnnorm_change_origin_series_le_tsum\n\n",
 "nnnorm_change_origin_series_apply_le_tsum":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–â‚ŠÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ‘' , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ‘' , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–â‚ŠÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–â‚ŠÂ» -/\ntheorem nnnorm_change_origin_series_apply_le_tsum (k l : â„•) (x : E) :\n    Â«exprâ€– â€–â‚ŠÂ» (p.change_origin_series k l fun _ => x) â‰¤\n      Â«exprâˆ‘' , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ‘' , Â»\"\n        (Â«exprâ€– â€–â‚ŠÂ» (p (k + l)) * Â«exprâ€– â€–â‚ŠÂ» x ^ l) :=\n  by\n  rw [NNReal.tsum_mul_right, â† Fin.prod_const]\n  exact (p.change_origin_series k l).le_of_op_nnnorm_le _ (p.nnnorm_change_origin_series_le_tsum _ _)\n#align nnnorm_change_origin_series_apply_le_tsum nnnorm_change_origin_series_apply_le_tsum\n\n",
 "nnnorm_change_origin_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–â‚ŠÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–â‚ŠÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ‘' , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ‘' , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–â‚ŠÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–â‚ŠÂ» -/\ntheorem nnnorm_change_origin_le (k : â„•) (h : (Â«exprâ€– â€–â‚ŠÂ» x : ennreal) < p.radius) :\n    Â«exprâ€– â€–â‚ŠÂ» (p.change_origin x k) â‰¤\n      Â«exprâˆ‘' , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ‘' , Â»\"\n        (Â«exprâ€– â€–â‚ŠÂ» (p (k + s.1)) * Â«exprâ€– â€–â‚ŠÂ» x ^ s.1) :=\n  by\n  refine' tsum_of_nnnorm_bounded _ fun l => p.nnnorm_change_origin_series_apply_le_tsum k l x\n  have := p.change_origin_series_summable_auxâ‚‚ h k\n  refine' HasSum.sigma this.has_sum fun l => _\n  exact ((NNReal.summable_sigma.1 this).1 l).has_sum\n#align nnnorm_change_origin_le nnnorm_change_origin_le\n\n",
 "neg":
 "theorem analytic_at.neg (hf : analytic_at ğ•œ f x) : analytic_at ğ•œ (-f) x :=\n  let âŸ¨pf, hpfâŸ© := hf\n  hpf.neg.analytic_at\n#align analytic_at.neg analytic_at.neg\n\n",
 "mono":
 "theorem analytic_on.mono {s t : Set E} (hf : analytic_on ğ•œ f t) (hst : s âŠ† t) : analytic_on ğ•œ f s := fun z hz =>\n  hf z (hst hz)\n#align analytic_on.mono analytic_on.mono\n\n",
 "min_radius_le_radius_add":
 "/-- The radius of the sum of two formal series is at least the minimum of their two radii. -/\ntheorem min_radius_le_radius_add (p q : formal_multilinear_series ğ•œ E F) : min p.radius q.radius â‰¤ (p + q).radius :=\n  by\n  refine' ENNReal.le_of_forall_nnreal_lt fun r hr => _\n  rw [lt_min_iff] at hr\n  have := ((p.is_o_one_of_lt_radius hr.1).add (q.is_o_one_of_lt_radius hr.2)).is_O\n  refine' (p + q).le_radius_of_is_O ((is_O_of_le _ fun n => _).trans this)\n  rw [â† add_mul, norm_mul, norm_mul, norm_norm]\n  exact mul_le_mul_of_nonneg_right ((norm_add_le _ _).trans (le_abs_self _)) (norm_nonneg _)\n#align min_radius_le_radius_add min_radius_le_radius_add\n\n",
 "lt_radius_of_is_O":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr =O[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/-- If `r â‰  0` and `â€–pâ‚™â€– râ¿ = O(aâ¿)` for some `-1 < a < 1`, then `r < p.radius`. -/\ntheorem lt_radius_of_is_O (hâ‚€ : r â‰  0) {a : exprâ„} (ha : a âˆˆ Ioo (-1 : exprâ„) 1)\n    (hp : Â«expr =O[ ] Â» (fun n => Â«exprâ€– â€–Â» (p n) * r ^ n) atTop (pow a)) : â†‘r < p.radius :=\n  by\n  rcases((TFAE_exists_lt_isLittleO_pow (fun n => Â«exprâ€– â€–Â» (p n) * r ^ n) 1).out 2 5).mp âŸ¨a, ha, hpâŸ© with\n    âŸ¨a, ha, C, hC, hpâŸ©\n  rw [â† pos_iff_ne_zero, â† NNReal.coe_pos] at hâ‚€\n  lift a to nnreal using ha.1.le\n  have : (r : exprâ„) < r / a := by simpa only [div_one] using (div_lt_div_left hâ‚€ zero_lt_one ha.1).2 ha.2\n  norm_cast  at this\n  rw [â† ENNReal.coe_lt_coe] at this\n  refine' this.trans_le (p.le_radius_of_bound C fun n => _)\n  rw [NNReal.coe_div, div_pow, â† mul_div_assoc, div_le_iff (pow_pos ha.1 n)]\n  exact (le_abs_self _).trans (hp n)\n#align lt_radius_of_is_O lt_radius_of_is_O\n\n",
 "le_radius_of_tendsto":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem le_radius_of_tendsto (p : formal_multilinear_series ğ•œ E F) {l : exprâ„}\n    (h : Tendsto (fun n => Â«exprâ€– â€–Â» (p n) * r ^ n) atTop ((nhds) l)) : â†‘r â‰¤ p.radius :=\n  p.le_radius_of_is_O (h.is_O_one _)\n#align le_radius_of_tendsto le_radius_of_tendsto\n\n",
 "le_radius_of_summable_norm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\ntheorem le_radius_of_summable_norm (p : formal_multilinear_series ğ•œ E F)\n    (hs : Summable fun n => Â«exprâ€– â€–Â» (p n) * r ^ n) : â†‘r â‰¤ p.radius :=\n  p.le_radius_of_tendsto hs.tendsto_at_top_zero\n#align le_radius_of_summable_norm le_radius_of_summable_norm\n\n",
 "le_radius_of_summable_nnnorm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ‘' , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ‘' , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–â‚ŠÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–â‚ŠÂ» -/\ntheorem le_radius_of_summable_nnnorm (h : Summable fun n => Â«exprâ€– â€–â‚ŠÂ» (p n) * r ^ n) : â†‘r â‰¤ p.radius :=\n  p.le_radius_of_bound_nnreal\n    (Â«exprâˆ‘' , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ‘' , Â»\"\n      (Â«exprâ€– â€–â‚ŠÂ» (p n) * r ^ n))\n    fun n => le_tsum' h _\n#align le_radius_of_summable_nnnorm le_radius_of_summable_nnnorm\n\n",
 "le_radius_of_summable":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\ntheorem le_radius_of_summable (h : Summable fun n => Â«exprâ€– â€–Â» (p n) * r ^ n) : â†‘r â‰¤ p.radius :=\n  p.le_radius_of_summable_nnnorm <| by\n    simp only [â† coe_nnnorm] at h\n    exact_mod_cast h\n#align le_radius_of_summable le_radius_of_summable\n\n",
 "le_radius_of_is_O":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr =O[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/-- If `â€–pâ‚™â€– râ¿ = O(1)`, as `n â†’ âˆ`, then the radius of `p` is at least `r`. -/\ntheorem le_radius_of_is_O (h : Â«expr =O[ ] Â» (fun n => Â«exprâ€– â€–Â» (p n) * r ^ n) atTop fun n => (1 : exprâ„)) :\n    â†‘r â‰¤ p.radius :=\n  exists.elim (isBigO_one_nat_atTop_iff.1 h) fun C hC => p.le_radius_of_bound C fun n => (le_abs_self _).trans (hC n)\n#align le_radius_of_is_O le_radius_of_is_O\n\n",
 "le_radius_of_eventually_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\ntheorem le_radius_of_eventually_le (C)\n    (h :\n      Â«exprâˆ€á¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â»\" atTop\n        (Â«exprâ€– â€–Â» (p n) * r ^ n â‰¤ C)) :\n    â†‘r â‰¤ p.radius :=\n  p.le_radius_of_is_O <| IsBigO.of_bound C <| h.mono fun n hn => by simpa\n#align le_radius_of_eventually_le le_radius_of_eventually_le\n\n",
 "le_radius_of_bound_nnreal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–â‚ŠÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/-- If `â€–pâ‚™â€– râ¿` is bounded in `n`, then the radius of `p` is at least `r`. -/\ntheorem le_radius_of_bound_nnreal (C : nnreal) {r : nnreal} (h : âˆ€ n : â„•, Â«exprâ€– â€–â‚ŠÂ» (p n) * r ^ n â‰¤ C) :\n    (r : ennreal) â‰¤ p.radius :=\n  p.le_radius_of_bound C fun n => by exact_mod_cast h n\n#align le_radius_of_bound_nnreal le_radius_of_bound_nnreal\n\n",
 "le_radius_of_bound":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/-- If `â€–pâ‚™â€– râ¿` is bounded in `n`, then the radius of `p` is at least `r`. -/\ntheorem le_radius_of_bound (C : exprâ„) {r : nnreal} (h : âˆ€ n : â„•, Â«exprâ€– â€–Â» (p n) * r ^ n â‰¤ C) :\n    (r : ennreal) â‰¤ p.radius :=\n  le_supáµ¢_of_le r <| le_supáµ¢_of_le C <| le_supáµ¢ (fun _ => (r : ennreal)) h\n#align le_radius_of_bound le_radius_of_bound\n\n",
 "le_mul_pow_of_radius_pos":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/-- If the radius of `p` is positive, then `â€–pâ‚™â€–` grows at most geometrically. -/\ntheorem le_mul_pow_of_radius_pos (p : formal_multilinear_series ğ•œ E F) (h : 0 < p.radius) :\n    âˆƒ (C r : _)(hC : 0 < C)(hr : 0 < r), âˆ€ n, Â«exprâ€– â€–Â» (p n) â‰¤ C * r ^ n :=\n  by\n  rcases ENNReal.lt_iff_exists_nnreal_btwn.1 h with âŸ¨r, r0, rltâŸ©\n  have rpos : 0 < (r : exprâ„) := by simp [ENNReal.coe_pos.1 r0]\n  rcases norm_le_div_pow_of_pos_of_lt_radius p rpos rlt with âŸ¨C, Cpos, hCpâŸ©\n  refine' âŸ¨C, râ»Â¹, Cpos, by simp [rpos], fun n => _âŸ©\n  convert hCp n\n  exact inv_pow _ _\n#align le_mul_pow_of_radius_pos le_mul_pow_of_radius_pos\n\n",
 "le_change_origin_series_radius":
 "theorem le_change_origin_series_radius (k : â„•) : p.radius â‰¤ (p.change_origin_series k).radius :=\n  ENNReal.le_of_forall_nnreal_lt fun r hr => le_radius_of_summable_nnnorm _ (p.change_origin_series_summable_auxâ‚ƒ hr k)\n#align le_change_origin_series_radius le_change_origin_series_radius\n\n",
 "is_open_analytic_at":
 "/-- For any function `f` from a normed vector space to a Banach space, the set of points `x` such\nthat `f` is analytic at `x` is open. -/\ntheorem is_open_analytic_at : IsOpen { x | analytic_at ğ•œ f x } :=\n  by\n  rw [isOpen_iff_mem_nhds]\n  rintro x âŸ¨p, r, hrâŸ©\n  exact mem_of_superset (EMetric.ball_mem_nhds _ hr.r_pos) fun y hy => hr.analytic_at_of_mem hy\n#align is_open_analytic_at is_open_analytic_at\n\n",
 "is_o_one_of_lt_radius":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr =o[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/-- For `r` strictly smaller than the radius of `p`, then `â€–pâ‚™â€– râ¿ = o(1)`. -/\ntheorem is_o_one_of_lt_radius (h : â†‘r < p.radius) :\n    Â«expr =o[ ] Â» (fun n => Â«exprâ€– â€–Â» (p n) * r ^ n) atTop (fun _ => 1 : â„• â†’ exprâ„) :=\n  let âŸ¨a, ha, hpâŸ© := p.is_o_of_lt_radius h\n  hp.trans <| (isLittleO_pow_pow_of_lt_left ha.1.le ha.2).congr (fun n => rfl) one_pow\n#align is_o_one_of_lt_radius is_o_one_of_lt_radius\n\n",
 "is_o_of_lt_radius":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr =o[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/-- For `r` strictly smaller than the radius of `p`, then `â€–pâ‚™â€– râ¿` tends to zero exponentially:\nfor some `0 < a < 1`, `â€–p nâ€– râ¿ = o(aâ¿)`. -/\ntheorem is_o_of_lt_radius (h : â†‘r < p.radius) :\n    âˆƒ a âˆˆ Ioo (0 : exprâ„) 1, Â«expr =o[ ] Â» (fun n => Â«exprâ€– â€–Â» (p n) * r ^ n) atTop (pow a) :=\n  by\n  rw [(TFAE_exists_lt_isLittleO_pow (fun n => Â«exprâ€– â€–Â» (p n) * r ^ n) 1).out 1 4]\n  simp only [radius, lt_supáµ¢_iff] at h\n  rcases h with âŸ¨t, C, hC, rtâŸ©\n  rw [ENNReal.coe_lt_coe, â† NNReal.coe_lt_coe] at rt\n  have : 0 < (t : exprâ„) := r.coe_nonneg.trans_lt rt\n  rw [â† div_lt_one this] at rt\n  refine' âŸ¨_, rt, C, or.inr zero_lt_one, fun n => _âŸ©\n  calc\n    |Â«exprâ€– â€–Â» (p n) * r ^ n| = Â«exprâ€– â€–Â» (p n) * t ^ n * (r / t) ^ n := by\n      field_simp [mul_right_comm, abs_mul, this.ne']\n    _ â‰¤ C * (r / t) ^ n := mul_le_mul_of_nonneg_right (hC n) (pow_nonneg (div_nonneg r.2 t.2) _)\n    \n#align is_o_of_lt_radius is_o_of_lt_radius\n\n",
 "is_O_sub_partial_sum_pow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr =O[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/-- Taylor formula for an analytic function, `is_O` version. -/\ntheorem has_fpower_series_at.is_O_sub_partial_sum_pow (hf : has_fpower_series_at f p x) (n : â„•) :\n    Â«expr =O[ ] Â» (fun y : E => f (x + y) - p.partial_sum n y) ((nhds) 0) fun y => Â«exprâ€– â€–Â» y ^ n :=\n  by\n  rcases hf with âŸ¨r, hfâŸ©\n  rcases ENNReal.lt_iff_exists_nnreal_btwn.1 hf.r_pos with âŸ¨r', r'0, hâŸ©\n  obtain âŸ¨a, ha, C, hC, hpâŸ© :\n    âˆƒ a âˆˆ Ioo (0 : exprâ„) 1,\n      âˆƒ C > 0,\n        âˆ€ y âˆˆ Metric.ball (0 : E) r', âˆ€ n, Â«exprâ€– â€–Â» (f (x + y) - p.partial_sum n y) â‰¤ C * (a * (Â«exprâ€– â€–Â» y / r')) ^ n\n  exact hf.uniform_geometric_approx' h\n  refine' is_O_iff.2 âŸ¨C * (a / r') ^ n, _âŸ©\n  replace r'0 : 0 < (r' : exprâ„); Â· exact_mod_cast r'0\n  filter_upwards [Metric.ball_mem_nhds (0 : E) r'0]with y hy\n  simpa [mul_pow, mul_div_assoc, mul_assoc, div_mul_eq_mul_div] using hp y hy n\n#align has_fpower_series_at.is_O_sub_partial_sum_pow has_fpower_series_at.is_O_sub_partial_sum_pow\n\n",
 "is_O_image_sub_norm_mul_norm_sub":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr =O[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/-- If `f` has formal power series `âˆ‘ n, pâ‚™` at `x`, then\n`f y - f z - p 1 (Î» _, y - z) = O(â€–(y, z) - (x, x)â€– * â€–y - zâ€–)` as `(y, z) â†’ (x, x)`.\nIn particular, `f` is strictly differentiable at `x`. -/\ntheorem has_fpower_series_at.is_O_image_sub_norm_mul_norm_sub (hf : has_fpower_series_at f p x) :\n    Â«expr =O[ ] Â» (fun y : E Ã— E => f y.1 - f y.2 - p 1 fun _ => y.1 - y.2) ((nhds) (x, x)) fun y =>\n      Â«exprâ€– â€–Â» (y - (x, x)) * Â«exprâ€– â€–Â» (y.1 - y.2) :=\n  by\n  rcases hf with âŸ¨r, hfâŸ©\n  rcases ENNReal.lt_iff_exists_nnreal_btwn.1 hf.r_pos with âŸ¨r', r'0, hâŸ©\n  refine' (hf.is_O_image_sub_image_sub_deriv_principal h).mono _\n  exact le_principal_iff.2 (EMetric.ball_mem_nhds _ r'0)\n#align has_fpower_series_at.is_O_image_sub_norm_mul_norm_sub has_fpower_series_at.is_O_image_sub_norm_mul_norm_sub\n\n",
 "is_O_image_sub_image_sub_deriv_principal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr =O[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr =O[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/-- If `f` has formal power series `âˆ‘ n, pâ‚™` on a ball of radius `r`, then for `y, z` in any smaller\nball, the norm of the difference `f y - f z - p 1 (Î» _, y - z)` is bounded above by\n`C * (max â€–y - xâ€– â€–z - xâ€–) * â€–y - zâ€–`. This lemma formulates this property using `is_O` and\n`filter.principal` on `E Ã— E`. -/\ntheorem has_fpower_series_on_ball.is_O_image_sub_image_sub_deriv_principal (hf : has_fpower_series_on_ball f p x r)\n    (hr : r' < r) :\n    Â«expr =O[ ] Â» (fun y : E Ã— E => f y.1 - f y.2 - p 1 fun _ => y.1 - y.2)\n      ((filter.principal) (EMetric.ball (x, x) r')) fun y => Â«exprâ€– â€–Â» (y - (x, x)) * Â«exprâ€– â€–Â» (y.1 - y.2) :=\n  by\n  lift r' to nnreal using ne_top_of_lt hr\n  rcases(zero_le r').eq_or_lt with (rfl | hr'0)\n  Â· simp only [is_O_bot, EMetric.ball_zero, principal_empty, ENNReal.coe_zero]\n  obtain âŸ¨a, ha, C, hC : 0 < C, hpâŸ© : âˆƒ a âˆˆ Ioo (0 : exprâ„) 1, âˆƒ C > 0, âˆ€ n : â„•, Â«exprâ€– â€–Â» (p n) * â†‘r' ^ n â‰¤ C * a ^ n\n  exact p.norm_mul_pow_le_mul_pow_of_lt_radius (hr.trans_le hf.r_le)\n  simp only [â† le_div_iff (pow_pos (NNReal.coe_pos.2 hr'0) _)] at hp\n  set L : E Ã— E â†’ exprâ„ := fun y =>\n    C * (a / r') ^ 2 * (Â«exprâ€– â€–Â» (y - (x, x)) * Â«exprâ€– â€–Â» (y.1 - y.2)) * (a / (1 - a) ^ 2 + 2 / (1 - a))\n  have hL : âˆ€ y âˆˆ EMetric.ball (x, x) r', Â«exprâ€– â€–Â» (f y.1 - f y.2 - p 1 fun _ => y.1 - y.2) â‰¤ L y :=\n    by\n    intro y hy'\n    have hy : y âˆˆ lower_set.prod (EMetric.ball x r) (EMetric.ball x r) :=\n      by\n      rw [EMetric.ball_prod_same]\n      exact EMetric.ball_subset_ball hr.le hy'\n    set A : â„• â†’ F := fun n => (p n fun _ => y.1 - x) - p n fun _ => y.2 - x\n    have hA : HasSum (fun n => A (n + 2)) (f y.1 - f y.2 - p 1 fun _ => y.1 - y.2) :=\n      by\n      convert(hasSum_nat_add_iff' 2).2 ((hf.has_sum_sub hy.1).sub (hf.has_sum_sub hy.2)) using 1\n      rw [Finset.sum_range_succ, Finset.sum_range_one, hf.coeff_zero, hf.coeff_zero, sub_self, zero_add, â†\n        Subsingleton.pi_single_eq (0 : Fin 1) (y.1 - x), Pi.single, â† Subsingleton.pi_single_eq (0 : Fin 1) (y.2 - x),\n        Pi.single, â† (p 1).map_sub, â† Pi.single, Subsingleton.pi_single_eq, sub_sub_sub_cancel_right]\n    rw [EMetric.mem_ball, edist_eq_coe_nnnorm_sub, ENNReal.coe_lt_coe] at hy'\n    set B : â„• â†’ exprâ„ := fun n =>\n      C * (a / r') ^ 2 * (Â«exprâ€– â€–Â» (y - (x, x)) * Â«exprâ€– â€–Â» (y.1 - y.2)) * ((n + 2) * a ^ n)\n    have hAB : âˆ€ n, Â«exprâ€– â€–Â» (A (n + 2)) â‰¤ B n := fun n =>\n      calc\n        Â«exprâ€– â€–Â» (A (n + 2)) â‰¤\n            Â«exprâ€– â€–Â» (p (n + 2)) * â†‘(n + 2) * Â«exprâ€– â€–Â» (y - (x, x)) ^ (n + 1) * Â«exprâ€– â€–Â» (y.1 - y.2) :=\n          by\n          simpa only [Fintype.card_fin, pi_norm_const (_ : E), Prod.norm_def, Pi.sub_def, Prod.fst_sub, Prod.snd_sub,\n            sub_sub_sub_cancel_right] using (p <| n + 2).norm_image_sub_le (fun _ => y.1 - x) fun _ => y.2 - x\n        _ =\n            Â«exprâ€– â€–Â» (p (n + 2)) * Â«exprâ€– â€–Â» (y - (x, x)) ^ n *\n              (â†‘(n + 2) * Â«exprâ€– â€–Â» (y - (x, x)) * Â«exprâ€– â€–Â» (y.1 - y.2)) :=\n          by\n          rw [pow_succ (Â«exprâ€– â€–Â» (y - (x, x)))]\n          ring\n        _ â‰¤ C * a ^ (n + 2) / r' ^ (n + 2) * r' ^ n * (â†‘(n + 2) * Â«exprâ€– â€–Â» (y - (x, x)) * Â«exprâ€– â€–Â» (y.1 - y.2)) := by\n          apply_rules [mul_le_mul_of_nonneg_right, mul_le_mul, hp, pow_le_pow_of_le_left, hy'.le, norm_nonneg,\n            pow_nonneg, div_nonneg, mul_nonneg, Nat.cast_nonneg, hC.le, r'.coe_nonneg, ha.1.le]\n        _ = B n := by\n          field_simp [B, pow_succ, hr'0.ne']\n          simp only [mul_assoc, mul_comm, mul_left_comm]\n        \n    have hBL : HasSum B (L y) := by\n      apply HasSum.mul_left\n      simp only [add_mul]\n      have : Â«exprâ€– â€–Â» a < 1 := by simp only [Real.norm_eq_abs, abs_of_pos ha.1, ha.2]\n      convert(hasSum_coe_mul_geometric_of_norm_lt_1 this).add ((hasSum_geometric_of_norm_lt_1 this).mul_left 2)\n    exact hA.norm_le_of_bounded hBL hAB\n  suffices\n    Â«expr =O[ ] Â» L ((filter.principal) (EMetric.ball (x, x) r')) fun y =>\n      Â«exprâ€– â€–Â» (y - (x, x)) * Â«exprâ€– â€–Â» (y.1 - y.2)\n    by\n    refine' (is_O.of_bound 1 (eventually_principal.2 fun y hy => _)).trans this\n    rw [one_mul]\n    exact (hL y hy).trans (le_abs_self _)\n  simp_rw [L, mul_right_comm _ (_ * _)]\n  exact (is_O_refl _ _).const_mul_left _\n#align has_fpower_series_on_ball.is_O_image_sub_image_sub_deriv_principal has_fpower_series_on_ball.is_O_image_sub_image_sub_deriv_principal\n\n",
 "image_sub_sub_deriv_le":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (y z Â«expr âˆˆ Â» emetric.ball[emetric.ball] x r') -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/-- If `f` has formal power series `âˆ‘ n, pâ‚™` on a ball of radius `r`, then for `y, z` in any smaller\nball, the norm of the difference `f y - f z - p 1 (Î» _, y - z)` is bounded above by\n`C * (max â€–y - xâ€– â€–z - xâ€–) * â€–y - zâ€–`. -/\ntheorem has_fpower_series_on_ball.image_sub_sub_deriv_le (hf : has_fpower_series_on_ball f p x r) (hr : r' < r) :\n    âˆƒ C,\n      âˆ€ (y) (_ : y âˆˆ EMetric.ball x r') (z) (_ : z âˆˆ EMetric.ball x r'),\n        Â«exprâ€– â€–Â» (f y - f z - p 1 fun _ => y - z) â‰¤\n          C * max (Â«exprâ€– â€–Â» (y - x)) (Â«exprâ€– â€–Â» (z - x)) * Â«exprâ€– â€–Â» (y - z) :=\n  by\n  simpa only [is_O_principal, mul_assoc, norm_mul, norm_norm, Prod.forall, EMetric.mem_ball, Prod.edist_eq, max_lt_iff,\n    and_imp, @forall_swap (_ < _) E] using hf.is_O_image_sub_image_sub_deriv_principal hr\n#align has_fpower_series_on_ball.image_sub_sub_deriv_le has_fpower_series_on_ball.image_sub_sub_deriv_le\n\n",
 "has_sum_sub":
 "theorem has_fpower_series_on_ball.has_sum_sub (hf : has_fpower_series_on_ball f p x r) {y : E}\n    (hy : y âˆˆ EMetric.ball x r) : HasSum (fun n : â„• => p n fun i => y - x) (f y) :=\n  by\n  have : y - x âˆˆ EMetric.ball (0 : E) r := by simpa [edist_eq_coe_nnnorm_sub] using hy\n  simpa only [add_sub_cancel'_right] using hf.has_sum this\n#align has_fpower_series_on_ball.has_sum_sub has_fpower_series_on_ball.has_sum_sub\n\n",
 "has_fpower_series_on_ball_const":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\ntheorem has_fpower_series_on_ball_const {c : F} {e : E} :\n    has_fpower_series_on_ball (fun _ => c) (const_formal_multilinear_series ğ•œ E c) e (Â«exprâŠ¤Â») :=\n  by\n  refine' âŸ¨by simp, WithTop.zero_lt_top, fun y hy => hasSum_single 0 fun n hn => _âŸ©\n  simp [const_formal_multilinear_series_apply hn]\n#align has_fpower_series_on_ball_const has_fpower_series_on_ball_const\n\n",
 "has_fpower_series_on_ball_change_origin":
 "-- From this point on, assume that the space is complete, to make sure that series that converge\n-- in norm also converge in `F`.\ntheorem has_fpower_series_on_ball_change_origin (k : â„•) (hr : 0 < p.radius) :\n    has_fpower_series_on_ball (fun x => p.change_origin x k) (p.change_origin_series k) 0 p.radius :=\n  have := p.le_change_origin_series_radius k\n  ((p.change_origin_series k).has_fpower_series_on_ball (hr.trans_le this)).mono hr this\n#align has_fpower_series_on_ball_change_origin has_fpower_series_on_ball_change_origin\n\n",
 "has_fpower_series_on_ball":
 "/-- In a complete space, the sum of a converging power series `p` admits `p` as a power series.\nThis is not totally obvious as we need to check the convergence of the series. -/\nprotected theorem formal_multilinear_series.has_fpower_series_on_ball [CompleteSpace F]\n    (p : formal_multilinear_series ğ•œ E F) (h : 0 < p.radius) : has_fpower_series_on_ball p.sum p 0 p.radius :=\n  { r_le := le_rfl\n    r_pos := h\n    has_sum := fun y hy => by\n      rw [zero_add]\n      exact p.has_sum hy }\n#align formal_multilinear_series.has_fpower_series_on_ball formal_multilinear_series.has_fpower_series_on_ball\n\n",
 "has_fpower_series_at_iff'":
 "/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:73:14: unsupported tactic `congrm #[[expr Â«exprâˆ€á¶  in , Â»((z), (nhds() 0 : filter ğ•œ), has_sum (Î» n, _) (f Â«expr + Â»(zâ‚€, z)))]] -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\ntheorem has_fpower_series_at_iff' :\n    has_fpower_series_at f p zâ‚€ â†”\n      Â«exprâˆ€á¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â»\"\n        ((nhds) zâ‚€) (HasSum (fun n => Â«expr â€¢ Â» ((z - zâ‚€) ^ n) (p.coeff n)) (f z)) :=\n  by\n  rw [â† map_add_left_nhds_zero, eventually_map, has_fpower_series_at_iff]\n  trace\n    \"./././Mathport/Syntax/Translate/Tactic/Builtin.lean:73:14: unsupported tactic `congrm #[[expr Â«exprâˆ€á¶  in , Â»((z), (nhds() 0 : filter ğ•œ), has_sum (Î» n, _) (f Â«expr + Â»(zâ‚€, z)))]]\"\n  rw [add_sub_cancel']\n#align has_fpower_series_at_iff' has_fpower_series_at_iff'\n\n",
 "has_fpower_series_at_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŠ“ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–â‚ŠÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/-- A function `f : ğ•œ â†’ E` has `p` as power series expansion at a point `zâ‚€` iff it is the sum of\n`p` in a neighborhood of `zâ‚€`. This makes some proofs easier by hiding the fact that\n`has_fpower_series_at` depends on `p.radius`. -/\ntheorem has_fpower_series_at_iff :\n    has_fpower_series_at f p zâ‚€ â†”\n      Â«exprâˆ€á¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â»\" ((nhds) 0)\n        (HasSum (fun n => Â«expr â€¢ Â» (z ^ n) (p.coeff n)) (f (zâ‚€ + z))) :=\n  by\n  refine' âŸ¨fun âŸ¨r, r_le, r_pos, hâŸ© => eventually_of_mem (EMetric.ball_mem_nhds 0 r_pos) fun _ => by simpa using h, _âŸ©\n  simp only [Metric.eventually_nhds_iff]\n  rintro âŸ¨r, r_pos, hâŸ©\n  refine' âŸ¨Â«expr âŠ“ Â» p.radius r.to_nnreal, by simp, _, _âŸ©\n  Â· simp only [r_pos.lt, lt_inf_iff, ENNReal.coe_pos, Real.toNNReal_pos, and_true_iff]\n    obtain âŸ¨z, z_pos, le_zâŸ© := NormedField.exists_norm_lt ğ•œ r_pos.lt\n    have : (Â«exprâ€– â€–â‚ŠÂ» z : ENNReal) â‰¤ p.radius :=\n      by\n      simp only [dist_zero_right] at h\n      apply formal_multilinear_series.le_radius_of_tendsto\n      convert tendsto_norm.comp (h le_z).summable.tendsto_at_top_zero\n      funext <;> simp [norm_smul, mul_comm]\n    refine' lt_of_lt_of_le _ this\n    simp only [ENNReal.coe_pos]\n    exact zero_lt_iff.mpr (nnnorm_ne_zero_iff.mpr (norm_pos_iff.mp z_pos))\n  Â· simp only [EMetric.mem_ball, lt_inf_iff, edist_lt_coe, apply_eq_pow_smul_coeff, and_imp, dist_zero_right] at hâŠ¢\n    refine' fun y hyp hyr => h _\n    simpa [nndist_eq_nnnorm, Real.lt_toNNReal_iff_coe_lt] using hyr\n#align has_fpower_series_at_iff has_fpower_series_at_iff\n\n",
 "has_fpower_series_at_const":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\ntheorem has_fpower_series_at_const {c : F} {e : E} :\n    has_fpower_series_at (fun _ => c) (const_formal_multilinear_series ğ•œ E c) e :=\n  âŸ¨Â«exprâŠ¤Â», has_fpower_series_on_ball_constâŸ©\n#align has_fpower_series_at_const has_fpower_series_at_const\n\n",
 "has_fpower_series_at":
 "theorem has_fpower_series_on_ball.has_fpower_series_at (hf : has_fpower_series_on_ball f p x r) :\n    has_fpower_series_at f p x :=\n  âŸ¨r, hfâŸ©\n#align has_fpower_series_on_ball.has_fpower_series_at has_fpower_series_on_ball.has_fpower_series_at\n\n",
 "exchange_radius":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/-- If a function `f : ğ•œ â†’ E` has two power series representations at `x`, then the given radii in\nwhich convergence is guaranteed may be interchanged. This can be useful when the formal multilinear\nseries in one representation has a particularly nice form, but the other has a larger radius. -/\ntheorem has_fpower_series_on_ball.exchange_radius {pâ‚ pâ‚‚ : formal_multilinear_series ğ•œ ğ•œ E} {f : ğ•œ â†’ E}\n    {râ‚ râ‚‚ : ennreal} {x : ğ•œ} (hâ‚ : has_fpower_series_on_ball f pâ‚ x râ‚) (hâ‚‚ : has_fpower_series_on_ball f pâ‚‚ x râ‚‚) :\n    has_fpower_series_on_ball f pâ‚ x râ‚‚ :=\n  hâ‚‚.has_fpower_series_at.eq_formal_multilinear_series hâ‚.has_fpower_series_at â–¸ hâ‚‚\n#align has_fpower_series_on_ball.exchange_radius has_fpower_series_on_ball.exchange_radius\n\n",
 "eventually_has_sum_sub":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem has_fpower_series_at.eventually_has_sum_sub (hf : has_fpower_series_at f p x) :\n    Â«exprâˆ€á¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â»\" ((nhds) x)\n      (HasSum (fun n : â„• => p n fun i : Fin n => y - x) (f y)) :=\n  let âŸ¨r, hrâŸ© := hf\n  hr.eventually_has_sum_sub\n#align has_fpower_series_at.eventually_has_sum_sub has_fpower_series_at.eventually_has_sum_sub\n\n",
 "eventually_has_sum":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem has_fpower_series_at.eventually_has_sum (hf : has_fpower_series_at f p x) :\n    Â«exprâˆ€á¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â»\" ((nhds) 0)\n      (HasSum (fun n : â„• => p n fun i : Fin n => y) (f (x + y))) :=\n  let âŸ¨r, hrâŸ© := hf\n  hr.eventually_has_sum\n#align has_fpower_series_at.eventually_has_sum has_fpower_series_at.eventually_has_sum\n\n",
 "eventually_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem has_fpower_series_at.eventually_eq_zero (hf : has_fpower_series_at f (0 : formal_multilinear_series ğ•œ E F) x) :\n    Â«exprâˆ€á¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â»\" ((nhds) x)\n      (f z = 0) :=\n  let âŸ¨r, hrâŸ© := hf\n  hr.eventually_eq_zero\n#align has_fpower_series_at.eventually_eq_zero has_fpower_series_at.eventually_eq_zero\n\n",
 "eventually":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.gt -/\nprotected theorem has_fpower_series_at.eventually (hf : has_fpower_series_at f p x) :\n    Â«exprâˆ€á¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â»\"\n      (nhds_within.gt 0) (has_fpower_series_on_ball f p x r) :=\n  let âŸ¨r, hrâŸ© := hf\n  mem_of_superset (Ioo_mem_nhdsWithin_Ioi (left_mem_Ico.2 hr.r_pos)) fun r' hr' => hr.mono hr'.1 hr'.2.le\n#align has_fpower_series_at.eventually has_fpower_series_at.eventually\n\n",
 "eq_zero_of_eventually":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr =á¶ [ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- A one-dimensional formal multilinear series representing a locally zero function is zero. -/\ntheorem has_fpower_series_at.eq_zero_of_eventually {p : formal_multilinear_series ğ•œ ğ•œ E} {f : ğ•œ â†’ E} {x : ğ•œ}\n    (hp : has_fpower_series_at f p x) (hf : Â«expr =á¶ [ ] Â» f ((nhds) x) 0) : p = 0 :=\n  (hp.congr hf).eq_zero\n#align has_fpower_series_at.eq_zero_of_eventually has_fpower_series_at.eq_zero_of_eventually\n\n",
 "eq_zero":
 "/-- A one-dimensional formal multilinear series representing the zero function is zero. -/\ntheorem has_fpower_series_at.eq_zero {p : formal_multilinear_series ğ•œ ğ•œ E} {x : ğ•œ} (h : has_fpower_series_at 0 p x) :\n    p = 0 := by\n  ext (n x)\n  rw [â† mk_pi_field_apply_one_eq_self (p n)]\n  simp [h.apply_eq_zero n 1]\n#align has_fpower_series_at.eq_zero has_fpower_series_at.eq_zero\n\n",
 "eq_formal_multilinear_series_of_eventually":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem has_fpower_series_at.eq_formal_multilinear_series_of_eventually {p q : formal_multilinear_series ğ•œ ğ•œ E}\n    {f g : ğ•œ â†’ E} {x : ğ•œ} (hp : has_fpower_series_at f p x) (hq : has_fpower_series_at g q x)\n    (heq :\n      Â«exprâˆ€á¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â»\" ((nhds) x)\n        (f z = g z)) :\n    p = q :=\n  (hp.congr HEq).eq_formal_multilinear_series hq\n#align has_fpower_series_at.eq_formal_multilinear_series_of_eventually has_fpower_series_at.eq_formal_multilinear_series_of_eventually\n\n",
 "eq_formal_multilinear_series":
 "/-- One-dimensional formal multilinear series representing the same function are equal. -/\ntheorem has_fpower_series_at.eq_formal_multilinear_series {pâ‚ pâ‚‚ : formal_multilinear_series ğ•œ ğ•œ E} {f : ğ•œ â†’ E} {x : ğ•œ}\n    (hâ‚ : has_fpower_series_at f pâ‚ x) (hâ‚‚ : has_fpower_series_at f pâ‚‚ x) : pâ‚ = pâ‚‚ :=\n  sub_eq_zero.mp (has_fpower_series_at.eq_zero (by simpa only [sub_self] using hâ‚.sub hâ‚‚))\n#align has_fpower_series_at.eq_formal_multilinear_series has_fpower_series_at.eq_formal_multilinear_series\n\n",
 "continuous_on":
 "/-- The sum of a converging power series is continuous in its disk of convergence. -/\nprotected theorem formal_multilinear_series.continuous_on [CompleteSpace F] :\n    ContinuousOn p.sum (EMetric.ball 0 p.radius) :=\n  by\n  cases' (zero_le p.radius).eq_or_lt with h h\n  Â· simp [â† h, continuousOn_empty]\n  Â· exact (p.has_fpower_series_on_ball h).continuous_on\n#align formal_multilinear_series.continuous_on formal_multilinear_series.continuous_on\n\n",
 "continuous_multilinear_map_apply_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr [Ã— ]â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr =O[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\ntheorem asymptotics.is_O.continuous_multilinear_map_apply_eq_zero {n : â„•} {p : Â«expr [Ã— ]â†’L[ ] Â» E n ğ•œ F}\n    (h : Â«expr =O[ ] Â» (fun y => p fun i => y) ((nhds) 0) fun y => Â«exprâ€– â€–Â» y ^ (n + 1)) (y : E) :\n    (p fun i => y) = 0 := by\n  obtain âŸ¨c, c_pos, hcâŸ© := h.exists_pos\n  obtain âŸ¨t, ht, t_open, z_memâŸ© := eventually_nhds_iff.mp (is_O_with_iff.mp hc)\n  obtain âŸ¨Î´, Î´_pos, Î´ÎµâŸ© := (metric.is_open_iff.mp t_open) 0 z_mem\n  clear h hc z_mem\n  cases n\n  Â·\n    exact\n      norm_eq_zero.mp\n        (by\n          simpa only [fin0_apply_norm, norm_eq_zero, norm_zero, zero_pow', ne.def, nat.one_ne_zero, not_false_iff,\n            MulZeroClass.mul_zero, norm_le_zero_iff] using ht 0 (Î´Îµ (Metric.mem_ball_self Î´_pos)))\n  Â· refine' or.elim (em (y = 0)) (fun hy => by simpa only [hy] using p.map_zero) fun hy => _\n    replace hy := norm_pos_iff.mpr hy\n    refine' norm_eq_zero.mp (le_antisymm (le_of_forall_pos_le_add fun Îµ Îµ_pos => _) (norm_nonneg _))\n    have hâ‚€ := mul_pos c_pos (pow_pos hy (n.succ + 1))\n    obtain âŸ¨k, k_pos, k_normâŸ© :=\n      NormedField.exists_norm_lt ğ•œ (lt_min (mul_pos Î´_pos (inv_pos.mpr hy)) (mul_pos Îµ_pos (inv_pos.mpr hâ‚€)))\n    have hâ‚ : Â«exprâ€– â€–Â» (Â«expr â€¢ Â» k y) < Î´ := by\n      rw [norm_smul]\n      exact inv_mul_cancel_rightâ‚€ hy.ne.symm Î´ â–¸ mul_lt_mul_of_pos_right (lt_of_lt_of_le k_norm (min_le_left _ _)) hy\n    have hâ‚‚ :=\n      calc\n        Â«exprâ€– â€–Â» (p fun i => Â«expr â€¢ Â» k y) â‰¤ c * Â«exprâ€– â€–Â» (Â«expr â€¢ Â» k y) ^ (n.succ + 1) := by\n          simpa only [norm_pow, norm_norm] using ht (Â«expr â€¢ Â» k y) (Î´Îµ (mem_ball_zero_iff.mpr hâ‚))\n        _ = Â«exprâ€– â€–Â» k ^ n.succ * (Â«exprâ€– â€–Â» k * (c * Â«exprâ€– â€–Â» y ^ (n.succ + 1))) :=\n          by\n          simp only [norm_smul, mul_pow]\n          rw [pow_succ]\n          ring\n        \n    have hâ‚ƒ : Â«exprâ€– â€–Â» k * (c * Â«exprâ€– â€–Â» y ^ (n.succ + 1)) < Îµ :=\n      inv_mul_cancel_rightâ‚€ hâ‚€.ne.symm Îµ â–¸ mul_lt_mul_of_pos_right (lt_of_lt_of_le k_norm (min_le_right _ _)) hâ‚€\n    calc\n      Â«exprâ€– â€–Â» (p fun i => y) = Â«exprâ€– â€–Â» (kâ»Â¹ ^ n.succ) * Â«exprâ€– â€–Â» (p fun i => Â«expr â€¢ Â» k y) := by\n        simpa only [inv_smul_smulâ‚€ (norm_pos_iff.mp k_pos), norm_smul, Finset.prod_const, Finset.card_fin] using\n          congr_arg norm (p.map_smul_univ (fun i : Fin n.succ => kâ»Â¹) fun i : Fin n.succ => Â«expr â€¢ Â» k y)\n      _ â‰¤ Â«exprâ€– â€–Â» (kâ»Â¹ ^ n.succ) * (Â«exprâ€– â€–Â» k ^ n.succ * (Â«exprâ€– â€–Â» k * (c * Â«exprâ€– â€–Â» y ^ (n.succ + 1)))) :=\n        (mul_le_mul_of_nonneg_left hâ‚‚ (norm_nonneg _))\n      _ = Â«exprâ€– â€–Â» ((kâ»Â¹ * k) ^ n.succ) * (Â«exprâ€– â€–Â» k * (c * Â«exprâ€– â€–Â» y ^ (n.succ + 1))) :=\n        by\n        rw [â† mul_assoc]\n        simp [norm_mul, mul_pow]\n      _ â‰¤ 0 + Îµ := by\n        rw [inv_mul_cancel (norm_pos_iff.mp k_pos)]\n        simpa using hâ‚ƒ.le\n      \n#align asymptotics.is_O.continuous_multilinear_map_apply_eq_zero asymptotics.is_O.continuous_multilinear_map_apply_eq_zero\n\n",
 "continuous_at":
 "protected theorem analytic_at.continuous_at (hf : analytic_at ğ•œ f x) : ContinuousAt f x :=\n  let âŸ¨p, hpâŸ© := hf\n  hp.continuous_at\n#align analytic_at.continuous_at analytic_at.continuous_at\n\n",
 "const_formal_multilinear_series_radius":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\n@[simp]\ntheorem const_formal_multilinear_series_radius {v : F} : (const_formal_multilinear_series ğ•œ E v).radius = Â«exprâŠ¤Â» :=\n  (const_formal_multilinear_series ğ•œ E v).radius_eq_top_of_forall_image_add_eq_zero 1\n    (by simp [const_formal_multilinear_series])\n#align const_formal_multilinear_series_radius const_formal_multilinear_series_radius\n\n",
 "congr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr =á¶ [ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem has_fpower_series_at.congr (hf : has_fpower_series_at f p x) (hg : Â«expr =á¶ [ ] Â» f ((nhds) x) g) :\n    has_fpower_series_at g p x := by\n  rcases hf with âŸ¨râ‚, hâ‚âŸ©\n  rcases emetric.mem_nhds_iff.mp hg with âŸ¨râ‚‚, hâ‚‚pos, hâ‚‚âŸ©\n  exact\n    âŸ¨min râ‚ râ‚‚,\n      (hâ‚.mono (lt_min hâ‚.r_pos hâ‚‚pos) inf_le_left).congr fun y hy => hâ‚‚ (EMetric.ball_subset_ball inf_le_right hy)âŸ©\n#align has_fpower_series_at.congr has_fpower_series_at.congr\n\n",
 "comp_sub":
 "/-- If a function `f` has a power series `p` around `x`, then the function `z â†¦ f (z - y)` has the\nsame power series around `x + y`. -/\ntheorem has_fpower_series_on_ball.comp_sub (hf : has_fpower_series_on_ball f p x r) (y : E) :\n    has_fpower_series_on_ball (fun z => f (z - y)) p (x + y) r :=\n  { r_le := hf.r_le\n    r_pos := hf.r_pos\n    has_sum := fun z hz => by\n      convert hf.has_sum hz\n      abel }\n#align has_fpower_series_on_ball.comp_sub has_fpower_series_on_ball.comp_sub\n\n",
 "comp_has_fpower_series_on_ball":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/-- If a function `f` has a power series `p` on a ball and `g` is linear, then `g âˆ˜ f` has the\npower series `g âˆ˜ p` on the same ball. -/\ntheorem _root_.continuous_linear_map.comp_has_fpower_series_on_ball (g : Â«expr â†’L[ ] Â» F ğ•œ G)\n    (h : has_fpower_series_on_ball f p x r) :\n    has_fpower_series_on_ball (g âˆ˜ f) (g.comp_formal_multilinear_series p) x r :=\n  { r_le := h.r_le.trans (p.radius_le_radius_continuous_linear_map_comp _)\n    r_pos := h.r_pos\n    has_sum := fun y hy => by\n      simpa only [continuous_linear_map.comp_formal_multilinear_series_apply,\n        ContinuousLinearMap.compContinuousMultilinearMap_coe, Function.comp_apply] using g.has_sum (h.has_sum hy) }\n#align continuous_linear_map.comp_has_fpower_series_on_ball continuous_linear_map.comp_has_fpower_series_on_ball\n\n",
 "comp_analytic_on":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/-- If a function `f` is analytic on a set `s` and `g` is linear, then `g âˆ˜ f` is analytic\non `s`. -/\ntheorem _root_.continuous_linear_map.comp_analytic_on {s : Set E} (g : Â«expr â†’L[ ] Â» F ğ•œ G) (h : analytic_on ğ•œ f s) :\n    analytic_on ğ•œ (g âˆ˜ f) s := by\n  rintro x hx\n  rcases h x hx with âŸ¨p, r, hpâŸ©\n  exact âŸ¨g.comp_formal_multilinear_series p, r, g.comp_has_fpower_series_on_ball hpâŸ©\n#align continuous_linear_map.comp_analytic_on continuous_linear_map.comp_analytic_on\n\n",
 "coeff_zero":
 "theorem has_fpower_series_at.coeff_zero (hf : has_fpower_series_at f pf x) (v : Fin 0 â†’ E) : pf 0 v = f x :=\n  let âŸ¨rf, hrfâŸ© := hf\n  hrf.coeff_zero v\n#align has_fpower_series_at.coeff_zero has_fpower_series_at.coeff_zero\n\n",
 "change_origin_series_term_apply":
 "theorem change_origin_series_term_apply (k l : â„•) (s : Finset (Fin (k + l))) (hs : s.card = l) (x y : E) :\n    (p.change_origin_series_term k l s hs (fun _ => x) fun _ => y) = p (k + l) (s.piecewise (fun _ => x) fun _ => y) :=\n  continuous_multilinear_map.curry_fin_finset_apply_const _ _ _ _ _\n#align change_origin_series_term_apply change_origin_series_term_apply\n\n",
 "change_origin_series_summable_auxâ‚ƒ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–â‚ŠÂ» -/\ntheorem change_origin_series_summable_auxâ‚ƒ {r : nnreal} (hr : â†‘r < p.radius) (k : â„•) :\n    Summable fun l : â„• => Â«exprâ€– â€–â‚ŠÂ» (p.change_origin_series k l) * r ^ l :=\n  by\n  refine' NNReal.summable_of_le (fun n => _) (NNReal.summable_sigma.1 <| p.change_origin_series_summable_auxâ‚‚ hr k).2\n  simp only [NNReal.tsum_mul_right]\n  exact mul_le_mul' (p.nnnorm_change_origin_series_le_tsum _ _) le_rfl\n#align change_origin_series_summable_auxâ‚ƒ change_origin_series_summable_auxâ‚ƒ\n\n",
 "change_origin_series_summable_auxâ‚‚":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–â‚ŠÂ» -/\ntheorem change_origin_series_summable_auxâ‚‚ (hr : (r : ennreal) < p.radius) (k : â„•) :\n    Summable fun s : Î£l : â„•, { s : Finset (Fin (k + l)) // s.card = l } => Â«exprâ€– â€–â‚ŠÂ» (p (k + s.1)) * r ^ s.1 :=\n  by\n  rcases ENNReal.lt_iff_exists_add_pos_lt.1 hr with âŸ¨r', h0, hr'âŸ©\n  simpa only [mul_inv_cancel_rightâ‚€ (pow_pos h0 _).ne'] using\n    ((NNReal.summable_sigma.1 (p.change_origin_series_summable_auxâ‚ hr')).1 k).mul_right (r' ^ k)â»Â¹\n#align change_origin_series_summable_auxâ‚‚ change_origin_series_summable_auxâ‚‚\n\n",
 "change_origin_series_summable_auxâ‚":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–â‚ŠÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–â‚ŠÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–â‚ŠÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–â‚ŠÂ» -/\n-- Lean can't automatically generalize `k' = k + l - s.card`, `l' = s.card`, so we explicitly\n-- formulate the generalized goal\ntheorem change_origin_series_summable_auxâ‚ {r r' : nnreal} (hr : (r + r' : ennreal) < p.radius) :\n    Summable fun s : Î£k l : â„•, { s : Finset (Fin (k + l)) // s.card = l } =>\n      Â«exprâ€– â€–â‚ŠÂ» (p (s.1 + s.2.1)) * r ^ s.2.1 * r' ^ s.1 :=\n  by\n  rw [â† change_origin_index_equiv.symm.summable_iff]\n  dsimp only [(Â· âˆ˜ Â·), change_origin_index_equiv_symm_apply_fst, change_origin_index_equiv_symm_apply_snd_fst]\n  have :\n    âˆ€ n : â„•,\n      HasSum (fun s : Finset (Fin n) => Â«exprâ€– â€–â‚ŠÂ» (p (n - s.card + s.card)) * r ^ s.card * r' ^ (n - s.card))\n        (Â«exprâ€– â€–â‚ŠÂ» (p n) * (r + r') ^ n) :=\n    by\n    intro n\n    -- TODO: why `simp only [tsub_add_cancel_of_le (card_finset_fin_le _)]` fails?\n    convert_to HasSum (fun s : Finset (Fin n) => Â«exprâ€– â€–â‚ŠÂ» (p n) * (r ^ s.card * r' ^ (n - s.card))) _\n    Â· ext1 s\n      rw [tsub_add_cancel_of_le (card_finset_fin_le _), mul_assoc]\n    rw [â† Fin.sum_pow_mul_eq_add_pow]\n    exact (hasSum_fintype _).mul_left _\n  refine' NNReal.summable_sigma.2 âŸ¨fun n => (this n).summable, _âŸ©\n  simp only [(this _).tsum_eq]\n  exact p.summable_nnnorm_mul_pow hr\n#align change_origin_series_summable_auxâ‚ change_origin_series_summable_auxâ‚\n\n",
 "change_origin_radius":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–â‚ŠÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–â‚ŠÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ‘' , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ‘' , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–â‚ŠÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–â‚ŠÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–â‚ŠÂ» -/\n/-- The radius of convergence of `p.change_origin x` is at least `p.radius - â€–xâ€–`. In other words,\n`p.change_origin x` is well defined on the largest ball contained in the original ball of\nconvergence.-/\ntheorem change_origin_radius : p.radius - Â«exprâ€– â€–â‚ŠÂ» x â‰¤ (p.change_origin x).radius :=\n  by\n  refine' ENNReal.le_of_forall_pos_nnreal_lt fun r h0 hr => _\n  rw [lt_tsub_iff_right, add_comm] at hr\n  have hr' : (Â«exprâ€– â€–â‚ŠÂ» x : ennreal) < p.radius := (le_add_right le_rfl).trans_lt hr\n  apply le_radius_of_summable_nnnorm\n  have :\n    âˆ€ k : â„•,\n      Â«exprâ€– â€–â‚ŠÂ» (p.change_origin x k) * r ^ k â‰¤\n        Â«exprâˆ‘' , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ‘' , Â»\"\n            (Â«exprâ€– â€–â‚ŠÂ» (p (k + s.1)) * Â«exprâ€– â€–â‚ŠÂ» x ^ s.1) *\n          r ^ k :=\n    fun k => mul_le_mul_right' (p.nnnorm_change_origin_le k hr') (r ^ k)\n  refine' NNReal.summable_of_le this _\n  simpa only [â† NNReal.tsum_mul_right] using (NNReal.summable_sigma.1 (p.change_origin_series_summable_auxâ‚ hr)).2\n#align change_origin_radius change_origin_radius\n\n",
 "change_origin_eval":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–â‚ŠÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–â‚ŠÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/-- Summing the series `p.change_origin x` at a point `y` gives back `p (x + y)`-/\ntheorem change_origin_eval (h : (Â«exprâ€– â€–â‚ŠÂ» x + Â«exprâ€– â€–â‚ŠÂ» y : ennreal) < p.radius) :\n    (p.change_origin x).sum y = p.sum (x + y) :=\n  by\n  have radius_pos : 0 < p.radius := lt_of_le_of_lt (zero_le _) h\n  have x_mem_ball : x âˆˆ EMetric.ball (0 : E) p.radius := mem_emetric_ball_zero_iff.2 ((le_add_right le_rfl).trans_lt h)\n  have y_mem_ball : y âˆˆ EMetric.ball (0 : E) (p.change_origin x).radius :=\n    by\n    refine' mem_emetric_ball_zero_iff.2 (lt_of_lt_of_le _ p.change_origin_radius)\n    rwa [lt_tsub_iff_right, add_comm]\n  have x_add_y_mem_ball : x + y âˆˆ EMetric.ball (0 : E) p.radius :=\n    by\n    refine' mem_emetric_ball_zero_iff.2 (lt_of_le_of_lt _ h)\n    exact_mod_cast nnnorm_add_le x y\n  set f : (Î£k l : â„•, { s : Finset (Fin (k + l)) // s.card = l }) â†’ F := fun s =>\n    p.change_origin_series_term s.1 s.2.1 s.2.2 s.2.2.2 (fun _ => x) fun _ => y\n  have hsf : Summable f :=\n    by\n    refine' summable_of_nnnorm_bounded _ (p.change_origin_series_summable_auxâ‚ h) _\n    rintro âŸ¨k, l, s, hsâŸ©\n    dsimp only [Subtype.coe_mk]\n    exact p.nnnorm_change_origin_series_term_apply_le _ _ _ _ _ _\n  have hf : HasSum f ((p.change_origin x).sum y) :=\n    by\n    refine' HasSum.sigma_of_hasSum ((p.change_origin x).summable y_mem_ball).has_sum (fun k => _) hsf\n    Â· dsimp only [f]\n      refine' continuous_multilinear_map.has_sum_eval _ _\n      have := (p.has_fpower_series_on_ball_change_origin k radius_pos).has_sum x_mem_ball\n      rw [zero_add] at this\n      refine' HasSum.sigma_of_hasSum this (fun l => _) _\n      Â· simp only [change_origin_series, ContinuousMultilinearMap.sum_apply]\n        apply hasSum_fintype\n      Â· refine'\n          summable_of_nnnorm_bounded _ (p.change_origin_series_summable_auxâ‚‚ (mem_emetric_ball_zero_iff.1 x_mem_ball) k)\n            fun s => _\n        refine' (continuous_multilinear_map.le_op_nnnorm _ _).trans_eq _\n        simp\n  refine' hf.unique (change_origin_index_equiv.symm.has_sum_iff.1 _)\n  refine'\n    HasSum.sigma_of_hasSum (p.has_sum x_add_y_mem_ball) (fun n => _) (change_origin_index_equiv.symm.summable_iff.2 hsf)\n  erw [(p n).map_add_univ (fun _ => x) fun _ => y]\n  convert hasSum_fintype _\n  ext1 s\n  dsimp only [f, change_origin_series_term, (Â· âˆ˜ Â·), change_origin_index_equiv_symm_apply_fst,\n    change_origin_index_equiv_symm_apply_snd_fst, change_origin_index_equiv_symm_apply_snd_snd_coe]\n  rw [continuous_multilinear_map.curry_fin_finset_apply_const]\n  have :\n    âˆ€ (m) (hm : n = m),\n      p n (s.piecewise (fun _ => x) fun _ => y) =\n        p m ((s.map (Fin.cast hm).to_equiv.to_embedding).piecewise (fun _ => x) fun _ => y) :=\n    by\n    rintro m rfl\n    simp\n  apply this\n#align change_origin_eval change_origin_eval\n\n",
 "change_origin":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–â‚ŠÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–â‚ŠÂ» -/\n/-- If a function admits a power series expansion `p` on a ball `B (x, r)`, then it also admits a\npower series on any subball of this ball (even with a different center), given by `p.change_origin`.\n-/\ntheorem has_fpower_series_on_ball.change_origin (hf : has_fpower_series_on_ball f p x r)\n    (h : (Â«exprâ€– â€–â‚ŠÂ» y : ennreal) < r) : has_fpower_series_on_ball f (p.change_origin y) (x + y) (r - Â«exprâ€– â€–â‚ŠÂ» y) :=\n  { r_le := by\n      apply le_trans _ p.change_origin_radius\n      exact tsub_le_tsub hf.r_le le_rfl\n    r_pos := by simp [h]\n    has_sum := fun z hz => by\n      convert(p.change_origin y).has_sum _\n      Â· rw [mem_emetric_ball_zero_iff, lt_tsub_iff_right, add_comm] at hz\n        rw [p.change_origin_eval (hz.trans_le hf.r_le), add_assoc, hf.sum]\n        refine' mem_emetric_ball_zero_iff.2 (lt_of_le_of_lt _ hz)\n        exact_mod_cast nnnorm_add_le y z\n      Â· refine' EMetric.ball_subset_ball (le_trans _ p.change_origin_radius) hz\n        exact tsub_le_tsub hf.r_le le_rfl }\n#align has_fpower_series_on_ball.change_origin has_fpower_series_on_ball.change_origin\n\n",
 "apply_eq_zero":
 "/-- If a formal multilinear series `p` represents the zero function at `x : E`, then the\nterms `p n (Î» i, y)` appearing the in sum are zero for any `n : â„•`, `y : E`. -/\ntheorem has_fpower_series_at.apply_eq_zero {p : formal_multilinear_series ğ•œ E F} {x : E}\n    (h : has_fpower_series_at 0 p x) (n : â„•) : âˆ€ y : E, (p n fun i => y) = 0 :=\n  by\n  refine' nat.strong_rec_on n fun k hk => _\n  have psum_eq : p.partial_sum (k + 1) = fun y => p k fun i => y :=\n    by\n    funext z\n    refine' Finset.sum_eq_single _ (fun b hb hnb => _) fun hn => _\n    Â· have := finset.mem_range_succ_iff.mp hb\n      simp only [hk b (this.lt_of_ne hnb), Pi.zero_apply, zero_apply]\n    Â· exact false.elim (hn (finset.mem_range.mpr (lt_add_one k)))\n  replace h := h.is_O_sub_partial_sum_pow k.succ\n  simp only [psum_eq, zero_sub, Pi.zero_apply, Asymptotics.isBigO_neg_left] at h\n  exact h.continuous_multilinear_map_apply_eq_zero\n#align has_fpower_series_at.apply_eq_zero has_fpower_series_at.apply_eq_zero\n\n",
 "analytic_on_const":
 "theorem analytic_on_const {v : F} {s : Set E} : analytic_on ğ•œ (fun _ => v) s := fun z _ => analytic_at_const\n#align analytic_on_const analytic_on_const\n\n",
 "analytic_on":
 "theorem has_fpower_series_on_ball.analytic_on (hf : has_fpower_series_on_ball f p x r) :\n    analytic_on ğ•œ f (EMetric.ball x r) := fun y hy => hf.analytic_at_of_mem hy\n#align has_fpower_series_on_ball.analytic_on has_fpower_series_on_ball.analytic_on\n\n",
 "analytic_at_of_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–â‚ŠÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/-- If a function admits a power series expansion `p` on an open ball `B (x, r)`, then\nit is analytic at every point of this ball. -/\ntheorem has_fpower_series_on_ball.analytic_at_of_mem (hf : has_fpower_series_on_ball f p x r)\n    (h : y âˆˆ EMetric.ball x r) : analytic_at ğ•œ f y :=\n  by\n  have : (Â«exprâ€– â€–â‚ŠÂ» (y - x) : ennreal) < r := by simpa [edist_eq_coe_nnnorm_sub] using h\n  have := hf.change_origin this\n  rw [add_sub_cancel'_right] at this\n  exact this.analytic_at\n#align has_fpower_series_on_ball.analytic_at_of_mem has_fpower_series_on_ball.analytic_at_of_mem\n\n",
 "analytic_at_const":
 "theorem analytic_at_const {v : F} : analytic_at ğ•œ (fun _ => v) x :=\n  âŸ¨const_formal_multilinear_series ğ•œ E v, has_fpower_series_at_constâŸ©\n#align analytic_at_const analytic_at_const\n\n",
 "analytic_at":
 "theorem has_fpower_series_on_ball.analytic_at (hf : has_fpower_series_on_ball f p x r) : analytic_at ğ•œ f x :=\n  hf.has_fpower_series_at.analytic_at\n#align has_fpower_series_on_ball.analytic_at has_fpower_series_on_ball.analytic_at\n\n",
 "add":
 "theorem analytic_on.add {s : Set E} (hf : analytic_on ğ•œ f s) (hg : analytic_on ğ•œ g s) : analytic_on ğ•œ (f + g) s :=\n  fun z hz => (hf z hz).add (hg z hz)\n#align analytic_on.add analytic_on.add\n\n",
 "Summable":
 "#print Summable /-\nprotected theorem Summable [CompleteSpace F] (p : formal_multilinear_series ğ•œ E F) {x : E}\n    (hx : x âˆˆ EMetric.ball (0 : E) p.radius) : Summable fun n : â„• => p n fun _ => x :=\n  summable_of_summable_norm (p.summable_norm_apply hx)\n#align summable Summable\n-/\n\n",
 "HasSum":
 "#print HasSum /-\nprotected theorem HasSum [CompleteSpace F] (p : formal_multilinear_series ğ•œ E F) {x : E}\n    (hx : x âˆˆ EMetric.ball (0 : E) p.radius) : HasSum (fun n : â„• => p n fun _ => x) (p.sum x) :=\n  (p.summable hx).has_sum\n#align has_sum HasSum\n-/\n\n"}