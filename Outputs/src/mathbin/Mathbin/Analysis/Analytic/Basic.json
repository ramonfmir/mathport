{"uniform_geometric_approx'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/-- If a function admits a power series expansion, then it is exponentially close to the partial\nsums of this power series on strict subdisks of the disk of convergence.\n\nThis version provides an upper estimate that decreases both in `‖y‖` and `n`. See also\n`has_fpower_series_on_ball.uniform_geometric_approx` for a weaker version. -/\ntheorem has_fpower_series_on_ball.uniform_geometric_approx' {r' : nnreal} (hf : has_fpower_series_on_ball f p x r)\n    (h : (r' : ennreal) < r) :\n    ∃ a ∈ Ioo (0 : exprℝ) 1,\n      ∃ C > 0,\n        ∀ y ∈ Metric.ball (0 : E) r',\n          ∀ n, «expr‖ ‖» (f (x + y) - p.partial_sum n y) ≤ C * (a * («expr‖ ‖» y / r')) ^ n :=\n  by\n  obtain ⟨a, ha, C, hC, hp⟩ : ∃ a ∈ Ioo (0 : exprℝ) 1, ∃ C > 0, ∀ n, «expr‖ ‖» (p n) * r' ^ n ≤ C * a ^ n :=\n    p.norm_mul_pow_le_mul_pow_of_lt_radius (h.trans_le hf.r_le)\n  refine' ⟨a, ha, C / (1 - a), div_pos hC (sub_pos.2 ha.2), fun y hy n => _⟩\n  have yr' : «expr‖ ‖» y < r' := by\n    rw [ball_zero_eq] at hy\n    exact hy\n  have hr'0 : 0 < (r' : exprℝ) := (norm_nonneg _).trans_lt yr'\n  have : y ∈ EMetric.ball (0 : E) r :=\n    by\n    refine' mem_emetric_ball_zero_iff.2 (lt_trans _ h)\n    exact_mod_cast yr'\n  rw [norm_sub_rev, ← mul_div_right_comm]\n  have ya : a * («expr‖ ‖» y / ↑r') ≤ a := mul_le_of_le_one_right ha.1.le (div_le_one_of_le yr'.le r'.coe_nonneg)\n  suffices «expr‖ ‖» (p.partial_sum n y - f (x + y)) ≤ C * (a * («expr‖ ‖» y / r')) ^ n / (1 - a * («expr‖ ‖» y / r'))\n    by\n    refine' this.trans _\n    apply_rules [div_le_div_of_le_left, sub_pos.2, div_nonneg, mul_nonneg, pow_nonneg, hC.lt.le, ha.1.le, norm_nonneg,\n        NNReal.coe_nonneg, ha.2, (sub_le_sub_iff_left _).2] <;>\n      infer_instance\n  apply norm_sub_le_of_geometric_bound_of_hasSum (ya.trans_lt ha.2) _ (hf.has_sum this)\n  intro n\n  calc\n    «expr‖ ‖» ((p n) fun i : Fin n => y) ≤\n        «expr‖ ‖» (p n) *\n          finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n            («expr‖ ‖» y) :=\n      continuous_multilinear_map.le_op_norm _ _\n    _ = «expr‖ ‖» (p n) * r' ^ n * («expr‖ ‖» y / r') ^ n := by field_simp [hr'0.ne', mul_right_comm]\n    _ ≤ C * a ^ n * («expr‖ ‖» y / r') ^ n :=\n      (mul_le_mul_of_nonneg_right (hp n) (pow_nonneg (div_nonneg (norm_nonneg _) r'.coe_nonneg) _))\n    _ ≤ C * (a * («expr‖ ‖» y / r')) ^ n := by rw [mul_pow, mul_assoc]\n    \n#align has_fpower_series_on_ball.uniform_geometric_approx' has_fpower_series_on_ball.uniform_geometric_approx'\n\n",
 "uniform_geometric_approx":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/-- If a function admits a power series expansion, then it is exponentially close to the partial\nsums of this power series on strict subdisks of the disk of convergence. -/\ntheorem has_fpower_series_on_ball.uniform_geometric_approx {r' : nnreal} (hf : has_fpower_series_on_ball f p x r)\n    (h : (r' : ennreal) < r) :\n    ∃ a ∈ Ioo (0 : exprℝ) 1,\n      ∃ C > 0, ∀ y ∈ Metric.ball (0 : E) r', ∀ n, «expr‖ ‖» (f (x + y) - p.partial_sum n y) ≤ C * a ^ n :=\n  by\n  obtain ⟨a, ha, C, hC, hp⟩ :\n    ∃ a ∈ Ioo (0 : exprℝ) 1,\n      ∃ C > 0,\n        ∀ y ∈ Metric.ball (0 : E) r', ∀ n, «expr‖ ‖» (f (x + y) - p.partial_sum n y) ≤ C * (a * («expr‖ ‖» y / r')) ^ n\n  exact hf.uniform_geometric_approx' h\n  refine' ⟨a, ha, C, hC, fun y hy n => (hp y hy n).trans _⟩\n  have yr' : «expr‖ ‖» y < r' := by rwa [ball_zero_eq] at hy\n  refine' mul_le_mul_of_nonneg_left (pow_le_pow_of_le_left _ _ _) hC.lt.le\n  exacts[mul_nonneg ha.1.le (div_nonneg (norm_nonneg y) r'.coe_nonneg),\n    mul_le_of_le_one_right ha.1.le (div_le_one_of_le yr'.le r'.coe_nonneg)]\n#align has_fpower_series_on_ball.uniform_geometric_approx has_fpower_series_on_ball.uniform_geometric_approx\n\n",
 "tendsto_uniformly_on'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/-- If a function admits a power series expansion at `x`, then it is the uniform limit of the\npartial sums of this power series on strict subdisks of the disk of convergence, i.e., `f y`\nis the uniform limit of `p.partial_sum n (y - x)` there. -/\ntheorem has_fpower_series_on_ball.tendsto_uniformly_on' {r' : nnreal} (hf : has_fpower_series_on_ball f p x r)\n    (h : (r' : ennreal) < r) :\n    TendstoUniformlyOn (fun n y => p.partial_sum n (y - x)) f atTop (Metric.ball (x : E) r') :=\n  by\n  convert(hf.tendsto_uniformly_on h).comp fun y => y - x\n  · simp [(· ∘ ·)]\n  · ext z\n    simp [dist_eq_norm]\n#align has_fpower_series_on_ball.tendsto_uniformly_on' has_fpower_series_on_ball.tendsto_uniformly_on'\n\n",
 "tendsto_uniformly_on":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/-- If a function admits a power series expansion at `x`, then it is the uniform limit of the\npartial sums of this power series on strict subdisks of the disk of convergence, i.e., `f (x + y)`\nis the uniform limit of `p.partial_sum n y` there. -/\ntheorem has_fpower_series_on_ball.tendsto_uniformly_on {r' : nnreal} (hf : has_fpower_series_on_ball f p x r)\n    (h : (r' : ennreal) < r) :\n    TendstoUniformlyOn (fun n y => p.partial_sum n y) (fun y => f (x + y)) atTop (Metric.ball (0 : E) r') :=\n  by\n  obtain ⟨a, ha, C, hC, hp⟩ :\n    ∃ a ∈ Ioo (0 : exprℝ) 1,\n      ∃ C > 0, ∀ y ∈ Metric.ball (0 : E) r', ∀ n, «expr‖ ‖» (f (x + y) - p.partial_sum n y) ≤ C * a ^ n\n  exact hf.uniform_geometric_approx h\n  refine' Metric.tendstoUniformlyOn_iff.2 fun ε εpos => _\n  have L : tendsto (fun n => (C : exprℝ) * a ^ n) at_top ((nhds) ((C : exprℝ) * 0)) :=\n    tendsto_const_nhds.mul (tendsto_pow_atTop_nhds_0_of_lt_1 ha.1.le ha.2)\n  rw [MulZeroClass.mul_zero] at L\n  refine' (L.eventually (gt_mem_nhds εpos)).mono fun n hn y hy => _\n  rw [dist_eq_norm]\n  exact (hp y hy n).trans_lt hn\n#align has_fpower_series_on_ball.tendsto_uniformly_on has_fpower_series_on_ball.tendsto_uniformly_on\n\n",
 "tendsto_locally_uniformly_on'":
 "/-- If a function admits a power series expansion at `x`, then it is the locally uniform limit of\nthe  partial sums of this power series on the disk of convergence, i.e., `f y`\nis the locally uniform limit of `p.partial_sum n (y - x)` there. -/\ntheorem has_fpower_series_on_ball.tendsto_locally_uniformly_on' (hf : has_fpower_series_on_ball f p x r) :\n    TendstoLocallyUniformlyOn (fun n y => p.partial_sum n (y - x)) f atTop (EMetric.ball (x : E) r) :=\n  by\n  have A : ContinuousOn (fun y : E => y - x) (EMetric.ball (x : E) r) :=\n    (continuous_id.sub continuous_const).continuous_on\n  convert hf.tendsto_locally_uniformly_on.comp (fun y : E => y - x) _ A\n  · ext z\n    simp\n  · intro z\n    simp [edist_eq_coe_nnnorm, edist_eq_coe_nnnorm_sub]\n#align has_fpower_series_on_ball.tendsto_locally_uniformly_on' has_fpower_series_on_ball.tendsto_locally_uniformly_on'\n\n",
 "tendsto_locally_uniformly_on":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- If a function admits a power series expansion at `x`, then it is the locally uniform limit of\nthe partial sums of this power series on the disk of convergence, i.e., `f (x + y)`\nis the locally uniform limit of `p.partial_sum n y` there. -/\ntheorem has_fpower_series_on_ball.tendsto_locally_uniformly_on (hf : has_fpower_series_on_ball f p x r) :\n    TendstoLocallyUniformlyOn (fun n y => p.partial_sum n y) (fun y => f (x + y)) atTop (EMetric.ball (0 : E) r) :=\n  by\n  intro u hu x hx\n  rcases ENNReal.lt_iff_exists_nnreal_btwn.1 hx with ⟨r', xr', hr'⟩\n  have : EMetric.ball (0 : E) r' ∈ (nhds) x := IsOpen.mem_nhds EMetric.isOpen_ball xr'\n  refine' ⟨EMetric.ball (0 : E) r', mem_nhdsWithin_of_mem_nhds this, _⟩\n  simpa [Metric.emetric_ball_nnreal] using hf.tendsto_uniformly_on hr' u hu\n#align has_fpower_series_on_ball.tendsto_locally_uniformly_on has_fpower_series_on_ball.tendsto_locally_uniformly_on\n\n",
 "summable_norm_mul_pow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem summable_norm_mul_pow (p : formal_multilinear_series 𝕜 E F) {r : nnreal} (h : ↑r < p.radius) :\n    Summable fun n : ℕ => «expr‖ ‖» (p n) * r ^ n :=\n  by\n  obtain ⟨a, ha : a ∈ Ioo (0 : exprℝ) 1, C, hC : 0 < C, hp⟩ := p.norm_mul_pow_le_mul_pow_of_lt_radius h\n  exact\n    summable_of_nonneg_of_le (fun n => mul_nonneg (norm_nonneg _) (pow_nonneg r.coe_nonneg _)) hp\n      ((summable_geometric_of_lt_1 ha.1.le ha.2).mul_left _)\n#align summable_norm_mul_pow summable_norm_mul_pow\n\n",
 "summable_norm_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem summable_norm_apply (p : formal_multilinear_series 𝕜 E F) {x : E} (hx : x ∈ EMetric.ball (0 : E) p.radius) :\n    Summable fun n : ℕ => «expr‖ ‖» (p n fun _ => x) :=\n  by\n  rw [mem_emetric_ball_zero_iff] at hx\n  refine'\n    summable_of_nonneg_of_le (fun _ => norm_nonneg _) (fun n => ((p n).le_op_norm _).trans_eq _)\n      (p.summable_norm_mul_pow hx)\n  simp\n#align summable_norm_apply summable_norm_apply\n\n",
 "summable_nnnorm_mul_pow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\ntheorem summable_nnnorm_mul_pow (p : formal_multilinear_series 𝕜 E F) {r : nnreal} (h : ↑r < p.radius) :\n    Summable fun n : ℕ => «expr‖ ‖₊» (p n) * r ^ n :=\n  by\n  rw [← NNReal.summable_coe]\n  push_cast\n  exact p.summable_norm_mul_pow h\n#align summable_nnnorm_mul_pow summable_nnnorm_mul_pow\n\n",
 "sum":
 "theorem has_fpower_series_on_ball.sum (h : has_fpower_series_on_ball f p x r) {y : E}\n    (hy : y ∈ EMetric.ball (0 : E) r) : f (x + y) = p.sum y :=\n  (h.has_sum hy).tsum_eq.symm\n#align has_fpower_series_on_ball.sum has_fpower_series_on_ball.sum\n\n",
 "sub":
 "theorem analytic_on.sub {s : Set E} (hf : analytic_on 𝕜 f s) (hg : analytic_on 𝕜 g s) : analytic_on 𝕜 (f - g) s :=\n  fun z hz => (hf z hz).sub (hg z hz)\n#align analytic_on.sub analytic_on.sub\n\n",
 "radius_pos":
 "theorem has_fpower_series_at.radius_pos (hf : has_fpower_series_at f p x) : 0 < p.radius :=\n  let ⟨r, hr⟩ := hf\n  hr.radius_pos\n#align has_fpower_series_at.radius_pos has_fpower_series_at.radius_pos\n\n",
 "radius_neg":
 "@[simp]\ntheorem radius_neg (p : formal_multilinear_series 𝕜 E F) : (-p).radius = p.radius := by simp [radius]\n#align radius_neg radius_neg\n\n",
 "radius_le_radius_continuous_linear_map_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\ntheorem radius_le_radius_continuous_linear_map_comp (p : formal_multilinear_series 𝕜 E F) (f : «expr →L[ ] » F 𝕜 G) :\n    p.radius ≤ (f.comp_formal_multilinear_series p).radius :=\n  by\n  refine' ENNReal.le_of_forall_nnreal_lt fun r hr => _\n  apply le_radius_of_is_O\n  apply (is_O.trans_is_o _ (p.is_o_one_of_lt_radius hr)).is_O\n  refine' is_O.mul (@is_O_with.is_O _ _ _ _ _ («expr‖ ‖» f) _ _ _ _) (is_O_refl _ _)\n  apply is_O_with.of_bound (eventually_of_forall fun n => _)\n  simpa only [norm_norm] using f.norm_comp_continuous_multilinear_map_le (p n)\n#align radius_le_radius_continuous_linear_map_comp radius_le_radius_continuous_linear_map_comp\n\n",
 "radius_eq_top_of_summable_norm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\ntheorem radius_eq_top_of_summable_norm (p : formal_multilinear_series 𝕜 E F)\n    (hs : ∀ r : nnreal, Summable fun n => «expr‖ ‖» (p n) * r ^ n) : p.radius = ennreal.top :=\n  ENNReal.eq_top_of_forall_nnreal_le fun r => p.le_radius_of_summable_norm (hs r)\n#align radius_eq_top_of_summable_norm radius_eq_top_of_summable_norm\n\n",
 "radius_eq_top_of_forall_nnreal_is_O":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =O[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\ntheorem radius_eq_top_of_forall_nnreal_is_O\n    (h : ∀ r : nnreal, «expr =O[ ] » (fun n => «expr‖ ‖» (p n) * r ^ n) atTop fun n => (1 : exprℝ)) :\n    p.radius = ennreal.top :=\n  ENNReal.eq_top_of_forall_nnreal_le fun r => p.le_radius_of_is_O (h r)\n#align radius_eq_top_of_forall_nnreal_is_O radius_eq_top_of_forall_nnreal_is_O\n\n",
 "radius_eq_top_of_forall_image_add_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\ntheorem radius_eq_top_of_forall_image_add_eq_zero (n : ℕ) (hn : ∀ m, p (m + n) = 0) : p.radius = ennreal.top :=\n  p.radius_eq_top_of_eventually_eq_zero <| mem_atTop_sets.2 ⟨n, fun k hk => tsub_add_cancel_of_le hk ▸ hn _⟩\n#align radius_eq_top_of_forall_image_add_eq_zero radius_eq_top_of_forall_image_add_eq_zero\n\n",
 "radius_eq_top_of_eventually_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\ntheorem radius_eq_top_of_eventually_eq_zero\n    (h :\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" atTop\n        (p n = 0)) :\n    p.radius = ennreal.top :=\n  p.radius_eq_top_of_forall_nnreal_is_O fun r =>\n    (isBigO_zero _ _).congr' (h.mono fun n hn => by simp [hn]) EventuallyEq.rfl\n#align radius_eq_top_of_eventually_eq_zero radius_eq_top_of_eventually_eq_zero\n\n",
 "radius_eq_top_iff_summable_norm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem radius_eq_top_iff_summable_norm (p : formal_multilinear_series 𝕜 E F) :\n    p.radius = ennreal.top ↔ ∀ r : nnreal, Summable fun n => «expr‖ ‖» (p n) * r ^ n :=\n  by\n  constructor\n  · intro h r\n    obtain ⟨a, ha : a ∈ Ioo (0 : exprℝ) 1, C, hC : 0 < C, hp⟩ :=\n      p.norm_mul_pow_le_mul_pow_of_lt_radius (show (r : ennreal) < p.radius from h.symm ▸ ENNReal.coe_lt_top)\n    refine'\n      summable_of_norm_bounded (fun n => (C : exprℝ) * a ^ n) ((summable_geometric_of_lt_1 ha.1.le ha.2).mul_left _)\n        fun n => _\n    specialize hp n\n    rwa [Real.norm_of_nonneg (mul_nonneg (norm_nonneg _) (pow_nonneg r.coe_nonneg n))]\n  · exact p.radius_eq_top_of_summable_norm\n#align radius_eq_top_iff_summable_norm radius_eq_top_iff_summable_norm\n\n",
 "r_eq_top_of_exists":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/-- If a function `f : 𝕜 → E` has power series representation `p` on a ball of some radius and for\neach positive radius it has some power series representation, then `p` converges to `f` on the whole\n`𝕜`. -/\ntheorem has_fpower_series_on_ball.r_eq_top_of_exists {f : 𝕜 → E} {r : ennreal} {x : 𝕜}\n    {p : formal_multilinear_series 𝕜 𝕜 E} (h : has_fpower_series_on_ball f p x r)\n    (h' : ∀ (r' : nnreal) (hr : 0 < r'), ∃ p' : formal_multilinear_series 𝕜 𝕜 E, has_fpower_series_on_ball f p' x r') :\n    has_fpower_series_on_ball f p x (ennreal.top) :=\n  { r_le :=\n      ENNReal.le_of_forall_pos_nnreal_lt fun r hr hr' =>\n        let ⟨p', hp'⟩ := h' r hr\n        (h.exchange_radius hp').r_le\n    r_pos := ENNReal.coe_lt_top\n    has_sum := fun y hy =>\n      let ⟨r', hr'⟩ := exists_gt («expr‖ ‖₊» y)\n      let ⟨p', hp'⟩ := h' r' hr'.ne_bot.bot_lt\n      (h.exchange_radius hp').has_sum <| mem_emetric_ball_zero_iff.mpr (ENNReal.coe_lt_coe.2 hr') }\n#align has_fpower_series_on_ball.r_eq_top_of_exists has_fpower_series_on_ball.r_eq_top_of_exists\n\n",
 "partial_sum_continuous":
 "/-\nCopyright (c) 2020 Sébastien Gouëzel. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Sébastien Gouëzel, Yury Kudryashov\n-/\n/-- The partial sums of a formal multilinear series are continuous. -/\ntheorem partial_sum_continuous (p : formal_multilinear_series 𝕜 E F) (n : ℕ) : Continuous (p.partial_sum n) := by\n  continuity\n#align partial_sum_continuous partial_sum_continuous\n\n",
 "not_summable_norm_of_radius_lt_nnnorm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem not_summable_norm_of_radius_lt_nnnorm (p : formal_multilinear_series 𝕜 E F) {x : E}\n    (h : p.radius < «expr‖ ‖₊» x) : ¬Summable fun n => «expr‖ ‖» (p n) * «expr‖ ‖» x ^ n := fun hs =>\n  not_le_of_lt h (p.le_radius_of_summable_norm hs)\n#align not_summable_norm_of_radius_lt_nnnorm not_summable_norm_of_radius_lt_nnnorm\n\n",
 "norm_mul_pow_le_of_lt_radius":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/-- For `r` strictly smaller than the radius of `p`, then `‖pₙ‖ rⁿ` is bounded. -/\ntheorem norm_mul_pow_le_of_lt_radius (p : formal_multilinear_series 𝕜 E F) {r : nnreal} (h : (r : ennreal) < p.radius) :\n    ∃ C > 0, ∀ n, «expr‖ ‖» (p n) * r ^ n ≤ C :=\n  let ⟨a, ha, C, hC, h⟩ := p.norm_mul_pow_le_mul_pow_of_lt_radius h\n  ⟨C, hC, fun n => (h n).trans <| mul_le_of_le_one_right hC.lt.le (pow_le_one _ ha.1.le ha.2.le)⟩\n#align norm_mul_pow_le_of_lt_radius norm_mul_pow_le_of_lt_radius\n\n",
 "norm_mul_pow_le_mul_pow_of_lt_radius":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/-- For `r` strictly smaller than the radius of `p`, then `‖pₙ‖ rⁿ` tends to zero exponentially:\nfor some `0 < a < 1` and `C > 0`,  `‖p n‖ * r ^ n ≤ C * a ^ n`. -/\ntheorem norm_mul_pow_le_mul_pow_of_lt_radius (h : ↑r < p.radius) :\n    ∃ a ∈ Ioo (0 : exprℝ) 1, ∃ C > 0, ∀ n, «expr‖ ‖» (p n) * r ^ n ≤ C * a ^ n :=\n  by\n  rcases((TFAE_exists_lt_isLittleO_pow (fun n => «expr‖ ‖» (p n) * r ^ n) 1).out 1 5).mp (p.is_o_of_lt_radius h) with\n    ⟨a, ha, C, hC, H⟩\n  exact ⟨a, ha, C, hC, fun n => (le_abs_self _).trans (H n)⟩\n#align norm_mul_pow_le_mul_pow_of_lt_radius norm_mul_pow_le_mul_pow_of_lt_radius\n\n",
 "norm_le_div_pow_of_pos_of_lt_radius":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/-- For `r` strictly smaller than the radius of `p`, then `‖pₙ‖ rⁿ` is bounded. -/\ntheorem norm_le_div_pow_of_pos_of_lt_radius (p : formal_multilinear_series 𝕜 E F) {r : nnreal} (h0 : 0 < r)\n    (h : (r : ennreal) < p.radius) : ∃ C > 0, ∀ n, «expr‖ ‖» (p n) ≤ C / r ^ n :=\n  let ⟨C, hC, hp⟩ := p.norm_mul_pow_le_of_lt_radius h\n  ⟨C, hC, fun n => Iff.mpr (le_div_iff (pow_pos h0 _)) (hp n)⟩\n#align norm_le_div_pow_of_pos_of_lt_radius norm_le_div_pow_of_pos_of_lt_radius\n\n",
 "norm_change_origin_series_term":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n@[simp]\ntheorem norm_change_origin_series_term (k l : ℕ) (s : Finset (Fin (k + l))) (hs : s.card = l) :\n    «expr‖ ‖» (p.change_origin_series_term k l s hs) = «expr‖ ‖» (p (k + l)) := by\n  simp only [change_origin_series_term, LinearIsometryEquiv.norm_map]\n#align norm_change_origin_series_term norm_change_origin_series_term\n\n",
 "nnnorm_mul_pow_le_of_lt_radius":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/-- For `r` strictly smaller than the radius of `p`, then `‖pₙ‖ rⁿ` is bounded. -/\ntheorem nnnorm_mul_pow_le_of_lt_radius (p : formal_multilinear_series 𝕜 E F) {r : nnreal}\n    (h : (r : ennreal) < p.radius) : ∃ C > 0, ∀ n, «expr‖ ‖₊» (p n) * r ^ n ≤ C :=\n  let ⟨C, hC, hp⟩ := p.norm_mul_pow_le_of_lt_radius h\n  ⟨⟨C, hC.lt.le⟩, hC, by exact_mod_cast hp⟩\n#align nnnorm_mul_pow_le_of_lt_radius nnnorm_mul_pow_le_of_lt_radius\n\n",
 "nnnorm_change_origin_series_term_apply_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\ntheorem nnnorm_change_origin_series_term_apply_le (k l : ℕ) (s : Finset (Fin (k + l))) (hs : s.card = l) (x y : E) :\n    «expr‖ ‖₊» (p.change_origin_series_term k l s hs (fun _ => x) fun _ => y) ≤\n      «expr‖ ‖₊» (p (k + l)) * «expr‖ ‖₊» x ^ l * «expr‖ ‖₊» y ^ k :=\n  by\n  rw [← p.nnnorm_change_origin_series_term k l s hs, ← Fin.prod_const, ← Fin.prod_const]\n  apply continuous_multilinear_map.le_of_op_nnnorm_le\n  apply continuous_multilinear_map.le_op_nnnorm\n#align nnnorm_change_origin_series_term_apply_le nnnorm_change_origin_series_term_apply_le\n\n",
 "nnnorm_change_origin_series_term":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n@[simp]\ntheorem nnnorm_change_origin_series_term (k l : ℕ) (s : Finset (Fin (k + l))) (hs : s.card = l) :\n    «expr‖ ‖₊» (p.change_origin_series_term k l s hs) = «expr‖ ‖₊» (p (k + l)) := by\n  simp only [change_origin_series_term, LinearIsometryEquiv.nnnorm_map]\n#align nnnorm_change_origin_series_term nnnorm_change_origin_series_term\n\n",
 "nnnorm_change_origin_series_le_tsum":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\ntheorem nnnorm_change_origin_series_le_tsum (k l : ℕ) :\n    «expr‖ ‖₊» (p.change_origin_series k l) ≤\n      «expr∑' , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , »\"\n        («expr‖ ‖₊» (p (k + l))) :=\n  (nnnorm_sum_le _ _).trans_eq <| by simp only [tsum_fintype, nnnorm_change_origin_series_term]\n#align nnnorm_change_origin_series_le_tsum nnnorm_change_origin_series_le_tsum\n\n",
 "nnnorm_change_origin_series_apply_le_tsum":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\ntheorem nnnorm_change_origin_series_apply_le_tsum (k l : ℕ) (x : E) :\n    «expr‖ ‖₊» (p.change_origin_series k l fun _ => x) ≤\n      «expr∑' , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , »\"\n        («expr‖ ‖₊» (p (k + l)) * «expr‖ ‖₊» x ^ l) :=\n  by\n  rw [NNReal.tsum_mul_right, ← Fin.prod_const]\n  exact (p.change_origin_series k l).le_of_op_nnnorm_le _ (p.nnnorm_change_origin_series_le_tsum _ _)\n#align nnnorm_change_origin_series_apply_le_tsum nnnorm_change_origin_series_apply_le_tsum\n\n",
 "nnnorm_change_origin_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\ntheorem nnnorm_change_origin_le (k : ℕ) (h : («expr‖ ‖₊» x : ennreal) < p.radius) :\n    «expr‖ ‖₊» (p.change_origin x k) ≤\n      «expr∑' , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , »\"\n        («expr‖ ‖₊» (p (k + s.1)) * «expr‖ ‖₊» x ^ s.1) :=\n  by\n  refine' tsum_of_nnnorm_bounded _ fun l => p.nnnorm_change_origin_series_apply_le_tsum k l x\n  have := p.change_origin_series_summable_aux₂ h k\n  refine' HasSum.sigma this.has_sum fun l => _\n  exact ((NNReal.summable_sigma.1 this).1 l).has_sum\n#align nnnorm_change_origin_le nnnorm_change_origin_le\n\n",
 "neg":
 "theorem analytic_at.neg (hf : analytic_at 𝕜 f x) : analytic_at 𝕜 (-f) x :=\n  let ⟨pf, hpf⟩ := hf\n  hpf.neg.analytic_at\n#align analytic_at.neg analytic_at.neg\n\n",
 "mono":
 "theorem analytic_on.mono {s t : Set E} (hf : analytic_on 𝕜 f t) (hst : s ⊆ t) : analytic_on 𝕜 f s := fun z hz =>\n  hf z (hst hz)\n#align analytic_on.mono analytic_on.mono\n\n",
 "min_radius_le_radius_add":
 "/-- The radius of the sum of two formal series is at least the minimum of their two radii. -/\ntheorem min_radius_le_radius_add (p q : formal_multilinear_series 𝕜 E F) : min p.radius q.radius ≤ (p + q).radius :=\n  by\n  refine' ENNReal.le_of_forall_nnreal_lt fun r hr => _\n  rw [lt_min_iff] at hr\n  have := ((p.is_o_one_of_lt_radius hr.1).add (q.is_o_one_of_lt_radius hr.2)).is_O\n  refine' (p + q).le_radius_of_is_O ((is_O_of_le _ fun n => _).trans this)\n  rw [← add_mul, norm_mul, norm_mul, norm_norm]\n  exact mul_le_mul_of_nonneg_right ((norm_add_le _ _).trans (le_abs_self _)) (norm_nonneg _)\n#align min_radius_le_radius_add min_radius_le_radius_add\n\n",
 "lt_radius_of_is_O":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =O[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/-- If `r ≠ 0` and `‖pₙ‖ rⁿ = O(aⁿ)` for some `-1 < a < 1`, then `r < p.radius`. -/\ntheorem lt_radius_of_is_O (h₀ : r ≠ 0) {a : exprℝ} (ha : a ∈ Ioo (-1 : exprℝ) 1)\n    (hp : «expr =O[ ] » (fun n => «expr‖ ‖» (p n) * r ^ n) atTop (pow a)) : ↑r < p.radius :=\n  by\n  rcases((TFAE_exists_lt_isLittleO_pow (fun n => «expr‖ ‖» (p n) * r ^ n) 1).out 2 5).mp ⟨a, ha, hp⟩ with\n    ⟨a, ha, C, hC, hp⟩\n  rw [← pos_iff_ne_zero, ← NNReal.coe_pos] at h₀\n  lift a to nnreal using ha.1.le\n  have : (r : exprℝ) < r / a := by simpa only [div_one] using (div_lt_div_left h₀ zero_lt_one ha.1).2 ha.2\n  norm_cast  at this\n  rw [← ENNReal.coe_lt_coe] at this\n  refine' this.trans_le (p.le_radius_of_bound C fun n => _)\n  rw [NNReal.coe_div, div_pow, ← mul_div_assoc, div_le_iff (pow_pos ha.1 n)]\n  exact (le_abs_self _).trans (hp n)\n#align lt_radius_of_is_O lt_radius_of_is_O\n\n",
 "le_radius_of_tendsto":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem le_radius_of_tendsto (p : formal_multilinear_series 𝕜 E F) {l : exprℝ}\n    (h : Tendsto (fun n => «expr‖ ‖» (p n) * r ^ n) atTop ((nhds) l)) : ↑r ≤ p.radius :=\n  p.le_radius_of_is_O (h.is_O_one _)\n#align le_radius_of_tendsto le_radius_of_tendsto\n\n",
 "le_radius_of_summable_norm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem le_radius_of_summable_norm (p : formal_multilinear_series 𝕜 E F)\n    (hs : Summable fun n => «expr‖ ‖» (p n) * r ^ n) : ↑r ≤ p.radius :=\n  p.le_radius_of_tendsto hs.tendsto_at_top_zero\n#align le_radius_of_summable_norm le_radius_of_summable_norm\n\n",
 "le_radius_of_summable_nnnorm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\ntheorem le_radius_of_summable_nnnorm (h : Summable fun n => «expr‖ ‖₊» (p n) * r ^ n) : ↑r ≤ p.radius :=\n  p.le_radius_of_bound_nnreal\n    («expr∑' , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , »\"\n      («expr‖ ‖₊» (p n) * r ^ n))\n    fun n => le_tsum' h _\n#align le_radius_of_summable_nnnorm le_radius_of_summable_nnnorm\n\n",
 "le_radius_of_summable":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem le_radius_of_summable (h : Summable fun n => «expr‖ ‖» (p n) * r ^ n) : ↑r ≤ p.radius :=\n  p.le_radius_of_summable_nnnorm <| by\n    simp only [← coe_nnnorm] at h\n    exact_mod_cast h\n#align le_radius_of_summable le_radius_of_summable\n\n",
 "le_radius_of_is_O":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =O[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- If `‖pₙ‖ rⁿ = O(1)`, as `n → ∞`, then the radius of `p` is at least `r`. -/\ntheorem le_radius_of_is_O (h : «expr =O[ ] » (fun n => «expr‖ ‖» (p n) * r ^ n) atTop fun n => (1 : exprℝ)) :\n    ↑r ≤ p.radius :=\n  exists.elim (isBigO_one_nat_atTop_iff.1 h) fun C hC => p.le_radius_of_bound C fun n => (le_abs_self _).trans (hC n)\n#align le_radius_of_is_O le_radius_of_is_O\n\n",
 "le_radius_of_eventually_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem le_radius_of_eventually_le (C)\n    (h :\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" atTop\n        («expr‖ ‖» (p n) * r ^ n ≤ C)) :\n    ↑r ≤ p.radius :=\n  p.le_radius_of_is_O <| IsBigO.of_bound C <| h.mono fun n hn => by simpa\n#align le_radius_of_eventually_le le_radius_of_eventually_le\n\n",
 "le_radius_of_bound_nnreal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/-- If `‖pₙ‖ rⁿ` is bounded in `n`, then the radius of `p` is at least `r`. -/\ntheorem le_radius_of_bound_nnreal (C : nnreal) {r : nnreal} (h : ∀ n : ℕ, «expr‖ ‖₊» (p n) * r ^ n ≤ C) :\n    (r : ennreal) ≤ p.radius :=\n  p.le_radius_of_bound C fun n => by exact_mod_cast h n\n#align le_radius_of_bound_nnreal le_radius_of_bound_nnreal\n\n",
 "le_radius_of_bound":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/-- If `‖pₙ‖ rⁿ` is bounded in `n`, then the radius of `p` is at least `r`. -/\ntheorem le_radius_of_bound (C : exprℝ) {r : nnreal} (h : ∀ n : ℕ, «expr‖ ‖» (p n) * r ^ n ≤ C) :\n    (r : ennreal) ≤ p.radius :=\n  le_supᵢ_of_le r <| le_supᵢ_of_le C <| le_supᵢ (fun _ => (r : ennreal)) h\n#align le_radius_of_bound le_radius_of_bound\n\n",
 "le_mul_pow_of_radius_pos":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/-- If the radius of `p` is positive, then `‖pₙ‖` grows at most geometrically. -/\ntheorem le_mul_pow_of_radius_pos (p : formal_multilinear_series 𝕜 E F) (h : 0 < p.radius) :\n    ∃ (C r : _)(hC : 0 < C)(hr : 0 < r), ∀ n, «expr‖ ‖» (p n) ≤ C * r ^ n :=\n  by\n  rcases ENNReal.lt_iff_exists_nnreal_btwn.1 h with ⟨r, r0, rlt⟩\n  have rpos : 0 < (r : exprℝ) := by simp [ENNReal.coe_pos.1 r0]\n  rcases norm_le_div_pow_of_pos_of_lt_radius p rpos rlt with ⟨C, Cpos, hCp⟩\n  refine' ⟨C, r⁻¹, Cpos, by simp [rpos], fun n => _⟩\n  convert hCp n\n  exact inv_pow _ _\n#align le_mul_pow_of_radius_pos le_mul_pow_of_radius_pos\n\n",
 "le_change_origin_series_radius":
 "theorem le_change_origin_series_radius (k : ℕ) : p.radius ≤ (p.change_origin_series k).radius :=\n  ENNReal.le_of_forall_nnreal_lt fun r hr => le_radius_of_summable_nnnorm _ (p.change_origin_series_summable_aux₃ hr k)\n#align le_change_origin_series_radius le_change_origin_series_radius\n\n",
 "is_open_analytic_at":
 "/-- For any function `f` from a normed vector space to a Banach space, the set of points `x` such\nthat `f` is analytic at `x` is open. -/\ntheorem is_open_analytic_at : IsOpen { x | analytic_at 𝕜 f x } :=\n  by\n  rw [isOpen_iff_mem_nhds]\n  rintro x ⟨p, r, hr⟩\n  exact mem_of_superset (EMetric.ball_mem_nhds _ hr.r_pos) fun y hy => hr.analytic_at_of_mem hy\n#align is_open_analytic_at is_open_analytic_at\n\n",
 "is_o_one_of_lt_radius":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =o[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- For `r` strictly smaller than the radius of `p`, then `‖pₙ‖ rⁿ = o(1)`. -/\ntheorem is_o_one_of_lt_radius (h : ↑r < p.radius) :\n    «expr =o[ ] » (fun n => «expr‖ ‖» (p n) * r ^ n) atTop (fun _ => 1 : ℕ → exprℝ) :=\n  let ⟨a, ha, hp⟩ := p.is_o_of_lt_radius h\n  hp.trans <| (isLittleO_pow_pow_of_lt_left ha.1.le ha.2).congr (fun n => rfl) one_pow\n#align is_o_one_of_lt_radius is_o_one_of_lt_radius\n\n",
 "is_o_of_lt_radius":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =o[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/-- For `r` strictly smaller than the radius of `p`, then `‖pₙ‖ rⁿ` tends to zero exponentially:\nfor some `0 < a < 1`, `‖p n‖ rⁿ = o(aⁿ)`. -/\ntheorem is_o_of_lt_radius (h : ↑r < p.radius) :\n    ∃ a ∈ Ioo (0 : exprℝ) 1, «expr =o[ ] » (fun n => «expr‖ ‖» (p n) * r ^ n) atTop (pow a) :=\n  by\n  rw [(TFAE_exists_lt_isLittleO_pow (fun n => «expr‖ ‖» (p n) * r ^ n) 1).out 1 4]\n  simp only [radius, lt_supᵢ_iff] at h\n  rcases h with ⟨t, C, hC, rt⟩\n  rw [ENNReal.coe_lt_coe, ← NNReal.coe_lt_coe] at rt\n  have : 0 < (t : exprℝ) := r.coe_nonneg.trans_lt rt\n  rw [← div_lt_one this] at rt\n  refine' ⟨_, rt, C, or.inr zero_lt_one, fun n => _⟩\n  calc\n    |«expr‖ ‖» (p n) * r ^ n| = «expr‖ ‖» (p n) * t ^ n * (r / t) ^ n := by\n      field_simp [mul_right_comm, abs_mul, this.ne']\n    _ ≤ C * (r / t) ^ n := mul_le_mul_of_nonneg_right (hC n) (pow_nonneg (div_nonneg r.2 t.2) _)\n    \n#align is_o_of_lt_radius is_o_of_lt_radius\n\n",
 "is_O_sub_partial_sum_pow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =O[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/-- Taylor formula for an analytic function, `is_O` version. -/\ntheorem has_fpower_series_at.is_O_sub_partial_sum_pow (hf : has_fpower_series_at f p x) (n : ℕ) :\n    «expr =O[ ] » (fun y : E => f (x + y) - p.partial_sum n y) ((nhds) 0) fun y => «expr‖ ‖» y ^ n :=\n  by\n  rcases hf with ⟨r, hf⟩\n  rcases ENNReal.lt_iff_exists_nnreal_btwn.1 hf.r_pos with ⟨r', r'0, h⟩\n  obtain ⟨a, ha, C, hC, hp⟩ :\n    ∃ a ∈ Ioo (0 : exprℝ) 1,\n      ∃ C > 0,\n        ∀ y ∈ Metric.ball (0 : E) r', ∀ n, «expr‖ ‖» (f (x + y) - p.partial_sum n y) ≤ C * (a * («expr‖ ‖» y / r')) ^ n\n  exact hf.uniform_geometric_approx' h\n  refine' is_O_iff.2 ⟨C * (a / r') ^ n, _⟩\n  replace r'0 : 0 < (r' : exprℝ); · exact_mod_cast r'0\n  filter_upwards [Metric.ball_mem_nhds (0 : E) r'0]with y hy\n  simpa [mul_pow, mul_div_assoc, mul_assoc, div_mul_eq_mul_div] using hp y hy n\n#align has_fpower_series_at.is_O_sub_partial_sum_pow has_fpower_series_at.is_O_sub_partial_sum_pow\n\n",
 "is_O_image_sub_norm_mul_norm_sub":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =O[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/-- If `f` has formal power series `∑ n, pₙ` at `x`, then\n`f y - f z - p 1 (λ _, y - z) = O(‖(y, z) - (x, x)‖ * ‖y - z‖)` as `(y, z) → (x, x)`.\nIn particular, `f` is strictly differentiable at `x`. -/\ntheorem has_fpower_series_at.is_O_image_sub_norm_mul_norm_sub (hf : has_fpower_series_at f p x) :\n    «expr =O[ ] » (fun y : E × E => f y.1 - f y.2 - p 1 fun _ => y.1 - y.2) ((nhds) (x, x)) fun y =>\n      «expr‖ ‖» (y - (x, x)) * «expr‖ ‖» (y.1 - y.2) :=\n  by\n  rcases hf with ⟨r, hf⟩\n  rcases ENNReal.lt_iff_exists_nnreal_btwn.1 hf.r_pos with ⟨r', r'0, h⟩\n  refine' (hf.is_O_image_sub_image_sub_deriv_principal h).mono _\n  exact le_principal_iff.2 (EMetric.ball_mem_nhds _ r'0)\n#align has_fpower_series_at.is_O_image_sub_norm_mul_norm_sub has_fpower_series_at.is_O_image_sub_norm_mul_norm_sub\n\n",
 "is_O_image_sub_image_sub_deriv_principal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =O[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =O[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/-- If `f` has formal power series `∑ n, pₙ` on a ball of radius `r`, then for `y, z` in any smaller\nball, the norm of the difference `f y - f z - p 1 (λ _, y - z)` is bounded above by\n`C * (max ‖y - x‖ ‖z - x‖) * ‖y - z‖`. This lemma formulates this property using `is_O` and\n`filter.principal` on `E × E`. -/\ntheorem has_fpower_series_on_ball.is_O_image_sub_image_sub_deriv_principal (hf : has_fpower_series_on_ball f p x r)\n    (hr : r' < r) :\n    «expr =O[ ] » (fun y : E × E => f y.1 - f y.2 - p 1 fun _ => y.1 - y.2)\n      ((filter.principal) (EMetric.ball (x, x) r')) fun y => «expr‖ ‖» (y - (x, x)) * «expr‖ ‖» (y.1 - y.2) :=\n  by\n  lift r' to nnreal using ne_top_of_lt hr\n  rcases(zero_le r').eq_or_lt with (rfl | hr'0)\n  · simp only [is_O_bot, EMetric.ball_zero, principal_empty, ENNReal.coe_zero]\n  obtain ⟨a, ha, C, hC : 0 < C, hp⟩ : ∃ a ∈ Ioo (0 : exprℝ) 1, ∃ C > 0, ∀ n : ℕ, «expr‖ ‖» (p n) * ↑r' ^ n ≤ C * a ^ n\n  exact p.norm_mul_pow_le_mul_pow_of_lt_radius (hr.trans_le hf.r_le)\n  simp only [← le_div_iff (pow_pos (NNReal.coe_pos.2 hr'0) _)] at hp\n  set L : E × E → exprℝ := fun y =>\n    C * (a / r') ^ 2 * («expr‖ ‖» (y - (x, x)) * «expr‖ ‖» (y.1 - y.2)) * (a / (1 - a) ^ 2 + 2 / (1 - a))\n  have hL : ∀ y ∈ EMetric.ball (x, x) r', «expr‖ ‖» (f y.1 - f y.2 - p 1 fun _ => y.1 - y.2) ≤ L y :=\n    by\n    intro y hy'\n    have hy : y ∈ lower_set.prod (EMetric.ball x r) (EMetric.ball x r) :=\n      by\n      rw [EMetric.ball_prod_same]\n      exact EMetric.ball_subset_ball hr.le hy'\n    set A : ℕ → F := fun n => (p n fun _ => y.1 - x) - p n fun _ => y.2 - x\n    have hA : HasSum (fun n => A (n + 2)) (f y.1 - f y.2 - p 1 fun _ => y.1 - y.2) :=\n      by\n      convert(hasSum_nat_add_iff' 2).2 ((hf.has_sum_sub hy.1).sub (hf.has_sum_sub hy.2)) using 1\n      rw [Finset.sum_range_succ, Finset.sum_range_one, hf.coeff_zero, hf.coeff_zero, sub_self, zero_add, ←\n        Subsingleton.pi_single_eq (0 : Fin 1) (y.1 - x), Pi.single, ← Subsingleton.pi_single_eq (0 : Fin 1) (y.2 - x),\n        Pi.single, ← (p 1).map_sub, ← Pi.single, Subsingleton.pi_single_eq, sub_sub_sub_cancel_right]\n    rw [EMetric.mem_ball, edist_eq_coe_nnnorm_sub, ENNReal.coe_lt_coe] at hy'\n    set B : ℕ → exprℝ := fun n =>\n      C * (a / r') ^ 2 * («expr‖ ‖» (y - (x, x)) * «expr‖ ‖» (y.1 - y.2)) * ((n + 2) * a ^ n)\n    have hAB : ∀ n, «expr‖ ‖» (A (n + 2)) ≤ B n := fun n =>\n      calc\n        «expr‖ ‖» (A (n + 2)) ≤\n            «expr‖ ‖» (p (n + 2)) * ↑(n + 2) * «expr‖ ‖» (y - (x, x)) ^ (n + 1) * «expr‖ ‖» (y.1 - y.2) :=\n          by\n          simpa only [Fintype.card_fin, pi_norm_const (_ : E), Prod.norm_def, Pi.sub_def, Prod.fst_sub, Prod.snd_sub,\n            sub_sub_sub_cancel_right] using (p <| n + 2).norm_image_sub_le (fun _ => y.1 - x) fun _ => y.2 - x\n        _ =\n            «expr‖ ‖» (p (n + 2)) * «expr‖ ‖» (y - (x, x)) ^ n *\n              (↑(n + 2) * «expr‖ ‖» (y - (x, x)) * «expr‖ ‖» (y.1 - y.2)) :=\n          by\n          rw [pow_succ («expr‖ ‖» (y - (x, x)))]\n          ring\n        _ ≤ C * a ^ (n + 2) / r' ^ (n + 2) * r' ^ n * (↑(n + 2) * «expr‖ ‖» (y - (x, x)) * «expr‖ ‖» (y.1 - y.2)) := by\n          apply_rules [mul_le_mul_of_nonneg_right, mul_le_mul, hp, pow_le_pow_of_le_left, hy'.le, norm_nonneg,\n            pow_nonneg, div_nonneg, mul_nonneg, Nat.cast_nonneg, hC.le, r'.coe_nonneg, ha.1.le]\n        _ = B n := by\n          field_simp [B, pow_succ, hr'0.ne']\n          simp only [mul_assoc, mul_comm, mul_left_comm]\n        \n    have hBL : HasSum B (L y) := by\n      apply HasSum.mul_left\n      simp only [add_mul]\n      have : «expr‖ ‖» a < 1 := by simp only [Real.norm_eq_abs, abs_of_pos ha.1, ha.2]\n      convert(hasSum_coe_mul_geometric_of_norm_lt_1 this).add ((hasSum_geometric_of_norm_lt_1 this).mul_left 2)\n    exact hA.norm_le_of_bounded hBL hAB\n  suffices\n    «expr =O[ ] » L ((filter.principal) (EMetric.ball (x, x) r')) fun y =>\n      «expr‖ ‖» (y - (x, x)) * «expr‖ ‖» (y.1 - y.2)\n    by\n    refine' (is_O.of_bound 1 (eventually_principal.2 fun y hy => _)).trans this\n    rw [one_mul]\n    exact (hL y hy).trans (le_abs_self _)\n  simp_rw [L, mul_right_comm _ (_ * _)]\n  exact (is_O_refl _ _).const_mul_left _\n#align has_fpower_series_on_ball.is_O_image_sub_image_sub_deriv_principal has_fpower_series_on_ball.is_O_image_sub_image_sub_deriv_principal\n\n",
 "image_sub_sub_deriv_le":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (y z «expr ∈ » emetric.ball[emetric.ball] x r') -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/-- If `f` has formal power series `∑ n, pₙ` on a ball of radius `r`, then for `y, z` in any smaller\nball, the norm of the difference `f y - f z - p 1 (λ _, y - z)` is bounded above by\n`C * (max ‖y - x‖ ‖z - x‖) * ‖y - z‖`. -/\ntheorem has_fpower_series_on_ball.image_sub_sub_deriv_le (hf : has_fpower_series_on_ball f p x r) (hr : r' < r) :\n    ∃ C,\n      ∀ (y) (_ : y ∈ EMetric.ball x r') (z) (_ : z ∈ EMetric.ball x r'),\n        «expr‖ ‖» (f y - f z - p 1 fun _ => y - z) ≤\n          C * max («expr‖ ‖» (y - x)) («expr‖ ‖» (z - x)) * «expr‖ ‖» (y - z) :=\n  by\n  simpa only [is_O_principal, mul_assoc, norm_mul, norm_norm, Prod.forall, EMetric.mem_ball, Prod.edist_eq, max_lt_iff,\n    and_imp, @forall_swap (_ < _) E] using hf.is_O_image_sub_image_sub_deriv_principal hr\n#align has_fpower_series_on_ball.image_sub_sub_deriv_le has_fpower_series_on_ball.image_sub_sub_deriv_le\n\n",
 "has_sum_sub":
 "theorem has_fpower_series_on_ball.has_sum_sub (hf : has_fpower_series_on_ball f p x r) {y : E}\n    (hy : y ∈ EMetric.ball x r) : HasSum (fun n : ℕ => p n fun i => y - x) (f y) :=\n  by\n  have : y - x ∈ EMetric.ball (0 : E) r := by simpa [edist_eq_coe_nnnorm_sub] using hy\n  simpa only [add_sub_cancel'_right] using hf.has_sum this\n#align has_fpower_series_on_ball.has_sum_sub has_fpower_series_on_ball.has_sum_sub\n\n",
 "has_fpower_series_on_ball_const":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem has_fpower_series_on_ball_const {c : F} {e : E} :\n    has_fpower_series_on_ball (fun _ => c) (const_formal_multilinear_series 𝕜 E c) e («expr⊤») :=\n  by\n  refine' ⟨by simp, WithTop.zero_lt_top, fun y hy => hasSum_single 0 fun n hn => _⟩\n  simp [const_formal_multilinear_series_apply hn]\n#align has_fpower_series_on_ball_const has_fpower_series_on_ball_const\n\n",
 "has_fpower_series_on_ball_change_origin":
 "-- From this point on, assume that the space is complete, to make sure that series that converge\n-- in norm also converge in `F`.\ntheorem has_fpower_series_on_ball_change_origin (k : ℕ) (hr : 0 < p.radius) :\n    has_fpower_series_on_ball (fun x => p.change_origin x k) (p.change_origin_series k) 0 p.radius :=\n  have := p.le_change_origin_series_radius k\n  ((p.change_origin_series k).has_fpower_series_on_ball (hr.trans_le this)).mono hr this\n#align has_fpower_series_on_ball_change_origin has_fpower_series_on_ball_change_origin\n\n",
 "has_fpower_series_on_ball":
 "/-- In a complete space, the sum of a converging power series `p` admits `p` as a power series.\nThis is not totally obvious as we need to check the convergence of the series. -/\nprotected theorem formal_multilinear_series.has_fpower_series_on_ball [CompleteSpace F]\n    (p : formal_multilinear_series 𝕜 E F) (h : 0 < p.radius) : has_fpower_series_on_ball p.sum p 0 p.radius :=\n  { r_le := le_rfl\n    r_pos := h\n    has_sum := fun y hy => by\n      rw [zero_add]\n      exact p.has_sum hy }\n#align formal_multilinear_series.has_fpower_series_on_ball formal_multilinear_series.has_fpower_series_on_ball\n\n",
 "has_fpower_series_at_iff'":
 "/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:73:14: unsupported tactic `congrm #[[expr «expr∀ᶠ in , »((z), (nhds() 0 : filter 𝕜), has_sum (λ n, _) (f «expr + »(z₀, z)))]] -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem has_fpower_series_at_iff' :\n    has_fpower_series_at f p z₀ ↔\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\"\n        ((nhds) z₀) (HasSum (fun n => «expr • » ((z - z₀) ^ n) (p.coeff n)) (f z)) :=\n  by\n  rw [← map_add_left_nhds_zero, eventually_map, has_fpower_series_at_iff]\n  trace\n    \"./././Mathport/Syntax/Translate/Tactic/Builtin.lean:73:14: unsupported tactic `congrm #[[expr «expr∀ᶠ in , »((z), (nhds() 0 : filter 𝕜), has_sum (λ n, _) (f «expr + »(z₀, z)))]]\"\n  rw [add_sub_cancel']\n#align has_fpower_series_at_iff' has_fpower_series_at_iff'\n\n",
 "has_fpower_series_at_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- A function `f : 𝕜 → E` has `p` as power series expansion at a point `z₀` iff it is the sum of\n`p` in a neighborhood of `z₀`. This makes some proofs easier by hiding the fact that\n`has_fpower_series_at` depends on `p.radius`. -/\ntheorem has_fpower_series_at_iff :\n    has_fpower_series_at f p z₀ ↔\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" ((nhds) 0)\n        (HasSum (fun n => «expr • » (z ^ n) (p.coeff n)) (f (z₀ + z))) :=\n  by\n  refine' ⟨fun ⟨r, r_le, r_pos, h⟩ => eventually_of_mem (EMetric.ball_mem_nhds 0 r_pos) fun _ => by simpa using h, _⟩\n  simp only [Metric.eventually_nhds_iff]\n  rintro ⟨r, r_pos, h⟩\n  refine' ⟨«expr ⊓ » p.radius r.to_nnreal, by simp, _, _⟩\n  · simp only [r_pos.lt, lt_inf_iff, ENNReal.coe_pos, Real.toNNReal_pos, and_true_iff]\n    obtain ⟨z, z_pos, le_z⟩ := NormedField.exists_norm_lt 𝕜 r_pos.lt\n    have : («expr‖ ‖₊» z : ENNReal) ≤ p.radius :=\n      by\n      simp only [dist_zero_right] at h\n      apply formal_multilinear_series.le_radius_of_tendsto\n      convert tendsto_norm.comp (h le_z).summable.tendsto_at_top_zero\n      funext <;> simp [norm_smul, mul_comm]\n    refine' lt_of_lt_of_le _ this\n    simp only [ENNReal.coe_pos]\n    exact zero_lt_iff.mpr (nnnorm_ne_zero_iff.mpr (norm_pos_iff.mp z_pos))\n  · simp only [EMetric.mem_ball, lt_inf_iff, edist_lt_coe, apply_eq_pow_smul_coeff, and_imp, dist_zero_right] at h⊢\n    refine' fun y hyp hyr => h _\n    simpa [nndist_eq_nnnorm, Real.lt_toNNReal_iff_coe_lt] using hyr\n#align has_fpower_series_at_iff has_fpower_series_at_iff\n\n",
 "has_fpower_series_at_const":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem has_fpower_series_at_const {c : F} {e : E} :\n    has_fpower_series_at (fun _ => c) (const_formal_multilinear_series 𝕜 E c) e :=\n  ⟨«expr⊤», has_fpower_series_on_ball_const⟩\n#align has_fpower_series_at_const has_fpower_series_at_const\n\n",
 "has_fpower_series_at":
 "theorem has_fpower_series_on_ball.has_fpower_series_at (hf : has_fpower_series_on_ball f p x r) :\n    has_fpower_series_at f p x :=\n  ⟨r, hf⟩\n#align has_fpower_series_on_ball.has_fpower_series_at has_fpower_series_on_ball.has_fpower_series_at\n\n",
 "exchange_radius":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/-- If a function `f : 𝕜 → E` has two power series representations at `x`, then the given radii in\nwhich convergence is guaranteed may be interchanged. This can be useful when the formal multilinear\nseries in one representation has a particularly nice form, but the other has a larger radius. -/\ntheorem has_fpower_series_on_ball.exchange_radius {p₁ p₂ : formal_multilinear_series 𝕜 𝕜 E} {f : 𝕜 → E}\n    {r₁ r₂ : ennreal} {x : 𝕜} (h₁ : has_fpower_series_on_ball f p₁ x r₁) (h₂ : has_fpower_series_on_ball f p₂ x r₂) :\n    has_fpower_series_on_ball f p₁ x r₂ :=\n  h₂.has_fpower_series_at.eq_formal_multilinear_series h₁.has_fpower_series_at ▸ h₂\n#align has_fpower_series_on_ball.exchange_radius has_fpower_series_on_ball.exchange_radius\n\n",
 "eventually_has_sum_sub":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem has_fpower_series_at.eventually_has_sum_sub (hf : has_fpower_series_at f p x) :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" ((nhds) x)\n      (HasSum (fun n : ℕ => p n fun i : Fin n => y - x) (f y)) :=\n  let ⟨r, hr⟩ := hf\n  hr.eventually_has_sum_sub\n#align has_fpower_series_at.eventually_has_sum_sub has_fpower_series_at.eventually_has_sum_sub\n\n",
 "eventually_has_sum":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem has_fpower_series_at.eventually_has_sum (hf : has_fpower_series_at f p x) :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" ((nhds) 0)\n      (HasSum (fun n : ℕ => p n fun i : Fin n => y) (f (x + y))) :=\n  let ⟨r, hr⟩ := hf\n  hr.eventually_has_sum\n#align has_fpower_series_at.eventually_has_sum has_fpower_series_at.eventually_has_sum\n\n",
 "eventually_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem has_fpower_series_at.eventually_eq_zero (hf : has_fpower_series_at f (0 : formal_multilinear_series 𝕜 E F) x) :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" ((nhds) x)\n      (f z = 0) :=\n  let ⟨r, hr⟩ := hf\n  hr.eventually_eq_zero\n#align has_fpower_series_at.eventually_eq_zero has_fpower_series_at.eventually_eq_zero\n\n",
 "eventually":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.gt -/\nprotected theorem has_fpower_series_at.eventually (hf : has_fpower_series_at f p x) :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\"\n      (nhds_within.gt 0) (has_fpower_series_on_ball f p x r) :=\n  let ⟨r, hr⟩ := hf\n  mem_of_superset (Ioo_mem_nhdsWithin_Ioi (left_mem_Ico.2 hr.r_pos)) fun r' hr' => hr.mono hr'.1 hr'.2.le\n#align has_fpower_series_at.eventually has_fpower_series_at.eventually\n\n",
 "eq_zero_of_eventually":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- A one-dimensional formal multilinear series representing a locally zero function is zero. -/\ntheorem has_fpower_series_at.eq_zero_of_eventually {p : formal_multilinear_series 𝕜 𝕜 E} {f : 𝕜 → E} {x : 𝕜}\n    (hp : has_fpower_series_at f p x) (hf : «expr =ᶠ[ ] » f ((nhds) x) 0) : p = 0 :=\n  (hp.congr hf).eq_zero\n#align has_fpower_series_at.eq_zero_of_eventually has_fpower_series_at.eq_zero_of_eventually\n\n",
 "eq_zero":
 "/-- A one-dimensional formal multilinear series representing the zero function is zero. -/\ntheorem has_fpower_series_at.eq_zero {p : formal_multilinear_series 𝕜 𝕜 E} {x : 𝕜} (h : has_fpower_series_at 0 p x) :\n    p = 0 := by\n  ext (n x)\n  rw [← mk_pi_field_apply_one_eq_self (p n)]\n  simp [h.apply_eq_zero n 1]\n#align has_fpower_series_at.eq_zero has_fpower_series_at.eq_zero\n\n",
 "eq_formal_multilinear_series_of_eventually":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem has_fpower_series_at.eq_formal_multilinear_series_of_eventually {p q : formal_multilinear_series 𝕜 𝕜 E}\n    {f g : 𝕜 → E} {x : 𝕜} (hp : has_fpower_series_at f p x) (hq : has_fpower_series_at g q x)\n    (heq :\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" ((nhds) x)\n        (f z = g z)) :\n    p = q :=\n  (hp.congr HEq).eq_formal_multilinear_series hq\n#align has_fpower_series_at.eq_formal_multilinear_series_of_eventually has_fpower_series_at.eq_formal_multilinear_series_of_eventually\n\n",
 "eq_formal_multilinear_series":
 "/-- One-dimensional formal multilinear series representing the same function are equal. -/\ntheorem has_fpower_series_at.eq_formal_multilinear_series {p₁ p₂ : formal_multilinear_series 𝕜 𝕜 E} {f : 𝕜 → E} {x : 𝕜}\n    (h₁ : has_fpower_series_at f p₁ x) (h₂ : has_fpower_series_at f p₂ x) : p₁ = p₂ :=\n  sub_eq_zero.mp (has_fpower_series_at.eq_zero (by simpa only [sub_self] using h₁.sub h₂))\n#align has_fpower_series_at.eq_formal_multilinear_series has_fpower_series_at.eq_formal_multilinear_series\n\n",
 "continuous_on":
 "/-- The sum of a converging power series is continuous in its disk of convergence. -/\nprotected theorem formal_multilinear_series.continuous_on [CompleteSpace F] :\n    ContinuousOn p.sum (EMetric.ball 0 p.radius) :=\n  by\n  cases' (zero_le p.radius).eq_or_lt with h h\n  · simp [← h, continuousOn_empty]\n  · exact (p.has_fpower_series_on_ball h).continuous_on\n#align formal_multilinear_series.continuous_on formal_multilinear_series.continuous_on\n\n",
 "continuous_multilinear_map_apply_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr [× ]→L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =O[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem asymptotics.is_O.continuous_multilinear_map_apply_eq_zero {n : ℕ} {p : «expr [× ]→L[ ] » E n 𝕜 F}\n    (h : «expr =O[ ] » (fun y => p fun i => y) ((nhds) 0) fun y => «expr‖ ‖» y ^ (n + 1)) (y : E) :\n    (p fun i => y) = 0 := by\n  obtain ⟨c, c_pos, hc⟩ := h.exists_pos\n  obtain ⟨t, ht, t_open, z_mem⟩ := eventually_nhds_iff.mp (is_O_with_iff.mp hc)\n  obtain ⟨δ, δ_pos, δε⟩ := (metric.is_open_iff.mp t_open) 0 z_mem\n  clear h hc z_mem\n  cases n\n  ·\n    exact\n      norm_eq_zero.mp\n        (by\n          simpa only [fin0_apply_norm, norm_eq_zero, norm_zero, zero_pow', ne.def, nat.one_ne_zero, not_false_iff,\n            MulZeroClass.mul_zero, norm_le_zero_iff] using ht 0 (δε (Metric.mem_ball_self δ_pos)))\n  · refine' or.elim (em (y = 0)) (fun hy => by simpa only [hy] using p.map_zero) fun hy => _\n    replace hy := norm_pos_iff.mpr hy\n    refine' norm_eq_zero.mp (le_antisymm (le_of_forall_pos_le_add fun ε ε_pos => _) (norm_nonneg _))\n    have h₀ := mul_pos c_pos (pow_pos hy (n.succ + 1))\n    obtain ⟨k, k_pos, k_norm⟩ :=\n      NormedField.exists_norm_lt 𝕜 (lt_min (mul_pos δ_pos (inv_pos.mpr hy)) (mul_pos ε_pos (inv_pos.mpr h₀)))\n    have h₁ : «expr‖ ‖» («expr • » k y) < δ := by\n      rw [norm_smul]\n      exact inv_mul_cancel_right₀ hy.ne.symm δ ▸ mul_lt_mul_of_pos_right (lt_of_lt_of_le k_norm (min_le_left _ _)) hy\n    have h₂ :=\n      calc\n        «expr‖ ‖» (p fun i => «expr • » k y) ≤ c * «expr‖ ‖» («expr • » k y) ^ (n.succ + 1) := by\n          simpa only [norm_pow, norm_norm] using ht («expr • » k y) (δε (mem_ball_zero_iff.mpr h₁))\n        _ = «expr‖ ‖» k ^ n.succ * («expr‖ ‖» k * (c * «expr‖ ‖» y ^ (n.succ + 1))) :=\n          by\n          simp only [norm_smul, mul_pow]\n          rw [pow_succ]\n          ring\n        \n    have h₃ : «expr‖ ‖» k * (c * «expr‖ ‖» y ^ (n.succ + 1)) < ε :=\n      inv_mul_cancel_right₀ h₀.ne.symm ε ▸ mul_lt_mul_of_pos_right (lt_of_lt_of_le k_norm (min_le_right _ _)) h₀\n    calc\n      «expr‖ ‖» (p fun i => y) = «expr‖ ‖» (k⁻¹ ^ n.succ) * «expr‖ ‖» (p fun i => «expr • » k y) := by\n        simpa only [inv_smul_smul₀ (norm_pos_iff.mp k_pos), norm_smul, Finset.prod_const, Finset.card_fin] using\n          congr_arg norm (p.map_smul_univ (fun i : Fin n.succ => k⁻¹) fun i : Fin n.succ => «expr • » k y)\n      _ ≤ «expr‖ ‖» (k⁻¹ ^ n.succ) * («expr‖ ‖» k ^ n.succ * («expr‖ ‖» k * (c * «expr‖ ‖» y ^ (n.succ + 1)))) :=\n        (mul_le_mul_of_nonneg_left h₂ (norm_nonneg _))\n      _ = «expr‖ ‖» ((k⁻¹ * k) ^ n.succ) * («expr‖ ‖» k * (c * «expr‖ ‖» y ^ (n.succ + 1))) :=\n        by\n        rw [← mul_assoc]\n        simp [norm_mul, mul_pow]\n      _ ≤ 0 + ε := by\n        rw [inv_mul_cancel (norm_pos_iff.mp k_pos)]\n        simpa using h₃.le\n      \n#align asymptotics.is_O.continuous_multilinear_map_apply_eq_zero asymptotics.is_O.continuous_multilinear_map_apply_eq_zero\n\n",
 "continuous_at":
 "protected theorem analytic_at.continuous_at (hf : analytic_at 𝕜 f x) : ContinuousAt f x :=\n  let ⟨p, hp⟩ := hf\n  hp.continuous_at\n#align analytic_at.continuous_at analytic_at.continuous_at\n\n",
 "const_formal_multilinear_series_radius":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem const_formal_multilinear_series_radius {v : F} : (const_formal_multilinear_series 𝕜 E v).radius = «expr⊤» :=\n  (const_formal_multilinear_series 𝕜 E v).radius_eq_top_of_forall_image_add_eq_zero 1\n    (by simp [const_formal_multilinear_series])\n#align const_formal_multilinear_series_radius const_formal_multilinear_series_radius\n\n",
 "congr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem has_fpower_series_at.congr (hf : has_fpower_series_at f p x) (hg : «expr =ᶠ[ ] » f ((nhds) x) g) :\n    has_fpower_series_at g p x := by\n  rcases hf with ⟨r₁, h₁⟩\n  rcases emetric.mem_nhds_iff.mp hg with ⟨r₂, h₂pos, h₂⟩\n  exact\n    ⟨min r₁ r₂,\n      (h₁.mono (lt_min h₁.r_pos h₂pos) inf_le_left).congr fun y hy => h₂ (EMetric.ball_subset_ball inf_le_right hy)⟩\n#align has_fpower_series_at.congr has_fpower_series_at.congr\n\n",
 "comp_sub":
 "/-- If a function `f` has a power series `p` around `x`, then the function `z ↦ f (z - y)` has the\nsame power series around `x + y`. -/\ntheorem has_fpower_series_on_ball.comp_sub (hf : has_fpower_series_on_ball f p x r) (y : E) :\n    has_fpower_series_on_ball (fun z => f (z - y)) p (x + y) r :=\n  { r_le := hf.r_le\n    r_pos := hf.r_pos\n    has_sum := fun z hz => by\n      convert hf.has_sum hz\n      abel }\n#align has_fpower_series_on_ball.comp_sub has_fpower_series_on_ball.comp_sub\n\n",
 "comp_has_fpower_series_on_ball":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/-- If a function `f` has a power series `p` on a ball and `g` is linear, then `g ∘ f` has the\npower series `g ∘ p` on the same ball. -/\ntheorem _root_.continuous_linear_map.comp_has_fpower_series_on_ball (g : «expr →L[ ] » F 𝕜 G)\n    (h : has_fpower_series_on_ball f p x r) :\n    has_fpower_series_on_ball (g ∘ f) (g.comp_formal_multilinear_series p) x r :=\n  { r_le := h.r_le.trans (p.radius_le_radius_continuous_linear_map_comp _)\n    r_pos := h.r_pos\n    has_sum := fun y hy => by\n      simpa only [continuous_linear_map.comp_formal_multilinear_series_apply,\n        ContinuousLinearMap.compContinuousMultilinearMap_coe, Function.comp_apply] using g.has_sum (h.has_sum hy) }\n#align continuous_linear_map.comp_has_fpower_series_on_ball continuous_linear_map.comp_has_fpower_series_on_ball\n\n",
 "comp_analytic_on":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/-- If a function `f` is analytic on a set `s` and `g` is linear, then `g ∘ f` is analytic\non `s`. -/\ntheorem _root_.continuous_linear_map.comp_analytic_on {s : Set E} (g : «expr →L[ ] » F 𝕜 G) (h : analytic_on 𝕜 f s) :\n    analytic_on 𝕜 (g ∘ f) s := by\n  rintro x hx\n  rcases h x hx with ⟨p, r, hp⟩\n  exact ⟨g.comp_formal_multilinear_series p, r, g.comp_has_fpower_series_on_ball hp⟩\n#align continuous_linear_map.comp_analytic_on continuous_linear_map.comp_analytic_on\n\n",
 "coeff_zero":
 "theorem has_fpower_series_at.coeff_zero (hf : has_fpower_series_at f pf x) (v : Fin 0 → E) : pf 0 v = f x :=\n  let ⟨rf, hrf⟩ := hf\n  hrf.coeff_zero v\n#align has_fpower_series_at.coeff_zero has_fpower_series_at.coeff_zero\n\n",
 "change_origin_series_term_apply":
 "theorem change_origin_series_term_apply (k l : ℕ) (s : Finset (Fin (k + l))) (hs : s.card = l) (x y : E) :\n    (p.change_origin_series_term k l s hs (fun _ => x) fun _ => y) = p (k + l) (s.piecewise (fun _ => x) fun _ => y) :=\n  continuous_multilinear_map.curry_fin_finset_apply_const _ _ _ _ _\n#align change_origin_series_term_apply change_origin_series_term_apply\n\n",
 "change_origin_series_summable_aux₃":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\ntheorem change_origin_series_summable_aux₃ {r : nnreal} (hr : ↑r < p.radius) (k : ℕ) :\n    Summable fun l : ℕ => «expr‖ ‖₊» (p.change_origin_series k l) * r ^ l :=\n  by\n  refine' NNReal.summable_of_le (fun n => _) (NNReal.summable_sigma.1 <| p.change_origin_series_summable_aux₂ hr k).2\n  simp only [NNReal.tsum_mul_right]\n  exact mul_le_mul' (p.nnnorm_change_origin_series_le_tsum _ _) le_rfl\n#align change_origin_series_summable_aux₃ change_origin_series_summable_aux₃\n\n",
 "change_origin_series_summable_aux₂":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\ntheorem change_origin_series_summable_aux₂ (hr : (r : ennreal) < p.radius) (k : ℕ) :\n    Summable fun s : Σl : ℕ, { s : Finset (Fin (k + l)) // s.card = l } => «expr‖ ‖₊» (p (k + s.1)) * r ^ s.1 :=\n  by\n  rcases ENNReal.lt_iff_exists_add_pos_lt.1 hr with ⟨r', h0, hr'⟩\n  simpa only [mul_inv_cancel_right₀ (pow_pos h0 _).ne'] using\n    ((NNReal.summable_sigma.1 (p.change_origin_series_summable_aux₁ hr')).1 k).mul_right (r' ^ k)⁻¹\n#align change_origin_series_summable_aux₂ change_origin_series_summable_aux₂\n\n",
 "change_origin_series_summable_aux₁":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n-- Lean can't automatically generalize `k' = k + l - s.card`, `l' = s.card`, so we explicitly\n-- formulate the generalized goal\ntheorem change_origin_series_summable_aux₁ {r r' : nnreal} (hr : (r + r' : ennreal) < p.radius) :\n    Summable fun s : Σk l : ℕ, { s : Finset (Fin (k + l)) // s.card = l } =>\n      «expr‖ ‖₊» (p (s.1 + s.2.1)) * r ^ s.2.1 * r' ^ s.1 :=\n  by\n  rw [← change_origin_index_equiv.symm.summable_iff]\n  dsimp only [(· ∘ ·), change_origin_index_equiv_symm_apply_fst, change_origin_index_equiv_symm_apply_snd_fst]\n  have :\n    ∀ n : ℕ,\n      HasSum (fun s : Finset (Fin n) => «expr‖ ‖₊» (p (n - s.card + s.card)) * r ^ s.card * r' ^ (n - s.card))\n        («expr‖ ‖₊» (p n) * (r + r') ^ n) :=\n    by\n    intro n\n    -- TODO: why `simp only [tsub_add_cancel_of_le (card_finset_fin_le _)]` fails?\n    convert_to HasSum (fun s : Finset (Fin n) => «expr‖ ‖₊» (p n) * (r ^ s.card * r' ^ (n - s.card))) _\n    · ext1 s\n      rw [tsub_add_cancel_of_le (card_finset_fin_le _), mul_assoc]\n    rw [← Fin.sum_pow_mul_eq_add_pow]\n    exact (hasSum_fintype _).mul_left _\n  refine' NNReal.summable_sigma.2 ⟨fun n => (this n).summable, _⟩\n  simp only [(this _).tsum_eq]\n  exact p.summable_nnnorm_mul_pow hr\n#align change_origin_series_summable_aux₁ change_origin_series_summable_aux₁\n\n",
 "change_origin_radius":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/-- The radius of convergence of `p.change_origin x` is at least `p.radius - ‖x‖`. In other words,\n`p.change_origin x` is well defined on the largest ball contained in the original ball of\nconvergence.-/\ntheorem change_origin_radius : p.radius - «expr‖ ‖₊» x ≤ (p.change_origin x).radius :=\n  by\n  refine' ENNReal.le_of_forall_pos_nnreal_lt fun r h0 hr => _\n  rw [lt_tsub_iff_right, add_comm] at hr\n  have hr' : («expr‖ ‖₊» x : ennreal) < p.radius := (le_add_right le_rfl).trans_lt hr\n  apply le_radius_of_summable_nnnorm\n  have :\n    ∀ k : ℕ,\n      «expr‖ ‖₊» (p.change_origin x k) * r ^ k ≤\n        «expr∑' , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , »\"\n            («expr‖ ‖₊» (p (k + s.1)) * «expr‖ ‖₊» x ^ s.1) *\n          r ^ k :=\n    fun k => mul_le_mul_right' (p.nnnorm_change_origin_le k hr') (r ^ k)\n  refine' NNReal.summable_of_le this _\n  simpa only [← NNReal.tsum_mul_right] using (NNReal.summable_sigma.1 (p.change_origin_series_summable_aux₁ hr)).2\n#align change_origin_radius change_origin_radius\n\n",
 "change_origin_eval":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/-- Summing the series `p.change_origin x` at a point `y` gives back `p (x + y)`-/\ntheorem change_origin_eval (h : («expr‖ ‖₊» x + «expr‖ ‖₊» y : ennreal) < p.radius) :\n    (p.change_origin x).sum y = p.sum (x + y) :=\n  by\n  have radius_pos : 0 < p.radius := lt_of_le_of_lt (zero_le _) h\n  have x_mem_ball : x ∈ EMetric.ball (0 : E) p.radius := mem_emetric_ball_zero_iff.2 ((le_add_right le_rfl).trans_lt h)\n  have y_mem_ball : y ∈ EMetric.ball (0 : E) (p.change_origin x).radius :=\n    by\n    refine' mem_emetric_ball_zero_iff.2 (lt_of_lt_of_le _ p.change_origin_radius)\n    rwa [lt_tsub_iff_right, add_comm]\n  have x_add_y_mem_ball : x + y ∈ EMetric.ball (0 : E) p.radius :=\n    by\n    refine' mem_emetric_ball_zero_iff.2 (lt_of_le_of_lt _ h)\n    exact_mod_cast nnnorm_add_le x y\n  set f : (Σk l : ℕ, { s : Finset (Fin (k + l)) // s.card = l }) → F := fun s =>\n    p.change_origin_series_term s.1 s.2.1 s.2.2 s.2.2.2 (fun _ => x) fun _ => y\n  have hsf : Summable f :=\n    by\n    refine' summable_of_nnnorm_bounded _ (p.change_origin_series_summable_aux₁ h) _\n    rintro ⟨k, l, s, hs⟩\n    dsimp only [Subtype.coe_mk]\n    exact p.nnnorm_change_origin_series_term_apply_le _ _ _ _ _ _\n  have hf : HasSum f ((p.change_origin x).sum y) :=\n    by\n    refine' HasSum.sigma_of_hasSum ((p.change_origin x).summable y_mem_ball).has_sum (fun k => _) hsf\n    · dsimp only [f]\n      refine' continuous_multilinear_map.has_sum_eval _ _\n      have := (p.has_fpower_series_on_ball_change_origin k radius_pos).has_sum x_mem_ball\n      rw [zero_add] at this\n      refine' HasSum.sigma_of_hasSum this (fun l => _) _\n      · simp only [change_origin_series, ContinuousMultilinearMap.sum_apply]\n        apply hasSum_fintype\n      · refine'\n          summable_of_nnnorm_bounded _ (p.change_origin_series_summable_aux₂ (mem_emetric_ball_zero_iff.1 x_mem_ball) k)\n            fun s => _\n        refine' (continuous_multilinear_map.le_op_nnnorm _ _).trans_eq _\n        simp\n  refine' hf.unique (change_origin_index_equiv.symm.has_sum_iff.1 _)\n  refine'\n    HasSum.sigma_of_hasSum (p.has_sum x_add_y_mem_ball) (fun n => _) (change_origin_index_equiv.symm.summable_iff.2 hsf)\n  erw [(p n).map_add_univ (fun _ => x) fun _ => y]\n  convert hasSum_fintype _\n  ext1 s\n  dsimp only [f, change_origin_series_term, (· ∘ ·), change_origin_index_equiv_symm_apply_fst,\n    change_origin_index_equiv_symm_apply_snd_fst, change_origin_index_equiv_symm_apply_snd_snd_coe]\n  rw [continuous_multilinear_map.curry_fin_finset_apply_const]\n  have :\n    ∀ (m) (hm : n = m),\n      p n (s.piecewise (fun _ => x) fun _ => y) =\n        p m ((s.map (Fin.cast hm).to_equiv.to_embedding).piecewise (fun _ => x) fun _ => y) :=\n    by\n    rintro m rfl\n    simp\n  apply this\n#align change_origin_eval change_origin_eval\n\n",
 "change_origin":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/-- If a function admits a power series expansion `p` on a ball `B (x, r)`, then it also admits a\npower series on any subball of this ball (even with a different center), given by `p.change_origin`.\n-/\ntheorem has_fpower_series_on_ball.change_origin (hf : has_fpower_series_on_ball f p x r)\n    (h : («expr‖ ‖₊» y : ennreal) < r) : has_fpower_series_on_ball f (p.change_origin y) (x + y) (r - «expr‖ ‖₊» y) :=\n  { r_le := by\n      apply le_trans _ p.change_origin_radius\n      exact tsub_le_tsub hf.r_le le_rfl\n    r_pos := by simp [h]\n    has_sum := fun z hz => by\n      convert(p.change_origin y).has_sum _\n      · rw [mem_emetric_ball_zero_iff, lt_tsub_iff_right, add_comm] at hz\n        rw [p.change_origin_eval (hz.trans_le hf.r_le), add_assoc, hf.sum]\n        refine' mem_emetric_ball_zero_iff.2 (lt_of_le_of_lt _ hz)\n        exact_mod_cast nnnorm_add_le y z\n      · refine' EMetric.ball_subset_ball (le_trans _ p.change_origin_radius) hz\n        exact tsub_le_tsub hf.r_le le_rfl }\n#align has_fpower_series_on_ball.change_origin has_fpower_series_on_ball.change_origin\n\n",
 "apply_eq_zero":
 "/-- If a formal multilinear series `p` represents the zero function at `x : E`, then the\nterms `p n (λ i, y)` appearing the in sum are zero for any `n : ℕ`, `y : E`. -/\ntheorem has_fpower_series_at.apply_eq_zero {p : formal_multilinear_series 𝕜 E F} {x : E}\n    (h : has_fpower_series_at 0 p x) (n : ℕ) : ∀ y : E, (p n fun i => y) = 0 :=\n  by\n  refine' nat.strong_rec_on n fun k hk => _\n  have psum_eq : p.partial_sum (k + 1) = fun y => p k fun i => y :=\n    by\n    funext z\n    refine' Finset.sum_eq_single _ (fun b hb hnb => _) fun hn => _\n    · have := finset.mem_range_succ_iff.mp hb\n      simp only [hk b (this.lt_of_ne hnb), Pi.zero_apply, zero_apply]\n    · exact false.elim (hn (finset.mem_range.mpr (lt_add_one k)))\n  replace h := h.is_O_sub_partial_sum_pow k.succ\n  simp only [psum_eq, zero_sub, Pi.zero_apply, Asymptotics.isBigO_neg_left] at h\n  exact h.continuous_multilinear_map_apply_eq_zero\n#align has_fpower_series_at.apply_eq_zero has_fpower_series_at.apply_eq_zero\n\n",
 "analytic_on_const":
 "theorem analytic_on_const {v : F} {s : Set E} : analytic_on 𝕜 (fun _ => v) s := fun z _ => analytic_at_const\n#align analytic_on_const analytic_on_const\n\n",
 "analytic_on":
 "theorem has_fpower_series_on_ball.analytic_on (hf : has_fpower_series_on_ball f p x r) :\n    analytic_on 𝕜 f (EMetric.ball x r) := fun y hy => hf.analytic_at_of_mem hy\n#align has_fpower_series_on_ball.analytic_on has_fpower_series_on_ball.analytic_on\n\n",
 "analytic_at_of_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/-- If a function admits a power series expansion `p` on an open ball `B (x, r)`, then\nit is analytic at every point of this ball. -/\ntheorem has_fpower_series_on_ball.analytic_at_of_mem (hf : has_fpower_series_on_ball f p x r)\n    (h : y ∈ EMetric.ball x r) : analytic_at 𝕜 f y :=\n  by\n  have : («expr‖ ‖₊» (y - x) : ennreal) < r := by simpa [edist_eq_coe_nnnorm_sub] using h\n  have := hf.change_origin this\n  rw [add_sub_cancel'_right] at this\n  exact this.analytic_at\n#align has_fpower_series_on_ball.analytic_at_of_mem has_fpower_series_on_ball.analytic_at_of_mem\n\n",
 "analytic_at_const":
 "theorem analytic_at_const {v : F} : analytic_at 𝕜 (fun _ => v) x :=\n  ⟨const_formal_multilinear_series 𝕜 E v, has_fpower_series_at_const⟩\n#align analytic_at_const analytic_at_const\n\n",
 "analytic_at":
 "theorem has_fpower_series_on_ball.analytic_at (hf : has_fpower_series_on_ball f p x r) : analytic_at 𝕜 f x :=\n  hf.has_fpower_series_at.analytic_at\n#align has_fpower_series_on_ball.analytic_at has_fpower_series_on_ball.analytic_at\n\n",
 "add":
 "theorem analytic_on.add {s : Set E} (hf : analytic_on 𝕜 f s) (hg : analytic_on 𝕜 g s) : analytic_on 𝕜 (f + g) s :=\n  fun z hz => (hf z hz).add (hg z hz)\n#align analytic_on.add analytic_on.add\n\n",
 "Summable":
 "#print Summable /-\nprotected theorem Summable [CompleteSpace F] (p : formal_multilinear_series 𝕜 E F) {x : E}\n    (hx : x ∈ EMetric.ball (0 : E) p.radius) : Summable fun n : ℕ => p n fun _ => x :=\n  summable_of_summable_norm (p.summable_norm_apply hx)\n#align summable Summable\n-/\n\n",
 "HasSum":
 "#print HasSum /-\nprotected theorem HasSum [CompleteSpace F] (p : formal_multilinear_series 𝕜 E F) {x : E}\n    (hx : x ∈ EMetric.ball (0 : E) p.radius) : HasSum (fun n : ℕ => p n fun _ => x) (p.sum x) :=\n  (p.summable hx).has_sum\n#align has_sum HasSum\n-/\n\n"}