{"right_inv_remove_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰ƒL[ ] Â» -/\n/-- The right inverse does not depend on the zeroth coefficient of a formal multilinear\nseries. -/\ntheorem right_inv_remove_zero (p : formal_multilinear_series ğ•œ E F) (i : Â«expr â‰ƒL[ ] Â» E ğ•œ F) :\n    p.remove_zero.right_inv i = p.right_inv i := by\n  ext1 n\n  induction' n using Nat.strongRec' with n IH\n  rcases n with (_ | _ | n)\n  Â· simp only [right_inv_coeff_zero]\n  Â· simp only [right_inv_coeff_one]\n  simp only [right_inv, neg_inj]\n  rw [remove_zero_comp_of_pos _ _ (add_pos_of_nonneg_of_pos n.zero_le zero_lt_two)]\n  congr 2 with k\n  by_cases hk : k < n + 2 <;> simp [hk, IH]\n#align right_inv_remove_zero right_inv_remove_zero\n\n",
 "right_inv_coeff_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰ƒL[ ] Â» -/\n@[simp]\ntheorem right_inv_coeff_zero (p : formal_multilinear_series ğ•œ E F) (i : Â«expr â‰ƒL[ ] Â» E ğ•œ F) : p.right_inv i 0 = 0 := by\n  rw [right_inv]\n#align right_inv_coeff_zero right_inv_coeff_zero\n\n",
 "right_inv_coeff_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰ƒL[ ] Â» -/\n@[simp]\ntheorem right_inv_coeff_one (p : formal_multilinear_series ğ•œ E F) (i : Â«expr â‰ƒL[ ] Â» E ğ•œ F) :\n    p.right_inv i 1 = (continuous_multilinear_curry_fin1 ğ•œ F E).symm i.symm := by rw [right_inv]\n#align right_inv_coeff_one right_inv_coeff_one\n\n",
 "right_inv_coeff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰ƒL[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem right_inv_coeff (p : formal_multilinear_series ğ•œ E F) (i : Â«expr â‰ƒL[ ] Â» E ğ•œ F) (n : â„•) (hn : 2 â‰¤ n) :\n    p.right_inv i n =\n      -(i.symm : Â«expr â†’L[ ] Â» F ğ•œ E).comp_continuous_multilinear_map\n          (finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n            ({ c | 1 < Composition.length c }.to_finset : Finset (Composition n))\n            (p.comp_along_composition (p.right_inv i) c)) :=\n  by\n  cases n\n  Â· exact false.elim (zero_lt_two.not_le hn)\n  cases n\n  Â· exact false.elim (one_lt_two.not_le hn)\n  simp only [right_inv, neg_inj]\n  congr 1\n  ext v\n  have N : 0 < n + 2 := by decide\n  have : ((p 1) fun i : Fin 1 => 0) = 0 := ContinuousMultilinearMap.map_zero _\n  simp [comp_right_inv_aux1 N, lt_irrefl n, this, comp_right_inv_aux2, -Set.toFinset_setOf]\n#align right_inv_coeff right_inv_coeff\n\n",
 "radius_right_inv_pos_of_radius_pos_aux2":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰ƒL[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/-- Second technical lemma to control the growth of coefficients of the inverse. Bound the explicit\nexpression for `âˆ‘_{k<n+1} aáµ Qâ‚–` in terms of a sum of powers of the same sum one step before,\nin the specific setup we are interesting in, by reducing to the general bound in\n`radius_right_inv_pos_of_radius_pos_aux1`. -/\ntheorem radius_right_inv_pos_of_radius_pos_aux2 {n : â„•} (hn : 2 â‰¤ n + 1) (p : formal_multilinear_series ğ•œ E F)\n    (i : Â«expr â‰ƒL[ ] Â» E ğ•œ F) {r a C : exprâ„} (hr : 0 â‰¤ r) (ha : 0 â‰¤ a) (hC : 0 â‰¤ C)\n    (hp : âˆ€ n, Â«exprâ€– â€–Â» (p n) â‰¤ C * r ^ n) :\n    finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (Ico 1 (n + 1))\n        (a ^ k * Â«exprâ€– â€–Â» (p.right_inv i k)) â‰¤\n      Â«exprâ€– â€–Â» (i.symm : Â«expr â†’L[ ] Â» F ğ•œ E) * a +\n        Â«exprâ€– â€–Â» (i.symm : Â«expr â†’L[ ] Â» F ğ•œ E) * C *\n          finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n            (Ico 2 (n + 1))\n            ((r *\n                finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n                  (Ico 1 n) (a ^ j * Â«exprâ€– â€–Â» (p.right_inv i j))) ^\n              k) :=\n  let I := Â«exprâ€– â€–Â» (i.symm : Â«expr â†’L[ ] Â» F ğ•œ E)\n  calc\n    finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (Ico 1 (n + 1))\n          (a ^ k * Â«exprâ€– â€–Â» (p.right_inv i k)) =\n        a * I +\n          finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n            (Ico 2 (n + 1)) (a ^ k * Â«exprâ€– â€–Â» (p.right_inv i k)) :=\n      by\n      simp only [LinearIsometryEquiv.norm_map, pow_one, right_inv_coeff_one, Nat.Ico_succ_singleton, sum_singleton, â†\n        sum_Ico_consecutive _ one_le_two hn]\n    _ =\n        a * I +\n          finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n            (Ico 2 (n + 1))\n            (a ^ k *\n              Â«exprâ€– â€–Â»\n                ((i.symm : Â«expr â†’L[ ] Â» F ğ•œ E).comp_continuous_multilinear_map\n                  (finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n                    ({ c | 1 < Composition.length c }.to_finset : Finset (Composition k))\n                    (p.comp_along_composition (p.right_inv i) c)))) :=\n      by\n      congr 1\n      apply sum_congr rfl fun j hj => _\n      rw [right_inv_coeff _ _ _ (mem_Ico.1 hj).1, norm_neg]\n    _ â‰¤\n        a * Â«exprâ€– â€–Â» (i.symm : Â«expr â†’L[ ] Â» F ğ•œ E) +\n          finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n            (Ico 2 (n + 1))\n            (a ^ k *\n              (I *\n                finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n                  ({ c | 1 < Composition.length c }.to_finset : Finset (Composition k))\n                  (C * r ^ c.length *\n                    finset.prod_univ\n                      \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n                      (Â«exprâ€– â€–Â» (p.right_inv i (c.blocks_fun j)))))) :=\n      by\n      apply_rules [add_le_add, le_refl, sum_le_sum fun j hj => _, mul_le_mul_of_nonneg_left, pow_nonneg, ha]\n      apply (continuous_linear_map.norm_comp_continuous_multilinear_map_le _ _).trans\n      apply mul_le_mul_of_nonneg_left _ (norm_nonneg _)\n      apply (norm_sum_le _ _).trans\n      apply sum_le_sum fun c hc => _\n      apply (comp_along_composition_norm _ _ _).trans\n      apply mul_le_mul_of_nonneg_right (hp _)\n      exact prod_nonneg fun j hj => norm_nonneg _\n    _ =\n        I * a +\n          I * C *\n            finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n              (Ico 2 (n + 1))\n              (a ^ k *\n                finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n                  ({ c | 1 < Composition.length c }.to_finset : Finset (Composition k))\n                  (r ^ c.length *\n                    finset.prod_univ\n                      \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n                      (Â«exprâ€– â€–Â» (p.right_inv i (c.blocks_fun j))))) :=\n      by\n      simp_rw [mul_assoc C, â† mul_sum, â† mul_assoc, mul_comm _ (Â«exprâ€– â€–Â» â†‘i.symm), mul_assoc, â† mul_sum, â† mul_assoc,\n        mul_comm _ C, mul_assoc, â† mul_sum]\n      ring\n    _ â‰¤\n        I * a +\n          I * C *\n            finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n              (Ico 2 (n + 1))\n              ((r *\n                  finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n                    (Ico 1 n) (a ^ j * Â«exprâ€– â€–Â» (p.right_inv i j))) ^\n                k) :=\n      by\n      apply_rules [add_le_add, le_refl, mul_le_mul_of_nonneg_left, norm_nonneg, hC, mul_nonneg]\n      simp_rw [mul_pow]\n      apply\n        radius_right_inv_pos_of_radius_pos_aux1 n (fun k => Â«exprâ€– â€–Â» (p.right_inv i k)) (fun k => norm_nonneg _) hr ha\n    \n#align radius_right_inv_pos_of_radius_pos_aux2 radius_right_inv_pos_of_radius_pos_aux2\n\n",
 "radius_right_inv_pos_of_radius_pos_aux1":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/-- First technical lemma to control the growth of coefficients of the inverse. Bound the explicit\nexpression for `âˆ‘_{k<n+1} aáµ Qâ‚–` in terms of a sum of powers of the same sum one step before,\nin a general abstract setup. -/\ntheorem radius_right_inv_pos_of_radius_pos_aux1 (n : â„•) (p : â„• â†’ exprâ„) (hp : âˆ€ k, 0 â‰¤ p k) {r a : exprâ„} (hr : 0 â‰¤ r)\n    (ha : 0 â‰¤ a) :\n    finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (Ico 2 (n + 1))\n        (a ^ k *\n          finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n            ({ c | 1 < Composition.length c }.to_finset : Finset (Composition k))\n            (r ^ c.length *\n              finset.prod_univ\n                \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n                (p (c.blocks_fun j)))) â‰¤\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (Ico 2 (n + 1))\n        (r ^ j *\n          finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (Ico 1 n)\n              (a ^ k * p k) ^\n            j) :=\n  calc\n    finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (Ico 2 (n + 1))\n          (a ^ k *\n            finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n              ({ c | 1 < Composition.length c }.to_finset : Finset (Composition k))\n              (r ^ c.length *\n                finset.prod_univ\n                  \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n                  (p (c.blocks_fun j)))) =\n        finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (Ico 2 (n + 1))\n          (finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n            ({ c | 1 < Composition.length c }.to_finset : Finset (Composition k))\n            (finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n              (r * (a ^ c.blocks_fun j * p (c.blocks_fun j))))) :=\n      by\n      simp_rw [mul_sum]\n      apply sum_congr rfl fun k hk => _\n      apply sum_congr rfl fun c hc => _\n      rw [prod_mul_distrib, prod_mul_distrib, prod_pow_eq_pow_sum, Composition.sum_blocksFun, prod_const, card_fin]\n      ring\n    _ â‰¤\n        finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n          (comp_partial_sum_target 2 (n + 1) n)\n          (finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n            (r * (a ^ d.2.blocks_fun j * p (d.2.blocks_fun j)))) :=\n      by\n      rw [sum_sigma']\n      refine'\n        sum_le_sum_of_subset_of_nonneg _ fun x hx1 hx2 =>\n          prod_nonneg fun j hj => mul_nonneg hr (mul_nonneg (pow_nonneg ha _) (hp _))\n      rintro âŸ¨k, câŸ© hd\n      simp only [Set.mem_toFinset, mem_Ico, mem_sigma, Set.mem_setOf_eq] at hd\n      simp only [mem_comp_partial_sum_target_iff]\n      refine' âŸ¨hd.2, c.length_le.trans_lt hd.1.2, fun j => _âŸ©\n      have : c â‰  Composition.single k (zero_lt_two.trans_le hd.1.1) := by\n        simp [Composition.eq_single_iff_length, ne_of_gt hd.2]\n      rw [Composition.ne_single_iff] at this\n      exact (this j).trans_le (nat.lt_succ_iff.mp hd.1.2)\n    _ =\n        finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n          (comp_partial_sum_source 2 (n + 1) n)\n          (finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n            (r * (a ^ e.2 j * p (e.2 j)))) :=\n      by\n      symm\n      apply comp_change_of_variables_sum\n      rintro âŸ¨k, blocks_funâŸ© H\n      have K : (comp_change_of_variables 2 (n + 1) n âŸ¨k, blocks_funâŸ© H).snd.length = k := by simp\n      congr 2 <;> try rw [K]\n      rw [Fin.heq_fun_iff K.symm]\n      intro j\n      rw [comp_change_of_variables_blocks_fun]\n    _ =\n        finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (Ico 2 (n + 1))\n          (r ^ j *\n            finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (Ico 1 n)\n                (a ^ k * p k) ^\n              j) :=\n      by\n      rw [comp_partial_sum_source, â†\n        sum_sigma' (Ico 2 (n + 1)) (fun k : â„• => (Fintype.piFinset fun i : Fin k => Ico 1 n : Finset (Fin k â†’ â„•)))\n          fun n e =>\n          finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n            (r * (a ^ e j * p (e j)))]\n      apply sum_congr rfl fun j hj => _\n      simp only [â† @MultilinearMap.mkPiAlgebra_apply (exprâ„) (Fin j) _ (exprâ„)]\n      simp only [â†\n        MultilinearMap.map_sum_finset (MultilinearMap.mkPiAlgebra (exprâ„) (Fin j) (exprâ„)) fun k (m : â„•) =>\n          r * (a ^ m * p m)]\n      simp only [MultilinearMap.mkPiAlgebra_apply]\n      dsimp\n      simp [prod_const, â† mul_sum, mul_pow]\n    \n#align radius_right_inv_pos_of_radius_pos_aux1 radius_right_inv_pos_of_radius_pos_aux1\n\n",
 "radius_right_inv_pos_of_radius_pos":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.gt -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰ƒL[ ] Â» -/\n/-- If a a formal multilinear series has a positive radius of convergence, then its right inverse\nalso has a positive radius of convergence. -/\ntheorem radius_right_inv_pos_of_radius_pos (p : formal_multilinear_series ğ•œ E F) (i : Â«expr â‰ƒL[ ] Â» E ğ•œ F)\n    (hp : 0 < p.radius) : 0 < (p.right_inv i).radius :=\n  by\n  obtain âŸ¨C, r, Cpos, rpos, pleâŸ© : âˆƒ (C r : _)(hC : 0 < C)(hr : 0 < r), âˆ€ n : â„•, Â«exprâ€– â€–Â» (p n) â‰¤ C * r ^ n :=\n    le_mul_pow_of_radius_pos p hp\n  let I := Â«exprâ€– â€–Â» (i.symm : Â«expr â†’L[ ] Â» F ğ•œ E)\n  -- choose `a` small enough to make sure that `âˆ‘_{k â‰¤ n} aáµ Qâ‚–` will be controllable by\n  -- induction\n  obtain âŸ¨a, apos, ha1, ha2âŸ© :\n    âˆƒ (a : _)(apos : 0 < a), 2 * I * C * r ^ 2 * (I + 1) ^ 2 * a â‰¤ 1 âˆ§ r * (I + 1) * a â‰¤ 1 / 2 :=\n    by\n    have :\n      tendsto (fun a => 2 * I * C * r ^ 2 * (I + 1) ^ 2 * a) ((nhds) 0)\n        ((nhds) (2 * I * C * r ^ 2 * (I + 1) ^ 2 * 0)) :=\n      tendsto_const_nhds.mul tendsto_id\n    have A :\n      Â«exprâˆ€á¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â»\" ((nhds) 0)\n        (2 * I * C * r ^ 2 * (I + 1) ^ 2 * a < 1) :=\n      by\n      apply (tendsto_order.1 this).2\n      simp [zero_lt_one]\n    have : tendsto (fun a => r * (I + 1) * a) ((nhds) 0) ((nhds) (r * (I + 1) * 0)) := tendsto_const_nhds.mul tendsto_id\n    have B :\n      Â«exprâˆ€á¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â»\" ((nhds) 0)\n        (r * (I + 1) * a < 1 / 2) :=\n      by\n      apply (tendsto_order.1 this).2\n      simp [zero_lt_one]\n    have C :\n      Â«exprâˆ€á¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â»\"\n        (nhds_within.gt (0 : exprâ„)) ((0 : exprâ„) < a) :=\n      by filter_upwards [self_mem_nhdsWithin]with _ ha using ha\n    rcases(C.and ((A.and B).filter_mono inf_le_left)).exists with âŸ¨a, haâŸ©\n    exact âŸ¨a, ha.1, ha.2.1.le, ha.2.2.leâŸ©\n  -- check by induction that the partial sums are suitably bounded, using the choice of `a` and the\n  -- inductive control from Lemma `radius_right_inv_pos_of_radius_pos_aux2`.\n  let S n :=\n    finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (Ico 1 n)\n      (a ^ k * Â«exprâ€– â€–Â» (p.right_inv i k))\n  have IRec : âˆ€ n, 1 â‰¤ n â†’ S n â‰¤ (I + 1) * a := by\n    apply Nat.le_induction\n    Â· simp only [S]\n      rw [Ico_eq_empty_of_le (le_refl 1), sum_empty]\n      exact mul_nonneg (add_nonneg (norm_nonneg _) zero_le_one) apos.le\n    Â· intro n one_le_n hn\n      have In : 2 â‰¤ n + 1 := by linarith\n      have Snonneg : 0 â‰¤ S n := sum_nonneg fun x hx => mul_nonneg (pow_nonneg apos.le _) (norm_nonneg _)\n      have rSn : r * S n â‰¤ 1 / 2 :=\n        calc\n          r * S n â‰¤ r * ((I + 1) * a) := mul_le_mul_of_nonneg_left hn rpos.le\n          _ â‰¤ 1 / 2 := by rwa [â† mul_assoc]\n          \n      calc\n        S (n + 1) â‰¤\n            I * a +\n              I * C *\n                finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n                  (Ico 2 (n + 1)) ((r * S n) ^ k) :=\n          radius_right_inv_pos_of_radius_pos_aux2 In p i rpos.le apos.le Cpos.le ple\n        _ = I * a + I * C * (((r * S n) ^ 2 - (r * S n) ^ (n + 1)) / (1 - r * S n)) :=\n          by\n          rw [geom_sum_Ico' _ In]\n          exact ne_of_lt (rSn.trans_lt (by norm_num))\n        _ â‰¤ I * a + I * C * ((r * S n) ^ 2 / (1 / 2)) :=\n          by\n          apply_rules [add_le_add, le_refl, mul_le_mul_of_nonneg_left, mul_nonneg, norm_nonneg, Cpos.le]\n          refine' div_le_div (sq_nonneg _) _ (by norm_num) (by linarith)\n          simp only [sub_le_self_iff]\n          apply pow_nonneg (mul_nonneg rpos.le Snonneg)\n        _ = I * a + 2 * I * C * (r * S n) ^ 2 := by ring\n        _ â‰¤ I * a + 2 * I * C * (r * ((I + 1) * a)) ^ 2 := by\n          apply_rules [add_le_add, le_refl, mul_le_mul_of_nonneg_left, mul_nonneg, norm_nonneg, Cpos.le, zero_le_two,\n            pow_le_pow_of_le_left, rpos.le]\n        _ = (I + 2 * I * C * r ^ 2 * (I + 1) ^ 2 * a) * a := by ring\n        _ â‰¤ (I + 1) * a := by apply_rules [mul_le_mul_of_nonneg_right, apos.le, add_le_add, le_refl]\n        \n  -- conclude that all coefficients satisfy `aâ¿ Qâ‚™ â‰¤ (I + 1) a`.\n  let a' : NNReal := âŸ¨a, apos.leâŸ©\n  suffices H : (a' : ENNReal) â‰¤ (p.right_inv i).radius\n  Â· apply lt_of_lt_of_le _ H\n    exact_mod_cast apos\n  apply le_radius_of_bound _ ((I + 1) * a) fun n => _\n  by_cases hn : n = 0\n  Â· have : Â«exprâ€– â€–Â» (p.right_inv i n) = Â«exprâ€– â€–Â» (p.right_inv i 0) := by congr <;> try rw [hn]\n    simp only [this, norm_zero, MulZeroClass.zero_mul, right_inv_coeff_zero]\n    apply_rules [mul_nonneg, add_nonneg, norm_nonneg, zero_le_one, apos.le]\n  Â· have one_le_n : 1 â‰¤ n := bot_lt_iff_ne_bot.2 hn\n    calc\n      Â«exprâ€– â€–Â» (p.right_inv i n) * â†‘a' ^ n = a ^ n * Â«exprâ€– â€–Â» (p.right_inv i n) := mul_comm _ _\n      _ â‰¤\n          finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n            (Ico 1 (n + 1)) (a ^ k * Â«exprâ€– â€–Â» (p.right_inv i k)) :=\n        (haveI : âˆ€ k âˆˆ Ico 1 (n + 1), 0 â‰¤ a ^ k * Â«exprâ€– â€–Â» (p.right_inv i k) := fun k hk =>\n          mul_nonneg (pow_nonneg apos.le _) (norm_nonneg _)\n        single_le_sum this (by simp [one_le_n]))\n      _ â‰¤ (I + 1) * a := IRec (n + 1) (by decide)\n      \n#align radius_right_inv_pos_of_radius_pos radius_right_inv_pos_of_radius_pos\n\n",
 "left_inv_remove_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰ƒL[ ] Â» -/\n/-- The left inverse does not depend on the zeroth coefficient of a formal multilinear\nseries. -/\ntheorem left_inv_remove_zero (p : formal_multilinear_series ğ•œ E F) (i : Â«expr â‰ƒL[ ] Â» E ğ•œ F) :\n    p.remove_zero.left_inv i = p.left_inv i := by\n  ext1 n\n  induction' n using Nat.strongRec' with n IH\n  cases n; Â· simp\n  -- if one replaces `simp` with `refl`, the proof times out in the kernel.\n  cases n;\n  Â· simp\n  -- TODO: why?\n  simp only [left_inv, neg_inj]\n  refine' Finset.sum_congr rfl fun c cuniv => _\n  rcases c with âŸ¨c, hcâŸ©\n  ext v\n  dsimp\n  simp [IH _ hc]\n#align left_inv_remove_zero left_inv_remove_zero\n\n",
 "left_inv_eq_right_inv_aux":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰ƒL[ ] Â» -/\nprivate theorem left_inv_eq_right_inv_aux (p : formal_multilinear_series ğ•œ E F) (i : Â«expr â‰ƒL[ ] Â» E ğ•œ F)\n    (h : p 1 = (continuous_multilinear_curry_fin1 ğ•œ E F).symm i) (h0 : p 0 = 0) : left_inv p i = right_inv p i :=\n  calc\n    left_inv p i = (left_inv p i).comp (id ğ•œ F) := by simp\n    _ = (left_inv p i).comp (p.comp (right_inv p i)) := by rw [comp_right_inv p i h h0]\n    _ = ((left_inv p i).comp p).comp (right_inv p i) := by rw [comp_assoc]\n    _ = (id ğ•œ E).comp (right_inv p i) := by rw [left_inv_comp p i h]\n    _ = right_inv p i := by simp\n    \n#align left_inv_eq_right_inv_aux left_inv_eq_right_inv_aux\n\n",
 "left_inv_eq_right_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰ƒL[ ] Â» -/\n#print left_inv_eq_right_inv /-\n/-- The left inverse and the right inverse of a formal multilinear series coincide. This is not at\nall obvious from their definition, but it follows from uniqueness of inverses (which comes from the\nfact that composition is associative on formal multilinear series). -/\ntheorem left_inv_eq_right_inv (p : formal_multilinear_series ğ•œ E F) (i : Â«expr â‰ƒL[ ] Â» E ğ•œ F)\n    (h : p 1 = (continuous_multilinear_curry_fin1 ğ•œ E F).symm i) : left_inv p i = right_inv p i :=\n  calc\n    left_inv p i = left_inv p.remove_zero i := by rw [left_inv_remove_zero]\n    _ = right_inv p.remove_zero i := by apply left_inv_eq_right_inv_aux <;> simp [h]\n    _ = right_inv p i := by rw [right_inv_remove_zero]\n    \n#align left_inv_eq_right_inv left_inv_eq_right_inv\n-/\n\n",
 "left_inv_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰ƒL[ ] Â» -/\n/-- The left inverse to a formal multilinear series is indeed a left inverse, provided its linear\nterm is invertible. -/\ntheorem left_inv_comp (p : formal_multilinear_series ğ•œ E F) (i : Â«expr â‰ƒL[ ] Â» E ğ•œ F)\n    (h : p 1 = (continuous_multilinear_curry_fin1 ğ•œ E F).symm i) : (left_inv p i).comp p = id ğ•œ E :=\n  by\n  ext (n v)\n  cases n\n  Â·\n    simp only [left_inv, ContinuousMultilinearMap.zero_apply, id_apply_ne_one, ne.def, not_false_iff, zero_ne_one,\n      comp_coeff_zero']\n  cases n\n  Â·\n    simp only [left_inv, comp_coeff_one, h, id_apply_one, ContinuousLinearEquiv.coe_apply,\n      ContinuousLinearEquiv.symm_apply_apply, continuous_multilinear_curry_fin1_symm_apply]\n  have A :\n    (Finset.univ : Finset (Composition (n + 2))) =\n      { c | Composition.length c < n + 2 }.to_finset âˆª {Composition.ones (n + 2)} :=\n    by\n    refine' subset.antisymm (fun c hc => _) (subset_univ _)\n    by_cases h : c.length < n + 2\n    Â· simp [h]\n    Â· simp [Composition.eq_ones_iff_le_length.2 (not_lt.1 h)]\n  have B :\n    Disjoint ({ c | Composition.length c < n + 2 } : Set (Composition (n + 2))).to_finset {Composition.ones (n + 2)} :=\n    by simp\n  have C :\n    ((p.left_inv i (Composition.ones (n + 2)).length) fun j : Fin (Composition.ones n.succ.succ).length =>\n        p 1 fun k => v ((Fin.castLE (Composition.length_le _)) j)) =\n      p.left_inv i (n + 2) fun j : Fin (n + 2) => p 1 fun k => v j :=\n    by\n    apply formal_multilinear_series.congr _ (Composition.ones_length _) fun j hj1 hj2 => _\n    exact formal_multilinear_series.congr _ rfl fun k hk1 hk2 => by congr\n  have D :\n    (p.left_inv i (n + 2) fun j : Fin (n + 2) => p 1 fun k => v j) =\n      -finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n          { c : Composition (n + 2) | c.length < n + 2 }.to_finset\n          ((p.left_inv i c.length) (p.apply_composition c v)) :=\n    by\n    simp only [left_inv, ContinuousMultilinearMap.neg_apply, neg_inj, ContinuousMultilinearMap.sum_apply]\n    convert(sum_to_finset_eq_subtype (fun c : Composition (n + 2) => c.length < n + 2) fun c : Composition (n + 2) =>\n              (continuous_multilinear_map.comp_along_composition (p.comp_continuous_linear_map â†‘i.symm) c\n                  (p.left_inv i c.length))\n                fun j : Fin (n + 2) => p 1 fun k : Fin 1 => v j).symm.trans\n        _\n    simp only [comp_continuous_linear_map_apply_composition, continuous_multilinear_map.comp_along_composition_apply]\n    congr\n    ext c\n    congr\n    ext k\n    simp [h]\n  simp [formal_multilinear_series.comp, show n + 2 â‰  1 by decide, A, Finset.sum_union B, apply_composition_ones, C, D,\n    -Set.toFinset_setOf]\n#align left_inv_comp left_inv_comp\n\n",
 "left_inv_coeff_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰ƒL[ ] Â» -/\n/-\nCopyright (c) 2021 SÃ©bastien GouÃ«zel. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: SÃ©bastien GouÃ«zel\n-/\n@[simp]\ntheorem left_inv_coeff_zero (p : formal_multilinear_series ğ•œ E F) (i : Â«expr â‰ƒL[ ] Â» E ğ•œ F) : p.left_inv i 0 = 0 := by\n  rw [left_inv]\n#align left_inv_coeff_zero left_inv_coeff_zero\n\n",
 "left_inv_coeff_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰ƒL[ ] Â» -/\n@[simp]\ntheorem left_inv_coeff_one (p : formal_multilinear_series ğ•œ E F) (i : Â«expr â‰ƒL[ ] Â» E ğ•œ F) :\n    p.left_inv i 1 = (continuous_multilinear_curry_fin1 ğ•œ F E).symm i.symm := by rw [left_inv]\n#align left_inv_coeff_one left_inv_coeff_one\n\n",
 "comp_right_inv_aux2":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰ƒL[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem comp_right_inv_aux2 (p : formal_multilinear_series ğ•œ E F) (i : Â«expr â‰ƒL[ ] Â» E ğ•œ F) (n : â„•)\n    (v : Fin (n + 2) â†’ F) :\n    finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n        { c : Composition (n + 2) | 1 < c.length }.to_finset\n        (p c.length (apply_composition (fun k : â„• => ite (k < n + 2) (p.right_inv i k) 0) c v)) =\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n        { c : Composition (n + 2) | 1 < c.length }.to_finset (p c.length ((p.right_inv i).apply_composition c v)) :=\n  by\n  have N : 0 < n + 2 := by decide\n  refine' sum_congr rfl fun c hc => p.congr rfl fun j hj1 hj2 => _\n  have : âˆ€ k, c.blocks_fun k < n + 2 :=\n    by\n    simp only [Set.mem_toFinset, Set.mem_setOf_eq] at hc\n    simp [â† Composition.ne_single_iff N, Composition.eq_single_iff_length, ne_of_gt hc]\n  simp [apply_composition, this]\n#align comp_right_inv_aux2 comp_right_inv_aux2\n\n",
 "comp_right_inv_aux1":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem comp_right_inv_aux1 {n : â„•} (hn : 0 < n) (p : formal_multilinear_series ğ•œ E F)\n    (q : formal_multilinear_series ğ•œ F E) (v : Fin n â†’ F) :\n    p.comp q n v =\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n          { c : Composition n | 1 < c.length }.to_finset (p c.length (q.apply_composition c v)) +\n        p 1 fun i => q n v :=\n  by\n  have A :\n    (Finset.univ : Finset (Composition n)) = { c | 1 < Composition.length c }.to_finset âˆª {Composition.single n hn} :=\n    by\n    refine' subset.antisymm (fun c hc => _) (subset_univ _)\n    by_cases h : 1 < c.length\n    Â· simp [h]\n    Â· have : c.length = 1 := by\n        refine' (eq_iff_le_not_lt.2 âŸ¨_, hâŸ©).symm\n        exact c.length_pos_of_pos hn\n      rw [â† Composition.eq_single_iff_length hn] at this\n      simp [this]\n  have B : Disjoint ({ c | 1 < Composition.length c } : Set (Composition n)).to_finset {Composition.single n hn} := by\n    simp\n  have C :\n    p (Composition.single n hn).length (q.apply_composition (Composition.single n hn) v) = p 1 fun i : Fin 1 => q n v :=\n    by\n    apply p.congr (Composition.single_length hn) fun j hj1 hj2 => _\n    simp [apply_composition_single]\n  simp [formal_multilinear_series.comp, A, Finset.sum_union B, C, -Set.toFinset_setOf]\n#align comp_right_inv_aux1 comp_right_inv_aux1\n\n",
 "comp_right_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰ƒL[ ] Â» -/\n/-- The right inverse to a formal multilinear series is indeed a right inverse, provided its linear\nterm is invertible and its constant term vanishes. -/\ntheorem comp_right_inv (p : formal_multilinear_series ğ•œ E F) (i : Â«expr â‰ƒL[ ] Â» E ğ•œ F)\n    (h : p 1 = (continuous_multilinear_curry_fin1 ğ•œ E F).symm i) (h0 : p 0 = 0) : p.comp (right_inv p i) = id ğ•œ F :=\n  by\n  ext (n v)\n  cases n\n  Â·\n    simp only [h0, ContinuousMultilinearMap.zero_apply, id_apply_ne_one, ne.def, not_false_iff, zero_ne_one,\n      comp_coeff_zero']\n  cases n\n  Â·\n    simp only [comp_coeff_one, h, right_inv, ContinuousLinearEquiv.apply_symm_apply, id_apply_one,\n      ContinuousLinearEquiv.coe_apply, continuous_multilinear_curry_fin1_symm_apply]\n  have N : 0 < n + 2 := by decide\n  simp [comp_right_inv_aux1 N, h, right_inv, lt_irrefl n, show n + 2 â‰  1 by decide, â† sub_eq_add_neg, sub_eq_zero,\n    comp_right_inv_aux2, -Set.toFinset_setOf]\n#align comp_right_inv comp_right_inv\n\n"}