{"radius_eq_liminf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/-\nCopyright (c) 2020 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-/\n/-- The radius of a formal multilinear series is equal to\n$\\liminf_{n\\to\\infty} \\frac{1}{\\sqrt[n]{‖p n‖}}$. The actual statement uses `ℝ≥0` and some\ncoercions. -/\ntheorem radius_eq_liminf : p.radius = liminf (fun n => 1 / («expr‖ ‖₊» (p n) ^ (1 / (n : exprℝ)) : nnreal)) atTop :=\n  by\n  have :\n    ∀ (r : nnreal) {n : ℕ},\n      0 < n → ((r : ennreal) ≤ 1 / ↑(«expr‖ ‖₊» (p n) ^ (1 / (n : exprℝ))) ↔ «expr‖ ‖₊» (p n) * r ^ n ≤ 1) :=\n    by\n    intro r n hn\n    have : 0 < (n : exprℝ) := Nat.cast_pos.2 hn\n    conv_lhs =>\n      rw [one_div, ENNReal.le_inv_iff_mul_le, ← ENNReal.coe_mul, ENNReal.coe_le_one_iff, one_div, ← nnreal.rpow_one r, ←\n        mul_inv_cancel this.ne', nnreal.rpow_mul, ← nnreal.mul_rpow, ← nnreal.one_rpow n⁻¹,\n        nnreal.rpow_le_rpow_iff (inv_pos.2 this), mul_comm, nnreal.rpow_nat_cast]\n  apply le_antisymm <;> refine' ENNReal.le_of_forall_nnreal_lt fun r hr => _\n  · rcases((TFAE_exists_lt_isLittleO_pow (fun n => «expr‖ ‖» (p n) * r ^ n) 1).out 1 7).1 (p.is_o_of_lt_radius hr) with\n      ⟨a, ha, H⟩\n    refine' le_Liminf_of_le (by infer_param) (eventually_map.2 <| _)\n    refine' H.mp ((eventually_gt_at_top 0).mono fun n hn₀ hn => (this _ hn₀).2 (NNReal.coe_le_coe.1 _))\n    push_cast\n    exact (le_abs_self _).trans (hn.trans (pow_le_one _ ha.1.le ha.2.le))\n  · refine' p.le_radius_of_is_O (is_O.of_bound 1 _)\n    refine' (eventually_lt_of_lt_liminf hr).mp ((eventually_gt_at_top 0).mono fun n hn₀ hn => _)\n    simpa using NNReal.coe_le_coe.2 ((this _ hn₀).1 hn.le)\n#align radius_eq_liminf radius_eq_liminf\n\n"}