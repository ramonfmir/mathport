{"eq_on_zero_of_preconnected_of_eventually_eq_zero_aux":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr =á¶ [ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–â‚ŠÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr =á¶ [ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-\nCopyright (c) 2022 SÃ©bastien GouÃ«zel. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: SÃ©bastien GouÃ«zel\n-/\n/-- If an analytic function vanishes around a point, then it is uniformly zero along\na connected set. Superseded by `eq_on_zero_of_preconnected_of_locally_zero` which does not assume\ncompleteness of the target space. -/\ntheorem eq_on_zero_of_preconnected_of_eventually_eq_zero_aux [CompleteSpace F] {f : E â†’ F} {U : Set E}\n    (hf : analytic_on ğ•œ f U) (hU : IsPreconnected U) {zâ‚€ : E} (hâ‚€ : zâ‚€ âˆˆ U) (hfzâ‚€ : Â«expr =á¶ [ ] Â» f ((nhds) zâ‚€) 0) :\n    EqOn f 0 U :=\n  by\n  /- Let `u` be the set of points around which `f` vanishes. It is clearly open. We have to show\n    that its limit points in `U` still belong to it, from which the inclusion `U âŠ† u` will follow\n    by connectedness. -/\n  let u := { x | Â«expr =á¶ [ ] Â» f ((nhds) x) 0 }\n  suffices main : closure u âˆ© U âŠ† u\n  Â· have Uu : U âŠ† u := hU.subset_of_closure_inter_subset isOpen_setOf_eventually_nhds âŸ¨zâ‚€, hâ‚€, hfzâ‚€âŸ© main\n    intro z hz\n    simpa using mem_of_mem_nhds (Uu hz)\n  /- Take a limit point `x`, then a ball `B (x, r)` on which it has a power series expansion, and\n    then `y âˆˆ B (x, r/2) âˆ© u`. Then `f` has a power series expansion on `B (y, r/2)` as it is\n    contained in `B (x, r)`. All the coefficients in this series expansion vanish, as `f` is zero on a\n    neighborhood of `y`. Therefore, `f` is zero on `B (y, r/2)`. As this ball contains `x`, it follows\n    that `f` vanishes on a neighborhood of `x`, proving the claim. -/\n  rintro x âŸ¨xu, xUâŸ©\n  rcases hf x xU with âŸ¨p, r, hpâŸ©\n  obtain âŸ¨y, yu, hxyâŸ© : âˆƒ y âˆˆ u, edist x y < r / 2\n  exact EMetric.mem_closure_iff.1 xu (r / 2) (ENNReal.half_pos hp.r_pos.ne')\n  let q := p.change_origin (y - x)\n  have has_series : has_fpower_series_on_ball f q y (r / 2) :=\n    by\n    have A : (Â«exprâ€– â€–â‚ŠÂ» (y - x) : ennreal) < r / 2 := by rwa [edist_comm, edist_eq_coe_nnnorm_sub] at hxy\n    have := hp.change_origin (A.trans_le ENNReal.half_le_self)\n    simp only [add_sub_cancel'_right] at this\n    apply this.mono (ENNReal.half_pos hp.r_pos.ne')\n    apply ENNReal.le_sub_of_add_le_left ENNReal.coe_ne_top\n    apply (add_le_add A.le (le_refl (r / 2))).trans (le_of_eq _)\n    exact ENNReal.add_halves _\n  have M : EMetric.ball y (r / 2) âˆˆ (nhds) x := emetric.is_open_ball.mem_nhds hxy\n  filter_upwards [M]with z hz\n  have A : HasSum (fun n : â„• => q n fun i : Fin n => z - y) (f z) := has_series.has_sum_sub hz\n  have B : HasSum (fun n : â„• => q n fun i : Fin n => z - y) 0 :=\n    by\n    have : has_fpower_series_at 0 q y := has_series.has_fpower_series_at.congr yu\n    convert hasSum_zero\n    ext n\n    exact this.apply_eq_zero n _\n  exact HasSum.unique A B\n#align eq_on_zero_of_preconnected_of_eventually_eq_zero_aux eq_on_zero_of_preconnected_of_eventually_eq_zero_aux\n\n",
 "eq_on_zero_of_preconnected_of_eventually_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr =á¶ [ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- The *identity principle* for analytic functions: If an analytic function vanishes in a whole\nneighborhood of a point `zâ‚€`, then it is uniformly zero along a connected set. For a one-dimensional\nversion assuming only that the function vanishes at some points arbitrarily close to `zâ‚€`, see\n`eq_on_zero_of_preconnected_of_frequently_eq_zero`. -/\ntheorem eq_on_zero_of_preconnected_of_eventually_eq_zero {f : E â†’ F} {U : Set E} (hf : analytic_on ğ•œ f U)\n    (hU : IsPreconnected U) {zâ‚€ : E} (hâ‚€ : zâ‚€ âˆˆ U) (hfzâ‚€ : Â«expr =á¶ [ ] Â» f ((nhds) zâ‚€) 0) : EqOn f 0 U :=\n  by\n  let F' := UniformSpace.Completion F\n  set e : Â«expr â†’L[ ] Â» F ğ•œ F' := uniform_space.completion.to_complL\n  have : analytic_on ğ•œ (e âˆ˜ f) U := fun x hx => (e.analytic_at _).comp (hf x hx)\n  have A : eq_on (e âˆ˜ f) 0 U :=\n    by\n    apply eq_on_zero_of_preconnected_of_eventually_eq_zero_aux this hU hâ‚€\n    filter_upwards [hfzâ‚€]with x hx\n    simp only [hx, Function.comp_apply, Pi.zero_apply, map_zero]\n  intro z hz\n  have : e (f z) = e 0 := by simpa only using A hz\n  exact UniformSpace.Completion.coe_injective F this\n#align eq_on_zero_of_preconnected_of_eventually_eq_zero eq_on_zero_of_preconnected_of_eventually_eq_zero\n\n",
 "eq_on_of_preconnected_of_eventually_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr =á¶ [ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr =á¶ [ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- The *identity principle* for analytic functions: If two analytic function coincide in a whole\nneighborhood of a point `zâ‚€`, then they coincide globally along a connected set.\nFor a one-dimensional version assuming only that the functions coincide at some points\narbitrarily close to `zâ‚€`, see `eq_on_of_preconnected_of_frequently_eq`. -/\ntheorem eq_on_of_preconnected_of_eventually_eq {f g : E â†’ F} {U : Set E} (hf : analytic_on ğ•œ f U)\n    (hg : analytic_on ğ•œ g U) (hU : IsPreconnected U) {zâ‚€ : E} (hâ‚€ : zâ‚€ âˆˆ U) (hfg : Â«expr =á¶ [ ] Â» f ((nhds) zâ‚€) g) :\n    EqOn f g U := by\n  have hfg' : Â«expr =á¶ [ ] Â» (f - g) ((nhds) zâ‚€) 0 := hfg.mono fun z h => by simp [h]\n  simpa [sub_eq_zero] using fun z hz => (hf.sub hg).eq_on_zero_of_preconnected_of_eventually_eq_zero hU hâ‚€ hfg' hz\n#align eq_on_of_preconnected_of_eventually_eq eq_on_of_preconnected_of_eventually_eq\n\n"}