{"size_up_to_size_up_to_add":
 "/-- Auxiliary lemma to prove that the composition of formal multilinear series is associative.\n\nConsider a composition `a` of `n` and a composition `b` of `a.length`. Grouping together some\nblocks of `a` according to `b` as in `a.gather b`, one can compute the total size of the blocks\nof `a` up to an index `size_up_to b i + j` (where the `j` corresponds to a set of blocks of `a`\nthat do not fill a whole block of `a.gather b`). The first part corresponds to a sum of blocks\nin `a.gather b`, and the second one to a sum of blocks in the next block of\n`sigma_composition_aux a b`. This is the content of this lemma. -/\ntheorem size_up_to_size_up_to_add (a : composition n) (b : composition a.length) {i j : â„•} (hi : i < b.length)\n    (hj : j < blocks_fun b âŸ¨i, hiâŸ©) :\n    size_up_to a (size_up_to b i + j) =\n      size_up_to (a.gather b) i + size_up_to (sigma_composition_aux a b âŸ¨i, (length_gather a b).symm â–¸ hiâŸ©) j :=\n  by\n  induction' j with j IHj\n  Â· show sum (take (b.blocks.take i).sum a.blocks) = sum (take i (map sum (split_wrt_composition a.blocks b)))\n    induction' i with i IH\n    Â· rfl\n    Â· have A : i < b.length := nat.lt_of_succ_lt hi\n      have B : i < list.length (map List.sum (split_wrt_composition a.blocks b)) := by simp [A]\n      have C : 0 < blocks_fun b âŸ¨i, AâŸ© := composition.blocks_pos' _ _ _\n      rw [sum_take_succ _ _ B, â† IH A C]\n      have :\n        take (sum (take i b.blocks)) a.blocks =\n          take (sum (take i b.blocks)) (take (sum (take (i + 1) b.blocks)) a.blocks) :=\n        by\n        rw [take_take, min_eq_left]\n        apply monotone_sum_take _ (nat.le_succ _)\n      rw [this, nth_le_map', nth_le_split_wrt_composition, â†\n        take_append_drop (sum (take i b.blocks)) (take (sum (take (nat.succ i) b.blocks)) a.blocks), sum_append]\n      congr\n      rw [take_append_drop]\n  Â· have A : j < blocks_fun b âŸ¨i, hiâŸ© := lt_trans (lt_add_one j) hj\n    have B : j < length (sigma_composition_aux a b âŸ¨i, (length_gather a b).symm â–¸ hiâŸ©) :=\n      by\n      convert A\n      rw [â† length_sigma_composition_aux]\n      rfl\n    have C : size_up_to b i + j < size_up_to b (i + 1) :=\n      by\n      simp only [size_up_to_succ b hi, add_lt_add_iff_left]\n      exact A\n    have D : size_up_to b i + j < length a := lt_of_lt_of_le C (b.size_up_to_le _)\n    have : size_up_to b i + nat.succ j = (size_up_to b i + j).succ := rfl\n    rw [this, size_up_to_succ _ D, IHj A, size_up_to_succ _ B]\n    simp only [sigma_composition_aux, add_assoc, add_left_inj, Fin.val_mk]\n    rw [nth_le_of_eq (nth_le_split_wrt_composition _ _ _), nth_le_drop', nth_le_take _ _ C]\n#align size_up_to_size_up_to_add size_up_to_size_up_to_add\n\n",
 "sigma_pi_composition_eq_iff":
 "/-- Rewriting equality in the dependent type\n`Î£ (c : composition n), Î  (i : fin c.length), composition (c.blocks_fun i)` in\nnon-dependent terms with lists, requiring that the lists of blocks coincide. -/\ntheorem sigma_pi_composition_eq_iff (u v : Î£c : composition n, âˆ€ i : fin c.length, composition (c.blocks_fun i)) :\n    u = v â†” (ofFn fun i => (u.2 i).blocks) = ofFn fun i => (v.2 i).blocks :=\n  by\n  refine' âŸ¨fun H => by rw [H], fun H => _âŸ©\n  rcases u with âŸ¨a, bâŸ©\n  rcases v with âŸ¨a', b'âŸ©\n  dsimp at H\n  have h : a = a' := by\n    ext1\n    have :\n      map List.sum (of_fn fun i : fin (composition.length a) => (b i).blocks) =\n        map List.sum (of_fn fun i : fin (composition.length a') => (b' i).blocks) :=\n      by rw [H]\n    simp only [map_of_fn] at this\n    change\n      (of_fn fun i : fin (composition.length a) => (b i).blocks.sum) =\n        of_fn fun i : fin (composition.length a') => (b' i).blocks.sum at\n      this\n    simpa [composition.blocks_sum, composition.of_fn_blocks_fun] using this\n  induction h\n  simp only [true_and_iff, eq_self_iff_true, heq_iff_eq]\n  ext i : 2\n  have :\n    nth_le (of_fn fun i : fin (composition.length a) => (b i).blocks) i (by simp [i.is_lt]) =\n      nth_le (of_fn fun i : fin (composition.length a) => (b' i).blocks) i (by simp [i.is_lt]) :=\n    nth_le_of_eq H _\n  rwa [nth_le_of_fn, nth_le_of_fn] at this\n#align sigma_pi_composition_eq_iff sigma_pi_composition_eq_iff\n\n",
 "sigma_composition_eq_iff":
 "/-- Rewriting equality in the dependent type `Î£ (a : composition n), composition a.length)` in\nnon-dependent terms with lists, requiring that the blocks coincide. -/\ntheorem sigma_composition_eq_iff (i j : Î£a : composition n, composition a.length) :\n    i = j â†” i.1.blocks = j.1.blocks âˆ§ i.2.blocks = j.2.blocks :=\n  by\n  refine' âŸ¨by rintro rfl <;> exact âŸ¨rfl, rflâŸ©, _âŸ©\n  rcases i with âŸ¨a, bâŸ©\n  rcases j with âŸ¨a', b'âŸ©\n  rintro âŸ¨h, h'âŸ©\n  have H : a = a' := by\n    ext1\n    exact h\n  induction H\n  congr\n  ext1\n  exact h'\n#align sigma_composition_eq_iff sigma_composition_eq_iff\n\n",
 "remove_zero_comp_of_pos":
 "/-- Only `0`-th coefficient of `q.comp p` depends on `q 0`. -/\ntheorem remove_zero_comp_of_pos (q : formal_multilinear_series ğ•œ F G) (p : formal_multilinear_series ğ•œ E F) {n : â„•}\n    (hn : 0 < n) : q.remove_zero.comp p n = q.comp p n :=\n  by\n  ext v\n  simp only [formal_multilinear_series.comp, comp_along_composition,\n    continuous_multilinear_map.comp_along_composition_apply, continuous_multilinear_map.sum_apply]\n  apply finset.sum_congr rfl fun c hc => _\n  rw [remove_zero_of_pos _ (c.length_pos_of_pos hn)]\n#align remove_zero_comp_of_pos remove_zero_comp_of_pos\n\n",
 "remove_zero_apply_composition":
 "@[simp]\ntheorem remove_zero_apply_composition (p : formal_multilinear_series ğ•œ E F) {n : â„•} (c : composition n) :\n    p.remove_zero.apply_composition c = p.apply_composition c :=\n  by\n  ext (v i)\n  simp [apply_composition, zero_lt_one.trans_le (c.one_le_blocks_fun i), remove_zero_of_pos]\n#align remove_zero_apply_composition remove_zero_apply_composition\n\n",
 "mem_comp_partial_sum_target_iff":
 "@[simp]\ntheorem mem_comp_partial_sum_target_iff {m M N : â„•} {a : Î£n, composition n} :\n    a âˆˆ comp_partial_sum_target m M N â†” m â‰¤ a.2.length âˆ§ a.2.length < M âˆ§ âˆ€ j : fin a.2.length, a.2.blocks_fun j < N :=\n  by simp [comp_partial_sum_target, comp_partial_sum_target_set]\n#align mem_comp_partial_sum_target_iff mem_comp_partial_sum_target_iff\n\n",
 "mem_comp_partial_sum_source_iff":
 "@[simp]\ntheorem mem_comp_partial_sum_source_iff (m M N : â„•) (i : Î£n, fin n â†’ â„•) :\n    i âˆˆ comp_partial_sum_source m M N â†” (m â‰¤ i.1 âˆ§ i.1 < M) âˆ§ âˆ€ a : fin i.1, 1 â‰¤ i.2 a âˆ§ i.2 a < N := by\n  simp only [comp_partial_sum_source, finset.mem_Ico, fintype.mem_pi_finset, finset.mem_sigma, iff_self_iff]\n#align mem_comp_partial_sum_source_iff mem_comp_partial_sum_source_iff\n\n",
 "length_sigma_composition_aux":
 "theorem length_sigma_composition_aux (a : composition n) (b : composition a.length) (i : fin b.length) :\n    composition.length (composition.sigma_composition_aux a b âŸ¨i, (length_gather a b).symm â–¸ i.2âŸ©) =\n      composition.blocks_fun b i :=\n  show list.length (nthLe (split_wrt_composition a.blocks b) i _) = blocks_fun b i\n    by\n    rw [nth_le_map_rev list.length, nth_le_of_eq (map_length_split_wrt_composition _ _)]\n    rfl\n#align length_sigma_composition_aux length_sigma_composition_aux\n\n",
 "length_gather":
 "theorem length_gather (a : composition n) (b : composition a.length) : length (a.gather b) = b.length :=\n  show (map List.sum (a.blocks.split_wrt_composition b)).length = b.blocks.length by\n    rw [length_map, length_split_wrt_composition]\n#align length_gather length_gather\n\n",
 "le_comp_radius_of_summable":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ‘' , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ‘' , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–â‚ŠÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–â‚ŠÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ‘' , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ‘' , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–â‚ŠÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ‘' , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ‘' , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–â‚ŠÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–â‚ŠÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/-- Bounding below the radius of the composition of two formal multilinear series assuming\nsummability over all compositions. -/\ntheorem le_comp_radius_of_summable (q : formal_multilinear_series ğ•œ F G) (p : formal_multilinear_series ğ•œ E F)\n    (r : nnreal) (hr : summable fun i : Î£n, composition n => Â«exprâ€– â€–â‚ŠÂ» (q.comp_along_composition p i.2) * r ^ i.1) :\n    (r : ennreal) â‰¤ (q.comp p).radius :=\n  by\n  refine'\n    le_radius_of_bound_nnreal _\n      (Â«exprâˆ‘' , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ‘' , Â»\"\n        (Â«exprâ€– â€–â‚ŠÂ» (comp_along_composition q p i.snd) * r ^ i.fst))\n      fun n => _\n  calc\n    Â«exprâ€– â€–â‚ŠÂ» (formal_multilinear_series.comp q p n) * r ^ n â‰¤\n        Â«exprâˆ‘' , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ‘' , Â»\"\n          (Â«exprâ€– â€–â‚ŠÂ» (comp_along_composition q p c) * r ^ n) :=\n      by\n      rw [tsum_fintype, â† finset.sum_mul]\n      exact mul_le_mul' (nnnorm_sum_le _ _) le_rfl\n    _ â‰¤\n        Â«exprâˆ‘' , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ‘' , Â»\"\n          (Â«exprâ€– â€–â‚ŠÂ» (comp_along_composition q p i.snd) * r ^ i.fst) :=\n      nnreal.tsum_comp_le_tsum_of_inj hr sigma_mk_injective\n    \n#align le_comp_radius_of_summable le_comp_radius_of_summable\n\n",
 "id_comp":
 "@[simp]\ntheorem id_comp (p : formal_multilinear_series ğ•œ E F) (h : p 0 = 0) : (id ğ•œ F).comp p = p :=\n  by\n  ext1 n\n  by_cases hn : n = 0\n  Â· rw [hn, h]\n    ext v\n    rw [comp_coeff_zero', id_apply_ne_one _ _ zero_ne_one]\n    rfl\n  Â· dsimp [formal_multilinear_series.comp]\n    have n_pos : 0 < n := bot_lt_iff_ne_bot.mpr hn\n    rw [finset.sum_eq_single (composition.single n n_pos)]\n    show comp_along_composition (id ğ•œ F) p (composition.single n n_pos) = p n\n    Â· ext v\n      rw [comp_along_composition_apply, id_apply_one' _ _ (composition.single_length n_pos)]\n      dsimp [apply_composition]\n      refine' p.congr rfl fun i him hin => congr_arg v <| _\n      ext\n      simp\n    show âˆ€ b : composition n, b âˆˆ finset.univ â†’ b â‰  composition.single n n_pos â†’ comp_along_composition (id ğ•œ F) p b = 0\n    Â· intro b _ hb\n      have A : b.length â‰  1 := by simpa [composition.eq_single_iff_length] using hb\n      ext v\n      rw [comp_along_composition_apply, id_apply_ne_one _ _ A]\n      rfl\n    Â· simp\n#align id_comp id_comp\n\n",
 "id_apply_one'":
 "/-- The `n`th coefficient of `id ğ•œ E` is the identity when `n = 1`. We state this in a dependent\nway, as it will often appear in this form. -/\ntheorem id_apply_one' {n : â„•} (h : n = 1) (v : fin n â†’ E) : (id ğ•œ E) n v = v âŸ¨0, h.symm â–¸ zero_lt_oneâŸ© :=\n  by\n  subst n\n  apply id_apply_one\n#align id_apply_one' id_apply_one'\n\n",
 "id_apply_one":
 "/-- The first coefficient of `id ğ•œ E` is the identity. -/\n@[simp]\ntheorem id_apply_one (v : fin 1 â†’ E) : (formal_multilinear_series.id ğ•œ E) 1 v = v 0 :=\n  rfl\n#align id_apply_one id_apply_one\n\n",
 "id_apply_ne_one":
 "/-- For `n â‰  1`, the `n`-th coefficient of `id ğ•œ E` is zero, by definition. -/\n@[simp]\ntheorem id_apply_ne_one {n : â„•} (h : n â‰  1) : (formal_multilinear_series.id ğ•œ E) n = 0 :=\n  by\n  cases n\n  Â· rfl\n  cases n\n  Â· contradiction\n  rfl\n#align id_apply_ne_one id_apply_ne_one\n\n",
 "comp_summable_nnreal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–â‚ŠÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–â‚ŠÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–â‚ŠÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–â‚ŠÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–â‚ŠÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–â‚ŠÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–â‚ŠÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–â‚ŠÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–â‚ŠÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–â‚ŠÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–â‚ŠÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–â‚ŠÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–â‚ŠÂ» -/\n/-- If two formal multilinear series have positive radius of convergence, then the terms appearing\nin the definition of their composition are also summable (when multiplied by a suitable positive\ngeometric term). -/\ntheorem comp_summable_nnreal (q : formal_multilinear_series ğ•œ F G) (p : formal_multilinear_series ğ•œ E F)\n    (hq : 0 < q.radius) (hp : 0 < p.radius) :\n    âˆƒ r > (0 : nnreal), summable fun i : Î£n, composition n => Â«exprâ€– â€–â‚ŠÂ» (q.comp_along_composition p i.2) * r ^ i.1 :=\n  by\n  /- This follows from the fact that the growth rate of `â€–qâ‚™â€–` and `â€–pâ‚™â€–` is at most geometric,\n    giving a geometric bound on each `â€–q.comp_along_composition p opâ€–`, together with the\n    fact that there are `2^(n-1)` compositions of `n`, giving at most a geometric loss. -/\n  rcases ennreal.lt_iff_exists_nnreal_btwn.1 (lt_min ennreal.zero_lt_one hq) with âŸ¨rq, rq_pos, hrqâŸ©\n  rcases ennreal.lt_iff_exists_nnreal_btwn.1 (lt_min ennreal.zero_lt_one hp) with âŸ¨rp, rp_pos, hrpâŸ©\n  simp only [lt_min_iff, ennreal.coe_lt_one_iff, ennreal.coe_pos] at hrp hrq rp_pos rq_pos\n  obtain âŸ¨Cq, hCq0, hCqâŸ© : âˆƒ Cq > 0, âˆ€ n, Â«exprâ€– â€–â‚ŠÂ» (q n) * rq ^ n â‰¤ Cq := q.nnnorm_mul_pow_le_of_lt_radius hrq.2\n  obtain âŸ¨Cp, hCp1, hCpâŸ© : âˆƒ Cp â‰¥ 1, âˆ€ n, Â«exprâ€– â€–â‚ŠÂ» (p n) * rp ^ n â‰¤ Cp :=\n    by\n    rcases p.nnnorm_mul_pow_le_of_lt_radius hrp.2 with âŸ¨Cp, -, hCpâŸ©\n    exact âŸ¨max Cp 1, le_max_right _ _, fun n => (hCp n).trans (le_max_left _ _)âŸ©\n  let r0 : nnreal := (4 * Cp)â»Â¹\n  have r0_pos : 0 < r0 := nnreal.inv_pos.2 (mul_pos zero_lt_four (zero_lt_one.trans_le hCp1))\n  set r : nnreal := rp * rq * r0\n  have r_pos : 0 < r := mul_pos (mul_pos rp_pos rq_pos) r0_pos\n  have I : âˆ€ i : Î£n : â„•, composition n, Â«exprâ€– â€–â‚ŠÂ» (q.comp_along_composition p i.2) * r ^ i.1 â‰¤ Cq / 4 ^ i.1 :=\n    by\n    rintro âŸ¨n, câŸ©\n    have A\n    calc\n      Â«exprâ€– â€–â‚ŠÂ» (q c.length) * rq ^ n â‰¤ Â«exprâ€– â€–â‚ŠÂ» (q c.length) * rq ^ c.length :=\n        mul_le_mul' le_rfl (pow_le_pow_of_le_one rq.2 hrq.1.le c.length_le)\n      _ â‰¤ Cq := hCq _\n      \n    have B\n    calc\n      finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n              (Â«exprâ€– â€–â‚ŠÂ» (p (c.blocks_fun i))) *\n            rp ^ n =\n          finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n            (Â«exprâ€– â€–â‚ŠÂ» (p (c.blocks_fun i)) * rp ^ c.blocks_fun i) :=\n        by simp only [finset.prod_mul_distrib, finset.prod_pow_eq_pow_sum, c.sum_blocks_fun]\n      _ â‰¤\n          finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n            Cp :=\n        finset.prod_le_prod' fun i _ => hCp _\n      _ = Cp ^ c.length := by simp\n      _ â‰¤ Cp ^ n := pow_le_pow hCp1 c.length_le\n      \n    calc\n      Â«exprâ€– â€–â‚ŠÂ» (q.comp_along_composition p c) * r ^ n â‰¤\n          Â«exprâ€– â€–â‚ŠÂ» (q c.length) *\n              finset.prod_univ\n                \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n                (Â«exprâ€– â€–â‚ŠÂ» (p (c.blocks_fun i))) *\n            r ^ n :=\n        mul_le_mul' (q.comp_along_composition_nnnorm p c) le_rfl\n      _ =\n          Â«exprâ€– â€–â‚ŠÂ» (q c.length) * rq ^ n *\n              (finset.prod_univ\n                  \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n                  (Â«exprâ€– â€–â‚ŠÂ» (p (c.blocks_fun i))) *\n                rp ^ n) *\n            r0 ^ n :=\n        by\n        simp only [r, mul_pow]\n        ring\n      _ â‰¤ Cq * Cp ^ n * r0 ^ n := mul_le_mul' (mul_le_mul' A B) le_rfl\n      _ = Cq / 4 ^ n := by\n        simp only [r0]\n        field_simp [mul_pow, (zero_lt_one.trans_le hCp1).ne']\n        ring\n      \n  refine' âŸ¨r, r_pos, nnreal.summable_of_le I _âŸ©\n  simp_rw [div_eq_mul_inv]\n  refine' summable.mul_left _ _\n  have : âˆ€ n : â„•, has_sum (fun c : composition n => (4 ^ n : nnreal)â»Â¹) (2 ^ (n - 1) / 4 ^ n) :=\n    by\n    intro n\n    convert has_sum_fintype fun c : composition n => (4 ^ n : nnreal)â»Â¹\n    simp [finset.card_univ, composition_card, div_eq_mul_inv]\n  refine' nnreal.summable_sigma.2 âŸ¨fun n => (this n).summable, (nnreal.summable_nat_add_iff 1).1 _âŸ©\n  convert (nnreal.summable_geometric (nnreal.div_lt_one_of_lt one_lt_two)).mul_left (1 / 4)\n  ext1 n\n  rw [(this _).tsum_eq, add_tsub_cancel_right]\n  field_simp [â† mul_assoc, pow_succ', mul_pow, show (4 : nnreal) = 2 * 2 from (two_mul 2).symm, mul_right_comm]\n#align comp_summable_nnreal comp_summable_nnreal\n\n",
 "comp_remove_zero":
 "@[simp]\ntheorem comp_remove_zero (q : formal_multilinear_series ğ•œ F G) (p : formal_multilinear_series ğ•œ E F) :\n    q.comp p.remove_zero = q.comp p := by\n  ext n\n  simp [formal_multilinear_series.comp]\n#align comp_remove_zero comp_remove_zero\n\n",
 "comp_partial_sum_target_tendsto_at_top":
 "/-- The auxiliary set corresponding to the composition of partial sums asymptotically contains\nall possible compositions. -/\ntheorem comp_partial_sum_target_tendsto_at_top : tendsto (fun N => comp_partial_sum_target 0 N N) at_top at_top :=\n  by\n  apply monotone.tendsto_at_top_finset\n  Â· intro m n hmn a ha\n    have : âˆ€ i, i < m â†’ i < n := fun i hi => lt_of_lt_of_le hi hmn\n    tidy\n  Â· rintro âŸ¨n, câŸ©\n    simp only [mem_comp_partial_sum_target_iff]\n    obtain âŸ¨n, hnâŸ© : BddAbove â†‘(finset.univ.image fun i : fin c.length => c.blocks_fun i) := finset.bdd_above _\n    refine'\n      âŸ¨max n c.length + 1, bot_le, lt_of_le_of_lt (le_max_right n c.length) (lt_add_one _), fun j =>\n        lt_of_le_of_lt (le_trans _ (le_max_left _ _)) (lt_add_one _)âŸ©\n    apply hn\n    simp only [Finset.mem_image_of_mem, Finset.mem_coe, finset.mem_univ]\n#align comp_partial_sum_target_tendsto_at_top comp_partial_sum_target_tendsto_at_top\n\n",
 "comp_partial_sum_target_subset_image_comp_partial_sum_source":
 "theorem comp_partial_sum_target_subset_image_comp_partial_sum_source (m M N : â„•) (i : Î£n, composition n)\n    (hi : i âˆˆ comp_partial_sum_target_set m M N) :\n    âˆƒ (j : _)(hj : j âˆˆ comp_partial_sum_source m M N), i = comp_change_of_variables m M N j hj :=\n  by\n  rcases i with âŸ¨n, câŸ©\n  refine' âŸ¨âŸ¨c.length, c.blocks_funâŸ©, _, _âŸ©\n  Â· simp only [comp_partial_sum_target_set, Set.mem_setOf_eq] at hi\n    simp only [mem_comp_partial_sum_source_iff, hi.left, hi.right, true_and_iff, and_true_iff]\n    exact fun a => c.one_le_blocks' _\n  Â· dsimp [comp_change_of_variables]\n    rw [composition.sigma_eq_iff_blocks_eq]\n    simp only [composition.blocks_fun, composition.blocks, subtype.coe_eta, nth_le_map']\n    conv_lhs => rw [â† of_fn_nth_le c.blocks]\n#align\n  comp_partial_sum_target_subset_image_comp_partial_sum_source comp_partial_sum_target_subset_image_comp_partial_sum_source\n\n",
 "comp_partial_sum":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/-- Composing the partial sums of two multilinear series coincides with the sum over all\ncompositions in `comp_partial_sum_target 0 N N`. This is precisely the motivation for the\ndefinition of `comp_partial_sum_target`. -/\ntheorem comp_partial_sum (q : formal_multilinear_series ğ•œ F G) (p : formal_multilinear_series ğ•œ E F) (N : â„•) (z : E) :\n    q.partial_sum N\n        (finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n          (finset.Ico 1 N) (p i fun j => z)) =\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n        (comp_partial_sum_target 0 N N) (q.comp_along_composition p i.2 fun j => z) :=\n  by\n  -- we expand the composition, using the multilinearity of `q` to expand along each coordinate.\n  suffices H :\n    finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (Finset.range N)\n        (finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n          (fintype.pi_finset fun i : fin n => finset.Ico 1 N) (q n fun i : fin n => p (r i) fun j => z)) =\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n        (comp_partial_sum_target 0 N N) (q.comp_along_composition p i.2 fun j => z)\n  Â· simpa only [formal_multilinear_series.partial_sum, continuous_multilinear_map.map_sum_finset] using H\n  -- rewrite the first sum as a big sum over a sigma type, in the finset\n  -- `comp_partial_sum_target 0 N N`\n  rw [finset.range_eq_Ico, finset.sum_sigma']\n  -- use `comp_change_of_variables_sum`, saying that this change of variables respects sums\n  apply comp_change_of_variables_sum 0 N N\n  rintro âŸ¨k, blocks_funâŸ© H\n  apply congr _ (comp_change_of_variables_length 0 N N H).symm\n  intros\n  rw [â† comp_change_of_variables_blocks_fun 0 N N H]\n  rfl\n#align comp_partial_sum comp_partial_sum\n\n",
 "comp_id":
 "@[simp]\ntheorem comp_id (p : formal_multilinear_series ğ•œ E F) : p.comp (id ğ•œ E) = p :=\n  by\n  ext1 n\n  dsimp [formal_multilinear_series.comp]\n  rw [finset.sum_eq_single (composition.ones n)]\n  show comp_along_composition p (id ğ•œ E) (composition.ones n) = p n\n  Â· ext v\n    rw [comp_along_composition_apply]\n    apply p.congr (composition.ones_length n)\n    intros\n    rw [apply_composition_ones]\n    refine' congr_arg v _\n    rw [Fin.ext_iff, Fin.coe_castLe, Fin.val_mk, Fin.val_mk]\n  show âˆ€ b : composition n, b âˆˆ finset.univ â†’ b â‰  composition.ones n â†’ comp_along_composition p (id ğ•œ E) b = 0\n  Â· intro b _ hb\n    obtain âŸ¨k, hk, lt_kâŸ© : âˆƒ (k : â„•)(H : k âˆˆ composition.blocks b), 1 < k := composition.ne_ones_iff.1 hb\n    obtain âŸ¨i, i_lt, hiâŸ© : âˆƒ (i : â„•)(h : i < b.blocks.length), b.blocks.nth_le i h = k := nth_le_of_mem hk\n    let j : fin b.length := âŸ¨i, b.blocks_length â–¸ i_ltâŸ©\n    have A : 1 < b.blocks_fun j := by convert lt_k\n    ext v\n    rw [comp_along_composition_apply, continuous_multilinear_map.zero_apply]\n    apply continuous_multilinear_map.map_coord_zero _ j\n    dsimp [apply_composition]\n    rw [id_apply_ne_one _ _ (ne_of_gt A)]\n    rfl\n  Â· simp\n#align comp_id comp_id\n\n",
 "comp_continuous_linear_map_apply_composition":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n@[simp]\ntheorem comp_continuous_linear_map_apply_composition {n : â„•} (p : formal_multilinear_series ğ•œ F G)\n    (f : Â«expr â†’L[ ] Â» E ğ•œ F) (c : composition n) (v : fin n â†’ E) :\n    (p.comp_continuous_linear_map f).apply_composition c v = p.apply_composition c (f âˆ˜ v) := by\n  simp [apply_composition]\n#align comp_continuous_linear_map_apply_composition comp_continuous_linear_map_apply_composition\n\n",
 "comp_coeff_zero''":
 "/-- The `0`-th coefficient of `q.comp p` is `q 0`. When `p` goes from `E` to `E`, this can be\nexpressed as a direct equality -/\ntheorem comp_coeff_zero'' (q : formal_multilinear_series ğ•œ E F) (p : formal_multilinear_series ğ•œ E E) :\n    (q.comp p) 0 = q 0 := by\n  ext v\n  exact q.comp_coeff_zero p _ _\n#align comp_coeff_zero'' comp_coeff_zero''\n\n",
 "comp_coeff_zero'":
 "@[simp]\ntheorem comp_coeff_zero' (q : formal_multilinear_series ğ•œ F G) (p : formal_multilinear_series ğ•œ E F) (v : fin 0 â†’ E) :\n    (q.comp p) 0 v = q 0 fun i => 0 :=\n  q.comp_coeff_zero p v _\n#align comp_coeff_zero' comp_coeff_zero'\n\n",
 "comp_coeff_zero":
 "/-- The `0`-th coefficient of `q.comp p` is `q 0`. Since these maps are multilinear maps in zero\nvariables, but on different spaces, we can not state this directly, so we state it when applied to\narbitrary vectors (which have to be the zero vector). -/\ntheorem comp_coeff_zero (q : formal_multilinear_series ğ•œ F G) (p : formal_multilinear_series ğ•œ E F) (v : fin 0 â†’ E)\n    (v' : fin 0 â†’ F) : (q.comp p) 0 v = q 0 v' :=\n  by\n  let c : composition 0 := composition.ones 0\n  dsimp [formal_multilinear_series.comp]\n  have : {c} = (finset.univ : Finset (composition 0)) := by\n    apply finset.eq_of_subset_of_card_le <;> simp [finset.card_univ, composition_card 0]\n  rw [â† this, finset.sum_singleton, comp_along_composition_apply]\n  symm\n  congr\n#align comp_coeff_zero comp_coeff_zero\n\n",
 "comp_coeff_one":
 "/-- The first coefficient of a composition of formal multilinear series is the composition of the\nfirst coefficients seen as continuous linear maps. -/\ntheorem comp_coeff_one (q : formal_multilinear_series ğ•œ F G) (p : formal_multilinear_series ğ•œ E F) (v : fin 1 â†’ E) :\n    (q.comp p) 1 v = q 1 fun i => p 1 v :=\n  by\n  have : {composition.ones 1} = (finset.univ : Finset (composition 1)) :=\n    finset.eq_univ_of_card _ (by simp [composition_card])\n  simp only [formal_multilinear_series.comp, comp_along_composition_apply, â† this, finset.sum_singleton]\n  refine' q.congr (by simp) fun i hi1 hi2 => _\n  simp only [apply_composition_ones]\n  exact p.congr rfl fun j hj1 hj2 => by congr\n#align comp_coeff_one comp_coeff_one\n\n",
 "comp_change_of_variables_sum":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/-- `comp_change_of_variables m M N` is a bijection between `comp_partial_sum_source m M N`\nand `comp_partial_sum_target m M N`, yielding equal sums for functions that correspond to each\nother under the bijection. As `comp_change_of_variables m M N` is a dependent function, stating\nthat it is a bijection is not directly possible, but the consequence on sums can be stated\nmore easily. -/\ntheorem comp_change_of_variables_sum {Î± : Type _} [add_comm_monoid Î±] (m M N : â„•) (f : (Î£n : â„•, fin n â†’ â„•) â†’ Î±)\n    (g : (Î£n, composition n) â†’ Î±)\n    (h : âˆ€ (e) (he : e âˆˆ comp_partial_sum_source m M N), f e = g (comp_change_of_variables m M N e he)) :\n    finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n        (comp_partial_sum_source m M N) (f e) =\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n        (comp_partial_sum_target m M N) (g e) :=\n  by\n  apply finset.sum_bij (comp_change_of_variables m M N)\n  -- We should show that the correspondance we have set up is indeed a bijection\n  -- between the index sets of the two sums.\n  -- 1 - show that the image belongs to `comp_partial_sum_target m N N`\n  Â· rintro âŸ¨k, blocks_funâŸ© H\n    rw [mem_comp_partial_sum_source_iff] at H\n    simp only [mem_comp_partial_sum_target_iff, composition.length, composition.blocks, H.left, map_of_fn, length_of_fn,\n      true_and_iff, comp_change_of_variables]\n    intro j\n    simp only [composition.blocks_fun, (H.right _).right, nth_le_of_fn']\n  -- 2 - show that the composition gives the `comp_along_composition` application\n  Â· rintro âŸ¨k, blocks_funâŸ© H\n    rw [h]\n  -- 3 - show that the map is injective\n  Â· rintro âŸ¨k, blocks_funâŸ© âŸ¨k', blocks_fun'âŸ© H H' heq\n    obtain rfl : k = k' := by\n      have := (comp_change_of_variables_length m M N H).symm\n      rwa [HEq, comp_change_of_variables_length] at this\n    congr\n    funext i\n    calc\n      blocks_fun i = (comp_change_of_variables m M N _ H).2.blocks_fun _ :=\n        (comp_change_of_variables_blocks_fun m M N H i).symm\n      _ = (comp_change_of_variables m M N _ H').2.blocks_fun _ :=\n        by\n        apply composition.blocks_fun_congr <;> try rw [HEq]\n        rfl\n      _ = blocks_fun' i := comp_change_of_variables_blocks_fun m M N H' i\n      \n  -- 4 - show that the map is surjective\n  Â· intro i hi\n    apply comp_partial_sum_target_subset_image_comp_partial_sum_source m M N i\n    simpa [comp_partial_sum_target] using hi\n#align comp_change_of_variables_sum comp_change_of_variables_sum\n\n",
 "comp_change_of_variables_length":
 "@[simp]\ntheorem comp_change_of_variables_length (m M N : â„•) {i : Î£n, fin n â†’ â„•} (hi : i âˆˆ comp_partial_sum_source m M N) :\n    composition.length (comp_change_of_variables m M N i hi).2 = i.1 :=\n  by\n  rcases i with âŸ¨k, blocks_funâŸ©\n  dsimp [comp_change_of_variables]\n  simp only [composition.length, map_of_fn, length_of_fn]\n#align comp_change_of_variables_length comp_change_of_variables_length\n\n",
 "comp_change_of_variables_blocks_fun":
 "theorem comp_change_of_variables_blocks_fun (m M N : â„•) {i : Î£n, fin n â†’ â„•} (hi : i âˆˆ comp_partial_sum_source m M N)\n    (j : fin i.1) :\n    (comp_change_of_variables m M N i hi).2.blocks_fun âŸ¨j, (comp_change_of_variables_length m M N hi).symm â–¸ j.2âŸ© =\n      i.2 j :=\n  by\n  rcases i with âŸ¨n, fâŸ©\n  dsimp [composition.blocks_fun, composition.blocks, comp_change_of_variables]\n  simp only [map_of_fn, nth_le_of_fn', Function.comp_apply]\n  apply congr_arg\n  exact Fin.eta _ _\n#align comp_change_of_variables_blocks_fun comp_change_of_variables_blocks_fun\n\n",
 "comp_assoc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n-- the fact that we have a left inverse is essentially `join_split_wrt_composition`,\n-- but we need to massage it to take care of the dependent setting.\n-- the fact that we have a right inverse is essentially `split_wrt_composition_join`,\n-- but we need to massage it to take care of the dependent setting.\ntheorem comp_assoc (r : formal_multilinear_series ğ•œ G H) (q : formal_multilinear_series ğ•œ F G)\n    (p : formal_multilinear_series ğ•œ E F) : (r.comp q).comp p = r.comp (q.comp p) :=\n  by\n  ext (n v)\n  /- First, rewrite the two compositions appearing in the theorem as two sums over complicated\n    sigma types, as in the description of the proof above. -/\n  let f : (Î£a : composition n, composition a.length) â†’ H := fun c =>\n    r c.2.length (apply_composition q c.2 (apply_composition p c.1 v))\n  let g : (Î£c : composition n, âˆ€ i : fin c.length, composition (c.blocks_fun i)) â†’ H := fun c =>\n    r c.1.length fun i : fin c.1.length => q (c.2 i).length (apply_composition p (c.2 i) (v âˆ˜ c.1.embedding i))\n  suffices\n    finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\" (f c) =\n      finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\" (g c)\n    by\n    simpa only [formal_multilinear_series.comp, continuous_multilinear_map.sum_apply, comp_along_composition_apply,\n      continuous_multilinear_map.map_sum, finset.sum_sigma', apply_composition]\n  /- Now, we use `composition.sigma_equiv_sigma_pi n` to change\n    variables in the second sum, and check that we get exactly the same sums. -/\n  rw [â† (sigma_equiv_sigma_pi n).sum_comp]\n  /- To check that we have the same terms, we should check that we apply the same component of\n    `r`, and the same component of `q`, and the same component of `p`, to the same coordinate of\n    `v`. This is true by definition, but at each step one needs to convince Lean that the types\n    one considers are the same, using a suitable congruence lemma to avoid dependent type issues.\n    This dance has to be done three times, one for `r`, one for `q` and one for `p`.-/\n  apply finset.sum_congr rfl\n  rintro âŸ¨a, bâŸ© _\n  dsimp [f, g, sigma_equiv_sigma_pi]\n  -- check that the `r` components are the same. Based on `composition.length_gather`\n  apply r.congr (composition.length_gather a b).symm\n  intro i hi1 hi2\n  -- check that the `q` components are the same. Based on `length_sigma_composition_aux`\n  apply q.congr (length_sigma_composition_aux a b _).symm\n  intro j hj1 hj2\n  -- check that the `p` components are the same. Based on `blocks_fun_sigma_composition_aux`\n  apply p.congr (blocks_fun_sigma_composition_aux a b _ _).symm\n  intro k hk1 hk2\n  -- finally, check that the coordinates of `v` one is using are the same. Based on\n  -- `size_up_to_size_up_to_add`.\n  refine' congr_arg v (fin.eq_of_veq _)\n  dsimp [composition.embedding]\n  rw [size_up_to_size_up_to_add _ _ hi1 hj1, add_assoc]\n#align comp_assoc comp_assoc\n\n",
 "comp_along_composition_norm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/-- The norm of `q.comp_along_composition p c` is controlled by the product of\nthe norms of the relevant bits of `q` and `p`. -/\ntheorem comp_along_composition_norm {n : â„•} (q : formal_multilinear_series ğ•œ F G) (p : formal_multilinear_series ğ•œ E F)\n    (c : composition n) :\n    Â«exprâ€– â€–Â» (q.comp_along_composition p c) â‰¤\n      Â«exprâ€– â€–Â» (q c.length) *\n        finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n          (Â«exprâ€– â€–Â» (p (c.blocks_fun i))) :=\n  continuous_multilinear_map.op_norm_le_bound _\n    (mul_nonneg (norm_nonneg _) (finset.prod_nonneg fun i hi => norm_nonneg _)) (comp_along_composition_bound _ _ _)\n#align comp_along_composition_norm comp_along_composition_norm\n\n",
 "comp_along_composition_nnnorm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–â‚ŠÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–â‚ŠÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–â‚ŠÂ» -/\ntheorem comp_along_composition_nnnorm {n : â„•} (q : formal_multilinear_series ğ•œ F G)\n    (p : formal_multilinear_series ğ•œ E F) (c : composition n) :\n    Â«exprâ€– â€–â‚ŠÂ» (q.comp_along_composition p c) â‰¤\n      Â«exprâ€– â€–â‚ŠÂ» (q c.length) *\n        finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n          (Â«exprâ€– â€–â‚ŠÂ» (p (c.blocks_fun i))) :=\n  by\n  rw [â† nnreal.coe_le_coe]\n  push_cast\n  exact q.comp_along_composition_norm p c\n#align comp_along_composition_nnnorm comp_along_composition_nnnorm\n\n",
 "comp_along_composition_bound":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/-- The norm of `f.comp_along_composition p c` is controlled by the product of\nthe norms of the relevant bits of `f` and `p`. -/\ntheorem comp_along_composition_bound {n : â„•} (p : formal_multilinear_series ğ•œ E F) (c : composition n)\n    (f : continuous_multilinear_map ğ•œ (fun i : fin c.length => F) G) (v : fin n â†’ E) :\n    Â«exprâ€– â€–Â» (f.comp_along_composition p c v) â‰¤\n      Â«exprâ€– â€–Â» f *\n          finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n            (Â«exprâ€– â€–Â» (p (c.blocks_fun i))) *\n        finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n          (Â«exprâ€– â€–Â» (v i)) :=\n  calc\n    Â«exprâ€– â€–Â» (f.comp_along_composition p c v) = Â«exprâ€– â€–Â» (f (p.apply_composition c v)) := rfl\n    _ â‰¤\n        Â«exprâ€– â€–Â» f *\n          finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n            (Â«exprâ€– â€–Â» (p.apply_composition c v i)) :=\n      continuous_multilinear_map.le_op_norm _ _\n    _ â‰¤\n        Â«exprâ€– â€–Â» f *\n          finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n            (Â«exprâ€– â€–Â» (p (c.blocks_fun i)) *\n              finset.prod_univ\n                \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n                (Â«exprâ€– â€–Â» ((v âˆ˜ c.embedding i) j))) :=\n      by\n      apply mul_le_mul_of_nonneg_left _ (norm_nonneg _)\n      refine' finset.prod_le_prod (fun i hi => norm_nonneg _) fun i hi => _\n      apply continuous_multilinear_map.le_op_norm\n    _ =\n        Â«exprâ€– â€–Â» f *\n            finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n              (Â«exprâ€– â€–Â» (p (c.blocks_fun i))) *\n          finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n            (Â«exprâ€– â€–Â» ((v âˆ˜ c.embedding i) j)) :=\n      by rw [finset.prod_mul_distrib, mul_assoc]\n    _ =\n        Â«exprâ€– â€–Â» f *\n            finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n              (Â«exprâ€– â€–Â» (p (c.blocks_fun i))) *\n          finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n            (Â«exprâ€– â€–Â» (v i)) :=\n      by\n      rw [â† c.blocks_fin_equiv.prod_comp, â† finset.univ_sigma_univ, finset.prod_sigma]\n      congr\n    \n#align comp_along_composition_bound comp_along_composition_bound\n\n",
 "comp_along_composition_apply":
 "@[simp]\ntheorem comp_along_composition_apply {n : â„•} (q : formal_multilinear_series ğ•œ F G) (p : formal_multilinear_series ğ•œ E F)\n    (c : composition n) (v : fin n â†’ E) : (q.comp_along_composition p c) v = q c.length (p.apply_composition c v) :=\n  rfl\n#align comp_along_composition_apply comp_along_composition_apply\n\n",
 "comp":
 "/-- If two functions `g` and `f` are analytic respectively at `f x` and `x`, then `g âˆ˜ f` is\nanalytic at `x`. -/\ntheorem analytic_at.comp {g : F â†’ G} {f : E â†’ F} {x : E} (hg : analytic_at ğ•œ g (f x)) (hf : analytic_at ğ•œ f x) :\n    analytic_at ğ•œ (g âˆ˜ f) x :=\n  let âŸ¨q, hqâŸ© := hg\n  let âŸ¨p, hpâŸ© := hf\n  (hq.comp hp).analytic_at\n#align analytic_at.comp analytic_at.comp\n\n",
 "blocks_fun_sigma_composition_aux":
 "theorem blocks_fun_sigma_composition_aux (a : composition n) (b : composition a.length) (i : fin b.length)\n    (j : fin (blocks_fun b i)) :\n    blocks_fun (sigma_composition_aux a b âŸ¨i, (length_gather a b).symm â–¸ i.2âŸ©)\n        âŸ¨j, (length_sigma_composition_aux a b i).symm â–¸ j.2âŸ© =\n      blocks_fun a (embedding b i j) :=\n  show nthLe (nthLe _ _ _) _ _ = nthLe a.blocks _ _\n    by\n    rw [nth_le_of_eq (nth_le_split_wrt_composition _ _ _), nth_le_drop', nth_le_take']\n    rfl\n#align blocks_fun_sigma_composition_aux blocks_fun_sigma_composition_aux\n\n",
 "apply_composition_update":
 "/-- Technical lemma stating how `p.apply_composition` commutes with updating variables. This\nwill be the key point to show that functions constructed from `apply_composition` retain\nmultilinearity. -/\ntheorem apply_composition_update (p : formal_multilinear_series ğ•œ E F) {n : â„•} (c : composition n) (j : fin n)\n    (v : fin n â†’ E) (z : E) :\n    p.apply_composition c (function.update v j z) =\n      function.update (p.apply_composition c v) (c.index j)\n        (p (c.blocks_fun (c.index j)) (function.update (v âˆ˜ c.embedding (c.index j)) (c.inv_embedding j) z)) :=\n  by\n  ext k\n  by_cases h : k = c.index j\n  Â· rw [h]\n    let r : fin (c.blocks_fun (c.index j)) â†’ fin n := c.embedding (c.index j)\n    simp only [function.update_same]\n    change p (c.blocks_fun (c.index j)) (function.update v j z âˆ˜ r) = _\n    let j' := c.inv_embedding j\n    suffices B : function.update v j z âˆ˜ r = function.update (v âˆ˜ r) j' z\n    Â· rw [B]\n    suffices C : function.update v (r j') z âˆ˜ r = function.update (v âˆ˜ r) j' z\n    Â· convert C\n      exact (c.embedding_comp_inv j).symm\n    exact function.update_comp_eq_of_injective _ (c.embedding _).injective _ _\n  Â· simp only [h, function.update_eq_self, function.update_noteq, ne.def, not_false_iff]\n    let r : fin (c.blocks_fun k) â†’ fin n := c.embedding k\n    change p (c.blocks_fun k) (function.update v j z âˆ˜ r) = p (c.blocks_fun k) (v âˆ˜ r)\n    suffices B : function.update v j z âˆ˜ r = v âˆ˜ r\n    Â· rw [B]\n    apply Function.update_comp_eq_of_not_mem_range\n    rwa [c.mem_range_embedding_iff']\n#align apply_composition_update apply_composition_update\n\n",
 "apply_composition_single":
 "theorem apply_composition_single (p : formal_multilinear_series ğ•œ E F) {n : â„•} (hn : 0 < n) (v : fin n â†’ E) :\n    p.apply_composition (composition.single n hn) v = fun j => p n v :=\n  by\n  ext j\n  refine' p.congr (by simp) fun i hi1 hi2 => _\n  dsimp\n  congr 1\n  convert composition.single_embedding hn âŸ¨i, hi2âŸ©\n  cases j\n  have : j_val = 0 := le_bot_iff.1 (Nat.lt_succ_iff.1 j_property)\n  unfold_coes\n  congr <;> try first |assumption|simp\n#align apply_composition_single apply_composition_single\n\n",
 "apply_composition_ones":
 "/-\nCopyright (c) 2020 SÃ©bastien GouÃ«zel. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: SÃ©bastien GouÃ«zel, Johan Commelin\n-/\ntheorem apply_composition_ones (p : formal_multilinear_series ğ•œ E F) (n : â„•) :\n    p.apply_composition (composition.ones n) = fun v i => p 1 fun _ => v (Fin.castLe (composition.length_le _) i) :=\n  by\n  funext v i\n  apply p.congr (composition.ones_blocks_fun _ _)\n  intro j hjn hj1\n  obtain rfl : j = 0 := by linarith\n  refine' congr_arg v _\n  rw [Fin.ext_iff, Fin.coe_castLe, composition.ones_embedding, Fin.val_mk]\n#align apply_composition_ones apply_composition_ones\n\n"}