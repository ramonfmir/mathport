{"exists_extension_norm_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/-- Hahn-Banach theorem for continuous linear functions over `ğ•œ` satisyfing `is_R_or_C ğ•œ`. -/\ntheorem exists_extension_norm_eq (p : Subspace ğ•œ F) (f : Â«expr â†’L[ ] Â» p ğ•œ ğ•œ) :\n    âˆƒ g : Â«expr â†’L[ ] Â» F ğ•œ ğ•œ, (âˆ€ x : p, g x = f x) âˆ§ Â«exprâ€– â€–Â» g = Â«exprâ€– â€–Â» f :=\n  by\n  letI : Module (exprâ„) F := restrict_scalars.module (exprâ„) ğ•œ F\n  letI : IsScalarTower (exprâ„) ğ•œ F := RestrictScalars.isScalarTower _ _ _\n  letI : NormedSpace (exprâ„) F := NormedSpace.restrictScalars _ ğ•œ _\n  -- Let `fr: p â†’L[â„] â„` be the real part of `f`.\n  let fr := re_clm.comp (f.restrict_scalars (exprâ„))\n  have fr_apply : âˆ€ x, fr x = re (f x) := by\n    intro x\n    rfl\n  -- Use the real version to get a norm-preserving extension of `fr`, which\n  -- we'll call `g : F â†’L[â„] â„`.\n  rcases real.exists_extension_norm_eq (p.restrict_scalars (exprâ„)) fr with âŸ¨g, âŸ¨hextends, hnormeqâŸ©âŸ©\n  -- Now `g` can be extended to the `F â†’L[ğ•œ] ğ•œ` we need.\n  refine' âŸ¨g.extend_to_ğ•œ, _âŸ©\n  -- It is an extension of `f`.\n  have h : âˆ€ x : p, g.extend_to_ğ•œ x = f x := by\n    intro x\n    rw [continuous_linear_map.extend_to_ğ•œ_apply, â† Submodule.coe_smul, hextends, hextends]\n    have : (fr x : ğ•œ) - I * â†‘(fr (Â«expr â€¢ Â» I x)) = (re (f x) : ğ•œ) - (I : ğ•œ) * re (f (Â«expr â€¢ Â» (I : ğ•œ) x)) := by rfl\n    rw [this]\n    apply ext\n    Â·\n      simp only [add_zero, Algebra.id.smul_eq_mul, I_re, of_real_im, AddMonoidHom.map_add, zero_sub, I_im',\n        MulZeroClass.zero_mul, of_real_re, eq_self_iff_true, sub_zero, mul_neg, of_real_neg, mul_re,\n        MulZeroClass.mul_zero, sub_neg_eq_add, ContinuousLinearMap.map_smul]\n    Â·\n      simp only [Algebra.id.smul_eq_mul, I_re, of_real_im, AddMonoidHom.map_add, zero_sub, I_im', MulZeroClass.zero_mul,\n        of_real_re, mul_neg, mul_im, zero_add, of_real_neg, mul_re, sub_neg_eq_add, ContinuousLinearMap.map_smul]\n  -- And we derive the equality of the norms by bounding on both sides.\n  refine' âŸ¨h, le_antisymm _ _âŸ©\n  Â·\n    calc\n      Â«exprâ€– â€–Â» g.extend_to_ğ•œ = Â«exprâ€– â€–Â» g := g.norm_extend_to_ğ•œ\n      _ = Â«exprâ€– â€–Â» fr := hnormeq\n      _ â‰¤ Â«exprâ€– â€–Â» re_clm * Â«exprâ€– â€–Â» f := (continuous_linear_map.op_norm_comp_le _ _)\n      _ = Â«exprâ€– â€–Â» f := by rw [re_clm_norm, one_mul]\n      \n  Â· exact f.op_norm_le_bound g.extend_to_ğ•œ.op_norm_nonneg fun x => h x â–¸ g.extend_to_ğ•œ.le_op_norm x\n#align exists_extension_norm_eq exists_extension_norm_eq\n\n",
 "exists_dual_vector''":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/-- Variant of Hahn-Banach, eliminating the hypothesis that `x` be nonzero, but only ensuring that\n    the dual element has norm at most `1` (this can not be improved for the trivial\n    vector space). -/\ntheorem exists_dual_vector'' (x : E) : âˆƒ g : Â«expr â†’L[ ] Â» E ğ•œ ğ•œ, Â«exprâ€– â€–Â» g â‰¤ 1 âˆ§ g x = Â«exprâ€– â€–Â» x :=\n  by\n  by_cases hx : x = 0\n  Â· refine' âŸ¨0, by simp, _âŸ©\n    symm\n    simp [hx]\n  Â· rcases exists_dual_vector ğ•œ x hx with âŸ¨g, g_norm, g_eqâŸ©\n    exact âŸ¨g, g_norm.le, g_eqâŸ©\n#align exists_dual_vector'' exists_dual_vector''\n\n",
 "exists_dual_vector'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/-- Variant of Hahn-Banach, eliminating the hypothesis that `x` be nonzero, and choosing\n    the dual element arbitrarily when `x = 0`. -/\ntheorem exists_dual_vector' [Nontrivial E] (x : E) : âˆƒ g : Â«expr â†’L[ ] Â» E ğ•œ ğ•œ, Â«exprâ€– â€–Â» g = 1 âˆ§ g x = Â«exprâ€– â€–Â» x :=\n  by\n  by_cases hx : x = 0\n  Â· obtain âŸ¨y, hyâŸ© := exists_ne (0 : E)\n    obtain âŸ¨g, hgâŸ© : âˆƒ g : Â«expr â†’L[ ] Â» E ğ•œ ğ•œ, Â«exprâ€– â€–Â» g = 1 âˆ§ g y = Â«exprâ€– â€–Â» y := exists_dual_vector ğ•œ y hy\n    refine' âŸ¨g, hg.left, _âŸ©\n    simp [hx]\n  Â· exact exists_dual_vector ğ•œ x hx\n#align exists_dual_vector' exists_dual_vector'\n\n",
 "exists_dual_vector":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âˆ™ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âˆ™ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âˆ™ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/-- Corollary of Hahn-Banach.  Given a nonzero element `x` of a normed space, there exists an\n    element of the dual space, of norm `1`, whose value on `x` is `â€–xâ€–`. -/\ntheorem exists_dual_vector (x : E) (h : x â‰  0) : âˆƒ g : Â«expr â†’L[ ] Â» E ğ•œ ğ•œ, Â«exprâ€– â€–Â» g = 1 âˆ§ g x = Â«exprâ€– â€–Â» x :=\n  by\n  let p : Submodule ğ•œ E := Â«expr âˆ™ Â» ğ•œ x\n  let f := Â«expr â€¢ Â» (Â«exprâ€– â€–Â» x : ğ•œ) (coord ğ•œ x h)\n  obtain âŸ¨g, hgâŸ© := exists_extension_norm_eq p f\n  refine' âŸ¨g, _, _âŸ©\n  Â· rw [hg.2, coord_norm']\n  Â·\n    calc\n      g x = g (âŸ¨x, mem_span_singleton_self xâŸ© : Â«expr âˆ™ Â» ğ•œ x) := by rw [coe_mk]\n      _ = (Â«expr â€¢ Â» (Â«exprâ€– â€–Â» x : ğ•œ) (coord ğ•œ x h)) (âŸ¨x, mem_span_singleton_self xâŸ© : Â«expr âˆ™ Â» ğ•œ x) := by rw [â† hg.1]\n      _ = Â«exprâ€– â€–Â» x := by simp\n      \n#align exists_dual_vector exists_dual_vector\n\n",
 "coord_norm'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\ntheorem coord_norm' {x : E} (h : x â‰  0) : Â«exprâ€– â€–Â» (Â«expr â€¢ Â» (Â«exprâ€– â€–Â» x : ğ•œ) (coord ğ•œ x h)) = 1 := by\n  rw [norm_smul, is_R_or_C.norm_coe_norm, coord_norm, mul_inv_cancel (mt norm_eq_zero.mp h)]\n#align coord_norm' coord_norm'\n\n"}