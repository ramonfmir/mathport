{"exists_extension_norm_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/-- Hahn-Banach theorem for continuous linear functions over `𝕜` satisyfing `is_R_or_C 𝕜`. -/\ntheorem exists_extension_norm_eq (p : Subspace 𝕜 F) (f : «expr →L[ ] » p 𝕜 𝕜) :\n    ∃ g : «expr →L[ ] » F 𝕜 𝕜, (∀ x : p, g x = f x) ∧ «expr‖ ‖» g = «expr‖ ‖» f :=\n  by\n  letI : Module (exprℝ) F := restrict_scalars.module (exprℝ) 𝕜 F\n  letI : IsScalarTower (exprℝ) 𝕜 F := RestrictScalars.isScalarTower _ _ _\n  letI : NormedSpace (exprℝ) F := NormedSpace.restrictScalars _ 𝕜 _\n  -- Let `fr: p →L[ℝ] ℝ` be the real part of `f`.\n  let fr := re_clm.comp (f.restrict_scalars (exprℝ))\n  have fr_apply : ∀ x, fr x = re (f x) := by\n    intro x\n    rfl\n  -- Use the real version to get a norm-preserving extension of `fr`, which\n  -- we'll call `g : F →L[ℝ] ℝ`.\n  rcases real.exists_extension_norm_eq (p.restrict_scalars (exprℝ)) fr with ⟨g, ⟨hextends, hnormeq⟩⟩\n  -- Now `g` can be extended to the `F →L[𝕜] 𝕜` we need.\n  refine' ⟨g.extend_to_𝕜, _⟩\n  -- It is an extension of `f`.\n  have h : ∀ x : p, g.extend_to_𝕜 x = f x := by\n    intro x\n    rw [continuous_linear_map.extend_to_𝕜_apply, ← Submodule.coe_smul, hextends, hextends]\n    have : (fr x : 𝕜) - I * ↑(fr («expr • » I x)) = (re (f x) : 𝕜) - (I : 𝕜) * re (f («expr • » (I : 𝕜) x)) := by rfl\n    rw [this]\n    apply ext\n    ·\n      simp only [add_zero, Algebra.id.smul_eq_mul, I_re, of_real_im, AddMonoidHom.map_add, zero_sub, I_im',\n        MulZeroClass.zero_mul, of_real_re, eq_self_iff_true, sub_zero, mul_neg, of_real_neg, mul_re,\n        MulZeroClass.mul_zero, sub_neg_eq_add, ContinuousLinearMap.map_smul]\n    ·\n      simp only [Algebra.id.smul_eq_mul, I_re, of_real_im, AddMonoidHom.map_add, zero_sub, I_im', MulZeroClass.zero_mul,\n        of_real_re, mul_neg, mul_im, zero_add, of_real_neg, mul_re, sub_neg_eq_add, ContinuousLinearMap.map_smul]\n  -- And we derive the equality of the norms by bounding on both sides.\n  refine' ⟨h, le_antisymm _ _⟩\n  ·\n    calc\n      «expr‖ ‖» g.extend_to_𝕜 = «expr‖ ‖» g := g.norm_extend_to_𝕜\n      _ = «expr‖ ‖» fr := hnormeq\n      _ ≤ «expr‖ ‖» re_clm * «expr‖ ‖» f := (continuous_linear_map.op_norm_comp_le _ _)\n      _ = «expr‖ ‖» f := by rw [re_clm_norm, one_mul]\n      \n  · exact f.op_norm_le_bound g.extend_to_𝕜.op_norm_nonneg fun x => h x ▸ g.extend_to_𝕜.le_op_norm x\n#align exists_extension_norm_eq exists_extension_norm_eq\n\n",
 "exists_dual_vector''":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/-- Variant of Hahn-Banach, eliminating the hypothesis that `x` be nonzero, but only ensuring that\n    the dual element has norm at most `1` (this can not be improved for the trivial\n    vector space). -/\ntheorem exists_dual_vector'' (x : E) : ∃ g : «expr →L[ ] » E 𝕜 𝕜, «expr‖ ‖» g ≤ 1 ∧ g x = «expr‖ ‖» x :=\n  by\n  by_cases hx : x = 0\n  · refine' ⟨0, by simp, _⟩\n    symm\n    simp [hx]\n  · rcases exists_dual_vector 𝕜 x hx with ⟨g, g_norm, g_eq⟩\n    exact ⟨g, g_norm.le, g_eq⟩\n#align exists_dual_vector'' exists_dual_vector''\n\n",
 "exists_dual_vector'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/-- Variant of Hahn-Banach, eliminating the hypothesis that `x` be nonzero, and choosing\n    the dual element arbitrarily when `x = 0`. -/\ntheorem exists_dual_vector' [Nontrivial E] (x : E) : ∃ g : «expr →L[ ] » E 𝕜 𝕜, «expr‖ ‖» g = 1 ∧ g x = «expr‖ ‖» x :=\n  by\n  by_cases hx : x = 0\n  · obtain ⟨y, hy⟩ := exists_ne (0 : E)\n    obtain ⟨g, hg⟩ : ∃ g : «expr →L[ ] » E 𝕜 𝕜, «expr‖ ‖» g = 1 ∧ g y = «expr‖ ‖» y := exists_dual_vector 𝕜 y hy\n    refine' ⟨g, hg.left, _⟩\n    simp [hx]\n  · exact exists_dual_vector 𝕜 x hx\n#align exists_dual_vector' exists_dual_vector'\n\n",
 "exists_dual_vector":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/-- Corollary of Hahn-Banach.  Given a nonzero element `x` of a normed space, there exists an\n    element of the dual space, of norm `1`, whose value on `x` is `‖x‖`. -/\ntheorem exists_dual_vector (x : E) (h : x ≠ 0) : ∃ g : «expr →L[ ] » E 𝕜 𝕜, «expr‖ ‖» g = 1 ∧ g x = «expr‖ ‖» x :=\n  by\n  let p : Submodule 𝕜 E := «expr ∙ » 𝕜 x\n  let f := «expr • » («expr‖ ‖» x : 𝕜) (coord 𝕜 x h)\n  obtain ⟨g, hg⟩ := exists_extension_norm_eq p f\n  refine' ⟨g, _, _⟩\n  · rw [hg.2, coord_norm']\n  ·\n    calc\n      g x = g (⟨x, mem_span_singleton_self x⟩ : «expr ∙ » 𝕜 x) := by rw [coe_mk]\n      _ = («expr • » («expr‖ ‖» x : 𝕜) (coord 𝕜 x h)) (⟨x, mem_span_singleton_self x⟩ : «expr ∙ » 𝕜 x) := by rw [← hg.1]\n      _ = «expr‖ ‖» x := by simp\n      \n#align exists_dual_vector exists_dual_vector\n\n",
 "coord_norm'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem coord_norm' {x : E} (h : x ≠ 0) : «expr‖ ‖» («expr • » («expr‖ ‖» x : 𝕜) (coord 𝕜 x h)) = 1 := by\n  rw [norm_smul, is_R_or_C.norm_coe_norm, coord_norm, mul_inv_cancel (mt norm_eq_zero.mp h)]\n#align coord_norm' coord_norm'\n\n"}