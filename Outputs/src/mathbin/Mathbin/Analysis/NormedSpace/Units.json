{"subset_compl_ball":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/-- The `nonunits` in a complete normed ring are contained in the complement of the ball of radius\n`1` centered at `1 : R`. -/\ntheorem subset_compl_ball : nonunits R ⊆ «expr ᶜ» (metric.ball (1 : R) 1) :=\n  Set.subset_compl_comm.mp fun x hx => by\n    simpa [sub_sub_self, units.coe_one_sub] using\n      (units.one_sub (1 - x) (by rwa [metric.mem_ball, dist_eq_norm, norm_sub_rev] at hx)).is_unit\n#align subset_compl_ball subset_compl_ball\n\n",
 "open_embedding_coe":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/-- In a normed ring, the coercion from `Rˣ` (equipped with the induced topology from the\nembedding in `R × R`) to `R` is an open embedding. -/\ntheorem open_embedding_coe : open_embedding (coe : «expr ˣ» R → R) :=\n  open_embedding_of_continuous_injective_open continuous_coe ext is_open_map_coe\n#align open_embedding_coe open_embedding_coe\n\n",
 "nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\nprotected theorem nhds (x : «expr ˣ» R) : { x : R | is_unit x } ∈ (nhds) (x : R) :=\n  is_open.mem_nhds units.is_open x.is_unit\n#align nhds nhds\n\n",
 "is_open_map_coe":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵐᵒᵖ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/-- In a normed ring, the coercion from `Rˣ` (equipped with the induced topology from the\nembedding in `R × R`) to `R` is an open map. -/\ntheorem is_open_map_coe : is_open_map (coe : «expr ˣ» R → R) :=\n  by\n  rw [is_open_map_iff_nhds_le]\n  intro x s\n  rw [mem_map, mem_nhds_induced]\n  rintro ⟨t, ht, hts⟩\n  obtain ⟨u, hu, v, hv, huvt⟩ :\n    ∃ u : set R, u ∈ (nhds) ↑x ∧ ∃ v : set («expr ᵐᵒᵖ» R), v ∈ (nhds) (op ↑x⁻¹) ∧ lower_set.prod u v ⊆ t := by\n    simpa [embed_product, mem_nhds_prod_iff] using ht\n  have : u ∩ «expr ⁻¹' » (op ∘ Ring.inverse) v ∩ Set.range (coe : «expr ˣ» R → R) ∈ (nhds) ↑x :=\n    by\n    refine' inter_mem (inter_mem hu _) (units.nhds x)\n    refine' (continuous_op.continuous_at.comp (inverse_continuous_at x)).preimage_mem_nhds _\n    simpa using hv\n  refine' mem_of_superset this _\n  rintro _ ⟨⟨huy, hvy⟩, ⟨y, rfl⟩⟩\n  have : embed_product R y ∈ lower_set.prod u v := ⟨huy, by simpa using hvy⟩\n  simpa using hts (huvt this)\n#align is_open_map_coe is_open_map_coe\n\n",
 "is_open":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/-\nCopyright (c) 2020 Heather Macbeth. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Heather Macbeth\n-/\n-- to make `coe_add` true definitionally, for convenience\n/-- The group of units of a complete normed ring is an open subset of the ring. -/\nprotected theorem is_open : is_open { x : R | is_unit x } :=\n  by\n  nontriviality R\n  apply metric.is_open_iff.mpr\n  rintro x' ⟨x, rfl⟩\n  refine' ⟨(«expr‖ ‖» (↑x⁻¹ : R))⁻¹, _root_.inv_pos.mpr (units.norm_pos x⁻¹), _⟩\n  intro y hy\n  rw [metric.mem_ball, dist_eq_norm] at hy\n  exact (x.unit_of_nearby y hy).is_unit\n#align is_open is_open\n\n",
 "is_closed":
 "-- The `nonunits` in a complete normed ring are a closed set\nprotected theorem is_closed : is_closed (nonunits R) :=\n  units.is_open.is_closed_compl\n#align is_closed is_closed\n\n",
 "inverse_one_sub_nth_order":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem inverse_one_sub_nth_order (n : ℕ) :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" ((nhds) 0)\n      (inverse ((1 : R) - t) =\n        finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (range n)\n            (t ^ i) +\n          t ^ n * inverse (1 - t)) :=\n  by\n  simp only [eventually_iff, metric.mem_nhds_iff]\n  use 1, by norm_num\n  intro t ht\n  simp only [mem_ball, dist_zero_right] at ht\n  simp only [inverse_one_sub t ht, Set.mem_setOf_eq]\n  have h : 1 = ((range n).sum fun i => t ^ i) * units.one_sub t ht + t ^ n :=\n    by\n    simp only [units.coe_one_sub]\n    rw [geom_sum_mul_neg]\n    simp\n  rw [← one_mul ↑(units.one_sub t ht)⁻¹, h, add_mul]\n  congr\n  · rw [mul_assoc, (units.one_sub t ht).mul_inv]\n    simp\n  · simp only [units.coe_one_sub]\n    rw [← add_mul, geom_sum_mul_neg]\n    simp\n#align inverse_one_sub_nth_order inverse_one_sub_nth_order\n\n",
 "inverse_one_sub_norm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =O[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem inverse_one_sub_norm : «expr =O[ ] » (fun t : R => inverse (1 - t)) ((nhds) 0) (fun t => 1 : R → exprℝ) :=\n  by\n  simp only [is_O, is_O_with, eventually_iff, metric.mem_nhds_iff]\n  refine' ⟨«expr‖ ‖» (1 : R) + 1, (2 : exprℝ)⁻¹, by norm_num, _⟩\n  intro t ht\n  simp only [ball, dist_zero_right, Set.mem_setOf_eq] at ht\n  have ht' : «expr‖ ‖» t < 1 := by\n    have : (2 : exprℝ)⁻¹ < 1 := by cancel_denoms\n    linarith\n  simp only [inverse_one_sub t ht', norm_one, mul_one, Set.mem_setOf_eq]\n  change\n    «expr‖ ‖»\n        («expr∑' , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , »\" (t ^ n)) ≤\n      _\n  have := normed_ring.tsum_geometric_of_norm_lt_1 t ht'\n  have : (1 - «expr‖ ‖» t)⁻¹ ≤ 2 := by\n    rw [← inv_inv (2 : exprℝ)]\n    refine' inv_le_inv_of_le (by norm_num) _\n    have : (2 : exprℝ)⁻¹ + (2 : exprℝ)⁻¹ = 1 := by ring\n    linarith\n  linarith\n#align inverse_one_sub_norm inverse_one_sub_norm\n\n",
 "inverse_one_sub":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem inverse_one_sub (t : R) (h : «expr‖ ‖» t < 1) : inverse (1 - t) = ↑(units.one_sub t h)⁻¹ := by\n  rw [← inverse_unit (units.one_sub t h), units.coe_one_sub]\n#align inverse_one_sub inverse_one_sub\n\n",
 "inverse_continuous_at":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =o[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/-- The function `inverse` is continuous at each unit of `R`. -/\ntheorem inverse_continuous_at (x : «expr ˣ» R) : continuous_at inverse (x : R) :=\n  by\n  have h_is_o : «expr =o[ ] » (fun t : R => inverse (↑x + t) - ↑x⁻¹) ((nhds) 0) (fun _ => 1 : R → exprℝ) :=\n    (inverse_add_norm_diff_first_order x).trans_is_o (is_o.norm_left <| is_o_id_const one_ne_zero)\n  have h_lim : tendsto (fun y : R => y - x) ((nhds) x) ((nhds) 0) :=\n    by\n    refine' tendsto_zero_iff_norm_tendsto_zero.mpr _\n    exact tendsto_iff_norm_tendsto_zero.mp tendsto_id\n  rw [continuous_at, tendsto_iff_norm_tendsto_zero, inverse_unit]\n  simpa [(· ∘ ·)] using h_is_o.norm_left.tendsto_div_nhds_zero.comp h_lim\n#align inverse_continuous_at inverse_continuous_at\n\n",
 "inverse_add_nth_order":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/-- The formula\n`inverse (x + t) = (∑ i in range n, (- x⁻¹ * t) ^ i) * x⁻¹ + (- x⁻¹ * t) ^ n * inverse (x + t)`\nholds for `t` sufficiently small. -/\ntheorem inverse_add_nth_order (x : «expr ˣ» R) (n : ℕ) :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" ((nhds) 0)\n      (inverse ((x : R) + t) =\n        finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (range n)\n              ((-↑x⁻¹ * t) ^ i) *\n            ↑x⁻¹ +\n          (-↑x⁻¹ * t) ^ n * inverse (x + t)) :=\n  by\n  refine' (inverse_add x).mp _\n  have hzero : tendsto (fun t : R => -↑x⁻¹ * t) ((nhds) 0) ((nhds) 0) :=\n    by\n    convert ((mul_left_continuous (-(↑x⁻¹ : R))).tendsto 0).comp tendsto_id\n    simp\n  refine' (hzero.eventually (inverse_one_sub_nth_order n)).mp (eventually_of_forall _)\n  simp only [neg_mul, sub_neg_eq_add]\n  intro t h1 h2\n  have h := congr_arg (fun a : R => a * ↑x⁻¹) h1\n  dsimp at h\n  convert h\n  rw [add_mul, mul_assoc]\n  simp [h2.symm]\n#align inverse_add_nth_order inverse_add_nth_order\n\n",
 "inverse_add_norm_diff_second_order":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =O[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/-- The function\n`λ t, inverse (x + t) - x⁻¹ + x⁻¹ * t * x⁻¹`\nis `O(t ^ 2)` as `t → 0`. -/\ntheorem inverse_add_norm_diff_second_order (x : «expr ˣ» R) :\n    «expr =O[ ] » (fun t : R => inverse (↑x + t) - ↑x⁻¹ + ↑x⁻¹ * t * ↑x⁻¹) ((nhds) 0) fun t => «expr‖ ‖» t ^ 2 :=\n  by\n  convert inverse_add_norm_diff_nth_order x 2\n  ext t\n  simp only [range_succ, range_one, sum_insert, mem_singleton, sum_singleton, not_false_iff, one_ne_zero, pow_zero,\n    add_mul, pow_one, one_mul, neg_mul, sub_add_eq_sub_sub_swap, sub_neg_eq_add]\n#align inverse_add_norm_diff_second_order inverse_add_norm_diff_second_order\n\n",
 "inverse_add_norm_diff_nth_order":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =O[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/-- The function\n`λ t, inverse (x + t) - (∑ i in range n, (- x⁻¹ * t) ^ i) * x⁻¹`\nis `O(t ^ n)` as `t → 0`. -/\ntheorem inverse_add_norm_diff_nth_order (x : «expr ˣ» R) (n : ℕ) :\n    «expr =O[ ] »\n      (fun t : R =>\n        inverse (↑x + t) -\n          finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (range n)\n              ((-↑x⁻¹ * t) ^ i) *\n            ↑x⁻¹)\n      ((nhds) (0 : R)) fun t => «expr‖ ‖» t ^ n :=\n  by\n  by_cases h : n = 0\n  · simpa [h] using inverse_add_norm x\n  have hn : 0 < n := nat.pos_of_ne_zero h\n  simp [is_O_iff]\n  cases' is_O_iff.mp (inverse_add_norm x) with C hC\n  use C * «expr‖ ‖» (1 : exprℝ) * «expr‖ ‖» (↑x⁻¹ : R) ^ n\n  have h :\n    eventually_eq ((nhds) (0 : R))\n      (fun t =>\n        inverse (↑x + t) -\n          finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (range n)\n              ((-↑x⁻¹ * t) ^ i) *\n            ↑x⁻¹)\n      fun t => (-↑x⁻¹ * t) ^ n * inverse (x + t) :=\n    by\n    refine' (inverse_add_nth_order x n).mp (eventually_of_forall _)\n    intro t ht\n    convert congr_arg (fun a => a - (range n).sum (pow (-↑x⁻¹ * t)) * ↑x⁻¹) ht\n    simp\n  refine' h.mp (hC.mp (eventually_of_forall _))\n  intro t _ hLHS\n  simp only [neg_mul] at hLHS\n  rw [hLHS]\n  refine' le_trans (norm_mul_le _ _) _\n  have h' : «expr‖ ‖» ((-(↑x⁻¹ * t)) ^ n) ≤ «expr‖ ‖» (↑x⁻¹ : R) ^ n * «expr‖ ‖» t ^ n :=\n    by\n    calc\n      «expr‖ ‖» ((-(↑x⁻¹ * t)) ^ n) ≤ «expr‖ ‖» (-(↑x⁻¹ * t)) ^ n := norm_pow_le' _ hn\n      _ = «expr‖ ‖» (↑x⁻¹ * t) ^ n := by rw [norm_neg]\n      _ ≤ («expr‖ ‖» (↑x⁻¹ : R) * «expr‖ ‖» t) ^ n := _\n      _ = «expr‖ ‖» (↑x⁻¹ : R) ^ n * «expr‖ ‖» t ^ n := mul_pow _ _ n\n      \n    exact pow_le_pow_of_le_left (norm_nonneg _) (norm_mul_le (↑x⁻¹) t) n\n  have h'' : 0 ≤ «expr‖ ‖» (↑x⁻¹ : R) ^ n * «expr‖ ‖» t ^ n := by\n    refine' mul_nonneg _ _ <;> exact pow_nonneg (norm_nonneg _) n\n  nlinarith [norm_nonneg (inverse (↑x + t))]\n#align inverse_add_norm_diff_nth_order inverse_add_norm_diff_nth_order\n\n",
 "inverse_add_norm_diff_first_order":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =O[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/-- The function `λ t, inverse (x + t) - x⁻¹` is `O(t)` as `t → 0`. -/\ntheorem inverse_add_norm_diff_first_order (x : «expr ˣ» R) :\n    «expr =O[ ] » (fun t : R => inverse (↑x + t) - ↑x⁻¹) ((nhds) 0) fun t => «expr‖ ‖» t := by\n  simpa using inverse_add_norm_diff_nth_order x 1\n#align inverse_add_norm_diff_first_order inverse_add_norm_diff_first_order\n\n",
 "inverse_add_norm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =O[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- The function `λ t, inverse (x + t)` is O(1) as `t → 0`. -/\ntheorem inverse_add_norm (x : «expr ˣ» R) :\n    «expr =O[ ] » (fun t : R => inverse (↑x + t)) ((nhds) 0) fun t => (1 : exprℝ) :=\n  by\n  simp only [is_O_iff, norm_one, mul_one]\n  cases' is_O_iff.mp (@inverse_one_sub_norm R _ _) with C hC\n  use C * «expr‖ ‖» ((x⁻¹ : «expr ˣ» R) : R)\n  have hzero : tendsto (fun t => -(↑x⁻¹ : R) * t) ((nhds) 0) ((nhds) 0) :=\n    by\n    convert ((mul_left_continuous (-↑x⁻¹ : R)).tendsto 0).comp tendsto_id\n    simp\n  refine' (inverse_add x).mp ((hzero.eventually hC).mp (eventually_of_forall _))\n  intro t bound iden\n  rw [iden]\n  simp at bound\n  have hmul := norm_mul_le (inverse (1 + ↑x⁻¹ * t)) ↑x⁻¹\n  nlinarith [norm_nonneg (↑x⁻¹ : R)]\n#align inverse_add_norm inverse_add_norm\n\n",
 "inverse_add":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- The formula `inverse (x + t) = inverse (1 + x⁻¹ * t) * x⁻¹` holds for `t` sufficiently small. -/\ntheorem inverse_add (x : «expr ˣ» R) :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" ((nhds) 0)\n      (inverse ((x : R) + t) = inverse (1 + ↑x⁻¹ * t) * ↑x⁻¹) :=\n  by\n  nontriviality R\n  rw [eventually_iff, metric.mem_nhds_iff]\n  have hinv : 0 < («expr‖ ‖» (↑x⁻¹ : R))⁻¹ := by cancel_denoms\n  use («expr‖ ‖» (↑x⁻¹ : R))⁻¹, hinv\n  intro t ht\n  simp only [mem_ball, dist_zero_right] at ht\n  have ht' : «expr‖ ‖» (-↑x⁻¹ * t) < 1 :=\n    by\n    refine' lt_of_le_of_lt (norm_mul_le _ _) _\n    rw [norm_neg]\n    refine' lt_of_lt_of_le (mul_lt_mul_of_pos_left ht x⁻¹.norm_pos) _\n    cancel_denoms\n  have hright := inverse_one_sub (-↑x⁻¹ * t) ht'\n  have hleft := inverse_unit (x.add t ht)\n  simp only [neg_mul, sub_neg_eq_add] at hright\n  simp only [units.coe_add] at hleft\n  simp [hleft, hright, units.add]\n#align inverse_add inverse_add\n\n",
 "eq_top_of_norm_lt_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/-- An ideal which contains an element within `1` of `1 : R` is the unit ideal. -/\ntheorem eq_top_of_norm_lt_one (I : ideal R) {x : R} (hxI : x ∈ I) (hx : «expr‖ ‖» (1 - x) < 1) : I = «expr⊤» :=\n  let u := units.one_sub (1 - x) hx\n  I.eq_top_iff_one.mpr <| by simpa only [show u.inv * x = 1 by simp] using I.mul_mem_left u.inv hxI\n#align eq_top_of_norm_lt_one eq_top_of_norm_lt_one\n\n",
 "closure_ne_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/-- The `ideal.closure` of a proper ideal in a complete normed ring is proper. -/\ntheorem closure_ne_top (I : ideal R) (hI : I ≠ «expr⊤») : I.closure ≠ «expr⊤» :=\n  by\n  have h := closure_minimal (coe_subset_nonunits hI) nonunits.is_closed\n  simpa only [I.closure.eq_top_iff_one, ne.def] using mt (@h 1) one_not_mem_nonunits\n#align closure_ne_top closure_ne_top\n\n",
 "closure_eq":
 "/-- The `ideal.closure` of a maximal ideal in a complete normed ring is the ideal itself. -/\ntheorem is_maximal.closure_eq {I : ideal R} (hI : I.is_maximal) : I.closure = I :=\n  (hI.eq_of_le (I.closure_ne_top hI.ne_top) subset_closure).symm\n#align is_maximal.closure_eq is_maximal.closure_eq\n\n"}