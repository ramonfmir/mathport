{"sub":
 "theorem is_compact_operator.sub [topological_add_group M₄] {f g : M₁ → M₄} (hf : is_compact_operator f)\n    (hg : is_compact_operator g) : is_compact_operator (f - g) := by rw [sub_eq_add_neg] <;> exact hf.add hg.neg\n#align is_compact_operator.sub is_compact_operator.sub\n\n",
 "smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem is_compact_operator.smul {S : Type _} [monoid S] [DistribMulAction S M₂] [has_continuous_const_smul S M₂]\n    {f : M₁ → M₂} (hf : is_compact_operator f) (c : S) : is_compact_operator («expr • » c f) :=\n  let ⟨K, hK, hKf⟩ := hf\n  ⟨«expr • » c K, hK.image <| continuous_id.const_smul c, mem_of_superset hKf fun x hx => smul_mem_smul_set hx⟩\n#align is_compact_operator.smul is_compact_operator.smul\n\n",
 "restrict'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/-- If a compact operator preserves a complete submodule, its restriction to that submodule is\ncompact.\n\nNote that, following mathlib's convention in linear algebra, `restrict` designates the restriction\nof an endomorphism `f : E →ₗ E` to an endomorphism `f' : ↥V →ₗ ↥V`. To prove that the restriction\n`f' : ↥U →ₛₗ ↥V` of a compact operator `f : E →ₛₗ F` is compact, apply\n`is_compact_operator.cod_restrict` to `f ∘ U.subtypeL`, which is compact by\n`is_compact_operator.comp_clm`. -/\ntheorem is_compact_operator.restrict' [separated_space M₂] {f : «expr →ₗ[ ] » M₂ R₂ M₂} (hf : is_compact_operator f)\n    {V : submodule R₂ M₂} (hV : ∀ v ∈ V, f v ∈ V) [hcomplete : complete_space V] :\n    is_compact_operator (f.restrict hV) :=\n  hf.restrict hV (complete_space_coe_iff_is_complete.mp hcomplete).is_closed\n#align is_compact_operator.restrict' is_compact_operator.restrict'\n\n",
 "restrict":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/-- If a compact operator preserves a closed submodule, its restriction to that submodule is\ncompact.\n\nNote that, following mathlib's convention in linear algebra, `restrict` designates the restriction\nof an endomorphism `f : E →ₗ E` to an endomorphism `f' : ↥V →ₗ ↥V`. To prove that the restriction\n`f' : ↥U →ₛₗ ↥V` of a compact operator `f : E →ₛₗ F` is compact, apply\n`is_compact_operator.cod_restrict` to `f ∘ U.subtypeL`, which is compact by\n`is_compact_operator.comp_clm`. -/\ntheorem is_compact_operator.restrict {f : «expr →ₗ[ ] » M₁ R₁ M₁} (hf : is_compact_operator f) {V : submodule R₁ M₁}\n    (hV : ∀ v ∈ V, f v ∈ V) (h_closed : is_closed (V : set M₁)) : is_compact_operator (f.restrict hV) :=\n  (hf.comp_clm V.subtypeL).cod_restrict (SetLike.forall.2 hV) h_closed\n#align is_compact_operator.restrict is_compact_operator.restrict\n\n",
 "neg":
 "theorem is_compact_operator.neg [has_continuous_neg M₄] {f : M₁ → M₄} (hf : is_compact_operator f) :\n    is_compact_operator (-f) :=\n  let ⟨K, hK, hKf⟩ := hf\n  ⟨-K, hK.neg, mem_of_superset hKf fun x (hx : f x ∈ K) => set.neg_mem_neg.mpr hx⟩\n#align is_compact_operator.neg is_compact_operator.neg\n\n",
 "mk_of_is_compact_operator_to_linear_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n@[simp]\ntheorem continuous_linear_map.mk_of_is_compact_operator_to_linear_map {f : «expr →ₛₗ[ ] » M₁ σ₁₂ M₂}\n    (hf : is_compact_operator f) :\n    (continuous_linear_map.mk_of_is_compact_operator hf : «expr →ₛₗ[ ] » M₁ σ₁₂ M₂) = f :=\n  rfl\n#align\n  continuous_linear_map.mk_of_is_compact_operator_to_linear_map continuous_linear_map.mk_of_is_compact_operator_to_linear_map\n\n",
 "mk_of_is_compact_operator_mem_compact_operator":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\ntheorem continuous_linear_map.mk_of_is_compact_operator_mem_compact_operator {f : «expr →ₛₗ[ ] » M₁ σ₁₂ M₂}\n    (hf : is_compact_operator f) : continuous_linear_map.mk_of_is_compact_operator hf ∈ compact_operator σ₁₂ M₁ M₂ :=\n  hf\n#align\n  continuous_linear_map.mk_of_is_compact_operator_mem_compact_operator continuous_linear_map.mk_of_is_compact_operator_mem_compact_operator\n\n",
 "is_compact_operator_zero":
 "/-\nCopyright (c) 2022 Anatole Dedecker. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Anatole Dedecker\n-/\ntheorem is_compact_operator_zero {M₁ M₂ : Type _} [Zero M₁] [topological_space M₁] [topological_space M₂] [Zero M₂] :\n    is_compact_operator (0 : M₁ → M₂) :=\n  ⟨{0}, is_compact_singleton, mem_of_superset univ_mem fun x _ => rfl⟩\n#align is_compact_operator_zero is_compact_operator_zero\n\n",
 "is_compact_operator_of_tendsto":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\ntheorem is_compact_operator_of_tendsto {ι 𝕜₁ 𝕜₂ : Type _} [nontrivially_normed_field 𝕜₁] [normed_field 𝕜₂]\n    {σ₁₂ : «expr →+* » 𝕜₁ 𝕜₂} {M₁ M₂ : Type _} [seminormed_add_comm_group M₁] [add_comm_group M₂] [normed_space 𝕜₁ M₁]\n    [Module 𝕜₂ M₂] [uniform_space M₂] [uniform_add_group M₂] [has_continuous_const_smul 𝕜₂ M₂] [t2_space M₂]\n    [complete_space M₂] {l : filter ι} [l.ne_bot] {F : ι → «expr →SL[ ] » M₁ σ₁₂ M₂} {f : «expr →SL[ ] » M₁ σ₁₂ M₂}\n    (hf : tendsto F l ((nhds) f))\n    (hF :\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" l\n        (is_compact_operator (F i))) :\n    is_compact_operator f :=\n  is_closed_set_of_is_compact_operator.mem_of_tendsto hf hF\n#align is_compact_operator_of_tendsto is_compact_operator_of_tendsto\n\n",
 "is_compact_operator_iff_is_compact_closure_image_closed_ball":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem is_compact_operator_iff_is_compact_closure_image_closed_ball [has_continuous_const_smul 𝕜₂ M₂] [t2_space M₂]\n    (f : «expr →ₛₗ[ ] » M₁ σ₁₂ M₂) {r : exprℝ} (hr : 0 < r) :\n    is_compact_operator f ↔ is_compact (closure <| «expr '' » f (metric.closed_ball 0 r)) :=\n  ⟨fun hf => hf.is_compact_closure_image_closed_ball r, fun hf =>\n    (is_compact_operator_iff_exists_mem_nhds_is_compact_closure_image f).mpr\n      ⟨metric.closed_ball 0 r, closed_ball_mem_nhds _ hr, hf⟩⟩\n#align\n  is_compact_operator_iff_is_compact_closure_image_closed_ball is_compact_operator_iff_is_compact_closure_image_closed_ball\n\n",
 "is_compact_operator_iff_is_compact_closure_image_ball":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem is_compact_operator_iff_is_compact_closure_image_ball [has_continuous_const_smul 𝕜₂ M₂] [t2_space M₂]\n    (f : «expr →ₛₗ[ ] » M₁ σ₁₂ M₂) {r : exprℝ} (hr : 0 < r) :\n    is_compact_operator f ↔ is_compact (closure <| «expr '' » f (metric.ball 0 r)) :=\n  ⟨fun hf => hf.is_compact_closure_image_ball r, fun hf =>\n    (is_compact_operator_iff_exists_mem_nhds_is_compact_closure_image f).mpr ⟨metric.ball 0 r, ball_mem_nhds _ hr, hf⟩⟩\n#align is_compact_operator_iff_is_compact_closure_image_ball is_compact_operator_iff_is_compact_closure_image_ball\n\n",
 "is_compact_operator_iff_image_closed_ball_subset_compact":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem is_compact_operator_iff_image_closed_ball_subset_compact [has_continuous_const_smul 𝕜₂ M₂]\n    (f : «expr →ₛₗ[ ] » M₁ σ₁₂ M₂) {r : exprℝ} (hr : 0 < r) :\n    is_compact_operator f ↔ ∃ K : set M₂, is_compact K ∧ «expr '' » f (metric.closed_ball 0 r) ⊆ K :=\n  ⟨fun hf => hf.image_closed_ball_subset_compact r, fun ⟨K, hK, hKr⟩ =>\n    (is_compact_operator_iff_exists_mem_nhds_image_subset_compact f).mpr\n      ⟨metric.closed_ball 0 r, closed_ball_mem_nhds _ hr, K, hK, hKr⟩⟩\n#align is_compact_operator_iff_image_closed_ball_subset_compact is_compact_operator_iff_image_closed_ball_subset_compact\n\n",
 "is_compact_operator_iff_image_ball_subset_compact":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem is_compact_operator_iff_image_ball_subset_compact [has_continuous_const_smul 𝕜₂ M₂]\n    (f : «expr →ₛₗ[ ] » M₁ σ₁₂ M₂) {r : exprℝ} (hr : 0 < r) :\n    is_compact_operator f ↔ ∃ K : set M₂, is_compact K ∧ «expr '' » f (metric.ball 0 r) ⊆ K :=\n  ⟨fun hf => hf.image_ball_subset_compact r, fun ⟨K, hK, hKr⟩ =>\n    (is_compact_operator_iff_exists_mem_nhds_image_subset_compact f).mpr\n      ⟨metric.ball 0 r, ball_mem_nhds _ hr, K, hK, hKr⟩⟩\n#align is_compact_operator_iff_image_ball_subset_compact is_compact_operator_iff_image_ball_subset_compact\n\n",
 "is_compact_operator_iff_exists_mem_nhds_is_compact_closure_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem is_compact_operator_iff_exists_mem_nhds_is_compact_closure_image [t2_space M₂] (f : M₁ → M₂) :\n    is_compact_operator f ↔ ∃ V ∈ ((nhds) 0 : filter M₁), is_compact (closure <| «expr '' » f V) :=\n  by\n  rw [is_compact_operator_iff_exists_mem_nhds_image_subset_compact]\n  exact\n    ⟨fun ⟨V, hV, K, hK, hKV⟩ => ⟨V, hV, is_compact_closure_of_subset_compact hK hKV⟩, fun ⟨V, hV, hVc⟩ =>\n      ⟨V, hV, closure («expr '' » f V), hVc, subset_closure⟩⟩\n#align\n  is_compact_operator_iff_exists_mem_nhds_is_compact_closure_image is_compact_operator_iff_exists_mem_nhds_is_compact_closure_image\n\n",
 "is_compact_operator_iff_exists_mem_nhds_image_subset_compact":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem is_compact_operator_iff_exists_mem_nhds_image_subset_compact (f : M₁ → M₂) :\n    is_compact_operator f ↔ ∃ V ∈ ((nhds) 0 : filter M₁), ∃ K : set M₂, is_compact K ∧ «expr '' » f V ⊆ K :=\n  ⟨fun ⟨K, hK, hKf⟩ => ⟨«expr ⁻¹' » f K, hKf, K, hK, image_preimage_subset _ _⟩, fun ⟨V, hV, K, hK, hVK⟩ =>\n    ⟨K, hK, mem_of_superset hV (image_subset_iff.mp hVK)⟩⟩\n#align\n  is_compact_operator_iff_exists_mem_nhds_image_subset_compact is_compact_operator_iff_exists_mem_nhds_image_subset_compact\n\n",
 "is_compact_closure_image_of_vonN_bounded":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem is_compact_operator.is_compact_closure_image_of_vonN_bounded [t2_space M₂] {f : «expr →ₛₗ[ ] » M₁ σ₁₂ M₂}\n    (hf : is_compact_operator f) {S : set M₁} (hS : is_vonN_bounded 𝕜₁ S) : is_compact (closure <| «expr '' » f S) :=\n  let ⟨K, hK, hKf⟩ := hf.image_subset_compact_of_vonN_bounded hS\n  is_compact_closure_of_subset_compact hK hKf\n#align\n  is_compact_operator.is_compact_closure_image_of_vonN_bounded is_compact_operator.is_compact_closure_image_of_vonN_bounded\n\n",
 "is_compact_closure_image_of_bounded":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem is_compact_operator.is_compact_closure_image_of_bounded [has_continuous_const_smul 𝕜₂ M₂] [t2_space M₂]\n    {f : «expr →ₛₗ[ ] » M₁ σ₁₂ M₂} (hf : is_compact_operator f) {S : set M₁} (hS : metric.bounded S) :\n    is_compact (closure <| «expr '' » f S) :=\n  hf.is_compact_closure_image_of_vonN_bounded\n    (by rwa [normed_space.is_vonN_bounded_iff, ← metric.bounded_iff_is_bounded])\n#align is_compact_operator.is_compact_closure_image_of_bounded is_compact_operator.is_compact_closure_image_of_bounded\n\n",
 "is_compact_closure_image_closed_ball":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem is_compact_operator.is_compact_closure_image_closed_ball [has_continuous_const_smul 𝕜₂ M₂] [t2_space M₂]\n    {f : «expr →ₛₗ[ ] » M₁ σ₁₂ M₂} (hf : is_compact_operator f) (r : exprℝ) :\n    is_compact (closure <| «expr '' » f (metric.closed_ball 0 r)) :=\n  hf.is_compact_closure_image_of_vonN_bounded (normed_space.is_vonN_bounded_closed_ball 𝕜₁ M₁ r)\n#align is_compact_operator.is_compact_closure_image_closed_ball is_compact_operator.is_compact_closure_image_closed_ball\n\n",
 "is_compact_closure_image_ball":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem is_compact_operator.is_compact_closure_image_ball [has_continuous_const_smul 𝕜₂ M₂] [t2_space M₂]\n    {f : «expr →ₛₗ[ ] » M₁ σ₁₂ M₂} (hf : is_compact_operator f) (r : exprℝ) :\n    is_compact (closure <| «expr '' » f (metric.ball 0 r)) :=\n  hf.is_compact_closure_image_of_vonN_bounded (normed_space.is_vonN_bounded_ball 𝕜₁ M₁ r)\n#align is_compact_operator.is_compact_closure_image_ball is_compact_operator.is_compact_closure_image_ball\n\n",
 "is_closed_set_of_is_compact_operator":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n/-- The set of compact operators from a normed space to a complete topological vector space is\nclosed. -/\ntheorem is_closed_set_of_is_compact_operator {𝕜₁ 𝕜₂ : Type _} [nontrivially_normed_field 𝕜₁] [normed_field 𝕜₂]\n    {σ₁₂ : «expr →+* » 𝕜₁ 𝕜₂} {M₁ M₂ : Type _} [seminormed_add_comm_group M₁] [add_comm_group M₂] [normed_space 𝕜₁ M₁]\n    [Module 𝕜₂ M₂] [uniform_space M₂] [uniform_add_group M₂] [has_continuous_const_smul 𝕜₂ M₂] [t2_space M₂]\n    [complete_space M₂] : is_closed { f : «expr →SL[ ] » M₁ σ₁₂ M₂ | is_compact_operator f } :=\n  by\n  refine' is_closed_of_closure_subset _\n  rintro u hu\n  rw [mem_closure_iff_nhds_zero] at hu\n  suffices totally_bounded («expr '' » u (metric.closed_ball 0 1))\n    by\n    change is_compact_operator (u : «expr →ₛₗ[ ] » M₁ σ₁₂ M₂)\n    rw [is_compact_operator_iff_is_compact_closure_image_closed_ball (u : «expr →ₛₗ[ ] » M₁ σ₁₂ M₂) zero_lt_one]\n    exact is_compact_of_totally_bounded_is_closed this.closure is_closed_closure\n  rw [totally_bounded_iff_subset_finite_Union_nhds_zero]\n  intro U hU\n  rcases exists_nhds_zero_half hU with ⟨V, hV, hVU⟩\n  let SV : set M₁ × set M₂ := ⟨closed_ball 0 1, -V⟩\n  rcases hu { f | ∀ x ∈ SV.1, f x ∈ SV.2 }\n      (continuous_linear_map.has_basis_nhds_zero.mem_of_mem\n        ⟨normed_space.is_vonN_bounded_closed_ball _ _ _, neg_mem_nhds_zero M₂ hV⟩) with\n    ⟨v, hv, huv⟩\n  rcases totally_bounded_iff_subset_finite_Union_nhds_zero.mp\n      (hv.is_compact_closure_image_closed_ball 1).totally_bounded V hV with\n    ⟨T, hT, hTv⟩\n  have hTv : «expr '' » v (closed_ball 0 1) ⊆ _ := subset_closure.trans hTv\n  refine' ⟨T, hT, _⟩\n  rw [image_subset_iff, preimage_Union₂] at hTv⊢\n  intro x hx\n  specialize hTv hx\n  rw [mem_Union₂] at hTv⊢\n  rcases hTv with ⟨t, ht, htx⟩\n  refine' ⟨t, ht, _⟩\n  rw [mem_preimage, mem_vadd_set_iff_neg_vadd_mem, vadd_eq_add, neg_add_eq_sub] at htx⊢\n  convert hVU _ htx _ (huv x hx) using 1\n  rw [continuous_linear_map.sub_apply]\n  abel\n#align is_closed_set_of_is_compact_operator is_closed_set_of_is_compact_operator\n\n",
 "image_subset_compact_of_vonN_bounded":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem is_compact_operator.image_subset_compact_of_vonN_bounded {f : «expr →ₛₗ[ ] » M₁ σ₁₂ M₂}\n    (hf : is_compact_operator f) {S : set M₁} (hS : is_vonN_bounded 𝕜₁ S) :\n    ∃ K : set M₂, is_compact K ∧ «expr '' » f S ⊆ K :=\n  let ⟨K, hK, hKf⟩ := hf\n  let ⟨r, hr, hrS⟩ := hS hKf\n  let ⟨c, hc⟩ := normed_field.exists_lt_norm 𝕜₁ r\n  let this := ne_zero_of_norm_ne_zero (hr.trans hc).ne.symm\n  ⟨«expr • » (σ₁₂ c) K, hK.image <| continuous_id.const_smul (σ₁₂ c), by\n    rw [image_subset_iff, preimage_smul_setₛₗ _ _ _ f this.is_unit] <;> exact hrS c hc.le⟩\n#align is_compact_operator.image_subset_compact_of_vonN_bounded is_compact_operator.image_subset_compact_of_vonN_bounded\n\n",
 "image_subset_compact_of_bounded":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem is_compact_operator.image_subset_compact_of_bounded [has_continuous_const_smul 𝕜₂ M₂]\n    {f : «expr →ₛₗ[ ] » M₁ σ₁₂ M₂} (hf : is_compact_operator f) {S : set M₁} (hS : metric.bounded S) :\n    ∃ K : set M₂, is_compact K ∧ «expr '' » f S ⊆ K :=\n  hf.image_subset_compact_of_vonN_bounded (by rwa [normed_space.is_vonN_bounded_iff, ← metric.bounded_iff_is_bounded])\n#align is_compact_operator.image_subset_compact_of_bounded is_compact_operator.image_subset_compact_of_bounded\n\n",
 "image_closed_ball_subset_compact":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem is_compact_operator.image_closed_ball_subset_compact [has_continuous_const_smul 𝕜₂ M₂]\n    {f : «expr →ₛₗ[ ] » M₁ σ₁₂ M₂} (hf : is_compact_operator f) (r : exprℝ) :\n    ∃ K : set M₂, is_compact K ∧ «expr '' » f (metric.closed_ball 0 r) ⊆ K :=\n  hf.image_subset_compact_of_vonN_bounded (normed_space.is_vonN_bounded_closed_ball 𝕜₁ M₁ r)\n#align is_compact_operator.image_closed_ball_subset_compact is_compact_operator.image_closed_ball_subset_compact\n\n",
 "image_ball_subset_compact":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem is_compact_operator.image_ball_subset_compact [has_continuous_const_smul 𝕜₂ M₂] {f : «expr →ₛₗ[ ] » M₁ σ₁₂ M₂}\n    (hf : is_compact_operator f) (r : exprℝ) : ∃ K : set M₂, is_compact K ∧ «expr '' » f (metric.ball 0 r) ⊆ K :=\n  hf.image_subset_compact_of_vonN_bounded (normed_space.is_vonN_bounded_ball 𝕜₁ M₁ r)\n#align is_compact_operator.image_ball_subset_compact is_compact_operator.image_ball_subset_compact\n\n",
 "continuous_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem is_compact_operator.continuous_comp {f : M₁ → M₂} (hf : is_compact_operator f) {g : M₂ → M₃}\n    (hg : continuous g) : is_compact_operator (g ∘ f) :=\n  by\n  rcases hf with ⟨K, hK, hKf⟩\n  refine' ⟨«expr '' » g K, hK.image hg, mem_of_superset hKf _⟩\n  nth_rw 2 [preimage_comp]\n  exact preimage_mono (subset_preimage_image _ _)\n#align is_compact_operator.continuous_comp is_compact_operator.continuous_comp\n\n",
 "continuous":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n@[continuity]\ntheorem is_compact_operator.continuous {f : «expr →ₛₗ[ ] » M₁ σ₁₂ M₂} (hf : is_compact_operator f) : continuous f :=\n  by\n  letI : uniform_space M₂ := topological_add_group.to_uniform_space _\n  haveI : uniform_add_group M₂ := topological_add_comm_group_is_uniform\n  -- Since `f` is linear, we only need to show that it is continuous at zero.\n  -- Let `U` be a neighborhood of `0` in `M₂`.\n  refine' continuous_of_continuous_at_zero f fun U hU => _\n  rw [map_zero] at hU\n  -- The compactness of `f` gives us a compact set `K : set M₂` such that `f ⁻¹' K` is a\n  -- neighborhood of `0` in `M₁`.\n  rcases hf with ⟨K, hK, hKf⟩\n  -- But any compact set is totally bounded, hence Von-Neumann bounded. Thus, `K` absorbs `U`.\n  -- This gives `r > 0` such that `∀ a : 𝕜₂, r ≤ ‖a‖ → K ⊆ a • U`.\n  rcases hK.totally_bounded.is_vonN_bounded 𝕜₂ hU with ⟨r, hr, hrU⟩\n  -- Choose `c : 𝕜₂` with `r < ‖c‖`.\n  rcases normed_field.exists_lt_norm 𝕜₁ r with ⟨c, hc⟩\n  have hcnz : c ≠ 0 := ne_zero_of_norm_ne_zero (hr.trans hc).ne.symm\n  -- We have `f ⁻¹' ((σ₁₂ c⁻¹) • K) = c⁻¹ • f ⁻¹' K ∈ 𝓝 0`. Thus, showing that\n  -- `(σ₁₂ c⁻¹) • K ⊆ U` is enough to deduce that `f ⁻¹' U ∈ 𝓝 0`.\n  suffices «expr • » (σ₁₂ <| c⁻¹) K ⊆ U by\n    refine' mem_of_superset _ this\n    have : is_unit c⁻¹ := hcnz.is_unit.inv\n    rwa [mem_map, preimage_smul_setₛₗ _ _ _ f this, set_smul_mem_nhds_zero_iff (inv_ne_zero hcnz)]\n    infer_instance\n  -- Since `σ₁₂ c⁻¹` = `(σ₁₂ c)⁻¹`, we have to prove that `K ⊆ σ₁₂ c • U`.\n  rw [map_inv₀, ← subset_set_smul_iff₀ ((map_ne_zero σ₁₂).mpr hcnz)]\n  -- But `σ₁₂` is isometric, so `‖σ₁₂ c‖ = ‖c‖ > r`, which concludes the argument since\n  -- `∀ a : 𝕜₂, r ≤ ‖a‖ → K ⊆ a • U`.\n  refine' hrU (σ₁₂ c) _\n  rw [ring_hom_isometric.is_iso]\n  exact hc.le\n#align is_compact_operator.continuous is_compact_operator.continuous\n\n",
 "compact_operator_topological_closure":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\ntheorem compact_operator_topological_closure {𝕜₁ 𝕜₂ : Type _} [nontrivially_normed_field 𝕜₁] [normed_field 𝕜₂]\n    {σ₁₂ : «expr →+* » 𝕜₁ 𝕜₂} {M₁ M₂ : Type _} [seminormed_add_comm_group M₁] [add_comm_group M₂] [normed_space 𝕜₁ M₁]\n    [Module 𝕜₂ M₂] [uniform_space M₂] [uniform_add_group M₂] [has_continuous_const_smul 𝕜₂ M₂] [t2_space M₂]\n    [complete_space M₂] [has_continuous_smul 𝕜₂ («expr →SL[ ] » M₁ σ₁₂ M₂)] :\n    (compact_operator σ₁₂ M₁ M₂).topological_closure = compact_operator σ₁₂ M₁ M₂ :=\n  SetLike.ext' is_closed_set_of_is_compact_operator.closure_eq\n#align compact_operator_topological_closure compact_operator_topological_closure\n\n",
 "comp_clm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\ntheorem is_compact_operator.comp_clm [add_comm_monoid M₂] [Module R₂ M₂] {f : M₂ → M₃} (hf : is_compact_operator f)\n    (g : «expr →SL[ ] » M₁ σ₁₂ M₂) : is_compact_operator (f ∘ g) :=\n  by\n  have := g.continuous.tendsto 0\n  rw [map_zero] at this\n  rcases hf with ⟨K, hK, hKf⟩\n  exact ⟨K, hK, this hKf⟩\n#align is_compact_operator.comp_clm is_compact_operator.comp_clm\n\n",
 "coe_mk_of_is_compact_operator":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n@[simp]\ntheorem continuous_linear_map.coe_mk_of_is_compact_operator {f : «expr →ₛₗ[ ] » M₁ σ₁₂ M₂}\n    (hf : is_compact_operator f) : (continuous_linear_map.mk_of_is_compact_operator hf : M₁ → M₂) = f :=\n  rfl\n#align continuous_linear_map.coe_mk_of_is_compact_operator continuous_linear_map.coe_mk_of_is_compact_operator\n\n",
 "cod_restrict":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem is_compact_operator.cod_restrict {f : M₁ → M₂} (hf : is_compact_operator f) {V : submodule R₂ M₂}\n    (hV : ∀ x, f x ∈ V) (h_closed : is_closed (V : set M₂)) : is_compact_operator (Set.codRestrict f V hV) :=\n  let ⟨K, hK, hKf⟩ := hf\n  ⟨«expr ⁻¹' » coe K, (closed_embedding_subtype_coe h_closed).is_compact_preimage hK, hKf⟩\n#align is_compact_operator.cod_restrict is_compact_operator.cod_restrict\n\n",
 "clm_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\ntheorem is_compact_operator.clm_comp [add_comm_monoid M₂] [Module R₂ M₂] [add_comm_monoid M₃] [Module R₃ M₃]\n    {f : M₁ → M₂} (hf : is_compact_operator f) (g : «expr →SL[ ] » M₂ σ₂₃ M₃) : is_compact_operator (g ∘ f) :=\n  hf.continuous_comp g.continuous\n#align is_compact_operator.clm_comp is_compact_operator.clm_comp\n\n",
 "add":
 "theorem is_compact_operator.add [has_continuous_add M₂] {f g : M₁ → M₂} (hf : is_compact_operator f)\n    (hg : is_compact_operator g) : is_compact_operator (f + g) :=\n  let ⟨A, hA, hAf⟩ := hf\n  let ⟨B, hB, hBg⟩ := hg\n  ⟨A + B, hA.add hB, mem_of_superset (inter_mem hAf hBg) fun x ⟨hxA, hxB⟩ => set.add_mem_add hxA hxB⟩\n#align is_compact_operator.add is_compact_operator.add\n\n"}