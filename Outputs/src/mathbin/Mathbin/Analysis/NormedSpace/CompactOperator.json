{"sub":
 "#print IsCompactOperator.sub /-\ntheorem IsCompactOperator.sub [TopologicalAddGroup M₄] {f g : M₁ → M₄} (hf : IsCompactOperator f)\n    (hg : IsCompactOperator g) : IsCompactOperator (f - g) := by rw [sub_eq_add_neg] <;> exact hf.add hg.neg\n#align is_compact_operator.sub IsCompactOperator.sub\n-/\n\n",
 "smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print IsCompactOperator.smul /-\ntheorem IsCompactOperator.smul {S : Type _} [Monoid S] [DistribMulAction S M₂] [ContinuousConstSMul S M₂] {f : M₁ → M₂}\n    (hf : IsCompactOperator f) (c : S) : IsCompactOperator («expr • » c f) :=\n  let ⟨K, hK, hKf⟩ := hf\n  ⟨«expr • » c K, hK.image <| continuous_id.const_smul c, mem_of_superset hKf fun x hx => smul_mem_smul_set hx⟩\n#align is_compact_operator.smul IsCompactOperator.smul\n-/\n\n",
 "restrict'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n#print IsCompactOperator.restrict' /-\n/-- If a compact operator preserves a complete submodule, its restriction to that submodule is\ncompact.\n\nNote that, following mathlib's convention in linear algebra, `restrict` designates the restriction\nof an endomorphism `f : E →ₗ E` to an endomorphism `f' : ↥V →ₗ ↥V`. To prove that the restriction\n`f' : ↥U →ₛₗ ↥V` of a compact operator `f : E →ₛₗ F` is compact, apply\n`is_compact_operator.cod_restrict` to `f ∘ U.subtypeL`, which is compact by\n`is_compact_operator.comp_clm`. -/\ntheorem IsCompactOperator.restrict' [SeparatedSpace M₂] {f : «expr →ₗ[ ] » M₂ R₂ M₂} (hf : IsCompactOperator f)\n    {V : Submodule R₂ M₂} (hV : ∀ v ∈ V, f v ∈ V) [hcomplete : CompleteSpace V] : IsCompactOperator (f.restrict hV) :=\n  hf.restrict hV (completeSpace_coe_iff_isComplete.mp hcomplete).is_closed\n#align is_compact_operator.restrict' IsCompactOperator.restrict'\n-/\n\n",
 "restrict":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n#print IsCompactOperator.restrict /-\n/-- If a compact operator preserves a closed submodule, its restriction to that submodule is\ncompact.\n\nNote that, following mathlib's convention in linear algebra, `restrict` designates the restriction\nof an endomorphism `f : E →ₗ E` to an endomorphism `f' : ↥V →ₗ ↥V`. To prove that the restriction\n`f' : ↥U →ₛₗ ↥V` of a compact operator `f : E →ₛₗ F` is compact, apply\n`is_compact_operator.cod_restrict` to `f ∘ U.subtypeL`, which is compact by\n`is_compact_operator.comp_clm`. -/\ntheorem IsCompactOperator.restrict {f : «expr →ₗ[ ] » M₁ R₁ M₁} (hf : IsCompactOperator f) {V : Submodule R₁ M₁}\n    (hV : ∀ v ∈ V, f v ∈ V) (h_closed : IsClosed (V : Set M₁)) : IsCompactOperator (f.restrict hV) :=\n  (hf.comp_clm V.subtypeL).cod_restrict (SetLike.forall.2 hV) h_closed\n#align is_compact_operator.restrict IsCompactOperator.restrict\n-/\n\n",
 "neg":
 "#print IsCompactOperator.neg /-\ntheorem IsCompactOperator.neg [ContinuousNeg M₄] {f : M₁ → M₄} (hf : IsCompactOperator f) : IsCompactOperator (-f) :=\n  let ⟨K, hK, hKf⟩ := hf\n  ⟨-K, hK.neg, mem_of_superset hKf fun x (hx : f x ∈ K) => Set.neg_mem_neg.mpr hx⟩\n#align is_compact_operator.neg IsCompactOperator.neg\n-/\n\n",
 "mkOfIsCompactOperator_to_linearMap":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n#print ContinuousLinearMap.mkOfIsCompactOperator_to_linearMap /-\n@[simp]\ntheorem ContinuousLinearMap.mkOfIsCompactOperator_to_linearMap {f : «expr →ₛₗ[ ] » M₁ σ₁₂ M₂}\n    (hf : IsCompactOperator f) : (ContinuousLinearMap.mkOfIsCompactOperator hf : «expr →ₛₗ[ ] » M₁ σ₁₂ M₂) = f :=\n  rfl\n#align continuous_linear_map.mk_of_is_compact_operator_to_linear_map ContinuousLinearMap.mkOfIsCompactOperator_to_linearMap\n-/\n\n",
 "mkOfIsCompactOperator_mem_compactOperator":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n#print ContinuousLinearMap.mkOfIsCompactOperator_mem_compactOperator /-\ntheorem ContinuousLinearMap.mkOfIsCompactOperator_mem_compactOperator {f : «expr →ₛₗ[ ] » M₁ σ₁₂ M₂}\n    (hf : IsCompactOperator f) : ContinuousLinearMap.mkOfIsCompactOperator hf ∈ compactOperator σ₁₂ M₁ M₂ :=\n  hf\n#align continuous_linear_map.mk_of_is_compact_operator_mem_compact_operator ContinuousLinearMap.mkOfIsCompactOperator_mem_compactOperator\n-/\n\n",
 "isCompact_closure_image_of_vonN_bounded":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n#print IsCompactOperator.isCompact_closure_image_of_vonN_bounded /-\ntheorem IsCompactOperator.isCompact_closure_image_of_vonN_bounded [T2Space M₂] {f : «expr →ₛₗ[ ] » M₁ σ₁₂ M₂}\n    (hf : IsCompactOperator f) {S : Set M₁} (hS : IsVonNBounded 𝕜₁ S) : IsCompact (closure <| «expr '' » f S) :=\n  let ⟨K, hK, hKf⟩ := hf.image_subset_compact_of_vonN_bounded hS\n  isCompact_closure_of_subset_compact hK hKf\n#align is_compact_operator.is_compact_closure_image_of_vonN_bounded IsCompactOperator.isCompact_closure_image_of_vonN_bounded\n-/\n\n",
 "isCompact_closure_image_of_bounded":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n#print IsCompactOperator.isCompact_closure_image_of_bounded /-\ntheorem IsCompactOperator.isCompact_closure_image_of_bounded [ContinuousConstSMul 𝕜₂ M₂] [T2Space M₂]\n    {f : «expr →ₛₗ[ ] » M₁ σ₁₂ M₂} (hf : IsCompactOperator f) {S : Set M₁} (hS : Metric.Bounded S) :\n    IsCompact (closure <| «expr '' » f S) :=\n  hf.is_compact_closure_image_of_vonN_bounded (by rwa [NormedSpace.isVonNBounded_iff, ← Metric.bounded_iff_isBounded])\n#align is_compact_operator.is_compact_closure_image_of_bounded IsCompactOperator.isCompact_closure_image_of_bounded\n-/\n\n",
 "isCompact_closure_image_closedBall":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n#print IsCompactOperator.isCompact_closure_image_closedBall /-\ntheorem IsCompactOperator.isCompact_closure_image_closedBall [ContinuousConstSMul 𝕜₂ M₂] [T2Space M₂]\n    {f : «expr →ₛₗ[ ] » M₁ σ₁₂ M₂} (hf : IsCompactOperator f) (r : exprℝ) :\n    IsCompact (closure <| «expr '' » f (Metric.closedBall 0 r)) :=\n  hf.is_compact_closure_image_of_vonN_bounded (NormedSpace.isVonNBounded_closedBall 𝕜₁ M₁ r)\n#align is_compact_operator.is_compact_closure_image_closed_ball IsCompactOperator.isCompact_closure_image_closedBall\n-/\n\n",
 "isCompact_closure_image_ball":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n#print IsCompactOperator.isCompact_closure_image_ball /-\ntheorem IsCompactOperator.isCompact_closure_image_ball [ContinuousConstSMul 𝕜₂ M₂] [T2Space M₂]\n    {f : «expr →ₛₗ[ ] » M₁ σ₁₂ M₂} (hf : IsCompactOperator f) (r : exprℝ) :\n    IsCompact (closure <| «expr '' » f (Metric.ball 0 r)) :=\n  hf.is_compact_closure_image_of_vonN_bounded (NormedSpace.isVonNBounded_ball 𝕜₁ M₁ r)\n#align is_compact_operator.is_compact_closure_image_ball IsCompactOperator.isCompact_closure_image_ball\n-/\n\n",
 "isCompactOperator_zero":
 "#print isCompactOperator_zero /-\n/-\nCopyright (c) 2022 Anatole Dedecker. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Anatole Dedecker\n-/\ntheorem isCompactOperator_zero {M₁ M₂ : Type _} [Zero M₁] [TopologicalSpace M₁] [TopologicalSpace M₂] [Zero M₂] :\n    IsCompactOperator (0 : M₁ → M₂) :=\n  ⟨{0}, isCompact_singleton, mem_of_superset univ_mem fun x _ => rfl⟩\n#align is_compact_operator_zero isCompactOperator_zero\n-/\n\n",
 "isCompactOperator_of_tendsto":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n#print isCompactOperator_of_tendsto /-\ntheorem isCompactOperator_of_tendsto {ι 𝕜₁ 𝕜₂ : Type _} [NontriviallyNormedField 𝕜₁] [NormedField 𝕜₂]\n    {σ₁₂ : «expr →+* » 𝕜₁ 𝕜₂} {M₁ M₂ : Type _} [SeminormedAddCommGroup M₁] [AddCommGroup M₂] [NormedSpace 𝕜₁ M₁]\n    [Module 𝕜₂ M₂] [UniformSpace M₂] [UniformAddGroup M₂] [ContinuousConstSMul 𝕜₂ M₂] [T2Space M₂] [CompleteSpace M₂]\n    {l : Filter ι} [l.ne_bot] {F : ι → «expr →SL[ ] » M₁ σ₁₂ M₂} {f : «expr →SL[ ] » M₁ σ₁₂ M₂}\n    (hf : Tendsto F l ((nhds) f))\n    (hF :\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" l\n        (IsCompactOperator (F i))) :\n    IsCompactOperator f :=\n  isClosed_setOf_isCompactOperator.mem_of_tendsto hf hF\n#align is_compact_operator_of_tendsto isCompactOperator_of_tendsto\n-/\n\n",
 "isCompactOperator_iff_isCompact_closure_image_closedBall":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n#print isCompactOperator_iff_isCompact_closure_image_closedBall /-\ntheorem isCompactOperator_iff_isCompact_closure_image_closedBall [ContinuousConstSMul 𝕜₂ M₂] [T2Space M₂]\n    (f : «expr →ₛₗ[ ] » M₁ σ₁₂ M₂) {r : exprℝ} (hr : 0 < r) :\n    IsCompactOperator f ↔ IsCompact (closure <| «expr '' » f (Metric.closedBall 0 r)) :=\n  ⟨fun hf => hf.is_compact_closure_image_closed_ball r, fun hf =>\n    (isCompactOperator_iff_exists_mem_nhds_isCompact_closure_image f).mpr\n      ⟨Metric.closedBall 0 r, closedBall_mem_nhds _ hr, hf⟩⟩\n#align is_compact_operator_iff_is_compact_closure_image_closed_ball isCompactOperator_iff_isCompact_closure_image_closedBall\n-/\n\n",
 "isCompactOperator_iff_isCompact_closure_image_ball":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n#print isCompactOperator_iff_isCompact_closure_image_ball /-\ntheorem isCompactOperator_iff_isCompact_closure_image_ball [ContinuousConstSMul 𝕜₂ M₂] [T2Space M₂]\n    (f : «expr →ₛₗ[ ] » M₁ σ₁₂ M₂) {r : exprℝ} (hr : 0 < r) :\n    IsCompactOperator f ↔ IsCompact (closure <| «expr '' » f (Metric.ball 0 r)) :=\n  ⟨fun hf => hf.is_compact_closure_image_ball r, fun hf =>\n    (isCompactOperator_iff_exists_mem_nhds_isCompact_closure_image f).mpr ⟨Metric.ball 0 r, ball_mem_nhds _ hr, hf⟩⟩\n#align is_compact_operator_iff_is_compact_closure_image_ball isCompactOperator_iff_isCompact_closure_image_ball\n-/\n\n",
 "isCompactOperator_iff_image_closedBall_subset_compact":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n#print isCompactOperator_iff_image_closedBall_subset_compact /-\ntheorem isCompactOperator_iff_image_closedBall_subset_compact [ContinuousConstSMul 𝕜₂ M₂] (f : «expr →ₛₗ[ ] » M₁ σ₁₂ M₂)\n    {r : exprℝ} (hr : 0 < r) :\n    IsCompactOperator f ↔ ∃ K : Set M₂, IsCompact K ∧ «expr '' » f (Metric.closedBall 0 r) ⊆ K :=\n  ⟨fun hf => hf.image_closed_ball_subset_compact r, fun ⟨K, hK, hKr⟩ =>\n    (isCompactOperator_iff_exists_mem_nhds_image_subset_compact f).mpr\n      ⟨Metric.closedBall 0 r, closedBall_mem_nhds _ hr, K, hK, hKr⟩⟩\n#align is_compact_operator_iff_image_closed_ball_subset_compact isCompactOperator_iff_image_closedBall_subset_compact\n-/\n\n",
 "isCompactOperator_iff_image_ball_subset_compact":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n#print isCompactOperator_iff_image_ball_subset_compact /-\ntheorem isCompactOperator_iff_image_ball_subset_compact [ContinuousConstSMul 𝕜₂ M₂] (f : «expr →ₛₗ[ ] » M₁ σ₁₂ M₂)\n    {r : exprℝ} (hr : 0 < r) : IsCompactOperator f ↔ ∃ K : Set M₂, IsCompact K ∧ «expr '' » f (Metric.ball 0 r) ⊆ K :=\n  ⟨fun hf => hf.image_ball_subset_compact r, fun ⟨K, hK, hKr⟩ =>\n    (isCompactOperator_iff_exists_mem_nhds_image_subset_compact f).mpr\n      ⟨Metric.ball 0 r, ball_mem_nhds _ hr, K, hK, hKr⟩⟩\n#align is_compact_operator_iff_image_ball_subset_compact isCompactOperator_iff_image_ball_subset_compact\n-/\n\n",
 "isCompactOperator_iff_exists_mem_nhds_isCompact_closure_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n#print isCompactOperator_iff_exists_mem_nhds_isCompact_closure_image /-\ntheorem isCompactOperator_iff_exists_mem_nhds_isCompact_closure_image [T2Space M₂] (f : M₁ → M₂) :\n    IsCompactOperator f ↔ ∃ V ∈ ((nhds) 0 : Filter M₁), IsCompact (closure <| «expr '' » f V) :=\n  by\n  rw [isCompactOperator_iff_exists_mem_nhds_image_subset_compact]\n  exact\n    ⟨fun ⟨V, hV, K, hK, hKV⟩ => ⟨V, hV, isCompact_closure_of_subset_compact hK hKV⟩, fun ⟨V, hV, hVc⟩ =>\n      ⟨V, hV, closure («expr '' » f V), hVc, subset_closure⟩⟩\n#align is_compact_operator_iff_exists_mem_nhds_is_compact_closure_image isCompactOperator_iff_exists_mem_nhds_isCompact_closure_image\n-/\n\n",
 "isCompactOperator_iff_exists_mem_nhds_image_subset_compact":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n#print isCompactOperator_iff_exists_mem_nhds_image_subset_compact /-\ntheorem isCompactOperator_iff_exists_mem_nhds_image_subset_compact (f : M₁ → M₂) :\n    IsCompactOperator f ↔ ∃ V ∈ ((nhds) 0 : Filter M₁), ∃ K : Set M₂, IsCompact K ∧ «expr '' » f V ⊆ K :=\n  ⟨fun ⟨K, hK, hKf⟩ => ⟨«expr ⁻¹' » f K, hKf, K, hK, image_preimage_subset _ _⟩, fun ⟨V, hV, K, hK, hVK⟩ =>\n    ⟨K, hK, mem_of_superset hV (image_subset_iff.mp hVK)⟩⟩\n#align is_compact_operator_iff_exists_mem_nhds_image_subset_compact isCompactOperator_iff_exists_mem_nhds_image_subset_compact\n-/\n\n",
 "isClosed_setOf_isCompactOperator":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n#print isClosed_setOf_isCompactOperator /-\n/-- The set of compact operators from a normed space to a complete topological vector space is\nclosed. -/\ntheorem isClosed_setOf_isCompactOperator {𝕜₁ 𝕜₂ : Type _} [NontriviallyNormedField 𝕜₁] [NormedField 𝕜₂]\n    {σ₁₂ : «expr →+* » 𝕜₁ 𝕜₂} {M₁ M₂ : Type _} [SeminormedAddCommGroup M₁] [AddCommGroup M₂] [NormedSpace 𝕜₁ M₁]\n    [Module 𝕜₂ M₂] [UniformSpace M₂] [UniformAddGroup M₂] [ContinuousConstSMul 𝕜₂ M₂] [T2Space M₂] [CompleteSpace M₂] :\n    IsClosed { f : «expr →SL[ ] » M₁ σ₁₂ M₂ | IsCompactOperator f } :=\n  by\n  refine' isClosed_of_closure_subset _\n  rintro u hu\n  rw [mem_closure_iff_nhds_zero] at hu\n  suffices TotallyBounded («expr '' » u (Metric.closedBall 0 1))\n    by\n    change IsCompactOperator (u : «expr →ₛₗ[ ] » M₁ σ₁₂ M₂)\n    rw [isCompactOperator_iff_isCompact_closure_image_closedBall (u : «expr →ₛₗ[ ] » M₁ σ₁₂ M₂) zero_lt_one]\n    exact isCompact_of_totallyBounded_isClosed this.closure isClosed_closure\n  rw [totallyBounded_iff_subset_finite_unionᵢ_nhds_zero]\n  intro U hU\n  rcases exists_nhds_zero_half hU with ⟨V, hV, hVU⟩\n  let SV : Set M₁ × Set M₂ := ⟨closed_ball 0 1, -V⟩\n  rcases hu { f | ∀ x ∈ SV.1, f x ∈ SV.2 }\n      (continuous_linear_map.has_basis_nhds_zero.mem_of_mem\n        ⟨NormedSpace.isVonNBounded_closedBall _ _ _, neg_mem_nhds_zero M₂ hV⟩) with\n    ⟨v, hv, huv⟩\n  rcases totally_bounded_iff_subset_finite_Union_nhds_zero.mp\n      (hv.is_compact_closure_image_closed_ball 1).totally_bounded V hV with\n    ⟨T, hT, hTv⟩\n  have hTv : «expr '' » v (closed_ball 0 1) ⊆ _ := subset_closure.trans hTv\n  refine' ⟨T, hT, _⟩\n  rw [image_subset_iff, preimage_Union₂] at hTv⊢\n  intro x hx\n  specialize hTv hx\n  rw [mem_Union₂] at hTv⊢\n  rcases hTv with ⟨t, ht, htx⟩\n  refine' ⟨t, ht, _⟩\n  rw [mem_preimage, mem_vadd_set_iff_neg_vadd_mem, vadd_eq_add, neg_add_eq_sub] at htx⊢\n  convert hVU _ htx _ (huv x hx) using 1\n  rw [ContinuousLinearMap.sub_apply]\n  abel\n#align is_closed_set_of_is_compact_operator isClosed_setOf_isCompactOperator\n-/\n\n",
 "image_subset_compact_of_vonN_bounded":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n#print IsCompactOperator.image_subset_compact_of_vonN_bounded /-\ntheorem IsCompactOperator.image_subset_compact_of_vonN_bounded {f : «expr →ₛₗ[ ] » M₁ σ₁₂ M₂} (hf : IsCompactOperator f)\n    {S : Set M₁} (hS : IsVonNBounded 𝕜₁ S) : ∃ K : Set M₂, IsCompact K ∧ «expr '' » f S ⊆ K :=\n  let ⟨K, hK, hKf⟩ := hf\n  let ⟨r, hr, hrS⟩ := hS hKf\n  let ⟨c, hc⟩ := NormedField.exists_lt_norm 𝕜₁ r\n  let this := ne_zero_of_norm_ne_zero (hr.trans hc).ne.symm\n  ⟨«expr • » (σ₁₂ c) K, hK.image <| continuous_id.const_smul (σ₁₂ c), by\n    rw [image_subset_iff, preimage_smul_setₛₗ _ _ _ f this.is_unit] <;> exact hrS c hc.le⟩\n#align is_compact_operator.image_subset_compact_of_vonN_bounded IsCompactOperator.image_subset_compact_of_vonN_bounded\n-/\n\n",
 "image_subset_compact_of_bounded":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n#print IsCompactOperator.image_subset_compact_of_bounded /-\ntheorem IsCompactOperator.image_subset_compact_of_bounded [ContinuousConstSMul 𝕜₂ M₂] {f : «expr →ₛₗ[ ] » M₁ σ₁₂ M₂}\n    (hf : IsCompactOperator f) {S : Set M₁} (hS : Metric.Bounded S) : ∃ K : Set M₂, IsCompact K ∧ «expr '' » f S ⊆ K :=\n  hf.image_subset_compact_of_vonN_bounded (by rwa [NormedSpace.isVonNBounded_iff, ← Metric.bounded_iff_isBounded])\n#align is_compact_operator.image_subset_compact_of_bounded IsCompactOperator.image_subset_compact_of_bounded\n-/\n\n",
 "image_closedBall_subset_compact":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n#print IsCompactOperator.image_closedBall_subset_compact /-\ntheorem IsCompactOperator.image_closedBall_subset_compact [ContinuousConstSMul 𝕜₂ M₂] {f : «expr →ₛₗ[ ] » M₁ σ₁₂ M₂}\n    (hf : IsCompactOperator f) (r : exprℝ) : ∃ K : Set M₂, IsCompact K ∧ «expr '' » f (Metric.closedBall 0 r) ⊆ K :=\n  hf.image_subset_compact_of_vonN_bounded (NormedSpace.isVonNBounded_closedBall 𝕜₁ M₁ r)\n#align is_compact_operator.image_closed_ball_subset_compact IsCompactOperator.image_closedBall_subset_compact\n-/\n\n",
 "image_ball_subset_compact":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n#print IsCompactOperator.image_ball_subset_compact /-\ntheorem IsCompactOperator.image_ball_subset_compact [ContinuousConstSMul 𝕜₂ M₂] {f : «expr →ₛₗ[ ] » M₁ σ₁₂ M₂}\n    (hf : IsCompactOperator f) (r : exprℝ) : ∃ K : Set M₂, IsCompact K ∧ «expr '' » f (Metric.ball 0 r) ⊆ K :=\n  hf.image_subset_compact_of_vonN_bounded (NormedSpace.isVonNBounded_ball 𝕜₁ M₁ r)\n#align is_compact_operator.image_ball_subset_compact IsCompactOperator.image_ball_subset_compact\n-/\n\n",
 "continuous_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n#print IsCompactOperator.continuous_comp /-\ntheorem IsCompactOperator.continuous_comp {f : M₁ → M₂} (hf : IsCompactOperator f) {g : M₂ → M₃} (hg : Continuous g) :\n    IsCompactOperator (g ∘ f) := by\n  rcases hf with ⟨K, hK, hKf⟩\n  refine' ⟨«expr '' » g K, hK.image hg, mem_of_superset hKf _⟩\n  nth_rw 2 [preimage_comp]\n  exact preimage_mono (subset_preimage_image _ _)\n#align is_compact_operator.continuous_comp IsCompactOperator.continuous_comp\n-/\n\n",
 "continuous":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n#print IsCompactOperator.continuous /-\n@[continuity]\ntheorem IsCompactOperator.continuous {f : «expr →ₛₗ[ ] » M₁ σ₁₂ M₂} (hf : IsCompactOperator f) : Continuous f :=\n  by\n  letI : UniformSpace M₂ := TopologicalAddGroup.toUniformSpace _\n  haveI : UniformAddGroup M₂ := comm_topologicalAddGroup_is_uniform\n  -- Since `f` is linear, we only need to show that it is continuous at zero.\n  -- Let `U` be a neighborhood of `0` in `M₂`.\n  refine' continuous_of_continuousAt_zero f fun U hU => _\n  rw [map_zero] at hU\n  -- The compactness of `f` gives us a compact set `K : set M₂` such that `f ⁻¹' K` is a\n  -- neighborhood of `0` in `M₁`.\n  rcases hf with ⟨K, hK, hKf⟩\n  -- But any compact set is totally bounded, hence Von-Neumann bounded. Thus, `K` absorbs `U`.\n  -- This gives `r > 0` such that `∀ a : 𝕜₂, r ≤ ‖a‖ → K ⊆ a • U`.\n  rcases hK.totally_bounded.is_vonN_bounded 𝕜₂ hU with ⟨r, hr, hrU⟩\n  -- Choose `c : 𝕜₂` with `r < ‖c‖`.\n  rcases NormedField.exists_lt_norm 𝕜₁ r with ⟨c, hc⟩\n  have hcnz : c ≠ 0 := ne_zero_of_norm_ne_zero (hr.trans hc).ne.symm\n  -- We have `f ⁻¹' ((σ₁₂ c⁻¹) • K) = c⁻¹ • f ⁻¹' K ∈ 𝓝 0`. Thus, showing that\n  -- `(σ₁₂ c⁻¹) • K ⊆ U` is enough to deduce that `f ⁻¹' U ∈ 𝓝 0`.\n  suffices «expr • » (σ₁₂ <| c⁻¹) K ⊆ U by\n    refine' mem_of_superset _ this\n    have : IsUnit c⁻¹ := hcnz.is_unit.inv\n    rwa [mem_map, preimage_smul_setₛₗ _ _ _ f this, set_smul_mem_nhds_zero_iff (inv_ne_zero hcnz)]\n    infer_instance\n  -- Since `σ₁₂ c⁻¹` = `(σ₁₂ c)⁻¹`, we have to prove that `K ⊆ σ₁₂ c • U`.\n  rw [map_inv₀, ← subset_set_smul_iff₀ ((map_ne_zero σ₁₂).mpr hcnz)]\n  -- But `σ₁₂` is isometric, so `‖σ₁₂ c‖ = ‖c‖ > r`, which concludes the argument since\n  -- `∀ a : 𝕜₂, r ≤ ‖a‖ → K ⊆ a • U`.\n  refine' hrU (σ₁₂ c) _\n  rw [ring_hom_isometric.is_iso]\n  exact hc.le\n#align is_compact_operator.continuous IsCompactOperator.continuous\n-/\n\n",
 "compactOperator_topologicalClosure":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n#print compactOperator_topologicalClosure /-\ntheorem compactOperator_topologicalClosure {𝕜₁ 𝕜₂ : Type _} [NontriviallyNormedField 𝕜₁] [NormedField 𝕜₂]\n    {σ₁₂ : «expr →+* » 𝕜₁ 𝕜₂} {M₁ M₂ : Type _} [SeminormedAddCommGroup M₁] [AddCommGroup M₂] [NormedSpace 𝕜₁ M₁]\n    [Module 𝕜₂ M₂] [UniformSpace M₂] [UniformAddGroup M₂] [ContinuousConstSMul 𝕜₂ M₂] [T2Space M₂] [CompleteSpace M₂]\n    [ContinuousSMul 𝕜₂ («expr →SL[ ] » M₁ σ₁₂ M₂)] :\n    (compactOperator σ₁₂ M₁ M₂).topological_closure = compactOperator σ₁₂ M₁ M₂ :=\n  SetLike.ext' isClosed_setOf_isCompactOperator.closure_eq\n#align compact_operator_topological_closure compactOperator_topologicalClosure\n-/\n\n",
 "comp_clm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n#print IsCompactOperator.comp_clm /-\ntheorem IsCompactOperator.comp_clm [AddCommMonoid M₂] [Module R₂ M₂] {f : M₂ → M₃} (hf : IsCompactOperator f)\n    (g : «expr →SL[ ] » M₁ σ₁₂ M₂) : IsCompactOperator (f ∘ g) :=\n  by\n  have := g.continuous.tendsto 0\n  rw [map_zero] at this\n  rcases hf with ⟨K, hK, hKf⟩\n  exact ⟨K, hK, this hKf⟩\n#align is_compact_operator.comp_clm IsCompactOperator.comp_clm\n-/\n\n",
 "coe_mkOfIsCompactOperator":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n#print ContinuousLinearMap.coe_mkOfIsCompactOperator /-\n@[simp]\ntheorem ContinuousLinearMap.coe_mkOfIsCompactOperator {f : «expr →ₛₗ[ ] » M₁ σ₁₂ M₂} (hf : IsCompactOperator f) :\n    (ContinuousLinearMap.mkOfIsCompactOperator hf : M₁ → M₂) = f :=\n  rfl\n#align continuous_linear_map.coe_mk_of_is_compact_operator ContinuousLinearMap.coe_mkOfIsCompactOperator\n-/\n\n",
 "codRestrict":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n#print IsCompactOperator.codRestrict /-\ntheorem IsCompactOperator.codRestrict {f : M₁ → M₂} (hf : IsCompactOperator f) {V : Submodule R₂ M₂} (hV : ∀ x, f x ∈ V)\n    (h_closed : IsClosed (V : Set M₂)) : IsCompactOperator (Set.codRestrict f V hV) :=\n  let ⟨K, hK, hKf⟩ := hf\n  ⟨«expr ⁻¹' » coe K, (closedEmbedding_subtype_val h_closed).is_compact_preimage hK, hKf⟩\n#align is_compact_operator.cod_restrict IsCompactOperator.codRestrict\n-/\n\n",
 "clm_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n#print IsCompactOperator.clm_comp /-\ntheorem IsCompactOperator.clm_comp [AddCommMonoid M₂] [Module R₂ M₂] [AddCommMonoid M₃] [Module R₃ M₃] {f : M₁ → M₂}\n    (hf : IsCompactOperator f) (g : «expr →SL[ ] » M₂ σ₂₃ M₃) : IsCompactOperator (g ∘ f) :=\n  hf.continuous_comp g.continuous\n#align is_compact_operator.clm_comp IsCompactOperator.clm_comp\n-/\n\n",
 "add":
 "#print IsCompactOperator.add /-\ntheorem IsCompactOperator.add [ContinuousAdd M₂] {f g : M₁ → M₂} (hf : IsCompactOperator f) (hg : IsCompactOperator g) :\n    IsCompactOperator (f + g) :=\n  let ⟨A, hA, hAf⟩ := hf\n  let ⟨B, hB, hBg⟩ := hg\n  ⟨A + B, hA.add hB, mem_of_superset (inter_mem hAf hBg) fun x ⟨hxA, hxB⟩ => Set.add_mem_add hxA hxB⟩\n#align is_compact_operator.add IsCompactOperator.add\n-/\n\n"}