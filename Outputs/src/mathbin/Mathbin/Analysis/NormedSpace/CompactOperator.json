{"sub":
 "theorem is_compact_operator.sub [topological_add_group Mâ‚„] {f g : Mâ‚ â†’ Mâ‚„} (hf : is_compact_operator f)\n    (hg : is_compact_operator g) : is_compact_operator (f - g) := by rw [sub_eq_add_neg] <;> exact hf.add hg.neg\n#align is_compact_operator.sub is_compact_operator.sub\n\n",
 "smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\ntheorem is_compact_operator.smul {S : Type _} [monoid S] [DistribMulAction S Mâ‚‚] [has_continuous_const_smul S Mâ‚‚]\n    {f : Mâ‚ â†’ Mâ‚‚} (hf : is_compact_operator f) (c : S) : is_compact_operator (Â«expr â€¢ Â» c f) :=\n  let âŸ¨K, hK, hKfâŸ© := hf\n  âŸ¨Â«expr â€¢ Â» c K, hK.image <| continuous_id.const_smul c, mem_of_superset hKf fun x hx => smul_mem_smul_set hxâŸ©\n#align is_compact_operator.smul is_compact_operator.smul\n\n",
 "restrict'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚—[ ] Â» -/\n/-- If a compact operator preserves a complete submodule, its restriction to that submodule is\ncompact.\n\nNote that, following mathlib's convention in linear algebra, `restrict` designates the restriction\nof an endomorphism `f : E â†’â‚— E` to an endomorphism `f' : â†¥V â†’â‚— â†¥V`. To prove that the restriction\n`f' : â†¥U â†’â‚›â‚— â†¥V` of a compact operator `f : E â†’â‚›â‚— F` is compact, apply\n`is_compact_operator.cod_restrict` to `f âˆ˜ U.subtypeL`, which is compact by\n`is_compact_operator.comp_clm`. -/\ntheorem is_compact_operator.restrict' [separated_space Mâ‚‚] {f : Â«expr â†’â‚—[ ] Â» Mâ‚‚ Râ‚‚ Mâ‚‚} (hf : is_compact_operator f)\n    {V : submodule Râ‚‚ Mâ‚‚} (hV : âˆ€ v âˆˆ V, f v âˆˆ V) [hcomplete : complete_space V] :\n    is_compact_operator (f.restrict hV) :=\n  hf.restrict hV (complete_space_coe_iff_is_complete.mp hcomplete).is_closed\n#align is_compact_operator.restrict' is_compact_operator.restrict'\n\n",
 "restrict":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚—[ ] Â» -/\n/-- If a compact operator preserves a closed submodule, its restriction to that submodule is\ncompact.\n\nNote that, following mathlib's convention in linear algebra, `restrict` designates the restriction\nof an endomorphism `f : E â†’â‚— E` to an endomorphism `f' : â†¥V â†’â‚— â†¥V`. To prove that the restriction\n`f' : â†¥U â†’â‚›â‚— â†¥V` of a compact operator `f : E â†’â‚›â‚— F` is compact, apply\n`is_compact_operator.cod_restrict` to `f âˆ˜ U.subtypeL`, which is compact by\n`is_compact_operator.comp_clm`. -/\ntheorem is_compact_operator.restrict {f : Â«expr â†’â‚—[ ] Â» Mâ‚ Râ‚ Mâ‚} (hf : is_compact_operator f) {V : submodule Râ‚ Mâ‚}\n    (hV : âˆ€ v âˆˆ V, f v âˆˆ V) (h_closed : is_closed (V : set Mâ‚)) : is_compact_operator (f.restrict hV) :=\n  (hf.comp_clm V.subtypeL).cod_restrict (SetLike.forall.2 hV) h_closed\n#align is_compact_operator.restrict is_compact_operator.restrict\n\n",
 "neg":
 "theorem is_compact_operator.neg [has_continuous_neg Mâ‚„] {f : Mâ‚ â†’ Mâ‚„} (hf : is_compact_operator f) :\n    is_compact_operator (-f) :=\n  let âŸ¨K, hK, hKfâŸ© := hf\n  âŸ¨-K, hK.neg, mem_of_superset hKf fun x (hx : f x âˆˆ K) => set.neg_mem_neg.mpr hxâŸ©\n#align is_compact_operator.neg is_compact_operator.neg\n\n",
 "mk_of_is_compact_operator_to_linear_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚›â‚—[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚›â‚—[ ] Â» -/\n@[simp]\ntheorem continuous_linear_map.mk_of_is_compact_operator_to_linear_map {f : Â«expr â†’â‚›â‚—[ ] Â» Mâ‚ Ïƒâ‚â‚‚ Mâ‚‚}\n    (hf : is_compact_operator f) :\n    (continuous_linear_map.mk_of_is_compact_operator hf : Â«expr â†’â‚›â‚—[ ] Â» Mâ‚ Ïƒâ‚â‚‚ Mâ‚‚) = f :=\n  rfl\n#align\n  continuous_linear_map.mk_of_is_compact_operator_to_linear_map continuous_linear_map.mk_of_is_compact_operator_to_linear_map\n\n",
 "mk_of_is_compact_operator_mem_compact_operator":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚›â‚—[ ] Â» -/\ntheorem continuous_linear_map.mk_of_is_compact_operator_mem_compact_operator {f : Â«expr â†’â‚›â‚—[ ] Â» Mâ‚ Ïƒâ‚â‚‚ Mâ‚‚}\n    (hf : is_compact_operator f) : continuous_linear_map.mk_of_is_compact_operator hf âˆˆ compact_operator Ïƒâ‚â‚‚ Mâ‚ Mâ‚‚ :=\n  hf\n#align\n  continuous_linear_map.mk_of_is_compact_operator_mem_compact_operator continuous_linear_map.mk_of_is_compact_operator_mem_compact_operator\n\n",
 "is_compact_operator_zero":
 "/-\nCopyright (c) 2022 Anatole Dedecker. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Anatole Dedecker\n-/\ntheorem is_compact_operator_zero {Mâ‚ Mâ‚‚ : Type _} [Zero Mâ‚] [topological_space Mâ‚] [topological_space Mâ‚‚] [Zero Mâ‚‚] :\n    is_compact_operator (0 : Mâ‚ â†’ Mâ‚‚) :=\n  âŸ¨{0}, is_compact_singleton, mem_of_superset univ_mem fun x _ => rflâŸ©\n#align is_compact_operator_zero is_compact_operator_zero\n\n",
 "is_compact_operator_of_tendsto":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’+* Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’SL[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’SL[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\ntheorem is_compact_operator_of_tendsto {Î¹ ğ•œâ‚ ğ•œâ‚‚ : Type _} [nontrivially_normed_field ğ•œâ‚] [normed_field ğ•œâ‚‚]\n    {Ïƒâ‚â‚‚ : Â«expr â†’+* Â» ğ•œâ‚ ğ•œâ‚‚} {Mâ‚ Mâ‚‚ : Type _} [seminormed_add_comm_group Mâ‚] [add_comm_group Mâ‚‚] [normed_space ğ•œâ‚ Mâ‚]\n    [Module ğ•œâ‚‚ Mâ‚‚] [uniform_space Mâ‚‚] [uniform_add_group Mâ‚‚] [has_continuous_const_smul ğ•œâ‚‚ Mâ‚‚] [t2_space Mâ‚‚]\n    [complete_space Mâ‚‚] {l : filter Î¹} [l.ne_bot] {F : Î¹ â†’ Â«expr â†’SL[ ] Â» Mâ‚ Ïƒâ‚â‚‚ Mâ‚‚} {f : Â«expr â†’SL[ ] Â» Mâ‚ Ïƒâ‚â‚‚ Mâ‚‚}\n    (hf : tendsto F l ((nhds) f))\n    (hF :\n      Â«exprâˆ€á¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â»\" l\n        (is_compact_operator (F i))) :\n    is_compact_operator f :=\n  is_closed_set_of_is_compact_operator.mem_of_tendsto hf hF\n#align is_compact_operator_of_tendsto is_compact_operator_of_tendsto\n\n",
 "is_compact_operator_iff_is_compact_closure_image_closed_ball":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚›â‚—[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\ntheorem is_compact_operator_iff_is_compact_closure_image_closed_ball [has_continuous_const_smul ğ•œâ‚‚ Mâ‚‚] [t2_space Mâ‚‚]\n    (f : Â«expr â†’â‚›â‚—[ ] Â» Mâ‚ Ïƒâ‚â‚‚ Mâ‚‚) {r : exprâ„} (hr : 0 < r) :\n    is_compact_operator f â†” is_compact (closure <| Â«expr '' Â» f (metric.closed_ball 0 r)) :=\n  âŸ¨fun hf => hf.is_compact_closure_image_closed_ball r, fun hf =>\n    (is_compact_operator_iff_exists_mem_nhds_is_compact_closure_image f).mpr\n      âŸ¨metric.closed_ball 0 r, closed_ball_mem_nhds _ hr, hfâŸ©âŸ©\n#align\n  is_compact_operator_iff_is_compact_closure_image_closed_ball is_compact_operator_iff_is_compact_closure_image_closed_ball\n\n",
 "is_compact_operator_iff_is_compact_closure_image_ball":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚›â‚—[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\ntheorem is_compact_operator_iff_is_compact_closure_image_ball [has_continuous_const_smul ğ•œâ‚‚ Mâ‚‚] [t2_space Mâ‚‚]\n    (f : Â«expr â†’â‚›â‚—[ ] Â» Mâ‚ Ïƒâ‚â‚‚ Mâ‚‚) {r : exprâ„} (hr : 0 < r) :\n    is_compact_operator f â†” is_compact (closure <| Â«expr '' Â» f (metric.ball 0 r)) :=\n  âŸ¨fun hf => hf.is_compact_closure_image_ball r, fun hf =>\n    (is_compact_operator_iff_exists_mem_nhds_is_compact_closure_image f).mpr âŸ¨metric.ball 0 r, ball_mem_nhds _ hr, hfâŸ©âŸ©\n#align is_compact_operator_iff_is_compact_closure_image_ball is_compact_operator_iff_is_compact_closure_image_ball\n\n",
 "is_compact_operator_iff_image_closed_ball_subset_compact":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚›â‚—[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\ntheorem is_compact_operator_iff_image_closed_ball_subset_compact [has_continuous_const_smul ğ•œâ‚‚ Mâ‚‚]\n    (f : Â«expr â†’â‚›â‚—[ ] Â» Mâ‚ Ïƒâ‚â‚‚ Mâ‚‚) {r : exprâ„} (hr : 0 < r) :\n    is_compact_operator f â†” âˆƒ K : set Mâ‚‚, is_compact K âˆ§ Â«expr '' Â» f (metric.closed_ball 0 r) âŠ† K :=\n  âŸ¨fun hf => hf.image_closed_ball_subset_compact r, fun âŸ¨K, hK, hKrâŸ© =>\n    (is_compact_operator_iff_exists_mem_nhds_image_subset_compact f).mpr\n      âŸ¨metric.closed_ball 0 r, closed_ball_mem_nhds _ hr, K, hK, hKrâŸ©âŸ©\n#align is_compact_operator_iff_image_closed_ball_subset_compact is_compact_operator_iff_image_closed_ball_subset_compact\n\n",
 "is_compact_operator_iff_image_ball_subset_compact":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚›â‚—[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\ntheorem is_compact_operator_iff_image_ball_subset_compact [has_continuous_const_smul ğ•œâ‚‚ Mâ‚‚]\n    (f : Â«expr â†’â‚›â‚—[ ] Â» Mâ‚ Ïƒâ‚â‚‚ Mâ‚‚) {r : exprâ„} (hr : 0 < r) :\n    is_compact_operator f â†” âˆƒ K : set Mâ‚‚, is_compact K âˆ§ Â«expr '' Â» f (metric.ball 0 r) âŠ† K :=\n  âŸ¨fun hf => hf.image_ball_subset_compact r, fun âŸ¨K, hK, hKrâŸ© =>\n    (is_compact_operator_iff_exists_mem_nhds_image_subset_compact f).mpr\n      âŸ¨metric.ball 0 r, ball_mem_nhds _ hr, K, hK, hKrâŸ©âŸ©\n#align is_compact_operator_iff_image_ball_subset_compact is_compact_operator_iff_image_ball_subset_compact\n\n",
 "is_compact_operator_iff_exists_mem_nhds_is_compact_closure_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\ntheorem is_compact_operator_iff_exists_mem_nhds_is_compact_closure_image [t2_space Mâ‚‚] (f : Mâ‚ â†’ Mâ‚‚) :\n    is_compact_operator f â†” âˆƒ V âˆˆ ((nhds) 0 : filter Mâ‚), is_compact (closure <| Â«expr '' Â» f V) :=\n  by\n  rw [is_compact_operator_iff_exists_mem_nhds_image_subset_compact]\n  exact\n    âŸ¨fun âŸ¨V, hV, K, hK, hKVâŸ© => âŸ¨V, hV, is_compact_closure_of_subset_compact hK hKVâŸ©, fun âŸ¨V, hV, hVcâŸ© =>\n      âŸ¨V, hV, closure (Â«expr '' Â» f V), hVc, subset_closureâŸ©âŸ©\n#align\n  is_compact_operator_iff_exists_mem_nhds_is_compact_closure_image is_compact_operator_iff_exists_mem_nhds_is_compact_closure_image\n\n",
 "is_compact_operator_iff_exists_mem_nhds_image_subset_compact":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\ntheorem is_compact_operator_iff_exists_mem_nhds_image_subset_compact (f : Mâ‚ â†’ Mâ‚‚) :\n    is_compact_operator f â†” âˆƒ V âˆˆ ((nhds) 0 : filter Mâ‚), âˆƒ K : set Mâ‚‚, is_compact K âˆ§ Â«expr '' Â» f V âŠ† K :=\n  âŸ¨fun âŸ¨K, hK, hKfâŸ© => âŸ¨Â«expr â»Â¹' Â» f K, hKf, K, hK, image_preimage_subset _ _âŸ©, fun âŸ¨V, hV, K, hK, hVKâŸ© =>\n    âŸ¨K, hK, mem_of_superset hV (image_subset_iff.mp hVK)âŸ©âŸ©\n#align\n  is_compact_operator_iff_exists_mem_nhds_image_subset_compact is_compact_operator_iff_exists_mem_nhds_image_subset_compact\n\n",
 "is_compact_closure_image_of_vonN_bounded":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚›â‚—[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\ntheorem is_compact_operator.is_compact_closure_image_of_vonN_bounded [t2_space Mâ‚‚] {f : Â«expr â†’â‚›â‚—[ ] Â» Mâ‚ Ïƒâ‚â‚‚ Mâ‚‚}\n    (hf : is_compact_operator f) {S : set Mâ‚} (hS : is_vonN_bounded ğ•œâ‚ S) : is_compact (closure <| Â«expr '' Â» f S) :=\n  let âŸ¨K, hK, hKfâŸ© := hf.image_subset_compact_of_vonN_bounded hS\n  is_compact_closure_of_subset_compact hK hKf\n#align\n  is_compact_operator.is_compact_closure_image_of_vonN_bounded is_compact_operator.is_compact_closure_image_of_vonN_bounded\n\n",
 "is_compact_closure_image_of_bounded":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚›â‚—[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\ntheorem is_compact_operator.is_compact_closure_image_of_bounded [has_continuous_const_smul ğ•œâ‚‚ Mâ‚‚] [t2_space Mâ‚‚]\n    {f : Â«expr â†’â‚›â‚—[ ] Â» Mâ‚ Ïƒâ‚â‚‚ Mâ‚‚} (hf : is_compact_operator f) {S : set Mâ‚} (hS : metric.bounded S) :\n    is_compact (closure <| Â«expr '' Â» f S) :=\n  hf.is_compact_closure_image_of_vonN_bounded\n    (by rwa [normed_space.is_vonN_bounded_iff, â† metric.bounded_iff_is_bounded])\n#align is_compact_operator.is_compact_closure_image_of_bounded is_compact_operator.is_compact_closure_image_of_bounded\n\n",
 "is_compact_closure_image_closed_ball":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚›â‚—[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\ntheorem is_compact_operator.is_compact_closure_image_closed_ball [has_continuous_const_smul ğ•œâ‚‚ Mâ‚‚] [t2_space Mâ‚‚]\n    {f : Â«expr â†’â‚›â‚—[ ] Â» Mâ‚ Ïƒâ‚â‚‚ Mâ‚‚} (hf : is_compact_operator f) (r : exprâ„) :\n    is_compact (closure <| Â«expr '' Â» f (metric.closed_ball 0 r)) :=\n  hf.is_compact_closure_image_of_vonN_bounded (normed_space.is_vonN_bounded_closed_ball ğ•œâ‚ Mâ‚ r)\n#align is_compact_operator.is_compact_closure_image_closed_ball is_compact_operator.is_compact_closure_image_closed_ball\n\n",
 "is_compact_closure_image_ball":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚›â‚—[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\ntheorem is_compact_operator.is_compact_closure_image_ball [has_continuous_const_smul ğ•œâ‚‚ Mâ‚‚] [t2_space Mâ‚‚]\n    {f : Â«expr â†’â‚›â‚—[ ] Â» Mâ‚ Ïƒâ‚â‚‚ Mâ‚‚} (hf : is_compact_operator f) (r : exprâ„) :\n    is_compact (closure <| Â«expr '' Â» f (metric.ball 0 r)) :=\n  hf.is_compact_closure_image_of_vonN_bounded (normed_space.is_vonN_bounded_ball ğ•œâ‚ Mâ‚ r)\n#align is_compact_operator.is_compact_closure_image_ball is_compact_operator.is_compact_closure_image_ball\n\n",
 "is_closed_set_of_is_compact_operator":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚›â‚—[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚›â‚—[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’+* Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’SL[ ] Â» -/\n/-- The set of compact operators from a normed space to a complete topological vector space is\nclosed. -/\ntheorem is_closed_set_of_is_compact_operator {ğ•œâ‚ ğ•œâ‚‚ : Type _} [nontrivially_normed_field ğ•œâ‚] [normed_field ğ•œâ‚‚]\n    {Ïƒâ‚â‚‚ : Â«expr â†’+* Â» ğ•œâ‚ ğ•œâ‚‚} {Mâ‚ Mâ‚‚ : Type _} [seminormed_add_comm_group Mâ‚] [add_comm_group Mâ‚‚] [normed_space ğ•œâ‚ Mâ‚]\n    [Module ğ•œâ‚‚ Mâ‚‚] [uniform_space Mâ‚‚] [uniform_add_group Mâ‚‚] [has_continuous_const_smul ğ•œâ‚‚ Mâ‚‚] [t2_space Mâ‚‚]\n    [complete_space Mâ‚‚] : is_closed { f : Â«expr â†’SL[ ] Â» Mâ‚ Ïƒâ‚â‚‚ Mâ‚‚ | is_compact_operator f } :=\n  by\n  refine' is_closed_of_closure_subset _\n  rintro u hu\n  rw [mem_closure_iff_nhds_zero] at hu\n  suffices totally_bounded (Â«expr '' Â» u (metric.closed_ball 0 1))\n    by\n    change is_compact_operator (u : Â«expr â†’â‚›â‚—[ ] Â» Mâ‚ Ïƒâ‚â‚‚ Mâ‚‚)\n    rw [is_compact_operator_iff_is_compact_closure_image_closed_ball (u : Â«expr â†’â‚›â‚—[ ] Â» Mâ‚ Ïƒâ‚â‚‚ Mâ‚‚) zero_lt_one]\n    exact is_compact_of_totally_bounded_is_closed this.closure is_closed_closure\n  rw [totally_bounded_iff_subset_finite_Union_nhds_zero]\n  intro U hU\n  rcases exists_nhds_zero_half hU with âŸ¨V, hV, hVUâŸ©\n  let SV : set Mâ‚ Ã— set Mâ‚‚ := âŸ¨closed_ball 0 1, -VâŸ©\n  rcases hu { f | âˆ€ x âˆˆ SV.1, f x âˆˆ SV.2 }\n      (continuous_linear_map.has_basis_nhds_zero.mem_of_mem\n        âŸ¨normed_space.is_vonN_bounded_closed_ball _ _ _, neg_mem_nhds_zero Mâ‚‚ hVâŸ©) with\n    âŸ¨v, hv, huvâŸ©\n  rcases totally_bounded_iff_subset_finite_Union_nhds_zero.mp\n      (hv.is_compact_closure_image_closed_ball 1).totally_bounded V hV with\n    âŸ¨T, hT, hTvâŸ©\n  have hTv : Â«expr '' Â» v (closed_ball 0 1) âŠ† _ := subset_closure.trans hTv\n  refine' âŸ¨T, hT, _âŸ©\n  rw [image_subset_iff, preimage_Unionâ‚‚] at hTvâŠ¢\n  intro x hx\n  specialize hTv hx\n  rw [mem_Unionâ‚‚] at hTvâŠ¢\n  rcases hTv with âŸ¨t, ht, htxâŸ©\n  refine' âŸ¨t, ht, _âŸ©\n  rw [mem_preimage, mem_vadd_set_iff_neg_vadd_mem, vadd_eq_add, neg_add_eq_sub] at htxâŠ¢\n  convert hVU _ htx _ (huv x hx) using 1\n  rw [continuous_linear_map.sub_apply]\n  abel\n#align is_closed_set_of_is_compact_operator is_closed_set_of_is_compact_operator\n\n",
 "image_subset_compact_of_vonN_bounded":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚›â‚—[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\ntheorem is_compact_operator.image_subset_compact_of_vonN_bounded {f : Â«expr â†’â‚›â‚—[ ] Â» Mâ‚ Ïƒâ‚â‚‚ Mâ‚‚}\n    (hf : is_compact_operator f) {S : set Mâ‚} (hS : is_vonN_bounded ğ•œâ‚ S) :\n    âˆƒ K : set Mâ‚‚, is_compact K âˆ§ Â«expr '' Â» f S âŠ† K :=\n  let âŸ¨K, hK, hKfâŸ© := hf\n  let âŸ¨r, hr, hrSâŸ© := hS hKf\n  let âŸ¨c, hcâŸ© := normed_field.exists_lt_norm ğ•œâ‚ r\n  let this := ne_zero_of_norm_ne_zero (hr.trans hc).ne.symm\n  âŸ¨Â«expr â€¢ Â» (Ïƒâ‚â‚‚ c) K, hK.image <| continuous_id.const_smul (Ïƒâ‚â‚‚ c), by\n    rw [image_subset_iff, preimage_smul_setâ‚›â‚— _ _ _ f this.is_unit] <;> exact hrS c hc.leâŸ©\n#align is_compact_operator.image_subset_compact_of_vonN_bounded is_compact_operator.image_subset_compact_of_vonN_bounded\n\n",
 "image_subset_compact_of_bounded":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚›â‚—[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\ntheorem is_compact_operator.image_subset_compact_of_bounded [has_continuous_const_smul ğ•œâ‚‚ Mâ‚‚]\n    {f : Â«expr â†’â‚›â‚—[ ] Â» Mâ‚ Ïƒâ‚â‚‚ Mâ‚‚} (hf : is_compact_operator f) {S : set Mâ‚} (hS : metric.bounded S) :\n    âˆƒ K : set Mâ‚‚, is_compact K âˆ§ Â«expr '' Â» f S âŠ† K :=\n  hf.image_subset_compact_of_vonN_bounded (by rwa [normed_space.is_vonN_bounded_iff, â† metric.bounded_iff_is_bounded])\n#align is_compact_operator.image_subset_compact_of_bounded is_compact_operator.image_subset_compact_of_bounded\n\n",
 "image_closed_ball_subset_compact":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚›â‚—[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\ntheorem is_compact_operator.image_closed_ball_subset_compact [has_continuous_const_smul ğ•œâ‚‚ Mâ‚‚]\n    {f : Â«expr â†’â‚›â‚—[ ] Â» Mâ‚ Ïƒâ‚â‚‚ Mâ‚‚} (hf : is_compact_operator f) (r : exprâ„) :\n    âˆƒ K : set Mâ‚‚, is_compact K âˆ§ Â«expr '' Â» f (metric.closed_ball 0 r) âŠ† K :=\n  hf.image_subset_compact_of_vonN_bounded (normed_space.is_vonN_bounded_closed_ball ğ•œâ‚ Mâ‚ r)\n#align is_compact_operator.image_closed_ball_subset_compact is_compact_operator.image_closed_ball_subset_compact\n\n",
 "image_ball_subset_compact":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚›â‚—[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\ntheorem is_compact_operator.image_ball_subset_compact [has_continuous_const_smul ğ•œâ‚‚ Mâ‚‚] {f : Â«expr â†’â‚›â‚—[ ] Â» Mâ‚ Ïƒâ‚â‚‚ Mâ‚‚}\n    (hf : is_compact_operator f) (r : exprâ„) : âˆƒ K : set Mâ‚‚, is_compact K âˆ§ Â«expr '' Â» f (metric.ball 0 r) âŠ† K :=\n  hf.image_subset_compact_of_vonN_bounded (normed_space.is_vonN_bounded_ball ğ•œâ‚ Mâ‚ r)\n#align is_compact_operator.image_ball_subset_compact is_compact_operator.image_ball_subset_compact\n\n",
 "continuous_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\ntheorem is_compact_operator.continuous_comp {f : Mâ‚ â†’ Mâ‚‚} (hf : is_compact_operator f) {g : Mâ‚‚ â†’ Mâ‚ƒ}\n    (hg : continuous g) : is_compact_operator (g âˆ˜ f) :=\n  by\n  rcases hf with âŸ¨K, hK, hKfâŸ©\n  refine' âŸ¨Â«expr '' Â» g K, hK.image hg, mem_of_superset hKf _âŸ©\n  nth_rw 2 [preimage_comp]\n  exact preimage_mono (subset_preimage_image _ _)\n#align is_compact_operator.continuous_comp is_compact_operator.continuous_comp\n\n",
 "continuous":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚›â‚—[ ] Â» -/\n@[continuity]\ntheorem is_compact_operator.continuous {f : Â«expr â†’â‚›â‚—[ ] Â» Mâ‚ Ïƒâ‚â‚‚ Mâ‚‚} (hf : is_compact_operator f) : continuous f :=\n  by\n  letI : uniform_space Mâ‚‚ := topological_add_group.to_uniform_space _\n  haveI : uniform_add_group Mâ‚‚ := topological_add_comm_group_is_uniform\n  -- Since `f` is linear, we only need to show that it is continuous at zero.\n  -- Let `U` be a neighborhood of `0` in `Mâ‚‚`.\n  refine' continuous_of_continuous_at_zero f fun U hU => _\n  rw [map_zero] at hU\n  -- The compactness of `f` gives us a compact set `K : set Mâ‚‚` such that `f â»Â¹' K` is a\n  -- neighborhood of `0` in `Mâ‚`.\n  rcases hf with âŸ¨K, hK, hKfâŸ©\n  -- But any compact set is totally bounded, hence Von-Neumann bounded. Thus, `K` absorbs `U`.\n  -- This gives `r > 0` such that `âˆ€ a : ğ•œâ‚‚, r â‰¤ â€–aâ€– â†’ K âŠ† a â€¢ U`.\n  rcases hK.totally_bounded.is_vonN_bounded ğ•œâ‚‚ hU with âŸ¨r, hr, hrUâŸ©\n  -- Choose `c : ğ•œâ‚‚` with `r < â€–câ€–`.\n  rcases normed_field.exists_lt_norm ğ•œâ‚ r with âŸ¨c, hcâŸ©\n  have hcnz : c â‰  0 := ne_zero_of_norm_ne_zero (hr.trans hc).ne.symm\n  -- We have `f â»Â¹' ((Ïƒâ‚â‚‚ câ»Â¹) â€¢ K) = câ»Â¹ â€¢ f â»Â¹' K âˆˆ ğ“ 0`. Thus, showing that\n  -- `(Ïƒâ‚â‚‚ câ»Â¹) â€¢ K âŠ† U` is enough to deduce that `f â»Â¹' U âˆˆ ğ“ 0`.\n  suffices Â«expr â€¢ Â» (Ïƒâ‚â‚‚ <| câ»Â¹) K âŠ† U by\n    refine' mem_of_superset _ this\n    have : is_unit câ»Â¹ := hcnz.is_unit.inv\n    rwa [mem_map, preimage_smul_setâ‚›â‚— _ _ _ f this, set_smul_mem_nhds_zero_iff (inv_ne_zero hcnz)]\n    infer_instance\n  -- Since `Ïƒâ‚â‚‚ câ»Â¹` = `(Ïƒâ‚â‚‚ c)â»Â¹`, we have to prove that `K âŠ† Ïƒâ‚â‚‚ c â€¢ U`.\n  rw [map_invâ‚€, â† subset_set_smul_iffâ‚€ ((map_ne_zero Ïƒâ‚â‚‚).mpr hcnz)]\n  -- But `Ïƒâ‚â‚‚` is isometric, so `â€–Ïƒâ‚â‚‚ câ€– = â€–câ€– > r`, which concludes the argument since\n  -- `âˆ€ a : ğ•œâ‚‚, r â‰¤ â€–aâ€– â†’ K âŠ† a â€¢ U`.\n  refine' hrU (Ïƒâ‚â‚‚ c) _\n  rw [ring_hom_isometric.is_iso]\n  exact hc.le\n#align is_compact_operator.continuous is_compact_operator.continuous\n\n",
 "compact_operator_topological_closure":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’+* Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’SL[ ] Â» -/\ntheorem compact_operator_topological_closure {ğ•œâ‚ ğ•œâ‚‚ : Type _} [nontrivially_normed_field ğ•œâ‚] [normed_field ğ•œâ‚‚]\n    {Ïƒâ‚â‚‚ : Â«expr â†’+* Â» ğ•œâ‚ ğ•œâ‚‚} {Mâ‚ Mâ‚‚ : Type _} [seminormed_add_comm_group Mâ‚] [add_comm_group Mâ‚‚] [normed_space ğ•œâ‚ Mâ‚]\n    [Module ğ•œâ‚‚ Mâ‚‚] [uniform_space Mâ‚‚] [uniform_add_group Mâ‚‚] [has_continuous_const_smul ğ•œâ‚‚ Mâ‚‚] [t2_space Mâ‚‚]\n    [complete_space Mâ‚‚] [has_continuous_smul ğ•œâ‚‚ (Â«expr â†’SL[ ] Â» Mâ‚ Ïƒâ‚â‚‚ Mâ‚‚)] :\n    (compact_operator Ïƒâ‚â‚‚ Mâ‚ Mâ‚‚).topological_closure = compact_operator Ïƒâ‚â‚‚ Mâ‚ Mâ‚‚ :=\n  SetLike.ext' is_closed_set_of_is_compact_operator.closure_eq\n#align compact_operator_topological_closure compact_operator_topological_closure\n\n",
 "comp_clm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’SL[ ] Â» -/\ntheorem is_compact_operator.comp_clm [add_comm_monoid Mâ‚‚] [Module Râ‚‚ Mâ‚‚] {f : Mâ‚‚ â†’ Mâ‚ƒ} (hf : is_compact_operator f)\n    (g : Â«expr â†’SL[ ] Â» Mâ‚ Ïƒâ‚â‚‚ Mâ‚‚) : is_compact_operator (f âˆ˜ g) :=\n  by\n  have := g.continuous.tendsto 0\n  rw [map_zero] at this\n  rcases hf with âŸ¨K, hK, hKfâŸ©\n  exact âŸ¨K, hK, this hKfâŸ©\n#align is_compact_operator.comp_clm is_compact_operator.comp_clm\n\n",
 "coe_mk_of_is_compact_operator":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚›â‚—[ ] Â» -/\n@[simp]\ntheorem continuous_linear_map.coe_mk_of_is_compact_operator {f : Â«expr â†’â‚›â‚—[ ] Â» Mâ‚ Ïƒâ‚â‚‚ Mâ‚‚}\n    (hf : is_compact_operator f) : (continuous_linear_map.mk_of_is_compact_operator hf : Mâ‚ â†’ Mâ‚‚) = f :=\n  rfl\n#align continuous_linear_map.coe_mk_of_is_compact_operator continuous_linear_map.coe_mk_of_is_compact_operator\n\n",
 "cod_restrict":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\ntheorem is_compact_operator.cod_restrict {f : Mâ‚ â†’ Mâ‚‚} (hf : is_compact_operator f) {V : submodule Râ‚‚ Mâ‚‚}\n    (hV : âˆ€ x, f x âˆˆ V) (h_closed : is_closed (V : set Mâ‚‚)) : is_compact_operator (Set.codRestrict f V hV) :=\n  let âŸ¨K, hK, hKfâŸ© := hf\n  âŸ¨Â«expr â»Â¹' Â» coe K, (closed_embedding_subtype_coe h_closed).is_compact_preimage hK, hKfâŸ©\n#align is_compact_operator.cod_restrict is_compact_operator.cod_restrict\n\n",
 "clm_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’SL[ ] Â» -/\ntheorem is_compact_operator.clm_comp [add_comm_monoid Mâ‚‚] [Module Râ‚‚ Mâ‚‚] [add_comm_monoid Mâ‚ƒ] [Module Râ‚ƒ Mâ‚ƒ]\n    {f : Mâ‚ â†’ Mâ‚‚} (hf : is_compact_operator f) (g : Â«expr â†’SL[ ] Â» Mâ‚‚ Ïƒâ‚‚â‚ƒ Mâ‚ƒ) : is_compact_operator (g âˆ˜ f) :=\n  hf.continuous_comp g.continuous\n#align is_compact_operator.clm_comp is_compact_operator.clm_comp\n\n",
 "add":
 "theorem is_compact_operator.add [has_continuous_add Mâ‚‚] {f g : Mâ‚ â†’ Mâ‚‚} (hf : is_compact_operator f)\n    (hg : is_compact_operator g) : is_compact_operator (f + g) :=\n  let âŸ¨A, hA, hAfâŸ© := hf\n  let âŸ¨B, hB, hBgâŸ© := hg\n  âŸ¨A + B, hA.add hB, mem_of_superset (inter_mem hAf hBg) fun x âŸ¨hxA, hxBâŸ© => set.add_mem_add hxA hxBâŸ©\n#align is_compact_operator.add is_compact_operator.add\n\n"}