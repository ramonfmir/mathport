{"to_linear_isometry_equiv_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗᵢ[ ] » -/\n@[simp]\ntheorem to_linear_isometry_equiv_apply (li : «expr →ₗᵢ[ ] » E₁ R₁ F) (h : finrank R₁ E₁ = finrank R₁ F) (x : E₁) :\n    (li.to_linear_isometry_equiv h) x = li x :=\n  rfl\n#align to_linear_isometry_equiv_apply to_linear_isometry_equiv_apply\n\n",
 "to_affine_isometry_equiv_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ᵃⁱ[ ] » -/\n@[simp]\ntheorem to_affine_isometry_equiv_apply [Inhabited P₁] (li : «expr →ᵃⁱ[ ] » P₁ 𝕜 P₂) (h : finrank 𝕜 V₁ = finrank 𝕜 V₂)\n    (x : P₁) : (li.to_affine_isometry_equiv h) x = li x :=\n  rfl\n#align to_affine_isometry_equiv_apply to_affine_isometry_equiv_apply\n\n",
 "summable_of_is_equivalent_nat":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `asymptotics.is_equivalent -/\ntheorem summable_of_is_equivalent_nat {E : Type _} [NormedAddCommGroup E] [NormedSpace (exprℝ) E]\n    [FiniteDimensional (exprℝ) E] {f : ℕ → E} {g : ℕ → E} (hg : Summable g) (h : asymptotics.is_equivalent f atTop g) :\n    Summable f :=\n  hg.trans_sub (summable_of_is_O_nat' hg h.is_o.is_O)\n#align summable_of_is_equivalent_nat summable_of_is_equivalent_nat\n\n",
 "summable_of_is_equivalent":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `asymptotics.is_equivalent -/\ntheorem summable_of_is_equivalent {ι E : Type _} [NormedAddCommGroup E] [NormedSpace (exprℝ) E]\n    [FiniteDimensional (exprℝ) E] {f : ι → E} {g : ι → E} (hg : Summable g)\n    (h : asymptotics.is_equivalent f cofinite g) : Summable f :=\n  hg.trans_sub (summable_of_is_O' hg h.is_o.is_O)\n#align summable_of_is_equivalent summable_of_is_equivalent\n\n",
 "summable_of_is_O_nat'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =O[ ] » -/\ntheorem summable_of_is_O_nat' {E F : Type _} [NormedAddCommGroup E] [CompleteSpace E] [NormedAddCommGroup F]\n    [NormedSpace (exprℝ) F] [FiniteDimensional (exprℝ) F] {f : ℕ → E} {g : ℕ → F} (hg : Summable g)\n    (h : «expr =O[ ] » f atTop g) : Summable f :=\n  summable_of_isBigO_nat (summable_norm_iff.mpr hg) h.norm_right\n#align summable_of_is_O_nat' summable_of_is_O_nat'\n\n",
 "summable_of_is_O'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =O[ ] » -/\ntheorem summable_of_is_O' {ι E F : Type _} [NormedAddCommGroup E] [CompleteSpace E] [NormedAddCommGroup F]\n    [NormedSpace (exprℝ) F] [FiniteDimensional (exprℝ) F] {f : ι → E} {g : ι → F} (hg : Summable g)\n    (h : «expr =O[ ] » f cofinite g) : Summable f :=\n  summable_of_isBigO (summable_norm_iff.mpr hg) h.norm_right\n#align summable_of_is_O' summable_of_is_O'\n\n",
 "summable_norm_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/-- In a finite dimensional vector space over `ℝ`, the series `∑ x, ‖f x‖` is unconditionally\nsummable if and only if the series `∑ x, f x` is unconditionally summable. One implication holds in\nany complete normed space, while the other holds only in finite dimensional spaces. -/\ntheorem summable_norm_iff {α E : Type _} [NormedAddCommGroup E] [NormedSpace (exprℝ) E] [FiniteDimensional (exprℝ) E]\n    {f : α → E} : (Summable fun x => «expr‖ ‖» (f x)) ↔ Summable f :=\n  by\n  refine' ⟨summable_of_summable_norm, fun hf => _⟩\n  -- First we use a finite basis to reduce the problem to the case `E = fin N → ℝ`\n  suffices ∀ {N : ℕ} {g : α → Fin N → exprℝ}, Summable g → Summable fun x => «expr‖ ‖» (g x)\n    by\n    obtain v := fin_basis (exprℝ) E\n    set e := v.equiv_funL\n    have : Summable fun x => «expr‖ ‖» (e (f x)) := this (e.summable.2 hf)\n    refine'\n      summable_of_norm_bounded _\n        (this.mul_left ↑(«expr‖ ‖₊» (e.symm : «expr →L[ ] » (Fin (finrank (exprℝ) E) → exprℝ) (exprℝ) E))) fun i => _\n    simpa using (e.symm : «expr →L[ ] » (Fin (finrank (exprℝ) E) → exprℝ) (exprℝ) E).le_op_norm (e <| f i)\n  clear! E\n  -- Now we deal with `g : α → fin N → ℝ`\n  intro N g hg\n  have : ∀ i, Summable fun x => «expr‖ ‖» (g x i) := fun i => (Pi.summable.1 hg i).abs\n  refine' summable_of_norm_bounded _ (summable_sum fun i (hi : i ∈ Finset.univ) => this i) fun x => _\n  rw [norm_norm, pi_norm_le_iff_of_nonneg]\n  · refine' fun i => Finset.single_le_sum (fun i hi => _) (Finset.mem_univ i)\n    exact norm_nonneg (g x i)\n  · exact Finset.sum_nonneg fun _ _ => norm_nonneg _\n#align summable_norm_iff summable_norm_iff\n\n",
 "summable_iff_nat":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `asymptotics.is_equivalent -/\ntheorem is_equivalent.summable_iff_nat {E : Type _} [NormedAddCommGroup E] [NormedSpace (exprℝ) E]\n    [FiniteDimensional (exprℝ) E] {f : ℕ → E} {g : ℕ → E} (h : asymptotics.is_equivalent f atTop g) :\n    Summable f ↔ Summable g :=\n  ⟨fun hf => summable_of_is_equivalent_nat hf h.symm, fun hg => summable_of_is_equivalent_nat hg h⟩\n#align is_equivalent.summable_iff_nat is_equivalent.summable_iff_nat\n\n",
 "summable_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `asymptotics.is_equivalent -/\ntheorem is_equivalent.summable_iff {ι E : Type _} [NormedAddCommGroup E] [NormedSpace (exprℝ) E]\n    [FiniteDimensional (exprℝ) E] {f : ι → E} {g : ι → E} (h : asymptotics.is_equivalent f cofinite g) :\n    Summable f ↔ Summable g :=\n  ⟨fun hf => summable_of_is_equivalent hf h.symm, fun hg => summable_of_is_equivalent hg h⟩\n#align is_equivalent.summable_iff is_equivalent.summable_iff\n\n",
 "proper":
 "/-- Any finite-dimensional vector space over a proper field is proper.\nWe do not register this as an instance to avoid an instance loop when trying to prove the\nproperness of `𝕜`, and the search for `𝕜` as an unknown metavariable. Declare the instance\nexplicitly when needed. -/\ntheorem finite_dimensional.proper [FiniteDimensional 𝕜 E] : ProperSpace E :=\n  by\n  set e := continuous_linear_equiv.of_finrank_eq (@finrank_fin_fun 𝕜 _ _ (finrank 𝕜 E)).symm\n  exact e.symm.antilipschitz.proper_space e.symm.continuous e.symm.surjective\n#align finite_dimensional.proper finite_dimensional.proper\n\n",
 "op_norm_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem basis.op_norm_le {ι : Type _} [Fintype ι] (v : Basis ι 𝕜 E) {u : «expr →L[ ] » E 𝕜 F} {M : exprℝ} (hM : 0 ≤ M)\n    (hu : ∀ i, «expr‖ ‖» (u (v i)) ≤ M) :\n    «expr‖ ‖» u ≤ «expr • » (Fintype.card ι) («expr‖ ‖» v.equiv_funL.to_continuous_linear_map) * M := by\n  simpa using nnreal.coe_le_coe.mpr (v.op_nnnorm_le ⟨M, hM⟩ hu)\n#align basis.op_norm_le basis.op_norm_le\n\n",
 "op_nnnorm_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\ntheorem basis.op_nnnorm_le {ι : Type _} [Fintype ι] (v : Basis ι 𝕜 E) {u : «expr →L[ ] » E 𝕜 F} (M : nnreal)\n    (hu : ∀ i, «expr‖ ‖₊» (u (v i)) ≤ M) :\n    «expr‖ ‖₊» u ≤ «expr • » (Fintype.card ι) («expr‖ ‖₊» v.equiv_funL.to_continuous_linear_map) * M :=\n  u.op_nnnorm_le_bound _ fun e => by\n    set φ := v.equiv_funL.to_continuous_linear_map\n    calc\n      «expr‖ ‖₊» (u e) =\n          «expr‖ ‖₊»\n            (u\n              (finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n                («expr • » (v.equiv_fun e i) (v i)))) :=\n        by rw [v.sum_equiv_fun]\n      _ =\n          «expr‖ ‖₊»\n            (finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n              («expr • » (v.equiv_fun e i) (u <| v i))) :=\n        by simp [u.map_sum, LinearMap.map_smul]\n      _ ≤\n          finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n            («expr‖ ‖₊» («expr • » (v.equiv_fun e i) (u <| v i))) :=\n        (nnnorm_sum_le _ _)\n      _ =\n          finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n            («expr‖ ‖₊» (v.equiv_fun e i) * «expr‖ ‖₊» (u (v i))) :=\n        by simp only [nnnorm_smul]\n      _ ≤\n          finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n            («expr‖ ‖₊» (v.equiv_fun e i) * M) :=\n        (Finset.sum_le_sum fun i hi => mul_le_mul_of_nonneg_left (hu i) (zero_le _))\n      _ =\n          finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n              («expr‖ ‖₊» (v.equiv_fun e i)) *\n            M :=\n        finset.sum_mul.symm\n      _ ≤ «expr • » (Fintype.card ι) («expr‖ ‖₊» φ * «expr‖ ‖₊» e) * M :=\n        (suffices _ from mul_le_mul_of_nonneg_right this (zero_le M)\n        calc\n          finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n                («expr‖ ‖₊» (v.equiv_fun e i)) ≤\n              «expr • » (Fintype.card ι) («expr‖ ‖₊» (φ e)) :=\n            Pi.sum_nnnorm_apply_le_nnnorm _\n          _ ≤ «expr • » (Fintype.card ι) («expr‖ ‖₊» φ * «expr‖ ‖₊» e) :=\n            nsmul_le_nsmul_of_le_right (φ.le_op_nnnorm e) _\n          )\n      _ = «expr • » (Fintype.card ι) («expr‖ ‖₊» φ) * M * «expr‖ ‖₊» e := by simp only [smul_mul_assoc, mul_right_comm]\n      \n#align basis.op_nnnorm_le basis.op_nnnorm_le\n\n",
 "lipschitz_extension_constant_pos":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem lipschitz_extension_constant_pos (E' : Type _) [NormedAddCommGroup E'] [NormedSpace (exprℝ) E']\n    [FiniteDimensional (exprℝ) E'] : 0 < lipschitz_extension_constant E' :=\n  by\n  rw [lipschitz_extension_constant]\n  exact zero_lt_one.trans_le (le_max_right _ _)\n#align lipschitz_extension_constant_pos lipschitz_extension_constant_pos\n\n",
 "is_open_set_of_nat_le_rank":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\ntheorem is_open_set_of_nat_le_rank (n : ℕ) : IsOpen { f : «expr →L[ ] » E 𝕜 F | ↑n ≤ (f : «expr →ₗ[ ] » E 𝕜 F).rank } :=\n  by\n  simp only [LinearMap.le_rank_iff_exists_linearIndependent_finset, set_of_exists, ← exists_prop]\n  refine' isOpen_bunionᵢ fun t ht => _\n  have : Continuous fun f : «expr →L[ ] » E 𝕜 F => fun x : (t : Set E) => f x :=\n    continuous_pi fun x => (continuous_linear_map.apply 𝕜 F (x : E)).continuous\n  exact is_open_set_of_linear_independent.preimage this\n#align is_open_set_of_nat_le_rank is_open_set_of_nat_le_rank\n\n",
 "is_open_set_of_linear_independent":
 "theorem is_open_set_of_linear_independent {ι : Type _} [Finite ι] : IsOpen { f : ι → E | LinearIndependent 𝕜 f } :=\n  isOpen_iff_mem_nhds.2 fun f => linear_independent.eventually\n#align is_open_set_of_linear_independent is_open_set_of_linear_independent\n\n",
 "is_closed_map_smul_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n-- `smul` is a closed map in the first argument.\ntheorem is_closed_map_smul_left (c : E) : IsClosedMap fun x : 𝕜 => «expr • » x c :=\n  by\n  by_cases hc : c = 0\n  · simp_rw [hc, smul_zero]\n    exact isClosedMap_const\n  · exact (closed_embedding_smul_left hc).is_closed_map\n#align is_closed_map_smul_left is_closed_map_smul_left\n\n",
 "finite_dimensional_of_is_compact_closed_ball₀":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- **Riesz's theorem**: if a closed ball with center zero of positive radius is compact in a vector\nspace, then the space is finite-dimensional. -/\ntheorem finite_dimensional_of_is_compact_closed_ball₀ {r : exprℝ} (rpos : 0 < r)\n    (h : IsCompact (Metric.closedBall (0 : E) r)) : FiniteDimensional 𝕜 E :=\n  by\n  by_contra hfin\n  obtain ⟨R, f, Rgt, fle, lef⟩ :\n    ∃ (R : exprℝ)(f : ℕ → E), 1 < R ∧ (∀ n, «expr‖ ‖» (f n) ≤ R) ∧ ∀ m n, m ≠ n → 1 ≤ «expr‖ ‖» (f m - f n) :=\n    exists_seq_norm_le_one_le_norm_sub hfin\n  have rRpos : 0 < r / R := div_pos rpos (zero_lt_one.trans Rgt)\n  obtain ⟨c, hc⟩ : ∃ c : 𝕜, 0 < «expr‖ ‖» c ∧ «expr‖ ‖» c < r / R := NormedField.exists_norm_lt _ rRpos\n  let g := fun n : ℕ => «expr • » c (f n)\n  have A : ∀ n, g n ∈ Metric.closedBall (0 : E) r := by\n    intro n\n    simp only [norm_smul, dist_zero_right, Metric.mem_closedBall]\n    calc\n      «expr‖ ‖» c * «expr‖ ‖» (f n) ≤ r / R * R := mul_le_mul hc.2.le (fle n) (norm_nonneg _) rRpos.le\n      _ = r := by field_simp [(zero_lt_one.trans Rgt).ne']\n      \n  obtain ⟨x, hx, φ, φmono, φlim⟩ :\n    ∃ (x : E)(H : x ∈ Metric.closedBall (0 : E) r)(φ : ℕ → ℕ), StrictMono φ ∧ tendsto (g ∘ φ) at_top ((nhds) x) :=\n    h.tendsto_subseq A\n  have B : CauchySeq (g ∘ φ) := φlim.cauchy_seq\n  obtain ⟨N, hN⟩ : ∃ N : ℕ, ∀ n : ℕ, N ≤ n → dist ((g ∘ φ) n) ((g ∘ φ) N) < «expr‖ ‖» c :=\n    Metric.cauchySeq_iff'.1 B («expr‖ ‖» c) hc.1\n  apply lt_irrefl («expr‖ ‖» c)\n  calc\n    «expr‖ ‖» c ≤ dist (g (φ (N + 1))) (g (φ N)) :=\n      by\n      conv_lhs => rw [← mul_one («expr‖ ‖» c)]\n      simp only [g, dist_eq_norm, ← smul_sub, norm_smul, -mul_one]\n      apply mul_le_mul_of_nonneg_left (lef _ _ (ne_of_gt _)) (norm_nonneg _)\n      exact φmono (nat.lt_succ_self N)\n    _ < «expr‖ ‖» c := hN (N + 1) (nat.le_succ N)\n    \n#align finite_dimensional_of_is_compact_closed_ball₀ finite_dimensional_of_is_compact_closed_ball₀\n\n",
 "finite_dimensional_of_is_compact_closed_ball":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- **Riesz's theorem**: if a closed ball of positive radius is compact in a vector space, then the\nspace is finite-dimensional. -/\ntheorem finite_dimensional_of_is_compact_closed_ball {r : exprℝ} (rpos : 0 < r) {c : E}\n    (h : IsCompact (Metric.closedBall c r)) : FiniteDimensional 𝕜 E :=\n  by\n  apply finite_dimensional_of_is_compact_closed_ball₀ 𝕜 rpos\n  have : Continuous fun x => -c + x := continuous_const.add continuous_id\n  simpa using h.image this\n#align finite_dimensional_of_is_compact_closed_ball finite_dimensional_of_is_compact_closed_ball\n\n",
 "extend_finite_dimension":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/-- Any `K`-Lipschitz map from a subset `s` of a metric space `α` to a finite-dimensional real\nvector space `E'` can be extended to a Lipschitz map on the whole space `α`, with a slightly worse\nconstant `lipschitz_extension_constant E' * K`. -/\ntheorem lipschitz_on_with.extend_finite_dimension {α : Type _} [PseudoMetricSpace α] {E' : Type _}\n    [NormedAddCommGroup E'] [NormedSpace (exprℝ) E'] [FiniteDimensional (exprℝ) E'] {s : Set α} {f : α → E'}\n    {K : nnreal} (hf : LipschitzOnWith K f s) :\n    ∃ g : α → E', LipschitzWith (lipschitz_extension_constant E' * K) g ∧ EqOn f g s :=\n  by\n  /- This result is already known for spaces `ι → ℝ`. We use a continuous linear equiv between\n    `E'` and such a space to transfer the result to `E'`. -/\n  let ι : Type _ := Basis.ofVectorSpaceIndex (exprℝ) E'\n  let A := (Basis.ofVectorSpace (exprℝ) E').equiv_fun.to_continuous_linear_equiv\n  have LA : LipschitzWith («expr‖ ‖₊» A.to_continuous_linear_map) A := by apply A.lipschitz\n  have L : LipschitzOnWith («expr‖ ‖₊» A.to_continuous_linear_map * K) (A ∘ f) s := LA.comp_lipschitz_on_with hf\n  obtain ⟨g, hg, gs⟩ :\n    ∃ g : α → ι → exprℝ, LipschitzWith («expr‖ ‖₊» A.to_continuous_linear_map * K) g ∧ eq_on (A ∘ f) g s := L.extend_pi\n  refine' ⟨A.symm ∘ g, _, _⟩\n  · have LAsymm : LipschitzWith («expr‖ ‖₊» A.symm.to_continuous_linear_map) A.symm := by apply A.symm.lipschitz\n    apply (LAsymm.comp hg).weaken\n    rw [lipschitz_extension_constant, ← mul_assoc]\n    refine' mul_le_mul' (le_max_left _ _) le_rfl\n  · intro x hx\n    have : A (f x) = g x := gs hx\n    simp only [(· ∘ ·), ← this, A.symm_apply_apply]\n#align lipschitz_on_with.extend_finite_dimension lipschitz_on_with.extend_finite_dimension\n\n",
 "exists_seq_norm_le_one_le_norm_sub'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/-- In an infinite-dimensional normed space, there exists a sequence of points which are all\nbounded by `R` and at distance at least `1`. For a version not assuming `c` and `R`, see\n`exists_seq_norm_le_one_le_norm_sub`. -/\ntheorem exists_seq_norm_le_one_le_norm_sub' {c : 𝕜} (hc : 1 < «expr‖ ‖» c) {R : exprℝ} (hR : «expr‖ ‖» c < R)\n    (h : ¬FiniteDimensional 𝕜 E) : ∃ f : ℕ → E, (∀ n, «expr‖ ‖» (f n) ≤ R) ∧ ∀ m n, m ≠ n → 1 ≤ «expr‖ ‖» (f m - f n) :=\n  by\n  have : is_symm E fun x y : E => 1 ≤ «expr‖ ‖» (x - y) :=\n    by\n    constructor\n    intro x y hxy\n    rw [← norm_neg]\n    simpa\n  apply exists_seq_of_forall_finset_exists' (fun x : E => «expr‖ ‖» x ≤ R) fun (x : E) (y : E) => 1 ≤ «expr‖ ‖» (x - y)\n  intro s hs\n  exact exists_norm_le_le_norm_sub_of_finset hc hR h s\n#align exists_seq_norm_le_one_le_norm_sub' exists_seq_norm_le_one_le_norm_sub'\n\n",
 "exists_seq_norm_le_one_le_norm_sub":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem exists_seq_norm_le_one_le_norm_sub (h : ¬FiniteDimensional 𝕜 E) :\n    ∃ (R : exprℝ)(f : ℕ → E), 1 < R ∧ (∀ n, «expr‖ ‖» (f n) ≤ R) ∧ ∀ m n, m ≠ n → 1 ≤ «expr‖ ‖» (f m - f n) :=\n  by\n  obtain ⟨c, hc⟩ : ∃ c : 𝕜, 1 < «expr‖ ‖» c := NormedField.exists_one_lt_norm 𝕜\n  have A : «expr‖ ‖» c < «expr‖ ‖» c + 1 := by linarith\n  rcases exists_seq_norm_le_one_le_norm_sub' hc A h with ⟨f, hf⟩\n  exact ⟨«expr‖ ‖» c + 1, f, hc.trans A, hf.1, hf.2⟩\n#align exists_seq_norm_le_one_le_norm_sub exists_seq_norm_le_one_le_norm_sub\n\n",
 "exists_right_inverse_of_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\ntheorem continuous_linear_map.exists_right_inverse_of_surjective [FiniteDimensional 𝕜 F] (f : «expr →L[ ] » E 𝕜 F)\n    (hf : LinearMap.range f = «expr⊤») : ∃ g : «expr →L[ ] » F 𝕜 E, f.comp g = ContinuousLinearMap.id 𝕜 F :=\n  let ⟨g, hg⟩ := (f : «expr →ₗ[ ] » E 𝕜 F).exists_right_inverse_of_surjective hf\n  ⟨g.to_continuous_linear_map, ContinuousLinearMap.ext <| LinearMap.ext_iff.1 hg⟩\n#align continuous_linear_map.exists_right_inverse_of_surjective continuous_linear_map.exists_right_inverse_of_surjective\n\n",
 "exists_op_norm_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/-- A weaker version of `basis.op_norm_le` that abstracts away the value of `C`. -/\ntheorem basis.exists_op_norm_le {ι : Type _} [Finite ι] (v : Basis ι 𝕜 E) :\n    ∃ C > (0 : exprℝ),\n      ∀ {u : «expr →L[ ] » E 𝕜 F} {M : exprℝ}, 0 ≤ M → (∀ i, «expr‖ ‖» (u (v i)) ≤ M) → «expr‖ ‖» u ≤ C * M :=\n  let ⟨C, hC, h⟩ := v.exists_op_nnnorm_le\n  ⟨C, hC, fun u => Subtype.forall'.mpr h⟩\n#align basis.exists_op_norm_le basis.exists_op_norm_le\n\n",
 "exists_op_nnnorm_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/-- A weaker version of `basis.op_nnnorm_le` that abstracts away the value of `C`. -/\ntheorem basis.exists_op_nnnorm_le {ι : Type _} [Finite ι] (v : Basis ι 𝕜 E) :\n    ∃ C > (0 : nnreal),\n      ∀ {u : «expr →L[ ] » E 𝕜 F} (M : nnreal), (∀ i, «expr‖ ‖₊» (u (v i)) ≤ M) → «expr‖ ‖₊» u ≤ C * M :=\n  by\n  cases nonempty_fintype ι <;>\n    exact\n      ⟨max («expr • » (Fintype.card ι) («expr‖ ‖₊» v.equiv_funL.to_continuous_linear_map)) 1,\n        zero_lt_one.trans_le (le_max_right _ _), fun u M hu =>\n        (v.op_nnnorm_le M hu).trans <| mul_le_mul_of_nonneg_right (le_max_left _ _) (zero_le M)⟩\n#align basis.exists_op_nnnorm_le basis.exists_op_nnnorm_le\n\n",
 "exists_norm_le_le_norm_sub_of_finset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/-- In an infinite dimensional space, given a finite number of points, one may find a point\nwith norm at most `R` which is at distance at least `1` of all these points. -/\ntheorem exists_norm_le_le_norm_sub_of_finset {c : 𝕜} (hc : 1 < «expr‖ ‖» c) {R : exprℝ} (hR : «expr‖ ‖» c < R)\n    (h : ¬FiniteDimensional 𝕜 E) (s : Finset E) : ∃ x : E, «expr‖ ‖» x ≤ R ∧ ∀ y ∈ s, 1 ≤ «expr‖ ‖» (y - x) :=\n  by\n  let F := Submodule.span 𝕜 (s : Set E)\n  haveI : FiniteDimensional 𝕜 F :=\n    Module.finite_def.2 ((Submodule.fg_top _).2 (Submodule.fg_def.2 ⟨s, Finset.finite_toSet _, rfl⟩))\n  have Fclosed : IsClosed (F : Set E) := submodule.closed_of_finite_dimensional _\n  have : ∃ x, x ∉ F := by\n    contrapose! h\n    have : («expr⊤» : Submodule 𝕜 E) = F := by\n      ext x\n      simp [h]\n    have : FiniteDimensional 𝕜 («expr⊤» : Submodule 𝕜 E) := by rwa [this]\n    refine' Module.finite_def.2 ((Submodule.fg_top _).1 (Module.finite_def.1 this))\n  obtain ⟨x, xR, hx⟩ : ∃ x : E, «expr‖ ‖» x ≤ R ∧ ∀ y : E, y ∈ F → 1 ≤ «expr‖ ‖» (x - y) :=\n    riesz_lemma_of_norm_lt hc hR Fclosed this\n  have hx' : ∀ y : E, y ∈ F → 1 ≤ «expr‖ ‖» (y - x) := by\n    intro y hy\n    rw [← norm_neg]\n    simpa using hx y hy\n  exact ⟨x, xR, fun y hy => hx' _ (Submodule.subset_span hy)⟩\n#align exists_norm_le_le_norm_sub_of_finset exists_norm_le_le_norm_sub_of_finset\n\n",
 "exists_mem_frontier_inf_dist_compl_eq_dist":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/-- If `K` is a compact set in a nontrivial real normed space and `x ∈ K`, then there exists a point\n`y` of the boundary of `K` at distance `metric.inf_dist x Kᶜ` from `x`. See also\n`exists_mem_frontier_inf_dist_compl_eq_dist`. -/\ntheorem is_compact.exists_mem_frontier_inf_dist_compl_eq_dist {E : Type _} [NormedAddCommGroup E]\n    [NormedSpace (exprℝ) E] [Nontrivial E] {x : E} {K : Set E} (hK : IsCompact K) (hx : x ∈ K) :\n    ∃ y ∈ frontier K, Metric.infDist x («expr ᶜ» K) = dist x y :=\n  by\n  obtain hx' | hx' : x ∈ interior K ∪ frontier K :=\n    by\n    rw [← closure_eq_interior_union_frontier]\n    exact subset_closure hx\n  · rw [mem_interior_iff_mem_nhds, metric.nhds_basis_closed_ball.mem_iff] at hx'\n    rcases hx' with ⟨r, hr₀, hrK⟩\n    have : FiniteDimensional (exprℝ) E :=\n      finite_dimensional_of_is_compact_closed_ball (exprℝ) hr₀\n        (isCompact_of_isClosed_subset hK Metric.isClosed_ball hrK)\n    exact exists_mem_frontier_inf_dist_compl_eq_dist hx hK.ne_univ\n  · refine' ⟨x, hx', _⟩\n    rw [frontier_eq_closure_inter_closure] at hx'\n    rw [Metric.infDist_zero_of_mem_closure hx'.2, dist_self]\n#align is_compact.exists_mem_frontier_inf_dist_compl_eq_dist is_compact.exists_mem_frontier_inf_dist_compl_eq_dist\n\n",
 "exists_antilipschitz_with":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem linear_map.exists_antilipschitz_with [FiniteDimensional 𝕜 E] (f : «expr →ₗ[ ] » E 𝕜 F) (hf : f.ker = «expr⊥») :\n    ∃ K > 0, AntilipschitzWith K f := by\n  cases subsingleton_or_nontrivial E\n  · exact ⟨1, zero_lt_one, AntilipschitzWith.of_subsingleton⟩\n  · rw [LinearMap.ker_eq_bot] at hf\n    let e : «expr ≃L[ ] » E 𝕜 f.range := (LinearEquiv.ofInjective f hf).to_continuous_linear_equiv\n    exact ⟨_, e.nnnorm_symm_pos, e.antilipschitz⟩\n#align linear_map.exists_antilipschitz_with linear_map.exists_antilipschitz_with\n\n",
 "eventually":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\nprotected theorem linear_independent.eventually {ι} [Finite ι] {f : ι → E} (hf : LinearIndependent 𝕜 f) :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" ((nhds) f)\n      (LinearIndependent 𝕜 g) :=\n  by\n  cases nonempty_fintype ι\n  simp only [Fintype.linearIndependent_iff'] at hf⊢\n  rcases linear_map.exists_antilipschitz_with _ hf with ⟨K, K0, hK⟩\n  have :\n    tendsto\n      (fun g : ι → E =>\n        finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n          («expr‖ ‖» (g i - f i)))\n      ((nhds) f)\n      (nhds <|\n        finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n          («expr‖ ‖» (f i - f i))) :=\n    tendsto_finset_sum _ fun i hi => tendsto.norm <| ((continuous_apply i).tendsto _).sub tendsto_const_nhds\n  simp only [sub_self, norm_zero, Finset.sum_const_zero] at this\n  refine' (this.eventually (gt_mem_nhds <| inv_pos.2 K0)).mono fun g hg => _\n  replace hg :\n    finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n        («expr‖ ‖₊» (g i - f i)) <\n      K⁻¹\n  · rw [← NNReal.coe_lt_coe]\n    push_cast\n    exact hg\n  rw [LinearMap.ker_eq_bot]\n  refine' (hK.add_sub_lipschitz_with (LipschitzWith.of_dist_le_mul fun v u => _) hg).injective\n  simp only [dist_eq_norm, linear_map.lsum_apply, Pi.sub_apply, LinearMap.sum_apply, LinearMap.comp_apply,\n    LinearMap.proj_apply, LinearMap.smulRight_apply, LinearMap.id_apply, ← Finset.sum_sub_distrib, ← smul_sub, ←\n    sub_smul, NNReal.coe_sum, coe_nnnorm, Finset.sum_mul]\n  refine' norm_sum_le_of_le _ fun i _ => _\n  rw [norm_smul, mul_comm]\n  exact mul_le_mul_of_nonneg_left (norm_le_pi_norm (v - u) i) (norm_nonneg _)\n#align linear_independent.eventually linear_independent.eventually\n\n",
 "eq_one_or_finite_dimensional":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- If a function has compact multiplicative support, then either the function is trivial or the\nspace if finite-dimensional. -/\n@[to_additive\n      \"If a function has compact support, then either the function is trivial or the\\nspace if finite-dimensional.\"]\ntheorem has_compact_mul_support.eq_one_or_finite_dimensional {X : Type _} [TopologicalSpace X] [One X] [T2Space X]\n    {f : E → X} (hf : HasCompactMulSupport f) (h'f : Continuous f) : f = 1 ∨ FiniteDimensional 𝕜 E :=\n  by\n  by_cases h : ∀ x, f x = 1\n  · apply or.inl\n    ext x\n    exact h x\n  apply or.inr\n  push_neg  at h\n  obtain ⟨x, hx⟩ : ∃ x, f x ≠ 1\n  exact h\n  have : Function.mulSupport f ∈ (nhds) x := h'f.is_open_mul_support.mem_nhds hx\n  obtain ⟨r, rpos, hr⟩ : ∃ (r : exprℝ)(hi : 0 < r), Metric.closedBall x r ⊆ Function.mulSupport f\n  exact metric.nhds_basis_closed_ball.mem_iff.1 this\n  have : IsCompact (Metric.closedBall x r) :=\n    isCompact_of_isClosed_subset hf Metric.isClosed_ball (hr.trans (subset_mulTSupport _))\n  exact finite_dimensional_of_is_compact_closed_ball 𝕜 rpos this\n#align has_compact_mul_support.eq_one_or_finite_dimensional has_compact_mul_support.eq_one_or_finite_dimensional\n\n",
 "continuous_on_clm_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/-- A family of continuous linear maps is continuous on `s` if all its applications are. -/\ntheorem continuous_on_clm_apply {X : Type _} [TopologicalSpace X] [FiniteDimensional 𝕜 E] {f : X → «expr →L[ ] » E 𝕜 F}\n    {s : Set X} : ContinuousOn f s ↔ ∀ y, ContinuousOn (fun x => f x y) s :=\n  by\n  refine' ⟨fun h y => (continuous_linear_map.apply 𝕜 F y).continuous.comp_continuous_on h, fun h => _⟩\n  let d := finrank 𝕜 E\n  have hd : d = finrank 𝕜 (Fin d → 𝕜) := (finrank_fin_fun 𝕜).symm\n  let e₁ : «expr ≃L[ ] » E 𝕜 (Fin d → 𝕜) := continuous_linear_equiv.of_finrank_eq hd\n  let e₂ : «expr ≃L[ ] » («expr →L[ ] » E 𝕜 F) 𝕜 (Fin d → F) :=\n    (e₁.arrow_congr (1 : «expr ≃L[ ] » F 𝕜 F)).trans (continuous_linear_equiv.pi_ring (Fin d))\n  rw [← function.comp.left_id f, ← e₂.symm_comp_self]\n  exact e₂.symm.continuous.comp_continuous_on (continuous_on_pi.mpr fun i => h _)\n#align continuous_on_clm_apply continuous_on_clm_apply\n\n",
 "continuous_of_finite_dimensional":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ᵃ[ ] » -/\ntheorem affine_equiv.continuous_of_finite_dimensional (f : «expr ≃ᵃ[ ] » PE 𝕜 PF) : Continuous f :=\n  f.to_affine_map.continuous_of_finite_dimensional\n#align affine_equiv.continuous_of_finite_dimensional affine_equiv.continuous_of_finite_dimensional\n\n",
 "continuous_det":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\ntheorem continuous_linear_map.continuous_det : Continuous fun f : «expr →L[ ] » E 𝕜 E => f.det :=\n  by\n  change Continuous fun f : «expr →L[ ] » E 𝕜 E => (f : «expr →ₗ[ ] » E 𝕜 E).det\n  by_cases h : ∃ s : Finset E, Nonempty (Basis («expr↥ » s) 𝕜 E)\n  · rcases h with ⟨s, ⟨b⟩⟩\n    haveI : FiniteDimensional 𝕜 E := FiniteDimensional.of_fintype_basis b\n    simp_rw [LinearMap.det_eq_det_toMatrix_of_finset b]\n    refine' Continuous.matrix_det _\n    exact ((LinearMap.toMatrix b b).to_linear_map.comp (ContinuousLinearMap.coeLM 𝕜)).continuous_of_finite_dimensional\n  · unfold LinearMap.det\n    simpa only [h, MonoidHom.one_apply, dif_neg, not_false_iff] using continuous_const\n#align continuous_linear_map.continuous_det continuous_linear_map.continuous_det\n\n",
 "continuous_clm_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\ntheorem continuous_clm_apply {X : Type _} [TopologicalSpace X] [FiniteDimensional 𝕜 E] {f : X → «expr →L[ ] » E 𝕜 F} :\n    Continuous f ↔ ∀ y, Continuous fun x => f x y := by\n  simp_rw [continuous_iff_continuousOn_univ, continuous_on_clm_apply]\n#align continuous_clm_apply continuous_clm_apply\n\n",
 "complete_of_finite_dimensional":
 "/-- A finite-dimensional subspace is complete. -/\ntheorem submodule.complete_of_finite_dimensional (s : Submodule 𝕜 E) [FiniteDimensional 𝕜 s] : IsComplete (s : Set E) :=\n  completeSpace_coe_iff_isComplete.1 (finite_dimensional.complete 𝕜 s)\n#align submodule.complete_of_finite_dimensional submodule.complete_of_finite_dimensional\n\n",
 "complete":
 "theorem finite_dimensional.complete [FiniteDimensional 𝕜 E] : CompleteSpace E :=\n  by\n  set e := continuous_linear_equiv.of_finrank_eq (@finrank_fin_fun 𝕜 _ _ (finrank 𝕜 E)).symm\n  have : UniformEmbedding e.to_linear_equiv.to_equiv.symm := e.symm.uniform_embedding\n  exact (completeSpace_congr this).1 (by infer_instance)\n#align finite_dimensional.complete finite_dimensional.complete\n\n",
 "coe_to_linear_isometry_equiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗᵢ[ ] » -/\n/-\nCopyright (c) 2019 Sébastien Gouëzel. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Sébastien Gouëzel\n-/\n@[simp]\ntheorem coe_to_linear_isometry_equiv (li : «expr →ₗᵢ[ ] » E₁ R₁ F) (h : finrank R₁ E₁ = finrank R₁ F) :\n    (li.to_linear_isometry_equiv h : E₁ → F) = li :=\n  rfl\n#align coe_to_linear_isometry_equiv coe_to_linear_isometry_equiv\n\n",
 "coe_to_homeomorph_of_finite_dimensional_symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ᵃ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n@[simp]\ntheorem affine_equiv.coe_to_homeomorph_of_finite_dimensional_symm (f : «expr ≃ᵃ[ ] » PE 𝕜 PF) :\n    «expr⇑ » f.to_homeomorph_of_finite_dimensional.symm = f.symm :=\n  rfl\n#align affine_equiv.coe_to_homeomorph_of_finite_dimensional_symm affine_equiv.coe_to_homeomorph_of_finite_dimensional_symm\n\n",
 "coe_to_homeomorph_of_finite_dimensional":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ᵃ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n@[simp]\ntheorem affine_equiv.coe_to_homeomorph_of_finite_dimensional (f : «expr ≃ᵃ[ ] » PE 𝕜 PF) :\n    «expr⇑ » f.to_homeomorph_of_finite_dimensional = f :=\n  rfl\n#align affine_equiv.coe_to_homeomorph_of_finite_dimensional affine_equiv.coe_to_homeomorph_of_finite_dimensional\n\n",
 "coe_to_affine_isometry_equiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ᵃⁱ[ ] » -/\n@[simp]\ntheorem coe_to_affine_isometry_equiv [Inhabited P₁] (li : «expr →ᵃⁱ[ ] » P₁ 𝕜 P₂) (h : finrank 𝕜 V₁ = finrank 𝕜 V₂) :\n    (li.to_affine_isometry_equiv h : P₁ → P₂) = li :=\n  rfl\n#align coe_to_affine_isometry_equiv coe_to_affine_isometry_equiv\n\n",
 "closed_of_finite_dimensional":
 "theorem affine_subspace.closed_of_finite_dimensional {P : Type _} [MetricSpace P] [NormedAddTorsor E P]\n    (s : AffineSubspace 𝕜 P) [FiniteDimensional 𝕜 s.direction] : IsClosed (s : Set P) :=\n  s.is_closed_direction_iff.mp s.direction.closed_of_finite_dimensional\n#align affine_subspace.closed_of_finite_dimensional affine_subspace.closed_of_finite_dimensional\n\n",
 "closed_embedding_smul_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem closed_embedding_smul_left {c : E} (hc : c ≠ 0) : ClosedEmbedding fun x : 𝕜 => «expr • » x c :=\n  linear_equiv.closed_embedding_of_injective (LinearMap.ker_toSpanSingleton 𝕜 E hc)\n#align closed_embedding_smul_left closed_embedding_smul_left\n\n",
 "closed_embedding_of_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n/-- An injective linear map with finite-dimensional domain is a closed embedding. -/\ntheorem linear_equiv.closed_embedding_of_injective {f : «expr →ₗ[ ] » E 𝕜 F} (hf : f.ker = «expr⊥»)\n    [FiniteDimensional 𝕜 E] : ClosedEmbedding («expr⇑ » f) :=\n  let g := LinearEquiv.ofInjective f (LinearMap.ker_eq_bot.mp hf)\n  { embedding_subtype_val.comp g.to_continuous_linear_equiv.to_homeomorph.embedding with\n    closed_range := by\n      haveI := f.finite_dimensional_range\n      simpa [f.range_coe] using f.range.closed_of_finite_dimensional }\n#align linear_equiv.closed_embedding_of_injective linear_equiv.closed_embedding_of_injective\n\n"}