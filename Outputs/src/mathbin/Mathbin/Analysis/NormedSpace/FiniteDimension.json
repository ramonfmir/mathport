{"to_linear_isometry_equiv_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗᵢ[ ] » -/\n@[simp]\ntheorem to_linear_isometry_equiv_apply (li : «expr →ₗᵢ[ ] » E₁ R₁ F) (h : finrank R₁ E₁ = finrank R₁ F) (x : E₁) :\n    (li.to_linear_isometry_equiv h) x = li x :=\n  rfl\n#align to_linear_isometry_equiv_apply to_linear_isometry_equiv_apply\n\n",
 "to_affine_isometry_equiv_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ᵃⁱ[ ] » -/\n@[simp]\ntheorem to_affine_isometry_equiv_apply [inhabited P₁] (li : «expr →ᵃⁱ[ ] » P₁ 𝕜 P₂) (h : finrank 𝕜 V₁ = finrank 𝕜 V₂)\n    (x : P₁) : (li.to_affine_isometry_equiv h) x = li x :=\n  rfl\n#align to_affine_isometry_equiv_apply to_affine_isometry_equiv_apply\n\n",
 "summable_of_is_equivalent_nat":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `asymptotics.is_equivalent -/\ntheorem summable_of_is_equivalent_nat {E : Type _} [normed_add_comm_group E] [normed_space (exprℝ) E]\n    [finite_dimensional (exprℝ) E] {f : ℕ → E} {g : ℕ → E} (hg : summable g)\n    (h : asymptotics.is_equivalent f at_top g) : summable f :=\n  hg.trans_sub (summable_of_is_O_nat' hg h.is_o.is_O)\n#align summable_of_is_equivalent_nat summable_of_is_equivalent_nat\n\n",
 "summable_of_is_equivalent":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `asymptotics.is_equivalent -/\ntheorem summable_of_is_equivalent {ι E : Type _} [normed_add_comm_group E] [normed_space (exprℝ) E]\n    [finite_dimensional (exprℝ) E] {f : ι → E} {g : ι → E} (hg : summable g)\n    (h : asymptotics.is_equivalent f cofinite g) : summable f :=\n  hg.trans_sub (summable_of_is_O' hg h.is_o.is_O)\n#align summable_of_is_equivalent summable_of_is_equivalent\n\n",
 "summable_of_is_O_nat'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =O[ ] » -/\ntheorem summable_of_is_O_nat' {E F : Type _} [normed_add_comm_group E] [complete_space E] [normed_add_comm_group F]\n    [normed_space (exprℝ) F] [finite_dimensional (exprℝ) F] {f : ℕ → E} {g : ℕ → F} (hg : summable g)\n    (h : «expr =O[ ] » f at_top g) : summable f :=\n  summable_of_is_O_nat (summable_norm_iff.mpr hg) h.norm_right\n#align summable_of_is_O_nat' summable_of_is_O_nat'\n\n",
 "summable_of_is_O'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =O[ ] » -/\ntheorem summable_of_is_O' {ι E F : Type _} [normed_add_comm_group E] [complete_space E] [normed_add_comm_group F]\n    [normed_space (exprℝ) F] [finite_dimensional (exprℝ) F] {f : ι → E} {g : ι → F} (hg : summable g)\n    (h : «expr =O[ ] » f cofinite g) : summable f :=\n  summable_of_is_O (summable_norm_iff.mpr hg) h.norm_right\n#align summable_of_is_O' summable_of_is_O'\n\n",
 "summable_norm_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/-- In a finite dimensional vector space over `ℝ`, the series `∑ x, ‖f x‖` is unconditionally\nsummable if and only if the series `∑ x, f x` is unconditionally summable. One implication holds in\nany complete normed space, while the other holds only in finite dimensional spaces. -/\ntheorem summable_norm_iff {α E : Type _} [normed_add_comm_group E] [normed_space (exprℝ) E]\n    [finite_dimensional (exprℝ) E] {f : α → E} : (summable fun x => «expr‖ ‖» (f x)) ↔ summable f :=\n  by\n  refine' ⟨summable_of_summable_norm, fun hf => _⟩\n  -- First we use a finite basis to reduce the problem to the case `E = fin N → ℝ`\n  suffices ∀ {N : ℕ} {g : α → fin N → exprℝ}, summable g → summable fun x => «expr‖ ‖» (g x)\n    by\n    obtain v := fin_basis (exprℝ) E\n    set e := v.equiv_funL\n    have : summable fun x => «expr‖ ‖» (e (f x)) := this (e.summable.2 hf)\n    refine'\n      summable_of_norm_bounded _\n        (this.mul_left ↑(«expr‖ ‖₊» (e.symm : «expr →L[ ] » (fin (finrank (exprℝ) E) → exprℝ) (exprℝ) E))) fun i => _\n    simpa using (e.symm : «expr →L[ ] » (fin (finrank (exprℝ) E) → exprℝ) (exprℝ) E).le_op_norm (e <| f i)\n  clear! E\n  -- Now we deal with `g : α → fin N → ℝ`\n  intro N g hg\n  have : ∀ i, summable fun x => «expr‖ ‖» (g x i) := fun i => (pi.summable.1 hg i).abs\n  refine' summable_of_norm_bounded _ (summable_sum fun i (hi : i ∈ finset.univ) => this i) fun x => _\n  rw [norm_norm, pi_norm_le_iff_of_nonneg]\n  · refine' fun i => finset.single_le_sum (fun i hi => _) (finset.mem_univ i)\n    exact norm_nonneg (g x i)\n  · exact finset.sum_nonneg fun _ _ => norm_nonneg _\n#align summable_norm_iff summable_norm_iff\n\n",
 "summable_iff_nat":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `asymptotics.is_equivalent -/\ntheorem is_equivalent.summable_iff_nat {E : Type _} [normed_add_comm_group E] [normed_space (exprℝ) E]\n    [finite_dimensional (exprℝ) E] {f : ℕ → E} {g : ℕ → E} (h : asymptotics.is_equivalent f at_top g) :\n    summable f ↔ summable g :=\n  ⟨fun hf => summable_of_is_equivalent_nat hf h.symm, fun hg => summable_of_is_equivalent_nat hg h⟩\n#align is_equivalent.summable_iff_nat is_equivalent.summable_iff_nat\n\n",
 "summable_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `asymptotics.is_equivalent -/\ntheorem is_equivalent.summable_iff {ι E : Type _} [normed_add_comm_group E] [normed_space (exprℝ) E]\n    [finite_dimensional (exprℝ) E] {f : ι → E} {g : ι → E} (h : asymptotics.is_equivalent f cofinite g) :\n    summable f ↔ summable g :=\n  ⟨fun hf => summable_of_is_equivalent hf h.symm, fun hg => summable_of_is_equivalent hg h⟩\n#align is_equivalent.summable_iff is_equivalent.summable_iff\n\n",
 "proper":
 "/-- Any finite-dimensional vector space over a proper field is proper.\nWe do not register this as an instance to avoid an instance loop when trying to prove the\nproperness of `𝕜`, and the search for `𝕜` as an unknown metavariable. Declare the instance\nexplicitly when needed. -/\ntheorem finite_dimensional.proper [finite_dimensional 𝕜 E] : proper_space E :=\n  by\n  set e := continuous_linear_equiv.of_finrank_eq (@finrank_fin_fun 𝕜 _ (finrank 𝕜 E)).symm\n  exact e.symm.antilipschitz.proper_space e.symm.continuous e.symm.surjective\n#align finite_dimensional.proper finite_dimensional.proper\n\n",
 "op_norm_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem basis.op_norm_le {ι : Type _} [fintype ι] (v : basis ι 𝕜 E) {u : «expr →L[ ] » E 𝕜 F} {M : exprℝ} (hM : 0 ≤ M)\n    (hu : ∀ i, «expr‖ ‖» (u (v i)) ≤ M) :\n    «expr‖ ‖» u ≤ «expr • » (fintype.card ι) («expr‖ ‖» v.equiv_funL.to_continuous_linear_map) * M := by\n  simpa using nnreal.coe_le_coe.mpr (v.op_nnnorm_le ⟨M, hM⟩ hu)\n#align basis.op_norm_le basis.op_norm_le\n\n",
 "op_nnnorm_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\ntheorem basis.op_nnnorm_le {ι : Type _} [fintype ι] (v : basis ι 𝕜 E) {u : «expr →L[ ] » E 𝕜 F} (M : nnreal)\n    (hu : ∀ i, «expr‖ ‖₊» (u (v i)) ≤ M) :\n    «expr‖ ‖₊» u ≤ «expr • » (fintype.card ι) («expr‖ ‖₊» v.equiv_funL.to_continuous_linear_map) * M :=\n  u.op_nnnorm_le_bound _ fun e => by\n    set φ := v.equiv_funL.to_continuous_linear_map\n    calc\n      «expr‖ ‖₊» (u e) =\n          «expr‖ ‖₊»\n            (u\n              (finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n                («expr • » (v.equiv_fun e i) (v i)))) :=\n        by rw [v.sum_equiv_fun]\n      _ =\n          «expr‖ ‖₊»\n            (finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n              («expr • » (v.equiv_fun e i) (u <| v i))) :=\n        by simp [u.map_sum, linear_map.map_smul]\n      _ ≤\n          finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n            («expr‖ ‖₊» («expr • » (v.equiv_fun e i) (u <| v i))) :=\n        nnnorm_sum_le _ _\n      _ =\n          finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n            («expr‖ ‖₊» (v.equiv_fun e i) * «expr‖ ‖₊» (u (v i))) :=\n        by simp only [nnnorm_smul]\n      _ ≤\n          finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n            («expr‖ ‖₊» (v.equiv_fun e i) * M) :=\n        finset.sum_le_sum fun i hi => mul_le_mul_of_nonneg_left (hu i) (zero_le _)\n      _ =\n          finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n              («expr‖ ‖₊» (v.equiv_fun e i)) *\n            M :=\n        finset.sum_mul.symm\n      _ ≤ «expr • » (fintype.card ι) («expr‖ ‖₊» φ * «expr‖ ‖₊» e) * M :=\n        suffices _ from mul_le_mul_of_nonneg_right this (zero_le M)\n        calc\n          finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n                («expr‖ ‖₊» (v.equiv_fun e i)) ≤\n              «expr • » (fintype.card ι) («expr‖ ‖₊» (φ e)) :=\n            pi.sum_nnnorm_apply_le_nnnorm _\n          _ ≤ «expr • » (fintype.card ι) («expr‖ ‖₊» φ * «expr‖ ‖₊» e) :=\n            nsmul_le_nsmul_of_le_right (φ.le_op_nnnorm e) _\n          \n      _ = «expr • » (fintype.card ι) («expr‖ ‖₊» φ) * M * «expr‖ ‖₊» e := by simp only [smul_mul_assoc, mul_right_comm]\n      \n#align basis.op_nnnorm_le basis.op_nnnorm_le\n\n",
 "nonempty_continuous_linear_equiv_of_finrank_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃L[ ] » -/\n/-- Two finite-dimensional normed spaces are continuously linearly equivalent if they have the same\n(finite) dimension. -/\ntheorem finite_dimensional.nonempty_continuous_linear_equiv_of_finrank_eq [finite_dimensional 𝕜 E]\n    [finite_dimensional 𝕜 F] (cond : finrank 𝕜 E = finrank 𝕜 F) : nonempty («expr ≃L[ ] » E 𝕜 F) :=\n  (nonempty_linear_equiv_of_finrank_eq cond).map linear_equiv.to_continuous_linear_equiv\n#align\n  finite_dimensional.nonempty_continuous_linear_equiv_of_finrank_eq finite_dimensional.nonempty_continuous_linear_equiv_of_finrank_eq\n\n",
 "nonempty_continuous_linear_equiv_iff_finrank_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃L[ ] » -/\n/-- Two finite-dimensional normed spaces are continuously linearly equivalent if and only if they\nhave the same (finite) dimension. -/\ntheorem finite_dimensional.nonempty_continuous_linear_equiv_iff_finrank_eq [finite_dimensional 𝕜 E]\n    [finite_dimensional 𝕜 F] : nonempty («expr ≃L[ ] » E 𝕜 F) ↔ finrank 𝕜 E = finrank 𝕜 F :=\n  ⟨fun ⟨h⟩ => h.to_linear_equiv.finrank_eq, fun h =>\n    finite_dimensional.nonempty_continuous_linear_equiv_of_finrank_eq h⟩\n#align\n  finite_dimensional.nonempty_continuous_linear_equiv_iff_finrank_eq finite_dimensional.nonempty_continuous_linear_equiv_iff_finrank_eq\n\n",
 "lipschitz_extension_constant_pos":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem lipschitz_extension_constant_pos (E' : Type _) [normed_add_comm_group E'] [normed_space (exprℝ) E']\n    [finite_dimensional (exprℝ) E'] : 0 < lipschitz_extension_constant E' :=\n  by\n  rw [lipschitz_extension_constant]\n  exact zero_lt_one.trans_le (le_max_right _ _)\n#align lipschitz_extension_constant_pos lipschitz_extension_constant_pos\n\n",
 "is_open_set_of_nat_le_rank":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\ntheorem is_open_set_of_nat_le_rank (n : ℕ) :\n    is_open { f : «expr →L[ ] » E 𝕜 F | ↑n ≤ rank (f : «expr →ₗ[ ] » E 𝕜 F) } :=\n  by\n  simp only [le_rank_iff_exists_linear_independent_finset, set_of_exists, ← exists_prop]\n  refine' is_open_bUnion fun t ht => _\n  have : continuous fun f : «expr →L[ ] » E 𝕜 F => fun x : (t : set E) => f x :=\n    continuous_pi fun x => (continuous_linear_map.apply 𝕜 F (x : E)).continuous\n  exact is_open_set_of_linear_independent.preimage this\n#align is_open_set_of_nat_le_rank is_open_set_of_nat_le_rank\n\n",
 "is_open_set_of_linear_independent":
 "theorem is_open_set_of_linear_independent {ι : Type _} [Finite ι] : is_open { f : ι → E | linear_independent 𝕜 f } :=\n  is_open_iff_mem_nhds.2 fun f => linear_independent.eventually\n#align is_open_set_of_linear_independent is_open_set_of_linear_independent\n\n",
 "is_closed_map_smul_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n-- `smul` is a closed map in the first argument.\ntheorem is_closed_map_smul_left (c : E) : is_closed_map fun x : 𝕜 => «expr • » x c :=\n  by\n  by_cases hc : c = 0\n  · simp_rw [hc, smul_zero]\n    exact is_closed_map_const\n  · exact (closed_embedding_smul_left hc).is_closed_map\n#align is_closed_map_smul_left is_closed_map_smul_left\n\n",
 "finite_dimensional_of_is_compact_closed_ball₀":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- **Riesz's theorem**: if a closed ball with center zero of positive radius is compact in a vector\nspace, then the space is finite-dimensional. -/\ntheorem finite_dimensional_of_is_compact_closed_ball₀ {r : exprℝ} (rpos : 0 < r)\n    (h : is_compact (metric.closed_ball (0 : E) r)) : finite_dimensional 𝕜 E :=\n  by\n  by_contra hfin\n  obtain ⟨R, f, Rgt, fle, lef⟩ :\n    ∃ (R : exprℝ)(f : ℕ → E), 1 < R ∧ (∀ n, «expr‖ ‖» (f n) ≤ R) ∧ ∀ m n, m ≠ n → 1 ≤ «expr‖ ‖» (f m - f n) :=\n    exists_seq_norm_le_one_le_norm_sub hfin\n  have rRpos : 0 < r / R := div_pos rpos (zero_lt_one.trans Rgt)\n  obtain ⟨c, hc⟩ : ∃ c : 𝕜, 0 < «expr‖ ‖» c ∧ «expr‖ ‖» c < r / R := normed_field.exists_norm_lt _ rRpos\n  let g := fun n : ℕ => «expr • » c (f n)\n  have A : ∀ n, g n ∈ metric.closed_ball (0 : E) r := by\n    intro n\n    simp only [norm_smul, dist_zero_right, metric.mem_closed_ball]\n    calc\n      «expr‖ ‖» c * «expr‖ ‖» (f n) ≤ r / R * R := mul_le_mul hc.2.le (fle n) (norm_nonneg _) rRpos.le\n      _ = r := by field_simp [(zero_lt_one.trans Rgt).ne']\n      \n  obtain ⟨x, hx, φ, φmono, φlim⟩ :\n    ∃ (x : E)(H : x ∈ metric.closed_ball (0 : E) r)(φ : ℕ → ℕ), strict_mono φ ∧ tendsto (g ∘ φ) at_top ((nhds) x) :=\n    h.tendsto_subseq A\n  have B : cauchy_seq (g ∘ φ) := φlim.cauchy_seq\n  obtain ⟨N, hN⟩ : ∃ N : ℕ, ∀ n : ℕ, N ≤ n → dist ((g ∘ φ) n) ((g ∘ φ) N) < «expr‖ ‖» c :=\n    metric.cauchy_seq_iff'.1 B («expr‖ ‖» c) hc.1\n  apply lt_irrefl («expr‖ ‖» c)\n  calc\n    «expr‖ ‖» c ≤ dist (g (φ (N + 1))) (g (φ N)) :=\n      by\n      conv_lhs => rw [← mul_one («expr‖ ‖» c)]\n      simp only [g, dist_eq_norm, ← smul_sub, norm_smul, -mul_one]\n      apply mul_le_mul_of_nonneg_left (lef _ _ (ne_of_gt _)) (norm_nonneg _)\n      exact φmono (nat.lt_succ_self N)\n    _ < «expr‖ ‖» c := hN (N + 1) (nat.le_succ N)\n    \n#align finite_dimensional_of_is_compact_closed_ball₀ finite_dimensional_of_is_compact_closed_ball₀\n\n",
 "finite_dimensional_of_is_compact_closed_ball":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- **Riesz's theorem**: if a closed ball of positive radius is compact in a vector space, then the\nspace is finite-dimensional. -/\ntheorem finite_dimensional_of_is_compact_closed_ball {r : exprℝ} (rpos : 0 < r) {c : E}\n    (h : is_compact (metric.closed_ball c r)) : finite_dimensional 𝕜 E :=\n  by\n  apply finite_dimensional_of_is_compact_closed_ball₀ 𝕜 rpos\n  have : continuous fun x => -c + x := continuous_const.add continuous_id\n  simpa using h.image this\n#align finite_dimensional_of_is_compact_closed_ball finite_dimensional_of_is_compact_closed_ball\n\n",
 "extend_finite_dimension":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/-- Any `K`-Lipschitz map from a subset `s` of a metric space `α` to a finite-dimensional real\nvector space `E'` can be extended to a Lipschitz map on the whole space `α`, with a slightly worse\nconstant `lipschitz_extension_constant E' * K`. -/\ntheorem lipschitz_on_with.extend_finite_dimension {α : Type _} [pseudo_metric_space α] {E' : Type _}\n    [normed_add_comm_group E'] [normed_space (exprℝ) E'] [finite_dimensional (exprℝ) E'] {s : set α} {f : α → E'}\n    {K : nnreal} (hf : lipschitz_on_with K f s) :\n    ∃ g : α → E', lipschitz_with (lipschitz_extension_constant E' * K) g ∧ EqOn f g s :=\n  by\n  /- This result is already known for spaces `ι → ℝ`. We use a continuous linear equiv between\n    `E'` and such a space to transfer the result to `E'`. -/\n  let ι : Type _ := basis.of_vector_space_index (exprℝ) E'\n  let A := (basis.of_vector_space (exprℝ) E').equiv_fun.to_continuous_linear_equiv\n  have LA : lipschitz_with («expr‖ ‖₊» A.to_continuous_linear_map) A := by apply A.lipschitz\n  have L : lipschitz_on_with («expr‖ ‖₊» A.to_continuous_linear_map * K) (A ∘ f) s := LA.comp_lipschitz_on_with hf\n  obtain ⟨g, hg, gs⟩ :\n    ∃ g : α → ι → exprℝ, lipschitz_with («expr‖ ‖₊» A.to_continuous_linear_map * K) g ∧ eq_on (A ∘ f) g s := L.extend_pi\n  refine' ⟨A.symm ∘ g, _, _⟩\n  · have LAsymm : lipschitz_with («expr‖ ‖₊» A.symm.to_continuous_linear_map) A.symm := by apply A.symm.lipschitz\n    apply (LAsymm.comp hg).weaken\n    rw [lipschitz_extension_constant, ← mul_assoc]\n    refine' mul_le_mul' (le_max_left _ _) le_rfl\n  · intro x hx\n    have : A (f x) = g x := gs hx\n    simp only [(· ∘ ·), ← this, A.symm_apply_apply]\n#align lipschitz_on_with.extend_finite_dimension lipschitz_on_with.extend_finite_dimension\n\n",
 "exists_seq_norm_le_one_le_norm_sub'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/-- In an infinite-dimensional normed space, there exists a sequence of points which are all\nbounded by `R` and at distance at least `1`. For a version not assuming `c` and `R`, see\n`exists_seq_norm_le_one_le_norm_sub`. -/\ntheorem exists_seq_norm_le_one_le_norm_sub' {c : 𝕜} (hc : 1 < «expr‖ ‖» c) {R : exprℝ} (hR : «expr‖ ‖» c < R)\n    (h : ¬finite_dimensional 𝕜 E) :\n    ∃ f : ℕ → E, (∀ n, «expr‖ ‖» (f n) ≤ R) ∧ ∀ m n, m ≠ n → 1 ≤ «expr‖ ‖» (f m - f n) :=\n  by\n  have : is_symm E fun x y : E => 1 ≤ «expr‖ ‖» (x - y) :=\n    by\n    constructor\n    intro x y hxy\n    rw [← norm_neg]\n    simpa\n  apply exists_seq_of_forall_finset_exists' (fun x : E => «expr‖ ‖» x ≤ R) fun (x : E) (y : E) => 1 ≤ «expr‖ ‖» (x - y)\n  intro s hs\n  exact exists_norm_le_le_norm_sub_of_finset hc hR h s\n#align exists_seq_norm_le_one_le_norm_sub' exists_seq_norm_le_one_le_norm_sub'\n\n",
 "exists_seq_norm_le_one_le_norm_sub":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem exists_seq_norm_le_one_le_norm_sub (h : ¬finite_dimensional 𝕜 E) :\n    ∃ (R : exprℝ)(f : ℕ → E), 1 < R ∧ (∀ n, «expr‖ ‖» (f n) ≤ R) ∧ ∀ m n, m ≠ n → 1 ≤ «expr‖ ‖» (f m - f n) :=\n  by\n  obtain ⟨c, hc⟩ : ∃ c : 𝕜, 1 < «expr‖ ‖» c := normed_field.exists_one_lt_norm 𝕜\n  have A : «expr‖ ‖» c < «expr‖ ‖» c + 1 := by linarith\n  rcases exists_seq_norm_le_one_le_norm_sub' hc A h with ⟨f, hf⟩\n  exact ⟨«expr‖ ‖» c + 1, f, hc.trans A, hf.1, hf.2⟩\n#align exists_seq_norm_le_one_le_norm_sub exists_seq_norm_le_one_le_norm_sub\n\n",
 "exists_right_inverse_of_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\ntheorem continuous_linear_map.exists_right_inverse_of_surjective [finite_dimensional 𝕜 F] (f : «expr →L[ ] » E 𝕜 F)\n    (hf : linear_map.range f = «expr⊤») : ∃ g : «expr →L[ ] » F 𝕜 E, f.comp g = continuous_linear_map.id 𝕜 F :=\n  let ⟨g, hg⟩ := (f : «expr →ₗ[ ] » E 𝕜 F).exists_right_inverse_of_surjective hf\n  ⟨g.to_continuous_linear_map, continuous_linear_map.ext <| linear_map.ext_iff.1 hg⟩\n#align continuous_linear_map.exists_right_inverse_of_surjective continuous_linear_map.exists_right_inverse_of_surjective\n\n",
 "exists_op_norm_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/-- A weaker version of `basis.op_norm_le` that abstracts away the value of `C`. -/\ntheorem basis.exists_op_norm_le {ι : Type _} [Finite ι] (v : basis ι 𝕜 E) :\n    ∃ C > (0 : exprℝ),\n      ∀ {u : «expr →L[ ] » E 𝕜 F} {M : exprℝ}, 0 ≤ M → (∀ i, «expr‖ ‖» (u (v i)) ≤ M) → «expr‖ ‖» u ≤ C * M :=\n  let ⟨C, hC, h⟩ := v.exists_op_nnnorm_le\n  ⟨C, hC, fun u => subtype.forall'.mpr h⟩\n#align basis.exists_op_norm_le basis.exists_op_norm_le\n\n",
 "exists_op_nnnorm_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/-- A weaker version of `basis.op_nnnorm_le` that abstracts away the value of `C`. -/\ntheorem basis.exists_op_nnnorm_le {ι : Type _} [Finite ι] (v : basis ι 𝕜 E) :\n    ∃ C > (0 : nnreal),\n      ∀ {u : «expr →L[ ] » E 𝕜 F} (M : nnreal), (∀ i, «expr‖ ‖₊» (u (v i)) ≤ M) → «expr‖ ‖₊» u ≤ C * M :=\n  by\n  cases nonempty_fintype ι <;>\n    exact\n      ⟨max («expr • » (fintype.card ι) («expr‖ ‖₊» v.equiv_funL.to_continuous_linear_map)) 1,\n        zero_lt_one.trans_le (le_max_right _ _), fun u M hu =>\n        (v.op_nnnorm_le M hu).trans <| mul_le_mul_of_nonneg_right (le_max_left _ _) (zero_le M)⟩\n#align basis.exists_op_nnnorm_le basis.exists_op_nnnorm_le\n\n",
 "exists_norm_le_le_norm_sub_of_finset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/-- In an infinite dimensional space, given a finite number of points, one may find a point\nwith norm at most `R` which is at distance at least `1` of all these points. -/\ntheorem exists_norm_le_le_norm_sub_of_finset {c : 𝕜} (hc : 1 < «expr‖ ‖» c) {R : exprℝ} (hR : «expr‖ ‖» c < R)\n    (h : ¬finite_dimensional 𝕜 E) (s : Finset E) : ∃ x : E, «expr‖ ‖» x ≤ R ∧ ∀ y ∈ s, 1 ≤ «expr‖ ‖» (y - x) :=\n  by\n  let F := submodule.span 𝕜 (s : set E)\n  haveI : finite_dimensional 𝕜 F :=\n    module.finite_def.2 ((submodule.fg_top _).2 (submodule.fg_def.2 ⟨s, finset.finite_to_set _, rfl⟩))\n  have Fclosed : is_closed (F : set E) := submodule.closed_of_finite_dimensional _\n  have : ∃ x, x ∉ F := by\n    contrapose! h\n    have : («expr⊤» : submodule 𝕜 E) = F := by\n      ext x\n      simp [h]\n    have : finite_dimensional 𝕜 («expr⊤» : submodule 𝕜 E) := by rwa [this]\n    refine' module.finite_def.2 ((submodule.fg_top _).1 (module.finite_def.1 this))\n  obtain ⟨x, xR, hx⟩ : ∃ x : E, «expr‖ ‖» x ≤ R ∧ ∀ y : E, y ∈ F → 1 ≤ «expr‖ ‖» (x - y) :=\n    riesz_lemma_of_norm_lt hc hR Fclosed this\n  have hx' : ∀ y : E, y ∈ F → 1 ≤ «expr‖ ‖» (y - x) := by\n    intro y hy\n    rw [← norm_neg]\n    simpa using hx y hy\n  exact ⟨x, xR, fun y hy => hx' _ (submodule.subset_span hy)⟩\n#align exists_norm_le_le_norm_sub_of_finset exists_norm_le_le_norm_sub_of_finset\n\n",
 "exists_mem_frontier_inf_dist_compl_eq_dist":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/-- If `K` is a compact set in a nontrivial real normed space and `x ∈ K`, then there exists a point\n`y` of the boundary of `K` at distance `metric.inf_dist x Kᶜ` from `x`. See also\n`exists_mem_frontier_inf_dist_compl_eq_dist`. -/\ntheorem is_compact.exists_mem_frontier_inf_dist_compl_eq_dist {E : Type _} [normed_add_comm_group E]\n    [normed_space (exprℝ) E] [nontrivial E] {x : E} {K : set E} (hK : is_compact K) (hx : x ∈ K) :\n    ∃ y ∈ frontier K, metric.inf_dist x («expr ᶜ» K) = dist x y :=\n  by\n  obtain hx' | hx' : x ∈ interior K ∪ frontier K :=\n    by\n    rw [← closure_eq_interior_union_frontier]\n    exact subset_closure hx\n  · rw [mem_interior_iff_mem_nhds, metric.nhds_basis_closed_ball.mem_iff] at hx'\n    rcases hx' with ⟨r, hr₀, hrK⟩\n    have : finite_dimensional (exprℝ) E :=\n      finite_dimensional_of_is_compact_closed_ball (exprℝ) hr₀\n        (is_compact_of_is_closed_subset hK metric.is_closed_ball hrK)\n    exact exists_mem_frontier_inf_dist_compl_eq_dist hx hK.ne_univ\n  · refine' ⟨x, hx', _⟩\n    rw [frontier_eq_closure_inter_closure] at hx'\n    rw [metric.inf_dist_zero_of_mem_closure hx'.2, dist_self]\n#align is_compact.exists_mem_frontier_inf_dist_compl_eq_dist is_compact.exists_mem_frontier_inf_dist_compl_eq_dist\n\n",
 "exists_antilipschitz_with":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem linear_map.exists_antilipschitz_with [finite_dimensional 𝕜 E] (f : «expr →ₗ[ ] » E 𝕜 F) (hf : f.ker = «expr⊥») :\n    ∃ K > 0, antilipschitz_with K f := by\n  cases subsingleton_or_nontrivial E\n  · exact ⟨1, zero_lt_one, antilipschitz_with.of_subsingleton⟩\n  · rw [linear_map.ker_eq_bot] at hf\n    let e : «expr ≃L[ ] » E 𝕜 f.range := (linear_equiv.of_injective f hf).to_continuous_linear_equiv\n    exact ⟨_, e.nnnorm_symm_pos, e.antilipschitz⟩\n#align linear_map.exists_antilipschitz_with linear_map.exists_antilipschitz_with\n\n",
 "eventually":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\nprotected theorem linear_independent.eventually {ι} [Finite ι] {f : ι → E} (hf : linear_independent 𝕜 f) :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" ((nhds) f)\n      (linear_independent 𝕜 g) :=\n  by\n  cases nonempty_fintype ι\n  simp only [fintype.linear_independent_iff'] at hf⊢\n  rcases linear_map.exists_antilipschitz_with _ hf with ⟨K, K0, hK⟩\n  have :\n    tendsto\n      (fun g : ι → E =>\n        finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n          («expr‖ ‖» (g i - f i)))\n      ((nhds) f)\n      (nhds <|\n        finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n          («expr‖ ‖» (f i - f i))) :=\n    tendsto_finset_sum _ fun i hi => tendsto.norm <| ((continuous_apply i).tendsto _).sub tendsto_const_nhds\n  simp only [sub_self, norm_zero, finset.sum_const_zero] at this\n  refine' (this.eventually (gt_mem_nhds <| inv_pos.2 K0)).mono fun g hg => _\n  replace hg :\n    finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n        («expr‖ ‖₊» (g i - f i)) <\n      K⁻¹\n  · rw [← nnreal.coe_lt_coe]\n    push_cast\n    exact hg\n  rw [linear_map.ker_eq_bot]\n  refine' (hK.add_sub_lipschitz_with (lipschitz_with.of_dist_le_mul fun v u => _) hg).injective\n  simp only [dist_eq_norm, linear_map.lsum_apply, pi.sub_apply, linear_map.sum_apply, linear_map.comp_apply,\n    linear_map.proj_apply, linear_map.smul_right_apply, linear_map.id_apply, ← finset.sum_sub_distrib, ← smul_sub, ←\n    sub_smul, nnreal.coe_sum, coe_nnnorm, finset.sum_mul]\n  refine' norm_sum_le_of_le _ fun i _ => _\n  rw [norm_smul, mul_comm]\n  exact mul_le_mul_of_nonneg_left (norm_le_pi_norm (v - u) i) (norm_nonneg _)\n#align linear_independent.eventually linear_independent.eventually\n\n",
 "eq_one_or_finite_dimensional":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- If a function has compact multiplicative support, then either the function is trivial or the\nspace if finite-dimensional. -/\n@[to_additive\n      \"If a function has compact support, then either the function is trivial or the\\nspace if finite-dimensional.\"]\ntheorem has_compact_mul_support.eq_one_or_finite_dimensional {X : Type _} [topological_space X] [One X] [t2_space X]\n    {f : E → X} (hf : has_compact_mul_support f) (h'f : continuous f) : f = 1 ∨ finite_dimensional 𝕜 E :=\n  by\n  by_cases h : ∀ x, f x = 1\n  · apply or.inl\n    ext x\n    exact h x\n  apply or.inr\n  push_neg  at h\n  obtain ⟨x, hx⟩ : ∃ x, f x ≠ 1\n  exact h\n  have : function.mul_support f ∈ (nhds) x := h'f.is_open_mul_support.mem_nhds hx\n  obtain ⟨r, rpos, hr⟩ : ∃ (r : exprℝ)(hi : 0 < r), metric.closed_ball x r ⊆ function.mul_support f\n  exact metric.nhds_basis_closed_ball.mem_iff.1 this\n  have : is_compact (metric.closed_ball x r) :=\n    is_compact_of_is_closed_subset hf metric.is_closed_ball (hr.trans (subset_mul_tsupport _))\n  exact finite_dimensional_of_is_compact_closed_ball 𝕜 rpos this\n#align has_compact_mul_support.eq_one_or_finite_dimensional has_compact_mul_support.eq_one_or_finite_dimensional\n\n",
 "continuous_on_clm_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/-- A family of continuous linear maps is continuous on `s` if all its applications are. -/\ntheorem continuous_on_clm_apply {X : Type _} [topological_space X] [finite_dimensional 𝕜 E]\n    {f : X → «expr →L[ ] » E 𝕜 F} {s : set X} : continuous_on f s ↔ ∀ y, continuous_on (fun x => f x y) s :=\n  by\n  refine' ⟨fun h y => (continuous_linear_map.apply 𝕜 F y).continuous.comp_continuous_on h, fun h => _⟩\n  let d := finrank 𝕜 E\n  have hd : d = finrank 𝕜 (fin d → 𝕜) := (finrank_fin_fun 𝕜).symm\n  let e₁ : «expr ≃L[ ] » E 𝕜 (fin d → 𝕜) := continuous_linear_equiv.of_finrank_eq hd\n  let e₂ : «expr ≃L[ ] » («expr →L[ ] » E 𝕜 F) 𝕜 (fin d → F) :=\n    (e₁.arrow_congr (1 : «expr ≃L[ ] » F 𝕜 F)).trans (continuous_linear_equiv.pi_ring (fin d))\n  rw [← function.comp.left_id f, ← e₂.symm_comp_self]\n  exact e₂.symm.continuous.comp_continuous_on (continuous_on_pi.mpr fun i => h _)\n#align continuous_on_clm_apply continuous_on_clm_apply\n\n",
 "continuous_of_finite_dimensional":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ᵃ[ ] » -/\ntheorem affine_equiv.continuous_of_finite_dimensional (f : «expr ≃ᵃ[ ] » PE 𝕜 PF) : continuous f :=\n  f.to_affine_map.continuous_of_finite_dimensional\n#align affine_equiv.continuous_of_finite_dimensional affine_equiv.continuous_of_finite_dimensional\n\n",
 "continuous_det":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\ntheorem continuous_linear_map.continuous_det : continuous fun f : «expr →L[ ] » E 𝕜 E => f.det :=\n  by\n  change continuous fun f : «expr →L[ ] » E 𝕜 E => (f : «expr →ₗ[ ] » E 𝕜 E).det\n  by_cases h : ∃ s : Finset E, nonempty (basis («expr↥ » s) 𝕜 E)\n  · rcases h with ⟨s, ⟨b⟩⟩\n    haveI : finite_dimensional 𝕜 E := finite_dimensional.of_fintype_basis b\n    simp_rw [linear_map.det_eq_det_to_matrix_of_finset b]\n    refine' continuous.matrix_det _\n    exact\n      ((linear_map.to_matrix b b).to_linear_map.comp (continuous_linear_map.coe_lm 𝕜)).continuous_of_finite_dimensional\n  · unfold linear_map.det\n    simpa only [h, MonoidHom.one_apply, dif_neg, not_false_iff] using continuous_const\n#align continuous_linear_map.continuous_det continuous_linear_map.continuous_det\n\n",
 "continuous_clm_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\ntheorem continuous_clm_apply {X : Type _} [topological_space X] [finite_dimensional 𝕜 E] {f : X → «expr →L[ ] » E 𝕜 F} :\n    continuous f ↔ ∀ y, continuous fun x => f x y := by\n  simp_rw [continuous_iff_continuous_on_univ, continuous_on_clm_apply]\n#align continuous_clm_apply continuous_clm_apply\n\n",
 "constrL_basis":
 "@[simp]\ntheorem basis.constrL_basis (v : basis ι 𝕜 E) (f : ι → F) (i : ι) : (v.constrL f) (v i) = f i :=\n  v.constr_basis 𝕜 _ _\n#align basis.constrL_basis basis.constrL_basis\n\n",
 "constrL_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem basis.constrL_apply (v : basis ι 𝕜 E) (f : ι → F) (e : E) :\n    (v.constrL f) e =\n      finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n        («expr • » (v.equiv_fun e i) (f i)) :=\n  v.constr_apply_fintype 𝕜 _ _\n#align basis.constrL_apply basis.constrL_apply\n\n",
 "complete_of_finite_dimensional":
 "/-- A finite-dimensional subspace is complete. -/\ntheorem submodule.complete_of_finite_dimensional (s : submodule 𝕜 E) [finite_dimensional 𝕜 s] :\n    is_complete (s : set E) :=\n  complete_space_coe_iff_is_complete.1 (finite_dimensional.complete 𝕜 s)\n#align submodule.complete_of_finite_dimensional submodule.complete_of_finite_dimensional\n\n",
 "complete":
 "theorem finite_dimensional.complete [finite_dimensional 𝕜 E] : complete_space E :=\n  by\n  set e := continuous_linear_equiv.of_finrank_eq (@finrank_fin_fun 𝕜 _ (finrank 𝕜 E)).symm\n  have : uniform_embedding e.to_linear_equiv.to_equiv.symm := e.symm.uniform_embedding\n  exact (complete_space_congr this).1 (by infer_instance)\n#align finite_dimensional.complete finite_dimensional.complete\n\n",
 "coe_to_linear_isometry_equiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗᵢ[ ] » -/\n/-\nCopyright (c) 2019 Sébastien Gouëzel. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Sébastien Gouëzel\n-/\n@[simp]\ntheorem coe_to_linear_isometry_equiv (li : «expr →ₗᵢ[ ] » E₁ R₁ F) (h : finrank R₁ E₁ = finrank R₁ F) :\n    (li.to_linear_isometry_equiv h : E₁ → F) = li :=\n  rfl\n#align coe_to_linear_isometry_equiv coe_to_linear_isometry_equiv\n\n",
 "coe_to_homeomorph_of_finite_dimensional_symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ᵃ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n@[simp]\ntheorem affine_equiv.coe_to_homeomorph_of_finite_dimensional_symm (f : «expr ≃ᵃ[ ] » PE 𝕜 PF) :\n    «expr⇑ » f.to_homeomorph_of_finite_dimensional.symm = f.symm :=\n  rfl\n#align\n  affine_equiv.coe_to_homeomorph_of_finite_dimensional_symm affine_equiv.coe_to_homeomorph_of_finite_dimensional_symm\n\n",
 "coe_to_homeomorph_of_finite_dimensional":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ᵃ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n@[simp]\ntheorem affine_equiv.coe_to_homeomorph_of_finite_dimensional (f : «expr ≃ᵃ[ ] » PE 𝕜 PF) :\n    «expr⇑ » f.to_homeomorph_of_finite_dimensional = f :=\n  rfl\n#align affine_equiv.coe_to_homeomorph_of_finite_dimensional affine_equiv.coe_to_homeomorph_of_finite_dimensional\n\n",
 "coe_to_affine_isometry_equiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ᵃⁱ[ ] » -/\n@[simp]\ntheorem coe_to_affine_isometry_equiv [inhabited P₁] (li : «expr →ᵃⁱ[ ] » P₁ 𝕜 P₂) (h : finrank 𝕜 V₁ = finrank 𝕜 V₂) :\n    (li.to_affine_isometry_equiv h : P₁ → P₂) = li :=\n  rfl\n#align coe_to_affine_isometry_equiv coe_to_affine_isometry_equiv\n\n",
 "coe_constrL":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n@[simp, norm_cast]\ntheorem basis.coe_constrL (v : basis ι 𝕜 E) (f : ι → F) : (v.constrL f : «expr →ₗ[ ] » E 𝕜 F) = v.constr 𝕜 f :=\n  rfl\n#align basis.coe_constrL basis.coe_constrL\n\n",
 "closed_of_finite_dimensional":
 "theorem affine_subspace.closed_of_finite_dimensional {P : Type _} [metric_space P] [normed_add_torsor E P]\n    (s : affine_subspace 𝕜 P) [finite_dimensional 𝕜 s.direction] : is_closed (s : set P) :=\n  s.is_closed_direction_iff.mp s.direction.closed_of_finite_dimensional\n#align affine_subspace.closed_of_finite_dimensional affine_subspace.closed_of_finite_dimensional\n\n",
 "closed_embedding_smul_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem closed_embedding_smul_left {c : E} (hc : c ≠ 0) : closed_embedding fun x : 𝕜 => «expr • » x c :=\n  linear_equiv.closed_embedding_of_injective (linear_map.ker_to_span_singleton 𝕜 E hc)\n#align closed_embedding_smul_left closed_embedding_smul_left\n\n",
 "closed_embedding_of_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n/-- An injective linear map with finite-dimensional domain is a closed embedding. -/\ntheorem linear_equiv.closed_embedding_of_injective {f : «expr →ₗ[ ] » E 𝕜 F} (hf : f.ker = «expr⊥»)\n    [finite_dimensional 𝕜 E] : closed_embedding («expr⇑ » f) :=\n  let g := linear_equiv.of_injective f (linear_map.ker_eq_bot.mp hf)\n  { embedding_subtype_coe.comp g.to_continuous_linear_equiv.to_homeomorph.embedding with\n    closed_range := by\n      haveI := f.finite_dimensional_range\n      simpa [f.range_coe] using f.range.closed_of_finite_dimensional }\n#align linear_equiv.closed_embedding_of_injective linear_equiv.closed_embedding_of_injective\n\n"}