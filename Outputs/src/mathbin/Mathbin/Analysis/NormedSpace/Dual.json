{"topDualPairing_apply":
 "#print topDualPairing_apply /-\n@[simp]\ntheorem topDualPairing_apply {v : dual ğ•œ E} {x : E} : dual_pairing ğ•œ E v x = v x :=\n  rfl\n#align dual_pairing_apply topDualPairing_apply\n-/\n\n",
 "smul_mem_polar":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/-- If `x'` is a dual element such that the norms `â€–x' zâ€–` are bounded for `z âˆˆ s`, then a\nsmall scalar multiple of `x'` is in `polar ğ•œ s`. -/\ntheorem smul_mem_polar {s : Set E} {x' : dual ğ•œ E} {c : ğ•œ} (hc : âˆ€ z, z âˆˆ s â†’ Â«exprâ€– â€–Â» (x' z) â‰¤ Â«exprâ€– â€–Â» c) :\n    Â«expr â€¢ Â» câ»Â¹ x' âˆˆ polar ğ•œ s := by\n  by_cases c_zero : c = 0\n  Â· simp only [c_zero, inv_zero, zero_smul]\n    exact (dual_pairing ğ•œ E).flip.zero_mem_polar _\n  have eq : âˆ€ z, Â«exprâ€– â€–Â» (Â«expr â€¢ Â» câ»Â¹ (x' z)) = Â«exprâ€– â€–Â» câ»Â¹ * Â«exprâ€– â€–Â» (x' z) := fun z => norm_smul câ»Â¹ _\n  have le : âˆ€ z, z âˆˆ s â†’ Â«exprâ€– â€–Â» (Â«expr â€¢ Â» câ»Â¹ (x' z)) â‰¤ Â«exprâ€– â€–Â» câ»Â¹ * Â«exprâ€– â€–Â» c :=\n    by\n    intro z hzs\n    rw [Eq z]\n    apply mul_le_mul (le_of_eq rfl) (hc z hzs) (norm_nonneg _) (norm_nonneg _)\n  have cancel : Â«exprâ€– â€–Â» câ»Â¹ * Â«exprâ€– â€–Â» c = 1 := by\n    simp only [c_zero, norm_eq_zero, ne.def, not_false_iff, inv_mul_cancel, norm_inv]\n  rwa [cancel] at le\n#align smul_mem_polar smul_mem_polar\n\n",
 "polar_univ":
 "@[simp]\ntheorem polar_univ : polar ğ•œ (univ : Set E) = {(0 : dual ğ•œ E)} :=\n  (dual_pairing ğ•œ E).flip.polar_univ (LinearMap.flip_separatingRight.mpr (dual_pairing_separating_left ğ•œ E))\n#align polar_univ polar_univ\n\n",
 "polar_closure":
 "@[simp]\ntheorem polar_closure (s : Set E) : polar ğ•œ (closure s) = polar ğ•œ s :=\n  ((dual_pairing ğ•œ E).flip.polar_antitone subset_closure).antisymm <|\n    (dual_pairing ğ•œ E).flip.polar_gc.l_le <|\n      closure_minimal ((dual_pairing ğ•œ E).flip.polar_gc.le_u_l s) <| by\n        simpa [LinearMap.flip_flip] using (is_closed_polar _ _).preimage (inclusion_in_double_dual ğ•œ E).continuous\n#align polar_closure polar_closure\n\n",
 "polar_closed_ball":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/-- The `polar` of closed ball in a normed space `E` is the closed ball of the dual with\ninverse radius. -/\ntheorem polar_closed_ball {ğ•œ E : Type _} [IsROrC ğ•œ] [NormedAddCommGroup E] [NormedSpace ğ•œ E] {r : exprâ„} (hr : 0 < r) :\n    polar ğ•œ (closedBall (0 : E) r) = closedBall (0 : dual ğ•œ E) râ»Â¹ :=\n  by\n  refine' subset.antisymm _ (closed_ball_inv_subset_polar_closed_ball _)\n  intro x' h\n  simp only [mem_closedBall_zero_iff]\n  refine' continuous_linear_map.op_norm_le_of_ball hr (inv_nonneg.mpr hr.le) fun z hz => _\n  simpa only [one_div] using linear_map.bound_of_ball_bound' hr 1 x'.to_linear_map h z\n#align polar_closed_ball polar_closed_ball\n\n",
 "polar_ball_subset_closed_ball_div":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\ntheorem polar_ball_subset_closed_ball_div {c : ğ•œ} (hc : 1 < Â«exprâ€– â€–Â» c) {r : exprâ„} (hr : 0 < r) :\n    polar ğ•œ (ball (0 : E) r) âŠ† closedBall (0 : dual ğ•œ E) (Â«exprâ€– â€–Â» c / r) :=\n  by\n  intro x' hx'\n  rw [mem_polar_iff] at hx'\n  simp only [polar, mem_set_of_eq, mem_closedBall_zero_iff, mem_ball_zero_iff] at *\n  have hcr : 0 < Â«exprâ€– â€–Â» c / r := div_pos (zero_lt_one.trans hc) hr\n  refine' continuous_linear_map.op_norm_le_of_shell hr hcr.le hc fun x hâ‚ hâ‚‚ => _\n  calc\n    Â«exprâ€– â€–Â» (x' x) â‰¤ 1 := hx' _ hâ‚‚\n    _ â‰¤ Â«exprâ€– â€–Â» c / r * Â«exprâ€– â€–Â» x := (inv_pos_le_iff_one_le_mul' hcr).1 (by rwa [inv_div])\n    \n#align polar_ball_subset_closed_ball_div polar_ball_subset_closed_ball_div\n\n",
 "norm_le_dual_bound":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/-- If one controls the norm of every `f x`, then one controls the norm of `x`.\n    Compare `continuous_linear_map.op_norm_le_bound`. -/\ntheorem norm_le_dual_bound (x : E) {M : exprâ„} (hMp : 0 â‰¤ M) (hM : âˆ€ f : dual ğ•œ E, Â«exprâ€– â€–Â» (f x) â‰¤ M * Â«exprâ€– â€–Â» f) :\n    Â«exprâ€– â€–Â» x â‰¤ M := by\n  classical\n    by_cases h : x = 0\n    Â· simp only [h, hMp, norm_zero]\n    Â· obtain âŸ¨f, hfâ‚, hfxâŸ© : âˆƒ f : Â«expr â†’L[ ] Â» E ğ•œ ğ•œ, Â«exprâ€– â€–Â» f = 1 âˆ§ f x = Â«exprâ€– â€–Â» x := exists_dual_vector ğ•œ x h\n      calc\n        Â«exprâ€– â€–Â» x = Â«exprâ€– â€–Â» (Â«exprâ€– â€–Â» x : ğ•œ) := is_R_or_C.norm_coe_norm.symm\n        _ = Â«exprâ€– â€–Â» (f x) := by rw [hfx]\n        _ â‰¤ M * Â«exprâ€– â€–Â» f := (hM f)\n        _ = M := by rw [hfâ‚, mul_one]\n        \n#align norm_le_dual_bound norm_le_dual_bound\n\n",
 "mem_polar_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\ntheorem mem_polar_iff {x' : dual ğ•œ E} (s : Set E) : x' âˆˆ polar ğ•œ s â†” âˆ€ z âˆˆ s, Â«exprâ€– â€–Â» (x' z) â‰¤ 1 :=\n  iff.rfl\n#align mem_polar_iff mem_polar_iff\n\n",
 "is_closed_polar":
 "theorem is_closed_polar (s : Set E) : IsClosed (polar ğ•œ s) :=\n  by\n  dsimp only [normed_space.polar]\n  simp only [LinearMap.polar_eq_interáµ¢, LinearMap.flip_apply]\n  refine' isClosed_binteráµ¢ fun z hz => _\n  exact is_closed_Iic.preimage (continuous_linear_map.apply ğ•œ ğ•œ z).continuous.norm\n#align is_closed_polar is_closed_polar\n\n",
 "inclusion_in_double_dual_norm_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\ntheorem inclusion_in_double_dual_norm_le : Â«exprâ€– â€–Â» (inclusion_in_double_dual ğ•œ E) â‰¤ 1 :=\n  by\n  rw [inclusion_in_double_dual_norm_eq]\n  exact continuous_linear_map.norm_id_le\n#align inclusion_in_double_dual_norm_le inclusion_in_double_dual_norm_le\n\n",
 "inclusion_in_double_dual_norm_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\ntheorem inclusion_in_double_dual_norm_eq :\n    Â«exprâ€– â€–Â» (inclusion_in_double_dual ğ•œ E) = Â«exprâ€– â€–Â» (ContinuousLinearMap.id ğ•œ (dual ğ•œ E)) :=\n  continuous_linear_map.op_norm_flip _\n#align inclusion_in_double_dual_norm_eq inclusion_in_double_dual_norm_eq\n\n",
 "eq_zero_of_forall_dual_eq_zero":
 "theorem eq_zero_of_forall_dual_eq_zero {x : E} (h : âˆ€ f : dual ğ•œ E, f x = (0 : ğ•œ)) : x = 0 :=\n  norm_le_zero_iff.mp (norm_le_dual_bound ğ•œ x le_rfl fun f => by simp [h f])\n#align eq_zero_of_forall_dual_eq_zero eq_zero_of_forall_dual_eq_zero\n\n",
 "eq_zero_iff_forall_dual_eq_zero":
 "theorem eq_zero_iff_forall_dual_eq_zero (x : E) : x = 0 â†” âˆ€ g : dual ğ•œ E, g x = 0 :=\n  âŸ¨fun hx => by simp [hx], fun h => eq_zero_of_forall_dual_eq_zero ğ•œ hâŸ©\n#align eq_zero_iff_forall_dual_eq_zero eq_zero_iff_forall_dual_eq_zero\n\n",
 "eq_iff_forall_dual_eq":
 "/-- See also `geometric_hahn_banach_point_point`. -/\ntheorem eq_iff_forall_dual_eq {x y : E} : x = y â†” âˆ€ g : dual ğ•œ E, g x = g y :=\n  by\n  rw [â† sub_eq_zero, eq_zero_iff_forall_dual_eq_zero ğ•œ (x - y)]\n  simp [sub_eq_zero]\n#align eq_iff_forall_dual_eq eq_iff_forall_dual_eq\n\n",
 "dual_pairing_separating_left":
 "theorem dual_pairing_separating_left : (dual_pairing ğ•œ E).separating_left :=\n  by\n  rw [LinearMap.separatingLeft_iff_ker_eq_bot, LinearMap.ker_eq_bot]\n  exact ContinuousLinearMap.coe_injective\n#align dual_pairing_separating_left dual_pairing_separating_left\n\n",
 "dual_def":
 "/-\nCopyright (c) 2020 Heather Macbeth. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Heather Macbeth\n-/\n@[simp]\ntheorem dual_def (x : E) (f : dual ğ•œ E) : inclusion_in_double_dual ğ•œ E x f = f x :=\n  rfl\n#align dual_def dual_def\n\n",
 "double_dual_bound":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\ntheorem double_dual_bound (x : E) : Â«exprâ€– â€–Â» ((inclusion_in_double_dual ğ•œ E) x) â‰¤ Â«exprâ€– â€–Â» x := by\n  simpa using continuous_linear_map.le_of_op_norm_le _ (inclusion_in_double_dual_norm_le ğ•œ E) x\n#align double_dual_bound double_dual_bound\n\n",
 "closed_ball_inv_subset_polar_closed_ball":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\ntheorem closed_ball_inv_subset_polar_closed_ball {r : exprâ„} :\n    closedBall (0 : dual ğ•œ E) râ»Â¹ âŠ† polar ğ•œ (closedBall (0 : E) r) := fun x' hx' x hx =>\n  calc\n    Â«exprâ€– â€–Â» (x' x) â‰¤ Â«exprâ€– â€–Â» x' * Â«exprâ€– â€–Â» x := x'.le_op_norm x\n    _ â‰¤ râ»Â¹ * r :=\n      (mul_le_mul (mem_closedBall_zero_iff.1 hx') (mem_closedBall_zero_iff.1 hx) (norm_nonneg _)\n        (dist_nonneg.trans hx'))\n    _ = r / r := (inv_mul_eq_div _ _)\n    _ â‰¤ 1 := div_self_le_one r\n    \n#align closed_ball_inv_subset_polar_closed_ball closed_ball_inv_subset_polar_closed_ball\n\n",
 "bounded_polar_of_mem_nhds_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- Given a neighborhood `s` of the origin in a normed space `E`, the dual norms\nof all elements of the polar `polar ğ•œ s` are bounded by a constant. -/\ntheorem bounded_polar_of_mem_nhds_zero {s : Set E} (s_nhd : s âˆˆ (nhds) (0 : E)) : Bounded (polar ğ•œ s) :=\n  by\n  obtain âŸ¨a, haâŸ© : âˆƒ a : ğ•œ, 1 < Â«exprâ€– â€–Â» a := NormedField.exists_one_lt_norm ğ•œ\n  obtain âŸ¨r, r_pos, r_ballâŸ© : âˆƒ (r : exprâ„)(hr : 0 < r), ball 0 r âŠ† s := Metric.mem_nhds_iff.1 s_nhd\n  exact\n    bounded_closed_ball.mono\n      (((dual_pairing ğ•œ E).flip.polar_antitone r_ball).trans <| polar_ball_subset_closed_ball_div ha r_pos)\n#align bounded_polar_of_mem_nhds_zero bounded_polar_of_mem_nhds_zero\n\n"}