{"topDualPairing_apply":
 "#print topDualPairing_apply /-\n@[simp]\ntheorem topDualPairing_apply {v : dual 𝕜 E} {x : E} : dual_pairing 𝕜 E v x = v x :=\n  rfl\n#align dual_pairing_apply topDualPairing_apply\n-/\n\n",
 "smul_mem_polar":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- If `x'` is a dual element such that the norms `‖x' z‖` are bounded for `z ∈ s`, then a\nsmall scalar multiple of `x'` is in `polar 𝕜 s`. -/\ntheorem smul_mem_polar {s : Set E} {x' : dual 𝕜 E} {c : 𝕜} (hc : ∀ z, z ∈ s → «expr‖ ‖» (x' z) ≤ «expr‖ ‖» c) :\n    «expr • » c⁻¹ x' ∈ polar 𝕜 s := by\n  by_cases c_zero : c = 0\n  · simp only [c_zero, inv_zero, zero_smul]\n    exact (dual_pairing 𝕜 E).flip.zero_mem_polar _\n  have eq : ∀ z, «expr‖ ‖» («expr • » c⁻¹ (x' z)) = «expr‖ ‖» c⁻¹ * «expr‖ ‖» (x' z) := fun z => norm_smul c⁻¹ _\n  have le : ∀ z, z ∈ s → «expr‖ ‖» («expr • » c⁻¹ (x' z)) ≤ «expr‖ ‖» c⁻¹ * «expr‖ ‖» c :=\n    by\n    intro z hzs\n    rw [Eq z]\n    apply mul_le_mul (le_of_eq rfl) (hc z hzs) (norm_nonneg _) (norm_nonneg _)\n  have cancel : «expr‖ ‖» c⁻¹ * «expr‖ ‖» c = 1 := by\n    simp only [c_zero, norm_eq_zero, ne.def, not_false_iff, inv_mul_cancel, norm_inv]\n  rwa [cancel] at le\n#align smul_mem_polar smul_mem_polar\n\n",
 "polar_univ":
 "@[simp]\ntheorem polar_univ : polar 𝕜 (univ : Set E) = {(0 : dual 𝕜 E)} :=\n  (dual_pairing 𝕜 E).flip.polar_univ (LinearMap.flip_separatingRight.mpr (dual_pairing_separating_left 𝕜 E))\n#align polar_univ polar_univ\n\n",
 "polar_closure":
 "@[simp]\ntheorem polar_closure (s : Set E) : polar 𝕜 (closure s) = polar 𝕜 s :=\n  ((dual_pairing 𝕜 E).flip.polar_antitone subset_closure).antisymm <|\n    (dual_pairing 𝕜 E).flip.polar_gc.l_le <|\n      closure_minimal ((dual_pairing 𝕜 E).flip.polar_gc.le_u_l s) <| by\n        simpa [LinearMap.flip_flip] using (is_closed_polar _ _).preimage (inclusion_in_double_dual 𝕜 E).continuous\n#align polar_closure polar_closure\n\n",
 "polar_closed_ball":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- The `polar` of closed ball in a normed space `E` is the closed ball of the dual with\ninverse radius. -/\ntheorem polar_closed_ball {𝕜 E : Type _} [IsROrC 𝕜] [NormedAddCommGroup E] [NormedSpace 𝕜 E] {r : exprℝ} (hr : 0 < r) :\n    polar 𝕜 (closedBall (0 : E) r) = closedBall (0 : dual 𝕜 E) r⁻¹ :=\n  by\n  refine' subset.antisymm _ (closed_ball_inv_subset_polar_closed_ball _)\n  intro x' h\n  simp only [mem_closedBall_zero_iff]\n  refine' continuous_linear_map.op_norm_le_of_ball hr (inv_nonneg.mpr hr.le) fun z hz => _\n  simpa only [one_div] using linear_map.bound_of_ball_bound' hr 1 x'.to_linear_map h z\n#align polar_closed_ball polar_closed_ball\n\n",
 "polar_ball_subset_closed_ball_div":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem polar_ball_subset_closed_ball_div {c : 𝕜} (hc : 1 < «expr‖ ‖» c) {r : exprℝ} (hr : 0 < r) :\n    polar 𝕜 (ball (0 : E) r) ⊆ closedBall (0 : dual 𝕜 E) («expr‖ ‖» c / r) :=\n  by\n  intro x' hx'\n  rw [mem_polar_iff] at hx'\n  simp only [polar, mem_set_of_eq, mem_closedBall_zero_iff, mem_ball_zero_iff] at *\n  have hcr : 0 < «expr‖ ‖» c / r := div_pos (zero_lt_one.trans hc) hr\n  refine' continuous_linear_map.op_norm_le_of_shell hr hcr.le hc fun x h₁ h₂ => _\n  calc\n    «expr‖ ‖» (x' x) ≤ 1 := hx' _ h₂\n    _ ≤ «expr‖ ‖» c / r * «expr‖ ‖» x := (inv_pos_le_iff_one_le_mul' hcr).1 (by rwa [inv_div])\n    \n#align polar_ball_subset_closed_ball_div polar_ball_subset_closed_ball_div\n\n",
 "norm_le_dual_bound":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/-- If one controls the norm of every `f x`, then one controls the norm of `x`.\n    Compare `continuous_linear_map.op_norm_le_bound`. -/\ntheorem norm_le_dual_bound (x : E) {M : exprℝ} (hMp : 0 ≤ M) (hM : ∀ f : dual 𝕜 E, «expr‖ ‖» (f x) ≤ M * «expr‖ ‖» f) :\n    «expr‖ ‖» x ≤ M := by\n  classical\n    by_cases h : x = 0\n    · simp only [h, hMp, norm_zero]\n    · obtain ⟨f, hf₁, hfx⟩ : ∃ f : «expr →L[ ] » E 𝕜 𝕜, «expr‖ ‖» f = 1 ∧ f x = «expr‖ ‖» x := exists_dual_vector 𝕜 x h\n      calc\n        «expr‖ ‖» x = «expr‖ ‖» («expr‖ ‖» x : 𝕜) := is_R_or_C.norm_coe_norm.symm\n        _ = «expr‖ ‖» (f x) := by rw [hfx]\n        _ ≤ M * «expr‖ ‖» f := (hM f)\n        _ = M := by rw [hf₁, mul_one]\n        \n#align norm_le_dual_bound norm_le_dual_bound\n\n",
 "mem_polar_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem mem_polar_iff {x' : dual 𝕜 E} (s : Set E) : x' ∈ polar 𝕜 s ↔ ∀ z ∈ s, «expr‖ ‖» (x' z) ≤ 1 :=\n  iff.rfl\n#align mem_polar_iff mem_polar_iff\n\n",
 "is_closed_polar":
 "theorem is_closed_polar (s : Set E) : IsClosed (polar 𝕜 s) :=\n  by\n  dsimp only [normed_space.polar]\n  simp only [LinearMap.polar_eq_interᵢ, LinearMap.flip_apply]\n  refine' isClosed_binterᵢ fun z hz => _\n  exact is_closed_Iic.preimage (continuous_linear_map.apply 𝕜 𝕜 z).continuous.norm\n#align is_closed_polar is_closed_polar\n\n",
 "inclusion_in_double_dual_norm_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem inclusion_in_double_dual_norm_le : «expr‖ ‖» (inclusion_in_double_dual 𝕜 E) ≤ 1 :=\n  by\n  rw [inclusion_in_double_dual_norm_eq]\n  exact continuous_linear_map.norm_id_le\n#align inclusion_in_double_dual_norm_le inclusion_in_double_dual_norm_le\n\n",
 "inclusion_in_double_dual_norm_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem inclusion_in_double_dual_norm_eq :\n    «expr‖ ‖» (inclusion_in_double_dual 𝕜 E) = «expr‖ ‖» (ContinuousLinearMap.id 𝕜 (dual 𝕜 E)) :=\n  continuous_linear_map.op_norm_flip _\n#align inclusion_in_double_dual_norm_eq inclusion_in_double_dual_norm_eq\n\n",
 "eq_zero_of_forall_dual_eq_zero":
 "theorem eq_zero_of_forall_dual_eq_zero {x : E} (h : ∀ f : dual 𝕜 E, f x = (0 : 𝕜)) : x = 0 :=\n  norm_le_zero_iff.mp (norm_le_dual_bound 𝕜 x le_rfl fun f => by simp [h f])\n#align eq_zero_of_forall_dual_eq_zero eq_zero_of_forall_dual_eq_zero\n\n",
 "eq_zero_iff_forall_dual_eq_zero":
 "theorem eq_zero_iff_forall_dual_eq_zero (x : E) : x = 0 ↔ ∀ g : dual 𝕜 E, g x = 0 :=\n  ⟨fun hx => by simp [hx], fun h => eq_zero_of_forall_dual_eq_zero 𝕜 h⟩\n#align eq_zero_iff_forall_dual_eq_zero eq_zero_iff_forall_dual_eq_zero\n\n",
 "eq_iff_forall_dual_eq":
 "/-- See also `geometric_hahn_banach_point_point`. -/\ntheorem eq_iff_forall_dual_eq {x y : E} : x = y ↔ ∀ g : dual 𝕜 E, g x = g y :=\n  by\n  rw [← sub_eq_zero, eq_zero_iff_forall_dual_eq_zero 𝕜 (x - y)]\n  simp [sub_eq_zero]\n#align eq_iff_forall_dual_eq eq_iff_forall_dual_eq\n\n",
 "dual_pairing_separating_left":
 "theorem dual_pairing_separating_left : (dual_pairing 𝕜 E).separating_left :=\n  by\n  rw [LinearMap.separatingLeft_iff_ker_eq_bot, LinearMap.ker_eq_bot]\n  exact ContinuousLinearMap.coe_injective\n#align dual_pairing_separating_left dual_pairing_separating_left\n\n",
 "dual_def":
 "/-\nCopyright (c) 2020 Heather Macbeth. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Heather Macbeth\n-/\n@[simp]\ntheorem dual_def (x : E) (f : dual 𝕜 E) : inclusion_in_double_dual 𝕜 E x f = f x :=\n  rfl\n#align dual_def dual_def\n\n",
 "double_dual_bound":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem double_dual_bound (x : E) : «expr‖ ‖» ((inclusion_in_double_dual 𝕜 E) x) ≤ «expr‖ ‖» x := by\n  simpa using continuous_linear_map.le_of_op_norm_le _ (inclusion_in_double_dual_norm_le 𝕜 E) x\n#align double_dual_bound double_dual_bound\n\n",
 "closed_ball_inv_subset_polar_closed_ball":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem closed_ball_inv_subset_polar_closed_ball {r : exprℝ} :\n    closedBall (0 : dual 𝕜 E) r⁻¹ ⊆ polar 𝕜 (closedBall (0 : E) r) := fun x' hx' x hx =>\n  calc\n    «expr‖ ‖» (x' x) ≤ «expr‖ ‖» x' * «expr‖ ‖» x := x'.le_op_norm x\n    _ ≤ r⁻¹ * r :=\n      (mul_le_mul (mem_closedBall_zero_iff.1 hx') (mem_closedBall_zero_iff.1 hx) (norm_nonneg _)\n        (dist_nonneg.trans hx'))\n    _ = r / r := (inv_mul_eq_div _ _)\n    _ ≤ 1 := div_self_le_one r\n    \n#align closed_ball_inv_subset_polar_closed_ball closed_ball_inv_subset_polar_closed_ball\n\n",
 "bounded_polar_of_mem_nhds_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- Given a neighborhood `s` of the origin in a normed space `E`, the dual norms\nof all elements of the polar `polar 𝕜 s` are bounded by a constant. -/\ntheorem bounded_polar_of_mem_nhds_zero {s : Set E} (s_nhd : s ∈ (nhds) (0 : E)) : Bounded (polar 𝕜 s) :=\n  by\n  obtain ⟨a, ha⟩ : ∃ a : 𝕜, 1 < «expr‖ ‖» a := NormedField.exists_one_lt_norm 𝕜\n  obtain ⟨r, r_pos, r_ball⟩ : ∃ (r : exprℝ)(hr : 0 < r), ball 0 r ⊆ s := Metric.mem_nhds_iff.1 s_nhd\n  exact\n    bounded_closed_ball.mono\n      (((dual_pairing 𝕜 E).flip.polar_antitone r_ball).trans <| polar_ball_subset_closed_ball_div ha r_pos)\n#align bounded_polar_of_mem_nhds_zero bounded_polar_of_mem_nhds_zero\n\n"}