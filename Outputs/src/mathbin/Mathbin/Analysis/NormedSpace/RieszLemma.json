{"riesz_lemma_of_norm_lt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/-- A version of Riesz lemma: given a strict closed subspace `F`, one may find an element of norm `≤ R`\nwhich is at distance  at least `1` of every element of `F`. Here, `R` is any given constant\nstrictly larger than the norm of an element of norm `> 1`. For a version without an `R`, see\n`riesz_lemma`.\n\nSince we are considering a general nontrivially normed field, there may be a gap in possible norms\n(for instance no element of norm in `(1,2)`). Hence, we can not allow `R` arbitrarily close to `1`,\nand require `R > ‖c‖` for some `c : 𝕜` with norm `> 1`.\n-/\ntheorem riesz_lemma_of_norm_lt {c : 𝕜} (hc : 1 < «expr‖ ‖» c) {R : exprℝ} (hR : «expr‖ ‖» c < R) {F : subspace 𝕜 E}\n    (hFc : is_closed (F : set E)) (hF : ∃ x : E, x ∉ F) :\n    ∃ x₀ : E, «expr‖ ‖» x₀ ≤ R ∧ ∀ y ∈ F, 1 ≤ «expr‖ ‖» (x₀ - y) :=\n  by\n  have Rpos : 0 < R := (norm_nonneg _).trans_lt hR\n  have : «expr‖ ‖» c / R < 1 := by\n    rw [div_lt_iff Rpos]\n    simpa using hR\n  rcases riesz_lemma hFc hF this with ⟨x, xF, hx⟩\n  have x0 : x ≠ 0 := fun H => by simpa [H] using xF\n  obtain ⟨d, d0, dxlt, ledx, -⟩ :\n    ∃ d : 𝕜,\n      d ≠ 0 ∧\n        «expr‖ ‖» («expr • » d x) < R ∧\n          R / «expr‖ ‖» c ≤ «expr‖ ‖» («expr • » d x) ∧ («expr‖ ‖» d)⁻¹ ≤ R⁻¹ * «expr‖ ‖» c * «expr‖ ‖» x :=\n    rescale_to_shell hc Rpos x0\n  refine' ⟨«expr • » d x, dxlt.le, fun y hy => _⟩\n  set y' := «expr • » d⁻¹ y with hy'\n  have y'F : y' ∈ F := by simp [hy', submodule.smul_mem _ _ hy]\n  have yy' : y = «expr • » d y' := by simp [hy', smul_smul, mul_inv_cancel d0]\n  calc\n    1 = «expr‖ ‖» c / R * (R / «expr‖ ‖» c) := by field_simp [Rpos.ne', (zero_lt_one.trans hc).ne']\n    _ ≤ «expr‖ ‖» c / R * «expr‖ ‖» («expr • » d x) :=\n      mul_le_mul_of_nonneg_left ledx (div_nonneg (norm_nonneg _) Rpos.le)\n    _ = «expr‖ ‖» d * («expr‖ ‖» c / R * «expr‖ ‖» x) :=\n      by\n      simp [norm_smul]\n      ring\n    _ ≤ «expr‖ ‖» d * «expr‖ ‖» (x - y') :=\n      mul_le_mul_of_nonneg_left (hx y' (by simp [hy', submodule.smul_mem _ _ hy])) (norm_nonneg _)\n    _ = «expr‖ ‖» («expr • » d x - y) := by simp [yy', ← smul_sub, norm_smul]\n    \n#align riesz_lemma_of_norm_lt riesz_lemma_of_norm_lt\n\n",
 "riesz_lemma":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/-\nCopyright (c) 2019 Jean Lo. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Jean Lo, Yury Kudryashov\n-/\n/-- Riesz's lemma, which usually states that it is possible to find a\nvector with norm 1 whose distance to a closed proper subspace is\narbitrarily close to 1. The statement here is in terms of multiples of\nnorms, since in general the existence of an element of norm exactly 1\nis not guaranteed. For a variant giving an element with norm in `[1, R]`, see\n`riesz_lemma_of_norm_lt`. -/\ntheorem riesz_lemma {F : subspace 𝕜 E} (hFc : is_closed (F : set E)) (hF : ∃ x : E, x ∉ F) {r : exprℝ} (hr : r < 1) :\n    ∃ x₀ : E, x₀ ∉ F ∧ ∀ y ∈ F, r * «expr‖ ‖» x₀ ≤ «expr‖ ‖» (x₀ - y) := by\n  classical\n    obtain ⟨x, hx⟩ : ∃ x : E, x ∉ F := hF\n    let d := metric.inf_dist x F\n    have hFn : (F : set E).nonempty := ⟨_, F.zero_mem⟩\n    have hdp : 0 < d := lt_of_le_of_ne metric.inf_dist_nonneg fun heq => hx ((hFc.mem_iff_inf_dist_zero hFn).2 HEq.symm)\n    let r' := max r 2⁻¹\n    have hr' : r' < 1 := by\n      simp [r', hr]\n      norm_num\n    have hlt : 0 < r' := lt_of_lt_of_le (by norm_num) (le_max_right r 2⁻¹)\n    have hdlt : d < d / r' := (lt_div_iff hlt).mpr ((mul_lt_iff_lt_one_right hdp).2 hr')\n    obtain ⟨y₀, hy₀F, hxy₀⟩ : ∃ y ∈ F, dist x y < d / r' := (metric.inf_dist_lt_iff hFn).mp hdlt\n    have x_ne_y₀ : x - y₀ ∉ F := by\n      by_contra h\n      have : x - y₀ + y₀ ∈ F := F.add_mem h hy₀F\n      simp only [neg_add_cancel_right, sub_eq_add_neg] at this\n      exact hx this\n    refine' ⟨x - y₀, x_ne_y₀, fun y hy => le_of_lt _⟩\n    have hy₀y : y₀ + y ∈ F := F.add_mem hy₀F hy\n    calc\n      r * «expr‖ ‖» (x - y₀) ≤ r' * «expr‖ ‖» (x - y₀) := mul_le_mul_of_nonneg_right (le_max_left _ _) (norm_nonneg _)\n      _ < d := by\n        rw [← dist_eq_norm]\n        exact (lt_div_iff' hlt).1 hxy₀\n      _ ≤ dist x (y₀ + y) := metric.inf_dist_le_dist_of_mem hy₀y\n      _ = «expr‖ ‖» (x - y₀ - y) := by rw [sub_sub, dist_eq_norm]\n      \n#align riesz_lemma riesz_lemma\n\n",
 "closed_ball_inf_dist_compl_subset_closure":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\ntheorem metric.closed_ball_inf_dist_compl_subset_closure {x : F} {s : set F} (hx : x ∈ s) :\n    closed_ball x (inf_dist x («expr ᶜ» s)) ⊆ closure s :=\n  by\n  cases' eq_or_ne (inf_dist x («expr ᶜ» s)) 0 with h₀ h₀\n  · rw [h₀, closed_ball_zero']\n    exact closure_mono (singleton_subset_iff.2 hx)\n  · rw [← closure_ball x h₀]\n    exact closure_mono ball_inf_dist_compl_subset\n#align metric.closed_ball_inf_dist_compl_subset_closure metric.closed_ball_inf_dist_compl_subset_closure\n\n"}