{"thickening_thickening":
 "@[simp]\ntheorem thickening_thickening (hε : 0 < ε) (hδ : 0 < δ) (s : set E) :\n    thickening ε (thickening δ s) = thickening (ε + δ) s :=\n  (thickening_thickening_subset _ _ _).antisymm fun x =>\n    by\n    simp_rw [mem_thickening_iff]\n    rintro ⟨z, hz, hxz⟩\n    rw [add_comm] at hxz\n    obtain ⟨y, hxy, hyz⟩ := exists_dist_lt_lt hε hδ hxz\n    exact ⟨y, ⟨_, hz, hyz⟩, hxy⟩\n#align thickening_thickening thickening_thickening\n\n",
 "thickening_cthickening":
 "@[simp]\ntheorem thickening_cthickening (hε : 0 < ε) (hδ : 0 ≤ δ) (s : set E) :\n    thickening ε (cthickening δ s) = thickening (ε + δ) s :=\n  by\n  obtain rfl | hδ := hδ.eq_or_lt\n  · rw [cthickening_zero, thickening_closure, add_zero]\n  · rw [← closure_thickening hδ, thickening_closure, thickening_thickening hε hδ] <;> infer_instance\n#align thickening_cthickening thickening_cthickening\n\n",
 "thickening_closed_ball":
 "@[simp]\ntheorem thickening_closed_ball (hε : 0 < ε) (hδ : 0 ≤ δ) (x : E) : thickening ε (closed_ball x δ) = ball x (ε + δ) := by\n  rw [← cthickening_singleton _ hδ, thickening_cthickening hε hδ, thickening_singleton] <;> infer_instance\n#align thickening_closed_ball thickening_closed_ball\n\n",
 "thickening_ball":
 "@[simp]\ntheorem thickening_ball (hε : 0 < ε) (hδ : 0 < δ) (x : E) : thickening ε (ball x δ) = ball x (ε + δ) := by\n  rw [← thickening_singleton, thickening_thickening hε hδ, thickening_singleton] <;> infer_instance\n#align thickening_ball thickening_ball\n\n",
 "sphere_nonempty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- In a nontrivial real normed space, a sphere is nonempty if and only if its radius is\nnonnegative. -/\n@[simp]\ntheorem normed_space.sphere_nonempty [nontrivial E] {x : E} {r : exprℝ} : (sphere x r).nonempty ↔ 0 ≤ r :=\n  by\n  obtain ⟨y, hy⟩ := exists_ne x\n  refine'\n    ⟨fun h => nonempty_closed_ball.1 (h.mono sphere_subset_closed_ball), fun hr =>\n      ⟨«expr • » r («expr • » («expr‖ ‖» (y - x))⁻¹ (y - x)) + x, _⟩⟩\n  have : «expr‖ ‖» (y - x) ≠ 0 := by simpa [sub_eq_zero]\n  simp [norm_smul, this, real.norm_of_nonneg hr]\n#align normed_space.sphere_nonempty normed_space.sphere_nonempty\n\n",
 "smul_unit_ball_of_pos":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- In a real normed space, the image of the unit ball under scalar multiplication by a positive\nconstant `r` is the ball of radius `r`. -/\ntheorem smul_unit_ball_of_pos {r : exprℝ} (hr : 0 < r) : «expr • » r (ball 0 1) = ball (0 : E) r := by\n  rw [smul_unit_ball hr.ne', real.norm_of_nonneg hr.le]\n#align smul_unit_ball_of_pos smul_unit_ball_of_pos\n\n",
 "smul_unit_ball":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem smul_unit_ball {c : 𝕜} (hc : c ≠ 0) : «expr • » c (ball (0 : E) (1 : exprℝ)) = ball (0 : E) («expr‖ ‖» c) := by\n  rw [smul_ball hc, smul_zero, mul_one]\n#align smul_unit_ball smul_unit_ball\n\n",
 "smul_sphere'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem smul_sphere' {c : 𝕜} (hc : c ≠ 0) (x : E) (r : exprℝ) :\n    «expr • » c (sphere x r) = sphere («expr • » c x) («expr‖ ‖» c * r) :=\n  by\n  ext y\n  rw [mem_smul_set_iff_inv_smul_mem₀ hc]\n  conv_lhs => rw [← inv_smul_smul₀ hc x]\n  simp only [mem_sphere, dist_smul, norm_inv, ← div_eq_inv_mul, div_eq_iff (norm_pos_iff.2 hc).ne', mul_comm r]\n#align smul_sphere' smul_sphere'\n\n",
 "smul_sphere":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem smul_sphere [nontrivial E] (c : 𝕜) (x : E) {r : exprℝ} (hr : 0 ≤ r) :\n    «expr • » c (sphere x r) = sphere («expr • » c x) («expr‖ ‖» c * r) :=\n  by\n  rcases eq_or_ne c 0 with (rfl | hc)\n  · simp [zero_smul_set, set.singleton_zero, hr]\n  · exact smul_sphere' hc x r\n#align smul_sphere smul_sphere\n\n",
 "smul_closed_unit_ball_of_nonneg":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- In a real normed space, the image of the unit closed ball under multiplication by a nonnegative\nnumber `r` is the closed ball of radius `r` with center at the origin. -/\ntheorem smul_closed_unit_ball_of_nonneg {r : exprℝ} (hr : 0 ≤ r) :\n    «expr • » r (closed_ball 0 1) = closed_ball (0 : E) r := by rw [smul_closed_unit_ball, real.norm_of_nonneg hr]\n#align smul_closed_unit_ball_of_nonneg smul_closed_unit_ball_of_nonneg\n\n",
 "smul_closed_unit_ball":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem smul_closed_unit_ball (c : 𝕜) :\n    «expr • » c (closed_ball (0 : E) (1 : exprℝ)) = closed_ball (0 : E) («expr‖ ‖» c) := by\n  rw [smul_closed_ball _ _ zero_le_one, smul_zero, mul_one]\n#align smul_closed_unit_ball smul_closed_unit_ball\n\n",
 "smul_closed_ball'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem smul_closed_ball' {c : 𝕜} (hc : c ≠ 0) (x : E) (r : exprℝ) :\n    «expr • » c (closed_ball x r) = closed_ball («expr • » c x) («expr‖ ‖» c * r) := by\n  simp only [← ball_union_sphere, Set.smul_set_union, smul_ball hc, smul_sphere' hc]\n#align smul_closed_ball' smul_closed_ball'\n\n",
 "smul_closed_ball":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem smul_closed_ball (c : 𝕜) (x : E) {r : exprℝ} (hr : 0 ≤ r) :\n    «expr • » c (closed_ball x r) = closed_ball («expr • » c x) («expr‖ ‖» c * r) :=\n  by\n  rcases eq_or_ne c 0 with (rfl | hc)\n  · simp [hr, zero_smul_set, set.singleton_zero, ← nonempty_closed_ball]\n  · exact smul_closed_ball' hc x r\n#align smul_closed_ball smul_closed_ball\n\n",
 "smul_ball":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/-\nCopyright (c) 2021 Sébastien Gouëzel. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Sébastien Gouëzel, Yaël Dillies\n-/\ntheorem smul_ball {c : 𝕜} (hc : c ≠ 0) (x : E) (r : exprℝ) :\n    «expr • » c (ball x r) = ball («expr • » c x) («expr‖ ‖» c * r) :=\n  by\n  ext y\n  rw [mem_smul_set_iff_inv_smul_mem₀ hc]\n  conv_lhs => rw [← inv_smul_smul₀ hc x]\n  simp [← div_eq_inv_mul, div_lt_iff (norm_pos_iff.2 hc), mul_comm _ r, dist_smul]\n#align smul_ball smul_ball\n\n",
 "smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem metric.bounded.smul {s : set E} (hs : bounded s) (c : 𝕜) : bounded («expr • » c s) :=\n  by\n  obtain ⟨R, hR⟩ : ∃ R : exprℝ, ∀ x ∈ s, «expr‖ ‖» x ≤ R := hs.exists_norm_le\n  refine' bounded_iff_forall_norm_le.2 ⟨«expr‖ ‖» c * R, fun z hz => _⟩\n  obtain ⟨y, ys, rfl⟩ : ∃ y : E, y ∈ s ∧ «expr • » c y = z := mem_smul_set.1 hz\n  calc\n    «expr‖ ‖» («expr • » c y) = «expr‖ ‖» c * «expr‖ ‖» y := norm_smul _ _\n    _ ≤ «expr‖ ‖» c * R := mul_le_mul_of_nonneg_left (hR y ys) (norm_nonneg _)\n    \n#align metric.bounded.smul metric.bounded.smul\n\n",
 "inf_edist_thickening":
 "@[simp]\ntheorem inf_edist_thickening (hδ : 0 < δ) (s : set E) (x : E) :\n    inf_edist x (thickening δ s) = inf_edist x s - ennreal.of_real δ :=\n  by\n  obtain hs | hs := lt_or_le (inf_edist x s) (ennreal.of_real δ)\n  · rw [inf_edist_zero_of_mem, tsub_eq_zero_of_le hs.le]\n    exact hs\n  refine' (tsub_le_iff_right.2 inf_edist_le_inf_edist_thickening_add).antisymm' _\n  refine' le_sub_of_add_le_right of_real_ne_top _\n  refine' le_inf_edist.2 fun z hz => le_of_forall_lt' fun r h => _\n  cases r\n  · exact add_lt_top.2 ⟨lt_top_iff_ne_top.2 <| inf_edist_ne_top ⟨z, self_subset_thickening hδ _ hz⟩, of_real_lt_top⟩\n  have hr : 0 < ↑r - δ := by\n    refine' sub_pos_of_lt _\n    have := hs.trans_lt ((inf_edist_le_edist_of_mem hz).trans_lt h)\n    rw [of_real_eq_coe_nnreal hδ.le, some_eq_coe] at this\n    exact_mod_cast this\n  rw [some_eq_coe, edist_lt_coe, ← dist_lt_coe, ← add_sub_cancel'_right δ ↑r] at h\n  obtain ⟨y, hxy, hyz⟩ := exists_dist_lt_lt hr hδ h\n  refine'\n    (ennreal.add_lt_add_right of_real_ne_top <|\n          inf_edist_lt_iff.2 ⟨_, mem_thickening_iff.2 ⟨_, hz, hyz⟩, edist_lt_of_real.2 hxy⟩).trans_le\n      _\n  rw [← of_real_add hr.le hδ.le, sub_add_cancel, of_real_coe_nnreal]\n  exact le_rfl\n#align inf_edist_thickening inf_edist_thickening\n\n",
 "inf_edist_cthickening":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n@[simp]\ntheorem inf_edist_cthickening (δ : exprℝ) (s : set E) (x : E) :\n    inf_edist x (cthickening δ s) = inf_edist x s - ennreal.of_real δ :=\n  by\n  obtain hδ | hδ := le_or_lt δ 0\n  · rw [cthickening_of_nonpos hδ, inf_edist_closure, of_real_of_nonpos hδ, tsub_zero]\n  · rw [← closure_thickening hδ, inf_edist_closure, inf_edist_thickening hδ] <;> infer_instance\n#align inf_edist_cthickening inf_edist_cthickening\n\n",
 "exists_dist_lt_lt":
 "-- This is also true for `ℚ`-normed spaces\ntheorem exists_dist_lt_lt (hδ : 0 < δ) (hε : 0 < ε) (h : dist x z < ε + δ) : ∃ y, dist x y < δ ∧ dist y z < ε :=\n  by\n  refine'\n    (exists_dist_eq x z (div_nonneg hε.le <| add_nonneg hε.le hδ.le) (div_nonneg hδ.le <| add_nonneg hε.le hδ.le) <| by\n          rw [← add_div, div_self (add_pos hε hδ).ne']).imp\n      fun y hy => _\n  rw [hy.1, hy.2, div_mul_comm, div_mul_comm ε]\n  rw [← div_lt_one (add_pos hε hδ)] at h\n  exact ⟨mul_lt_of_lt_one_left hδ h, mul_lt_of_lt_one_left hε h⟩\n#align exists_dist_lt_lt exists_dist_lt_lt\n\n",
 "exists_dist_lt_le":
 "-- This is also true for `ℚ`-normed spaces\ntheorem exists_dist_lt_le (hδ : 0 < δ) (hε : 0 ≤ ε) (h : dist x z < ε + δ) : ∃ y, dist x y < δ ∧ dist y z ≤ ε :=\n  by\n  obtain ⟨y, yz, xy⟩ := exists_dist_le_lt hε hδ (show dist z x < δ + ε by simpa only [dist_comm, add_comm] using h)\n  exact ⟨y, by simp [dist_comm x y, dist_comm y z, *]⟩\n#align exists_dist_lt_le exists_dist_lt_le\n\n",
 "exists_dist_le_lt":
 "-- This is also true for `ℚ`-normed spaces\ntheorem exists_dist_le_lt (hδ : 0 ≤ δ) (hε : 0 < ε) (h : dist x z < ε + δ) : ∃ y, dist x y ≤ δ ∧ dist y z < ε :=\n  by\n  refine'\n    (exists_dist_eq x z (div_nonneg hε.le <| add_nonneg hε.le hδ) (div_nonneg hδ <| add_nonneg hε.le hδ) <| by\n          rw [← add_div, div_self (add_pos_of_pos_of_nonneg hε hδ).ne']).imp\n      fun y hy => _\n  rw [hy.1, hy.2, div_mul_comm, div_mul_comm ε]\n  rw [← div_lt_one (add_pos_of_pos_of_nonneg hε hδ)] at h\n  exact ⟨mul_le_of_le_one_left hδ h.le, mul_lt_of_lt_one_left hε h⟩\n#align exists_dist_le_lt exists_dist_le_lt\n\n",
 "exists_dist_le_le":
 "theorem exists_dist_le_le (hδ : 0 ≤ δ) (hε : 0 ≤ ε) (h : dist x z ≤ ε + δ) : ∃ y, dist x y ≤ δ ∧ dist y z ≤ ε :=\n  by\n  obtain rfl | hε' := hε.eq_or_lt\n  · exact ⟨z, by rwa [zero_add] at h, (dist_self _).le⟩\n  have hεδ := add_pos_of_pos_of_nonneg hε' hδ\n  refine'\n    (exists_dist_eq x z (div_nonneg hε <| add_nonneg hε hδ) (div_nonneg hδ <| add_nonneg hε hδ) <| by\n          rw [← add_div, div_self hεδ.ne']).imp\n      fun y hy => _\n  rw [hy.1, hy.2, div_mul_comm, div_mul_comm ε]\n  rw [← div_le_one hεδ] at h\n  exact ⟨mul_le_of_le_one_left hδ h, mul_le_of_le_one_left hε h⟩\n#align exists_dist_le_le exists_dist_le_le\n\n",
 "exists_dist_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n-- This is also true for `ℚ`-normed spaces\ntheorem exists_dist_eq (x z : E) {a b : exprℝ} (ha : 0 ≤ a) (hb : 0 ≤ b) (hab : a + b = 1) :\n    ∃ y, dist x y = b * dist x z ∧ dist y z = a * dist x z :=\n  by\n  use «expr • » a x + «expr • » b z\n  nth_rw 1 [← one_smul (exprℝ) x]\n  nth_rw 4 [← one_smul (exprℝ) z]\n  simp [dist_eq_norm, ← hab, add_smul, ← smul_sub, norm_smul_of_nonneg, ha, hb]\n#align exists_dist_eq exists_dist_eq\n\n",
 "eventually_singleton_add_smul_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- If `s` is a bounded set, then for small enough `r`, the set `{x} + r • s` is contained in any\nfixed neighborhood of `x`. -/\ntheorem eventually_singleton_add_smul_subset {x : E} {s : set E} (hs : bounded s) {u : set E} (hu : u ∈ (nhds) x) :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\"\n      ((nhds) (0 : 𝕜)) ({x} + «expr • » r s ⊆ u) :=\n  by\n  obtain ⟨ε, εpos, hε⟩ : ∃ (ε : _)(hε : 0 < ε), closed_ball x ε ⊆ u := nhds_basis_closed_ball.mem_iff.1 hu\n  obtain ⟨R, Rpos, hR⟩ : ∃ R : exprℝ, 0 < R ∧ s ⊆ closed_ball 0 R := hs.subset_ball_lt 0 0\n  have : metric.closed_ball (0 : 𝕜) (ε / R) ∈ (nhds) (0 : 𝕜) := closed_ball_mem_nhds _ (div_pos εpos Rpos)\n  filter_upwards [this] with r hr\n  simp only [image_add_left, singleton_add]\n  intro y hy\n  obtain ⟨z, zs, hz⟩ : ∃ z : E, z ∈ s ∧ «expr • » r z = -x + y := by simpa [mem_smul_set] using hy\n  have I : «expr‖ ‖» («expr • » r z) ≤ ε :=\n    calc\n      «expr‖ ‖» («expr • » r z) = «expr‖ ‖» r * «expr‖ ‖» z := norm_smul _ _\n      _ ≤ ε / R * R :=\n        mul_le_mul (mem_closed_ball_zero_iff.1 hr) (mem_closed_ball_zero_iff.1 (hR zs)) (norm_nonneg _)\n          (div_pos εpos Rpos).le\n      _ = ε := by field_simp [Rpos.ne']\n      \n  have : y = x + «expr • » r z := by simp only [hz, add_neg_cancel_left]\n  apply hε\n  simpa only [this, dist_eq_norm, add_sub_cancel', mem_closed_ball] using I\n#align eventually_singleton_add_smul_subset eventually_singleton_add_smul_subset\n\n",
 "disjoint_closed_ball_closed_ball_iff":
 "theorem disjoint_closed_ball_closed_ball_iff (hδ : 0 ≤ δ) (hε : 0 ≤ ε) :\n    Disjoint (closed_ball x δ) (closed_ball y ε) ↔ δ + ε < dist x y :=\n  by\n  refine' ⟨fun h => lt_of_not_ge fun hxy => _, closed_ball_disjoint_closed_ball⟩\n  rw [add_comm] at hxy\n  obtain ⟨z, hxz, hzy⟩ := exists_dist_le_le hδ hε hxy\n  rw [dist_comm] at hxz\n  exact h.le_bot ⟨hxz, hzy⟩\n#align disjoint_closed_ball_closed_ball_iff disjoint_closed_ball_closed_ball_iff\n\n",
 "disjoint_closed_ball_ball_iff":
 "-- This is also true for `ℚ`-normed spaces\ntheorem disjoint_closed_ball_ball_iff (hδ : 0 ≤ δ) (hε : 0 < ε) :\n    Disjoint (closed_ball x δ) (ball y ε) ↔ δ + ε ≤ dist x y := by\n  rw [disjoint_comm, disjoint_ball_closed_ball_iff hε hδ, add_comm, dist_comm] <;> infer_instance\n#align disjoint_closed_ball_ball_iff disjoint_closed_ball_ball_iff\n\n",
 "disjoint_ball_closed_ball_iff":
 "-- This is also true for `ℚ`-normed spaces\ntheorem disjoint_ball_closed_ball_iff (hδ : 0 < δ) (hε : 0 ≤ ε) :\n    Disjoint (ball x δ) (closed_ball y ε) ↔ δ + ε ≤ dist x y :=\n  by\n  refine' ⟨fun h => le_of_not_lt fun hxy => _, ball_disjoint_closed_ball⟩\n  rw [add_comm] at hxy\n  obtain ⟨z, hxz, hzy⟩ := exists_dist_lt_le hδ hε hxy\n  rw [dist_comm] at hxz\n  exact h.le_bot ⟨hxz, hzy⟩\n#align disjoint_ball_closed_ball_iff disjoint_ball_closed_ball_iff\n\n",
 "disjoint_ball_ball_iff":
 "-- This is also true for `ℚ`-normed spaces\ntheorem disjoint_ball_ball_iff (hδ : 0 < δ) (hε : 0 < ε) : Disjoint (ball x δ) (ball y ε) ↔ δ + ε ≤ dist x y :=\n  by\n  refine' ⟨fun h => le_of_not_lt fun hxy => _, ball_disjoint_ball⟩\n  rw [add_comm] at hxy\n  obtain ⟨z, hxz, hzy⟩ := exists_dist_lt_lt hδ hε hxy\n  rw [dist_comm] at hxz\n  exact h.le_bot ⟨hxz, hzy⟩\n#align disjoint_ball_ball_iff disjoint_ball_ball_iff\n\n",
 "cthickening_thickening":
 "@[simp]\ntheorem cthickening_thickening (hε : 0 ≤ ε) (hδ : 0 < δ) (s : set E) :\n    cthickening ε (thickening δ s) = cthickening (ε + δ) s :=\n  (cthickening_thickening_subset hε _ _).antisymm fun x =>\n    by\n    simp_rw [mem_cthickening_iff, ennreal.of_real_add hε hδ.le, inf_edist_thickening hδ]\n    exact tsub_le_iff_right.2\n#align cthickening_thickening cthickening_thickening\n\n",
 "cthickening_cthickening":
 "@[simp]\ntheorem cthickening_cthickening (hε : 0 ≤ ε) (hδ : 0 ≤ δ) (s : set E) :\n    cthickening ε (cthickening δ s) = cthickening (ε + δ) s :=\n  (cthickening_cthickening_subset hε hδ _).antisymm fun x =>\n    by\n    simp_rw [mem_cthickening_iff, ennreal.of_real_add hε hδ, inf_edist_cthickening]\n    exact tsub_le_iff_right.2\n#align cthickening_cthickening cthickening_cthickening\n\n",
 "cthickening_closed_ball":
 "@[simp]\ntheorem cthickening_closed_ball (hε : 0 ≤ ε) (hδ : 0 ≤ δ) (x : E) :\n    cthickening ε (closed_ball x δ) = closed_ball x (ε + δ) := by\n  rw [← cthickening_singleton _ hδ, cthickening_cthickening hε hδ, cthickening_singleton _ (add_nonneg hε hδ)] <;>\n    infer_instance\n#align cthickening_closed_ball cthickening_closed_ball\n\n",
 "cthickening_ball":
 "@[simp]\ntheorem cthickening_ball (hε : 0 ≤ ε) (hδ : 0 < δ) (x : E) : cthickening ε (ball x δ) = closed_ball x (ε + δ) := by\n  rw [← thickening_singleton, cthickening_thickening hε hδ, cthickening_singleton _ (add_nonneg hε hδ.le)] <;>\n    infer_instance\n#align cthickening_ball cthickening_ball\n\n",
 "closure_thickening":
 "-- Note: `interior (cthickening δ s) ≠ thickening δ s` in general\n@[simp]\ntheorem closure_thickening (hδ : 0 < δ) (s : set E) : closure (thickening δ s) = cthickening δ s :=\n  by\n  rw [← cthickening_zero, cthickening_thickening le_rfl hδ, zero_add]\n  infer_instance\n#align closure_thickening closure_thickening\n\n",
 "closed_ball_sub_closed_ball":
 "theorem closed_ball_sub_closed_ball [proper_space E] (hε : 0 ≤ ε) (hδ : 0 ≤ δ) (a b : E) :\n    closed_ball a ε - closed_ball b δ = closed_ball (a - b) (ε + δ) := by\n  simp_rw [sub_eq_add_neg, neg_closed_ball, closed_ball_add_closed_ball hε hδ]\n#align closed_ball_sub_closed_ball closed_ball_sub_closed_ball\n\n",
 "closed_ball_sub_ball":
 "theorem closed_ball_sub_ball (hε : 0 ≤ ε) (hδ : 0 < δ) (a b : E) : closed_ball a ε - ball b δ = ball (a - b) (ε + δ) :=\n  by simp_rw [sub_eq_add_neg, neg_ball, closed_ball_add_ball hε hδ]\n#align closed_ball_sub_ball closed_ball_sub_ball\n\n",
 "closed_ball_add_closed_ball":
 "theorem closed_ball_add_closed_ball [proper_space E] (hε : 0 ≤ ε) (hδ : 0 ≤ δ) (a b : E) :\n    closed_ball a ε + closed_ball b δ = closed_ball (a + b) (ε + δ) := by\n  rw [(is_compact_closed_ball _ _).add_closed_ball hδ, cthickening_closed_ball hδ hε, vadd_closed_ball, vadd_eq_add,\n      add_comm, add_comm δ] <;>\n    infer_instance\n#align closed_ball_add_closed_ball closed_ball_add_closed_ball\n\n",
 "closed_ball_add_ball":
 "theorem closed_ball_add_ball (hε : 0 ≤ ε) (hδ : 0 < δ) (a b : E) : closed_ball a ε + ball b δ = ball (a + b) (ε + δ) :=\n  by rw [add_comm, ball_add_closed_ball hδ hε, add_comm, add_comm δ] <;> infer_instance\n#align closed_ball_add_ball closed_ball_add_ball\n\n",
 "ball_sub_closed_ball":
 "theorem ball_sub_closed_ball (hε : 0 < ε) (hδ : 0 ≤ δ) (a b : E) : ball a ε - closed_ball b δ = ball (a - b) (ε + δ) :=\n  by simp_rw [sub_eq_add_neg, neg_closed_ball, ball_add_closed_ball hε hδ]\n#align ball_sub_closed_ball ball_sub_closed_ball\n\n",
 "ball_sub_ball":
 "theorem ball_sub_ball (hε : 0 < ε) (hδ : 0 < δ) (a b : E) : ball a ε - ball b δ = ball (a - b) (ε + δ) := by\n  simp_rw [sub_eq_add_neg, neg_ball, ball_add_ball hε hδ]\n#align ball_sub_ball ball_sub_ball\n\n",
 "ball_add_closed_ball":
 "theorem ball_add_closed_ball (hε : 0 < ε) (hδ : 0 ≤ δ) (a b : E) : ball a ε + closed_ball b δ = ball (a + b) (ε + δ) :=\n  by rw [ball_add, thickening_closed_ball hε hδ, vadd_ball, vadd_eq_add] <;> infer_instance\n#align ball_add_closed_ball ball_add_closed_ball\n\n",
 "ball_add_ball":
 "theorem ball_add_ball (hε : 0 < ε) (hδ : 0 < δ) (a b : E) : ball a ε + ball b δ = ball (a + b) (ε + δ) := by\n  rw [ball_add, thickening_ball hε hδ, vadd_ball, vadd_eq_add] <;> infer_instance\n#align ball_add_ball ball_add_ball\n\n",
 "affinity_unit_closed_ball":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr +ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- Any closed ball `metric.closed_ball x r`, `0 ≤ r` is the image of the unit closed ball under\n`λ y, x + r • y`. -/\ntheorem affinity_unit_closed_ball {r : exprℝ} (hr : 0 ≤ r) (x : E) :\n    «expr +ᵥ » x («expr • » r (closed_ball 0 1)) = closed_ball x r := by\n  rw [smul_closed_unit_ball, real.norm_of_nonneg hr, vadd_closed_ball_zero]\n#align affinity_unit_closed_ball affinity_unit_closed_ball\n\n",
 "affinity_unit_ball":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr +ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- Any ball `metric.ball x r`, `0 < r` is the image of the unit ball under `λ y, x + r • y`. -/\ntheorem affinity_unit_ball {r : exprℝ} (hr : 0 < r) (x : E) : «expr +ᵥ » x («expr • » r (ball 0 1)) = ball x r := by\n  rw [smul_unit_ball_of_pos hr, vadd_ball_zero]\n#align affinity_unit_ball affinity_unit_ball\n\n"}