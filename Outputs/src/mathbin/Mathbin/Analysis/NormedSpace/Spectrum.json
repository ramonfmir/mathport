{"to_continuous_linear_map_norm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n@[simp]\ntheorem to_continuous_linear_map_norm [NormOneClass A] (φ : «expr →ₐ[ ] » A 𝕜 𝕜) :\n    «expr‖ ‖» φ.to_continuous_linear_map = 1 :=\n  continuous_linear_map.op_norm_eq_of_bounds zero_le_one\n    (fun a => (one_mul («expr‖ ‖» a)).symm ▸ spectrum.norm_le_norm_of_mem (apply_mem_spectrum φ _)) fun _ _ h => by\n    simpa only [coe_to_continuous_linear_map, map_one, norm_one, mul_one] using h 1\n#align to_continuous_linear_map_norm to_continuous_linear_map_norm\n\n",
 "subset_closed_ball_norm_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprσ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem subset_closed_ball_norm_mul (a : A) : (exprσ) a ⊆ Metric.closedBall (0 : 𝕜) («expr‖ ‖» a * «expr‖ ‖» (1 : A)) :=\n  fun k hk => by simp [norm_le_norm_mul_of_mem hk]\n#align subset_closed_ball_norm_mul subset_closed_ball_norm_mul\n\n",
 "subset_closed_ball_norm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprσ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem subset_closed_ball_norm [NormOneClass A] (a : A) : (exprσ) a ⊆ Metric.closedBall (0 : 𝕜) («expr‖ ‖» a) :=\n  fun k hk => by simp [norm_le_norm_of_mem hk]\n#align subset_closed_ball_norm subset_closed_ball_norm\n\n",
 "spectral_radius_zero":
 "@[simp]\ntheorem spectral_radius_zero : spectral_radius 𝕜 (0 : A) = 0 :=\n  by\n  nontriviality A\n  simp [spectral_radius]\n#align spectral_radius_zero spectral_radius_zero\n\n",
 "spectral_radius_lt_of_forall_lt_of_nonempty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprσ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprσ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\ntheorem spectral_radius_lt_of_forall_lt_of_nonempty [ProperSpace 𝕜] {a : A} (ha : ((exprσ) a).nonempty) {r : nnreal}\n    (hr : ∀ k ∈ (exprσ) a, «expr‖ ‖₊» k < r) : spectral_radius 𝕜 a < r :=\n  supₛ_image.symm.trans_lt <|\n    ((spectrum.is_compact a).Sup_lt_iff_of_continuous ha (ENNReal.continuous_coe.comp continuous_nnnorm).continuous_on\n          (r : ennreal)).mpr\n      (by exact_mod_cast hr)\n#align spectral_radius_lt_of_forall_lt_of_nonempty spectral_radius_lt_of_forall_lt_of_nonempty\n\n",
 "spectral_radius_lt_of_forall_lt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/-- In a complex Banach algebra, if every element of the spectrum has norm strictly less than\n`r : ℝ≥0`, then the spectral radius is also strictly less than `r`. -/\ntheorem spectral_radius_lt_of_forall_lt {r : nnreal} (hr : ∀ z ∈ spectrum (exprℂ) a, «expr‖ ‖₊» z < r) :\n    spectral_radius (exprℂ) a < r :=\n  spectral_radius_lt_of_forall_lt_of_nonempty (spectrum.nonempty a) hr\n#align spectral_radius_lt_of_forall_lt spectral_radius_lt_of_forall_lt\n\n",
 "spectral_radius_le_pow_nnnorm_pow_one_div":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprσ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem spectral_radius_le_pow_nnnorm_pow_one_div (a : A) (n : ℕ) :\n    spectral_radius 𝕜 a ≤\n      «expr‖ ‖₊» (a ^ (n + 1)) ^ (1 / (n + 1) : exprℝ) * «expr‖ ‖₊» (1 : A) ^ (1 / (n + 1) : exprℝ) :=\n  by\n  refine' supᵢ₂_le fun k hk => _\n  -- apply easy direction of the spectral mapping theorem for polynomials\n  have pow_mem : k ^ (n + 1) ∈ (exprσ) (a ^ (n + 1)) := by\n    simpa only [one_mul, Algebra.algebraMap_eq_smul_one, one_smul, aeval_monomial, one_mul, eval_monomial] using\n      subset_polynomial_aeval a (monomial (n + 1) (1 : 𝕜)) ⟨k, hk, rfl⟩\n  -- power of the norm is bounded by norm of the power\n  have nnnorm_pow_le : (↑(«expr‖ ‖₊» k ^ (n + 1)) : ennreal) ≤ «expr‖ ‖₊» (a ^ (n + 1)) * «expr‖ ‖₊» (1 : A) := by\n    simpa only [Real.toNNReal_mul (norm_nonneg _), norm_toNNReal, nnnorm_pow k (n + 1), ENNReal.coe_mul] using\n      coe_mono (Real.toNNReal_mono (norm_le_norm_mul_of_mem pow_mem))\n  -- take (n + 1)ᵗʰ roots and clean up the left-hand side\n  have hn : 0 < ((n + 1 : ℕ) : exprℝ) := by exact_mod_cast Nat.succ_pos'\n  convert monotone_rpow_of_nonneg (one_div_pos.mpr hn).le nnnorm_pow_le\n  erw [coe_pow, ← rpow_nat_cast, ← rpow_mul, mul_one_div_cancel hn.ne', rpow_one]\n  rw [Nat.cast_succ, ennreal.coe_mul_rpow]\n#align spectral_radius_le_pow_nnnorm_pow_one_div spectral_radius_le_pow_nnnorm_pow_one_div\n\n",
 "spectral_radius_le_nnnorm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\ntheorem spectral_radius_le_nnnorm [NormOneClass A] (a : A) : spectral_radius 𝕜 a ≤ «expr‖ ‖₊» a :=\n  by\n  refine' supᵢ₂_le fun k hk => _\n  exact_mod_cast norm_le_norm_of_mem hk\n#align spectral_radius_le_nnnorm spectral_radius_le_nnnorm\n\n",
 "spectral_radius_le_liminf_pow_nnnorm_pow_one_div":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem spectral_radius_le_liminf_pow_nnnorm_pow_one_div (a : A) :\n    spectral_radius 𝕜 a ≤ atTop.liminf fun n : ℕ => («expr‖ ‖₊» (a ^ n) : ennreal) ^ (1 / n : exprℝ) :=\n  by\n  refine' ENNReal.le_of_forall_lt_one_mul_le fun ε hε => _\n  by_cases ε = 0\n  · simp only [h, MulZeroClass.zero_mul, zero_le']\n  have hε' : ε⁻¹ ≠ ennreal.top := fun h' =>\n    h (by simpa only [inv_inv, inv_top] using congr_arg (fun x : ennreal => x⁻¹) h')\n  simp only [ENNReal.mul_le_iff_le_inv h (hε.trans_le le_top).ne, mul_comm ε⁻¹, liminf_eq_supr_infi_of_nat',\n    ENNReal.supᵢ_mul, ENNReal.infᵢ_mul hε']\n  rw [← ENNReal.inv_lt_inv, inv_one] at hε\n  obtain ⟨N, hN⟩ :=\n    eventually_at_top.mp\n      (ennreal.eventually_pow_one_div_le (ENNReal.coe_ne_top : ↑(«expr‖ ‖₊» (1 : A)) ≠ ennreal.top) hε)\n  refine' le_trans _ (le_supᵢ _ (N + 1))\n  refine' le_infᵢ fun n => _\n  simp only [← add_assoc]\n  refine' (spectral_radius_le_pow_nnnorm_pow_one_div 𝕜 a (n + N)).trans _\n  norm_cast\n  exact mul_le_mul_left' (hN (n + N + 1) (by linarith)) _\n#align spectral_radius_le_liminf_pow_nnnorm_pow_one_div spectral_radius_le_liminf_pow_nnnorm_pow_one_div\n\n",
 "pow_norm_pow_one_div_tendsto_nhds_spectral_radius":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- This is the same as `pow_nnnorm_pow_one_div_tendsto_nhds_spectral_radius` but for `norm`\ninstead of `nnnorm`. -/\n/-- **Gelfand's formula**: Given an element `a : A` of a complex Banach algebra, the\n`spectral_radius` of `a` is the limit of the sequence `‖a ^ n‖₊ ^ (1 / n)` -/\ntheorem pow_norm_pow_one_div_tendsto_nhds_spectral_radius (a : A) :\n    Tendsto (fun n : ℕ => ENNReal.ofReal («expr‖ ‖» (a ^ n) ^ (1 / n : exprℝ))) atTop\n      ((nhds) (spectral_radius (exprℂ) a)) :=\n  by\n  convert pow_nnnorm_pow_one_div_tendsto_nhds_spectral_radius a\n  ext1\n  rw [← of_real_rpow_of_nonneg (norm_nonneg _) _, ← coe_nnnorm, coe_nnreal_eq]\n  exact one_div_nonneg.mpr (by exact_mod_cast zero_le _)\n#align pow_norm_pow_one_div_tendsto_nhds_spectral_radius pow_norm_pow_one_div_tendsto_nhds_spectral_radius\n\n",
 "pow_nnnorm_pow_one_div_tendsto_nhds_spectral_radius":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/-- **Gelfand's formula**: Given an element `a : A` of a complex Banach algebra, the\n`spectral_radius` of `a` is the limit of the sequence `‖a ^ n‖₊ ^ (1 / n)` -/\ntheorem pow_nnnorm_pow_one_div_tendsto_nhds_spectral_radius (a : A) :\n    Tendsto (fun n : ℕ => («expr‖ ‖₊» (a ^ n) ^ (1 / n : exprℝ) : ennreal)) atTop\n      ((nhds) (spectral_radius (exprℂ) a)) :=\n  tendsto_of_le_liminf_of_limsup_le (spectral_radius_le_liminf_pow_nnnorm_pow_one_div (exprℂ) a)\n    (limsup_pow_nnnorm_pow_one_div_le_spectral_radius a)\n#align pow_nnnorm_pow_one_div_tendsto_nhds_spectral_radius pow_nnnorm_pow_one_div_tendsto_nhds_spectral_radius\n\n",
 "of_subsingleton":
 "/-\nCopyright (c) 2021 Jireh Loreaux. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Jireh Loreaux\n-/\n@[simp]\ntheorem spectral_radius.of_subsingleton [subsingleton A] (a : A) : spectral_radius 𝕜 a = 0 := by simp [spectral_radius]\n#align spectral_radius.of_subsingleton spectral_radius.of_subsingleton\n\n",
 "norm_resolvent_le_forall":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- TODO: Once there is sufficient API for bornology, we should get a nice filter / asymptotics\nversion of this, for example: `tendsto (resolvent a) (cobounded 𝕜) (𝓝 0)` or more specifically\n`(resolvent a) =O[cobounded 𝕜] (λ z, z⁻¹)`. -/\ntheorem norm_resolvent_le_forall (a : A) : ∀ ε > 0, ∃ R > 0, ∀ z : 𝕜, R ≤ «expr‖ ‖» z → «expr‖ ‖» (resolvent a z) ≤ ε :=\n  by\n  obtain ⟨c, c_pos, hc⟩ := (@NormedRing.inverse_one_sub_norm A _ _).exists_pos\n  rw [is_O_with_iff, eventually_iff, Metric.mem_nhds_iff] at hc\n  rcases hc with ⟨δ, δ_pos, hδ⟩\n  simp only [CstarRing.norm_one, mul_one] at hδ\n  intro ε hε\n  have ha₁ : 0 < «expr‖ ‖» a + 1 := lt_of_le_of_lt (norm_nonneg a) (lt_add_one _)\n  have min_pos : 0 < min (δ * («expr‖ ‖» a + 1)⁻¹) (ε * c⁻¹) :=\n    lt_min (mul_pos δ_pos (inv_pos.mpr ha₁)) (mul_pos hε (inv_pos.mpr c_pos))\n  refine' ⟨(min (δ * («expr‖ ‖» a + 1)⁻¹) (ε * c⁻¹))⁻¹, inv_pos.mpr min_pos, fun z hz => _⟩\n  have hnz : z ≠ 0 := norm_pos_iff.mp (lt_of_lt_of_le (inv_pos.mpr min_pos) hz)\n  replace hz := inv_le_of_inv_le min_pos hz\n  rcases(⟨Units.mk0 z hnz, Units.val_mk0 hnz⟩ : IsUnit z) with ⟨z, rfl⟩\n  have lt_δ : «expr‖ ‖» («expr • » z⁻¹ a) < δ :=\n    by\n    rw [Units.smul_def, norm_smul, Units.val_inv_eq_inv_val, norm_inv]\n    calc\n      («expr‖ ‖» (z : 𝕜))⁻¹ * «expr‖ ‖» a ≤ δ * («expr‖ ‖» a + 1)⁻¹ * «expr‖ ‖» a :=\n        mul_le_mul_of_nonneg_right (hz.trans (min_le_left _ _)) (norm_nonneg _)\n      _ < δ :=\n        by\n        conv =>\n          rw [mul_assoc]\n          rhs\n          rw [(mul_one δ).symm]\n        exact mul_lt_mul_of_pos_left ((inv_mul_lt_iff ha₁).mpr ((mul_one («expr‖ ‖» a + 1)).symm ▸ lt_add_one _)) δ_pos\n      \n  rw [← inv_smul_smul z (resolvent a (z : 𝕜)), units_smul_resolvent_self, resolvent, Algebra.algebraMap_eq_smul_one,\n    one_smul, Units.smul_def, norm_smul, Units.val_inv_eq_inv_val, norm_inv]\n  calc\n    _ ≤ ε * c⁻¹ * c :=\n      mul_le_mul (hz.trans (min_le_right _ _)) (hδ (mem_ball_zero_iff.mpr lt_δ)) (norm_nonneg _)\n        (mul_pos hε (inv_pos.mpr c_pos)).le\n    _ = _ := inv_mul_cancel_right₀ c_pos.ne.symm ε\n    \n#align norm_resolvent_le_forall norm_resolvent_le_forall\n\n",
 "norm_le_norm_of_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprσ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem norm_le_norm_of_mem [NormOneClass A] {a : A} {k : 𝕜} (hk : k ∈ (exprσ) a) : «expr‖ ‖» k ≤ «expr‖ ‖» a :=\n  le_of_not_lt <| mt mem_resolvent_set_of_norm_lt hk\n#align norm_le_norm_of_mem norm_le_norm_of_mem\n\n",
 "norm_le_norm_mul_of_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprσ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem norm_le_norm_mul_of_mem {a : A} {k : 𝕜} (hk : k ∈ (exprσ) a) : «expr‖ ‖» k ≤ «expr‖ ‖» a * «expr‖ ‖» (1 : A) :=\n  le_of_not_lt <| mt mem_resolvent_set_of_norm_lt_mul hk\n#align norm_le_norm_mul_of_mem norm_le_norm_mul_of_mem\n\n",
 "norm_apply_le_self_mul_norm_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem norm_apply_le_self_mul_norm_one [AlgHomClass F 𝕜 A 𝕜] (f : F) (a : A) :\n    «expr‖ ‖» (f a) ≤ «expr‖ ‖» a * «expr‖ ‖» (1 : A) :=\n  spectrum.norm_le_norm_mul_of_mem (apply_mem_spectrum f _)\n#align norm_apply_le_self_mul_norm_one norm_apply_le_self_mul_norm_one\n\n",
 "norm_apply_le_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem norm_apply_le_self [NormOneClass A] [AlgHomClass F 𝕜 A 𝕜] (f : F) (a : A) : «expr‖ ‖» (f a) ≤ «expr‖ ‖» a :=\n  spectrum.norm_le_norm_of_mem (apply_mem_spectrum f _)\n#align norm_apply_le_self norm_apply_le_self\n\n",
 "mem_resolvent_set_of_spectral_radius_lt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprρ -/\ntheorem mem_resolvent_set_of_spectral_radius_lt {a : A} {k : 𝕜} (h : spectral_radius 𝕜 a < «expr‖ ‖₊» k) :\n    k ∈ (exprρ) a :=\n  Classical.not_not.mp fun hn => h.not_le <| le_supᵢ₂ k hn\n#align mem_resolvent_set_of_spectral_radius_lt mem_resolvent_set_of_spectral_radius_lt\n\n",
 "mem_resolvent_set_of_norm_lt_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↑ₐ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprρ -/\ntheorem mem_resolvent_set_of_norm_lt_mul {a : A} {k : 𝕜} (h : «expr‖ ‖» a * «expr‖ ‖» (1 : A) < «expr‖ ‖» k) :\n    k ∈ (exprρ) a := by\n  rw [resolvent_set, Set.mem_setOf_eq, Algebra.algebraMap_eq_smul_one]\n  nontriviality A\n  have hk : k ≠ 0 := ne_zero_of_norm_ne_zero ((mul_nonneg (norm_nonneg _) (norm_nonneg _)).trans_lt h).ne'\n  let ku := Units.map («expr↑ₐ»).to_monoid_hom (Units.mk0 k hk)\n  rw [← inv_inv («expr‖ ‖» (1 : A)), mul_inv_lt_iff (inv_pos.2 <| norm_pos_iff.2 (one_ne_zero : (1 : A) ≠ 0))] at h\n  have hku : «expr‖ ‖» (-a) < («expr‖ ‖» (↑ku⁻¹ : A))⁻¹ := by simpa [ku, norm_algebraMap] using h\n  simpa [ku, sub_eq_add_neg, Algebra.algebraMap_eq_smul_one] using (ku.add (-a) hku).is_unit\n#align mem_resolvent_set_of_norm_lt_mul mem_resolvent_set_of_norm_lt_mul\n\n",
 "mem_resolvent_set_of_norm_lt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprρ -/\ntheorem mem_resolvent_set_of_norm_lt [NormOneClass A] {a : A} {k : 𝕜} (h : «expr‖ ‖» a < «expr‖ ‖» k) : k ∈ (exprρ) a :=\n  mem_resolvent_set_of_norm_lt_mul (by rwa [norm_one, mul_one])\n#align mem_resolvent_set_of_norm_lt mem_resolvent_set_of_norm_lt\n\n",
 "map_pow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n#print map_pow /-\n/-- A specialization of the spectral mapping theorem for polynomials in a Banach algebra over `ℂ`\nto monic monomials. -/\nprotected theorem map_pow (n : ℕ) : spectrum (exprℂ) (a ^ n) = «expr '' » (fun x => x ^ n) (spectrum (exprℂ) a) := by\n  simpa only [aeval_X_pow, eval_pow, eval_X] using map_polynomial_aeval a (X ^ n)\n#align map_pow map_pow\n-/\n\n",
 "map_polynomial_aeval":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/-- The **spectral mapping theorem** for polynomials in a Banach algebra over `ℂ`. -/\ntheorem map_polynomial_aeval (p : polynomial (exprℂ)) :\n    spectrum (exprℂ) (aeval a p) = «expr '' » (fun k => eval k p) (spectrum (exprℂ) a) :=\n  map_polynomial_aeval_of_nonempty a p (spectrum.nonempty a)\n#align map_polynomial_aeval map_polynomial_aeval\n\n",
 "limsup_pow_nnnorm_pow_one_div_le_spectral_radius":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/-- The `limsup` relationship for the spectral radius used to prove `spectrum.gelfand_formula`. -/\ntheorem limsup_pow_nnnorm_pow_one_div_le_spectral_radius (a : A) :\n    limsup (fun n : ℕ => ↑(«expr‖ ‖₊» (a ^ n)) ^ (1 / n : exprℝ)) atTop ≤ spectral_radius (exprℂ) a :=\n  by\n  refine' ennreal.inv_le_inv.mp (le_of_forall_pos_nnreal_lt fun r r_pos r_lt => _)\n  simp_rw [inv_limsup, ← one_div]\n  let p : formal_multilinear_series (exprℂ) (exprℂ) A := fun n =>\n    continuous_multilinear_map.mk_pi_field (exprℂ) (Fin n) (a ^ n)\n  suffices h : (r : ennreal) ≤ p.radius\n  · convert h\n    simp only [p.radius_eq_liminf, ← norm_toNNReal, norm_mk_pi_field]\n    congr\n    ext n\n    rw [norm_toNNReal, ennreal.coe_rpow_def («expr‖ ‖₊» (a ^ n)) (1 / n : exprℝ), if_neg]\n    exact fun ha => by linarith [ha.2, (one_div_nonneg.mpr n.cast_nonneg : 0 ≤ (1 / n : exprℝ))]\n  · have H₁ := (differentiable_on_inverse_one_sub_smul r_lt).has_fpower_series_on_ball r_pos\n    exact ((has_fpower_series_on_ball_inverse_one_sub_smul (exprℂ) a).exchange_radius H₁).r_le\n#align limsup_pow_nnnorm_pow_one_div_le_spectral_radius limsup_pow_nnnorm_pow_one_div_le_spectral_radius\n\n",
 "is_unit_one_sub_smul_of_lt_inv_radius":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem is_unit_one_sub_smul_of_lt_inv_radius {a : A} {z : 𝕜} (h : ↑(«expr‖ ‖₊» z) < (spectral_radius 𝕜 a)⁻¹) :\n    IsUnit (1 - «expr • » z a) := by\n  by_cases hz : z = 0\n  · simp only [hz, isUnit_one, sub_zero, zero_smul]\n  · let u := Units.mk0 z hz\n    suffices hu : IsUnit («expr • » u⁻¹ 1 - a)\n    · rwa [IsUnit.smul_sub_iff_sub_inv_smul, inv_inv u] at hu\n    · rw [Units.smul_def, ← Algebra.algebraMap_eq_smul_one, ← mem_resolvent_set_iff]\n      refine' mem_resolvent_set_of_spectral_radius_lt _\n      rwa [Units.val_inv_eq_inv_val, nnnorm_inv, coe_inv (nnnorm_ne_zero_iff.mpr (Units.val_mk0 hz ▸ hz : (u : 𝕜) ≠ 0)),\n        lt_inv_iff_lt_inv]\n#align is_unit_one_sub_smul_of_lt_inv_radius is_unit_one_sub_smul_of_lt_inv_radius\n\n",
 "is_open_resolvent_set":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprρ -/\ntheorem is_open_resolvent_set (a : A) : IsOpen ((exprρ) a) :=\n  Units.isOpen.preimage ((continuous_algebraMap 𝕜 A).sub continuous_const)\n#align is_open_resolvent_set is_open_resolvent_set\n\n",
 "is_bounded":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprσ -/\ntheorem is_bounded (a : A) : Metric.Bounded ((exprσ) a) :=\n  (Metric.bounded_iff_subset_ball 0).mpr ⟨«expr‖ ‖» a * «expr‖ ‖» (1 : A), subset_closed_ball_norm_mul a⟩\n#align is_bounded is_bounded\n\n",
 "has_fpower_series_on_ball_inverse_one_sub_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/-- In a Banach algebra `A` over a nontrivially normed field `𝕜`, for any `a : A` the\npower series with coefficients `a ^ n` represents the function `(1 - z • a)⁻¹` in a disk of\nradius `‖a‖₊⁻¹`. -/\ntheorem has_fpower_series_on_ball_inverse_one_sub_smul [CompleteSpace A] (a : A) :\n    has_fpower_series_on_ball (fun z : 𝕜 => Ring.inverse (1 - «expr • » z a))\n      (fun n => continuous_multilinear_map.mk_pi_field 𝕜 (Fin n) (a ^ n)) 0 («expr‖ ‖₊» a)⁻¹ :=\n  { r_le :=\n      by\n      refine' le_of_forall_nnreal_lt fun r hr => le_radius_of_bound_nnreal _ (max 1 («expr‖ ‖₊» (1 : A))) fun n => _\n      rw [← norm_toNNReal, norm_mk_pi_field, norm_toNNReal]\n      cases n\n      · simp only [le_refl, mul_one, or_true_iff, le_max_iff, pow_zero]\n      · refine' le_trans (le_trans (mul_le_mul_right' (nnnorm_pow_le' a n.succ_pos) (r ^ n.succ)) _) (le_max_left _ _)\n        · by_cases «expr‖ ‖₊» a = 0\n          · simp only [h, MulZeroClass.zero_mul, zero_le', pow_succ]\n          · rw [← coe_inv h, coe_lt_coe, NNReal.lt_inv_iff_mul_lt h] at hr\n            simpa only [← mul_pow, mul_comm] using pow_le_one' hr.le n.succ\n    r_pos := ENNReal.inv_pos.mpr coe_ne_top\n    has_sum := fun y hy =>\n      by\n      have norm_lt : «expr‖ ‖» («expr • » y a) < 1 :=\n        by\n        by_cases h : «expr‖ ‖₊» a = 0\n        · simp only [nnnorm_eq_zero.mp h, norm_zero, zero_lt_one, smul_zero]\n        · have nnnorm_lt : «expr‖ ‖₊» y < («expr‖ ‖₊» a)⁻¹ := by\n            simpa only [← coe_inv h, mem_ball_zero_iff, Metric.emetric_ball_nnreal] using hy\n          rwa [← coe_nnnorm, ← Real.lt_toNNReal_iff_coe_lt, Real.toNNReal_one, nnnorm_smul, ←\n            NNReal.lt_inv_iff_mul_lt h]\n      simpa [← smul_pow, (NormedRing.summable_geometric_of_norm_lt_1 _ norm_lt).has_sum_iff] using\n        (NormedRing.inverse_one_sub _ norm_lt).symm }\n#align has_fpower_series_on_ball_inverse_one_sub_smul has_fpower_series_on_ball_inverse_one_sub_smul\n\n",
 "has_deriv_at_resolvent":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↑ₐ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↑ₐ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprρ -/\ntheorem has_deriv_at_resolvent {a : A} {k : 𝕜} (hk : k ∈ (exprρ) a) :\n    has_deriv_at (resolvent a) (-resolvent a k ^ 2) k :=\n  by\n  have H₁ : has_fderiv_at Ring.inverse _ ((«expr↑ₐ») k - a) := has_fderiv_at_ring_inverse hk.unit\n  have H₂ : has_deriv_at (fun k => («expr↑ₐ») k - a) 1 k := by\n    simpa using (Algebra.linearMap 𝕜 A).has_deriv_at.sub_const a\n  simpa [resolvent, sq, hk.unit_spec, ← Ring.inverse_unit hk.unit] using H₁.comp_has_deriv_at k H₂\n#align has_deriv_at_resolvent has_deriv_at_resolvent\n\n",
 "exp_mem_exp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↑ₐ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↑ₐ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↑ₐ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↑ₐ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↑ₐ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↑ₐ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↑ₐ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↑ₐ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↑ₐ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↑ₐ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↑ₐ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↑ₐ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↑ₐ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↑ₐ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↑ₐ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↑ₐ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↑ₐ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↑ₐ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↑ₐ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↑ₐ» -/\n/-- For `𝕜 = ℝ` or `𝕜 = ℂ`, `exp 𝕜` maps the spectrum of `a` into the spectrum of `exp 𝕜 a`. -/\ntheorem exp_mem_exp [IsROrC 𝕜] [NormedRing A] [NormedAlgebra 𝕜 A] [CompleteSpace A] (a : A) {z : 𝕜}\n    (hz : z ∈ spectrum 𝕜 a) : exp 𝕜 z ∈ spectrum 𝕜 (exp 𝕜 a) :=\n  by\n  have hexpmul : exp 𝕜 a = exp 𝕜 (a - («expr↑ₐ») z) * («expr↑ₐ») (exp 𝕜 z) := by\n    rw [algebra_map_exp_comm z, ← exp_add_of_commute (Algebra.commutes z (a - («expr↑ₐ») z)).symm, sub_add_cancel]\n  let b :=\n    «expr∑' , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , »\"\n      («expr • » ((n + 1).factorial⁻¹ : 𝕜) ((a - («expr↑ₐ») z) ^ n))\n  have hb : Summable fun n : ℕ => «expr • » ((n + 1).factorial⁻¹ : 𝕜) ((a - («expr↑ₐ») z) ^ n) :=\n    by\n    refine' summable_of_norm_bounded_eventually _ (Real.summable_pow_div_factorial («expr‖ ‖» (a - («expr↑ₐ») z))) _\n    filter_upwards [Filter.eventually_cofinite_ne 0]with n hn\n    rw [norm_smul, mul_comm, norm_inv, is_R_or_C.norm_eq_abs, is_R_or_C.abs_cast_nat, ← div_eq_mul_inv]\n    exact\n      div_le_div (pow_nonneg (norm_nonneg _) n) (norm_pow_le' (a - («expr↑ₐ») z) (zero_lt_iff.mpr hn))\n        (by exact_mod_cast Nat.factorial_pos n) (by exact_mod_cast Nat.factorial_le (lt_add_one n).le)\n  have h₀ :\n    «expr∑' , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , »\"\n        («expr • » ((n + 1).factorial⁻¹ : 𝕜) ((a - («expr↑ₐ») z) ^ (n + 1))) =\n      (a - («expr↑ₐ») z) * b :=\n    by simpa only [mul_smul_comm, pow_succ] using hb.tsum_mul_left (a - («expr↑ₐ») z)\n  have h₁ :\n    «expr∑' , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , »\"\n        («expr • » ((n + 1).factorial⁻¹ : 𝕜) ((a - («expr↑ₐ») z) ^ (n + 1))) =\n      b * (a - («expr↑ₐ») z) :=\n    by simpa only [pow_succ', Algebra.smul_mul_assoc] using hb.tsum_mul_right (a - («expr↑ₐ») z)\n  have h₃ : exp 𝕜 (a - («expr↑ₐ») z) = 1 + (a - («expr↑ₐ») z) * b :=\n    by\n    rw [exp_eq_tsum]\n    convert tsum_eq_zero_add (exp_series_summable' (a - («expr↑ₐ») z))\n    simp only [Nat.factorial_zero, Nat.cast_one, inv_one, pow_zero, one_smul]\n    exact h₀.symm\n  rw [spectrum.mem_iff, IsUnit.sub_iff, ← one_mul ((«expr↑ₐ») (exp 𝕜 z)), hexpmul, ← _root_.sub_mul,\n    Commute.isUnit_mul_iff (Algebra.commutes (exp 𝕜 z) (exp 𝕜 (a - («expr↑ₐ») z) - 1)).symm, sub_eq_iff_eq_add'.mpr h₃,\n    Commute.isUnit_mul_iff (h₀ ▸ h₁ : (a - («expr↑ₐ») z) * b = b * (a - («expr↑ₐ») z))]\n  exact not_and_of_not_left _ (not_and_of_not_left _ ((not_iff_not.mpr IsUnit.sub_iff).mp hz))\n#align exp_mem_exp exp_mem_exp\n\n",
 "exists_nnnorm_eq_spectral_radius_of_nonempty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprσ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprσ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\ntheorem exists_nnnorm_eq_spectral_radius_of_nonempty [ProperSpace 𝕜] {a : A} (ha : ((exprσ) a).nonempty) :\n    ∃ k ∈ (exprσ) a, («expr‖ ‖₊» k : ennreal) = spectral_radius 𝕜 a :=\n  by\n  obtain ⟨k, hk, h⟩ := (spectrum.is_compact a).exists_forall_ge ha continuous_nnnorm.continuous_on\n  exact ⟨k, hk, le_antisymm (le_supᵢ₂ k hk) (supᵢ₂_le <| by exact_mod_cast h)⟩\n#align exists_nnnorm_eq_spectral_radius_of_nonempty exists_nnnorm_eq_spectral_radius_of_nonempty\n\n",
 "exists_nnnorm_eq_spectral_radius":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/-- In a complex Banach algebra, the spectral radius is always attained by some element of the\nspectrum. -/\ntheorem exists_nnnorm_eq_spectral_radius :\n    ∃ z ∈ spectrum (exprℂ) a, («expr‖ ‖₊» z : ennreal) = spectral_radius (exprℂ) a :=\n  exists_nnnorm_eq_spectral_radius_of_nonempty (spectrum.nonempty a)\n#align exists_nnnorm_eq_spectral_radius exists_nnnorm_eq_spectral_radius\n\n",
 "equiv_alg_hom_symm_coe":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n@[simp]\ntheorem equiv_alg_hom_symm_coe (f : «expr →ₐ[ ] » A 𝕜 𝕜) : «expr⇑ » (equiv_alg_hom.symm f) = f :=\n  rfl\n#align equiv_alg_hom_symm_coe equiv_alg_hom_symm_coe\n\n",
 "equiv_alg_hom_coe":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n@[simp]\ntheorem equiv_alg_hom_coe (f : character_space 𝕜 A) : «expr⇑ » (equiv_alg_hom f) = f :=\n  rfl\n#align equiv_alg_hom_coe equiv_alg_hom_coe\n\n",
 "differentiable_on_inverse_one_sub_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- In a Banach algebra `A` over `𝕜`, for `a : A` the function `λ z, (1 - z • a)⁻¹` is\ndifferentiable on any closed ball centered at zero of radius `r < (spectral_radius 𝕜 a)⁻¹`. -/\ntheorem differentiable_on_inverse_one_sub_smul [CompleteSpace A] {a : A} {r : nnreal}\n    (hr : (r : ennreal) < (spectral_radius 𝕜 a)⁻¹) :\n    differentiable_on 𝕜 (fun z : 𝕜 => Ring.inverse (1 - «expr • » z a)) (Metric.closedBall 0 r) :=\n  by\n  intro z z_mem\n  apply differentiable_at.differentiable_within_at\n  have hu : IsUnit (1 - «expr • » z a) :=\n    by\n    refine' is_unit_one_sub_smul_of_lt_inv_radius (lt_of_le_of_lt (coe_mono _) hr)\n    simpa only [norm_toNNReal, Real.toNNReal_coe] using Real.toNNReal_mono (mem_closed_ball_zero_iff.mp z_mem)\n  have H₁ : differentiable 𝕜 fun w : 𝕜 => 1 - «expr • » w a := (differentiable_id.smul_const a).const_sub 1\n  exact differentiable_at.comp z (differentiable_at_inverse hu.unit) H₁.differentiable_at\n#align differentiable_on_inverse_one_sub_smul differentiable_on_inverse_one_sub_smul\n\n",
 "coe_to_continuous_linear_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n@[simp]\ntheorem coe_to_continuous_linear_map (φ : «expr →ₐ[ ] » A 𝕜 𝕜) : «expr⇑ » φ.to_continuous_linear_map = φ :=\n  rfl\n#align coe_to_continuous_linear_map coe_to_continuous_linear_map\n\n",
 "algebra_map_eq_of_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprσ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\ntheorem algebra_map_eq_of_mem {a : A} {z : exprℂ} (h : z ∈ (exprσ) a) : algebraMap (exprℂ) A z = a := by\n  rwa [mem_iff, hA, Classical.not_not, sub_eq_zero] at h\n#align algebra_map_eq_of_mem algebra_map_eq_of_mem\n\n",
 "Nonempty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n#print Nonempty /-\n/-- In a (nontrivial) complex Banach algebra, every element has nonempty spectrum. -/\nprotected theorem Nonempty : (spectrum (exprℂ) a).nonempty :=\n  by\n  /- Suppose `σ a = ∅`, then resolvent set is `ℂ`, any `(z • 1 - a)` is a unit, and `resolvent`\n    is differentiable on `ℂ`. -/\n  rw [Set.nonempty_iff_ne_empty]\n  by_contra h\n  have H₀ : resolvent_set (exprℂ) a = Set.univ := by rwa [spectrum, Set.compl_empty_iff] at h\n  have H₁ : differentiable (exprℂ) fun z : exprℂ => resolvent a z := fun z =>\n    (has_deriv_at_resolvent (H₀.symm ▸ Set.mem_univ z : z ∈ resolvent_set (exprℂ) a)).differentiable_at\n  /- The norm of the resolvent is small for all sufficently large `z`, and by compactness and\n    continuity it is bounded on the complement of a large ball, thus uniformly bounded on `ℂ`.\n    By Liouville's theorem `λ z, resolvent a z` is constant -/\n  have H₂ := norm_resolvent_le_forall a\n  have H₃ : ∀ z : exprℂ, resolvent a z = resolvent a (0 : exprℂ) :=\n    by\n    refine' fun z => H₁.apply_eq_apply_of_bounded (bounded_iff_forall_norm_le.mpr _) z 0\n    rcases H₂ 1 zero_lt_one with ⟨R, R_pos, hR⟩\n    rcases(proper_space.is_compact_closed_ball (0 : exprℂ) R).exists_bound_of_continuous_on\n        H₁.continuous.continuous_on with\n      ⟨C, hC⟩\n    use max C 1\n    rintro _ ⟨w, rfl⟩\n    refine' or.elim (em («expr‖ ‖» w ≤ R)) (fun hw => _) fun hw => _\n    · exact (hC w (mem_closed_ball_zero_iff.mpr hw)).trans (le_max_left _ _)\n    · exact (hR w (not_le.mp hw).le).trans (le_max_right _ _)\n  -- `resolvent a 0 = 0`, which is a contradition because it isn't a unit.\n  have H₅ : resolvent a (0 : exprℂ) = 0 :=\n    by\n    refine' norm_eq_zero.mp (le_antisymm (le_of_forall_pos_le_add fun ε hε => _) (norm_nonneg _))\n    rcases H₂ ε hε with ⟨R, R_pos, hR⟩\n    simpa only [H₃ R] using (zero_add ε).symm.subst (hR R (by exact_mod_cast (Real.norm_of_nonneg R_pos.lt.le).symm.le))\n  -- `not_is_unit_zero` is where we need `nontrivial A`, it is unavoidable.\n  exact not_isUnit_zero (H₅.subst (is_unit_resolvent.mp (mem_resolvent_set_iff.mp (H₀.symm ▸ Set.mem_univ 0))))\n#align nonempty Nonempty\n-/\n\n",
 "IsCompact":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprσ -/\n#print IsCompact /-\nprotected theorem IsCompact [ProperSpace 𝕜] (a : A) : IsCompact ((exprσ) a) :=\n  Metric.isCompact_of_isClosed_bounded (spectrum.is_closed a) (is_bounded a)\n#align is_compact IsCompact\n-/\n\n",
 "IsClosed":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprσ -/\n#print IsClosed /-\nprotected theorem IsClosed (a : A) : IsClosed ((exprσ) a) :=\n  (is_open_resolvent_set a).is_closed_compl\n#align is_closed IsClosed\n-/\n\n"}