{"to_continuous_linear_map_norm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n@[simp]\ntheorem to_continuous_linear_map_norm [NormOneClass A] (Ï† : Â«expr â†’â‚[ ] Â» A ğ•œ ğ•œ) :\n    Â«exprâ€– â€–Â» Ï†.to_continuous_linear_map = 1 :=\n  continuous_linear_map.op_norm_eq_of_bounds zero_le_one\n    (fun a => (one_mul (Â«exprâ€– â€–Â» a)).symm â–¸ spectrum.norm_le_norm_of_mem (apply_mem_spectrum Ï† _)) fun _ _ h => by\n    simpa only [coe_to_continuous_linear_map, map_one, norm_one, mul_one] using h 1\n#align to_continuous_linear_map_norm to_continuous_linear_map_norm\n\n",
 "subset_closed_ball_norm_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprÏƒ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\ntheorem subset_closed_ball_norm_mul (a : A) : (exprÏƒ) a âŠ† Metric.closedBall (0 : ğ•œ) (Â«exprâ€– â€–Â» a * Â«exprâ€– â€–Â» (1 : A)) :=\n  fun k hk => by simp [norm_le_norm_mul_of_mem hk]\n#align subset_closed_ball_norm_mul subset_closed_ball_norm_mul\n\n",
 "subset_closed_ball_norm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprÏƒ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\ntheorem subset_closed_ball_norm [NormOneClass A] (a : A) : (exprÏƒ) a âŠ† Metric.closedBall (0 : ğ•œ) (Â«exprâ€– â€–Â» a) :=\n  fun k hk => by simp [norm_le_norm_of_mem hk]\n#align subset_closed_ball_norm subset_closed_ball_norm\n\n",
 "spectral_radius_zero":
 "@[simp]\ntheorem spectral_radius_zero : spectral_radius ğ•œ (0 : A) = 0 :=\n  by\n  nontriviality A\n  simp [spectral_radius]\n#align spectral_radius_zero spectral_radius_zero\n\n",
 "spectral_radius_lt_of_forall_lt_of_nonempty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprÏƒ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprÏƒ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–â‚ŠÂ» -/\ntheorem spectral_radius_lt_of_forall_lt_of_nonempty [ProperSpace ğ•œ] {a : A} (ha : ((exprÏƒ) a).nonempty) {r : nnreal}\n    (hr : âˆ€ k âˆˆ (exprÏƒ) a, Â«exprâ€– â€–â‚ŠÂ» k < r) : spectral_radius ğ•œ a < r :=\n  supâ‚›_image.symm.trans_lt <|\n    ((spectrum.is_compact a).Sup_lt_iff_of_continuous ha (ENNReal.continuous_coe.comp continuous_nnnorm).continuous_on\n          (r : ennreal)).mpr\n      (by exact_mod_cast hr)\n#align spectral_radius_lt_of_forall_lt_of_nonempty spectral_radius_lt_of_forall_lt_of_nonempty\n\n",
 "spectral_radius_lt_of_forall_lt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„‚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–â‚ŠÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„‚ -/\n/-- In a complex Banach algebra, if every element of the spectrum has norm strictly less than\n`r : â„â‰¥0`, then the spectral radius is also strictly less than `r`. -/\ntheorem spectral_radius_lt_of_forall_lt {r : nnreal} (hr : âˆ€ z âˆˆ spectrum (exprâ„‚) a, Â«exprâ€– â€–â‚ŠÂ» z < r) :\n    spectral_radius (exprâ„‚) a < r :=\n  spectral_radius_lt_of_forall_lt_of_nonempty (spectrum.nonempty a) hr\n#align spectral_radius_lt_of_forall_lt spectral_radius_lt_of_forall_lt\n\n",
 "spectral_radius_le_pow_nnnorm_pow_one_div":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprÏƒ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–â‚ŠÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–â‚ŠÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–â‚ŠÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–â‚ŠÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–â‚ŠÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\ntheorem spectral_radius_le_pow_nnnorm_pow_one_div (a : A) (n : â„•) :\n    spectral_radius ğ•œ a â‰¤\n      Â«exprâ€– â€–â‚ŠÂ» (a ^ (n + 1)) ^ (1 / (n + 1) : exprâ„) * Â«exprâ€– â€–â‚ŠÂ» (1 : A) ^ (1 / (n + 1) : exprâ„) :=\n  by\n  refine' supáµ¢â‚‚_le fun k hk => _\n  -- apply easy direction of the spectral mapping theorem for polynomials\n  have pow_mem : k ^ (n + 1) âˆˆ (exprÏƒ) (a ^ (n + 1)) := by\n    simpa only [one_mul, Algebra.algebraMap_eq_smul_one, one_smul, aeval_monomial, one_mul, eval_monomial] using\n      subset_polynomial_aeval a (monomial (n + 1) (1 : ğ•œ)) âŸ¨k, hk, rflâŸ©\n  -- power of the norm is bounded by norm of the power\n  have nnnorm_pow_le : (â†‘(Â«exprâ€– â€–â‚ŠÂ» k ^ (n + 1)) : ennreal) â‰¤ Â«exprâ€– â€–â‚ŠÂ» (a ^ (n + 1)) * Â«exprâ€– â€–â‚ŠÂ» (1 : A) := by\n    simpa only [Real.toNNReal_mul (norm_nonneg _), norm_toNNReal, nnnorm_pow k (n + 1), ENNReal.coe_mul] using\n      coe_mono (Real.toNNReal_mono (norm_le_norm_mul_of_mem pow_mem))\n  -- take (n + 1)áµ—Ê° roots and clean up the left-hand side\n  have hn : 0 < ((n + 1 : â„•) : exprâ„) := by exact_mod_cast Nat.succ_pos'\n  convert monotone_rpow_of_nonneg (one_div_pos.mpr hn).le nnnorm_pow_le\n  erw [coe_pow, â† rpow_nat_cast, â† rpow_mul, mul_one_div_cancel hn.ne', rpow_one]\n  rw [Nat.cast_succ, ennreal.coe_mul_rpow]\n#align spectral_radius_le_pow_nnnorm_pow_one_div spectral_radius_le_pow_nnnorm_pow_one_div\n\n",
 "spectral_radius_le_nnnorm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–â‚ŠÂ» -/\ntheorem spectral_radius_le_nnnorm [NormOneClass A] (a : A) : spectral_radius ğ•œ a â‰¤ Â«exprâ€– â€–â‚ŠÂ» a :=\n  by\n  refine' supáµ¢â‚‚_le fun k hk => _\n  exact_mod_cast norm_le_norm_of_mem hk\n#align spectral_radius_le_nnnorm spectral_radius_le_nnnorm\n\n",
 "spectral_radius_le_liminf_pow_nnnorm_pow_one_div":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–â‚ŠÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–â‚ŠÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\ntheorem spectral_radius_le_liminf_pow_nnnorm_pow_one_div (a : A) :\n    spectral_radius ğ•œ a â‰¤ atTop.liminf fun n : â„• => (Â«exprâ€– â€–â‚ŠÂ» (a ^ n) : ennreal) ^ (1 / n : exprâ„) :=\n  by\n  refine' ENNReal.le_of_forall_lt_one_mul_le fun Îµ hÎµ => _\n  by_cases Îµ = 0\n  Â· simp only [h, MulZeroClass.zero_mul, zero_le']\n  have hÎµ' : Îµâ»Â¹ â‰  ennreal.top := fun h' =>\n    h (by simpa only [inv_inv, inv_top] using congr_arg (fun x : ennreal => xâ»Â¹) h')\n  simp only [ENNReal.mul_le_iff_le_inv h (hÎµ.trans_le le_top).ne, mul_comm Îµâ»Â¹, liminf_eq_supr_infi_of_nat',\n    ENNReal.supáµ¢_mul, ENNReal.infáµ¢_mul hÎµ']\n  rw [â† ENNReal.inv_lt_inv, inv_one] at hÎµ\n  obtain âŸ¨N, hNâŸ© :=\n    eventually_at_top.mp\n      (ennreal.eventually_pow_one_div_le (ENNReal.coe_ne_top : â†‘(Â«exprâ€– â€–â‚ŠÂ» (1 : A)) â‰  ennreal.top) hÎµ)\n  refine' le_trans _ (le_supáµ¢ _ (N + 1))\n  refine' le_infáµ¢ fun n => _\n  simp only [â† add_assoc]\n  refine' (spectral_radius_le_pow_nnnorm_pow_one_div ğ•œ a (n + N)).trans _\n  norm_cast\n  exact mul_le_mul_left' (hN (n + N + 1) (by linarith)) _\n#align spectral_radius_le_liminf_pow_nnnorm_pow_one_div spectral_radius_le_liminf_pow_nnnorm_pow_one_div\n\n",
 "pow_norm_pow_one_div_tendsto_nhds_spectral_radius":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„‚ -/\n/- This is the same as `pow_nnnorm_pow_one_div_tendsto_nhds_spectral_radius` but for `norm`\ninstead of `nnnorm`. -/\n/-- **Gelfand's formula**: Given an element `a : A` of a complex Banach algebra, the\n`spectral_radius` of `a` is the limit of the sequence `â€–a ^ nâ€–â‚Š ^ (1 / n)` -/\ntheorem pow_norm_pow_one_div_tendsto_nhds_spectral_radius (a : A) :\n    Tendsto (fun n : â„• => ENNReal.ofReal (Â«exprâ€– â€–Â» (a ^ n) ^ (1 / n : exprâ„))) atTop\n      ((nhds) (spectral_radius (exprâ„‚) a)) :=\n  by\n  convert pow_nnnorm_pow_one_div_tendsto_nhds_spectral_radius a\n  ext1\n  rw [â† of_real_rpow_of_nonneg (norm_nonneg _) _, â† coe_nnnorm, coe_nnreal_eq]\n  exact one_div_nonneg.mpr (by exact_mod_cast zero_le _)\n#align pow_norm_pow_one_div_tendsto_nhds_spectral_radius pow_norm_pow_one_div_tendsto_nhds_spectral_radius\n\n",
 "pow_nnnorm_pow_one_div_tendsto_nhds_spectral_radius":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„‚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–â‚ŠÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„‚ -/\n/-- **Gelfand's formula**: Given an element `a : A` of a complex Banach algebra, the\n`spectral_radius` of `a` is the limit of the sequence `â€–a ^ nâ€–â‚Š ^ (1 / n)` -/\ntheorem pow_nnnorm_pow_one_div_tendsto_nhds_spectral_radius (a : A) :\n    Tendsto (fun n : â„• => (Â«exprâ€– â€–â‚ŠÂ» (a ^ n) ^ (1 / n : exprâ„) : ennreal)) atTop\n      ((nhds) (spectral_radius (exprâ„‚) a)) :=\n  tendsto_of_le_liminf_of_limsup_le (spectral_radius_le_liminf_pow_nnnorm_pow_one_div (exprâ„‚) a)\n    (limsup_pow_nnnorm_pow_one_div_le_spectral_radius a)\n#align pow_nnnorm_pow_one_div_tendsto_nhds_spectral_radius pow_nnnorm_pow_one_div_tendsto_nhds_spectral_radius\n\n",
 "of_subsingleton":
 "/-\nCopyright (c) 2021 Jireh Loreaux. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Jireh Loreaux\n-/\n@[simp]\ntheorem spectral_radius.of_subsingleton [subsingleton A] (a : A) : spectral_radius ğ•œ a = 0 := by simp [spectral_radius]\n#align spectral_radius.of_subsingleton spectral_radius.of_subsingleton\n\n",
 "norm_resolvent_le_forall":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- TODO: Once there is sufficient API for bornology, we should get a nice filter / asymptotics\nversion of this, for example: `tendsto (resolvent a) (cobounded ğ•œ) (ğ“ 0)` or more specifically\n`(resolvent a) =O[cobounded ğ•œ] (Î» z, zâ»Â¹)`. -/\ntheorem norm_resolvent_le_forall (a : A) : âˆ€ Îµ > 0, âˆƒ R > 0, âˆ€ z : ğ•œ, R â‰¤ Â«exprâ€– â€–Â» z â†’ Â«exprâ€– â€–Â» (resolvent a z) â‰¤ Îµ :=\n  by\n  obtain âŸ¨c, c_pos, hcâŸ© := (@NormedRing.inverse_one_sub_norm A _ _).exists_pos\n  rw [is_O_with_iff, eventually_iff, Metric.mem_nhds_iff] at hc\n  rcases hc with âŸ¨Î´, Î´_pos, hÎ´âŸ©\n  simp only [CstarRing.norm_one, mul_one] at hÎ´\n  intro Îµ hÎµ\n  have haâ‚ : 0 < Â«exprâ€– â€–Â» a + 1 := lt_of_le_of_lt (norm_nonneg a) (lt_add_one _)\n  have min_pos : 0 < min (Î´ * (Â«exprâ€– â€–Â» a + 1)â»Â¹) (Îµ * câ»Â¹) :=\n    lt_min (mul_pos Î´_pos (inv_pos.mpr haâ‚)) (mul_pos hÎµ (inv_pos.mpr c_pos))\n  refine' âŸ¨(min (Î´ * (Â«exprâ€– â€–Â» a + 1)â»Â¹) (Îµ * câ»Â¹))â»Â¹, inv_pos.mpr min_pos, fun z hz => _âŸ©\n  have hnz : z â‰  0 := norm_pos_iff.mp (lt_of_lt_of_le (inv_pos.mpr min_pos) hz)\n  replace hz := inv_le_of_inv_le min_pos hz\n  rcases(âŸ¨Units.mk0 z hnz, Units.val_mk0 hnzâŸ© : IsUnit z) with âŸ¨z, rflâŸ©\n  have lt_Î´ : Â«exprâ€– â€–Â» (Â«expr â€¢ Â» zâ»Â¹ a) < Î´ :=\n    by\n    rw [Units.smul_def, norm_smul, Units.val_inv_eq_inv_val, norm_inv]\n    calc\n      (Â«exprâ€– â€–Â» (z : ğ•œ))â»Â¹ * Â«exprâ€– â€–Â» a â‰¤ Î´ * (Â«exprâ€– â€–Â» a + 1)â»Â¹ * Â«exprâ€– â€–Â» a :=\n        mul_le_mul_of_nonneg_right (hz.trans (min_le_left _ _)) (norm_nonneg _)\n      _ < Î´ :=\n        by\n        conv =>\n          rw [mul_assoc]\n          rhs\n          rw [(mul_one Î´).symm]\n        exact mul_lt_mul_of_pos_left ((inv_mul_lt_iff haâ‚).mpr ((mul_one (Â«exprâ€– â€–Â» a + 1)).symm â–¸ lt_add_one _)) Î´_pos\n      \n  rw [â† inv_smul_smul z (resolvent a (z : ğ•œ)), units_smul_resolvent_self, resolvent, Algebra.algebraMap_eq_smul_one,\n    one_smul, Units.smul_def, norm_smul, Units.val_inv_eq_inv_val, norm_inv]\n  calc\n    _ â‰¤ Îµ * câ»Â¹ * c :=\n      mul_le_mul (hz.trans (min_le_right _ _)) (hÎ´ (mem_ball_zero_iff.mpr lt_Î´)) (norm_nonneg _)\n        (mul_pos hÎµ (inv_pos.mpr c_pos)).le\n    _ = _ := inv_mul_cancel_rightâ‚€ c_pos.ne.symm Îµ\n    \n#align norm_resolvent_le_forall norm_resolvent_le_forall\n\n",
 "norm_le_norm_of_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprÏƒ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\ntheorem norm_le_norm_of_mem [NormOneClass A] {a : A} {k : ğ•œ} (hk : k âˆˆ (exprÏƒ) a) : Â«exprâ€– â€–Â» k â‰¤ Â«exprâ€– â€–Â» a :=\n  le_of_not_lt <| mt mem_resolvent_set_of_norm_lt hk\n#align norm_le_norm_of_mem norm_le_norm_of_mem\n\n",
 "norm_le_norm_mul_of_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprÏƒ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\ntheorem norm_le_norm_mul_of_mem {a : A} {k : ğ•œ} (hk : k âˆˆ (exprÏƒ) a) : Â«exprâ€– â€–Â» k â‰¤ Â«exprâ€– â€–Â» a * Â«exprâ€– â€–Â» (1 : A) :=\n  le_of_not_lt <| mt mem_resolvent_set_of_norm_lt_mul hk\n#align norm_le_norm_mul_of_mem norm_le_norm_mul_of_mem\n\n",
 "norm_apply_le_self_mul_norm_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\ntheorem norm_apply_le_self_mul_norm_one [AlgHomClass F ğ•œ A ğ•œ] (f : F) (a : A) :\n    Â«exprâ€– â€–Â» (f a) â‰¤ Â«exprâ€– â€–Â» a * Â«exprâ€– â€–Â» (1 : A) :=\n  spectrum.norm_le_norm_mul_of_mem (apply_mem_spectrum f _)\n#align norm_apply_le_self_mul_norm_one norm_apply_le_self_mul_norm_one\n\n",
 "norm_apply_le_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\ntheorem norm_apply_le_self [NormOneClass A] [AlgHomClass F ğ•œ A ğ•œ] (f : F) (a : A) : Â«exprâ€– â€–Â» (f a) â‰¤ Â«exprâ€– â€–Â» a :=\n  spectrum.norm_le_norm_of_mem (apply_mem_spectrum f _)\n#align norm_apply_le_self norm_apply_le_self\n\n",
 "mem_resolvent_set_of_spectral_radius_lt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–â‚ŠÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprÏ -/\ntheorem mem_resolvent_set_of_spectral_radius_lt {a : A} {k : ğ•œ} (h : spectral_radius ğ•œ a < Â«exprâ€– â€–â‚ŠÂ» k) :\n    k âˆˆ (exprÏ) a :=\n  Classical.not_not.mp fun hn => h.not_le <| le_supáµ¢â‚‚ k hn\n#align mem_resolvent_set_of_spectral_radius_lt mem_resolvent_set_of_spectral_radius_lt\n\n",
 "mem_resolvent_set_of_norm_lt_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ†‘â‚Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprÏ -/\ntheorem mem_resolvent_set_of_norm_lt_mul {a : A} {k : ğ•œ} (h : Â«exprâ€– â€–Â» a * Â«exprâ€– â€–Â» (1 : A) < Â«exprâ€– â€–Â» k) :\n    k âˆˆ (exprÏ) a := by\n  rw [resolvent_set, Set.mem_setOf_eq, Algebra.algebraMap_eq_smul_one]\n  nontriviality A\n  have hk : k â‰  0 := ne_zero_of_norm_ne_zero ((mul_nonneg (norm_nonneg _) (norm_nonneg _)).trans_lt h).ne'\n  let ku := Units.map (Â«exprâ†‘â‚Â»).to_monoid_hom (Units.mk0 k hk)\n  rw [â† inv_inv (Â«exprâ€– â€–Â» (1 : A)), mul_inv_lt_iff (inv_pos.2 <| norm_pos_iff.2 (one_ne_zero : (1 : A) â‰  0))] at h\n  have hku : Â«exprâ€– â€–Â» (-a) < (Â«exprâ€– â€–Â» (â†‘kuâ»Â¹ : A))â»Â¹ := by simpa [ku, norm_algebraMap] using h\n  simpa [ku, sub_eq_add_neg, Algebra.algebraMap_eq_smul_one] using (ku.add (-a) hku).is_unit\n#align mem_resolvent_set_of_norm_lt_mul mem_resolvent_set_of_norm_lt_mul\n\n",
 "mem_resolvent_set_of_norm_lt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprÏ -/\ntheorem mem_resolvent_set_of_norm_lt [NormOneClass A] {a : A} {k : ğ•œ} (h : Â«exprâ€– â€–Â» a < Â«exprâ€– â€–Â» k) : k âˆˆ (exprÏ) a :=\n  mem_resolvent_set_of_norm_lt_mul (by rwa [norm_one, mul_one])\n#align mem_resolvent_set_of_norm_lt mem_resolvent_set_of_norm_lt\n\n",
 "map_pow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„‚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„‚ -/\n#print map_pow /-\n/-- A specialization of the spectral mapping theorem for polynomials in a Banach algebra over `â„‚`\nto monic monomials. -/\nprotected theorem map_pow (n : â„•) : spectrum (exprâ„‚) (a ^ n) = Â«expr '' Â» (fun x => x ^ n) (spectrum (exprâ„‚) a) := by\n  simpa only [aeval_X_pow, eval_pow, eval_X] using map_polynomial_aeval a (X ^ n)\n#align map_pow map_pow\n-/\n\n",
 "map_polynomial_aeval":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„‚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„‚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„‚ -/\n/-- The **spectral mapping theorem** for polynomials in a Banach algebra over `â„‚`. -/\ntheorem map_polynomial_aeval (p : polynomial (exprâ„‚)) :\n    spectrum (exprâ„‚) (aeval a p) = Â«expr '' Â» (fun k => eval k p) (spectrum (exprâ„‚) a) :=\n  map_polynomial_aeval_of_nonempty a p (spectrum.nonempty a)\n#align map_polynomial_aeval map_polynomial_aeval\n\n",
 "limsup_pow_nnnorm_pow_one_div_le_spectral_radius":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„‚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„‚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„‚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–â‚ŠÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„‚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–â‚ŠÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„‚ -/\n/-- The `limsup` relationship for the spectral radius used to prove `spectrum.gelfand_formula`. -/\ntheorem limsup_pow_nnnorm_pow_one_div_le_spectral_radius (a : A) :\n    limsup (fun n : â„• => â†‘(Â«exprâ€– â€–â‚ŠÂ» (a ^ n)) ^ (1 / n : exprâ„)) atTop â‰¤ spectral_radius (exprâ„‚) a :=\n  by\n  refine' ennreal.inv_le_inv.mp (le_of_forall_pos_nnreal_lt fun r r_pos r_lt => _)\n  simp_rw [inv_limsup, â† one_div]\n  let p : formal_multilinear_series (exprâ„‚) (exprâ„‚) A := fun n =>\n    continuous_multilinear_map.mk_pi_field (exprâ„‚) (Fin n) (a ^ n)\n  suffices h : (r : ennreal) â‰¤ p.radius\n  Â· convert h\n    simp only [p.radius_eq_liminf, â† norm_toNNReal, norm_mk_pi_field]\n    congr\n    ext n\n    rw [norm_toNNReal, ennreal.coe_rpow_def (Â«exprâ€– â€–â‚ŠÂ» (a ^ n)) (1 / n : exprâ„), if_neg]\n    exact fun ha => by linarith [ha.2, (one_div_nonneg.mpr n.cast_nonneg : 0 â‰¤ (1 / n : exprâ„))]\n  Â· have Hâ‚ := (differentiable_on_inverse_one_sub_smul r_lt).has_fpower_series_on_ball r_pos\n    exact ((has_fpower_series_on_ball_inverse_one_sub_smul (exprâ„‚) a).exchange_radius Hâ‚).r_le\n#align limsup_pow_nnnorm_pow_one_div_le_spectral_radius limsup_pow_nnnorm_pow_one_div_le_spectral_radius\n\n",
 "is_unit_one_sub_smul_of_lt_inv_radius":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–â‚ŠÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\ntheorem is_unit_one_sub_smul_of_lt_inv_radius {a : A} {z : ğ•œ} (h : â†‘(Â«exprâ€– â€–â‚ŠÂ» z) < (spectral_radius ğ•œ a)â»Â¹) :\n    IsUnit (1 - Â«expr â€¢ Â» z a) := by\n  by_cases hz : z = 0\n  Â· simp only [hz, isUnit_one, sub_zero, zero_smul]\n  Â· let u := Units.mk0 z hz\n    suffices hu : IsUnit (Â«expr â€¢ Â» uâ»Â¹ 1 - a)\n    Â· rwa [IsUnit.smul_sub_iff_sub_inv_smul, inv_inv u] at hu\n    Â· rw [Units.smul_def, â† Algebra.algebraMap_eq_smul_one, â† mem_resolvent_set_iff]\n      refine' mem_resolvent_set_of_spectral_radius_lt _\n      rwa [Units.val_inv_eq_inv_val, nnnorm_inv, coe_inv (nnnorm_ne_zero_iff.mpr (Units.val_mk0 hz â–¸ hz : (u : ğ•œ) â‰  0)),\n        lt_inv_iff_lt_inv]\n#align is_unit_one_sub_smul_of_lt_inv_radius is_unit_one_sub_smul_of_lt_inv_radius\n\n",
 "is_open_resolvent_set":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprÏ -/\ntheorem is_open_resolvent_set (a : A) : IsOpen ((exprÏ) a) :=\n  Units.isOpen.preimage ((continuous_algebraMap ğ•œ A).sub continuous_const)\n#align is_open_resolvent_set is_open_resolvent_set\n\n",
 "is_bounded":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprÏƒ -/\ntheorem is_bounded (a : A) : Metric.Bounded ((exprÏƒ) a) :=\n  (Metric.bounded_iff_subset_ball 0).mpr âŸ¨Â«exprâ€– â€–Â» a * Â«exprâ€– â€–Â» (1 : A), subset_closed_ball_norm_mul aâŸ©\n#align is_bounded is_bounded\n\n",
 "has_fpower_series_on_ball_inverse_one_sub_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–â‚ŠÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–â‚ŠÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–â‚ŠÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–â‚ŠÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–â‚ŠÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–â‚ŠÂ» -/\n/-- In a Banach algebra `A` over a nontrivially normed field `ğ•œ`, for any `a : A` the\npower series with coefficients `a ^ n` represents the function `(1 - z â€¢ a)â»Â¹` in a disk of\nradius `â€–aâ€–â‚Šâ»Â¹`. -/\ntheorem has_fpower_series_on_ball_inverse_one_sub_smul [CompleteSpace A] (a : A) :\n    has_fpower_series_on_ball (fun z : ğ•œ => Ring.inverse (1 - Â«expr â€¢ Â» z a))\n      (fun n => continuous_multilinear_map.mk_pi_field ğ•œ (Fin n) (a ^ n)) 0 (Â«exprâ€– â€–â‚ŠÂ» a)â»Â¹ :=\n  { r_le :=\n      by\n      refine' le_of_forall_nnreal_lt fun r hr => le_radius_of_bound_nnreal _ (max 1 (Â«exprâ€– â€–â‚ŠÂ» (1 : A))) fun n => _\n      rw [â† norm_toNNReal, norm_mk_pi_field, norm_toNNReal]\n      cases n\n      Â· simp only [le_refl, mul_one, or_true_iff, le_max_iff, pow_zero]\n      Â· refine' le_trans (le_trans (mul_le_mul_right' (nnnorm_pow_le' a n.succ_pos) (r ^ n.succ)) _) (le_max_left _ _)\n        Â· by_cases Â«exprâ€– â€–â‚ŠÂ» a = 0\n          Â· simp only [h, MulZeroClass.zero_mul, zero_le', pow_succ]\n          Â· rw [â† coe_inv h, coe_lt_coe, NNReal.lt_inv_iff_mul_lt h] at hr\n            simpa only [â† mul_pow, mul_comm] using pow_le_one' hr.le n.succ\n    r_pos := ENNReal.inv_pos.mpr coe_ne_top\n    has_sum := fun y hy =>\n      by\n      have norm_lt : Â«exprâ€– â€–Â» (Â«expr â€¢ Â» y a) < 1 :=\n        by\n        by_cases h : Â«exprâ€– â€–â‚ŠÂ» a = 0\n        Â· simp only [nnnorm_eq_zero.mp h, norm_zero, zero_lt_one, smul_zero]\n        Â· have nnnorm_lt : Â«exprâ€– â€–â‚ŠÂ» y < (Â«exprâ€– â€–â‚ŠÂ» a)â»Â¹ := by\n            simpa only [â† coe_inv h, mem_ball_zero_iff, Metric.emetric_ball_nnreal] using hy\n          rwa [â† coe_nnnorm, â† Real.lt_toNNReal_iff_coe_lt, Real.toNNReal_one, nnnorm_smul, â†\n            NNReal.lt_inv_iff_mul_lt h]\n      simpa [â† smul_pow, (NormedRing.summable_geometric_of_norm_lt_1 _ norm_lt).has_sum_iff] using\n        (NormedRing.inverse_one_sub _ norm_lt).symm }\n#align has_fpower_series_on_ball_inverse_one_sub_smul has_fpower_series_on_ball_inverse_one_sub_smul\n\n",
 "has_deriv_at_resolvent":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ†‘â‚Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ†‘â‚Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprÏ -/\ntheorem has_deriv_at_resolvent {a : A} {k : ğ•œ} (hk : k âˆˆ (exprÏ) a) :\n    has_deriv_at (resolvent a) (-resolvent a k ^ 2) k :=\n  by\n  have Hâ‚ : has_fderiv_at Ring.inverse _ ((Â«exprâ†‘â‚Â») k - a) := has_fderiv_at_ring_inverse hk.unit\n  have Hâ‚‚ : has_deriv_at (fun k => (Â«exprâ†‘â‚Â») k - a) 1 k := by\n    simpa using (Algebra.linearMap ğ•œ A).has_deriv_at.sub_const a\n  simpa [resolvent, sq, hk.unit_spec, â† Ring.inverse_unit hk.unit] using Hâ‚.comp_has_deriv_at k Hâ‚‚\n#align has_deriv_at_resolvent has_deriv_at_resolvent\n\n",
 "exp_mem_exp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ†‘â‚Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ†‘â‚Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ†‘â‚Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ‘' , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ‘' , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ†‘â‚Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ†‘â‚Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ†‘â‚Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ†‘â‚Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ‘' , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ‘' , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ†‘â‚Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ†‘â‚Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ†‘â‚Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ‘' , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ‘' , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ†‘â‚Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ†‘â‚Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ†‘â‚Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ†‘â‚Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ†‘â‚Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ†‘â‚Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ†‘â‚Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ†‘â‚Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ†‘â‚Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ†‘â‚Â» -/\n/-- For `ğ•œ = â„` or `ğ•œ = â„‚`, `exp ğ•œ` maps the spectrum of `a` into the spectrum of `exp ğ•œ a`. -/\ntheorem exp_mem_exp [IsROrC ğ•œ] [NormedRing A] [NormedAlgebra ğ•œ A] [CompleteSpace A] (a : A) {z : ğ•œ}\n    (hz : z âˆˆ spectrum ğ•œ a) : exp ğ•œ z âˆˆ spectrum ğ•œ (exp ğ•œ a) :=\n  by\n  have hexpmul : exp ğ•œ a = exp ğ•œ (a - (Â«exprâ†‘â‚Â») z) * (Â«exprâ†‘â‚Â») (exp ğ•œ z) := by\n    rw [algebra_map_exp_comm z, â† exp_add_of_commute (Algebra.commutes z (a - (Â«exprâ†‘â‚Â») z)).symm, sub_add_cancel]\n  let b :=\n    Â«exprâˆ‘' , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ‘' , Â»\"\n      (Â«expr â€¢ Â» ((n + 1).factorialâ»Â¹ : ğ•œ) ((a - (Â«exprâ†‘â‚Â») z) ^ n))\n  have hb : Summable fun n : â„• => Â«expr â€¢ Â» ((n + 1).factorialâ»Â¹ : ğ•œ) ((a - (Â«exprâ†‘â‚Â») z) ^ n) :=\n    by\n    refine' summable_of_norm_bounded_eventually _ (Real.summable_pow_div_factorial (Â«exprâ€– â€–Â» (a - (Â«exprâ†‘â‚Â») z))) _\n    filter_upwards [Filter.eventually_cofinite_ne 0]with n hn\n    rw [norm_smul, mul_comm, norm_inv, is_R_or_C.norm_eq_abs, is_R_or_C.abs_cast_nat, â† div_eq_mul_inv]\n    exact\n      div_le_div (pow_nonneg (norm_nonneg _) n) (norm_pow_le' (a - (Â«exprâ†‘â‚Â») z) (zero_lt_iff.mpr hn))\n        (by exact_mod_cast Nat.factorial_pos n) (by exact_mod_cast Nat.factorial_le (lt_add_one n).le)\n  have hâ‚€ :\n    Â«exprâˆ‘' , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ‘' , Â»\"\n        (Â«expr â€¢ Â» ((n + 1).factorialâ»Â¹ : ğ•œ) ((a - (Â«exprâ†‘â‚Â») z) ^ (n + 1))) =\n      (a - (Â«exprâ†‘â‚Â») z) * b :=\n    by simpa only [mul_smul_comm, pow_succ] using hb.tsum_mul_left (a - (Â«exprâ†‘â‚Â») z)\n  have hâ‚ :\n    Â«exprâˆ‘' , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ‘' , Â»\"\n        (Â«expr â€¢ Â» ((n + 1).factorialâ»Â¹ : ğ•œ) ((a - (Â«exprâ†‘â‚Â») z) ^ (n + 1))) =\n      b * (a - (Â«exprâ†‘â‚Â») z) :=\n    by simpa only [pow_succ', Algebra.smul_mul_assoc] using hb.tsum_mul_right (a - (Â«exprâ†‘â‚Â») z)\n  have hâ‚ƒ : exp ğ•œ (a - (Â«exprâ†‘â‚Â») z) = 1 + (a - (Â«exprâ†‘â‚Â») z) * b :=\n    by\n    rw [exp_eq_tsum]\n    convert tsum_eq_zero_add (exp_series_summable' (a - (Â«exprâ†‘â‚Â») z))\n    simp only [Nat.factorial_zero, Nat.cast_one, inv_one, pow_zero, one_smul]\n    exact hâ‚€.symm\n  rw [spectrum.mem_iff, IsUnit.sub_iff, â† one_mul ((Â«exprâ†‘â‚Â») (exp ğ•œ z)), hexpmul, â† _root_.sub_mul,\n    Commute.isUnit_mul_iff (Algebra.commutes (exp ğ•œ z) (exp ğ•œ (a - (Â«exprâ†‘â‚Â») z) - 1)).symm, sub_eq_iff_eq_add'.mpr hâ‚ƒ,\n    Commute.isUnit_mul_iff (hâ‚€ â–¸ hâ‚ : (a - (Â«exprâ†‘â‚Â») z) * b = b * (a - (Â«exprâ†‘â‚Â») z))]\n  exact not_and_of_not_left _ (not_and_of_not_left _ ((not_iff_not.mpr IsUnit.sub_iff).mp hz))\n#align exp_mem_exp exp_mem_exp\n\n",
 "exists_nnnorm_eq_spectral_radius_of_nonempty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprÏƒ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprÏƒ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–â‚ŠÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\ntheorem exists_nnnorm_eq_spectral_radius_of_nonempty [ProperSpace ğ•œ] {a : A} (ha : ((exprÏƒ) a).nonempty) :\n    âˆƒ k âˆˆ (exprÏƒ) a, (Â«exprâ€– â€–â‚ŠÂ» k : ennreal) = spectral_radius ğ•œ a :=\n  by\n  obtain âŸ¨k, hk, hâŸ© := (spectrum.is_compact a).exists_forall_ge ha continuous_nnnorm.continuous_on\n  exact âŸ¨k, hk, le_antisymm (le_supáµ¢â‚‚ k hk) (supáµ¢â‚‚_le <| by exact_mod_cast h)âŸ©\n#align exists_nnnorm_eq_spectral_radius_of_nonempty exists_nnnorm_eq_spectral_radius_of_nonempty\n\n",
 "exists_nnnorm_eq_spectral_radius":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„‚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–â‚ŠÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„‚ -/\n/-- In a complex Banach algebra, the spectral radius is always attained by some element of the\nspectrum. -/\ntheorem exists_nnnorm_eq_spectral_radius :\n    âˆƒ z âˆˆ spectrum (exprâ„‚) a, (Â«exprâ€– â€–â‚ŠÂ» z : ennreal) = spectral_radius (exprâ„‚) a :=\n  exists_nnnorm_eq_spectral_radius_of_nonempty (spectrum.nonempty a)\n#align exists_nnnorm_eq_spectral_radius exists_nnnorm_eq_spectral_radius\n\n",
 "equiv_alg_hom_symm_coe":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‡‘ Â» -/\n@[simp]\ntheorem equiv_alg_hom_symm_coe (f : Â«expr â†’â‚[ ] Â» A ğ•œ ğ•œ) : Â«exprâ‡‘ Â» (equiv_alg_hom.symm f) = f :=\n  rfl\n#align equiv_alg_hom_symm_coe equiv_alg_hom_symm_coe\n\n",
 "equiv_alg_hom_coe":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‡‘ Â» -/\n@[simp]\ntheorem equiv_alg_hom_coe (f : character_space ğ•œ A) : Â«exprâ‡‘ Â» (equiv_alg_hom f) = f :=\n  rfl\n#align equiv_alg_hom_coe equiv_alg_hom_coe\n\n",
 "differentiable_on_inverse_one_sub_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/-- In a Banach algebra `A` over `ğ•œ`, for `a : A` the function `Î» z, (1 - z â€¢ a)â»Â¹` is\ndifferentiable on any closed ball centered at zero of radius `r < (spectral_radius ğ•œ a)â»Â¹`. -/\ntheorem differentiable_on_inverse_one_sub_smul [CompleteSpace A] {a : A} {r : nnreal}\n    (hr : (r : ennreal) < (spectral_radius ğ•œ a)â»Â¹) :\n    differentiable_on ğ•œ (fun z : ğ•œ => Ring.inverse (1 - Â«expr â€¢ Â» z a)) (Metric.closedBall 0 r) :=\n  by\n  intro z z_mem\n  apply differentiable_at.differentiable_within_at\n  have hu : IsUnit (1 - Â«expr â€¢ Â» z a) :=\n    by\n    refine' is_unit_one_sub_smul_of_lt_inv_radius (lt_of_le_of_lt (coe_mono _) hr)\n    simpa only [norm_toNNReal, Real.toNNReal_coe] using Real.toNNReal_mono (mem_closed_ball_zero_iff.mp z_mem)\n  have Hâ‚ : differentiable ğ•œ fun w : ğ•œ => 1 - Â«expr â€¢ Â» w a := (differentiable_id.smul_const a).const_sub 1\n  exact differentiable_at.comp z (differentiable_at_inverse hu.unit) Hâ‚.differentiable_at\n#align differentiable_on_inverse_one_sub_smul differentiable_on_inverse_one_sub_smul\n\n",
 "coe_to_continuous_linear_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‡‘ Â» -/\n@[simp]\ntheorem coe_to_continuous_linear_map (Ï† : Â«expr â†’â‚[ ] Â» A ğ•œ ğ•œ) : Â«exprâ‡‘ Â» Ï†.to_continuous_linear_map = Ï† :=\n  rfl\n#align coe_to_continuous_linear_map coe_to_continuous_linear_map\n\n",
 "algebra_map_eq_of_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„‚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprÏƒ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„‚ -/\ntheorem algebra_map_eq_of_mem {a : A} {z : exprâ„‚} (h : z âˆˆ (exprÏƒ) a) : algebraMap (exprâ„‚) A z = a := by\n  rwa [mem_iff, hA, Classical.not_not, sub_eq_zero] at h\n#align algebra_map_eq_of_mem algebra_map_eq_of_mem\n\n",
 "Nonempty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„‚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„‚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„‚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„‚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„‚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„‚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„‚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„‚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„‚ -/\n#print Nonempty /-\n/-- In a (nontrivial) complex Banach algebra, every element has nonempty spectrum. -/\nprotected theorem Nonempty : (spectrum (exprâ„‚) a).nonempty :=\n  by\n  /- Suppose `Ïƒ a = âˆ…`, then resolvent set is `â„‚`, any `(z â€¢ 1 - a)` is a unit, and `resolvent`\n    is differentiable on `â„‚`. -/\n  rw [Set.nonempty_iff_ne_empty]\n  by_contra h\n  have Hâ‚€ : resolvent_set (exprâ„‚) a = Set.univ := by rwa [spectrum, Set.compl_empty_iff] at h\n  have Hâ‚ : differentiable (exprâ„‚) fun z : exprâ„‚ => resolvent a z := fun z =>\n    (has_deriv_at_resolvent (Hâ‚€.symm â–¸ Set.mem_univ z : z âˆˆ resolvent_set (exprâ„‚) a)).differentiable_at\n  /- The norm of the resolvent is small for all sufficently large `z`, and by compactness and\n    continuity it is bounded on the complement of a large ball, thus uniformly bounded on `â„‚`.\n    By Liouville's theorem `Î» z, resolvent a z` is constant -/\n  have Hâ‚‚ := norm_resolvent_le_forall a\n  have Hâ‚ƒ : âˆ€ z : exprâ„‚, resolvent a z = resolvent a (0 : exprâ„‚) :=\n    by\n    refine' fun z => Hâ‚.apply_eq_apply_of_bounded (bounded_iff_forall_norm_le.mpr _) z 0\n    rcases Hâ‚‚ 1 zero_lt_one with âŸ¨R, R_pos, hRâŸ©\n    rcases(proper_space.is_compact_closed_ball (0 : exprâ„‚) R).exists_bound_of_continuous_on\n        Hâ‚.continuous.continuous_on with\n      âŸ¨C, hCâŸ©\n    use max C 1\n    rintro _ âŸ¨w, rflâŸ©\n    refine' or.elim (em (Â«exprâ€– â€–Â» w â‰¤ R)) (fun hw => _) fun hw => _\n    Â· exact (hC w (mem_closed_ball_zero_iff.mpr hw)).trans (le_max_left _ _)\n    Â· exact (hR w (not_le.mp hw).le).trans (le_max_right _ _)\n  -- `resolvent a 0 = 0`, which is a contradition because it isn't a unit.\n  have Hâ‚… : resolvent a (0 : exprâ„‚) = 0 :=\n    by\n    refine' norm_eq_zero.mp (le_antisymm (le_of_forall_pos_le_add fun Îµ hÎµ => _) (norm_nonneg _))\n    rcases Hâ‚‚ Îµ hÎµ with âŸ¨R, R_pos, hRâŸ©\n    simpa only [Hâ‚ƒ R] using (zero_add Îµ).symm.subst (hR R (by exact_mod_cast (Real.norm_of_nonneg R_pos.lt.le).symm.le))\n  -- `not_is_unit_zero` is where we need `nontrivial A`, it is unavoidable.\n  exact not_isUnit_zero (Hâ‚….subst (is_unit_resolvent.mp (mem_resolvent_set_iff.mp (Hâ‚€.symm â–¸ Set.mem_univ 0))))\n#align nonempty Nonempty\n-/\n\n",
 "IsCompact":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprÏƒ -/\n#print IsCompact /-\nprotected theorem IsCompact [ProperSpace ğ•œ] (a : A) : IsCompact ((exprÏƒ) a) :=\n  Metric.isCompact_of_isClosed_bounded (spectrum.is_closed a) (is_bounded a)\n#align is_compact IsCompact\n-/\n\n",
 "IsClosed":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprÏƒ -/\n#print IsClosed /-\nprotected theorem IsClosed (a : A) : IsClosed ((exprÏƒ) a) :=\n  (is_open_resolvent_set a).is_closed_compl\n#align is_closed IsClosed\n-/\n\n"}