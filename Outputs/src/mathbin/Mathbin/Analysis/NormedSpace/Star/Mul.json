{"op_nnnorm_mul_flip":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/-- In a C⋆-algebra `E`, either unital or non-unital, multiplication on the right by `a : E` has\nnorm eqaul to the norm of `a`. -/\n@[simp]\ntheorem op_nnnorm_mul_flip : «expr‖ ‖₊» ((mul 𝕜 E).flip a) = «expr‖ ‖₊» a :=\n  by\n  rw [← Sup_unit_ball_eq_nnnorm, ← nnnorm_star, ← @op_nnnorm_mul 𝕜 E, ← Sup_unit_ball_eq_nnnorm]\n  congr 1\n  simp only [mul_apply', flip_apply]\n  refine' Set.Subset.antisymm _ _ <;> rintro - ⟨b, hb, rfl⟩ <;>\n    refine' ⟨star b, by simpa only [norm_star, mem_ball_zero_iff] using hb, _⟩\n  · simp only [← star_mul, nnnorm_star]\n  · simpa using (nnnorm_star (star b * a)).symm\n#align op_nnnorm_mul_flip op_nnnorm_mul_flip\n\n",
 "op_nnnorm_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/-\nCopyright (c) 2022 Jireh Loreaux. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Jireh Loreaux\n-/\n/-- In a C⋆-algebra `E`, either unital or non-unital, multiplication on the left by `a : E` has\nnorm equal to the norm of `a`. -/\n@[simp]\ntheorem op_nnnorm_mul : «expr‖ ‖₊» (mul 𝕜 E a) = «expr‖ ‖₊» a :=\n  by\n  rw [← Sup_closed_unit_ball_eq_nnnorm]\n  refine' csupₛ_eq_of_forall_le_of_forall_lt_exists_gt _ _ fun r hr => _\n  · exact (metric.nonempty_closed_ball.mpr zero_le_one).image _\n  · rintro - ⟨x, hx, rfl⟩\n    exact ((mul 𝕜 E a).unit_le_op_norm x <| mem_closed_ball_zero_iff.mp hx).trans (op_norm_mul_apply_le 𝕜 E a)\n  · have ha : 0 < «expr‖ ‖₊» a := zero_le'.trans_lt hr\n    rw [← inv_inv («expr‖ ‖₊» a), nnreal.lt_inv_iff_mul_lt (inv_ne_zero ha.ne')] at hr\n    obtain ⟨k, hk₁, hk₂⟩ := normed_field.exists_lt_nnnorm_lt 𝕜 (mul_lt_mul_of_pos_right hr <| nnreal.inv_pos.2 ha)\n    refine' ⟨_, ⟨«expr • » k (star a), _, rfl⟩, _⟩\n    ·\n      simpa only [mem_closed_ball_zero_iff, norm_smul, one_mul, norm_star] using\n        (nnreal.le_inv_iff_mul_le ha.ne').1 (one_mul («expr‖ ‖₊» a)⁻¹ ▸ hk₂.le : «expr‖ ‖₊» k ≤ («expr‖ ‖₊» a)⁻¹)\n    · simp only [map_smul, nnnorm_smul, mul_apply', mul_smul_comm, cstar_ring.nnnorm_self_mul_star]\n      rwa [← nnreal.div_lt_iff (mul_pos ha ha).ne', div_eq_mul_inv, mul_inv, ← mul_assoc]\n#align op_nnnorm_mul op_nnnorm_mul\n\n",
 "mul_isometry":
 "/-- In a C⋆-algebra `E`, either unital or non-unital, the left regular representation is an\nisometry. -/\ntheorem mul_isometry : isometry (mul 𝕜 E) :=\n  add_monoid_hom_class.isometry_of_norm _ fun a => congr_arg coe <| op_nnnorm_mul 𝕜 a\n#align mul_isometry mul_isometry\n\n",
 "mul_flip_isometry":
 "/-- In a C⋆-algebra `E`, either unital or non-unital, the right regular anti-representation is an\nisometry. -/\ntheorem mul_flip_isometry : isometry (mul 𝕜 E).flip :=\n  add_monoid_hom_class.isometry_of_norm _ fun a => congr_arg coe <| op_nnnorm_mul_flip 𝕜 a\n#align mul_flip_isometry mul_flip_isometry\n\n"}