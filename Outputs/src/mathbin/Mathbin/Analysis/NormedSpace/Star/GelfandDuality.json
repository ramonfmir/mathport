{"to_character_space_apply_eq_zero_of_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/-\nCopyright (c) 2022 Jireh Loreaux. All rights reserved.\nReeased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Jireh Loreaux\n-/\ntheorem ideal.to_character_space_apply_eq_zero_of_mem {a : A} (ha : a ∈ I) : I.to_character_space a = 0 :=\n  by\n  unfold ideal.to_character_space\n  simpa only [character_space.equiv_alg_hom_symm_coe, AlgHom.coe_comp, AlgEquiv.coe_algHom, quotient.mkₐ_eq_mk,\n    Function.comp_apply, quotient.eq_zero_iff_mem.mpr ha, spectrum.zero_eq,\n    normed_ring.alg_equiv_complex_of_complete_symm_apply] using\n    Set.eq_of_mem_singleton (Set.singleton_nonempty (0 : exprℂ)).some_mem\n#align ideal.to_character_space_apply_eq_zero_of_mem ideal.to_character_space_apply_eq_zero_of_mem\n\n",
 "mem_spectrum_iff_exists":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\ntheorem weak_dual.character_space.mem_spectrum_iff_exists {a : A} {z : exprℂ} :\n    z ∈ spectrum (exprℂ) a ↔ ∃ f : character_space (exprℂ) A, f a = z :=\n  by\n  refine' ⟨fun hz => _, _⟩\n  · obtain ⟨f, hf⟩ := weak_dual.character_space.exists_apply_eq_zero hz\n    simp only [map_sub, sub_eq_zero, alg_hom_class.commutes, Algebra.id.map_eq_id, RingHom.id_apply] at hf\n    exact (continuous_map.spectrum_eq_range (gelfand_transform (exprℂ) A a)).symm ▸ ⟨f, hf.symm⟩\n  · rintro ⟨f, rfl⟩\n    exact alg_hom.apply_mem_spectrum f a\n#align weak_dual.character_space.mem_spectrum_iff_exists weak_dual.character_space.mem_spectrum_iff_exists\n\n",
 "gelfand_transform_map_star":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\ntheorem gelfand_transform_map_star (a : A) :\n    gelfand_transform (exprℂ) A (star a) = star (gelfand_transform (exprℂ) A a) :=\n  ContinuousMap.ext fun φ => map_star φ a\n#align gelfand_transform_map_star gelfand_transform_map_star\n\n",
 "gelfand_transform_isometry":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/-- The Gelfand transform is an isometry when the algebra is a C⋆-algebra over `ℂ`. -/\ntheorem gelfand_transform_isometry : Isometry (gelfand_transform (exprℂ) A) :=\n  by\n  nontriviality A\n  refine' add_monoid_hom_class.isometry_of_norm (gelfand_transform (exprℂ) A) fun a => _\n  /- By `spectrum.gelfand_transform_eq`, the spectra of `star a * a` and its\n    `gelfand_transform` coincide. Therefore, so do their spectral radii, and since they are\n    self-adjoint, so also do their norms. Applying the C⋆-property of the norm and taking square\n    roots shows that the norm is preserved. -/\n  have : spectral_radius (exprℂ) (gelfand_transform (exprℂ) A (star a * a)) = spectral_radius (exprℂ) (star a * a) :=\n    by\n    unfold spectral_radius\n    rw [spectrum.gelfand_transform_eq]\n  simp only [map_mul, (IsSelfAdjoint.star_mul_self _).spectral_radius_eq_nnnorm, gelfand_transform_map_star a,\n    ENNReal.coe_eq_coe, CstarRing.nnnorm_star_mul_self, ← sq] at this\n  simpa only [Function.comp_apply, NNReal.sqrt_sq] using congr_arg ((coe : nnreal → exprℝ) ∘ «expr⇑ » NNReal.sqrt) this\n#align gelfand_transform_isometry gelfand_transform_isometry\n\n",
 "gelfand_transform_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/-- The Gelfand transform is spectrum-preserving. -/\ntheorem spectrum.gelfand_transform_eq (a : A) : spectrum (exprℂ) (gelfand_transform (exprℂ) A a) = spectrum (exprℂ) a :=\n  by\n  ext z\n  rw [continuous_map.spectrum_eq_range, weak_dual.character_space.mem_spectrum_iff_exists]\n  exact iff.rfl\n#align spectrum.gelfand_transform_eq spectrum.gelfand_transform_eq\n\n",
 "gelfand_transform_bijective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/-- The Gelfand transform is bijective when the algebra is a C⋆-algebra over `ℂ`. -/\ntheorem gelfand_transform_bijective : function.bijective (gelfand_transform (exprℂ) A) :=\n  by\n  refine' ⟨(gelfand_transform_isometry A).injective, _⟩\n  suffices (gelfand_transform (exprℂ) A).range = «expr⊤» by\n    exact fun x => this.symm ▸ (gelfand_transform (exprℂ) A).mem_range.mp (this.symm ▸ Algebra.mem_top)\n  /- Because the `gelfand_transform ℂ A` is an isometry, it has closed range, and so by the\n    Stone-Weierstrass theorem, it suffices to show that the image of the Gelfand transform separates\n    points in `C(character_space ℂ A, ℂ)` and is closed under `star`. -/\n  have h : (gelfand_transform (exprℂ) A).range.topological_closure = (gelfand_transform (exprℂ) A).range :=\n    le_antisymm\n      (Subalgebra.topologicalClosure_minimal _ le_rfl (gelfand_transform_isometry A).closed_embedding.closed_range)\n      (Subalgebra.le_topologicalClosure _)\n  refine'\n    h ▸\n      continuous_map.subalgebra_is_R_or_C_topological_closure_eq_top_of_separates_points _ (fun _ _ => _) fun f hf => _\n  /- Separating points just means that elements of the `character_space` which agree at all points\n    of `A` are the same functional, which is just extensionality. -/\n  · contrapose!\n    exact fun h =>\n      Subtype.ext\n        (ContinuousLinearMap.ext fun a =>\n          h (gelfand_transform (exprℂ) A a) ⟨gelfand_transform (exprℂ) A a, ⟨a, rfl⟩, rfl⟩)\n  /- If `f = gelfand_transform ℂ A a`, then `star f` is also in the range of `gelfand_transform ℂ A`\n    using the argument `star a`. The key lemma below may be hard to spot; it's `map_star` coming from\n    `weak_dual.star_hom_class`, which is a nontrivial result. -/\n  · obtain ⟨f, ⟨a, rfl⟩, rfl⟩ := subalgebra.mem_map.mp hf\n    refine' ⟨star a, ContinuousMap.ext fun ψ => _⟩\n    simpa only [gelfand_transform_map_star a, AlgHom.toRingHom_eq_coe, AlgHom.coe_toRingHom]\n#align gelfand_transform_bijective gelfand_transform_bijective\n\n",
 "exists_apply_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/-- If `a : A` is not a unit, then some character takes the value zero at `a`. This is equivlaent\nto `gelfand_transform ℂ A a` takes the value zero at some character. -/\ntheorem weak_dual.character_space.exists_apply_eq_zero {a : A} (ha : ¬IsUnit a) :\n    ∃ f : character_space (exprℂ) A, f a = 0 :=\n  by\n  obtain ⟨M, hM, haM⟩ := (span {a}).exists_le_maximal (span_singleton_ne_top ha)\n  exact\n    ⟨M.to_character_space,\n      M.to_character_space_apply_eq_zero_of_mem (haM (mem_span_singleton.mpr ⟨1, (mul_one a).symm⟩))⟩\n#align weak_dual.character_space.exists_apply_eq_zero weak_dual.character_space.exists_apply_eq_zero\n\n",
 "comp_continuous_map_id":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/-- `weak_dual.character_space.comp_continuous_map` sends the identity to the identity. -/\n@[simp]\ntheorem comp_continuous_map_id :\n    comp_continuous_map (StarAlgHom.id (exprℂ) A) = ContinuousMap.id (character_space (exprℂ) A) :=\n  ContinuousMap.ext fun a => ext fun x => rfl\n#align comp_continuous_map_id comp_continuous_map_id\n\n",
 "comp_continuous_map_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →⋆ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →⋆ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/-- `weak_dual.character_space.comp_continuous_map` is functorial. -/\n@[simp]\ntheorem comp_continuous_map_comp (ψ₂ : «expr →⋆ₐ[ ] » B (exprℂ) C) (ψ₁ : «expr →⋆ₐ[ ] » A (exprℂ) B) :\n    comp_continuous_map (ψ₂.comp ψ₁) = (comp_continuous_map ψ₁).comp (comp_continuous_map ψ₂) :=\n  ContinuousMap.ext fun a => ext fun x => rfl\n#align comp_continuous_map_comp comp_continuous_map_comp\n\n"}