{"exp_unitary_add":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem commute.exp_unitary_add {a b : self_adjoint A} (h : Commute (a : A) (b : A)) :\n    exp_unitary (a + b) = exp_unitary a * exp_unitary b :=\n  by\n  ext\n  have hcomm : Commute («expr • » I (a : A)) («expr • » I (b : A))\n  calc\n    _ = _ := by simp only [h.eq, algebra.smul_mul_assoc, algebra.mul_smul_comm]\n    \n  simpa only [exp_unitary_coe, add_subgroup.coe_add, smul_add] using exp_add_of_commute hcomm\n#align commute.exp_unitary_add commute.exp_unitary_add\n\n",
 "exp_unitary":
 "theorem commute.exp_unitary {a b : self_adjoint A} (h : Commute (a : A) (b : A)) :\n    Commute (exp_unitary a) (exp_unitary b) :=\n  calc\n    exp_unitary a * exp_unitary b = exp_unitary b * exp_unitary a := by\n      rw [← h.exp_unitary_add, ← h.symm.exp_unitary_add, add_comm]\n    \n#align commute.exp_unitary commute.exp_unitary\n\n",
 "exp_i_smul_unitary":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-\nCopyright (c) 2022 Jireh Loreaux. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Jireh Loreaux\n-/\ntheorem is_self_adjoint.exp_i_smul_unitary {a : A} (ha : is_self_adjoint a) : exp (exprℂ) («expr • » I a) ∈ unitary A :=\n  by\n  rw [unitary.mem_iff, star_exp]\n  simp only [star_smul, is_R_or_C.star_def, self_adjoint.mem_iff.mp ha, conj_I, neg_smul]\n  rw [← @exp_add_of_commute (exprℂ) A _ _ _ _ _ _ (Commute.refl («expr • » I a)).neg_left]\n  rw [← @exp_add_of_commute (exprℂ) A _ _ _ _ _ _ (Commute.refl («expr • » I a)).neg_right]\n  simpa only [add_right_neg, add_left_neg, and_self_iff] using (exp_zero : exp (exprℂ) (0 : A) = 1)\n#align is_self_adjoint.exp_i_smul_unitary is_self_adjoint.exp_i_smul_unitary\n\n"}