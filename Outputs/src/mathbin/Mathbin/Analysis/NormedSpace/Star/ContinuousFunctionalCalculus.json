{"spectrum_star_mul_self_of_is_star_normal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/-\nCopyright (c) 2022 Jireh Loreaux. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Jireh Loreaux\n-/\n-- without this instance type class search causes timeouts\n/-- This lemma is used in the proof of `star_subalgebra.is_unit_of_is_unit_of_is_star_normal`,\nwhich in turn is the key to spectral permanence `star_subalgebra.spectrum_eq`, which is itself\nnecessary for the continuous functional calculus. Using the continuous functional calculus, this\nlemma can be superseded by one that omits the `is_star_normal` hypothesis. -/\ntheorem spectrum_star_mul_self_of_is_star_normal :\n    spectrum (exprℂ) (star a * a) ⊆ Set.Icc (0 : exprℂ) («expr‖ ‖» (star a * a)) :=\n  by\n  -- this instance should be found automatically, but without providing it Lean goes on a wild\n  -- goose chase when trying to apply `spectrum.gelfand_transform_eq`.\n  letI := elemental_star_algebra.complex.normed_algebra a\n  rcases subsingleton_or_nontrivial A with ⟨⟩\n  · simp only [spectrum.of_subsingleton, Set.empty_subset]\n  · set a' : elementalStarAlgebra (exprℂ) a := ⟨a, self_mem (exprℂ) a⟩\n    refine' (spectrum.subset_star_subalgebra (star a' * a')).trans _\n    rw [← spectrum.gelfand_transform_eq (star a' * a'), continuous_map.spectrum_eq_range]\n    rintro - ⟨φ, rfl⟩\n    rw [gelfand_transform_apply_apply (exprℂ) _ (star a' * a') φ, map_mul φ, map_star φ]\n    rw [complex.eq_coe_norm_of_nonneg star_mul_self_nonneg, ← map_star, ← map_mul]\n    exact ⟨Complex.zero_le_real.2 (norm_nonneg _), Complex.real_le_real.2 (alg_hom.norm_apply_le_self φ (star a' * a'))⟩\n#align spectrum_star_mul_self_of_is_star_normal spectrum_star_mul_self_of_is_star_normal\n\n",
 "spectrum_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/-- **Spectral permanence.** The spectrum of an element is invariant of the (closed)\n`star_subalgebra` in which it is contained. -/\ntheorem star_subalgebra.spectrum_eq {S : StarSubalgebra (exprℂ) A} (hS : IsClosed (S : Set A)) (x : S) :\n    spectrum (exprℂ) x = spectrum (exprℂ) (x : A) :=\n  Set.ext fun z => star_subalgebra.mem_spectrum_iff hS\n#align star_subalgebra.spectrum_eq star_subalgebra.spectrum_eq\n\n",
 "mem_spectrum_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\ntheorem star_subalgebra.mem_spectrum_iff {S : StarSubalgebra (exprℂ) A} (hS : IsClosed (S : Set A)) {x : S}\n    {z : exprℂ} : z ∈ spectrum (exprℂ) x ↔ z ∈ spectrum (exprℂ) (x : A) :=\n  not_iff_not.2 (star_subalgebra.coe_is_unit hS).symm\n#align star_subalgebra.mem_spectrum_iff star_subalgebra.mem_spectrum_iff\n\n",
 "is_unit_of_is_unit_of_is_star_normal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/-- This is the key lemma on the way to establishing spectral permanence for C⋆-algebras, which is\nestablished in `star_subalgebra.spectrum_eq`. This lemma is superseded by\n`star_subalgebra.coe_is_unit`, which does not require an `is_star_normal` hypothesis and holds for\nany closed star subalgebra. -/\ntheorem elemental_star_algebra.is_unit_of_is_unit_of_is_star_normal (h : IsUnit a) :\n    IsUnit (⟨a, self_mem (exprℂ) a⟩ : elementalStarAlgebra (exprℂ) a) :=\n  by\n  /- Sketch of proof: Because `a` is normal, it suffices to prove that `star a * a` is invertible\n    in `elemental_star_algebra ℂ a`. For this it suffices to prove that it is sufficiently close to a\n    unit, namely `algebra_map ℂ _ ‖star a * a‖`, and in this case the required distance is\n    `‖star a * a‖`. So one must show `‖star a * a - algebra_map ℂ _ ‖star a * a‖‖ < ‖star a * a‖`.\n    Since `star a * a - algebra_map ℂ _ ‖star a * a‖` is selfadjoint, by a corollary of Gelfand's\n    formula for the spectral radius (`is_self_adjoint.spectral_radius_eq_nnnorm`) its norm is the\n    supremum of the norms of elements in its spectrum (we may use the spectrum in `A` here because\n    the norm in `A` and the norm in the subalgebra coincide).\n  \n    By `spectrum_star_mul_self_of_is_star_normal`, the spectrum (in the algebra `A`) of `star a * a`\n    is contained in the interval `[0, ‖star a * a‖]`, and since `a` (and hence `star a * a`) is\n    invertible in `A`, we may omit `0` from this interval. Therefore, by basic spectral mapping\n    properties, the spectrum (in the algebra `A`) of `star a * a - algebra_map ℂ _ ‖star a * a‖` is\n    contained in `[0, ‖star a * a‖)`. The supremum of the (norms of) elements of the spectrum must be\n    *strictly* less that `‖star a * a‖` because the spectrum is compact, which completes the proof. -/\n  /- We may assume `A` is nontrivial. It suffices to show that `star a * a` is invertible in the\n    commutative (because `a` is normal) ring `elemental_star_algebra ℂ a`. Indeed, by commutativity,\n    if `star a * a` is invertible, then so is `a`. -/\n  nontriviality A\n  set a' : elementalStarAlgebra (exprℂ) a := ⟨a, self_mem (exprℂ) a⟩\n  suffices : IsUnit (star a' * a')\n  exact (IsUnit.mul_iff.1 this).2\n  replace h := (show Commute (star a) a from star_comm_self' a).is_unit_mul_iff.2 ⟨h.star, h⟩\n  /- Since `a` is invertible, `‖star a * a‖ ≠ 0`, so `‖star a * a‖ • 1` is invertible in\n    `elemental_star_algebra ℂ a`, and so it suffices to show that the distance between this unit and\n    `star a * a` is less than `‖star a * a‖`. -/\n  have h₁ : («expr‖ ‖» (star a * a) : exprℂ) ≠ 0 := complex.of_real_ne_zero.mpr (norm_ne_zero_iff.mpr h.ne_zero)\n  set u : Units (elementalStarAlgebra (exprℂ) a) :=\n    Units.map (algebraMap (exprℂ) (elementalStarAlgebra (exprℂ) a)).to_monoid_hom (Units.mk0 _ h₁)\n  refine' ⟨u.unit_of_nearby _ _, rfl⟩\n  simp only [Complex.abs_ofReal, map_inv₀, Units.coe_map, Units.val_inv_eq_inv_val, [anonymous],\n    RingHom.toMonoidHom_eq_coe, Units.val_mk0, Units.coe_map_inv, norm_algebraMap', inv_inv, complex.norm_eq_abs,\n    abs_norm, subtype.val_eq_coe, coe_coe]\n  /- Since `a` is invertible, by `spectrum_star_mul_self_of_is_star_normal`, the spectrum (in `A`)\n    of `star a * a` is contained in the half-open interval `(0, ‖star a * a‖]`. Therefore, by basic\n    spectral mapping properties, the spectrum of `‖star a * a‖ • 1 - star a * a` is contained in\n    `[0, ‖star a * a‖)`. -/\n  have h₂ :\n    ∀ z ∈ spectrum (exprℂ) (algebraMap (exprℂ) A («expr‖ ‖» (star a * a)) - star a * a),\n      «expr‖ ‖₊» z < «expr‖ ‖₊» (star a * a) :=\n    by\n    intro z hz\n    rw [← spectrum.singleton_sub_eq, Set.singleton_sub] at hz\n    have h₃ : z ∈ Set.Icc (0 : exprℂ) («expr‖ ‖» (star a * a)) :=\n      by\n      replace hz := Set.image_subset _ (spectrum_star_mul_self_of_is_star_normal a) hz\n      rwa [Set.image_const_sub_Icc, sub_self, sub_zero] at hz\n    refine' lt_of_le_of_ne (Complex.real_le_real.1 <| complex.eq_coe_norm_of_nonneg h₃.1 ▸ h₃.2) _\n    · intro hz'\n      replace hz' := congr_arg (fun x : nnreal => ((x : exprℝ) : exprℂ)) hz'\n      simp only [coe_nnnorm] at hz'\n      rw [← complex.eq_coe_norm_of_nonneg h₃.1] at hz'\n      obtain ⟨w, hw₁, hw₂⟩ := hz\n      refine' (spectrum.zero_not_mem_iff (exprℂ)).mpr h _\n      rw [hz', sub_eq_self] at hw₂\n      rwa [hw₂] at hw₁\n  /- The norm of `‖star a * a‖ • 1 - star a * a` in the subalgebra and in `A` coincide. In `A`,\n    because this element is selfadjoint, by `is_self_adjoint.spectral_radius_eq_nnnorm`, its norm is\n    the supremum of the norms of the elements of the spectrum, which is strictly less than\n    `‖star a * a‖` by `h₂` and because the spectrum is compact. -/\n  exact\n    ENNReal.coe_lt_coe.1\n      (calc\n        («expr‖ ‖₊» (star a' * a' - algebraMap (exprℂ) _ («expr‖ ‖» (star a * a))) : ennreal) =\n            «expr‖ ‖₊» (algebraMap (exprℂ) A («expr‖ ‖» (star a * a)) - star a * a) :=\n          by\n          rw [← nnnorm_neg, neg_sub]\n          rfl\n        _ = spectral_radius (exprℂ) (algebraMap (exprℂ) A («expr‖ ‖» (star a * a)) - star a * a) :=\n          by\n          refine' (is_self_adjoint.spectral_radius_eq_nnnorm _).symm\n          rw [IsSelfAdjoint, star_sub, star_mul, star_star, ← algebraMap_star_comm, IsROrC.star_def, IsROrC.conj_ofReal]\n        _ < «expr‖ ‖₊» (star a * a) := spectrum.spectral_radius_lt_of_forall_lt _ h₂\n        )\n#align elemental_star_algebra.is_unit_of_is_unit_of_is_star_normal elemental_star_algebra.is_unit_of_is_unit_of_is_star_normal\n\n",
 "is_unit_coe_inv_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/-- For `x : A` which is invertible in `A`, the inverse lies in any unital C⋆-subalgebra `S`\ncontaining `x`. -/\ntheorem star_subalgebra.is_unit_coe_inv_mem {S : StarSubalgebra (exprℂ) A} (hS : IsClosed (S : Set A)) {x : A}\n    (h : IsUnit x) (hxS : x ∈ S) : ↑h.unit⁻¹ ∈ S :=\n  by\n  have hx := h.star.mul h\n  suffices this : (↑hx.unit⁻¹ : A) ∈ S\n  · rw [← one_mul (↑h.unit⁻¹ : A), ← hx.unit.inv_mul, mul_assoc, IsUnit.unit_spec, mul_assoc, h.mul_coe_inv, mul_one]\n    exact mul_mem this (star_mem hxS)\n  refine' le_of_is_closed_of_mem (exprℂ) hS (mul_mem (star_mem hxS) hxS) _\n  haveI := (IsSelfAdjoint.star_mul_self x).is_star_normal\n  have hx' := elemental_star_algebra.is_unit_of_is_unit_of_is_star_normal hx\n  convert(↑hx'.unit⁻¹ : elementalStarAlgebra (exprℂ) (star x * x)).prop using 1\n  exact left_inv_eq_right_inv hx.unit.inv_mul (congr_arg coe hx'.unit.mul_inv)\n#align star_subalgebra.is_unit_coe_inv_mem star_subalgebra.is_unit_coe_inv_mem\n\n",
 "continuous_functional_calculus_map_id":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\ntheorem continuous_functional_calculus_map_id :\n    continuous_functional_calculus a ((ContinuousMap.id (exprℂ)).restrict (spectrum (exprℂ) a)) =\n      ⟨a, self_mem (exprℂ) a⟩ :=\n  StarAlgEquiv.symm_apply_apply _ _\n#align continuous_functional_calculus_map_id continuous_functional_calculus_map_id\n\n",
 "continuous_character_space_to_spectrum":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\ntheorem elemental_star_algebra.continuous_character_space_to_spectrum (x : A) :\n    Continuous (elemental_star_algebra.character_space_to_spectrum x) :=\n  continuous_induced_rng.2\n    (map_continuous <| gelfand_transform (exprℂ) (elementalStarAlgebra (exprℂ) x) ⟨x, self_mem (exprℂ) x⟩)\n#align elemental_star_algebra.continuous_character_space_to_spectrum elemental_star_algebra.continuous_character_space_to_spectrum\n\n",
 "coe_is_unit":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/-- For a unital C⋆-subalgebra `S` of `A` and `x : S`, if `↑x : A` is invertible in `A`, then\n`x` is invertible in `S`. -/\ntheorem star_subalgebra.coe_is_unit {S : StarSubalgebra (exprℂ) A} (hS : IsClosed (S : Set A)) {x : S} :\n    IsUnit (x : A) ↔ IsUnit x :=\n  by\n  refine'\n    ⟨fun hx => ⟨⟨x, ⟨(↑hx.unit⁻¹ : A), star_subalgebra.is_unit_coe_inv_mem hS hx x.prop⟩, _, _⟩, rfl⟩, fun hx =>\n      hx.map S.subtype⟩\n  exacts[Subtype.coe_injective hx.mul_coe_inv, Subtype.coe_injective hx.coe_inv_mul]\n#align star_subalgebra.coe_is_unit star_subalgebra.coe_is_unit\n\n",
 "bijective_character_space_to_spectrum":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\ntheorem elemental_star_algebra.bijective_character_space_to_spectrum :\n    function.bijective (elemental_star_algebra.character_space_to_spectrum a) :=\n  by\n  refine'\n    ⟨fun φ ψ h =>\n      star_alg_hom_class_ext (exprℂ) (map_continuous φ) (map_continuous ψ)\n        (by\n          simpa only [elemental_star_algebra.character_space_to_spectrum, Subtype.mk_eq_mk, ContinuousMap.coe_mk] using\n            h),\n      _⟩\n  rintro ⟨z, hz⟩\n  have hz' :=\n    (star_subalgebra.spectrum_eq (elementalStarAlgebra.isClosed (exprℂ) a) ⟨a, self_mem (exprℂ) a⟩).symm.subst hz\n  rw [character_space.mem_spectrum_iff_exists] at hz'\n  obtain ⟨φ, rfl⟩ := hz'\n  exact ⟨φ, rfl⟩\n#align elemental_star_algebra.bijective_character_space_to_spectrum elemental_star_algebra.bijective_character_space_to_spectrum\n\n"}