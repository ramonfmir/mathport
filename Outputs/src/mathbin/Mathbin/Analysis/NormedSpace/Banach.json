{"right_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/-\nCopyright (c) 2019 Sébastien Gouëzel. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Sébastien Gouëzel\n-/\n@[simp]\ntheorem nonlinear_right_inverse.right_inv {f : «expr →L[ ] » E 𝕜 F} (fsymm : nonlinear_right_inverse f) (y : F) :\n    f (fsymm y) = y :=\n  fsymm.right_inv' y\n#align nonlinear_right_inverse.right_inv nonlinear_right_inverse.right_inv\n\n",
 "range_eq_map_coprod_subtypeL_equiv_of_is_compl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\ntheorem range_eq_map_coprod_subtypeL_equiv_of_is_compl (f : «expr →L[ ] » E 𝕜 F) {G : Submodule 𝕜 F}\n    (h : IsCompl (LinearMap.range f) G) [CompleteSpace G] (hker : ker f = «expr⊥») :\n    LinearMap.range f =\n      ((«expr⊤» : Submodule 𝕜 E).prod («expr⊥» : Submodule 𝕜 G)).map\n        (f.coprod_subtypeL_equiv_of_is_compl h hker : «expr →ₗ[ ] » (E × G) 𝕜 F) :=\n  by\n  rw [coprod_subtypeL_equiv_of_is_compl, _root_.coe_coe, continuous_linear_equiv.coe_of_bijective, coe_coprod,\n    LinearMap.coprod_map_prod, Submodule.map_bot, sup_bot_eq, Submodule.map_top]\n  rfl\n#align range_eq_map_coprod_subtypeL_equiv_of_is_compl range_eq_map_coprod_subtypeL_equiv_of_is_compl\n\n",
 "of_bijective_symm_apply_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem of_bijective_symm_apply_apply (f : «expr →L[ ] » E 𝕜 F) (hinj : ker f = «expr⊥»)\n    (hsurj : LinearMap.range f = «expr⊤») (x : E) : (of_bijective f hinj hsurj).symm (f x) = x :=\n  (of_bijective f hinj hsurj).symm_apply_apply x\n#align of_bijective_symm_apply_apply of_bijective_symm_apply_apply\n\n",
 "of_bijective_apply_symm_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem of_bijective_apply_symm_apply (f : «expr →L[ ] » E 𝕜 F) (hinj : ker f = «expr⊥»)\n    (hsurj : LinearMap.range f = «expr⊤») (y : F) : f ((of_bijective f hinj hsurj).symm y) = y :=\n  (of_bijective f hinj hsurj).apply_symm_apply y\n#align of_bijective_apply_symm_apply of_bijective_apply_symm_apply\n\n",
 "nonlinear_right_inverse_of_surjective_nnnorm_pos":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem nonlinear_right_inverse_of_surjective_nnnorm_pos (f : «expr →L[ ] » E 𝕜 F)\n    (hsurj : LinearMap.range f = «expr⊤») : 0 < (nonlinear_right_inverse_of_surjective f hsurj).nnnorm :=\n  by\n  rw [nonlinear_right_inverse_of_surjective]\n  exact Classical.choose_spec (exists_nonlinear_right_inverse_of_surjective f hsurj)\n#align nonlinear_right_inverse_of_surjective_nnnorm_pos nonlinear_right_inverse_of_surjective_nnnorm_pos\n\n",
 "is_open_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ᵃ[ ] » -/\ntheorem _root_.affine_map.is_open_map {P Q : Type _} [MetricSpace P] [NormedAddTorsor E P] [MetricSpace Q]\n    [NormedAddTorsor F Q] (f : «expr →ᵃ[ ] » P 𝕜 Q) (hf : Continuous f) (surj : surjective f) : IsOpenMap f :=\n  affine_map.is_open_map_linear_iff.mp <|\n    continuous_linear_map.is_open_map { f.linear with cont := affine_map.continuous_linear_iff.mpr hf }\n      (f.linear_surjective_iff.mpr surj)\n#align affine_map.is_open_map affine_map.is_open_map\n\n",
 "interior_preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem interior_preimage (hsurj : surjective f) (s : Set F) :\n    interior («expr ⁻¹' » f s) = «expr ⁻¹' » f (interior s) :=\n  ((f.is_open_map hsurj).preimage_interior_eq_interior_preimage f.continuous s).symm\n#align interior_preimage interior_preimage\n\n",
 "frontier_preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem frontier_preimage (hsurj : surjective f) (s : Set F) :\n    frontier («expr ⁻¹' » f s) = «expr ⁻¹' » f (frontier s) :=\n  ((f.is_open_map hsurj).preimage_frontier_eq_frontier_preimage f.continuous s).symm\n#align frontier_preimage frontier_preimage\n\n",
 "exists_preimage_norm_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/-- The Banach open mapping theorem: if a bounded linear map between Banach spaces is onto, then\nany point has a preimage with controlled norm. -/\ntheorem exists_preimage_norm_le (surj : surjective f) : ∃ C > 0, ∀ y, ∃ x, f x = y ∧ «expr‖ ‖» x ≤ C * «expr‖ ‖» y :=\n  by\n  obtain ⟨C, C0, hC⟩ := exists_approx_preimage_norm_le f surj\n  /- Second step of the proof: starting from `y`, we want an exact preimage of `y`. Let `g y` be\n    the approximate preimage of `y` given by the first step, and `h y = y - f(g y)` the part that\n    has no preimage yet. We will iterate this process, taking the approximate preimage of `h y`,\n    leaving only `h^2 y` without preimage yet, and so on. Let `u n` be the approximate preimage\n    of `h^n y`. Then `u` is a converging series, and by design the sum of the series is a\n    preimage of `y`. This uses completeness of `E`. -/\n  choose g hg using hC\n  let h y := y - f (g y)\n  have hle : ∀ y, «expr‖ ‖» (h y) ≤ 1 / 2 * «expr‖ ‖» y :=\n    by\n    intro y\n    rw [← dist_eq_norm, dist_comm]\n    exact (hg y).1\n  refine' ⟨2 * C + 1, by linarith, fun y => _⟩\n  have hnle : ∀ n : ℕ, «expr‖ ‖» ((«expr ^[ ]» h n) y) ≤ (1 / 2) ^ n * «expr‖ ‖» y :=\n    by\n    intro n\n    induction' n with n IH\n    · simp only [one_div, Nat.zero_eq, one_mul, iterate_zero_apply, pow_zero]\n    · rw [iterate_succ']\n      apply le_trans (hle _) _\n      rw [pow_succ, mul_assoc]\n      apply mul_le_mul_of_nonneg_left IH\n      norm_num\n  let u n := g ((«expr ^[ ]» h n) y)\n  have ule : ∀ n, «expr‖ ‖» (u n) ≤ (1 / 2) ^ n * (C * «expr‖ ‖» y) :=\n    by\n    intro n\n    apply le_trans (hg _).2 _\n    calc\n      C * «expr‖ ‖» ((«expr ^[ ]» h n) y) ≤ C * ((1 / 2) ^ n * «expr‖ ‖» y) := mul_le_mul_of_nonneg_left (hnle n) C0\n      _ = (1 / 2) ^ n * (C * «expr‖ ‖» y) := by ring\n      \n  have sNu : Summable fun n => «expr‖ ‖» (u n) :=\n    by\n    refine' summable_of_nonneg_of_le (fun n => norm_nonneg _) ule _\n    exact Summable.mul_right _ (summable_geometric_of_lt_1 (by norm_num) (by norm_num))\n  have su : Summable u := summable_of_summable_norm sNu\n  let x := tsum u\n  have x_ineq : «expr‖ ‖» x ≤ (2 * C + 1) * «expr‖ ‖» y :=\n    calc\n      «expr‖ ‖» x ≤\n          «expr∑' , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , »\"\n            («expr‖ ‖» (u n)) :=\n        norm_tsum_le_tsum_norm sNu\n      _ ≤\n          «expr∑' , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , »\"\n            ((1 / 2) ^ n * (C * «expr‖ ‖» y)) :=\n        (tsum_le_tsum ule sNu (Summable.mul_right _ summable_geometric_two))\n      _ =\n          «expr∑' , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , »\"\n              ((1 / 2) ^ n) *\n            (C * «expr‖ ‖» y) :=\n        tsum_mul_right\n      _ = 2 * C * «expr‖ ‖» y := by rw [tsum_geometric_two, mul_assoc]\n      _ ≤ 2 * C * «expr‖ ‖» y + «expr‖ ‖» y := (le_add_of_nonneg_right (norm_nonneg y))\n      _ = (2 * C + 1) * «expr‖ ‖» y := by ring\n      \n  have fsumeq :\n    ∀ n : ℕ,\n      f\n          (finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n            (Finset.range n) (u i)) =\n        y - («expr ^[ ]» h n) y :=\n    by\n    intro n\n    induction' n with n IH\n    · simp [f.map_zero]\n    · rw [sum_range_succ, f.map_add, IH, iterate_succ', sub_add]\n  have :\n    tendsto\n      (fun n =>\n        finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (Finset.range n)\n          (u i))\n      at_top ((nhds) x) :=\n    su.has_sum.tendsto_sum_nat\n  have L₁ :\n    tendsto\n      (fun n =>\n        f\n          (finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n            (Finset.range n) (u i)))\n      at_top ((nhds) (f x)) :=\n    (f.continuous.tendsto _).comp this\n  simp only [fsumeq] at L₁\n  have L₂ : tendsto (fun n => y - («expr ^[ ]» h n) y) at_top ((nhds) (y - 0)) :=\n    by\n    refine' tendsto_const_nhds.sub _\n    rw [tendsto_iff_norm_tendsto_zero]\n    simp only [sub_zero]\n    refine' squeeze_zero (fun _ => norm_nonneg _) hnle _\n    rw [← MulZeroClass.zero_mul («expr‖ ‖» y)]\n    refine' (tendsto_pow_atTop_nhds_0_of_lt_1 _ _).mul tendsto_const_nhds <;> norm_num\n  have feq : f x = y - 0 := tendsto_nhds_unique L₁ L₂\n  rw [sub_zero] at feq\n  exact ⟨x, feq, x_ineq⟩\n#align exists_preimage_norm_le exists_preimage_norm_le\n\n",
 "exists_nonlinear_right_inverse_of_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem exists_nonlinear_right_inverse_of_surjective (f : «expr →L[ ] » E 𝕜 F) (hsurj : LinearMap.range f = «expr⊤») :\n    ∃ fsymm : nonlinear_right_inverse f, 0 < fsymm.nnnorm :=\n  by\n  choose C hC fsymm h using exists_preimage_norm_le _ (linear_map.range_eq_top.mp hsurj)\n  use {\n      to_fun := fsymm\n      nnnorm := ⟨C, hC.lt.le⟩\n      bound' := fun y => (h y).2\n      right_inv' := fun y => (h y).1 }\n  exact hC\n#align exists_nonlinear_right_inverse_of_surjective exists_nonlinear_right_inverse_of_surjective\n\n",
 "exists_approx_preimage_norm_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/-- First step of the proof of the Banach open mapping theorem (using completeness of `F`):\nby Baire's theorem, there exists a ball in `E` whose image closure has nonempty interior.\nRescaling everything, it follows that any `y ∈ F` is arbitrarily well approached by\nimages of elements of norm at most `C * ‖y‖`.\nFor further use, we will only need such an element whose image\nis within distance `‖y‖/2` of `y`, to apply an iterative process. -/\ntheorem exists_approx_preimage_norm_le (surj : surjective f) :\n    ∃ C ≥ 0, ∀ y, ∃ x, dist (f x) y ≤ 1 / 2 * «expr‖ ‖» y ∧ «expr‖ ‖» x ≤ C * «expr‖ ‖» y :=\n  by\n  have A :\n    «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n        (closure («expr '' » f (ball 0 n))) =\n      univ :=\n    by\n    refine' subset.antisymm (subset_univ _) fun y hy => _\n    rcases surj y with ⟨x, hx⟩\n    rcases exists_nat_gt («expr‖ ‖» x) with ⟨n, hn⟩\n    refine' mem_Union.2 ⟨n, subset_closure _⟩\n    refine' (mem_image _ _ _).2 ⟨x, ⟨_, hx⟩⟩\n    rwa [mem_ball, dist_eq_norm, sub_zero]\n  have : ∃ (n : ℕ)(x : _), x ∈ interior (closure («expr '' » f (ball 0 n))) :=\n    nonempty_interior_of_unionᵢ_of_closed (fun n => isClosed_closure) A\n  simp only [mem_interior_iff_mem_nhds, Metric.mem_nhds_iff] at this\n  rcases this with ⟨n, a, ε, ⟨εpos, H⟩⟩\n  rcases NormedField.exists_one_lt_norm 𝕜 with ⟨c, hc⟩\n  refine' ⟨(ε / 2)⁻¹ * «expr‖ ‖» c * 2 * n, _, fun y => _⟩\n  · refine' mul_nonneg (mul_nonneg (mul_nonneg _ (norm_nonneg _)) (by norm_num)) _\n    exacts[inv_nonneg.2 (div_nonneg (le_of_lt εpos) (by norm_num)), n.cast_nonneg]\n  · by_cases hy : y = 0\n    · use 0\n      simp [hy]\n    · rcases rescale_to_shell hc (half_pos εpos) hy with ⟨d, hd, ydlt, leyd, dinv⟩\n      let δ := «expr‖ ‖» d * «expr‖ ‖» y / 4\n      have δpos : 0 < δ := div_pos (mul_pos (norm_pos_iff.2 hd) (norm_pos_iff.2 hy)) (by norm_num)\n      have : a + «expr • » d y ∈ ball a ε := by simp [dist_eq_norm, lt_of_le_of_lt ydlt.le (half_lt_self εpos)]\n      rcases Metric.mem_closure_iff.1 (H this) _ δpos with ⟨z₁, z₁im, h₁⟩\n      rcases(mem_image _ _ _).1 z₁im with ⟨x₁, hx₁, xz₁⟩\n      rw [← xz₁] at h₁\n      rw [mem_ball, dist_eq_norm, sub_zero] at hx₁\n      have : a ∈ ball a ε := by\n        simp\n        exact εpos\n      rcases Metric.mem_closure_iff.1 (H this) _ δpos with ⟨z₂, z₂im, h₂⟩\n      rcases(mem_image _ _ _).1 z₂im with ⟨x₂, hx₂, xz₂⟩\n      rw [← xz₂] at h₂\n      rw [mem_ball, dist_eq_norm, sub_zero] at hx₂\n      let x := x₁ - x₂\n      have I : «expr‖ ‖» (f x - «expr • » d y) ≤ 2 * δ :=\n        calc\n          «expr‖ ‖» (f x - «expr • » d y) = «expr‖ ‖» (f x₁ - (a + «expr • » d y) - (f x₂ - a)) :=\n            by\n            congr 1\n            simp only [x, f.map_sub]\n            abel\n          _ ≤ «expr‖ ‖» (f x₁ - (a + «expr • » d y)) + «expr‖ ‖» (f x₂ - a) := (norm_sub_le _ _)\n          _ ≤ δ + δ := by\n            apply add_le_add\n            · rw [← dist_eq_norm, dist_comm]\n              exact le_of_lt h₁\n            · rw [← dist_eq_norm, dist_comm]\n              exact le_of_lt h₂\n          _ = 2 * δ := (two_mul _).symm\n          \n      have J : «expr‖ ‖» (f («expr • » d⁻¹ x) - y) ≤ 1 / 2 * «expr‖ ‖» y :=\n        calc\n          «expr‖ ‖» (f («expr • » d⁻¹ x) - y) = «expr‖ ‖» («expr • » d⁻¹ (f x) - «expr • » (d⁻¹ * d) y) := by\n            rwa [f.map_smul _, inv_mul_cancel, one_smul]\n          _ = «expr‖ ‖» («expr • » d⁻¹ (f x - «expr • » d y)) := by rw [mul_smul, smul_sub]\n          _ = («expr‖ ‖» d)⁻¹ * «expr‖ ‖» (f x - «expr • » d y) := by rw [norm_smul, norm_inv]\n          _ ≤ («expr‖ ‖» d)⁻¹ * (2 * δ) := by\n            apply mul_le_mul_of_nonneg_left I\n            rw [inv_nonneg]\n            exact norm_nonneg _\n          _ = («expr‖ ‖» d)⁻¹ * «expr‖ ‖» d * «expr‖ ‖» y / 2 :=\n            by\n            simp only [δ]\n            ring\n          _ = «expr‖ ‖» y / 2 := by\n            rw [inv_mul_cancel, one_mul]\n            simp [norm_eq_zero, hd]\n          _ = 1 / 2 * «expr‖ ‖» y := by ring\n          \n      rw [← dist_eq_norm] at J\n      have K : «expr‖ ‖» («expr • » d⁻¹ x) ≤ (ε / 2)⁻¹ * «expr‖ ‖» c * 2 * ↑n * «expr‖ ‖» y :=\n        calc\n          «expr‖ ‖» («expr • » d⁻¹ x) = («expr‖ ‖» d)⁻¹ * «expr‖ ‖» (x₁ - x₂) := by rw [norm_smul, norm_inv]\n          _ ≤ (ε / 2)⁻¹ * «expr‖ ‖» c * «expr‖ ‖» y * (n + n) :=\n            by\n            refine' mul_le_mul dinv _ (norm_nonneg _) _\n            · exact le_trans (norm_sub_le _ _) (add_le_add (le_of_lt hx₁) (le_of_lt hx₂))\n            · apply mul_nonneg (mul_nonneg _ (norm_nonneg _)) (norm_nonneg _)\n              exact inv_nonneg.2 (le_of_lt (half_pos εpos))\n          _ = (ε / 2)⁻¹ * «expr‖ ‖» c * 2 * ↑n * «expr‖ ‖» y := by ring\n          \n      exact ⟨«expr • » d⁻¹ x, J, K⟩\n#align exists_approx_preimage_norm_le exists_approx_preimage_norm_le\n\n",
 "continuous_symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n/-- If a bounded linear map is a bijection, then its inverse is also a bounded linear map. -/\n@[continuity]\ntheorem continuous_symm (e : «expr ≃ₗ[ ] » E 𝕜 F) (h : Continuous e) : Continuous e.symm :=\n  by\n  rw [continuous_def]\n  intro s hs\n  rw [← e.image_eq_preimage]\n  rw [← e.coe_coe] at h⊢\n  exact continuous_linear_map.is_open_map ⟨↑e, h⟩ e.surjective s hs\n#align continuous_symm continuous_symm\n\n",
 "continuous_of_seq_closed_graph":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- A useful form of the **closed graph theorem** : let `f` be a linear map between two Banach\nspaces. To show that `f` is continuous, it suffices to show that for any convergent sequence\n`uₙ ⟶ x`, if `f(uₙ) ⟶ y` then `y = f(x)`. -/\ntheorem linear_map.continuous_of_seq_closed_graph\n    (hg : ∀ (u : ℕ → E) (x y), Tendsto u atTop ((nhds) x) → Tendsto (g ∘ u) atTop ((nhds) y) → y = g x) :\n    Continuous g := by\n  refine' g.continuous_of_is_closed_graph (IsSeqClosed.isClosed _)\n  rintro φ ⟨x, y⟩ hφg hφ\n  refine' hg (Prod.fst ∘ φ) x y ((continuous_fst.tendsto _).comp hφ) _\n  have : g ∘ Prod.fst ∘ φ = Prod.snd ∘ φ := by\n    ext n\n    exact (hφg n).symm\n  rw [this]\n  exact (continuous_snd.tendsto _).comp hφ\n#align linear_map.continuous_of_seq_closed_graph linear_map.continuous_of_seq_closed_graph\n\n",
 "continuous_of_is_closed_graph":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃L[ ] » -/\n/-- The **closed graph theorem** : a linear map between two Banach spaces whose graph is closed\nis continuous. -/\ntheorem linear_map.continuous_of_is_closed_graph (hg : IsClosed (g.graph : Set <| E × F)) : Continuous g :=\n  by\n  letI : CompleteSpace g.graph := complete_space_coe_iff_is_complete.mpr hg.is_complete\n  let φ₀ : «expr →ₗ[ ] » E 𝕜 (E × F) := linear_map.id.prod g\n  have : function.left_inverse Prod.fst φ₀ := fun x => rfl\n  let φ : «expr ≃ₗ[ ] » E 𝕜 g.graph :=\n    (LinearEquiv.ofLeftInverse this).trans (LinearEquiv.ofEq _ _ g.graph_eq_range_prod.symm)\n  let ψ : «expr ≃L[ ] » g.graph 𝕜 E := φ.symm.to_continuous_linear_equiv_of_continuous continuous_subtype_coe.fst\n  exact (continuous_subtype_coe.comp ψ.symm.continuous).snd\n#align linear_map.continuous_of_is_closed_graph linear_map.continuous_of_is_closed_graph\n\n",
 "coe_of_seq_closed_graph":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem coe_of_seq_closed_graph\n    (hg : ∀ (u : ℕ → E) (x y), Tendsto u atTop ((nhds) x) → Tendsto (g ∘ u) atTop ((nhds) y) → y = g x) :\n    ↑(continuous_linear_map.of_seq_closed_graph hg) = g :=\n  by\n  ext\n  rfl\n#align coe_of_seq_closed_graph coe_of_seq_closed_graph\n\n",
 "coe_of_is_closed_graph":
 "theorem coe_of_is_closed_graph (hg : IsClosed (g.graph : Set <| E × F)) :\n    ↑(continuous_linear_map.of_is_closed_graph hg) = g := by\n  ext\n  rfl\n#align coe_of_is_closed_graph coe_of_is_closed_graph\n\n",
 "coe_of_bijective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem coe_of_bijective (f : «expr →L[ ] » E 𝕜 F) (hinj : ker f = «expr⊥») (hsurj : LinearMap.range f = «expr⊤») :\n    ↑(of_bijective f hinj hsurj) = f := by\n  ext\n  rfl\n#align coe_of_bijective coe_of_bijective\n\n",
 "coe_fn_to_continuous_linear_equiv_of_continuous_symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n@[simp]\ntheorem coe_fn_to_continuous_linear_equiv_of_continuous_symm (e : «expr ≃ₗ[ ] » E 𝕜 F) (h : Continuous e) :\n    «expr⇑ » (e.to_continuous_linear_equiv_of_continuous h).symm = e.symm :=\n  rfl\n#align coe_fn_to_continuous_linear_equiv_of_continuous_symm coe_fn_to_continuous_linear_equiv_of_continuous_symm\n\n",
 "coe_fn_to_continuous_linear_equiv_of_continuous":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n@[simp]\ntheorem coe_fn_to_continuous_linear_equiv_of_continuous (e : «expr ≃ₗ[ ] » E 𝕜 F) (h : Continuous e) :\n    «expr⇑ » (e.to_continuous_linear_equiv_of_continuous h) = e :=\n  rfl\n#align coe_fn_to_continuous_linear_equiv_of_continuous coe_fn_to_continuous_linear_equiv_of_continuous\n\n",
 "coe_fn_of_seq_closed_graph":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n@[simp]\ntheorem coe_fn_of_seq_closed_graph\n    (hg : ∀ (u : ℕ → E) (x y), Tendsto u atTop ((nhds) x) → Tendsto (g ∘ u) atTop ((nhds) y) → y = g x) :\n    «expr⇑ » (continuous_linear_map.of_seq_closed_graph hg) = g :=\n  rfl\n#align coe_fn_of_seq_closed_graph coe_fn_of_seq_closed_graph\n\n",
 "coe_fn_of_is_closed_graph":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n@[simp]\ntheorem coe_fn_of_is_closed_graph (hg : IsClosed (g.graph : Set <| E × F)) :\n    «expr⇑ » (continuous_linear_map.of_is_closed_graph hg) = g :=\n  rfl\n#align coe_fn_of_is_closed_graph coe_fn_of_is_closed_graph\n\n",
 "coe_fn_of_bijective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n@[simp]\ntheorem coe_fn_of_bijective (f : «expr →L[ ] » E 𝕜 F) (hinj : ker f = «expr⊥») (hsurj : LinearMap.range f = «expr⊤») :\n    «expr⇑ » (of_bijective f hinj hsurj) = f :=\n  rfl\n#align coe_fn_of_bijective coe_fn_of_bijective\n\n",
 "closure_preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem closure_preimage (hsurj : surjective f) (s : Set F) : closure («expr ⁻¹' » f s) = «expr ⁻¹' » f (closure s) :=\n  ((f.is_open_map hsurj).preimage_closure_eq_closure_preimage f.continuous s).symm\n#align closure_preimage closure_preimage\n\n",
 "closed_complemented_range_of_is_compl_of_ker_eq_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- TODO: remove the assumption `f.ker = ⊥` in the next lemma, by using the map induced by `f` on\n`E / f.ker`, once we have quotient normed spaces. -/\ntheorem closed_complemented_range_of_is_compl_of_ker_eq_bot (f : «expr →L[ ] » E 𝕜 F) (G : Submodule 𝕜 F)\n    (h : IsCompl (LinearMap.range f) G) (hG : IsClosed (G : Set F)) (hker : ker f = «expr⊥») :\n    IsClosed (LinearMap.range f : Set F) :=\n  by\n  haveI : CompleteSpace G := hG.complete_space_coe\n  let g := coprod_subtypeL_equiv_of_is_compl f h hker\n  rw [congr_arg coe (range_eq_map_coprod_subtypeL_equiv_of_is_compl f h hker)]\n  apply g.to_homeomorph.is_closed_image.2\n  exact is_closed_univ.prod isClosed_singleton\n#align closed_complemented_range_of_is_compl_of_ker_eq_bot closed_complemented_range_of_is_compl_of_ker_eq_bot\n\n",
 "bound":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem nonlinear_right_inverse.bound {f : «expr →L[ ] » E 𝕜 F} (fsymm : nonlinear_right_inverse f) (y : F) :\n    «expr‖ ‖» (fsymm y) ≤ fsymm.nnnorm * «expr‖ ‖» y :=\n  fsymm.bound' y\n#align nonlinear_right_inverse.bound nonlinear_right_inverse.bound\n\n",
 "QuotientMap":
 "#print QuotientMap /-\nprotected theorem QuotientMap (surj : surjective f) : QuotientMap f :=\n  (f.is_open_map surj).to_quotient_map f.continuous surj\n#align quotient_map QuotientMap\n-/\n\n",
 "IsOpenMap":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n#print IsOpenMap /-\n/-- The Banach open mapping theorem: a surjective bounded linear map between Banach spaces is\nopen. -/\nprotected theorem IsOpenMap (surj : surjective f) : IsOpenMap f :=\n  by\n  intro s hs\n  rcases exists_preimage_norm_le f surj with ⟨C, Cpos, hC⟩\n  refine' is_open_iff.2 fun y yfs => _\n  rcases mem_image_iff_bex.1 yfs with ⟨x, xs, fxy⟩\n  rcases is_open_iff.1 hs x xs with ⟨ε, εpos, hε⟩\n  refine' ⟨ε / C, div_pos εpos Cpos, fun z hz => _⟩\n  rcases hC (z - y) with ⟨w, wim, wnorm⟩\n  have : f (x + w) = z := by rw [f.map_add, wim, fxy, add_sub_cancel'_right]\n  rw [← this]\n  have : x + w ∈ ball x ε :=\n    calc\n      dist (x + w) x = «expr‖ ‖» w := by\n        rw [dist_eq_norm]\n        simp\n      _ ≤ C * «expr‖ ‖» (z - y) := wnorm\n      _ < C * (ε / C) := by\n        apply mul_lt_mul_of_pos_left _ Cpos\n        rwa [mem_ball, dist_eq_norm] at hz\n      _ = ε := mul_div_cancel' _ (ne_of_gt Cpos)\n      \n  exact Set.mem_image_of_mem _ (hε this)\n#align is_open_map IsOpenMap\n-/\n\n"}