{"banach_steinhaus_supr_nnnorm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/-- This version of Banach-Steinhaus is stated in terms of suprema of `↑‖⬝‖₊ : ℝ≥0∞`\nfor convenience. -/\ntheorem banach_steinhaus_supr_nnnorm {ι : Type _} [complete_space E] {g : ι → «expr →SL[ ] » E σ₁₂ F}\n    (h :\n      ∀ x,\n        «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n            ↑(«expr‖ ‖₊» (g i x)) <\n          ennreal.top) :\n    «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n        ↑(«expr‖ ‖₊» (g i)) <\n      ennreal.top :=\n  by\n  have h' : ∀ x : E, ∃ C : exprℝ, ∀ i : ι, «expr‖ ‖» (g i x) ≤ C :=\n    by\n    intro x\n    rcases lt_iff_exists_coe.mp (h x) with ⟨p, hp₁, _⟩\n    refine' ⟨p, fun i => _⟩\n    exact_mod_cast\n      calc\n        («expr‖ ‖₊» (g i x) : ennreal) ≤\n            «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n              («expr‖ ‖₊» (g j x)) :=\n          le_supᵢ _ i\n        _ = p := hp₁\n        \n  cases' banach_steinhaus h' with C' hC'\n  refine' (supᵢ_le fun i => _).trans_lt (@coe_lt_top C'.to_nnreal)\n  rw [← norm_to_nnreal]\n  exact coe_mono (real.to_nnreal_le_to_nnreal <| hC' i)\n#align banach_steinhaus_supr_nnnorm banach_steinhaus_supr_nnnorm\n\n",
 "banach_steinhaus":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/-\nCopyright (c) 2021 Jireh Loreaux. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Jireh Loreaux\n-/\n/-- This is the standard Banach-Steinhaus theorem, or Uniform Boundedness Principle.\nIf a family of continuous linear maps from a Banach space into a normed space is pointwise\nbounded, then the norms of these linear maps are uniformly bounded. -/\ntheorem banach_steinhaus {ι : Type _} [complete_space E] {g : ι → «expr →SL[ ] » E σ₁₂ F}\n    (h : ∀ x, ∃ C, ∀ i, «expr‖ ‖» (g i x) ≤ C) : ∃ C', ∀ i, «expr‖ ‖» (g i) ≤ C' :=\n  by\n  -- sequence of subsets consisting of those `x : E` with norms `‖g i x‖` bounded by `n`\n  let e : ℕ → set E := fun n =>\n    «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\"\n      { x : E | «expr‖ ‖» (g i x) ≤ n }\n  -- each of these sets is closed\n  have hc : ∀ n : ℕ, is_closed (e n) := fun i =>\n    is_closed_Inter fun i => is_closed_le (continuous.norm (g i).cont) continuous_const\n  -- the union is the entire space; this is where we use `h`\n  have hU :\n    «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (e n) = univ :=\n    by\n    refine' eq_univ_of_forall fun x => _\n    cases' h x with C hC\n    obtain ⟨m, hm⟩ := exists_nat_ge C\n    exact ⟨e m, mem_range_self m, mem_Inter.mpr fun i => le_trans (hC i) hm⟩\n  -- apply the Baire category theorem to conclude that for some `m : ℕ`, `e m` contains some `x`\n  rcases nonempty_interior_of_Union_of_closed hc hU with ⟨m, x, hx⟩\n  rcases metric.is_open_iff.mp is_open_interior x hx with ⟨ε, ε_pos, hε⟩\n  obtain ⟨k, hk⟩ := normed_field.exists_one_lt_norm 𝕜\n  -- show all elements in the ball have norm bounded by `m` after applying any `g i`\n  have real_norm_le : ∀ z : E, z ∈ metric.ball x ε → ∀ i : ι, «expr‖ ‖» (g i z) ≤ m :=\n    by\n    intro z hz i\n    replace hz := mem_Inter.mp (interior_Inter_subset _ (hε hz)) i\n    apply interior_subset hz\n  have εk_pos : 0 < ε / «expr‖ ‖» k := div_pos ε_pos (zero_lt_one.trans hk)\n  refine' ⟨(m + m : ℕ) / (ε / «expr‖ ‖» k), fun i => continuous_linear_map.op_norm_le_of_shell ε_pos _ hk _⟩\n  · exact div_nonneg (nat.cast_nonneg _) εk_pos.le\n  intro y le_y y_lt\n  calc\n    «expr‖ ‖» (g i y) = «expr‖ ‖» (g i (y + x) - g i x) := by rw [continuous_linear_map.map_add, add_sub_cancel]\n    _ ≤ «expr‖ ‖» (g i (y + x)) + «expr‖ ‖» (g i x) := norm_sub_le _ _\n    _ ≤ m + m :=\n      add_le_add (real_norm_le (y + x) (by rwa [add_comm, add_mem_ball_iff_norm]) i)\n        (real_norm_le x (metric.mem_ball_self ε_pos) i)\n    _ = (m + m : ℕ) := (m.cast_add m).symm\n    _ ≤ (m + m : ℕ) * («expr‖ ‖» y / (ε / «expr‖ ‖» k)) :=\n      le_mul_of_one_le_right (nat.cast_nonneg _) ((one_le_div <| div_pos ε_pos (zero_lt_one.trans hk)).2 le_y)\n    _ = (m + m : ℕ) / (ε / «expr‖ ‖» k) * «expr‖ ‖» y := (mul_comm_div _ _ _).symm\n    \n#align banach_steinhaus banach_steinhaus\n\n"}