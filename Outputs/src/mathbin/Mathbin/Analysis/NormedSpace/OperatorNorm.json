{"unit_le_op_norm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/-- The image of the unit ball under a continuous linear map is bounded. -/\ntheorem unit_le_op_norm : «expr‖ ‖» x ≤ 1 → «expr‖ ‖» (f x) ≤ «expr‖ ‖» f :=\n  mul_one («expr‖ ‖» f) ▸ f.le_op_norm_of_le\n#align unit_le_op_norm unit_le_op_norm\n\n",
 "to_span_singleton_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem _root_.linear_isometry.to_span_singleton_apply {v : E} (hv : «expr‖ ‖» v = 1) (a : 𝕜) :\n    linear_isometry.to_span_singleton 𝕜 E hv a = «expr • » a v :=\n  rfl\n#align linear_isometry.to_span_singleton_apply linear_isometry.to_span_singleton_apply\n\n",
 "tmp_uniform_space_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\nprotected theorem tmp_uniform_space_eq :\n    (continuous_linear_map.tmp_uniform_space : UniformSpace («expr →SL[ ] » E σ₁₂ F)) =\n      continuous_linear_map.uniform_space :=\n  by\n  rw [← @UniformAddGroup.toUniformSpace_eq _ continuous_linear_map.tmp_uniform_space, ←\n    @UniformAddGroup.toUniformSpace_eq _ continuous_linear_map.uniform_space]\n  congr 1\n  exact continuous_linear_map.tmp_topology_eq\n#align tmp_uniform_space_eq tmp_uniform_space_eq\n\n",
 "tmp_topology_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\nprotected theorem tmp_topology_eq :\n    (continuous_linear_map.tmp_topological_space : TopologicalSpace («expr →SL[ ] » E σ₁₂ F)) =\n      continuous_linear_map.topological_space :=\n  by\n  refine'\n    continuous_linear_map.tmp_topological_add_group.ext inferInstance\n      ((@Metric.nhds_basis_closedBall _ continuous_linear_map.tmp_pseudo_metric_space 0).ext\n        (ContinuousLinearMap.hasBasis_nhds_zero_of_basis Metric.nhds_basis_closedBall) _ _)\n  · rcases NormedField.exists_norm_lt_one 𝕜 with ⟨c, hc₀, hc₁⟩\n    refine' fun ε hε =>\n      ⟨⟨closed_ball 0 (1 / «expr‖ ‖» c), ε⟩, ⟨NormedSpace.isVonNBounded_closedBall _ _ _, hε⟩, fun f hf => _⟩\n    change ∀ x, _ at hf\n    simp_rw [mem_closedBall_zero_iff] at hf\n    rw [@mem_closedBall_zero_iff _ SeminormedAddCommGroup.toSeminormedAddGroup]\n    refine' op_norm_le_of_shell' (div_pos one_pos hc₀) hε.le hc₁ fun x hx₁ hxc => _\n    rw [div_mul_cancel 1 hc₀.ne.symm] at hx₁\n    exact (hf x hxc.le).trans (le_mul_of_one_le_right hε.le hx₁)\n  · rintro ⟨S, ε⟩ ⟨hS, hε⟩\n    rw [NormedSpace.isVonNBounded_iff, ← bounded_iff_is_bounded] at hS\n    rcases hS.subset_ball_lt 0 0 with ⟨δ, hδ, hSδ⟩\n    exact\n      ⟨ε / δ, div_pos hε hδ,\n        (continuous_linear_map.tmp_closed_ball_div_subset hε hδ).trans fun f hf x hx => hf x <| hSδ hx⟩\n#align tmp_topology_eq tmp_topology_eq\n\n",
 "tmp_topological_add_group":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\nprotected theorem tmp_topological_add_group : TopologicalAddGroup («expr →SL[ ] » E σ₁₂ F) :=\n  inferInstance\n#align tmp_topological_add_group tmp_topological_add_group\n\n",
 "tmp_closed_ball_div_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\nprotected theorem tmp_closed_ball_div_subset {a b : exprℝ} (ha : 0 < a) (hb : 0 < b) :\n    closedBall (0 : «expr →SL[ ] » E σ₁₂ F) (a / b) ⊆ { f | ∀ x ∈ closedBall (0 : E) b, f x ∈ closedBall (0 : F) a } :=\n  by\n  intro f hf x hx\n  rw [mem_closedBall_zero_iff] at hf hx⊢\n  calc\n    «expr‖ ‖» (f x) ≤ «expr‖ ‖» f * «expr‖ ‖» x := le_op_norm _ _\n    _ ≤ a / b * b := (mul_le_mul hf hx (norm_nonneg _) (div_pos ha hb).le)\n    _ = a := div_mul_cancel a hb.ne.symm\n    \n#align tmp_closed_ball_div_subset tmp_closed_ball_div_subset\n\n",
 "tendsto_of_tendsto_pointwise_of_cauchy_seq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n-- `f` is a linear map due to `linear_map_of_mem_closure_range_coe`\n-- We need to show that `f` has bounded norm. Choose `C` such that `‖g‖ ≤ C` for all `g ∈ s`.\n-- Then `‖g x‖ ≤ C * ‖x‖` for all `g ∈ s`, `x : E`, hence `‖f x‖ ≤ C * ‖x‖` for all `x`.\n/-- If a Cauchy sequence of continuous linear map converges to a continuous linear map pointwise,\nthen it converges to the same map in norm. This lemma is used to prove that the space of continuous\nlinear maps is complete provided that the codomain is a complete space. -/\ntheorem tendsto_of_tendsto_pointwise_of_cauchy_seq {f : ℕ → «expr →SL[ ] » E' σ₁₂ F} {g : «expr →SL[ ] » E' σ₁₂ F}\n    (hg : Tendsto (fun n x => f n x) atTop ((nhds) g)) (hf : CauchySeq f) : Tendsto f atTop ((nhds) g) :=\n  by\n  /- Since `f` is a Cauchy sequence, there exists `b → 0` such that `‖f n - f m‖ ≤ b N` for any\n    `m, n ≥ N`. -/\n  rcases cauchySeq_iff_le_tendsto_0.1 hf with ⟨b, hb₀, hfb, hb_lim⟩\n  -- Since `b → 0`, it suffices to show that `‖f n x - g x‖ ≤ b n * ‖x‖` for all `n` and `x`.\n  suffices : ∀ n x, «expr‖ ‖» (f n x - g x) ≤ b n * «expr‖ ‖» x\n  exact\n    tendsto_iff_norm_tendsto_zero.2\n      (squeeze_zero (fun n => norm_nonneg _) (fun n => op_norm_le_bound _ (hb₀ n) (this n)) hb_lim)\n  intro n x\n  -- Note that `f m x → g x`, hence `‖f n x - f m x‖ → ‖f n x - g x‖` as `m → ∞`\n  have : tendsto (fun m => «expr‖ ‖» (f n x - f m x)) at_top ((nhds) («expr‖ ‖» (f n x - g x))) :=\n    (tendsto_const_nhds.sub <| tendsto_pi_nhds.1 hg _).norm\n  -- Thus it suffices to verify `‖f n x - f m x‖ ≤ b n * ‖x‖` for `m ≥ n`.\n  refine' le_of_tendsto this (eventually_at_top.2 ⟨n, fun m hm => _⟩)\n  -- This inequality follows from `‖f n - f m‖ ≤ b n`.\n  exact (f n - f m).le_of_op_norm_le (hfb _ _ _ le_rfl hm) _\n#align tendsto_of_tendsto_pointwise_of_cauchy_seq tendsto_of_tendsto_pointwise_of_cauchy_seq\n\n",
 "subsingleton_or_norm_symm_pos":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\ntheorem subsingleton_or_norm_symm_pos [RingHomIsometric σ₁₂] (e : «expr ≃SL[ ] » E σ₁₂ F) :\n    subsingleton E ∨ 0 < «expr‖ ‖» (e.symm : «expr →SL[ ] » F σ₂₁ E) :=\n  by\n  rcases subsingleton_or_nontrivial E with (_i | _i) <;> skip\n  · left\n    infer_instance\n  · right\n    exact e.norm_symm_pos\n#align subsingleton_or_norm_symm_pos subsingleton_or_norm_symm_pos\n\n",
 "subsingleton_or_nnnorm_symm_pos":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\ntheorem subsingleton_or_nnnorm_symm_pos [RingHomIsometric σ₁₂] (e : «expr ≃SL[ ] » E σ₁₂ F) :\n    subsingleton E ∨ 0 < «expr‖ ‖₊» (e.symm : «expr →SL[ ] » F σ₂₁ E) :=\n  subsingleton_or_norm_symm_pos e\n#align subsingleton_or_nnnorm_symm_pos subsingleton_or_nnnorm_symm_pos\n\n",
 "restrict_scalars_isometry_to_linear_map":
 "@[simp]\ntheorem restrict_scalars_isometry_to_linear_map :\n    (restrict_scalars_isometry 𝕜 E Fₗ 𝕜' 𝕜'').to_linear_map = restrictScalarsₗ 𝕜 E Fₗ 𝕜' 𝕜'' :=\n  rfl\n#align restrict_scalars_isometry_to_linear_map restrict_scalars_isometry_to_linear_map\n\n",
 "ratio_le_op_norm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem ratio_le_op_norm : «expr‖ ‖» (f x) / «expr‖ ‖» x ≤ «expr‖ ‖» f :=\n  div_le_of_nonneg_of_le_mul (norm_nonneg _) f.op_norm_nonneg (le_op_norm _ _)\n#align ratio_le_op_norm ratio_le_op_norm\n\n",
 "prod_map_equivL":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\ntheorem _root_.continuous_on.prod_map_equivL {f : X → «expr ≃L[ ] » M₁ 𝕜 M₂} {g : X → «expr ≃L[ ] » M₃ 𝕜 M₄} {s : Set X}\n    (hf : ContinuousOn (fun x => (f x : «expr →L[ ] » M₁ 𝕜 M₂)) s)\n    (hg : ContinuousOn (fun x => (g x : «expr →L[ ] » M₃ 𝕜 M₄)) s) :\n    ContinuousOn (fun x => ((f x).prod (g x) : «expr →L[ ] » (M₁ × M₃) 𝕜 (M₂ × M₄))) s :=\n  (prod_mapL 𝕜 M₁ M₂ M₃ M₄).continuous.comp_continuous_on (hf.prod hg)\n#align continuous_on.prod_map_equivL continuous_on.prod_map_equivL\n\n",
 "prod_mapL_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n@[simp]\ntheorem prod_mapL_apply (p : «expr →L[ ] » M₁ 𝕜 M₂ × «expr →L[ ] » M₃ 𝕜 M₄) :\n    continuous_linear_map.prod_mapL 𝕜 M₁ M₂ M₃ M₄ p = p.1.prod_map p.2 :=\n  rfl\n#align prod_mapL_apply prod_mapL_apply\n\n",
 "prod_mapL":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\ntheorem _root_.continuous_on.prod_mapL {f : X → «expr →L[ ] » M₁ 𝕜 M₂} {g : X → «expr →L[ ] » M₃ 𝕜 M₄} {s : Set X}\n    (hf : ContinuousOn f s) (hg : ContinuousOn g s) : ContinuousOn (fun x => (f x).prod_map (g x)) s :=\n  ((prod_mapL 𝕜 M₁ M₂ M₃ M₄).continuous.comp_continuous_on (hf.prod hg) : _)\n#align continuous_on.prod_mapL continuous_on.prod_mapL\n\n",
 "op_norm_zero_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/-- An operator is zero iff its norm vanishes. -/\ntheorem op_norm_zero_iff [RingHomIsometric σ₁₂] : «expr‖ ‖» f = 0 ↔ f = 0 :=\n  iff.intro\n    (fun hn =>\n      ContinuousLinearMap.ext fun x =>\n        norm_le_zero_iff.1\n          (calc\n            _ ≤ «expr‖ ‖» f * «expr‖ ‖» x := le_op_norm _ _\n            _ = _ := by rw [hn, MulZeroClass.zero_mul]\n            ))\n    (by\n      rintro rfl\n      exact op_norm_zero)\n#align op_norm_zero_iff op_norm_zero_iff\n\n",
 "op_norm_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n/-- The norm of the `0` operator is `0`. -/\ntheorem op_norm_zero : «expr‖ ‖» (0 : «expr →SL[ ] » E σ₁₂ F) = 0 :=\n  le_antisymm\n    (cinfₛ_le bounds_bdd_below\n      ⟨le_rfl, fun _ =>\n        le_of_eq\n          (by\n            rw [MulZeroClass.zero_mul]\n            exact norm_zero)⟩)\n    (op_norm_nonneg _)\n#align op_norm_zero op_norm_zero\n\n",
 "op_norm_subsingleton":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n@[simp, nontriviality]\ntheorem op_norm_subsingleton [subsingleton E] : «expr‖ ‖» f = 0 :=\n  by\n  refine' le_antisymm _ (norm_nonneg _)\n  apply op_norm_le_bound _ rfl.ge\n  intro x\n  simp [subsingleton.elim x 0]\n#align op_norm_subsingleton op_norm_subsingleton\n\n",
 "op_norm_smul_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem op_norm_smul_le {𝕜' : Type _} [NormedField 𝕜'] [NormedSpace 𝕜' F] [SMulCommClass 𝕜₂ 𝕜' F] (c : 𝕜')\n    (f : «expr →SL[ ] » E σ₁₂ F) : «expr‖ ‖» («expr • » c f) ≤ «expr‖ ‖» c * «expr‖ ‖» f :=\n  («expr • » c f).op_norm_le_bound (mul_nonneg (norm_nonneg _) (op_norm_nonneg _)) fun _ =>\n    by\n    erw [norm_smul, mul_assoc]\n    exact mul_le_mul_of_nonneg_left (le_op_norm _ _) (norm_nonneg _)\n#align op_norm_smul_le op_norm_smul_le\n\n",
 "op_norm_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n@[simp]\ntheorem op_norm_prod (f : «expr →L[ ] » E 𝕜 Fₗ) (g : «expr →L[ ] » E 𝕜 Gₗ) : «expr‖ ‖» (f.prod g) = «expr‖ ‖» (f, g) :=\n  le_antisymm\n      (op_norm_le_bound _ (norm_nonneg _) fun x => by\n        simpa only [prod_apply, Prod.norm_def, max_mul_of_nonneg, norm_nonneg] using\n          max_le_max (le_op_norm f x) (le_op_norm g x)) <|\n    max_le (op_norm_le_bound _ (norm_nonneg _) fun x => (le_max_left _ _).trans ((f.prod g).le_op_norm x))\n      (op_norm_le_bound _ (norm_nonneg _) fun x => (le_max_right _ _).trans ((f.prod g).le_op_norm x))\n#align op_norm_prod op_norm_prod\n\n",
 "op_norm_nonneg":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem op_norm_nonneg : 0 ≤ «expr‖ ‖» f :=\n  le_cinfₛ bounds_nonempty fun _ ⟨hx, _⟩ => hx\n#align op_norm_nonneg op_norm_nonneg\n\n",
 "op_norm_neg":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem op_norm_neg (f : «expr →SL[ ] » E σ₁₂ F) : «expr‖ ‖» (-f) = «expr‖ ‖» f := by\n  simp only [norm_def, neg_apply, norm_neg]\n#align op_norm_neg op_norm_neg\n\n",
 "op_norm_mul_left_right_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem op_norm_mul_left_right_le : «expr‖ ‖» (mul_left_right 𝕜 𝕜') ≤ 1 :=\n  op_norm_le_bound _ zero_le_one fun x => (one_mul («expr‖ ‖» x)).symm ▸ op_norm_mul_left_right_apply_le 𝕜 𝕜' x\n#align op_norm_mul_left_right_le op_norm_mul_left_right_le\n\n",
 "op_norm_mul_left_right_apply_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem op_norm_mul_left_right_apply_le (x : 𝕜') : «expr‖ ‖» (mul_left_right 𝕜 𝕜' x) ≤ «expr‖ ‖» x :=\n  op_norm_le_bound _ (norm_nonneg x) (op_norm_mul_left_right_apply_apply_le 𝕜 𝕜' x)\n#align op_norm_mul_left_right_apply_le op_norm_mul_left_right_apply_le\n\n",
 "op_norm_mul_left_right_apply_apply_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem op_norm_mul_left_right_apply_apply_le (x y : 𝕜') :\n    «expr‖ ‖» (mul_left_right 𝕜 𝕜' x y) ≤ «expr‖ ‖» x * «expr‖ ‖» y :=\n  (op_norm_comp_le _ _).trans <|\n    (mul_comm _ _).trans_le <|\n      mul_le_mul (op_norm_mul_apply_le _ _ _)\n        (op_norm_le_bound _ (norm_nonneg _) fun _ => (norm_mul_le _ _).trans_eq (mul_comm _ _)) (norm_nonneg _)\n        (norm_nonneg _)\n#align op_norm_mul_left_right_apply_apply_le op_norm_mul_left_right_apply_apply_le\n\n",
 "op_norm_mul_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem op_norm_mul_le : «expr‖ ‖» (mul 𝕜 𝕜') ≤ 1 :=\n  linear_map.mk_continuous₂_norm_le _ zero_le_one _\n#align op_norm_mul_le op_norm_mul_le\n\n",
 "op_norm_mul_apply_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n@[simp]\ntheorem op_norm_mul_apply_le (x : 𝕜') : «expr‖ ‖» (mul 𝕜 𝕜' x) ≤ «expr‖ ‖» x :=\n  op_norm_le_bound _ (norm_nonneg x) (norm_mul_le x)\n#align op_norm_mul_apply_le op_norm_mul_apply_le\n\n",
 "op_norm_mul_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n@[simp]\ntheorem op_norm_mul_apply (x : 𝕜') : «expr‖ ‖» (mul 𝕜 𝕜' x) = «expr‖ ‖» x :=\n  (mulₗᵢ 𝕜 𝕜').norm_map x\n#align op_norm_mul_apply op_norm_mul_apply\n\n",
 "op_norm_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n@[simp]\ntheorem op_norm_mul [NormOneClass 𝕜'] : «expr‖ ‖» (mul 𝕜 𝕜') = 1 :=\n  haveI := NormOneClass.nontrivial 𝕜'\n  (mulₗᵢ 𝕜 𝕜').norm_to_continuous_linear_map\n#align op_norm_mul op_norm_mul\n\n",
 "op_norm_lsmul_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/-- The norm of `lsmul` is at most 1 in any semi-normed group. -/\ntheorem op_norm_lsmul_le : «expr‖ ‖» (lsmul 𝕜 𝕜' : «expr →L[ ] » 𝕜' 𝕜 («expr →L[ ] » E 𝕜 E)) ≤ 1 :=\n  by\n  refine' continuous_linear_map.op_norm_le_bound _ zero_le_one fun x => _\n  simp_rw [one_mul]\n  exact op_norm_lsmul_apply_le _\n#align op_norm_lsmul_le op_norm_lsmul_le\n\n",
 "op_norm_lsmul_apply_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem op_norm_lsmul_apply_le (x : 𝕜') : «expr‖ ‖» (lsmul 𝕜 𝕜' x : «expr →L[ ] » E 𝕜 E) ≤ «expr‖ ‖» x :=\n  continuous_linear_map.op_norm_le_bound _ (norm_nonneg x) fun y => norm_smul_le x y\n#align op_norm_lsmul_apply_le op_norm_lsmul_apply_le\n\n",
 "op_norm_lsmul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/-- The norm of `lsmul` equals 1 in any nontrivial normed group.\n\nThis is `continuous_linear_map.op_norm_lsmul_le` as an equality. -/\n@[simp]\ntheorem op_norm_lsmul [NormedField 𝕜'] [NormedAlgebra 𝕜 𝕜'] [NormedSpace 𝕜' E] [IsScalarTower 𝕜 𝕜' E] [Nontrivial E] :\n    «expr‖ ‖» (lsmul 𝕜 𝕜' : «expr →L[ ] » 𝕜' 𝕜 («expr →L[ ] » E 𝕜 E)) = 1 :=\n  by\n  refine' continuous_linear_map.op_norm_eq_of_bounds zero_le_one (fun x => _) fun N hN h => _\n  · rw [one_mul]\n    exact op_norm_lsmul_apply_le _\n  obtain ⟨y, hy⟩ := exists_ne (0 : E)\n  have := le_of_op_norm_le _ (h 1) y\n  simp_rw [lsmul_apply, one_smul, norm_one, mul_one] at this\n  refine' le_of_mul_le_mul_right _ (norm_pos_iff.mpr hy)\n  simp_rw [one_mul, this]\n#align op_norm_lsmul op_norm_lsmul\n\n",
 "op_norm_le_of_unit_norm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/-- For a continuous real linear map `f`, if one controls the norm of every `f x`, `‖x‖ = 1`, then\none controls the norm of `f`. -/\ntheorem op_norm_le_of_unit_norm [NormedSpace (exprℝ) E] [NormedSpace (exprℝ) F] {f : «expr →L[ ] » E (exprℝ) F}\n    {C : exprℝ} (hC : 0 ≤ C) (hf : ∀ x, «expr‖ ‖» x = 1 → «expr‖ ‖» (f x) ≤ C) : «expr‖ ‖» f ≤ C :=\n  by\n  refine' op_norm_le_bound' f hC fun x hx => _\n  have H₁ : «expr‖ ‖» («expr • » («expr‖ ‖» x)⁻¹ x) = 1 := by rw [norm_smul, norm_inv, norm_norm, inv_mul_cancel hx]\n  have H₂ := hf _ H₁\n  rwa [map_smul, norm_smul, norm_inv, norm_norm, ← div_eq_inv_mul, div_le_iff] at H₂\n  exact (norm_nonneg x).lt_of_ne' hx\n#align op_norm_le_of_unit_norm op_norm_le_of_unit_norm\n\n",
 "op_norm_le_of_shell'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem op_norm_le_of_shell' {f : «expr →SL[ ] » E σ₁₂ F} {ε C : exprℝ} (ε_pos : 0 < ε) (hC : 0 ≤ C) {c : 𝕜}\n    (hc : «expr‖ ‖» c < 1)\n    (hf : ∀ x, ε * «expr‖ ‖» c ≤ «expr‖ ‖» x → «expr‖ ‖» x < ε → «expr‖ ‖» (f x) ≤ C * «expr‖ ‖» x) : «expr‖ ‖» f ≤ C :=\n  by\n  by_cases h0 : c = 0\n  · refine' op_norm_le_of_ball ε_pos hC fun x hx => hf x _ _\n    · simp [h0]\n    · rwa [ball_zero_eq] at hx\n  · rw [← inv_inv c, norm_inv, inv_lt_one_iff_of_pos (norm_pos_iff.2 <| inv_ne_zero h0)] at hc\n    refine' op_norm_le_of_shell ε_pos hC hc _\n    rwa [norm_inv, div_eq_mul_inv, inv_inv]\n#align op_norm_le_of_shell' op_norm_le_of_shell'\n\n",
 "op_norm_le_of_shell":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem op_norm_le_of_shell {f : «expr →SL[ ] » E σ₁₂ F} {ε C : exprℝ} (ε_pos : 0 < ε) (hC : 0 ≤ C) {c : 𝕜}\n    (hc : 1 < «expr‖ ‖» c)\n    (hf : ∀ x, ε / «expr‖ ‖» c ≤ «expr‖ ‖» x → «expr‖ ‖» x < ε → «expr‖ ‖» (f x) ≤ C * «expr‖ ‖» x) : «expr‖ ‖» f ≤ C :=\n  f.op_norm_le_bound' hC fun x hx => semilinear_map_class.bound_of_shell_semi_normed f ε_pos hc hf hx\n#align op_norm_le_of_shell op_norm_le_of_shell\n\n",
 "op_norm_le_of_nhds_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem op_norm_le_of_nhds_zero {f : «expr →SL[ ] » E σ₁₂ F} {C : exprℝ} (hC : 0 ≤ C)\n    (hf :\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\"\n        ((nhds) (0 : E)) («expr‖ ‖» (f x) ≤ C * «expr‖ ‖» x)) :\n    «expr‖ ‖» f ≤ C :=\n  let ⟨ε, ε0, hε⟩ := Metric.eventually_nhds_iff_ball.1 hf\n  op_norm_le_of_ball ε0 hC hε\n#align op_norm_le_of_nhds_zero op_norm_le_of_nhds_zero\n\n",
 "op_norm_le_of_lipschitz":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem op_norm_le_of_lipschitz {f : «expr →SL[ ] » E σ₁₂ F} {K : nnreal} (hf : LipschitzWith K f) : «expr‖ ‖» f ≤ K :=\n  f.op_norm_le_bound K.2 fun x => by simpa only [dist_zero_right, f.map_zero] using hf.dist_le_mul x 0\n#align op_norm_le_of_lipschitz op_norm_le_of_lipschitz\n\n",
 "op_norm_le_of_ball":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem op_norm_le_of_ball {f : «expr →SL[ ] » E σ₁₂ F} {ε : exprℝ} {C : exprℝ} (ε_pos : 0 < ε) (hC : 0 ≤ C)\n    (hf : ∀ x ∈ ball (0 : E) ε, «expr‖ ‖» (f x) ≤ C * «expr‖ ‖» x) : «expr‖ ‖» f ≤ C :=\n  by\n  rcases NormedField.exists_one_lt_norm 𝕜 with ⟨c, hc⟩\n  refine' op_norm_le_of_shell ε_pos hC hc fun x _ hx => hf x _\n  rwa [ball_zero_eq]\n#align op_norm_le_of_ball op_norm_le_of_ball\n\n",
 "op_norm_le_bound₂":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem op_norm_le_bound₂ (f : «expr →SL[ ] » E σ₁₃ («expr →SL[ ] » F σ₂₃ G)) {C : exprℝ} (h0 : 0 ≤ C)\n    (hC : ∀ x y, «expr‖ ‖» (f x y) ≤ C * «expr‖ ‖» x * «expr‖ ‖» y) : «expr‖ ‖» f ≤ C :=\n  f.op_norm_le_bound h0 fun x => (f x).op_norm_le_bound (mul_nonneg h0 (norm_nonneg _)) <| hC x\n#align op_norm_le_bound₂ op_norm_le_bound₂\n\n",
 "op_norm_le_bound'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/-- If one controls the norm of every `A x`, `‖x‖ ≠ 0`, then one controls the norm of `A`. -/\ntheorem op_norm_le_bound' (f : «expr →SL[ ] » E σ₁₂ F) {M : exprℝ} (hMp : 0 ≤ M)\n    (hM : ∀ x, «expr‖ ‖» x ≠ 0 → «expr‖ ‖» (f x) ≤ M * «expr‖ ‖» x) : «expr‖ ‖» f ≤ M :=\n  op_norm_le_bound f hMp fun x =>\n    (ne_or_eq («expr‖ ‖» x) 0).elim (hM x) fun h => by\n      simp only [h, MulZeroClass.mul_zero, norm_image_of_norm_zero f f.2 h]\n#align op_norm_le_bound' op_norm_le_bound'\n\n",
 "op_norm_le_bound":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/-- If one controls the norm of every `A x`, then one controls the norm of `A`. -/\ntheorem op_norm_le_bound (f : «expr →SL[ ] » E σ₁₂ F) {M : exprℝ} (hMp : 0 ≤ M)\n    (hM : ∀ x, «expr‖ ‖» (f x) ≤ M * «expr‖ ‖» x) : «expr‖ ‖» f ≤ M :=\n  cinfₛ_le bounds_bdd_below ⟨hMp, hM⟩\n#align op_norm_le_bound op_norm_le_bound\n\n",
 "op_norm_flip":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n@[simp]\ntheorem op_norm_flip (f : «expr →SL[ ] » E σ₁₃ («expr →SL[ ] » F σ₂₃ G)) : «expr‖ ‖» f.flip = «expr‖ ‖» f :=\n  le_antisymm (by simpa only [flip_flip] using le_norm_flip f.flip) (le_norm_flip f)\n#align op_norm_flip op_norm_flip\n\n",
 "op_norm_extend_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprψ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprψ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprψ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprψ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprψ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/-- If a dense embedding `e : E →L[𝕜] G` expands the norm by a constant factor `N⁻¹`, then the\nnorm of the extension of `f` along `e` is bounded by `N * ‖f‖`. -/\ntheorem op_norm_extend_le : «expr‖ ‖» (exprψ) ≤ N * «expr‖ ‖» f :=\n  by\n  have uni : UniformInducing e := (uniform_embedding_of_bound _ h_e).to_uniform_inducing\n  have eq : ∀ x, (exprψ) (e x) = f x := uniformly_extend_of_ind uni h_dense f.uniform_continuous\n  by_cases N0 : 0 ≤ N\n  · refine' op_norm_le_bound (exprψ) _ (isClosed_property h_dense (isClosed_le _ _) _)\n    · exact mul_nonneg N0 (norm_nonneg _)\n    · exact continuous_norm.comp (cont (exprψ))\n    · exact continuous_const.mul continuous_norm\n    · intro x\n      rw [Eq]\n      calc\n        «expr‖ ‖» (f x) ≤ «expr‖ ‖» f * «expr‖ ‖» x := le_op_norm _ _\n        _ ≤ «expr‖ ‖» f * (N * «expr‖ ‖» (e x)) := (mul_le_mul_of_nonneg_left (h_e x) (norm_nonneg _))\n        _ ≤ N * «expr‖ ‖» f * «expr‖ ‖» (e x) := by rw [mul_comm (↑N) («expr‖ ‖» f), mul_assoc]\n        \n  · have he : ∀ x : E, x = 0 := by\n      intro x\n      have N0 : N ≤ 0 := le_of_lt (lt_of_not_ge N0)\n      rw [← norm_le_zero_iff]\n      exact le_trans (h_e x) (mul_nonpos_of_nonpos_of_nonneg N0 (norm_nonneg _))\n    have hf : f = 0 := by\n      ext\n      simp only [he x, zero_apply, map_zero]\n    have hψ : exprψ = 0 := by\n      rw [hf]\n      apply extend_zero\n    rw [hψ, hf, norm_zero, norm_zero, MulZeroClass.mul_zero]\n#align op_norm_extend_le op_norm_extend_le\n\n",
 "op_norm_ext":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem op_norm_ext [RingHomIsometric σ₁₃] (f : «expr →SL[ ] » E σ₁₂ F) (g : «expr →SL[ ] » E σ₁₃ G)\n    (h : ∀ x, «expr‖ ‖» (f x) = «expr‖ ‖» (g x)) : «expr‖ ‖» f = «expr‖ ‖» g :=\n  op_norm_eq_of_bounds (norm_nonneg _)\n    (fun x => by\n      rw [h x]\n      exact le_op_norm _ _)\n    fun c hc h₂ =>\n    op_norm_le_bound _ hc fun z => by\n      rw [← h z]\n      exact h₂ z\n#align op_norm_ext op_norm_ext\n\n",
 "op_norm_eq_of_bounds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem op_norm_eq_of_bounds {φ : «expr →SL[ ] » E σ₁₂ F} {M : exprℝ} (M_nonneg : 0 ≤ M)\n    (h_above : ∀ x, «expr‖ ‖» (φ x) ≤ M * «expr‖ ‖» x)\n    (h_below : ∀ N ≥ 0, (∀ x, «expr‖ ‖» (φ x) ≤ N * «expr‖ ‖» x) → M ≤ N) : «expr‖ ‖» φ = M :=\n  le_antisymm (φ.op_norm_le_bound M_nonneg h_above)\n    ((le_cinfₛ_iff continuous_linear_map.bounds_bdd_below ⟨M, M_nonneg, h_above⟩).mpr fun N ⟨N_nonneg, hN⟩ =>\n      h_below N N_nonneg hN)\n#align op_norm_eq_of_bounds op_norm_eq_of_bounds\n\n",
 "op_norm_comp_linear_isometry_equiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₛₗᵢ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/-- Precomposition with a linear isometry preserves the operator norm. -/\ntheorem op_norm_comp_linear_isometry_equiv (f : «expr →SL[ ] » F σ₂₃ G) (g : «expr ≃ₛₗᵢ[ ] » F' σ₂' F) :\n    «expr‖ ‖» (f.comp g.to_linear_isometry.to_continuous_linear_map) = «expr‖ ‖» f :=\n  by\n  cases subsingleton_or_nontrivial F'\n  · haveI := g.symm.to_linear_equiv.to_equiv.subsingleton\n    simp\n  refine' le_antisymm _ _\n  · convert f.op_norm_comp_le g.to_linear_isometry.to_continuous_linear_map\n    simp [g.to_linear_isometry.norm_to_continuous_linear_map]\n  · convert(f.comp g.to_linear_isometry.to_continuous_linear_map).op_norm_comp_le\n        g.symm.to_linear_isometry.to_continuous_linear_map\n    · ext\n      simp\n    haveI := g.symm.surjective.nontrivial\n    simp [g.symm.to_linear_isometry.norm_to_continuous_linear_map]\n#align op_norm_comp_linear_isometry_equiv op_norm_comp_linear_isometry_equiv\n\n",
 "op_norm_comp_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/-- The operator norm is submultiplicative. -/\ntheorem op_norm_comp_le (f : «expr →SL[ ] » E σ₁₂ F) : «expr‖ ‖» (h.comp f) ≤ «expr‖ ‖» h * «expr‖ ‖» f :=\n  cinfₛ_le bounds_bdd_below\n    ⟨mul_nonneg (op_norm_nonneg _) (op_norm_nonneg _), fun x =>\n      by\n      rw [mul_assoc]\n      exact h.le_op_norm_of_le (f.le_op_norm x)⟩\n#align op_norm_comp_le op_norm_comp_le\n\n",
 "op_norm_add_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/-- The operator norm satisfies the triangle inequality. -/\ntheorem op_norm_add_le : «expr‖ ‖» (f + g) ≤ «expr‖ ‖» f + «expr‖ ‖» g :=\n  (f + g).op_norm_le_bound (add_nonneg f.op_norm_nonneg g.op_norm_nonneg) fun x =>\n    (norm_add_le_of_le (f.le_op_norm x) (g.le_op_norm x)).trans_eq (add_mul _ _ _).symm\n#align op_norm_add_le op_norm_add_le\n\n",
 "op_nnnorm_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n@[simp]\ntheorem op_nnnorm_prod (f : «expr →L[ ] » E 𝕜 Fₗ) (g : «expr →L[ ] » E 𝕜 Gₗ) :\n    «expr‖ ‖₊» (f.prod g) = «expr‖ ‖₊» (f, g) :=\n  Subtype.ext <| op_norm_prod f g\n#align op_nnnorm_prod op_nnnorm_prod\n\n",
 "op_nnnorm_le_of_unit_nnnorm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/-- For a continuous real linear map `f`, if one controls the norm of every `f x`, `‖x‖₊ = 1`, then\none controls the norm of `f`. -/\ntheorem op_nnnorm_le_of_unit_nnnorm [NormedSpace (exprℝ) E] [NormedSpace (exprℝ) F] {f : «expr →L[ ] » E (exprℝ) F}\n    {C : nnreal} (hf : ∀ x, «expr‖ ‖₊» x = 1 → «expr‖ ‖₊» (f x) ≤ C) : «expr‖ ‖₊» f ≤ C :=\n  op_norm_le_of_unit_norm C.coe_nonneg fun x hx => hf x <| by rwa [← NNReal.coe_eq_one]\n#align op_nnnorm_le_of_unit_nnnorm op_nnnorm_le_of_unit_nnnorm\n\n",
 "op_nnnorm_le_of_lipschitz":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\ntheorem op_nnnorm_le_of_lipschitz {f : «expr →SL[ ] » E σ₁₂ F} {K : nnreal} (hf : LipschitzWith K f) :\n    «expr‖ ‖₊» f ≤ K :=\n  op_norm_le_of_lipschitz hf\n#align op_nnnorm_le_of_lipschitz op_nnnorm_le_of_lipschitz\n\n",
 "op_nnnorm_le_bound'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/-- If one controls the norm of every `A x`, `‖x‖₊ ≠ 0`, then one controls the norm of `A`. -/\ntheorem op_nnnorm_le_bound' (f : «expr →SL[ ] » E σ₁₂ F) (M : nnreal)\n    (hM : ∀ x, «expr‖ ‖₊» x ≠ 0 → «expr‖ ‖₊» (f x) ≤ M * «expr‖ ‖₊» x) : «expr‖ ‖₊» f ≤ M :=\n  op_norm_le_bound' f (zero_le M) fun x hx => hM x <| by rwa [← NNReal.coe_ne_zero]\n#align op_nnnorm_le_bound' op_nnnorm_le_bound'\n\n",
 "op_nnnorm_le_bound":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/-- If one controls the norm of every `A x`, then one controls the norm of `A`. -/\ntheorem op_nnnorm_le_bound (f : «expr →SL[ ] » E σ₁₂ F) (M : nnreal) (hM : ∀ x, «expr‖ ‖₊» (f x) ≤ M * «expr‖ ‖₊» x) :\n    «expr‖ ‖₊» f ≤ M :=\n  op_norm_le_bound f (zero_le M) hM\n#align op_nnnorm_le_bound op_nnnorm_le_bound\n\n",
 "op_nnnorm_eq_of_bounds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\ntheorem op_nnnorm_eq_of_bounds {φ : «expr →SL[ ] » E σ₁₂ F} (M : nnreal)\n    (h_above : ∀ x, «expr‖ ‖» (φ x) ≤ M * «expr‖ ‖» x)\n    (h_below : ∀ N, (∀ x, «expr‖ ‖₊» (φ x) ≤ N * «expr‖ ‖₊» x) → M ≤ N) : «expr‖ ‖₊» φ = M :=\n  Subtype.ext <| op_norm_eq_of_bounds (zero_le M) h_above <| Subtype.forall'.mpr h_below\n#align op_nnnorm_eq_of_bounds op_nnnorm_eq_of_bounds\n\n",
 "op_nnnorm_comp_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\ntheorem op_nnnorm_comp_le [RingHomIsometric σ₁₃] (f : «expr →SL[ ] » E σ₁₂ F) :\n    «expr‖ ‖₊» (h.comp f) ≤ «expr‖ ‖₊» h * «expr‖ ‖₊» f :=\n  op_norm_comp_le h f\n#align op_nnnorm_comp_le op_nnnorm_comp_le\n\n",
 "one_le_norm_mul_norm_symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\ntheorem one_le_norm_mul_norm_symm [RingHomIsometric σ₁₂] [Nontrivial E] (e : «expr ≃SL[ ] » E σ₁₂ F) :\n    1 ≤ «expr‖ ‖» (e : «expr →SL[ ] » E σ₁₂ F) * «expr‖ ‖» (e.symm : «expr →SL[ ] » F σ₂₁ E) :=\n  by\n  rw [mul_comm]\n  convert(e.symm : «expr →SL[ ] » F σ₂₁ E).op_norm_comp_le (e : «expr →SL[ ] » E σ₁₂ F)\n  rw [e.coe_symm_comp_coe, continuous_linear_map.norm_id]\n#align one_le_norm_mul_norm_symm one_le_norm_mul_norm_symm\n\n",
 "norm_to_span_singleton":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem norm_to_span_singleton (x : E) : «expr‖ ‖» (toSpanSingleton 𝕜 x) = «expr‖ ‖» x :=\n  by\n  refine' op_norm_eq_of_bounds (norm_nonneg _) (fun x => _) fun N hN_nonneg h => _\n  · rw [to_span_singleton_apply, norm_smul, mul_comm]\n  · specialize h 1\n    rw [to_span_singleton_apply, norm_smul, mul_comm] at h\n    exact (mul_le_mul_right (by simp)).mp h\n#align norm_to_span_singleton norm_to_span_singleton\n\n",
 "norm_to_continuous_linear_map_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗᵢ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem norm_to_continuous_linear_map_le (f : «expr →ₛₗᵢ[ ] » E σ₁₂ F) : «expr‖ ‖» f.to_continuous_linear_map ≤ 1 :=\n  f.to_continuous_linear_map.op_norm_le_bound zero_le_one fun x => by simp\n#align norm_to_continuous_linear_map_le norm_to_continuous_linear_map_le\n\n",
 "norm_to_continuous_linear_map_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗᵢ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/-- Postcomposition of a continuous linear map with a linear isometry preserves\nthe operator norm. -/\ntheorem norm_to_continuous_linear_map_comp [RingHomIsometric σ₁₂] (f : «expr →ₛₗᵢ[ ] » F σ₂₃ G)\n    {g : «expr →SL[ ] » E σ₁₂ F} : «expr‖ ‖» (f.to_continuous_linear_map.comp g) = «expr‖ ‖» g :=\n  op_norm_ext (f.to_continuous_linear_map.comp g) g fun x => by\n    simp only [norm_map, coe_to_continuous_linear_map, coe_comp']\n#align norm_to_continuous_linear_map_comp norm_to_continuous_linear_map_comp\n\n",
 "norm_to_continuous_linear_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗᵢ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n@[simp]\ntheorem norm_to_continuous_linear_map [Nontrivial E] [RingHomIsometric σ₁₂] (f : «expr →ₛₗᵢ[ ] » E σ₁₂ F) :\n    «expr‖ ‖» f.to_continuous_linear_map = 1 :=\n  f.to_continuous_linear_map.homothety_norm <| by simp\n#align norm_to_continuous_linear_map norm_to_continuous_linear_map\n\n",
 "norm_symm_pos":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\ntheorem norm_symm_pos [RingHomIsometric σ₁₂] [Nontrivial E] (e : «expr ≃SL[ ] » E σ₁₂ F) :\n    0 < «expr‖ ‖» (e.symm : «expr →SL[ ] » F σ₂₁ E) :=\n  pos_of_mul_pos_right (zero_lt_one.trans_le e.one_le_norm_mul_norm_symm) (norm_nonneg _)\n#align norm_symm_pos norm_symm_pos\n\n",
 "norm_subtypeL_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem norm_subtypeL_le (K : Submodule 𝕜 E) : «expr‖ ‖» K.subtypeL ≤ 1 :=\n  K.subtypeₗᵢ.norm_to_continuous_linear_map_le\n#align norm_subtypeL_le norm_subtypeL_le\n\n",
 "norm_subtypeL":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem norm_subtypeL (K : Submodule 𝕜 E) [Nontrivial K] : «expr‖ ‖» K.subtypeL = 1 :=\n  K.subtypeₗᵢ.norm_to_continuous_linear_map\n#align norm_subtypeL norm_subtypeL\n\n",
 "norm_smul_right_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/-- The norm of the tensor product of a scalar linear map and of an element of a normed space\nis the product of the norms. -/\n@[simp]\ntheorem norm_smul_right_apply (c : «expr →L[ ] » E 𝕜 𝕜) (f : Fₗ) :\n    «expr‖ ‖» (smulRight c f) = «expr‖ ‖» c * «expr‖ ‖» f :=\n  by\n  refine' le_antisymm _ _\n  · apply op_norm_le_bound _ (mul_nonneg (norm_nonneg _) (norm_nonneg _)) fun x => _\n    calc\n      «expr‖ ‖» («expr • » (c x) f) = «expr‖ ‖» (c x) * «expr‖ ‖» f := norm_smul _ _\n      _ ≤ «expr‖ ‖» c * «expr‖ ‖» x * «expr‖ ‖» f := (mul_le_mul_of_nonneg_right (le_op_norm _ _) (norm_nonneg _))\n      _ = «expr‖ ‖» c * «expr‖ ‖» f * «expr‖ ‖» x := by ring\n      \n  · by_cases h : f = 0\n    · simp [h]\n    · have : 0 < «expr‖ ‖» f := norm_pos_iff.2 h\n      rw [← le_div_iff this]\n      apply op_norm_le_bound _ (div_nonneg (norm_nonneg _) (norm_nonneg f)) fun x => _\n      rw [div_mul_eq_mul_div, le_div_iff this]\n      calc\n        «expr‖ ‖» (c x) * «expr‖ ‖» f = «expr‖ ‖» («expr • » (c x) f) := (norm_smul _ _).symm\n        _ = «expr‖ ‖» (smul_right c f x) := rfl\n        _ ≤ «expr‖ ‖» (smul_right c f) * «expr‖ ‖» x := le_op_norm _ _\n        \n#align norm_smul_right_apply norm_smul_right_apply\n\n",
 "norm_smul_rightL_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n@[simp]\ntheorem norm_smul_rightL_apply (c : «expr →L[ ] » E 𝕜 𝕜) (f : Fₗ) :\n    «expr‖ ‖» (smul_rightL 𝕜 E Fₗ c f) = «expr‖ ‖» c * «expr‖ ‖» f :=\n  norm_smul_right_apply c f\n#align norm_smul_rightL_apply norm_smul_rightL_apply\n\n",
 "norm_smul_rightL":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n@[simp]\ntheorem norm_smul_rightL (c : «expr →L[ ] » E 𝕜 𝕜) [Nontrivial Fₗ] : «expr‖ ‖» (smul_rightL 𝕜 E Fₗ c) = «expr‖ ‖» c :=\n  continuous_linear_map.homothety_norm _ c.norm_smul_right_apply\n#align norm_smul_rightL norm_smul_rightL\n\n",
 "norm_restrict_scalars":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n@[simp]\ntheorem norm_restrict_scalars (f : «expr →L[ ] » E 𝕜 Fₗ) : «expr‖ ‖» (f.restrict_scalars 𝕜') = «expr‖ ‖» f :=\n  le_antisymm (op_norm_le_bound _ (norm_nonneg _) fun x => f.le_op_norm x)\n    (op_norm_le_bound _ (norm_nonneg _) fun x => f.le_op_norm x)\n#align norm_restrict_scalars norm_restrict_scalars\n\n",
 "norm_precompR_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem norm_precompR_le (L : «expr →L[ ] » E 𝕜 («expr →L[ ] » Fₗ 𝕜 Gₗ)) : «expr‖ ‖» (precompR Eₗ L) ≤ «expr‖ ‖» L :=\n  calc\n    «expr‖ ‖» (precompR Eₗ L) ≤ «expr‖ ‖» (compL 𝕜 Eₗ Fₗ Gₗ) * «expr‖ ‖» L := op_norm_comp_le _ _\n    _ ≤ 1 * «expr‖ ‖» L := (mul_le_mul_of_nonneg_right (norm_compL_le _ _ _ _) (norm_nonneg _))\n    _ = «expr‖ ‖» L := by rw [one_mul]\n    \n#align norm_precompR_le norm_precompR_le\n\n",
 "norm_precompL_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem norm_precompL_le (L : «expr →L[ ] » E 𝕜 («expr →L[ ] » Fₗ 𝕜 Gₗ)) : «expr‖ ‖» (precompL Eₗ L) ≤ «expr‖ ‖» L :=\n  by\n  rw [precompL, op_norm_flip, ← op_norm_flip L]\n  exact norm_precompR_le _ L.flip\n#align norm_precompL_le norm_precompL_le\n\n",
 "norm_pos":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\ntheorem norm_pos [RingHomIsometric σ₁₂] [Nontrivial E] (e : «expr ≃SL[ ] » E σ₁₂ F) :\n    0 < «expr‖ ‖» (e : «expr →SL[ ] » E σ₁₂ F) :=\n  pos_of_mul_pos_left (lt_of_lt_of_le zero_lt_one e.one_le_norm_mul_norm_symm) (norm_nonneg _)\n#align norm_pos norm_pos\n\n",
 "norm_image_of_norm_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/-\nCopyright (c) 2019 Jan-David Salchow. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Jan-David Salchow, Sébastien Gouëzel, Jean Lo\n-/\n-- the `ₗ` subscript variables are for special cases about linear (as opposed to semilinear) maps\n/-- If `‖x‖ = 0` and `f` is continuous then `‖f x‖ = 0`. -/\ntheorem norm_image_of_norm_zero [SemilinearMapClass 𝓕 σ₁₂ E F] (f : 𝓕) (hf : Continuous f) {x : E}\n    (hx : «expr‖ ‖» x = 0) : «expr‖ ‖» (f x) = 0 :=\n  by\n  refine' le_antisymm (le_of_forall_pos_le_add fun ε hε => _) (norm_nonneg (f x))\n  rcases NormedAddCommGroup.tendsto_nhds_nhds.1 (hf.tendsto 0) ε hε with ⟨δ, δ_pos, hδ⟩\n  replace hδ := hδ x\n  rw [sub_zero, hx] at hδ\n  replace hδ := le_of_lt (hδ δ_pos)\n  rw [map_zero, sub_zero] at hδ\n  rwa [zero_add]\n#align norm_image_of_norm_zero norm_image_of_norm_zero\n\n",
 "norm_id_of_nontrivial_seminorm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/-- If there is an element with norm different from `0`, then the norm of the identity equals `1`.\n(Since we are working with seminorms supposing that the space is non-trivial is not enough.) -/\ntheorem norm_id_of_nontrivial_seminorm (h : ∃ x : E, «expr‖ ‖» x ≠ 0) : «expr‖ ‖» (id 𝕜 E) = 1 :=\n  le_antisymm norm_id_le <| by\n    let ⟨x, hx⟩ := h\n    have := (id 𝕜 E).ratio_le_op_norm x\n    rwa [id_apply, div_self hx] at this\n#align norm_id_of_nontrivial_seminorm norm_id_of_nontrivial_seminorm\n\n",
 "norm_id_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/-- The norm of the identity is at most `1`. It is in fact `1`, except when the space is trivial\nwhere it is `0`. It means that one can not do better than an inequality in general. -/\ntheorem norm_id_le : «expr‖ ‖» (id 𝕜 E) ≤ 1 :=\n  op_norm_le_bound _ zero_le_one fun x => by simp\n#align norm_id_le norm_id_le\n\n",
 "norm_id":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/-- If a normed space is non-trivial, then the norm of the identity equals `1`. -/\n@[simp]\ntheorem norm_id [Nontrivial E] : «expr‖ ‖» (id 𝕜 E) = 1 :=\n  by\n  refine' norm_id_of_nontrivial_seminorm _\n  obtain ⟨x, hx⟩ := exists_ne (0 : E)\n  exact ⟨x, ne_of_gt (norm_pos_iff.2 hx)⟩\n#align norm_id norm_id\n\n",
 "norm_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem norm_def (f : «expr →SL[ ] » E σ₁₂ F) :\n    «expr‖ ‖» f = infₛ { c | 0 ≤ c ∧ ∀ x, «expr‖ ‖» (f x) ≤ c * «expr‖ ‖» x } :=\n  rfl\n#align norm_def norm_def\n\n",
 "norm_compSL_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem norm_compSL_le : «expr‖ ‖» (compSL E F G σ₁₂ σ₂₃) ≤ 1 :=\n  linear_map.mk_continuous₂_norm_le _ zero_le_one _\n#align norm_compSL_le norm_compSL_le\n\n",
 "norm_compL_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem norm_compL_le : «expr‖ ‖» (compL 𝕜 E Fₗ Gₗ) ≤ 1 :=\n  norm_compSL_le _ _ _ _ _\n#align norm_compL_le norm_compL_le\n\n",
 "nnnorm_symm_pos":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\ntheorem nnnorm_symm_pos [RingHomIsometric σ₁₂] [Nontrivial E] (e : «expr ≃SL[ ] » E σ₁₂ F) :\n    0 < «expr‖ ‖₊» (e.symm : «expr →SL[ ] » F σ₂₁ E) :=\n  e.norm_symm_pos\n#align nnnorm_symm_pos nnnorm_symm_pos\n\n",
 "nnnorm_smul_right_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/-- The non-negative norm of the tensor product of a scalar linear map and of an element of a normed\nspace is the product of the non-negative norms. -/\n@[simp]\ntheorem nnnorm_smul_right_apply (c : «expr →L[ ] » E 𝕜 𝕜) (f : Fₗ) :\n    «expr‖ ‖₊» (smulRight c f) = «expr‖ ‖₊» c * «expr‖ ‖₊» f :=\n  NNReal.eq <| c.norm_smul_right_apply f\n#align nnnorm_smul_right_apply nnnorm_smul_right_apply\n\n",
 "nnnorm_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\ntheorem nnnorm_def (f : «expr →SL[ ] » E σ₁₂ F) :\n    «expr‖ ‖₊» f = infₛ { c | ∀ x, «expr‖ ‖₊» (f x) ≤ c * «expr‖ ‖₊» x } :=\n  by\n  ext\n  rw [NNReal.coe_infₛ, coe_nnnorm, norm_def, NNReal.coe_image]\n  simp_rw [← NNReal.coe_le_coe, NNReal.coe_mul, coe_nnnorm, mem_set_of_eq, Subtype.coe_mk, exists_prop]\n#align nnnorm_def nnnorm_def\n\n",
 "nndist_le_op_nnnorm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\ntheorem nndist_le_op_nnnorm (x y : E) : nndist (f x) (f y) ≤ «expr‖ ‖₊» f * nndist x y :=\n  dist_le_op_norm f x y\n#align nndist_le_op_nnnorm nndist_le_op_nnnorm\n\n",
 "mul_left_right_apply":
 "@[simp]\ntheorem mul_left_right_apply (x y z : 𝕜') : mul_left_right 𝕜 𝕜' x y z = x * z * y :=\n  rfl\n#align mul_left_right_apply mul_left_right_apply\n\n",
 "mul_apply'":
 "@[simp]\ntheorem mul_apply' (x y : 𝕜') : mul 𝕜 𝕜' x y = x * y :=\n  rfl\n#align mul_apply' mul_apply'\n\n",
 "mk_continuous₂_norm_le'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem mk_continuous₂_norm_le' (f : «expr →ₛₗ[ ] » E σ₁₃ («expr →ₛₗ[ ] » F σ₂₃ G)) {C : exprℝ}\n    (hC : ∀ x y, «expr‖ ‖» (f x y) ≤ C * «expr‖ ‖» x * «expr‖ ‖» y) : «expr‖ ‖» (f.mk_continuous₂ C hC) ≤ max C 0 :=\n  mk_continuous_norm_le _ (le_max_iff.2 <| or.inr le_rfl) _\n#align mk_continuous₂_norm_le' mk_continuous₂_norm_le'\n\n",
 "mk_continuous₂_norm_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem mk_continuous₂_norm_le (f : «expr →ₛₗ[ ] » E σ₁₃ («expr →ₛₗ[ ] » F σ₂₃ G)) {C : exprℝ} (h0 : 0 ≤ C)\n    (hC : ∀ x y, «expr‖ ‖» (f x y) ≤ C * «expr‖ ‖» x * «expr‖ ‖» y) : «expr‖ ‖» (f.mk_continuous₂ C hC) ≤ C :=\n  (f.mk_continuous₂_norm_le' hC).trans_eq <| max_eq_left h0\n#align mk_continuous₂_norm_le mk_continuous₂_norm_le\n\n",
 "mk_continuous₂_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n@[simp]\ntheorem mk_continuous₂_apply (f : «expr →ₛₗ[ ] » E σ₁₃ («expr →ₛₗ[ ] » F σ₂₃ G)) {C : exprℝ}\n    (hC : ∀ x y, «expr‖ ‖» (f x y) ≤ C * «expr‖ ‖» x * «expr‖ ‖» y) (x : E) (y : F) :\n    f.mk_continuous₂ C hC x y = f x y :=\n  rfl\n#align mk_continuous₂_apply mk_continuous₂_apply\n\n",
 "mk_continuous_norm_le'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/-- If a continuous linear map is constructed from a linear map via the constructor `mk_continuous`,\nthen its norm is bounded by the bound or zero if bound is negative. -/\ntheorem mk_continuous_norm_le' (f : «expr →ₛₗ[ ] » E σ₁₂ F) {C : exprℝ} (h : ∀ x, «expr‖ ‖» (f x) ≤ C * «expr‖ ‖» x) :\n    «expr‖ ‖» (f.mk_continuous C h) ≤ max C 0 :=\n  continuous_linear_map.op_norm_le_bound _ (le_max_right _ _) fun x =>\n    (h x).trans <| mul_le_mul_of_nonneg_right (le_max_left _ _) (norm_nonneg x)\n#align mk_continuous_norm_le' mk_continuous_norm_le'\n\n",
 "mk_continuous_norm_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/-- If a continuous linear map is constructed from a linear map via the constructor `mk_continuous`,\nthen its norm is bounded by the bound given to the constructor if it is nonnegative. -/\ntheorem mk_continuous_norm_le (f : «expr →ₛₗ[ ] » E σ₁₂ F) {C : exprℝ} (hC : 0 ≤ C)\n    (h : ∀ x, «expr‖ ‖» (f x) ≤ C * «expr‖ ‖» x) : «expr‖ ‖» (f.mk_continuous C h) ≤ C :=\n  continuous_linear_map.op_norm_le_bound _ hC h\n#align mk_continuous_norm_le mk_continuous_norm_le\n\n",
 "map_add_add":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\ntheorem map_add_add (f : «expr →L[ ] » E 𝕜 («expr →L[ ] » Fₗ 𝕜 Gₗ)) (x x' : E) (y y' : Fₗ) :\n    f (x + x') (y + y') = f x y + f.deriv₂ (x, y) (x', y') + f x' y' := by\n  simp only [map_add, add_apply, coe_deriv₂, add_assoc]\n#align map_add_add map_add_add\n\n",
 "lsmul_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem lsmul_apply (c : 𝕜') (x : E) : lsmul 𝕜 𝕜' c x = «expr • » c x :=\n  rfl\n#align lsmul_apply lsmul_apply\n\n",
 "lipschitz_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n/-- Evaluation of a continuous linear map `f` at a point is Lipschitz continuous in `f`. -/\ntheorem lipschitz_apply (x : E) : LipschitzWith («expr‖ ‖₊» x) fun f : «expr →SL[ ] » E σ₁₂ F => f x :=\n  lipschitzWith_iff_norm_sub_le.2 fun f g => ((f - g).le_op_norm x).trans_eq (mul_comm _ _)\n#align lipschitz_apply lipschitz_apply\n\n",
 "lipschitz":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\nprotected theorem lipschitz : LipschitzWith («expr‖ ‖₊» (e : «expr →SL[ ] » E σ₁₂ F)) e :=\n  (e : «expr →SL[ ] » E σ₁₂ F).lipschitz\n#align lipschitz lipschitz\n\n",
 "le_op_norm₂":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem le_op_norm₂ [RingHomIsometric σ₁₃] (f : «expr →SL[ ] » E σ₁₃ («expr →SL[ ] » F σ₂₃ G)) (x : E) (y : F) :\n    «expr‖ ‖» (f x y) ≤ «expr‖ ‖» f * «expr‖ ‖» x * «expr‖ ‖» y :=\n  (f x).le_of_op_norm_le (f.le_op_norm x) y\n#align le_op_norm₂ le_op_norm₂\n\n",
 "le_op_norm_of_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem le_op_norm_of_le {c : exprℝ} {x} (h : «expr‖ ‖» x ≤ c) : «expr‖ ‖» (f x) ≤ «expr‖ ‖» f * c :=\n  le_trans (f.le_op_norm x) (mul_le_mul_of_nonneg_left h f.op_norm_nonneg)\n#align le_op_norm_of_le le_op_norm_of_le\n\n",
 "le_op_norm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/-- The fundamental property of the operator norm: `‖f x‖ ≤ ‖f‖ * ‖x‖`. -/\ntheorem le_op_norm : «expr‖ ‖» (f x) ≤ «expr‖ ‖» f * «expr‖ ‖» x :=\n  by\n  obtain ⟨C, Cpos, hC⟩ := f.bound\n  replace hC := hC x\n  by_cases h : «expr‖ ‖» x = 0\n  · rwa [h, MulZeroClass.mul_zero] at hC⊢\n  have hlt : 0 < «expr‖ ‖» x := lt_of_le_of_ne (norm_nonneg x) (ne.symm h)\n  exact (div_le_iff hlt).mp (le_cinfₛ bounds_nonempty fun c ⟨_, hc⟩ => (div_le_iff hlt).mpr <| by apply hc)\n#align le_op_norm le_op_norm\n\n",
 "le_op_nnnorm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\ntheorem le_op_nnnorm : «expr‖ ‖₊» (f x) ≤ «expr‖ ‖₊» f * «expr‖ ‖₊» x :=\n  f.le_op_norm x\n#align le_op_nnnorm le_op_nnnorm\n\n",
 "le_of_op_norm_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem le_of_op_norm_le {c : exprℝ} (h : «expr‖ ‖» f ≤ c) (x : E) : «expr‖ ‖» (f x) ≤ c * «expr‖ ‖» x :=\n  (f.le_op_norm x).trans (mul_le_mul_of_nonneg_right h (norm_nonneg x))\n#align le_of_op_norm_le le_of_op_norm_le\n\n",
 "le_norm_flip":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\nprivate theorem le_norm_flip (f : «expr →SL[ ] » E σ₁₃ («expr →SL[ ] » F σ₂₃ G)) : «expr‖ ‖» f ≤ «expr‖ ‖» (flip f) :=\n  f.op_norm_le_bound₂ (norm_nonneg _) fun x y => by\n    rw [mul_right_comm]\n    exact (flip f).le_op_norm₂ y x\n#align le_norm_flip le_norm_flip\n\n",
 "is_weak_closed_closed_ball":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n/-- A closed ball is closed in the weak-* topology. We don't have a name for `E →SL[σ] F` with\nweak-* topology in `mathlib`, so we use an equivalent condition (see `is_closed_induced_iff'`). -/\ntheorem is_weak_closed_closed_ball (f₀ : «expr →SL[ ] » E' σ₁₂ F) (r : exprℝ) ⦃f : «expr →SL[ ] » E' σ₁₂ F⦄\n    (hf : «expr⇑ » f ∈ closure («expr '' » (coe_fn : «expr →SL[ ] » E' σ₁₂ F → E' → F) (closedBall f₀ r))) :\n    f ∈ closedBall f₀ r :=\n  by\n  have hr : 0 ≤ r := nonempty_closed_ball.1 (nonempty_image_iff.1 (closure_nonempty_iff.1 ⟨_, hf⟩))\n  refine' mem_closedBall_iff_norm.2 (op_norm_le_bound _ hr fun x => _)\n  have : IsClosed { g : E' → F | «expr‖ ‖» (g x - f₀ x) ≤ r * «expr‖ ‖» x } :=\n    is_closed_Iic.preimage ((@continuous_apply E' (fun _ => F) _ x).sub continuous_const).norm\n  refine' this.closure_subset_iff.2 (image_subset_iff.2 fun g hg => _) hf\n  exact (g - f₀).le_of_op_norm_le (mem_closedBall_iff_norm.1 hg) _\n#align is_weak_closed_closed_ball is_weak_closed_closed_ball\n\n",
 "is_compact_image_coe_of_bounded_of_weak_closed":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n/-- If a set `s` of semilinear functions is bounded and is closed in the weak-* topology, then its\nimage under coercion to functions `E → F` is a compact set. We don't have a name for `E →SL[σ] F`\nwith weak-* topology in `mathlib`, so we use an equivalent condition (see `is_closed_induced_iff'`).\n-/\ntheorem is_compact_image_coe_of_bounded_of_weak_closed [ProperSpace F] {s : Set («expr →SL[ ] » E' σ₁₂ F)}\n    (hb : Bounded s)\n    (hc : ∀ f, («expr⇑ » f : E' → F) ∈ closure («expr '' » (coe_fn : «expr →SL[ ] » E' σ₁₂ F → E' → F) s) → f ∈ s) :\n    IsCompact («expr '' » (coe_fn : «expr →SL[ ] » E' σ₁₂ F → E' → F) s) :=\n  is_compact_image_coe_of_bounded_of_closed_image hb <| is_closed_image_coe_of_bounded_of_weak_closed hb hc\n#align is_compact_image_coe_of_bounded_of_weak_closed is_compact_image_coe_of_bounded_of_weak_closed\n\n",
 "is_compact_image_coe_of_bounded_of_closed_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n/-- Let `s` be a bounded set in the space of continuous (semi)linear maps `E →SL[σ] F` taking values\nin a proper space. If `s` interpreted as a set in the space of maps `E → F` with topology of\npointwise convergence is closed, then it is compact.\n\nTODO: reformulate this in terms of a type synonym with the right topology. -/\ntheorem is_compact_image_coe_of_bounded_of_closed_image [ProperSpace F] {s : Set («expr →SL[ ] » E' σ₁₂ F)}\n    (hb : Bounded s) (hc : IsClosed («expr '' » (coe_fn : «expr →SL[ ] » E' σ₁₂ F → E' → F) s)) :\n    IsCompact («expr '' » (coe_fn : «expr →SL[ ] » E' σ₁₂ F → E' → F) s) :=\n  hc.closure_eq ▸ is_compact_closure_image_coe_of_bounded hb\n#align is_compact_image_coe_of_bounded_of_closed_image is_compact_image_coe_of_bounded_of_closed_image\n\n",
 "is_compact_image_coe_closed_ball":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n/-- **Banach-Alaoglu** theorem. The set of functions `f : E → F` that represent continuous linear\nmaps `f : E →SL[σ₁₂] F` at distance `≤ r` from `f₀ : E →SL[σ₁₂] F` is compact in the topology of\npointwise convergence. Other versions of this theorem can be found in\n`analysis.normed_space.weak_dual`. -/\ntheorem is_compact_image_coe_closed_ball [ProperSpace F] (f₀ : «expr →SL[ ] » E σ₁₂ F) (r : exprℝ) :\n    IsCompact («expr '' » (coe_fn : «expr →SL[ ] » E σ₁₂ F → E → F) (closedBall f₀ r)) :=\n  is_compact_image_coe_of_bounded_of_weak_closed bounded_closedBall <| is_weak_closed_closed_ball f₀ r\n#align is_compact_image_coe_closed_ball is_compact_image_coe_closed_ball\n\n",
 "is_compact_closure_image_coe_of_bounded":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n-- We show that every Cauchy sequence converges.\n-- The evaluation at any point `v : E` is Cauchy.\n-- We assemble the limits points of those Cauchy sequences\n-- (which exist as `F` is complete)\n-- into a function which we call `G`.\n-- Next, we show that this `G` is a continuous linear map.\n-- This is done in `continuous_linear_map.of_tendsto_of_bounded_range`.\n-- Finally, `f n` converges to `Glin` in norm because of\n-- `continuous_linear_map.tendsto_of_tendsto_pointwise_of_cauchy_seq`\n/-- Let `s` be a bounded set in the space of continuous (semi)linear maps `E →SL[σ] F` taking values\nin a proper space. Then `s` interpreted as a set in the space of maps `E → F` with topology of\npointwise convergence is precompact: its closure is a compact set. -/\ntheorem is_compact_closure_image_coe_of_bounded [ProperSpace F] {s : Set («expr →SL[ ] » E' σ₁₂ F)} (hb : Bounded s) :\n    IsCompact (closure («expr '' » (coe_fn : «expr →SL[ ] » E' σ₁₂ F → E' → F) s)) :=\n  have : ∀ x, IsCompact (closure («expr '' » (apply' F σ₁₂ x) s)) := fun x =>\n    ((apply' F σ₁₂ x).lipschitz.bounded_image hb).is_compact_closure\n  isCompact_closure_of_subset_compact (isCompact_pi_infinite this)\n    (image_subset_iff.2 fun g hg x => subset_closure <| mem_image_of_mem _ hg)\n#align is_compact_closure_image_coe_of_bounded is_compact_closure_image_coe_of_bounded\n\n",
 "is_closed_image_coe_of_bounded_of_weak_closed":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n/-- If a set `s` of semilinear functions is bounded and is closed in the weak-* topology, then its\nimage under coercion to functions `E → F` is a closed set. We don't have a name for `E →SL[σ] F`\nwith weak-* topology in `mathlib`, so we use an equivalent condition (see `is_closed_induced_iff'`).\n\nTODO: reformulate this in terms of a type synonym with the right topology. -/\ntheorem is_closed_image_coe_of_bounded_of_weak_closed {s : Set («expr →SL[ ] » E' σ₁₂ F)} (hb : Bounded s)\n    (hc : ∀ f, («expr⇑ » f : E' → F) ∈ closure («expr '' » (coe_fn : «expr →SL[ ] » E' σ₁₂ F → E' → F) s) → f ∈ s) :\n    IsClosed («expr '' » (coe_fn : «expr →SL[ ] » E' σ₁₂ F → E' → F) s) :=\n  isClosed_of_closure_subset fun f hf =>\n    ⟨of_mem_closure_image_coe_bounded f hb hf, hc (of_mem_closure_image_coe_bounded f hb hf) hf, rfl⟩\n#align is_closed_image_coe_of_bounded_of_weak_closed is_closed_image_coe_of_bounded_of_weak_closed\n\n",
 "is_closed_image_coe_closed_ball":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n/-- The set of functions `f : E → F` that represent continuous linear maps `f : E →SL[σ₁₂] F`\nat distance `≤ r` from `f₀ : E →SL[σ₁₂] F` is closed in the topology of pointwise convergence.\nThis is one of the key steps in the proof of the **Banach-Alaoglu** theorem. -/\ntheorem is_closed_image_coe_closed_ball (f₀ : «expr →SL[ ] » E σ₁₂ F) (r : exprℝ) :\n    IsClosed («expr '' » (coe_fn : «expr →SL[ ] » E σ₁₂ F → E → F) (closedBall f₀ r)) :=\n  is_closed_image_coe_of_bounded_of_weak_closed bounded_closedBall (is_weak_closed_closed_ball f₀ r)\n#align is_closed_image_coe_closed_ball is_closed_image_coe_closed_ball\n\n",
 "is_O_with_sub":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem is_O_with_sub (f : «expr →SL[ ] » E σ₁₂ F) (l : Filter E) (x : E) :\n    IsBigOWith («expr‖ ‖» f) l (fun x' => f (x' - x)) fun x' => x' - x :=\n  f.is_O_with_comp _ l\n#align is_O_with_sub is_O_with_sub\n\n",
 "is_O_with_id":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem is_O_with_id (l : Filter E) : IsBigOWith («expr‖ ‖» f) l f fun x => x :=\n  isBigOWith_of_le' _ f.le_op_norm\n#align is_O_with_id is_O_with_id\n\n",
 "is_O_with_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem is_O_with_comp [RingHomIsometric σ₂₃] {α : Type _} (g : «expr →SL[ ] » F σ₂₃ G) (f : α → F) (l : Filter α) :\n    IsBigOWith («expr‖ ‖» g) l (fun x' => g (f x')) f :=\n  (g.is_O_with_id («expr⊤»)).comp_tendsto le_top\n#align is_O_with_comp is_O_with_comp\n\n",
 "is_O_sub_rev":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =O[ ] » -/\ntheorem is_O_sub_rev (l : Filter E) (x : E) : «expr =O[ ] » (fun x' => x' - x) l fun x' => e (x' - x) :=\n  e.is_O_comp_rev _ _\n#align is_O_sub_rev is_O_sub_rev\n\n",
 "is_O_sub":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =O[ ] » -/\ntheorem is_O_sub (l : Filter E) (x : E) : «expr =O[ ] » (fun x' => e (x' - x)) l fun x' => x' - x :=\n  (e : «expr →SL[ ] » E σ₁₂ F).is_O_sub l x\n#align is_O_sub is_O_sub\n\n",
 "is_O_id":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =O[ ] » -/\ntheorem is_O_id (l : Filter E) : «expr =O[ ] » f l fun x => x :=\n  (f.is_O_with_id l).is_O\n#align is_O_id is_O_id\n\n",
 "is_O_comp_rev":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =O[ ] » -/\ntheorem is_O_comp_rev {α : Type _} (f : α → E) (l : Filter α) : «expr =O[ ] » f l fun x' => e (f x') :=\n  (e.symm.is_O_comp _ l).congr_left fun _ => e.symm_apply_apply _\n#align is_O_comp_rev is_O_comp_rev\n\n",
 "is_O_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =O[ ] » -/\ntheorem is_O_comp {α : Type _} (f : α → E) (l : Filter α) : «expr =O[ ] » (fun x' => e (f x')) l f :=\n  (e : «expr →SL[ ] » E σ₁₂ F).is_O_comp f l\n#align is_O_comp is_O_comp\n\n",
 "homothety_norm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem homothety_norm [RingHomIsometric σ₁₂] [Nontrivial E] (f : «expr →SL[ ] » E σ₁₂ F) {a : exprℝ}\n    (hf : ∀ x, «expr‖ ‖» (f x) = a * «expr‖ ‖» x) : «expr‖ ‖» f = a :=\n  by\n  obtain ⟨x, hx⟩ : ∃ x : E, x ≠ 0 := exists_ne 0\n  rw [← norm_pos_iff] at hx\n  have ha : 0 ≤ a := by simpa only [hf, hx, zero_le_mul_right] using norm_nonneg (f x)\n  apply le_antisymm (f.op_norm_le_bound ha fun y => le_of_eq (hf y))\n  simpa only [hf, hx, mul_le_mul_right] using f.le_op_norm x\n#align homothety_norm homothety_norm\n\n",
 "flipₗᵢ_symm":
 "@[simp]\ntheorem flipₗᵢ_symm : (flipₗᵢ 𝕜 E Fₗ Gₗ).symm = flipₗᵢ 𝕜 Fₗ E Gₗ :=\n  rfl\n#align flipₗᵢ_symm flipₗᵢ_symm\n\n",
 "flipₗᵢ'_symm":
 "@[simp]\ntheorem flipₗᵢ'_symm : (flipₗᵢ' E F G σ₂₃ σ₁₃).symm = flipₗᵢ' F E G σ₁₃ σ₂₃ :=\n  rfl\n#align flipₗᵢ'_symm flipₗᵢ'_symm\n\n",
 "flip_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem flip_smul (c : 𝕜₃) (f : «expr →SL[ ] » E σ₁₃ («expr →SL[ ] » F σ₂₃ G)) :\n    («expr • » c f).flip = «expr • » c f.flip :=\n  rfl\n#align flip_smul flip_smul\n\n",
 "flip_flip":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n@[simp]\ntheorem flip_flip (f : «expr →SL[ ] » E σ₁₃ («expr →SL[ ] » F σ₂₃ G)) : f.flip.flip = f :=\n  by\n  ext\n  rfl\n#align flip_flip flip_flip\n\n",
 "flip_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n@[simp]\ntheorem flip_apply (f : «expr →SL[ ] » E σ₁₃ («expr →SL[ ] » F σ₂₃ G)) (x : E) (y : F) : f.flip y x = f x y :=\n  rfl\n#align flip_apply flip_apply\n\n",
 "flip_add":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n#print flip_add /-\n@[simp]\ntheorem flip_add (f g : «expr →SL[ ] » E σ₁₃ («expr →SL[ ] » F σ₂₃ G)) : (f + g).flip = f.flip + g.flip :=\n  rfl\n#align flip_add flip_add\n-/\n\n",
 "extend_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n@[simp]\ntheorem extend_zero : extend (0 : «expr →SL[ ] » E σ₁₂ F) e h_dense h_e = 0 :=\n  extend_unique _ _ _ _ _ (zero_comp _)\n#align extend_zero extend_zero\n\n",
 "extend_unique":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\ntheorem extend_unique (g : «expr →SL[ ] » Fₗ σ₁₂ F) (H : g.comp e = f) : extend f e h_dense h_e = g :=\n  ContinuousLinearMap.coeFn_injective <|\n    uniformly_extend_unique h_e h_dense (ContinuousLinearMap.ext_iff.1 H) g.continuous\n#align extend_unique extend_unique\n\n",
 "extend_eq":
 "-- extension of `f` is continuous \n-- extension of `f` agrees with `f` on the domain of the embedding `e`\n@[simp]\ntheorem extend_eq (x : E) : extend f e h_dense h_e (e x) = f x :=\n  DenseInducing.extend_eq _ f.cont _\n#align extend_eq extend_eq\n\n",
 "exists_mul_lt_of_lt_op_norm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem exists_mul_lt_of_lt_op_norm (f : «expr →SL[ ] » E σ₁₂ F) {r : exprℝ} (hr₀ : 0 ≤ r) (hr : r < «expr‖ ‖» f) :\n    ∃ x, r * «expr‖ ‖» x < «expr‖ ‖» (f x) := by\n  lift r to nnreal using hr₀\n  exact f.exists_mul_lt_apply_of_lt_op_nnnorm hr\n#align exists_mul_lt_of_lt_op_norm exists_mul_lt_of_lt_op_norm\n\n",
 "exists_mul_lt_apply_of_lt_op_nnnorm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\ntheorem exists_mul_lt_apply_of_lt_op_nnnorm (f : «expr →SL[ ] » E σ₁₂ F) {r : nnreal} (hr : r < «expr‖ ‖₊» f) :\n    ∃ x, r * «expr‖ ‖₊» x < «expr‖ ‖₊» (f x) := by\n  simpa only [not_forall, not_le, Set.mem_setOf] using\n    not_mem_of_lt_cinfₛ (nnnorm_def f ▸ hr : r < Inf { c : nnreal | ∀ x, «expr‖ ‖₊» (f x) ≤ c * «expr‖ ‖₊» x })\n      (OrderBot.bddBelow _)\n#align exists_mul_lt_apply_of_lt_op_nnnorm exists_mul_lt_apply_of_lt_op_nnnorm\n\n",
 "exists_lt_apply_of_lt_op_norm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem exists_lt_apply_of_lt_op_norm {𝕜 𝕜₂ E F : Type _} [NormedAddCommGroup E] [SeminormedAddCommGroup F]\n    [DenselyNormedField 𝕜] [NontriviallyNormedField 𝕜₂] {σ₁₂ : «expr →+* » 𝕜 𝕜₂} [NormedSpace 𝕜 E] [NormedSpace 𝕜₂ F]\n    [RingHomIsometric σ₁₂] (f : «expr →SL[ ] » E σ₁₂ F) {r : exprℝ} (hr : r < «expr‖ ‖» f) :\n    ∃ x : E, «expr‖ ‖» x < 1 ∧ r < «expr‖ ‖» (f x) :=\n  by\n  by_cases hr₀ : r < 0\n  · exact ⟨0, by simpa using hr₀⟩\n  · lift r to nnreal using not_lt.1 hr₀\n    exact f.exists_lt_apply_of_lt_op_nnnorm hr\n#align exists_lt_apply_of_lt_op_norm exists_lt_apply_of_lt_op_norm\n\n",
 "exists_lt_apply_of_lt_op_nnnorm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\ntheorem exists_lt_apply_of_lt_op_nnnorm {𝕜 𝕜₂ E F : Type _} [NormedAddCommGroup E] [SeminormedAddCommGroup F]\n    [DenselyNormedField 𝕜] [NontriviallyNormedField 𝕜₂] {σ₁₂ : «expr →+* » 𝕜 𝕜₂} [NormedSpace 𝕜 E] [NormedSpace 𝕜₂ F]\n    [RingHomIsometric σ₁₂] (f : «expr →SL[ ] » E σ₁₂ F) {r : nnreal} (hr : r < «expr‖ ‖₊» f) :\n    ∃ x : E, «expr‖ ‖₊» x < 1 ∧ r < «expr‖ ‖₊» (f x) :=\n  by\n  obtain ⟨y, hy⟩ := f.exists_mul_lt_apply_of_lt_op_nnnorm hr\n  have hy' : «expr‖ ‖₊» y ≠ 0 :=\n    nnnorm_ne_zero_iff.2 fun heq => by simpa only [HEq, nnnorm_zero, map_zero, not_lt_zero'] using hy\n  have hfy : «expr‖ ‖₊» (f y) ≠ 0 := (zero_le'.trans_lt hy).ne'\n  rw [← inv_inv («expr‖ ‖₊» (f y)), NNReal.lt_inv_iff_mul_lt (inv_ne_zero hfy), mul_assoc, mul_comm («expr‖ ‖₊» y), ←\n    mul_assoc, ← NNReal.lt_inv_iff_mul_lt hy'] at hy\n  obtain ⟨k, hk₁, hk₂⟩ := NormedField.exists_lt_nnnorm_lt 𝕜 hy\n  refine' ⟨«expr • » k y, (nnnorm_smul k y).symm ▸ (NNReal.lt_inv_iff_mul_lt hy').1 hk₂, _⟩\n  have : «expr‖ ‖₊» (σ₁₂ k) = «expr‖ ‖₊» k := Subtype.ext ring_hom_isometric.is_iso\n  rwa [map_smulₛₗ f, nnnorm_smul, ← NNReal.div_lt_iff hfy, div_eq_mul_inv, this]\n#align exists_lt_apply_of_lt_op_nnnorm exists_lt_apply_of_lt_op_nnnorm\n\n",
 "dist_le_op_norm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem dist_le_op_norm (x y : E) : dist (f x) (f y) ≤ «expr‖ ‖» f * dist x y := by\n  simp_rw [dist_eq_norm, ← map_sub, f.le_op_norm]\n#align dist_le_op_norm dist_le_op_norm\n\n",
 "coord_norm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n@[simp]\ntheorem coord_norm (x : E) (h : x ≠ 0) : «expr‖ ‖» (coord 𝕜 x h) = («expr‖ ‖» x)⁻¹ :=\n  by\n  have hx : 0 < «expr‖ ‖» x := norm_pos_iff.mpr h\n  haveI : Nontrivial («expr ∙ » 𝕜 x) := Submodule.nontrivial_span_singleton h\n  exact\n    continuous_linear_map.homothety_norm _ fun y =>\n      homothety_inverse _ hx _ (to_span_nonzero_singleton_homothety 𝕜 x h) _\n#align coord_norm coord_norm\n\n",
 "const_clm_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\ntheorem _root_.continuous.const_clm_comp {X} [TopologicalSpace X] {f : X → «expr →SL[ ] » E σ₁₂ F} (hf : Continuous f)\n    (g : «expr →SL[ ] » F σ₂₃ G) : Continuous (fun x => g.comp (f x) : X → «expr →SL[ ] » E σ₁₃ G) :=\n  (compSL E F G σ₁₂ σ₂₃ g).continuous.comp hf\n#align continuous.const_clm_comp continuous.const_clm_comp\n\n",
 "compSL_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n@[simp]\ntheorem compSL_apply (f : «expr →SL[ ] » F σ₂₃ G) (g : «expr →SL[ ] » E σ₁₂ F) : compSL E F G σ₁₂ σ₂₃ f g = f.comp g :=\n  rfl\n#align compSL_apply compSL_apply\n\n",
 "compL_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n@[simp]\ntheorem compL_apply (f : «expr →L[ ] » Fₗ 𝕜 Gₗ) (g : «expr →L[ ] » E 𝕜 Fₗ) : compL 𝕜 E Fₗ Gₗ f g = f.comp g :=\n  rfl\n#align compL_apply compL_apply\n\n",
 "coe_to_span_singleton":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n@[simp]\ntheorem _root_.linear_isometry.coe_to_span_singleton {v : E} (hv : «expr‖ ‖» v = 1) :\n    (linear_isometry.to_span_singleton 𝕜 E hv).to_linear_map = LinearMap.toSpanSingleton 𝕜 E v :=\n  rfl\n#align linear_isometry.coe_to_span_singleton linear_isometry.coe_to_span_singleton\n\n",
 "coe_restrict_scalars_isometry":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n@[simp]\ntheorem coe_restrict_scalars_isometry : «expr⇑ » (restrict_scalars_isometry 𝕜 E Fₗ 𝕜' 𝕜'') = restrictScalars 𝕜' :=\n  rfl\n#align coe_restrict_scalars_isometry coe_restrict_scalars_isometry\n\n",
 "coe_restrict_scalarsL'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n@[simp]\ntheorem coe_restrict_scalarsL' : «expr⇑ » (restrict_scalarsL 𝕜 E Fₗ 𝕜' 𝕜'') = restrictScalars 𝕜' :=\n  rfl\n#align coe_restrict_scalarsL' coe_restrict_scalarsL'\n\n",
 "coe_restrict_scalarsL":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n@[simp]\ntheorem coe_restrict_scalarsL :\n    (restrict_scalarsL 𝕜 E Fₗ 𝕜' 𝕜'' : «expr →ₗ[ ] » («expr →L[ ] » E 𝕜 Fₗ) 𝕜'' («expr →L[ ] » E 𝕜' Fₗ)) =\n      restrictScalarsₗ 𝕜 E Fₗ 𝕜' 𝕜'' :=\n  rfl\n#align coe_restrict_scalarsL coe_restrict_scalarsL\n\n",
 "coe_mulₗᵢ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n@[simp]\ntheorem coe_mulₗᵢ : «expr⇑ » (mulₗᵢ 𝕜 𝕜') = mul 𝕜 𝕜' :=\n  rfl\n#align coe_mulₗᵢ coe_mulₗᵢ\n\n",
 "coe_flipₗᵢ'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n@[simp]\ntheorem coe_flipₗᵢ' : «expr⇑ » (flipₗᵢ' E F G σ₂₃ σ₁₃) = flip :=\n  rfl\n#align coe_flipₗᵢ' coe_flipₗᵢ'\n\n",
 "coe_flipₗᵢ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n@[simp]\ntheorem coe_flipₗᵢ : «expr⇑ » (flipₗᵢ 𝕜 E Fₗ Gₗ) = flip :=\n  rfl\n#align coe_flipₗᵢ coe_flipₗᵢ\n\n",
 "coe_deriv₂":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n@[simp]\ntheorem coe_deriv₂ (f : «expr →L[ ] » E 𝕜 («expr →L[ ] » Fₗ 𝕜 Gₗ)) (p : E × Fₗ) :\n    «expr⇑ » (f.deriv₂ p) = fun q : E × Fₗ => f p.1 q.2 + f q.1 p.2 :=\n  rfl\n#align coe_deriv₂ coe_deriv₂\n\n",
 "clm_comp_const":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n-- Giving the implicit argument speeds up elaboration significantly\ntheorem _root_.continuous.clm_comp_const {X} [TopologicalSpace X] {g : X → «expr →SL[ ] » F σ₂₃ G} (hg : Continuous g)\n    (f : «expr →SL[ ] » E σ₁₂ F) : Continuous (fun x => (g x).comp f : X → «expr →SL[ ] » E σ₁₃ G) :=\n  (@continuous_linear_map.flip _ _ _ _ _ («expr →SL[ ] » E σ₁₃ G) _ _ _ _ _ _ _ _ _ _ _ _ _ (compSL E F G σ₁₂ σ₂₃)\n          f).continuous.comp\n    hg\n#align continuous.clm_comp_const continuous.clm_comp_const\n\n",
 "bounds_nonempty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n-- So that invocations of `le_cInf` make sense: we show that the set of\n-- bounds is nonempty and bounded below.\ntheorem bounds_nonempty [RingHomIsometric σ₁₂] {f : «expr →SL[ ] » E σ₁₂ F} :\n    ∃ c, c ∈ { c | 0 ≤ c ∧ ∀ x, «expr‖ ‖» (f x) ≤ c * «expr‖ ‖» x } :=\n  let ⟨M, hMp, hMb⟩ := f.bound\n  ⟨M, le_of_lt hMp, hMb⟩\n#align bounds_nonempty bounds_nonempty\n\n",
 "bounds_bdd_below":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem bounds_bdd_below {f : «expr →SL[ ] » E σ₁₂ F} :\n    BddBelow { c | 0 ≤ c ∧ ∀ x, «expr‖ ‖» (f x) ≤ c * «expr‖ ‖» x } :=\n  ⟨0, fun _ ⟨hn, _⟩ => hn⟩\n#align bounds_bdd_below bounds_bdd_below\n\n",
 "bound_of_shell_semi_normed":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem semilinear_map_class.bound_of_shell_semi_normed [SemilinearMapClass 𝓕 σ₁₂ E F] (f : 𝓕) {ε C : exprℝ}\n    (ε_pos : 0 < ε) {c : 𝕜} (hc : 1 < «expr‖ ‖» c)\n    (hf : ∀ x, ε / «expr‖ ‖» c ≤ «expr‖ ‖» x → «expr‖ ‖» x < ε → «expr‖ ‖» (f x) ≤ C * «expr‖ ‖» x) {x : E}\n    (hx : «expr‖ ‖» x ≠ 0) : «expr‖ ‖» (f x) ≤ C * «expr‖ ‖» x :=\n  by\n  rcases rescale_to_shell_semi_normed hc ε_pos hx with ⟨δ, hδ, δxle, leδx, δinv⟩\n  have := hf («expr • » δ x) leδx δxle\n  simpa only [map_smulₛₗ, norm_smul, mul_left_comm C, mul_le_mul_left (norm_pos_iff.2 hδ),\n    ring_hom_isometric.is_iso] using hf («expr • » δ x) leδx δxle\n#align semilinear_map_class.bound_of_shell_semi_normed semilinear_map_class.bound_of_shell_semi_normed\n\n",
 "bound_of_shell":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem bound_of_shell [RingHomIsometric σ₁₂] (f : «expr →ₛₗ[ ] » E σ₁₂ F) {ε C : exprℝ} (ε_pos : 0 < ε) {c : 𝕜}\n    (hc : 1 < «expr‖ ‖» c)\n    (hf : ∀ x, ε / «expr‖ ‖» c ≤ «expr‖ ‖» x → «expr‖ ‖» x < ε → «expr‖ ‖» (f x) ≤ C * «expr‖ ‖» x) (x : E) :\n    «expr‖ ‖» (f x) ≤ C * «expr‖ ‖» x := by\n  by_cases hx : x = 0; · simp [hx]\n  exact semilinear_map_class.bound_of_shell_semi_normed f ε_pos hc hf (ne_of_lt (norm_pos_iff.2 hx)).symm\n#align bound_of_shell bound_of_shell\n\n",
 "bound_of_continuous":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/-- A continuous linear map between seminormed spaces is bounded when the field is nontrivially\nnormed. The continuity ensures boundedness on a ball of some radius `ε`. The nontriviality of the\nnorm is then used to rescale any element into an element of norm in `[ε/C, ε]`, whose image has a\ncontrolled norm. The norm control for the original element follows by rescaling. -/\ntheorem semilinear_map_class.bound_of_continuous [SemilinearMapClass 𝓕 σ₁₂ E F] (f : 𝓕) (hf : Continuous f) :\n    ∃ C, 0 < C ∧ ∀ x : E, «expr‖ ‖» (f x) ≤ C * «expr‖ ‖» x :=\n  by\n  rcases NormedAddCommGroup.tendsto_nhds_nhds.1 (hf.tendsto 0) 1 zero_lt_one with ⟨ε, ε_pos, hε⟩\n  simp only [sub_zero, map_zero] at hε\n  rcases NormedField.exists_one_lt_norm 𝕜 with ⟨c, hc⟩\n  have : 0 < «expr‖ ‖» c / ε := div_pos (zero_lt_one.trans hc) ε_pos\n  refine' ⟨«expr‖ ‖» c / ε, this, fun x => _⟩\n  by_cases hx : «expr‖ ‖» x = 0\n  · rw [hx, MulZeroClass.mul_zero]\n    exact le_of_eq (norm_image_of_norm_zero f hf hx)\n  refine' semilinear_map_class.bound_of_shell_semi_normed f ε_pos hc (fun x hle hlt => _) hx\n  refine' (hε _ hlt).le.trans _\n  rwa [← div_le_iff' this, one_div_div]\n#align semilinear_map_class.bound_of_continuous semilinear_map_class.bound_of_continuous\n\n",
 "bound_of_ball_bound":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/-- `linear_map.bound_of_ball_bound'` is a version of this lemma over a field satisfying `is_R_or_C`\nthat produces a concrete bound.\n-/\ntheorem bound_of_ball_bound {r : exprℝ} (r_pos : 0 < r) (c : exprℝ) (f : «expr →ₗ[ ] » E 𝕜 Fₗ)\n    (h : ∀ z ∈ Metric.ball (0 : E) r, «expr‖ ‖» (f z) ≤ c) : ∃ C, ∀ z : E, «expr‖ ‖» (f z) ≤ C * «expr‖ ‖» z :=\n  by\n  cases' @nontrivially_normed_field.non_trivial 𝕜 _ with k hk\n  use c * («expr‖ ‖» k / r)\n  intro z\n  refine' bound_of_shell _ r_pos hk (fun x hko hxo => _) _\n  calc\n    «expr‖ ‖» (f x) ≤ c := h _ (mem_ball_zero_iff.mpr hxo)\n    _ ≤ c * («expr‖ ‖» x * «expr‖ ‖» k / r) := (le_mul_of_one_le_right _ _)\n    _ = _ := by ring\n    \n  · exact le_trans (norm_nonneg _) (h 0 (by simp [r_pos]))\n  · rw [div_le_iff (zero_lt_one.trans hk)] at hko\n    exact (one_le_div r_pos).mpr hko\n#align bound_of_ball_bound bound_of_ball_bound\n\n",
 "bound":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem bound [RingHomIsometric σ₁₂] (f : «expr →SL[ ] » E σ₁₂ F) :\n    ∃ C, 0 < C ∧ ∀ x : E, «expr‖ ‖» (f x) ≤ C * «expr‖ ‖» x :=\n  semilinear_map_class.bound_of_continuous f f.2\n#align bound bound\n\n",
 "bilinear_comp_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n@[simp]\ntheorem bilinear_comp_apply (f : «expr →SL[ ] » E σ₁₃ («expr →SL[ ] » F σ₂₃ G)) (gE : «expr →SL[ ] » E' σ₁' E)\n    (gF : «expr →SL[ ] » F' σ₂' F) (x : E') (y : F') : f.bilinear_comp gE gF x y = f (gE x) (gF y) :=\n  rfl\n#align bilinear_comp_apply bilinear_comp_apply\n\n",
 "apply_apply'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n@[simp]\ntheorem apply_apply' (v : E) (f : «expr →SL[ ] » E σ₁₂ F) : apply' F σ₁₂ v f = f v :=\n  rfl\n#align apply_apply' apply_apply'\n\n",
 "apply_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n@[simp]\ntheorem apply_apply (v : E) (f : «expr →L[ ] » E 𝕜 Fₗ) : apply 𝕜 Fₗ v f = f v :=\n  rfl\n#align apply_apply apply_apply\n\n",
 "antilipschitz_of_embedding":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/-- If a continuous linear map is a topology embedding, then it is expands the distances\nby a positive factor.-/\ntheorem antilipschitz_of_embedding (f : «expr →L[ ] » E 𝕜 Fₗ) (hf : Embedding f) : ∃ K, AntilipschitzWith K f :=\n  f.to_linear_map.antilipschitz_of_comap_nhds_le <| map_zero f ▸ (hf.nhds_eq_comap 0).ge\n#align antilipschitz_of_embedding antilipschitz_of_embedding\n\n",
 "antilipschitz_of_comap_nhds_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem antilipschitz_of_comap_nhds_le [h : RingHomIsometric σ₁₂] (f : «expr →ₛₗ[ ] » E σ₁₂ F)\n    (hf : ((nhds) 0).comap f ≤ (nhds) 0) : ∃ K, AntilipschitzWith K f :=\n  by\n  rcases((nhds_basis_ball.comap _).le_basis_iff nhds_basis_ball).1 hf 1 one_pos with ⟨ε, ε0, hε⟩\n  simp only [Set.subset_def, Set.mem_preimage, mem_ball_zero_iff] at hε\n  lift ε to nnreal using ε0.le\n  rcases NormedField.exists_one_lt_norm 𝕜 with ⟨c, hc⟩\n  refine' ⟨ε⁻¹ * «expr‖ ‖₊» c, AddMonoidHomClass.antilipschitz_of_bound f fun x => _⟩\n  by_cases hx : f x = 0\n  · rw [← hx] at hf\n    obtain rfl : x = 0 :=\n      Specializes.eq\n        (specializes_iff_pure.2 <| ((Filter.tendsto_pure_pure _ _).mono_right (pure_le_nhds _)).le_comap.trans hf)\n    exact norm_zero.trans_le (mul_nonneg (NNReal.coe_nonneg _) (norm_nonneg _))\n  have hc₀ : c ≠ 0 := norm_pos_iff.1 (one_pos.trans hc)\n  rw [← h.1] at hc\n  rcases rescale_to_shell_zpow hc ε0 hx with ⟨n, -, hlt, -, hle⟩\n  simp only [← map_zpow₀, h.1, ← map_smulₛₗ] at hlt hle\n  calc\n    «expr‖ ‖» x = («expr‖ ‖» (c ^ n))⁻¹ * «expr‖ ‖» («expr • » (c ^ n) x) := by\n      rwa [← norm_inv, ← norm_smul, inv_smul_smul₀ (zpow_ne_zero _ _)]\n    _ ≤ («expr‖ ‖» (c ^ n))⁻¹ * 1 := (mul_le_mul_of_nonneg_left (hε _ hlt).le (inv_nonneg.2 (norm_nonneg _)))\n    _ ≤ ε⁻¹ * «expr‖ ‖» c * «expr‖ ‖» (f x) := by rwa [mul_one]\n    \n#align antilipschitz_of_comap_nhds_le antilipschitz_of_comap_nhds_le\n\n",
 "antilipschitz":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\nprotected theorem antilipschitz (e : «expr ≃SL[ ] » E σ₁₂ F) :\n    AntilipschitzWith («expr‖ ‖₊» (e.symm : «expr →SL[ ] » F σ₂₁ E)) e :=\n  e.symm.lipschitz.to_right_inverse e.left_inv\n#align antilipschitz antilipschitz\n\n",
 "Sup_unit_ball_eq_norm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem Sup_unit_ball_eq_norm {𝕜 𝕜₂ E F : Type _} [NormedAddCommGroup E] [SeminormedAddCommGroup F]\n    [DenselyNormedField 𝕜] [NontriviallyNormedField 𝕜₂] {σ₁₂ : «expr →+* » 𝕜 𝕜₂} [NormedSpace 𝕜 E] [NormedSpace 𝕜₂ F]\n    [RingHomIsometric σ₁₂] (f : «expr →SL[ ] » E σ₁₂ F) :\n    supₛ («expr '' » (fun x => «expr‖ ‖» (f x)) (ball 0 1)) = «expr‖ ‖» f := by\n  simpa only [NNReal.coe_supₛ, Set.image_image] using NNReal.coe_eq.2 f.Sup_unit_ball_eq_nnnorm\n#align Sup_unit_ball_eq_norm Sup_unit_ball_eq_norm\n\n",
 "Sup_unit_ball_eq_nnnorm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\ntheorem Sup_unit_ball_eq_nnnorm {𝕜 𝕜₂ E F : Type _} [NormedAddCommGroup E] [SeminormedAddCommGroup F]\n    [DenselyNormedField 𝕜] [NontriviallyNormedField 𝕜₂] {σ₁₂ : «expr →+* » 𝕜 𝕜₂} [NormedSpace 𝕜 E] [NormedSpace 𝕜₂ F]\n    [RingHomIsometric σ₁₂] (f : «expr →SL[ ] » E σ₁₂ F) :\n    supₛ («expr '' » (fun x => «expr‖ ‖₊» (f x)) (ball 0 1)) = «expr‖ ‖₊» f :=\n  by\n  refine' csupₛ_eq_of_forall_le_of_forall_lt_exists_gt ((nonempty_ball.mpr zero_lt_one).image _) _ fun ub hub => _\n  · rintro - ⟨x, hx, rfl⟩\n    simpa only [mul_one] using f.le_op_norm_of_le (mem_ball_zero_iff.1 hx).le\n  · obtain ⟨x, hx, hxf⟩ := f.exists_lt_apply_of_lt_op_nnnorm hub\n    exact ⟨_, ⟨x, mem_ball_zero_iff.2 hx, rfl⟩, hxf⟩\n#align Sup_unit_ball_eq_nnnorm Sup_unit_ball_eq_nnnorm\n\n",
 "Sup_closed_unit_ball_eq_norm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem Sup_closed_unit_ball_eq_norm {𝕜 𝕜₂ E F : Type _} [NormedAddCommGroup E] [SeminormedAddCommGroup F]\n    [DenselyNormedField 𝕜] [NontriviallyNormedField 𝕜₂] {σ₁₂ : «expr →+* » 𝕜 𝕜₂} [NormedSpace 𝕜 E] [NormedSpace 𝕜₂ F]\n    [RingHomIsometric σ₁₂] (f : «expr →SL[ ] » E σ₁₂ F) :\n    supₛ («expr '' » (fun x => «expr‖ ‖» (f x)) (closedBall 0 1)) = «expr‖ ‖» f := by\n  simpa only [NNReal.coe_supₛ, Set.image_image] using NNReal.coe_eq.2 f.Sup_closed_unit_ball_eq_nnnorm\n#align Sup_closed_unit_ball_eq_norm Sup_closed_unit_ball_eq_norm\n\n",
 "Sup_closed_unit_ball_eq_nnnorm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\ntheorem Sup_closed_unit_ball_eq_nnnorm {𝕜 𝕜₂ E F : Type _} [NormedAddCommGroup E] [SeminormedAddCommGroup F]\n    [DenselyNormedField 𝕜] [NontriviallyNormedField 𝕜₂] {σ₁₂ : «expr →+* » 𝕜 𝕜₂} [NormedSpace 𝕜 E] [NormedSpace 𝕜₂ F]\n    [RingHomIsometric σ₁₂] (f : «expr →SL[ ] » E σ₁₂ F) :\n    supₛ («expr '' » (fun x => «expr‖ ‖₊» (f x)) (closedBall 0 1)) = «expr‖ ‖₊» f :=\n  by\n  have hbdd : ∀ y ∈ «expr '' » (fun x => «expr‖ ‖₊» (f x)) (closed_ball 0 1), y ≤ «expr‖ ‖₊» f :=\n    by\n    rintro - ⟨x, hx, rfl⟩\n    exact f.unit_le_op_norm x (mem_closedBall_zero_iff.1 hx)\n  refine' le_antisymm (csupₛ_le ((nonempty_closed_ball.mpr zero_le_one).image _) hbdd) _\n  rw [← Sup_unit_ball_eq_nnnorm]\n  exact\n    csupₛ_le_csupₛ ⟨«expr‖ ‖₊» f, hbdd⟩ ((nonempty_ball.2 zero_lt_one).image _)\n      (Set.image_subset _ ball_subset_closed_ball)\n#align Sup_closed_unit_ball_eq_nnnorm Sup_closed_unit_ball_eq_nnnorm\n\n"}