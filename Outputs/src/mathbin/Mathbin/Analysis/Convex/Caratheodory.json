{"min_card_finset_of_mem_convex_hull_subseteq":
 "theorem min_card_finset_of_mem_convex_hull_subseteq : ↑(min_card_finset_of_mem_convex_hull hx) ⊆ s :=\n  (Function.argminOn_mem _ _ { t : Finset E | ↑t ⊆ s ∧ x ∈ convex_hull 𝕜 (t : set E) } _).1\n#align min_card_finset_of_mem_convex_hull_subseteq min_card_finset_of_mem_convex_hull_subseteq\n\n",
 "min_card_finset_of_mem_convex_hull_nonempty":
 "theorem min_card_finset_of_mem_convex_hull_nonempty : (min_card_finset_of_mem_convex_hull hx).nonempty :=\n  by\n  rw [← Finset.coe_nonempty, ← @convex_hull_nonempty_iff 𝕜]\n  exact ⟨x, mem_min_card_finset_of_mem_convex_hull hx⟩\n#align min_card_finset_of_mem_convex_hull_nonempty min_card_finset_of_mem_convex_hull_nonempty\n\n",
 "min_card_finset_of_mem_convex_hull_card_le_card":
 "theorem min_card_finset_of_mem_convex_hull_card_le_card {t : Finset E} (ht₁ : ↑t ⊆ s)\n    (ht₂ : x ∈ convex_hull 𝕜 (t : set E)) : (min_card_finset_of_mem_convex_hull hx).card ≤ t.card :=\n  Function.argminOn_le _ _ _ ⟨ht₁, ht₂⟩\n#align min_card_finset_of_mem_convex_hull_card_le_card min_card_finset_of_mem_convex_hull_card_le_card\n\n",
 "mem_min_card_finset_of_mem_convex_hull":
 "theorem mem_min_card_finset_of_mem_convex_hull : x ∈ convex_hull 𝕜 (min_card_finset_of_mem_convex_hull hx : set E) :=\n  (Function.argminOn_mem _ _ { t : Finset E | ↑t ⊆ s ∧ x ∈ convex_hull 𝕜 (t : set E) } _).2\n#align mem_min_card_finset_of_mem_convex_hull mem_min_card_finset_of_mem_convex_hull\n\n",
 "mem_convex_hull_erase":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-\nCopyright (c) 2020 Scott Morrison. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johan Commelin, Scott Morrison\n-/\n/-- If `x` is in the convex hull of some finset `t` whose elements are not affine-independent,\nthen it is in the convex hull of a strict subset of `t`. -/\ntheorem mem_convex_hull_erase [decidable_eq E] {t : Finset E} (h : ¬affine_independent 𝕜 (coe : t → E)) {x : E}\n    (m : x ∈ convex_hull 𝕜 (↑t : set E)) : ∃ y : (↑t : set E), x ∈ convex_hull 𝕜 (↑(t.erase y) : set E) :=\n  by\n  simp only [finset.convex_hull_eq, mem_set_of_eq] at m⊢\n  obtain ⟨f, fpos, fsum, rfl⟩ := m\n  obtain ⟨g, gcombo, gsum, gpos⟩ := exists_nontrivial_relation_sum_zero_of_not_affine_ind h\n  replace gpos := exists_pos_of_sum_zero_of_exists_nonzero g gsum gpos\n  clear h\n  let s := @Finset.filter _ (fun z => 0 < g z) (fun _ => linear_order.decidable_lt _ _) t\n  obtain ⟨i₀, mem, w⟩ : ∃ i₀ ∈ s, ∀ i ∈ s, f i₀ / g i₀ ≤ f i / g i :=\n    by\n    apply s.exists_min_image fun z => f z / g z\n    obtain ⟨x, hx, hgx⟩ : ∃ x ∈ t, 0 < g x := gpos\n    exact ⟨x, mem_filter.mpr ⟨hx, hgx⟩⟩\n  have hg : 0 < g i₀ := by\n    rw [mem_filter] at mem\n    exact mem.2\n  have hi₀ : i₀ ∈ t := filter_subset _ _ mem\n  let k : E → 𝕜 := fun z => f z - f i₀ / g i₀ * g z\n  have hk : k i₀ = 0 := by field_simp [k, ne_of_gt hg]\n  have ksum :\n    finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (t.erase i₀) (k e) =\n      1 :=\n    by\n    calc\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (t.erase i₀)\n            (k e) =\n          finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" t (k e) :=\n        by conv_rhs => rw [← insert_erase hi₀, sum_insert (not_mem_erase i₀ t), hk, zero_add]\n      _ =\n          finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" t\n            (f e - f i₀ / g i₀ * g e) :=\n        rfl\n      _ = 1 := by rw [sum_sub_distrib, fsum, ← mul_sum, gsum, mul_zero, sub_zero]\n      \n  refine' ⟨⟨i₀, hi₀⟩, k, _, by convert ksum, _⟩\n  · simp only [and_imp, sub_nonneg, mem_erase, ne.def, subtype.coe_mk]\n    intro e hei₀ het\n    by_cases hes : e ∈ s\n    · have hge : 0 < g e := by\n        rw [mem_filter] at hes\n        exact hes.2\n      rw [← le_div_iff hge]\n      exact w _ hes\n    · calc\n        _ ≤ 0 := mul_nonpos_of_nonneg_of_nonpos _ _\n        -- prove two goals below\n            _ ≤\n            f e :=\n          fpos e het\n        \n      · apply div_nonneg (fpos i₀ (mem_of_subset (filter_subset _ t) mem)) (le_of_lt hg)\n      · simpa only [mem_filter, het, true_and_iff, not_lt] using hes\n  · simp only [subtype.coe_mk, center_mass_eq_of_sum_1 _ id ksum, id]\n    calc\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (t.erase i₀)\n            («expr • » (k e) e) =\n          finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" t\n            («expr • » (k e) e) :=\n        sum_erase _ (by rw [hk, zero_smul])\n      _ =\n          finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" t\n            («expr • » (f e - f i₀ / g i₀ * g e) e) :=\n        rfl\n      _ = t.center_mass f id := _\n      \n    simp only [sub_smul, mul_smul, sum_sub_distrib, ← smul_sum, gcombo, smul_zero, sub_zero, center_mass, fsum, inv_one,\n      one_smul, id.def]\n#align mem_convex_hull_erase mem_convex_hull_erase\n\n",
 "eq_pos_convex_span_of_mem_convex_hull":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- A more explicit version of `convex_hull_eq_union`. -/\ntheorem eq_pos_convex_span_of_mem_convex_hull {x : E} (hx : x ∈ convex_hull 𝕜 s) :\n    ∃ (ι : Sort (u + 1))(_ : fintype ι),\n      ∃ (z : ι → E)(w : ι → 𝕜)(hss : Set.range z ⊆ s)(hai : affine_independent 𝕜 z)(hw : ∀ i, 0 < w i),\n        finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n              (w i) =\n            1 ∧\n          finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n              («expr • » (w i) (z i)) =\n            x :=\n  by\n  rw [convex_hull_eq_union] at hx\n  simp only [exists_prop, Set.mem_unionᵢ] at hx\n  obtain ⟨t, ht₁, ht₂, ht₃⟩ := hx\n  simp only [t.convex_hull_eq, exists_prop, Set.mem_setOf_eq] at ht₃\n  obtain ⟨w, hw₁, hw₂, hw₃⟩ := ht₃\n  let t' := t.filter fun i => w i ≠ 0\n  refine' ⟨t', t'.fintype_coe_sort, (coe : t' → E), w ∘ (coe : t' → E), _, _, _, _, _⟩\n  · rw [Subtype.range_coe_subtype]\n    exact subset.trans (Finset.filter_subset _ t) ht₁\n  · exact ht₂.comp_embedding ⟨_, inclusion_injective (Finset.filter_subset (fun i => w i ≠ 0) t)⟩\n  · exact fun i => (hw₁ _ (finset.mem_filter.mp i.2).1).lt_of_ne (finset.mem_filter.mp i.property).2.symm\n  · erw [finset.sum_attach, finset.sum_filter_ne_zero, hw₂]\n  · change\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" t'.attach\n          ((fun e => «expr • » (w e) e) ↑i) =\n        x\n    erw [finset.sum_attach, finset.sum_filter_of_ne]\n    · rw [t.center_mass_eq_of_sum_1 id hw₂] at hw₃\n      exact hw₃\n    · intro e he hwe contra\n      apply hwe\n      rw [contra, zero_smul]\n#align eq_pos_convex_span_of_mem_convex_hull eq_pos_convex_span_of_mem_convex_hull\n\n",
 "convex_hull_eq_union":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/-- **Carathéodory's convexity theorem** -/\ntheorem convex_hull_eq_union :\n    convex_hull 𝕜 s =\n      «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n        (convex_hull 𝕜 ↑t) :=\n  by\n  apply Set.Subset.antisymm\n  · intro x hx\n    simp only [exists_prop, Set.mem_unionᵢ]\n    exact\n      ⟨caratheodory.min_card_finset_of_mem_convex_hull hx, caratheodory.min_card_finset_of_mem_convex_hull_subseteq hx,\n        caratheodory.affine_independent_min_card_finset_of_mem_convex_hull hx,\n        caratheodory.mem_min_card_finset_of_mem_convex_hull hx⟩\n  · iterate 3 convert Set.unionᵢ_subset _; intro\n    exact convex_hull_mono ‹_›\n#align convex_hull_eq_union convex_hull_eq_union\n\n",
 "affine_independent_min_card_finset_of_mem_convex_hull":
 "theorem affine_independent_min_card_finset_of_mem_convex_hull :\n    affine_independent 𝕜 (coe : min_card_finset_of_mem_convex_hull hx → E) :=\n  by\n  let k := (min_card_finset_of_mem_convex_hull hx).card - 1\n  have hk : (min_card_finset_of_mem_convex_hull hx).card = k + 1 :=\n    (nat.succ_pred_eq_of_pos (finset.card_pos.mpr (min_card_finset_of_mem_convex_hull_nonempty hx))).symm\n  classical\n    by_contra\n    obtain ⟨p, hp⟩ := mem_convex_hull_erase h (mem_min_card_finset_of_mem_convex_hull hx)\n    have contra :=\n      min_card_finset_of_mem_convex_hull_card_le_card hx\n        (Set.Subset.trans (Finset.erase_subset (↑p) (min_card_finset_of_mem_convex_hull hx))\n          (min_card_finset_of_mem_convex_hull_subseteq hx))\n        hp\n    rw [← not_lt] at contra\n    apply contra\n    erw [card_erase_of_mem p.2, hk]\n    exact lt_add_one _\n#align affine_independent_min_card_finset_of_mem_convex_hull affine_independent_min_card_finset_of_mem_convex_hull\n\n"}