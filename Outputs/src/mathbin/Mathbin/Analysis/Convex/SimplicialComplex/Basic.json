{"vertices_subset_space":
 "theorem vertices_subset_space : K.vertices ‚äÜ K.space :=\n  vertices_eq.subset.trans <| union·µ¢‚ÇÇ_mono fun x hx => subset_convexHull ùïú x\n#align vertices_subset_space vertices_subset_space\n\n",
 "vertices_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚ãÉ , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚ãÉ , ¬ª -/\ntheorem vertices_eq :\n    K.vertices =\n      ¬´expr‚ãÉ , ¬ª \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚ãÉ , ¬ª\" (k : Set E) :=\n  by\n  ext x\n  refine' ‚ü®fun h => mem_bUnion h <| mem_coe.2 <| mem_singleton_self x, fun h => _‚ü©\n  obtain ‚ü®s, hs, hx‚ü© := mem_Union‚ÇÇ.1 h\n  exact K.down_closed hs (Finset.singleton_subset_iff.2 <| mem_coe.1 hx) (singleton_ne_empty _)\n#align vertices_eq vertices_eq\n\n",
 "vertex_mem_convex_hull_iff":
 "theorem vertex_mem_convex_hull_iff (hx : x ‚àà K.vertices) (hs : s ‚àà K.faces) : x ‚àà convexHull ùïú (s : Set E) ‚Üî x ‚àà s :=\n  by\n  refine' ‚ü®fun h => _, fun h => subset_convexHull _ _ h‚ü©\n  classical\n    have h := K.inter_subset_convex_hull hx hs ‚ü®by simp, h‚ü©\n    by_contra H\n    rwa [‚Üê coe_inter, Finset.disjoint_iff_inter_eq_empty.1 (Finset.disjoint_singleton_right.2 H).symm, coe_empty,\n      convexHull_empty] at h\n#align vertex_mem_convex_hull_iff vertex_mem_convex_hull_iff\n\n",
 "subset_space":
 "protected theorem subset_space (hs : s ‚àà K.faces) : (s : Set E) ‚äÜ K.space :=\n  (subset_convexHull ùïú _).trans <| convexHull_subset_space hs\n#align subset_space subset_space\n\n",
 "space_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚ä•¬ª -/\ntheorem space_bot : (¬´expr‚ä•¬ª : SimplicialComplex ùïú E).space = ‚àÖ :=\n  Set.bunion·µ¢_empty _\n#align space_bot space_bot\n\n",
 "not_facet_iff_subface":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚äÇ ¬ª -/\ntheorem not_facet_iff_subface (hs : s ‚àà K.faces) : s ‚àâ K.facets ‚Üî ‚àÉ t, t ‚àà K.faces ‚àß ¬´expr ‚äÇ ¬ª s t :=\n  by\n  refine' ‚ü®fun hs' : ¬¨(_ ‚àß _) => _, _‚ü©\n  ¬∑ push_neg  at hs'\n    obtain ‚ü®t, ht‚ü© := hs' hs\n    exact ‚ü®t, ht.1, ‚ü®ht.2.1, fun hts => ht.2.2 (subset.antisymm ht.2.1 hts)‚ü©‚ü©\n  ¬∑ rintro ‚ü®t, ht‚ü© ‚ü®hs, hs'‚ü©\n    have := hs' ht.1 ht.2.1\n    rw [this] at ht\n    exact ht.2.2 (subset.refl t)\n#align not_facet_iff_subface not_facet_iff_subface\n\n",
 "mem_vertices":
 "theorem mem_vertices : x ‚àà K.vertices ‚Üî {x} ‚àà K.faces :=\n  iff.rfl\n#align mem_vertices mem_vertices\n\n",
 "mem_space_iff":
 "/-\nCopyright (c) 2021 Ya√´l Dillies, Bhavik Mehta. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Ya√´l Dillies, Bhavik Mehta\n-/\n-- TODO: update to new binder order? not sure what binder order is correct for `down_closed`.\ntheorem mem_space_iff : x ‚àà K.space ‚Üî ‚àÉ s ‚àà K.faces, x ‚àà convexHull ùïú (s : Set E) :=\n  mem_union·µ¢‚ÇÇ\n#align mem_space_iff mem_space_iff\n\n",
 "mem_facets":
 "theorem mem_facets : s ‚àà K.facets ‚Üî s ‚àà K.faces ‚àß ‚àÄ t ‚àà K.faces, s ‚äÜ t ‚Üí s = t :=\n  mem_sep_iff\n#align mem_facets mem_facets\n\n",
 "facets_subset":
 "theorem facets_subset : K.facets ‚äÜ K.faces := fun s hs => hs.1\n#align facets_subset facets_subset\n\n",
 "facets_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚ä•¬ª -/\ntheorem facets_bot : (¬´expr‚ä•¬ª : SimplicialComplex ùïú E).facets = ‚àÖ :=\n  eq_empty_of_subset_empty facets_subset\n#align facets_bot facets_bot\n\n",
 "faces_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚ä•¬ª -/\n-- `has_ssubset.ssubset.ne` would be handy here\ntheorem faces_bot : (¬´expr‚ä•¬ª : SimplicialComplex ùïú E).faces = ‚àÖ :=\n  rfl\n#align faces_bot faces_bot\n\n",
 "face_subset_face_iff":
 "/-- A face is a subset of another one iff its vertices are.  -/\ntheorem face_subset_face_iff (hs : s ‚àà K.faces) (ht : t ‚àà K.faces) :\n    convexHull ùïú (s : Set E) ‚äÜ convexHull ùïú ‚Üët ‚Üî s ‚äÜ t :=\n  ‚ü®fun h x hxs =>\n    (vertex_mem_convexHull_iff (K.down_closed hs (Finset.singleton_subset_iff.2 hxs) <| singleton_ne_empty _) ht).1\n      (h (subset_convexHull ùïú (‚Üës) hxs)),\n    convexHull_mono‚ü©\n#align face_subset_face_iff face_subset_face_iff\n\n",
 "disjoint_or_exists_inter_eq_convex_hull":
 "/-- The conclusion is the usual meaning of \"glue nicely\" in textbooks. It turns out to be quite\nunusable, as it's about faces as sets in space rather than simplices. Further,  additional structure\non `ùïú` means the only choice of `u` is `s ‚à© t` (but it's hard to prove). -/\ntheorem disjoint_or_exists_inter_eq_convex_hull (hs : s ‚àà K.faces) (ht : t ‚àà K.faces) :\n    Disjoint (convexHull ùïú (s : Set E)) (convexHull ùïú ‚Üët) ‚à®\n      ‚àÉ u ‚àà K.faces, convexHull ùïú (s : Set E) ‚à© convexHull ùïú ‚Üët = convexHull ùïú ‚Üëu :=\n  by\n  classical\n    by_contra' h\n    refine'\n      h.2 (s ‚à© t)\n        (K.down_closed hs (inter_subset_left _ _) fun hst =>\n          h.1 <| disjoint_iff_inf_le.mpr <| (K.inter_subset_convex_hull hs ht).trans _)\n        _\n    ¬∑ rw [‚Üê coe_inter, hst, coe_empty, convexHull_empty]\n      rfl\n    ¬∑ rw [coe_inter, convex_hull_inter_convex_hull hs ht]\n#align disjoint_or_exists_inter_eq_convex_hull disjoint_or_exists_inter_eq_convex_hull\n\n",
 "convex_hull_subset_space":
 "theorem convex_hull_subset_space (hs : s ‚àà K.faces) : convexHull ùïú ‚Üës ‚äÜ K.space :=\n  subset_bunion·µ¢_of_mem hs\n#align convex_hull_subset_space convex_hull_subset_space\n\n",
 "convex_hull_inter_convex_hull":
 "theorem convex_hull_inter_convex_hull (hs : s ‚àà K.faces) (ht : t ‚àà K.faces) :\n    convexHull ùïú ‚Üës ‚à© convexHull ùïú ‚Üët = convexHull ùïú (s ‚à© t : Set E) :=\n  (K.inter_subset_convex_hull hs ht).antisymm <|\n    subset_inter (convexHull_mono <| Set.inter_subset_left _ _) <| convexHull_mono <| Set.inter_subset_right _ _\n#align convex_hull_inter_convex_hull convex_hull_inter_convex_hull\n\n"}