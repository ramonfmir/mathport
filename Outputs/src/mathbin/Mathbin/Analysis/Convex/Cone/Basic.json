{"to_ordered_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/-- Constructs an ordered module given an `ordered_add_comm_group`, a cone, and a proof that\nthe order relation is the one defined by the cone.\n-/\ntheorem to_ordered_smul (S : convex_cone ğ•œ E) (h : âˆ€ x y : E, x â‰¤ y â†” y - x âˆˆ S) : ordered_smul ğ•œ E :=\n  ordered_smul.mk'\n    (by\n      intro x y z xy hz\n      rw [h (Â«expr â€¢ Â» z x) (Â«expr â€¢ Â» z y), â† smul_sub z y x]\n      exact smul_mem S hz ((h x y).mp xy.le))\n#align to_ordered_smul to_ordered_smul\n\n",
 "to_convex_cone_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\n@[simp]\ntheorem to_convex_cone_top : (Â«exprâŠ¤Â» : submodule ğ•œ E).to_convex_cone = Â«exprâŠ¤Â» :=\n  rfl\n#align to_convex_cone_top to_convex_cone_top\n\n",
 "to_convex_cone_le_iff":
 "@[simp]\ntheorem to_convex_cone_le_iff {S T : submodule ğ•œ E} : S.to_convex_cone â‰¤ T.to_convex_cone â†” S â‰¤ T :=\n  iff.rfl\n#align to_convex_cone_le_iff to_convex_cone_le_iff\n\n",
 "to_convex_cone_inf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŠ“ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŠ“ Â» -/\n@[simp]\ntheorem to_convex_cone_inf (S T : submodule ğ•œ E) :\n    (Â«expr âŠ“ Â» S T).to_convex_cone = Â«expr âŠ“ Â» S.to_convex_cone T.to_convex_cone :=\n  rfl\n#align to_convex_cone_inf to_convex_cone_inf\n\n",
 "to_convex_cone_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¥Â» -/\n@[simp]\ntheorem to_convex_cone_bot : (Â«exprâŠ¥Â» : submodule ğ•œ E).to_convex_cone = 0 :=\n  rfl\n#align to_convex_cone_bot to_convex_cone_bot\n\n",
 "to_cone_is_least":
 "/-- `hs.to_cone s` is the least cone that includes `s`. -/\ntheorem to_cone_is_least : IsLeast { t : convex_cone ğ•œ E | s âŠ† t } (hs.to_cone s) :=\n  by\n  refine' âŸ¨hs.subset_to_cone, fun t ht x hx => _âŸ©\n  rcases hs.mem_to_cone.1 hx with âŸ¨c, hc, y, hy, rflâŸ©\n  exact t.smul_mem hc (ht hy)\n#align to_cone_is_least to_cone_is_least\n\n",
 "to_cone_eq_Inf":
 "theorem to_cone_eq_Inf : hs.to_cone s = infâ‚› { t : convex_cone ğ•œ E | s âŠ† t } :=\n  hs.to_cone_is_least.is_glb.Inf_eq.symm\n#align to_cone_eq_Inf to_cone_eq_Inf\n\n",
 "subset_to_cone":
 "theorem subset_to_cone : s âŠ† hs.to_cone s := fun x hx => hs.mem_to_cone'.2 âŸ¨1, zero_lt_one, by rwa [one_smul]âŸ©\n#align subset_to_cone subset_to_cone\n\n",
 "step":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\n/-- Induction step in M. Riesz extension theorem. Given a convex cone `s` in a vector space `E`,\na partially defined linear map `f : f.domain â†’ â„`, assume that `f` is nonnegative on `f.domain âˆ© p`\nand `p + s = E`. If `f` is not defined on the whole `E`, then we can extend it to a larger\nsubmodule without breaking the non-negativity condition. -/\ntheorem step (nonneg : âˆ€ x : f.domain, (x : E) âˆˆ s â†’ 0 â‰¤ f x) (dense : âˆ€ y, âˆƒ x : f.domain, (x : E) + y âˆˆ s)\n    (hdom : f.domain â‰  Â«exprâŠ¤Â») : âˆƒ g, f < g âˆ§ âˆ€ x : g.domain, (x : E) âˆˆ s â†’ 0 â‰¤ g x :=\n  by\n  obtain âŸ¨y, -, hyâŸ© : âˆƒ (y : E)(h : y âˆˆ Â«exprâŠ¤Â»), y âˆ‰ f.domain :=\n    @SetLike.exists_of_lt (submodule (exprâ„) E) _ _ _ _ (lt_top_iff_ne_top.2 hdom)\n  obtain âŸ¨c, le_c, c_leâŸ© :\n    âˆƒ c, (âˆ€ x : f.domain, -(x : E) - y âˆˆ s â†’ f x â‰¤ c) âˆ§ âˆ€ x : f.domain, (x : E) + y âˆˆ s â†’ c â‰¤ f x :=\n    by\n    set Sp := Â«expr '' Â» f { x : f.domain | (x : E) + y âˆˆ s }\n    set Sn := Â«expr '' Â» f { x : f.domain | -(x : E) - y âˆˆ s }\n    suffices (upperBounds Sn âˆ© lowerBounds Sp).nonempty by\n      simpa only [Set.Nonempty, upperBounds, lowerBounds, ball_image_iff] using this\n    refine' exists_between_of_forall_le (nonempty.image f _) (nonempty.image f (dense y)) _\n    Â· rcases dense (-y) with âŸ¨x, hxâŸ©\n      rw [â† neg_neg x, add_subgroup_class.coe_neg, â† sub_eq_add_neg] at hx\n      exact âŸ¨_, hxâŸ©\n    rintro a âŸ¨xn, hxn, rflâŸ© b âŸ¨xp, hxp, rflâŸ©\n    have := s.add_mem hxp hxn\n    rw [add_assoc, add_sub_cancel'_right, â† sub_eq_add_neg, â† add_subgroup_class.coe_sub] at this\n    replace := nonneg _ this\n    rwa [f.map_sub, sub_nonneg] at this\n  have hy' : y â‰  0 := fun hyâ‚€ => hy (hyâ‚€.symm â–¸ zero_mem _)\n  refine' âŸ¨f.sup_span_singleton y (-c) hy, _, _âŸ©\n  Â· refine' lt_iff_le_not_le.2 âŸ¨f.left_le_sup _ _, fun H => _âŸ©\n    replace H := linear_pmap.domain_mono.monotone H\n    rw [linear_pmap.domain_sup_span_singleton, sup_le_iff, span_le, singleton_subset_iff] at H\n    exact hy H.2\n  Â· rintro âŸ¨z, hzâŸ© hzs\n    rcases mem_sup.1 hz with âŸ¨x, hx, y', hy', rflâŸ©\n    rcases mem_span_singleton.1 hy' with âŸ¨r, rflâŸ©\n    simp only [subtype.coe_mk] at hzs\n    erw [linear_pmap.sup_span_singleton_apply_mk _ _ _ _ _ hx, smul_neg, â† sub_eq_add_neg, sub_nonneg]\n    rcases lt_trichotomy r 0 with (hr | hr | hr)\n    Â· have : -Â«expr â€¢ Â» râ»Â¹ x - y âˆˆ s := by\n        rwa [â† s.smul_mem_iff (neg_pos.2 hr), smul_sub, smul_neg, neg_smul, neg_neg, smul_smul, mul_inv_cancel hr.ne,\n          one_smul, sub_eq_add_neg, neg_smul, neg_neg]\n      replace := le_c (Â«expr â€¢ Â» râ»Â¹ âŸ¨x, hxâŸ©) this\n      rwa [â† mul_le_mul_left (neg_pos.2 hr), neg_mul, neg_mul, neg_le_neg_iff, f.map_smul, smul_eq_mul, â† mul_assoc,\n        mul_inv_cancel hr.ne, one_mul] at this\n    Â· subst r\n      simp only [zero_smul, add_zero] at hzsâŠ¢\n      apply nonneg\n      exact hzs\n    Â· have : Â«expr â€¢ Â» râ»Â¹ x + y âˆˆ s := by\n        rwa [â† s.smul_mem_iff hr, smul_add, smul_smul, mul_inv_cancel hr.ne', one_smul]\n      replace := c_le (Â«expr â€¢ Â» râ»Â¹ âŸ¨x, hxâŸ©) this\n      rwa [â† mul_le_mul_left hr, f.map_smul, smul_eq_mul, â† mul_assoc, mul_inv_cancel hr.ne', one_mul] at this\n#align step step\n\n",
 "smul_mem_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\ntheorem smul_mem_iff {c : ğ•œ} (hc : 0 < c) {x : E} : Â«expr â€¢ Â» c x âˆˆ S â†” x âˆˆ S :=\n  âŸ¨fun h => inv_smul_smulâ‚€ hc.ne' x â–¸ S.smul_mem (inv_pos.2 hc) h, S.smul_mem hcâŸ©\n#align smul_mem_iff smul_mem_iff\n\n",
 "smul_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n#print smul_mem /-\ntheorem smul_mem {c : ğ•œ} {x : E} (hc : 0 < c) (hx : x âˆˆ S) : Â«expr â€¢ Â» c x âˆˆ S :=\n  S.smul_mem' hc hx\n#align smul_mem smul_mem\n-/\n\n",
 "salient_strictly_positive":
 "/-- The strictly positive cone of an ordered module is always salient. -/\ntheorem salient_strictly_positive : salient (strictly_positive ğ•œ E) :=\n  (salient_positive ğ•œ E).anti <| positive_le_strictly_positive ğ•œ E\n#align salient_strictly_positive salient_strictly_positive\n\n",
 "salient_positive":
 "/-- The positive cone of an ordered module is always salient. -/\ntheorem salient_positive : salient (positive ğ•œ E) := fun x xs hx hx' =>\n  lt_irrefl (0 : E)\n    (calc\n      0 < x := lt_of_le_of_ne xs hx.symm\n      _ â‰¤ x + -x := le_add_of_nonneg_right hx'\n      _ = 0 := add_neg_self x\n      )\n#align salient_positive salient_positive\n\n",
 "salient_iff_not_flat":
 "theorem salient_iff_not_flat (S : convex_cone ğ•œ E) : S.salient â†” Â¬S.flat :=\n  by\n  constructor\n  Â· rintro hâ‚ âŸ¨x, xs, Hâ‚, Hâ‚‚âŸ©\n    exact hâ‚ x xs Hâ‚ Hâ‚‚\n  Â· intro h\n    unfold flat at h\n    push_neg  at h\n    exact h\n#align salient_iff_not_flat salient_iff_not_flat\n\n",
 "salient":
 "/-- A blunt cone (one not containing `0`) is always salient. -/\ntheorem blunt.salient {S : convex_cone ğ•œ E} : S.blunt â†’ S.salient :=\n  by\n  rw [salient_iff_not_flat, blunt_iff_not_pointed]\n  exact mt flat.pointed\n#align blunt.salient blunt.salient\n\n",
 "riesz_extension":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âˆ˜â‚— Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚—.[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚—[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/-- M. **Riesz extension theorem**: given a convex cone `s` in a vector space `E`, a submodule `p`,\nand a linear `f : p â†’ â„`, assume that `f` is nonnegative on `p âˆ© s` and `p + s = E`. Then\nthere exists a globally defined linear function `g : E â†’ â„` that agrees with `f` on `p`,\nand is nonnegative on `s`. -/\ntheorem riesz_extension (s : convex_cone (exprâ„) E) (f : Â«expr â†’â‚—.[ ] Â» E (exprâ„) (exprâ„))\n    (nonneg : âˆ€ x : f.domain, (x : E) âˆˆ s â†’ 0 â‰¤ f x) (dense : âˆ€ y, âˆƒ x : f.domain, (x : E) + y âˆˆ s) :\n    âˆƒ g : Â«expr â†’â‚—[ ] Â» E (exprâ„) (exprâ„), (âˆ€ x : f.domain, g x = f x) âˆ§ âˆ€ x âˆˆ s, 0 â‰¤ g x :=\n  by\n  rcases riesz_extension.exists_top s f nonneg dense with âŸ¨âŸ¨g_dom, gâŸ©, âŸ¨hpg, hfgâŸ©, htop, hgsâŸ©\n  clear hpg\n  refine' âŸ¨Â«expr âˆ˜â‚— Â» g â†‘(linear_equiv.of_top _ htop).symm, _, _âŸ© <;>\n    simp only [comp_apply, linear_equiv.coe_coe, linear_equiv.of_top_symm_apply]\n  Â· exact fun x => (hfg (submodule.coe_mk _ _).symm).symm\n  Â· exact fun x hx => hgs âŸ¨x, _âŸ© hx\n#align riesz_extension riesz_extension\n\n",
 "positive_le_strictly_positive":
 "theorem positive_le_strictly_positive : strictly_positive ğ•œ E â‰¤ positive ğ•œ E := fun x => le_of_lt\n#align positive_le_strictly_positive positive_le_strictly_positive\n\n",
 "pointed_zero":
 "theorem pointed_zero : (0 : convex_cone ğ•œ E).pointed := by rw [pointed, mem_zero]\n#align pointed_zero pointed_zero\n\n",
 "pointed_to_convex_cone":
 "@[simp]\ntheorem pointed_to_convex_cone (S : submodule ğ•œ E) : S.to_convex_cone.pointed :=\n  S.zero_mem\n#align pointed_to_convex_cone pointed_to_convex_cone\n\n",
 "pointed_positive":
 "/-- The positive cone of an ordered module is always pointed. -/\ntheorem pointed_positive : pointed (positive ğ•œ E) :=\n  le_refl 0\n#align pointed_positive pointed_positive\n\n",
 "pointed_of_nonempty_of_is_closed":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:219:4: warning: unsupported binary notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\ntheorem convex_cone.pointed_of_nonempty_of_is_closed (K : convex_cone (exprâ„) H) (ne : (K : set H).nonempty)\n    (hc : is_closed (K : set H)) : K.pointed := by\n  obtain âŸ¨x, hxâŸ© := ne\n  let f : exprâ„ â†’ H := (Â«expr â€¢ Â» Â· x)\n  -- f (0, âˆ) is a subset of K\n  have fI : Â«expr '' Â» f (Set.Ioi 0) âŠ† (K : set H) :=\n    by\n    rintro _ âŸ¨_, h, rflâŸ©\n    exact K.smul_mem (Set.mem_Ioi.1 h) hx\n  -- closure of f (0, âˆ) is a subset of K\n  have clf : closure (Â«expr '' Â» f (Set.Ioi 0)) âŠ† (K : set H) := hc.closure_subset_iff.2 fI\n  -- f is continuous at 0 from the right\n  have fc : continuous_within_at f (Set.Ioi (0 : exprâ„)) 0 := (continuous_id.smul continuous_const).continuous_within_at\n  -- 0 belongs to the closure of the f (0, âˆ)\n  have memâ‚€ := fc.mem_closure_image (by rw [closure_Ioi (0 : exprâ„), mem_Ici])\n  -- as 0 âˆˆ closure f (0, âˆ) and closure f (0, âˆ) âŠ† K, 0 âˆˆ K.\n  have fâ‚€ : f 0 = 0 := zero_smul (exprâ„) x\n  simpa only [fâ‚€, convex_cone.pointed, â† SetLike.mem_coe] using mem_of_subset_of_mem clf memâ‚€\n#align convex_cone.pointed_of_nonempty_of_is_closed convex_cone.pointed_of_nonempty_of_is_closed\n\n",
 "pointed_inner_dual_cone":
 "theorem pointed_inner_dual_cone : s.inner_dual_cone.pointed := fun x hx => by rw [inner_zero_right]\n#align pointed_inner_dual_cone pointed_inner_dual_cone\n\n",
 "pointed_iff_not_blunt":
 "theorem pointed_iff_not_blunt (S : convex_cone ğ•œ E) : S.pointed â†” Â¬S.blunt :=\n  âŸ¨fun hâ‚ hâ‚‚ => hâ‚‚ hâ‚, not_not.mpâŸ©\n#align pointed_iff_not_blunt pointed_iff_not_blunt\n\n",
 "pointed":
 "/-- A flat cone is always pointed (contains `0`). -/\ntheorem flat.pointed {S : convex_cone ğ•œ E} (hS : S.flat) : S.pointed :=\n  by\n  obtain âŸ¨x, hx, _, hxnegâŸ© := hS\n  rw [pointed, â† add_neg_self x]\n  exact add_mem S hx hxneg\n#align flat.pointed flat.pointed\n\n",
 "mono":
 "theorem flat.mono {S T : convex_cone ğ•œ E} (h : S â‰¤ T) : S.flat â†’ T.flat\n  | âŸ¨x, hxS, hx, hnxSâŸ© => âŸ¨x, h hxS, hx, h hnxSâŸ©\n#align flat.mono flat.mono\n\n",
 "mem_zero":
 "@[simp]\ntheorem mem_zero (x : E) : x âˆˆ (0 : convex_cone ğ•œ E) â†” x = 0 :=\n  iff.rfl\n#align mem_zero mem_zero\n\n",
 "mem_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\ntheorem mem_top (x : E) : x âˆˆ (Â«exprâŠ¤Â» : convex_cone ğ•œ E) :=\n  mem_univ x\n#align mem_top mem_top\n\n",
 "mem_to_convex_cone":
 "@[simp]\ntheorem mem_to_convex_cone {x : E} {S : submodule ğ•œ E} : x âˆˆ S.to_convex_cone â†” x âˆˆ S :=\n  iff.rfl\n#align mem_to_convex_cone mem_to_convex_cone\n\n",
 "mem_to_cone'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\ntheorem mem_to_cone' : x âˆˆ hs.to_cone s â†” âˆƒ c : ğ•œ, 0 < c âˆ§ Â«expr â€¢ Â» c x âˆˆ s :=\n  by\n  refine' hs.mem_to_cone.trans âŸ¨_, _âŸ©\n  Â· rintro âŸ¨c, hc, y, hy, rflâŸ©\n    exact âŸ¨câ»Â¹, inv_pos.2 hc, by rwa [smul_smul, inv_mul_cancel hc.ne', one_smul]âŸ©\n  Â· rintro âŸ¨c, hc, hcxâŸ©\n    exact âŸ¨câ»Â¹, inv_pos.2 hc, _, hcx, by rw [smul_smul, inv_mul_cancel hc.ne', one_smul]âŸ©\n#align mem_to_cone' mem_to_cone'\n\n",
 "mem_to_cone":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\ntheorem mem_to_cone : x âˆˆ hs.to_cone s â†” âˆƒ c : ğ•œ, 0 < c âˆ§ âˆƒ y âˆˆ s, Â«expr â€¢ Â» c y = x := by\n  simp only [to_cone, convex_cone.mem_mk, mem_Union, mem_smul_set, eq_comm, exists_prop]\n#align mem_to_cone mem_to_cone\n\n",
 "mem_strictly_positive":
 "@[simp]\ntheorem mem_strictly_positive {x : E} : x âˆˆ strictly_positive ğ•œ E â†” 0 < x :=\n  iff.rfl\n#align mem_strictly_positive mem_strictly_positive\n\n",
 "mem_positive":
 "@[simp]\ntheorem mem_positive {x : E} : x âˆˆ positive ğ•œ E â†” 0 â‰¤ x :=\n  iff.rfl\n#align mem_positive mem_positive\n\n",
 "mem_mk":
 "@[simp]\ntheorem mem_mk {s : set E} {hâ‚ hâ‚‚ x} : x âˆˆ @mk ğ•œ _ _ _ _ s hâ‚ hâ‚‚ â†” x âˆˆ s :=\n  iff.rfl\n#align mem_mk mem_mk\n\n",
 "mem_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚—[ ] Â» -/\n@[simp]\ntheorem mem_map {f : Â«expr â†’â‚—[ ] Â» E ğ•œ F} {S : convex_cone ğ•œ E} {y : F} : y âˆˆ S.map f â†” âˆƒ x âˆˆ S, f x = y :=\n  mem_image_iff_bex\n#align mem_map mem_map\n\n",
 "mem_inner_dual_cone":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `inner.real -/\n@[simp]\ntheorem mem_inner_dual_cone (y : H) (s : set H) : y âˆˆ s.inner_dual_cone â†” âˆ€ x âˆˆ s, 0 â‰¤ inner.real x y :=\n  iff.rfl\n#align mem_inner_dual_cone mem_inner_dual_cone\n\n",
 "mem_infi":
 "theorem mem_infi {Î¹ : Sort _} {x : E} {f : Î¹ â†’ convex_cone ğ•œ E} : x âˆˆ infáµ¢ f â†” âˆ€ i, x âˆˆ f i :=\n  mem_interáµ¢â‚‚.trans <| by simp\n#align mem_infi mem_infi\n\n",
 "mem_inf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŠ“ Â» -/\ntheorem mem_inf {x} : x âˆˆ Â«expr âŠ“ Â» S T â†” x âˆˆ S âˆ§ x âˆˆ T :=\n  iff.rfl\n#align mem_inf mem_inf\n\n",
 "mem_comap":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚—[ ] Â» -/\n@[simp]\ntheorem mem_comap {f : Â«expr â†’â‚—[ ] Â» E ğ•œ F} {S : convex_cone ğ•œ F} {x : E} : x âˆˆ S.comap f â†” f x âˆˆ S :=\n  iff.rfl\n#align mem_comap mem_comap\n\n",
 "mem_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¥Â» -/\ntheorem mem_bot (x : E) : (x âˆˆ (Â«exprâŠ¥Â» : convex_cone ğ•œ E)) = false :=\n  rfl\n#align mem_bot mem_bot\n\n",
 "mem_add":
 "@[simp]\ntheorem mem_add {Kâ‚ Kâ‚‚ : convex_cone ğ•œ E} {a : E} : a âˆˆ Kâ‚ + Kâ‚‚ â†” âˆƒ x y : E, x âˆˆ Kâ‚ âˆ§ y âˆˆ Kâ‚‚ âˆ§ x + y = a :=\n  iff.rfl\n#align mem_add mem_add\n\n",
 "mem_Inf":
 "theorem mem_Inf {x : E} {S : set (convex_cone ğ•œ E)} : x âˆˆ infâ‚› S â†” âˆ€ s âˆˆ S, x âˆˆ s :=\n  mem_Interâ‚‚\n#align mem_Inf mem_Inf\n\n",
 "map_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚—[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚—[ ] Â» -/\ntheorem map_map (g : Â«expr â†’â‚—[ ] Â» F ğ•œ G) (f : Â«expr â†’â‚—[ ] Â» E ğ•œ F) (S : convex_cone ğ•œ E) :\n    (S.map f).map g = S.map (g.comp f) :=\n  SetLike.coe_injective <| image_image g f S\n#align map_map map_map\n\n",
 "map_id":
 "@[simp]\ntheorem map_id (S : convex_cone ğ•œ E) : S.map linear_map.id = S :=\n  SetLike.coe_injective <| image_id _\n#align map_id map_id\n\n",
 "is_closed_inner_dual_cone":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\ntheorem is_closed_inner_dual_cone : is_closed (s.inner_dual_cone : set H) :=\n  by\n  -- reduce the problem to showing that dual cone of a singleton `{x}` is closed\n  rw [inner_dual_cone_eq_Inter_inner_dual_cone_singleton]\n  apply is_closed_Inter\n  intro x\n  -- the dual cone of a singleton `{x}` is the preimage of `[0, âˆ)` under `inner x`\n  have h : â†‘({x} : set H).inner_dual_cone = Â«expr â»Â¹' Â» (inner x : H â†’ exprâ„) (Set.Ici 0) := by\n    rw [inner_dual_cone_singleton, convex_cone.coe_comap, convex_cone.coe_positive, innerâ‚›â‚—_apply_coe]\n  -- the preimage is closed as `inner x` is continuous and `[0, âˆ)` is closed\n  rw [h]\n  exact is_closed_Ici.preimage (by continuity)\n#align is_closed_inner_dual_cone is_closed_inner_dual_cone\n\n",
 "inner_dual_cone_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\n/-- Dual cone of the convex cone {0} is the total space. -/\n@[simp]\ntheorem inner_dual_cone_zero : (0 : set H).inner_dual_cone = Â«exprâŠ¤Â» :=\n  eq_top_iff.mpr fun x hy y (hy : y = 0) => hy.symm â–¸ inner_zero_left.ge\n#align inner_dual_cone_zero inner_dual_cone_zero\n\n",
 "inner_dual_cone_univ":
 "/-- Dual cone of the total space is the convex cone {0}. -/\n@[simp]\ntheorem inner_dual_cone_univ : (univ : set H).inner_dual_cone = 0 :=\n  by\n  suffices âˆ€ x : H, x âˆˆ (univ : set H).inner_dual_cone â†’ x = 0\n    by\n    apply SetLike.coe_injective\n    exact eq_singleton_iff_unique_mem.mpr âŸ¨fun x hx => inner_zero_right.ge, thisâŸ©\n  exact fun x hx => by simpa [â† real_inner_self_nonpos] using hx (-x) (mem_univ _)\n#align inner_dual_cone_univ inner_dual_cone_univ\n\n",
 "inner_dual_cone_union":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŠ“ Â» -/\ntheorem inner_dual_cone_union (s t : set H) : (s âˆª t).inner_dual_cone = Â«expr âŠ“ Â» s.inner_dual_cone t.inner_dual_cone :=\n  le_antisymm (le_inf (fun x hx y hy => hx _ <| or.inl hy) fun x hx y hy => hx _ <| or.inr hy) fun x hx y =>\n    or.rec (hx.1 _) (hx.2 _)\n#align inner_dual_cone_union inner_dual_cone_union\n\n",
 "inner_dual_cone_singleton":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/-- The inner dual cone of a singleton is given by the preimage of the positive cone under the\nlinear map `Î» y, âŸªx, yâŸ«`. -/\ntheorem inner_dual_cone_singleton (x : H) :\n    ({x} : set H).inner_dual_cone = (convex_cone.positive (exprâ„) (exprâ„)).comap (innerâ‚›â‚— x) :=\n  convex_cone.ext fun i => forall_eq\n#align inner_dual_cone_singleton inner_dual_cone_singleton\n\n",
 "inner_dual_cone_sUnion":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\ntheorem inner_dual_cone_sUnion (S : set (set H)) : (â‹ƒâ‚€ S).inner_dual_cone = infâ‚› (Â«expr '' Â» set.inner_dual_cone S) :=\n  by simp_rw [infâ‚›_image, sUnion_eq_bUnion, inner_dual_cone_Union]\n#align inner_dual_cone_sUnion inner_dual_cone_sUnion\n\n",
 "inner_dual_cone_of_inner_dual_cone_eq_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/-- The inner dual of inner dual of a non-empty, closed convex cone is itself.  -/\ntheorem convex_cone.inner_dual_cone_of_inner_dual_cone_eq_self (K : convex_cone (exprâ„) H) (ne : (K : set H).nonempty)\n    (hc : is_closed (K : set H)) : ((K : set H).inner_dual_cone : set H).inner_dual_cone = K :=\n  by\n  ext x\n  constructor\n  Â· rw [mem_inner_dual_cone, â† SetLike.mem_coe]\n    contrapose!\n    exact K.hyperplane_separation_of_nonempty_of_is_closed_of_nmem ne hc\n  Â· rintro hxK y h\n    specialize h x hxK\n    rwa [real_inner_comm]\n#align convex_cone.inner_dual_cone_of_inner_dual_cone_eq_self convex_cone.inner_dual_cone_of_inner_dual_cone_eq_self\n\n",
 "inner_dual_cone_le_inner_dual_cone":
 "theorem inner_dual_cone_le_inner_dual_cone (h : t âŠ† s) : s.inner_dual_cone â‰¤ t.inner_dual_cone := fun y hy x hx =>\n  hy x (h hx)\n#align inner_dual_cone_le_inner_dual_cone inner_dual_cone_le_inner_dual_cone\n\n",
 "inner_dual_cone_insert":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŠ“ Â» -/\ntheorem inner_dual_cone_insert (x : H) (s : set H) :\n    (insert x s).inner_dual_cone = Â«expr âŠ“ Â» (set.inner_dual_cone {x}) s.inner_dual_cone := by\n  rw [insert_eq, inner_dual_cone_union]\n#align inner_dual_cone_insert inner_dual_cone_insert\n\n",
 "inner_dual_cone_eq_Inter_inner_dual_cone_singleton":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹‚ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹‚ , Â» -/\n/-- The dual cone of `s` equals the intersection of dual cones of the points in `s`. -/\ntheorem inner_dual_cone_eq_Inter_inner_dual_cone_singleton :\n    (s.inner_dual_cone : set H) =\n      Â«exprâ‹‚ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹‚ , Â»\"\n        (({i} : set H).inner_dual_cone : set H) :=\n  by rw [â† convex_cone.coe_infi, â† inner_dual_cone_Union, Union_of_singleton_coe]\n#align inner_dual_cone_eq_Inter_inner_dual_cone_singleton inner_dual_cone_eq_Inter_inner_dual_cone_singleton\n\n",
 "inner_dual_cone_empty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\n@[simp]\ntheorem inner_dual_cone_empty : (âˆ… : set H).inner_dual_cone = Â«exprâŠ¤Â» :=\n  eq_top_iff.mpr fun x hy y => false.elim\n#align inner_dual_cone_empty inner_dual_cone_empty\n\n",
 "inner_dual_cone_Union":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ¨… , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨… , Â» -/\ntheorem inner_dual_cone_Union {Î¹ : Sort _} (f : Î¹ â†’ set H) :\n    (Â«exprâ‹ƒ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â»\"\n          (f i)).inner_dual_cone =\n      Â«exprâ¨… , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨… , Â»\"\n        (f i).inner_dual_cone :=\n  by\n  refine' le_antisymm (le_infáµ¢ fun i x hx y hy => hx _ <| mem_Union_of_mem _ hy) _\n  intro x hx y hy\n  rw [convex_cone.mem_infi] at hx\n  obtain âŸ¨j, hjâŸ© := mem_Union.mp hy\n  exact hx _ _ hj\n#align inner_dual_cone_Union inner_dual_cone_Union\n\n",
 "hyperplane_separation_of_nonempty_of_is_closed_of_nmem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŸª , âŸ«_â„Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŸª , âŸ«_â„Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŸª , âŸ«_â„Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŸª , âŸ«_â„Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŸª , âŸ«_â„Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŸª , âŸ«_â„Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŸª , âŸ«_â„Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŸª , âŸ«_â„Â» -/\n/-- This is a stronger version of the Hahn-Banach separation theorem for closed convex cones. This\nis also the geometric interpretation of Farkas' lemma. -/\ntheorem convex_cone.hyperplane_separation_of_nonempty_of_is_closed_of_nmem (K : convex_cone (exprâ„) H)\n    (ne : (K : set H).nonempty) (hc : is_closed (K : set H)) {b : H} (disj : b âˆ‰ K) :\n    âˆƒ y : H, (âˆ€ x : H, x âˆˆ K â†’ 0 â‰¤ Â«exprâŸª , âŸ«_â„Â» x y) âˆ§ Â«exprâŸª , âŸ«_â„Â» y b < 0 :=\n  by\n  -- let `z` be the point in `K` closest to `b`\n  obtain âŸ¨z, hzK, infiâŸ© := exists_norm_eq_infi_of_complete_convex ne hc.is_complete K.convex b\n  -- for any `w` in `K`, we have `âŸªb - z, w - zâŸ«_â„ â‰¤ 0`\n  have hinner := (norm_eq_infi_iff_real_inner_le_zero K.convex hzK).1 infáµ¢\n  -- set `y := z - b`\n  use z - b\n  constructor\n  Â· -- the rest of the proof is a straightforward calculation\n    rintro x hxK\n    specialize hinner _ (K.add_mem hxK hzK)\n    rwa [add_sub_cancel, real_inner_comm, â† neg_nonneg, neg_eq_neg_one_mul, â† real_inner_smul_right, neg_smul, one_smul,\n      neg_sub] at hinner\n  Â· -- as `K` is closed and non-empty, it is pointed\n    have hinnerâ‚€ := hinner 0 (K.pointed_of_nonempty_of_is_closed ne hc)\n    -- the rest of the proof is a straightforward calculation\n    rw [zero_sub, inner_neg_right, right.neg_nonpos_iff] at hinnerâ‚€\n    have hbz : b - z â‰  0 := by\n      rw [sub_ne_zero]\n      contrapose! hzK\n      rwa [â† hzK]\n    rw [â† neg_zero, lt_neg, â† neg_one_mul, â† real_inner_smul_left, smul_sub, neg_smul, one_smul, neg_smul, neg_sub_neg,\n      one_smul]\n    calc\n      0 < Â«exprâŸª , âŸ«_â„Â» (b - z) (b - z) := lt_of_not_le ((iff.not real_inner_self_nonpos).2 hbz)\n      _ = Â«exprâŸª , âŸ«_â„Â» (b - z) (b - z) + 0 := (add_zero _).symm\n      _ â‰¤ Â«exprâŸª , âŸ«_â„Â» (b - z) (b - z) + Â«exprâŸª , âŸ«_â„Â» (b - z) z := add_le_add rfl.ge hinnerâ‚€\n      _ = Â«exprâŸª , âŸ«_â„Â» (b - z) (b - z + z) := inner_add_right.symm\n      _ = Â«exprâŸª , âŸ«_â„Â» (b - z) b := by rw [sub_add_cancel]\n      \n#align\n  convex_cone.hyperplane_separation_of_nonempty_of_is_closed_of_nmem convex_cone.hyperplane_separation_of_nonempty_of_is_closed_of_nmem\n\n",
 "ext":
 "/-- Two `convex_cone`s are equal if they have the same elements. -/\n@[ext]\ntheorem ext {S T : convex_cone ğ•œ E} (h : âˆ€ x, x âˆˆ S â†” x âˆˆ T) : S = T :=\n  SetLike.ext h\n#align ext ext\n\n",
 "exists_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚—.[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\ntheorem exists_top (p : Â«expr â†’â‚—.[ ] Â» E (exprâ„) (exprâ„)) (hp_nonneg : âˆ€ x : p.domain, (x : E) âˆˆ s â†’ 0 â‰¤ p x)\n    (hp_dense : âˆ€ y, âˆƒ x : p.domain, (x : E) + y âˆˆ s) :\n    âˆƒ q â‰¥ p, q.domain = Â«exprâŠ¤Â» âˆ§ âˆ€ x : q.domain, (x : E) âˆˆ s â†’ 0 â‰¤ q x :=\n  by\n  replace hp_nonneg : p âˆˆ { p | _ };\n  Â· rw [mem_set_of_eq]\n    exact hp_nonneg\n  obtain âŸ¨q, hqs, hpq, hqâŸ© := zorn_nonempty_partialOrderâ‚€ _ _ _ hp_nonneg\n  Â· refine' âŸ¨q, hpq, _, hqsâŸ©\n    contrapose! hq\n    rcases step s q hqs _ hq with âŸ¨r, hqr, hrâŸ©\n    Â· exact âŸ¨r, hr, hqr.le, hqr.ne'âŸ©\n    Â·\n      exact fun y =>\n        let âŸ¨x, hxâŸ© := hp_dense y\n        âŸ¨of_le hpq.left x, hxâŸ©\n  Â· intro c hcs c_chain y hy\n    clear hp_nonneg hp_dense p\n    have cne : c.nonempty := âŸ¨y, hyâŸ©\n    refine' âŸ¨linear_pmap.Sup c c_chain.directed_on, _, fun _ => linear_pmap.le_Sup c_chain.directed_onâŸ©\n    rintro âŸ¨x, hxâŸ© hxs\n    have hdir : DirectedOn (Â· â‰¤ Â·) (Â«expr '' Â» linear_pmap.domain c) :=\n      directedOn_image.2 (c_chain.directed_on.mono linear_pmap.domain_mono.monotone)\n    rcases(mem_Sup_of_directed (cne.image _) hdir).1 hx with âŸ¨_, âŸ¨f, hfc, rflâŸ©, hfxâŸ©\n    have : f â‰¤ linear_pmap.Sup c c_chain.directed_on := linear_pmap.le_Sup _ hfc\n    convert â† hcs hfc âŸ¨x, hfxâŸ© hxs\n    apply this.2\n    rfl\n#align exists_top exists_top\n\n",
 "exists_extension_of_le_sublinear":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚—.[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚—[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/-- **Hahn-Banach theorem**: if `N : E â†’ â„` is a sublinear map, `f` is a linear map\ndefined on a subspace of `E`, and `f x â‰¤ N x` for all `x` in the domain of `f`,\nthen `f` can be extended to the whole space to a linear map `g` such that `g x â‰¤ N x`\nfor all `x`. -/\ntheorem exists_extension_of_le_sublinear (f : Â«expr â†’â‚—.[ ] Â» E (exprâ„) (exprâ„)) (N : E â†’ exprâ„)\n    (N_hom : âˆ€ c : exprâ„, 0 < c â†’ âˆ€ x, N (Â«expr â€¢ Â» c x) = c * N x) (N_add : âˆ€ x y, N (x + y) â‰¤ N x + N y)\n    (hf : âˆ€ x : f.domain, f x â‰¤ N x) :\n    âˆƒ g : Â«expr â†’â‚—[ ] Â» E (exprâ„) (exprâ„), (âˆ€ x : f.domain, g x = f x) âˆ§ âˆ€ x, g x â‰¤ N x :=\n  by\n  let s : convex_cone (exprâ„) (E Ã— exprâ„) :=\n    { carrier := { p : E Ã— exprâ„ | N p.1 â‰¤ p.2 }\n      smul_mem' := fun c hc p hp =>\n        calc\n          N (Â«expr â€¢ Â» c p.1) = c * N p.1 := N_hom c hc p.1\n          _ â‰¤ c * p.2 := mul_le_mul_of_nonneg_left hp hc.le\n          \n      add_mem' := fun x hx y hy => (N_add _ _).trans (add_le_add hx hy) }\n  obtain âŸ¨g, g_eq, g_nonnegâŸ© := riesz_extension s ((-f).coprod (linear_map.id.to_pmap (Â«exprâŠ¤Â»))) _ _ <;>\n    try\n      simp only [linear_pmap.coprod_apply, to_pmap_apply, id_apply, linear_pmap.neg_apply, â† sub_eq_neg_add, sub_nonneg,\n        subtype.coe_mk] at *\n  replace g_eq : âˆ€ (x : f.domain) (y : exprâ„), g (x, y) = y - f x\n  Â· intro x y\n    simpa only [subtype.coe_mk, subtype.coe_eta] using g_eq âŸ¨(x, y), âŸ¨x.2, trivialâŸ©âŸ©\n  Â· refine' âŸ¨-g.comp (inl (exprâ„) E (exprâ„)), _, _âŸ© <;> simp only [neg_apply, inl_apply, comp_apply]\n    Â· intro x\n      simp [g_eq x 0]\n    Â· intro x\n      have A : (x, N x) = (x, 0) + (0, N x) := by simp\n      have B := g_nonneg âŸ¨x, N xâŸ© (le_refl (N x))\n      rw [A, map_add, â† neg_le_iff_add_nonneg'] at B\n      have C := g_eq 0 (N x)\n      simp only [submodule.coe_zero, f.map_zero, sub_zero] at C\n      rwa [â† C]\n  Â· exact fun x hx => le_trans (hf _) hx\n  Â· rintro âŸ¨x, yâŸ©\n    refine' âŸ¨âŸ¨(0, N x - y), âŸ¨f.domain.zero_mem, trivialâŸ©âŸ©, _âŸ©\n    simp only [convex_cone.mem_mk, mem_set_of_eq, subtype.coe_mk, Prod.fst_add, Prod.snd_add, zero_add, sub_add_cancel]\n#align exists_extension_of_le_sublinear exists_extension_of_le_sublinear\n\n",
 "convex_hull_to_cone_is_least":
 "theorem convex_hull_to_cone_is_least (s : set E) :\n    IsLeast { t : convex_cone ğ•œ E | s âŠ† t } ((convex_convex_hull ğ•œ s).to_cone _) :=\n  by\n  convert (convex_convex_hull ğ•œ s).to_cone_is_least\n  ext t\n  exact âŸ¨fun h => convex_hull_min h t.convex, (subset_convex_hull ğ•œ s).transâŸ©\n#align convex_hull_to_cone_is_least convex_hull_to_cone_is_least\n\n",
 "convex_hull_to_cone_eq_Inf":
 "theorem convex_hull_to_cone_eq_Inf (s : set E) :\n    (convex_convex_hull ğ•œ s).to_cone _ = infâ‚› { t : convex_cone ğ•œ E | s âŠ† t } :=\n  eq.symm <| IsGLB.infâ‚›_eq <| IsLeast.isGLB <| convex_hull_to_cone_is_least s\n#align convex_hull_to_cone_eq_Inf convex_hull_to_cone_eq_Inf\n\n",
 "convex":
 "protected theorem convex : convex ğ•œ (S : set E) :=\n  convex_iff_forall_pos.2 fun x hx y hy a b ha hb _ => S.add_mem (S.smul_mem ha hx) (S.smul_mem hb hy)\n#align convex convex\n\n",
 "comap_id":
 "@[simp]\ntheorem comap_id (S : convex_cone ğ•œ E) : S.comap linear_map.id = S :=\n  SetLike.coe_injective preimage_id\n#align comap_id comap_id\n\n",
 "comap_comap":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚—[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚—[ ] Â» -/\ntheorem comap_comap (g : Â«expr â†’â‚—[ ] Â» F ğ•œ G) (f : Â«expr â†’â‚—[ ] Â» E ğ•œ F) (S : convex_cone ğ•œ G) :\n    (S.comap g).comap f = S.comap (g.comp f) :=\n  SetLike.coe_injective <| preimage_comp.symm\n#align comap_comap comap_comap\n\n",
 "coe_zero":
 "@[simp]\ntheorem coe_zero : ((0 : convex_cone ğ•œ E) : set E) = 0 :=\n  rfl\n#align coe_zero coe_zero\n\n",
 "coe_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\n@[simp]\ntheorem coe_top : â†‘(Â«exprâŠ¤Â» : convex_cone ğ•œ E) = (univ : set E) :=\n  rfl\n#align coe_top coe_top\n\n",
 "coe_to_convex_cone":
 "@[simp]\ntheorem coe_to_convex_cone (S : submodule ğ•œ E) : â†‘S.to_convex_cone = (S : set E) :=\n  rfl\n#align coe_to_convex_cone coe_to_convex_cone\n\n",
 "coe_strictly_positive":
 "@[simp]\ntheorem coe_strictly_positive : â†‘(strictly_positive ğ•œ E) = Set.Ioi (0 : E) :=\n  rfl\n#align coe_strictly_positive coe_strictly_positive\n\n",
 "coe_positive":
 "@[simp]\ntheorem coe_positive : â†‘(positive ğ•œ E) = Set.Ici (0 : E) :=\n  rfl\n#align coe_positive coe_positive\n\n",
 "coe_mk":
 "/-\nCopyright (c) 2020 Yury Kudryashov All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov, FrÃ©dÃ©ric Dupuis\n-/\n@[simp]\ntheorem coe_mk {s : set E} {hâ‚ hâ‚‚} : â†‘(@mk ğ•œ _ _ _ _ s hâ‚ hâ‚‚) = s :=\n  rfl\n#align coe_mk coe_mk\n\n",
 "coe_infi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹‚ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹‚ , Â» -/\n@[simp]\ntheorem coe_infi {Î¹ : Sort _} (f : Î¹ â†’ convex_cone ğ•œ E) :\n    â†‘(infáµ¢ f) =\n      Â«exprâ‹‚ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹‚ , Â»\" (f i : set E) :=\n  by simp [infáµ¢]\n#align coe_infi coe_infi\n\n",
 "coe_inf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŠ“ Â» -/\n@[simp]\ntheorem coe_inf : ((Â«expr âŠ“ Â» S T : convex_cone ğ•œ E) : set E) = â†‘S âˆ© â†‘T :=\n  rfl\n#align coe_inf coe_inf\n\n",
 "coe_comap":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚—[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n@[simp]\ntheorem coe_comap (f : Â«expr â†’â‚—[ ] Â» E ğ•œ F) (S : convex_cone ğ•œ F) : (S.comap f : set E) = Â«expr â»Â¹' Â» f S :=\n  rfl\n#align coe_comap coe_comap\n\n",
 "coe_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¥Â» -/\n@[simp]\ntheorem coe_bot : â†‘(Â«exprâŠ¥Â» : convex_cone ğ•œ E) = (âˆ… : set E) :=\n  rfl\n#align coe_bot coe_bot\n\n",
 "coe_Inf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹‚ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹‚ , Â» -/\n@[simp]\ntheorem coe_Inf (S : set (convex_cone ğ•œ E)) :\n    â†‘(infâ‚› S) =\n      Â«exprâ‹‚ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹‚ , Â»\" (s : set E) :=\n  rfl\n#align coe_Inf coe_Inf\n\n",
 "blunt_strictly_positive":
 "/-- The strictly positive cone of an ordered module is always blunt. -/\ntheorem blunt_strictly_positive : blunt (strictly_positive ğ•œ E) :=\n  lt_irrefl 0\n#align blunt_strictly_positive blunt_strictly_positive\n\n",
 "blunt_iff_not_pointed":
 "theorem blunt_iff_not_pointed (S : convex_cone ğ•œ E) : S.blunt â†” Â¬S.pointed := by rw [pointed_iff_not_blunt, not_not]\n#align blunt_iff_not_pointed blunt_iff_not_pointed\n\n",
 "anti":
 "theorem salient.anti {S T : convex_cone ğ•œ E} (h : T â‰¤ S) : S.salient â†’ T.salient := fun hS x hxT hx hnT =>\n  hS x (h hxT) hx (h hnT)\n#align salient.anti salient.anti\n\n",
 "add_mem":
 "theorem add_mem â¦ƒxâ¦„ (hx : x âˆˆ S) â¦ƒyâ¦„ (hy : y âˆˆ S) : x + y âˆˆ S :=\n  S.add_mem' hx hy\n#align add_mem add_mem\n\n"}