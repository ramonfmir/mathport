{"to_ordered_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- Constructs an ordered module given an `ordered_add_comm_group`, a cone, and a proof that\nthe order relation is the one defined by the cone.\n-/\ntheorem to_ordered_smul (S : convex_cone 𝕜 E) (h : ∀ x y : E, x ≤ y ↔ y - x ∈ S) : ordered_smul 𝕜 E :=\n  ordered_smul.mk'\n    (by\n      intro x y z xy hz\n      rw [h («expr • » z x) («expr • » z y), ← smul_sub z y x]\n      exact smul_mem S hz ((h x y).mp xy.le))\n#align to_ordered_smul to_ordered_smul\n\n",
 "to_convex_cone_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem to_convex_cone_top : («expr⊤» : submodule 𝕜 E).to_convex_cone = «expr⊤» :=\n  rfl\n#align to_convex_cone_top to_convex_cone_top\n\n",
 "to_convex_cone_le_iff":
 "@[simp]\ntheorem to_convex_cone_le_iff {S T : submodule 𝕜 E} : S.to_convex_cone ≤ T.to_convex_cone ↔ S ≤ T :=\n  iff.rfl\n#align to_convex_cone_le_iff to_convex_cone_le_iff\n\n",
 "to_convex_cone_inf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n@[simp]\ntheorem to_convex_cone_inf (S T : submodule 𝕜 E) :\n    («expr ⊓ » S T).to_convex_cone = «expr ⊓ » S.to_convex_cone T.to_convex_cone :=\n  rfl\n#align to_convex_cone_inf to_convex_cone_inf\n\n",
 "to_convex_cone_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem to_convex_cone_bot : («expr⊥» : submodule 𝕜 E).to_convex_cone = 0 :=\n  rfl\n#align to_convex_cone_bot to_convex_cone_bot\n\n",
 "to_cone_is_least":
 "/-- `hs.to_cone s` is the least cone that includes `s`. -/\ntheorem to_cone_is_least : IsLeast { t : convex_cone 𝕜 E | s ⊆ t } (hs.to_cone s) :=\n  by\n  refine' ⟨hs.subset_to_cone, fun t ht x hx => _⟩\n  rcases hs.mem_to_cone.1 hx with ⟨c, hc, y, hy, rfl⟩\n  exact t.smul_mem hc (ht hy)\n#align to_cone_is_least to_cone_is_least\n\n",
 "to_cone_eq_Inf":
 "theorem to_cone_eq_Inf : hs.to_cone s = infₛ { t : convex_cone 𝕜 E | s ⊆ t } :=\n  hs.to_cone_is_least.is_glb.Inf_eq.symm\n#align to_cone_eq_Inf to_cone_eq_Inf\n\n",
 "subset_to_cone":
 "theorem subset_to_cone : s ⊆ hs.to_cone s := fun x hx => hs.mem_to_cone'.2 ⟨1, zero_lt_one, by rwa [one_smul]⟩\n#align subset_to_cone subset_to_cone\n\n",
 "step":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/-- Induction step in M. Riesz extension theorem. Given a convex cone `s` in a vector space `E`,\na partially defined linear map `f : f.domain → ℝ`, assume that `f` is nonnegative on `f.domain ∩ p`\nand `p + s = E`. If `f` is not defined on the whole `E`, then we can extend it to a larger\nsubmodule without breaking the non-negativity condition. -/\ntheorem step (nonneg : ∀ x : f.domain, (x : E) ∈ s → 0 ≤ f x) (dense : ∀ y, ∃ x : f.domain, (x : E) + y ∈ s)\n    (hdom : f.domain ≠ «expr⊤») : ∃ g, f < g ∧ ∀ x : g.domain, (x : E) ∈ s → 0 ≤ g x :=\n  by\n  obtain ⟨y, -, hy⟩ : ∃ (y : E)(h : y ∈ «expr⊤»), y ∉ f.domain :=\n    @SetLike.exists_of_lt (submodule (exprℝ) E) _ _ _ _ (lt_top_iff_ne_top.2 hdom)\n  obtain ⟨c, le_c, c_le⟩ :\n    ∃ c, (∀ x : f.domain, -(x : E) - y ∈ s → f x ≤ c) ∧ ∀ x : f.domain, (x : E) + y ∈ s → c ≤ f x :=\n    by\n    set Sp := «expr '' » f { x : f.domain | (x : E) + y ∈ s }\n    set Sn := «expr '' » f { x : f.domain | -(x : E) - y ∈ s }\n    suffices (upperBounds Sn ∩ lowerBounds Sp).nonempty by\n      simpa only [Set.Nonempty, upperBounds, lowerBounds, ball_image_iff] using this\n    refine' exists_between_of_forall_le (nonempty.image f _) (nonempty.image f (dense y)) _\n    · rcases dense (-y) with ⟨x, hx⟩\n      rw [← neg_neg x, add_subgroup_class.coe_neg, ← sub_eq_add_neg] at hx\n      exact ⟨_, hx⟩\n    rintro a ⟨xn, hxn, rfl⟩ b ⟨xp, hxp, rfl⟩\n    have := s.add_mem hxp hxn\n    rw [add_assoc, add_sub_cancel'_right, ← sub_eq_add_neg, ← add_subgroup_class.coe_sub] at this\n    replace := nonneg _ this\n    rwa [f.map_sub, sub_nonneg] at this\n  have hy' : y ≠ 0 := fun hy₀ => hy (hy₀.symm ▸ zero_mem _)\n  refine' ⟨f.sup_span_singleton y (-c) hy, _, _⟩\n  · refine' lt_iff_le_not_le.2 ⟨f.left_le_sup _ _, fun H => _⟩\n    replace H := linear_pmap.domain_mono.monotone H\n    rw [linear_pmap.domain_sup_span_singleton, sup_le_iff, span_le, singleton_subset_iff] at H\n    exact hy H.2\n  · rintro ⟨z, hz⟩ hzs\n    rcases mem_sup.1 hz with ⟨x, hx, y', hy', rfl⟩\n    rcases mem_span_singleton.1 hy' with ⟨r, rfl⟩\n    simp only [subtype.coe_mk] at hzs\n    erw [linear_pmap.sup_span_singleton_apply_mk _ _ _ _ _ hx, smul_neg, ← sub_eq_add_neg, sub_nonneg]\n    rcases lt_trichotomy r 0 with (hr | hr | hr)\n    · have : -«expr • » r⁻¹ x - y ∈ s := by\n        rwa [← s.smul_mem_iff (neg_pos.2 hr), smul_sub, smul_neg, neg_smul, neg_neg, smul_smul, mul_inv_cancel hr.ne,\n          one_smul, sub_eq_add_neg, neg_smul, neg_neg]\n      replace := le_c («expr • » r⁻¹ ⟨x, hx⟩) this\n      rwa [← mul_le_mul_left (neg_pos.2 hr), neg_mul, neg_mul, neg_le_neg_iff, f.map_smul, smul_eq_mul, ← mul_assoc,\n        mul_inv_cancel hr.ne, one_mul] at this\n    · subst r\n      simp only [zero_smul, add_zero] at hzs⊢\n      apply nonneg\n      exact hzs\n    · have : «expr • » r⁻¹ x + y ∈ s := by\n        rwa [← s.smul_mem_iff hr, smul_add, smul_smul, mul_inv_cancel hr.ne', one_smul]\n      replace := c_le («expr • » r⁻¹ ⟨x, hx⟩) this\n      rwa [← mul_le_mul_left hr, f.map_smul, smul_eq_mul, ← mul_assoc, mul_inv_cancel hr.ne', one_mul] at this\n#align step step\n\n",
 "smul_mem_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem smul_mem_iff {c : 𝕜} (hc : 0 < c) {x : E} : «expr • » c x ∈ S ↔ x ∈ S :=\n  ⟨fun h => inv_smul_smul₀ hc.ne' x ▸ S.smul_mem (inv_pos.2 hc) h, S.smul_mem hc⟩\n#align smul_mem_iff smul_mem_iff\n\n",
 "smul_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print smul_mem /-\ntheorem smul_mem {c : 𝕜} {x : E} (hc : 0 < c) (hx : x ∈ S) : «expr • » c x ∈ S :=\n  S.smul_mem' hc hx\n#align smul_mem smul_mem\n-/\n\n",
 "salient_strictly_positive":
 "/-- The strictly positive cone of an ordered module is always salient. -/\ntheorem salient_strictly_positive : salient (strictly_positive 𝕜 E) :=\n  (salient_positive 𝕜 E).anti <| positive_le_strictly_positive 𝕜 E\n#align salient_strictly_positive salient_strictly_positive\n\n",
 "salient_positive":
 "/-- The positive cone of an ordered module is always salient. -/\ntheorem salient_positive : salient (positive 𝕜 E) := fun x xs hx hx' =>\n  lt_irrefl (0 : E)\n    (calc\n      0 < x := lt_of_le_of_ne xs hx.symm\n      _ ≤ x + -x := le_add_of_nonneg_right hx'\n      _ = 0 := add_neg_self x\n      )\n#align salient_positive salient_positive\n\n",
 "salient_iff_not_flat":
 "theorem salient_iff_not_flat (S : convex_cone 𝕜 E) : S.salient ↔ ¬S.flat :=\n  by\n  constructor\n  · rintro h₁ ⟨x, xs, H₁, H₂⟩\n    exact h₁ x xs H₁ H₂\n  · intro h\n    unfold flat at h\n    push_neg  at h\n    exact h\n#align salient_iff_not_flat salient_iff_not_flat\n\n",
 "salient":
 "/-- A blunt cone (one not containing `0`) is always salient. -/\ntheorem blunt.salient {S : convex_cone 𝕜 E} : S.blunt → S.salient :=\n  by\n  rw [salient_iff_not_flat, blunt_iff_not_pointed]\n  exact mt flat.pointed\n#align blunt.salient blunt.salient\n\n",
 "riesz_extension":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∘ₗ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ.[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- M. **Riesz extension theorem**: given a convex cone `s` in a vector space `E`, a submodule `p`,\nand a linear `f : p → ℝ`, assume that `f` is nonnegative on `p ∩ s` and `p + s = E`. Then\nthere exists a globally defined linear function `g : E → ℝ` that agrees with `f` on `p`,\nand is nonnegative on `s`. -/\ntheorem riesz_extension (s : convex_cone (exprℝ) E) (f : «expr →ₗ.[ ] » E (exprℝ) (exprℝ))\n    (nonneg : ∀ x : f.domain, (x : E) ∈ s → 0 ≤ f x) (dense : ∀ y, ∃ x : f.domain, (x : E) + y ∈ s) :\n    ∃ g : «expr →ₗ[ ] » E (exprℝ) (exprℝ), (∀ x : f.domain, g x = f x) ∧ ∀ x ∈ s, 0 ≤ g x :=\n  by\n  rcases riesz_extension.exists_top s f nonneg dense with ⟨⟨g_dom, g⟩, ⟨hpg, hfg⟩, htop, hgs⟩\n  clear hpg\n  refine' ⟨«expr ∘ₗ » g ↑(linear_equiv.of_top _ htop).symm, _, _⟩ <;>\n    simp only [comp_apply, linear_equiv.coe_coe, linear_equiv.of_top_symm_apply]\n  · exact fun x => (hfg (submodule.coe_mk _ _).symm).symm\n  · exact fun x hx => hgs ⟨x, _⟩ hx\n#align riesz_extension riesz_extension\n\n",
 "positive_le_strictly_positive":
 "theorem positive_le_strictly_positive : strictly_positive 𝕜 E ≤ positive 𝕜 E := fun x => le_of_lt\n#align positive_le_strictly_positive positive_le_strictly_positive\n\n",
 "pointed_zero":
 "theorem pointed_zero : (0 : convex_cone 𝕜 E).pointed := by rw [pointed, mem_zero]\n#align pointed_zero pointed_zero\n\n",
 "pointed_to_convex_cone":
 "@[simp]\ntheorem pointed_to_convex_cone (S : submodule 𝕜 E) : S.to_convex_cone.pointed :=\n  S.zero_mem\n#align pointed_to_convex_cone pointed_to_convex_cone\n\n",
 "pointed_positive":
 "/-- The positive cone of an ordered module is always pointed. -/\ntheorem pointed_positive : pointed (positive 𝕜 E) :=\n  le_refl 0\n#align pointed_positive pointed_positive\n\n",
 "pointed_of_nonempty_of_is_closed":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:219:4: warning: unsupported binary notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem convex_cone.pointed_of_nonempty_of_is_closed (K : convex_cone (exprℝ) H) (ne : (K : set H).nonempty)\n    (hc : is_closed (K : set H)) : K.pointed := by\n  obtain ⟨x, hx⟩ := ne\n  let f : exprℝ → H := («expr • » · x)\n  -- f (0, ∞) is a subset of K\n  have fI : «expr '' » f (Set.Ioi 0) ⊆ (K : set H) :=\n    by\n    rintro _ ⟨_, h, rfl⟩\n    exact K.smul_mem (Set.mem_Ioi.1 h) hx\n  -- closure of f (0, ∞) is a subset of K\n  have clf : closure («expr '' » f (Set.Ioi 0)) ⊆ (K : set H) := hc.closure_subset_iff.2 fI\n  -- f is continuous at 0 from the right\n  have fc : continuous_within_at f (Set.Ioi (0 : exprℝ)) 0 := (continuous_id.smul continuous_const).continuous_within_at\n  -- 0 belongs to the closure of the f (0, ∞)\n  have mem₀ := fc.mem_closure_image (by rw [closure_Ioi (0 : exprℝ), mem_Ici])\n  -- as 0 ∈ closure f (0, ∞) and closure f (0, ∞) ⊆ K, 0 ∈ K.\n  have f₀ : f 0 = 0 := zero_smul (exprℝ) x\n  simpa only [f₀, convex_cone.pointed, ← SetLike.mem_coe] using mem_of_subset_of_mem clf mem₀\n#align convex_cone.pointed_of_nonempty_of_is_closed convex_cone.pointed_of_nonempty_of_is_closed\n\n",
 "pointed_inner_dual_cone":
 "theorem pointed_inner_dual_cone : s.inner_dual_cone.pointed := fun x hx => by rw [inner_zero_right]\n#align pointed_inner_dual_cone pointed_inner_dual_cone\n\n",
 "pointed_iff_not_blunt":
 "theorem pointed_iff_not_blunt (S : convex_cone 𝕜 E) : S.pointed ↔ ¬S.blunt :=\n  ⟨fun h₁ h₂ => h₂ h₁, not_not.mp⟩\n#align pointed_iff_not_blunt pointed_iff_not_blunt\n\n",
 "pointed":
 "/-- A flat cone is always pointed (contains `0`). -/\ntheorem flat.pointed {S : convex_cone 𝕜 E} (hS : S.flat) : S.pointed :=\n  by\n  obtain ⟨x, hx, _, hxneg⟩ := hS\n  rw [pointed, ← add_neg_self x]\n  exact add_mem S hx hxneg\n#align flat.pointed flat.pointed\n\n",
 "mono":
 "theorem flat.mono {S T : convex_cone 𝕜 E} (h : S ≤ T) : S.flat → T.flat\n  | ⟨x, hxS, hx, hnxS⟩ => ⟨x, h hxS, hx, h hnxS⟩\n#align flat.mono flat.mono\n\n",
 "mem_zero":
 "@[simp]\ntheorem mem_zero (x : E) : x ∈ (0 : convex_cone 𝕜 E) ↔ x = 0 :=\n  iff.rfl\n#align mem_zero mem_zero\n\n",
 "mem_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem mem_top (x : E) : x ∈ («expr⊤» : convex_cone 𝕜 E) :=\n  mem_univ x\n#align mem_top mem_top\n\n",
 "mem_to_convex_cone":
 "@[simp]\ntheorem mem_to_convex_cone {x : E} {S : submodule 𝕜 E} : x ∈ S.to_convex_cone ↔ x ∈ S :=\n  iff.rfl\n#align mem_to_convex_cone mem_to_convex_cone\n\n",
 "mem_to_cone'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem mem_to_cone' : x ∈ hs.to_cone s ↔ ∃ c : 𝕜, 0 < c ∧ «expr • » c x ∈ s :=\n  by\n  refine' hs.mem_to_cone.trans ⟨_, _⟩\n  · rintro ⟨c, hc, y, hy, rfl⟩\n    exact ⟨c⁻¹, inv_pos.2 hc, by rwa [smul_smul, inv_mul_cancel hc.ne', one_smul]⟩\n  · rintro ⟨c, hc, hcx⟩\n    exact ⟨c⁻¹, inv_pos.2 hc, _, hcx, by rw [smul_smul, inv_mul_cancel hc.ne', one_smul]⟩\n#align mem_to_cone' mem_to_cone'\n\n",
 "mem_to_cone":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem mem_to_cone : x ∈ hs.to_cone s ↔ ∃ c : 𝕜, 0 < c ∧ ∃ y ∈ s, «expr • » c y = x := by\n  simp only [to_cone, convex_cone.mem_mk, mem_Union, mem_smul_set, eq_comm, exists_prop]\n#align mem_to_cone mem_to_cone\n\n",
 "mem_strictly_positive":
 "@[simp]\ntheorem mem_strictly_positive {x : E} : x ∈ strictly_positive 𝕜 E ↔ 0 < x :=\n  iff.rfl\n#align mem_strictly_positive mem_strictly_positive\n\n",
 "mem_positive":
 "@[simp]\ntheorem mem_positive {x : E} : x ∈ positive 𝕜 E ↔ 0 ≤ x :=\n  iff.rfl\n#align mem_positive mem_positive\n\n",
 "mem_mk":
 "@[simp]\ntheorem mem_mk {s : set E} {h₁ h₂ x} : x ∈ @mk 𝕜 _ _ _ _ s h₁ h₂ ↔ x ∈ s :=\n  iff.rfl\n#align mem_mk mem_mk\n\n",
 "mem_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n@[simp]\ntheorem mem_map {f : «expr →ₗ[ ] » E 𝕜 F} {S : convex_cone 𝕜 E} {y : F} : y ∈ S.map f ↔ ∃ x ∈ S, f x = y :=\n  mem_image_iff_bex\n#align mem_map mem_map\n\n",
 "mem_inner_dual_cone":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `inner.real -/\n@[simp]\ntheorem mem_inner_dual_cone (y : H) (s : set H) : y ∈ s.inner_dual_cone ↔ ∀ x ∈ s, 0 ≤ inner.real x y :=\n  iff.rfl\n#align mem_inner_dual_cone mem_inner_dual_cone\n\n",
 "mem_infi":
 "theorem mem_infi {ι : Sort _} {x : E} {f : ι → convex_cone 𝕜 E} : x ∈ infᵢ f ↔ ∀ i, x ∈ f i :=\n  mem_interᵢ₂.trans <| by simp\n#align mem_infi mem_infi\n\n",
 "mem_inf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\ntheorem mem_inf {x} : x ∈ «expr ⊓ » S T ↔ x ∈ S ∧ x ∈ T :=\n  iff.rfl\n#align mem_inf mem_inf\n\n",
 "mem_comap":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n@[simp]\ntheorem mem_comap {f : «expr →ₗ[ ] » E 𝕜 F} {S : convex_cone 𝕜 F} {x : E} : x ∈ S.comap f ↔ f x ∈ S :=\n  iff.rfl\n#align mem_comap mem_comap\n\n",
 "mem_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem mem_bot (x : E) : (x ∈ («expr⊥» : convex_cone 𝕜 E)) = false :=\n  rfl\n#align mem_bot mem_bot\n\n",
 "mem_add":
 "@[simp]\ntheorem mem_add {K₁ K₂ : convex_cone 𝕜 E} {a : E} : a ∈ K₁ + K₂ ↔ ∃ x y : E, x ∈ K₁ ∧ y ∈ K₂ ∧ x + y = a :=\n  iff.rfl\n#align mem_add mem_add\n\n",
 "mem_Inf":
 "theorem mem_Inf {x : E} {S : set (convex_cone 𝕜 E)} : x ∈ infₛ S ↔ ∀ s ∈ S, x ∈ s :=\n  mem_Inter₂\n#align mem_Inf mem_Inf\n\n",
 "map_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\ntheorem map_map (g : «expr →ₗ[ ] » F 𝕜 G) (f : «expr →ₗ[ ] » E 𝕜 F) (S : convex_cone 𝕜 E) :\n    (S.map f).map g = S.map (g.comp f) :=\n  SetLike.coe_injective <| image_image g f S\n#align map_map map_map\n\n",
 "map_id":
 "@[simp]\ntheorem map_id (S : convex_cone 𝕜 E) : S.map linear_map.id = S :=\n  SetLike.coe_injective <| image_id _\n#align map_id map_id\n\n",
 "is_closed_inner_dual_cone":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem is_closed_inner_dual_cone : is_closed (s.inner_dual_cone : set H) :=\n  by\n  -- reduce the problem to showing that dual cone of a singleton `{x}` is closed\n  rw [inner_dual_cone_eq_Inter_inner_dual_cone_singleton]\n  apply is_closed_Inter\n  intro x\n  -- the dual cone of a singleton `{x}` is the preimage of `[0, ∞)` under `inner x`\n  have h : ↑({x} : set H).inner_dual_cone = «expr ⁻¹' » (inner x : H → exprℝ) (Set.Ici 0) := by\n    rw [inner_dual_cone_singleton, convex_cone.coe_comap, convex_cone.coe_positive, innerₛₗ_apply_coe]\n  -- the preimage is closed as `inner x` is continuous and `[0, ∞)` is closed\n  rw [h]\n  exact is_closed_Ici.preimage (by continuity)\n#align is_closed_inner_dual_cone is_closed_inner_dual_cone\n\n",
 "inner_dual_cone_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/-- Dual cone of the convex cone {0} is the total space. -/\n@[simp]\ntheorem inner_dual_cone_zero : (0 : set H).inner_dual_cone = «expr⊤» :=\n  eq_top_iff.mpr fun x hy y (hy : y = 0) => hy.symm ▸ inner_zero_left.ge\n#align inner_dual_cone_zero inner_dual_cone_zero\n\n",
 "inner_dual_cone_univ":
 "/-- Dual cone of the total space is the convex cone {0}. -/\n@[simp]\ntheorem inner_dual_cone_univ : (univ : set H).inner_dual_cone = 0 :=\n  by\n  suffices ∀ x : H, x ∈ (univ : set H).inner_dual_cone → x = 0\n    by\n    apply SetLike.coe_injective\n    exact eq_singleton_iff_unique_mem.mpr ⟨fun x hx => inner_zero_right.ge, this⟩\n  exact fun x hx => by simpa [← real_inner_self_nonpos] using hx (-x) (mem_univ _)\n#align inner_dual_cone_univ inner_dual_cone_univ\n\n",
 "inner_dual_cone_union":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\ntheorem inner_dual_cone_union (s t : set H) : (s ∪ t).inner_dual_cone = «expr ⊓ » s.inner_dual_cone t.inner_dual_cone :=\n  le_antisymm (le_inf (fun x hx y hy => hx _ <| or.inl hy) fun x hx y hy => hx _ <| or.inr hy) fun x hx y =>\n    or.rec (hx.1 _) (hx.2 _)\n#align inner_dual_cone_union inner_dual_cone_union\n\n",
 "inner_dual_cone_singleton":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- The inner dual cone of a singleton is given by the preimage of the positive cone under the\nlinear map `λ y, ⟪x, y⟫`. -/\ntheorem inner_dual_cone_singleton (x : H) :\n    ({x} : set H).inner_dual_cone = (convex_cone.positive (exprℝ) (exprℝ)).comap (innerₛₗ x) :=\n  convex_cone.ext fun i => forall_eq\n#align inner_dual_cone_singleton inner_dual_cone_singleton\n\n",
 "inner_dual_cone_sUnion":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem inner_dual_cone_sUnion (S : set (set H)) : (⋃₀ S).inner_dual_cone = infₛ («expr '' » set.inner_dual_cone S) :=\n  by simp_rw [infₛ_image, sUnion_eq_bUnion, inner_dual_cone_Union]\n#align inner_dual_cone_sUnion inner_dual_cone_sUnion\n\n",
 "inner_dual_cone_of_inner_dual_cone_eq_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- The inner dual of inner dual of a non-empty, closed convex cone is itself.  -/\ntheorem convex_cone.inner_dual_cone_of_inner_dual_cone_eq_self (K : convex_cone (exprℝ) H) (ne : (K : set H).nonempty)\n    (hc : is_closed (K : set H)) : ((K : set H).inner_dual_cone : set H).inner_dual_cone = K :=\n  by\n  ext x\n  constructor\n  · rw [mem_inner_dual_cone, ← SetLike.mem_coe]\n    contrapose!\n    exact K.hyperplane_separation_of_nonempty_of_is_closed_of_nmem ne hc\n  · rintro hxK y h\n    specialize h x hxK\n    rwa [real_inner_comm]\n#align convex_cone.inner_dual_cone_of_inner_dual_cone_eq_self convex_cone.inner_dual_cone_of_inner_dual_cone_eq_self\n\n",
 "inner_dual_cone_le_inner_dual_cone":
 "theorem inner_dual_cone_le_inner_dual_cone (h : t ⊆ s) : s.inner_dual_cone ≤ t.inner_dual_cone := fun y hy x hx =>\n  hy x (h hx)\n#align inner_dual_cone_le_inner_dual_cone inner_dual_cone_le_inner_dual_cone\n\n",
 "inner_dual_cone_insert":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\ntheorem inner_dual_cone_insert (x : H) (s : set H) :\n    (insert x s).inner_dual_cone = «expr ⊓ » (set.inner_dual_cone {x}) s.inner_dual_cone := by\n  rw [insert_eq, inner_dual_cone_union]\n#align inner_dual_cone_insert inner_dual_cone_insert\n\n",
 "inner_dual_cone_eq_Inter_inner_dual_cone_singleton":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/-- The dual cone of `s` equals the intersection of dual cones of the points in `s`. -/\ntheorem inner_dual_cone_eq_Inter_inner_dual_cone_singleton :\n    (s.inner_dual_cone : set H) =\n      «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\"\n        (({i} : set H).inner_dual_cone : set H) :=\n  by rw [← convex_cone.coe_infi, ← inner_dual_cone_Union, Union_of_singleton_coe]\n#align inner_dual_cone_eq_Inter_inner_dual_cone_singleton inner_dual_cone_eq_Inter_inner_dual_cone_singleton\n\n",
 "inner_dual_cone_empty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem inner_dual_cone_empty : (∅ : set H).inner_dual_cone = «expr⊤» :=\n  eq_top_iff.mpr fun x hy y => false.elim\n#align inner_dual_cone_empty inner_dual_cone_empty\n\n",
 "inner_dual_cone_Union":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\ntheorem inner_dual_cone_Union {ι : Sort _} (f : ι → set H) :\n    («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n          (f i)).inner_dual_cone =\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n        (f i).inner_dual_cone :=\n  by\n  refine' le_antisymm (le_infᵢ fun i x hx y hy => hx _ <| mem_Union_of_mem _ hy) _\n  intro x hx y hy\n  rw [convex_cone.mem_infi] at hx\n  obtain ⟨j, hj⟩ := mem_Union.mp hy\n  exact hx _ _ hj\n#align inner_dual_cone_Union inner_dual_cone_Union\n\n",
 "hyperplane_separation_of_nonempty_of_is_closed_of_nmem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟪ , ⟫_ℝ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟪ , ⟫_ℝ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟪ , ⟫_ℝ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟪ , ⟫_ℝ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟪ , ⟫_ℝ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟪ , ⟫_ℝ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟪ , ⟫_ℝ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟪ , ⟫_ℝ» -/\n/-- This is a stronger version of the Hahn-Banach separation theorem for closed convex cones. This\nis also the geometric interpretation of Farkas' lemma. -/\ntheorem convex_cone.hyperplane_separation_of_nonempty_of_is_closed_of_nmem (K : convex_cone (exprℝ) H)\n    (ne : (K : set H).nonempty) (hc : is_closed (K : set H)) {b : H} (disj : b ∉ K) :\n    ∃ y : H, (∀ x : H, x ∈ K → 0 ≤ «expr⟪ , ⟫_ℝ» x y) ∧ «expr⟪ , ⟫_ℝ» y b < 0 :=\n  by\n  -- let `z` be the point in `K` closest to `b`\n  obtain ⟨z, hzK, infi⟩ := exists_norm_eq_infi_of_complete_convex ne hc.is_complete K.convex b\n  -- for any `w` in `K`, we have `⟪b - z, w - z⟫_ℝ ≤ 0`\n  have hinner := (norm_eq_infi_iff_real_inner_le_zero K.convex hzK).1 infᵢ\n  -- set `y := z - b`\n  use z - b\n  constructor\n  · -- the rest of the proof is a straightforward calculation\n    rintro x hxK\n    specialize hinner _ (K.add_mem hxK hzK)\n    rwa [add_sub_cancel, real_inner_comm, ← neg_nonneg, neg_eq_neg_one_mul, ← real_inner_smul_right, neg_smul, one_smul,\n      neg_sub] at hinner\n  · -- as `K` is closed and non-empty, it is pointed\n    have hinner₀ := hinner 0 (K.pointed_of_nonempty_of_is_closed ne hc)\n    -- the rest of the proof is a straightforward calculation\n    rw [zero_sub, inner_neg_right, right.neg_nonpos_iff] at hinner₀\n    have hbz : b - z ≠ 0 := by\n      rw [sub_ne_zero]\n      contrapose! hzK\n      rwa [← hzK]\n    rw [← neg_zero, lt_neg, ← neg_one_mul, ← real_inner_smul_left, smul_sub, neg_smul, one_smul, neg_smul, neg_sub_neg,\n      one_smul]\n    calc\n      0 < «expr⟪ , ⟫_ℝ» (b - z) (b - z) := lt_of_not_le ((iff.not real_inner_self_nonpos).2 hbz)\n      _ = «expr⟪ , ⟫_ℝ» (b - z) (b - z) + 0 := (add_zero _).symm\n      _ ≤ «expr⟪ , ⟫_ℝ» (b - z) (b - z) + «expr⟪ , ⟫_ℝ» (b - z) z := add_le_add rfl.ge hinner₀\n      _ = «expr⟪ , ⟫_ℝ» (b - z) (b - z + z) := inner_add_right.symm\n      _ = «expr⟪ , ⟫_ℝ» (b - z) b := by rw [sub_add_cancel]\n      \n#align\n  convex_cone.hyperplane_separation_of_nonempty_of_is_closed_of_nmem convex_cone.hyperplane_separation_of_nonempty_of_is_closed_of_nmem\n\n",
 "ext":
 "/-- Two `convex_cone`s are equal if they have the same elements. -/\n@[ext]\ntheorem ext {S T : convex_cone 𝕜 E} (h : ∀ x, x ∈ S ↔ x ∈ T) : S = T :=\n  SetLike.ext h\n#align ext ext\n\n",
 "exists_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ.[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem exists_top (p : «expr →ₗ.[ ] » E (exprℝ) (exprℝ)) (hp_nonneg : ∀ x : p.domain, (x : E) ∈ s → 0 ≤ p x)\n    (hp_dense : ∀ y, ∃ x : p.domain, (x : E) + y ∈ s) :\n    ∃ q ≥ p, q.domain = «expr⊤» ∧ ∀ x : q.domain, (x : E) ∈ s → 0 ≤ q x :=\n  by\n  replace hp_nonneg : p ∈ { p | _ };\n  · rw [mem_set_of_eq]\n    exact hp_nonneg\n  obtain ⟨q, hqs, hpq, hq⟩ := zorn_nonempty_partialOrder₀ _ _ _ hp_nonneg\n  · refine' ⟨q, hpq, _, hqs⟩\n    contrapose! hq\n    rcases step s q hqs _ hq with ⟨r, hqr, hr⟩\n    · exact ⟨r, hr, hqr.le, hqr.ne'⟩\n    ·\n      exact fun y =>\n        let ⟨x, hx⟩ := hp_dense y\n        ⟨of_le hpq.left x, hx⟩\n  · intro c hcs c_chain y hy\n    clear hp_nonneg hp_dense p\n    have cne : c.nonempty := ⟨y, hy⟩\n    refine' ⟨linear_pmap.Sup c c_chain.directed_on, _, fun _ => linear_pmap.le_Sup c_chain.directed_on⟩\n    rintro ⟨x, hx⟩ hxs\n    have hdir : DirectedOn (· ≤ ·) («expr '' » linear_pmap.domain c) :=\n      directedOn_image.2 (c_chain.directed_on.mono linear_pmap.domain_mono.monotone)\n    rcases(mem_Sup_of_directed (cne.image _) hdir).1 hx with ⟨_, ⟨f, hfc, rfl⟩, hfx⟩\n    have : f ≤ linear_pmap.Sup c c_chain.directed_on := linear_pmap.le_Sup _ hfc\n    convert ← hcs hfc ⟨x, hfx⟩ hxs\n    apply this.2\n    rfl\n#align exists_top exists_top\n\n",
 "exists_extension_of_le_sublinear":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ.[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- **Hahn-Banach theorem**: if `N : E → ℝ` is a sublinear map, `f` is a linear map\ndefined on a subspace of `E`, and `f x ≤ N x` for all `x` in the domain of `f`,\nthen `f` can be extended to the whole space to a linear map `g` such that `g x ≤ N x`\nfor all `x`. -/\ntheorem exists_extension_of_le_sublinear (f : «expr →ₗ.[ ] » E (exprℝ) (exprℝ)) (N : E → exprℝ)\n    (N_hom : ∀ c : exprℝ, 0 < c → ∀ x, N («expr • » c x) = c * N x) (N_add : ∀ x y, N (x + y) ≤ N x + N y)\n    (hf : ∀ x : f.domain, f x ≤ N x) :\n    ∃ g : «expr →ₗ[ ] » E (exprℝ) (exprℝ), (∀ x : f.domain, g x = f x) ∧ ∀ x, g x ≤ N x :=\n  by\n  let s : convex_cone (exprℝ) (E × exprℝ) :=\n    { carrier := { p : E × exprℝ | N p.1 ≤ p.2 }\n      smul_mem' := fun c hc p hp =>\n        calc\n          N («expr • » c p.1) = c * N p.1 := N_hom c hc p.1\n          _ ≤ c * p.2 := mul_le_mul_of_nonneg_left hp hc.le\n          \n      add_mem' := fun x hx y hy => (N_add _ _).trans (add_le_add hx hy) }\n  obtain ⟨g, g_eq, g_nonneg⟩ := riesz_extension s ((-f).coprod (linear_map.id.to_pmap («expr⊤»))) _ _ <;>\n    try\n      simp only [linear_pmap.coprod_apply, to_pmap_apply, id_apply, linear_pmap.neg_apply, ← sub_eq_neg_add, sub_nonneg,\n        subtype.coe_mk] at *\n  replace g_eq : ∀ (x : f.domain) (y : exprℝ), g (x, y) = y - f x\n  · intro x y\n    simpa only [subtype.coe_mk, subtype.coe_eta] using g_eq ⟨(x, y), ⟨x.2, trivial⟩⟩\n  · refine' ⟨-g.comp (inl (exprℝ) E (exprℝ)), _, _⟩ <;> simp only [neg_apply, inl_apply, comp_apply]\n    · intro x\n      simp [g_eq x 0]\n    · intro x\n      have A : (x, N x) = (x, 0) + (0, N x) := by simp\n      have B := g_nonneg ⟨x, N x⟩ (le_refl (N x))\n      rw [A, map_add, ← neg_le_iff_add_nonneg'] at B\n      have C := g_eq 0 (N x)\n      simp only [submodule.coe_zero, f.map_zero, sub_zero] at C\n      rwa [← C]\n  · exact fun x hx => le_trans (hf _) hx\n  · rintro ⟨x, y⟩\n    refine' ⟨⟨(0, N x - y), ⟨f.domain.zero_mem, trivial⟩⟩, _⟩\n    simp only [convex_cone.mem_mk, mem_set_of_eq, subtype.coe_mk, Prod.fst_add, Prod.snd_add, zero_add, sub_add_cancel]\n#align exists_extension_of_le_sublinear exists_extension_of_le_sublinear\n\n",
 "convex_hull_to_cone_is_least":
 "theorem convex_hull_to_cone_is_least (s : set E) :\n    IsLeast { t : convex_cone 𝕜 E | s ⊆ t } ((convex_convex_hull 𝕜 s).to_cone _) :=\n  by\n  convert (convex_convex_hull 𝕜 s).to_cone_is_least\n  ext t\n  exact ⟨fun h => convex_hull_min h t.convex, (subset_convex_hull 𝕜 s).trans⟩\n#align convex_hull_to_cone_is_least convex_hull_to_cone_is_least\n\n",
 "convex_hull_to_cone_eq_Inf":
 "theorem convex_hull_to_cone_eq_Inf (s : set E) :\n    (convex_convex_hull 𝕜 s).to_cone _ = infₛ { t : convex_cone 𝕜 E | s ⊆ t } :=\n  eq.symm <| IsGLB.infₛ_eq <| IsLeast.isGLB <| convex_hull_to_cone_is_least s\n#align convex_hull_to_cone_eq_Inf convex_hull_to_cone_eq_Inf\n\n",
 "convex":
 "protected theorem convex : convex 𝕜 (S : set E) :=\n  convex_iff_forall_pos.2 fun x hx y hy a b ha hb _ => S.add_mem (S.smul_mem ha hx) (S.smul_mem hb hy)\n#align convex convex\n\n",
 "comap_id":
 "@[simp]\ntheorem comap_id (S : convex_cone 𝕜 E) : S.comap linear_map.id = S :=\n  SetLike.coe_injective preimage_id\n#align comap_id comap_id\n\n",
 "comap_comap":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\ntheorem comap_comap (g : «expr →ₗ[ ] » F 𝕜 G) (f : «expr →ₗ[ ] » E 𝕜 F) (S : convex_cone 𝕜 G) :\n    (S.comap g).comap f = S.comap (g.comp f) :=\n  SetLike.coe_injective <| preimage_comp.symm\n#align comap_comap comap_comap\n\n",
 "coe_zero":
 "@[simp]\ntheorem coe_zero : ((0 : convex_cone 𝕜 E) : set E) = 0 :=\n  rfl\n#align coe_zero coe_zero\n\n",
 "coe_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem coe_top : ↑(«expr⊤» : convex_cone 𝕜 E) = (univ : set E) :=\n  rfl\n#align coe_top coe_top\n\n",
 "coe_to_convex_cone":
 "@[simp]\ntheorem coe_to_convex_cone (S : submodule 𝕜 E) : ↑S.to_convex_cone = (S : set E) :=\n  rfl\n#align coe_to_convex_cone coe_to_convex_cone\n\n",
 "coe_strictly_positive":
 "@[simp]\ntheorem coe_strictly_positive : ↑(strictly_positive 𝕜 E) = Set.Ioi (0 : E) :=\n  rfl\n#align coe_strictly_positive coe_strictly_positive\n\n",
 "coe_positive":
 "@[simp]\ntheorem coe_positive : ↑(positive 𝕜 E) = Set.Ici (0 : E) :=\n  rfl\n#align coe_positive coe_positive\n\n",
 "coe_mk":
 "/-\nCopyright (c) 2020 Yury Kudryashov All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov, Frédéric Dupuis\n-/\n@[simp]\ntheorem coe_mk {s : set E} {h₁ h₂} : ↑(@mk 𝕜 _ _ _ _ s h₁ h₂) = s :=\n  rfl\n#align coe_mk coe_mk\n\n",
 "coe_infi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n@[simp]\ntheorem coe_infi {ι : Sort _} (f : ι → convex_cone 𝕜 E) :\n    ↑(infᵢ f) =\n      «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (f i : set E) :=\n  by simp [infᵢ]\n#align coe_infi coe_infi\n\n",
 "coe_inf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n@[simp]\ntheorem coe_inf : ((«expr ⊓ » S T : convex_cone 𝕜 E) : set E) = ↑S ∩ ↑T :=\n  rfl\n#align coe_inf coe_inf\n\n",
 "coe_comap":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n@[simp]\ntheorem coe_comap (f : «expr →ₗ[ ] » E 𝕜 F) (S : convex_cone 𝕜 F) : (S.comap f : set E) = «expr ⁻¹' » f S :=\n  rfl\n#align coe_comap coe_comap\n\n",
 "coe_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem coe_bot : ↑(«expr⊥» : convex_cone 𝕜 E) = (∅ : set E) :=\n  rfl\n#align coe_bot coe_bot\n\n",
 "coe_Inf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n@[simp]\ntheorem coe_Inf (S : set (convex_cone 𝕜 E)) :\n    ↑(infₛ S) =\n      «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (s : set E) :=\n  rfl\n#align coe_Inf coe_Inf\n\n",
 "blunt_strictly_positive":
 "/-- The strictly positive cone of an ordered module is always blunt. -/\ntheorem blunt_strictly_positive : blunt (strictly_positive 𝕜 E) :=\n  lt_irrefl 0\n#align blunt_strictly_positive blunt_strictly_positive\n\n",
 "blunt_iff_not_pointed":
 "theorem blunt_iff_not_pointed (S : convex_cone 𝕜 E) : S.blunt ↔ ¬S.pointed := by rw [pointed_iff_not_blunt, not_not]\n#align blunt_iff_not_pointed blunt_iff_not_pointed\n\n",
 "anti":
 "theorem salient.anti {S T : convex_cone 𝕜 E} (h : T ≤ S) : S.salient → T.salient := fun hS x hxT hx hnT =>\n  hS x (h hxT) hx (h hnT)\n#align salient.anti salient.anti\n\n",
 "add_mem":
 "theorem add_mem ⦃x⦄ (hx : x ∈ S) ⦃y⦄ (hy : y ∈ S) : x + y ∈ S :=\n  S.add_mem' hx hy\n#align add_mem add_mem\n\n"}