{"subset_interior_image_homothety_of_one_lt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n#print Convex.subset_interior_image_homothety_of_one_lt /-\n/-- If we dilate a convex set about a point in its interior by a scale `t > 1`, the interior of\nthe result includes the closure of the original set.\n\nTODO Generalise this from convex sets to sets that are balanced / star-shaped about `x`. -/\ntheorem Convex.subset_interior_image_homothety_of_one_lt {s : Set E} (hs : Convex (exprℝ) s) {x : E}\n    (hx : x ∈ interior s) (t : exprℝ) (ht : 1 < t) : s ⊆ interior («expr '' » (homothety x t) s) :=\n  subset_closure.trans <| hs.closure_subset_interior_image_homothety_of_one_lt hx t ht\n#align convex.subset_interior_image_homothety_of_one_lt Convex.subset_interior_image_homothety_of_one_lt\n-/\n\n",
 "strictConvex'":
 "#print Convex.strictConvex' /-\n/-- A convex set `s` is strictly convex provided that for any two distinct points of\n`s \\ interior s`, the line passing through these points has nonempty intersection with\n`interior s`. -/\nprotected theorem Convex.strictConvex' {s : Set E} (hs : Convex 𝕜 s)\n    (h : (s \\ interior s).pairwise fun x y => ∃ c : 𝕜, lineMap x y c ∈ interior s) : StrictConvex 𝕜 s :=\n  by\n  refine' strictConvex_iff_openSegment_subset.2 _\n  intro x hx y hy hne\n  by_cases hx' : x ∈ interior s; · exact hs.open_segment_interior_self_subset_interior hx' hy\n  by_cases hy' : y ∈ interior s; · exact hs.open_segment_self_interior_subset_interior hx hy'\n  rcases h ⟨hx, hx'⟩ ⟨hy, hy'⟩ hne with ⟨c, hc⟩\n  refine' (openSegment_subset_union x y ⟨c, rfl⟩).trans (insert_subset.2 ⟨hc, union_subset _ _⟩)\n  exacts[hs.open_segment_self_interior_subset_interior hx hc, hs.open_segment_interior_self_subset_interior hc hy]\n#align convex.strict_convex' Convex.strictConvex'\n-/\n\n",
 "strictConvex":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `segment -/\n#print Convex.strictConvex /-\n/-- A convex set `s` is strictly convex provided that for any two distinct points `x`, `y` of\n`s \\ interior s`, the segment with endpoints `x`, `y` has nonempty intersection with\n`interior s`. -/\nprotected theorem Convex.strictConvex {s : Set E} (hs : Convex 𝕜 s)\n    (h : (s \\ interior s).pairwise fun x y => (segment x 𝕜 y \\ frontier s).nonempty) : StrictConvex 𝕜 s :=\n  by\n  refine' hs.strict_convex' <| h.imp_on fun x hx y hy hne => _\n  simp only [segment_eq_image_lineMap, ← self_diff_frontier]\n  rintro ⟨_, ⟨⟨c, hc, rfl⟩, hcs⟩⟩\n  refine' ⟨c, hs.segment_subset hx.1 hy.1 _, hcs⟩\n  exact (segment_eq_image_lineMap 𝕜 x y).symm ▸ mem_image_of_mem _ hc\n#align convex.strict_convex Convex.strictConvex\n-/\n\n",
 "stdSimplex_subset_closedBall":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n#print stdSimplex_subset_closedBall /-\n/-- Every vector in `std_simplex 𝕜 ι` has `max`-norm at most `1`. -/\ntheorem stdSimplex_subset_closedBall : stdSimplex (exprℝ) ι ⊆ Metric.closedBall 0 1 :=\n  by\n  intro f hf\n  rw [Metric.mem_closedBall, dist_pi_le_iff zero_le_one]\n  intro x\n  rw [Pi.zero_apply, Real.dist_0_eq_abs, abs_of_nonneg <| hf.1 x]\n  exact (mem_Icc_of_mem_stdSimplex hf x).2\n#align std_simplex_subset_closed_ball stdSimplex_subset_closedBall\n-/\n\n",
 "segment_subset_closure_openSegment":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `segment -/\n#print segment_subset_closure_openSegment /-\ntheorem segment_subset_closure_openSegment : segment x 𝕜 y ⊆ closure (openSegment 𝕜 x y) :=\n  by\n  rw [segment_eq_image, openSegment_eq_image, ← closure_Ioo (zero_ne_one' 𝕜)]\n  exact image_closure_subset_closure_image (by continuity)\n#align segment_subset_closure_open_segment segment_subset_closure_openSegment\n-/\n\n",
 "pathConnectedSpace":
 "#print TopologicalAddGroup.pathConnectedSpace /-\n/-- Every topological vector space over ℝ is path connected.\n\nNot an instance, because it creates enormous TC subproblems (turn on `pp.all`).\n-/\nprotected theorem TopologicalAddGroup.pathConnectedSpace : PathConnectedSpace E :=\n  pathConnectedSpace_iff_univ.mpr <| convex_univ.is_path_connected ⟨(0 : E), trivial⟩\n#align topological_add_group.path_connected TopologicalAddGroup.pathConnectedSpace\n-/\n\n",
 "openSegment_self_interior_subset_interior":
 "#print Convex.openSegment_self_interior_subset_interior /-\ntheorem Convex.openSegment_self_interior_subset_interior {s : Set E} (hs : Convex 𝕜 s) {x y : E} (hx : x ∈ s)\n    (hy : y ∈ interior s) : openSegment 𝕜 x y ⊆ interior s :=\n  hs.open_segment_closure_interior_subset_interior (subset_closure hx) hy\n#align convex.open_segment_self_interior_subset_interior Convex.openSegment_self_interior_subset_interior\n-/\n\n",
 "openSegment_interior_self_subset_interior":
 "#print Convex.openSegment_interior_self_subset_interior /-\ntheorem Convex.openSegment_interior_self_subset_interior {s : Set E} (hs : Convex 𝕜 s) {x y : E} (hx : x ∈ interior s)\n    (hy : y ∈ s) : openSegment 𝕜 x y ⊆ interior s :=\n  hs.open_segment_interior_closure_subset_interior hx (subset_closure hy)\n#align convex.open_segment_interior_self_subset_interior Convex.openSegment_interior_self_subset_interior\n-/\n\n",
 "openSegment_interior_closure_subset_interior":
 "#print Convex.openSegment_interior_closure_subset_interior /-\ntheorem Convex.openSegment_interior_closure_subset_interior {s : Set E} (hs : Convex 𝕜 s) {x y : E}\n    (hx : x ∈ interior s) (hy : y ∈ closure s) : openSegment 𝕜 x y ⊆ interior s :=\n  by\n  rintro _ ⟨a, b, ha, hb, hab, rfl⟩\n  exact hs.combo_interior_closure_mem_interior hx hy ha hb.le hab\n#align convex.open_segment_interior_closure_subset_interior Convex.openSegment_interior_closure_subset_interior\n-/\n\n",
 "openSegment_closure_interior_subset_interior":
 "#print Convex.openSegment_closure_interior_subset_interior /-\ntheorem Convex.openSegment_closure_interior_subset_interior {s : Set E} (hs : Convex 𝕜 s) {x y : E} (hx : x ∈ closure s)\n    (hy : y ∈ interior s) : openSegment 𝕜 x y ⊆ interior s :=\n  by\n  rintro _ ⟨a, b, ha, hb, hab, rfl⟩\n  exact hs.combo_closure_interior_mem_interior hx hy ha.le hb hab\n#align convex.open_segment_closure_interior_subset_interior Convex.openSegment_closure_interior_subset_interior\n-/\n\n",
 "isPreconnected":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n#print Convex.isPreconnected /-\n/-- A convex set is preconnected. -/\nprotected theorem Convex.isPreconnected {s : Set E} (h : Convex (exprℝ) s) : IsPreconnected s :=\n  s.eq_empty_or_nonempty.elim (fun h => h.symm ▸ isPreconnected_empty) fun hne => (h.is_connected hne).is_preconnected\n#align convex.is_preconnected Convex.isPreconnected\n-/\n\n",
 "isPathConnected":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n#print Convex.isPathConnected /-\n/-- A nonempty convex set is path connected. -/\nprotected theorem Convex.isPathConnected {s : Set E} (hconv : Convex (exprℝ) s) (hne : s.nonempty) :\n    IsPathConnected s := by\n  refine' is_path_connected_iff.mpr ⟨hne, _⟩\n  intro x x_in y y_in\n  have H := hconv.segment_subset x_in y_in\n  rw [segment_eq_image_lineMap] at H\n  exact\n    JoinedIn.ofLine affine_map.line_map_continuous.continuous_on (line_map_apply_zero _ _) (line_map_apply_one _ _) H\n#align convex.is_path_connected Convex.isPathConnected\n-/\n\n",
 "isConnected":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n#print Convex.isConnected /-\n/-- A nonempty convex set is connected. -/\nprotected theorem Convex.isConnected {s : Set E} (h : Convex (exprℝ) s) (hne : s.nonempty) : IsConnected s :=\n  (h.is_path_connected hne).is_connected\n#align convex.is_connected Convex.isConnected\n-/\n\n",
 "isCompact_stdSimplex":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n#print isCompact_stdSimplex /-\n/-- `std_simplex ℝ ι` is compact. -/\ntheorem isCompact_stdSimplex : IsCompact (stdSimplex (exprℝ) ι) :=\n  Metric.isCompact_iff_isClosed_bounded.2 ⟨isClosed_stdSimplex ι, bounded_stdSimplex ι⟩\n#align is_compact_std_simplex isCompact_stdSimplex\n-/\n\n",
 "isCompact_convexHull":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n#print Set.Finite.isCompact_convexHull /-\n/-- Convex hull of a finite set is compact. -/\ntheorem Set.Finite.isCompact_convexHull {s : Set E} (hs : s.finite) : IsCompact (convexHull (exprℝ) s) :=\n  by\n  rw [hs.convex_hull_eq_image]\n  apply (isCompact_stdSimplex _).image\n  haveI := hs.fintype\n  apply LinearMap.continuous_on_pi\n#align set.finite.compact_convex_hull Set.Finite.isCompact_convexHull\n-/\n\n",
 "isClosed_stdSimplex":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n#print isClosed_stdSimplex /-\n/-- `std_simplex ℝ ι` is closed. -/\ntheorem isClosed_stdSimplex : IsClosed (stdSimplex (exprℝ) ι) :=\n  (stdSimplex_eq_inter (exprℝ) ι).symm ▸\n    IsClosed.inter (isClosed_interᵢ fun i => isClosed_le continuous_const (continuous_apply i))\n      (isClosed_eq (continuous_finset_sum _ fun x _ => continuous_apply x) continuous_const)\n#align is_closed_std_simplex isClosed_stdSimplex\n-/\n\n",
 "isClosed_convexHull":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n#print Set.Finite.isClosed_convexHull /-\n/-- Convex hull of a finite set is closed. -/\ntheorem Set.Finite.isClosed_convexHull [T2Space E] {s : Set E} (hs : s.finite) : IsClosed (convexHull (exprℝ) s) :=\n  hs.compact_convex_hull.is_closed\n#align set.finite.is_closed_convex_hull Set.Finite.isClosed_convexHull\n-/\n\n",
 "interior":
 "#print Convex.interior /-\n/-- In a topological vector space, the interior of a convex set is convex. -/\nprotected theorem Convex.interior {s : Set E} (hs : Convex 𝕜 s) : Convex 𝕜 (interior s) :=\n  convex_iff_openSegment_subset.mpr fun x hx y hy =>\n    hs.open_segment_closure_interior_subset_interior (interior_subset_closure hx) hy\n#align convex.interior Convex.interior\n-/\n\n",
 "convex_iff_isPreconnected":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n#print Real.convex_iff_isPreconnected /-\n/-\nCopyright (c) 2020 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Alexander Bentkamp, Yury Kudryashov\n-/\ntheorem Real.convex_iff_isPreconnected {s : Set (exprℝ)} : Convex (exprℝ) s ↔ IsPreconnected s :=\n  convex_iff_ordConnected.trans isPreconnected_iff_ordConnected.symm\n#align real.convex_iff_is_preconnected Real.convex_iff_isPreconnected\n-/\n\n",
 "combo_self_interior_subset_interior":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print Convex.combo_self_interior_subset_interior /-\n/-- If `s` is a convex set, then `a • s + b • interior s ⊆ interior s` for all `0 ≤ a`, `0 < b`,\n`a + b = 1`. See also `convex.combo_closure_interior_subset_interior` for a stronger version. -/\ntheorem Convex.combo_self_interior_subset_interior {s : Set E} (hs : Convex 𝕜 s) {a b : 𝕜} (ha : 0 ≤ a) (hb : 0 < b)\n    (hab : a + b = 1) : «expr • » a s + «expr • » b (interior s) ⊆ interior s :=\n  by\n  rw [add_comm]\n  exact hs.combo_interior_self_subset_interior hb ha (add_comm a b ▸ hab)\n#align convex.combo_self_interior_subset_interior Convex.combo_self_interior_subset_interior\n-/\n\n",
 "combo_self_interior_mem_interior":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print Convex.combo_self_interior_mem_interior /-\ntheorem Convex.combo_self_interior_mem_interior {s : Set E} (hs : Convex 𝕜 s) {x y : E} (hx : x ∈ s)\n    (hy : y ∈ interior s) {a b : 𝕜} (ha : 0 ≤ a) (hb : 0 < b) (hab : a + b = 1) :\n    «expr • » a x + «expr • » b y ∈ interior s :=\n  hs.combo_closure_interior_mem_interior (subset_closure hx) hy ha hb hab\n#align convex.combo_self_interior_mem_interior Convex.combo_self_interior_mem_interior\n-/\n\n",
 "combo_interior_self_subset_interior":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print Convex.combo_interior_self_subset_interior /-\n/-- If `s` is a convex set, then `a • interior s + b • s ⊆ interior s` for all `0 < a`, `0 ≤ b`,\n`a + b = 1`. See also `convex.combo_interior_closure_subset_interior` for a stronger version. -/\ntheorem Convex.combo_interior_self_subset_interior {s : Set E} (hs : Convex 𝕜 s) {a b : 𝕜} (ha : 0 < a) (hb : 0 ≤ b)\n    (hab : a + b = 1) : «expr • » a (interior s) + «expr • » b s ⊆ interior s :=\n  calc\n    «expr • » a (interior s) + «expr • » b s ⊆ «expr • » a (interior s) + «expr • » b (closure s) :=\n      add_subset_add Subset.rfl <| image_subset _ subset_closure\n    _ ⊆ interior s := hs.combo_interior_closure_subset_interior ha hb hab\n    \n#align convex.combo_interior_self_subset_interior Convex.combo_interior_self_subset_interior\n-/\n\n",
 "combo_interior_self_mem_interior":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print Convex.combo_interior_self_mem_interior /-\ntheorem Convex.combo_interior_self_mem_interior {s : Set E} (hs : Convex 𝕜 s) {x y : E} (hx : x ∈ interior s)\n    (hy : y ∈ s) {a b : 𝕜} (ha : 0 < a) (hb : 0 ≤ b) (hab : a + b = 1) : «expr • » a x + «expr • » b y ∈ interior s :=\n  hs.combo_interior_closure_mem_interior hx (subset_closure hy) ha hb hab\n#align convex.combo_interior_self_mem_interior Convex.combo_interior_self_mem_interior\n-/\n\n",
 "combo_interior_closure_subset_interior":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print Convex.combo_interior_closure_subset_interior /-\n/-- If `s` is a convex set, then `a • interior s + b • closure s ⊆ interior s` for all `0 < a`,\n`0 ≤ b`, `a + b = 1`. See also `convex.combo_interior_self_subset_interior` for a weaker version. -/\ntheorem Convex.combo_interior_closure_subset_interior {s : Set E} (hs : Convex 𝕜 s) {a b : 𝕜} (ha : 0 < a) (hb : 0 ≤ b)\n    (hab : a + b = 1) : «expr • » a (interior s) + «expr • » b (closure s) ⊆ interior s :=\n  interior_smul₀ ha.ne' s ▸\n    calc\n      interior («expr • » a s) + «expr • » b (closure s) ⊆ interior («expr • » a s) + closure («expr • » b s) :=\n        add_subset_add Subset.rfl (smul_closure_subset b s)\n      _ = interior («expr • » a s) + «expr • » b s := by rw [is_open_interior.add_closure («expr • » b s)]\n      _ ⊆ interior («expr • » a s + «expr • » b s) := subset_interior_add_left\n      _ ⊆ interior s := interior_mono <| hs.set_combo_subset ha.le hb hab\n      \n#align convex.combo_interior_closure_subset_interior Convex.combo_interior_closure_subset_interior\n-/\n\n",
 "combo_interior_closure_mem_interior":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print Convex.combo_interior_closure_mem_interior /-\ntheorem Convex.combo_interior_closure_mem_interior {s : Set E} (hs : Convex 𝕜 s) {x y : E} (hx : x ∈ interior s)\n    (hy : y ∈ closure s) {a b : 𝕜} (ha : 0 < a) (hb : 0 ≤ b) (hab : a + b = 1) :\n    «expr • » a x + «expr • » b y ∈ interior s :=\n  hs.combo_interior_closure_subset_interior ha hb hab <| add_mem_add (smul_mem_smul_set hx) (smul_mem_smul_set hy)\n#align convex.combo_interior_closure_mem_interior Convex.combo_interior_closure_mem_interior\n-/\n\n",
 "combo_closure_interior_subset_interior":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print Convex.combo_closure_interior_subset_interior /-\n/-- If `s` is a convex set, then `a • closure s + b • interior s ⊆ interior s` for all `0 ≤ a`,\n`0 < b`, `a + b = 1`. See also `convex.combo_self_interior_subset_interior` for a weaker version. -/\ntheorem Convex.combo_closure_interior_subset_interior {s : Set E} (hs : Convex 𝕜 s) {a b : 𝕜} (ha : 0 ≤ a) (hb : 0 < b)\n    (hab : a + b = 1) : «expr • » a (closure s) + «expr • » b (interior s) ⊆ interior s :=\n  by\n  rw [add_comm]\n  exact hs.combo_interior_closure_subset_interior hb ha (add_comm a b ▸ hab)\n#align convex.combo_closure_interior_subset_interior Convex.combo_closure_interior_subset_interior\n-/\n\n",
 "combo_closure_interior_mem_interior":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print Convex.combo_closure_interior_mem_interior /-\ntheorem Convex.combo_closure_interior_mem_interior {s : Set E} (hs : Convex 𝕜 s) {x y : E} (hx : x ∈ closure s)\n    (hy : y ∈ interior s) {a b : 𝕜} (ha : 0 ≤ a) (hb : 0 < b) (hab : a + b = 1) :\n    «expr • » a x + «expr • » b y ∈ interior s :=\n  hs.combo_closure_interior_subset_interior ha hb hab <| add_mem_add (smul_mem_smul_set hx) (smul_mem_smul_set hy)\n#align convex.combo_closure_interior_mem_interior Convex.combo_closure_interior_mem_interior\n-/\n\n",
 "closure_subset_interior_image_homothety_of_one_lt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n#print Convex.closure_subset_interior_image_homothety_of_one_lt /-\n/-- If we dilate a convex set about a point in its interior by a scale `t > 1`, the interior of\nthe result includes the closure of the original set.\n\nTODO Generalise this from convex sets to sets that are balanced / star-shaped about `x`. -/\ntheorem Convex.closure_subset_interior_image_homothety_of_one_lt {s : Set E} (hs : Convex (exprℝ) s) {x : E}\n    (hx : x ∈ interior s) (t : exprℝ) (ht : 1 < t) : closure s ⊆ interior («expr '' » (homothety x t) s) :=\n  (hs.closure_subset_image_homothety_interior_of_one_lt hx t ht).trans <|\n    (homothety_isOpenMap x t (one_pos.trans ht).ne').image_interior_subset _\n#align convex.closure_subset_interior_image_homothety_of_one_lt Convex.closure_subset_interior_image_homothety_of_one_lt\n-/\n\n",
 "closure_subset_image_homothety_interior_of_one_lt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n#print Convex.closure_subset_image_homothety_interior_of_one_lt /-\n/-- If we dilate the interior of a convex set about a point in its interior by a scale `t > 1`,\nthe result includes the closure of the original set.\n\nTODO Generalise this from convex sets to sets that are balanced / star-shaped about `x`. -/\ntheorem Convex.closure_subset_image_homothety_interior_of_one_lt {s : Set E} (hs : Convex (exprℝ) s) {x : E}\n    (hx : x ∈ interior s) (t : exprℝ) (ht : 1 < t) : closure s ⊆ «expr '' » (homothety x t) (interior s) :=\n  by\n  intro y hy\n  have hne : t ≠ 0 := (one_pos.trans ht).ne'\n  refine'\n    ⟨homothety x t⁻¹ y, hs.open_segment_interior_closure_subset_interior hx hy _,\n      (AffineEquiv.homothetyUnitsMulHom x (Units.mk0 t hne)).apply_symm_apply y⟩\n  rw [openSegment_eq_image_lineMap, ← inv_one, ← inv_Ioi (zero_lt_one' (exprℝ)), ← image_inv, image_image,\n    homothety_eq_line_map]\n  exact mem_image_of_mem _ ht\n#align convex.closure_subset_image_homothety_interior_of_one_lt Convex.closure_subset_image_homothety_interior_of_one_lt\n-/\n\n",
 "closure_openSegment":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `segment -/\n#print closure_openSegment /-\n@[simp]\ntheorem closure_openSegment (x y : E) : closure (openSegment 𝕜 x y) = segment x 𝕜 y :=\n  by\n  rw [segment_eq_image, openSegment_eq_image, ← closure_Ioo (zero_ne_one' 𝕜)]\n  exact\n    (image_closure_of_isCompact (bounded_Ioo _ _).is_compact_closure <| Continuous.continuousOn <| by continuity).symm\n#align closure_open_segment closure_openSegment\n-/\n\n",
 "closure":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print Convex.closure /-\n/-- In a topological vector space, the closure of a convex set is convex. -/\nprotected theorem Convex.closure {s : Set E} (hs : Convex 𝕜 s) : Convex 𝕜 (closure s) := fun x hx y hy a b ha hb hab =>\n  let f : E → E → E := fun x' y' => «expr • » a x' + «expr • » b y'\n  have hf : Continuous (function.uncurry f) := (continuous_fst.const_smul _).add (continuous_snd.const_smul _)\n  show f x y ∈ closure s from map_mem_closure₂ hf hx hy fun x' hx' y' hy' => hs hx' hy' ha hb hab\n#align convex.closure Convex.closure\n-/\n\n",
 "bounded_stdSimplex":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n#print bounded_stdSimplex /-\n/-- `std_simplex ℝ ι` is bounded. -/\ntheorem bounded_stdSimplex : Metric.Bounded (stdSimplex (exprℝ) ι) :=\n  (Metric.bounded_iff_subset_ball 0).2 ⟨1, stdSimplex_subset_closedBall⟩\n#align bounded_std_simplex bounded_stdSimplex\n-/\n\n",
 "add_smul_sub_mem_interior'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print Convex.add_smul_sub_mem_interior' /-\n/-- If `x ∈ closure s` and `y ∈ interior s`, then the segment `(x, y]` is included in `interior s`.\n-/\ntheorem Convex.add_smul_sub_mem_interior' {s : Set E} (hs : Convex 𝕜 s) {x y : E} (hx : x ∈ closure s)\n    (hy : y ∈ interior s) {t : 𝕜} (ht : t ∈ Ioc (0 : 𝕜) 1) : x + «expr • » t (y - x) ∈ interior s := by\n  simpa only [sub_smul, smul_sub, one_smul, add_sub, add_comm] using\n    hs.combo_interior_closure_mem_interior hy hx ht.1 (sub_nonneg.mpr ht.2) (add_sub_cancel'_right _ _)\n#align convex.add_smul_sub_mem_interior' Convex.add_smul_sub_mem_interior'\n-/\n\n",
 "add_smul_sub_mem_interior":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print Convex.add_smul_sub_mem_interior /-\n/-- If `x ∈ s` and `y ∈ interior s`, then the segment `(x, y]` is included in `interior s`. -/\ntheorem Convex.add_smul_sub_mem_interior {s : Set E} (hs : Convex 𝕜 s) {x y : E} (hx : x ∈ s) (hy : y ∈ interior s)\n    {t : 𝕜} (ht : t ∈ Ioc (0 : 𝕜) 1) : x + «expr • » t (y - x) ∈ interior s :=\n  hs.add_smul_sub_mem_interior' (subset_closure hx) hy ht\n#align convex.add_smul_sub_mem_interior Convex.add_smul_sub_mem_interior\n-/\n\n",
 "add_smul_mem_interior'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print Convex.add_smul_mem_interior' /-\n/-- If `x ∈ closure s` and `x + y ∈ interior s`, then `x + t y ∈ interior s` for `t ∈ (0, 1]`. -/\ntheorem Convex.add_smul_mem_interior' {s : Set E} (hs : Convex 𝕜 s) {x y : E} (hx : x ∈ closure s)\n    (hy : x + y ∈ interior s) {t : 𝕜} (ht : t ∈ Ioc (0 : 𝕜) 1) : x + «expr • » t y ∈ interior s := by\n  simpa only [add_sub_cancel'] using hs.add_smul_sub_mem_interior' hx hy ht\n#align convex.add_smul_mem_interior' Convex.add_smul_mem_interior'\n-/\n\n",
 "add_smul_mem_interior":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print Convex.add_smul_mem_interior /-\n/-- If `x ∈ s` and `x + y ∈ interior s`, then `x + t y ∈ interior s` for `t ∈ (0, 1]`. -/\ntheorem Convex.add_smul_mem_interior {s : Set E} (hs : Convex 𝕜 s) {x y : E} (hx : x ∈ s) (hy : x + y ∈ interior s)\n    {t : 𝕜} (ht : t ∈ Ioc (0 : 𝕜) 1) : x + «expr • » t y ∈ interior s :=\n  hs.add_smul_mem_interior' (subset_closure hx) hy ht\n#align convex.add_smul_mem_interior Convex.add_smul_mem_interior\n-/\n\n"}