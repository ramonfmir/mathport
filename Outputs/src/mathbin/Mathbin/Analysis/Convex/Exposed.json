{"subset":
 "protected theorem subset (hAB : IsExposed ùïú A B) : B ‚äÜ A :=\n  by\n  rintro x hx\n  obtain ‚ü®_, rfl‚ü© := hAB ‚ü®x, hx‚ü©\n  exact hx.1\n#align subset subset\n\n",
 "sInter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚ãÇ‚ÇÄ ¬ª -/\ntheorem sInter [ContinuousAdd ùïú] {F : Finset (Set E)} (hF : F.nonempty) (hAF : ‚àÄ B ‚àà F, IsExposed ùïú A B) :\n    IsExposed ùïú A (¬´expr‚ãÇ‚ÇÄ ¬ª F) := by\n  revert hF F\n  refine' Finset.induction _ _\n  ¬∑ rintro h\n    exfalso\n    exact not_nonempty_empty h\n  rintro C F _ hF _ hCF\n  rw [Finset.coe_insert, sInter_insert]\n  obtain rfl | hFnemp := F.eq_empty_or_nonempty\n  ¬∑ rw [Finset.coe_empty, sInter_empty, inter_univ]\n    exact hCF C (Finset.mem_singleton_self C)\n  exact (hCF C (Finset.mem_insert_self C F)).inter (hF hFnemp fun B hB => hCF B (Finset.mem_insert_of_mem hB))\n#align sInter sInter\n\n",
 "refl":
 "#print refl /-\n@[refl]\nprotected theorem refl (A : Set E) : IsExposed ùïú A A := fun ‚ü®w, hw‚ü© =>\n  ‚ü®0, Subset.antisymm (fun x hx => ‚ü®hx, fun y hy => le_refl 0‚ü©) fun x hx => hx.1‚ü©\n#align refl refl\n-/\n\n",
 "mono":
 "/- `is_exposed` is *not* transitive: Consider a (topologically) open cube with vertices\n`A‚ÇÄ‚ÇÄ‚ÇÄ, ..., A‚ÇÅ‚ÇÅ‚ÇÅ` and add to it the triangle `A‚ÇÄ‚ÇÄ‚ÇÄA‚ÇÄ‚ÇÄ‚ÇÅA‚ÇÄ‚ÇÅ‚ÇÄ`. Then `A‚ÇÄ‚ÇÄ‚ÇÅA‚ÇÄ‚ÇÅ‚ÇÄ` is an exposed subset\nof `A‚ÇÄ‚ÇÄ‚ÇÄA‚ÇÄ‚ÇÄ‚ÇÅA‚ÇÄ‚ÇÅ‚ÇÄ` which is an exposed subset of the cube, but `A‚ÇÄ‚ÇÄ‚ÇÅA‚ÇÄ‚ÇÅ‚ÇÄ` is not itself an exposed\nsubset of the cube. -/\nprotected theorem mono (hC : IsExposed ùïú A C) (hBA : B ‚äÜ A) (hCB : C ‚äÜ B) : IsExposed ùïú B C :=\n  by\n  rintro ‚ü®w, hw‚ü©\n  obtain ‚ü®l, rfl‚ü© := hC ‚ü®w, hw‚ü©\n  exact\n    ‚ü®l,\n      subset.antisymm (fun x hx => ‚ü®hCB hx, fun y hy => hx.2 y (hBA hy)‚ü©) fun x hx =>\n        ‚ü®hBA hx.1, fun y hy => (hw.2 y hy).trans (hx.2 w (hCB hw))‚ü©‚ü©\n#align mono mono\n\n",
 "mem_exposedPoints_iff_exposed_singleton":
 "#print mem_exposedPoints_iff_exposed_singleton /-\n/-- Exposed points exactly correspond to exposed singletons. -/\ntheorem mem_exposedPoints_iff_exposed_singleton : x ‚àà A.exposed_points ùïú ‚Üî IsExposed ùïú A {x} :=\n  by\n  use fun ‚ü®hxA, l, hl‚ü© h =>\n    ‚ü®l,\n      Eq.symm <| eq_singleton_iff_unique_mem.2 ‚ü®‚ü®hxA, fun y hy => (hl y hy).1‚ü©, fun z hz => (hl z hz.1).2 (hz.2 x hxA)‚ü©‚ü©\n  rintro h\n  obtain ‚ü®l, hl‚ü© := h ‚ü®x, mem_singleton _‚ü©\n  rw [eq_comm, eq_singleton_iff_unique_mem] at hl\n  exact ‚ü®hl.1.1, l, fun y hy => ‚ü®hl.1.2 y hy, fun hxy => hl.2 y ‚ü®hy, fun z hz => (hl.1.2 z hz).trans hxy‚ü©‚ü©‚ü©\n#align mem_exposed_points_iff_exposed_singleton mem_exposedPoints_iff_exposed_singleton\n-/\n\n",
 "isExposed_empty":
 "#print isExposed_empty /-\ntheorem isExposed_empty : IsExposed ùïú A ‚àÖ := fun ‚ü®x, hx‚ü© =>\n  by\n  exfalso\n  exact hx\n#align is_exposed_empty isExposed_empty\n-/\n\n",
 "isExposed":
 "#print ContinuousLinearMap.toExposed.isExposed /-\n/-\nCopyright (c) 2021 Ya√´l Dillies, Bhavik Mehta. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Ya√´l Dillies, Bhavik Mehta\n-/\ntheorem ContinuousLinearMap.toExposed.isExposed : IsExposed ùïú A (l.to_exposed A) := fun h => ‚ü®l, rfl‚ü©\n#align continuous_linear_map.to_exposed.is_exposed ContinuousLinearMap.toExposed.isExposed\n-/\n\n",
 "inter_right":
 "theorem inter_right (hC : IsExposed ùïú B C) (hCA : C ‚äÜ A) : IsExposed ùïú (A ‚à© B) C :=\n  by\n  rw [inter_comm]\n  exact hC.inter_left hCA\n#align inter_right inter_right\n\n",
 "inter_left":
 "theorem inter_left (hC : IsExposed ùïú A C) (hCB : C ‚äÜ B) : IsExposed ùïú (A ‚à© B) C :=\n  by\n  rintro ‚ü®w, hw‚ü©\n  obtain ‚ü®l, rfl‚ü© := hC ‚ü®w, hw‚ü©\n  exact\n    ‚ü®l,\n      subset.antisymm (fun x hx => ‚ü®‚ü®hx.1, hCB hx‚ü©, fun y hy => hx.2 y hy.1‚ü©) fun x ‚ü®‚ü®hxC, _‚ü©, hx‚ü© =>\n        ‚ü®hxC, fun y hy => (hw.2 y hy).trans (hx w ‚ü®hC.subset hw, hCB hw‚ü©)‚ü©‚ü©\n#align inter_left inter_left\n\n",
 "inter":
 "protected theorem inter [ContinuousAdd ùïú] {A B C : Set E} (hB : IsExposed ùïú A B) (hC : IsExposed ùïú A C) :\n    IsExposed ùïú A (B ‚à© C) := by\n  rintro ‚ü®w, hwB, hwC‚ü©\n  obtain ‚ü®l‚ÇÅ, rfl‚ü© := hB ‚ü®w, hwB‚ü©\n  obtain ‚ü®l‚ÇÇ, rfl‚ü© := hC ‚ü®w, hwC‚ü©\n  refine' ‚ü®l‚ÇÅ + l‚ÇÇ, subset.antisymm _ _‚ü©\n  ¬∑ rintro x ‚ü®‚ü®hxA, hxB‚ü©, ‚ü®-, hxC‚ü©‚ü©\n    exact ‚ü®hxA, fun z hz => add_le_add (hxB z hz) (hxC z hz)‚ü©\n  rintro x ‚ü®hxA, hx‚ü©\n  refine' ‚ü®‚ü®hxA, fun y hy => _‚ü©, hxA, fun y hy => _‚ü©\n  ¬∑ exact (add_le_add_iff_right (l‚ÇÇ x)).1 ((add_le_add (hwB.2 y hy) (hwC.2 x hxA)).trans (hx w hwB.1))\n  ¬∑ exact (add_le_add_iff_left (l‚ÇÅ x)).1 (le_trans (add_le_add (hwB.2 x hxA) (hwC.2 y hy)) (hx w hwB.1))\n#align inter inter\n\n",
 "exposed_point_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚ÜíL[ ] ¬ª -/\n#print exposed_point_def /-\ntheorem exposed_point_def :\n    x ‚àà A.exposed_points ùïú ‚Üî x ‚àà A ‚àß ‚àÉ l : ¬´expr ‚ÜíL[ ] ¬ª E ùïú ùïú, ‚àÄ y ‚àà A, l y ‚â§ l x ‚àß (l x ‚â§ l y ‚Üí y = x) :=\n  iff.rfl\n#align exposed_point_def exposed_point_def\n-/\n\n",
 "exposedPoints_subset_extremePoints":
 "#print exposedPoints_subset_extremePoints /-\ntheorem exposedPoints_subset_extremePoints : A.exposed_points ùïú ‚äÜ A.extreme_points ùïú := fun x hx =>\n  mem_extremePoints_iff_extreme_singleton.2 (mem_exposedPoints_iff_exposed_singleton.1 hx).is_extreme\n#align exposed_points_subset_extreme_points exposedPoints_subset_extremePoints\n-/\n\n",
 "exposedPoints_subset":
 "#print exposedPoints_subset /-\ntheorem exposedPoints_subset : A.exposed_points ùïú ‚äÜ A := fun x hx => hx.1\n#align exposed_points_subset exposedPoints_subset\n-/\n\n",
 "exposedPoints_empty":
 "#print exposedPoints_empty /-\n@[simp]\ntheorem exposedPoints_empty : (‚àÖ : Set E).exposed_points ùïú = ‚àÖ :=\n  subset_empty_iff.1 exposedPoints_subset\n#align exposed_points_empty exposedPoints_empty\n-/\n\n",
 "eq_inter_halfspace'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚ÜíL[ ] ¬ª -/\n/-- If `B` is a nonempty exposed subset of `A`, then `B` is the intersection of `A` with some closed\nhalfspace. The converse is *not* true. It would require that the corresponding open halfspace\ndoesn't intersect `A`. -/\ntheorem eq_inter_halfspace' {A B : Set E} (hAB : IsExposed ùïú A B) (hB : B.nonempty) :\n    ‚àÉ l : ¬´expr ‚ÜíL[ ] ¬ª E ùïú ùïú, ‚àÉ a, B = { x ‚àà A | a ‚â§ l x } :=\n  by\n  obtain ‚ü®l, rfl‚ü© := hAB hB\n  obtain ‚ü®w, hw‚ü© := hB\n  exact\n    ‚ü®l, l w, subset.antisymm (fun x hx => ‚ü®hx.1, hx.2 w hw.1‚ü©) fun x hx => ‚ü®hx.1, fun y hy => (hw.2 y hy).trans hx.2‚ü©‚ü©\n#align eq_inter_halfspace' eq_inter_halfspace'\n\n",
 "eq_inter_halfspace":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚ÜíL[ ] ¬ª -/\n/-- For nontrivial `ùïú`, if `B` is an exposed subset of `A`, then `B` is the intersection of `A` with\nsome closed halfspace. The converse is *not* true. It would require that the corresponding open\nhalfspace doesn't intersect `A`. -/\ntheorem eq_inter_halfspace [Nontrivial ùïú] {A B : Set E} (hAB : IsExposed ùïú A B) :\n    ‚àÉ l : ¬´expr ‚ÜíL[ ] ¬ª E ùïú ùïú, ‚àÉ a, B = { x ‚àà A | a ‚â§ l x } :=\n  by\n  obtain rfl | hB := B.eq_empty_or_nonempty\n  ¬∑ refine' ‚ü®0, 1, _‚ü©\n    rw [eq_comm, eq_empty_iff_forall_not_mem]\n    rintro x ‚ü®-, h‚ü©\n    rw [ContinuousLinearMap.zero_apply] at h\n    have : ¬¨(1 : ùïú) ‚â§ 0 := not_le_of_lt zero_lt_one\n    contradiction\n  exact hAB.eq_inter_halfspace' hB\n#align eq_inter_halfspace eq_inter_halfspace\n\n",
 "antisymm":
 "#print antisymm /-\nprotected theorem antisymm (hB : IsExposed ùïú A B) (hA : IsExposed ùïú B A) : A = B :=\n  hA.subset.antisymm hB.subset\n#align antisymm antisymm\n-/\n\n",
 "IsExtreme":
 "#print IsExtreme /-\nprotected theorem IsExtreme (hAB : IsExposed ùïú A B) : IsExtreme ùïú A B :=\n  by\n  refine' ‚ü®hAB.subset, fun x‚ÇÅ hx‚ÇÅA x‚ÇÇ hx‚ÇÇA x hxB hx => _‚ü©\n  obtain ‚ü®l, rfl‚ü© := hAB ‚ü®x, hxB‚ü©\n  have hl : ConvexOn ùïú univ l := l.to_linear_map.convex_on convex_univ\n  have hlx‚ÇÅ := hxB.2 x‚ÇÅ hx‚ÇÅA\n  have hlx‚ÇÇ := hxB.2 x‚ÇÇ hx‚ÇÇA\n  refine' ‚ü®‚ü®hx‚ÇÅA, fun y hy => _‚ü©, ‚ü®hx‚ÇÇA, fun y hy => _‚ü©‚ü©\n  ¬∑ have := @ConvexOn.le_left_of_right_le ùïú E ùïú _ _ _\n    rw [hlx‚ÇÅ.antisymm (hl.le_left_of_right_le (mem_univ _) (mem_univ _) hx hlx‚ÇÇ)]\n    exact hxB.2 y hy\n  ¬∑ rw [hlx‚ÇÇ.antisymm (hl.le_right_of_left_le (mem_univ _) (mem_univ _) hx hlx‚ÇÅ)]\n    exact hxB.2 y hy\n#align is_extreme IsExtreme\n-/\n\n",
 "IsCompact":
 "#print IsCompact /-\nprotected theorem IsCompact [OrderClosedTopology ùïú] [T2Space E] {A B : Set E} (hAB : IsExposed ùïú A B)\n    (hA : IsCompact A) : IsCompact B :=\n  isCompact_of_isClosed_subset hA (hAB.is_closed hA.is_closed) hAB.subset\n#align is_compact IsCompact\n-/\n\n",
 "IsClosed":
 "#print IsClosed /-\nprotected theorem IsClosed [OrderClosedTopology ùïú] {A B : Set E} (hAB : IsExposed ùïú A B) (hA : IsClosed A) :\n    IsClosed B := by\n  obtain rfl | hB := B.eq_empty_or_nonempty\n  ¬∑ simp\n  obtain ‚ü®l, a, rfl‚ü© := hAB.eq_inter_halfspace' hB\n  exact hA.is_closed_le continuousOn_const l.continuous.continuous_on\n#align is_closed IsClosed\n-/\n\n",
 "Convex":
 "#print Convex /-\nprotected theorem Convex (hAB : IsExposed ùïú A B) (hA : Convex ùïú A) : Convex ùïú B :=\n  by\n  obtain rfl | hB := B.eq_empty_or_nonempty\n  ¬∑ exact convex_empty\n  obtain ‚ü®l, rfl‚ü© := hAB hB\n  exact fun x‚ÇÅ hx‚ÇÅ x‚ÇÇ hx‚ÇÇ a b ha hb hab =>\n    ‚ü®hA hx‚ÇÅ.1 hx‚ÇÇ.1 ha hb hab, fun y hy =>\n      ((l.to_linear_map.concave_on convex_univ).convex_ge _ ‚ü®mem_univ _, hx‚ÇÅ.2 y hy‚ü© ‚ü®mem_univ _, hx‚ÇÇ.2 y hy‚ü© ha hb\n          hab).2‚ü©\n#align convex Convex\n-/\n\n"}