{"subset":
 "protected theorem subset (hAB : is_exposed ğ•œ A B) : B âŠ† A :=\n  by\n  rintro x hx\n  obtain âŸ¨_, rflâŸ© := hAB âŸ¨x, hxâŸ©\n  exact hx.1\n#align subset subset\n\n",
 "sInter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹‚â‚€ Â» -/\ntheorem sInter [has_continuous_add ğ•œ] {F : Finset (set E)} (hF : F.nonempty) (hAF : âˆ€ B âˆˆ F, is_exposed ğ•œ A B) :\n    is_exposed ğ•œ A (Â«exprâ‹‚â‚€ Â» F) := by\n  revert hF F\n  refine' Finset.induction _ _\n  Â· rintro h\n    exfalso\n    exact not_nonempty_empty h\n  rintro C F _ hF _ hCF\n  rw [Finset.coe_insert, sInter_insert]\n  obtain rfl | hFnemp := F.eq_empty_or_nonempty\n  Â· rw [Finset.coe_empty, sInter_empty, inter_univ]\n    exact hCF C (Finset.mem_singleton_self C)\n  exact (hCF C (Finset.mem_insert_self C F)).inter (hF hFnemp fun B hB => hCF B (Finset.mem_insert_of_mem hB))\n#align sInter sInter\n\n",
 "refl":
 "#print refl /-\n@[refl]\nprotected theorem refl (A : set E) : is_exposed ğ•œ A A := fun âŸ¨w, hwâŸ© =>\n  âŸ¨0, Subset.antisymm (fun x hx => âŸ¨hx, fun y hy => le_refl 0âŸ©) fun x hx => hx.1âŸ©\n#align refl refl\n-/\n\n",
 "mono":
 "/- `is_exposed` is *not* transitive: Consider a (topologically) open cube with vertices\n`Aâ‚€â‚€â‚€, ..., Aâ‚â‚â‚` and add to it the triangle `Aâ‚€â‚€â‚€Aâ‚€â‚€â‚Aâ‚€â‚â‚€`. Then `Aâ‚€â‚€â‚Aâ‚€â‚â‚€` is an exposed subset\nof `Aâ‚€â‚€â‚€Aâ‚€â‚€â‚Aâ‚€â‚â‚€` which is an exposed subset of the cube, but `Aâ‚€â‚€â‚Aâ‚€â‚â‚€` is not itself an exposed\nsubset of the cube. -/\nprotected theorem mono (hC : is_exposed ğ•œ A C) (hBA : B âŠ† A) (hCB : C âŠ† B) : is_exposed ğ•œ B C :=\n  by\n  rintro âŸ¨w, hwâŸ©\n  obtain âŸ¨l, rflâŸ© := hC âŸ¨w, hwâŸ©\n  exact\n    âŸ¨l,\n      subset.antisymm (fun x hx => âŸ¨hCB hx, fun y hy => hx.2 y (hBA hy)âŸ©) fun x hx =>\n        âŸ¨hBA hx.1, fun y hy => (hw.2 y hy).trans (hx.2 w (hCB hw))âŸ©âŸ©\n#align mono mono\n\n",
 "mem_exposed_points_iff_exposed_singleton":
 "/-- Exposed points exactly correspond to exposed singletons. -/\ntheorem mem_exposed_points_iff_exposed_singleton : x âˆˆ A.exposed_points ğ•œ â†” is_exposed ğ•œ A {x} :=\n  by\n  use fun âŸ¨hxA, l, hlâŸ© h =>\n    âŸ¨l,\n      eq.symm <| eq_singleton_iff_unique_mem.2 âŸ¨âŸ¨hxA, fun y hy => (hl y hy).1âŸ©, fun z hz => (hl z hz.1).2 (hz.2 x hxA)âŸ©âŸ©\n  rintro h\n  obtain âŸ¨l, hlâŸ© := h âŸ¨x, mem_singleton _âŸ©\n  rw [eq_comm, eq_singleton_iff_unique_mem] at hl\n  exact âŸ¨hl.1.1, l, fun y hy => âŸ¨hl.1.2 y hy, fun hxy => hl.2 y âŸ¨hy, fun z hz => (hl.1.2 z hz).trans hxyâŸ©âŸ©âŸ©\n#align mem_exposed_points_iff_exposed_singleton mem_exposed_points_iff_exposed_singleton\n\n",
 "is_extreme":
 "protected theorem is_extreme (hAB : is_exposed ğ•œ A B) : is_extreme ğ•œ A B :=\n  by\n  refine' âŸ¨hAB.subset, fun xâ‚ hxâ‚A xâ‚‚ hxâ‚‚A x hxB hx => _âŸ©\n  obtain âŸ¨l, rflâŸ© := hAB âŸ¨x, hxBâŸ©\n  have hl : convex_on ğ•œ univ l := l.to_linear_map.convex_on convex_univ\n  have hlxâ‚ := hxB.2 xâ‚ hxâ‚A\n  have hlxâ‚‚ := hxB.2 xâ‚‚ hxâ‚‚A\n  refine' âŸ¨âŸ¨hxâ‚A, fun y hy => _âŸ©, âŸ¨hxâ‚‚A, fun y hy => _âŸ©âŸ©\n  Â· have := @convex_on.le_left_of_right_le ğ•œ E ğ•œ _ _ _\n    rw [hlxâ‚.antisymm (hl.le_left_of_right_le (mem_univ _) (mem_univ _) hx hlxâ‚‚)]\n    exact hxB.2 y hy\n  Â· rw [hlxâ‚‚.antisymm (hl.le_right_of_left_le (mem_univ _) (mem_univ _) hx hlxâ‚)]\n    exact hxB.2 y hy\n#align is_extreme is_extreme\n\n",
 "is_exposed_empty":
 "theorem is_exposed_empty : is_exposed ğ•œ A âˆ… := fun âŸ¨x, hxâŸ© =>\n  by\n  exfalso\n  exact hx\n#align is_exposed_empty is_exposed_empty\n\n",
 "is_exposed":
 "/-\nCopyright (c) 2021 YaÃ«l Dillies, Bhavik Mehta. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: YaÃ«l Dillies, Bhavik Mehta\n-/\ntheorem continuous_linear_map.to_exposed.is_exposed : is_exposed ğ•œ A (l.to_exposed A) := fun h => âŸ¨l, rflâŸ©\n#align continuous_linear_map.to_exposed.is_exposed continuous_linear_map.to_exposed.is_exposed\n\n",
 "is_compact":
 "protected theorem is_compact [order_closed_topology ğ•œ] [t2_space E] {A B : set E} (hAB : is_exposed ğ•œ A B)\n    (hA : is_compact A) : is_compact B :=\n  is_compact_of_is_closed_subset hA (hAB.is_closed hA.is_closed) hAB.subset\n#align is_compact is_compact\n\n",
 "is_closed":
 "protected theorem is_closed [order_closed_topology ğ•œ] {A B : set E} (hAB : is_exposed ğ•œ A B) (hA : is_closed A) :\n    is_closed B := by\n  obtain rfl | hB := B.eq_empty_or_nonempty\n  Â· simp\n  obtain âŸ¨l, a, rflâŸ© := hAB.eq_inter_halfspace' hB\n  exact hA.is_closed_le continuous_on_const l.continuous.continuous_on\n#align is_closed is_closed\n\n",
 "inter_right":
 "theorem inter_right (hC : is_exposed ğ•œ B C) (hCA : C âŠ† A) : is_exposed ğ•œ (A âˆ© B) C :=\n  by\n  rw [inter_comm]\n  exact hC.inter_left hCA\n#align inter_right inter_right\n\n",
 "inter_left":
 "theorem inter_left (hC : is_exposed ğ•œ A C) (hCB : C âŠ† B) : is_exposed ğ•œ (A âˆ© B) C :=\n  by\n  rintro âŸ¨w, hwâŸ©\n  obtain âŸ¨l, rflâŸ© := hC âŸ¨w, hwâŸ©\n  exact\n    âŸ¨l,\n      subset.antisymm (fun x hx => âŸ¨âŸ¨hx.1, hCB hxâŸ©, fun y hy => hx.2 y hy.1âŸ©) fun x âŸ¨âŸ¨hxC, _âŸ©, hxâŸ© =>\n        âŸ¨hxC, fun y hy => (hw.2 y hy).trans (hx w âŸ¨hC.subset hw, hCB hwâŸ©)âŸ©âŸ©\n#align inter_left inter_left\n\n",
 "inter":
 "protected theorem inter [has_continuous_add ğ•œ] {A B C : set E} (hB : is_exposed ğ•œ A B) (hC : is_exposed ğ•œ A C) :\n    is_exposed ğ•œ A (B âˆ© C) := by\n  rintro âŸ¨w, hwB, hwCâŸ©\n  obtain âŸ¨lâ‚, rflâŸ© := hB âŸ¨w, hwBâŸ©\n  obtain âŸ¨lâ‚‚, rflâŸ© := hC âŸ¨w, hwCâŸ©\n  refine' âŸ¨lâ‚ + lâ‚‚, subset.antisymm _ _âŸ©\n  Â· rintro x âŸ¨âŸ¨hxA, hxBâŸ©, âŸ¨-, hxCâŸ©âŸ©\n    exact âŸ¨hxA, fun z hz => add_le_add (hxB z hz) (hxC z hz)âŸ©\n  rintro x âŸ¨hxA, hxâŸ©\n  refine' âŸ¨âŸ¨hxA, fun y hy => _âŸ©, hxA, fun y hy => _âŸ©\n  Â· exact (add_le_add_iff_right (lâ‚‚ x)).1 ((add_le_add (hwB.2 y hy) (hwC.2 x hxA)).trans (hx w hwB.1))\n  Â· exact (add_le_add_iff_left (lâ‚ x)).1 (le_trans (add_le_add (hwB.2 x hxA) (hwC.2 y hy)) (hx w hwB.1))\n#align inter inter\n\n",
 "exposed_points_subset_extreme_points":
 "theorem exposed_points_subset_extreme_points : A.exposed_points ğ•œ âŠ† A.extreme_points ğ•œ := fun x hx =>\n  mem_extreme_points_iff_extreme_singleton.2 (mem_exposed_points_iff_exposed_singleton.1 hx).is_extreme\n#align exposed_points_subset_extreme_points exposed_points_subset_extreme_points\n\n",
 "exposed_points_subset":
 "theorem exposed_points_subset : A.exposed_points ğ•œ âŠ† A := fun x hx => hx.1\n#align exposed_points_subset exposed_points_subset\n\n",
 "exposed_points_empty":
 "@[simp]\ntheorem exposed_points_empty : (âˆ… : set E).exposed_points ğ•œ = âˆ… :=\n  subset_empty_iff.1 exposed_points_subset\n#align exposed_points_empty exposed_points_empty\n\n",
 "exposed_point_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\ntheorem exposed_point_def :\n    x âˆˆ A.exposed_points ğ•œ â†” x âˆˆ A âˆ§ âˆƒ l : Â«expr â†’L[ ] Â» E ğ•œ ğ•œ, âˆ€ y âˆˆ A, l y â‰¤ l x âˆ§ (l x â‰¤ l y â†’ y = x) :=\n  iff.rfl\n#align exposed_point_def exposed_point_def\n\n",
 "eq_inter_halfspace'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/-- If `B` is a nonempty exposed subset of `A`, then `B` is the intersection of `A` with some closed\nhalfspace. The converse is *not* true. It would require that the corresponding open halfspace\ndoesn't intersect `A`. -/\ntheorem eq_inter_halfspace' {A B : set E} (hAB : is_exposed ğ•œ A B) (hB : B.nonempty) :\n    âˆƒ l : Â«expr â†’L[ ] Â» E ğ•œ ğ•œ, âˆƒ a, B = { x âˆˆ A | a â‰¤ l x } :=\n  by\n  obtain âŸ¨l, rflâŸ© := hAB hB\n  obtain âŸ¨w, hwâŸ© := hB\n  exact\n    âŸ¨l, l w, subset.antisymm (fun x hx => âŸ¨hx.1, hx.2 w hw.1âŸ©) fun x hx => âŸ¨hx.1, fun y hy => (hw.2 y hy).trans hx.2âŸ©âŸ©\n#align eq_inter_halfspace' eq_inter_halfspace'\n\n",
 "eq_inter_halfspace":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/-- For nontrivial `ğ•œ`, if `B` is an exposed subset of `A`, then `B` is the intersection of `A` with\nsome closed halfspace. The converse is *not* true. It would require that the corresponding open\nhalfspace doesn't intersect `A`. -/\ntheorem eq_inter_halfspace [nontrivial ğ•œ] {A B : set E} (hAB : is_exposed ğ•œ A B) :\n    âˆƒ l : Â«expr â†’L[ ] Â» E ğ•œ ğ•œ, âˆƒ a, B = { x âˆˆ A | a â‰¤ l x } :=\n  by\n  obtain rfl | hB := B.eq_empty_or_nonempty\n  Â· refine' âŸ¨0, 1, _âŸ©\n    rw [eq_comm, eq_empty_iff_forall_not_mem]\n    rintro x âŸ¨-, hâŸ©\n    rw [continuous_linear_map.zero_apply] at h\n    have : Â¬(1 : ğ•œ) â‰¤ 0 := not_le_of_lt zero_lt_one\n    contradiction\n  exact hAB.eq_inter_halfspace' hB\n#align eq_inter_halfspace eq_inter_halfspace\n\n",
 "convex":
 "protected theorem convex (hAB : is_exposed ğ•œ A B) (hA : convex ğ•œ A) : convex ğ•œ B :=\n  by\n  obtain rfl | hB := B.eq_empty_or_nonempty\n  Â· exact convex_empty\n  obtain âŸ¨l, rflâŸ© := hAB hB\n  exact fun xâ‚ hxâ‚ xâ‚‚ hxâ‚‚ a b ha hb hab =>\n    âŸ¨hA hxâ‚.1 hxâ‚‚.1 ha hb hab, fun y hy =>\n      ((l.to_linear_map.concave_on convex_univ).convex_ge _ âŸ¨mem_univ _, hxâ‚.2 y hyâŸ© âŸ¨mem_univ _, hxâ‚‚.2 y hyâŸ© ha hb\n          hab).2âŸ©\n#align convex convex\n\n",
 "antisymm":
 "#print antisymm /-\nprotected theorem antisymm (hB : is_exposed ğ•œ A B) (hA : is_exposed ğ•œ B A) : A = B :=\n  hA.subset.antisymm hB.subset\n#align antisymm antisymm\n-/\n\n"}