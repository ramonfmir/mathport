{"subset":
 "protected theorem subset (hAB : is_exposed 𝕜 A B) : B ⊆ A :=\n  by\n  rintro x hx\n  obtain ⟨_, rfl⟩ := hAB ⟨x, hx⟩\n  exact hx.1\n#align subset subset\n\n",
 "sInter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂₀ » -/\ntheorem sInter [has_continuous_add 𝕜] {F : Finset (set E)} (hF : F.nonempty) (hAF : ∀ B ∈ F, is_exposed 𝕜 A B) :\n    is_exposed 𝕜 A («expr⋂₀ » F) := by\n  revert hF F\n  refine' Finset.induction _ _\n  · rintro h\n    exfalso\n    exact not_nonempty_empty h\n  rintro C F _ hF _ hCF\n  rw [Finset.coe_insert, sInter_insert]\n  obtain rfl | hFnemp := F.eq_empty_or_nonempty\n  · rw [Finset.coe_empty, sInter_empty, inter_univ]\n    exact hCF C (Finset.mem_singleton_self C)\n  exact (hCF C (Finset.mem_insert_self C F)).inter (hF hFnemp fun B hB => hCF B (Finset.mem_insert_of_mem hB))\n#align sInter sInter\n\n",
 "refl":
 "#print refl /-\n@[refl]\nprotected theorem refl (A : set E) : is_exposed 𝕜 A A := fun ⟨w, hw⟩ =>\n  ⟨0, Subset.antisymm (fun x hx => ⟨hx, fun y hy => le_refl 0⟩) fun x hx => hx.1⟩\n#align refl refl\n-/\n\n",
 "mono":
 "/- `is_exposed` is *not* transitive: Consider a (topologically) open cube with vertices\n`A₀₀₀, ..., A₁₁₁` and add to it the triangle `A₀₀₀A₀₀₁A₀₁₀`. Then `A₀₀₁A₀₁₀` is an exposed subset\nof `A₀₀₀A₀₀₁A₀₁₀` which is an exposed subset of the cube, but `A₀₀₁A₀₁₀` is not itself an exposed\nsubset of the cube. -/\nprotected theorem mono (hC : is_exposed 𝕜 A C) (hBA : B ⊆ A) (hCB : C ⊆ B) : is_exposed 𝕜 B C :=\n  by\n  rintro ⟨w, hw⟩\n  obtain ⟨l, rfl⟩ := hC ⟨w, hw⟩\n  exact\n    ⟨l,\n      subset.antisymm (fun x hx => ⟨hCB hx, fun y hy => hx.2 y (hBA hy)⟩) fun x hx =>\n        ⟨hBA hx.1, fun y hy => (hw.2 y hy).trans (hx.2 w (hCB hw))⟩⟩\n#align mono mono\n\n",
 "mem_exposed_points_iff_exposed_singleton":
 "/-- Exposed points exactly correspond to exposed singletons. -/\ntheorem mem_exposed_points_iff_exposed_singleton : x ∈ A.exposed_points 𝕜 ↔ is_exposed 𝕜 A {x} :=\n  by\n  use fun ⟨hxA, l, hl⟩ h =>\n    ⟨l,\n      eq.symm <| eq_singleton_iff_unique_mem.2 ⟨⟨hxA, fun y hy => (hl y hy).1⟩, fun z hz => (hl z hz.1).2 (hz.2 x hxA)⟩⟩\n  rintro h\n  obtain ⟨l, hl⟩ := h ⟨x, mem_singleton _⟩\n  rw [eq_comm, eq_singleton_iff_unique_mem] at hl\n  exact ⟨hl.1.1, l, fun y hy => ⟨hl.1.2 y hy, fun hxy => hl.2 y ⟨hy, fun z hz => (hl.1.2 z hz).trans hxy⟩⟩⟩\n#align mem_exposed_points_iff_exposed_singleton mem_exposed_points_iff_exposed_singleton\n\n",
 "is_extreme":
 "protected theorem is_extreme (hAB : is_exposed 𝕜 A B) : is_extreme 𝕜 A B :=\n  by\n  refine' ⟨hAB.subset, fun x₁ hx₁A x₂ hx₂A x hxB hx => _⟩\n  obtain ⟨l, rfl⟩ := hAB ⟨x, hxB⟩\n  have hl : convex_on 𝕜 univ l := l.to_linear_map.convex_on convex_univ\n  have hlx₁ := hxB.2 x₁ hx₁A\n  have hlx₂ := hxB.2 x₂ hx₂A\n  refine' ⟨⟨hx₁A, fun y hy => _⟩, ⟨hx₂A, fun y hy => _⟩⟩\n  · have := @convex_on.le_left_of_right_le 𝕜 E 𝕜 _ _ _\n    rw [hlx₁.antisymm (hl.le_left_of_right_le (mem_univ _) (mem_univ _) hx hlx₂)]\n    exact hxB.2 y hy\n  · rw [hlx₂.antisymm (hl.le_right_of_left_le (mem_univ _) (mem_univ _) hx hlx₁)]\n    exact hxB.2 y hy\n#align is_extreme is_extreme\n\n",
 "is_exposed_empty":
 "theorem is_exposed_empty : is_exposed 𝕜 A ∅ := fun ⟨x, hx⟩ =>\n  by\n  exfalso\n  exact hx\n#align is_exposed_empty is_exposed_empty\n\n",
 "is_exposed":
 "/-\nCopyright (c) 2021 Yaël Dillies, Bhavik Mehta. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yaël Dillies, Bhavik Mehta\n-/\ntheorem continuous_linear_map.to_exposed.is_exposed : is_exposed 𝕜 A (l.to_exposed A) := fun h => ⟨l, rfl⟩\n#align continuous_linear_map.to_exposed.is_exposed continuous_linear_map.to_exposed.is_exposed\n\n",
 "is_compact":
 "protected theorem is_compact [order_closed_topology 𝕜] [t2_space E] {A B : set E} (hAB : is_exposed 𝕜 A B)\n    (hA : is_compact A) : is_compact B :=\n  is_compact_of_is_closed_subset hA (hAB.is_closed hA.is_closed) hAB.subset\n#align is_compact is_compact\n\n",
 "is_closed":
 "protected theorem is_closed [order_closed_topology 𝕜] {A B : set E} (hAB : is_exposed 𝕜 A B) (hA : is_closed A) :\n    is_closed B := by\n  obtain rfl | hB := B.eq_empty_or_nonempty\n  · simp\n  obtain ⟨l, a, rfl⟩ := hAB.eq_inter_halfspace' hB\n  exact hA.is_closed_le continuous_on_const l.continuous.continuous_on\n#align is_closed is_closed\n\n",
 "inter_right":
 "theorem inter_right (hC : is_exposed 𝕜 B C) (hCA : C ⊆ A) : is_exposed 𝕜 (A ∩ B) C :=\n  by\n  rw [inter_comm]\n  exact hC.inter_left hCA\n#align inter_right inter_right\n\n",
 "inter_left":
 "theorem inter_left (hC : is_exposed 𝕜 A C) (hCB : C ⊆ B) : is_exposed 𝕜 (A ∩ B) C :=\n  by\n  rintro ⟨w, hw⟩\n  obtain ⟨l, rfl⟩ := hC ⟨w, hw⟩\n  exact\n    ⟨l,\n      subset.antisymm (fun x hx => ⟨⟨hx.1, hCB hx⟩, fun y hy => hx.2 y hy.1⟩) fun x ⟨⟨hxC, _⟩, hx⟩ =>\n        ⟨hxC, fun y hy => (hw.2 y hy).trans (hx w ⟨hC.subset hw, hCB hw⟩)⟩⟩\n#align inter_left inter_left\n\n",
 "inter":
 "protected theorem inter [has_continuous_add 𝕜] {A B C : set E} (hB : is_exposed 𝕜 A B) (hC : is_exposed 𝕜 A C) :\n    is_exposed 𝕜 A (B ∩ C) := by\n  rintro ⟨w, hwB, hwC⟩\n  obtain ⟨l₁, rfl⟩ := hB ⟨w, hwB⟩\n  obtain ⟨l₂, rfl⟩ := hC ⟨w, hwC⟩\n  refine' ⟨l₁ + l₂, subset.antisymm _ _⟩\n  · rintro x ⟨⟨hxA, hxB⟩, ⟨-, hxC⟩⟩\n    exact ⟨hxA, fun z hz => add_le_add (hxB z hz) (hxC z hz)⟩\n  rintro x ⟨hxA, hx⟩\n  refine' ⟨⟨hxA, fun y hy => _⟩, hxA, fun y hy => _⟩\n  · exact (add_le_add_iff_right (l₂ x)).1 ((add_le_add (hwB.2 y hy) (hwC.2 x hxA)).trans (hx w hwB.1))\n  · exact (add_le_add_iff_left (l₁ x)).1 (le_trans (add_le_add (hwB.2 x hxA) (hwC.2 y hy)) (hx w hwB.1))\n#align inter inter\n\n",
 "exposed_points_subset_extreme_points":
 "theorem exposed_points_subset_extreme_points : A.exposed_points 𝕜 ⊆ A.extreme_points 𝕜 := fun x hx =>\n  mem_extreme_points_iff_extreme_singleton.2 (mem_exposed_points_iff_exposed_singleton.1 hx).is_extreme\n#align exposed_points_subset_extreme_points exposed_points_subset_extreme_points\n\n",
 "exposed_points_subset":
 "theorem exposed_points_subset : A.exposed_points 𝕜 ⊆ A := fun x hx => hx.1\n#align exposed_points_subset exposed_points_subset\n\n",
 "exposed_points_empty":
 "@[simp]\ntheorem exposed_points_empty : (∅ : set E).exposed_points 𝕜 = ∅ :=\n  subset_empty_iff.1 exposed_points_subset\n#align exposed_points_empty exposed_points_empty\n\n",
 "exposed_point_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\ntheorem exposed_point_def :\n    x ∈ A.exposed_points 𝕜 ↔ x ∈ A ∧ ∃ l : «expr →L[ ] » E 𝕜 𝕜, ∀ y ∈ A, l y ≤ l x ∧ (l x ≤ l y → y = x) :=\n  iff.rfl\n#align exposed_point_def exposed_point_def\n\n",
 "eq_inter_halfspace'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/-- If `B` is a nonempty exposed subset of `A`, then `B` is the intersection of `A` with some closed\nhalfspace. The converse is *not* true. It would require that the corresponding open halfspace\ndoesn't intersect `A`. -/\ntheorem eq_inter_halfspace' {A B : set E} (hAB : is_exposed 𝕜 A B) (hB : B.nonempty) :\n    ∃ l : «expr →L[ ] » E 𝕜 𝕜, ∃ a, B = { x ∈ A | a ≤ l x } :=\n  by\n  obtain ⟨l, rfl⟩ := hAB hB\n  obtain ⟨w, hw⟩ := hB\n  exact\n    ⟨l, l w, subset.antisymm (fun x hx => ⟨hx.1, hx.2 w hw.1⟩) fun x hx => ⟨hx.1, fun y hy => (hw.2 y hy).trans hx.2⟩⟩\n#align eq_inter_halfspace' eq_inter_halfspace'\n\n",
 "eq_inter_halfspace":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/-- For nontrivial `𝕜`, if `B` is an exposed subset of `A`, then `B` is the intersection of `A` with\nsome closed halfspace. The converse is *not* true. It would require that the corresponding open\nhalfspace doesn't intersect `A`. -/\ntheorem eq_inter_halfspace [nontrivial 𝕜] {A B : set E} (hAB : is_exposed 𝕜 A B) :\n    ∃ l : «expr →L[ ] » E 𝕜 𝕜, ∃ a, B = { x ∈ A | a ≤ l x } :=\n  by\n  obtain rfl | hB := B.eq_empty_or_nonempty\n  · refine' ⟨0, 1, _⟩\n    rw [eq_comm, eq_empty_iff_forall_not_mem]\n    rintro x ⟨-, h⟩\n    rw [continuous_linear_map.zero_apply] at h\n    have : ¬(1 : 𝕜) ≤ 0 := not_le_of_lt zero_lt_one\n    contradiction\n  exact hAB.eq_inter_halfspace' hB\n#align eq_inter_halfspace eq_inter_halfspace\n\n",
 "convex":
 "protected theorem convex (hAB : is_exposed 𝕜 A B) (hA : convex 𝕜 A) : convex 𝕜 B :=\n  by\n  obtain rfl | hB := B.eq_empty_or_nonempty\n  · exact convex_empty\n  obtain ⟨l, rfl⟩ := hAB hB\n  exact fun x₁ hx₁ x₂ hx₂ a b ha hb hab =>\n    ⟨hA hx₁.1 hx₂.1 ha hb hab, fun y hy =>\n      ((l.to_linear_map.concave_on convex_univ).convex_ge _ ⟨mem_univ _, hx₁.2 y hy⟩ ⟨mem_univ _, hx₂.2 y hy⟩ ha hb\n          hab).2⟩\n#align convex convex\n\n",
 "antisymm":
 "#print antisymm /-\nprotected theorem antisymm (hB : is_exposed 𝕜 A B) (hA : is_exposed 𝕜 B A) : A = B :=\n  hA.subset.antisymm hB.subset\n#align antisymm antisymm\n-/\n\n"}