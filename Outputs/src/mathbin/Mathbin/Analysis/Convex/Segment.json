{"vadd_segment":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr +áµ¥ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `segment -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `segment -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr +áµ¥ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr +áµ¥ Â» -/\n#print vadd_segment /-\n@[simp]\ntheorem vadd_segment [AddTorsor G E] [VAddCommClass G E E] (a : G) (b c : E) :\n    Â«expr +áµ¥ Â» a (segment b ğ•œ c) = segment (Â«expr +áµ¥ Â» a b) ğ•œ (Â«expr +áµ¥ Â» a c) :=\n  image_segment ğ•œ âŸ¨_, LinearMap.id, fun _ _ => vadd_comm _ _ _âŸ© b c\n#align vadd_segment vadd_segment\n-/\n\n",
 "vadd_openSegment":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr +áµ¥ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr +áµ¥ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr +áµ¥ Â» -/\n#print vadd_openSegment /-\n@[simp]\ntheorem vadd_openSegment [AddTorsor G E] [VAddCommClass G E E] (a : G) (b c : E) :\n    Â«expr +áµ¥ Â» a (openSegment ğ•œ b c) = openSegment ğ•œ (Â«expr +áµ¥ Â» a b) (Â«expr +áµ¥ Â» a c) :=\n  image_openSegment ğ•œ âŸ¨_, LinearMap.id, fun _ _ => vadd_comm _ _ _âŸ© b c\n#align vadd_open_segment vadd_openSegment\n-/\n\n",
 "segment_translate_preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `segment -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `segment -/\n#print segment_translate_preimage /-\ntheorem segment_translate_preimage (a b c : E) :\n    Â«expr â»Â¹' Â» (fun x => a + x) (segment (a + b) ğ•œ (a + c)) = segment b ğ•œ c :=\n  Set.ext fun x => mem_segment_translate ğ•œ a\n#align segment_translate_preimage segment_translate_preimage\n-/\n\n",
 "segment_translate_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `segment -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `segment -/\n#print segment_translate_image /-\ntheorem segment_translate_image (a b c : E) : Â«expr '' Â» (fun x => a + x) (segment b ğ•œ c) = segment (a + b) ğ•œ (a + c) :=\n  segment_translate_preimage ğ•œ a b c â–¸ image_preimage_eq _ <| add_left_surjective a\n#align segment_translate_image segment_translate_image\n-/\n\n",
 "segment_symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `segment -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `segment -/\n#print segment_symm /-\ntheorem segment_symm (x y : E) : segment x ğ•œ y = segment y ğ•œ x :=\n  Set.ext fun z =>\n    âŸ¨fun âŸ¨a, b, ha, hb, hab, HâŸ© => âŸ¨b, a, hb, ha, (add_comm _ _).trans hab, (add_comm _ _).trans HâŸ©,\n      fun âŸ¨a, b, ha, hb, hab, HâŸ© => âŸ¨b, a, hb, ha, (add_comm _ _).trans hab, (add_comm _ _).trans HâŸ©âŸ©\n#align segment_symm segment_symm\n-/\n\n",
 "segment_subset_uIcc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `segment -/\n#print segment_subset_uIcc /-\ntheorem segment_subset_uIcc (x y : E) : segment x ğ•œ y âŠ† uIcc x y :=\n  by\n  cases le_total x y\n  Â· rw [uIcc_of_le h]\n    exact segment_subset_Icc h\n  Â· rw [uIcc_of_ge h, segment_symm]\n    exact segment_subset_Icc h\n#align segment_subset_uIcc segment_subset_uIcc\n-/\n\n",
 "segment_subset_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `segment -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n#print segment_subset_iff /-\ntheorem segment_subset_iff :\n    segment x ğ•œ y âŠ† s â†” âˆ€ a b : ğ•œ, 0 â‰¤ a â†’ 0 â‰¤ b â†’ a + b = 1 â†’ Â«expr â€¢ Â» a x + Â«expr â€¢ Â» b y âˆˆ s :=\n  âŸ¨fun H a b ha hb hab => H âŸ¨a, b, ha, hb, hab, rflâŸ©, fun H z âŸ¨a, b, ha, hb, hab, hzâŸ© => hz â–¸ H a b ha hb habâŸ©\n#align segment_subset_iff segment_subset_iff\n-/\n\n",
 "segment_subset_Icc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `segment -/\n#print segment_subset_Icc /-\ntheorem segment_subset_Icc (h : x â‰¤ y) : segment x ğ•œ y âŠ† Icc x y :=\n  by\n  rintro z âŸ¨a, b, ha, hb, hab, rflâŸ©\n  constructor\n  calc\n    x = Â«expr â€¢ Â» a x + Â«expr â€¢ Â» b x := (Convex.combo_self hab _).symm\n    _ â‰¤ Â«expr â€¢ Â» a x + Â«expr â€¢ Â» b y := add_le_add_left (smul_le_smul_of_nonneg h hb) _\n    \n  calc\n    Â«expr â€¢ Â» a x + Â«expr â€¢ Â» b y â‰¤ Â«expr â€¢ Â» a y + Â«expr â€¢ Â» b y := add_le_add_right (smul_le_smul_of_nonneg h ha) _\n    _ = y := Convex.combo_self hab _\n    \n#align segment_subset_Icc segment_subset_Icc\n-/\n\n",
 "segment_subset":
 "theorem segment_subset (x y : âˆ€ i, Ï€ i) : segment ğ•œ x y âŠ† s.pi fun i => segment ğ•œ (x i) (y i) :=\n  by\n  rintro z âŸ¨a, b, ha, hb, hab, hzâŸ© i -\n  exact âŸ¨a, b, ha, hb, hab, congr_fun hz iâŸ©\n#align segment_subset segment_subset\n\n",
 "segment_same":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `segment -/\n#print segment_same /-\n@[simp]\ntheorem segment_same (x : E) : segment x ğ•œ x = {x} :=\n  Set.ext fun z =>\n    âŸ¨fun âŸ¨a, b, ha, hb, hab, hzâŸ© => by\n      simpa only [(add_smul _ _ _).symm, mem_singleton_iff, hab, one_smul, eq_comm] using hz, fun h =>\n      mem_singleton_iff.1 h â–¸ left_mem_segment ğ•œ z zâŸ©\n#align segment_same segment_same\n-/\n\n",
 "segment_eq_uIcc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `segment -/\n#print segment_eq_uIcc /-\ntheorem segment_eq_uIcc (x y : ğ•œ) : segment x ğ•œ y = uIcc x y :=\n  segment_eq_Icc' _ _\n#align segment_eq_uIcc segment_eq_uIcc\n-/\n\n",
 "segment_eq_imageâ‚‚":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `segment -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n#print segment_eq_imageâ‚‚ /-\n/-\nCopyright (c) 2019 Alexander Bentkamp. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Alexander Bentkamp, Yury Kudryashov, YaÃ«l Dillies\n-/\ntheorem segment_eq_imageâ‚‚ (x y : E) :\n    segment x ğ•œ y =\n      Â«expr '' Â» (fun p : ğ•œ Ã— ğ•œ => Â«expr â€¢ Â» p.1 x + Â«expr â€¢ Â» p.2 y) { p | 0 â‰¤ p.1 âˆ§ 0 â‰¤ p.2 âˆ§ p.1 + p.2 = 1 } :=\n  by simp only [segment, image, Prod.exists, mem_set_of_eq, exists_prop, and_assoc']\n#align segment_eq_imageâ‚‚ segment_eq_imageâ‚‚\n-/\n\n",
 "segment_eq_image_lineMap":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `segment -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n#print segment_eq_image_lineMap /-\ntheorem segment_eq_image_lineMap (x y : E) : segment x ğ•œ y = Â«expr '' Â» (AffineMap.lineMap x y) (Icc (0 : ğ•œ) 1) :=\n  by\n  convert segment_eq_image ğ•œ x y\n  ext\n  exact AffineMap.lineMap_apply_module _ _ _\n#align segment_eq_image_line_map segment_eq_image_lineMap\n-/\n\n",
 "segment_eq_image'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `segment -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n#print segment_eq_image' /-\ntheorem segment_eq_image' (x y : E) :\n    segment x ğ•œ y = Â«expr '' Â» (fun Î¸ : ğ•œ => x + Â«expr â€¢ Â» Î¸ (y - x)) (Icc (0 : ğ•œ) 1) :=\n  by\n  convert segment_eq_image ğ•œ x y\n  ext Î¸\n  simp only [smul_sub, sub_smul, one_smul]\n  abel\n#align segment_eq_image' segment_eq_image'\n-/\n\n",
 "segment_eq_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `segment -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n#print segment_eq_image /-\ntheorem segment_eq_image (x y : E) :\n    segment x ğ•œ y = Â«expr '' Â» (fun Î¸ : ğ•œ => Â«expr â€¢ Â» (1 - Î¸) x + Â«expr â€¢ Â» Î¸ y) (Icc (0 : ğ•œ) 1) :=\n  Set.ext fun z =>\n    âŸ¨fun âŸ¨a, b, ha, hb, hab, hzâŸ© => âŸ¨b, âŸ¨hb, hab â–¸ le_add_of_nonneg_left haâŸ©, hab â–¸ hz â–¸ by simp only [add_sub_cancel]âŸ©,\n      fun âŸ¨Î¸, âŸ¨hÎ¸â‚€, hÎ¸â‚âŸ©, hzâŸ© => âŸ¨1 - Î¸, Î¸, sub_nonneg.2 hÎ¸â‚, hÎ¸â‚€, sub_add_cancel _ _, hzâŸ©âŸ©\n#align segment_eq_image segment_eq_image\n-/\n\n",
 "segment_eq_Icc'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `segment -/\n#print segment_eq_Icc' /-\ntheorem segment_eq_Icc' (x y : ğ•œ) : segment x ğ•œ y = Icc (min x y) (max x y) :=\n  by\n  cases le_total x y\n  Â· rw [segment_eq_Icc h, max_eq_right h, min_eq_left h]\n  Â· rw [segment_symm, segment_eq_Icc h, max_eq_left h, min_eq_right h]\n#align segment_eq_Icc' segment_eq_Icc'\n-/\n\n",
 "segment_eq_Icc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `segment -/\n#print segment_eq_Icc /-\n@[simp]\ntheorem segment_eq_Icc (h : x â‰¤ y) : segment x ğ•œ y = Icc x y :=\n  (segment_subset_Icc h).antisymm Icc_subset_segment\n#align segment_eq_Icc segment_eq_Icc\n-/\n\n",
 "sameRay_of_mem_segment":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `segment -/\n#print sameRay_of_mem_segment /-\ntheorem sameRay_of_mem_segment [StrictOrderedCommRing ğ•œ] [AddCommGroup E] [Module ğ•œ E] {x y z : E}\n    (h : x âˆˆ segment y ğ•œ z) : SameRay ğ•œ (x - y) (z - x) :=\n  by\n  rw [segment_eq_image'] at h\n  rcases h with âŸ¨Î¸, âŸ¨hÎ¸â‚€, hÎ¸â‚âŸ©, rflâŸ©\n  simpa only [add_sub_cancel', â† sub_sub, sub_smul, one_smul] using\n    (SameRay.sameRay_nonneg_smul_left (z - y) hÎ¸â‚€).nonneg_smul_right (sub_nonneg.2 hÎ¸â‚)\n#align same_ray_of_mem_segment sameRay_of_mem_segment\n-/\n\n",
 "right_mem_segment":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `segment -/\n#print right_mem_segment /-\ntheorem right_mem_segment (x y : E) : y âˆˆ segment x ğ•œ y :=\n  segment_symm ğ•œ y x â–¸ left_mem_segment ğ•œ y x\n#align right_mem_segment right_mem_segment\n-/\n\n",
 "right_mem_openSegment_iff":
 "#print right_mem_openSegment_iff /-\n@[simp]\ntheorem right_mem_openSegment_iff [DenselyOrdered ğ•œ] [NoZeroSMulDivisors ğ•œ E] : y âˆˆ openSegment ğ•œ x y â†” x = y := by\n  rw [openSegment_symm, left_mem_openSegment_iff, eq_comm]\n#align right_mem_open_segment_iff right_mem_openSegment_iff\n-/\n\n",
 "open_segment_subset":
 "theorem open_segment_subset (x y : âˆ€ i, Ï€ i) : openSegment ğ•œ x y âŠ† s.pi fun i => openSegment ğ•œ (x i) (y i) :=\n  by\n  rintro z âŸ¨a, b, ha, hb, hab, hzâŸ© i -\n  exact âŸ¨a, b, ha, hb, hab, congr_fun hz iâŸ©\n#align open_segment_subset open_segment_subset\n\n",
 "openSegment_translate_preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n#print openSegment_translate_preimage /-\ntheorem openSegment_translate_preimage (a b c : E) :\n    Â«expr â»Â¹' Â» (fun x => a + x) (openSegment ğ•œ (a + b) (a + c)) = openSegment ğ•œ b c :=\n  Set.ext fun x => mem_openSegment_translate ğ•œ a\n#align open_segment_translate_preimage openSegment_translate_preimage\n-/\n\n",
 "openSegment_translate_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n#print openSegment_translate_image /-\ntheorem openSegment_translate_image (a b c : E) :\n    Â«expr '' Â» (fun x => a + x) (openSegment ğ•œ b c) = openSegment ğ•œ (a + b) (a + c) :=\n  openSegment_translate_preimage ğ•œ a b c â–¸ image_preimage_eq _ <| add_left_surjective a\n#align open_segment_translate_image openSegment_translate_image\n-/\n\n",
 "openSegment_symm":
 "#print openSegment_symm /-\ntheorem openSegment_symm (x y : E) : openSegment ğ•œ x y = openSegment ğ•œ y x :=\n  Set.ext fun z =>\n    âŸ¨fun âŸ¨a, b, ha, hb, hab, HâŸ© => âŸ¨b, a, hb, ha, (add_comm _ _).trans hab, (add_comm _ _).trans HâŸ©,\n      fun âŸ¨a, b, ha, hb, hab, HâŸ© => âŸ¨b, a, hb, ha, (add_comm _ _).trans hab, (add_comm _ _).trans HâŸ©âŸ©\n#align open_segment_symm openSegment_symm\n-/\n\n",
 "openSegment_subset_union":
 "#print openSegment_subset_union /-\n/-- If `z = line_map x y c` is a point on the line passing through `x` and `y`, then the open\nsegment `open_segment ğ•œ x y` is included in the union of the open segments `open_segment ğ•œ x z`,\n`open_segment ğ•œ z y`, and the point `z`. Informally, `(x, y) âŠ† {z} âˆª (x, z) âˆª (z, y)`. -/\ntheorem openSegment_subset_union (x y : E) {z : E} (hz : z âˆˆ range (lineMap x y : ğ•œ â†’ E)) :\n    openSegment ğ•œ x y âŠ† insert z (openSegment ğ•œ x z âˆª openSegment ğ•œ z y) :=\n  by\n  rcases hz with âŸ¨c, rflâŸ©\n  simp only [openSegment_eq_image_lineMap, â† maps_to']\n  rintro a âŸ¨hâ‚€, hâ‚âŸ©\n  rcases lt_trichotomy a c with (hac | rfl | hca)\n  Â· right\n    left\n    have hc : 0 < c := hâ‚€.trans hac\n    refine' âŸ¨a / c, âŸ¨div_pos hâ‚€ hc, (div_lt_one hc).2 hacâŸ©, _âŸ©\n    simp only [â† homothety_eq_line_map, â† homothety_mul_apply, div_mul_cancel _ hc.ne']\n  Â· left\n    rfl\n  Â· right\n    right\n    have hc : 0 < 1 - c := sub_pos.2 (hca.trans hâ‚)\n    simp only [â† line_map_apply_one_sub y]\n    refine' âŸ¨(a - c) / (1 - c), âŸ¨div_pos (sub_pos.2 hca) hc, (div_lt_one hc).2 <| sub_lt_sub_right hâ‚ _âŸ©, _âŸ©\n    simp only [â† homothety_eq_line_map, â† homothety_mul_apply, sub_mul, one_mul, div_mul_cancel _ hc.ne',\n      sub_sub_sub_cancel_right]\n#align open_segment_subset_union openSegment_subset_union\n-/\n\n",
 "openSegment_subset_segment":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `segment -/\n#print openSegment_subset_segment /-\ntheorem openSegment_subset_segment (x y : E) : openSegment ğ•œ x y âŠ† segment x ğ•œ y := fun z âŸ¨a, b, ha, hb, hab, hzâŸ© =>\n  âŸ¨a, b, ha.le, hb.le, hab, hzâŸ©\n#align open_segment_subset_segment openSegment_subset_segment\n-/\n\n",
 "openSegment_subset_iff_segment_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `segment -/\n#print openSegment_subset_iff_segment_subset /-\ntheorem openSegment_subset_iff_segment_subset (hx : x âˆˆ s) (hy : y âˆˆ s) : openSegment ğ•œ x y âŠ† s â†” segment x ğ•œ y âŠ† s :=\n  by simp only [â† insert_endpoints_openSegment, insert_subset, *, true_and_iff]\n#align open_segment_subset_iff_segment_subset openSegment_subset_iff_segment_subset\n-/\n\n",
 "openSegment_subset_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n#print openSegment_subset_iff /-\ntheorem openSegment_subset_iff :\n    openSegment ğ•œ x y âŠ† s â†” âˆ€ a b : ğ•œ, 0 < a â†’ 0 < b â†’ a + b = 1 â†’ Â«expr â€¢ Â» a x + Â«expr â€¢ Â» b y âˆˆ s :=\n  âŸ¨fun H a b ha hb hab => H âŸ¨a, b, ha, hb, hab, rflâŸ©, fun H z âŸ¨a, b, ha, hb, hab, hzâŸ© => hz â–¸ H a b ha hb habâŸ©\n#align open_segment_subset_iff openSegment_subset_iff\n-/\n\n",
 "openSegment_subset_Ioo":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n#print openSegment_subset_Ioo /-\ntheorem openSegment_subset_Ioo (h : x < y) : openSegment ğ•œ x y âŠ† Ioo x y :=\n  by\n  rintro z âŸ¨a, b, ha, hb, hab, rflâŸ©\n  constructor\n  calc\n    x = Â«expr â€¢ Â» a x + Â«expr â€¢ Â» b x := (Convex.combo_self hab _).symm\n    _ < Â«expr â€¢ Â» a x + Â«expr â€¢ Â» b y := add_lt_add_left (smul_lt_smul_of_pos h hb) _\n    \n  calc\n    Â«expr â€¢ Â» a x + Â«expr â€¢ Â» b y < Â«expr â€¢ Â» a y + Â«expr â€¢ Â» b y := add_lt_add_right (smul_lt_smul_of_pos h ha) _\n    _ = y := Convex.combo_self hab _\n    \n#align open_segment_subset_Ioo openSegment_subset_Ioo\n-/\n\n",
 "openSegment_same":
 "#print openSegment_same /-\n@[simp]\ntheorem openSegment_same (x : E) : openSegment ğ•œ x x = {x} :=\n  Set.ext fun z =>\n    âŸ¨fun âŸ¨a, b, ha, hb, hab, hzâŸ© => by simpa only [â† add_smul, mem_singleton_iff, hab, one_smul, eq_comm] using hz,\n      fun h : z = x => by\n      obtain âŸ¨a, haâ‚€, haâ‚âŸ© := densely_ordered.dense (0 : ğ•œ) 1 zero_lt_one\n      refine' âŸ¨a, 1 - a, haâ‚€, sub_pos_of_lt haâ‚, add_sub_cancel'_right _ _, _âŸ©\n      rw [â† add_smul, add_sub_cancel'_right, one_smul, h]âŸ©\n#align open_segment_same openSegment_same\n-/\n\n",
 "openSegment_eq_imageâ‚‚":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n#print openSegment_eq_imageâ‚‚ /-\ntheorem openSegment_eq_imageâ‚‚ (x y : E) :\n    openSegment ğ•œ x y =\n      Â«expr '' Â» (fun p : ğ•œ Ã— ğ•œ => Â«expr â€¢ Â» p.1 x + Â«expr â€¢ Â» p.2 y) { p | 0 < p.1 âˆ§ 0 < p.2 âˆ§ p.1 + p.2 = 1 } :=\n  by simp only [openSegment, image, Prod.exists, mem_set_of_eq, exists_prop, and_assoc']\n#align open_segment_eq_imageâ‚‚ openSegment_eq_imageâ‚‚\n-/\n\n",
 "openSegment_eq_image_lineMap":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n#print openSegment_eq_image_lineMap /-\ntheorem openSegment_eq_image_lineMap (x y : E) :\n    openSegment ğ•œ x y = Â«expr '' Â» (AffineMap.lineMap x y) (Ioo (0 : ğ•œ) 1) :=\n  by\n  convert openSegment_eq_image ğ•œ x y\n  ext\n  exact AffineMap.lineMap_apply_module _ _ _\n#align open_segment_eq_image_line_map openSegment_eq_image_lineMap\n-/\n\n",
 "openSegment_eq_image'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n#print openSegment_eq_image' /-\ntheorem openSegment_eq_image' (x y : E) :\n    openSegment ğ•œ x y = Â«expr '' Â» (fun Î¸ : ğ•œ => x + Â«expr â€¢ Â» Î¸ (y - x)) (Ioo (0 : ğ•œ) 1) :=\n  by\n  convert openSegment_eq_image ğ•œ x y\n  ext Î¸\n  simp only [smul_sub, sub_smul, one_smul]\n  abel\n#align open_segment_eq_image' openSegment_eq_image'\n-/\n\n",
 "openSegment_eq_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n#print openSegment_eq_image /-\ntheorem openSegment_eq_image (x y : E) :\n    openSegment ğ•œ x y = Â«expr '' Â» (fun Î¸ : ğ•œ => Â«expr â€¢ Â» (1 - Î¸) x + Â«expr â€¢ Â» Î¸ y) (Ioo (0 : ğ•œ) 1) :=\n  Set.ext fun z =>\n    âŸ¨fun âŸ¨a, b, ha, hb, hab, hzâŸ© => âŸ¨b, âŸ¨hb, hab â–¸ lt_add_of_pos_left _ haâŸ©, hab â–¸ hz â–¸ by simp only [add_sub_cancel]âŸ©,\n      fun âŸ¨Î¸, âŸ¨hÎ¸â‚€, hÎ¸â‚âŸ©, hzâŸ© => âŸ¨1 - Î¸, Î¸, sub_pos.2 hÎ¸â‚, hÎ¸â‚€, sub_add_cancel _ _, hzâŸ©âŸ©\n#align open_segment_eq_image openSegment_eq_image\n-/\n\n",
 "openSegment_eq_Ioo'":
 "#print openSegment_eq_Ioo' /-\ntheorem openSegment_eq_Ioo' (hxy : x â‰  y) : openSegment ğ•œ x y = Ioo (min x y) (max x y) :=\n  by\n  cases hxy.lt_or_lt\n  Â· rw [openSegment_eq_Ioo h, max_eq_right h.le, min_eq_left h.le]\n  Â· rw [openSegment_symm, openSegment_eq_Ioo h, max_eq_left h.le, min_eq_right h.le]\n#align open_segment_eq_Ioo' openSegment_eq_Ioo'\n-/\n\n",
 "openSegment_eq_Ioo":
 "#print openSegment_eq_Ioo /-\n@[simp]\ntheorem openSegment_eq_Ioo (h : x < y) : openSegment ğ•œ x y = Ioo x y :=\n  (openSegment_subset_Ioo h).antisymm Ioo_subset_openSegment\n#align open_segment_eq_Ioo openSegment_eq_Ioo\n-/\n\n",
 "min_le_combo":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n#print Convex.min_le_combo /-\ntheorem Convex.min_le_combo (x y : E) (ha : 0 â‰¤ a) (hb : 0 â‰¤ b) (hab : a + b = 1) :\n    min x y â‰¤ Â«expr â€¢ Â» a x + Â«expr â€¢ Â» b y :=\n  (segment_subset_uIcc x y âŸ¨_, _, ha, hb, hab, rflâŸ©).1\n#align convex.min_le_combo Convex.min_le_combo\n-/\n\n",
 "midpoint_mem_segment":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ…ŸÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `segment -/\n#print midpoint_mem_segment /-\ntheorem midpoint_mem_segment [Invertible (2 : ğ•œ)] (x y : E) : midpoint ğ•œ x y âˆˆ segment x ğ•œ y :=\n  by\n  rw [segment_eq_image_lineMap]\n  exact âŸ¨(Â«exprâ…ŸÂ») 2, âŸ¨inv_of_nonneg.mpr zero_le_two, invOf_le_one one_le_twoâŸ©, rflâŸ©\n#align midpoint_mem_segment midpoint_mem_segment\n-/\n\n",
 "mem_segment_translate":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `segment -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `segment -/\n#print mem_segment_translate /-\n@[simp]\ntheorem mem_segment_translate (a : E) {x b c} : a + x âˆˆ segment (a + b) ğ•œ (a + c) â†” x âˆˆ segment b ğ•œ c := by\n  simp_rw [â† vadd_eq_add, â† vadd_segment, vadd_mem_vadd_set_iff]\n#align mem_segment_translate mem_segment_translate\n-/\n\n",
 "mem_segment_sub_add":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `segment -/\n#print mem_segment_sub_add /-\ntheorem mem_segment_sub_add [Invertible (2 : ğ•œ)] (x y : E) : x âˆˆ segment (x - y) ğ•œ (x + y) :=\n  by\n  convert@midpoint_mem_segment ğ•œ _ _ _ _ _ _ _\n  rw [midpoint_sub_add]\n#align mem_segment_sub_add mem_segment_sub_add\n-/\n\n",
 "mem_segment_iff_sameRay":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `segment -/\n#print mem_segment_iff_sameRay /-\ntheorem mem_segment_iff_sameRay : x âˆˆ segment y ğ•œ z â†” SameRay ğ•œ (x - y) (z - x) :=\n  by\n  refine' âŸ¨sameRay_of_mem_segment, fun h => _âŸ©\n  rcases h.exists_eq_smul_add with âŸ¨a, b, ha, hb, hab, hxy, hzxâŸ©\n  rw [add_comm, sub_add_sub_cancel] at hxy hzx\n  rw [â† mem_segment_translate _ (-x), neg_add_self]\n  refine' âŸ¨b, a, hb, ha, add_comm a b â–¸ hab, _âŸ©\n  rw [â† sub_eq_neg_add, â† neg_sub, hxy, â† sub_eq_neg_add, hzx, smul_neg, smul_comm, neg_add_self]\n#align mem_segment_iff_same_ray mem_segment_iff_sameRay\n-/\n\n",
 "mem_segment_iff_div":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `segment -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n#print mem_segment_iff_div /-\ntheorem mem_segment_iff_div :\n    x âˆˆ segment y ğ•œ z â†”\n      âˆƒ a b : ğ•œ, 0 â‰¤ a âˆ§ 0 â‰¤ b âˆ§ 0 < a + b âˆ§ Â«expr â€¢ Â» (a / (a + b)) y + Â«expr â€¢ Â» (b / (a + b)) z = x :=\n  by\n  constructor\n  Â· rintro âŸ¨a, b, ha, hb, hab, rflâŸ©\n    use a, b, ha, hb\n    simp [*]\n  Â· rintro âŸ¨a, b, ha, hb, hab, rflâŸ©\n    refine' âŸ¨a / (a + b), b / (a + b), div_nonneg ha hab.le, div_nonneg hb hab.le, _, rflâŸ©\n    rw [â† add_div, div_self hab.ne']\n#align mem_segment_iff_div mem_segment_iff_div\n-/\n\n",
 "mem_segment_add_sub":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `segment -/\n#print mem_segment_add_sub /-\ntheorem mem_segment_add_sub [Invertible (2 : ğ•œ)] (x y : E) : x âˆˆ segment (x + y) ğ•œ (x - y) :=\n  by\n  convert@midpoint_mem_segment ğ•œ _ _ _ _ _ _ _\n  rw [midpoint_add_sub]\n#align mem_segment_add_sub mem_segment_add_sub\n-/\n\n",
 "mem_openSegment_translate":
 "#print mem_openSegment_translate /-\n@[simp]\ntheorem mem_openSegment_translate (a : E) {x b c : E} : a + x âˆˆ openSegment ğ•œ (a + b) (a + c) â†” x âˆˆ openSegment ğ•œ b c :=\n  by simp_rw [â† vadd_eq_add, â† vadd_openSegment, vadd_mem_vadd_set_iff]\n#align mem_open_segment_translate mem_openSegment_translate\n-/\n\n",
 "mem_openSegment_of_ne_left_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `segment -/\n#print mem_openSegment_of_ne_left_right /-\ntheorem mem_openSegment_of_ne_left_right (hx : x â‰  z) (hy : y â‰  z) (hz : z âˆˆ segment x ğ•œ y) : z âˆˆ openSegment ğ•œ x y :=\n  by\n  rw [â† insert_endpoints_openSegment] at hz\n  exact (hz.resolve_left hx.symm).resolve_left hy.symm\n#align mem_open_segment_of_ne_left_right mem_openSegment_of_ne_left_right\n-/\n\n",
 "mem_openSegment_iff_div":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n#print mem_openSegment_iff_div /-\ntheorem mem_openSegment_iff_div :\n    x âˆˆ openSegment ğ•œ y z â†” âˆƒ a b : ğ•œ, 0 < a âˆ§ 0 < b âˆ§ Â«expr â€¢ Â» (a / (a + b)) y + Â«expr â€¢ Â» (b / (a + b)) z = x :=\n  by\n  constructor\n  Â· rintro âŸ¨a, b, ha, hb, hab, rflâŸ©\n    use a, b, ha, hb\n    rw [hab, div_one, div_one]\n  Â· rintro âŸ¨a, b, ha, hb, rflâŸ©\n    have hab : 0 < a + b := by positivity\n    refine' âŸ¨a / (a + b), b / (a + b), by positivity, by positivity, _, rflâŸ©\n    rw [â† add_div, div_self hab.ne']\n#align mem_open_segment_iff_div mem_openSegment_iff_div\n-/\n\n",
 "mem_Ioo":
 "#print Convex.mem_Ioo /-\n/-- A point is in an `Ioo` iff it can be expressed as a strict convex combination of the endpoints.\n-/\ntheorem Convex.mem_Ioo (h : x < y) : z âˆˆ Ioo x y â†” âˆƒ a b, 0 < a âˆ§ 0 < b âˆ§ a + b = 1 âˆ§ a * x + b * y = z :=\n  by\n  rw [â† openSegment_eq_Ioo h]\n  simp_rw [â† exists_prop]\n  rfl\n#align convex.mem_Ioo Convex.mem_Ioo\n-/\n\n",
 "mem_Ioc":
 "#print Convex.mem_Ioc /-\n/-- A point is in an `Ioc` iff it can be expressed as a semistrict convex combination of the\nendpoints. -/\ntheorem Convex.mem_Ioc (h : x < y) : z âˆˆ Ioc x y â†” âˆƒ a b, 0 â‰¤ a âˆ§ 0 < b âˆ§ a + b = 1 âˆ§ a * x + b * y = z :=\n  by\n  refine' âŸ¨fun hz => _, _âŸ©\n  Â· obtain âŸ¨a, b, ha, hb, hab, rflâŸ© := (Convex.mem_Icc h.le).1 (Ioc_subset_Icc_self hz)\n    obtain rfl | hb' := hb.eq_or_lt\n    Â· rw [add_zero] at hab\n      rw [hab, one_mul, MulZeroClass.zero_mul, add_zero] at hz\n      exact (hz.1.ne rfl).elim\n    Â· exact âŸ¨a, b, ha, hb', hab, rflâŸ©\n  Â· rintro âŸ¨a, b, ha, hb, hab, rflâŸ©\n    obtain rfl | ha' := ha.eq_or_lt\n    Â· rw [zero_add] at hab\n      rwa [hab, one_mul, MulZeroClass.zero_mul, zero_add, right_mem_Ioc]\n    Â· exact Ioo_subset_Ioc_self ((Convex.mem_Ioo h).2 âŸ¨a, b, ha', hb, hab, rflâŸ©)\n#align convex.mem_Ioc Convex.mem_Ioc\n-/\n\n",
 "mem_Ico":
 "#print Convex.mem_Ico /-\n/-- A point is in an `Ico` iff it can be expressed as a semistrict convex combination of the\nendpoints. -/\ntheorem Convex.mem_Ico (h : x < y) : z âˆˆ Ico x y â†” âˆƒ a b, 0 < a âˆ§ 0 â‰¤ b âˆ§ a + b = 1 âˆ§ a * x + b * y = z :=\n  by\n  refine' âŸ¨fun hz => _, _âŸ©\n  Â· obtain âŸ¨a, b, ha, hb, hab, rflâŸ© := (Convex.mem_Icc h.le).1 (Ico_subset_Icc_self hz)\n    obtain rfl | ha' := ha.eq_or_lt\n    Â· rw [zero_add] at hab\n      rw [hab, one_mul, MulZeroClass.zero_mul, zero_add] at hz\n      exact (hz.2.ne rfl).elim\n    Â· exact âŸ¨a, b, ha', hb, hab, rflâŸ©\n  Â· rintro âŸ¨a, b, ha, hb, hab, rflâŸ©\n    obtain rfl | hb' := hb.eq_or_lt\n    Â· rw [add_zero] at hab\n      rwa [hab, one_mul, MulZeroClass.zero_mul, add_zero, left_mem_Ico]\n    Â· exact Ioo_subset_Ico_self ((Convex.mem_Ioo h).2 âŸ¨a, b, ha, hb', hab, rflâŸ©)\n#align convex.mem_Ico Convex.mem_Ico\n-/\n\n",
 "mem_Icc":
 "#print Convex.mem_Icc /-\n/-- A point is in an `Icc` iff it can be expressed as a convex combination of the endpoints. -/\ntheorem Convex.mem_Icc (h : x â‰¤ y) : z âˆˆ Icc x y â†” âˆƒ a b, 0 â‰¤ a âˆ§ 0 â‰¤ b âˆ§ a + b = 1 âˆ§ a * x + b * y = z :=\n  by\n  rw [â† segment_eq_Icc h]\n  simp_rw [â† exists_prop]\n  rfl\n#align convex.mem_Icc Convex.mem_Icc\n-/\n\n",
 "left_mem_segment":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `segment -/\n#print left_mem_segment /-\ntheorem left_mem_segment (x y : E) : x âˆˆ segment x ğ•œ y :=\n  âŸ¨1, 0, zero_le_one, le_refl 0, add_zero 1, by rw [zero_smul, one_smul, add_zero]âŸ©\n#align left_mem_segment left_mem_segment\n-/\n\n",
 "left_mem_openSegment_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n#print left_mem_openSegment_iff /-\n@[simp]\ntheorem left_mem_openSegment_iff [DenselyOrdered ğ•œ] [NoZeroSMulDivisors ğ•œ E] : x âˆˆ openSegment ğ•œ x y â†” x = y :=\n  by\n  constructor\n  Â· rintro âŸ¨a, b, ha, hb, hab, hxâŸ©\n    refine' smul_right_injective _ hb.ne' ((add_right_inj (Â«expr â€¢ Â» a x)).1 _)\n    rw [hx, â† add_smul, hab, one_smul]\n  Â· rintro rfl\n    rw [openSegment_same]\n    exact mem_singleton _\n#align left_mem_open_segment_iff left_mem_openSegment_iff\n-/\n\n",
 "insert_endpoints_openSegment":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `segment -/\n#print insert_endpoints_openSegment /-\ntheorem insert_endpoints_openSegment (x y : E) : insert x (insert y (openSegment ğ•œ x y)) = segment x ğ•œ y :=\n  by\n  simp only [subset_antisymm_iff, insert_subset, left_mem_segment, right_mem_segment, openSegment_subset_segment,\n    true_and_iff]\n  rintro z âŸ¨a, b, ha, hb, hab, rflâŸ©\n  refine' hb.eq_or_gt.imp _ fun hb' => ha.eq_or_gt.imp _ fun ha' => _\n  Â· rintro rfl\n    rw [â† add_zero a, hab, one_smul, zero_smul, add_zero]\n  Â· rintro rfl\n    rw [â† zero_add b, hab, one_smul, zero_smul, zero_add]\n  Â· exact âŸ¨a, b, ha', hb', hab, rflâŸ©\n#align insert_endpoints_open_segment insert_endpoints_openSegment\n-/\n\n",
 "image_update_segment":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `segment -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `segment -/\ntheorem image_update_segment (i : Î¹) (xâ‚ xâ‚‚ : Ï€ i) (y : âˆ€ i, Ï€ i) :\n    Â«expr '' Â» (update y i) (segment xâ‚ ğ•œ xâ‚‚) = segment (update y i xâ‚) ğ•œ (update y i xâ‚‚) :=\n  by\n  ext z\n  simp_rw [Set.mem_image, segment, Set.mem_setOf, â† update_smul, â† update_add, update_eq_iff, â† exists_and_right,\n    @exists_comm (Ï€ i), exists_eq_left']\n  refine' existsâ‚…_congr fun a b ha hb hab => _\n  rw [Convex.combo_self hab]\n#align image_update_segment image_update_segment\n\n",
 "image_update_open_segment":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\ntheorem image_update_open_segment (i : Î¹) (xâ‚ xâ‚‚ : Ï€ i) (y : âˆ€ i, Ï€ i) :\n    Â«expr '' Â» (update y i) (openSegment ğ•œ xâ‚ xâ‚‚) = openSegment ğ•œ (update y i xâ‚) (update y i xâ‚‚) :=\n  by\n  ext z\n  simp_rw [Set.mem_image, openSegment, Set.mem_setOf, â† update_smul, â† update_add, update_eq_iff, â† exists_and_right,\n    @exists_comm (Ï€ i), exists_eq_left']\n  refine' existsâ‚…_congr fun a b ha hb hab => _\n  rw [Convex.combo_self hab]\n#align image_update_open_segment image_update_open_segment\n\n",
 "image_segment":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’áµƒ[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `segment -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `segment -/\n#print image_segment /-\n@[simp]\ntheorem image_segment (f : Â«expr â†’áµƒ[ ] Â» E ğ•œ F) (a b : E) : Â«expr '' Â» f (segment a ğ•œ b) = segment (f a) ğ•œ (f b) :=\n  Set.ext fun x => by simp_rw [segment_eq_image_lineMap, mem_image, exists_exists_and_eq_and, AffineMap.apply_lineMap]\n#align image_segment image_segment\n-/\n\n",
 "image_openSegment":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’áµƒ[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n#print image_openSegment /-\n@[simp]\ntheorem image_openSegment (f : Â«expr â†’áµƒ[ ] Â» E ğ•œ F) (a b : E) :\n    Â«expr '' Â» f (openSegment ğ•œ a b) = openSegment ğ•œ (f a) (f b) :=\n  Set.ext fun x => by\n    simp_rw [openSegment_eq_image_lineMap, mem_image, exists_exists_and_eq_and, AffineMap.apply_lineMap]\n#align image_open_segment image_openSegment\n-/\n\n",
 "image_mk_segment_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `segment -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `segment -/\ntheorem image_mk_segment_right (x : E) (yâ‚ yâ‚‚ : F) :\n    Â«expr '' Â» (fun y => (x, y)) (segment yâ‚ ğ•œ yâ‚‚) = segment (x, yâ‚) ğ•œ (x, yâ‚‚) :=\n  by\n  ext âŸ¨x', y'âŸ©\n  simp_rw [Set.mem_image, segment, Set.mem_setOf, Prod.smul_mk, Prod.mk_add_mk, Prod.mk.inj_iff, â† exists_and_right,\n    @exists_comm F, exists_eq_left']\n  refine' existsâ‚…_congr fun a b ha hb hab => _\n  rw [Convex.combo_self hab]\n#align image_mk_segment_right image_mk_segment_right\n\n",
 "image_mk_segment_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `segment -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `segment -/\ntheorem image_mk_segment_left (xâ‚ xâ‚‚ : E) (y : F) :\n    Â«expr '' Â» (fun x => (x, y)) (segment xâ‚ ğ•œ xâ‚‚) = segment (xâ‚, y) ğ•œ (xâ‚‚, y) :=\n  by\n  ext âŸ¨x', y'âŸ©\n  simp_rw [Set.mem_image, segment, Set.mem_setOf, Prod.smul_mk, Prod.mk_add_mk, Prod.mk.inj_iff, â† exists_and_right,\n    @exists_comm E, exists_eq_left']\n  refine' existsâ‚…_congr fun a b ha hb hab => _\n  rw [Convex.combo_self hab]\n#align image_mk_segment_left image_mk_segment_left\n\n",
 "image_mk_open_segment_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n@[simp]\ntheorem image_mk_open_segment_right (x : E) (yâ‚ yâ‚‚ : F) :\n    Â«expr '' Â» (fun y => (x, y)) (openSegment ğ•œ yâ‚ yâ‚‚) = openSegment ğ•œ (x, yâ‚) (x, yâ‚‚) :=\n  by\n  ext âŸ¨x', y'âŸ©\n  simp_rw [Set.mem_image, openSegment, Set.mem_setOf, Prod.smul_mk, Prod.mk_add_mk, Prod.mk.inj_iff, â† exists_and_right,\n    @exists_comm F, exists_eq_left']\n  refine' existsâ‚…_congr fun a b ha hb hab => _\n  rw [Convex.combo_self hab]\n#align image_mk_open_segment_right image_mk_open_segment_right\n\n",
 "image_mk_open_segment_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\ntheorem image_mk_open_segment_left (xâ‚ xâ‚‚ : E) (y : F) :\n    Â«expr '' Â» (fun x => (x, y)) (openSegment ğ•œ xâ‚ xâ‚‚) = openSegment ğ•œ (xâ‚, y) (xâ‚‚, y) :=\n  by\n  ext âŸ¨x', y'âŸ©\n  simp_rw [Set.mem_image, openSegment, Set.mem_setOf, Prod.smul_mk, Prod.mk_add_mk, Prod.mk.inj_iff, â† exists_and_right,\n    @exists_comm E, exists_eq_left']\n  refine' existsâ‚…_congr fun a b ha hb hab => _\n  rw [Convex.combo_self hab]\n#align image_mk_open_segment_left image_mk_open_segment_left\n\n",
 "combo_le_max":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n#print Convex.combo_le_max /-\ntheorem Convex.combo_le_max (x y : E) (ha : 0 â‰¤ a) (hb : 0 â‰¤ b) (hab : a + b = 1) :\n    Â«expr â€¢ Â» a x + Â«expr â€¢ Â» b y â‰¤ max x y :=\n  (segment_subset_uIcc x y âŸ¨_, _, ha, hb, hab, rflâŸ©).2\n#align convex.combo_le_max Convex.combo_le_max\n-/\n\n",
 "Ioo_subset_openSegment":
 "#print Ioo_subset_openSegment /-\ntheorem Ioo_subset_openSegment : Ioo x y âŠ† openSegment ğ•œ x y := fun z hz =>\n  mem_openSegment_of_ne_left_right hz.1.ne hz.2.ne' <| Icc_subset_segment <| Ioo_subset_Icc_self hz\n#align Ioo_subset_open_segment Ioo_subset_openSegment\n-/\n\n",
 "Icc_subset_segment":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `segment -/\n#print Icc_subset_segment /-\ntheorem Icc_subset_segment : Icc x y âŠ† segment x ğ•œ y :=\n  by\n  rintro z âŸ¨hxz, hyzâŸ©\n  obtain rfl | h := (hxz.trans hyz).eq_or_lt\n  Â· rw [segment_same]\n    exact hyz.antisymm hxz\n  rw [â† sub_nonneg] at hxz hyz\n  rw [â† sub_pos] at h\n  refine' âŸ¨(y - z) / (y - x), (z - x) / (y - x), div_nonneg hyz h.le, div_nonneg hxz h.le, _, _âŸ©\n  Â· rw [â† add_div, sub_add_sub_cancel, div_self h.ne']\n  Â·\n    rw [smul_eq_mul, smul_eq_mul, â† mul_div_right_comm, â† mul_div_right_comm, â† add_div, div_eq_iff h.ne', add_comm,\n      sub_mul, sub_mul, mul_comm x, sub_add_sub_cancel, mul_sub]\n#align Icc_subset_segment Icc_subset_segment\n-/\n\n"}