{"vadd_segment":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr +ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `segment -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `segment -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr +ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr +ᵥ » -/\n#print vadd_segment /-\n@[simp]\ntheorem vadd_segment [AddTorsor G E] [VAddCommClass G E E] (a : G) (b c : E) :\n    «expr +ᵥ » a (segment b 𝕜 c) = segment («expr +ᵥ » a b) 𝕜 («expr +ᵥ » a c) :=\n  image_segment 𝕜 ⟨_, LinearMap.id, fun _ _ => vadd_comm _ _ _⟩ b c\n#align vadd_segment vadd_segment\n-/\n\n",
 "vadd_openSegment":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr +ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr +ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr +ᵥ » -/\n#print vadd_openSegment /-\n@[simp]\ntheorem vadd_openSegment [AddTorsor G E] [VAddCommClass G E E] (a : G) (b c : E) :\n    «expr +ᵥ » a (openSegment 𝕜 b c) = openSegment 𝕜 («expr +ᵥ » a b) («expr +ᵥ » a c) :=\n  image_openSegment 𝕜 ⟨_, LinearMap.id, fun _ _ => vadd_comm _ _ _⟩ b c\n#align vadd_open_segment vadd_openSegment\n-/\n\n",
 "segment_translate_preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `segment -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `segment -/\n#print segment_translate_preimage /-\ntheorem segment_translate_preimage (a b c : E) :\n    «expr ⁻¹' » (fun x => a + x) (segment (a + b) 𝕜 (a + c)) = segment b 𝕜 c :=\n  Set.ext fun x => mem_segment_translate 𝕜 a\n#align segment_translate_preimage segment_translate_preimage\n-/\n\n",
 "segment_translate_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `segment -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `segment -/\n#print segment_translate_image /-\ntheorem segment_translate_image (a b c : E) : «expr '' » (fun x => a + x) (segment b 𝕜 c) = segment (a + b) 𝕜 (a + c) :=\n  segment_translate_preimage 𝕜 a b c ▸ image_preimage_eq _ <| add_left_surjective a\n#align segment_translate_image segment_translate_image\n-/\n\n",
 "segment_symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `segment -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `segment -/\n#print segment_symm /-\ntheorem segment_symm (x y : E) : segment x 𝕜 y = segment y 𝕜 x :=\n  Set.ext fun z =>\n    ⟨fun ⟨a, b, ha, hb, hab, H⟩ => ⟨b, a, hb, ha, (add_comm _ _).trans hab, (add_comm _ _).trans H⟩,\n      fun ⟨a, b, ha, hb, hab, H⟩ => ⟨b, a, hb, ha, (add_comm _ _).trans hab, (add_comm _ _).trans H⟩⟩\n#align segment_symm segment_symm\n-/\n\n",
 "segment_subset_uIcc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `segment -/\n#print segment_subset_uIcc /-\ntheorem segment_subset_uIcc (x y : E) : segment x 𝕜 y ⊆ uIcc x y :=\n  by\n  cases le_total x y\n  · rw [uIcc_of_le h]\n    exact segment_subset_Icc h\n  · rw [uIcc_of_ge h, segment_symm]\n    exact segment_subset_Icc h\n#align segment_subset_uIcc segment_subset_uIcc\n-/\n\n",
 "segment_subset_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `segment -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print segment_subset_iff /-\ntheorem segment_subset_iff :\n    segment x 𝕜 y ⊆ s ↔ ∀ a b : 𝕜, 0 ≤ a → 0 ≤ b → a + b = 1 → «expr • » a x + «expr • » b y ∈ s :=\n  ⟨fun H a b ha hb hab => H ⟨a, b, ha, hb, hab, rfl⟩, fun H z ⟨a, b, ha, hb, hab, hz⟩ => hz ▸ H a b ha hb hab⟩\n#align segment_subset_iff segment_subset_iff\n-/\n\n",
 "segment_subset_Icc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `segment -/\n#print segment_subset_Icc /-\ntheorem segment_subset_Icc (h : x ≤ y) : segment x 𝕜 y ⊆ Icc x y :=\n  by\n  rintro z ⟨a, b, ha, hb, hab, rfl⟩\n  constructor\n  calc\n    x = «expr • » a x + «expr • » b x := (Convex.combo_self hab _).symm\n    _ ≤ «expr • » a x + «expr • » b y := add_le_add_left (smul_le_smul_of_nonneg h hb) _\n    \n  calc\n    «expr • » a x + «expr • » b y ≤ «expr • » a y + «expr • » b y := add_le_add_right (smul_le_smul_of_nonneg h ha) _\n    _ = y := Convex.combo_self hab _\n    \n#align segment_subset_Icc segment_subset_Icc\n-/\n\n",
 "segment_subset":
 "theorem segment_subset (x y : ∀ i, π i) : segment 𝕜 x y ⊆ s.pi fun i => segment 𝕜 (x i) (y i) :=\n  by\n  rintro z ⟨a, b, ha, hb, hab, hz⟩ i -\n  exact ⟨a, b, ha, hb, hab, congr_fun hz i⟩\n#align segment_subset segment_subset\n\n",
 "segment_same":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `segment -/\n#print segment_same /-\n@[simp]\ntheorem segment_same (x : E) : segment x 𝕜 x = {x} :=\n  Set.ext fun z =>\n    ⟨fun ⟨a, b, ha, hb, hab, hz⟩ => by\n      simpa only [(add_smul _ _ _).symm, mem_singleton_iff, hab, one_smul, eq_comm] using hz, fun h =>\n      mem_singleton_iff.1 h ▸ left_mem_segment 𝕜 z z⟩\n#align segment_same segment_same\n-/\n\n",
 "segment_eq_uIcc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `segment -/\n#print segment_eq_uIcc /-\ntheorem segment_eq_uIcc (x y : 𝕜) : segment x 𝕜 y = uIcc x y :=\n  segment_eq_Icc' _ _\n#align segment_eq_uIcc segment_eq_uIcc\n-/\n\n",
 "segment_eq_image₂":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `segment -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print segment_eq_image₂ /-\n/-\nCopyright (c) 2019 Alexander Bentkamp. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Alexander Bentkamp, Yury Kudryashov, Yaël Dillies\n-/\ntheorem segment_eq_image₂ (x y : E) :\n    segment x 𝕜 y =\n      «expr '' » (fun p : 𝕜 × 𝕜 => «expr • » p.1 x + «expr • » p.2 y) { p | 0 ≤ p.1 ∧ 0 ≤ p.2 ∧ p.1 + p.2 = 1 } :=\n  by simp only [segment, image, Prod.exists, mem_set_of_eq, exists_prop, and_assoc']\n#align segment_eq_image₂ segment_eq_image₂\n-/\n\n",
 "segment_eq_image_lineMap":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `segment -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n#print segment_eq_image_lineMap /-\ntheorem segment_eq_image_lineMap (x y : E) : segment x 𝕜 y = «expr '' » (AffineMap.lineMap x y) (Icc (0 : 𝕜) 1) :=\n  by\n  convert segment_eq_image 𝕜 x y\n  ext\n  exact AffineMap.lineMap_apply_module _ _ _\n#align segment_eq_image_line_map segment_eq_image_lineMap\n-/\n\n",
 "segment_eq_image'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `segment -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print segment_eq_image' /-\ntheorem segment_eq_image' (x y : E) :\n    segment x 𝕜 y = «expr '' » (fun θ : 𝕜 => x + «expr • » θ (y - x)) (Icc (0 : 𝕜) 1) :=\n  by\n  convert segment_eq_image 𝕜 x y\n  ext θ\n  simp only [smul_sub, sub_smul, one_smul]\n  abel\n#align segment_eq_image' segment_eq_image'\n-/\n\n",
 "segment_eq_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `segment -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print segment_eq_image /-\ntheorem segment_eq_image (x y : E) :\n    segment x 𝕜 y = «expr '' » (fun θ : 𝕜 => «expr • » (1 - θ) x + «expr • » θ y) (Icc (0 : 𝕜) 1) :=\n  Set.ext fun z =>\n    ⟨fun ⟨a, b, ha, hb, hab, hz⟩ => ⟨b, ⟨hb, hab ▸ le_add_of_nonneg_left ha⟩, hab ▸ hz ▸ by simp only [add_sub_cancel]⟩,\n      fun ⟨θ, ⟨hθ₀, hθ₁⟩, hz⟩ => ⟨1 - θ, θ, sub_nonneg.2 hθ₁, hθ₀, sub_add_cancel _ _, hz⟩⟩\n#align segment_eq_image segment_eq_image\n-/\n\n",
 "segment_eq_Icc'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `segment -/\n#print segment_eq_Icc' /-\ntheorem segment_eq_Icc' (x y : 𝕜) : segment x 𝕜 y = Icc (min x y) (max x y) :=\n  by\n  cases le_total x y\n  · rw [segment_eq_Icc h, max_eq_right h, min_eq_left h]\n  · rw [segment_symm, segment_eq_Icc h, max_eq_left h, min_eq_right h]\n#align segment_eq_Icc' segment_eq_Icc'\n-/\n\n",
 "segment_eq_Icc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `segment -/\n#print segment_eq_Icc /-\n@[simp]\ntheorem segment_eq_Icc (h : x ≤ y) : segment x 𝕜 y = Icc x y :=\n  (segment_subset_Icc h).antisymm Icc_subset_segment\n#align segment_eq_Icc segment_eq_Icc\n-/\n\n",
 "sameRay_of_mem_segment":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `segment -/\n#print sameRay_of_mem_segment /-\ntheorem sameRay_of_mem_segment [StrictOrderedCommRing 𝕜] [AddCommGroup E] [Module 𝕜 E] {x y z : E}\n    (h : x ∈ segment y 𝕜 z) : SameRay 𝕜 (x - y) (z - x) :=\n  by\n  rw [segment_eq_image'] at h\n  rcases h with ⟨θ, ⟨hθ₀, hθ₁⟩, rfl⟩\n  simpa only [add_sub_cancel', ← sub_sub, sub_smul, one_smul] using\n    (SameRay.sameRay_nonneg_smul_left (z - y) hθ₀).nonneg_smul_right (sub_nonneg.2 hθ₁)\n#align same_ray_of_mem_segment sameRay_of_mem_segment\n-/\n\n",
 "right_mem_segment":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `segment -/\n#print right_mem_segment /-\ntheorem right_mem_segment (x y : E) : y ∈ segment x 𝕜 y :=\n  segment_symm 𝕜 y x ▸ left_mem_segment 𝕜 y x\n#align right_mem_segment right_mem_segment\n-/\n\n",
 "right_mem_openSegment_iff":
 "#print right_mem_openSegment_iff /-\n@[simp]\ntheorem right_mem_openSegment_iff [DenselyOrdered 𝕜] [NoZeroSMulDivisors 𝕜 E] : y ∈ openSegment 𝕜 x y ↔ x = y := by\n  rw [openSegment_symm, left_mem_openSegment_iff, eq_comm]\n#align right_mem_open_segment_iff right_mem_openSegment_iff\n-/\n\n",
 "open_segment_subset":
 "theorem open_segment_subset (x y : ∀ i, π i) : openSegment 𝕜 x y ⊆ s.pi fun i => openSegment 𝕜 (x i) (y i) :=\n  by\n  rintro z ⟨a, b, ha, hb, hab, hz⟩ i -\n  exact ⟨a, b, ha, hb, hab, congr_fun hz i⟩\n#align open_segment_subset open_segment_subset\n\n",
 "openSegment_translate_preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n#print openSegment_translate_preimage /-\ntheorem openSegment_translate_preimage (a b c : E) :\n    «expr ⁻¹' » (fun x => a + x) (openSegment 𝕜 (a + b) (a + c)) = openSegment 𝕜 b c :=\n  Set.ext fun x => mem_openSegment_translate 𝕜 a\n#align open_segment_translate_preimage openSegment_translate_preimage\n-/\n\n",
 "openSegment_translate_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n#print openSegment_translate_image /-\ntheorem openSegment_translate_image (a b c : E) :\n    «expr '' » (fun x => a + x) (openSegment 𝕜 b c) = openSegment 𝕜 (a + b) (a + c) :=\n  openSegment_translate_preimage 𝕜 a b c ▸ image_preimage_eq _ <| add_left_surjective a\n#align open_segment_translate_image openSegment_translate_image\n-/\n\n",
 "openSegment_symm":
 "#print openSegment_symm /-\ntheorem openSegment_symm (x y : E) : openSegment 𝕜 x y = openSegment 𝕜 y x :=\n  Set.ext fun z =>\n    ⟨fun ⟨a, b, ha, hb, hab, H⟩ => ⟨b, a, hb, ha, (add_comm _ _).trans hab, (add_comm _ _).trans H⟩,\n      fun ⟨a, b, ha, hb, hab, H⟩ => ⟨b, a, hb, ha, (add_comm _ _).trans hab, (add_comm _ _).trans H⟩⟩\n#align open_segment_symm openSegment_symm\n-/\n\n",
 "openSegment_subset_union":
 "#print openSegment_subset_union /-\n/-- If `z = line_map x y c` is a point on the line passing through `x` and `y`, then the open\nsegment `open_segment 𝕜 x y` is included in the union of the open segments `open_segment 𝕜 x z`,\n`open_segment 𝕜 z y`, and the point `z`. Informally, `(x, y) ⊆ {z} ∪ (x, z) ∪ (z, y)`. -/\ntheorem openSegment_subset_union (x y : E) {z : E} (hz : z ∈ range (lineMap x y : 𝕜 → E)) :\n    openSegment 𝕜 x y ⊆ insert z (openSegment 𝕜 x z ∪ openSegment 𝕜 z y) :=\n  by\n  rcases hz with ⟨c, rfl⟩\n  simp only [openSegment_eq_image_lineMap, ← maps_to']\n  rintro a ⟨h₀, h₁⟩\n  rcases lt_trichotomy a c with (hac | rfl | hca)\n  · right\n    left\n    have hc : 0 < c := h₀.trans hac\n    refine' ⟨a / c, ⟨div_pos h₀ hc, (div_lt_one hc).2 hac⟩, _⟩\n    simp only [← homothety_eq_line_map, ← homothety_mul_apply, div_mul_cancel _ hc.ne']\n  · left\n    rfl\n  · right\n    right\n    have hc : 0 < 1 - c := sub_pos.2 (hca.trans h₁)\n    simp only [← line_map_apply_one_sub y]\n    refine' ⟨(a - c) / (1 - c), ⟨div_pos (sub_pos.2 hca) hc, (div_lt_one hc).2 <| sub_lt_sub_right h₁ _⟩, _⟩\n    simp only [← homothety_eq_line_map, ← homothety_mul_apply, sub_mul, one_mul, div_mul_cancel _ hc.ne',\n      sub_sub_sub_cancel_right]\n#align open_segment_subset_union openSegment_subset_union\n-/\n\n",
 "openSegment_subset_segment":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `segment -/\n#print openSegment_subset_segment /-\ntheorem openSegment_subset_segment (x y : E) : openSegment 𝕜 x y ⊆ segment x 𝕜 y := fun z ⟨a, b, ha, hb, hab, hz⟩ =>\n  ⟨a, b, ha.le, hb.le, hab, hz⟩\n#align open_segment_subset_segment openSegment_subset_segment\n-/\n\n",
 "openSegment_subset_iff_segment_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `segment -/\n#print openSegment_subset_iff_segment_subset /-\ntheorem openSegment_subset_iff_segment_subset (hx : x ∈ s) (hy : y ∈ s) : openSegment 𝕜 x y ⊆ s ↔ segment x 𝕜 y ⊆ s :=\n  by simp only [← insert_endpoints_openSegment, insert_subset, *, true_and_iff]\n#align open_segment_subset_iff_segment_subset openSegment_subset_iff_segment_subset\n-/\n\n",
 "openSegment_subset_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print openSegment_subset_iff /-\ntheorem openSegment_subset_iff :\n    openSegment 𝕜 x y ⊆ s ↔ ∀ a b : 𝕜, 0 < a → 0 < b → a + b = 1 → «expr • » a x + «expr • » b y ∈ s :=\n  ⟨fun H a b ha hb hab => H ⟨a, b, ha, hb, hab, rfl⟩, fun H z ⟨a, b, ha, hb, hab, hz⟩ => hz ▸ H a b ha hb hab⟩\n#align open_segment_subset_iff openSegment_subset_iff\n-/\n\n",
 "openSegment_subset_Ioo":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print openSegment_subset_Ioo /-\ntheorem openSegment_subset_Ioo (h : x < y) : openSegment 𝕜 x y ⊆ Ioo x y :=\n  by\n  rintro z ⟨a, b, ha, hb, hab, rfl⟩\n  constructor\n  calc\n    x = «expr • » a x + «expr • » b x := (Convex.combo_self hab _).symm\n    _ < «expr • » a x + «expr • » b y := add_lt_add_left (smul_lt_smul_of_pos h hb) _\n    \n  calc\n    «expr • » a x + «expr • » b y < «expr • » a y + «expr • » b y := add_lt_add_right (smul_lt_smul_of_pos h ha) _\n    _ = y := Convex.combo_self hab _\n    \n#align open_segment_subset_Ioo openSegment_subset_Ioo\n-/\n\n",
 "openSegment_same":
 "#print openSegment_same /-\n@[simp]\ntheorem openSegment_same (x : E) : openSegment 𝕜 x x = {x} :=\n  Set.ext fun z =>\n    ⟨fun ⟨a, b, ha, hb, hab, hz⟩ => by simpa only [← add_smul, mem_singleton_iff, hab, one_smul, eq_comm] using hz,\n      fun h : z = x => by\n      obtain ⟨a, ha₀, ha₁⟩ := densely_ordered.dense (0 : 𝕜) 1 zero_lt_one\n      refine' ⟨a, 1 - a, ha₀, sub_pos_of_lt ha₁, add_sub_cancel'_right _ _, _⟩\n      rw [← add_smul, add_sub_cancel'_right, one_smul, h]⟩\n#align open_segment_same openSegment_same\n-/\n\n",
 "openSegment_eq_image₂":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print openSegment_eq_image₂ /-\ntheorem openSegment_eq_image₂ (x y : E) :\n    openSegment 𝕜 x y =\n      «expr '' » (fun p : 𝕜 × 𝕜 => «expr • » p.1 x + «expr • » p.2 y) { p | 0 < p.1 ∧ 0 < p.2 ∧ p.1 + p.2 = 1 } :=\n  by simp only [openSegment, image, Prod.exists, mem_set_of_eq, exists_prop, and_assoc']\n#align open_segment_eq_image₂ openSegment_eq_image₂\n-/\n\n",
 "openSegment_eq_image_lineMap":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n#print openSegment_eq_image_lineMap /-\ntheorem openSegment_eq_image_lineMap (x y : E) :\n    openSegment 𝕜 x y = «expr '' » (AffineMap.lineMap x y) (Ioo (0 : 𝕜) 1) :=\n  by\n  convert openSegment_eq_image 𝕜 x y\n  ext\n  exact AffineMap.lineMap_apply_module _ _ _\n#align open_segment_eq_image_line_map openSegment_eq_image_lineMap\n-/\n\n",
 "openSegment_eq_image'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print openSegment_eq_image' /-\ntheorem openSegment_eq_image' (x y : E) :\n    openSegment 𝕜 x y = «expr '' » (fun θ : 𝕜 => x + «expr • » θ (y - x)) (Ioo (0 : 𝕜) 1) :=\n  by\n  convert openSegment_eq_image 𝕜 x y\n  ext θ\n  simp only [smul_sub, sub_smul, one_smul]\n  abel\n#align open_segment_eq_image' openSegment_eq_image'\n-/\n\n",
 "openSegment_eq_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print openSegment_eq_image /-\ntheorem openSegment_eq_image (x y : E) :\n    openSegment 𝕜 x y = «expr '' » (fun θ : 𝕜 => «expr • » (1 - θ) x + «expr • » θ y) (Ioo (0 : 𝕜) 1) :=\n  Set.ext fun z =>\n    ⟨fun ⟨a, b, ha, hb, hab, hz⟩ => ⟨b, ⟨hb, hab ▸ lt_add_of_pos_left _ ha⟩, hab ▸ hz ▸ by simp only [add_sub_cancel]⟩,\n      fun ⟨θ, ⟨hθ₀, hθ₁⟩, hz⟩ => ⟨1 - θ, θ, sub_pos.2 hθ₁, hθ₀, sub_add_cancel _ _, hz⟩⟩\n#align open_segment_eq_image openSegment_eq_image\n-/\n\n",
 "openSegment_eq_Ioo'":
 "#print openSegment_eq_Ioo' /-\ntheorem openSegment_eq_Ioo' (hxy : x ≠ y) : openSegment 𝕜 x y = Ioo (min x y) (max x y) :=\n  by\n  cases hxy.lt_or_lt\n  · rw [openSegment_eq_Ioo h, max_eq_right h.le, min_eq_left h.le]\n  · rw [openSegment_symm, openSegment_eq_Ioo h, max_eq_left h.le, min_eq_right h.le]\n#align open_segment_eq_Ioo' openSegment_eq_Ioo'\n-/\n\n",
 "openSegment_eq_Ioo":
 "#print openSegment_eq_Ioo /-\n@[simp]\ntheorem openSegment_eq_Ioo (h : x < y) : openSegment 𝕜 x y = Ioo x y :=\n  (openSegment_subset_Ioo h).antisymm Ioo_subset_openSegment\n#align open_segment_eq_Ioo openSegment_eq_Ioo\n-/\n\n",
 "min_le_combo":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print Convex.min_le_combo /-\ntheorem Convex.min_le_combo (x y : E) (ha : 0 ≤ a) (hb : 0 ≤ b) (hab : a + b = 1) :\n    min x y ≤ «expr • » a x + «expr • » b y :=\n  (segment_subset_uIcc x y ⟨_, _, ha, hb, hab, rfl⟩).1\n#align convex.min_le_combo Convex.min_le_combo\n-/\n\n",
 "midpoint_mem_segment":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⅟» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `segment -/\n#print midpoint_mem_segment /-\ntheorem midpoint_mem_segment [Invertible (2 : 𝕜)] (x y : E) : midpoint 𝕜 x y ∈ segment x 𝕜 y :=\n  by\n  rw [segment_eq_image_lineMap]\n  exact ⟨(«expr⅟») 2, ⟨inv_of_nonneg.mpr zero_le_two, invOf_le_one one_le_two⟩, rfl⟩\n#align midpoint_mem_segment midpoint_mem_segment\n-/\n\n",
 "mem_segment_translate":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `segment -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `segment -/\n#print mem_segment_translate /-\n@[simp]\ntheorem mem_segment_translate (a : E) {x b c} : a + x ∈ segment (a + b) 𝕜 (a + c) ↔ x ∈ segment b 𝕜 c := by\n  simp_rw [← vadd_eq_add, ← vadd_segment, vadd_mem_vadd_set_iff]\n#align mem_segment_translate mem_segment_translate\n-/\n\n",
 "mem_segment_sub_add":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `segment -/\n#print mem_segment_sub_add /-\ntheorem mem_segment_sub_add [Invertible (2 : 𝕜)] (x y : E) : x ∈ segment (x - y) 𝕜 (x + y) :=\n  by\n  convert@midpoint_mem_segment 𝕜 _ _ _ _ _ _ _\n  rw [midpoint_sub_add]\n#align mem_segment_sub_add mem_segment_sub_add\n-/\n\n",
 "mem_segment_iff_sameRay":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `segment -/\n#print mem_segment_iff_sameRay /-\ntheorem mem_segment_iff_sameRay : x ∈ segment y 𝕜 z ↔ SameRay 𝕜 (x - y) (z - x) :=\n  by\n  refine' ⟨sameRay_of_mem_segment, fun h => _⟩\n  rcases h.exists_eq_smul_add with ⟨a, b, ha, hb, hab, hxy, hzx⟩\n  rw [add_comm, sub_add_sub_cancel] at hxy hzx\n  rw [← mem_segment_translate _ (-x), neg_add_self]\n  refine' ⟨b, a, hb, ha, add_comm a b ▸ hab, _⟩\n  rw [← sub_eq_neg_add, ← neg_sub, hxy, ← sub_eq_neg_add, hzx, smul_neg, smul_comm, neg_add_self]\n#align mem_segment_iff_same_ray mem_segment_iff_sameRay\n-/\n\n",
 "mem_segment_iff_div":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `segment -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print mem_segment_iff_div /-\ntheorem mem_segment_iff_div :\n    x ∈ segment y 𝕜 z ↔\n      ∃ a b : 𝕜, 0 ≤ a ∧ 0 ≤ b ∧ 0 < a + b ∧ «expr • » (a / (a + b)) y + «expr • » (b / (a + b)) z = x :=\n  by\n  constructor\n  · rintro ⟨a, b, ha, hb, hab, rfl⟩\n    use a, b, ha, hb\n    simp [*]\n  · rintro ⟨a, b, ha, hb, hab, rfl⟩\n    refine' ⟨a / (a + b), b / (a + b), div_nonneg ha hab.le, div_nonneg hb hab.le, _, rfl⟩\n    rw [← add_div, div_self hab.ne']\n#align mem_segment_iff_div mem_segment_iff_div\n-/\n\n",
 "mem_segment_add_sub":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `segment -/\n#print mem_segment_add_sub /-\ntheorem mem_segment_add_sub [Invertible (2 : 𝕜)] (x y : E) : x ∈ segment (x + y) 𝕜 (x - y) :=\n  by\n  convert@midpoint_mem_segment 𝕜 _ _ _ _ _ _ _\n  rw [midpoint_add_sub]\n#align mem_segment_add_sub mem_segment_add_sub\n-/\n\n",
 "mem_openSegment_translate":
 "#print mem_openSegment_translate /-\n@[simp]\ntheorem mem_openSegment_translate (a : E) {x b c : E} : a + x ∈ openSegment 𝕜 (a + b) (a + c) ↔ x ∈ openSegment 𝕜 b c :=\n  by simp_rw [← vadd_eq_add, ← vadd_openSegment, vadd_mem_vadd_set_iff]\n#align mem_open_segment_translate mem_openSegment_translate\n-/\n\n",
 "mem_openSegment_of_ne_left_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `segment -/\n#print mem_openSegment_of_ne_left_right /-\ntheorem mem_openSegment_of_ne_left_right (hx : x ≠ z) (hy : y ≠ z) (hz : z ∈ segment x 𝕜 y) : z ∈ openSegment 𝕜 x y :=\n  by\n  rw [← insert_endpoints_openSegment] at hz\n  exact (hz.resolve_left hx.symm).resolve_left hy.symm\n#align mem_open_segment_of_ne_left_right mem_openSegment_of_ne_left_right\n-/\n\n",
 "mem_openSegment_iff_div":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print mem_openSegment_iff_div /-\ntheorem mem_openSegment_iff_div :\n    x ∈ openSegment 𝕜 y z ↔ ∃ a b : 𝕜, 0 < a ∧ 0 < b ∧ «expr • » (a / (a + b)) y + «expr • » (b / (a + b)) z = x :=\n  by\n  constructor\n  · rintro ⟨a, b, ha, hb, hab, rfl⟩\n    use a, b, ha, hb\n    rw [hab, div_one, div_one]\n  · rintro ⟨a, b, ha, hb, rfl⟩\n    have hab : 0 < a + b := by positivity\n    refine' ⟨a / (a + b), b / (a + b), by positivity, by positivity, _, rfl⟩\n    rw [← add_div, div_self hab.ne']\n#align mem_open_segment_iff_div mem_openSegment_iff_div\n-/\n\n",
 "mem_Ioo":
 "#print Convex.mem_Ioo /-\n/-- A point is in an `Ioo` iff it can be expressed as a strict convex combination of the endpoints.\n-/\ntheorem Convex.mem_Ioo (h : x < y) : z ∈ Ioo x y ↔ ∃ a b, 0 < a ∧ 0 < b ∧ a + b = 1 ∧ a * x + b * y = z :=\n  by\n  rw [← openSegment_eq_Ioo h]\n  simp_rw [← exists_prop]\n  rfl\n#align convex.mem_Ioo Convex.mem_Ioo\n-/\n\n",
 "mem_Ioc":
 "#print Convex.mem_Ioc /-\n/-- A point is in an `Ioc` iff it can be expressed as a semistrict convex combination of the\nendpoints. -/\ntheorem Convex.mem_Ioc (h : x < y) : z ∈ Ioc x y ↔ ∃ a b, 0 ≤ a ∧ 0 < b ∧ a + b = 1 ∧ a * x + b * y = z :=\n  by\n  refine' ⟨fun hz => _, _⟩\n  · obtain ⟨a, b, ha, hb, hab, rfl⟩ := (Convex.mem_Icc h.le).1 (Ioc_subset_Icc_self hz)\n    obtain rfl | hb' := hb.eq_or_lt\n    · rw [add_zero] at hab\n      rw [hab, one_mul, MulZeroClass.zero_mul, add_zero] at hz\n      exact (hz.1.ne rfl).elim\n    · exact ⟨a, b, ha, hb', hab, rfl⟩\n  · rintro ⟨a, b, ha, hb, hab, rfl⟩\n    obtain rfl | ha' := ha.eq_or_lt\n    · rw [zero_add] at hab\n      rwa [hab, one_mul, MulZeroClass.zero_mul, zero_add, right_mem_Ioc]\n    · exact Ioo_subset_Ioc_self ((Convex.mem_Ioo h).2 ⟨a, b, ha', hb, hab, rfl⟩)\n#align convex.mem_Ioc Convex.mem_Ioc\n-/\n\n",
 "mem_Ico":
 "#print Convex.mem_Ico /-\n/-- A point is in an `Ico` iff it can be expressed as a semistrict convex combination of the\nendpoints. -/\ntheorem Convex.mem_Ico (h : x < y) : z ∈ Ico x y ↔ ∃ a b, 0 < a ∧ 0 ≤ b ∧ a + b = 1 ∧ a * x + b * y = z :=\n  by\n  refine' ⟨fun hz => _, _⟩\n  · obtain ⟨a, b, ha, hb, hab, rfl⟩ := (Convex.mem_Icc h.le).1 (Ico_subset_Icc_self hz)\n    obtain rfl | ha' := ha.eq_or_lt\n    · rw [zero_add] at hab\n      rw [hab, one_mul, MulZeroClass.zero_mul, zero_add] at hz\n      exact (hz.2.ne rfl).elim\n    · exact ⟨a, b, ha', hb, hab, rfl⟩\n  · rintro ⟨a, b, ha, hb, hab, rfl⟩\n    obtain rfl | hb' := hb.eq_or_lt\n    · rw [add_zero] at hab\n      rwa [hab, one_mul, MulZeroClass.zero_mul, add_zero, left_mem_Ico]\n    · exact Ioo_subset_Ico_self ((Convex.mem_Ioo h).2 ⟨a, b, ha, hb', hab, rfl⟩)\n#align convex.mem_Ico Convex.mem_Ico\n-/\n\n",
 "mem_Icc":
 "#print Convex.mem_Icc /-\n/-- A point is in an `Icc` iff it can be expressed as a convex combination of the endpoints. -/\ntheorem Convex.mem_Icc (h : x ≤ y) : z ∈ Icc x y ↔ ∃ a b, 0 ≤ a ∧ 0 ≤ b ∧ a + b = 1 ∧ a * x + b * y = z :=\n  by\n  rw [← segment_eq_Icc h]\n  simp_rw [← exists_prop]\n  rfl\n#align convex.mem_Icc Convex.mem_Icc\n-/\n\n",
 "left_mem_segment":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `segment -/\n#print left_mem_segment /-\ntheorem left_mem_segment (x y : E) : x ∈ segment x 𝕜 y :=\n  ⟨1, 0, zero_le_one, le_refl 0, add_zero 1, by rw [zero_smul, one_smul, add_zero]⟩\n#align left_mem_segment left_mem_segment\n-/\n\n",
 "left_mem_openSegment_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print left_mem_openSegment_iff /-\n@[simp]\ntheorem left_mem_openSegment_iff [DenselyOrdered 𝕜] [NoZeroSMulDivisors 𝕜 E] : x ∈ openSegment 𝕜 x y ↔ x = y :=\n  by\n  constructor\n  · rintro ⟨a, b, ha, hb, hab, hx⟩\n    refine' smul_right_injective _ hb.ne' ((add_right_inj («expr • » a x)).1 _)\n    rw [hx, ← add_smul, hab, one_smul]\n  · rintro rfl\n    rw [openSegment_same]\n    exact mem_singleton _\n#align left_mem_open_segment_iff left_mem_openSegment_iff\n-/\n\n",
 "insert_endpoints_openSegment":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `segment -/\n#print insert_endpoints_openSegment /-\ntheorem insert_endpoints_openSegment (x y : E) : insert x (insert y (openSegment 𝕜 x y)) = segment x 𝕜 y :=\n  by\n  simp only [subset_antisymm_iff, insert_subset, left_mem_segment, right_mem_segment, openSegment_subset_segment,\n    true_and_iff]\n  rintro z ⟨a, b, ha, hb, hab, rfl⟩\n  refine' hb.eq_or_gt.imp _ fun hb' => ha.eq_or_gt.imp _ fun ha' => _\n  · rintro rfl\n    rw [← add_zero a, hab, one_smul, zero_smul, add_zero]\n  · rintro rfl\n    rw [← zero_add b, hab, one_smul, zero_smul, zero_add]\n  · exact ⟨a, b, ha', hb', hab, rfl⟩\n#align insert_endpoints_open_segment insert_endpoints_openSegment\n-/\n\n",
 "image_update_segment":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `segment -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `segment -/\ntheorem image_update_segment (i : ι) (x₁ x₂ : π i) (y : ∀ i, π i) :\n    «expr '' » (update y i) (segment x₁ 𝕜 x₂) = segment (update y i x₁) 𝕜 (update y i x₂) :=\n  by\n  ext z\n  simp_rw [Set.mem_image, segment, Set.mem_setOf, ← update_smul, ← update_add, update_eq_iff, ← exists_and_right,\n    @exists_comm (π i), exists_eq_left']\n  refine' exists₅_congr fun a b ha hb hab => _\n  rw [Convex.combo_self hab]\n#align image_update_segment image_update_segment\n\n",
 "image_update_open_segment":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem image_update_open_segment (i : ι) (x₁ x₂ : π i) (y : ∀ i, π i) :\n    «expr '' » (update y i) (openSegment 𝕜 x₁ x₂) = openSegment 𝕜 (update y i x₁) (update y i x₂) :=\n  by\n  ext z\n  simp_rw [Set.mem_image, openSegment, Set.mem_setOf, ← update_smul, ← update_add, update_eq_iff, ← exists_and_right,\n    @exists_comm (π i), exists_eq_left']\n  refine' exists₅_congr fun a b ha hb hab => _\n  rw [Convex.combo_self hab]\n#align image_update_open_segment image_update_open_segment\n\n",
 "image_segment":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ᵃ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `segment -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `segment -/\n#print image_segment /-\n@[simp]\ntheorem image_segment (f : «expr →ᵃ[ ] » E 𝕜 F) (a b : E) : «expr '' » f (segment a 𝕜 b) = segment (f a) 𝕜 (f b) :=\n  Set.ext fun x => by simp_rw [segment_eq_image_lineMap, mem_image, exists_exists_and_eq_and, AffineMap.apply_lineMap]\n#align image_segment image_segment\n-/\n\n",
 "image_openSegment":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ᵃ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n#print image_openSegment /-\n@[simp]\ntheorem image_openSegment (f : «expr →ᵃ[ ] » E 𝕜 F) (a b : E) :\n    «expr '' » f (openSegment 𝕜 a b) = openSegment 𝕜 (f a) (f b) :=\n  Set.ext fun x => by\n    simp_rw [openSegment_eq_image_lineMap, mem_image, exists_exists_and_eq_and, AffineMap.apply_lineMap]\n#align image_open_segment image_openSegment\n-/\n\n",
 "image_mk_segment_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `segment -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `segment -/\ntheorem image_mk_segment_right (x : E) (y₁ y₂ : F) :\n    «expr '' » (fun y => (x, y)) (segment y₁ 𝕜 y₂) = segment (x, y₁) 𝕜 (x, y₂) :=\n  by\n  ext ⟨x', y'⟩\n  simp_rw [Set.mem_image, segment, Set.mem_setOf, Prod.smul_mk, Prod.mk_add_mk, Prod.mk.inj_iff, ← exists_and_right,\n    @exists_comm F, exists_eq_left']\n  refine' exists₅_congr fun a b ha hb hab => _\n  rw [Convex.combo_self hab]\n#align image_mk_segment_right image_mk_segment_right\n\n",
 "image_mk_segment_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `segment -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `segment -/\ntheorem image_mk_segment_left (x₁ x₂ : E) (y : F) :\n    «expr '' » (fun x => (x, y)) (segment x₁ 𝕜 x₂) = segment (x₁, y) 𝕜 (x₂, y) :=\n  by\n  ext ⟨x', y'⟩\n  simp_rw [Set.mem_image, segment, Set.mem_setOf, Prod.smul_mk, Prod.mk_add_mk, Prod.mk.inj_iff, ← exists_and_right,\n    @exists_comm E, exists_eq_left']\n  refine' exists₅_congr fun a b ha hb hab => _\n  rw [Convex.combo_self hab]\n#align image_mk_segment_left image_mk_segment_left\n\n",
 "image_mk_open_segment_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n@[simp]\ntheorem image_mk_open_segment_right (x : E) (y₁ y₂ : F) :\n    «expr '' » (fun y => (x, y)) (openSegment 𝕜 y₁ y₂) = openSegment 𝕜 (x, y₁) (x, y₂) :=\n  by\n  ext ⟨x', y'⟩\n  simp_rw [Set.mem_image, openSegment, Set.mem_setOf, Prod.smul_mk, Prod.mk_add_mk, Prod.mk.inj_iff, ← exists_and_right,\n    @exists_comm F, exists_eq_left']\n  refine' exists₅_congr fun a b ha hb hab => _\n  rw [Convex.combo_self hab]\n#align image_mk_open_segment_right image_mk_open_segment_right\n\n",
 "image_mk_open_segment_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem image_mk_open_segment_left (x₁ x₂ : E) (y : F) :\n    «expr '' » (fun x => (x, y)) (openSegment 𝕜 x₁ x₂) = openSegment 𝕜 (x₁, y) (x₂, y) :=\n  by\n  ext ⟨x', y'⟩\n  simp_rw [Set.mem_image, openSegment, Set.mem_setOf, Prod.smul_mk, Prod.mk_add_mk, Prod.mk.inj_iff, ← exists_and_right,\n    @exists_comm E, exists_eq_left']\n  refine' exists₅_congr fun a b ha hb hab => _\n  rw [Convex.combo_self hab]\n#align image_mk_open_segment_left image_mk_open_segment_left\n\n",
 "combo_le_max":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print Convex.combo_le_max /-\ntheorem Convex.combo_le_max (x y : E) (ha : 0 ≤ a) (hb : 0 ≤ b) (hab : a + b = 1) :\n    «expr • » a x + «expr • » b y ≤ max x y :=\n  (segment_subset_uIcc x y ⟨_, _, ha, hb, hab, rfl⟩).2\n#align convex.combo_le_max Convex.combo_le_max\n-/\n\n",
 "Ioo_subset_openSegment":
 "#print Ioo_subset_openSegment /-\ntheorem Ioo_subset_openSegment : Ioo x y ⊆ openSegment 𝕜 x y := fun z hz =>\n  mem_openSegment_of_ne_left_right hz.1.ne hz.2.ne' <| Icc_subset_segment <| Ioo_subset_Icc_self hz\n#align Ioo_subset_open_segment Ioo_subset_openSegment\n-/\n\n",
 "Icc_subset_segment":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `segment -/\n#print Icc_subset_segment /-\ntheorem Icc_subset_segment : Icc x y ⊆ segment x 𝕜 y :=\n  by\n  rintro z ⟨hxz, hyz⟩\n  obtain rfl | h := (hxz.trans hyz).eq_or_lt\n  · rw [segment_same]\n    exact hyz.antisymm hxz\n  rw [← sub_nonneg] at hxz hyz\n  rw [← sub_pos] at h\n  refine' ⟨(y - z) / (y - x), (z - x) / (y - x), div_nonneg hyz h.le, div_nonneg hxz h.le, _, _⟩\n  · rw [← add_div, sub_add_sub_cancel, div_self h.ne']\n  ·\n    rw [smul_eq_mul, smul_eq_mul, ← mul_div_right_comm, ← mul_div_right_comm, ← add_div, div_eq_iff h.ne', add_comm,\n      sub_mul, sub_mul, mul_comm x, sub_add_sub_cancel, mul_sub]\n#align Icc_subset_segment Icc_subset_segment\n-/\n\n"}