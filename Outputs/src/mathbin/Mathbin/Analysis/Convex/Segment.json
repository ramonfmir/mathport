{"segment_translate_preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `segment -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `segment -/\ntheorem segment_translate_preimage (a b c : E) :\n    Â«expr â»Â¹' Â» (fun x => a + x) (segment (a + b) ğ•œ (a + c)) = segment b ğ•œ c :=\n  Set.ext fun x => mem_segment_translate ğ•œ a\n#align segment_translate_preimage segment_translate_preimage\n\n",
 "segment_translate_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `segment -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `segment -/\ntheorem segment_translate_image (a b c : E) : Â«expr '' Â» (fun x => a + x) (segment b ğ•œ c) = segment (a + b) ğ•œ (a + c) :=\n  segment_translate_preimage ğ•œ a b c â–¸ image_preimage_eq _ <| add_left_surjective a\n#align segment_translate_image segment_translate_image\n\n",
 "segment_symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `segment -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `segment -/\ntheorem segment_symm (x y : E) : segment x ğ•œ y = segment y ğ•œ x :=\n  Set.ext fun z =>\n    âŸ¨fun âŸ¨a, b, ha, hb, hab, HâŸ© => âŸ¨b, a, hb, ha, (add_comm _ _).trans hab, (add_comm _ _).trans HâŸ©,\n      fun âŸ¨a, b, ha, hb, hab, HâŸ© => âŸ¨b, a, hb, ha, (add_comm _ _).trans hab, (add_comm _ _).trans HâŸ©âŸ©\n#align segment_symm segment_symm\n\n",
 "segment_subset_uIcc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `segment -/\ntheorem segment_subset_uIcc (x y : E) : segment x ğ•œ y âŠ† uIcc x y :=\n  by\n  cases le_total x y\n  Â· rw [uIcc_of_le h]\n    exact segment_subset_Icc h\n  Â· rw [uIcc_of_ge h, segment_symm]\n    exact segment_subset_Icc h\n#align segment_subset_uIcc segment_subset_uIcc\n\n",
 "segment_subset_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `segment -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\ntheorem segment_subset_iff :\n    segment x ğ•œ y âŠ† s â†” âˆ€ a b : ğ•œ, 0 â‰¤ a â†’ 0 â‰¤ b â†’ a + b = 1 â†’ Â«expr â€¢ Â» a x + Â«expr â€¢ Â» b y âˆˆ s :=\n  âŸ¨fun H a b ha hb hab => H âŸ¨a, b, ha, hb, hab, rflâŸ©, fun H z âŸ¨a, b, ha, hb, hab, hzâŸ© => hz â–¸ H a b ha hb habâŸ©\n#align segment_subset_iff segment_subset_iff\n\n",
 "segment_subset_Icc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `segment -/\ntheorem segment_subset_Icc (h : x â‰¤ y) : segment x ğ•œ y âŠ† Icc x y :=\n  by\n  rintro z âŸ¨a, b, ha, hb, hab, rflâŸ©\n  constructor\n  calc\n    x = Â«expr â€¢ Â» a x + Â«expr â€¢ Â» b x := (Convex.combo_self hab _).symm\n    _ â‰¤ Â«expr â€¢ Â» a x + Â«expr â€¢ Â» b y := add_le_add_left (smul_le_smul_of_nonneg h hb) _\n    \n  calc\n    Â«expr â€¢ Â» a x + Â«expr â€¢ Â» b y â‰¤ Â«expr â€¢ Â» a y + Â«expr â€¢ Â» b y := add_le_add_right (smul_le_smul_of_nonneg h ha) _\n    _ = y := Convex.combo_self hab _\n    \n#align segment_subset_Icc segment_subset_Icc\n\n",
 "segment_same":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `segment -/\n@[simp]\ntheorem segment_same (x : E) : segment x ğ•œ x = {x} :=\n  Set.ext fun z =>\n    âŸ¨fun âŸ¨a, b, ha, hb, hab, hzâŸ© => by\n      simpa only [(add_smul _ _ _).symm, mem_singleton_iff, hab, one_smul, eq_comm] using hz, fun h =>\n      mem_singleton_iff.1 h â–¸ left_mem_segment ğ•œ z zâŸ©\n#align segment_same segment_same\n\n",
 "segment_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚—[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `segment -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `segment -/\ntheorem segment_image (f : Â«expr â†’â‚—[ ] Â» E ğ•œ F) (a b : E) : Â«expr '' Â» f (segment a ğ•œ b) = segment (f a) ğ•œ (f b) :=\n  Set.ext fun x => by simp_rw [segment_eq_image, mem_image, exists_exists_and_eq_and, map_add, map_smul]\n#align segment_image segment_image\n\n",
 "segment_eq_uIcc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `segment -/\ntheorem segment_eq_uIcc (x y : ğ•œ) : segment x ğ•œ y = uIcc x y :=\n  segment_eq_Icc' _ _\n#align segment_eq_uIcc segment_eq_uIcc\n\n",
 "segment_eq_imageâ‚‚":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `segment -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/-\nCopyright (c) 2019 Alexander Bentkamp. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Alexander Bentkamp, Yury Kudriashov, YaÃ«l Dillies\n-/\ntheorem segment_eq_imageâ‚‚ (x y : E) :\n    segment x ğ•œ y =\n      Â«expr '' Â» (fun p : ğ•œ Ã— ğ•œ => Â«expr â€¢ Â» p.1 x + Â«expr â€¢ Â» p.2 y) { p | 0 â‰¤ p.1 âˆ§ 0 â‰¤ p.2 âˆ§ p.1 + p.2 = 1 } :=\n  by simp only [segment, image, prod.exists, mem_set_of_eq, exists_prop, and_assoc']\n#align segment_eq_imageâ‚‚ segment_eq_imageâ‚‚\n\n",
 "segment_eq_image_line_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `segment -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\ntheorem segment_eq_image_line_map (x y : E) : segment x ğ•œ y = Â«expr '' Â» (affine_map.line_map x y) (Icc (0 : ğ•œ) 1) :=\n  by\n  convert segment_eq_image ğ•œ x y\n  ext\n  exact affine_map.line_map_apply_module _ _ _\n#align segment_eq_image_line_map segment_eq_image_line_map\n\n",
 "segment_eq_image'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `segment -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\ntheorem segment_eq_image' (x y : E) :\n    segment x ğ•œ y = Â«expr '' Â» (fun Î¸ : ğ•œ => x + Â«expr â€¢ Â» Î¸ (y - x)) (Icc (0 : ğ•œ) 1) :=\n  by\n  convert segment_eq_image ğ•œ x y\n  ext Î¸\n  simp only [smul_sub, sub_smul, one_smul]\n  abel\n#align segment_eq_image' segment_eq_image'\n\n",
 "segment_eq_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `segment -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\ntheorem segment_eq_image (x y : E) :\n    segment x ğ•œ y = Â«expr '' Â» (fun Î¸ : ğ•œ => Â«expr â€¢ Â» (1 - Î¸) x + Â«expr â€¢ Â» Î¸ y) (Icc (0 : ğ•œ) 1) :=\n  Set.ext fun z =>\n    âŸ¨fun âŸ¨a, b, ha, hb, hab, hzâŸ© => âŸ¨b, âŸ¨hb, hab â–¸ le_add_of_nonneg_left haâŸ©, hab â–¸ hz â–¸ by simp only [add_sub_cancel]âŸ©,\n      fun âŸ¨Î¸, âŸ¨hÎ¸â‚€, hÎ¸â‚âŸ©, hzâŸ© => âŸ¨1 - Î¸, Î¸, sub_nonneg.2 hÎ¸â‚, hÎ¸â‚€, sub_add_cancel _ _, hzâŸ©âŸ©\n#align segment_eq_image segment_eq_image\n\n",
 "segment_eq_Icc'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `segment -/\ntheorem segment_eq_Icc' (x y : ğ•œ) : segment x ğ•œ y = Icc (min x y) (max x y) :=\n  by\n  cases le_total x y\n  Â· rw [segment_eq_Icc h, max_eq_right h, min_eq_left h]\n  Â· rw [segment_symm, segment_eq_Icc h, max_eq_left h, min_eq_right h]\n#align segment_eq_Icc' segment_eq_Icc'\n\n",
 "segment_eq_Icc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `segment -/\n@[simp]\ntheorem segment_eq_Icc (h : x â‰¤ y) : segment x ğ•œ y = Icc x y :=\n  (segment_subset_Icc h).antisymm Icc_subset_segment\n#align segment_eq_Icc segment_eq_Icc\n\n",
 "same_ray_of_mem_segment":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `segment -/\ntheorem same_ray_of_mem_segment [StrictOrderedCommRing ğ•œ] [add_comm_group E] [Module ğ•œ E] {x y z : E}\n    (h : x âˆˆ segment y ğ•œ z) : same_ray ğ•œ (x - y) (z - x) :=\n  by\n  rw [segment_eq_image'] at h\n  rcases h with âŸ¨Î¸, âŸ¨hÎ¸â‚€, hÎ¸â‚âŸ©, rflâŸ©\n  simpa only [add_sub_cancel', â† sub_sub, sub_smul, one_smul] using\n    (same_ray_nonneg_smul_left (z - y) hÎ¸â‚€).nonneg_smul_right (sub_nonneg.2 hÎ¸â‚)\n#align same_ray_of_mem_segment same_ray_of_mem_segment\n\n",
 "right_mem_segment":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `segment -/\ntheorem right_mem_segment (x y : E) : y âˆˆ segment x ğ•œ y :=\n  segment_symm ğ•œ y x â–¸ left_mem_segment ğ•œ y x\n#align right_mem_segment right_mem_segment\n\n",
 "right_mem_open_segment_iff":
 "@[simp]\ntheorem right_mem_open_segment_iff [DenselyOrdered ğ•œ] [NoZeroSMulDivisors ğ•œ E] : y âˆˆ open_segment ğ•œ x y â†” x = y := by\n  rw [open_segment_symm, left_mem_open_segment_iff, eq_comm]\n#align right_mem_open_segment_iff right_mem_open_segment_iff\n\n",
 "open_segment_translate_preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\ntheorem open_segment_translate_preimage (a b c : E) :\n    Â«expr â»Â¹' Â» (fun x => a + x) (open_segment ğ•œ (a + b) (a + c)) = open_segment ğ•œ b c :=\n  Set.ext fun x => mem_open_segment_translate ğ•œ a\n#align open_segment_translate_preimage open_segment_translate_preimage\n\n",
 "open_segment_translate_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\ntheorem open_segment_translate_image (a b c : E) :\n    Â«expr '' Â» (fun x => a + x) (open_segment ğ•œ b c) = open_segment ğ•œ (a + b) (a + c) :=\n  open_segment_translate_preimage ğ•œ a b c â–¸ image_preimage_eq _ <| add_left_surjective a\n#align open_segment_translate_image open_segment_translate_image\n\n",
 "open_segment_symm":
 "theorem open_segment_symm (x y : E) : open_segment ğ•œ x y = open_segment ğ•œ y x :=\n  Set.ext fun z =>\n    âŸ¨fun âŸ¨a, b, ha, hb, hab, HâŸ© => âŸ¨b, a, hb, ha, (add_comm _ _).trans hab, (add_comm _ _).trans HâŸ©,\n      fun âŸ¨a, b, ha, hb, hab, HâŸ© => âŸ¨b, a, hb, ha, (add_comm _ _).trans hab, (add_comm _ _).trans HâŸ©âŸ©\n#align open_segment_symm open_segment_symm\n\n",
 "open_segment_subset_union":
 "/-- If `z = line_map x y c` is a point on the line passing through `x` and `y`, then the open\nsegment `open_segment ğ•œ x y` is included in the union of the open segments `open_segment ğ•œ x z`,\n`open_segment ğ•œ z y`, and the point `z`. Informally, `(x, y) âŠ† {z} âˆª (x, z) âˆª (z, y)`. -/\ntheorem open_segment_subset_union (x y : E) {z : E} (hz : z âˆˆ range (line_map x y : ğ•œ â†’ E)) :\n    open_segment ğ•œ x y âŠ† insert z (open_segment ğ•œ x z âˆª open_segment ğ•œ z y) :=\n  by\n  rcases hz with âŸ¨c, rflâŸ©\n  simp only [open_segment_eq_image_line_map, â† maps_to']\n  rintro a âŸ¨hâ‚€, hâ‚âŸ©\n  rcases lt_trichotomy a c with (hac | rfl | hca)\n  Â· right\n    left\n    have hc : 0 < c := hâ‚€.trans hac\n    refine' âŸ¨a / c, âŸ¨div_pos hâ‚€ hc, (div_lt_one hc).2 hacâŸ©, _âŸ©\n    simp only [â† homothety_eq_line_map, â† homothety_mul_apply, div_mul_cancel _ hc.ne']\n  Â· left\n    rfl\n  Â· right\n    right\n    have hc : 0 < 1 - c := sub_pos.2 (hca.trans hâ‚)\n    simp only [â† line_map_apply_one_sub y]\n    refine' âŸ¨(a - c) / (1 - c), âŸ¨div_pos (sub_pos.2 hca) hc, (div_lt_one hc).2 <| sub_lt_sub_right hâ‚ _âŸ©, _âŸ©\n    simp only [â† homothety_eq_line_map, â† homothety_mul_apply, sub_mul, one_mul, div_mul_cancel _ hc.ne',\n      sub_sub_sub_cancel_right]\n#align open_segment_subset_union open_segment_subset_union\n\n",
 "open_segment_subset_segment":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `segment -/\ntheorem open_segment_subset_segment (x y : E) : open_segment ğ•œ x y âŠ† segment x ğ•œ y := fun z âŸ¨a, b, ha, hb, hab, hzâŸ© =>\n  âŸ¨a, b, ha.le, hb.le, hab, hzâŸ©\n#align open_segment_subset_segment open_segment_subset_segment\n\n",
 "open_segment_subset_iff_segment_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `segment -/\ntheorem open_segment_subset_iff_segment_subset (hx : x âˆˆ s) (hy : y âˆˆ s) : open_segment ğ•œ x y âŠ† s â†” segment x ğ•œ y âŠ† s :=\n  by simp only [â† insert_endpoints_open_segment, insert_subset, *, true_and_iff]\n#align open_segment_subset_iff_segment_subset open_segment_subset_iff_segment_subset\n\n",
 "open_segment_subset_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\ntheorem open_segment_subset_iff :\n    open_segment ğ•œ x y âŠ† s â†” âˆ€ a b : ğ•œ, 0 < a â†’ 0 < b â†’ a + b = 1 â†’ Â«expr â€¢ Â» a x + Â«expr â€¢ Â» b y âˆˆ s :=\n  âŸ¨fun H a b ha hb hab => H âŸ¨a, b, ha, hb, hab, rflâŸ©, fun H z âŸ¨a, b, ha, hb, hab, hzâŸ© => hz â–¸ H a b ha hb habâŸ©\n#align open_segment_subset_iff open_segment_subset_iff\n\n",
 "open_segment_subset_Ioo":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\ntheorem open_segment_subset_Ioo (h : x < y) : open_segment ğ•œ x y âŠ† Ioo x y :=\n  by\n  rintro z âŸ¨a, b, ha, hb, hab, rflâŸ©\n  constructor\n  calc\n    x = Â«expr â€¢ Â» a x + Â«expr â€¢ Â» b x := (Convex.combo_self hab _).symm\n    _ < Â«expr â€¢ Â» a x + Â«expr â€¢ Â» b y := add_lt_add_left (smul_lt_smul_of_pos h hb) _\n    \n  calc\n    Â«expr â€¢ Â» a x + Â«expr â€¢ Â» b y < Â«expr â€¢ Â» a y + Â«expr â€¢ Â» b y := add_lt_add_right (smul_lt_smul_of_pos h ha) _\n    _ = y := Convex.combo_self hab _\n    \n#align open_segment_subset_Ioo open_segment_subset_Ioo\n\n",
 "open_segment_same":
 "@[simp]\ntheorem open_segment_same (x : E) : open_segment ğ•œ x x = {x} :=\n  Set.ext fun z =>\n    âŸ¨fun âŸ¨a, b, ha, hb, hab, hzâŸ© => by simpa only [â† add_smul, mem_singleton_iff, hab, one_smul, eq_comm] using hz,\n      fun h : z = x => by\n      obtain âŸ¨a, haâ‚€, haâ‚âŸ© := densely_ordered.dense (0 : ğ•œ) 1 zero_lt_one\n      refine' âŸ¨a, 1 - a, haâ‚€, sub_pos_of_lt haâ‚, add_sub_cancel'_right _ _, _âŸ©\n      rw [â† add_smul, add_sub_cancel'_right, one_smul, h]âŸ©\n#align open_segment_same open_segment_same\n\n",
 "open_segment_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚—[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n@[simp]\ntheorem open_segment_image (f : Â«expr â†’â‚—[ ] Â» E ğ•œ F) (a b : E) :\n    Â«expr '' Â» f (open_segment ğ•œ a b) = open_segment ğ•œ (f a) (f b) :=\n  Set.ext fun x => by simp_rw [open_segment_eq_image, mem_image, exists_exists_and_eq_and, map_add, map_smul]\n#align open_segment_image open_segment_image\n\n",
 "open_segment_eq_imageâ‚‚":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\ntheorem open_segment_eq_imageâ‚‚ (x y : E) :\n    open_segment ğ•œ x y =\n      Â«expr '' Â» (fun p : ğ•œ Ã— ğ•œ => Â«expr â€¢ Â» p.1 x + Â«expr â€¢ Â» p.2 y) { p | 0 < p.1 âˆ§ 0 < p.2 âˆ§ p.1 + p.2 = 1 } :=\n  by simp only [open_segment, image, prod.exists, mem_set_of_eq, exists_prop, and_assoc']\n#align open_segment_eq_imageâ‚‚ open_segment_eq_imageâ‚‚\n\n",
 "open_segment_eq_image_line_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\ntheorem open_segment_eq_image_line_map (x y : E) :\n    open_segment ğ•œ x y = Â«expr '' Â» (affine_map.line_map x y) (Ioo (0 : ğ•œ) 1) :=\n  by\n  convert open_segment_eq_image ğ•œ x y\n  ext\n  exact affine_map.line_map_apply_module _ _ _\n#align open_segment_eq_image_line_map open_segment_eq_image_line_map\n\n",
 "open_segment_eq_image'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\ntheorem open_segment_eq_image' (x y : E) :\n    open_segment ğ•œ x y = Â«expr '' Â» (fun Î¸ : ğ•œ => x + Â«expr â€¢ Â» Î¸ (y - x)) (Ioo (0 : ğ•œ) 1) :=\n  by\n  convert open_segment_eq_image ğ•œ x y\n  ext Î¸\n  simp only [smul_sub, sub_smul, one_smul]\n  abel\n#align open_segment_eq_image' open_segment_eq_image'\n\n",
 "open_segment_eq_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\ntheorem open_segment_eq_image (x y : E) :\n    open_segment ğ•œ x y = Â«expr '' Â» (fun Î¸ : ğ•œ => Â«expr â€¢ Â» (1 - Î¸) x + Â«expr â€¢ Â» Î¸ y) (Ioo (0 : ğ•œ) 1) :=\n  Set.ext fun z =>\n    âŸ¨fun âŸ¨a, b, ha, hb, hab, hzâŸ© => âŸ¨b, âŸ¨hb, hab â–¸ lt_add_of_pos_left _ haâŸ©, hab â–¸ hz â–¸ by simp only [add_sub_cancel]âŸ©,\n      fun âŸ¨Î¸, âŸ¨hÎ¸â‚€, hÎ¸â‚âŸ©, hzâŸ© => âŸ¨1 - Î¸, Î¸, sub_pos.2 hÎ¸â‚, hÎ¸â‚€, sub_add_cancel _ _, hzâŸ©âŸ©\n#align open_segment_eq_image open_segment_eq_image\n\n",
 "open_segment_eq_Ioo'":
 "theorem open_segment_eq_Ioo' (hxy : x â‰  y) : open_segment ğ•œ x y = Ioo (min x y) (max x y) :=\n  by\n  cases hxy.lt_or_lt\n  Â· rw [open_segment_eq_Ioo h, max_eq_right h.le, min_eq_left h.le]\n  Â· rw [open_segment_symm, open_segment_eq_Ioo h, max_eq_left h.le, min_eq_right h.le]\n#align open_segment_eq_Ioo' open_segment_eq_Ioo'\n\n",
 "open_segment_eq_Ioo":
 "@[simp]\ntheorem open_segment_eq_Ioo (h : x < y) : open_segment ğ•œ x y = Ioo x y :=\n  (open_segment_subset_Ioo h).antisymm Ioo_subset_open_segment\n#align open_segment_eq_Ioo open_segment_eq_Ioo\n\n",
 "min_le_combo":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\ntheorem convex.min_le_combo (x y : E) (ha : 0 â‰¤ a) (hb : 0 â‰¤ b) (hab : a + b = 1) :\n    min x y â‰¤ Â«expr â€¢ Â» a x + Â«expr â€¢ Â» b y :=\n  (segment_subset_uIcc x y âŸ¨_, _, ha, hb, hab, rflâŸ©).1\n#align convex.min_le_combo convex.min_le_combo\n\n",
 "midpoint_mem_segment":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ…ŸÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `segment -/\ntheorem midpoint_mem_segment [Invertible (2 : ğ•œ)] (x y : E) : midpoint ğ•œ x y âˆˆ segment x ğ•œ y :=\n  by\n  rw [segment_eq_image_line_map]\n  exact âŸ¨(Â«exprâ…ŸÂ») 2, âŸ¨inv_of_nonneg.mpr zero_le_two, invOf_le_one one_le_twoâŸ©, rflâŸ©\n#align midpoint_mem_segment midpoint_mem_segment\n\n",
 "mem_segment_translate":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `segment -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `segment -/\ntheorem mem_segment_translate (a : E) {x b c} : a + x âˆˆ segment (a + b) ğ•œ (a + c) â†” x âˆˆ segment b ğ•œ c :=\n  by\n  rw [segment_eq_image', segment_eq_image']\n  refine' exists_congr fun Î¸ => and_congr iff.rfl _\n  simp only [add_sub_add_left_eq_sub, add_assoc, add_right_inj]\n#align mem_segment_translate mem_segment_translate\n\n",
 "mem_segment_sub_add":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `segment -/\ntheorem mem_segment_sub_add [Invertible (2 : ğ•œ)] (x y : E) : x âˆˆ segment (x - y) ğ•œ (x + y) :=\n  by\n  convert @midpoint_mem_segment ğ•œ _ _ _ _ _ _ _\n  rw [midpoint_sub_add]\n#align mem_segment_sub_add mem_segment_sub_add\n\n",
 "mem_segment_iff_same_ray":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `segment -/\ntheorem mem_segment_iff_same_ray : x âˆˆ segment y ğ•œ z â†” same_ray ğ•œ (x - y) (z - x) :=\n  by\n  refine' âŸ¨same_ray_of_mem_segment, fun h => _âŸ©\n  rcases h.exists_eq_smul_add with âŸ¨a, b, ha, hb, hab, hxy, hzxâŸ©\n  rw [add_comm, sub_add_sub_cancel] at hxy hzx\n  rw [â† mem_segment_translate _ (-x), neg_add_self]\n  refine' âŸ¨b, a, hb, ha, add_comm a b â–¸ hab, _âŸ©\n  rw [â† sub_eq_neg_add, â† neg_sub, hxy, â† sub_eq_neg_add, hzx, smul_neg, smul_comm, neg_add_self]\n#align mem_segment_iff_same_ray mem_segment_iff_same_ray\n\n",
 "mem_segment_iff_div":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `segment -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\ntheorem mem_segment_iff_div :\n    x âˆˆ segment y ğ•œ z â†”\n      âˆƒ a b : ğ•œ, 0 â‰¤ a âˆ§ 0 â‰¤ b âˆ§ 0 < a + b âˆ§ Â«expr â€¢ Â» (a / (a + b)) y + Â«expr â€¢ Â» (b / (a + b)) z = x :=\n  by\n  constructor\n  Â· rintro âŸ¨a, b, ha, hb, hab, rflâŸ©\n    use a, b, ha, hb\n    simp [*]\n  Â· rintro âŸ¨a, b, ha, hb, hab, rflâŸ©\n    refine' âŸ¨a / (a + b), b / (a + b), div_nonneg ha hab.le, div_nonneg hb hab.le, _, rflâŸ©\n    rw [â† add_div, div_self hab.ne']\n#align mem_segment_iff_div mem_segment_iff_div\n\n",
 "mem_segment_add_sub":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `segment -/\ntheorem mem_segment_add_sub [Invertible (2 : ğ•œ)] (x y : E) : x âˆˆ segment (x + y) ğ•œ (x - y) :=\n  by\n  convert @midpoint_mem_segment ğ•œ _ _ _ _ _ _ _\n  rw [midpoint_add_sub]\n#align mem_segment_add_sub mem_segment_add_sub\n\n",
 "mem_open_segment_translate":
 "@[simp]\ntheorem mem_open_segment_translate (a : E) {x b c : E} :\n    a + x âˆˆ open_segment ğ•œ (a + b) (a + c) â†” x âˆˆ open_segment ğ•œ b c :=\n  by\n  rw [open_segment_eq_image', open_segment_eq_image']\n  refine' exists_congr fun Î¸ => and_congr iff.rfl _\n  simp only [add_sub_add_left_eq_sub, add_assoc, add_right_inj]\n#align mem_open_segment_translate mem_open_segment_translate\n\n",
 "mem_open_segment_of_ne_left_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `segment -/\ntheorem mem_open_segment_of_ne_left_right (hx : x â‰  z) (hy : y â‰  z) (hz : z âˆˆ segment x ğ•œ y) : z âˆˆ open_segment ğ•œ x y :=\n  by\n  rw [â† insert_endpoints_open_segment] at hz\n  exact (hz.resolve_left hx.symm).resolve_left hy.symm\n#align mem_open_segment_of_ne_left_right mem_open_segment_of_ne_left_right\n\n",
 "mem_open_segment_iff_div":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\ntheorem mem_open_segment_iff_div :\n    x âˆˆ open_segment ğ•œ y z â†” âˆƒ a b : ğ•œ, 0 < a âˆ§ 0 < b âˆ§ Â«expr â€¢ Â» (a / (a + b)) y + Â«expr â€¢ Â» (b / (a + b)) z = x :=\n  by\n  constructor\n  Â· rintro âŸ¨a, b, ha, hb, hab, rflâŸ©\n    use a, b, ha, hb\n    rw [hab, div_one, div_one]\n  Â· rintro âŸ¨a, b, ha, hb, rflâŸ©\n    have hab : 0 < a + b := by positivity\n    refine' âŸ¨a / (a + b), b / (a + b), by positivity, by positivity, _, rflâŸ©\n    rw [â† add_div, div_self hab.ne']\n#align mem_open_segment_iff_div mem_open_segment_iff_div\n\n",
 "mem_Ioo":
 "/-- A point is in an `Ioo` iff it can be expressed as a strict convex combination of the endpoints.\n-/\ntheorem convex.mem_Ioo (h : x < y) : z âˆˆ Ioo x y â†” âˆƒ a b, 0 < a âˆ§ 0 < b âˆ§ a + b = 1 âˆ§ a * x + b * y = z :=\n  by\n  rw [â† open_segment_eq_Ioo h]\n  simp_rw [â† exists_prop]\n  rfl\n#align convex.mem_Ioo convex.mem_Ioo\n\n",
 "mem_Ioc":
 "/-- A point is in an `Ioc` iff it can be expressed as a semistrict convex combination of the\nendpoints. -/\ntheorem convex.mem_Ioc (h : x < y) : z âˆˆ Ioc x y â†” âˆƒ a b, 0 â‰¤ a âˆ§ 0 < b âˆ§ a + b = 1 âˆ§ a * x + b * y = z :=\n  by\n  refine' âŸ¨fun hz => _, _âŸ©\n  Â· obtain âŸ¨a, b, ha, hb, hab, rflâŸ© := (convex.mem_Icc h.le).1 (Ioc_subset_Icc_self hz)\n    obtain rfl | hb' := hb.eq_or_lt\n    Â· rw [add_zero] at hab\n      rw [hab, one_mul, zero_mul, add_zero] at hz\n      exact (hz.1.ne rfl).elim\n    Â· exact âŸ¨a, b, ha, hb', hab, rflâŸ©\n  Â· rintro âŸ¨a, b, ha, hb, hab, rflâŸ©\n    obtain rfl | ha' := ha.eq_or_lt\n    Â· rw [zero_add] at hab\n      rwa [hab, one_mul, zero_mul, zero_add, right_mem_Ioc]\n    Â· exact Ioo_subset_Ioc_self ((convex.mem_Ioo h).2 âŸ¨a, b, ha', hb, hab, rflâŸ©)\n#align convex.mem_Ioc convex.mem_Ioc\n\n",
 "mem_Ico":
 "/-- A point is in an `Ico` iff it can be expressed as a semistrict convex combination of the\nendpoints. -/\ntheorem convex.mem_Ico (h : x < y) : z âˆˆ Ico x y â†” âˆƒ a b, 0 < a âˆ§ 0 â‰¤ b âˆ§ a + b = 1 âˆ§ a * x + b * y = z :=\n  by\n  refine' âŸ¨fun hz => _, _âŸ©\n  Â· obtain âŸ¨a, b, ha, hb, hab, rflâŸ© := (convex.mem_Icc h.le).1 (Ico_subset_Icc_self hz)\n    obtain rfl | ha' := ha.eq_or_lt\n    Â· rw [zero_add] at hab\n      rw [hab, one_mul, zero_mul, zero_add] at hz\n      exact (hz.2.ne rfl).elim\n    Â· exact âŸ¨a, b, ha', hb, hab, rflâŸ©\n  Â· rintro âŸ¨a, b, ha, hb, hab, rflâŸ©\n    obtain rfl | hb' := hb.eq_or_lt\n    Â· rw [add_zero] at hab\n      rwa [hab, one_mul, zero_mul, add_zero, left_mem_Ico]\n    Â· exact Ioo_subset_Ico_self ((convex.mem_Ioo h).2 âŸ¨a, b, ha, hb', hab, rflâŸ©)\n#align convex.mem_Ico convex.mem_Ico\n\n",
 "mem_Icc":
 "/-- A point is in an `Icc` iff it can be expressed as a convex combination of the endpoints. -/\ntheorem convex.mem_Icc (h : x â‰¤ y) : z âˆˆ Icc x y â†” âˆƒ a b, 0 â‰¤ a âˆ§ 0 â‰¤ b âˆ§ a + b = 1 âˆ§ a * x + b * y = z :=\n  by\n  rw [â† segment_eq_Icc h]\n  simp_rw [â† exists_prop]\n  rfl\n#align convex.mem_Icc convex.mem_Icc\n\n",
 "left_mem_segment":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `segment -/\ntheorem left_mem_segment (x y : E) : x âˆˆ segment x ğ•œ y :=\n  âŸ¨1, 0, zero_le_one, le_refl 0, add_zero 1, by rw [zero_smul, one_smul, add_zero]âŸ©\n#align left_mem_segment left_mem_segment\n\n",
 "left_mem_open_segment_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n@[simp]\ntheorem left_mem_open_segment_iff [DenselyOrdered ğ•œ] [NoZeroSMulDivisors ğ•œ E] : x âˆˆ open_segment ğ•œ x y â†” x = y :=\n  by\n  constructor\n  Â· rintro âŸ¨a, b, ha, hb, hab, hxâŸ©\n    refine' smul_right_injective _ hb.ne' ((add_right_inj (Â«expr â€¢ Â» a x)).1 _)\n    rw [hx, â† add_smul, hab, one_smul]\n  Â· rintro rfl\n    rw [open_segment_same]\n    exact mem_singleton _\n#align left_mem_open_segment_iff left_mem_open_segment_iff\n\n",
 "insert_endpoints_open_segment":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `segment -/\ntheorem insert_endpoints_open_segment (x y : E) : insert x (insert y (open_segment ğ•œ x y)) = segment x ğ•œ y :=\n  by\n  simp only [subset_antisymm_iff, insert_subset, left_mem_segment, right_mem_segment, open_segment_subset_segment,\n    true_and_iff]\n  rintro z âŸ¨a, b, ha, hb, hab, rflâŸ©\n  refine' hb.eq_or_gt.imp _ fun hb' => ha.eq_or_gt.imp _ fun ha' => _\n  Â· rintro rfl\n    rw [â† add_zero a, hab, one_smul, zero_smul, add_zero]\n  Â· rintro rfl\n    rw [â† zero_add b, hab, one_smul, zero_smul, zero_add]\n  Â· exact âŸ¨a, b, ha', hb', hab, rflâŸ©\n#align insert_endpoints_open_segment insert_endpoints_open_segment\n\n",
 "combo_le_max":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\ntheorem convex.combo_le_max (x y : E) (ha : 0 â‰¤ a) (hb : 0 â‰¤ b) (hab : a + b = 1) :\n    Â«expr â€¢ Â» a x + Â«expr â€¢ Â» b y â‰¤ max x y :=\n  (segment_subset_uIcc x y âŸ¨_, _, ha, hb, hab, rflâŸ©).2\n#align convex.combo_le_max convex.combo_le_max\n\n",
 "Ioo_subset_open_segment":
 "theorem Ioo_subset_open_segment : Ioo x y âŠ† open_segment ğ•œ x y := fun z hz =>\n  mem_open_segment_of_ne_left_right hz.1.ne hz.2.ne' <| Icc_subset_segment <| Ioo_subset_Icc_self hz\n#align Ioo_subset_open_segment Ioo_subset_open_segment\n\n",
 "Icc_subset_segment":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `segment -/\ntheorem Icc_subset_segment : Icc x y âŠ† segment x ğ•œ y :=\n  by\n  rintro z âŸ¨hxz, hyzâŸ©\n  obtain rfl | h := (hxz.trans hyz).eq_or_lt\n  Â· rw [segment_same]\n    exact hyz.antisymm hxz\n  rw [â† sub_nonneg] at hxz hyz\n  rw [â† sub_pos] at h\n  refine' âŸ¨(y - z) / (y - x), (z - x) / (y - x), div_nonneg hyz h.le, div_nonneg hxz h.le, _, _âŸ©\n  Â· rw [â† add_div, sub_add_sub_cancel, div_self h.ne']\n  Â·\n    rw [smul_eq_mul, smul_eq_mul, â† mul_div_right_comm, â† mul_div_right_comm, â† add_div, div_eq_iff h.ne', add_comm,\n      sub_mul, sub_mul, mul_comm x, sub_add_sub_cancel, mul_sub]\n#align Icc_subset_segment Icc_subset_segment\n\n"}