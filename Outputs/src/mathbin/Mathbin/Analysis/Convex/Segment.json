{"segment_translate_preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `segment -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `segment -/\ntheorem segment_translate_preimage (a b c : E) :\n    «expr ⁻¹' » (fun x => a + x) (segment (a + b) 𝕜 (a + c)) = segment b 𝕜 c :=\n  Set.ext fun x => mem_segment_translate 𝕜 a\n#align segment_translate_preimage segment_translate_preimage\n\n",
 "segment_translate_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `segment -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `segment -/\ntheorem segment_translate_image (a b c : E) : «expr '' » (fun x => a + x) (segment b 𝕜 c) = segment (a + b) 𝕜 (a + c) :=\n  segment_translate_preimage 𝕜 a b c ▸ image_preimage_eq _ <| add_left_surjective a\n#align segment_translate_image segment_translate_image\n\n",
 "segment_symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `segment -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `segment -/\ntheorem segment_symm (x y : E) : segment x 𝕜 y = segment y 𝕜 x :=\n  Set.ext fun z =>\n    ⟨fun ⟨a, b, ha, hb, hab, H⟩ => ⟨b, a, hb, ha, (add_comm _ _).trans hab, (add_comm _ _).trans H⟩,\n      fun ⟨a, b, ha, hb, hab, H⟩ => ⟨b, a, hb, ha, (add_comm _ _).trans hab, (add_comm _ _).trans H⟩⟩\n#align segment_symm segment_symm\n\n",
 "segment_subset_uIcc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `segment -/\ntheorem segment_subset_uIcc (x y : E) : segment x 𝕜 y ⊆ uIcc x y :=\n  by\n  cases le_total x y\n  · rw [uIcc_of_le h]\n    exact segment_subset_Icc h\n  · rw [uIcc_of_ge h, segment_symm]\n    exact segment_subset_Icc h\n#align segment_subset_uIcc segment_subset_uIcc\n\n",
 "segment_subset_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `segment -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem segment_subset_iff :\n    segment x 𝕜 y ⊆ s ↔ ∀ a b : 𝕜, 0 ≤ a → 0 ≤ b → a + b = 1 → «expr • » a x + «expr • » b y ∈ s :=\n  ⟨fun H a b ha hb hab => H ⟨a, b, ha, hb, hab, rfl⟩, fun H z ⟨a, b, ha, hb, hab, hz⟩ => hz ▸ H a b ha hb hab⟩\n#align segment_subset_iff segment_subset_iff\n\n",
 "segment_subset_Icc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `segment -/\ntheorem segment_subset_Icc (h : x ≤ y) : segment x 𝕜 y ⊆ Icc x y :=\n  by\n  rintro z ⟨a, b, ha, hb, hab, rfl⟩\n  constructor\n  calc\n    x = «expr • » a x + «expr • » b x := (Convex.combo_self hab _).symm\n    _ ≤ «expr • » a x + «expr • » b y := add_le_add_left (smul_le_smul_of_nonneg h hb) _\n    \n  calc\n    «expr • » a x + «expr • » b y ≤ «expr • » a y + «expr • » b y := add_le_add_right (smul_le_smul_of_nonneg h ha) _\n    _ = y := Convex.combo_self hab _\n    \n#align segment_subset_Icc segment_subset_Icc\n\n",
 "segment_same":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `segment -/\n@[simp]\ntheorem segment_same (x : E) : segment x 𝕜 x = {x} :=\n  Set.ext fun z =>\n    ⟨fun ⟨a, b, ha, hb, hab, hz⟩ => by\n      simpa only [(add_smul _ _ _).symm, mem_singleton_iff, hab, one_smul, eq_comm] using hz, fun h =>\n      mem_singleton_iff.1 h ▸ left_mem_segment 𝕜 z z⟩\n#align segment_same segment_same\n\n",
 "segment_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `segment -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `segment -/\ntheorem segment_image (f : «expr →ₗ[ ] » E 𝕜 F) (a b : E) : «expr '' » f (segment a 𝕜 b) = segment (f a) 𝕜 (f b) :=\n  Set.ext fun x => by simp_rw [segment_eq_image, mem_image, exists_exists_and_eq_and, map_add, map_smul]\n#align segment_image segment_image\n\n",
 "segment_eq_uIcc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `segment -/\ntheorem segment_eq_uIcc (x y : 𝕜) : segment x 𝕜 y = uIcc x y :=\n  segment_eq_Icc' _ _\n#align segment_eq_uIcc segment_eq_uIcc\n\n",
 "segment_eq_image₂":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `segment -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-\nCopyright (c) 2019 Alexander Bentkamp. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Alexander Bentkamp, Yury Kudriashov, Yaël Dillies\n-/\ntheorem segment_eq_image₂ (x y : E) :\n    segment x 𝕜 y =\n      «expr '' » (fun p : 𝕜 × 𝕜 => «expr • » p.1 x + «expr • » p.2 y) { p | 0 ≤ p.1 ∧ 0 ≤ p.2 ∧ p.1 + p.2 = 1 } :=\n  by simp only [segment, image, prod.exists, mem_set_of_eq, exists_prop, and_assoc']\n#align segment_eq_image₂ segment_eq_image₂\n\n",
 "segment_eq_image_line_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `segment -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem segment_eq_image_line_map (x y : E) : segment x 𝕜 y = «expr '' » (affine_map.line_map x y) (Icc (0 : 𝕜) 1) :=\n  by\n  convert segment_eq_image 𝕜 x y\n  ext\n  exact affine_map.line_map_apply_module _ _ _\n#align segment_eq_image_line_map segment_eq_image_line_map\n\n",
 "segment_eq_image'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `segment -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem segment_eq_image' (x y : E) :\n    segment x 𝕜 y = «expr '' » (fun θ : 𝕜 => x + «expr • » θ (y - x)) (Icc (0 : 𝕜) 1) :=\n  by\n  convert segment_eq_image 𝕜 x y\n  ext θ\n  simp only [smul_sub, sub_smul, one_smul]\n  abel\n#align segment_eq_image' segment_eq_image'\n\n",
 "segment_eq_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `segment -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem segment_eq_image (x y : E) :\n    segment x 𝕜 y = «expr '' » (fun θ : 𝕜 => «expr • » (1 - θ) x + «expr • » θ y) (Icc (0 : 𝕜) 1) :=\n  Set.ext fun z =>\n    ⟨fun ⟨a, b, ha, hb, hab, hz⟩ => ⟨b, ⟨hb, hab ▸ le_add_of_nonneg_left ha⟩, hab ▸ hz ▸ by simp only [add_sub_cancel]⟩,\n      fun ⟨θ, ⟨hθ₀, hθ₁⟩, hz⟩ => ⟨1 - θ, θ, sub_nonneg.2 hθ₁, hθ₀, sub_add_cancel _ _, hz⟩⟩\n#align segment_eq_image segment_eq_image\n\n",
 "segment_eq_Icc'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `segment -/\ntheorem segment_eq_Icc' (x y : 𝕜) : segment x 𝕜 y = Icc (min x y) (max x y) :=\n  by\n  cases le_total x y\n  · rw [segment_eq_Icc h, max_eq_right h, min_eq_left h]\n  · rw [segment_symm, segment_eq_Icc h, max_eq_left h, min_eq_right h]\n#align segment_eq_Icc' segment_eq_Icc'\n\n",
 "segment_eq_Icc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `segment -/\n@[simp]\ntheorem segment_eq_Icc (h : x ≤ y) : segment x 𝕜 y = Icc x y :=\n  (segment_subset_Icc h).antisymm Icc_subset_segment\n#align segment_eq_Icc segment_eq_Icc\n\n",
 "same_ray_of_mem_segment":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `segment -/\ntheorem same_ray_of_mem_segment [StrictOrderedCommRing 𝕜] [add_comm_group E] [Module 𝕜 E] {x y z : E}\n    (h : x ∈ segment y 𝕜 z) : same_ray 𝕜 (x - y) (z - x) :=\n  by\n  rw [segment_eq_image'] at h\n  rcases h with ⟨θ, ⟨hθ₀, hθ₁⟩, rfl⟩\n  simpa only [add_sub_cancel', ← sub_sub, sub_smul, one_smul] using\n    (same_ray_nonneg_smul_left (z - y) hθ₀).nonneg_smul_right (sub_nonneg.2 hθ₁)\n#align same_ray_of_mem_segment same_ray_of_mem_segment\n\n",
 "right_mem_segment":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `segment -/\ntheorem right_mem_segment (x y : E) : y ∈ segment x 𝕜 y :=\n  segment_symm 𝕜 y x ▸ left_mem_segment 𝕜 y x\n#align right_mem_segment right_mem_segment\n\n",
 "right_mem_open_segment_iff":
 "@[simp]\ntheorem right_mem_open_segment_iff [DenselyOrdered 𝕜] [NoZeroSMulDivisors 𝕜 E] : y ∈ open_segment 𝕜 x y ↔ x = y := by\n  rw [open_segment_symm, left_mem_open_segment_iff, eq_comm]\n#align right_mem_open_segment_iff right_mem_open_segment_iff\n\n",
 "open_segment_translate_preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem open_segment_translate_preimage (a b c : E) :\n    «expr ⁻¹' » (fun x => a + x) (open_segment 𝕜 (a + b) (a + c)) = open_segment 𝕜 b c :=\n  Set.ext fun x => mem_open_segment_translate 𝕜 a\n#align open_segment_translate_preimage open_segment_translate_preimage\n\n",
 "open_segment_translate_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem open_segment_translate_image (a b c : E) :\n    «expr '' » (fun x => a + x) (open_segment 𝕜 b c) = open_segment 𝕜 (a + b) (a + c) :=\n  open_segment_translate_preimage 𝕜 a b c ▸ image_preimage_eq _ <| add_left_surjective a\n#align open_segment_translate_image open_segment_translate_image\n\n",
 "open_segment_symm":
 "theorem open_segment_symm (x y : E) : open_segment 𝕜 x y = open_segment 𝕜 y x :=\n  Set.ext fun z =>\n    ⟨fun ⟨a, b, ha, hb, hab, H⟩ => ⟨b, a, hb, ha, (add_comm _ _).trans hab, (add_comm _ _).trans H⟩,\n      fun ⟨a, b, ha, hb, hab, H⟩ => ⟨b, a, hb, ha, (add_comm _ _).trans hab, (add_comm _ _).trans H⟩⟩\n#align open_segment_symm open_segment_symm\n\n",
 "open_segment_subset_union":
 "/-- If `z = line_map x y c` is a point on the line passing through `x` and `y`, then the open\nsegment `open_segment 𝕜 x y` is included in the union of the open segments `open_segment 𝕜 x z`,\n`open_segment 𝕜 z y`, and the point `z`. Informally, `(x, y) ⊆ {z} ∪ (x, z) ∪ (z, y)`. -/\ntheorem open_segment_subset_union (x y : E) {z : E} (hz : z ∈ range (line_map x y : 𝕜 → E)) :\n    open_segment 𝕜 x y ⊆ insert z (open_segment 𝕜 x z ∪ open_segment 𝕜 z y) :=\n  by\n  rcases hz with ⟨c, rfl⟩\n  simp only [open_segment_eq_image_line_map, ← maps_to']\n  rintro a ⟨h₀, h₁⟩\n  rcases lt_trichotomy a c with (hac | rfl | hca)\n  · right\n    left\n    have hc : 0 < c := h₀.trans hac\n    refine' ⟨a / c, ⟨div_pos h₀ hc, (div_lt_one hc).2 hac⟩, _⟩\n    simp only [← homothety_eq_line_map, ← homothety_mul_apply, div_mul_cancel _ hc.ne']\n  · left\n    rfl\n  · right\n    right\n    have hc : 0 < 1 - c := sub_pos.2 (hca.trans h₁)\n    simp only [← line_map_apply_one_sub y]\n    refine' ⟨(a - c) / (1 - c), ⟨div_pos (sub_pos.2 hca) hc, (div_lt_one hc).2 <| sub_lt_sub_right h₁ _⟩, _⟩\n    simp only [← homothety_eq_line_map, ← homothety_mul_apply, sub_mul, one_mul, div_mul_cancel _ hc.ne',\n      sub_sub_sub_cancel_right]\n#align open_segment_subset_union open_segment_subset_union\n\n",
 "open_segment_subset_segment":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `segment -/\ntheorem open_segment_subset_segment (x y : E) : open_segment 𝕜 x y ⊆ segment x 𝕜 y := fun z ⟨a, b, ha, hb, hab, hz⟩ =>\n  ⟨a, b, ha.le, hb.le, hab, hz⟩\n#align open_segment_subset_segment open_segment_subset_segment\n\n",
 "open_segment_subset_iff_segment_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `segment -/\ntheorem open_segment_subset_iff_segment_subset (hx : x ∈ s) (hy : y ∈ s) : open_segment 𝕜 x y ⊆ s ↔ segment x 𝕜 y ⊆ s :=\n  by simp only [← insert_endpoints_open_segment, insert_subset, *, true_and_iff]\n#align open_segment_subset_iff_segment_subset open_segment_subset_iff_segment_subset\n\n",
 "open_segment_subset_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem open_segment_subset_iff :\n    open_segment 𝕜 x y ⊆ s ↔ ∀ a b : 𝕜, 0 < a → 0 < b → a + b = 1 → «expr • » a x + «expr • » b y ∈ s :=\n  ⟨fun H a b ha hb hab => H ⟨a, b, ha, hb, hab, rfl⟩, fun H z ⟨a, b, ha, hb, hab, hz⟩ => hz ▸ H a b ha hb hab⟩\n#align open_segment_subset_iff open_segment_subset_iff\n\n",
 "open_segment_subset_Ioo":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem open_segment_subset_Ioo (h : x < y) : open_segment 𝕜 x y ⊆ Ioo x y :=\n  by\n  rintro z ⟨a, b, ha, hb, hab, rfl⟩\n  constructor\n  calc\n    x = «expr • » a x + «expr • » b x := (Convex.combo_self hab _).symm\n    _ < «expr • » a x + «expr • » b y := add_lt_add_left (smul_lt_smul_of_pos h hb) _\n    \n  calc\n    «expr • » a x + «expr • » b y < «expr • » a y + «expr • » b y := add_lt_add_right (smul_lt_smul_of_pos h ha) _\n    _ = y := Convex.combo_self hab _\n    \n#align open_segment_subset_Ioo open_segment_subset_Ioo\n\n",
 "open_segment_same":
 "@[simp]\ntheorem open_segment_same (x : E) : open_segment 𝕜 x x = {x} :=\n  Set.ext fun z =>\n    ⟨fun ⟨a, b, ha, hb, hab, hz⟩ => by simpa only [← add_smul, mem_singleton_iff, hab, one_smul, eq_comm] using hz,\n      fun h : z = x => by\n      obtain ⟨a, ha₀, ha₁⟩ := densely_ordered.dense (0 : 𝕜) 1 zero_lt_one\n      refine' ⟨a, 1 - a, ha₀, sub_pos_of_lt ha₁, add_sub_cancel'_right _ _, _⟩\n      rw [← add_smul, add_sub_cancel'_right, one_smul, h]⟩\n#align open_segment_same open_segment_same\n\n",
 "open_segment_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n@[simp]\ntheorem open_segment_image (f : «expr →ₗ[ ] » E 𝕜 F) (a b : E) :\n    «expr '' » f (open_segment 𝕜 a b) = open_segment 𝕜 (f a) (f b) :=\n  Set.ext fun x => by simp_rw [open_segment_eq_image, mem_image, exists_exists_and_eq_and, map_add, map_smul]\n#align open_segment_image open_segment_image\n\n",
 "open_segment_eq_image₂":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem open_segment_eq_image₂ (x y : E) :\n    open_segment 𝕜 x y =\n      «expr '' » (fun p : 𝕜 × 𝕜 => «expr • » p.1 x + «expr • » p.2 y) { p | 0 < p.1 ∧ 0 < p.2 ∧ p.1 + p.2 = 1 } :=\n  by simp only [open_segment, image, prod.exists, mem_set_of_eq, exists_prop, and_assoc']\n#align open_segment_eq_image₂ open_segment_eq_image₂\n\n",
 "open_segment_eq_image_line_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem open_segment_eq_image_line_map (x y : E) :\n    open_segment 𝕜 x y = «expr '' » (affine_map.line_map x y) (Ioo (0 : 𝕜) 1) :=\n  by\n  convert open_segment_eq_image 𝕜 x y\n  ext\n  exact affine_map.line_map_apply_module _ _ _\n#align open_segment_eq_image_line_map open_segment_eq_image_line_map\n\n",
 "open_segment_eq_image'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem open_segment_eq_image' (x y : E) :\n    open_segment 𝕜 x y = «expr '' » (fun θ : 𝕜 => x + «expr • » θ (y - x)) (Ioo (0 : 𝕜) 1) :=\n  by\n  convert open_segment_eq_image 𝕜 x y\n  ext θ\n  simp only [smul_sub, sub_smul, one_smul]\n  abel\n#align open_segment_eq_image' open_segment_eq_image'\n\n",
 "open_segment_eq_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem open_segment_eq_image (x y : E) :\n    open_segment 𝕜 x y = «expr '' » (fun θ : 𝕜 => «expr • » (1 - θ) x + «expr • » θ y) (Ioo (0 : 𝕜) 1) :=\n  Set.ext fun z =>\n    ⟨fun ⟨a, b, ha, hb, hab, hz⟩ => ⟨b, ⟨hb, hab ▸ lt_add_of_pos_left _ ha⟩, hab ▸ hz ▸ by simp only [add_sub_cancel]⟩,\n      fun ⟨θ, ⟨hθ₀, hθ₁⟩, hz⟩ => ⟨1 - θ, θ, sub_pos.2 hθ₁, hθ₀, sub_add_cancel _ _, hz⟩⟩\n#align open_segment_eq_image open_segment_eq_image\n\n",
 "open_segment_eq_Ioo'":
 "theorem open_segment_eq_Ioo' (hxy : x ≠ y) : open_segment 𝕜 x y = Ioo (min x y) (max x y) :=\n  by\n  cases hxy.lt_or_lt\n  · rw [open_segment_eq_Ioo h, max_eq_right h.le, min_eq_left h.le]\n  · rw [open_segment_symm, open_segment_eq_Ioo h, max_eq_left h.le, min_eq_right h.le]\n#align open_segment_eq_Ioo' open_segment_eq_Ioo'\n\n",
 "open_segment_eq_Ioo":
 "@[simp]\ntheorem open_segment_eq_Ioo (h : x < y) : open_segment 𝕜 x y = Ioo x y :=\n  (open_segment_subset_Ioo h).antisymm Ioo_subset_open_segment\n#align open_segment_eq_Ioo open_segment_eq_Ioo\n\n",
 "min_le_combo":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem convex.min_le_combo (x y : E) (ha : 0 ≤ a) (hb : 0 ≤ b) (hab : a + b = 1) :\n    min x y ≤ «expr • » a x + «expr • » b y :=\n  (segment_subset_uIcc x y ⟨_, _, ha, hb, hab, rfl⟩).1\n#align convex.min_le_combo convex.min_le_combo\n\n",
 "midpoint_mem_segment":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⅟» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `segment -/\ntheorem midpoint_mem_segment [Invertible (2 : 𝕜)] (x y : E) : midpoint 𝕜 x y ∈ segment x 𝕜 y :=\n  by\n  rw [segment_eq_image_line_map]\n  exact ⟨(«expr⅟») 2, ⟨inv_of_nonneg.mpr zero_le_two, invOf_le_one one_le_two⟩, rfl⟩\n#align midpoint_mem_segment midpoint_mem_segment\n\n",
 "mem_segment_translate":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `segment -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `segment -/\ntheorem mem_segment_translate (a : E) {x b c} : a + x ∈ segment (a + b) 𝕜 (a + c) ↔ x ∈ segment b 𝕜 c :=\n  by\n  rw [segment_eq_image', segment_eq_image']\n  refine' exists_congr fun θ => and_congr iff.rfl _\n  simp only [add_sub_add_left_eq_sub, add_assoc, add_right_inj]\n#align mem_segment_translate mem_segment_translate\n\n",
 "mem_segment_sub_add":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `segment -/\ntheorem mem_segment_sub_add [Invertible (2 : 𝕜)] (x y : E) : x ∈ segment (x - y) 𝕜 (x + y) :=\n  by\n  convert @midpoint_mem_segment 𝕜 _ _ _ _ _ _ _\n  rw [midpoint_sub_add]\n#align mem_segment_sub_add mem_segment_sub_add\n\n",
 "mem_segment_iff_same_ray":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `segment -/\ntheorem mem_segment_iff_same_ray : x ∈ segment y 𝕜 z ↔ same_ray 𝕜 (x - y) (z - x) :=\n  by\n  refine' ⟨same_ray_of_mem_segment, fun h => _⟩\n  rcases h.exists_eq_smul_add with ⟨a, b, ha, hb, hab, hxy, hzx⟩\n  rw [add_comm, sub_add_sub_cancel] at hxy hzx\n  rw [← mem_segment_translate _ (-x), neg_add_self]\n  refine' ⟨b, a, hb, ha, add_comm a b ▸ hab, _⟩\n  rw [← sub_eq_neg_add, ← neg_sub, hxy, ← sub_eq_neg_add, hzx, smul_neg, smul_comm, neg_add_self]\n#align mem_segment_iff_same_ray mem_segment_iff_same_ray\n\n",
 "mem_segment_iff_div":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `segment -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem mem_segment_iff_div :\n    x ∈ segment y 𝕜 z ↔\n      ∃ a b : 𝕜, 0 ≤ a ∧ 0 ≤ b ∧ 0 < a + b ∧ «expr • » (a / (a + b)) y + «expr • » (b / (a + b)) z = x :=\n  by\n  constructor\n  · rintro ⟨a, b, ha, hb, hab, rfl⟩\n    use a, b, ha, hb\n    simp [*]\n  · rintro ⟨a, b, ha, hb, hab, rfl⟩\n    refine' ⟨a / (a + b), b / (a + b), div_nonneg ha hab.le, div_nonneg hb hab.le, _, rfl⟩\n    rw [← add_div, div_self hab.ne']\n#align mem_segment_iff_div mem_segment_iff_div\n\n",
 "mem_segment_add_sub":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `segment -/\ntheorem mem_segment_add_sub [Invertible (2 : 𝕜)] (x y : E) : x ∈ segment (x + y) 𝕜 (x - y) :=\n  by\n  convert @midpoint_mem_segment 𝕜 _ _ _ _ _ _ _\n  rw [midpoint_add_sub]\n#align mem_segment_add_sub mem_segment_add_sub\n\n",
 "mem_open_segment_translate":
 "@[simp]\ntheorem mem_open_segment_translate (a : E) {x b c : E} :\n    a + x ∈ open_segment 𝕜 (a + b) (a + c) ↔ x ∈ open_segment 𝕜 b c :=\n  by\n  rw [open_segment_eq_image', open_segment_eq_image']\n  refine' exists_congr fun θ => and_congr iff.rfl _\n  simp only [add_sub_add_left_eq_sub, add_assoc, add_right_inj]\n#align mem_open_segment_translate mem_open_segment_translate\n\n",
 "mem_open_segment_of_ne_left_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `segment -/\ntheorem mem_open_segment_of_ne_left_right (hx : x ≠ z) (hy : y ≠ z) (hz : z ∈ segment x 𝕜 y) : z ∈ open_segment 𝕜 x y :=\n  by\n  rw [← insert_endpoints_open_segment] at hz\n  exact (hz.resolve_left hx.symm).resolve_left hy.symm\n#align mem_open_segment_of_ne_left_right mem_open_segment_of_ne_left_right\n\n",
 "mem_open_segment_iff_div":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem mem_open_segment_iff_div :\n    x ∈ open_segment 𝕜 y z ↔ ∃ a b : 𝕜, 0 < a ∧ 0 < b ∧ «expr • » (a / (a + b)) y + «expr • » (b / (a + b)) z = x :=\n  by\n  constructor\n  · rintro ⟨a, b, ha, hb, hab, rfl⟩\n    use a, b, ha, hb\n    rw [hab, div_one, div_one]\n  · rintro ⟨a, b, ha, hb, rfl⟩\n    have hab : 0 < a + b := by positivity\n    refine' ⟨a / (a + b), b / (a + b), by positivity, by positivity, _, rfl⟩\n    rw [← add_div, div_self hab.ne']\n#align mem_open_segment_iff_div mem_open_segment_iff_div\n\n",
 "mem_Ioo":
 "/-- A point is in an `Ioo` iff it can be expressed as a strict convex combination of the endpoints.\n-/\ntheorem convex.mem_Ioo (h : x < y) : z ∈ Ioo x y ↔ ∃ a b, 0 < a ∧ 0 < b ∧ a + b = 1 ∧ a * x + b * y = z :=\n  by\n  rw [← open_segment_eq_Ioo h]\n  simp_rw [← exists_prop]\n  rfl\n#align convex.mem_Ioo convex.mem_Ioo\n\n",
 "mem_Ioc":
 "/-- A point is in an `Ioc` iff it can be expressed as a semistrict convex combination of the\nendpoints. -/\ntheorem convex.mem_Ioc (h : x < y) : z ∈ Ioc x y ↔ ∃ a b, 0 ≤ a ∧ 0 < b ∧ a + b = 1 ∧ a * x + b * y = z :=\n  by\n  refine' ⟨fun hz => _, _⟩\n  · obtain ⟨a, b, ha, hb, hab, rfl⟩ := (convex.mem_Icc h.le).1 (Ioc_subset_Icc_self hz)\n    obtain rfl | hb' := hb.eq_or_lt\n    · rw [add_zero] at hab\n      rw [hab, one_mul, zero_mul, add_zero] at hz\n      exact (hz.1.ne rfl).elim\n    · exact ⟨a, b, ha, hb', hab, rfl⟩\n  · rintro ⟨a, b, ha, hb, hab, rfl⟩\n    obtain rfl | ha' := ha.eq_or_lt\n    · rw [zero_add] at hab\n      rwa [hab, one_mul, zero_mul, zero_add, right_mem_Ioc]\n    · exact Ioo_subset_Ioc_self ((convex.mem_Ioo h).2 ⟨a, b, ha', hb, hab, rfl⟩)\n#align convex.mem_Ioc convex.mem_Ioc\n\n",
 "mem_Ico":
 "/-- A point is in an `Ico` iff it can be expressed as a semistrict convex combination of the\nendpoints. -/\ntheorem convex.mem_Ico (h : x < y) : z ∈ Ico x y ↔ ∃ a b, 0 < a ∧ 0 ≤ b ∧ a + b = 1 ∧ a * x + b * y = z :=\n  by\n  refine' ⟨fun hz => _, _⟩\n  · obtain ⟨a, b, ha, hb, hab, rfl⟩ := (convex.mem_Icc h.le).1 (Ico_subset_Icc_self hz)\n    obtain rfl | ha' := ha.eq_or_lt\n    · rw [zero_add] at hab\n      rw [hab, one_mul, zero_mul, zero_add] at hz\n      exact (hz.2.ne rfl).elim\n    · exact ⟨a, b, ha', hb, hab, rfl⟩\n  · rintro ⟨a, b, ha, hb, hab, rfl⟩\n    obtain rfl | hb' := hb.eq_or_lt\n    · rw [add_zero] at hab\n      rwa [hab, one_mul, zero_mul, add_zero, left_mem_Ico]\n    · exact Ioo_subset_Ico_self ((convex.mem_Ioo h).2 ⟨a, b, ha, hb', hab, rfl⟩)\n#align convex.mem_Ico convex.mem_Ico\n\n",
 "mem_Icc":
 "/-- A point is in an `Icc` iff it can be expressed as a convex combination of the endpoints. -/\ntheorem convex.mem_Icc (h : x ≤ y) : z ∈ Icc x y ↔ ∃ a b, 0 ≤ a ∧ 0 ≤ b ∧ a + b = 1 ∧ a * x + b * y = z :=\n  by\n  rw [← segment_eq_Icc h]\n  simp_rw [← exists_prop]\n  rfl\n#align convex.mem_Icc convex.mem_Icc\n\n",
 "left_mem_segment":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `segment -/\ntheorem left_mem_segment (x y : E) : x ∈ segment x 𝕜 y :=\n  ⟨1, 0, zero_le_one, le_refl 0, add_zero 1, by rw [zero_smul, one_smul, add_zero]⟩\n#align left_mem_segment left_mem_segment\n\n",
 "left_mem_open_segment_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem left_mem_open_segment_iff [DenselyOrdered 𝕜] [NoZeroSMulDivisors 𝕜 E] : x ∈ open_segment 𝕜 x y ↔ x = y :=\n  by\n  constructor\n  · rintro ⟨a, b, ha, hb, hab, hx⟩\n    refine' smul_right_injective _ hb.ne' ((add_right_inj («expr • » a x)).1 _)\n    rw [hx, ← add_smul, hab, one_smul]\n  · rintro rfl\n    rw [open_segment_same]\n    exact mem_singleton _\n#align left_mem_open_segment_iff left_mem_open_segment_iff\n\n",
 "insert_endpoints_open_segment":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `segment -/\ntheorem insert_endpoints_open_segment (x y : E) : insert x (insert y (open_segment 𝕜 x y)) = segment x 𝕜 y :=\n  by\n  simp only [subset_antisymm_iff, insert_subset, left_mem_segment, right_mem_segment, open_segment_subset_segment,\n    true_and_iff]\n  rintro z ⟨a, b, ha, hb, hab, rfl⟩\n  refine' hb.eq_or_gt.imp _ fun hb' => ha.eq_or_gt.imp _ fun ha' => _\n  · rintro rfl\n    rw [← add_zero a, hab, one_smul, zero_smul, add_zero]\n  · rintro rfl\n    rw [← zero_add b, hab, one_smul, zero_smul, zero_add]\n  · exact ⟨a, b, ha', hb', hab, rfl⟩\n#align insert_endpoints_open_segment insert_endpoints_open_segment\n\n",
 "combo_le_max":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem convex.combo_le_max (x y : E) (ha : 0 ≤ a) (hb : 0 ≤ b) (hab : a + b = 1) :\n    «expr • » a x + «expr • » b y ≤ max x y :=\n  (segment_subset_uIcc x y ⟨_, _, ha, hb, hab, rfl⟩).2\n#align convex.combo_le_max convex.combo_le_max\n\n",
 "Ioo_subset_open_segment":
 "theorem Ioo_subset_open_segment : Ioo x y ⊆ open_segment 𝕜 x y := fun z hz =>\n  mem_open_segment_of_ne_left_right hz.1.ne hz.2.ne' <| Icc_subset_segment <| Ioo_subset_Icc_self hz\n#align Ioo_subset_open_segment Ioo_subset_open_segment\n\n",
 "Icc_subset_segment":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `segment -/\ntheorem Icc_subset_segment : Icc x y ⊆ segment x 𝕜 y :=\n  by\n  rintro z ⟨hxz, hyz⟩\n  obtain rfl | h := (hxz.trans hyz).eq_or_lt\n  · rw [segment_same]\n    exact hyz.antisymm hxz\n  rw [← sub_nonneg] at hxz hyz\n  rw [← sub_pos] at h\n  refine' ⟨(y - z) / (y - x), (z - x) / (y - x), div_nonneg hyz h.le, div_nonneg hxz h.le, _, _⟩\n  · rw [← add_div, sub_add_sub_cancel, div_self h.ne']\n  ·\n    rw [smul_eq_mul, smul_eq_mul, ← mul_div_right_comm, ← mul_div_right_comm, ← add_div, div_eq_iff h.ne', add_comm,\n      sub_mul, sub_mul, mul_comm x, sub_add_sub_cancel, mul_sub]\n#align Icc_subset_segment Icc_subset_segment\n\n"}