{"subset_intrinsic_closure":
 "theorem subset_intrinsic_closure : s ⊆ intrinsic_closure 𝕜 s := fun x hx =>\n  ⟨⟨x, subset_affineSpan _ _ hx⟩, subset_closure hx, rfl⟩\n#align subset_intrinsic_closure subset_intrinsic_closure\n\n",
 "mem_intrinsic_interior":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/-\nCopyright (c) 2023 Paul Reichert. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Paul Reichert, Yaël Dillies\n-/\n@[simp]\ntheorem mem_intrinsic_interior :\n    x ∈ intrinsic_interior 𝕜 s ↔ ∃ y, y ∈ interior («expr ⁻¹' » coe s : Set <| affineSpan 𝕜 s) ∧ ↑y = x :=\n  mem_image _ _ _\n#align mem_intrinsic_interior mem_intrinsic_interior\n\n",
 "mem_intrinsic_frontier":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n@[simp]\ntheorem mem_intrinsic_frontier :\n    x ∈ intrinsic_frontier 𝕜 s ↔ ∃ y, y ∈ frontier («expr ⁻¹' » coe s : Set <| affineSpan 𝕜 s) ∧ ↑y = x :=\n  mem_image _ _ _\n#align mem_intrinsic_frontier mem_intrinsic_frontier\n\n",
 "mem_intrinsic_closure":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n@[simp]\ntheorem mem_intrinsic_closure :\n    x ∈ intrinsic_closure 𝕜 s ↔ ∃ y, y ∈ closure («expr ⁻¹' » coe s : Set <| affineSpan 𝕜 s) ∧ ↑y = x :=\n  mem_image _ _ _\n#align mem_intrinsic_closure mem_intrinsic_closure\n\n",
 "is_closed_intrinsic_frontier":
 "theorem is_closed_intrinsic_frontier (hs : IsClosed (affineSpan 𝕜 s : Set P)) : IsClosed (intrinsic_frontier 𝕜 s) :=\n  (closedEmbedding_subtype_val hs).is_closed_map _ isClosed_frontier\n#align is_closed_intrinsic_frontier is_closed_intrinsic_frontier\n\n",
 "is_closed_intrinsic_closure":
 "theorem is_closed_intrinsic_closure (hs : IsClosed (affineSpan 𝕜 s : Set P)) : IsClosed (intrinsic_closure 𝕜 s) :=\n  (closedEmbedding_subtype_val hs).is_closed_map _ isClosed_closure\n#align is_closed_intrinsic_closure is_closed_intrinsic_closure\n\n",
 "intrinsic_interior_union_intrinsic_frontier":
 "@[simp]\ntheorem intrinsic_interior_union_intrinsic_frontier (s : Set P) :\n    intrinsic_interior 𝕜 s ∪ intrinsic_frontier 𝕜 s = intrinsic_closure 𝕜 s := by\n  simp [intrinsic_closure, intrinsic_interior, intrinsic_frontier, closure_eq_interior_union_frontier, image_union]\n#align intrinsic_interior_union_intrinsic_frontier intrinsic_interior_union_intrinsic_frontier\n\n",
 "intrinsic_interior_subset":
 "theorem intrinsic_interior_subset : intrinsic_interior 𝕜 s ⊆ s :=\n  image_subset_iff.2 interior_subset\n#align intrinsic_interior_subset intrinsic_interior_subset\n\n",
 "intrinsic_interior_singleton":
 "@[simp]\ntheorem intrinsic_interior_singleton (x : P) : intrinsic_interior 𝕜 ({x} : Set P) = {x} := by\n  simpa only [intrinsic_interior, preimage_coe_affine_span_singleton, interior_univ, image_univ,\n    Subtype.range_coe] using coe_affine_span_singleton _ _ _\n#align intrinsic_interior_singleton intrinsic_interior_singleton\n\n",
 "intrinsic_interior_nonempty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem intrinsic_interior_nonempty (hs : Convex (exprℝ) s) : (intrinsic_interior (exprℝ) s).nonempty ↔ s.nonempty :=\n  ⟨by\n    simp_rw [nonempty_iff_ne_empty]\n    rintro h rfl\n    exact h intrinsic_interior_empty, set.nonempty.intrinsic_interior hs⟩\n#align intrinsic_interior_nonempty intrinsic_interior_nonempty\n\n",
 "intrinsic_interior_empty":
 "@[simp]\ntheorem intrinsic_interior_empty : intrinsic_interior 𝕜 (∅ : Set P) = ∅ := by simp [intrinsic_interior]\n#align intrinsic_interior_empty intrinsic_interior_empty\n\n",
 "intrinsic_interior":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- The intrinsic interior of a nonempty convex set is nonempty. -/\nprotected theorem set.nonempty.intrinsic_interior (hscv : Convex (exprℝ) s) (hsne : s.nonempty) :\n    (intrinsic_interior (exprℝ) s).nonempty := by\n  haveI := hsne.coe_sort\n  obtain ⟨p, hp⟩ := hsne\n  let p' : affineSpan (exprℝ) s := ⟨p, subset_affineSpan _ _ hp⟩\n  rw [intrinsic_interior, nonempty_image_iff, aux (affine_isometry_equiv.const_vsub (exprℝ) p').symm.to_homeomorph,\n    convex.interior_nonempty_iff_affine_span_eq_top, affine_isometry_equiv.coe_to_homeomorph, ←\n    affine_isometry_equiv.coe_to_affine_equiv, ← comap_span, affineSpan_coe_preimage_eq_top, comap_top]\n  exact\n    hscv.affine_preimage\n      ((affineSpan (exprℝ) s).subtype.comp\n        (affine_isometry_equiv.const_vsub (exprℝ) p').symm.to_affine_equiv.to_affine_map)\n#align set.nonempty.intrinsic_interior set.nonempty.intrinsic_interior\n\n",
 "intrinsic_frontier_union_intrinsic_interior":
 "@[simp]\ntheorem intrinsic_frontier_union_intrinsic_interior (s : Set P) :\n    intrinsic_frontier 𝕜 s ∪ intrinsic_interior 𝕜 s = intrinsic_closure 𝕜 s := by\n  rw [union_comm, intrinsic_interior_union_intrinsic_frontier]\n#align intrinsic_frontier_union_intrinsic_interior intrinsic_frontier_union_intrinsic_interior\n\n",
 "intrinsic_frontier_subset_intrinsic_closure":
 "theorem intrinsic_frontier_subset_intrinsic_closure : intrinsic_frontier 𝕜 s ⊆ intrinsic_closure 𝕜 s :=\n  image_subset _ frontier_subset_closure\n#align intrinsic_frontier_subset_intrinsic_closure intrinsic_frontier_subset_intrinsic_closure\n\n",
 "intrinsic_frontier_subset_frontier":
 "theorem intrinsic_frontier_subset_frontier : intrinsic_frontier 𝕜 s ⊆ frontier s :=\n  image_subset_iff.2 <| continuous_subtype_val.frontier_preimage_subset _\n#align intrinsic_frontier_subset_frontier intrinsic_frontier_subset_frontier\n\n",
 "intrinsic_frontier_subset":
 "theorem intrinsic_frontier_subset (hs : IsClosed s) : intrinsic_frontier 𝕜 s ⊆ s :=\n  image_subset_iff.2 (hs.preimage continuous_induced_dom).frontier_subset\n#align intrinsic_frontier_subset intrinsic_frontier_subset\n\n",
 "intrinsic_frontier_singleton":
 "@[simp]\ntheorem intrinsic_frontier_singleton (x : P) : intrinsic_frontier 𝕜 ({x} : Set P) = ∅ := by\n  rw [intrinsic_frontier, preimage_coe_affine_span_singleton, frontier_univ, image_empty]\n#align intrinsic_frontier_singleton intrinsic_frontier_singleton\n\n",
 "intrinsic_frontier_empty":
 "@[simp]\ntheorem intrinsic_frontier_empty : intrinsic_frontier 𝕜 (∅ : Set P) = ∅ := by simp [intrinsic_frontier]\n#align intrinsic_frontier_empty intrinsic_frontier_empty\n\n",
 "intrinsic_closure_subset_closure":
 "theorem intrinsic_closure_subset_closure : intrinsic_closure 𝕜 s ⊆ closure s :=\n  image_subset_iff.2 <| continuous_subtype_val.closure_preimage_subset _\n#align intrinsic_closure_subset_closure intrinsic_closure_subset_closure\n\n",
 "intrinsic_closure_subset_affine_span":
 "theorem intrinsic_closure_subset_affine_span : intrinsic_closure 𝕜 s ⊆ affineSpan 𝕜 s :=\n  (image_subset_range _ _).trans Subtype.range_coe.subset\n#align intrinsic_closure_subset_affine_span intrinsic_closure_subset_affine_span\n\n",
 "intrinsic_closure_singleton":
 "@[simp]\ntheorem intrinsic_closure_singleton (x : P) : intrinsic_closure 𝕜 ({x} : Set P) = {x} := by\n  simpa only [intrinsic_closure, preimage_coe_affine_span_singleton, closure_univ, image_univ, Subtype.range_coe] using\n    coe_affine_span_singleton _ _ _\n#align intrinsic_closure_singleton intrinsic_closure_singleton\n\n",
 "intrinsic_closure_nonempty":
 "@[simp]\ntheorem intrinsic_closure_nonempty : (intrinsic_closure 𝕜 s).nonempty ↔ s.nonempty :=\n  ⟨by\n    simp_rw [nonempty_iff_ne_empty]\n    rintro h rfl\n    exact h intrinsic_closure_empty, Nonempty.mono subset_intrinsic_closure⟩\n#align intrinsic_closure_nonempty intrinsic_closure_nonempty\n\n",
 "intrinsic_closure_mono":
 "theorem intrinsic_closure_mono (h : s ⊆ t) : intrinsic_closure 𝕜 s ⊆ intrinsic_closure 𝕜 t :=\n  by\n  refine'\n    image_subset_iff.2 fun x hx =>\n      ⟨Set.inclusion (affineSpan_mono _ h) x, (continuous_inclusion _).closure_preimage_subset _ <| closure_mono _ hx,\n        rfl⟩\n  exact fun y hy => h hy\n#align intrinsic_closure_mono intrinsic_closure_mono\n\n",
 "intrinsic_closure_idem":
 "@[simp]\ntheorem intrinsic_closure_idem (s : Set P) : intrinsic_closure 𝕜 (intrinsic_closure 𝕜 s) = intrinsic_closure 𝕜 s :=\n  by\n  refine' is_closed.intrinsic_closure _\n  set t := affineSpan 𝕜 (intrinsic_closure 𝕜 s) with ht\n  clear_value t\n  obtain rfl := ht.trans (affine_span_intrinsic_closure _)\n  rw [intrinsic_closure, preimage_image_eq _ Subtype.coe_injective]\n  exact isClosed_closure\n#align intrinsic_closure_idem intrinsic_closure_idem\n\n",
 "intrinsic_closure_eq_closure":
 "@[simp]\ntheorem intrinsic_closure_eq_closure : intrinsic_closure 𝕜 s = closure s :=\n  by\n  ext x\n  simp only [mem_closure_iff, mem_intrinsic_closure]\n  refine' ⟨_, fun h => ⟨⟨x, _⟩, _, Subtype.coe_mk _ _⟩⟩\n  · rintro ⟨x, h, rfl⟩ t ht hx\n    obtain ⟨z, hz₁, hz₂⟩ := h _ (continuous_induced_dom.is_open_preimage t ht) hx\n    exact ⟨z, hz₁, hz₂⟩\n  · by_contra hc\n    obtain ⟨z, hz₁, hz₂⟩ := h _ (affineSpan 𝕜 s).closed_of_finite_dimensional.is_open_compl hc\n    exact hz₁ (subset_affineSpan 𝕜 s hz₂)\n  · rintro _ ⟨t, ht, rfl⟩ hx\n    obtain ⟨y, hyt, hys⟩ := h _ ht hx\n    exact ⟨⟨_, subset_affineSpan 𝕜 s hys⟩, hyt, hys⟩\n#align intrinsic_closure_eq_closure intrinsic_closure_eq_closure\n\n",
 "intrinsic_closure_empty":
 "@[simp]\ntheorem intrinsic_closure_empty : intrinsic_closure 𝕜 (∅ : Set P) = ∅ := by simp [intrinsic_closure]\n#align intrinsic_closure_empty intrinsic_closure_empty\n\n",
 "intrinsic_closure_diff_intrinsic_interior":
 "@[simp]\ntheorem intrinsic_closure_diff_intrinsic_interior (s : Set P) :\n    intrinsic_closure 𝕜 s \\ intrinsic_interior 𝕜 s = intrinsic_frontier 𝕜 s :=\n  (image_diff Subtype.coe_injective _ _).symm\n#align intrinsic_closure_diff_intrinsic_interior intrinsic_closure_diff_intrinsic_interior\n\n",
 "intrinsic_closure_diff_intrinsic_frontier":
 "@[simp]\ntheorem intrinsic_closure_diff_intrinsic_frontier (s : Set P) :\n    intrinsic_closure 𝕜 s \\ intrinsic_frontier 𝕜 s = intrinsic_interior 𝕜 s :=\n  (image_diff Subtype.coe_injective _ _).symm.trans <| by rw [closure_diff_frontier, intrinsic_interior]\n#align intrinsic_closure_diff_intrinsic_frontier intrinsic_closure_diff_intrinsic_frontier\n\n",
 "intrinsic_closure":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\nprotected theorem is_closed.intrinsic_closure (hs : IsClosed («expr ⁻¹' » coe s : Set <| affineSpan 𝕜 s)) :\n    intrinsic_closure 𝕜 s = s :=\n  by\n  rw [intrinsic_closure, hs.closure_eq, image_preimage_eq_of_subset]\n  exact (subset_affineSpan _ _).trans subtype.range_coe.superset\n#align is_closed.intrinsic_closure is_closed.intrinsic_closure\n\n",
 "interior_subset_intrinsic_interior":
 "theorem interior_subset_intrinsic_interior : interior s ⊆ intrinsic_interior 𝕜 s := fun x hx =>\n  ⟨⟨x, subset_affineSpan _ _ <| interior_subset hx⟩,\n    preimage_interior_subset_interior_preimage continuous_subtype_val hx, rfl⟩\n#align interior_subset_intrinsic_interior interior_subset_intrinsic_interior\n\n",
 "image_intrinsic_interior":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ᵃⁱ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n@[simp]\ntheorem image_intrinsic_interior (φ : «expr →ᵃⁱ[ ] » P 𝕜 Q) (s : Set P) :\n    intrinsic_interior 𝕜 («expr '' » φ s) = «expr '' » φ (intrinsic_interior 𝕜 s) :=\n  by\n  obtain rfl | hs := s.eq_empty_or_nonempty\n  · simp only [intrinsic_interior_empty, image_empty]\n  haveI : Nonempty s := hs.to_subtype\n  let f := ((affineSpan 𝕜 s).isometry_equiv_map φ).to_homeomorph\n  have : φ.to_affine_map ∘ coe ∘ f.symm = coe := funext isometry_equiv_map.apply_symm_apply\n  rw [intrinsic_interior, intrinsic_interior, ← φ.coe_to_affine_map, ← map_span φ.to_affine_map s, ← this, ←\n    function.comp.assoc, image_comp, image_comp, f.symm.image_interior, f.image_symm, ← preimage_comp,\n    function.comp.assoc, f.symm_comp_self, affine_isometry.coe_to_affine_map, function.comp.right_id, preimage_comp,\n    φ.injective.preimage_image]\n#align image_intrinsic_interior image_intrinsic_interior\n\n",
 "image_intrinsic_frontier":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ᵃⁱ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n@[simp]\ntheorem image_intrinsic_frontier (φ : «expr →ᵃⁱ[ ] » P 𝕜 Q) (s : Set P) :\n    intrinsic_frontier 𝕜 («expr '' » φ s) = «expr '' » φ (intrinsic_frontier 𝕜 s) :=\n  by\n  obtain rfl | hs := s.eq_empty_or_nonempty\n  · simp\n  haveI : Nonempty s := hs.to_subtype\n  let f := ((affineSpan 𝕜 s).isometry_equiv_map φ).to_homeomorph\n  have : φ.to_affine_map ∘ coe ∘ f.symm = coe := funext isometry_equiv_map.apply_symm_apply\n  rw [intrinsic_frontier, intrinsic_frontier, ← φ.coe_to_affine_map, ← map_span φ.to_affine_map s, ← this, ←\n    function.comp.assoc, image_comp, image_comp, f.symm.image_frontier, f.image_symm, ← preimage_comp,\n    function.comp.assoc, f.symm_comp_self, affine_isometry.coe_to_affine_map, function.comp.right_id, preimage_comp,\n    φ.injective.preimage_image]\n#align image_intrinsic_frontier image_intrinsic_frontier\n\n",
 "image_intrinsic_closure":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ᵃⁱ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n@[simp]\ntheorem image_intrinsic_closure (φ : «expr →ᵃⁱ[ ] » P 𝕜 Q) (s : Set P) :\n    intrinsic_closure 𝕜 («expr '' » φ s) = «expr '' » φ (intrinsic_closure 𝕜 s) :=\n  by\n  obtain rfl | hs := s.eq_empty_or_nonempty\n  · simp\n  haveI : Nonempty s := hs.to_subtype\n  let f := ((affineSpan 𝕜 s).isometry_equiv_map φ).to_homeomorph\n  have : φ.to_affine_map ∘ coe ∘ f.symm = coe := funext isometry_equiv_map.apply_symm_apply\n  rw [intrinsic_closure, intrinsic_closure, ← φ.coe_to_affine_map, ← map_span φ.to_affine_map s, ← this, ←\n    function.comp.assoc, image_comp, image_comp, f.symm.image_closure, f.image_symm, ← preimage_comp,\n    function.comp.assoc, f.symm_comp_self, affine_isometry.coe_to_affine_map, function.comp.right_id, preimage_comp,\n    φ.injective.preimage_image]\n#align image_intrinsic_closure image_intrinsic_closure\n\n",
 "closure_diff_intrinsic_interior":
 "@[simp]\ntheorem closure_diff_intrinsic_interior (s : Set P) : closure s \\ intrinsic_interior 𝕜 s = intrinsic_frontier 𝕜 s :=\n  intrinsic_closure_eq_closure 𝕜 s ▸ intrinsic_closure_diff_intrinsic_interior s\n#align closure_diff_intrinsic_interior closure_diff_intrinsic_interior\n\n",
 "closure_diff_intrinsic_frontier":
 "@[simp]\ntheorem closure_diff_intrinsic_frontier (s : Set P) : closure s \\ intrinsic_frontier 𝕜 s = intrinsic_interior 𝕜 s :=\n  intrinsic_closure_eq_closure 𝕜 s ▸ intrinsic_closure_diff_intrinsic_frontier s\n#align closure_diff_intrinsic_frontier closure_diff_intrinsic_frontier\n\n",
 "aux":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₜ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\nprivate theorem aux {α β : Type _} [TopologicalSpace α] [TopologicalSpace β] (φ : «expr ≃ₜ » α β) (s : Set β) :\n    (interior s).nonempty ↔ (interior («expr ⁻¹' » φ s)).nonempty := by\n  rw [← φ.image_symm, ← φ.symm.image_interior, nonempty_image_iff]\n#align aux aux\n\n",
 "affine_span_intrinsic_closure":
 "@[simp]\ntheorem affine_span_intrinsic_closure (s : Set P) : affineSpan 𝕜 (intrinsic_closure 𝕜 s) = affineSpan 𝕜 s :=\n  (affineSpan_le.2 intrinsic_closure_subset_affine_span).antisymm <| affineSpan_mono _ subset_intrinsic_closure\n#align affine_span_intrinsic_closure affine_span_intrinsic_closure\n\n"}