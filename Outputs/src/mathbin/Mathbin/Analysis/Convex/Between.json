{"wbtw_zero_one_iff":
 "@[simp]\ntheorem wbtw_zero_one_iff {x : R} : wbtw R 0 x 1 ↔ x ∈ Set.Icc (0 : R) 1 :=\n  by\n  simp_rw [wbtw, affine_segment, Set.mem_image, line_map_apply_ring]\n  simp\n#align wbtw_zero_one_iff wbtw_zero_one_iff\n\n",
 "wbtw_vsub_const_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n@[simp]\ntheorem wbtw_vsub_const_iff {x y z : P} (p : P) :\n    wbtw R («expr -ᵥ » x p) («expr -ᵥ » y p) («expr -ᵥ » z p) ↔ wbtw R x y z :=\n  mem_vsub_const_affine_segment _\n#align wbtw_vsub_const_iff wbtw_vsub_const_iff\n\n",
 "wbtw_vadd_const_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr +ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr +ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr +ᵥ » -/\n@[simp]\ntheorem wbtw_vadd_const_iff {x y z : V} (p : P) :\n    wbtw R («expr +ᵥ » x p) («expr +ᵥ » y p) («expr +ᵥ » z p) ↔ wbtw R x y z :=\n  mem_vadd_const_affine_segment _\n#align wbtw_vadd_const_iff wbtw_vadd_const_iff\n\n",
 "wbtw_swap_right_iff":
 "theorem wbtw_swap_right_iff [NoZeroSMulDivisors R V] (x : P) {y z : P} : wbtw R x y z ∧ wbtw R x z y ↔ y = z :=\n  by\n  nth_rw 1 [wbtw_comm]\n  nth_rw 2 [wbtw_comm]\n  rw [eq_comm]\n  exact wbtw_swap_left_iff R x\n#align wbtw_swap_right_iff wbtw_swap_right_iff\n\n",
 "wbtw_swap_left_iff":
 "theorem wbtw_swap_left_iff [NoZeroSMulDivisors R V] {x y : P} (z : P) : wbtw R x y z ∧ wbtw R y x z ↔ x = y :=\n  by\n  constructor\n  · rintro ⟨hxyz, hyxz⟩\n    rcases hxyz with ⟨ty, hty, rfl⟩\n    rcases hyxz with ⟨tx, htx, hx⟩\n    simp_rw [line_map_apply, ← add_vadd] at hx\n    rw [← @vsub_eq_zero_iff_eq V, vadd_vsub, vsub_vadd_eq_vsub_sub, smul_sub, smul_smul, ← sub_smul, ← add_smul,\n      smul_eq_zero] at hx\n    rcases hx with (h | h)\n    · nth_rw 1 [← mul_one tx] at h\n      rw [← mul_sub, add_eq_zero_iff_neg_eq] at h\n      have h' : ty = 0 := by\n        refine' le_antisymm _ hty.1\n        rw [← h, Left.neg_nonpos_iff]\n        exact mul_nonneg htx.1 (sub_nonneg.2 hty.2)\n      simp [h']\n    · rw [vsub_eq_zero_iff_eq] at h\n      simp [h]\n  · rintro rfl\n    exact ⟨wbtw_self_left _ _ _, wbtw_self_left _ _ _⟩\n#align wbtw_swap_left_iff wbtw_swap_left_iff\n\n",
 "wbtw_smul_vadd_smul_vadd_of_nonpos_of_nonneg":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr +ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr +ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr +ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem wbtw_smul_vadd_smul_vadd_of_nonpos_of_nonneg (x : P) (v : V) {r₁ r₂ : R} (hr₁ : r₁ ≤ 0) (hr₂ : 0 ≤ r₂) :\n    wbtw R («expr +ᵥ » («expr • » r₁ v) x) x («expr +ᵥ » («expr • » r₂ v) x) := by\n  convert wbtw_smul_vadd_smul_vadd_of_nonneg_of_le («expr +ᵥ » («expr • » r₁ v) x) v (Left.nonneg_neg_iff.2 hr₁)\n        (neg_le_sub_iff_le_add.2 ((le_add_iff_nonneg_left r₁).2 hr₂)) using\n      1 <;>\n    simp [sub_smul, ← add_vadd]\n#align wbtw_smul_vadd_smul_vadd_of_nonpos_of_nonneg wbtw_smul_vadd_smul_vadd_of_nonpos_of_nonneg\n\n",
 "wbtw_smul_vadd_smul_vadd_of_nonpos_of_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr +ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr +ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem wbtw_smul_vadd_smul_vadd_of_nonpos_of_le (x : P) (v : V) {r₁ r₂ : R} (hr₁ : r₁ ≤ 0) (hr₂ : r₂ ≤ r₁) :\n    wbtw R x («expr +ᵥ » («expr • » r₁ v) x) («expr +ᵥ » («expr • » r₂ v) x) := by\n  convert wbtw_smul_vadd_smul_vadd_of_nonneg_of_le x (-v) (Left.nonneg_neg_iff.2 hr₁) (neg_le_neg_iff.2 hr₂) using 1 <;>\n    rw [neg_smul_neg]\n#align wbtw_smul_vadd_smul_vadd_of_nonpos_of_le wbtw_smul_vadd_smul_vadd_of_nonpos_of_le\n\n",
 "wbtw_smul_vadd_smul_vadd_of_nonneg_of_nonpos":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr +ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr +ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem wbtw_smul_vadd_smul_vadd_of_nonneg_of_nonpos (x : P) (v : V) {r₁ r₂ : R} (hr₁ : 0 ≤ r₁) (hr₂ : r₂ ≤ 0) :\n    wbtw R («expr +ᵥ » («expr • » r₁ v) x) x («expr +ᵥ » («expr • » r₂ v) x) :=\n  by\n  rw [wbtw_comm]\n  exact wbtw_smul_vadd_smul_vadd_of_nonpos_of_nonneg x v hr₂ hr₁\n#align wbtw_smul_vadd_smul_vadd_of_nonneg_of_nonpos wbtw_smul_vadd_smul_vadd_of_nonneg_of_nonpos\n\n",
 "wbtw_smul_vadd_smul_vadd_of_nonneg_of_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr +ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr +ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem wbtw_smul_vadd_smul_vadd_of_nonneg_of_le (x : P) (v : V) {r₁ r₂ : R} (hr₁ : 0 ≤ r₁) (hr₂ : r₁ ≤ r₂) :\n    wbtw R x («expr +ᵥ » («expr • » r₁ v) x) («expr +ᵥ » («expr • » r₂ v) x) :=\n  by\n  refine' ⟨r₁ / r₂, ⟨div_nonneg hr₁ (hr₁.trans hr₂), div_le_one_of_le hr₂ (hr₁.trans hr₂)⟩, _⟩\n  by_cases h : r₁ = 0; · simp [h]\n  simp [line_map_apply, smul_smul, ((hr₁.lt_of_ne' h).trans_le hr₂).ne.symm]\n#align wbtw_smul_vadd_smul_vadd_of_nonneg_of_le wbtw_smul_vadd_smul_vadd_of_nonneg_of_le\n\n",
 "wbtw_self_right":
 "@[simp]\ntheorem wbtw_self_right (x y : P) : wbtw R x y y :=\n  right_mem_affine_segment _ _ _\n#align wbtw_self_right wbtw_self_right\n\n",
 "wbtw_self_left":
 "@[simp]\ntheorem wbtw_self_left (x y : P) : wbtw R x x y :=\n  left_mem_affine_segment _ _ _\n#align wbtw_self_left wbtw_self_left\n\n",
 "wbtw_self_iff":
 "@[simp]\ntheorem wbtw_self_iff {x y : P} : wbtw R x y x ↔ y = x :=\n  by\n  refine' ⟨fun h => _, fun h => _⟩\n  · simpa [wbtw, affine_segment] using h\n  · rw [h]\n    exact wbtw_self_left R x x\n#align wbtw_self_iff wbtw_self_iff\n\n",
 "wbtw_rotate_iff":
 "theorem wbtw_rotate_iff [NoZeroSMulDivisors R V] (x : P) {y z : P} : wbtw R x y z ∧ wbtw R z x y ↔ x = y := by\n  rw [wbtw_comm, wbtw_swap_right_iff, eq_comm]\n#align wbtw_rotate_iff wbtw_rotate_iff\n\n",
 "wbtw_point_reflection":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\ntheorem wbtw_point_reflection (x y : P) : wbtw R y x (pointReflection R x y) :=\n  by\n  refine' ⟨2⁻¹, ⟨by norm_num, by norm_num⟩, _⟩\n  rw [line_map_apply, point_reflection_apply, vadd_vsub_assoc, ← two_smul R («expr -ᵥ » x y)]\n  simp\n#align wbtw_point_reflection wbtw_point_reflection\n\n",
 "wbtw_or_wbtw_smul_vadd_of_nonpos":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr +ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr +ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr +ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr +ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem wbtw_or_wbtw_smul_vadd_of_nonpos (x : P) (v : V) {r₁ r₂ : R} (hr₁ : r₁ ≤ 0) (hr₂ : r₂ ≤ 0) :\n    wbtw R x («expr +ᵥ » («expr • » r₁ v) x) («expr +ᵥ » («expr • » r₂ v) x) ∨\n      wbtw R x («expr +ᵥ » («expr • » r₂ v) x) («expr +ᵥ » («expr • » r₁ v) x) :=\n  by\n  rcases le_total r₁ r₂ with (h | h)\n  · exact or.inr (wbtw_smul_vadd_smul_vadd_of_nonpos_of_le x v hr₂ h)\n  · exact or.inl (wbtw_smul_vadd_smul_vadd_of_nonpos_of_le x v hr₁ h)\n#align wbtw_or_wbtw_smul_vadd_of_nonpos wbtw_or_wbtw_smul_vadd_of_nonpos\n\n",
 "wbtw_or_wbtw_smul_vadd_of_nonneg":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr +ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr +ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr +ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr +ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem wbtw_or_wbtw_smul_vadd_of_nonneg (x : P) (v : V) {r₁ r₂ : R} (hr₁ : 0 ≤ r₁) (hr₂ : 0 ≤ r₂) :\n    wbtw R x («expr +ᵥ » («expr • » r₁ v) x) («expr +ᵥ » («expr • » r₂ v) x) ∨\n      wbtw R x («expr +ᵥ » («expr • » r₂ v) x) («expr +ᵥ » («expr • » r₁ v) x) :=\n  by\n  rcases le_total r₁ r₂ with (h | h)\n  · exact or.inl (wbtw_smul_vadd_smul_vadd_of_nonneg_of_le x v hr₁ h)\n  · exact or.inr (wbtw_smul_vadd_smul_vadd_of_nonneg_of_le x v hr₂ h)\n#align wbtw_or_wbtw_smul_vadd_of_nonneg wbtw_or_wbtw_smul_vadd_of_nonneg\n\n",
 "wbtw_or_wbtw_or_wbtw":
 "theorem collinear.wbtw_or_wbtw_or_wbtw {x y z : P} (h : Collinear R ({x, y, z} : Set P)) :\n    wbtw R x y z ∨ wbtw R y z x ∨ wbtw R z x y :=\n  by\n  rw [collinear_iff_of_mem (Set.mem_insert _ _)] at h\n  rcases h with ⟨v, h⟩\n  simp_rw [Set.mem_insert_iff, Set.mem_singleton_iff] at h\n  have hy := h y (or.inr (or.inl rfl))\n  have hz := h z (or.inr (or.inr rfl))\n  rcases hy with ⟨ty, rfl⟩\n  rcases hz with ⟨tz, rfl⟩\n  rcases lt_trichotomy ty 0 with (hy0 | rfl | hy0)\n  · rcases lt_trichotomy tz 0 with (hz0 | rfl | hz0)\n    · nth_rw 2 [wbtw_comm]\n      rw [← or_assoc']\n      exact or.inl (wbtw_or_wbtw_smul_vadd_of_nonpos _ _ hy0.le hz0.le)\n    · simp\n    · exact or.inr (or.inr (wbtw_smul_vadd_smul_vadd_of_nonneg_of_nonpos _ _ hz0.le hy0.le))\n  · simp\n  · rcases lt_trichotomy tz 0 with (hz0 | rfl | hz0)\n    · refine' or.inr (or.inr (wbtw_smul_vadd_smul_vadd_of_nonpos_of_nonneg _ _ hz0.le hy0.le))\n    · simp\n    · nth_rw 2 [wbtw_comm]\n      rw [← or_assoc']\n      exact or.inl (wbtw_or_wbtw_smul_vadd_of_nonneg _ _ hy0.le hz0.le)\n#align collinear.wbtw_or_wbtw_or_wbtw collinear.wbtw_or_wbtw_or_wbtw\n\n",
 "wbtw_one_zero_iff":
 "@[simp]\ntheorem wbtw_one_zero_iff {x : R} : wbtw R 1 x 0 ↔ x ∈ Set.Icc (0 : R) 1 := by rw [wbtw_comm, wbtw_zero_one_iff]\n#align wbtw_one_zero_iff wbtw_one_zero_iff\n\n",
 "wbtw_mul_sub_add_iff":
 "@[simp]\ntheorem wbtw_mul_sub_add_iff [NoZeroDivisors R] {x y r : R} :\n    wbtw R x (r * (y - x) + x) y ↔ x = y ∨ r ∈ Set.Icc (0 : R) 1 :=\n  wbtw_line_map_iff\n#align wbtw_mul_sub_add_iff wbtw_mul_sub_add_iff\n\n",
 "wbtw_midpoint":
 "theorem wbtw_midpoint (x y : P) : wbtw R x (midpoint R x y) y :=\n  by\n  convert wbtw_point_reflection R (midpoint R x y) x\n  simp\n#align wbtw_midpoint wbtw_midpoint\n\n",
 "wbtw_map_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ᵃ[ ] » -/\n@[simp]\ntheorem affine_equiv.wbtw_map_iff {x y z : P} (f : «expr ≃ᵃ[ ] » P R P') : wbtw R (f x) (f y) (f z) ↔ wbtw R x y z :=\n  by\n  refine' function.injective.wbtw_map_iff (_ : function.injective f.to_affine_map)\n  exact f.injective\n#align affine_equiv.wbtw_map_iff affine_equiv.wbtw_map_iff\n\n",
 "wbtw_line_map_iff":
 "@[simp]\ntheorem wbtw_line_map_iff [NoZeroSMulDivisors R V] {x y : P} {r : R} :\n    wbtw R x (lineMap x y r) y ↔ x = y ∨ r ∈ Set.Icc (0 : R) 1 :=\n  by\n  by_cases hxy : x = y; · simp [hxy]\n  rw [or_iff_right hxy, wbtw, affine_segment, (line_map_injective R hxy).mem_set_image]\n#align wbtw_line_map_iff wbtw_line_map_iff\n\n",
 "wbtw_iff_same_ray_vsub":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr +ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\ntheorem wbtw_iff_same_ray_vsub {x y z : P} : wbtw R x y z ↔ SameRay R («expr -ᵥ » y x) («expr -ᵥ » z y) :=\n  by\n  refine' ⟨wbtw.same_ray_vsub, fun h => _⟩\n  rcases h with (h | h | ⟨r₁, r₂, hr₁, hr₂, h⟩)\n  · rw [vsub_eq_zero_iff_eq] at h\n    simp [h]\n  · rw [vsub_eq_zero_iff_eq] at h\n    simp [h]\n  · refine'\n      ⟨r₂ / (r₁ + r₂),\n        ⟨div_nonneg hr₂.le (add_nonneg hr₁.le hr₂.le),\n          div_le_one_of_le (le_add_of_nonneg_left hr₁.le) (add_nonneg hr₁.le hr₂.le)⟩,\n        _⟩\n    have h' : z = «expr +ᵥ » («expr • » r₂⁻¹ («expr • » r₁ («expr -ᵥ » y x))) y := by simp [h, hr₂.ne']\n    rw [eq_comm]\n    simp only [line_map_apply, h', vadd_vsub_assoc, smul_smul, ← add_smul, eq_vadd_iff_vsub_eq, smul_add]\n    convert(one_smul _ _).symm\n    field_simp [(add_pos hr₁ hr₂).ne', hr₂.ne']\n    ring\n#align wbtw_iff_same_ray_vsub wbtw_iff_same_ray_vsub\n\n",
 "wbtw_iff_right_eq_or_left_mem_image_Ici":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem wbtw_iff_right_eq_or_left_mem_image_Ici {x y z : P} :\n    wbtw R x y z ↔ z = y ∨ x ∈ «expr '' » (lineMap z y) (Set.Ici (1 : R)) := by\n  rw [wbtw_comm, wbtw_iff_left_eq_or_right_mem_image_Ici]\n#align wbtw_iff_right_eq_or_left_mem_image_Ici wbtw_iff_right_eq_or_left_mem_image_Ici\n\n",
 "wbtw_iff_left_eq_or_right_mem_image_Ici":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem wbtw_iff_left_eq_or_right_mem_image_Ici {x y z : P} :\n    wbtw R x y z ↔ x = y ∨ z ∈ «expr '' » (lineMap x y) (Set.Ici (1 : R)) :=\n  by\n  refine' ⟨fun h => _, fun h => _⟩\n  · rcases h with ⟨r, ⟨hr0, hr1⟩, rfl⟩\n    rcases hr0.lt_or_eq with (hr0' | rfl)\n    · rw [Set.mem_image]\n      refine' or.inr ⟨r⁻¹, one_le_inv hr0' hr1, _⟩\n      simp only [line_map_apply, smul_smul, vadd_vsub]\n      rw [inv_mul_cancel hr0'.ne', one_smul, vsub_vadd]\n    · simp\n  · rcases h with (rfl | ⟨r, ⟨hr, rfl⟩⟩)\n    · exact wbtw_self_left _ _ _\n    · rw [Set.mem_Ici] at hr\n      refine' ⟨r⁻¹, ⟨inv_nonneg.2 (zero_le_one.trans hr), inv_le_one hr⟩, _⟩\n      simp only [line_map_apply, smul_smul, vadd_vsub]\n      rw [inv_mul_cancel (one_pos.trans_le hr).ne', one_smul, vsub_vadd]\n#align wbtw_iff_left_eq_or_right_mem_image_Ici wbtw_iff_left_eq_or_right_mem_image_Ici\n\n",
 "wbtw_const_vsub_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n@[simp]\ntheorem wbtw_const_vsub_iff {x y z : P} (p : P) :\n    wbtw R («expr -ᵥ » p x) («expr -ᵥ » p y) («expr -ᵥ » p z) ↔ wbtw R x y z :=\n  mem_const_vsub_affine_segment _\n#align wbtw_const_vsub_iff wbtw_const_vsub_iff\n\n",
 "wbtw_const_vadd_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr +ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr +ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr +ᵥ » -/\n@[simp]\ntheorem wbtw_const_vadd_iff {x y z : P} (v : V) :\n    wbtw R («expr +ᵥ » v x) («expr +ᵥ » v y) («expr +ᵥ » v z) ↔ wbtw R x y z :=\n  mem_const_vadd_affine_segment _\n#align wbtw_const_vadd_iff wbtw_const_vadd_iff\n\n",
 "wbtw_comm":
 "theorem wbtw_comm {x y z : P} : wbtw R x y z ↔ wbtw R z y x := by rw [wbtw, wbtw, affine_segment_comm]\n#align wbtw_comm wbtw_comm\n\n",
 "wbtw":
 "theorem sbtw.wbtw {x y z : P} (h : sbtw R x y z) : wbtw R x y z :=\n  h.1\n#align sbtw.wbtw sbtw.wbtw\n\n",
 "trans_wbtw_right_ne":
 "theorem sbtw.trans_wbtw_right_ne [NoZeroSMulDivisors R V] {w x y z : P} (h₁ : sbtw R w x z) (h₂ : wbtw R x y z) :\n    w ≠ y :=\n  h₁.wbtw.trans_right_ne h₂ h₁.left_ne\n#align sbtw.trans_wbtw_right_ne sbtw.trans_wbtw_right_ne\n\n",
 "trans_wbtw_left_ne":
 "theorem sbtw.trans_wbtw_left_ne [NoZeroSMulDivisors R V] {w x y z : P} (h₁ : sbtw R w y z) (h₂ : wbtw R w x y) :\n    x ≠ z :=\n  h₁.wbtw.trans_left_ne h₂ h₁.ne_right\n#align sbtw.trans_wbtw_left_ne sbtw.trans_wbtw_left_ne\n\n",
 "trans_sbtw_right":
 "theorem wbtw.trans_sbtw_right [NoZeroSMulDivisors R V] {w x y z : P} (h₁ : wbtw R w x z) (h₂ : sbtw R x y z) :\n    sbtw R w y z := by\n  rw [wbtw_comm] at *\n  rw [sbtw_comm] at *\n  exact h₁.trans_sbtw_left h₂\n#align wbtw.trans_sbtw_right wbtw.trans_sbtw_right\n\n",
 "trans_sbtw_left":
 "theorem wbtw.trans_sbtw_left [NoZeroSMulDivisors R V] {w x y z : P} (h₁ : wbtw R w y z) (h₂ : sbtw R w x y) :\n    sbtw R w x z := by\n  refine' ⟨h₁.trans_left h₂.wbtw, h₂.ne_left, _⟩\n  rintro rfl\n  exact h₂.right_ne ((wbtw_swap_right_iff R w).1 ⟨h₁, h₂.wbtw⟩)\n#align wbtw.trans_sbtw_left wbtw.trans_sbtw_left\n\n",
 "trans_right_ne":
 "theorem wbtw.trans_right_ne [NoZeroSMulDivisors R V] {w x y z : P} (h₁ : wbtw R w x z) (h₂ : wbtw R x y z) (h : w ≠ x) :\n    w ≠ y := by\n  rintro rfl\n  exact h (h₁.swap_left_iff.1 h₂)\n#align wbtw.trans_right_ne wbtw.trans_right_ne\n\n",
 "trans_right_left":
 "theorem sbtw.trans_right_left {w x y z : P} (h₁ : sbtw R w x z) (h₂ : sbtw R x y z) : sbtw R w x y :=\n  ⟨h₁.wbtw.trans_right_left h₂.wbtw, h₁.ne_left, h₂.left_ne⟩\n#align sbtw.trans_right_left sbtw.trans_right_left\n\n",
 "trans_right":
 "theorem sbtw.trans_right [NoZeroSMulDivisors R V] {w x y z : P} (h₁ : sbtw R w x z) (h₂ : sbtw R x y z) :\n    sbtw R w y z :=\n  h₁.wbtw.trans_sbtw_right h₂\n#align sbtw.trans_right sbtw.trans_right\n\n",
 "trans_left_right":
 "theorem sbtw.trans_left_right {w x y z : P} (h₁ : sbtw R w y z) (h₂ : sbtw R w x y) : sbtw R x y z :=\n  ⟨h₁.wbtw.trans_left_right h₂.wbtw, h₂.right_ne, h₁.ne_right⟩\n#align sbtw.trans_left_right sbtw.trans_left_right\n\n",
 "trans_left_ne":
 "theorem wbtw.trans_left_ne [NoZeroSMulDivisors R V] {w x y z : P} (h₁ : wbtw R w y z) (h₂ : wbtw R w x y) (h : y ≠ z) :\n    x ≠ z := by\n  rintro rfl\n  exact h (h₁.swap_right_iff.1 h₂)\n#align wbtw.trans_left_ne wbtw.trans_left_ne\n\n",
 "trans_left":
 "theorem sbtw.trans_left [NoZeroSMulDivisors R V] {w x y z : P} (h₁ : sbtw R w y z) (h₂ : sbtw R w x y) : sbtw R w x z :=\n  h₁.wbtw.trans_sbtw_left h₂\n#align sbtw.trans_left sbtw.trans_left\n\n",
 "swap_right_iff":
 "theorem wbtw.swap_right_iff [NoZeroSMulDivisors R V] {x y z : P} (h : wbtw R x y z) : wbtw R x z y ↔ y = z := by\n  rw [← wbtw_swap_right_iff R x, and_iff_right h]\n#align wbtw.swap_right_iff wbtw.swap_right_iff\n\n",
 "swap_left_iff":
 "theorem wbtw.swap_left_iff [NoZeroSMulDivisors R V] {x y z : P} (h : wbtw R x y z) : wbtw R y x z ↔ x = y := by\n  rw [← wbtw_swap_left_iff R z, and_iff_right h]\n#align wbtw.swap_left_iff wbtw.swap_left_iff\n\n",
 "sbtw_zero_one_iff":
 "@[simp]\ntheorem sbtw_zero_one_iff {x : R} : sbtw R 0 x 1 ↔ x ∈ Set.Ioo (0 : R) 1 :=\n  by\n  rw [sbtw, wbtw_zero_one_iff, Set.mem_Icc, Set.mem_Ioo]\n  exact ⟨fun h => ⟨h.1.1.lt_of_ne (ne.symm h.2.1), h.1.2.lt_of_ne h.2.2⟩, fun h => ⟨⟨h.1.le, h.2.le⟩, h.1.ne', h.2.ne⟩⟩\n#align sbtw_zero_one_iff sbtw_zero_one_iff\n\n",
 "sbtw_vsub_const_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n@[simp]\ntheorem sbtw_vsub_const_iff {x y z : P} (p : P) :\n    sbtw R («expr -ᵥ » x p) («expr -ᵥ » y p) («expr -ᵥ » z p) ↔ sbtw R x y z := by\n  simp_rw [sbtw, wbtw_vsub_const_iff, (vsub_left_injective p).ne_iff]\n#align sbtw_vsub_const_iff sbtw_vsub_const_iff\n\n",
 "sbtw_vadd_const_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr +ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr +ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr +ᵥ » -/\n@[simp]\ntheorem sbtw_vadd_const_iff {x y z : V} (p : P) :\n    sbtw R («expr +ᵥ » x p) («expr +ᵥ » y p) («expr +ᵥ » z p) ↔ sbtw R x y z := by\n  simp_rw [sbtw, wbtw_vadd_const_iff, (vadd_right_injective p).ne_iff]\n#align sbtw_vadd_const_iff sbtw_vadd_const_iff\n\n",
 "sbtw_point_reflection_of_ne":
 "theorem sbtw_point_reflection_of_ne {x y : P} (h : x ≠ y) : sbtw R y x (pointReflection R x y) :=\n  by\n  refine' ⟨wbtw_point_reflection _ _ _, h, _⟩\n  nth_rw 1 [← point_reflection_self R x]\n  exact (point_reflection_involutive R x).injective.ne h\n#align sbtw_point_reflection_of_ne sbtw_point_reflection_of_ne\n\n",
 "sbtw_one_zero_iff":
 "@[simp]\ntheorem sbtw_one_zero_iff {x : R} : sbtw R 1 x 0 ↔ x ∈ Set.Ioo (0 : R) 1 := by rw [sbtw_comm, sbtw_zero_one_iff]\n#align sbtw_one_zero_iff sbtw_one_zero_iff\n\n",
 "sbtw_of_sbtw_of_sbtw_of_mem_affine_span_pair":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprline[ , , ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprline[ , , ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprline[ , , ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprline[ , , ]» -/\n/-- Suppose lines from two vertices of a triangle to interior points of the opposite side meet at\n`p`. Then `p` lies in the interior of the first (and by symmetry the other) segment from a\nvertex to the point on the opposite side. -/\ntheorem sbtw_of_sbtw_of_sbtw_of_mem_affine_span_pair [NoZeroSMulDivisors R V] {t : Affine.Triangle R P}\n    {i₁ i₂ i₃ : Fin 3} (h₁₂ : i₁ ≠ i₂) {p₁ p₂ p : P} (h₁ : sbtw R (t.points i₂) p₁ (t.points i₃))\n    (h₂ : sbtw R (t.points i₁) p₂ (t.points i₃)) (h₁' : p ∈ «exprline[ , , ]» R (t.points i₁) p₁)\n    (h₂' : p ∈ «exprline[ , , ]» R (t.points i₂) p₂) : sbtw R (t.points i₁) p p₁ :=\n  by\n  -- Should not be needed; see comments on local instances in `data.sign`.\n  letI : DecidableRel ((· < ·) : R → R → Prop) := linear_ordered_ring.decidable_lt\n  have h₁₃ : i₁ ≠ i₃ := by\n    rintro rfl\n    simpa using h₂\n  have h₂₃ : i₂ ≠ i₃ := by\n    rintro rfl\n    simpa using h₁\n  have h3 : ∀ i : Fin 3, i = i₁ ∨ i = i₂ ∨ i = i₃ :=\n    by\n    clear h₁ h₂ h₁' h₂'\n    decide!\n  have hu : (Finset.univ : Finset (Fin 3)) = {i₁, i₂, i₃} :=\n    by\n    clear h₁ h₂ h₁' h₂'\n    decide!\n  have hp : p ∈ affineSpan R (Set.range t.points) :=\n    by\n    have hle : «exprline[ , , ]» R (t.points i₁) p₁ ≤ affineSpan R (Set.range t.points) :=\n      by\n      refine' affineSpan_pair_le_of_mem_of_mem (mem_affineSpan _ (Set.mem_range_self _)) _\n      have hle : «exprline[ , , ]» R (t.points i₂) (t.points i₃) ≤ affineSpan R (Set.range t.points) :=\n        by\n        refine' affineSpan_mono _ _\n        simp [Set.insert_subset]\n      rw [AffineSubspace.le_def'] at hle\n      exact hle _ h₁.wbtw.mem_affine_span\n    rw [AffineSubspace.le_def'] at hle\n    exact hle _ h₁'\n  have h₁i := h₁.mem_image_Ioo\n  have h₂i := h₂.mem_image_Ioo\n  rw [Set.mem_image] at h₁i h₂i\n  rcases h₁i with ⟨r₁, ⟨hr₁0, hr₁1⟩, rfl⟩\n  rcases h₂i with ⟨r₂, ⟨hr₂0, hr₂1⟩, rfl⟩\n  rcases eq_affineCombination_of_mem_affineSpan_of_fintype hp with ⟨w, hw, rfl⟩\n  have h₁s :=\n    sign_eq_of_affineCombination_mem_affineSpan_single_lineMap t.independent hw (Finset.mem_univ _) (Finset.mem_univ _)\n      (Finset.mem_univ _) h₁₂ h₁₃ h₂₃ hr₁0 hr₁1 h₁'\n  have h₂s :=\n    sign_eq_of_affineCombination_mem_affineSpan_single_lineMap t.independent hw (Finset.mem_univ _) (Finset.mem_univ _)\n      (Finset.mem_univ _) h₁₂.symm h₂₃ h₁₃ hr₂0 hr₂1 h₂'\n  dsimp only at h₁s h₂s\n  rw [← finset.univ.affine_combination_affine_combination_single_weights R t.points (Finset.mem_univ i₁), ←\n    finset.univ.affine_combination_affine_combination_line_map_weights t.points (Finset.mem_univ _)\n      (Finset.mem_univ _)] at\n    h₁'⊢\n  refine'\n    sbtw.affine_combination_of_mem_affine_span_pair t.independent hw\n      (finset.univ.sum_affine_combination_single_weights R (Finset.mem_univ _))\n      (finset.univ.sum_affine_combination_line_map_weights (Finset.mem_univ _) (Finset.mem_univ _) _) h₁'\n      (Finset.mem_univ i₁) _\n  rw [Finset.affineCombinationSingleWeights_apply_self, Finset.affineCombinationLineMapWeights_apply_of_ne h₁₂ h₁₃,\n    sbtw_one_zero_iff]\n  have hs : ∀ i : Fin 3, SignType.sign (w i) = SignType.sign (w i₃) :=\n    by\n    intro i\n    rcases h3 i with (rfl | rfl | rfl)\n    · exact h₂s\n    · exact h₁s\n    · rfl\n  have hss :\n    SignType.sign\n        (finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n          (w i)) =\n      1 :=\n    by simp [hw]\n  have hs' := sign_sum Finset.univ_nonempty (SignType.sign (w i₃)) fun i _ => hs i\n  rw [hs'] at hss\n  simp_rw [hss, sign_eq_one_iff] at hs\n  refine' ⟨hs i₁, _⟩\n  rw [hu] at hw\n  rw [Finset.sum_insert, Finset.sum_insert, Finset.sum_singleton] at hw\n  · by_contra hle\n    rw [not_lt] at hle\n    exact (hle.trans_lt (lt_add_of_pos_right _ (Left.add_pos (hs i₂) (hs i₃)))).ne' hw\n  · simp [h₂₃]\n  · simp [h₁₂, h₁₃]\n#align sbtw_of_sbtw_of_sbtw_of_mem_affine_span_pair sbtw_of_sbtw_of_sbtw_of_mem_affine_span_pair\n\n",
 "sbtw_mul_sub_add_iff":
 "@[simp]\ntheorem sbtw_mul_sub_add_iff [NoZeroDivisors R] {x y r : R} :\n    sbtw R x (r * (y - x) + x) y ↔ x ≠ y ∧ r ∈ Set.Ioo (0 : R) 1 :=\n  sbtw_line_map_iff\n#align sbtw_mul_sub_add_iff sbtw_mul_sub_add_iff\n\n",
 "sbtw_midpoint_of_ne":
 "theorem sbtw_midpoint_of_ne {x y : P} (h : x ≠ y) : sbtw R x (midpoint R x y) y :=\n  by\n  have h : midpoint R x y ≠ x := by simp [h]\n  convert sbtw_point_reflection_of_ne R h\n  simp\n#align sbtw_midpoint_of_ne sbtw_midpoint_of_ne\n\n",
 "sbtw_map_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ᵃ[ ] » -/\n@[simp]\ntheorem affine_equiv.sbtw_map_iff {x y z : P} (f : «expr ≃ᵃ[ ] » P R P') : sbtw R (f x) (f y) (f z) ↔ sbtw R x y z :=\n  by\n  refine' function.injective.sbtw_map_iff (_ : function.injective f.to_affine_map)\n  exact f.injective\n#align affine_equiv.sbtw_map_iff affine_equiv.sbtw_map_iff\n\n",
 "sbtw_line_map_iff":
 "@[simp]\ntheorem sbtw_line_map_iff [NoZeroSMulDivisors R V] {x y : P} {r : R} :\n    sbtw R x (lineMap x y r) y ↔ x ≠ y ∧ r ∈ Set.Ioo (0 : R) 1 :=\n  by\n  rw [sbtw_iff_mem_image_Ioo_and_ne, and_comm', and_congr_right]\n  intro hxy\n  rw [(line_map_injective R hxy).mem_set_image]\n#align sbtw_line_map_iff sbtw_line_map_iff\n\n",
 "sbtw_iff_right_ne_and_left_mem_image_IoI":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem sbtw_iff_right_ne_and_left_mem_image_IoI {x y z : P} :\n    sbtw R x y z ↔ z ≠ y ∧ x ∈ «expr '' » (lineMap z y) (Set.Ioi (1 : R)) := by\n  rw [sbtw_comm, sbtw_iff_left_ne_and_right_mem_image_IoI]\n#align sbtw_iff_right_ne_and_left_mem_image_IoI sbtw_iff_right_ne_and_left_mem_image_IoI\n\n",
 "sbtw_iff_mem_image_Ioo_and_ne":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem sbtw_iff_mem_image_Ioo_and_ne [NoZeroSMulDivisors R V] {x y z : P} :\n    sbtw R x y z ↔ y ∈ «expr '' » (lineMap x z) (Set.Ioo (0 : R) 1) ∧ x ≠ z :=\n  by\n  refine' ⟨fun h => ⟨h.mem_image_Ioo, h.left_ne_right⟩, fun h => _⟩\n  rcases h with ⟨⟨t, ht, rfl⟩, hxz⟩\n  refine' ⟨⟨t, Set.mem_Icc_of_Ioo ht, rfl⟩, _⟩\n  rw [line_map_apply, ← @vsub_ne_zero V, ← @vsub_ne_zero V _ _ _ _ z, vadd_vsub_assoc, vadd_vsub_assoc, ←\n    neg_vsub_eq_vsub_rev z x, ← @neg_one_smul R, ← add_smul, ← sub_eq_add_neg]\n  simp [smul_ne_zero, hxz.symm, sub_eq_zero, ht.1.ne.symm, ht.2.ne]\n#align sbtw_iff_mem_image_Ioo_and_ne sbtw_iff_mem_image_Ioo_and_ne\n\n",
 "sbtw_iff_left_ne_and_right_mem_image_IoI":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem sbtw_iff_left_ne_and_right_mem_image_IoI {x y z : P} :\n    sbtw R x y z ↔ x ≠ y ∧ z ∈ «expr '' » (lineMap x y) (Set.Ioi (1 : R)) :=\n  by\n  refine' ⟨fun h => ⟨h.left_ne, _⟩, fun h => _⟩\n  · obtain ⟨r, ⟨hr, rfl⟩⟩ := h.wbtw.right_mem_image_Ici_of_left_ne h.left_ne\n    rw [Set.mem_Ici] at hr\n    rcases hr.lt_or_eq with (hrlt | rfl)\n    · exact Set.mem_image_of_mem _ hrlt\n    · exfalso\n      simpa using h\n  · rcases h with ⟨hne, r, hr, rfl⟩\n    rw [Set.mem_Ioi] at hr\n    refine'\n      ⟨wbtw_iff_left_eq_or_right_mem_image_Ici.2\n          (or.inr (Set.mem_image_of_mem _ (Set.mem_of_mem_of_subset hr Set.Ioi_subset_Ici_self))),\n        hne.symm, _⟩\n    rw [line_map_apply, ← @vsub_ne_zero V, vsub_vadd_eq_vsub_sub]\n    nth_rw 1 [← one_smul R («expr -ᵥ » y x)]\n    rw [← sub_smul, smul_ne_zero_iff, vsub_ne_zero, sub_ne_zero]\n    exact ⟨hr.ne, hne.symm⟩\n#align sbtw_iff_left_ne_and_right_mem_image_IoI sbtw_iff_left_ne_and_right_mem_image_IoI\n\n",
 "sbtw_const_vsub_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n@[simp]\ntheorem sbtw_const_vsub_iff {x y z : P} (p : P) :\n    sbtw R («expr -ᵥ » p x) («expr -ᵥ » p y) («expr -ᵥ » p z) ↔ sbtw R x y z := by\n  simp_rw [sbtw, wbtw_const_vsub_iff, (vsub_right_injective p).ne_iff]\n#align sbtw_const_vsub_iff sbtw_const_vsub_iff\n\n",
 "sbtw_const_vadd_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr +ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr +ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr +ᵥ » -/\n@[simp]\ntheorem sbtw_const_vadd_iff {x y z : P} (v : V) :\n    sbtw R («expr +ᵥ » v x) («expr +ᵥ » v y) («expr +ᵥ » v z) ↔ sbtw R x y z := by\n  simp_rw [sbtw, wbtw_const_vadd_iff, (AddAction.injective v).ne_iff]\n#align sbtw_const_vadd_iff sbtw_const_vadd_iff\n\n",
 "sbtw_comm":
 "theorem sbtw_comm {x y z : P} : sbtw R x y z ↔ sbtw R z y x := by\n  rw [sbtw, sbtw, wbtw_comm, ← and_assoc', ← and_assoc', and_right_comm]\n#align sbtw_comm sbtw_comm\n\n",
 "same_ray_vsub_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\ntheorem wbtw.same_ray_vsub_right {x y z : P} (h : wbtw R x y z) : SameRay R («expr -ᵥ » z x) («expr -ᵥ » z y) :=\n  by\n  rcases h with ⟨t, ⟨ht0, ht1⟩, rfl⟩\n  simpa [line_map_apply, vsub_vadd_eq_vsub_sub, sub_smul] using\n    SameRay.sameRay_nonneg_smul_right («expr -ᵥ » z x) (sub_nonneg.2 ht1)\n#align wbtw.same_ray_vsub_right wbtw.same_ray_vsub_right\n\n",
 "same_ray_vsub_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\ntheorem wbtw.same_ray_vsub_left {x y z : P} (h : wbtw R x y z) : SameRay R («expr -ᵥ » y x) («expr -ᵥ » z x) :=\n  by\n  rcases h with ⟨t, ⟨ht0, ht1⟩, rfl⟩\n  simpa [line_map_apply] using SameRay.sameRay_nonneg_smul_left («expr -ᵥ » z x) ht0\n#align wbtw.same_ray_vsub_left wbtw.same_ray_vsub_left\n\n",
 "same_ray_vsub":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\ntheorem wbtw.same_ray_vsub {x y z : P} (h : wbtw R x y z) : SameRay R («expr -ᵥ » y x) («expr -ᵥ » z y) :=\n  by\n  rcases h with ⟨t, ⟨ht0, ht1⟩, rfl⟩\n  simp_rw [line_map_apply]\n  rcases ht0.lt_or_eq with (ht0' | rfl); swap; · simp\n  rcases ht1.lt_or_eq with (ht1' | rfl); swap; · simp\n  refine' or.inr (or.inr ⟨1 - t, t, sub_pos.2 ht1', ht0', _⟩)\n  simp [vsub_vadd_eq_vsub_sub, smul_sub, smul_smul, ← sub_smul]\n  ring_nf\n#align wbtw.same_ray_vsub wbtw.same_ray_vsub\n\n",
 "rotate_iff":
 "theorem wbtw.rotate_iff [NoZeroSMulDivisors R V] {x y z : P} (h : wbtw R x y z) : wbtw R z x y ↔ x = y := by\n  rw [← wbtw_rotate_iff R x, and_iff_right h]\n#align wbtw.rotate_iff wbtw.rotate_iff\n\n",
 "right_ne":
 "theorem sbtw.right_ne {x y z : P} (h : sbtw R x y z) : z ≠ y :=\n  h.2.2.symm\n#align sbtw.right_ne sbtw.right_ne\n\n",
 "right_mem_image_Ioi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem sbtw.right_mem_image_Ioi {x y z : P} (h : sbtw R x y z) : z ∈ «expr '' » (lineMap x y) (Set.Ioi (1 : R)) :=\n  (sbtw_iff_left_ne_and_right_mem_image_IoI.1 h).2\n#align sbtw.right_mem_image_Ioi sbtw.right_mem_image_Ioi\n\n",
 "right_mem_image_Ici_of_left_ne":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem wbtw.right_mem_image_Ici_of_left_ne {x y z : P} (h : wbtw R x y z) (hne : x ≠ y) :\n    z ∈ «expr '' » (lineMap x y) (Set.Ici (1 : R)) :=\n  (wbtw_iff_left_eq_or_right_mem_image_Ici.1 h).resolve_left hne\n#align wbtw.right_mem_image_Ici_of_left_ne wbtw.right_mem_image_Ici_of_left_ne\n\n",
 "right_mem_affine_span_of_left_ne":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprline[ , , ]» -/\ntheorem wbtw.right_mem_affine_span_of_left_ne {x y z : P} (h : wbtw R x y z) (hne : x ≠ y) :\n    z ∈ «exprline[ , , ]» R x y :=\n  by\n  rcases h.right_mem_image_Ici_of_left_ne hne with ⟨r, ⟨-, rfl⟩⟩\n  exact line_map_mem_affine_span_pair _ _ _\n#align wbtw.right_mem_affine_span_of_left_ne wbtw.right_mem_affine_span_of_left_ne\n\n",
 "right_mem_affine_span":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprline[ , , ]» -/\ntheorem sbtw.right_mem_affine_span {x y z : P} (h : sbtw R x y z) : z ∈ «exprline[ , , ]» R x y :=\n  h.wbtw.right_mem_affine_span_of_left_ne h.left_ne\n#align sbtw.right_mem_affine_span sbtw.right_mem_affine_span\n\n",
 "right_mem_affine_segment":
 "theorem right_mem_affine_segment (x y : P) : y ∈ affine_segment R x y :=\n  ⟨1, Set.right_mem_Icc.2 zero_le_one, lineMap_apply_one _ _⟩\n#align right_mem_affine_segment right_mem_affine_segment\n\n",
 "not_swap_right":
 "theorem sbtw.not_swap_right [NoZeroSMulDivisors R V] {x y z : P} (h : sbtw R x y z) : ¬wbtw R x z y := fun hs =>\n  h.ne_right (h.wbtw.swap_right_iff.1 hs)\n#align sbtw.not_swap_right sbtw.not_swap_right\n\n",
 "not_swap_left":
 "theorem sbtw.not_swap_left [NoZeroSMulDivisors R V] {x y z : P} (h : sbtw R x y z) : ¬wbtw R y x z := fun hs =>\n  h.left_ne (h.wbtw.swap_left_iff.1 hs)\n#align sbtw.not_swap_left sbtw.not_swap_left\n\n",
 "not_sbtw_self_right":
 "@[simp]\ntheorem not_sbtw_self_right (x y : P) : ¬sbtw R x y y := fun h => h.ne_right rfl\n#align not_sbtw_self_right not_sbtw_self_right\n\n",
 "not_sbtw_self_left":
 "@[simp]\ntheorem not_sbtw_self_left (x y : P) : ¬sbtw R x x y := fun h => h.ne_left rfl\n#align not_sbtw_self_left not_sbtw_self_left\n\n",
 "not_sbtw_self":
 "@[simp]\ntheorem not_sbtw_self (x y : P) : ¬sbtw R x y x := fun h => h.left_ne_right rfl\n#align not_sbtw_self not_sbtw_self\n\n",
 "not_rotate":
 "theorem sbtw.not_rotate [NoZeroSMulDivisors R V] {x y z : P} (h : sbtw R x y z) : ¬wbtw R z x y := fun hs =>\n  h.left_ne (h.wbtw.rotate_iff.1 hs)\n#align sbtw.not_rotate sbtw.not_rotate\n\n",
 "ne_right":
 "theorem sbtw.ne_right {x y z : P} (h : sbtw R x y z) : y ≠ z :=\n  h.2.2\n#align sbtw.ne_right sbtw.ne_right\n\n",
 "ne_left":
 "theorem sbtw.ne_left {x y z : P} (h : sbtw R x y z) : y ≠ x :=\n  h.2.1\n#align sbtw.ne_left sbtw.ne_left\n\n",
 "mem_vsub_const_affine_segment":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n@[simp]\ntheorem mem_vsub_const_affine_segment {x y z : P} (p : P) :\n    «expr -ᵥ » z p ∈ affine_segment R («expr -ᵥ » x p) («expr -ᵥ » y p) ↔ z ∈ affine_segment R x y := by\n  rw [← affine_segment_vsub_const_image, (vsub_left_injective p).mem_set_image]\n#align mem_vsub_const_affine_segment mem_vsub_const_affine_segment\n\n",
 "mem_vadd_const_affine_segment":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr +ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr +ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr +ᵥ » -/\n@[simp]\ntheorem mem_vadd_const_affine_segment {x y z : V} (p : P) :\n    «expr +ᵥ » z p ∈ affine_segment R («expr +ᵥ » x p) («expr +ᵥ » y p) ↔ z ∈ affine_segment R x y := by\n  rw [← affine_segment_vadd_const_image, (vadd_right_injective p).mem_set_image]\n#align mem_vadd_const_affine_segment mem_vadd_const_affine_segment\n\n",
 "mem_image_Ioo":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem sbtw.mem_image_Ioo {x y z : P} (h : sbtw R x y z) : y ∈ «expr '' » (lineMap x z) (Set.Ioo (0 : R) 1) :=\n  by\n  rcases h with ⟨⟨t, ht, rfl⟩, hyx, hyz⟩\n  rcases Set.eq_endpoints_or_mem_Ioo_of_mem_Icc ht with (rfl | rfl | ho)\n  · exfalso\n    simpa using hyx\n  · exfalso\n    simpa using hyz\n  · exact ⟨t, ho, rfl⟩\n#align sbtw.mem_image_Ioo sbtw.mem_image_Ioo\n\n",
 "mem_const_vsub_affine_segment":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n@[simp]\ntheorem mem_const_vsub_affine_segment {x y z : P} (p : P) :\n    «expr -ᵥ » p z ∈ affine_segment R («expr -ᵥ » p x) («expr -ᵥ » p y) ↔ z ∈ affine_segment R x y := by\n  rw [← affine_segment_const_vsub_image, (vsub_right_injective p).mem_set_image]\n#align mem_const_vsub_affine_segment mem_const_vsub_affine_segment\n\n",
 "mem_const_vadd_affine_segment":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr +ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr +ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr +ᵥ » -/\n@[simp]\ntheorem mem_const_vadd_affine_segment {x y z : P} (v : V) :\n    «expr +ᵥ » v z ∈ affine_segment R («expr +ᵥ » v x) («expr +ᵥ » v y) ↔ z ∈ affine_segment R x y := by\n  rw [← affine_segment_const_vadd_image, (AddAction.injective v).mem_set_image]\n#align mem_const_vadd_affine_segment mem_const_vadd_affine_segment\n\n",
 "mem_affine_span":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprline[ , , ]» -/\ntheorem wbtw.mem_affine_span {x y z : P} (h : wbtw R x y z) : y ∈ «exprline[ , , ]» R x z :=\n  by\n  rcases h with ⟨r, ⟨-, rfl⟩⟩\n  exact line_map_mem_affine_span_pair _ _ _\n#align wbtw.mem_affine_span wbtw.mem_affine_span\n\n",
 "map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ᵃ[ ] » -/\ntheorem wbtw.map {x y z : P} (h : wbtw R x y z) (f : «expr →ᵃ[ ] » P R P') : wbtw R (f x) (f y) (f z) :=\n  by\n  rw [wbtw, ← affine_segment_image]\n  exact Set.mem_image_of_mem _ h\n#align wbtw.map wbtw.map\n\n",
 "left_ne_right_of_ne_right":
 "theorem wbtw.left_ne_right_of_ne_right {x y z : P} (h : wbtw R x y z) (hne : y ≠ z) : x ≠ z :=\n  by\n  rintro rfl\n  rw [wbtw_self_iff] at h\n  exact hne h\n#align wbtw.left_ne_right_of_ne_right wbtw.left_ne_right_of_ne_right\n\n",
 "left_ne_right_of_ne_left":
 "theorem wbtw.left_ne_right_of_ne_left {x y z : P} (h : wbtw R x y z) (hne : y ≠ x) : x ≠ z :=\n  by\n  rintro rfl\n  rw [wbtw_self_iff] at h\n  exact hne h\n#align wbtw.left_ne_right_of_ne_left wbtw.left_ne_right_of_ne_left\n\n",
 "left_ne_right":
 "theorem sbtw.left_ne_right {x y z : P} (h : sbtw R x y z) : x ≠ z :=\n  h.wbtw.left_ne_right_of_ne_left h.2.1\n#align sbtw.left_ne_right sbtw.left_ne_right\n\n",
 "left_ne":
 "theorem sbtw.left_ne {x y z : P} (h : sbtw R x y z) : x ≠ y :=\n  h.2.1.symm\n#align sbtw.left_ne sbtw.left_ne\n\n",
 "left_mem_image_Ioi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem sbtw.left_mem_image_Ioi {x y z : P} (h : sbtw R x y z) : x ∈ «expr '' » (lineMap z y) (Set.Ioi (1 : R)) :=\n  h.symm.right_mem_image_Ioi\n#align sbtw.left_mem_image_Ioi sbtw.left_mem_image_Ioi\n\n",
 "left_mem_image_Ici_of_right_ne":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem wbtw.left_mem_image_Ici_of_right_ne {x y z : P} (h : wbtw R x y z) (hne : z ≠ y) :\n    x ∈ «expr '' » (lineMap z y) (Set.Ici (1 : R)) :=\n  h.symm.right_mem_image_Ici_of_left_ne hne\n#align wbtw.left_mem_image_Ici_of_right_ne wbtw.left_mem_image_Ici_of_right_ne\n\n",
 "left_mem_affine_span_of_right_ne":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprline[ , , ]» -/\ntheorem wbtw.left_mem_affine_span_of_right_ne {x y z : P} (h : wbtw R x y z) (hne : z ≠ y) :\n    x ∈ «exprline[ , , ]» R z y :=\n  h.symm.right_mem_affine_span_of_left_ne hne\n#align wbtw.left_mem_affine_span_of_right_ne wbtw.left_mem_affine_span_of_right_ne\n\n",
 "left_mem_affine_span":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprline[ , , ]» -/\ntheorem sbtw.left_mem_affine_span {x y z : P} (h : sbtw R x y z) : x ∈ «exprline[ , , ]» R z y :=\n  h.symm.right_mem_affine_span\n#align sbtw.left_mem_affine_span sbtw.left_mem_affine_span\n\n",
 "left_mem_affine_segment":
 "theorem left_mem_affine_segment (x y : P) : x ∈ affine_segment R x y :=\n  ⟨0, Set.left_mem_Icc.2 zero_le_one, lineMap_apply_zero _ _⟩\n#align left_mem_affine_segment left_mem_affine_segment\n\n",
 "collinear":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\ntheorem wbtw.collinear {x y z : P} (h : wbtw R x y z) : Collinear R ({x, y, z} : Set P) :=\n  by\n  rw [collinear_iff_exists_forall_eq_smul_vadd]\n  refine' ⟨x, «expr -ᵥ » z x, _⟩\n  intro p hp\n  simp_rw [Set.mem_insert_iff, Set.mem_singleton_iff] at hp\n  rcases hp with (rfl | rfl | rfl)\n  · refine' ⟨0, _⟩\n    simp\n  · rcases h with ⟨t, -, rfl⟩\n    exact ⟨t, rfl⟩\n  · refine' ⟨1, _⟩\n    simp\n#align wbtw.collinear wbtw.collinear\n\n",
 "affine_segment_vsub_const_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ᵃ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:219:4: warning: unsupported binary notation `«expr -ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n@[simp]\ntheorem affine_segment_vsub_const_image (x y p : P) :\n    «expr '' » («expr -ᵥ » · p) (affine_segment R x y) = affine_segment R («expr -ᵥ » x p) («expr -ᵥ » y p) :=\n  affine_segment_image ((AffineEquiv.vaddConst R p).symm : «expr →ᵃ[ ] » P R V) x y\n#align affine_segment_vsub_const_image affine_segment_vsub_const_image\n\n",
 "affine_segment_vadd_const_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ᵃ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:219:4: warning: unsupported binary notation `«expr +ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr +ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr +ᵥ » -/\n@[simp]\ntheorem affine_segment_vadd_const_image (x y : V) (p : P) :\n    «expr '' » («expr +ᵥ » · p) (affine_segment R x y) = affine_segment R («expr +ᵥ » x p) («expr +ᵥ » y p) :=\n  affine_segment_image (AffineEquiv.vaddConst R p : «expr →ᵃ[ ] » V R P) x y\n#align affine_segment_vadd_const_image affine_segment_vadd_const_image\n\n",
 "affine_segment_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ᵃ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n@[simp]\ntheorem affine_segment_image (f : «expr →ᵃ[ ] » P R P') (x y : P) :\n    «expr '' » f (affine_segment R x y) = affine_segment R (f x) (f y) :=\n  by\n  rw [affine_segment, affine_segment, Set.image_image, ← comp_line_map]\n  rfl\n#align affine_segment_image affine_segment_image\n\n",
 "affine_segment_eq_segment":
 "/-\nCopyright (c) 2022 Joseph Myers. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Joseph Myers\n-/\ntheorem affine_segment_eq_segment (x y : V) : affine_segment R x y = segment R x y := by\n  rw [segment_eq_image_lineMap, affine_segment]\n#align affine_segment_eq_segment affine_segment_eq_segment\n\n",
 "affine_segment_const_vsub_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ᵃ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:219:4: warning: unsupported binary notation `«expr -ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n@[simp]\ntheorem affine_segment_const_vsub_image (x y p : P) :\n    «expr '' » ((«expr -ᵥ » · ·) p) (affine_segment R x y) = affine_segment R («expr -ᵥ » p x) («expr -ᵥ » p y) :=\n  affine_segment_image (AffineEquiv.constVSub R p : «expr →ᵃ[ ] » P R V) x y\n#align affine_segment_const_vsub_image affine_segment_const_vsub_image\n\n",
 "affine_segment_const_vadd_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ᵃ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:219:4: warning: unsupported binary notation `«expr +ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr +ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr +ᵥ » -/\n@[simp]\ntheorem affine_segment_const_vadd_image (x y : P) (v : V) :\n    «expr '' » ((«expr +ᵥ » · ·) v) (affine_segment R x y) = affine_segment R («expr +ᵥ » v x) («expr +ᵥ » v y) :=\n  affine_segment_image (AffineEquiv.constVAdd R P v : «expr →ᵃ[ ] » P R P) x y\n#align affine_segment_const_vadd_image affine_segment_const_vadd_image\n\n",
 "affine_segment_comm":
 "theorem affine_segment_comm (x y : P) : affine_segment R x y = affine_segment R y x :=\n  by\n  refine' Set.ext fun z => _\n  constructor <;>\n    · rintro ⟨t, ht, hxy⟩\n      refine' ⟨1 - t, _, _⟩\n      · rwa [Set.sub_mem_Icc_iff_right, sub_self, sub_zero]\n      · rwa [line_map_apply_one_sub]\n#align affine_segment_comm affine_segment_comm\n\n",
 "affine_combination_of_mem_affine_span_pair":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprline[ , , ]» -/\ntheorem sbtw.affine_combination_of_mem_affine_span_pair [NoZeroDivisors R] [NoZeroSMulDivisors R V] {ι : Type _}\n    {p : ι → P} (ha : AffineIndependent R p) {w w₁ w₂ : ι → R} {s : Finset ι}\n    (hw : finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s (w i) = 1)\n    (hw₁ : finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s (w₁ i) = 1)\n    (hw₂ : finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s (w₂ i) = 1)\n    (h : s.affine_combination R p w ∈ «exprline[ , , ]» R (s.affine_combination R p w₁) (s.affine_combination R p w₂))\n    {i : ι} (his : i ∈ s) (hs : sbtw R (w₁ i) (w i) (w₂ i)) :\n    sbtw R (s.affine_combination R p w₁) (s.affine_combination R p w) (s.affine_combination R p w₂) :=\n  by\n  rw [affineCombination_mem_affineSpan_pair ha hw hw₁ hw₂] at h\n  rcases h with ⟨r, hr⟩\n  dsimp only at hr\n  rw [hr i his, sbtw_mul_sub_add_iff] at hs\n  change ∀ i ∈ s, w i = («expr • » r (w₂ - w₁) + w₁) i at hr\n  rw [s.affine_combination_congr hr fun _ _ => rfl]\n  dsimp only\n  rw [← s.weighted_vsub_vadd_affine_combination, s.weighted_vsub_const_smul, ← s.affine_combination_vsub, ←\n    line_map_apply, sbtw_line_map_iff, and_iff_left hs.2, ← @vsub_ne_zero V, s.affine_combination_vsub]\n  intro hz\n  have hw₁w₂ :\n    finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s ((w₁ - w₂) i) =\n      0 :=\n    by simp_rw [Pi.sub_apply, Finset.sum_sub_distrib, hw₁, hw₂, sub_self]\n  refine' hs.1 _\n  have ha' := ha s (w₁ - w₂) hw₁w₂ hz i his\n  rwa [Pi.sub_apply, sub_eq_zero] at ha'\n#align sbtw.affine_combination_of_mem_affine_span_pair sbtw.affine_combination_of_mem_affine_span_pair\n\n"}