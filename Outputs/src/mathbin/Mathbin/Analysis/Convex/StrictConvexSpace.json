{"strict_convex_closed_ball":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-\nCopyright (c) 2022 Yaël Dillies. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yaël Dillies, Yury Kudryashov\n-/\n/-- A closed ball in a strictly convex space is strictly convex. -/\ntheorem strict_convex_closed_ball [strict_convex_space 𝕜 E] (x : E) (r : exprℝ) : StrictConvex 𝕜 (closedBall x r) :=\n  by\n  cases' le_or_lt r 0 with hr hr\n  · exact (subsingleton_closed_ball x hr).strict_convex\n  rw [← vadd_closedBall_zero]\n  exact (strict_convex_space.strict_convex_closed_ball r hr).vadd _\n#align strict_convex_closed_ball strict_convex_closed_ball\n\n",
 "same_ray_iff_norm_sub":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem same_ray_iff_norm_sub : SameRay (exprℝ) x y ↔ «expr‖ ‖» (x - y) = |«expr‖ ‖» x - «expr‖ ‖» y| :=\n  ⟨SameRay.norm_sub, fun h => Classical.not_not.1 fun h' => (abs_lt_norm_sub_of_not_same_ray h').ne' h⟩\n#align same_ray_iff_norm_sub same_ray_iff_norm_sub\n\n",
 "same_ray_iff_norm_add":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/-- In a strictly convex space, two vectors `x`, `y` are in the same ray if and only if the triangle\ninequality for `x` and `y` becomes an equality. -/\ntheorem same_ray_iff_norm_add : SameRay (exprℝ) x y ↔ «expr‖ ‖» (x + y) = «expr‖ ‖» x + «expr‖ ‖» y :=\n  ⟨SameRay.norm_add, fun h => Classical.not_not.1 fun h' => (norm_add_lt_of_not_same_ray h').ne h⟩\n#align same_ray_iff_norm_add same_ray_iff_norm_add\n\n",
 "open_segment_subset_ball_of_ne":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- If `x ≠ y` belong to the same closed ball, then the open segment with endpoints `x` and `y` is\nincluded in the corresponding open ball. -/\ntheorem open_segment_subset_ball_of_ne (hx : x ∈ closedBall z r) (hy : y ∈ closedBall z r) (hne : x ≠ y) :\n    openSegment (exprℝ) x y ⊆ ball z r :=\n  (openSegment_subset_iff _).2 fun a b => combo_mem_ball_of_ne hx hy hne\n#align open_segment_subset_ball_of_ne open_segment_subset_ball_of_ne\n\n",
 "of_strict_convex_closed_unit_ball":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- A real normed vector space is strictly convex provided that the unit ball is strictly convex. -/\ntheorem strict_convex_space.of_strict_convex_closed_unit_ball [LinearMap.CompatibleSMul E E 𝕜 (exprℝ)]\n    (h : StrictConvex 𝕜 (closedBall (0 : E) 1)) : strict_convex_space 𝕜 E :=\n  ⟨fun r hr => by simpa only [smul_closedUnitBall_of_nonneg hr.le] using h.smul r⟩\n#align strict_convex_space.of_strict_convex_closed_unit_ball strict_convex_space.of_strict_convex_closed_unit_ball\n\n",
 "of_pairwise_sphere_norm_ne_two":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem strict_convex_space.of_pairwise_sphere_norm_ne_two\n    (h : (sphere (0 : E) 1).pairwise fun x y => «expr‖ ‖» (x + y) ≠ 2) : strict_convex_space (exprℝ) E :=\n  strict_convex_space.of_norm_add_ne_two fun x y hx hy =>\n    h (mem_sphere_zero_iff_norm.2 hx) (mem_sphere_zero_iff_norm.2 hy)\n#align strict_convex_space.of_pairwise_sphere_norm_ne_two strict_convex_space.of_pairwise_sphere_norm_ne_two\n\n",
 "of_norm_combo_ne_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem strict_convex_space.of_norm_combo_ne_one\n    (h :\n      ∀ x y : E,\n        «expr‖ ‖» x = 1 →\n          «expr‖ ‖» y = 1 →\n            x ≠ y → ∃ a b : exprℝ, 0 ≤ a ∧ 0 ≤ b ∧ a + b = 1 ∧ «expr‖ ‖» («expr • » a x + «expr • » b y) ≠ 1) :\n    strict_convex_space (exprℝ) E :=\n  by\n  refine' strict_convex_space.of_strict_convex_closed_unit_ball (exprℝ) ((convex_closedBall _ _).strict_convex _)\n  simp only [interior_closedBall _ one_ne_zero, closed_ball_diff_ball, Set.Pairwise, frontier_closedBall _ one_ne_zero,\n    mem_sphere_zero_iff_norm]\n  intro x hx y hy hne\n  rcases h x y hx hy hne with ⟨a, b, ha, hb, hab, hne'⟩\n  exact ⟨_, ⟨a, b, ha, hb, hab, rfl⟩, mt mem_sphere_zero_iff_norm.1 hne'⟩\n#align strict_convex_space.of_norm_combo_ne_one strict_convex_space.of_norm_combo_ne_one\n\n",
 "of_norm_combo_lt_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- Strict convexity is equivalent to `‖a • x + b • y‖ < 1` for all `x` and `y` of norm at most `1`\nand all strictly positive `a` and `b` such that `a + b = 1`. This lemma shows that it suffices to\ncheck this for points of norm one and some `a`, `b` such that `a + b = 1`. -/\ntheorem strict_convex_space.of_norm_combo_lt_one\n    (h :\n      ∀ x y : E,\n        «expr‖ ‖» x = 1 →\n          «expr‖ ‖» y = 1 → x ≠ y → ∃ a b : exprℝ, a + b = 1 ∧ «expr‖ ‖» («expr • » a x + «expr • » b y) < 1) :\n    strict_convex_space (exprℝ) E :=\n  by\n  refine'\n    strict_convex_space.of_strict_convex_closed_unit_ball (exprℝ)\n      ((convex_closedBall _ _).strict_convex' fun x hx y hy hne => _)\n  rw [interior_closedBall (0 : E) one_ne_zero, closed_ball_diff_ball, mem_sphere_zero_iff_norm] at hx hy\n  rcases h x y hx hy hne with ⟨a, b, hab, hlt⟩\n  use b\n  rwa [AffineMap.lineMap_apply_module, interior_closedBall (0 : E) one_ne_zero, mem_ball_zero_iff,\n    sub_eq_iff_eq_add.2 hab.symm]\n#align strict_convex_space.of_norm_combo_lt_one strict_convex_space.of_norm_combo_lt_one\n\n",
 "of_norm_add_ne_two":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem strict_convex_space.of_norm_add_ne_two\n    (h : ∀ ⦃x y : E⦄, «expr‖ ‖» x = 1 → «expr‖ ‖» y = 1 → x ≠ y → «expr‖ ‖» (x + y) ≠ 2) :\n    strict_convex_space (exprℝ) E :=\n  by\n  refine'\n    strict_convex_space.of_norm_combo_ne_one fun x y hx hy hne =>\n      ⟨1 / 2, 1 / 2, one_half_pos.le, one_half_pos.le, add_halves _, _⟩\n  rw [← smul_add, norm_smul, Real.norm_of_nonneg one_half_pos.le, one_div, ← div_eq_inv_mul, ne.def,\n    div_eq_one_iff_eq (two_ne_zero' (exprℝ))]\n  exact h hx hy hne\n#align strict_convex_space.of_norm_add_ne_two strict_convex_space.of_norm_add_ne_two\n\n",
 "of_norm_add":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- If `‖x + y‖ = ‖x‖ + ‖y‖` implies that `x y : E` are in the same ray, then `E` is a strictly\nconvex space. See also a more -/\ntheorem strict_convex_space.of_norm_add\n    (h : ∀ x y : E, «expr‖ ‖» x = 1 → «expr‖ ‖» y = 1 → «expr‖ ‖» (x + y) = 2 → SameRay (exprℝ) x y) :\n    strict_convex_space (exprℝ) E :=\n  by\n  refine' strict_convex_space.of_pairwise_sphere_norm_ne_two fun x hx y hy => mt fun h₂ => _\n  rw [mem_sphere_zero_iff_norm] at hx hy\n  exact (sameRay_iff_of_norm_eq (hx.trans hy.symm)).1 (h x y hx hy h₂)\n#align strict_convex_space.of_norm_add strict_convex_space.of_norm_add\n\n",
 "not_same_ray_iff_norm_add_lt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/-- In a strictly convex space, two vectors `x`, `y` are not in the same ray if and only if the\ntriangle inequality for `x` and `y` is strict. -/\ntheorem not_same_ray_iff_norm_add_lt : ¬SameRay (exprℝ) x y ↔ «expr‖ ‖» (x + y) < «expr‖ ‖» x + «expr‖ ‖» y :=\n  same_ray_iff_norm_add.not.trans (norm_add_le _ _).lt_iff_ne.symm\n#align not_same_ray_iff_norm_add_lt not_same_ray_iff_norm_add_lt\n\n",
 "not_same_ray_iff_abs_lt_norm_sub":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem not_same_ray_iff_abs_lt_norm_sub : ¬SameRay (exprℝ) x y ↔ |«expr‖ ‖» x - «expr‖ ‖» y| < «expr‖ ‖» (x - y) :=\n  same_ray_iff_norm_sub.not.trans <| ne_comm.trans (abs_norm_sub_norm_le _ _).lt_iff_ne.symm\n#align not_same_ray_iff_abs_lt_norm_sub not_same_ray_iff_abs_lt_norm_sub\n\n",
 "norm_midpoint_lt_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem norm_midpoint_lt_iff (h : «expr‖ ‖» x = «expr‖ ‖» y) :\n    «expr‖ ‖» («expr • » (1 / 2 : exprℝ) (x + y)) < «expr‖ ‖» x ↔ x ≠ y := by\n  rw [norm_smul, Real.norm_of_nonneg (one_div_nonneg.2 zero_le_two), ← inv_eq_one_div, ← div_eq_inv_mul,\n    div_lt_iff (zero_lt_two' (exprℝ)), mul_two, ← not_sameRay_iff_of_norm_eq h, not_same_ray_iff_norm_add_lt, h]\n#align norm_midpoint_lt_iff norm_midpoint_lt_iff\n\n",
 "norm_combo_lt_of_ne":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- If `x` and `y` are two distinct vectors of norm at most `r`, then a convex combination of `x`\nand `y` with positive coefficients has norm strictly less than `r`. -/\ntheorem norm_combo_lt_of_ne (hx : «expr‖ ‖» x ≤ r) (hy : «expr‖ ‖» y ≤ r) (hne : x ≠ y) (ha : 0 < a) (hb : 0 < b)\n    (hab : a + b = 1) : «expr‖ ‖» («expr • » a x + «expr • » b y) < r :=\n  by\n  simp only [← mem_ball_zero_iff, ← mem_closedBall_zero_iff] at hx hy⊢\n  exact combo_mem_ball_of_ne hx hy hne ha hb hab\n#align norm_combo_lt_of_ne norm_combo_lt_of_ne\n\n",
 "norm_add_lt_of_not_same_ray":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/-- In a strictly convex space, if `x` and `y` are not in the same ray, then `‖x + y‖ < ‖x‖ +\n‖y‖`. -/\ntheorem norm_add_lt_of_not_same_ray (h : ¬SameRay (exprℝ) x y) : «expr‖ ‖» (x + y) < «expr‖ ‖» x + «expr‖ ‖» y :=\n  by\n  simp only [sameRay_iff_inv_norm_smul_eq, not_or, ← ne.def] at h\n  rcases h with ⟨hx, hy, hne⟩\n  rw [← norm_pos_iff] at hx hy\n  have hxy : 0 < «expr‖ ‖» x + «expr‖ ‖» y := add_pos hx hy\n  have :=\n    combo_mem_ball_of_ne (inv_norm_smul_mem_closed_unit_ball x) (inv_norm_smul_mem_closed_unit_ball y) hne\n      (div_pos hx hxy) (div_pos hy hxy) (by rw [← add_div, div_self hxy.ne'])\n  rwa [mem_ball_zero_iff, div_eq_inv_mul, div_eq_inv_mul, mul_smul, mul_smul, smul_inv_smul₀ hx.ne',\n    smul_inv_smul₀ hy.ne', ← smul_add, norm_smul, Real.norm_of_nonneg (inv_pos.2 hxy).le, ← div_eq_inv_mul,\n    div_lt_one hxy] at this\n#align norm_add_lt_of_not_same_ray norm_add_lt_of_not_same_ray\n\n",
 "lt_norm_sub_of_not_same_ray":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem lt_norm_sub_of_not_same_ray (h : ¬SameRay (exprℝ) x y) : «expr‖ ‖» x - «expr‖ ‖» y < «expr‖ ‖» (x - y) :=\n  by\n  nth_rw 1 [← sub_add_cancel x y] at h⊢\n  exact sub_lt_iff_lt_add.2 (norm_add_lt_of_not_same_ray fun H' => h <| H'.add_left SameRay.rfl)\n#align lt_norm_sub_of_not_same_ray lt_norm_sub_of_not_same_ray\n\n",
 "eq_of_norm_eq_of_norm_add_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/-- If `x` and `y` are two vectors in a strictly convex space have the same norm and the norm of\ntheir sum is equal to the sum of their norms, then they are equal. -/\ntheorem eq_of_norm_eq_of_norm_add_eq (h₁ : «expr‖ ‖» x = «expr‖ ‖» y)\n    (h₂ : «expr‖ ‖» (x + y) = «expr‖ ‖» x + «expr‖ ‖» y) : x = y :=\n  (same_ray_iff_norm_add.mpr h₂).eq_of_norm_eq h₁\n#align eq_of_norm_eq_of_norm_add_eq eq_of_norm_eq_of_norm_add_eq\n\n",
 "eq_midpoint_of_dist_eq_half":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem eq_midpoint_of_dist_eq_half {x y z : PE} (hx : dist x y = dist x z / 2) (hy : dist y z = dist x z / 2) :\n    y = midpoint (exprℝ) x z := by\n  apply eq_line_map_of_dist_eq_mul_of_dist_eq_mul\n  · rwa [invOf_eq_inv, ← div_eq_inv_mul]\n  · rwa [invOf_eq_inv, ← one_div, sub_half, one_div, ← div_eq_inv_mul]\n#align eq_midpoint_of_dist_eq_half eq_midpoint_of_dist_eq_half\n\n",
 "eq_line_map_of_dist_eq_mul_of_dist_eq_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `segment -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\ntheorem eq_line_map_of_dist_eq_mul_of_dist_eq_mul {x y z : PE} (hxy : dist x y = r * dist x z)\n    (hyz : dist y z = (1 - r) * dist x z) : y = AffineMap.lineMap x z r :=\n  by\n  have : «expr -ᵥ » y x ∈ segment (0 : E) (exprℝ) («expr -ᵥ » z x) := by\n    rw [← dist_add_dist_eq_iff, dist_zero_left, dist_vsub_cancel_right, ← dist_eq_norm_vsub', ← dist_eq_norm_vsub', hxy,\n      hyz, ← add_mul, add_sub_cancel'_right, one_mul]\n  rcases eq_or_ne x z with (rfl | hne)\n  · obtain rfl : y = x := by simpa\n    simp\n  · rw [← dist_ne_zero] at hne\n    rcases this with ⟨a, b, ha, hb, hab, H⟩\n    rw [smul_zero, zero_add] at H\n    have H' := congr_arg norm H\n    rw [norm_smul, Real.norm_of_nonneg hb, ← dist_eq_norm_vsub', ← dist_eq_norm_vsub', hxy, mul_left_inj' hne] at H'\n    rw [AffineMap.lineMap_apply, ← H', H, vsub_vadd]\n#align eq_line_map_of_dist_eq_mul_of_dist_eq_mul eq_line_map_of_dist_eq_mul_of_dist_eq_mul\n\n",
 "dist_add_dist_eq_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `segment -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- In a strictly convex space, the triangle inequality turns into an equality if and only if the\nmiddle point belongs to the segment joining two other points. -/\ntheorem dist_add_dist_eq_iff : dist x y + dist y z = dist x z ↔ y ∈ segment x (exprℝ) z := by\n  simp only [mem_segment_iff_sameRay, same_ray_iff_norm_add, dist_eq_norm', sub_add_sub_cancel', eq_comm]\n#align dist_add_dist_eq_iff dist_add_dist_eq_iff\n\n",
 "combo_mem_ball_of_ne":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- If `x ≠ y` belong to the same closed ball, then a convex combination of `x` and `y` with\npositive coefficients belongs to the corresponding open ball. -/\ntheorem combo_mem_ball_of_ne (hx : x ∈ closedBall z r) (hy : y ∈ closedBall z r) (hne : x ≠ y) (ha : 0 < a) (hb : 0 < b)\n    (hab : a + b = 1) : «expr • » a x + «expr • » b y ∈ ball z r :=\n  by\n  rcases eq_or_ne r 0 with (rfl | hr)\n  · rw [closed_ball_zero, mem_singleton_iff] at hx hy\n    exact (hne (hx.trans hy.symm)).elim\n  · simp only [← interior_closedBall _ hr] at hx hy⊢\n    exact strict_convex_closed_ball (exprℝ) z r hx hy hne ha hb hab\n#align combo_mem_ball_of_ne combo_mem_ball_of_ne\n\n",
 "coe_affine_isometry_of_strict_convex_space":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n@[simp]\ntheorem coe_affine_isometry_of_strict_convex_space {f : PF → PE} (hi : Isometry f) :\n    «expr⇑ » hi.affine_isometry_of_strict_convex_space = f :=\n  rfl\n#align coe_affine_isometry_of_strict_convex_space coe_affine_isometry_of_strict_convex_space\n\n",
 "affine_isometry_of_strict_convex_space_apply":
 "@[simp]\ntheorem affine_isometry_of_strict_convex_space_apply {f : PF → PE} (hi : Isometry f) (p : PF) :\n    hi.affine_isometry_of_strict_convex_space p = f p :=\n  rfl\n#align affine_isometry_of_strict_convex_space_apply affine_isometry_of_strict_convex_space_apply\n\n",
 "abs_lt_norm_sub_of_not_same_ray":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem abs_lt_norm_sub_of_not_same_ray (h : ¬SameRay (exprℝ) x y) : |«expr‖ ‖» x - «expr‖ ‖» y| < «expr‖ ‖» (x - y) :=\n  by\n  refine' abs_sub_lt_iff.2 ⟨lt_norm_sub_of_not_same_ray h, _⟩\n  rw [norm_sub_rev]\n  exact lt_norm_sub_of_not_same_ray (mt SameRay.symm h)\n#align abs_lt_norm_sub_of_not_same_ray abs_lt_norm_sub_of_not_same_ray\n\n"}