{"subtype":
 "/-- If a family is convex independent, so is any subfamily indexed by a subtype of the index type.\n-/\nprotected theorem convex_independent.subtype {p : ι → E} (hc : convex_independent 𝕜 p) (s : set ι) :\n    convex_independent 𝕜 fun i : s => p i :=\n  hc.comp_embedding (Embedding.subtype _)\n#align convex_independent.subtype convex_independent.subtype\n\n",
 "range":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ↪ » -/\n/-- If an indexed family of points is convex independent, so is the corresponding set of points. -/\nprotected theorem convex_independent.range {p : ι → E} (hc : convex_independent 𝕜 p) :\n    convex_independent 𝕜 (fun x => x : Set.range p → E) :=\n  by\n  let f : Set.range p → ι := fun x => x.property.some\n  have hf : ∀ x, p (f x) = x := fun x => x.property.some_spec\n  let fe : «expr ↪ » (Set.range p) ι := ⟨f, fun x₁ x₂ he => subtype.ext (hf x₁ ▸ hf x₂ ▸ he ▸ rfl)⟩\n  convert hc.comp_embedding fe\n  ext\n  rw [embedding.coe_fn_mk, comp_app, hf]\n#align convex_independent.range convex_independent.range\n\n",
 "mono":
 "/-- A subset of a convex independent set of points is convex independent as well. -/\nprotected theorem convex_independent.mono {s t : set E} (hc : convex_independent 𝕜 (fun x => x : t → E)) (hs : s ⊆ t) :\n    convex_independent 𝕜 (fun x => x : s → E) :=\n  hc.comp_embedding (s.embedding_of_subset t hs)\n#align convex_independent.mono convex_independent.mono\n\n",
 "mem_convex_hull_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/-- If a family is convex independent, a point in the family is in the convex hull of some of the\npoints given by a subset of the index type if and only if the point's index is in this subset. -/\n@[simp]\nprotected theorem convex_independent.mem_convex_hull_iff {p : ι → E} (hc : convex_independent 𝕜 p) (s : set ι) (i : ι) :\n    p i ∈ convex_hull 𝕜 («expr '' » p s) ↔ i ∈ s :=\n  ⟨hc _ _, fun hi => subset_convex_hull 𝕜 _ (Set.mem_image_of_mem p hi)⟩\n#align convex_independent.mem_convex_hull_iff convex_independent.mem_convex_hull_iff\n\n",
 "injective":
 "/-- A convex independent family is injective. -/\nprotected theorem convex_independent.injective {p : ι → E} (hc : convex_independent 𝕜 p) : function.injective p :=\n  by\n  refine' fun i j hij => hc {j} i _\n  rw [hij, Set.image_singleton, convex_hull_singleton]\n  exact Set.mem_singleton _\n#align convex_independent.injective convex_independent.injective\n\n",
 "convex_independent_set_iff_not_mem_convex_hull_diff":
 "/-- If a set is convex independent, a point in the set is not in the convex hull of the other\npoints. See `convex_independent_iff_not_mem_convex_hull_diff` for the indexed family version.  -/\ntheorem convex_independent_set_iff_not_mem_convex_hull_diff {s : set E} :\n    convex_independent 𝕜 (fun x => x : s → E) ↔ ∀ x ∈ s, x ∉ convex_hull 𝕜 (s \\ {x}) :=\n  by\n  rw [convex_independent_set_iff_inter_convex_hull_subset]\n  constructor\n  · rintro hs x hxs hx\n    exact (hs _ (Set.diff_subset _ _) ⟨hxs, hx⟩).2 (Set.mem_singleton _)\n  · rintro hs t ht x ⟨hxs, hxt⟩\n    by_contra h\n    exact hs _ hxs (convex_hull_mono (Set.subset_diff_singleton ht h) hxt)\n#align convex_independent_set_iff_not_mem_convex_hull_diff convex_independent_set_iff_not_mem_convex_hull_diff\n\n",
 "convex_independent_set_iff_inter_convex_hull_subset":
 "theorem convex_independent_set_iff_inter_convex_hull_subset {s : set E} :\n    convex_independent 𝕜 (fun x => x : s → E) ↔ ∀ t, t ⊆ s → s ∩ convex_hull 𝕜 t ⊆ t :=\n  by\n  constructor\n  · rintro hc t h x ⟨hxs, hxt⟩\n    refine' hc { x | ↑x ∈ t } ⟨x, hxs⟩ _\n    rw [Subtype.coe_image_of_subset h]\n    exact hxt\n  · intro hc t x h\n    rw [← subtype.coe_injective.mem_set_image]\n    exact hc (t.image coe) (Subtype.coe_image_subset s t) ⟨x.prop, h⟩\n#align convex_independent_set_iff_inter_convex_hull_subset convex_independent_set_iff_inter_convex_hull_subset\n\n",
 "convex_independent_iff_set":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ↪ » -/\n/-- The range of an injective indexed family of points is convex independent iff that family is. -/\ntheorem function.injective.convex_independent_iff_set {p : ι → E} (hi : function.injective p) :\n    convex_independent 𝕜 (fun x => x : Set.range p → E) ↔ convex_independent 𝕜 p :=\n  ⟨fun hc =>\n    hc.comp_embedding\n      (⟨fun i => ⟨p i, Set.mem_range_self _⟩, fun x y h => hi (subtype.mk_eq_mk.1 h)⟩ : «expr ↪ » ι (Set.range p)),\n    convex_independent.range⟩\n#align function.injective.convex_independent_iff_set function.injective.convex_independent_iff_set\n\n",
 "convex_independent_iff_not_mem_convex_hull_diff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/-- If a family is convex independent, a point in the family is not in the convex hull of the other\npoints. See `convex_independent_set_iff_not_mem_convex_hull_diff` for the `set` version.  -/\ntheorem convex_independent_iff_not_mem_convex_hull_diff {p : ι → E} :\n    convex_independent 𝕜 p ↔ ∀ i s, p i ∉ convex_hull 𝕜 («expr '' » p (s \\ {i})) :=\n  by\n  refine' ⟨fun hc i s h => _, fun h s i hi => _⟩\n  · rw [hc.mem_convex_hull_iff] at h\n    exact h.2 (Set.mem_singleton _)\n  · by_contra H\n    refine' h i s _\n    rw [Set.diff_singleton_eq_self H]\n    exact hi\n#align convex_independent_iff_not_mem_convex_hull_diff convex_independent_iff_not_mem_convex_hull_diff\n\n",
 "convex_independent_iff_finset":
 "/-- To check convex independence, one only has to check finsets thanks to Carathéodory's theorem. -/\ntheorem convex_independent_iff_finset {p : ι → E} :\n    convex_independent 𝕜 p ↔ ∀ (s : Finset ι) (x : ι), p x ∈ convex_hull 𝕜 (s.image p : set E) → x ∈ s :=\n  by\n  refine' ⟨fun hc s x hx => hc s x _, fun h s x hx => _⟩\n  · rwa [Finset.coe_image] at hx\n  have hp : injective p := by\n    rintro a b hab\n    rw [← mem_singleton]\n    refine' h {b} a _\n    rw [hab, image_singleton, coe_singleton, convex_hull_singleton]\n    exact Set.mem_singleton _\n  rw [convex_hull_eq_union_convex_hull_finite_subsets] at hx\n  simp_rw [Set.mem_unionᵢ] at hx\n  obtain ⟨t, ht, hx⟩ := hx\n  rw [← hp.mem_set_image]\n  refine' ht _\n  suffices x ∈ t.preimage p (hp.inj_on _) by rwa [mem_preimage, ← mem_coe] at this\n  refine' h _ x _\n  rwa [t.image_preimage p (hp.inj_on _), filter_true_of_mem]\n  · exact fun y hy => s.image_subset_range p (ht <| mem_coe.2 hy)\n#align convex_independent_iff_finset convex_independent_iff_finset\n\n",
 "convex_independent_extreme_points":
 "theorem convex.convex_independent_extreme_points (hs : convex 𝕜 s) :\n    convex_independent 𝕜 (fun p => p : s.extreme_points 𝕜 → E) :=\n  convex_independent_set_iff_not_mem_convex_hull_diff.2 fun x hx h =>\n    (extreme_points_convex_hull_subset\n          (inter_extreme_points_subset_extreme_points_of_subset\n            (convex_hull_min ((Set.diff_subset _ _).trans extreme_points_subset) hs) ⟨h, hx⟩)).2\n      (Set.mem_singleton _)\n#align convex.convex_independent_extreme_points convex.convex_independent_extreme_points\n\n",
 "convex_independent":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/-\nCopyright (c) 2021 Yaël Dillies, Bhavik Mehta. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yaël Dillies, Bhavik Mehta\n-/\n/-- A family with at most one point is convex independent. -/\ntheorem subsingleton.convex_independent [subsingleton ι] (p : ι → E) : convex_independent 𝕜 p := fun s x hx =>\n  by\n  have : (convex_hull 𝕜 («expr '' » p s)).nonempty := ⟨p x, hx⟩\n  rw [convex_hull_nonempty_iff, Set.nonempty_image_iff] at this\n  rwa [Subsingleton.mem_iff_nonempty]\n#align subsingleton.convex_independent subsingleton.convex_independent\n\n",
 "comp_embedding":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ↪ » -/\n/-- If a family is convex independent, so is any subfamily given by composition of an embedding into\nindex type with the original family. -/\ntheorem convex_independent.comp_embedding {ι' : Type _} (f : «expr ↪ » ι' ι) {p : ι → E} (hc : convex_independent 𝕜 p) :\n    convex_independent 𝕜 (p ∘ f) := by\n  intro s x hx\n  rw [← f.injective.mem_set_image]\n  exact hc _ _ (by rwa [Set.image_image])\n#align convex_independent.comp_embedding convex_independent.comp_embedding\n\n"}