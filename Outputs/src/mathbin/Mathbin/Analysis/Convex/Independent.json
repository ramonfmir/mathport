{"subtype":
 "#print ConvexIndependent.subtype /-\n/-- If a family is convex independent, so is any subfamily indexed by a subtype of the index type.\n-/\nprotected theorem ConvexIndependent.subtype {p : Î¹ â†’ E} (hc : ConvexIndependent ğ•œ p) (s : Set Î¹) :\n    ConvexIndependent ğ•œ fun i : s => p i :=\n  hc.comp_embedding (Embedding.subtype _)\n#align convex_independent.subtype ConvexIndependent.subtype\n-/\n\n",
 "range":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†ª Â» -/\n#print ConvexIndependent.range /-\n/-- If an indexed family of points is convex independent, so is the corresponding set of points. -/\nprotected theorem ConvexIndependent.range {p : Î¹ â†’ E} (hc : ConvexIndependent ğ•œ p) :\n    ConvexIndependent ğ•œ (fun x => x : Set.range p â†’ E) :=\n  by\n  let f : Set.range p â†’ Î¹ := fun x => x.property.some\n  have hf : âˆ€ x, p (f x) = x := fun x => x.property.some_spec\n  let fe : Â«expr â†ª Â» (Set.range p) Î¹ := âŸ¨f, fun xâ‚ xâ‚‚ he => Subtype.ext (hf xâ‚ â–¸ hf xâ‚‚ â–¸ he â–¸ rfl)âŸ©\n  convert hc.comp_embedding fe\n  ext\n  rw [embedding.coe_fn_mk, comp_app, hf]\n#align convex_independent.range ConvexIndependent.range\n-/\n\n",
 "mono":
 "#print ConvexIndependent.mono /-\n/-- A subset of a convex independent set of points is convex independent as well. -/\nprotected theorem ConvexIndependent.mono {s t : Set E} (hc : ConvexIndependent ğ•œ (fun x => x : t â†’ E)) (hs : s âŠ† t) :\n    ConvexIndependent ğ•œ (fun x => x : s â†’ E) :=\n  hc.comp_embedding (s.embedding_of_subset t hs)\n#align convex_independent.mono ConvexIndependent.mono\n-/\n\n",
 "mem_convexHull_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n#print ConvexIndependent.mem_convexHull_iff /-\n/-- If a family is convex independent, a point in the family is in the convex hull of some of the\npoints given by a subset of the index type if and only if the point's index is in this subset. -/\n@[simp]\nprotected theorem ConvexIndependent.mem_convexHull_iff {p : Î¹ â†’ E} (hc : ConvexIndependent ğ•œ p) (s : Set Î¹) (i : Î¹) :\n    p i âˆˆ convexHull ğ•œ (Â«expr '' Â» p s) â†” i âˆˆ s :=\n  âŸ¨hc _ _, fun hi => subset_convexHull ğ•œ _ (Set.mem_image_of_mem p hi)âŸ©\n#align convex_independent.mem_convex_hull_iff ConvexIndependent.mem_convexHull_iff\n-/\n\n",
 "injective":
 "#print ConvexIndependent.injective /-\n/-- A convex independent family is injective. -/\nprotected theorem ConvexIndependent.injective {p : Î¹ â†’ E} (hc : ConvexIndependent ğ•œ p) : function.injective p :=\n  by\n  refine' fun i j hij => hc {j} i _\n  rw [hij, Set.image_singleton, convexHull_singleton]\n  exact Set.mem_singleton _\n#align convex_independent.injective ConvexIndependent.injective\n-/\n\n",
 "convexIndependent_set_iff_not_mem_convexHull_diff":
 "#print convexIndependent_set_iff_not_mem_convexHull_diff /-\n/-- If a set is convex independent, a point in the set is not in the convex hull of the other\npoints. See `convex_independent_iff_not_mem_convex_hull_diff` for the indexed family version.  -/\ntheorem convexIndependent_set_iff_not_mem_convexHull_diff {s : Set E} :\n    ConvexIndependent ğ•œ (fun x => x : s â†’ E) â†” âˆ€ x âˆˆ s, x âˆ‰ convexHull ğ•œ (s \\ {x}) :=\n  by\n  rw [convexIndependent_set_iff_inter_convexHull_subset]\n  constructor\n  Â· rintro hs x hxs hx\n    exact (hs _ (Set.diff_subset _ _) âŸ¨hxs, hxâŸ©).2 (Set.mem_singleton _)\n  Â· rintro hs t ht x âŸ¨hxs, hxtâŸ©\n    by_contra h\n    exact hs _ hxs (convexHull_mono (Set.subset_diff_singleton ht h) hxt)\n#align convex_independent_set_iff_not_mem_convex_hull_diff convexIndependent_set_iff_not_mem_convexHull_diff\n-/\n\n",
 "convexIndependent_set_iff_inter_convexHull_subset":
 "#print convexIndependent_set_iff_inter_convexHull_subset /-\ntheorem convexIndependent_set_iff_inter_convexHull_subset {s : Set E} :\n    ConvexIndependent ğ•œ (fun x => x : s â†’ E) â†” âˆ€ t, t âŠ† s â†’ s âˆ© convexHull ğ•œ t âŠ† t :=\n  by\n  constructor\n  Â· rintro hc t h x âŸ¨hxs, hxtâŸ©\n    refine' hc { x | â†‘x âˆˆ t } âŸ¨x, hxsâŸ© _\n    rw [Subtype.coe_image_of_subset h]\n    exact hxt\n  Â· intro hc t x h\n    rw [â† subtype.coe_injective.mem_set_image]\n    exact hc (t.image coe) (Subtype.coe_image_subset s t) âŸ¨x.prop, hâŸ©\n#align convex_independent_set_iff_inter_convex_hull_subset convexIndependent_set_iff_inter_convexHull_subset\n-/\n\n",
 "convexIndependent_iff_set":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†ª Â» -/\n#print Function.Injective.convexIndependent_iff_set /-\n/-- The range of an injective indexed family of points is convex independent iff that family is. -/\ntheorem Function.Injective.convexIndependent_iff_set {p : Î¹ â†’ E} (hi : function.injective p) :\n    ConvexIndependent ğ•œ (fun x => x : Set.range p â†’ E) â†” ConvexIndependent ğ•œ p :=\n  âŸ¨fun hc =>\n    hc.comp_embedding\n      (âŸ¨fun i => âŸ¨p i, Set.mem_range_self _âŸ©, fun x y h => hi (Subtype.mk_eq_mk.1 h)âŸ© : Â«expr â†ª Â» Î¹ (Set.range p)),\n    ConvexIndependent.rangeâŸ©\n#align function.injective.convex_independent_iff_set Function.Injective.convexIndependent_iff_set\n-/\n\n",
 "convexIndependent_iff_not_mem_convexHull_diff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n#print convexIndependent_iff_not_mem_convexHull_diff /-\n/-- If a family is convex independent, a point in the family is not in the convex hull of the other\npoints. See `convex_independent_set_iff_not_mem_convex_hull_diff` for the `set` version.  -/\ntheorem convexIndependent_iff_not_mem_convexHull_diff {p : Î¹ â†’ E} :\n    ConvexIndependent ğ•œ p â†” âˆ€ i s, p i âˆ‰ convexHull ğ•œ (Â«expr '' Â» p (s \\ {i})) :=\n  by\n  refine' âŸ¨fun hc i s h => _, fun h s i hi => _âŸ©\n  Â· rw [hc.mem_convex_hull_iff] at h\n    exact h.2 (Set.mem_singleton _)\n  Â· by_contra H\n    refine' h i s _\n    rw [Set.diff_singleton_eq_self H]\n    exact hi\n#align convex_independent_iff_not_mem_convex_hull_diff convexIndependent_iff_not_mem_convexHull_diff\n-/\n\n",
 "convexIndependent_iff_finset":
 "#print convexIndependent_iff_finset /-\n/-- To check convex independence, one only has to check finsets thanks to CarathÃ©odory's theorem. -/\ntheorem convexIndependent_iff_finset {p : Î¹ â†’ E} :\n    ConvexIndependent ğ•œ p â†” âˆ€ (s : Finset Î¹) (x : Î¹), p x âˆˆ convexHull ğ•œ (s.image p : Set E) â†’ x âˆˆ s :=\n  by\n  refine' âŸ¨fun hc s x hx => hc s x _, fun h s x hx => _âŸ©\n  Â· rwa [Finset.coe_image] at hx\n  have hp : injective p := by\n    rintro a b hab\n    rw [â† mem_singleton]\n    refine' h {b} a _\n    rw [hab, image_singleton, coe_singleton, convexHull_singleton]\n    exact Set.mem_singleton _\n  rw [convexHull_eq_union_convexHull_finite_subsets] at hx\n  simp_rw [Set.mem_unionáµ¢] at hx\n  obtain âŸ¨t, ht, hxâŸ© := hx\n  rw [â† hp.mem_set_image]\n  refine' ht _\n  suffices x âˆˆ t.preimage p (hp.inj_on _) by rwa [mem_preimage, â† mem_coe] at this\n  refine' h _ x _\n  rwa [t.image_preimage p (hp.inj_on _), filter_true_of_mem]\n  Â· exact fun y hy => s.image_subset_range p (ht <| mem_coe.2 hy)\n#align convex_independent_iff_finset convexIndependent_iff_finset\n-/\n\n",
 "convexIndependent_extremePoints":
 "#print Convex.convexIndependent_extremePoints /-\ntheorem Convex.convexIndependent_extremePoints (hs : Convex ğ•œ s) :\n    ConvexIndependent ğ•œ (fun p => p : s.extreme_points ğ•œ â†’ E) :=\n  convexIndependent_set_iff_not_mem_convexHull_diff.2 fun x hx h =>\n    (extremePoints_convexHull_subset\n          (inter_extremePoints_subset_extremePoints_of_subset\n            (convexHull_min ((Set.diff_subset _ _).trans extremePoints_subset) hs) âŸ¨h, hxâŸ©)).2\n      (Set.mem_singleton _)\n#align convex.convex_independent_extreme_points Convex.convexIndependent_extremePoints\n-/\n\n",
 "convexIndependent":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n#print Subsingleton.convexIndependent /-\n/-\nCopyright (c) 2021 YaÃ«l Dillies, Bhavik Mehta. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: YaÃ«l Dillies, Bhavik Mehta\n-/\n/-- A family with at most one point is convex independent. -/\ntheorem Subsingleton.convexIndependent [subsingleton Î¹] (p : Î¹ â†’ E) : ConvexIndependent ğ•œ p := fun s x hx =>\n  by\n  have : (convexHull ğ•œ (Â«expr '' Â» p s)).nonempty := âŸ¨p x, hxâŸ©\n  rw [convexHull_nonempty_iff, Set.nonempty_image_iff] at this\n  rwa [Subsingleton.mem_iff_nonempty]\n#align subsingleton.convex_independent Subsingleton.convexIndependent\n-/\n\n",
 "comp_embedding":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†ª Â» -/\n#print ConvexIndependent.comp_embedding /-\n/-- If a family is convex independent, so is any subfamily given by composition of an embedding into\nindex type with the original family. -/\ntheorem ConvexIndependent.comp_embedding {Î¹' : Type _} (f : Â«expr â†ª Â» Î¹' Î¹) {p : Î¹ â†’ E} (hc : ConvexIndependent ğ•œ p) :\n    ConvexIndependent ğ•œ (p âˆ˜ f) := by\n  intro s x hx\n  rw [â† f.injective.mem_set_image]\n  exact hc _ _ (by rwa [Set.image_image])\n#align convex_independent.comp_embedding ConvexIndependent.comp_embedding\n-/\n\n"}