{"star_convex":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem balanced.star_convex (hs : balanced (exprℝ) s) : star_convex (exprℝ) 0 s :=\n  star_convex_zero_iff.2 fun x hx a ha₀ ha₁ => hs _ (by rwa [real.norm_of_nonneg ha₀]) (smul_mem_smul_set hx)\n#align balanced.star_convex balanced.star_convex\n\n",
 "self_subset_gauge_le_one":
 "theorem self_subset_gauge_le_one : s ⊆ { x | gauge s x ≤ 1 } := fun x => gauge_le_one_of_mem\n#align self_subset_gauge_le_one self_subset_gauge_le_one\n\n",
 "one_le_gauge_of_not_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem one_le_gauge_of_not_mem (hs₁ : star_convex (exprℝ) 0 s) (hs₂ : absorbs (exprℝ) s {x}) (hx : x ∉ s) :\n    1 ≤ gauge s x :=\n  le_gauge_of_not_mem hs₁ hs₂ <| by rwa [one_smul]\n#align one_le_gauge_of_not_mem one_le_gauge_of_not_mem\n\n",
 "mul_gauge_le_norm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem mul_gauge_le_norm (hs : metric.ball (0 : E) r ⊆ s) : r * gauge s x ≤ «expr‖ ‖» x :=\n  by\n  obtain hr | hr := le_or_lt r 0\n  · exact (mul_nonpos_of_nonpos_of_nonneg hr <| gauge_nonneg _).trans (norm_nonneg _)\n  rw [mul_comm, ← le_div_iff hr, ← gauge_ball hr]\n  exact gauge_mono (absorbent_ball_zero hr) hs x\n#align mul_gauge_le_norm mul_gauge_le_norm\n\n",
 "le_gauge_of_not_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem le_gauge_of_not_mem (hs₀ : star_convex (exprℝ) 0 s) (hs₂ : absorbs (exprℝ) s {x}) (hx : x ∉ «expr • » a s) :\n    a ≤ gauge s x := by\n  rw [star_convex_zero_iff] at hs₀\n  obtain ⟨r, hr, h⟩ := hs₂\n  refine' le_cinfₛ ⟨r, hr, singleton_subset_iff.1 <| h _ (real.norm_of_nonneg hr.le).ge⟩ _\n  rintro b ⟨hb, x, hx', rfl⟩\n  refine' not_lt.1 fun hba => hx _\n  have ha := hb.trans hba\n  refine' ⟨«expr • » (a⁻¹ * b) x, hs₀ hx' (by positivity) _, _⟩\n  · rw [← div_eq_inv_mul]\n    exact div_le_one_of_le hba.le ha.le\n  · rw [← mul_smul, mul_inv_cancel_left₀ ha.ne']\n#align le_gauge_of_not_mem le_gauge_of_not_mem\n\n",
 "interior_subset_gauge_lt_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem interior_subset_gauge_lt_one (s : set E) : interior s ⊆ { x | gauge s x < 1 } :=\n  by\n  intro x hx\n  let f : exprℝ → E := fun t => «expr • » t x\n  have hf : continuous f := by continuity\n  let s' := «expr ⁻¹' » f (interior s)\n  have hs' : is_open s' := hf.is_open_preimage _ is_open_interior\n  have one_mem : (1 : exprℝ) ∈ s' := by simpa only [s', f, Set.mem_preimage, one_smul]\n  obtain ⟨ε, hε₀, hε⟩ := (metric.nhds_basis_closed_ball.1 _).1 (is_open_iff_mem_nhds.1 hs' 1 one_mem)\n  rw [real.closed_ball_eq_Icc] at hε\n  have hε₁ : 0 < 1 + ε := hε₀.trans (lt_one_add ε)\n  have : (1 + ε)⁻¹ < 1 := by\n    rw [inv_lt_one_iff]\n    right\n    linarith\n  refine' (gauge_le_of_mem (inv_nonneg.2 hε₁.le) _).trans_lt this\n  rw [mem_inv_smul_set_iff₀ hε₁.ne']\n  exact interior_subset (hε ⟨(sub_le_self _ hε₀.le).trans ((le_add_iff_nonneg_right _).2 hε₀.le), le_rfl⟩)\n#align interior_subset_gauge_lt_one interior_subset_gauge_lt_one\n\n",
 "gauge_zero'":
 "@[simp]\ntheorem gauge_zero' : gauge (0 : set E) = 0 := by\n  ext\n  rw [gauge_def']\n  obtain rfl | hx := eq_or_ne x 0\n  · simp only [cinfₛ_Ioi, mem_zero, pi.zero_apply, eq_self_iff_true, sep_true, smul_zero]\n  · simp only [mem_zero, pi.zero_apply, inv_eq_zero, smul_eq_zero]\n    convert real.Inf_empty\n    exact eq_empty_iff_forall_not_mem.2 fun r hr => hr.2.elim (ne_of_gt hr.1) hx\n#align gauge_zero' gauge_zero'\n\n",
 "gauge_zero":
 "/-- The gauge evaluated at `0` is always zero (mathematically this requires `0` to be in the set `s`\nbut, the real infimum of the empty set in Lean being defined as `0`, it holds unconditionally). -/\n@[simp]\ntheorem gauge_zero : gauge s 0 = 0 := by\n  rw [gauge_def']\n  by_cases (0 : E) ∈ s\n  · simp only [smul_zero, sep_true, h, cinfₛ_Ioi]\n  · simp only [smul_zero, sep_false, h, real.Inf_empty]\n#align gauge_zero gauge_zero\n\n",
 "gauge_unit_ball":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem gauge_unit_ball (x : E) : gauge (metric.ball (0 : E) 1) x = «expr‖ ‖» x :=\n  by\n  obtain rfl | hx := eq_or_ne x 0\n  · rw [norm_zero, gauge_zero]\n  refine' (le_of_forall_pos_le_add fun ε hε => _).antisymm _\n  · have : 0 < «expr‖ ‖» x + ε := by positivity\n    refine' gauge_le_of_mem this.le _\n    rw [smul_ball this.ne', smul_zero, real.norm_of_nonneg this.le, mul_one, mem_ball_zero_iff]\n    exact lt_add_of_pos_right _ hε\n  refine' le_gauge_of_not_mem balanced_ball_zero.star_convex (absorbent_ball_zero zero_lt_one).absorbs fun h => _\n  obtain hx' | hx' := eq_or_ne («expr‖ ‖» x) 0\n  · rw [hx'] at h\n    exact hx (zero_smul_set_subset _ h)\n  · rw [mem_smul_set_iff_inv_smul_mem₀ hx', mem_ball_zero_iff, norm_smul, norm_inv, norm_norm, inv_mul_cancel hx'] at h\n    exact lt_irrefl _ h\n#align gauge_unit_ball gauge_unit_ball\n\n",
 "gauge_smul_of_nonneg":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem gauge_smul_of_nonneg [MulActionWithZero α E] [IsScalarTower α (exprℝ) (set E)] {s : set E} {a : α} (ha : 0 ≤ a)\n    (x : E) : gauge s («expr • » a x) = «expr • » a (gauge s x) :=\n  by\n  obtain rfl | ha' := ha.eq_or_lt\n  · rw [zero_smul, gauge_zero, zero_smul]\n  rw [gauge_def', gauge_def', ← real.Inf_smul_of_nonneg ha]\n  congr 1\n  ext r\n  simp_rw [Set.mem_smul_set, Set.mem_sep_iff]\n  constructor\n  · rintro ⟨hr, hx⟩\n    simp_rw [mem_Ioi] at hr⊢\n    rw [← mem_smul_set_iff_inv_smul_mem₀ hr.ne'] at hx\n    have := smul_pos (inv_pos.2 ha') hr\n    refine' ⟨«expr • » a⁻¹ r, ⟨this, _⟩, smul_inv_smul₀ ha'.ne' _⟩\n    rwa [← mem_smul_set_iff_inv_smul_mem₀ this.ne', smul_assoc, mem_smul_set_iff_inv_smul_mem₀ (inv_ne_zero ha'.ne'),\n      inv_inv]\n  · rintro ⟨r, ⟨hr, hx⟩, rfl⟩\n    rw [mem_Ioi] at hr⊢\n    rw [← mem_smul_set_iff_inv_smul_mem₀ hr.ne'] at hx\n    have := smul_pos ha' hr\n    refine' ⟨this, _⟩\n    rw [← mem_smul_set_iff_inv_smul_mem₀ this.ne', smul_assoc]\n    exact smul_mem_smul_set hx\n#align gauge_smul_of_nonneg gauge_smul_of_nonneg\n\n",
 "gauge_smul_left_of_nonneg":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem gauge_smul_left_of_nonneg [MulActionWithZero α E] [SMulCommClass α (exprℝ) (exprℝ)]\n    [IsScalarTower α (exprℝ) (exprℝ)] [IsScalarTower α (exprℝ) E] {s : set E} {a : α} (ha : 0 ≤ a) :\n    gauge («expr • » a s) = «expr • » a⁻¹ (gauge s) :=\n  by\n  obtain rfl | ha' := ha.eq_or_lt\n  · rw [inv_zero, zero_smul, gauge_of_subset_zero (zero_smul_set_subset _)]\n  ext\n  rw [gauge_def', pi.smul_apply, gauge_def', ← real.Inf_smul_of_nonneg (inv_nonneg.2 ha)]\n  congr 1\n  ext r\n  simp_rw [Set.mem_smul_set, Set.mem_sep_iff]\n  constructor\n  · rintro ⟨hr, y, hy, h⟩\n    simp_rw [mem_Ioi] at hr⊢\n    refine' ⟨«expr • » a r, ⟨smul_pos ha' hr, _⟩, inv_smul_smul₀ ha'.ne' _⟩\n    rwa [smul_inv₀, smul_assoc, ← h, inv_smul_smul₀ ha'.ne']\n  · rintro ⟨r, ⟨hr, hx⟩, rfl⟩\n    rw [mem_Ioi] at hr⊢\n    have := smul_pos ha' hr\n    refine' ⟨smul_pos (inv_pos.2 ha') hr, «expr • » r⁻¹ x, hx, _⟩\n    rw [smul_inv₀, smul_assoc, inv_inv]\n#align gauge_smul_left_of_nonneg gauge_smul_left_of_nonneg\n\n",
 "gauge_smul_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem gauge_smul_left [Module α E] [SMulCommClass α (exprℝ) (exprℝ)] [IsScalarTower α (exprℝ) (exprℝ)]\n    [IsScalarTower α (exprℝ) E] {s : set E} (symmetric : ∀ x ∈ s, -x ∈ s) (a : α) :\n    gauge («expr • » a s) = «expr • » (|a|)⁻¹ (gauge s) :=\n  by\n  rw [← gauge_smul_left_of_nonneg (abs_nonneg a)]\n  obtain h | h := abs_choice a\n  · rw [h]\n  · rw [h, Set.neg_smul_set, ← Set.smul_set_neg]\n    congr\n    ext y\n    refine' ⟨symmetric _, fun hy => _⟩\n    rw [← neg_neg y]\n    exact symmetric _ hy\n  · infer_instance\n#align gauge_smul_left gauge_smul_left\n\n",
 "gauge_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/-- If `s` is balanced, then the Minkowski functional is ℂ-homogeneous. -/\ntheorem gauge_smul (hs : balanced 𝕜 s) (r : 𝕜) (x : E) : gauge s («expr • » r x) = «expr‖ ‖» r * gauge s x :=\n  by\n  rw [← smul_eq_mul, ← gauge_smul_of_nonneg (norm_nonneg r), gauge_norm_smul hs]\n  infer_instance\n#align gauge_smul gauge_smul\n\n",
 "gauge_set_nonempty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- If the given subset is `absorbent` then the set we take an infimum over in `gauge` is nonempty,\nwhich is useful for proving many properties about the gauge.  -/\ntheorem absorbent.gauge_set_nonempty (absorbs : absorbent (exprℝ) s) :\n    { r : exprℝ | 0 < r ∧ x ∈ «expr • » r s }.nonempty :=\n  let ⟨r, hr₁, hr₂⟩ := absorbs x\n  ⟨r, hr₁, hr₂ r (real.norm_of_nonneg hr₁.le).ge⟩\n#align absorbent.gauge_set_nonempty absorbent.gauge_set_nonempty\n\n",
 "gauge_set_bdd_below":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\nprivate theorem gauge_set_bdd_below : BddBelow { r : exprℝ | 0 < r ∧ x ∈ «expr • » r s } :=\n  ⟨0, fun r hr => hr.1.le⟩\n#align gauge_set_bdd_below gauge_set_bdd_below\n\n",
 "gauge_seminorm_lt_one_of_open":
 "theorem gauge_seminorm_lt_one_of_open (hs : is_open s) {x : E} (hx : x ∈ s) : gauge_seminorm hs₀ hs₁ hs₂ x < 1 :=\n  gauge_lt_one_of_mem_of_open hs₁ hs₂.zero_mem hs hx\n#align gauge_seminorm_lt_one_of_open gauge_seminorm_lt_one_of_open\n\n",
 "gauge_seminorm_ball_one":
 "theorem gauge_seminorm_ball_one (hs : is_open s) : (gauge_seminorm hs₀ hs₁ hs₂).ball 0 1 = s :=\n  by\n  rw [seminorm.ball_zero_eq]\n  exact gauge_lt_one_eq_self_of_open hs₁ hs₂.zero_mem hs\n#align gauge_seminorm_ball_one gauge_seminorm_ball_one\n\n",
 "gauge_seminorm_ball":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem seminorm.gauge_seminorm_ball (p : seminorm (exprℝ) E) :\n    gauge_seminorm (p.balanced_ball_zero 1) (p.convex_ball 0 1) (p.absorbent_ball_zero zero_lt_one) = p :=\n  fun_like.coe_injective p.gauge_ball\n#align seminorm.gauge_seminorm_ball seminorm.gauge_seminorm_ball\n\n",
 "gauge_of_subset_zero":
 "theorem gauge_of_subset_zero (h : s ⊆ 0) : gauge s = 0 :=\n  by\n  obtain rfl | rfl := subset_singleton_iff_eq.1 h\n  exacts[gauge_empty, gauge_zero']\n#align gauge_of_subset_zero gauge_of_subset_zero\n\n",
 "gauge_norm_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem gauge_norm_smul (hs : balanced 𝕜 s) (r : 𝕜) (x : E) :\n    gauge s («expr • » («expr‖ ‖» r) x) = gauge s («expr • » r x) :=\n  by\n  rw [@is_R_or_C.real_smul_eq_coe_smul 𝕜]\n  obtain rfl | hr := eq_or_ne r 0\n  · simp only [norm_zero, is_R_or_C.of_real_zero]\n  unfold gauge\n  congr with θ\n  refine' and_congr_right fun hθ => (hs.smul _).mem_smul_iff _\n  rw [is_R_or_C.norm_of_real, norm_norm]\n#align gauge_norm_smul gauge_norm_smul\n\n",
 "gauge_nonneg":
 "/-- The gauge is always nonnegative. -/\ntheorem gauge_nonneg (x : E) : 0 ≤ gauge s x :=\n  real.Inf_nonneg _ fun x hx => hx.1.le\n#align gauge_nonneg gauge_nonneg\n\n",
 "gauge_neg_set_neg":
 "theorem gauge_neg_set_neg (x : E) : gauge (-s) (-x) = gauge s x := by simp_rw [gauge_def', smul_neg, neg_mem_neg]\n#align gauge_neg_set_neg gauge_neg_set_neg\n\n",
 "gauge_neg_set_eq_gauge_neg":
 "theorem gauge_neg_set_eq_gauge_neg (x : E) : gauge (-s) x = gauge s (-x) := by rw [← gauge_neg_set_neg, neg_neg]\n#align gauge_neg_set_eq_gauge_neg gauge_neg_set_eq_gauge_neg\n\n",
 "gauge_neg":
 "theorem gauge_neg (symmetric : ∀ x ∈ s, -x ∈ s) (x : E) : gauge s (-x) = gauge s x :=\n  by\n  have : ∀ x, -x ∈ s ↔ x ∈ s := fun x => ⟨fun h => by simpa using symmetric _ h, symmetric x⟩\n  simp_rw [gauge_def', smul_neg, this]\n#align gauge_neg gauge_neg\n\n",
 "gauge_mono":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem gauge_mono (hs : absorbent (exprℝ) s) (h : s ⊆ t) : gauge t ≤ gauge s := fun x =>\n  cinfₛ_le_cinfₛ gauge_set_bdd_below hs.gauge_set_nonempty fun r hr => ⟨hr.1, smul_set_mono h hr.2⟩\n#align gauge_mono gauge_mono\n\n",
 "gauge_lt_one_subset_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem gauge_lt_one_subset_self (hs : convex (exprℝ) s) (h₀ : (0 : E) ∈ s) (absorbs : absorbent (exprℝ) s) :\n    { x | gauge s x < 1 } ⊆ s := by\n  rw [gauge_lt_eq absorbs]\n  refine' Set.unionᵢ₂_subset fun r hr _ => _\n  rintro ⟨y, hy, rfl⟩\n  exact hs.smul_mem_of_zero_mem h₀ hy (Ioo_subset_Icc_self hr)\n#align gauge_lt_one_subset_self gauge_lt_one_subset_self\n\n",
 "gauge_lt_one_of_mem_of_open":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem gauge_lt_one_of_mem_of_open (hs₁ : convex (exprℝ) s) (hs₀ : (0 : E) ∈ s) (hs₂ : is_open s) {x : E}\n    (hx : x ∈ s) : gauge s x < 1 := by rwa [← gauge_lt_one_eq_self_of_open hs₁ hs₀ hs₂] at hx\n#align gauge_lt_one_of_mem_of_open gauge_lt_one_of_mem_of_open\n\n",
 "gauge_lt_one_eq_self_of_open":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem gauge_lt_one_eq_self_of_open (hs₁ : convex (exprℝ) s) (hs₀ : (0 : E) ∈ s) (hs₂ : is_open s) :\n    { x | gauge s x < 1 } = s :=\n  by\n  refine' (gauge_lt_one_subset_self hs₁ ‹_› <| absorbent_nhds_zero <| hs₂.mem_nhds hs₀).antisymm _\n  convert interior_subset_gauge_lt_one s\n  exact hs₂.interior_eq.symm\n#align gauge_lt_one_eq_self_of_open gauge_lt_one_eq_self_of_open\n\n",
 "gauge_lt_of_mem_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem gauge_lt_of_mem_smul (x : E) (ε : exprℝ) (hε : 0 < ε) (hs₀ : (0 : E) ∈ s) (hs₁ : convex (exprℝ) s)\n    (hs₂ : is_open s) (hx : x ∈ «expr • » ε s) : gauge s x < ε :=\n  by\n  have : «expr • » ε⁻¹ x ∈ s := by rwa [← mem_smul_set_iff_inv_smul_mem₀ hε.ne']\n  have h_gauge_lt := gauge_lt_one_of_mem_of_open hs₁ hs₀ hs₂ this\n  rwa [gauge_smul_of_nonneg (inv_nonneg.2 hε.le), smul_eq_mul, inv_mul_lt_iff hε, mul_one] at h_gauge_lt\n  infer_instance\n#align gauge_lt_of_mem_smul gauge_lt_of_mem_smul\n\n",
 "gauge_lt_eq'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem gauge_lt_eq' (absorbs : absorbent (exprℝ) s) (a : exprℝ) :\n    { x | gauge s x < a } =\n      «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" («expr • » r s) :=\n  by\n  ext\n  simp_rw [mem_set_of_eq, mem_Union, exists_prop]\n  exact ⟨exists_lt_of_gauge_lt absorbs, fun ⟨r, hr₀, hr₁, hx⟩ => (gauge_le_of_mem hr₀.le hx).trans_lt hr₁⟩\n#align gauge_lt_eq' gauge_lt_eq'\n\n",
 "gauge_lt_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem gauge_lt_eq (absorbs : absorbent (exprℝ) s) (a : exprℝ) :\n    { x | gauge s x < a } =\n      «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" («expr • » r s) :=\n  by\n  ext\n  simp_rw [mem_set_of_eq, mem_Union, exists_prop, mem_Ioo, and_assoc']\n  exact ⟨exists_lt_of_gauge_lt absorbs, fun ⟨r, hr₀, hr₁, hx⟩ => (gauge_le_of_mem hr₀.le hx).trans_lt hr₁⟩\n#align gauge_lt_eq gauge_lt_eq\n\n",
 "gauge_le_one_of_mem":
 "theorem gauge_le_one_of_mem {x : E} (hx : x ∈ s) : gauge s x ≤ 1 :=\n  gauge_le_of_mem zero_le_one <| by rwa [one_smul]\n#align gauge_le_one_of_mem gauge_le_one_of_mem\n\n",
 "gauge_le_of_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem gauge_le_of_mem (ha : 0 ≤ a) (hx : x ∈ «expr • » a s) : gauge s x ≤ a :=\n  by\n  obtain rfl | ha' := ha.eq_or_lt\n  · rw [mem_singleton_iff.1 (zero_smul_set_subset _ hx), gauge_zero]\n  · exact cinfₛ_le gauge_set_bdd_below ⟨ha', hx⟩\n#align gauge_le_of_mem gauge_le_of_mem\n\n",
 "gauge_le_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem gauge_le_eq (hs₁ : convex (exprℝ) s) (hs₀ : (0 : E) ∈ s) (hs₂ : absorbent (exprℝ) s) (ha : 0 ≤ a) :\n    { x | gauge s x ≤ a } =\n      «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" («expr • » r s) :=\n  by\n  ext\n  simp_rw [Set.mem_interᵢ, Set.mem_setOf_eq]\n  refine' ⟨fun h r hr => _, fun h => le_of_forall_pos_lt_add fun ε hε => _⟩\n  · have hr' := ha.trans_lt hr\n    rw [mem_smul_set_iff_inv_smul_mem₀ hr'.ne']\n    obtain ⟨δ, δ_pos, hδr, hδ⟩ := exists_lt_of_gauge_lt hs₂ (h.trans_lt hr)\n    suffices «expr • » (r⁻¹ * δ) («expr • » δ⁻¹ x) ∈ s by rwa [smul_smul, mul_inv_cancel_right₀ δ_pos.ne'] at this\n    rw [mem_smul_set_iff_inv_smul_mem₀ δ_pos.ne'] at hδ\n    refine' hs₁.smul_mem_of_zero_mem hs₀ hδ ⟨by positivity, _⟩\n    rw [inv_mul_le_iff hr', mul_one]\n    exact hδr.le\n  · have hε' := (lt_add_iff_pos_right a).2 (half_pos hε)\n    exact (gauge_le_of_mem (ha.trans hε'.le) <| h _ hε').trans_lt (add_lt_add_left (half_lt_self hε) _)\n#align gauge_le_eq gauge_le_eq\n\n",
 "gauge_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem convex.gauge_le (hs : convex (exprℝ) s) (h₀ : (0 : E) ∈ s) (absorbs : absorbent (exprℝ) s) (a : exprℝ) :\n    convex (exprℝ) { x | gauge s x ≤ a } := by\n  by_cases ha : 0 ≤ a\n  · rw [gauge_le_eq hs h₀ absorbs ha]\n    exact convex_Inter fun i => convex_Inter fun hi => hs.smul _\n  · convert convex_empty\n    exact eq_empty_iff_forall_not_mem.2 fun x hx => ha <| (gauge_nonneg _).trans hx\n#align convex.gauge_le convex.gauge_le\n\n",
 "gauge_empty":
 "@[simp]\ntheorem gauge_empty : gauge (∅ : set E) = 0 := by\n  ext\n  simp only [gauge_def', real.Inf_empty, mem_empty_iff_false, pi.zero_apply, sep_false]\n#align gauge_empty gauge_empty\n\n",
 "gauge_def'":
 "/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:76:14: unsupported tactic `congrm #[[expr Inf (λ r, _)]] -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- An alternative definition of the gauge using scalar multiplication on the element rather than on\nthe set. -/\ntheorem gauge_def' : gauge s x = infₛ ({ r ∈ Set.Ioi 0 | «expr • » r⁻¹ x ∈ s }) :=\n  by\n  trace \"./././Mathport/Syntax/Translate/Tactic/Builtin.lean:76:14: unsupported tactic `congrm #[[expr Inf (λ r, _)]]\"\n  exact and_congr_right fun hr => mem_smul_set_iff_inv_smul_mem₀ hr.ne' _ _\n#align gauge_def' gauge_def'\n\n",
 "gauge_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-\nCopyright (c) 2021 Yaël Dillies, Bhavik Mehta. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yaël Dillies, Bhavik Mehta\n-/\ntheorem gauge_def : gauge s x = infₛ ({ r ∈ Set.Ioi 0 | x ∈ «expr • » r s }) :=\n  rfl\n#align gauge_def gauge_def\n\n",
 "gauge_ball":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem gauge_ball (hr : 0 < r) (x : E) : gauge (metric.ball (0 : E) r) x = «expr‖ ‖» x / r :=\n  by\n  rw [← smul_unit_ball_of_pos hr, gauge_smul_left, pi.smul_apply, gauge_unit_ball, smul_eq_mul, abs_of_nonneg hr.le,\n    div_eq_inv_mul]\n  simp_rw [mem_ball_zero_iff, norm_neg]\n  exact fun _ => id\n#align gauge_ball gauge_ball\n\n",
 "gauge_add_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem gauge_add_le (hs : convex (exprℝ) s) (absorbs : absorbent (exprℝ) s) (x y : E) :\n    gauge s (x + y) ≤ gauge s x + gauge s y :=\n  by\n  refine' le_of_forall_pos_lt_add fun ε hε => _\n  obtain ⟨a, ha, ha', hx⟩ := exists_lt_of_gauge_lt absorbs (lt_add_of_pos_right (gauge s x) (half_pos hε))\n  obtain ⟨b, hb, hb', hy⟩ := exists_lt_of_gauge_lt absorbs (lt_add_of_pos_right (gauge s y) (half_pos hε))\n  rw [mem_smul_set_iff_inv_smul_mem₀ ha.ne'] at hx\n  rw [mem_smul_set_iff_inv_smul_mem₀ hb.ne'] at hy\n  suffices gauge s (x + y) ≤ a + b by linarith\n  have hab : 0 < a + b := add_pos ha hb\n  apply gauge_le_of_mem hab.le\n  have := convex_iff_div.1 hs hx hy ha.le hb.le hab\n  rwa [smul_smul, smul_smul, ← mul_div_right_comm, ← mul_div_right_comm, mul_inv_cancel ha.ne', mul_inv_cancel hb.ne', ←\n    smul_add, one_div, ← mem_smul_set_iff_inv_smul_mem₀ hab.ne'] at this\n#align gauge_add_le gauge_add_le\n\n",
 "exists_lt_of_gauge_lt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem exists_lt_of_gauge_lt (absorbs : absorbent (exprℝ) s) (h : gauge s x < a) :\n    ∃ b, 0 < b ∧ b < a ∧ x ∈ «expr • » b s :=\n  by\n  obtain ⟨b, ⟨hb, hx⟩, hba⟩ := exists_lt_of_cinfₛ_lt absorbs.gauge_set_nonempty h\n  exact ⟨b, hb, hba, hx⟩\n#align exists_lt_of_gauge_lt exists_lt_of_gauge_lt\n\n"}