{"trans":
 "#print IsExtreme.trans /-\n@[trans]\nprotected theorem IsExtreme.trans (hAB : IsExtreme ğ•œ A B) (hBC : IsExtreme ğ•œ B C) : IsExtreme ğ•œ A C :=\n  by\n  refine' âŸ¨subset.trans hBC.1 hAB.1, fun xâ‚ hxâ‚A xâ‚‚ hxâ‚‚A x hxC hx => _âŸ©\n  obtain âŸ¨hxâ‚B, hxâ‚‚BâŸ© := hAB.2 hxâ‚A hxâ‚‚A (hBC.1 hxC) hx\n  exact hBC.2 hxâ‚B hxâ‚‚B hxC hx\n#align is_extreme.trans IsExtreme.trans\n-/\n\n",
 "rfl":
 "#print IsExtreme.rfl /-\nprotected theorem IsExtreme.rfl : IsExtreme ğ•œ A A :=\n  IsExtreme.refl ğ•œ A\n#align is_extreme.rfl IsExtreme.rfl\n-/\n\n",
 "refl":
 "#print IsExtreme.refl /-\n/-\nCopyright (c) 2021 YaÃ«l Dillies, Bhavik Mehta. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: YaÃ«l Dillies, Bhavik Mehta\n-/\n@[refl]\nprotected theorem IsExtreme.refl (A : Set E) : IsExtreme ğ•œ A A :=\n  âŸ¨Subset.rfl, fun xâ‚ hxâ‚A xâ‚‚ hxâ‚‚A x hxA hx => âŸ¨hxâ‚A, hxâ‚‚AâŸ©âŸ©\n#align is_extreme.refl IsExtreme.refl\n-/\n\n",
 "mono":
 "#print IsExtreme.mono /-\nprotected theorem IsExtreme.mono (hAC : IsExtreme ğ•œ A C) (hBA : B âŠ† A) (hCB : C âŠ† B) : IsExtreme ğ•œ B C :=\n  âŸ¨hCB, fun xâ‚ hxâ‚B xâ‚‚ hxâ‚‚B x hxC hx => hAC.2 (hBA hxâ‚B) (hBA hxâ‚‚B) hxC hxâŸ©\n#align is_extreme.mono IsExtreme.mono\n-/\n\n",
 "mem_extremePoints_iff_mem_diff_convexHull_diff":
 "#print Convex.mem_extremePoints_iff_mem_diff_convexHull_diff /-\ntheorem Convex.mem_extremePoints_iff_mem_diff_convexHull_diff (hA : Convex ğ•œ A) :\n    x âˆˆ A.extreme_points ğ•œ â†” x âˆˆ A \\ convexHull ğ•œ (A \\ {x}) := by\n  rw [hA.mem_extreme_points_iff_convex_diff, hA.convex_remove_iff_not_mem_convex_hull_remove, mem_diff]\n#align convex.mem_extreme_points_iff_mem_diff_convex_hull_diff Convex.mem_extremePoints_iff_mem_diff_convexHull_diff\n-/\n\n",
 "mem_extremePoints_iff_forall_segment":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (xâ‚ xâ‚‚ Â«expr âˆˆ Â» A) -/\n#print mem_extremePoints_iff_forall_segment /-\n/-- A useful restatement using `segment`: `x` is an extreme point iff the only (closed) segments\nthat contain it are those with `x` as one of their endpoints. -/\ntheorem mem_extremePoints_iff_forall_segment :\n    x âˆˆ A.extreme_points ğ•œ â†” x âˆˆ A âˆ§ âˆ€ (xâ‚) (_ : xâ‚ âˆˆ A) (xâ‚‚) (_ : xâ‚‚ âˆˆ A), x âˆˆ segment ğ•œ xâ‚ xâ‚‚ â†’ xâ‚ = x âˆ¨ xâ‚‚ = x :=\n  by\n  refine' and_congr_right fun hxA => forallâ‚„_congr fun xâ‚ hâ‚ xâ‚‚ hâ‚‚ => _\n  constructor\n  Â· rw [â† insert_endpoints_openSegment]\n    rintro H (rfl | rfl | hx)\n    exacts[or.inl rfl, or.inr rfl, or.inl <| (H hx).1]\n  Â· intro H hx\n    rcases H (openSegment_subset_segment _ _ _ hx) with (rfl | rfl)\n    exacts[âŸ¨rfl, (left_mem_openSegment_iff.1 hx).symmâŸ©, âŸ¨right_mem_openSegment_iff.1 hx, rflâŸ©]\n#align mem_extreme_points_iff_forall_segment mem_extremePoints_iff_forall_segment\n-/\n\n",
 "mem_extremePoints_iff_extreme_singleton":
 "#print mem_extremePoints_iff_extreme_singleton /-\n/-- x is an extreme point to A iff {x} is an extreme set of A. -/\ntheorem mem_extremePoints_iff_extreme_singleton : x âˆˆ A.extreme_points ğ•œ â†” IsExtreme ğ•œ A {x} :=\n  by\n  refine' âŸ¨_, fun hx => âŸ¨singleton_subset_iff.1 hx.1, fun xâ‚ hxâ‚ xâ‚‚ hxâ‚‚ => hx.2 hxâ‚ hxâ‚‚ rflâŸ©âŸ©\n  rintro âŸ¨hxA, hAxâŸ©\n  use singleton_subset_iff.2 hxA\n  rintro xâ‚ hxâ‚A xâ‚‚ hxâ‚‚A y (rfl : y = x)\n  exact hAx hxâ‚A hxâ‚‚A\n#align mem_extreme_points_iff_extreme_singleton mem_extremePoints_iff_extreme_singleton\n-/\n\n",
 "mem_extremePoints_iff_convex_diff":
 "#print Convex.mem_extremePoints_iff_convex_diff /-\ntheorem Convex.mem_extremePoints_iff_convex_diff (hA : Convex ğ•œ A) :\n    x âˆˆ A.extreme_points ğ•œ â†” x âˆˆ A âˆ§ Convex ğ•œ (A \\ {x}) :=\n  by\n  use fun hx => âŸ¨hx.1, (mem_extremePoints_iff_extreme_singleton.1 hx).convex_diff hAâŸ©\n  rintro âŸ¨hxA, hAxâŸ©\n  refine' mem_extremePoints_iff_forall_segment.2 âŸ¨hxA, fun xâ‚ hxâ‚ xâ‚‚ hxâ‚‚ hx => _âŸ©\n  rw [convex_iff_segment_subset] at hAx\n  by_contra' h\n  exact (hAx âŸ¨hxâ‚, fun hxâ‚ => h.1 (mem_singleton_iff.2 hxâ‚)âŸ© âŸ¨hxâ‚‚, fun hxâ‚‚ => h.2 (mem_singleton_iff.2 hxâ‚‚)âŸ© hx).2 rfl\n#align convex.mem_extreme_points_iff_convex_diff Convex.mem_extremePoints_iff_convex_diff\n-/\n\n",
 "mem_extremePoints":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (xâ‚ xâ‚‚ Â«expr âˆˆ Â» A) -/\n#print mem_extremePoints /-\ntheorem mem_extremePoints :\n    x âˆˆ A.extreme_points ğ•œ â†” x âˆˆ A âˆ§ âˆ€ (xâ‚) (_ : xâ‚ âˆˆ A) (xâ‚‚) (_ : xâ‚‚ âˆˆ A), x âˆˆ openSegment ğ•œ xâ‚ xâ‚‚ â†’ xâ‚ = x âˆ§ xâ‚‚ = x :=\n  iff.rfl\n#align mem_extreme_points mem_extremePoints\n-/\n\n",
 "isExtreme_interâ‚›":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹‚â‚€ Â» -/\n#print isExtreme_interâ‚› /-\ntheorem isExtreme_interâ‚› {F : Set (Set E)} (hF : F.nonempty) (hAF : âˆ€ B âˆˆ F, IsExtreme ğ•œ A B) :\n    IsExtreme ğ•œ A (Â«exprâ‹‚â‚€ Â» F) := by\n  obtain âŸ¨B, hBâŸ© := hF\n  refine' âŸ¨(sInter_subset_of_mem hB).trans (hAF B hB).1, fun xâ‚ hxâ‚A xâ‚‚ hxâ‚‚A x hxF hx => _âŸ©\n  simp_rw [mem_sInter] at hxFâŠ¢\n  have h := fun B hB => (hAF B hB).2 hxâ‚A hxâ‚‚A (hxF B hB) hx\n  exact âŸ¨fun B hB => (h B hB).1, fun B hB => (h B hB).2âŸ©\n#align is_extreme_sInter isExtreme_interâ‚›\n-/\n\n",
 "isExtreme_interáµ¢":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹‚ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹‚ , Â» -/\n#print isExtreme_interáµ¢ /-\ntheorem isExtreme_interáµ¢ {Î¹ : Sort _} [Nonempty Î¹] {F : Î¹ â†’ Set E} (hAF : âˆ€ i : Î¹, IsExtreme ğ•œ A (F i)) :\n    IsExtreme ğ•œ A\n      (Â«exprâ‹‚ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹‚ , Â»\" (F i)) :=\n  by\n  obtain i := Classical.arbitrary Î¹\n  refine' âŸ¨Inter_subset_of_subset i (hAF i).1, fun xâ‚ hxâ‚A xâ‚‚ hxâ‚‚A x hxF hx => _âŸ©\n  simp_rw [mem_Inter] at hxFâŠ¢\n  have h := fun i => (hAF i).2 hxâ‚A hxâ‚‚A (hxF i) hx\n  exact âŸ¨fun i => (h i).1, fun i => (h i).2âŸ©\n#align is_extreme_Inter isExtreme_interáµ¢\n-/\n\n",
 "isExtreme_binteráµ¢":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹‚ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹‚ , Â» -/\n#print isExtreme_binteráµ¢ /-\ntheorem isExtreme_binteráµ¢ {F : Set (Set E)} (hF : F.nonempty) (hA : âˆ€ B âˆˆ F, IsExtreme ğ•œ A B) :\n    IsExtreme ğ•œ A (Â«exprâ‹‚ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹‚ , Â»\" B) :=\n  by\n  haveI := hF.to_subtype\n  simpa only [Inter_subtype] using isExtreme_interáµ¢ fun i : F => hA _ i.2\n#align is_extreme_bInter isExtreme_binteráµ¢\n-/\n\n",
 "inter_extremePoints_subset_extremePoints_of_subset":
 "#print inter_extremePoints_subset_extremePoints_of_subset /-\ntheorem inter_extremePoints_subset_extremePoints_of_subset (hBA : B âŠ† A) :\n    B âˆ© A.extreme_points ğ•œ âŠ† B.extreme_points ğ•œ := fun x âŸ¨hxB, hxAâŸ© =>\n  âŸ¨hxB, fun xâ‚ hxâ‚ xâ‚‚ hxâ‚‚ hx => hxA.2 (hBA hxâ‚) (hBA hxâ‚‚) hxâŸ©\n#align inter_extreme_points_subset_extreme_points_of_subset inter_extremePoints_subset_extremePoints_of_subset\n-/\n\n",
 "inter":
 "#print IsExtreme.inter /-\ntheorem IsExtreme.inter (hAB : IsExtreme ğ•œ A B) (hAC : IsExtreme ğ•œ A C) : IsExtreme ğ•œ A (B âˆ© C) :=\n  by\n  use subset.trans (inter_subset_left _ _) hAB.1\n  rintro xâ‚ hxâ‚A xâ‚‚ hxâ‚‚A x âŸ¨hxB, hxCâŸ© hx\n  obtain âŸ¨hxâ‚B, hxâ‚‚BâŸ© := hAB.2 hxâ‚A hxâ‚‚A hxB hx\n  obtain âŸ¨hxâ‚C, hxâ‚‚CâŸ© := hAC.2 hxâ‚A hxâ‚‚A hxC hx\n  exact âŸ¨âŸ¨hxâ‚B, hxâ‚CâŸ©, hxâ‚‚B, hxâ‚‚CâŸ©\n#align is_extreme.inter IsExtreme.inter\n-/\n\n",
 "extremePoints_subset_extremePoints":
 "#print IsExtreme.extremePoints_subset_extremePoints /-\ntheorem IsExtreme.extremePoints_subset_extremePoints (hAB : IsExtreme ğ•œ A B) :\n    B.extreme_points ğ•œ âŠ† A.extreme_points ğ•œ := fun x hx =>\n  mem_extremePoints_iff_extreme_singleton.2 (hAB.trans (mem_extremePoints_iff_extreme_singleton.1 hx))\n#align is_extreme.extreme_points_subset_extreme_points IsExtreme.extremePoints_subset_extremePoints\n-/\n\n",
 "extremePoints_subset":
 "#print extremePoints_subset /-\ntheorem extremePoints_subset : A.extreme_points ğ•œ âŠ† A := fun x hx => hx.1\n#align extreme_points_subset extremePoints_subset\n-/\n\n",
 "extremePoints_singleton":
 "#print extremePoints_singleton /-\n@[simp]\ntheorem extremePoints_singleton : ({x} : Set E).extreme_points ğ•œ = {x} :=\n  extremePoints_subset.antisymm <| singleton_subset_iff.2 âŸ¨mem_singleton x, fun xâ‚ hxâ‚ xâ‚‚ hxâ‚‚ _ => âŸ¨hxâ‚, hxâ‚‚âŸ©âŸ©\n#align extreme_points_singleton extremePoints_singleton\n-/\n\n",
 "extremePoints_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n#print extremePoints_prod /-\n@[simp]\ntheorem extremePoints_prod (s : Set E) (t : Set F) :\n    (finset.product s t).extreme_points ğ•œ = finset.product (s.extreme_points ğ•œ) (t.extreme_points ğ•œ) :=\n  by\n  ext\n  refine' (and_congr_right fun hx => âŸ¨fun h => _, fun h => _âŸ©).trans (and_and_and_comm _ _ _ _)\n  constructor\n  Â· rintro xâ‚ hxâ‚ xâ‚‚ hxâ‚‚ hx_fst\n    refine' (h (mk_mem_prod hxâ‚ hx.2) (mk_mem_prod hxâ‚‚ hx.2) _).imp (congr_arg Prod.fst) (congr_arg Prod.fst)\n    rw [â† Prod.image_mk_openSegment_left]\n    exact âŸ¨_, hx_fst, prod.mk.etaâŸ©\n  Â· rintro xâ‚ hxâ‚ xâ‚‚ hxâ‚‚ hx_snd\n    refine' (h (mk_mem_prod hx.1 hxâ‚) (mk_mem_prod hx.1 hxâ‚‚) _).imp (congr_arg Prod.snd) (congr_arg Prod.snd)\n    rw [â† Prod.image_mk_openSegment_right]\n    exact âŸ¨_, hx_snd, prod.mk.etaâŸ©\n  Â· rintro xâ‚ hxâ‚ xâ‚‚ hxâ‚‚ âŸ¨a, b, ha, hb, hab, hx'âŸ©\n    simp_rw [Prod.ext_iff]\n    exact\n      (and_and_and_comm _ _ _ _).1\n        âŸ¨h.1 hxâ‚.1 hxâ‚‚.1 âŸ¨a, b, ha, hb, hab, congr_arg Prod.fst hx'âŸ©,\n          h.2 hxâ‚.2 hxâ‚‚.2 âŸ¨a, b, ha, hb, hab, congr_arg Prod.snd hx'âŸ©âŸ©\n#align extreme_points_prod extremePoints_prod\n-/\n\n",
 "extremePoints_pi":
 "#print extremePoints_pi /-\n@[simp]\ntheorem extremePoints_pi (s : âˆ€ i, Set (Ï€ i)) :\n    (univ.pi s).extreme_points ğ•œ = univ.pi fun i => (s i).extreme_points ğ•œ :=\n  by\n  ext\n  simp only [mem_extremePoints, mem_pi, mem_univ, true_imp_iff, @forall_and Î¹]\n  refine' and_congr_right fun hx => âŸ¨fun h i => _, fun h => _âŸ©\n  Â· rintro xâ‚ hxâ‚ xâ‚‚ hxâ‚‚ hi\n    refine'\n      (h (update x i xâ‚) _ (update x i xâ‚‚) _ _).imp (fun hâ‚ => by rw [â† hâ‚, update_same]) fun hâ‚‚ => by\n        rw [â† hâ‚‚, update_same]\n    iterate 2 \n      rintro j\n      obtain rfl | hji := eq_or_ne j i\n      Â· rwa [update_same]\n      Â· rw [update_noteq hji]\n        exact hx _\n    rw [â† Pi.image_update_openSegment]\n    exact âŸ¨_, hi, update_eq_self _ _âŸ©\n  Â· rintro xâ‚ hxâ‚ xâ‚‚ hxâ‚‚ âŸ¨a, b, ha, hb, hab, hx'âŸ©\n    simp_rw [funext_iff, â† forall_and]\n    exact fun i => h _ _ (hxâ‚ _) _ (hxâ‚‚ _) âŸ¨a, b, ha, hb, hab, congr_fun hx' _âŸ©\n#align extreme_points_pi extremePoints_pi\n-/\n\n",
 "extremePoints_eq":
 "#print IsExtreme.extremePoints_eq /-\ntheorem IsExtreme.extremePoints_eq (hAB : IsExtreme ğ•œ A B) : B.extreme_points ğ•œ = B âˆ© A.extreme_points ğ•œ :=\n  Subset.antisymm (fun x hx => âŸ¨hx.1, hAB.extreme_points_subset_extreme_points hxâŸ©)\n    (inter_extremePoints_subset_extremePoints_of_subset hAB.1)\n#align is_extreme.extreme_points_eq IsExtreme.extremePoints_eq\n-/\n\n",
 "extremePoints_empty":
 "#print extremePoints_empty /-\n@[simp]\ntheorem extremePoints_empty : (âˆ… : Set E).extreme_points ğ•œ = âˆ… :=\n  subset_empty_iff.1 extremePoints_subset\n#align extreme_points_empty extremePoints_empty\n-/\n\n",
 "extremePoints_convexHull_subset":
 "#print extremePoints_convexHull_subset /-\ntheorem extremePoints_convexHull_subset : (convexHull ğ•œ A).extreme_points ğ•œ âŠ† A :=\n  by\n  rintro x hx\n  rw [(convex_convexHull ğ•œ _).mem_extreme_points_iff_convex_diff] at hx\n  by_contra\n  exact (convexHull_min (subset_diff.2 âŸ¨subset_convexHull ğ•œ _, disjoint_singleton_right.2 hâŸ©) hx.2 hx.1).2 rfl\n  infer_instance\n#align extreme_points_convex_hull_subset extremePoints_convexHull_subset\n-/\n\n",
 "convex_diff":
 "#print IsExtreme.convex_diff /-\ntheorem IsExtreme.convex_diff (hA : Convex ğ•œ A) (hAB : IsExtreme ğ•œ A B) : Convex ğ•œ (A \\ B) :=\n  convex_iff_openSegment_subset.2 fun xâ‚ âŸ¨hxâ‚A, hxâ‚BâŸ© xâ‚‚ âŸ¨hxâ‚‚A, hxâ‚‚BâŸ© x hx =>\n    âŸ¨hA.open_segment_subset hxâ‚A hxâ‚‚A hx, fun hxB => hxâ‚B (hAB.2 hxâ‚A hxâ‚‚A hxB hx).1âŸ©\n#align is_extreme.convex_diff IsExtreme.convex_diff\n-/\n\n",
 "antisymm":
 "#print IsExtreme.antisymm /-\nprotected theorem IsExtreme.antisymm : anti_symmetric (IsExtreme ğ•œ : Set E â†’ Set E â†’ Prop) := fun A B hAB hBA =>\n  Subset.antisymm hBA.1 hAB.1\n#align is_extreme.antisymm IsExtreme.antisymm\n-/\n\n"}