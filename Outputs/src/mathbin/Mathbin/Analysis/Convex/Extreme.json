{"trans":
 "#print IsExtreme.trans /-\n@[trans]\nprotected theorem IsExtreme.trans (hAB : IsExtreme ùïú A B) (hBC : IsExtreme ùïú B C) : IsExtreme ùïú A C :=\n  by\n  refine' ‚ü®subset.trans hBC.1 hAB.1, fun x‚ÇÅ hx‚ÇÅA x‚ÇÇ hx‚ÇÇA x hxC hx => _‚ü©\n  obtain ‚ü®hx‚ÇÅB, hx‚ÇÇB‚ü© := hAB.2 hx‚ÇÅA hx‚ÇÇA (hBC.1 hxC) hx\n  exact hBC.2 hx‚ÇÅB hx‚ÇÇB hxC hx\n#align is_extreme.trans IsExtreme.trans\n-/\n\n",
 "rfl":
 "#print IsExtreme.rfl /-\nprotected theorem IsExtreme.rfl : IsExtreme ùïú A A :=\n  IsExtreme.refl ùïú A\n#align is_extreme.rfl IsExtreme.rfl\n-/\n\n",
 "refl":
 "#print IsExtreme.refl /-\n/-\nCopyright (c) 2021 Ya√´l Dillies, Bhavik Mehta. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Ya√´l Dillies, Bhavik Mehta\n-/\n@[refl]\nprotected theorem IsExtreme.refl (A : Set E) : IsExtreme ùïú A A :=\n  ‚ü®Subset.rfl, fun x‚ÇÅ hx‚ÇÅA x‚ÇÇ hx‚ÇÇA x hxA hx => ‚ü®hx‚ÇÅA, hx‚ÇÇA‚ü©‚ü©\n#align is_extreme.refl IsExtreme.refl\n-/\n\n",
 "mono":
 "#print IsExtreme.mono /-\nprotected theorem IsExtreme.mono (hAC : IsExtreme ùïú A C) (hBA : B ‚äÜ A) (hCB : C ‚äÜ B) : IsExtreme ùïú B C :=\n  ‚ü®hCB, fun x‚ÇÅ hx‚ÇÅB x‚ÇÇ hx‚ÇÇB x hxC hx => hAC.2 (hBA hx‚ÇÅB) (hBA hx‚ÇÇB) hxC hx‚ü©\n#align is_extreme.mono IsExtreme.mono\n-/\n\n",
 "mem_extremePoints_iff_mem_diff_convexHull_diff":
 "#print Convex.mem_extremePoints_iff_mem_diff_convexHull_diff /-\ntheorem Convex.mem_extremePoints_iff_mem_diff_convexHull_diff (hA : Convex ùïú A) :\n    x ‚àà A.extreme_points ùïú ‚Üî x ‚àà A \\ convexHull ùïú (A \\ {x}) := by\n  rw [hA.mem_extreme_points_iff_convex_diff, hA.convex_remove_iff_not_mem_convex_hull_remove, mem_diff]\n#align convex.mem_extreme_points_iff_mem_diff_convex_hull_diff Convex.mem_extremePoints_iff_mem_diff_convexHull_diff\n-/\n\n",
 "mem_extremePoints_iff_forall_segment":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (x‚ÇÅ x‚ÇÇ ¬´expr ‚àà ¬ª A) -/\n#print mem_extremePoints_iff_forall_segment /-\n/-- A useful restatement using `segment`: `x` is an extreme point iff the only (closed) segments\nthat contain it are those with `x` as one of their endpoints. -/\ntheorem mem_extremePoints_iff_forall_segment :\n    x ‚àà A.extreme_points ùïú ‚Üî x ‚àà A ‚àß ‚àÄ (x‚ÇÅ) (_ : x‚ÇÅ ‚àà A) (x‚ÇÇ) (_ : x‚ÇÇ ‚àà A), x ‚àà segment ùïú x‚ÇÅ x‚ÇÇ ‚Üí x‚ÇÅ = x ‚à® x‚ÇÇ = x :=\n  by\n  refine' and_congr_right fun hxA => forall‚ÇÑ_congr fun x‚ÇÅ h‚ÇÅ x‚ÇÇ h‚ÇÇ => _\n  constructor\n  ¬∑ rw [‚Üê insert_endpoints_openSegment]\n    rintro H (rfl | rfl | hx)\n    exacts[or.inl rfl, or.inr rfl, or.inl <| (H hx).1]\n  ¬∑ intro H hx\n    rcases H (openSegment_subset_segment _ _ _ hx) with (rfl | rfl)\n    exacts[‚ü®rfl, (left_mem_openSegment_iff.1 hx).symm‚ü©, ‚ü®right_mem_openSegment_iff.1 hx, rfl‚ü©]\n#align mem_extreme_points_iff_forall_segment mem_extremePoints_iff_forall_segment\n-/\n\n",
 "mem_extremePoints_iff_extreme_singleton":
 "#print mem_extremePoints_iff_extreme_singleton /-\n/-- x is an extreme point to A iff {x} is an extreme set of A. -/\ntheorem mem_extremePoints_iff_extreme_singleton : x ‚àà A.extreme_points ùïú ‚Üî IsExtreme ùïú A {x} :=\n  by\n  refine' ‚ü®_, fun hx => ‚ü®singleton_subset_iff.1 hx.1, fun x‚ÇÅ hx‚ÇÅ x‚ÇÇ hx‚ÇÇ => hx.2 hx‚ÇÅ hx‚ÇÇ rfl‚ü©‚ü©\n  rintro ‚ü®hxA, hAx‚ü©\n  use singleton_subset_iff.2 hxA\n  rintro x‚ÇÅ hx‚ÇÅA x‚ÇÇ hx‚ÇÇA y (rfl : y = x)\n  exact hAx hx‚ÇÅA hx‚ÇÇA\n#align mem_extreme_points_iff_extreme_singleton mem_extremePoints_iff_extreme_singleton\n-/\n\n",
 "mem_extremePoints_iff_convex_diff":
 "#print Convex.mem_extremePoints_iff_convex_diff /-\ntheorem Convex.mem_extremePoints_iff_convex_diff (hA : Convex ùïú A) :\n    x ‚àà A.extreme_points ùïú ‚Üî x ‚àà A ‚àß Convex ùïú (A \\ {x}) :=\n  by\n  use fun hx => ‚ü®hx.1, (mem_extremePoints_iff_extreme_singleton.1 hx).convex_diff hA‚ü©\n  rintro ‚ü®hxA, hAx‚ü©\n  refine' mem_extremePoints_iff_forall_segment.2 ‚ü®hxA, fun x‚ÇÅ hx‚ÇÅ x‚ÇÇ hx‚ÇÇ hx => _‚ü©\n  rw [convex_iff_segment_subset] at hAx\n  by_contra' h\n  exact (hAx ‚ü®hx‚ÇÅ, fun hx‚ÇÅ => h.1 (mem_singleton_iff.2 hx‚ÇÅ)‚ü© ‚ü®hx‚ÇÇ, fun hx‚ÇÇ => h.2 (mem_singleton_iff.2 hx‚ÇÇ)‚ü© hx).2 rfl\n#align convex.mem_extreme_points_iff_convex_diff Convex.mem_extremePoints_iff_convex_diff\n-/\n\n",
 "mem_extremePoints":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (x‚ÇÅ x‚ÇÇ ¬´expr ‚àà ¬ª A) -/\n#print mem_extremePoints /-\ntheorem mem_extremePoints :\n    x ‚àà A.extreme_points ùïú ‚Üî x ‚àà A ‚àß ‚àÄ (x‚ÇÅ) (_ : x‚ÇÅ ‚àà A) (x‚ÇÇ) (_ : x‚ÇÇ ‚àà A), x ‚àà openSegment ùïú x‚ÇÅ x‚ÇÇ ‚Üí x‚ÇÅ = x ‚àß x‚ÇÇ = x :=\n  iff.rfl\n#align mem_extreme_points mem_extremePoints\n-/\n\n",
 "isExtreme_inter‚Çõ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚ãÇ‚ÇÄ ¬ª -/\n#print isExtreme_inter‚Çõ /-\ntheorem isExtreme_inter‚Çõ {F : Set (Set E)} (hF : F.nonempty) (hAF : ‚àÄ B ‚àà F, IsExtreme ùïú A B) :\n    IsExtreme ùïú A (¬´expr‚ãÇ‚ÇÄ ¬ª F) := by\n  obtain ‚ü®B, hB‚ü© := hF\n  refine' ‚ü®(sInter_subset_of_mem hB).trans (hAF B hB).1, fun x‚ÇÅ hx‚ÇÅA x‚ÇÇ hx‚ÇÇA x hxF hx => _‚ü©\n  simp_rw [mem_sInter] at hxF‚ä¢\n  have h := fun B hB => (hAF B hB).2 hx‚ÇÅA hx‚ÇÇA (hxF B hB) hx\n  exact ‚ü®fun B hB => (h B hB).1, fun B hB => (h B hB).2‚ü©\n#align is_extreme_sInter isExtreme_inter‚Çõ\n-/\n\n",
 "isExtreme_inter·µ¢":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚ãÇ , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚ãÇ , ¬ª -/\n#print isExtreme_inter·µ¢ /-\ntheorem isExtreme_inter·µ¢ {Œπ : Sort _} [Nonempty Œπ] {F : Œπ ‚Üí Set E} (hAF : ‚àÄ i : Œπ, IsExtreme ùïú A (F i)) :\n    IsExtreme ùïú A\n      (¬´expr‚ãÇ , ¬ª \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚ãÇ , ¬ª\" (F i)) :=\n  by\n  obtain i := Classical.arbitrary Œπ\n  refine' ‚ü®Inter_subset_of_subset i (hAF i).1, fun x‚ÇÅ hx‚ÇÅA x‚ÇÇ hx‚ÇÇA x hxF hx => _‚ü©\n  simp_rw [mem_Inter] at hxF‚ä¢\n  have h := fun i => (hAF i).2 hx‚ÇÅA hx‚ÇÇA (hxF i) hx\n  exact ‚ü®fun i => (h i).1, fun i => (h i).2‚ü©\n#align is_extreme_Inter isExtreme_inter·µ¢\n-/\n\n",
 "isExtreme_binter·µ¢":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚ãÇ , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚ãÇ , ¬ª -/\n#print isExtreme_binter·µ¢ /-\ntheorem isExtreme_binter·µ¢ {F : Set (Set E)} (hF : F.nonempty) (hA : ‚àÄ B ‚àà F, IsExtreme ùïú A B) :\n    IsExtreme ùïú A (¬´expr‚ãÇ , ¬ª \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚ãÇ , ¬ª\" B) :=\n  by\n  haveI := hF.to_subtype\n  simpa only [Inter_subtype] using isExtreme_inter·µ¢ fun i : F => hA _ i.2\n#align is_extreme_bInter isExtreme_binter·µ¢\n-/\n\n",
 "inter_extremePoints_subset_extremePoints_of_subset":
 "#print inter_extremePoints_subset_extremePoints_of_subset /-\ntheorem inter_extremePoints_subset_extremePoints_of_subset (hBA : B ‚äÜ A) :\n    B ‚à© A.extreme_points ùïú ‚äÜ B.extreme_points ùïú := fun x ‚ü®hxB, hxA‚ü© =>\n  ‚ü®hxB, fun x‚ÇÅ hx‚ÇÅ x‚ÇÇ hx‚ÇÇ hx => hxA.2 (hBA hx‚ÇÅ) (hBA hx‚ÇÇ) hx‚ü©\n#align inter_extreme_points_subset_extreme_points_of_subset inter_extremePoints_subset_extremePoints_of_subset\n-/\n\n",
 "inter":
 "#print IsExtreme.inter /-\ntheorem IsExtreme.inter (hAB : IsExtreme ùïú A B) (hAC : IsExtreme ùïú A C) : IsExtreme ùïú A (B ‚à© C) :=\n  by\n  use subset.trans (inter_subset_left _ _) hAB.1\n  rintro x‚ÇÅ hx‚ÇÅA x‚ÇÇ hx‚ÇÇA x ‚ü®hxB, hxC‚ü© hx\n  obtain ‚ü®hx‚ÇÅB, hx‚ÇÇB‚ü© := hAB.2 hx‚ÇÅA hx‚ÇÇA hxB hx\n  obtain ‚ü®hx‚ÇÅC, hx‚ÇÇC‚ü© := hAC.2 hx‚ÇÅA hx‚ÇÇA hxC hx\n  exact ‚ü®‚ü®hx‚ÇÅB, hx‚ÇÅC‚ü©, hx‚ÇÇB, hx‚ÇÇC‚ü©\n#align is_extreme.inter IsExtreme.inter\n-/\n\n",
 "extremePoints_subset_extremePoints":
 "#print IsExtreme.extremePoints_subset_extremePoints /-\ntheorem IsExtreme.extremePoints_subset_extremePoints (hAB : IsExtreme ùïú A B) :\n    B.extreme_points ùïú ‚äÜ A.extreme_points ùïú := fun x hx =>\n  mem_extremePoints_iff_extreme_singleton.2 (hAB.trans (mem_extremePoints_iff_extreme_singleton.1 hx))\n#align is_extreme.extreme_points_subset_extreme_points IsExtreme.extremePoints_subset_extremePoints\n-/\n\n",
 "extremePoints_subset":
 "#print extremePoints_subset /-\ntheorem extremePoints_subset : A.extreme_points ùïú ‚äÜ A := fun x hx => hx.1\n#align extreme_points_subset extremePoints_subset\n-/\n\n",
 "extremePoints_singleton":
 "#print extremePoints_singleton /-\n@[simp]\ntheorem extremePoints_singleton : ({x} : Set E).extreme_points ùïú = {x} :=\n  extremePoints_subset.antisymm <| singleton_subset_iff.2 ‚ü®mem_singleton x, fun x‚ÇÅ hx‚ÇÅ x‚ÇÇ hx‚ÇÇ _ => ‚ü®hx‚ÇÅ, hx‚ÇÇ‚ü©‚ü©\n#align extreme_points_singleton extremePoints_singleton\n-/\n\n",
 "extremePoints_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n#print extremePoints_prod /-\n@[simp]\ntheorem extremePoints_prod (s : Set E) (t : Set F) :\n    (finset.product s t).extreme_points ùïú = finset.product (s.extreme_points ùïú) (t.extreme_points ùïú) :=\n  by\n  ext\n  refine' (and_congr_right fun hx => ‚ü®fun h => _, fun h => _‚ü©).trans (and_and_and_comm _ _ _ _)\n  constructor\n  ¬∑ rintro x‚ÇÅ hx‚ÇÅ x‚ÇÇ hx‚ÇÇ hx_fst\n    refine' (h (mk_mem_prod hx‚ÇÅ hx.2) (mk_mem_prod hx‚ÇÇ hx.2) _).imp (congr_arg Prod.fst) (congr_arg Prod.fst)\n    rw [‚Üê Prod.image_mk_openSegment_left]\n    exact ‚ü®_, hx_fst, prod.mk.eta‚ü©\n  ¬∑ rintro x‚ÇÅ hx‚ÇÅ x‚ÇÇ hx‚ÇÇ hx_snd\n    refine' (h (mk_mem_prod hx.1 hx‚ÇÅ) (mk_mem_prod hx.1 hx‚ÇÇ) _).imp (congr_arg Prod.snd) (congr_arg Prod.snd)\n    rw [‚Üê Prod.image_mk_openSegment_right]\n    exact ‚ü®_, hx_snd, prod.mk.eta‚ü©\n  ¬∑ rintro x‚ÇÅ hx‚ÇÅ x‚ÇÇ hx‚ÇÇ ‚ü®a, b, ha, hb, hab, hx'‚ü©\n    simp_rw [Prod.ext_iff]\n    exact\n      (and_and_and_comm _ _ _ _).1\n        ‚ü®h.1 hx‚ÇÅ.1 hx‚ÇÇ.1 ‚ü®a, b, ha, hb, hab, congr_arg Prod.fst hx'‚ü©,\n          h.2 hx‚ÇÅ.2 hx‚ÇÇ.2 ‚ü®a, b, ha, hb, hab, congr_arg Prod.snd hx'‚ü©‚ü©\n#align extreme_points_prod extremePoints_prod\n-/\n\n",
 "extremePoints_pi":
 "#print extremePoints_pi /-\n@[simp]\ntheorem extremePoints_pi (s : ‚àÄ i, Set (œÄ i)) :\n    (univ.pi s).extreme_points ùïú = univ.pi fun i => (s i).extreme_points ùïú :=\n  by\n  ext\n  simp only [mem_extremePoints, mem_pi, mem_univ, true_imp_iff, @forall_and Œπ]\n  refine' and_congr_right fun hx => ‚ü®fun h i => _, fun h => _‚ü©\n  ¬∑ rintro x‚ÇÅ hx‚ÇÅ x‚ÇÇ hx‚ÇÇ hi\n    refine'\n      (h (update x i x‚ÇÅ) _ (update x i x‚ÇÇ) _ _).imp (fun h‚ÇÅ => by rw [‚Üê h‚ÇÅ, update_same]) fun h‚ÇÇ => by\n        rw [‚Üê h‚ÇÇ, update_same]\n    iterate 2 \n      rintro j\n      obtain rfl | hji := eq_or_ne j i\n      ¬∑ rwa [update_same]\n      ¬∑ rw [update_noteq hji]\n        exact hx _\n    rw [‚Üê Pi.image_update_openSegment]\n    exact ‚ü®_, hi, update_eq_self _ _‚ü©\n  ¬∑ rintro x‚ÇÅ hx‚ÇÅ x‚ÇÇ hx‚ÇÇ ‚ü®a, b, ha, hb, hab, hx'‚ü©\n    simp_rw [funext_iff, ‚Üê forall_and]\n    exact fun i => h _ _ (hx‚ÇÅ _) _ (hx‚ÇÇ _) ‚ü®a, b, ha, hb, hab, congr_fun hx' _‚ü©\n#align extreme_points_pi extremePoints_pi\n-/\n\n",
 "extremePoints_eq":
 "#print IsExtreme.extremePoints_eq /-\ntheorem IsExtreme.extremePoints_eq (hAB : IsExtreme ùïú A B) : B.extreme_points ùïú = B ‚à© A.extreme_points ùïú :=\n  Subset.antisymm (fun x hx => ‚ü®hx.1, hAB.extreme_points_subset_extreme_points hx‚ü©)\n    (inter_extremePoints_subset_extremePoints_of_subset hAB.1)\n#align is_extreme.extreme_points_eq IsExtreme.extremePoints_eq\n-/\n\n",
 "extremePoints_empty":
 "#print extremePoints_empty /-\n@[simp]\ntheorem extremePoints_empty : (‚àÖ : Set E).extreme_points ùïú = ‚àÖ :=\n  subset_empty_iff.1 extremePoints_subset\n#align extreme_points_empty extremePoints_empty\n-/\n\n",
 "extremePoints_convexHull_subset":
 "#print extremePoints_convexHull_subset /-\ntheorem extremePoints_convexHull_subset : (convexHull ùïú A).extreme_points ùïú ‚äÜ A :=\n  by\n  rintro x hx\n  rw [(convex_convexHull ùïú _).mem_extreme_points_iff_convex_diff] at hx\n  by_contra\n  exact (convexHull_min (subset_diff.2 ‚ü®subset_convexHull ùïú _, disjoint_singleton_right.2 h‚ü©) hx.2 hx.1).2 rfl\n  infer_instance\n#align extreme_points_convex_hull_subset extremePoints_convexHull_subset\n-/\n\n",
 "convex_diff":
 "#print IsExtreme.convex_diff /-\ntheorem IsExtreme.convex_diff (hA : Convex ùïú A) (hAB : IsExtreme ùïú A B) : Convex ùïú (A \\ B) :=\n  convex_iff_openSegment_subset.2 fun x‚ÇÅ ‚ü®hx‚ÇÅA, hx‚ÇÅB‚ü© x‚ÇÇ ‚ü®hx‚ÇÇA, hx‚ÇÇB‚ü© x hx =>\n    ‚ü®hA.open_segment_subset hx‚ÇÅA hx‚ÇÇA hx, fun hxB => hx‚ÇÅB (hAB.2 hx‚ÇÅA hx‚ÇÇA hxB hx).1‚ü©\n#align is_extreme.convex_diff IsExtreme.convex_diff\n-/\n\n",
 "antisymm":
 "#print IsExtreme.antisymm /-\nprotected theorem IsExtreme.antisymm : anti_symmetric (IsExtreme ùïú : Set E ‚Üí Set E ‚Üí Prop) := fun A B hAB hBA =>\n  Subset.antisymm hBA.1 hAB.1\n#align is_extreme.antisymm IsExtreme.antisymm\n-/\n\n"}