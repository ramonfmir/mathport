{"trans":
 "@[trans]\nprotected theorem is_extreme.trans (hAB : is_extreme ğ•œ A B) (hBC : is_extreme ğ•œ B C) : is_extreme ğ•œ A C :=\n  by\n  refine' âŸ¨subset.trans hBC.1 hAB.1, fun xâ‚ hxâ‚A xâ‚‚ hxâ‚‚A x hxC hx => _âŸ©\n  obtain âŸ¨hxâ‚B, hxâ‚‚BâŸ© := hAB.2 hxâ‚A hxâ‚‚A (hBC.1 hxC) hx\n  exact hBC.2 hxâ‚B hxâ‚‚B hxC hx\n#align is_extreme.trans is_extreme.trans\n\n",
 "rfl":
 "protected theorem is_extreme.rfl : is_extreme ğ•œ A A :=\n  is_extreme.refl ğ•œ A\n#align is_extreme.rfl is_extreme.rfl\n\n",
 "refl":
 "/-\nCopyright (c) 2021 YaÃ«l Dillies, Bhavik Mehta. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: YaÃ«l Dillies, Bhavik Mehta\n-/\n@[refl]\nprotected theorem is_extreme.refl (A : set E) : is_extreme ğ•œ A A :=\n  âŸ¨Subset.rfl, fun xâ‚ hxâ‚A xâ‚‚ hxâ‚‚A x hxA hx => âŸ¨hxâ‚A, hxâ‚‚AâŸ©âŸ©\n#align is_extreme.refl is_extreme.refl\n\n",
 "mono":
 "protected theorem is_extreme.mono (hAC : is_extreme ğ•œ A C) (hBA : B âŠ† A) (hCB : C âŠ† B) : is_extreme ğ•œ B C :=\n  âŸ¨hCB, fun xâ‚ hxâ‚B xâ‚‚ hxâ‚‚B x hxC hx => hAC.2 (hBA hxâ‚B) (hBA hxâ‚‚B) hxC hxâŸ©\n#align is_extreme.mono is_extreme.mono\n\n",
 "mem_extreme_points_iff_mem_diff_convex_hull_diff":
 "theorem convex.mem_extreme_points_iff_mem_diff_convex_hull_diff (hA : convex ğ•œ A) :\n    x âˆˆ A.extreme_points ğ•œ â†” x âˆˆ A \\ convex_hull ğ•œ (A \\ {x}) := by\n  rw [hA.mem_extreme_points_iff_convex_diff, hA.convex_remove_iff_not_mem_convex_hull_remove, mem_diff]\n#align convex.mem_extreme_points_iff_mem_diff_convex_hull_diff convex.mem_extreme_points_iff_mem_diff_convex_hull_diff\n\n",
 "mem_extreme_points_iff_forall_segment":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:632:2: warning: expanding binder collection (xâ‚ xâ‚‚ Â«expr âˆˆ Â» A) -/\n/-- A useful restatement using `segment`: `x` is an extreme point iff the only (closed) segments\nthat contain it are those with `x` as one of their endpoints. -/\ntheorem mem_extreme_points_iff_forall_segment :\n    x âˆˆ A.extreme_points ğ•œ â†” x âˆˆ A âˆ§ âˆ€ (xâ‚) (_ : xâ‚ âˆˆ A) (xâ‚‚) (_ : xâ‚‚ âˆˆ A), x âˆˆ segment ğ•œ xâ‚ xâ‚‚ â†’ xâ‚ = x âˆ¨ xâ‚‚ = x :=\n  by\n  refine' and_congr_right fun hxA => forallâ‚„_congr fun xâ‚ hâ‚ xâ‚‚ hâ‚‚ => _\n  constructor\n  Â· rw [â† insert_endpoints_open_segment]\n    rintro H (rfl | rfl | hx)\n    exacts[or.inl rfl, or.inr rfl, or.inl <| (H hx).1]\n  Â· intro H hx\n    rcases H (open_segment_subset_segment _ _ _ hx) with (rfl | rfl)\n    exacts[âŸ¨rfl, (left_mem_open_segment_iff.1 hx).symmâŸ©, âŸ¨right_mem_open_segment_iff.1 hx, rflâŸ©]\n#align mem_extreme_points_iff_forall_segment mem_extreme_points_iff_forall_segment\n\n",
 "mem_extreme_points_iff_extreme_singleton":
 "/-- x is an extreme point to A iff {x} is an extreme set of A. -/\ntheorem mem_extreme_points_iff_extreme_singleton : x âˆˆ A.extreme_points ğ•œ â†” is_extreme ğ•œ A {x} :=\n  by\n  refine' âŸ¨_, fun hx => âŸ¨singleton_subset_iff.1 hx.1, fun xâ‚ hxâ‚ xâ‚‚ hxâ‚‚ => hx.2 hxâ‚ hxâ‚‚ rflâŸ©âŸ©\n  rintro âŸ¨hxA, hAxâŸ©\n  use singleton_subset_iff.2 hxA\n  rintro xâ‚ hxâ‚A xâ‚‚ hxâ‚‚A y (rfl : y = x)\n  exact hAx hxâ‚A hxâ‚‚A\n#align mem_extreme_points_iff_extreme_singleton mem_extreme_points_iff_extreme_singleton\n\n",
 "mem_extreme_points_iff_convex_diff":
 "theorem convex.mem_extreme_points_iff_convex_diff (hA : convex ğ•œ A) :\n    x âˆˆ A.extreme_points ğ•œ â†” x âˆˆ A âˆ§ convex ğ•œ (A \\ {x}) :=\n  by\n  use fun hx => âŸ¨hx.1, (mem_extreme_points_iff_extreme_singleton.1 hx).convex_diff hAâŸ©\n  rintro âŸ¨hxA, hAxâŸ©\n  refine' mem_extreme_points_iff_forall_segment.2 âŸ¨hxA, fun xâ‚ hxâ‚ xâ‚‚ hxâ‚‚ hx => _âŸ©\n  rw [convex_iff_segment_subset] at hAx\n  by_contra' h\n  exact (hAx âŸ¨hxâ‚, fun hxâ‚ => h.1 (mem_singleton_iff.2 hxâ‚)âŸ© âŸ¨hxâ‚‚, fun hxâ‚‚ => h.2 (mem_singleton_iff.2 hxâ‚‚)âŸ© hx).2 rfl\n#align convex.mem_extreme_points_iff_convex_diff convex.mem_extreme_points_iff_convex_diff\n\n",
 "is_extreme_sInter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹‚â‚€ Â» -/\ntheorem is_extreme_sInter {F : set (set E)} (hF : F.nonempty) (hAF : âˆ€ B âˆˆ F, is_extreme ğ•œ A B) :\n    is_extreme ğ•œ A (Â«exprâ‹‚â‚€ Â» F) := by\n  obtain âŸ¨B, hBâŸ© := hF\n  refine' âŸ¨(sInter_subset_of_mem hB).trans (hAF B hB).1, fun xâ‚ hxâ‚A xâ‚‚ hxâ‚‚A x hxF hx => _âŸ©\n  simp_rw [mem_sInter] at hxFâŠ¢\n  have h := fun B hB => (hAF B hB).2 hxâ‚A hxâ‚‚A (hxF B hB) hx\n  exact âŸ¨fun B hB => (h B hB).1, fun B hB => (h B hB).2âŸ©\n#align is_extreme_sInter is_extreme_sInter\n\n",
 "is_extreme_bInter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹‚ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹‚ , Â» -/\ntheorem is_extreme_bInter {F : set (set E)} (hF : F.nonempty) (hAF : âˆ€ B âˆˆ F, is_extreme ğ•œ A B) :\n    is_extreme ğ•œ A\n      (Â«exprâ‹‚ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹‚ , Â»\" B) :=\n  by\n  obtain âŸ¨B, hBâŸ© := hF\n  refine' âŸ¨(bInter_subset_of_mem hB).trans (hAF B hB).1, fun xâ‚ hxâ‚A xâ‚‚ hxâ‚‚A x hxF hx => _âŸ©\n  simp_rw [mem_Interâ‚‚] at hxFâŠ¢\n  have h := fun B hB => (hAF B hB).2 hxâ‚A hxâ‚‚A (hxF B hB) hx\n  exact âŸ¨fun B hB => (h B hB).1, fun B hB => (h B hB).2âŸ©\n#align is_extreme_bInter is_extreme_bInter\n\n",
 "is_extreme_Inter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹‚ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹‚ , Â» -/\ntheorem is_extreme_Inter {Î¹ : Type _} [nonempty Î¹] {F : Î¹ â†’ set E} (hAF : âˆ€ i : Î¹, is_extreme ğ•œ A (F i)) :\n    is_extreme ğ•œ A\n      (Â«exprâ‹‚ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹‚ , Â»\" (F i)) :=\n  by\n  obtain i := classical.arbitrary Î¹\n  refine' âŸ¨Inter_subset_of_subset i (hAF i).1, fun xâ‚ hxâ‚A xâ‚‚ hxâ‚‚A x hxF hx => _âŸ©\n  simp_rw [mem_Inter] at hxFâŠ¢\n  have h := fun i => (hAF i).2 hxâ‚A hxâ‚‚A (hxF i) hx\n  exact âŸ¨fun i => (h i).1, fun i => (h i).2âŸ©\n#align is_extreme_Inter is_extreme_Inter\n\n",
 "inter_extreme_points_subset_extreme_points_of_subset":
 "theorem inter_extreme_points_subset_extreme_points_of_subset (hBA : B âŠ† A) :\n    B âˆ© A.extreme_points ğ•œ âŠ† B.extreme_points ğ•œ := fun x âŸ¨hxB, hxAâŸ© =>\n  âŸ¨hxB, fun xâ‚ hxâ‚ xâ‚‚ hxâ‚‚ hx => hxA.2 (hBA hxâ‚) (hBA hxâ‚‚) hxâŸ©\n#align inter_extreme_points_subset_extreme_points_of_subset inter_extreme_points_subset_extreme_points_of_subset\n\n",
 "inter":
 "theorem is_extreme.inter (hAB : is_extreme ğ•œ A B) (hAC : is_extreme ğ•œ A C) : is_extreme ğ•œ A (B âˆ© C) :=\n  by\n  use subset.trans (inter_subset_left _ _) hAB.1\n  rintro xâ‚ hxâ‚A xâ‚‚ hxâ‚‚A x âŸ¨hxB, hxCâŸ© hx\n  obtain âŸ¨hxâ‚B, hxâ‚‚BâŸ© := hAB.2 hxâ‚A hxâ‚‚A hxB hx\n  obtain âŸ¨hxâ‚C, hxâ‚‚CâŸ© := hAC.2 hxâ‚A hxâ‚‚A hxC hx\n  exact âŸ¨âŸ¨hxâ‚B, hxâ‚CâŸ©, hxâ‚‚B, hxâ‚‚CâŸ©\n#align is_extreme.inter is_extreme.inter\n\n",
 "extreme_points_subset_extreme_points":
 "theorem is_extreme.extreme_points_subset_extreme_points (hAB : is_extreme ğ•œ A B) :\n    B.extreme_points ğ•œ âŠ† A.extreme_points ğ•œ := fun x hx =>\n  mem_extreme_points_iff_extreme_singleton.2 (hAB.trans (mem_extreme_points_iff_extreme_singleton.1 hx))\n#align is_extreme.extreme_points_subset_extreme_points is_extreme.extreme_points_subset_extreme_points\n\n",
 "extreme_points_subset":
 "theorem extreme_points_subset : A.extreme_points ğ•œ âŠ† A := fun x hx => hx.1\n#align extreme_points_subset extreme_points_subset\n\n",
 "extreme_points_singleton":
 "@[simp]\ntheorem extreme_points_singleton : ({x} : set E).extreme_points ğ•œ = {x} :=\n  extreme_points_subset.antisymm <| singleton_subset_iff.2 âŸ¨mem_singleton x, fun xâ‚ hxâ‚ xâ‚‚ hxâ‚‚ _ => âŸ¨hxâ‚, hxâ‚‚âŸ©âŸ©\n#align extreme_points_singleton extreme_points_singleton\n\n",
 "extreme_points_eq":
 "theorem is_extreme.extreme_points_eq (hAB : is_extreme ğ•œ A B) : B.extreme_points ğ•œ = B âˆ© A.extreme_points ğ•œ :=\n  Subset.antisymm (fun x hx => âŸ¨hx.1, hAB.extreme_points_subset_extreme_points hxâŸ©)\n    (inter_extreme_points_subset_extreme_points_of_subset hAB.1)\n#align is_extreme.extreme_points_eq is_extreme.extreme_points_eq\n\n",
 "extreme_points_empty":
 "@[simp]\ntheorem extreme_points_empty : (âˆ… : set E).extreme_points ğ•œ = âˆ… :=\n  subset_empty_iff.1 extreme_points_subset\n#align extreme_points_empty extreme_points_empty\n\n",
 "extreme_points_def":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:632:2: warning: expanding binder collection (xâ‚ xâ‚‚ Â«expr âˆˆ Â» A) -/\ntheorem extreme_points_def :\n    x âˆˆ A.extreme_points ğ•œ â†”\n      x âˆˆ A âˆ§ âˆ€ (xâ‚) (_ : xâ‚ âˆˆ A) (xâ‚‚) (_ : xâ‚‚ âˆˆ A), x âˆˆ open_segment ğ•œ xâ‚ xâ‚‚ â†’ xâ‚ = x âˆ§ xâ‚‚ = x :=\n  iff.rfl\n#align extreme_points_def extreme_points_def\n\n",
 "extreme_points_convex_hull_subset":
 "theorem extreme_points_convex_hull_subset : (convex_hull ğ•œ A).extreme_points ğ•œ âŠ† A :=\n  by\n  rintro x hx\n  rw [(convex_convex_hull ğ•œ _).mem_extreme_points_iff_convex_diff] at hx\n  by_contra\n  exact (convex_hull_min (subset_diff.2 âŸ¨subset_convex_hull ğ•œ _, disjoint_singleton_right.2 hâŸ©) hx.2 hx.1).2 rfl\n  infer_instance\n#align extreme_points_convex_hull_subset extreme_points_convex_hull_subset\n\n",
 "convex_diff":
 "theorem is_extreme.convex_diff (hA : convex ğ•œ A) (hAB : is_extreme ğ•œ A B) : convex ğ•œ (A \\ B) :=\n  convex_iff_open_segment_subset.2 fun xâ‚ âŸ¨hxâ‚A, hxâ‚BâŸ© xâ‚‚ âŸ¨hxâ‚‚A, hxâ‚‚BâŸ© x hx =>\n    âŸ¨hA.open_segment_subset hxâ‚A hxâ‚‚A hx, fun hxB => hxâ‚B (hAB.2 hxâ‚A hxâ‚‚A hxB hx).1âŸ©\n#align is_extreme.convex_diff is_extreme.convex_diff\n\n",
 "antisymm":
 "protected theorem is_extreme.antisymm : anti_symmetric (is_extreme ğ•œ : set E â†’ set E â†’ Prop) := fun A B hAB hBA =>\n  Subset.antisymm hBA.1 hAB.1\n#align is_extreme.antisymm is_extreme.antisymm\n\n"}