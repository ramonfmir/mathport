{"trans":
 "@[trans]\nprotected theorem is_extreme.trans (hAB : is_extreme 𝕜 A B) (hBC : is_extreme 𝕜 B C) : is_extreme 𝕜 A C :=\n  by\n  refine' ⟨subset.trans hBC.1 hAB.1, fun x₁ hx₁A x₂ hx₂A x hxC hx => _⟩\n  obtain ⟨hx₁B, hx₂B⟩ := hAB.2 hx₁A hx₂A (hBC.1 hxC) hx\n  exact hBC.2 hx₁B hx₂B hxC hx\n#align is_extreme.trans is_extreme.trans\n\n",
 "rfl":
 "protected theorem is_extreme.rfl : is_extreme 𝕜 A A :=\n  is_extreme.refl 𝕜 A\n#align is_extreme.rfl is_extreme.rfl\n\n",
 "refl":
 "/-\nCopyright (c) 2021 Yaël Dillies, Bhavik Mehta. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yaël Dillies, Bhavik Mehta\n-/\n@[refl]\nprotected theorem is_extreme.refl (A : set E) : is_extreme 𝕜 A A :=\n  ⟨Subset.rfl, fun x₁ hx₁A x₂ hx₂A x hxA hx => ⟨hx₁A, hx₂A⟩⟩\n#align is_extreme.refl is_extreme.refl\n\n",
 "mono":
 "protected theorem is_extreme.mono (hAC : is_extreme 𝕜 A C) (hBA : B ⊆ A) (hCB : C ⊆ B) : is_extreme 𝕜 B C :=\n  ⟨hCB, fun x₁ hx₁B x₂ hx₂B x hxC hx => hAC.2 (hBA hx₁B) (hBA hx₂B) hxC hx⟩\n#align is_extreme.mono is_extreme.mono\n\n",
 "mem_extreme_points_iff_mem_diff_convex_hull_diff":
 "theorem convex.mem_extreme_points_iff_mem_diff_convex_hull_diff (hA : convex 𝕜 A) :\n    x ∈ A.extreme_points 𝕜 ↔ x ∈ A \\ convex_hull 𝕜 (A \\ {x}) := by\n  rw [hA.mem_extreme_points_iff_convex_diff, hA.convex_remove_iff_not_mem_convex_hull_remove, mem_diff]\n#align convex.mem_extreme_points_iff_mem_diff_convex_hull_diff convex.mem_extreme_points_iff_mem_diff_convex_hull_diff\n\n",
 "mem_extreme_points_iff_forall_segment":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:632:2: warning: expanding binder collection (x₁ x₂ «expr ∈ » A) -/\n/-- A useful restatement using `segment`: `x` is an extreme point iff the only (closed) segments\nthat contain it are those with `x` as one of their endpoints. -/\ntheorem mem_extreme_points_iff_forall_segment :\n    x ∈ A.extreme_points 𝕜 ↔ x ∈ A ∧ ∀ (x₁) (_ : x₁ ∈ A) (x₂) (_ : x₂ ∈ A), x ∈ segment 𝕜 x₁ x₂ → x₁ = x ∨ x₂ = x :=\n  by\n  refine' and_congr_right fun hxA => forall₄_congr fun x₁ h₁ x₂ h₂ => _\n  constructor\n  · rw [← insert_endpoints_open_segment]\n    rintro H (rfl | rfl | hx)\n    exacts[or.inl rfl, or.inr rfl, or.inl <| (H hx).1]\n  · intro H hx\n    rcases H (open_segment_subset_segment _ _ _ hx) with (rfl | rfl)\n    exacts[⟨rfl, (left_mem_open_segment_iff.1 hx).symm⟩, ⟨right_mem_open_segment_iff.1 hx, rfl⟩]\n#align mem_extreme_points_iff_forall_segment mem_extreme_points_iff_forall_segment\n\n",
 "mem_extreme_points_iff_extreme_singleton":
 "/-- x is an extreme point to A iff {x} is an extreme set of A. -/\ntheorem mem_extreme_points_iff_extreme_singleton : x ∈ A.extreme_points 𝕜 ↔ is_extreme 𝕜 A {x} :=\n  by\n  refine' ⟨_, fun hx => ⟨singleton_subset_iff.1 hx.1, fun x₁ hx₁ x₂ hx₂ => hx.2 hx₁ hx₂ rfl⟩⟩\n  rintro ⟨hxA, hAx⟩\n  use singleton_subset_iff.2 hxA\n  rintro x₁ hx₁A x₂ hx₂A y (rfl : y = x)\n  exact hAx hx₁A hx₂A\n#align mem_extreme_points_iff_extreme_singleton mem_extreme_points_iff_extreme_singleton\n\n",
 "mem_extreme_points_iff_convex_diff":
 "theorem convex.mem_extreme_points_iff_convex_diff (hA : convex 𝕜 A) :\n    x ∈ A.extreme_points 𝕜 ↔ x ∈ A ∧ convex 𝕜 (A \\ {x}) :=\n  by\n  use fun hx => ⟨hx.1, (mem_extreme_points_iff_extreme_singleton.1 hx).convex_diff hA⟩\n  rintro ⟨hxA, hAx⟩\n  refine' mem_extreme_points_iff_forall_segment.2 ⟨hxA, fun x₁ hx₁ x₂ hx₂ hx => _⟩\n  rw [convex_iff_segment_subset] at hAx\n  by_contra' h\n  exact (hAx ⟨hx₁, fun hx₁ => h.1 (mem_singleton_iff.2 hx₁)⟩ ⟨hx₂, fun hx₂ => h.2 (mem_singleton_iff.2 hx₂)⟩ hx).2 rfl\n#align convex.mem_extreme_points_iff_convex_diff convex.mem_extreme_points_iff_convex_diff\n\n",
 "is_extreme_sInter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂₀ » -/\ntheorem is_extreme_sInter {F : set (set E)} (hF : F.nonempty) (hAF : ∀ B ∈ F, is_extreme 𝕜 A B) :\n    is_extreme 𝕜 A («expr⋂₀ » F) := by\n  obtain ⟨B, hB⟩ := hF\n  refine' ⟨(sInter_subset_of_mem hB).trans (hAF B hB).1, fun x₁ hx₁A x₂ hx₂A x hxF hx => _⟩\n  simp_rw [mem_sInter] at hxF⊢\n  have h := fun B hB => (hAF B hB).2 hx₁A hx₂A (hxF B hB) hx\n  exact ⟨fun B hB => (h B hB).1, fun B hB => (h B hB).2⟩\n#align is_extreme_sInter is_extreme_sInter\n\n",
 "is_extreme_bInter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\ntheorem is_extreme_bInter {F : set (set E)} (hF : F.nonempty) (hAF : ∀ B ∈ F, is_extreme 𝕜 A B) :\n    is_extreme 𝕜 A\n      («expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" B) :=\n  by\n  obtain ⟨B, hB⟩ := hF\n  refine' ⟨(bInter_subset_of_mem hB).trans (hAF B hB).1, fun x₁ hx₁A x₂ hx₂A x hxF hx => _⟩\n  simp_rw [mem_Inter₂] at hxF⊢\n  have h := fun B hB => (hAF B hB).2 hx₁A hx₂A (hxF B hB) hx\n  exact ⟨fun B hB => (h B hB).1, fun B hB => (h B hB).2⟩\n#align is_extreme_bInter is_extreme_bInter\n\n",
 "is_extreme_Inter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\ntheorem is_extreme_Inter {ι : Type _} [nonempty ι] {F : ι → set E} (hAF : ∀ i : ι, is_extreme 𝕜 A (F i)) :\n    is_extreme 𝕜 A\n      («expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (F i)) :=\n  by\n  obtain i := classical.arbitrary ι\n  refine' ⟨Inter_subset_of_subset i (hAF i).1, fun x₁ hx₁A x₂ hx₂A x hxF hx => _⟩\n  simp_rw [mem_Inter] at hxF⊢\n  have h := fun i => (hAF i).2 hx₁A hx₂A (hxF i) hx\n  exact ⟨fun i => (h i).1, fun i => (h i).2⟩\n#align is_extreme_Inter is_extreme_Inter\n\n",
 "inter_extreme_points_subset_extreme_points_of_subset":
 "theorem inter_extreme_points_subset_extreme_points_of_subset (hBA : B ⊆ A) :\n    B ∩ A.extreme_points 𝕜 ⊆ B.extreme_points 𝕜 := fun x ⟨hxB, hxA⟩ =>\n  ⟨hxB, fun x₁ hx₁ x₂ hx₂ hx => hxA.2 (hBA hx₁) (hBA hx₂) hx⟩\n#align inter_extreme_points_subset_extreme_points_of_subset inter_extreme_points_subset_extreme_points_of_subset\n\n",
 "inter":
 "theorem is_extreme.inter (hAB : is_extreme 𝕜 A B) (hAC : is_extreme 𝕜 A C) : is_extreme 𝕜 A (B ∩ C) :=\n  by\n  use subset.trans (inter_subset_left _ _) hAB.1\n  rintro x₁ hx₁A x₂ hx₂A x ⟨hxB, hxC⟩ hx\n  obtain ⟨hx₁B, hx₂B⟩ := hAB.2 hx₁A hx₂A hxB hx\n  obtain ⟨hx₁C, hx₂C⟩ := hAC.2 hx₁A hx₂A hxC hx\n  exact ⟨⟨hx₁B, hx₁C⟩, hx₂B, hx₂C⟩\n#align is_extreme.inter is_extreme.inter\n\n",
 "extreme_points_subset_extreme_points":
 "theorem is_extreme.extreme_points_subset_extreme_points (hAB : is_extreme 𝕜 A B) :\n    B.extreme_points 𝕜 ⊆ A.extreme_points 𝕜 := fun x hx =>\n  mem_extreme_points_iff_extreme_singleton.2 (hAB.trans (mem_extreme_points_iff_extreme_singleton.1 hx))\n#align is_extreme.extreme_points_subset_extreme_points is_extreme.extreme_points_subset_extreme_points\n\n",
 "extreme_points_subset":
 "theorem extreme_points_subset : A.extreme_points 𝕜 ⊆ A := fun x hx => hx.1\n#align extreme_points_subset extreme_points_subset\n\n",
 "extreme_points_singleton":
 "@[simp]\ntheorem extreme_points_singleton : ({x} : set E).extreme_points 𝕜 = {x} :=\n  extreme_points_subset.antisymm <| singleton_subset_iff.2 ⟨mem_singleton x, fun x₁ hx₁ x₂ hx₂ _ => ⟨hx₁, hx₂⟩⟩\n#align extreme_points_singleton extreme_points_singleton\n\n",
 "extreme_points_eq":
 "theorem is_extreme.extreme_points_eq (hAB : is_extreme 𝕜 A B) : B.extreme_points 𝕜 = B ∩ A.extreme_points 𝕜 :=\n  Subset.antisymm (fun x hx => ⟨hx.1, hAB.extreme_points_subset_extreme_points hx⟩)\n    (inter_extreme_points_subset_extreme_points_of_subset hAB.1)\n#align is_extreme.extreme_points_eq is_extreme.extreme_points_eq\n\n",
 "extreme_points_empty":
 "@[simp]\ntheorem extreme_points_empty : (∅ : set E).extreme_points 𝕜 = ∅ :=\n  subset_empty_iff.1 extreme_points_subset\n#align extreme_points_empty extreme_points_empty\n\n",
 "extreme_points_def":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:632:2: warning: expanding binder collection (x₁ x₂ «expr ∈ » A) -/\ntheorem extreme_points_def :\n    x ∈ A.extreme_points 𝕜 ↔\n      x ∈ A ∧ ∀ (x₁) (_ : x₁ ∈ A) (x₂) (_ : x₂ ∈ A), x ∈ open_segment 𝕜 x₁ x₂ → x₁ = x ∧ x₂ = x :=\n  iff.rfl\n#align extreme_points_def extreme_points_def\n\n",
 "extreme_points_convex_hull_subset":
 "theorem extreme_points_convex_hull_subset : (convex_hull 𝕜 A).extreme_points 𝕜 ⊆ A :=\n  by\n  rintro x hx\n  rw [(convex_convex_hull 𝕜 _).mem_extreme_points_iff_convex_diff] at hx\n  by_contra\n  exact (convex_hull_min (subset_diff.2 ⟨subset_convex_hull 𝕜 _, disjoint_singleton_right.2 h⟩) hx.2 hx.1).2 rfl\n  infer_instance\n#align extreme_points_convex_hull_subset extreme_points_convex_hull_subset\n\n",
 "convex_diff":
 "theorem is_extreme.convex_diff (hA : convex 𝕜 A) (hAB : is_extreme 𝕜 A B) : convex 𝕜 (A \\ B) :=\n  convex_iff_open_segment_subset.2 fun x₁ ⟨hx₁A, hx₁B⟩ x₂ ⟨hx₂A, hx₂B⟩ x hx =>\n    ⟨hA.open_segment_subset hx₁A hx₂A hx, fun hxB => hx₁B (hAB.2 hx₁A hx₂A hxB hx).1⟩\n#align is_extreme.convex_diff is_extreme.convex_diff\n\n",
 "antisymm":
 "protected theorem is_extreme.antisymm : anti_symmetric (is_extreme 𝕜 : set E → set E → Prop) := fun A B hAB hBA =>\n  Subset.antisymm hBA.1 hAB.1\n#align is_extreme.antisymm is_extreme.antisymm\n\n"}