{"w_same_side₃₂":
 "theorem _root_.wbtw.w_same_side₃₂ {s : AffineSubspace R P} {x y z : P} (h : wbtw R x y z) (hx : x ∈ s) :\n    s.w_same_side z y :=\n  (h.w_same_side₂₃ hx).symm\n#align wbtw.w_same_side₃₂ wbtw.w_same_side₃₂\n\n",
 "w_same_side₂₃":
 "theorem _root_.wbtw.w_same_side₂₃ {s : AffineSubspace R P} {x y z : P} (h : wbtw R x y z) (hx : x ∈ s) :\n    s.w_same_side y z := by\n  rcases h with ⟨t, ⟨ht0, -⟩, rfl⟩\n  exact w_same_side_line_map_left z hx ht0\n#align wbtw.w_same_side₂₃ wbtw.w_same_side₂₃\n\n",
 "w_same_side₂₁":
 "theorem _root_.wbtw.w_same_side₂₁ {s : AffineSubspace R P} {x y z : P} (h : wbtw R x y z) (hz : z ∈ s) :\n    s.w_same_side y x :=\n  h.symm.w_same_side₂₃ hz\n#align wbtw.w_same_side₂₁ wbtw.w_same_side₂₁\n\n",
 "w_same_side₁₂":
 "theorem _root_.wbtw.w_same_side₁₂ {s : AffineSubspace R P} {x y z : P} (h : wbtw R x y z) (hz : z ∈ s) :\n    s.w_same_side x y :=\n  h.symm.w_same_side₃₂ hz\n#align wbtw.w_same_side₁₂ wbtw.w_same_side₁₂\n\n",
 "w_same_side_vadd_right_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr +ᵥ » -/\ntheorem w_same_side_vadd_right_iff {s : AffineSubspace R P} {x y : P} {v : V} (hv : v ∈ s.direction) :\n    s.w_same_side x («expr +ᵥ » v y) ↔ s.w_same_side x y := by\n  rw [w_same_side_comm, w_same_side_vadd_left_iff hv, w_same_side_comm]\n#align w_same_side_vadd_right_iff w_same_side_vadd_right_iff\n\n",
 "w_same_side_vadd_left_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr +ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr +ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr +ᵥ » -/\ntheorem w_same_side_vadd_left_iff {s : AffineSubspace R P} {x y : P} {v : V} (hv : v ∈ s.direction) :\n    s.w_same_side («expr +ᵥ » v x) y ↔ s.w_same_side x y :=\n  by\n  constructor\n  · rintro ⟨p₁, hp₁, p₂, hp₂, h⟩\n    refine' ⟨«expr +ᵥ » (-v) p₁, AffineSubspace.vadd_mem_of_mem_direction (Submodule.neg_mem _ hv) hp₁, p₂, hp₂, _⟩\n    rwa [vsub_vadd_eq_vsub_sub, sub_neg_eq_add, add_comm, ← vadd_vsub_assoc]\n  · rintro ⟨p₁, hp₁, p₂, hp₂, h⟩\n    refine' ⟨«expr +ᵥ » v p₁, AffineSubspace.vadd_mem_of_mem_direction hv hp₁, p₂, hp₂, _⟩\n    rwa [vadd_vsub_vadd_cancel_left]\n#align w_same_side_vadd_left_iff w_same_side_vadd_left_iff\n\n",
 "w_same_side_smul_vsub_vadd_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr +ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\ntheorem w_same_side_smul_vsub_vadd_right {s : AffineSubspace R P} {p₁ p₂ : P} (x : P) (hp₁ : p₁ ∈ s) (hp₂ : p₂ ∈ s)\n    {t : R} (ht : 0 ≤ t) : s.w_same_side x («expr +ᵥ » («expr • » t («expr -ᵥ » x p₁)) p₂) :=\n  (w_same_side_smul_vsub_vadd_left x hp₁ hp₂ ht).symm\n#align w_same_side_smul_vsub_vadd_right w_same_side_smul_vsub_vadd_right\n\n",
 "w_same_side_smul_vsub_vadd_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr +ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\ntheorem w_same_side_smul_vsub_vadd_left {s : AffineSubspace R P} {p₁ p₂ : P} (x : P) (hp₁ : p₁ ∈ s) (hp₂ : p₂ ∈ s)\n    {t : R} (ht : 0 ≤ t) : s.w_same_side («expr +ᵥ » («expr • » t («expr -ᵥ » x p₁)) p₂) x :=\n  by\n  refine' ⟨p₂, hp₂, p₁, hp₁, _⟩\n  rw [vadd_vsub]\n  exact SameRay.sameRay_nonneg_smul_left _ ht\n#align w_same_side_smul_vsub_vadd_left w_same_side_smul_vsub_vadd_left\n\n",
 "w_same_side_self_iff":
 "@[simp]\ntheorem w_same_side_self_iff {s : AffineSubspace R P} {x : P} : s.w_same_side x x ↔ (s : Set P).nonempty :=\n  ⟨fun h => h.nonempty, fun ⟨p, hp⟩ => ⟨p, hp, p, hp, SameRay.rfl⟩⟩\n#align w_same_side_self_iff w_same_side_self_iff\n\n",
 "w_same_side_of_right_mem":
 "theorem w_same_side_of_right_mem {s : AffineSubspace R P} (x : P) {y : P} (hy : y ∈ s) : s.w_same_side x y :=\n  (w_same_side_of_left_mem x hy).symm\n#align w_same_side_of_right_mem w_same_side_of_right_mem\n\n",
 "w_same_side_of_left_mem":
 "theorem w_same_side_of_left_mem {s : AffineSubspace R P} {x : P} (y : P) (hx : x ∈ s) : s.w_same_side x y :=\n  by\n  refine' ⟨x, hx, x, hx, _⟩\n  simp\n#align w_same_side_of_left_mem w_same_side_of_left_mem\n\n",
 "w_same_side_map_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ᵃ[ ] » -/\n@[simp]\ntheorem _root_.affine_equiv.w_same_side_map_iff {s : AffineSubspace R P} {x y : P} (f : «expr ≃ᵃ[ ] » P R P') :\n    (s.map ↑f).w_same_side (f x) (f y) ↔ s.w_same_side x y :=\n  (show function.injective f.to_affine_map from f.injective).w_same_side_map_iff\n#align affine_equiv.w_same_side_map_iff affine_equiv.w_same_side_map_iff\n\n",
 "w_same_side_line_map_right":
 "theorem w_same_side_line_map_right {s : AffineSubspace R P} {x : P} (y : P) (h : x ∈ s) {t : R} (ht : 0 ≤ t) :\n    s.w_same_side y (lineMap x y t) :=\n  (w_same_side_line_map_left y h ht).symm\n#align w_same_side_line_map_right w_same_side_line_map_right\n\n",
 "w_same_side_line_map_left":
 "theorem w_same_side_line_map_left {s : AffineSubspace R P} {x : P} (y : P) (h : x ∈ s) {t : R} (ht : 0 ≤ t) :\n    s.w_same_side (lineMap x y t) y :=\n  w_same_side_smul_vsub_vadd_left y h h ht\n#align w_same_side_line_map_left w_same_side_line_map_left\n\n",
 "w_same_side_iff_exists_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\ntheorem w_same_side_iff_exists_right {s : AffineSubspace R P} {x y p₂ : P} (h : p₂ ∈ s) :\n    s.w_same_side x y ↔ y ∈ s ∨ ∃ p₁ ∈ s, SameRay R («expr -ᵥ » x p₁) («expr -ᵥ » y p₂) :=\n  by\n  rw [w_same_side_comm, w_same_side_iff_exists_left h]\n  simp_rw [SameRay.sameRay_comm]\n#align w_same_side_iff_exists_right w_same_side_iff_exists_right\n\n",
 "w_same_side_iff_exists_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr +ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\ntheorem w_same_side_iff_exists_left {s : AffineSubspace R P} {x y p₁ : P} (h : p₁ ∈ s) :\n    s.w_same_side x y ↔ x ∈ s ∨ ∃ p₂ ∈ s, SameRay R («expr -ᵥ » x p₁) («expr -ᵥ » y p₂) :=\n  by\n  constructor\n  · rintro ⟨p₁', hp₁', p₂', hp₂', h0 | h0 | ⟨r₁, r₂, hr₁, hr₂, hr⟩⟩\n    · rw [vsub_eq_zero_iff_eq] at h0\n      rw [h0]\n      exact or.inl hp₁'\n    · refine' or.inr ⟨p₂', hp₂', _⟩\n      rw [h0]\n      exact SameRay.zero_right _\n    · refine'\n        or.inr\n          ⟨«expr +ᵥ » («expr • » (r₁ / r₂) («expr -ᵥ » p₁ p₁')) p₂', s.smul_vsub_vadd_mem _ h hp₁' hp₂',\n            or.inr (or.inr ⟨r₁, r₂, hr₁, hr₂, _⟩)⟩\n      rw [vsub_vadd_eq_vsub_sub, smul_sub, ← hr, smul_smul, mul_div_cancel' _ hr₂.ne.symm, ← smul_sub,\n        vsub_sub_vsub_cancel_right]\n  · rintro (h' | h')\n    · exact w_same_side_of_left_mem y h'\n    · exact ⟨p₁, h, h'⟩\n#align w_same_side_iff_exists_left w_same_side_iff_exists_left\n\n",
 "w_same_side_comm":
 "theorem w_same_side_comm {s : AffineSubspace R P} {x y : P} : s.w_same_side x y ↔ s.w_same_side y x :=\n  ⟨fun ⟨p₁, hp₁, p₂, hp₂, h⟩ => ⟨p₂, hp₂, p₁, hp₁, h.symm⟩, fun ⟨p₁, hp₁, p₂, hp₂, h⟩ => ⟨p₂, hp₂, p₁, hp₁, h.symm⟩⟩\n#align w_same_side_comm w_same_side_comm\n\n",
 "w_same_side_and_w_opp_side_iff":
 "theorem w_same_side_and_w_opp_side_iff {s : AffineSubspace R P} {x y : P} :\n    s.w_same_side x y ∧ s.w_opp_side x y ↔ x ∈ s ∨ y ∈ s :=\n  by\n  constructor\n  · rintro ⟨hs, ho⟩\n    rw [w_opp_side_comm] at ho\n    by_contra h\n    rw [not_or] at h\n    exact h.1 (w_opp_side_self_iff.1 (hs.trans_w_opp_side ho h.2))\n  · rintro (h | h)\n    · exact ⟨w_same_side_of_left_mem y h, w_opp_side_of_left_mem y h⟩\n    · exact ⟨w_same_side_of_right_mem x h, w_opp_side_of_right_mem x h⟩\n#align w_same_side_and_w_opp_side_iff w_same_side_and_w_opp_side_iff\n\n",
 "w_same_side":
 "theorem s_same_side.w_same_side {s : AffineSubspace R P} {x y : P} (h : s.s_same_side x y) : s.w_same_side x y :=\n  h.1\n#align s_same_side.w_same_side s_same_side.w_same_side\n\n",
 "w_opp_side₃₁":
 "theorem _root_.wbtw.w_opp_side₃₁ {s : AffineSubspace R P} {x y z : P} (h : wbtw R x y z) (hy : y ∈ s) :\n    s.w_opp_side z x :=\n  h.symm.w_opp_side₁₃ hy\n#align wbtw.w_opp_side₃₁ wbtw.w_opp_side₃₁\n\n",
 "w_opp_side₁₃":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\ntheorem _root_.wbtw.w_opp_side₁₃ {s : AffineSubspace R P} {x y z : P} (h : wbtw R x y z) (hy : y ∈ s) :\n    s.w_opp_side x z := by\n  rcases h with ⟨t, ⟨ht0, ht1⟩, rfl⟩\n  refine' ⟨_, hy, _, hy, _⟩\n  rcases ht1.lt_or_eq with (ht1' | rfl); swap; · simp\n  rcases ht0.lt_or_eq with (ht0' | rfl); swap; · simp\n  refine' or.inr (or.inr ⟨1 - t, t, sub_pos.2 ht1', ht0', _⟩)\n  simp_rw [line_map_apply, vadd_vsub_assoc, vsub_vadd_eq_vsub_sub, ← neg_vsub_eq_vsub_rev z x, vsub_self, zero_sub, ←\n    neg_one_smul R («expr -ᵥ » z x), ← add_smul, smul_neg, ← neg_smul, smul_smul]\n  ring_nf\n#align wbtw.w_opp_side₁₃ wbtw.w_opp_side₁₃\n\n",
 "w_opp_side_vadd_right_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr +ᵥ » -/\ntheorem w_opp_side_vadd_right_iff {s : AffineSubspace R P} {x y : P} {v : V} (hv : v ∈ s.direction) :\n    s.w_opp_side x («expr +ᵥ » v y) ↔ s.w_opp_side x y := by\n  rw [w_opp_side_comm, w_opp_side_vadd_left_iff hv, w_opp_side_comm]\n#align w_opp_side_vadd_right_iff w_opp_side_vadd_right_iff\n\n",
 "w_opp_side_vadd_left_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr +ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr +ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr +ᵥ » -/\ntheorem w_opp_side_vadd_left_iff {s : AffineSubspace R P} {x y : P} {v : V} (hv : v ∈ s.direction) :\n    s.w_opp_side («expr +ᵥ » v x) y ↔ s.w_opp_side x y :=\n  by\n  constructor\n  · rintro ⟨p₁, hp₁, p₂, hp₂, h⟩\n    refine' ⟨«expr +ᵥ » (-v) p₁, AffineSubspace.vadd_mem_of_mem_direction (Submodule.neg_mem _ hv) hp₁, p₂, hp₂, _⟩\n    rwa [vsub_vadd_eq_vsub_sub, sub_neg_eq_add, add_comm, ← vadd_vsub_assoc]\n  · rintro ⟨p₁, hp₁, p₂, hp₂, h⟩\n    refine' ⟨«expr +ᵥ » v p₁, AffineSubspace.vadd_mem_of_mem_direction hv hp₁, p₂, hp₂, _⟩\n    rwa [vadd_vsub_vadd_cancel_left]\n#align w_opp_side_vadd_left_iff w_opp_side_vadd_left_iff\n\n",
 "w_opp_side_smul_vsub_vadd_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr +ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\ntheorem w_opp_side_smul_vsub_vadd_right {s : AffineSubspace R P} {p₁ p₂ : P} (x : P) (hp₁ : p₁ ∈ s) (hp₂ : p₂ ∈ s)\n    {t : R} (ht : t ≤ 0) : s.w_opp_side x («expr +ᵥ » («expr • » t («expr -ᵥ » x p₁)) p₂) :=\n  (w_opp_side_smul_vsub_vadd_left x hp₁ hp₂ ht).symm\n#align w_opp_side_smul_vsub_vadd_right w_opp_side_smul_vsub_vadd_right\n\n",
 "w_opp_side_smul_vsub_vadd_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr +ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\ntheorem w_opp_side_smul_vsub_vadd_left {s : AffineSubspace R P} {p₁ p₂ : P} (x : P) (hp₁ : p₁ ∈ s) (hp₂ : p₂ ∈ s)\n    {t : R} (ht : t ≤ 0) : s.w_opp_side («expr +ᵥ » («expr • » t («expr -ᵥ » x p₁)) p₂) x :=\n  by\n  refine' ⟨p₂, hp₂, p₁, hp₁, _⟩\n  rw [vadd_vsub, ← neg_neg t, neg_smul, ← smul_neg, neg_vsub_eq_vsub_rev]\n  exact SameRay.sameRay_nonneg_smul_left _ (neg_nonneg.2 ht)\n#align w_opp_side_smul_vsub_vadd_left w_opp_side_smul_vsub_vadd_left\n\n",
 "w_opp_side_self_iff":
 "@[simp]\ntheorem w_opp_side_self_iff {s : AffineSubspace R P} {x : P} : s.w_opp_side x x ↔ x ∈ s :=\n  by\n  constructor\n  · rintro ⟨p₁, hp₁, p₂, hp₂, h⟩\n    obtain ⟨a, -, -, -, -, h₁, -⟩ := h.exists_eq_smul_add\n    rw [add_comm, vsub_add_vsub_cancel, ← eq_vadd_iff_vsub_eq] at h₁\n    rw [h₁]\n    exact s.smul_vsub_vadd_mem a hp₂ hp₁ hp₁\n  · exact fun h => ⟨x, h, x, h, SameRay.rfl⟩\n#align w_opp_side_self_iff w_opp_side_self_iff\n\n",
 "w_opp_side_point_reflection":
 "theorem w_opp_side_point_reflection {s : AffineSubspace R P} {x : P} (y : P) (hx : x ∈ s) :\n    s.w_opp_side y (pointReflection R x y) :=\n  (wbtw_point_reflection R _ _).w_opp_side₁₃ hx\n#align w_opp_side_point_reflection w_opp_side_point_reflection\n\n",
 "w_opp_side_of_right_mem":
 "theorem w_opp_side_of_right_mem {s : AffineSubspace R P} (x : P) {y : P} (hy : y ∈ s) : s.w_opp_side x y :=\n  (w_opp_side_of_left_mem x hy).symm\n#align w_opp_side_of_right_mem w_opp_side_of_right_mem\n\n",
 "w_opp_side_of_left_mem":
 "theorem w_opp_side_of_left_mem {s : AffineSubspace R P} {x : P} (y : P) (hx : x ∈ s) : s.w_opp_side x y :=\n  by\n  refine' ⟨x, hx, x, hx, _⟩\n  simp\n#align w_opp_side_of_left_mem w_opp_side_of_left_mem\n\n",
 "w_opp_side_map_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ᵃ[ ] » -/\n@[simp]\ntheorem _root_.affine_equiv.w_opp_side_map_iff {s : AffineSubspace R P} {x y : P} (f : «expr ≃ᵃ[ ] » P R P') :\n    (s.map ↑f).w_opp_side (f x) (f y) ↔ s.w_opp_side x y :=\n  (show function.injective f.to_affine_map from f.injective).w_opp_side_map_iff\n#align affine_equiv.w_opp_side_map_iff affine_equiv.w_opp_side_map_iff\n\n",
 "w_opp_side_line_map_right":
 "theorem w_opp_side_line_map_right {s : AffineSubspace R P} {x : P} (y : P) (h : x ∈ s) {t : R} (ht : t ≤ 0) :\n    s.w_opp_side y (lineMap x y t) :=\n  (w_opp_side_line_map_left y h ht).symm\n#align w_opp_side_line_map_right w_opp_side_line_map_right\n\n",
 "w_opp_side_line_map_left":
 "theorem w_opp_side_line_map_left {s : AffineSubspace R P} {x : P} (y : P) (h : x ∈ s) {t : R} (ht : t ≤ 0) :\n    s.w_opp_side (lineMap x y t) y :=\n  w_opp_side_smul_vsub_vadd_left y h h ht\n#align w_opp_side_line_map_left w_opp_side_line_map_left\n\n",
 "w_opp_side_iff_exists_wbtw":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\ntheorem w_opp_side_iff_exists_wbtw {s : AffineSubspace R P} {x y : P} : s.w_opp_side x y ↔ ∃ p ∈ s, wbtw R x p y :=\n  by\n  refine' ⟨fun h => _, fun ⟨p, hp, h⟩ => h.w_opp_side₁₃ hp⟩\n  rcases h with ⟨p₁, hp₁, p₂, hp₂, h | h | ⟨r₁, r₂, hr₁, hr₂, h⟩⟩\n  · rw [vsub_eq_zero_iff_eq] at h\n    rw [h]\n    exact ⟨p₁, hp₁, wbtw_self_left _ _ _⟩\n  · rw [vsub_eq_zero_iff_eq] at h\n    rw [← h]\n    exact ⟨p₂, hp₂, wbtw_self_right _ _ _⟩\n  · refine' ⟨line_map x y (r₂ / (r₁ + r₂)), _, _⟩\n    · rw [line_map_apply, ← vsub_vadd x p₁, ← vsub_vadd y p₂, vsub_vadd_eq_vsub_sub, vadd_vsub_assoc, ← vadd_assoc,\n        vadd_eq_add]\n      convert s.smul_vsub_vadd_mem (r₂ / (r₁ + r₂)) hp₂ hp₁ hp₁\n      rw [add_comm («expr -ᵥ » y p₂), smul_sub, smul_add, add_sub_assoc, add_assoc, add_right_eq_self, div_eq_inv_mul, ←\n        neg_vsub_eq_vsub_rev, smul_neg, ← smul_smul, ← h, smul_smul, ← neg_smul, ← sub_smul, ← div_eq_inv_mul, ←\n        div_eq_inv_mul, ← neg_div, ← sub_div, sub_eq_add_neg, ← neg_add, neg_div,\n        div_self (Left.add_pos hr₁ hr₂).ne.symm, neg_one_smul, neg_add_self]\n    ·\n      exact\n        Set.mem_image_of_mem _\n          ⟨div_nonneg hr₂.le (Left.add_pos hr₁ hr₂).le,\n            div_le_one_of_le (le_add_of_nonneg_left hr₁.le) (Left.add_pos hr₁ hr₂).le⟩\n#align w_opp_side_iff_exists_wbtw w_opp_side_iff_exists_wbtw\n\n",
 "w_opp_side_iff_exists_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\ntheorem w_opp_side_iff_exists_right {s : AffineSubspace R P} {x y p₂ : P} (h : p₂ ∈ s) :\n    s.w_opp_side x y ↔ y ∈ s ∨ ∃ p₁ ∈ s, SameRay R («expr -ᵥ » x p₁) («expr -ᵥ » p₂ y) :=\n  by\n  rw [w_opp_side_comm, w_opp_side_iff_exists_left h]\n  constructor\n  · rintro (hy | ⟨p, hp, hr⟩)\n    · exact or.inl hy\n    refine' or.inr ⟨p, hp, _⟩\n    rwa [SameRay.sameRay_comm, ← sameRay_neg_iff, neg_vsub_eq_vsub_rev, neg_vsub_eq_vsub_rev]\n  · rintro (hy | ⟨p, hp, hr⟩)\n    · exact or.inl hy\n    refine' or.inr ⟨p, hp, _⟩\n    rwa [SameRay.sameRay_comm, ← sameRay_neg_iff, neg_vsub_eq_vsub_rev, neg_vsub_eq_vsub_rev]\n#align w_opp_side_iff_exists_right w_opp_side_iff_exists_right\n\n",
 "w_opp_side_iff_exists_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr +ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\ntheorem w_opp_side_iff_exists_left {s : AffineSubspace R P} {x y p₁ : P} (h : p₁ ∈ s) :\n    s.w_opp_side x y ↔ x ∈ s ∨ ∃ p₂ ∈ s, SameRay R («expr -ᵥ » x p₁) («expr -ᵥ » p₂ y) :=\n  by\n  constructor\n  · rintro ⟨p₁', hp₁', p₂', hp₂', h0 | h0 | ⟨r₁, r₂, hr₁, hr₂, hr⟩⟩\n    · rw [vsub_eq_zero_iff_eq] at h0\n      rw [h0]\n      exact or.inl hp₁'\n    · refine' or.inr ⟨p₂', hp₂', _⟩\n      rw [h0]\n      exact SameRay.zero_right _\n    · refine'\n        or.inr\n          ⟨«expr +ᵥ » («expr • » (-r₁ / r₂) («expr -ᵥ » p₁ p₁')) p₂', s.smul_vsub_vadd_mem _ h hp₁' hp₂',\n            or.inr (or.inr ⟨r₁, r₂, hr₁, hr₂, _⟩)⟩\n      rw [vadd_vsub_assoc, smul_add, ← hr, smul_smul, neg_div, mul_neg, mul_div_cancel' _ hr₂.ne.symm, neg_smul,\n        neg_add_eq_sub, ← smul_sub, vsub_sub_vsub_cancel_right]\n  · rintro (h' | h')\n    · exact w_opp_side_of_left_mem y h'\n    · exact ⟨p₁, h, h'⟩\n#align w_opp_side_iff_exists_left w_opp_side_iff_exists_left\n\n",
 "w_opp_side_comm":
 "theorem w_opp_side_comm {s : AffineSubspace R P} {x y : P} : s.w_opp_side x y ↔ s.w_opp_side y x :=\n  by\n  constructor\n  · rintro ⟨p₁, hp₁, p₂, hp₂, h⟩\n    refine' ⟨p₂, hp₂, p₁, hp₁, _⟩\n    rwa [SameRay.sameRay_comm, ← sameRay_neg_iff, neg_vsub_eq_vsub_rev, neg_vsub_eq_vsub_rev]\n  · rintro ⟨p₁, hp₁, p₂, hp₂, h⟩\n    refine' ⟨p₂, hp₂, p₁, hp₁, _⟩\n    rwa [SameRay.sameRay_comm, ← sameRay_neg_iff, neg_vsub_eq_vsub_rev, neg_vsub_eq_vsub_rev]\n#align w_opp_side_comm w_opp_side_comm\n\n",
 "w_opp_side":
 "theorem s_opp_side.w_opp_side {s : AffineSubspace R P} {x y : P} (h : s.s_opp_side x y) : s.w_opp_side x y :=\n  h.1\n#align s_opp_side.w_opp_side s_opp_side.w_opp_side\n\n",
 "trans_w_same_side":
 "theorem s_opp_side.trans_w_same_side {s : AffineSubspace R P} {x y z : P} (hxy : s.s_opp_side x y)\n    (hyz : s.w_same_side y z) : s.w_opp_side x z :=\n  (hyz.symm.trans_s_opp_side hxy.symm).symm\n#align s_opp_side.trans_w_same_side s_opp_side.trans_w_same_side\n\n",
 "trans_w_opp_side":
 "theorem s_opp_side.trans_w_opp_side {s : AffineSubspace R P} {x y z : P} (hxy : s.s_opp_side x y)\n    (hyz : s.w_opp_side y z) : s.w_same_side x z :=\n  (hyz.symm.trans_s_opp_side hxy.symm).symm\n#align s_opp_side.trans_w_opp_side s_opp_side.trans_w_opp_side\n\n",
 "trans_s_same_side":
 "theorem s_opp_side.trans_s_same_side {s : AffineSubspace R P} {x y z : P} (hxy : s.s_opp_side x y)\n    (hyz : s.s_same_side y z) : s.s_opp_side x z :=\n  (hyz.symm.trans_s_opp_side hxy.symm).symm\n#align s_opp_side.trans_s_same_side s_opp_side.trans_s_same_side\n\n",
 "trans_s_opp_side":
 "theorem w_opp_side.trans_s_opp_side {s : AffineSubspace R P} {x y z : P} (hxy : s.w_opp_side x y)\n    (hyz : s.s_opp_side y z) : s.w_same_side x z :=\n  hxy.trans hyz.1 hyz.2.1\n#align w_opp_side.trans_s_opp_side w_opp_side.trans_s_opp_side\n\n",
 "trans":
 "theorem s_opp_side.trans {s : AffineSubspace R P} {x y z : P} (hxy : s.s_opp_side x y) (hyz : s.s_opp_side y z) :\n    s.s_same_side x z :=\n  ⟨hxy.trans_w_opp_side hyz.1, hxy.2.1, hyz.2.2⟩\n#align s_opp_side.trans s_opp_side.trans\n\n",
 "set_of_w_same_side_eq_image2":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr +ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\ntheorem set_of_w_same_side_eq_image2 {s : AffineSubspace R P} {x p : P} (hx : x ∉ s) (hp : p ∈ s) :\n    { y | s.w_same_side x y } =\n      Set.image2 (fun (t : R) q => «expr +ᵥ » («expr • » t («expr -ᵥ » x p)) q) (Set.Ici 0) s :=\n  by\n  ext y\n  simp_rw [Set.mem_setOf, Set.mem_image2, Set.mem_Ici, mem_coe]\n  constructor\n  · rw [w_same_side_iff_exists_left hp, or_iff_right hx]\n    rintro ⟨p₂, hp₂, h | h | ⟨r₁, r₂, hr₁, hr₂, h⟩⟩\n    · rw [vsub_eq_zero_iff_eq] at h\n      exact false.elim (hx (h.symm ▸ hp))\n    · rw [vsub_eq_zero_iff_eq] at h\n      refine' ⟨0, p₂, le_refl _, hp₂, _⟩\n      simp [h]\n    · refine' ⟨r₁ / r₂, p₂, (div_pos hr₁ hr₂).le, hp₂, _⟩\n      rw [div_eq_inv_mul, ← smul_smul, h, smul_smul, inv_mul_cancel hr₂.ne.symm, one_smul, vsub_vadd]\n  · rintro ⟨t, p', ht, hp', rfl⟩\n    exact w_same_side_smul_vsub_vadd_right x hp hp' ht\n#align set_of_w_same_side_eq_image2 set_of_w_same_side_eq_image2\n\n",
 "set_of_w_opp_side_eq_image2":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr +ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\ntheorem set_of_w_opp_side_eq_image2 {s : AffineSubspace R P} {x p : P} (hx : x ∉ s) (hp : p ∈ s) :\n    { y | s.w_opp_side x y } =\n      Set.image2 (fun (t : R) q => «expr +ᵥ » («expr • » t («expr -ᵥ » x p)) q) (Set.Iic 0) s :=\n  by\n  ext y\n  simp_rw [Set.mem_setOf, Set.mem_image2, Set.mem_Iic, mem_coe]\n  constructor\n  · rw [w_opp_side_iff_exists_left hp, or_iff_right hx]\n    rintro ⟨p₂, hp₂, h | h | ⟨r₁, r₂, hr₁, hr₂, h⟩⟩\n    · rw [vsub_eq_zero_iff_eq] at h\n      exact false.elim (hx (h.symm ▸ hp))\n    · rw [vsub_eq_zero_iff_eq] at h\n      refine' ⟨0, p₂, le_refl _, hp₂, _⟩\n      simp [h]\n    · refine' ⟨-r₁ / r₂, p₂, (div_neg_of_neg_of_pos (Left.neg_neg_iff.2 hr₁) hr₂).le, hp₂, _⟩\n      rw [div_eq_inv_mul, ← smul_smul, neg_smul, h, smul_neg, smul_smul, inv_mul_cancel hr₂.ne.symm, one_smul,\n        neg_vsub_eq_vsub_rev, vsub_vadd]\n  · rintro ⟨t, p', ht, hp', rfl⟩\n    exact w_opp_side_smul_vsub_vadd_right x hp hp' ht\n#align set_of_w_opp_side_eq_image2 set_of_w_opp_side_eq_image2\n\n",
 "set_of_s_same_side_eq_image2":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr +ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\ntheorem set_of_s_same_side_eq_image2 {s : AffineSubspace R P} {x p : P} (hx : x ∉ s) (hp : p ∈ s) :\n    { y | s.s_same_side x y } =\n      Set.image2 (fun (t : R) q => «expr +ᵥ » («expr • » t («expr -ᵥ » x p)) q) (Set.Ioi 0) s :=\n  by\n  ext y\n  simp_rw [Set.mem_setOf, Set.mem_image2, Set.mem_Ioi, mem_coe]\n  constructor\n  · rw [s_same_side_iff_exists_left hp]\n    rintro ⟨-, hy, p₂, hp₂, h | h | ⟨r₁, r₂, hr₁, hr₂, h⟩⟩\n    · rw [vsub_eq_zero_iff_eq] at h\n      exact false.elim (hx (h.symm ▸ hp))\n    · rw [vsub_eq_zero_iff_eq] at h\n      exact false.elim (hy (h.symm ▸ hp₂))\n    · refine' ⟨r₁ / r₂, p₂, div_pos hr₁ hr₂, hp₂, _⟩\n      rw [div_eq_inv_mul, ← smul_smul, h, smul_smul, inv_mul_cancel hr₂.ne.symm, one_smul, vsub_vadd]\n  · rintro ⟨t, p', ht, hp', rfl⟩\n    exact s_same_side_smul_vsub_vadd_right hx hp hp' ht\n#align set_of_s_same_side_eq_image2 set_of_s_same_side_eq_image2\n\n",
 "set_of_s_opp_side_eq_image2":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr +ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\ntheorem set_of_s_opp_side_eq_image2 {s : AffineSubspace R P} {x p : P} (hx : x ∉ s) (hp : p ∈ s) :\n    { y | s.s_opp_side x y } =\n      Set.image2 (fun (t : R) q => «expr +ᵥ » («expr • » t («expr -ᵥ » x p)) q) (Set.Iio 0) s :=\n  by\n  ext y\n  simp_rw [Set.mem_setOf, Set.mem_image2, Set.mem_Iio, mem_coe]\n  constructor\n  · rw [s_opp_side_iff_exists_left hp]\n    rintro ⟨-, hy, p₂, hp₂, h | h | ⟨r₁, r₂, hr₁, hr₂, h⟩⟩\n    · rw [vsub_eq_zero_iff_eq] at h\n      exact false.elim (hx (h.symm ▸ hp))\n    · rw [vsub_eq_zero_iff_eq] at h\n      exact false.elim (hy (h ▸ hp₂))\n    · refine' ⟨-r₁ / r₂, p₂, div_neg_of_neg_of_pos (Left.neg_neg_iff.2 hr₁) hr₂, hp₂, _⟩\n      rw [div_eq_inv_mul, ← smul_smul, neg_smul, h, smul_neg, smul_smul, inv_mul_cancel hr₂.ne.symm, one_smul,\n        neg_vsub_eq_vsub_rev, vsub_vadd]\n  · rintro ⟨t, p', ht, hp', rfl⟩\n    exact s_opp_side_smul_vsub_vadd_right hx hp hp' ht\n#align set_of_s_opp_side_eq_image2 set_of_s_opp_side_eq_image2\n\n",
 "s_same_side_vadd_right_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr +ᵥ » -/\ntheorem s_same_side_vadd_right_iff {s : AffineSubspace R P} {x y : P} {v : V} (hv : v ∈ s.direction) :\n    s.s_same_side x («expr +ᵥ » v y) ↔ s.s_same_side x y := by\n  rw [s_same_side_comm, s_same_side_vadd_left_iff hv, s_same_side_comm]\n#align s_same_side_vadd_right_iff s_same_side_vadd_right_iff\n\n",
 "s_same_side_vadd_left_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr +ᵥ » -/\ntheorem s_same_side_vadd_left_iff {s : AffineSubspace R P} {x y : P} {v : V} (hv : v ∈ s.direction) :\n    s.s_same_side («expr +ᵥ » v x) y ↔ s.s_same_side x y := by\n  rw [s_same_side, s_same_side, w_same_side_vadd_left_iff hv, vadd_mem_iff_mem_of_mem_direction hv]\n#align s_same_side_vadd_left_iff s_same_side_vadd_left_iff\n\n",
 "s_same_side_smul_vsub_vadd_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr +ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\ntheorem s_same_side_smul_vsub_vadd_right {s : AffineSubspace R P} {x p₁ p₂ : P} (hx : x ∉ s) (hp₁ : p₁ ∈ s)\n    (hp₂ : p₂ ∈ s) {t : R} (ht : 0 < t) : s.s_same_side x («expr +ᵥ » («expr • » t («expr -ᵥ » x p₁)) p₂) :=\n  (s_same_side_smul_vsub_vadd_left hx hp₁ hp₂ ht).symm\n#align s_same_side_smul_vsub_vadd_right s_same_side_smul_vsub_vadd_right\n\n",
 "s_same_side_smul_vsub_vadd_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr +ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\ntheorem s_same_side_smul_vsub_vadd_left {s : AffineSubspace R P} {x p₁ p₂ : P} (hx : x ∉ s) (hp₁ : p₁ ∈ s)\n    (hp₂ : p₂ ∈ s) {t : R} (ht : 0 < t) : s.s_same_side («expr +ᵥ » («expr • » t («expr -ᵥ » x p₁)) p₂) x :=\n  by\n  refine' ⟨w_same_side_smul_vsub_vadd_left x hp₁ hp₂ ht.le, fun h => hx _, hx⟩\n  rwa [vadd_mem_iff_mem_direction _ hp₂, s.direction.smul_mem_iff ht.ne.symm, vsub_right_mem_direction_iff_mem hp₁] at h\n#align s_same_side_smul_vsub_vadd_left s_same_side_smul_vsub_vadd_left\n\n",
 "s_same_side_self_iff":
 "theorem s_same_side_self_iff {s : AffineSubspace R P} {x : P} : s.s_same_side x x ↔ (s : Set P).nonempty ∧ x ∉ s :=\n  ⟨fun ⟨h, hx, _⟩ => ⟨w_same_side_self_iff.1 h, hx⟩, fun ⟨h, hx⟩ => ⟨w_same_side_self_iff.2 h, hx, hx⟩⟩\n#align s_same_side_self_iff s_same_side_self_iff\n\n",
 "s_same_side_map_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ᵃ[ ] » -/\n@[simp]\ntheorem _root_.affine_equiv.s_same_side_map_iff {s : AffineSubspace R P} {x y : P} (f : «expr ≃ᵃ[ ] » P R P') :\n    (s.map ↑f).s_same_side (f x) (f y) ↔ s.s_same_side x y :=\n  (show function.injective f.to_affine_map from f.injective).s_same_side_map_iff\n#align affine_equiv.s_same_side_map_iff affine_equiv.s_same_side_map_iff\n\n",
 "s_same_side_line_map_right":
 "theorem s_same_side_line_map_right {s : AffineSubspace R P} {x y : P} (hx : x ∈ s) (hy : y ∉ s) {t : R} (ht : 0 < t) :\n    s.s_same_side y (lineMap x y t) :=\n  (s_same_side_line_map_left hx hy ht).symm\n#align s_same_side_line_map_right s_same_side_line_map_right\n\n",
 "s_same_side_line_map_left":
 "theorem s_same_side_line_map_left {s : AffineSubspace R P} {x y : P} (hx : x ∈ s) (hy : y ∉ s) {t : R} (ht : 0 < t) :\n    s.s_same_side (lineMap x y t) y :=\n  s_same_side_smul_vsub_vadd_left hy hx hx ht\n#align s_same_side_line_map_left s_same_side_line_map_left\n\n",
 "s_same_side_iff_exists_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\ntheorem s_same_side_iff_exists_right {s : AffineSubspace R P} {x y p₂ : P} (h : p₂ ∈ s) :\n    s.s_same_side x y ↔ x ∉ s ∧ y ∉ s ∧ ∃ p₁ ∈ s, SameRay R («expr -ᵥ » x p₁) («expr -ᵥ » y p₂) :=\n  by\n  rw [s_same_side_comm, s_same_side_iff_exists_left h, ← and_assoc', and_comm' (y ∉ s), and_assoc']\n  simp_rw [SameRay.sameRay_comm]\n#align s_same_side_iff_exists_right s_same_side_iff_exists_right\n\n",
 "s_same_side_iff_exists_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\ntheorem s_same_side_iff_exists_left {s : AffineSubspace R P} {x y p₁ : P} (h : p₁ ∈ s) :\n    s.s_same_side x y ↔ x ∉ s ∧ y ∉ s ∧ ∃ p₂ ∈ s, SameRay R («expr -ᵥ » x p₁) («expr -ᵥ » y p₂) :=\n  by\n  rw [s_same_side, and_comm', w_same_side_iff_exists_left h, and_assoc', and_congr_right_iff]\n  intro hx\n  rw [or_iff_right hx]\n#align s_same_side_iff_exists_left s_same_side_iff_exists_left\n\n",
 "s_same_side_comm":
 "theorem s_same_side_comm {s : AffineSubspace R P} {x y : P} : s.s_same_side x y ↔ s.s_same_side y x := by\n  rw [s_same_side, s_same_side, w_same_side_comm, and_comm' (x ∉ s)]\n#align s_same_side_comm s_same_side_comm\n\n",
 "s_opp_side_vadd_right_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr +ᵥ » -/\ntheorem s_opp_side_vadd_right_iff {s : AffineSubspace R P} {x y : P} {v : V} (hv : v ∈ s.direction) :\n    s.s_opp_side x («expr +ᵥ » v y) ↔ s.s_opp_side x y := by\n  rw [s_opp_side_comm, s_opp_side_vadd_left_iff hv, s_opp_side_comm]\n#align s_opp_side_vadd_right_iff s_opp_side_vadd_right_iff\n\n",
 "s_opp_side_vadd_left_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr +ᵥ » -/\ntheorem s_opp_side_vadd_left_iff {s : AffineSubspace R P} {x y : P} {v : V} (hv : v ∈ s.direction) :\n    s.s_opp_side («expr +ᵥ » v x) y ↔ s.s_opp_side x y := by\n  rw [s_opp_side, s_opp_side, w_opp_side_vadd_left_iff hv, vadd_mem_iff_mem_of_mem_direction hv]\n#align s_opp_side_vadd_left_iff s_opp_side_vadd_left_iff\n\n",
 "s_opp_side_smul_vsub_vadd_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr +ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\ntheorem s_opp_side_smul_vsub_vadd_right {s : AffineSubspace R P} {x p₁ p₂ : P} (hx : x ∉ s) (hp₁ : p₁ ∈ s)\n    (hp₂ : p₂ ∈ s) {t : R} (ht : t < 0) : s.s_opp_side x («expr +ᵥ » («expr • » t («expr -ᵥ » x p₁)) p₂) :=\n  (s_opp_side_smul_vsub_vadd_left hx hp₁ hp₂ ht).symm\n#align s_opp_side_smul_vsub_vadd_right s_opp_side_smul_vsub_vadd_right\n\n",
 "s_opp_side_smul_vsub_vadd_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr +ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\ntheorem s_opp_side_smul_vsub_vadd_left {s : AffineSubspace R P} {x p₁ p₂ : P} (hx : x ∉ s) (hp₁ : p₁ ∈ s) (hp₂ : p₂ ∈ s)\n    {t : R} (ht : t < 0) : s.s_opp_side («expr +ᵥ » («expr • » t («expr -ᵥ » x p₁)) p₂) x :=\n  by\n  refine' ⟨w_opp_side_smul_vsub_vadd_left x hp₁ hp₂ ht.le, fun h => hx _, hx⟩\n  rwa [vadd_mem_iff_mem_direction _ hp₂, s.direction.smul_mem_iff ht.ne, vsub_right_mem_direction_iff_mem hp₁] at h\n#align s_opp_side_smul_vsub_vadd_left s_opp_side_smul_vsub_vadd_left\n\n",
 "s_opp_side_point_reflection":
 "theorem s_opp_side_point_reflection {s : AffineSubspace R P} {x y : P} (hx : x ∈ s) (hy : y ∉ s) :\n    s.s_opp_side y (pointReflection R x y) :=\n  by\n  refine' (sbtw_point_reflection_of_ne R fun h => hy _).s_opp_side_of_not_mem_of_mem hy hx\n  rwa [← h]\n#align s_opp_side_point_reflection s_opp_side_point_reflection\n\n",
 "s_opp_side_of_not_mem_of_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\ntheorem _root_.sbtw.s_opp_side_of_not_mem_of_mem {s : AffineSubspace R P} {x y z : P} (h : sbtw R x y z) (hx : x ∉ s)\n    (hy : y ∈ s) : s.s_opp_side x z :=\n  by\n  refine' ⟨h.wbtw.w_opp_side₁₃ hy, hx, fun hz => hx _⟩\n  rcases h with ⟨⟨t, ⟨ht0, ht1⟩, rfl⟩, hyx, hyz⟩\n  rw [line_map_apply] at hy\n  have ht : t ≠ 1 := by\n    rintro rfl\n    simpa [line_map_apply] using hyz\n  have hy' := vsub_mem_direction hy hz\n  rw [vadd_vsub_assoc, ← neg_vsub_eq_vsub_rev z, ← neg_one_smul R («expr -ᵥ » z x), ← add_smul, ← sub_eq_add_neg,\n    s.direction.smul_mem_iff (sub_ne_zero_of_ne ht)] at hy'\n  rwa [vadd_mem_iff_mem_of_mem_direction (Submodule.smul_mem _ _ hy')] at hy\n#align sbtw.s_opp_side_of_not_mem_of_mem sbtw.s_opp_side_of_not_mem_of_mem\n\n",
 "s_opp_side_map_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ᵃ[ ] » -/\n@[simp]\ntheorem _root_.affine_equiv.s_opp_side_map_iff {s : AffineSubspace R P} {x y : P} (f : «expr ≃ᵃ[ ] » P R P') :\n    (s.map ↑f).s_opp_side (f x) (f y) ↔ s.s_opp_side x y :=\n  (show function.injective f.to_affine_map from f.injective).s_opp_side_map_iff\n#align affine_equiv.s_opp_side_map_iff affine_equiv.s_opp_side_map_iff\n\n",
 "s_opp_side_line_map_right":
 "theorem s_opp_side_line_map_right {s : AffineSubspace R P} {x y : P} (hx : x ∈ s) (hy : y ∉ s) {t : R} (ht : t < 0) :\n    s.s_opp_side y (lineMap x y t) :=\n  (s_opp_side_line_map_left hx hy ht).symm\n#align s_opp_side_line_map_right s_opp_side_line_map_right\n\n",
 "s_opp_side_line_map_left":
 "theorem s_opp_side_line_map_left {s : AffineSubspace R P} {x y : P} (hx : x ∈ s) (hy : y ∉ s) {t : R} (ht : t < 0) :\n    s.s_opp_side (lineMap x y t) y :=\n  s_opp_side_smul_vsub_vadd_left hy hx hx ht\n#align s_opp_side_line_map_left s_opp_side_line_map_left\n\n",
 "s_opp_side_iff_exists_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\ntheorem s_opp_side_iff_exists_right {s : AffineSubspace R P} {x y p₂ : P} (h : p₂ ∈ s) :\n    s.s_opp_side x y ↔ x ∉ s ∧ y ∉ s ∧ ∃ p₁ ∈ s, SameRay R («expr -ᵥ » x p₁) («expr -ᵥ » p₂ y) :=\n  by\n  rw [s_opp_side, and_comm', w_opp_side_iff_exists_right h, and_assoc', and_congr_right_iff, and_congr_right_iff]\n  rintro hx hy\n  rw [or_iff_right hy]\n#align s_opp_side_iff_exists_right s_opp_side_iff_exists_right\n\n",
 "s_opp_side_iff_exists_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\ntheorem s_opp_side_iff_exists_left {s : AffineSubspace R P} {x y p₁ : P} (h : p₁ ∈ s) :\n    s.s_opp_side x y ↔ x ∉ s ∧ y ∉ s ∧ ∃ p₂ ∈ s, SameRay R («expr -ᵥ » x p₁) («expr -ᵥ » p₂ y) :=\n  by\n  rw [s_opp_side, and_comm', w_opp_side_iff_exists_left h, and_assoc', and_congr_right_iff]\n  intro hx\n  rw [or_iff_right hx]\n#align s_opp_side_iff_exists_left s_opp_side_iff_exists_left\n\n",
 "s_opp_side_comm":
 "theorem s_opp_side_comm {s : AffineSubspace R P} {x y : P} : s.s_opp_side x y ↔ s.s_opp_side y x := by\n  rw [s_opp_side, s_opp_side, w_opp_side_comm, and_comm' (x ∉ s)]\n#align s_opp_side_comm s_opp_side_comm\n\n",
 "right_not_mem":
 "theorem s_opp_side.right_not_mem {s : AffineSubspace R P} {x y : P} (h : s.s_opp_side x y) : y ∉ s :=\n  h.2.2\n#align s_opp_side.right_not_mem s_opp_side.right_not_mem\n\n",
 "not_w_same_side_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem not_w_same_side_bot (x y : P) : ¬(«expr⊥» : AffineSubspace R P).w_same_side x y := by\n  simp [w_same_side, not_mem_bot]\n#align not_w_same_side_bot not_w_same_side_bot\n\n",
 "not_w_same_side":
 "theorem s_opp_side.not_w_same_side {s : AffineSubspace R P} {x y : P} (h : s.s_opp_side x y) : ¬s.w_same_side x y :=\n  fun hs => hs.not_s_opp_side h\n#align s_opp_side.not_w_same_side s_opp_side.not_w_same_side\n\n",
 "not_w_opp_side_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem not_w_opp_side_bot (x y : P) : ¬(«expr⊥» : AffineSubspace R P).w_opp_side x y := by\n  simp [w_opp_side, not_mem_bot]\n#align not_w_opp_side_bot not_w_opp_side_bot\n\n",
 "not_w_opp_side":
 "theorem s_same_side.not_w_opp_side {s : AffineSubspace R P} {x y : P} (h : s.s_same_side x y) : ¬s.w_opp_side x y :=\n  by\n  intro ho\n  have hxy := w_same_side_and_w_opp_side_iff.1 ⟨h.1, ho⟩\n  rcases hxy with (hx | hy)\n  · exact h.2.1 hx\n  · exact h.2.2 hy\n#align s_same_side.not_w_opp_side s_same_side.not_w_opp_side\n\n",
 "not_s_same_side_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem not_s_same_side_bot (x y : P) : ¬(«expr⊥» : AffineSubspace R P).s_same_side x y := fun h =>\n  not_w_same_side_bot x y h.w_same_side\n#align not_s_same_side_bot not_s_same_side_bot\n\n",
 "not_s_same_side":
 "theorem s_opp_side.not_s_same_side {s : AffineSubspace R P} {x y : P} (h : s.s_opp_side x y) : ¬s.s_same_side x y :=\n  fun hs => h.not_w_same_side hs.1\n#align s_opp_side.not_s_same_side s_opp_side.not_s_same_side\n\n",
 "not_s_opp_side_self":
 "theorem not_s_opp_side_self (s : AffineSubspace R P) (x : P) : ¬s.s_opp_side x x := by simp [s_opp_side]\n#align not_s_opp_side_self not_s_opp_side_self\n\n",
 "not_s_opp_side_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem not_s_opp_side_bot (x y : P) : ¬(«expr⊥» : AffineSubspace R P).s_opp_side x y := fun h =>\n  not_w_opp_side_bot x y h.w_opp_side\n#align not_s_opp_side_bot not_s_opp_side_bot\n\n",
 "not_s_opp_side":
 "theorem s_same_side.not_s_opp_side {s : AffineSubspace R P} {x y : P} (h : s.s_same_side x y) : ¬s.s_opp_side x y :=\n  fun ho => h.not_w_opp_side ho.1\n#align s_same_side.not_s_opp_side s_same_side.not_s_opp_side\n\n",
 "nonempty":
 "theorem s_opp_side.nonempty {s : AffineSubspace R P} {x y : P} (h : s.s_opp_side x y) : (s : Set P).nonempty :=\n  ⟨h.1.some, h.1.some_spec.some⟩\n#align s_opp_side.nonempty s_opp_side.nonempty\n\n",
 "map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ᵃ[ ] » -/\ntheorem w_opp_side.map {s : AffineSubspace R P} {x y : P} (h : s.w_opp_side x y) (f : «expr →ᵃ[ ] » P R P') :\n    (s.map f).w_opp_side (f x) (f y) := by\n  rcases h with ⟨p₁, hp₁, p₂, hp₂, h⟩\n  refine' ⟨f p₁, mem_map_of_mem f hp₁, f p₂, mem_map_of_mem f hp₂, _⟩\n  simp_rw [← linear_map_vsub]\n  exact h.map f.linear\n#align w_opp_side.map w_opp_side.map\n\n",
 "left_not_mem":
 "theorem s_opp_side.left_not_mem {s : AffineSubspace R P} {x y : P} (h : s.s_opp_side x y) : x ∉ s :=\n  h.2.1\n#align s_opp_side.left_not_mem s_opp_side.left_not_mem\n\n",
 "is_preconnected_set_of_w_same_side":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem is_preconnected_set_of_w_same_side (s : AffineSubspace (exprℝ) P) (x : P) :\n    IsPreconnected { y | s.w_same_side x y } :=\n  by\n  rcases Set.eq_empty_or_nonempty (s : Set P) with (h | h)\n  · convert isPreconnected_empty\n    rw [coe_eq_bot_iff] at h\n    simp only [h, not_w_same_side_bot]\n    rfl\n  · exact (is_connected_set_of_w_same_side x h).is_preconnected\n#align is_preconnected_set_of_w_same_side is_preconnected_set_of_w_same_side\n\n",
 "is_preconnected_set_of_w_opp_side":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem is_preconnected_set_of_w_opp_side (s : AffineSubspace (exprℝ) P) (x : P) :\n    IsPreconnected { y | s.w_opp_side x y } :=\n  by\n  rcases Set.eq_empty_or_nonempty (s : Set P) with (h | h)\n  · convert isPreconnected_empty\n    rw [coe_eq_bot_iff] at h\n    simp only [h, not_w_opp_side_bot]\n    rfl\n  · exact (is_connected_set_of_w_opp_side x h).is_preconnected\n#align is_preconnected_set_of_w_opp_side is_preconnected_set_of_w_opp_side\n\n",
 "is_preconnected_set_of_s_same_side":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem is_preconnected_set_of_s_same_side (s : AffineSubspace (exprℝ) P) (x : P) :\n    IsPreconnected { y | s.s_same_side x y } :=\n  by\n  rcases Set.eq_empty_or_nonempty (s : Set P) with (h | h)\n  · convert isPreconnected_empty\n    rw [coe_eq_bot_iff] at h\n    simp only [h, not_s_same_side_bot]\n    rfl\n  · by_cases hx : x ∈ s\n    · convert isPreconnected_empty\n      simp only [hx, s_same_side, not_true, false_and_iff, and_false_iff]\n      rfl\n    · exact (is_connected_set_of_s_same_side hx h).is_preconnected\n#align is_preconnected_set_of_s_same_side is_preconnected_set_of_s_same_side\n\n",
 "is_preconnected_set_of_s_opp_side":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem is_preconnected_set_of_s_opp_side (s : AffineSubspace (exprℝ) P) (x : P) :\n    IsPreconnected { y | s.s_opp_side x y } :=\n  by\n  rcases Set.eq_empty_or_nonempty (s : Set P) with (h | h)\n  · convert isPreconnected_empty\n    rw [coe_eq_bot_iff] at h\n    simp only [h, not_s_opp_side_bot]\n    rfl\n  · by_cases hx : x ∈ s\n    · convert isPreconnected_empty\n      simp only [hx, s_opp_side, not_true, false_and_iff, and_false_iff]\n      rfl\n    · exact (is_connected_set_of_s_opp_side hx h).is_preconnected\n#align is_preconnected_set_of_s_opp_side is_preconnected_set_of_s_opp_side\n\n",
 "is_connected_set_of_w_same_side":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem is_connected_set_of_w_same_side {s : AffineSubspace (exprℝ) P} (x : P) (h : (s : Set P).nonempty) :\n    IsConnected { y | s.w_same_side x y } := by\n  obtain ⟨p, hp⟩ := h\n  haveI : Nonempty s := ⟨⟨p, hp⟩⟩\n  by_cases hx : x ∈ s\n  · convert isConnected_univ\n    · simp [w_same_side_of_left_mem, hx]\n    · exact AddTorsor.connectedSpace V P\n  · rw [set_of_w_same_side_eq_image2 hx hp, ← Set.image_prod]\n    refine'\n      (is_connected_Ici.prod (isConnected_iff_connectedSpace.2 _)).image _\n        ((continuous_fst.smul continuous_const).vadd continuous_snd).continuous_on\n    convert AddTorsor.connectedSpace s.direction s\n#align is_connected_set_of_w_same_side is_connected_set_of_w_same_side\n\n",
 "is_connected_set_of_w_opp_side":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem is_connected_set_of_w_opp_side {s : AffineSubspace (exprℝ) P} (x : P) (h : (s : Set P).nonempty) :\n    IsConnected { y | s.w_opp_side x y } := by\n  obtain ⟨p, hp⟩ := h\n  haveI : Nonempty s := ⟨⟨p, hp⟩⟩\n  by_cases hx : x ∈ s\n  · convert isConnected_univ\n    · simp [w_opp_side_of_left_mem, hx]\n    · exact AddTorsor.connectedSpace V P\n  · rw [set_of_w_opp_side_eq_image2 hx hp, ← Set.image_prod]\n    refine'\n      (is_connected_Iic.prod (isConnected_iff_connectedSpace.2 _)).image _\n        ((continuous_fst.smul continuous_const).vadd continuous_snd).continuous_on\n    convert AddTorsor.connectedSpace s.direction s\n#align is_connected_set_of_w_opp_side is_connected_set_of_w_opp_side\n\n",
 "is_connected_set_of_s_same_side":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem is_connected_set_of_s_same_side {s : AffineSubspace (exprℝ) P} {x : P} (hx : x ∉ s) (h : (s : Set P).nonempty) :\n    IsConnected { y | s.s_same_side x y } := by\n  obtain ⟨p, hp⟩ := h\n  haveI : Nonempty s := ⟨⟨p, hp⟩⟩\n  rw [set_of_s_same_side_eq_image2 hx hp, ← Set.image_prod]\n  refine'\n    (is_connected_Ioi.prod (isConnected_iff_connectedSpace.2 _)).image _\n      ((continuous_fst.smul continuous_const).vadd continuous_snd).continuous_on\n  convert AddTorsor.connectedSpace s.direction s\n#align is_connected_set_of_s_same_side is_connected_set_of_s_same_side\n\n",
 "is_connected_set_of_s_opp_side":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem is_connected_set_of_s_opp_side {s : AffineSubspace (exprℝ) P} {x : P} (hx : x ∉ s) (h : (s : Set P).nonempty) :\n    IsConnected { y | s.s_opp_side x y } := by\n  obtain ⟨p, hp⟩ := h\n  haveI : Nonempty s := ⟨⟨p, hp⟩⟩\n  rw [set_of_s_opp_side_eq_image2 hx hp, ← Set.image_prod]\n  refine'\n    (is_connected_Iio.prod (isConnected_iff_connectedSpace.2 _)).image _\n      ((continuous_fst.smul continuous_const).vadd continuous_snd).continuous_on\n  convert AddTorsor.connectedSpace s.direction s\n#align is_connected_set_of_s_opp_side is_connected_set_of_s_opp_side\n\n",
 "exists_sbtw":
 "theorem s_opp_side.exists_sbtw {s : AffineSubspace R P} {x y : P} (h : s.s_opp_side x y) : ∃ p ∈ s, sbtw R x p y :=\n  by\n  obtain ⟨p, hp, hw⟩ := w_opp_side_iff_exists_wbtw.1 h.w_opp_side\n  refine' ⟨p, hp, hw, _, _⟩\n  · rintro rfl\n    exact h.2.1 hp\n  · rintro rfl\n    exact h.2.2 hp\n#align s_opp_side.exists_sbtw s_opp_side.exists_sbtw\n\n"}