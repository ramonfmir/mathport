{"not_disjoint_segment_convexHull_triple":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr![ ,]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr![ ,]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr![ ,]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr![ ,]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print not_disjoint_segment_convexHull_triple /-\n/-\nCopyright (c) 2022 Yaël Dillies. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yaël Dillies\n-/\n/-- In a tetrahedron with vertices `x`, `y`, `p`, `q`, any segment `[u, v]` joining the opposite\nedges `[x, p]` and `[y, q]` passes through any triangle of vertices `p`, `q`, `z` where\n`z ∈ [x, y]`. -/\ntheorem not_disjoint_segment_convexHull_triple {p q u v x y z : E} (hz : z ∈ segment 𝕜 x y) (hu : u ∈ segment 𝕜 x p)\n    (hv : v ∈ segment 𝕜 y q) : ¬Disjoint (segment 𝕜 u v) (convexHull 𝕜 {p, q, z}) :=\n  by\n  rw [not_disjoint_iff]\n  obtain ⟨az, bz, haz, hbz, habz, rfl⟩ := hz\n  obtain rfl | haz' := haz.eq_or_lt\n  · rw [zero_add] at habz\n    rw [zero_smul, zero_add, habz, one_smul]\n    refine' ⟨v, right_mem_segment _ _ _, segment_subset_convexHull _ _ hv⟩ <;> simp\n  obtain ⟨av, bv, hav, hbv, habv, rfl⟩ := hv\n  obtain rfl | hav' := hav.eq_or_lt\n  · rw [zero_add] at habv\n    rw [zero_smul, zero_add, habv, one_smul]\n    exact ⟨q, right_mem_segment _ _ _, subset_convexHull _ _ <| by simp⟩\n  obtain ⟨au, bu, hau, hbu, habu, rfl⟩ := hu\n  have hab : 0 < az * av + bz * au := add_pos_of_pos_of_nonneg (mul_pos haz' hav') (mul_nonneg hbz hau)\n  refine'\n    ⟨«expr • » (az * av / (az * av + bz * au)) («expr • » au x + «expr • » bu p) +\n        «expr • » (bz * au / (az * av + bz * au)) («expr • » av y + «expr • » bv q),\n      ⟨_, _, _, _, _, rfl⟩, _⟩\n  · exact div_nonneg (mul_nonneg haz hav) hab.le\n  · exact div_nonneg (mul_nonneg hbz hau) hab.le\n  · rw [← add_div, div_self hab.ne']\n  rw [smul_add, smul_add, add_add_add_comm, add_comm, ← mul_smul, ← mul_smul]\n  classical\n    let w : Fin 3 → 𝕜 :=\n      «expr![ ,]» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr![ ,]»\"\n    let z : Fin 3 → E :=\n      «expr![ ,]» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr![ ,]»\"\n    have hw₀ : ∀ i, 0 ≤ w i := by\n      rintro i\n      fin_cases i\n      · exact mul_nonneg (mul_nonneg haz hav) hbu\n      · exact mul_nonneg (mul_nonneg hbz hau) hbv\n      · exact mul_nonneg hau hav\n    have hw :\n      finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\" (w i) =\n        az * av + bz * au :=\n      by\n      trans az * av * bu + (bz * au * bv + au * av)\n      · simp [w, Fin.sum_univ_succ, Fin.sum_univ_zero]\n      rw [← one_mul (au * av), ← habz, add_mul, ← add_assoc, add_add_add_comm, mul_assoc, ← mul_add, mul_assoc, ←\n        mul_add, mul_comm av, ← add_mul, ← mul_add, add_comm bu, add_comm bv, habu, habv, one_mul, mul_one]\n    have hz : ∀ i, z i ∈ ({p, q, «expr • » az x + «expr • » bz y} : Set E) :=\n      by\n      rintro i\n      fin_cases i <;> simp [z]\n    convert Finset.centerMass_mem_convexHull (Finset.univ : Finset (Fin 3)) (fun i _ => hw₀ i) (by rwa [hw]) fun i _ =>\n        hz i\n    rw [Finset.centerMass]\n    simp_rw [div_eq_inv_mul, hw, mul_assoc, mul_smul (az * av + bz * au)⁻¹, ← smul_add, add_assoc, ← mul_assoc]\n    congr 3\n    rw [← mul_smul, ← mul_rotate, mul_right_comm, mul_smul, ← mul_smul _ av, mul_rotate, mul_smul _ bz, ← smul_add]\n    simp only [list.map, List.pmap, Nat.add_def, add_zero, Fin.mk_bit0, Fin.mk_one, List.foldr_cons, List.foldr_nil]\n    rfl\n#align not_disjoint_segment_convex_hull_triple not_disjoint_segment_convexHull_triple\n-/\n\n",
 "exists_convex_convex_compl_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n#print exists_convex_convex_compl_subset /-\n/-- **Stone's Separation Theorem** -/\ntheorem exists_convex_convex_compl_subset (hs : Convex 𝕜 s) (ht : Convex 𝕜 t) (hst : Disjoint s t) :\n    ∃ C : Set E, Convex 𝕜 C ∧ Convex 𝕜 («expr ᶜ» C) ∧ s ⊆ C ∧ t ⊆ «expr ᶜ» C :=\n  by\n  let S : Set (Set E) := { C | Convex 𝕜 C ∧ Disjoint C t }\n  obtain ⟨C, hC, hsC, hCmax⟩ :=\n    zorn_subset_nonempty S\n      (fun c hcS hc ⟨t, ht⟩ =>\n        ⟨⋃₀ c, ⟨hc.directed_on.convex_sUnion fun s hs => (hcS hs).1, disjoint_sUnion_left.2 fun c hc => (hcS hc).2⟩,\n          fun s => subset_sUnion_of_mem⟩)\n      s ⟨hs, hst⟩\n  refine' ⟨C, hC.1, convex_iff_segment_subset.2 fun x hx y hy z hz hzC => _, hsC, hC.2.subset_compl_left⟩\n  suffices h : ∀ c ∈ «expr ᶜ» C, ∃ a ∈ C, (segment 𝕜 c a ∩ t).nonempty\n  · obtain ⟨p, hp, u, hu, hut⟩ := h x hx\n    obtain ⟨q, hq, v, hv, hvt⟩ := h y hy\n    refine'\n      not_disjoint_segment_convexHull_triple hz hu hv\n        (hC.2.symm.mono (ht.segment_subset hut hvt) <| convexHull_min _ hC.1)\n    simp [insert_subset, hp, hq, singleton_subset_iff.2 hzC]\n  rintro c hc\n  by_contra' h\n  suffices h : Disjoint (convexHull 𝕜 (insert c C)) t\n  · rw [← hCmax _ ⟨convex_convexHull _ _, h⟩ ((subset_insert _ _).trans <| subset_convexHull _ _)] at hc\n    exact hc (subset_convexHull _ _ <| mem_insert _ _)\n  rw [convexHull_insert ⟨z, hzC⟩, convexJoin_singleton_left]\n  refine' disjoint_Union₂_left.2 fun a ha => disjoint_iff_inf_le.mpr fun b hb => h a _ ⟨b, hb⟩\n  rwa [← hC.1.convex_hull_eq]\n#align exists_convex_convex_compl_subset exists_convex_convex_compl_subset\n-/\n\n"}