{"not_disjoint_segment_convexHull_triple":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr![ ,]Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«expr![ ,]Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr![ ,]Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«expr![ ,]Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n#print not_disjoint_segment_convexHull_triple /-\n/-\nCopyright (c) 2022 YaÃ«l Dillies. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: YaÃ«l Dillies\n-/\n/-- In a tetrahedron with vertices `x`, `y`, `p`, `q`, any segment `[u, v]` joining the opposite\nedges `[x, p]` and `[y, q]` passes through any triangle of vertices `p`, `q`, `z` where\n`z âˆˆ [x, y]`. -/\ntheorem not_disjoint_segment_convexHull_triple {p q u v x y z : E} (hz : z âˆˆ segment ğ•œ x y) (hu : u âˆˆ segment ğ•œ x p)\n    (hv : v âˆˆ segment ğ•œ y q) : Â¬Disjoint (segment ğ•œ u v) (convexHull ğ•œ {p, q, z}) :=\n  by\n  rw [not_disjoint_iff]\n  obtain âŸ¨az, bz, haz, hbz, habz, rflâŸ© := hz\n  obtain rfl | haz' := haz.eq_or_lt\n  Â· rw [zero_add] at habz\n    rw [zero_smul, zero_add, habz, one_smul]\n    refine' âŸ¨v, right_mem_segment _ _ _, segment_subset_convexHull _ _ hvâŸ© <;> simp\n  obtain âŸ¨av, bv, hav, hbv, habv, rflâŸ© := hv\n  obtain rfl | hav' := hav.eq_or_lt\n  Â· rw [zero_add] at habv\n    rw [zero_smul, zero_add, habv, one_smul]\n    exact âŸ¨q, right_mem_segment _ _ _, subset_convexHull _ _ <| by simpâŸ©\n  obtain âŸ¨au, bu, hau, hbu, habu, rflâŸ© := hu\n  have hab : 0 < az * av + bz * au := add_pos_of_pos_of_nonneg (mul_pos haz' hav') (mul_nonneg hbz hau)\n  refine'\n    âŸ¨Â«expr â€¢ Â» (az * av / (az * av + bz * au)) (Â«expr â€¢ Â» au x + Â«expr â€¢ Â» bu p) +\n        Â«expr â€¢ Â» (bz * au / (az * av + bz * au)) (Â«expr â€¢ Â» av y + Â«expr â€¢ Â» bv q),\n      âŸ¨_, _, _, _, _, rflâŸ©, _âŸ©\n  Â· exact div_nonneg (mul_nonneg haz hav) hab.le\n  Â· exact div_nonneg (mul_nonneg hbz hau) hab.le\n  Â· rw [â† add_div, div_self hab.ne']\n  rw [smul_add, smul_add, add_add_add_comm, add_comm, â† mul_smul, â† mul_smul]\n  classical\n    let w : Fin 3 â†’ ğ•œ :=\n      Â«expr![ ,]Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«expr![ ,]Â»\"\n    let z : Fin 3 â†’ E :=\n      Â«expr![ ,]Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«expr![ ,]Â»\"\n    have hwâ‚€ : âˆ€ i, 0 â‰¤ w i := by\n      rintro i\n      fin_cases i\n      Â· exact mul_nonneg (mul_nonneg haz hav) hbu\n      Â· exact mul_nonneg (mul_nonneg hbz hau) hbv\n      Â· exact mul_nonneg hau hav\n    have hw :\n      finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\" (w i) =\n        az * av + bz * au :=\n      by\n      trans az * av * bu + (bz * au * bv + au * av)\n      Â· simp [w, Fin.sum_univ_succ, Fin.sum_univ_zero]\n      rw [â† one_mul (au * av), â† habz, add_mul, â† add_assoc, add_add_add_comm, mul_assoc, â† mul_add, mul_assoc, â†\n        mul_add, mul_comm av, â† add_mul, â† mul_add, add_comm bu, add_comm bv, habu, habv, one_mul, mul_one]\n    have hz : âˆ€ i, z i âˆˆ ({p, q, Â«expr â€¢ Â» az x + Â«expr â€¢ Â» bz y} : Set E) :=\n      by\n      rintro i\n      fin_cases i <;> simp [z]\n    convert Finset.centerMass_mem_convexHull (Finset.univ : Finset (Fin 3)) (fun i _ => hwâ‚€ i) (by rwa [hw]) fun i _ =>\n        hz i\n    rw [Finset.centerMass]\n    simp_rw [div_eq_inv_mul, hw, mul_assoc, mul_smul (az * av + bz * au)â»Â¹, â† smul_add, add_assoc, â† mul_assoc]\n    congr 3\n    rw [â† mul_smul, â† mul_rotate, mul_right_comm, mul_smul, â† mul_smul _ av, mul_rotate, mul_smul _ bz, â† smul_add]\n    simp only [list.map, List.pmap, Nat.add_def, add_zero, Fin.mk_bit0, Fin.mk_one, List.foldr_cons, List.foldr_nil]\n    rfl\n#align not_disjoint_segment_convex_hull_triple not_disjoint_segment_convexHull_triple\n-/\n\n",
 "exists_convex_convex_compl_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á¶œÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á¶œÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á¶œÂ» -/\n#print exists_convex_convex_compl_subset /-\n/-- **Stone's Separation Theorem** -/\ntheorem exists_convex_convex_compl_subset (hs : Convex ğ•œ s) (ht : Convex ğ•œ t) (hst : Disjoint s t) :\n    âˆƒ C : Set E, Convex ğ•œ C âˆ§ Convex ğ•œ (Â«expr á¶œÂ» C) âˆ§ s âŠ† C âˆ§ t âŠ† Â«expr á¶œÂ» C :=\n  by\n  let S : Set (Set E) := { C | Convex ğ•œ C âˆ§ Disjoint C t }\n  obtain âŸ¨C, hC, hsC, hCmaxâŸ© :=\n    zorn_subset_nonempty S\n      (fun c hcS hc âŸ¨t, htâŸ© =>\n        âŸ¨â‹ƒâ‚€ c, âŸ¨hc.directed_on.convex_sUnion fun s hs => (hcS hs).1, disjoint_sUnion_left.2 fun c hc => (hcS hc).2âŸ©,\n          fun s => subset_sUnion_of_memâŸ©)\n      s âŸ¨hs, hstâŸ©\n  refine' âŸ¨C, hC.1, convex_iff_segment_subset.2 fun x hx y hy z hz hzC => _, hsC, hC.2.subset_compl_leftâŸ©\n  suffices h : âˆ€ c âˆˆ Â«expr á¶œÂ» C, âˆƒ a âˆˆ C, (segment ğ•œ c a âˆ© t).nonempty\n  Â· obtain âŸ¨p, hp, u, hu, hutâŸ© := h x hx\n    obtain âŸ¨q, hq, v, hv, hvtâŸ© := h y hy\n    refine'\n      not_disjoint_segment_convexHull_triple hz hu hv\n        (hC.2.symm.mono (ht.segment_subset hut hvt) <| convexHull_min _ hC.1)\n    simp [insert_subset, hp, hq, singleton_subset_iff.2 hzC]\n  rintro c hc\n  by_contra' h\n  suffices h : Disjoint (convexHull ğ•œ (insert c C)) t\n  Â· rw [â† hCmax _ âŸ¨convex_convexHull _ _, hâŸ© ((subset_insert _ _).trans <| subset_convexHull _ _)] at hc\n    exact hc (subset_convexHull _ _ <| mem_insert _ _)\n  rw [convexHull_insert âŸ¨z, hzCâŸ©, convexJoin_singleton_left]\n  refine' disjoint_Unionâ‚‚_left.2 fun a ha => disjoint_iff_inf_le.mpr fun b hb => h a _ âŸ¨b, hbâŸ©\n  rwa [â† hC.1.convex_hull_eq]\n#align exists_convex_convex_compl_subset exists_convex_convex_compl_subset\n-/\n\n"}