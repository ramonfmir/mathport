{"unique_unit_speed_on_Icc_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/-- If both `f` and `f ∘ φ` have unit speed (on `Icc 0 t` and `Icc 0 s` respectively)\nand `φ` monotonically maps `Icc 0 s` onto `Icc 0 t`, then `φ` is the identity on `Icc 0 s`\n-/\ntheorem unique_unit_speed_on_Icc_zero {s t : exprℝ} (hs : 0 ≤ s) (ht : 0 ≤ t) {φ : exprℝ → exprℝ}\n    (φm : MonotoneOn φ <| Icc 0 s) (φst : «expr '' » φ (Icc 0 s) = Icc 0 t) (hfφ : has_unit_speed_on (f ∘ φ) (Icc 0 s))\n    (hf : has_unit_speed_on f (Icc 0 t)) : EqOn φ id (Icc 0 s) :=\n  by\n  rw [← φst] at hf\n  convert unique_unit_speed φm hfφ hf ⟨le_rfl, hs⟩\n  have : φ 0 = 0 := by\n    obtain ⟨x, xs, hx⟩ := φst.rec_on (surj_on_image φ (Icc 0 s)) ⟨le_rfl, ht⟩\n    exact le_antisymm (hx.rec_on (φm ⟨le_rfl, hs⟩ xs xs.1)) (φst.rec_on (maps_to_image φ (Icc 0 s)) ⟨le_rfl, hs⟩).1\n  simp only [tsub_zero, this, add_zero]\n  rfl\n#align unique_unit_speed_on_Icc_zero unique_unit_speed_on_Icc_zero\n\n",
 "unique_unit_speed":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- If both `f` and `f ∘ φ` have unit speed (on `t` and `s` respectively) and `φ`\nmonotonically maps `s` onto `t`, then `φ` is just a translation (on `s`).\n-/\ntheorem unique_unit_speed {φ : exprℝ → exprℝ} (φm : MonotoneOn φ s) (hfφ : has_unit_speed_on (f ∘ φ) s)\n    (hf : has_unit_speed_on f («expr '' » φ s)) ⦃x : exprℝ⦄ (xs : x ∈ s) : EqOn φ (fun y => y - x + φ x) s :=\n  by\n  dsimp only [has_unit_speed_on] at hf hfφ\n  convert has_constant_speed_on_with.ratio one_ne_zero φm hfφ hf xs\n  simp only [Nonneg.coe_one, div_self, ne.def, one_ne_zero, not_false_iff, one_mul]\n#align unique_unit_speed unique_unit_speed\n\n",
 "union":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem has_unit_speed_on.union {t : Set (exprℝ)} {x : exprℝ} (hfs : has_unit_speed_on f s)\n    (hft : has_unit_speed_on f t) (hs : IsGreatest s x) (ht : IsLeast t x) : has_unit_speed_on f (s ∪ t) :=\n  has_constant_speed_on_with.union hfs hft hs ht\n#align has_unit_speed_on.union has_unit_speed_on.union\n\n",
 "ratio":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem has_constant_speed_on_with.ratio {l' : nnreal} (hl' : l' ≠ 0) {φ : exprℝ → exprℝ} (φm : MonotoneOn φ s)\n    (hfφ : has_constant_speed_on_with (f ∘ φ) s l) (hf : has_constant_speed_on_with f («expr '' » φ s) l') ⦃x : exprℝ⦄\n    (xs : x ∈ s) : EqOn φ (fun y => l / l' * (y - x) + φ x) s :=\n  by\n  rintro y ys\n  rw [← sub_eq_iff_eq_add, mul_comm, ← mul_div_assoc, eq_div_iff (nnreal.coe_ne_zero.mpr hl')]\n  rw [has_constant_speed_on_with_iff_variation_on_from_to_eq] at hf\n  rw [has_constant_speed_on_with_iff_variation_on_from_to_eq] at hfφ\n  symm\n  calc\n    (y - x) * l = l * (y - x) := by rw [mul_comm]\n    _ = variation_on_from_to (f ∘ φ) s x y := (hfφ.2 xs ys).symm\n    _ = variation_on_from_to f («expr '' » φ s) (φ x) (φ y) :=\n      (variation_on_from_to.comp_eq_of_monotone_on f φ φm xs ys)\n    _ = l' * (φ y - φ x) := (hf.2 ⟨x, xs, rfl⟩ ⟨y, ys, rfl⟩)\n    _ = (φ y - φ x) * l' := by rw [mul_comm]\n    \n#align has_constant_speed_on_with.ratio has_constant_speed_on_with.ratio\n\n",
 "has_unit_speed_natural_parameterization":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem has_unit_speed_natural_parameterization (f : α → E) {s : Set α} (hf : has_locally_bounded_variation_on f s)\n    {a : α} (as : a ∈ s) :\n    has_unit_speed_on (natural_parameterization f s a) («expr '' » (variation_on_from_to f s a) s) :=\n  by\n  dsimp only [has_unit_speed_on]\n  rw [has_constant_speed_on_with_iff_ordered]\n  rintro _ ⟨b, bs, rfl⟩ _ ⟨c, cs, rfl⟩ h\n  rcases le_total c b with (cb | bc)\n  · rw [NNReal.coe_one, one_mul, le_antisymm h (variation_on_from_to.monotone_on hf as cs bs cb), sub_self,\n      ENNReal.ofReal_zero, Icc_self, evariation_on.subsingleton]\n    exact fun x hx y hy => hx.2.trans hy.2.symm\n  · rw [NNReal.coe_one, one_mul, sub_eq_add_neg, variation_on_from_to.eq_neg_swap, neg_neg, add_comm,\n      variation_on_from_to.add hf bs as cs, ← variation_on_from_to.eq_neg_swap f]\n    rw [←\n      evariation_on.comp_inter_Icc_eq_of_monotone_on (natural_parameterization f s a) _\n        (variation_on_from_to.monotone_on hf as) bs cs]\n    rw [@evariation_on.eq_of_edist_zero_on _ _ _ _ _ f]\n    · rw [variation_on_from_to.eq_of_le _ _ bc, ENNReal.ofReal_toReal (hf b c bs cs)]\n    · rintro x ⟨xs, bx, xc⟩\n      exact edist_natural_parameterization_eq_zero hf as xs\n#align has_unit_speed_natural_parameterization has_unit_speed_natural_parameterization\n\n",
 "has_locally_bounded_variation_on":
 "/-\nCopyright (c) 2023 Rémi Bottinelli. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Rémi Bottinelli\n-/\ntheorem has_constant_speed_on_with.has_locally_bounded_variation_on (h : has_constant_speed_on_with f s l) :\n    has_locally_bounded_variation_on f s := fun x y hx hy => by\n  simp only [has_bounded_variation_on, h hx hy, ne.def, ENNReal.ofReal_ne_top, not_false_iff]\n#align has_constant_speed_on_with.has_locally_bounded_variation_on has_constant_speed_on_with.has_locally_bounded_variation_on\n\n",
 "has_constant_speed_on_with_zero_iff":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (x y «expr ∈ » s) -/\ntheorem has_constant_speed_on_with_zero_iff :\n    has_constant_speed_on_with f s 0 ↔ ∀ (x) (_ : x ∈ s) (y) (_ : y ∈ s), edist (f x) (f y) = 0 :=\n  by\n  dsimp [has_constant_speed_on_with]\n  simp only [MulZeroClass.zero_mul, ENNReal.ofReal_zero, ← evariation_on.eq_zero_iff]\n  constructor\n  · by_contra'\n    obtain ⟨h, hfs⟩ := this\n    simp_rw [evariation_on.eq_zero_iff] at hfs h\n    push_neg  at hfs\n    obtain ⟨x, xs, y, ys, hxy⟩ := hfs\n    rcases le_total x y with (xy | yx)\n    · exact hxy (h xs ys x ⟨xs, le_rfl, xy⟩ y ⟨ys, xy, le_rfl⟩)\n    · rw [edist_comm] at hxy\n      exact hxy (h ys xs y ⟨ys, le_rfl, yx⟩ x ⟨xs, yx, le_rfl⟩)\n  · rintro h x xs y ys\n    refine' le_antisymm _ zero_le'\n    rw [← h]\n    exact evariation_on.mono f (inter_subset_left s (Icc x y))\n#align has_constant_speed_on_with_zero_iff has_constant_speed_on_with_zero_iff\n\n",
 "has_constant_speed_on_with_of_subsingleton":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\ntheorem has_constant_speed_on_with_of_subsingleton (f : exprℝ → E) {s : Set (exprℝ)} (hs : s.subsingleton)\n    (l : nnreal) : has_constant_speed_on_with f s l :=\n  by\n  rintro x hx y hy; cases hs hx hy\n  rw [evariation_on.subsingleton f (fun y hy z hz => hs hy.1 hz.1 : (s ∩ Icc x x).subsingleton)]\n  simp only [sub_self, MulZeroClass.mul_zero, ENNReal.ofReal_zero]\n#align has_constant_speed_on_with_of_subsingleton has_constant_speed_on_with_of_subsingleton\n\n",
 "has_constant_speed_on_with_iff_variation_on_from_to_eq":
 "theorem has_constant_speed_on_with_iff_variation_on_from_to_eq :\n    has_constant_speed_on_with f s l ↔\n      has_locally_bounded_variation_on f s ∧\n        ∀ ⦃x⦄ (hx : x ∈ s) ⦃y⦄ (hy : y ∈ s), variation_on_from_to f s x y = l * (y - x) :=\n  by\n  constructor\n  · rintro h\n    refine' ⟨h.has_locally_bounded_variation_on, fun x xs y ys => _⟩\n    rw [has_constant_speed_on_with_iff_ordered] at h\n    rcases le_total x y with (xy | yx)\n    ·\n      rw [variation_on_from_to.eq_of_le f s xy, h xs ys xy,\n        ENNReal.toReal_ofReal (mul_nonneg l.prop (sub_nonneg.mpr xy))]\n    ·\n      rw [variation_on_from_to.eq_of_ge f s yx, h ys xs yx,\n        ENNReal.toReal_ofReal (mul_nonneg l.prop (sub_nonneg.mpr yx)), mul_comm ↑l, mul_comm ↑l, ← neg_mul, neg_sub]\n  · rw [has_constant_speed_on_with_iff_ordered]\n    rintro h x xs y ys xy\n    rw [← h.2 xs ys, variation_on_from_to.eq_of_le f s xy, ENNReal.ofReal_toReal (h.1 x y xs ys)]\n#align has_constant_speed_on_with_iff_variation_on_from_to_eq has_constant_speed_on_with_iff_variation_on_from_to_eq\n\n",
 "has_constant_speed_on_with_iff_ordered":
 "theorem has_constant_speed_on_with_iff_ordered :\n    has_constant_speed_on_with f s l ↔\n      ∀ ⦃x⦄ (hx : x ∈ s) ⦃y⦄ (hy : y ∈ s), x ≤ y → evariation_on f (s ∩ Icc x y) = ENNReal.ofReal (l * (y - x)) :=\n  by\n  refine' ⟨fun h x xs y ys xy => h xs ys, fun h x xs y ys => _⟩\n  rcases le_total x y with (xy | yx)\n  · exact h xs ys xy\n  · rw [evariation_on.subsingleton, ENNReal.ofReal_of_nonpos]\n    · exact mul_nonpos_of_nonneg_of_nonpos l.prop (sub_nonpos_of_le yx)\n    · rintro z ⟨zs, xz, zy⟩ w ⟨ws, xw, wy⟩\n      cases le_antisymm (zy.trans yx) xz\n      cases le_antisymm (wy.trans yx) xw\n      rfl\n#align has_constant_speed_on_with_iff_ordered has_constant_speed_on_with_iff_ordered\n\n",
 "edist_natural_parameterization_eq_zero":
 "theorem edist_natural_parameterization_eq_zero {f : α → E} {s : Set α} (hf : has_locally_bounded_variation_on f s)\n    {a : α} (as : a ∈ s) {b : α} (bs : b ∈ s) :\n    edist (natural_parameterization f s a (variation_on_from_to f s a b)) (f b) = 0 :=\n  by\n  dsimp only [natural_parameterization]\n  haveI : Nonempty α := ⟨a⟩\n  let c := Function.invFunOn (variation_on_from_to f s a) s (variation_on_from_to f s a b)\n  obtain ⟨cs, hc⟩ :=\n    @Function.invFunOn_pos _ _ _ s (variation_on_from_to f s a) (variation_on_from_to f s a b) ⟨b, bs, rfl⟩\n  rw [variation_on_from_to.eq_left_iff hf as cs bs] at hc\n  apply variation_on_from_to.edist_zero_of_eq_zero hf cs bs hc\n#align edist_natural_parameterization_eq_zero edist_natural_parameterization_eq_zero\n\n",
 "Icc_Icc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem has_unit_speed_on.Icc_Icc {x y z : exprℝ} (hfs : has_unit_speed_on f (Icc x y))\n    (hft : has_unit_speed_on f (Icc y z)) : has_unit_speed_on f (Icc x z) :=\n  has_constant_speed_on_with.Icc_Icc hfs hft\n#align has_unit_speed_on.Icc_Icc has_unit_speed_on.Icc_Icc\n\n"}