{"tendsto_lim":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- Fekete's lemma: a subadditive sequence which is bounded below converges. -/\ntheorem tendsto_lim (hbdd : BddBelow (range fun n => u n / n)) : tendsto (fun n => u n / n) at_top ((nhds) h.lim) :=\n  by\n  refine' tendsto_order.2 ⟨fun l hl => _, fun L hL => _⟩\n  · refine' eventually_at_top.2 ⟨1, fun n hn => hl.trans_le (h.lim_le_div hbdd (zero_lt_one.trans_le hn).ne')⟩\n  · obtain ⟨n, npos, hn⟩ : ∃ n : ℕ, 0 < n ∧ u n / n < L :=\n      by\n      rw [subadditive.lim] at hL\n      rcases exists_lt_of_cinfₛ_lt (by simp) hL with ⟨x, hx, xL⟩\n      rcases(mem_image _ _ _).1 hx with ⟨n, hn, rfl⟩\n      exact ⟨n, zero_lt_one.trans_le hn, xL⟩\n    exact h.eventually_div_lt_of_div_lt npos.ne' hn\n#align tendsto_lim tendsto_lim\n\n",
 "lim_le_div":
 "/-\nCopyright (c) 2021 Sébastien Gouëzel. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Sébastien Gouëzel\n-/\ntheorem lim_le_div (hbdd : BddBelow (range fun n => u n / n)) {n : ℕ} (hn : n ≠ 0) : h.lim ≤ u n / n :=\n  by\n  rw [subadditive.lim]\n  apply cinfₛ_le _ _\n  · rcases hbdd with ⟨c, hc⟩\n    exact ⟨c, fun x hx => hc (image_subset_range _ _ hx)⟩\n  · apply mem_image_of_mem\n    exact zero_lt_iff.2 hn\n#align lim_le_div lim_le_div\n\n",
 "eventually_div_lt_of_div_lt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\ntheorem eventually_div_lt_of_div_lt {L : exprℝ} {n : ℕ} (hn : n ≠ 0) (hL : u n / n < L) :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" at_top\n      (u p / p < L) :=\n  by\n  have I : ∀ i : ℕ, 0 < i → (i : exprℝ) ≠ 0 := by\n    intro i hi\n    simp only [hi.ne', ne.def, Nat.cast_eq_zero, not_false_iff]\n  obtain ⟨w, nw, wL⟩ : ∃ w, u n / n < w ∧ w < L := exists_between hL\n  obtain ⟨x, hx⟩ : ∃ x, ∀ i < n, u i - i * w ≤ x :=\n    by\n    obtain ⟨x, hx⟩ : BddAbove ↑(Finset.image (fun i => u i - i * w) (Finset.range n)) := finset.bdd_above _\n    refine' ⟨x, fun i hi => _⟩\n    simp only [upperBounds, mem_image, and_imp, forall_exists_index, mem_set_of_eq, forall_apply_eq_imp_iff₂,\n      Finset.mem_range, Finset.mem_coe, Finset.coe_image] at hx\n    exact hx _ hi\n  have A : ∀ p : ℕ, u p ≤ p * w + x := by\n    intro p\n    let s := p / n\n    let r := p % n\n    have hp : p = s * n + r := by rw [mul_comm, nat.div_add_mod]\n    calc\n      u p = u (s * n + r) := by rw [hp]\n      _ ≤ s * u n + u r := h.apply_mul_add_le _ _ _\n      _ = s * n * (u n / n) + u r := by\n        field_simp [I _ hn.bot_lt]\n        ring\n      _ ≤ s * n * w + u r :=\n        add_le_add_right (mul_le_mul_of_nonneg_left nw.le (mul_nonneg (nat.cast_nonneg _) (nat.cast_nonneg _))) _\n      _ = (s * n + r) * w + (u r - r * w) := by ring\n      _ = p * w + (u r - r * w) := by\n        rw [hp]\n        simp only [Nat.cast_add, nat.cast_mul]\n      _ ≤ p * w + x := add_le_add_left (hx _ (nat.mod_lt _ hn.bot_lt)) _\n      \n  have B :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" at_top\n      (u p / p ≤ w + x / p) :=\n    by\n    refine' eventually_at_top.2 ⟨1, fun p hp => _⟩\n    simp only [I p hp, ne.def, not_false_iff, field_simps]\n    refine' div_le_div_of_le_of_nonneg _ (nat.cast_nonneg _)\n    rw [mul_comm]\n    exact A _\n  have C :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" at_top\n      (w + x / p < L) :=\n    by\n    have : tendsto (fun p : ℕ => w + x / p) at_top ((nhds) (w + 0)) :=\n      tendsto_const_nhds.add (tendsto_const_nhds.div_at_top tendsto_coe_nat_at_top_at_top)\n    rw [add_zero] at this\n    exact (tendsto_order.1 this).2 _ wL\n  filter_upwards [B, C] with _ hp h'p using hp.trans_lt h'p\n#align eventually_div_lt_of_div_lt eventually_div_lt_of_div_lt\n\n",
 "apply_mul_add_le":
 "theorem apply_mul_add_le (k n r) : u (k * n + r) ≤ k * u n + u r :=\n  by\n  induction' k with k IH; · simp only [Nat.cast_zero, zero_mul, zero_add]\n  calc\n    u ((k + 1) * n + r) = u (n + (k * n + r)) := by\n      congr 1\n      ring\n    _ ≤ u n + u (k * n + r) := h _ _\n    _ ≤ u n + (k * u n + u r) := add_le_add_left IH _\n    _ = (k + 1 : ℕ) * u n + u r := by simp <;> ring\n    \n#align apply_mul_add_le apply_mul_add_le\n\n"}