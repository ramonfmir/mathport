{"triorthogonal_eq_orthogonal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᗮ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᗮ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᗮ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᗮ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᗮ» -/\n/-- The orthogonal complement satisfies `Kᗮᗮᗮ = Kᗮ`. -/\ntheorem submodule.triorthogonal_eq_orthogonal [CompleteSpace E] : «expr ᗮ» («expr ᗮ» («expr ᗮ» K)) = «expr ᗮ» K :=\n  by\n  rw [(«expr ᗮ» K).orthogonal_orthogonal_eq_closure]\n  exact K.is_closed_orthogonal.submodule_topological_closure_eq\n#align submodule.triorthogonal_eq_orthogonal submodule.triorthogonal_eq_orthogonal\n\n",
 "topological_closure_eq_top_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᗮ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/-- The closure of `K` is the full space iff `Kᗮ` is trivial. -/\ntheorem submodule.topological_closure_eq_top_iff [CompleteSpace E] :\n    K.topological_closure = «expr⊤» ↔ «expr ᗮ» K = «expr⊥» :=\n  by\n  rw [← submodule.orthogonal_orthogonal_eq_closure]\n  constructor <;> intro h\n  · rw [← submodule.triorthogonal_eq_orthogonal, h, submodule.top_orthogonal_eq_bot]\n  · rw [h, submodule.bot_orthogonal_eq_top]\n#align submodule.topological_closure_eq_top_iff submodule.topological_closure_eq_top_iff\n\n",
 "sup_orthogonal_of_complete_space":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᗮ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/-- If `K` is complete, `K` and `Kᗮ` span the whole space. -/\ntheorem submodule.sup_orthogonal_of_complete_space [CompleteSpace K] : «expr ⊔ » K («expr ᗮ» K) = «expr⊤» :=\n  by\n  convert submodule.sup_orthogonal_inf_of_complete_space (le_top : K ≤ «expr⊤»)\n  simp\n#align submodule.sup_orthogonal_of_complete_space submodule.sup_orthogonal_of_complete_space\n\n",
 "sup_orthogonal_inf_of_complete_space":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᗮ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᗮ» -/\n/-- If `K₁` is complete and contained in `K₂`, `K₁` and `K₁ᗮ ⊓ K₂` span `K₂`. -/\ntheorem submodule.sup_orthogonal_inf_of_complete_space {K₁ K₂ : Submodule 𝕜 E} (h : K₁ ≤ K₂) [CompleteSpace K₁] :\n    «expr ⊔ » K₁ («expr ⊓ » («expr ᗮ» K₁) K₂) = K₂ := by\n  ext x\n  rw [Submodule.mem_sup]\n  let v : K₁ := orthogonal_projection K₁ x\n  have hvm : x - v ∈ «expr ᗮ» K₁ := sub_orthogonal_projection_mem_orthogonal x\n  constructor\n  · rintro ⟨y, hy, z, hz, rfl⟩\n    exact K₂.add_mem (h hy) hz.2\n  · exact fun hx => ⟨v, v.prop, x - v, ⟨hvm, K₂.sub_mem hx (h v.prop)⟩, add_sub_cancel'_right _ _⟩\n#align submodule.sup_orthogonal_inf_of_complete_space submodule.sup_orthogonal_inf_of_complete_space\n\n",
 "sub_orthogonal_projection_mem_orthogonal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᗮ» -/\n/-- The difference of `v` from its orthogonal projection onto `K` is in `Kᗮ`.  -/\n@[simp]\ntheorem sub_orthogonal_projection_mem_orthogonal (v : E) : v - orthogonal_projection K v ∈ «expr ᗮ» K :=\n  by\n  intro w hw\n  rw [inner_eq_zero_symm]\n  exact orthogonal_projection_inner_eq_zero _ _ hw\n#align sub_orthogonal_projection_mem_orthogonal sub_orthogonal_projection_mem_orthogonal\n\n",
 "smul_orthogonal_projection_singleton":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟪ , ⟫» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟪ , ⟫» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟪ , ⟫» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟪ , ⟫» -/\ntheorem smul_orthogonal_projection_singleton {v : E} (w : E) :\n    «expr • » («expr‖ ‖» v ^ 2 : 𝕜) (orthogonal_projection («expr ∙ » 𝕜 v) w : E) = «expr • » («expr⟪ , ⟫» v w) v :=\n  by\n  suffices ↑(orthogonal_projection («expr ∙ » 𝕜 v) («expr • » («expr‖ ‖» v ^ 2 : 𝕜) w)) = «expr • » («expr⟪ , ⟫» v w) v\n    by simpa using this\n  apply eq_orthogonal_projection_of_mem_of_inner_eq_zero\n  · rw [Submodule.mem_span_singleton]\n    use «expr⟪ , ⟫» v w\n  · intro x hx\n    obtain ⟨c, rfl⟩ := submodule.mem_span_singleton.mp hx\n    have hv : ↑(«expr‖ ‖» v) ^ 2 = «expr⟪ , ⟫» v v := by\n      norm_cast\n      simp [@norm_sq_eq_inner 𝕜]\n    simp [inner_sub_left, inner_smul_left, inner_smul_right, map_div₀, mul_comm, hv, inner_product_space.conj_symm, hv]\n#align smul_orthogonal_projection_singleton smul_orthogonal_projection_singleton\n\n",
 "reflections_generate_dim_aux":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᗮ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᗮ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᗮ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᗮ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᗮ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᗮ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᗮ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᗮ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᗮ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᗮ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `sym.cons' -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗᵢ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᗮ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᗮ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- An element `φ` of the orthogonal group of `F` can be factored as a product of reflections, and\nspecifically at most as many reflections as the dimension of the complement of the fixed subspace\nof `φ`. -/\ntheorem linear_isometry_equiv.reflections_generate_dim_aux [FiniteDimensional (exprℝ) F] {n : ℕ}\n    (φ : «expr ≃ₗᵢ[ ] » F (exprℝ) F)\n    (hn : finrank (exprℝ) («expr ᗮ» (ker (ContinuousLinearMap.id (exprℝ) F - φ))) ≤ n) :\n    ∃ l : List F, l.length ≤ n ∧ φ = (l.map fun v => reflection («expr ᗮ» («expr ∙ » (exprℝ) v))).prod :=\n  by\n  -- We prove this by strong induction on `n`, the dimension of the orthogonal complement of the\n  -- fixed subspace of the endomorphism `φ`\n  induction' n with n IH generalizing φ\n  · -- Base case: `n = 0`, the fixed subspace is the whole space, so `φ = id`\n    refine' ⟨[], rfl.le, show φ = 1 from _⟩\n    have : ker (ContinuousLinearMap.id (exprℝ) F - φ) = «expr⊤» := by\n      rwa [le_zero_iff, finrank_eq_zero, submodule.orthogonal_eq_bot_iff] at hn\n    symm\n    ext x\n    have := LinearMap.congr_fun (linear_map.ker_eq_top.mp this) x\n    simpa only [sub_eq_zero, [anonymous], ContinuousLinearMap.coe_sub, LinearMap.sub_apply, LinearMap.zero_apply] using\n      this\n  · -- Inductive step.  Let `W` be the fixed subspace of `φ`.  We suppose its complement to have\n    -- dimension at most n + 1.\n    let W := ker (ContinuousLinearMap.id (exprℝ) F - φ)\n    have hW : ∀ w ∈ W, φ w = w := fun w hw => (sub_eq_zero.mp hw).symm\n    by_cases hn' : finrank (exprℝ) («expr ᗮ» W) ≤ n\n    · obtain ⟨V, hV₁, hV₂⟩ := IH φ hn'\n      exact ⟨V, hV₁.trans n.le_succ, hV₂⟩\n    -- Take a nonzero element `v` of the orthogonal complement of `W`.\n    haveI : Nontrivial («expr ᗮ» W) :=\n      nontrivial_of_finrank_pos (by linarith [zero_le n] : 0 < finrank (exprℝ) («expr ᗮ» W))\n    obtain ⟨v, hv⟩ := exists_ne (0 : «expr ᗮ» W)\n    have hφv : φ v ∈ «expr ᗮ» W := by\n      intro w hw\n      rw [← hW w hw, linear_isometry_equiv.inner_map_map]\n      exact v.prop w hw\n    have hv' : (v : F) ∉ W := by\n      intro h\n      exact hv ((Submodule.mem_left_iff_eq_zero_of_disjoint W.orthogonal_disjoint).mp h)\n    -- Let `ρ` be the reflection in `v - φ v`; this is designed to swap `v` and `φ v`\n    let x : F := v - φ v\n    let ρ := reflection («expr ᗮ» («expr ∙ » (exprℝ) x))\n    -- Notation: Let `V` be the fixed subspace of `φ.trans ρ`\n    let V := ker (ContinuousLinearMap.id (exprℝ) F - φ.trans ρ)\n    have hV : ∀ w, ρ (φ w) = w → w ∈ V := by\n      intro w hw\n      change w - ρ (φ w) = 0\n      rw [sub_eq_zero, hw]\n    -- Everything fixed by `φ` is fixed by `φ.trans ρ`\n    have H₂V : W ≤ V := by\n      intro w hw\n      apply hV\n      rw [hW w hw]\n      refine' reflection_mem_subspace_eq_self _\n      rw [submodule.mem_orthogonal_singleton_iff_inner_left]\n      exact Submodule.sub_mem _ v.prop hφv _ hw\n    -- `v` is also fixed by `φ.trans ρ`\n    have H₁V : (v : F) ∈ V := by\n      apply hV\n      have : ρ v = φ v := reflection_sub (φ.norm_map v).symm\n      rw [← this]\n      exact reflection_reflection _ _\n    -- By dimension-counting, the complement of the fixed subspace of `φ.trans ρ` has dimension at\n    -- most `n`\n    have : finrank (exprℝ) («expr ᗮ» V) ≤ n :=\n      by\n      change finrank (exprℝ) («expr ᗮ» W) ≤ n + 1 at hn\n      have : finrank (exprℝ) W + 1 ≤ finrank (exprℝ) V :=\n        Submodule.finrank_lt_finrank_of_lt (SetLike.lt_iff_le_and_exists.2 ⟨H₂V, v, H₁V, hv'⟩)\n      have : finrank (exprℝ) V + finrank (exprℝ) («expr ᗮ» V) = finrank (exprℝ) F := V.finrank_add_finrank_orthogonal\n      have : finrank (exprℝ) W + finrank (exprℝ) («expr ᗮ» W) = finrank (exprℝ) F := W.finrank_add_finrank_orthogonal\n      linarith\n    -- So apply the inductive hypothesis to `φ.trans ρ`\n    obtain ⟨l, hl, hφl⟩ := IH (ρ * φ) this\n    -- Prepend `ρ` to the factorization into reflections obtained for `φ.trans ρ`; this gives a\n    -- factorization into reflections for `φ`.\n    refine' ⟨sym.cons' x l, nat.succ_le_succ hl, _⟩\n    rw [list.map_cons, List.prod_cons]\n    have := congr_arg ((· * ·) ρ) hφl\n    rwa [← mul_assoc, reflection_mul_reflection, one_mul] at this\n#align linear_isometry_equiv.reflections_generate_dim_aux linear_isometry_equiv.reflections_generate_dim_aux\n\n",
 "reflections_generate_dim":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗᵢ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᗮ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- The orthogonal group of `F` is generated by reflections; specifically each element `φ` of the\northogonal group is a product of at most as many reflections as the dimension of `F`.\n\nSpecial case of the **Cartan–Dieudonné theorem**. -/\ntheorem linear_isometry_equiv.reflections_generate_dim [FiniteDimensional (exprℝ) F] (φ : «expr ≃ₗᵢ[ ] » F (exprℝ) F) :\n    ∃ l : List F,\n      l.length ≤ finrank (exprℝ) F ∧ φ = (l.map fun v => reflection («expr ᗮ» («expr ∙ » (exprℝ) v))).prod :=\n  let ⟨l, hl₁, hl₂⟩ := φ.reflections_generate_dim_aux le_rfl\n  ⟨l, hl₁.trans (Submodule.finrank_le _), hl₂⟩\n#align linear_isometry_equiv.reflections_generate_dim linear_isometry_equiv.reflections_generate_dim\n\n",
 "reflections_generate":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᗮ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/-- The orthogonal group of `F` is generated by reflections. -/\ntheorem linear_isometry_equiv.reflections_generate [FiniteDimensional (exprℝ) F] :\n    Subgroup.closure (Set.range fun v : F => reflection («expr ᗮ» («expr ∙ » (exprℝ) v))) = «expr⊤» :=\n  by\n  rw [Subgroup.eq_top_iff']\n  intro φ\n  rcases φ.reflections_generate_dim with ⟨l, _, rfl⟩\n  apply (Subgroup.closure _).list_prod_mem\n  intro x hx\n  rcases list.mem_map.mp hx with ⟨a, _, hax⟩\n  exact Subgroup.subset_closure ⟨a, hax⟩\n#align linear_isometry_equiv.reflections_generate linear_isometry_equiv.reflections_generate\n\n",
 "reflection_trans_reflection":
 "/-- Reflection is involutive. -/\n@[simp]\ntheorem reflection_trans_reflection : (reflection K).trans (reflection K) = LinearIsometryEquiv.refl 𝕜 E :=\n  LinearIsometryEquiv.ext <| reflection_involutive K\n#align reflection_trans_reflection reflection_trans_reflection\n\n",
 "reflection_symm":
 "/-- Reflection is its own inverse. -/\n@[simp]\ntheorem reflection_symm : (reflection K).symm = reflection K :=\n  rfl\n#align reflection_symm reflection_symm\n\n",
 "reflection_sub":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗᵢ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᗮ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᗮ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem reflection_sub [CompleteSpace F] {v w : F} (h : «expr‖ ‖» v = «expr‖ ‖» w) :\n    reflection («expr ᗮ» («expr ∙ » (exprℝ) (v - w))) v = w :=\n  by\n  set R : «expr ≃ₗᵢ[ ] » F (exprℝ) F := reflection («expr ᗮ» («expr ∙ » (exprℝ) (v - w)))\n  suffices R v + R v = w + w by\n    apply smul_right_injective F (by norm_num : (2 : exprℝ) ≠ 0)\n    simpa [two_smul] using this\n  have h₁ : R (v - w) = -(v - w) := reflection_orthogonal_complement_singleton_eq_neg (v - w)\n  have h₂ : R (v + w) = v + w := by\n    apply reflection_mem_subspace_eq_self\n    rw [submodule.mem_orthogonal_singleton_iff_inner_left]\n    rw [real_inner_add_sub_eq_zero_iff]\n    exact h\n  convert congr_arg₂ (· + ·) h₂ h₁ using 1\n  · simp\n  · abel\n#align reflection_sub reflection_sub\n\n",
 "reflection_reflection":
 "/-- Reflecting twice in the same subspace. -/\n@[simp]\ntheorem reflection_reflection (p : E) : reflection K (reflection K p) = p :=\n  (reflection K).left_inv p\n#align reflection_reflection reflection_reflection\n\n",
 "reflection_orthogonal_complement_singleton_eq_neg":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᗮ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\n/-- The reflection in `(𝕜 ∙ v)ᗮ` of `v` is `-v`. -/\ntheorem reflection_orthogonal_complement_singleton_eq_neg [CompleteSpace E] (v : E) :\n    reflection («expr ᗮ» («expr ∙ » 𝕜 v)) v = -v :=\n  reflection_mem_subspace_orthogonal_precomplement_eq_neg (Submodule.mem_span_singleton_self v)\n#align reflection_orthogonal_complement_singleton_eq_neg reflection_orthogonal_complement_singleton_eq_neg\n\n",
 "reflection_mul_reflection":
 "/-- Reflection is involutive. -/\n@[simp]\ntheorem reflection_mul_reflection : reflection K * reflection K = 1 :=\n  reflection_trans_reflection _\n#align reflection_mul_reflection reflection_mul_reflection\n\n",
 "reflection_mem_subspace_orthogonal_precomplement_eq_neg":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᗮ» -/\n/-- The reflection in `Kᗮ` of an element of `K` is its negation. -/\ntheorem reflection_mem_subspace_orthogonal_precomplement_eq_neg [CompleteSpace E] {v : E} (hv : v ∈ K) :\n    reflection («expr ᗮ» K) v = -v :=\n  reflection_mem_subspace_orthogonal_complement_eq_neg (K.le_orthogonal_orthogonal hv)\n#align reflection_mem_subspace_orthogonal_precomplement_eq_neg reflection_mem_subspace_orthogonal_precomplement_eq_neg\n\n",
 "reflection_mem_subspace_orthogonal_complement_eq_neg":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᗮ» -/\n/-- The reflection in `K` of an element of `Kᗮ` is its negation. -/\ntheorem reflection_mem_subspace_orthogonal_complement_eq_neg [CompleteSpace K] {v : E} (hv : v ∈ «expr ᗮ» K) :\n    reflection K v = -v := by\n  simp [reflection_apply, orthogonal_projection_mem_subspace_orthogonal_complement_eq_zero hv]\n#align reflection_mem_subspace_orthogonal_complement_eq_neg reflection_mem_subspace_orthogonal_complement_eq_neg\n\n",
 "reflection_mem_subspace_eq_self":
 "theorem reflection_mem_subspace_eq_self {x : E} (hx : x ∈ K) : reflection K x = x :=\n  (reflection_eq_self_iff x).mpr hx\n#align reflection_mem_subspace_eq_self reflection_mem_subspace_eq_self\n\n",
 "reflection_map_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗᵢ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/-- Reflection in the `submodule.map` of a subspace. -/\ntheorem reflection_map_apply {E E' : Type _} [NormedAddCommGroup E] [NormedAddCommGroup E'] [inner_product_space 𝕜 E]\n    [inner_product_space 𝕜 E'] (f : «expr ≃ₗᵢ[ ] » E 𝕜 E') (K : Submodule 𝕜 E) [CompleteSpace K] (x : E') :\n    reflection (K.map (f.to_linear_equiv : «expr →ₗ[ ] » E 𝕜 E')) x = f (reflection K (f.symm x)) := by\n  simp [bit0, reflection_apply, orthogonal_projection_map_apply f K x]\n#align reflection_map_apply reflection_map_apply\n\n",
 "reflection_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗᵢ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/-- Reflection in the `submodule.map` of a subspace. -/\ntheorem reflection_map {E E' : Type _} [NormedAddCommGroup E] [NormedAddCommGroup E'] [inner_product_space 𝕜 E]\n    [inner_product_space 𝕜 E'] (f : «expr ≃ₗᵢ[ ] » E 𝕜 E') (K : Submodule 𝕜 E) [CompleteSpace K] :\n    reflection (K.map (f.to_linear_equiv : «expr →ₗ[ ] » E 𝕜 E')) = f.symm.trans ((reflection K).trans f) :=\n  LinearIsometryEquiv.ext <| reflection_map_apply f K\n#align reflection_map reflection_map\n\n",
 "reflection_involutive":
 "/-- Reflection is involutive. -/\ntheorem reflection_involutive : Function.Involutive (reflection K) :=\n  reflection_reflection K\n#align reflection_involutive reflection_involutive\n\n",
 "reflection_inv":
 "/-- Reflection is its own inverse. -/\n@[simp]\ntheorem reflection_inv : (reflection K)⁻¹ = reflection K :=\n  rfl\n#align reflection_inv reflection_inv\n\n",
 "reflection_eq_self_iff":
 "/-- A point is its own reflection if and only if it is in the subspace. -/\ntheorem reflection_eq_self_iff (x : E) : reflection K x = x ↔ x ∈ K :=\n  by\n  rw [← orthogonal_projection_eq_self_iff, reflection_apply, sub_eq_iff_eq_add', ← two_smul 𝕜, ← two_smul' 𝕜]\n  refine' (smul_right_injective E _).eq_iff\n  exact two_ne_zero\n#align reflection_eq_self_iff reflection_eq_self_iff\n\n",
 "reflection_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/-- Reflection through the trivial subspace {0} is just negation. -/\n@[simp]\ntheorem reflection_bot : reflection («expr⊥» : Submodule 𝕜 E) = LinearIsometryEquiv.neg 𝕜 := by\n  ext <;> simp [reflection_apply]\n#align reflection_bot reflection_bot\n\n",
 "reflection_apply":
 "/-- The result of reflecting. -/\ntheorem reflection_apply (p : E) : reflection K p = bit0 ↑(orthogonal_projection K p) - p :=\n  rfl\n#align reflection_apply reflection_apply\n\n",
 "orthogonal_projection_unit_singleton":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟪ , ⟫» -/\n/-- Formula for orthogonal projection onto a single unit vector. -/\ntheorem orthogonal_projection_unit_singleton {v : E} (hv : «expr‖ ‖» v = 1) (w : E) :\n    (orthogonal_projection («expr ∙ » 𝕜 v) w : E) = «expr • » («expr⟪ , ⟫» v w) v :=\n  by\n  rw [← smul_orthogonal_projection_singleton 𝕜 w]\n  simp [hv]\n#align orthogonal_projection_unit_singleton orthogonal_projection_unit_singleton\n\n",
 "orthogonal_projection_tendsto_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- Given a monotone family `U` of complete submodules of `E` with dense span supremum,\nand a fixed `x : E`, the orthogonal projection of `x` on `U i` tends to `x` along `at_top`. -/\ntheorem orthogonal_projection_tendsto_self [CompleteSpace E] {ι : Type _} [SemilatticeSup ι] (U : ι → Submodule 𝕜 E)\n    [∀ t, CompleteSpace (U t)] (hU : Monotone U) (x : E)\n    (hU' :\n      «expr⊤» ≤\n        («expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n            (U t)).topological_closure) :\n    Filter.Tendsto (fun t => (orthogonal_projection (U t) x : E)) atTop ((nhds) x) :=\n  by\n  rw [← eq_top_iff] at hU'\n  convert orthogonal_projection_tendsto_closure_supr U hU x\n  rw [orthogonal_projection_eq_self_iff.mpr _]\n  rw [hU']\n  trivial\n#align orthogonal_projection_tendsto_self orthogonal_projection_tendsto_self\n\n",
 "orthogonal_projection_tendsto_closure_supr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/-- Given a monotone family `U` of complete submodules of `E` and a fixed `x : E`,\nthe orthogonal projection of `x` on `U i` tends to the orthogonal projection of `x` on\n`(⨆ i, U i).topological_closure` along `at_top`. -/\ntheorem orthogonal_projection_tendsto_closure_supr [CompleteSpace E] {ι : Type _} [SemilatticeSup ι]\n    (U : ι → Submodule 𝕜 E) [∀ i, CompleteSpace (U i)] (hU : Monotone U) (x : E) :\n    Filter.Tendsto (fun i => (orthogonal_projection (U i) x : E)) atTop\n      ((nhds)\n        (orthogonal_projection\n            («expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n                (U i)).topological_closure\n            x :\n          E)) :=\n  by\n  cases isEmpty_or_nonempty ι\n  · rw [filter_eq_bot_of_is_empty (at_top : Filter ι)]\n    exact tendsto_bot\n  let y :=\n    (orthogonal_projection\n        («expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n            (U i)).topological_closure\n        x :\n      E)\n  have proj_x : ∀ i, orthogonal_projection (U i) x = orthogonal_projection (U i) y := fun i =>\n    (orthogonal_projection_orthogonal_projection_of_le ((le_supᵢ U i).trans (supᵢ U).le_topological_closure) _).symm\n  suffices ∀ ε > 0, ∃ I, ∀ i ≥ I, «expr‖ ‖» ((orthogonal_projection (U i) y : E) - y) < ε by\n    simpa only [proj_x, NormedAddCommGroup.tendsto_atTop] using this\n  intro ε hε\n  obtain ⟨a, ha, hay⟩ :\n    ∃ a ∈ «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (U i),\n      dist y a < ε :=\n    by\n    have y_mem :\n      y ∈\n        («expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n            (U i)).topological_closure :=\n      Submodule.coe_mem _\n    rw [← SetLike.mem_coe, Submodule.topologicalClosure_coe, Metric.mem_closure_iff] at y_mem\n    exact y_mem ε hε\n  rw [dist_eq_norm] at hay\n  obtain ⟨I, hI⟩ : ∃ I, a ∈ U I := by rwa [Submodule.mem_supᵢ_of_directed _ hU.directed_le] at ha\n  refine' ⟨I, fun i (hi : I ≤ i) => _⟩\n  rw [norm_sub_rev, orthogonal_projection_minimal]\n  refine' lt_of_le_of_lt _ hay\n  change _ ≤ «expr‖ ‖» (y - (⟨a, hU hi hI⟩ : U i))\n  exact cinfᵢ_le ⟨0, set.forall_range_iff.mpr fun _ => norm_nonneg _⟩ _\n#align orthogonal_projection_tendsto_closure_supr orthogonal_projection_tendsto_closure_supr\n\n",
 "orthogonal_projection_singleton":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟪ , ⟫» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟪ , ⟫» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/-- Formula for orthogonal projection onto a single vector. -/\ntheorem orthogonal_projection_singleton {v : E} (w : E) :\n    (orthogonal_projection («expr ∙ » 𝕜 v) w : E) = «expr • » («expr⟪ , ⟫» v w / «expr‖ ‖» v ^ 2) v :=\n  by\n  by_cases hv : v = 0\n  · rw [hv, eq_orthogonal_projection_of_eq_submodule (Submodule.span_zero_singleton 𝕜)]\n    · simp\n    · infer_instance\n  have hv' : «expr‖ ‖» v ≠ 0 := ne_of_gt (norm_pos_iff.mpr hv)\n  have key :\n    «expr • » ((«expr‖ ‖» v ^ 2 : 𝕜)⁻¹ * «expr‖ ‖» v ^ 2) ↑(orthogonal_projection («expr ∙ » 𝕜 v) w) =\n      «expr • » ((«expr‖ ‖» v ^ 2 : 𝕜)⁻¹ * «expr⟪ , ⟫» v w) v :=\n    by simp [mul_smul, smul_orthogonal_projection_singleton 𝕜 w]\n  convert key <;> field_simp [hv']\n#align orthogonal_projection_singleton orthogonal_projection_singleton\n\n",
 "orthogonal_projection_orthogonal_projection_of_le":
 "/-- If `U ≤ V`, then projecting on `V` and then on `U` is the same as projecting on `U`. -/\ntheorem orthogonal_projection_orthogonal_projection_of_le {U V : Submodule 𝕜 E} [CompleteSpace U] [CompleteSpace V]\n    (h : U ≤ V) (x : E) : orthogonal_projection U (orthogonal_projection V x) = orthogonal_projection U x :=\n  Eq.symm <| by\n    simpa only [sub_eq_zero, map_sub] using\n      orthogonal_projection_mem_subspace_orthogonal_complement_eq_zero\n        (submodule.orthogonal_le h (sub_orthogonal_projection_mem_orthogonal x))\n#align orthogonal_projection_orthogonal_projection_of_le orthogonal_projection_orthogonal_projection_of_le\n\n",
 "orthogonal_projection_orthogonal_complement_singleton_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᗮ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\n/-- The orthogonal projection onto `(𝕜 ∙ v)ᗮ` of `v` is zero. -/\ntheorem orthogonal_projection_orthogonal_complement_singleton_eq_zero [CompleteSpace E] (v : E) :\n    orthogonal_projection («expr ᗮ» («expr ∙ » 𝕜 v)) v = 0 :=\n  orthogonal_projection_mem_subspace_orthogonal_precomplement_eq_zero (Submodule.mem_span_singleton_self v)\n#align orthogonal_projection_orthogonal_complement_singleton_eq_zero orthogonal_projection_orthogonal_complement_singleton_eq_zero\n\n",
 "orthogonal_projection_norm_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/-- The orthogonal projection has norm `≤ 1`. -/\ntheorem orthogonal_projection_norm_le : «expr‖ ‖» (orthogonal_projection K) ≤ 1 :=\n  linear_map.mk_continuous_norm_le _ (by norm_num) _\n#align orthogonal_projection_norm_le orthogonal_projection_norm_le\n\n",
 "orthogonal_projection_minimal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/-- The orthogonal projection of `y` on `U` minimizes the distance `‖y - x‖` for `x ∈ U`. -/\ntheorem orthogonal_projection_minimal {U : Submodule 𝕜 E} [CompleteSpace U] (y : E) :\n    «expr‖ ‖» (y - orthogonal_projection U y) =\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n        («expr‖ ‖» (y - x)) :=\n  by\n  rw [norm_eq_infi_iff_inner_eq_zero _ (Submodule.coe_mem _)]\n  exact orthogonal_projection_inner_eq_zero _\n#align orthogonal_projection_minimal orthogonal_projection_minimal\n\n",
 "orthogonal_projection_mem_subspace_orthogonal_precomplement_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᗮ» -/\n/-- The orthogonal projection onto `Kᗮ` of an element of `K` is zero. -/\ntheorem orthogonal_projection_mem_subspace_orthogonal_precomplement_eq_zero [CompleteSpace E] {v : E} (hv : v ∈ K) :\n    orthogonal_projection («expr ᗮ» K) v = 0 :=\n  orthogonal_projection_mem_subspace_orthogonal_complement_eq_zero (K.le_orthogonal_orthogonal hv)\n#align orthogonal_projection_mem_subspace_orthogonal_precomplement_eq_zero orthogonal_projection_mem_subspace_orthogonal_precomplement_eq_zero\n\n",
 "orthogonal_projection_mem_subspace_orthogonal_complement_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᗮ» -/\n/-- The orthogonal projection onto `K` of an element of `Kᗮ` is zero. -/\ntheorem orthogonal_projection_mem_subspace_orthogonal_complement_eq_zero [CompleteSpace K] {v : E}\n    (hv : v ∈ «expr ᗮ» K) : orthogonal_projection K v = 0 :=\n  by\n  ext\n  convert eq_orthogonal_projection_of_mem_orthogonal _ _ <;> simp [hv]\n#align orthogonal_projection_mem_subspace_orthogonal_complement_eq_zero orthogonal_projection_mem_subspace_orthogonal_complement_eq_zero\n\n",
 "orthogonal_projection_mem_subspace_eq_self":
 "/-- The orthogonal projection sends elements of `K` to themselves. -/\n@[simp]\ntheorem orthogonal_projection_mem_subspace_eq_self (v : K) : orthogonal_projection K v = v :=\n  by\n  ext\n  apply eq_orthogonal_projection_of_mem_of_inner_eq_zero <;> simp\n#align orthogonal_projection_mem_subspace_eq_self orthogonal_projection_mem_subspace_eq_self\n\n",
 "orthogonal_projection_map_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗᵢ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/-- Orthogonal projection onto the `submodule.map` of a subspace. -/\ntheorem orthogonal_projection_map_apply {E E' : Type _} [NormedAddCommGroup E] [NormedAddCommGroup E']\n    [inner_product_space 𝕜 E] [inner_product_space 𝕜 E'] (f : «expr ≃ₗᵢ[ ] » E 𝕜 E') (p : Submodule 𝕜 E)\n    [CompleteSpace p] (x : E') :\n    (orthogonal_projection (p.map (f.to_linear_equiv : «expr →ₗ[ ] » E 𝕜 E')) x : E') =\n      f (orthogonal_projection p (f.symm x)) :=\n  by\n  simpa only [f.coe_to_linear_isometry, f.apply_symm_apply] using\n    (f.to_linear_isometry.map_orthogonal_projection p (f.symm x)).symm\n#align orthogonal_projection_map_apply orthogonal_projection_map_apply\n\n",
 "orthogonal_projection_is_symmetric":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∘L » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/-- The orthogonal projection is symmetric. -/\ntheorem orthogonal_projection_is_symmetric [CompleteSpace K] :\n    («expr ∘L » K.subtypeL (orthogonal_projection K) : «expr →ₗ[ ] » E 𝕜 E).is_symmetric :=\n  inner_orthogonal_projection_left_eq_right K\n#align orthogonal_projection_is_symmetric orthogonal_projection_is_symmetric\n\n",
 "orthogonal_projection_inner_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟪ , ⟫» -/\n/-- The characterization of the orthogonal projection.  -/\n@[simp]\ntheorem orthogonal_projection_inner_eq_zero (v : E) : ∀ w ∈ K, «expr⟪ , ⟫» (v - orthogonal_projection K v) w = 0 :=\n  orthogonal_projection_fn_inner_eq_zero v\n#align orthogonal_projection_inner_eq_zero orthogonal_projection_inner_eq_zero\n\n",
 "orthogonal_projection_fn_norm_sq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟪ , ⟫» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem orthogonal_projection_fn_norm_sq (v : E) :\n    «expr‖ ‖» v * «expr‖ ‖» v =\n      «expr‖ ‖» (v - orthogonal_projection_fn K v) * «expr‖ ‖» (v - orthogonal_projection_fn K v) +\n        «expr‖ ‖» (orthogonal_projection_fn K v) * «expr‖ ‖» (orthogonal_projection_fn K v) :=\n  by\n  set p := orthogonal_projection_fn K v\n  have h' : «expr⟪ , ⟫» (v - p) p = 0 := orthogonal_projection_fn_inner_eq_zero _ _ (orthogonal_projection_fn_mem v)\n  convert norm_add_sq_eq_norm_sq_add_norm_sq_of_inner_eq_zero (v - p) p h' using 2 <;> simp\n#align orthogonal_projection_fn_norm_sq orthogonal_projection_fn_norm_sq\n\n",
 "orthogonal_projection_fn_mem":
 "/-- The unbundled orthogonal projection is in the given subspace.\nThis lemma is only intended for use in setting up the bundled version\nand should not be used once that is defined. -/\ntheorem orthogonal_projection_fn_mem (v : E) : orthogonal_projection_fn K v ∈ K :=\n  (exists_norm_eq_infi_of_complete_subspace K (completeSpace_coe_iff_isComplete.mp ‹_›) v).some_spec.some\n#align orthogonal_projection_fn_mem orthogonal_projection_fn_mem\n\n",
 "orthogonal_projection_fn_inner_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟪ , ⟫» -/\n/-- The characterization of the unbundled orthogonal projection.  This\nlemma is only intended for use in setting up the bundled version\nand should not be used once that is defined. -/\ntheorem orthogonal_projection_fn_inner_eq_zero (v : E) :\n    ∀ w ∈ K, «expr⟪ , ⟫» (v - orthogonal_projection_fn K v) w = 0 :=\n  by\n  rw [← norm_eq_infi_iff_inner_eq_zero K (orthogonal_projection_fn_mem v)]\n  exact (exists_norm_eq_infi_of_complete_subspace K (complete_space_coe_iff_is_complete.mp ‹_›) v).some_spec.some_spec\n#align orthogonal_projection_fn_inner_eq_zero orthogonal_projection_fn_inner_eq_zero\n\n",
 "orthogonal_projection_fn_eq":
 "@[simp]\ntheorem orthogonal_projection_fn_eq (v : E) : orthogonal_projection_fn K v = (orthogonal_projection K v : E) :=\n  rfl\n#align orthogonal_projection_fn_eq orthogonal_projection_fn_eq\n\n",
 "orthogonal_projection_eq_self_iff":
 "/-- A point equals its orthogonal projection if and only if it lies in the subspace. -/\ntheorem orthogonal_projection_eq_self_iff {v : E} : (orthogonal_projection K v : E) = v ↔ v ∈ K :=\n  by\n  refine' ⟨fun h => _, fun h => eq_orthogonal_projection_of_mem_of_inner_eq_zero h _⟩\n  · rw [← h]\n    simp\n  · simp\n#align orthogonal_projection_eq_self_iff orthogonal_projection_eq_self_iff\n\n",
 "orthogonal_projection_eq_linear_proj":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᗮ» -/\ntheorem orthogonal_projection_eq_linear_proj [CompleteSpace K] (x : E) :\n    orthogonal_projection K x = K.linear_proj_of_is_compl _ submodule.is_compl_orthogonal_of_complete_space x :=\n  by\n  have : IsCompl K («expr ᗮ» K) := submodule.is_compl_orthogonal_of_complete_space\n  nth_rw 1 [← Submodule.linear_proj_add_linearProjOfIsCompl_eq_self this x]\n  rw [map_add, orthogonal_projection_mem_subspace_eq_self,\n    orthogonal_projection_mem_subspace_orthogonal_complement_eq_zero (Submodule.coe_mem _), add_zero]\n#align orthogonal_projection_eq_linear_proj orthogonal_projection_eq_linear_proj\n\n",
 "orthogonal_projection_comp_subtypeL_eq_zero_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∘L » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟂ » -/\n/-- The projection into `U` from `V` is the zero map if and only if `U` and `V` are orthogonal. -/\ntheorem orthogonal_projection_comp_subtypeL_eq_zero_iff {U V : Submodule 𝕜 E} [CompleteSpace U] :\n    «expr ∘L » (orthogonal_projection U) V.subtypeL = 0 ↔ «expr ⟂ » U V :=\n  ⟨fun h u hu v hv => by\n    convert orthogonal_projection_inner_eq_zero v u hu using 2\n    have : orthogonal_projection U v = 0 := FunLike.congr_fun h ⟨_, hv⟩\n    rw [this, Submodule.coe_zero, sub_zero], submodule.is_ortho.orthogonal_projection_comp_subtypeL⟩\n#align orthogonal_projection_comp_subtypeL_eq_zero_iff orthogonal_projection_comp_subtypeL_eq_zero_iff\n\n",
 "orthogonal_projection_comp_subtypeL":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∘L » -/\n/-- The projection into `U` from an orthogonal submodule `V` is the zero map. -/\ntheorem submodule.is_ortho.orthogonal_projection_comp_subtypeL {U V : Submodule 𝕜 E} [CompleteSpace U]\n    (h : «expr ⟂ » U V) : «expr ∘L » (orthogonal_projection U) V.subtypeL = 0 :=\n  ContinuousLinearMap.ext fun v => orthogonal_projection_mem_subspace_orthogonal_complement_eq_zero <| h.symm v.prop\n#align submodule.is_ortho.orthogonal_projection_comp_subtypeL submodule.is_ortho.orthogonal_projection_comp_subtypeL\n\n",
 "orthogonal_projection_coe_linear_map_eq_linear_proj":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\ntheorem orthogonal_projection_coe_linear_map_eq_linear_proj [CompleteSpace K] :\n    (orthogonal_projection K : «expr →ₗ[ ] » E 𝕜 K) =\n      K.linear_proj_of_is_compl _ submodule.is_compl_orthogonal_of_complete_space :=\n  LinearMap.ext <| orthogonal_projection_eq_linear_proj\n#align orthogonal_projection_coe_linear_map_eq_linear_proj orthogonal_projection_coe_linear_map_eq_linear_proj\n\n",
 "orthogonal_projection_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/-- The orthogonal projection onto the trivial submodule is the zero map. -/\n@[simp]\ntheorem orthogonal_projection_bot : orthogonal_projection («expr⊥» : Submodule 𝕜 E) = 0 := by ext\n#align orthogonal_projection_bot orthogonal_projection_bot\n\n",
 "orthogonal_orthogonal_eq_closure":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᗮ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᗮ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᗮ» -/\ntheorem submodule.orthogonal_orthogonal_eq_closure [CompleteSpace E] : «expr ᗮ» («expr ᗮ» K) = K.topological_closure :=\n  by\n  refine' le_antisymm _ _\n  · convert submodule.orthogonal_orthogonal_monotone K.le_topological_closure\n    haveI : CompleteSpace K.topological_closure := K.is_closed_topological_closure.complete_space_coe\n    rw [K.topological_closure.orthogonal_orthogonal]\n  · exact K.topological_closure_minimal K.le_orthogonal_orthogonal («expr ᗮ» K).is_closed_orthogonal\n#align submodule.orthogonal_orthogonal_eq_closure submodule.orthogonal_orthogonal_eq_closure\n\n",
 "orthogonal_orthogonal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟪ , ⟫» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᗮ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᗮ» -/\n/-- If `K` is complete, then the orthogonal complement of its orthogonal complement is itself. -/\n@[simp]\ntheorem submodule.orthogonal_orthogonal [CompleteSpace K] : «expr ᗮ» («expr ᗮ» K) = K :=\n  by\n  ext v\n  constructor\n  · obtain ⟨y, hy, z, hz, rfl⟩ := K.exists_sum_mem_mem_orthogonal v\n    intro hv\n    have hz' : z = 0 := by\n      have hyz : «expr⟪ , ⟫» z y = 0 := by simp [hz y hy, inner_eq_zero_symm]\n      simpa [inner_add_right, hyz] using hv z hz\n    simp [hy, hz']\n  · intro hv w hw\n    rw [inner_eq_zero_symm]\n    exact hw v hv\n#align submodule.orthogonal_orthogonal submodule.orthogonal_orthogonal\n\n",
 "orthogonal_eq_bot_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᗮ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᗮ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem submodule.orthogonal_eq_bot_iff [CompleteSpace (K : Set E)] : «expr ᗮ» K = «expr⊥» ↔ K = «expr⊤» :=\n  by\n  refine' ⟨_, fun h => by rw [h, submodule.top_orthogonal_eq_bot]⟩\n  intro h\n  have : «expr ⊔ » K («expr ᗮ» K) = «expr⊤» := submodule.sup_orthogonal_of_complete_space\n  rwa [h, sup_comm, bot_sup_eq] at this\n#align submodule.orthogonal_eq_bot_iff submodule.orthogonal_eq_bot_iff\n\n",
 "norm_sq_eq_add_norm_sq_projection":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᗮ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟪ , ⟫» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᗮ» -/\n/-- The Pythagorean theorem, for an orthogonal projection.-/\ntheorem norm_sq_eq_add_norm_sq_projection (x : E) (S : Submodule 𝕜 E) [CompleteSpace E] [CompleteSpace S] :\n    «expr‖ ‖» x ^ 2 =\n      «expr‖ ‖» (orthogonal_projection S x) ^ 2 + «expr‖ ‖» (orthogonal_projection («expr ᗮ» S) x) ^ 2 :=\n  by\n  let p1 := orthogonal_projection S\n  let p2 := orthogonal_projection («expr ᗮ» S)\n  have x_decomp : x = p1 x + p2 x := eq_sum_orthogonal_projection_self_orthogonal_complement S x\n  have x_orth : «expr⟪ , ⟫» (p1 x : E) (p2 x) = 0 :=\n    submodule.inner_right_of_mem_orthogonal (SetLike.coe_mem (p1 x)) (SetLike.coe_mem (p2 x))\n  nth_rw 1 [x_decomp]\n  simp only [sq, norm_add_sq_eq_norm_sq_add_norm_sq_of_inner_eq_zero (p1 x : E) (p2 x) x_orth, add_left_inj,\n    mul_eq_mul_left_iff, norm_eq_zero, true_or_iff, eq_self_iff_true, Submodule.coe_norm, Submodule.coe_eq_zero]\n#align norm_sq_eq_add_norm_sq_projection norm_sq_eq_add_norm_sq_projection\n\n",
 "norm_eq_infi_iff_real_inner_le_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟪ , ⟫_ℝ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟪ , ⟫_ℝ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprabsR -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprabsR -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟪ , ⟫_ℝ» -/\n/-- Characterization of minimizers for the projection on a convex set in a real inner product\nspace. -/\ntheorem norm_eq_infi_iff_real_inner_le_zero {K : Set F} (h : Convex (exprℝ) K) {u : F} {v : F} (hv : v ∈ K) :\n    «expr‖ ‖» (u - v) =\n        «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n          («expr‖ ‖» (u - w)) ↔\n      ∀ w ∈ K, «expr⟪ , ⟫_ℝ» (u - v) (w - v) ≤ 0 :=\n  iff.intro\n    (by\n      intro eq w hw\n      let δ :=\n        «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n          («expr‖ ‖» (u - w))\n      let p := «expr⟪ , ⟫_ℝ» (u - v) (w - v)\n      let q := «expr‖ ‖» (w - v) ^ 2\n      letI : Nonempty K := ⟨⟨v, hv⟩⟩\n      have zero_le_δ : 0 ≤ δ\n      apply le_cinfᵢ\n      intro\n      exact norm_nonneg _\n      have δ_le : ∀ w : K, δ ≤ «expr‖ ‖» (u - w)\n      intro w\n      apply cinfᵢ_le\n      use (0 : exprℝ)\n      rintro _ ⟨_, rfl⟩\n      exact norm_nonneg _\n      have δ_le' : ∀ w ∈ K, δ ≤ «expr‖ ‖» (u - w) := fun w hw => δ_le ⟨w, hw⟩\n      have : ∀ θ : exprℝ, 0 < θ → θ ≤ 1 → 2 * p ≤ θ * q\n      intro θ hθ₁ hθ₂\n      have :\n        «expr‖ ‖» (u - v) ^ 2 ≤\n          «expr‖ ‖» (u - v) ^ 2 - 2 * θ * «expr⟪ , ⟫_ℝ» (u - v) (w - v) + θ * θ * «expr‖ ‖» (w - v) ^ 2 :=\n        calc\n          «expr‖ ‖» (u - v) ^ 2 ≤ «expr‖ ‖» (u - («expr • » θ w + «expr • » (1 - θ) v)) ^ 2 :=\n            by\n            simp only [sq]; apply mul_self_le_mul_self (norm_nonneg _)\n            rw [Eq]; apply δ_le'\n            apply h hw hv\n            exacts[le_of_lt hθ₁, sub_nonneg.2 hθ₂, add_sub_cancel'_right _ _]\n          _ = «expr‖ ‖» (u - v - «expr • » θ (w - v)) ^ 2 :=\n            by\n            have : u - («expr • » θ w + «expr • » (1 - θ) v) = u - v - «expr • » θ (w - v) :=\n              by\n              rw [smul_sub, sub_smul, one_smul]\n              simp only [sub_eq_add_neg, add_comm, add_left_comm, add_assoc, neg_add_rev]\n            rw [this]\n          _ = «expr‖ ‖» (u - v) ^ 2 - 2 * θ * inner (u - v) (w - v) + θ * θ * «expr‖ ‖» (w - v) ^ 2 :=\n            by\n            rw [@norm_sub_sq (exprℝ), inner_smul_right, norm_smul]\n            simp only [sq]\n            show\n              «expr‖ ‖» (u - v) * «expr‖ ‖» (u - v) - 2 * (θ * inner (u - v) (w - v)) +\n                  (exprabsR) θ * «expr‖ ‖» (w - v) * ((exprabsR) θ * «expr‖ ‖» (w - v)) =\n                «expr‖ ‖» (u - v) * «expr‖ ‖» (u - v) - 2 * θ * inner (u - v) (w - v) +\n                  θ * θ * («expr‖ ‖» (w - v) * «expr‖ ‖» (w - v))\n            rw [abs_of_pos hθ₁]; ring\n          \n      have eq₁ :\n        «expr‖ ‖» (u - v) ^ 2 - 2 * θ * inner (u - v) (w - v) + θ * θ * «expr‖ ‖» (w - v) ^ 2 =\n          «expr‖ ‖» (u - v) ^ 2 + (θ * θ * «expr‖ ‖» (w - v) ^ 2 - 2 * θ * inner (u - v) (w - v)) :=\n        by abel\n      rw [eq₁, le_add_iff_nonneg_right] at this\n      have eq₂ :\n        θ * θ * «expr‖ ‖» (w - v) ^ 2 - 2 * θ * inner (u - v) (w - v) =\n          θ * (θ * «expr‖ ‖» (w - v) ^ 2 - 2 * inner (u - v) (w - v))\n      ring\n      rw [eq₂] at this\n      have := le_of_sub_nonneg (nonneg_of_mul_nonneg_right this hθ₁)\n      exact this\n      by_cases hq : q = 0\n      · rw [hq] at this\n        have : p ≤ 0\n        have := this (1 : exprℝ) (by norm_num) (by norm_num)\n        linarith\n        exact this\n      · have q_pos : 0 < q\n        apply lt_of_le_of_ne\n        exact sq_nonneg _\n        intro h\n        exact hq h.symm\n        by_contra hp\n        rw [not_le] at hp\n        let θ := min (1 : exprℝ) (p / q)\n        have eq₁ : θ * q ≤ p :=\n          calc\n            θ * q ≤ p / q * q := mul_le_mul_of_nonneg_right (min_le_right _ _) (sq_nonneg _)\n            _ = p := div_mul_cancel _ hq\n            \n        have : 2 * p ≤ p :=\n          calc\n            2 * p ≤ θ * q := by refine' this θ (lt_min (by norm_num) (div_pos hp q_pos)) (by norm_num)\n            _ ≤ p := eq₁\n            \n        linarith)\n    (by\n      intro h\n      letI : Nonempty K := ⟨⟨v, hv⟩⟩\n      apply le_antisymm\n      · apply le_cinfᵢ\n        intro w\n        apply nonneg_le_nonneg_of_sq_le_sq (norm_nonneg _)\n        have := h w w.2\n        calc\n          «expr‖ ‖» (u - v) * «expr‖ ‖» (u - v) ≤\n              «expr‖ ‖» (u - v) * «expr‖ ‖» (u - v) - 2 * inner (u - v) ((w : F) - v) :=\n            by linarith\n          _ ≤ «expr‖ ‖» (u - v) ^ 2 - 2 * inner (u - v) ((w : F) - v) + «expr‖ ‖» ((w : F) - v) ^ 2 :=\n            by\n            rw [sq]\n            refine' le_add_of_nonneg_right _\n            exact sq_nonneg _\n          _ = «expr‖ ‖» (u - v - (w - v)) ^ 2 := (@norm_sub_sq (exprℝ) _ _ _ _ _ _).symm\n          _ = «expr‖ ‖» (u - w) * «expr‖ ‖» (u - w) :=\n            by\n            have : u - v - (w - v) = u - w\n            abel\n            rw [this, sq]\n          \n      · show\n          «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n              («expr‖ ‖» (u - w)) ≤\n            (fun w : K => «expr‖ ‖» (u - w)) ⟨v, hv⟩\n        apply cinfᵢ_le\n        use 0\n        rintro y ⟨z, rfl⟩\n        exact norm_nonneg _)\n#align norm_eq_infi_iff_real_inner_le_zero norm_eq_infi_iff_real_inner_le_zero\n\n",
 "norm_eq_infi_iff_real_inner_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟪ , ⟫_ℝ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟪ , ⟫_ℝ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟪ , ⟫_ℝ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟪ , ⟫_ℝ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟪ , ⟫_ℝ» -/\n/-- Characterization of minimizers in the projection on a subspace, in the real case.\nLet `u` be a point in a real inner product space, and let `K` be a nonempty subspace.\nThen point `v` minimizes the distance `‖u - v‖` over points in `K` if and only if\nfor all `w ∈ K`, `⟪u - v, w⟫ = 0` (i.e., `u - v` is orthogonal to the subspace `K`).\nThis is superceded by `norm_eq_infi_iff_inner_eq_zero` that gives the same conclusion over\nany `is_R_or_C` field.\n-/\ntheorem norm_eq_infi_iff_real_inner_eq_zero (K : Submodule (exprℝ) F) {u : F} {v : F} (hv : v ∈ K) :\n    «expr‖ ‖» (u - v) =\n        «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n          («expr‖ ‖» (u - w)) ↔\n      ∀ w ∈ K, «expr⟪ , ⟫_ℝ» (u - v) w = 0 :=\n  iff.intro\n    (by\n      intro h\n      have h : ∀ w ∈ K, «expr⟪ , ⟫_ℝ» (u - v) (w - v) ≤ 0 :=\n        by\n        rwa [norm_eq_infi_iff_real_inner_le_zero] at h\n        exacts[K.convex, hv]\n      intro w hw\n      have le : «expr⟪ , ⟫_ℝ» (u - v) w ≤ 0\n      let w' := w + v\n      have : w' ∈ K := Submodule.add_mem _ hw hv\n      have h₁ := h w' this\n      have h₂ : w' - v = w\n      simp only [add_neg_cancel_right, sub_eq_add_neg]\n      rw [h₂] at h₁\n      exact h₁\n      have ge : «expr⟪ , ⟫_ℝ» (u - v) w ≥ 0\n      let w'' := -w + v\n      have : w'' ∈ K := Submodule.add_mem _ (Submodule.neg_mem _ hw) hv\n      have h₁ := h w'' this\n      have h₂ : w'' - v = -w\n      simp only [neg_inj, add_neg_cancel_right, sub_eq_add_neg]\n      rw [h₂, inner_neg_right] at h₁\n      linarith\n      exact le_antisymm le GE.ge)\n    (by\n      intro h\n      have : ∀ w ∈ K, «expr⟪ , ⟫_ℝ» (u - v) (w - v) ≤ 0\n      intro w hw\n      let w' := w - v\n      have : w' ∈ K := Submodule.sub_mem _ hw hv\n      have h₁ := h w' this\n      exact le_of_eq h₁\n      rwa [norm_eq_infi_iff_real_inner_le_zero]\n      exacts[Submodule.convex _, hv])\n#align norm_eq_infi_iff_real_inner_eq_zero norm_eq_infi_iff_real_inner_eq_zero\n\n",
 "norm_eq_infi_iff_inner_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟪ , ⟫» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟪ , ⟫» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟪ , ⟫» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟪ , ⟫» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟪ , ⟫_ℝ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟪ , ⟫» -/\n/-- Characterization of minimizers in the projection on a subspace.\nLet `u` be a point in an inner product space, and let `K` be a nonempty subspace.\nThen point `v` minimizes the distance `‖u - v‖` over points in `K` if and only if\nfor all `w ∈ K`, `⟪u - v, w⟫ = 0` (i.e., `u - v` is orthogonal to the subspace `K`)\n-/\ntheorem norm_eq_infi_iff_inner_eq_zero {u : E} {v : E} (hv : v ∈ K) :\n    «expr‖ ‖» (u - v) =\n        «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n          («expr‖ ‖» (u - w)) ↔\n      ∀ w ∈ K, «expr⟪ , ⟫» (u - v) w = 0 :=\n  by\n  letI : inner_product_space (exprℝ) E := inner_product_space.is_R_or_C_to_real 𝕜 E\n  letI : Module (exprℝ) E := restrict_scalars.module (exprℝ) 𝕜 E\n  let K' : Submodule (exprℝ) E := K.restrict_scalars (exprℝ)\n  constructor\n  · intro H\n    have A : ∀ w ∈ K, re («expr⟪ , ⟫» (u - v) w) = 0 := (norm_eq_infi_iff_real_inner_eq_zero K' hv).1 H\n    intro w hw\n    apply ext\n    · simp [A w hw]\n    · symm\n      calc\n        im (0 : 𝕜) = 0 := im.map_zero\n        _ = re («expr⟪ , ⟫» (u - v) («expr • » (-I) w)) := (A _ (K.smul_mem (-I) hw)).symm\n        _ = re (-I * «expr⟪ , ⟫» (u - v) w) := by rw [inner_smul_right]\n        _ = im («expr⟪ , ⟫» (u - v) w) := by simp\n        \n  · intro H\n    have : ∀ w ∈ K', «expr⟪ , ⟫_ℝ» (u - v) w = 0 := by\n      intro w hw\n      rw [real_inner_eq_re_inner, H w hw]\n      exact zero_re'\n    exact (norm_eq_infi_iff_real_inner_eq_zero K' hv).2 this\n#align norm_eq_infi_iff_inner_eq_zero norm_eq_infi_iff_inner_eq_zero\n\n",
 "maximal_orthonormal_iff_orthogonal_complement_eq_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᗮ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᗮ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟪ , ⟫» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↥ » -/\n/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (u «expr ⊇ » v) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊇ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᗮ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/-- An orthonormal set in an `inner_product_space` is maximal, if and only if the orthogonal\ncomplement of its span is empty. -/\ntheorem maximal_orthonormal_iff_orthogonal_complement_eq_bot (hv : orthonormal 𝕜 (coe : v → E)) :\n    (∀ (u) (_ : «expr ⊇ » u v), orthonormal 𝕜 (coe : u → E) → u = v) ↔ «expr ᗮ» (span 𝕜 v) = «expr⊥» :=\n  by\n  rw [Submodule.eq_bot_iff]\n  constructor\n  · contrapose!\n    -- ** direction 1: nonempty orthogonal complement implies nonmaximal\n    rintro ⟨x, hx', hx⟩\n    -- take a nonzero vector and normalize it\n    let e := «expr • » ((«expr‖ ‖» x)⁻¹ : 𝕜) x\n    have he : «expr‖ ‖» e = 1 := by simp [e, norm_smul_inv_norm hx]\n    have he' : e ∈ «expr ᗮ» (span 𝕜 v) := smul_mem' _ _ hx'\n    have he'' : e ∉ v := by\n      intro hev\n      have : e = 0 := by\n        have : e ∈ «expr ⊓ » (span 𝕜 v) («expr ᗮ» (span 𝕜 v)) := ⟨subset_span hev, he'⟩\n        simpa [(span 𝕜 v).inf_orthogonal_eq_bot] using this\n      have : e ≠ 0 := hv.ne_zero ⟨e, hev⟩\n      contradiction\n    -- put this together with `v` to provide a candidate orthonormal basis for the whole space\n    refine' ⟨insert e v, v.subset_insert e, ⟨_, _⟩, (v.ne_insert_of_not_mem he'').symm⟩\n    · -- show that the elements of `insert e v` have unit length\n      rintro ⟨a, ha'⟩\n      cases' eq_or_mem_of_mem_insert ha' with ha ha\n      · simp [ha, he]\n      · exact hv.1 ⟨a, ha⟩\n    · -- show that the elements of `insert e v` are orthogonal\n      have h_end : ∀ a ∈ v, «expr⟪ , ⟫» a e = 0 := by\n        intro a ha\n        exact he' a (Submodule.subset_span ha)\n      rintro ⟨a, ha'⟩\n      cases' eq_or_mem_of_mem_insert ha' with ha ha\n      · rintro ⟨b, hb'⟩ hab'\n        have hb : b ∈ v := by\n          refine' mem_of_mem_insert_of_ne hb' _\n          intro hbe'\n          apply hab'\n          simp [ha, hbe']\n        rw [inner_eq_zero_symm]\n        simpa [ha] using h_end b hb\n      rintro ⟨b, hb'⟩ hab'\n      cases' eq_or_mem_of_mem_insert hb' with hb hb\n      · simpa [hb] using h_end a ha\n      have : (⟨a, ha⟩ : v) ≠ ⟨b, hb⟩ := by\n        intro hab''\n        apply hab'\n        simpa using hab''\n      exact hv.2 this\n  · -- ** direction 2: empty orthogonal complement implies maximal\n    simp only [subset.antisymm_iff]\n    rintro h u (huv : v ⊆ u) hu\n    refine' ⟨_, huv⟩\n    intro x hxu\n    refine' ((mt (h x)) (hu.ne_zero ⟨x, hxu⟩)).imp_symm _\n    intro hxv y hy\n    have hxv' : (⟨x, hxu⟩ : u) ∉ («expr ⁻¹' » coe v : Set u) := by simp [huv, hxv]\n    obtain ⟨l, hl, rfl⟩ :\n      ∃ l ∈ Finsupp.supported 𝕜 𝕜 («expr ⁻¹' » coe v : Set u), (Finsupp.total («expr↥ » u) E 𝕜 coe) l = y :=\n      by\n      rw [← Finsupp.mem_span_image_iff_total]\n      simp [huv, inter_eq_self_of_subset_left, hy]\n    exact hu.inner_finsupp_eq_zero hxv' hl\n#align maximal_orthonormal_iff_orthogonal_complement_eq_bot maximal_orthonormal_iff_orthogonal_complement_eq_bot\n\n",
 "maximal_orthonormal_iff_basis_of_finite_dimensional":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (u «expr ⊇ » v) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊇ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n/-- An orthonormal set in a finite-dimensional `inner_product_space` is maximal, if and only if it\nis a basis. -/\ntheorem maximal_orthonormal_iff_basis_of_finite_dimensional (hv : orthonormal 𝕜 (coe : v → E)) :\n    (∀ (u) (_ : «expr ⊇ » u v), orthonormal 𝕜 (coe : u → E) → u = v) ↔ ∃ b : Basis v 𝕜 E, «expr⇑ » b = coe :=\n  by\n  haveI := proper_is_R_or_C 𝕜 (span 𝕜 v)\n  rw [maximal_orthonormal_iff_orthogonal_complement_eq_bot hv]\n  have hv_compl : IsComplete (span 𝕜 v : Set E) := (span 𝕜 v).complete_of_finite_dimensional\n  rw [submodule.orthogonal_eq_bot_iff]\n  have hv_coe : range (coe : v → E) = v := by simp\n  constructor\n  · refine' fun h => ⟨Basis.mk hv.linear_independent _, Basis.coe_mk _ _⟩\n    convert h.ge\n  · rintro ⟨h, coe_h⟩\n    rw [← h.span_eq, coe_h, hv_coe]\n#align maximal_orthonormal_iff_basis_of_finite_dimensional maximal_orthonormal_iff_basis_of_finite_dimensional\n\n",
 "map_orthogonal_projection'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗᵢ[ ] » -/\ntheorem linear_isometry.map_orthogonal_projection' {E E' : Type _} [NormedAddCommGroup E] [NormedAddCommGroup E']\n    [inner_product_space 𝕜 E] [inner_product_space 𝕜 E'] (f : «expr →ₗᵢ[ ] » E 𝕜 E') (p : Submodule 𝕜 E)\n    [CompleteSpace p] (x : E) : f (orthogonal_projection p x) = orthogonal_projection (p.map f) (f x) :=\n  by\n  refine' (eq_orthogonal_projection_of_mem_of_inner_eq_zero _ fun y hy => _).symm\n  refine' Submodule.apply_coe_mem_map _ _\n  rcases hy with ⟨x', hx', rfl : f x' = y⟩\n  rw [← f.map_sub, f.inner_map_map, orthogonal_projection_inner_eq_zero x x' hx']\n#align linear_isometry.map_orthogonal_projection' linear_isometry.map_orthogonal_projection'\n\n",
 "map_orthogonal_projection":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗᵢ[ ] » -/\ntheorem linear_isometry.map_orthogonal_projection {E E' : Type _} [NormedAddCommGroup E] [NormedAddCommGroup E']\n    [inner_product_space 𝕜 E] [inner_product_space 𝕜 E'] (f : «expr →ₗᵢ[ ] » E 𝕜 E') (p : Submodule 𝕜 E)\n    [CompleteSpace p] (x : E) : f (orthogonal_projection p x) = orthogonal_projection (p.map f.to_linear_map) (f x) :=\n  by\n  refine' (eq_orthogonal_projection_of_mem_of_inner_eq_zero _ fun y hy => _).symm\n  refine' Submodule.apply_coe_mem_map _ _\n  rcases hy with ⟨x', hx', rfl : f x' = y⟩\n  rw [← f.map_sub, f.inner_map_map, orthogonal_projection_inner_eq_zero x x' hx']\n#align linear_isometry.map_orthogonal_projection linear_isometry.map_orthogonal_projection\n\n",
 "is_internal_iff_of_is_complete":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᗮ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/-- An orthogonal family of subspaces of `E` satisfies `direct_sum.is_internal` (that is,\nthey provide an internal direct sum decomposition of `E`) if and only if their span has trivial\northogonal complement. -/\ntheorem orthogonal_family.is_internal_iff_of_is_complete [DecidableEq ι] {V : ι → Submodule 𝕜 E}\n    (hV : orthogonal_family 𝕜 (fun i => V i) fun i => (V i).subtypeₗᵢ) (hc : IsComplete (↑(supᵢ V) : Set E)) :\n    DirectSum.IsInternal V ↔ «expr ᗮ» (supᵢ V) = «expr⊥» :=\n  by\n  haveI : CompleteSpace («expr↥ » (supᵢ V)) := hc.complete_space_coe\n  simp only [DirectSum.isInternal_submodule_iff_independent_and_supᵢ_eq_top, hV.independent, true_and_iff,\n    submodule.orthogonal_eq_bot_iff]\n#align orthogonal_family.is_internal_iff_of_is_complete orthogonal_family.is_internal_iff_of_is_complete\n\n",
 "is_internal_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᗮ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/-- An orthogonal family of subspaces of `E` satisfies `direct_sum.is_internal` (that is,\nthey provide an internal direct sum decomposition of `E`) if and only if their span has trivial\northogonal complement. -/\ntheorem orthogonal_family.is_internal_iff [DecidableEq ι] [FiniteDimensional 𝕜 E] {V : ι → Submodule 𝕜 E}\n    (hV : orthogonal_family 𝕜 (fun i => V i) fun i => (V i).subtypeₗᵢ) :\n    DirectSum.IsInternal V ↔ «expr ᗮ» (supᵢ V) = «expr⊥» :=\n  haveI h := finite_dimensional.proper_is_R_or_C 𝕜 («expr↥ » (supᵢ V))\n  hV.is_internal_iff_of_is_complete (complete_space_coe_iff_is_complete.mp inferInstance)\n#align orthogonal_family.is_internal_iff orthogonal_family.is_internal_iff\n\n",
 "is_compl_orthogonal_of_complete_space":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᗮ» -/\n/-- If `K` is complete, `K` and `Kᗮ` are complements of each other. -/\ntheorem submodule.is_compl_orthogonal_of_complete_space [CompleteSpace K] : IsCompl K («expr ᗮ» K) :=\n  ⟨K.orthogonal_disjoint, codisjoint_iff.2 submodule.sup_orthogonal_of_complete_space⟩\n#align submodule.is_compl_orthogonal_of_complete_space submodule.is_compl_orthogonal_of_complete_space\n\n",
 "inner_orthogonal_projection_left_eq_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟪ , ⟫» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟪ , ⟫» -/\n/-- The orthogonal projection is self-adjoint. -/\ntheorem inner_orthogonal_projection_left_eq_right [CompleteSpace K] (u v : E) :\n    «expr⟪ , ⟫» (↑(orthogonal_projection K u)) v = «expr⟪ , ⟫» u (orthogonal_projection K v) := by\n  rw [← inner_orthogonal_projection_eq_of_mem_left, inner_orthogonal_projection_eq_of_mem_right]\n#align inner_orthogonal_projection_left_eq_right inner_orthogonal_projection_left_eq_right\n\n",
 "inner_orthogonal_projection_eq_of_mem_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟪ , ⟫» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟪ , ⟫» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟪ , ⟫» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟪ , ⟫» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟪ , ⟫» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟪ , ⟫» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟪ , ⟫» -/\n@[simp]\ntheorem inner_orthogonal_projection_eq_of_mem_right [CompleteSpace K] (u : K) (v : E) :\n    «expr⟪ , ⟫» (orthogonal_projection K v) u = «expr⟪ , ⟫» v u :=\n  calc\n    «expr⟪ , ⟫» (orthogonal_projection K v) u = «expr⟪ , ⟫» (orthogonal_projection K v : E) u := K.coe_inner _ _\n    _ = «expr⟪ , ⟫» (orthogonal_projection K v : E) u + «expr⟪ , ⟫» (v - orthogonal_projection K v) u := by\n      rw [orthogonal_projection_inner_eq_zero _ _ (Submodule.coe_mem _), add_zero]\n    _ = «expr⟪ , ⟫» v u := by rw [← inner_add_left, add_sub_cancel'_right]\n    \n#align inner_orthogonal_projection_eq_of_mem_right inner_orthogonal_projection_eq_of_mem_right\n\n",
 "inner_orthogonal_projection_eq_of_mem_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟪ , ⟫» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟪ , ⟫» -/\n@[simp]\ntheorem inner_orthogonal_projection_eq_of_mem_left [CompleteSpace K] (u : K) (v : E) :\n    «expr⟪ , ⟫» u (orthogonal_projection K v) = «expr⟪ , ⟫» (u : E) v := by\n  rw [← inner_conj_symm, ← inner_conj_symm (u : E), inner_orthogonal_projection_eq_of_mem_right]\n#align inner_orthogonal_projection_eq_of_mem_left inner_orthogonal_projection_eq_of_mem_left\n\n",
 "id_eq_sum_orthogonal_projection_self_orthogonal_complement":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᗮ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᗮ» -/\n/-- In a complete space `E`, the projection maps onto a complete subspace `K` and its orthogonal\ncomplement sum to the identity. -/\ntheorem id_eq_sum_orthogonal_projection_self_orthogonal_complement [CompleteSpace E] [CompleteSpace K] :\n    ContinuousLinearMap.id 𝕜 E =\n      K.subtypeL.comp (orthogonal_projection K) + («expr ᗮ» K).subtypeL.comp (orthogonal_projection («expr ᗮ» K)) :=\n  by\n  ext w\n  exact eq_sum_orthogonal_projection_self_orthogonal_complement K w\n#align id_eq_sum_orthogonal_projection_self_orthogonal_complement id_eq_sum_orthogonal_projection_self_orthogonal_complement\n\n",
 "finrank_orthogonal_span_singleton":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᗮ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\n/-- In a finite-dimensional inner product space, the dimension of the orthogonal complement of the\nspan of a nonzero vector is one less than the dimension of the space. -/\ntheorem finrank_orthogonal_span_singleton {n : ℕ} [_i : Fact (finrank 𝕜 E = n + 1)] {v : E} (hv : v ≠ 0) :\n    finrank 𝕜 («expr ᗮ» («expr ∙ » 𝕜 v)) = n :=\n  submodule.finrank_add_finrank_orthogonal' <| by simp [finrank_span_singleton hv, _i.elim, add_comm]\n#align finrank_orthogonal_span_singleton finrank_orthogonal_span_singleton\n\n",
 "finrank_add_inf_finrank_orthogonal'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᗮ» -/\n/-- Given a finite-dimensional subspace `K₂`, and a subspace `K₁`\ncontainined in it, the dimensions of `K₁` and the intersection of its\northogonal subspace with `K₂` add to that of `K₂`. -/\ntheorem submodule.finrank_add_inf_finrank_orthogonal' {K₁ K₂ : Submodule 𝕜 E} [FiniteDimensional 𝕜 K₂] (h : K₁ ≤ K₂)\n    {n : ℕ} (h_dim : finrank 𝕜 K₁ + n = finrank 𝕜 K₂) : finrank 𝕜 («expr ⊓ » («expr ᗮ» K₁) K₂ : Submodule 𝕜 E) = n :=\n  by\n  rw [← add_right_inj (finrank 𝕜 K₁)]\n  simp [submodule.finrank_add_inf_finrank_orthogonal h, h_dim]\n#align submodule.finrank_add_inf_finrank_orthogonal' submodule.finrank_add_inf_finrank_orthogonal'\n\n",
 "finrank_add_inf_finrank_orthogonal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᗮ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᗮ» -/\n/-- Given a finite-dimensional subspace `K₂`, and a subspace `K₁`\ncontainined in it, the dimensions of `K₁` and the intersection of its\northogonal subspace with `K₂` add to that of `K₂`. -/\ntheorem submodule.finrank_add_inf_finrank_orthogonal {K₁ K₂ : Submodule 𝕜 E} [FiniteDimensional 𝕜 K₂] (h : K₁ ≤ K₂) :\n    finrank 𝕜 K₁ + finrank 𝕜 («expr ⊓ » («expr ᗮ» K₁) K₂ : Submodule 𝕜 E) = finrank 𝕜 K₂ :=\n  by\n  haveI := Submodule.finiteDimensional_of_le h\n  haveI := proper_is_R_or_C 𝕜 K₁\n  have hd := Submodule.finrank_sup_add_finrank_inf_eq K₁ («expr ⊓ » («expr ᗮ» K₁) K₂)\n  rw [← inf_assoc, (submodule.orthogonal_disjoint K₁).eq_bot, bot_inf_eq, finrank_bot,\n    submodule.sup_orthogonal_inf_of_complete_space h] at hd\n  rw [add_zero] at hd\n  exact hd.symm\n#align submodule.finrank_add_inf_finrank_orthogonal submodule.finrank_add_inf_finrank_orthogonal\n\n",
 "finrank_add_finrank_orthogonal'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᗮ» -/\n/-- Given a finite-dimensional space `E` and subspace `K`, the dimensions of `K` and `Kᗮ` add to\nthat of `E`. -/\ntheorem submodule.finrank_add_finrank_orthogonal' [FiniteDimensional 𝕜 E] {K : Submodule 𝕜 E} {n : ℕ}\n    (h_dim : finrank 𝕜 K + n = finrank 𝕜 E) : finrank 𝕜 («expr ᗮ» K) = n :=\n  by\n  rw [← add_right_inj (finrank 𝕜 K)]\n  simp [submodule.finrank_add_finrank_orthogonal, h_dim]\n#align submodule.finrank_add_finrank_orthogonal' submodule.finrank_add_finrank_orthogonal'\n\n",
 "finrank_add_finrank_orthogonal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᗮ» -/\n/-- Given a finite-dimensional space `E` and subspace `K`, the dimensions of `K` and `Kᗮ` add to\nthat of `E`. -/\ntheorem submodule.finrank_add_finrank_orthogonal [FiniteDimensional 𝕜 E] (K : Submodule 𝕜 E) :\n    finrank 𝕜 K + finrank 𝕜 («expr ᗮ» K) = finrank 𝕜 E :=\n  by\n  convert submodule.finrank_add_inf_finrank_orthogonal (le_top : K ≤ «expr⊤») using 1\n  · rw [inf_top_eq]\n  · simp\n#align submodule.finrank_add_finrank_orthogonal submodule.finrank_add_finrank_orthogonal\n\n",
 "exists_sum_mem_mem_orthogonal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᗮ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᗮ» -/\n/-- If `K` is complete, any `v` in `E` can be expressed as a sum of elements of `K` and `Kᗮ`. -/\ntheorem submodule.exists_sum_mem_mem_orthogonal [CompleteSpace K] (v : E) : ∃ y ∈ K, ∃ z ∈ «expr ᗮ» K, v = y + z :=\n  by\n  have h_mem : v ∈ «expr ⊔ » K («expr ᗮ» K) := by simp [submodule.sup_orthogonal_of_complete_space]\n  obtain ⟨y, hy, z, hz, hyz⟩ := submodule.mem_sup.mp h_mem\n  exact ⟨y, hy, z, hz, hyz.symm⟩\n#align submodule.exists_sum_mem_mem_orthogonal submodule.exists_sum_mem_mem_orthogonal\n\n",
 "exists_norm_eq_infi_of_complete_subspace":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/-- Existence of projections on complete subspaces.\nLet `u` be a point in an inner product space, and let `K` be a nonempty complete subspace.\nThen there exists a (unique) `v` in `K` that minimizes the distance `‖u - v‖` to `u`.\nThis point `v` is usually called the orthogonal projection of `u` onto `K`.\n-/\ntheorem exists_norm_eq_infi_of_complete_subspace (h : IsComplete (↑K : Set E)) :\n    ∀ u : E,\n      ∃ v ∈ K,\n        «expr‖ ‖» (u - v) =\n          «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n            («expr‖ ‖» (u - w)) :=\n  by\n  letI : inner_product_space (exprℝ) E := inner_product_space.is_R_or_C_to_real 𝕜 E\n  letI : Module (exprℝ) E := restrict_scalars.module (exprℝ) 𝕜 E\n  let K' : Submodule (exprℝ) E := Submodule.restrictScalars (exprℝ) K\n  exact exists_norm_eq_infi_of_complete_convex ⟨0, K'.zero_mem⟩ h K'.convex\n#align exists_norm_eq_infi_of_complete_subspace exists_norm_eq_infi_of_complete_subspace\n\n",
 "exists_norm_eq_infi_of_complete_convex":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprabsR -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprabsR -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/-\nCopyright (c) 2019 Zhouhang Zhou. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Zhouhang Zhou, Frédéric Dupuis, Heather Macbeth\n-/\n-- FIXME this monolithic proof causes a deterministic timeout with `-T50000`\n-- It should be broken in a sequence of more manageable pieces,\n-- perhaps with individual statements for the three steps below.\n/-- Existence of minimizers\nLet `u` be a point in a real inner product space, and let `K` be a nonempty complete convex subset.\nThen there exists a (unique) `v` in `K` that minimizes the distance `‖u - v‖` to `u`.\n -/\ntheorem exists_norm_eq_infi_of_complete_convex {K : Set F} (ne : K.nonempty) (h₁ : IsComplete K)\n    (h₂ : Convex (exprℝ) K) :\n    ∀ u : F,\n      ∃ v ∈ K,\n        «expr‖ ‖» (u - v) =\n          «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n            («expr‖ ‖» (u - w)) :=\n  fun u =>\n  by\n  let δ :=\n    «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" («expr‖ ‖» (u - w))\n  letI : Nonempty K := ne.to_subtype\n  have zero_le_δ : 0 ≤ δ := le_cinfᵢ fun _ => norm_nonneg _\n  have δ_le : ∀ w : K, δ ≤ «expr‖ ‖» (u - w) := cinfᵢ_le ⟨0, Set.forall_range_iff.2 fun _ => norm_nonneg _⟩\n  have δ_le' : ∀ w ∈ K, δ ≤ «expr‖ ‖» (u - w) := fun w hw => δ_le ⟨w, hw⟩\n  -- Step 1: since `δ` is the infimum, can find a sequence `w : ℕ → K` in `K`\n  -- such that `‖u - w n‖ < δ + 1 / (n + 1)` (which implies `‖u - w n‖ --> δ`);\n  -- maybe this should be a separate lemma\n  have exists_seq : ∃ w : ℕ → K, ∀ n, «expr‖ ‖» (u - w n) < δ + 1 / (n + 1) :=\n    by\n    have hδ : ∀ n : ℕ, δ < δ + 1 / (n + 1) := fun n => lt_add_of_le_of_pos le_rfl Nat.one_div_pos_of_nat\n    have h := fun n => exists_lt_of_cinfᵢ_lt (hδ n)\n    let w : ℕ → K := fun n => Classical.choose (h n)\n    exact ⟨w, fun n => Classical.choose_spec (h n)⟩\n  rcases exists_seq with ⟨w, hw⟩\n  have norm_tendsto : tendsto (fun n => «expr‖ ‖» (u - w n)) at_top (nhds δ) :=\n    by\n    have h : tendsto (fun n : ℕ => δ) at_top (nhds δ) := tendsto_const_nhds\n    have h' : tendsto (fun n : ℕ => δ + 1 / (n + 1)) at_top (nhds δ) :=\n      by\n      convert h.add tendsto_one_div_add_atTop_nhds_0_nat\n      simp only [add_zero]\n    exact tendsto_of_tendsto_of_tendsto_of_le_of_le h h' (fun x => δ_le _) fun x => le_of_lt (hw _)\n  -- Step 2: Prove that the sequence `w : ℕ → K` is a Cauchy sequence\n  have seq_is_cauchy : CauchySeq fun n => (w n : F) :=\n    by\n    rw [cauchySeq_iff_le_tendsto_0]\n    -- splits into three goals\n    let b := fun n : ℕ => 8 * δ * (1 / (n + 1)) + 4 * (1 / (n + 1)) * (1 / (n + 1))\n    use fun n => sqrt (b n)\n    constructor\n    -- first goal :  `∀ (n : ℕ), 0 ≤ sqrt (b n)`\n    intro n\n    exact sqrt_nonneg _\n    constructor\n    -- second goal : `∀ (n m N : ℕ), N ≤ n → N ≤ m → dist ↑(w n) ↑(w m) ≤ sqrt (b N)`\n    intro p q N hp hq\n    let wp := (w p : F)\n    let wq := (w q : F)\n    let a := u - wq\n    let b := u - wp\n    let half := 1 / (2 : exprℝ)\n    let div := 1 / ((N : exprℝ) + 1)\n    have :\n      4 * «expr‖ ‖» (u - «expr • » half (wq + wp)) * «expr‖ ‖» (u - «expr • » half (wq + wp)) +\n          «expr‖ ‖» (wp - wq) * «expr‖ ‖» (wp - wq) =\n        2 * («expr‖ ‖» a * «expr‖ ‖» a + «expr‖ ‖» b * «expr‖ ‖» b) :=\n      calc\n        4 * «expr‖ ‖» (u - «expr • » half (wq + wp)) * «expr‖ ‖» (u - «expr • » half (wq + wp)) +\n              «expr‖ ‖» (wp - wq) * «expr‖ ‖» (wp - wq) =\n            2 * «expr‖ ‖» (u - «expr • » half (wq + wp)) * (2 * «expr‖ ‖» (u - «expr • » half (wq + wp))) +\n              «expr‖ ‖» (wp - wq) * «expr‖ ‖» (wp - wq) :=\n          by ring\n        _ =\n            (exprabsR) (2 : exprℝ) * «expr‖ ‖» (u - «expr • » half (wq + wp)) *\n                ((exprabsR) (2 : exprℝ) * «expr‖ ‖» (u - «expr • » half (wq + wp))) +\n              «expr‖ ‖» (wp - wq) * «expr‖ ‖» (wp - wq) :=\n          by\n          rw [_root_.abs_of_nonneg]\n          exact zero_le_two\n        _ =\n            «expr‖ ‖» («expr • » (2 : exprℝ) (u - «expr • » half (wq + wp))) *\n                «expr‖ ‖» («expr • » (2 : exprℝ) (u - «expr • » half (wq + wp))) +\n              «expr‖ ‖» (wp - wq) * «expr‖ ‖» (wp - wq) :=\n          by simp [norm_smul]\n        _ = «expr‖ ‖» (a + b) * «expr‖ ‖» (a + b) + «expr‖ ‖» (a - b) * «expr‖ ‖» (a - b) :=\n          by\n          rw [smul_sub, smul_smul, mul_one_div_cancel (_root_.two_ne_zero : (2 : exprℝ) ≠ 0), ← one_add_one_eq_two,\n            add_smul]\n          simp only [one_smul]\n          have eq₁ : wp - wq = a - b := (sub_sub_sub_cancel_left _ _ _).symm\n          have eq₂ : u + u - (wq + wp) = a + b\n          show u + u - (wq + wp) = u - wq + (u - wp)\n          abel\n          rw [eq₁, eq₂]\n        _ = 2 * («expr‖ ‖» a * «expr‖ ‖» a + «expr‖ ‖» b * «expr‖ ‖» b) := parallelogram_law_with_norm (exprℝ) _ _\n        \n    have eq : δ ≤ «expr‖ ‖» (u - «expr • » half (wq + wp)) :=\n      by\n      rw [smul_add]\n      apply δ_le'\n      apply h₂\n      repeat' exact Subtype.mem _\n      repeat' exact le_of_lt one_half_pos\n      exact add_halves 1\n    have eq₁ : 4 * δ * δ ≤ 4 * «expr‖ ‖» (u - «expr • » half (wq + wp)) * «expr‖ ‖» (u - «expr • » half (wq + wp)) :=\n      by\n      simp_rw [mul_assoc]\n      exact mul_le_mul_of_nonneg_left (mul_self_le_mul_self zero_le_δ Eq) zero_le_four\n    have eq₂ : «expr‖ ‖» a * «expr‖ ‖» a ≤ (δ + div) * (δ + div) :=\n      mul_self_le_mul_self (norm_nonneg _) (le_trans (le_of_lt <| hw q) (add_le_add_left (Nat.one_div_le_one_div hq) _))\n    have eq₂' : «expr‖ ‖» b * «expr‖ ‖» b ≤ (δ + div) * (δ + div) :=\n      mul_self_le_mul_self (norm_nonneg _) (le_trans (le_of_lt <| hw p) (add_le_add_left (Nat.one_div_le_one_div hp) _))\n    rw [dist_eq_norm]\n    apply nonneg_le_nonneg_of_sq_le_sq\n    · exact sqrt_nonneg _\n    rw [mul_self_sqrt]\n    calc\n      «expr‖ ‖» (wp - wq) * «expr‖ ‖» (wp - wq) =\n          2 * («expr‖ ‖» a * «expr‖ ‖» a + «expr‖ ‖» b * «expr‖ ‖» b) -\n            4 * «expr‖ ‖» (u - «expr • » half (wq + wp)) * «expr‖ ‖» (u - «expr • » half (wq + wp)) :=\n        by\n        rw [← this]\n        simp\n      _ ≤ 2 * («expr‖ ‖» a * «expr‖ ‖» a + «expr‖ ‖» b * «expr‖ ‖» b) - 4 * δ * δ := (sub_le_sub_left eq₁ _)\n      _ ≤ 2 * ((δ + div) * (δ + div) + (δ + div) * (δ + div)) - 4 * δ * δ :=\n        (sub_le_sub_right (mul_le_mul_of_nonneg_left (add_le_add eq₂ eq₂') (by norm_num)) _)\n      _ = 8 * δ * div + 4 * div * div := by ring\n      \n    exact\n      add_nonneg (mul_nonneg (mul_nonneg (by norm_num) zero_le_δ) (le_of_lt Nat.one_div_pos_of_nat))\n        (mul_nonneg (mul_nonneg (by norm_num) nat.one_div_pos_of_nat.le) nat.one_div_pos_of_nat.le)\n    -- third goal : `tendsto (λ (n : ℕ), sqrt (b n)) at_top (𝓝 0)`\n    apply tendsto.comp\n    · convert continuous_sqrt.continuous_at\n      exact sqrt_zero.symm\n    have eq₁ : tendsto (fun n : ℕ => 8 * δ * (1 / (n + 1))) at_top (nhds (0 : exprℝ)) :=\n      by\n      convert(@tendsto_const_nhds _ _ _ (8 * δ) _).mul tendsto_one_div_add_atTop_nhds_0_nat\n      simp only [MulZeroClass.mul_zero]\n    have : tendsto (fun n : ℕ => (4 : exprℝ) * (1 / (n + 1))) at_top (nhds (0 : exprℝ)) :=\n      by\n      convert(@tendsto_const_nhds _ _ _ (4 : exprℝ) _).mul tendsto_one_div_add_atTop_nhds_0_nat\n      simp only [MulZeroClass.mul_zero]\n    have eq₂ : tendsto (fun n : ℕ => (4 : exprℝ) * (1 / (n + 1)) * (1 / (n + 1))) at_top (nhds (0 : exprℝ)) :=\n      by\n      convert this.mul tendsto_one_div_add_atTop_nhds_0_nat\n      simp only [MulZeroClass.mul_zero]\n    convert eq₁.add eq₂\n    simp only [add_zero]\n  -- Step 3: By completeness of `K`, let `w : ℕ → K` converge to some `v : K`.\n  -- Prove that it satisfies all requirements.\n  rcases cauchySeq_tendsto_of_isComplete h₁ (fun n => _) seq_is_cauchy with ⟨v, hv, w_tendsto⟩\n  use v\n  use hv\n  have h_cont : Continuous fun v => «expr‖ ‖» (u - v) :=\n    Continuous.comp continuous_norm (Continuous.sub continuous_const continuous_id)\n  have : tendsto (fun n => «expr‖ ‖» (u - w n)) at_top (nhds («expr‖ ‖» (u - v)))\n  convert tendsto.comp h_cont.continuous_at w_tendsto\n  exact tendsto_nhds_unique this norm_tendsto\n  exact Subtype.mem _\n#align exists_norm_eq_infi_of_complete_convex exists_norm_eq_infi_of_complete_convex\n\n",
 "eq_zero_of_mem_orthogonal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᗮ» -/\ntheorem eq_zero_of_mem_orthogonal (hK : Dense (K : Set E)) (h : x ∈ «expr ᗮ» K) : x = 0 :=\n  hK.eq_of_sub_mem_orthogonal (by rwa [sub_zero])\n#align eq_zero_of_mem_orthogonal eq_zero_of_mem_orthogonal\n\n",
 "eq_zero_of_inner_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟪ , ⟫» -/\ntheorem eq_zero_of_inner_right (hK : Dense (K : Set E)) (h : ∀ v : K, «expr⟪ , ⟫» (v : E) x = 0) : x = 0 :=\n  hK.eq_of_inner_right fun v => by rw [inner_zero_right, h v]\n#align eq_zero_of_inner_right eq_zero_of_inner_right\n\n",
 "eq_zero_of_inner_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟪ , ⟫» -/\ntheorem eq_zero_of_inner_left (hK : Dense (K : Set E)) (h : ∀ v : K, «expr⟪ , ⟫» x v = 0) : x = 0 :=\n  hK.eq_of_inner_left fun v => by rw [inner_zero_left, h v]\n#align eq_zero_of_inner_left eq_zero_of_inner_left\n\n",
 "eq_sum_orthogonal_projection_self_orthogonal_complement":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᗮ» -/\n/-- In a complete space `E`, a vector splits as the sum of its orthogonal projections onto a\ncomplete submodule `K` and onto the orthogonal complement of `K`.-/\ntheorem eq_sum_orthogonal_projection_self_orthogonal_complement [CompleteSpace E] [CompleteSpace K] (w : E) :\n    w = (orthogonal_projection K w : E) + (orthogonal_projection («expr ᗮ» K) w : E) :=\n  by\n  obtain ⟨y, hy, z, hz, hwyz⟩ := K.exists_sum_mem_mem_orthogonal w\n  convert hwyz\n  · exact eq_orthogonal_projection_of_mem_orthogonal' hy hz hwyz\n  · rw [add_comm] at hwyz\n    refine' eq_orthogonal_projection_of_mem_orthogonal' hz _ hwyz\n    simp [hy]\n#align eq_sum_orthogonal_projection_self_orthogonal_complement eq_sum_orthogonal_projection_self_orthogonal_complement\n\n",
 "eq_orthogonal_projection_of_mem_orthogonal'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᗮ» -/\n/-- A point in `K` with the orthogonality property (here characterized in terms of `Kᗮ`) must be the\northogonal projection. -/\ntheorem eq_orthogonal_projection_of_mem_orthogonal' [CompleteSpace K] {u v z : E} (hv : v ∈ K) (hz : z ∈ «expr ᗮ» K)\n    (hu : u = v + z) : (orthogonal_projection K u : E) = v :=\n  eq_orthogonal_projection_of_mem_orthogonal hv (by simpa [hu] )\n#align eq_orthogonal_projection_of_mem_orthogonal' eq_orthogonal_projection_of_mem_orthogonal'\n\n",
 "eq_orthogonal_projection_of_mem_orthogonal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᗮ» -/\n/-- A point in `K` with the orthogonality property (here characterized in terms of `Kᗮ`) must be the\northogonal projection. -/\ntheorem eq_orthogonal_projection_of_mem_orthogonal [CompleteSpace K] {u v : E} (hv : v ∈ K) (hvo : u - v ∈ «expr ᗮ» K) :\n    (orthogonal_projection K u : E) = v :=\n  eq_orthogonal_projection_fn_of_mem_of_inner_eq_zero hv fun w => inner_eq_zero_symm.mp ∘ hvo w\n#align eq_orthogonal_projection_of_mem_orthogonal eq_orthogonal_projection_of_mem_orthogonal\n\n",
 "eq_orthogonal_projection_of_mem_of_inner_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟪ , ⟫» -/\n/-- The orthogonal projection is the unique point in `K` with the\northogonality property. -/\ntheorem eq_orthogonal_projection_of_mem_of_inner_eq_zero {u v : E} (hvm : v ∈ K)\n    (hvo : ∀ w ∈ K, «expr⟪ , ⟫» (u - v) w = 0) : (orthogonal_projection K u : E) = v :=\n  eq_orthogonal_projection_fn_of_mem_of_inner_eq_zero hvm hvo\n#align eq_orthogonal_projection_of_mem_of_inner_eq_zero eq_orthogonal_projection_of_mem_of_inner_eq_zero\n\n",
 "eq_orthogonal_projection_of_eq_submodule":
 "/-- The orthogonal projections onto equal subspaces are coerced back to the same point in `E`. -/\ntheorem eq_orthogonal_projection_of_eq_submodule {K' : Submodule 𝕜 E} [CompleteSpace K'] (h : K = K') (u : E) :\n    (orthogonal_projection K u : E) = (orthogonal_projection K' u : E) :=\n  by\n  change orthogonal_projection_fn K u = orthogonal_projection_fn K' u\n  congr\n  exact h\n#align eq_orthogonal_projection_of_eq_submodule eq_orthogonal_projection_of_eq_submodule\n\n",
 "eq_orthogonal_projection_fn_of_mem_of_inner_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟪ , ⟫» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟪ , ⟫» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟪ , ⟫» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟪ , ⟫» -/\n/-- The unbundled orthogonal projection is the unique point in `K`\nwith the orthogonality property.  This lemma is only intended for use\nin setting up the bundled version and should not be used once that is\ndefined. -/\ntheorem eq_orthogonal_projection_fn_of_mem_of_inner_eq_zero {u v : E} (hvm : v ∈ K)\n    (hvo : ∀ w ∈ K, «expr⟪ , ⟫» (u - v) w = 0) : orthogonal_projection_fn K u = v :=\n  by\n  rw [← sub_eq_zero, ← @inner_self_eq_zero 𝕜]\n  have hvs : orthogonal_projection_fn K u - v ∈ K := Submodule.sub_mem K (orthogonal_projection_fn_mem u) hvm\n  have huo : «expr⟪ , ⟫» (u - orthogonal_projection_fn K u) (orthogonal_projection_fn K u - v) = 0 :=\n    orthogonal_projection_fn_inner_eq_zero u _ hvs\n  have huv : «expr⟪ , ⟫» (u - v) (orthogonal_projection_fn K u - v) = 0 := hvo _ hvs\n  have houv : «expr⟪ , ⟫» (u - v - (u - orthogonal_projection_fn K u)) (orthogonal_projection_fn K u - v) = 0 := by\n    rw [inner_sub_left, huo, huv, sub_zero]\n  rwa [sub_sub_sub_cancel_left] at houv\n#align eq_orthogonal_projection_fn_of_mem_of_inner_eq_zero eq_orthogonal_projection_fn_of_mem_of_inner_eq_zero\n\n",
 "eq_of_sub_mem_orthogonal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᗮ» -/\n/-- If `S` is dense and `x - y ∈ Kᗮ`, then `x = y`. -/\ntheorem eq_of_sub_mem_orthogonal (hK : Dense (K : Set E)) (h : x - y ∈ «expr ᗮ» K) : x = y :=\n  by\n  rw [dense_iff_topological_closure_eq_top, topological_closure_eq_top_iff] at hK\n  rwa [hK, Submodule.mem_bot, sub_eq_zero] at h\n#align eq_of_sub_mem_orthogonal eq_of_sub_mem_orthogonal\n\n",
 "eq_of_inner_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟪ , ⟫» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟪ , ⟫» -/\ntheorem eq_of_inner_right (hK : Dense (K : Set E)) (h : ∀ v : K, «expr⟪ , ⟫» (v : E) x = «expr⟪ , ⟫» (v : E) y) :\n    x = y :=\n  hK.eq_of_sub_mem_orthogonal (submodule.sub_mem_orthogonal_of_inner_right h)\n#align eq_of_inner_right eq_of_inner_right\n\n",
 "eq_of_inner_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟪ , ⟫» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟪ , ⟫» -/\ntheorem eq_of_inner_left (hK : Dense (K : Set E)) (h : ∀ v : K, «expr⟪ , ⟫» x v = «expr⟪ , ⟫» y v) : x = y :=\n  hK.eq_of_sub_mem_orthogonal (submodule.sub_mem_orthogonal_of_inner_left h)\n#align eq_of_inner_left eq_of_inner_left\n\n"}