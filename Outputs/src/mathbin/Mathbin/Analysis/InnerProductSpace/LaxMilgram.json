{"unique_continuous_linear_equiv_of_bilin":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟪ , ⟫_ℝ» -/\ntheorem unique_continuous_linear_equiv_of_bilin (coercive : is_coercive B) {v f : V}\n    (is_lax_milgram : ∀ w, «expr⟪ , ⟫_ℝ» f w = B v w) : f = coercive.continuous_linear_equiv_of_bilin v :=\n  unique_continuous_linear_map_of_bilin (exprℝ) B is_lax_milgram\n#align unique_continuous_linear_equiv_of_bilin unique_continuous_linear_equiv_of_bilin\n\n",
 "range_eq_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ♯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟪ , ⟫_ℝ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ♯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ♯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem range_eq_top (coercive : is_coercive B) : range («expr ♯» B) = «expr⊤» :=\n  by\n  haveI := coercive.closed_range.complete_space_coe\n  rw [← (range («expr ♯» B)).orthogonal_orthogonal]\n  rw [submodule.eq_top_iff']\n  intro v w mem_w_orthogonal\n  rcases coercive with ⟨C, C_pos, coercivity⟩\n  obtain rfl : w = 0 :=\n    by\n    rw [← norm_eq_zero, ← mul_self_eq_zero, ← mul_right_inj' C_pos.ne', mul_zero, ← mul_assoc]\n    apply le_antisymm\n    ·\n      calc\n        C * «expr‖ ‖» w * «expr‖ ‖» w ≤ B w w := coercivity w\n        _ = «expr⟪ , ⟫_ℝ» ((«expr ♯» B) w) w := (continuous_linear_map_of_bilin_apply (exprℝ) B w w).symm\n        _ = 0 := mem_w_orthogonal _ ⟨w, rfl⟩\n        \n    · exact mul_nonneg (mul_nonneg C_pos.le (norm_nonneg w)) (norm_nonneg w)\n  exact inner_zero_left\n#align range_eq_top range_eq_top\n\n",
 "ker_eq_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ♯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem ker_eq_bot (coercive : is_coercive B) : ker («expr ♯» B) = «expr⊥» :=\n  by\n  rw [linear_map_class.ker_eq_bot]\n  rcases coercive.antilipschitz with ⟨_, _, antilipschitz⟩\n  exact antilipschitz.injective\n#align ker_eq_bot ker_eq_bot\n\n",
 "continuous_linear_equiv_of_bilin_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟪ , ⟫_ℝ» -/\n@[simp]\ntheorem continuous_linear_equiv_of_bilin_apply (coercive : is_coercive B) (v w : V) :\n    «expr⟪ , ⟫_ℝ» (coercive.continuous_linear_equiv_of_bilin v) w = B v w :=\n  continuous_linear_map_of_bilin_apply (exprℝ) B v w\n#align continuous_linear_equiv_of_bilin_apply continuous_linear_equiv_of_bilin_apply\n\n",
 "closed_range":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ♯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ♯» -/\ntheorem closed_range (coercive : is_coercive B) : is_closed (range («expr ♯» B) : set V) :=\n  by\n  rcases coercive.antilipschitz with ⟨_, _, antilipschitz⟩\n  exact antilipschitz.is_closed_range («expr ♯» B).uniform_continuous\n#align closed_range closed_range\n\n",
 "bounded_below":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟪ , ⟫_ℝ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ♯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ♯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ♯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ♯» -/\n/-\nCopyright (c) 2022 Daniel Roca González. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Daniel Roca González\n-/\ntheorem bounded_below (coercive : is_coercive B) : ∃ C, 0 < C ∧ ∀ v, C * «expr‖ ‖» v ≤ «expr‖ ‖» ((«expr ♯» B) v) :=\n  by\n  rcases coercive with ⟨C, C_ge_0, coercivity⟩\n  refine' ⟨C, C_ge_0, _⟩\n  intro v\n  by_cases h : 0 < «expr‖ ‖» v\n  · refine' (mul_le_mul_right h).mp _\n    calc\n      C * «expr‖ ‖» v * «expr‖ ‖» v ≤ B v v := coercivity v\n      _ = «expr⟪ , ⟫_ℝ» ((«expr ♯» B) v) v := (continuous_linear_map_of_bilin_apply (exprℝ) B v v).symm\n      _ ≤ «expr‖ ‖» ((«expr ♯» B) v) * «expr‖ ‖» v := real_inner_le_norm ((«expr ♯» B) v) v\n      \n  · have : v = 0 := by simpa using h\n    simp [this]\n#align bounded_below bounded_below\n\n",
 "antilipschitz":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ♯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ♯» -/\ntheorem antilipschitz (coercive : is_coercive B) : ∃ C : nnreal, 0 < C ∧ antilipschitz_with C («expr ♯» B) :=\n  by\n  rcases coercive.bounded_below with ⟨C, C_pos, below_bound⟩\n  refine' ⟨C⁻¹.to_nnreal, real.to_nnreal_pos.mpr (inv_pos.mpr C_pos), _⟩\n  refine' continuous_linear_map.antilipschitz_of_bound («expr ♯» B) _\n  simp_rw [real.coe_to_nnreal', max_eq_left_of_lt (inv_pos.mpr C_pos), ← inv_mul_le_iff (inv_pos.mpr C_pos)]\n  simpa using below_bound\n#align antilipschitz antilipschitz\n\n"}