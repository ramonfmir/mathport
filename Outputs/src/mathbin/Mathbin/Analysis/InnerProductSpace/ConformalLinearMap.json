{"is_conformal_map_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `inner.real -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `inner.real -/\n/-\nCopyright (c) 2021 Yourong Zang. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yourong Zang\n-/\n/-- A map between two inner product spaces is a conformal map if and only if it preserves inner\nproducts up to a scalar factor, i.e., there exists a positive `c : ℝ` such that `⟪f u, f v⟫ = c *\n⟪u, v⟫` for all `u`, `v`. -/\ntheorem is_conformal_map_iff (f : «expr →L[ ] » E (exprℝ) F) :\n    is_conformal_map f ↔ ∃ c : exprℝ, 0 < c ∧ ∀ u v : E, inner.real (f u) (f v) = c * inner.real u v :=\n  by\n  constructor\n  · rintro ⟨c₁, hc₁, li, rfl⟩\n    refine' ⟨c₁ * c₁, mul_self_pos.2 hc₁, fun u v => _⟩\n    simp only [real_inner_smul_left, real_inner_smul_right, mul_assoc, coe_smul', coe_to_continuous_linear_map,\n      pi.smul_apply, inner_map_map]\n  · rintro ⟨c₁, hc₁, huv⟩\n    obtain ⟨c, hc, rfl⟩ : ∃ c : exprℝ, 0 < c ∧ c₁ = c * c\n    exact ⟨real.sqrt c₁, real.sqrt_pos.2 hc₁, (real.mul_self_sqrt hc₁.le).symm⟩\n    refine' ⟨c, hc.ne', («expr • » c⁻¹ f : «expr →ₗ[ ] » E (exprℝ) F).isometry_of_inner fun u v => _, _⟩\n    ·\n      simp only [real_inner_smul_left, real_inner_smul_right, huv, mul_assoc, coe_smul, inv_mul_cancel_left₀ hc.ne',\n        linear_map.smul_apply, continuous_linear_map.coe_coe]\n    · ext1 x\n      exact (smul_inv_smul₀ hc.ne' (f x)).symm\n#align is_conformal_map_iff is_conformal_map_iff\n\n"}