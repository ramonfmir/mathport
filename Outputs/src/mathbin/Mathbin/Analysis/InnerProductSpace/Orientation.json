{"volume_form_zero_pos":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n@[simp]\ntheorem volume_form_zero_pos [_i : Fact (finrank (exprℝ) E = 0)] :\n    orientation.volume_form (positive_orientation : Orientation (exprℝ) E (Fin 0)) =\n      AlternatingMap.constLinearEquivOfIsEmpty 1 :=\n  by simp [volume_form, Or.by_cases, if_pos]\n#align volume_form_zero_pos volume_form_zero_pos\n\n",
 "volume_form_zero_neg":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem volume_form_zero_neg [_i : Fact (finrank (exprℝ) E = 0)] :\n    orientation.volume_form (-positive_orientation : Orientation (exprℝ) E (Fin 0)) =\n      -AlternatingMap.constLinearEquivOfIsEmpty 1 :=\n  by\n  dsimp [volume_form, Or.by_cases, positive_orientation]\n  apply if_neg\n  rw [ray_eq_iff, SameRay.sameRay_comm]\n  intro h\n  simpa using congr_arg alternating_map.const_linear_equiv_of_is_empty.symm (eq_zero_of_sameRay_self_neg h)\n#align volume_form_zero_neg volume_form_zero_neg\n\n",
 "volume_form_robust_neg":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- The volume form on an oriented real inner product space can be evaluated as the determinant with\nrespect to any orthonormal basis of the space compatible with the orientation. -/\ntheorem volume_form_robust_neg (b : orthonormal_basis (Fin n) (exprℝ) E) (hb : b.to_basis.orientation ≠ o) :\n    o.volume_form = -b.to_basis.det := by\n  cases n\n  ·\n    classical\n      have : positive_orientation ≠ o := by rwa [b.to_basis.orientation_is_empty] at hb\n      simp [volume_form, Or.by_cases, dif_neg this.symm]\n  let e : orthonormal_basis (Fin n.succ) (exprℝ) E := o.fin_orthonormal_basis n.succ_pos (fact.out _)\n  dsimp [volume_form]\n  apply e.det_eq_neg_det_of_opposite_orientation b\n  convert hb.symm\n  exact o.fin_orthonormal_basis_orientation _ _\n#align volume_form_robust_neg volume_form_robust_neg\n\n",
 "volume_form_robust'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem volume_form_robust' (b : orthonormal_basis (Fin n) (exprℝ) E) (v : Fin n → E) :\n    |o.volume_form v| = |b.to_basis.det v| := by\n  cases n\n  · refine' o.eq_or_eq_neg_of_is_empty.elim _ _ <;> rintro rfl <;> simp\n  ·\n    rw [o.volume_form_robust (b.adjust_to_orientation o) (b.orientation_adjust_to_orientation o),\n      b.abs_det_adjust_to_orientation]\n#align volume_form_robust' volume_form_robust'\n\n",
 "volume_form_robust":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- The volume form on an oriented real inner product space can be evaluated as the determinant with\nrespect to any orthonormal basis of the space compatible with the orientation. -/\ntheorem volume_form_robust (b : orthonormal_basis (Fin n) (exprℝ) E) (hb : b.to_basis.orientation = o) :\n    o.volume_form = b.to_basis.det := by\n  cases n\n  ·\n    classical\n      have : o = positive_orientation := hb.symm.trans b.to_basis.orientation_is_empty\n      simp [volume_form, Or.by_cases, dif_pos this]\n  · dsimp [volume_form]\n    rw [same_orientation_iff_det_eq_det, hb]\n    exact o.fin_orthonormal_basis_orientation _ _\n#align volume_form_robust volume_form_robust\n\n",
 "volume_form_neg_orientation":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n@[simp]\ntheorem volume_form_neg_orientation : (-o).volume_form = -o.volume_form :=\n  by\n  cases n\n  · refine' o.eq_or_eq_neg_of_is_empty.elim _ _ <;> rintro rfl <;> simp [volume_form_zero_neg]\n  let e : orthonormal_basis (Fin n.succ) (exprℝ) E := o.fin_orthonormal_basis n.succ_pos (fact.out _)\n  have h₁ : e.to_basis.orientation = o := o.fin_orthonormal_basis_orientation _ _\n  have h₂ : e.to_basis.orientation ≠ -o := by\n    symm\n    rw [e.to_basis.orientation_ne_iff_eq_neg, h₁]\n  rw [o.volume_form_robust e h₁, (-o).volume_form_robust_neg e h₂]\n#align volume_form_neg_orientation volume_form_neg_orientation\n\n",
 "volume_form_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗᵢ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem volume_form_map {F : Type _} [NormedAddCommGroup F] [inner_product_space (exprℝ) F]\n    [Fact (finrank (exprℝ) F = n)] (φ : «expr ≃ₗᵢ[ ] » E (exprℝ) F) (x : Fin n → F) :\n    (Orientation.map (Fin n) φ.to_linear_equiv o).volume_form x = o.volume_form (φ.symm ∘ x) :=\n  by\n  cases n\n  · refine' o.eq_or_eq_neg_of_is_empty.elim _ _ <;> rintro rfl <;> simp\n  let e : orthonormal_basis (Fin n.succ) (exprℝ) E := o.fin_orthonormal_basis n.succ_pos (fact.out _)\n  have he : e.to_basis.orientation = o := o.fin_orthonormal_basis_orientation n.succ_pos (fact.out _)\n  have heφ : (e.map φ).to_basis.orientation = Orientation.map (Fin n.succ) φ.to_linear_equiv o :=\n    by\n    rw [← he]\n    exact e.to_basis.orientation_map φ.to_linear_equiv\n  rw [(Orientation.map (Fin n.succ) φ.to_linear_equiv o).volume_form_robust (e.map φ) heφ]\n  rw [o.volume_form_robust e he]\n  simp\n#align volume_form_map volume_form_map\n\n",
 "volume_form_comp_linear_isometry_equiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗᵢ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- The volume form is invariant under pullback by a positively-oriented isometric automorphism. -/\ntheorem volume_form_comp_linear_isometry_equiv (φ : «expr ≃ₗᵢ[ ] » E (exprℝ) E)\n    (hφ : 0 < (φ.to_linear_equiv : «expr →ₗ[ ] » E (exprℝ) E).det) (x : Fin n → E) :\n    o.volume_form (φ ∘ x) = o.volume_form x :=\n  by\n  convert o.volume_form_map φ (φ ∘ x)\n  · symm\n    rwa [← o.map_eq_iff_det_pos φ.to_linear_equiv] at hφ\n    rw [_i.out, Fintype.card_fin]\n  · ext\n    simp\n#align volume_form_comp_linear_isometry_equiv volume_form_comp_linear_isometry_equiv\n\n",
 "volume_form_apply_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem volume_form_apply_le (v : Fin n → E) :\n    o.volume_form v ≤\n      finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n        («expr‖ ‖» (v i)) :=\n  (le_abs_self _).trans (o.abs_volume_form_apply_le v)\n#align volume_form_apply_le volume_form_apply_le\n\n",
 "to_basis_adjust_to_orientation":
 "theorem to_basis_adjust_to_orientation : (e.adjust_to_orientation x).to_basis = e.to_basis.adjust_to_orientation x :=\n  (e.to_basis.adjust_to_orientation x).to_basis_to_orthonormal_basis _\n#align to_basis_adjust_to_orientation to_basis_adjust_to_orientation\n\n",
 "same_orientation_iff_det_eq_det":
 "/-- Two orthonormal bases with the same orientation determine the same \"determinant\" top-dimensional\nform on `E`, and conversely. -/\ntheorem same_orientation_iff_det_eq_det :\n    e.to_basis.det = f.to_basis.det ↔ e.to_basis.orientation = f.to_basis.orientation :=\n  by\n  constructor\n  · intro h\n    dsimp [Basis.orientation]\n    congr\n  · intro h\n    rw [e.to_basis.det.eq_smul_basis_det f.to_basis]\n    simp [e.det_to_matrix_orthonormal_basis_of_same_orientation f h]\n#align same_orientation_iff_det_eq_det same_orientation_iff_det_eq_det\n\n",
 "orthonormal_adjust_to_orientation":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- `orthonormal_basis.adjust_to_orientation`, applied to an orthonormal basis, preserves the\nproperty of orthonormality. -/\ntheorem orthonormal_adjust_to_orientation : orthonormal (exprℝ) (e.to_basis.adjust_to_orientation x) :=\n  by\n  apply e.orthonormal.orthonormal_of_forall_eq_or_eq_neg\n  simpa using e.to_basis.adjust_to_orientation_apply_eq_or_eq_neg x\n#align orthonormal_adjust_to_orientation orthonormal_adjust_to_orientation\n\n",
 "orientation_adjust_to_orientation":
 "/-- `adjust_to_orientation` gives an orthonormal basis with the required orientation. -/\n@[simp]\ntheorem orientation_adjust_to_orientation : (e.adjust_to_orientation x).to_basis.orientation = x :=\n  by\n  rw [e.to_basis_adjust_to_orientation]\n  exact e.to_basis.orientation_adjust_to_orientation x\n#align orientation_adjust_to_orientation orientation_adjust_to_orientation\n\n",
 "fin_orthonormal_basis_orientation":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- `orientation.fin_orthonormal_basis` gives a basis with the required orientation. -/\n@[simp]\ntheorem fin_orthonormal_basis_orientation (hn : 0 < n) (h : finrank (exprℝ) E = n) (x : Orientation (exprℝ) E (Fin n)) :\n    (x.fin_orthonormal_basis hn h).to_basis.orientation = x :=\n  by\n  haveI := Fin.pos_iff_nonempty.1 hn\n  haveI := finite_dimensional_of_finrank (h.symm ▸ hn : 0 < finrank (exprℝ) E)\n  exact ((std_orthonormal_basis _ _).reindex <| finCongr h).orientation_adjust_to_orientation x\n#align fin_orthonormal_basis_orientation fin_orthonormal_basis_orientation\n\n",
 "det_to_matrix_orthonormal_basis_of_same_orientation":
 "/-\nCopyright (c) 2022 Joseph Myers. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Joseph Myers, Heather Macbeth\n-/\n/-- The change-of-basis matrix between two orthonormal bases with the same orientation has\ndeterminant 1. -/\ntheorem det_to_matrix_orthonormal_basis_of_same_orientation (h : e.to_basis.orientation = f.to_basis.orientation) :\n    e.to_basis.det f = 1 := by\n  apply (e.det_to_matrix_orthonormal_basis_real f).resolve_right\n  have : 0 < e.to_basis.det f := by\n    rw [e.to_basis.orientation_eq_iff_det_pos] at h\n    simpa using h\n  linarith\n#align det_to_matrix_orthonormal_basis_of_same_orientation det_to_matrix_orthonormal_basis_of_same_orientation\n\n",
 "det_to_matrix_orthonormal_basis_of_opposite_orientation":
 "/-- The change-of-basis matrix between two orthonormal bases with the opposite orientations has\ndeterminant -1. -/\ntheorem det_to_matrix_orthonormal_basis_of_opposite_orientation (h : e.to_basis.orientation ≠ f.to_basis.orientation) :\n    e.to_basis.det f = -1 := by\n  contrapose! h\n  simp [e.to_basis.orientation_eq_iff_det_pos, (e.det_to_matrix_orthonormal_basis_real f).resolve_right h]\n#align det_to_matrix_orthonormal_basis_of_opposite_orientation det_to_matrix_orthonormal_basis_of_opposite_orientation\n\n",
 "det_eq_neg_det_of_opposite_orientation":
 "/-- Two orthonormal bases with opposite orientations determine opposite \"determinant\"\ntop-dimensional forms on `E`. -/\ntheorem det_eq_neg_det_of_opposite_orientation (h : e.to_basis.orientation ≠ f.to_basis.orientation) :\n    e.to_basis.det = -f.to_basis.det :=\n  by\n  rw [e.to_basis.det.eq_smul_basis_det f.to_basis]\n  simp [e.det_to_matrix_orthonormal_basis_of_opposite_orientation f h]\n#align det_eq_neg_det_of_opposite_orientation det_eq_neg_det_of_opposite_orientation\n\n",
 "det_adjust_to_orientation":
 "theorem det_adjust_to_orientation :\n    (e.adjust_to_orientation x).to_basis.det = e.to_basis.det ∨\n      (e.adjust_to_orientation x).to_basis.det = -e.to_basis.det :=\n  by simpa using e.to_basis.det_adjust_to_orientation x\n#align det_adjust_to_orientation det_adjust_to_orientation\n\n",
 "adjust_to_orientation_apply_eq_or_eq_neg":
 "/-- Every basis vector from `adjust_to_orientation` is either that from the original basis or its\nnegation. -/\ntheorem adjust_to_orientation_apply_eq_or_eq_neg (i : ι) :\n    e.adjust_to_orientation x i = e i ∨ e.adjust_to_orientation x i = -e i := by\n  simpa [← e.to_basis_adjust_to_orientation] using e.to_basis.adjust_to_orientation_apply_eq_or_eq_neg x i\n#align adjust_to_orientation_apply_eq_or_eq_neg adjust_to_orientation_apply_eq_or_eq_neg\n\n",
 "abs_volume_form_apply_of_pairwise_orthogonal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `inner.real -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `inner.real -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/-- Let `v` be an indexed family of `n` orthogonal vectors in an oriented `n`-dimensional\nreal inner product space `E`. The output of the volume form of `E` when evaluated on `v` is, up to\nsign, the product of the norms of the vectors `v i`. -/\ntheorem abs_volume_form_apply_of_pairwise_orthogonal {v : Fin n → E}\n    (hv : Pairwise fun i j => inner.real (v i) (v j) = 0) :\n    |o.volume_form v| =\n      finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n        («expr‖ ‖» (v i)) :=\n  by\n  cases n\n  · refine' o.eq_or_eq_neg_of_is_empty.elim _ _ <;> rintro rfl <;> simp\n  haveI : FiniteDimensional (exprℝ) E := fact_finite_dimensional_of_finrank_eq_succ n\n  have hdim : finrank (exprℝ) E = Fintype.card (Fin n.succ) := by simpa using _i.out\n  let b : orthonormal_basis (Fin n.succ) (exprℝ) E := gram_schmidt_orthonormal_basis hdim v\n  have hb :\n    b.to_basis.det v =\n      finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n        (inner.real (b i) (v i)) :=\n    gram_schmidt_orthonormal_basis_det hdim v\n  rw [o.volume_form_robust' b, hb, Finset.abs_prod]\n  by_cases h : ∃ i, v i = 0\n  obtain ⟨i, hi⟩ := h\n  · rw [Finset.prod_eq_zero (Finset.mem_univ i), Finset.prod_eq_zero (Finset.mem_univ i)] <;> simp [hi]\n  push_neg  at h\n  congr\n  ext i\n  have hb : b i = «expr • » («expr‖ ‖» (v i))⁻¹ (v i) :=\n    gram_schmidt_orthonormal_basis_apply_of_orthogonal hdim hv (h i)\n  simp only [hb, inner_smul_left, real_inner_self_eq_norm_mul_norm, IsROrC.conj_to_real]\n  rw [abs_of_nonneg]\n  · have : «expr‖ ‖» (v i) ≠ 0 := by simpa using h i\n    field_simp\n  · positivity\n#align abs_volume_form_apply_of_pairwise_orthogonal abs_volume_form_apply_of_pairwise_orthogonal\n\n",
 "abs_volume_form_apply_of_orthonormal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- The output of the volume form of an oriented real inner product space `E` when evaluated on an\northonormal basis is ±1. -/\ntheorem abs_volume_form_apply_of_orthonormal (v : orthonormal_basis (Fin n) (exprℝ) E) : |o.volume_form v| = 1 := by\n  simpa [o.volume_form_robust' v v] using congr_arg abs v.to_basis.det_self\n#align abs_volume_form_apply_of_orthonormal abs_volume_form_apply_of_orthonormal\n\n",
 "abs_volume_form_apply_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `inner.real -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/-- Let `v` be an indexed family of `n` vectors in an oriented `n`-dimensional real inner\nproduct space `E`. The output of the volume form of `E` when evaluated on `v` is bounded in absolute\nvalue by the product of the norms of the vectors `v i`. -/\ntheorem abs_volume_form_apply_le (v : Fin n → E) :\n    |o.volume_form v| ≤\n      finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n        («expr‖ ‖» (v i)) :=\n  by\n  cases n\n  · refine' o.eq_or_eq_neg_of_is_empty.elim _ _ <;> rintro rfl <;> simp\n  haveI : FiniteDimensional (exprℝ) E := fact_finite_dimensional_of_finrank_eq_succ n\n  have : finrank (exprℝ) E = Fintype.card (Fin n.succ) := by simpa using _i.out\n  let b : orthonormal_basis (Fin n.succ) (exprℝ) E := gram_schmidt_orthonormal_basis this v\n  have hb :\n    b.to_basis.det v =\n      finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n        (inner.real (b i) (v i)) :=\n    gram_schmidt_orthonormal_basis_det this v\n  rw [o.volume_form_robust' b, hb, Finset.abs_prod]\n  apply Finset.prod_le_prod\n  · intro i hi\n    positivity\n  intro i hi\n  convert abs_real_inner_le_norm (b i) (v i)\n  simp [b.orthonormal.1 i]\n#align abs_volume_form_apply_le abs_volume_form_apply_le\n\n",
 "abs_det_adjust_to_orientation":
 "theorem abs_det_adjust_to_orientation (v : ι → E) : |(e.adjust_to_orientation x).to_basis.det v| = |e.to_basis.det v| :=\n  by simp [to_basis_adjust_to_orientation]\n#align abs_det_adjust_to_orientation abs_det_adjust_to_orientation\n\n"}