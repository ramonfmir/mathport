{"orthogonal_projection_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âˆ˜L Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âˆ˜L Â» -/\ntheorem is_positive.orthogonal_projection_comp {T : Â«expr â†’L[ ] Â» E ğ•œ E} (hT : T.is_positive) (U : Submodule ğ•œ E)\n    [CompleteSpace U] : (Â«expr âˆ˜L Â» (orthogonal_projection U) (Â«expr âˆ˜L Â» T U.subtypeL)).is_positive :=\n  by\n  have := hT.conj_adjoint (orthogonal_projection U : Â«expr â†’L[ ] Â» E ğ•œ U)\n  rwa [U.adjoint_orthogonal_projection] at this\n#align is_positive.orthogonal_projection_comp is_positive.orthogonal_projection_comp\n\n",
 "is_self_adjoint":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/-\nCopyright (c) 2022 Anatole Dedecker. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Anatole Dedecker\n-/\ntheorem is_positive.is_self_adjoint {T : Â«expr â†’L[ ] Â» E ğ•œ E} (hT : is_positive T) : IsSelfAdjoint T :=\n  hT.1\n#align is_positive.is_self_adjoint is_positive.is_self_adjoint\n\n",
 "is_positive_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŸª , âŸ«Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\ntheorem is_positive_zero : is_positive (0 : Â«expr â†’L[ ] Â» E ğ•œ E) :=\n  by\n  refine' âŸ¨isSelfAdjoint_zero _, fun x => _âŸ©\n  change 0 â‰¤ re (Â«exprâŸª , âŸ«Â» _ _)\n  rw [zero_apply, inner_zero_left, ZeroHomClass.map_zero]\n#align is_positive_zero is_positive_zero\n\n",
 "is_positive_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\ntheorem is_positive_one : is_positive (1 : Â«expr â†’L[ ] Â» E ğ•œ E) :=\n  âŸ¨isSelfAdjoint_one _, fun x => inner_self_nonnegâŸ©\n#align is_positive_one is_positive_one\n\n",
 "is_positive_iff_complex":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„‚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŸª , âŸ«_â„‚Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„‚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŸª , âŸ«_â„‚Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŸª , âŸ«_â„‚Â» -/\ntheorem is_positive_iff_complex (T : Â«expr â†’L[ ] Â» E' (exprâ„‚) E') :\n    is_positive T â†”\n      âˆ€ x, (re (Â«exprâŸª , âŸ«_â„‚Â» (T x) x) : exprâ„‚) = Â«exprâŸª , âŸ«_â„‚Â» (T x) x âˆ§ 0 â‰¤ re (Â«exprâŸª , âŸ«_â„‚Â» (T x) x) :=\n  by\n  simp_rw [is_positive, forall_and, is_self_adjoint_iff_is_symmetric, linear_map.is_symmetric_iff_inner_map_self_real,\n    conj_eq_iff_re]\n  rfl\n#align is_positive_iff_complex is_positive_iff_complex\n\n",
 "inner_nonneg_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŸª , âŸ«Â» -/\ntheorem is_positive.inner_nonneg_right {T : Â«expr â†’L[ ] Â» E ğ•œ E} (hT : is_positive T) (x : E) :\n    0 â‰¤ re (Â«exprâŸª , âŸ«Â» x (T x)) := by rw [inner_re_symm] <;> exact hT.inner_nonneg_left x\n#align is_positive.inner_nonneg_right is_positive.inner_nonneg_right\n\n",
 "inner_nonneg_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŸª , âŸ«Â» -/\ntheorem is_positive.inner_nonneg_left {T : Â«expr â†’L[ ] Â» E ğ•œ E} (hT : is_positive T) (x : E) :\n    0 â‰¤ re (Â«exprâŸª , âŸ«Â» (T x) x) :=\n  hT.2 x\n#align is_positive.inner_nonneg_left is_positive.inner_nonneg_left\n\n",
 "conj_orthogonal_projection":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âˆ˜L Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âˆ˜L Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âˆ˜L Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âˆ˜L Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âˆ˜L Â» -/\ntheorem is_positive.conj_orthogonal_projection (U : Submodule ğ•œ E) {T : Â«expr â†’L[ ] Â» E ğ•œ E} (hT : T.is_positive)\n    [CompleteSpace U] :\n    (Â«expr âˆ˜L Â» U.subtypeL\n        (Â«expr âˆ˜L Â» (orthogonal_projection U)\n          (Â«expr âˆ˜L Â» T (Â«expr âˆ˜L Â» U.subtypeL (orthogonal_projection U))))).is_positive :=\n  by\n  have := hT.conj_adjoint (Â«expr âˆ˜L Â» U.subtypeL (orthogonal_projection U))\n  rwa [(orthogonal_projection_is_self_adjoint U).adjoint_eq] at this\n#align is_positive.conj_orthogonal_projection is_positive.conj_orthogonal_projection\n\n",
 "conj_adjoint":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âˆ˜L Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âˆ˜L Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `adjoint -/\ntheorem is_positive.conj_adjoint {T : Â«expr â†’L[ ] Â» E ğ•œ E} (hT : T.is_positive) (S : Â«expr â†’L[ ] Â» E ğ•œ F) :\n    (Â«expr âˆ˜L Â» S (Â«expr âˆ˜L Â» T (adjoint S))).is_positive :=\n  by\n  refine' âŸ¨hT.is_self_adjoint.conj_adjoint S, fun x => _âŸ©\n  rw [re_apply_inner_self, comp_apply, â† adjoint_inner_right]\n  exact hT.inner_nonneg_left _\n#align is_positive.conj_adjoint is_positive.conj_adjoint\n\n",
 "adjoint_conj":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `adjoint -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âˆ˜L Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `adjoint -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âˆ˜L Â» -/\ntheorem is_positive.adjoint_conj {T : Â«expr â†’L[ ] Â» E ğ•œ E} (hT : T.is_positive) (S : Â«expr â†’L[ ] Â» F ğ•œ E) :\n    (Â«expr âˆ˜L Â» (adjoint S) (Â«expr âˆ˜L Â» T S)).is_positive :=\n  by\n  convert hT.conj_adjoint (adjoint S)\n  rw [adjoint_adjoint]\n#align is_positive.adjoint_conj is_positive.adjoint_conj\n\n",
 "add":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\ntheorem is_positive.add {T S : Â«expr â†’L[ ] Â» E ğ•œ E} (hT : T.is_positive) (hS : S.is_positive) : (T + S).is_positive :=\n  by\n  refine' âŸ¨hT.is_self_adjoint.add hS.is_self_adjoint, fun x => _âŸ©\n  rw [re_apply_inner_self, add_apply, inner_add_left, map_add]\n  exact add_nonneg (hT.inner_nonneg_left x) (hS.inner_nonneg_left x)\n#align is_positive.add is_positive.add\n\n"}