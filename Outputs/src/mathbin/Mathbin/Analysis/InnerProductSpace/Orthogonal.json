{"top_orthogonal_eq_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᗮ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem top_orthogonal_eq_bot : «expr ᗮ» («expr⊤» : Submodule 𝕜 E) = «expr⊥» :=\n  by\n  ext\n  rw [mem_bot, mem_orthogonal]\n  exact\n    ⟨fun h => inner_self_eq_zero.mp (h x mem_top), by\n      rintro rfl\n      simp⟩\n#align top_orthogonal_eq_bot top_orthogonal_eq_bot\n\n",
 "symmetric_is_ortho":
 "theorem symmetric_is_ortho : symmetric (is_ortho : Submodule 𝕜 E → Submodule 𝕜 E → Prop) := fun _ _ => is_ortho.symm\n#align symmetric_is_ortho symmetric_is_ortho\n\n",
 "symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟂ » -/\n@[symm]\ntheorem is_ortho.symm {U V : Submodule 𝕜 E} (h : «expr ⟂ » U V) : «expr ⟂ » V U :=\n  (le_orthogonal_orthogonal _).trans (orthogonal_le h)\n#align is_ortho.symm is_ortho.symm\n\n",
 "sub_mem_orthogonal_of_inner_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟪ , ⟫» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟪ , ⟫» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᗮ» -/\ntheorem sub_mem_orthogonal_of_inner_right {x y : E} (h : ∀ v : K, «expr⟪ , ⟫» (v : E) x = «expr⟪ , ⟫» (v : E) y) :\n    x - y ∈ «expr ᗮ» K := by\n  intro u hu\n  rw [inner_sub_right, sub_eq_zero]\n  exact h ⟨u, hu⟩\n#align sub_mem_orthogonal_of_inner_right sub_mem_orthogonal_of_inner_right\n\n",
 "sub_mem_orthogonal_of_inner_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟪ , ⟫» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟪ , ⟫» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᗮ» -/\ntheorem sub_mem_orthogonal_of_inner_left {x y : E} (h : ∀ v : K, «expr⟪ , ⟫» x v = «expr⟪ , ⟫» y v) :\n    x - y ∈ «expr ᗮ» K := by\n  rw [mem_orthogonal']\n  intro u hu\n  rw [inner_sub_left, sub_eq_zero]\n  exact h ⟨u, hu⟩\n#align sub_mem_orthogonal_of_inner_left sub_mem_orthogonal_of_inner_left\n\n",
 "orthogonal_orthogonal_monotone":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᗮ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᗮ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᗮ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᗮ» -/\n/-- `orthogonal.orthogonal` preserves the `≤` ordering of two\nsubspaces. -/\ntheorem orthogonal_orthogonal_monotone {K₁ K₂ : Submodule 𝕜 E} (h : K₁ ≤ K₂) :\n    «expr ᗮ» («expr ᗮ» K₁) ≤ «expr ᗮ» («expr ᗮ» K₂) :=\n  orthogonal_le (orthogonal_le h)\n#align orthogonal_orthogonal_monotone orthogonal_orthogonal_monotone\n\n",
 "orthogonal_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᗮ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᗮ» -/\n/-- `orthogonal` reverses the `≤` ordering of two\nsubspaces. -/\ntheorem orthogonal_le {K₁ K₂ : Submodule 𝕜 E} (h : K₁ ≤ K₂) : «expr ᗮ» K₂ ≤ «expr ᗮ» K₁ :=\n  (orthogonal_gc 𝕜 E).monotone_l h\n#align orthogonal_le orthogonal_le\n\n",
 "orthogonal_gc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/-- `orthogonal` gives a `galois_connection` between\n`submodule 𝕜 E` and its `order_dual`. -/\ntheorem orthogonal_gc : @GaloisConnection (Submodule 𝕜 E) («expr ᵒᵈ» (Submodule 𝕜 E)) _ _ orthogonal orthogonal :=\n  fun K₁ K₂ =>\n  ⟨fun h v hv u hu => inner_left_of_mem_orthogonal hv (h hu), fun h v hv u hu => inner_left_of_mem_orthogonal hv (h hu)⟩\n#align orthogonal_gc orthogonal_gc\n\n",
 "orthogonal_family_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᗮ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᗮ» -/\ntheorem orthogonal_family_self :\n    orthogonal_family 𝕜 (fun b => «expr↥ » (cond b K («expr ᗮ» K))) fun b => (cond b K («expr ᗮ» K)).subtypeₗᵢ\n  | tt, tt => absurd rfl\n  | tt, ff => fun _ x y => inner_right_of_mem_orthogonal x.prop y.prop\n  | ff, tt => fun _ x y => inner_left_of_mem_orthogonal y.prop x.prop\n  | ff, ff => absurd rfl\n#align orthogonal_family_self orthogonal_family_self\n\n",
 "orthogonal_family_iff_pairwise":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr on » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:219:4: warning: unsupported binary notation `«expr ⟂ » -/\ntheorem orthogonal_family_iff_pairwise {ι} {V : ι → Submodule 𝕜 E} :\n    (orthogonal_family 𝕜 (fun i => V i) fun i => (V i).subtypeₗᵢ) ↔ Pairwise («expr on » («expr ⟂ » · ·) V) :=\n  forall₃_congr fun i j hij =>\n    Subtype.forall.trans <|\n      forall₂_congr fun x hx => Subtype.forall.trans <| forall₂_congr fun y hy => inner_eq_zero_symm\n#align orthogonal_family_iff_pairwise orthogonal_family_iff_pairwise\n\n",
 "orthogonal_eq_top_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᗮ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᗮ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem orthogonal_eq_top_iff : «expr ᗮ» K = «expr⊤» ↔ K = «expr⊥» :=\n  by\n  refine'\n    ⟨_, by\n      rintro rfl\n      exact bot_orthogonal_eq_top⟩\n  intro h\n  have : «expr ⊓ » K («expr ᗮ» K) = «expr⊥» := K.orthogonal_disjoint.eq_bot\n  rwa [h, inf_comm, top_inf_eq] at this\n#align orthogonal_eq_top_iff orthogonal_eq_top_iff\n\n",
 "orthogonal_eq_inter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᗮ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/-- `Kᗮ` can be characterized as the intersection of the kernels of the operations of\ninner product with each of the elements of `K`. -/\ntheorem orthogonal_eq_inter :\n    «expr ᗮ» K =\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n        (LinearMap.ker (innerSL 𝕜 (v : E))) :=\n  by\n  apply le_antisymm\n  · rw [le_infᵢ_iff]\n    rintro ⟨v, hv⟩ w hw\n    simpa using hw _ hv\n  · intro v hv w hw\n    simp only [mem_infi] at hv\n    exact hv ⟨w, hw⟩\n#align orthogonal_eq_inter orthogonal_eq_inter\n\n",
 "orthogonal_disjoint":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᗮ» -/\n/-- `K` and `Kᗮ` have trivial intersection. -/\ntheorem orthogonal_disjoint : Disjoint K («expr ᗮ» K) := by simp [disjoint_iff, K.inf_orthogonal_eq_bot]\n#align orthogonal_disjoint orthogonal_disjoint\n\n",
 "mono_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟂ » -/\ntheorem is_ortho.mono_right {U V₁ V₂ : Submodule 𝕜 E} (hV : V₂ ≤ V₁) (h : «expr ⟂ » U V₁) : «expr ⟂ » U V₂ :=\n  (h.symm.mono_left hV).symm\n#align is_ortho.mono_right is_ortho.mono_right\n\n",
 "mono_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟂ » -/\ntheorem is_ortho.mono_left {U₁ U₂ V : Submodule 𝕜 E} (hU : U₂ ≤ U₁) (h : «expr ⟂ » U₁ V) : «expr ⟂ » U₂ V :=\n  hU.trans h\n#align is_ortho.mono_left is_ortho.mono_left\n\n",
 "mono":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟂ » -/\ntheorem is_ortho.mono {U₁ V₁ U₂ V₂ : Submodule 𝕜 E} (hU : U₂ ≤ U₁) (hV : V₂ ≤ V₁) (h : «expr ⟂ » U₁ V₁) :\n    «expr ⟂ » U₂ V₂ :=\n  (h.mono_right hV).mono_left hU\n#align is_ortho.mono is_ortho.mono\n\n",
 "mem_orthogonal_singleton_iff_inner_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᗮ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟪ , ⟫» -/\n/-- A vector is in `(𝕜 ∙ u)ᗮ` iff it is orthogonal to `u`. -/\ntheorem mem_orthogonal_singleton_iff_inner_right {u v : E} : v ∈ «expr ᗮ» («expr ∙ » 𝕜 u) ↔ «expr⟪ , ⟫» u v = 0 :=\n  by\n  refine' ⟨inner_right_of_mem_orthogonal (mem_span_singleton_self u), _⟩\n  intro hv w hw\n  rw [mem_span_singleton] at hw\n  obtain ⟨c, rfl⟩ := hw\n  simp [inner_smul_left, hv]\n#align mem_orthogonal_singleton_iff_inner_right mem_orthogonal_singleton_iff_inner_right\n\n",
 "mem_orthogonal_singleton_iff_inner_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᗮ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟪ , ⟫» -/\n/-- A vector in `(𝕜 ∙ u)ᗮ` is orthogonal to `u`. -/\ntheorem mem_orthogonal_singleton_iff_inner_left {u v : E} : v ∈ «expr ᗮ» («expr ∙ » 𝕜 u) ↔ «expr⟪ , ⟫» v u = 0 := by\n  rw [mem_orthogonal_singleton_iff_inner_right, inner_eq_zero_symm]\n#align mem_orthogonal_singleton_iff_inner_left mem_orthogonal_singleton_iff_inner_left\n\n",
 "mem_orthogonal'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᗮ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟪ , ⟫» -/\n/-- When a vector is in `Kᗮ`, with the inner product the\nother way round. -/\ntheorem mem_orthogonal' (v : E) : v ∈ «expr ᗮ» K ↔ ∀ u ∈ K, «expr⟪ , ⟫» v u = 0 := by\n  simp_rw [mem_orthogonal, inner_eq_zero_symm]\n#align mem_orthogonal' mem_orthogonal'\n\n",
 "mem_orthogonal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᗮ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟪ , ⟫» -/\n/-\nCopyright (c) 2019 Zhouhang Zhou. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Zhouhang Zhou, Sébastien Gouëzel, Frédéric Dupuis\n-/\n/-- When a vector is in `Kᗮ`. -/\ntheorem mem_orthogonal (v : E) : v ∈ «expr ᗮ» K ↔ ∀ u ∈ K, «expr⟪ , ⟫» u v = 0 :=\n  iff.rfl\n#align mem_orthogonal mem_orthogonal\n\n",
 "map_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗᵢ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟂ » -/\n@[simp]\ntheorem is_ortho.map_iff (f : «expr ≃ₗᵢ[ ] » E 𝕜 F) {U V : Submodule 𝕜 E} :\n    «expr ⟂ » (U.map f) (V.map f) ↔ «expr ⟂ » U V :=\n  ⟨fun h =>\n    by\n    have hf : ∀ p : Submodule 𝕜 E, (p.map f).comap f.to_linear_isometry = p := comap_map_eq_of_injective f.injective\n    simpa only [hf] using h.comap f.to_linear_isometry, is_ortho.map f.to_linear_isometry⟩\n#align is_ortho.map_iff is_ortho.map_iff\n\n",
 "map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗᵢ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟂ » -/\ntheorem is_ortho.map (f : «expr →ₗᵢ[ ] » E 𝕜 F) {U V : Submodule 𝕜 E} (h : «expr ⟂ » U V) :\n    «expr ⟂ » (U.map f) (V.map f) := by\n  rw [is_ortho_iff_inner_eq] at *\n  simp_rw [mem_map, forall_exists_index, and_imp, forall_apply_eq_imp_iff₂, linear_isometry.inner_map_map]\n  exact h\n#align is_ortho.map is_ortho.map\n\n",
 "le_orthogonal_orthogonal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᗮ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᗮ» -/\n/-- `K` is contained in `Kᗮᗮ`. -/\ntheorem le_orthogonal_orthogonal : K ≤ «expr ᗮ» («expr ᗮ» K) :=\n  (orthogonal_gc 𝕜 E).le_u_l _\n#align le_orthogonal_orthogonal le_orthogonal_orthogonal\n\n",
 "le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᗮ» -/\ntheorem is_ortho.le {U V : Submodule 𝕜 E} (h : «expr ⟂ » U V) : U ≤ «expr ᗮ» V :=\n  h\n#align is_ortho.le is_ortho.le\n\n",
 "is_ortho_top_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem is_ortho_top_right {U : Submodule 𝕜 E} : «expr ⟂ » U («expr⊤») ↔ U = «expr⊥» :=\n  ⟨fun h => eq_bot_iff.mpr fun x hx => inner_self_eq_zero.mp (h hx _ mem_top), fun h => h.symm ▸ is_ortho_bot_left⟩\n#align is_ortho_top_right is_ortho_top_right\n\n",
 "is_ortho_top_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem is_ortho_top_left {V : Submodule 𝕜 E} : «expr ⟂ » («expr⊤») V ↔ V = «expr⊥» :=\n  is_ortho_comm.trans is_ortho_top_right\n#align is_ortho_top_left is_ortho_top_left\n\n",
 "is_ortho_supr_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟂ » -/\n@[simp]\ntheorem is_ortho_supr_right {ι : Sort _} {U : Submodule 𝕜 E} {V : ι → Submodule 𝕜 E} :\n    «expr ⟂ » U (supᵢ V) ↔ ∀ i, «expr ⟂ » U (V i) :=\n  is_ortho_comm.trans <| is_ortho_supr_left.trans <| by simp_rw [is_ortho_comm]\n#align is_ortho_supr_right is_ortho_supr_right\n\n",
 "is_ortho_supr_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟂ » -/\n@[simp]\ntheorem is_ortho_supr_left {ι : Sort _} {U : ι → Submodule 𝕜 E} {V : Submodule 𝕜 E} :\n    «expr ⟂ » (supᵢ U) V ↔ ∀ i, «expr ⟂ » (U i) V :=\n  supᵢ_le_iff\n#align is_ortho_supr_left is_ortho_supr_left\n\n",
 "is_ortho_sup_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟂ » -/\n@[simp]\ntheorem is_ortho_sup_right {U V₁ V₂ : Submodule 𝕜 E} :\n    «expr ⟂ » U («expr ⊔ » V₁ V₂) ↔ «expr ⟂ » U V₁ ∧ «expr ⟂ » U V₂ :=\n  is_ortho_comm.trans <| is_ortho_sup_left.trans <| is_ortho_comm.and is_ortho_comm\n#align is_ortho_sup_right is_ortho_sup_right\n\n",
 "is_ortho_sup_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟂ » -/\n@[simp]\ntheorem is_ortho_sup_left {U₁ U₂ V : Submodule 𝕜 E} : «expr ⟂ » («expr ⊔ » U₁ U₂) V ↔ «expr ⟂ » U₁ V ∧ «expr ⟂ » U₂ V :=\n  sup_le_iff\n#align is_ortho_sup_left is_ortho_sup_left\n\n",
 "is_ortho_span":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟪ , ⟫» -/\n@[simp]\ntheorem is_ortho_span {s t : Set E} :\n    «expr ⟂ » (span 𝕜 s) (span 𝕜 t) ↔ ∀ ⦃u⦄, u ∈ s → ∀ ⦃v⦄, v ∈ t → «expr⟪ , ⟫» u v = 0 := by\n  simp_rw [span_eq_supr_of_singleton_spans s, span_eq_supr_of_singleton_spans t, is_ortho_supr_left,\n    is_ortho_supr_right, is_ortho_iff_le, span_le, Set.subset_def, SetLike.mem_coe,\n    mem_orthogonal_singleton_iff_inner_left, Set.mem_singleton_iff, forall_eq]\n#align is_ortho_span is_ortho_span\n\n",
 "is_ortho_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem is_ortho_self {U : Submodule 𝕜 E} : «expr ⟂ » U U ↔ U = «expr⊥» :=\n  ⟨fun h => eq_bot_iff.mpr fun x hx => inner_self_eq_zero.mp (h hx x hx), fun h => h.symm ▸ is_ortho_bot_left⟩\n#align is_ortho_self is_ortho_self\n\n",
 "is_ortho_orthogonal_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᗮ» -/\n@[simp]\ntheorem is_ortho_orthogonal_right (U : Submodule 𝕜 E) : «expr ⟂ » U («expr ᗮ» U) :=\n  le_orthogonal_orthogonal _\n#align is_ortho_orthogonal_right is_ortho_orthogonal_right\n\n",
 "is_ortho_orthogonal_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᗮ» -/\n@[simp]\ntheorem is_ortho_orthogonal_left (U : Submodule 𝕜 E) : «expr ⟂ » («expr ᗮ» U) U :=\n  (is_ortho_orthogonal_right U).symm\n#align is_ortho_orthogonal_left is_ortho_orthogonal_left\n\n",
 "is_ortho_iff_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᗮ» -/\ntheorem is_ortho_iff_le {U V : Submodule 𝕜 E} : «expr ⟂ » U V ↔ U ≤ «expr ᗮ» V :=\n  iff.rfl\n#align is_ortho_iff_le is_ortho_iff_le\n\n",
 "is_ortho_iff_inner_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟪ , ⟫» -/\ntheorem is_ortho_iff_inner_eq {U V : Submodule 𝕜 E} : «expr ⟂ » U V ↔ ∀ u ∈ U, ∀ v ∈ V, «expr⟪ , ⟫» u v = 0 :=\n  forall₄_congr fun u hu v hv => inner_eq_zero_symm\n#align is_ortho_iff_inner_eq is_ortho_iff_inner_eq\n\n",
 "is_ortho_comm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟂ » -/\ntheorem is_ortho_comm {U V : Submodule 𝕜 E} : «expr ⟂ » U V ↔ «expr ⟂ » V U :=\n  ⟨is_ortho.symm, is_ortho.symm⟩\n#align is_ortho_comm is_ortho_comm\n\n",
 "is_ortho_bot_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem is_ortho_bot_right {U : Submodule 𝕜 E} : «expr ⟂ » U («expr⊥») :=\n  is_ortho_bot_left.symm\n#align is_ortho_bot_right is_ortho_bot_right\n\n",
 "is_ortho_bot_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- TODO: generalize `submodule.map₂` to semilinear maps, so that we can state\n`U ⟂ V ↔ submodule.map₂ (innerₛₗ 𝕜) U V ≤ ⊥`. -/\n@[simp]\ntheorem is_ortho_bot_left {V : Submodule 𝕜 E} : «expr ⟂ » («expr⊥») V :=\n  bot_le\n#align is_ortho_bot_left is_ortho_bot_left\n\n",
 "is_ortho_Sup_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟂ » -/\n@[simp]\ntheorem is_ortho_Sup_right {U : Submodule 𝕜 E} {V : Set (Submodule 𝕜 E)} :\n    «expr ⟂ » U (supₛ V) ↔ ∀ Vᵢ ∈ V, «expr ⟂ » U Vᵢ :=\n  is_ortho_comm.trans <| is_ortho_Sup_left.trans <| by simp_rw [is_ortho_comm]\n#align is_ortho_Sup_right is_ortho_Sup_right\n\n",
 "is_ortho_Sup_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟂ » -/\n@[simp]\ntheorem is_ortho_Sup_left {U : Set (Submodule 𝕜 E)} {V : Submodule 𝕜 E} :\n    «expr ⟂ » (supₛ U) V ↔ ∀ Uᵢ ∈ U, «expr ⟂ » Uᵢ V :=\n  supₛ_le_iff\n#align is_ortho_Sup_left is_ortho_Sup_left\n\n",
 "is_ortho":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟂ » -/\n/-- Two submodules in an orthogonal family with different indices are orthogonal. -/\ntheorem orthogonal_family.is_ortho {ι} {V : ι → Submodule 𝕜 E}\n    (hV : orthogonal_family 𝕜 (fun i => V i) fun i => (V i).subtypeₗᵢ) {i j : ι} (hij : i ≠ j) :\n    «expr ⟂ » (V i) (V j) :=\n  hV.pairwise hij\n#align orthogonal_family.is_ortho orthogonal_family.is_ortho\n\n",
 "is_closed_orthogonal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᗮ» -/\n/-- The orthogonal complement of any submodule `K` is closed. -/\ntheorem is_closed_orthogonal : IsClosed («expr ᗮ» K : Set E) :=\n  by\n  rw [orthogonal_eq_inter K]\n  have := fun v : K => ContinuousLinearMap.isClosed_ker (innerSL 𝕜 (v : E))\n  convert isClosed_interᵢ this\n  simp only [infi_coe]\n#align is_closed_orthogonal is_closed_orthogonal\n\n",
 "inner_right_of_mem_orthogonal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᗮ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟪ , ⟫» -/\n/-- A vector in `K` is orthogonal to one in `Kᗮ`. -/\ntheorem inner_right_of_mem_orthogonal {u v : E} (hu : u ∈ K) (hv : v ∈ «expr ᗮ» K) : «expr⟪ , ⟫» u v = 0 :=\n  (K.mem_orthogonal v).1 hv u hu\n#align inner_right_of_mem_orthogonal inner_right_of_mem_orthogonal\n\n",
 "inner_left_of_mem_orthogonal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᗮ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟪ , ⟫» -/\n/-- A vector in `Kᗮ` is orthogonal to one in `K`. -/\ntheorem inner_left_of_mem_orthogonal {u v : E} (hu : u ∈ K) (hv : v ∈ «expr ᗮ» K) : «expr⟪ , ⟫» v u = 0 := by\n  rw [inner_eq_zero_symm] <;> exact inner_right_of_mem_orthogonal hu hv\n#align inner_left_of_mem_orthogonal inner_left_of_mem_orthogonal\n\n",
 "inner_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟪ , ⟫» -/\ntheorem is_ortho.inner_eq {U V : Submodule 𝕜 E} (h : «expr ⟂ » U V) {u v : E} (hu : u ∈ U) (hv : v ∈ V) :\n    «expr⟪ , ⟫» u v = 0 :=\n  h.symm hv _ hu\n#align is_ortho.inner_eq is_ortho.inner_eq\n\n",
 "infi_orthogonal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᗮ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᗮ» -/\n/-- The inf of an indexed family of orthogonal subspaces equals the\nsubspace orthogonal to the sup. -/\ntheorem infi_orthogonal {ι : Type _} (K : ι → Submodule 𝕜 E) :\n    «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" («expr ᗮ» (K i)) =\n      «expr ᗮ» (supᵢ K) :=\n  (orthogonal_gc 𝕜 E).l_supr.symm\n#align infi_orthogonal infi_orthogonal\n\n",
 "inf_orthogonal_eq_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᗮ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/-- `K` and `Kᗮ` have trivial intersection. -/\ntheorem inf_orthogonal_eq_bot : «expr ⊓ » K («expr ᗮ» K) = «expr⊥» :=\n  by\n  rw [eq_bot_iff]\n  intro x\n  rw [mem_inf]\n  exact fun ⟨hx, ho⟩ => inner_self_eq_zero.1 (ho x hx)\n#align inf_orthogonal_eq_bot inf_orthogonal_eq_bot\n\n",
 "inf_orthogonal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᗮ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᗮ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᗮ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/-- The inf of two orthogonal subspaces equals the subspace orthogonal\nto the sup. -/\ntheorem inf_orthogonal (K₁ K₂ : Submodule 𝕜 E) : «expr ⊓ » («expr ᗮ» K₁) («expr ᗮ» K₂) = «expr ᗮ» («expr ⊔ » K₁ K₂) :=\n  (orthogonal_gc 𝕜 E).l_sup.symm\n#align inf_orthogonal inf_orthogonal\n\n",
 "ge":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᗮ» -/\ntheorem is_ortho.ge {U V : Submodule 𝕜 E} (h : «expr ⟂ » U V) : V ≤ «expr ᗮ» U :=\n  h.symm\n#align is_ortho.ge is_ortho.ge\n\n",
 "disjoint":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟂ » -/\n/-- Orthogonal submodules are disjoint. -/\ntheorem is_ortho.disjoint {U V : Submodule 𝕜 E} (h : «expr ⟂ » U V) : Disjoint U V :=\n  (submodule.orthogonal_disjoint _).mono_right h.symm\n#align is_ortho.disjoint is_ortho.disjoint\n\n",
 "comap_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗᵢ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟂ » -/\n@[simp]\ntheorem is_ortho.comap_iff (f : «expr ≃ₗᵢ[ ] » E 𝕜 F) {U V : Submodule 𝕜 F} :\n    «expr ⟂ » (U.comap f) (V.comap f) ↔ «expr ⟂ » U V :=\n  ⟨fun h =>\n    by\n    have hf : ∀ p : Submodule 𝕜 F, (p.comap f).map f.to_linear_isometry = p := map_comap_eq_of_surjective f.surjective\n    simpa only [hf] using h.map f.to_linear_isometry, is_ortho.comap f.to_linear_isometry⟩\n#align is_ortho.comap_iff is_ortho.comap_iff\n\n",
 "comap":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗᵢ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟂ » -/\ntheorem is_ortho.comap (f : «expr →ₗᵢ[ ] » E 𝕜 F) {U V : Submodule 𝕜 F} (h : «expr ⟂ » U V) :\n    «expr ⟂ » (U.comap f) (V.comap f) := by\n  rw [is_ortho_iff_inner_eq] at *\n  simp_rw [mem_comap, ← f.inner_map_map]\n  intro u hu v hv\n  exact h _ hu _ hv\n#align is_ortho.comap is_ortho.comap\n\n",
 "bot_orthogonal_eq_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᗮ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem bot_orthogonal_eq_top : «expr ᗮ» («expr⊥» : Submodule 𝕜 E) = «expr⊤» :=\n  by\n  rw [← top_orthogonal_eq_bot, eq_top_iff]\n  exact le_orthogonal_orthogonal («expr⊤»)\n#align bot_orthogonal_eq_top bot_orthogonal_eq_top\n\n",
 "bilin_form_of_real_inner_orthogonal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᗮ» -/\n@[simp]\ntheorem bilin_form_of_real_inner_orthogonal {E} [NormedAddCommGroup E] [inner_product_space (exprℝ) E]\n    (K : Submodule (exprℝ) E) : bilin_form_of_real_inner.orthogonal K = «expr ᗮ» K :=\n  rfl\n#align bilin_form_of_real_inner_orthogonal bilin_form_of_real_inner_orthogonal\n\n",
 "Inf_orthogonal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᗮ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᗮ» -/\n/-- The inf of a set of orthogonal subspaces equals the subspace orthogonal to the sup. -/\ntheorem Inf_orthogonal (s : Set <| Submodule 𝕜 E) :\n    «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" («expr ᗮ» K) =\n      «expr ᗮ» (supₛ s) :=\n  (orthogonal_gc 𝕜 E).l_Sup.symm\n#align Inf_orthogonal Inf_orthogonal\n\n"}