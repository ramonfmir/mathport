{"orthogonal_supr_eigenspaces_invariant":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á—®Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ¨† , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨† , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á—®Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ¨† , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨† , Â» -/\n/-- The mutual orthogonal complement of the eigenspaces of a self-adjoint operator on an inner\nproduct space is an invariant subspace of the operator. -/\ntheorem orthogonal_supr_eigenspaces_invariant â¦ƒv : Eâ¦„\n    (hv :\n      v âˆˆ\n        Â«expr á—®Â»\n          (Â«exprâ¨† , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨† , Â»\"\n            (eigenspace T Î¼))) :\n    T v âˆˆ\n      Â«expr á—®Â»\n        (Â«exprâ¨† , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨† , Â»\"\n          (eigenspace T Î¼)) :=\n  by\n  rw [â† submodule.infi_orthogonal] at hvâŠ¢\n  exact T.infi_invariant hT.invariant_orthogonal_eigenspace v hv\n#align orthogonal_supr_eigenspaces_invariant orthogonal_supr_eigenspaces_invariant\n\n",
 "orthogonal_supr_eigenspaces_eq_bot'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á—®Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ¨† , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨† , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¥Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á—®Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ¨† , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨† , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¥Â» -/\ntheorem orthogonal_supr_eigenspaces_eq_bot' :\n    Â«expr á—®Â»\n        (Â«exprâ¨† , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨† , Â»\"\n          (eigenspace T Î¼)) =\n      Â«exprâŠ¥Â» :=\n  show\n    Â«expr á—®Â»\n        (Â«exprâ¨† , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨† , Â»\"\n          (eigenspace T Î¼)) =\n      Â«exprâŠ¥Â»\n    by rw [supáµ¢_ne_bot_subtype, hT.orthogonal_supr_eigenspaces_eq_bot]\n#align orthogonal_supr_eigenspaces_eq_bot' orthogonal_supr_eigenspaces_eq_bot'\n\n",
 "orthogonal_supr_eigenspaces_eq_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á—®Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ¨† , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨† , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¥Â» -/\n/-- The mutual orthogonal complement of the eigenspaces of a self-adjoint operator on a\nfinite-dimensional inner product space is trivial. -/\ntheorem orthogonal_supr_eigenspaces_eq_bot :\n    Â«expr á—®Â»\n        (Â«exprâ¨† , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨† , Â»\"\n          (eigenspace T Î¼)) =\n      Â«exprâŠ¥Â» :=\n  by\n  have hT' : is_symmetric _ := hT.restrict_invariant hT.orthogonal_supr_eigenspaces_invariant\n  -- a self-adjoint operator on a nontrivial inner product space has an eigenvalue\n  haveI := hT'.subsingleton_of_no_eigenvalue_finite_dimensional hT.orthogonal_supr_eigenspaces\n  exact submodule.eq_bot_of_subsingleton _\n#align orthogonal_supr_eigenspaces_eq_bot orthogonal_supr_eigenspaces_eq_bot\n\n",
 "orthogonal_supr_eigenspaces":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á—®Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ¨† , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨† , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á—®Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¥Â» -/\n/-- The mutual orthogonal complement of the eigenspaces of a self-adjoint operator on an inner\nproduct space has no eigenvalues. -/\ntheorem orthogonal_supr_eigenspaces (Î¼ : ğ•œ) :\n    eigenspace (T.restrict hT.orthogonal_supr_eigenspaces_invariant) Î¼ = Â«exprâŠ¥Â» :=\n  by\n  set p : submodule ğ•œ E :=\n    Â«expr á—®Â»\n      (Â«exprâ¨† , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨† , Â»\" (eigenspace T Î¼))\n  refine' eigenspace_restrict_eq_bot hT.orthogonal_supr_eigenspaces_invariant _\n  have Hâ‚‚ : p â‰¤ Â«expr á—®Â» (eigenspace T Î¼) := submodule.orthogonal_le (le_supáµ¢ _ _)\n  exact (eigenspace T Î¼).orthogonal_disjoint.mono_right Hâ‚‚\n#align orthogonal_supr_eigenspaces orthogonal_supr_eigenspaces\n\n",
 "orthogonal_family_eigenspaces'":
 "theorem orthogonal_family_eigenspaces' :\n    @orthogonal_family ğ•œ _ _ _ _ (fun Î¼ : eigenvalues T => eigenspace T Î¼) _ fun Î¼ => (eigenspace T Î¼).subtypeâ‚—áµ¢ :=\n  hT.orthogonal_family_eigenspaces.comp subtype.coe_injective\n#align orthogonal_family_eigenspaces' orthogonal_family_eigenspaces'\n\n",
 "orthogonal_family_eigenspaces":
 "/-- The eigenspaces of a self-adjoint operator are mutually orthogonal. -/\ntheorem orthogonal_family_eigenspaces :\n    @orthogonal_family ğ•œ _ _ _ _ (fun Î¼ => eigenspace T Î¼) _ fun Î¼ => (eigenspace T Î¼).subtypeâ‚—áµ¢ :=\n  by\n  rintro Î¼ Î½ hÎ¼Î½ âŸ¨v, hvâŸ© âŸ¨w, hwâŸ©\n  by_cases hv' : v = 0\n  Â· simp [hv']\n  have H := hT.conj_eigenvalue_eq_self (has_eigenvalue_of_has_eigenvector âŸ¨hv, hv'âŸ©)\n  rw [mem_eigenspace_iff] at hv hw\n  refine' or.resolve_left _ hÎ¼Î½.symm\n  simpa [inner_smul_left, inner_smul_right, hv, hw, H] using (hT v w).symm\n#align orthogonal_family_eigenspaces orthogonal_family_eigenspaces\n\n",
 "invariant_orthogonal_eigenspace":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á—®Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á—®Â» -/\n/-\nCopyright (c) 2021 Heather Macbeth. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Heather Macbeth\n-/\n/-- A self-adjoint operator preserves orthogonal complements of its eigenspaces. -/\ntheorem invariant_orthogonal_eigenspace (Î¼ : ğ•œ) (v : E) (hv : v âˆˆ Â«expr á—®Â» (eigenspace T Î¼)) :\n    T v âˆˆ Â«expr á—®Â» (eigenspace T Î¼) := by\n  intro w hw\n  have : T w = Â«expr â€¢ Â» (Î¼ : ğ•œ) w := by rwa [mem_eigenspace_iff] at hw\n  simp [â† hT w, this, inner_smul_left, hv w hw]\n#align invariant_orthogonal_eigenspace invariant_orthogonal_eigenspace\n\n",
 "inner_product_apply_eigenvector":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚—[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŸª , âŸ«Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n@[simp]\ntheorem inner_product_apply_eigenvector {Î¼ : ğ•œ} {v : E} {T : Â«expr â†’â‚—[ ] Â» E ğ•œ E} (h : v âˆˆ module.End.eigenspace T Î¼) :\n    Â«exprâŸª , âŸ«Â» v (T v) = Î¼ * Â«exprâ€– â€–Â» v ^ 2 := by\n  simp only [mem_eigenspace_iff.mp h, inner_smul_right, inner_self_eq_norm_sq_to_K]\n#align inner_product_apply_eigenvector inner_product_apply_eigenvector\n\n",
 "has_eigenvector_eigenvector_basis":
 "theorem has_eigenvector_eigenvector_basis (i : fin n) :\n    has_eigenvector T (hT.eigenvalues hn i) (hT.eigenvector_basis hn i) :=\n  by\n  let v : E := hT.eigenvector_basis hn i\n  let Î¼ : ğ•œ := hT.direct_sum_is_internal.subordinate_orthonormal_basis_index hn i hT.orthogonal_family_eigenspaces'\n  simp_rw [eigenvalues]\n  change has_eigenvector T (is_R_or_C.re Î¼) v\n  have key : has_eigenvector T Î¼ v :=\n    by\n    have Hâ‚ : v âˆˆ eigenspace T Î¼ := by\n      simp_rw [v, eigenvector_basis]\n      exact hT.direct_sum_is_internal.subordinate_orthonormal_basis_subordinate hn i hT.orthogonal_family_eigenspaces'\n    have Hâ‚‚ : v â‰  0 := by simpa using (hT.eigenvector_basis hn).to_basis.ne_zero i\n    exact âŸ¨Hâ‚, Hâ‚‚âŸ©\n  have re_Î¼ : â†‘(is_R_or_C.re Î¼) = Î¼ := by\n    rw [â† is_R_or_C.eq_conj_iff_re]\n    exact hT.conj_eigenvalue_eq_self (has_eigenvalue_of_has_eigenvector key)\n  simpa [re_Î¼] using key\n#align has_eigenvector_eigenvector_basis has_eigenvector_eigenvector_basis\n\n",
 "has_eigenvalue_eigenvalues":
 "theorem has_eigenvalue_eigenvalues (i : fin n) : has_eigenvalue T (hT.eigenvalues hn i) :=\n  module.End.has_eigenvalue_of_has_eigenvector (hT.has_eigenvector_eigenvector_basis hn i)\n#align has_eigenvalue_eigenvalues has_eigenvalue_eigenvalues\n\n",
 "eigenvalue_pos_of_pos":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŸª , âŸ«Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚—[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŸª , âŸ«Â» -/\ntheorem eigenvalue_pos_of_pos {Î¼ : exprâ„} {T : Â«expr â†’â‚—[ ] Â» E ğ•œ E} (hÎ¼ : has_eigenvalue T Î¼)\n    (hnn : âˆ€ x : E, 0 < is_R_or_C.re (Â«exprâŸª , âŸ«Â» x (T x))) : 0 < Î¼ :=\n  by\n  obtain âŸ¨v, hvâŸ© := hÎ¼.exists_has_eigenvector\n  have hpos : 0 < Â«exprâ€– â€–Â» v ^ 2 := by simpa only [sq_pos_iff, norm_ne_zero_iff] using hv.2\n  have : is_R_or_C.re (Â«exprâŸª , âŸ«Â» v (T v)) = Î¼ * Â«exprâ€– â€–Â» v ^ 2 := by\n    exact_mod_cast congr_arg is_R_or_C.re (inner_product_apply_eigenvector hv.1)\n  exact (zero_lt_mul_right hpos).mp (this â–¸ hnn v)\n#align eigenvalue_pos_of_pos eigenvalue_pos_of_pos\n\n",
 "eigenvalue_nonneg_of_nonneg":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŸª , âŸ«Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚—[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŸª , âŸ«Â» -/\ntheorem eigenvalue_nonneg_of_nonneg {Î¼ : exprâ„} {T : Â«expr â†’â‚—[ ] Â» E ğ•œ E} (hÎ¼ : has_eigenvalue T Î¼)\n    (hnn : âˆ€ x : E, 0 â‰¤ is_R_or_C.re (Â«exprâŸª , âŸ«Â» x (T x))) : 0 â‰¤ Î¼ :=\n  by\n  obtain âŸ¨v, hvâŸ© := hÎ¼.exists_has_eigenvector\n  have hpos : 0 < Â«exprâ€– â€–Â» v ^ 2 := by simpa only [sq_pos_iff, norm_ne_zero_iff] using hv.2\n  have : is_R_or_C.re (Â«exprâŸª , âŸ«Â» v (T v)) = Î¼ * Â«exprâ€– â€–Â» v ^ 2 := by\n    exact_mod_cast congr_arg is_R_or_C.re (inner_product_apply_eigenvector hv.1)\n  exact (zero_le_mul_right hpos).mp (this â–¸ hnn v)\n#align eigenvalue_nonneg_of_nonneg eigenvalue_nonneg_of_nonneg\n\n",
 "direct_sum_is_internal":
 "/-- The eigenspaces of a self-adjoint operator on a finite-dimensional inner product space `E` give\nan internal direct sum decomposition of `E`. -/\ntheorem direct_sum_is_internal : direct_sum.is_internal fun Î¼ : eigenvalues T => eigenspace T Î¼ :=\n  hT.orthogonal_family_eigenspaces'.is_internal_iff.mpr hT.orthogonal_supr_eigenspaces_eq_bot'\n#align direct_sum_is_internal direct_sum_is_internal\n\n",
 "diagonalization_symm_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n@[simp]\ntheorem diagonalization_symm_apply (w : pi_Lp 2 fun Î¼ : eigenvalues T => eigenspace T Î¼) :\n    hT.diagonalization.symm w =\n      finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\" (w Î¼) :=\n  hT.direct_sum_is_internal.isometry_L2_of_orthogonal_family_symm_apply hT.orthogonal_family_eigenspaces' w\n#align diagonalization_symm_apply diagonalization_symm_apply\n\n",
 "diagonalization_basis_apply_self_apply":
 "/-- *Diagonalization theorem*, *spectral theorem*; version 2: A self-adjoint operator `T` on a\nfinite-dimensional inner product space `E` acts diagonally on the identification of `E` with\nEuclidean space induced by an orthonormal basis of eigenvectors of `T`. -/\ntheorem diagonalization_basis_apply_self_apply (v : E) (i : fin n) :\n    (hT.eigenvector_basis hn).repr (T v) i = hT.eigenvalues hn i * (hT.eigenvector_basis hn).repr v i :=\n  by\n  suffices\n    âˆ€ w : euclidean_space ğ•œ (fin n),\n      T ((hT.eigenvector_basis hn).repr.symm w) = (hT.eigenvector_basis hn).repr.symm fun i => hT.eigenvalues hn i * w i\n    by\n    simpa [orthonormal_basis.sum_repr_symm] using\n      congr_arg (fun v => (hT.eigenvector_basis hn).repr v i) (this ((hT.eigenvector_basis hn).repr v))\n  intro w\n  simp_rw [â† orthonormal_basis.sum_repr_symm, linear_map.map_sum, linear_map.map_smul, apply_eigenvector_basis]\n  apply fintype.sum_congr\n  intro a\n  rw [smul_smul, mul_comm]\n#align diagonalization_basis_apply_self_apply diagonalization_basis_apply_self_apply\n\n",
 "diagonalization_apply_self_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/-- *Diagonalization theorem*, *spectral theorem*; version 1: A self-adjoint operator `T` on a\nfinite-dimensional inner product space `E` acts diagonally on the decomposition of `E` into the\ndirect sum of the eigenspaces of `T`. -/\ntheorem diagonalization_apply_self_apply (v : E) (Î¼ : eigenvalues T) :\n    hT.diagonalization (T v) Î¼ = Â«expr â€¢ Â» (Î¼ : ğ•œ) (hT.diagonalization v Î¼) :=\n  by\n  suffices\n    âˆ€ w : pi_Lp 2 fun Î¼ : eigenvalues T => eigenspace T Î¼,\n      T (hT.diagonalization.symm w) = hT.diagonalization.symm fun Î¼ => Â«expr â€¢ Â» (Î¼ : ğ•œ) (w Î¼)\n    by\n    simpa [linear_isometry_equiv.symm_apply_apply, -is_symmetric.diagonalization_symm_apply] using\n      congr_arg (fun w => hT.diagonalization w Î¼) (this (hT.diagonalization v))\n  intro w\n  have hwT : âˆ€ Î¼ : eigenvalues T, T (w Î¼) = Â«expr â€¢ Â» (Î¼ : ğ•œ) (w Î¼) :=\n    by\n    intro Î¼\n    simpa [mem_eigenspace_iff] using (w Î¼).prop\n  simp [hwT]\n#align diagonalization_apply_self_apply diagonalization_apply_self_apply\n\n",
 "conj_eigenvalue_eq_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `star_ring_end -/\n/-- The eigenvalues of a self-adjoint operator are real. -/\ntheorem conj_eigenvalue_eq_self {Î¼ : ğ•œ} (hÎ¼ : has_eigenvalue T Î¼) : (star_ring_end) Î¼ = Î¼ :=\n  by\n  obtain âŸ¨v, hvâ‚, hvâ‚‚âŸ© := hÎ¼.exists_has_eigenvector\n  rw [mem_eigenspace_iff] at hvâ‚\n  simpa [hvâ‚‚, inner_smul_left, inner_smul_right, hvâ‚] using hT v v\n#align conj_eigenvalue_eq_self conj_eigenvalue_eq_self\n\n",
 "apply_eigenvector_basis":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n@[simp]\ntheorem apply_eigenvector_basis (i : fin n) :\n    T (hT.eigenvector_basis hn i) = Â«expr â€¢ Â» (hT.eigenvalues hn i : ğ•œ) (hT.eigenvector_basis hn i) :=\n  mem_eigenspace_iff.mp (hT.has_eigenvector_eigenvector_basis hn i).1\n#align apply_eigenvector_basis apply_eigenvector_basis\n\n"}