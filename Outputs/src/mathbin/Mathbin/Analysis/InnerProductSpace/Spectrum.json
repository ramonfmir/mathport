{"orthogonal_supr_eigenspaces_invariant":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᗮ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᗮ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/-- The mutual orthogonal complement of the eigenspaces of a self-adjoint operator on an inner\nproduct space is an invariant subspace of the operator. -/\ntheorem orthogonal_supr_eigenspaces_invariant ⦃v : E⦄\n    (hv :\n      v ∈\n        «expr ᗮ»\n          («expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n            (eigenspace T μ))) :\n    T v ∈\n      «expr ᗮ»\n        («expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n          (eigenspace T μ)) :=\n  by\n  rw [← submodule.infi_orthogonal] at hv⊢\n  exact T.infi_invariant hT.invariant_orthogonal_eigenspace v hv\n#align orthogonal_supr_eigenspaces_invariant orthogonal_supr_eigenspaces_invariant\n\n",
 "orthogonal_supr_eigenspaces_eq_bot'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᗮ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᗮ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem orthogonal_supr_eigenspaces_eq_bot' :\n    «expr ᗮ»\n        («expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n          (eigenspace T μ)) =\n      «expr⊥» :=\n  show\n    «expr ᗮ»\n        («expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n          (eigenspace T μ)) =\n      «expr⊥»\n    by rw [supᵢ_ne_bot_subtype, hT.orthogonal_supr_eigenspaces_eq_bot]\n#align orthogonal_supr_eigenspaces_eq_bot' orthogonal_supr_eigenspaces_eq_bot'\n\n",
 "orthogonal_supr_eigenspaces_eq_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᗮ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/-- The mutual orthogonal complement of the eigenspaces of a self-adjoint operator on a\nfinite-dimensional inner product space is trivial. -/\ntheorem orthogonal_supr_eigenspaces_eq_bot :\n    «expr ᗮ»\n        («expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n          (eigenspace T μ)) =\n      «expr⊥» :=\n  by\n  have hT' : is_symmetric _ := hT.restrict_invariant hT.orthogonal_supr_eigenspaces_invariant\n  -- a self-adjoint operator on a nontrivial inner product space has an eigenvalue\n  haveI := hT'.subsingleton_of_no_eigenvalue_finite_dimensional hT.orthogonal_supr_eigenspaces\n  exact submodule.eq_bot_of_subsingleton _\n#align orthogonal_supr_eigenspaces_eq_bot orthogonal_supr_eigenspaces_eq_bot\n\n",
 "orthogonal_supr_eigenspaces":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᗮ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᗮ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/-- The mutual orthogonal complement of the eigenspaces of a self-adjoint operator on an inner\nproduct space has no eigenvalues. -/\ntheorem orthogonal_supr_eigenspaces (μ : 𝕜) :\n    eigenspace (T.restrict hT.orthogonal_supr_eigenspaces_invariant) μ = «expr⊥» :=\n  by\n  set p : submodule 𝕜 E :=\n    «expr ᗮ»\n      («expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (eigenspace T μ))\n  refine' eigenspace_restrict_eq_bot hT.orthogonal_supr_eigenspaces_invariant _\n  have H₂ : p ≤ «expr ᗮ» (eigenspace T μ) := submodule.orthogonal_le (le_supᵢ _ _)\n  exact (eigenspace T μ).orthogonal_disjoint.mono_right H₂\n#align orthogonal_supr_eigenspaces orthogonal_supr_eigenspaces\n\n",
 "orthogonal_family_eigenspaces'":
 "theorem orthogonal_family_eigenspaces' :\n    @orthogonal_family 𝕜 _ _ _ _ (fun μ : eigenvalues T => eigenspace T μ) _ fun μ => (eigenspace T μ).subtypeₗᵢ :=\n  hT.orthogonal_family_eigenspaces.comp subtype.coe_injective\n#align orthogonal_family_eigenspaces' orthogonal_family_eigenspaces'\n\n",
 "orthogonal_family_eigenspaces":
 "/-- The eigenspaces of a self-adjoint operator are mutually orthogonal. -/\ntheorem orthogonal_family_eigenspaces :\n    @orthogonal_family 𝕜 _ _ _ _ (fun μ => eigenspace T μ) _ fun μ => (eigenspace T μ).subtypeₗᵢ :=\n  by\n  rintro μ ν hμν ⟨v, hv⟩ ⟨w, hw⟩\n  by_cases hv' : v = 0\n  · simp [hv']\n  have H := hT.conj_eigenvalue_eq_self (has_eigenvalue_of_has_eigenvector ⟨hv, hv'⟩)\n  rw [mem_eigenspace_iff] at hv hw\n  refine' or.resolve_left _ hμν.symm\n  simpa [inner_smul_left, inner_smul_right, hv, hw, H] using (hT v w).symm\n#align orthogonal_family_eigenspaces orthogonal_family_eigenspaces\n\n",
 "invariant_orthogonal_eigenspace":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᗮ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᗮ» -/\n/-\nCopyright (c) 2021 Heather Macbeth. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Heather Macbeth\n-/\n/-- A self-adjoint operator preserves orthogonal complements of its eigenspaces. -/\ntheorem invariant_orthogonal_eigenspace (μ : 𝕜) (v : E) (hv : v ∈ «expr ᗮ» (eigenspace T μ)) :\n    T v ∈ «expr ᗮ» (eigenspace T μ) := by\n  intro w hw\n  have : T w = «expr • » (μ : 𝕜) w := by rwa [mem_eigenspace_iff] at hw\n  simp [← hT w, this, inner_smul_left, hv w hw]\n#align invariant_orthogonal_eigenspace invariant_orthogonal_eigenspace\n\n",
 "inner_product_apply_eigenvector":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟪ , ⟫» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n@[simp]\ntheorem inner_product_apply_eigenvector {μ : 𝕜} {v : E} {T : «expr →ₗ[ ] » E 𝕜 E} (h : v ∈ module.End.eigenspace T μ) :\n    «expr⟪ , ⟫» v (T v) = μ * «expr‖ ‖» v ^ 2 := by\n  simp only [mem_eigenspace_iff.mp h, inner_smul_right, inner_self_eq_norm_sq_to_K]\n#align inner_product_apply_eigenvector inner_product_apply_eigenvector\n\n",
 "has_eigenvector_eigenvector_basis":
 "theorem has_eigenvector_eigenvector_basis (i : fin n) :\n    has_eigenvector T (hT.eigenvalues hn i) (hT.eigenvector_basis hn i) :=\n  by\n  let v : E := hT.eigenvector_basis hn i\n  let μ : 𝕜 := hT.direct_sum_is_internal.subordinate_orthonormal_basis_index hn i hT.orthogonal_family_eigenspaces'\n  simp_rw [eigenvalues]\n  change has_eigenvector T (is_R_or_C.re μ) v\n  have key : has_eigenvector T μ v :=\n    by\n    have H₁ : v ∈ eigenspace T μ := by\n      simp_rw [v, eigenvector_basis]\n      exact hT.direct_sum_is_internal.subordinate_orthonormal_basis_subordinate hn i hT.orthogonal_family_eigenspaces'\n    have H₂ : v ≠ 0 := by simpa using (hT.eigenvector_basis hn).to_basis.ne_zero i\n    exact ⟨H₁, H₂⟩\n  have re_μ : ↑(is_R_or_C.re μ) = μ := by\n    rw [← is_R_or_C.eq_conj_iff_re]\n    exact hT.conj_eigenvalue_eq_self (has_eigenvalue_of_has_eigenvector key)\n  simpa [re_μ] using key\n#align has_eigenvector_eigenvector_basis has_eigenvector_eigenvector_basis\n\n",
 "has_eigenvalue_eigenvalues":
 "theorem has_eigenvalue_eigenvalues (i : fin n) : has_eigenvalue T (hT.eigenvalues hn i) :=\n  module.End.has_eigenvalue_of_has_eigenvector (hT.has_eigenvector_eigenvector_basis hn i)\n#align has_eigenvalue_eigenvalues has_eigenvalue_eigenvalues\n\n",
 "eigenvalue_pos_of_pos":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟪ , ⟫» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟪ , ⟫» -/\ntheorem eigenvalue_pos_of_pos {μ : exprℝ} {T : «expr →ₗ[ ] » E 𝕜 E} (hμ : has_eigenvalue T μ)\n    (hnn : ∀ x : E, 0 < is_R_or_C.re («expr⟪ , ⟫» x (T x))) : 0 < μ :=\n  by\n  obtain ⟨v, hv⟩ := hμ.exists_has_eigenvector\n  have hpos : 0 < «expr‖ ‖» v ^ 2 := by simpa only [sq_pos_iff, norm_ne_zero_iff] using hv.2\n  have : is_R_or_C.re («expr⟪ , ⟫» v (T v)) = μ * «expr‖ ‖» v ^ 2 := by\n    exact_mod_cast congr_arg is_R_or_C.re (inner_product_apply_eigenvector hv.1)\n  exact (zero_lt_mul_right hpos).mp (this ▸ hnn v)\n#align eigenvalue_pos_of_pos eigenvalue_pos_of_pos\n\n",
 "eigenvalue_nonneg_of_nonneg":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟪ , ⟫» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟪ , ⟫» -/\ntheorem eigenvalue_nonneg_of_nonneg {μ : exprℝ} {T : «expr →ₗ[ ] » E 𝕜 E} (hμ : has_eigenvalue T μ)\n    (hnn : ∀ x : E, 0 ≤ is_R_or_C.re («expr⟪ , ⟫» x (T x))) : 0 ≤ μ :=\n  by\n  obtain ⟨v, hv⟩ := hμ.exists_has_eigenvector\n  have hpos : 0 < «expr‖ ‖» v ^ 2 := by simpa only [sq_pos_iff, norm_ne_zero_iff] using hv.2\n  have : is_R_or_C.re («expr⟪ , ⟫» v (T v)) = μ * «expr‖ ‖» v ^ 2 := by\n    exact_mod_cast congr_arg is_R_or_C.re (inner_product_apply_eigenvector hv.1)\n  exact (zero_le_mul_right hpos).mp (this ▸ hnn v)\n#align eigenvalue_nonneg_of_nonneg eigenvalue_nonneg_of_nonneg\n\n",
 "direct_sum_is_internal":
 "/-- The eigenspaces of a self-adjoint operator on a finite-dimensional inner product space `E` give\nan internal direct sum decomposition of `E`. -/\ntheorem direct_sum_is_internal : direct_sum.is_internal fun μ : eigenvalues T => eigenspace T μ :=\n  hT.orthogonal_family_eigenspaces'.is_internal_iff.mpr hT.orthogonal_supr_eigenspaces_eq_bot'\n#align direct_sum_is_internal direct_sum_is_internal\n\n",
 "diagonalization_symm_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n@[simp]\ntheorem diagonalization_symm_apply (w : pi_Lp 2 fun μ : eigenvalues T => eigenspace T μ) :\n    hT.diagonalization.symm w =\n      finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\" (w μ) :=\n  hT.direct_sum_is_internal.isometry_L2_of_orthogonal_family_symm_apply hT.orthogonal_family_eigenspaces' w\n#align diagonalization_symm_apply diagonalization_symm_apply\n\n",
 "diagonalization_basis_apply_self_apply":
 "/-- *Diagonalization theorem*, *spectral theorem*; version 2: A self-adjoint operator `T` on a\nfinite-dimensional inner product space `E` acts diagonally on the identification of `E` with\nEuclidean space induced by an orthonormal basis of eigenvectors of `T`. -/\ntheorem diagonalization_basis_apply_self_apply (v : E) (i : fin n) :\n    (hT.eigenvector_basis hn).repr (T v) i = hT.eigenvalues hn i * (hT.eigenvector_basis hn).repr v i :=\n  by\n  suffices\n    ∀ w : euclidean_space 𝕜 (fin n),\n      T ((hT.eigenvector_basis hn).repr.symm w) = (hT.eigenvector_basis hn).repr.symm fun i => hT.eigenvalues hn i * w i\n    by\n    simpa [orthonormal_basis.sum_repr_symm] using\n      congr_arg (fun v => (hT.eigenvector_basis hn).repr v i) (this ((hT.eigenvector_basis hn).repr v))\n  intro w\n  simp_rw [← orthonormal_basis.sum_repr_symm, linear_map.map_sum, linear_map.map_smul, apply_eigenvector_basis]\n  apply fintype.sum_congr\n  intro a\n  rw [smul_smul, mul_comm]\n#align diagonalization_basis_apply_self_apply diagonalization_basis_apply_self_apply\n\n",
 "diagonalization_apply_self_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- *Diagonalization theorem*, *spectral theorem*; version 1: A self-adjoint operator `T` on a\nfinite-dimensional inner product space `E` acts diagonally on the decomposition of `E` into the\ndirect sum of the eigenspaces of `T`. -/\ntheorem diagonalization_apply_self_apply (v : E) (μ : eigenvalues T) :\n    hT.diagonalization (T v) μ = «expr • » (μ : 𝕜) (hT.diagonalization v μ) :=\n  by\n  suffices\n    ∀ w : pi_Lp 2 fun μ : eigenvalues T => eigenspace T μ,\n      T (hT.diagonalization.symm w) = hT.diagonalization.symm fun μ => «expr • » (μ : 𝕜) (w μ)\n    by\n    simpa [linear_isometry_equiv.symm_apply_apply, -is_symmetric.diagonalization_symm_apply] using\n      congr_arg (fun w => hT.diagonalization w μ) (this (hT.diagonalization v))\n  intro w\n  have hwT : ∀ μ : eigenvalues T, T (w μ) = «expr • » (μ : 𝕜) (w μ) :=\n    by\n    intro μ\n    simpa [mem_eigenspace_iff] using (w μ).prop\n  simp [hwT]\n#align diagonalization_apply_self_apply diagonalization_apply_self_apply\n\n",
 "conj_eigenvalue_eq_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `star_ring_end -/\n/-- The eigenvalues of a self-adjoint operator are real. -/\ntheorem conj_eigenvalue_eq_self {μ : 𝕜} (hμ : has_eigenvalue T μ) : (star_ring_end) μ = μ :=\n  by\n  obtain ⟨v, hv₁, hv₂⟩ := hμ.exists_has_eigenvector\n  rw [mem_eigenspace_iff] at hv₁\n  simpa [hv₂, inner_smul_left, inner_smul_right, hv₁] using hT v v\n#align conj_eigenvalue_eq_self conj_eigenvalue_eq_self\n\n",
 "apply_eigenvector_basis":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem apply_eigenvector_basis (i : fin n) :\n    T (hT.eigenvector_basis hn i) = «expr • » (hT.eigenvalues hn i : 𝕜) (hT.eigenvector_basis hn i) :=\n  mem_eigenspace_iff.mp (hT.has_eigenvector_eigenvector_basis hn i).1\n#align apply_eigenvector_basis apply_eigenvector_basis\n\n"}