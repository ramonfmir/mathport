{"restrict_scalars":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚—[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\ntheorem is_symmetric.restrict_scalars {T : Â«expr â†’â‚—[ ] Â» E ğ•œ E} (hT : T.is_symmetric) :\n    @linear_map.is_symmetric (exprâ„) E _ _ (inner_product_space.is_R_or_C_to_real ğ•œ E)\n      (@LinearMap.restrictScalars (exprâ„) ğ•œ _ _ _ _ _ _ (inner_product_space.is_R_or_C_to_real ğ•œ E).to_module\n        (inner_product_space.is_R_or_C_to_real ğ•œ E).to_module _ _ _ T) :=\n  fun x y => by simp [hT x y, real_inner_eq_re_inner, LinearMap.coe_restrictScalars]\n#align is_symmetric.restrict_scalars is_symmetric.restrict_scalars\n\n",
 "restrict_invariant":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚—[ ] Â» -/\n/-- If a symmetric operator preserves a submodule, its restriction to that submodule is\nsymmetric. -/\ntheorem is_symmetric.restrict_invariant {T : Â«expr â†’â‚—[ ] Â» E ğ•œ E} (hT : is_symmetric T) {V : Submodule ğ•œ E}\n    (hV : âˆ€ v âˆˆ V, T v âˆˆ V) : is_symmetric (T.restrict hV) := fun v w => hT v w\n#align is_symmetric.restrict_invariant is_symmetric.restrict_invariant\n\n",
 "is_symmetric_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŸª , âŸ«Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŸª , âŸ«Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚—[ ] Â» -/\ntheorem is_symmetric_zero : (0 : Â«expr â†’â‚—[ ] Â» E ğ•œ E).is_symmetric := fun x y =>\n  (inner_zero_right x : Â«exprâŸª , âŸ«Â» x 0 = 0).symm â–¸ (inner_zero_left y : Â«exprâŸª , âŸ«Â» 0 y = 0)\n#align is_symmetric_zero is_symmetric_zero\n\n",
 "is_symmetric_iff_sesq_form":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚—[ ] Â» -/\n/-\nCopyright (c) 2022 Anatole Dedecker. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Moritz Doll, FrÃ©dÃ©ric Dupuis, Heather Macbeth\n-/\n/-- An operator `T` on an inner product space is symmetric if and only if it is\n`linear_map.is_self_adjoint` with respect to the sesquilinear form given by the inner product. -/\ntheorem is_symmetric_iff_sesq_form (T : Â«expr â†’â‚—[ ] Â» E ğ•œ E) :\n    T.is_symmetric â†” @LinearMap.IsSelfAdjoint ğ•œ E _ _ _ (starRingEnd ğ•œ) sesq_form_of_inner T :=\n  âŸ¨fun h x y => (h y x).symm, fun h x y => (h y x).symmâŸ©\n#align is_symmetric_iff_sesq_form is_symmetric_iff_sesq_form\n\n",
 "is_symmetric_iff_inner_map_self_real":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚—[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„‚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `star_ring_end -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŸª , âŸ«_â„‚Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŸª , âŸ«_â„‚Â» -/\n/-- A linear operator on a complex inner product space is symmetric precisely when\n`âŸªT v, vâŸ«_â„‚` is real for all v.-/\ntheorem is_symmetric_iff_inner_map_self_real (T : Â«expr â†’â‚—[ ] Â» V (exprâ„‚) V) :\n    is_symmetric T â†” âˆ€ v : V, (star_ring_end) (Â«exprâŸª , âŸ«_â„‚Â» (T v) v) = Â«exprâŸª , âŸ«_â„‚Â» (T v) v :=\n  by\n  constructor\n  Â· intro hT v\n    apply is_symmetric.conj_inner_sym hT\n  Â· intro h x y\n    nth_rw 2 [â† inner_conj_symm]\n    nth_rw 2 [inner_map_polarization]\n    simp only [starRingEnd_apply, star_div', star_sub, star_add, star_mul]\n    simp only [â† starRingEnd_apply]\n    rw [h (x + y), h (x - y), h (x + Â«expr â€¢ Â» Complex.I y), h (x - Â«expr â€¢ Â» Complex.I y)]\n    simp only [Complex.conj_I]\n    rw [inner_map_polarization']\n    norm_num\n    ring\n#align is_symmetric_iff_inner_map_self_real is_symmetric_iff_inner_map_self_real\n\n",
 "is_symmetric_id":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚—[ ] Â» -/\ntheorem is_symmetric_id : (LinearMap.id : Â«expr â†’â‚—[ ] Â» E ğ•œ E).is_symmetric := fun x y => rfl\n#align is_symmetric_id is_symmetric_id\n\n",
 "inner_map_self_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚—[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŸª , âŸ«Â» -/\n/-- A symmetric linear map `T` is zero if and only if `âŸªT x, xâŸ«_â„ = 0` for all `x`.\nSee `inner_map_self_eq_zero` for the complex version without the symmetric assumption. -/\ntheorem is_symmetric.inner_map_self_eq_zero {T : Â«expr â†’â‚—[ ] Â» E ğ•œ E} (hT : T.is_symmetric) :\n    (âˆ€ x, Â«exprâŸª , âŸ«Â» (T x) x = 0) â†” T = 0 :=\n  by\n  simp_rw [LinearMap.ext_iff, zero_apply]\n  refine' âŸ¨fun h x => _, fun h => by simp_rw [h, inner_zero_left, forall_const]âŸ©\n  rw [â† @inner_self_eq_zero ğ•œ, hT.inner_map_polarization]\n  simp_rw [h _]\n  ring\n#align is_symmetric.inner_map_self_eq_zero is_symmetric.inner_map_self_eq_zero\n\n",
 "inner_map_polarization":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŸª , âŸ«Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŸª , âŸ«Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŸª , âŸ«Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚—[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŸª , âŸ«Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŸª , âŸ«Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŸª , âŸ«Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŸª , âŸ«Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŸª , âŸ«Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/-- Polarization identity for symmetric linear maps.\nSee `inner_map_polarization` for the complex version without the symmetric assumption. -/\ntheorem is_symmetric.inner_map_polarization {T : Â«expr â†’â‚—[ ] Â» E ğ•œ E} (hT : T.is_symmetric) (x y : E) :\n    Â«exprâŸª , âŸ«Â» (T x) y =\n      (Â«exprâŸª , âŸ«Â» (T (x + y)) (x + y) - Â«exprâŸª , âŸ«Â» (T (x - y)) (x - y) -\n            I * Â«exprâŸª , âŸ«Â» (T (x + Â«expr â€¢ Â» (I : ğ•œ) y)) (x + Â«expr â€¢ Â» (I : ğ•œ) y) +\n          I * Â«exprâŸª , âŸ«Â» (T (x - Â«expr â€¢ Â» (I : ğ•œ) y)) (x - Â«expr â€¢ Â» (I : ğ•œ) y)) /\n        4 :=\n  by\n  rcases@I_mul_I_ax ğ•œ _ with (h | h)\n  Â· simp_rw [h, MulZeroClass.zero_mul, sub_zero, add_zero, map_add, map_sub, inner_add_left, inner_add_right,\n      inner_sub_left, inner_sub_right, hT x, â† inner_conj_symm x (T y)]\n    suffices (re (Â«exprâŸª , âŸ«Â» (T y) x) : ğ•œ) = Â«exprâŸª , âŸ«Â» (T y) x\n      by\n      rw [conj_eq_iff_re.mpr this]\n      ring_nf\n    Â· rw [â† re_add_im (Â«exprâŸª , âŸ«Â» (T y) x)]\n      simp_rw [h, MulZeroClass.mul_zero, add_zero]\n      norm_cast\n  Â· simp_rw [map_add, map_sub, inner_add_left, inner_add_right, inner_sub_left, inner_sub_right, LinearMap.map_smul,\n      inner_smul_left, inner_smul_right, IsROrC.conj_I, mul_add, mul_sub, sub_sub, â† mul_assoc, mul_neg, h, neg_neg,\n      one_mul, neg_one_mul]\n    ring\n#align is_symmetric.inner_map_polarization is_symmetric.inner_map_polarization\n\n",
 "continuous":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŸª , âŸ«Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŸª , âŸ«Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚—[ ] Â» -/\n/-- The **Hellinger--Toeplitz theorem**: if a symmetric operator is defined on a complete space,\n  then it is automatically continuous. -/\ntheorem is_symmetric.continuous [CompleteSpace E] {T : Â«expr â†’â‚—[ ] Â» E ğ•œ E} (hT : is_symmetric T) : Continuous T :=\n  by\n  -- We prove it by using the closed graph theorem\n  refine' T.continuous_of_seq_closed_graph fun u x y hu hTu => _\n  rw [â† sub_eq_zero, â† @inner_self_eq_zero ğ•œ]\n  have hlhs : âˆ€ k : â„•, Â«exprâŸª , âŸ«Â» (T (u k) - T x) (y - T x) = Â«exprâŸª , âŸ«Â» (u k - x) (T (y - T x)) :=\n    by\n    intro k\n    rw [â† T.map_sub, hT]\n  refine' tendsto_nhds_unique ((hTu.sub_const _).inner tendsto_const_nhds) _\n  simp_rw [hlhs]\n  rw [â† inner_zero_left (T (y - T x))]\n  refine' filter.tendsto.inner _ tendsto_const_nhds\n  rw [â† sub_self x]\n  exact hu.sub_const _\n#align is_symmetric.continuous is_symmetric.continuous\n\n",
 "conj_inner_sym":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚—[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `star_ring_end -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŸª , âŸ«Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŸª , âŸ«Â» -/\ntheorem is_symmetric.conj_inner_sym {T : Â«expr â†’â‚—[ ] Â» E ğ•œ E} (hT : is_symmetric T) (x y : E) :\n    (star_ring_end) (Â«exprâŸª , âŸ«Â» (T x) y) = Â«exprâŸª , âŸ«Â» (T y) x := by rw [hT x y, inner_conj_symm]\n#align is_symmetric.conj_inner_sym is_symmetric.conj_inner_sym\n\n",
 "coe_re_apply_inner_self_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŸª , âŸ«Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚—[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŸª , âŸ«Â» -/\n/-- For a symmetric operator `T`, the function `Î» x, âŸªT x, xâŸ«` is real-valued. -/\n@[simp]\ntheorem is_symmetric.coe_re_apply_inner_self_apply {T : Â«expr â†’L[ ] Â» E ğ•œ E}\n    (hT : is_symmetric (T : Â«expr â†’â‚—[ ] Â» E ğ•œ E)) (x : E) : (T.re_apply_inner_self x : ğ•œ) = Â«exprâŸª , âŸ«Â» (T x) x :=\n  by\n  rsuffices âŸ¨r, hrâŸ© : âˆƒ r : exprâ„, Â«exprâŸª , âŸ«Â» (T x) x = r\n  Â· simp [hr, T.re_apply_inner_self_apply]\n  rw [â† conj_eq_iff_real]\n  exact hT.conj_inner_sym x x\n#align is_symmetric.coe_re_apply_inner_self_apply is_symmetric.coe_re_apply_inner_self_apply\n\n",
 "apply_clm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚—[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŸª , âŸ«Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŸª , âŸ«Â» -/\n@[simp]\ntheorem is_symmetric.apply_clm {T : Â«expr â†’L[ ] Â» E ğ•œ E} (hT : is_symmetric (T : Â«expr â†’â‚—[ ] Â» E ğ•œ E)) (x y : E) :\n    Â«exprâŸª , âŸ«Â» (T x) y = Â«exprâŸª , âŸ«Â» x (T y) :=\n  hT x y\n#align is_symmetric.apply_clm is_symmetric.apply_clm\n\n",
 "add":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚—[ ] Â» -/\ntheorem is_symmetric.add {T S : Â«expr â†’â‚—[ ] Â» E ğ•œ E} (hT : T.is_symmetric) (hS : S.is_symmetric) :\n    (T + S).is_symmetric := by\n  intro x y\n  rw [LinearMap.add_apply, inner_add_left, hT x y, hS x y, â† inner_add_right]\n  rfl\n#align is_symmetric.add is_symmetric.add\n\n"}