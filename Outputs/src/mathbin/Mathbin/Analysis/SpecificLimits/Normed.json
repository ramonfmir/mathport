{"tsum_geometric_of_norm_lt_1":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/-- Bound for the sum of a geometric series in a normed ring.  This formula does not assume that the\nnormed ring satisfies the axiom `‖1‖ = 1`. -/\ntheorem normed_ring.tsum_geometric_of_norm_lt_1 (x : R) (h : «expr‖ ‖» x < 1) :\n    «expr‖ ‖»\n        («expr∑' , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , »\" (x ^ n)) ≤\n      «expr‖ ‖» (1 : R) - 1 + (1 - «expr‖ ‖» x)⁻¹ :=\n  by\n  rw [tsum_eq_zero_add (normed_ring.summable_geometric_of_norm_lt_1 x h)]\n  simp only [pow_zero]\n  refine' le_trans (norm_add_le _ _) _\n  have :\n    «expr‖ ‖»\n        («expr∑' , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , »\"\n          ((fun n => x ^ (n + 1)) b)) ≤\n      (1 - «expr‖ ‖» x)⁻¹ - 1 :=\n    by\n    refine' tsum_of_norm_bounded _ fun b => norm_pow_le' _ (nat.succ_pos b)\n    convert (has_sum_nat_add_iff' 1).mpr (has_sum_geometric_of_lt_1 (norm_nonneg x) h)\n    simp\n  linarith\n#align normed_ring.tsum_geometric_of_norm_lt_1 normed_ring.tsum_geometric_of_norm_lt_1\n\n",
 "tsum_geometric_of_abs_lt_1":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , » -/\ntheorem tsum_geometric_of_abs_lt_1 {r : exprℝ} (h : |r| < 1) :\n    «expr∑' , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , »\" (r ^ n) =\n      (1 - r)⁻¹ :=\n  tsum_geometric_of_norm_lt_1 h\n#align tsum_geometric_of_abs_lt_1 tsum_geometric_of_abs_lt_1\n\n",
 "tsum_coe_mul_geometric_of_norm_lt_1":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , » -/\n/-- If `‖r‖ < 1`, then `∑' n : ℕ, n * r ^ n = r / (1 - r) ^ 2`. -/\ntheorem tsum_coe_mul_geometric_of_norm_lt_1 {𝕜 : Type _} [normed_field 𝕜] [complete_space 𝕜] {r : 𝕜}\n    (hr : «expr‖ ‖» r < 1) :\n    («expr∑' , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , »\" (n * r ^ n) :\n        𝕜) =\n      r / (1 - r) ^ 2 :=\n  (has_sum_coe_mul_geometric_of_norm_lt_1 hr).tsum_eq\n#align tsum_coe_mul_geometric_of_norm_lt_1 tsum_coe_mul_geometric_of_norm_lt_1\n\n",
 "tfae_exists_lt_is_o_pow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =o[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =o[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =O[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =O[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- failed to parenthesize: parenthesize: uncaught backtrack exception\n[PrettyPrinter.parenthesize.input] (Command.declaration\n     (Command.declModifiers\n      [(Command.docComment\n        \"/--\"\n        \"Various statements equivalent to the fact that `f n` grows exponentially slower than `R ^ n`.\\n\\n* 0: $f n = o(a ^ n)$ for some $-R < a < R$;\\n* 1: $f n = o(a ^ n)$ for some $0 < a < R$;\\n* 2: $f n = O(a ^ n)$ for some $-R < a < R$;\\n* 3: $f n = O(a ^ n)$ for some $0 < a < R$;\\n* 4: there exist `a < R` and `C` such that one of `C` and `R` is positive and $|f n| ≤ Ca^n$\\n     for all `n`;\\n* 5: there exists `0 < a < R` and a positive `C` such that $|f n| ≤ Ca^n$ for all `n`;\\n* 6: there exists `a < R` such that $|f n| ≤ a ^ n$ for sufficiently large `n`;\\n* 7: there exists `0 < a < R` such that $|f n| ≤ a ^ n$ for sufficiently large `n`.\\n\\nNB: For backwards compatibility, if you add more items to the list, please append them at the end of\\nthe list. -/\")]\n      []\n      []\n      []\n      []\n      [])\n     (Command.theorem\n      \"theorem\"\n      (Command.declId `tfae_exists_lt_is_o_pow [])\n      (Command.declSig\n       [(Term.explicitBinder \"(\" [`f] [\":\" (Term.arrow (termℕ \"ℕ\") \"→\" (Term.app `exprℝ []))] [] \")\")\n        (Term.explicitBinder \"(\" [`R] [\":\" (Term.app `exprℝ [])] [] \")\")]\n       (Term.typeSpec\n        \":\"\n        (Term.app\n         `TFAE\n         [(«term[_]»\n           \"[\"\n           [(Std.ExtendedBinder.«term∃__,_»\n             \"∃\"\n             (Lean.binderIdent `a)\n             («binderTerm∈_» \"∈\" (Term.app `Ioo [(«term-_» \"-\" `R) `R]))\n             \",\"\n             (Term.app `«expr =o[ ] » [`f `at_top (Term.app `pow [`a])]))\n            \",\"\n            (Std.ExtendedBinder.«term∃__,_»\n             \"∃\"\n             (Lean.binderIdent `a)\n             («binderTerm∈_» \"∈\" (Term.app `Ioo [(num \"0\") `R]))\n             \",\"\n             (Term.app `«expr =o[ ] » [`f `at_top (Term.app `pow [`a])]))\n            \",\"\n            (Std.ExtendedBinder.«term∃__,_»\n             \"∃\"\n             (Lean.binderIdent `a)\n             («binderTerm∈_» \"∈\" (Term.app `Ioo [(«term-_» \"-\" `R) `R]))\n             \",\"\n             (Term.app `«expr =O[ ] » [`f `at_top (Term.app `pow [`a])]))\n            \",\"\n            (Std.ExtendedBinder.«term∃__,_»\n             \"∃\"\n             (Lean.binderIdent `a)\n             («binderTerm∈_» \"∈\" (Term.app `Ioo [(num \"0\") `R]))\n             \",\"\n             (Term.app `«expr =O[ ] » [`f `at_top (Term.app `pow [`a])]))\n            \",\"\n            (Std.ExtendedBinder.«term∃__,_»\n             \"∃\"\n             (Lean.binderIdent `a)\n             (Std.ExtendedBinder.«binderTerm<_» \"<\" `R)\n             \",\"\n             («term∃_,_»\n              \"∃\"\n              (Lean.explicitBinders\n               [(Lean.bracketedExplicitBinders \"(\" [(Lean.binderIdent `C)] \":\" (Term.hole \"_\") \")\")\n                (Lean.bracketedExplicitBinders\n                 \"(\"\n                 [(Lean.binderIdent `h₀)]\n                 \":\"\n                 («term_∨_» («term_<_» (num \"0\") \"<\" `C) \"∨\" («term_<_» (num \"0\") \"<\" `R))\n                 \")\")])\n              \",\"\n              (Term.forall\n               \"∀\"\n               [`n]\n               []\n               \",\"\n               («term_≤_»\n                («term|___|» (group \"|\") (Term.app `f [`n]) (group) \"|\")\n                \"≤\"\n                («term_*_» `C \"*\" («term_^_» `a \"^\" `n))))))\n            \",\"\n            (Std.ExtendedBinder.«term∃__,_»\n             \"∃\"\n             (Lean.binderIdent `a)\n             («binderTerm∈_» \"∈\" (Term.app `Ioo [(num \"0\") `R]))\n             \",\"\n             (Std.ExtendedBinder.«term∃__,_»\n              \"∃\"\n              (Lean.binderIdent `C)\n              (Std.ExtendedBinder.«binderTerm>_» \">\" (num \"0\"))\n              \",\"\n              (Term.forall\n               \"∀\"\n               [`n]\n               []\n               \",\"\n               («term_≤_»\n                («term|___|» (group \"|\") (Term.app `f [`n]) (group) \"|\")\n                \"≤\"\n                («term_*_» `C \"*\" («term_^_» `a \"^\" `n))))))\n            \",\"\n            (Std.ExtendedBinder.«term∃__,_»\n             \"∃\"\n             (Lean.binderIdent `a)\n             (Std.ExtendedBinder.«binderTerm<_» \"<\" `R)\n             \",\"\n             (Term.app\n              `«expr∀ᶠ in , »\n              [(str \"\\\"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\\\"\")\n               `at_top\n               («term_≤_» («term|___|» (group \"|\") (Term.app `f [`n]) (group) \"|\") \"≤\" («term_^_» `a \"^\" `n))]))\n            \",\"\n            (Std.ExtendedBinder.«term∃__,_»\n             \"∃\"\n             (Lean.binderIdent `a)\n             («binderTerm∈_» \"∈\" (Term.app `Ioo [(num \"0\") `R]))\n             \",\"\n             (Term.app\n              `«expr∀ᶠ in , »\n              [(str \"\\\"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\\\"\")\n               `at_top\n               («term_≤_» («term|___|» (group \"|\") (Term.app `f [`n]) (group) \"|\") \"≤\" («term_^_» `a \"^\" `n))]))]\n           \"]\")])))\n      (Command.declValSimple\n       \":=\"\n       (Term.byTactic\n        \"by\"\n        (Tactic.tacticSeq\n         (Tactic.tacticSeq1Indented\n          [(Tactic.tacticHave_\n            \"have\"\n            (Term.haveDecl\n             (Term.haveIdDecl\n              [`A []]\n              [(Term.typeSpec\n                \":\"\n                («term_⊆_» (Term.app `Ico [(num \"0\") `R]) \"⊆\" (Term.app `Ioo [(«term-_» \"-\" `R) `R])))]\n              \":=\"\n              (Term.fun\n               \"fun\"\n               (Term.basicFun\n                [`x `hx]\n                []\n                \"=>\"\n                (Term.anonymousCtor\n                 \"⟨\"\n                 [(Term.app\n                   (Term.proj\n                    (Term.app\n                     (Term.proj `neg_lt_zero \".\" (fieldIdx \"2\"))\n                     [(Term.app\n                       (Term.proj (Term.proj `hx \".\" (fieldIdx \"1\")) \".\" `trans_lt)\n                       [(Term.proj `hx \".\" (fieldIdx \"2\"))])])\n                    \".\"\n                    `trans_le)\n                   [(Term.proj `hx \".\" (fieldIdx \"1\"))])\n                  \",\"\n                  (Term.proj `hx \".\" (fieldIdx \"2\"))]\n                 \"⟩\"))))))\n           []\n           (Tactic.tacticHave_\n            \"have\"\n            (Term.haveDecl\n             (Term.haveIdDecl\n              [`B []]\n              [(Term.typeSpec\n                \":\"\n                («term_⊆_» (Term.app `Ioo [(num \"0\") `R]) \"⊆\" (Term.app `Ioo [(«term-_» \"-\" `R) `R])))]\n              \":=\"\n              (Term.app `subset.trans [`Ioo_subset_Ico_self `A]))))\n           []\n           (Tactic.tfaeHave \"tfae_have\" [] (num \"1\") \"→\" (num \"3\"))\n           []\n           (Tactic.exact\n            \"exact\"\n            (Term.fun\n             \"fun\"\n             (Term.basicFun\n              [(Term.anonymousCtor \"⟨\" [`a \",\" `ha \",\" `H] \"⟩\")]\n              []\n              \"=>\"\n              (Term.anonymousCtor \"⟨\" [`a \",\" `ha \",\" (Term.proj `H \".\" `is_O)] \"⟩\"))))\n           []\n           (Tactic.tfaeHave \"tfae_have\" [] (num \"2\") \"→\" (num \"1\"))\n           []\n           (Tactic.exact\n            \"exact\"\n            (Term.fun\n             \"fun\"\n             (Term.basicFun\n              [(Term.anonymousCtor \"⟨\" [`a \",\" `ha \",\" `H] \"⟩\")]\n              []\n              \"=>\"\n              (Term.anonymousCtor \"⟨\" [`a \",\" (Term.app `B [`ha]) \",\" `H] \"⟩\"))))\n           []\n           (Tactic.tfaeHave \"tfae_have\" [] (num \"3\") \"→\" (num \"2\"))\n           []\n           (tactic__\n            (cdotTk (patternIgnore (token.«· » \"·\")))\n            [(Std.Tactic.rintro\n              \"rintro\"\n              [(Std.Tactic.RCases.rintroPat.one\n                (Std.Tactic.RCases.rcasesPat.tuple\n                 \"⟨\"\n                 [(Std.Tactic.RCases.rcasesPatLo\n                   (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `a)])\n                   [])\n                  \",\"\n                  (Std.Tactic.RCases.rcasesPatLo\n                   (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `ha)])\n                   [])\n                  \",\"\n                  (Std.Tactic.RCases.rcasesPatLo\n                   (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `H)])\n                   [])]\n                 \"⟩\"))]\n              [])\n             []\n             (Std.Tactic.rcases\n              \"rcases\"\n              [(Tactic.casesTarget\n                []\n                (Term.app `exists_between [(Term.app (Term.proj `abs_lt \".\" (fieldIdx \"2\")) [`ha])]))]\n              [\"with\"\n               (Std.Tactic.RCases.rcasesPatLo\n                (Std.Tactic.RCases.rcasesPatMed\n                 [(Std.Tactic.RCases.rcasesPat.tuple\n                   \"⟨\"\n                   [(Std.Tactic.RCases.rcasesPatLo\n                     (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `b)])\n                     [])\n                    \",\"\n                    (Std.Tactic.RCases.rcasesPatLo\n                     (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hab)])\n                     [])\n                    \",\"\n                    (Std.Tactic.RCases.rcasesPatLo\n                     (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hbR)])\n                     [])]\n                   \"⟩\")])\n                [])])\n             []\n             (Tactic.exact\n              \"exact\"\n              (Term.anonymousCtor\n               \"⟨\"\n               [`b\n                \",\"\n                (Term.anonymousCtor\n                 \"⟨\"\n                 [(Term.app (Term.proj (Term.app `abs_nonneg [`a]) \".\" `trans_lt) [`hab]) \",\" `hbR]\n                 \"⟩\")\n                \",\"\n                (Term.app\n                 `H.trans_is_o\n                 [(Term.app `is_o_pow_pow_of_abs_lt_left [(Term.app `hab.trans_le [(Term.app `le_abs_self [`b])])])])]\n               \"⟩\"))])\n           []\n           (Tactic.tfaeHave \"tfae_have\" [] (num \"2\") \"→\" (num \"4\"))\n           []\n           (Tactic.exact\n            \"exact\"\n            (Term.fun\n             \"fun\"\n             (Term.basicFun\n              [(Term.anonymousCtor \"⟨\" [`a \",\" `ha \",\" `H] \"⟩\")]\n              []\n              \"=>\"\n              (Term.anonymousCtor \"⟨\" [`a \",\" `ha \",\" (Term.proj `H \".\" `is_O)] \"⟩\"))))\n           []\n           (Tactic.tfaeHave \"tfae_have\" [] (num \"4\") \"→\" (num \"3\"))\n           []\n           (Tactic.exact\n            \"exact\"\n            (Term.fun\n             \"fun\"\n             (Term.basicFun\n              [(Term.anonymousCtor \"⟨\" [`a \",\" `ha \",\" `H] \"⟩\")]\n              []\n              \"=>\"\n              (Term.anonymousCtor \"⟨\" [`a \",\" (Term.app `B [`ha]) \",\" `H] \"⟩\"))))\n           []\n           (Tactic.tfaeHave \"tfae_have\" [] (num \"4\") \"→\" (num \"6\"))\n           []\n           (tactic__\n            (cdotTk (patternIgnore (token.«· » \"·\")))\n            [(Std.Tactic.rintro\n              \"rintro\"\n              [(Std.Tactic.RCases.rintroPat.one\n                (Std.Tactic.RCases.rcasesPat.tuple\n                 \"⟨\"\n                 [(Std.Tactic.RCases.rcasesPatLo\n                   (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `a)])\n                   [])\n                  \",\"\n                  (Std.Tactic.RCases.rcasesPatLo\n                   (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `ha)])\n                   [])\n                  \",\"\n                  (Std.Tactic.RCases.rcasesPatLo\n                   (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `H)])\n                   [])]\n                 \"⟩\"))]\n              [])\n             []\n             (Std.Tactic.rcases\n              \"rcases\"\n              [(Tactic.casesTarget [] (Term.app `bound_of_is_O_nat_at_top [`H]))]\n              [\"with\"\n               (Std.Tactic.RCases.rcasesPatLo\n                (Std.Tactic.RCases.rcasesPatMed\n                 [(Std.Tactic.RCases.rcasesPat.tuple\n                   \"⟨\"\n                   [(Std.Tactic.RCases.rcasesPatLo\n                     (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `C)])\n                     [])\n                    \",\"\n                    (Std.Tactic.RCases.rcasesPatLo\n                     (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hC₀)])\n                     [])\n                    \",\"\n                    (Std.Tactic.RCases.rcasesPatLo\n                     (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hC)])\n                     [])]\n                   \"⟩\")])\n                [])])\n             []\n             (Tactic.refine'\n              \"refine'\"\n              (Term.anonymousCtor\n               \"⟨\"\n               [`a \",\" `ha \",\" `C \",\" `hC₀ \",\" (Term.fun \"fun\" (Term.basicFun [`n] [] \"=>\" (Term.hole \"_\")))]\n               \"⟩\"))\n             []\n             (Std.Tactic.Simpa.simpa\n              \"simpa\"\n              []\n              []\n              (Std.Tactic.Simpa.simpaArgsRest\n               []\n               []\n               [\"only\"]\n               [(Tactic.simpArgs\n                 \"[\"\n                 [(Tactic.simpLemma [] [] `real.norm_eq_abs)\n                  \",\"\n                  (Tactic.simpLemma [] [] `abs_pow)\n                  \",\"\n                  (Tactic.simpLemma\n                   []\n                   []\n                   (Term.app `abs_of_nonneg [(Term.proj (Term.proj `ha \".\" (fieldIdx \"1\")) \".\" `le)]))]\n                 \"]\")]\n               [\"using\"\n                (Term.app\n                 `hC\n                 [(Term.app `pow_ne_zero [`n (Term.proj (Term.proj `ha \".\" (fieldIdx \"1\")) \".\" `ne')])])]))])\n           []\n           (Tactic.tfaeHave \"tfae_have\" [] (num \"6\") \"→\" (num \"5\"))\n           []\n           (Tactic.exact\n            \"exact\"\n            (Term.fun\n             \"fun\"\n             (Term.basicFun\n              [(Term.anonymousCtor \"⟨\" [`a \",\" `ha \",\" `C \",\" `H₀ \",\" `H] \"⟩\")]\n              []\n              \"=>\"\n              (Term.anonymousCtor\n               \"⟨\"\n               [`a \",\" (Term.proj `ha \".\" (fieldIdx \"2\")) \",\" `C \",\" (Term.app `or.inl [`H₀]) \",\" `H]\n               \"⟩\"))))\n           []\n           (Tactic.tfaeHave \"tfae_have\" [] (num \"5\") \"→\" (num \"3\"))\n           []\n           (tactic__\n            (cdotTk (patternIgnore (token.«· » \"·\")))\n            [(Std.Tactic.rintro\n              \"rintro\"\n              [(Std.Tactic.RCases.rintroPat.one\n                (Std.Tactic.RCases.rcasesPat.tuple\n                 \"⟨\"\n                 [(Std.Tactic.RCases.rcasesPatLo\n                   (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `a)])\n                   [])\n                  \",\"\n                  (Std.Tactic.RCases.rcasesPatLo\n                   (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `ha)])\n                   [])\n                  \",\"\n                  (Std.Tactic.RCases.rcasesPatLo\n                   (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `C)])\n                   [])\n                  \",\"\n                  (Std.Tactic.RCases.rcasesPatLo\n                   (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `h₀)])\n                   [])\n                  \",\"\n                  (Std.Tactic.RCases.rcasesPatLo\n                   (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `H)])\n                   [])]\n                 \"⟩\"))]\n              [])\n             []\n             (Std.Tactic.rcases\n              \"rcases\"\n              [(Tactic.casesTarget\n                []\n                (Term.app\n                 `sign_cases_of_C_mul_pow_nonneg\n                 [(Term.fun\n                   \"fun\"\n                   (Term.basicFun\n                    [`n]\n                    []\n                    \"=>\"\n                    (Term.app\n                     (Term.proj (Term.app `abs_nonneg [(Term.hole \"_\")]) \".\" `trans)\n                     [(Term.app `H [`n])])))]))]\n              [\"with\"\n               (Std.Tactic.RCases.rcasesPatLo\n                (Std.Tactic.RCases.rcasesPatMed\n                 [(Std.Tactic.RCases.rcasesPat.paren\n                   \"(\"\n                   (Std.Tactic.RCases.rcasesPatLo\n                    (Std.Tactic.RCases.rcasesPatMed\n                     [(Std.Tactic.RCases.rcasesPat.one `rfl)\n                      \"|\"\n                      (Std.Tactic.RCases.rcasesPat.tuple\n                       \"⟨\"\n                       [(Std.Tactic.RCases.rcasesPatLo\n                         (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hC₀)])\n                         [])\n                        \",\"\n                        (Std.Tactic.RCases.rcasesPatLo\n                         (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `ha₀)])\n                         [])]\n                       \"⟩\")])\n                    [])\n                   \")\")])\n                [])])\n             []\n             (tactic__\n              (cdotTk (patternIgnore (token.«· » \"·\")))\n              [(Std.Tactic.obtain\n                \"obtain\"\n                [(Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `rfl)])]\n                [\":\" («term_=_» `f \"=\" (num \"0\"))]\n                [\":=\"\n                 [(Term.byTactic\n                   \"by\"\n                   (Tactic.tacticSeq\n                    (Tactic.tacticSeq1Indented\n                     [(Std.Tactic.Ext.«tacticExt___:_»\n                       \"ext\"\n                       [(Std.Tactic.RCases.rintroPat.one (Std.Tactic.RCases.rcasesPat.one `n))]\n                       [])\n                      []\n                      (Std.Tactic.Simpa.simpa\n                       \"simpa\"\n                       []\n                       []\n                       (Std.Tactic.Simpa.simpaArgsRest [] [] [] [] [\"using\" (Term.app `H [`n])]))])))]])\n               []\n               (Tactic.simp\n                \"simp\"\n                []\n                []\n                [\"only\"]\n                [\"[\" [(Tactic.simpLemma [] [] `lt_irrefl) \",\" (Tactic.simpLemma [] [] `false_or_iff)] \"]\"]\n                [(Tactic.location \"at\" (Tactic.locationHyp [`h₀] []))])\n               []\n               (Tactic.exact\n                \"exact\"\n                (Term.anonymousCtor\n                 \"⟨\"\n                 [(num \"0\")\n                  \",\"\n                  (Term.anonymousCtor \"⟨\" [(Term.app (Term.proj `neg_lt_zero \".\" (fieldIdx \"2\")) [`h₀]) \",\" `h₀] \"⟩\")\n                  \",\"\n                  (Term.app `is_O_zero [(Term.hole \"_\") (Term.hole \"_\")])]\n                 \"⟩\"))])\n             []\n             (Tactic.exact\n              \"exact\"\n              (Term.anonymousCtor\n               \"⟨\"\n               [`a\n                \",\"\n                (Term.app `A [(Term.anonymousCtor \"⟨\" [`ha₀ \",\" `ha] \"⟩\")])\n                \",\"\n                (Term.app\n                 `is_O_of_le'\n                 [(Term.hole \"_\")\n                  (Term.fun\n                   \"fun\"\n                   (Term.basicFun\n                    [`n]\n                    []\n                    \"=>\"\n                    («term_<|_»\n                     (Term.proj (Term.app `H [`n]) \".\" `trans)\n                     \"<|\"\n                     (Term.app `mul_le_mul_of_nonneg_left [(Term.app `le_abs_self [(Term.hole \"_\")]) `hC₀.le]))))])]\n               \"⟩\"))])\n           []\n           (Tactic.tfaeHave \"tfae_have\" [] (num \"2\") \"→\" (num \"8\"))\n           []\n           (tactic__\n            (cdotTk (patternIgnore (token.«· » \"·\")))\n            [(Std.Tactic.rintro\n              \"rintro\"\n              [(Std.Tactic.RCases.rintroPat.one\n                (Std.Tactic.RCases.rcasesPat.tuple\n                 \"⟨\"\n                 [(Std.Tactic.RCases.rcasesPatLo\n                   (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `a)])\n                   [])\n                  \",\"\n                  (Std.Tactic.RCases.rcasesPatLo\n                   (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `ha)])\n                   [])\n                  \",\"\n                  (Std.Tactic.RCases.rcasesPatLo\n                   (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `H)])\n                   [])]\n                 \"⟩\"))]\n              [])\n             []\n             (Tactic.refine'\n              \"refine'\"\n              (Term.anonymousCtor\n               \"⟨\"\n               [`a\n                \",\"\n                `ha\n                \",\"\n                (Term.app\n                 (Term.proj (Term.app `H.def [`zero_lt_one]) \".\" `mono)\n                 [(Term.fun \"fun\" (Term.basicFun [`n `hn] [] \"=>\" (Term.hole \"_\")))])]\n               \"⟩\"))\n             []\n             (Std.Tactic.tacticRwa__\n              \"rwa\"\n              (Tactic.rwRuleSeq\n               \"[\"\n               [(Tactic.rwRule [] `real.norm_eq_abs)\n                \",\"\n                (Tactic.rwRule [] `real.norm_eq_abs)\n                \",\"\n                (Tactic.rwRule [] `one_mul)\n                \",\"\n                (Tactic.rwRule [] `abs_pow)\n                \",\"\n                (Tactic.rwRule [] (Term.app `abs_of_pos [(Term.proj `ha \".\" (fieldIdx \"1\"))]))]\n               \"]\")\n              [(Tactic.location \"at\" (Tactic.locationHyp [`hn] []))])])\n           []\n           (Tactic.tfaeHave \"tfae_have\" [] (num \"8\") \"→\" (num \"7\"))\n           []\n           (Tactic.exact\n            \"exact\"\n            (Term.fun\n             \"fun\"\n             (Term.basicFun\n              [(Term.anonymousCtor \"⟨\" [`a \",\" `ha \",\" `H] \"⟩\")]\n              []\n              \"=>\"\n              (Term.anonymousCtor \"⟨\" [`a \",\" (Term.proj `ha \".\" (fieldIdx \"2\")) \",\" `H] \"⟩\"))))\n           []\n           (Tactic.tfaeHave \"tfae_have\" [] (num \"7\") \"→\" (num \"3\"))\n           []\n           (tactic__\n            (cdotTk (patternIgnore (token.«· » \"·\")))\n            [(Std.Tactic.rintro\n              \"rintro\"\n              [(Std.Tactic.RCases.rintroPat.one\n                (Std.Tactic.RCases.rcasesPat.tuple\n                 \"⟨\"\n                 [(Std.Tactic.RCases.rcasesPatLo\n                   (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `a)])\n                   [])\n                  \",\"\n                  (Std.Tactic.RCases.rcasesPatLo\n                   (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `ha)])\n                   [])\n                  \",\"\n                  (Std.Tactic.RCases.rcasesPatLo\n                   (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `H)])\n                   [])]\n                 \"⟩\"))]\n              [])\n             []\n             (Tactic.tacticHave_\n              \"have\"\n              (Term.haveDecl\n               (Term.haveIdDecl\n                []\n                [(Term.typeSpec \":\" («term_≤_» (num \"0\") \"≤\" `a))]\n                \":=\"\n                (Term.app\n                 `nonneg_of_eventually_pow_nonneg\n                 [(Term.app\n                   `H.mono\n                   [(Term.fun\n                     \"fun\"\n                     (Term.basicFun\n                      [`n]\n                      []\n                      \"=>\"\n                      (Term.proj (Term.app `abs_nonneg [(Term.hole \"_\")]) \".\" `trans)))])]))))\n             []\n             (Tactic.refine'\n              \"refine'\"\n              (Term.anonymousCtor\n               \"⟨\"\n               [`a\n                \",\"\n                (Term.app `A [(Term.anonymousCtor \"⟨\" [`this \",\" `ha] \"⟩\")])\n                \",\"\n                (Term.app `is_O.of_bound [(num \"1\") (Term.hole \"_\")])]\n               \"⟩\"))\n             []\n             (Std.Tactic.Simpa.simpa\n              \"simpa\"\n              []\n              []\n              (Std.Tactic.Simpa.simpaArgsRest\n               []\n               []\n               [\"only\"]\n               [(Tactic.simpArgs\n                 \"[\"\n                 [(Tactic.simpLemma [] [] `real.norm_eq_abs)\n                  \",\"\n                  (Tactic.simpLemma [] [] `one_mul)\n                  \",\"\n                  (Tactic.simpLemma [] [] `abs_pow)\n                  \",\"\n                  (Tactic.simpLemma [] [] (Term.app `abs_of_nonneg [`this]))]\n                 \"]\")]\n               []))])\n           []\n           (Tactic.tfaeFinish \"tfae_finish\")])))\n       [])\n      []\n      []))\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.byTactic\n       \"by\"\n       (Tactic.tacticSeq\n        (Tactic.tacticSeq1Indented\n         [(Tactic.tacticHave_\n           \"have\"\n           (Term.haveDecl\n            (Term.haveIdDecl\n             [`A []]\n             [(Term.typeSpec \":\" («term_⊆_» (Term.app `Ico [(num \"0\") `R]) \"⊆\" (Term.app `Ioo [(«term-_» \"-\" `R) `R])))]\n             \":=\"\n             (Term.fun\n              \"fun\"\n              (Term.basicFun\n               [`x `hx]\n               []\n               \"=>\"\n               (Term.anonymousCtor\n                \"⟨\"\n                [(Term.app\n                  (Term.proj\n                   (Term.app\n                    (Term.proj `neg_lt_zero \".\" (fieldIdx \"2\"))\n                    [(Term.app\n                      (Term.proj (Term.proj `hx \".\" (fieldIdx \"1\")) \".\" `trans_lt)\n                      [(Term.proj `hx \".\" (fieldIdx \"2\"))])])\n                   \".\"\n                   `trans_le)\n                  [(Term.proj `hx \".\" (fieldIdx \"1\"))])\n                 \",\"\n                 (Term.proj `hx \".\" (fieldIdx \"2\"))]\n                \"⟩\"))))))\n          []\n          (Tactic.tacticHave_\n           \"have\"\n           (Term.haveDecl\n            (Term.haveIdDecl\n             [`B []]\n             [(Term.typeSpec \":\" («term_⊆_» (Term.app `Ioo [(num \"0\") `R]) \"⊆\" (Term.app `Ioo [(«term-_» \"-\" `R) `R])))]\n             \":=\"\n             (Term.app `subset.trans [`Ioo_subset_Ico_self `A]))))\n          []\n          (Tactic.tfaeHave \"tfae_have\" [] (num \"1\") \"→\" (num \"3\"))\n          []\n          (Tactic.exact\n           \"exact\"\n           (Term.fun\n            \"fun\"\n            (Term.basicFun\n             [(Term.anonymousCtor \"⟨\" [`a \",\" `ha \",\" `H] \"⟩\")]\n             []\n             \"=>\"\n             (Term.anonymousCtor \"⟨\" [`a \",\" `ha \",\" (Term.proj `H \".\" `is_O)] \"⟩\"))))\n          []\n          (Tactic.tfaeHave \"tfae_have\" [] (num \"2\") \"→\" (num \"1\"))\n          []\n          (Tactic.exact\n           \"exact\"\n           (Term.fun\n            \"fun\"\n            (Term.basicFun\n             [(Term.anonymousCtor \"⟨\" [`a \",\" `ha \",\" `H] \"⟩\")]\n             []\n             \"=>\"\n             (Term.anonymousCtor \"⟨\" [`a \",\" (Term.app `B [`ha]) \",\" `H] \"⟩\"))))\n          []\n          (Tactic.tfaeHave \"tfae_have\" [] (num \"3\") \"→\" (num \"2\"))\n          []\n          (tactic__\n           (cdotTk (patternIgnore (token.«· » \"·\")))\n           [(Std.Tactic.rintro\n             \"rintro\"\n             [(Std.Tactic.RCases.rintroPat.one\n               (Std.Tactic.RCases.rcasesPat.tuple\n                \"⟨\"\n                [(Std.Tactic.RCases.rcasesPatLo\n                  (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `a)])\n                  [])\n                 \",\"\n                 (Std.Tactic.RCases.rcasesPatLo\n                  (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `ha)])\n                  [])\n                 \",\"\n                 (Std.Tactic.RCases.rcasesPatLo\n                  (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `H)])\n                  [])]\n                \"⟩\"))]\n             [])\n            []\n            (Std.Tactic.rcases\n             \"rcases\"\n             [(Tactic.casesTarget\n               []\n               (Term.app `exists_between [(Term.app (Term.proj `abs_lt \".\" (fieldIdx \"2\")) [`ha])]))]\n             [\"with\"\n              (Std.Tactic.RCases.rcasesPatLo\n               (Std.Tactic.RCases.rcasesPatMed\n                [(Std.Tactic.RCases.rcasesPat.tuple\n                  \"⟨\"\n                  [(Std.Tactic.RCases.rcasesPatLo\n                    (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `b)])\n                    [])\n                   \",\"\n                   (Std.Tactic.RCases.rcasesPatLo\n                    (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hab)])\n                    [])\n                   \",\"\n                   (Std.Tactic.RCases.rcasesPatLo\n                    (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hbR)])\n                    [])]\n                  \"⟩\")])\n               [])])\n            []\n            (Tactic.exact\n             \"exact\"\n             (Term.anonymousCtor\n              \"⟨\"\n              [`b\n               \",\"\n               (Term.anonymousCtor\n                \"⟨\"\n                [(Term.app (Term.proj (Term.app `abs_nonneg [`a]) \".\" `trans_lt) [`hab]) \",\" `hbR]\n                \"⟩\")\n               \",\"\n               (Term.app\n                `H.trans_is_o\n                [(Term.app `is_o_pow_pow_of_abs_lt_left [(Term.app `hab.trans_le [(Term.app `le_abs_self [`b])])])])]\n              \"⟩\"))])\n          []\n          (Tactic.tfaeHave \"tfae_have\" [] (num \"2\") \"→\" (num \"4\"))\n          []\n          (Tactic.exact\n           \"exact\"\n           (Term.fun\n            \"fun\"\n            (Term.basicFun\n             [(Term.anonymousCtor \"⟨\" [`a \",\" `ha \",\" `H] \"⟩\")]\n             []\n             \"=>\"\n             (Term.anonymousCtor \"⟨\" [`a \",\" `ha \",\" (Term.proj `H \".\" `is_O)] \"⟩\"))))\n          []\n          (Tactic.tfaeHave \"tfae_have\" [] (num \"4\") \"→\" (num \"3\"))\n          []\n          (Tactic.exact\n           \"exact\"\n           (Term.fun\n            \"fun\"\n            (Term.basicFun\n             [(Term.anonymousCtor \"⟨\" [`a \",\" `ha \",\" `H] \"⟩\")]\n             []\n             \"=>\"\n             (Term.anonymousCtor \"⟨\" [`a \",\" (Term.app `B [`ha]) \",\" `H] \"⟩\"))))\n          []\n          (Tactic.tfaeHave \"tfae_have\" [] (num \"4\") \"→\" (num \"6\"))\n          []\n          (tactic__\n           (cdotTk (patternIgnore (token.«· » \"·\")))\n           [(Std.Tactic.rintro\n             \"rintro\"\n             [(Std.Tactic.RCases.rintroPat.one\n               (Std.Tactic.RCases.rcasesPat.tuple\n                \"⟨\"\n                [(Std.Tactic.RCases.rcasesPatLo\n                  (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `a)])\n                  [])\n                 \",\"\n                 (Std.Tactic.RCases.rcasesPatLo\n                  (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `ha)])\n                  [])\n                 \",\"\n                 (Std.Tactic.RCases.rcasesPatLo\n                  (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `H)])\n                  [])]\n                \"⟩\"))]\n             [])\n            []\n            (Std.Tactic.rcases\n             \"rcases\"\n             [(Tactic.casesTarget [] (Term.app `bound_of_is_O_nat_at_top [`H]))]\n             [\"with\"\n              (Std.Tactic.RCases.rcasesPatLo\n               (Std.Tactic.RCases.rcasesPatMed\n                [(Std.Tactic.RCases.rcasesPat.tuple\n                  \"⟨\"\n                  [(Std.Tactic.RCases.rcasesPatLo\n                    (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `C)])\n                    [])\n                   \",\"\n                   (Std.Tactic.RCases.rcasesPatLo\n                    (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hC₀)])\n                    [])\n                   \",\"\n                   (Std.Tactic.RCases.rcasesPatLo\n                    (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hC)])\n                    [])]\n                  \"⟩\")])\n               [])])\n            []\n            (Tactic.refine'\n             \"refine'\"\n             (Term.anonymousCtor\n              \"⟨\"\n              [`a \",\" `ha \",\" `C \",\" `hC₀ \",\" (Term.fun \"fun\" (Term.basicFun [`n] [] \"=>\" (Term.hole \"_\")))]\n              \"⟩\"))\n            []\n            (Std.Tactic.Simpa.simpa\n             \"simpa\"\n             []\n             []\n             (Std.Tactic.Simpa.simpaArgsRest\n              []\n              []\n              [\"only\"]\n              [(Tactic.simpArgs\n                \"[\"\n                [(Tactic.simpLemma [] [] `real.norm_eq_abs)\n                 \",\"\n                 (Tactic.simpLemma [] [] `abs_pow)\n                 \",\"\n                 (Tactic.simpLemma\n                  []\n                  []\n                  (Term.app `abs_of_nonneg [(Term.proj (Term.proj `ha \".\" (fieldIdx \"1\")) \".\" `le)]))]\n                \"]\")]\n              [\"using\"\n               (Term.app\n                `hC\n                [(Term.app `pow_ne_zero [`n (Term.proj (Term.proj `ha \".\" (fieldIdx \"1\")) \".\" `ne')])])]))])\n          []\n          (Tactic.tfaeHave \"tfae_have\" [] (num \"6\") \"→\" (num \"5\"))\n          []\n          (Tactic.exact\n           \"exact\"\n           (Term.fun\n            \"fun\"\n            (Term.basicFun\n             [(Term.anonymousCtor \"⟨\" [`a \",\" `ha \",\" `C \",\" `H₀ \",\" `H] \"⟩\")]\n             []\n             \"=>\"\n             (Term.anonymousCtor\n              \"⟨\"\n              [`a \",\" (Term.proj `ha \".\" (fieldIdx \"2\")) \",\" `C \",\" (Term.app `or.inl [`H₀]) \",\" `H]\n              \"⟩\"))))\n          []\n          (Tactic.tfaeHave \"tfae_have\" [] (num \"5\") \"→\" (num \"3\"))\n          []\n          (tactic__\n           (cdotTk (patternIgnore (token.«· » \"·\")))\n           [(Std.Tactic.rintro\n             \"rintro\"\n             [(Std.Tactic.RCases.rintroPat.one\n               (Std.Tactic.RCases.rcasesPat.tuple\n                \"⟨\"\n                [(Std.Tactic.RCases.rcasesPatLo\n                  (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `a)])\n                  [])\n                 \",\"\n                 (Std.Tactic.RCases.rcasesPatLo\n                  (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `ha)])\n                  [])\n                 \",\"\n                 (Std.Tactic.RCases.rcasesPatLo\n                  (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `C)])\n                  [])\n                 \",\"\n                 (Std.Tactic.RCases.rcasesPatLo\n                  (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `h₀)])\n                  [])\n                 \",\"\n                 (Std.Tactic.RCases.rcasesPatLo\n                  (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `H)])\n                  [])]\n                \"⟩\"))]\n             [])\n            []\n            (Std.Tactic.rcases\n             \"rcases\"\n             [(Tactic.casesTarget\n               []\n               (Term.app\n                `sign_cases_of_C_mul_pow_nonneg\n                [(Term.fun\n                  \"fun\"\n                  (Term.basicFun\n                   [`n]\n                   []\n                   \"=>\"\n                   (Term.app (Term.proj (Term.app `abs_nonneg [(Term.hole \"_\")]) \".\" `trans) [(Term.app `H [`n])])))]))]\n             [\"with\"\n              (Std.Tactic.RCases.rcasesPatLo\n               (Std.Tactic.RCases.rcasesPatMed\n                [(Std.Tactic.RCases.rcasesPat.paren\n                  \"(\"\n                  (Std.Tactic.RCases.rcasesPatLo\n                   (Std.Tactic.RCases.rcasesPatMed\n                    [(Std.Tactic.RCases.rcasesPat.one `rfl)\n                     \"|\"\n                     (Std.Tactic.RCases.rcasesPat.tuple\n                      \"⟨\"\n                      [(Std.Tactic.RCases.rcasesPatLo\n                        (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hC₀)])\n                        [])\n                       \",\"\n                       (Std.Tactic.RCases.rcasesPatLo\n                        (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `ha₀)])\n                        [])]\n                      \"⟩\")])\n                   [])\n                  \")\")])\n               [])])\n            []\n            (tactic__\n             (cdotTk (patternIgnore (token.«· » \"·\")))\n             [(Std.Tactic.obtain\n               \"obtain\"\n               [(Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `rfl)])]\n               [\":\" («term_=_» `f \"=\" (num \"0\"))]\n               [\":=\"\n                [(Term.byTactic\n                  \"by\"\n                  (Tactic.tacticSeq\n                   (Tactic.tacticSeq1Indented\n                    [(Std.Tactic.Ext.«tacticExt___:_»\n                      \"ext\"\n                      [(Std.Tactic.RCases.rintroPat.one (Std.Tactic.RCases.rcasesPat.one `n))]\n                      [])\n                     []\n                     (Std.Tactic.Simpa.simpa\n                      \"simpa\"\n                      []\n                      []\n                      (Std.Tactic.Simpa.simpaArgsRest [] [] [] [] [\"using\" (Term.app `H [`n])]))])))]])\n              []\n              (Tactic.simp\n               \"simp\"\n               []\n               []\n               [\"only\"]\n               [\"[\" [(Tactic.simpLemma [] [] `lt_irrefl) \",\" (Tactic.simpLemma [] [] `false_or_iff)] \"]\"]\n               [(Tactic.location \"at\" (Tactic.locationHyp [`h₀] []))])\n              []\n              (Tactic.exact\n               \"exact\"\n               (Term.anonymousCtor\n                \"⟨\"\n                [(num \"0\")\n                 \",\"\n                 (Term.anonymousCtor \"⟨\" [(Term.app (Term.proj `neg_lt_zero \".\" (fieldIdx \"2\")) [`h₀]) \",\" `h₀] \"⟩\")\n                 \",\"\n                 (Term.app `is_O_zero [(Term.hole \"_\") (Term.hole \"_\")])]\n                \"⟩\"))])\n            []\n            (Tactic.exact\n             \"exact\"\n             (Term.anonymousCtor\n              \"⟨\"\n              [`a\n               \",\"\n               (Term.app `A [(Term.anonymousCtor \"⟨\" [`ha₀ \",\" `ha] \"⟩\")])\n               \",\"\n               (Term.app\n                `is_O_of_le'\n                [(Term.hole \"_\")\n                 (Term.fun\n                  \"fun\"\n                  (Term.basicFun\n                   [`n]\n                   []\n                   \"=>\"\n                   («term_<|_»\n                    (Term.proj (Term.app `H [`n]) \".\" `trans)\n                    \"<|\"\n                    (Term.app `mul_le_mul_of_nonneg_left [(Term.app `le_abs_self [(Term.hole \"_\")]) `hC₀.le]))))])]\n              \"⟩\"))])\n          []\n          (Tactic.tfaeHave \"tfae_have\" [] (num \"2\") \"→\" (num \"8\"))\n          []\n          (tactic__\n           (cdotTk (patternIgnore (token.«· » \"·\")))\n           [(Std.Tactic.rintro\n             \"rintro\"\n             [(Std.Tactic.RCases.rintroPat.one\n               (Std.Tactic.RCases.rcasesPat.tuple\n                \"⟨\"\n                [(Std.Tactic.RCases.rcasesPatLo\n                  (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `a)])\n                  [])\n                 \",\"\n                 (Std.Tactic.RCases.rcasesPatLo\n                  (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `ha)])\n                  [])\n                 \",\"\n                 (Std.Tactic.RCases.rcasesPatLo\n                  (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `H)])\n                  [])]\n                \"⟩\"))]\n             [])\n            []\n            (Tactic.refine'\n             \"refine'\"\n             (Term.anonymousCtor\n              \"⟨\"\n              [`a\n               \",\"\n               `ha\n               \",\"\n               (Term.app\n                (Term.proj (Term.app `H.def [`zero_lt_one]) \".\" `mono)\n                [(Term.fun \"fun\" (Term.basicFun [`n `hn] [] \"=>\" (Term.hole \"_\")))])]\n              \"⟩\"))\n            []\n            (Std.Tactic.tacticRwa__\n             \"rwa\"\n             (Tactic.rwRuleSeq\n              \"[\"\n              [(Tactic.rwRule [] `real.norm_eq_abs)\n               \",\"\n               (Tactic.rwRule [] `real.norm_eq_abs)\n               \",\"\n               (Tactic.rwRule [] `one_mul)\n               \",\"\n               (Tactic.rwRule [] `abs_pow)\n               \",\"\n               (Tactic.rwRule [] (Term.app `abs_of_pos [(Term.proj `ha \".\" (fieldIdx \"1\"))]))]\n              \"]\")\n             [(Tactic.location \"at\" (Tactic.locationHyp [`hn] []))])])\n          []\n          (Tactic.tfaeHave \"tfae_have\" [] (num \"8\") \"→\" (num \"7\"))\n          []\n          (Tactic.exact\n           \"exact\"\n           (Term.fun\n            \"fun\"\n            (Term.basicFun\n             [(Term.anonymousCtor \"⟨\" [`a \",\" `ha \",\" `H] \"⟩\")]\n             []\n             \"=>\"\n             (Term.anonymousCtor \"⟨\" [`a \",\" (Term.proj `ha \".\" (fieldIdx \"2\")) \",\" `H] \"⟩\"))))\n          []\n          (Tactic.tfaeHave \"tfae_have\" [] (num \"7\") \"→\" (num \"3\"))\n          []\n          (tactic__\n           (cdotTk (patternIgnore (token.«· » \"·\")))\n           [(Std.Tactic.rintro\n             \"rintro\"\n             [(Std.Tactic.RCases.rintroPat.one\n               (Std.Tactic.RCases.rcasesPat.tuple\n                \"⟨\"\n                [(Std.Tactic.RCases.rcasesPatLo\n                  (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `a)])\n                  [])\n                 \",\"\n                 (Std.Tactic.RCases.rcasesPatLo\n                  (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `ha)])\n                  [])\n                 \",\"\n                 (Std.Tactic.RCases.rcasesPatLo\n                  (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `H)])\n                  [])]\n                \"⟩\"))]\n             [])\n            []\n            (Tactic.tacticHave_\n             \"have\"\n             (Term.haveDecl\n              (Term.haveIdDecl\n               []\n               [(Term.typeSpec \":\" («term_≤_» (num \"0\") \"≤\" `a))]\n               \":=\"\n               (Term.app\n                `nonneg_of_eventually_pow_nonneg\n                [(Term.app\n                  `H.mono\n                  [(Term.fun\n                    \"fun\"\n                    (Term.basicFun [`n] [] \"=>\" (Term.proj (Term.app `abs_nonneg [(Term.hole \"_\")]) \".\" `trans)))])]))))\n            []\n            (Tactic.refine'\n             \"refine'\"\n             (Term.anonymousCtor\n              \"⟨\"\n              [`a\n               \",\"\n               (Term.app `A [(Term.anonymousCtor \"⟨\" [`this \",\" `ha] \"⟩\")])\n               \",\"\n               (Term.app `is_O.of_bound [(num \"1\") (Term.hole \"_\")])]\n              \"⟩\"))\n            []\n            (Std.Tactic.Simpa.simpa\n             \"simpa\"\n             []\n             []\n             (Std.Tactic.Simpa.simpaArgsRest\n              []\n              []\n              [\"only\"]\n              [(Tactic.simpArgs\n                \"[\"\n                [(Tactic.simpLemma [] [] `real.norm_eq_abs)\n                 \",\"\n                 (Tactic.simpLemma [] [] `one_mul)\n                 \",\"\n                 (Tactic.simpLemma [] [] `abs_pow)\n                 \",\"\n                 (Tactic.simpLemma [] [] (Term.app `abs_of_nonneg [`this]))]\n                \"]\")]\n              []))])\n          []\n          (Tactic.tfaeFinish \"tfae_finish\")])))\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.tfaeFinish \"tfae_finish\")\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (tactic__\n       (cdotTk (patternIgnore (token.«· » \"·\")))\n       [(Std.Tactic.rintro\n         \"rintro\"\n         [(Std.Tactic.RCases.rintroPat.one\n           (Std.Tactic.RCases.rcasesPat.tuple\n            \"⟨\"\n            [(Std.Tactic.RCases.rcasesPatLo (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `a)]) [])\n             \",\"\n             (Std.Tactic.RCases.rcasesPatLo (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `ha)]) [])\n             \",\"\n             (Std.Tactic.RCases.rcasesPatLo (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `H)]) [])]\n            \"⟩\"))]\n         [])\n        []\n        (Tactic.tacticHave_\n         \"have\"\n         (Term.haveDecl\n          (Term.haveIdDecl\n           []\n           [(Term.typeSpec \":\" («term_≤_» (num \"0\") \"≤\" `a))]\n           \":=\"\n           (Term.app\n            `nonneg_of_eventually_pow_nonneg\n            [(Term.app\n              `H.mono\n              [(Term.fun\n                \"fun\"\n                (Term.basicFun [`n] [] \"=>\" (Term.proj (Term.app `abs_nonneg [(Term.hole \"_\")]) \".\" `trans)))])]))))\n        []\n        (Tactic.refine'\n         \"refine'\"\n         (Term.anonymousCtor\n          \"⟨\"\n          [`a\n           \",\"\n           (Term.app `A [(Term.anonymousCtor \"⟨\" [`this \",\" `ha] \"⟩\")])\n           \",\"\n           (Term.app `is_O.of_bound [(num \"1\") (Term.hole \"_\")])]\n          \"⟩\"))\n        []\n        (Std.Tactic.Simpa.simpa\n         \"simpa\"\n         []\n         []\n         (Std.Tactic.Simpa.simpaArgsRest\n          []\n          []\n          [\"only\"]\n          [(Tactic.simpArgs\n            \"[\"\n            [(Tactic.simpLemma [] [] `real.norm_eq_abs)\n             \",\"\n             (Tactic.simpLemma [] [] `one_mul)\n             \",\"\n             (Tactic.simpLemma [] [] `abs_pow)\n             \",\"\n             (Tactic.simpLemma [] [] (Term.app `abs_of_nonneg [`this]))]\n            \"]\")]\n          []))])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Std.Tactic.Simpa.simpa\n       \"simpa\"\n       []\n       []\n       (Std.Tactic.Simpa.simpaArgsRest\n        []\n        []\n        [\"only\"]\n        [(Tactic.simpArgs\n          \"[\"\n          [(Tactic.simpLemma [] [] `real.norm_eq_abs)\n           \",\"\n           (Tactic.simpLemma [] [] `one_mul)\n           \",\"\n           (Tactic.simpLemma [] [] `abs_pow)\n           \",\"\n           (Tactic.simpLemma [] [] (Term.app `abs_of_nonneg [`this]))]\n          \"]\")]\n        []))\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.app `abs_of_nonneg [`this])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `this\n[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))\n      `abs_of_nonneg\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1022, term)\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `abs_pow\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `one_mul\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `real.norm_eq_abs\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.refine'\n       \"refine'\"\n       (Term.anonymousCtor\n        \"⟨\"\n        [`a\n         \",\"\n         (Term.app `A [(Term.anonymousCtor \"⟨\" [`this \",\" `ha] \"⟩\")])\n         \",\"\n         (Term.app `is_O.of_bound [(num \"1\") (Term.hole \"_\")])]\n        \"⟩\"))\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.anonymousCtor\n       \"⟨\"\n       [`a\n        \",\"\n        (Term.app `A [(Term.anonymousCtor \"⟨\" [`this \",\" `ha] \"⟩\")])\n        \",\"\n        (Term.app `is_O.of_bound [(num \"1\") (Term.hole \"_\")])]\n       \"⟩\")\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.app `is_O.of_bound [(num \"1\") (Term.hole \"_\")])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.namedArgument'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.ellipsis'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.hole \"_\")\n[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'num', expected 'Lean.Parser.Term.namedArgument'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'num', expected 'Lean.Parser.Term.ellipsis'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, term))\n      (num \"1\")\n[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (some 1023, term)\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))\n      `is_O.of_bound\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1022, term)\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.app `A [(Term.anonymousCtor \"⟨\" [`this \",\" `ha] \"⟩\")])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.anonymousCtor', expected 'Lean.Parser.Term.namedArgument'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.anonymousCtor', expected 'Lean.Parser.Term.ellipsis'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.anonymousCtor \"⟨\" [`this \",\" `ha] \"⟩\")\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `ha\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `this\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))\n      `A\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1022, term)\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `a\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.tacticHave_\n       \"have\"\n       (Term.haveDecl\n        (Term.haveIdDecl\n         []\n         [(Term.typeSpec \":\" («term_≤_» (num \"0\") \"≤\" `a))]\n         \":=\"\n         (Term.app\n          `nonneg_of_eventually_pow_nonneg\n          [(Term.app\n            `H.mono\n            [(Term.fun\n              \"fun\"\n              (Term.basicFun [`n] [] \"=>\" (Term.proj (Term.app `abs_nonneg [(Term.hole \"_\")]) \".\" `trans)))])]))))\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.app\n       `nonneg_of_eventually_pow_nonneg\n       [(Term.app\n         `H.mono\n         [(Term.fun\n           \"fun\"\n           (Term.basicFun [`n] [] \"=>\" (Term.proj (Term.app `abs_nonneg [(Term.hole \"_\")]) \".\" `trans)))])])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.namedArgument'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.ellipsis'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.app\n       `H.mono\n       [(Term.fun \"fun\" (Term.basicFun [`n] [] \"=>\" (Term.proj (Term.app `abs_nonneg [(Term.hole \"_\")]) \".\" `trans)))])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.fun', expected 'Lean.Parser.Term.namedArgument'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.fun', expected 'Lean.Parser.Term.ellipsis'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.fun \"fun\" (Term.basicFun [`n] [] \"=>\" (Term.proj (Term.app `abs_nonneg [(Term.hole \"_\")]) \".\" `trans)))\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.proj (Term.app `abs_nonneg [(Term.hole \"_\")]) \".\" `trans)\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))\n      (Term.app `abs_nonneg [(Term.hole \"_\")])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.namedArgument'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.ellipsis'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.hole \"_\")\n[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))\n      `abs_nonneg\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1022, term)\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (some 1024, term)\n[PrettyPrinter.parenthesize] parenthesized: (Term.paren \"(\" (Term.app `abs_nonneg [(Term.hole \"_\")]) \")\")\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.strictImplicitBinder'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.implicitBinder'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.instBinder'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `n\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (some 0, term) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))\n      `H.mono\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1022, term)\n[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1022, (some 0, term) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] parenthesized: (Term.paren\n     \"(\"\n     (Term.app\n      `H.mono\n      [(Term.fun\n        \"fun\"\n        (Term.basicFun\n         [`n]\n         []\n         \"=>\"\n         (Term.proj (Term.paren \"(\" (Term.app `abs_nonneg [(Term.hole \"_\")]) \")\") \".\" `trans)))])\n     \")\")\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))\n      `nonneg_of_eventually_pow_nonneg\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1022, term)\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      («term_≤_» (num \"0\") \"≤\" `a)\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `a\n[PrettyPrinter.parenthesize] ...precedences are 51 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 50, term))\n      (num \"0\")\n[PrettyPrinter.parenthesize] ...precedences are 51 >? 1024, (none, [anonymous]) <=? (some 50, term)\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 50, (some 51, term) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Std.Tactic.rintro\n       \"rintro\"\n       [(Std.Tactic.RCases.rintroPat.one\n         (Std.Tactic.RCases.rcasesPat.tuple\n          \"⟨\"\n          [(Std.Tactic.RCases.rcasesPatLo (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `a)]) [])\n           \",\"\n           (Std.Tactic.RCases.rcasesPatLo (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `ha)]) [])\n           \",\"\n           (Std.Tactic.RCases.rcasesPatLo (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `H)]) [])]\n          \"⟩\"))]\n       [])\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.tfaeHave \"tfae_have\" [] (num \"7\") \"→\" (num \"3\"))\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind '«→»', expected 'token.« → »'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind '«→»', expected 'token.« ↔ »'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind '«→»', expected 'token.« ← »'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.declValEqns'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.whereStructInst'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception\n/--\n    Various statements equivalent to the fact that `f n` grows exponentially slower than `R ^ n`.\n    \n    * 0: $f n = o(a ^ n)$ for some $-R < a < R$;\n    * 1: $f n = o(a ^ n)$ for some $0 < a < R$;\n    * 2: $f n = O(a ^ n)$ for some $-R < a < R$;\n    * 3: $f n = O(a ^ n)$ for some $0 < a < R$;\n    * 4: there exist `a < R` and `C` such that one of `C` and `R` is positive and $|f n| ≤ Ca^n$\n         for all `n`;\n    * 5: there exists `0 < a < R` and a positive `C` such that $|f n| ≤ Ca^n$ for all `n`;\n    * 6: there exists `a < R` such that $|f n| ≤ a ^ n$ for sufficiently large `n`;\n    * 7: there exists `0 < a < R` such that $|f n| ≤ a ^ n$ for sufficiently large `n`.\n    \n    NB: For backwards compatibility, if you add more items to the list, please append them at the end of\n    the list. -/\n  theorem\n    tfae_exists_lt_is_o_pow\n    ( f : ℕ → exprℝ ) ( R : exprℝ )\n      :\n        TFAE\n          [\n            ∃ a ∈ Ioo - R R , «expr =o[ ] » f at_top pow a\n              ,\n              ∃ a ∈ Ioo 0 R , «expr =o[ ] » f at_top pow a\n              ,\n              ∃ a ∈ Ioo - R R , «expr =O[ ] » f at_top pow a\n              ,\n              ∃ a ∈ Ioo 0 R , «expr =O[ ] » f at_top pow a\n              ,\n              ∃ a < R , ∃ ( C : _ ) ( h₀ : 0 < C ∨ 0 < R ) , ∀ n , | f n | ≤ C * a ^ n\n              ,\n              ∃ a ∈ Ioo 0 R , ∃ C > 0 , ∀ n , | f n | ≤ C * a ^ n\n              ,\n              ∃\n                a\n                < R\n                ,\n                «expr∀ᶠ in , »\n                  \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\"\n                    at_top\n                    | f n | ≤ a ^ n\n              ,\n              ∃\n                a\n                ∈ Ioo 0 R\n                ,\n                «expr∀ᶠ in , »\n                  \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\"\n                    at_top\n                    | f n | ≤ a ^ n\n            ]\n    :=\n      by\n        have\n            A\n              : Ico 0 R ⊆ Ioo - R R\n              :=\n              fun x hx => ⟨ neg_lt_zero . 2 hx . 1 . trans_lt hx . 2 . trans_le hx . 1 , hx . 2 ⟩\n          have B : Ioo 0 R ⊆ Ioo - R R := subset.trans Ioo_subset_Ico_self A\n          tfae_have 1 → 3\n          exact fun ⟨ a , ha , H ⟩ => ⟨ a , ha , H . is_O ⟩\n          tfae_have 2 → 1\n          exact fun ⟨ a , ha , H ⟩ => ⟨ a , B ha , H ⟩\n          tfae_have 3 → 2\n          ·\n            rintro ⟨ a , ha , H ⟩\n              rcases exists_between abs_lt . 2 ha with ⟨ b , hab , hbR ⟩\n              exact\n                ⟨\n                  b\n                    ,\n                    ⟨ abs_nonneg a . trans_lt hab , hbR ⟩\n                    ,\n                    H.trans_is_o is_o_pow_pow_of_abs_lt_left hab.trans_le le_abs_self b\n                  ⟩\n          tfae_have 2 → 4\n          exact fun ⟨ a , ha , H ⟩ => ⟨ a , ha , H . is_O ⟩\n          tfae_have 4 → 3\n          exact fun ⟨ a , ha , H ⟩ => ⟨ a , B ha , H ⟩\n          tfae_have 4 → 6\n          ·\n            rintro ⟨ a , ha , H ⟩\n              rcases bound_of_is_O_nat_at_top H with ⟨ C , hC₀ , hC ⟩\n              refine' ⟨ a , ha , C , hC₀ , fun n => _ ⟩\n              simpa only [ real.norm_eq_abs , abs_pow , abs_of_nonneg ha . 1 . le ] using hC pow_ne_zero n ha . 1 . ne'\n          tfae_have 6 → 5\n          exact fun ⟨ a , ha , C , H₀ , H ⟩ => ⟨ a , ha . 2 , C , or.inl H₀ , H ⟩\n          tfae_have 5 → 3\n          ·\n            rintro ⟨ a , ha , C , h₀ , H ⟩\n              rcases sign_cases_of_C_mul_pow_nonneg fun n => abs_nonneg _ . trans H n with ( rfl | ⟨ hC₀ , ha₀ ⟩ )\n              ·\n                obtain rfl : f = 0 := by ext n simpa using H n\n                  simp only [ lt_irrefl , false_or_iff ] at h₀\n                  exact ⟨ 0 , ⟨ neg_lt_zero . 2 h₀ , h₀ ⟩ , is_O_zero _ _ ⟩\n              exact\n                ⟨\n                  a\n                    ,\n                    A ⟨ ha₀ , ha ⟩\n                    ,\n                    is_O_of_le' _ fun n => H n . trans <| mul_le_mul_of_nonneg_left le_abs_self _ hC₀.le\n                  ⟩\n          tfae_have 2 → 8\n          ·\n            rintro ⟨ a , ha , H ⟩\n              refine' ⟨ a , ha , H.def zero_lt_one . mono fun n hn => _ ⟩\n              rwa [ real.norm_eq_abs , real.norm_eq_abs , one_mul , abs_pow , abs_of_pos ha . 1 ] at hn\n          tfae_have 8 → 7\n          exact fun ⟨ a , ha , H ⟩ => ⟨ a , ha . 2 , H ⟩\n          tfae_have 7 → 3\n          ·\n            rintro ⟨ a , ha , H ⟩\n              have : 0 ≤ a := nonneg_of_eventually_pow_nonneg H.mono fun n => abs_nonneg _ . trans\n              refine' ⟨ a , A ⟨ this , ha ⟩ , is_O.of_bound 1 _ ⟩\n              simpa only [ real.norm_eq_abs , one_mul , abs_pow , abs_of_nonneg this ]\n          tfae_finish\n#align tfae_exists_lt_is_o_pow tfae_exists_lt_is_o_pow\n\n",
 "tendsto_zero_smul_of_tendsto_zero_of_bounded":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- The (scalar) product of a sequence that tends to zero with a bounded one also tends to zero. -/\ntheorem tendsto_zero_smul_of_tendsto_zero_of_bounded {ι 𝕜 𝔸 : Type _} [normed_field 𝕜] [normed_add_comm_group 𝔸]\n    [normed_space 𝕜 𝔸] {l : filter ι} {ε : ι → 𝕜} {f : ι → 𝔸} (hε : tendsto ε l ((nhds) 0))\n    (hf : filter.is_bounded_under (· ≤ ·) l (norm ∘ f)) : tendsto («expr • » ε f) l ((nhds) 0) :=\n  by\n  rw [← is_o_one_iff 𝕜] at hε⊢\n  simpa using is_o.smul_is_O hε (hf.is_O_const (one_ne_zero : (1 : 𝕜) ≠ 0))\n#align tendsto_zero_smul_of_tendsto_zero_of_bounded tendsto_zero_smul_of_tendsto_zero_of_bounded\n\n",
 "tendsto_self_mul_const_pow_of_lt_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- If `0 ≤ r < 1`, then `n * r ^ n` tends to zero. This is a specialized version of\n`tendsto_self_mul_const_pow_of_abs_lt_one`, singled out for ease of application. -/\ntheorem tendsto_self_mul_const_pow_of_lt_one {r : exprℝ} (hr : 0 ≤ r) (h'r : r < 1) :\n    tendsto (fun n => n * r ^ n : ℕ → exprℝ) at_top ((nhds) 0) := by\n  simpa only [pow_one] using tendsto_pow_const_mul_const_pow_of_lt_one 1 hr h'r\n#align tendsto_self_mul_const_pow_of_lt_one tendsto_self_mul_const_pow_of_lt_one\n\n",
 "tendsto_self_mul_const_pow_of_abs_lt_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- If `|r| < 1`, then `n * r ^ n` tends to zero. -/\ntheorem tendsto_self_mul_const_pow_of_abs_lt_one {r : exprℝ} (hr : |r| < 1) :\n    tendsto (fun n => n * r ^ n : ℕ → exprℝ) at_top ((nhds) 0) := by\n  simpa only [pow_one] using tendsto_pow_const_mul_const_pow_of_abs_lt_one 1 hr\n#align tendsto_self_mul_const_pow_of_abs_lt_one tendsto_self_mul_const_pow_of_abs_lt_one\n\n",
 "tendsto_pow_div_factorial_at_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem real.tendsto_pow_div_factorial_at_top (x : exprℝ) :\n    tendsto (fun n => x ^ n / nat.factorial n : ℕ → exprℝ) at_top ((nhds) 0) :=\n  (real.summable_pow_div_factorial x).tendsto_at_top_zero\n#align real.tendsto_pow_div_factorial_at_top real.tendsto_pow_div_factorial_at_top\n\n",
 "tendsto_pow_const_mul_const_pow_of_lt_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- If `0 ≤ r < 1`, then `n ^ k r ^ n` tends to zero for any natural `k`.\nThis is a specialized version of `tendsto_pow_const_mul_const_pow_of_abs_lt_one`, singled out\nfor ease of application. -/\ntheorem tendsto_pow_const_mul_const_pow_of_lt_one (k : ℕ) {r : exprℝ} (hr : 0 ≤ r) (h'r : r < 1) :\n    tendsto (fun n => n ^ k * r ^ n : ℕ → exprℝ) at_top ((nhds) 0) :=\n  tendsto_pow_const_mul_const_pow_of_abs_lt_one k (abs_lt.2 ⟨neg_one_lt_zero.trans_le hr, h'r⟩)\n#align tendsto_pow_const_mul_const_pow_of_lt_one tendsto_pow_const_mul_const_pow_of_lt_one\n\n",
 "tendsto_pow_const_mul_const_pow_of_abs_lt_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- If `|r| < 1`, then `n ^ k r ^ n` tends to zero for any natural `k`. -/\ntheorem tendsto_pow_const_mul_const_pow_of_abs_lt_one (k : ℕ) {r : exprℝ} (hr : |r| < 1) :\n    tendsto (fun n => n ^ k * r ^ n : ℕ → exprℝ) at_top ((nhds) 0) :=\n  by\n  by_cases h0 : r = 0\n  · exact tendsto_const_nhds.congr' (mem_at_top_sets.2 ⟨1, fun n hn => by simp [zero_lt_one.trans_le hn, h0]⟩)\n  have hr' : 1 < (|r|)⁻¹ := one_lt_inv (abs_pos.2 h0) hr\n  rw [tendsto_zero_iff_norm_tendsto_zero]\n  simpa [div_eq_mul_inv] using tendsto_pow_const_div_const_pow_of_one_lt k hr'\n#align tendsto_pow_const_mul_const_pow_of_abs_lt_one tendsto_pow_const_mul_const_pow_of_abs_lt_one\n\n",
 "tendsto_pow_const_div_const_pow_of_one_lt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem tendsto_pow_const_div_const_pow_of_one_lt (k : ℕ) {r : exprℝ} (hr : 1 < r) :\n    tendsto (fun n => n ^ k / r ^ n : ℕ → exprℝ) at_top ((nhds) 0) :=\n  (is_o_pow_const_const_pow_of_one_lt k hr).tendsto_div_nhds_zero\n#align tendsto_pow_const_div_const_pow_of_one_lt tendsto_pow_const_div_const_pow_of_one_lt\n\n",
 "tendsto_pow_at_top_nhds_0_of_norm_lt_1":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- In a normed ring, the powers of an element x with `‖x‖ < 1` tend to zero. -/\ntheorem tendsto_pow_at_top_nhds_0_of_norm_lt_1 {R : Type _} [normed_ring R] {x : R} (h : «expr‖ ‖» x < 1) :\n    tendsto (fun n : ℕ => x ^ n) at_top ((nhds) 0) :=\n  by\n  apply squeeze_zero_norm' (eventually_norm_pow_le x)\n  exact tendsto_pow_at_top_nhds_0_of_lt_1 (norm_nonneg _) h\n#align tendsto_pow_at_top_nhds_0_of_norm_lt_1 tendsto_pow_at_top_nhds_0_of_norm_lt_1\n\n",
 "tendsto_pow_at_top_nhds_0_of_abs_lt_1":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem tendsto_pow_at_top_nhds_0_of_abs_lt_1 {r : exprℝ} (h : |r| < 1) :\n    tendsto (fun n : ℕ => r ^ n) at_top ((nhds) 0) :=\n  tendsto_pow_at_top_nhds_0_of_norm_lt_1 h\n#align tendsto_pow_at_top_nhds_0_of_abs_lt_1 tendsto_pow_at_top_nhds_0_of_abs_lt_1\n\n",
 "tendsto_norm_zpow_nhds_within_0_at_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.ne -/\ntheorem tendsto_norm_zpow_nhds_within_0_at_top {𝕜 : Type _} [normed_field 𝕜] {m : ℤ} (hm : m < 0) :\n    tendsto (fun x : 𝕜 => «expr‖ ‖» (x ^ m)) (nhds_within.ne 0) at_top :=\n  by\n  rcases neg_surjective m with ⟨m, rfl⟩\n  rw [neg_lt_zero] at hm; lift m to ℕ using hm.le; rw [Int.coe_nat_pos] at hm\n  simp only [norm_pow, zpow_neg, zpow_ofNat, ← inv_pow]\n  exact (tendsto_pow_at_top hm.ne').comp normed_field.tendsto_norm_inverse_nhds_within_0_at_top\n#align tendsto_norm_zpow_nhds_within_0_at_top tendsto_norm_zpow_nhds_within_0_at_top\n\n",
 "tendsto_norm_zero'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.ne -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.gt -/\ntheorem tendsto_norm_zero' {𝕜 : Type _} [normed_add_comm_group 𝕜] :\n    tendsto (norm : 𝕜 → exprℝ) (nhds_within.ne 0) (nhds_within.gt 0) :=\n  tendsto_norm_zero.inf <| tendsto_principal_principal.2 fun x hx => norm_pos_iff.2 hx\n#align tendsto_norm_zero' tendsto_norm_zero'\n\n",
 "tendsto_norm_inverse_nhds_within_0_at_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.ne -/\ntheorem tendsto_norm_inverse_nhds_within_0_at_top {𝕜 : Type _} [normed_field 𝕜] :\n    tendsto (fun x : 𝕜 => «expr‖ ‖» x⁻¹) (nhds_within.ne 0) at_top :=\n  (tendsto_inv_zero_at_top.comp tendsto_norm_zero').congr fun x => (norm_inv x).symm\n#align tendsto_norm_inverse_nhds_within_0_at_top tendsto_norm_inverse_nhds_within_0_at_top\n\n",
 "tendsto_norm_at_top_at_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-\nCopyright (c) 2020 Sébastien Gouëzel. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Anatole Dedecker, Sébastien Gouëzel, Yury G. Kudryashov, Dylan MacKenzie, Patrick Massot\n-/\ntheorem tendsto_norm_at_top_at_top : tendsto (norm : exprℝ → exprℝ) at_top at_top :=\n  tendsto_abs_at_top_at_top\n#align tendsto_norm_at_top_at_top tendsto_norm_at_top_at_top\n\n",
 "tendsto_alternating_series_of_tendsto_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- The **alternating series test** for antitone sequences. -/\ntheorem antitone.tendsto_alternating_series_of_tendsto_zero (hfa : antitone f) (hf0 : tendsto f at_top ((nhds) 0)) :\n    ∃ l,\n      tendsto\n        (fun n =>\n          finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n            (range (n + 1)) ((-1) ^ i * f i))\n        at_top ((nhds) l) :=\n  cauchy_seq_tendsto_of_complete <| hfa.cauchy_seq_alternating_series_of_tendsto_zero hf0\n#align antitone.tendsto_alternating_series_of_tendsto_zero antitone.tendsto_alternating_series_of_tendsto_zero\n\n",
 "summable_pow_mul_geometric_of_norm_lt_1":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem summable_pow_mul_geometric_of_norm_lt_1 {R : Type _} [normed_ring R] [complete_space R] (k : ℕ) {r : R}\n    (hr : «expr‖ ‖» r < 1) : summable (fun n => n ^ k * r ^ n : ℕ → R) :=\n  summable_of_summable_norm <| summable_norm_pow_mul_geometric_of_norm_lt_1 _ hr\n#align summable_pow_mul_geometric_of_norm_lt_1 summable_pow_mul_geometric_of_norm_lt_1\n\n",
 "summable_pow_div_factorial":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⌊ ⌋₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⌊ ⌋₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⌊ ⌋₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⌊ ⌋₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⌊ ⌋₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⌊ ⌋₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- The series `∑' n, x ^ n / n!` is summable of any `x : ℝ`. See also `exp_series_div_summable`\nfor a version that also works in `ℂ`, and `exp_series_summable'` for a version that works in\nany normed algebra over `ℝ` or `ℂ`. -/\ntheorem real.summable_pow_div_factorial (x : exprℝ) : summable (fun n => x ^ n / nat.factorial n : ℕ → exprℝ) :=\n  by\n  -- We start with trivial extimates\n  have A : (0 : exprℝ) < «expr⌊ ⌋₊» («expr‖ ‖» x) + 1 := zero_lt_one.trans_le (by simp)\n  have B : «expr‖ ‖» x / («expr⌊ ⌋₊» («expr‖ ‖» x) + 1) < 1 := (div_lt_one A).2 (Nat.lt_floor_add_one _)\n  -- Then we apply the ratio test. The estimate works for `n ≥ ⌊‖x‖⌋₊`.\n  suffices :\n    ∀ n ≥ «expr⌊ ⌋₊» («expr‖ ‖» x),\n      «expr‖ ‖» (x ^ (n + 1) / nat.factorial (n + 1)) ≤\n        «expr‖ ‖» x / («expr⌊ ⌋₊» («expr‖ ‖» x) + 1) * «expr‖ ‖» (x ^ n / ↑(nat.factorial n))\n  exact summable_of_ratio_norm_eventually_le B (eventually_at_top.2 ⟨«expr⌊ ⌋₊» («expr‖ ‖» x), this⟩)\n  -- Finally, we prove the upper estimate\n  intro n hn\n  calc\n    «expr‖ ‖» (x ^ (n + 1) / nat.factorial (n + 1)) = «expr‖ ‖» x / (n + 1) * «expr‖ ‖» (x ^ n / nat.factorial n) := by\n      rw [pow_succ, Nat.factorial_succ, nat.cast_mul, ← div_mul_div_comm, norm_mul, norm_div, real.norm_coe_nat,\n        Nat.cast_succ]\n    _ ≤ «expr‖ ‖» x / («expr⌊ ⌋₊» («expr‖ ‖» x) + 1) * «expr‖ ‖» (x ^ n / nat.factorial n) := by\n      mono* with 0 ≤ «expr‖ ‖» (x ^ n / nat.factorial n), 0 ≤ «expr‖ ‖» x <;> apply norm_nonneg\n    \n#align real.summable_pow_div_factorial real.summable_pow_div_factorial\n\n",
 "summable_of_ratio_test_tendsto_lt_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem summable_of_ratio_test_tendsto_lt_one {α : Type _} [normed_add_comm_group α] [complete_space α] {f : ℕ → α}\n    {l : exprℝ} (hl₁ : l < 1)\n    (hf :\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" at_top\n        (f n ≠ 0))\n    (h : tendsto (fun n => «expr‖ ‖» (f (n + 1)) / «expr‖ ‖» (f n)) at_top ((nhds) l)) : summable f :=\n  by\n  rcases exists_between hl₁ with ⟨r, hr₀, hr₁⟩\n  refine' summable_of_ratio_norm_eventually_le hr₁ _\n  filter_upwards [eventually_le_of_tendsto_lt hr₀ h, hf] with _ _ h₁\n  rwa [← div_le_iff (norm_pos_iff.mpr h₁)]\n#align summable_of_ratio_test_tendsto_lt_one summable_of_ratio_test_tendsto_lt_one\n\n",
 "summable_of_ratio_norm_eventually_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem summable_of_ratio_norm_eventually_le {α : Type _} [seminormed_add_comm_group α] [complete_space α] {f : ℕ → α}\n    {r : exprℝ} (hr₁ : r < 1)\n    (h :\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" at_top\n        («expr‖ ‖» (f (n + 1)) ≤ r * «expr‖ ‖» (f n))) :\n    summable f := by\n  by_cases hr₀ : 0 ≤ r\n  · rw [eventually_at_top] at h\n    rcases h with ⟨N, hN⟩\n    rw [← @summable_nat_add_iff α _ _ _ _ N]\n    refine'\n      summable_of_norm_bounded (fun n => «expr‖ ‖» (f N) * r ^ n)\n        (summable.mul_left _ <| summable_geometric_of_lt_1 hr₀ hr₁) fun n => _\n    conv_rhs => rw [mul_comm, ← zero_add N]\n    refine' le_geom hr₀ n fun i _ => _\n    convert hN (i + N) (N.le_add_left i) using 3\n    ac_rfl\n  · push_neg  at hr₀\n    refine' summable_of_norm_bounded_eventually 0 summable_zero _\n    rw [nat.cofinite_eq_at_top]\n    filter_upwards [h] with _ hn\n    by_contra' h\n    exact not_lt.mpr (norm_nonneg _) (lt_of_le_of_lt hn <| mul_neg_of_neg_of_pos hr₀ h)\n#align summable_of_ratio_norm_eventually_le summable_of_ratio_norm_eventually_le\n\n",
 "summable_of_absolute_convergence_real":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem summable_of_absolute_convergence_real {f : ℕ → exprℝ} :\n    (∃ r,\n        tendsto\n          (fun n =>\n            finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (range n)\n              (|f i|))\n          at_top ((nhds) r)) →\n      summable f\n  | ⟨r, hr⟩ => by\n    refine' summable_of_summable_norm ⟨r, (has_sum_iff_tendsto_nat_of_nonneg _ _).2 _⟩\n    exact fun i => norm_nonneg _\n    simpa only using hr\n#align summable_of_absolute_convergence_real summable_of_absolute_convergence_real\n\n",
 "summable_norm_pow_mul_geometric_of_norm_lt_1":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem summable_norm_pow_mul_geometric_of_norm_lt_1 {R : Type _} [normed_ring R] (k : ℕ) {r : R}\n    (hr : «expr‖ ‖» r < 1) : summable fun n : ℕ => «expr‖ ‖» (n ^ k * r ^ n : R) :=\n  by\n  rcases exists_between hr with ⟨r', hrr', h⟩\n  exact\n    summable_of_is_O_nat (summable_geometric_of_lt_1 ((norm_nonneg _).trans hrr'.le) h)\n      (is_o_pow_const_mul_const_pow_const_pow_of_norm_lt _ hrr').is_O.norm_left\n#align summable_norm_pow_mul_geometric_of_norm_lt_1 summable_norm_pow_mul_geometric_of_norm_lt_1\n\n",
 "summable_geometric_of_norm_lt_1":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/-- A geometric series in a complete normed ring is summable.\nProved above (same name, different namespace) for not-necessarily-complete normed fields. -/\ntheorem normed_ring.summable_geometric_of_norm_lt_1 (x : R) (h : «expr‖ ‖» x < 1) : summable fun n : ℕ => x ^ n :=\n  by\n  have h1 : summable fun n : ℕ => «expr‖ ‖» x ^ n := summable_geometric_of_lt_1 (norm_nonneg _) h\n  refine' summable_of_norm_bounded_eventually _ h1 _\n  rw [nat.cofinite_eq_at_top]\n  exact eventually_norm_pow_le x\n#align normed_ring.summable_geometric_of_norm_lt_1 normed_ring.summable_geometric_of_norm_lt_1\n\n",
 "summable_geometric_of_abs_lt_1":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem summable_geometric_of_abs_lt_1 {r : exprℝ} (h : |r| < 1) : summable fun n : ℕ => r ^ n :=\n  summable_geometric_of_norm_lt_1 h\n#align summable_geometric_of_abs_lt_1 summable_geometric_of_abs_lt_1\n\n",
 "summable_geometric_iff_norm_lt_1":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/-- A geometric series in a normed field is summable iff the norm of the common ratio is less than\none. -/\n@[simp]\ntheorem summable_geometric_iff_norm_lt_1 : (summable fun n : ℕ => ξ ^ n) ↔ «expr‖ ‖» ξ < 1 :=\n  by\n  refine' ⟨fun h => _, summable_geometric_of_norm_lt_1⟩\n  obtain ⟨k : ℕ, hk : dist (ξ ^ k) 0 < 1⟩ := (h.tendsto_cofinite_zero.eventually (ball_mem_nhds _ zero_lt_one)).exists\n  simp only [norm_pow, dist_zero_right] at hk\n  rw [← one_pow k] at hk\n  exact lt_of_pow_lt_pow _ zero_le_one hk\n#align summable_geometric_iff_norm_lt_1 summable_geometric_iff_norm_lt_1\n\n",
 "not_summable_of_ratio_test_tendsto_gt_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem not_summable_of_ratio_test_tendsto_gt_one {α : Type _} [seminormed_add_comm_group α] {f : ℕ → α} {l : exprℝ}\n    (hl : 1 < l) (h : tendsto (fun n => «expr‖ ‖» (f (n + 1)) / «expr‖ ‖» (f n)) at_top ((nhds) l)) : ¬summable f :=\n  by\n  have key :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" at_top\n      («expr‖ ‖» (f n) ≠ 0) :=\n    by\n    filter_upwards [eventually_ge_of_tendsto_gt hl h] with _ hn hc\n    rw [hc, div_zero] at hn\n    linarith\n  rcases exists_between hl with ⟨r, hr₀, hr₁⟩\n  refine' not_summable_of_ratio_norm_eventually_ge hr₀ key.frequently _\n  filter_upwards [eventually_ge_of_tendsto_gt hr₁ h, key] with _ _ h₁\n  rwa [← le_div_iff (lt_of_le_of_ne (norm_nonneg _) h₁.symm)]\n#align not_summable_of_ratio_test_tendsto_gt_one not_summable_of_ratio_test_tendsto_gt_one\n\n",
 "not_summable_of_ratio_norm_eventually_ge":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem not_summable_of_ratio_norm_eventually_ge {α : Type _} [seminormed_add_comm_group α] {f : ℕ → α} {r : exprℝ}\n    (hr : 1 < r)\n    (hf :\n      «expr∃ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , »\" at_top\n        («expr‖ ‖» (f n) ≠ 0))\n    (h :\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" at_top\n        (r * «expr‖ ‖» (f n) ≤ «expr‖ ‖» (f (n + 1)))) :\n    ¬summable f := by\n  rw [eventually_at_top] at h\n  rcases h with ⟨N₀, hN₀⟩\n  rw [frequently_at_top] at hf\n  rcases hf N₀ with ⟨N, hNN₀ : N₀ ≤ N, hN⟩\n  rw [← @summable_nat_add_iff α _ _ _ _ N]\n  refine' mt summable.tendsto_at_top_zero fun h' => not_tendsto_at_top_of_tendsto_nhds (tendsto_norm_zero.comp h') _\n  convert tendsto_at_top_of_geom_le _ hr _\n  · refine' lt_of_le_of_ne (norm_nonneg _) _\n    intro h''\n    specialize hN₀ N hNN₀\n    simp only [comp_app, zero_add] at h''\n    exact hN h''.symm\n  · intro i\n    dsimp only [comp_app]\n    convert hN₀ (i + N) (hNN₀.trans (N.le_add_left i)) using 3\n    ac_rfl\n#align not_summable_of_ratio_norm_eventually_ge not_summable_of_ratio_norm_eventually_ge\n\n",
 "norm_sum_neg_one_pow_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem norm_sum_neg_one_pow_le (n : ℕ) :\n    «expr‖ ‖»\n        (finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (range n)\n          ((-1 : exprℝ) ^ i)) ≤\n      1 :=\n  by\n  rw [neg_one_geom_sum]\n  split_ifs <;> norm_num\n#align norm_sum_neg_one_pow_le norm_sum_neg_one_pow_le\n\n",
 "norm_sub_le_of_geometric_bound_of_has_sum":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/-- If `‖f n‖ ≤ C * r ^ n` for all `n : ℕ` and some `r < 1`, then the partial sums of `f` are within\ndistance `C * r ^ n / (1 - r)` of the sum of the series. This lemma does not assume `0 ≤ r` or\n`0 ≤ C`. -/\ntheorem norm_sub_le_of_geometric_bound_of_has_sum (hr : r < 1) (hf : ∀ n, «expr‖ ‖» (f n) ≤ C * r ^ n) {a : α}\n    (ha : has_sum f a) (n : ℕ) :\n    «expr‖ ‖»\n        (finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n            (Finset.range n) (f x) -\n          a) ≤\n      C * r ^ n / (1 - r) :=\n  by\n  rw [← dist_eq_norm]\n  apply dist_le_of_le_geometric_of_tendsto r C hr (dist_partial_sum_le_of_le_geometric hf)\n  exact ha.tendsto_sum_nat\n#align norm_sub_le_of_geometric_bound_of_has_sum norm_sub_le_of_geometric_bound_of_has_sum\n\n",
 "mul_neg_geom_series":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , » -/\ntheorem mul_neg_geom_series (x : R) (h : «expr‖ ‖» x < 1) :\n    (1 - x) *\n        «expr∑' , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , »\" (x ^ i) =\n      1 :=\n  by\n  have := (normed_ring.summable_geometric_of_norm_lt_1 x h).has_sum.mul_left (1 - x)\n  refine' tendsto_nhds_unique this.tendsto_sum_nat _\n  have : tendsto (fun n : ℕ => 1 - x ^ n) at_top (nhds 1) := by\n    simpa using tendsto_const_nhds.sub (tendsto_pow_at_top_nhds_0_of_norm_lt_1 h)\n  convert ← this\n  ext n\n  rw [← mul_neg_geom_sum, finset.mul_sum]\n#align mul_neg_geom_series mul_neg_geom_series\n\n",
 "is_o_pow_pow_of_lt_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =o[ ] » -/\ntheorem is_o_pow_pow_of_lt_left {r₁ r₂ : exprℝ} (h₁ : 0 ≤ r₁) (h₂ : r₁ < r₂) :\n    «expr =o[ ] » (fun n : ℕ => r₁ ^ n) at_top fun n => r₂ ^ n :=\n  have H : 0 < r₂ := h₁.trans_lt h₂\n  (is_o_of_tendsto fun n hn => false.elim <| H.ne' <| pow_eq_zero hn) <|\n    (tendsto_pow_at_top_nhds_0_of_lt_1 (div_nonneg h₁ (h₁.trans h₂.le)) ((div_lt_one H).2 h₂)).congr fun n =>\n      div_pow _ _ _\n#align is_o_pow_pow_of_lt_left is_o_pow_pow_of_lt_left\n\n",
 "is_o_pow_pow_of_abs_lt_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =o[ ] » -/\ntheorem is_o_pow_pow_of_abs_lt_left {r₁ r₂ : exprℝ} (h : |r₁| < |r₂|) :\n    «expr =o[ ] » (fun n : ℕ => r₁ ^ n) at_top fun n => r₂ ^ n :=\n  by\n  refine' (is_o.of_norm_left _).of_norm_right\n  exact (is_o_pow_pow_of_lt_left (abs_nonneg r₁) h).congr (pow_abs r₁) (pow_abs r₂)\n#align is_o_pow_pow_of_abs_lt_left is_o_pow_pow_of_abs_lt_left\n\n",
 "is_o_pow_const_mul_const_pow_const_pow_of_norm_lt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =o[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =O[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =o[ ] » -/\n/-- If `‖r₁‖ < r₂`, then for any naturak `k` we have `n ^ k r₁ ^ n = o (r₂ ^ n)` as `n → ∞`. -/\ntheorem is_o_pow_const_mul_const_pow_const_pow_of_norm_lt {R : Type _} [normed_ring R] (k : ℕ) {r₁ : R} {r₂ : exprℝ}\n    (h : «expr‖ ‖» r₁ < r₂) : «expr =o[ ] » (fun n => n ^ k * r₁ ^ n : ℕ → R) at_top fun n => r₂ ^ n :=\n  by\n  by_cases h0 : r₁ = 0\n  · refine' (is_o_zero _ _).congr' (mem_at_top_sets.2 <| ⟨1, fun n hn => _⟩) eventually_eq.rfl\n    simp [zero_pow (zero_lt_one.trans_le hn), h0]\n  rw [← ne.def, ← norm_pos_iff] at h0\n  have A : «expr =o[ ] » (fun n => n ^ k : ℕ → R) at_top fun n => (r₂ / «expr‖ ‖» r₁) ^ n :=\n    is_o_pow_const_const_pow_of_one_lt k ((one_lt_div h0).2 h)\n  suffices «expr =O[ ] » (fun n => r₁ ^ n) at_top fun n => «expr‖ ‖» r₁ ^ n by\n    simpa [div_mul_cancel _ (pow_pos h0 _).ne'] using A.mul_is_O this\n  exact is_O.of_bound 1 (by simpa using eventually_norm_pow_le r₁)\n#align is_o_pow_const_mul_const_pow_const_pow_of_norm_lt is_o_pow_const_mul_const_pow_const_pow_of_norm_lt\n\n",
 "is_o_pow_const_const_pow_of_one_lt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.gt -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =O[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =o[ ] » -/\n/-- For any natural `k` and a real `r > 1` we have `n ^ k = o(r ^ n)` as `n → ∞`. -/\ntheorem is_o_pow_const_const_pow_of_one_lt {R : Type _} [normed_ring R] (k : ℕ) {r : exprℝ} (hr : 1 < r) :\n    «expr =o[ ] » (fun n => n ^ k : ℕ → R) at_top fun n => r ^ n :=\n  by\n  have : tendsto (fun x : exprℝ => x ^ k) (nhds_within.gt 1) ((nhds) 1) :=\n    ((continuous_id.pow k).tendsto' (1 : exprℝ) 1 (one_pow _)).mono_left inf_le_left\n  obtain ⟨r' : exprℝ, hr' : r' ^ k < r, h1 : 1 < r'⟩ :=\n    ((this.eventually (gt_mem_nhds hr)).and self_mem_nhds_within).exists\n  have h0 : 0 ≤ r' := zero_le_one.trans h1.le\n  suffices : «expr =O[ ] » (fun n => n ^ k : ℕ → R) at_top fun n : ℕ => (r' ^ k) ^ n\n  exact this.trans_is_o (is_o_pow_pow_of_lt_left (pow_nonneg h0 _) hr')\n  conv in (r' ^ _) ^ _ => rw [← pow_mul, mul_comm, pow_mul]\n  suffices : ∀ n : ℕ, «expr‖ ‖» (n : R) ≤ (r' - 1)⁻¹ * «expr‖ ‖» (1 : R) * «expr‖ ‖» (r' ^ n)\n  exact (is_O_of_le' _ this).pow _\n  intro n\n  rw [mul_right_comm]\n  refine' n.norm_cast_le.trans (mul_le_mul_of_nonneg_right _ (norm_nonneg _))\n  simpa [div_eq_inv_mul, real.norm_eq_abs, abs_of_nonneg h0] using n.cast_le_pow_div_sub h1\n#align is_o_pow_const_const_pow_of_one_lt is_o_pow_const_const_pow_of_one_lt\n\n",
 "is_o_coe_const_pow_of_one_lt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =o[ ] » -/\n/-- For a real `r > 1` we have `n = o(r ^ n)` as `n → ∞`. -/\ntheorem is_o_coe_const_pow_of_one_lt {R : Type _} [normed_ring R] {r : exprℝ} (hr : 1 < r) :\n    «expr =o[ ] » (coe : ℕ → R) at_top fun n => r ^ n := by\n  simpa only [pow_one] using @is_o_pow_const_const_pow_of_one_lt R _ 1 _ hr\n#align is_o_coe_const_pow_of_one_lt is_o_coe_const_pow_of_one_lt\n\n",
 "is_O_pow_pow_of_le_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =O[ ] » -/\ntheorem is_O_pow_pow_of_le_left {r₁ r₂ : exprℝ} (h₁ : 0 ≤ r₁) (h₂ : r₁ ≤ r₂) :\n    «expr =O[ ] » (fun n : ℕ => r₁ ^ n) at_top fun n => r₂ ^ n :=\n  h₂.eq_or_lt.elim (fun h => h ▸ is_O_refl _ _) fun h => (is_o_pow_pow_of_lt_left h₁ h).is_O\n#align is_O_pow_pow_of_le_left is_O_pow_pow_of_le_left\n\n",
 "has_sum_geometric_of_norm_lt_1":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem has_sum_geometric_of_norm_lt_1 (h : «expr‖ ‖» ξ < 1) : has_sum (fun n : ℕ => ξ ^ n) (1 - ξ)⁻¹ :=\n  by\n  have xi_ne_one : ξ ≠ 1 := by\n    contrapose! h\n    simp [h]\n  have A : tendsto (fun n => (ξ ^ n - 1) * (ξ - 1)⁻¹) at_top ((nhds) ((0 - 1) * (ξ - 1)⁻¹)) :=\n    ((tendsto_pow_at_top_nhds_0_of_norm_lt_1 h).sub tendsto_const_nhds).mul tendsto_const_nhds\n  rw [has_sum_iff_tendsto_nat_of_summable_norm]\n  · simpa [geom_sum_eq, xi_ne_one, neg_inv, div_eq_mul_inv] using A\n  · simp [norm_pow, summable_geometric_of_lt_1 (norm_nonneg _) h]\n#align has_sum_geometric_of_norm_lt_1 has_sum_geometric_of_norm_lt_1\n\n",
 "has_sum_geometric_of_abs_lt_1":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem has_sum_geometric_of_abs_lt_1 {r : exprℝ} (h : |r| < 1) : has_sum (fun n : ℕ => r ^ n) (1 - r)⁻¹ :=\n  has_sum_geometric_of_norm_lt_1 h\n#align has_sum_geometric_of_abs_lt_1 has_sum_geometric_of_abs_lt_1\n\n",
 "has_sum_coe_mul_geometric_of_norm_lt_1":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/-- If `‖r‖ < 1`, then `∑' n : ℕ, n * r ^ n = r / (1 - r) ^ 2`, `has_sum` version. -/\ntheorem has_sum_coe_mul_geometric_of_norm_lt_1 {𝕜 : Type _} [normed_field 𝕜] [complete_space 𝕜] {r : 𝕜}\n    (hr : «expr‖ ‖» r < 1) : has_sum (fun n => n * r ^ n : ℕ → 𝕜) (r / (1 - r) ^ 2) :=\n  by\n  have A : summable (fun n => n * r ^ n : ℕ → 𝕜) := by simpa using summable_pow_mul_geometric_of_norm_lt_1 1 hr\n  have B : has_sum (pow r : ℕ → 𝕜) (1 - r)⁻¹ := has_sum_geometric_of_norm_lt_1 hr\n  refine' A.has_sum_iff.2 _\n  have hr' : r ≠ 1 := by\n    rintro rfl\n    simpa [lt_irrefl] using hr\n  set s : 𝕜 :=\n    «expr∑' , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , »\" (n * r ^ n)\n  calc\n    s = (1 - r) * s / (1 - r) := (mul_div_cancel_left _ (sub_ne_zero.2 hr'.symm)).symm\n    _ = (s - r * s) / (1 - r) := by rw [sub_mul, one_mul]\n    _ =\n        ((0 : ℕ) * r ^ 0 +\n              «expr∑' , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , »\"\n                ((n + 1 : ℕ) * r ^ (n + 1)) -\n            r * s) /\n          (1 - r) :=\n      by rw [← tsum_eq_zero_add A]\n    _ =\n        (r *\n              «expr∑' , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , »\"\n                ((n + 1) * r ^ n) -\n            r * s) /\n          (1 - r) :=\n      by simp [pow_succ, mul_left_comm _ r, tsum_mul_left]\n    _ = r / (1 - r) ^ 2 := by simp [add_mul, tsum_add A B.summable, mul_add, B.tsum_eq, ← div_eq_mul_inv, sq, div_div]\n    \n#align has_sum_coe_mul_geometric_of_norm_lt_1 has_sum_coe_mul_geometric_of_norm_lt_1\n\n",
 "geom_series_mul_neg":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , » -/\ntheorem geom_series_mul_neg (x : R) (h : «expr‖ ‖» x < 1) :\n    «expr∑' , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , »\" (x ^ i) *\n        (1 - x) =\n      1 :=\n  by\n  have := (normed_ring.summable_geometric_of_norm_lt_1 x h).has_sum.mul_right (1 - x)\n  refine' tendsto_nhds_unique this.tendsto_sum_nat _\n  have : tendsto (fun n : ℕ => 1 - x ^ n) at_top ((nhds) 1) := by\n    simpa using tendsto_const_nhds.sub (tendsto_pow_at_top_nhds_0_of_norm_lt_1 h)\n  convert ← this\n  ext n\n  rw [← geom_sum_mul_neg, finset.sum_mul]\n#align geom_series_mul_neg geom_series_mul_neg\n\n",
 "dist_partial_sum_le_of_le_geometric":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem dist_partial_sum_le_of_le_geometric (hf : ∀ n, «expr‖ ‖» (f n) ≤ C * r ^ n) (n : ℕ) :\n    dist\n        (finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (range n)\n          (f i))\n        (finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (range (n + 1))\n          (f i)) ≤\n      C * r ^ n :=\n  by\n  rw [sum_range_succ, dist_eq_norm, ← norm_neg, neg_sub, add_sub_cancel']\n  exact hf n\n#align dist_partial_sum_le_of_le_geometric dist_partial_sum_le_of_le_geometric\n\n",
 "dist_partial_sum'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n@[simp]\ntheorem dist_partial_sum' (u : ℕ → α) (n : ℕ) :\n    dist\n        (finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (range n)\n          (u k))\n        (finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (range (n + 1))\n          (u k)) =\n      «expr‖ ‖» (u n) :=\n  by simp [dist_eq_norm', sum_range_succ]\n#align dist_partial_sum' dist_partial_sum'\n\n",
 "dist_partial_sum":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n@[simp]\ntheorem dist_partial_sum (u : ℕ → α) (n : ℕ) :\n    dist\n        (finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (range (n + 1))\n          (u k))\n        (finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (range n)\n          (u k)) =\n      «expr‖ ‖» (u n) :=\n  by simp [dist_eq_norm, sum_range_succ]\n#align dist_partial_sum dist_partial_sum\n\n",
 "continuous_at_zpow":
 "@[simp]\ntheorem continuous_at_zpow {𝕜 : Type _} [nontrivially_normed_field 𝕜] {m : ℤ} {x : 𝕜} :\n    continuous_at (fun x => x ^ m) x ↔ x ≠ 0 ∨ 0 ≤ m :=\n  by\n  refine' ⟨_, continuous_at_zpow₀ _ _⟩\n  contrapose!; rintro ⟨rfl, hm⟩ hc\n  exact\n    not_tendsto_at_top_of_tendsto_nhds (hc.tendsto.mono_left nhds_within_le_nhds).norm\n      (tendsto_norm_zpow_nhds_within_0_at_top hm)\n#align continuous_at_zpow continuous_at_zpow\n\n",
 "continuous_at_inv":
 "@[simp]\ntheorem continuous_at_inv {𝕜 : Type _} [nontrivially_normed_field 𝕜] {x : 𝕜} : continuous_at has_inv.inv x ↔ x ≠ 0 := by\n  simpa [(zero_lt_one' ℤ).not_le] using @continuous_at_zpow _ _ (-1) x\n#align continuous_at_inv continuous_at_inv\n\n",
 "cauchy_series_of_le_geometric''":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem normed_add_comm_group.cauchy_series_of_le_geometric'' {C : exprℝ} {u : ℕ → α} {N : ℕ} {r : exprℝ} (hr₀ : 0 < r)\n    (hr₁ : r < 1) (h : ∀ n ≥ N, «expr‖ ‖» (u n) ≤ C * r ^ n) :\n    cauchy_seq fun n =>\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (range (n + 1))\n        (u k) :=\n  by\n  set v : ℕ → α := fun n => if n < N then 0 else u n\n  have hC : 0 ≤ C := (zero_le_mul_right <| pow_pos hr₀ N).mp ((norm_nonneg _).trans <| h N <| le_refl N)\n  have : ∀ n ≥ N, u n = v n := by\n    intro n hn\n    simp [v, hn, if_neg (not_lt.mpr hn)]\n  refine' cauchy_seq_sum_of_eventually_eq this (normed_add_comm_group.cauchy_series_of_le_geometric' hr₁ _)\n  · exact C\n  intro n\n  dsimp [v]\n  split_ifs with H H\n  · rw [norm_zero]\n    exact mul_nonneg hC (pow_nonneg hr₀.le _)\n  · push_neg  at H\n    exact h _ H\n#align normed_add_comm_group.cauchy_series_of_le_geometric'' normed_add_comm_group.cauchy_series_of_le_geometric''\n\n",
 "cauchy_series_of_le_geometric'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem normed_add_comm_group.cauchy_series_of_le_geometric' {C : exprℝ} {u : ℕ → α} {r : exprℝ} (hr : r < 1)\n    (h : ∀ n, «expr‖ ‖» (u n) ≤ C * r ^ n) :\n    cauchy_seq fun n =>\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (range (n + 1))\n        (u k) :=\n  (cauchy_series_of_le_geometric hr h).comp_tendsto <| tendsto_add_at_top_nat 1\n#align normed_add_comm_group.cauchy_series_of_le_geometric' normed_add_comm_group.cauchy_series_of_le_geometric'\n\n",
 "cauchy_series_of_le_geometric":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem cauchy_series_of_le_geometric {C : exprℝ} {u : ℕ → α} {r : exprℝ} (hr : r < 1)\n    (h : ∀ n, «expr‖ ‖» (u n) ≤ C * r ^ n) :\n    cauchy_seq fun n =>\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (range n) (u k) :=\n  cauchy_seq_of_le_geometric r C hr (by simp [h])\n#align cauchy_series_of_le_geometric cauchy_series_of_le_geometric\n\n",
 "cauchy_seq_series_mul_of_tendsto_zero_of_bounded":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- **Dirichlet's test** for antitone sequences. -/\ntheorem antitone.cauchy_seq_series_mul_of_tendsto_zero_of_bounded (hfa : antitone f) (hf0 : tendsto f at_top ((nhds) 0))\n    (hzb :\n      ∀ n,\n        «expr‖ ‖»\n            (finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (range n)\n              (z i)) ≤\n          b) :\n    cauchy_seq fun n =>\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (range (n + 1))\n        («expr • » (f i) (z i)) :=\n  by\n  have hfa' : monotone fun n => -f n := fun _ _ hab => neg_le_neg <| hfa hab\n  have hf0' : tendsto (fun n => -f n) at_top ((nhds) 0) :=\n    by\n    convert hf0.neg\n    norm_num\n  convert (hfa'.cauchy_seq_series_mul_of_tendsto_zero_of_bounded hf0' hzb).neg\n  funext\n  simp\n#align\n  antitone.cauchy_seq_series_mul_of_tendsto_zero_of_bounded antitone.cauchy_seq_series_mul_of_tendsto_zero_of_bounded\n\n",
 "cauchy_seq_of_le_geometric":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem seminormed_add_comm_group.cauchy_seq_of_le_geometric {C : exprℝ} {r : exprℝ} (hr : r < 1) {u : ℕ → α}\n    (h : ∀ n, «expr‖ ‖» (u n - u (n + 1)) ≤ C * r ^ n) : cauchy_seq u :=\n  cauchy_seq_of_le_geometric r C hr (by simpa [dist_eq_norm] using h)\n#align seminormed_add_comm_group.cauchy_seq_of_le_geometric seminormed_add_comm_group.cauchy_seq_of_le_geometric\n\n",
 "cauchy_seq_finset_of_geometric_bound":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/-- If `‖f n‖ ≤ C * r ^ n` for all `n : ℕ` and some `r < 1`, then the partial sums of `f` form a\nCauchy sequence. This lemma does not assume `0 ≤ r` or `0 ≤ C`. -/\ntheorem cauchy_seq_finset_of_geometric_bound (hr : r < 1) (hf : ∀ n, «expr‖ ‖» (f n) ≤ C * r ^ n) :\n    cauchy_seq fun s : Finset ℕ =>\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s (f x) :=\n  cauchy_seq_finset_of_norm_bounded _ (aux_has_sum_of_le_geometric hr (dist_partial_sum_le_of_le_geometric hf)).summable\n    hf\n#align cauchy_seq_finset_of_geometric_bound cauchy_seq_finset_of_geometric_bound\n\n",
 "cauchy_seq_alternating_series_of_tendsto_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/-- The **alternating series test** for antitone sequences.\nSee also `tendsto_alternating_series_of_antitone_tendsto_zero`. -/\ntheorem antitone.cauchy_seq_alternating_series_of_tendsto_zero (hfa : antitone f) (hf0 : tendsto f at_top ((nhds) 0)) :\n    cauchy_seq fun n =>\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (range (n + 1))\n        ((-1) ^ i * f i) :=\n  by\n  simp_rw [mul_comm]\n  exact hfa.cauchy_seq_series_mul_of_tendsto_zero_of_bounded hf0 norm_sum_neg_one_pow_le\n#align antitone.cauchy_seq_alternating_series_of_tendsto_zero antitone.cauchy_seq_alternating_series_of_tendsto_zero\n\n"}