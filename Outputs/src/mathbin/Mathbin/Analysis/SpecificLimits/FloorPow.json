{"tendsto_div_of_monotone_of_tendsto_div_floor_pow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⌊ ⌋₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⌊ ⌋₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⌊ ⌋₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⌊ ⌋₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⌊ ⌋₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⌊ ⌋₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:69:18: unsupported non-interactive tactic tactic.field_simp.ne_zero -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⌊ ⌋₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⌊ ⌋₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- If a monotone sequence `u` is such that `u ⌊c^n⌋₊ / ⌊c^n⌋₊` converges to a limit `l` for all\n`c > 1`, then `u n / n` tends to `l`. It is even enough to have the assumption for a sequence of\n`c`s converging to `1`. -/\ntheorem tendsto_div_of_monotone_of_tendsto_div_floor_pow (u : ℕ → exprℝ) (l : exprℝ) (hmono : Monotone u)\n    (c : ℕ → exprℝ) (cone : ∀ k, 1 < c k) (clim : Tendsto c atTop ((nhds) 1))\n    (hc : ∀ k, Tendsto (fun n : ℕ => u («expr⌊ ⌋₊» (c k ^ n)) / «expr⌊ ⌋₊» (c k ^ n)) atTop ((nhds) l)) :\n    Tendsto (fun n => u n / n) atTop ((nhds) l) :=\n  by\n  apply tendsto_div_of_monotone_of_exists_subseq_tendsto_div u l hmono\n  intro a ha\n  obtain ⟨k, hk⟩ : ∃ k, c k < a := ((tendsto_order.1 clim).2 a ha).exists\n  refine'\n    ⟨fun n => «expr⌊ ⌋₊» (c k ^ n), _, tendsto_nat_floor_at_top.comp (tendsto_pow_atTop_atTop_of_one_lt (cone k)), hc k⟩\n  have H : ∀ n : ℕ, (0 : exprℝ) < «expr⌊ ⌋₊» (c k ^ n) :=\n    by\n    intro n\n    refine' zero_lt_one.trans_le _\n    simp only [Nat.one_le_cast, Nat.one_le_floor_iff, one_le_pow_of_one_le (cone k).le n]\n  have A :\n    tendsto (fun n : ℕ => («expr⌊ ⌋₊» (c k ^ (n + 1)) : exprℝ) / c k ^ (n + 1) * c k / («expr⌊ ⌋₊» (c k ^ n) / c k ^ n))\n      at_top ((nhds) (1 * c k / 1)) :=\n    by\n    refine' tendsto.div (tendsto.mul _ tendsto_const_nhds) _ one_ne_zero\n    · refine' tendsto_nat_floor_div_at_top.comp _\n      exact (tendsto_pow_atTop_atTop_of_one_lt (cone k)).comp (tendsto_add_at_top_nat 1)\n    · refine' tendsto_nat_floor_div_at_top.comp _\n      exact tendsto_pow_atTop_atTop_of_one_lt (cone k)\n  have B : tendsto (fun n : ℕ => («expr⌊ ⌋₊» (c k ^ (n + 1)) : exprℝ) / «expr⌊ ⌋₊» (c k ^ n)) at_top ((nhds) (c k)) :=\n    by\n    simp only [one_mul, div_one] at A\n    convert A\n    ext1 n\n    simp (disch :=\n      run_tac\n        tactic.field_simp.ne_zero) only [(zero_lt_one.trans (cone k)).ne',\n      ne.def, not_false_iff, (H n).ne', field_simps]\n    ring\n  filter_upwards [(tendsto_order.1 B).2 a hk]with n hn\n  exact (div_le_iff (H n)).1 hn.le\n#align tendsto_div_of_monotone_of_tendsto_div_floor_pow tendsto_div_of_monotone_of_tendsto_div_floor_pow\n\n",
 "tendsto_div_of_monotone_of_exists_subseq_tendsto_div":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.gt -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.gt -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-\nCopyright (c) 2022 Sébastien Gouëzel. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Sébastien Gouëzel\n-/\n/-- If a monotone sequence `u` is such that `u n / n` tends to a limit `l` along subsequences with\nexponential growth rate arbitrarily close to `1`, then `u n / n` tends to `l`. -/\ntheorem tendsto_div_of_monotone_of_exists_subseq_tendsto_div (u : ℕ → exprℝ) (l : exprℝ) (hmono : Monotone u)\n    (hlim :\n      ∀ a : exprℝ,\n        1 < a →\n          ∃ c : ℕ → ℕ,\n            «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\"\n                atTop ((c (n + 1) : exprℝ) ≤ a * c n) ∧\n              Tendsto c atTop atTop ∧ Tendsto (fun n => u (c n) / c n) atTop ((nhds) l)) :\n    Tendsto (fun n => u n / n) atTop ((nhds) l) :=\n  by\n  /- To check the result up to some `ε > 0`, we use a sequence `c` for which the ratio\n    `c (N+1) / c N` is bounded by `1 + ε`. Sandwiching a given `n` between two consecutive values of\n    `c`, say `c N` and `c (N+1)`, one can then bound `u n / n` from above by `u (c N) / c (N - 1)`\n    and from below by `u (c (N - 1)) / c N` (using that `u` is monotone), which are both comparable\n    to the limit `l` up to `1 + ε`.\n    We give a version of this proof by clearing out denominators first, to avoid discussing the sign\n    of different quantities. -/\n  have lnonneg : 0 ≤ l := by\n    rcases hlim 2 one_lt_two with ⟨c, cgrowth, ctop, clim⟩\n    have : tendsto (fun n => u 0 / c n) at_top ((nhds) 0) :=\n      tendsto_const_nhds.div_at_top (tendsto_nat_cast_atTop_iff.2 Ctop)\n    apply le_of_tendsto_of_tendsto' this clim fun n => _\n    simp_rw [div_eq_inv_mul]\n    exact mul_le_mul_of_nonneg_left (hmono (zero_le _)) (inv_nonneg.2 (Nat.cast_nonneg _))\n  have A :\n    ∀ ε : exprℝ,\n      0 < ε →\n        «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" at_top\n          (u n - n * l ≤ ε * (1 + ε + l) * n) :=\n    by\n    intro ε εpos\n    rcases hlim (1 + ε) ((lt_add_iff_pos_right _).2 εpos) with ⟨c, cgrowth, ctop, clim⟩\n    have L :\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" at_top\n        (u (c n) - c n * l ≤ ε * c n) :=\n      by\n      rw [← tendsto_sub_nhds_zero_iff, ← Asymptotics.isLittleO_one_iff (exprℝ), Asymptotics.isLittleO_iff] at clim\n      filter_upwards [clim εpos, Ctop (Ioi_mem_at_top 0)]with n hn cnpos'\n      have cnpos : 0 < c n := cnpos'\n      calc\n        u (c n) - c n * l = (u (c n) / c n - l) * c n := by\n          simp only [cnpos.ne', ne.def, Nat.cast_eq_zero, not_false_iff, field_simps]\n        _ ≤ ε * c n := by\n          refine' mul_le_mul_of_nonneg_right _ (Nat.cast_nonneg _)\n          simp only [mul_one, Real.norm_eq_abs, abs_one] at hn\n          exact le_trans (le_abs_self _) hn\n        \n    obtain ⟨a, ha⟩ : ∃ a : ℕ, ∀ b : ℕ, a ≤ b → (c (b + 1) : exprℝ) ≤ (1 + ε) * c b ∧ u (c b) - c b * l ≤ ε * c b :=\n      eventually_at_top.1 (cgrowth.and L)\n    let M := ((Finset.range (a + 1)).image fun i => c i).max' (by simp)\n    filter_upwards [Ici_mem_at_top M]with n hn\n    have exN : ∃ N, n < c N := by\n      rcases(tendsto_at_top.1 Ctop (n + 1)).exists with ⟨N, hN⟩\n      exact ⟨N, by linarith only [hN]⟩\n    let N := nat.find exN\n    have ncN : n < c N := nat.find_spec exN\n    have aN : a + 1 ≤ N := by\n      by_contra' h\n      have cNM : c N ≤ M := by\n        apply le_max'\n        apply mem_image_of_mem\n        exact mem_range.2 h\n      exact lt_irrefl _ ((cNM.trans hn).trans_lt ncN)\n    have Npos : 0 < N := lt_of_lt_of_le Nat.succ_pos' aN\n    have cNn : c (N - 1) ≤ n := by\n      have : N - 1 < N := nat.pred_lt Npos.ne'\n      simpa only [not_lt] using nat.find_min exN this\n    have IcN : (c N : exprℝ) ≤ (1 + ε) * c (N - 1) :=\n      by\n      have A : a ≤ N - 1 := by linarith only [aN, Npos]\n      have B : N - 1 + 1 = N := nat.succ_pred_eq_of_pos Npos\n      have := (ha _ A).1\n      rwa [B] at this\n    calc\n      u n - n * l ≤ u (c N) - c (N - 1) * l := by\n        apply sub_le_sub (hmono ncN.le)\n        apply mul_le_mul_of_nonneg_right (Nat.cast_le.2 cNn) lnonneg\n      _ = u (c N) - c N * l + (c N - c (N - 1)) * l := by ring\n      _ ≤ ε * c N + ε * c (N - 1) * l := by\n        apply add_le_add\n        · apply (ha _ _).2\n          exact le_trans (by simp only [le_add_iff_nonneg_right, zero_le']) aN\n        · apply mul_le_mul_of_nonneg_right _ lnonneg\n          linarith only [IcN]\n      _ ≤ ε * ((1 + ε) * c (N - 1)) + ε * c (N - 1) * l := (add_le_add (mul_le_mul_of_nonneg_left IcN εpos.le) le_rfl)\n      _ = ε * (1 + ε + l) * c (N - 1) := by ring\n      _ ≤ ε * (1 + ε + l) * n := by\n        refine' mul_le_mul_of_nonneg_left (Nat.cast_le.2 cNn) _\n        apply mul_nonneg εpos.le\n        linarith only [εpos, lnonneg]\n      \n  have B :\n    ∀ ε : exprℝ,\n      0 < ε →\n        «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" at_top\n          ((n : exprℝ) * l - u n ≤ ε * (1 + l) * n) :=\n    by\n    intro ε εpos\n    rcases hlim (1 + ε) ((lt_add_iff_pos_right _).2 εpos) with ⟨c, cgrowth, ctop, clim⟩\n    have L :\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" at_top\n        ((c n : exprℝ) * l - u (c n) ≤ ε * c n) :=\n      by\n      rw [← tendsto_sub_nhds_zero_iff, ← Asymptotics.isLittleO_one_iff (exprℝ), Asymptotics.isLittleO_iff] at clim\n      filter_upwards [clim εpos, Ctop (Ioi_mem_at_top 0)]with n hn cnpos'\n      have cnpos : 0 < c n := cnpos'\n      calc\n        (c n : exprℝ) * l - u (c n) = -(u (c n) / c n - l) * c n := by\n          simp only [cnpos.ne', ne.def, Nat.cast_eq_zero, not_false_iff, neg_sub, field_simps]\n        _ ≤ ε * c n := by\n          refine' mul_le_mul_of_nonneg_right _ (Nat.cast_nonneg _)\n          simp only [mul_one, Real.norm_eq_abs, abs_one] at hn\n          exact le_trans (neg_le_abs_self _) hn\n        \n    obtain ⟨a, ha⟩ :\n      ∃ a : ℕ, ∀ b : ℕ, a ≤ b → (c (b + 1) : exprℝ) ≤ (1 + ε) * c b ∧ (c b : exprℝ) * l - u (c b) ≤ ε * c b :=\n      eventually_at_top.1 (cgrowth.and L)\n    let M := ((Finset.range (a + 1)).image fun i => c i).max' (by simp)\n    filter_upwards [Ici_mem_at_top M]with n hn\n    have exN : ∃ N, n < c N := by\n      rcases(tendsto_at_top.1 Ctop (n + 1)).exists with ⟨N, hN⟩\n      exact ⟨N, by linarith only [hN]⟩\n    let N := nat.find exN\n    have ncN : n < c N := nat.find_spec exN\n    have aN : a + 1 ≤ N := by\n      by_contra' h\n      have cNM : c N ≤ M := by\n        apply le_max'\n        apply mem_image_of_mem\n        exact mem_range.2 h\n      exact lt_irrefl _ ((cNM.trans hn).trans_lt ncN)\n    have Npos : 0 < N := lt_of_lt_of_le Nat.succ_pos' aN\n    have aN' : a ≤ N - 1 := by linarith only [aN, Npos]\n    have cNn : c (N - 1) ≤ n := by\n      have : N - 1 < N := nat.pred_lt Npos.ne'\n      simpa only [not_lt] using nat.find_min exN this\n    calc\n      (n : exprℝ) * l - u n ≤ c N * l - u (c (N - 1)) :=\n        by\n        refine' add_le_add (mul_le_mul_of_nonneg_right (Nat.cast_le.2 ncN.le) lnonneg) _\n        exact neg_le_neg (hmono cNn)\n      _ ≤ (1 + ε) * c (N - 1) * l - u (c (N - 1)) :=\n        by\n        refine' add_le_add (mul_le_mul_of_nonneg_right _ lnonneg) le_rfl\n        have B : N - 1 + 1 = N := nat.succ_pred_eq_of_pos Npos\n        have := (ha _ aN').1\n        rwa [B] at this\n      _ = c (N - 1) * l - u (c (N - 1)) + ε * c (N - 1) * l := by ring\n      _ ≤ ε * c (N - 1) + ε * c (N - 1) * l := (add_le_add (ha _ aN').2 le_rfl)\n      _ = ε * (1 + l) * c (N - 1) := by ring\n      _ ≤ ε * (1 + l) * n := by\n        refine' mul_le_mul_of_nonneg_left (Nat.cast_le.2 cNn) _\n        exact mul_nonneg εpos.le (add_nonneg zero_le_one lnonneg)\n      \n  refine' tendsto_order.2 ⟨fun d hd => _, fun d hd => _⟩\n  · obtain ⟨ε, hε, εpos⟩ : ∃ ε : exprℝ, d + ε * (1 + l) < l ∧ 0 < ε :=\n      by\n      have L : tendsto (fun ε => d + ε * (1 + l)) (nhds_within.gt 0) ((nhds) (d + 0 * (1 + l))) :=\n        by\n        apply tendsto.mono_left _ nhdsWithin_le_nhds\n        exact tendsto_const_nhds.add (tendsto_id.mul tendsto_const_nhds)\n      simp only [MulZeroClass.zero_mul, add_zero] at L\n      exact (((tendsto_order.1 L).2 l hd).and self_mem_nhdsWithin).exists\n    filter_upwards [B ε εpos, Ioi_mem_at_top 0]with n hn npos\n    simp_rw [div_eq_inv_mul]\n    calc\n      d < n⁻¹ * n * (l - ε * (1 + l)) := by\n        rw [inv_mul_cancel, one_mul]\n        · linarith only [hε]\n        · exact Nat.cast_ne_zero.2 (ne_of_gt npos)\n      _ = n⁻¹ * (n * l - ε * (1 + l) * n) := by ring\n      _ ≤ n⁻¹ * u n := by\n        refine' mul_le_mul_of_nonneg_left _ (inv_nonneg.2 (Nat.cast_nonneg _))\n        linarith only [hn]\n      \n  · obtain ⟨ε, hε, εpos⟩ : ∃ ε : exprℝ, l + ε * (1 + ε + l) < d ∧ 0 < ε :=\n      by\n      have L : tendsto (fun ε => l + ε * (1 + ε + l)) (nhds_within.gt 0) ((nhds) (l + 0 * (1 + 0 + l))) :=\n        by\n        apply tendsto.mono_left _ nhdsWithin_le_nhds\n        exact tendsto_const_nhds.add (tendsto_id.mul ((tendsto_const_nhds.add tendsto_id).add tendsto_const_nhds))\n      simp only [MulZeroClass.zero_mul, add_zero] at L\n      exact (((tendsto_order.1 L).2 d hd).and self_mem_nhdsWithin).exists\n    filter_upwards [A ε εpos, Ioi_mem_at_top 0]with n hn npos\n    simp_rw [div_eq_inv_mul]\n    calc\n      (n : exprℝ)⁻¹ * u n ≤ (n : exprℝ)⁻¹ * (n * l + ε * (1 + ε + l) * n) :=\n        by\n        refine' mul_le_mul_of_nonneg_left _ (inv_nonneg.2 (Nat.cast_nonneg _))\n        linarith only [hn]\n      _ = (n : exprℝ)⁻¹ * n * (l + ε * (1 + ε + l)) := by ring\n      _ < d := by\n        rwa [inv_mul_cancel, one_mul]\n        exact Nat.cast_ne_zero.2 (ne_of_gt npos)\n      \n#align tendsto_div_of_monotone_of_exists_subseq_tendsto_div tendsto_div_of_monotone_of_exists_subseq_tendsto_div\n\n",
 "sum_div_pow_sq_le_div_sq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⌊ ⌋₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⌊ ⌋₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⌊ ⌋₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/-- The sum of `1/(c^i)^2` above a threshold `j` is comparable to `1/j^2`, up to a multiplicative\nconstant. -/\ntheorem sum_div_pow_sq_le_div_sq (N : ℕ) {j : exprℝ} (hj : 0 < j) {c : exprℝ} (hc : 1 < c) :\n    finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n        ((range N).filter fun i => j < c ^ i) (1 / (c ^ i) ^ 2) ≤\n      c ^ 3 * (c - 1)⁻¹ / j ^ 2 :=\n  by\n  have cpos : 0 < c := zero_lt_one.trans hc\n  have A : 0 < c⁻¹ ^ 2 := sq_pos_of_pos (inv_pos.2 cpos)\n  have B : c ^ 2 * (1 - c⁻¹ ^ 2)⁻¹ ≤ c ^ 3 * (c - 1)⁻¹ :=\n    by\n    rw [← div_eq_mul_inv, ← div_eq_mul_inv, div_le_div_iff _ (sub_pos.2 hc)]\n    swap\n    · exact sub_pos.2 (pow_lt_one (inv_nonneg.2 cpos.le) (inv_lt_one hc) two_ne_zero)\n    have : c ^ 3 = c ^ 2 * c := by ring\n    simp only [mul_sub, this, mul_one, inv_pow, sub_le_sub_iff_left]\n    rw [mul_assoc, mul_comm c, ← mul_assoc, mul_inv_cancel (sq_pos_of_pos cpos).ne', one_mul]\n    simpa using pow_le_pow hc.le one_le_two\n  calc\n    finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n          ((range N).filter fun i => j < c ^ i) (1 / (c ^ i) ^ 2) ≤\n        finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n          (Ico («expr⌊ ⌋₊» (real.log j / real.log c)) N) (1 / (c ^ i) ^ 2) :=\n      by\n      refine' sum_le_sum_of_subset_of_nonneg _ fun i hi hident => div_nonneg zero_le_one (sq_nonneg _)\n      intro i hi\n      simp only [mem_filter, mem_range] at hi\n      simp only [hi.1, mem_Ico, and_true_iff]\n      apply Nat.floor_le_of_le\n      apply le_of_lt\n      rw [div_lt_iff (real.log_pos hc), ← real.log_pow]\n      exact real.log_lt_log hj hi.2\n    _ =\n        finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n          (Ico («expr⌊ ⌋₊» (real.log j / real.log c)) N) ((c⁻¹ ^ 2) ^ i) :=\n      by\n      congr 1 with i\n      simp [← pow_mul, mul_comm]\n    _ ≤ (c⁻¹ ^ 2) ^ «expr⌊ ⌋₊» (real.log j / real.log c) / (1 - c⁻¹ ^ 2) :=\n      by\n      apply geom_sum_Ico_le_of_lt_one (sq_nonneg _)\n      rw [sq_lt_one_iff (inv_nonneg.2 (zero_le_one.trans hc.le))]\n      exact inv_lt_one hc\n    _ ≤ (c⁻¹ ^ 2) ^ (real.log j / real.log c - 1) / (1 - c⁻¹ ^ 2) :=\n      by\n      apply div_le_div _ _ _ le_rfl\n      · apply real.rpow_nonneg_of_nonneg (sq_nonneg _)\n      · rw [← real.rpow_nat_cast]\n        apply real.rpow_le_rpow_of_exponent_ge A\n        · exact pow_le_one _ (inv_nonneg.2 (zero_le_one.trans hc.le)) (inv_le_one hc.le)\n        · exact (Nat.sub_one_lt_floor _).le\n      · simpa only [inv_pow, sub_pos] using inv_lt_one (one_lt_pow hc two_ne_zero)\n    _ = c ^ 2 * (1 - c⁻¹ ^ 2)⁻¹ / j ^ 2 :=\n      by\n      have I : (c⁻¹ ^ 2) ^ (real.log j / real.log c) = 1 / j ^ 2 :=\n        by\n        apply real.log_inj_on_pos (real.rpow_pos_of_pos A _)\n        · rw [one_div]\n          exact inv_pos.2 (sq_pos_of_pos hj)\n        rw [real.log_rpow A]\n        simp only [one_div, real.log_inv, real.log_pow, Nat.cast_bit0, Nat.cast_one, mul_neg, neg_inj]\n        field_simp [(real.log_pos hc).ne']\n        ring\n      rw [real.rpow_sub A, I]\n      have : c ^ 2 - 1 ≠ 0 := (sub_pos.2 (one_lt_pow hc two_ne_zero)).ne'\n      field_simp [hj.ne', (zero_lt_one.trans hc).ne']\n      ring\n    _ ≤ c ^ 3 * (c - 1)⁻¹ / j ^ 2 := by\n      apply div_le_div _ B (sq_pos_of_pos hj) le_rfl\n      exact mul_nonneg (pow_nonneg cpos.le _) (inv_nonneg.2 (sub_pos.2 hc).le)\n    \n#align sum_div_pow_sq_le_div_sq sum_div_pow_sq_le_div_sq\n\n",
 "sum_div_nat_floor_pow_sq_le_div_sq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⌊ ⌋₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⌊ ⌋₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⌊ ⌋₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⌊ ⌋₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⌊ ⌋₊» -/\n/-- The sum of `1/⌊c^i⌋₊^2` above a threshold `j` is comparable to `1/j^2`, up to a multiplicative\nconstant. -/\ntheorem sum_div_nat_floor_pow_sq_le_div_sq (N : ℕ) {j : exprℝ} (hj : 0 < j) {c : exprℝ} (hc : 1 < c) :\n    finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n        ((range N).filter fun i => j < «expr⌊ ⌋₊» (c ^ i)) ((1 : exprℝ) / «expr⌊ ⌋₊» (c ^ i) ^ 2) ≤\n      c ^ 5 * (c - 1)⁻¹ ^ 3 / j ^ 2 :=\n  by\n  have cpos : 0 < c := zero_lt_one.trans hc\n  have A : 0 < 1 - c⁻¹ := sub_pos.2 (inv_lt_one hc)\n  calc\n    finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n          ((range N).filter fun i => j < «expr⌊ ⌋₊» (c ^ i)) ((1 : exprℝ) / «expr⌊ ⌋₊» (c ^ i) ^ 2) ≤\n        finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n          ((range N).filter fun i => j < c ^ i) ((1 : exprℝ) / «expr⌊ ⌋₊» (c ^ i) ^ 2) :=\n      by\n      apply sum_le_sum_of_subset_of_nonneg\n      · intro i hi\n        simp only [mem_filter, mem_range] at hi\n        simpa only [hi.1, mem_filter, mem_range, true_and_iff] using hi.2.trans_le (Nat.floor_le (pow_nonneg cpos.le _))\n      · intro i hi hident\n        exact div_nonneg zero_le_one (sq_nonneg _)\n    _ ≤\n        finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n          ((range N).filter fun i => j < c ^ i) ((1 - c⁻¹)⁻¹ ^ 2 * (1 / (c ^ i) ^ 2)) :=\n      by\n      apply sum_le_sum fun i hi => _\n      rw [mul_div_assoc', mul_one, div_le_div_iff]; rotate_left\n      · apply sq_pos_of_pos\n        refine' zero_lt_one.trans_le _\n        simp only [Nat.le_floor, one_le_pow_of_one_le, hc.le, Nat.one_le_cast, Nat.cast_one]\n      · exact sq_pos_of_pos (pow_pos cpos _)\n      rw [one_mul, ← mul_pow]\n      apply pow_le_pow_of_le_left (pow_nonneg cpos.le _)\n      rw [← div_eq_inv_mul, le_div_iff A, mul_comm]\n      exact mul_pow_le_nat_floor_pow hc i\n    _ ≤ (1 - c⁻¹)⁻¹ ^ 2 * (c ^ 3 * (c - 1)⁻¹) / j ^ 2 :=\n      by\n      rw [← mul_sum, ← mul_div_assoc']\n      refine' mul_le_mul_of_nonneg_left _ (sq_nonneg _)\n      exact sum_div_pow_sq_le_div_sq N hj hc\n    _ = c ^ 5 * (c - 1)⁻¹ ^ 3 / j ^ 2 := by\n      congr 1\n      field_simp [cpos.ne', (sub_pos.2 hc).ne']\n      ring\n    \n#align sum_div_nat_floor_pow_sq_le_div_sq sum_div_nat_floor_pow_sq_le_div_sq\n\n",
 "mul_pow_le_nat_floor_pow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⌊ ⌋₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⌊ ⌋₊» -/\ntheorem mul_pow_le_nat_floor_pow {c : exprℝ} (hc : 1 < c) (i : ℕ) : (1 - c⁻¹) * c ^ i ≤ «expr⌊ ⌋₊» (c ^ i) :=\n  by\n  have cpos : 0 < c := zero_lt_one.trans hc\n  rcases nat.eq_zero_or_pos i with (rfl | hi)\n  · simp only [pow_zero, Nat.floor_one, Nat.cast_one, mul_one, sub_le_self_iff, inv_nonneg, cpos.le]\n  have hident : 1 ≤ i := hi\n  calc\n    (1 - c⁻¹) * c ^ i = c ^ i - c ^ i * c⁻¹ := by ring\n    _ ≤ c ^ i - 1 := by\n      simpa only [← div_eq_mul_inv, sub_le_sub_iff_left, one_le_div cpos, pow_one] using pow_le_pow hc.le hident\n    _ ≤ «expr⌊ ⌋₊» (c ^ i) := (Nat.sub_one_lt_floor _).le\n    \n#align mul_pow_le_nat_floor_pow mul_pow_le_nat_floor_pow\n\n"}