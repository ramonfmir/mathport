{"sum_split_boxes":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem sum_split_boxes {M : Type _} [add_comm_monoid M] (I : box ι) (i : ι) (x : exprℝ) (f : box ι → M) :\n    finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (split I i x).boxes\n        (f J) =\n      (I.split_lower i x).elim 0 f + (I.split_upper i x).elim 0 f :=\n  by rw [split, sum_of_with_bot, finset.sum_pair (I.split_lower_ne_split_upper i x)]\n#align sum_split_boxes sum_split_boxes\n\n",
 "split_upper_le":
 "theorem split_upper_le : I.split_upper i x ≤ I :=\n  with_bot_coe_subset_iff.1 <| by simp\n#align split_upper_le split_upper_le\n\n",
 "split_upper_eq_self":
 "@[simp]\ntheorem split_upper_eq_self : I.split_upper i x = I ↔ x ≤ I.lower i := by simp [split_upper, update_eq_iff]\n#align split_upper_eq_self split_upper_eq_self\n\n",
 "split_upper_eq_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem split_upper_eq_bot {i x} : I.split_upper i x = «expr⊥» ↔ I.upper i ≤ x :=\n  by\n  rw [split_upper, mk'_eq_bot, exists_update_iff I.lower fun j y => I.upper j ≤ y]\n  simp [(I.lower_lt_upper _).not_le]\n#align split_upper_eq_bot split_upper_eq_bot\n\n",
 "split_upper_def":
 "theorem split_upper_def [decidable_eq ι] {i x} (h : x ∈ Ioo (I.lower i) (I.upper i))\n    (h' : ∀ j, update I.lower i x j < I.upper j :=\n      (forall_update_iff I.lower fun j y => y < I.upper j).2 ⟨h.2, fun j hne => I.lower_lt_upper _⟩) :\n    I.split_upper i x = (⟨update I.lower i x, I.upper, h'⟩ : box ι) :=\n  by\n  simp only [split_upper, mk'_eq_coe, max_eq_left h.1.le]\n  refine' ⟨_, rfl⟩\n  congr\n#align split_upper_def split_upper_def\n\n",
 "split_of_not_mem_Ioo":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/-- If `x ∉ (I.lower i, I.upper i)`, then the hyperplane `{y | y i = x}` does not split `I`. -/\ntheorem split_of_not_mem_Ioo (h : x ∉ Ioo (I.lower i) (I.upper i)) : split I i x = «expr⊤» :=\n  by\n  refine' ((is_partition_top I).eq_of_boxes_subset fun J hJ => _).symm\n  rcases mem_top.1 hJ with rfl; clear hJ\n  rw [mem_boxes, mem_split_iff]\n  rw [mem_Ioo, not_and_or, not_lt, not_lt] at h\n  cases h <;> [right, left]\n  · rwa [eq_comm, box.split_upper_eq_self]\n  · rwa [eq_comm, box.split_lower_eq_self]\n#align split_of_not_mem_Ioo split_of_not_mem_Ioo\n\n",
 "split_many_le_split":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem split_many_le_split (I : box ι) {s : Finset (ι × exprℝ)} {p : ι × exprℝ} (hp : p ∈ s) :\n    split_many I s ≤ split I p.1 p.2 :=\n  finset.inf_le hp\n#align split_many_le_split split_many_le_split\n\n",
 "split_many_insert":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n@[simp]\ntheorem split_many_insert (I : box ι) (s : Finset (ι × exprℝ)) (p : ι × exprℝ) :\n    split_many I (insert p s) = «expr ⊓ » (split_many I s) (split I p.1 p.2) := by\n  rw [split_many, finset.inf_insert, inf_comm, split_many]\n#align split_many_insert split_many_insert\n\n",
 "split_many_empty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem split_many_empty (I : box ι) : split_many I ∅ = «expr⊤» :=\n  finset.inf_empty\n#align split_many_empty split_many_empty\n\n",
 "split_lower_ne_split_upper":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem split_lower_ne_split_upper (I : box ι) (i : ι) (x : exprℝ) : I.split_lower i x ≠ I.split_upper i x :=\n  by\n  cases le_or_lt x (I.lower i)\n  · rw [split_upper_eq_self.2 h, split_lower_eq_bot.2 h]\n    exact WithBot.bot_ne_coe\n  · refine' (disjoint_split_lower_split_upper I i x).ne _\n    rwa [ne.def, split_lower_eq_bot, not_le]\n#align split_lower_ne_split_upper split_lower_ne_split_upper\n\n",
 "split_lower_le":
 "theorem split_lower_le : I.split_lower i x ≤ I :=\n  with_bot_coe_subset_iff.1 <| by simp\n#align split_lower_le split_lower_le\n\n",
 "split_lower_eq_self":
 "@[simp]\ntheorem split_lower_eq_self : I.split_lower i x = I ↔ I.upper i ≤ x := by simp [split_lower, update_eq_iff]\n#align split_lower_eq_self split_lower_eq_self\n\n",
 "split_lower_eq_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem split_lower_eq_bot {i x} : I.split_lower i x = «expr⊥» ↔ x ≤ I.lower i :=\n  by\n  rw [split_lower, mk'_eq_bot, exists_update_iff I.upper fun j y => y ≤ I.lower j]\n  simp [(I.lower_lt_upper _).not_le]\n#align split_lower_eq_bot split_lower_eq_bot\n\n",
 "split_lower_def":
 "theorem split_lower_def [decidable_eq ι] {i x} (h : x ∈ Ioo (I.lower i) (I.upper i))\n    (h' : ∀ j, I.lower j < update I.upper i x j :=\n      (forall_update_iff I.upper fun j y => I.lower j < y).2 ⟨h.1, fun j hne => I.lower_lt_upper _⟩) :\n    I.split_lower i x = (⟨I.lower, update I.upper i x, h'⟩ : box ι) :=\n  by\n  simp only [split_lower, mk'_eq_coe, min_eq_left h.2.le]\n  use rfl\n  congr\n#align split_lower_def split_lower_def\n\n",
 "restrict_split":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n@[simp]\ntheorem restrict_split (h : I ≤ J) (i : ι) (x : exprℝ) : (split J i x).restrict I = split I i x :=\n  by\n  refine' ((is_partition_split J i x).restrict h).eq_of_boxes_subset _\n  simp only [Finset.subset_iff, mem_boxes, mem_restrict', exists_prop, mem_split_iff']\n  have : ∀ s, (I ∩ s : set (ι → exprℝ)) ⊆ J := fun s => (inter_subset_left _ _).trans h\n  rintro J₁ ⟨J₂, H₂ | H₂, H₁⟩ <;> [left, right] <;> simp [H₁, H₂, inter_left_comm ↑I, this]\n#align restrict_split restrict_split\n\n",
 "not_disjoint_imp_le_of_subset_of_mem_split_many":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- Let `s : finset (ι × ℝ)` be a set of hyperplanes `{x : ι → ℝ | x i = r}` in `ι → ℝ` encoded as\npairs `(i, r)`. Suppose that this set contains all faces of a box `J`. The hyperplanes of `s` split\na box `I` into subboxes. Let `Js` be one of them. If `J` and `Js` have nonempty intersection, then\n`Js` is a subbox of `J`.  -/\ntheorem not_disjoint_imp_le_of_subset_of_mem_split_many {I J Js : box ι} {s : Finset (ι × exprℝ)}\n    (H : ∀ i, {(i, J i), (i, J.upper i)} ⊆ s) (HJs : Js ∈ split_many I s) (Hn : ¬Disjoint (J : WithBot (box ι)) Js) :\n    Js ≤ J := by\n  simp only [Finset.insert_subset, Finset.singleton_subset_iff] at H\n  rcases box.not_disjoint_coe_iff_nonempty_inter.mp Hn with ⟨x, hx, hxs⟩\n  refine' fun y hy i => ⟨_, _⟩\n  · rcases split_many_le_split I (H i).1 HJs with ⟨Jl, Hmem : Jl ∈ split I i (J.lower i), Hle⟩\n    have := Hle hxs\n    rw [← box.coe_subset_coe, coe_eq_of_mem_split_of_lt_mem Hmem this (hx i).1] at Hle\n    exact (Hle hy).2\n  · rcases split_many_le_split I (H i).2 HJs with ⟨Jl, Hmem : Jl ∈ split I i (J.upper i), Hle⟩\n    have := Hle hxs\n    rw [← box.coe_subset_coe, coe_eq_of_mem_split_of_mem_le Hmem this (hx i).2] at Hle\n    exact (Hle hy).2\n#align not_disjoint_imp_le_of_subset_of_mem_split_many not_disjoint_imp_le_of_subset_of_mem_split_many\n\n",
 "mem_split_iff'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem mem_split_iff' :\n    J ∈ split I i x ↔ (J : set (ι → exprℝ)) = I ∩ { y | y i ≤ x } ∨ (J : set (ι → exprℝ)) = I ∩ { y | x < y i } := by\n  simp [mem_split_iff, ← box.with_bot_coe_inj]\n#align mem_split_iff' mem_split_iff'\n\n",
 "mem_split_iff":
 "@[simp]\ntheorem mem_split_iff : J ∈ split I i x ↔ ↑J = I.split_lower i x ∨ ↑J = I.split_upper i x := by simp [split]\n#align mem_split_iff mem_split_iff\n\n",
 "is_partition_split_many":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem is_partition_split_many (I : box ι) (s : Finset (ι × exprℝ)) : is_partition (split_many I s) :=\n  Finset.induction_on s (by simp only [split_many_empty, is_partition_top]) fun a s ha hs => by\n    simpa only [split_many_insert, inf_split] using hs.bUnion fun J hJ => is_partition_split _ _ _\n#align is_partition_split_many is_partition_split_many\n\n",
 "is_partition_split":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem is_partition_split (I : box ι) (i : ι) (x : exprℝ) : is_partition (split I i x) :=\n  is_partition_iff_Union_eq.2 <| Union_split I i x\n#align is_partition_split is_partition_split\n\n",
 "inf_split_many":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\ntheorem inf_split_many {I : box ι} (π : prepartition I) (s : Finset (ι × exprℝ)) :\n    «expr ⊓ » π (split_many I s) = π.bUnion fun J => split_many J s :=\n  by\n  induction' s using Finset.induction_on with p s hp ihp\n  · simp\n  · simp_rw [split_many_insert, ← inf_assoc, ihp, inf_split, bUnion_assoc]\n#align inf_split_many inf_split_many\n\n",
 "inf_split":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\ntheorem inf_split (π : prepartition I) (i : ι) (x : exprℝ) :\n    «expr ⊓ » π (split I i x) = π.bUnion fun J => split J i x :=\n  bUnion_congr_of_le rfl fun J hJ => restrict_split hJ i x\n#align inf_split inf_split\n\n",
 "exists_split_many_le":
 "/-- If `π` is a partition of `I`, then there exists a finite set `s` of hyperplanes such that\n`split_many I s ≤ π`. -/\ntheorem is_partition.exists_split_many_le {I : box ι} {π : prepartition I} (h : is_partition π) :\n    ∃ s, split_many I s ≤ π :=\n  (eventually_split_many_inf_eq_filter π).exists.imp fun s hs =>\n    by\n    rwa [h.Union_eq, filter_of_true, inf_eq_right] at hs\n    exact fun J hJ => le_of_mem _ hJ\n#align is_partition.exists_split_many_le is_partition.exists_split_many_le\n\n",
 "exists_split_many_inf_eq_filter_of_finite":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\ntheorem exists_split_many_inf_eq_filter_of_finite (s : set (prepartition I)) (hs : s.finite) :\n    ∃ t : Finset (ι × exprℝ), ∀ π ∈ s, «expr ⊓ » π (split_many I t) = (split_many I t).filter fun J => ↑J ⊆ π.Union :=\n  haveI := fun π (hπ : π ∈ s) => eventually_split_many_inf_eq_filter π\n  (hs.eventually_all.2 this).exists\n#align exists_split_many_inf_eq_filter_of_finite exists_split_many_inf_eq_filter_of_finite\n\n",
 "exists_Union_eq_diff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- For every prepartition `π` of `I` there exists a prepartition that covers exactly\n`I \\ π.Union`. -/\ntheorem exists_Union_eq_diff (π : prepartition I) : ∃ π' : prepartition I, π'.Union = I \\ π.Union :=\n  by\n  rcases π.eventually_split_many_inf_eq_filter.exists with ⟨s, hs⟩\n  use (split_many I s).filter fun J => ¬(J : set (ι → exprℝ)) ⊆ π.Union\n  simp [← hs]\n#align exists_Union_eq_diff exists_Union_eq_diff\n\n",
 "eventually_split_many_inf_eq_filter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\ntheorem eventually_split_many_inf_eq_filter (π : prepartition I) :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" at_top\n      («expr ⊓ » π (split_many I t) = (split_many I t).filter fun J => ↑J ⊆ π.Union) :=\n  by\n  refine' (eventually_not_disjoint_imp_le_of_mem_split_many π.boxes).mono fun t ht => _\n  refine' le_antisymm ((bUnion_le_iff _).2 fun J hJ => _) (le_inf (fun J hJ => _) (filter_le _ _))\n  · refine' of_with_bot_mono _\n    simp only [Finset.mem_image, exists_prop, mem_boxes, mem_filter]\n    rintro _ ⟨J₁, h₁, rfl⟩ hne\n    refine' ⟨_, ⟨J₁, ⟨h₁, subset.trans _ (π.subset_Union hJ)⟩, rfl⟩, le_rfl⟩\n    exact ht I J hJ J₁ h₁ (mt disjoint_iff.1 hne)\n  · rw [mem_filter] at hJ\n    rcases Set.mem_unionᵢ₂.1 (hJ.2 J.upper_mem) with ⟨J', hJ', hmem⟩\n    refine' ⟨J', hJ', ht I _ hJ' _ hJ.1 <| box.not_disjoint_coe_iff_nonempty_inter.2 _⟩\n    exact ⟨J.upper, hmem, J.upper_mem⟩\n#align eventually_split_many_inf_eq_filter eventually_split_many_inf_eq_filter\n\n",
 "eventually_not_disjoint_imp_le_of_mem_split_many":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/-- Let `s` be a finite set of boxes in `ℝⁿ = ι → ℝ`. Then there exists a finite set `t₀` of\nhyperplanes (namely, the set of all hyperfaces of boxes in `s`) such that for any `t ⊇ t₀`\nand any box `I` in `ℝⁿ` the following holds. The hyperplanes from `t` split `I` into subboxes.\nLet `J'` be one of them, and let `J` be one of the boxes in `s`. If these boxes have a nonempty\nintersection, then `J' ≤ J`. -/\ntheorem eventually_not_disjoint_imp_le_of_mem_split_many (s : Finset (box ι)) :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" at_top\n      (∀ (I : box ι), ∀ J ∈ s, ∀ J' ∈ split_many I t, ¬Disjoint (J : WithBot (box ι)) J' → J' ≤ J) :=\n  by\n  cases nonempty_fintype ι\n  refine'\n    eventually_at_top.2\n      ⟨s.bUnion fun J => finset.univ.bUnion fun i => {(i, J i), (i, J.upper i)}, fun t ht I J hJ J' hJ' =>\n        not_disjoint_imp_le_of_subset_of_mem_split_many (fun i => _) hJ'⟩\n  exact fun p hp => ht (Finset.mem_bunionᵢ.2 ⟨J, hJ, Finset.mem_bunionᵢ.2 ⟨i, finset.mem_univ _, hp⟩⟩)\n#align eventually_not_disjoint_imp_le_of_mem_split_many eventually_not_disjoint_imp_le_of_mem_split_many\n\n",
 "disjoint_split_lower_split_upper":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem disjoint_split_lower_split_upper (I : box ι) (i : ι) (x : exprℝ) :\n    Disjoint (I.split_lower i x) (I.split_upper i x) :=\n  by\n  rw [← disjoint_with_bot_coe, coe_split_lower, coe_split_upper]\n  refine' (Disjoint.inf_left' _ _).inf_right' _\n  rw [Set.disjoint_left]\n  exact fun y (hle : y i ≤ x) hlt => not_lt_of_le hle hlt\n#align disjoint_split_lower_split_upper disjoint_split_lower_split_upper\n\n",
 "compl_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n#print compl_top /-\n@[simp]\ntheorem compl_top : («expr⊤» : prepartition I).compl = «expr⊥» :=\n  (is_partition_top I).compl_eq_bot\n#align compl_top compl_top\n-/\n\n",
 "compl_eq_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem is_partition.compl_eq_bot {π : prepartition I} (h : is_partition π) : π.compl = «expr⊥» := by\n  rw [← Union_eq_empty, Union_compl, h.Union_eq, diff_self]\n#align is_partition.compl_eq_bot is_partition.compl_eq_bot\n\n",
 "compl_congr":
 "/-- Since the definition of `box_integral.prepartition.compl` uses `Exists.some`,\nthe result depends only on `π.Union`. -/\ntheorem compl_congr {π₁ π₂ : prepartition I} (h : π₁.Union = π₂.Union) : π₁.compl = π₂.compl :=\n  by\n  dsimp only [compl]\n  congr 1\n  rw [h]\n#align compl_congr compl_congr\n\n",
 "coe_split_upper":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n@[simp]\ntheorem coe_split_upper : (split_upper I i x : set (ι → exprℝ)) = I ∩ { y | x < y i } :=\n  by\n  rw [split_upper, coe_mk']\n  ext y\n  simp only [mem_univ_pi, mem_Ioc, mem_inter_iff, mem_coe, mem_set_of_eq, forall_and,\n    forall_update_iff I.lower fun j z => z < y j, max_lt_iff, and_assoc' (x < y i), and_forall_ne i, mem_def]\n  exact and_comm' _ _\n#align coe_split_upper coe_split_upper\n\n",
 "coe_split_lower":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-\nCopyright (c) 2021 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-/\n@[simp]\ntheorem coe_split_lower : (split_lower I i x : set (ι → exprℝ)) = I ∩ { y | y i ≤ x } :=\n  by\n  rw [split_lower, coe_mk']\n  ext y\n  simp only [mem_univ_pi, mem_Ioc, mem_inter_iff, mem_coe, mem_set_of_eq, forall_and, ← Pi.le_def, le_update_iff,\n    le_min_iff, and_assoc', and_forall_ne i, mem_def]\n  rw [and_comm' (y i ≤ x), Pi.le_def]\n#align coe_split_lower coe_split_lower\n\n",
 "coe_eq_of_mem_split_of_mem_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem coe_eq_of_mem_split_of_mem_le {y : ι → exprℝ} (h₁ : J ∈ split I i x) (h₂ : y ∈ J) (h₃ : y i ≤ x) :\n    (J : set (ι → exprℝ)) = I ∩ { y | y i ≤ x } :=\n  (mem_split_iff'.1 h₁).resolve_right fun H => by\n    rw [← box.mem_coe, H] at h₂\n    exact h₃.not_lt h₂.2\n#align coe_eq_of_mem_split_of_mem_le coe_eq_of_mem_split_of_mem_le\n\n",
 "coe_eq_of_mem_split_of_lt_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem coe_eq_of_mem_split_of_lt_mem {y : ι → exprℝ} (h₁ : J ∈ split I i x) (h₂ : y ∈ J) (h₃ : x < y i) :\n    (J : set (ι → exprℝ)) = I ∩ { y | x < y i } :=\n  (mem_split_iff'.1 h₁).resolve_left fun H => by\n    rw [← box.mem_coe, H] at h₂\n    exact h₃.not_le h₂.2\n#align coe_eq_of_mem_split_of_lt_mem coe_eq_of_mem_split_of_lt_mem\n\n",
 "Union_split_many":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n@[simp]\ntheorem Union_split_many (I : box ι) (s : Finset (ι × exprℝ)) : (split_many I s).Union = I :=\n  (is_partition_split_many I s).Union_eq\n#align Union_split_many Union_split_many\n\n",
 "Union_split":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n@[simp]\ntheorem Union_split (I : box ι) (i : ι) (x : exprℝ) : (split I i x).Union = I := by\n  simp [split, ← inter_union_distrib_left, ← set_of_or, le_or_lt]\n#align Union_split Union_split\n\n",
 "Union_compl":
 "@[simp]\ntheorem Union_compl (π : prepartition I) : π.compl.Union = I \\ π.Union :=\n  π.exists_Union_eq_diff.some_spec\n#align Union_compl Union_compl\n\n"}