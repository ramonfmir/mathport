{"union_compl_to_subordinate":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\nprotected theorem mem_base_set.union_compl_to_subordinate (hπ₁ : l.mem_base_set I c r₁ π₁)\n    (hle : ∀ x ∈ I.Icc, r₂ x ≤ r₁ x) {π₂ : prepartition I} (hU : π₂.Union = I \\ π₁.Union)\n    (hc : l.bDistortion → π₂.distortion ≤ c) : l.mem_base_set I c r₁ (π₁.union_compl_to_subordinate π₂ hU r₂) :=\n  ⟨hπ₁.1.disj_union ((π₂.is_subordinate_to_subordinate r₂).mono hle) _, fun h =>\n    (hπ₁.2 h).disj_union (π₂.is_Henstock_to_subordinate _) _, fun h =>\n    (distortion_union_compl_to_subordinate _ _ _ _).trans_le (max_le (hπ₁.3 h) (hc h)), fun _ => ⟨«expr⊥», by simp⟩⟩\n#align mem_base_set.union_compl_to_subordinate mem_base_set.union_compl_to_subordinate\n\n",
 "to_filter_mono":
 "@[mono]\ntheorem to_filter_mono (I : box ι) {l₁ l₂ : integration_params} (h : l₁ ≤ l₂) : l₁.to_filter I ≤ l₂.to_filter I :=\n  supᵢ_mono fun c => to_filter_distortion_mono I h le_rfl\n#align to_filter_mono to_filter_mono\n\n",
 "to_filter_inf_Union_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\ntheorem to_filter_inf_Union_eq (l : integration_params) (I : box ι) (π₀ : prepartition I) :\n    «expr ⊓ » (l.to_filter I) ((filter.principal) { π | π.Union = π₀.Union }) = l.to_filter_Union I π₀ :=\n  (supr_inf_principal _ _).symm\n#align to_filter_inf_Union_eq to_filter_inf_Union_eq\n\n",
 "to_filter_distortion_mono":
 "@[mono]\ntheorem to_filter_distortion_mono (I : box ι) (h : l₁ ≤ l₂) (hc : c₁ ≤ c₂) :\n    l₁.to_filter_distortion I c₁ ≤ l₂.to_filter_distortion I c₂ :=\n  infᵢ_mono fun r =>\n    infᵢ_mono' fun hr => ⟨hr.mono h, principal_mono.2 fun _ => mem_base_set.mono I h hc fun _ _ => le_rfl⟩\n#align to_filter_distortion_mono to_filter_distortion_mono\n\n",
 "to_filter_distortion_Union_ne_bot":
 "theorem to_filter_distortion_Union_ne_bot (l : integration_params) (I : box ι) (π₀ : prepartition I)\n    (hc₁ : π₀.distortion ≤ c) (hc₂ : π₀.compl.distortion ≤ c) : (l.to_filter_distortion_Union I c π₀).ne_bot :=\n  ((l.has_basis_to_filter_distortion I _).inf_principal _).ne_bot_iff.2 fun r hr =>\n    (l.exists_mem_base_set_le_Union_eq π₀ hc₁ hc₂ r).imp fun π hπ => ⟨hπ.1, hπ.2.2⟩\n#align to_filter_distortion_Union_ne_bot to_filter_distortion_Union_ne_bot\n\n",
 "to_filter_Union_mono":
 "@[mono]\ntheorem to_filter_Union_mono (I : box ι) {l₁ l₂ : integration_params} (h : l₁ ≤ l₂) (π₀ : prepartition I) :\n    l₁.to_filter_Union I π₀ ≤ l₂.to_filter_Union I π₀ :=\n  supᵢ_mono fun c => inf_le_inf_right _ <| to_filter_distortion_mono _ h le_rfl\n#align to_filter_Union_mono to_filter_Union_mono\n\n",
 "to_filter_Union_congr":
 "theorem to_filter_Union_congr (I : box ι) (l : integration_params) {π₁ π₂ : prepartition I} (h : π₁.Union = π₂.Union) :\n    l.to_filter_Union I π₁ = l.to_filter_Union I π₂ := by simp only [to_filter_Union, to_filter_distortion_Union, h]\n#align to_filter_Union_congr to_filter_Union_congr\n\n",
 "tendsto_embed_box_to_filter_Union_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem tendsto_embed_box_to_filter_Union_top (l : integration_params) (h : I ≤ J) :\n    tendsto (tagged_prepartition.embed_box I J h) (l.to_filter_Union I («expr⊤»))\n      (l.to_filter_Union J (prepartition.single J I h)) :=\n  by\n  simp only [to_filter_Union, tendsto_supr]; intro c\n  set π₀ := prepartition.single J I h\n  refine' le_supᵢ_of_le (max c π₀.compl.distortion) _\n  refine'\n    ((l.has_basis_to_filter_distortion_Union I c («expr⊤»)).tendsto_iff\n          (l.has_basis_to_filter_distortion_Union J _ _)).2\n      fun r hr => _\n  refine' ⟨r, hr, fun π hπ => _⟩\n  rw [mem_set_of_eq, prepartition.Union_top] at hπ\n  refine' ⟨⟨hπ.1.1, hπ.1.2, fun hD => le_trans (hπ.1.3 hD) (le_max_left _ _), fun hD => _⟩, _⟩\n  · refine' ⟨_, π₀.Union_compl.trans _, le_max_right _ _⟩\n    congr 1\n    exact (prepartition.Union_single h).trans hπ.2.symm\n  · exact hπ.2.trans (prepartition.Union_single _).symm\n#align tendsto_embed_box_to_filter_Union_top tendsto_embed_box_to_filter_Union_top\n\n",
 "r_cond_of_bRiemann_eq_ff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem r_cond_of_bRiemann_eq_ff {ι} (l : integration_params) (hl : l.bRiemann = ff)\n    {r : (ι → exprℝ) → Ioi (0 : exprℝ)} : l.r_cond r := by simp [r_cond, hl]\n#align r_cond_of_bRiemann_eq_ff r_cond_of_bRiemann_eq_ff\n\n",
 "mono'":
 "theorem mem_base_set.mono' (I : box ι) (h : l₁ ≤ l₂) (hc : c₁ ≤ c₂) {π : tagged_prepartition I}\n    (hr : ∀ J ∈ π, r₁ (π.tag J) ≤ r₂ (π.tag J)) (hπ : l₁.mem_base_set I c₁ r₁ π) : l₂.mem_base_set I c₂ r₂ π :=\n  ⟨hπ.1.mono' hr, fun h₂ => hπ.2 (le_iff_imp.1 h.2.1 h₂), fun hD => (hπ.3 (le_iff_imp.1 h.2.2 hD)).trans hc, fun hD =>\n    (hπ.4 (le_iff_imp.1 h.2.2 hD)).imp fun π hπ => ⟨hπ.1, hπ.2.trans hc⟩⟩\n#align mem_base_set.mono' mem_base_set.mono'\n\n",
 "mono":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n@[mono]\ntheorem r_cond.mono {ι : Type _} {r : (ι → exprℝ) → Ioi (0 : exprℝ)} (h : l₁ ≤ l₂) (hr : l₂.r_cond r) : l₁.r_cond r :=\n  fun hR => hr (le_iff_imp.1 h.1 hR)\n#align r_cond.mono r_cond.mono\n\n",
 "min":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem r_cond.min {ι : Type _} {r₁ r₂ : (ι → exprℝ) → Ioi (0 : exprℝ)} (h₁ : l.r_cond r₁) (h₂ : l.r_cond r₂) :\n    l.r_cond fun x => min (r₁ x) (r₂ x) := fun hR x => congr_arg₂ min (h₁ hR x) (h₂ hR x)\n#align r_cond.min r_cond.min\n\n",
 "has_basis_to_filter_distortion_Union":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\ntheorem has_basis_to_filter_distortion_Union (l : integration_params) (I : box ι) (c : nnreal) (π₀ : prepartition I) :\n    (l.to_filter_distortion_Union I c π₀).has_basis l.r_cond fun r =>\n      { π | l.mem_base_set I c r π ∧ π.Union = π₀.Union } :=\n  (l.has_basis_to_filter_distortion I c).inf_principal _\n#align has_basis_to_filter_distortion_Union has_basis_to_filter_distortion_Union\n\n",
 "has_basis_to_filter_distortion":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\ntheorem has_basis_to_filter_distortion (l : integration_params) (I : box ι) (c : nnreal) :\n    (l.to_filter_distortion I c).has_basis l.r_cond fun r => { π | l.mem_base_set I c r π } :=\n  has_basis_binfi_principal'\n    (fun r₁ hr₁ r₂ hr₂ =>\n      ⟨_, hr₁.min hr₂, fun _ => mem_base_set.mono _ le_rfl le_rfl fun x hx => min_le_left _ _, fun _ =>\n        mem_base_set.mono _ le_rfl le_rfl fun x hx => min_le_right _ _⟩)\n    ⟨fun _ => ⟨1, zero_lt_one⟩, fun _ _ => rfl⟩\n#align has_basis_to_filter_distortion has_basis_to_filter_distortion\n\n",
 "has_basis_to_filter_Union_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem has_basis_to_filter_Union_top (l : integration_params) (I : box ι) :\n    (l.to_filter_Union I («expr⊤»)).has_basis (fun r : nnreal → (ι → exprℝ) → Ioi (0 : exprℝ) => ∀ c, l.r_cond (r c))\n      fun r => { π | ∃ c, l.mem_base_set I c (r c) π ∧ π.is_partition } :=\n  by\n  simpa only [tagged_prepartition.is_partition_iff_Union_eq, prepartition.Union_top] using\n    l.has_basis_to_filter_Union I («expr⊤»)\n#align has_basis_to_filter_Union_top has_basis_to_filter_Union_top\n\n",
 "has_basis_to_filter_Union":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem has_basis_to_filter_Union (l : integration_params) (I : box ι) (π₀ : prepartition I) :\n    (l.to_filter_Union I π₀).has_basis (fun r : nnreal → (ι → exprℝ) → Ioi (0 : exprℝ) => ∀ c, l.r_cond (r c)) fun r =>\n      { π | ∃ c, l.mem_base_set I c (r c) π ∧ π.Union = π₀.Union } :=\n  by\n  have := fun c => l.has_basis_to_filter_distortion_Union I c π₀\n  simpa only [set_of_and, set_of_exists] using has_basis_supr this\n#align has_basis_to_filter_Union has_basis_to_filter_Union\n\n",
 "has_basis_to_filter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem has_basis_to_filter (l : integration_params) (I : box ι) :\n    (l.to_filter I).has_basis (fun r : nnreal → (ι → exprℝ) → Ioi (0 : exprℝ) => ∀ c, l.r_cond (r c)) fun r =>\n      { π | ∃ c, l.mem_base_set I c (r c) π } :=\n  by simpa only [set_of_exists] using has_basis_supr (l.has_basis_to_filter_distortion I)\n#align has_basis_to_filter has_basis_to_filter\n\n",
 "filter":
 "protected theorem mem_base_set.filter (hπ : l.mem_base_set I c r π) (p : box ι → Prop) :\n    l.mem_base_set I c r (π.filter p) :=\n  by\n  refine'\n    ⟨fun J hJ => hπ.1 J (π.mem_filter.1 hJ).1, fun hH J hJ => hπ.2 hH J (π.mem_filter.1 hJ).1, fun hD =>\n      (distortion_filter_le _ _).trans (hπ.3 hD), fun hD => _⟩\n  rcases hπ.4 hD with ⟨π₁, hπ₁U, hc⟩\n  set π₂ := π.filter fun J => ¬p J\n  have : Disjoint π₁.Union π₂.Union := by simpa [π₂, hπ₁U] using disjoint_sdiff_self_left.mono_right sdiff_le\n  refine' ⟨π₁.disj_union π₂.to_prepartition this, _, _⟩\n  · suffices ↑I \\ π.Union ∪ π.Union \\ (π.filter p).Union = ↑I \\ (π.filter p).Union by simpa [*]\n    have : (π.filter p).Union ⊆ π.Union := bUnion_subset_bUnion_left (Finset.filter_subset _ _)\n    ext x\n    fconstructor\n    · rintro (⟨hxI, hxπ⟩ | ⟨hxπ, hxp⟩)\n      exacts[⟨hxI, mt (@this x) hxπ⟩, ⟨π.Union_subset hxπ, hxp⟩]\n    · rintro ⟨hxI, hxp⟩\n      by_cases hxπ : x ∈ π.Union\n      exacts[or.inr ⟨hxπ, hxp⟩, or.inl ⟨hxI, hxπ⟩]\n  · have : (π.filter fun J => ¬p J).distortion ≤ c := (distortion_filter_le _ _).trans (hπ.3 hD)\n    simpa [hc]\n#align mem_base_set.filter mem_base_set.filter\n\n",
 "exists_mem_base_set_le_Union_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem exists_mem_base_set_le_Union_eq (l : integration_params) (π₀ : prepartition I) (hc₁ : π₀.distortion ≤ c)\n    (hc₂ : π₀.compl.distortion ≤ c) (r : (ι → exprℝ) → Ioi (0 : exprℝ)) :\n    ∃ π, l.mem_base_set I c r π ∧ π.to_prepartition ≤ π₀ ∧ π.Union = π₀.Union :=\n  by\n  rcases π₀.exists_tagged_le_is_Henstock_is_subordinate_Union_eq r with ⟨π, hle, hH, hr, hd, hU⟩\n  refine' ⟨π, ⟨hr, fun _ => hH, fun _ => hd.trans_le hc₁, fun hD => ⟨π₀.compl, _, hc₂⟩⟩, ⟨hle, hU⟩⟩\n  exact prepartition.compl_congr hU ▸ π.to_prepartition.Union_compl\n#align exists_mem_base_set_le_Union_eq exists_mem_base_set_le_Union_eq\n\n",
 "exists_mem_base_set_is_partition":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem exists_mem_base_set_is_partition (l : integration_params) (I : box ι) (hc : I.distortion ≤ c)\n    (r : (ι → exprℝ) → Ioi (0 : exprℝ)) : ∃ π, l.mem_base_set I c r π ∧ π.is_partition :=\n  by\n  rw [← prepartition.distortion_top] at hc\n  have hc' : («expr⊤» : prepartition I).compl.distortion ≤ c := by simp\n  simpa [is_partition_iff_Union_eq] using l.exists_mem_base_set_le_Union_eq («expr⊤») hc hc' r\n#align exists_mem_base_set_is_partition exists_mem_base_set_is_partition\n\n",
 "exists_common_compl":
 "theorem mem_base_set.exists_common_compl (h₁ : l.mem_base_set I c₁ r₁ π₁) (h₂ : l.mem_base_set I c₂ r₂ π₂)\n    (hU : π₁.Union = π₂.Union) :\n    ∃ π : prepartition I,\n      π.Union = I \\ π₁.Union ∧ (l.bDistortion → π.distortion ≤ c₁) ∧ (l.bDistortion → π.distortion ≤ c₂) :=\n  by\n  wlog (discharger := tactic.skip) hc : c₁ ≤ c₂ := le_total c₁ c₂ using c₁ c₂ r₁ r₂ π₁ π₂, c₂ c₁ r₂ r₁ π₂ π₁\n  · by_cases hD : (l.bDistortion : Prop)\n    · rcases h₁.4 hD with ⟨π, hπU, hπc⟩\n      exact ⟨π, hπU, fun _ => hπc, fun _ => hπc.trans hc⟩\n    · exact ⟨π₁.to_prepartition.compl, π₁.to_prepartition.Union_compl, fun h => (hD h).elim, fun h => (hD h).elim⟩\n  · intro h₁ h₂ hU\n    simpa [hU, and_comm'] using this h₂ h₁ hU.symm\n#align mem_base_set.exists_common_compl mem_base_set.exists_common_compl\n\n",
 "eventually_is_partition":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem eventually_is_partition (l : integration_params) (I : box ι) :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\"\n      (l.to_filter_Union I («expr⊤»)) (tagged_prepartition.is_partition π) :=\n  eventually_supr.2 fun c =>\n    eventually_inf_principal.2 <|\n      eventually_of_forall fun π h => π.is_partition_iff_Union_eq.2 (h.trans prepartition.Union_top)\n#align eventually_is_partition eventually_is_partition\n\n",
 "bUnion_tagged_mem_base_set":
 "theorem bUnion_tagged_mem_base_set {π : prepartition I} {πi : ∀ J, tagged_prepartition J}\n    (h : ∀ J ∈ π, l.mem_base_set J c r (πi J)) (hp : ∀ J ∈ π, (πi J).is_partition)\n    (hc : l.bDistortion → π.compl.distortion ≤ c) : l.mem_base_set I c r (π.bUnion_tagged πi) :=\n  by\n  refine'\n    ⟨tagged_prepartition.is_subordinate_bUnion_tagged.2 fun J hJ => (h J hJ).1, fun hH =>\n      tagged_prepartition.is_Henstock_bUnion_tagged.2 fun J hJ => (h J hJ).2 hH, fun hD => _, fun hD => _⟩\n  · rw [prepartition.distortion_bUnion_tagged, finset.sup_le_iff]\n    exact fun J hJ => (h J hJ).3 hD\n  · refine' ⟨_, _, hc hD⟩\n    rw [π.Union_compl, ← π.Union_bUnion_partition hp]\n    rfl\n#align bUnion_tagged_mem_base_set bUnion_tagged_mem_base_set\n\n",
 "Henstock_le_Riemann":
 "/-\nCopyright (c) 2021 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-/\ntheorem Henstock_le_Riemann : Henstock ≤ Riemann := by decide\n#align Henstock_le_Riemann Henstock_le_Riemann\n\n",
 "Henstock_le_McShane":
 "theorem Henstock_le_McShane : Henstock ≤ McShane := by decide\n#align Henstock_le_McShane Henstock_le_McShane\n\n",
 "GP_le": "theorem GP_le : GP ≤ l :=\n  bot_le\n#align GP_le GP_le\n\n"}