{"upper_sub_lower_of_mem_split_center":
 "theorem upper_sub_lower_of_mem_split_center (h : J ∈ split_center I) (i : ι) :\n    J.upper i - J.lower i = (I.upper i - I.lower i) / 2 :=\n  let ⟨s, hs⟩ := mem_split_center.1 h\n  hs ▸ I.upper_sub_lower_split_center_box s i\n#align upper_sub_lower_of_mem_split_center upper_sub_lower_of_mem_split_center\n\n",
 "union_compl_to_subordinate_boxes":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n@[simp]\ntheorem union_compl_to_subordinate_boxes (π₁ : tagged_prepartition I) (π₂ : prepartition I)\n    (hU : π₂.Union = I \\ π₁.Union) (r : (ι → exprℝ) → Ioi (0 : exprℝ)) :\n    (π₁.union_compl_to_subordinate π₂ hU r).boxes = π₁.boxes ∪ (π₂.to_subordinate r).boxes :=\n  rfl\n#align union_compl_to_subordinate_boxes union_compl_to_subordinate_boxes\n\n",
 "to_subordinate_to_prepartition_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem to_subordinate_to_prepartition_le (π : prepartition I) (r : (ι → exprℝ) → Ioi (0 : exprℝ)) :\n    (π.to_subordinate r).to_prepartition ≤ π :=\n  (π.exists_tagged_le_is_Henstock_is_subordinate_Union_eq r).some_spec.1\n#align to_subordinate_to_prepartition_le to_subordinate_to_prepartition_le\n\n",
 "subbox_induction_on":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/-- Let `p` be a predicate on `box ι`, let `I` be a box. Suppose that the following two properties\nhold true.\n\n* Consider a smaller box `J ≤ I`. The hyperplanes passing through the center of `J` split it into\n  `2 ^ n` boxes. If `p` holds true on each of these boxes, then it true on `J`.\n* For each `z` in the closed box `I.Icc` there exists a neighborhood `U` of `z` within `I.Icc` such\n  that for every box `J ≤ I` such that `z ∈ J.Icc ⊆ U`, if `J` is homothetic to `I` with a\n  coefficient of the form `1 / 2 ^ m`, then `p` is true on `J`.\n\nThen `p I` is true. See also `box_integral.box.subbox_induction_on'` for a version using\n`box_integral.box.split_center_box` instead of `box_integral.prepartition.split_center`. -/\n@[elab_as_elim]\ntheorem subbox_induction_on {p : box ι → Prop} (I : box ι) (H_ind : ∀ J ≤ I, (∀ J' ∈ split_center J, p J') → p J)\n    (H_nhds :\n      ∀ z ∈ I.Icc,\n        ∃ U ∈ nhds_within I.Icc z,\n          ∀ J ≤ I,\n            ∀ (m : ℕ), z ∈ J.Icc → J.Icc ⊆ U → (∀ i, J.upper i - J.lower i = (I.upper i - I.lower i) / 2 ^ m) → p J) :\n    p I := by\n  refine' subbox_induction_on' I (fun J hle hs => H_ind J hle fun J' h' => _) H_nhds\n  rcases mem_split_center.1 h' with ⟨s, rfl⟩\n  exact hs s\n#align subbox_induction_on subbox_induction_on\n\n",
 "mem_split_center":
 "/-\nCopyright (c) 2021 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-/\n@[simp]\ntheorem mem_split_center : J ∈ split_center I ↔ ∃ s, I.split_center_box s = J := by simp [split_center]\n#align mem_split_center mem_split_center\n\n",
 "is_subordinate_to_subordinate":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem is_subordinate_to_subordinate (π : prepartition I) (r : (ι → exprℝ) → Ioi (0 : exprℝ)) :\n    (π.to_subordinate r).is_subordinate r :=\n  (π.exists_tagged_le_is_Henstock_is_subordinate_Union_eq r).some_spec.2.2.1\n#align is_subordinate_to_subordinate is_subordinate_to_subordinate\n\n",
 "is_partition_union_compl_to_subordinate":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem is_partition_union_compl_to_subordinate (π₁ : tagged_prepartition I) (π₂ : prepartition I)\n    (hU : π₂.Union = I \\ π₁.Union) (r : (ι → exprℝ) → Ioi (0 : exprℝ)) :\n    is_partition (π₁.union_compl_to_subordinate π₂ hU r) :=\n  prepartition.is_partition_disj_union_of_eq_diff ((π₂.Union_to_subordinate r).trans hU)\n#align is_partition_union_compl_to_subordinate is_partition_union_compl_to_subordinate\n\n",
 "is_partition_split_center":
 "theorem is_partition_split_center (I : box ι) : is_partition (split_center I) := fun x hx => by simp [hx]\n#align is_partition_split_center is_partition_split_center\n\n",
 "is_Henstock_to_subordinate":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem is_Henstock_to_subordinate (π : prepartition I) (r : (ι → exprℝ) → Ioi (0 : exprℝ)) :\n    (π.to_subordinate r).is_Henstock :=\n  (π.exists_tagged_le_is_Henstock_is_subordinate_Union_eq r).some_spec.2.1\n#align is_Henstock_to_subordinate is_Henstock_to_subordinate\n\n",
 "exists_tagged_partition_is_Henstock_is_subordinate_homothetic":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- Given a box `I` in `ℝⁿ` and a function `r : ℝⁿ → (0, ∞)`, there exists a tagged partition `π` of\n`I` such that\n\n* `π` is a Henstock partition;\n* `π` is subordinate to `r`;\n* each box in `π` is homothetic to `I` with coefficient of the form `1 / 2 ^ m`.\n\nThis lemma implies that the Henstock filter is nontrivial, hence the Henstock integral is\nwell-defined. -/\ntheorem exists_tagged_partition_is_Henstock_is_subordinate_homothetic (I : box ι) (r : (ι → exprℝ) → Ioi (0 : exprℝ)) :\n    ∃ π : tagged_prepartition I,\n      π.is_partition ∧\n        π.is_Henstock ∧\n          π.is_subordinate r ∧\n            (∀ J ∈ π, ∃ m : ℕ, ∀ i, (J : _).upper i - J.lower i = (I.upper i - I.lower i) / 2 ^ m) ∧\n              π.distortion = I.distortion :=\n  by\n  refine' subbox_induction_on I (fun J hle hJ => _) fun z hz => _\n  · choose! πi hP hHen hr Hn Hd using hJ\n    choose! n hn using Hn\n    have hP : ((split_center J).bUnion_tagged πi).is_partition := (is_partition_split_center _).bUnion_tagged hP\n    have hsub :\n      ∀ J' ∈ (split_center J).bUnion_tagged πi,\n        ∃ n : ℕ, ∀ i, (J' : _).upper i - J'.lower i = (J.upper i - J.lower i) / 2 ^ n :=\n      by\n      intro J' hJ'\n      rcases(split_center J).mem_bUnion_tagged.1 hJ' with ⟨J₁, h₁, h₂⟩\n      refine' ⟨n J₁ J' + 1, fun i => _⟩\n      simp only [hn J₁ h₁ J' h₂, upper_sub_lower_of_mem_split_center h₁, pow_succ, div_div]\n    refine' ⟨_, hP, is_Henstock_bUnion_tagged.2 hHen, is_subordinate_bUnion_tagged.2 hr, hsub, _⟩\n    refine' tagged_prepartition.distortion_of_const _ hP.nonempty_boxes fun J' h' => _\n    rcases hsub J' h' with ⟨n, hn⟩\n    exact box.distortion_eq_of_sub_eq_div hn\n  · refine' ⟨I.Icc ∩ closed_ball z (r z), inter_mem_nhds_within _ (closed_ball_mem_nhds _ (r z).coe_prop), _⟩\n    intro J Hle n Hmem HIcc Hsub\n    rw [Set.subset_inter_iff] at HIcc\n    refine'\n      ⟨single _ _ le_rfl _ Hmem, is_partition_single _, is_Henstock_single _, (is_subordinate_single _ _).2 HIcc.2, _,\n        distortion_single _ _⟩\n    simp only [tagged_prepartition.mem_single, forall_eq]\n    refine' ⟨0, fun i => _⟩\n    simp\n#align\n  exists_tagged_partition_is_Henstock_is_subordinate_homothetic exists_tagged_partition_is_Henstock_is_subordinate_homothetic\n\n",
 "exists_tagged_le_is_Henstock_is_subordinate_Union_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- Given a box `I` in `ℝⁿ`, a function `r : ℝⁿ → (0, ∞)`, and a prepartition `π` of `I`, there\nexists a tagged prepartition `π'` of `I` such that\n\n* each box of `π'` is included in some box of `π`;\n* `π'` is a Henstock partition;\n* `π'` is subordinate to `r`;\n* `π'` covers exactly the same part of `I` as `π`;\n* the distortion of `π'` is equal to the distortion of `π`.\n-/\ntheorem exists_tagged_le_is_Henstock_is_subordinate_Union_eq {I : box ι} (r : (ι → exprℝ) → Ioi (0 : exprℝ))\n    (π : prepartition I) :\n    ∃ π' : tagged_prepartition I,\n      π'.to_prepartition ≤ π ∧\n        π'.is_Henstock ∧ π'.is_subordinate r ∧ π'.distortion = π.distortion ∧ π'.Union = π.Union :=\n  by\n  have := fun J => box.exists_tagged_partition_is_Henstock_is_subordinate_homothetic J r\n  choose! πi πip πiH πir hsub πid; clear hsub\n  refine'\n    ⟨π.bUnion_tagged πi, bUnion_le _ _, is_Henstock_bUnion_tagged.2 fun J _ => πiH J,\n      is_subordinate_bUnion_tagged.2 fun J _ => πir J, _, π.Union_bUnion_partition fun J _ => πip J⟩\n  rw [distortion_bUnion_tagged]\n  exact sup_congr rfl fun J _ => πid J\n#align exists_tagged_le_is_Henstock_is_subordinate_Union_eq exists_tagged_le_is_Henstock_is_subordinate_Union_eq\n\n",
 "distortion_union_compl_to_subordinate":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n@[simp]\ntheorem distortion_union_compl_to_subordinate (π₁ : tagged_prepartition I) (π₂ : prepartition I)\n    (hU : π₂.Union = I \\ π₁.Union) (r : (ι → exprℝ) → Ioi (0 : exprℝ)) :\n    (π₁.union_compl_to_subordinate π₂ hU r).distortion = max π₁.distortion π₂.distortion := by\n  simp [union_compl_to_subordinate]\n#align distortion_union_compl_to_subordinate distortion_union_compl_to_subordinate\n\n",
 "distortion_to_subordinate":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n@[simp]\ntheorem distortion_to_subordinate (π : prepartition I) (r : (ι → exprℝ) → Ioi (0 : exprℝ)) :\n    (π.to_subordinate r).distortion = π.distortion :=\n  (π.exists_tagged_le_is_Henstock_is_subordinate_Union_eq r).some_spec.2.2.2.1\n#align distortion_to_subordinate distortion_to_subordinate\n\n",
 "Union_union_compl_to_subordinate_boxes":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n@[simp]\ntheorem Union_union_compl_to_subordinate_boxes (π₁ : tagged_prepartition I) (π₂ : prepartition I)\n    (hU : π₂.Union = I \\ π₁.Union) (r : (ι → exprℝ) → Ioi (0 : exprℝ)) :\n    (π₁.union_compl_to_subordinate π₂ hU r).Union = I :=\n  (is_partition_union_compl_to_subordinate _ _ _ _).Union_eq\n#align Union_union_compl_to_subordinate_boxes Union_union_compl_to_subordinate_boxes\n\n",
 "Union_to_subordinate":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n@[simp]\ntheorem Union_to_subordinate (π : prepartition I) (r : (ι → exprℝ) → Ioi (0 : exprℝ)) :\n    (π.to_subordinate r).Union = π.Union :=\n  (π.exists_tagged_le_is_Henstock_is_subordinate_Union_eq r).some_spec.2.2.2.2\n#align Union_to_subordinate Union_to_subordinate\n\n"}