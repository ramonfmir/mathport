{"has_integral_zero_of_ae_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⌈ ⌉₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Basic.lean:632:2: warning: expanding binder collection (U «expr ⊇ » «expr ⁻¹' »(N, {n})) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊇ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\n/-- If `f` is a.e. equal to zero on a rectangular box, then it has McShane integral zero on this\nbox. -/\ntheorem has_integral_zero_of_ae_eq_zero {l : integration_params} {I : box ι} {f : (ι → exprℝ) → E}\n    {μ : measure (ι → exprℝ)} [is_locally_finite_measure μ] (hf : «expr =ᵐ[ ] » f (μ.restrict I) 0)\n    (hl : l.bRiemann = ff) : has_integral.{u, v, v} I l f μ.to_box_additive.to_smul 0 :=\n  by\n  /- Each set `{x | n < ‖f x‖ ≤ n + 1}`, `n : ℕ`, has measure zero. We cover it by an open set of\n    measure less than `ε / 2 ^ n / (n + 1)`. Then the norm of the integral sum is less than `ε`. -/\n  refine' has_integral_iff.2 fun ε ε0 => _\n  lift ε to nnreal using ε0.lt.le\n  rw [gt_iff_lt, nnreal.coe_pos] at ε0\n  rcases nnreal.exists_pos_sum_of_countable ε0.ne' ℕ with ⟨δ, δ0, c, hδc, hcε⟩\n  haveI := fact.mk (I.measure_coe_lt_top μ)\n  change μ.restrict I { x | f x ≠ 0 } = 0 at hf\n  set N : (ι → exprℝ) → ℕ := fun x => «expr⌈ ⌉₊» («expr‖ ‖» (f x))\n  have N0 : ∀ {x}, N x = 0 ↔ f x = 0 := by\n    intro x\n    simp [N]\n  have : ∀ n, ∃ (U : _)(_ : «expr ⊇ » U («expr ⁻¹' » N {n})), is_open U ∧ μ.restrict I U < δ n / n :=\n    by\n    refine' fun n => («expr ⁻¹' » N {n}).exists_is_open_lt_of_lt _ _\n    cases n\n    · simpa [ennreal.div_zero (ennreal.coe_pos.2 (δ0 _)).ne'] using measure_lt_top (μ.restrict I) _\n    · refine' (measure_mono_null _ hf).le.trans_lt _\n      · exact fun x hxN hxf => n.succ_ne_zero ((eq.symm hxN).trans <| N0.2 hxf)\n      · simp [(δ0 _).ne']\n  choose U hNU hUo hμU\n  have : ∀ x, ∃ r : Ioi (0 : exprℝ), closed_ball x r ⊆ U (N x) := fun x =>\n    subtype.exists'.1 (nhds_basis_closed_ball.mem_iff.1 ((hUo _).mem_nhds (hNU _ rfl)))\n  choose r hrU\n  refine' ⟨fun _ => r, fun c => l.r_cond_of_bRiemann_eq_ff hl, fun c π hπ hπp => _⟩\n  rw [dist_eq_norm, sub_zero, ← integral_sum_fiberwise fun J => N (π.tag J)]\n  refine' le_trans _ (nnreal.coe_lt_coe.2 hcε).le\n  refine' (norm_sum_le_of_le _ _).trans (sum_le_has_sum _ (fun n _ => (δ n).2) (nnreal.has_sum_coe.2 hδc))\n  rintro n -\n  dsimp [integral_sum]\n  have :\n    ∀ J ∈ π.filter fun J => N (π.tag J) = n, «expr‖ ‖» («expr • » (μ ↑J).to_real (f (π.tag J))) ≤ (μ J).to_real * n :=\n    by\n    intro J hJ\n    rw [tagged_prepartition.mem_filter] at hJ\n    rw [norm_smul, real.norm_eq_abs, abs_of_nonneg ennreal.to_real_nonneg]\n    exact mul_le_mul_of_nonneg_left (hJ.2 ▸ Nat.le_ceil _) ennreal.to_real_nonneg\n  refine' (norm_sum_le_of_le _ this).trans _\n  clear this\n  rw [← sum_mul, ← prepartition.measure_Union_to_real]\n  generalize hm : μ (π.filter fun J => N (π.tag J) = n).Union = m\n  have : m < δ n / n := by\n    simp only [measure.restrict_apply (hUo _).measurable_set] at hμU\n    refine' hm ▸ (measure_mono _).trans_lt (hμU _)\n    simp only [Set.subset_def, tagged_prepartition.mem_Union, exists_prop, tagged_prepartition.mem_filter]\n    rintro x ⟨J, ⟨hJ, rfl⟩, hx⟩\n    exact ⟨hrU _ (hπ.1 _ hJ (box.coe_subset_Icc hx)), π.le_of_mem' J hJ hx⟩\n  lift m to nnreal using ne_top_of_lt this\n  rw [ennreal.coe_to_real, ← nnreal.coe_nat_cast, ← nnreal.coe_mul, nnreal.coe_le_coe, ← ennreal.coe_le_coe,\n    ennreal.coe_mul, ennreal.coe_nat, mul_comm]\n  exact (mul_le_mul_left' this.le _).trans ennreal.mul_div_le\n#align has_integral_zero_of_ae_eq_zero has_integral_zero_of_ae_eq_zero\n\n",
 "has_integral_indicator_const":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Basic.lean:632:2: warning: expanding binder collection (F «expr ⊆ » «expr ∩ »(s, I.Icc)) -/\n/- ./././Mathport/Syntax/Translate/Basic.lean:632:2: warning: expanding binder collection (U «expr ⊇ » «expr ∩ »(s, I.Icc)) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊇ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-\nCopyright (c) 2021 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-/\n/-- The indicator function of a measurable set is McShane integrable with respect to any\nlocally-finite measure. -/\ntheorem has_integral_indicator_const (l : integration_params) (hl : l.bRiemann = ff) {s : set (ι → exprℝ)}\n    (hs : measurable_set s) (I : box ι) (y : E) (μ : measure (ι → exprℝ)) [is_locally_finite_measure μ] :\n    has_integral.{u, v, v} I l (s.indicator fun _ => y) μ.to_box_additive.to_smul («expr • » (μ (s ∩ I)).to_real y) :=\n  by\n  refine' has_integral_of_mul («expr‖ ‖» y) fun ε ε0 => _\n  lift ε to nnreal using ε0.le\n  rw [nnreal.coe_pos] at ε0\n  /- First we choose a closed set `F ⊆ s ∩ I.Icc` and an open set `U ⊇ s` such that\n    both `(s ∩ I.Icc) \\ F` and `U \\ s` have measuer less than `ε`. -/\n  have A : μ (s ∩ I.Icc) ≠ ennreal.top :=\n    ((measure_mono <| Set.inter_subset_right _ _).trans_lt (I.measure_Icc_lt_top μ)).ne\n  have B : μ (s ∩ I) ≠ ennreal.top :=\n    ((measure_mono <| Set.inter_subset_right _ _).trans_lt (I.measure_coe_lt_top μ)).ne\n  obtain ⟨F, hFs, hFc, hμF⟩ : ∃ (F : _)(_ : F ⊆ s ∩ I.Icc), is_closed F ∧ μ ((s ∩ I.Icc) \\ F) < ε\n  exact (hs.inter I.measurable_set_Icc).exists_is_closed_diff_lt A (ennreal.coe_pos.2 ε0).ne'\n  obtain ⟨U, hsU, hUo, hUt, hμU⟩ :\n    ∃ (U : _)(_ : «expr ⊇ » U (s ∩ I.Icc)), is_open U ∧ μ U < ennreal.top ∧ μ (U \\ (s ∩ I.Icc)) < ε\n  exact (hs.inter I.measurable_set_Icc).exists_is_open_diff_lt A (ennreal.coe_pos.2 ε0).ne'\n  /- Then we choose `r` so that `closed_ball x (r x) ⊆ U` whenever `x ∈ s ∩ I.Icc` and\n    `closed_ball x (r x)` is disjoint with `F` otherwise. -/\n  have : ∀ x ∈ s ∩ I.Icc, ∃ r : Ioi (0 : exprℝ), closed_ball x r ⊆ U := fun x hx =>\n    subtype.exists'.1 (nhds_basis_closed_ball.mem_iff.1 (hUo.mem_nhds <| hsU hx))\n  choose! rs hrsU\n  have : ∀ x ∈ I.Icc \\ s, ∃ r : Ioi (0 : exprℝ), closed_ball x r ⊆ «expr ᶜ» F := fun x hx =>\n    subtype.exists'.1 (nhds_basis_closed_ball.mem_iff.1 (hFc.is_open_compl.mem_nhds fun hx' => hx.2 (hFs hx').1))\n  choose! rs' hrs'F\n  set r : (ι → exprℝ) → Ioi (0 : exprℝ) := s.piecewise rs rs'\n  refine' ⟨fun c => r, fun c => l.r_cond_of_bRiemann_eq_ff hl, fun c π hπ hπp => _⟩\n  rw [mul_comm]\n  /- Then the union of boxes `J ∈ π` such that `π.tag ∈ s` includes `F` and is included by `U`,\n    hence its measure is `ε`-close to the measure of `s`. -/\n  dsimp [integral_sum]\n  simp only [mem_closed_ball, dist_eq_norm, ← indicator_const_smul_apply, sum_indicator_eq_sum_filter, ← sum_smul, ←\n    sub_smul, norm_smul, real.norm_eq_abs, ← prepartition.filter_boxes, ← prepartition.measure_Union_to_real]\n  refine' mul_le_mul_of_nonneg_right _ (norm_nonneg y)\n  set t := (π.to_prepartition.filter fun J => π.tag J ∈ s).Union\n  change abs ((μ t).to_real - (μ (s ∩ I)).to_real) ≤ ε\n  have htU : t ⊆ U ∩ I :=\n    by\n    simp only [t, prepartition.Union_def, Union_subset_iff, prepartition.mem_filter, and_imp]\n    refine' fun J hJ hJs x hx => ⟨hrsU _ ⟨hJs, π.tag_mem_Icc J⟩ _, π.le_of_mem' J hJ hx⟩\n    simpa only [r, s.piecewise_eq_of_mem _ _ hJs] using hπ.1 J hJ (box.coe_subset_Icc hx)\n  refine' abs_sub_le_iff.2 ⟨_, _⟩\n  · refine' (ennreal.le_to_real_sub B).trans (ennreal.to_real_le_coe_of_le_coe _)\n    refine' (tsub_le_tsub (measure_mono htU) le_rfl).trans (le_measure_diff.trans _)\n    refine' (measure_mono fun x hx => _).trans hμU.le\n    exact ⟨hx.1.1, fun hx' => hx.2 ⟨hx'.1, hx.1.2⟩⟩\n  · have hμt : μ t ≠ ennreal.top := ((measure_mono (htU.trans (inter_subset_left _ _))).trans_lt hUt).ne\n    refine' (ennreal.le_to_real_sub hμt).trans (ennreal.to_real_le_coe_of_le_coe _)\n    refine' le_measure_diff.trans ((measure_mono _).trans hμF.le)\n    rintro x ⟨⟨hxs, hxI⟩, hxt⟩\n    refine' ⟨⟨hxs, box.coe_subset_Icc hxI⟩, fun hxF => hxt _⟩\n    simp only [t, prepartition.Union_def, prepartition.mem_filter, Set.mem_unionᵢ, exists_prop]\n    rcases hπp x hxI with ⟨J, hJπ, hxJ⟩\n    refine' ⟨J, ⟨hJπ, _⟩, hxJ⟩\n    contrapose hxF\n    refine' hrs'F _ ⟨π.tag_mem_Icc J, hxF⟩ _\n    simpa only [r, s.piecewise_eq_of_not_mem _ _ hxF] using hπ.1 J hJπ (box.coe_subset_Icc hxJ)\n#align has_integral_indicator_const has_integral_indicator_const\n\n",
 "has_box_integral":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ in , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ in , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ in , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ in , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫⁻ in , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ in , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ in , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ in , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ in , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ in , ∂ » -/\n/-- If `f : ℝⁿ → E` is Bochner integrable w.r.t. a locally finite measure `μ` on a rectangular box\n`I`, then it is McShane integrable on `I` with the same integral.  -/\ntheorem integrable_on.has_box_integral [complete_space E] {f : (ι → exprℝ) → E} {μ : measure (ι → exprℝ)}\n    [is_locally_finite_measure μ] {I : box ι} (hf : integrable_on f I μ) (l : integration_params)\n    (hl : l.bRiemann = ff) :\n    has_integral.{u, v, v} I l f μ.to_box_additive.to_smul\n      («expr∫ in , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ in , ∂ »\" I (f x)\n        μ) :=\n  by\n  borelize E\n  -- First we replace an `ae_strongly_measurable` function by a measurable one.\n  rcases hf.ae_strongly_measurable with ⟨g, hg, hfg⟩\n  haveI : separable_space (range g ∪ {0} : set E) := hg.separable_space_range_union_singleton\n  rw [integral_congr_ae hfg]\n  have hgi : integrable_on g I μ := (integrable_congr hfg).1 hf\n  refine' box_integral.has_integral.congr_ae _ hfg.symm hl\n  clear! f\n  /- Now consider the sequence of simple functions\n    `simple_func.approx_on g hg.measurable (range g ∪ {0}) 0 (by simp)`\n    approximating `g`. Recall some properties of this sequence. -/\n  set f : ℕ → simple_func (ι → exprℝ) E := simple_func.approx_on g hg.measurable (range g ∪ {0}) 0 (by simp)\n  have hfi : ∀ n, integrable_on (f n) I μ := simple_func.integrable_approx_on_range hg.measurable hgi\n  have hfi' := fun n => ((f n).has_box_integral μ I l hl).integrable\n  have hfgi :\n    tendsto (fun n => (f n).integral (μ.restrict I)) at_top\n      (nhds <|\n        «expr∫ in , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ in , ∂ »\" I\n          (g x) μ) :=\n    tendsto_integral_approx_on_of_measurable_of_range_subset hg.measurable hgi _ subset.rfl\n  have hfg_mono : ∀ (x) {m n}, m ≤ n → «expr‖ ‖» (f n x - g x) ≤ «expr‖ ‖» (f m x - g x) :=\n    by\n    intro x m n hmn\n    rw [← dist_eq_norm, ← dist_eq_norm, dist_nndist, dist_nndist, nnreal.coe_le_coe, ← ennreal.coe_le_coe, ←\n      edist_nndist, ← edist_nndist]\n    exact simple_func.edist_approx_on_mono hg.measurable _ x hmn\n  /- Now consider `ε > 0`. We need to find `r` such that for any tagged partition subordinate\n    to `r`, the integral sum is `(μ I + 1 + 1) * ε`-close to the Bochner integral. -/\n  refine' has_integral_of_mul ((μ I).to_real + 1 + 1) fun ε ε0 => _\n  lift ε to nnreal using ε0.le\n  rw [nnreal.coe_pos] at ε0\n  have ε0' := ennreal.coe_pos.2 ε0\n  -- Choose `N` such that the integral of `‖f N x - g x‖` is less than or equal to `ε`.\n  obtain ⟨N₀, hN₀⟩ :\n    ∃ N : ℕ,\n      «expr∫ in , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ in , ∂ »\" I\n          («expr‖ ‖» (f N x - g x)) μ ≤\n        ε :=\n    by\n    have :\n      tendsto\n        (fun n =>\n          «expr∫⁻ in , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ in , ∂ »\" I\n            («expr‖ ‖₊» (f n x - g x)) μ)\n        at_top ((nhds) 0) :=\n      simple_func.tendsto_approx_on_range_L1_nnnorm hg.measurable hgi\n    refine' (this.eventually (ge_mem_nhds ε0')).exists.imp fun N hN => _\n    exact integral_coe_le_of_lintegral_coe_le hN\n  -- For each `x`, we choose `Nx x ≥ N₀` such that `dist (f Nx x) (g x) ≤ ε`.\n  have : ∀ x, ∃ N₁, N₀ ≤ N₁ ∧ dist (f N₁ x) (g x) ≤ ε := by\n    intro x\n    have : tendsto (fun n => f n x) at_top (nhds <| g x) :=\n      simple_func.tendsto_approx_on hg.measurable _ (subset_closure (by simp))\n    exact ((eventually_ge_at_top N₀).and <| this <| closed_ball_mem_nhds _ ε0).exists\n  choose Nx hNx hNxε\n  -- We also choose a convergent series with `∑' i : ℕ, δ i < ε`.\n  rcases nnreal.exists_pos_sum_of_countable ε0.ne' ℕ with ⟨δ, δ0, c, hδc, hcε⟩\n  /- Since each simple function `fᵢ` is integrable, there exists `rᵢ : ℝⁿ → (0, ∞)` such that\n    the integral sum of `f` over any tagged prepartition is `δᵢ`-close to the sum of integrals\n    of `fᵢ` over the boxes of this prepartition. For each `x`, we choose `r (Nx x)` as the radius\n    at `x`. -/\n  set r : nnreal → (ι → exprℝ) → Ioi (0 : exprℝ) := fun c x => (hfi' <| Nx x).convergence_r (δ <| Nx x) c x\n  refine' ⟨r, fun c => l.r_cond_of_bRiemann_eq_ff hl, fun c π hπ hπp => _⟩\n  /- Now we prove the estimate in 3 \"jumps\": first we replace `g x` in the formula for the\n    integral sum by `f (Nx x)`; then we replace each `μ J • f (Nx (π.tag J)) (π.tag J)`\n    by the Bochner integral of `f (Nx (π.tag J)) x` over `J`, then we jump to the Bochner\n    integral of `g`. -/\n  refine'\n    (dist_triangle4 _\n          (finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" π.boxes\n            («expr • » (μ J).to_real (f (Nx <| π.tag J) (π.tag J))))\n          (finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" π.boxes\n            («expr∫ in , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ in , ∂ »\" J\n              (f (Nx <| π.tag J) x) μ))\n          _).trans\n      _\n  rw [add_mul, add_mul, one_mul]\n  refine' add_le_add_three _ _ _\n  · /- Since each `f (Nx $ π.tag J)` is `ε`-close to `g (π.tag J)`, replacing the latter with\n        the former in the formula for the integral sum changes the sum at most by `μ I * ε`. -/\n    rw [← hπp.Union_eq, π.to_prepartition.measure_Union_to_real, sum_mul, integral_sum]\n    refine' dist_sum_sum_le_of_le _ fun J hJ => _\n    dsimp\n    rw [dist_eq_norm, ← smul_sub, norm_smul, real.norm_eq_abs, abs_of_nonneg ennreal.to_real_nonneg]\n    refine' mul_le_mul_of_nonneg_left _ ennreal.to_real_nonneg\n    rw [← dist_eq_norm']\n    exact hNxε _\n  · /- We group the terms of both sums by the values of `Nx (π.tag J)`.\n        For each `N`, the sum of Bochner integrals over the boxes is equal\n        to the sum of box integrals, and the sum of box integrals is `δᵢ`-close\n        to the corresponding integral sum due to the Henstock-Sacks inequality. -/\n    rw [← π.to_prepartition.sum_fiberwise fun J => Nx (π.tag J), ←\n      π.to_prepartition.sum_fiberwise fun J => Nx (π.tag J)]\n    refine' le_trans _ (nnreal.coe_lt_coe.2 hcε).le\n    refine'\n      (dist_sum_sum_le_of_le _ fun n hn => _).trans (sum_le_has_sum _ (fun n _ => (δ n).2) (nnreal.has_sum_coe.2 hδc))\n    have hNxn : ∀ J ∈ π.filter fun J => Nx (π.tag J) = n, Nx (π.tag J) = n := fun J hJ => (π.mem_filter.1 hJ).2\n    have hrn : ∀ J ∈ π.filter fun J => Nx (π.tag J) = n, r c (π.tag J) = (hfi' n).convergence_r (δ n) c (π.tag J) :=\n      by\n      intro J hJ\n      obtain rfl := hNxn J hJ\n      rfl\n    have : l.mem_base_set I c ((hfi' n).convergence_r (δ n) c) (π.filter fun J => Nx (π.tag J) = n) :=\n      (hπ.filter _).mono' _ le_rfl le_rfl fun J hJ => (hrn J hJ).le\n    convert (hfi' n).dist_integral_sum_sum_integral_le_of_mem_base_set (δ0 _) this using 2\n    · refine' sum_congr rfl fun J hJ => _\n      simp [hNxn J hJ]\n    · refine' sum_congr rfl fun J hJ => _\n      rw [← simple_func.integral_eq_integral, simple_func.box_integral_eq_integral _ _ _ _ hl, hNxn J hJ]\n      exact (hfi _).mono_set (prepartition.le_of_mem _ hJ)\n  · /-  For the last jump, we use the fact that the distance between `f (Nx x) x` and `g x` is less\n        than or equal to the distance between `f N₀ x` and `g x` and the integral of `‖f N₀ x - g x‖`\n        is less than or equal to `ε`. -/\n    refine' le_trans _ hN₀\n    have hfi : ∀ (n), ∀ J ∈ π, integrable_on (f n) (↑J) μ := fun n J hJ => (hfi n).mono_set (π.le_of_mem' J hJ)\n    have hgi : ∀ J ∈ π, integrable_on g (↑J) μ := fun J hJ => hgi.mono_set (π.le_of_mem' J hJ)\n    have hfgi : ∀ (n), ∀ J ∈ π, integrable_on (fun x => «expr‖ ‖» (f n x - g x)) J μ := fun n J hJ =>\n      ((hfi n J hJ).sub (hgi J hJ)).norm\n    rw [← hπp.Union_eq, prepartition.Union_def',\n      integral_finset_bUnion π.boxes (fun J hJ => J.measurable_set_coe) π.pairwise_disjoint hgi,\n      integral_finset_bUnion π.boxes (fun J hJ => J.measurable_set_coe) π.pairwise_disjoint (hfgi _)]\n    refine' dist_sum_sum_le_of_le _ fun J hJ => _\n    rw [dist_eq_norm, ← integral_sub (hfi _ J hJ) (hgi J hJ)]\n    refine' norm_integral_le_of_norm_le (hfgi _ J hJ) (eventually_of_forall fun x => _)\n    exact hfg_mono x (hNx (π.tag J))\n#align integrable_on.has_box_integral integrable_on.has_box_integral\n\n",
 "congr_ae":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\n/-- If `f` has integral `y` on a box `I` with respect to a locally finite measure `μ` and `g` is\na.e. equal to `f` on `I`, then `g` has the same integral on `I`.  -/\ntheorem has_integral.congr_ae {l : integration_params} {I : box ι} {y : E} {f g : (ι → exprℝ) → E}\n    {μ : measure (ι → exprℝ)} [is_locally_finite_measure μ]\n    (hf : has_integral.{u, v, v} I l f μ.to_box_additive.to_smul y) (hfg : «expr =ᵐ[ ] » f (μ.restrict I) g)\n    (hl : l.bRiemann = ff) : has_integral.{u, v, v} I l g μ.to_box_additive.to_smul y :=\n  by\n  have : «expr =ᵐ[ ] » (g - f) (μ.restrict I) 0 := hfg.mono fun x hx => sub_eq_zero.2 hx.symm\n  simpa using hf.add (has_integral_zero_of_ae_eq_zero this hl)\n#align has_integral.congr_ae has_integral.congr_ae\n\n",
 "box_integral_eq_integral":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- For a simple function, its McShane (or Henstock, or `⊥`) box integral is equal to its\nintegral in the sense of `measure_theory.simple_func.integral`. -/\ntheorem box_integral_eq_integral (f : simple_func (ι → exprℝ) E) (μ : measure (ι → exprℝ)) [is_locally_finite_measure μ]\n    (I : box ι) (l : integration_params) (hl : l.bRiemann = ff) :\n    box_integral.integral.{u, v, v} I l f μ.to_box_additive.to_smul = f.integral (μ.restrict I) :=\n  (f.has_box_integral μ I l hl).integral_eq\n#align box_integral_eq_integral box_integral_eq_integral\n\n"}