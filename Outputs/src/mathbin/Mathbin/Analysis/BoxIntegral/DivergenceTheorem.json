{"norm_volume_sub_integral_face_upper_sub_lower_smul_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℝⁿ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℝⁿ⁺¹» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℝⁿ⁺¹» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℝⁿ⁺¹» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\n/-\nCopyright (c) 2021 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-/\n/-- Auxiliary lemma for the divergence theorem. -/\ntheorem norm_volume_sub_integral_face_upper_sub_lower_smul_le {f : «exprℝⁿ⁺¹» → E}\n    {f' : «expr →L[ ] » («exprℝⁿ⁺¹») (exprℝ) E} (hfc : continuous_on f I.Icc) {x : «exprℝⁿ⁺¹»} (hxI : x ∈ I.Icc) {a : E}\n    {ε : exprℝ} (h0 : 0 < ε) (hε : ∀ y ∈ I.Icc, «expr‖ ‖» (f y - a - f' (y - x)) ≤ ε * «expr‖ ‖» (y - x)) {c : nnreal}\n    (hc : I.distortion ≤ c) :\n    «expr‖ ‖»\n        («expr • »\n            (finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n              (I.upper j - I.lower j))\n            (f' (Pi.single i 1)) -\n          (integral (I.face i) («expr⊥») (f ∘ i.insert_nth (I.upper i)) box_additive_map.volume -\n            integral (I.face i) («expr⊥») (f ∘ i.insert_nth (I.lower i)) box_additive_map.volume)) ≤\n      2 * ε * c *\n        finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n          (I.upper j - I.lower j) :=\n  by\n  /- **Plan of the proof**. The difference of the integrals of the affine function\n    `λ y, a + f' (y - x)` over the faces `x i = I.upper i` and `x i = I.lower i` is equal to the\n    volume of `I` multiplied by `f' (pi.single i 1)`, so it suffices to show that the integral of\n    `f y - a - f' (y - x)` over each of these faces is less than or equal to `ε * c * vol I`. We\n    integrate a function of the norm `≤ ε * diam I.Icc` over a box of volume\n    `∏ j ≠ i, (I.upper j - I.lower j)`. Since `diam I.Icc ≤ c * (I.upper i - I.lower i)`, we get the\n    required estimate.  -/\n  have Hl : I.lower i ∈ Icc (I.lower i) (I.upper i) := Set.left_mem_Icc.2 (I.lower_le_upper i)\n  have Hu : I.upper i ∈ Icc (I.lower i) (I.upper i) := Set.right_mem_Icc.2 (I.lower_le_upper i)\n  have Hi :\n    ∀ x ∈ Icc (I.lower i) (I.upper i),\n      integrable.{0, u, u} (I.face i) («expr⊥») (f ∘ i.insert_nth x) box_additive_map.volume :=\n    fun x hx => integrable_of_continuous_on _ (box.continuous_on_face_Icc hfc hx) volume\n  /- We start with an estimate: the difference of the values of `f` at the corresponding points\n    of the faces `x i = I.lower i` and `x i = I.upper i` is `(2 * ε * diam I.Icc)`-close to the value\n    of `f'` on `pi.single i (I.upper i - I.lower i) = lᵢ • eᵢ`, where `lᵢ = I.upper i - I.lower i`\n    is the length of `i`-th edge of `I` and `eᵢ = pi.single i 1` is the `i`-th unit vector. -/\n  have :\n    ∀ y ∈ (I.face i).Icc,\n      «expr‖ ‖»\n          (f' (Pi.single i (I.upper i - I.lower i)) -\n            (f (i.insert_nth (I.upper i) y) - f (i.insert_nth (I.lower i) y))) ≤\n        2 * ε * diam I.Icc :=\n    by\n    intro y hy\n    set g := fun y => f y - a - f' (y - x) with hg\n    change ∀ y ∈ I.Icc, «expr‖ ‖» (g y) ≤ ε * «expr‖ ‖» (y - x) at hε\n    clear_value g\n    obtain rfl : f = fun y => a + f' (y - x) + g y := by simp [hg]\n    convert_to «expr‖ ‖» (g (i.insert_nth (I.lower i) y) - g (i.insert_nth (I.upper i) y)) ≤ _\n    · congr 1\n      have := fin.insert_nth_sub_same i (I.upper i) (I.lower i) y\n      simp only [← this, f'.map_sub]\n      abel\n    · have : ∀ z ∈ Icc (I.lower i) (I.upper i), i.insert_nth z y ∈ I.Icc := fun z hz =>\n        I.maps_to_insert_nth_face_Icc hz hy\n      replace hε : ∀ y ∈ I.Icc, «expr‖ ‖» (g y) ≤ ε * diam I.Icc\n      · intro y hy\n        refine' (hε y hy).trans (mul_le_mul_of_nonneg_left _ h0.le)\n        rw [← dist_eq_norm]\n        exact dist_le_diam_of_mem I.is_compact_Icc.bounded hy hxI\n      rw [two_mul, add_mul]\n      exact norm_sub_le_of_le (hε _ (this _ Hl)) (hε _ (this _ Hu))\n  calc\n    «expr‖ ‖»\n          («expr • »\n              (finset.prod_univ\n                \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n                (I.upper j - I.lower j))\n              (f' (Pi.single i 1)) -\n            (integral (I.face i) («expr⊥») (f ∘ i.insert_nth (I.upper i)) box_additive_map.volume -\n              integral (I.face i) («expr⊥») (f ∘ i.insert_nth (I.lower i)) box_additive_map.volume)) =\n        «expr‖ ‖»\n          (integral.{0, u, u} (I.face i) («expr⊥»)\n            (fun x : fin n → exprℝ =>\n              f' (Pi.single i (I.upper i - I.lower i)) -\n                (f (i.insert_nth (I.upper i) x) - f (i.insert_nth (I.lower i) x)))\n            box_additive_map.volume) :=\n      by\n      rw [← integral_sub (Hi _ Hu) (Hi _ Hl), ← box.volume_face_mul i, mul_smul, ← box.volume_apply, ←\n        box_additive_map.to_smul_apply, ← integral_const, ← box_additive_map.volume, ←\n        integral_sub (integrable_const _) ((Hi _ Hu).sub (Hi _ Hl))]\n      simp only [(· ∘ ·), pi.sub_def, ← f'.map_smul, ← Pi.single_smul', smul_eq_mul, mul_one]\n    _ ≤ (volume (I.face i : set («exprℝⁿ»))).to_real * (2 * ε * c * (I.upper i - I.lower i)) :=\n      by\n      -- The hard part of the estimate was done above, here we just replace `diam I.Icc`\n      -- with `c * (I.upper i - I.lower i)`\n      refine' norm_integral_le_of_le_const (fun y hy => (this y hy).trans _) volume\n      rw [mul_assoc (2 * ε)]\n      exact mul_le_mul_of_nonneg_left (I.diam_Icc_le_of_distortion_le i hc) (mul_nonneg zero_le_two h0.le)\n    _ =\n        2 * ε * c *\n          finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n            (I.upper j - I.lower j) :=\n      by\n      rw [← measure.to_box_additive_apply, box.volume_apply, ← I.volume_face_mul i]\n      ac_rfl\n    \n#align norm_volume_sub_integral_face_upper_sub_lower_smul_le norm_volume_sub_integral_face_upper_sub_lower_smul_le\n\n",
 "has_integral_GP_pderiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `box_integral.box_additive_map -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `box_integral.box_additive_map -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℝⁿ⁺¹» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.gt -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Basic.lean:632:2: warning: expanding binder collection (y₁ y₂ «expr ∈ » «expr ∩ »(closed_ball x δ, I.Icc)) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℝⁿ⁺¹» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℝⁿ⁺¹» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℝⁿ⁺¹» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℝⁿ⁺¹» -/\n/-- If `f : ℝⁿ⁺¹ → E` is differentiable on a closed rectangular box `I` with derivative `f'`, then\nthe partial derivative `λ x, f' x (pi.single i 1)` is Henstock-Kurzweil integrable with integral\nequal to the difference of integrals of `f` over the faces `x i = I.upper i` and `x i = I.lower i`.\n\nMore precisely, we use a non-standard generalization of the Henstock-Kurzweil integral and\nwe allow `f` to be non-differentiable (but still continuous) at a countable set of points.\n\nTODO: If `n > 0`, then the condition at `x ∈ s` can be replaced by a much weaker estimate but this\nrequires either better integrability theorems, or usage of a filter depending on the countable set\n`s` (we need to ensure that none of the faces of a partition contain a point from `s`). -/\ntheorem has_integral_GP_pderiv (f : «exprℝⁿ⁺¹» → E) (f' : «exprℝⁿ⁺¹» → «expr →L[ ] » («exprℝⁿ⁺¹») (exprℝ) E)\n    (s : set («exprℝⁿ⁺¹»)) (hs : s.countable) (Hs : ∀ x ∈ s, continuous_within_at f I.Icc x)\n    (Hd : ∀ x ∈ I.Icc \\ s, has_fderiv_within_at f (f' x) I.Icc x) (i : fin (n + 1)) :\n    has_integral.{0, u, u} I GP (fun x => f' x (Pi.single i 1)) box_additive_map.volume\n      (integral.{0, u, u} (I.face i) GP (fun x => f (i.insert_nth (I.upper i) x)) box_additive_map.volume -\n        integral.{0, u, u} (I.face i) GP (fun x => f (i.insert_nth (I.lower i) x)) box_additive_map.volume) :=\n  by\n  /- Note that `f` is continuous on `I.Icc`, hence it is integrable on the faces of all boxes\n    `J ≤ I`, thus the difference of integrals over `x i = J.upper i` and `x i = J.lower i` is a\n    box-additive function of `J ≤ I`. -/\n  have Hc : continuous_on f I.Icc := by\n    intro x hx\n    by_cases hxs : x ∈ s\n    exacts[Hs x hxs, (Hd x ⟨hx, hxs⟩).continuous_within_at]\n  set fI : exprℝ → box (fin n) → E := fun y J =>\n    integral.{0, u, u} J GP (fun x => f (i.insert_nth y x)) box_additive_map.volume\n  set fb : Icc (I.lower i) (I.upper i) → box_integral.box_additive_map (fin n) (↑(I.face i)) E := fun x =>\n    (integrable_of_continuous_on GP (box.continuous_on_face_Icc Hc x.2) volume).to_box_additive\n  set F : box_integral.box_additive_map (fin (n + 1)) I E :=\n    box_additive_map.upper_sub_lower I i fI fb fun x hx J => rfl\n  -- Thus our statement follows from some local estimates.\n  change has_integral I GP (fun x => f' x (Pi.single i 1)) _ (F I)\n  refine' has_integral_of_le_Henstock_of_forall_is_o GP_le _ _ _ s hs _ _\n  ·-- We use the volume as an upper estimate.\n    exact (volume : measure («exprℝⁿ⁺¹»)).to_box_additive.restrict _ le_top\n  · exact fun J => ennreal.to_real_nonneg\n  · intro c x hx ε ε0\n    /- Near `x ∈ s` we choose `δ` so that both vectors are small. `volume J • eᵢ` is small because\n        `volume J ≤ (2 * δ) ^ (n + 1)` is small, and the difference of the integrals is small\n        because each of the integrals is close to `volume (J.face i) • f x`.\n        TODO: there should be a shorter and more readable way to formalize this simple proof. -/\n    have :\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\"\n        (nhds_within.gt (0 : exprℝ))\n        (δ ∈ Ioc (0 : exprℝ) (1 / 2) ∧\n          (∀ (y₁) (_ : y₁ ∈ closed_ball x δ ∩ I.Icc) (y₂) (_ : y₂ ∈ closed_ball x δ ∩ I.Icc),\n              «expr‖ ‖» (f y₁ - f y₂) ≤ ε / 2) ∧\n            (2 * δ) ^ (n + 1) * «expr‖ ‖» (f' x (Pi.single i 1)) ≤ ε / 2) :=\n      by\n      refine' eventually.and _ (eventually.and _ _)\n      · exact Ioc_mem_nhds_within_Ioi ⟨le_rfl, one_half_pos⟩\n      · rcases((nhds_within_has_basis nhds_basis_closed_ball _).tendsto_iff nhds_basis_closed_ball).1 (Hs x hx.2) _\n            (half_pos <| half_pos ε0) with ⟨δ₁, δ₁0, hδ₁⟩\n        filter_upwards [Ioc_mem_nhds_within_Ioi ⟨le_rfl, δ₁0⟩] with δ hδ y₁ hy₁ y₂ hy₂\n        have : closed_ball x δ ∩ I.Icc ⊆ closed_ball x δ₁ ∩ I.Icc :=\n          inter_subset_inter_left _ (closed_ball_subset_closed_ball hδ.2)\n        rw [← dist_eq_norm]\n        calc\n          dist (f y₁) (f y₂) ≤ dist (f y₁) (f x) + dist (f y₂) (f x) := dist_triangle_right _ _ _\n          _ ≤ ε / 2 / 2 + ε / 2 / 2 := add_le_add (hδ₁ _ <| this hy₁) (hδ₁ _ <| this hy₂)\n          _ = ε / 2 := add_halves _\n          \n      · have :\n          continuous_within_at (fun δ => (2 * δ) ^ (n + 1) * «expr‖ ‖» (f' x (Pi.single i 1))) (Ioi (0 : exprℝ)) 0 :=\n          ((continuous_within_at_id.const_mul _).pow _).mul_const _\n        refine' this.eventually (ge_mem_nhds _)\n        simpa using half_pos ε0\n    rcases this.exists with ⟨δ, ⟨hδ0, hδ12⟩, hdfδ, hδ⟩\n    refine' ⟨δ, hδ0, fun J hJI hJδ hxJ hJc => add_halves ε ▸ _⟩\n    have Hl : J.lower i ∈ Icc (J.lower i) (J.upper i) := Set.left_mem_Icc.2 (J.lower_le_upper i)\n    have Hu : J.upper i ∈ Icc (J.lower i) (J.upper i) := Set.right_mem_Icc.2 (J.lower_le_upper i)\n    have Hi :\n      ∀ x ∈ Icc (J.lower i) (J.upper i),\n        integrable.{0, u, u} (J.face i) GP (fun y => f (i.insert_nth x y)) box_additive_map.volume :=\n      fun x hx => integrable_of_continuous_on _ (box.continuous_on_face_Icc (Hc.mono <| box.le_iff_Icc.1 hJI) hx) volume\n    have hJδ' : J.Icc ⊆ closed_ball x δ ∩ I.Icc := subset_inter hJδ (box.le_iff_Icc.1 hJI)\n    have Hmaps : ∀ z ∈ Icc (J.lower i) (J.upper i), maps_to (i.insert_nth z) (J.face i).Icc (closed_ball x δ ∩ I.Icc) :=\n      fun z hz => (J.maps_to_insert_nth_face_Icc hz).mono subset.rfl hJδ'\n    simp only [dist_eq_norm, F, fI]\n    dsimp\n    rw [← integral_sub (Hi _ Hu) (Hi _ Hl)]\n    refine' (norm_sub_le _ _).trans (add_le_add _ _)\n    · simp_rw [box_additive_map.volume_apply, norm_smul, real.norm_eq_abs, abs_prod]\n      refine' (mul_le_mul_of_nonneg_right _ <| norm_nonneg _).trans hδ\n      have : ∀ j, |J.upper j - J.lower j| ≤ 2 * δ := by\n        intro j\n        calc\n          dist (J.upper j) (J.lower j) ≤ dist J.upper J.lower := dist_le_pi_dist _ _ _\n          _ ≤ dist J.upper x + dist J.lower x := dist_triangle_right _ _ _\n          _ ≤ δ + δ := add_le_add (hJδ J.upper_mem_Icc) (hJδ J.lower_mem_Icc)\n          _ = 2 * δ := (two_mul δ).symm\n          \n      calc\n        finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n              (|J.upper j - J.lower j|) ≤\n            finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n              (2 * δ) :=\n          prod_le_prod (fun _ _ => abs_nonneg _) fun j hj => this j\n        _ = (2 * δ) ^ (n + 1) := by simp\n        \n    · refine' (norm_integral_le_of_le_const (fun y hy => hdfδ _ (Hmaps _ Hu hy) _ (Hmaps _ Hl hy)) _).trans _\n      refine' (mul_le_mul_of_nonneg_right _ (half_pos ε0).le).trans_eq (one_mul _)\n      rw [box.coe_eq_pi, real.volume_pi_Ioc_to_real (box.lower_le_upper _)]\n      refine' prod_le_one (fun _ _ => sub_nonneg.2 <| box.lower_le_upper _ _) fun j hj => _\n      calc\n        J.upper (i.succ_above j) - J.lower (i.succ_above j) ≤\n            dist (J.upper (i.succ_above j)) (J.lower (i.succ_above j)) :=\n          le_abs_self _\n        _ ≤ dist J.upper J.lower := dist_le_pi_dist J.upper J.lower (i.succ_above j)\n        _ ≤ dist J.upper x + dist J.lower x := dist_triangle_right _ _ _\n        _ ≤ δ + δ := add_le_add (hJδ J.upper_mem_Icc) (hJδ J.lower_mem_Icc)\n        _ ≤ 1 / 2 + 1 / 2 := add_le_add hδ12 hδ12\n        _ = 1 := add_halves 1\n        \n  · intro c x hx ε ε0\n    /- At a point `x ∉ s`, we unfold the definition of Fréchet differentiability, then use\n        an estimate we proved earlier in this file. -/\n    rcases exists_pos_mul_lt ε0 (2 * c) with ⟨ε', ε'0, hlt⟩\n    rcases(nhds_within_has_basis nhds_basis_closed_ball _).mem_iff.1 ((Hd x hx).def ε'0) with ⟨δ, δ0, Hδ⟩\n    refine' ⟨δ, δ0, fun J hle hJδ hxJ hJc => _⟩\n    simp only [box_additive_map.volume_apply, box.volume_apply, dist_eq_norm]\n    refine'\n      (norm_volume_sub_integral_face_upper_sub_lower_smul_le _ (Hc.mono <| box.le_iff_Icc.1 hle) hxJ ε'0\n            (fun y hy => Hδ _) (hJc rfl)).trans\n        _\n    · exact ⟨hJδ hy, box.le_iff_Icc.1 hle hy⟩\n    · rw [mul_right_comm (2 : exprℝ), ← box.volume_apply]\n      exact mul_le_mul_of_nonneg_right hlt.le ennreal.to_real_nonneg\n#align has_integral_GP_pderiv has_integral_GP_pderiv\n\n",
 "has_integral_GP_divergence_of_forall_has_deriv_within_at":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℝⁿ⁺¹» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprEⁿ⁺¹» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℝⁿ⁺¹» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℝⁿ⁺¹» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprEⁿ⁺¹» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℝⁿ⁺¹» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/-- Divergence theorem for a Henstock-Kurzweil style integral.\n\nIf `f : ℝⁿ⁺¹ → Eⁿ⁺¹` is differentiable on a closed rectangular box `I` with derivative `f'`, then\nthe divergence `∑ i, f' x (pi.single i 1) i` is Henstock-Kurzweil integrable with integral equal to\nthe sum of integrals of `f` over the faces of `I` taken with appropriate signs.\n\nMore precisely, we use a non-standard generalization of the Henstock-Kurzweil integral and\nwe allow `f` to be non-differentiable (but still continuous) at a countable set of points. -/\ntheorem has_integral_GP_divergence_of_forall_has_deriv_within_at (f : «exprℝⁿ⁺¹» → «exprEⁿ⁺¹»)\n    (f' : «exprℝⁿ⁺¹» → «expr →L[ ] » («exprℝⁿ⁺¹») (exprℝ) («exprEⁿ⁺¹»)) (s : set («exprℝⁿ⁺¹»)) (hs : s.countable)\n    (Hs : ∀ x ∈ s, continuous_within_at f I.Icc x) (Hd : ∀ x ∈ I.Icc \\ s, has_fderiv_within_at f (f' x) I.Icc x) :\n    has_integral.{0, u, u} I GP\n      (fun x =>\n        finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n          (f' x (Pi.single i 1) i))\n      box_additive_map.volume\n      (finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n        (integral.{0, u, u} (I.face i) GP (fun x => f (i.insert_nth (I.upper i) x) i) box_additive_map.volume -\n          integral.{0, u, u} (I.face i) GP (fun x => f (i.insert_nth (I.lower i) x) i) box_additive_map.volume)) :=\n  by\n  refine' has_integral_sum fun i hi => _; clear hi\n  simp only [has_fderiv_within_at_pi', continuous_within_at_pi] at Hd Hs\n  convert has_integral_GP_pderiv I _ _ s hs (fun x hx => Hs x hx i) (fun x hx => Hd x hx i) i\n#align has_integral_GP_divergence_of_forall_has_deriv_within_at has_integral_GP_divergence_of_forall_has_deriv_within_at\n\n"}