{"unique":
 "theorem has_integral.unique (h : has_integral I l f vol y) (h' : has_integral I l f vol y') : y = y' :=\n  tendsto_nhds_unique h h'\n#align has_integral.unique has_integral.unique\n\n",
 "to_subbox_aux":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem to_subbox_aux (h : integrable I l f vol) (hJ : J ≤ I) :\n    ∃ y : F,\n      has_integral J l f vol y ∧\n        tendsto (integral_sum f vol) (l.to_filter_Union I (prepartition.single I J hJ)) ((nhds) y) :=\n  by\n  refine'\n    (cauchy_map_iff_exists_tendsto.1 (h.cauchy_map_integral_sum_to_filter_Union (prepartition.single I J hJ))).imp\n      fun y hy => ⟨_, hy⟩\n  convert hy.comp (l.tendsto_embed_box_to_filter_Union_top hJ)\n#align to_subbox_aux to_subbox_aux\n\n",
 "to_subbox":
 "-- faster than `exact` here\n/-- If `f` is integrable on a box `I`, then it is integrable on any subbox of `I`. -/\ntheorem to_subbox (h : integrable I l f vol) (hJ : J ≤ I) : integrable J l f vol :=\n  (h.to_subbox_aux hJ).imp fun y => And.left\n#align to_subbox to_subbox\n\n",
 "tendsto_integral_sum_to_filter_prod_self_inf_Union_eq_uniformity":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/-- If `f` is integrable on `I` along `l`, then for two sufficiently fine tagged prepartitions\n(in the sense of the filter `box_integral.integration_params.to_filter l I`) such that they cover\nthe same part of `I`, the integral sums of `f` over `π₁` and `π₂` are very close to each other.  -/\ntheorem tendsto_integral_sum_to_filter_prod_self_inf_Union_eq_uniformity (h : integrable I l f vol) :\n    tendsto (fun π : tagged_prepartition I × tagged_prepartition I => (integral_sum f vol π.1, integral_sum f vol π.2))\n      («expr ⊓ » (filter.prod (l.to_filter I) (l.to_filter I)) ((filter.principal) { π | π.1.Union = π.2.Union }))\n      ((uniformity) F) :=\n  by\n  refine' (((l.has_basis_to_filter I).prod_self.inf_principal _).tendsto_iff uniformity_basis_dist_le).2 fun ε ε0 => _\n  replace ε0 := half_pos ε0\n  use h.convergence_r (ε / 2), h.convergence_r_cond (ε / 2); rintro ⟨π₁, π₂⟩ ⟨⟨h₁, h₂⟩, hU⟩\n  rw [← add_halves ε]\n  exact h.dist_integral_sum_le_of_mem_base_set ε0 ε0 h₁.some_spec h₂.some_spec hU\n#align\n  tendsto_integral_sum_to_filter_prod_self_inf_Union_eq_uniformity tendsto_integral_sum_to_filter_prod_self_inf_Union_eq_uniformity\n\n",
 "tendsto_integral_sum_to_filter_Union_single":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- If `f` is integrable on a box `I`, then integral sums of `f` over tagged prepartitions\nthat cover exactly a subbox `J ≤ I` tend to the integral of `f` over `J` along `l`. -/\ntheorem tendsto_integral_sum_to_filter_Union_single (h : integrable I l f vol) (hJ : J ≤ I) :\n    tendsto (integral_sum f vol) (l.to_filter_Union I (prepartition.single I J hJ)) (nhds <| integral J l f vol) :=\n  let ⟨y, h₁, h₂⟩ := h.to_subbox_aux hJ\n  h₁.integral_eq.symm ▸ h₂\n#align tendsto_integral_sum_to_filter_Union_single tendsto_integral_sum_to_filter_Union_single\n\n",
 "tendsto_integral_sum_sum_integral":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/-- Integral sum of `f` over a tagged prepartition `π` such that `π.Union = π₀.Union` tends to the\nsum of integrals of `f` over the boxes of `π₀`. -/\ntheorem tendsto_integral_sum_sum_integral (h : integrable I l f vol) (π₀ : prepartition I) :\n    tendsto (integral_sum f vol) (l.to_filter_Union I π₀)\n      (nhds <|\n        finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" π₀.boxes\n          (integral J l f vol)) :=\n  by\n  refine' ((l.has_basis_to_filter_Union I π₀).tendsto_iff nhds_basis_closed_ball).2 fun ε ε0 => _\n  refine' ⟨h.convergence_r ε, h.convergence_r_cond ε, _⟩\n  simp only [mem_inter_iff, Set.mem_unionᵢ, mem_set_of_eq]\n  rintro π ⟨c, hc, hU⟩\n  exact h.dist_integral_sum_sum_integral_le_of_mem_base_set_of_Union_eq ε0 hc hU\n#align tendsto_integral_sum_sum_integral tendsto_integral_sum_sum_integral\n\n",
 "tendsto":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- Reinterpret `box_integral.has_integral` as `filter.tendsto`, e.g., dot-notation theorems\nthat are shadowed in the `box_integral.has_integral` namespace. -/\ntheorem has_integral.tendsto (h : has_integral I l f vol y) :\n    tendsto (integral_sum f vol) (l.to_filter_Union I («expr⊤»)) ((nhds) y) :=\n  h\n#align has_integral.tendsto has_integral.tendsto\n\n",
 "sum_integral_congr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/-- If `f` is integrable on `I`, then `λ J, integral J l f vol` is box-additive on subboxes of `I`:\nif `π₁`, `π₂` are two prepartitions of `I` covering the same part of `I`, then the sum of integrals\nof `f` over the boxes of `π₁` is equal to the sum of integrals of `f` over the boxes of `π₂`.\n\nSee also `box_integral.integrable.to_box_additive` for a bundled version. -/\ntheorem sum_integral_congr (h : integrable I l f vol) {π₁ π₂ : prepartition I} (hU : π₁.Union = π₂.Union) :\n    finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" π₁.boxes\n        (integral J l f vol) =\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" π₂.boxes\n        (integral J l f vol) :=\n  by\n  refine' tendsto_nhds_unique (h.tendsto_integral_sum_sum_integral π₁) _\n  rw [l.to_filter_Union_congr _ hU]\n  exact h.tendsto_integral_sum_sum_integral π₂\n#align sum_integral_congr sum_integral_congr\n\n",
 "sub":
 "theorem integrable.sub (hf : integrable I l f vol) (hg : integrable I l g vol) : integrable I l (f - g) vol :=\n  (hf.has_integral.sub hg.has_integral).integrable\n#align integrable.sub integrable.sub\n\n",
 "smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem integrable.smul (hf : integrable I l f vol) (c : exprℝ) : integrable I l («expr • » c f) vol :=\n  (hf.has_integral.smul c).integrable\n#align integrable.smul integrable.smul\n\n",
 "of_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem integrable.of_smul {c : exprℝ} (hf : integrable I l («expr • » c f) vol) (hc : c ≠ 0) : integrable I l f vol :=\n  by\n  convert hf.smul c⁻¹\n  ext x\n  simp only [pi.smul_apply, inv_smul_smul₀ hc]\n#align integrable.of_smul integrable.of_smul\n\n",
 "of_neg":
 "theorem integrable.of_neg (hf : integrable I l (-f) vol) : integrable I l f vol :=\n  neg_neg f ▸ hf.neg\n#align integrable.of_neg integrable.of_neg\n\n",
 "norm_integral_le_of_norm_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℝⁿ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℝⁿ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/-- If `‖f x‖ ≤ g x` on `[l, u]` and `g` is integrable, then the norm of the integral of `f` is less\nthan or equal to the integral of `g`. -/\ntheorem norm_integral_le_of_norm_le {g : «exprℝⁿ» → exprℝ} (hle : ∀ x ∈ I.Icc, «expr‖ ‖» (f x) ≤ g x)\n    (μ : measure («exprℝⁿ»)) [is_locally_finite_measure μ] (hg : integrable I l g μ.to_box_additive.to_smul) :\n    «expr‖ ‖» (integral I l f μ.to_box_additive.to_smul : E) ≤ integral I l g μ.to_box_additive.to_smul :=\n  by\n  by_cases hfi : integrable.{u, v, v} I l f μ.to_box_additive.to_smul\n  · refine' le_of_tendsto_of_tendsto' hfi.has_integral.norm hg.has_integral fun π => _\n    refine' norm_sum_le_of_le _ fun J hJ => _\n    simp only [box_additive_map.to_smul_apply, norm_smul, smul_eq_mul, real.norm_eq_abs, μ.to_box_additive_apply,\n      abs_of_nonneg ennreal.to_real_nonneg]\n    exact mul_le_mul_of_nonneg_left (hle _ <| π.tag_mem_Icc _) ennreal.to_real_nonneg\n  · rw [integral, dif_neg hfi, norm_zero]\n    exact integral_nonneg (fun x hx => (norm_nonneg _).trans (hle x hx)) μ\n#align norm_integral_le_of_norm_le norm_integral_le_of_norm_le\n\n",
 "norm_integral_le_of_le_const":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℝⁿ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem norm_integral_le_of_le_const {c : exprℝ} (hc : ∀ x ∈ I.Icc, «expr‖ ‖» (f x) ≤ c) (μ : measure («exprℝⁿ»))\n    [is_locally_finite_measure μ] : «expr‖ ‖» (integral I l f μ.to_box_additive.to_smul : E) ≤ (μ I).to_real * c := by\n  simpa only [integral_const] using norm_integral_le_of_norm_le hc μ (integrable_const c)\n#align norm_integral_le_of_le_const norm_integral_le_of_le_const\n\n",
 "neg":
 "theorem integrable.neg (hf : integrable I l f vol) : integrable I l (-f) vol :=\n  hf.has_integral.neg.integrable\n#align integrable.neg integrable.neg\n\n",
 "mono":
 "theorem integrable.mono {l'} (h : integrable I l f vol) (hle : l' ≤ l) : integrable I l' f vol :=\n  ⟨_, h.has_integral.mono hle⟩\n#align integrable.mono integrable.mono\n\n",
 "integral_zero":
 "theorem integral_zero : integral I l (fun _ => (0 : E)) vol = 0 :=\n  has_integral_zero.integral_eq\n#align integral_zero integral_zero\n\n",
 "integral_sum_sub_partitions":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℝⁿ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `box_integral.box_additive_map.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\ntheorem integral_sum_sub_partitions (f : «exprℝⁿ» → E)\n    (vol : box_integral.box_additive_map.top ι («expr →L[ ] » E (exprℝ) F)) {π₁ π₂ : tagged_prepartition I}\n    (h₁ : π₁.is_partition) (h₂ : π₂.is_partition) :\n    integral_sum f vol π₁ - integral_sum f vol π₂ =\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n        («expr ⊓ » π₁.to_prepartition π₂.to_prepartition).boxes\n        (vol J (f <| (π₁.inf_prepartition π₂.to_prepartition).tag J) -\n          vol J (f <| (π₂.inf_prepartition π₁.to_prepartition).tag J)) :=\n  by\n  rw [← integral_sum_inf_partition f vol π₁ h₂, ← integral_sum_inf_partition f vol π₂ h₁, integral_sum, integral_sum,\n    finset.sum_sub_distrib]\n  simp only [inf_prepartition_to_prepartition, _root_.inf_comm]\n#align integral_sum_sub_partitions integral_sum_sub_partitions\n\n",
 "integral_sum_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℝⁿ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `box_integral.box_additive_map.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem integral_sum_smul (c : exprℝ) (f : «exprℝⁿ» → E)\n    (vol : box_integral.box_additive_map.top ι («expr →L[ ] » E (exprℝ) F)) (π : tagged_prepartition I) :\n    integral_sum («expr • » c f) vol π = «expr • » c (integral_sum f vol π) := by\n  simp only [integral_sum, finset.smul_sum, pi.smul_apply, continuous_linear_map.map_smul]\n#align integral_sum_smul integral_sum_smul\n\n",
 "integral_sum_neg":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℝⁿ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `box_integral.box_additive_map.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n@[simp]\ntheorem integral_sum_neg (f : «exprℝⁿ» → E) (vol : box_integral.box_additive_map.top ι («expr →L[ ] » E (exprℝ) F))\n    (π : tagged_prepartition I) : integral_sum (-f) vol π = -integral_sum f vol π := by\n  simp only [integral_sum, pi.neg_apply, (vol _).map_neg, finset.sum_neg_distrib]\n#align integral_sum_neg integral_sum_neg\n\n",
 "integral_sum_inf_partition":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℝⁿ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `box_integral.box_additive_map.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem integral_sum_inf_partition (f : «exprℝⁿ» → E)\n    (vol : box_integral.box_additive_map.top ι («expr →L[ ] » E (exprℝ) F)) (π : tagged_prepartition I)\n    {π' : prepartition I} (h : π'.is_partition) : integral_sum f vol (π.inf_prepartition π') = integral_sum f vol π :=\n  integral_sum_bUnion_partition f vol π _ fun J hJ => h.restrict (prepartition.le_of_mem _ hJ)\n#align integral_sum_inf_partition integral_sum_inf_partition\n\n",
 "integral_sum_fiberwise":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℝⁿ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `box_integral.box_additive_map.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem integral_sum_fiberwise {α} (g : box ι → α) (f : «exprℝⁿ» → E)\n    (vol : box_integral.box_additive_map.top ι («expr →L[ ] » E (exprℝ) F)) (π : tagged_prepartition I) :\n    finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (π.boxes.image g)\n        (integral_sum f vol (π.filter fun x => g x = y)) =\n      integral_sum f vol π :=\n  π.to_prepartition.sum_fiberwise g fun J => vol J (f <| π.tag J)\n#align integral_sum_fiberwise integral_sum_fiberwise\n\n",
 "integral_sum_disj_union":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℝⁿ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `box_integral.box_additive_map.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n@[simp]\ntheorem integral_sum_disj_union (f : «exprℝⁿ» → E)\n    (vol : box_integral.box_additive_map.top ι («expr →L[ ] » E (exprℝ) F)) {π₁ π₂ : tagged_prepartition I}\n    (h : Disjoint π₁.Union π₂.Union) :\n    integral_sum f vol (π₁.disj_union π₂ h) = integral_sum f vol π₁ + integral_sum f vol π₂ :=\n  by\n  refine'\n    (prepartition.sum_disj_union_boxes h _).trans\n      (congr_arg₂ (· + ·) (sum_congr rfl fun J hJ => _) (sum_congr rfl fun J hJ => _))\n  · rw [disj_union_tag_of_mem_left _ hJ]\n  · rw [disj_union_tag_of_mem_right _ hJ]\n#align integral_sum_disj_union integral_sum_disj_union\n\n",
 "integral_sum_bUnion_tagged":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℝⁿ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `box_integral.box_additive_map.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/-\nCopyright (c) 2021 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-/\ntheorem integral_sum_bUnion_tagged (f : «exprℝⁿ» → E)\n    (vol : box_integral.box_additive_map.top ι («expr →L[ ] » E (exprℝ) F)) (π : prepartition I)\n    (πi : ∀ J, tagged_prepartition J) :\n    integral_sum f vol (π.bUnion_tagged πi) =\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" π.boxes\n        (integral_sum f vol (πi J)) :=\n  by\n  refine' (π.sum_bUnion_boxes _ _).trans (sum_congr rfl fun J hJ => sum_congr rfl fun J' hJ' => _)\n  rw [π.tag_bUnion_tagged hJ hJ']\n#align integral_sum_bUnion_tagged integral_sum_bUnion_tagged\n\n",
 "integral_sum_bUnion_partition":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℝⁿ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `box_integral.box_additive_map.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem integral_sum_bUnion_partition (f : «exprℝⁿ» → E)\n    (vol : box_integral.box_additive_map.top ι («expr →L[ ] » E (exprℝ) F)) (π : tagged_prepartition I)\n    (πi : ∀ J, prepartition J) (hπi : ∀ J ∈ π, (πi J).is_partition) :\n    integral_sum f vol (π.bUnion_prepartition πi) = integral_sum f vol π :=\n  by\n  refine' (π.to_prepartition.sum_bUnion_boxes _ _).trans (sum_congr rfl fun J hJ => _)\n  calc\n    finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (πi J).boxes\n          (vol J' (f (π.tag <| π.to_prepartition.bUnion_index πi J'))) =\n        finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (πi J).boxes\n          (vol J' (f (π.tag J))) :=\n      sum_congr rfl fun J' hJ' => by rw [prepartition.bUnion_index_of_mem _ hJ hJ']\n    _ = vol J (f (π.tag J)) :=\n      (vol.map ⟨fun g : «expr →L[ ] » E (exprℝ) F => g (f (π.tag J)), rfl, fun _ _ => rfl⟩).sum_partition_boxes le_top\n        (hπi J hJ)\n    \n#align integral_sum_bUnion_partition integral_sum_bUnion_partition\n\n",
 "integral_sum_add":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℝⁿ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `box_integral.box_additive_map.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n@[simp]\ntheorem integral_sum_add (f g : «exprℝⁿ» → E) (vol : box_integral.box_additive_map.top ι («expr →L[ ] » E (exprℝ) F))\n    (π : tagged_prepartition I) : integral_sum (f + g) vol π = integral_sum f vol π + integral_sum g vol π := by\n  simp only [integral_sum, pi.add_apply, (vol _).map_add, finset.sum_add_distrib]\n#align integral_sum_add integral_sum_add\n\n",
 "integral_sub":
 "theorem integral_sub (hf : integrable I l f vol) (hg : integrable I l g vol) :\n    integral I l (f - g) vol = integral I l f vol - integral I l g vol :=\n  (hf.has_integral.sub hg.has_integral).integral_eq\n#align integral_sub integral_sub\n\n",
 "integral_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem integral_smul (c : exprℝ) : integral I l (fun x => «expr • » c (f x)) vol = «expr • » c (integral I l f vol) :=\n  by\n  rcases eq_or_ne c 0 with (rfl | hc); · simp only [zero_smul, integral_zero]\n  by_cases hf : integrable I l f vol\n  · exact (hf.has_integral.smul c).integral_eq\n  · have : ¬integrable I l (fun x => «expr • » c (f x)) vol := mt (fun h => h.of_smul hc) hf\n    rw [integral, integral, dif_neg hf, dif_neg this, smul_zero]\n#align integral_smul integral_smul\n\n",
 "integral_nonneg":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℝⁿ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℝⁿ» -/\n/-- The integral of a nonnegative function w.r.t. a volume generated by a locally-finite measure is\nnonnegative. -/\ntheorem integral_nonneg {g : «exprℝⁿ» → exprℝ} (hg : ∀ x ∈ I.Icc, 0 ≤ g x) (μ : measure («exprℝⁿ»))\n    [is_locally_finite_measure μ] : 0 ≤ integral I l g μ.to_box_additive.to_smul :=\n  by\n  by_cases hgi : integrable I l g μ.to_box_additive.to_smul\n  · refine' ge_of_tendsto' hgi.has_integral fun π => sum_nonneg fun J hJ => _\n    exact mul_nonneg ennreal.to_real_nonneg (hg _ <| π.tag_mem_Icc _)\n  · rw [integral, dif_neg hgi]\n#align integral_nonneg integral_nonneg\n\n",
 "integral_neg":
 "@[simp]\ntheorem integral_neg : integral I l (-f) vol = -integral I l f vol :=\n  if h : integrable I l f vol then h.has_integral.neg.integral_eq\n  else by rw [integral, integral, dif_neg h, dif_neg (mt integrable.of_neg h), neg_zero]\n#align integral_neg integral_neg\n\n",
 "integral_eq":
 "theorem has_integral.integral_eq (h : has_integral I l f vol y) : integral I l f vol = y :=\n  h.integrable.has_integral.unique h\n#align has_integral.integral_eq has_integral.integral_eq\n\n",
 "integral_const":
 "@[simp]\ntheorem integral_const (c : E) : integral I l (fun _ => c) vol = vol I c :=\n  (has_integral_const c).integral_eq\n#align integral_const integral_const\n\n",
 "integral_add":
 "theorem integral_add (hf : integrable I l f vol) (hg : integrable I l g vol) :\n    integral I l (f + g) vol = integral I l f vol + integral I l g vol :=\n  (hf.has_integral.add hg.has_integral).integral_eq\n#align integral_add integral_add\n\n",
 "integrable_zero":
 "theorem integrable_zero : integrable I l (fun _ => (0 : E)) vol :=\n  ⟨0, has_integral_zero⟩\n#align integrable_zero integrable_zero\n\n",
 "integrable_of_continuous_on":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℝⁿ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℝⁿ» -/\n/-- A continuous function is box-integrable with respect to any locally finite measure.\n\nThis is true for any volume with bounded variation. -/\ntheorem integrable_of_continuous_on [complete_space E] {I : box ι} {f : «exprℝⁿ» → E} (hc : continuous_on f I.Icc)\n    (μ : measure («exprℝⁿ»)) [is_locally_finite_measure μ] : integrable.{u, v, v} I l f μ.to_box_additive.to_smul :=\n  by\n  have huc := I.is_compact_Icc.uniform_continuous_on_of_continuous hc\n  rw [metric.uniform_continuous_on_iff_le] at huc\n  refine' integrable_iff_cauchy_basis.2 fun ε ε0 => _\n  rcases exists_pos_mul_lt ε0 (μ.to_box_additive I) with ⟨ε', ε0', hε⟩\n  rcases huc ε' ε0' with ⟨δ, δ0 : 0 < δ, Hδ⟩\n  refine' ⟨fun _ _ => ⟨δ / 2, half_pos δ0⟩, fun _ _ _ => rfl, fun c₁ c₂ π₁ π₂ h₁ h₁p h₂ h₂p => _⟩\n  simp only [dist_eq_norm, integral_sum_sub_partitions _ _ h₁p h₂p, box_additive_map.to_smul_apply, ← smul_sub]\n  have :\n    ∀ J ∈ «expr ⊓ » π₁.to_prepartition π₂.to_prepartition,\n      «expr‖ ‖»\n          («expr • » (μ.to_box_additive J)\n            (f ((π₁.inf_prepartition π₂.to_prepartition).tag J) - f ((π₂.inf_prepartition π₁.to_prepartition).tag J))) ≤\n        μ.to_box_additive J * ε' :=\n    by\n    intro J hJ\n    have : 0 ≤ μ.to_box_additive J := ennreal.to_real_nonneg\n    rw [norm_smul, real.norm_eq_abs, abs_of_nonneg this, ← dist_eq_norm]\n    refine' mul_le_mul_of_nonneg_left _ this\n    refine' Hδ _ (tagged_prepartition.tag_mem_Icc _ _) _ (tagged_prepartition.tag_mem_Icc _ _) _\n    rw [← add_halves δ]\n    refine' (dist_triangle_left _ _ J.upper).trans (add_le_add (h₁.1 _ _ _) (h₂.1 _ _ _))\n    · exact prepartition.bUnion_index_mem _ hJ\n    · exact box.le_iff_Icc.1 (prepartition.le_bUnion_index _ hJ) J.upper_mem_Icc\n    · rw [_root_.inf_comm] at hJ\n      exact prepartition.bUnion_index_mem _ hJ\n    · rw [_root_.inf_comm] at hJ\n      exact box.le_iff_Icc.1 (prepartition.le_bUnion_index _ hJ) J.upper_mem_Icc\n  refine' (norm_sum_le_of_le _ this).trans _\n  rw [← finset.sum_mul, μ.to_box_additive.sum_partition_boxes le_top (h₁p.inf h₂p)]\n  exact hε.le\n#align integrable_of_continuous_on integrable_of_continuous_on\n\n",
 "integrable_neg":
 "@[simp]\ntheorem integrable_neg : integrable I l (-f) vol ↔ integrable I l f vol :=\n  ⟨fun h => h.of_neg, fun h => h.neg⟩\n#align integrable_neg integrable_neg\n\n",
 "integrable_iff_cauchy_basis":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℝⁿ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- In a complete space, a function is integrable if and only if its integral sums form a Cauchy\nnet. Here we restate this fact in terms of `∀ ε > 0, ∃ r, ...`. -/\ntheorem integrable_iff_cauchy_basis [complete_space F] :\n    integrable I l f vol ↔\n      ∀ ε > (0 : exprℝ),\n        ∃ r : nnreal → «exprℝⁿ» → Ioi (0 : exprℝ),\n          (∀ c, l.r_cond (r c)) ∧\n            ∀ c₁ c₂ π₁ π₂,\n              l.mem_base_set I c₁ (r c₁) π₁ →\n                π₁.is_partition →\n                  l.mem_base_set I c₂ (r c₂) π₂ →\n                    π₂.is_partition → dist (integral_sum f vol π₁) (integral_sum f vol π₂) ≤ ε :=\n  by\n  rw [integrable_iff_cauchy, cauchy_map_iff',\n    (l.has_basis_to_filter_Union_top _).prod_self.tendsto_iff uniformity_basis_dist_le]\n  refine' forall₂_congr fun ε ε0 => exists_congr fun r => _\n  simp only [exists_prop, prod.forall, Set.mem_unionᵢ, exists_imp, prod_mk_mem_set_prod_eq, and_imp, mem_inter_iff,\n    mem_set_of_eq]\n  exact\n    and_congr iff.rfl\n      ⟨fun H c₁ c₂ π₁ π₂ h₁ hU₁ h₂ hU₂ => H π₁ π₂ c₁ h₁ hU₁ c₂ h₂ hU₂, fun H π₁ π₂ c₁ h₁ hU₁ c₂ h₂ hU₂ =>\n        H c₁ c₂ π₁ π₂ h₁ hU₁ h₂ hU₂⟩\n#align integrable_iff_cauchy_basis integrable_iff_cauchy_basis\n\n",
 "integrable_iff_cauchy":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem integrable_iff_cauchy [complete_space F] :\n    integrable I l f vol ↔ cauchy ((l.to_filter_Union I («expr⊤»)).map (integral_sum f vol)) :=\n  cauchy_map_iff_exists_tendsto.symm\n#align integrable_iff_cauchy integrable_iff_cauchy\n\n",
 "integrable_const":
 "theorem integrable_const (c : E) : integrable I l (fun _ => c) vol :=\n  ⟨_, has_integral_const c⟩\n#align integrable_const integrable_const\n\n",
 "integrable":
 "theorem has_integral.integrable (h : has_integral I l f vol y) : integrable I l f vol :=\n  ⟨_, h⟩\n#align has_integral.integrable has_integral.integrable\n\n",
 "has_integral_zero":
 "theorem has_integral_zero : has_integral I l (fun _ => (0 : E)) vol 0 := by\n  simpa only [← (vol I).map_zero] using has_integral_const (0 : E)\n#align has_integral_zero has_integral_zero\n\n",
 "has_integral_sum":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℝⁿ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem has_integral_sum {α : Type _} {s : Finset α} {f : α → «exprℝⁿ» → E} {g : α → F}\n    (h : ∀ i ∈ s, has_integral I l (f i) vol (g i)) :\n    has_integral I l\n      (fun x =>\n        finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s (f i x))\n      vol (finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s (g i)) :=\n  by\n  induction' s using Finset.induction_on with a s ha ihs; · simp [has_integral_zero]\n  simp only [finset.sum_insert ha]; rw [Finset.forall_mem_insert] at h\n  exact h.1.add (ihs h.2)\n#align has_integral_sum has_integral_sum\n\n",
 "has_integral_of_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℝⁿ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- Quite often it is more natural to prove an estimate of the form `a * ε`, not `ε` in the RHS of\n`box_integral.has_integral_iff`, so we provide this auxiliary lemma.  -/\ntheorem has_integral_of_mul (a : exprℝ)\n    (h :\n      ∀ ε : exprℝ,\n        0 < ε →\n          ∃ r : nnreal → «exprℝⁿ» → Ioi (0 : exprℝ),\n            (∀ c, l.r_cond (r c)) ∧\n              ∀ c π, l.mem_base_set I c (r c) π → is_partition π → dist (integral_sum f vol π) y ≤ a * ε) :\n    has_integral I l f vol y := by\n  refine' has_integral_iff.2 fun ε hε => _\n  rcases exists_pos_mul_lt hε a with ⟨ε', hε', ha⟩\n  rcases h ε' hε' with ⟨r, hr, H⟩\n  exact ⟨r, hr, fun c π hπ hπp => (H c π hπ hπp).trans ha.le⟩\n#align has_integral_of_mul has_integral_of_mul\n\n",
 "has_integral_of_le_Henstock_of_forall_is_o":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `box_integral.box_additive_map -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `box_integral.box_additive_map -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℝⁿ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- A function `f` has Henstock (or `⊥`) integral over `I` is equal to the value of a box-additive\nfunction `g` on `I` provided that `vol J (f x)` is sufficiently close to `g J` for sufficiently\nsmall boxes `J ∋ x`. This lemma is useful to prove, e.g., to prove the Divergence theorem for\nintegral along `⊥`.\n\nLet `l` be either `box_integral.integration_params.Henstock` or `⊥`. Let `g` a box-additive function\non subboxes of `I`. Suppose that there exists a nonnegative box-additive function `B` and a\ncountable set `s` with the following property.\n\nFor every `c : ℝ≥0`, a point `x ∈ I.Icc`, and a positive `ε` there exists `δ > 0` such that for any\nbox `J ≤ I` such that\n\n- `x ∈ J.Icc ⊆ metric.closed_ball x δ`;\n- if `l.bDistortion` (i.e., `l = ⊥`), then the distortion of `J` is less than or equal to `c`,\n\nthe distance between the term `vol J (f x)` of an integral sum corresponding to `J` and `g J` is\nless than or equal to `ε` if `x ∈ s` and is less than or equal to `ε * B J` otherwise.\n\nThen `f` is integrable on `I along `l` with integral `g I`. -/\ntheorem has_integral_of_le_Henstock_of_forall_is_o (hl : l ≤ Henstock) (B : box_integral.box_additive_map ι I (exprℝ))\n    (hB0 : ∀ J, 0 ≤ B J) (g : box_integral.box_additive_map ι I F) (s : set («exprℝⁿ»)) (hs : s.countable)\n    (H₁ :\n      ∀ (c : nnreal),\n        ∀ x ∈ I.Icc ∩ s,\n          ∀ ε > (0 : exprℝ),\n            ∃ δ > 0,\n              ∀ J ≤ I,\n                J.Icc ⊆ metric.closed_ball x δ →\n                  x ∈ J.Icc → (l.bDistortion → J.distortion ≤ c) → dist (vol J (f x)) (g J) ≤ ε)\n    (H₂ :\n      ∀ (c : nnreal),\n        ∀ x ∈ I.Icc \\ s,\n          ∀ ε > (0 : exprℝ),\n            ∃ δ > 0,\n              ∀ J ≤ I,\n                J.Icc ⊆ metric.closed_ball x δ →\n                  x ∈ J.Icc → (l.bDistortion → J.distortion ≤ c) → dist (vol J (f x)) (g J) ≤ ε * B J) :\n    has_integral I l f vol (g I) :=\n  have A : l.bHenstock := hl.2.1.resolve_left (by decide)\n  has_integral_of_bRiemann_eq_ff_of_forall_is_o (hl.1.resolve_right (by decide)) B hB0 _ s hs (fun _ => A) H₁ <| by\n    simpa only [A, true_imp_iff] using H₂\n#align has_integral_of_le_Henstock_of_forall_is_o has_integral_of_le_Henstock_of_forall_is_o\n\n",
 "has_integral_of_bRiemann_eq_ff_of_forall_is_o":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℝⁿ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `box_integral.box_additive_map -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `box_integral.box_additive_map -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℝⁿ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- This is an auxiliary lemma used to prove two statements at once. Use one of the next two\nlemmas instead. -/\ntheorem has_integral_of_bRiemann_eq_ff_of_forall_is_o (hl : l.bRiemann = ff)\n    (B : box_integral.box_additive_map ι I (exprℝ)) (hB0 : ∀ J, 0 ≤ B J) (g : box_integral.box_additive_map ι I F)\n    (s : set («exprℝⁿ»)) (hs : s.countable) (hlH : s.nonempty → l.bHenstock = tt)\n    (H₁ :\n      ∀ (c : nnreal),\n        ∀ x ∈ I.Icc ∩ s,\n          ∀ ε > (0 : exprℝ),\n            ∃ δ > 0,\n              ∀ J ≤ I,\n                J.Icc ⊆ metric.closed_ball x δ →\n                  x ∈ J.Icc → (l.bDistortion → J.distortion ≤ c) → dist (vol J (f x)) (g J) ≤ ε)\n    (H₂ :\n      ∀ (c : nnreal),\n        ∀ x ∈ I.Icc \\ s,\n          ∀ ε > (0 : exprℝ),\n            ∃ δ > 0,\n              ∀ J ≤ I,\n                J.Icc ⊆ metric.closed_ball x δ →\n                  (l.bHenstock → x ∈ J.Icc) → (l.bDistortion → J.distortion ≤ c) → dist (vol J (f x)) (g J) ≤ ε * B J) :\n    has_integral I l f vol (g I) :=\n  by\n  /- We choose `r x` differently for `x ∈ s` and `x ∉ s`.\n  \n    For `x ∈ s`, we choose `εs` such that `∑' x : s, εs x < ε / 2 / 2 ^ #ι`, then choose `r x` so that\n    `dist (vol J (f x)) (g J) ≤ εs x` for `J` in the `r x`-neighborhood of `x`. This guarantees that\n    the sum of these distances over boxes `J` such that `π.tag J ∈ s` is less than `ε / 2`. We need an\n    additional multiplier `2 ^ #ι` because different boxes can have the same tag.\n  \n    For `x ∉ s`, we choose `r x` so that `dist (vol (J (f x))) (g J) ≤ (ε / 2 / B I) * B J` for a box\n    `J` in the `δ`-neighborhood of `x`. -/\n  refine' ((l.has_basis_to_filter_Union_top _).tendsto_iff metric.nhds_basis_closed_ball).2 _\n  intro ε ε0\n  simp only [subtype.exists'] at H₁ H₂\n  choose! δ₁ Hδ₁ using H₁\n  choose! δ₂ Hδ₂ using H₂\n  have ε0' := half_pos ε0\n  have H0 : 0 < (2 ^ fintype.card ι : exprℝ) := pow_pos zero_lt_two _\n  rcases hs.exists_pos_forall_sum_le (div_pos ε0' H0) with ⟨εs, hεs0, hεs⟩\n  simp only [le_div_iff' H0, mul_sum] at hεs\n  rcases exists_pos_mul_lt ε0' (B I) with ⟨ε', ε'0, hεI⟩\n  set δ : nnreal → «exprℝⁿ» → Ioi (0 : exprℝ) := fun c x => if x ∈ s then δ₁ c x (εs x) else (δ₂ c) x ε'\n  refine' ⟨δ, fun c => l.r_cond_of_bRiemann_eq_ff hl, _⟩\n  simp only [Set.mem_unionᵢ, mem_inter_iff, mem_set_of_eq]\n  rintro π ⟨c, hπδ, hπp⟩\n  -- Now we split the sum into two parts based on whether `π.tag J` belongs to `s` or not.\n  rw [← g.sum_partition_boxes le_rfl hπp, mem_closed_ball, integral_sum, ←\n    sum_filter_add_sum_filter_not π.boxes fun J => π.tag J ∈ s, ←\n    sum_filter_add_sum_filter_not π.boxes fun J => π.tag J ∈ s, ← add_halves ε]\n  refine' dist_add_add_le_of_le _ _\n  · rcases s.eq_empty_or_nonempty with (rfl | hsne)\n    · simp [ε0'.le]\n    /- For the boxes such that `π.tag J ∈ s`, we use the fact that at most `2 ^ #ι` boxes have the\n        same tag. -/\n    specialize hlH hsne\n    have : ∀ J ∈ π.boxes.filter fun J => π.tag J ∈ s, dist (vol J (f <| π.tag J)) (g J) ≤ εs (π.tag J) :=\n      by\n      intro J hJ\n      rw [Finset.mem_filter] at hJ\n      cases' hJ with hJ hJs\n      refine'\n        Hδ₁ c _ ⟨π.tag_mem_Icc _, hJs⟩ _ (hεs0 _) _ (π.le_of_mem' _ hJ) _ (hπδ.2 hlH J hJ) fun hD =>\n          (finset.le_sup hJ).trans (hπδ.3 hD)\n      convert hπδ.1 J hJ\n      exact (dif_pos hJs).symm\n    refine' (dist_sum_sum_le_of_le _ this).trans _\n    rw [sum_comp]\n    refine' (sum_le_sum _).trans (hεs _ _)\n    · rintro b -\n      rw [← Nat.cast_two, ← Nat.cast_pow, ← nsmul_eq_mul]\n      refine' nsmul_le_nsmul (hεs0 _).le _\n      refine' (finset.card_le_of_subset _).trans ((hπδ.is_Henstock hlH).card_filter_tag_eq_le b)\n      exact filter_subset_filter _ (filter_subset _ _)\n    · rw [Finset.coe_image, Set.image_subset_iff]\n      exact fun J hJ => (Finset.mem_filter.1 hJ).2\n  /- Now we deal with boxes such that `π.tag J ∉ s`.\n    In this case the estimate is straightforward. -/\n  have H₂ : ∀ J ∈ π.boxes.filter fun J => π.tag J ∉ s, dist (vol J (f <| π.tag J)) (g J) ≤ ε' * B J :=\n    by\n    intro J hJ\n    rw [Finset.mem_filter] at hJ\n    cases' hJ with hJ hJs\n    refine'\n      Hδ₂ c _ ⟨π.tag_mem_Icc _, hJs⟩ _ ε'0 _ (π.le_of_mem' _ hJ) _ (fun hH => hπδ.2 hH J hJ) fun hD =>\n        (finset.le_sup hJ).trans (hπδ.3 hD)\n    convert hπδ.1 J hJ\n    exact (dif_neg hJs).symm\n  refine' (dist_sum_sum_le_of_le _ H₂).trans ((sum_le_sum_of_subset_of_nonneg (filter_subset _ _) _).trans _)\n  · exact fun _ _ _ => mul_nonneg ε'0.le (hB0 _)\n  · rw [← mul_sum, B.sum_partition_boxes le_rfl hπp, mul_comm]\n    exact hεI.le\n#align has_integral_of_bRiemann_eq_ff_of_forall_is_o has_integral_of_bRiemann_eq_ff_of_forall_is_o\n\n",
 "has_integral_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℝⁿ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- The `ε`-`δ` definition of `box_integral.has_integral`. -/\ntheorem has_integral_iff :\n    has_integral I l f vol y ↔\n      ∀ ε > (0 : exprℝ),\n        ∃ r : nnreal → «exprℝⁿ» → Ioi (0 : exprℝ),\n          (∀ c, l.r_cond (r c)) ∧\n            ∀ c π, l.mem_base_set I c (r c) π → is_partition π → dist (integral_sum f vol π) y ≤ ε :=\n  ((l.has_basis_to_filter_Union_top I).tendsto_iff nhds_basis_closed_ball).trans <| by\n    simp [@forall_swap (nnreal) (tagged_prepartition I)]\n#align has_integral_iff has_integral_iff\n\n",
 "has_integral_const":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem has_integral_const (c : E) : has_integral I l (fun _ => c) vol (vol I c) :=\n  tendsto_const_nhds.congr' <|\n    (l.eventually_is_partition I).mono fun π hπ =>\n      ((vol.map ⟨fun g : «expr →L[ ] » E (exprℝ) F => g c, rfl, fun _ _ => rfl⟩).sum_partition_boxes le_top hπ).symm\n#align has_integral_const has_integral_const\n\n",
 "has_integral_McShane_of_forall_is_o":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `box_integral.box_additive_map -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `box_integral.box_additive_map -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- Suppose that there exists a nonnegative box-additive function `B` with the following property.\n\nFor every `c : ℝ≥0`, a point `x ∈ I.Icc`, and a positive `ε` there exists `δ > 0` such that for any\nbox `J ≤ I` such that\n\n- `J.Icc ⊆ metric.closed_ball x δ`;\n- if `l.bDistortion` (i.e., `l = ⊥`), then the distortion of `J` is less than or equal to `c`,\n\nthe distance between the term `vol J (f x)` of an integral sum corresponding to `J` and `g J` is\nless than or equal to `ε * B J`.\n\nThen `f` is McShane integrable on `I` with integral `g I`. -/\ntheorem has_integral_McShane_of_forall_is_o (B : box_integral.box_additive_map ι I (exprℝ)) (hB0 : ∀ J, 0 ≤ B J)\n    (g : box_integral.box_additive_map ι I F)\n    (H :\n      ∀ (c : nnreal),\n        ∀ x ∈ I.Icc,\n          ∀ ε > (0 : exprℝ), ∃ δ > 0, ∀ J ≤ I, J.Icc ⊆ metric.closed_ball x δ → dist (vol J (f x)) (g J) ≤ ε * B J) :\n    has_integral I McShane f vol (g I) :=\n  (has_integral_of_bRiemann_eq_ff_of_forall_is_o rfl B hB0 g ∅ countable_empty (fun ⟨x, hx⟩ => hx.elim) fun c x hx =>\n      hx.2.elim) <|\n    by simpa only [McShane, Bool.coe_sort_false, false_imp_iff, true_imp_iff, diff_empty] using H\n#align has_integral_McShane_of_forall_is_o has_integral_McShane_of_forall_is_o\n\n",
 "has_integral":
 "protected theorem integrable.has_integral (h : integrable I l f vol) : has_integral I l f vol (integral I l f vol) :=\n  by\n  rw [integral, dif_pos h]\n  exact Classical.choose_spec h\n#align integrable.has_integral integrable.has_integral\n\n",
 "dist_integral_sum_sum_integral_le_of_mem_base_set_of_Union_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/-- **Henstock-Sacks inequality**. Let `r : ℝⁿ → (0, ∞)` be a function such that for any tagged\n*partition* of `I` subordinate to `r`, the integral sum of `f` over this partition differs from the\nintegral of `f` by at most `ε`. Then for any tagged *prepartition* `π` subordinate to `r`, the\nintegral sum of `f` over this prepartition differs from the integral of `f` over the part of `I`\ncovered by `π` by at most `ε`.\n\nThe actual statement\n\n- uses `box_integral.integrable.convergence_r` instead of a predicate assumption on `r`;\n- uses `box_integral.integration_params.mem_base_set` instead of “subordinate to `r`” to\n  account for additional requirements like being a Henstock partition or having a bounded\n  distortion;\n- takes an extra argument `π₀ : prepartition I` and an assumption `π.Union = π₀.Union` instead of\n  using `π.to_prepartition`.\n-/\ntheorem dist_integral_sum_sum_integral_le_of_mem_base_set_of_Union_eq (h : integrable I l f vol) (h0 : 0 < ε)\n    (hπ : l.mem_base_set I c (h.convergence_r ε c) π) {π₀ : prepartition I} (hU : π.Union = π₀.Union) :\n    dist (integral_sum f vol π)\n        (finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" π₀.boxes\n          (integral J l f vol)) ≤\n      ε :=\n  by\n  -- Let us prove that the distance is less than or equal to `ε + δ` for all positive `δ`.\n  refine' le_of_forall_pos_le_add fun δ δ0 => _\n  -- First we choose some constants.\n  set δ' : exprℝ := δ / (π₀.boxes.card + 1)\n  have H0 : 0 < (π₀.boxes.card + 1 : exprℝ) := nat.cast_add_one_pos _\n  have δ'0 : 0 < δ' := div_pos δ0 H0\n  set C := max π₀.distortion π₀.compl.distortion\n  /- Next we choose a tagged partition of each `J ∈ π₀` such that the integral sum of `f` over this\n    partition is `δ'`-close to the integral of `f` over `J`. -/\n  have :\n    ∀ J ∈ π₀,\n      ∃ πi : tagged_prepartition J,\n        πi.is_partition ∧\n          dist (integral_sum f vol πi) (integral J l f vol) ≤ δ' ∧ l.mem_base_set J C (h.convergence_r δ' C) πi :=\n    by\n    intro J hJ\n    have Hle : J ≤ I := π₀.le_of_mem hJ\n    have HJi : integrable J l f vol := h.to_subbox Hle\n    set r := fun x => min (h.convergence_r δ' C x) (HJi.convergence_r δ' C x)\n    have hr : l.r_cond r := (h.convergence_r_cond _ C).min (HJi.convergence_r_cond _ C)\n    have hJd : J.distortion ≤ C := le_trans (finset.le_sup hJ) (le_max_left _ _)\n    rcases l.exists_mem_base_set_is_partition J hJd r with ⟨πJ, hC, hp⟩\n    have hC₁ : l.mem_base_set J C (HJi.convergence_r δ' C) πJ :=\n      by\n      refine' hC.mono J le_rfl le_rfl fun x hx => _\n      exact min_le_right _ _\n    have hC₂ : l.mem_base_set J C (h.convergence_r δ' C) πJ :=\n      by\n      refine' hC.mono J le_rfl le_rfl fun x hx => _\n      exact min_le_left _ _\n    exact ⟨πJ, hp, HJi.dist_integral_sum_integral_le_of_mem_base_set δ'0 hC₁ hp, hC₂⟩\n  /- Now we combine these tagged partitions into a tagged prepartition of `I` that covers the\n    same part of `I` as `π₀` and apply `box_integral.dist_integral_sum_le_of_mem_base_set` to\n    `π` and this prepartition. -/\n  choose! πi hπip hπiδ' hπiC\n  have : l.mem_base_set I C (h.convergence_r δ' C) (π₀.bUnion_tagged πi) :=\n    bUnion_tagged_mem_base_set hπiC hπip fun _ => le_max_right _ _\n  have hU' : π.Union = (π₀.bUnion_tagged πi).Union := hU.trans (prepartition.Union_bUnion_partition _ hπip).symm\n  have := h.dist_integral_sum_le_of_mem_base_set h0 δ'0 hπ this hU'\n  rw [integral_sum_bUnion_tagged] at this\n  calc\n    dist (integral_sum f vol π)\n          (finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" π₀.boxes\n            (integral J l f vol)) ≤\n        dist (integral_sum f vol π)\n            (finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" π₀.boxes\n              (integral_sum f vol (πi J))) +\n          dist\n            (finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" π₀.boxes\n              (integral_sum f vol (πi J)))\n            (finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" π₀.boxes\n              (integral J l f vol)) :=\n      dist_triangle _ _ _\n    _ ≤\n        ε + δ' +\n          finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" π₀.boxes δ' :=\n      add_le_add this (dist_sum_sum_le_of_le _ hπiδ')\n    _ = ε + δ := by\n      field_simp [H0.ne']\n      ring\n    \n#align\n  dist_integral_sum_sum_integral_le_of_mem_base_set_of_Union_eq dist_integral_sum_sum_integral_le_of_mem_base_set_of_Union_eq\n\n",
 "dist_integral_sum_sum_integral_le_of_mem_base_set":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/-- **Henstock-Sacks inequality**. Let `r : ℝⁿ → (0, ∞)` be a function such that for any tagged\n*partition* of `I` subordinate to `r`, the integral sum of `f` over this partition differs from the\nintegral of `f` by at most `ε`. Then for any tagged *prepartition* `π` subordinate to `r`, the\nintegral sum of `f` over this prepartition differs from the integral of `f` over the part of `I`\ncovered by `π` by at most `ε`.\n\nThe actual statement\n\n- uses `box_integral.integrable.convergence_r` instead of a predicate assumption on `r`;\n- uses `box_integral.integration_params.mem_base_set` instead of “subordinate to `r`” to\n  account for additional requirements like being a Henstock partition or having a bounded\n  distortion;\n-/\ntheorem dist_integral_sum_sum_integral_le_of_mem_base_set (h : integrable I l f vol) (h0 : 0 < ε)\n    (hπ : l.mem_base_set I c (h.convergence_r ε c) π) :\n    dist (integral_sum f vol π)\n        (finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" π.boxes\n          (integral J l f vol)) ≤\n      ε :=\n  h.dist_integral_sum_sum_integral_le_of_mem_base_set_of_Union_eq h0 hπ rfl\n#align dist_integral_sum_sum_integral_le_of_mem_base_set dist_integral_sum_sum_integral_le_of_mem_base_set\n\n",
 "dist_integral_sum_le_of_mem_base_set":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℝⁿ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- **Henstock-Sacks inequality**. Let `r₁ r₂ : ℝⁿ → (0, ∞)` be function such that for any tagged\n*partition* of `I` subordinate to `rₖ`, `k=1,2`, the integral sum of `f` over this partition differs\nfrom the integral of `f` by at most `εₖ`. Then for any two tagged *prepartition* `π₁ π₂` subordinate\nto `r₁` and `r₂` respectively and covering the same part of `I`, the integral sums of `f` over these\nprepartitions differ from each other by at most `ε₁ + ε₂`.\n\nThe actual statement\n\n- uses `box_integral.integrable.convergence_r` instead of a predicate assumption on `r`;\n- uses `box_integral.integration_params.mem_base_set` instead of “subordinate to `r`” to\n  account for additional requirements like being a Henstock partition or having a bounded\n  distortion.\n\nSee also `box_integral.integrable.dist_integral_sum_sum_integral_le_of_mem_base_set_of_Union_eq` and\n`box_integral.integrable.dist_integral_sum_sum_integral_le_of_mem_base_set`.\n-/\ntheorem dist_integral_sum_le_of_mem_base_set (h : integrable I l f vol) (hpos₁ : 0 < ε₁) (hpos₂ : 0 < ε₂)\n    (h₁ : l.mem_base_set I c₁ (h.convergence_r ε₁ c₁) π₁) (h₂ : l.mem_base_set I c₂ (h.convergence_r ε₂ c₂) π₂)\n    (HU : π₁.Union = π₂.Union) : dist (integral_sum f vol π₁) (integral_sum f vol π₂) ≤ ε₁ + ε₂ :=\n  by\n  rcases h₁.exists_common_compl h₂ HU with ⟨π, hπU, hπc₁, hπc₂⟩\n  set r : «exprℝⁿ» → Ioi (0 : exprℝ) := fun x => min (h.convergence_r ε₁ c₁ x) (h.convergence_r ε₂ c₂ x)\n  have hr : l.r_cond r := (h.convergence_r_cond _ c₁).min (h.convergence_r_cond _ c₂)\n  set πr := π.to_subordinate r\n  have H₁ : dist (integral_sum f vol (π₁.union_compl_to_subordinate π hπU r)) (integral I l f vol) ≤ ε₁ :=\n    h.dist_integral_sum_integral_le_of_mem_base_set hpos₁\n      (h₁.union_compl_to_subordinate (fun _ _ => min_le_left _ _) hπU hπc₁)\n      (is_partition_union_compl_to_subordinate _ _ _ _)\n  rw [HU] at hπU\n  have H₂ : dist (integral_sum f vol (π₂.union_compl_to_subordinate π hπU r)) (integral I l f vol) ≤ ε₂ :=\n    h.dist_integral_sum_integral_le_of_mem_base_set hpos₂\n      (h₂.union_compl_to_subordinate (fun _ _ => min_le_right _ _) hπU hπc₂)\n      (is_partition_union_compl_to_subordinate _ _ _ _)\n  simpa [union_compl_to_subordinate] using (dist_triangle_right _ _ _).trans (add_le_add H₁ H₂)\n#align dist_integral_sum_le_of_mem_base_set dist_integral_sum_le_of_mem_base_set\n\n",
 "dist_integral_sum_integral_le_of_mem_base_set":
 "theorem dist_integral_sum_integral_le_of_mem_base_set (h : integrable I l f vol) (h₀ : 0 < ε)\n    (hπ : l.mem_base_set I c (h.convergence_r ε c) π) (hπp : π.is_partition) :\n    dist (integral_sum f vol π) (integral I l f vol) ≤ ε :=\n  by\n  rw [convergence_r, dif_pos h₀] at hπ\n  exact (has_integral_iff.1 h.has_integral ε h₀).some_spec.2 c _ hπ hπp\n#align dist_integral_sum_integral_le_of_mem_base_set dist_integral_sum_integral_le_of_mem_base_set\n\n",
 "convergence_r_cond":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\ntheorem convergence_r_cond (h : integrable I l f vol) (ε : exprℝ) (c : nnreal) : l.r_cond (h.convergence_r ε c) :=\n  by\n  rw [convergence_r]; split_ifs with h₀\n  exacts[(has_integral_iff.1 h.has_integral ε h₀).some_spec.1 _, fun _ x => rfl]\n#align convergence_r_cond convergence_r_cond\n\n",
 "cauchy_map_integral_sum_to_filter_Union":
 "/-- If `f` is integrable on a box `I` along `l`, then for any fixed subset `s` of `I` that can be\nrepresented as a finite union of boxes, the integral sums of `f` over tagged prepartitions that\ncover exactly `s` form a Cauchy “sequence” along `l`. -/\ntheorem cauchy_map_integral_sum_to_filter_Union (h : integrable I l f vol) (π₀ : prepartition I) :\n    cauchy ((l.to_filter_Union I π₀).map (integral_sum f vol)) :=\n  by\n  refine' ⟨infer_instance, _⟩\n  rw [prod_map_map_eq, ← to_filter_inf_Union_eq, ← prod_inf_prod, prod_principal_principal]\n  exact\n    h.tendsto_integral_sum_to_filter_prod_self_inf_Union_eq_uniformity.mono_left\n      (inf_le_inf_left _ <| principal_mono.2 fun π h => h.1.trans h.2.symm)\n#align cauchy_map_integral_sum_to_filter_Union cauchy_map_integral_sum_to_filter_Union\n\n",
 "add":
 "theorem integrable.add (hf : integrable I l f vol) (hg : integrable I l g vol) : integrable I l (f + g) vol :=\n  (hf.has_integral.add hg.has_integral).integrable\n#align integrable.add integrable.add\n\n"}