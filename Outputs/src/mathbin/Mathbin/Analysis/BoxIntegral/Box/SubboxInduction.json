{"upper_sub_lower_split_center_box":
 "@[simp]\ntheorem upper_sub_lower_split_center_box (I : box ι) (s : set ι) (i : ι) :\n    (I.split_center_box s).upper i - (I.split_center_box s).lower i = (I.upper i - I.lower i) / 2 := by\n  by_cases hs : i ∈ s <;> field_simp [split_center_box, hs, mul_two, two_mul]\n#align upper_sub_lower_split_center_box upper_sub_lower_split_center_box\n\n",
 "subbox_induction_on'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/-- Let `p` be a predicate on `box ι`, let `I` be a box. Suppose that the following two properties\nhold true.\n\n* `H_ind` : Consider a smaller box `J ≤ I`. The hyperplanes passing through the center of `J` split\n  it into `2 ^ n` boxes. If `p` holds true on each of these boxes, then it true on `J`.\n\n* `H_nhds` : For each `z` in the closed box `I.Icc` there exists a neighborhood `U` of `z` within\n  `I.Icc` such that for every box `J ≤ I` such that `z ∈ J.Icc ⊆ U`, if `J` is homothetic to `I`\n  with a coefficient of the form `1 / 2 ^ m`, then `p` is true on `J`.\n\nThen `p I` is true. See also `box_integral.box.subbox_induction_on` for a version using\n`box_integral.prepartition.split_center` instead of `box_integral.box.split_center_box`.\n\nThe proof still works if we assume `H_ind` only for subboxes `J ≤ I` that are homothetic to `I` with\na coefficient of the form `2⁻ᵐ` but we do not need this generalization yet. -/\n@[elab_as_elim]\ntheorem subbox_induction_on' {p : box ι → Prop} (I : box ι) (H_ind : ∀ J ≤ I, (∀ s, p (split_center_box J s)) → p J)\n    (H_nhds :\n      ∀ z ∈ I.Icc,\n        ∃ U ∈ nhds_within I.Icc z,\n          ∀ J ≤ I,\n            ∀ (m : ℕ), z ∈ J.Icc → J.Icc ⊆ U → (∀ i, J.upper i - J.lower i = (I.upper i - I.lower i) / 2 ^ m) → p J) :\n    p I := by\n  by_contra hpI\n  -- First we use `H_ind` to construct a decreasing sequence of boxes such that `∀ m, ¬p (J m)`.\n  replace H_ind := fun J hJ => not_imp_not.2 (H_ind J hJ)\n  simp only [exists_imp, not_forall] at H_ind\n  choose! s hs using H_ind\n  set J : ℕ → box ι := fun m => («expr ^[ ]» (fun J => split_center_box J (s J)) m) I\n  have J_succ : ∀ m, J (m + 1) = split_center_box (J m) (s <| J m) := fun m => iterate_succ_apply' _ _ _\n  -- Now we prove some properties of `J`\n  have hJmono : antitone J := antitone_nat_of_succ_le fun n => by simpa [J_succ] using split_center_box_le _ _\n  have hJle : ∀ m, J m ≤ I := fun m => hJmono (zero_le m)\n  have hJp : ∀ m, ¬p (J m) := fun m => nat.rec_on m hpI fun m => by simpa only [J_succ] using hs (J m) (hJle m)\n  have hJsub : ∀ m i, (J m).upper i - (J m).lower i = (I.upper i - I.lower i) / 2 ^ m :=\n    by\n    intro m i\n    induction' m with m ihm\n    · simp [J]\n    simp only [pow_succ', J_succ, upper_sub_lower_split_center_box, ihm, div_div]\n  have h0 : J 0 = I := rfl\n  -- Now we clear unneeded assumptions\n  clear_value J\n  clear hpI hs J_succ s\n  -- Let `z` be the unique common point of all `(J m).Icc`. Then `H_nhds` proves `p (J m)` for\n  -- sufficiently large `m`. This contradicts `hJp`.\n  set z : ι → exprℝ :=\n    «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (J m).lower\n  have hzJ : ∀ m, z ∈ (J m).Icc :=\n    mem_Inter.1\n      (csupᵢ_mem_Inter_Icc_of_antitone_Icc ((@box.Icc ι).monotone.comp_antitone hJmono) fun m => (J m).lower_le_upper)\n  have hJl_mem : ∀ m, (J m).lower ∈ I.Icc := fun m => le_iff_Icc.1 (hJle m) (J m).lower_mem_Icc\n  have hJu_mem : ∀ m, (J m).upper ∈ I.Icc := fun m => le_iff_Icc.1 (hJle m) (J m).upper_mem_Icc\n  have hJlz : tendsto (fun m => (J m).lower) at_top ((nhds) z) :=\n    tendsto_at_top_csupr (antitone_lower.comp hJmono) ⟨I.upper, fun x ⟨m, hm⟩ => hm ▸ (hJl_mem m).2⟩\n  have hJuz : tendsto (fun m => (J m).upper) at_top ((nhds) z) :=\n    by\n    suffices tendsto (fun m => (J m).upper - (J m).lower) at_top ((nhds) 0) by simpa using hJlz.add this\n    refine' tendsto_pi_nhds.2 fun i => _\n    simpa [hJsub] using tendsto_const_nhds.div_at_top (tendsto_pow_at_top_at_top_of_one_lt one_lt_two)\n  replace hJlz : tendsto (fun m => (J m).lower) at_top (nhds_within (Icc I.lower I.upper) z)\n  exact tendsto_nhds_within_of_tendsto_nhds_of_eventually_within _ hJlz (eventually_of_forall hJl_mem)\n  replace hJuz : tendsto (fun m => (J m).upper) at_top (nhds_within (Icc I.lower I.upper) z)\n  exact tendsto_nhds_within_of_tendsto_nhds_of_eventually_within _ hJuz (eventually_of_forall hJu_mem)\n  rcases H_nhds z (h0 ▸ hzJ 0) with ⟨U, hUz, hU⟩\n  rcases(tendsto_lift'.1 (hJlz.Icc hJuz) U hUz).exists with ⟨m, hUm⟩\n  exact hJp m (hU (J m) (hJle m) m (hzJ m) hUm (hJsub m))\n#align subbox_induction_on' subbox_induction_on'\n\n",
 "split_center_box_le":
 "theorem split_center_box_le (I : box ι) (s : set ι) : I.split_center_box s ≤ I := fun x hx =>\n  (mem_split_center_box.1 hx).1\n#align split_center_box_le split_center_box_le\n\n",
 "mem_split_center_box":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-\nCopyright (c) 2021 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-/\ntheorem mem_split_center_box {s : set ι} {y : ι → exprℝ} :\n    y ∈ I.split_center_box s ↔ y ∈ I ∧ ∀ i, (I.lower i + I.upper i) / 2 < y i ↔ i ∈ s :=\n  by\n  simp only [split_center_box, mem_def, ← forall_and]\n  refine' forall_congr' fun i => _\n  dsimp only [set.piecewise]\n  split_ifs with hs <;> simp only [hs, iff_true_iff, iff_false_iff, not_lt]\n  exacts[⟨fun H => ⟨⟨(left_lt_add_div_two.2 (I.lower_lt_upper i)).trans H.1, H.2⟩, H.1⟩, fun H => ⟨H.2, H.1.2⟩⟩,\n    ⟨fun H => ⟨⟨H.1, H.2.trans (add_div_two_lt_right.2 (I.lower_lt_upper i)).le⟩, H.2⟩, fun H => ⟨H.1.1, H.2⟩⟩]\n#align mem_split_center_box mem_split_center_box\n\n",
 "injective_split_center_box":
 "theorem injective_split_center_box (I : box ι) : injective I.split_center_box := fun s t H =>\n  by_contra fun Hne => (I.disjoint_split_center_box Hne).ne (nonempty_coe _).ne_empty (H ▸ rfl)\n#align injective_split_center_box injective_split_center_box\n\n",
 "exists_mem_split_center_box":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n@[simp]\ntheorem exists_mem_split_center_box {I : box ι} {x : ι → exprℝ} : (∃ s, x ∈ I.split_center_box s) ↔ x ∈ I :=\n  ⟨fun ⟨s, hs⟩ => I.split_center_box_le s hs, fun hx =>\n    ⟨{ i | (I.lower i + I.upper i) / 2 < x i }, mem_split_center_box.2 ⟨hx, fun i => iff.rfl⟩⟩⟩\n#align exists_mem_split_center_box exists_mem_split_center_box\n\n",
 "disjoint_split_center_box":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem disjoint_split_center_box (I : box ι) {s t : set ι} (h : s ≠ t) :\n    Disjoint (I.split_center_box s : set (ι → exprℝ)) (I.split_center_box t) :=\n  by\n  rw [disjoint_iff_inf_le]\n  rintro y ⟨hs, ht⟩; apply h\n  ext i\n  rw [mem_coe, mem_split_center_box] at hs ht\n  rw [← hs.2, ← ht.2]\n#align disjoint_split_center_box disjoint_split_center_box\n\n",
 "Union_coe_split_center_box":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n@[simp]\ntheorem Union_coe_split_center_box (I : box ι) :\n    «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n        (I.split_center_box s : set (ι → exprℝ)) =\n      I :=\n  by\n  ext x\n  simp\n#align Union_coe_split_center_box Union_coe_split_center_box\n\n"}