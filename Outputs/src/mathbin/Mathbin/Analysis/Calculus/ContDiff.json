{"zero_eq'":
 "theorem has_ftaylor_series_up_to.zero_eq' (h : has_ftaylor_series_up_to n f p) (x : E) :\n    p x 0 = (continuous_multilinear_curry_fin0 ğ•œ E F).symm (f x) :=\n  by\n  rw [â† h.zero_eq x]\n  symm\n  exact continuous_multilinear_map.uncurry0_curry0 _\n#align has_ftaylor_series_up_to.zero_eq' has_ftaylor_series_up_to.zero_eq'\n\n",
 "sum":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem cont_diff.sum {Î¹ : Type _} {f : Î¹ â†’ E â†’ F} {s : Finset Î¹} (h : âˆ€ i âˆˆ s, cont_diff ğ•œ n fun x => f i x) :\n    cont_diff ğ•œ n fun x =>\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s (f i x) :=\n  by simp only [â† cont_diff_on_univ] at * <;> exact cont_diff_on.sum h\n#align cont_diff.sum cont_diff.sum\n\n",
 "sub":
 "/-- The difference of two `C^n` functions is `C^n`. -/\ntheorem cont_diff.sub {f g : E â†’ F} (hf : cont_diff ğ•œ n f) (hg : cont_diff ğ•œ n g) : cont_diff ğ•œ n fun x => f x - g x :=\n  by simpa only [sub_eq_add_neg] using hf.add hg.neg\n#align cont_diff.sub cont_diff.sub\n\n",
 "snd''":
 "/-- Precomposing `f` with `prod.snd` is `C^n` at `x : E Ã— F` -/\ntheorem cont_diff_at.snd'' {f : F â†’ G} {x : E Ã— F} (hf : cont_diff_at ğ•œ n f x.2) :\n    cont_diff_at ğ•œ n (fun x : E Ã— F => f x.2) x :=\n  hf.comp x cont_diff_at_snd\n#align cont_diff_at.snd'' cont_diff_at.snd''\n\n",
 "snd'":
 "/-- Precomposing `f` with `prod.snd` is `C^n` at `(x, y)` -/\ntheorem cont_diff_at.snd' {f : F â†’ G} {x : E} {y : F} (hf : cont_diff_at ğ•œ n f y) :\n    cont_diff_at ğ•œ n (fun x : E Ã— F => f x.2) (x, y) :=\n  cont_diff_at.comp (x, y) hf cont_diff_at_snd\n#align cont_diff_at.snd' cont_diff_at.snd'\n\n",
 "snd":
 "/-- Postcomposing `f` with `prod.snd` is `C^n` at `x` -/\ntheorem cont_diff_at.snd {f : E â†’ F Ã— G} {x : E} (hf : cont_diff_at ğ•œ n f x) : cont_diff_at ğ•œ n (fun x => (f x).2) x :=\n  cont_diff_at_snd.comp x hf\n#align cont_diff_at.snd cont_diff_at.snd\n\n",
 "smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/-- The scalar multiplication of two `C^n` functions on a domain is `C^n`. -/\ntheorem cont_diff_on.smul {s : set E} {f : E â†’ ğ•œ} {g : E â†’ F} (hf : cont_diff_on ğ•œ n f s) (hg : cont_diff_on ğ•œ n g s) :\n    cont_diff_on ğ•œ n (fun x => Â«expr â€¢ Â» (f x) (g x)) s := fun x hx => (hf x hx).smul (hg x hx)\n#align cont_diff_on.smul cont_diff_on.smul\n\n",
 "restrict_scalars":
 "theorem cont_diff.restrict_scalars (h : cont_diff ğ•œ' n f) : cont_diff ğ•œ n f :=\n  cont_diff_iff_cont_diff_at.2 fun x => h.cont_diff_at.restrict_scalars _\n#align cont_diff.restrict_scalars cont_diff.restrict_scalars\n\n",
 "prod_map'":
 "/-- The product map of two `C^n` functions within a set at a point is `C^n`\nwithin the product set at the product point. -/\ntheorem cont_diff_at.prod_map' {f : E â†’ F} {g : E' â†’ F'} {p : E Ã— E'} (hf : cont_diff_at ğ•œ n f p.1)\n    (hg : cont_diff_at ğ•œ n g p.2) : cont_diff_at ğ•œ n (prod.map f g) p :=\n  by\n  rcases p with âŸ¨âŸ©\n  exact cont_diff_at.prod_map hf hg\n#align cont_diff_at.prod_map' cont_diff_at.prod_map'\n\n",
 "prod_map":
 "/-- The product map of two `C^n` functions is `C^n`. -/\ntheorem cont_diff.prod_map {f : E â†’ F} {g : E' â†’ F'} (hf : cont_diff ğ•œ n f) (hg : cont_diff ğ•œ n g) :\n    cont_diff ğ•œ n (prod.map f g) := by\n  rw [cont_diff_iff_cont_diff_at] at *\n  exact fun âŸ¨x, yâŸ© => (hf x).prod_map (hg y)\n#align cont_diff.prod_map cont_diff.prod_map\n\n",
 "prod":
 "/-- The cartesian product of `C^n` functions is `C^n`.-/\ntheorem cont_diff.prod {f : E â†’ F} {g : E â†’ G} (hf : cont_diff ğ•œ n f) (hg : cont_diff ğ•œ n g) :\n    cont_diff ğ•œ n fun x : E => (f x, g x) :=\n  cont_diff_on_univ.1 <| cont_diff_on.prod (cont_diff_on_univ.2 hf) (cont_diff_on_univ.2 hg)\n#align cont_diff.prod cont_diff.prod\n\n",
 "pow":
 "theorem cont_diff_on.pow {f : E â†’ ğ”¸} (hf : cont_diff_on ğ•œ n f s) (m : â„•) : cont_diff_on ğ•œ n (fun y => f y ^ m) s :=\n  fun y hy => (hf y hy).pow m\n#align cont_diff_on.pow cont_diff_on.pow\n\n",
 "one_of_succ":
 "theorem cont_diff.one_of_succ {n : â„•} (h : cont_diff ğ•œ (n + 1) f) : cont_diff ğ•œ 1 f :=\n  h.of_le <| WithTop.coe_le_coe.mpr le_add_self\n#align cont_diff.one_of_succ cont_diff.one_of_succ\n\n",
 "of_succ":
 "theorem cont_diff.of_succ {n : â„•} (h : cont_diff ğ•œ (n + 1) f) : cont_diff ğ•œ n f :=\n  h.of_le <| WithTop.coe_le_coe.mpr le_self_add\n#align cont_diff.of_succ cont_diff.of_succ\n\n",
 "of_le":
 "theorem cont_diff.of_le (h : cont_diff ğ•œ n f) (hmn : m â‰¤ n) : cont_diff ğ•œ m f :=\n  cont_diff_on_univ.1 <| (cont_diff_on_univ.2 h).of_le hmn\n#align cont_diff.of_le cont_diff.of_le\n\n",
 "norm_iterated_fderiv_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\ntheorem norm_iterated_fderiv_zero : Â«exprâ€– â€–Â» (iterated_fderiv ğ•œ 0 f x) = Â«exprâ€– â€–Â» (f x) := by\n  rw [iterated_fderiv_zero_eq_comp, linear_isometry_equiv.norm_map]\n#align norm_iterated_fderiv_zero norm_iterated_fderiv_zero\n\n",
 "norm_iterated_fderiv_within_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\ntheorem norm_iterated_fderiv_within_zero : Â«exprâ€– â€–Â» (iterated_fderiv_within ğ•œ 0 f s x) = Â«exprâ€– â€–Â» (f x) := by\n  rw [iterated_fderiv_within_zero_eq_comp, linear_isometry_equiv.norm_map]\n#align norm_iterated_fderiv_within_zero norm_iterated_fderiv_within_zero\n\n",
 "norm_iterated_fderiv_within_fderiv_within":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\ntheorem norm_iterated_fderiv_within_fderiv_within {n : â„•} (hs : unique_diff_on ğ•œ s) (hx : x âˆˆ s) :\n    Â«exprâ€– â€–Â» (iterated_fderiv_within ğ•œ n (fderiv_within ğ•œ f s) s x) =\n      Â«exprâ€– â€–Â» (iterated_fderiv_within ğ•œ (n + 1) f s x) :=\n  by rw [iterated_fderiv_within_succ_eq_comp_right hs hx, linear_isometry_equiv.norm_map]\n#align norm_iterated_fderiv_within_fderiv_within norm_iterated_fderiv_within_fderiv_within\n\n",
 "norm_iterated_fderiv_fderiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\ntheorem norm_iterated_fderiv_fderiv {n : â„•} :\n    Â«exprâ€– â€–Â» (iterated_fderiv ğ•œ n (fderiv ğ•œ f) x) = Â«exprâ€– â€–Â» (iterated_fderiv ğ•œ (n + 1) f x) := by\n  rw [iterated_fderiv_succ_eq_comp_right, linear_isometry_equiv.norm_map]\n#align norm_iterated_fderiv_fderiv norm_iterated_fderiv_fderiv\n\n",
 "norm_fderiv_within_iterated_fderiv_within":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\ntheorem norm_fderiv_within_iterated_fderiv_within {n : â„•} :\n    Â«exprâ€– â€–Â» (fderiv_within ğ•œ (iterated_fderiv_within ğ•œ n f s) s x) =\n      Â«exprâ€– â€–Â» (iterated_fderiv_within ğ•œ (n + 1) f s x) :=\n  by rw [iterated_fderiv_within_succ_eq_comp_left, linear_isometry_equiv.norm_map]\n#align norm_fderiv_within_iterated_fderiv_within norm_fderiv_within_iterated_fderiv_within\n\n",
 "norm_fderiv_iterated_fderiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\ntheorem norm_fderiv_iterated_fderiv {n : â„•} :\n    Â«exprâ€– â€–Â» (fderiv ğ•œ (iterated_fderiv ğ•œ n f) x) = Â«exprâ€– â€–Â» (iterated_fderiv ğ•œ (n + 1) f x) := by\n  rw [iterated_fderiv_succ_eq_comp_left, linear_isometry_equiv.norm_map]\n#align norm_fderiv_iterated_fderiv norm_fderiv_iterated_fderiv\n\n",
 "neg":
 "/-- The negative of a `C^n` function on a domain is `C^n`. -/\ntheorem cont_diff_on.neg {s : set E} {f : E â†’ F} (hf : cont_diff_on ğ•œ n f s) : cont_diff_on ğ•œ n (fun x => -f x) s :=\n  fun x hx => (hf x hx).neg\n#align cont_diff_on.neg cont_diff_on.neg\n\n",
 "mul":
 "/-- The product of two `C^n`functions is `C^n`. -/\ntheorem cont_diff.mul {f g : E â†’ ğ”¸} (hf : cont_diff ğ•œ n f) (hg : cont_diff ğ•œ n g) : cont_diff ğ•œ n fun x => f x * g x :=\n  cont_diff_mul.comp (hf.prod hg)\n#align cont_diff.mul cont_diff.mul\n\n",
 "mono_of_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\ntheorem cont_diff_within_at.mono_of_mem (h : cont_diff_within_at ğ•œ n f s x) {t : set E} (hst : s âˆˆ nhds_within t x) :\n    cont_diff_within_at ğ•œ n f t x := by\n  intro m hm\n  rcases h m hm with âŸ¨u, hu, p, HâŸ©\n  exact âŸ¨u, nhds_within_le_of_mem (insert_mem_nhds_within_insert hst) hu, p, HâŸ©\n#align cont_diff_within_at.mono_of_mem cont_diff_within_at.mono_of_mem\n\n",
 "mono":
 "theorem cont_diff_on.mono (h : cont_diff_on ğ•œ n f s) {t : set E} (hst : t âŠ† s) : cont_diff_on ğ•œ n f t := fun x hx =>\n  (h x (hst hx)).mono hst\n#align cont_diff_on.mono cont_diff_on.mono\n\n",
 "iterated_fderiv_zero_fun":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr [Ã— ]â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr [Ã— ]â†’L[ ] Â» -/\n@[simp]\ntheorem iterated_fderiv_zero_fun {n : â„•} : (iterated_fderiv ğ•œ n fun x : E => (0 : F)) = 0 :=\n  by\n  induction' n with n IH\n  Â· ext m\n    simp\n  Â· ext (x m)\n    rw [iterated_fderiv_succ_apply_left, IH]\n    change\n      (fderiv ğ•œ (fun x : E => (0 : Â«expr [Ã— ]â†’L[ ] Â» E n ğ•œ F)) x : E â†’ Â«expr [Ã— ]â†’L[ ] Â» E n ğ•œ F) (m 0) (tail m) = _\n    rw [fderiv_const]\n    rfl\n#align iterated_fderiv_zero_fun iterated_fderiv_zero_fun\n\n",
 "iterated_fderiv_zero_eq_comp":
 "theorem iterated_fderiv_zero_eq_comp : iterated_fderiv ğ•œ 0 f = (continuous_multilinear_curry_fin0 ğ•œ E F).symm âˆ˜ f :=\n  rfl\n#align iterated_fderiv_zero_eq_comp iterated_fderiv_zero_eq_comp\n\n",
 "iterated_fderiv_zero_apply":
 "@[simp]\ntheorem iterated_fderiv_zero_apply (m : fin 0 â†’ E) : (iterated_fderiv ğ•œ 0 f x : (fin 0 â†’ E) â†’ F) m = f x :=\n  rfl\n#align iterated_fderiv_zero_apply iterated_fderiv_zero_apply\n\n",
 "iterated_fderiv_within_zero_eq_comp":
 "theorem iterated_fderiv_within_zero_eq_comp :\n    iterated_fderiv_within ğ•œ 0 f s = (continuous_multilinear_curry_fin0 ğ•œ E F).symm âˆ˜ f :=\n  rfl\n#align iterated_fderiv_within_zero_eq_comp iterated_fderiv_within_zero_eq_comp\n\n",
 "iterated_fderiv_within_zero_apply":
 "@[simp]\ntheorem iterated_fderiv_within_zero_apply (m : fin 0 â†’ E) :\n    (iterated_fderiv_within ğ•œ 0 f s x : (fin 0 â†’ E) â†’ F) m = f x :=\n  rfl\n#align iterated_fderiv_within_zero_apply iterated_fderiv_within_zero_apply\n\n",
 "iterated_fderiv_within_univ":
 "theorem iterated_fderiv_within_univ {n : â„•} : iterated_fderiv_within ğ•œ n f univ = iterated_fderiv ğ•œ n f :=\n  by\n  induction' n with n IH\n  Â· ext x\n    simp\n  Â· ext (x m)\n    rw [iterated_fderiv_succ_apply_left, iterated_fderiv_within_succ_apply_left, IH, fderiv_within_univ]\n#align iterated_fderiv_within_univ iterated_fderiv_within_univ\n\n",
 "iterated_fderiv_within_succ_eq_comp_right":
 "/-- Writing explicitly the `n+1`-th derivative as the composition of a currying linear equiv,\nand the `n`-th derivative of the derivative. -/\ntheorem iterated_fderiv_within_succ_eq_comp_right {n : â„•} (hs : unique_diff_on ğ•œ s) (hx : x âˆˆ s) :\n    iterated_fderiv_within ğ•œ (n + 1) f s x =\n      (continuous_multilinear_curry_right_equiv' ğ•œ n E F âˆ˜\n          iterated_fderiv_within ğ•œ n (fun y => fderiv_within ğ•œ f s y) s)\n        x :=\n  by\n  ext m\n  rw [iterated_fderiv_within_succ_apply_right hs hx]\n  rfl\n#align iterated_fderiv_within_succ_eq_comp_right iterated_fderiv_within_succ_eq_comp_right\n\n",
 "iterated_fderiv_within_succ_eq_comp_left":
 "/-- Writing explicitly the `n+1`-th derivative as the composition of a currying linear equiv,\nand the derivative of the `n`-th derivative. -/\ntheorem iterated_fderiv_within_succ_eq_comp_left {n : â„•} :\n    iterated_fderiv_within ğ•œ (n + 1) f s =\n      continuous_multilinear_curry_left_equiv ğ•œ (fun i : fin (n + 1) => E) F âˆ˜\n        fderiv_within ğ•œ (iterated_fderiv_within ğ•œ n f s) s :=\n  rfl\n#align iterated_fderiv_within_succ_eq_comp_left iterated_fderiv_within_succ_eq_comp_left\n\n",
 "iterated_fderiv_within_succ_apply_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr [Ã— ]â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr [Ã— ]â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr [Ã— ]â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr [Ã— ]â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\ntheorem iterated_fderiv_within_succ_apply_right {n : â„•} (hs : unique_diff_on ğ•œ s) (hx : x âˆˆ s) (m : fin (n + 1) â†’ E) :\n    (iterated_fderiv_within ğ•œ (n + 1) f s x : (fin (n + 1) â†’ E) â†’ F) m =\n      iterated_fderiv_within ğ•œ n (fun y => fderiv_within ğ•œ f s y) s x (init m) (m (last n)) :=\n  by\n  induction' n with n IH generalizing x\n  Â· rw [iterated_fderiv_within_succ_eq_comp_left, iterated_fderiv_within_zero_eq_comp,\n      iterated_fderiv_within_zero_apply, function.comp_apply, linear_isometry_equiv.comp_fderiv_within _ (hs x hx)]\n    rfl\n  Â· let I := continuous_multilinear_curry_right_equiv' ğ•œ n E F\n    have A :\n      âˆ€ y âˆˆ s,\n        iterated_fderiv_within ğ•œ n.succ f s y = (I âˆ˜ iterated_fderiv_within ğ•œ n (fun y => fderiv_within ğ•œ f s y) s) y :=\n      by\n      intro y hy\n      ext m\n      rw [@IH m y hy]\n      rfl\n    calc\n      (iterated_fderiv_within ğ•œ (n + 2) f s x : (fin (n + 2) â†’ E) â†’ F) m =\n          (fderiv_within ğ•œ (iterated_fderiv_within ğ•œ n.succ f s) s x : E â†’ Â«expr [Ã— ]â†’L[ ] Â» E (n + 1) ğ•œ F) (m 0)\n            (tail m) :=\n        rfl\n      _ =\n          (fderiv_within ğ•œ (I âˆ˜ iterated_fderiv_within ğ•œ n (fderiv_within ğ•œ f s) s) s x :\n              E â†’ Â«expr [Ã— ]â†’L[ ] Â» E (n + 1) ğ•œ F)\n            (m 0) (tail m) :=\n        by rw [fderiv_within_congr (hs x hx) A (A x hx)]\n      _ =\n          (I âˆ˜ fderiv_within ğ•œ (iterated_fderiv_within ğ•œ n (fderiv_within ğ•œ f s) s) s x :\n              E â†’ Â«expr [Ã— ]â†’L[ ] Â» E (n + 1) ğ•œ F)\n            (m 0) (tail m) :=\n        by\n        rw [linear_isometry_equiv.comp_fderiv_within _ (hs x hx)]\n        rfl\n      _ =\n          (fderiv_within ğ•œ (iterated_fderiv_within ğ•œ n (fun y => fderiv_within ğ•œ f s y) s) s x :\n              E â†’ Â«expr [Ã— ]â†’L[ ] Â» E n ğ•œ (Â«expr â†’L[ ] Â» E ğ•œ F))\n            (m 0) (init (tail m)) ((tail m) (last n)) :=\n        rfl\n      _ = iterated_fderiv_within ğ•œ (nat.succ n) (fun y => fderiv_within ğ•œ f s y) s x (init m) (m (last (n + 1))) :=\n        by\n        rw [iterated_fderiv_within_succ_apply_left, tail_init_eq_init_tail]\n        rfl\n      \n#align iterated_fderiv_within_succ_apply_right iterated_fderiv_within_succ_apply_right\n\n",
 "iterated_fderiv_within_succ_apply_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr [Ã— ]â†’L[ ] Â» -/\ntheorem iterated_fderiv_within_succ_apply_left {n : â„•} (m : fin (n + 1) â†’ E) :\n    (iterated_fderiv_within ğ•œ (n + 1) f s x : (fin (n + 1) â†’ E) â†’ F) m =\n      (fderiv_within ğ•œ (iterated_fderiv_within ğ•œ n f s) s x : E â†’ Â«expr [Ã— ]â†’L[ ] Â» E n ğ•œ F) (m 0) (tail m) :=\n  rfl\n#align iterated_fderiv_within_succ_apply_left iterated_fderiv_within_succ_apply_left\n\n",
 "iterated_fderiv_within_one_apply":
 "@[simp]\ntheorem iterated_fderiv_within_one_apply (hs : unique_diff_on ğ•œ s) (hx : x âˆˆ s) (m : fin 1 â†’ E) :\n    (iterated_fderiv_within ğ•œ 1 f s x : (fin 1 â†’ E) â†’ F) m = (fderiv_within ğ•œ f s x : E â†’ F) (m 0) :=\n  by\n  rw [iterated_fderiv_within_succ_apply_right hs hx, iterated_fderiv_within_zero_apply]\n  rfl\n#align iterated_fderiv_within_one_apply iterated_fderiv_within_one_apply\n\n",
 "iterated_fderiv_within_of_is_open":
 "/-- In an open set, the iterated derivative within this set coincides with the global iterated\nderivative. -/\ntheorem iterated_fderiv_within_of_is_open (n : â„•) (hs : is_open s) :\n    EqOn (iterated_fderiv_within ğ•œ n f s) (iterated_fderiv ğ•œ n f) s :=\n  by\n  induction' n with n IH\n  Â· intro x hx\n    ext1 m\n    simp only [iterated_fderiv_within_zero_apply, iterated_fderiv_zero_apply]\n  Â· intro x hx\n    rw [iterated_fderiv_succ_eq_comp_left, iterated_fderiv_within_succ_eq_comp_left]\n    dsimp\n    congr 1\n    rw [fderiv_within_of_open hs hx]\n    apply filter.eventually_eq.fderiv_eq\n    filter_upwards [hs.mem_nhds hx]\n    exact IH\n#align iterated_fderiv_within_of_is_open iterated_fderiv_within_of_is_open\n\n",
 "iterated_fderiv_within_neg_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ„•âˆÂ» -/\ntheorem iterated_fderiv_within_neg_apply {f : E â†’ F} (hu : unique_diff_on ğ•œ s) (hx : x âˆˆ s) :\n    iterated_fderiv_within ğ•œ i (-f) s x = -iterated_fderiv_within ğ•œ i f s x :=\n  by\n  induction' i with i hi generalizing x\n  Â· ext h\n    simp\n  Â· ext h\n    have hi' : (i : Â«exprâ„•âˆÂ») < i + 1 := with_top.coe_lt_coe.mpr (nat.lt_succ_self _)\n    calc\n      iterated_fderiv_within ğ•œ (i + 1) (-f) s x h =\n          fderiv_within ğ•œ (iterated_fderiv_within ğ•œ i (-f) s) s x (h 0) (fin.tail h) :=\n        rfl\n      _ = fderiv_within ğ•œ (-iterated_fderiv_within ğ•œ i f s) s x (h 0) (fin.tail h) :=\n        by\n        congr 2\n        exact fderiv_within_congr (hu x hx) (fun _ => hi) (hi hx)\n      _ = -(fderiv_within ğ•œ (iterated_fderiv_within ğ•œ i f s) s) x (h 0) (fin.tail h) := by\n        rw [pi.neg_def, fderiv_within_neg (hu x hx)] <;> rfl\n      _ = -(iterated_fderiv_within ğ•œ (i + 1) f s) x h := rfl\n      \n#align iterated_fderiv_within_neg_apply iterated_fderiv_within_neg_apply\n\n",
 "iterated_fderiv_within_inter_open":
 "/-- The iterated differential within a set `s` at a point `x` is not modified if one intersects\n`s` with an open set containing `x`. -/\ntheorem iterated_fderiv_within_inter_open {n : â„•} (hu : is_open u) (hs : unique_diff_on ğ•œ (s âˆ© u)) (hx : x âˆˆ s âˆ© u) :\n    iterated_fderiv_within ğ•œ n f (s âˆ© u) x = iterated_fderiv_within ğ•œ n f s x :=\n  by\n  induction' n with n IH generalizing x\n  Â· ext m\n    simp\n  Â· have A :\n      fderiv_within ğ•œ (fun y => iterated_fderiv_within ğ•œ n f (s âˆ© u) y) (s âˆ© u) x =\n        fderiv_within ğ•œ (fun y => iterated_fderiv_within ğ•œ n f s y) (s âˆ© u) x :=\n      fderiv_within_congr (hs x hx) (fun y hy => IH hy) (IH hx)\n    have B :\n      fderiv_within ğ•œ (fun y => iterated_fderiv_within ğ•œ n f s y) (s âˆ© u) x =\n        fderiv_within ğ•œ (fun y => iterated_fderiv_within ğ•œ n f s y) s x :=\n      fderiv_within_inter (is_open.mem_nhds hu hx.2)\n        ((unique_diff_within_at_inter (is_open.mem_nhds hu hx.2)).1 (hs x hx))\n    ext m\n    rw [iterated_fderiv_within_succ_apply_left, iterated_fderiv_within_succ_apply_left, A, B]\n#align iterated_fderiv_within_inter_open iterated_fderiv_within_inter_open\n\n",
 "iterated_fderiv_within_inter'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/-- The iterated differential within a set `s` at a point `x` is not modified if one intersects\n`s` with a neighborhood of `x` within `s`. -/\ntheorem iterated_fderiv_within_inter' {n : â„•} (hu : u âˆˆ nhds_within s x) (hs : unique_diff_on ğ•œ s) (xs : x âˆˆ s) :\n    iterated_fderiv_within ğ•œ n f (s âˆ© u) x = iterated_fderiv_within ğ•œ n f s x :=\n  by\n  obtain âŸ¨v, v_open, xv, vuâŸ© : âˆƒ v, is_open v âˆ§ x âˆˆ v âˆ§ v âˆ© s âŠ† u := mem_nhds_within.1 hu\n  have A : s âˆ© u âˆ© v = s âˆ© v :=\n    by\n    apply subset.antisymm (inter_subset_inter (inter_subset_left _ _) (subset.refl _))\n    exact fun y âŸ¨ys, yvâŸ© => âŸ¨âŸ¨ys, vu âŸ¨yv, ysâŸ©âŸ©, yvâŸ©\n  have : iterated_fderiv_within ğ•œ n f (s âˆ© v) x = iterated_fderiv_within ğ•œ n f s x :=\n    iterated_fderiv_within_inter_open v_open (hs.inter v_open) âŸ¨xs, xvâŸ©\n  rw [â† this]\n  have : iterated_fderiv_within ğ•œ n f (s âˆ© u âˆ© v) x = iterated_fderiv_within ğ•œ n f (s âˆ© u) x :=\n    by\n    refine' iterated_fderiv_within_inter_open v_open _ âŸ¨âŸ¨xs, vu âŸ¨xv, xsâŸ©âŸ©, xvâŸ©\n    rw [A]\n    exact hs.inter v_open\n  rw [A] at this\n  rw [â† this]\n#align iterated_fderiv_within_inter' iterated_fderiv_within_inter'\n\n",
 "iterated_fderiv_within_inter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- The iterated differential within a set `s` at a point `x` is not modified if one intersects\n`s` with a neighborhood of `x`. -/\ntheorem iterated_fderiv_within_inter {n : â„•} (hu : u âˆˆ (nhds) x) (hs : unique_diff_on ğ•œ s) (xs : x âˆˆ s) :\n    iterated_fderiv_within ğ•œ n f (s âˆ© u) x = iterated_fderiv_within ğ•œ n f s x :=\n  iterated_fderiv_within_inter' (mem_nhds_within_of_mem_nhds hu) hs xs\n#align iterated_fderiv_within_inter iterated_fderiv_within_inter\n\n",
 "iterated_fderiv_within_const_smul_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ„•âˆÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\ntheorem iterated_fderiv_within_const_smul_apply (hf : cont_diff_on ğ•œ i f s) (hu : unique_diff_on ğ•œ s) (hx : x âˆˆ s) :\n    iterated_fderiv_within ğ•œ i (Â«expr â€¢ Â» a f) s x = Â«expr â€¢ Â» a (iterated_fderiv_within ğ•œ i f s x) :=\n  by\n  induction' i with i hi generalizing x\n  Â· ext\n    simp\n  Â· ext h\n    have hi' : (i : Â«exprâ„•âˆÂ») < i + 1 := with_top.coe_lt_coe.mpr (nat.lt_succ_self _)\n    have hdf : differentiable_on ğ•œ (iterated_fderiv_within ğ•œ i f s) s :=\n      hf.differentiable_on_iterated_fderiv_within hi' hu\n    have hcdf : cont_diff_on ğ•œ i f s := hf.of_le hi'.le\n    calc\n      iterated_fderiv_within ğ•œ (i + 1) (Â«expr â€¢ Â» a f) s x h =\n          fderiv_within ğ•œ (iterated_fderiv_within ğ•œ i (Â«expr â€¢ Â» a f) s) s x (h 0) (fin.tail h) :=\n        rfl\n      _ = fderiv_within ğ•œ (Â«expr â€¢ Â» a (iterated_fderiv_within ğ•œ i f s)) s x (h 0) (fin.tail h) :=\n        by\n        congr 2\n        exact fderiv_within_congr (hu x hx) (fun _ => hi hcdf) (hi hcdf hx)\n      _ = (Â«expr â€¢ Â» a (fderiv_within ğ•œ (iterated_fderiv_within ğ•œ i f s))) s x (h 0) (fin.tail h) := by\n        rw [pi.smul_def, fderiv_within_const_smul (hu x hx) (hdf x hx)] <;> rfl\n      _ = Â«expr â€¢ Â» a (iterated_fderiv_within ğ•œ (i + 1) f s x h) := rfl\n      \n#align iterated_fderiv_within_const_smul_apply iterated_fderiv_within_const_smul_apply\n\n",
 "iterated_fderiv_within_congr":
 "/-- If two functions coincide on a set `s` of unique differentiability, then their iterated\ndifferentials within this set coincide. -/\ntheorem iterated_fderiv_within_congr {n : â„•} (hs : unique_diff_on ğ•œ s) (hL : âˆ€ y âˆˆ s, fâ‚ y = f y) (hx : x âˆˆ s) :\n    iterated_fderiv_within ğ•œ n fâ‚ s x = iterated_fderiv_within ğ•œ n f s x :=\n  by\n  induction' n with n IH generalizing x\n  Â· ext m\n    simp [hL x hx]\n  Â· have :\n      fderiv_within ğ•œ (fun y => iterated_fderiv_within ğ•œ n fâ‚ s y) s x =\n        fderiv_within ğ•œ (fun y => iterated_fderiv_within ğ•œ n f s y) s x :=\n      fderiv_within_congr (hs x hx) (fun y hy => IH hy) (IH hx)\n    ext m\n    rw [iterated_fderiv_within_succ_apply_left, iterated_fderiv_within_succ_apply_left, this]\n#align iterated_fderiv_within_congr iterated_fderiv_within_congr\n\n",
 "iterated_fderiv_within_add_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ„•âˆÂ» -/\ntheorem iterated_fderiv_within_add_apply {f g : E â†’ F} (hf : cont_diff_on ğ•œ i f s) (hg : cont_diff_on ğ•œ i g s)\n    (hu : unique_diff_on ğ•œ s) (hx : x âˆˆ s) :\n    iterated_fderiv_within ğ•œ i (f + g) s x = iterated_fderiv_within ğ•œ i f s x + iterated_fderiv_within ğ•œ i g s x :=\n  by\n  induction' i with i hi generalizing x\n  Â· ext h\n    simp\n  Â· ext h\n    have hi' : (i : Â«exprâ„•âˆÂ») < i + 1 := with_top.coe_lt_coe.mpr (nat.lt_succ_self _)\n    have hdf : differentiable_on ğ•œ (iterated_fderiv_within ğ•œ i f s) s :=\n      hf.differentiable_on_iterated_fderiv_within hi' hu\n    have hdg : differentiable_on ğ•œ (iterated_fderiv_within ğ•œ i g s) s :=\n      hg.differentiable_on_iterated_fderiv_within hi' hu\n    have hcdf : cont_diff_on ğ•œ i f s := hf.of_le hi'.le\n    have hcdg : cont_diff_on ğ•œ i g s := hg.of_le hi'.le\n    calc\n      iterated_fderiv_within ğ•œ (i + 1) (f + g) s x h =\n          fderiv_within ğ•œ (iterated_fderiv_within ğ•œ i (f + g) s) s x (h 0) (fin.tail h) :=\n        rfl\n      _ = fderiv_within ğ•œ (iterated_fderiv_within ğ•œ i f s + iterated_fderiv_within ğ•œ i g s) s x (h 0) (fin.tail h) :=\n        by\n        congr 2\n        exact fderiv_within_congr (hu x hx) (fun _ => hi hcdf hcdg) (hi hcdf hcdg hx)\n      _ =\n          (fderiv_within ğ•œ (iterated_fderiv_within ğ•œ i f s) s + fderiv_within ğ•œ (iterated_fderiv_within ğ•œ i g s) s) x\n            (h 0) (fin.tail h) :=\n        by rw [pi.add_def, fderiv_within_add (hu x hx) (hdf x hx) (hdg x hx)] <;> rfl\n      _ = (iterated_fderiv_within ğ•œ (i + 1) f s + iterated_fderiv_within ğ•œ (i + 1) g s) x h := rfl\n      \n#align iterated_fderiv_within_add_apply iterated_fderiv_within_add_apply\n\n",
 "iterated_fderiv_with_zero_eq":
 "theorem iterated_fderiv_with_zero_eq : iterated_fderiv_within ğ•œ 0 f s = iterated_fderiv ğ•œ 0 f :=\n  by\n  ext\n  rfl\n#align iterated_fderiv_with_zero_eq iterated_fderiv_with_zero_eq\n\n",
 "iterated_fderiv_succ_eq_comp_right":
 "/-- Writing explicitly the `n+1`-th derivative as the composition of a currying linear equiv,\nand the `n`-th derivative of the derivative. -/\ntheorem iterated_fderiv_succ_eq_comp_right {n : â„•} :\n    iterated_fderiv ğ•œ (n + 1) f x =\n      (continuous_multilinear_curry_right_equiv' ğ•œ n E F âˆ˜ iterated_fderiv ğ•œ n fun y => fderiv ğ•œ f y) x :=\n  by\n  ext m\n  rw [iterated_fderiv_succ_apply_right]\n  rfl\n#align iterated_fderiv_succ_eq_comp_right iterated_fderiv_succ_eq_comp_right\n\n",
 "iterated_fderiv_succ_eq_comp_left":
 "/-- Writing explicitly the `n+1`-th derivative as the composition of a currying linear equiv,\nand the derivative of the `n`-th derivative. -/\ntheorem iterated_fderiv_succ_eq_comp_left {n : â„•} :\n    iterated_fderiv ğ•œ (n + 1) f =\n      continuous_multilinear_curry_left_equiv ğ•œ (fun i : fin (n + 1) => E) F âˆ˜ fderiv ğ•œ (iterated_fderiv ğ•œ n f) :=\n  rfl\n#align iterated_fderiv_succ_eq_comp_left iterated_fderiv_succ_eq_comp_left\n\n",
 "iterated_fderiv_succ_apply_right":
 "theorem iterated_fderiv_succ_apply_right {n : â„•} (m : fin (n + 1) â†’ E) :\n    (iterated_fderiv ğ•œ (n + 1) f x : (fin (n + 1) â†’ E) â†’ F) m =\n      iterated_fderiv ğ•œ n (fun y => fderiv ğ•œ f y) x (init m) (m (last n)) :=\n  by\n  rw [â† iterated_fderiv_within_univ, â† iterated_fderiv_within_univ, â† fderiv_within_univ]\n  exact iterated_fderiv_within_succ_apply_right unique_diff_on_univ (mem_univ _) _\n#align iterated_fderiv_succ_apply_right iterated_fderiv_succ_apply_right\n\n",
 "iterated_fderiv_succ_apply_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr [Ã— ]â†’L[ ] Â» -/\ntheorem iterated_fderiv_succ_apply_left {n : â„•} (m : fin (n + 1) â†’ E) :\n    (iterated_fderiv ğ•œ (n + 1) f x : (fin (n + 1) â†’ E) â†’ F) m =\n      (fderiv ğ•œ (iterated_fderiv ğ•œ n f) x : E â†’ Â«expr [Ã— ]â†’L[ ] Â» E n ğ•œ F) (m 0) (tail m) :=\n  rfl\n#align iterated_fderiv_succ_apply_left iterated_fderiv_succ_apply_left\n\n",
 "iterated_fderiv_one_apply":
 "@[simp]\ntheorem iterated_fderiv_one_apply (m : fin 1 â†’ E) :\n    (iterated_fderiv ğ•œ 1 f x : (fin 1 â†’ E) â†’ F) m = (fderiv ğ•œ f x : E â†’ F) (m 0) :=\n  by\n  rw [iterated_fderiv_succ_apply_right, iterated_fderiv_zero_apply]\n  rfl\n#align iterated_fderiv_one_apply iterated_fderiv_one_apply\n\n",
 "iterated_fderiv_neg_apply":
 "theorem iterated_fderiv_neg_apply {i : â„•} {f : E â†’ F} : iterated_fderiv ğ•œ i (-f) x = -iterated_fderiv ğ•œ i f x :=\n  by\n  simp_rw [â† iterated_fderiv_within_univ]\n  exact iterated_fderiv_within_neg_apply unique_diff_on_univ (Set.mem_univ _)\n#align iterated_fderiv_neg_apply iterated_fderiv_neg_apply\n\n",
 "iterated_fderiv_const_smul_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\ntheorem iterated_fderiv_const_smul_apply {x : E} (hf : cont_diff ğ•œ i f) :\n    iterated_fderiv ğ•œ i (Â«expr â€¢ Â» a f) x = Â«expr â€¢ Â» a (iterated_fderiv ğ•œ i f x) :=\n  by\n  simp_rw [â† cont_diff_on_univ, â† iterated_fderiv_within_univ] at *\n  refine' iterated_fderiv_within_const_smul_apply hf unique_diff_on_univ (Set.mem_univ _)\n#align iterated_fderiv_const_smul_apply iterated_fderiv_const_smul_apply\n\n",
 "iterated_fderiv_add_apply":
 "theorem iterated_fderiv_add_apply {i : â„•} {f g : E â†’ F} (hf : cont_diff ğ•œ i f) (hg : cont_diff ğ•œ i g) :\n    iterated_fderiv ğ•œ i (f + g) x = iterated_fderiv ğ•œ i f x + iterated_fderiv ğ•œ i g x :=\n  by\n  simp_rw [â† cont_diff_on_univ, â† iterated_fderiv_within_univ] at hf hgâŠ¢\n  exact iterated_fderiv_within_add_apply hf hg unique_diff_on_univ (Set.mem_univ _)\n#align iterated_fderiv_add_apply iterated_fderiv_add_apply\n\n",
 "iterated_fderiv":
 "theorem has_compact_support.iterated_fderiv (hf : has_compact_support f) (n : â„•) :\n    has_compact_support (iterated_fderiv ğ•œ n f) :=\n  by\n  induction' n with n IH\n  Â· rw [iterated_fderiv_zero_eq_comp]\n    apply hf.comp_left\n    exact linear_isometry_equiv.map_zero _\n  Â· rw [iterated_fderiv_succ_eq_comp_left]\n    apply (IH.fderiv ğ•œ).comp_left\n    exact linear_isometry_equiv.map_zero _\n#align has_compact_support.iterated_fderiv has_compact_support.iterated_fderiv\n\n",
 "inv":
 "theorem cont_diff.inv {f : E â†’ ğ•œ'} {n} (hf : cont_diff ğ•œ n f) (h : âˆ€ x, f x â‰  0) : cont_diff ğ•œ n fun x => (f x)â»Â¹ :=\n  by\n  rw [cont_diff_iff_cont_diff_at]\n  exact fun x => hf.cont_diff_at.inv (h x)\n#align cont_diff.inv cont_diff.inv\n\n",
 "insert":
 "theorem cont_diff_within_at.insert (h : cont_diff_within_at ğ•œ n f s x) : cont_diff_within_at ğ•œ n f (insert x s) x :=\n  h.insert'\n#align cont_diff_within_at.insert cont_diff_within_at.insert\n\n",
 "has_strict_fderiv_at'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/-- If a function is `C^n` with `1 â‰¤ n` around a point, and its derivative at that point is given to\nus as `f'`, then `f'` is also a strict derivative. -/\ntheorem cont_diff_at.has_strict_fderiv_at' {f : E' â†’ F'} {f' : Â«expr â†’L[ ] Â» E' ğ•‚ F'} {x : E'}\n    (hf : cont_diff_at ğ•‚ n f x) (hf' : has_fderiv_at f f' x) (hn : 1 â‰¤ n) : has_strict_fderiv_at f f' x :=\n  by\n  rcases hf 1 hn with âŸ¨u, H, p, hpâŸ©\n  simp only [nhds_within_univ, mem_univ, insert_eq_of_mem] at H\n  have := hp.has_strict_fderiv_at le_rfl H\n  rwa [hf'.unique this.has_fderiv_at]\n#align cont_diff_at.has_strict_fderiv_at' cont_diff_at.has_strict_fderiv_at'\n\n",
 "has_strict_fderiv_at":
 "/-- If a function is `C^n` with `1 â‰¤ n`, then the derivative of `f` is also a strict derivative. -/\ntheorem cont_diff.has_strict_fderiv_at {f : E' â†’ F'} {x : E'} (hf : cont_diff ğ•‚ n f) (hn : 1 â‰¤ n) :\n    has_strict_fderiv_at f (fderiv ğ•‚ f x) x :=\n  hf.cont_diff_at.has_strict_fderiv_at hn\n#align cont_diff.has_strict_fderiv_at cont_diff.has_strict_fderiv_at\n\n",
 "has_strict_deriv_at'":
 "/-- If a function is `C^n` with `1 â‰¤ n` around a point, and its derivative at that point is given to\nus as `f'`, then `f'` is also a strict derivative. -/\ntheorem cont_diff_at.has_strict_deriv_at' {f : ğ•‚ â†’ F'} {f' : F'} {x : ğ•‚} (hf : cont_diff_at ğ•‚ n f x)\n    (hf' : has_deriv_at f f' x) (hn : 1 â‰¤ n) : has_strict_deriv_at f f' x :=\n  hf.has_strict_fderiv_at' hf' hn\n#align cont_diff_at.has_strict_deriv_at' cont_diff_at.has_strict_deriv_at'\n\n",
 "has_strict_deriv_at":
 "/-- If a function is `C^n` with `1 â‰¤ n`, then the derivative of `f` is also a strict derivative. -/\ntheorem cont_diff.has_strict_deriv_at {f : ğ•‚ â†’ F'} {x : ğ•‚} (hf : cont_diff ğ•‚ n f) (hn : 1 â‰¤ n) :\n    has_strict_deriv_at f (deriv f x) x :=\n  hf.cont_diff_at.has_strict_deriv_at hn\n#align cont_diff.has_strict_deriv_at cont_diff.has_strict_deriv_at\n\n",
 "has_ftaylor_series_up_to_zero_iff":
 "theorem has_ftaylor_series_up_to_zero_iff :\n    has_ftaylor_series_up_to 0 f p â†” continuous f âˆ§ âˆ€ x, (p x 0).uncurry0 = f x := by\n  simp [has_ftaylor_series_up_to_on_univ_iff.symm, continuous_iff_continuous_on_univ,\n    has_ftaylor_series_up_to_on_zero_iff]\n#align has_ftaylor_series_up_to_zero_iff has_ftaylor_series_up_to_zero_iff\n\n",
 "has_ftaylor_series_up_to_succ_iff_right":
 "/-- `p` is a Taylor series of `f` up to `n+1` if and only if `p.shift` is a Taylor series up to `n`\nfor `p 1`, which is a derivative of `f`. -/\ntheorem has_ftaylor_series_up_to_succ_iff_right {n : â„•} :\n    has_ftaylor_series_up_to (n + 1 : â„•) f p â†”\n      (âˆ€ x, (p x 0).uncurry0 = f x) âˆ§\n        (âˆ€ x, has_fderiv_at (fun y => p y 0) (p x 1).curry_left x) âˆ§\n          has_ftaylor_series_up_to n (fun x => continuous_multilinear_curry_fin1 ğ•œ E F (p x 1)) fun x => (p x).shift :=\n  by\n  simp only [has_ftaylor_series_up_to_on_succ_iff_right, â† has_ftaylor_series_up_to_on_univ_iff, mem_univ,\n    forall_true_left, has_fderiv_within_at_univ]\n#align has_ftaylor_series_up_to_succ_iff_right has_ftaylor_series_up_to_succ_iff_right\n\n",
 "has_ftaylor_series_up_to_on_zero_iff":
 "theorem has_ftaylor_series_up_to_on_zero_iff :\n    has_ftaylor_series_up_to_on 0 f p s â†” continuous_on f s âˆ§ âˆ€ x âˆˆ s, (p x 0).uncurry0 = f x :=\n  by\n  refine' âŸ¨fun H => âŸ¨H.continuous_on, H.zero_eqâŸ©, fun H => âŸ¨H.2, fun m hm => false.elim (not_le.2 hm bot_le), _âŸ©âŸ©\n  intro m hm\n  obtain rfl : m = 0 := by exact_mod_cast hm.antisymm (zero_le _)\n  have : âˆ€ x âˆˆ s, p x 0 = (continuous_multilinear_curry_fin0 ğ•œ E F).symm (f x) :=\n    by\n    intro x hx\n    rw [â† H.2 x hx]\n    symm\n    exact continuous_multilinear_map.uncurry0_curry0 _\n  rw [continuous_on_congr this, linear_isometry_equiv.comp_continuous_on_iff]\n  exact H.1\n#align has_ftaylor_series_up_to_on_zero_iff has_ftaylor_series_up_to_on_zero_iff\n\n",
 "has_ftaylor_series_up_to_on_univ_iff":
 "theorem has_ftaylor_series_up_to_on_univ_iff :\n    has_ftaylor_series_up_to_on n f p univ â†” has_ftaylor_series_up_to n f p :=\n  by\n  constructor\n  Â· intro H\n    constructor\n    Â· exact fun x => H.zero_eq x (mem_univ x)\n    Â· intro m hm x\n      rw [â† has_fderiv_within_at_univ]\n      exact H.fderiv_within m hm x (mem_univ x)\n    Â· intro m hm\n      rw [continuous_iff_continuous_on_univ]\n      exact H.cont m hm\n  Â· intro H\n    constructor\n    Â· exact fun x hx => H.zero_eq x\n    Â· intro m hm x hx\n      rw [has_fderiv_within_at_univ]\n      exact H.fderiv m hm x\n    Â· intro m hm\n      rw [â† continuous_iff_continuous_on_univ]\n      exact H.cont m hm\n#align has_ftaylor_series_up_to_on_univ_iff has_ftaylor_series_up_to_on_univ_iff\n\n",
 "has_ftaylor_series_up_to_on_top_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆÂ» -/\ntheorem has_ftaylor_series_up_to_on_top_iff :\n    has_ftaylor_series_up_to_on (Â«exprâˆÂ») f p s â†” âˆ€ n : â„•, has_ftaylor_series_up_to_on n f p s :=\n  by\n  constructor\n  Â· intro H n\n    exact H.of_le le_top\n  Â· intro H\n    constructor\n    Â· exact (H 0).zero_eq\n    Â· intro m hm\n      apply (H m.succ).fderiv_within m (WithTop.coe_lt_coe.2 (lt_add_one m))\n    Â· intro m hm\n      apply (H m).cont m le_rfl\n#align has_ftaylor_series_up_to_on_top_iff has_ftaylor_series_up_to_on_top_iff\n\n",
 "has_ftaylor_series_up_to_on_succ_iff_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ„•âˆÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ„•âˆÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ„•âˆÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ„•âˆÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ„•âˆÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ„•âˆÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ„•âˆÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ„•âˆÂ» -/\n/-- `p` is a Taylor series of `f` up to `n+1` if and only if `p.shift` is a Taylor series up to `n`\nfor `p 1`, which is a derivative of `f`. -/\ntheorem has_ftaylor_series_up_to_on_succ_iff_right {n : â„•} :\n    has_ftaylor_series_up_to_on (n + 1 : â„•) f p s â†”\n      (âˆ€ x âˆˆ s, (p x 0).uncurry0 = f x) âˆ§\n        (âˆ€ x âˆˆ s, has_fderiv_within_at (fun y => p y 0) (p x 1).curry_left s x) âˆ§\n          has_ftaylor_series_up_to_on n (fun x => continuous_multilinear_curry_fin1 ğ•œ E F (p x 1))\n            (fun x => (p x).shift) s :=\n  by\n  constructor\n  Â· intro H\n    refine' âŸ¨H.zero_eq, H.fderiv_within 0 (WithTop.coe_lt_coe.2 (nat.succ_pos n)), _âŸ©\n    constructor\n    Â· intro x hx\n      rfl\n    Â· intro m(hm : (m : Â«exprâ„•âˆÂ») < n)x(hx : x âˆˆ s)\n      have A : (m.succ : Â«exprâ„•âˆÂ») < n.succ := by\n        rw [WithTop.coe_lt_coe] at hmâŠ¢\n        exact nat.lt_succ_iff.mpr hm\n      change\n        has_fderiv_within_at ((continuous_multilinear_curry_right_equiv' ğ•œ m E F).symm âˆ˜ fun y : E => p y m.succ)\n          (p x m.succ.succ).curry_right.curry_left s x\n      rw [linear_isometry_equiv.comp_has_fderiv_within_at_iff']\n      convert H.fderiv_within _ A x hx\n      ext (y v)\n      change (p x m.succ.succ) (snoc (cons y (init v)) (v (last _))) = (p x (nat.succ (nat.succ m))) (cons y v)\n      rw [â† cons_snoc_eq_snoc_cons, snoc_init_self]\n    Â· intro m(hm : (m : Â«exprâ„•âˆÂ») â‰¤ n)\n      have A : (m.succ : Â«exprâ„•âˆÂ») â‰¤ n.succ := by\n        rw [WithTop.coe_le_coe] at hmâŠ¢\n        exact nat.pred_le_iff.mp hm\n      change continuous_on ((continuous_multilinear_curry_right_equiv' ğ•œ m E F).symm âˆ˜ fun y : E => p y m.succ) s\n      rw [linear_isometry_equiv.comp_continuous_on_iff]\n      exact H.cont _ A\n  Â· rintro âŸ¨Hzero_eq, Hfderiv_zero, HtaylorâŸ©\n    constructor\n    Â· exact Hzero_eq\n    Â· intro m(hm : (m : Â«exprâ„•âˆÂ») < n.succ)x(hx : x âˆˆ s)\n      cases m\n      Â· exact Hfderiv_zero x hx\n      Â· have A : (m : Â«exprâ„•âˆÂ») < n := by\n          rw [WithTop.coe_lt_coe] at hmâŠ¢\n          exact nat.lt_of_succ_lt_succ hm\n        have :\n          has_fderiv_within_at ((continuous_multilinear_curry_right_equiv' ğ•œ m E F).symm âˆ˜ fun y : E => p y m.succ)\n            ((p x).shift m.succ).curry_left s x :=\n          Htaylor.fderiv_within _ A x hx\n        rw [linear_isometry_equiv.comp_has_fderiv_within_at_iff'] at this\n        convert this\n        ext (y v)\n        change (p x (nat.succ (nat.succ m))) (cons y v) = (p x m.succ.succ) (snoc (cons y (init v)) (v (last _)))\n        rw [â† cons_snoc_eq_snoc_cons, snoc_init_self]\n    Â· intro m(hm : (m : Â«exprâ„•âˆÂ») â‰¤ n.succ)\n      cases m\n      Â· have : differentiable_on ğ•œ (fun x => p x 0) s := fun x hx => (Hfderiv_zero x hx).differentiable_within_at\n        exact this.continuous_on\n      Â· have A : (m : Â«exprâ„•âˆÂ») â‰¤ n := by\n          rw [WithTop.coe_le_coe] at hmâŠ¢\n          exact nat.lt_succ_iff.mp hm\n        have : continuous_on ((continuous_multilinear_curry_right_equiv' ğ•œ m E F).symm âˆ˜ fun y : E => p y m.succ) s :=\n          Htaylor.cont _ A\n        rwa [linear_isometry_equiv.comp_continuous_on_iff] at this\n#align has_ftaylor_series_up_to_on_succ_iff_right has_ftaylor_series_up_to_on_succ_iff_right\n\n",
 "has_ftaylor_series_up_to_on_succ_iff_left":
 "/-- `p` is a Taylor series of `f` up to `n+1` if and only if `p` is a Taylor series up to `n`, and\n`p (n + 1)` is a derivative of `p n`. -/\ntheorem has_ftaylor_series_up_to_on_succ_iff_left {n : â„•} :\n    has_ftaylor_series_up_to_on (n + 1) f p s â†”\n      has_ftaylor_series_up_to_on n f p s âˆ§\n        (âˆ€ x âˆˆ s, has_fderiv_within_at (fun y => p y n) (p x n.succ).curry_left s x) âˆ§\n          continuous_on (fun x => p x (n + 1)) s :=\n  by\n  constructor\n  Â· intro h\n    exact\n      âŸ¨h.of_le (WithTop.coe_le_coe.2 (nat.le_succ n)), h.fderiv_within _ (WithTop.coe_lt_coe.2 (lt_add_one n)),\n        h.cont (n + 1) le_rflâŸ©\n  Â· intro h\n    constructor\n    Â· exact h.1.zero_eq\n    Â· intro m hm\n      by_cases h' : m < n\n      Â· exact h.1.fderiv_within m (WithTop.coe_lt_coe.2 h')\n      Â· have : m = n := Nat.eq_of_lt_succ_of_not_lt (WithTop.coe_lt_coe.1 hm) h'\n        rw [this]\n        exact h.2.1\n    Â· intro m hm\n      by_cases h' : m â‰¤ n\n      Â· apply h.1.cont m (WithTop.coe_le_coe.2 h')\n      Â· have : m = n + 1 := le_antisymm (WithTop.coe_le_coe.1 hm) (not_le.1 h')\n        rw [this]\n        exact h.2.2\n#align has_ftaylor_series_up_to_on_succ_iff_left has_ftaylor_series_up_to_on_succ_iff_left\n\n",
 "has_ftaylor_series_up_to_on_pi'":
 "@[simp]\ntheorem has_ftaylor_series_up_to_on_pi' :\n    has_ftaylor_series_up_to_on n Î¦ P' s â†”\n      âˆ€ i,\n        has_ftaylor_series_up_to_on n (fun x => Î¦ x i)\n          (fun x m => (@continuous_linear_map.proj ğ•œ _ Î¹ F' _ _ _ i).comp_continuous_multilinear_map (P' x m)) s :=\n  by\n  convert has_ftaylor_series_up_to_on_pi\n  ext\n  rfl\n#align has_ftaylor_series_up_to_on_pi' has_ftaylor_series_up_to_on_pi'\n\n",
 "has_ftaylor_series_up_to_on_pi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr [Ã— ]â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰ƒâ‚—áµ¢[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr [Ã— ]â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr [Ã— ]â†’L[ ] Â» -/\ntheorem has_ftaylor_series_up_to_on_pi :\n    has_ftaylor_series_up_to_on n (fun x i => Ï† i x) (fun x m => continuous_multilinear_map.pi fun i => p' i x m) s â†”\n      âˆ€ i, has_ftaylor_series_up_to_on n (Ï† i) (p' i) s :=\n  by\n  set pr := @continuous_linear_map.proj ğ•œ _ Î¹ F' _ _ _\n  letI : âˆ€ (m : â„•) (i : Î¹), normed_space ğ•œ (Â«expr [Ã— ]â†’L[ ] Â» E m ğ•œ (F' i)) := fun m i => infer_instance\n  set L : âˆ€ m : â„•, Â«expr â‰ƒâ‚—áµ¢[ ] Â» (âˆ€ i, Â«expr [Ã— ]â†’L[ ] Â» E m ğ•œ (F' i)) ğ•œ (Â«expr [Ã— ]â†’L[ ] Â» E m ğ•œ (âˆ€ i, F' i)) :=\n    fun m => continuous_multilinear_map.piâ‚—áµ¢ _ _\n  refine' âŸ¨fun h i => _, fun h => âŸ¨fun x hx => _, _, _âŸ©âŸ©\n  Â· convert h.continuous_linear_map_comp (pr i)\n    ext\n    rfl\n  Â· ext1 i\n    exact (h i).zero_eq x hx\n  Â· intro m hm x hx\n    have := has_fderiv_within_at_pi.2 fun i => (h i).fderiv_within m hm x hx\n    convert (L m).has_fderiv_at.comp_has_fderiv_within_at x this\n  Â· intro m hm\n    have := continuous_on_pi.2 fun i => (h i).cont m hm\n    convert (L m).continuous.comp_continuous_on this\n#align has_ftaylor_series_up_to_on_pi has_ftaylor_series_up_to_on_pi\n\n",
 "has_ftaylor_series_up_to_on":
 "theorem has_ftaylor_series_up_to.has_ftaylor_series_up_to_on (h : has_ftaylor_series_up_to n f p) (s : set E) :\n    has_ftaylor_series_up_to_on n f p s :=\n  (has_ftaylor_series_up_to_on_univ_iff.2 h).mono (subset_univ _)\n#align has_ftaylor_series_up_to.has_ftaylor_series_up_to_on has_ftaylor_series_up_to.has_ftaylor_series_up_to_on\n\n",
 "has_fderiv_within_at":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ„•âˆÂ» -/\n/-- If a function has a Taylor series at order at least `1`, then the term of order `1` of this\nseries is a derivative of `f`. -/\ntheorem has_ftaylor_series_up_to_on.has_fderiv_within_at (h : has_ftaylor_series_up_to_on n f p s) (hn : 1 â‰¤ n)\n    (hx : x âˆˆ s) : has_fderiv_within_at f (continuous_multilinear_curry_fin1 ğ•œ E F (p x 1)) s x :=\n  by\n  have A : âˆ€ y âˆˆ s, f y = (continuous_multilinear_curry_fin0 ğ•œ E F) (p y 0) :=\n    by\n    intro y hy\n    rw [â† h.zero_eq y hy]\n    rfl\n  suffices H :\n    has_fderiv_within_at (fun y => continuous_multilinear_curry_fin0 ğ•œ E F (p y 0))\n      (continuous_multilinear_curry_fin1 ğ•œ E F (p x 1)) s x\n  Â· exact H.congr A (A x hx)\n  rw [linear_isometry_equiv.comp_has_fderiv_within_at_iff']\n  have : ((0 : â„•) : Â«exprâ„•âˆÂ») < n := lt_of_lt_of_le (WithTop.coe_lt_coe.2 nat.zero_lt_one) hn\n  convert h.fderiv_within _ this x hx\n  ext (y v)\n  change (p x 1) (snoc 0 y) = (p x 1) (cons y v)\n  unfold_coes\n  congr with i\n  rw [unique.eq_default i]\n  rfl\n#align has_ftaylor_series_up_to_on.has_fderiv_within_at has_ftaylor_series_up_to_on.has_fderiv_within_at\n\n",
 "has_fderiv_at":
 "/-- If a function has a Taylor series at order at least `1`, then the term of order `1` of this\nseries is a derivative of `f`. -/\ntheorem has_ftaylor_series_up_to.has_fderiv_at (h : has_ftaylor_series_up_to n f p) (hn : 1 â‰¤ n) (x : E) :\n    has_fderiv_at f (continuous_multilinear_curry_fin1 ğ•œ E F (p x 1)) x :=\n  by\n  rw [â† has_fderiv_within_at_univ]\n  exact (has_ftaylor_series_up_to_on_univ_iff.2 h).has_fderiv_within_at hn (mem_univ _)\n#align has_ftaylor_series_up_to.has_fderiv_at has_ftaylor_series_up_to.has_fderiv_at\n\n",
 "ftaylor_series_within_univ":
 "theorem ftaylor_series_within_univ : ftaylor_series_within ğ•œ f univ = ftaylor_series ğ•œ f :=\n  by\n  ext1 x; ext1 n\n  change iterated_fderiv_within ğ•œ n f univ x = iterated_fderiv ğ•œ n f x\n  rw [iterated_fderiv_within_univ]\n#align ftaylor_series_within_univ ftaylor_series_within_univ\n\n",
 "ftaylor_series_within":
 "/-- When a function is `C^n` in a set `s` of unique differentiability, it admits\n`ftaylor_series_within ğ•œ f s` as a Taylor series up to order `n` in `s`. -/\ntheorem cont_diff_on.ftaylor_series_within (h : cont_diff_on ğ•œ n f s) (hs : unique_diff_on ğ•œ s) :\n    has_ftaylor_series_up_to_on n f (ftaylor_series_within ğ•œ f s) s :=\n  by\n  constructor\n  Â· intro x hx\n    simp only [ftaylor_series_within, continuous_multilinear_map.uncurry0_apply, iterated_fderiv_within_zero_apply]\n  Â· intro m hm x hx\n    rcases(h x hx) m.succ (enat.add_one_le_of_lt hm) with âŸ¨u, hu, p, HpâŸ©\n    rw [insert_eq_of_mem hx] at hu\n    rcases mem_nhds_within.1 hu with âŸ¨o, o_open, xo, hoâŸ©\n    rw [inter_comm] at ho\n    have : p x m.succ = ftaylor_series_within ğ•œ f s x m.succ :=\n      by\n      change p x m.succ = iterated_fderiv_within ğ•œ m.succ f s x\n      rw [â† iterated_fderiv_within_inter (is_open.mem_nhds o_open xo) hs hx]\n      exact (Hp.mono ho).eq_ftaylor_series_of_unique_diff_on le_rfl (hs.inter o_open) âŸ¨hx, xoâŸ©\n    rw [â† this, â† has_fderiv_within_at_inter (is_open.mem_nhds o_open xo)]\n    have A : âˆ€ y âˆˆ s âˆ© o, p y m = ftaylor_series_within ğ•œ f s y m :=\n      by\n      rintro y âŸ¨hy, yoâŸ©\n      change p y m = iterated_fderiv_within ğ•œ m f s y\n      rw [â† iterated_fderiv_within_inter (is_open.mem_nhds o_open yo) hs hy]\n      exact\n        (Hp.mono ho).eq_ftaylor_series_of_unique_diff_on (WithTop.coe_le_coe.2 (nat.le_succ m)) (hs.inter o_open)\n          âŸ¨hy, yoâŸ©\n    exact\n      ((Hp.mono ho).fderiv_within m (WithTop.coe_lt_coe.2 (lt_add_one m)) x âŸ¨hx, xoâŸ©).congr (fun y hy => (A y hy).symm)\n        (A x âŸ¨hx, xoâŸ©).symm\n  Â· intro m hm\n    apply continuous_on_of_locally_continuous_on\n    intro x hx\n    rcases h x hx m hm with âŸ¨u, hu, p, HpâŸ©\n    rcases mem_nhds_within.1 hu with âŸ¨o, o_open, xo, hoâŸ©\n    rw [insert_eq_of_mem hx] at ho\n    rw [inter_comm] at ho\n    refine' âŸ¨o, o_open, xo, _âŸ©\n    have A : âˆ€ y âˆˆ s âˆ© o, p y m = ftaylor_series_within ğ•œ f s y m :=\n      by\n      rintro y âŸ¨hy, yoâŸ©\n      change p y m = iterated_fderiv_within ğ•œ m f s y\n      rw [â† iterated_fderiv_within_inter (is_open.mem_nhds o_open yo) hs hy]\n      exact (Hp.mono ho).eq_ftaylor_series_of_unique_diff_on le_rfl (hs.inter o_open) âŸ¨hy, yoâŸ©\n    exact ((Hp.mono ho).cont m le_rfl).congr fun y hy => (A y hy).symm\n#align cont_diff_on.ftaylor_series_within cont_diff_on.ftaylor_series_within\n\n",
 "fst''":
 "/-- Precomposing `f` with `prod.fst` is `C^n` at `x : E Ã— F` -/\ntheorem cont_diff_at.fst'' {f : E â†’ G} {x : E Ã— F} (hf : cont_diff_at ğ•œ n f x.1) :\n    cont_diff_at ğ•œ n (fun x : E Ã— F => f x.1) x :=\n  hf.comp x cont_diff_at_fst\n#align cont_diff_at.fst'' cont_diff_at.fst''\n\n",
 "fst'":
 "/-- Precomposing `f` with `prod.fst` is `C^n` at `(x, y)` -/\ntheorem cont_diff_at.fst' {f : E â†’ G} {x : E} {y : F} (hf : cont_diff_at ğ•œ n f x) :\n    cont_diff_at ğ•œ n (fun x : E Ã— F => f x.1) (x, y) :=\n  cont_diff_at.comp (x, y) hf cont_diff_at_fst\n#align cont_diff_at.fst' cont_diff_at.fst'\n\n",
 "fst":
 "/-- Postcomposing `f` with `prod.fst` is `C^n` at `(x, y)` -/\ntheorem cont_diff_at.fst {f : E â†’ F Ã— G} {x : E} (hf : cont_diff_at ğ•œ n f x) : cont_diff_at ğ•œ n (fun x => (f x).1) x :=\n  cont_diff_at_fst.comp x hf\n#align cont_diff_at.fst cont_diff_at.fst\n\n",
 "fderiv_within'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ„•âˆÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\ntheorem cont_diff_within_at.fderiv_within' (hf : cont_diff_within_at ğ•œ n f s x)\n    (hs :\n      Â«exprâˆ€á¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â»\"\n        (nhds_within (insert x s) x) (unique_diff_within_at ğ•œ s y))\n    (hmn : m + 1 â‰¤ n) : cont_diff_within_at ğ•œ m (fderiv_within ğ•œ f s) s x :=\n  by\n  have : âˆ€ k : â„•, (k + 1 : Â«exprâ„•âˆÂ») â‰¤ n â†’ cont_diff_within_at ğ•œ k (fderiv_within ğ•œ f s) s x :=\n    by\n    intro k hkn\n    obtain âŸ¨v, hv, -, f', hvf', hf'âŸ© := cont_diff_within_at_succ_iff_has_fderiv_within_at'.mp (hf.of_le hkn)\n    apply hf'.congr_of_eventually_eq_insert\n    filter_upwards [hv, hs]\n    exact fun y hy h2y => (hvf' y hy).fderiv_within h2y\n  induction m using WithTop.recTopCoe\n  Â· obtain rfl := eq_top_iff.mpr hmn\n    rw [cont_diff_within_at_top]\n    exact fun m => this m le_top\n  exact this m hmn\n#align cont_diff_within_at.fderiv_within' cont_diff_within_at.fderiv_within'\n\n",
 "fderiv_within":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ„•âˆÂ» -/\ntheorem cont_diff_within_at.fderiv_within (hf : cont_diff_within_at ğ•œ n f s x) (hs : unique_diff_on ğ•œ s)\n    (hmn : (m + 1 : Â«exprâ„•âˆÂ») â‰¤ n) (hxs : x âˆˆ s) : cont_diff_within_at ğ•œ m (fderiv_within ğ•œ f s) s x :=\n  hf.fderiv_within'\n    (by\n      rw [insert_eq_of_mem hxs]\n      exact eventually_of_mem self_mem_nhds_within hs)\n    hmn\n#align cont_diff_within_at.fderiv_within cont_diff_within_at.fderiv_within\n\n",
 "fderiv_of_open":
 "theorem cont_diff_on.fderiv_of_open (hf : cont_diff_on ğ•œ n f s) (hs : is_open s) (hmn : m + 1 â‰¤ n) :\n    cont_diff_on ğ•œ m (fun y => fderiv ğ•œ f y) s :=\n  (hf.fderiv_within hs.unique_diff_on hmn).congr fun x hx => (fderiv_within_of_open hs hx).symm\n#align cont_diff_on.fderiv_of_open cont_diff_on.fderiv_of_open\n\n",
 "fderiv_iterated_fderiv":
 "/-- Writing explicitly the derivative of the `n`-th derivative as the composition of a currying\nlinear equiv, and the `n + 1`-th derivative. -/\ntheorem fderiv_iterated_fderiv {n : â„•} :\n    fderiv ğ•œ (iterated_fderiv ğ•œ n f) =\n      (continuous_multilinear_curry_left_equiv ğ•œ (fun i : fin (n + 1) => E) F).symm âˆ˜ iterated_fderiv ğ•œ (n + 1) f :=\n  by\n  rw [iterated_fderiv_succ_eq_comp_left]\n  ext1 x\n  simp only [Function.comp_apply, linear_isometry_equiv.symm_apply_apply]\n#align fderiv_iterated_fderiv fderiv_iterated_fderiv\n\n",
 "exists_lipschitz_on_with_of_nnnorm_lt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–â‚ŠÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- If `f` is `C^1` at `x` and `K > â€–fderiv ğ•‚ f xâ€–`, then `f` is `K`-Lipschitz in a neighborhood of\n`x`. -/\ntheorem cont_diff_at.exists_lipschitz_on_with_of_nnnorm_lt {f : E' â†’ F'} {x : E'} (hf : cont_diff_at ğ•‚ 1 f x)\n    (K : nnreal) (hK : Â«exprâ€– â€–â‚ŠÂ» (fderiv ğ•‚ f x) < K) : âˆƒ t âˆˆ (nhds) x, lipschitz_on_with K f t :=\n  (hf.has_strict_fderiv_at le_rfl).exists_lipschitz_on_with_of_nnnorm_lt K hK\n#align cont_diff_at.exists_lipschitz_on_with_of_nnnorm_lt cont_diff_at.exists_lipschitz_on_with_of_nnnorm_lt\n\n",
 "exists_lipschitz_on_with":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- If `f` is `C^1` at `x`, then `f` is Lipschitz in a neighborhood of `x`. -/\ntheorem cont_diff_at.exists_lipschitz_on_with {f : E' â†’ F'} {x : E'} (hf : cont_diff_at ğ•‚ 1 f x) :\n    âˆƒ K, âˆƒ t âˆˆ (nhds) x, lipschitz_on_with K f t :=\n  (hf.has_strict_fderiv_at le_rfl).exists_lipschitz_on_with\n#align cont_diff_at.exists_lipschitz_on_with cont_diff_at.exists_lipschitz_on_with\n\n",
 "eventually_has_fderiv_at":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- If a function has a Taylor series at order at least `1` on a neighborhood of `x`, then\nin a neighborhood of `x`, the term of order `1` of this series is a derivative of `f`. -/\ntheorem has_ftaylor_series_up_to_on.eventually_has_fderiv_at (h : has_ftaylor_series_up_to_on n f p s) (hn : 1 â‰¤ n)\n    (hx : s âˆˆ (nhds) x) :\n    Â«exprâˆ€á¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â»\" ((nhds) x)\n      (has_fderiv_at f (continuous_multilinear_curry_fin1 ğ•œ E F (p y 1)) y) :=\n  (eventually_eventually_nhds.2 hx).mono fun y hy => h.has_fderiv_at hn hy\n#align has_ftaylor_series_up_to_on.eventually_has_fderiv_at has_ftaylor_series_up_to_on.eventually_has_fderiv_at\n\n",
 "eventually":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\nprotected theorem cont_diff_at.eventually {n : â„•} (h : cont_diff_at ğ•œ n f x) :\n    Â«exprâˆ€á¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â»\" ((nhds) x)\n      (cont_diff_at ğ•œ n f y) :=\n  by simpa [nhds_within_univ] using h.eventually\n#align cont_diff_at.eventually cont_diff_at.eventually\n\n",
 "eq_ftaylor_series_of_unique_diff_on":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ„•âˆÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ„•âˆÂ» -/\n/-- On a set with unique differentiability, any choice of iterated differential has to coincide\nwith the one we have chosen in `iterated_fderiv_within ğ•œ m f s`. -/\ntheorem has_ftaylor_series_up_to_on.eq_ftaylor_series_of_unique_diff_on (h : has_ftaylor_series_up_to_on n f p s)\n    {m : â„•} (hmn : (m : Â«exprâ„•âˆÂ») â‰¤ n) (hs : unique_diff_on ğ•œ s) (hx : x âˆˆ s) :\n    p x m = iterated_fderiv_within ğ•œ m f s x :=\n  by\n  induction' m with m IH generalizing x\n  Â· rw [h.zero_eq' hx, iterated_fderiv_within_zero_eq_comp]\n  Â· have A : (m : Â«exprâ„•âˆÂ») < n := lt_of_lt_of_le (WithTop.coe_lt_coe.2 (lt_add_one m)) hmn\n    have :\n      has_fderiv_within_at (fun y : E => iterated_fderiv_within ğ•œ m f s y)\n        (continuous_multilinear_map.curry_left (p x (nat.succ m))) s x :=\n      (h.fderiv_within m A x hx).congr (fun y hy => (IH (le_of_lt A) hy).symm) (IH (le_of_lt A) hx).symm\n    rw [iterated_fderiv_within_succ_eq_comp_left, function.comp_apply, this.fderiv_within (hs x hx)]\n    exact (continuous_multilinear_map.uncurry_curry_left _).symm\n#align\n  has_ftaylor_series_up_to_on.eq_ftaylor_series_of_unique_diff_on has_ftaylor_series_up_to_on.eq_ftaylor_series_of_unique_diff_on\n\n",
 "div_const":
 "theorem cont_diff.div_const {f : E â†’ ğ•œ'} {n} {c : ğ•œ'} (hf : cont_diff ğ•œ n f) : cont_diff ğ•œ n fun x => f x / c := by\n  simpa only [div_eq_mul_inv] using hf.mul cont_diff_const\n#align cont_diff.div_const cont_diff.div_const\n\n",
 "div":
 "theorem cont_diff.div [complete_space ğ•œ] {f g : E â†’ ğ•œ} {n} (hf : cont_diff ğ•œ n f) (hg : cont_diff ğ•œ n g)\n    (h0 : âˆ€ x, g x â‰  0) : cont_diff ğ•œ n fun x => f x / g x :=\n  by\n  simp only [cont_diff_iff_cont_diff_at] at *\n  exact fun x => (hf x).div (hg x) (h0 x)\n#align cont_diff.div cont_diff.div\n\n",
 "differentiable_within_at'":
 "/-- If a function is `C^n` within a set at a point, with `n â‰¥ 1`, then it is differentiable\nwithin this set at this point. -/\ntheorem cont_diff_within_at.differentiable_within_at' (h : cont_diff_within_at ğ•œ n f s x) (hn : 1 â‰¤ n) :\n    differentiable_within_at ğ•œ f (insert x s) x :=\n  by\n  rcases h 1 hn with âŸ¨u, hu, p, HâŸ©\n  rcases mem_nhds_within.1 hu with âŸ¨t, t_open, xt, tuâŸ©\n  rw [inter_comm] at tu\n  have := ((H.mono tu).differentiable_on le_rfl) x âŸ¨mem_insert x s, xtâŸ©\n  exact (differentiable_within_at_inter (is_open.mem_nhds t_open xt)).1 this\n#align cont_diff_within_at.differentiable_within_at' cont_diff_within_at.differentiable_within_at'\n\n",
 "differentiable_within_at":
 "theorem cont_diff_within_at.differentiable_within_at (h : cont_diff_within_at ğ•œ n f s x) (hn : 1 â‰¤ n) :\n    differentiable_within_at ğ•œ f s x :=\n  (h.differentiable_within_at' hn).mono (subset_insert x s)\n#align cont_diff_within_at.differentiable_within_at cont_diff_within_at.differentiable_within_at\n\n",
 "differentiable_on_iterated_fderiv_within":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ„•âˆÂ» -/\ntheorem cont_diff_on.differentiable_on_iterated_fderiv_within {m : â„•} (h : cont_diff_on ğ•œ n f s)\n    (hmn : (m : Â«exprâ„•âˆÂ») < n) (hs : unique_diff_on ğ•œ s) : differentiable_on ğ•œ (iterated_fderiv_within ğ•œ m f s) s :=\n  fun x hx => ((h.ftaylor_series_within hs).fderiv_within m hmn x hx).differentiable_within_at\n#align cont_diff_on.differentiable_on_iterated_fderiv_within cont_diff_on.differentiable_on_iterated_fderiv_within\n\n",
 "differentiable_on":
 "/-- If a function is `C^n` on a set with `n â‰¥ 1`, then it is differentiable there. -/\ntheorem cont_diff_on.differentiable_on (h : cont_diff_on ğ•œ n f s) (hn : 1 â‰¤ n) : differentiable_on ğ•œ f s := fun x hx =>\n  (h x hx).differentiable_within_at hn\n#align cont_diff_on.differentiable_on cont_diff_on.differentiable_on\n\n",
 "differentiable_iterated_fderiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ„•âˆÂ» -/\n/-- If `f` is `C^n` then its `m`-times iterated derivative is differentiable for `m < n`. -/\ntheorem cont_diff.differentiable_iterated_fderiv {m : â„•} (hm : (m : Â«exprâ„•âˆÂ») < n) (hf : cont_diff ğ•œ n f) :\n    differentiable ğ•œ fun x => iterated_fderiv ğ•œ m f x :=\n  (cont_diff_iff_continuous_differentiable.mp hf).2 m hm\n#align cont_diff.differentiable_iterated_fderiv cont_diff.differentiable_iterated_fderiv\n\n",
 "differentiable_at":
 "/-- If a function is `C^n` with `n â‰¥ 1` at a point, then it is differentiable there. -/\ntheorem cont_diff_at.differentiable_at (h : cont_diff_at ğ•œ n f x) (hn : 1 â‰¤ n) : differentiable_at ğ•œ f x := by\n  simpa [hn, differentiable_within_at_univ] using h.differentiable_within_at\n#align cont_diff_at.differentiable_at cont_diff_at.differentiable_at\n\n",
 "differentiable":
 "/-- If a function is `C^n` with `n â‰¥ 1`, then it is differentiable. -/\ntheorem cont_diff.differentiable (h : cont_diff ğ•œ n f) (hn : 1 â‰¤ n) : differentiable ğ•œ f :=\n  differentiable_on_univ.1 <| (cont_diff_on_univ.2 h).differentiable_on hn\n#align cont_diff.differentiable cont_diff.differentiable\n\n",
 "deriv_within":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ„•âˆÂ» -/\ntheorem cont_diff_on.deriv_within (hf : cont_diff_on ğ•œ n fâ‚‚ sâ‚‚) (hs : unique_diff_on ğ•œ sâ‚‚) (hmn : m + 1 â‰¤ n) :\n    cont_diff_on ğ•œ m (deriv_within fâ‚‚ sâ‚‚) sâ‚‚ := by\n  cases m\n  Â· change Â«exprâˆÂ» + 1 â‰¤ n at hmn\n    have : n = Â«exprâˆÂ» := by simpa using hmn\n    rw [this] at hf\n    exact ((cont_diff_on_top_iff_deriv_within hs).1 hf).2\n  Â· change (m.succ : Â«exprâ„•âˆÂ») â‰¤ n at hmn\n    exact ((cont_diff_on_succ_iff_deriv_within hs).1 (hf.of_le hmn)).2\n#align cont_diff_on.deriv_within cont_diff_on.deriv_within\n\n",
 "deriv_of_open":
 "theorem cont_diff_on.deriv_of_open (hf : cont_diff_on ğ•œ n fâ‚‚ sâ‚‚) (hs : is_open sâ‚‚) (hmn : m + 1 â‰¤ n) :\n    cont_diff_on ğ•œ m (deriv fâ‚‚) sâ‚‚ :=\n  (hf.deriv_within hs.unique_diff_on hmn).congr fun x hx => (deriv_within_of_open hs hx).symm\n#align cont_diff_on.deriv_of_open cont_diff_on.deriv_of_open\n\n",
 "continuous_within_at":
 "theorem cont_diff_within_at.continuous_within_at (h : cont_diff_within_at ğ•œ n f s x) : continuous_within_at f s x :=\n  by\n  rcases h 0 bot_le with âŸ¨u, hu, p, HâŸ©\n  rw [mem_nhds_within_insert] at hu\n  exact (H.continuous_on.continuous_within_at hu.1).mono_of_mem hu.2\n#align cont_diff_within_at.continuous_within_at cont_diff_within_at.continuous_within_at\n\n",
 "continuous_on_iterated_fderiv_within":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ„•âˆÂ» -/\ntheorem cont_diff_on.continuous_on_iterated_fderiv_within {m : â„•} (h : cont_diff_on ğ•œ n f s) (hmn : (m : Â«exprâ„•âˆÂ») â‰¤ n)\n    (hs : unique_diff_on ğ•œ s) : continuous_on (iterated_fderiv_within ğ•œ m f s) s :=\n  (h.ftaylor_series_within hs).cont m hmn\n#align cont_diff_on.continuous_on_iterated_fderiv_within cont_diff_on.continuous_on_iterated_fderiv_within\n\n",
 "continuous_on_fderiv_within_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n/-- If a function is at least `C^1`, its bundled derivative (mapping `(x, v)` to `Df(x) v`) is\ncontinuous. -/\ntheorem cont_diff_on.continuous_on_fderiv_within_apply (hf : cont_diff_on ğ•œ n f s) (hs : unique_diff_on ğ•œ s)\n    (hn : 1 â‰¤ n) : continuous_on (fun p : E Ã— E => (fderiv_within ğ•œ f s p.1 : E â†’ F) p.2) (lower_set.prod s univ) :=\n  (cont_diff_on_fderiv_within_apply hf hs <| by rwa [zero_add]).continuous_on\n#align cont_diff_on.continuous_on_fderiv_within_apply cont_diff_on.continuous_on_fderiv_within_apply\n\n",
 "continuous_on_fderiv_within":
 "theorem cont_diff_on.continuous_on_fderiv_within (h : cont_diff_on ğ•œ n f s) (hs : unique_diff_on ğ•œ s) (hn : 1 â‰¤ n) :\n    continuous_on (fun x => fderiv_within ğ•œ f s x) s :=\n  ((cont_diff_on_succ_iff_fderiv_within hs).1 (h.of_le hn)).2.continuous_on\n#align cont_diff_on.continuous_on_fderiv_within cont_diff_on.continuous_on_fderiv_within\n\n",
 "continuous_on_fderiv_of_open":
 "theorem cont_diff_on.continuous_on_fderiv_of_open (h : cont_diff_on ğ•œ n f s) (hs : is_open s) (hn : 1 â‰¤ n) :\n    continuous_on (fun x => fderiv ğ•œ f x) s :=\n  ((cont_diff_on_succ_iff_fderiv_of_open hs).1 (h.of_le hn)).2.continuous_on\n#align cont_diff_on.continuous_on_fderiv_of_open cont_diff_on.continuous_on_fderiv_of_open\n\n",
 "continuous_on_deriv_within":
 "theorem cont_diff_on.continuous_on_deriv_within (h : cont_diff_on ğ•œ n fâ‚‚ sâ‚‚) (hs : unique_diff_on ğ•œ sâ‚‚) (hn : 1 â‰¤ n) :\n    continuous_on (deriv_within fâ‚‚ sâ‚‚) sâ‚‚ :=\n  ((cont_diff_on_succ_iff_deriv_within hs).1 (h.of_le hn)).2.continuous_on\n#align cont_diff_on.continuous_on_deriv_within cont_diff_on.continuous_on_deriv_within\n\n",
 "continuous_on_deriv_of_open":
 "theorem cont_diff_on.continuous_on_deriv_of_open (h : cont_diff_on ğ•œ n fâ‚‚ sâ‚‚) (hs : is_open sâ‚‚) (hn : 1 â‰¤ n) :\n    continuous_on (deriv fâ‚‚) sâ‚‚ :=\n  ((cont_diff_on_succ_iff_deriv_of_open hs).1 (h.of_le hn)).2.continuous_on\n#align cont_diff_on.continuous_on_deriv_of_open cont_diff_on.continuous_on_deriv_of_open\n\n",
 "continuous_on":
 "theorem cont_diff_on.continuous_on (h : cont_diff_on ğ•œ n f s) : continuous_on f s := fun x hx =>\n  (h x hx).continuous_within_at\n#align cont_diff_on.continuous_on cont_diff_on.continuous_on\n\n",
 "continuous_linear_map_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/-- Composition by continuous linear maps on the left preserves `C^n` functions. -/\ntheorem cont_diff.continuous_linear_map_comp {f : E â†’ F} (g : Â«expr â†’L[ ] Â» F ğ•œ G) (hf : cont_diff ğ•œ n f) :\n    cont_diff ğ•œ n fun x => g (f x) :=\n  cont_diff_on_univ.1 <| cont_diff_on.continuous_linear_map_comp _ (cont_diff_on_univ.2 hf)\n#align cont_diff.continuous_linear_map_comp cont_diff.continuous_linear_map_comp\n\n",
 "continuous_iterated_fderiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ„•âˆÂ» -/\n/-- If `f` is `C^n` then its `m`-times iterated derivative is continuous for `m â‰¤ n`. -/\ntheorem cont_diff.continuous_iterated_fderiv {m : â„•} (hm : (m : Â«exprâ„•âˆÂ») â‰¤ n) (hf : cont_diff ğ•œ n f) :\n    continuous fun x => iterated_fderiv ğ•œ m f x :=\n  (cont_diff_iff_continuous_differentiable.mp hf).1 m hm\n#align cont_diff.continuous_iterated_fderiv cont_diff.continuous_iterated_fderiv\n\n",
 "continuous_fderiv_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/-- If a function is at least `C^1`, its bundled derivative (mapping `(x, v)` to `Df(x) v`) is\ncontinuous. -/\ntheorem cont_diff.continuous_fderiv_apply (h : cont_diff ğ•œ n f) (hn : 1 â‰¤ n) :\n    continuous fun p : E Ã— E => (fderiv ğ•œ f p.1 : E â†’ F) p.2 :=\n  have A : continuous fun q : Â«expr â†’L[ ] Â» E ğ•œ F Ã— E => q.1 q.2 := is_bounded_bilinear_map_apply.continuous\n  have B : continuous fun p : E Ã— E => (fderiv ğ•œ f p.1, p.2) :=\n    ((h.continuous_fderiv hn).comp continuous_fst).prod_mk continuous_snd\n  A.comp B\n#align cont_diff.continuous_fderiv_apply cont_diff.continuous_fderiv_apply\n\n",
 "continuous_fderiv":
 "theorem cont_diff.continuous_fderiv (h : cont_diff ğ•œ n f) (hn : 1 â‰¤ n) : continuous fun x => fderiv ğ•œ f x :=\n  (cont_diff_succ_iff_fderiv.1 (h.of_le hn)).2.continuous\n#align cont_diff.continuous_fderiv cont_diff.continuous_fderiv\n\n",
 "continuous_deriv":
 "theorem cont_diff.continuous_deriv (h : cont_diff ğ•œ n fâ‚‚) (hn : 1 â‰¤ n) : continuous (deriv fâ‚‚) :=\n  (cont_diff_succ_iff_deriv.mp (h.of_le hn)).2.continuous\n#align cont_diff.continuous_deriv cont_diff.continuous_deriv\n\n",
 "continuous_at":
 "theorem cont_diff_at.continuous_at (h : cont_diff_at ğ•œ n f x) : continuous_at f x := by\n  simpa [continuous_within_at_univ] using h.continuous_within_at\n#align cont_diff_at.continuous_at cont_diff_at.continuous_at\n\n",
 "continuous":
 "theorem cont_diff.continuous (h : cont_diff ğ•œ n f) : continuous f :=\n  cont_diff_zero.1 (h.of_le bot_le)\n#align cont_diff.continuous cont_diff.continuous\n\n",
 "cont_diff_zero_fun":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr [Ã— ]â†’L[ ] Â» -/\ntheorem cont_diff_zero_fun : cont_diff ğ•œ n fun x : E => (0 : F) :=\n  by\n  apply cont_diff_of_differentiable_iterated_fderiv fun m hm => _\n  rw [iterated_fderiv_zero_fun]\n  exact differentiable_const (0 : Â«expr [Ã— ]â†’L[ ] Â» E m ğ•œ F)\n#align cont_diff_zero_fun cont_diff_zero_fun\n\n",
 "cont_diff_zero":
 "@[simp]\ntheorem cont_diff_zero : cont_diff ğ•œ 0 f â†” continuous f :=\n  by\n  rw [â† cont_diff_on_univ, continuous_iff_continuous_on_univ]\n  exact cont_diff_on_zero\n#align cont_diff_zero cont_diff_zero\n\n",
 "cont_diff_within_at_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\ntheorem cont_diff_within_at_zero (hx : x âˆˆ s) :\n    cont_diff_within_at ğ•œ 0 f s x â†” âˆƒ u âˆˆ nhds_within s x, continuous_on f (s âˆ© u) :=\n  by\n  constructor\n  Â· intro h\n    obtain âŸ¨u, H, p, hpâŸ© := h 0 (by norm_num)\n    refine' âŸ¨u, _, _âŸ©\n    Â· simpa [hx] using H\n    Â· simp only [with_top.coe_zero, has_ftaylor_series_up_to_on_zero_iff] at hp\n      exact hp.1.mono (inter_subset_right s u)\n  Â· rintro âŸ¨u, H, huâŸ©\n    rw [â† cont_diff_within_at_inter' H]\n    have h' : x âˆˆ s âˆ© u := âŸ¨hx, mem_of_mem_nhds_within hx HâŸ©\n    exact (cont_diff_on_zero.mpr hu).cont_diff_within_at h'\n#align cont_diff_within_at_zero cont_diff_within_at_zero\n\n",
 "cont_diff_within_at_univ":
 "theorem cont_diff_within_at_univ : cont_diff_within_at ğ•œ n f univ x â†” cont_diff_at ğ•œ n f x :=\n  iff.rfl\n#align cont_diff_within_at_univ cont_diff_within_at_univ\n\n",
 "cont_diff_within_at_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆÂ» -/\ntheorem cont_diff_within_at_top : cont_diff_within_at ğ•œ (Â«exprâˆÂ») f s x â†” âˆ€ n : â„•, cont_diff_within_at ğ•œ n f s x :=\n  cont_diff_within_at_iff_forall_nat_le.trans <| by simp only [forall_prop_of_true, le_top]\n#align cont_diff_within_at_top cont_diff_within_at_top\n\n",
 "cont_diff_within_at_succ_iff_has_fderiv_within_at'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/-- A version of `cont_diff_within_at_succ_iff_has_fderiv_within_at` where all derivatives\n  are taken within the same set. -/\ntheorem cont_diff_within_at_succ_iff_has_fderiv_within_at' {n : â„•} :\n    cont_diff_within_at ğ•œ (n + 1 : â„•) f s x â†”\n      âˆƒ u âˆˆ nhds_within (insert x s) x,\n        u âŠ† insert x s âˆ§\n          âˆƒ f' : E â†’ Â«expr â†’L[ ] Â» E ğ•œ F,\n            (âˆ€ x âˆˆ u, has_fderiv_within_at f (f' x) s x) âˆ§ cont_diff_within_at ğ•œ n f' s x :=\n  by\n  refine' âŸ¨fun hf => _, _âŸ©\n  Â· obtain âŸ¨u, hu, f', huf', hf'âŸ© := cont_diff_within_at_succ_iff_has_fderiv_within_at.mp hf\n    obtain âŸ¨w, hw, hxw, hwuâŸ© := mem_nhds_within.mp hu\n    rw [inter_comm] at hwu\n    refine' âŸ¨insert x s âˆ© w, inter_mem_nhds_within _ (hw.mem_nhds hxw), inter_subset_left _ _, f', fun y hy => _, _âŸ©\n    Â· refine' ((huf' y <| hwu hy).mono hwu).mono_of_mem _\n      refine' mem_of_superset _ (inter_subset_inter_left _ (subset_insert _ _))\n      refine' inter_mem_nhds_within _ (hw.mem_nhds hy.2)\n    Â· exact hf'.mono_of_mem (nhds_within_mono _ (subset_insert _ _) hu)\n  Â· rw [â† cont_diff_within_at_insert, cont_diff_within_at_succ_iff_has_fderiv_within_at,\n      insert_eq_of_mem (mem_insert _ _)]\n    rintro âŸ¨u, hu, hus, f', huf', hf'âŸ©\n    refine' âŸ¨u, hu, f', fun y hy => (huf' y hy).insert'.mono hus, hf'.insert.mono husâŸ©\n#align cont_diff_within_at_succ_iff_has_fderiv_within_at' cont_diff_within_at_succ_iff_has_fderiv_within_at'\n\n",
 "cont_diff_within_at_succ_iff_has_fderiv_within_at":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/-- A function is `C^(n + 1)` on a domain iff locally, it has a derivative which is `C^n`. -/\ntheorem cont_diff_within_at_succ_iff_has_fderiv_within_at {n : â„•} :\n    cont_diff_within_at ğ•œ (n + 1 : â„•) f s x â†”\n      âˆƒ u âˆˆ nhds_within (insert x s) x,\n        âˆƒ f' : E â†’ Â«expr â†’L[ ] Â» E ğ•œ F, (âˆ€ x âˆˆ u, has_fderiv_within_at f (f' x) u x) âˆ§ cont_diff_within_at ğ•œ n f' u x :=\n  by\n  constructor\n  Â· intro h\n    rcases h n.succ le_rfl with âŸ¨u, hu, p, HpâŸ©\n    refine'\n      âŸ¨u, hu, fun y => (continuous_multilinear_curry_fin1 ğ•œ E F) (p y 1), fun y hy =>\n        Hp.has_fderiv_within_at (WithTop.coe_le_coe.2 (nat.le_add_left 1 n)) hy, _âŸ©\n    intro m hm\n    refine' âŸ¨u, _, fun y : E => (p y).shift, _âŸ©\n    Â· convert self_mem_nhds_within\n      have : x âˆˆ insert x s := by simp\n      exact insert_eq_of_mem (mem_of_mem_nhds_within this hu)\n    Â· rw [has_ftaylor_series_up_to_on_succ_iff_right] at Hp\n      exact Hp.2.2.of_le hm\n  Â· rintro âŸ¨u, hu, f', f'_eq_deriv, Hf'âŸ©\n    rw [cont_diff_within_at_nat]\n    rcases Hf' n le_rfl with âŸ¨v, hv, p', Hp'âŸ©\n    refine' âŸ¨v âˆ© u, _, fun x => (p' x).unshift (f x), _âŸ©\n    Â· apply filter.inter_mem _ hu\n      apply nhds_within_le_of_mem hu\n      exact nhds_within_mono _ (subset_insert x u) hv\n    Â· rw [has_ftaylor_series_up_to_on_succ_iff_right]\n      refine' âŸ¨fun y hy => rfl, fun y hy => _, _âŸ©\n      Â· change\n          has_fderiv_within_at (fun z => (continuous_multilinear_curry_fin0 ğ•œ E F).symm (f z))\n            (formal_multilinear_series.unshift (p' y) (f y) 1).curry_left (v âˆ© u) y\n        rw [linear_isometry_equiv.comp_has_fderiv_within_at_iff']\n        convert (f'_eq_deriv y hy.2).mono (inter_subset_right v u)\n        rw [â† Hp'.zero_eq y hy.1]\n        ext z\n        change ((p' y 0) (init (@cons 0 (fun i => E) z 0))) (@cons 0 (fun i => E) z 0 (last 0)) = ((p' y 0) 0) z\n        unfold_coes\n        congr\n      Â· convert (Hp'.mono (inter_subset_left v u)).congr fun x hx => Hp'.zero_eq x hx.1\n        Â· ext (x y)\n          change p' x 0 (init (@snoc 0 (fun i : fin 1 => E) 0 y)) y = p' x 0 0 y\n          rw [init_snoc]\n        Â· ext (x k v y)\n          change\n            p' x k (init (@snoc k (fun i : fin k.succ => E) v y)) (@snoc k (fun i : fin k.succ => E) v y (last k)) =\n              p' x k v y\n          rw [snoc_last, init_snoc]\n#align cont_diff_within_at_succ_iff_has_fderiv_within_at cont_diff_within_at_succ_iff_has_fderiv_within_at\n\n",
 "cont_diff_within_at_snd":
 "/-- The second projection within a domain at a point in a product is `C^âˆ`. -/\ntheorem cont_diff_within_at_snd {s : set (E Ã— F)} {p : E Ã— F} : cont_diff_within_at ğ•œ n (prod.snd : E Ã— F â†’ F) s p :=\n  cont_diff_snd.cont_diff_within_at\n#align cont_diff_within_at_snd cont_diff_within_at_snd\n\n",
 "cont_diff_within_at_prod'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\ntheorem cont_diff_within_at_prod' {t : Finset Î¹} {f : Î¹ â†’ E â†’ ğ”¸'} (h : âˆ€ i âˆˆ t, cont_diff_within_at ğ•œ n (f i) s x) :\n    cont_diff_within_at ğ•œ n\n      (finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" t (f i)) s x :=\n  finset.prod_induction f (fun f => cont_diff_within_at ğ•œ n f s x) (fun _ _ => cont_diff_within_at.mul)\n    (@cont_diff_within_at_const _ _ _ _ _ _ _ _ _ _ _ 1) h\n#align cont_diff_within_at_prod' cont_diff_within_at_prod'\n\n",
 "cont_diff_within_at_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\ntheorem cont_diff_within_at_prod {t : Finset Î¹} {f : Î¹ â†’ E â†’ ğ”¸'} (h : âˆ€ i âˆˆ t, cont_diff_within_at ğ•œ n (f i) s x) :\n    cont_diff_within_at ğ•œ n\n      (fun y =>\n        finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" t (f i y))\n      s x :=\n  by simpa only [â† finset.prod_apply] using cont_diff_within_at_prod' h\n#align cont_diff_within_at_prod cont_diff_within_at_prod\n\n",
 "cont_diff_within_at_pi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹‚ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹‚ , Â» -/\ntheorem cont_diff_within_at_pi : cont_diff_within_at ğ•œ n Î¦ s x â†” âˆ€ i, cont_diff_within_at ğ•œ n (fun x => Î¦ x i) s x :=\n  by\n  set pr := @continuous_linear_map.proj ğ•œ _ Î¹ F' _ _ _\n  refine' âŸ¨fun h i => h.continuous_linear_map_comp (pr i), fun h m hm => _âŸ©\n  choose u hux p hp using fun i => h i m hm\n  exact\n    âŸ¨Â«exprâ‹‚ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹‚ , Â»\" (u i),\n      filter.Inter_mem.2 hux, _, has_ftaylor_series_up_to_on_pi.2 fun i => (hp i).mono <| Inter_subset _ _âŸ©\n#align cont_diff_within_at_pi cont_diff_within_at_pi\n\n",
 "cont_diff_within_at_of_subsingleton":
 "@[nontriviality]\ntheorem cont_diff_within_at_of_subsingleton [subsingleton F] : cont_diff_within_at ğ•œ n f s x :=\n  by\n  rw [subsingleton.elim f fun _ => 0]\n  exact cont_diff_within_at_const\n#align cont_diff_within_at_of_subsingleton cont_diff_within_at_of_subsingleton\n\n",
 "cont_diff_within_at_nat":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\ntheorem cont_diff_within_at_nat {n : â„•} :\n    cont_diff_within_at ğ•œ n f s x â†”\n      âˆƒ u âˆˆ nhds_within (insert x s) x,\n        âˆƒ p : E â†’ formal_multilinear_series ğ•œ E F, has_ftaylor_series_up_to_on n f p u :=\n  âŸ¨fun H => H n le_rfl, fun âŸ¨u, hu, p, hpâŸ© m hm => âŸ¨u, hu, p, hp.of_le hmâŸ©âŸ©\n#align cont_diff_within_at_nat cont_diff_within_at_nat\n\n",
 "cont_diff_within_at_inter'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\ntheorem cont_diff_within_at_inter' (h : t âˆˆ nhds_within s x) :\n    cont_diff_within_at ğ•œ n f (s âˆ© t) x â†” cont_diff_within_at ğ•œ n f s x :=\n  cont_diff_within_at_congr_nhds <| eq.symm <| nhds_within_restrict'' _ h\n#align cont_diff_within_at_inter' cont_diff_within_at_inter'\n\n",
 "cont_diff_within_at_inter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem cont_diff_within_at_inter (h : t âˆˆ (nhds) x) :\n    cont_diff_within_at ğ•œ n f (s âˆ© t) x â†” cont_diff_within_at ğ•œ n f s x :=\n  cont_diff_within_at_inter' (mem_nhds_within_of_mem_nhds h)\n#align cont_diff_within_at_inter cont_diff_within_at_inter\n\n",
 "cont_diff_within_at_insert":
 "theorem cont_diff_within_at_insert {y : E} : cont_diff_within_at ğ•œ n f (insert y s) x â†” cont_diff_within_at ğ•œ n f s x :=\n  by\n  simp_rw [cont_diff_within_at]\n  rcases eq_or_ne x y with (rfl | h)\n  Â· simp_rw [insert_eq_of_mem (mem_insert _ _)]\n  simp_rw [insert_comm x y, nhds_within_insert_of_ne h]\n#align cont_diff_within_at_insert cont_diff_within_at_insert\n\n",
 "cont_diff_within_at_iff_forall_nat_le":
 "theorem cont_diff_within_at_iff_forall_nat_le :\n    cont_diff_within_at ğ•œ n f s x â†” âˆ€ m : â„•, â†‘m â‰¤ n â†’ cont_diff_within_at ğ•œ m f s x :=\n  âŸ¨fun H m hm => H.of_le hm, fun H m hm => H m hm _ le_rflâŸ©\n#align cont_diff_within_at_iff_forall_nat_le cont_diff_within_at_iff_forall_nat_le\n\n",
 "cont_diff_within_at_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr =á¶ [ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\ntheorem filter.eventually_eq.cont_diff_within_at_iff (hâ‚ : Â«expr =á¶ [ ] Â» fâ‚ (nhds_within s x) f) (hx : fâ‚ x = f x) :\n    cont_diff_within_at ğ•œ n fâ‚ s x â†” cont_diff_within_at ğ•œ n f s x :=\n  âŸ¨fun H => cont_diff_within_at.congr_of_eventually_eq H hâ‚.symm hx.symm, fun H => H.congr_of_eventually_eq hâ‚ hxâŸ©\n#align filter.eventually_eq.cont_diff_within_at_iff filter.eventually_eq.cont_diff_within_at_iff\n\n",
 "cont_diff_within_at_id":
 "theorem cont_diff_within_at_id {s x} : cont_diff_within_at ğ•œ n (id : E â†’ E) s x :=\n  cont_diff_id.cont_diff_within_at\n#align cont_diff_within_at_id cont_diff_within_at_id\n\n",
 "cont_diff_within_at_fst":
 "/-- The first projection within a domain at a point in a product is `C^âˆ`. -/\ntheorem cont_diff_within_at_fst {s : set (E Ã— F)} {p : E Ã— F} : cont_diff_within_at ğ•œ n (prod.fst : E Ã— F â†’ E) s p :=\n  cont_diff_fst.cont_diff_within_at\n#align cont_diff_within_at_fst cont_diff_within_at_fst\n\n",
 "cont_diff_within_at_const":
 "theorem cont_diff_within_at_const {c : F} : cont_diff_within_at ğ•œ n (fun x : E => c) s x :=\n  cont_diff_at_const.cont_diff_within_at\n#align cont_diff_within_at_const cont_diff_within_at_const\n\n",
 "cont_diff_within_at_congr_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\ntheorem cont_diff_within_at_congr_nhds {t : set E} (hst : nhds_within s x = nhds_within t x) :\n    cont_diff_within_at ğ•œ n f s x â†” cont_diff_within_at ğ•œ n f t x :=\n  âŸ¨fun h => h.congr_nhds hst, fun h => h.congr_nhds hst.symmâŸ©\n#align cont_diff_within_at_congr_nhds cont_diff_within_at_congr_nhds\n\n",
 "cont_diff_within_at_comp_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰ƒL[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/-- Composition by continuous linear equivs on the right respects higher differentiability at a\npoint in a domain. -/\ntheorem continuous_linear_equiv.cont_diff_within_at_comp_iff (e : Â«expr â‰ƒL[ ] Â» G ğ•œ E) :\n    cont_diff_within_at ğ•œ n (f âˆ˜ e) (Â«expr â»Â¹' Â» e s) (e.symm x) â†” cont_diff_within_at ğ•œ n f s x :=\n  by\n  constructor\n  Â· intro H\n    simpa [â† preimage_comp, (Â· âˆ˜ Â·)] using H.comp_continuous_linear_map (e.symm : Â«expr â†’L[ ] Â» E ğ•œ G)\n  Â· intro H\n    rw [â† e.apply_symm_apply x, â† e.coe_coe] at H\n    exact H.comp_continuous_linear_map _\n#align continuous_linear_equiv.cont_diff_within_at_comp_iff continuous_linear_equiv.cont_diff_within_at_comp_iff\n\n",
 "cont_diff_within_at":
 "theorem cont_diff.cont_diff_within_at (h : cont_diff ğ•œ n f) : cont_diff_within_at ğ•œ n f s x :=\n  h.cont_diff_at.cont_diff_within_at\n#align cont_diff.cont_diff_within_at cont_diff.cont_diff_within_at\n\n",
 "cont_diff_top_iff_fderiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆÂ» -/\n/-- A function is `C^âˆ` if and only if it is differentiable,\nand its derivative (formulated in terms of `fderiv`) is `C^âˆ`. -/\ntheorem cont_diff_top_iff_fderiv :\n    cont_diff ğ•œ (Â«exprâˆÂ») f â†” differentiable ğ•œ f âˆ§ cont_diff ğ•œ (Â«exprâˆÂ») fun y => fderiv ğ•œ f y :=\n  by\n  simp only [â† cont_diff_on_univ, â† differentiable_on_univ, â† fderiv_within_univ]\n  rw [cont_diff_on_top_iff_fderiv_within unique_diff_on_univ]\n#align cont_diff_top_iff_fderiv cont_diff_top_iff_fderiv\n\n",
 "cont_diff_top_iff_deriv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆÂ» -/\n/-- A function is `C^âˆ` if and only if it is differentiable,\nand its derivative (formulated in terms of `deriv`) is `C^âˆ`. -/\ntheorem cont_diff_top_iff_deriv : cont_diff ğ•œ (Â«exprâˆÂ») fâ‚‚ â†” differentiable ğ•œ fâ‚‚ âˆ§ cont_diff ğ•œ (Â«exprâˆÂ») (deriv fâ‚‚) :=\n  by\n  simp only [â† cont_diff_on_univ, â† differentiable_on_univ, â† deriv_within_univ]\n  rw [cont_diff_on_top_iff_deriv_within unique_diff_on_univ]\n#align cont_diff_top_iff_deriv cont_diff_top_iff_deriv\n\n",
 "cont_diff_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆÂ» -/\ntheorem cont_diff_top : cont_diff ğ•œ (Â«exprâˆÂ») f â†” âˆ€ n : â„•, cont_diff ğ•œ n f := by\n  simp [cont_diff_on_univ.symm, cont_diff_on_top]\n#align cont_diff_top cont_diff_top\n\n",
 "cont_diff_symm_deriv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰ƒâ‚œ Â» -/\n/-- Let `f` be an `n` times continuously differentiable homeomorphism of a nontrivially normed\nfield.  Suppose that the derivative of `f` is never equal to zero. Then `f.symm` is `n` times\ncontinuously differentiable.\n\nThis is one of the easy parts of the inverse function theorem: it assumes that we already have\nan inverse function. -/\ntheorem homeomorph.cont_diff_symm_deriv [complete_space ğ•œ] (f : Â«expr â‰ƒâ‚œ Â» ğ•œ ğ•œ) {f' : ğ•œ â†’ ğ•œ} (hâ‚€ : âˆ€ x, f' x â‰  0)\n    (hf' : âˆ€ x, has_deriv_at f (f' x) x) (hf : cont_diff ğ•œ n (f : ğ•œ â†’ ğ•œ)) : cont_diff ğ•œ n (f.symm : ğ•œ â†’ ğ•œ) :=\n  cont_diff_iff_cont_diff_at.2 fun x =>\n    f.to_local_homeomorph.cont_diff_at_symm_deriv (hâ‚€ _) (mem_univ x) (hf' _) hf.cont_diff_at\n#align homeomorph.cont_diff_symm_deriv homeomorph.cont_diff_symm_deriv\n\n",
 "cont_diff_symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰ƒâ‚œ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰ƒL[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/-- If `f` is an `n` times continuously differentiable homeomorphism,\nand if the derivative of `f` at each point is a continuous linear equivalence,\nthen `f.symm` is `n` times continuously differentiable.\n\nThis is one of the easy parts of the inverse function theorem: it assumes that we already have\nan inverse function. -/\ntheorem homeomorph.cont_diff_symm [complete_space E] (f : Â«expr â‰ƒâ‚œ Â» E F) {fâ‚€' : E â†’ Â«expr â‰ƒL[ ] Â» E ğ•œ F}\n    (hfâ‚€' : âˆ€ a, has_fderiv_at f (fâ‚€' a : Â«expr â†’L[ ] Â» E ğ•œ F) a) (hf : cont_diff ğ•œ n (f : E â†’ F)) :\n    cont_diff ğ•œ n (f.symm : F â†’ E) :=\n  cont_diff_iff_cont_diff_at.2 fun x => f.to_local_homeomorph.cont_diff_at_symm (mem_univ x) (hfâ‚€' _) hf.cont_diff_at\n#align homeomorph.cont_diff_symm homeomorph.cont_diff_symm\n\n",
 "cont_diff_succ_iff_fderiv_apply":
 "/-- This is a useful lemma to prove that a certain operation preserves functions being `C^n`.\nWhen you do induction on `n`, this gives a useful characterization of a function being `C^(n+1)`,\nassuming you have already computed the derivative. The advantage of this version over\n`cont_diff_succ_iff_fderiv` is that both occurences of `cont_diff` are for functions with the same\ndomain and codomain (`E` and `F`). This is not the case for `cont_diff_succ_iff_fderiv`, which\noften requires an inconvenient need to generalize `F`, which results in universe issues\n(see the discussion in the section of `cont_diff.comp`).\n\nThis lemma avoids these universe issues, but only applies for finite dimensional `E`. -/\ntheorem cont_diff_succ_iff_fderiv_apply [finite_dimensional ğ•œ E] {n : â„•} {f : E â†’ F} :\n    cont_diff ğ•œ (n + 1 : â„•) f â†” differentiable ğ•œ f âˆ§ âˆ€ y, cont_diff ğ•œ n fun x => fderiv ğ•œ f x y := by\n  rw [cont_diff_succ_iff_fderiv, cont_diff_clm_apply_iff]\n#align cont_diff_succ_iff_fderiv_apply cont_diff_succ_iff_fderiv_apply\n\n",
 "cont_diff_succ_iff_fderiv":
 "/-- A function is `C^(n + 1)` if and only if it is differentiable,\nand its derivative (formulated in terms of `fderiv`) is `C^n`. -/\ntheorem cont_diff_succ_iff_fderiv {n : â„•} :\n    cont_diff ğ•œ (n + 1 : â„•) f â†” differentiable ğ•œ f âˆ§ cont_diff ğ•œ n fun y => fderiv ğ•œ f y := by\n  simp only [â† cont_diff_on_univ, â† differentiable_on_univ, â† fderiv_within_univ,\n    cont_diff_on_succ_iff_fderiv_within unique_diff_on_univ]\n#align cont_diff_succ_iff_fderiv cont_diff_succ_iff_fderiv\n\n",
 "cont_diff_succ_iff_deriv":
 "/-- A function is `C^(n + 1)` if and only if it is differentiable,\n  and its derivative (formulated in terms of `deriv`) is `C^n`. -/\ntheorem cont_diff_succ_iff_deriv {n : â„•} :\n    cont_diff ğ•œ (n + 1 : â„•) fâ‚‚ â†” differentiable ğ•œ fâ‚‚ âˆ§ cont_diff ğ•œ n (deriv fâ‚‚) := by\n  simp only [â† cont_diff_on_univ, cont_diff_on_succ_iff_deriv_of_open, is_open_univ, differentiable_on_univ]\n#align cont_diff_succ_iff_deriv cont_diff_succ_iff_deriv\n\n",
 "cont_diff_snd":
 "/-- The second projection in a product is `C^âˆ`. -/\ntheorem cont_diff_snd : cont_diff ğ•œ n (prod.snd : E Ã— F â†’ F) :=\n  is_bounded_linear_map.cont_diff is_bounded_linear_map.snd\n#align cont_diff_snd cont_diff_snd\n\n",
 "cont_diff_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n-- The scalar multiplication is smooth.\ntheorem cont_diff_smul : cont_diff ğ•œ n fun p : ğ•œ Ã— F => Â«expr â€¢ Â» p.1 p.2 :=\n  is_bounded_bilinear_map_smul.cont_diff\n#align cont_diff_smul cont_diff_smul\n\n",
 "cont_diff_prod_mk_right":
 "theorem cont_diff_prod_mk_right (eâ‚€ : E) : cont_diff ğ•œ n fun f : F => (eâ‚€, f) :=\n  cont_diff_const.prod cont_diff_id\n#align cont_diff_prod_mk_right cont_diff_prod_mk_right\n\n",
 "cont_diff_prod_mk_left":
 "theorem cont_diff_prod_mk_left (fâ‚€ : F) : cont_diff ğ•œ n fun e : E => (e, fâ‚€) :=\n  cont_diff_id.prod cont_diff_const\n#align cont_diff_prod_mk_left cont_diff_prod_mk_left\n\n",
 "cont_diff_prod_assoc_symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\n/-- The natural equivalence `E Ã— (F Ã— G) â‰ƒ (E Ã— F) Ã— G` is smooth.\n\nWarning: see remarks attached to `cont_diff_prod_assoc`\n-/\ntheorem cont_diff_prod_assoc_symm : cont_diff ğ•œ (Â«exprâŠ¤Â») <| (Equiv.prodAssoc E F G).symm :=\n  (linear_isometry_equiv.prod_assoc ğ•œ E F G).symm.cont_diff\n#align cont_diff_prod_assoc_symm cont_diff_prod_assoc_symm\n\n",
 "cont_diff_prod_assoc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\n/-- The natural equivalence `(E Ã— F) Ã— G â‰ƒ E Ã— (F Ã— G)` is smooth.\n\nWarning: if you think you need this lemma, it is likely that you can simplify your proof by\nreformulating the lemma that you're applying next using the tips in\nNote [continuity lemma statement]\n-/\ntheorem cont_diff_prod_assoc : cont_diff ğ•œ (Â«exprâŠ¤Â») <| Equiv.prodAssoc E F G :=\n  (linear_isometry_equiv.prod_assoc ğ•œ E F G).cont_diff\n#align cont_diff_prod_assoc cont_diff_prod_assoc\n\n",
 "cont_diff_prod'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\ntheorem cont_diff_prod' {t : Finset Î¹} {f : Î¹ â†’ E â†’ ğ”¸'} (h : âˆ€ i âˆˆ t, cont_diff ğ•œ n (f i)) :\n    cont_diff ğ•œ n\n      (finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" t (f i)) :=\n  cont_diff_iff_cont_diff_at.mpr fun x => cont_diff_at_prod' fun i hi => (h i hi).cont_diff_at\n#align cont_diff_prod' cont_diff_prod'\n\n",
 "cont_diff_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\ntheorem cont_diff_prod {t : Finset Î¹} {f : Î¹ â†’ E â†’ ğ”¸'} (h : âˆ€ i âˆˆ t, cont_diff ğ•œ n (f i)) :\n    cont_diff ğ•œ n fun y =>\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" t (f i y) :=\n  cont_diff_iff_cont_diff_at.mpr fun x => cont_diff_at_prod fun i hi => (h i hi).cont_diff_at\n#align cont_diff_prod cont_diff_prod\n\n",
 "cont_diff_pi":
 "theorem cont_diff_pi : cont_diff ğ•œ n Î¦ â†” âˆ€ i, cont_diff ğ•œ n fun x => Î¦ x i := by\n  simp only [â† cont_diff_on_univ, cont_diff_on_pi]\n#align cont_diff_pi cont_diff_pi\n\n",
 "cont_diff_one_iff_fderiv":
 "theorem cont_diff_one_iff_fderiv : cont_diff ğ•œ 1 f â†” differentiable ğ•œ f âˆ§ continuous (fderiv ğ•œ f) :=\n  cont_diff_succ_iff_fderiv.trans <| iff.rfl.and cont_diff_zero\n#align cont_diff_one_iff_fderiv cont_diff_one_iff_fderiv\n\n",
 "cont_diff_one_iff_deriv":
 "theorem cont_diff_one_iff_deriv : cont_diff ğ•œ 1 fâ‚‚ â†” differentiable ğ•œ fâ‚‚ âˆ§ continuous (deriv fâ‚‚) :=\n  cont_diff_succ_iff_deriv.trans <| iff.rfl.and cont_diff_zero\n#align cont_diff_one_iff_deriv cont_diff_one_iff_deriv\n\n",
 "cont_diff_on_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ„•âˆÂ» -/\n@[simp]\ntheorem cont_diff_on_zero : cont_diff_on ğ•œ 0 f s â†” continuous_on f s :=\n  by\n  refine' âŸ¨fun H => H.continuous_on, fun H => _âŸ©\n  intro x hx m hm\n  have : (m : Â«exprâ„•âˆÂ») = 0 := le_antisymm hm bot_le\n  rw [this]\n  refine' âŸ¨insert x s, self_mem_nhds_within, ftaylor_series_within ğ•œ f s, _âŸ©\n  rw [has_ftaylor_series_up_to_on_zero_iff]\n  exact âŸ¨by rwa [insert_eq_of_mem hx], fun x hx => by simp [ftaylor_series_within]âŸ©\n#align cont_diff_on_zero cont_diff_on_zero\n\n",
 "cont_diff_on_univ":
 "theorem cont_diff_on_univ : cont_diff_on ğ•œ n f univ â†” cont_diff ğ•œ n f :=\n  by\n  constructor\n  Â· intro H\n    use ftaylor_series_within ğ•œ f univ\n    rw [â† has_ftaylor_series_up_to_on_univ_iff]\n    exact H.ftaylor_series_within unique_diff_on_univ\n  Â· rintro âŸ¨p, hpâŸ© x hx m hm\n    exact âŸ¨univ, filter.univ_sets _, p, (hp.has_ftaylor_series_up_to_on univ).of_le hmâŸ©\n#align cont_diff_on_univ cont_diff_on_univ\n\n",
 "cont_diff_on_top_iff_fderiv_within":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ„•âˆÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆÂ» -/\n/-- A function is `C^âˆ` on a domain with unique derivatives if and only if it is differentiable\nthere, and its derivative (expressed with `fderiv_within`) is `C^âˆ`. -/\ntheorem cont_diff_on_top_iff_fderiv_within (hs : unique_diff_on ğ•œ s) :\n    cont_diff_on ğ•œ (Â«exprâˆÂ») f s â†”\n      differentiable_on ğ•œ f s âˆ§ cont_diff_on ğ•œ (Â«exprâˆÂ») (fun y => fderiv_within ğ•œ f s y) s :=\n  by\n  constructor\n  Â· intro h\n    refine' âŸ¨h.differentiable_on le_top, _âŸ©\n    apply cont_diff_on_top.2 fun n => ((cont_diff_on_succ_iff_fderiv_within hs).1 _).2\n    exact h.of_le le_top\n  Â· intro h\n    refine' cont_diff_on_top.2 fun n => _\n    have A : (n : Â«exprâ„•âˆÂ») â‰¤ Â«exprâˆÂ» := le_top\n    apply ((cont_diff_on_succ_iff_fderiv_within hs).2 âŸ¨h.1, h.2.of_le AâŸ©).of_le\n    exact WithTop.coe_le_coe.2 (nat.le_succ n)\n#align cont_diff_on_top_iff_fderiv_within cont_diff_on_top_iff_fderiv_within\n\n",
 "cont_diff_on_top_iff_fderiv_of_open":
 "/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:76:14: unsupported tactic `congrm #[[expr Â«expr âˆ§ Â»(_, _)]] -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆÂ» -/\n/-- A function is `C^âˆ` on an open domain if and only if it is differentiable there, and its\nderivative (expressed with `fderiv`) is `C^âˆ`. -/\ntheorem cont_diff_on_top_iff_fderiv_of_open (hs : is_open s) :\n    cont_diff_on ğ•œ (Â«exprâˆÂ») f s â†” differentiable_on ğ•œ f s âˆ§ cont_diff_on ğ•œ (Â«exprâˆÂ») (fun y => fderiv ğ•œ f y) s :=\n  by\n  rw [cont_diff_on_top_iff_fderiv_within hs.unique_diff_on]\n  trace\n    \"./././Mathport/Syntax/Translate/Tactic/Builtin.lean:76:14: unsupported tactic `congrm #[[expr Â«expr âˆ§ Â»(_, _)]]\"\n  apply cont_diff_on_congr\n  intro x hx\n  exact fderiv_within_of_open hs hx\n#align cont_diff_on_top_iff_fderiv_of_open cont_diff_on_top_iff_fderiv_of_open\n\n",
 "cont_diff_on_top_iff_deriv_within":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ„•âˆÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆÂ» -/\n/-- A function is `C^âˆ` on a domain with unique derivatives if and only if it is differentiable\nthere, and its derivative (formulated with `deriv_within`) is `C^âˆ`. -/\ntheorem cont_diff_on_top_iff_deriv_within (hs : unique_diff_on ğ•œ sâ‚‚) :\n    cont_diff_on ğ•œ (Â«exprâˆÂ») fâ‚‚ sâ‚‚ â†” differentiable_on ğ•œ fâ‚‚ sâ‚‚ âˆ§ cont_diff_on ğ•œ (Â«exprâˆÂ») (deriv_within fâ‚‚ sâ‚‚) sâ‚‚ :=\n  by\n  constructor\n  Â· intro h\n    refine' âŸ¨h.differentiable_on le_top, _âŸ©\n    apply cont_diff_on_top.2 fun n => ((cont_diff_on_succ_iff_deriv_within hs).1 _).2\n    exact h.of_le le_top\n  Â· intro h\n    refine' cont_diff_on_top.2 fun n => _\n    have A : (n : Â«exprâ„•âˆÂ») â‰¤ Â«exprâˆÂ» := le_top\n    apply ((cont_diff_on_succ_iff_deriv_within hs).2 âŸ¨h.1, h.2.of_le AâŸ©).of_le\n    exact WithTop.coe_le_coe.2 (nat.le_succ n)\n#align cont_diff_on_top_iff_deriv_within cont_diff_on_top_iff_deriv_within\n\n",
 "cont_diff_on_top_iff_deriv_of_open":
 "/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:76:14: unsupported tactic `congrm #[[expr Â«expr âˆ§ Â»(_, _)]] -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆÂ» -/\n/-- A function is `C^âˆ` on an open domain if and only if it is differentiable\nthere, and its derivative (formulated with `deriv`) is `C^âˆ`. -/\ntheorem cont_diff_on_top_iff_deriv_of_open (hs : is_open sâ‚‚) :\n    cont_diff_on ğ•œ (Â«exprâˆÂ») fâ‚‚ sâ‚‚ â†” differentiable_on ğ•œ fâ‚‚ sâ‚‚ âˆ§ cont_diff_on ğ•œ (Â«exprâˆÂ») (deriv fâ‚‚) sâ‚‚ :=\n  by\n  rw [cont_diff_on_top_iff_deriv_within hs.unique_diff_on]\n  trace\n    \"./././Mathport/Syntax/Translate/Tactic/Builtin.lean:76:14: unsupported tactic `congrm #[[expr Â«expr âˆ§ Â»(_, _)]]\"\n  exact cont_diff_on_congr fun _ => deriv_within_of_open hs\n#align cont_diff_on_top_iff_deriv_of_open cont_diff_on_top_iff_deriv_of_open\n\n",
 "cont_diff_on_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆÂ» -/\ntheorem cont_diff_on_top : cont_diff_on ğ•œ (Â«exprâˆÂ») f s â†” âˆ€ n : â„•, cont_diff_on ğ•œ n f s :=\n  cont_diff_on_iff_forall_nat_le.trans <| by simp only [le_top, forall_prop_of_true]\n#align cont_diff_on_top cont_diff_on_top\n\n",
 "cont_diff_on_succ_of_fderiv_within":
 "theorem cont_diff_on_succ_of_fderiv_within {n : â„•} (hf : differentiable_on ğ•œ f s)\n    (h : cont_diff_on ğ•œ n (fun y => fderiv_within ğ•œ f s y) s) : cont_diff_on ğ•œ (n + 1 : â„•) f s :=\n  by\n  intro x hx\n  rw [cont_diff_within_at_succ_iff_has_fderiv_within_at, insert_eq_of_mem hx]\n  exact âŸ¨s, self_mem_nhds_within, fderiv_within ğ•œ f s, fun y hy => (hf y hy).has_fderiv_within_at, h x hxâŸ©\n#align cont_diff_on_succ_of_fderiv_within cont_diff_on_succ_of_fderiv_within\n\n",
 "cont_diff_on_succ_of_fderiv_apply":
 "theorem cont_diff_on_succ_of_fderiv_apply [finite_dimensional ğ•œ E] {n : â„•} {f : E â†’ F} {s : set E}\n    (hf : differentiable_on ğ•œ f s) (h : âˆ€ y, cont_diff_on ğ•œ n (fun x => fderiv_within ğ•œ f s x y) s) :\n    cont_diff_on ğ•œ (n + 1 : â„•) f s :=\n  cont_diff_on_succ_of_fderiv_within hf <| cont_diff_on_clm_apply.mpr h\n#align cont_diff_on_succ_of_fderiv_apply cont_diff_on_succ_of_fderiv_apply\n\n",
 "cont_diff_on_succ_iff_has_fderiv_within_at":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/-- A function is `C^(n + 1)` on a domain iff locally, it has a derivative which is `C^n`. -/\ntheorem cont_diff_on_succ_iff_has_fderiv_within_at {n : â„•} :\n    cont_diff_on ğ•œ (n + 1 : â„•) f s â†”\n      âˆ€ x âˆˆ s,\n        âˆƒ u âˆˆ nhds_within (insert x s) x,\n          âˆƒ f' : E â†’ Â«expr â†’L[ ] Â» E ğ•œ F, (âˆ€ x âˆˆ u, has_fderiv_within_at f (f' x) u x) âˆ§ cont_diff_on ğ•œ n f' u :=\n  by\n  constructor\n  Â· intro h x hx\n    rcases(h x hx) n.succ le_rfl with âŸ¨u, hu, p, HpâŸ©\n    refine'\n      âŸ¨u, hu, fun y => (continuous_multilinear_curry_fin1 ğ•œ E F) (p y 1), fun y hy =>\n        Hp.has_fderiv_within_at (WithTop.coe_le_coe.2 (nat.le_add_left 1 n)) hy, _âŸ©\n    rw [has_ftaylor_series_up_to_on_succ_iff_right] at Hp\n    intro z hz m hm\n    refine' âŸ¨u, _, fun x : E => (p x).shift, Hp.2.2.of_le hmâŸ©\n    convert self_mem_nhds_within\n    exact insert_eq_of_mem hz\n  Â· intro h x hx\n    rw [cont_diff_within_at_succ_iff_has_fderiv_within_at]\n    rcases h x hx with âŸ¨u, u_nhbd, f', hu, hf'âŸ©\n    have : x âˆˆ u := mem_of_mem_nhds_within (mem_insert _ _) u_nhbd\n    exact âŸ¨u, u_nhbd, f', hu, hf' x thisâŸ©\n#align cont_diff_on_succ_iff_has_fderiv_within_at cont_diff_on_succ_iff_has_fderiv_within_at\n\n",
 "cont_diff_on_succ_iff_fderiv_within":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/-- A function is `C^(n + 1)` on a domain with unique derivatives if and only if it is\ndifferentiable there, and its derivative (expressed with `fderiv_within`) is `C^n`. -/\ntheorem cont_diff_on_succ_iff_fderiv_within {n : â„•} (hs : unique_diff_on ğ•œ s) :\n    cont_diff_on ğ•œ (n + 1 : â„•) f s â†” differentiable_on ğ•œ f s âˆ§ cont_diff_on ğ•œ n (fun y => fderiv_within ğ•œ f s y) s :=\n  by\n  refine' âŸ¨fun H => _, fun h => cont_diff_on_succ_of_fderiv_within h.1 h.2âŸ©\n  refine' âŸ¨H.differentiable_on (WithTop.coe_le_coe.2 (nat.le_add_left 1 n)), fun x hx => _âŸ©\n  rcases cont_diff_within_at_succ_iff_has_fderiv_within_at.1 (H x hx) with âŸ¨u, hu, f', hff', hf'âŸ©\n  rcases mem_nhds_within.1 hu with âŸ¨o, o_open, xo, hoâŸ©\n  rw [inter_comm, insert_eq_of_mem hx] at ho\n  have := hf'.mono ho\n  rw [cont_diff_within_at_inter' (mem_nhds_within_of_mem_nhds (is_open.mem_nhds o_open xo))] at this\n  apply this.congr_of_eventually_eq' _ hx\n  have : o âˆ© s âˆˆ nhds_within s x := mem_nhds_within.2 âŸ¨o, o_open, xo, subset.refl _âŸ©\n  rw [inter_comm] at this\n  apply filter.eventually_eq_of_mem this fun y hy => _\n  have A : fderiv_within ğ•œ f (s âˆ© o) y = f' y := ((hff' y (ho hy)).mono ho).fderiv_within (hs.inter o_open y hy)\n  rwa [fderiv_within_inter (is_open.mem_nhds o_open hy.2) (hs y hy.1)] at A\n#align cont_diff_on_succ_iff_fderiv_within cont_diff_on_succ_iff_fderiv_within\n\n",
 "cont_diff_on_succ_iff_fderiv_of_open":
 "/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:76:14: unsupported tactic `congrm #[[expr Â«expr âˆ§ Â»(_, _)]] -/\n/-- A function is `C^(n + 1)` on an open domain if and only if it is\ndifferentiable there, and its derivative (expressed with `fderiv`) is `C^n`. -/\ntheorem cont_diff_on_succ_iff_fderiv_of_open {n : â„•} (hs : is_open s) :\n    cont_diff_on ğ•œ (n + 1 : â„•) f s â†” differentiable_on ğ•œ f s âˆ§ cont_diff_on ğ•œ n (fun y => fderiv ğ•œ f y) s :=\n  by\n  rw [cont_diff_on_succ_iff_fderiv_within hs.unique_diff_on]\n  trace\n    \"./././Mathport/Syntax/Translate/Tactic/Builtin.lean:76:14: unsupported tactic `congrm #[[expr Â«expr âˆ§ Â»(_, _)]]\"\n  apply cont_diff_on_congr\n  intro x hx\n  exact fderiv_within_of_open hs hx\n#align cont_diff_on_succ_iff_fderiv_of_open cont_diff_on_succ_iff_fderiv_of_open\n\n",
 "cont_diff_on_succ_iff_fderiv_apply":
 "theorem cont_diff_on_succ_iff_fderiv_apply [finite_dimensional ğ•œ E] {n : â„•} {f : E â†’ F} {s : set E}\n    (hs : unique_diff_on ğ•œ s) :\n    cont_diff_on ğ•œ (n + 1 : â„•) f s â†”\n      differentiable_on ğ•œ f s âˆ§ âˆ€ y, cont_diff_on ğ•œ n (fun x => fderiv_within ğ•œ f s x y) s :=\n  by rw [cont_diff_on_succ_iff_fderiv_within hs, cont_diff_on_clm_apply]\n#align cont_diff_on_succ_iff_fderiv_apply cont_diff_on_succ_iff_fderiv_apply\n\n",
 "cont_diff_on_succ_iff_deriv_within":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/-- A function is `C^(n + 1)` on a domain with unique derivatives if and only if it is\ndifferentiable there, and its derivative (formulated with `deriv_within`) is `C^n`. -/\ntheorem cont_diff_on_succ_iff_deriv_within {n : â„•} (hs : unique_diff_on ğ•œ sâ‚‚) :\n    cont_diff_on ğ•œ (n + 1 : â„•) fâ‚‚ sâ‚‚ â†” differentiable_on ğ•œ fâ‚‚ sâ‚‚ âˆ§ cont_diff_on ğ•œ n (deriv_within fâ‚‚ sâ‚‚) sâ‚‚ :=\n  by\n  rw [cont_diff_on_succ_iff_fderiv_within hs]\n  congr 2\n  apply le_antisymm\n  Â· intro h\n    have : deriv_within fâ‚‚ sâ‚‚ = (fun u : Â«expr â†’L[ ] Â» ğ•œ ğ•œ F => u 1) âˆ˜ fderiv_within ğ•œ fâ‚‚ sâ‚‚ :=\n      by\n      ext x\n      rfl\n    simp only [this]\n    apply cont_diff.comp_cont_diff_on _ h\n    exact (is_bounded_bilinear_map_apply.is_bounded_linear_map_left _).cont_diff\n  Â· intro h\n    have : fderiv_within ğ•œ fâ‚‚ sâ‚‚ = smul_right (1 : Â«expr â†’L[ ] Â» ğ•œ ğ•œ ğ•œ) âˆ˜ deriv_within fâ‚‚ sâ‚‚ :=\n      by\n      ext x\n      simp [deriv_within]\n    simp only [this]\n    apply cont_diff.comp_cont_diff_on _ h\n    have : is_bounded_bilinear_map ğ•œ fun _ : Â«expr â†’L[ ] Â» ğ•œ ğ•œ ğ•œ Ã— F => _ := is_bounded_bilinear_map_smul_right\n    exact (this.is_bounded_linear_map_right _).cont_diff\n#align cont_diff_on_succ_iff_deriv_within cont_diff_on_succ_iff_deriv_within\n\n",
 "cont_diff_on_succ_iff_deriv_of_open":
 "/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:76:14: unsupported tactic `congrm #[[expr Â«expr âˆ§ Â»(_, _)]] -/\n/-- A function is `C^(n + 1)` on an open domain if and only if it is\ndifferentiable there, and its derivative (formulated with `deriv`) is `C^n`. -/\ntheorem cont_diff_on_succ_iff_deriv_of_open {n : â„•} (hs : is_open sâ‚‚) :\n    cont_diff_on ğ•œ (n + 1 : â„•) fâ‚‚ sâ‚‚ â†” differentiable_on ğ•œ fâ‚‚ sâ‚‚ âˆ§ cont_diff_on ğ•œ n (deriv fâ‚‚) sâ‚‚ :=\n  by\n  rw [cont_diff_on_succ_iff_deriv_within hs.unique_diff_on]\n  trace\n    \"./././Mathport/Syntax/Translate/Tactic/Builtin.lean:76:14: unsupported tactic `congrm #[[expr Â«expr âˆ§ Â»(_, _)]]\"\n  exact cont_diff_on_congr fun _ => deriv_within_of_open hs\n#align cont_diff_on_succ_iff_deriv_of_open cont_diff_on_succ_iff_deriv_of_open\n\n",
 "cont_diff_on_snd":
 "/-- The second projection on a domain in a product is `C^âˆ`. -/\ntheorem cont_diff_on_snd {s : set (E Ã— F)} : cont_diff_on ğ•œ n (prod.snd : E Ã— F â†’ F) s :=\n  cont_diff.cont_diff_on cont_diff_snd\n#align cont_diff_on_snd cont_diff_on_snd\n\n",
 "cont_diff_on_prod'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\ntheorem cont_diff_on_prod' {t : Finset Î¹} {f : Î¹ â†’ E â†’ ğ”¸'} (h : âˆ€ i âˆˆ t, cont_diff_on ğ•œ n (f i) s) :\n    cont_diff_on ğ•œ n\n      (finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" t (f i)) s :=\n  fun x hx => cont_diff_within_at_prod' fun i hi => h i hi x hx\n#align cont_diff_on_prod' cont_diff_on_prod'\n\n",
 "cont_diff_on_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\ntheorem cont_diff_on_prod {t : Finset Î¹} {f : Î¹ â†’ E â†’ ğ”¸'} (h : âˆ€ i âˆˆ t, cont_diff_on ğ•œ n (f i) s) :\n    cont_diff_on ğ•œ n\n      (fun y =>\n        finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" t (f i y))\n      s :=\n  fun x hx => cont_diff_within_at_prod fun i hi => h i hi x hx\n#align cont_diff_on_prod cont_diff_on_prod\n\n",
 "cont_diff_on_pi":
 "theorem cont_diff_on_pi : cont_diff_on ğ•œ n Î¦ s â†” âˆ€ i, cont_diff_on ğ•œ n (fun x => Î¦ x i) s :=\n  âŸ¨fun h i x hx => cont_diff_within_at_pi.1 (h x hx) _, fun h x hx => cont_diff_within_at_pi.2 fun i => h i x hxâŸ©\n#align cont_diff_on_pi cont_diff_on_pi\n\n",
 "cont_diff_on_of_subsingleton":
 "@[nontriviality]\ntheorem cont_diff_on_of_subsingleton [subsingleton F] : cont_diff_on ğ•œ n f s :=\n  by\n  rw [subsingleton.elim f fun _ => 0]\n  exact cont_diff_on_const\n#align cont_diff_on_of_subsingleton cont_diff_on_of_subsingleton\n\n",
 "cont_diff_on_of_locally_cont_diff_on":
 "/-- If a function is `C^n` around each point in a set, then it is `C^n` on the set. -/\ntheorem cont_diff_on_of_locally_cont_diff_on (h : âˆ€ x âˆˆ s, âˆƒ u, is_open u âˆ§ x âˆˆ u âˆ§ cont_diff_on ğ•œ n f (s âˆ© u)) :\n    cont_diff_on ğ•œ n f s := by\n  intro x xs\n  rcases h x xs with âŸ¨u, u_open, xu, huâŸ©\n  apply (cont_diff_within_at_inter _).1 (hu x âŸ¨xs, xuâŸ©)\n  exact is_open.mem_nhds u_open xu\n#align cont_diff_on_of_locally_cont_diff_on cont_diff_on_of_locally_cont_diff_on\n\n",
 "cont_diff_on_of_differentiable_on":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ„•âˆÂ» -/\ntheorem cont_diff_on_of_differentiable_on\n    (h : âˆ€ m : â„•, (m : Â«exprâ„•âˆÂ») â‰¤ n â†’ differentiable_on ğ•œ (iterated_fderiv_within ğ•œ m f s) s) : cont_diff_on ğ•œ n f s :=\n  cont_diff_on_of_continuous_on_differentiable_on (fun m hm => (h m hm).continuous_on) fun m hm => h m (le_of_lt hm)\n#align cont_diff_on_of_differentiable_on cont_diff_on_of_differentiable_on\n\n",
 "cont_diff_on_of_continuous_on_differentiable_on":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ„•âˆÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ„•âˆÂ» -/\ntheorem cont_diff_on_of_continuous_on_differentiable_on\n    (Hcont : âˆ€ m : â„•, (m : Â«exprâ„•âˆÂ») â‰¤ n â†’ continuous_on (fun x => iterated_fderiv_within ğ•œ m f s x) s)\n    (Hdiff : âˆ€ m : â„•, (m : Â«exprâ„•âˆÂ») < n â†’ differentiable_on ğ•œ (fun x => iterated_fderiv_within ğ•œ m f s x) s) :\n    cont_diff_on ğ•œ n f s := by\n  intro x hx m hm\n  rw [insert_eq_of_mem hx]\n  refine' âŸ¨s, self_mem_nhds_within, ftaylor_series_within ğ•œ f s, _âŸ©\n  constructor\n  Â· intro y hy\n    simp only [ftaylor_series_within, continuous_multilinear_map.uncurry0_apply, iterated_fderiv_within_zero_apply]\n  Â· intro k hk y hy\n    convert (Hdiff k (lt_of_lt_of_le hk hm) y hy).has_fderiv_within_at\n    simp only [ftaylor_series_within, iterated_fderiv_within_succ_eq_comp_left, continuous_linear_equiv.coe_apply,\n      Function.comp_apply, coe_fn_coe_base]\n    exact continuous_linear_map.curry_uncurry_left _\n  Â· intro k hk\n    exact Hcont k (le_trans hk hm)\n#align cont_diff_on_of_continuous_on_differentiable_on cont_diff_on_of_continuous_on_differentiable_on\n\n",
 "cont_diff_on_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á¶œÂ» -/\ntheorem cont_diff_on_inv {n} : cont_diff_on ğ•œ n (has_inv.inv : ğ•œ' â†’ ğ•œ') (Â«expr á¶œÂ» {0}) := fun x hx =>\n  (cont_diff_at_inv ğ•œ hx).cont_diff_within_at\n#align cont_diff_on_inv cont_diff_on_inv\n\n",
 "cont_diff_on_iff_ftaylor_series":
 "/-- When a function is `C^n` in a set `s` of unique differentiability, it admits\n`ftaylor_series_within ğ•œ f s` as a Taylor series up to order `n` in `s`. -/\ntheorem cont_diff_on_iff_ftaylor_series : cont_diff ğ•œ n f â†” has_ftaylor_series_up_to n f (ftaylor_series ğ•œ f) :=\n  by\n  constructor\n  Â· rw [â† cont_diff_on_univ, â† has_ftaylor_series_up_to_on_univ_iff, â† ftaylor_series_within_univ]\n    exact fun h => cont_diff_on.ftaylor_series_within h unique_diff_on_univ\n  Â· intro h\n    exact âŸ¨ftaylor_series ğ•œ f, hâŸ©\n#align cont_diff_on_iff_ftaylor_series cont_diff_on_iff_ftaylor_series\n\n",
 "cont_diff_on_iff_forall_nat_le":
 "theorem cont_diff_on_iff_forall_nat_le : cont_diff_on ğ•œ n f s â†” âˆ€ m : â„•, â†‘m â‰¤ n â†’ cont_diff_on ğ•œ m f s :=\n  âŸ¨fun H m hm => H.of_le hm, fun H x hx m hm => H m hm x hx m le_rflâŸ©\n#align cont_diff_on_iff_forall_nat_le cont_diff_on_iff_forall_nat_le\n\n",
 "cont_diff_on_iff_continuous_on_differentiable_on":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ„•âˆÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ„•âˆÂ» -/\ntheorem cont_diff_on_iff_continuous_on_differentiable_on (hs : unique_diff_on ğ•œ s) :\n    cont_diff_on ğ•œ n f s â†”\n      (âˆ€ m : â„•, (m : Â«exprâ„•âˆÂ») â‰¤ n â†’ continuous_on (fun x => iterated_fderiv_within ğ•œ m f s x) s) âˆ§\n        âˆ€ m : â„•, (m : Â«exprâ„•âˆÂ») < n â†’ differentiable_on ğ•œ (fun x => iterated_fderiv_within ğ•œ m f s x) s :=\n  by\n  constructor\n  Â· intro h\n    constructor\n    Â· intro m hm\n      exact h.continuous_on_iterated_fderiv_within hm hs\n    Â· intro m hm\n      exact h.differentiable_on_iterated_fderiv_within hm hs\n  Â· intro h\n    exact cont_diff_on_of_continuous_on_differentiable_on h.1 h.2\n#align cont_diff_on_iff_continuous_on_differentiable_on cont_diff_on_iff_continuous_on_differentiable_on\n\n",
 "cont_diff_on_id":
 "theorem cont_diff_on_id {s} : cont_diff_on ğ•œ n (id : E â†’ E) s :=\n  cont_diff_id.cont_diff_on\n#align cont_diff_on_id cont_diff_on_id\n\n",
 "cont_diff_on_fst":
 "/-- The first projection on a domain in a product is `C^âˆ`. -/\ntheorem cont_diff_on_fst {s : set (E Ã— F)} : cont_diff_on ğ•œ n (prod.fst : E Ã— F â†’ E) s :=\n  cont_diff.cont_diff_on cont_diff_fst\n#align cont_diff_on_fst cont_diff_on_fst\n\n",
 "cont_diff_on_fderiv_within_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n/-- The bundled derivative of a `C^{n+1}` function is `C^n`. -/\ntheorem cont_diff_on_fderiv_within_apply {m n : WithTop â„•} {s : set E} {f : E â†’ F} (hf : cont_diff_on ğ•œ n f s)\n    (hs : unique_diff_on ğ•œ s) (hmn : m + 1 â‰¤ n) :\n    cont_diff_on ğ•œ m (fun p : E Ã— E => (fderiv_within ğ•œ f s p.1 : Â«expr â†’L[ ] Â» E ğ•œ F) p.2) (lower_set.prod s univ) :=\n  have I : cont_diff_on ğ•œ m (fun x : E => fderiv_within ğ•œ f s x) s := hf.fderiv_within hs hmn\n  have J : cont_diff_on ğ•œ m (fun x : E Ã— E => x.1) (lower_set.prod s univ) := cont_diff_fst.cont_diff_on\n  have A : cont_diff ğ•œ m fun p : Â«expr â†’L[ ] Â» E ğ•œ F Ã— E => p.1 p.2 := is_bounded_bilinear_map_apply.cont_diff\n  have B : cont_diff_on ğ•œ m (fun p : E Ã— E => (fderiv_within ğ•œ f s p.fst, p.snd)) (lower_set.prod s univ) :=\n    (I.comp J (prod_subset_preimage_fst _ _)).prod is_bounded_linear_map.snd.cont_diff.cont_diff_on\n  A.comp_cont_diff_on B\n#align cont_diff_on_fderiv_within_apply cont_diff_on_fderiv_within_apply\n\n",
 "cont_diff_on_const":
 "theorem cont_diff_on_const {c : F} {s : set E} : cont_diff_on ğ•œ n (fun x : E => c) s :=\n  cont_diff_const.cont_diff_on\n#align cont_diff_on_const cont_diff_on_const\n\n",
 "cont_diff_on_congr":
 "theorem cont_diff_on_congr (hâ‚ : âˆ€ x âˆˆ s, fâ‚ x = f x) : cont_diff_on ğ•œ n fâ‚ s â†” cont_diff_on ğ•œ n f s :=\n  âŸ¨fun H => H.congr fun x hx => (hâ‚ x hx).symm, fun H => H.congr hâ‚âŸ©\n#align cont_diff_on_congr cont_diff_on_congr\n\n",
 "cont_diff_on_comp_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰ƒL[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/-- Composition by continuous linear equivs on the right respects higher differentiability on\ndomains. -/\ntheorem continuous_linear_equiv.cont_diff_on_comp_iff (e : Â«expr â‰ƒL[ ] Â» G ğ•œ E) :\n    cont_diff_on ğ•œ n (f âˆ˜ e) (Â«expr â»Â¹' Â» e s) â†” cont_diff_on ğ•œ n f s :=\n  by\n  refine' âŸ¨fun H => _, fun H => H.comp_continuous_linear_map (e : Â«expr â†’L[ ] Â» G ğ•œ E)âŸ©\n  have A : f = (f âˆ˜ e) âˆ˜ e.symm := by\n    ext y\n    simp only [Function.comp_apply]\n    rw [e.apply_symm_apply y]\n  have B : Â«expr â»Â¹' Â» e.symm (Â«expr â»Â¹' Â» e s) = s :=\n    by\n    rw [â† preimage_comp, e.self_comp_symm]\n    rfl\n  rw [A, â† B]\n  exact H.comp_continuous_linear_map (e.symm : Â«expr â†’L[ ] Â» E ğ•œ G)\n#align continuous_linear_equiv.cont_diff_on_comp_iff continuous_linear_equiv.cont_diff_on_comp_iff\n\n",
 "cont_diff_on_clm_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰ƒL[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ„•âˆÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/-- A family of continuous linear maps is `C^n` on `s` if all its applications are. -/\ntheorem cont_diff_on_clm_apply {n : Â«exprâ„•âˆÂ»} {f : E â†’ Â«expr â†’L[ ] Â» F ğ•œ G} {s : set E} [finite_dimensional ğ•œ F] :\n    cont_diff_on ğ•œ n f s â†” âˆ€ y, cont_diff_on ğ•œ n (fun x => f x y) s :=\n  by\n  refine' âŸ¨fun h y => (continuous_linear_map.apply ğ•œ G y).cont_diff.comp_cont_diff_on h, fun h => _âŸ©\n  let d := finrank ğ•œ F\n  have hd : d = finrank ğ•œ (fin d â†’ ğ•œ) := (finrank_fin_fun ğ•œ).symm\n  let eâ‚ := continuous_linear_equiv.of_finrank_eq hd\n  let eâ‚‚ := (eâ‚.arrow_congr (1 : Â«expr â‰ƒL[ ] Â» G ğ•œ G)).trans (continuous_linear_equiv.pi_ring (fin d))\n  rw [â† comp.left_id f, â† eâ‚‚.symm_comp_self]\n  exact eâ‚‚.symm.cont_diff.comp_cont_diff_on (cont_diff_on_pi.mpr fun i => h _)\n#align cont_diff_on_clm_apply cont_diff_on_clm_apply\n\n",
 "cont_diff_on_all_iff_nat":
 "theorem cont_diff_on_all_iff_nat : (âˆ€ n, cont_diff_on ğ•œ n f s) â†” âˆ€ n : â„•, cont_diff_on ğ•œ n f s :=\n  by\n  refine' âŸ¨fun H n => H n, _âŸ©\n  rintro H (_ | n)\n  exacts[cont_diff_on_top.2 H, H n]\n#align cont_diff_on_all_iff_nat cont_diff_on_all_iff_nat\n\n",
 "cont_diff_on":
 "theorem cont_diff.cont_diff_on (h : cont_diff ğ•œ n f) : cont_diff_on ğ•œ n f s :=\n  (cont_diff_on_univ.2 h).mono (subset_univ _)\n#align cont_diff.cont_diff_on cont_diff.cont_diff_on\n\n",
 "cont_diff_of_subsingleton":
 "@[nontriviality]\ntheorem cont_diff_of_subsingleton [subsingleton F] : cont_diff ğ•œ n f :=\n  by\n  rw [subsingleton.elim f fun _ => 0]\n  exact cont_diff_const\n#align cont_diff_of_subsingleton cont_diff_of_subsingleton\n\n",
 "cont_diff_of_differentiable_iterated_fderiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ„•âˆÂ» -/\ntheorem cont_diff_of_differentiable_iterated_fderiv\n    (h : âˆ€ m : â„•, (m : Â«exprâ„•âˆÂ») â‰¤ n â†’ differentiable ğ•œ (iterated_fderiv ğ•œ m f)) : cont_diff ğ•œ n f :=\n  cont_diff_iff_continuous_differentiable.2 âŸ¨fun m hm => (h m hm).continuous, fun m hm => h m (le_of_lt hm)âŸ©\n#align cont_diff_of_differentiable_iterated_fderiv cont_diff_of_differentiable_iterated_fderiv\n\n",
 "cont_diff_neg":
 "-- The negative is smooth.\ntheorem cont_diff_neg : cont_diff ğ•œ n fun p : F => -p :=\n  is_bounded_linear_map.id.neg.cont_diff\n#align cont_diff_neg cont_diff_neg\n\n",
 "cont_diff_mul":
 "-- The product is smooth.\ntheorem cont_diff_mul : cont_diff ğ•œ n fun p : ğ”¸ Ã— ğ”¸ => p.1 * p.2 :=\n  (continuous_linear_map.mul ğ•œ ğ”¸).is_bounded_bilinear_map.cont_diff\n#align cont_diff_mul cont_diff_mul\n\n",
 "cont_diff_iff_forall_nat_le":
 "theorem cont_diff_iff_forall_nat_le : cont_diff ğ•œ n f â†” âˆ€ m : â„•, â†‘m â‰¤ n â†’ cont_diff ğ•œ m f :=\n  by\n  simp_rw [â† cont_diff_on_univ]\n  exact cont_diff_on_iff_forall_nat_le\n#align cont_diff_iff_forall_nat_le cont_diff_iff_forall_nat_le\n\n",
 "cont_diff_iff_continuous_differentiable":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ„•âˆÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ„•âˆÂ» -/\ntheorem cont_diff_iff_continuous_differentiable :\n    cont_diff ğ•œ n f â†”\n      (âˆ€ m : â„•, (m : Â«exprâ„•âˆÂ») â‰¤ n â†’ continuous fun x => iterated_fderiv ğ•œ m f x) âˆ§\n        âˆ€ m : â„•, (m : Â«exprâ„•âˆÂ») < n â†’ differentiable ğ•œ fun x => iterated_fderiv ğ•œ m f x :=\n  by\n  simp [cont_diff_on_univ.symm, continuous_iff_continuous_on_univ, differentiable_on_univ.symm,\n    iterated_fderiv_within_univ, cont_diff_on_iff_continuous_on_differentiable_on unique_diff_on_univ]\n#align cont_diff_iff_continuous_differentiable cont_diff_iff_continuous_differentiable\n\n",
 "cont_diff_iff_cont_diff_at":
 "theorem cont_diff_iff_cont_diff_at : cont_diff ğ•œ n f â†” âˆ€ x, cont_diff_at ğ•œ n f x := by\n  simp [â† cont_diff_on_univ, cont_diff_on, cont_diff_at]\n#align cont_diff_iff_cont_diff_at cont_diff_iff_cont_diff_at\n\n",
 "cont_diff_id":
 "/-- The identity is `C^âˆ`.\n-/\ntheorem cont_diff_id : cont_diff ğ•œ n (id : E â†’ E) :=\n  is_bounded_linear_map.id.cont_diff\n#align cont_diff_id cont_diff_id\n\n",
 "cont_diff_fst":
 "/-- The first projection in a product is `C^âˆ`. -/\ntheorem cont_diff_fst : cont_diff ğ•œ n (prod.fst : E Ã— F â†’ E) :=\n  is_bounded_linear_map.cont_diff is_bounded_linear_map.fst\n#align cont_diff_fst cont_diff_fst\n\n",
 "cont_diff_fderiv_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/-- The bundled derivative of a `C^{n+1}` function is `C^n`. -/\ntheorem cont_diff.cont_diff_fderiv_apply {f : E â†’ F} (hf : cont_diff ğ•œ n f) (hmn : m + 1 â‰¤ n) :\n    cont_diff ğ•œ m fun p : E Ã— E => (fderiv ğ•œ f p.1 : Â«expr â†’L[ ] Â» E ğ•œ F) p.2 :=\n  by\n  rw [â† cont_diff_on_univ] at hfâŠ¢\n  rw [â† fderiv_within_univ, â† univ_prod_univ]\n  exact cont_diff_on_fderiv_within_apply hf unique_diff_on_univ hmn\n#align cont_diff.cont_diff_fderiv_apply cont_diff.cont_diff_fderiv_apply\n\n",
 "cont_diff_const_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n-- The scalar multiplication with a constant is smooth.\ntheorem cont_diff_const_smul (c : R) : cont_diff ğ•œ n fun p : F => Â«expr â€¢ Â» c p :=\n  (Â«expr â€¢ Â» c (continuous_linear_map.id ğ•œ F)).cont_diff\n#align cont_diff_const_smul cont_diff_const_smul\n\n",
 "cont_diff_const":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆÂ» -/\n/-- Constants are `C^âˆ`.\n-/\ntheorem cont_diff_const {c : F} : cont_diff ğ•œ n fun x : E => c :=\n  by\n  suffices h : cont_diff ğ•œ (Â«exprâˆÂ») fun x : E => c; Â· exact h.of_le le_top\n  rw [cont_diff_top_iff_fderiv]\n  refine' âŸ¨differentiable_const c, _âŸ©\n  rw [fderiv_const]\n  exact cont_diff_zero_fun\n#align cont_diff_const cont_diff_const\n\n",
 "cont_diff_comp_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰ƒL[ ] Â» -/\n/-- Composition by continuous linear equivs on the right respects higher differentiability. -/\ntheorem continuous_linear_equiv.cont_diff_comp_iff (e : Â«expr â‰ƒL[ ] Â» G ğ•œ E) :\n    cont_diff ğ•œ n (f âˆ˜ e) â†” cont_diff ğ•œ n f :=\n  by\n  rw [â† cont_diff_on_univ, â† cont_diff_on_univ, â† preimage_univ]\n  exact e.cont_diff_on_comp_iff\n#align continuous_linear_equiv.cont_diff_comp_iff continuous_linear_equiv.cont_diff_comp_iff\n\n",
 "cont_diff_clm_apply_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ„•âˆÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\ntheorem cont_diff_clm_apply_iff {n : Â«exprâ„•âˆÂ»} {f : E â†’ Â«expr â†’L[ ] Â» F ğ•œ G} [finite_dimensional ğ•œ F] :\n    cont_diff ğ•œ n f â†” âˆ€ y, cont_diff ğ•œ n fun x => f x y := by simp_rw [â† cont_diff_on_univ, cont_diff_on_clm_apply]\n#align cont_diff_clm_apply_iff cont_diff_clm_apply_iff\n\n",
 "cont_diff_at_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem cont_diff_at_zero : cont_diff_at ğ•œ 0 f x â†” âˆƒ u âˆˆ (nhds) x, continuous_on f u :=\n  by\n  rw [â† cont_diff_within_at_univ]\n  simp [cont_diff_within_at_zero, nhds_within_univ]\n#align cont_diff_at_zero cont_diff_at_zero\n\n",
 "cont_diff_at_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆÂ» -/\ntheorem cont_diff_at_top : cont_diff_at ğ•œ (Â«exprâˆÂ») f x â†” âˆ€ n : â„•, cont_diff_at ğ•œ n f x := by\n  simp [â† cont_diff_within_at_univ, cont_diff_within_at_top]\n#align cont_diff_at_top cont_diff_at_top\n\n",
 "cont_diff_at_symm_deriv":
 "/-- Let `f` be a local homeomorphism of a nontrivially normed field, let `a` be a point in its\ntarget. if `f` is `n` times continuously differentiable at `f.symm a`, and if the derivative at\n`f.symm a` is nonzero, then `f.symm` is `n` times continuously differentiable at the point `a`.\n\nThis is one of the easy parts of the inverse function theorem: it assumes that we already have\nan inverse function. -/\ntheorem local_homeomorph.cont_diff_at_symm_deriv [complete_space ğ•œ] (f : local_homeomorph ğ•œ ğ•œ) {fâ‚€' a : ğ•œ}\n    (hâ‚€ : fâ‚€' â‰  0) (ha : a âˆˆ f.target) (hfâ‚€' : has_deriv_at f fâ‚€' (f.symm a)) (hf : cont_diff_at ğ•œ n f (f.symm a)) :\n    cont_diff_at ğ•œ n f.symm a :=\n  f.cont_diff_at_symm ha (hfâ‚€'.has_fderiv_at_equiv hâ‚€) hf\n#align local_homeomorph.cont_diff_at_symm_deriv local_homeomorph.cont_diff_at_symm_deriv\n\n",
 "cont_diff_at_symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰ƒL[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰ƒL[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/-- If `f` is a local homeomorphism and the point `a` is in its target,\nand if `f` is `n` times continuously differentiable at `f.symm a`,\nand if the derivative at `f.symm a` is a continuous linear equivalence,\nthen `f.symm` is `n` times continuously differentiable at the point `a`.\n\nThis is one of the easy parts of the inverse function theorem: it assumes that we already have\nan inverse function. -/\ntheorem local_homeomorph.cont_diff_at_symm [complete_space E] (f : local_homeomorph E F) {fâ‚€' : Â«expr â‰ƒL[ ] Â» E ğ•œ F}\n    {a : F} (ha : a âˆˆ f.target) (hfâ‚€' : has_fderiv_at f (fâ‚€' : Â«expr â†’L[ ] Â» E ğ•œ F) (f.symm a))\n    (hf : cont_diff_at ğ•œ n f (f.symm a)) : cont_diff_at ğ•œ n f.symm a :=\n  by\n  -- We prove this by induction on `n`\n  induction' n using enat.nat_induction with n IH Itop\n  Â· rw [cont_diff_at_zero]\n    exact âŸ¨f.target, is_open.mem_nhds f.open_target ha, f.continuous_inv_funâŸ©\n  Â· obtain âŸ¨f', âŸ¨u, hu, hff'âŸ©, hf'âŸ© := cont_diff_at_succ_iff_has_fderiv_at.mp hf\n    apply cont_diff_at_succ_iff_has_fderiv_at.mpr\n    -- For showing `n.succ` times continuous differentiability (the main inductive step), it\n    -- suffices to produce the derivative and show that it is `n` times continuously differentiable\n    have eq_fâ‚€' : f' (f.symm a) = fâ‚€' := (hff' (f.symm a) (mem_of_mem_nhds hu)).unique hfâ‚€'\n    -- This follows by a bootstrapping formula expressing the derivative as a function of `f` itself\n    refine' âŸ¨inverse âˆ˜ f' âˆ˜ f.symm, _, _âŸ©\n    Â· -- We first check that the derivative of `f` is that formula\n      have h_nhds : { y : E | âˆƒ e : Â«expr â‰ƒL[ ] Â» E ğ•œ F, â†‘e = f' y } âˆˆ (nhds) (f.symm a) :=\n        by\n        have hfâ‚€' := fâ‚€'.nhds\n        rw [â† eq_fâ‚€'] at hfâ‚€'\n        exact hf'.continuous_at.preimage_mem_nhds hfâ‚€'\n      obtain âŸ¨t, htu, ht, htfâŸ© := mem_nhds_iff.mp (filter.inter_mem hu h_nhds)\n      use f.target âˆ© Â«expr â»Â¹' Â» f.symm t\n      refine' âŸ¨is_open.mem_nhds _ _, _âŸ©\n      Â· exact f.preimage_open_of_open_symm ht\n      Â· exact mem_inter ha (mem_preimage.mpr htf)\n      intro x hx\n      obtain âŸ¨hxu, e, heâŸ© := htu hx.2\n      have h_deriv : has_fderiv_at f (â†‘e) (f.symm x) := by\n        rw [he]\n        exact hff' (f.symm x) hxu\n      convert f.has_fderiv_at_symm hx.1 h_deriv\n      simp [â† he]\n    Â· -- Then we check that the formula, being a composition of `cont_diff` pieces, is\n      -- itself `cont_diff`\n      have h_derivâ‚ : cont_diff_at ğ•œ n inverse (f' (f.symm a)) :=\n        by\n        rw [eq_fâ‚€']\n        exact cont_diff_at_map_inverse _\n      have h_derivâ‚‚ : cont_diff_at ğ•œ n f.symm a := by\n        refine' IH (hf.of_le _)\n        norm_cast\n        exact nat.le_succ n\n      exact (h_derivâ‚.comp _ hf').comp _ h_derivâ‚‚\n  Â· refine' cont_diff_at_top.mpr _\n    intro n\n    exact Itop n (cont_diff_at_top.mp hf n)\n#align local_homeomorph.cont_diff_at_symm local_homeomorph.cont_diff_at_symm\n\n",
 "cont_diff_at_succ_iff_has_fderiv_at":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- A function is `C^(n + 1)` at a point iff locally, it has a derivative which is `C^n`. -/\ntheorem cont_diff_at_succ_iff_has_fderiv_at {n : â„•} :\n    cont_diff_at ğ•œ (n + 1 : â„•) f x â†”\n      âˆƒ f' : E â†’ Â«expr â†’L[ ] Â» E ğ•œ F, (âˆƒ u âˆˆ (nhds) x, âˆ€ x âˆˆ u, has_fderiv_at f (f' x) x) âˆ§ cont_diff_at ğ•œ n f' x :=\n  by\n  rw [â† cont_diff_within_at_univ, cont_diff_within_at_succ_iff_has_fderiv_within_at]\n  simp only [nhds_within_univ, exists_prop, mem_univ, insert_eq_of_mem]\n  constructor\n  Â· rintro âŸ¨u, H, f', h_fderiv, h_cont_diffâŸ©\n    rcases mem_nhds_iff.mp H with âŸ¨t, htu, ht, hxtâŸ©\n    refine' âŸ¨f', âŸ¨t, _âŸ©, h_cont_diff.cont_diff_at HâŸ©\n    refine' âŸ¨mem_nhds_iff.mpr âŸ¨t, subset.rfl, ht, hxtâŸ©, _âŸ©\n    intro y hyt\n    refine' (h_fderiv y (htu hyt)).has_fderiv_at _\n    exact mem_nhds_iff.mpr âŸ¨t, htu, ht, hytâŸ©\n  Â· rintro âŸ¨f', âŸ¨u, H, h_fderivâŸ©, h_cont_diffâŸ©\n    refine' âŸ¨u, H, f', _, h_cont_diff.cont_diff_within_atâŸ©\n    intro x hxu\n    exact (h_fderiv x hxu).has_fderiv_within_at\n#align cont_diff_at_succ_iff_has_fderiv_at cont_diff_at_succ_iff_has_fderiv_at\n\n",
 "cont_diff_at_snd":
 "/-- The second projection at a point in a product is `C^âˆ`. -/\ntheorem cont_diff_at_snd {p : E Ã— F} : cont_diff_at ğ•œ n (prod.snd : E Ã— F â†’ F) p :=\n  cont_diff_snd.cont_diff_at\n#align cont_diff_at_snd cont_diff_at_snd\n\n",
 "cont_diff_at_ring_inverse":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr Ë£Â» -/\n/-- In a complete normed algebra, the operation of inversion is `C^n`, for all `n`, at each\ninvertible element.  The proof is by induction, bootstrapping using an identity expressing the\nderivative of inversion as a bilinear map of inversion itself. -/\ntheorem cont_diff_at_ring_inverse [complete_space R] (x : Â«expr Ë£Â» R) : cont_diff_at ğ•œ n Ring.inverse (x : R) :=\n  by\n  induction' n using enat.nat_induction with n IH Itop\n  Â· intro m hm\n    refine' âŸ¨{ y : R | is_unit y }, _, _âŸ©\n    Â· simp [nhds_within_univ]\n      exact x.nhds\n    Â· use ftaylor_series_within ğ•œ inverse univ\n      rw [le_antisymm hm bot_le, has_ftaylor_series_up_to_on_zero_iff]\n      constructor\n      Â· rintro _ âŸ¨x', rflâŸ©\n        exact (inverse_continuous_at x').continuous_within_at\n      Â· simp [ftaylor_series_within]\n  Â· apply cont_diff_at_succ_iff_has_fderiv_at.mpr\n    refine' âŸ¨fun x : R => -mul_left_right ğ•œ R (inverse x) (inverse x), _, _âŸ©\n    Â· refine' âŸ¨{ y : R | is_unit y }, x.nhds, _âŸ©\n      rintro _ âŸ¨y, rflâŸ©\n      rw [inverse_unit]\n      exact has_fderiv_at_ring_inverse y\n    Â· convert (mul_left_right_is_bounded_bilinear ğ•œ R).cont_diff.neg.comp_cont_diff_at (x : R) (IH.prod IH)\n  Â· exact cont_diff_at_top.mpr Itop\n#align cont_diff_at_ring_inverse cont_diff_at_ring_inverse\n\n",
 "cont_diff_at_prod'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\ntheorem cont_diff_at_prod' {t : Finset Î¹} {f : Î¹ â†’ E â†’ ğ”¸'} (h : âˆ€ i âˆˆ t, cont_diff_at ğ•œ n (f i) x) :\n    cont_diff_at ğ•œ n\n      (finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" t (f i)) x :=\n  cont_diff_within_at_prod' h\n#align cont_diff_at_prod' cont_diff_at_prod'\n\n",
 "cont_diff_at_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\ntheorem cont_diff_at_prod {t : Finset Î¹} {f : Î¹ â†’ E â†’ ğ”¸'} (h : âˆ€ i âˆˆ t, cont_diff_at ğ•œ n (f i) x) :\n    cont_diff_at ğ•œ n\n      (fun y =>\n        finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" t (f i y))\n      x :=\n  cont_diff_within_at_prod h\n#align cont_diff_at_prod cont_diff_at_prod\n\n",
 "cont_diff_at_pi":
 "theorem cont_diff_at_pi : cont_diff_at ğ•œ n Î¦ x â†” âˆ€ i, cont_diff_at ğ•œ n (fun x => Î¦ x i) x :=\n  cont_diff_within_at_pi\n#align cont_diff_at_pi cont_diff_at_pi\n\n",
 "cont_diff_at_one_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ„•âˆÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ„•âˆÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem cont_diff_at_one_iff :\n    cont_diff_at ğ•œ 1 f x â†”\n      âˆƒ f' : E â†’ Â«expr â†’L[ ] Â» E ğ•œ F, âˆƒ u âˆˆ (nhds) x, continuous_on f' u âˆ§ âˆ€ x âˆˆ u, has_fderiv_at f (f' x) x :=\n  by\n  simp_rw [show (1 : Â«exprâ„•âˆÂ») = (0 + 1 : â„•) from (zero_add 1).symm, cont_diff_at_succ_iff_has_fderiv_at,\n    show ((0 : â„•) : Â«exprâ„•âˆÂ») = 0 from rfl, cont_diff_at_zero,\n    exists_mem_and_iff antitone_bforall antitone_continuous_on, and_comm']\n#align cont_diff_at_one_iff cont_diff_at_one_iff\n\n",
 "cont_diff_at_of_subsingleton":
 "@[nontriviality]\ntheorem cont_diff_at_of_subsingleton [subsingleton F] : cont_diff_at ğ•œ n f x :=\n  by\n  rw [subsingleton.elim f fun _ => 0]\n  exact cont_diff_at_const\n#align cont_diff_at_of_subsingleton cont_diff_at_of_subsingleton\n\n",
 "cont_diff_at_map_inverse":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr Ë£Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰ƒL[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/-- At a continuous linear equivalence `e : E â‰ƒL[ğ•œ] F` between Banach spaces, the operation of\ninversion is `C^n`, for all `n`. -/\ntheorem cont_diff_at_map_inverse [complete_space E] (e : Â«expr â‰ƒL[ ] Â» E ğ•œ F) :\n    cont_diff_at ğ•œ n inverse (e : Â«expr â†’L[ ] Â» E ğ•œ F) :=\n  by\n  nontriviality E\n  -- first, we use the lemma `to_ring_inverse` to rewrite in terms of `ring.inverse` in the ring\n  -- `E â†’L[ğ•œ] E`\n  let Oâ‚ : Â«expr â†’L[ ] Â» E ğ•œ E â†’ Â«expr â†’L[ ] Â» F ğ•œ E := fun f => f.comp (e.symm : Â«expr â†’L[ ] Â» F ğ•œ E)\n  let Oâ‚‚ : Â«expr â†’L[ ] Â» E ğ•œ F â†’ Â«expr â†’L[ ] Â» E ğ•œ E := fun f => (e.symm : Â«expr â†’L[ ] Â» F ğ•œ E).comp f\n  have : continuous_linear_map.inverse = Oâ‚ âˆ˜ Ring.inverse âˆ˜ Oâ‚‚ := funext (to_ring_inverse e)\n  rw [this]\n  -- `Oâ‚` and `Oâ‚‚` are `cont_diff`,\n  -- so we reduce to proving that `ring.inverse` is `cont_diff`\n  have hâ‚ : cont_diff ğ•œ n Oâ‚ := cont_diff_id.clm_comp cont_diff_const\n  have hâ‚‚ : cont_diff ğ•œ n Oâ‚‚ := cont_diff_const.clm_comp cont_diff_id\n  refine' hâ‚.cont_diff_at.comp _ (cont_diff_at.comp _ _ hâ‚‚.cont_diff_at)\n  convert cont_diff_at_ring_inverse ğ•œ (1 : Â«expr Ë£Â» (Â«expr â†’L[ ] Â» E ğ•œ E))\n  simp [Oâ‚‚, one_def]\n#align cont_diff_at_map_inverse cont_diff_at_map_inverse\n\n",
 "cont_diff_at_inv":
 "theorem cont_diff_at_inv {x : ğ•œ'} (hx : x â‰  0) {n} : cont_diff_at ğ•œ n has_inv.inv x := by\n  simpa only [Ring.inverse_eq_inv'] using cont_diff_at_ring_inverse ğ•œ (Units.mk0 x hx)\n#align cont_diff_at_inv cont_diff_at_inv\n\n",
 "cont_diff_at_id":
 "theorem cont_diff_at_id {x} : cont_diff_at ğ•œ n (id : E â†’ E) x :=\n  cont_diff_id.cont_diff_at\n#align cont_diff_at_id cont_diff_at_id\n\n",
 "cont_diff_at_fst":
 "/-- The first projection at a point in a product is `C^âˆ`. -/\ntheorem cont_diff_at_fst {p : E Ã— F} : cont_diff_at ğ•œ n (prod.fst : E Ã— F â†’ E) p :=\n  cont_diff_fst.cont_diff_at\n#align cont_diff_at_fst cont_diff_at_fst\n\n",
 "cont_diff_at_const":
 "theorem cont_diff_at_const {c : F} : cont_diff_at ğ•œ n (fun x : E => c) x :=\n  cont_diff_const.cont_diff_at\n#align cont_diff_at_const cont_diff_at_const\n\n",
 "cont_diff_at_comp_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰ƒL[ ] Â» -/\n/-- Composition by continuous linear equivs on the right respects higher differentiability at a\npoint. -/\ntheorem continuous_linear_equiv.cont_diff_at_comp_iff (e : Â«expr â‰ƒL[ ] Â» G ğ•œ E) :\n    cont_diff_at ğ•œ n (f âˆ˜ e) (e.symm x) â†” cont_diff_at ğ•œ n f x :=\n  by\n  rw [â† cont_diff_within_at_univ, â† cont_diff_within_at_univ, â† preimage_univ]\n  exact e.cont_diff_within_at_comp_iff\n#align continuous_linear_equiv.cont_diff_at_comp_iff continuous_linear_equiv.cont_diff_at_comp_iff\n\n",
 "cont_diff_at":
 "theorem cont_diff.cont_diff_at (h : cont_diff ğ•œ n f) : cont_diff_at ğ•œ n f x :=\n  cont_diff_iff_cont_diff_at.1 h x\n#align cont_diff.cont_diff_at cont_diff.cont_diff_at\n\n",
 "cont_diff_apply_apply":
 "theorem cont_diff_apply_apply (i : Î¹) (j : Î¹') : cont_diff ğ•œ n fun f : Î¹ â†’ Î¹' â†’ E => f i j :=\n  cont_diff_pi.mp (cont_diff_apply ğ•œ (Î¹' â†’ E) i) j\n#align cont_diff_apply_apply cont_diff_apply_apply\n\n",
 "cont_diff_apply":
 "theorem cont_diff_apply (i : Î¹) : cont_diff ğ•œ n fun f : Î¹ â†’ E => f i :=\n  cont_diff_pi.mp cont_diff_id i\n#align cont_diff_apply cont_diff_apply\n\n",
 "cont_diff_all_iff_nat":
 "theorem cont_diff_all_iff_nat : (âˆ€ n, cont_diff ğ•œ n f) â†” âˆ€ n : â„•, cont_diff ğ•œ n f := by\n  simp only [â† cont_diff_on_univ, cont_diff_on_all_iff_nat]\n#align cont_diff_all_iff_nat cont_diff_all_iff_nat\n\n",
 "cont_diff_add":
 "-- The sum is smooth.\ntheorem cont_diff_add : cont_diff ğ•œ n fun p : F Ã— F => p.1 + p.2 :=\n  (is_bounded_linear_map.fst.add is_bounded_linear_map.snd).cont_diff\n#align cont_diff_add cont_diff_add\n\n",
 "cont_diff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆÂ» -/\n/-- Bilinear functions are `C^âˆ`.\n-/\ntheorem is_bounded_bilinear_map.cont_diff (hb : is_bounded_bilinear_map ğ•œ b) : cont_diff ğ•œ n b :=\n  by\n  suffices h : cont_diff ğ•œ (Â«exprâˆÂ») b; Â· exact h.of_le le_top\n  rw [cont_diff_top_iff_fderiv]\n  refine' âŸ¨hb.differentiable, _âŸ©\n  simp [hb.fderiv]\n  exact hb.is_bounded_linear_map_deriv.cont_diff\n#align is_bounded_bilinear_map.cont_diff is_bounded_bilinear_map.cont_diff\n\n",
 "const_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/-- The scalar multiplication of a constant and a `C^n` on a domain is `C^n`. -/\ntheorem cont_diff_on.const_smul {s : set E} {f : E â†’ F} (c : R) (hf : cont_diff_on ğ•œ n f s) :\n    cont_diff_on ğ•œ n (fun y => Â«expr â€¢ Â» c (f y)) s := fun x hx => (hf x hx).const_smul c\n#align cont_diff_on.const_smul cont_diff_on.const_smul\n\n",
 "congr_of_eventually_eq_insert":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr =á¶ [ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\ntheorem cont_diff_within_at.congr_of_eventually_eq_insert (h : cont_diff_within_at ğ•œ n f s x)\n    (hâ‚ : Â«expr =á¶ [ ] Â» fâ‚ (nhds_within (insert x s) x) f) : cont_diff_within_at ğ•œ n fâ‚ s x :=\n  h.congr_of_eventually_eq (nhds_within_mono x (subset_insert x s) hâ‚) (mem_of_mem_nhds_within (mem_insert x s) hâ‚ : _)\n#align cont_diff_within_at.congr_of_eventually_eq_insert cont_diff_within_at.congr_of_eventually_eq_insert\n\n",
 "congr_of_eventually_eq'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr =á¶ [ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\ntheorem cont_diff_within_at.congr_of_eventually_eq' (h : cont_diff_within_at ğ•œ n f s x)\n    (hâ‚ : Â«expr =á¶ [ ] Â» fâ‚ (nhds_within s x) f) (hx : x âˆˆ s) : cont_diff_within_at ğ•œ n fâ‚ s x :=\n  h.congr_of_eventually_eq hâ‚ <| hâ‚.self_of_nhds_within hx\n#align cont_diff_within_at.congr_of_eventually_eq' cont_diff_within_at.congr_of_eventually_eq'\n\n",
 "congr_of_eventually_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr =á¶ [ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem cont_diff_at.congr_of_eventually_eq (h : cont_diff_at ğ•œ n f x) (hg : Â«expr =á¶ [ ] Â» fâ‚ ((nhds) x) f) :\n    cont_diff_at ğ•œ n fâ‚ x :=\n  h.congr_of_eventually_eq' (by rwa [nhds_within_univ]) (mem_univ x)\n#align cont_diff_at.congr_of_eventually_eq cont_diff_at.congr_of_eventually_eq\n\n",
 "congr_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\ntheorem cont_diff_within_at.congr_nhds (h : cont_diff_within_at ğ•œ n f s x) {t : set E}\n    (hst : nhds_within s x = nhds_within t x) : cont_diff_within_at ğ•œ n f t x :=\n  h.mono_of_mem <| hst â–¸ self_mem_nhds_within\n#align cont_diff_within_at.congr_nhds cont_diff_within_at.congr_nhds\n\n",
 "congr_mono":
 "theorem cont_diff_on.congr_mono (hf : cont_diff_on ğ•œ n f s) (hâ‚ : âˆ€ x âˆˆ sâ‚, fâ‚ x = f x) (hs : sâ‚ âŠ† s) :\n    cont_diff_on ğ•œ n fâ‚ sâ‚ :=\n  (hf.mono hs).congr hâ‚\n#align cont_diff_on.congr_mono cont_diff_on.congr_mono\n\n",
 "congr'":
 "theorem cont_diff_within_at.congr' (h : cont_diff_within_at ğ•œ n f s x) (hâ‚ : âˆ€ y âˆˆ s, fâ‚ y = f y) (hx : x âˆˆ s) :\n    cont_diff_within_at ğ•œ n fâ‚ s x :=\n  h.congr hâ‚ (hâ‚ _ hx)\n#align cont_diff_within_at.congr' cont_diff_within_at.congr'\n\n",
 "congr":
 "theorem cont_diff_on.congr (h : cont_diff_on ğ•œ n f s) (hâ‚ : âˆ€ x âˆˆ s, fâ‚ x = f x) : cont_diff_on ğ•œ n fâ‚ s := fun x hx =>\n  (h x hx).congr hâ‚ (hâ‚ x hx)\n#align cont_diff_on.congr cont_diff_on.congr\n\n",
 "compâ‚ƒ":
 "theorem cont_diff.compâ‚ƒ {g : Eâ‚ Ã— Eâ‚‚ Ã— Eâ‚ƒ â†’ G} {fâ‚ : F â†’ Eâ‚} {fâ‚‚ : F â†’ Eâ‚‚} {fâ‚ƒ : F â†’ Eâ‚ƒ} (hg : cont_diff ğ•œ n g)\n    (hfâ‚ : cont_diff ğ•œ n fâ‚) (hfâ‚‚ : cont_diff ğ•œ n fâ‚‚) (hfâ‚ƒ : cont_diff ğ•œ n fâ‚ƒ) :\n    cont_diff ğ•œ n fun x => g (fâ‚ x, fâ‚‚ x, fâ‚ƒ x) :=\n  hg.compâ‚‚ hfâ‚ <| hfâ‚‚.prod hfâ‚ƒ\n#align cont_diff.compâ‚ƒ cont_diff.compâ‚ƒ\n\n",
 "compâ‚‚":
 "theorem cont_diff.compâ‚‚ {g : Eâ‚ Ã— Eâ‚‚ â†’ G} {fâ‚ : F â†’ Eâ‚} {fâ‚‚ : F â†’ Eâ‚‚} (hg : cont_diff ğ•œ n g) (hfâ‚ : cont_diff ğ•œ n fâ‚)\n    (hfâ‚‚ : cont_diff ğ•œ n fâ‚‚) : cont_diff ğ•œ n fun x => g (fâ‚ x, fâ‚‚ x) :=\n  hg.comp <| hfâ‚.prod hfâ‚‚\n#align cont_diff.compâ‚‚ cont_diff.compâ‚‚\n\n",
 "comp_same_univ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/-- Auxiliary lemma proving that the composition of `C^n` functions on domains is `C^n` when all\nspaces live in the same universe. Use instead `cont_diff_on.comp` which removes the universe\nassumption (but is deduced from this one). -/\nprivate theorem cont_diff_on.comp_same_univ {Eu : Type u} [normed_add_comm_group Eu] [normed_space ğ•œ Eu] {Fu : Type u}\n    [normed_add_comm_group Fu] [normed_space ğ•œ Fu] {Gu : Type u} [normed_add_comm_group Gu] [normed_space ğ•œ Gu]\n    {s : set Eu} {t : set Fu} {g : Fu â†’ Gu} {f : Eu â†’ Fu} (hg : cont_diff_on ğ•œ n g t) (hf : cont_diff_on ğ•œ n f s)\n    (st : s âŠ† Â«expr â»Â¹' Â» f t) : cont_diff_on ğ•œ n (g âˆ˜ f) s :=\n  by\n  induction' n using enat.nat_induction with n IH Itop generalizing Eu Fu Gu\n  Â· rw [cont_diff_on_zero] at hf hgâŠ¢\n    exact continuous_on.comp hg hf st\n  Â· rw [cont_diff_on_succ_iff_has_fderiv_within_at] at hgâŠ¢\n    intro x hx\n    rcases(cont_diff_on_succ_iff_has_fderiv_within_at.1 hf) x hx with âŸ¨u, hu, f', hf', f'_diffâŸ©\n    rcases hg (f x) (st hx) with âŸ¨v, hv, g', hg', g'_diffâŸ©\n    rw [insert_eq_of_mem hx] at huâŠ¢\n    have xu : x âˆˆ u := mem_of_mem_nhds_within hx hu\n    let w := s âˆ© (u âˆ© Â«expr â»Â¹' Â» f v)\n    have wv : w âŠ† Â«expr â»Â¹' Â» f v := fun y hy => hy.2.2\n    have wu : w âŠ† u := fun y hy => hy.2.1\n    have ws : w âŠ† s := fun y hy => hy.1\n    refine' âŸ¨w, _, fun y => (g' (f y)).comp (f' y), _, _âŸ©\n    show w âˆˆ nhds_within s x\n    Â· apply filter.inter_mem self_mem_nhds_within\n      apply filter.inter_mem hu\n      apply continuous_within_at.preimage_mem_nhds_within'\n      Â· rw [â† continuous_within_at_inter' hu]\n        exact (hf' x xu).differentiable_within_at.continuous_within_at.mono (inter_subset_right _ _)\n      Â· apply nhds_within_mono _ _ hv\n        exact subset.trans (image_subset_iff.mpr st) (subset_insert (f x) t)\n    show âˆ€ y âˆˆ w, has_fderiv_within_at (g âˆ˜ f) ((g' (f y)).comp (f' y)) w y\n    Â· rintro y âŸ¨ys, yu, yvâŸ©\n      exact (hg' (f y) yv).comp y ((hf' y yu).mono wu) wv\n    show cont_diff_on ğ•œ n (fun y => (g' (f y)).comp (f' y)) w\n    Â· have A : cont_diff_on ğ•œ n (fun y => g' (f y)) w :=\n        IH g'_diff ((hf.of_le (WithTop.coe_le_coe.2 (nat.le_succ n))).mono ws) wv\n      have B : cont_diff_on ğ•œ n f' w := f'_diff.mono wu\n      have C : cont_diff_on ğ•œ n (fun y => (g' (f y), f' y)) w := A.prod B\n      have D : cont_diff_on ğ•œ n (fun p : Â«expr â†’L[ ] Â» Fu ğ•œ Gu Ã— Â«expr â†’L[ ] Â» Eu ğ•œ Fu => p.1.comp p.2) univ :=\n        is_bounded_bilinear_map_comp.cont_diff.cont_diff_on\n      exact IH D C (subset_univ _)\n  Â· rw [cont_diff_on_top] at hf hgâŠ¢\n    exact fun n => Itop n (hg n) (hf n) st\n#align cont_diff_on.comp_same_univ cont_diff_on.comp_same_univ\n\n",
 "comp_of_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/-- The composition of `C^n` functions at points in domains is `C^n`,\n  with a weaker condition on `s` and `t`. -/\ntheorem cont_diff_within_at.comp_of_mem {s : set E} {t : set F} {g : F â†’ G} {f : E â†’ F} (x : E)\n    (hg : cont_diff_within_at ğ•œ n g t (f x)) (hf : cont_diff_within_at ğ•œ n f s x)\n    (hs : t âˆˆ nhds_within (Â«expr '' Â» f s) (f x)) : cont_diff_within_at ğ•œ n (g âˆ˜ f) s x :=\n  (hg.mono_of_mem hs).comp x hf (subset_preimage_image f s)\n#align cont_diff_within_at.comp_of_mem cont_diff_within_at.comp_of_mem\n\n",
 "comp_continuous_linear_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/-- Composition by continuous linear maps on the right preserves `C^n` functions. -/\ntheorem cont_diff.comp_continuous_linear_map {f : E â†’ F} {g : Â«expr â†’L[ ] Â» G ğ•œ E} (hf : cont_diff ğ•œ n f) :\n    cont_diff ğ•œ n (f âˆ˜ g) :=\n  cont_diff_on_univ.1 <| cont_diff_on.comp_continuous_linear_map (cont_diff_on_univ.2 hf) _\n#align cont_diff.comp_continuous_linear_map cont_diff.comp_continuous_linear_map\n\n",
 "comp_cont_diff_within_at_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰ƒL[ ] Â» -/\n/-- Composition by continuous linear equivs on the left respects higher differentiability at a\npoint in a domain. -/\ntheorem continuous_linear_equiv.comp_cont_diff_within_at_iff (e : Â«expr â‰ƒL[ ] Â» F ğ•œ G) :\n    cont_diff_within_at ğ•œ n (e âˆ˜ f) s x â†” cont_diff_within_at ğ•œ n f s x :=\n  âŸ¨fun H => by\n    simpa only [(Â· âˆ˜ Â·), e.symm.coe_coe, e.symm_apply_apply] using\n      H.continuous_linear_map_comp (e.symm : Â«expr â†’L[ ] Â» G ğ•œ F),\n    fun H => H.continuous_linear_map_comp (e : Â«expr â†’L[ ] Â» F ğ•œ G)âŸ©\n#align continuous_linear_equiv.comp_cont_diff_within_at_iff continuous_linear_equiv.comp_cont_diff_within_at_iff\n\n",
 "comp_cont_diff_within_at":
 "theorem cont_diff.comp_cont_diff_within_at {g : F â†’ G} {f : E â†’ F} (h : cont_diff ğ•œ n g)\n    (hf : cont_diff_within_at ğ•œ n f t x) : cont_diff_within_at ğ•œ n (g âˆ˜ f) t x :=\n  haveI : cont_diff_within_at ğ•œ n g univ (f x) := h.cont_diff_at.cont_diff_within_at\n  this.comp x hf (subset_univ _)\n#align cont_diff.comp_cont_diff_within_at cont_diff.comp_cont_diff_within_at\n\n",
 "comp_cont_diff_onâ‚ƒ":
 "theorem cont_diff.comp_cont_diff_onâ‚ƒ {g : Eâ‚ Ã— Eâ‚‚ Ã— Eâ‚ƒ â†’ G} {fâ‚ : F â†’ Eâ‚} {fâ‚‚ : F â†’ Eâ‚‚} {fâ‚ƒ : F â†’ Eâ‚ƒ} {s : set F}\n    (hg : cont_diff ğ•œ n g) (hfâ‚ : cont_diff_on ğ•œ n fâ‚ s) (hfâ‚‚ : cont_diff_on ğ•œ n fâ‚‚ s) (hfâ‚ƒ : cont_diff_on ğ•œ n fâ‚ƒ s) :\n    cont_diff_on ğ•œ n (fun x => g (fâ‚ x, fâ‚‚ x, fâ‚ƒ x)) s :=\n  hg.comp_cont_diff_onâ‚‚ hfâ‚ <| hfâ‚‚.prod hfâ‚ƒ\n#align cont_diff.comp_cont_diff_onâ‚ƒ cont_diff.comp_cont_diff_onâ‚ƒ\n\n",
 "comp_cont_diff_onâ‚‚":
 "theorem cont_diff.comp_cont_diff_onâ‚‚ {g : Eâ‚ Ã— Eâ‚‚ â†’ G} {fâ‚ : F â†’ Eâ‚} {fâ‚‚ : F â†’ Eâ‚‚} {s : set F} (hg : cont_diff ğ•œ n g)\n    (hfâ‚ : cont_diff_on ğ•œ n fâ‚ s) (hfâ‚‚ : cont_diff_on ğ•œ n fâ‚‚ s) : cont_diff_on ğ•œ n (fun x => g (fâ‚ x, fâ‚‚ x)) s :=\n  hg.comp_cont_diff_on <| hfâ‚.prod hfâ‚‚\n#align cont_diff.comp_cont_diff_onâ‚‚ cont_diff.comp_cont_diff_onâ‚‚\n\n",
 "comp_cont_diff_on_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰ƒL[ ] Â» -/\n/-- Composition by continuous linear equivs on the left respects higher differentiability on\ndomains. -/\ntheorem continuous_linear_equiv.comp_cont_diff_on_iff (e : Â«expr â‰ƒL[ ] Â» F ğ•œ G) :\n    cont_diff_on ğ•œ n (e âˆ˜ f) s â†” cont_diff_on ğ•œ n f s := by simp [cont_diff_on, e.comp_cont_diff_within_at_iff]\n#align continuous_linear_equiv.comp_cont_diff_on_iff continuous_linear_equiv.comp_cont_diff_on_iff\n\n",
 "comp_cont_diff_on":
 "/-- The composition of a `C^n` function on a domain with a `C^n` function is `C^n`. -/\ntheorem cont_diff.comp_cont_diff_on {s : set E} {g : F â†’ G} {f : E â†’ F} (hg : cont_diff ğ•œ n g)\n    (hf : cont_diff_on ğ•œ n f s) : cont_diff_on ğ•œ n (g âˆ˜ f) s :=\n  (cont_diff_on_univ.2 hg).comp hf subset_preimage_univ\n#align cont_diff.comp_cont_diff_on cont_diff.comp_cont_diff_on\n\n",
 "comp_cont_diff_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰ƒL[ ] Â» -/\n/-- Composition by continuous linear equivs on the left respects higher differentiability. -/\ntheorem continuous_linear_equiv.comp_cont_diff_iff (e : Â«expr â‰ƒL[ ] Â» F ğ•œ G) :\n    cont_diff ğ•œ n (e âˆ˜ f) â†” cont_diff ğ•œ n f := by simp only [â† cont_diff_on_univ, e.comp_cont_diff_on_iff]\n#align continuous_linear_equiv.comp_cont_diff_iff continuous_linear_equiv.comp_cont_diff_iff\n\n",
 "comp_cont_diff_at_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰ƒL[ ] Â» -/\n/-- Composition by continuous linear equivs on the left respects higher differentiability at a\npoint. -/\ntheorem continuous_linear_equiv.comp_cont_diff_at_iff (e : Â«expr â‰ƒL[ ] Â» F ğ•œ G) :\n    cont_diff_at ğ•œ n (e âˆ˜ f) x â†” cont_diff_at ğ•œ n f x := by\n  simp only [â† cont_diff_within_at_univ, e.comp_cont_diff_within_at_iff]\n#align continuous_linear_equiv.comp_cont_diff_at_iff continuous_linear_equiv.comp_cont_diff_at_iff\n\n",
 "comp_cont_diff_at":
 "theorem cont_diff.comp_cont_diff_at {g : F â†’ G} {f : E â†’ F} (x : E) (hg : cont_diff ğ•œ n g) (hf : cont_diff_at ğ•œ n f x) :\n    cont_diff_at ğ•œ n (g âˆ˜ f) x :=\n  hg.comp_cont_diff_within_at hf\n#align cont_diff.comp_cont_diff_at cont_diff.comp_cont_diff_at\n\n",
 "comp'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/-- The composition of `C^n` functions at points in domains is `C^n`. -/\ntheorem cont_diff_within_at.comp' {s : set E} {t : set F} {g : F â†’ G} {f : E â†’ F} (x : E)\n    (hg : cont_diff_within_at ğ•œ n g t (f x)) (hf : cont_diff_within_at ğ•œ n f s x) :\n    cont_diff_within_at ğ•œ n (g âˆ˜ f) (s âˆ© Â«expr â»Â¹' Â» f t) x :=\n  hg.comp x (hf.mono (inter_subset_left _ _)) (inter_subset_right _ _)\n#align cont_diff_within_at.comp' cont_diff_within_at.comp'\n\n",
 "comp":
 "/-- The composition of `C^n` functions at points is `C^n`. -/\ntheorem cont_diff_at.comp (x : E) (hg : cont_diff_at ğ•œ n g (f x)) (hf : cont_diff_at ğ•œ n f x) :\n    cont_diff_at ğ•œ n (g âˆ˜ f) x :=\n  hg.comp x hf subset_preimage_univ\n#align cont_diff_at.comp cont_diff_at.comp\n\n",
 "clm_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\ntheorem cont_diff_on.clm_comp {g : X â†’ Â«expr â†’L[ ] Â» F ğ•œ G} {f : X â†’ Â«expr â†’L[ ] Â» E ğ•œ F} {s : set X}\n    (hg : cont_diff_on ğ•œ n g s) (hf : cont_diff_on ğ•œ n f s) : cont_diff_on ğ•œ n (fun x => (g x).comp (f x)) s :=\n  is_bounded_bilinear_map_comp.cont_diff.comp_cont_diff_onâ‚‚ hg hf\n#align cont_diff_on.clm_comp cont_diff_on.clm_comp\n\n",
 "add":
 "/-- The sum of two `C^n` functions on a domain is `C^n`. -/\ntheorem cont_diff_on.add {s : set E} {f g : E â†’ F} (hf : cont_diff_on ğ•œ n f s) (hg : cont_diff_on ğ•œ n g s) :\n    cont_diff_on ğ•œ n (fun x => f x + g x) s := fun x hx => (hf x hx).add (hg x hx)\n#align cont_diff_on.add cont_diff_on.add\n\n"}