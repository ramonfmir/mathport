{"sum_choose_succ_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/-\nCopyright (c) 2019 SÃ©bastien GouÃ«zel. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: SÃ©bastien GouÃ«zel, Floris van Doorn\n-/\n-- TODO porting note: move the next two lemmas to the file `data.nat.choose.sum`\n/-- The sum of `(n+1).choose i * f i (n+1-i)` can be split into two sums at rank `n`,\nrespectively of `n.choose i * f i (n+1-i)` and `n.choose i * f (i+1) (n-i)`. -/\ntheorem sum_choose_succ_mul {R : Type _} [Semiring R] (f : â„• â†’ â„• â†’ R) (n : â„•) :\n    finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (range (n + 2))\n        (((n + 1).choose i : R) * f i (n + 1 - i)) =\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (range (n + 1))\n          ((n.choose i : R) * f i (n + 1 - i)) +\n        finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (range (n + 1))\n          ((n.choose i : R) * f (i + 1) (n - i)) :=\n  by\n  have A :\n    finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (range (n + 1))\n          ((n.choose (i + 1) : R) * f (i + 1) (n - i)) +\n        f 0 (n + 1) =\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (range (n + 1))\n        (n.choose i * f i (n + 1 - i)) :=\n    by\n    rw [Finset.sum_range_succ, Finset.sum_range_succ']\n    simp only [Nat.choose_succ_self, algebraMap.coe_zero, MulZeroClass.zero_mul, add_zero, nat.succ_sub_succ_eq_sub,\n      Nat.choose_zero_right, algebraMap.coe_one, one_mul, tsub_zero]\n  calc\n    finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n          (Finset.range (n + 2)) (((n + 1).choose i : R) * f i (n + 1 - i)) =\n        finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n            (Finset.range (n + 1)) (((n + 1).choose (i + 1) : R) * f (i + 1) (n + 1 - (i + 1))) +\n          f 0 (n + 1 - 0) :=\n      by\n      rw [Finset.sum_range_succ']\n      simp only [Nat.choose_zero_right, algebraMap.coe_one, one_mul]\n    _ =\n        finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n            (Finset.range (n + 1)) ((n.choose i : R) * f i (n + 1 - i)) +\n          finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n            (Finset.range (n + 1)) (n.choose i * f (i + 1) (n - i)) :=\n      by\n      simp only [Nat.choose_succ_succ, Nat.cast_add, nat.succ_sub_succ_eq_sub, tsub_zero, add_mul]\n      rw [Finset.sum_add_distrib, â† A]\n      abel\n    \n#align sum_choose_succ_mul sum_choose_succ_mul\n\n",
 "sum_antidiagonal_choose_succ_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/-- The sum along the antidiagonal of `(n+1).choose i * f i j` can be split into two sums along the\nantidiagonal at rank `n`, respectively of `n.choose i * f i (j+1)` and `n.choose j * f (i+1) j`. -/\ntheorem sum_antidiagonal_choose_succ_mul {R : Type _} [Semiring R] (f : â„• â†’ â„• â†’ R) (n : â„•) :\n    finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n        (Nat.antidiagonal (n + 1)) (((n + 1).choose ij.1 : R) * f ij.1 ij.2) =\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n          (Nat.antidiagonal n) ((n.choose ij.1 : R) * f ij.1 (ij.2 + 1)) +\n        finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n          (Nat.antidiagonal n) ((n.choose ij.2 : R) * f (ij.1 + 1) ij.2) :=\n  by\n  convert sum_choose_succ_mul f n using 1\n  Â· exact nat.sum_antidiagonal_eq_sum_range_succ (fun i j => ((n + 1).choose i : R) * f i j) (n + 1)\n  congr 1\n  Â· rw [nat.sum_antidiagonal_eq_sum_range_succ (fun i j => (n.choose i : R) * f i (j + 1)) n]\n    apply Finset.sum_congr rfl fun i hi => _\n    have : n + 1 - i = n - i + 1 := nat.sub_add_comm (Nat.lt_succ_iff.1 (Finset.mem_range.1 hi))\n    simp only [this]\n  Â· suffices H :\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n          (nat.antidiagonal n) ((n.choose ij.2 : R) * f (ij.1 + 1) ij.2) =\n        finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n          (nat.antidiagonal n) ((n.choose ij.1 : R) * f (ij.1 + 1) ij.2)\n    Â· rw [H, nat.sum_antidiagonal_eq_sum_range_succ (fun i j => (n.choose i : R) * f (i + 1) j) n]\n    apply Finset.sum_congr rfl fun i hi => _\n    congr 2\n    apply Nat.choose_symm_of_eq_add\n    rw [â† nat.mem_antidiagonal.1 hi, add_comm]\n#align sum_antidiagonal_choose_succ_mul sum_antidiagonal_choose_succ_mul\n\n",
 "sum":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem cont_diff.sum {Î¹ : Type _} {f : Î¹ â†’ E â†’ F} {s : Finset Î¹} (h : âˆ€ i âˆˆ s, cont_diff ğ•œ n fun x => f i x) :\n    cont_diff ğ•œ n fun x =>\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s (f i x) :=\n  by simp only [â† cont_diff_on_univ] at * <;> exact cont_diff_on.sum h\n#align cont_diff.sum cont_diff.sum\n\n",
 "sub":
 "/-- The difference of two `C^n` functions is `C^n`. -/\ntheorem cont_diff.sub {f g : E â†’ F} (hf : cont_diff ğ•œ n f) (hg : cont_diff ğ•œ n g) : cont_diff ğ•œ n fun x => f x - g x :=\n  by simpa only [sub_eq_add_neg] using hf.add hg.neg\n#align cont_diff.sub cont_diff.sub\n\n",
 "snd''":
 "/-- Precomposing `f` with `prod.snd` is `C^n` at `x : E Ã— F` -/\ntheorem cont_diff_at.snd'' {f : F â†’ G} {x : E Ã— F} (hf : cont_diff_at ğ•œ n f x.2) :\n    cont_diff_at ğ•œ n (fun x : E Ã— F => f x.2) x :=\n  hf.comp x cont_diff_at_snd\n#align cont_diff_at.snd'' cont_diff_at.snd''\n\n",
 "snd'":
 "/-- Precomposing `f` with `prod.snd` is `C^n` at `(x, y)` -/\ntheorem cont_diff_at.snd' {f : F â†’ G} {x : E} {y : F} (hf : cont_diff_at ğ•œ n f y) :\n    cont_diff_at ğ•œ n (fun x : E Ã— F => f x.2) (x, y) :=\n  cont_diff_at.comp (x, y) hf cont_diff_at_snd\n#align cont_diff_at.snd' cont_diff_at.snd'\n\n",
 "snd":
 "/-- Postcomposing `f` with `prod.snd` is `C^n` at `x` -/\ntheorem cont_diff_at.snd {f : E â†’ F Ã— G} {x : E} (hf : cont_diff_at ğ•œ n f x) : cont_diff_at ğ•œ n (fun x => (f x).2) x :=\n  cont_diff_at_snd.comp x hf\n#align cont_diff_at.snd cont_diff_at.snd\n\n",
 "smul_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ„•âˆÂ» -/\ntheorem cont_diff.smul_right {f : E â†’ Â«expr â†’L[ ] Â» F ğ•œ ğ•œ} {g : E â†’ G} {n : Â«exprâ„•âˆÂ»} (hf : cont_diff ğ•œ n f)\n    (hg : cont_diff ğ•œ n g) : cont_diff ğ•œ n fun x => (f x).smul_right (g x) :=\n  (-- giving the following implicit type arguments speeds up elaboration significantly\n          @is_bounded_bilinear_map_smul_right\n          ğ•œ _ F _ _ G _ _).cont_diff.compâ‚‚\n    hf hg\n#align cont_diff.smul_right cont_diff.smul_right\n\n",
 "smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/-- The scalar multiplication of two `C^n` functions on a domain is `C^n`. -/\ntheorem cont_diff_on.smul {s : Set E} {f : E â†’ ğ•œ} {g : E â†’ F} (hf : cont_diff_on ğ•œ n f s) (hg : cont_diff_on ğ•œ n g s) :\n    cont_diff_on ğ•œ n (fun x => Â«expr â€¢ Â» (f x) (g x)) s := fun x hx => (hf x hx).smul (hg x hx)\n#align cont_diff_on.smul cont_diff_on.smul\n\n",
 "restrict_scalars":
 "theorem cont_diff.restrict_scalars (h : cont_diff ğ•œ' n f) : cont_diff ğ•œ n f :=\n  cont_diff_iff_cont_diff_at.2 fun x => h.cont_diff_at.restrict_scalars _\n#align cont_diff.restrict_scalars cont_diff.restrict_scalars\n\n",
 "prod_map'":
 "/-- The product map of two `C^n` functions within a set at a point is `C^n`\nwithin the product set at the product point. -/\ntheorem cont_diff_at.prod_map' {f : E â†’ F} {g : E' â†’ F'} {p : E Ã— E'} (hf : cont_diff_at ğ•œ n f p.1)\n    (hg : cont_diff_at ğ•œ n g p.2) : cont_diff_at ğ•œ n (prod.map f g) p :=\n  by\n  rcases p with âŸ¨âŸ©\n  exact cont_diff_at.prod_map hf hg\n#align cont_diff_at.prod_map' cont_diff_at.prod_map'\n\n",
 "prod_map":
 "/-- The product map of two `C^n` functions is `C^n`. -/\ntheorem cont_diff.prod_map {f : E â†’ F} {g : E' â†’ F'} (hf : cont_diff ğ•œ n f) (hg : cont_diff ğ•œ n g) :\n    cont_diff ğ•œ n (prod.map f g) := by\n  rw [cont_diff_iff_cont_diff_at] at *\n  exact fun âŸ¨x, yâŸ© => (hf x).prod_map (hg y)\n#align cont_diff.prod_map cont_diff.prod_map\n\n",
 "prod":
 "/-- The cartesian product of `C^n` functions is `C^n`.-/\ntheorem cont_diff.prod {f : E â†’ F} {g : E â†’ G} (hf : cont_diff ğ•œ n f) (hg : cont_diff ğ•œ n g) :\n    cont_diff ğ•œ n fun x : E => (f x, g x) :=\n  cont_diff_on_univ.1 <| cont_diff_on.prod (cont_diff_on_univ.2 hf) (cont_diff_on_univ.2 hg)\n#align cont_diff.prod cont_diff.prod\n\n",
 "pow":
 "theorem cont_diff_on.pow {f : E â†’ ğ”¸} (hf : cont_diff_on ğ•œ n f s) (m : â„•) : cont_diff_on ğ•œ n (fun y => f y ^ m) s :=\n  fun y hy => (hf y hy).pow m\n#align cont_diff_on.pow cont_diff_on.pow\n\n",
 "norm_iterated_fderiv_within_smul_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ„•âˆÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ„•âˆÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\ntheorem norm_iterated_fderiv_within_smul_le {f : E â†’ ğ•œ'} {g : E â†’ F} {N : Â«exprâ„•âˆÂ»} (hf : cont_diff_on ğ•œ N f s)\n    (hg : cont_diff_on ğ•œ N g s) (hs : unique_diff_on ğ•œ s) {x : E} (hx : x âˆˆ s) {n : â„•} (hn : (n : Â«exprâ„•âˆÂ») â‰¤ N) :\n    Â«exprâ€– â€–Â» (iterated_fderiv_within ğ•œ n (fun y => Â«expr â€¢ Â» (f y) (g y)) s x) â‰¤\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n        (Finset.range (n + 1))\n        ((n.choose i : exprâ„) * Â«exprâ€– â€–Â» (iterated_fderiv_within ğ•œ i f s x) *\n          Â«exprâ€– â€–Â» (iterated_fderiv_within ğ•œ (n - i) g s x)) :=\n  (continuous_linear_map.lsmul ğ•œ ğ•œ' :\n        Â«expr â†’L[ ] Â» ğ•œ' ğ•œ (Â«expr â†’L[ ] Â» F ğ•œ F)).norm_iterated_fderiv_within_le_of_bilinear_of_le_one\n    hf hg hs hx hn continuous_linear_map.op_norm_lsmul_le\n#align norm_iterated_fderiv_within_smul_le norm_iterated_fderiv_within_smul_le\n\n",
 "norm_iterated_fderiv_within_mul_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ„•âˆÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ„•âˆÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\ntheorem norm_iterated_fderiv_within_mul_le {f : E â†’ A} {g : E â†’ A} {N : Â«exprâ„•âˆÂ»} (hf : cont_diff_on ğ•œ N f s)\n    (hg : cont_diff_on ğ•œ N g s) (hs : unique_diff_on ğ•œ s) {x : E} (hx : x âˆˆ s) {n : â„•} (hn : (n : Â«exprâ„•âˆÂ») â‰¤ N) :\n    Â«exprâ€– â€–Â» (iterated_fderiv_within ğ•œ n (fun y => f y * g y) s x) â‰¤\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n        (Finset.range (n + 1))\n        ((n.choose i : exprâ„) * Â«exprâ€– â€–Â» (iterated_fderiv_within ğ•œ i f s x) *\n          Â«exprâ€– â€–Â» (iterated_fderiv_within ğ•œ (n - i) g s x)) :=\n  (continuous_linear_map.mul ğ•œ A :\n        Â«expr â†’L[ ] Â» A ğ•œ (Â«expr â†’L[ ] Â» A ğ•œ A)).norm_iterated_fderiv_within_le_of_bilinear_of_le_one\n    hf hg hs hx hn (continuous_linear_map.op_norm_mul_le _ _)\n#align norm_iterated_fderiv_within_mul_le norm_iterated_fderiv_within_mul_le\n\n",
 "norm_iterated_fderiv_within_le_of_bilinear_of_le_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ„•âˆÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ„•âˆÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/-- Bounding the norm of the iterated derivative of `B (f x) (g x)` within a set in terms of the\niterated derivatives of `f` and `g` when `B` is bilinear of norm at most `1`:\n`â€–D^n (x â†¦ B (f x) (g x))â€– â‰¤ âˆ‘_{k â‰¤ n} n.choose k â€–D^k fâ€– â€–D^{n-k} gâ€–` -/\ntheorem continuous_linear_map.norm_iterated_fderiv_within_le_of_bilinear_of_le_one\n    (B : Â«expr â†’L[ ] Â» E ğ•œ (Â«expr â†’L[ ] Â» F ğ•œ G)) {f : D â†’ E} {g : D â†’ F} {N : Â«exprâ„•âˆÂ»} {s : Set D} {x : D}\n    (hf : cont_diff_on ğ•œ N f s) (hg : cont_diff_on ğ•œ N g s) (hs : unique_diff_on ğ•œ s) (hx : x âˆˆ s) {n : â„•}\n    (hn : (n : Â«exprâ„•âˆÂ») â‰¤ N) (hB : Â«exprâ€– â€–Â» B â‰¤ 1) :\n    Â«exprâ€– â€–Â» (iterated_fderiv_within ğ•œ n (fun y => B (f y) (g y)) s x) â‰¤\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n        (Finset.range (n + 1))\n        ((n.choose i : exprâ„) * Â«exprâ€– â€–Â» (iterated_fderiv_within ğ•œ i f s x) *\n          Â«exprâ€– â€–Â» (iterated_fderiv_within ğ•œ (n - i) g s x)) :=\n  by\n  apply (B.norm_iterated_fderiv_within_le_of_bilinear hf hg hs hx hn).trans\n  apply mul_le_of_le_one_left (Finset.sum_nonneg' fun i => _) hB\n  positivity\n#align continuous_linear_map.norm_iterated_fderiv_within_le_of_bilinear_of_le_one continuous_linear_map.norm_iterated_fderiv_within_le_of_bilinear_of_le_one\n\n",
 "norm_iterated_fderiv_within_le_of_bilinear_aux":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ„•âˆÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ„•âˆÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/-- Bounding the norm of the iterated derivative of `B (f x) (g x)` within a set in terms of the\niterated derivatives of `f` and `g` when `B` is bilinear. This lemma is an auxiliary version\nassuming all spaces live in the same universe, to enable an induction. Use instead\n`continuous_linear_map.norm_iterated_fderiv_within_le_of_bilinear` that removes this assumption. -/\ntheorem continuous_linear_map.norm_iterated_fderiv_within_le_of_bilinear_aux {Du Eu Fu Gu : Type u}\n    [NormedAddCommGroup Du] [NormedSpace ğ•œ Du] [NormedAddCommGroup Eu] [NormedSpace ğ•œ Eu] [NormedAddCommGroup Fu]\n    [NormedSpace ğ•œ Fu] [NormedAddCommGroup Gu] [NormedSpace ğ•œ Gu] (B : Â«expr â†’L[ ] Â» Eu ğ•œ (Â«expr â†’L[ ] Â» Fu ğ•œ Gu))\n    {f : Du â†’ Eu} {g : Du â†’ Fu} {n : â„•} {s : Set Du} {x : Du} (hf : cont_diff_on ğ•œ n f s) (hg : cont_diff_on ğ•œ n g s)\n    (hs : unique_diff_on ğ•œ s) (hx : x âˆˆ s) :\n    Â«exprâ€– â€–Â» (iterated_fderiv_within ğ•œ n (fun y => B (f y) (g y)) s x) â‰¤\n      Â«exprâ€– â€–Â» B *\n        finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n          (Finset.range (n + 1))\n          ((n.choose i : exprâ„) * Â«exprâ€– â€–Â» (iterated_fderiv_within ğ•œ i f s x) *\n            Â«exprâ€– â€–Â» (iterated_fderiv_within ğ•œ (n - i) g s x)) :=\n  by\n  /- We argue by induction on `n`. The bound is trivial for `n = 0`. For `n + 1`, we write\n    the `(n+1)`-th derivative as the `n`-th derivative of the derivative `B f g' + B f' g`, and apply\n    the inductive assumption to each of those two terms. For this induction to make sense,\n    the spaces of linear maps that appear in the induction should be in the same universe as the\n    original spaces, which explains why we assume in the lemma that all spaces live in the same\n    universe. -/\n  induction' n with n IH generalizing Eu Fu Gu\n  Â· simp only [â† mul_assoc, norm_iterated_fderiv_within_zero, Finset.range_one, Finset.sum_singleton, Nat.choose_self,\n      algebraMap.coe_one, one_mul]\n    apply ((B (f x)).le_op_norm (g x)).trans\n    apply mul_le_mul_of_nonneg_right _ (norm_nonneg _)\n    exact B.le_op_norm (f x)\n  Â· have In : (n : Â«exprâ„•âˆÂ») + 1 â‰¤ n.succ := by simp only [Nat.cast_succ, le_refl]\n    have I1 :\n      Â«exprâ€– â€–Â» (iterated_fderiv_within ğ•œ n (fun y : Du => B.precompR Du (f y) (fderiv_within ğ•œ g s y)) s x) â‰¤\n        Â«exprâ€– â€–Â» B *\n          finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n            (Finset.range (n + 1))\n            (n.choose i * Â«exprâ€– â€–Â» (iterated_fderiv_within ğ•œ i f s x) *\n              Â«exprâ€– â€–Â» (iterated_fderiv_within ğ•œ (n + 1 - i) g s x)) :=\n      calc\n        Â«exprâ€– â€–Â» (iterated_fderiv_within ğ•œ n (fun y : Du => B.precompR Du (f y) (fderiv_within ğ•œ g s y)) s x) â‰¤\n            Â«exprâ€– â€–Â» (B.precompR Du) *\n              finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n                (Finset.range (n + 1))\n                (n.choose i * Â«exprâ€– â€–Â» (iterated_fderiv_within ğ•œ i f s x) *\n                  Â«exprâ€– â€–Â» (iterated_fderiv_within ğ•œ (n - i) (fderiv_within ğ•œ g s) s x)) :=\n          IH _ (hf.of_le (Nat.cast_le.2 (nat.le_succ n))) (hg.fderiv_within hs In)\n        _ â‰¤\n            Â«exprâ€– â€–Â» B *\n              finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n                (Finset.range (n + 1))\n                (n.choose i * Â«exprâ€– â€–Â» (iterated_fderiv_within ğ•œ i f s x) *\n                  Â«exprâ€– â€–Â» (iterated_fderiv_within ğ•œ (n - i) (fderiv_within ğ•œ g s) s x)) :=\n          (mul_le_mul_of_nonneg_right (B.norm_precompR_le Du) (Finset.sum_nonneg' fun i => by positivity))\n        _ = _ := by\n          congr 1\n          apply Finset.sum_congr rfl fun i hi => _\n          rw [nat.succ_sub (Nat.lt_succ_iff.1 (Finset.mem_range.1 hi)), iterated_fderiv_within_succ_eq_comp_right hs hx,\n            LinearIsometryEquiv.norm_map]\n        \n    have I2 :\n      Â«exprâ€– â€–Â» (iterated_fderiv_within ğ•œ n (fun y : Du => B.precompL Du (fderiv_within ğ•œ f s y) (g y)) s x) â‰¤\n        Â«exprâ€– â€–Â» B *\n          finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n            (Finset.range (n + 1))\n            (n.choose i * Â«exprâ€– â€–Â» (iterated_fderiv_within ğ•œ (i + 1) f s x) *\n              Â«exprâ€– â€–Â» (iterated_fderiv_within ğ•œ (n - i) g s x)) :=\n      calc\n        Â«exprâ€– â€–Â» (iterated_fderiv_within ğ•œ n (fun y : Du => B.precompL Du (fderiv_within ğ•œ f s y) (g y)) s x) â‰¤\n            Â«exprâ€– â€–Â» (B.precompL Du) *\n              finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n                (Finset.range (n + 1))\n                (n.choose i * Â«exprâ€– â€–Â» (iterated_fderiv_within ğ•œ i (fderiv_within ğ•œ f s) s x) *\n                  Â«exprâ€– â€–Â» (iterated_fderiv_within ğ•œ (n - i) g s x)) :=\n          IH _ (hf.fderiv_within hs In) (hg.of_le (Nat.cast_le.2 (nat.le_succ n)))\n        _ â‰¤\n            Â«exprâ€– â€–Â» B *\n              finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n                (Finset.range (n + 1))\n                (n.choose i * Â«exprâ€– â€–Â» (iterated_fderiv_within ğ•œ i (fderiv_within ğ•œ f s) s x) *\n                  Â«exprâ€– â€–Â» (iterated_fderiv_within ğ•œ (n - i) g s x)) :=\n          (mul_le_mul_of_nonneg_right (B.norm_precompL_le Du) (Finset.sum_nonneg' fun i => by positivity))\n        _ = _ := by\n          congr 1\n          apply Finset.sum_congr rfl fun i hi => _\n          rw [iterated_fderiv_within_succ_eq_comp_right hs hx, LinearIsometryEquiv.norm_map]\n        \n    have J :\n      iterated_fderiv_within ğ•œ n (fun y : Du => fderiv_within ğ•œ (fun y : Du => B (f y) (g y)) s y) s x =\n        iterated_fderiv_within ğ•œ n\n          (fun y => B.precompR Du (f y) (fderiv_within ğ•œ g s y) + B.precompL Du (fderiv_within ğ•œ f s y) (g y)) s x :=\n      by\n      apply iterated_fderiv_within_congr hs (fun y hy => _) hx\n      have L : (1 : Â«exprâ„•âˆÂ») â‰¤ n.succ := by simpa only [ENat.coe_one, Nat.one_le_cast] using nat.succ_pos n\n      exact B.fderiv_within_of_bilinear (hf.differentiable_on L y hy) (hg.differentiable_on L y hy) (hs y hy)\n    rw [iterated_fderiv_within_succ_eq_comp_right hs hx, LinearIsometryEquiv.norm_map, J]\n    have A : cont_diff_on ğ•œ n (fun y => B.precompR Du (f y) (fderiv_within ğ•œ g s y)) s :=\n      (B.precompR Du).is_bounded_bilinear_map.cont_diff.comp_cont_diff_onâ‚‚ (hf.of_le (Nat.cast_le.2 (nat.le_succ n)))\n        (hg.fderiv_within hs In)\n    have A' : cont_diff_on ğ•œ n (fun y => B.precompL Du (fderiv_within ğ•œ f s y) (g y)) s :=\n      (B.precompL Du).is_bounded_bilinear_map.cont_diff.comp_cont_diff_onâ‚‚ (hf.fderiv_within hs In)\n        (hg.of_le (Nat.cast_le.2 (nat.le_succ n)))\n    rw [iterated_fderiv_within_add_apply' A A' hs hx]\n    apply (norm_add_le _ _).trans ((add_le_add I1 I2).trans (le_of_eq _))\n    simp_rw [â† mul_add, mul_assoc]\n    congr 1\n    exact\n      (finset.sum_choose_succ_mul\n          (fun i j => Â«exprâ€– â€–Â» (iterated_fderiv_within ğ•œ i f s x) * Â«exprâ€– â€–Â» (iterated_fderiv_within ğ•œ j g s x))\n          n).symm\n#align continuous_linear_map.norm_iterated_fderiv_within_le_of_bilinear_aux continuous_linear_map.norm_iterated_fderiv_within_le_of_bilinear_aux\n\n",
 "norm_iterated_fderiv_within_le_of_bilinear":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰ƒâ‚—áµ¢[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰ƒâ‚—áµ¢[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰ƒâ‚—áµ¢[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰ƒâ‚—áµ¢[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ„•âˆÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ„•âˆÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/-- Bounding the norm of the iterated derivative of `B (f x) (g x)` within a set in terms of the\niterated derivatives of `f` and `g` when `B` is bilinear:\n`â€–D^n (x â†¦ B (f x) (g x))â€– â‰¤ â€–Bâ€– âˆ‘_{k â‰¤ n} n.choose k â€–D^k fâ€– â€–D^{n-k} gâ€–` -/\ntheorem continuous_linear_map.norm_iterated_fderiv_within_le_of_bilinear (B : Â«expr â†’L[ ] Â» E ğ•œ (Â«expr â†’L[ ] Â» F ğ•œ G))\n    {f : D â†’ E} {g : D â†’ F} {N : Â«exprâ„•âˆÂ»} {s : Set D} {x : D} (hf : cont_diff_on ğ•œ N f s) (hg : cont_diff_on ğ•œ N g s)\n    (hs : unique_diff_on ğ•œ s) (hx : x âˆˆ s) {n : â„•} (hn : (n : Â«exprâ„•âˆÂ») â‰¤ N) :\n    Â«exprâ€– â€–Â» (iterated_fderiv_within ğ•œ n (fun y => B (f y) (g y)) s x) â‰¤\n      Â«exprâ€– â€–Â» B *\n        finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n          (Finset.range (n + 1))\n          ((n.choose i : exprâ„) * Â«exprâ€– â€–Â» (iterated_fderiv_within ğ•œ i f s x) *\n            Â«exprâ€– â€–Â» (iterated_fderiv_within ğ•œ (n - i) g s x)) :=\n  by\n  /- We reduce the bound to the case where all spaces live in the same universe (in which we\n    already have proved the result), by using linear isometries between the spaces and their `ulift`\n    to a common universe. These linear isometries preserve the norm of the iterated derivative. -/\n  let Du : Type max uD uE uF uG := ULift.{max uE uF uG, uD} D\n  let Eu : Type max uD uE uF uG := ULift.{max uD uF uG, uE} E\n  let Fu : Type max uD uE uF uG := ULift.{max uD uE uG, uF} F\n  let Gu : Type max uD uE uF uG := ULift.{max uD uE uF, uG} G\n  have isoD : Â«expr â‰ƒâ‚—áµ¢[ ] Â» Du ğ•œ D := LinearIsometryEquiv.ulift ğ•œ D\n  have isoE : Â«expr â‰ƒâ‚—áµ¢[ ] Â» Eu ğ•œ E := LinearIsometryEquiv.ulift ğ•œ E\n  have isoF : Â«expr â‰ƒâ‚—áµ¢[ ] Â» Fu ğ•œ F := LinearIsometryEquiv.ulift ğ•œ F\n  have isoG : Â«expr â‰ƒâ‚—áµ¢[ ] Â» Gu ğ•œ G := LinearIsometryEquiv.ulift ğ•œ G\n  -- lift `f` and `g` to versions `fu` and `gu` on the lifted spaces.\n  let fu : Du â†’ Eu := isoE.symm âˆ˜ f âˆ˜ isoD\n  let gu : Du â†’ Fu := isoF.symm âˆ˜ g âˆ˜ isoD\n  -- lift the bilinear map `B` to a bilinear map `Bu` on the lifted spaces.\n  let Buâ‚€ : Â«expr â†’L[ ] Â» Eu ğ•œ (Â«expr â†’L[ ] Â» Fu ğ•œ G)\n  exact ((B.comp (isoE : Â«expr â†’L[ ] Â» Eu ğ•œ E)).flip.comp (isoF : Â«expr â†’L[ ] Â» Fu ğ•œ F)).flip\n  let Bu : Â«expr â†’L[ ] Â» Eu ğ•œ (Â«expr â†’L[ ] Â» Fu ğ•œ Gu)\n  exact\n    continuous_linear_map.compL ğ•œ Eu (Â«expr â†’L[ ] Â» Fu ğ•œ G) (Â«expr â†’L[ ] Â» Fu ğ•œ Gu)\n      (continuous_linear_map.compL ğ•œ Fu G Gu (isoG.symm : Â«expr â†’L[ ] Â» G ğ•œ Gu)) Buâ‚€\n  have Bu_eq : (fun y => Bu (fu y) (gu y)) = isoG.symm âˆ˜ (fun y => B (f y) (g y)) âˆ˜ isoD :=\n    by\n    ext1 y\n    simp only [Bu, continuous_linear_map.compL_apply, Function.comp_apply, ContinuousLinearMap.coe_comp',\n      LinearIsometryEquiv.coe_coe'', continuous_linear_map.flip_apply, LinearIsometryEquiv.apply_symm_apply]\n  -- All norms are preserved by the lifting process.\n  have Bu_le : Â«exprâ€– â€–Â» Bu â‰¤ Â«exprâ€– â€–Â» B :=\n    by\n    refine' continuous_linear_map.op_norm_le_bound _ (norm_nonneg _) fun y => _\n    refine' continuous_linear_map.op_norm_le_bound _ (by positivity) fun x => _\n    simp only [Bu, continuous_linear_map.compL_apply, ContinuousLinearMap.coe_comp', Function.comp_apply,\n      LinearIsometryEquiv.coe_coe'', continuous_linear_map.flip_apply, LinearIsometryEquiv.norm_map]\n    calc\n      Â«exprâ€– â€–Â» (B (isoE y) (isoF x)) â‰¤ Â«exprâ€– â€–Â» (B (isoE y)) * Â«exprâ€– â€–Â» (isoF x) :=\n        continuous_linear_map.le_op_norm _ _\n      _ â‰¤ Â«exprâ€– â€–Â» B * Â«exprâ€– â€–Â» (isoE y) * Â«exprâ€– â€–Â» (isoF x) :=\n        (mul_le_mul_of_nonneg_right (continuous_linear_map.le_op_norm _ _) (norm_nonneg _))\n      _ = Â«exprâ€– â€–Â» B * Â«exprâ€– â€–Â» y * Â«exprâ€– â€–Â» x := by simp only [LinearIsometryEquiv.norm_map]\n      \n  let su := Â«expr â»Â¹' Â» isoD s\n  have hsu : unique_diff_on ğ•œ su := isoD.to_continuous_linear_equiv.unique_diff_on_preimage_iff.2 hs\n  let xu := isoD.symm x\n  have hxu : xu âˆˆ su := by simpa only [Set.mem_preimage, LinearIsometryEquiv.apply_symm_apply] using hx\n  have xu_x : isoD xu = x := by simp only [LinearIsometryEquiv.apply_symm_apply]\n  have hfu : cont_diff_on ğ•œ n fu su :=\n    isoE.symm.cont_diff.comp_cont_diff_on ((hf.of_le hn).comp_continuous_linear_map (isoD : Â«expr â†’L[ ] Â» Du ğ•œ D))\n  have hgu : cont_diff_on ğ•œ n gu su :=\n    isoF.symm.cont_diff.comp_cont_diff_on ((hg.of_le hn).comp_continuous_linear_map (isoD : Â«expr â†’L[ ] Â» Du ğ•œ D))\n  have Nfu : âˆ€ i, Â«exprâ€– â€–Â» (iterated_fderiv_within ğ•œ i fu su xu) = Â«exprâ€– â€–Â» (iterated_fderiv_within ğ•œ i f s x) :=\n    by\n    intro i\n    rw [linear_isometry_equiv.norm_iterated_fderiv_within_comp_left _ _ hsu hxu]\n    rw [linear_isometry_equiv.norm_iterated_fderiv_within_comp_right _ _ hs, xu_x]\n    rwa [â† xu_x] at hx\n  have Ngu : âˆ€ i, Â«exprâ€– â€–Â» (iterated_fderiv_within ğ•œ i gu su xu) = Â«exprâ€– â€–Â» (iterated_fderiv_within ğ•œ i g s x) :=\n    by\n    intro i\n    rw [linear_isometry_equiv.norm_iterated_fderiv_within_comp_left _ _ hsu hxu]\n    rw [linear_isometry_equiv.norm_iterated_fderiv_within_comp_right _ _ hs, xu_x]\n    rwa [â† xu_x] at hx\n  have NBu :\n    Â«exprâ€– â€–Â» (iterated_fderiv_within ğ•œ n (fun y => Bu (fu y) (gu y)) su xu) =\n      Â«exprâ€– â€–Â» (iterated_fderiv_within ğ•œ n (fun y => B (f y) (g y)) s x) :=\n    by\n    rw [Bu_eq]\n    rw [linear_isometry_equiv.norm_iterated_fderiv_within_comp_left _ _ hsu hxu]\n    rw [linear_isometry_equiv.norm_iterated_fderiv_within_comp_right _ _ hs, xu_x]\n    rwa [â† xu_x] at hx\n  -- state the bound for the lifted objects, and deduce the original bound from it.\n  have :\n    Â«exprâ€– â€–Â» (iterated_fderiv_within ğ•œ n (fun y => Bu (fu y) (gu y)) su xu) â‰¤\n      Â«exprâ€– â€–Â» Bu *\n        finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n          (Finset.range (n + 1))\n          ((n.choose i : exprâ„) * Â«exprâ€– â€–Â» (iterated_fderiv_within ğ•œ i fu su xu) *\n            Â«exprâ€– â€–Â» (iterated_fderiv_within ğ•œ (n - i) gu su xu)) :=\n    Bu.norm_iterated_fderiv_within_le_of_bilinear_aux hfu hgu hsu hxu\n  simp only [Nfu, Ngu, NBu] at this\n  apply this.trans (mul_le_mul_of_nonneg_right Bu_le _)\n  exact Finset.sum_nonneg' fun i => by positivity\n#align continuous_linear_map.norm_iterated_fderiv_within_le_of_bilinear continuous_linear_map.norm_iterated_fderiv_within_le_of_bilinear\n\n",
 "norm_iterated_fderiv_within_comp_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰ƒâ‚—áµ¢[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/-- Composition with a linear isometry on the right preserves the norm of the iterated derivative\nwithin a set. -/\ntheorem linear_isometry_equiv.norm_iterated_fderiv_within_comp_right (g : Â«expr â‰ƒâ‚—áµ¢[ ] Â» G ğ•œ E) (f : E â†’ F)\n    (hs : unique_diff_on ğ•œ s) {x : G} (hx : g x âˆˆ s) (i : â„•) :\n    Â«exprâ€– â€–Â» (iterated_fderiv_within ğ•œ i (f âˆ˜ g) (Â«expr â»Â¹' Â» g s) x) =\n      Â«exprâ€– â€–Â» (iterated_fderiv_within ğ•œ i f s (g x)) :=\n  by\n  have :\n    iterated_fderiv_within ğ•œ i (f âˆ˜ g) (Â«expr â»Â¹' Â» g s) x =\n      (iterated_fderiv_within ğ•œ i f s (g x)).comp_continuous_linear_map fun _ => g :=\n    g.to_continuous_linear_equiv.iterated_fderiv_within_comp_right f hs hx i\n  rw [this, continuous_multilinear_map.norm_comp_continuous_linear_isometry_equiv]\n#align linear_isometry_equiv.norm_iterated_fderiv_within_comp_right linear_isometry_equiv.norm_iterated_fderiv_within_comp_right\n\n",
 "norm_iterated_fderiv_within_comp_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰ƒâ‚—áµ¢[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/-- Composition with a linear isometry equiv on the left preserves the norm of the iterated\nderivative within a set. -/\ntheorem linear_isometry_equiv.norm_iterated_fderiv_within_comp_left (g : Â«expr â‰ƒâ‚—áµ¢[ ] Â» F ğ•œ G) (f : E â†’ F)\n    (hs : unique_diff_on ğ•œ s) (hx : x âˆˆ s) (i : â„•) :\n    Â«exprâ€– â€–Â» (iterated_fderiv_within ğ•œ i (g âˆ˜ f) s x) = Â«exprâ€– â€–Â» (iterated_fderiv_within ğ•œ i f s x) :=\n  by\n  have :\n    iterated_fderiv_within ğ•œ i (g âˆ˜ f) s x =\n      (g : Â«expr â†’L[ ] Â» F ğ•œ G).comp_continuous_multilinear_map (iterated_fderiv_within ğ•œ i f s x) :=\n    g.to_continuous_linear_equiv.iterated_fderiv_within_comp_left f hs hx i\n  rw [this]\n  apply linear_isometry.norm_comp_continuous_multilinear_map g.to_linear_isometry\n#align linear_isometry_equiv.norm_iterated_fderiv_within_comp_left linear_isometry_equiv.norm_iterated_fderiv_within_comp_left\n\n",
 "norm_iterated_fderiv_within_comp_le_aux":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ„•âˆÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ„•âˆÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\n/-- If the derivatives within a set of `g` at `f x` are bounded by `C`, and the `i`-th derivative\nwithin a set of `f` at `x` is bounded by `D^i` for all `1 â‰¤ i â‰¤ n`, then the `n`-th derivative\nof `g âˆ˜ f` is bounded by `n! * C * D^n`.\nThis lemma proves this estimate assuming additionally that two of the spaces live in the same\nuniverse, to make an induction possible. Use instead `norm_iterated_fderiv_within_comp_le` that\nremoves this assumption. -/\ntheorem norm_iterated_fderiv_within_comp_le_aux {Fu Gu : Type u} [NormedAddCommGroup Fu] [NormedSpace ğ•œ Fu]\n    [NormedAddCommGroup Gu] [NormedSpace ğ•œ Gu] {g : Fu â†’ Gu} {f : E â†’ Fu} {n : â„•} {s : Set E} {t : Set Fu} {x : E}\n    (hg : cont_diff_on ğ•œ n g t) (hf : cont_diff_on ğ•œ n f s) (ht : unique_diff_on ğ•œ t) (hs : unique_diff_on ğ•œ s)\n    (hst : MapsTo f s t) (hx : x âˆˆ s) {C : exprâ„} {D : exprâ„}\n    (hC : âˆ€ i, i â‰¤ n â†’ Â«exprâ€– â€–Â» (iterated_fderiv_within ğ•œ i g t (f x)) â‰¤ C)\n    (hD : âˆ€ i, 1 â‰¤ i â†’ i â‰¤ n â†’ Â«exprâ€– â€–Â» (iterated_fderiv_within ğ•œ i f s x) â‰¤ D ^ i) :\n    Â«exprâ€– â€–Â» (iterated_fderiv_within ğ•œ n (g âˆ˜ f) s x) â‰¤ nat.factorial n * C * D ^ n :=\n  by\n  /- We argue by induction on `n`, using that `D^(n+1) (g âˆ˜ f) = D^n (g ' âˆ˜ f â¬ f')`. The successive\n    derivatives of `g' âˆ˜ f` are controlled thanks to the inductive assumption, and those of `f'` are\n    controlled by assumption.\n    As composition of linear maps is a bilinear map, one may use\n    `continuous_linear_map.norm_iterated_fderiv_le_of_bilinear_of_le_one` to get from these a bound\n    on `D^n (g ' âˆ˜ f â¬ f')`. -/\n  induction' n using nat.case_strong_induction_on with n IH generalizing Gu\n  Â·\n    simpa only [norm_iterated_fderiv_within_zero, Nat.factorial_zero, algebraMap.coe_one, one_mul, pow_zero,\n      mul_one] using hC 0 le_rfl\n  have M : (n : Â«exprâ„•âˆÂ») < n.succ := Nat.cast_lt.2 n.lt_succ_self\n  have Cnonneg : 0 â‰¤ C := (norm_nonneg _).trans (hC 0 bot_le)\n  have Dnonneg : 0 â‰¤ D := by\n    have : 1 â‰¤ n + 1 := by simp only [le_add_iff_nonneg_left, zero_le']\n    simpa only [pow_one] using (norm_nonneg _).trans (hD 1 le_rfl this)\n  -- use the inductive assumption to bound the derivatives of `g' âˆ˜ f`.\n  have I :\n    âˆ€ i âˆˆ Finset.range (n + 1),\n      Â«exprâ€– â€–Â» (iterated_fderiv_within ğ•œ i (fderiv_within ğ•œ g t âˆ˜ f) s x) â‰¤ nat.factorial i * C * D ^ i :=\n    by\n    intro i hi\n    simp only [Finset.mem_range_succ_iff] at hi\n    apply IH i hi\n    apply hf.of_le (Nat.cast_le.2 (hi.trans n.le_succ))\n    Â· intro j hj h'j\n      exact hD j hj (h'j.trans (hi.trans n.le_succ))\n    Â· apply hg.fderiv_within ht\n      simp only [Nat.cast_succ]\n      exact add_le_add_right (Nat.cast_le.2 hi) _\n    Â· intro j hj\n      have :\n        Â«exprâ€– â€–Â» (iterated_fderiv_within ğ•œ j (fderiv_within ğ•œ g t) t (f x)) =\n          Â«exprâ€– â€–Â» (iterated_fderiv_within ğ•œ (j + 1) g t (f x)) :=\n        by rw [iterated_fderiv_within_succ_eq_comp_right ht (hst hx), LinearIsometryEquiv.norm_map]\n      rw [this]\n      exact hC (j + 1) (add_le_add (hj.trans hi) le_rfl)\n  -- reformulate `hD` as a bound for the derivatives of `f'`.\n  have J : âˆ€ i, Â«exprâ€– â€–Â» (iterated_fderiv_within ğ•œ (n - i) (fderiv_within ğ•œ f s) s x) â‰¤ D ^ (n - i + 1) :=\n    by\n    intro i\n    have :\n      Â«exprâ€– â€–Â» (iterated_fderiv_within ğ•œ (n - i) (fderiv_within ğ•œ f s) s x) =\n        Â«exprâ€– â€–Â» (iterated_fderiv_within ğ•œ (n - i + 1) f s x) :=\n      by rw [iterated_fderiv_within_succ_eq_comp_right hs hx, LinearIsometryEquiv.norm_map]\n    rw [this]\n    apply hD\n    Â· simp only [le_add_iff_nonneg_left, zero_le']\n    Â· apply nat.succ_le_succ tsub_le_self\n  -- Now put these together: first, notice that we have to bound `D^n (g' âˆ˜ f â¬ f')`.\n  calc\n    Â«exprâ€– â€–Â» (iterated_fderiv_within ğ•œ (n + 1) (g âˆ˜ f) s x) =\n        Â«exprâ€– â€–Â» (iterated_fderiv_within ğ•œ n (fun y : E => fderiv_within ğ•œ (g âˆ˜ f) s y) s x) :=\n      by rw [iterated_fderiv_within_succ_eq_comp_right hs hx, LinearIsometryEquiv.norm_map]\n    _ =\n        Â«exprâ€– â€–Â»\n          (iterated_fderiv_within ğ•œ n\n            (fun y : E => continuous_linear_map.compL ğ•œ E Fu Gu (fderiv_within ğ•œ g t (f y)) (fderiv_within ğ•œ f s y)) s\n            x) :=\n      by\n      have L : (1 : Â«exprâ„•âˆÂ») â‰¤ n.succ := by simpa only [ENat.coe_one, Nat.one_le_cast] using n.succ_pos\n      congr 1\n      apply iterated_fderiv_within_congr hs (fun y hy => _) hx\n      apply fderiv_within.comp _ _ _ hst (hs y hy)\n      Â· exact hg.differentiable_on L _ (hst hy)\n      Â· exact hf.differentiable_on L _ hy\n    -- bound it using the fact that the composition of linear maps is a bilinear operation,\n        -- for which we have bounds for the`n`-th derivative.\n        _ â‰¤\n        finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n          (Finset.range (n + 1))\n          ((n.choose i : exprâ„) * Â«exprâ€– â€–Â» (iterated_fderiv_within ğ•œ i (fderiv_within ğ•œ g t âˆ˜ f) s x) *\n            Â«exprâ€– â€–Â» (iterated_fderiv_within ğ•œ (n - i) (fderiv_within ğ•œ f s) s x)) :=\n      by\n      have A : cont_diff_on ğ•œ n (fderiv_within ğ•œ g t âˆ˜ f) s :=\n        by\n        apply cont_diff_on.comp _ (hf.of_le M.le) hst\n        apply hg.fderiv_within ht\n        simp only [Nat.cast_succ, le_refl]\n      have B : cont_diff_on ğ•œ n (fderiv_within ğ•œ f s) s :=\n        by\n        apply hf.fderiv_within hs\n        simp only [Nat.cast_succ, le_refl]\n      exact\n        (continuous_linear_map.compL ğ•œ E Fu Gu).norm_iterated_fderiv_within_le_of_bilinear_of_le_one A B hs hx le_rfl\n          (continuous_linear_map.norm_compL_le ğ•œ E Fu Gu)\n    -- bound each of the terms using the estimates on previous derivatives (that use the inductive\n        -- assumption for `g' âˆ˜ f`).\n        _ â‰¤\n        finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n          (Finset.range (n + 1)) ((n.choose i : exprâ„) * (nat.factorial i * C * D ^ i) * D ^ (n - i + 1)) :=\n      by\n      apply Finset.sum_le_sum fun i hi => _\n      simp only [mul_assoc (n.choose i : exprâ„)]\n      refine' mul_le_mul_of_nonneg_left _ (Nat.cast_nonneg _)\n      apply mul_le_mul (I i hi) (J i) (norm_nonneg _)\n      positivity\n    -- We are left with trivial algebraic manipulations to see that this is smaller than\n        -- the claimed bound.\n        _ =\n        finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n          (Finset.range (n + 1))\n          ((nat.factorial n : exprâ„) * ((nat.factorial i)â»Â¹ * nat.factorial i) * C * (D ^ i * D ^ (n - i + 1)) *\n            (nat.factorial (n - i))â»Â¹) :=\n      by\n      apply Finset.sum_congr rfl fun i hi => _\n      simp only [Nat.cast_choose (exprâ„) (Finset.mem_range_succ_iff.1 hi), div_eq_inv_mul, mul_inv]\n      ring\n    _ =\n        finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n          (Finset.range (n + 1)) ((nat.factorial n : exprâ„) * 1 * C * D ^ (n + 1) * (nat.factorial (n - i))â»Â¹) :=\n      by\n      apply Finset.sum_congr rfl fun i hi => _\n      congr 2\n      Â· congr\n        apply inv_mul_cancel\n        simpa only [ne.def, Nat.cast_eq_zero] using i.factorial_ne_zero\n      Â· rw [â† pow_add]\n        congr 1\n        rw [nat.add_succ, Nat.succ_inj']\n        exact nat.add_sub_of_le (Finset.mem_range_succ_iff.1 hi)\n    _ â‰¤\n        finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n          (Finset.range (n + 1)) ((nat.factorial n : exprâ„) * 1 * C * D ^ (n + 1) * 1) :=\n      by\n      apply Finset.sum_le_sum fun i hi => _\n      refine' mul_le_mul_of_nonneg_left _ (by positivity)\n      apply inv_le_one\n      simpa only [Nat.one_le_cast] using (n - i).factorial_pos\n    _ = nat.factorial (n + 1) * C * D ^ (n + 1) := by\n      simp only [mul_assoc, mul_one, Finset.sum_const, Finset.card_range, nsmul_eq_mul, Nat.factorial_succ,\n        Nat.cast_mul]\n    \n#align norm_iterated_fderiv_within_comp_le_aux norm_iterated_fderiv_within_comp_le_aux\n\n",
 "norm_iterated_fderiv_within_comp_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰ƒâ‚—áµ¢[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰ƒâ‚—áµ¢[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ„•âˆÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ„•âˆÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\n/-- If the derivatives within a set of `g` at `f x` are bounded by `C`, and the `i`-th derivative\nwithin a set of `f` at `x` is bounded by `D^i` for all `1 â‰¤ i â‰¤ n`, then the `n`-th derivative\nof `g âˆ˜ f` is bounded by `n! * C * D^n`. -/\ntheorem norm_iterated_fderiv_within_comp_le {g : F â†’ G} {f : E â†’ F} {n : â„•} {s : Set E} {t : Set F} {x : E}\n    {N : Â«exprâ„•âˆÂ»} (hg : cont_diff_on ğ•œ N g t) (hf : cont_diff_on ğ•œ N f s) (hn : (n : Â«exprâ„•âˆÂ») â‰¤ N)\n    (ht : unique_diff_on ğ•œ t) (hs : unique_diff_on ğ•œ s) (hst : MapsTo f s t) (hx : x âˆˆ s) {C : exprâ„} {D : exprâ„}\n    (hC : âˆ€ i, i â‰¤ n â†’ Â«exprâ€– â€–Â» (iterated_fderiv_within ğ•œ i g t (f x)) â‰¤ C)\n    (hD : âˆ€ i, 1 â‰¤ i â†’ i â‰¤ n â†’ Â«exprâ€– â€–Â» (iterated_fderiv_within ğ•œ i f s x) â‰¤ D ^ i) :\n    Â«exprâ€– â€–Â» (iterated_fderiv_within ğ•œ n (g âˆ˜ f) s x) â‰¤ nat.factorial n * C * D ^ n :=\n  by\n  /- We reduce the bound to the case where all spaces live in the same universe (in which we\n    already have proved the result), by using linear isometries between the spaces and their `ulift`\n    to a common universe. These linear isometries preserve the norm of the iterated derivative. -/\n  let Fu : Type max uF uG := ULift.{uG, uF} F\n  let Gu : Type max uF uG := ULift.{uF, uG} G\n  have isoF : Â«expr â‰ƒâ‚—áµ¢[ ] Â» Fu ğ•œ F := LinearIsometryEquiv.ulift ğ•œ F\n  have isoG : Â«expr â‰ƒâ‚—áµ¢[ ] Â» Gu ğ•œ G := LinearIsometryEquiv.ulift ğ•œ G\n  -- lift `f` and `g` to versions `fu` and `gu` on the lifted spaces.\n  let fu : E â†’ Fu := isoF.symm âˆ˜ f\n  let gu : Fu â†’ Gu := isoG.symm âˆ˜ g âˆ˜ isoF\n  let tu := Â«expr â»Â¹' Â» isoF t\n  have htu : unique_diff_on ğ•œ tu := isoF.to_continuous_linear_equiv.unique_diff_on_preimage_iff.2 ht\n  have hstu : maps_to fu s tu := by\n    intro y hy\n    simpa only [mem_preimage, LinearIsometryEquiv.apply_symm_apply] using hst hy\n  have Ffu : isoF (fu x) = f x := by simp only [LinearIsometryEquiv.apply_symm_apply]\n  -- All norms are preserved by the lifting process.\n  have hfu : cont_diff_on ğ•œ n fu s := isoF.symm.cont_diff.comp_cont_diff_on (hf.of_le hn)\n  have hgu : cont_diff_on ğ•œ n gu tu :=\n    isoG.symm.cont_diff.comp_cont_diff_on ((hg.of_le hn).comp_continuous_linear_map (isoF : Â«expr â†’L[ ] Â» Fu ğ•œ F))\n  have Nfu : âˆ€ i, Â«exprâ€– â€–Â» (iterated_fderiv_within ğ•œ i fu s x) = Â«exprâ€– â€–Â» (iterated_fderiv_within ğ•œ i f s x) :=\n    by\n    intro i\n    rw [linear_isometry_equiv.norm_iterated_fderiv_within_comp_left _ _ hs hx]\n  simp_rw [â† Nfu] at hD\n  have Ngu :\n    âˆ€ i, Â«exprâ€– â€–Â» (iterated_fderiv_within ğ•œ i gu tu (fu x)) = Â«exprâ€– â€–Â» (iterated_fderiv_within ğ•œ i g t (f x)) :=\n    by\n    intro i\n    rw [linear_isometry_equiv.norm_iterated_fderiv_within_comp_left _ _ htu (hstu hx)]\n    rw [linear_isometry_equiv.norm_iterated_fderiv_within_comp_right _ _ ht, Ffu]\n    rw [Ffu]\n    exact hst hx\n  simp_rw [â† Ngu] at hC\n  have Nfgu :\n    Â«exprâ€– â€–Â» (iterated_fderiv_within ğ•œ n (g âˆ˜ f) s x) = Â«exprâ€– â€–Â» (iterated_fderiv_within ğ•œ n (gu âˆ˜ fu) s x) :=\n    by\n    have : gu âˆ˜ fu = isoG.symm âˆ˜ g âˆ˜ f := by\n      ext x\n      simp only [comp_app, LinearIsometryEquiv.map_eq_iff, LinearIsometryEquiv.apply_symm_apply]\n    rw [this, linear_isometry_equiv.norm_iterated_fderiv_within_comp_left _ _ hs hx]\n  -- deduce the required bound from the one for `gu âˆ˜ fu`.\n  rw [Nfgu]\n  exact norm_iterated_fderiv_within_comp_le_aux hgu hfu htu hs hstu hx hC hD\n#align norm_iterated_fderiv_within_comp_le norm_iterated_fderiv_within_comp_le\n\n",
 "norm_iterated_fderiv_within_clm_apply_const":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ„•âˆÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\ntheorem norm_iterated_fderiv_within_clm_apply_const {f : E â†’ Â«expr â†’L[ ] Â» F ğ•œ G} {c : F} {s : Set E} {x : E}\n    {N : Â«exprâ„•âˆÂ»} {n : â„•} (hf : cont_diff_on ğ•œ N f s) (hs : unique_diff_on ğ•œ s) (hx : x âˆˆ s) (hn : â†‘n â‰¤ N) :\n    Â«exprâ€– â€–Â» (iterated_fderiv_within ğ•œ n (fun y : E => (f y) c) s x) â‰¤\n      Â«exprâ€– â€–Â» c * Â«exprâ€– â€–Â» (iterated_fderiv_within ğ•œ n f s x) :=\n  by\n  let g : Â«expr â†’L[ ] Â» (Â«expr â†’L[ ] Â» F ğ•œ G) ğ•œ G := continuous_linear_map.apply ğ•œ G c\n  have h := g.norm_comp_continuous_multilinear_map_le (iterated_fderiv_within ğ•œ n f s x)\n  rw [â† g.iterated_fderiv_within_comp_left hf hs hx hn] at h\n  refine' h.trans (mul_le_mul_of_nonneg_right _ (norm_nonneg _))\n  refine' g.op_norm_le_bound (norm_nonneg _) fun f => _\n  rw [continuous_linear_map.apply_apply, mul_comm]\n  exact f.le_op_norm c\n#align norm_iterated_fderiv_within_clm_apply_const norm_iterated_fderiv_within_clm_apply_const\n\n",
 "norm_iterated_fderiv_within_clm_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ„•âˆÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\ntheorem norm_iterated_fderiv_within_clm_apply {f : E â†’ Â«expr â†’L[ ] Â» F ğ•œ G} {g : E â†’ F} {s : Set E} {x : E}\n    {N : Â«exprâ„•âˆÂ»} {n : â„•} (hf : cont_diff_on ğ•œ N f s) (hg : cont_diff_on ğ•œ N g s) (hs : unique_diff_on ğ•œ s)\n    (hx : x âˆˆ s) (hn : â†‘n â‰¤ N) :\n    Â«exprâ€– â€–Â» (iterated_fderiv_within ğ•œ n (fun y => (f y) (g y)) s x) â‰¤\n      (Finset.range (n + 1)).sum fun i =>\n        â†‘(n.choose i) * Â«exprâ€– â€–Â» (iterated_fderiv_within ğ•œ i f s x) *\n          Â«exprâ€– â€–Â» (iterated_fderiv_within ğ•œ (n - i) g s x) :=\n  by\n  let B : Â«expr â†’L[ ] Â» (Â«expr â†’L[ ] Â» F ğ•œ G) ğ•œ (Â«expr â†’L[ ] Â» F ğ•œ G) :=\n    continuous_linear_map.flip (continuous_linear_map.apply ğ•œ G)\n  have hB : Â«exprâ€– â€–Â» B â‰¤ 1 :=\n    by\n    simp only [continuous_linear_map.op_norm_flip, continuous_linear_map.apply]\n    refine' continuous_linear_map.op_norm_le_bound _ zero_le_one fun f => _\n    simp only [ContinuousLinearMap.coe_id', id.def, one_mul]\n  exact B.norm_iterated_fderiv_within_le_of_bilinear_of_le_one hf hg hs hx hn hB\n#align norm_iterated_fderiv_within_clm_apply norm_iterated_fderiv_within_clm_apply\n\n",
 "norm_iterated_fderiv_smul_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ„•âˆÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ„•âˆÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\ntheorem norm_iterated_fderiv_smul_le {f : E â†’ ğ•œ'} {g : E â†’ F} {N : Â«exprâ„•âˆÂ»} (hf : cont_diff ğ•œ N f)\n    (hg : cont_diff ğ•œ N g) (x : E) {n : â„•} (hn : (n : Â«exprâ„•âˆÂ») â‰¤ N) :\n    Â«exprâ€– â€–Â» (iterated_fderiv ğ•œ n (fun y => Â«expr â€¢ Â» (f y) (g y)) x) â‰¤\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n        (Finset.range (n + 1))\n        ((n.choose i : exprâ„) * Â«exprâ€– â€–Â» (iterated_fderiv ğ•œ i f x) * Â«exprâ€– â€–Â» (iterated_fderiv ğ•œ (n - i) g x)) :=\n  (continuous_linear_map.lsmul ğ•œ ğ•œ' :\n        Â«expr â†’L[ ] Â» ğ•œ' ğ•œ (Â«expr â†’L[ ] Â» F ğ•œ F)).norm_iterated_fderiv_le_of_bilinear_of_le_one\n    hf hg x hn continuous_linear_map.op_norm_lsmul_le\n#align norm_iterated_fderiv_smul_le norm_iterated_fderiv_smul_le\n\n",
 "norm_iterated_fderiv_mul_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ„•âˆÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ„•âˆÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\ntheorem norm_iterated_fderiv_mul_le {f : E â†’ A} {g : E â†’ A} {N : Â«exprâ„•âˆÂ»} (hf : cont_diff ğ•œ N f) (hg : cont_diff ğ•œ N g)\n    (x : E) {n : â„•} (hn : (n : Â«exprâ„•âˆÂ») â‰¤ N) :\n    Â«exprâ€– â€–Â» (iterated_fderiv ğ•œ n (fun y => f y * g y) x) â‰¤\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n        (Finset.range (n + 1))\n        ((n.choose i : exprâ„) * Â«exprâ€– â€–Â» (iterated_fderiv ğ•œ i f x) * Â«exprâ€– â€–Â» (iterated_fderiv ğ•œ (n - i) g x)) :=\n  by\n  simp_rw [â† iterated_fderiv_within_univ]\n  exact norm_iterated_fderiv_within_mul_le hf.cont_diff_on hg.cont_diff_on unique_diff_on_univ (mem_univ x) hn\n#align norm_iterated_fderiv_mul_le norm_iterated_fderiv_mul_le\n\n",
 "norm_iterated_fderiv_le_of_bilinear_of_le_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ„•âˆÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ„•âˆÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/-- Bounding the norm of the iterated derivative of `B (f x) (g x)` in terms of the\niterated derivatives of `f` and `g` when `B` is bilinear of norm at most `1`:\n`â€–D^n (x â†¦ B (f x) (g x))â€– â‰¤ âˆ‘_{k â‰¤ n} n.choose k â€–D^k fâ€– â€–D^{n-k} gâ€–` -/\ntheorem continuous_linear_map.norm_iterated_fderiv_le_of_bilinear_of_le_one\n    (B : Â«expr â†’L[ ] Â» E ğ•œ (Â«expr â†’L[ ] Â» F ğ•œ G)) {f : D â†’ E} {g : D â†’ F} {N : Â«exprâ„•âˆÂ»} (hf : cont_diff ğ•œ N f)\n    (hg : cont_diff ğ•œ N g) (x : D) {n : â„•} (hn : (n : Â«exprâ„•âˆÂ») â‰¤ N) (hB : Â«exprâ€– â€–Â» B â‰¤ 1) :\n    Â«exprâ€– â€–Â» (iterated_fderiv ğ•œ n (fun y => B (f y) (g y)) x) â‰¤\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n        (Finset.range (n + 1))\n        ((n.choose i : exprâ„) * Â«exprâ€– â€–Â» (iterated_fderiv ğ•œ i f x) * Â«exprâ€– â€–Â» (iterated_fderiv ğ•œ (n - i) g x)) :=\n  by\n  simp_rw [â† iterated_fderiv_within_univ]\n  exact\n    B.norm_iterated_fderiv_within_le_of_bilinear_of_le_one hf.cont_diff_on hg.cont_diff_on unique_diff_on_univ\n      (mem_univ x) hn hB\n#align continuous_linear_map.norm_iterated_fderiv_le_of_bilinear_of_le_one continuous_linear_map.norm_iterated_fderiv_le_of_bilinear_of_le_one\n\n",
 "norm_iterated_fderiv_le_of_bilinear":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ„•âˆÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ„•âˆÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/-- Bounding the norm of the iterated derivative of `B (f x) (g x)` in terms of the\niterated derivatives of `f` and `g` when `B` is bilinear:\n`â€–D^n (x â†¦ B (f x) (g x))â€– â‰¤ â€–Bâ€– âˆ‘_{k â‰¤ n} n.choose k â€–D^k fâ€– â€–D^{n-k} gâ€–` -/\ntheorem continuous_linear_map.norm_iterated_fderiv_le_of_bilinear (B : Â«expr â†’L[ ] Â» E ğ•œ (Â«expr â†’L[ ] Â» F ğ•œ G))\n    {f : D â†’ E} {g : D â†’ F} {N : Â«exprâ„•âˆÂ»} (hf : cont_diff ğ•œ N f) (hg : cont_diff ğ•œ N g) (x : D) {n : â„•}\n    (hn : (n : Â«exprâ„•âˆÂ») â‰¤ N) :\n    Â«exprâ€– â€–Â» (iterated_fderiv ğ•œ n (fun y => B (f y) (g y)) x) â‰¤\n      Â«exprâ€– â€–Â» B *\n        finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n          (Finset.range (n + 1))\n          ((n.choose i : exprâ„) * Â«exprâ€– â€–Â» (iterated_fderiv ğ•œ i f x) * Â«exprâ€– â€–Â» (iterated_fderiv ğ•œ (n - i) g x)) :=\n  by\n  simp_rw [â† iterated_fderiv_within_univ]\n  exact B.norm_iterated_fderiv_within_le_of_bilinear hf.cont_diff_on hg.cont_diff_on unique_diff_on_univ (mem_univ x) hn\n#align continuous_linear_map.norm_iterated_fderiv_le_of_bilinear continuous_linear_map.norm_iterated_fderiv_le_of_bilinear\n\n",
 "norm_iterated_fderiv_comp_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰ƒâ‚—áµ¢[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/-- Composition with a linear isometry on the right preserves the norm of the iterated derivative\nwithin a set. -/\ntheorem linear_isometry_equiv.norm_iterated_fderiv_comp_right (g : Â«expr â‰ƒâ‚—áµ¢[ ] Â» G ğ•œ E) (f : E â†’ F) (x : G) (i : â„•) :\n    Â«exprâ€– â€–Â» (iterated_fderiv ğ•œ i (f âˆ˜ g) x) = Â«exprâ€– â€–Â» (iterated_fderiv ğ•œ i f (g x)) :=\n  by\n  simp only [â† iterated_fderiv_within_univ]\n  apply g.norm_iterated_fderiv_within_comp_right f unique_diff_on_univ (mem_univ (g x)) i\n#align linear_isometry_equiv.norm_iterated_fderiv_comp_right linear_isometry_equiv.norm_iterated_fderiv_comp_right\n\n",
 "norm_iterated_fderiv_comp_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰ƒâ‚—áµ¢[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/-- Composition with a linear isometry equiv on the left preserves the norm of the iterated\nderivative. -/\ntheorem linear_isometry_equiv.norm_iterated_fderiv_comp_left (g : Â«expr â‰ƒâ‚—áµ¢[ ] Â» F ğ•œ G) (f : E â†’ F) (x : E) (i : â„•) :\n    Â«exprâ€– â€–Â» (iterated_fderiv ğ•œ i (g âˆ˜ f) x) = Â«exprâ€– â€–Â» (iterated_fderiv ğ•œ i f x) :=\n  by\n  rw [â† iterated_fderiv_within_univ, â† iterated_fderiv_within_univ]\n  apply g.norm_iterated_fderiv_within_comp_left f unique_diff_on_univ (mem_univ x) i\n#align linear_isometry_equiv.norm_iterated_fderiv_comp_left linear_isometry_equiv.norm_iterated_fderiv_comp_left\n\n",
 "norm_iterated_fderiv_comp_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ„•âˆÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ„•âˆÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\n/-- If the derivatives of `g` at `f x` are bounded by `C`, and the `i`-th derivative\nof `f` at `x` is bounded by `D^i` for all `1 â‰¤ i â‰¤ n`, then the `n`-th derivative\nof `g âˆ˜ f` is bounded by `n! * C * D^n`. -/\ntheorem norm_iterated_fderiv_comp_le {g : F â†’ G} {f : E â†’ F} {n : â„•} {N : Â«exprâ„•âˆÂ»} (hg : cont_diff ğ•œ N g)\n    (hf : cont_diff ğ•œ N f) (hn : (n : Â«exprâ„•âˆÂ») â‰¤ N) (x : E) {C : exprâ„} {D : exprâ„}\n    (hC : âˆ€ i, i â‰¤ n â†’ Â«exprâ€– â€–Â» (iterated_fderiv ğ•œ i g (f x)) â‰¤ C)\n    (hD : âˆ€ i, 1 â‰¤ i â†’ i â‰¤ n â†’ Â«exprâ€– â€–Â» (iterated_fderiv ğ•œ i f x) â‰¤ D ^ i) :\n    Â«exprâ€– â€–Â» (iterated_fderiv ğ•œ n (g âˆ˜ f) x) â‰¤ nat.factorial n * C * D ^ n :=\n  by\n  simp_rw [â† iterated_fderiv_within_univ] at hC hDâŠ¢\n  exact\n    norm_iterated_fderiv_within_comp_le hg.cont_diff_on hf.cont_diff_on hn unique_diff_on_univ unique_diff_on_univ\n      (maps_to_univ _ _) (mem_univ x) hC hD\n#align norm_iterated_fderiv_comp_le norm_iterated_fderiv_comp_le\n\n",
 "norm_iterated_fderiv_clm_apply_const":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ„•âˆÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\ntheorem norm_iterated_fderiv_clm_apply_const {f : E â†’ Â«expr â†’L[ ] Â» F ğ•œ G} {c : F} {x : E} {N : Â«exprâ„•âˆÂ»} {n : â„•}\n    (hf : cont_diff ğ•œ N f) (hn : â†‘n â‰¤ N) :\n    Â«exprâ€– â€–Â» (iterated_fderiv ğ•œ n (fun y : E => (f y) c) x) â‰¤ Â«exprâ€– â€–Â» c * Â«exprâ€– â€–Â» (iterated_fderiv ğ•œ n f x) :=\n  by\n  simp only [â† iterated_fderiv_within_univ]\n  refine' norm_iterated_fderiv_within_clm_apply_const hf.cont_diff_on unique_diff_on_univ (Set.mem_univ x) hn\n#align norm_iterated_fderiv_clm_apply_const norm_iterated_fderiv_clm_apply_const\n\n",
 "norm_iterated_fderiv_clm_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ„•âˆÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\ntheorem norm_iterated_fderiv_clm_apply {f : E â†’ Â«expr â†’L[ ] Â» F ğ•œ G} {g : E â†’ F} {N : Â«exprâ„•âˆÂ»} {n : â„•}\n    (hf : cont_diff ğ•œ N f) (hg : cont_diff ğ•œ N g) (x : E) (hn : â†‘n â‰¤ N) :\n    Â«exprâ€– â€–Â» (iterated_fderiv ğ•œ n (fun y : E => (f y) (g y)) x) â‰¤\n      (Finset.range (n + 1)).sum fun i : â„• =>\n        â†‘(n.choose i) * Â«exprâ€– â€–Â» (iterated_fderiv ğ•œ i f x) * Â«exprâ€– â€–Â» (iterated_fderiv ğ•œ (n - i) g x) :=\n  by\n  simp only [â† iterated_fderiv_within_univ]\n  exact norm_iterated_fderiv_within_clm_apply hf.cont_diff_on hg.cont_diff_on unique_diff_on_univ (Set.mem_univ x) hn\n#align norm_iterated_fderiv_clm_apply norm_iterated_fderiv_clm_apply\n\n",
 "neg":
 "/-- The negative of a `C^n` function on a domain is `C^n`. -/\ntheorem cont_diff_on.neg {s : Set E} {f : E â†’ F} (hf : cont_diff_on ğ•œ n f s) : cont_diff_on ğ•œ n (fun x => -f x) s :=\n  fun x hx => (hf x hx).neg\n#align cont_diff_on.neg cont_diff_on.neg\n\n",
 "mul":
 "/-- The product of two `C^n`functions is `C^n`. -/\ntheorem cont_diff.mul {f g : E â†’ ğ”¸} (hf : cont_diff ğ•œ n f) (hg : cont_diff ğ•œ n g) : cont_diff ğ•œ n fun x => f x * g x :=\n  cont_diff_mul.comp (hf.prod hg)\n#align cont_diff.mul cont_diff.mul\n\n",
 "iterated_fderiv_zero_fun":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr [Ã— ]â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr [Ã— ]â†’L[ ] Â» -/\n@[simp]\ntheorem iterated_fderiv_zero_fun {n : â„•} : (iterated_fderiv ğ•œ n fun x : E => (0 : F)) = 0 :=\n  by\n  induction' n with n IH\n  Â· ext m\n    simp\n  Â· ext (x m)\n    rw [iterated_fderiv_succ_apply_left, IH]\n    change\n      (fderiv ğ•œ (fun x : E => (0 : Â«expr [Ã— ]â†’L[ ] Â» E n ğ•œ F)) x : E â†’ Â«expr [Ã— ]â†’L[ ] Â» E n ğ•œ F) (m 0) (tail m) = _\n    rw [fderiv_const]\n    rfl\n#align iterated_fderiv_zero_fun iterated_fderiv_zero_fun\n\n",
 "iterated_fderiv_within_neg_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ„•âˆÂ» -/\ntheorem iterated_fderiv_within_neg_apply {f : E â†’ F} (hu : unique_diff_on ğ•œ s) (hx : x âˆˆ s) :\n    iterated_fderiv_within ğ•œ i (-f) s x = -iterated_fderiv_within ğ•œ i f s x :=\n  by\n  induction' i with i hi generalizing x\n  Â· ext h\n    simp\n  Â· ext h\n    have hi' : (i : Â«exprâ„•âˆÂ») < i + 1 := with_top.coe_lt_coe.mpr (nat.lt_succ_self _)\n    calc\n      iterated_fderiv_within ğ•œ (i + 1) (-f) s x h =\n          fderiv_within ğ•œ (iterated_fderiv_within ğ•œ i (-f) s) s x (h 0) (Fin.tail h) :=\n        rfl\n      _ = fderiv_within ğ•œ (-iterated_fderiv_within ğ•œ i f s) s x (h 0) (Fin.tail h) :=\n        by\n        congr 2\n        exact fderiv_within_congr (hu x hx) (fun _ => hi) (hi hx)\n      _ = -(fderiv_within ğ•œ (iterated_fderiv_within ğ•œ i f s) s) x (h 0) (Fin.tail h) := by\n        rw [Pi.neg_def, fderiv_within_neg (hu x hx)] <;> rfl\n      _ = -(iterated_fderiv_within ğ•œ (i + 1) f s) x h := rfl\n      \n#align iterated_fderiv_within_neg_apply iterated_fderiv_within_neg_apply\n\n",
 "iterated_fderiv_within_const_smul_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ„•âˆÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\ntheorem iterated_fderiv_within_const_smul_apply (hf : cont_diff_on ğ•œ i f s) (hu : unique_diff_on ğ•œ s) (hx : x âˆˆ s) :\n    iterated_fderiv_within ğ•œ i (Â«expr â€¢ Â» a f) s x = Â«expr â€¢ Â» a (iterated_fderiv_within ğ•œ i f s x) :=\n  by\n  induction' i with i hi generalizing x\n  Â· ext\n    simp\n  Â· ext h\n    have hi' : (i : Â«exprâ„•âˆÂ») < i + 1 := with_top.coe_lt_coe.mpr (nat.lt_succ_self _)\n    have hdf : differentiable_on ğ•œ (iterated_fderiv_within ğ•œ i f s) s :=\n      hf.differentiable_on_iterated_fderiv_within hi' hu\n    have hcdf : cont_diff_on ğ•œ i f s := hf.of_le hi'.le\n    calc\n      iterated_fderiv_within ğ•œ (i + 1) (Â«expr â€¢ Â» a f) s x h =\n          fderiv_within ğ•œ (iterated_fderiv_within ğ•œ i (Â«expr â€¢ Â» a f) s) s x (h 0) (Fin.tail h) :=\n        rfl\n      _ = fderiv_within ğ•œ (Â«expr â€¢ Â» a (iterated_fderiv_within ğ•œ i f s)) s x (h 0) (Fin.tail h) :=\n        by\n        congr 2\n        exact fderiv_within_congr (hu x hx) (fun _ => hi hcdf) (hi hcdf hx)\n      _ = (Â«expr â€¢ Â» a (fderiv_within ğ•œ (iterated_fderiv_within ğ•œ i f s))) s x (h 0) (Fin.tail h) := by\n        rw [Pi.smul_def, fderiv_within_const_smul (hu x hx) (hdf x hx)] <;> rfl\n      _ = Â«expr â€¢ Â» a (iterated_fderiv_within ğ•œ (i + 1) f s x h) := rfl\n      \n#align iterated_fderiv_within_const_smul_apply iterated_fderiv_within_const_smul_apply\n\n",
 "iterated_fderiv_within_comp_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‡‘ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‡‘ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‡‘ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰ƒL[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/-- The iterated derivative within a set of the composition with a linear equiv on the right is\nobtained by composing the iterated derivative with the linear equiv. -/\ntheorem continuous_linear_equiv.iterated_fderiv_within_comp_right (g : Â«expr â‰ƒL[ ] Â» G ğ•œ E) (f : E â†’ F)\n    (hs : unique_diff_on ğ•œ s) {x : G} (hx : g x âˆˆ s) (i : â„•) :\n    iterated_fderiv_within ğ•œ i (f âˆ˜ g) (Â«expr â»Â¹' Â» g s) x =\n      (iterated_fderiv_within ğ•œ i f s (g x)).comp_continuous_linear_map fun _ => g :=\n  by\n  induction' i with i IH generalizing x\n  Â· ext1 m\n    simp only [iterated_fderiv_within_zero_apply, ContinuousMultilinearMap.compContinuousLinearMap_apply]\n  Â· ext1 m\n    simp only [ContinuousMultilinearMap.compContinuousLinearMap_apply, ContinuousLinearEquiv.coe_coe,\n      iterated_fderiv_within_succ_apply_left]\n    have :\n      fderiv_within ğ•œ (iterated_fderiv_within ğ•œ i (f âˆ˜ Â«exprâ‡‘ Â» g) (Â«expr â»Â¹' Â» (Â«exprâ‡‘ Â» g) s))\n          (Â«expr â»Â¹' Â» (Â«exprâ‡‘ Â» g) s) x =\n        fderiv_within ğ•œ\n          (fun y =>\n            continuous_multilinear_map.comp_continuous_linear_map_equivL _ (fun _x : Fin i => g)\n              (iterated_fderiv_within ğ•œ i f s (g y)))\n          (Â«expr â»Â¹' Â» g s) x :=\n      fderiv_within_congr' (g.unique_diff_on_preimage_iff.2 hs x hx) (fun y hy => IH hy) hx\n    rw [this]\n    rw [continuous_linear_equiv.comp_fderiv_within _ (g.unique_diff_on_preimage_iff.2 hs x hx)]\n    simp only [ContinuousLinearMap.coe_comp', ContinuousLinearEquiv.coe_coe, comp_app,\n      continuous_multilinear_map.comp_continuous_linear_map_equivL_apply,\n      ContinuousMultilinearMap.compContinuousLinearMap_apply]\n    rw [continuous_linear_equiv.comp_right_fderiv_within _ (g.unique_diff_on_preimage_iff.2 hs x hx)]\n    rfl\n#align continuous_linear_equiv.iterated_fderiv_within_comp_right continuous_linear_equiv.iterated_fderiv_within_comp_right\n\n",
 "iterated_fderiv_within_comp_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰ƒL[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/-- The iterated derivative within a set of the composition with a linear equiv on the left is\nobtained by applying the linear equiv to the iterated derivative. This is true without\ndifferentiability assumptions. -/\ntheorem continuous_linear_equiv.iterated_fderiv_within_comp_left (g : Â«expr â‰ƒL[ ] Â» F ğ•œ G) (f : E â†’ F)\n    (hs : unique_diff_on ğ•œ s) (hx : x âˆˆ s) (i : â„•) :\n    iterated_fderiv_within ğ•œ i (g âˆ˜ f) s x =\n      (g : Â«expr â†’L[ ] Â» F ğ•œ G).comp_continuous_multilinear_map (iterated_fderiv_within ğ•œ i f s x) :=\n  by\n  induction' i with i IH generalizing x\n  Â· ext1 m\n    simp only [iterated_fderiv_within_zero_apply, ContinuousLinearEquiv.coe_coe,\n      ContinuousLinearMap.compContinuousMultilinearMap_coe, EmbeddingLike.apply_eq_iff_eq]\n  Â· ext1 m\n    rw [iterated_fderiv_within_succ_apply_left]\n    have Z :\n      fderiv_within ğ•œ (iterated_fderiv_within ğ•œ i (g âˆ˜ f) s) s x =\n        fderiv_within ğ•œ\n          (fun y => g.comp_continuous_multilinear_mapL (fun j : Fin i => E) (iterated_fderiv_within ğ•œ i f s y)) s x :=\n      fderiv_within_congr' (hs x hx) (fun y hy => IH hy) hx\n    simp_rw [Z]\n    rw [(g.comp_continuous_multilinear_mapL fun j : Fin i => E).comp_fderiv_within (hs x hx)]\n    simp only [ContinuousLinearMap.coe_comp', ContinuousLinearEquiv.coe_coe, comp_app,\n      continuous_linear_equiv.comp_continuous_multilinear_mapL_apply,\n      ContinuousLinearMap.compContinuousMultilinearMap_coe, EmbeddingLike.apply_eq_iff_eq]\n    rw [iterated_fderiv_within_succ_apply_left]\n#align continuous_linear_equiv.iterated_fderiv_within_comp_left continuous_linear_equiv.iterated_fderiv_within_comp_left\n\n",
 "iterated_fderiv_within_add_apply'":
 "/-- The iterated derivative of the sum of two functions is the sum of the iterated derivatives.\nThis is the same as `iterated_fderiv_within_add_apply`, but using the spelling `(Î» x, f x + g x)`\ninstead of `f + g`, which can be handy for some rewrites.\nTODO: use one form consistently. -/\ntheorem iterated_fderiv_within_add_apply' {f g : E â†’ F} (hf : cont_diff_on ğ•œ i f s) (hg : cont_diff_on ğ•œ i g s)\n    (hu : unique_diff_on ğ•œ s) (hx : x âˆˆ s) :\n    iterated_fderiv_within ğ•œ i (fun x => f x + g x) s x =\n      iterated_fderiv_within ğ•œ i f s x + iterated_fderiv_within ğ•œ i g s x :=\n  iterated_fderiv_within_add_apply hf hg hu hx\n#align iterated_fderiv_within_add_apply' iterated_fderiv_within_add_apply'\n\n",
 "iterated_fderiv_within_add_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ„•âˆÂ» -/\n/-- The iterated derivative of the sum of two functions is the sum of the iterated derivatives.\nSee also `iterated_fderiv_within_add_apply'`, which uses the spelling `(Î» x, f x + g x)`\ninstead of `f + g`. -/\ntheorem iterated_fderiv_within_add_apply {f g : E â†’ F} (hf : cont_diff_on ğ•œ i f s) (hg : cont_diff_on ğ•œ i g s)\n    (hu : unique_diff_on ğ•œ s) (hx : x âˆˆ s) :\n    iterated_fderiv_within ğ•œ i (f + g) s x = iterated_fderiv_within ğ•œ i f s x + iterated_fderiv_within ğ•œ i g s x :=\n  by\n  induction' i with i hi generalizing x\n  Â· ext h\n    simp\n  Â· ext h\n    have hi' : (i : Â«exprâ„•âˆÂ») < i + 1 := with_top.coe_lt_coe.mpr (nat.lt_succ_self _)\n    have hdf : differentiable_on ğ•œ (iterated_fderiv_within ğ•œ i f s) s :=\n      hf.differentiable_on_iterated_fderiv_within hi' hu\n    have hdg : differentiable_on ğ•œ (iterated_fderiv_within ğ•œ i g s) s :=\n      hg.differentiable_on_iterated_fderiv_within hi' hu\n    have hcdf : cont_diff_on ğ•œ i f s := hf.of_le hi'.le\n    have hcdg : cont_diff_on ğ•œ i g s := hg.of_le hi'.le\n    calc\n      iterated_fderiv_within ğ•œ (i + 1) (f + g) s x h =\n          fderiv_within ğ•œ (iterated_fderiv_within ğ•œ i (f + g) s) s x (h 0) (Fin.tail h) :=\n        rfl\n      _ = fderiv_within ğ•œ (iterated_fderiv_within ğ•œ i f s + iterated_fderiv_within ğ•œ i g s) s x (h 0) (Fin.tail h) :=\n        by\n        congr 2\n        exact fderiv_within_congr (hu x hx) (fun _ => hi hcdf hcdg) (hi hcdf hcdg hx)\n      _ =\n          (fderiv_within ğ•œ (iterated_fderiv_within ğ•œ i f s) s + fderiv_within ğ•œ (iterated_fderiv_within ğ•œ i g s) s) x\n            (h 0) (Fin.tail h) :=\n        by rw [Pi.add_def, fderiv_within_add (hu x hx) (hdf x hx) (hdg x hx)] <;> rfl\n      _ = (iterated_fderiv_within ğ•œ (i + 1) f s + iterated_fderiv_within ğ•œ (i + 1) g s) x h := rfl\n      \n#align iterated_fderiv_within_add_apply iterated_fderiv_within_add_apply\n\n",
 "iterated_fderiv_succ_const":
 "theorem iterated_fderiv_succ_const (n : â„•) (c : F) : (iterated_fderiv ğ•œ (n + 1) fun y : E => c) = 0 :=\n  by\n  ext (x m)\n  simp only [iterated_fderiv_succ_apply_right, fderiv_const, Pi.zero_apply, iterated_fderiv_zero_fun,\n    ContinuousMultilinearMap.zero_apply, ContinuousLinearMap.zero_apply]\n#align iterated_fderiv_succ_const iterated_fderiv_succ_const\n\n",
 "iterated_fderiv_neg_apply":
 "theorem iterated_fderiv_neg_apply {i : â„•} {f : E â†’ F} : iterated_fderiv ğ•œ i (-f) x = -iterated_fderiv ğ•œ i f x :=\n  by\n  simp_rw [â† iterated_fderiv_within_univ]\n  exact iterated_fderiv_within_neg_apply unique_diff_on_univ (Set.mem_univ _)\n#align iterated_fderiv_neg_apply iterated_fderiv_neg_apply\n\n",
 "iterated_fderiv_const_smul_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\ntheorem iterated_fderiv_const_smul_apply {x : E} (hf : cont_diff ğ•œ i f) :\n    iterated_fderiv ğ•œ i (Â«expr â€¢ Â» a f) x = Â«expr â€¢ Â» a (iterated_fderiv ğ•œ i f x) :=\n  by\n  simp_rw [â† cont_diff_on_univ, â† iterated_fderiv_within_univ] at *\n  refine' iterated_fderiv_within_const_smul_apply hf unique_diff_on_univ (Set.mem_univ _)\n#align iterated_fderiv_const_smul_apply iterated_fderiv_const_smul_apply\n\n",
 "iterated_fderiv_const_of_ne":
 "theorem iterated_fderiv_const_of_ne {n : â„•} (hn : n â‰  0) (c : F) : (iterated_fderiv ğ•œ n fun y : E => c) = 0 :=\n  by\n  cases' nat.exists_eq_succ_of_ne_zero hn with k hk\n  rw [hk, iterated_fderiv_succ_const]\n#align iterated_fderiv_const_of_ne iterated_fderiv_const_of_ne\n\n",
 "iterated_fderiv_comp_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ„•âˆÂ» -/\n/-- The iterated derivative of the composition with a linear map on the right is\nobtained by composing the iterated derivative with the linear map. -/\ntheorem continuous_linear_map.iterated_fderiv_comp_right (g : Â«expr â†’L[ ] Â» G ğ•œ E) {f : E â†’ F} (hf : cont_diff ğ•œ n f)\n    (x : G) {i : â„•} (hi : (i : Â«exprâ„•âˆÂ») â‰¤ n) :\n    iterated_fderiv ğ•œ i (f âˆ˜ g) x = (iterated_fderiv ğ•œ i f (g x)).comp_continuous_linear_map fun _ => g :=\n  by\n  simp only [â† iterated_fderiv_within_univ]\n  apply g.iterated_fderiv_within_comp_right hf.cont_diff_on unique_diff_on_univ unique_diff_on_univ (mem_univ _) hi\n#align continuous_linear_map.iterated_fderiv_comp_right continuous_linear_map.iterated_fderiv_comp_right\n\n",
 "iterated_fderiv_comp_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ„•âˆÂ» -/\n/-- The iterated derivative of the composition with a linear map on the left is\nobtained by applying the linear map to the iterated derivative. -/\ntheorem continuous_linear_map.iterated_fderiv_comp_left {f : E â†’ F} (g : Â«expr â†’L[ ] Â» F ğ•œ G) (hf : cont_diff ğ•œ n f)\n    (x : E) {i : â„•} (hi : (i : Â«exprâ„•âˆÂ») â‰¤ n) :\n    iterated_fderiv ğ•œ i (g âˆ˜ f) x = g.comp_continuous_multilinear_map (iterated_fderiv ğ•œ i f x) :=\n  by\n  simp only [â† iterated_fderiv_within_univ]\n  exact g.iterated_fderiv_within_comp_left hf.cont_diff_on unique_diff_on_univ (mem_univ x) hi\n#align continuous_linear_map.iterated_fderiv_comp_left continuous_linear_map.iterated_fderiv_comp_left\n\n",
 "iterated_fderiv_add_apply'":
 "theorem iterated_fderiv_add_apply' {i : â„•} {f g : E â†’ F} (hf : cont_diff ğ•œ i f) (hg : cont_diff ğ•œ i g) :\n    iterated_fderiv ğ•œ i (fun x => f x + g x) x = iterated_fderiv ğ•œ i f x + iterated_fderiv ğ•œ i g x :=\n  iterated_fderiv_add_apply hf hg\n#align iterated_fderiv_add_apply' iterated_fderiv_add_apply'\n\n",
 "iterated_fderiv_add_apply":
 "theorem iterated_fderiv_add_apply {i : â„•} {f g : E â†’ F} (hf : cont_diff ğ•œ i f) (hg : cont_diff ğ•œ i g) :\n    iterated_fderiv ğ•œ i (f + g) x = iterated_fderiv ğ•œ i f x + iterated_fderiv ğ•œ i g x :=\n  by\n  simp_rw [â† cont_diff_on_univ, â† iterated_fderiv_within_univ] at hf hgâŠ¢\n  exact iterated_fderiv_within_add_apply hf hg unique_diff_on_univ (Set.mem_univ _)\n#align iterated_fderiv_add_apply iterated_fderiv_add_apply\n\n",
 "inv":
 "theorem cont_diff.inv {f : E â†’ ğ•œ'} {n} (hf : cont_diff ğ•œ n f) (h : âˆ€ x, f x â‰  0) : cont_diff ğ•œ n fun x => (f x)â»Â¹ :=\n  by\n  rw [cont_diff_iff_cont_diff_at]\n  exact fun x => hf.cont_diff_at.inv (h x)\n#align cont_diff.inv cont_diff.inv\n\n",
 "has_strict_fderiv_at'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/-- If a function is `C^n` with `1 â‰¤ n` around a point, and its derivative at that point is given to\nus as `f'`, then `f'` is also a strict derivative. -/\ntheorem cont_diff_at.has_strict_fderiv_at' {f : E' â†’ F'} {f' : Â«expr â†’L[ ] Â» E' ğ•‚ F'} {x : E'}\n    (hf : cont_diff_at ğ•‚ n f x) (hf' : has_fderiv_at f f' x) (hn : 1 â‰¤ n) : has_strict_fderiv_at f f' x :=\n  by\n  rcases hf 1 hn with âŸ¨u, H, p, hpâŸ©\n  simp only [nhdsWithin_univ, mem_univ, insert_eq_of_mem] at H\n  have := hp.has_strict_fderiv_at le_rfl H\n  rwa [hf'.unique this.has_fderiv_at]\n#align cont_diff_at.has_strict_fderiv_at' cont_diff_at.has_strict_fderiv_at'\n\n",
 "has_strict_fderiv_at":
 "/-- If a function is `C^n` with `1 â‰¤ n`, then the derivative of `f` is also a strict derivative. -/\ntheorem cont_diff.has_strict_fderiv_at {f : E' â†’ F'} {x : E'} (hf : cont_diff ğ•‚ n f) (hn : 1 â‰¤ n) :\n    has_strict_fderiv_at f (fderiv ğ•‚ f x) x :=\n  hf.cont_diff_at.has_strict_fderiv_at hn\n#align cont_diff.has_strict_fderiv_at cont_diff.has_strict_fderiv_at\n\n",
 "has_strict_deriv_at'":
 "/-- If a function is `C^n` with `1 â‰¤ n` around a point, and its derivative at that point is given to\nus as `f'`, then `f'` is also a strict derivative. -/\ntheorem cont_diff_at.has_strict_deriv_at' {f : ğ•‚ â†’ F'} {f' : F'} {x : ğ•‚} (hf : cont_diff_at ğ•‚ n f x)\n    (hf' : has_deriv_at f f' x) (hn : 1 â‰¤ n) : has_strict_deriv_at f f' x :=\n  hf.has_strict_fderiv_at' hf' hn\n#align cont_diff_at.has_strict_deriv_at' cont_diff_at.has_strict_deriv_at'\n\n",
 "has_strict_deriv_at":
 "/-- If a function is `C^n` with `1 â‰¤ n`, then the derivative of `f` is also a strict derivative. -/\ntheorem cont_diff.has_strict_deriv_at {f : ğ•‚ â†’ F'} {x : ğ•‚} (hf : cont_diff ğ•‚ n f) (hn : 1 â‰¤ n) :\n    has_strict_deriv_at f (deriv f x) x :=\n  hf.cont_diff_at.has_strict_deriv_at hn\n#align cont_diff.has_strict_deriv_at cont_diff.has_strict_deriv_at\n\n",
 "has_ftaylor_series_up_to_on_pi'":
 "@[simp]\ntheorem has_ftaylor_series_up_to_on_pi' :\n    has_ftaylor_series_up_to_on n Î¦ P' s â†”\n      âˆ€ i,\n        has_ftaylor_series_up_to_on n (fun x => Î¦ x i)\n          (fun x m => (@ContinuousLinearMap.proj ğ•œ _ Î¹ F' _ _ _ i).comp_continuous_multilinear_map (P' x m)) s :=\n  by\n  convert has_ftaylor_series_up_to_on_pi\n  ext\n  rfl\n#align has_ftaylor_series_up_to_on_pi' has_ftaylor_series_up_to_on_pi'\n\n",
 "has_ftaylor_series_up_to_on_pi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr [Ã— ]â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰ƒâ‚—áµ¢[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr [Ã— ]â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr [Ã— ]â†’L[ ] Â» -/\ntheorem has_ftaylor_series_up_to_on_pi :\n    has_ftaylor_series_up_to_on n (fun x i => Ï† i x) (fun x m => ContinuousMultilinearMap.pi fun i => p' i x m) s â†”\n      âˆ€ i, has_ftaylor_series_up_to_on n (Ï† i) (p' i) s :=\n  by\n  set pr := @ContinuousLinearMap.proj ğ•œ _ Î¹ F' _ _ _\n  letI : âˆ€ (m : â„•) (i : Î¹), NormedSpace ğ•œ (Â«expr [Ã— ]â†’L[ ] Â» E m ğ•œ (F' i)) := fun m i => inferInstance\n  set L : âˆ€ m : â„•, Â«expr â‰ƒâ‚—áµ¢[ ] Â» (âˆ€ i, Â«expr [Ã— ]â†’L[ ] Â» E m ğ•œ (F' i)) ğ•œ (Â«expr [Ã— ]â†’L[ ] Â» E m ğ•œ (âˆ€ i, F' i)) :=\n    fun m => continuous_multilinear_map.piâ‚—áµ¢ _ _\n  refine' âŸ¨fun h i => _, fun h => âŸ¨fun x hx => _, _, _âŸ©âŸ©\n  Â· convert h.continuous_linear_map_comp (pr i)\n    ext\n    rfl\n  Â· ext1 i\n    exact (h i).zero_eq x hx\n  Â· intro m hm x hx\n    have := has_fderiv_within_at_pi.2 fun i => (h i).fderiv_within m hm x hx\n    convert(L m).has_fderiv_at.comp_has_fderiv_within_at x this\n  Â· intro m hm\n    have := continuousOn_pi.2 fun i => (h i).cont m hm\n    convert(L m).continuous.comp_continuous_on this\n#align has_ftaylor_series_up_to_on_pi has_ftaylor_series_up_to_on_pi\n\n",
 "has_fderiv_within_at_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/-- One direction of `cont_diff_within_at_succ_iff_has_fderiv_within_at`, but where all derivatives\n\u0009are taken within the same set. Version for partial derivatives / functions with parameters.\n\u0009If `f x` is a `C^n+1` family of functions and `g x` is a `C^n` family of points, then the\n  derivative of `f x` at `g x` depends in a `C^n` way on `x`. We give a general version of this fact\n  relative to sets which may not have unique derivatives, in the following form.\n\u0009If `f : E Ã— F â†’ G` is `C^n+1` at `(xâ‚€, g(xâ‚€))` in `(s âˆª {xâ‚€}) Ã— t âŠ† E Ã— F` and `g : E â†’ F` is\n\u0009`C^n` at `xâ‚€` within some set `s âŠ† E`, then there is a function `f' : E â†’ F â†’L[ğ•œ] G`\n\u0009that is `C^n` at `xâ‚€` within `s` such that for all `x` sufficiently close to `xâ‚€` within\n\u0009`s âˆª {xâ‚€}` the function `y â†¦ f x y` has derivative `f' x` at `g x` within `t âŠ† F`.\n\u0009For convenience, we return an explicit set of `x`'s where this holds that is a subset of\n\u0009`s âˆª {xâ‚€}`.\n\u0009We need one additional condition, namely that `t` is a neighborhood of `g(xâ‚€)` within `g '' s`.\n\u0009-/\ntheorem cont_diff_within_at.has_fderiv_within_at_nhds {f : E â†’ F â†’ G} {g : E â†’ F} {t : Set F} {n : â„•} {xâ‚€ : E}\n    (hf : cont_diff_within_at ğ•œ (n + 1) (uncurry f) (lower_set.prod (insert xâ‚€ s) t) (xâ‚€, g xâ‚€))\n    (hg : cont_diff_within_at ğ•œ n g s xâ‚€) (hgt : t âˆˆ nhds_within (Â«expr '' Â» g s) (g xâ‚€)) :\n    âˆƒ v âˆˆ nhds_within (insert xâ‚€ s) xâ‚€,\n      v âŠ† insert xâ‚€ s âˆ§\n        âˆƒ f' : E â†’ Â«expr â†’L[ ] Â» F ğ•œ G,\n          (âˆ€ x âˆˆ v, has_fderiv_within_at (f x) (f' x) t (g x)) âˆ§ cont_diff_within_at ğ•œ n (fun x => f' x) s xâ‚€ :=\n  by\n  have hst : lower_set.prod (insert xâ‚€ s) t âˆˆ nhds_within (Â«expr '' Â» (fun x => (x, g x)) s) (xâ‚€, g xâ‚€) :=\n    by\n    refine' nhdsWithin_mono _ _ (nhdsWithin_prod self_mem_nhdsWithin hgt)\n    simp_rw [image_subset_iff, mk_preimage_prod, preimage_id', subset_inter_iff, subset_insert, true_and_iff,\n      subset_preimage_image]\n  obtain âŸ¨v, hv, hvs, f', hvf', hf'âŸ© := cont_diff_within_at_succ_iff_has_fderiv_within_at'.mp hf\n  refine'\n    âŸ¨Â«expr â»Â¹' Â» (fun z => (z, g z)) v âˆ© insert xâ‚€ s, _, inter_subset_right _ _, fun z =>\n      (f' (z, g z)).comp (ContinuousLinearMap.inr ğ•œ E F), _, _âŸ©\n  Â· refine' inter_mem _ self_mem_nhdsWithin\n    have := mem_of_mem_nhdsWithin (mem_insert _ _) hv\n    refine' mem_nhds_within_insert.mpr âŸ¨this, _âŸ©\n    refine' (continuous_within_at_id.prod hg.continuous_within_at).preimage_mem_nhds_within' _\n    rw [â† nhdsWithin_le_iff] at hst hvâŠ¢\n    refine' (hst.trans <| nhdsWithin_mono _ <| subset_insert _ _).trans hv\n  Â· intro z hz\n    have := hvf' (z, g z) hz.1\n    refine' this.comp _ (has_fderiv_at_prod_mk_right _ _).has_fderiv_within_at _\n    exact maps_to'.mpr (image_prod_mk_subset_prod_right hz.2)\n  Â·\n    exact\n      (hf'.continuous_linear_map_comp <|\n            (continuous_linear_map.compL ğ•œ F (E Ã— F) G).flip (ContinuousLinearMap.inr ğ•œ E F)).comp_of_mem\n        xâ‚€ (cont_diff_within_at_id.prod hg) hst\n#align cont_diff_within_at.has_fderiv_within_at_nhds cont_diff_within_at.has_fderiv_within_at_nhds\n\n",
 "fst''":
 "/-- Precomposing `f` with `prod.fst` is `C^n` at `x : E Ã— F` -/\ntheorem cont_diff_at.fst'' {f : E â†’ G} {x : E Ã— F} (hf : cont_diff_at ğ•œ n f x.1) :\n    cont_diff_at ğ•œ n (fun x : E Ã— F => f x.1) x :=\n  hf.comp x cont_diff_at_fst\n#align cont_diff_at.fst'' cont_diff_at.fst''\n\n",
 "fst'":
 "/-- Precomposing `f` with `prod.fst` is `C^n` at `(x, y)` -/\ntheorem cont_diff_at.fst' {f : E â†’ G} {x : E} {y : F} (hf : cont_diff_at ğ•œ n f x) :\n    cont_diff_at ğ•œ n (fun x : E Ã— F => f x.1) (x, y) :=\n  cont_diff_at.comp (x, y) hf cont_diff_at_fst\n#align cont_diff_at.fst' cont_diff_at.fst'\n\n",
 "fst":
 "/-- Postcomposing `f` with `prod.fst` is `C^n` at `(x, y)` -/\ntheorem cont_diff_at.fst {f : E â†’ F Ã— G} {x : E} (hf : cont_diff_at ğ•œ n f x) : cont_diff_at ğ•œ n (fun x => (f x).1) x :=\n  cont_diff_at_fst.comp x hf\n#align cont_diff_at.fst cont_diff_at.fst\n\n",
 "fderiv_within_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ„•âˆÂ» -/\n/-- `fderiv_within ğ•œ f s` is smooth at `xâ‚€` within `s`. -/\ntheorem cont_diff_within_at.fderiv_within_right (hf : cont_diff_within_at ğ•œ n f s xâ‚€) (hs : unique_diff_on ğ•œ s)\n    (hmn : (m + 1 : Â«exprâ„•âˆÂ») â‰¤ n) (hxâ‚€s : xâ‚€ âˆˆ s) : cont_diff_within_at ğ•œ m (fderiv_within ğ•œ f s) s xâ‚€ :=\n  cont_diff_within_at.fderiv_within\n    (cont_diff_within_at.comp (xâ‚€, xâ‚€) hf cont_diff_within_at_snd <| prod_subset_preimage_snd s s)\n    cont_diff_within_at_id hs hmn hxâ‚€s (by rw [preimage_id'])\n#align cont_diff_within_at.fderiv_within_right cont_diff_within_at.fderiv_within_right\n\n",
 "fderiv_within_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ„•âˆÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/-- `x â†¦ fderiv_within ğ•œ (f x) t (g x) (k x)` is smooth at a point within a set. -/\ntheorem cont_diff_within_at.fderiv_within_apply {f : E â†’ F â†’ G} {g k : E â†’ F} {t : Set F} {n : Â«exprâ„•âˆÂ»}\n    (hf : cont_diff_within_at ğ•œ n (function.uncurry f) (lower_set.prod s t) (xâ‚€, g xâ‚€))\n    (hg : cont_diff_within_at ğ•œ m g s xâ‚€) (hk : cont_diff_within_at ğ•œ m k s xâ‚€) (ht : unique_diff_on ğ•œ t)\n    (hmn : m + 1 â‰¤ n) (hxâ‚€ : xâ‚€ âˆˆ s) (hst : s âŠ† Â«expr â»Â¹' Â» g t) :\n    cont_diff_within_at ğ•œ m (fun x => fderiv_within ğ•œ (f x) t (g x) (k x)) s xâ‚€ :=\n  (cont_diff_fst.clm_apply cont_diff_snd).cont_diff_at.comp_cont_diff_within_at xâ‚€\n    ((hf.fderiv_within hg ht hmn hxâ‚€ hst).prod hk)\n#align cont_diff_within_at.fderiv_within_apply cont_diff_within_at.fderiv_within_apply\n\n",
 "fderiv_within''":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ„•âˆÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ„•âˆÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/-- The most general lemma stating that `x â†¦ fderiv_within ğ•œ (f x) t (g x)` is `C^n`\nat a point within a set.\nTo show that `x â†¦ D_yf(x,y)g(x)` (taken within `t`) is `C^m` at `xâ‚€` within `s`, we require that\n* `f` is `C^n` at `(xâ‚€, g(xâ‚€))` within `(s âˆª {xâ‚€}) Ã— t` for `n â‰¥ m+1`.\n* `g` is `C^m` at `xâ‚€` within `s`;\n* Derivatives are unique at `g(x)` within `t` for `x` sufficiently close to `xâ‚€` within `s âˆª {xâ‚€}`;\n* `t` is a neighborhood of `g(xâ‚€)` within `g '' s`; -/\ntheorem cont_diff_within_at.fderiv_within'' {f : E â†’ F â†’ G} {g : E â†’ F} {t : Set F} {n : Â«exprâ„•âˆÂ»}\n    (hf : cont_diff_within_at ğ•œ n (function.uncurry f) (lower_set.prod (insert xâ‚€ s) t) (xâ‚€, g xâ‚€))\n    (hg : cont_diff_within_at ğ•œ m g s xâ‚€)\n    (ht :\n      Â«exprâˆ€á¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â»\"\n        (nhds_within (insert xâ‚€ s) xâ‚€) (unique_diff_within_at ğ•œ t (g x)))\n    (hmn : m + 1 â‰¤ n) (hgt : t âˆˆ nhds_within (Â«expr '' Â» g s) (g xâ‚€)) :\n    cont_diff_within_at ğ•œ m (fun x => fderiv_within ğ•œ (f x) t (g x)) s xâ‚€ :=\n  by\n  have : âˆ€ k : â„•, (k : Â«exprâ„•âˆÂ») â‰¤ m â†’ cont_diff_within_at ğ•œ k (fun x => fderiv_within ğ•œ (f x) t (g x)) s xâ‚€ :=\n    by\n    intro k hkm\n    obtain âŸ¨v, hv, -, f', hvf', hf'âŸ© :=\n      (hf.of_le <| (add_le_add_right hkm 1).trans hmn).has_fderiv_within_at_nhds (hg.of_le hkm) hgt\n    refine' hf'.congr_of_eventually_eq_insert _\n    filter_upwards [hv, ht]\n    exact fun y hy h2y => (hvf' y hy).fderiv_within h2y\n  induction m using WithTop.recTopCoe\n  Â· obtain rfl := eq_top_iff.mpr hmn\n    rw [cont_diff_within_at_top]\n    exact fun m => this m le_top\n  exact this m le_rfl\n#align cont_diff_within_at.fderiv_within'' cont_diff_within_at.fderiv_within''\n\n",
 "fderiv_within'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ„•âˆÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/-- A special case of `cont_diff_within_at.fderiv_within''` where we require that `s âŠ† gâ»Â¹(t)`. -/\ntheorem cont_diff_within_at.fderiv_within' {f : E â†’ F â†’ G} {g : E â†’ F} {t : Set F} {n : Â«exprâ„•âˆÂ»}\n    (hf : cont_diff_within_at ğ•œ n (function.uncurry f) (lower_set.prod (insert xâ‚€ s) t) (xâ‚€, g xâ‚€))\n    (hg : cont_diff_within_at ğ•œ m g s xâ‚€)\n    (ht :\n      Â«exprâˆ€á¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â»\"\n        (nhds_within (insert xâ‚€ s) xâ‚€) (unique_diff_within_at ğ•œ t (g x)))\n    (hmn : m + 1 â‰¤ n) (hst : s âŠ† Â«expr â»Â¹' Â» g t) :\n    cont_diff_within_at ğ•œ m (fun x => fderiv_within ğ•œ (f x) t (g x)) s xâ‚€ :=\n  hf.fderiv_within'' hg ht hmn <| mem_of_superset self_mem_nhdsWithin <| image_subset_iff.mpr hst\n#align cont_diff_within_at.fderiv_within' cont_diff_within_at.fderiv_within'\n\n",
 "fderiv_within":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ„•âˆÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/-- A special case of `cont_diff_within_at.fderiv_within'` where we require that `xâ‚€ âˆˆ s` and there\n  are unique derivatives everywhere within `t`. -/\ntheorem cont_diff_within_at.fderiv_within {f : E â†’ F â†’ G} {g : E â†’ F} {t : Set F} {n : Â«exprâ„•âˆÂ»}\n    (hf : cont_diff_within_at ğ•œ n (function.uncurry f) (lower_set.prod s t) (xâ‚€, g xâ‚€))\n    (hg : cont_diff_within_at ğ•œ m g s xâ‚€) (ht : unique_diff_on ğ•œ t) (hmn : m + 1 â‰¤ n) (hxâ‚€ : xâ‚€ âˆˆ s)\n    (hst : s âŠ† Â«expr â»Â¹' Â» g t) : cont_diff_within_at ğ•œ m (fun x => fderiv_within ğ•œ (f x) t (g x)) s xâ‚€ :=\n  by\n  rw [â† insert_eq_self.mpr hxâ‚€] at hf\n  refine' hf.fderiv_within' hg _ hmn hst\n  rw [insert_eq_self.mpr hxâ‚€]\n  exact eventually_of_mem self_mem_nhdsWithin fun x hx => ht _ (hst hx)\n#align cont_diff_within_at.fderiv_within cont_diff_within_at.fderiv_within\n\n",
 "fderiv_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ„•âˆÂ» -/\n/-- `fderiv ğ•œ f` is smooth. -/\ntheorem cont_diff.fderiv_right (hf : cont_diff ğ•œ n f) (hmn : (m + 1 : Â«exprâ„•âˆÂ») â‰¤ n) : cont_diff ğ•œ m (fderiv ğ•œ f) :=\n  cont_diff_iff_cont_diff_at.mpr fun x => hf.cont_diff_at.fderiv_right hmn\n#align cont_diff.fderiv_right cont_diff.fderiv_right\n\n",
 "fderiv_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ„•âˆÂ» -/\n/-- `x â†¦ fderiv ğ•œ (f x) (g x) (k x)` is smooth. -/\ntheorem cont_diff.fderiv_apply {f : E â†’ F â†’ G} {g k : E â†’ F} {n m : Â«exprâ„•âˆÂ»} (hf : cont_diff ğ•œ m <| function.uncurry f)\n    (hg : cont_diff ğ•œ n g) (hk : cont_diff ğ•œ n k) (hnm : n + 1 â‰¤ m) :\n    cont_diff ğ•œ n fun x => fderiv ğ•œ (f x) (g x) (k x) :=\n  (hf.fderiv hg hnm).clm_apply hk\n#align cont_diff.fderiv_apply cont_diff.fderiv_apply\n\n",
 "fderiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ„•âˆÂ» -/\n/-- `x â†¦ fderiv ğ•œ (f x) (g x)` is continuous. -/\ntheorem continuous.fderiv {f : E â†’ F â†’ G} {g : E â†’ F} {n : Â«exprâ„•âˆÂ»} (hf : cont_diff ğ•œ n <| function.uncurry f)\n    (hg : Continuous g) (hn : 1 â‰¤ n) : Continuous fun x => fderiv ğ•œ (f x) (g x) :=\n  (hf.fderiv (cont_diff_zero.mpr hg) hn).continuous\n#align continuous.fderiv continuous.fderiv\n\n",
 "exists_lipschitz_on_with_of_nnnorm_lt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–â‚ŠÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- If `f` is `C^1` at `x` and `K > â€–fderiv ğ•‚ f xâ€–`, then `f` is `K`-Lipschitz in a neighborhood of\n`x`. -/\ntheorem cont_diff_at.exists_lipschitz_on_with_of_nnnorm_lt {f : E' â†’ F'} {x : E'} (hf : cont_diff_at ğ•‚ 1 f x)\n    (K : nnreal) (hK : Â«exprâ€– â€–â‚ŠÂ» (fderiv ğ•‚ f x) < K) : âˆƒ t âˆˆ (nhds) x, LipschitzOnWith K f t :=\n  (hf.has_strict_fderiv_at le_rfl).exists_lipschitz_on_with_of_nnnorm_lt K hK\n#align cont_diff_at.exists_lipschitz_on_with_of_nnnorm_lt cont_diff_at.exists_lipschitz_on_with_of_nnnorm_lt\n\n",
 "exists_lipschitz_on_with":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- If `f` is `C^1` at `x`, then `f` is Lipschitz in a neighborhood of `x`. -/\ntheorem cont_diff_at.exists_lipschitz_on_with {f : E' â†’ F'} {x : E'} (hf : cont_diff_at ğ•‚ 1 f x) :\n    âˆƒ K, âˆƒ t âˆˆ (nhds) x, LipschitzOnWith K f t :=\n  (hf.has_strict_fderiv_at le_rfl).exists_lipschitz_on_with\n#align cont_diff_at.exists_lipschitz_on_with cont_diff_at.exists_lipschitz_on_with\n\n",
 "div_const":
 "theorem cont_diff.div_const {f : E â†’ ğ•œ'} {n} (hf : cont_diff ğ•œ n f) (c : ğ•œ') : cont_diff ğ•œ n fun x => f x / c := by\n  simpa only [div_eq_mul_inv] using hf.mul cont_diff_const\n#align cont_diff.div_const cont_diff.div_const\n\n",
 "div":
 "theorem cont_diff.div [CompleteSpace ğ•œ] {f g : E â†’ ğ•œ} {n} (hf : cont_diff ğ•œ n f) (hg : cont_diff ğ•œ n g)\n    (h0 : âˆ€ x, g x â‰  0) : cont_diff ğ•œ n fun x => f x / g x :=\n  by\n  simp only [cont_diff_iff_cont_diff_at] at *\n  exact fun x => (hf x).div (hg x) (h0 x)\n#align cont_diff.div cont_diff.div\n\n",
 "deriv_within":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ„•âˆÂ» -/\ntheorem cont_diff_on.deriv_within (hf : cont_diff_on ğ•œ n fâ‚‚ sâ‚‚) (hs : unique_diff_on ğ•œ sâ‚‚) (hmn : m + 1 â‰¤ n) :\n    cont_diff_on ğ•œ m (deriv_within fâ‚‚ sâ‚‚) sâ‚‚ := by\n  cases m\n  Â· change Â«exprâˆÂ» + 1 â‰¤ n at hmn\n    have : n = Â«exprâˆÂ» := by simpa using hmn\n    rw [this] at hf\n    exact ((cont_diff_on_top_iff_deriv_within hs).1 hf).2\n  Â· change (m.succ : Â«exprâ„•âˆÂ») â‰¤ n at hmn\n    exact ((cont_diff_on_succ_iff_deriv_within hs).1 (hf.of_le hmn)).2\n#align cont_diff_on.deriv_within cont_diff_on.deriv_within\n\n",
 "deriv_of_open":
 "theorem cont_diff_on.deriv_of_open (hf : cont_diff_on ğ•œ n fâ‚‚ sâ‚‚) (hs : IsOpen sâ‚‚) (hmn : m + 1 â‰¤ n) :\n    cont_diff_on ğ•œ m (deriv fâ‚‚) sâ‚‚ :=\n  (hf.deriv_within hs.unique_diff_on hmn).congr fun x hx => (deriv_within_of_open hs hx).symm\n#align cont_diff_on.deriv_of_open cont_diff_on.deriv_of_open\n\n",
 "continuous_on_fderiv_within_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n/-- If a function is at least `C^1`, its bundled derivative (mapping `(x, v)` to `Df(x) v`) is\ncontinuous. -/\ntheorem cont_diff_on.continuous_on_fderiv_within_apply (hf : cont_diff_on ğ•œ n f s) (hs : unique_diff_on ğ•œ s)\n    (hn : 1 â‰¤ n) : ContinuousOn (fun p : E Ã— E => (fderiv_within ğ•œ f s p.1 : E â†’ F) p.2) (lower_set.prod s univ) :=\n  (cont_diff_on_fderiv_within_apply hf hs <| by rwa [zero_add]).continuous_on\n#align cont_diff_on.continuous_on_fderiv_within_apply cont_diff_on.continuous_on_fderiv_within_apply\n\n",
 "continuous_on_deriv_within":
 "theorem cont_diff_on.continuous_on_deriv_within (h : cont_diff_on ğ•œ n fâ‚‚ sâ‚‚) (hs : unique_diff_on ğ•œ sâ‚‚) (hn : 1 â‰¤ n) :\n    ContinuousOn (deriv_within fâ‚‚ sâ‚‚) sâ‚‚ :=\n  ((cont_diff_on_succ_iff_deriv_within hs).1 (h.of_le hn)).2.continuous_on\n#align cont_diff_on.continuous_on_deriv_within cont_diff_on.continuous_on_deriv_within\n\n",
 "continuous_on_deriv_of_open":
 "theorem cont_diff_on.continuous_on_deriv_of_open (h : cont_diff_on ğ•œ n fâ‚‚ sâ‚‚) (hs : IsOpen sâ‚‚) (hn : 1 â‰¤ n) :\n    ContinuousOn (deriv fâ‚‚) sâ‚‚ :=\n  ((cont_diff_on_succ_iff_deriv_of_open hs).1 (h.of_le hn)).2.continuous_on\n#align cont_diff_on.continuous_on_deriv_of_open cont_diff_on.continuous_on_deriv_of_open\n\n",
 "continuous_linear_map_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/-- Composition by continuous linear maps on the left preserves `C^n` functions. -/\ntheorem cont_diff.continuous_linear_map_comp {f : E â†’ F} (g : Â«expr â†’L[ ] Â» F ğ•œ G) (hf : cont_diff ğ•œ n f) :\n    cont_diff ğ•œ n fun x => g (f x) :=\n  cont_diff_on_univ.1 <| cont_diff_on.continuous_linear_map_comp _ (cont_diff_on_univ.2 hf)\n#align cont_diff.continuous_linear_map_comp cont_diff.continuous_linear_map_comp\n\n",
 "continuous_deriv":
 "theorem cont_diff.continuous_deriv (h : cont_diff ğ•œ n fâ‚‚) (hn : 1 â‰¤ n) : Continuous (deriv fâ‚‚) :=\n  (cont_diff_succ_iff_deriv.mp (h.of_le hn)).2.continuous\n#align cont_diff.continuous_deriv cont_diff.continuous_deriv\n\n",
 "cont_diff_zero_fun":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr [Ã— ]â†’L[ ] Â» -/\ntheorem cont_diff_zero_fun : cont_diff ğ•œ n fun x : E => (0 : F) :=\n  by\n  apply cont_diff_of_differentiable_iterated_fderiv fun m hm => _\n  rw [iterated_fderiv_zero_fun]\n  exact differentiable_const (0 : Â«expr [Ã— ]â†’L[ ] Â» E m ğ•œ F)\n#align cont_diff_zero_fun cont_diff_zero_fun\n\n",
 "cont_diff_within_at_snd":
 "/-- The second projection within a domain at a point in a product is `C^âˆ`. -/\ntheorem cont_diff_within_at_snd {s : Set (E Ã— F)} {p : E Ã— F} : cont_diff_within_at ğ•œ n (Prod.snd : E Ã— F â†’ F) s p :=\n  cont_diff_snd.cont_diff_within_at\n#align cont_diff_within_at_snd cont_diff_within_at_snd\n\n",
 "cont_diff_within_at_prod'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\ntheorem cont_diff_within_at_prod' {t : Finset Î¹} {f : Î¹ â†’ E â†’ ğ”¸'} (h : âˆ€ i âˆˆ t, cont_diff_within_at ğ•œ n (f i) s x) :\n    cont_diff_within_at ğ•œ n\n      (finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" t (f i)) s x :=\n  Finset.prod_induction f (fun f => cont_diff_within_at ğ•œ n f s x) (fun _ _ => cont_diff_within_at.mul)\n    (@cont_diff_within_at_const _ _ _ _ _ _ _ _ _ _ _ 1) h\n#align cont_diff_within_at_prod' cont_diff_within_at_prod'\n\n",
 "cont_diff_within_at_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\ntheorem cont_diff_within_at_prod {t : Finset Î¹} {f : Î¹ â†’ E â†’ ğ”¸'} (h : âˆ€ i âˆˆ t, cont_diff_within_at ğ•œ n (f i) s x) :\n    cont_diff_within_at ğ•œ n\n      (fun y =>\n        finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" t (f i y))\n      s x :=\n  by simpa only [â† Finset.prod_apply] using cont_diff_within_at_prod' h\n#align cont_diff_within_at_prod cont_diff_within_at_prod\n\n",
 "cont_diff_within_at_pi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹‚ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹‚ , Â» -/\ntheorem cont_diff_within_at_pi : cont_diff_within_at ğ•œ n Î¦ s x â†” âˆ€ i, cont_diff_within_at ğ•œ n (fun x => Î¦ x i) s x :=\n  by\n  set pr := @ContinuousLinearMap.proj ğ•œ _ Î¹ F' _ _ _\n  refine' âŸ¨fun h i => h.continuous_linear_map_comp (pr i), fun h m hm => _âŸ©\n  choose u hux p hp using fun i => h i m hm\n  exact\n    âŸ¨Â«exprâ‹‚ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹‚ , Â»\" (u i),\n      Filter.interáµ¢_mem.2 hux, _, has_ftaylor_series_up_to_on_pi.2 fun i => (hp i).mono <| Inter_subset _ _âŸ©\n#align cont_diff_within_at_pi cont_diff_within_at_pi\n\n",
 "cont_diff_within_at_of_subsingleton":
 "@[nontriviality]\ntheorem cont_diff_within_at_of_subsingleton [subsingleton F] : cont_diff_within_at ğ•œ n f s x :=\n  by\n  rw [subsingleton.elim f fun _ => 0]\n  exact cont_diff_within_at_const\n#align cont_diff_within_at_of_subsingleton cont_diff_within_at_of_subsingleton\n\n",
 "cont_diff_within_at_id":
 "theorem cont_diff_within_at_id {s x} : cont_diff_within_at ğ•œ n (id : E â†’ E) s x :=\n  cont_diff_id.cont_diff_within_at\n#align cont_diff_within_at_id cont_diff_within_at_id\n\n",
 "cont_diff_within_at_fst":
 "/-- The first projection within a domain at a point in a product is `C^âˆ`. -/\ntheorem cont_diff_within_at_fst {s : Set (E Ã— F)} {p : E Ã— F} : cont_diff_within_at ğ•œ n (Prod.fst : E Ã— F â†’ E) s p :=\n  cont_diff_fst.cont_diff_within_at\n#align cont_diff_within_at_fst cont_diff_within_at_fst\n\n",
 "cont_diff_within_at_const":
 "theorem cont_diff_within_at_const {c : F} : cont_diff_within_at ğ•œ n (fun x : E => c) s x :=\n  cont_diff_at_const.cont_diff_within_at\n#align cont_diff_within_at_const cont_diff_within_at_const\n\n",
 "cont_diff_within_at_comp_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰ƒL[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/-- Composition by continuous linear equivs on the right respects higher differentiability at a\npoint in a domain. -/\ntheorem continuous_linear_equiv.cont_diff_within_at_comp_iff (e : Â«expr â‰ƒL[ ] Â» G ğ•œ E) :\n    cont_diff_within_at ğ•œ n (f âˆ˜ e) (Â«expr â»Â¹' Â» e s) (e.symm x) â†” cont_diff_within_at ğ•œ n f s x :=\n  by\n  constructor\n  Â· intro H\n    simpa [â† preimage_comp, (Â· âˆ˜ Â·)] using H.comp_continuous_linear_map (e.symm : Â«expr â†’L[ ] Â» E ğ•œ G)\n  Â· intro H\n    rw [â† e.apply_symm_apply x, â† e.coe_coe] at H\n    exact H.comp_continuous_linear_map _\n#align continuous_linear_equiv.cont_diff_within_at_comp_iff continuous_linear_equiv.cont_diff_within_at_comp_iff\n\n",
 "cont_diff_top_iff_deriv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆÂ» -/\n/-- A function is `C^âˆ` if and only if it is differentiable,\nand its derivative (formulated in terms of `deriv`) is `C^âˆ`. -/\ntheorem cont_diff_top_iff_deriv : cont_diff ğ•œ (Â«exprâˆÂ») fâ‚‚ â†” differentiable ğ•œ fâ‚‚ âˆ§ cont_diff ğ•œ (Â«exprâˆÂ») (deriv fâ‚‚) :=\n  by\n  simp only [â† cont_diff_on_univ, â† differentiable_on_univ, â† deriv_within_univ]\n  rw [cont_diff_on_top_iff_deriv_within unique_diff_on_univ]\n#align cont_diff_top_iff_deriv cont_diff_top_iff_deriv\n\n",
 "cont_diff_symm_deriv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰ƒâ‚œ Â» -/\n/-- Let `f` be an `n` times continuously differentiable homeomorphism of a nontrivially normed\nfield.  Suppose that the derivative of `f` is never equal to zero. Then `f.symm` is `n` times\ncontinuously differentiable.\n\nThis is one of the easy parts of the inverse function theorem: it assumes that we already have\nan inverse function. -/\ntheorem homeomorph.cont_diff_symm_deriv [CompleteSpace ğ•œ] (f : Â«expr â‰ƒâ‚œ Â» ğ•œ ğ•œ) {f' : ğ•œ â†’ ğ•œ} (hâ‚€ : âˆ€ x, f' x â‰  0)\n    (hf' : âˆ€ x, has_deriv_at f (f' x) x) (hf : cont_diff ğ•œ n (f : ğ•œ â†’ ğ•œ)) : cont_diff ğ•œ n (f.symm : ğ•œ â†’ ğ•œ) :=\n  cont_diff_iff_cont_diff_at.2 fun x =>\n    f.to_local_homeomorph.cont_diff_at_symm_deriv (hâ‚€ _) (mem_univ x) (hf' _) hf.cont_diff_at\n#align homeomorph.cont_diff_symm_deriv homeomorph.cont_diff_symm_deriv\n\n",
 "cont_diff_symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰ƒâ‚œ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰ƒL[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/-- If `f` is an `n` times continuously differentiable homeomorphism,\nand if the derivative of `f` at each point is a continuous linear equivalence,\nthen `f.symm` is `n` times continuously differentiable.\n\nThis is one of the easy parts of the inverse function theorem: it assumes that we already have\nan inverse function. -/\ntheorem homeomorph.cont_diff_symm [CompleteSpace E] (f : Â«expr â‰ƒâ‚œ Â» E F) {fâ‚€' : E â†’ Â«expr â‰ƒL[ ] Â» E ğ•œ F}\n    (hfâ‚€' : âˆ€ a, has_fderiv_at f (fâ‚€' a : Â«expr â†’L[ ] Â» E ğ•œ F) a) (hf : cont_diff ğ•œ n (f : E â†’ F)) :\n    cont_diff ğ•œ n (f.symm : F â†’ E) :=\n  cont_diff_iff_cont_diff_at.2 fun x => f.to_local_homeomorph.cont_diff_at_symm (mem_univ x) (hfâ‚€' _) hf.cont_diff_at\n#align homeomorph.cont_diff_symm homeomorph.cont_diff_symm\n\n",
 "cont_diff_succ_iff_fderiv_apply":
 "/-- This is a useful lemma to prove that a certain operation preserves functions being `C^n`.\nWhen you do induction on `n`, this gives a useful characterization of a function being `C^(n+1)`,\nassuming you have already computed the derivative. The advantage of this version over\n`cont_diff_succ_iff_fderiv` is that both occurences of `cont_diff` are for functions with the same\ndomain and codomain (`E` and `F`). This is not the case for `cont_diff_succ_iff_fderiv`, which\noften requires an inconvenient need to generalize `F`, which results in universe issues\n(see the discussion in the section of `cont_diff.comp`).\n\nThis lemma avoids these universe issues, but only applies for finite dimensional `E`. -/\ntheorem cont_diff_succ_iff_fderiv_apply [FiniteDimensional ğ•œ E] {n : â„•} {f : E â†’ F} :\n    cont_diff ğ•œ (n + 1 : â„•) f â†” differentiable ğ•œ f âˆ§ âˆ€ y, cont_diff ğ•œ n fun x => fderiv ğ•œ f x y := by\n  rw [cont_diff_succ_iff_fderiv, cont_diff_clm_apply_iff]\n#align cont_diff_succ_iff_fderiv_apply cont_diff_succ_iff_fderiv_apply\n\n",
 "cont_diff_succ_iff_deriv":
 "/-- A function is `C^(n + 1)` if and only if it is differentiable,\n  and its derivative (formulated in terms of `deriv`) is `C^n`. -/\ntheorem cont_diff_succ_iff_deriv {n : â„•} :\n    cont_diff ğ•œ (n + 1 : â„•) fâ‚‚ â†” differentiable ğ•œ fâ‚‚ âˆ§ cont_diff ğ•œ n (deriv fâ‚‚) := by\n  simp only [â† cont_diff_on_univ, cont_diff_on_succ_iff_deriv_of_open, isOpen_univ, differentiable_on_univ]\n#align cont_diff_succ_iff_deriv cont_diff_succ_iff_deriv\n\n",
 "cont_diff_snd":
 "/-- The second projection in a product is `C^âˆ`. -/\ntheorem cont_diff_snd : cont_diff ğ•œ n (Prod.snd : E Ã— F â†’ F) :=\n  is_bounded_linear_map.cont_diff is_bounded_linear_map.snd\n#align cont_diff_snd cont_diff_snd\n\n",
 "cont_diff_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n-- The scalar multiplication is smooth.\ntheorem cont_diff_smul : cont_diff ğ•œ n fun p : ğ•œ Ã— F => Â«expr â€¢ Â» p.1 p.2 :=\n  is_bounded_bilinear_map_smul.cont_diff\n#align cont_diff_smul cont_diff_smul\n\n",
 "cont_diff_prod_mk_right":
 "theorem cont_diff_prod_mk_right (eâ‚€ : E) : cont_diff ğ•œ n fun f : F => (eâ‚€, f) :=\n  cont_diff_const.prod cont_diff_id\n#align cont_diff_prod_mk_right cont_diff_prod_mk_right\n\n",
 "cont_diff_prod_mk_left":
 "theorem cont_diff_prod_mk_left (fâ‚€ : F) : cont_diff ğ•œ n fun e : E => (e, fâ‚€) :=\n  cont_diff_id.prod cont_diff_const\n#align cont_diff_prod_mk_left cont_diff_prod_mk_left\n\n",
 "cont_diff_prod_assoc_symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\n/-- The natural equivalence `E Ã— (F Ã— G) â‰ƒ (E Ã— F) Ã— G` is smooth.\n\nWarning: see remarks attached to `cont_diff_prod_assoc`\n-/\ntheorem cont_diff_prod_assoc_symm : cont_diff ğ•œ (Â«exprâŠ¤Â») <| (Equiv.prodAssoc E F G).symm :=\n  (LinearIsometryEquiv.prodAssoc ğ•œ E F G).symm.cont_diff\n#align cont_diff_prod_assoc_symm cont_diff_prod_assoc_symm\n\n",
 "cont_diff_prod_assoc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\n/-- The natural equivalence `(E Ã— F) Ã— G â‰ƒ E Ã— (F Ã— G)` is smooth.\n\nWarning: if you think you need this lemma, it is likely that you can simplify your proof by\nreformulating the lemma that you're applying next using the tips in\nNote [continuity lemma statement]\n-/\ntheorem cont_diff_prod_assoc : cont_diff ğ•œ (Â«exprâŠ¤Â») <| Equiv.prodAssoc E F G :=\n  (LinearIsometryEquiv.prodAssoc ğ•œ E F G).cont_diff\n#align cont_diff_prod_assoc cont_diff_prod_assoc\n\n",
 "cont_diff_prod'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\ntheorem cont_diff_prod' {t : Finset Î¹} {f : Î¹ â†’ E â†’ ğ”¸'} (h : âˆ€ i âˆˆ t, cont_diff ğ•œ n (f i)) :\n    cont_diff ğ•œ n\n      (finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" t (f i)) :=\n  cont_diff_iff_cont_diff_at.mpr fun x => cont_diff_at_prod' fun i hi => (h i hi).cont_diff_at\n#align cont_diff_prod' cont_diff_prod'\n\n",
 "cont_diff_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\ntheorem cont_diff_prod {t : Finset Î¹} {f : Î¹ â†’ E â†’ ğ”¸'} (h : âˆ€ i âˆˆ t, cont_diff ğ•œ n (f i)) :\n    cont_diff ğ•œ n fun y =>\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" t (f i y) :=\n  cont_diff_iff_cont_diff_at.mpr fun x => cont_diff_at_prod fun i hi => (h i hi).cont_diff_at\n#align cont_diff_prod cont_diff_prod\n\n",
 "cont_diff_pi":
 "theorem cont_diff_pi : cont_diff ğ•œ n Î¦ â†” âˆ€ i, cont_diff ğ•œ n fun x => Î¦ x i := by\n  simp only [â† cont_diff_on_univ, cont_diff_on_pi]\n#align cont_diff_pi cont_diff_pi\n\n",
 "cont_diff_one_iff_deriv":
 "theorem cont_diff_one_iff_deriv : cont_diff ğ•œ 1 fâ‚‚ â†” differentiable ğ•œ fâ‚‚ âˆ§ Continuous (deriv fâ‚‚) :=\n  cont_diff_succ_iff_deriv.trans <| iff.rfl.and cont_diff_zero\n#align cont_diff_one_iff_deriv cont_diff_one_iff_deriv\n\n",
 "cont_diff_on_top_iff_deriv_within":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ„•âˆÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆÂ» -/\n/-- A function is `C^âˆ` on a domain with unique derivatives if and only if it is differentiable\nthere, and its derivative (formulated with `deriv_within`) is `C^âˆ`. -/\ntheorem cont_diff_on_top_iff_deriv_within (hs : unique_diff_on ğ•œ sâ‚‚) :\n    cont_diff_on ğ•œ (Â«exprâˆÂ») fâ‚‚ sâ‚‚ â†” differentiable_on ğ•œ fâ‚‚ sâ‚‚ âˆ§ cont_diff_on ğ•œ (Â«exprâˆÂ») (deriv_within fâ‚‚ sâ‚‚) sâ‚‚ :=\n  by\n  constructor\n  Â· intro h\n    refine' âŸ¨h.differentiable_on le_top, _âŸ©\n    apply cont_diff_on_top.2 fun n => ((cont_diff_on_succ_iff_deriv_within hs).1 _).2\n    exact h.of_le le_top\n  Â· intro h\n    refine' cont_diff_on_top.2 fun n => _\n    have A : (n : Â«exprâ„•âˆÂ») â‰¤ Â«exprâˆÂ» := le_top\n    apply ((cont_diff_on_succ_iff_deriv_within hs).2 âŸ¨h.1, h.2.of_le AâŸ©).of_le\n    exact WithTop.coe_le_coe.2 (nat.le_succ n)\n#align cont_diff_on_top_iff_deriv_within cont_diff_on_top_iff_deriv_within\n\n",
 "cont_diff_on_top_iff_deriv_of_open":
 "/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:73:14: unsupported tactic `congrm #[[expr Â«expr âˆ§ Â»(_, _)]] -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆÂ» -/\n/-- A function is `C^âˆ` on an open domain if and only if it is differentiable\nthere, and its derivative (formulated with `deriv`) is `C^âˆ`. -/\ntheorem cont_diff_on_top_iff_deriv_of_open (hs : IsOpen sâ‚‚) :\n    cont_diff_on ğ•œ (Â«exprâˆÂ») fâ‚‚ sâ‚‚ â†” differentiable_on ğ•œ fâ‚‚ sâ‚‚ âˆ§ cont_diff_on ğ•œ (Â«exprâˆÂ») (deriv fâ‚‚) sâ‚‚ :=\n  by\n  rw [cont_diff_on_top_iff_deriv_within hs.unique_diff_on]\n  trace\n    \"./././Mathport/Syntax/Translate/Tactic/Builtin.lean:73:14: unsupported tactic `congrm #[[expr Â«expr âˆ§ Â»(_, _)]]\"\n  exact cont_diff_on_congr fun _ => deriv_within_of_open hs\n#align cont_diff_on_top_iff_deriv_of_open cont_diff_on_top_iff_deriv_of_open\n\n",
 "cont_diff_on_succ_of_fderiv_apply":
 "theorem cont_diff_on_succ_of_fderiv_apply [FiniteDimensional ğ•œ E] {n : â„•} {f : E â†’ F} {s : Set E}\n    (hf : differentiable_on ğ•œ f s) (h : âˆ€ y, cont_diff_on ğ•œ n (fun x => fderiv_within ğ•œ f s x y) s) :\n    cont_diff_on ğ•œ (n + 1 : â„•) f s :=\n  cont_diff_on_succ_of_fderiv_within hf <| cont_diff_on_clm_apply.mpr h\n#align cont_diff_on_succ_of_fderiv_apply cont_diff_on_succ_of_fderiv_apply\n\n",
 "cont_diff_on_succ_iff_fderiv_apply":
 "theorem cont_diff_on_succ_iff_fderiv_apply [FiniteDimensional ğ•œ E] {n : â„•} {f : E â†’ F} {s : Set E}\n    (hs : unique_diff_on ğ•œ s) :\n    cont_diff_on ğ•œ (n + 1 : â„•) f s â†”\n      differentiable_on ğ•œ f s âˆ§ âˆ€ y, cont_diff_on ğ•œ n (fun x => fderiv_within ğ•œ f s x y) s :=\n  by rw [cont_diff_on_succ_iff_fderiv_within hs, cont_diff_on_clm_apply]\n#align cont_diff_on_succ_iff_fderiv_apply cont_diff_on_succ_iff_fderiv_apply\n\n",
 "cont_diff_on_succ_iff_deriv_within":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/-- A function is `C^(n + 1)` on a domain with unique derivatives if and only if it is\ndifferentiable there, and its derivative (formulated with `deriv_within`) is `C^n`. -/\ntheorem cont_diff_on_succ_iff_deriv_within {n : â„•} (hs : unique_diff_on ğ•œ sâ‚‚) :\n    cont_diff_on ğ•œ (n + 1 : â„•) fâ‚‚ sâ‚‚ â†” differentiable_on ğ•œ fâ‚‚ sâ‚‚ âˆ§ cont_diff_on ğ•œ n (deriv_within fâ‚‚ sâ‚‚) sâ‚‚ :=\n  by\n  rw [cont_diff_on_succ_iff_fderiv_within hs]\n  congr 2\n  apply le_antisymm\n  Â· intro h\n    have : deriv_within fâ‚‚ sâ‚‚ = (fun u : Â«expr â†’L[ ] Â» ğ•œ ğ•œ F => u 1) âˆ˜ fderiv_within ğ•œ fâ‚‚ sâ‚‚ :=\n      by\n      ext x\n      rfl\n    simp only [this]\n    apply cont_diff.comp_cont_diff_on _ h\n    exact (is_bounded_bilinear_map_apply.is_bounded_linear_map_left _).cont_diff\n  Â· intro h\n    have : fderiv_within ğ•œ fâ‚‚ sâ‚‚ = smul_right (1 : Â«expr â†’L[ ] Â» ğ•œ ğ•œ ğ•œ) âˆ˜ deriv_within fâ‚‚ sâ‚‚ :=\n      by\n      ext x\n      simp [deriv_within]\n    simp only [this]\n    apply cont_diff.comp_cont_diff_on _ h\n    have : is_bounded_bilinear_map ğ•œ fun _ : Â«expr â†’L[ ] Â» ğ•œ ğ•œ ğ•œ Ã— F => _ := is_bounded_bilinear_map_smul_right\n    exact (this.is_bounded_linear_map_right _).cont_diff\n#align cont_diff_on_succ_iff_deriv_within cont_diff_on_succ_iff_deriv_within\n\n",
 "cont_diff_on_succ_iff_deriv_of_open":
 "/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:73:14: unsupported tactic `congrm #[[expr Â«expr âˆ§ Â»(_, _)]] -/\n/-- A function is `C^(n + 1)` on an open domain if and only if it is\ndifferentiable there, and its derivative (formulated with `deriv`) is `C^n`. -/\ntheorem cont_diff_on_succ_iff_deriv_of_open {n : â„•} (hs : IsOpen sâ‚‚) :\n    cont_diff_on ğ•œ (n + 1 : â„•) fâ‚‚ sâ‚‚ â†” differentiable_on ğ•œ fâ‚‚ sâ‚‚ âˆ§ cont_diff_on ğ•œ n (deriv fâ‚‚) sâ‚‚ :=\n  by\n  rw [cont_diff_on_succ_iff_deriv_within hs.unique_diff_on]\n  trace\n    \"./././Mathport/Syntax/Translate/Tactic/Builtin.lean:73:14: unsupported tactic `congrm #[[expr Â«expr âˆ§ Â»(_, _)]]\"\n  exact cont_diff_on_congr fun _ => deriv_within_of_open hs\n#align cont_diff_on_succ_iff_deriv_of_open cont_diff_on_succ_iff_deriv_of_open\n\n",
 "cont_diff_on_snd":
 "/-- The second projection on a domain in a product is `C^âˆ`. -/\ntheorem cont_diff_on_snd {s : Set (E Ã— F)} : cont_diff_on ğ•œ n (Prod.snd : E Ã— F â†’ F) s :=\n  cont_diff.cont_diff_on cont_diff_snd\n#align cont_diff_on_snd cont_diff_on_snd\n\n",
 "cont_diff_on_prod'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\ntheorem cont_diff_on_prod' {t : Finset Î¹} {f : Î¹ â†’ E â†’ ğ”¸'} (h : âˆ€ i âˆˆ t, cont_diff_on ğ•œ n (f i) s) :\n    cont_diff_on ğ•œ n\n      (finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" t (f i)) s :=\n  fun x hx => cont_diff_within_at_prod' fun i hi => h i hi x hx\n#align cont_diff_on_prod' cont_diff_on_prod'\n\n",
 "cont_diff_on_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\ntheorem cont_diff_on_prod {t : Finset Î¹} {f : Î¹ â†’ E â†’ ğ”¸'} (h : âˆ€ i âˆˆ t, cont_diff_on ğ•œ n (f i) s) :\n    cont_diff_on ğ•œ n\n      (fun y =>\n        finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" t (f i y))\n      s :=\n  fun x hx => cont_diff_within_at_prod fun i hi => h i hi x hx\n#align cont_diff_on_prod cont_diff_on_prod\n\n",
 "cont_diff_on_pi":
 "theorem cont_diff_on_pi : cont_diff_on ğ•œ n Î¦ s â†” âˆ€ i, cont_diff_on ğ•œ n (fun x => Î¦ x i) s :=\n  âŸ¨fun h i x hx => cont_diff_within_at_pi.1 (h x hx) _, fun h x hx => cont_diff_within_at_pi.2 fun i => h i x hxâŸ©\n#align cont_diff_on_pi cont_diff_on_pi\n\n",
 "cont_diff_on_of_subsingleton":
 "@[nontriviality]\ntheorem cont_diff_on_of_subsingleton [subsingleton F] : cont_diff_on ğ•œ n f s :=\n  by\n  rw [subsingleton.elim f fun _ => 0]\n  exact cont_diff_on_const\n#align cont_diff_on_of_subsingleton cont_diff_on_of_subsingleton\n\n",
 "cont_diff_on_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á¶œÂ» -/\ntheorem cont_diff_on_inv {n} : cont_diff_on ğ•œ n (has_inv.inv : ğ•œ' â†’ ğ•œ') (Â«expr á¶œÂ» {0}) := fun x hx =>\n  (cont_diff_at_inv ğ•œ hx).cont_diff_within_at\n#align cont_diff_on_inv cont_diff_on_inv\n\n",
 "cont_diff_on_id":
 "theorem cont_diff_on_id {s} : cont_diff_on ğ•œ n (id : E â†’ E) s :=\n  cont_diff_id.cont_diff_on\n#align cont_diff_on_id cont_diff_on_id\n\n",
 "cont_diff_on_fst":
 "/-- The first projection on a domain in a product is `C^âˆ`. -/\ntheorem cont_diff_on_fst {s : Set (E Ã— F)} : cont_diff_on ğ•œ n (Prod.fst : E Ã— F â†’ E) s :=\n  cont_diff.cont_diff_on cont_diff_fst\n#align cont_diff_on_fst cont_diff_on_fst\n\n",
 "cont_diff_on_fderiv_within_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ„•âˆÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n/-- The bundled derivative of a `C^{n+1}` function is `C^n`. -/\ntheorem cont_diff_on_fderiv_within_apply {m n : Â«exprâ„•âˆÂ»} {s : Set E} {f : E â†’ F} (hf : cont_diff_on ğ•œ n f s)\n    (hs : unique_diff_on ğ•œ s) (hmn : m + 1 â‰¤ n) :\n    cont_diff_on ğ•œ m (fun p : E Ã— E => (fderiv_within ğ•œ f s p.1 : Â«expr â†’L[ ] Â» E ğ•œ F) p.2) (lower_set.prod s univ) :=\n  ((hf.fderiv_within hs hmn).comp cont_diff_on_fst (prod_subset_preimage_fst _ _)).clm_apply cont_diff_on_snd\n#align cont_diff_on_fderiv_within_apply cont_diff_on_fderiv_within_apply\n\n",
 "cont_diff_on_const":
 "theorem cont_diff_on_const {c : F} {s : Set E} : cont_diff_on ğ•œ n (fun x : E => c) s :=\n  cont_diff_const.cont_diff_on\n#align cont_diff_on_const cont_diff_on_const\n\n",
 "cont_diff_on_comp_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰ƒL[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/-- Composition by continuous linear equivs on the right respects higher differentiability on\ndomains. -/\ntheorem continuous_linear_equiv.cont_diff_on_comp_iff (e : Â«expr â‰ƒL[ ] Â» G ğ•œ E) :\n    cont_diff_on ğ•œ n (f âˆ˜ e) (Â«expr â»Â¹' Â» e s) â†” cont_diff_on ğ•œ n f s :=\n  by\n  refine' âŸ¨fun H => _, fun H => H.comp_continuous_linear_map (e : Â«expr â†’L[ ] Â» G ğ•œ E)âŸ©\n  have A : f = (f âˆ˜ e) âˆ˜ e.symm := by\n    ext y\n    simp only [Function.comp_apply]\n    rw [e.apply_symm_apply y]\n  have B : Â«expr â»Â¹' Â» e.symm (Â«expr â»Â¹' Â» e s) = s :=\n    by\n    rw [â† preimage_comp, e.self_comp_symm]\n    rfl\n  rw [A, â† B]\n  exact H.comp_continuous_linear_map (e.symm : Â«expr â†’L[ ] Â» E ğ•œ G)\n#align continuous_linear_equiv.cont_diff_on_comp_iff continuous_linear_equiv.cont_diff_on_comp_iff\n\n",
 "cont_diff_on_clm_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰ƒL[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ„•âˆÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/-- A family of continuous linear maps is `C^n` on `s` if all its applications are. -/\ntheorem cont_diff_on_clm_apply {n : Â«exprâ„•âˆÂ»} {f : E â†’ Â«expr â†’L[ ] Â» F ğ•œ G} {s : Set E} [FiniteDimensional ğ•œ F] :\n    cont_diff_on ğ•œ n f s â†” âˆ€ y, cont_diff_on ğ•œ n (fun x => f x y) s :=\n  by\n  refine' âŸ¨fun h y => h.clm_apply cont_diff_on_const, fun h => _âŸ©\n  let d := finrank ğ•œ F\n  have hd : d = finrank ğ•œ (Fin d â†’ ğ•œ) := (finrank_fin_fun ğ•œ).symm\n  let eâ‚ := continuous_linear_equiv.of_finrank_eq hd\n  let eâ‚‚ := (eâ‚.arrow_congr (1 : Â«expr â‰ƒL[ ] Â» G ğ•œ G)).trans (continuous_linear_equiv.pi_ring (Fin d))\n  rw [â† comp.left_id f, â† eâ‚‚.symm_comp_self]\n  exact eâ‚‚.symm.cont_diff.comp_cont_diff_on (cont_diff_on_pi.mpr fun i => h _)\n#align cont_diff_on_clm_apply cont_diff_on_clm_apply\n\n",
 "cont_diff_of_subsingleton":
 "@[nontriviality]\ntheorem cont_diff_of_subsingleton [subsingleton F] : cont_diff ğ•œ n f :=\n  by\n  rw [subsingleton.elim f fun _ => 0]\n  exact cont_diff_const\n#align cont_diff_of_subsingleton cont_diff_of_subsingleton\n\n",
 "cont_diff_neg":
 "-- The negative is smooth.\ntheorem cont_diff_neg : cont_diff ğ•œ n fun p : F => -p :=\n  is_bounded_linear_map.id.neg.cont_diff\n#align cont_diff_neg cont_diff_neg\n\n",
 "cont_diff_mul":
 "-- The product is smooth.\ntheorem cont_diff_mul : cont_diff ğ•œ n fun p : ğ”¸ Ã— ğ”¸ => p.1 * p.2 :=\n  (continuous_linear_map.mul ğ•œ ğ”¸).is_bounded_bilinear_map.cont_diff\n#align cont_diff_mul cont_diff_mul\n\n",
 "cont_diff_id":
 "/-- The identity is `C^âˆ`.\n-/\ntheorem cont_diff_id : cont_diff ğ•œ n (id : E â†’ E) :=\n  is_bounded_linear_map.id.cont_diff\n#align cont_diff_id cont_diff_id\n\n",
 "cont_diff_fst":
 "/-- The first projection in a product is `C^âˆ`. -/\ntheorem cont_diff_fst : cont_diff ğ•œ n (Prod.fst : E Ã— F â†’ E) :=\n  is_bounded_linear_map.cont_diff is_bounded_linear_map.fst\n#align cont_diff_fst cont_diff_fst\n\n",
 "cont_diff_fderiv_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/-- The bundled derivative of a `C^{n+1}` function is `C^n`. -/\ntheorem cont_diff.cont_diff_fderiv_apply {f : E â†’ F} (hf : cont_diff ğ•œ n f) (hmn : m + 1 â‰¤ n) :\n    cont_diff ğ•œ m fun p : E Ã— E => (fderiv ğ•œ f p.1 : Â«expr â†’L[ ] Â» E ğ•œ F) p.2 :=\n  by\n  rw [â† cont_diff_on_univ] at hfâŠ¢\n  rw [â† fderiv_within_univ, â† univ_prod_univ]\n  exact cont_diff_on_fderiv_within_apply hf unique_diff_on_univ hmn\n#align cont_diff.cont_diff_fderiv_apply cont_diff.cont_diff_fderiv_apply\n\n",
 "cont_diff_const_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n-- The scalar multiplication with a constant is smooth.\ntheorem cont_diff_const_smul (c : R) : cont_diff ğ•œ n fun p : F => Â«expr â€¢ Â» c p :=\n  (Â«expr â€¢ Â» c (ContinuousLinearMap.id ğ•œ F)).cont_diff\n#align cont_diff_const_smul cont_diff_const_smul\n\n",
 "cont_diff_const":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆÂ» -/\n/-- Constants are `C^âˆ`.\n-/\ntheorem cont_diff_const {c : F} : cont_diff ğ•œ n fun x : E => c :=\n  by\n  suffices h : cont_diff ğ•œ (Â«exprâˆÂ») fun x : E => c; Â· exact h.of_le le_top\n  rw [cont_diff_top_iff_fderiv]\n  refine' âŸ¨differentiable_const c, _âŸ©\n  rw [fderiv_const]\n  exact cont_diff_zero_fun\n#align cont_diff_const cont_diff_const\n\n",
 "cont_diff_comp_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰ƒL[ ] Â» -/\n/-- Composition by continuous linear equivs on the right respects higher differentiability. -/\ntheorem continuous_linear_equiv.cont_diff_comp_iff (e : Â«expr â‰ƒL[ ] Â» G ğ•œ E) :\n    cont_diff ğ•œ n (f âˆ˜ e) â†” cont_diff ğ•œ n f :=\n  by\n  rw [â† cont_diff_on_univ, â† cont_diff_on_univ, â† preimage_univ]\n  exact e.cont_diff_on_comp_iff\n#align continuous_linear_equiv.cont_diff_comp_iff continuous_linear_equiv.cont_diff_comp_iff\n\n",
 "cont_diff_clm_apply_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ„•âˆÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\ntheorem cont_diff_clm_apply_iff {n : Â«exprâ„•âˆÂ»} {f : E â†’ Â«expr â†’L[ ] Â» F ğ•œ G} [FiniteDimensional ğ•œ F] :\n    cont_diff ğ•œ n f â†” âˆ€ y, cont_diff ğ•œ n fun x => f x y := by simp_rw [â† cont_diff_on_univ, cont_diff_on_clm_apply]\n#align cont_diff_clm_apply_iff cont_diff_clm_apply_iff\n\n",
 "cont_diff_at_symm_deriv":
 "/-- Let `f` be a local homeomorphism of a nontrivially normed field, let `a` be a point in its\ntarget. if `f` is `n` times continuously differentiable at `f.symm a`, and if the derivative at\n`f.symm a` is nonzero, then `f.symm` is `n` times continuously differentiable at the point `a`.\n\nThis is one of the easy parts of the inverse function theorem: it assumes that we already have\nan inverse function. -/\ntheorem local_homeomorph.cont_diff_at_symm_deriv [CompleteSpace ğ•œ] (f : LocalHomeomorph ğ•œ ğ•œ) {fâ‚€' a : ğ•œ} (hâ‚€ : fâ‚€' â‰  0)\n    (ha : a âˆˆ f.target) (hfâ‚€' : has_deriv_at f fâ‚€' (f.symm a)) (hf : cont_diff_at ğ•œ n f (f.symm a)) :\n    cont_diff_at ğ•œ n f.symm a :=\n  f.cont_diff_at_symm ha (hfâ‚€'.has_fderiv_at_equiv hâ‚€) hf\n#align local_homeomorph.cont_diff_at_symm_deriv local_homeomorph.cont_diff_at_symm_deriv\n\n",
 "cont_diff_at_symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰ƒL[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰ƒL[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/-- If `f` is a local homeomorphism and the point `a` is in its target,\nand if `f` is `n` times continuously differentiable at `f.symm a`,\nand if the derivative at `f.symm a` is a continuous linear equivalence,\nthen `f.symm` is `n` times continuously differentiable at the point `a`.\n\nThis is one of the easy parts of the inverse function theorem: it assumes that we already have\nan inverse function. -/\ntheorem local_homeomorph.cont_diff_at_symm [CompleteSpace E] (f : LocalHomeomorph E F) {fâ‚€' : Â«expr â‰ƒL[ ] Â» E ğ•œ F}\n    {a : F} (ha : a âˆˆ f.target) (hfâ‚€' : has_fderiv_at f (fâ‚€' : Â«expr â†’L[ ] Â» E ğ•œ F) (f.symm a))\n    (hf : cont_diff_at ğ•œ n f (f.symm a)) : cont_diff_at ğ•œ n f.symm a :=\n  by\n  -- We prove this by induction on `n`\n  induction' n using ENat.nat_induction with n IH Itop\n  Â· rw [cont_diff_at_zero]\n    exact âŸ¨f.target, IsOpen.mem_nhds f.open_target ha, f.continuous_inv_funâŸ©\n  Â· obtain âŸ¨f', âŸ¨u, hu, hff'âŸ©, hf'âŸ© := cont_diff_at_succ_iff_has_fderiv_at.mp hf\n    apply cont_diff_at_succ_iff_has_fderiv_at.mpr\n    -- For showing `n.succ` times continuous differentiability (the main inductive step), it\n    -- suffices to produce the derivative and show that it is `n` times continuously differentiable\n    have eq_fâ‚€' : f' (f.symm a) = fâ‚€' := (hff' (f.symm a) (mem_of_mem_nhds hu)).unique hfâ‚€'\n    -- This follows by a bootstrapping formula expressing the derivative as a function of `f` itself\n    refine' âŸ¨inverse âˆ˜ f' âˆ˜ f.symm, _, _âŸ©\n    Â· -- We first check that the derivative of `f` is that formula\n      have h_nhds : { y : E | âˆƒ e : Â«expr â‰ƒL[ ] Â» E ğ•œ F, â†‘e = f' y } âˆˆ (nhds) (f.symm a) :=\n        by\n        have hfâ‚€' := fâ‚€'.nhds\n        rw [â† eq_fâ‚€'] at hfâ‚€'\n        exact hf'.continuous_at.preimage_mem_nhds hfâ‚€'\n      obtain âŸ¨t, htu, ht, htfâŸ© := mem_nhds_iff.mp (Filter.inter_mem hu h_nhds)\n      use f.target âˆ© Â«expr â»Â¹' Â» f.symm t\n      refine' âŸ¨IsOpen.mem_nhds _ _, _âŸ©\n      Â· exact f.preimage_open_of_open_symm ht\n      Â· exact mem_inter ha (mem_preimage.mpr htf)\n      intro x hx\n      obtain âŸ¨hxu, e, heâŸ© := htu hx.2\n      have h_deriv : has_fderiv_at f (â†‘e) (f.symm x) := by\n        rw [he]\n        exact hff' (f.symm x) hxu\n      convert f.has_fderiv_at_symm hx.1 h_deriv\n      simp [â† he]\n    Â· -- Then we check that the formula, being a composition of `cont_diff` pieces, is\n      -- itself `cont_diff`\n      have h_derivâ‚ : cont_diff_at ğ•œ n inverse (f' (f.symm a)) :=\n        by\n        rw [eq_fâ‚€']\n        exact cont_diff_at_map_inverse _\n      have h_derivâ‚‚ : cont_diff_at ğ•œ n f.symm a := by\n        refine' IH (hf.of_le _)\n        norm_cast\n        exact nat.le_succ n\n      exact (h_derivâ‚.comp _ hf').comp _ h_derivâ‚‚\n  Â· refine' cont_diff_at_top.mpr _\n    intro n\n    exact Itop n (cont_diff_at_top.mp hf n)\n#align local_homeomorph.cont_diff_at_symm local_homeomorph.cont_diff_at_symm\n\n",
 "cont_diff_at_snd":
 "/-- The second projection at a point in a product is `C^âˆ`. -/\ntheorem cont_diff_at_snd {p : E Ã— F} : cont_diff_at ğ•œ n (Prod.snd : E Ã— F â†’ F) p :=\n  cont_diff_snd.cont_diff_at\n#align cont_diff_at_snd cont_diff_at_snd\n\n",
 "cont_diff_at_ring_inverse":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr Ë£Â» -/\n/-- In a complete normed algebra, the operation of inversion is `C^n`, for all `n`, at each\ninvertible element.  The proof is by induction, bootstrapping using an identity expressing the\nderivative of inversion as a bilinear map of inversion itself. -/\ntheorem cont_diff_at_ring_inverse [CompleteSpace R] (x : Â«expr Ë£Â» R) : cont_diff_at ğ•œ n Ring.inverse (x : R) :=\n  by\n  induction' n using ENat.nat_induction with n IH Itop\n  Â· intro m hm\n    refine' âŸ¨{ y : R | IsUnit y }, _, _âŸ©\n    Â· simp [nhdsWithin_univ]\n      exact x.nhds\n    Â· use ftaylor_series_within ğ•œ inverse univ\n      rw [le_antisymm hm bot_le, has_ftaylor_series_up_to_on_zero_iff]\n      constructor\n      Â· rintro _ âŸ¨x', rflâŸ©\n        exact (inverse_continuous_at x').continuous_within_at\n      Â· simp [ftaylor_series_within]\n  Â· apply cont_diff_at_succ_iff_has_fderiv_at.mpr\n    refine' âŸ¨fun x : R => -mul_left_right ğ•œ R (inverse x) (inverse x), _, _âŸ©\n    Â· refine' âŸ¨{ y : R | IsUnit y }, x.nhds, _âŸ©\n      rintro _ âŸ¨y, rflâŸ©\n      rw [inverse_unit]\n      exact has_fderiv_at_ring_inverse y\n    Â· convert(mul_left_right_is_bounded_bilinear ğ•œ R).cont_diff.neg.comp_cont_diff_at (x : R) (IH.prod IH)\n  Â· exact cont_diff_at_top.mpr Itop\n#align cont_diff_at_ring_inverse cont_diff_at_ring_inverse\n\n",
 "cont_diff_at_prod'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\ntheorem cont_diff_at_prod' {t : Finset Î¹} {f : Î¹ â†’ E â†’ ğ”¸'} (h : âˆ€ i âˆˆ t, cont_diff_at ğ•œ n (f i) x) :\n    cont_diff_at ğ•œ n\n      (finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" t (f i)) x :=\n  cont_diff_within_at_prod' h\n#align cont_diff_at_prod' cont_diff_at_prod'\n\n",
 "cont_diff_at_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\ntheorem cont_diff_at_prod {t : Finset Î¹} {f : Î¹ â†’ E â†’ ğ”¸'} (h : âˆ€ i âˆˆ t, cont_diff_at ğ•œ n (f i) x) :\n    cont_diff_at ğ•œ n\n      (fun y =>\n        finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" t (f i y))\n      x :=\n  cont_diff_within_at_prod h\n#align cont_diff_at_prod cont_diff_at_prod\n\n",
 "cont_diff_at_pi":
 "theorem cont_diff_at_pi : cont_diff_at ğ•œ n Î¦ x â†” âˆ€ i, cont_diff_at ğ•œ n (fun x => Î¦ x i) x :=\n  cont_diff_within_at_pi\n#align cont_diff_at_pi cont_diff_at_pi\n\n",
 "cont_diff_at_of_subsingleton":
 "@[nontriviality]\ntheorem cont_diff_at_of_subsingleton [subsingleton F] : cont_diff_at ğ•œ n f x :=\n  by\n  rw [subsingleton.elim f fun _ => 0]\n  exact cont_diff_at_const\n#align cont_diff_at_of_subsingleton cont_diff_at_of_subsingleton\n\n",
 "cont_diff_at_map_inverse":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr Ë£Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰ƒL[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/-- At a continuous linear equivalence `e : E â‰ƒL[ğ•œ] F` between Banach spaces, the operation of\ninversion is `C^n`, for all `n`. -/\ntheorem cont_diff_at_map_inverse [CompleteSpace E] (e : Â«expr â‰ƒL[ ] Â» E ğ•œ F) :\n    cont_diff_at ğ•œ n inverse (e : Â«expr â†’L[ ] Â» E ğ•œ F) :=\n  by\n  nontriviality E\n  -- first, we use the lemma `to_ring_inverse` to rewrite in terms of `ring.inverse` in the ring\n  -- `E â†’L[ğ•œ] E`\n  let Oâ‚ : Â«expr â†’L[ ] Â» E ğ•œ E â†’ Â«expr â†’L[ ] Â» F ğ•œ E := fun f => f.comp (e.symm : Â«expr â†’L[ ] Â» F ğ•œ E)\n  let Oâ‚‚ : Â«expr â†’L[ ] Â» E ğ•œ F â†’ Â«expr â†’L[ ] Â» E ğ•œ E := fun f => (e.symm : Â«expr â†’L[ ] Â» F ğ•œ E).comp f\n  have : ContinuousLinearMap.inverse = Oâ‚ âˆ˜ Ring.inverse âˆ˜ Oâ‚‚ := funext (to_ring_inverse e)\n  rw [this]\n  -- `Oâ‚` and `Oâ‚‚` are `cont_diff`,\n  -- so we reduce to proving that `ring.inverse` is `cont_diff`\n  have hâ‚ : cont_diff ğ•œ n Oâ‚ := cont_diff_id.clm_comp cont_diff_const\n  have hâ‚‚ : cont_diff ğ•œ n Oâ‚‚ := cont_diff_const.clm_comp cont_diff_id\n  refine' hâ‚.cont_diff_at.comp _ (cont_diff_at.comp _ _ hâ‚‚.cont_diff_at)\n  convert cont_diff_at_ring_inverse ğ•œ (1 : Â«expr Ë£Â» (Â«expr â†’L[ ] Â» E ğ•œ E))\n  simp [Oâ‚‚, one_def]\n#align cont_diff_at_map_inverse cont_diff_at_map_inverse\n\n",
 "cont_diff_at_inv":
 "theorem cont_diff_at_inv {x : ğ•œ'} (hx : x â‰  0) {n} : cont_diff_at ğ•œ n has_inv.inv x := by\n  simpa only [Ring.inverse_eq_inv'] using cont_diff_at_ring_inverse ğ•œ (Units.mk0 x hx)\n#align cont_diff_at_inv cont_diff_at_inv\n\n",
 "cont_diff_at_id":
 "theorem cont_diff_at_id {x} : cont_diff_at ğ•œ n (id : E â†’ E) x :=\n  cont_diff_id.cont_diff_at\n#align cont_diff_at_id cont_diff_at_id\n\n",
 "cont_diff_at_fst":
 "/-- The first projection at a point in a product is `C^âˆ`. -/\ntheorem cont_diff_at_fst {p : E Ã— F} : cont_diff_at ğ•œ n (Prod.fst : E Ã— F â†’ E) p :=\n  cont_diff_fst.cont_diff_at\n#align cont_diff_at_fst cont_diff_at_fst\n\n",
 "cont_diff_at_const":
 "theorem cont_diff_at_const {c : F} : cont_diff_at ğ•œ n (fun x : E => c) x :=\n  cont_diff_const.cont_diff_at\n#align cont_diff_at_const cont_diff_at_const\n\n",
 "cont_diff_at_comp_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰ƒL[ ] Â» -/\n/-- Composition by continuous linear equivs on the right respects higher differentiability at a\npoint. -/\ntheorem continuous_linear_equiv.cont_diff_at_comp_iff (e : Â«expr â‰ƒL[ ] Â» G ğ•œ E) :\n    cont_diff_at ğ•œ n (f âˆ˜ e) (e.symm x) â†” cont_diff_at ğ•œ n f x :=\n  by\n  rw [â† cont_diff_within_at_univ, â† cont_diff_within_at_univ, â† preimage_univ]\n  exact e.cont_diff_within_at_comp_iff\n#align continuous_linear_equiv.cont_diff_at_comp_iff continuous_linear_equiv.cont_diff_at_comp_iff\n\n",
 "cont_diff_apply_apply":
 "theorem cont_diff_apply_apply (i : Î¹) (j : Î¹') : cont_diff ğ•œ n fun f : Î¹ â†’ Î¹' â†’ E => f i j :=\n  cont_diff_pi.mp (cont_diff_apply ğ•œ (Î¹' â†’ E) i) j\n#align cont_diff_apply_apply cont_diff_apply_apply\n\n",
 "cont_diff_apply":
 "theorem cont_diff_apply (i : Î¹) : cont_diff ğ•œ n fun f : Î¹ â†’ E => f i :=\n  cont_diff_pi.mp cont_diff_id i\n#align cont_diff_apply cont_diff_apply\n\n",
 "cont_diff_add":
 "-- The sum is smooth.\ntheorem cont_diff_add : cont_diff ğ•œ n fun p : F Ã— F => p.1 + p.2 :=\n  (is_bounded_linear_map.fst.add is_bounded_linear_map.snd).cont_diff\n#align cont_diff_add cont_diff_add\n\n",
 "cont_diff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆÂ» -/\n/-- Bilinear functions are `C^âˆ`.\n-/\ntheorem is_bounded_bilinear_map.cont_diff (hb : is_bounded_bilinear_map ğ•œ b) : cont_diff ğ•œ n b :=\n  by\n  suffices h : cont_diff ğ•œ (Â«exprâˆÂ») b; Â· exact h.of_le le_top\n  rw [cont_diff_top_iff_fderiv]\n  refine' âŸ¨hb.differentiable, _âŸ©\n  simp [hb.fderiv]\n  exact hb.is_bounded_linear_map_deriv.cont_diff\n#align is_bounded_bilinear_map.cont_diff is_bounded_bilinear_map.cont_diff\n\n",
 "const_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/-- The scalar multiplication of a constant and a `C^n` on a domain is `C^n`. -/\ntheorem cont_diff_on.const_smul {s : Set E} {f : E â†’ F} (c : R) (hf : cont_diff_on ğ•œ n f s) :\n    cont_diff_on ğ•œ n (fun y => Â«expr â€¢ Â» c (f y)) s := fun x hx => (hf x hx).const_smul c\n#align cont_diff_on.const_smul cont_diff_on.const_smul\n\n",
 "compâ‚ƒ":
 "theorem cont_diff.compâ‚ƒ {g : Eâ‚ Ã— Eâ‚‚ Ã— Eâ‚ƒ â†’ G} {fâ‚ : F â†’ Eâ‚} {fâ‚‚ : F â†’ Eâ‚‚} {fâ‚ƒ : F â†’ Eâ‚ƒ} (hg : cont_diff ğ•œ n g)\n    (hfâ‚ : cont_diff ğ•œ n fâ‚) (hfâ‚‚ : cont_diff ğ•œ n fâ‚‚) (hfâ‚ƒ : cont_diff ğ•œ n fâ‚ƒ) :\n    cont_diff ğ•œ n fun x => g (fâ‚ x, fâ‚‚ x, fâ‚ƒ x) :=\n  hg.compâ‚‚ hfâ‚ <| hfâ‚‚.prod hfâ‚ƒ\n#align cont_diff.compâ‚ƒ cont_diff.compâ‚ƒ\n\n",
 "compâ‚‚":
 "theorem cont_diff.compâ‚‚ {g : Eâ‚ Ã— Eâ‚‚ â†’ G} {fâ‚ : F â†’ Eâ‚} {fâ‚‚ : F â†’ Eâ‚‚} (hg : cont_diff ğ•œ n g) (hfâ‚ : cont_diff ğ•œ n fâ‚)\n    (hfâ‚‚ : cont_diff ğ•œ n fâ‚‚) : cont_diff ğ•œ n fun x => g (fâ‚ x, fâ‚‚ x) :=\n  hg.comp <| hfâ‚.prod hfâ‚‚\n#align cont_diff.compâ‚‚ cont_diff.compâ‚‚\n\n",
 "comp_same_univ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/-- Auxiliary lemma proving that the composition of `C^n` functions on domains is `C^n` when all\nspaces live in the same universe. Use instead `cont_diff_on.comp` which removes the universe\nassumption (but is deduced from this one). -/\nprivate theorem cont_diff_on.comp_same_univ {Eu : Type u} [NormedAddCommGroup Eu] [NormedSpace ğ•œ Eu] {Fu : Type u}\n    [NormedAddCommGroup Fu] [NormedSpace ğ•œ Fu] {Gu : Type u} [NormedAddCommGroup Gu] [NormedSpace ğ•œ Gu] {s : Set Eu}\n    {t : Set Fu} {g : Fu â†’ Gu} {f : Eu â†’ Fu} (hg : cont_diff_on ğ•œ n g t) (hf : cont_diff_on ğ•œ n f s)\n    (st : s âŠ† Â«expr â»Â¹' Â» f t) : cont_diff_on ğ•œ n (g âˆ˜ f) s :=\n  by\n  induction' n using ENat.nat_induction with n IH Itop generalizing Eu Fu Gu\n  Â· rw [cont_diff_on_zero] at hf hgâŠ¢\n    exact ContinuousOn.comp hg hf st\n  Â· rw [cont_diff_on_succ_iff_has_fderiv_within_at] at hgâŠ¢\n    intro x hx\n    rcases(cont_diff_on_succ_iff_has_fderiv_within_at.1 hf) x hx with âŸ¨u, hu, f', hf', f'_diffâŸ©\n    rcases hg (f x) (st hx) with âŸ¨v, hv, g', hg', g'_diffâŸ©\n    rw [insert_eq_of_mem hx] at huâŠ¢\n    have xu : x âˆˆ u := mem_of_mem_nhdsWithin hx hu\n    let w := s âˆ© (u âˆ© Â«expr â»Â¹' Â» f v)\n    have wv : w âŠ† Â«expr â»Â¹' Â» f v := fun y hy => hy.2.2\n    have wu : w âŠ† u := fun y hy => hy.2.1\n    have ws : w âŠ† s := fun y hy => hy.1\n    refine' âŸ¨w, _, fun y => (g' (f y)).comp (f' y), _, _âŸ©\n    show w âˆˆ nhds_within s x\n    Â· apply Filter.inter_mem self_mem_nhdsWithin\n      apply Filter.inter_mem hu\n      apply ContinuousWithinAt.preimage_mem_nhds_within'\n      Â· rw [â† continuousWithinAt_inter' hu]\n        exact (hf' x xu).differentiable_within_at.continuous_within_at.mono (inter_subset_right _ _)\n      Â· apply nhdsWithin_mono _ _ hv\n        exact subset.trans (image_subset_iff.mpr st) (subset_insert (f x) t)\n    show âˆ€ y âˆˆ w, has_fderiv_within_at (g âˆ˜ f) ((g' (f y)).comp (f' y)) w y\n    Â· rintro y âŸ¨ys, yu, yvâŸ©\n      exact (hg' (f y) yv).comp y ((hf' y yu).mono wu) wv\n    show cont_diff_on ğ•œ n (fun y => (g' (f y)).comp (f' y)) w\n    Â· have A : cont_diff_on ğ•œ n (fun y => g' (f y)) w :=\n        IH g'_diff ((hf.of_le (WithTop.coe_le_coe.2 (nat.le_succ n))).mono ws) wv\n      have B : cont_diff_on ğ•œ n f' w := f'_diff.mono wu\n      have C : cont_diff_on ğ•œ n (fun y => (g' (f y), f' y)) w := A.prod B\n      have D : cont_diff_on ğ•œ n (fun p : Â«expr â†’L[ ] Â» Fu ğ•œ Gu Ã— Â«expr â†’L[ ] Â» Eu ğ•œ Fu => p.1.comp p.2) univ :=\n        is_bounded_bilinear_map_comp.cont_diff.cont_diff_on\n      exact IH D C (subset_univ _)\n  Â· rw [cont_diff_on_top] at hf hgâŠ¢\n    exact fun n => Itop n (hg n) (hf n) st\n#align cont_diff_on.comp_same_univ cont_diff_on.comp_same_univ\n\n",
 "comp_of_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/-- The composition of `C^n` functions at points in domains is `C^n`,\n  with a weaker condition on `s` and `t`. -/\ntheorem cont_diff_within_at.comp_of_mem {s : Set E} {t : Set F} {g : F â†’ G} {f : E â†’ F} (x : E)\n    (hg : cont_diff_within_at ğ•œ n g t (f x)) (hf : cont_diff_within_at ğ•œ n f s x)\n    (hs : t âˆˆ nhds_within (Â«expr '' Â» f s) (f x)) : cont_diff_within_at ğ•œ n (g âˆ˜ f) s x :=\n  (hg.mono_of_mem hs).comp x hf (subset_preimage_image f s)\n#align cont_diff_within_at.comp_of_mem cont_diff_within_at.comp_of_mem\n\n",
 "comp_continuous_linear_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/-- Composition by continuous linear maps on the right preserves `C^n` functions. -/\ntheorem cont_diff.comp_continuous_linear_map {f : E â†’ F} {g : Â«expr â†’L[ ] Â» G ğ•œ E} (hf : cont_diff ğ•œ n f) :\n    cont_diff ğ•œ n (f âˆ˜ g) :=\n  cont_diff_on_univ.1 <| cont_diff_on.comp_continuous_linear_map (cont_diff_on_univ.2 hf) _\n#align cont_diff.comp_continuous_linear_map cont_diff.comp_continuous_linear_map\n\n",
 "comp_cont_diff_within_at_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰ƒL[ ] Â» -/\n/-- Composition by continuous linear equivs on the left respects higher differentiability at a\npoint in a domain. -/\ntheorem continuous_linear_equiv.comp_cont_diff_within_at_iff (e : Â«expr â‰ƒL[ ] Â» F ğ•œ G) :\n    cont_diff_within_at ğ•œ n (e âˆ˜ f) s x â†” cont_diff_within_at ğ•œ n f s x :=\n  âŸ¨fun H => by\n    simpa only [(Â· âˆ˜ Â·), e.symm.coe_coe, e.symm_apply_apply] using\n      H.continuous_linear_map_comp (e.symm : Â«expr â†’L[ ] Â» G ğ•œ F),\n    fun H => H.continuous_linear_map_comp (e : Â«expr â†’L[ ] Â» F ğ•œ G)âŸ©\n#align continuous_linear_equiv.comp_cont_diff_within_at_iff continuous_linear_equiv.comp_cont_diff_within_at_iff\n\n",
 "comp_cont_diff_within_at":
 "theorem cont_diff.comp_cont_diff_within_at {g : F â†’ G} {f : E â†’ F} (h : cont_diff ğ•œ n g)\n    (hf : cont_diff_within_at ğ•œ n f t x) : cont_diff_within_at ğ•œ n (g âˆ˜ f) t x :=\n  haveI : cont_diff_within_at ğ•œ n g univ (f x) := h.cont_diff_at.cont_diff_within_at\n  this.comp x hf (subset_univ _)\n#align cont_diff.comp_cont_diff_within_at cont_diff.comp_cont_diff_within_at\n\n",
 "comp_cont_diff_onâ‚ƒ":
 "theorem cont_diff.comp_cont_diff_onâ‚ƒ {g : Eâ‚ Ã— Eâ‚‚ Ã— Eâ‚ƒ â†’ G} {fâ‚ : F â†’ Eâ‚} {fâ‚‚ : F â†’ Eâ‚‚} {fâ‚ƒ : F â†’ Eâ‚ƒ} {s : Set F}\n    (hg : cont_diff ğ•œ n g) (hfâ‚ : cont_diff_on ğ•œ n fâ‚ s) (hfâ‚‚ : cont_diff_on ğ•œ n fâ‚‚ s) (hfâ‚ƒ : cont_diff_on ğ•œ n fâ‚ƒ s) :\n    cont_diff_on ğ•œ n (fun x => g (fâ‚ x, fâ‚‚ x, fâ‚ƒ x)) s :=\n  hg.comp_cont_diff_onâ‚‚ hfâ‚ <| hfâ‚‚.prod hfâ‚ƒ\n#align cont_diff.comp_cont_diff_onâ‚ƒ cont_diff.comp_cont_diff_onâ‚ƒ\n\n",
 "comp_cont_diff_onâ‚‚":
 "theorem cont_diff.comp_cont_diff_onâ‚‚ {g : Eâ‚ Ã— Eâ‚‚ â†’ G} {fâ‚ : F â†’ Eâ‚} {fâ‚‚ : F â†’ Eâ‚‚} {s : Set F} (hg : cont_diff ğ•œ n g)\n    (hfâ‚ : cont_diff_on ğ•œ n fâ‚ s) (hfâ‚‚ : cont_diff_on ğ•œ n fâ‚‚ s) : cont_diff_on ğ•œ n (fun x => g (fâ‚ x, fâ‚‚ x)) s :=\n  hg.comp_cont_diff_on <| hfâ‚.prod hfâ‚‚\n#align cont_diff.comp_cont_diff_onâ‚‚ cont_diff.comp_cont_diff_onâ‚‚\n\n",
 "comp_cont_diff_on_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰ƒL[ ] Â» -/\n/-- Composition by continuous linear equivs on the left respects higher differentiability on\ndomains. -/\ntheorem continuous_linear_equiv.comp_cont_diff_on_iff (e : Â«expr â‰ƒL[ ] Â» F ğ•œ G) :\n    cont_diff_on ğ•œ n (e âˆ˜ f) s â†” cont_diff_on ğ•œ n f s := by simp [cont_diff_on, e.comp_cont_diff_within_at_iff]\n#align continuous_linear_equiv.comp_cont_diff_on_iff continuous_linear_equiv.comp_cont_diff_on_iff\n\n",
 "comp_cont_diff_on":
 "/-- The composition of a `C^n` function on a domain with a `C^n` function is `C^n`. -/\ntheorem cont_diff.comp_cont_diff_on {s : Set E} {g : F â†’ G} {f : E â†’ F} (hg : cont_diff ğ•œ n g)\n    (hf : cont_diff_on ğ•œ n f s) : cont_diff_on ğ•œ n (g âˆ˜ f) s :=\n  (cont_diff_on_univ.2 hg).comp hf subset_preimage_univ\n#align cont_diff.comp_cont_diff_on cont_diff.comp_cont_diff_on\n\n",
 "comp_cont_diff_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰ƒL[ ] Â» -/\n/-- Composition by continuous linear equivs on the left respects higher differentiability. -/\ntheorem continuous_linear_equiv.comp_cont_diff_iff (e : Â«expr â‰ƒL[ ] Â» F ğ•œ G) :\n    cont_diff ğ•œ n (e âˆ˜ f) â†” cont_diff ğ•œ n f := by simp only [â† cont_diff_on_univ, e.comp_cont_diff_on_iff]\n#align continuous_linear_equiv.comp_cont_diff_iff continuous_linear_equiv.comp_cont_diff_iff\n\n",
 "comp_cont_diff_at_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰ƒL[ ] Â» -/\n/-- Composition by continuous linear equivs on the left respects higher differentiability at a\npoint. -/\ntheorem continuous_linear_equiv.comp_cont_diff_at_iff (e : Â«expr â‰ƒL[ ] Â» F ğ•œ G) :\n    cont_diff_at ğ•œ n (e âˆ˜ f) x â†” cont_diff_at ğ•œ n f x := by\n  simp only [â† cont_diff_within_at_univ, e.comp_cont_diff_within_at_iff]\n#align continuous_linear_equiv.comp_cont_diff_at_iff continuous_linear_equiv.comp_cont_diff_at_iff\n\n",
 "comp_cont_diff_at":
 "theorem cont_diff.comp_cont_diff_at {g : F â†’ G} {f : E â†’ F} (x : E) (hg : cont_diff ğ•œ n g) (hf : cont_diff_at ğ•œ n f x) :\n    cont_diff_at ğ•œ n (g âˆ˜ f) x :=\n  hg.comp_cont_diff_within_at hf\n#align cont_diff.comp_cont_diff_at cont_diff.comp_cont_diff_at\n\n",
 "comp'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/-- The composition of `C^n` functions at points in domains is `C^n`. -/\ntheorem cont_diff_within_at.comp' {s : Set E} {t : Set F} {g : F â†’ G} {f : E â†’ F} (x : E)\n    (hg : cont_diff_within_at ğ•œ n g t (f x)) (hf : cont_diff_within_at ğ•œ n f s x) :\n    cont_diff_within_at ğ•œ n (g âˆ˜ f) (s âˆ© Â«expr â»Â¹' Â» f t) x :=\n  hg.comp x (hf.mono (inter_subset_left _ _)) (inter_subset_right _ _)\n#align cont_diff_within_at.comp' cont_diff_within_at.comp'\n\n",
 "comp":
 "/-- The composition of `C^n` functions at points is `C^n`. -/\ntheorem cont_diff_at.comp (x : E) (hg : cont_diff_at ğ•œ n g (f x)) (hf : cont_diff_at ğ•œ n f x) :\n    cont_diff_at ğ•œ n (g âˆ˜ f) x :=\n  hg.comp x hf subset_preimage_univ\n#align cont_diff_at.comp cont_diff_at.comp\n\n",
 "clm_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\ntheorem cont_diff_on.clm_comp {g : X â†’ Â«expr â†’L[ ] Â» F ğ•œ G} {f : X â†’ Â«expr â†’L[ ] Â» E ğ•œ F} {s : Set X}\n    (hg : cont_diff_on ğ•œ n g s) (hf : cont_diff_on ğ•œ n f s) : cont_diff_on ğ•œ n (fun x => (g x).comp (f x)) s :=\n  is_bounded_bilinear_map_comp.cont_diff.comp_cont_diff_onâ‚‚ hg hf\n#align cont_diff_on.clm_comp cont_diff_on.clm_comp\n\n",
 "clm_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ„•âˆÂ» -/\ntheorem cont_diff_on.clm_apply {f : E â†’ Â«expr â†’L[ ] Â» F ğ•œ G} {g : E â†’ F} {n : Â«exprâ„•âˆÂ»} (hf : cont_diff_on ğ•œ n f s)\n    (hg : cont_diff_on ğ•œ n g s) : cont_diff_on ğ•œ n (fun x => (f x) (g x)) s :=\n  is_bounded_bilinear_map_apply.cont_diff.comp_cont_diff_onâ‚‚ hf hg\n#align cont_diff_on.clm_apply cont_diff_on.clm_apply\n\n",
 "add":
 "/-- The sum of two `C^n` functions on a domain is `C^n`. -/\ntheorem cont_diff_on.add {s : Set E} {f g : E â†’ F} (hf : cont_diff_on ğ•œ n f s) (hg : cont_diff_on ğ•œ n g s) :\n    cont_diff_on ğ•œ n (fun x => f x + g x) s := fun x hx => (hf x hx).add (hg x hx)\n#align cont_diff_on.add cont_diff_on.add\n\n"}