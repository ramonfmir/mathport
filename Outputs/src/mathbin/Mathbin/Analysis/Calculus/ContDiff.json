{"zero_eq'":
 "theorem has_ftaylor_series_up_to.zero_eq' (h : has_ftaylor_series_up_to n f p) (x : E) :\n    p x 0 = (continuous_multilinear_curry_fin0 𝕜 E F).symm (f x) :=\n  by\n  rw [← h.zero_eq x]\n  symm\n  exact continuous_multilinear_map.uncurry0_curry0 _\n#align has_ftaylor_series_up_to.zero_eq' has_ftaylor_series_up_to.zero_eq'\n\n",
 "sum":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem cont_diff.sum {ι : Type _} {f : ι → E → F} {s : Finset ι} (h : ∀ i ∈ s, cont_diff 𝕜 n fun x => f i x) :\n    cont_diff 𝕜 n fun x =>\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s (f i x) :=\n  by simp only [← cont_diff_on_univ] at * <;> exact cont_diff_on.sum h\n#align cont_diff.sum cont_diff.sum\n\n",
 "sub":
 "/-- The difference of two `C^n` functions is `C^n`. -/\ntheorem cont_diff.sub {f g : E → F} (hf : cont_diff 𝕜 n f) (hg : cont_diff 𝕜 n g) : cont_diff 𝕜 n fun x => f x - g x :=\n  by simpa only [sub_eq_add_neg] using hf.add hg.neg\n#align cont_diff.sub cont_diff.sub\n\n",
 "snd''":
 "/-- Precomposing `f` with `prod.snd` is `C^n` at `x : E × F` -/\ntheorem cont_diff_at.snd'' {f : F → G} {x : E × F} (hf : cont_diff_at 𝕜 n f x.2) :\n    cont_diff_at 𝕜 n (fun x : E × F => f x.2) x :=\n  hf.comp x cont_diff_at_snd\n#align cont_diff_at.snd'' cont_diff_at.snd''\n\n",
 "snd'":
 "/-- Precomposing `f` with `prod.snd` is `C^n` at `(x, y)` -/\ntheorem cont_diff_at.snd' {f : F → G} {x : E} {y : F} (hf : cont_diff_at 𝕜 n f y) :\n    cont_diff_at 𝕜 n (fun x : E × F => f x.2) (x, y) :=\n  cont_diff_at.comp (x, y) hf cont_diff_at_snd\n#align cont_diff_at.snd' cont_diff_at.snd'\n\n",
 "snd":
 "/-- Postcomposing `f` with `prod.snd` is `C^n` at `x` -/\ntheorem cont_diff_at.snd {f : E → F × G} {x : E} (hf : cont_diff_at 𝕜 n f x) : cont_diff_at 𝕜 n (fun x => (f x).2) x :=\n  cont_diff_at_snd.comp x hf\n#align cont_diff_at.snd cont_diff_at.snd\n\n",
 "smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- The scalar multiplication of two `C^n` functions on a domain is `C^n`. -/\ntheorem cont_diff_on.smul {s : set E} {f : E → 𝕜} {g : E → F} (hf : cont_diff_on 𝕜 n f s) (hg : cont_diff_on 𝕜 n g s) :\n    cont_diff_on 𝕜 n (fun x => «expr • » (f x) (g x)) s := fun x hx => (hf x hx).smul (hg x hx)\n#align cont_diff_on.smul cont_diff_on.smul\n\n",
 "restrict_scalars":
 "theorem cont_diff.restrict_scalars (h : cont_diff 𝕜' n f) : cont_diff 𝕜 n f :=\n  cont_diff_iff_cont_diff_at.2 fun x => h.cont_diff_at.restrict_scalars _\n#align cont_diff.restrict_scalars cont_diff.restrict_scalars\n\n",
 "prod_map'":
 "/-- The product map of two `C^n` functions within a set at a point is `C^n`\nwithin the product set at the product point. -/\ntheorem cont_diff_at.prod_map' {f : E → F} {g : E' → F'} {p : E × E'} (hf : cont_diff_at 𝕜 n f p.1)\n    (hg : cont_diff_at 𝕜 n g p.2) : cont_diff_at 𝕜 n (prod.map f g) p :=\n  by\n  rcases p with ⟨⟩\n  exact cont_diff_at.prod_map hf hg\n#align cont_diff_at.prod_map' cont_diff_at.prod_map'\n\n",
 "prod_map":
 "/-- The product map of two `C^n` functions is `C^n`. -/\ntheorem cont_diff.prod_map {f : E → F} {g : E' → F'} (hf : cont_diff 𝕜 n f) (hg : cont_diff 𝕜 n g) :\n    cont_diff 𝕜 n (prod.map f g) := by\n  rw [cont_diff_iff_cont_diff_at] at *\n  exact fun ⟨x, y⟩ => (hf x).prod_map (hg y)\n#align cont_diff.prod_map cont_diff.prod_map\n\n",
 "prod":
 "/-- The cartesian product of `C^n` functions is `C^n`.-/\ntheorem cont_diff.prod {f : E → F} {g : E → G} (hf : cont_diff 𝕜 n f) (hg : cont_diff 𝕜 n g) :\n    cont_diff 𝕜 n fun x : E => (f x, g x) :=\n  cont_diff_on_univ.1 <| cont_diff_on.prod (cont_diff_on_univ.2 hf) (cont_diff_on_univ.2 hg)\n#align cont_diff.prod cont_diff.prod\n\n",
 "pow":
 "theorem cont_diff_on.pow {f : E → 𝔸} (hf : cont_diff_on 𝕜 n f s) (m : ℕ) : cont_diff_on 𝕜 n (fun y => f y ^ m) s :=\n  fun y hy => (hf y hy).pow m\n#align cont_diff_on.pow cont_diff_on.pow\n\n",
 "one_of_succ":
 "theorem cont_diff.one_of_succ {n : ℕ} (h : cont_diff 𝕜 (n + 1) f) : cont_diff 𝕜 1 f :=\n  h.of_le <| WithTop.coe_le_coe.mpr le_add_self\n#align cont_diff.one_of_succ cont_diff.one_of_succ\n\n",
 "of_succ":
 "theorem cont_diff.of_succ {n : ℕ} (h : cont_diff 𝕜 (n + 1) f) : cont_diff 𝕜 n f :=\n  h.of_le <| WithTop.coe_le_coe.mpr le_self_add\n#align cont_diff.of_succ cont_diff.of_succ\n\n",
 "of_le":
 "theorem cont_diff.of_le (h : cont_diff 𝕜 n f) (hmn : m ≤ n) : cont_diff 𝕜 m f :=\n  cont_diff_on_univ.1 <| (cont_diff_on_univ.2 h).of_le hmn\n#align cont_diff.of_le cont_diff.of_le\n\n",
 "norm_iterated_fderiv_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem norm_iterated_fderiv_zero : «expr‖ ‖» (iterated_fderiv 𝕜 0 f x) = «expr‖ ‖» (f x) := by\n  rw [iterated_fderiv_zero_eq_comp, linear_isometry_equiv.norm_map]\n#align norm_iterated_fderiv_zero norm_iterated_fderiv_zero\n\n",
 "norm_iterated_fderiv_within_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem norm_iterated_fderiv_within_zero : «expr‖ ‖» (iterated_fderiv_within 𝕜 0 f s x) = «expr‖ ‖» (f x) := by\n  rw [iterated_fderiv_within_zero_eq_comp, linear_isometry_equiv.norm_map]\n#align norm_iterated_fderiv_within_zero norm_iterated_fderiv_within_zero\n\n",
 "norm_iterated_fderiv_within_fderiv_within":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem norm_iterated_fderiv_within_fderiv_within {n : ℕ} (hs : unique_diff_on 𝕜 s) (hx : x ∈ s) :\n    «expr‖ ‖» (iterated_fderiv_within 𝕜 n (fderiv_within 𝕜 f s) s x) =\n      «expr‖ ‖» (iterated_fderiv_within 𝕜 (n + 1) f s x) :=\n  by rw [iterated_fderiv_within_succ_eq_comp_right hs hx, linear_isometry_equiv.norm_map]\n#align norm_iterated_fderiv_within_fderiv_within norm_iterated_fderiv_within_fderiv_within\n\n",
 "norm_iterated_fderiv_fderiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem norm_iterated_fderiv_fderiv {n : ℕ} :\n    «expr‖ ‖» (iterated_fderiv 𝕜 n (fderiv 𝕜 f) x) = «expr‖ ‖» (iterated_fderiv 𝕜 (n + 1) f x) := by\n  rw [iterated_fderiv_succ_eq_comp_right, linear_isometry_equiv.norm_map]\n#align norm_iterated_fderiv_fderiv norm_iterated_fderiv_fderiv\n\n",
 "norm_fderiv_within_iterated_fderiv_within":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem norm_fderiv_within_iterated_fderiv_within {n : ℕ} :\n    «expr‖ ‖» (fderiv_within 𝕜 (iterated_fderiv_within 𝕜 n f s) s x) =\n      «expr‖ ‖» (iterated_fderiv_within 𝕜 (n + 1) f s x) :=\n  by rw [iterated_fderiv_within_succ_eq_comp_left, linear_isometry_equiv.norm_map]\n#align norm_fderiv_within_iterated_fderiv_within norm_fderiv_within_iterated_fderiv_within\n\n",
 "norm_fderiv_iterated_fderiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem norm_fderiv_iterated_fderiv {n : ℕ} :\n    «expr‖ ‖» (fderiv 𝕜 (iterated_fderiv 𝕜 n f) x) = «expr‖ ‖» (iterated_fderiv 𝕜 (n + 1) f x) := by\n  rw [iterated_fderiv_succ_eq_comp_left, linear_isometry_equiv.norm_map]\n#align norm_fderiv_iterated_fderiv norm_fderiv_iterated_fderiv\n\n",
 "neg":
 "/-- The negative of a `C^n` function on a domain is `C^n`. -/\ntheorem cont_diff_on.neg {s : set E} {f : E → F} (hf : cont_diff_on 𝕜 n f s) : cont_diff_on 𝕜 n (fun x => -f x) s :=\n  fun x hx => (hf x hx).neg\n#align cont_diff_on.neg cont_diff_on.neg\n\n",
 "mul":
 "/-- The product of two `C^n`functions is `C^n`. -/\ntheorem cont_diff.mul {f g : E → 𝔸} (hf : cont_diff 𝕜 n f) (hg : cont_diff 𝕜 n g) : cont_diff 𝕜 n fun x => f x * g x :=\n  cont_diff_mul.comp (hf.prod hg)\n#align cont_diff.mul cont_diff.mul\n\n",
 "mono_of_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\ntheorem cont_diff_within_at.mono_of_mem (h : cont_diff_within_at 𝕜 n f s x) {t : set E} (hst : s ∈ nhds_within t x) :\n    cont_diff_within_at 𝕜 n f t x := by\n  intro m hm\n  rcases h m hm with ⟨u, hu, p, H⟩\n  exact ⟨u, nhds_within_le_of_mem (insert_mem_nhds_within_insert hst) hu, p, H⟩\n#align cont_diff_within_at.mono_of_mem cont_diff_within_at.mono_of_mem\n\n",
 "mono":
 "theorem cont_diff_on.mono (h : cont_diff_on 𝕜 n f s) {t : set E} (hst : t ⊆ s) : cont_diff_on 𝕜 n f t := fun x hx =>\n  (h x (hst hx)).mono hst\n#align cont_diff_on.mono cont_diff_on.mono\n\n",
 "iterated_fderiv_zero_fun":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr [× ]→L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr [× ]→L[ ] » -/\n@[simp]\ntheorem iterated_fderiv_zero_fun {n : ℕ} : (iterated_fderiv 𝕜 n fun x : E => (0 : F)) = 0 :=\n  by\n  induction' n with n IH\n  · ext m\n    simp\n  · ext (x m)\n    rw [iterated_fderiv_succ_apply_left, IH]\n    change\n      (fderiv 𝕜 (fun x : E => (0 : «expr [× ]→L[ ] » E n 𝕜 F)) x : E → «expr [× ]→L[ ] » E n 𝕜 F) (m 0) (tail m) = _\n    rw [fderiv_const]\n    rfl\n#align iterated_fderiv_zero_fun iterated_fderiv_zero_fun\n\n",
 "iterated_fderiv_zero_eq_comp":
 "theorem iterated_fderiv_zero_eq_comp : iterated_fderiv 𝕜 0 f = (continuous_multilinear_curry_fin0 𝕜 E F).symm ∘ f :=\n  rfl\n#align iterated_fderiv_zero_eq_comp iterated_fderiv_zero_eq_comp\n\n",
 "iterated_fderiv_zero_apply":
 "@[simp]\ntheorem iterated_fderiv_zero_apply (m : fin 0 → E) : (iterated_fderiv 𝕜 0 f x : (fin 0 → E) → F) m = f x :=\n  rfl\n#align iterated_fderiv_zero_apply iterated_fderiv_zero_apply\n\n",
 "iterated_fderiv_within_zero_eq_comp":
 "theorem iterated_fderiv_within_zero_eq_comp :\n    iterated_fderiv_within 𝕜 0 f s = (continuous_multilinear_curry_fin0 𝕜 E F).symm ∘ f :=\n  rfl\n#align iterated_fderiv_within_zero_eq_comp iterated_fderiv_within_zero_eq_comp\n\n",
 "iterated_fderiv_within_zero_apply":
 "@[simp]\ntheorem iterated_fderiv_within_zero_apply (m : fin 0 → E) :\n    (iterated_fderiv_within 𝕜 0 f s x : (fin 0 → E) → F) m = f x :=\n  rfl\n#align iterated_fderiv_within_zero_apply iterated_fderiv_within_zero_apply\n\n",
 "iterated_fderiv_within_univ":
 "theorem iterated_fderiv_within_univ {n : ℕ} : iterated_fderiv_within 𝕜 n f univ = iterated_fderiv 𝕜 n f :=\n  by\n  induction' n with n IH\n  · ext x\n    simp\n  · ext (x m)\n    rw [iterated_fderiv_succ_apply_left, iterated_fderiv_within_succ_apply_left, IH, fderiv_within_univ]\n#align iterated_fderiv_within_univ iterated_fderiv_within_univ\n\n",
 "iterated_fderiv_within_succ_eq_comp_right":
 "/-- Writing explicitly the `n+1`-th derivative as the composition of a currying linear equiv,\nand the `n`-th derivative of the derivative. -/\ntheorem iterated_fderiv_within_succ_eq_comp_right {n : ℕ} (hs : unique_diff_on 𝕜 s) (hx : x ∈ s) :\n    iterated_fderiv_within 𝕜 (n + 1) f s x =\n      (continuous_multilinear_curry_right_equiv' 𝕜 n E F ∘\n          iterated_fderiv_within 𝕜 n (fun y => fderiv_within 𝕜 f s y) s)\n        x :=\n  by\n  ext m\n  rw [iterated_fderiv_within_succ_apply_right hs hx]\n  rfl\n#align iterated_fderiv_within_succ_eq_comp_right iterated_fderiv_within_succ_eq_comp_right\n\n",
 "iterated_fderiv_within_succ_eq_comp_left":
 "/-- Writing explicitly the `n+1`-th derivative as the composition of a currying linear equiv,\nand the derivative of the `n`-th derivative. -/\ntheorem iterated_fderiv_within_succ_eq_comp_left {n : ℕ} :\n    iterated_fderiv_within 𝕜 (n + 1) f s =\n      continuous_multilinear_curry_left_equiv 𝕜 (fun i : fin (n + 1) => E) F ∘\n        fderiv_within 𝕜 (iterated_fderiv_within 𝕜 n f s) s :=\n  rfl\n#align iterated_fderiv_within_succ_eq_comp_left iterated_fderiv_within_succ_eq_comp_left\n\n",
 "iterated_fderiv_within_succ_apply_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr [× ]→L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr [× ]→L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr [× ]→L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr [× ]→L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\ntheorem iterated_fderiv_within_succ_apply_right {n : ℕ} (hs : unique_diff_on 𝕜 s) (hx : x ∈ s) (m : fin (n + 1) → E) :\n    (iterated_fderiv_within 𝕜 (n + 1) f s x : (fin (n + 1) → E) → F) m =\n      iterated_fderiv_within 𝕜 n (fun y => fderiv_within 𝕜 f s y) s x (init m) (m (last n)) :=\n  by\n  induction' n with n IH generalizing x\n  · rw [iterated_fderiv_within_succ_eq_comp_left, iterated_fderiv_within_zero_eq_comp,\n      iterated_fderiv_within_zero_apply, function.comp_apply, linear_isometry_equiv.comp_fderiv_within _ (hs x hx)]\n    rfl\n  · let I := continuous_multilinear_curry_right_equiv' 𝕜 n E F\n    have A :\n      ∀ y ∈ s,\n        iterated_fderiv_within 𝕜 n.succ f s y = (I ∘ iterated_fderiv_within 𝕜 n (fun y => fderiv_within 𝕜 f s y) s) y :=\n      by\n      intro y hy\n      ext m\n      rw [@IH m y hy]\n      rfl\n    calc\n      (iterated_fderiv_within 𝕜 (n + 2) f s x : (fin (n + 2) → E) → F) m =\n          (fderiv_within 𝕜 (iterated_fderiv_within 𝕜 n.succ f s) s x : E → «expr [× ]→L[ ] » E (n + 1) 𝕜 F) (m 0)\n            (tail m) :=\n        rfl\n      _ =\n          (fderiv_within 𝕜 (I ∘ iterated_fderiv_within 𝕜 n (fderiv_within 𝕜 f s) s) s x :\n              E → «expr [× ]→L[ ] » E (n + 1) 𝕜 F)\n            (m 0) (tail m) :=\n        by rw [fderiv_within_congr (hs x hx) A (A x hx)]\n      _ =\n          (I ∘ fderiv_within 𝕜 (iterated_fderiv_within 𝕜 n (fderiv_within 𝕜 f s) s) s x :\n              E → «expr [× ]→L[ ] » E (n + 1) 𝕜 F)\n            (m 0) (tail m) :=\n        by\n        rw [linear_isometry_equiv.comp_fderiv_within _ (hs x hx)]\n        rfl\n      _ =\n          (fderiv_within 𝕜 (iterated_fderiv_within 𝕜 n (fun y => fderiv_within 𝕜 f s y) s) s x :\n              E → «expr [× ]→L[ ] » E n 𝕜 («expr →L[ ] » E 𝕜 F))\n            (m 0) (init (tail m)) ((tail m) (last n)) :=\n        rfl\n      _ = iterated_fderiv_within 𝕜 (nat.succ n) (fun y => fderiv_within 𝕜 f s y) s x (init m) (m (last (n + 1))) :=\n        by\n        rw [iterated_fderiv_within_succ_apply_left, tail_init_eq_init_tail]\n        rfl\n      \n#align iterated_fderiv_within_succ_apply_right iterated_fderiv_within_succ_apply_right\n\n",
 "iterated_fderiv_within_succ_apply_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr [× ]→L[ ] » -/\ntheorem iterated_fderiv_within_succ_apply_left {n : ℕ} (m : fin (n + 1) → E) :\n    (iterated_fderiv_within 𝕜 (n + 1) f s x : (fin (n + 1) → E) → F) m =\n      (fderiv_within 𝕜 (iterated_fderiv_within 𝕜 n f s) s x : E → «expr [× ]→L[ ] » E n 𝕜 F) (m 0) (tail m) :=\n  rfl\n#align iterated_fderiv_within_succ_apply_left iterated_fderiv_within_succ_apply_left\n\n",
 "iterated_fderiv_within_one_apply":
 "@[simp]\ntheorem iterated_fderiv_within_one_apply (hs : unique_diff_on 𝕜 s) (hx : x ∈ s) (m : fin 1 → E) :\n    (iterated_fderiv_within 𝕜 1 f s x : (fin 1 → E) → F) m = (fderiv_within 𝕜 f s x : E → F) (m 0) :=\n  by\n  rw [iterated_fderiv_within_succ_apply_right hs hx, iterated_fderiv_within_zero_apply]\n  rfl\n#align iterated_fderiv_within_one_apply iterated_fderiv_within_one_apply\n\n",
 "iterated_fderiv_within_of_is_open":
 "/-- In an open set, the iterated derivative within this set coincides with the global iterated\nderivative. -/\ntheorem iterated_fderiv_within_of_is_open (n : ℕ) (hs : is_open s) :\n    EqOn (iterated_fderiv_within 𝕜 n f s) (iterated_fderiv 𝕜 n f) s :=\n  by\n  induction' n with n IH\n  · intro x hx\n    ext1 m\n    simp only [iterated_fderiv_within_zero_apply, iterated_fderiv_zero_apply]\n  · intro x hx\n    rw [iterated_fderiv_succ_eq_comp_left, iterated_fderiv_within_succ_eq_comp_left]\n    dsimp\n    congr 1\n    rw [fderiv_within_of_open hs hx]\n    apply filter.eventually_eq.fderiv_eq\n    filter_upwards [hs.mem_nhds hx]\n    exact IH\n#align iterated_fderiv_within_of_is_open iterated_fderiv_within_of_is_open\n\n",
 "iterated_fderiv_within_neg_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ∞» -/\ntheorem iterated_fderiv_within_neg_apply {f : E → F} (hu : unique_diff_on 𝕜 s) (hx : x ∈ s) :\n    iterated_fderiv_within 𝕜 i (-f) s x = -iterated_fderiv_within 𝕜 i f s x :=\n  by\n  induction' i with i hi generalizing x\n  · ext h\n    simp\n  · ext h\n    have hi' : (i : «exprℕ∞») < i + 1 := with_top.coe_lt_coe.mpr (nat.lt_succ_self _)\n    calc\n      iterated_fderiv_within 𝕜 (i + 1) (-f) s x h =\n          fderiv_within 𝕜 (iterated_fderiv_within 𝕜 i (-f) s) s x (h 0) (fin.tail h) :=\n        rfl\n      _ = fderiv_within 𝕜 (-iterated_fderiv_within 𝕜 i f s) s x (h 0) (fin.tail h) :=\n        by\n        congr 2\n        exact fderiv_within_congr (hu x hx) (fun _ => hi) (hi hx)\n      _ = -(fderiv_within 𝕜 (iterated_fderiv_within 𝕜 i f s) s) x (h 0) (fin.tail h) := by\n        rw [pi.neg_def, fderiv_within_neg (hu x hx)] <;> rfl\n      _ = -(iterated_fderiv_within 𝕜 (i + 1) f s) x h := rfl\n      \n#align iterated_fderiv_within_neg_apply iterated_fderiv_within_neg_apply\n\n",
 "iterated_fderiv_within_inter_open":
 "/-- The iterated differential within a set `s` at a point `x` is not modified if one intersects\n`s` with an open set containing `x`. -/\ntheorem iterated_fderiv_within_inter_open {n : ℕ} (hu : is_open u) (hs : unique_diff_on 𝕜 (s ∩ u)) (hx : x ∈ s ∩ u) :\n    iterated_fderiv_within 𝕜 n f (s ∩ u) x = iterated_fderiv_within 𝕜 n f s x :=\n  by\n  induction' n with n IH generalizing x\n  · ext m\n    simp\n  · have A :\n      fderiv_within 𝕜 (fun y => iterated_fderiv_within 𝕜 n f (s ∩ u) y) (s ∩ u) x =\n        fderiv_within 𝕜 (fun y => iterated_fderiv_within 𝕜 n f s y) (s ∩ u) x :=\n      fderiv_within_congr (hs x hx) (fun y hy => IH hy) (IH hx)\n    have B :\n      fderiv_within 𝕜 (fun y => iterated_fderiv_within 𝕜 n f s y) (s ∩ u) x =\n        fderiv_within 𝕜 (fun y => iterated_fderiv_within 𝕜 n f s y) s x :=\n      fderiv_within_inter (is_open.mem_nhds hu hx.2)\n        ((unique_diff_within_at_inter (is_open.mem_nhds hu hx.2)).1 (hs x hx))\n    ext m\n    rw [iterated_fderiv_within_succ_apply_left, iterated_fderiv_within_succ_apply_left, A, B]\n#align iterated_fderiv_within_inter_open iterated_fderiv_within_inter_open\n\n",
 "iterated_fderiv_within_inter'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/-- The iterated differential within a set `s` at a point `x` is not modified if one intersects\n`s` with a neighborhood of `x` within `s`. -/\ntheorem iterated_fderiv_within_inter' {n : ℕ} (hu : u ∈ nhds_within s x) (hs : unique_diff_on 𝕜 s) (xs : x ∈ s) :\n    iterated_fderiv_within 𝕜 n f (s ∩ u) x = iterated_fderiv_within 𝕜 n f s x :=\n  by\n  obtain ⟨v, v_open, xv, vu⟩ : ∃ v, is_open v ∧ x ∈ v ∧ v ∩ s ⊆ u := mem_nhds_within.1 hu\n  have A : s ∩ u ∩ v = s ∩ v :=\n    by\n    apply subset.antisymm (inter_subset_inter (inter_subset_left _ _) (subset.refl _))\n    exact fun y ⟨ys, yv⟩ => ⟨⟨ys, vu ⟨yv, ys⟩⟩, yv⟩\n  have : iterated_fderiv_within 𝕜 n f (s ∩ v) x = iterated_fderiv_within 𝕜 n f s x :=\n    iterated_fderiv_within_inter_open v_open (hs.inter v_open) ⟨xs, xv⟩\n  rw [← this]\n  have : iterated_fderiv_within 𝕜 n f (s ∩ u ∩ v) x = iterated_fderiv_within 𝕜 n f (s ∩ u) x :=\n    by\n    refine' iterated_fderiv_within_inter_open v_open _ ⟨⟨xs, vu ⟨xv, xs⟩⟩, xv⟩\n    rw [A]\n    exact hs.inter v_open\n  rw [A] at this\n  rw [← this]\n#align iterated_fderiv_within_inter' iterated_fderiv_within_inter'\n\n",
 "iterated_fderiv_within_inter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- The iterated differential within a set `s` at a point `x` is not modified if one intersects\n`s` with a neighborhood of `x`. -/\ntheorem iterated_fderiv_within_inter {n : ℕ} (hu : u ∈ (nhds) x) (hs : unique_diff_on 𝕜 s) (xs : x ∈ s) :\n    iterated_fderiv_within 𝕜 n f (s ∩ u) x = iterated_fderiv_within 𝕜 n f s x :=\n  iterated_fderiv_within_inter' (mem_nhds_within_of_mem_nhds hu) hs xs\n#align iterated_fderiv_within_inter iterated_fderiv_within_inter\n\n",
 "iterated_fderiv_within_const_smul_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ∞» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem iterated_fderiv_within_const_smul_apply (hf : cont_diff_on 𝕜 i f s) (hu : unique_diff_on 𝕜 s) (hx : x ∈ s) :\n    iterated_fderiv_within 𝕜 i («expr • » a f) s x = «expr • » a (iterated_fderiv_within 𝕜 i f s x) :=\n  by\n  induction' i with i hi generalizing x\n  · ext\n    simp\n  · ext h\n    have hi' : (i : «exprℕ∞») < i + 1 := with_top.coe_lt_coe.mpr (nat.lt_succ_self _)\n    have hdf : differentiable_on 𝕜 (iterated_fderiv_within 𝕜 i f s) s :=\n      hf.differentiable_on_iterated_fderiv_within hi' hu\n    have hcdf : cont_diff_on 𝕜 i f s := hf.of_le hi'.le\n    calc\n      iterated_fderiv_within 𝕜 (i + 1) («expr • » a f) s x h =\n          fderiv_within 𝕜 (iterated_fderiv_within 𝕜 i («expr • » a f) s) s x (h 0) (fin.tail h) :=\n        rfl\n      _ = fderiv_within 𝕜 («expr • » a (iterated_fderiv_within 𝕜 i f s)) s x (h 0) (fin.tail h) :=\n        by\n        congr 2\n        exact fderiv_within_congr (hu x hx) (fun _ => hi hcdf) (hi hcdf hx)\n      _ = («expr • » a (fderiv_within 𝕜 (iterated_fderiv_within 𝕜 i f s))) s x (h 0) (fin.tail h) := by\n        rw [pi.smul_def, fderiv_within_const_smul (hu x hx) (hdf x hx)] <;> rfl\n      _ = «expr • » a (iterated_fderiv_within 𝕜 (i + 1) f s x h) := rfl\n      \n#align iterated_fderiv_within_const_smul_apply iterated_fderiv_within_const_smul_apply\n\n",
 "iterated_fderiv_within_congr":
 "/-- If two functions coincide on a set `s` of unique differentiability, then their iterated\ndifferentials within this set coincide. -/\ntheorem iterated_fderiv_within_congr {n : ℕ} (hs : unique_diff_on 𝕜 s) (hL : ∀ y ∈ s, f₁ y = f y) (hx : x ∈ s) :\n    iterated_fderiv_within 𝕜 n f₁ s x = iterated_fderiv_within 𝕜 n f s x :=\n  by\n  induction' n with n IH generalizing x\n  · ext m\n    simp [hL x hx]\n  · have :\n      fderiv_within 𝕜 (fun y => iterated_fderiv_within 𝕜 n f₁ s y) s x =\n        fderiv_within 𝕜 (fun y => iterated_fderiv_within 𝕜 n f s y) s x :=\n      fderiv_within_congr (hs x hx) (fun y hy => IH hy) (IH hx)\n    ext m\n    rw [iterated_fderiv_within_succ_apply_left, iterated_fderiv_within_succ_apply_left, this]\n#align iterated_fderiv_within_congr iterated_fderiv_within_congr\n\n",
 "iterated_fderiv_within_add_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ∞» -/\ntheorem iterated_fderiv_within_add_apply {f g : E → F} (hf : cont_diff_on 𝕜 i f s) (hg : cont_diff_on 𝕜 i g s)\n    (hu : unique_diff_on 𝕜 s) (hx : x ∈ s) :\n    iterated_fderiv_within 𝕜 i (f + g) s x = iterated_fderiv_within 𝕜 i f s x + iterated_fderiv_within 𝕜 i g s x :=\n  by\n  induction' i with i hi generalizing x\n  · ext h\n    simp\n  · ext h\n    have hi' : (i : «exprℕ∞») < i + 1 := with_top.coe_lt_coe.mpr (nat.lt_succ_self _)\n    have hdf : differentiable_on 𝕜 (iterated_fderiv_within 𝕜 i f s) s :=\n      hf.differentiable_on_iterated_fderiv_within hi' hu\n    have hdg : differentiable_on 𝕜 (iterated_fderiv_within 𝕜 i g s) s :=\n      hg.differentiable_on_iterated_fderiv_within hi' hu\n    have hcdf : cont_diff_on 𝕜 i f s := hf.of_le hi'.le\n    have hcdg : cont_diff_on 𝕜 i g s := hg.of_le hi'.le\n    calc\n      iterated_fderiv_within 𝕜 (i + 1) (f + g) s x h =\n          fderiv_within 𝕜 (iterated_fderiv_within 𝕜 i (f + g) s) s x (h 0) (fin.tail h) :=\n        rfl\n      _ = fderiv_within 𝕜 (iterated_fderiv_within 𝕜 i f s + iterated_fderiv_within 𝕜 i g s) s x (h 0) (fin.tail h) :=\n        by\n        congr 2\n        exact fderiv_within_congr (hu x hx) (fun _ => hi hcdf hcdg) (hi hcdf hcdg hx)\n      _ =\n          (fderiv_within 𝕜 (iterated_fderiv_within 𝕜 i f s) s + fderiv_within 𝕜 (iterated_fderiv_within 𝕜 i g s) s) x\n            (h 0) (fin.tail h) :=\n        by rw [pi.add_def, fderiv_within_add (hu x hx) (hdf x hx) (hdg x hx)] <;> rfl\n      _ = (iterated_fderiv_within 𝕜 (i + 1) f s + iterated_fderiv_within 𝕜 (i + 1) g s) x h := rfl\n      \n#align iterated_fderiv_within_add_apply iterated_fderiv_within_add_apply\n\n",
 "iterated_fderiv_with_zero_eq":
 "theorem iterated_fderiv_with_zero_eq : iterated_fderiv_within 𝕜 0 f s = iterated_fderiv 𝕜 0 f :=\n  by\n  ext\n  rfl\n#align iterated_fderiv_with_zero_eq iterated_fderiv_with_zero_eq\n\n",
 "iterated_fderiv_succ_eq_comp_right":
 "/-- Writing explicitly the `n+1`-th derivative as the composition of a currying linear equiv,\nand the `n`-th derivative of the derivative. -/\ntheorem iterated_fderiv_succ_eq_comp_right {n : ℕ} :\n    iterated_fderiv 𝕜 (n + 1) f x =\n      (continuous_multilinear_curry_right_equiv' 𝕜 n E F ∘ iterated_fderiv 𝕜 n fun y => fderiv 𝕜 f y) x :=\n  by\n  ext m\n  rw [iterated_fderiv_succ_apply_right]\n  rfl\n#align iterated_fderiv_succ_eq_comp_right iterated_fderiv_succ_eq_comp_right\n\n",
 "iterated_fderiv_succ_eq_comp_left":
 "/-- Writing explicitly the `n+1`-th derivative as the composition of a currying linear equiv,\nand the derivative of the `n`-th derivative. -/\ntheorem iterated_fderiv_succ_eq_comp_left {n : ℕ} :\n    iterated_fderiv 𝕜 (n + 1) f =\n      continuous_multilinear_curry_left_equiv 𝕜 (fun i : fin (n + 1) => E) F ∘ fderiv 𝕜 (iterated_fderiv 𝕜 n f) :=\n  rfl\n#align iterated_fderiv_succ_eq_comp_left iterated_fderiv_succ_eq_comp_left\n\n",
 "iterated_fderiv_succ_apply_right":
 "theorem iterated_fderiv_succ_apply_right {n : ℕ} (m : fin (n + 1) → E) :\n    (iterated_fderiv 𝕜 (n + 1) f x : (fin (n + 1) → E) → F) m =\n      iterated_fderiv 𝕜 n (fun y => fderiv 𝕜 f y) x (init m) (m (last n)) :=\n  by\n  rw [← iterated_fderiv_within_univ, ← iterated_fderiv_within_univ, ← fderiv_within_univ]\n  exact iterated_fderiv_within_succ_apply_right unique_diff_on_univ (mem_univ _) _\n#align iterated_fderiv_succ_apply_right iterated_fderiv_succ_apply_right\n\n",
 "iterated_fderiv_succ_apply_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr [× ]→L[ ] » -/\ntheorem iterated_fderiv_succ_apply_left {n : ℕ} (m : fin (n + 1) → E) :\n    (iterated_fderiv 𝕜 (n + 1) f x : (fin (n + 1) → E) → F) m =\n      (fderiv 𝕜 (iterated_fderiv 𝕜 n f) x : E → «expr [× ]→L[ ] » E n 𝕜 F) (m 0) (tail m) :=\n  rfl\n#align iterated_fderiv_succ_apply_left iterated_fderiv_succ_apply_left\n\n",
 "iterated_fderiv_one_apply":
 "@[simp]\ntheorem iterated_fderiv_one_apply (m : fin 1 → E) :\n    (iterated_fderiv 𝕜 1 f x : (fin 1 → E) → F) m = (fderiv 𝕜 f x : E → F) (m 0) :=\n  by\n  rw [iterated_fderiv_succ_apply_right, iterated_fderiv_zero_apply]\n  rfl\n#align iterated_fderiv_one_apply iterated_fderiv_one_apply\n\n",
 "iterated_fderiv_neg_apply":
 "theorem iterated_fderiv_neg_apply {i : ℕ} {f : E → F} : iterated_fderiv 𝕜 i (-f) x = -iterated_fderiv 𝕜 i f x :=\n  by\n  simp_rw [← iterated_fderiv_within_univ]\n  exact iterated_fderiv_within_neg_apply unique_diff_on_univ (Set.mem_univ _)\n#align iterated_fderiv_neg_apply iterated_fderiv_neg_apply\n\n",
 "iterated_fderiv_const_smul_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem iterated_fderiv_const_smul_apply {x : E} (hf : cont_diff 𝕜 i f) :\n    iterated_fderiv 𝕜 i («expr • » a f) x = «expr • » a (iterated_fderiv 𝕜 i f x) :=\n  by\n  simp_rw [← cont_diff_on_univ, ← iterated_fderiv_within_univ] at *\n  refine' iterated_fderiv_within_const_smul_apply hf unique_diff_on_univ (Set.mem_univ _)\n#align iterated_fderiv_const_smul_apply iterated_fderiv_const_smul_apply\n\n",
 "iterated_fderiv_add_apply":
 "theorem iterated_fderiv_add_apply {i : ℕ} {f g : E → F} (hf : cont_diff 𝕜 i f) (hg : cont_diff 𝕜 i g) :\n    iterated_fderiv 𝕜 i (f + g) x = iterated_fderiv 𝕜 i f x + iterated_fderiv 𝕜 i g x :=\n  by\n  simp_rw [← cont_diff_on_univ, ← iterated_fderiv_within_univ] at hf hg⊢\n  exact iterated_fderiv_within_add_apply hf hg unique_diff_on_univ (Set.mem_univ _)\n#align iterated_fderiv_add_apply iterated_fderiv_add_apply\n\n",
 "iterated_fderiv":
 "theorem has_compact_support.iterated_fderiv (hf : has_compact_support f) (n : ℕ) :\n    has_compact_support (iterated_fderiv 𝕜 n f) :=\n  by\n  induction' n with n IH\n  · rw [iterated_fderiv_zero_eq_comp]\n    apply hf.comp_left\n    exact linear_isometry_equiv.map_zero _\n  · rw [iterated_fderiv_succ_eq_comp_left]\n    apply (IH.fderiv 𝕜).comp_left\n    exact linear_isometry_equiv.map_zero _\n#align has_compact_support.iterated_fderiv has_compact_support.iterated_fderiv\n\n",
 "inv":
 "theorem cont_diff.inv {f : E → 𝕜'} {n} (hf : cont_diff 𝕜 n f) (h : ∀ x, f x ≠ 0) : cont_diff 𝕜 n fun x => (f x)⁻¹ :=\n  by\n  rw [cont_diff_iff_cont_diff_at]\n  exact fun x => hf.cont_diff_at.inv (h x)\n#align cont_diff.inv cont_diff.inv\n\n",
 "insert":
 "theorem cont_diff_within_at.insert (h : cont_diff_within_at 𝕜 n f s x) : cont_diff_within_at 𝕜 n f (insert x s) x :=\n  h.insert'\n#align cont_diff_within_at.insert cont_diff_within_at.insert\n\n",
 "has_strict_fderiv_at'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/-- If a function is `C^n` with `1 ≤ n` around a point, and its derivative at that point is given to\nus as `f'`, then `f'` is also a strict derivative. -/\ntheorem cont_diff_at.has_strict_fderiv_at' {f : E' → F'} {f' : «expr →L[ ] » E' 𝕂 F'} {x : E'}\n    (hf : cont_diff_at 𝕂 n f x) (hf' : has_fderiv_at f f' x) (hn : 1 ≤ n) : has_strict_fderiv_at f f' x :=\n  by\n  rcases hf 1 hn with ⟨u, H, p, hp⟩\n  simp only [nhds_within_univ, mem_univ, insert_eq_of_mem] at H\n  have := hp.has_strict_fderiv_at le_rfl H\n  rwa [hf'.unique this.has_fderiv_at]\n#align cont_diff_at.has_strict_fderiv_at' cont_diff_at.has_strict_fderiv_at'\n\n",
 "has_strict_fderiv_at":
 "/-- If a function is `C^n` with `1 ≤ n`, then the derivative of `f` is also a strict derivative. -/\ntheorem cont_diff.has_strict_fderiv_at {f : E' → F'} {x : E'} (hf : cont_diff 𝕂 n f) (hn : 1 ≤ n) :\n    has_strict_fderiv_at f (fderiv 𝕂 f x) x :=\n  hf.cont_diff_at.has_strict_fderiv_at hn\n#align cont_diff.has_strict_fderiv_at cont_diff.has_strict_fderiv_at\n\n",
 "has_strict_deriv_at'":
 "/-- If a function is `C^n` with `1 ≤ n` around a point, and its derivative at that point is given to\nus as `f'`, then `f'` is also a strict derivative. -/\ntheorem cont_diff_at.has_strict_deriv_at' {f : 𝕂 → F'} {f' : F'} {x : 𝕂} (hf : cont_diff_at 𝕂 n f x)\n    (hf' : has_deriv_at f f' x) (hn : 1 ≤ n) : has_strict_deriv_at f f' x :=\n  hf.has_strict_fderiv_at' hf' hn\n#align cont_diff_at.has_strict_deriv_at' cont_diff_at.has_strict_deriv_at'\n\n",
 "has_strict_deriv_at":
 "/-- If a function is `C^n` with `1 ≤ n`, then the derivative of `f` is also a strict derivative. -/\ntheorem cont_diff.has_strict_deriv_at {f : 𝕂 → F'} {x : 𝕂} (hf : cont_diff 𝕂 n f) (hn : 1 ≤ n) :\n    has_strict_deriv_at f (deriv f x) x :=\n  hf.cont_diff_at.has_strict_deriv_at hn\n#align cont_diff.has_strict_deriv_at cont_diff.has_strict_deriv_at\n\n",
 "has_ftaylor_series_up_to_zero_iff":
 "theorem has_ftaylor_series_up_to_zero_iff :\n    has_ftaylor_series_up_to 0 f p ↔ continuous f ∧ ∀ x, (p x 0).uncurry0 = f x := by\n  simp [has_ftaylor_series_up_to_on_univ_iff.symm, continuous_iff_continuous_on_univ,\n    has_ftaylor_series_up_to_on_zero_iff]\n#align has_ftaylor_series_up_to_zero_iff has_ftaylor_series_up_to_zero_iff\n\n",
 "has_ftaylor_series_up_to_succ_iff_right":
 "/-- `p` is a Taylor series of `f` up to `n+1` if and only if `p.shift` is a Taylor series up to `n`\nfor `p 1`, which is a derivative of `f`. -/\ntheorem has_ftaylor_series_up_to_succ_iff_right {n : ℕ} :\n    has_ftaylor_series_up_to (n + 1 : ℕ) f p ↔\n      (∀ x, (p x 0).uncurry0 = f x) ∧\n        (∀ x, has_fderiv_at (fun y => p y 0) (p x 1).curry_left x) ∧\n          has_ftaylor_series_up_to n (fun x => continuous_multilinear_curry_fin1 𝕜 E F (p x 1)) fun x => (p x).shift :=\n  by\n  simp only [has_ftaylor_series_up_to_on_succ_iff_right, ← has_ftaylor_series_up_to_on_univ_iff, mem_univ,\n    forall_true_left, has_fderiv_within_at_univ]\n#align has_ftaylor_series_up_to_succ_iff_right has_ftaylor_series_up_to_succ_iff_right\n\n",
 "has_ftaylor_series_up_to_on_zero_iff":
 "theorem has_ftaylor_series_up_to_on_zero_iff :\n    has_ftaylor_series_up_to_on 0 f p s ↔ continuous_on f s ∧ ∀ x ∈ s, (p x 0).uncurry0 = f x :=\n  by\n  refine' ⟨fun H => ⟨H.continuous_on, H.zero_eq⟩, fun H => ⟨H.2, fun m hm => false.elim (not_le.2 hm bot_le), _⟩⟩\n  intro m hm\n  obtain rfl : m = 0 := by exact_mod_cast hm.antisymm (zero_le _)\n  have : ∀ x ∈ s, p x 0 = (continuous_multilinear_curry_fin0 𝕜 E F).symm (f x) :=\n    by\n    intro x hx\n    rw [← H.2 x hx]\n    symm\n    exact continuous_multilinear_map.uncurry0_curry0 _\n  rw [continuous_on_congr this, linear_isometry_equiv.comp_continuous_on_iff]\n  exact H.1\n#align has_ftaylor_series_up_to_on_zero_iff has_ftaylor_series_up_to_on_zero_iff\n\n",
 "has_ftaylor_series_up_to_on_univ_iff":
 "theorem has_ftaylor_series_up_to_on_univ_iff :\n    has_ftaylor_series_up_to_on n f p univ ↔ has_ftaylor_series_up_to n f p :=\n  by\n  constructor\n  · intro H\n    constructor\n    · exact fun x => H.zero_eq x (mem_univ x)\n    · intro m hm x\n      rw [← has_fderiv_within_at_univ]\n      exact H.fderiv_within m hm x (mem_univ x)\n    · intro m hm\n      rw [continuous_iff_continuous_on_univ]\n      exact H.cont m hm\n  · intro H\n    constructor\n    · exact fun x hx => H.zero_eq x\n    · intro m hm x hx\n      rw [has_fderiv_within_at_univ]\n      exact H.fderiv m hm x\n    · intro m hm\n      rw [← continuous_iff_continuous_on_univ]\n      exact H.cont m hm\n#align has_ftaylor_series_up_to_on_univ_iff has_ftaylor_series_up_to_on_univ_iff\n\n",
 "has_ftaylor_series_up_to_on_top_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∞» -/\ntheorem has_ftaylor_series_up_to_on_top_iff :\n    has_ftaylor_series_up_to_on («expr∞») f p s ↔ ∀ n : ℕ, has_ftaylor_series_up_to_on n f p s :=\n  by\n  constructor\n  · intro H n\n    exact H.of_le le_top\n  · intro H\n    constructor\n    · exact (H 0).zero_eq\n    · intro m hm\n      apply (H m.succ).fderiv_within m (WithTop.coe_lt_coe.2 (lt_add_one m))\n    · intro m hm\n      apply (H m).cont m le_rfl\n#align has_ftaylor_series_up_to_on_top_iff has_ftaylor_series_up_to_on_top_iff\n\n",
 "has_ftaylor_series_up_to_on_succ_iff_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ∞» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ∞» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ∞» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ∞» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ∞» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ∞» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ∞» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ∞» -/\n/-- `p` is a Taylor series of `f` up to `n+1` if and only if `p.shift` is a Taylor series up to `n`\nfor `p 1`, which is a derivative of `f`. -/\ntheorem has_ftaylor_series_up_to_on_succ_iff_right {n : ℕ} :\n    has_ftaylor_series_up_to_on (n + 1 : ℕ) f p s ↔\n      (∀ x ∈ s, (p x 0).uncurry0 = f x) ∧\n        (∀ x ∈ s, has_fderiv_within_at (fun y => p y 0) (p x 1).curry_left s x) ∧\n          has_ftaylor_series_up_to_on n (fun x => continuous_multilinear_curry_fin1 𝕜 E F (p x 1))\n            (fun x => (p x).shift) s :=\n  by\n  constructor\n  · intro H\n    refine' ⟨H.zero_eq, H.fderiv_within 0 (WithTop.coe_lt_coe.2 (nat.succ_pos n)), _⟩\n    constructor\n    · intro x hx\n      rfl\n    · intro m(hm : (m : «exprℕ∞») < n)x(hx : x ∈ s)\n      have A : (m.succ : «exprℕ∞») < n.succ := by\n        rw [WithTop.coe_lt_coe] at hm⊢\n        exact nat.lt_succ_iff.mpr hm\n      change\n        has_fderiv_within_at ((continuous_multilinear_curry_right_equiv' 𝕜 m E F).symm ∘ fun y : E => p y m.succ)\n          (p x m.succ.succ).curry_right.curry_left s x\n      rw [linear_isometry_equiv.comp_has_fderiv_within_at_iff']\n      convert H.fderiv_within _ A x hx\n      ext (y v)\n      change (p x m.succ.succ) (snoc (cons y (init v)) (v (last _))) = (p x (nat.succ (nat.succ m))) (cons y v)\n      rw [← cons_snoc_eq_snoc_cons, snoc_init_self]\n    · intro m(hm : (m : «exprℕ∞») ≤ n)\n      have A : (m.succ : «exprℕ∞») ≤ n.succ := by\n        rw [WithTop.coe_le_coe] at hm⊢\n        exact nat.pred_le_iff.mp hm\n      change continuous_on ((continuous_multilinear_curry_right_equiv' 𝕜 m E F).symm ∘ fun y : E => p y m.succ) s\n      rw [linear_isometry_equiv.comp_continuous_on_iff]\n      exact H.cont _ A\n  · rintro ⟨Hzero_eq, Hfderiv_zero, Htaylor⟩\n    constructor\n    · exact Hzero_eq\n    · intro m(hm : (m : «exprℕ∞») < n.succ)x(hx : x ∈ s)\n      cases m\n      · exact Hfderiv_zero x hx\n      · have A : (m : «exprℕ∞») < n := by\n          rw [WithTop.coe_lt_coe] at hm⊢\n          exact nat.lt_of_succ_lt_succ hm\n        have :\n          has_fderiv_within_at ((continuous_multilinear_curry_right_equiv' 𝕜 m E F).symm ∘ fun y : E => p y m.succ)\n            ((p x).shift m.succ).curry_left s x :=\n          Htaylor.fderiv_within _ A x hx\n        rw [linear_isometry_equiv.comp_has_fderiv_within_at_iff'] at this\n        convert this\n        ext (y v)\n        change (p x (nat.succ (nat.succ m))) (cons y v) = (p x m.succ.succ) (snoc (cons y (init v)) (v (last _)))\n        rw [← cons_snoc_eq_snoc_cons, snoc_init_self]\n    · intro m(hm : (m : «exprℕ∞») ≤ n.succ)\n      cases m\n      · have : differentiable_on 𝕜 (fun x => p x 0) s := fun x hx => (Hfderiv_zero x hx).differentiable_within_at\n        exact this.continuous_on\n      · have A : (m : «exprℕ∞») ≤ n := by\n          rw [WithTop.coe_le_coe] at hm⊢\n          exact nat.lt_succ_iff.mp hm\n        have : continuous_on ((continuous_multilinear_curry_right_equiv' 𝕜 m E F).symm ∘ fun y : E => p y m.succ) s :=\n          Htaylor.cont _ A\n        rwa [linear_isometry_equiv.comp_continuous_on_iff] at this\n#align has_ftaylor_series_up_to_on_succ_iff_right has_ftaylor_series_up_to_on_succ_iff_right\n\n",
 "has_ftaylor_series_up_to_on_succ_iff_left":
 "/-- `p` is a Taylor series of `f` up to `n+1` if and only if `p` is a Taylor series up to `n`, and\n`p (n + 1)` is a derivative of `p n`. -/\ntheorem has_ftaylor_series_up_to_on_succ_iff_left {n : ℕ} :\n    has_ftaylor_series_up_to_on (n + 1) f p s ↔\n      has_ftaylor_series_up_to_on n f p s ∧\n        (∀ x ∈ s, has_fderiv_within_at (fun y => p y n) (p x n.succ).curry_left s x) ∧\n          continuous_on (fun x => p x (n + 1)) s :=\n  by\n  constructor\n  · intro h\n    exact\n      ⟨h.of_le (WithTop.coe_le_coe.2 (nat.le_succ n)), h.fderiv_within _ (WithTop.coe_lt_coe.2 (lt_add_one n)),\n        h.cont (n + 1) le_rfl⟩\n  · intro h\n    constructor\n    · exact h.1.zero_eq\n    · intro m hm\n      by_cases h' : m < n\n      · exact h.1.fderiv_within m (WithTop.coe_lt_coe.2 h')\n      · have : m = n := Nat.eq_of_lt_succ_of_not_lt (WithTop.coe_lt_coe.1 hm) h'\n        rw [this]\n        exact h.2.1\n    · intro m hm\n      by_cases h' : m ≤ n\n      · apply h.1.cont m (WithTop.coe_le_coe.2 h')\n      · have : m = n + 1 := le_antisymm (WithTop.coe_le_coe.1 hm) (not_le.1 h')\n        rw [this]\n        exact h.2.2\n#align has_ftaylor_series_up_to_on_succ_iff_left has_ftaylor_series_up_to_on_succ_iff_left\n\n",
 "has_ftaylor_series_up_to_on_pi'":
 "@[simp]\ntheorem has_ftaylor_series_up_to_on_pi' :\n    has_ftaylor_series_up_to_on n Φ P' s ↔\n      ∀ i,\n        has_ftaylor_series_up_to_on n (fun x => Φ x i)\n          (fun x m => (@continuous_linear_map.proj 𝕜 _ ι F' _ _ _ i).comp_continuous_multilinear_map (P' x m)) s :=\n  by\n  convert has_ftaylor_series_up_to_on_pi\n  ext\n  rfl\n#align has_ftaylor_series_up_to_on_pi' has_ftaylor_series_up_to_on_pi'\n\n",
 "has_ftaylor_series_up_to_on_pi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr [× ]→L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗᵢ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr [× ]→L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr [× ]→L[ ] » -/\ntheorem has_ftaylor_series_up_to_on_pi :\n    has_ftaylor_series_up_to_on n (fun x i => φ i x) (fun x m => continuous_multilinear_map.pi fun i => p' i x m) s ↔\n      ∀ i, has_ftaylor_series_up_to_on n (φ i) (p' i) s :=\n  by\n  set pr := @continuous_linear_map.proj 𝕜 _ ι F' _ _ _\n  letI : ∀ (m : ℕ) (i : ι), normed_space 𝕜 («expr [× ]→L[ ] » E m 𝕜 (F' i)) := fun m i => infer_instance\n  set L : ∀ m : ℕ, «expr ≃ₗᵢ[ ] » (∀ i, «expr [× ]→L[ ] » E m 𝕜 (F' i)) 𝕜 («expr [× ]→L[ ] » E m 𝕜 (∀ i, F' i)) :=\n    fun m => continuous_multilinear_map.piₗᵢ _ _\n  refine' ⟨fun h i => _, fun h => ⟨fun x hx => _, _, _⟩⟩\n  · convert h.continuous_linear_map_comp (pr i)\n    ext\n    rfl\n  · ext1 i\n    exact (h i).zero_eq x hx\n  · intro m hm x hx\n    have := has_fderiv_within_at_pi.2 fun i => (h i).fderiv_within m hm x hx\n    convert (L m).has_fderiv_at.comp_has_fderiv_within_at x this\n  · intro m hm\n    have := continuous_on_pi.2 fun i => (h i).cont m hm\n    convert (L m).continuous.comp_continuous_on this\n#align has_ftaylor_series_up_to_on_pi has_ftaylor_series_up_to_on_pi\n\n",
 "has_ftaylor_series_up_to_on":
 "theorem has_ftaylor_series_up_to.has_ftaylor_series_up_to_on (h : has_ftaylor_series_up_to n f p) (s : set E) :\n    has_ftaylor_series_up_to_on n f p s :=\n  (has_ftaylor_series_up_to_on_univ_iff.2 h).mono (subset_univ _)\n#align has_ftaylor_series_up_to.has_ftaylor_series_up_to_on has_ftaylor_series_up_to.has_ftaylor_series_up_to_on\n\n",
 "has_fderiv_within_at":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ∞» -/\n/-- If a function has a Taylor series at order at least `1`, then the term of order `1` of this\nseries is a derivative of `f`. -/\ntheorem has_ftaylor_series_up_to_on.has_fderiv_within_at (h : has_ftaylor_series_up_to_on n f p s) (hn : 1 ≤ n)\n    (hx : x ∈ s) : has_fderiv_within_at f (continuous_multilinear_curry_fin1 𝕜 E F (p x 1)) s x :=\n  by\n  have A : ∀ y ∈ s, f y = (continuous_multilinear_curry_fin0 𝕜 E F) (p y 0) :=\n    by\n    intro y hy\n    rw [← h.zero_eq y hy]\n    rfl\n  suffices H :\n    has_fderiv_within_at (fun y => continuous_multilinear_curry_fin0 𝕜 E F (p y 0))\n      (continuous_multilinear_curry_fin1 𝕜 E F (p x 1)) s x\n  · exact H.congr A (A x hx)\n  rw [linear_isometry_equiv.comp_has_fderiv_within_at_iff']\n  have : ((0 : ℕ) : «exprℕ∞») < n := lt_of_lt_of_le (WithTop.coe_lt_coe.2 nat.zero_lt_one) hn\n  convert h.fderiv_within _ this x hx\n  ext (y v)\n  change (p x 1) (snoc 0 y) = (p x 1) (cons y v)\n  unfold_coes\n  congr with i\n  rw [unique.eq_default i]\n  rfl\n#align has_ftaylor_series_up_to_on.has_fderiv_within_at has_ftaylor_series_up_to_on.has_fderiv_within_at\n\n",
 "has_fderiv_at":
 "/-- If a function has a Taylor series at order at least `1`, then the term of order `1` of this\nseries is a derivative of `f`. -/\ntheorem has_ftaylor_series_up_to.has_fderiv_at (h : has_ftaylor_series_up_to n f p) (hn : 1 ≤ n) (x : E) :\n    has_fderiv_at f (continuous_multilinear_curry_fin1 𝕜 E F (p x 1)) x :=\n  by\n  rw [← has_fderiv_within_at_univ]\n  exact (has_ftaylor_series_up_to_on_univ_iff.2 h).has_fderiv_within_at hn (mem_univ _)\n#align has_ftaylor_series_up_to.has_fderiv_at has_ftaylor_series_up_to.has_fderiv_at\n\n",
 "ftaylor_series_within_univ":
 "theorem ftaylor_series_within_univ : ftaylor_series_within 𝕜 f univ = ftaylor_series 𝕜 f :=\n  by\n  ext1 x; ext1 n\n  change iterated_fderiv_within 𝕜 n f univ x = iterated_fderiv 𝕜 n f x\n  rw [iterated_fderiv_within_univ]\n#align ftaylor_series_within_univ ftaylor_series_within_univ\n\n",
 "ftaylor_series_within":
 "/-- When a function is `C^n` in a set `s` of unique differentiability, it admits\n`ftaylor_series_within 𝕜 f s` as a Taylor series up to order `n` in `s`. -/\ntheorem cont_diff_on.ftaylor_series_within (h : cont_diff_on 𝕜 n f s) (hs : unique_diff_on 𝕜 s) :\n    has_ftaylor_series_up_to_on n f (ftaylor_series_within 𝕜 f s) s :=\n  by\n  constructor\n  · intro x hx\n    simp only [ftaylor_series_within, continuous_multilinear_map.uncurry0_apply, iterated_fderiv_within_zero_apply]\n  · intro m hm x hx\n    rcases(h x hx) m.succ (enat.add_one_le_of_lt hm) with ⟨u, hu, p, Hp⟩\n    rw [insert_eq_of_mem hx] at hu\n    rcases mem_nhds_within.1 hu with ⟨o, o_open, xo, ho⟩\n    rw [inter_comm] at ho\n    have : p x m.succ = ftaylor_series_within 𝕜 f s x m.succ :=\n      by\n      change p x m.succ = iterated_fderiv_within 𝕜 m.succ f s x\n      rw [← iterated_fderiv_within_inter (is_open.mem_nhds o_open xo) hs hx]\n      exact (Hp.mono ho).eq_ftaylor_series_of_unique_diff_on le_rfl (hs.inter o_open) ⟨hx, xo⟩\n    rw [← this, ← has_fderiv_within_at_inter (is_open.mem_nhds o_open xo)]\n    have A : ∀ y ∈ s ∩ o, p y m = ftaylor_series_within 𝕜 f s y m :=\n      by\n      rintro y ⟨hy, yo⟩\n      change p y m = iterated_fderiv_within 𝕜 m f s y\n      rw [← iterated_fderiv_within_inter (is_open.mem_nhds o_open yo) hs hy]\n      exact\n        (Hp.mono ho).eq_ftaylor_series_of_unique_diff_on (WithTop.coe_le_coe.2 (nat.le_succ m)) (hs.inter o_open)\n          ⟨hy, yo⟩\n    exact\n      ((Hp.mono ho).fderiv_within m (WithTop.coe_lt_coe.2 (lt_add_one m)) x ⟨hx, xo⟩).congr (fun y hy => (A y hy).symm)\n        (A x ⟨hx, xo⟩).symm\n  · intro m hm\n    apply continuous_on_of_locally_continuous_on\n    intro x hx\n    rcases h x hx m hm with ⟨u, hu, p, Hp⟩\n    rcases mem_nhds_within.1 hu with ⟨o, o_open, xo, ho⟩\n    rw [insert_eq_of_mem hx] at ho\n    rw [inter_comm] at ho\n    refine' ⟨o, o_open, xo, _⟩\n    have A : ∀ y ∈ s ∩ o, p y m = ftaylor_series_within 𝕜 f s y m :=\n      by\n      rintro y ⟨hy, yo⟩\n      change p y m = iterated_fderiv_within 𝕜 m f s y\n      rw [← iterated_fderiv_within_inter (is_open.mem_nhds o_open yo) hs hy]\n      exact (Hp.mono ho).eq_ftaylor_series_of_unique_diff_on le_rfl (hs.inter o_open) ⟨hy, yo⟩\n    exact ((Hp.mono ho).cont m le_rfl).congr fun y hy => (A y hy).symm\n#align cont_diff_on.ftaylor_series_within cont_diff_on.ftaylor_series_within\n\n",
 "fst''":
 "/-- Precomposing `f` with `prod.fst` is `C^n` at `x : E × F` -/\ntheorem cont_diff_at.fst'' {f : E → G} {x : E × F} (hf : cont_diff_at 𝕜 n f x.1) :\n    cont_diff_at 𝕜 n (fun x : E × F => f x.1) x :=\n  hf.comp x cont_diff_at_fst\n#align cont_diff_at.fst'' cont_diff_at.fst''\n\n",
 "fst'":
 "/-- Precomposing `f` with `prod.fst` is `C^n` at `(x, y)` -/\ntheorem cont_diff_at.fst' {f : E → G} {x : E} {y : F} (hf : cont_diff_at 𝕜 n f x) :\n    cont_diff_at 𝕜 n (fun x : E × F => f x.1) (x, y) :=\n  cont_diff_at.comp (x, y) hf cont_diff_at_fst\n#align cont_diff_at.fst' cont_diff_at.fst'\n\n",
 "fst":
 "/-- Postcomposing `f` with `prod.fst` is `C^n` at `(x, y)` -/\ntheorem cont_diff_at.fst {f : E → F × G} {x : E} (hf : cont_diff_at 𝕜 n f x) : cont_diff_at 𝕜 n (fun x => (f x).1) x :=\n  cont_diff_at_fst.comp x hf\n#align cont_diff_at.fst cont_diff_at.fst\n\n",
 "fderiv_within'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ∞» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\ntheorem cont_diff_within_at.fderiv_within' (hf : cont_diff_within_at 𝕜 n f s x)\n    (hs :\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\"\n        (nhds_within (insert x s) x) (unique_diff_within_at 𝕜 s y))\n    (hmn : m + 1 ≤ n) : cont_diff_within_at 𝕜 m (fderiv_within 𝕜 f s) s x :=\n  by\n  have : ∀ k : ℕ, (k + 1 : «exprℕ∞») ≤ n → cont_diff_within_at 𝕜 k (fderiv_within 𝕜 f s) s x :=\n    by\n    intro k hkn\n    obtain ⟨v, hv, -, f', hvf', hf'⟩ := cont_diff_within_at_succ_iff_has_fderiv_within_at'.mp (hf.of_le hkn)\n    apply hf'.congr_of_eventually_eq_insert\n    filter_upwards [hv, hs]\n    exact fun y hy h2y => (hvf' y hy).fderiv_within h2y\n  induction m using WithTop.recTopCoe\n  · obtain rfl := eq_top_iff.mpr hmn\n    rw [cont_diff_within_at_top]\n    exact fun m => this m le_top\n  exact this m hmn\n#align cont_diff_within_at.fderiv_within' cont_diff_within_at.fderiv_within'\n\n",
 "fderiv_within":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ∞» -/\ntheorem cont_diff_within_at.fderiv_within (hf : cont_diff_within_at 𝕜 n f s x) (hs : unique_diff_on 𝕜 s)\n    (hmn : (m + 1 : «exprℕ∞») ≤ n) (hxs : x ∈ s) : cont_diff_within_at 𝕜 m (fderiv_within 𝕜 f s) s x :=\n  hf.fderiv_within'\n    (by\n      rw [insert_eq_of_mem hxs]\n      exact eventually_of_mem self_mem_nhds_within hs)\n    hmn\n#align cont_diff_within_at.fderiv_within cont_diff_within_at.fderiv_within\n\n",
 "fderiv_of_open":
 "theorem cont_diff_on.fderiv_of_open (hf : cont_diff_on 𝕜 n f s) (hs : is_open s) (hmn : m + 1 ≤ n) :\n    cont_diff_on 𝕜 m (fun y => fderiv 𝕜 f y) s :=\n  (hf.fderiv_within hs.unique_diff_on hmn).congr fun x hx => (fderiv_within_of_open hs hx).symm\n#align cont_diff_on.fderiv_of_open cont_diff_on.fderiv_of_open\n\n",
 "fderiv_iterated_fderiv":
 "/-- Writing explicitly the derivative of the `n`-th derivative as the composition of a currying\nlinear equiv, and the `n + 1`-th derivative. -/\ntheorem fderiv_iterated_fderiv {n : ℕ} :\n    fderiv 𝕜 (iterated_fderiv 𝕜 n f) =\n      (continuous_multilinear_curry_left_equiv 𝕜 (fun i : fin (n + 1) => E) F).symm ∘ iterated_fderiv 𝕜 (n + 1) f :=\n  by\n  rw [iterated_fderiv_succ_eq_comp_left]\n  ext1 x\n  simp only [Function.comp_apply, linear_isometry_equiv.symm_apply_apply]\n#align fderiv_iterated_fderiv fderiv_iterated_fderiv\n\n",
 "exists_lipschitz_on_with_of_nnnorm_lt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- If `f` is `C^1` at `x` and `K > ‖fderiv 𝕂 f x‖`, then `f` is `K`-Lipschitz in a neighborhood of\n`x`. -/\ntheorem cont_diff_at.exists_lipschitz_on_with_of_nnnorm_lt {f : E' → F'} {x : E'} (hf : cont_diff_at 𝕂 1 f x)\n    (K : nnreal) (hK : «expr‖ ‖₊» (fderiv 𝕂 f x) < K) : ∃ t ∈ (nhds) x, lipschitz_on_with K f t :=\n  (hf.has_strict_fderiv_at le_rfl).exists_lipschitz_on_with_of_nnnorm_lt K hK\n#align cont_diff_at.exists_lipschitz_on_with_of_nnnorm_lt cont_diff_at.exists_lipschitz_on_with_of_nnnorm_lt\n\n",
 "exists_lipschitz_on_with":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- If `f` is `C^1` at `x`, then `f` is Lipschitz in a neighborhood of `x`. -/\ntheorem cont_diff_at.exists_lipschitz_on_with {f : E' → F'} {x : E'} (hf : cont_diff_at 𝕂 1 f x) :\n    ∃ K, ∃ t ∈ (nhds) x, lipschitz_on_with K f t :=\n  (hf.has_strict_fderiv_at le_rfl).exists_lipschitz_on_with\n#align cont_diff_at.exists_lipschitz_on_with cont_diff_at.exists_lipschitz_on_with\n\n",
 "eventually_has_fderiv_at":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- If a function has a Taylor series at order at least `1` on a neighborhood of `x`, then\nin a neighborhood of `x`, the term of order `1` of this series is a derivative of `f`. -/\ntheorem has_ftaylor_series_up_to_on.eventually_has_fderiv_at (h : has_ftaylor_series_up_to_on n f p s) (hn : 1 ≤ n)\n    (hx : s ∈ (nhds) x) :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" ((nhds) x)\n      (has_fderiv_at f (continuous_multilinear_curry_fin1 𝕜 E F (p y 1)) y) :=\n  (eventually_eventually_nhds.2 hx).mono fun y hy => h.has_fderiv_at hn hy\n#align has_ftaylor_series_up_to_on.eventually_has_fderiv_at has_ftaylor_series_up_to_on.eventually_has_fderiv_at\n\n",
 "eventually":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\nprotected theorem cont_diff_at.eventually {n : ℕ} (h : cont_diff_at 𝕜 n f x) :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" ((nhds) x)\n      (cont_diff_at 𝕜 n f y) :=\n  by simpa [nhds_within_univ] using h.eventually\n#align cont_diff_at.eventually cont_diff_at.eventually\n\n",
 "eq_ftaylor_series_of_unique_diff_on":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ∞» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ∞» -/\n/-- On a set with unique differentiability, any choice of iterated differential has to coincide\nwith the one we have chosen in `iterated_fderiv_within 𝕜 m f s`. -/\ntheorem has_ftaylor_series_up_to_on.eq_ftaylor_series_of_unique_diff_on (h : has_ftaylor_series_up_to_on n f p s)\n    {m : ℕ} (hmn : (m : «exprℕ∞») ≤ n) (hs : unique_diff_on 𝕜 s) (hx : x ∈ s) :\n    p x m = iterated_fderiv_within 𝕜 m f s x :=\n  by\n  induction' m with m IH generalizing x\n  · rw [h.zero_eq' hx, iterated_fderiv_within_zero_eq_comp]\n  · have A : (m : «exprℕ∞») < n := lt_of_lt_of_le (WithTop.coe_lt_coe.2 (lt_add_one m)) hmn\n    have :\n      has_fderiv_within_at (fun y : E => iterated_fderiv_within 𝕜 m f s y)\n        (continuous_multilinear_map.curry_left (p x (nat.succ m))) s x :=\n      (h.fderiv_within m A x hx).congr (fun y hy => (IH (le_of_lt A) hy).symm) (IH (le_of_lt A) hx).symm\n    rw [iterated_fderiv_within_succ_eq_comp_left, function.comp_apply, this.fderiv_within (hs x hx)]\n    exact (continuous_multilinear_map.uncurry_curry_left _).symm\n#align\n  has_ftaylor_series_up_to_on.eq_ftaylor_series_of_unique_diff_on has_ftaylor_series_up_to_on.eq_ftaylor_series_of_unique_diff_on\n\n",
 "div_const":
 "theorem cont_diff.div_const {f : E → 𝕜'} {n} {c : 𝕜'} (hf : cont_diff 𝕜 n f) : cont_diff 𝕜 n fun x => f x / c := by\n  simpa only [div_eq_mul_inv] using hf.mul cont_diff_const\n#align cont_diff.div_const cont_diff.div_const\n\n",
 "div":
 "theorem cont_diff.div [complete_space 𝕜] {f g : E → 𝕜} {n} (hf : cont_diff 𝕜 n f) (hg : cont_diff 𝕜 n g)\n    (h0 : ∀ x, g x ≠ 0) : cont_diff 𝕜 n fun x => f x / g x :=\n  by\n  simp only [cont_diff_iff_cont_diff_at] at *\n  exact fun x => (hf x).div (hg x) (h0 x)\n#align cont_diff.div cont_diff.div\n\n",
 "differentiable_within_at'":
 "/-- If a function is `C^n` within a set at a point, with `n ≥ 1`, then it is differentiable\nwithin this set at this point. -/\ntheorem cont_diff_within_at.differentiable_within_at' (h : cont_diff_within_at 𝕜 n f s x) (hn : 1 ≤ n) :\n    differentiable_within_at 𝕜 f (insert x s) x :=\n  by\n  rcases h 1 hn with ⟨u, hu, p, H⟩\n  rcases mem_nhds_within.1 hu with ⟨t, t_open, xt, tu⟩\n  rw [inter_comm] at tu\n  have := ((H.mono tu).differentiable_on le_rfl) x ⟨mem_insert x s, xt⟩\n  exact (differentiable_within_at_inter (is_open.mem_nhds t_open xt)).1 this\n#align cont_diff_within_at.differentiable_within_at' cont_diff_within_at.differentiable_within_at'\n\n",
 "differentiable_within_at":
 "theorem cont_diff_within_at.differentiable_within_at (h : cont_diff_within_at 𝕜 n f s x) (hn : 1 ≤ n) :\n    differentiable_within_at 𝕜 f s x :=\n  (h.differentiable_within_at' hn).mono (subset_insert x s)\n#align cont_diff_within_at.differentiable_within_at cont_diff_within_at.differentiable_within_at\n\n",
 "differentiable_on_iterated_fderiv_within":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ∞» -/\ntheorem cont_diff_on.differentiable_on_iterated_fderiv_within {m : ℕ} (h : cont_diff_on 𝕜 n f s)\n    (hmn : (m : «exprℕ∞») < n) (hs : unique_diff_on 𝕜 s) : differentiable_on 𝕜 (iterated_fderiv_within 𝕜 m f s) s :=\n  fun x hx => ((h.ftaylor_series_within hs).fderiv_within m hmn x hx).differentiable_within_at\n#align cont_diff_on.differentiable_on_iterated_fderiv_within cont_diff_on.differentiable_on_iterated_fderiv_within\n\n",
 "differentiable_on":
 "/-- If a function is `C^n` on a set with `n ≥ 1`, then it is differentiable there. -/\ntheorem cont_diff_on.differentiable_on (h : cont_diff_on 𝕜 n f s) (hn : 1 ≤ n) : differentiable_on 𝕜 f s := fun x hx =>\n  (h x hx).differentiable_within_at hn\n#align cont_diff_on.differentiable_on cont_diff_on.differentiable_on\n\n",
 "differentiable_iterated_fderiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ∞» -/\n/-- If `f` is `C^n` then its `m`-times iterated derivative is differentiable for `m < n`. -/\ntheorem cont_diff.differentiable_iterated_fderiv {m : ℕ} (hm : (m : «exprℕ∞») < n) (hf : cont_diff 𝕜 n f) :\n    differentiable 𝕜 fun x => iterated_fderiv 𝕜 m f x :=\n  (cont_diff_iff_continuous_differentiable.mp hf).2 m hm\n#align cont_diff.differentiable_iterated_fderiv cont_diff.differentiable_iterated_fderiv\n\n",
 "differentiable_at":
 "/-- If a function is `C^n` with `n ≥ 1` at a point, then it is differentiable there. -/\ntheorem cont_diff_at.differentiable_at (h : cont_diff_at 𝕜 n f x) (hn : 1 ≤ n) : differentiable_at 𝕜 f x := by\n  simpa [hn, differentiable_within_at_univ] using h.differentiable_within_at\n#align cont_diff_at.differentiable_at cont_diff_at.differentiable_at\n\n",
 "differentiable":
 "/-- If a function is `C^n` with `n ≥ 1`, then it is differentiable. -/\ntheorem cont_diff.differentiable (h : cont_diff 𝕜 n f) (hn : 1 ≤ n) : differentiable 𝕜 f :=\n  differentiable_on_univ.1 <| (cont_diff_on_univ.2 h).differentiable_on hn\n#align cont_diff.differentiable cont_diff.differentiable\n\n",
 "deriv_within":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∞» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∞» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ∞» -/\ntheorem cont_diff_on.deriv_within (hf : cont_diff_on 𝕜 n f₂ s₂) (hs : unique_diff_on 𝕜 s₂) (hmn : m + 1 ≤ n) :\n    cont_diff_on 𝕜 m (deriv_within f₂ s₂) s₂ := by\n  cases m\n  · change «expr∞» + 1 ≤ n at hmn\n    have : n = «expr∞» := by simpa using hmn\n    rw [this] at hf\n    exact ((cont_diff_on_top_iff_deriv_within hs).1 hf).2\n  · change (m.succ : «exprℕ∞») ≤ n at hmn\n    exact ((cont_diff_on_succ_iff_deriv_within hs).1 (hf.of_le hmn)).2\n#align cont_diff_on.deriv_within cont_diff_on.deriv_within\n\n",
 "deriv_of_open":
 "theorem cont_diff_on.deriv_of_open (hf : cont_diff_on 𝕜 n f₂ s₂) (hs : is_open s₂) (hmn : m + 1 ≤ n) :\n    cont_diff_on 𝕜 m (deriv f₂) s₂ :=\n  (hf.deriv_within hs.unique_diff_on hmn).congr fun x hx => (deriv_within_of_open hs hx).symm\n#align cont_diff_on.deriv_of_open cont_diff_on.deriv_of_open\n\n",
 "continuous_within_at":
 "theorem cont_diff_within_at.continuous_within_at (h : cont_diff_within_at 𝕜 n f s x) : continuous_within_at f s x :=\n  by\n  rcases h 0 bot_le with ⟨u, hu, p, H⟩\n  rw [mem_nhds_within_insert] at hu\n  exact (H.continuous_on.continuous_within_at hu.1).mono_of_mem hu.2\n#align cont_diff_within_at.continuous_within_at cont_diff_within_at.continuous_within_at\n\n",
 "continuous_on_iterated_fderiv_within":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ∞» -/\ntheorem cont_diff_on.continuous_on_iterated_fderiv_within {m : ℕ} (h : cont_diff_on 𝕜 n f s) (hmn : (m : «exprℕ∞») ≤ n)\n    (hs : unique_diff_on 𝕜 s) : continuous_on (iterated_fderiv_within 𝕜 m f s) s :=\n  (h.ftaylor_series_within hs).cont m hmn\n#align cont_diff_on.continuous_on_iterated_fderiv_within cont_diff_on.continuous_on_iterated_fderiv_within\n\n",
 "continuous_on_fderiv_within_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n/-- If a function is at least `C^1`, its bundled derivative (mapping `(x, v)` to `Df(x) v`) is\ncontinuous. -/\ntheorem cont_diff_on.continuous_on_fderiv_within_apply (hf : cont_diff_on 𝕜 n f s) (hs : unique_diff_on 𝕜 s)\n    (hn : 1 ≤ n) : continuous_on (fun p : E × E => (fderiv_within 𝕜 f s p.1 : E → F) p.2) (lower_set.prod s univ) :=\n  (cont_diff_on_fderiv_within_apply hf hs <| by rwa [zero_add]).continuous_on\n#align cont_diff_on.continuous_on_fderiv_within_apply cont_diff_on.continuous_on_fderiv_within_apply\n\n",
 "continuous_on_fderiv_within":
 "theorem cont_diff_on.continuous_on_fderiv_within (h : cont_diff_on 𝕜 n f s) (hs : unique_diff_on 𝕜 s) (hn : 1 ≤ n) :\n    continuous_on (fun x => fderiv_within 𝕜 f s x) s :=\n  ((cont_diff_on_succ_iff_fderiv_within hs).1 (h.of_le hn)).2.continuous_on\n#align cont_diff_on.continuous_on_fderiv_within cont_diff_on.continuous_on_fderiv_within\n\n",
 "continuous_on_fderiv_of_open":
 "theorem cont_diff_on.continuous_on_fderiv_of_open (h : cont_diff_on 𝕜 n f s) (hs : is_open s) (hn : 1 ≤ n) :\n    continuous_on (fun x => fderiv 𝕜 f x) s :=\n  ((cont_diff_on_succ_iff_fderiv_of_open hs).1 (h.of_le hn)).2.continuous_on\n#align cont_diff_on.continuous_on_fderiv_of_open cont_diff_on.continuous_on_fderiv_of_open\n\n",
 "continuous_on_deriv_within":
 "theorem cont_diff_on.continuous_on_deriv_within (h : cont_diff_on 𝕜 n f₂ s₂) (hs : unique_diff_on 𝕜 s₂) (hn : 1 ≤ n) :\n    continuous_on (deriv_within f₂ s₂) s₂ :=\n  ((cont_diff_on_succ_iff_deriv_within hs).1 (h.of_le hn)).2.continuous_on\n#align cont_diff_on.continuous_on_deriv_within cont_diff_on.continuous_on_deriv_within\n\n",
 "continuous_on_deriv_of_open":
 "theorem cont_diff_on.continuous_on_deriv_of_open (h : cont_diff_on 𝕜 n f₂ s₂) (hs : is_open s₂) (hn : 1 ≤ n) :\n    continuous_on (deriv f₂) s₂ :=\n  ((cont_diff_on_succ_iff_deriv_of_open hs).1 (h.of_le hn)).2.continuous_on\n#align cont_diff_on.continuous_on_deriv_of_open cont_diff_on.continuous_on_deriv_of_open\n\n",
 "continuous_on":
 "theorem cont_diff_on.continuous_on (h : cont_diff_on 𝕜 n f s) : continuous_on f s := fun x hx =>\n  (h x hx).continuous_within_at\n#align cont_diff_on.continuous_on cont_diff_on.continuous_on\n\n",
 "continuous_linear_map_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/-- Composition by continuous linear maps on the left preserves `C^n` functions. -/\ntheorem cont_diff.continuous_linear_map_comp {f : E → F} (g : «expr →L[ ] » F 𝕜 G) (hf : cont_diff 𝕜 n f) :\n    cont_diff 𝕜 n fun x => g (f x) :=\n  cont_diff_on_univ.1 <| cont_diff_on.continuous_linear_map_comp _ (cont_diff_on_univ.2 hf)\n#align cont_diff.continuous_linear_map_comp cont_diff.continuous_linear_map_comp\n\n",
 "continuous_iterated_fderiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ∞» -/\n/-- If `f` is `C^n` then its `m`-times iterated derivative is continuous for `m ≤ n`. -/\ntheorem cont_diff.continuous_iterated_fderiv {m : ℕ} (hm : (m : «exprℕ∞») ≤ n) (hf : cont_diff 𝕜 n f) :\n    continuous fun x => iterated_fderiv 𝕜 m f x :=\n  (cont_diff_iff_continuous_differentiable.mp hf).1 m hm\n#align cont_diff.continuous_iterated_fderiv cont_diff.continuous_iterated_fderiv\n\n",
 "continuous_fderiv_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/-- If a function is at least `C^1`, its bundled derivative (mapping `(x, v)` to `Df(x) v`) is\ncontinuous. -/\ntheorem cont_diff.continuous_fderiv_apply (h : cont_diff 𝕜 n f) (hn : 1 ≤ n) :\n    continuous fun p : E × E => (fderiv 𝕜 f p.1 : E → F) p.2 :=\n  have A : continuous fun q : «expr →L[ ] » E 𝕜 F × E => q.1 q.2 := is_bounded_bilinear_map_apply.continuous\n  have B : continuous fun p : E × E => (fderiv 𝕜 f p.1, p.2) :=\n    ((h.continuous_fderiv hn).comp continuous_fst).prod_mk continuous_snd\n  A.comp B\n#align cont_diff.continuous_fderiv_apply cont_diff.continuous_fderiv_apply\n\n",
 "continuous_fderiv":
 "theorem cont_diff.continuous_fderiv (h : cont_diff 𝕜 n f) (hn : 1 ≤ n) : continuous fun x => fderiv 𝕜 f x :=\n  (cont_diff_succ_iff_fderiv.1 (h.of_le hn)).2.continuous\n#align cont_diff.continuous_fderiv cont_diff.continuous_fderiv\n\n",
 "continuous_deriv":
 "theorem cont_diff.continuous_deriv (h : cont_diff 𝕜 n f₂) (hn : 1 ≤ n) : continuous (deriv f₂) :=\n  (cont_diff_succ_iff_deriv.mp (h.of_le hn)).2.continuous\n#align cont_diff.continuous_deriv cont_diff.continuous_deriv\n\n",
 "continuous_at":
 "theorem cont_diff_at.continuous_at (h : cont_diff_at 𝕜 n f x) : continuous_at f x := by\n  simpa [continuous_within_at_univ] using h.continuous_within_at\n#align cont_diff_at.continuous_at cont_diff_at.continuous_at\n\n",
 "continuous":
 "theorem cont_diff.continuous (h : cont_diff 𝕜 n f) : continuous f :=\n  cont_diff_zero.1 (h.of_le bot_le)\n#align cont_diff.continuous cont_diff.continuous\n\n",
 "cont_diff_zero_fun":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr [× ]→L[ ] » -/\ntheorem cont_diff_zero_fun : cont_diff 𝕜 n fun x : E => (0 : F) :=\n  by\n  apply cont_diff_of_differentiable_iterated_fderiv fun m hm => _\n  rw [iterated_fderiv_zero_fun]\n  exact differentiable_const (0 : «expr [× ]→L[ ] » E m 𝕜 F)\n#align cont_diff_zero_fun cont_diff_zero_fun\n\n",
 "cont_diff_zero":
 "@[simp]\ntheorem cont_diff_zero : cont_diff 𝕜 0 f ↔ continuous f :=\n  by\n  rw [← cont_diff_on_univ, continuous_iff_continuous_on_univ]\n  exact cont_diff_on_zero\n#align cont_diff_zero cont_diff_zero\n\n",
 "cont_diff_within_at_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\ntheorem cont_diff_within_at_zero (hx : x ∈ s) :\n    cont_diff_within_at 𝕜 0 f s x ↔ ∃ u ∈ nhds_within s x, continuous_on f (s ∩ u) :=\n  by\n  constructor\n  · intro h\n    obtain ⟨u, H, p, hp⟩ := h 0 (by norm_num)\n    refine' ⟨u, _, _⟩\n    · simpa [hx] using H\n    · simp only [with_top.coe_zero, has_ftaylor_series_up_to_on_zero_iff] at hp\n      exact hp.1.mono (inter_subset_right s u)\n  · rintro ⟨u, H, hu⟩\n    rw [← cont_diff_within_at_inter' H]\n    have h' : x ∈ s ∩ u := ⟨hx, mem_of_mem_nhds_within hx H⟩\n    exact (cont_diff_on_zero.mpr hu).cont_diff_within_at h'\n#align cont_diff_within_at_zero cont_diff_within_at_zero\n\n",
 "cont_diff_within_at_univ":
 "theorem cont_diff_within_at_univ : cont_diff_within_at 𝕜 n f univ x ↔ cont_diff_at 𝕜 n f x :=\n  iff.rfl\n#align cont_diff_within_at_univ cont_diff_within_at_univ\n\n",
 "cont_diff_within_at_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∞» -/\ntheorem cont_diff_within_at_top : cont_diff_within_at 𝕜 («expr∞») f s x ↔ ∀ n : ℕ, cont_diff_within_at 𝕜 n f s x :=\n  cont_diff_within_at_iff_forall_nat_le.trans <| by simp only [forall_prop_of_true, le_top]\n#align cont_diff_within_at_top cont_diff_within_at_top\n\n",
 "cont_diff_within_at_succ_iff_has_fderiv_within_at'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/-- A version of `cont_diff_within_at_succ_iff_has_fderiv_within_at` where all derivatives\n  are taken within the same set. -/\ntheorem cont_diff_within_at_succ_iff_has_fderiv_within_at' {n : ℕ} :\n    cont_diff_within_at 𝕜 (n + 1 : ℕ) f s x ↔\n      ∃ u ∈ nhds_within (insert x s) x,\n        u ⊆ insert x s ∧\n          ∃ f' : E → «expr →L[ ] » E 𝕜 F,\n            (∀ x ∈ u, has_fderiv_within_at f (f' x) s x) ∧ cont_diff_within_at 𝕜 n f' s x :=\n  by\n  refine' ⟨fun hf => _, _⟩\n  · obtain ⟨u, hu, f', huf', hf'⟩ := cont_diff_within_at_succ_iff_has_fderiv_within_at.mp hf\n    obtain ⟨w, hw, hxw, hwu⟩ := mem_nhds_within.mp hu\n    rw [inter_comm] at hwu\n    refine' ⟨insert x s ∩ w, inter_mem_nhds_within _ (hw.mem_nhds hxw), inter_subset_left _ _, f', fun y hy => _, _⟩\n    · refine' ((huf' y <| hwu hy).mono hwu).mono_of_mem _\n      refine' mem_of_superset _ (inter_subset_inter_left _ (subset_insert _ _))\n      refine' inter_mem_nhds_within _ (hw.mem_nhds hy.2)\n    · exact hf'.mono_of_mem (nhds_within_mono _ (subset_insert _ _) hu)\n  · rw [← cont_diff_within_at_insert, cont_diff_within_at_succ_iff_has_fderiv_within_at,\n      insert_eq_of_mem (mem_insert _ _)]\n    rintro ⟨u, hu, hus, f', huf', hf'⟩\n    refine' ⟨u, hu, f', fun y hy => (huf' y hy).insert'.mono hus, hf'.insert.mono hus⟩\n#align cont_diff_within_at_succ_iff_has_fderiv_within_at' cont_diff_within_at_succ_iff_has_fderiv_within_at'\n\n",
 "cont_diff_within_at_succ_iff_has_fderiv_within_at":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/-- A function is `C^(n + 1)` on a domain iff locally, it has a derivative which is `C^n`. -/\ntheorem cont_diff_within_at_succ_iff_has_fderiv_within_at {n : ℕ} :\n    cont_diff_within_at 𝕜 (n + 1 : ℕ) f s x ↔\n      ∃ u ∈ nhds_within (insert x s) x,\n        ∃ f' : E → «expr →L[ ] » E 𝕜 F, (∀ x ∈ u, has_fderiv_within_at f (f' x) u x) ∧ cont_diff_within_at 𝕜 n f' u x :=\n  by\n  constructor\n  · intro h\n    rcases h n.succ le_rfl with ⟨u, hu, p, Hp⟩\n    refine'\n      ⟨u, hu, fun y => (continuous_multilinear_curry_fin1 𝕜 E F) (p y 1), fun y hy =>\n        Hp.has_fderiv_within_at (WithTop.coe_le_coe.2 (nat.le_add_left 1 n)) hy, _⟩\n    intro m hm\n    refine' ⟨u, _, fun y : E => (p y).shift, _⟩\n    · convert self_mem_nhds_within\n      have : x ∈ insert x s := by simp\n      exact insert_eq_of_mem (mem_of_mem_nhds_within this hu)\n    · rw [has_ftaylor_series_up_to_on_succ_iff_right] at Hp\n      exact Hp.2.2.of_le hm\n  · rintro ⟨u, hu, f', f'_eq_deriv, Hf'⟩\n    rw [cont_diff_within_at_nat]\n    rcases Hf' n le_rfl with ⟨v, hv, p', Hp'⟩\n    refine' ⟨v ∩ u, _, fun x => (p' x).unshift (f x), _⟩\n    · apply filter.inter_mem _ hu\n      apply nhds_within_le_of_mem hu\n      exact nhds_within_mono _ (subset_insert x u) hv\n    · rw [has_ftaylor_series_up_to_on_succ_iff_right]\n      refine' ⟨fun y hy => rfl, fun y hy => _, _⟩\n      · change\n          has_fderiv_within_at (fun z => (continuous_multilinear_curry_fin0 𝕜 E F).symm (f z))\n            (formal_multilinear_series.unshift (p' y) (f y) 1).curry_left (v ∩ u) y\n        rw [linear_isometry_equiv.comp_has_fderiv_within_at_iff']\n        convert (f'_eq_deriv y hy.2).mono (inter_subset_right v u)\n        rw [← Hp'.zero_eq y hy.1]\n        ext z\n        change ((p' y 0) (init (@cons 0 (fun i => E) z 0))) (@cons 0 (fun i => E) z 0 (last 0)) = ((p' y 0) 0) z\n        unfold_coes\n        congr\n      · convert (Hp'.mono (inter_subset_left v u)).congr fun x hx => Hp'.zero_eq x hx.1\n        · ext (x y)\n          change p' x 0 (init (@snoc 0 (fun i : fin 1 => E) 0 y)) y = p' x 0 0 y\n          rw [init_snoc]\n        · ext (x k v y)\n          change\n            p' x k (init (@snoc k (fun i : fin k.succ => E) v y)) (@snoc k (fun i : fin k.succ => E) v y (last k)) =\n              p' x k v y\n          rw [snoc_last, init_snoc]\n#align cont_diff_within_at_succ_iff_has_fderiv_within_at cont_diff_within_at_succ_iff_has_fderiv_within_at\n\n",
 "cont_diff_within_at_snd":
 "/-- The second projection within a domain at a point in a product is `C^∞`. -/\ntheorem cont_diff_within_at_snd {s : set (E × F)} {p : E × F} : cont_diff_within_at 𝕜 n (prod.snd : E × F → F) s p :=\n  cont_diff_snd.cont_diff_within_at\n#align cont_diff_within_at_snd cont_diff_within_at_snd\n\n",
 "cont_diff_within_at_prod'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\ntheorem cont_diff_within_at_prod' {t : Finset ι} {f : ι → E → 𝔸'} (h : ∀ i ∈ t, cont_diff_within_at 𝕜 n (f i) s x) :\n    cont_diff_within_at 𝕜 n\n      (finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" t (f i)) s x :=\n  finset.prod_induction f (fun f => cont_diff_within_at 𝕜 n f s x) (fun _ _ => cont_diff_within_at.mul)\n    (@cont_diff_within_at_const _ _ _ _ _ _ _ _ _ _ _ 1) h\n#align cont_diff_within_at_prod' cont_diff_within_at_prod'\n\n",
 "cont_diff_within_at_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\ntheorem cont_diff_within_at_prod {t : Finset ι} {f : ι → E → 𝔸'} (h : ∀ i ∈ t, cont_diff_within_at 𝕜 n (f i) s x) :\n    cont_diff_within_at 𝕜 n\n      (fun y =>\n        finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" t (f i y))\n      s x :=\n  by simpa only [← finset.prod_apply] using cont_diff_within_at_prod' h\n#align cont_diff_within_at_prod cont_diff_within_at_prod\n\n",
 "cont_diff_within_at_pi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\ntheorem cont_diff_within_at_pi : cont_diff_within_at 𝕜 n Φ s x ↔ ∀ i, cont_diff_within_at 𝕜 n (fun x => Φ x i) s x :=\n  by\n  set pr := @continuous_linear_map.proj 𝕜 _ ι F' _ _ _\n  refine' ⟨fun h i => h.continuous_linear_map_comp (pr i), fun h m hm => _⟩\n  choose u hux p hp using fun i => h i m hm\n  exact\n    ⟨«expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (u i),\n      filter.Inter_mem.2 hux, _, has_ftaylor_series_up_to_on_pi.2 fun i => (hp i).mono <| Inter_subset _ _⟩\n#align cont_diff_within_at_pi cont_diff_within_at_pi\n\n",
 "cont_diff_within_at_of_subsingleton":
 "@[nontriviality]\ntheorem cont_diff_within_at_of_subsingleton [subsingleton F] : cont_diff_within_at 𝕜 n f s x :=\n  by\n  rw [subsingleton.elim f fun _ => 0]\n  exact cont_diff_within_at_const\n#align cont_diff_within_at_of_subsingleton cont_diff_within_at_of_subsingleton\n\n",
 "cont_diff_within_at_nat":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\ntheorem cont_diff_within_at_nat {n : ℕ} :\n    cont_diff_within_at 𝕜 n f s x ↔\n      ∃ u ∈ nhds_within (insert x s) x,\n        ∃ p : E → formal_multilinear_series 𝕜 E F, has_ftaylor_series_up_to_on n f p u :=\n  ⟨fun H => H n le_rfl, fun ⟨u, hu, p, hp⟩ m hm => ⟨u, hu, p, hp.of_le hm⟩⟩\n#align cont_diff_within_at_nat cont_diff_within_at_nat\n\n",
 "cont_diff_within_at_inter'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\ntheorem cont_diff_within_at_inter' (h : t ∈ nhds_within s x) :\n    cont_diff_within_at 𝕜 n f (s ∩ t) x ↔ cont_diff_within_at 𝕜 n f s x :=\n  cont_diff_within_at_congr_nhds <| eq.symm <| nhds_within_restrict'' _ h\n#align cont_diff_within_at_inter' cont_diff_within_at_inter'\n\n",
 "cont_diff_within_at_inter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem cont_diff_within_at_inter (h : t ∈ (nhds) x) :\n    cont_diff_within_at 𝕜 n f (s ∩ t) x ↔ cont_diff_within_at 𝕜 n f s x :=\n  cont_diff_within_at_inter' (mem_nhds_within_of_mem_nhds h)\n#align cont_diff_within_at_inter cont_diff_within_at_inter\n\n",
 "cont_diff_within_at_insert":
 "theorem cont_diff_within_at_insert {y : E} : cont_diff_within_at 𝕜 n f (insert y s) x ↔ cont_diff_within_at 𝕜 n f s x :=\n  by\n  simp_rw [cont_diff_within_at]\n  rcases eq_or_ne x y with (rfl | h)\n  · simp_rw [insert_eq_of_mem (mem_insert _ _)]\n  simp_rw [insert_comm x y, nhds_within_insert_of_ne h]\n#align cont_diff_within_at_insert cont_diff_within_at_insert\n\n",
 "cont_diff_within_at_iff_forall_nat_le":
 "theorem cont_diff_within_at_iff_forall_nat_le :\n    cont_diff_within_at 𝕜 n f s x ↔ ∀ m : ℕ, ↑m ≤ n → cont_diff_within_at 𝕜 m f s x :=\n  ⟨fun H m hm => H.of_le hm, fun H m hm => H m hm _ le_rfl⟩\n#align cont_diff_within_at_iff_forall_nat_le cont_diff_within_at_iff_forall_nat_le\n\n",
 "cont_diff_within_at_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\ntheorem filter.eventually_eq.cont_diff_within_at_iff (h₁ : «expr =ᶠ[ ] » f₁ (nhds_within s x) f) (hx : f₁ x = f x) :\n    cont_diff_within_at 𝕜 n f₁ s x ↔ cont_diff_within_at 𝕜 n f s x :=\n  ⟨fun H => cont_diff_within_at.congr_of_eventually_eq H h₁.symm hx.symm, fun H => H.congr_of_eventually_eq h₁ hx⟩\n#align filter.eventually_eq.cont_diff_within_at_iff filter.eventually_eq.cont_diff_within_at_iff\n\n",
 "cont_diff_within_at_id":
 "theorem cont_diff_within_at_id {s x} : cont_diff_within_at 𝕜 n (id : E → E) s x :=\n  cont_diff_id.cont_diff_within_at\n#align cont_diff_within_at_id cont_diff_within_at_id\n\n",
 "cont_diff_within_at_fst":
 "/-- The first projection within a domain at a point in a product is `C^∞`. -/\ntheorem cont_diff_within_at_fst {s : set (E × F)} {p : E × F} : cont_diff_within_at 𝕜 n (prod.fst : E × F → E) s p :=\n  cont_diff_fst.cont_diff_within_at\n#align cont_diff_within_at_fst cont_diff_within_at_fst\n\n",
 "cont_diff_within_at_const":
 "theorem cont_diff_within_at_const {c : F} : cont_diff_within_at 𝕜 n (fun x : E => c) s x :=\n  cont_diff_at_const.cont_diff_within_at\n#align cont_diff_within_at_const cont_diff_within_at_const\n\n",
 "cont_diff_within_at_congr_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\ntheorem cont_diff_within_at_congr_nhds {t : set E} (hst : nhds_within s x = nhds_within t x) :\n    cont_diff_within_at 𝕜 n f s x ↔ cont_diff_within_at 𝕜 n f t x :=\n  ⟨fun h => h.congr_nhds hst, fun h => h.congr_nhds hst.symm⟩\n#align cont_diff_within_at_congr_nhds cont_diff_within_at_congr_nhds\n\n",
 "cont_diff_within_at_comp_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/-- Composition by continuous linear equivs on the right respects higher differentiability at a\npoint in a domain. -/\ntheorem continuous_linear_equiv.cont_diff_within_at_comp_iff (e : «expr ≃L[ ] » G 𝕜 E) :\n    cont_diff_within_at 𝕜 n (f ∘ e) («expr ⁻¹' » e s) (e.symm x) ↔ cont_diff_within_at 𝕜 n f s x :=\n  by\n  constructor\n  · intro H\n    simpa [← preimage_comp, (· ∘ ·)] using H.comp_continuous_linear_map (e.symm : «expr →L[ ] » E 𝕜 G)\n  · intro H\n    rw [← e.apply_symm_apply x, ← e.coe_coe] at H\n    exact H.comp_continuous_linear_map _\n#align continuous_linear_equiv.cont_diff_within_at_comp_iff continuous_linear_equiv.cont_diff_within_at_comp_iff\n\n",
 "cont_diff_within_at":
 "theorem cont_diff.cont_diff_within_at (h : cont_diff 𝕜 n f) : cont_diff_within_at 𝕜 n f s x :=\n  h.cont_diff_at.cont_diff_within_at\n#align cont_diff.cont_diff_within_at cont_diff.cont_diff_within_at\n\n",
 "cont_diff_top_iff_fderiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∞» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∞» -/\n/-- A function is `C^∞` if and only if it is differentiable,\nand its derivative (formulated in terms of `fderiv`) is `C^∞`. -/\ntheorem cont_diff_top_iff_fderiv :\n    cont_diff 𝕜 («expr∞») f ↔ differentiable 𝕜 f ∧ cont_diff 𝕜 («expr∞») fun y => fderiv 𝕜 f y :=\n  by\n  simp only [← cont_diff_on_univ, ← differentiable_on_univ, ← fderiv_within_univ]\n  rw [cont_diff_on_top_iff_fderiv_within unique_diff_on_univ]\n#align cont_diff_top_iff_fderiv cont_diff_top_iff_fderiv\n\n",
 "cont_diff_top_iff_deriv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∞» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∞» -/\n/-- A function is `C^∞` if and only if it is differentiable,\nand its derivative (formulated in terms of `deriv`) is `C^∞`. -/\ntheorem cont_diff_top_iff_deriv : cont_diff 𝕜 («expr∞») f₂ ↔ differentiable 𝕜 f₂ ∧ cont_diff 𝕜 («expr∞») (deriv f₂) :=\n  by\n  simp only [← cont_diff_on_univ, ← differentiable_on_univ, ← deriv_within_univ]\n  rw [cont_diff_on_top_iff_deriv_within unique_diff_on_univ]\n#align cont_diff_top_iff_deriv cont_diff_top_iff_deriv\n\n",
 "cont_diff_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∞» -/\ntheorem cont_diff_top : cont_diff 𝕜 («expr∞») f ↔ ∀ n : ℕ, cont_diff 𝕜 n f := by\n  simp [cont_diff_on_univ.symm, cont_diff_on_top]\n#align cont_diff_top cont_diff_top\n\n",
 "cont_diff_symm_deriv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₜ » -/\n/-- Let `f` be an `n` times continuously differentiable homeomorphism of a nontrivially normed\nfield.  Suppose that the derivative of `f` is never equal to zero. Then `f.symm` is `n` times\ncontinuously differentiable.\n\nThis is one of the easy parts of the inverse function theorem: it assumes that we already have\nan inverse function. -/\ntheorem homeomorph.cont_diff_symm_deriv [complete_space 𝕜] (f : «expr ≃ₜ » 𝕜 𝕜) {f' : 𝕜 → 𝕜} (h₀ : ∀ x, f' x ≠ 0)\n    (hf' : ∀ x, has_deriv_at f (f' x) x) (hf : cont_diff 𝕜 n (f : 𝕜 → 𝕜)) : cont_diff 𝕜 n (f.symm : 𝕜 → 𝕜) :=\n  cont_diff_iff_cont_diff_at.2 fun x =>\n    f.to_local_homeomorph.cont_diff_at_symm_deriv (h₀ _) (mem_univ x) (hf' _) hf.cont_diff_at\n#align homeomorph.cont_diff_symm_deriv homeomorph.cont_diff_symm_deriv\n\n",
 "cont_diff_symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₜ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/-- If `f` is an `n` times continuously differentiable homeomorphism,\nand if the derivative of `f` at each point is a continuous linear equivalence,\nthen `f.symm` is `n` times continuously differentiable.\n\nThis is one of the easy parts of the inverse function theorem: it assumes that we already have\nan inverse function. -/\ntheorem homeomorph.cont_diff_symm [complete_space E] (f : «expr ≃ₜ » E F) {f₀' : E → «expr ≃L[ ] » E 𝕜 F}\n    (hf₀' : ∀ a, has_fderiv_at f (f₀' a : «expr →L[ ] » E 𝕜 F) a) (hf : cont_diff 𝕜 n (f : E → F)) :\n    cont_diff 𝕜 n (f.symm : F → E) :=\n  cont_diff_iff_cont_diff_at.2 fun x => f.to_local_homeomorph.cont_diff_at_symm (mem_univ x) (hf₀' _) hf.cont_diff_at\n#align homeomorph.cont_diff_symm homeomorph.cont_diff_symm\n\n",
 "cont_diff_succ_iff_fderiv_apply":
 "/-- This is a useful lemma to prove that a certain operation preserves functions being `C^n`.\nWhen you do induction on `n`, this gives a useful characterization of a function being `C^(n+1)`,\nassuming you have already computed the derivative. The advantage of this version over\n`cont_diff_succ_iff_fderiv` is that both occurences of `cont_diff` are for functions with the same\ndomain and codomain (`E` and `F`). This is not the case for `cont_diff_succ_iff_fderiv`, which\noften requires an inconvenient need to generalize `F`, which results in universe issues\n(see the discussion in the section of `cont_diff.comp`).\n\nThis lemma avoids these universe issues, but only applies for finite dimensional `E`. -/\ntheorem cont_diff_succ_iff_fderiv_apply [finite_dimensional 𝕜 E] {n : ℕ} {f : E → F} :\n    cont_diff 𝕜 (n + 1 : ℕ) f ↔ differentiable 𝕜 f ∧ ∀ y, cont_diff 𝕜 n fun x => fderiv 𝕜 f x y := by\n  rw [cont_diff_succ_iff_fderiv, cont_diff_clm_apply_iff]\n#align cont_diff_succ_iff_fderiv_apply cont_diff_succ_iff_fderiv_apply\n\n",
 "cont_diff_succ_iff_fderiv":
 "/-- A function is `C^(n + 1)` if and only if it is differentiable,\nand its derivative (formulated in terms of `fderiv`) is `C^n`. -/\ntheorem cont_diff_succ_iff_fderiv {n : ℕ} :\n    cont_diff 𝕜 (n + 1 : ℕ) f ↔ differentiable 𝕜 f ∧ cont_diff 𝕜 n fun y => fderiv 𝕜 f y := by\n  simp only [← cont_diff_on_univ, ← differentiable_on_univ, ← fderiv_within_univ,\n    cont_diff_on_succ_iff_fderiv_within unique_diff_on_univ]\n#align cont_diff_succ_iff_fderiv cont_diff_succ_iff_fderiv\n\n",
 "cont_diff_succ_iff_deriv":
 "/-- A function is `C^(n + 1)` if and only if it is differentiable,\n  and its derivative (formulated in terms of `deriv`) is `C^n`. -/\ntheorem cont_diff_succ_iff_deriv {n : ℕ} :\n    cont_diff 𝕜 (n + 1 : ℕ) f₂ ↔ differentiable 𝕜 f₂ ∧ cont_diff 𝕜 n (deriv f₂) := by\n  simp only [← cont_diff_on_univ, cont_diff_on_succ_iff_deriv_of_open, is_open_univ, differentiable_on_univ]\n#align cont_diff_succ_iff_deriv cont_diff_succ_iff_deriv\n\n",
 "cont_diff_snd":
 "/-- The second projection in a product is `C^∞`. -/\ntheorem cont_diff_snd : cont_diff 𝕜 n (prod.snd : E × F → F) :=\n  is_bounded_linear_map.cont_diff is_bounded_linear_map.snd\n#align cont_diff_snd cont_diff_snd\n\n",
 "cont_diff_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n-- The scalar multiplication is smooth.\ntheorem cont_diff_smul : cont_diff 𝕜 n fun p : 𝕜 × F => «expr • » p.1 p.2 :=\n  is_bounded_bilinear_map_smul.cont_diff\n#align cont_diff_smul cont_diff_smul\n\n",
 "cont_diff_prod_mk_right":
 "theorem cont_diff_prod_mk_right (e₀ : E) : cont_diff 𝕜 n fun f : F => (e₀, f) :=\n  cont_diff_const.prod cont_diff_id\n#align cont_diff_prod_mk_right cont_diff_prod_mk_right\n\n",
 "cont_diff_prod_mk_left":
 "theorem cont_diff_prod_mk_left (f₀ : F) : cont_diff 𝕜 n fun e : E => (e, f₀) :=\n  cont_diff_id.prod cont_diff_const\n#align cont_diff_prod_mk_left cont_diff_prod_mk_left\n\n",
 "cont_diff_prod_assoc_symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/-- The natural equivalence `E × (F × G) ≃ (E × F) × G` is smooth.\n\nWarning: see remarks attached to `cont_diff_prod_assoc`\n-/\ntheorem cont_diff_prod_assoc_symm : cont_diff 𝕜 («expr⊤») <| (Equiv.prodAssoc E F G).symm :=\n  (linear_isometry_equiv.prod_assoc 𝕜 E F G).symm.cont_diff\n#align cont_diff_prod_assoc_symm cont_diff_prod_assoc_symm\n\n",
 "cont_diff_prod_assoc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/-- The natural equivalence `(E × F) × G ≃ E × (F × G)` is smooth.\n\nWarning: if you think you need this lemma, it is likely that you can simplify your proof by\nreformulating the lemma that you're applying next using the tips in\nNote [continuity lemma statement]\n-/\ntheorem cont_diff_prod_assoc : cont_diff 𝕜 («expr⊤») <| Equiv.prodAssoc E F G :=\n  (linear_isometry_equiv.prod_assoc 𝕜 E F G).cont_diff\n#align cont_diff_prod_assoc cont_diff_prod_assoc\n\n",
 "cont_diff_prod'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\ntheorem cont_diff_prod' {t : Finset ι} {f : ι → E → 𝔸'} (h : ∀ i ∈ t, cont_diff 𝕜 n (f i)) :\n    cont_diff 𝕜 n\n      (finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" t (f i)) :=\n  cont_diff_iff_cont_diff_at.mpr fun x => cont_diff_at_prod' fun i hi => (h i hi).cont_diff_at\n#align cont_diff_prod' cont_diff_prod'\n\n",
 "cont_diff_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\ntheorem cont_diff_prod {t : Finset ι} {f : ι → E → 𝔸'} (h : ∀ i ∈ t, cont_diff 𝕜 n (f i)) :\n    cont_diff 𝕜 n fun y =>\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" t (f i y) :=\n  cont_diff_iff_cont_diff_at.mpr fun x => cont_diff_at_prod fun i hi => (h i hi).cont_diff_at\n#align cont_diff_prod cont_diff_prod\n\n",
 "cont_diff_pi":
 "theorem cont_diff_pi : cont_diff 𝕜 n Φ ↔ ∀ i, cont_diff 𝕜 n fun x => Φ x i := by\n  simp only [← cont_diff_on_univ, cont_diff_on_pi]\n#align cont_diff_pi cont_diff_pi\n\n",
 "cont_diff_one_iff_fderiv":
 "theorem cont_diff_one_iff_fderiv : cont_diff 𝕜 1 f ↔ differentiable 𝕜 f ∧ continuous (fderiv 𝕜 f) :=\n  cont_diff_succ_iff_fderiv.trans <| iff.rfl.and cont_diff_zero\n#align cont_diff_one_iff_fderiv cont_diff_one_iff_fderiv\n\n",
 "cont_diff_one_iff_deriv":
 "theorem cont_diff_one_iff_deriv : cont_diff 𝕜 1 f₂ ↔ differentiable 𝕜 f₂ ∧ continuous (deriv f₂) :=\n  cont_diff_succ_iff_deriv.trans <| iff.rfl.and cont_diff_zero\n#align cont_diff_one_iff_deriv cont_diff_one_iff_deriv\n\n",
 "cont_diff_on_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ∞» -/\n@[simp]\ntheorem cont_diff_on_zero : cont_diff_on 𝕜 0 f s ↔ continuous_on f s :=\n  by\n  refine' ⟨fun H => H.continuous_on, fun H => _⟩\n  intro x hx m hm\n  have : (m : «exprℕ∞») = 0 := le_antisymm hm bot_le\n  rw [this]\n  refine' ⟨insert x s, self_mem_nhds_within, ftaylor_series_within 𝕜 f s, _⟩\n  rw [has_ftaylor_series_up_to_on_zero_iff]\n  exact ⟨by rwa [insert_eq_of_mem hx], fun x hx => by simp [ftaylor_series_within]⟩\n#align cont_diff_on_zero cont_diff_on_zero\n\n",
 "cont_diff_on_univ":
 "theorem cont_diff_on_univ : cont_diff_on 𝕜 n f univ ↔ cont_diff 𝕜 n f :=\n  by\n  constructor\n  · intro H\n    use ftaylor_series_within 𝕜 f univ\n    rw [← has_ftaylor_series_up_to_on_univ_iff]\n    exact H.ftaylor_series_within unique_diff_on_univ\n  · rintro ⟨p, hp⟩ x hx m hm\n    exact ⟨univ, filter.univ_sets _, p, (hp.has_ftaylor_series_up_to_on univ).of_le hm⟩\n#align cont_diff_on_univ cont_diff_on_univ\n\n",
 "cont_diff_on_top_iff_fderiv_within":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ∞» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∞» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∞» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∞» -/\n/-- A function is `C^∞` on a domain with unique derivatives if and only if it is differentiable\nthere, and its derivative (expressed with `fderiv_within`) is `C^∞`. -/\ntheorem cont_diff_on_top_iff_fderiv_within (hs : unique_diff_on 𝕜 s) :\n    cont_diff_on 𝕜 («expr∞») f s ↔\n      differentiable_on 𝕜 f s ∧ cont_diff_on 𝕜 («expr∞») (fun y => fderiv_within 𝕜 f s y) s :=\n  by\n  constructor\n  · intro h\n    refine' ⟨h.differentiable_on le_top, _⟩\n    apply cont_diff_on_top.2 fun n => ((cont_diff_on_succ_iff_fderiv_within hs).1 _).2\n    exact h.of_le le_top\n  · intro h\n    refine' cont_diff_on_top.2 fun n => _\n    have A : (n : «exprℕ∞») ≤ «expr∞» := le_top\n    apply ((cont_diff_on_succ_iff_fderiv_within hs).2 ⟨h.1, h.2.of_le A⟩).of_le\n    exact WithTop.coe_le_coe.2 (nat.le_succ n)\n#align cont_diff_on_top_iff_fderiv_within cont_diff_on_top_iff_fderiv_within\n\n",
 "cont_diff_on_top_iff_fderiv_of_open":
 "/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:76:14: unsupported tactic `congrm #[[expr «expr ∧ »(_, _)]] -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∞» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∞» -/\n/-- A function is `C^∞` on an open domain if and only if it is differentiable there, and its\nderivative (expressed with `fderiv`) is `C^∞`. -/\ntheorem cont_diff_on_top_iff_fderiv_of_open (hs : is_open s) :\n    cont_diff_on 𝕜 («expr∞») f s ↔ differentiable_on 𝕜 f s ∧ cont_diff_on 𝕜 («expr∞») (fun y => fderiv 𝕜 f y) s :=\n  by\n  rw [cont_diff_on_top_iff_fderiv_within hs.unique_diff_on]\n  trace\n    \"./././Mathport/Syntax/Translate/Tactic/Builtin.lean:76:14: unsupported tactic `congrm #[[expr «expr ∧ »(_, _)]]\"\n  apply cont_diff_on_congr\n  intro x hx\n  exact fderiv_within_of_open hs hx\n#align cont_diff_on_top_iff_fderiv_of_open cont_diff_on_top_iff_fderiv_of_open\n\n",
 "cont_diff_on_top_iff_deriv_within":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ∞» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∞» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∞» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∞» -/\n/-- A function is `C^∞` on a domain with unique derivatives if and only if it is differentiable\nthere, and its derivative (formulated with `deriv_within`) is `C^∞`. -/\ntheorem cont_diff_on_top_iff_deriv_within (hs : unique_diff_on 𝕜 s₂) :\n    cont_diff_on 𝕜 («expr∞») f₂ s₂ ↔ differentiable_on 𝕜 f₂ s₂ ∧ cont_diff_on 𝕜 («expr∞») (deriv_within f₂ s₂) s₂ :=\n  by\n  constructor\n  · intro h\n    refine' ⟨h.differentiable_on le_top, _⟩\n    apply cont_diff_on_top.2 fun n => ((cont_diff_on_succ_iff_deriv_within hs).1 _).2\n    exact h.of_le le_top\n  · intro h\n    refine' cont_diff_on_top.2 fun n => _\n    have A : (n : «exprℕ∞») ≤ «expr∞» := le_top\n    apply ((cont_diff_on_succ_iff_deriv_within hs).2 ⟨h.1, h.2.of_le A⟩).of_le\n    exact WithTop.coe_le_coe.2 (nat.le_succ n)\n#align cont_diff_on_top_iff_deriv_within cont_diff_on_top_iff_deriv_within\n\n",
 "cont_diff_on_top_iff_deriv_of_open":
 "/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:76:14: unsupported tactic `congrm #[[expr «expr ∧ »(_, _)]] -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∞» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∞» -/\n/-- A function is `C^∞` on an open domain if and only if it is differentiable\nthere, and its derivative (formulated with `deriv`) is `C^∞`. -/\ntheorem cont_diff_on_top_iff_deriv_of_open (hs : is_open s₂) :\n    cont_diff_on 𝕜 («expr∞») f₂ s₂ ↔ differentiable_on 𝕜 f₂ s₂ ∧ cont_diff_on 𝕜 («expr∞») (deriv f₂) s₂ :=\n  by\n  rw [cont_diff_on_top_iff_deriv_within hs.unique_diff_on]\n  trace\n    \"./././Mathport/Syntax/Translate/Tactic/Builtin.lean:76:14: unsupported tactic `congrm #[[expr «expr ∧ »(_, _)]]\"\n  exact cont_diff_on_congr fun _ => deriv_within_of_open hs\n#align cont_diff_on_top_iff_deriv_of_open cont_diff_on_top_iff_deriv_of_open\n\n",
 "cont_diff_on_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∞» -/\ntheorem cont_diff_on_top : cont_diff_on 𝕜 («expr∞») f s ↔ ∀ n : ℕ, cont_diff_on 𝕜 n f s :=\n  cont_diff_on_iff_forall_nat_le.trans <| by simp only [le_top, forall_prop_of_true]\n#align cont_diff_on_top cont_diff_on_top\n\n",
 "cont_diff_on_succ_of_fderiv_within":
 "theorem cont_diff_on_succ_of_fderiv_within {n : ℕ} (hf : differentiable_on 𝕜 f s)\n    (h : cont_diff_on 𝕜 n (fun y => fderiv_within 𝕜 f s y) s) : cont_diff_on 𝕜 (n + 1 : ℕ) f s :=\n  by\n  intro x hx\n  rw [cont_diff_within_at_succ_iff_has_fderiv_within_at, insert_eq_of_mem hx]\n  exact ⟨s, self_mem_nhds_within, fderiv_within 𝕜 f s, fun y hy => (hf y hy).has_fderiv_within_at, h x hx⟩\n#align cont_diff_on_succ_of_fderiv_within cont_diff_on_succ_of_fderiv_within\n\n",
 "cont_diff_on_succ_of_fderiv_apply":
 "theorem cont_diff_on_succ_of_fderiv_apply [finite_dimensional 𝕜 E] {n : ℕ} {f : E → F} {s : set E}\n    (hf : differentiable_on 𝕜 f s) (h : ∀ y, cont_diff_on 𝕜 n (fun x => fderiv_within 𝕜 f s x y) s) :\n    cont_diff_on 𝕜 (n + 1 : ℕ) f s :=\n  cont_diff_on_succ_of_fderiv_within hf <| cont_diff_on_clm_apply.mpr h\n#align cont_diff_on_succ_of_fderiv_apply cont_diff_on_succ_of_fderiv_apply\n\n",
 "cont_diff_on_succ_iff_has_fderiv_within_at":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/-- A function is `C^(n + 1)` on a domain iff locally, it has a derivative which is `C^n`. -/\ntheorem cont_diff_on_succ_iff_has_fderiv_within_at {n : ℕ} :\n    cont_diff_on 𝕜 (n + 1 : ℕ) f s ↔\n      ∀ x ∈ s,\n        ∃ u ∈ nhds_within (insert x s) x,\n          ∃ f' : E → «expr →L[ ] » E 𝕜 F, (∀ x ∈ u, has_fderiv_within_at f (f' x) u x) ∧ cont_diff_on 𝕜 n f' u :=\n  by\n  constructor\n  · intro h x hx\n    rcases(h x hx) n.succ le_rfl with ⟨u, hu, p, Hp⟩\n    refine'\n      ⟨u, hu, fun y => (continuous_multilinear_curry_fin1 𝕜 E F) (p y 1), fun y hy =>\n        Hp.has_fderiv_within_at (WithTop.coe_le_coe.2 (nat.le_add_left 1 n)) hy, _⟩\n    rw [has_ftaylor_series_up_to_on_succ_iff_right] at Hp\n    intro z hz m hm\n    refine' ⟨u, _, fun x : E => (p x).shift, Hp.2.2.of_le hm⟩\n    convert self_mem_nhds_within\n    exact insert_eq_of_mem hz\n  · intro h x hx\n    rw [cont_diff_within_at_succ_iff_has_fderiv_within_at]\n    rcases h x hx with ⟨u, u_nhbd, f', hu, hf'⟩\n    have : x ∈ u := mem_of_mem_nhds_within (mem_insert _ _) u_nhbd\n    exact ⟨u, u_nhbd, f', hu, hf' x this⟩\n#align cont_diff_on_succ_iff_has_fderiv_within_at cont_diff_on_succ_iff_has_fderiv_within_at\n\n",
 "cont_diff_on_succ_iff_fderiv_within":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/-- A function is `C^(n + 1)` on a domain with unique derivatives if and only if it is\ndifferentiable there, and its derivative (expressed with `fderiv_within`) is `C^n`. -/\ntheorem cont_diff_on_succ_iff_fderiv_within {n : ℕ} (hs : unique_diff_on 𝕜 s) :\n    cont_diff_on 𝕜 (n + 1 : ℕ) f s ↔ differentiable_on 𝕜 f s ∧ cont_diff_on 𝕜 n (fun y => fderiv_within 𝕜 f s y) s :=\n  by\n  refine' ⟨fun H => _, fun h => cont_diff_on_succ_of_fderiv_within h.1 h.2⟩\n  refine' ⟨H.differentiable_on (WithTop.coe_le_coe.2 (nat.le_add_left 1 n)), fun x hx => _⟩\n  rcases cont_diff_within_at_succ_iff_has_fderiv_within_at.1 (H x hx) with ⟨u, hu, f', hff', hf'⟩\n  rcases mem_nhds_within.1 hu with ⟨o, o_open, xo, ho⟩\n  rw [inter_comm, insert_eq_of_mem hx] at ho\n  have := hf'.mono ho\n  rw [cont_diff_within_at_inter' (mem_nhds_within_of_mem_nhds (is_open.mem_nhds o_open xo))] at this\n  apply this.congr_of_eventually_eq' _ hx\n  have : o ∩ s ∈ nhds_within s x := mem_nhds_within.2 ⟨o, o_open, xo, subset.refl _⟩\n  rw [inter_comm] at this\n  apply filter.eventually_eq_of_mem this fun y hy => _\n  have A : fderiv_within 𝕜 f (s ∩ o) y = f' y := ((hff' y (ho hy)).mono ho).fderiv_within (hs.inter o_open y hy)\n  rwa [fderiv_within_inter (is_open.mem_nhds o_open hy.2) (hs y hy.1)] at A\n#align cont_diff_on_succ_iff_fderiv_within cont_diff_on_succ_iff_fderiv_within\n\n",
 "cont_diff_on_succ_iff_fderiv_of_open":
 "/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:76:14: unsupported tactic `congrm #[[expr «expr ∧ »(_, _)]] -/\n/-- A function is `C^(n + 1)` on an open domain if and only if it is\ndifferentiable there, and its derivative (expressed with `fderiv`) is `C^n`. -/\ntheorem cont_diff_on_succ_iff_fderiv_of_open {n : ℕ} (hs : is_open s) :\n    cont_diff_on 𝕜 (n + 1 : ℕ) f s ↔ differentiable_on 𝕜 f s ∧ cont_diff_on 𝕜 n (fun y => fderiv 𝕜 f y) s :=\n  by\n  rw [cont_diff_on_succ_iff_fderiv_within hs.unique_diff_on]\n  trace\n    \"./././Mathport/Syntax/Translate/Tactic/Builtin.lean:76:14: unsupported tactic `congrm #[[expr «expr ∧ »(_, _)]]\"\n  apply cont_diff_on_congr\n  intro x hx\n  exact fderiv_within_of_open hs hx\n#align cont_diff_on_succ_iff_fderiv_of_open cont_diff_on_succ_iff_fderiv_of_open\n\n",
 "cont_diff_on_succ_iff_fderiv_apply":
 "theorem cont_diff_on_succ_iff_fderiv_apply [finite_dimensional 𝕜 E] {n : ℕ} {f : E → F} {s : set E}\n    (hs : unique_diff_on 𝕜 s) :\n    cont_diff_on 𝕜 (n + 1 : ℕ) f s ↔\n      differentiable_on 𝕜 f s ∧ ∀ y, cont_diff_on 𝕜 n (fun x => fderiv_within 𝕜 f s x y) s :=\n  by rw [cont_diff_on_succ_iff_fderiv_within hs, cont_diff_on_clm_apply]\n#align cont_diff_on_succ_iff_fderiv_apply cont_diff_on_succ_iff_fderiv_apply\n\n",
 "cont_diff_on_succ_iff_deriv_within":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/-- A function is `C^(n + 1)` on a domain with unique derivatives if and only if it is\ndifferentiable there, and its derivative (formulated with `deriv_within`) is `C^n`. -/\ntheorem cont_diff_on_succ_iff_deriv_within {n : ℕ} (hs : unique_diff_on 𝕜 s₂) :\n    cont_diff_on 𝕜 (n + 1 : ℕ) f₂ s₂ ↔ differentiable_on 𝕜 f₂ s₂ ∧ cont_diff_on 𝕜 n (deriv_within f₂ s₂) s₂ :=\n  by\n  rw [cont_diff_on_succ_iff_fderiv_within hs]\n  congr 2\n  apply le_antisymm\n  · intro h\n    have : deriv_within f₂ s₂ = (fun u : «expr →L[ ] » 𝕜 𝕜 F => u 1) ∘ fderiv_within 𝕜 f₂ s₂ :=\n      by\n      ext x\n      rfl\n    simp only [this]\n    apply cont_diff.comp_cont_diff_on _ h\n    exact (is_bounded_bilinear_map_apply.is_bounded_linear_map_left _).cont_diff\n  · intro h\n    have : fderiv_within 𝕜 f₂ s₂ = smul_right (1 : «expr →L[ ] » 𝕜 𝕜 𝕜) ∘ deriv_within f₂ s₂ :=\n      by\n      ext x\n      simp [deriv_within]\n    simp only [this]\n    apply cont_diff.comp_cont_diff_on _ h\n    have : is_bounded_bilinear_map 𝕜 fun _ : «expr →L[ ] » 𝕜 𝕜 𝕜 × F => _ := is_bounded_bilinear_map_smul_right\n    exact (this.is_bounded_linear_map_right _).cont_diff\n#align cont_diff_on_succ_iff_deriv_within cont_diff_on_succ_iff_deriv_within\n\n",
 "cont_diff_on_succ_iff_deriv_of_open":
 "/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:76:14: unsupported tactic `congrm #[[expr «expr ∧ »(_, _)]] -/\n/-- A function is `C^(n + 1)` on an open domain if and only if it is\ndifferentiable there, and its derivative (formulated with `deriv`) is `C^n`. -/\ntheorem cont_diff_on_succ_iff_deriv_of_open {n : ℕ} (hs : is_open s₂) :\n    cont_diff_on 𝕜 (n + 1 : ℕ) f₂ s₂ ↔ differentiable_on 𝕜 f₂ s₂ ∧ cont_diff_on 𝕜 n (deriv f₂) s₂ :=\n  by\n  rw [cont_diff_on_succ_iff_deriv_within hs.unique_diff_on]\n  trace\n    \"./././Mathport/Syntax/Translate/Tactic/Builtin.lean:76:14: unsupported tactic `congrm #[[expr «expr ∧ »(_, _)]]\"\n  exact cont_diff_on_congr fun _ => deriv_within_of_open hs\n#align cont_diff_on_succ_iff_deriv_of_open cont_diff_on_succ_iff_deriv_of_open\n\n",
 "cont_diff_on_snd":
 "/-- The second projection on a domain in a product is `C^∞`. -/\ntheorem cont_diff_on_snd {s : set (E × F)} : cont_diff_on 𝕜 n (prod.snd : E × F → F) s :=\n  cont_diff.cont_diff_on cont_diff_snd\n#align cont_diff_on_snd cont_diff_on_snd\n\n",
 "cont_diff_on_prod'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\ntheorem cont_diff_on_prod' {t : Finset ι} {f : ι → E → 𝔸'} (h : ∀ i ∈ t, cont_diff_on 𝕜 n (f i) s) :\n    cont_diff_on 𝕜 n\n      (finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" t (f i)) s :=\n  fun x hx => cont_diff_within_at_prod' fun i hi => h i hi x hx\n#align cont_diff_on_prod' cont_diff_on_prod'\n\n",
 "cont_diff_on_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\ntheorem cont_diff_on_prod {t : Finset ι} {f : ι → E → 𝔸'} (h : ∀ i ∈ t, cont_diff_on 𝕜 n (f i) s) :\n    cont_diff_on 𝕜 n\n      (fun y =>\n        finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" t (f i y))\n      s :=\n  fun x hx => cont_diff_within_at_prod fun i hi => h i hi x hx\n#align cont_diff_on_prod cont_diff_on_prod\n\n",
 "cont_diff_on_pi":
 "theorem cont_diff_on_pi : cont_diff_on 𝕜 n Φ s ↔ ∀ i, cont_diff_on 𝕜 n (fun x => Φ x i) s :=\n  ⟨fun h i x hx => cont_diff_within_at_pi.1 (h x hx) _, fun h x hx => cont_diff_within_at_pi.2 fun i => h i x hx⟩\n#align cont_diff_on_pi cont_diff_on_pi\n\n",
 "cont_diff_on_of_subsingleton":
 "@[nontriviality]\ntheorem cont_diff_on_of_subsingleton [subsingleton F] : cont_diff_on 𝕜 n f s :=\n  by\n  rw [subsingleton.elim f fun _ => 0]\n  exact cont_diff_on_const\n#align cont_diff_on_of_subsingleton cont_diff_on_of_subsingleton\n\n",
 "cont_diff_on_of_locally_cont_diff_on":
 "/-- If a function is `C^n` around each point in a set, then it is `C^n` on the set. -/\ntheorem cont_diff_on_of_locally_cont_diff_on (h : ∀ x ∈ s, ∃ u, is_open u ∧ x ∈ u ∧ cont_diff_on 𝕜 n f (s ∩ u)) :\n    cont_diff_on 𝕜 n f s := by\n  intro x xs\n  rcases h x xs with ⟨u, u_open, xu, hu⟩\n  apply (cont_diff_within_at_inter _).1 (hu x ⟨xs, xu⟩)\n  exact is_open.mem_nhds u_open xu\n#align cont_diff_on_of_locally_cont_diff_on cont_diff_on_of_locally_cont_diff_on\n\n",
 "cont_diff_on_of_differentiable_on":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ∞» -/\ntheorem cont_diff_on_of_differentiable_on\n    (h : ∀ m : ℕ, (m : «exprℕ∞») ≤ n → differentiable_on 𝕜 (iterated_fderiv_within 𝕜 m f s) s) : cont_diff_on 𝕜 n f s :=\n  cont_diff_on_of_continuous_on_differentiable_on (fun m hm => (h m hm).continuous_on) fun m hm => h m (le_of_lt hm)\n#align cont_diff_on_of_differentiable_on cont_diff_on_of_differentiable_on\n\n",
 "cont_diff_on_of_continuous_on_differentiable_on":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ∞» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ∞» -/\ntheorem cont_diff_on_of_continuous_on_differentiable_on\n    (Hcont : ∀ m : ℕ, (m : «exprℕ∞») ≤ n → continuous_on (fun x => iterated_fderiv_within 𝕜 m f s x) s)\n    (Hdiff : ∀ m : ℕ, (m : «exprℕ∞») < n → differentiable_on 𝕜 (fun x => iterated_fderiv_within 𝕜 m f s x) s) :\n    cont_diff_on 𝕜 n f s := by\n  intro x hx m hm\n  rw [insert_eq_of_mem hx]\n  refine' ⟨s, self_mem_nhds_within, ftaylor_series_within 𝕜 f s, _⟩\n  constructor\n  · intro y hy\n    simp only [ftaylor_series_within, continuous_multilinear_map.uncurry0_apply, iterated_fderiv_within_zero_apply]\n  · intro k hk y hy\n    convert (Hdiff k (lt_of_lt_of_le hk hm) y hy).has_fderiv_within_at\n    simp only [ftaylor_series_within, iterated_fderiv_within_succ_eq_comp_left, continuous_linear_equiv.coe_apply,\n      Function.comp_apply, coe_fn_coe_base]\n    exact continuous_linear_map.curry_uncurry_left _\n  · intro k hk\n    exact Hcont k (le_trans hk hm)\n#align cont_diff_on_of_continuous_on_differentiable_on cont_diff_on_of_continuous_on_differentiable_on\n\n",
 "cont_diff_on_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\ntheorem cont_diff_on_inv {n} : cont_diff_on 𝕜 n (has_inv.inv : 𝕜' → 𝕜') («expr ᶜ» {0}) := fun x hx =>\n  (cont_diff_at_inv 𝕜 hx).cont_diff_within_at\n#align cont_diff_on_inv cont_diff_on_inv\n\n",
 "cont_diff_on_iff_ftaylor_series":
 "/-- When a function is `C^n` in a set `s` of unique differentiability, it admits\n`ftaylor_series_within 𝕜 f s` as a Taylor series up to order `n` in `s`. -/\ntheorem cont_diff_on_iff_ftaylor_series : cont_diff 𝕜 n f ↔ has_ftaylor_series_up_to n f (ftaylor_series 𝕜 f) :=\n  by\n  constructor\n  · rw [← cont_diff_on_univ, ← has_ftaylor_series_up_to_on_univ_iff, ← ftaylor_series_within_univ]\n    exact fun h => cont_diff_on.ftaylor_series_within h unique_diff_on_univ\n  · intro h\n    exact ⟨ftaylor_series 𝕜 f, h⟩\n#align cont_diff_on_iff_ftaylor_series cont_diff_on_iff_ftaylor_series\n\n",
 "cont_diff_on_iff_forall_nat_le":
 "theorem cont_diff_on_iff_forall_nat_le : cont_diff_on 𝕜 n f s ↔ ∀ m : ℕ, ↑m ≤ n → cont_diff_on 𝕜 m f s :=\n  ⟨fun H m hm => H.of_le hm, fun H x hx m hm => H m hm x hx m le_rfl⟩\n#align cont_diff_on_iff_forall_nat_le cont_diff_on_iff_forall_nat_le\n\n",
 "cont_diff_on_iff_continuous_on_differentiable_on":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ∞» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ∞» -/\ntheorem cont_diff_on_iff_continuous_on_differentiable_on (hs : unique_diff_on 𝕜 s) :\n    cont_diff_on 𝕜 n f s ↔\n      (∀ m : ℕ, (m : «exprℕ∞») ≤ n → continuous_on (fun x => iterated_fderiv_within 𝕜 m f s x) s) ∧\n        ∀ m : ℕ, (m : «exprℕ∞») < n → differentiable_on 𝕜 (fun x => iterated_fderiv_within 𝕜 m f s x) s :=\n  by\n  constructor\n  · intro h\n    constructor\n    · intro m hm\n      exact h.continuous_on_iterated_fderiv_within hm hs\n    · intro m hm\n      exact h.differentiable_on_iterated_fderiv_within hm hs\n  · intro h\n    exact cont_diff_on_of_continuous_on_differentiable_on h.1 h.2\n#align cont_diff_on_iff_continuous_on_differentiable_on cont_diff_on_iff_continuous_on_differentiable_on\n\n",
 "cont_diff_on_id":
 "theorem cont_diff_on_id {s} : cont_diff_on 𝕜 n (id : E → E) s :=\n  cont_diff_id.cont_diff_on\n#align cont_diff_on_id cont_diff_on_id\n\n",
 "cont_diff_on_fst":
 "/-- The first projection on a domain in a product is `C^∞`. -/\ntheorem cont_diff_on_fst {s : set (E × F)} : cont_diff_on 𝕜 n (prod.fst : E × F → E) s :=\n  cont_diff.cont_diff_on cont_diff_fst\n#align cont_diff_on_fst cont_diff_on_fst\n\n",
 "cont_diff_on_fderiv_within_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n/-- The bundled derivative of a `C^{n+1}` function is `C^n`. -/\ntheorem cont_diff_on_fderiv_within_apply {m n : WithTop ℕ} {s : set E} {f : E → F} (hf : cont_diff_on 𝕜 n f s)\n    (hs : unique_diff_on 𝕜 s) (hmn : m + 1 ≤ n) :\n    cont_diff_on 𝕜 m (fun p : E × E => (fderiv_within 𝕜 f s p.1 : «expr →L[ ] » E 𝕜 F) p.2) (lower_set.prod s univ) :=\n  have I : cont_diff_on 𝕜 m (fun x : E => fderiv_within 𝕜 f s x) s := hf.fderiv_within hs hmn\n  have J : cont_diff_on 𝕜 m (fun x : E × E => x.1) (lower_set.prod s univ) := cont_diff_fst.cont_diff_on\n  have A : cont_diff 𝕜 m fun p : «expr →L[ ] » E 𝕜 F × E => p.1 p.2 := is_bounded_bilinear_map_apply.cont_diff\n  have B : cont_diff_on 𝕜 m (fun p : E × E => (fderiv_within 𝕜 f s p.fst, p.snd)) (lower_set.prod s univ) :=\n    (I.comp J (prod_subset_preimage_fst _ _)).prod is_bounded_linear_map.snd.cont_diff.cont_diff_on\n  A.comp_cont_diff_on B\n#align cont_diff_on_fderiv_within_apply cont_diff_on_fderiv_within_apply\n\n",
 "cont_diff_on_const":
 "theorem cont_diff_on_const {c : F} {s : set E} : cont_diff_on 𝕜 n (fun x : E => c) s :=\n  cont_diff_const.cont_diff_on\n#align cont_diff_on_const cont_diff_on_const\n\n",
 "cont_diff_on_congr":
 "theorem cont_diff_on_congr (h₁ : ∀ x ∈ s, f₁ x = f x) : cont_diff_on 𝕜 n f₁ s ↔ cont_diff_on 𝕜 n f s :=\n  ⟨fun H => H.congr fun x hx => (h₁ x hx).symm, fun H => H.congr h₁⟩\n#align cont_diff_on_congr cont_diff_on_congr\n\n",
 "cont_diff_on_comp_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/-- Composition by continuous linear equivs on the right respects higher differentiability on\ndomains. -/\ntheorem continuous_linear_equiv.cont_diff_on_comp_iff (e : «expr ≃L[ ] » G 𝕜 E) :\n    cont_diff_on 𝕜 n (f ∘ e) («expr ⁻¹' » e s) ↔ cont_diff_on 𝕜 n f s :=\n  by\n  refine' ⟨fun H => _, fun H => H.comp_continuous_linear_map (e : «expr →L[ ] » G 𝕜 E)⟩\n  have A : f = (f ∘ e) ∘ e.symm := by\n    ext y\n    simp only [Function.comp_apply]\n    rw [e.apply_symm_apply y]\n  have B : «expr ⁻¹' » e.symm («expr ⁻¹' » e s) = s :=\n    by\n    rw [← preimage_comp, e.self_comp_symm]\n    rfl\n  rw [A, ← B]\n  exact H.comp_continuous_linear_map (e.symm : «expr →L[ ] » E 𝕜 G)\n#align continuous_linear_equiv.cont_diff_on_comp_iff continuous_linear_equiv.cont_diff_on_comp_iff\n\n",
 "cont_diff_on_clm_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ∞» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/-- A family of continuous linear maps is `C^n` on `s` if all its applications are. -/\ntheorem cont_diff_on_clm_apply {n : «exprℕ∞»} {f : E → «expr →L[ ] » F 𝕜 G} {s : set E} [finite_dimensional 𝕜 F] :\n    cont_diff_on 𝕜 n f s ↔ ∀ y, cont_diff_on 𝕜 n (fun x => f x y) s :=\n  by\n  refine' ⟨fun h y => (continuous_linear_map.apply 𝕜 G y).cont_diff.comp_cont_diff_on h, fun h => _⟩\n  let d := finrank 𝕜 F\n  have hd : d = finrank 𝕜 (fin d → 𝕜) := (finrank_fin_fun 𝕜).symm\n  let e₁ := continuous_linear_equiv.of_finrank_eq hd\n  let e₂ := (e₁.arrow_congr (1 : «expr ≃L[ ] » G 𝕜 G)).trans (continuous_linear_equiv.pi_ring (fin d))\n  rw [← comp.left_id f, ← e₂.symm_comp_self]\n  exact e₂.symm.cont_diff.comp_cont_diff_on (cont_diff_on_pi.mpr fun i => h _)\n#align cont_diff_on_clm_apply cont_diff_on_clm_apply\n\n",
 "cont_diff_on_all_iff_nat":
 "theorem cont_diff_on_all_iff_nat : (∀ n, cont_diff_on 𝕜 n f s) ↔ ∀ n : ℕ, cont_diff_on 𝕜 n f s :=\n  by\n  refine' ⟨fun H n => H n, _⟩\n  rintro H (_ | n)\n  exacts[cont_diff_on_top.2 H, H n]\n#align cont_diff_on_all_iff_nat cont_diff_on_all_iff_nat\n\n",
 "cont_diff_on":
 "theorem cont_diff.cont_diff_on (h : cont_diff 𝕜 n f) : cont_diff_on 𝕜 n f s :=\n  (cont_diff_on_univ.2 h).mono (subset_univ _)\n#align cont_diff.cont_diff_on cont_diff.cont_diff_on\n\n",
 "cont_diff_of_subsingleton":
 "@[nontriviality]\ntheorem cont_diff_of_subsingleton [subsingleton F] : cont_diff 𝕜 n f :=\n  by\n  rw [subsingleton.elim f fun _ => 0]\n  exact cont_diff_const\n#align cont_diff_of_subsingleton cont_diff_of_subsingleton\n\n",
 "cont_diff_of_differentiable_iterated_fderiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ∞» -/\ntheorem cont_diff_of_differentiable_iterated_fderiv\n    (h : ∀ m : ℕ, (m : «exprℕ∞») ≤ n → differentiable 𝕜 (iterated_fderiv 𝕜 m f)) : cont_diff 𝕜 n f :=\n  cont_diff_iff_continuous_differentiable.2 ⟨fun m hm => (h m hm).continuous, fun m hm => h m (le_of_lt hm)⟩\n#align cont_diff_of_differentiable_iterated_fderiv cont_diff_of_differentiable_iterated_fderiv\n\n",
 "cont_diff_neg":
 "-- The negative is smooth.\ntheorem cont_diff_neg : cont_diff 𝕜 n fun p : F => -p :=\n  is_bounded_linear_map.id.neg.cont_diff\n#align cont_diff_neg cont_diff_neg\n\n",
 "cont_diff_mul":
 "-- The product is smooth.\ntheorem cont_diff_mul : cont_diff 𝕜 n fun p : 𝔸 × 𝔸 => p.1 * p.2 :=\n  (continuous_linear_map.mul 𝕜 𝔸).is_bounded_bilinear_map.cont_diff\n#align cont_diff_mul cont_diff_mul\n\n",
 "cont_diff_iff_forall_nat_le":
 "theorem cont_diff_iff_forall_nat_le : cont_diff 𝕜 n f ↔ ∀ m : ℕ, ↑m ≤ n → cont_diff 𝕜 m f :=\n  by\n  simp_rw [← cont_diff_on_univ]\n  exact cont_diff_on_iff_forall_nat_le\n#align cont_diff_iff_forall_nat_le cont_diff_iff_forall_nat_le\n\n",
 "cont_diff_iff_continuous_differentiable":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ∞» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ∞» -/\ntheorem cont_diff_iff_continuous_differentiable :\n    cont_diff 𝕜 n f ↔\n      (∀ m : ℕ, (m : «exprℕ∞») ≤ n → continuous fun x => iterated_fderiv 𝕜 m f x) ∧\n        ∀ m : ℕ, (m : «exprℕ∞») < n → differentiable 𝕜 fun x => iterated_fderiv 𝕜 m f x :=\n  by\n  simp [cont_diff_on_univ.symm, continuous_iff_continuous_on_univ, differentiable_on_univ.symm,\n    iterated_fderiv_within_univ, cont_diff_on_iff_continuous_on_differentiable_on unique_diff_on_univ]\n#align cont_diff_iff_continuous_differentiable cont_diff_iff_continuous_differentiable\n\n",
 "cont_diff_iff_cont_diff_at":
 "theorem cont_diff_iff_cont_diff_at : cont_diff 𝕜 n f ↔ ∀ x, cont_diff_at 𝕜 n f x := by\n  simp [← cont_diff_on_univ, cont_diff_on, cont_diff_at]\n#align cont_diff_iff_cont_diff_at cont_diff_iff_cont_diff_at\n\n",
 "cont_diff_id":
 "/-- The identity is `C^∞`.\n-/\ntheorem cont_diff_id : cont_diff 𝕜 n (id : E → E) :=\n  is_bounded_linear_map.id.cont_diff\n#align cont_diff_id cont_diff_id\n\n",
 "cont_diff_fst":
 "/-- The first projection in a product is `C^∞`. -/\ntheorem cont_diff_fst : cont_diff 𝕜 n (prod.fst : E × F → E) :=\n  is_bounded_linear_map.cont_diff is_bounded_linear_map.fst\n#align cont_diff_fst cont_diff_fst\n\n",
 "cont_diff_fderiv_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/-- The bundled derivative of a `C^{n+1}` function is `C^n`. -/\ntheorem cont_diff.cont_diff_fderiv_apply {f : E → F} (hf : cont_diff 𝕜 n f) (hmn : m + 1 ≤ n) :\n    cont_diff 𝕜 m fun p : E × E => (fderiv 𝕜 f p.1 : «expr →L[ ] » E 𝕜 F) p.2 :=\n  by\n  rw [← cont_diff_on_univ] at hf⊢\n  rw [← fderiv_within_univ, ← univ_prod_univ]\n  exact cont_diff_on_fderiv_within_apply hf unique_diff_on_univ hmn\n#align cont_diff.cont_diff_fderiv_apply cont_diff.cont_diff_fderiv_apply\n\n",
 "cont_diff_const_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n-- The scalar multiplication with a constant is smooth.\ntheorem cont_diff_const_smul (c : R) : cont_diff 𝕜 n fun p : F => «expr • » c p :=\n  («expr • » c (continuous_linear_map.id 𝕜 F)).cont_diff\n#align cont_diff_const_smul cont_diff_const_smul\n\n",
 "cont_diff_const":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∞» -/\n/-- Constants are `C^∞`.\n-/\ntheorem cont_diff_const {c : F} : cont_diff 𝕜 n fun x : E => c :=\n  by\n  suffices h : cont_diff 𝕜 («expr∞») fun x : E => c; · exact h.of_le le_top\n  rw [cont_diff_top_iff_fderiv]\n  refine' ⟨differentiable_const c, _⟩\n  rw [fderiv_const]\n  exact cont_diff_zero_fun\n#align cont_diff_const cont_diff_const\n\n",
 "cont_diff_comp_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃L[ ] » -/\n/-- Composition by continuous linear equivs on the right respects higher differentiability. -/\ntheorem continuous_linear_equiv.cont_diff_comp_iff (e : «expr ≃L[ ] » G 𝕜 E) :\n    cont_diff 𝕜 n (f ∘ e) ↔ cont_diff 𝕜 n f :=\n  by\n  rw [← cont_diff_on_univ, ← cont_diff_on_univ, ← preimage_univ]\n  exact e.cont_diff_on_comp_iff\n#align continuous_linear_equiv.cont_diff_comp_iff continuous_linear_equiv.cont_diff_comp_iff\n\n",
 "cont_diff_clm_apply_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ∞» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\ntheorem cont_diff_clm_apply_iff {n : «exprℕ∞»} {f : E → «expr →L[ ] » F 𝕜 G} [finite_dimensional 𝕜 F] :\n    cont_diff 𝕜 n f ↔ ∀ y, cont_diff 𝕜 n fun x => f x y := by simp_rw [← cont_diff_on_univ, cont_diff_on_clm_apply]\n#align cont_diff_clm_apply_iff cont_diff_clm_apply_iff\n\n",
 "cont_diff_at_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem cont_diff_at_zero : cont_diff_at 𝕜 0 f x ↔ ∃ u ∈ (nhds) x, continuous_on f u :=\n  by\n  rw [← cont_diff_within_at_univ]\n  simp [cont_diff_within_at_zero, nhds_within_univ]\n#align cont_diff_at_zero cont_diff_at_zero\n\n",
 "cont_diff_at_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∞» -/\ntheorem cont_diff_at_top : cont_diff_at 𝕜 («expr∞») f x ↔ ∀ n : ℕ, cont_diff_at 𝕜 n f x := by\n  simp [← cont_diff_within_at_univ, cont_diff_within_at_top]\n#align cont_diff_at_top cont_diff_at_top\n\n",
 "cont_diff_at_symm_deriv":
 "/-- Let `f` be a local homeomorphism of a nontrivially normed field, let `a` be a point in its\ntarget. if `f` is `n` times continuously differentiable at `f.symm a`, and if the derivative at\n`f.symm a` is nonzero, then `f.symm` is `n` times continuously differentiable at the point `a`.\n\nThis is one of the easy parts of the inverse function theorem: it assumes that we already have\nan inverse function. -/\ntheorem local_homeomorph.cont_diff_at_symm_deriv [complete_space 𝕜] (f : local_homeomorph 𝕜 𝕜) {f₀' a : 𝕜}\n    (h₀ : f₀' ≠ 0) (ha : a ∈ f.target) (hf₀' : has_deriv_at f f₀' (f.symm a)) (hf : cont_diff_at 𝕜 n f (f.symm a)) :\n    cont_diff_at 𝕜 n f.symm a :=\n  f.cont_diff_at_symm ha (hf₀'.has_fderiv_at_equiv h₀) hf\n#align local_homeomorph.cont_diff_at_symm_deriv local_homeomorph.cont_diff_at_symm_deriv\n\n",
 "cont_diff_at_symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/-- If `f` is a local homeomorphism and the point `a` is in its target,\nand if `f` is `n` times continuously differentiable at `f.symm a`,\nand if the derivative at `f.symm a` is a continuous linear equivalence,\nthen `f.symm` is `n` times continuously differentiable at the point `a`.\n\nThis is one of the easy parts of the inverse function theorem: it assumes that we already have\nan inverse function. -/\ntheorem local_homeomorph.cont_diff_at_symm [complete_space E] (f : local_homeomorph E F) {f₀' : «expr ≃L[ ] » E 𝕜 F}\n    {a : F} (ha : a ∈ f.target) (hf₀' : has_fderiv_at f (f₀' : «expr →L[ ] » E 𝕜 F) (f.symm a))\n    (hf : cont_diff_at 𝕜 n f (f.symm a)) : cont_diff_at 𝕜 n f.symm a :=\n  by\n  -- We prove this by induction on `n`\n  induction' n using enat.nat_induction with n IH Itop\n  · rw [cont_diff_at_zero]\n    exact ⟨f.target, is_open.mem_nhds f.open_target ha, f.continuous_inv_fun⟩\n  · obtain ⟨f', ⟨u, hu, hff'⟩, hf'⟩ := cont_diff_at_succ_iff_has_fderiv_at.mp hf\n    apply cont_diff_at_succ_iff_has_fderiv_at.mpr\n    -- For showing `n.succ` times continuous differentiability (the main inductive step), it\n    -- suffices to produce the derivative and show that it is `n` times continuously differentiable\n    have eq_f₀' : f' (f.symm a) = f₀' := (hff' (f.symm a) (mem_of_mem_nhds hu)).unique hf₀'\n    -- This follows by a bootstrapping formula expressing the derivative as a function of `f` itself\n    refine' ⟨inverse ∘ f' ∘ f.symm, _, _⟩\n    · -- We first check that the derivative of `f` is that formula\n      have h_nhds : { y : E | ∃ e : «expr ≃L[ ] » E 𝕜 F, ↑e = f' y } ∈ (nhds) (f.symm a) :=\n        by\n        have hf₀' := f₀'.nhds\n        rw [← eq_f₀'] at hf₀'\n        exact hf'.continuous_at.preimage_mem_nhds hf₀'\n      obtain ⟨t, htu, ht, htf⟩ := mem_nhds_iff.mp (filter.inter_mem hu h_nhds)\n      use f.target ∩ «expr ⁻¹' » f.symm t\n      refine' ⟨is_open.mem_nhds _ _, _⟩\n      · exact f.preimage_open_of_open_symm ht\n      · exact mem_inter ha (mem_preimage.mpr htf)\n      intro x hx\n      obtain ⟨hxu, e, he⟩ := htu hx.2\n      have h_deriv : has_fderiv_at f (↑e) (f.symm x) := by\n        rw [he]\n        exact hff' (f.symm x) hxu\n      convert f.has_fderiv_at_symm hx.1 h_deriv\n      simp [← he]\n    · -- Then we check that the formula, being a composition of `cont_diff` pieces, is\n      -- itself `cont_diff`\n      have h_deriv₁ : cont_diff_at 𝕜 n inverse (f' (f.symm a)) :=\n        by\n        rw [eq_f₀']\n        exact cont_diff_at_map_inverse _\n      have h_deriv₂ : cont_diff_at 𝕜 n f.symm a := by\n        refine' IH (hf.of_le _)\n        norm_cast\n        exact nat.le_succ n\n      exact (h_deriv₁.comp _ hf').comp _ h_deriv₂\n  · refine' cont_diff_at_top.mpr _\n    intro n\n    exact Itop n (cont_diff_at_top.mp hf n)\n#align local_homeomorph.cont_diff_at_symm local_homeomorph.cont_diff_at_symm\n\n",
 "cont_diff_at_succ_iff_has_fderiv_at":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- A function is `C^(n + 1)` at a point iff locally, it has a derivative which is `C^n`. -/\ntheorem cont_diff_at_succ_iff_has_fderiv_at {n : ℕ} :\n    cont_diff_at 𝕜 (n + 1 : ℕ) f x ↔\n      ∃ f' : E → «expr →L[ ] » E 𝕜 F, (∃ u ∈ (nhds) x, ∀ x ∈ u, has_fderiv_at f (f' x) x) ∧ cont_diff_at 𝕜 n f' x :=\n  by\n  rw [← cont_diff_within_at_univ, cont_diff_within_at_succ_iff_has_fderiv_within_at]\n  simp only [nhds_within_univ, exists_prop, mem_univ, insert_eq_of_mem]\n  constructor\n  · rintro ⟨u, H, f', h_fderiv, h_cont_diff⟩\n    rcases mem_nhds_iff.mp H with ⟨t, htu, ht, hxt⟩\n    refine' ⟨f', ⟨t, _⟩, h_cont_diff.cont_diff_at H⟩\n    refine' ⟨mem_nhds_iff.mpr ⟨t, subset.rfl, ht, hxt⟩, _⟩\n    intro y hyt\n    refine' (h_fderiv y (htu hyt)).has_fderiv_at _\n    exact mem_nhds_iff.mpr ⟨t, htu, ht, hyt⟩\n  · rintro ⟨f', ⟨u, H, h_fderiv⟩, h_cont_diff⟩\n    refine' ⟨u, H, f', _, h_cont_diff.cont_diff_within_at⟩\n    intro x hxu\n    exact (h_fderiv x hxu).has_fderiv_within_at\n#align cont_diff_at_succ_iff_has_fderiv_at cont_diff_at_succ_iff_has_fderiv_at\n\n",
 "cont_diff_at_snd":
 "/-- The second projection at a point in a product is `C^∞`. -/\ntheorem cont_diff_at_snd {p : E × F} : cont_diff_at 𝕜 n (prod.snd : E × F → F) p :=\n  cont_diff_snd.cont_diff_at\n#align cont_diff_at_snd cont_diff_at_snd\n\n",
 "cont_diff_at_ring_inverse":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/-- In a complete normed algebra, the operation of inversion is `C^n`, for all `n`, at each\ninvertible element.  The proof is by induction, bootstrapping using an identity expressing the\nderivative of inversion as a bilinear map of inversion itself. -/\ntheorem cont_diff_at_ring_inverse [complete_space R] (x : «expr ˣ» R) : cont_diff_at 𝕜 n Ring.inverse (x : R) :=\n  by\n  induction' n using enat.nat_induction with n IH Itop\n  · intro m hm\n    refine' ⟨{ y : R | is_unit y }, _, _⟩\n    · simp [nhds_within_univ]\n      exact x.nhds\n    · use ftaylor_series_within 𝕜 inverse univ\n      rw [le_antisymm hm bot_le, has_ftaylor_series_up_to_on_zero_iff]\n      constructor\n      · rintro _ ⟨x', rfl⟩\n        exact (inverse_continuous_at x').continuous_within_at\n      · simp [ftaylor_series_within]\n  · apply cont_diff_at_succ_iff_has_fderiv_at.mpr\n    refine' ⟨fun x : R => -mul_left_right 𝕜 R (inverse x) (inverse x), _, _⟩\n    · refine' ⟨{ y : R | is_unit y }, x.nhds, _⟩\n      rintro _ ⟨y, rfl⟩\n      rw [inverse_unit]\n      exact has_fderiv_at_ring_inverse y\n    · convert (mul_left_right_is_bounded_bilinear 𝕜 R).cont_diff.neg.comp_cont_diff_at (x : R) (IH.prod IH)\n  · exact cont_diff_at_top.mpr Itop\n#align cont_diff_at_ring_inverse cont_diff_at_ring_inverse\n\n",
 "cont_diff_at_prod'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\ntheorem cont_diff_at_prod' {t : Finset ι} {f : ι → E → 𝔸'} (h : ∀ i ∈ t, cont_diff_at 𝕜 n (f i) x) :\n    cont_diff_at 𝕜 n\n      (finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" t (f i)) x :=\n  cont_diff_within_at_prod' h\n#align cont_diff_at_prod' cont_diff_at_prod'\n\n",
 "cont_diff_at_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\ntheorem cont_diff_at_prod {t : Finset ι} {f : ι → E → 𝔸'} (h : ∀ i ∈ t, cont_diff_at 𝕜 n (f i) x) :\n    cont_diff_at 𝕜 n\n      (fun y =>\n        finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" t (f i y))\n      x :=\n  cont_diff_within_at_prod h\n#align cont_diff_at_prod cont_diff_at_prod\n\n",
 "cont_diff_at_pi":
 "theorem cont_diff_at_pi : cont_diff_at 𝕜 n Φ x ↔ ∀ i, cont_diff_at 𝕜 n (fun x => Φ x i) x :=\n  cont_diff_within_at_pi\n#align cont_diff_at_pi cont_diff_at_pi\n\n",
 "cont_diff_at_one_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ∞» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ∞» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem cont_diff_at_one_iff :\n    cont_diff_at 𝕜 1 f x ↔\n      ∃ f' : E → «expr →L[ ] » E 𝕜 F, ∃ u ∈ (nhds) x, continuous_on f' u ∧ ∀ x ∈ u, has_fderiv_at f (f' x) x :=\n  by\n  simp_rw [show (1 : «exprℕ∞») = (0 + 1 : ℕ) from (zero_add 1).symm, cont_diff_at_succ_iff_has_fderiv_at,\n    show ((0 : ℕ) : «exprℕ∞») = 0 from rfl, cont_diff_at_zero,\n    exists_mem_and_iff antitone_bforall antitone_continuous_on, and_comm']\n#align cont_diff_at_one_iff cont_diff_at_one_iff\n\n",
 "cont_diff_at_of_subsingleton":
 "@[nontriviality]\ntheorem cont_diff_at_of_subsingleton [subsingleton F] : cont_diff_at 𝕜 n f x :=\n  by\n  rw [subsingleton.elim f fun _ => 0]\n  exact cont_diff_at_const\n#align cont_diff_at_of_subsingleton cont_diff_at_of_subsingleton\n\n",
 "cont_diff_at_map_inverse":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/-- At a continuous linear equivalence `e : E ≃L[𝕜] F` between Banach spaces, the operation of\ninversion is `C^n`, for all `n`. -/\ntheorem cont_diff_at_map_inverse [complete_space E] (e : «expr ≃L[ ] » E 𝕜 F) :\n    cont_diff_at 𝕜 n inverse (e : «expr →L[ ] » E 𝕜 F) :=\n  by\n  nontriviality E\n  -- first, we use the lemma `to_ring_inverse` to rewrite in terms of `ring.inverse` in the ring\n  -- `E →L[𝕜] E`\n  let O₁ : «expr →L[ ] » E 𝕜 E → «expr →L[ ] » F 𝕜 E := fun f => f.comp (e.symm : «expr →L[ ] » F 𝕜 E)\n  let O₂ : «expr →L[ ] » E 𝕜 F → «expr →L[ ] » E 𝕜 E := fun f => (e.symm : «expr →L[ ] » F 𝕜 E).comp f\n  have : continuous_linear_map.inverse = O₁ ∘ Ring.inverse ∘ O₂ := funext (to_ring_inverse e)\n  rw [this]\n  -- `O₁` and `O₂` are `cont_diff`,\n  -- so we reduce to proving that `ring.inverse` is `cont_diff`\n  have h₁ : cont_diff 𝕜 n O₁ := cont_diff_id.clm_comp cont_diff_const\n  have h₂ : cont_diff 𝕜 n O₂ := cont_diff_const.clm_comp cont_diff_id\n  refine' h₁.cont_diff_at.comp _ (cont_diff_at.comp _ _ h₂.cont_diff_at)\n  convert cont_diff_at_ring_inverse 𝕜 (1 : «expr ˣ» («expr →L[ ] » E 𝕜 E))\n  simp [O₂, one_def]\n#align cont_diff_at_map_inverse cont_diff_at_map_inverse\n\n",
 "cont_diff_at_inv":
 "theorem cont_diff_at_inv {x : 𝕜'} (hx : x ≠ 0) {n} : cont_diff_at 𝕜 n has_inv.inv x := by\n  simpa only [Ring.inverse_eq_inv'] using cont_diff_at_ring_inverse 𝕜 (Units.mk0 x hx)\n#align cont_diff_at_inv cont_diff_at_inv\n\n",
 "cont_diff_at_id":
 "theorem cont_diff_at_id {x} : cont_diff_at 𝕜 n (id : E → E) x :=\n  cont_diff_id.cont_diff_at\n#align cont_diff_at_id cont_diff_at_id\n\n",
 "cont_diff_at_fst":
 "/-- The first projection at a point in a product is `C^∞`. -/\ntheorem cont_diff_at_fst {p : E × F} : cont_diff_at 𝕜 n (prod.fst : E × F → E) p :=\n  cont_diff_fst.cont_diff_at\n#align cont_diff_at_fst cont_diff_at_fst\n\n",
 "cont_diff_at_const":
 "theorem cont_diff_at_const {c : F} : cont_diff_at 𝕜 n (fun x : E => c) x :=\n  cont_diff_const.cont_diff_at\n#align cont_diff_at_const cont_diff_at_const\n\n",
 "cont_diff_at_comp_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃L[ ] » -/\n/-- Composition by continuous linear equivs on the right respects higher differentiability at a\npoint. -/\ntheorem continuous_linear_equiv.cont_diff_at_comp_iff (e : «expr ≃L[ ] » G 𝕜 E) :\n    cont_diff_at 𝕜 n (f ∘ e) (e.symm x) ↔ cont_diff_at 𝕜 n f x :=\n  by\n  rw [← cont_diff_within_at_univ, ← cont_diff_within_at_univ, ← preimage_univ]\n  exact e.cont_diff_within_at_comp_iff\n#align continuous_linear_equiv.cont_diff_at_comp_iff continuous_linear_equiv.cont_diff_at_comp_iff\n\n",
 "cont_diff_at":
 "theorem cont_diff.cont_diff_at (h : cont_diff 𝕜 n f) : cont_diff_at 𝕜 n f x :=\n  cont_diff_iff_cont_diff_at.1 h x\n#align cont_diff.cont_diff_at cont_diff.cont_diff_at\n\n",
 "cont_diff_apply_apply":
 "theorem cont_diff_apply_apply (i : ι) (j : ι') : cont_diff 𝕜 n fun f : ι → ι' → E => f i j :=\n  cont_diff_pi.mp (cont_diff_apply 𝕜 (ι' → E) i) j\n#align cont_diff_apply_apply cont_diff_apply_apply\n\n",
 "cont_diff_apply":
 "theorem cont_diff_apply (i : ι) : cont_diff 𝕜 n fun f : ι → E => f i :=\n  cont_diff_pi.mp cont_diff_id i\n#align cont_diff_apply cont_diff_apply\n\n",
 "cont_diff_all_iff_nat":
 "theorem cont_diff_all_iff_nat : (∀ n, cont_diff 𝕜 n f) ↔ ∀ n : ℕ, cont_diff 𝕜 n f := by\n  simp only [← cont_diff_on_univ, cont_diff_on_all_iff_nat]\n#align cont_diff_all_iff_nat cont_diff_all_iff_nat\n\n",
 "cont_diff_add":
 "-- The sum is smooth.\ntheorem cont_diff_add : cont_diff 𝕜 n fun p : F × F => p.1 + p.2 :=\n  (is_bounded_linear_map.fst.add is_bounded_linear_map.snd).cont_diff\n#align cont_diff_add cont_diff_add\n\n",
 "cont_diff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∞» -/\n/-- Bilinear functions are `C^∞`.\n-/\ntheorem is_bounded_bilinear_map.cont_diff (hb : is_bounded_bilinear_map 𝕜 b) : cont_diff 𝕜 n b :=\n  by\n  suffices h : cont_diff 𝕜 («expr∞») b; · exact h.of_le le_top\n  rw [cont_diff_top_iff_fderiv]\n  refine' ⟨hb.differentiable, _⟩\n  simp [hb.fderiv]\n  exact hb.is_bounded_linear_map_deriv.cont_diff\n#align is_bounded_bilinear_map.cont_diff is_bounded_bilinear_map.cont_diff\n\n",
 "const_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- The scalar multiplication of a constant and a `C^n` on a domain is `C^n`. -/\ntheorem cont_diff_on.const_smul {s : set E} {f : E → F} (c : R) (hf : cont_diff_on 𝕜 n f s) :\n    cont_diff_on 𝕜 n (fun y => «expr • » c (f y)) s := fun x hx => (hf x hx).const_smul c\n#align cont_diff_on.const_smul cont_diff_on.const_smul\n\n",
 "congr_of_eventually_eq_insert":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\ntheorem cont_diff_within_at.congr_of_eventually_eq_insert (h : cont_diff_within_at 𝕜 n f s x)\n    (h₁ : «expr =ᶠ[ ] » f₁ (nhds_within (insert x s) x) f) : cont_diff_within_at 𝕜 n f₁ s x :=\n  h.congr_of_eventually_eq (nhds_within_mono x (subset_insert x s) h₁) (mem_of_mem_nhds_within (mem_insert x s) h₁ : _)\n#align cont_diff_within_at.congr_of_eventually_eq_insert cont_diff_within_at.congr_of_eventually_eq_insert\n\n",
 "congr_of_eventually_eq'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\ntheorem cont_diff_within_at.congr_of_eventually_eq' (h : cont_diff_within_at 𝕜 n f s x)\n    (h₁ : «expr =ᶠ[ ] » f₁ (nhds_within s x) f) (hx : x ∈ s) : cont_diff_within_at 𝕜 n f₁ s x :=\n  h.congr_of_eventually_eq h₁ <| h₁.self_of_nhds_within hx\n#align cont_diff_within_at.congr_of_eventually_eq' cont_diff_within_at.congr_of_eventually_eq'\n\n",
 "congr_of_eventually_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem cont_diff_at.congr_of_eventually_eq (h : cont_diff_at 𝕜 n f x) (hg : «expr =ᶠ[ ] » f₁ ((nhds) x) f) :\n    cont_diff_at 𝕜 n f₁ x :=\n  h.congr_of_eventually_eq' (by rwa [nhds_within_univ]) (mem_univ x)\n#align cont_diff_at.congr_of_eventually_eq cont_diff_at.congr_of_eventually_eq\n\n",
 "congr_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\ntheorem cont_diff_within_at.congr_nhds (h : cont_diff_within_at 𝕜 n f s x) {t : set E}\n    (hst : nhds_within s x = nhds_within t x) : cont_diff_within_at 𝕜 n f t x :=\n  h.mono_of_mem <| hst ▸ self_mem_nhds_within\n#align cont_diff_within_at.congr_nhds cont_diff_within_at.congr_nhds\n\n",
 "congr_mono":
 "theorem cont_diff_on.congr_mono (hf : cont_diff_on 𝕜 n f s) (h₁ : ∀ x ∈ s₁, f₁ x = f x) (hs : s₁ ⊆ s) :\n    cont_diff_on 𝕜 n f₁ s₁ :=\n  (hf.mono hs).congr h₁\n#align cont_diff_on.congr_mono cont_diff_on.congr_mono\n\n",
 "congr'":
 "theorem cont_diff_within_at.congr' (h : cont_diff_within_at 𝕜 n f s x) (h₁ : ∀ y ∈ s, f₁ y = f y) (hx : x ∈ s) :\n    cont_diff_within_at 𝕜 n f₁ s x :=\n  h.congr h₁ (h₁ _ hx)\n#align cont_diff_within_at.congr' cont_diff_within_at.congr'\n\n",
 "congr":
 "theorem cont_diff_on.congr (h : cont_diff_on 𝕜 n f s) (h₁ : ∀ x ∈ s, f₁ x = f x) : cont_diff_on 𝕜 n f₁ s := fun x hx =>\n  (h x hx).congr h₁ (h₁ x hx)\n#align cont_diff_on.congr cont_diff_on.congr\n\n",
 "comp₃":
 "theorem cont_diff.comp₃ {g : E₁ × E₂ × E₃ → G} {f₁ : F → E₁} {f₂ : F → E₂} {f₃ : F → E₃} (hg : cont_diff 𝕜 n g)\n    (hf₁ : cont_diff 𝕜 n f₁) (hf₂ : cont_diff 𝕜 n f₂) (hf₃ : cont_diff 𝕜 n f₃) :\n    cont_diff 𝕜 n fun x => g (f₁ x, f₂ x, f₃ x) :=\n  hg.comp₂ hf₁ <| hf₂.prod hf₃\n#align cont_diff.comp₃ cont_diff.comp₃\n\n",
 "comp₂":
 "theorem cont_diff.comp₂ {g : E₁ × E₂ → G} {f₁ : F → E₁} {f₂ : F → E₂} (hg : cont_diff 𝕜 n g) (hf₁ : cont_diff 𝕜 n f₁)\n    (hf₂ : cont_diff 𝕜 n f₂) : cont_diff 𝕜 n fun x => g (f₁ x, f₂ x) :=\n  hg.comp <| hf₁.prod hf₂\n#align cont_diff.comp₂ cont_diff.comp₂\n\n",
 "comp_same_univ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/-- Auxiliary lemma proving that the composition of `C^n` functions on domains is `C^n` when all\nspaces live in the same universe. Use instead `cont_diff_on.comp` which removes the universe\nassumption (but is deduced from this one). -/\nprivate theorem cont_diff_on.comp_same_univ {Eu : Type u} [normed_add_comm_group Eu] [normed_space 𝕜 Eu] {Fu : Type u}\n    [normed_add_comm_group Fu] [normed_space 𝕜 Fu] {Gu : Type u} [normed_add_comm_group Gu] [normed_space 𝕜 Gu]\n    {s : set Eu} {t : set Fu} {g : Fu → Gu} {f : Eu → Fu} (hg : cont_diff_on 𝕜 n g t) (hf : cont_diff_on 𝕜 n f s)\n    (st : s ⊆ «expr ⁻¹' » f t) : cont_diff_on 𝕜 n (g ∘ f) s :=\n  by\n  induction' n using enat.nat_induction with n IH Itop generalizing Eu Fu Gu\n  · rw [cont_diff_on_zero] at hf hg⊢\n    exact continuous_on.comp hg hf st\n  · rw [cont_diff_on_succ_iff_has_fderiv_within_at] at hg⊢\n    intro x hx\n    rcases(cont_diff_on_succ_iff_has_fderiv_within_at.1 hf) x hx with ⟨u, hu, f', hf', f'_diff⟩\n    rcases hg (f x) (st hx) with ⟨v, hv, g', hg', g'_diff⟩\n    rw [insert_eq_of_mem hx] at hu⊢\n    have xu : x ∈ u := mem_of_mem_nhds_within hx hu\n    let w := s ∩ (u ∩ «expr ⁻¹' » f v)\n    have wv : w ⊆ «expr ⁻¹' » f v := fun y hy => hy.2.2\n    have wu : w ⊆ u := fun y hy => hy.2.1\n    have ws : w ⊆ s := fun y hy => hy.1\n    refine' ⟨w, _, fun y => (g' (f y)).comp (f' y), _, _⟩\n    show w ∈ nhds_within s x\n    · apply filter.inter_mem self_mem_nhds_within\n      apply filter.inter_mem hu\n      apply continuous_within_at.preimage_mem_nhds_within'\n      · rw [← continuous_within_at_inter' hu]\n        exact (hf' x xu).differentiable_within_at.continuous_within_at.mono (inter_subset_right _ _)\n      · apply nhds_within_mono _ _ hv\n        exact subset.trans (image_subset_iff.mpr st) (subset_insert (f x) t)\n    show ∀ y ∈ w, has_fderiv_within_at (g ∘ f) ((g' (f y)).comp (f' y)) w y\n    · rintro y ⟨ys, yu, yv⟩\n      exact (hg' (f y) yv).comp y ((hf' y yu).mono wu) wv\n    show cont_diff_on 𝕜 n (fun y => (g' (f y)).comp (f' y)) w\n    · have A : cont_diff_on 𝕜 n (fun y => g' (f y)) w :=\n        IH g'_diff ((hf.of_le (WithTop.coe_le_coe.2 (nat.le_succ n))).mono ws) wv\n      have B : cont_diff_on 𝕜 n f' w := f'_diff.mono wu\n      have C : cont_diff_on 𝕜 n (fun y => (g' (f y), f' y)) w := A.prod B\n      have D : cont_diff_on 𝕜 n (fun p : «expr →L[ ] » Fu 𝕜 Gu × «expr →L[ ] » Eu 𝕜 Fu => p.1.comp p.2) univ :=\n        is_bounded_bilinear_map_comp.cont_diff.cont_diff_on\n      exact IH D C (subset_univ _)\n  · rw [cont_diff_on_top] at hf hg⊢\n    exact fun n => Itop n (hg n) (hf n) st\n#align cont_diff_on.comp_same_univ cont_diff_on.comp_same_univ\n\n",
 "comp_of_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/-- The composition of `C^n` functions at points in domains is `C^n`,\n  with a weaker condition on `s` and `t`. -/\ntheorem cont_diff_within_at.comp_of_mem {s : set E} {t : set F} {g : F → G} {f : E → F} (x : E)\n    (hg : cont_diff_within_at 𝕜 n g t (f x)) (hf : cont_diff_within_at 𝕜 n f s x)\n    (hs : t ∈ nhds_within («expr '' » f s) (f x)) : cont_diff_within_at 𝕜 n (g ∘ f) s x :=\n  (hg.mono_of_mem hs).comp x hf (subset_preimage_image f s)\n#align cont_diff_within_at.comp_of_mem cont_diff_within_at.comp_of_mem\n\n",
 "comp_continuous_linear_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/-- Composition by continuous linear maps on the right preserves `C^n` functions. -/\ntheorem cont_diff.comp_continuous_linear_map {f : E → F} {g : «expr →L[ ] » G 𝕜 E} (hf : cont_diff 𝕜 n f) :\n    cont_diff 𝕜 n (f ∘ g) :=\n  cont_diff_on_univ.1 <| cont_diff_on.comp_continuous_linear_map (cont_diff_on_univ.2 hf) _\n#align cont_diff.comp_continuous_linear_map cont_diff.comp_continuous_linear_map\n\n",
 "comp_cont_diff_within_at_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃L[ ] » -/\n/-- Composition by continuous linear equivs on the left respects higher differentiability at a\npoint in a domain. -/\ntheorem continuous_linear_equiv.comp_cont_diff_within_at_iff (e : «expr ≃L[ ] » F 𝕜 G) :\n    cont_diff_within_at 𝕜 n (e ∘ f) s x ↔ cont_diff_within_at 𝕜 n f s x :=\n  ⟨fun H => by\n    simpa only [(· ∘ ·), e.symm.coe_coe, e.symm_apply_apply] using\n      H.continuous_linear_map_comp (e.symm : «expr →L[ ] » G 𝕜 F),\n    fun H => H.continuous_linear_map_comp (e : «expr →L[ ] » F 𝕜 G)⟩\n#align continuous_linear_equiv.comp_cont_diff_within_at_iff continuous_linear_equiv.comp_cont_diff_within_at_iff\n\n",
 "comp_cont_diff_within_at":
 "theorem cont_diff.comp_cont_diff_within_at {g : F → G} {f : E → F} (h : cont_diff 𝕜 n g)\n    (hf : cont_diff_within_at 𝕜 n f t x) : cont_diff_within_at 𝕜 n (g ∘ f) t x :=\n  haveI : cont_diff_within_at 𝕜 n g univ (f x) := h.cont_diff_at.cont_diff_within_at\n  this.comp x hf (subset_univ _)\n#align cont_diff.comp_cont_diff_within_at cont_diff.comp_cont_diff_within_at\n\n",
 "comp_cont_diff_on₃":
 "theorem cont_diff.comp_cont_diff_on₃ {g : E₁ × E₂ × E₃ → G} {f₁ : F → E₁} {f₂ : F → E₂} {f₃ : F → E₃} {s : set F}\n    (hg : cont_diff 𝕜 n g) (hf₁ : cont_diff_on 𝕜 n f₁ s) (hf₂ : cont_diff_on 𝕜 n f₂ s) (hf₃ : cont_diff_on 𝕜 n f₃ s) :\n    cont_diff_on 𝕜 n (fun x => g (f₁ x, f₂ x, f₃ x)) s :=\n  hg.comp_cont_diff_on₂ hf₁ <| hf₂.prod hf₃\n#align cont_diff.comp_cont_diff_on₃ cont_diff.comp_cont_diff_on₃\n\n",
 "comp_cont_diff_on₂":
 "theorem cont_diff.comp_cont_diff_on₂ {g : E₁ × E₂ → G} {f₁ : F → E₁} {f₂ : F → E₂} {s : set F} (hg : cont_diff 𝕜 n g)\n    (hf₁ : cont_diff_on 𝕜 n f₁ s) (hf₂ : cont_diff_on 𝕜 n f₂ s) : cont_diff_on 𝕜 n (fun x => g (f₁ x, f₂ x)) s :=\n  hg.comp_cont_diff_on <| hf₁.prod hf₂\n#align cont_diff.comp_cont_diff_on₂ cont_diff.comp_cont_diff_on₂\n\n",
 "comp_cont_diff_on_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃L[ ] » -/\n/-- Composition by continuous linear equivs on the left respects higher differentiability on\ndomains. -/\ntheorem continuous_linear_equiv.comp_cont_diff_on_iff (e : «expr ≃L[ ] » F 𝕜 G) :\n    cont_diff_on 𝕜 n (e ∘ f) s ↔ cont_diff_on 𝕜 n f s := by simp [cont_diff_on, e.comp_cont_diff_within_at_iff]\n#align continuous_linear_equiv.comp_cont_diff_on_iff continuous_linear_equiv.comp_cont_diff_on_iff\n\n",
 "comp_cont_diff_on":
 "/-- The composition of a `C^n` function on a domain with a `C^n` function is `C^n`. -/\ntheorem cont_diff.comp_cont_diff_on {s : set E} {g : F → G} {f : E → F} (hg : cont_diff 𝕜 n g)\n    (hf : cont_diff_on 𝕜 n f s) : cont_diff_on 𝕜 n (g ∘ f) s :=\n  (cont_diff_on_univ.2 hg).comp hf subset_preimage_univ\n#align cont_diff.comp_cont_diff_on cont_diff.comp_cont_diff_on\n\n",
 "comp_cont_diff_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃L[ ] » -/\n/-- Composition by continuous linear equivs on the left respects higher differentiability. -/\ntheorem continuous_linear_equiv.comp_cont_diff_iff (e : «expr ≃L[ ] » F 𝕜 G) :\n    cont_diff 𝕜 n (e ∘ f) ↔ cont_diff 𝕜 n f := by simp only [← cont_diff_on_univ, e.comp_cont_diff_on_iff]\n#align continuous_linear_equiv.comp_cont_diff_iff continuous_linear_equiv.comp_cont_diff_iff\n\n",
 "comp_cont_diff_at_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃L[ ] » -/\n/-- Composition by continuous linear equivs on the left respects higher differentiability at a\npoint. -/\ntheorem continuous_linear_equiv.comp_cont_diff_at_iff (e : «expr ≃L[ ] » F 𝕜 G) :\n    cont_diff_at 𝕜 n (e ∘ f) x ↔ cont_diff_at 𝕜 n f x := by\n  simp only [← cont_diff_within_at_univ, e.comp_cont_diff_within_at_iff]\n#align continuous_linear_equiv.comp_cont_diff_at_iff continuous_linear_equiv.comp_cont_diff_at_iff\n\n",
 "comp_cont_diff_at":
 "theorem cont_diff.comp_cont_diff_at {g : F → G} {f : E → F} (x : E) (hg : cont_diff 𝕜 n g) (hf : cont_diff_at 𝕜 n f x) :\n    cont_diff_at 𝕜 n (g ∘ f) x :=\n  hg.comp_cont_diff_within_at hf\n#align cont_diff.comp_cont_diff_at cont_diff.comp_cont_diff_at\n\n",
 "comp'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/-- The composition of `C^n` functions at points in domains is `C^n`. -/\ntheorem cont_diff_within_at.comp' {s : set E} {t : set F} {g : F → G} {f : E → F} (x : E)\n    (hg : cont_diff_within_at 𝕜 n g t (f x)) (hf : cont_diff_within_at 𝕜 n f s x) :\n    cont_diff_within_at 𝕜 n (g ∘ f) (s ∩ «expr ⁻¹' » f t) x :=\n  hg.comp x (hf.mono (inter_subset_left _ _)) (inter_subset_right _ _)\n#align cont_diff_within_at.comp' cont_diff_within_at.comp'\n\n",
 "comp":
 "/-- The composition of `C^n` functions at points is `C^n`. -/\ntheorem cont_diff_at.comp (x : E) (hg : cont_diff_at 𝕜 n g (f x)) (hf : cont_diff_at 𝕜 n f x) :\n    cont_diff_at 𝕜 n (g ∘ f) x :=\n  hg.comp x hf subset_preimage_univ\n#align cont_diff_at.comp cont_diff_at.comp\n\n",
 "clm_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\ntheorem cont_diff_on.clm_comp {g : X → «expr →L[ ] » F 𝕜 G} {f : X → «expr →L[ ] » E 𝕜 F} {s : set X}\n    (hg : cont_diff_on 𝕜 n g s) (hf : cont_diff_on 𝕜 n f s) : cont_diff_on 𝕜 n (fun x => (g x).comp (f x)) s :=\n  is_bounded_bilinear_map_comp.cont_diff.comp_cont_diff_on₂ hg hf\n#align cont_diff_on.clm_comp cont_diff_on.clm_comp\n\n",
 "add":
 "/-- The sum of two `C^n` functions on a domain is `C^n`. -/\ntheorem cont_diff_on.add {s : set E} {f g : E → F} (hf : cont_diff_on 𝕜 n f s) (hg : cont_diff_on 𝕜 n g s) :\n    cont_diff_on 𝕜 n (fun x => f x + g x) s := fun x hx => (hf x hx).add (hg x hx)\n#align cont_diff_on.add cont_diff_on.add\n\n"}