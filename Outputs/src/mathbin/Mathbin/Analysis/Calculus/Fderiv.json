{"unique_on":
 "/-- If `f'` and `fâ‚'` are two derivatives of `f` within `s` at `x`, then they are equal on the\ntangent cone to `s` at `x` -/\ntheorem has_fderiv_within_at.unique_on (hf : has_fderiv_within_at f f' s x) (hg : has_fderiv_within_at f fâ‚' s x) :\n    EqOn f' fâ‚' (tangent_cone_at ğ•œ s x) := fun y âŸ¨c, d, dtop, clim, cdlimâŸ© =>\n  tendsto_nhds_unique (hf.lim atTop dtop clim cdlim) (hg.lim atTop dtop clim cdlim)\n#align has_fderiv_within_at.unique_on has_fderiv_within_at.unique_on\n\n",
 "unique_diff_within_at_of_continuous_linear_equiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰ƒL[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\ntheorem has_fderiv_within_at.unique_diff_within_at_of_continuous_linear_equiv {x : E} (e' : Â«expr â‰ƒL[ ] Â» E ğ•œ F)\n    (h : has_fderiv_within_at f (e' : Â«expr â†’L[ ] Â» E ğ•œ F) s x) (hs : unique_diff_within_at ğ•œ s x) :\n    unique_diff_within_at ğ•œ (Â«expr '' Â» f s) (f x) :=\n  h.unique_diff_within_at hs e'.surjective.dense_range\n#align has_fderiv_within_at.unique_diff_within_at_of_continuous_linear_equiv has_fderiv_within_at.unique_diff_within_at_of_continuous_linear_equiv\n\n",
 "unique_diff_within_at":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/-- If a set has the unique differentiability property at a point x, then the image of this set\nunder a map with onto derivative has also the unique differentiability property at the image point.\n-/\ntheorem has_fderiv_within_at.unique_diff_within_at {x : E} (h : has_fderiv_within_at f f' s x)\n    (hs : unique_diff_within_at ğ•œ s x) (h' : DenseRange f') : unique_diff_within_at ğ•œ (Â«expr '' Â» f s) (f x) :=\n  by\n  refine' âŸ¨h'.dense_of_maps_to f'.continuous hs.1 _, h.continuous_within_at.mem_closure_image hs.2âŸ©\n  show Submodule.span ğ•œ (tangent_cone_at ğ•œ s x) â‰¤ (Submodule.span ğ•œ (tangent_cone_at ğ•œ (Â«expr '' Â» f s) (f x))).comap f'\n  rw [Submodule.span_le]\n  exact h.maps_to_tangent_cone.mono (subset.refl _) Submodule.subset_span\n#align has_fderiv_within_at.unique_diff_within_at has_fderiv_within_at.unique_diff_within_at\n\n",
 "unique_diff_on_preimage_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰ƒL[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n@[simp]\ntheorem continuous_linear_equiv.unique_diff_on_preimage_iff (e : Â«expr â‰ƒL[ ] Â» F ğ•œ E) :\n    unique_diff_on ğ•œ (Â«expr â»Â¹' Â» e s) â†” unique_diff_on ğ•œ s := by\n  rw [â† e.image_symm_eq_preimage, e.symm.unique_diff_on_image_iff]\n#align continuous_linear_equiv.unique_diff_on_preimage_iff continuous_linear_equiv.unique_diff_on_preimage_iff\n\n",
 "unique_diff_on_image_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰ƒL[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n@[simp]\ntheorem continuous_linear_equiv.unique_diff_on_image_iff (e : Â«expr â‰ƒL[ ] Â» E ğ•œ F) :\n    unique_diff_on ğ•œ (Â«expr '' Â» e s) â†” unique_diff_on ğ•œ s :=\n  âŸ¨fun h => e.symm_image_image s â–¸ e.symm.unique_diff_on_image h, e.unique_diff_on_imageâŸ©\n#align continuous_linear_equiv.unique_diff_on_image_iff continuous_linear_equiv.unique_diff_on_image_iff\n\n",
 "unique_diff_on_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰ƒL[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\ntheorem continuous_linear_equiv.unique_diff_on_image (e : Â«expr â‰ƒL[ ] Â» E ğ•œ F) (h : unique_diff_on ğ•œ s) :\n    unique_diff_on ğ•œ (Â«expr '' Â» e s) :=\n  h.image (fun x _ => e.has_fderiv_within_at) fun x hx => e.surjective.dense_range\n#align continuous_linear_equiv.unique_diff_on_image continuous_linear_equiv.unique_diff_on_image\n\n",
 "unique":
 "theorem has_fderiv_at.unique (hâ‚€ : has_fderiv_at f fâ‚€' x) (hâ‚ : has_fderiv_at f fâ‚' x) : fâ‚€' = fâ‚' :=\n  by\n  rw [â† has_fderiv_within_at_univ] at hâ‚€ hâ‚\n  exact unique_diff_within_at_univ.eq hâ‚€ hâ‚\n#align has_fderiv_at.unique has_fderiv_at.unique\n\n",
 "union":
 "theorem has_fderiv_within_at.union (hs : has_fderiv_within_at f f' s x) (ht : has_fderiv_within_at f f' t x) :\n    has_fderiv_within_at f f' (s âˆª t) x :=\n  by\n  simp only [has_fderiv_within_at, nhdsWithin_union]\n  exact hs.sup ht\n#align has_fderiv_within_at.union has_fderiv_within_at.union\n\n",
 "tendsto_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem has_fderiv_at_filter.tendsto_nhds (hL : L â‰¤ (nhds) x) (h : has_fderiv_at_filter f f' x L) :\n    Tendsto f L ((nhds) (f x)) :=\n  by\n  have : tendsto (fun x' => f x' - f x) L ((nhds) 0) :=\n    by\n    refine' h.is_O_sub.trans_tendsto (tendsto.mono_left _ hL)\n    rw [â† sub_self x]\n    exact tendsto_id.sub tendsto_const_nhds\n  have := tendsto.add this tendsto_const_nhds\n  rw [zero_add (f x)] at this\n  exact this.congr (by simp only [sub_add_cancel, eq_self_iff_true, forall_const])\n#align has_fderiv_at_filter.tendsto_nhds has_fderiv_at_filter.tendsto_nhds\n\n",
 "support_fderiv_subset":
 "theorem support_fderiv_subset : support (fderiv ğ•œ f) âŠ† tsupport f :=\n  by\n  intro x\n  rw [â† not_imp_not]\n  intro h2x\n  rw [not_mem_tsupport_iff_eventuallyEq] at h2x\n  exact nmem_support.mpr (h2x.fderiv_eq.trans <| fderiv_const_apply 0)\n#align support_fderiv_subset support_fderiv_subset\n\n",
 "sum":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n@[simp]\ntheorem differentiable.sum (h : âˆ€ i âˆˆ u, differentiable ğ•œ (A i)) :\n    differentiable ğ•œ fun y =>\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" u (A i y) :=\n  fun x => differentiable_at.sum fun i hi => h i hi x\n#align differentiable.sum differentiable.sum\n\n",
 "sub_const":
 "theorem differentiable.sub_const (hf : differentiable ğ•œ f) (c : F) : differentiable ğ•œ fun y => f y - c := fun x =>\n  (hf x).sub_const c\n#align differentiable.sub_const differentiable.sub_const\n\n",
 "sub":
 "@[simp]\ntheorem differentiable.sub (hf : differentiable ğ•œ f) (hg : differentiable ğ•œ g) : differentiable ğ•œ fun y => f y - g y :=\n  fun x => (hf x).sub (hg x)\n#align differentiable.sub differentiable.sub\n\n",
 "snd":
 "theorem fderiv_within.snd (hs : unique_diff_within_at ğ•œ s x) (h : differentiable_within_at ğ•œ fâ‚‚ s x) :\n    fderiv_within ğ•œ (fun x => (fâ‚‚ x).2) s x = (snd ğ•œ F G).comp (fderiv_within ğ•œ fâ‚‚ s x) :=\n  h.has_fderiv_within_at.snd.fderiv_within hs\n#align fderiv_within.snd fderiv_within.snd\n\n",
 "smul_const":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\ntheorem differentiable.smul_const (hc : differentiable ğ•œ c) (f : F) : differentiable ğ•œ fun y => Â«expr â€¢ Â» (c y) f :=\n  fun x => (hc x).smul_const f\n#align differentiable.smul_const differentiable.smul_const\n\n",
 "smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n@[simp]\ntheorem differentiable.smul (hc : differentiable ğ•œ c) (hf : differentiable ğ•œ f) :\n    differentiable ğ•œ fun y => Â«expr â€¢ Â» (c y) (f y) := fun x => (hc x).smul (hf x)\n#align differentiable.smul differentiable.smul\n\n",
 "restrict_scalars":
 "theorem differentiable.restrict_scalars (h : differentiable ğ•œ' f) : differentiable ğ•œ f := fun x =>\n  (h x).restrict_scalars ğ•œ\n#align differentiable.restrict_scalars differentiable.restrict_scalars\n\n",
 "prod_map":
 "@[simp]\nprotected theorem differentiable_at.prod_map (hf : differentiable_at ğ•œ f p.1) (hfâ‚‚ : differentiable_at ğ•œ fâ‚‚ p.2) :\n    differentiable_at ğ•œ (fun p : E Ã— G => (f p.1, fâ‚‚ p.2)) p :=\n  (hf.comp p differentiable_at_fst).prod (hfâ‚‚.comp p differentiable_at_snd)\n#align differentiable_at.prod_map differentiable_at.prod_map\n\n",
 "prod":
 "@[simp]\ntheorem differentiable.prod (hfâ‚ : differentiable ğ•œ fâ‚) (hfâ‚‚ : differentiable ğ•œ fâ‚‚) :\n    differentiable ğ•œ fun x : E => (fâ‚ x, fâ‚‚ x) := fun x => differentiable_at.prod (hfâ‚ x) (hfâ‚‚ x)\n#align differentiable.prod differentiable.prod\n\n",
 "pow":
 "@[simp]\ntheorem differentiable.pow (ha : differentiable ğ•œ a) (n : â„•) : differentiable ğ•œ fun x => a x ^ n := fun x =>\n  (ha x).pow n\n#align differentiable.pow differentiable.pow\n\n",
 "of_local_left_inverse":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr =O[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰ƒL[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/-- If `f (g y) = y` for `y` in some neighborhood of `a`, `g` is continuous at `a`, and `f` has an\ninvertible derivative `f'` at `g a`, then `g` has the derivative `f'â»Â¹` at `a`.\n\nThis is one of the easy parts of the inverse function theorem: it assumes that we already have\nan inverse function. -/\ntheorem has_fderiv_at.of_local_left_inverse {f : E â†’ F} {f' : Â«expr â‰ƒL[ ] Â» E ğ•œ F} {g : F â†’ E} {a : F}\n    (hg : ContinuousAt g a) (hf : has_fderiv_at f (f' : Â«expr â†’L[ ] Â» E ğ•œ F) (g a))\n    (hfg :\n      Â«exprâˆ€á¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â»\" ((nhds) a)\n        (f (g y) = y)) :\n    has_fderiv_at g (f'.symm : Â«expr â†’L[ ] Â» F ğ•œ E) a :=\n  by\n  have : Â«expr =O[ ] Â» (fun x : F => g x - g a - f'.symm (x - a)) ((nhds) a) fun x : F => f' (g x - g a) - (x - a) :=\n    by\n    refine' ((f'.symm : Â«expr â†’L[ ] Â» F ğ•œ E).is_O_comp _ _).congr (fun x => _) fun _ => rfl\n    simp\n  refine' this.trans_is_o _\n  clear this\n  refine' ((hf.comp_tendsto hg).symm.congr' (hfg.mono _) (eventually_of_forall fun _ => rfl)).trans_is_O _\n  Â· rintro p hp\n    simp [hp, hfg.self_of_nhds]\n  Â· refine' ((hf.is_O_sub_rev f'.antilipschitz).comp_tendsto hg).congr' (eventually_of_forall fun _ => rfl) (hfg.mono _)\n    rintro p hp\n    simp only [(Â· âˆ˜ Â·), hp, hfg.self_of_nhds]\n#align has_fderiv_at.of_local_left_inverse has_fderiv_at.of_local_left_inverse\n\n",
 "nhds_within":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\ntheorem has_fderiv_within_at.nhds_within (h : has_fderiv_within_at f f' s x) (ht : s âˆˆ nhds_within t x) :\n    has_fderiv_within_at f f' t x :=\n  (has_fderiv_within_at_inter' ht).1 (h.mono (inter_subset_right _ _))\n#align has_fderiv_within_at.nhds_within has_fderiv_within_at.nhds_within\n\n",
 "neg":
 "theorem differentiable.neg (h : differentiable ğ•œ f) : differentiable ğ•œ fun y => -f y := fun x => (h x).neg\n#align differentiable.neg differentiable.neg\n\n",
 "mul_const'":
 "theorem has_fderiv_at.mul_const' (ha : has_fderiv_at a a' x) (b : ğ”¸) :\n    has_fderiv_at (fun y => a y * b) (a'.smul_right b) x :=\n  ((continuous_linear_map.mul ğ•œ ğ”¸).flip b).has_fderiv_at.comp x ha\n#align has_fderiv_at.mul_const' has_fderiv_at.mul_const'\n\n",
 "mul_const":
 "theorem differentiable.mul_const (ha : differentiable ğ•œ a) (b : ğ”¸) : differentiable ğ•œ fun y => a y * b := fun x =>\n  (ha x).mul_const b\n#align differentiable.mul_const differentiable.mul_const\n\n",
 "mul'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\ntheorem has_fderiv_at.mul' (ha : has_fderiv_at a a' x) (hb : has_fderiv_at b b' x) :\n    has_fderiv_at (fun y => a y * b y) (Â«expr â€¢ Â» (a x) b' + a'.smul_right (b x)) x :=\n  ((continuous_linear_map.mul ğ•œ ğ”¸).is_bounded_bilinear_map.has_fderiv_at (a x, b x)).comp x (ha.prod hb)\n#align has_fderiv_at.mul' has_fderiv_at.mul'\n\n",
 "mul":
 "@[simp]\ntheorem differentiable.mul (ha : differentiable ğ•œ a) (hb : differentiable ğ•œ b) : differentiable ğ•œ fun y => a y * b y :=\n  fun x => (ha x).mul (hb x)\n#align differentiable.mul differentiable.mul\n\n",
 "mono_of_mem":
 "theorem differentiable_within_at.mono_of_mem (h : differentiable_within_at ğ•œ f s x) {t : Set E}\n    (hst : s âˆˆ nhdsWithin x t) : differentiable_within_at ğ•œ f t x :=\n  (h.has_fderiv_within_at.mono_of_mem hst).differentiable_within_at\n#align differentiable_within_at.mono_of_mem differentiable_within_at.mono_of_mem\n\n",
 "mono":
 "theorem differentiable_on.mono (h : differentiable_on ğ•œ f t) (st : s âŠ† t) : differentiable_on ğ•œ f s := fun x hx =>\n  (h x (st hx)).mono st\n#align differentiable_on.mono differentiable_on.mono\n\n",
 "maps_to_tangent_cone":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/-- The image of a tangent cone under the differential of a map is included in the tangent cone to\nthe image. -/\ntheorem has_fderiv_within_at.maps_to_tangent_cone {x : E} (h : has_fderiv_within_at f f' s x) :\n    MapsTo f' (tangent_cone_at ğ•œ s x) (tangent_cone_at ğ•œ (Â«expr '' Â» f s) (f x)) :=\n  by\n  rintro v âŸ¨c, d, dtop, clim, cdlimâŸ©\n  refine' âŸ¨c, fun n => f (x + d n) - f x, mem_of_superset dtop _, clim, h.lim at_top dtop clim cdlimâŸ©\n  simp (config := { contextual := true }) [-mem_image, mem_image_of_mem]\n#align has_fderiv_within_at.maps_to_tangent_cone has_fderiv_within_at.maps_to_tangent_cone\n\n",
 "lim_real":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem has_fderiv_at.lim_real (hf : has_fderiv_at f f' x) (v : E) :\n    Tendsto (fun c : exprâ„ => Â«expr â€¢ Â» c (f (x + Â«expr â€¢ Â» câ»Â¹ v) - f x)) atTop ((nhds) (f' v)) :=\n  by\n  apply hf.lim v\n  rw [tendsto_at_top_at_top]\n  exact fun b => âŸ¨b, fun a ha => le_trans ha (le_abs_self _)âŸ©\n#align has_fderiv_at.lim_real has_fderiv_at.lim_real\n\n",
 "lim":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- Directional derivative agrees with `has_fderiv`. -/\ntheorem has_fderiv_at.lim (hf : has_fderiv_at f f' x) (v : E) {Î± : Type _} {c : Î± â†’ ğ•œ} {l : Filter Î±}\n    (hc : Tendsto (fun n => Â«exprâ€– â€–Â» (c n)) l atTop) :\n    Tendsto (fun n => Â«expr â€¢ Â» (c n) (f (x + Â«expr â€¢ Â» (c n)â»Â¹ v) - f x)) l ((nhds) (f' v)) :=\n  by\n  refine' (has_fderiv_within_at_univ.2 hf).lim _ univ_mem hc _\n  intro U hU\n  refine' (eventually_ne_of_tendsto_norm_atTop hc (0 : ğ•œ)).mono fun y hy => _\n  convert mem_of_mem_nhds hU\n  dsimp only\n  rw [â† mul_smul, mul_inv_cancel hy, one_smul]\n#align has_fderiv_at.lim has_fderiv_at.lim\n\n",
 "le_of_lip'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/-- Converse to the mean value inequality: if `f` is differentiable at `xâ‚€` and `C`-lipschitz\non a neighborhood of `xâ‚€` then it its derivative at `xâ‚€` has norm bounded by `C`. This version\nonly assumes that `â€–f x - f xâ‚€â€– â‰¤ C * â€–x - xâ‚€â€–` in a neighborhood of `x`. -/\ntheorem has_fderiv_at.le_of_lip' {f : E â†’ F} {f' : Â«expr â†’L[ ] Â» E ğ•œ F} {xâ‚€ : E} (hf : has_fderiv_at f f' xâ‚€)\n    {C : exprâ„} (hCâ‚€ : 0 â‰¤ C)\n    (hlip :\n      Â«exprâˆ€á¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â»\"\n        ((nhds) xâ‚€) (Â«exprâ€– â€–Â» (f x - f xâ‚€) â‰¤ C * Â«exprâ€– â€–Â» (x - xâ‚€))) :\n    Â«exprâ€– â€–Â» f' â‰¤ C := by\n  refine' le_of_forall_pos_le_add fun Îµ Îµ0 => op_norm_le_of_nhds_zero _ _\n  exact add_nonneg hCâ‚€ Îµ0.le\n  rw [â† map_add_left_nhds_zero xâ‚€, eventually_map] at hlip\n  filter_upwards [is_o_iff.1 (has_fderiv_at_iff_is_o_nhds_zero.1 hf) Îµ0, hlip]with y hy hyC\n  rw [add_sub_cancel'] at hyC\n  calc\n    Â«exprâ€– â€–Â» (f' y) â‰¤ Â«exprâ€– â€–Â» (f (xâ‚€ + y) - f xâ‚€) + Â«exprâ€– â€–Â» (f (xâ‚€ + y) - f xâ‚€ - f' y) := norm_le_insert _ _\n    _ â‰¤ C * Â«exprâ€– â€–Â» y + Îµ * Â«exprâ€– â€–Â» y := (add_le_add hyC hy)\n    _ = (C + Îµ) * Â«exprâ€– â€–Â» y := (add_mul _ _ _).symm\n    \n#align has_fderiv_at.le_of_lip' has_fderiv_at.le_of_lip'\n\n",
 "le_of_lip":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/-- Converse to the mean value inequality: if `f` is differentiable at `xâ‚€` and `C`-lipschitz\non a neighborhood of `xâ‚€` then it its derivative at `xâ‚€` has norm bounded by `C`.\nVersion using `fderiv`. -/\ntheorem fderiv_at.le_of_lip {f : E â†’ F} {xâ‚€ : E} (hf : differentiable_at ğ•œ f xâ‚€) {s : Set E} (hs : s âˆˆ (nhds) xâ‚€)\n    {C : nnreal} (hlip : LipschitzOnWith C f s) : Â«exprâ€– â€–Â» (fderiv ğ•œ f xâ‚€) â‰¤ C :=\n  hf.has_fderiv_at.le_of_lip hs hlip\n#align fderiv_at.le_of_lip fderiv_at.le_of_lip\n\n",
 "iterate":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr ^[ ]Â» -/\nprotected theorem differentiable_within_at.iterate {f : E â†’ E} (hf : differentiable_within_at ğ•œ f s x) (hx : f x = x)\n    (hs : MapsTo f s s) (n : â„•) : differentiable_within_at ğ•œ (Â«expr ^[ ]Â» f n) s x :=\n  (hf.has_fderiv_within_at.iterate hx hs n).differentiable_within_at\n#align differentiable_within_at.iterate differentiable_within_at.iterate\n\n",
 "is_O_sub_rev":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr =O[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr =O[ ] Â» -/\ntheorem has_fderiv_at_filter.is_O_sub_rev (hf : has_fderiv_at_filter f f' x L) {C} (hf' : AntilipschitzWith C f') :\n    Â«expr =O[ ] Â» (fun x' => x' - x) L fun x' => f x' - f x :=\n  have : Â«expr =O[ ] Â» (fun x' => x' - x) L fun x' => f' (x' - x) :=\n    isBigO_iff.2 âŸ¨C, eventually_of_forall fun x' => AddMonoidHomClass.bound_of_antilipschitz f' hf' _âŸ©\n  (this.trans (hf.trans_is_O this).right_is_O_add).congr (fun _ => rfl) fun _ => sub_add_cancel _ _\n#align has_fderiv_at_filter.is_O_sub_rev has_fderiv_at_filter.is_O_sub_rev\n\n",
 "is_O_sub":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr =O[ ] Â» -/\ntheorem has_fderiv_at_filter.is_O_sub (h : has_fderiv_at_filter f f' x L) :\n    Â«expr =O[ ] Â» (fun x' => f x' - f x) L fun x' => x' - x :=\n  h.is_O.congr_of_sub.2 (f'.is_O_sub _ _)\n#align has_fderiv_at_filter.is_O_sub has_fderiv_at_filter.is_O_sub\n\n",
 "is_O":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr =O[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem has_fderiv_at.is_O {f : E â†’ F} {xâ‚€ : E} {f' : Â«expr â†’L[ ] Â» E ğ•œ F} (h : has_fderiv_at f f' xâ‚€) :\n    Â«expr =O[ ] Â» (fun x => f x - f xâ‚€) ((nhds) xâ‚€) fun x => x - xâ‚€ := by\n  simpa only [sub_add_cancel] using h.is_O.add (is_O_sub f' ((nhds) xâ‚€) xâ‚€)\n#align has_fderiv_at.is_O has_fderiv_at.is_O\n\n",
 "insert":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\ntheorem has_fderiv_within_at.insert {g' : Â«expr â†’L[ ] Â» E ğ•œ F} (h : has_fderiv_within_at g g' s x) :\n    has_fderiv_within_at g g' (insert x s) x :=\n  h.insert'\n#align has_fderiv_within_at.insert has_fderiv_within_at.insert\n\n",
 "image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\ntheorem unique_diff_on.image {f' : E â†’ Â«expr â†’L[ ] Â» E ğ•œ F} (hs : unique_diff_on ğ•œ s)\n    (hf' : âˆ€ x âˆˆ s, has_fderiv_within_at f (f' x) s x) (hd : âˆ€ x âˆˆ s, DenseRange (f' x)) :\n    unique_diff_on ğ•œ (Â«expr '' Â» f s) :=\n  ball_image_iff.2 fun x hx => (hf' x hx).unique_diff_within_at (hs x hx) (hd x hx)\n#align unique_diff_on.image unique_diff_on.image\n\n",
 "has_strict_fderiv_at_symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰ƒL[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/-- If `f` is a local homeomorphism defined on a neighbourhood of `f.symm a`, and `f` has an\ninvertible derivative `f'` in the sense of strict differentiability at `f.symm a`, then `f.symm` has\nthe derivative `f'â»Â¹` at `a`.\n\nThis is one of the easy parts of the inverse function theorem: it assumes that we already have\nan inverse function. -/\ntheorem local_homeomorph.has_strict_fderiv_at_symm (f : LocalHomeomorph E F) {f' : Â«expr â‰ƒL[ ] Â» E ğ•œ F} {a : F}\n    (ha : a âˆˆ f.target) (htff' : has_strict_fderiv_at f (f' : Â«expr â†’L[ ] Â» E ğ•œ F) (f.symm a)) :\n    has_strict_fderiv_at f.symm (f'.symm : Â«expr â†’L[ ] Â» F ğ•œ E) a :=\n  htff'.of_local_left_inverse (f.symm.continuous_at ha) (f.eventually_right_inverse ha)\n#align local_homeomorph.has_strict_fderiv_at_symm local_homeomorph.has_strict_fderiv_at_symm\n\n",
 "has_strict_fderiv_at_snd":
 "theorem has_strict_fderiv_at_snd : has_strict_fderiv_at (@Prod.snd E F) (snd ğ•œ E F) p :=\n  (snd ğ•œ E F).has_strict_fderiv_at\n#align has_strict_fderiv_at_snd has_strict_fderiv_at_snd\n\n",
 "has_strict_fderiv_at_pi'":
 "@[simp]\ntheorem has_strict_fderiv_at_pi' :\n    has_strict_fderiv_at Î¦ Î¦' x â†” âˆ€ i, has_strict_fderiv_at (fun x => Î¦ x i) ((proj i).comp Î¦') x :=\n  by\n  simp only [has_strict_fderiv_at, ContinuousLinearMap.coe_pi]\n  exact is_o_pi\n#align has_strict_fderiv_at_pi' has_strict_fderiv_at_pi'\n\n",
 "has_strict_fderiv_at_pi":
 "@[simp]\ntheorem has_strict_fderiv_at_pi :\n    has_strict_fderiv_at (fun x i => Ï† i x) (ContinuousLinearMap.pi Ï†') x â†” âˆ€ i, has_strict_fderiv_at (Ï† i) (Ï†' i) x :=\n  has_strict_fderiv_at_pi'\n#align has_strict_fderiv_at_pi has_strict_fderiv_at_pi\n\n",
 "has_strict_fderiv_at_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr =á¶ [ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem filter.eventually_eq.has_strict_fderiv_at_iff (h : Â«expr =á¶ [ ] Â» fâ‚€ ((nhds) x) fâ‚) (h' : âˆ€ y, fâ‚€' y = fâ‚' y) :\n    has_strict_fderiv_at fâ‚€ fâ‚€' x â†” has_strict_fderiv_at fâ‚ fâ‚' x :=\n  by\n  refine' is_o_congr ((h.prod_mk_nhds h).mono _) (eventually_of_forall fun _ => rfl)\n  rintro p âŸ¨hpâ‚, hpâ‚‚âŸ©\n  simp only [*]\n#align filter.eventually_eq.has_strict_fderiv_at_iff filter.eventually_eq.has_strict_fderiv_at_iff\n\n",
 "has_strict_fderiv_at_id":
 "theorem has_strict_fderiv_at_id (x : E) : has_strict_fderiv_at id (id ğ•œ E) x :=\n  (isLittleO_zero _ _).congr_left <| by simp\n#align has_strict_fderiv_at_id has_strict_fderiv_at_id\n\n",
 "has_strict_fderiv_at_fst":
 "theorem has_strict_fderiv_at_fst : has_strict_fderiv_at (@Prod.fst E F) (fst ğ•œ E F) p :=\n  (fst ğ•œ E F).has_strict_fderiv_at\n#align has_strict_fderiv_at_fst has_strict_fderiv_at_fst\n\n",
 "has_strict_fderiv_at_const":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\ntheorem has_strict_fderiv_at_const (c : F) (x : E) : has_strict_fderiv_at (fun _ => c) (0 : Â«expr â†’L[ ] Â» E ğ•œ F) x :=\n  (isLittleO_zero _ _).congr_left fun _ => by simp only [zero_apply, sub_self]\n#align has_strict_fderiv_at_const has_strict_fderiv_at_const\n\n",
 "has_strict_fderiv_at":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰ƒL[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\nprotected theorem has_strict_fderiv_at : has_strict_fderiv_at iso (iso : Â«expr â†’L[ ] Â» E ğ•œ F) x :=\n  (iso : Â«expr â‰ƒL[ ] Â» E ğ•œ F).has_strict_fderiv_at\n#align has_strict_fderiv_at has_strict_fderiv_at\n\n",
 "has_fderiv_within_at_univ":
 "@[simp]\ntheorem has_fderiv_within_at_univ : has_fderiv_within_at f f' univ x â†” has_fderiv_at f f' x :=\n  by\n  simp only [has_fderiv_within_at, nhdsWithin_univ]\n  rfl\n#align has_fderiv_within_at_univ has_fderiv_within_at_univ\n\n",
 "has_fderiv_within_at_snd":
 "theorem has_fderiv_within_at_snd {s : Set (E Ã— F)} : has_fderiv_within_at (@Prod.snd E F) (snd ğ•œ E F) s p :=\n  has_fderiv_at_filter_snd\n#align has_fderiv_within_at_snd has_fderiv_within_at_snd\n\n",
 "has_fderiv_within_at_singleton":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\ntheorem has_fderiv_within_at_singleton (f : E â†’ F) (x : E) : has_fderiv_within_at f (0 : Â«expr â†’L[ ] Â» E ğ•œ F) {x} x :=\n  by\n  simp only [has_fderiv_within_at, nhdsWithin_singleton, has_fderiv_at_filter, is_o_pure,\n    ContinuousLinearMap.zero_apply, sub_self]\n#align has_fderiv_within_at_singleton has_fderiv_within_at_singleton\n\n",
 "has_fderiv_within_at_pi'":
 "@[simp]\ntheorem has_fderiv_within_at_pi' :\n    has_fderiv_within_at Î¦ Î¦' s x â†” âˆ€ i, has_fderiv_within_at (fun x => Î¦ x i) ((proj i).comp Î¦') s x :=\n  has_fderiv_at_filter_pi'\n#align has_fderiv_within_at_pi' has_fderiv_within_at_pi'\n\n",
 "has_fderiv_within_at_pi":
 "theorem has_fderiv_within_at_pi :\n    has_fderiv_within_at (fun x i => Ï† i x) (ContinuousLinearMap.pi Ï†') s x â†”\n      âˆ€ i, has_fderiv_within_at (Ï† i) (Ï†' i) s x :=\n  has_fderiv_at_filter_pi\n#align has_fderiv_within_at_pi has_fderiv_within_at_pi\n\n",
 "has_fderiv_within_at_of_restrict_scalars":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\ntheorem has_fderiv_within_at_of_restrict_scalars {g' : Â«expr â†’L[ ] Â» E ğ•œ F} (h : has_fderiv_within_at f g' s x)\n    (H : f'.restrict_scalars ğ•œ = g') : has_fderiv_within_at f f' s x :=\n  by\n  rw [â† H] at h\n  exact h\n#align has_fderiv_within_at_of_restrict_scalars has_fderiv_within_at_of_restrict_scalars\n\n",
 "has_fderiv_within_at_of_not_mem_closure":
 "/-- If `x` is not in the closure of `s`, then `f` has any derivative at `x` within `s`,\nas this statement is empty. -/\ntheorem has_fderiv_within_at_of_not_mem_closure (h : x âˆ‰ closure s) : has_fderiv_within_at f f' s x :=\n  by\n  simp only [mem_closure_iff_nhdsWithin_neBot, ne_bot_iff, ne.def, Classical.not_not] at h\n  simp [has_fderiv_within_at, has_fderiv_at_filter, h, is_o, is_O_with]\n#align has_fderiv_within_at_of_not_mem_closure has_fderiv_within_at_of_not_mem_closure\n\n",
 "has_fderiv_within_at_of_bilinear":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\ntheorem continuous_linear_map.has_fderiv_within_at_of_bilinear {f : G' â†’ E} {g : G' â†’ F} {f' : Â«expr â†’L[ ] Â» G' ğ•œ E}\n    {g' : Â«expr â†’L[ ] Â» G' ğ•œ F} {x : G'} {s : Set G'} (hf : has_fderiv_within_at f f' s x)\n    (hg : has_fderiv_within_at g g' s x) :\n    has_fderiv_within_at (fun y => B (f y) (g y)) (B.precompR G' (f x) g' + B.precompL G' f' (g x)) s x :=\n  (B.is_bounded_bilinear_map.has_fderiv_at (f x, g x)).comp_has_fderiv_within_at x (hf.prod hg)\n#align continuous_linear_map.has_fderiv_within_at_of_bilinear continuous_linear_map.has_fderiv_within_at_of_bilinear\n\n",
 "has_fderiv_within_at_inter'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\ntheorem has_fderiv_within_at_inter' (h : t âˆˆ nhds_within s x) :\n    has_fderiv_within_at f f' (s âˆ© t) x â†” has_fderiv_within_at f f' s x := by\n  simp [has_fderiv_within_at, nhdsWithin_restrict'' s h]\n#align has_fderiv_within_at_inter' has_fderiv_within_at_inter'\n\n",
 "has_fderiv_within_at_inter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem has_fderiv_within_at_inter (h : t âˆˆ (nhds) x) :\n    has_fderiv_within_at f f' (s âˆ© t) x â†” has_fderiv_within_at f f' s x := by\n  simp [has_fderiv_within_at, nhdsWithin_restrict' s h]\n#align has_fderiv_within_at_inter has_fderiv_within_at_inter\n\n",
 "has_fderiv_within_at_insert":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\ntheorem has_fderiv_within_at_insert {y : E} {g' : Â«expr â†’L[ ] Â» E ğ•œ F} :\n    has_fderiv_within_at g g' (insert y s) x â†” has_fderiv_within_at g g' s x :=\n  by\n  rcases eq_or_ne x y with (rfl | h)\n  Â· simp_rw [has_fderiv_within_at, has_fderiv_at_filter]\n    apply Asymptotics.isLittleO_insert\n    simp only [sub_self, g'.map_zero]\n  refine' âŸ¨fun h => h.mono <| subset_insert y s, fun hg => hg.mono_of_mem _âŸ©\n  simp_rw [nhdsWithin_insert_of_ne h, self_mem_nhdsWithin]\n#align has_fderiv_within_at_insert has_fderiv_within_at_insert\n\n",
 "has_fderiv_within_at_iff_tendsto":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem has_fderiv_within_at_iff_tendsto :\n    has_fderiv_within_at f f' s x â†”\n      Tendsto (fun x' => (Â«exprâ€– â€–Â» (x' - x))â»Â¹ * Â«exprâ€– â€–Â» (f x' - f x - f' (x' - x))) (nhds_within s x) ((nhds) 0) :=\n  has_fderiv_at_filter_iff_tendsto\n#align has_fderiv_within_at_iff_tendsto has_fderiv_within_at_iff_tendsto\n\n",
 "has_fderiv_within_at_iff_of_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr =á¶ [ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\ntheorem filter.eventually_eq.has_fderiv_within_at_iff_of_mem (h : Â«expr =á¶ [ ] Â» fâ‚€ (nhds_within s x) fâ‚) (hx : x âˆˆ s) :\n    has_fderiv_within_at fâ‚€ f' s x â†” has_fderiv_within_at fâ‚ f' s x :=\n  h.has_fderiv_within_at_iff (h.eq_of_nhds_within hx)\n#align filter.eventually_eq.has_fderiv_within_at_iff_of_mem filter.eventually_eq.has_fderiv_within_at_iff_of_mem\n\n",
 "has_fderiv_within_at_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr =á¶ [ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\ntheorem filter.eventually_eq.has_fderiv_within_at_iff (h : Â«expr =á¶ [ ] Â» fâ‚€ (nhds_within s x) fâ‚) (hx : fâ‚€ x = fâ‚ x) :\n    has_fderiv_within_at fâ‚€ f' s x â†” has_fderiv_within_at fâ‚ f' s x :=\n  h.has_fderiv_at_filter_iff hx fun _ => rfl\n#align filter.eventually_eq.has_fderiv_within_at_iff filter.eventually_eq.has_fderiv_within_at_iff\n\n",
 "has_fderiv_within_at_id":
 "theorem has_fderiv_within_at_id (x : E) (s : Set E) : has_fderiv_within_at id (id ğ•œ E) s x :=\n  has_fderiv_at_filter_id _ _\n#align has_fderiv_within_at_id has_fderiv_within_at_id\n\n",
 "has_fderiv_within_at_fst":
 "theorem has_fderiv_within_at_fst {s : Set (E Ã— F)} : has_fderiv_within_at (@Prod.fst E F) (fst ğ•œ E F) s p :=\n  has_fderiv_at_filter_fst\n#align has_fderiv_within_at_fst has_fderiv_within_at_fst\n\n",
 "has_fderiv_within_at_const":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\ntheorem has_fderiv_within_at_const (c : F) (x : E) (s : Set E) :\n    has_fderiv_within_at (fun x => c) (0 : Â«expr â†’L[ ] Â» E ğ•œ F) s x :=\n  has_fderiv_at_filter_const _ _ _\n#align has_fderiv_within_at_const has_fderiv_within_at_const\n\n",
 "has_fderiv_within_at":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰ƒL[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\nprotected theorem has_fderiv_within_at : has_fderiv_within_at iso (iso : Â«expr â†’L[ ] Â» E ğ•œ F) s x :=\n  (iso : Â«expr â‰ƒL[ ] Â» E ğ•œ F).has_fderiv_within_at\n#align has_fderiv_within_at has_fderiv_within_at\n\n",
 "has_fderiv_at_zero_of_eventually_const":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr =á¶ [ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\ntheorem has_fderiv_at_zero_of_eventually_const (c : F) (hf : Â«expr =á¶ [ ] Â» f ((nhds) x) fun y => c) :\n    has_fderiv_at f (0 : Â«expr â†’L[ ] Â» E ğ•œ F) x :=\n  (has_fderiv_at_const _ _).congr_of_eventually_eq hf\n#align has_fderiv_at_zero_of_eventually_const has_fderiv_at_zero_of_eventually_const\n\n",
 "has_fderiv_at_symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰ƒL[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/-- If `f` is a local homeomorphism defined on a neighbourhood of `f.symm a`, and `f` has an\ninvertible derivative `f'` at `f.symm a`, then `f.symm` has the derivative `f'â»Â¹` at `a`.\n\nThis is one of the easy parts of the inverse function theorem: it assumes that we already have\nan inverse function. -/\ntheorem local_homeomorph.has_fderiv_at_symm (f : LocalHomeomorph E F) {f' : Â«expr â‰ƒL[ ] Â» E ğ•œ F} {a : F}\n    (ha : a âˆˆ f.target) (htff' : has_fderiv_at f (f' : Â«expr â†’L[ ] Â» E ğ•œ F) (f.symm a)) :\n    has_fderiv_at f.symm (f'.symm : Â«expr â†’L[ ] Â» F ğ•œ E) a :=\n  htff'.of_local_left_inverse (f.symm.continuous_at ha) (f.eventually_right_inverse ha)\n#align local_homeomorph.has_fderiv_at_symm local_homeomorph.has_fderiv_at_symm\n\n",
 "has_fderiv_at_snd":
 "theorem has_fderiv_at_snd : has_fderiv_at (@Prod.snd E F) (snd ğ•œ E F) p :=\n  has_fderiv_at_filter_snd\n#align has_fderiv_at_snd has_fderiv_at_snd\n\n",
 "has_fderiv_at_ring_inverse":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr =o[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr Ë£Â» -/\n/-- At an invertible element `x` of a normed algebra `R`, the FrÃ©chet derivative of the inversion\noperation is the linear map `Î» t, - xâ»Â¹ * t * xâ»Â¹`. -/\ntheorem has_fderiv_at_ring_inverse (x : Â«expr Ë£Â» R) : has_fderiv_at Ring.inverse (-mul_left_right ğ•œ R â†‘xâ»Â¹ â†‘xâ»Â¹) x :=\n  by\n  have h_is_o : Â«expr =o[ ] Â» (fun t : R => inverse (â†‘x + t) - â†‘xâ»Â¹ + â†‘xâ»Â¹ * t * â†‘xâ»Â¹) ((nhds) 0) fun t : R => t :=\n    by\n    refine' (inverse_add_norm_diff_second_order x).trans_is_o (is_o_norm_norm.mp _)\n    simp only [norm_pow, norm_norm]\n    have h12 : 1 < 2 := by norm_num\n    convert(Asymptotics.isLittleO_pow_pow h12).comp_tendsto tendsto_norm_zero\n    ext\n    simp\n  have h_lim : tendsto (fun y : R => y - x) ((nhds) x) ((nhds) 0) :=\n    by\n    refine' tendsto_zero_iff_norm_tendsto_zero.mpr _\n    exact tendsto_iff_norm_tendsto_zero.mp tendsto_id\n  simp only [has_fderiv_at, has_fderiv_at_filter]\n  convert h_is_o.comp_tendsto h_lim\n  ext y\n  simp only [coe_comp', Function.comp_apply, mul_left_right_apply, neg_apply, inverse_unit x, Units.inv_mul,\n    add_sub_cancel'_right, mul_sub, sub_mul, one_mul, sub_neg_eq_add]\n#align has_fderiv_at_ring_inverse has_fderiv_at_ring_inverse\n\n",
 "has_fderiv_at_prod_mk_right":
 "theorem has_fderiv_at_prod_mk_right (eâ‚€ : E) (fâ‚€ : F) : has_fderiv_at (fun f : F => (eâ‚€, f)) (inr ğ•œ E F) fâ‚€ :=\n  (has_fderiv_at_const eâ‚€ fâ‚€).prod (has_fderiv_at_id fâ‚€)\n#align has_fderiv_at_prod_mk_right has_fderiv_at_prod_mk_right\n\n",
 "has_fderiv_at_prod_mk_left":
 "theorem has_fderiv_at_prod_mk_left (eâ‚€ : E) (fâ‚€ : F) : has_fderiv_at (fun e : E => (e, fâ‚€)) (inl ğ•œ E F) eâ‚€ :=\n  (has_fderiv_at_id eâ‚€).prod (has_fderiv_at_const fâ‚€ eâ‚€)\n#align has_fderiv_at_prod_mk_left has_fderiv_at_prod_mk_left\n\n",
 "has_fderiv_at_pi'":
 "@[simp]\ntheorem has_fderiv_at_pi' : has_fderiv_at Î¦ Î¦' x â†” âˆ€ i, has_fderiv_at (fun x => Î¦ x i) ((proj i).comp Î¦') x :=\n  has_fderiv_at_filter_pi'\n#align has_fderiv_at_pi' has_fderiv_at_pi'\n\n",
 "has_fderiv_at_pi":
 "theorem has_fderiv_at_pi :\n    has_fderiv_at (fun x i => Ï† i x) (ContinuousLinearMap.pi Ï†') x â†” âˆ€ i, has_fderiv_at (Ï† i) (Ï†' i) x :=\n  has_fderiv_at_filter_pi\n#align has_fderiv_at_pi has_fderiv_at_pi\n\n",
 "has_fderiv_at_of_subsingleton":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\ntheorem has_fderiv_at_of_subsingleton [h : subsingleton E] (f : E â†’ F) (x : E) :\n    has_fderiv_at f (0 : Â«expr â†’L[ ] Â» E ğ•œ F) x :=\n  by\n  rw [â† has_fderiv_within_at_univ, subsingleton_univ.eq_singleton_of_mem (mem_univ x)]\n  exact has_fderiv_within_at_singleton f x\n#align has_fderiv_at_of_subsingleton has_fderiv_at_of_subsingleton\n\n",
 "has_fderiv_at_of_restrict_scalars":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\ntheorem has_fderiv_at_of_restrict_scalars {g' : Â«expr â†’L[ ] Â» E ğ•œ F} (h : has_fderiv_at f g' x)\n    (H : f'.restrict_scalars ğ•œ = g') : has_fderiv_at f f' x :=\n  by\n  rw [â† H] at h\n  exact h\n#align has_fderiv_at_of_restrict_scalars has_fderiv_at_of_restrict_scalars\n\n",
 "has_fderiv_at_of_bilinear":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\ntheorem continuous_linear_map.has_fderiv_at_of_bilinear {f : G' â†’ E} {g : G' â†’ F} {f' : Â«expr â†’L[ ] Â» G' ğ•œ E}\n    {g' : Â«expr â†’L[ ] Â» G' ğ•œ F} {x : G'} (hf : has_fderiv_at f f' x) (hg : has_fderiv_at g g' x) :\n    has_fderiv_at (fun y => B (f y) (g y)) (B.precompR G' (f x) g' + B.precompL G' f' (g x)) x :=\n  (B.is_bounded_bilinear_map.has_fderiv_at (f x, g x)).comp x (hf.prod hg)\n#align continuous_linear_map.has_fderiv_at_of_bilinear continuous_linear_map.has_fderiv_at_of_bilinear\n\n",
 "has_fderiv_at_iff_tendsto":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem has_fderiv_at_iff_tendsto :\n    has_fderiv_at f f' x â†”\n      Tendsto (fun x' => (Â«exprâ€– â€–Â» (x' - x))â»Â¹ * Â«exprâ€– â€–Â» (f x' - f x - f' (x' - x))) ((nhds) x) ((nhds) 0) :=\n  has_fderiv_at_filter_iff_tendsto\n#align has_fderiv_at_iff_tendsto has_fderiv_at_iff_tendsto\n\n",
 "has_fderiv_at_iff_is_o_nhds_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr =o[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem has_fderiv_at_iff_is_o_nhds_zero :\n    has_fderiv_at f f' x â†” Â«expr =o[ ] Â» (fun h : E => f (x + h) - f x - f' h) ((nhds) 0) fun h => h :=\n  by\n  rw [has_fderiv_at, has_fderiv_at_filter, â† map_add_left_nhds_zero x, is_o_map]\n  simp [(Â· âˆ˜ Â·)]\n#align has_fderiv_at_iff_is_o_nhds_zero has_fderiv_at_iff_is_o_nhds_zero\n\n",
 "has_fderiv_at_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr =á¶ [ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem filter.eventually_eq.has_fderiv_at_iff (h : Â«expr =á¶ [ ] Â» fâ‚€ ((nhds) x) fâ‚) :\n    has_fderiv_at fâ‚€ f' x â†” has_fderiv_at fâ‚ f' x :=\n  h.has_fderiv_at_filter_iff h.eq_of_nhds fun _ => rfl\n#align filter.eventually_eq.has_fderiv_at_iff filter.eventually_eq.has_fderiv_at_iff\n\n",
 "has_fderiv_at_id":
 "theorem has_fderiv_at_id (x : E) : has_fderiv_at id (id ğ•œ E) x :=\n  has_fderiv_at_filter_id _ _\n#align has_fderiv_at_id has_fderiv_at_id\n\n",
 "has_fderiv_at_fst":
 "theorem has_fderiv_at_fst : has_fderiv_at (@Prod.fst E F) (fst ğ•œ E F) p :=\n  has_fderiv_at_filter_fst\n#align has_fderiv_at_fst has_fderiv_at_fst\n\n",
 "has_fderiv_at_filter_snd":
 "theorem has_fderiv_at_filter_snd {L : Filter (E Ã— F)} : has_fderiv_at_filter (@Prod.snd E F) (snd ğ•œ E F) p L :=\n  (snd ğ•œ E F).has_fderiv_at_filter\n#align has_fderiv_at_filter_snd has_fderiv_at_filter_snd\n\n",
 "has_fderiv_at_filter_real_equiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-\n  In the special case of a normed space over the reals,\n  we can use  scalar multiplication in the `tendsto` characterization\n  of the FrÃ©chet derivative.\n-/\ntheorem has_fderiv_at_filter_real_equiv {L : Filter E} :\n    Tendsto (fun x' : E => (Â«exprâ€– â€–Â» (x' - x))â»Â¹ * Â«exprâ€– â€–Â» (f x' - f x - f' (x' - x))) L ((nhds) 0) â†”\n      Tendsto (fun x' : E => Â«expr â€¢ Â» (Â«exprâ€– â€–Â» (x' - x))â»Â¹ (f x' - f x - f' (x' - x))) L ((nhds) 0) :=\n  by\n  symm\n  rw [tendsto_iff_norm_tendsto_zero]\n  refine' tendsto_congr fun x' => _\n  have : (Â«exprâ€– â€–Â» (x' - x))â»Â¹ â‰¥ 0 := inv_nonneg.mpr (norm_nonneg _)\n  simp [norm_smul, abs_of_nonneg this]\n#align has_fderiv_at_filter_real_equiv has_fderiv_at_filter_real_equiv\n\n",
 "has_fderiv_at_filter_pi'":
 "@[simp]\ntheorem has_fderiv_at_filter_pi' :\n    has_fderiv_at_filter Î¦ Î¦' x L â†” âˆ€ i, has_fderiv_at_filter (fun x => Î¦ x i) ((proj i).comp Î¦') x L :=\n  by\n  simp only [has_fderiv_at_filter, ContinuousLinearMap.coe_pi]\n  exact is_o_pi\n#align has_fderiv_at_filter_pi' has_fderiv_at_filter_pi'\n\n",
 "has_fderiv_at_filter_pi":
 "theorem has_fderiv_at_filter_pi :\n    has_fderiv_at_filter (fun x i => Ï† i x) (ContinuousLinearMap.pi Ï†') x L â†”\n      âˆ€ i, has_fderiv_at_filter (Ï† i) (Ï†' i) x L :=\n  has_fderiv_at_filter_pi'\n#align has_fderiv_at_filter_pi has_fderiv_at_filter_pi\n\n",
 "has_fderiv_at_filter_iff_tendsto":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem has_fderiv_at_filter_iff_tendsto :\n    has_fderiv_at_filter f f' x L â†”\n      Tendsto (fun x' => (Â«exprâ€– â€–Â» (x' - x))â»Â¹ * Â«exprâ€– â€–Â» (f x' - f x - f' (x' - x))) L ((nhds) 0) :=\n  by\n  have h : âˆ€ x', Â«exprâ€– â€–Â» (x' - x) = 0 â†’ Â«exprâ€– â€–Â» (f x' - f x - f' (x' - x)) = 0 := fun x' hx' =>\n    by\n    rw [sub_eq_zero.1 (norm_eq_zero.1 hx')]\n    simp\n  unfold has_fderiv_at_filter\n  rw [â† is_o_norm_left, â† is_o_norm_right, is_o_iff_tendsto h]\n  exact tendsto_congr fun _ => div_eq_inv_mul _ _\n#align has_fderiv_at_filter_iff_tendsto has_fderiv_at_filter_iff_tendsto\n\n",
 "has_fderiv_at_filter_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr =á¶ [ ] Â» -/\ntheorem filter.eventually_eq.has_fderiv_at_filter_iff (hâ‚€ : Â«expr =á¶ [ ] Â» fâ‚€ L fâ‚) (hx : fâ‚€ x = fâ‚ x)\n    (hâ‚ : âˆ€ x, fâ‚€' x = fâ‚' x) : has_fderiv_at_filter fâ‚€ fâ‚€' x L â†” has_fderiv_at_filter fâ‚ fâ‚' x L :=\n  isLittleO_congr (hâ‚€.mono fun y hy => by simp only [hy, hâ‚, hx]) (eventually_of_forall fun _ => rfl)\n#align filter.eventually_eq.has_fderiv_at_filter_iff filter.eventually_eq.has_fderiv_at_filter_iff\n\n",
 "has_fderiv_at_filter_id":
 "theorem has_fderiv_at_filter_id (x : E) (L : Filter E) : has_fderiv_at_filter id (id ğ•œ E) x L :=\n  (isLittleO_zero _ _).congr_left <| by simp\n#align has_fderiv_at_filter_id has_fderiv_at_filter_id\n\n",
 "has_fderiv_at_filter_fst":
 "theorem has_fderiv_at_filter_fst {L : Filter (E Ã— F)} : has_fderiv_at_filter (@Prod.fst E F) (fst ğ•œ E F) p L :=\n  (fst ğ•œ E F).has_fderiv_at_filter\n#align has_fderiv_at_filter_fst has_fderiv_at_filter_fst\n\n",
 "has_fderiv_at_filter_const":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\ntheorem has_fderiv_at_filter_const (c : F) (x : E) (L : Filter E) :\n    has_fderiv_at_filter (fun x => c) (0 : Â«expr â†’L[ ] Â» E ğ•œ F) x L :=\n  (isLittleO_zero _ _).congr_left fun _ => by simp only [zero_apply, sub_self]\n#align has_fderiv_at_filter_const has_fderiv_at_filter_const\n\n",
 "has_fderiv_at_filter":
 "theorem is_bounded_linear_map.has_fderiv_at_filter (h : is_bounded_linear_map ğ•œ f) :\n    has_fderiv_at_filter f h.to_continuous_linear_map x L :=\n  h.to_continuous_linear_map.has_fderiv_at_filter\n#align is_bounded_linear_map.has_fderiv_at_filter is_bounded_linear_map.has_fderiv_at_filter\n\n",
 "has_fderiv_at_const":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\ntheorem has_fderiv_at_const (c : F) (x : E) : has_fderiv_at (fun x => c) (0 : Â«expr â†’L[ ] Â» E ğ•œ F) x :=\n  has_fderiv_at_filter_const _ _ _\n#align has_fderiv_at_const has_fderiv_at_const\n\n",
 "has_fderiv_at":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰ƒL[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\nprotected theorem has_fderiv_at : has_fderiv_at iso (iso : Â«expr â†’L[ ] Â» E ğ•œ F) x :=\n  (iso : Â«expr â‰ƒL[ ] Â» E ğ•œ F).has_fderiv_at\n#align has_fderiv_at has_fderiv_at\n\n",
 "fst":
 "theorem fderiv_within.fst (hs : unique_diff_within_at ğ•œ s x) (h : differentiable_within_at ğ•œ fâ‚‚ s x) :\n    fderiv_within ğ•œ (fun x => (fâ‚‚ x).1) s x = (fst ğ•œ F G).comp (fderiv_within ğ•œ fâ‚‚ s x) :=\n  h.has_fderiv_within_at.fst.fderiv_within hs\n#align fderiv_within.fst fderiv_within.fst\n\n",
 "fderiv_zero_of_not_differentiable_at":
 "theorem fderiv_zero_of_not_differentiable_at (h : Â¬differentiable_at ğ•œ f x) : fderiv ğ•œ f x = 0 :=\n  by\n  have : Â¬âˆƒ f', has_fderiv_at f f' x := h\n  simp [fderiv, this]\n#align fderiv_zero_of_not_differentiable_at fderiv_zero_of_not_differentiable_at\n\n",
 "fderiv_within_zero_of_not_differentiable_within_at":
 "/-\nCopyright (c) 2019 Jeremy Avigad. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Jeremy Avigad, SÃ©bastien GouÃ«zel, Yury Kudryashov\n-/\ntheorem fderiv_within_zero_of_not_differentiable_within_at (h : Â¬differentiable_within_at ğ•œ f s x) :\n    fderiv_within ğ•œ f s x = 0 := by\n  have : Â¬âˆƒ f', has_fderiv_within_at f f' s x := h\n  simp [fderiv_within, this]\n#align fderiv_within_zero_of_not_differentiable_within_at fderiv_within_zero_of_not_differentiable_within_at\n\n",
 "fderiv_within_univ":
 "@[simp]\ntheorem fderiv_within_univ : fderiv_within ğ•œ f univ = fderiv ğ•œ f :=\n  by\n  ext x : 1\n  by_cases h : differentiable_at ğ•œ f x\n  Â· apply has_fderiv_within_at.fderiv_within _ unique_diff_within_at_univ\n    rw [has_fderiv_within_at_univ]\n    apply h.has_fderiv_at\n  Â· have : Â¬differentiable_within_at ğ•œ f univ x := by rwa [differentiable_within_at_univ]\n    rw [fderiv_zero_of_not_differentiable_at h, fderiv_within_zero_of_not_differentiable_within_at this]\n#align fderiv_within_univ fderiv_within_univ\n\n",
 "fderiv_within_sum":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem fderiv_within_sum (hxs : unique_diff_within_at ğ•œ s x) (h : âˆ€ i âˆˆ u, differentiable_within_at ğ•œ (A i) s x) :\n    fderiv_within ğ•œ\n        (fun y =>\n          finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" u (A i y))\n        s x =\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" u\n        (fderiv_within ğ•œ (A i) s x) :=\n  (has_fderiv_within_at.sum fun i hi => (h i hi).has_fderiv_within_at).fderiv_within hxs\n#align fderiv_within_sum fderiv_within_sum\n\n",
 "fderiv_within_subset'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\ntheorem fderiv_within_subset' (st : s âŠ† t) (ht : unique_diff_within_at ğ•œ s x) (hx : s âˆˆ nhds_within t x)\n    (h : differentiable_within_at ğ•œ f s x) : fderiv_within ğ•œ f s x = fderiv_within ğ•œ f t x :=\n  fderiv_within_subset st ht (h.antimono st hx)\n#align fderiv_within_subset' fderiv_within_subset'\n\n",
 "fderiv_within_subset":
 "theorem fderiv_within_subset (st : s âŠ† t) (ht : unique_diff_within_at ğ•œ s x) (h : differentiable_within_at ğ•œ f t x) :\n    fderiv_within ğ•œ f s x = fderiv_within ğ•œ f t x :=\n  ((differentiable_within_at.has_fderiv_within_at h).mono st).fderiv_within ht\n#align fderiv_within_subset fderiv_within_subset\n\n",
 "fderiv_within_sub_const":
 "theorem fderiv_within_sub_const (hxs : unique_diff_within_at ğ•œ s x) (c : F) :\n    fderiv_within ğ•œ (fun y => f y - c) s x = fderiv_within ğ•œ f s x := by\n  simp only [sub_eq_add_neg, fderiv_within_add_const hxs]\n#align fderiv_within_sub_const fderiv_within_sub_const\n\n",
 "fderiv_within_sub":
 "theorem fderiv_within_sub (hxs : unique_diff_within_at ğ•œ s x) (hf : differentiable_within_at ğ•œ f s x)\n    (hg : differentiable_within_at ğ•œ g s x) :\n    fderiv_within ğ•œ (fun y => f y - g y) s x = fderiv_within ğ•œ f s x - fderiv_within ğ•œ g s x :=\n  (hf.has_fderiv_within_at.sub hg.has_fderiv_within_at).fderiv_within hxs\n#align fderiv_within_sub fderiv_within_sub\n\n",
 "fderiv_within_snd":
 "theorem fderiv_within_snd {s : Set (E Ã— F)} (hs : unique_diff_within_at ğ•œ s p) :\n    fderiv_within ğ•œ Prod.snd s p = snd ğ•œ E F :=\n  has_fderiv_within_at_snd.fderiv_within hs\n#align fderiv_within_snd fderiv_within_snd\n\n",
 "fderiv_within_smul_const":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\ntheorem fderiv_within_smul_const (hxs : unique_diff_within_at ğ•œ s x) (hc : differentiable_within_at ğ•œ c s x) (f : F) :\n    fderiv_within ğ•œ (fun y => Â«expr â€¢ Â» (c y) f) s x = (fderiv_within ğ•œ c s x).smul_right f :=\n  (hc.has_fderiv_within_at.smul_const f).fderiv_within hxs\n#align fderiv_within_smul_const fderiv_within_smul_const\n\n",
 "fderiv_within_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\ntheorem fderiv_within_smul (hxs : unique_diff_within_at ğ•œ s x) (hc : differentiable_within_at ğ•œ c s x)\n    (hf : differentiable_within_at ğ•œ f s x) :\n    fderiv_within ğ•œ (fun y => Â«expr â€¢ Â» (c y) (f y)) s x =\n      Â«expr â€¢ Â» (c x) (fderiv_within ğ•œ f s x) + (fderiv_within ğ•œ c s x).smul_right (f x) :=\n  (hc.has_fderiv_within_at.smul hf.has_fderiv_within_at).fderiv_within hxs\n#align fderiv_within_smul fderiv_within_smul\n\n",
 "fderiv_within_prod":
 "theorem differentiable_at.fderiv_within_prod (hfâ‚ : differentiable_within_at ğ•œ fâ‚ s x)\n    (hfâ‚‚ : differentiable_within_at ğ•œ fâ‚‚ s x) (hxs : unique_diff_within_at ğ•œ s x) :\n    fderiv_within ğ•œ (fun x : E => (fâ‚ x, fâ‚‚ x)) s x = (fderiv_within ğ•œ fâ‚ s x).prod (fderiv_within ğ•œ fâ‚‚ s x) :=\n  (hfâ‚.has_fderiv_within_at.prod hfâ‚‚.has_fderiv_within_at).fderiv_within hxs\n#align differentiable_at.fderiv_within_prod differentiable_at.fderiv_within_prod\n\n",
 "fderiv_within_pi":
 "-- TODO: find out which version (`Ï†` or `Î¦`) works better with `rw`/`simp`\ntheorem fderiv_within_pi (h : âˆ€ i, differentiable_within_at ğ•œ (Ï† i) s x) (hs : unique_diff_within_at ğ•œ s x) :\n    fderiv_within ğ•œ (fun x i => Ï† i x) s x = pi fun i => fderiv_within ğ•œ (Ï† i) s x :=\n  (has_fderiv_within_at_pi.2 fun i => (h i).has_fderiv_within_at).fderiv_within hs\n#align fderiv_within_pi fderiv_within_pi\n\n",
 "fderiv_within_of_open":
 "theorem fderiv_within_of_open (hs : IsOpen s) (hx : x âˆˆ s) : fderiv_within ğ•œ f s x = fderiv ğ•œ f x :=\n  fderiv_within_of_mem_nhds (IsOpen.mem_nhds hs hx)\n#align fderiv_within_of_open fderiv_within_of_open\n\n",
 "fderiv_within_of_mem_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem fderiv_within_of_mem_nhds (h : s âˆˆ (nhds) x) : fderiv_within ğ•œ f s x = fderiv ğ•œ f x :=\n  by\n  have : s = univ âˆ© s := by simp only [univ_inter]\n  rw [this, â† fderiv_within_univ]\n  exact fderiv_within_inter h (unique_diff_on_univ _ (mem_univ _))\n#align fderiv_within_of_mem_nhds fderiv_within_of_mem_nhds\n\n",
 "fderiv_within_of_bilinear":
 "theorem continuous_linear_map.fderiv_within_of_bilinear {f : G' â†’ E} {g : G' â†’ F} {x : G'} {s : Set G'}\n    (hf : differentiable_within_at ğ•œ f s x) (hg : differentiable_within_at ğ•œ g s x) (hs : unique_diff_within_at ğ•œ s x) :\n    fderiv_within ğ•œ (fun y => B (f y) (g y)) s x =\n      B.precompR G' (f x) (fderiv_within ğ•œ g s x) + B.precompL G' (fderiv_within ğ•œ f s x) (g x) :=\n  (B.has_fderiv_within_at_of_bilinear hf.has_fderiv_within_at hg.has_fderiv_within_at).fderiv_within hs\n#align continuous_linear_map.fderiv_within_of_bilinear continuous_linear_map.fderiv_within_of_bilinear\n\n",
 "fderiv_within_neg":
 "theorem fderiv_within_neg (hxs : unique_diff_within_at ğ•œ s x) :\n    fderiv_within ğ•œ (fun y => -f y) s x = -fderiv_within ğ•œ f s x :=\n  if h : differentiable_within_at ğ•œ f s x then h.has_fderiv_within_at.neg.fderiv_within hxs\n  else\n    by\n    rw [fderiv_within_zero_of_not_differentiable_within_at h, fderiv_within_zero_of_not_differentiable_within_at,\n      neg_zero]\n    simpa\n#align fderiv_within_neg fderiv_within_neg\n\n",
 "fderiv_within_mul_const'":
 "theorem fderiv_within_mul_const' (hxs : unique_diff_within_at ğ•œ s x) (ha : differentiable_within_at ğ•œ a s x) (b : ğ”¸) :\n    fderiv_within ğ•œ (fun y => a y * b) s x = (fderiv_within ğ•œ a s x).smul_right b :=\n  (ha.has_fderiv_within_at.mul_const' b).fderiv_within hxs\n#align fderiv_within_mul_const' fderiv_within_mul_const'\n\n",
 "fderiv_within_mul_const":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\ntheorem fderiv_within_mul_const (hxs : unique_diff_within_at ğ•œ s x) (hc : differentiable_within_at ğ•œ c s x) (d : ğ”¸') :\n    fderiv_within ğ•œ (fun y => c y * d) s x = Â«expr â€¢ Â» d (fderiv_within ğ•œ c s x) :=\n  (hc.has_fderiv_within_at.mul_const d).fderiv_within hxs\n#align fderiv_within_mul_const fderiv_within_mul_const\n\n",
 "fderiv_within_mul'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\ntheorem fderiv_within_mul' (hxs : unique_diff_within_at ğ•œ s x) (ha : differentiable_within_at ğ•œ a s x)\n    (hb : differentiable_within_at ğ•œ b s x) :\n    fderiv_within ğ•œ (fun y => a y * b y) s x =\n      Â«expr â€¢ Â» (a x) (fderiv_within ğ•œ b s x) + (fderiv_within ğ•œ a s x).smul_right (b x) :=\n  (ha.has_fderiv_within_at.mul' hb.has_fderiv_within_at).fderiv_within hxs\n#align fderiv_within_mul' fderiv_within_mul'\n\n",
 "fderiv_within_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\ntheorem fderiv_within_mul (hxs : unique_diff_within_at ğ•œ s x) (hc : differentiable_within_at ğ•œ c s x)\n    (hd : differentiable_within_at ğ•œ d s x) :\n    fderiv_within ğ•œ (fun y => c y * d y) s x =\n      Â«expr â€¢ Â» (c x) (fderiv_within ğ•œ d s x) + Â«expr â€¢ Â» (d x) (fderiv_within ğ•œ c s x) :=\n  (hc.has_fderiv_within_at.mul hd.has_fderiv_within_at).fderiv_within hxs\n#align fderiv_within_mul fderiv_within_mul\n\n",
 "fderiv_within_mem_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\ntheorem fderiv_within_mem_iff {f : E â†’ F} {t : Set E} {s : Set (Â«expr â†’L[ ] Â» E ğ•œ F)} {x : E} :\n    fderiv_within ğ•œ f t x âˆˆ s â†”\n      differentiable_within_at ğ•œ f t x âˆ§ fderiv_within ğ•œ f t x âˆˆ s âˆ¨\n        Â¬differentiable_within_at ğ•œ f t x âˆ§ (0 : Â«expr â†’L[ ] Â» E ğ•œ F) âˆˆ s :=\n  by by_cases hx : differentiable_within_at ğ•œ f t x <;> simp [fderiv_within_zero_of_not_differentiable_within_at, *]\n#align fderiv_within_mem_iff fderiv_within_mem_iff\n\n",
 "fderiv_within_inter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem fderiv_within_inter (ht : t âˆˆ (nhds) x) (hs : unique_diff_within_at ğ•œ s x) :\n    fderiv_within ğ•œ f (s âˆ© t) x = fderiv_within ğ•œ f s x :=\n  by\n  by_cases h : differentiable_within_at ğ•œ f (s âˆ© t) x\n  Â· apply fderiv_within_subset (inter_subset_left _ _) _ ((differentiable_within_at_inter ht).1 h)\n    apply hs.inter ht\n  Â· have : Â¬differentiable_within_at ğ•œ f s x := by rwa [â† differentiable_within_at_inter ht]\n    rw [fderiv_within_zero_of_not_differentiable_within_at h, fderiv_within_zero_of_not_differentiable_within_at this]\n#align fderiv_within_inter fderiv_within_inter\n\n",
 "fderiv_within_id'":
 "theorem fderiv_within_id' (hxs : unique_diff_within_at ğ•œ s x) :\n    fderiv_within ğ•œ (fun x : E => x) s x = ContinuousLinearMap.id ğ•œ E :=\n  fderiv_within_id hxs\n#align fderiv_within_id' fderiv_within_id'\n\n",
 "fderiv_within_id":
 "theorem fderiv_within_id (hxs : unique_diff_within_at ğ•œ s x) : fderiv_within ğ•œ id s x = id ğ•œ E :=\n  by\n  rw [differentiable_at.fderiv_within differentiable_at_id hxs]\n  exact fderiv_id\n#align fderiv_within_id fderiv_within_id\n\n",
 "fderiv_within_fst":
 "theorem fderiv_within_fst {s : Set (E Ã— F)} (hs : unique_diff_within_at ğ•œ s p) :\n    fderiv_within ğ•œ Prod.fst s p = fst ğ•œ E F :=\n  has_fderiv_within_at_fst.fderiv_within hs\n#align fderiv_within_fst fderiv_within_fst\n\n",
 "fderiv_within_fderiv_within":
 "/-- A version of `fderiv_within.comp` that is useful to rewrite the composition of two derivatives\n  into a single derivative. This version always applies, but creates a new side-goal `f x = y`. -/\ntheorem fderiv_within_fderiv_within {g : F â†’ G} {f : E â†’ F} {x : E} {y : F} {s : Set E} {t : Set F}\n    (hg : differentiable_within_at ğ•œ g t y) (hf : differentiable_within_at ğ•œ f s x) (h : MapsTo f s t)\n    (hxs : unique_diff_within_at ğ•œ s x) (hy : f x = y) (v : E) :\n    fderiv_within ğ•œ g t y (fderiv_within ğ•œ f s x v) = fderiv_within ğ•œ (g âˆ˜ f) s x v :=\n  by\n  subst y\n  rw [fderiv_within.comp x hg hf h hxs]\n  rfl\n#align fderiv_within_fderiv_within fderiv_within_fderiv_within\n\n",
 "fderiv_within_eq_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr =á¶ [ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr =á¶ [ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem filter.eventually_eq.fderiv_within_eq_nhds (hs : unique_diff_within_at ğ•œ s x)\n    (hL : Â«expr =á¶ [ ] Â» fâ‚ ((nhds) x) f) : fderiv_within ğ•œ fâ‚ s x = fderiv_within ğ•œ f s x :=\n  (show Â«expr =á¶ [ ] Â» fâ‚ (nhds_within s x) f from nhdsWithin_le_nhds hL).fderiv_within_eq hs (mem_of_mem_nhds hL : _)\n#align filter.eventually_eq.fderiv_within_eq_nhds filter.eventually_eq.fderiv_within_eq_nhds\n\n",
 "fderiv_within_eq_fderiv":
 "theorem fderiv_within_eq_fderiv (hs : unique_diff_within_at ğ•œ s x) (h : differentiable_at ğ•œ f x) :\n    fderiv_within ğ•œ f s x = fderiv ğ•œ f x := by\n  rw [â† fderiv_within_univ]\n  exact fderiv_within_subset (subset_univ _) hs h.differentiable_within_at\n#align fderiv_within_eq_fderiv fderiv_within_eq_fderiv\n\n",
 "fderiv_within_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr =á¶ [ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\ntheorem filter.eventually_eq.fderiv_within_eq (hs : unique_diff_within_at ğ•œ s x)\n    (hL : Â«expr =á¶ [ ] Â» fâ‚ (nhds_within s x) f) (hx : fâ‚ x = f x) : fderiv_within ğ•œ fâ‚ s x = fderiv_within ğ•œ f s x :=\n  if h : differentiable_within_at ğ•œ f s x then\n    has_fderiv_within_at.fderiv_within (h.has_fderiv_within_at.congr_of_eventually_eq hL hx) hs\n  else\n    by\n    have h' : Â¬differentiable_within_at ğ•œ fâ‚ s x :=\n      mt (fun h => h.congr_of_eventually_eq (hL.mono fun x => Eq.symm) hx.symm) h\n    rw [fderiv_within_zero_of_not_differentiable_within_at h, fderiv_within_zero_of_not_differentiable_within_at h']\n#align filter.eventually_eq.fderiv_within_eq filter.eventually_eq.fderiv_within_eq\n\n",
 "fderiv_within_const_sub":
 "theorem fderiv_within_const_sub (hxs : unique_diff_within_at ğ•œ s x) (c : F) :\n    fderiv_within ğ•œ (fun y => c - f y) s x = -fderiv_within ğ•œ f s x := by\n  simp only [sub_eq_add_neg, fderiv_within_const_add, fderiv_within_neg, hxs]\n#align fderiv_within_const_sub fderiv_within_const_sub\n\n",
 "fderiv_within_const_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\ntheorem fderiv_within_const_smul (hxs : unique_diff_within_at ğ•œ s x) (h : differentiable_within_at ğ•œ f s x) (c : R) :\n    fderiv_within ğ•œ (fun y => Â«expr â€¢ Â» c (f y)) s x = Â«expr â€¢ Â» c (fderiv_within ğ•œ f s x) :=\n  (h.has_fderiv_within_at.const_smul c).fderiv_within hxs\n#align fderiv_within_const_smul fderiv_within_const_smul\n\n",
 "fderiv_within_const_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\ntheorem fderiv_within_const_mul (hxs : unique_diff_within_at ğ•œ s x) (ha : differentiable_within_at ğ•œ a s x) (b : ğ”¸) :\n    fderiv_within ğ•œ (fun y => b * a y) s x = Â«expr â€¢ Â» b (fderiv_within ğ•œ a s x) :=\n  (ha.has_fderiv_within_at.const_mul b).fderiv_within hxs\n#align fderiv_within_const_mul fderiv_within_const_mul\n\n",
 "fderiv_within_const_apply":
 "theorem fderiv_within_const_apply (c : F) (hxs : unique_diff_within_at ğ•œ s x) : fderiv_within ğ•œ (fun y => c) s x = 0 :=\n  by\n  rw [differentiable_at.fderiv_within (differentiable_at_const _) hxs]\n  exact fderiv_const_apply _\n#align fderiv_within_const_apply fderiv_within_const_apply\n\n",
 "fderiv_within_const_add":
 "theorem fderiv_within_const_add (hxs : unique_diff_within_at ğ•œ s x) (c : F) :\n    fderiv_within ğ•œ (fun y => c + f y) s x = fderiv_within ğ•œ f s x := by\n  simpa only [add_comm] using fderiv_within_add_const hxs c\n#align fderiv_within_const_add fderiv_within_const_add\n\n",
 "fderiv_within_congr_mono":
 "theorem differentiable_within_at.fderiv_within_congr_mono (h : differentiable_within_at ğ•œ f s x)\n    (hs : âˆ€ x âˆˆ t, fâ‚ x = f x) (hx : fâ‚ x = f x) (hxt : unique_diff_within_at ğ•œ t x) (hâ‚ : t âŠ† s) :\n    fderiv_within ğ•œ fâ‚ t x = fderiv_within ğ•œ f s x :=\n  (has_fderiv_within_at.congr_mono h.has_fderiv_within_at hs hx hâ‚).fderiv_within hxt\n#align differentiable_within_at.fderiv_within_congr_mono differentiable_within_at.fderiv_within_congr_mono\n\n",
 "fderiv_within_congr'":
 "theorem fderiv_within_congr' (hs : unique_diff_within_at ğ•œ s x) (hL : âˆ€ y âˆˆ s, fâ‚ y = f y) (hx : x âˆˆ s) :\n    fderiv_within ğ•œ fâ‚ s x = fderiv_within ğ•œ f s x :=\n  fderiv_within_congr hs hL (hL x hx)\n#align fderiv_within_congr' fderiv_within_congr'\n\n",
 "fderiv_within_congr":
 "theorem fderiv_within_congr (hs : unique_diff_within_at ğ•œ s x) (hL : âˆ€ y âˆˆ s, fâ‚ y = f y) (hx : fâ‚ x = f x) :\n    fderiv_within ğ•œ fâ‚ s x = fderiv_within ğ•œ f s x :=\n  by\n  apply filter.eventually_eq.fderiv_within_eq hs _ hx\n  apply mem_of_superset self_mem_nhdsWithin\n  exact hL\n#align fderiv_within_congr fderiv_within_congr\n\n",
 "fderiv_within_clm_comp":
 "theorem fderiv_within_clm_comp (hxs : unique_diff_within_at ğ•œ s x) (hc : differentiable_within_at ğ•œ c s x)\n    (hd : differentiable_within_at ğ•œ d s x) :\n    fderiv_within ğ•œ (fun y => (c y).comp (d y)) s x =\n      (compL ğ•œ F G H (c x)).comp (fderiv_within ğ•œ d s x) + ((compL ğ•œ F G H).flip (d x)).comp (fderiv_within ğ•œ c s x) :=\n  (hc.has_fderiv_within_at.clm_comp hd.has_fderiv_within_at).fderiv_within hxs\n#align fderiv_within_clm_comp fderiv_within_clm_comp\n\n",
 "fderiv_within_clm_apply":
 "theorem fderiv_within_clm_apply (hxs : unique_diff_within_at ğ•œ s x) (hc : differentiable_within_at ğ•œ c s x)\n    (hu : differentiable_within_at ğ•œ u s x) :\n    fderiv_within ğ•œ (fun y => (c y) (u y)) s x =\n      (c x).comp (fderiv_within ğ•œ u s x) + (fderiv_within ğ•œ c s x).flip (u x) :=\n  (hc.has_fderiv_within_at.clm_apply hu.has_fderiv_within_at).fderiv_within hxs\n#align fderiv_within_clm_apply fderiv_within_clm_apply\n\n",
 "fderiv_within_add_const":
 "theorem fderiv_within_add_const (hxs : unique_diff_within_at ğ•œ s x) (c : F) :\n    fderiv_within ğ•œ (fun y => f y + c) s x = fderiv_within ğ•œ f s x :=\n  if hf : differentiable_within_at ğ•œ f s x then (hf.has_fderiv_within_at.add_const c).fderiv_within hxs\n  else\n    by\n    rw [fderiv_within_zero_of_not_differentiable_within_at hf, fderiv_within_zero_of_not_differentiable_within_at]\n    simpa\n#align fderiv_within_add_const fderiv_within_add_const\n\n",
 "fderiv_within_add":
 "theorem fderiv_within_add (hxs : unique_diff_within_at ğ•œ s x) (hf : differentiable_within_at ğ•œ f s x)\n    (hg : differentiable_within_at ğ•œ g s x) :\n    fderiv_within ğ•œ (fun y => f y + g y) s x = fderiv_within ğ•œ f s x + fderiv_within ğ•œ g s x :=\n  (hf.has_fderiv_within_at.add hg.has_fderiv_within_at).fderiv_within hxs\n#align fderiv_within_add fderiv_within_add\n\n",
 "fderiv_within":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰ƒL[ ] Â» -/\nprotected theorem fderiv_within (hxs : unique_diff_within_at ğ•œ s x) : fderiv_within ğ•œ iso s x = iso :=\n  (iso : Â«expr â‰ƒL[ ] Â» E ğ•œ F).fderiv_within hxs\n#align fderiv_within fderiv_within\n\n",
 "fderiv_sum":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem fderiv_sum (h : âˆ€ i âˆˆ u, differentiable_at ğ•œ (A i) x) :\n    fderiv ğ•œ\n        (fun y =>\n          finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" u (A i y))\n        x =\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" u\n        (fderiv ğ•œ (A i) x) :=\n  (has_fderiv_at.sum fun i hi => (h i hi).has_fderiv_at).fderiv\n#align fderiv_sum fderiv_sum\n\n",
 "fderiv_sub_const":
 "theorem fderiv_sub_const (c : F) : fderiv ğ•œ (fun y => f y - c) x = fderiv ğ•œ f x := by\n  simp only [sub_eq_add_neg, fderiv_add_const]\n#align fderiv_sub_const fderiv_sub_const\n\n",
 "fderiv_sub":
 "theorem fderiv_sub (hf : differentiable_at ğ•œ f x) (hg : differentiable_at ğ•œ g x) :\n    fderiv ğ•œ (fun y => f y - g y) x = fderiv ğ•œ f x - fderiv ğ•œ g x :=\n  (hf.has_fderiv_at.sub hg.has_fderiv_at).fderiv\n#align fderiv_sub fderiv_sub\n\n",
 "fderiv_snd":
 "theorem fderiv_snd : fderiv ğ•œ Prod.snd p = snd ğ•œ E F :=\n  has_fderiv_at_snd.fderiv\n#align fderiv_snd fderiv_snd\n\n",
 "fderiv_smul_const":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\ntheorem fderiv_smul_const (hc : differentiable_at ğ•œ c x) (f : F) :\n    fderiv ğ•œ (fun y => Â«expr â€¢ Â» (c y) f) x = (fderiv ğ•œ c x).smul_right f :=\n  (hc.has_fderiv_at.smul_const f).fderiv\n#align fderiv_smul_const fderiv_smul_const\n\n",
 "fderiv_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\ntheorem fderiv_smul (hc : differentiable_at ğ•œ c x) (hf : differentiable_at ğ•œ f x) :\n    fderiv ğ•œ (fun y => Â«expr â€¢ Â» (c y) (f y)) x = Â«expr â€¢ Â» (c x) (fderiv ğ•œ f x) + (fderiv ğ•œ c x).smul_right (f x) :=\n  (hc.has_fderiv_at.smul hf.has_fderiv_at).fderiv\n#align fderiv_smul fderiv_smul\n\n",
 "fderiv_restrict_scalars":
 "theorem differentiable_at.fderiv_restrict_scalars (h : differentiable_at ğ•œ' f x) :\n    fderiv ğ•œ f x = (fderiv ğ•œ' f x).restrict_scalars ğ•œ :=\n  (h.has_fderiv_at.restrict_scalars ğ•œ).fderiv\n#align differentiable_at.fderiv_restrict_scalars differentiable_at.fderiv_restrict_scalars\n\n",
 "fderiv_prod":
 "theorem differentiable_at.fderiv_prod (hfâ‚ : differentiable_at ğ•œ fâ‚ x) (hfâ‚‚ : differentiable_at ğ•œ fâ‚‚ x) :\n    fderiv ğ•œ (fun x : E => (fâ‚ x, fâ‚‚ x)) x = (fderiv ğ•œ fâ‚ x).prod (fderiv ğ•œ fâ‚‚ x) :=\n  (hfâ‚.has_fderiv_at.prod hfâ‚‚.has_fderiv_at).fderiv\n#align differentiable_at.fderiv_prod differentiable_at.fderiv_prod\n\n",
 "fderiv_pi":
 "theorem fderiv_pi (h : âˆ€ i, differentiable_at ğ•œ (Ï† i) x) :\n    fderiv ğ•œ (fun x i => Ï† i x) x = pi fun i => fderiv ğ•œ (Ï† i) x :=\n  (has_fderiv_at_pi.2 fun i => (h i).has_fderiv_at).fderiv\n#align fderiv_pi fderiv_pi\n\n",
 "fderiv_of_bilinear":
 "theorem continuous_linear_map.fderiv_of_bilinear {f : G' â†’ E} {g : G' â†’ F} {x : G'} (hf : differentiable_at ğ•œ f x)\n    (hg : differentiable_at ğ•œ g x) :\n    fderiv ğ•œ (fun y => B (f y) (g y)) x = B.precompR G' (f x) (fderiv ğ•œ g x) + B.precompL G' (fderiv ğ•œ f x) (g x) :=\n  (B.has_fderiv_at_of_bilinear hf.has_fderiv_at hg.has_fderiv_at).fderiv\n#align continuous_linear_map.fderiv_of_bilinear continuous_linear_map.fderiv_of_bilinear\n\n",
 "fderiv_neg":
 "@[simp]\ntheorem fderiv_neg : fderiv ğ•œ (fun y => -f y) x = -fderiv ğ•œ f x := by\n  simp only [â† fderiv_within_univ, fderiv_within_neg unique_diff_within_at_univ]\n#align fderiv_neg fderiv_neg\n\n",
 "fderiv_mul_const'":
 "theorem fderiv_mul_const' (ha : differentiable_at ğ•œ a x) (b : ğ”¸) :\n    fderiv ğ•œ (fun y => a y * b) x = (fderiv ğ•œ a x).smul_right b :=\n  (ha.has_fderiv_at.mul_const' b).fderiv\n#align fderiv_mul_const' fderiv_mul_const'\n\n",
 "fderiv_mul_const":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\ntheorem fderiv_mul_const (hc : differentiable_at ğ•œ c x) (d : ğ”¸') :\n    fderiv ğ•œ (fun y => c y * d) x = Â«expr â€¢ Â» d (fderiv ğ•œ c x) :=\n  (hc.has_fderiv_at.mul_const d).fderiv\n#align fderiv_mul_const fderiv_mul_const\n\n",
 "fderiv_mul'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\ntheorem fderiv_mul' (ha : differentiable_at ğ•œ a x) (hb : differentiable_at ğ•œ b x) :\n    fderiv ğ•œ (fun y => a y * b y) x = Â«expr â€¢ Â» (a x) (fderiv ğ•œ b x) + (fderiv ğ•œ a x).smul_right (b x) :=\n  (ha.has_fderiv_at.mul' hb.has_fderiv_at).fderiv\n#align fderiv_mul' fderiv_mul'\n\n",
 "fderiv_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\ntheorem fderiv_mul (hc : differentiable_at ğ•œ c x) (hd : differentiable_at ğ•œ d x) :\n    fderiv ğ•œ (fun y => c y * d y) x = Â«expr â€¢ Â» (c x) (fderiv ğ•œ d x) + Â«expr â€¢ Â» (d x) (fderiv ğ•œ c x) :=\n  (hc.has_fderiv_at.mul hd.has_fderiv_at).fderiv\n#align fderiv_mul fderiv_mul\n\n",
 "fderiv_mem_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\ntheorem fderiv_mem_iff {f : E â†’ F} {s : Set (Â«expr â†’L[ ] Â» E ğ•œ F)} {x : E} :\n    fderiv ğ•œ f x âˆˆ s â†”\n      differentiable_at ğ•œ f x âˆ§ fderiv ğ•œ f x âˆˆ s âˆ¨ Â¬differentiable_at ğ•œ f x âˆ§ (0 : Â«expr â†’L[ ] Â» E ğ•œ F) âˆˆ s :=\n  by by_cases hx : differentiable_at ğ•œ f x <;> simp [fderiv_zero_of_not_differentiable_at, *]\n#align fderiv_mem_iff fderiv_mem_iff\n\n",
 "fderiv_inverse":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr Ë£Â» -/\ntheorem fderiv_inverse (x : Â«expr Ë£Â» R) : fderiv ğ•œ (@Ring.inverse R _) x = -mul_left_right ğ•œ R â†‘xâ»Â¹ â†‘xâ»Â¹ :=\n  (has_fderiv_at_ring_inverse x).fderiv\n#align fderiv_inverse fderiv_inverse\n\n",
 "fderiv_id'":
 "@[simp]\ntheorem fderiv_id' : fderiv ğ•œ (fun x : E => x) x = ContinuousLinearMap.id ğ•œ E :=\n  fderiv_id\n#align fderiv_id' fderiv_id'\n\n",
 "fderiv_id":
 "theorem fderiv_id : fderiv ğ•œ id x = id ğ•œ E :=\n  has_fderiv_at.fderiv (has_fderiv_at_id x)\n#align fderiv_id fderiv_id\n\n",
 "fderiv_fst":
 "theorem fderiv_fst : fderiv ğ•œ Prod.fst p = fst ğ•œ E F :=\n  has_fderiv_at_fst.fderiv\n#align fderiv_fst fderiv_fst\n\n",
 "fderiv_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr =á¶ [ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem filter.eventually_eq.fderiv_eq (hL : Â«expr =á¶ [ ] Â» fâ‚ ((nhds) x) f) : fderiv ğ•œ fâ‚ x = fderiv ğ•œ f x :=\n  by\n  have A : fâ‚ x = f x := hL.eq_of_nhds\n  rw [â† fderiv_within_univ, â† fderiv_within_univ]\n  rw [â† nhdsWithin_univ] at hL\n  exact hL.fderiv_within_eq unique_diff_within_at_univ A\n#align filter.eventually_eq.fderiv_eq filter.eventually_eq.fderiv_eq\n\n",
 "fderiv_const_sub":
 "theorem fderiv_const_sub (c : F) : fderiv ğ•œ (fun y => c - f y) x = -fderiv ğ•œ f x := by\n  simp only [â† fderiv_within_univ, fderiv_within_const_sub unique_diff_within_at_univ]\n#align fderiv_const_sub fderiv_const_sub\n\n",
 "fderiv_const_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\ntheorem fderiv_const_smul (h : differentiable_at ğ•œ f x) (c : R) :\n    fderiv ğ•œ (fun y => Â«expr â€¢ Â» c (f y)) x = Â«expr â€¢ Â» c (fderiv ğ•œ f x) :=\n  (h.has_fderiv_at.const_smul c).fderiv\n#align fderiv_const_smul fderiv_const_smul\n\n",
 "fderiv_const_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\ntheorem fderiv_const_mul (ha : differentiable_at ğ•œ a x) (b : ğ”¸) :\n    fderiv ğ•œ (fun y => b * a y) x = Â«expr â€¢ Â» b (fderiv ğ•œ a x) :=\n  (ha.has_fderiv_at.const_mul b).fderiv\n#align fderiv_const_mul fderiv_const_mul\n\n",
 "fderiv_const_apply":
 "theorem fderiv_const_apply (c : F) : fderiv ğ•œ (fun y => c) x = 0 :=\n  has_fderiv_at.fderiv (has_fderiv_at_const c x)\n#align fderiv_const_apply fderiv_const_apply\n\n",
 "fderiv_const_add":
 "theorem fderiv_const_add (c : F) : fderiv ğ•œ (fun y => c + f y) x = fderiv ğ•œ f x := by\n  simp only [add_comm c, fderiv_add_const]\n#align fderiv_const_add fderiv_const_add\n\n",
 "fderiv_const":
 "@[simp]\ntheorem fderiv_const (c : F) : (fderiv ğ•œ fun y : E => c) = 0 :=\n  by\n  ext m\n  rw [fderiv_const_apply]\n  rfl\n#align fderiv_const fderiv_const\n\n",
 "fderiv_clm_comp":
 "theorem fderiv_clm_comp (hc : differentiable_at ğ•œ c x) (hd : differentiable_at ğ•œ d x) :\n    fderiv ğ•œ (fun y => (c y).comp (d y)) x =\n      (compL ğ•œ F G H (c x)).comp (fderiv ğ•œ d x) + ((compL ğ•œ F G H).flip (d x)).comp (fderiv ğ•œ c x) :=\n  (hc.has_fderiv_at.clm_comp hd.has_fderiv_at).fderiv\n#align fderiv_clm_comp fderiv_clm_comp\n\n",
 "fderiv_clm_apply":
 "theorem fderiv_clm_apply (hc : differentiable_at ğ•œ c x) (hu : differentiable_at ğ•œ u x) :\n    fderiv ğ•œ (fun y => (c y) (u y)) x = (c x).comp (fderiv ğ•œ u x) + (fderiv ğ•œ c x).flip (u x) :=\n  (hc.has_fderiv_at.clm_apply hu.has_fderiv_at).fderiv\n#align fderiv_clm_apply fderiv_clm_apply\n\n",
 "fderiv_add_const":
 "theorem fderiv_add_const (c : F) : fderiv ğ•œ (fun y => f y + c) x = fderiv ğ•œ f x := by\n  simp only [â† fderiv_within_univ, fderiv_within_add_const unique_diff_within_at_univ]\n#align fderiv_add_const fderiv_add_const\n\n",
 "fderiv_add":
 "theorem fderiv_add (hf : differentiable_at ğ•œ f x) (hg : differentiable_at ğ•œ g x) :\n    fderiv ğ•œ (fun y => f y + g y) x = fderiv ğ•œ f x + fderiv ğ•œ g x :=\n  (hf.has_fderiv_at.add hg.has_fderiv_at).fderiv\n#align fderiv_add fderiv_add\n\n",
 "fderiv":
 "theorem has_compact_support.fderiv (hf : HasCompactSupport f) : HasCompactSupport (fderiv ğ•œ f) :=\n  hf.mono' <| support_fderiv_subset ğ•œ\n#align has_compact_support.fderiv has_compact_support.fderiv\n\n",
 "exists_lipschitz_on_with_of_nnnorm_lt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–â‚ŠÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- If `f` is strictly differentiable at `x` with derivative `f'` and `K > â€–f'â€–â‚Š`, then `f` is\n`K`-Lipschitz in a neighborhood of `x`. -/\ntheorem has_strict_fderiv_at.exists_lipschitz_on_with_of_nnnorm_lt (hf : has_strict_fderiv_at f f' x) (K : nnreal)\n    (hK : Â«exprâ€– â€–â‚ŠÂ» f' < K) : âˆƒ s âˆˆ (nhds) x, LipschitzOnWith K f s :=\n  by\n  have := hf.add_is_O_with (f'.is_O_with_comp _ _) hK\n  simp only [sub_add_cancel, is_O_with] at this\n  rcases exists_nhds_square this with âŸ¨U, Uo, xU, hUâŸ©\n  exact âŸ¨U, Uo.mem_nhds xU, lipschitzOnWith_iff_norm_sub_le.2 fun x hx y hy => hU (mk_mem_prod hx hy)âŸ©\n#align has_strict_fderiv_at.exists_lipschitz_on_with_of_nnnorm_lt has_strict_fderiv_at.exists_lipschitz_on_with_of_nnnorm_lt\n\n",
 "exists_lipschitz_on_with":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- If `f` is strictly differentiable at `x` with derivative `f'`, then `f` is Lipschitz in a\nneighborhood of `x`. See also `has_strict_fderiv_at.exists_lipschitz_on_with_of_nnnorm_lt` for a\nmore precise statement. -/\ntheorem has_strict_fderiv_at.exists_lipschitz_on_with (hf : has_strict_fderiv_at f f' x) :\n    âˆƒ K, âˆƒ s âˆˆ (nhds) x, LipschitzOnWith K f s :=\n  (exists_gt _).imp hf.exists_lipschitz_on_with_of_nnnorm_lt\n#align has_strict_fderiv_at.exists_lipschitz_on_with has_strict_fderiv_at.exists_lipschitz_on_with\n\n",
 "eventually_ne":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.ne -/\ntheorem has_fderiv_at.eventually_ne (h : has_fderiv_at f f' x) (hf' : âˆƒ C, âˆ€ z, Â«exprâ€– â€–Â» z â‰¤ C * Â«exprâ€– â€–Â» (f' z)) :\n    Â«exprâˆ€á¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â»\"\n      (nhds_within.ne x) (f z â‰  f x) :=\n  by simpa only [compl_eq_univ_diff] using (has_fderiv_within_at_univ.2 h).eventually_ne hf'\n#align has_fderiv_at.eventually_ne has_fderiv_at.eventually_ne\n\n",
 "eventually_differentiable_at":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem differentiable_on.eventually_differentiable_at (h : differentiable_on ğ•œ f s) (hs : s âˆˆ (nhds) x) :\n    Â«exprâˆ€á¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â»\" ((nhds) x)\n      (differentiable_at ğ•œ f y) :=\n  (eventually_eventually_nhds.2 hs).mono fun y => h.differentiable_at\n#align differentiable_on.eventually_differentiable_at differentiable_on.eventually_differentiable_at\n\n",
 "eq":
 "theorem unique_diff_on.eq (H : unique_diff_on ğ•œ s) (hx : x âˆˆ s) (h : has_fderiv_within_at f f' s x)\n    (hâ‚ : has_fderiv_within_at f fâ‚' s x) : f' = fâ‚' :=\n  (H x hx).eq h hâ‚\n#align unique_diff_on.eq unique_diff_on.eq\n\n",
 "differentiable_within_at_univ":
 "theorem differentiable_within_at_univ : differentiable_within_at ğ•œ f univ x â†” differentiable_at ğ•œ f x := by\n  simp only [differentiable_within_at, has_fderiv_within_at_univ, differentiable_at]\n#align differentiable_within_at_univ differentiable_within_at_univ\n\n",
 "differentiable_within_at_sub_const_iff":
 "@[simp]\ntheorem differentiable_within_at_sub_const_iff (c : F) :\n    differentiable_within_at ğ•œ (fun y => f y - c) s x â†” differentiable_within_at ğ•œ f s x := by\n  simp only [sub_eq_add_neg, differentiable_within_at_add_const_iff]\n#align differentiable_within_at_sub_const_iff differentiable_within_at_sub_const_iff\n\n",
 "differentiable_within_at_snd":
 "theorem differentiable_within_at_snd {s : Set (E Ã— F)} : differentiable_within_at ğ•œ Prod.snd s p :=\n  differentiable_at_snd.differentiable_within_at\n#align differentiable_within_at_snd differentiable_within_at_snd\n\n",
 "differentiable_within_at_pi":
 "@[simp]\ntheorem differentiable_within_at_pi :\n    differentiable_within_at ğ•œ Î¦ s x â†” âˆ€ i, differentiable_within_at ğ•œ (fun x => Î¦ x i) s x :=\n  âŸ¨fun h i => (has_fderiv_within_at_pi'.1 h.has_fderiv_within_at i).differentiable_within_at, fun h =>\n    (has_fderiv_within_at_pi.2 fun i => (h i).has_fderiv_within_at).differentiable_within_atâŸ©\n#align differentiable_within_at_pi differentiable_within_at_pi\n\n",
 "differentiable_within_at_neg_iff":
 "@[simp]\ntheorem differentiable_within_at_neg_iff :\n    differentiable_within_at ğ•œ (fun y => -f y) s x â†” differentiable_within_at ğ•œ f s x :=\n  âŸ¨fun h => by simpa only [neg_neg] using h.neg, fun h => h.negâŸ©\n#align differentiable_within_at_neg_iff differentiable_within_at_neg_iff\n\n",
 "differentiable_within_at_inter'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\ntheorem differentiable_within_at_inter' (ht : t âˆˆ nhds_within s x) :\n    differentiable_within_at ğ•œ f (s âˆ© t) x â†” differentiable_within_at ğ•œ f s x := by\n  simp only [differentiable_within_at, has_fderiv_within_at, has_fderiv_at_filter, nhdsWithin_restrict'' s ht]\n#align differentiable_within_at_inter' differentiable_within_at_inter'\n\n",
 "differentiable_within_at_inter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem differentiable_within_at_inter (ht : t âˆˆ (nhds) x) :\n    differentiable_within_at ğ•œ f (s âˆ© t) x â†” differentiable_within_at ğ•œ f s x := by\n  simp only [differentiable_within_at, has_fderiv_within_at, has_fderiv_at_filter, nhdsWithin_restrict' s ht]\n#align differentiable_within_at_inter differentiable_within_at_inter\n\n",
 "differentiable_within_at_iff_restrict_scalars":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\ntheorem differentiable_within_at_iff_restrict_scalars (hf : differentiable_within_at ğ•œ f s x)\n    (hs : unique_diff_within_at ğ•œ s x) :\n    differentiable_within_at ğ•œ' f s x â†” âˆƒ g' : Â«expr â†’L[ ] Â» E ğ•œ' F, g'.restrict_scalars ğ•œ = fderiv_within ğ•œ f s x :=\n  by\n  constructor\n  Â· rintro âŸ¨g', hg'âŸ©\n    exact âŸ¨g', hs.eq (hg'.restrict_scalars ğ•œ) hf.has_fderiv_within_atâŸ©\n  Â· rintro âŸ¨f', hf'âŸ©\n    exact âŸ¨f', has_fderiv_within_at_of_restrict_scalars ğ•œ hf.has_fderiv_within_at hf'âŸ©\n#align differentiable_within_at_iff_restrict_scalars differentiable_within_at_iff_restrict_scalars\n\n",
 "differentiable_within_at_iff_of_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr =á¶ [ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\ntheorem filter.eventually_eq.differentiable_within_at_iff_of_mem (h : Â«expr =á¶ [ ] Â» fâ‚€ (nhds_within s x) fâ‚)\n    (hx : x âˆˆ s) : differentiable_within_at ğ•œ fâ‚€ s x â†” differentiable_within_at ğ•œ fâ‚ s x :=\n  h.differentiable_within_at_iff (h.eq_of_nhds_within hx)\n#align filter.eventually_eq.differentiable_within_at_iff_of_mem filter.eventually_eq.differentiable_within_at_iff_of_mem\n\n",
 "differentiable_within_at_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr =á¶ [ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\ntheorem filter.eventually_eq.differentiable_within_at_iff (h : Â«expr =á¶ [ ] Â» fâ‚€ (nhds_within s x) fâ‚)\n    (hx : fâ‚€ x = fâ‚ x) : differentiable_within_at ğ•œ fâ‚€ s x â†” differentiable_within_at ğ•œ fâ‚ s x :=\n  exists_congr fun f' => h.has_fderiv_within_at_iff hx\n#align filter.eventually_eq.differentiable_within_at_iff filter.eventually_eq.differentiable_within_at_iff\n\n",
 "differentiable_within_at_id":
 "theorem differentiable_within_at_id : differentiable_within_at ğ•œ id s x :=\n  differentiable_at_id.differentiable_within_at\n#align differentiable_within_at_id differentiable_within_at_id\n\n",
 "differentiable_within_at_fst":
 "theorem differentiable_within_at_fst {s : Set (E Ã— F)} : differentiable_within_at ğ•œ Prod.fst s p :=\n  differentiable_at_fst.differentiable_within_at\n#align differentiable_within_at_fst differentiable_within_at_fst\n\n",
 "differentiable_within_at_const_sub_iff":
 "@[simp]\ntheorem differentiable_within_at_const_sub_iff (c : F) :\n    differentiable_within_at ğ•œ (fun y => c - f y) s x â†” differentiable_within_at ğ•œ f s x := by simp [sub_eq_add_neg]\n#align differentiable_within_at_const_sub_iff differentiable_within_at_const_sub_iff\n\n",
 "differentiable_within_at_const_add_iff":
 "@[simp]\ntheorem differentiable_within_at_const_add_iff (c : F) :\n    differentiable_within_at ğ•œ (fun y => c + f y) s x â†” differentiable_within_at ğ•œ f s x :=\n  âŸ¨fun h => by simpa using h.const_add (-c), fun h => h.const_add câŸ©\n#align differentiable_within_at_const_add_iff differentiable_within_at_const_add_iff\n\n",
 "differentiable_within_at_const":
 "theorem differentiable_within_at_const (c : F) : differentiable_within_at ğ•œ (fun x => c) s x :=\n  differentiable_at.differentiable_within_at (differentiable_at_const _)\n#align differentiable_within_at_const differentiable_within_at_const\n\n",
 "differentiable_within_at_add_const_iff":
 "@[simp]\ntheorem differentiable_within_at_add_const_iff (c : F) :\n    differentiable_within_at ğ•œ (fun y => f y + c) s x â†” differentiable_within_at ğ•œ f s x :=\n  âŸ¨fun h => by simpa using h.add_const (-c), fun h => h.add_const câŸ©\n#align differentiable_within_at_add_const_iff differentiable_within_at_add_const_iff\n\n",
 "differentiable_within_at":
 "protected theorem differentiable_within_at : differentiable_within_at ğ•œ iso s x :=\n  iso.differentiable_at.differentiable_within_at\n#align differentiable_within_at differentiable_within_at\n\n",
 "differentiable_sub_const_iff":
 "@[simp]\ntheorem differentiable_sub_const_iff (c : F) : (differentiable ğ•œ fun y => f y - c) â†” differentiable ğ•œ f := by\n  simp only [sub_eq_add_neg, differentiable_add_const_iff]\n#align differentiable_sub_const_iff differentiable_sub_const_iff\n\n",
 "differentiable_snd":
 "theorem differentiable_snd : differentiable ğ•œ (Prod.snd : E Ã— F â†’ F) := fun x => differentiable_at_snd\n#align differentiable_snd differentiable_snd\n\n",
 "differentiable_pi":
 "theorem differentiable_pi : differentiable ğ•œ Î¦ â†” âˆ€ i, differentiable ğ•œ fun x => Î¦ x i :=\n  âŸ¨fun h i x => differentiable_at_pi.1 (h x) i, fun h x => differentiable_at_pi.2 fun i => h i xâŸ©\n#align differentiable_pi differentiable_pi\n\n",
 "differentiable_on_univ":
 "theorem differentiable_on_univ : differentiable_on ğ•œ f univ â†” differentiable ğ•œ f := by\n  simp only [differentiable_on, differentiable, differentiable_within_at_univ, mem_univ, forall_true_left]\n#align differentiable_on_univ differentiable_on_univ\n\n",
 "differentiable_on_sub_const_iff":
 "@[simp]\ntheorem differentiable_on_sub_const_iff (c : F) : differentiable_on ğ•œ (fun y => f y - c) s â†” differentiable_on ğ•œ f s :=\n  by simp only [sub_eq_add_neg, differentiable_on_add_const_iff]\n#align differentiable_on_sub_const_iff differentiable_on_sub_const_iff\n\n",
 "differentiable_on_snd":
 "theorem differentiable_on_snd {s : Set (E Ã— F)} : differentiable_on ğ•œ Prod.snd s :=\n  differentiable_snd.differentiable_on\n#align differentiable_on_snd differentiable_on_snd\n\n",
 "differentiable_on_singleton":
 "theorem differentiable_on_singleton : differentiable_on ğ•œ f {x} :=\n  forall_eq.2 (has_fderiv_within_at_singleton f x).differentiable_within_at\n#align differentiable_on_singleton differentiable_on_singleton\n\n",
 "differentiable_on_pi":
 "theorem differentiable_on_pi : differentiable_on ğ•œ Î¦ s â†” âˆ€ i, differentiable_on ğ•œ (fun x => Î¦ x i) s :=\n  âŸ¨fun h i x hx => differentiable_within_at_pi.1 (h x hx) i, fun h x hx =>\n    differentiable_within_at_pi.2 fun i => h i x hxâŸ©\n#align differentiable_on_pi differentiable_on_pi\n\n",
 "differentiable_on_of_locally_differentiable_on":
 "theorem differentiable_on_of_locally_differentiable_on\n    (h : âˆ€ x âˆˆ s, âˆƒ u, IsOpen u âˆ§ x âˆˆ u âˆ§ differentiable_on ğ•œ f (s âˆ© u)) : differentiable_on ğ•œ f s :=\n  by\n  intro x xs\n  rcases h x xs with âŸ¨t, t_open, xt, htâŸ©\n  exact (differentiable_within_at_inter (IsOpen.mem_nhds t_open xt)).1 (ht x âŸ¨xs, xtâŸ©)\n#align differentiable_on_of_locally_differentiable_on differentiable_on_of_locally_differentiable_on\n\n",
 "differentiable_on_neg_iff":
 "@[simp]\ntheorem differentiable_on_neg_iff : differentiable_on ğ•œ (fun y => -f y) s â†” differentiable_on ğ•œ f s :=\n  âŸ¨fun h => by simpa only [neg_neg] using h.neg, fun h => h.negâŸ©\n#align differentiable_on_neg_iff differentiable_on_neg_iff\n\n",
 "differentiable_on_id":
 "theorem differentiable_on_id : differentiable_on ğ•œ id s :=\n  differentiable_id.differentiable_on\n#align differentiable_on_id differentiable_on_id\n\n",
 "differentiable_on_fst":
 "theorem differentiable_on_fst {s : Set (E Ã— F)} : differentiable_on ğ•œ Prod.fst s :=\n  differentiable_fst.differentiable_on\n#align differentiable_on_fst differentiable_on_fst\n\n",
 "differentiable_on_empty":
 "theorem differentiable_on_empty : differentiable_on ğ•œ f âˆ… := fun x => false.elim\n#align differentiable_on_empty differentiable_on_empty\n\n",
 "differentiable_on_const_sub_iff":
 "@[simp]\ntheorem differentiable_on_const_sub_iff (c : F) : differentiable_on ğ•œ (fun y => c - f y) s â†” differentiable_on ğ•œ f s :=\n  by simp [sub_eq_add_neg]\n#align differentiable_on_const_sub_iff differentiable_on_const_sub_iff\n\n",
 "differentiable_on_const_add_iff":
 "@[simp]\ntheorem differentiable_on_const_add_iff (c : F) : differentiable_on ğ•œ (fun y => c + f y) s â†” differentiable_on ğ•œ f s :=\n  âŸ¨fun h => by simpa using h.const_add (-c), fun h => h.const_add câŸ©\n#align differentiable_on_const_add_iff differentiable_on_const_add_iff\n\n",
 "differentiable_on_const":
 "theorem differentiable_on_const (c : F) : differentiable_on ğ•œ (fun x => c) s :=\n  (differentiable_const _).differentiable_on\n#align differentiable_on_const differentiable_on_const\n\n",
 "differentiable_on_congr":
 "theorem differentiable_on_congr (h' : âˆ€ x âˆˆ s, fâ‚ x = f x) : differentiable_on ğ•œ fâ‚ s â†” differentiable_on ğ•œ f s :=\n  âŸ¨fun h => differentiable_on.congr h fun y hy => (h' y hy).symm, fun h => differentiable_on.congr h h'âŸ©\n#align differentiable_on_congr differentiable_on_congr\n\n",
 "differentiable_on_add_const_iff":
 "@[simp]\ntheorem differentiable_on_add_const_iff (c : F) : differentiable_on ğ•œ (fun y => f y + c) s â†” differentiable_on ğ•œ f s :=\n  âŸ¨fun h => by simpa using h.add_const (-c), fun h => h.add_const câŸ©\n#align differentiable_on_add_const_iff differentiable_on_add_const_iff\n\n",
 "differentiable_on":
 "protected theorem differentiable_on : differentiable_on ğ•œ iso s :=\n  iso.differentiable.differentiable_on\n#align differentiable_on differentiable_on\n\n",
 "differentiable_neg_iff":
 "@[simp]\ntheorem differentiable_neg_iff : (differentiable ğ•œ fun y => -f y) â†” differentiable ğ•œ f :=\n  âŸ¨fun h => by simpa only [neg_neg] using h.neg, fun h => h.negâŸ©\n#align differentiable_neg_iff differentiable_neg_iff\n\n",
 "differentiable_id'":
 "@[simp]\ntheorem differentiable_id' : differentiable ğ•œ fun x : E => x := fun x => differentiable_at_id\n#align differentiable_id' differentiable_id'\n\n",
 "differentiable_id":
 "@[simp]\ntheorem differentiable_id : differentiable ğ•œ (id : E â†’ E) := fun x => differentiable_at_id\n#align differentiable_id differentiable_id\n\n",
 "differentiable_fst":
 "theorem differentiable_fst : differentiable ğ•œ (Prod.fst : E Ã— F â†’ E) := fun x => differentiable_at_fst\n#align differentiable_fst differentiable_fst\n\n",
 "differentiable_const_sub_iff":
 "@[simp]\ntheorem differentiable_const_sub_iff (c : F) : (differentiable ğ•œ fun y => c - f y) â†” differentiable ğ•œ f := by\n  simp [sub_eq_add_neg]\n#align differentiable_const_sub_iff differentiable_const_sub_iff\n\n",
 "differentiable_const_add_iff":
 "@[simp]\ntheorem differentiable_const_add_iff (c : F) : (differentiable ğ•œ fun y => c + f y) â†” differentiable ğ•œ f :=\n  âŸ¨fun h => by simpa using h.const_add (-c), fun h => h.const_add câŸ©\n#align differentiable_const_add_iff differentiable_const_add_iff\n\n",
 "differentiable_const":
 "@[simp]\ntheorem differentiable_const (c : F) : differentiable ğ•œ fun x : E => c := fun x => differentiable_at_const _\n#align differentiable_const differentiable_const\n\n",
 "differentiable_at_sub_const_iff":
 "@[simp]\ntheorem differentiable_at_sub_const_iff (c : F) : differentiable_at ğ•œ (fun y => f y - c) x â†” differentiable_at ğ•œ f x :=\n  by simp only [sub_eq_add_neg, differentiable_at_add_const_iff]\n#align differentiable_at_sub_const_iff differentiable_at_sub_const_iff\n\n",
 "differentiable_at_snd":
 "theorem differentiable_at_snd : differentiable_at ğ•œ Prod.snd p :=\n  has_fderiv_at_snd.differentiable_at\n#align differentiable_at_snd differentiable_at_snd\n\n",
 "differentiable_at_pi":
 "@[simp]\ntheorem differentiable_at_pi : differentiable_at ğ•œ Î¦ x â†” âˆ€ i, differentiable_at ğ•œ (fun x => Î¦ x i) x :=\n  âŸ¨fun h i => (has_fderiv_at_pi'.1 h.has_fderiv_at i).differentiable_at, fun h =>\n    (has_fderiv_at_pi.2 fun i => (h i).has_fderiv_at).differentiable_atâŸ©\n#align differentiable_at_pi differentiable_at_pi\n\n",
 "differentiable_at_neg_iff":
 "@[simp]\ntheorem differentiable_at_neg_iff : differentiable_at ğ•œ (fun y => -f y) x â†” differentiable_at ğ•œ f x :=\n  âŸ¨fun h => by simpa only [neg_neg] using h.neg, fun h => h.negâŸ©\n#align differentiable_at_neg_iff differentiable_at_neg_iff\n\n",
 "differentiable_at_inverse":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr Ë£Â» -/\ntheorem differentiable_at_inverse (x : Â«expr Ë£Â» R) : differentiable_at ğ•œ (@Ring.inverse R _) x :=\n  (has_fderiv_at_ring_inverse x).differentiable_at\n#align differentiable_at_inverse differentiable_at_inverse\n\n",
 "differentiable_at_iff_restrict_scalars":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\ntheorem differentiable_at_iff_restrict_scalars (hf : differentiable_at ğ•œ f x) :\n    differentiable_at ğ•œ' f x â†” âˆƒ g' : Â«expr â†’L[ ] Â» E ğ•œ' F, g'.restrict_scalars ğ•œ = fderiv ğ•œ f x :=\n  by\n  rw [â† differentiable_within_at_univ, â† fderiv_within_univ]\n  exact differentiable_within_at_iff_restrict_scalars ğ•œ hf.differentiable_within_at unique_diff_within_at_univ\n#align differentiable_at_iff_restrict_scalars differentiable_at_iff_restrict_scalars\n\n",
 "differentiable_at_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr =á¶ [ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem filter.eventually_eq.differentiable_at_iff (h : Â«expr =á¶ [ ] Â» fâ‚€ ((nhds) x) fâ‚) :\n    differentiable_at ğ•œ fâ‚€ x â†” differentiable_at ğ•œ fâ‚ x :=\n  exists_congr fun f' => h.has_fderiv_at_iff\n#align filter.eventually_eq.differentiable_at_iff filter.eventually_eq.differentiable_at_iff\n\n",
 "differentiable_at_id'":
 "@[simp]\ntheorem differentiable_at_id' : differentiable_at ğ•œ (fun x => x) x :=\n  (has_fderiv_at_id x).differentiable_at\n#align differentiable_at_id' differentiable_at_id'\n\n",
 "differentiable_at_id":
 "@[simp]\ntheorem differentiable_at_id : differentiable_at ğ•œ id x :=\n  (has_fderiv_at_id x).differentiable_at\n#align differentiable_at_id differentiable_at_id\n\n",
 "differentiable_at_fst":
 "theorem differentiable_at_fst : differentiable_at ğ•œ Prod.fst p :=\n  has_fderiv_at_fst.differentiable_at\n#align differentiable_at_fst differentiable_at_fst\n\n",
 "differentiable_at_const_sub_iff":
 "@[simp]\ntheorem differentiable_at_const_sub_iff (c : F) : differentiable_at ğ•œ (fun y => c - f y) x â†” differentiable_at ğ•œ f x :=\n  by simp [sub_eq_add_neg]\n#align differentiable_at_const_sub_iff differentiable_at_const_sub_iff\n\n",
 "differentiable_at_const_add_iff":
 "@[simp]\ntheorem differentiable_at_const_add_iff (c : F) : differentiable_at ğ•œ (fun y => c + f y) x â†” differentiable_at ğ•œ f x :=\n  âŸ¨fun h => by simpa using h.const_add (-c), fun h => h.const_add câŸ©\n#align differentiable_at_const_add_iff differentiable_at_const_add_iff\n\n",
 "differentiable_at_const":
 "@[simp]\ntheorem differentiable_at_const (c : F) : differentiable_at ğ•œ (fun x => c) x :=\n  âŸ¨0, has_fderiv_at_const c xâŸ©\n#align differentiable_at_const differentiable_at_const\n\n",
 "differentiable_at_add_const_iff":
 "@[simp]\ntheorem differentiable_at_add_const_iff (c : F) : differentiable_at ğ•œ (fun y => f y + c) x â†” differentiable_at ğ•œ f x :=\n  âŸ¨fun h => by simpa using h.add_const (-c), fun h => h.add_const câŸ©\n#align differentiable_at_add_const_iff differentiable_at_add_const_iff\n\n",
 "differentiable_at":
 "protected theorem differentiable_at : differentiable_at ğ•œ iso x :=\n  iso.has_fderiv_at.differentiable_at\n#align differentiable_at differentiable_at\n\n",
 "differentiable_add_const_iff":
 "@[simp]\ntheorem differentiable_add_const_iff (c : F) : (differentiable ğ•œ fun y => f y + c) â†” differentiable ğ•œ f :=\n  âŸ¨fun h => by simpa using h.add_const (-c), fun h => h.add_const câŸ©\n#align differentiable_add_const_iff differentiable_add_const_iff\n\n",
 "differentiable":
 "protected theorem differentiable : differentiable ğ•œ iso := fun x => iso.differentiable_at\n#align differentiable differentiable\n\n",
 "continuous_within_at":
 "theorem differentiable_within_at.continuous_within_at (h : differentiable_within_at ğ•œ f s x) :\n    ContinuousWithinAt f s x :=\n  let âŸ¨f', hf'âŸ© := h\n  hf'.continuous_within_at\n#align differentiable_within_at.continuous_within_at differentiable_within_at.continuous_within_at\n\n",
 "continuous_on":
 "theorem differentiable_on.continuous_on (h : differentiable_on ğ•œ f s) : ContinuousOn f s := fun x hx =>\n  (h x hx).continuous_within_at\n#align differentiable_on.continuous_on differentiable_on.continuous_on\n\n",
 "continuous_at":
 "protected theorem has_strict_fderiv_at.continuous_at (hf : has_strict_fderiv_at f f' x) : ContinuousAt f x :=\n  hf.has_fderiv_at.continuous_at\n#align has_strict_fderiv_at.continuous_at has_strict_fderiv_at.continuous_at\n\n",
 "continuous":
 "theorem differentiable.continuous (h : differentiable ğ•œ f) : Continuous f :=\n  continuous_iff_continuousAt.2 fun x => (h x).continuous_at\n#align differentiable.continuous differentiable.continuous\n\n",
 "const_sub":
 "theorem differentiable.const_sub (hf : differentiable ğ•œ f) (c : F) : differentiable ğ•œ fun y => c - f y := fun x =>\n  (hf x).const_sub c\n#align differentiable.const_sub differentiable.const_sub\n\n",
 "const_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\ntheorem differentiable.const_smul (h : differentiable ğ•œ f) (c : R) : differentiable ğ•œ fun y => Â«expr â€¢ Â» c (f y) :=\n  fun x => (h x).const_smul c\n#align differentiable.const_smul differentiable.const_smul\n\n",
 "const_mul":
 "theorem differentiable.const_mul (ha : differentiable ğ•œ a) (b : ğ”¸) : differentiable ğ•œ fun y => b * a y := fun x =>\n  (ha x).const_mul b\n#align differentiable.const_mul differentiable.const_mul\n\n",
 "const_add":
 "theorem differentiable.const_add (hf : differentiable ğ•œ f) (c : F) : differentiable ğ•œ fun y => c + f y := fun x =>\n  (hf x).const_add c\n#align differentiable.const_add differentiable.const_add\n\n",
 "congr_of_eventually_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr =á¶ [ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem differentiable_at.congr_of_eventually_eq (h : differentiable_at ğ•œ f x) (hL : Â«expr =á¶ [ ] Â» fâ‚ ((nhds) x) f) :\n    differentiable_at ğ•œ fâ‚ x :=\n  hL.differentiable_at_iff.2 h\n#align differentiable_at.congr_of_eventually_eq differentiable_at.congr_of_eventually_eq\n\n",
 "congr_mono":
 "theorem differentiable_on.congr_mono (h : differentiable_on ğ•œ f s) (h' : âˆ€ x âˆˆ t, fâ‚ x = f x) (hâ‚ : t âŠ† s) :\n    differentiable_on ğ•œ fâ‚ t := fun x hx => (h x (hâ‚ hx)).congr_mono h' (h' x hx) hâ‚\n#align differentiable_on.congr_mono differentiable_on.congr_mono\n\n",
 "congr'":
 "theorem has_fderiv_within_at.congr' (h : has_fderiv_within_at f f' s x) (hs : âˆ€ x âˆˆ s, fâ‚ x = f x) (hx : x âˆˆ s) :\n    has_fderiv_within_at fâ‚ f' s x :=\n  h.congr hs (hs x hx)\n#align has_fderiv_within_at.congr' has_fderiv_within_at.congr'\n\n",
 "congr":
 "theorem differentiable_on.congr (h : differentiable_on ğ•œ f s) (h' : âˆ€ x âˆˆ s, fâ‚ x = f x) : differentiable_on ğ•œ fâ‚ s :=\n  fun x hx => (h x hx).congr h' (h' x hx)\n#align differentiable_on.congr differentiable_on.congr\n\n",
 "compâ‚ƒ":
 "/-- Ternary version of `fderiv_within.comp`, with equality assumptions of basepoints added, in\n  order to apply more easily as a rewrite from right-to-left. -/\ntheorem fderiv_within.compâ‚ƒ {g' : G â†’ G'} {g : F â†’ G} {t : Set F} {u : Set G} {y : F} {y' : G}\n    (hg' : differentiable_within_at ğ•œ g' u y') (hg : differentiable_within_at ğ•œ g t y)\n    (hf : differentiable_within_at ğ•œ f s x) (h2g : MapsTo g t u) (h2f : MapsTo f s t) (h3g : g y = y') (h3f : f x = y)\n    (hxs : unique_diff_within_at ğ•œ s x) :\n    fderiv_within ğ•œ (g' âˆ˜ g âˆ˜ f) s x =\n      (fderiv_within ğ•œ g' u y').comp ((fderiv_within ğ•œ g t y).comp (fderiv_within ğ•œ f s x)) :=\n  by\n  substs h3g h3f\n  exact\n    (hg'.has_fderiv_within_at.comp x (hg.has_fderiv_within_at.comp x hf.has_fderiv_within_at h2f) <|\n          h2g.comp h2f).fderiv_within\n      hxs\n#align fderiv_within.compâ‚ƒ fderiv_within.compâ‚ƒ\n\n",
 "comp_right_has_fderiv_within_at_iff'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\ntheorem comp_right_has_fderiv_within_at_iff' {f : F â†’ G} {s : Set F} {x : E} {f' : Â«expr â†’L[ ] Â» E ğ•œ G} :\n    has_fderiv_within_at (f âˆ˜ iso) f' (Â«expr â»Â¹' Â» iso s) x â†”\n      has_fderiv_within_at f (f'.comp (iso.symm : Â«expr â†’L[ ] Â» F ğ•œ E)) s (iso x) :=\n  by\n  rw [â† iso.comp_right_has_fderiv_within_at_iff, ContinuousLinearMap.comp_assoc, iso.coe_symm_comp_coe,\n    ContinuousLinearMap.comp_id]\n#align comp_right_has_fderiv_within_at_iff' comp_right_has_fderiv_within_at_iff'\n\n",
 "comp_right_has_fderiv_within_at_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\ntheorem comp_right_has_fderiv_within_at_iff {f : F â†’ G} {s : Set F} {x : E} {f' : Â«expr â†’L[ ] Â» F ğ•œ G} :\n    has_fderiv_within_at (f âˆ˜ iso) (f'.comp (iso : Â«expr â†’L[ ] Â» E ğ•œ F)) (Â«expr â»Â¹' Â» iso s) x â†”\n      has_fderiv_within_at f f' s (iso x) :=\n  by\n  refine' âŸ¨fun H => _, fun H => H.comp x iso.has_fderiv_within_at (maps_to_preimage _ s)âŸ©\n  rw [â† iso.symm_apply_apply x] at H\n  have A : f = (f âˆ˜ iso) âˆ˜ iso.symm :=\n    by\n    rw [function.comp.assoc, iso.self_comp_symm]\n    rfl\n  have B : f' = (f'.comp (iso : Â«expr â†’L[ ] Â» E ğ•œ F)).comp (iso.symm : Â«expr â†’L[ ] Â» F ğ•œ E) := by\n    rw [ContinuousLinearMap.comp_assoc, iso.coe_comp_coe_symm, ContinuousLinearMap.comp_id]\n  rw [A, B]\n  apply H.comp (iso x) iso.symm.has_fderiv_within_at\n  intro y hy\n  simpa only [mem_preimage, apply_symm_apply] using hy\n#align comp_right_has_fderiv_within_at_iff comp_right_has_fderiv_within_at_iff\n\n",
 "comp_right_has_fderiv_at_iff'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\ntheorem comp_right_has_fderiv_at_iff' {f : F â†’ G} {x : E} {f' : Â«expr â†’L[ ] Â» E ğ•œ G} :\n    has_fderiv_at (f âˆ˜ iso) f' x â†” has_fderiv_at f (f'.comp (iso.symm : Â«expr â†’L[ ] Â» F ğ•œ E)) (iso x) := by\n  simp only [â† has_fderiv_within_at_univ, â† iso.comp_right_has_fderiv_within_at_iff', preimage_univ]\n#align comp_right_has_fderiv_at_iff' comp_right_has_fderiv_at_iff'\n\n",
 "comp_right_has_fderiv_at_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\ntheorem comp_right_has_fderiv_at_iff {f : F â†’ G} {x : E} {f' : Â«expr â†’L[ ] Â» F ğ•œ G} :\n    has_fderiv_at (f âˆ˜ iso) (f'.comp (iso : Â«expr â†’L[ ] Â» E ğ•œ F)) x â†” has_fderiv_at f f' (iso x) := by\n  simp only [â† has_fderiv_within_at_univ, â† comp_right_has_fderiv_within_at_iff, preimage_univ]\n#align comp_right_has_fderiv_at_iff comp_right_has_fderiv_at_iff\n\n",
 "comp_right_fderiv_within":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\ntheorem comp_right_fderiv_within {f : F â†’ G} {s : Set F} {x : E} (hxs : unique_diff_within_at ğ•œ (Â«expr â»Â¹' Â» iso s) x) :\n    fderiv_within ğ•œ (f âˆ˜ iso) (Â«expr â»Â¹' Â» iso s) x = (fderiv_within ğ•œ f s (iso x)).comp (iso : Â«expr â†’L[ ] Â» E ğ•œ F) :=\n  by\n  by_cases h : differentiable_within_at ğ•œ f s (iso x)\n  Â· exact (iso.comp_right_has_fderiv_within_at_iff.2 h.has_fderiv_within_at).fderiv_within hxs\n  Â· have : Â¬differentiable_within_at ğ•œ (f âˆ˜ iso) (Â«expr â»Â¹' Â» iso s) x :=\n      by\n      intro h'\n      exact h (iso.comp_right_differentiable_within_at_iff.1 h')\n    rw [fderiv_within_zero_of_not_differentiable_within_at h, fderiv_within_zero_of_not_differentiable_within_at this,\n      ContinuousLinearMap.zero_comp]\n#align comp_right_fderiv_within comp_right_fderiv_within\n\n",
 "comp_right_fderiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\ntheorem comp_right_fderiv {f : F â†’ G} {x : E} :\n    fderiv ğ•œ (f âˆ˜ iso) x = (fderiv ğ•œ f (iso x)).comp (iso : Â«expr â†’L[ ] Â» E ğ•œ F) :=\n  by\n  rw [â† fderiv_within_univ, â† fderiv_within_univ, â† iso.comp_right_fderiv_within, preimage_univ]\n  exact unique_diff_within_at_univ\n#align comp_right_fderiv comp_right_fderiv\n\n",
 "comp_right_differentiable_within_at_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\ntheorem comp_right_differentiable_within_at_iff {f : F â†’ G} {s : Set F} {x : E} :\n    differentiable_within_at ğ•œ (f âˆ˜ iso) (Â«expr â»Â¹' Â» iso s) x â†” differentiable_within_at ğ•œ f s (iso x) :=\n  by\n  refine' âŸ¨fun H => _, fun H => H.comp x iso.differentiable_within_at (maps_to_preimage _ s)âŸ©\n  have : differentiable_within_at ğ•œ ((f âˆ˜ iso) âˆ˜ iso.symm) s (iso x) :=\n    by\n    rw [â† iso.symm_apply_apply x] at H\n    apply H.comp (iso x) iso.symm.differentiable_within_at\n    intro y hy\n    simpa only [mem_preimage, apply_symm_apply] using hy\n  rwa [function.comp.assoc, iso.self_comp_symm] at this\n#align comp_right_differentiable_within_at_iff comp_right_differentiable_within_at_iff\n\n",
 "comp_right_differentiable_on_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\ntheorem comp_right_differentiable_on_iff {f : F â†’ G} {s : Set F} :\n    differentiable_on ğ•œ (f âˆ˜ iso) (Â«expr â»Â¹' Â» iso s) â†” differentiable_on ğ•œ f s :=\n  by\n  refine' âŸ¨fun H y hy => _, fun H y hy => iso.comp_right_differentiable_within_at_iff.2 (H _ hy)âŸ©\n  rw [â† iso.apply_symm_apply y, â† comp_right_differentiable_within_at_iff]\n  apply H\n  simpa only [mem_preimage, apply_symm_apply] using hy\n#align comp_right_differentiable_on_iff comp_right_differentiable_on_iff\n\n",
 "comp_right_differentiable_iff":
 "theorem comp_right_differentiable_iff {f : F â†’ G} : differentiable ğ•œ (f âˆ˜ iso) â†” differentiable ğ•œ f := by\n  simp only [â† differentiable_on_univ, â† iso.comp_right_differentiable_on_iff, preimage_univ]\n#align comp_right_differentiable_iff comp_right_differentiable_iff\n\n",
 "comp_right_differentiable_at_iff":
 "theorem comp_right_differentiable_at_iff {f : F â†’ G} {x : E} :\n    differentiable_at ğ•œ (f âˆ˜ iso) x â†” differentiable_at ğ•œ f (iso x) := by\n  simp only [â† differentiable_within_at_univ, â† iso.comp_right_differentiable_within_at_iff, preimage_univ]\n#align comp_right_differentiable_at_iff comp_right_differentiable_at_iff\n\n",
 "comp_of_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\ntheorem has_fderiv_within_at.comp_of_mem {g : F â†’ G} {g' : Â«expr â†’L[ ] Â» F ğ•œ G} {t : Set F}\n    (hg : has_fderiv_within_at g g' t (f x)) (hf : has_fderiv_within_at f f' s x)\n    (hst : Tendsto f (nhds_within s x) (nhds_within t (f x))) : has_fderiv_within_at (g âˆ˜ f) (g'.comp f') s x :=\n  has_fderiv_at_filter.comp x hg hf hst\n#align has_fderiv_within_at.comp_of_mem has_fderiv_within_at.comp_of_mem\n\n",
 "comp_has_strict_fderiv_at_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰ƒL[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\ntheorem comp_has_strict_fderiv_at_iff {f : G â†’ E} {x : G} {f' : Â«expr â†’L[ ] Â» G ğ•œ E} :\n    has_strict_fderiv_at (iso âˆ˜ f) ((iso : Â«expr â†’L[ ] Â» E ğ•œ F).comp f') x â†” has_strict_fderiv_at f f' x :=\n  (iso : Â«expr â‰ƒL[ ] Â» E ğ•œ F).comp_has_strict_fderiv_at_iff\n#align comp_has_strict_fderiv_at_iff comp_has_strict_fderiv_at_iff\n\n",
 "comp_has_fderiv_within_at_iff'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰ƒL[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\ntheorem comp_has_fderiv_within_at_iff' {f : G â†’ E} {s : Set G} {x : G} {f' : Â«expr â†’L[ ] Â» G ğ•œ F} :\n    has_fderiv_within_at (iso âˆ˜ f) f' s x â†” has_fderiv_within_at f ((iso.symm : Â«expr â†’L[ ] Â» F ğ•œ E).comp f') s x :=\n  (iso : Â«expr â‰ƒL[ ] Â» E ğ•œ F).comp_has_fderiv_within_at_iff'\n#align comp_has_fderiv_within_at_iff' comp_has_fderiv_within_at_iff'\n\n",
 "comp_has_fderiv_within_at_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰ƒL[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\ntheorem comp_has_fderiv_within_at_iff {f : G â†’ E} {s : Set G} {x : G} {f' : Â«expr â†’L[ ] Â» G ğ•œ E} :\n    has_fderiv_within_at (iso âˆ˜ f) ((iso : Â«expr â†’L[ ] Â» E ğ•œ F).comp f') s x â†” has_fderiv_within_at f f' s x :=\n  (iso : Â«expr â‰ƒL[ ] Â» E ğ•œ F).comp_has_fderiv_within_at_iff\n#align comp_has_fderiv_within_at_iff comp_has_fderiv_within_at_iff\n\n",
 "comp_has_fderiv_within_at":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\ntheorem has_fderiv_at.comp_has_fderiv_within_at {g : F â†’ G} {g' : Â«expr â†’L[ ] Â» F ğ•œ G} (hg : has_fderiv_at g g' (f x))\n    (hf : has_fderiv_within_at f f' s x) : has_fderiv_within_at (g âˆ˜ f) (g'.comp f') s x :=\n  hg.comp x hf hf.continuous_within_at\n#align has_fderiv_at.comp_has_fderiv_within_at has_fderiv_at.comp_has_fderiv_within_at\n\n",
 "comp_has_fderiv_at_iff'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰ƒL[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\ntheorem comp_has_fderiv_at_iff' {f : G â†’ E} {x : G} {f' : Â«expr â†’L[ ] Â» G ğ•œ F} :\n    has_fderiv_at (iso âˆ˜ f) f' x â†” has_fderiv_at f ((iso.symm : Â«expr â†’L[ ] Â» F ğ•œ E).comp f') x :=\n  (iso : Â«expr â‰ƒL[ ] Â» E ğ•œ F).comp_has_fderiv_at_iff'\n#align comp_has_fderiv_at_iff' comp_has_fderiv_at_iff'\n\n",
 "comp_has_fderiv_at_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰ƒL[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\ntheorem comp_has_fderiv_at_iff {f : G â†’ E} {x : G} {f' : Â«expr â†’L[ ] Â» G ğ•œ E} :\n    has_fderiv_at (iso âˆ˜ f) ((iso : Â«expr â†’L[ ] Â» E ğ•œ F).comp f') x â†” has_fderiv_at f f' x :=\n  (iso : Â«expr â‰ƒL[ ] Â» E ğ•œ F).comp_has_fderiv_at_iff\n#align comp_has_fderiv_at_iff comp_has_fderiv_at_iff\n\n",
 "comp_fderiv_within":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰ƒL[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\ntheorem comp_fderiv_within {f : G â†’ E} {s : Set G} {x : G} (hxs : unique_diff_within_at ğ•œ s x) :\n    fderiv_within ğ•œ (iso âˆ˜ f) s x = (iso : Â«expr â†’L[ ] Â» E ğ•œ F).comp (fderiv_within ğ•œ f s x) :=\n  (iso : Â«expr â‰ƒL[ ] Â» E ğ•œ F).comp_fderiv_within hxs\n#align comp_fderiv_within comp_fderiv_within\n\n",
 "comp_fderiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰ƒL[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\ntheorem comp_fderiv {f : G â†’ E} {x : G} : fderiv ğ•œ (iso âˆ˜ f) x = (iso : Â«expr â†’L[ ] Â» E ğ•œ F).comp (fderiv ğ•œ f x) :=\n  (iso : Â«expr â‰ƒL[ ] Â» E ğ•œ F).comp_fderiv\n#align comp_fderiv comp_fderiv\n\n",
 "comp_differentiable_within_at_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰ƒL[ ] Â» -/\ntheorem comp_differentiable_within_at_iff {f : G â†’ E} {s : Set G} {x : G} :\n    differentiable_within_at ğ•œ (iso âˆ˜ f) s x â†” differentiable_within_at ğ•œ f s x :=\n  (iso : Â«expr â‰ƒL[ ] Â» E ğ•œ F).comp_differentiable_within_at_iff\n#align comp_differentiable_within_at_iff comp_differentiable_within_at_iff\n\n",
 "comp_differentiable_within_at":
 "theorem differentiable_at.comp_differentiable_within_at {g : F â†’ G} (hg : differentiable_at ğ•œ g (f x))\n    (hf : differentiable_within_at ğ•œ f s x) : differentiable_within_at ğ•œ (g âˆ˜ f) s x :=\n  hg.differentiable_within_at.comp x hf (mapsTo_univ _ _)\n#align differentiable_at.comp_differentiable_within_at differentiable_at.comp_differentiable_within_at\n\n",
 "comp_differentiable_on_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰ƒL[ ] Â» -/\ntheorem comp_differentiable_on_iff {f : G â†’ E} {s : Set G} :\n    differentiable_on ğ•œ (iso âˆ˜ f) s â†” differentiable_on ğ•œ f s :=\n  (iso : Â«expr â‰ƒL[ ] Â» E ğ•œ F).comp_differentiable_on_iff\n#align comp_differentiable_on_iff comp_differentiable_on_iff\n\n",
 "comp_differentiable_on":
 "theorem differentiable.comp_differentiable_on {g : F â†’ G} (hg : differentiable ğ•œ g) (hf : differentiable_on ğ•œ f s) :\n    differentiable_on ğ•œ (g âˆ˜ f) s :=\n  hg.differentiable_on.comp hf (mapsTo_univ _ _)\n#align differentiable.comp_differentiable_on differentiable.comp_differentiable_on\n\n",
 "comp_differentiable_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰ƒL[ ] Â» -/\ntheorem comp_differentiable_iff {f : G â†’ E} : differentiable ğ•œ (iso âˆ˜ f) â†” differentiable ğ•œ f :=\n  (iso : Â«expr â‰ƒL[ ] Â» E ğ•œ F).comp_differentiable_iff\n#align comp_differentiable_iff comp_differentiable_iff\n\n",
 "comp_differentiable_at_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰ƒL[ ] Â» -/\ntheorem comp_differentiable_at_iff {f : G â†’ E} {x : G} : differentiable_at ğ•œ (iso âˆ˜ f) x â†” differentiable_at ğ•œ f x :=\n  (iso : Â«expr â‰ƒL[ ] Â» E ğ•œ F).comp_differentiable_at_iff\n#align comp_differentiable_at_iff comp_differentiable_at_iff\n\n",
 "comp'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\ntheorem differentiable_within_at.comp' {g : F â†’ G} {t : Set F} (hg : differentiable_within_at ğ•œ g t (f x))\n    (hf : differentiable_within_at ğ•œ f s x) : differentiable_within_at ğ•œ (g âˆ˜ f) (s âˆ© Â«expr â»Â¹' Â» f t) x :=\n  hg.comp x (hf.mono (inter_subset_left _ _)) (inter_subset_right _ _)\n#align differentiable_within_at.comp' differentiable_within_at.comp'\n\n",
 "comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/-- The chain rule for derivatives in the sense of strict differentiability. -/\nprotected theorem has_strict_fderiv_at.comp {g : F â†’ G} {g' : Â«expr â†’L[ ] Â» F ğ•œ G}\n    (hg : has_strict_fderiv_at g g' (f x)) (hf : has_strict_fderiv_at f f' x) :\n    has_strict_fderiv_at (fun x => g (f x)) (g'.comp f') x :=\n  ((hg.comp_tendsto (hf.continuous_at.prod_map' hf.continuous_at)).trans_is_O hf.is_O_sub).triangle <| by\n    simpa only [g'.map_sub, f'.coe_comp'] using (g'.is_O_comp _ _).trans_is_o hf\n#align has_strict_fderiv_at.comp has_strict_fderiv_at.comp\n\n",
 "clm_comp":
 "theorem differentiable.clm_comp (hc : differentiable ğ•œ c) (hd : differentiable ğ•œ d) :\n    differentiable ğ•œ fun y => (c y).comp (d y) := fun x => (hc x).clm_comp (hd x)\n#align differentiable.clm_comp differentiable.clm_comp\n\n",
 "clm_apply":
 "theorem differentiable.clm_apply (hc : differentiable ğ•œ c) (hu : differentiable ğ•œ u) :\n    differentiable ğ•œ fun y => (c y) (u y) := fun x => (hc x).clm_apply (hu x)\n#align differentiable.clm_apply differentiable.clm_apply\n\n",
 "antimono":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\ntheorem has_fderiv_within_at.antimono (h : has_fderiv_within_at f f' s x) (hst : s âŠ† t)\n    (hs : unique_diff_within_at ğ•œ s x) (hx : s âˆˆ nhds_within t x) : has_fderiv_within_at f f' t x :=\n  by\n  have h' : has_fderiv_within_at f _ t x := (h.differentiable_within_at.antimono hst hx).has_fderiv_within_at\n  rwa [hs.eq h (h'.mono hst)]\n#align has_fderiv_within_at.antimono has_fderiv_within_at.antimono\n\n",
 "add_const":
 "theorem differentiable.add_const (hf : differentiable ğ•œ f) (c : F) : differentiable ğ•œ fun y => f y + c := fun x =>\n  (hf x).add_const c\n#align differentiable.add_const differentiable.add_const\n\n",
 "add":
 "@[simp]\ntheorem differentiable.add (hf : differentiable ğ•œ f) (hg : differentiable ğ•œ g) : differentiable ğ•œ fun y => f y + g y :=\n  fun x => (hf x).add (hg x)\n#align differentiable.add differentiable.add\n\n"}