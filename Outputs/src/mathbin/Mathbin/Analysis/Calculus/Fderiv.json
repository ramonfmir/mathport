{"unique_on":
 "/-- If `f'` and `f₁'` are two derivatives of `f` within `s` at `x`, then they are equal on the\ntangent cone to `s` at `x` -/\ntheorem has_fderiv_within_at.unique_on (hf : has_fderiv_within_at f f' s x) (hg : has_fderiv_within_at f f₁' s x) :\n    EqOn f' f₁' (tangent_cone_at 𝕜 s x) := fun y ⟨c, d, dtop, clim, cdlim⟩ =>\n  tendsto_nhds_unique (hf.lim atTop dtop clim cdlim) (hg.lim atTop dtop clim cdlim)\n#align has_fderiv_within_at.unique_on has_fderiv_within_at.unique_on\n\n",
 "unique_diff_within_at_of_continuous_linear_equiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem has_fderiv_within_at.unique_diff_within_at_of_continuous_linear_equiv {x : E} (e' : «expr ≃L[ ] » E 𝕜 F)\n    (h : has_fderiv_within_at f (e' : «expr →L[ ] » E 𝕜 F) s x) (hs : unique_diff_within_at 𝕜 s x) :\n    unique_diff_within_at 𝕜 («expr '' » f s) (f x) :=\n  h.unique_diff_within_at hs e'.surjective.dense_range\n#align has_fderiv_within_at.unique_diff_within_at_of_continuous_linear_equiv has_fderiv_within_at.unique_diff_within_at_of_continuous_linear_equiv\n\n",
 "unique_diff_within_at":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/-- If a set has the unique differentiability property at a point x, then the image of this set\nunder a map with onto derivative has also the unique differentiability property at the image point.\n-/\ntheorem has_fderiv_within_at.unique_diff_within_at {x : E} (h : has_fderiv_within_at f f' s x)\n    (hs : unique_diff_within_at 𝕜 s x) (h' : DenseRange f') : unique_diff_within_at 𝕜 («expr '' » f s) (f x) :=\n  by\n  refine' ⟨h'.dense_of_maps_to f'.continuous hs.1 _, h.continuous_within_at.mem_closure_image hs.2⟩\n  show Submodule.span 𝕜 (tangent_cone_at 𝕜 s x) ≤ (Submodule.span 𝕜 (tangent_cone_at 𝕜 («expr '' » f s) (f x))).comap f'\n  rw [Submodule.span_le]\n  exact h.maps_to_tangent_cone.mono (subset.refl _) Submodule.subset_span\n#align has_fderiv_within_at.unique_diff_within_at has_fderiv_within_at.unique_diff_within_at\n\n",
 "unique_diff_on_preimage_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n@[simp]\ntheorem continuous_linear_equiv.unique_diff_on_preimage_iff (e : «expr ≃L[ ] » F 𝕜 E) :\n    unique_diff_on 𝕜 («expr ⁻¹' » e s) ↔ unique_diff_on 𝕜 s := by\n  rw [← e.image_symm_eq_preimage, e.symm.unique_diff_on_image_iff]\n#align continuous_linear_equiv.unique_diff_on_preimage_iff continuous_linear_equiv.unique_diff_on_preimage_iff\n\n",
 "unique_diff_on_image_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n@[simp]\ntheorem continuous_linear_equiv.unique_diff_on_image_iff (e : «expr ≃L[ ] » E 𝕜 F) :\n    unique_diff_on 𝕜 («expr '' » e s) ↔ unique_diff_on 𝕜 s :=\n  ⟨fun h => e.symm_image_image s ▸ e.symm.unique_diff_on_image h, e.unique_diff_on_image⟩\n#align continuous_linear_equiv.unique_diff_on_image_iff continuous_linear_equiv.unique_diff_on_image_iff\n\n",
 "unique_diff_on_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem continuous_linear_equiv.unique_diff_on_image (e : «expr ≃L[ ] » E 𝕜 F) (h : unique_diff_on 𝕜 s) :\n    unique_diff_on 𝕜 («expr '' » e s) :=\n  h.image (fun x _ => e.has_fderiv_within_at) fun x hx => e.surjective.dense_range\n#align continuous_linear_equiv.unique_diff_on_image continuous_linear_equiv.unique_diff_on_image\n\n",
 "unique":
 "theorem has_fderiv_at.unique (h₀ : has_fderiv_at f f₀' x) (h₁ : has_fderiv_at f f₁' x) : f₀' = f₁' :=\n  by\n  rw [← has_fderiv_within_at_univ] at h₀ h₁\n  exact unique_diff_within_at_univ.eq h₀ h₁\n#align has_fderiv_at.unique has_fderiv_at.unique\n\n",
 "union":
 "theorem has_fderiv_within_at.union (hs : has_fderiv_within_at f f' s x) (ht : has_fderiv_within_at f f' t x) :\n    has_fderiv_within_at f f' (s ∪ t) x :=\n  by\n  simp only [has_fderiv_within_at, nhdsWithin_union]\n  exact hs.sup ht\n#align has_fderiv_within_at.union has_fderiv_within_at.union\n\n",
 "tendsto_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem has_fderiv_at_filter.tendsto_nhds (hL : L ≤ (nhds) x) (h : has_fderiv_at_filter f f' x L) :\n    Tendsto f L ((nhds) (f x)) :=\n  by\n  have : tendsto (fun x' => f x' - f x) L ((nhds) 0) :=\n    by\n    refine' h.is_O_sub.trans_tendsto (tendsto.mono_left _ hL)\n    rw [← sub_self x]\n    exact tendsto_id.sub tendsto_const_nhds\n  have := tendsto.add this tendsto_const_nhds\n  rw [zero_add (f x)] at this\n  exact this.congr (by simp only [sub_add_cancel, eq_self_iff_true, forall_const])\n#align has_fderiv_at_filter.tendsto_nhds has_fderiv_at_filter.tendsto_nhds\n\n",
 "support_fderiv_subset":
 "theorem support_fderiv_subset : support (fderiv 𝕜 f) ⊆ tsupport f :=\n  by\n  intro x\n  rw [← not_imp_not]\n  intro h2x\n  rw [not_mem_tsupport_iff_eventuallyEq] at h2x\n  exact nmem_support.mpr (h2x.fderiv_eq.trans <| fderiv_const_apply 0)\n#align support_fderiv_subset support_fderiv_subset\n\n",
 "sum":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n@[simp]\ntheorem differentiable.sum (h : ∀ i ∈ u, differentiable 𝕜 (A i)) :\n    differentiable 𝕜 fun y =>\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" u (A i y) :=\n  fun x => differentiable_at.sum fun i hi => h i hi x\n#align differentiable.sum differentiable.sum\n\n",
 "sub_const":
 "theorem differentiable.sub_const (hf : differentiable 𝕜 f) (c : F) : differentiable 𝕜 fun y => f y - c := fun x =>\n  (hf x).sub_const c\n#align differentiable.sub_const differentiable.sub_const\n\n",
 "sub":
 "@[simp]\ntheorem differentiable.sub (hf : differentiable 𝕜 f) (hg : differentiable 𝕜 g) : differentiable 𝕜 fun y => f y - g y :=\n  fun x => (hf x).sub (hg x)\n#align differentiable.sub differentiable.sub\n\n",
 "snd":
 "theorem fderiv_within.snd (hs : unique_diff_within_at 𝕜 s x) (h : differentiable_within_at 𝕜 f₂ s x) :\n    fderiv_within 𝕜 (fun x => (f₂ x).2) s x = (snd 𝕜 F G).comp (fderiv_within 𝕜 f₂ s x) :=\n  h.has_fderiv_within_at.snd.fderiv_within hs\n#align fderiv_within.snd fderiv_within.snd\n\n",
 "smul_const":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem differentiable.smul_const (hc : differentiable 𝕜 c) (f : F) : differentiable 𝕜 fun y => «expr • » (c y) f :=\n  fun x => (hc x).smul_const f\n#align differentiable.smul_const differentiable.smul_const\n\n",
 "smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem differentiable.smul (hc : differentiable 𝕜 c) (hf : differentiable 𝕜 f) :\n    differentiable 𝕜 fun y => «expr • » (c y) (f y) := fun x => (hc x).smul (hf x)\n#align differentiable.smul differentiable.smul\n\n",
 "restrict_scalars":
 "theorem differentiable.restrict_scalars (h : differentiable 𝕜' f) : differentiable 𝕜 f := fun x =>\n  (h x).restrict_scalars 𝕜\n#align differentiable.restrict_scalars differentiable.restrict_scalars\n\n",
 "prod_map":
 "@[simp]\nprotected theorem differentiable_at.prod_map (hf : differentiable_at 𝕜 f p.1) (hf₂ : differentiable_at 𝕜 f₂ p.2) :\n    differentiable_at 𝕜 (fun p : E × G => (f p.1, f₂ p.2)) p :=\n  (hf.comp p differentiable_at_fst).prod (hf₂.comp p differentiable_at_snd)\n#align differentiable_at.prod_map differentiable_at.prod_map\n\n",
 "prod":
 "@[simp]\ntheorem differentiable.prod (hf₁ : differentiable 𝕜 f₁) (hf₂ : differentiable 𝕜 f₂) :\n    differentiable 𝕜 fun x : E => (f₁ x, f₂ x) := fun x => differentiable_at.prod (hf₁ x) (hf₂ x)\n#align differentiable.prod differentiable.prod\n\n",
 "pow":
 "@[simp]\ntheorem differentiable.pow (ha : differentiable 𝕜 a) (n : ℕ) : differentiable 𝕜 fun x => a x ^ n := fun x =>\n  (ha x).pow n\n#align differentiable.pow differentiable.pow\n\n",
 "of_local_left_inverse":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =O[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/-- If `f (g y) = y` for `y` in some neighborhood of `a`, `g` is continuous at `a`, and `f` has an\ninvertible derivative `f'` at `g a`, then `g` has the derivative `f'⁻¹` at `a`.\n\nThis is one of the easy parts of the inverse function theorem: it assumes that we already have\nan inverse function. -/\ntheorem has_fderiv_at.of_local_left_inverse {f : E → F} {f' : «expr ≃L[ ] » E 𝕜 F} {g : F → E} {a : F}\n    (hg : ContinuousAt g a) (hf : has_fderiv_at f (f' : «expr →L[ ] » E 𝕜 F) (g a))\n    (hfg :\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" ((nhds) a)\n        (f (g y) = y)) :\n    has_fderiv_at g (f'.symm : «expr →L[ ] » F 𝕜 E) a :=\n  by\n  have : «expr =O[ ] » (fun x : F => g x - g a - f'.symm (x - a)) ((nhds) a) fun x : F => f' (g x - g a) - (x - a) :=\n    by\n    refine' ((f'.symm : «expr →L[ ] » F 𝕜 E).is_O_comp _ _).congr (fun x => _) fun _ => rfl\n    simp\n  refine' this.trans_is_o _\n  clear this\n  refine' ((hf.comp_tendsto hg).symm.congr' (hfg.mono _) (eventually_of_forall fun _ => rfl)).trans_is_O _\n  · rintro p hp\n    simp [hp, hfg.self_of_nhds]\n  · refine' ((hf.is_O_sub_rev f'.antilipschitz).comp_tendsto hg).congr' (eventually_of_forall fun _ => rfl) (hfg.mono _)\n    rintro p hp\n    simp only [(· ∘ ·), hp, hfg.self_of_nhds]\n#align has_fderiv_at.of_local_left_inverse has_fderiv_at.of_local_left_inverse\n\n",
 "nhds_within":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\ntheorem has_fderiv_within_at.nhds_within (h : has_fderiv_within_at f f' s x) (ht : s ∈ nhds_within t x) :\n    has_fderiv_within_at f f' t x :=\n  (has_fderiv_within_at_inter' ht).1 (h.mono (inter_subset_right _ _))\n#align has_fderiv_within_at.nhds_within has_fderiv_within_at.nhds_within\n\n",
 "neg":
 "theorem differentiable.neg (h : differentiable 𝕜 f) : differentiable 𝕜 fun y => -f y := fun x => (h x).neg\n#align differentiable.neg differentiable.neg\n\n",
 "mul_const'":
 "theorem has_fderiv_at.mul_const' (ha : has_fderiv_at a a' x) (b : 𝔸) :\n    has_fderiv_at (fun y => a y * b) (a'.smul_right b) x :=\n  ((continuous_linear_map.mul 𝕜 𝔸).flip b).has_fderiv_at.comp x ha\n#align has_fderiv_at.mul_const' has_fderiv_at.mul_const'\n\n",
 "mul_const":
 "theorem differentiable.mul_const (ha : differentiable 𝕜 a) (b : 𝔸) : differentiable 𝕜 fun y => a y * b := fun x =>\n  (ha x).mul_const b\n#align differentiable.mul_const differentiable.mul_const\n\n",
 "mul'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem has_fderiv_at.mul' (ha : has_fderiv_at a a' x) (hb : has_fderiv_at b b' x) :\n    has_fderiv_at (fun y => a y * b y) («expr • » (a x) b' + a'.smul_right (b x)) x :=\n  ((continuous_linear_map.mul 𝕜 𝔸).is_bounded_bilinear_map.has_fderiv_at (a x, b x)).comp x (ha.prod hb)\n#align has_fderiv_at.mul' has_fderiv_at.mul'\n\n",
 "mul":
 "@[simp]\ntheorem differentiable.mul (ha : differentiable 𝕜 a) (hb : differentiable 𝕜 b) : differentiable 𝕜 fun y => a y * b y :=\n  fun x => (ha x).mul (hb x)\n#align differentiable.mul differentiable.mul\n\n",
 "mono_of_mem":
 "theorem differentiable_within_at.mono_of_mem (h : differentiable_within_at 𝕜 f s x) {t : Set E}\n    (hst : s ∈ nhdsWithin x t) : differentiable_within_at 𝕜 f t x :=\n  (h.has_fderiv_within_at.mono_of_mem hst).differentiable_within_at\n#align differentiable_within_at.mono_of_mem differentiable_within_at.mono_of_mem\n\n",
 "mono":
 "theorem differentiable_on.mono (h : differentiable_on 𝕜 f t) (st : s ⊆ t) : differentiable_on 𝕜 f s := fun x hx =>\n  (h x (st hx)).mono st\n#align differentiable_on.mono differentiable_on.mono\n\n",
 "maps_to_tangent_cone":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/-- The image of a tangent cone under the differential of a map is included in the tangent cone to\nthe image. -/\ntheorem has_fderiv_within_at.maps_to_tangent_cone {x : E} (h : has_fderiv_within_at f f' s x) :\n    MapsTo f' (tangent_cone_at 𝕜 s x) (tangent_cone_at 𝕜 («expr '' » f s) (f x)) :=\n  by\n  rintro v ⟨c, d, dtop, clim, cdlim⟩\n  refine' ⟨c, fun n => f (x + d n) - f x, mem_of_superset dtop _, clim, h.lim at_top dtop clim cdlim⟩\n  simp (config := { contextual := true }) [-mem_image, mem_image_of_mem]\n#align has_fderiv_within_at.maps_to_tangent_cone has_fderiv_within_at.maps_to_tangent_cone\n\n",
 "lim_real":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem has_fderiv_at.lim_real (hf : has_fderiv_at f f' x) (v : E) :\n    Tendsto (fun c : exprℝ => «expr • » c (f (x + «expr • » c⁻¹ v) - f x)) atTop ((nhds) (f' v)) :=\n  by\n  apply hf.lim v\n  rw [tendsto_at_top_at_top]\n  exact fun b => ⟨b, fun a ha => le_trans ha (le_abs_self _)⟩\n#align has_fderiv_at.lim_real has_fderiv_at.lim_real\n\n",
 "lim":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- Directional derivative agrees with `has_fderiv`. -/\ntheorem has_fderiv_at.lim (hf : has_fderiv_at f f' x) (v : E) {α : Type _} {c : α → 𝕜} {l : Filter α}\n    (hc : Tendsto (fun n => «expr‖ ‖» (c n)) l atTop) :\n    Tendsto (fun n => «expr • » (c n) (f (x + «expr • » (c n)⁻¹ v) - f x)) l ((nhds) (f' v)) :=\n  by\n  refine' (has_fderiv_within_at_univ.2 hf).lim _ univ_mem hc _\n  intro U hU\n  refine' (eventually_ne_of_tendsto_norm_atTop hc (0 : 𝕜)).mono fun y hy => _\n  convert mem_of_mem_nhds hU\n  dsimp only\n  rw [← mul_smul, mul_inv_cancel hy, one_smul]\n#align has_fderiv_at.lim has_fderiv_at.lim\n\n",
 "le_of_lip'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/-- Converse to the mean value inequality: if `f` is differentiable at `x₀` and `C`-lipschitz\non a neighborhood of `x₀` then it its derivative at `x₀` has norm bounded by `C`. This version\nonly assumes that `‖f x - f x₀‖ ≤ C * ‖x - x₀‖` in a neighborhood of `x`. -/\ntheorem has_fderiv_at.le_of_lip' {f : E → F} {f' : «expr →L[ ] » E 𝕜 F} {x₀ : E} (hf : has_fderiv_at f f' x₀)\n    {C : exprℝ} (hC₀ : 0 ≤ C)\n    (hlip :\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\"\n        ((nhds) x₀) («expr‖ ‖» (f x - f x₀) ≤ C * «expr‖ ‖» (x - x₀))) :\n    «expr‖ ‖» f' ≤ C := by\n  refine' le_of_forall_pos_le_add fun ε ε0 => op_norm_le_of_nhds_zero _ _\n  exact add_nonneg hC₀ ε0.le\n  rw [← map_add_left_nhds_zero x₀, eventually_map] at hlip\n  filter_upwards [is_o_iff.1 (has_fderiv_at_iff_is_o_nhds_zero.1 hf) ε0, hlip]with y hy hyC\n  rw [add_sub_cancel'] at hyC\n  calc\n    «expr‖ ‖» (f' y) ≤ «expr‖ ‖» (f (x₀ + y) - f x₀) + «expr‖ ‖» (f (x₀ + y) - f x₀ - f' y) := norm_le_insert _ _\n    _ ≤ C * «expr‖ ‖» y + ε * «expr‖ ‖» y := (add_le_add hyC hy)\n    _ = (C + ε) * «expr‖ ‖» y := (add_mul _ _ _).symm\n    \n#align has_fderiv_at.le_of_lip' has_fderiv_at.le_of_lip'\n\n",
 "le_of_lip":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/-- Converse to the mean value inequality: if `f` is differentiable at `x₀` and `C`-lipschitz\non a neighborhood of `x₀` then it its derivative at `x₀` has norm bounded by `C`.\nVersion using `fderiv`. -/\ntheorem fderiv_at.le_of_lip {f : E → F} {x₀ : E} (hf : differentiable_at 𝕜 f x₀) {s : Set E} (hs : s ∈ (nhds) x₀)\n    {C : nnreal} (hlip : LipschitzOnWith C f s) : «expr‖ ‖» (fderiv 𝕜 f x₀) ≤ C :=\n  hf.has_fderiv_at.le_of_lip hs hlip\n#align fderiv_at.le_of_lip fderiv_at.le_of_lip\n\n",
 "iterate":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\nprotected theorem differentiable_within_at.iterate {f : E → E} (hf : differentiable_within_at 𝕜 f s x) (hx : f x = x)\n    (hs : MapsTo f s s) (n : ℕ) : differentiable_within_at 𝕜 («expr ^[ ]» f n) s x :=\n  (hf.has_fderiv_within_at.iterate hx hs n).differentiable_within_at\n#align differentiable_within_at.iterate differentiable_within_at.iterate\n\n",
 "is_O_sub_rev":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =O[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =O[ ] » -/\ntheorem has_fderiv_at_filter.is_O_sub_rev (hf : has_fderiv_at_filter f f' x L) {C} (hf' : AntilipschitzWith C f') :\n    «expr =O[ ] » (fun x' => x' - x) L fun x' => f x' - f x :=\n  have : «expr =O[ ] » (fun x' => x' - x) L fun x' => f' (x' - x) :=\n    isBigO_iff.2 ⟨C, eventually_of_forall fun x' => AddMonoidHomClass.bound_of_antilipschitz f' hf' _⟩\n  (this.trans (hf.trans_is_O this).right_is_O_add).congr (fun _ => rfl) fun _ => sub_add_cancel _ _\n#align has_fderiv_at_filter.is_O_sub_rev has_fderiv_at_filter.is_O_sub_rev\n\n",
 "is_O_sub":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =O[ ] » -/\ntheorem has_fderiv_at_filter.is_O_sub (h : has_fderiv_at_filter f f' x L) :\n    «expr =O[ ] » (fun x' => f x' - f x) L fun x' => x' - x :=\n  h.is_O.congr_of_sub.2 (f'.is_O_sub _ _)\n#align has_fderiv_at_filter.is_O_sub has_fderiv_at_filter.is_O_sub\n\n",
 "is_O":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =O[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem has_fderiv_at.is_O {f : E → F} {x₀ : E} {f' : «expr →L[ ] » E 𝕜 F} (h : has_fderiv_at f f' x₀) :\n    «expr =O[ ] » (fun x => f x - f x₀) ((nhds) x₀) fun x => x - x₀ := by\n  simpa only [sub_add_cancel] using h.is_O.add (is_O_sub f' ((nhds) x₀) x₀)\n#align has_fderiv_at.is_O has_fderiv_at.is_O\n\n",
 "insert":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\ntheorem has_fderiv_within_at.insert {g' : «expr →L[ ] » E 𝕜 F} (h : has_fderiv_within_at g g' s x) :\n    has_fderiv_within_at g g' (insert x s) x :=\n  h.insert'\n#align has_fderiv_within_at.insert has_fderiv_within_at.insert\n\n",
 "image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem unique_diff_on.image {f' : E → «expr →L[ ] » E 𝕜 F} (hs : unique_diff_on 𝕜 s)\n    (hf' : ∀ x ∈ s, has_fderiv_within_at f (f' x) s x) (hd : ∀ x ∈ s, DenseRange (f' x)) :\n    unique_diff_on 𝕜 («expr '' » f s) :=\n  ball_image_iff.2 fun x hx => (hf' x hx).unique_diff_within_at (hs x hx) (hd x hx)\n#align unique_diff_on.image unique_diff_on.image\n\n",
 "has_strict_fderiv_at_symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/-- If `f` is a local homeomorphism defined on a neighbourhood of `f.symm a`, and `f` has an\ninvertible derivative `f'` in the sense of strict differentiability at `f.symm a`, then `f.symm` has\nthe derivative `f'⁻¹` at `a`.\n\nThis is one of the easy parts of the inverse function theorem: it assumes that we already have\nan inverse function. -/\ntheorem local_homeomorph.has_strict_fderiv_at_symm (f : LocalHomeomorph E F) {f' : «expr ≃L[ ] » E 𝕜 F} {a : F}\n    (ha : a ∈ f.target) (htff' : has_strict_fderiv_at f (f' : «expr →L[ ] » E 𝕜 F) (f.symm a)) :\n    has_strict_fderiv_at f.symm (f'.symm : «expr →L[ ] » F 𝕜 E) a :=\n  htff'.of_local_left_inverse (f.symm.continuous_at ha) (f.eventually_right_inverse ha)\n#align local_homeomorph.has_strict_fderiv_at_symm local_homeomorph.has_strict_fderiv_at_symm\n\n",
 "has_strict_fderiv_at_snd":
 "theorem has_strict_fderiv_at_snd : has_strict_fderiv_at (@Prod.snd E F) (snd 𝕜 E F) p :=\n  (snd 𝕜 E F).has_strict_fderiv_at\n#align has_strict_fderiv_at_snd has_strict_fderiv_at_snd\n\n",
 "has_strict_fderiv_at_pi'":
 "@[simp]\ntheorem has_strict_fderiv_at_pi' :\n    has_strict_fderiv_at Φ Φ' x ↔ ∀ i, has_strict_fderiv_at (fun x => Φ x i) ((proj i).comp Φ') x :=\n  by\n  simp only [has_strict_fderiv_at, ContinuousLinearMap.coe_pi]\n  exact is_o_pi\n#align has_strict_fderiv_at_pi' has_strict_fderiv_at_pi'\n\n",
 "has_strict_fderiv_at_pi":
 "@[simp]\ntheorem has_strict_fderiv_at_pi :\n    has_strict_fderiv_at (fun x i => φ i x) (ContinuousLinearMap.pi φ') x ↔ ∀ i, has_strict_fderiv_at (φ i) (φ' i) x :=\n  has_strict_fderiv_at_pi'\n#align has_strict_fderiv_at_pi has_strict_fderiv_at_pi\n\n",
 "has_strict_fderiv_at_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem filter.eventually_eq.has_strict_fderiv_at_iff (h : «expr =ᶠ[ ] » f₀ ((nhds) x) f₁) (h' : ∀ y, f₀' y = f₁' y) :\n    has_strict_fderiv_at f₀ f₀' x ↔ has_strict_fderiv_at f₁ f₁' x :=\n  by\n  refine' is_o_congr ((h.prod_mk_nhds h).mono _) (eventually_of_forall fun _ => rfl)\n  rintro p ⟨hp₁, hp₂⟩\n  simp only [*]\n#align filter.eventually_eq.has_strict_fderiv_at_iff filter.eventually_eq.has_strict_fderiv_at_iff\n\n",
 "has_strict_fderiv_at_id":
 "theorem has_strict_fderiv_at_id (x : E) : has_strict_fderiv_at id (id 𝕜 E) x :=\n  (isLittleO_zero _ _).congr_left <| by simp\n#align has_strict_fderiv_at_id has_strict_fderiv_at_id\n\n",
 "has_strict_fderiv_at_fst":
 "theorem has_strict_fderiv_at_fst : has_strict_fderiv_at (@Prod.fst E F) (fst 𝕜 E F) p :=\n  (fst 𝕜 E F).has_strict_fderiv_at\n#align has_strict_fderiv_at_fst has_strict_fderiv_at_fst\n\n",
 "has_strict_fderiv_at_const":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\ntheorem has_strict_fderiv_at_const (c : F) (x : E) : has_strict_fderiv_at (fun _ => c) (0 : «expr →L[ ] » E 𝕜 F) x :=\n  (isLittleO_zero _ _).congr_left fun _ => by simp only [zero_apply, sub_self]\n#align has_strict_fderiv_at_const has_strict_fderiv_at_const\n\n",
 "has_strict_fderiv_at":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\nprotected theorem has_strict_fderiv_at : has_strict_fderiv_at iso (iso : «expr →L[ ] » E 𝕜 F) x :=\n  (iso : «expr ≃L[ ] » E 𝕜 F).has_strict_fderiv_at\n#align has_strict_fderiv_at has_strict_fderiv_at\n\n",
 "has_fderiv_within_at_univ":
 "@[simp]\ntheorem has_fderiv_within_at_univ : has_fderiv_within_at f f' univ x ↔ has_fderiv_at f f' x :=\n  by\n  simp only [has_fderiv_within_at, nhdsWithin_univ]\n  rfl\n#align has_fderiv_within_at_univ has_fderiv_within_at_univ\n\n",
 "has_fderiv_within_at_snd":
 "theorem has_fderiv_within_at_snd {s : Set (E × F)} : has_fderiv_within_at (@Prod.snd E F) (snd 𝕜 E F) s p :=\n  has_fderiv_at_filter_snd\n#align has_fderiv_within_at_snd has_fderiv_within_at_snd\n\n",
 "has_fderiv_within_at_singleton":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\ntheorem has_fderiv_within_at_singleton (f : E → F) (x : E) : has_fderiv_within_at f (0 : «expr →L[ ] » E 𝕜 F) {x} x :=\n  by\n  simp only [has_fderiv_within_at, nhdsWithin_singleton, has_fderiv_at_filter, is_o_pure,\n    ContinuousLinearMap.zero_apply, sub_self]\n#align has_fderiv_within_at_singleton has_fderiv_within_at_singleton\n\n",
 "has_fderiv_within_at_pi'":
 "@[simp]\ntheorem has_fderiv_within_at_pi' :\n    has_fderiv_within_at Φ Φ' s x ↔ ∀ i, has_fderiv_within_at (fun x => Φ x i) ((proj i).comp Φ') s x :=\n  has_fderiv_at_filter_pi'\n#align has_fderiv_within_at_pi' has_fderiv_within_at_pi'\n\n",
 "has_fderiv_within_at_pi":
 "theorem has_fderiv_within_at_pi :\n    has_fderiv_within_at (fun x i => φ i x) (ContinuousLinearMap.pi φ') s x ↔\n      ∀ i, has_fderiv_within_at (φ i) (φ' i) s x :=\n  has_fderiv_at_filter_pi\n#align has_fderiv_within_at_pi has_fderiv_within_at_pi\n\n",
 "has_fderiv_within_at_of_restrict_scalars":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\ntheorem has_fderiv_within_at_of_restrict_scalars {g' : «expr →L[ ] » E 𝕜 F} (h : has_fderiv_within_at f g' s x)\n    (H : f'.restrict_scalars 𝕜 = g') : has_fderiv_within_at f f' s x :=\n  by\n  rw [← H] at h\n  exact h\n#align has_fderiv_within_at_of_restrict_scalars has_fderiv_within_at_of_restrict_scalars\n\n",
 "has_fderiv_within_at_of_not_mem_closure":
 "/-- If `x` is not in the closure of `s`, then `f` has any derivative at `x` within `s`,\nas this statement is empty. -/\ntheorem has_fderiv_within_at_of_not_mem_closure (h : x ∉ closure s) : has_fderiv_within_at f f' s x :=\n  by\n  simp only [mem_closure_iff_nhdsWithin_neBot, ne_bot_iff, ne.def, Classical.not_not] at h\n  simp [has_fderiv_within_at, has_fderiv_at_filter, h, is_o, is_O_with]\n#align has_fderiv_within_at_of_not_mem_closure has_fderiv_within_at_of_not_mem_closure\n\n",
 "has_fderiv_within_at_of_bilinear":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\ntheorem continuous_linear_map.has_fderiv_within_at_of_bilinear {f : G' → E} {g : G' → F} {f' : «expr →L[ ] » G' 𝕜 E}\n    {g' : «expr →L[ ] » G' 𝕜 F} {x : G'} {s : Set G'} (hf : has_fderiv_within_at f f' s x)\n    (hg : has_fderiv_within_at g g' s x) :\n    has_fderiv_within_at (fun y => B (f y) (g y)) (B.precompR G' (f x) g' + B.precompL G' f' (g x)) s x :=\n  (B.is_bounded_bilinear_map.has_fderiv_at (f x, g x)).comp_has_fderiv_within_at x (hf.prod hg)\n#align continuous_linear_map.has_fderiv_within_at_of_bilinear continuous_linear_map.has_fderiv_within_at_of_bilinear\n\n",
 "has_fderiv_within_at_inter'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\ntheorem has_fderiv_within_at_inter' (h : t ∈ nhds_within s x) :\n    has_fderiv_within_at f f' (s ∩ t) x ↔ has_fderiv_within_at f f' s x := by\n  simp [has_fderiv_within_at, nhdsWithin_restrict'' s h]\n#align has_fderiv_within_at_inter' has_fderiv_within_at_inter'\n\n",
 "has_fderiv_within_at_inter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem has_fderiv_within_at_inter (h : t ∈ (nhds) x) :\n    has_fderiv_within_at f f' (s ∩ t) x ↔ has_fderiv_within_at f f' s x := by\n  simp [has_fderiv_within_at, nhdsWithin_restrict' s h]\n#align has_fderiv_within_at_inter has_fderiv_within_at_inter\n\n",
 "has_fderiv_within_at_insert":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\ntheorem has_fderiv_within_at_insert {y : E} {g' : «expr →L[ ] » E 𝕜 F} :\n    has_fderiv_within_at g g' (insert y s) x ↔ has_fderiv_within_at g g' s x :=\n  by\n  rcases eq_or_ne x y with (rfl | h)\n  · simp_rw [has_fderiv_within_at, has_fderiv_at_filter]\n    apply Asymptotics.isLittleO_insert\n    simp only [sub_self, g'.map_zero]\n  refine' ⟨fun h => h.mono <| subset_insert y s, fun hg => hg.mono_of_mem _⟩\n  simp_rw [nhdsWithin_insert_of_ne h, self_mem_nhdsWithin]\n#align has_fderiv_within_at_insert has_fderiv_within_at_insert\n\n",
 "has_fderiv_within_at_iff_tendsto":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem has_fderiv_within_at_iff_tendsto :\n    has_fderiv_within_at f f' s x ↔\n      Tendsto (fun x' => («expr‖ ‖» (x' - x))⁻¹ * «expr‖ ‖» (f x' - f x - f' (x' - x))) (nhds_within s x) ((nhds) 0) :=\n  has_fderiv_at_filter_iff_tendsto\n#align has_fderiv_within_at_iff_tendsto has_fderiv_within_at_iff_tendsto\n\n",
 "has_fderiv_within_at_iff_of_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\ntheorem filter.eventually_eq.has_fderiv_within_at_iff_of_mem (h : «expr =ᶠ[ ] » f₀ (nhds_within s x) f₁) (hx : x ∈ s) :\n    has_fderiv_within_at f₀ f' s x ↔ has_fderiv_within_at f₁ f' s x :=\n  h.has_fderiv_within_at_iff (h.eq_of_nhds_within hx)\n#align filter.eventually_eq.has_fderiv_within_at_iff_of_mem filter.eventually_eq.has_fderiv_within_at_iff_of_mem\n\n",
 "has_fderiv_within_at_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\ntheorem filter.eventually_eq.has_fderiv_within_at_iff (h : «expr =ᶠ[ ] » f₀ (nhds_within s x) f₁) (hx : f₀ x = f₁ x) :\n    has_fderiv_within_at f₀ f' s x ↔ has_fderiv_within_at f₁ f' s x :=\n  h.has_fderiv_at_filter_iff hx fun _ => rfl\n#align filter.eventually_eq.has_fderiv_within_at_iff filter.eventually_eq.has_fderiv_within_at_iff\n\n",
 "has_fderiv_within_at_id":
 "theorem has_fderiv_within_at_id (x : E) (s : Set E) : has_fderiv_within_at id (id 𝕜 E) s x :=\n  has_fderiv_at_filter_id _ _\n#align has_fderiv_within_at_id has_fderiv_within_at_id\n\n",
 "has_fderiv_within_at_fst":
 "theorem has_fderiv_within_at_fst {s : Set (E × F)} : has_fderiv_within_at (@Prod.fst E F) (fst 𝕜 E F) s p :=\n  has_fderiv_at_filter_fst\n#align has_fderiv_within_at_fst has_fderiv_within_at_fst\n\n",
 "has_fderiv_within_at_const":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\ntheorem has_fderiv_within_at_const (c : F) (x : E) (s : Set E) :\n    has_fderiv_within_at (fun x => c) (0 : «expr →L[ ] » E 𝕜 F) s x :=\n  has_fderiv_at_filter_const _ _ _\n#align has_fderiv_within_at_const has_fderiv_within_at_const\n\n",
 "has_fderiv_within_at":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\nprotected theorem has_fderiv_within_at : has_fderiv_within_at iso (iso : «expr →L[ ] » E 𝕜 F) s x :=\n  (iso : «expr ≃L[ ] » E 𝕜 F).has_fderiv_within_at\n#align has_fderiv_within_at has_fderiv_within_at\n\n",
 "has_fderiv_at_zero_of_eventually_const":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\ntheorem has_fderiv_at_zero_of_eventually_const (c : F) (hf : «expr =ᶠ[ ] » f ((nhds) x) fun y => c) :\n    has_fderiv_at f (0 : «expr →L[ ] » E 𝕜 F) x :=\n  (has_fderiv_at_const _ _).congr_of_eventually_eq hf\n#align has_fderiv_at_zero_of_eventually_const has_fderiv_at_zero_of_eventually_const\n\n",
 "has_fderiv_at_symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/-- If `f` is a local homeomorphism defined on a neighbourhood of `f.symm a`, and `f` has an\ninvertible derivative `f'` at `f.symm a`, then `f.symm` has the derivative `f'⁻¹` at `a`.\n\nThis is one of the easy parts of the inverse function theorem: it assumes that we already have\nan inverse function. -/\ntheorem local_homeomorph.has_fderiv_at_symm (f : LocalHomeomorph E F) {f' : «expr ≃L[ ] » E 𝕜 F} {a : F}\n    (ha : a ∈ f.target) (htff' : has_fderiv_at f (f' : «expr →L[ ] » E 𝕜 F) (f.symm a)) :\n    has_fderiv_at f.symm (f'.symm : «expr →L[ ] » F 𝕜 E) a :=\n  htff'.of_local_left_inverse (f.symm.continuous_at ha) (f.eventually_right_inverse ha)\n#align local_homeomorph.has_fderiv_at_symm local_homeomorph.has_fderiv_at_symm\n\n",
 "has_fderiv_at_snd":
 "theorem has_fderiv_at_snd : has_fderiv_at (@Prod.snd E F) (snd 𝕜 E F) p :=\n  has_fderiv_at_filter_snd\n#align has_fderiv_at_snd has_fderiv_at_snd\n\n",
 "has_fderiv_at_ring_inverse":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =o[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/-- At an invertible element `x` of a normed algebra `R`, the Fréchet derivative of the inversion\noperation is the linear map `λ t, - x⁻¹ * t * x⁻¹`. -/\ntheorem has_fderiv_at_ring_inverse (x : «expr ˣ» R) : has_fderiv_at Ring.inverse (-mul_left_right 𝕜 R ↑x⁻¹ ↑x⁻¹) x :=\n  by\n  have h_is_o : «expr =o[ ] » (fun t : R => inverse (↑x + t) - ↑x⁻¹ + ↑x⁻¹ * t * ↑x⁻¹) ((nhds) 0) fun t : R => t :=\n    by\n    refine' (inverse_add_norm_diff_second_order x).trans_is_o (is_o_norm_norm.mp _)\n    simp only [norm_pow, norm_norm]\n    have h12 : 1 < 2 := by norm_num\n    convert(Asymptotics.isLittleO_pow_pow h12).comp_tendsto tendsto_norm_zero\n    ext\n    simp\n  have h_lim : tendsto (fun y : R => y - x) ((nhds) x) ((nhds) 0) :=\n    by\n    refine' tendsto_zero_iff_norm_tendsto_zero.mpr _\n    exact tendsto_iff_norm_tendsto_zero.mp tendsto_id\n  simp only [has_fderiv_at, has_fderiv_at_filter]\n  convert h_is_o.comp_tendsto h_lim\n  ext y\n  simp only [coe_comp', Function.comp_apply, mul_left_right_apply, neg_apply, inverse_unit x, Units.inv_mul,\n    add_sub_cancel'_right, mul_sub, sub_mul, one_mul, sub_neg_eq_add]\n#align has_fderiv_at_ring_inverse has_fderiv_at_ring_inverse\n\n",
 "has_fderiv_at_prod_mk_right":
 "theorem has_fderiv_at_prod_mk_right (e₀ : E) (f₀ : F) : has_fderiv_at (fun f : F => (e₀, f)) (inr 𝕜 E F) f₀ :=\n  (has_fderiv_at_const e₀ f₀).prod (has_fderiv_at_id f₀)\n#align has_fderiv_at_prod_mk_right has_fderiv_at_prod_mk_right\n\n",
 "has_fderiv_at_prod_mk_left":
 "theorem has_fderiv_at_prod_mk_left (e₀ : E) (f₀ : F) : has_fderiv_at (fun e : E => (e, f₀)) (inl 𝕜 E F) e₀ :=\n  (has_fderiv_at_id e₀).prod (has_fderiv_at_const f₀ e₀)\n#align has_fderiv_at_prod_mk_left has_fderiv_at_prod_mk_left\n\n",
 "has_fderiv_at_pi'":
 "@[simp]\ntheorem has_fderiv_at_pi' : has_fderiv_at Φ Φ' x ↔ ∀ i, has_fderiv_at (fun x => Φ x i) ((proj i).comp Φ') x :=\n  has_fderiv_at_filter_pi'\n#align has_fderiv_at_pi' has_fderiv_at_pi'\n\n",
 "has_fderiv_at_pi":
 "theorem has_fderiv_at_pi :\n    has_fderiv_at (fun x i => φ i x) (ContinuousLinearMap.pi φ') x ↔ ∀ i, has_fderiv_at (φ i) (φ' i) x :=\n  has_fderiv_at_filter_pi\n#align has_fderiv_at_pi has_fderiv_at_pi\n\n",
 "has_fderiv_at_of_subsingleton":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\ntheorem has_fderiv_at_of_subsingleton [h : subsingleton E] (f : E → F) (x : E) :\n    has_fderiv_at f (0 : «expr →L[ ] » E 𝕜 F) x :=\n  by\n  rw [← has_fderiv_within_at_univ, subsingleton_univ.eq_singleton_of_mem (mem_univ x)]\n  exact has_fderiv_within_at_singleton f x\n#align has_fderiv_at_of_subsingleton has_fderiv_at_of_subsingleton\n\n",
 "has_fderiv_at_of_restrict_scalars":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\ntheorem has_fderiv_at_of_restrict_scalars {g' : «expr →L[ ] » E 𝕜 F} (h : has_fderiv_at f g' x)\n    (H : f'.restrict_scalars 𝕜 = g') : has_fderiv_at f f' x :=\n  by\n  rw [← H] at h\n  exact h\n#align has_fderiv_at_of_restrict_scalars has_fderiv_at_of_restrict_scalars\n\n",
 "has_fderiv_at_of_bilinear":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\ntheorem continuous_linear_map.has_fderiv_at_of_bilinear {f : G' → E} {g : G' → F} {f' : «expr →L[ ] » G' 𝕜 E}\n    {g' : «expr →L[ ] » G' 𝕜 F} {x : G'} (hf : has_fderiv_at f f' x) (hg : has_fderiv_at g g' x) :\n    has_fderiv_at (fun y => B (f y) (g y)) (B.precompR G' (f x) g' + B.precompL G' f' (g x)) x :=\n  (B.is_bounded_bilinear_map.has_fderiv_at (f x, g x)).comp x (hf.prod hg)\n#align continuous_linear_map.has_fderiv_at_of_bilinear continuous_linear_map.has_fderiv_at_of_bilinear\n\n",
 "has_fderiv_at_iff_tendsto":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem has_fderiv_at_iff_tendsto :\n    has_fderiv_at f f' x ↔\n      Tendsto (fun x' => («expr‖ ‖» (x' - x))⁻¹ * «expr‖ ‖» (f x' - f x - f' (x' - x))) ((nhds) x) ((nhds) 0) :=\n  has_fderiv_at_filter_iff_tendsto\n#align has_fderiv_at_iff_tendsto has_fderiv_at_iff_tendsto\n\n",
 "has_fderiv_at_iff_is_o_nhds_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =o[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem has_fderiv_at_iff_is_o_nhds_zero :\n    has_fderiv_at f f' x ↔ «expr =o[ ] » (fun h : E => f (x + h) - f x - f' h) ((nhds) 0) fun h => h :=\n  by\n  rw [has_fderiv_at, has_fderiv_at_filter, ← map_add_left_nhds_zero x, is_o_map]\n  simp [(· ∘ ·)]\n#align has_fderiv_at_iff_is_o_nhds_zero has_fderiv_at_iff_is_o_nhds_zero\n\n",
 "has_fderiv_at_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem filter.eventually_eq.has_fderiv_at_iff (h : «expr =ᶠ[ ] » f₀ ((nhds) x) f₁) :\n    has_fderiv_at f₀ f' x ↔ has_fderiv_at f₁ f' x :=\n  h.has_fderiv_at_filter_iff h.eq_of_nhds fun _ => rfl\n#align filter.eventually_eq.has_fderiv_at_iff filter.eventually_eq.has_fderiv_at_iff\n\n",
 "has_fderiv_at_id":
 "theorem has_fderiv_at_id (x : E) : has_fderiv_at id (id 𝕜 E) x :=\n  has_fderiv_at_filter_id _ _\n#align has_fderiv_at_id has_fderiv_at_id\n\n",
 "has_fderiv_at_fst":
 "theorem has_fderiv_at_fst : has_fderiv_at (@Prod.fst E F) (fst 𝕜 E F) p :=\n  has_fderiv_at_filter_fst\n#align has_fderiv_at_fst has_fderiv_at_fst\n\n",
 "has_fderiv_at_filter_snd":
 "theorem has_fderiv_at_filter_snd {L : Filter (E × F)} : has_fderiv_at_filter (@Prod.snd E F) (snd 𝕜 E F) p L :=\n  (snd 𝕜 E F).has_fderiv_at_filter\n#align has_fderiv_at_filter_snd has_fderiv_at_filter_snd\n\n",
 "has_fderiv_at_filter_real_equiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-\n  In the special case of a normed space over the reals,\n  we can use  scalar multiplication in the `tendsto` characterization\n  of the Fréchet derivative.\n-/\ntheorem has_fderiv_at_filter_real_equiv {L : Filter E} :\n    Tendsto (fun x' : E => («expr‖ ‖» (x' - x))⁻¹ * «expr‖ ‖» (f x' - f x - f' (x' - x))) L ((nhds) 0) ↔\n      Tendsto (fun x' : E => «expr • » («expr‖ ‖» (x' - x))⁻¹ (f x' - f x - f' (x' - x))) L ((nhds) 0) :=\n  by\n  symm\n  rw [tendsto_iff_norm_tendsto_zero]\n  refine' tendsto_congr fun x' => _\n  have : («expr‖ ‖» (x' - x))⁻¹ ≥ 0 := inv_nonneg.mpr (norm_nonneg _)\n  simp [norm_smul, abs_of_nonneg this]\n#align has_fderiv_at_filter_real_equiv has_fderiv_at_filter_real_equiv\n\n",
 "has_fderiv_at_filter_pi'":
 "@[simp]\ntheorem has_fderiv_at_filter_pi' :\n    has_fderiv_at_filter Φ Φ' x L ↔ ∀ i, has_fderiv_at_filter (fun x => Φ x i) ((proj i).comp Φ') x L :=\n  by\n  simp only [has_fderiv_at_filter, ContinuousLinearMap.coe_pi]\n  exact is_o_pi\n#align has_fderiv_at_filter_pi' has_fderiv_at_filter_pi'\n\n",
 "has_fderiv_at_filter_pi":
 "theorem has_fderiv_at_filter_pi :\n    has_fderiv_at_filter (fun x i => φ i x) (ContinuousLinearMap.pi φ') x L ↔\n      ∀ i, has_fderiv_at_filter (φ i) (φ' i) x L :=\n  has_fderiv_at_filter_pi'\n#align has_fderiv_at_filter_pi has_fderiv_at_filter_pi\n\n",
 "has_fderiv_at_filter_iff_tendsto":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem has_fderiv_at_filter_iff_tendsto :\n    has_fderiv_at_filter f f' x L ↔\n      Tendsto (fun x' => («expr‖ ‖» (x' - x))⁻¹ * «expr‖ ‖» (f x' - f x - f' (x' - x))) L ((nhds) 0) :=\n  by\n  have h : ∀ x', «expr‖ ‖» (x' - x) = 0 → «expr‖ ‖» (f x' - f x - f' (x' - x)) = 0 := fun x' hx' =>\n    by\n    rw [sub_eq_zero.1 (norm_eq_zero.1 hx')]\n    simp\n  unfold has_fderiv_at_filter\n  rw [← is_o_norm_left, ← is_o_norm_right, is_o_iff_tendsto h]\n  exact tendsto_congr fun _ => div_eq_inv_mul _ _\n#align has_fderiv_at_filter_iff_tendsto has_fderiv_at_filter_iff_tendsto\n\n",
 "has_fderiv_at_filter_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\ntheorem filter.eventually_eq.has_fderiv_at_filter_iff (h₀ : «expr =ᶠ[ ] » f₀ L f₁) (hx : f₀ x = f₁ x)\n    (h₁ : ∀ x, f₀' x = f₁' x) : has_fderiv_at_filter f₀ f₀' x L ↔ has_fderiv_at_filter f₁ f₁' x L :=\n  isLittleO_congr (h₀.mono fun y hy => by simp only [hy, h₁, hx]) (eventually_of_forall fun _ => rfl)\n#align filter.eventually_eq.has_fderiv_at_filter_iff filter.eventually_eq.has_fderiv_at_filter_iff\n\n",
 "has_fderiv_at_filter_id":
 "theorem has_fderiv_at_filter_id (x : E) (L : Filter E) : has_fderiv_at_filter id (id 𝕜 E) x L :=\n  (isLittleO_zero _ _).congr_left <| by simp\n#align has_fderiv_at_filter_id has_fderiv_at_filter_id\n\n",
 "has_fderiv_at_filter_fst":
 "theorem has_fderiv_at_filter_fst {L : Filter (E × F)} : has_fderiv_at_filter (@Prod.fst E F) (fst 𝕜 E F) p L :=\n  (fst 𝕜 E F).has_fderiv_at_filter\n#align has_fderiv_at_filter_fst has_fderiv_at_filter_fst\n\n",
 "has_fderiv_at_filter_const":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\ntheorem has_fderiv_at_filter_const (c : F) (x : E) (L : Filter E) :\n    has_fderiv_at_filter (fun x => c) (0 : «expr →L[ ] » E 𝕜 F) x L :=\n  (isLittleO_zero _ _).congr_left fun _ => by simp only [zero_apply, sub_self]\n#align has_fderiv_at_filter_const has_fderiv_at_filter_const\n\n",
 "has_fderiv_at_filter":
 "theorem is_bounded_linear_map.has_fderiv_at_filter (h : is_bounded_linear_map 𝕜 f) :\n    has_fderiv_at_filter f h.to_continuous_linear_map x L :=\n  h.to_continuous_linear_map.has_fderiv_at_filter\n#align is_bounded_linear_map.has_fderiv_at_filter is_bounded_linear_map.has_fderiv_at_filter\n\n",
 "has_fderiv_at_const":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\ntheorem has_fderiv_at_const (c : F) (x : E) : has_fderiv_at (fun x => c) (0 : «expr →L[ ] » E 𝕜 F) x :=\n  has_fderiv_at_filter_const _ _ _\n#align has_fderiv_at_const has_fderiv_at_const\n\n",
 "has_fderiv_at":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\nprotected theorem has_fderiv_at : has_fderiv_at iso (iso : «expr →L[ ] » E 𝕜 F) x :=\n  (iso : «expr ≃L[ ] » E 𝕜 F).has_fderiv_at\n#align has_fderiv_at has_fderiv_at\n\n",
 "fst":
 "theorem fderiv_within.fst (hs : unique_diff_within_at 𝕜 s x) (h : differentiable_within_at 𝕜 f₂ s x) :\n    fderiv_within 𝕜 (fun x => (f₂ x).1) s x = (fst 𝕜 F G).comp (fderiv_within 𝕜 f₂ s x) :=\n  h.has_fderiv_within_at.fst.fderiv_within hs\n#align fderiv_within.fst fderiv_within.fst\n\n",
 "fderiv_zero_of_not_differentiable_at":
 "theorem fderiv_zero_of_not_differentiable_at (h : ¬differentiable_at 𝕜 f x) : fderiv 𝕜 f x = 0 :=\n  by\n  have : ¬∃ f', has_fderiv_at f f' x := h\n  simp [fderiv, this]\n#align fderiv_zero_of_not_differentiable_at fderiv_zero_of_not_differentiable_at\n\n",
 "fderiv_within_zero_of_not_differentiable_within_at":
 "/-\nCopyright (c) 2019 Jeremy Avigad. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Jeremy Avigad, Sébastien Gouëzel, Yury Kudryashov\n-/\ntheorem fderiv_within_zero_of_not_differentiable_within_at (h : ¬differentiable_within_at 𝕜 f s x) :\n    fderiv_within 𝕜 f s x = 0 := by\n  have : ¬∃ f', has_fderiv_within_at f f' s x := h\n  simp [fderiv_within, this]\n#align fderiv_within_zero_of_not_differentiable_within_at fderiv_within_zero_of_not_differentiable_within_at\n\n",
 "fderiv_within_univ":
 "@[simp]\ntheorem fderiv_within_univ : fderiv_within 𝕜 f univ = fderiv 𝕜 f :=\n  by\n  ext x : 1\n  by_cases h : differentiable_at 𝕜 f x\n  · apply has_fderiv_within_at.fderiv_within _ unique_diff_within_at_univ\n    rw [has_fderiv_within_at_univ]\n    apply h.has_fderiv_at\n  · have : ¬differentiable_within_at 𝕜 f univ x := by rwa [differentiable_within_at_univ]\n    rw [fderiv_zero_of_not_differentiable_at h, fderiv_within_zero_of_not_differentiable_within_at this]\n#align fderiv_within_univ fderiv_within_univ\n\n",
 "fderiv_within_sum":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem fderiv_within_sum (hxs : unique_diff_within_at 𝕜 s x) (h : ∀ i ∈ u, differentiable_within_at 𝕜 (A i) s x) :\n    fderiv_within 𝕜\n        (fun y =>\n          finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" u (A i y))\n        s x =\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" u\n        (fderiv_within 𝕜 (A i) s x) :=\n  (has_fderiv_within_at.sum fun i hi => (h i hi).has_fderiv_within_at).fderiv_within hxs\n#align fderiv_within_sum fderiv_within_sum\n\n",
 "fderiv_within_subset'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\ntheorem fderiv_within_subset' (st : s ⊆ t) (ht : unique_diff_within_at 𝕜 s x) (hx : s ∈ nhds_within t x)\n    (h : differentiable_within_at 𝕜 f s x) : fderiv_within 𝕜 f s x = fderiv_within 𝕜 f t x :=\n  fderiv_within_subset st ht (h.antimono st hx)\n#align fderiv_within_subset' fderiv_within_subset'\n\n",
 "fderiv_within_subset":
 "theorem fderiv_within_subset (st : s ⊆ t) (ht : unique_diff_within_at 𝕜 s x) (h : differentiable_within_at 𝕜 f t x) :\n    fderiv_within 𝕜 f s x = fderiv_within 𝕜 f t x :=\n  ((differentiable_within_at.has_fderiv_within_at h).mono st).fderiv_within ht\n#align fderiv_within_subset fderiv_within_subset\n\n",
 "fderiv_within_sub_const":
 "theorem fderiv_within_sub_const (hxs : unique_diff_within_at 𝕜 s x) (c : F) :\n    fderiv_within 𝕜 (fun y => f y - c) s x = fderiv_within 𝕜 f s x := by\n  simp only [sub_eq_add_neg, fderiv_within_add_const hxs]\n#align fderiv_within_sub_const fderiv_within_sub_const\n\n",
 "fderiv_within_sub":
 "theorem fderiv_within_sub (hxs : unique_diff_within_at 𝕜 s x) (hf : differentiable_within_at 𝕜 f s x)\n    (hg : differentiable_within_at 𝕜 g s x) :\n    fderiv_within 𝕜 (fun y => f y - g y) s x = fderiv_within 𝕜 f s x - fderiv_within 𝕜 g s x :=\n  (hf.has_fderiv_within_at.sub hg.has_fderiv_within_at).fderiv_within hxs\n#align fderiv_within_sub fderiv_within_sub\n\n",
 "fderiv_within_snd":
 "theorem fderiv_within_snd {s : Set (E × F)} (hs : unique_diff_within_at 𝕜 s p) :\n    fderiv_within 𝕜 Prod.snd s p = snd 𝕜 E F :=\n  has_fderiv_within_at_snd.fderiv_within hs\n#align fderiv_within_snd fderiv_within_snd\n\n",
 "fderiv_within_smul_const":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem fderiv_within_smul_const (hxs : unique_diff_within_at 𝕜 s x) (hc : differentiable_within_at 𝕜 c s x) (f : F) :\n    fderiv_within 𝕜 (fun y => «expr • » (c y) f) s x = (fderiv_within 𝕜 c s x).smul_right f :=\n  (hc.has_fderiv_within_at.smul_const f).fderiv_within hxs\n#align fderiv_within_smul_const fderiv_within_smul_const\n\n",
 "fderiv_within_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem fderiv_within_smul (hxs : unique_diff_within_at 𝕜 s x) (hc : differentiable_within_at 𝕜 c s x)\n    (hf : differentiable_within_at 𝕜 f s x) :\n    fderiv_within 𝕜 (fun y => «expr • » (c y) (f y)) s x =\n      «expr • » (c x) (fderiv_within 𝕜 f s x) + (fderiv_within 𝕜 c s x).smul_right (f x) :=\n  (hc.has_fderiv_within_at.smul hf.has_fderiv_within_at).fderiv_within hxs\n#align fderiv_within_smul fderiv_within_smul\n\n",
 "fderiv_within_prod":
 "theorem differentiable_at.fderiv_within_prod (hf₁ : differentiable_within_at 𝕜 f₁ s x)\n    (hf₂ : differentiable_within_at 𝕜 f₂ s x) (hxs : unique_diff_within_at 𝕜 s x) :\n    fderiv_within 𝕜 (fun x : E => (f₁ x, f₂ x)) s x = (fderiv_within 𝕜 f₁ s x).prod (fderiv_within 𝕜 f₂ s x) :=\n  (hf₁.has_fderiv_within_at.prod hf₂.has_fderiv_within_at).fderiv_within hxs\n#align differentiable_at.fderiv_within_prod differentiable_at.fderiv_within_prod\n\n",
 "fderiv_within_pi":
 "-- TODO: find out which version (`φ` or `Φ`) works better with `rw`/`simp`\ntheorem fderiv_within_pi (h : ∀ i, differentiable_within_at 𝕜 (φ i) s x) (hs : unique_diff_within_at 𝕜 s x) :\n    fderiv_within 𝕜 (fun x i => φ i x) s x = pi fun i => fderiv_within 𝕜 (φ i) s x :=\n  (has_fderiv_within_at_pi.2 fun i => (h i).has_fderiv_within_at).fderiv_within hs\n#align fderiv_within_pi fderiv_within_pi\n\n",
 "fderiv_within_of_open":
 "theorem fderiv_within_of_open (hs : IsOpen s) (hx : x ∈ s) : fderiv_within 𝕜 f s x = fderiv 𝕜 f x :=\n  fderiv_within_of_mem_nhds (IsOpen.mem_nhds hs hx)\n#align fderiv_within_of_open fderiv_within_of_open\n\n",
 "fderiv_within_of_mem_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem fderiv_within_of_mem_nhds (h : s ∈ (nhds) x) : fderiv_within 𝕜 f s x = fderiv 𝕜 f x :=\n  by\n  have : s = univ ∩ s := by simp only [univ_inter]\n  rw [this, ← fderiv_within_univ]\n  exact fderiv_within_inter h (unique_diff_on_univ _ (mem_univ _))\n#align fderiv_within_of_mem_nhds fderiv_within_of_mem_nhds\n\n",
 "fderiv_within_of_bilinear":
 "theorem continuous_linear_map.fderiv_within_of_bilinear {f : G' → E} {g : G' → F} {x : G'} {s : Set G'}\n    (hf : differentiable_within_at 𝕜 f s x) (hg : differentiable_within_at 𝕜 g s x) (hs : unique_diff_within_at 𝕜 s x) :\n    fderiv_within 𝕜 (fun y => B (f y) (g y)) s x =\n      B.precompR G' (f x) (fderiv_within 𝕜 g s x) + B.precompL G' (fderiv_within 𝕜 f s x) (g x) :=\n  (B.has_fderiv_within_at_of_bilinear hf.has_fderiv_within_at hg.has_fderiv_within_at).fderiv_within hs\n#align continuous_linear_map.fderiv_within_of_bilinear continuous_linear_map.fderiv_within_of_bilinear\n\n",
 "fderiv_within_neg":
 "theorem fderiv_within_neg (hxs : unique_diff_within_at 𝕜 s x) :\n    fderiv_within 𝕜 (fun y => -f y) s x = -fderiv_within 𝕜 f s x :=\n  if h : differentiable_within_at 𝕜 f s x then h.has_fderiv_within_at.neg.fderiv_within hxs\n  else\n    by\n    rw [fderiv_within_zero_of_not_differentiable_within_at h, fderiv_within_zero_of_not_differentiable_within_at,\n      neg_zero]\n    simpa\n#align fderiv_within_neg fderiv_within_neg\n\n",
 "fderiv_within_mul_const'":
 "theorem fderiv_within_mul_const' (hxs : unique_diff_within_at 𝕜 s x) (ha : differentiable_within_at 𝕜 a s x) (b : 𝔸) :\n    fderiv_within 𝕜 (fun y => a y * b) s x = (fderiv_within 𝕜 a s x).smul_right b :=\n  (ha.has_fderiv_within_at.mul_const' b).fderiv_within hxs\n#align fderiv_within_mul_const' fderiv_within_mul_const'\n\n",
 "fderiv_within_mul_const":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem fderiv_within_mul_const (hxs : unique_diff_within_at 𝕜 s x) (hc : differentiable_within_at 𝕜 c s x) (d : 𝔸') :\n    fderiv_within 𝕜 (fun y => c y * d) s x = «expr • » d (fderiv_within 𝕜 c s x) :=\n  (hc.has_fderiv_within_at.mul_const d).fderiv_within hxs\n#align fderiv_within_mul_const fderiv_within_mul_const\n\n",
 "fderiv_within_mul'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem fderiv_within_mul' (hxs : unique_diff_within_at 𝕜 s x) (ha : differentiable_within_at 𝕜 a s x)\n    (hb : differentiable_within_at 𝕜 b s x) :\n    fderiv_within 𝕜 (fun y => a y * b y) s x =\n      «expr • » (a x) (fderiv_within 𝕜 b s x) + (fderiv_within 𝕜 a s x).smul_right (b x) :=\n  (ha.has_fderiv_within_at.mul' hb.has_fderiv_within_at).fderiv_within hxs\n#align fderiv_within_mul' fderiv_within_mul'\n\n",
 "fderiv_within_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem fderiv_within_mul (hxs : unique_diff_within_at 𝕜 s x) (hc : differentiable_within_at 𝕜 c s x)\n    (hd : differentiable_within_at 𝕜 d s x) :\n    fderiv_within 𝕜 (fun y => c y * d y) s x =\n      «expr • » (c x) (fderiv_within 𝕜 d s x) + «expr • » (d x) (fderiv_within 𝕜 c s x) :=\n  (hc.has_fderiv_within_at.mul hd.has_fderiv_within_at).fderiv_within hxs\n#align fderiv_within_mul fderiv_within_mul\n\n",
 "fderiv_within_mem_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\ntheorem fderiv_within_mem_iff {f : E → F} {t : Set E} {s : Set («expr →L[ ] » E 𝕜 F)} {x : E} :\n    fderiv_within 𝕜 f t x ∈ s ↔\n      differentiable_within_at 𝕜 f t x ∧ fderiv_within 𝕜 f t x ∈ s ∨\n        ¬differentiable_within_at 𝕜 f t x ∧ (0 : «expr →L[ ] » E 𝕜 F) ∈ s :=\n  by by_cases hx : differentiable_within_at 𝕜 f t x <;> simp [fderiv_within_zero_of_not_differentiable_within_at, *]\n#align fderiv_within_mem_iff fderiv_within_mem_iff\n\n",
 "fderiv_within_inter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem fderiv_within_inter (ht : t ∈ (nhds) x) (hs : unique_diff_within_at 𝕜 s x) :\n    fderiv_within 𝕜 f (s ∩ t) x = fderiv_within 𝕜 f s x :=\n  by\n  by_cases h : differentiable_within_at 𝕜 f (s ∩ t) x\n  · apply fderiv_within_subset (inter_subset_left _ _) _ ((differentiable_within_at_inter ht).1 h)\n    apply hs.inter ht\n  · have : ¬differentiable_within_at 𝕜 f s x := by rwa [← differentiable_within_at_inter ht]\n    rw [fderiv_within_zero_of_not_differentiable_within_at h, fderiv_within_zero_of_not_differentiable_within_at this]\n#align fderiv_within_inter fderiv_within_inter\n\n",
 "fderiv_within_id'":
 "theorem fderiv_within_id' (hxs : unique_diff_within_at 𝕜 s x) :\n    fderiv_within 𝕜 (fun x : E => x) s x = ContinuousLinearMap.id 𝕜 E :=\n  fderiv_within_id hxs\n#align fderiv_within_id' fderiv_within_id'\n\n",
 "fderiv_within_id":
 "theorem fderiv_within_id (hxs : unique_diff_within_at 𝕜 s x) : fderiv_within 𝕜 id s x = id 𝕜 E :=\n  by\n  rw [differentiable_at.fderiv_within differentiable_at_id hxs]\n  exact fderiv_id\n#align fderiv_within_id fderiv_within_id\n\n",
 "fderiv_within_fst":
 "theorem fderiv_within_fst {s : Set (E × F)} (hs : unique_diff_within_at 𝕜 s p) :\n    fderiv_within 𝕜 Prod.fst s p = fst 𝕜 E F :=\n  has_fderiv_within_at_fst.fderiv_within hs\n#align fderiv_within_fst fderiv_within_fst\n\n",
 "fderiv_within_fderiv_within":
 "/-- A version of `fderiv_within.comp` that is useful to rewrite the composition of two derivatives\n  into a single derivative. This version always applies, but creates a new side-goal `f x = y`. -/\ntheorem fderiv_within_fderiv_within {g : F → G} {f : E → F} {x : E} {y : F} {s : Set E} {t : Set F}\n    (hg : differentiable_within_at 𝕜 g t y) (hf : differentiable_within_at 𝕜 f s x) (h : MapsTo f s t)\n    (hxs : unique_diff_within_at 𝕜 s x) (hy : f x = y) (v : E) :\n    fderiv_within 𝕜 g t y (fderiv_within 𝕜 f s x v) = fderiv_within 𝕜 (g ∘ f) s x v :=\n  by\n  subst y\n  rw [fderiv_within.comp x hg hf h hxs]\n  rfl\n#align fderiv_within_fderiv_within fderiv_within_fderiv_within\n\n",
 "fderiv_within_eq_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem filter.eventually_eq.fderiv_within_eq_nhds (hs : unique_diff_within_at 𝕜 s x)\n    (hL : «expr =ᶠ[ ] » f₁ ((nhds) x) f) : fderiv_within 𝕜 f₁ s x = fderiv_within 𝕜 f s x :=\n  (show «expr =ᶠ[ ] » f₁ (nhds_within s x) f from nhdsWithin_le_nhds hL).fderiv_within_eq hs (mem_of_mem_nhds hL : _)\n#align filter.eventually_eq.fderiv_within_eq_nhds filter.eventually_eq.fderiv_within_eq_nhds\n\n",
 "fderiv_within_eq_fderiv":
 "theorem fderiv_within_eq_fderiv (hs : unique_diff_within_at 𝕜 s x) (h : differentiable_at 𝕜 f x) :\n    fderiv_within 𝕜 f s x = fderiv 𝕜 f x := by\n  rw [← fderiv_within_univ]\n  exact fderiv_within_subset (subset_univ _) hs h.differentiable_within_at\n#align fderiv_within_eq_fderiv fderiv_within_eq_fderiv\n\n",
 "fderiv_within_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\ntheorem filter.eventually_eq.fderiv_within_eq (hs : unique_diff_within_at 𝕜 s x)\n    (hL : «expr =ᶠ[ ] » f₁ (nhds_within s x) f) (hx : f₁ x = f x) : fderiv_within 𝕜 f₁ s x = fderiv_within 𝕜 f s x :=\n  if h : differentiable_within_at 𝕜 f s x then\n    has_fderiv_within_at.fderiv_within (h.has_fderiv_within_at.congr_of_eventually_eq hL hx) hs\n  else\n    by\n    have h' : ¬differentiable_within_at 𝕜 f₁ s x :=\n      mt (fun h => h.congr_of_eventually_eq (hL.mono fun x => Eq.symm) hx.symm) h\n    rw [fderiv_within_zero_of_not_differentiable_within_at h, fderiv_within_zero_of_not_differentiable_within_at h']\n#align filter.eventually_eq.fderiv_within_eq filter.eventually_eq.fderiv_within_eq\n\n",
 "fderiv_within_const_sub":
 "theorem fderiv_within_const_sub (hxs : unique_diff_within_at 𝕜 s x) (c : F) :\n    fderiv_within 𝕜 (fun y => c - f y) s x = -fderiv_within 𝕜 f s x := by\n  simp only [sub_eq_add_neg, fderiv_within_const_add, fderiv_within_neg, hxs]\n#align fderiv_within_const_sub fderiv_within_const_sub\n\n",
 "fderiv_within_const_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem fderiv_within_const_smul (hxs : unique_diff_within_at 𝕜 s x) (h : differentiable_within_at 𝕜 f s x) (c : R) :\n    fderiv_within 𝕜 (fun y => «expr • » c (f y)) s x = «expr • » c (fderiv_within 𝕜 f s x) :=\n  (h.has_fderiv_within_at.const_smul c).fderiv_within hxs\n#align fderiv_within_const_smul fderiv_within_const_smul\n\n",
 "fderiv_within_const_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem fderiv_within_const_mul (hxs : unique_diff_within_at 𝕜 s x) (ha : differentiable_within_at 𝕜 a s x) (b : 𝔸) :\n    fderiv_within 𝕜 (fun y => b * a y) s x = «expr • » b (fderiv_within 𝕜 a s x) :=\n  (ha.has_fderiv_within_at.const_mul b).fderiv_within hxs\n#align fderiv_within_const_mul fderiv_within_const_mul\n\n",
 "fderiv_within_const_apply":
 "theorem fderiv_within_const_apply (c : F) (hxs : unique_diff_within_at 𝕜 s x) : fderiv_within 𝕜 (fun y => c) s x = 0 :=\n  by\n  rw [differentiable_at.fderiv_within (differentiable_at_const _) hxs]\n  exact fderiv_const_apply _\n#align fderiv_within_const_apply fderiv_within_const_apply\n\n",
 "fderiv_within_const_add":
 "theorem fderiv_within_const_add (hxs : unique_diff_within_at 𝕜 s x) (c : F) :\n    fderiv_within 𝕜 (fun y => c + f y) s x = fderiv_within 𝕜 f s x := by\n  simpa only [add_comm] using fderiv_within_add_const hxs c\n#align fderiv_within_const_add fderiv_within_const_add\n\n",
 "fderiv_within_congr_mono":
 "theorem differentiable_within_at.fderiv_within_congr_mono (h : differentiable_within_at 𝕜 f s x)\n    (hs : ∀ x ∈ t, f₁ x = f x) (hx : f₁ x = f x) (hxt : unique_diff_within_at 𝕜 t x) (h₁ : t ⊆ s) :\n    fderiv_within 𝕜 f₁ t x = fderiv_within 𝕜 f s x :=\n  (has_fderiv_within_at.congr_mono h.has_fderiv_within_at hs hx h₁).fderiv_within hxt\n#align differentiable_within_at.fderiv_within_congr_mono differentiable_within_at.fderiv_within_congr_mono\n\n",
 "fderiv_within_congr'":
 "theorem fderiv_within_congr' (hs : unique_diff_within_at 𝕜 s x) (hL : ∀ y ∈ s, f₁ y = f y) (hx : x ∈ s) :\n    fderiv_within 𝕜 f₁ s x = fderiv_within 𝕜 f s x :=\n  fderiv_within_congr hs hL (hL x hx)\n#align fderiv_within_congr' fderiv_within_congr'\n\n",
 "fderiv_within_congr":
 "theorem fderiv_within_congr (hs : unique_diff_within_at 𝕜 s x) (hL : ∀ y ∈ s, f₁ y = f y) (hx : f₁ x = f x) :\n    fderiv_within 𝕜 f₁ s x = fderiv_within 𝕜 f s x :=\n  by\n  apply filter.eventually_eq.fderiv_within_eq hs _ hx\n  apply mem_of_superset self_mem_nhdsWithin\n  exact hL\n#align fderiv_within_congr fderiv_within_congr\n\n",
 "fderiv_within_clm_comp":
 "theorem fderiv_within_clm_comp (hxs : unique_diff_within_at 𝕜 s x) (hc : differentiable_within_at 𝕜 c s x)\n    (hd : differentiable_within_at 𝕜 d s x) :\n    fderiv_within 𝕜 (fun y => (c y).comp (d y)) s x =\n      (compL 𝕜 F G H (c x)).comp (fderiv_within 𝕜 d s x) + ((compL 𝕜 F G H).flip (d x)).comp (fderiv_within 𝕜 c s x) :=\n  (hc.has_fderiv_within_at.clm_comp hd.has_fderiv_within_at).fderiv_within hxs\n#align fderiv_within_clm_comp fderiv_within_clm_comp\n\n",
 "fderiv_within_clm_apply":
 "theorem fderiv_within_clm_apply (hxs : unique_diff_within_at 𝕜 s x) (hc : differentiable_within_at 𝕜 c s x)\n    (hu : differentiable_within_at 𝕜 u s x) :\n    fderiv_within 𝕜 (fun y => (c y) (u y)) s x =\n      (c x).comp (fderiv_within 𝕜 u s x) + (fderiv_within 𝕜 c s x).flip (u x) :=\n  (hc.has_fderiv_within_at.clm_apply hu.has_fderiv_within_at).fderiv_within hxs\n#align fderiv_within_clm_apply fderiv_within_clm_apply\n\n",
 "fderiv_within_add_const":
 "theorem fderiv_within_add_const (hxs : unique_diff_within_at 𝕜 s x) (c : F) :\n    fderiv_within 𝕜 (fun y => f y + c) s x = fderiv_within 𝕜 f s x :=\n  if hf : differentiable_within_at 𝕜 f s x then (hf.has_fderiv_within_at.add_const c).fderiv_within hxs\n  else\n    by\n    rw [fderiv_within_zero_of_not_differentiable_within_at hf, fderiv_within_zero_of_not_differentiable_within_at]\n    simpa\n#align fderiv_within_add_const fderiv_within_add_const\n\n",
 "fderiv_within_add":
 "theorem fderiv_within_add (hxs : unique_diff_within_at 𝕜 s x) (hf : differentiable_within_at 𝕜 f s x)\n    (hg : differentiable_within_at 𝕜 g s x) :\n    fderiv_within 𝕜 (fun y => f y + g y) s x = fderiv_within 𝕜 f s x + fderiv_within 𝕜 g s x :=\n  (hf.has_fderiv_within_at.add hg.has_fderiv_within_at).fderiv_within hxs\n#align fderiv_within_add fderiv_within_add\n\n",
 "fderiv_within":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃L[ ] » -/\nprotected theorem fderiv_within (hxs : unique_diff_within_at 𝕜 s x) : fderiv_within 𝕜 iso s x = iso :=\n  (iso : «expr ≃L[ ] » E 𝕜 F).fderiv_within hxs\n#align fderiv_within fderiv_within\n\n",
 "fderiv_sum":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem fderiv_sum (h : ∀ i ∈ u, differentiable_at 𝕜 (A i) x) :\n    fderiv 𝕜\n        (fun y =>\n          finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" u (A i y))\n        x =\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" u\n        (fderiv 𝕜 (A i) x) :=\n  (has_fderiv_at.sum fun i hi => (h i hi).has_fderiv_at).fderiv\n#align fderiv_sum fderiv_sum\n\n",
 "fderiv_sub_const":
 "theorem fderiv_sub_const (c : F) : fderiv 𝕜 (fun y => f y - c) x = fderiv 𝕜 f x := by\n  simp only [sub_eq_add_neg, fderiv_add_const]\n#align fderiv_sub_const fderiv_sub_const\n\n",
 "fderiv_sub":
 "theorem fderiv_sub (hf : differentiable_at 𝕜 f x) (hg : differentiable_at 𝕜 g x) :\n    fderiv 𝕜 (fun y => f y - g y) x = fderiv 𝕜 f x - fderiv 𝕜 g x :=\n  (hf.has_fderiv_at.sub hg.has_fderiv_at).fderiv\n#align fderiv_sub fderiv_sub\n\n",
 "fderiv_snd":
 "theorem fderiv_snd : fderiv 𝕜 Prod.snd p = snd 𝕜 E F :=\n  has_fderiv_at_snd.fderiv\n#align fderiv_snd fderiv_snd\n\n",
 "fderiv_smul_const":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem fderiv_smul_const (hc : differentiable_at 𝕜 c x) (f : F) :\n    fderiv 𝕜 (fun y => «expr • » (c y) f) x = (fderiv 𝕜 c x).smul_right f :=\n  (hc.has_fderiv_at.smul_const f).fderiv\n#align fderiv_smul_const fderiv_smul_const\n\n",
 "fderiv_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem fderiv_smul (hc : differentiable_at 𝕜 c x) (hf : differentiable_at 𝕜 f x) :\n    fderiv 𝕜 (fun y => «expr • » (c y) (f y)) x = «expr • » (c x) (fderiv 𝕜 f x) + (fderiv 𝕜 c x).smul_right (f x) :=\n  (hc.has_fderiv_at.smul hf.has_fderiv_at).fderiv\n#align fderiv_smul fderiv_smul\n\n",
 "fderiv_restrict_scalars":
 "theorem differentiable_at.fderiv_restrict_scalars (h : differentiable_at 𝕜' f x) :\n    fderiv 𝕜 f x = (fderiv 𝕜' f x).restrict_scalars 𝕜 :=\n  (h.has_fderiv_at.restrict_scalars 𝕜).fderiv\n#align differentiable_at.fderiv_restrict_scalars differentiable_at.fderiv_restrict_scalars\n\n",
 "fderiv_prod":
 "theorem differentiable_at.fderiv_prod (hf₁ : differentiable_at 𝕜 f₁ x) (hf₂ : differentiable_at 𝕜 f₂ x) :\n    fderiv 𝕜 (fun x : E => (f₁ x, f₂ x)) x = (fderiv 𝕜 f₁ x).prod (fderiv 𝕜 f₂ x) :=\n  (hf₁.has_fderiv_at.prod hf₂.has_fderiv_at).fderiv\n#align differentiable_at.fderiv_prod differentiable_at.fderiv_prod\n\n",
 "fderiv_pi":
 "theorem fderiv_pi (h : ∀ i, differentiable_at 𝕜 (φ i) x) :\n    fderiv 𝕜 (fun x i => φ i x) x = pi fun i => fderiv 𝕜 (φ i) x :=\n  (has_fderiv_at_pi.2 fun i => (h i).has_fderiv_at).fderiv\n#align fderiv_pi fderiv_pi\n\n",
 "fderiv_of_bilinear":
 "theorem continuous_linear_map.fderiv_of_bilinear {f : G' → E} {g : G' → F} {x : G'} (hf : differentiable_at 𝕜 f x)\n    (hg : differentiable_at 𝕜 g x) :\n    fderiv 𝕜 (fun y => B (f y) (g y)) x = B.precompR G' (f x) (fderiv 𝕜 g x) + B.precompL G' (fderiv 𝕜 f x) (g x) :=\n  (B.has_fderiv_at_of_bilinear hf.has_fderiv_at hg.has_fderiv_at).fderiv\n#align continuous_linear_map.fderiv_of_bilinear continuous_linear_map.fderiv_of_bilinear\n\n",
 "fderiv_neg":
 "@[simp]\ntheorem fderiv_neg : fderiv 𝕜 (fun y => -f y) x = -fderiv 𝕜 f x := by\n  simp only [← fderiv_within_univ, fderiv_within_neg unique_diff_within_at_univ]\n#align fderiv_neg fderiv_neg\n\n",
 "fderiv_mul_const'":
 "theorem fderiv_mul_const' (ha : differentiable_at 𝕜 a x) (b : 𝔸) :\n    fderiv 𝕜 (fun y => a y * b) x = (fderiv 𝕜 a x).smul_right b :=\n  (ha.has_fderiv_at.mul_const' b).fderiv\n#align fderiv_mul_const' fderiv_mul_const'\n\n",
 "fderiv_mul_const":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem fderiv_mul_const (hc : differentiable_at 𝕜 c x) (d : 𝔸') :\n    fderiv 𝕜 (fun y => c y * d) x = «expr • » d (fderiv 𝕜 c x) :=\n  (hc.has_fderiv_at.mul_const d).fderiv\n#align fderiv_mul_const fderiv_mul_const\n\n",
 "fderiv_mul'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem fderiv_mul' (ha : differentiable_at 𝕜 a x) (hb : differentiable_at 𝕜 b x) :\n    fderiv 𝕜 (fun y => a y * b y) x = «expr • » (a x) (fderiv 𝕜 b x) + (fderiv 𝕜 a x).smul_right (b x) :=\n  (ha.has_fderiv_at.mul' hb.has_fderiv_at).fderiv\n#align fderiv_mul' fderiv_mul'\n\n",
 "fderiv_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem fderiv_mul (hc : differentiable_at 𝕜 c x) (hd : differentiable_at 𝕜 d x) :\n    fderiv 𝕜 (fun y => c y * d y) x = «expr • » (c x) (fderiv 𝕜 d x) + «expr • » (d x) (fderiv 𝕜 c x) :=\n  (hc.has_fderiv_at.mul hd.has_fderiv_at).fderiv\n#align fderiv_mul fderiv_mul\n\n",
 "fderiv_mem_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\ntheorem fderiv_mem_iff {f : E → F} {s : Set («expr →L[ ] » E 𝕜 F)} {x : E} :\n    fderiv 𝕜 f x ∈ s ↔\n      differentiable_at 𝕜 f x ∧ fderiv 𝕜 f x ∈ s ∨ ¬differentiable_at 𝕜 f x ∧ (0 : «expr →L[ ] » E 𝕜 F) ∈ s :=\n  by by_cases hx : differentiable_at 𝕜 f x <;> simp [fderiv_zero_of_not_differentiable_at, *]\n#align fderiv_mem_iff fderiv_mem_iff\n\n",
 "fderiv_inverse":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\ntheorem fderiv_inverse (x : «expr ˣ» R) : fderiv 𝕜 (@Ring.inverse R _) x = -mul_left_right 𝕜 R ↑x⁻¹ ↑x⁻¹ :=\n  (has_fderiv_at_ring_inverse x).fderiv\n#align fderiv_inverse fderiv_inverse\n\n",
 "fderiv_id'":
 "@[simp]\ntheorem fderiv_id' : fderiv 𝕜 (fun x : E => x) x = ContinuousLinearMap.id 𝕜 E :=\n  fderiv_id\n#align fderiv_id' fderiv_id'\n\n",
 "fderiv_id":
 "theorem fderiv_id : fderiv 𝕜 id x = id 𝕜 E :=\n  has_fderiv_at.fderiv (has_fderiv_at_id x)\n#align fderiv_id fderiv_id\n\n",
 "fderiv_fst":
 "theorem fderiv_fst : fderiv 𝕜 Prod.fst p = fst 𝕜 E F :=\n  has_fderiv_at_fst.fderiv\n#align fderiv_fst fderiv_fst\n\n",
 "fderiv_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem filter.eventually_eq.fderiv_eq (hL : «expr =ᶠ[ ] » f₁ ((nhds) x) f) : fderiv 𝕜 f₁ x = fderiv 𝕜 f x :=\n  by\n  have A : f₁ x = f x := hL.eq_of_nhds\n  rw [← fderiv_within_univ, ← fderiv_within_univ]\n  rw [← nhdsWithin_univ] at hL\n  exact hL.fderiv_within_eq unique_diff_within_at_univ A\n#align filter.eventually_eq.fderiv_eq filter.eventually_eq.fderiv_eq\n\n",
 "fderiv_const_sub":
 "theorem fderiv_const_sub (c : F) : fderiv 𝕜 (fun y => c - f y) x = -fderiv 𝕜 f x := by\n  simp only [← fderiv_within_univ, fderiv_within_const_sub unique_diff_within_at_univ]\n#align fderiv_const_sub fderiv_const_sub\n\n",
 "fderiv_const_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem fderiv_const_smul (h : differentiable_at 𝕜 f x) (c : R) :\n    fderiv 𝕜 (fun y => «expr • » c (f y)) x = «expr • » c (fderiv 𝕜 f x) :=\n  (h.has_fderiv_at.const_smul c).fderiv\n#align fderiv_const_smul fderiv_const_smul\n\n",
 "fderiv_const_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem fderiv_const_mul (ha : differentiable_at 𝕜 a x) (b : 𝔸) :\n    fderiv 𝕜 (fun y => b * a y) x = «expr • » b (fderiv 𝕜 a x) :=\n  (ha.has_fderiv_at.const_mul b).fderiv\n#align fderiv_const_mul fderiv_const_mul\n\n",
 "fderiv_const_apply":
 "theorem fderiv_const_apply (c : F) : fderiv 𝕜 (fun y => c) x = 0 :=\n  has_fderiv_at.fderiv (has_fderiv_at_const c x)\n#align fderiv_const_apply fderiv_const_apply\n\n",
 "fderiv_const_add":
 "theorem fderiv_const_add (c : F) : fderiv 𝕜 (fun y => c + f y) x = fderiv 𝕜 f x := by\n  simp only [add_comm c, fderiv_add_const]\n#align fderiv_const_add fderiv_const_add\n\n",
 "fderiv_const":
 "@[simp]\ntheorem fderiv_const (c : F) : (fderiv 𝕜 fun y : E => c) = 0 :=\n  by\n  ext m\n  rw [fderiv_const_apply]\n  rfl\n#align fderiv_const fderiv_const\n\n",
 "fderiv_clm_comp":
 "theorem fderiv_clm_comp (hc : differentiable_at 𝕜 c x) (hd : differentiable_at 𝕜 d x) :\n    fderiv 𝕜 (fun y => (c y).comp (d y)) x =\n      (compL 𝕜 F G H (c x)).comp (fderiv 𝕜 d x) + ((compL 𝕜 F G H).flip (d x)).comp (fderiv 𝕜 c x) :=\n  (hc.has_fderiv_at.clm_comp hd.has_fderiv_at).fderiv\n#align fderiv_clm_comp fderiv_clm_comp\n\n",
 "fderiv_clm_apply":
 "theorem fderiv_clm_apply (hc : differentiable_at 𝕜 c x) (hu : differentiable_at 𝕜 u x) :\n    fderiv 𝕜 (fun y => (c y) (u y)) x = (c x).comp (fderiv 𝕜 u x) + (fderiv 𝕜 c x).flip (u x) :=\n  (hc.has_fderiv_at.clm_apply hu.has_fderiv_at).fderiv\n#align fderiv_clm_apply fderiv_clm_apply\n\n",
 "fderiv_add_const":
 "theorem fderiv_add_const (c : F) : fderiv 𝕜 (fun y => f y + c) x = fderiv 𝕜 f x := by\n  simp only [← fderiv_within_univ, fderiv_within_add_const unique_diff_within_at_univ]\n#align fderiv_add_const fderiv_add_const\n\n",
 "fderiv_add":
 "theorem fderiv_add (hf : differentiable_at 𝕜 f x) (hg : differentiable_at 𝕜 g x) :\n    fderiv 𝕜 (fun y => f y + g y) x = fderiv 𝕜 f x + fderiv 𝕜 g x :=\n  (hf.has_fderiv_at.add hg.has_fderiv_at).fderiv\n#align fderiv_add fderiv_add\n\n",
 "fderiv":
 "theorem has_compact_support.fderiv (hf : HasCompactSupport f) : HasCompactSupport (fderiv 𝕜 f) :=\n  hf.mono' <| support_fderiv_subset 𝕜\n#align has_compact_support.fderiv has_compact_support.fderiv\n\n",
 "exists_lipschitz_on_with_of_nnnorm_lt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- If `f` is strictly differentiable at `x` with derivative `f'` and `K > ‖f'‖₊`, then `f` is\n`K`-Lipschitz in a neighborhood of `x`. -/\ntheorem has_strict_fderiv_at.exists_lipschitz_on_with_of_nnnorm_lt (hf : has_strict_fderiv_at f f' x) (K : nnreal)\n    (hK : «expr‖ ‖₊» f' < K) : ∃ s ∈ (nhds) x, LipschitzOnWith K f s :=\n  by\n  have := hf.add_is_O_with (f'.is_O_with_comp _ _) hK\n  simp only [sub_add_cancel, is_O_with] at this\n  rcases exists_nhds_square this with ⟨U, Uo, xU, hU⟩\n  exact ⟨U, Uo.mem_nhds xU, lipschitzOnWith_iff_norm_sub_le.2 fun x hx y hy => hU (mk_mem_prod hx hy)⟩\n#align has_strict_fderiv_at.exists_lipschitz_on_with_of_nnnorm_lt has_strict_fderiv_at.exists_lipschitz_on_with_of_nnnorm_lt\n\n",
 "exists_lipschitz_on_with":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- If `f` is strictly differentiable at `x` with derivative `f'`, then `f` is Lipschitz in a\nneighborhood of `x`. See also `has_strict_fderiv_at.exists_lipschitz_on_with_of_nnnorm_lt` for a\nmore precise statement. -/\ntheorem has_strict_fderiv_at.exists_lipschitz_on_with (hf : has_strict_fderiv_at f f' x) :\n    ∃ K, ∃ s ∈ (nhds) x, LipschitzOnWith K f s :=\n  (exists_gt _).imp hf.exists_lipschitz_on_with_of_nnnorm_lt\n#align has_strict_fderiv_at.exists_lipschitz_on_with has_strict_fderiv_at.exists_lipschitz_on_with\n\n",
 "eventually_ne":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.ne -/\ntheorem has_fderiv_at.eventually_ne (h : has_fderiv_at f f' x) (hf' : ∃ C, ∀ z, «expr‖ ‖» z ≤ C * «expr‖ ‖» (f' z)) :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\"\n      (nhds_within.ne x) (f z ≠ f x) :=\n  by simpa only [compl_eq_univ_diff] using (has_fderiv_within_at_univ.2 h).eventually_ne hf'\n#align has_fderiv_at.eventually_ne has_fderiv_at.eventually_ne\n\n",
 "eventually_differentiable_at":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem differentiable_on.eventually_differentiable_at (h : differentiable_on 𝕜 f s) (hs : s ∈ (nhds) x) :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" ((nhds) x)\n      (differentiable_at 𝕜 f y) :=\n  (eventually_eventually_nhds.2 hs).mono fun y => h.differentiable_at\n#align differentiable_on.eventually_differentiable_at differentiable_on.eventually_differentiable_at\n\n",
 "eq":
 "theorem unique_diff_on.eq (H : unique_diff_on 𝕜 s) (hx : x ∈ s) (h : has_fderiv_within_at f f' s x)\n    (h₁ : has_fderiv_within_at f f₁' s x) : f' = f₁' :=\n  (H x hx).eq h h₁\n#align unique_diff_on.eq unique_diff_on.eq\n\n",
 "differentiable_within_at_univ":
 "theorem differentiable_within_at_univ : differentiable_within_at 𝕜 f univ x ↔ differentiable_at 𝕜 f x := by\n  simp only [differentiable_within_at, has_fderiv_within_at_univ, differentiable_at]\n#align differentiable_within_at_univ differentiable_within_at_univ\n\n",
 "differentiable_within_at_sub_const_iff":
 "@[simp]\ntheorem differentiable_within_at_sub_const_iff (c : F) :\n    differentiable_within_at 𝕜 (fun y => f y - c) s x ↔ differentiable_within_at 𝕜 f s x := by\n  simp only [sub_eq_add_neg, differentiable_within_at_add_const_iff]\n#align differentiable_within_at_sub_const_iff differentiable_within_at_sub_const_iff\n\n",
 "differentiable_within_at_snd":
 "theorem differentiable_within_at_snd {s : Set (E × F)} : differentiable_within_at 𝕜 Prod.snd s p :=\n  differentiable_at_snd.differentiable_within_at\n#align differentiable_within_at_snd differentiable_within_at_snd\n\n",
 "differentiable_within_at_pi":
 "@[simp]\ntheorem differentiable_within_at_pi :\n    differentiable_within_at 𝕜 Φ s x ↔ ∀ i, differentiable_within_at 𝕜 (fun x => Φ x i) s x :=\n  ⟨fun h i => (has_fderiv_within_at_pi'.1 h.has_fderiv_within_at i).differentiable_within_at, fun h =>\n    (has_fderiv_within_at_pi.2 fun i => (h i).has_fderiv_within_at).differentiable_within_at⟩\n#align differentiable_within_at_pi differentiable_within_at_pi\n\n",
 "differentiable_within_at_neg_iff":
 "@[simp]\ntheorem differentiable_within_at_neg_iff :\n    differentiable_within_at 𝕜 (fun y => -f y) s x ↔ differentiable_within_at 𝕜 f s x :=\n  ⟨fun h => by simpa only [neg_neg] using h.neg, fun h => h.neg⟩\n#align differentiable_within_at_neg_iff differentiable_within_at_neg_iff\n\n",
 "differentiable_within_at_inter'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\ntheorem differentiable_within_at_inter' (ht : t ∈ nhds_within s x) :\n    differentiable_within_at 𝕜 f (s ∩ t) x ↔ differentiable_within_at 𝕜 f s x := by\n  simp only [differentiable_within_at, has_fderiv_within_at, has_fderiv_at_filter, nhdsWithin_restrict'' s ht]\n#align differentiable_within_at_inter' differentiable_within_at_inter'\n\n",
 "differentiable_within_at_inter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem differentiable_within_at_inter (ht : t ∈ (nhds) x) :\n    differentiable_within_at 𝕜 f (s ∩ t) x ↔ differentiable_within_at 𝕜 f s x := by\n  simp only [differentiable_within_at, has_fderiv_within_at, has_fderiv_at_filter, nhdsWithin_restrict' s ht]\n#align differentiable_within_at_inter differentiable_within_at_inter\n\n",
 "differentiable_within_at_iff_restrict_scalars":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\ntheorem differentiable_within_at_iff_restrict_scalars (hf : differentiable_within_at 𝕜 f s x)\n    (hs : unique_diff_within_at 𝕜 s x) :\n    differentiable_within_at 𝕜' f s x ↔ ∃ g' : «expr →L[ ] » E 𝕜' F, g'.restrict_scalars 𝕜 = fderiv_within 𝕜 f s x :=\n  by\n  constructor\n  · rintro ⟨g', hg'⟩\n    exact ⟨g', hs.eq (hg'.restrict_scalars 𝕜) hf.has_fderiv_within_at⟩\n  · rintro ⟨f', hf'⟩\n    exact ⟨f', has_fderiv_within_at_of_restrict_scalars 𝕜 hf.has_fderiv_within_at hf'⟩\n#align differentiable_within_at_iff_restrict_scalars differentiable_within_at_iff_restrict_scalars\n\n",
 "differentiable_within_at_iff_of_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\ntheorem filter.eventually_eq.differentiable_within_at_iff_of_mem (h : «expr =ᶠ[ ] » f₀ (nhds_within s x) f₁)\n    (hx : x ∈ s) : differentiable_within_at 𝕜 f₀ s x ↔ differentiable_within_at 𝕜 f₁ s x :=\n  h.differentiable_within_at_iff (h.eq_of_nhds_within hx)\n#align filter.eventually_eq.differentiable_within_at_iff_of_mem filter.eventually_eq.differentiable_within_at_iff_of_mem\n\n",
 "differentiable_within_at_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\ntheorem filter.eventually_eq.differentiable_within_at_iff (h : «expr =ᶠ[ ] » f₀ (nhds_within s x) f₁)\n    (hx : f₀ x = f₁ x) : differentiable_within_at 𝕜 f₀ s x ↔ differentiable_within_at 𝕜 f₁ s x :=\n  exists_congr fun f' => h.has_fderiv_within_at_iff hx\n#align filter.eventually_eq.differentiable_within_at_iff filter.eventually_eq.differentiable_within_at_iff\n\n",
 "differentiable_within_at_id":
 "theorem differentiable_within_at_id : differentiable_within_at 𝕜 id s x :=\n  differentiable_at_id.differentiable_within_at\n#align differentiable_within_at_id differentiable_within_at_id\n\n",
 "differentiable_within_at_fst":
 "theorem differentiable_within_at_fst {s : Set (E × F)} : differentiable_within_at 𝕜 Prod.fst s p :=\n  differentiable_at_fst.differentiable_within_at\n#align differentiable_within_at_fst differentiable_within_at_fst\n\n",
 "differentiable_within_at_const_sub_iff":
 "@[simp]\ntheorem differentiable_within_at_const_sub_iff (c : F) :\n    differentiable_within_at 𝕜 (fun y => c - f y) s x ↔ differentiable_within_at 𝕜 f s x := by simp [sub_eq_add_neg]\n#align differentiable_within_at_const_sub_iff differentiable_within_at_const_sub_iff\n\n",
 "differentiable_within_at_const_add_iff":
 "@[simp]\ntheorem differentiable_within_at_const_add_iff (c : F) :\n    differentiable_within_at 𝕜 (fun y => c + f y) s x ↔ differentiable_within_at 𝕜 f s x :=\n  ⟨fun h => by simpa using h.const_add (-c), fun h => h.const_add c⟩\n#align differentiable_within_at_const_add_iff differentiable_within_at_const_add_iff\n\n",
 "differentiable_within_at_const":
 "theorem differentiable_within_at_const (c : F) : differentiable_within_at 𝕜 (fun x => c) s x :=\n  differentiable_at.differentiable_within_at (differentiable_at_const _)\n#align differentiable_within_at_const differentiable_within_at_const\n\n",
 "differentiable_within_at_add_const_iff":
 "@[simp]\ntheorem differentiable_within_at_add_const_iff (c : F) :\n    differentiable_within_at 𝕜 (fun y => f y + c) s x ↔ differentiable_within_at 𝕜 f s x :=\n  ⟨fun h => by simpa using h.add_const (-c), fun h => h.add_const c⟩\n#align differentiable_within_at_add_const_iff differentiable_within_at_add_const_iff\n\n",
 "differentiable_within_at":
 "protected theorem differentiable_within_at : differentiable_within_at 𝕜 iso s x :=\n  iso.differentiable_at.differentiable_within_at\n#align differentiable_within_at differentiable_within_at\n\n",
 "differentiable_sub_const_iff":
 "@[simp]\ntheorem differentiable_sub_const_iff (c : F) : (differentiable 𝕜 fun y => f y - c) ↔ differentiable 𝕜 f := by\n  simp only [sub_eq_add_neg, differentiable_add_const_iff]\n#align differentiable_sub_const_iff differentiable_sub_const_iff\n\n",
 "differentiable_snd":
 "theorem differentiable_snd : differentiable 𝕜 (Prod.snd : E × F → F) := fun x => differentiable_at_snd\n#align differentiable_snd differentiable_snd\n\n",
 "differentiable_pi":
 "theorem differentiable_pi : differentiable 𝕜 Φ ↔ ∀ i, differentiable 𝕜 fun x => Φ x i :=\n  ⟨fun h i x => differentiable_at_pi.1 (h x) i, fun h x => differentiable_at_pi.2 fun i => h i x⟩\n#align differentiable_pi differentiable_pi\n\n",
 "differentiable_on_univ":
 "theorem differentiable_on_univ : differentiable_on 𝕜 f univ ↔ differentiable 𝕜 f := by\n  simp only [differentiable_on, differentiable, differentiable_within_at_univ, mem_univ, forall_true_left]\n#align differentiable_on_univ differentiable_on_univ\n\n",
 "differentiable_on_sub_const_iff":
 "@[simp]\ntheorem differentiable_on_sub_const_iff (c : F) : differentiable_on 𝕜 (fun y => f y - c) s ↔ differentiable_on 𝕜 f s :=\n  by simp only [sub_eq_add_neg, differentiable_on_add_const_iff]\n#align differentiable_on_sub_const_iff differentiable_on_sub_const_iff\n\n",
 "differentiable_on_snd":
 "theorem differentiable_on_snd {s : Set (E × F)} : differentiable_on 𝕜 Prod.snd s :=\n  differentiable_snd.differentiable_on\n#align differentiable_on_snd differentiable_on_snd\n\n",
 "differentiable_on_singleton":
 "theorem differentiable_on_singleton : differentiable_on 𝕜 f {x} :=\n  forall_eq.2 (has_fderiv_within_at_singleton f x).differentiable_within_at\n#align differentiable_on_singleton differentiable_on_singleton\n\n",
 "differentiable_on_pi":
 "theorem differentiable_on_pi : differentiable_on 𝕜 Φ s ↔ ∀ i, differentiable_on 𝕜 (fun x => Φ x i) s :=\n  ⟨fun h i x hx => differentiable_within_at_pi.1 (h x hx) i, fun h x hx =>\n    differentiable_within_at_pi.2 fun i => h i x hx⟩\n#align differentiable_on_pi differentiable_on_pi\n\n",
 "differentiable_on_of_locally_differentiable_on":
 "theorem differentiable_on_of_locally_differentiable_on\n    (h : ∀ x ∈ s, ∃ u, IsOpen u ∧ x ∈ u ∧ differentiable_on 𝕜 f (s ∩ u)) : differentiable_on 𝕜 f s :=\n  by\n  intro x xs\n  rcases h x xs with ⟨t, t_open, xt, ht⟩\n  exact (differentiable_within_at_inter (IsOpen.mem_nhds t_open xt)).1 (ht x ⟨xs, xt⟩)\n#align differentiable_on_of_locally_differentiable_on differentiable_on_of_locally_differentiable_on\n\n",
 "differentiable_on_neg_iff":
 "@[simp]\ntheorem differentiable_on_neg_iff : differentiable_on 𝕜 (fun y => -f y) s ↔ differentiable_on 𝕜 f s :=\n  ⟨fun h => by simpa only [neg_neg] using h.neg, fun h => h.neg⟩\n#align differentiable_on_neg_iff differentiable_on_neg_iff\n\n",
 "differentiable_on_id":
 "theorem differentiable_on_id : differentiable_on 𝕜 id s :=\n  differentiable_id.differentiable_on\n#align differentiable_on_id differentiable_on_id\n\n",
 "differentiable_on_fst":
 "theorem differentiable_on_fst {s : Set (E × F)} : differentiable_on 𝕜 Prod.fst s :=\n  differentiable_fst.differentiable_on\n#align differentiable_on_fst differentiable_on_fst\n\n",
 "differentiable_on_empty":
 "theorem differentiable_on_empty : differentiable_on 𝕜 f ∅ := fun x => false.elim\n#align differentiable_on_empty differentiable_on_empty\n\n",
 "differentiable_on_const_sub_iff":
 "@[simp]\ntheorem differentiable_on_const_sub_iff (c : F) : differentiable_on 𝕜 (fun y => c - f y) s ↔ differentiable_on 𝕜 f s :=\n  by simp [sub_eq_add_neg]\n#align differentiable_on_const_sub_iff differentiable_on_const_sub_iff\n\n",
 "differentiable_on_const_add_iff":
 "@[simp]\ntheorem differentiable_on_const_add_iff (c : F) : differentiable_on 𝕜 (fun y => c + f y) s ↔ differentiable_on 𝕜 f s :=\n  ⟨fun h => by simpa using h.const_add (-c), fun h => h.const_add c⟩\n#align differentiable_on_const_add_iff differentiable_on_const_add_iff\n\n",
 "differentiable_on_const":
 "theorem differentiable_on_const (c : F) : differentiable_on 𝕜 (fun x => c) s :=\n  (differentiable_const _).differentiable_on\n#align differentiable_on_const differentiable_on_const\n\n",
 "differentiable_on_congr":
 "theorem differentiable_on_congr (h' : ∀ x ∈ s, f₁ x = f x) : differentiable_on 𝕜 f₁ s ↔ differentiable_on 𝕜 f s :=\n  ⟨fun h => differentiable_on.congr h fun y hy => (h' y hy).symm, fun h => differentiable_on.congr h h'⟩\n#align differentiable_on_congr differentiable_on_congr\n\n",
 "differentiable_on_add_const_iff":
 "@[simp]\ntheorem differentiable_on_add_const_iff (c : F) : differentiable_on 𝕜 (fun y => f y + c) s ↔ differentiable_on 𝕜 f s :=\n  ⟨fun h => by simpa using h.add_const (-c), fun h => h.add_const c⟩\n#align differentiable_on_add_const_iff differentiable_on_add_const_iff\n\n",
 "differentiable_on":
 "protected theorem differentiable_on : differentiable_on 𝕜 iso s :=\n  iso.differentiable.differentiable_on\n#align differentiable_on differentiable_on\n\n",
 "differentiable_neg_iff":
 "@[simp]\ntheorem differentiable_neg_iff : (differentiable 𝕜 fun y => -f y) ↔ differentiable 𝕜 f :=\n  ⟨fun h => by simpa only [neg_neg] using h.neg, fun h => h.neg⟩\n#align differentiable_neg_iff differentiable_neg_iff\n\n",
 "differentiable_id'":
 "@[simp]\ntheorem differentiable_id' : differentiable 𝕜 fun x : E => x := fun x => differentiable_at_id\n#align differentiable_id' differentiable_id'\n\n",
 "differentiable_id":
 "@[simp]\ntheorem differentiable_id : differentiable 𝕜 (id : E → E) := fun x => differentiable_at_id\n#align differentiable_id differentiable_id\n\n",
 "differentiable_fst":
 "theorem differentiable_fst : differentiable 𝕜 (Prod.fst : E × F → E) := fun x => differentiable_at_fst\n#align differentiable_fst differentiable_fst\n\n",
 "differentiable_const_sub_iff":
 "@[simp]\ntheorem differentiable_const_sub_iff (c : F) : (differentiable 𝕜 fun y => c - f y) ↔ differentiable 𝕜 f := by\n  simp [sub_eq_add_neg]\n#align differentiable_const_sub_iff differentiable_const_sub_iff\n\n",
 "differentiable_const_add_iff":
 "@[simp]\ntheorem differentiable_const_add_iff (c : F) : (differentiable 𝕜 fun y => c + f y) ↔ differentiable 𝕜 f :=\n  ⟨fun h => by simpa using h.const_add (-c), fun h => h.const_add c⟩\n#align differentiable_const_add_iff differentiable_const_add_iff\n\n",
 "differentiable_const":
 "@[simp]\ntheorem differentiable_const (c : F) : differentiable 𝕜 fun x : E => c := fun x => differentiable_at_const _\n#align differentiable_const differentiable_const\n\n",
 "differentiable_at_sub_const_iff":
 "@[simp]\ntheorem differentiable_at_sub_const_iff (c : F) : differentiable_at 𝕜 (fun y => f y - c) x ↔ differentiable_at 𝕜 f x :=\n  by simp only [sub_eq_add_neg, differentiable_at_add_const_iff]\n#align differentiable_at_sub_const_iff differentiable_at_sub_const_iff\n\n",
 "differentiable_at_snd":
 "theorem differentiable_at_snd : differentiable_at 𝕜 Prod.snd p :=\n  has_fderiv_at_snd.differentiable_at\n#align differentiable_at_snd differentiable_at_snd\n\n",
 "differentiable_at_pi":
 "@[simp]\ntheorem differentiable_at_pi : differentiable_at 𝕜 Φ x ↔ ∀ i, differentiable_at 𝕜 (fun x => Φ x i) x :=\n  ⟨fun h i => (has_fderiv_at_pi'.1 h.has_fderiv_at i).differentiable_at, fun h =>\n    (has_fderiv_at_pi.2 fun i => (h i).has_fderiv_at).differentiable_at⟩\n#align differentiable_at_pi differentiable_at_pi\n\n",
 "differentiable_at_neg_iff":
 "@[simp]\ntheorem differentiable_at_neg_iff : differentiable_at 𝕜 (fun y => -f y) x ↔ differentiable_at 𝕜 f x :=\n  ⟨fun h => by simpa only [neg_neg] using h.neg, fun h => h.neg⟩\n#align differentiable_at_neg_iff differentiable_at_neg_iff\n\n",
 "differentiable_at_inverse":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\ntheorem differentiable_at_inverse (x : «expr ˣ» R) : differentiable_at 𝕜 (@Ring.inverse R _) x :=\n  (has_fderiv_at_ring_inverse x).differentiable_at\n#align differentiable_at_inverse differentiable_at_inverse\n\n",
 "differentiable_at_iff_restrict_scalars":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\ntheorem differentiable_at_iff_restrict_scalars (hf : differentiable_at 𝕜 f x) :\n    differentiable_at 𝕜' f x ↔ ∃ g' : «expr →L[ ] » E 𝕜' F, g'.restrict_scalars 𝕜 = fderiv 𝕜 f x :=\n  by\n  rw [← differentiable_within_at_univ, ← fderiv_within_univ]\n  exact differentiable_within_at_iff_restrict_scalars 𝕜 hf.differentiable_within_at unique_diff_within_at_univ\n#align differentiable_at_iff_restrict_scalars differentiable_at_iff_restrict_scalars\n\n",
 "differentiable_at_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem filter.eventually_eq.differentiable_at_iff (h : «expr =ᶠ[ ] » f₀ ((nhds) x) f₁) :\n    differentiable_at 𝕜 f₀ x ↔ differentiable_at 𝕜 f₁ x :=\n  exists_congr fun f' => h.has_fderiv_at_iff\n#align filter.eventually_eq.differentiable_at_iff filter.eventually_eq.differentiable_at_iff\n\n",
 "differentiable_at_id'":
 "@[simp]\ntheorem differentiable_at_id' : differentiable_at 𝕜 (fun x => x) x :=\n  (has_fderiv_at_id x).differentiable_at\n#align differentiable_at_id' differentiable_at_id'\n\n",
 "differentiable_at_id":
 "@[simp]\ntheorem differentiable_at_id : differentiable_at 𝕜 id x :=\n  (has_fderiv_at_id x).differentiable_at\n#align differentiable_at_id differentiable_at_id\n\n",
 "differentiable_at_fst":
 "theorem differentiable_at_fst : differentiable_at 𝕜 Prod.fst p :=\n  has_fderiv_at_fst.differentiable_at\n#align differentiable_at_fst differentiable_at_fst\n\n",
 "differentiable_at_const_sub_iff":
 "@[simp]\ntheorem differentiable_at_const_sub_iff (c : F) : differentiable_at 𝕜 (fun y => c - f y) x ↔ differentiable_at 𝕜 f x :=\n  by simp [sub_eq_add_neg]\n#align differentiable_at_const_sub_iff differentiable_at_const_sub_iff\n\n",
 "differentiable_at_const_add_iff":
 "@[simp]\ntheorem differentiable_at_const_add_iff (c : F) : differentiable_at 𝕜 (fun y => c + f y) x ↔ differentiable_at 𝕜 f x :=\n  ⟨fun h => by simpa using h.const_add (-c), fun h => h.const_add c⟩\n#align differentiable_at_const_add_iff differentiable_at_const_add_iff\n\n",
 "differentiable_at_const":
 "@[simp]\ntheorem differentiable_at_const (c : F) : differentiable_at 𝕜 (fun x => c) x :=\n  ⟨0, has_fderiv_at_const c x⟩\n#align differentiable_at_const differentiable_at_const\n\n",
 "differentiable_at_add_const_iff":
 "@[simp]\ntheorem differentiable_at_add_const_iff (c : F) : differentiable_at 𝕜 (fun y => f y + c) x ↔ differentiable_at 𝕜 f x :=\n  ⟨fun h => by simpa using h.add_const (-c), fun h => h.add_const c⟩\n#align differentiable_at_add_const_iff differentiable_at_add_const_iff\n\n",
 "differentiable_at":
 "protected theorem differentiable_at : differentiable_at 𝕜 iso x :=\n  iso.has_fderiv_at.differentiable_at\n#align differentiable_at differentiable_at\n\n",
 "differentiable_add_const_iff":
 "@[simp]\ntheorem differentiable_add_const_iff (c : F) : (differentiable 𝕜 fun y => f y + c) ↔ differentiable 𝕜 f :=\n  ⟨fun h => by simpa using h.add_const (-c), fun h => h.add_const c⟩\n#align differentiable_add_const_iff differentiable_add_const_iff\n\n",
 "differentiable":
 "protected theorem differentiable : differentiable 𝕜 iso := fun x => iso.differentiable_at\n#align differentiable differentiable\n\n",
 "continuous_within_at":
 "theorem differentiable_within_at.continuous_within_at (h : differentiable_within_at 𝕜 f s x) :\n    ContinuousWithinAt f s x :=\n  let ⟨f', hf'⟩ := h\n  hf'.continuous_within_at\n#align differentiable_within_at.continuous_within_at differentiable_within_at.continuous_within_at\n\n",
 "continuous_on":
 "theorem differentiable_on.continuous_on (h : differentiable_on 𝕜 f s) : ContinuousOn f s := fun x hx =>\n  (h x hx).continuous_within_at\n#align differentiable_on.continuous_on differentiable_on.continuous_on\n\n",
 "continuous_at":
 "protected theorem has_strict_fderiv_at.continuous_at (hf : has_strict_fderiv_at f f' x) : ContinuousAt f x :=\n  hf.has_fderiv_at.continuous_at\n#align has_strict_fderiv_at.continuous_at has_strict_fderiv_at.continuous_at\n\n",
 "continuous":
 "theorem differentiable.continuous (h : differentiable 𝕜 f) : Continuous f :=\n  continuous_iff_continuousAt.2 fun x => (h x).continuous_at\n#align differentiable.continuous differentiable.continuous\n\n",
 "const_sub":
 "theorem differentiable.const_sub (hf : differentiable 𝕜 f) (c : F) : differentiable 𝕜 fun y => c - f y := fun x =>\n  (hf x).const_sub c\n#align differentiable.const_sub differentiable.const_sub\n\n",
 "const_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem differentiable.const_smul (h : differentiable 𝕜 f) (c : R) : differentiable 𝕜 fun y => «expr • » c (f y) :=\n  fun x => (h x).const_smul c\n#align differentiable.const_smul differentiable.const_smul\n\n",
 "const_mul":
 "theorem differentiable.const_mul (ha : differentiable 𝕜 a) (b : 𝔸) : differentiable 𝕜 fun y => b * a y := fun x =>\n  (ha x).const_mul b\n#align differentiable.const_mul differentiable.const_mul\n\n",
 "const_add":
 "theorem differentiable.const_add (hf : differentiable 𝕜 f) (c : F) : differentiable 𝕜 fun y => c + f y := fun x =>\n  (hf x).const_add c\n#align differentiable.const_add differentiable.const_add\n\n",
 "congr_of_eventually_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem differentiable_at.congr_of_eventually_eq (h : differentiable_at 𝕜 f x) (hL : «expr =ᶠ[ ] » f₁ ((nhds) x) f) :\n    differentiable_at 𝕜 f₁ x :=\n  hL.differentiable_at_iff.2 h\n#align differentiable_at.congr_of_eventually_eq differentiable_at.congr_of_eventually_eq\n\n",
 "congr_mono":
 "theorem differentiable_on.congr_mono (h : differentiable_on 𝕜 f s) (h' : ∀ x ∈ t, f₁ x = f x) (h₁ : t ⊆ s) :\n    differentiable_on 𝕜 f₁ t := fun x hx => (h x (h₁ hx)).congr_mono h' (h' x hx) h₁\n#align differentiable_on.congr_mono differentiable_on.congr_mono\n\n",
 "congr'":
 "theorem has_fderiv_within_at.congr' (h : has_fderiv_within_at f f' s x) (hs : ∀ x ∈ s, f₁ x = f x) (hx : x ∈ s) :\n    has_fderiv_within_at f₁ f' s x :=\n  h.congr hs (hs x hx)\n#align has_fderiv_within_at.congr' has_fderiv_within_at.congr'\n\n",
 "congr":
 "theorem differentiable_on.congr (h : differentiable_on 𝕜 f s) (h' : ∀ x ∈ s, f₁ x = f x) : differentiable_on 𝕜 f₁ s :=\n  fun x hx => (h x hx).congr h' (h' x hx)\n#align differentiable_on.congr differentiable_on.congr\n\n",
 "comp₃":
 "/-- Ternary version of `fderiv_within.comp`, with equality assumptions of basepoints added, in\n  order to apply more easily as a rewrite from right-to-left. -/\ntheorem fderiv_within.comp₃ {g' : G → G'} {g : F → G} {t : Set F} {u : Set G} {y : F} {y' : G}\n    (hg' : differentiable_within_at 𝕜 g' u y') (hg : differentiable_within_at 𝕜 g t y)\n    (hf : differentiable_within_at 𝕜 f s x) (h2g : MapsTo g t u) (h2f : MapsTo f s t) (h3g : g y = y') (h3f : f x = y)\n    (hxs : unique_diff_within_at 𝕜 s x) :\n    fderiv_within 𝕜 (g' ∘ g ∘ f) s x =\n      (fderiv_within 𝕜 g' u y').comp ((fderiv_within 𝕜 g t y).comp (fderiv_within 𝕜 f s x)) :=\n  by\n  substs h3g h3f\n  exact\n    (hg'.has_fderiv_within_at.comp x (hg.has_fderiv_within_at.comp x hf.has_fderiv_within_at h2f) <|\n          h2g.comp h2f).fderiv_within\n      hxs\n#align fderiv_within.comp₃ fderiv_within.comp₃\n\n",
 "comp_right_has_fderiv_within_at_iff'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\ntheorem comp_right_has_fderiv_within_at_iff' {f : F → G} {s : Set F} {x : E} {f' : «expr →L[ ] » E 𝕜 G} :\n    has_fderiv_within_at (f ∘ iso) f' («expr ⁻¹' » iso s) x ↔\n      has_fderiv_within_at f (f'.comp (iso.symm : «expr →L[ ] » F 𝕜 E)) s (iso x) :=\n  by\n  rw [← iso.comp_right_has_fderiv_within_at_iff, ContinuousLinearMap.comp_assoc, iso.coe_symm_comp_coe,\n    ContinuousLinearMap.comp_id]\n#align comp_right_has_fderiv_within_at_iff' comp_right_has_fderiv_within_at_iff'\n\n",
 "comp_right_has_fderiv_within_at_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem comp_right_has_fderiv_within_at_iff {f : F → G} {s : Set F} {x : E} {f' : «expr →L[ ] » F 𝕜 G} :\n    has_fderiv_within_at (f ∘ iso) (f'.comp (iso : «expr →L[ ] » E 𝕜 F)) («expr ⁻¹' » iso s) x ↔\n      has_fderiv_within_at f f' s (iso x) :=\n  by\n  refine' ⟨fun H => _, fun H => H.comp x iso.has_fderiv_within_at (maps_to_preimage _ s)⟩\n  rw [← iso.symm_apply_apply x] at H\n  have A : f = (f ∘ iso) ∘ iso.symm :=\n    by\n    rw [function.comp.assoc, iso.self_comp_symm]\n    rfl\n  have B : f' = (f'.comp (iso : «expr →L[ ] » E 𝕜 F)).comp (iso.symm : «expr →L[ ] » F 𝕜 E) := by\n    rw [ContinuousLinearMap.comp_assoc, iso.coe_comp_coe_symm, ContinuousLinearMap.comp_id]\n  rw [A, B]\n  apply H.comp (iso x) iso.symm.has_fderiv_within_at\n  intro y hy\n  simpa only [mem_preimage, apply_symm_apply] using hy\n#align comp_right_has_fderiv_within_at_iff comp_right_has_fderiv_within_at_iff\n\n",
 "comp_right_has_fderiv_at_iff'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\ntheorem comp_right_has_fderiv_at_iff' {f : F → G} {x : E} {f' : «expr →L[ ] » E 𝕜 G} :\n    has_fderiv_at (f ∘ iso) f' x ↔ has_fderiv_at f (f'.comp (iso.symm : «expr →L[ ] » F 𝕜 E)) (iso x) := by\n  simp only [← has_fderiv_within_at_univ, ← iso.comp_right_has_fderiv_within_at_iff', preimage_univ]\n#align comp_right_has_fderiv_at_iff' comp_right_has_fderiv_at_iff'\n\n",
 "comp_right_has_fderiv_at_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\ntheorem comp_right_has_fderiv_at_iff {f : F → G} {x : E} {f' : «expr →L[ ] » F 𝕜 G} :\n    has_fderiv_at (f ∘ iso) (f'.comp (iso : «expr →L[ ] » E 𝕜 F)) x ↔ has_fderiv_at f f' (iso x) := by\n  simp only [← has_fderiv_within_at_univ, ← comp_right_has_fderiv_within_at_iff, preimage_univ]\n#align comp_right_has_fderiv_at_iff comp_right_has_fderiv_at_iff\n\n",
 "comp_right_fderiv_within":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\ntheorem comp_right_fderiv_within {f : F → G} {s : Set F} {x : E} (hxs : unique_diff_within_at 𝕜 («expr ⁻¹' » iso s) x) :\n    fderiv_within 𝕜 (f ∘ iso) («expr ⁻¹' » iso s) x = (fderiv_within 𝕜 f s (iso x)).comp (iso : «expr →L[ ] » E 𝕜 F) :=\n  by\n  by_cases h : differentiable_within_at 𝕜 f s (iso x)\n  · exact (iso.comp_right_has_fderiv_within_at_iff.2 h.has_fderiv_within_at).fderiv_within hxs\n  · have : ¬differentiable_within_at 𝕜 (f ∘ iso) («expr ⁻¹' » iso s) x :=\n      by\n      intro h'\n      exact h (iso.comp_right_differentiable_within_at_iff.1 h')\n    rw [fderiv_within_zero_of_not_differentiable_within_at h, fderiv_within_zero_of_not_differentiable_within_at this,\n      ContinuousLinearMap.zero_comp]\n#align comp_right_fderiv_within comp_right_fderiv_within\n\n",
 "comp_right_fderiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\ntheorem comp_right_fderiv {f : F → G} {x : E} :\n    fderiv 𝕜 (f ∘ iso) x = (fderiv 𝕜 f (iso x)).comp (iso : «expr →L[ ] » E 𝕜 F) :=\n  by\n  rw [← fderiv_within_univ, ← fderiv_within_univ, ← iso.comp_right_fderiv_within, preimage_univ]\n  exact unique_diff_within_at_univ\n#align comp_right_fderiv comp_right_fderiv\n\n",
 "comp_right_differentiable_within_at_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem comp_right_differentiable_within_at_iff {f : F → G} {s : Set F} {x : E} :\n    differentiable_within_at 𝕜 (f ∘ iso) («expr ⁻¹' » iso s) x ↔ differentiable_within_at 𝕜 f s (iso x) :=\n  by\n  refine' ⟨fun H => _, fun H => H.comp x iso.differentiable_within_at (maps_to_preimage _ s)⟩\n  have : differentiable_within_at 𝕜 ((f ∘ iso) ∘ iso.symm) s (iso x) :=\n    by\n    rw [← iso.symm_apply_apply x] at H\n    apply H.comp (iso x) iso.symm.differentiable_within_at\n    intro y hy\n    simpa only [mem_preimage, apply_symm_apply] using hy\n  rwa [function.comp.assoc, iso.self_comp_symm] at this\n#align comp_right_differentiable_within_at_iff comp_right_differentiable_within_at_iff\n\n",
 "comp_right_differentiable_on_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem comp_right_differentiable_on_iff {f : F → G} {s : Set F} :\n    differentiable_on 𝕜 (f ∘ iso) («expr ⁻¹' » iso s) ↔ differentiable_on 𝕜 f s :=\n  by\n  refine' ⟨fun H y hy => _, fun H y hy => iso.comp_right_differentiable_within_at_iff.2 (H _ hy)⟩\n  rw [← iso.apply_symm_apply y, ← comp_right_differentiable_within_at_iff]\n  apply H\n  simpa only [mem_preimage, apply_symm_apply] using hy\n#align comp_right_differentiable_on_iff comp_right_differentiable_on_iff\n\n",
 "comp_right_differentiable_iff":
 "theorem comp_right_differentiable_iff {f : F → G} : differentiable 𝕜 (f ∘ iso) ↔ differentiable 𝕜 f := by\n  simp only [← differentiable_on_univ, ← iso.comp_right_differentiable_on_iff, preimage_univ]\n#align comp_right_differentiable_iff comp_right_differentiable_iff\n\n",
 "comp_right_differentiable_at_iff":
 "theorem comp_right_differentiable_at_iff {f : F → G} {x : E} :\n    differentiable_at 𝕜 (f ∘ iso) x ↔ differentiable_at 𝕜 f (iso x) := by\n  simp only [← differentiable_within_at_univ, ← iso.comp_right_differentiable_within_at_iff, preimage_univ]\n#align comp_right_differentiable_at_iff comp_right_differentiable_at_iff\n\n",
 "comp_of_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\ntheorem has_fderiv_within_at.comp_of_mem {g : F → G} {g' : «expr →L[ ] » F 𝕜 G} {t : Set F}\n    (hg : has_fderiv_within_at g g' t (f x)) (hf : has_fderiv_within_at f f' s x)\n    (hst : Tendsto f (nhds_within s x) (nhds_within t (f x))) : has_fderiv_within_at (g ∘ f) (g'.comp f') s x :=\n  has_fderiv_at_filter.comp x hg hf hst\n#align has_fderiv_within_at.comp_of_mem has_fderiv_within_at.comp_of_mem\n\n",
 "comp_has_strict_fderiv_at_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\ntheorem comp_has_strict_fderiv_at_iff {f : G → E} {x : G} {f' : «expr →L[ ] » G 𝕜 E} :\n    has_strict_fderiv_at (iso ∘ f) ((iso : «expr →L[ ] » E 𝕜 F).comp f') x ↔ has_strict_fderiv_at f f' x :=\n  (iso : «expr ≃L[ ] » E 𝕜 F).comp_has_strict_fderiv_at_iff\n#align comp_has_strict_fderiv_at_iff comp_has_strict_fderiv_at_iff\n\n",
 "comp_has_fderiv_within_at_iff'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\ntheorem comp_has_fderiv_within_at_iff' {f : G → E} {s : Set G} {x : G} {f' : «expr →L[ ] » G 𝕜 F} :\n    has_fderiv_within_at (iso ∘ f) f' s x ↔ has_fderiv_within_at f ((iso.symm : «expr →L[ ] » F 𝕜 E).comp f') s x :=\n  (iso : «expr ≃L[ ] » E 𝕜 F).comp_has_fderiv_within_at_iff'\n#align comp_has_fderiv_within_at_iff' comp_has_fderiv_within_at_iff'\n\n",
 "comp_has_fderiv_within_at_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\ntheorem comp_has_fderiv_within_at_iff {f : G → E} {s : Set G} {x : G} {f' : «expr →L[ ] » G 𝕜 E} :\n    has_fderiv_within_at (iso ∘ f) ((iso : «expr →L[ ] » E 𝕜 F).comp f') s x ↔ has_fderiv_within_at f f' s x :=\n  (iso : «expr ≃L[ ] » E 𝕜 F).comp_has_fderiv_within_at_iff\n#align comp_has_fderiv_within_at_iff comp_has_fderiv_within_at_iff\n\n",
 "comp_has_fderiv_within_at":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\ntheorem has_fderiv_at.comp_has_fderiv_within_at {g : F → G} {g' : «expr →L[ ] » F 𝕜 G} (hg : has_fderiv_at g g' (f x))\n    (hf : has_fderiv_within_at f f' s x) : has_fderiv_within_at (g ∘ f) (g'.comp f') s x :=\n  hg.comp x hf hf.continuous_within_at\n#align has_fderiv_at.comp_has_fderiv_within_at has_fderiv_at.comp_has_fderiv_within_at\n\n",
 "comp_has_fderiv_at_iff'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\ntheorem comp_has_fderiv_at_iff' {f : G → E} {x : G} {f' : «expr →L[ ] » G 𝕜 F} :\n    has_fderiv_at (iso ∘ f) f' x ↔ has_fderiv_at f ((iso.symm : «expr →L[ ] » F 𝕜 E).comp f') x :=\n  (iso : «expr ≃L[ ] » E 𝕜 F).comp_has_fderiv_at_iff'\n#align comp_has_fderiv_at_iff' comp_has_fderiv_at_iff'\n\n",
 "comp_has_fderiv_at_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\ntheorem comp_has_fderiv_at_iff {f : G → E} {x : G} {f' : «expr →L[ ] » G 𝕜 E} :\n    has_fderiv_at (iso ∘ f) ((iso : «expr →L[ ] » E 𝕜 F).comp f') x ↔ has_fderiv_at f f' x :=\n  (iso : «expr ≃L[ ] » E 𝕜 F).comp_has_fderiv_at_iff\n#align comp_has_fderiv_at_iff comp_has_fderiv_at_iff\n\n",
 "comp_fderiv_within":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\ntheorem comp_fderiv_within {f : G → E} {s : Set G} {x : G} (hxs : unique_diff_within_at 𝕜 s x) :\n    fderiv_within 𝕜 (iso ∘ f) s x = (iso : «expr →L[ ] » E 𝕜 F).comp (fderiv_within 𝕜 f s x) :=\n  (iso : «expr ≃L[ ] » E 𝕜 F).comp_fderiv_within hxs\n#align comp_fderiv_within comp_fderiv_within\n\n",
 "comp_fderiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\ntheorem comp_fderiv {f : G → E} {x : G} : fderiv 𝕜 (iso ∘ f) x = (iso : «expr →L[ ] » E 𝕜 F).comp (fderiv 𝕜 f x) :=\n  (iso : «expr ≃L[ ] » E 𝕜 F).comp_fderiv\n#align comp_fderiv comp_fderiv\n\n",
 "comp_differentiable_within_at_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃L[ ] » -/\ntheorem comp_differentiable_within_at_iff {f : G → E} {s : Set G} {x : G} :\n    differentiable_within_at 𝕜 (iso ∘ f) s x ↔ differentiable_within_at 𝕜 f s x :=\n  (iso : «expr ≃L[ ] » E 𝕜 F).comp_differentiable_within_at_iff\n#align comp_differentiable_within_at_iff comp_differentiable_within_at_iff\n\n",
 "comp_differentiable_within_at":
 "theorem differentiable_at.comp_differentiable_within_at {g : F → G} (hg : differentiable_at 𝕜 g (f x))\n    (hf : differentiable_within_at 𝕜 f s x) : differentiable_within_at 𝕜 (g ∘ f) s x :=\n  hg.differentiable_within_at.comp x hf (mapsTo_univ _ _)\n#align differentiable_at.comp_differentiable_within_at differentiable_at.comp_differentiable_within_at\n\n",
 "comp_differentiable_on_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃L[ ] » -/\ntheorem comp_differentiable_on_iff {f : G → E} {s : Set G} :\n    differentiable_on 𝕜 (iso ∘ f) s ↔ differentiable_on 𝕜 f s :=\n  (iso : «expr ≃L[ ] » E 𝕜 F).comp_differentiable_on_iff\n#align comp_differentiable_on_iff comp_differentiable_on_iff\n\n",
 "comp_differentiable_on":
 "theorem differentiable.comp_differentiable_on {g : F → G} (hg : differentiable 𝕜 g) (hf : differentiable_on 𝕜 f s) :\n    differentiable_on 𝕜 (g ∘ f) s :=\n  hg.differentiable_on.comp hf (mapsTo_univ _ _)\n#align differentiable.comp_differentiable_on differentiable.comp_differentiable_on\n\n",
 "comp_differentiable_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃L[ ] » -/\ntheorem comp_differentiable_iff {f : G → E} : differentiable 𝕜 (iso ∘ f) ↔ differentiable 𝕜 f :=\n  (iso : «expr ≃L[ ] » E 𝕜 F).comp_differentiable_iff\n#align comp_differentiable_iff comp_differentiable_iff\n\n",
 "comp_differentiable_at_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃L[ ] » -/\ntheorem comp_differentiable_at_iff {f : G → E} {x : G} : differentiable_at 𝕜 (iso ∘ f) x ↔ differentiable_at 𝕜 f x :=\n  (iso : «expr ≃L[ ] » E 𝕜 F).comp_differentiable_at_iff\n#align comp_differentiable_at_iff comp_differentiable_at_iff\n\n",
 "comp'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem differentiable_within_at.comp' {g : F → G} {t : Set F} (hg : differentiable_within_at 𝕜 g t (f x))\n    (hf : differentiable_within_at 𝕜 f s x) : differentiable_within_at 𝕜 (g ∘ f) (s ∩ «expr ⁻¹' » f t) x :=\n  hg.comp x (hf.mono (inter_subset_left _ _)) (inter_subset_right _ _)\n#align differentiable_within_at.comp' differentiable_within_at.comp'\n\n",
 "comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/-- The chain rule for derivatives in the sense of strict differentiability. -/\nprotected theorem has_strict_fderiv_at.comp {g : F → G} {g' : «expr →L[ ] » F 𝕜 G}\n    (hg : has_strict_fderiv_at g g' (f x)) (hf : has_strict_fderiv_at f f' x) :\n    has_strict_fderiv_at (fun x => g (f x)) (g'.comp f') x :=\n  ((hg.comp_tendsto (hf.continuous_at.prod_map' hf.continuous_at)).trans_is_O hf.is_O_sub).triangle <| by\n    simpa only [g'.map_sub, f'.coe_comp'] using (g'.is_O_comp _ _).trans_is_o hf\n#align has_strict_fderiv_at.comp has_strict_fderiv_at.comp\n\n",
 "clm_comp":
 "theorem differentiable.clm_comp (hc : differentiable 𝕜 c) (hd : differentiable 𝕜 d) :\n    differentiable 𝕜 fun y => (c y).comp (d y) := fun x => (hc x).clm_comp (hd x)\n#align differentiable.clm_comp differentiable.clm_comp\n\n",
 "clm_apply":
 "theorem differentiable.clm_apply (hc : differentiable 𝕜 c) (hu : differentiable 𝕜 u) :\n    differentiable 𝕜 fun y => (c y) (u y) := fun x => (hc x).clm_apply (hu x)\n#align differentiable.clm_apply differentiable.clm_apply\n\n",
 "antimono":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\ntheorem has_fderiv_within_at.antimono (h : has_fderiv_within_at f f' s x) (hst : s ⊆ t)\n    (hs : unique_diff_within_at 𝕜 s x) (hx : s ∈ nhds_within t x) : has_fderiv_within_at f f' t x :=\n  by\n  have h' : has_fderiv_within_at f _ t x := (h.differentiable_within_at.antimono hst hx).has_fderiv_within_at\n  rwa [hs.eq h (h'.mono hst)]\n#align has_fderiv_within_at.antimono has_fderiv_within_at.antimono\n\n",
 "add_const":
 "theorem differentiable.add_const (hf : differentiable 𝕜 f) (c : F) : differentiable 𝕜 fun y => f y + c := fun x =>\n  (hf x).add_const c\n#align differentiable.add_const differentiable.add_const\n\n",
 "add":
 "@[simp]\ntheorem differentiable.add (hf : differentiable 𝕜 f) (hg : differentiable 𝕜 g) : differentiable 𝕜 fun y => f y + g y :=\n  fun x => (hf x).add (hg x)\n#align differentiable.add differentiable.add\n\n"}