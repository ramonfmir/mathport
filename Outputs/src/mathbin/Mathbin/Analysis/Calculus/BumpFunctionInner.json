{"zero_of_nonpos":
 "theorem zero_of_nonpos (h : x ≤ 0) : smooth_transition x = 0 := by rw [smooth_transition, zero_of_nonpos h, zero_div]\n#align zero_of_nonpos zero_of_nonpos\n\n",
 "zero_of_le_dist":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem zero_of_le_dist (hx : f.R ≤ dist x c) : f x = 0 :=\n  by\n  rw [dist_eq_norm] at hx\n  suffices H : «expr • » f.r⁻¹ (x - c) ∉ support ((some_cont_diff_bump_base E).to_fun (f.R / f.r))\n  · simpa only [mem_support, Classical.not_not] using H\n  rw [cont_diff_bump_base.support _ _ f.one_lt_R_div_r]\n  simp [norm_smul, norm_eq_abs, abs_inv, abs_of_nonneg f.r_pos.le, ← div_eq_inv_mul]\n  exact div_le_div_of_le f.r_pos.le hx\n#align zero_of_le_dist zero_of_le_dist\n\n",
 "zero":
 "@[simp]\nprotected theorem zero : smooth_transition 0 = 0 :=\n  zero_of_nonpos le_rfl\n#align zero zero\n\n",
 "tsupport_normed_eq":
 "theorem tsupport_normed_eq : tsupport (f.normed μ) = Metric.closedBall c f.R := by\n  simp_rw [tsupport, f.support_normed_eq, closure_ball _ f.R_pos.ne']\n#align tsupport_normed_eq tsupport_normed_eq\n\n",
 "tsupport_eq":
 "theorem tsupport_eq : tsupport f = closedBall c f.R := by simp_rw [tsupport, f.support_eq, closure_ball _ f.R_pos.ne']\n#align tsupport_eq tsupport_eq\n\n",
 "tendsto_support_normed_small_sets":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem tendsto_support_normed_small_sets {ι} {φ : ι → cont_diff_bump c} {l : Filter ι}\n    (hφ : Tendsto (fun i => (φ i).R) l ((nhds) 0)) :\n    Tendsto (fun i => support fun x => (φ i).normed μ x) l ((nhds) c).small_sets :=\n  by\n  simp_rw [NormedAddCommGroup.tendsto_nhds_zero, Real.norm_eq_abs, abs_eq_self.mpr (φ _).R_pos.le] at hφ\n  rw [tendsto_small_sets_iff]\n  intro t ht\n  rcases metric.mem_nhds_iff.mp ht with ⟨ε, hε, ht⟩\n  refine' (hφ ε hε).mono fun i hi => subset_trans _ ht\n  simp_rw [(φ i).support_normed_eq]\n  exact ball_subset_ball hi.le\n#align tendsto_support_normed_small_sets tendsto_support_normed_small_sets\n\n",
 "support_normed_eq":
 "theorem support_normed_eq : support (f.normed μ) = Metric.ball c f.R := by\n  simp_rw [cont_diff_bump.normed, support_div, f.support_eq, support_const f.integral_pos.ne', inter_univ]\n#align support_normed_eq support_normed_eq\n\n",
 "support_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem support_eq : support (f : E → exprℝ) = Metric.ball c f.R :=\n  by\n  ext x\n  suffices f x ≠ 0 ↔ dist x c < f.R by simpa [mem_support]\n  cases' lt_or_le (dist x c) f.R with hx hx\n  · simp only [hx, (f.pos_of_mem_ball hx).ne', ne.def, not_false_iff]\n  · simp only [hx.not_lt, f.zero_of_le_dist hx, ne.def, eq_self_iff_true, not_true]\n#align support_eq support_eq\n\n",
 "sub":
 "protected theorem sub (x : E) : f (c - x) = f (c + x) := by simp [f.def, cont_diff_bump_base.symmetric]\n#align sub sub\n\n",
 "pos_of_pos":
 "theorem pos_of_pos (h : 0 < x) : 0 < smooth_transition x :=\n  div_pos (exp_neg_inv_glue.pos_of_pos h) (pos_denom x)\n#align pos_of_pos pos_of_pos\n\n",
 "pos_of_mem_ball":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem pos_of_mem_ball (hx : x ∈ ball c f.R) : 0 < f x :=\n  by\n  refine' lt_iff_le_and_ne.2 ⟨f.nonneg, ne.symm _⟩\n  change «expr • » f.r⁻¹ (x - c) ∈ support ((some_cont_diff_bump_base E).to_fun (f.R / f.r))\n  rw [cont_diff_bump_base.support _ _ f.one_lt_R_div_r]\n  simp only [dist_eq_norm, mem_ball] at hx\n  simpa only [norm_smul, mem_ball_zero_iff, norm_eq_abs, abs_inv, abs_of_nonneg f.r_pos.le, ← div_eq_inv_mul] using\n    (div_lt_div_right f.r_pos).2 hx\n#align pos_of_mem_ball pos_of_mem_ball\n\n",
 "pos_denom":
 "theorem pos_denom (x) : 0 < exp_neg_inv_glue x + exp_neg_inv_glue (1 - x) :=\n  (zero_lt_one.lt_or_lt x).elim (fun hx => add_pos_of_pos_of_nonneg (pos_of_pos hx) (nonneg _)) fun hx =>\n    add_pos_of_nonneg_of_pos (nonneg _) (pos_of_pos <| sub_pos.2 hx)\n#align pos_denom pos_denom\n\n",
 "one_of_one_le":
 "theorem one_of_one_le (h : 1 ≤ x) : smooth_transition x = 1 :=\n  (div_eq_one_iff_eq <| (pos_denom x).ne').2 <| by rw [zero_of_nonpos (sub_nonpos.2 h), add_zero]\n#align one_of_one_le one_of_one_le\n\n",
 "one_of_mem_closed_ball":
 "theorem one_of_mem_closed_ball (hx : x ∈ closedBall c f.r) : f x = 1 :=\n  by\n  apply cont_diff_bump_base.eq_one _ _ f.one_lt_R_div_r\n  simpa only [norm_smul, norm_eq_abs, abs_inv, abs_of_nonneg f.r_pos.le, ← div_eq_inv_mul, div_le_one f.r_pos] using\n    mem_closedBall_iff_norm.1 hx\n#align one_of_mem_closed_ball one_of_mem_closed_ball\n\n",
 "one_lt_R_div_r":
 "theorem one_lt_R_div_r {c : E} (f : cont_diff_bump c) : 1 < f.R / f.r :=\n  by\n  rw [one_lt_div f.r_pos]\n  exact f.r_lt_R\n#align one_lt_R_div_r one_lt_R_div_r\n\n",
 "one":
 "@[simp]\nprotected theorem one : smooth_transition 1 = 1 :=\n  one_of_one_le le_rfl\n#align one one\n\n",
 "normed_sub":
 "theorem normed_sub (x : E) : f.normed μ (c - x) = f.normed μ (c + x) := by simp_rw [f.normed_def, f.sub]\n#align normed_sub normed_sub\n\n",
 "normed_neg":
 "theorem normed_neg (f : cont_diff_bump (0 : E)) (x : E) : f.normed μ (-x) = f.normed μ x := by\n  simp_rw [f.normed_def, f.neg]\n#align normed_neg normed_neg\n\n",
 "normed_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ » -/\ntheorem normed_def {μ : measure E} (x : E) :\n    f.normed μ x =\n      f x /\n        «expr∫ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ »\" (f x) μ :=\n  rfl\n#align normed_def normed_def\n\n",
 "nonneg_normed":
 "theorem nonneg_normed (x : E) : 0 ≤ f.normed μ x :=\n  div_nonneg f.nonneg <| integral_nonneg f.nonneg'\n#align nonneg_normed nonneg_normed\n\n",
 "nonneg'":
 "/-- A version of `cont_diff_bump.nonneg` with `x` explicit -/\ntheorem nonneg' (x : E) : 0 ≤ f x :=\n  f.nonneg\n#align nonneg' nonneg'\n\n",
 "nonneg":
 "theorem nonneg : 0 ≤ f x :=\n  (cont_diff_bump_base.mem_Icc (some_cont_diff_bump_base E) _ _).1\n#align nonneg nonneg\n\n",
 "neg":
 "protected theorem neg (f : cont_diff_bump (0 : E)) (x : E) : f (-x) = f x := by simp_rw [← zero_sub, f.sub, zero_add]\n#align neg neg\n\n",
 "lt_one_of_lt_one":
 "theorem lt_one_of_lt_one (h : x < 1) : smooth_transition x < 1 :=\n  (div_lt_one <| pos_denom x).2 <| lt_add_of_pos_right _ <| pos_of_pos <| sub_pos.2 h\n#align lt_one_of_lt_one lt_one_of_lt_one\n\n",
 "le_one":
 "theorem le_one : f x ≤ 1 :=\n  (cont_diff_bump_base.mem_Icc (some_cont_diff_bump_base E) _ _).2\n#align le_one le_one\n\n",
 "integral_pos":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ » -/\ntheorem integral_pos :\n    0 < «expr∫ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ »\" (f x) μ :=\n  by\n  refine' (integral_pos_iff_support_of_nonneg f.nonneg' f.integrable).mpr _\n  rw [f.support_eq]\n  refine' is_open_ball.measure_pos _ (nonempty_ball.mpr f.R_pos)\n#align integral_pos integral_pos\n\n",
 "integral_normed_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem integral_normed_smul [CompleteSpace X] (z : X) :\n    «expr∫ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ »\"\n        («expr • » (f.normed μ x) z) μ =\n      z :=\n  by simp_rw [integral_smul_const, f.integral_normed, one_smul]\n#align integral_normed_smul integral_normed_smul\n\n",
 "integral_normed":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ » -/\ntheorem integral_normed :\n    «expr∫ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ »\" (f.normed μ x)\n        μ =\n      1 :=\n  by\n  simp_rw [cont_diff_bump.normed, div_eq_mul_inv, mul_comm (f _), ← smul_eq_mul, integral_smul]\n  exact inv_mul_cancel f.integral_pos.ne'\n#align integral_normed integral_normed\n\n",
 "integrable_normed":
 "protected theorem integrable_normed : integrable (f.normed μ) μ :=\n  f.integrable.div_const _\n#align integrable_normed integrable_normed\n\n",
 "integrable":
 "protected theorem integrable : integrable f μ :=\n  f.continuous.integrable_of_has_compact_support f.has_compact_support\n#align integrable integrable\n\n",
 "has_compact_support_normed":
 "theorem has_compact_support_normed : HasCompactSupport (f.normed μ) := by\n  simp_rw [HasCompactSupport, f.tsupport_normed_eq, is_compact_closed_ball]\n#align has_compact_support_normed has_compact_support_normed\n\n",
 "f_aux_zero_eq":
 "/-\nCopyright (c) 2020 Sébastien Gouëzel. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Sébastien Gouëzel, Floris van Doorn\n-/\n/-- The `0`-th auxiliary function `f_aux 0` coincides with `exp_neg_inv_glue`, by definition. -/\ntheorem f_aux_zero_eq : f_aux 0 = exp_neg_inv_glue := by\n  ext x\n  by_cases h : x ≤ 0\n  · simp [exp_neg_inv_glue, f_aux, h]\n  · simp [h, exp_neg_inv_glue, f_aux, ne_of_gt (not_le.1 h), P_aux]\n#align f_aux_zero_eq f_aux_zero_eq\n\n",
 "f_aux_limit":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.gt -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.gt -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.gt -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- To get differentiability at `0` of the auxiliary functions, we need to know that their limit\nis `0`, to be able to apply general differentiability extension theorems. This limit is checked in\nthis lemma. -/\ntheorem f_aux_limit (n : ℕ) :\n    Tendsto (fun x => (P_aux n).eval x * exp (-x⁻¹) / x ^ (2 * n)) (nhds_within.gt 0) ((nhds) 0) :=\n  by\n  have A : tendsto (fun x => (P_aux n).eval x) (nhds_within.gt 0) ((nhds) ((P_aux n).eval 0)) :=\n    (P_aux n).continuous_within_at\n  have B : tendsto (fun x => exp (-x⁻¹) / x ^ (2 * n)) (nhds_within.gt 0) ((nhds) 0) :=\n    by\n    convert(tendsto_pow_mul_exp_neg_at_top_nhds_0 (2 * n)).comp tendsto_inv_zero_atTop\n    ext x\n    field_simp\n  convert A.mul B <;> simp [mul_div_assoc]\n#align f_aux_limit f_aux_limit\n\n",
 "f_aux_iterated_deriv":
 "/-- The successive derivatives of the auxiliary function `f_aux 0` are the\nfunctions `f_aux n`, by induction. -/\ntheorem f_aux_iterated_deriv (n : ℕ) : iterated_deriv n (f_aux 0) = f_aux n :=\n  by\n  induction' n with n IH\n  · simp\n  · simp [iterated_deriv_succ, IH]\n    ext x\n    exact (f_aux_has_deriv_at n x).deriv\n#align f_aux_iterated_deriv f_aux_iterated_deriv\n\n",
 "f_aux_has_deriv_at":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- At every point, the auxiliary function `f_aux n` has a derivative which is\nequal to `f_aux (n+1)`. -/\ntheorem f_aux_has_deriv_at (n : ℕ) (x : exprℝ) : has_deriv_at (f_aux n) (f_aux (n + 1) x) x :=\n  by\n  -- check separately the result for `x < 0`, where it is trivial, for `x > 0`, where it is done\n  -- in `f_aux_deriv_pos`, and for `x = 0`, done in\n  -- `f_aux_deriv_zero`.\n  rcases lt_trichotomy x 0 with (hx | hx | hx)\n  · have : f_aux (n + 1) x = 0 := by simp [f_aux, le_of_lt hx]\n    rw [this]\n    apply (has_deriv_at_const x (0 : exprℝ)).congr_of_eventually_eq\n    filter_upwards [gt_mem_nhds hx]with _ hy\n    simp [f_aux, hy.le]\n  · have : f_aux (n + 1) 0 = 0 := by simp [f_aux, le_refl]\n    rw [hx, this]\n    exact f_aux_deriv_zero n\n  · have : f_aux (n + 1) x = (P_aux (n + 1)).eval x * exp (-x⁻¹) / x ^ (2 * (n + 1)) := by simp [f_aux, not_le_of_gt hx]\n    rw [this]\n    exact f_aux_deriv_pos n x hx\n#align f_aux_has_deriv_at f_aux_has_deriv_at\n\n",
 "f_aux_deriv_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- Deduce from the limiting behavior at `0` of its derivative and general differentiability\nextension theorems that the auxiliary function `f_aux n` is differentiable at `0`,\nwith derivative `0`. -/\ntheorem f_aux_deriv_zero (n : ℕ) : has_deriv_at (f_aux n) 0 0 :=\n  by\n  -- we check separately differentiability on the left and on the right\n  have A : has_deriv_within_at (f_aux n) (0 : exprℝ) (Iic 0) 0 :=\n    by\n    apply (has_deriv_at_const (0 : exprℝ) (0 : exprℝ)).has_deriv_within_at.congr\n    · intro y hy\n      simp at hy\n      simp [f_aux, hy]\n    · simp [f_aux, le_refl]\n  have B : has_deriv_within_at (f_aux n) (0 : exprℝ) (Ici 0) 0 :=\n    by\n    have diff : differentiable_on (exprℝ) (f_aux n) (Ioi 0) := fun x hx =>\n      (f_aux_deriv_pos n x hx).differentiable_at.differentiable_within_at\n    -- next line is the nontrivial bit of this proof, appealing to differentiability\n    -- extension results.\n    apply has_deriv_at_interval_left_endpoint_of_tendsto_deriv diff _ self_mem_nhdsWithin\n    · refine' (f_aux_limit (n + 1)).congr' _\n      apply mem_of_superset self_mem_nhdsWithin fun x hx => _\n      simp [(f_aux_deriv_pos n x hx).deriv]\n    · have : f_aux n 0 = 0 := by simp [f_aux, le_refl]\n      simp only [ContinuousWithinAt, this]\n      refine' (f_aux_limit n).congr' _\n      apply mem_of_superset self_mem_nhdsWithin fun x hx => _\n      have : ¬x ≤ 0 := by simpa using hx\n      simp [f_aux, this]\n  simpa using A.union B\n#align f_aux_deriv_zero f_aux_deriv_zero\n\n",
 "f_aux_deriv_pos":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- For positive values, the derivative of the `n`-th auxiliary function `f_aux n`\nis the `n+1`-th auxiliary function. -/\ntheorem f_aux_deriv_pos (n : ℕ) (x : exprℝ) (hx : 0 < x) :\n    has_deriv_at (f_aux n) ((P_aux (n + 1)).eval x * exp (-x⁻¹) / x ^ (2 * (n + 1))) x :=\n  by\n  apply (f_aux_deriv n x (ne_of_gt hx)).congr_of_eventually_eq\n  filter_upwards [lt_mem_nhds hx]with _ hy\n  simp [f_aux, hy.not_le]\n#align f_aux_deriv_pos f_aux_deriv_pos\n\n",
 "f_aux_deriv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- For positive values, the derivative of the `n`-th auxiliary function `f_aux n`\n(given in this statement in unfolded form) is the `n+1`-th auxiliary function, since\nthe polynomial `P_aux (n+1)` was chosen precisely to ensure this. -/\ntheorem f_aux_deriv (n : ℕ) (x : exprℝ) (hx : x ≠ 0) :\n    has_deriv_at (fun x => (P_aux n).eval x * exp (-x⁻¹) / x ^ (2 * n))\n      ((P_aux (n + 1)).eval x * exp (-x⁻¹) / x ^ (2 * (n + 1))) x :=\n  by\n  simp only [P_aux, eval_add, eval_sub, eval_mul, eval_pow, eval_X, eval_C, eval_one]\n  convert(((P_aux n).has_deriv_at x).mul ((has_deriv_at_exp _).comp x (has_deriv_at_inv hx).neg)).div\n      (has_deriv_at_pow (2 * n) x) (pow_ne_zero _ hx) using\n    1\n  rw [div_eq_div_iff]\n  · have := pow_ne_zero 2 hx\n    field_simp only\n    cases n\n    · simp only [MulZeroClass.mul_zero, Nat.cast_zero, mul_one]\n      ring\n    · rw [(id rfl : 2 * n.succ - 1 = 2 * n + 1)]\n      ring\n  all_goals apply_rules [pow_ne_zero]\n#align f_aux_deriv f_aux_deriv\n\n",
 "eventually_eq_one_of_mem_ball":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem eventually_eq_one_of_mem_ball (h : x ∈ ball c f.r) : «expr =ᶠ[ ] » f ((nhds) x) 1 :=\n  ((isOpen_lt (continuous_id.dist continuous_const) continuous_const).eventually_mem h).mono fun z hz =>\n    f.one_of_mem_closed_ball (le_of_lt hz)\n#align eventually_eq_one_of_mem_ball eventually_eq_one_of_mem_ball\n\n",
 "eventually_eq_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem eventually_eq_one : «expr =ᶠ[ ] » f ((nhds) c) 1 :=\n  f.eventually_eq_one_of_mem_ball (mem_ball_self f.r_pos)\n#align eventually_eq_one eventually_eq_one\n\n",
 "def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\nprotected theorem def (x : E) : f x = (some_cont_diff_bump_base E).to_fun (f.R / f.r) («expr • » f.r⁻¹ (x - c)) :=\n  rfl\n#align def def\n\n",
 "continuous_normed":
 "theorem continuous_normed : Continuous (f.normed μ) :=\n  f.continuous.div_const _\n#align continuous_normed continuous_normed\n\n",
 "cont_diff_within_at":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\nprotected theorem cont_diff_within_at {s : Set E} : cont_diff_within_at (exprℝ) n f s x :=\n  f.cont_diff_at.cont_diff_within_at\n#align cont_diff_within_at cont_diff_within_at\n\n",
 "cont_diff_normed":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ∞» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem cont_diff_normed {n : «exprℕ∞»} : cont_diff (exprℝ) n (f.normed μ) :=\n  f.cont_diff.div_const _\n#align cont_diff_normed cont_diff_normed\n\n",
 "cont_diff_bump":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem _root_.cont_diff.cont_diff_bump {c g : X → E} {f : ∀ x, cont_diff_bump (c x)} (hc : cont_diff (exprℝ) n c)\n    (hr : cont_diff (exprℝ) n fun x => (f x).r) (hR : cont_diff (exprℝ) n fun x => (f x).R)\n    (hg : cont_diff (exprℝ) n g) : cont_diff (exprℝ) n fun x => f x (g x) :=\n  by\n  rw [cont_diff_iff_cont_diff_at] at *\n  exact fun x => (hc x).cont_diff_bump (hr x) (hR x) (hg x)\n#align cont_diff.cont_diff_bump cont_diff.cont_diff_bump\n\n",
 "cont_diff_at":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\nprotected theorem cont_diff_at : cont_diff_at (exprℝ) n f x :=\n  f.cont_diff.cont_diff_at\n#align cont_diff_at cont_diff_at\n\n",
 "cont_diff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\nprotected theorem cont_diff : cont_diff (exprℝ) n f :=\n  cont_diff_const.cont_diff_bump cont_diff_const cont_diff_const cont_diff_id\n#align cont_diff cont_diff\n\n",
 "R_pos":
 "theorem R_pos {c : E} (f : cont_diff_bump c) : 0 < f.R :=\n  f.r_pos.trans f.r_lt_R\n#align R_pos R_pos\n\n",
 "HasCompactSupport":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n#print HasCompactSupport /-\nprotected theorem HasCompactSupport [FiniteDimensional (exprℝ) E] : HasCompactSupport f := by\n  simp_rw [HasCompactSupport, f.tsupport_eq, is_compact_closed_ball]\n#align has_compact_support HasCompactSupport\n-/\n\n",
 "Continuous":
 "#print Continuous /-\nprotected theorem Continuous : Continuous f :=\n  cont_diff_zero.mp f.cont_diff\n#align continuous Continuous\n-/\n\n"}