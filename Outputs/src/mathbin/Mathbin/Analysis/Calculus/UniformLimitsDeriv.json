{"uniform_cauchy_seq_on_filter_of_fderiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-\nCopyright (c) 2022 Kevin H. Wilson. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Kevin H. Wilson\n-/\n/-- If a sequence of functions real or complex functions are eventually differentiable on a\nneighborhood of `x`, they are Cauchy _at_ `x`, and their derivatives\nare a uniform Cauchy sequence in a neighborhood of `x`, then the functions form a uniform Cauchy\nsequence in a neighborhood of `x`. -/\ntheorem uniform_cauchy_seq_on_filter_of_fderiv (hf' : UniformCauchySeqOnFilter f' l ((nhds) x))\n    (hf :\n      Â«exprâˆ€á¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â»\"\n        (filter.prod l ((nhds) x)) (has_fderiv_at (f n.1) (f' n.1 n.2) n.2))\n    (hfg : Cauchy (map (fun n => f n x) l)) : UniformCauchySeqOnFilter f l ((nhds) x) :=\n  by\n  let : NormedSpace (exprâ„) E\n  exact NormedSpace.restrictScalars (exprâ„) ğ•œ _\n  rw [SeminormedAddGroup.uniformCauchySeqOnFilter_iff_tendstoUniformlyOnFilter_zero] at hf'âŠ¢\n  suffices\n    TendstoUniformlyOnFilter (fun (n : Î¹ Ã— Î¹) (z : E) => f n.1 z - f n.2 z - (f n.1 x - f n.2 x)) 0 (filter.prod l l)\n        ((nhds) x) âˆ§\n      TendstoUniformlyOnFilter (fun (n : Î¹ Ã— Î¹) (z : E) => f n.1 x - f n.2 x) 0 (filter.prod l l) ((nhds) x)\n    by\n    have := this.1.add this.2\n    rw [add_zero] at this\n    exact this.congr (by simp)\n  constructor\n  Â· -- This inequality follows from the mean value theorem. To apply it, we will need to shrink our\n    -- neighborhood to small enough ball\n    rw [Metric.tendstoUniformlyOnFilter_iff] at hf'âŠ¢\n    intro Îµ hÎµ\n    have := (tendsto_swap4_prod.eventually (hf.prod_mk hf)).diag_of_prod_right\n    obtain âŸ¨a, b, c, d, eâŸ© := eventually_prod_iff.1 ((hf' Îµ hÎµ).and this)\n    obtain âŸ¨R, hR, hR'âŸ© := metric.nhds_basis_ball.eventually_iff.mp d\n    let r := min 1 R\n    have hr : 0 < r := by simp [hR]\n    have hr' : âˆ€ â¦ƒy : Eâ¦„, y âˆˆ Metric.ball x r â†’ c y := fun y hy =>\n      hR' (lt_of_lt_of_le (metric.mem_ball.mp hy) (min_le_right _ _))\n    have hxy : âˆ€ y : E, y âˆˆ Metric.ball x r â†’ Â«exprâ€– â€–Â» (y - x) < 1 :=\n      by\n      intro y hy\n      rw [Metric.mem_ball, dist_eq_norm] at hy\n      exact lt_of_lt_of_le hy (min_le_left _ _)\n    have hxyÎµ : âˆ€ y : E, y âˆˆ Metric.ball x r â†’ Îµ * Â«exprâ€– â€–Â» (y - x) < Îµ :=\n      by\n      intro y hy\n      exact (mul_lt_iff_lt_one_right hÎµ.lt).mpr (hxy y hy)\n    -- With a small ball in hand, apply the mean value theorem\n    refine'\n      eventually_prod_iff.mpr\n        âŸ¨_, b, fun e : E => Metric.ball x r e, eventually_mem_set.mpr (metric.nhds_basis_ball.mem_of_mem hr),\n          fun n hn y hy => _âŸ©\n    simp only [Pi.zero_apply, dist_zero_left] at eâŠ¢\n    refine' lt_of_le_of_lt _ (hxyÎµ y hy)\n    exact\n      convex.norm_image_sub_le_of_norm_has_fderiv_within_le\n        (fun y hy => ((e hn (hr' hy)).2.1.sub (e hn (hr' hy)).2.2).has_fderiv_within_at)\n        (fun y hy => (e hn (hr' hy)).1.le) (convex_ball x r) (Metric.mem_ball_self hr) hy\n  Â· -- This is just `hfg` run through `eventually_prod_iff`\n    refine' metric.tendsto_uniformly_on_filter_iff.mpr fun Îµ hÎµ => _\n    obtain âŸ¨t, ht, ht'âŸ© := (metric.cauchy_iff.mp hfg).2 Îµ hÎµ\n    exact\n      eventually_prod_iff.mpr\n        âŸ¨fun n : Î¹ Ã— Î¹ => f n.1 x âˆˆ t âˆ§ f n.2 x âˆˆ t,\n          eventually_prod_iff.mpr âŸ¨_, ht, _, ht, fun n hn n' hn' => âŸ¨hn, hn'âŸ©âŸ©, fun y => True, by simp, fun n hn y hy =>\n          by simpa [norm_sub_rev, dist_eq_norm] using ht' _ hn.1 _ hn.2âŸ©\n#align uniform_cauchy_seq_on_filter_of_fderiv uniform_cauchy_seq_on_filter_of_fderiv\n\n",
 "uniform_cauchy_seq_on_filter_of_deriv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem uniform_cauchy_seq_on_filter_of_deriv (hf' : UniformCauchySeqOnFilter f' l ((nhds) x))\n    (hf :\n      Â«exprâˆ€á¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â»\"\n        (filter.prod l ((nhds) x)) (has_deriv_at (f n.1) (f' n.1 n.2) n.2))\n    (hfg : Cauchy (map (fun n => f n x) l)) : UniformCauchySeqOnFilter f l ((nhds) x) :=\n  by\n  simp_rw [has_deriv_at_iff_has_fderiv_at] at hf\n  exact uniform_cauchy_seq_on_filter_of_fderiv hf'.one_smul_right hf hfg\n#align uniform_cauchy_seq_on_filter_of_deriv uniform_cauchy_seq_on_filter_of_deriv\n\n",
 "uniform_cauchy_seq_on_ball_of_fderiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/-- A variant of the second fundamental theorem of calculus (FTC-2): If a sequence of functions\nbetween real or complex normed spaces are differentiable on a ball centered at `x`, they\nform a Cauchy sequence _at_ `x`, and their derivatives are Cauchy uniformly on the ball, then the\nfunctions form a uniform Cauchy sequence on the ball.\n\nNOTE: The fact that we work on a ball is typically all that is necessary to work with power series\nand Dirichlet series (our primary use case). However, this can be generalized by replacing the ball\nwith any connected, bounded, open set and replacing uniform convergence with local uniform\nconvergence. See `cauchy_map_of_uniform_cauchy_seq_on_fderiv`.\n-/\ntheorem uniform_cauchy_seq_on_ball_of_fderiv {r : exprâ„} (hf' : UniformCauchySeqOn f' l (Metric.ball x r))\n    (hf : âˆ€ n : Î¹, âˆ€ y : E, y âˆˆ Metric.ball x r â†’ has_fderiv_at (f n) (f' n y) y)\n    (hfg : Cauchy (map (fun n => f n x) l)) : UniformCauchySeqOn f l (Metric.ball x r) :=\n  by\n  let : NormedSpace (exprâ„) E\n  exact NormedSpace.restrictScalars (exprâ„) ğ•œ _\n  have : ne_bot l := (cauchy_map_iff.1 hfg).1\n  rcases le_or_lt r 0 with (hr | hr)\n  Â·\n    simp only [Metric.ball_eq_empty.2 hr, UniformCauchySeqOn, Set.mem_empty_iff_false, IsEmpty.forall_iff,\n      eventually_const, imp_true_iff]\n  rw [SeminormedAddGroup.uniformCauchySeqOn_iff_tendstoUniformlyOn_zero] at hf'âŠ¢\n  suffices\n    TendstoUniformlyOn (fun (n : Î¹ Ã— Î¹) (z : E) => f n.1 z - f n.2 z - (f n.1 x - f n.2 x)) 0 (filter.prod l l)\n        (Metric.ball x r) âˆ§\n      TendstoUniformlyOn (fun (n : Î¹ Ã— Î¹) (z : E) => f n.1 x - f n.2 x) 0 (filter.prod l l) (Metric.ball x r)\n    by\n    have := this.1.add this.2\n    rw [add_zero] at this\n    refine' this.congr _\n    apply eventually_of_forall\n    intro n z hz\n    simp\n  constructor\n  Â· -- This inequality follows from the mean value theorem\n    rw [Metric.tendstoUniformlyOn_iff] at hf'âŠ¢\n    intro Îµ hÎµ\n    obtain âŸ¨q, hqpos, hqâŸ© : âˆƒ q : exprâ„, 0 < q âˆ§ q * r < Îµ :=\n      by\n      simp_rw [mul_comm]\n      exact exists_pos_mul_lt hÎµ.lt r\n    apply (hf' q hqpos.gt).mono\n    intro n hn y hy\n    simp_rw [dist_eq_norm, Pi.zero_apply, zero_sub, norm_neg] at hnâŠ¢\n    have mvt :=\n      convex.norm_image_sub_le_of_norm_has_fderiv_within_le\n        (fun z hz => ((hf n.1 z hz).sub (hf n.2 z hz)).has_fderiv_within_at) (fun z hz => (hn z hz).le)\n        (convex_ball x r) (Metric.mem_ball_self hr) hy\n    refine' lt_of_le_of_lt mvt _\n    have : q * Â«exprâ€– â€–Â» (y - x) < q * r :=\n      mul_lt_mul' rfl.le (by simpa only [dist_eq_norm] using metric.mem_ball.mp hy) (norm_nonneg _) hqpos\n    exact this.trans hq\n  Â· -- This is just `hfg` run through `eventually_prod_iff`\n    refine' metric.tendsto_uniformly_on_iff.mpr fun Îµ hÎµ => _\n    obtain âŸ¨t, ht, ht'âŸ© := (metric.cauchy_iff.mp hfg).2 Îµ hÎµ\n    rw [eventually_prod_iff]\n    refine' âŸ¨fun n => f n x âˆˆ t, ht, fun n => f n x âˆˆ t, ht, _âŸ©\n    intro n hn n' hn' z hz\n    rw [dist_eq_norm, Pi.zero_apply, zero_sub, norm_neg, â† dist_eq_norm]\n    exact ht' _ hn _ hn'\n#align uniform_cauchy_seq_on_ball_of_fderiv uniform_cauchy_seq_on_ball_of_fderiv\n\n",
 "uniform_cauchy_seq_on_ball_of_deriv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\ntheorem uniform_cauchy_seq_on_ball_of_deriv {r : exprâ„} (hf' : UniformCauchySeqOn f' l (Metric.ball x r))\n    (hf : âˆ€ n : Î¹, âˆ€ y : ğ•œ, y âˆˆ Metric.ball x r â†’ has_deriv_at (f n) (f' n y) y)\n    (hfg : Cauchy (map (fun n => f n x) l)) : UniformCauchySeqOn f l (Metric.ball x r) :=\n  by\n  simp_rw [has_deriv_at_iff_has_fderiv_at] at hf\n  rw [uniformCauchySeqOn_iff_uniformCauchySeqOnFilter] at hf'\n  have hf' : UniformCauchySeqOn (fun n => fun z => (1 : Â«expr â†’L[ ] Â» ğ•œ ğ•œ ğ•œ).smul_right (f' n z)) l (Metric.ball x r) :=\n    by\n    rw [uniformCauchySeqOn_iff_uniformCauchySeqOnFilter]\n    exact hf'.one_smul_right\n  exact uniform_cauchy_seq_on_ball_of_fderiv hf' hf hfg\n#align uniform_cauchy_seq_on_ball_of_deriv uniform_cauchy_seq_on_ball_of_deriv\n\n",
 "one_smul_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/-- If our derivatives converge uniformly, then the FrÃ©chet derivatives converge uniformly -/\ntheorem uniform_cauchy_seq_on_filter.one_smul_right {l' : Filter ğ•œ} (hf' : UniformCauchySeqOnFilter f' l l') :\n    UniformCauchySeqOnFilter (fun n => fun z => (1 : Â«expr â†’L[ ] Â» ğ•œ ğ•œ ğ•œ).smul_right (f' n z)) l l' :=\n  by\n  -- The tricky part of this proof is that operator norms are written in terms of `â‰¤` whereas\n  -- metrics are written in terms of `<`. So we need to shrink `Îµ` utilizing the archimedean\n  -- property of `â„`\n  rw [SeminormedAddGroup.uniformCauchySeqOnFilter_iff_tendstoUniformlyOnFilter_zero,\n    Metric.tendstoUniformlyOnFilter_iff] at hf'âŠ¢\n  intro Îµ hÎµ\n  obtain âŸ¨q, hq, hq'âŸ© := exists_between hÎµ.lt\n  apply (hf' q hq).mono\n  intro n hn\n  refine' lt_of_le_of_lt _ hq'\n  simp only [dist_eq_norm, Pi.zero_apply, zero_sub, norm_neg] at hnâŠ¢\n  refine' continuous_linear_map.op_norm_le_bound _ hq.le _\n  intro z\n  simp only [ContinuousLinearMap.coe_sub', Pi.sub_apply, ContinuousLinearMap.smulRight_apply,\n    ContinuousLinearMap.one_apply]\n  rw [â† smul_sub, norm_smul, mul_comm]\n  exact mul_le_mul hn.le rfl.le (norm_nonneg _) hq.le\n#align uniform_cauchy_seq_on_filter.one_smul_right uniform_cauchy_seq_on_filter.one_smul_right\n\n",
 "has_fderiv_at_of_tendsto_uniformly_on_filter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- `(d/dx) lim_{n â†’ âˆ} f n x = lim_{n â†’ âˆ} f' n x` when the `f' n` converge\n_uniformly_ to their limit at `x`.\n\nIn words the assumptions mean the following:\n  * `hf'`: The `f'` converge \"uniformly at\" `x` to `g'`. This does not mean that the `f' n` even\n    converge away from `x`!\n  * `hf`: For all `(y, n)` with `y` sufficiently close to `x` and `n` sufficiently large, `f' n` is\n    the derivative of `f n`\n  * `hfg`: The `f n` converge pointwise to `g` on a neighborhood of `x` -/\ntheorem has_fderiv_at_of_tendsto_uniformly_on_filter [NeBot l] (hf' : TendstoUniformlyOnFilter f' g' l ((nhds) x))\n    (hf :\n      Â«exprâˆ€á¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â»\"\n        (filter.prod l ((nhds) x)) (has_fderiv_at (f n.1) (f' n.1 n.2) n.2))\n    (hfg :\n      Â«exprâˆ€á¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â»\" ((nhds) x)\n        (Tendsto (fun n => f n y) l ((nhds) (g y)))) :\n    has_fderiv_at g (g' x) x :=\n  by\n  -- The proof strategy follows several steps:\n  --   1. The quantifiers in the definition of the derivative are\n  --      `âˆ€ Îµ > 0, âˆƒÎ´ > 0, âˆ€y âˆˆ B_Î´(x)`. We will introduce a quantifier in the middle:\n  --      `âˆ€ Îµ > 0, âˆƒN, âˆ€n â‰¥ N, âˆƒÎ´ > 0, âˆ€y âˆˆ B_Î´(x)` which will allow us to introduce the `f(') n`\n  --   2. The order of the quantifiers `hfg` are opposite to what we need. We will be able to swap\n  --      the quantifiers using the uniform convergence assumption\n  rw [has_fderiv_at_iff_tendsto]\n  -- Introduce extra quantifier via curried filters\n  suffices\n    tendsto (fun y : Î¹ Ã— E => (Â«exprâ€– â€–Â» (y.2 - x))â»Â¹ * Â«exprâ€– â€–Â» (g y.2 - g x - (g' x) (y.2 - x))) (l.curry ((nhds) x))\n      ((nhds) 0)\n    by\n    rw [Metric.tendsto_nhds] at thisâŠ¢\n    intro Îµ hÎµ\n    specialize this Îµ hÎµ\n    rw [eventually_curry_iff] at this\n    simp only at this\n    exact (eventually_const.mp this).mono (by simp only [imp_self, forall_const])\n  -- With the new quantifier in hand, we can perform the famous `Îµ/3` proof. Specifically,\n  -- we will break up the limit (the difference functions minus the derivative go to 0) into 3:\n  --   * The difference functions of the `f n` converge *uniformly* to the difference functions\n  --     of the `g n`\n  --   * The `f' n` are the derivatives of the `f n`\n  --   * The `f' n` converge to `g'` at `x`\n  conv =>\n    congr\n    ext\n    rw [â† norm_norm, â† norm_inv, â† @IsROrC.norm_ofReal ğ•œ _ _, IsROrC.ofReal_inv, â† norm_smul]\n  rw [â† tendsto_zero_iff_norm_tendsto_zero]\n  have :\n    (fun a : Î¹ Ã— E => Â«expr â€¢ Â» ((Â«exprâ€– â€–Â» (a.2 - x))â»Â¹ : ğ•œ) (g a.2 - g x - (g' x) (a.2 - x))) =\n      ((fun a : Î¹ Ã— E => Â«expr â€¢ Â» ((Â«exprâ€– â€–Â» (a.2 - x))â»Â¹ : ğ•œ) (g a.2 - g x - (f a.1 a.2 - f a.1 x))) +\n          fun a : Î¹ Ã— E =>\n          Â«expr â€¢ Â» ((Â«exprâ€– â€–Â» (a.2 - x))â»Â¹ : ğ•œ) (f a.1 a.2 - f a.1 x - ((f' a.1 x) a.2 - (f' a.1 x) x))) +\n        fun a : Î¹ Ã— E => Â«expr â€¢ Â» ((Â«exprâ€– â€–Â» (a.2 - x))â»Â¹ : ğ•œ) ((f' a.1 x - g' x) (a.2 - x)) :=\n    by\n    ext\n    simp only [Pi.add_apply]\n    rw [â† smul_add, â† smul_add]\n    congr\n    simp only [map_sub, sub_add_sub_cancel, ContinuousLinearMap.coe_sub', Pi.sub_apply]\n  simp_rw [this]\n  have : (nhds) (0 : G) = (nhds) (0 + 0 + 0)\n  simp only [add_zero]\n  rw [this]\n  refine' tendsto.add (tendsto.add _ _) _\n  simp only\n  Â· have := difference_quotients_converge_uniformly hf' hf hfg\n    rw [Metric.tendstoUniformlyOnFilter_iff] at this\n    rw [Metric.tendsto_nhds]\n    intro Îµ hÎµ\n    apply ((this Îµ hÎµ).filter_mono curry_le_prod).mono\n    intro n hn\n    rw [dist_eq_norm] at hnâŠ¢\n    rw [â† smul_sub] at hn\n    rwa [sub_zero]\n  Â· -- (Almost) the definition of the derivatives\n    rw [Metric.tendsto_nhds]\n    intro Îµ hÎµ\n    rw [eventually_curry_iff]\n    refine' hf.curry.mono fun n hn => _\n    have := hn.self_of_nhds\n    rw [has_fderiv_at_iff_tendsto, Metric.tendsto_nhds] at this\n    refine' (this Îµ hÎµ).mono fun y hy => _\n    rw [dist_eq_norm] at hyâŠ¢\n    simp only [sub_zero, map_sub, norm_mul, norm_inv, norm_norm] at hyâŠ¢\n    rw [norm_smul, norm_inv, is_R_or_C.norm_coe_norm]\n    exact hy\n  Â· -- hfg' after specializing to `x` and applying the definition of the operator norm\n    refine' tendsto.mono_left _ curry_le_prod\n    have h1 : tendsto (fun n : Î¹ Ã— E => g' n.2 - f' n.1 n.2) (filter.prod l ((nhds) x)) ((nhds) 0) :=\n      by\n      rw [Metric.tendstoUniformlyOnFilter_iff] at hf'\n      exact metric.tendsto_nhds.mpr fun Îµ hÎµ => by simpa using hf' Îµ hÎµ\n    have h2 : tendsto (fun n : Î¹ => g' x - f' n x) l ((nhds) 0) :=\n      by\n      rw [Metric.tendsto_nhds] at h1âŠ¢\n      exact fun Îµ hÎµ => (h1 Îµ hÎµ).curry.mono fun n hn => hn.self_of_nhds\n    have := tendsto_fst.comp (h2.prod_map tendsto_id)\n    refine' squeeze_zero_norm _ (tendsto_zero_iff_norm_tendsto_zero.mp this)\n    intro n\n    simp_rw [norm_smul, norm_inv, is_R_or_C.norm_coe_norm]\n    by_cases hx : x = n.2\n    Â· simp [hx]\n    have hnx : 0 < Â«exprâ€– â€–Â» (n.2 - x) := by\n      rw [norm_pos_iff]\n      intro hx'\n      exact hx (eq_of_sub_eq_zero hx').symm\n    rw [inv_mul_le_iff hnx, mul_comm]\n    simp only [Function.comp_apply, Prod_map]\n    rw [norm_sub_rev]\n    exact (f' n.1 x - g' x).le_op_norm (n.2 - x)\n#align has_fderiv_at_of_tendsto_uniformly_on_filter has_fderiv_at_of_tendsto_uniformly_on_filter\n\n",
 "has_fderiv_at_of_tendsto_uniformly_on":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- `(d/dx) lim_{n â†’ âˆ} f n x = lim_{n â†’ âˆ} f' n x` when the `f' n` converge\n_uniformly_ to their limit on an open set containing `x`. -/\ntheorem has_fderiv_at_of_tendsto_uniformly_on [NeBot l] {s : Set E} (hs : IsOpen s) (hf' : TendstoUniformlyOn f' g' l s)\n    (hf : âˆ€ n : Î¹, âˆ€ x : E, x âˆˆ s â†’ has_fderiv_at (f n) (f' n x) x)\n    (hfg : âˆ€ x : E, x âˆˆ s â†’ Tendsto (fun n => f n x) l ((nhds) (g x))) : âˆ€ x : E, x âˆˆ s â†’ has_fderiv_at g (g' x) x :=\n  fun x => has_fderiv_at_of_tendsto_locally_uniformly_on hs hf'.tendsto_locally_uniformly_on hf hfg\n#align has_fderiv_at_of_tendsto_uniformly_on has_fderiv_at_of_tendsto_uniformly_on\n\n",
 "has_fderiv_at_of_tendsto_uniformly":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- `(d/dx) lim_{n â†’ âˆ} f n x = lim_{n â†’ âˆ} f' n x` when the `f' n` converge\n_uniformly_ to their limit. -/\ntheorem has_fderiv_at_of_tendsto_uniformly [NeBot l] (hf' : TendstoUniformly f' g' l)\n    (hf : âˆ€ n : Î¹, âˆ€ x : E, has_fderiv_at (f n) (f' n x) x) (hfg : âˆ€ x : E, Tendsto (fun n => f n x) l ((nhds) (g x))) :\n    âˆ€ x : E, has_fderiv_at g (g' x) x := by\n  intro x\n  have hf : âˆ€ n : Î¹, âˆ€ x : E, x âˆˆ Set.univ â†’ has_fderiv_at (f n) (f' n x) x := by simp [hf]\n  have hfg : âˆ€ x : E, x âˆˆ Set.univ â†’ tendsto (fun n => f n x) l ((nhds) (g x)) := by simp [hfg]\n  have hf' : TendstoUniformlyOn f' g' l Set.univ := by rwa [tendstoUniformlyOn_univ]\n  refine' has_fderiv_at_of_tendsto_uniformly_on isOpen_univ hf' hf hfg x (Set.mem_univ x)\n#align has_fderiv_at_of_tendsto_uniformly has_fderiv_at_of_tendsto_uniformly\n\n",
 "has_fderiv_at_of_tendsto_locally_uniformly_on'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- A slight variant of `has_fderiv_at_of_tendsto_locally_uniformly_on` with the assumption stated\nin terms of `differentiable_on` rather than `has_fderiv_at`. This makes a few proofs nicer in\ncomplex analysis where holomorphicity is assumed but the derivative is not known a priori. -/\ntheorem has_fderiv_at_of_tendsto_locally_uniformly_on' [NeBot l] {s : Set E} (hs : IsOpen s)\n    (hf' : TendstoLocallyUniformlyOn (fderiv ğ•œ âˆ˜ f) g' l s) (hf : âˆ€ n, differentiable_on ğ•œ (f n) s)\n    (hfg : âˆ€ x âˆˆ s, Tendsto (fun n => f n x) l ((nhds) (g x))) (hx : x âˆˆ s) : has_fderiv_at g (g' x) x :=\n  by\n  refine' has_fderiv_at_of_tendsto_locally_uniformly_on hs hf' (fun n z hz => _) hfg hx\n  exact ((hf n z hz).differentiable_at (hs.mem_nhds hz)).has_fderiv_at\n#align has_fderiv_at_of_tendsto_locally_uniformly_on' has_fderiv_at_of_tendsto_locally_uniformly_on'\n\n",
 "has_fderiv_at_of_tendsto_locally_uniformly_on":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem has_fderiv_at_of_tendsto_locally_uniformly_on [NeBot l] {s : Set E} (hs : IsOpen s)\n    (hf' : TendstoLocallyUniformlyOn f' g' l s) (hf : âˆ€ n, âˆ€ x âˆˆ s, has_fderiv_at (f n) (f' n x) x)\n    (hfg : âˆ€ x âˆˆ s, Tendsto (fun n => f n x) l ((nhds) (g x))) (hx : x âˆˆ s) : has_fderiv_at g (g' x) x :=\n  by\n  have h1 : s âˆˆ (nhds) x := hs.mem_nhds hx\n  have h3 : lower_set.prod Set.univ s âˆˆ filter.prod l ((nhds) x) := by\n    simp only [h1, prod_mem_prod_iff, univ_mem, and_self_iff]\n  have h4 :\n    Â«exprâˆ€á¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â»\"\n      (filter.prod l ((nhds) x)) (has_fderiv_at (f n.1) (f' n.1 n.2) n.2) :=\n    eventually_of_mem h3 fun âŸ¨n, zâŸ© âŸ¨hn, hzâŸ© => hf n z hz\n  refine' has_fderiv_at_of_tendsto_uniformly_on_filter _ h4 (eventually_of_mem h1 hfg)\n  simpa [IsOpen.nhdsWithin_eq hs hx] using tendsto_locally_uniformly_on_iff_filter.mp hf' x hx\n#align has_fderiv_at_of_tendsto_locally_uniformly_on has_fderiv_at_of_tendsto_locally_uniformly_on\n\n",
 "has_deriv_at_of_tendsto_uniformly_on_filter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem has_deriv_at_of_tendsto_uniformly_on_filter [NeBot l] (hf' : TendstoUniformlyOnFilter f' g' l ((nhds) x))\n    (hf :\n      Â«exprâˆ€á¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â»\"\n        (filter.prod l ((nhds) x)) (has_deriv_at (f n.1) (f' n.1 n.2) n.2))\n    (hfg :\n      Â«exprâˆ€á¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â»\" ((nhds) x)\n        (Tendsto (fun n => f n y) l ((nhds) (g y)))) :\n    has_deriv_at g (g' x) x :=\n  by\n  -- The first part of the proof rewrites `hf` and the goal to be functions so that Lean\n  -- can recognize them when we apply `has_fderiv_at_of_tendsto_uniformly_on_filter`\n  let F' n z := (1 : Â«expr â†’L[ ] Â» ğ•œ ğ•œ ğ•œ).smul_right (f' n z)\n  let G' z := (1 : Â«expr â†’L[ ] Â» ğ•œ ğ•œ ğ•œ).smul_right (g' z)\n  simp_rw [has_deriv_at_iff_has_fderiv_at] at hfâŠ¢\n  -- Now we need to rewrite hf' in terms of continuous_linear_maps. The tricky part is that\n  -- operator norms are written in terms of `â‰¤` whereas metrics are written in terms of `<`. So we\n  -- need to shrink `Îµ` utilizing the archimedean property of `â„`\n  have hf' : TendstoUniformlyOnFilter F' G' l ((nhds) x) :=\n    by\n    rw [Metric.tendstoUniformlyOnFilter_iff] at hf'âŠ¢\n    intro Îµ hÎµ\n    obtain âŸ¨q, hq, hq'âŸ© := exists_between hÎµ.lt\n    apply (hf' q hq).mono\n    intro n hn\n    refine' lt_of_le_of_lt _ hq'\n    simp only [F', G', dist_eq_norm] at hnâŠ¢\n    refine' continuous_linear_map.op_norm_le_bound _ hq.le _\n    intro z\n    simp only [ContinuousLinearMap.coe_sub', Pi.sub_apply, ContinuousLinearMap.smulRight_apply,\n      ContinuousLinearMap.one_apply]\n    rw [â† smul_sub, norm_smul, mul_comm]\n    exact mul_le_mul hn.le rfl.le (norm_nonneg _) hq.le\n  exact has_fderiv_at_of_tendsto_uniformly_on_filter hf' hf hfg\n#align has_deriv_at_of_tendsto_uniformly_on_filter has_deriv_at_of_tendsto_uniformly_on_filter\n\n",
 "has_deriv_at_of_tendsto_uniformly_on":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem has_deriv_at_of_tendsto_uniformly_on [NeBot l] {s : Set ğ•œ} (hs : IsOpen s) (hf' : TendstoUniformlyOn f' g' l s)\n    (hf :\n      Â«exprâˆ€á¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â»\" l\n        (âˆ€ x : ğ•œ, x âˆˆ s â†’ has_deriv_at (f n) (f' n x) x))\n    (hfg : âˆ€ x : ğ•œ, x âˆˆ s â†’ Tendsto (fun n => f n x) l ((nhds) (g x))) : âˆ€ x : ğ•œ, x âˆˆ s â†’ has_deriv_at g (g' x) x :=\n  fun x => has_deriv_at_of_tendsto_locally_uniformly_on hs hf'.tendsto_locally_uniformly_on hf hfg\n#align has_deriv_at_of_tendsto_uniformly_on has_deriv_at_of_tendsto_uniformly_on\n\n",
 "has_deriv_at_of_tendsto_uniformly":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem has_deriv_at_of_tendsto_uniformly [NeBot l] (hf' : TendstoUniformly f' g' l)\n    (hf :\n      Â«exprâˆ€á¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â»\" l\n        (âˆ€ x : ğ•œ, has_deriv_at (f n) (f' n x) x))\n    (hfg : âˆ€ x : ğ•œ, Tendsto (fun n => f n x) l ((nhds) (g x))) : âˆ€ x : ğ•œ, has_deriv_at g (g' x) x :=\n  by\n  intro x\n  have hf :\n    Â«exprâˆ€á¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â»\" l\n      (âˆ€ x : ğ•œ, x âˆˆ Set.univ â†’ has_deriv_at (f n) (f' n x) x) :=\n    by filter_upwards [hf]with n h x hx using h x\n  have hfg : âˆ€ x : ğ•œ, x âˆˆ Set.univ â†’ tendsto (fun n => f n x) l ((nhds) (g x)) := by simp [hfg]\n  have hf' : TendstoUniformlyOn f' g' l Set.univ := by rwa [tendstoUniformlyOn_univ]\n  exact has_deriv_at_of_tendsto_uniformly_on isOpen_univ hf' hf hfg x (Set.mem_univ x)\n#align has_deriv_at_of_tendsto_uniformly has_deriv_at_of_tendsto_uniformly\n\n",
 "has_deriv_at_of_tendsto_locally_uniformly_on'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- A slight variant of `has_deriv_at_of_tendsto_locally_uniformly_on` with the assumption stated in\nterms of `differentiable_on` rather than `has_deriv_at`. This makes a few proofs nicer in complex\nanalysis where holomorphicity is assumed but the derivative is not known a priori. -/\ntheorem has_deriv_at_of_tendsto_locally_uniformly_on' [NeBot l] {s : Set ğ•œ} (hs : IsOpen s)\n    (hf' : TendstoLocallyUniformlyOn (deriv âˆ˜ f) g' l s)\n    (hf :\n      Â«exprâˆ€á¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â»\" l\n        (differentiable_on ğ•œ (f n) s))\n    (hfg : âˆ€ x âˆˆ s, Tendsto (fun n => f n x) l ((nhds) (g x))) (hx : x âˆˆ s) : has_deriv_at g (g' x) x :=\n  by\n  refine' has_deriv_at_of_tendsto_locally_uniformly_on hs hf' _ hfg hx\n  filter_upwards [hf]with n h z hz using((h z hz).differentiable_at (hs.mem_nhds hz)).has_deriv_at\n#align has_deriv_at_of_tendsto_locally_uniformly_on' has_deriv_at_of_tendsto_locally_uniformly_on'\n\n",
 "has_deriv_at_of_tendsto_locally_uniformly_on":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem has_deriv_at_of_tendsto_locally_uniformly_on [NeBot l] {s : Set ğ•œ} (hs : IsOpen s)\n    (hf' : TendstoLocallyUniformlyOn f' g' l s)\n    (hf :\n      Â«exprâˆ€á¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â»\" l\n        (âˆ€ x âˆˆ s, has_deriv_at (f n) (f' n x) x))\n    (hfg : âˆ€ x âˆˆ s, Tendsto (fun n => f n x) l ((nhds) (g x))) (hx : x âˆˆ s) : has_deriv_at g (g' x) x :=\n  by\n  have h1 : s âˆˆ (nhds) x := hs.mem_nhds hx\n  have h2 :\n    Â«exprâˆ€á¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â»\"\n      (filter.prod l ((nhds) x)) (has_deriv_at (f n.1) (f' n.1 n.2) n.2) :=\n    eventually_prod_iff.2 âŸ¨_, hf, fun x => x âˆˆ s, h1, fun n => idâŸ©\n  refine' has_deriv_at_of_tendsto_uniformly_on_filter _ h2 (eventually_of_mem h1 hfg)\n  simpa [IsOpen.nhdsWithin_eq hs hx] using tendsto_locally_uniformly_on_iff_filter.mp hf' x hx\n#align has_deriv_at_of_tendsto_locally_uniformly_on has_deriv_at_of_tendsto_locally_uniformly_on\n\n",
 "difference_quotients_converge_uniformly":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¥Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- If `f_n â†’ g` pointwise and the derivatives `(f_n)' â†’ h` _uniformly_ converge, then\nin fact for a fixed `y`, the difference quotients `â€–z - yâ€–â»Â¹ â€¢ (f_n z - f_n y)` converge\n_uniformly_ to `â€–z - yâ€–â»Â¹ â€¢ (g z - g y)` -/\ntheorem difference_quotients_converge_uniformly (hf' : TendstoUniformlyOnFilter f' g' l ((nhds) x))\n    (hf :\n      Â«exprâˆ€á¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â»\"\n        (filter.prod l ((nhds) x)) (has_fderiv_at (f n.1) (f' n.1 n.2) n.2))\n    (hfg :\n      Â«exprâˆ€á¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â»\" ((nhds) x)\n        (Tendsto (fun n => f n y) l ((nhds) (g y)))) :\n    TendstoUniformlyOnFilter (fun n : Î¹ => fun y : E => Â«expr â€¢ Â» ((Â«exprâ€– â€–Â» (y - x))â»Â¹ : ğ•œ) (f n y - f n x))\n      (fun y : E => Â«expr â€¢ Â» ((Â«exprâ€– â€–Â» (y - x))â»Â¹ : ğ•œ) (g y - g x)) l ((nhds) x) :=\n  by\n  let : NormedSpace (exprâ„) E\n  exact NormedSpace.restrictScalars (exprâ„) ğ•œ _\n  rcases eq_or_ne l (Â«exprâŠ¥Â») with (hl | hl)\n  Â· simp only [hl, TendstoUniformlyOnFilter, bot_prod, eventually_bot, imp_true_iff]\n  haveI : ne_bot l := âŸ¨hlâŸ©\n  refine'\n    UniformCauchySeqOnFilter.tendstoUniformlyOnFilter_of_tendsto _\n      ((hfg.and (eventually_const.mpr hfg.self_of_nhds)).mono fun y hy => (hy.1.sub hy.2).const_smul _)\n  rw [SeminormedAddGroup.uniformCauchySeqOnFilter_iff_tendstoUniformlyOnFilter_zero]\n  rw [Metric.tendstoUniformlyOnFilter_iff]\n  have hfg' := hf'.uniform_cauchy_seq_on_filter\n  rw [SeminormedAddGroup.uniformCauchySeqOnFilter_iff_tendstoUniformlyOnFilter_zero] at hfg'\n  rw [Metric.tendstoUniformlyOnFilter_iff] at hfg'\n  intro Îµ hÎµ\n  obtain âŸ¨q, hqpos, hqÎµâŸ© := exists_pos_rat_lt hÎµ\n  specialize hfg' (q : exprâ„) (by simp [hqpos])\n  have := (tendsto_swap4_prod.eventually (hf.prod_mk hf)).diag_of_prod_right\n  obtain âŸ¨a, b, c, d, eâŸ© := eventually_prod_iff.1 (hfg'.and this)\n  obtain âŸ¨r, hr, hr'âŸ© := metric.nhds_basis_ball.eventually_iff.mp d\n  rw [eventually_prod_iff]\n  refine'\n    âŸ¨_, b, fun e : E => Metric.ball x r e, eventually_mem_set.mpr (metric.nhds_basis_ball.mem_of_mem hr),\n      fun n hn y hy => _âŸ©\n  simp only [Pi.zero_apply, dist_zero_left]\n  rw [â† smul_sub, norm_smul, norm_inv, is_R_or_C.norm_coe_norm]\n  refine' lt_of_le_of_lt _ hqÎµ\n  by_cases hyz' : x = y\n  Â· simp [hyz', hqpos.le]\n  have hyz : 0 < Â«exprâ€– â€–Â» (y - x) := by\n    rw [norm_pos_iff]\n    intro hy'\n    exact hyz' (eq_of_sub_eq_zero hy').symm\n  rw [inv_mul_le_iff hyz, mul_comm, sub_sub_sub_comm]\n  simp only [Pi.zero_apply, dist_zero_left] at e\n  refine'\n    convex.norm_image_sub_le_of_norm_has_fderiv_within_le\n      (fun y hy => ((e hn (hr' hy)).2.1.sub (e hn (hr' hy)).2.2).has_fderiv_within_at)\n      (fun y hy => (e hn (hr' hy)).1.le) (convex_ball x r) (Metric.mem_ball_self hr) hy\n#align difference_quotients_converge_uniformly difference_quotients_converge_uniformly\n\n",
 "cauchy_map_of_uniform_cauchy_seq_on_fderiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/-- If a sequence of functions between real or complex normed spaces are differentiable on a\npreconnected open set, they form a Cauchy sequence _at_ `x`, and their derivatives are Cauchy\nuniformly on the set, then the functions form a Cauchy sequence at any point in the set. -/\ntheorem cauchy_map_of_uniform_cauchy_seq_on_fderiv {s : Set E} (hs : IsOpen s) (h's : IsPreconnected s)\n    (hf' : UniformCauchySeqOn f' l s) (hf : âˆ€ n : Î¹, âˆ€ y : E, y âˆˆ s â†’ has_fderiv_at (f n) (f' n y) y) {xâ‚€ x : E}\n    (hxâ‚€ : xâ‚€ âˆˆ s) (hx : x âˆˆ s) (hfg : Cauchy (map (fun n => f n xâ‚€) l)) : Cauchy (map (fun n => f n x) l) :=\n  by\n  have : ne_bot l := (cauchy_map_iff.1 hfg).1\n  let t := { y | y âˆˆ s âˆ§ Cauchy (map (fun n => f n y) l) }\n  suffices H : s âŠ† t\n  exact (H hx).2\n  have A : âˆ€ x Îµ, x âˆˆ t â†’ Metric.ball x Îµ âŠ† s â†’ Metric.ball x Îµ âŠ† t := fun x Îµ xt hx y hy =>\n    âŸ¨hx hy, (uniform_cauchy_seq_on_ball_of_fderiv (hf'.mono hx) (fun n y hy => hf n y (hx hy)) xt.2).cauchy_map hyâŸ©\n  have open_t : IsOpen t := by\n    rw [Metric.isOpen_iff]\n    intro x hx\n    rcases Metric.isOpen_iff.1 hs x hx.1 with âŸ¨Îµ, Îµpos, hÎµâŸ©\n    exact âŸ¨Îµ, Îµpos, A x Îµ hx hÎµâŸ©\n  have st_nonempty : (s âˆ© t).nonempty := âŸ¨xâ‚€, hxâ‚€, âŸ¨hxâ‚€, hfgâŸ©âŸ©\n  suffices H : closure t âˆ© s âŠ† t\n  exact h's.subset_of_closure_inter_subset open_t st_nonempty H\n  rintro x âŸ¨xt, xsâŸ©\n  obtain âŸ¨Îµ, Îµpos, hÎµâŸ© : âˆƒ (Îµ : exprâ„)(H : Îµ > 0), Metric.ball x Îµ âŠ† s\n  exact Metric.isOpen_iff.1 hs x xs\n  obtain âŸ¨y, yt, hxyâŸ© : âˆƒ (y : E)(yt : y âˆˆ t), dist x y < Îµ / 2\n  exact Metric.mem_closure_iff.1 xt _ (half_pos Îµpos)\n  have B : Metric.ball y (Îµ / 2) âŠ† Metric.ball x Îµ :=\n    by\n    apply Metric.ball_subset_ball'\n    rw [dist_comm]\n    linarith\n  exact A y (Îµ / 2) yt (B.trans hÎµ) (Metric.mem_ball.2 hxy)\n#align cauchy_map_of_uniform_cauchy_seq_on_fderiv cauchy_map_of_uniform_cauchy_seq_on_fderiv\n\n"}