{"zero_eq'":
 "theorem has_ftaylor_series_up_to.zero_eq' (h : has_ftaylor_series_up_to n f p) (x : E) :\n    p x 0 = (continuous_multilinear_curry_fin0 ğ•œ E F).symm (f x) :=\n  by\n  rw [â† h.zero_eq x]\n  symm\n  exact continuous_multilinear_map.uncurry0_curry0 _\n#align has_ftaylor_series_up_to.zero_eq' has_ftaylor_series_up_to.zero_eq'\n\n",
 "one_of_succ":
 "theorem cont_diff.one_of_succ {n : â„•} (h : cont_diff ğ•œ (n + 1) f) : cont_diff ğ•œ 1 f :=\n  h.of_le <| WithTop.coe_le_coe.mpr le_add_self\n#align cont_diff.one_of_succ cont_diff.one_of_succ\n\n",
 "of_succ":
 "theorem cont_diff.of_succ {n : â„•} (h : cont_diff ğ•œ (n + 1) f) : cont_diff ğ•œ n f :=\n  h.of_le <| WithTop.coe_le_coe.mpr le_self_add\n#align cont_diff.of_succ cont_diff.of_succ\n\n",
 "of_le":
 "theorem cont_diff.of_le (h : cont_diff ğ•œ n f) (hmn : m â‰¤ n) : cont_diff ğ•œ m f :=\n  cont_diff_on_univ.1 <| (cont_diff_on_univ.2 h).of_le hmn\n#align cont_diff.of_le cont_diff.of_le\n\n",
 "norm_iterated_fderiv_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n@[simp]\ntheorem norm_iterated_fderiv_zero : Â«exprâ€– â€–Â» (iterated_fderiv ğ•œ 0 f x) = Â«exprâ€– â€–Â» (f x) := by\n  rw [iterated_fderiv_zero_eq_comp, LinearIsometryEquiv.norm_map]\n#align norm_iterated_fderiv_zero norm_iterated_fderiv_zero\n\n",
 "norm_iterated_fderiv_within_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n@[simp]\ntheorem norm_iterated_fderiv_within_zero : Â«exprâ€– â€–Â» (iterated_fderiv_within ğ•œ 0 f s x) = Â«exprâ€– â€–Â» (f x) := by\n  rw [iterated_fderiv_within_zero_eq_comp, LinearIsometryEquiv.norm_map]\n#align norm_iterated_fderiv_within_zero norm_iterated_fderiv_within_zero\n\n",
 "norm_iterated_fderiv_within_fderiv_within":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\ntheorem norm_iterated_fderiv_within_fderiv_within {n : â„•} (hs : unique_diff_on ğ•œ s) (hx : x âˆˆ s) :\n    Â«exprâ€– â€–Â» (iterated_fderiv_within ğ•œ n (fderiv_within ğ•œ f s) s x) =\n      Â«exprâ€– â€–Â» (iterated_fderiv_within ğ•œ (n + 1) f s x) :=\n  by rw [iterated_fderiv_within_succ_eq_comp_right hs hx, LinearIsometryEquiv.norm_map]\n#align norm_iterated_fderiv_within_fderiv_within norm_iterated_fderiv_within_fderiv_within\n\n",
 "norm_iterated_fderiv_fderiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\ntheorem norm_iterated_fderiv_fderiv {n : â„•} :\n    Â«exprâ€– â€–Â» (iterated_fderiv ğ•œ n (fderiv ğ•œ f) x) = Â«exprâ€– â€–Â» (iterated_fderiv ğ•œ (n + 1) f x) := by\n  rw [iterated_fderiv_succ_eq_comp_right, LinearIsometryEquiv.norm_map]\n#align norm_iterated_fderiv_fderiv norm_iterated_fderiv_fderiv\n\n",
 "norm_fderiv_within_iterated_fderiv_within":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\ntheorem norm_fderiv_within_iterated_fderiv_within {n : â„•} :\n    Â«exprâ€– â€–Â» (fderiv_within ğ•œ (iterated_fderiv_within ğ•œ n f s) s x) =\n      Â«exprâ€– â€–Â» (iterated_fderiv_within ğ•œ (n + 1) f s x) :=\n  by rw [iterated_fderiv_within_succ_eq_comp_left, LinearIsometryEquiv.norm_map]\n#align norm_fderiv_within_iterated_fderiv_within norm_fderiv_within_iterated_fderiv_within\n\n",
 "norm_fderiv_iterated_fderiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\ntheorem norm_fderiv_iterated_fderiv {n : â„•} :\n    Â«exprâ€– â€–Â» (fderiv ğ•œ (iterated_fderiv ğ•œ n f) x) = Â«exprâ€– â€–Â» (iterated_fderiv ğ•œ (n + 1) f x) := by\n  rw [iterated_fderiv_succ_eq_comp_left, LinearIsometryEquiv.norm_map]\n#align norm_fderiv_iterated_fderiv norm_fderiv_iterated_fderiv\n\n",
 "mono_of_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\ntheorem cont_diff_within_at.mono_of_mem (h : cont_diff_within_at ğ•œ n f s x) {t : Set E} (hst : s âˆˆ nhds_within t x) :\n    cont_diff_within_at ğ•œ n f t x := by\n  intro m hm\n  rcases h m hm with âŸ¨u, hu, p, HâŸ©\n  exact âŸ¨u, nhdsWithin_le_of_mem (insert_mem_nhdsWithin_insert hst) hu, p, HâŸ©\n#align cont_diff_within_at.mono_of_mem cont_diff_within_at.mono_of_mem\n\n",
 "mono":
 "theorem cont_diff_on.mono (h : cont_diff_on ğ•œ n f s) {t : Set E} (hst : t âŠ† s) : cont_diff_on ğ•œ n f t := fun x hx =>\n  (h x (hst hx)).mono hst\n#align cont_diff_on.mono cont_diff_on.mono\n\n",
 "iterated_fderiv_zero_eq_comp":
 "theorem iterated_fderiv_zero_eq_comp : iterated_fderiv ğ•œ 0 f = (continuous_multilinear_curry_fin0 ğ•œ E F).symm âˆ˜ f :=\n  rfl\n#align iterated_fderiv_zero_eq_comp iterated_fderiv_zero_eq_comp\n\n",
 "iterated_fderiv_zero_apply":
 "@[simp]\ntheorem iterated_fderiv_zero_apply (m : Fin 0 â†’ E) : (iterated_fderiv ğ•œ 0 f x : (Fin 0 â†’ E) â†’ F) m = f x :=\n  rfl\n#align iterated_fderiv_zero_apply iterated_fderiv_zero_apply\n\n",
 "iterated_fderiv_within_zero_eq_comp":
 "theorem iterated_fderiv_within_zero_eq_comp :\n    iterated_fderiv_within ğ•œ 0 f s = (continuous_multilinear_curry_fin0 ğ•œ E F).symm âˆ˜ f :=\n  rfl\n#align iterated_fderiv_within_zero_eq_comp iterated_fderiv_within_zero_eq_comp\n\n",
 "iterated_fderiv_within_zero_apply":
 "@[simp]\ntheorem iterated_fderiv_within_zero_apply (m : Fin 0 â†’ E) :\n    (iterated_fderiv_within ğ•œ 0 f s x : (Fin 0 â†’ E) â†’ F) m = f x :=\n  rfl\n#align iterated_fderiv_within_zero_apply iterated_fderiv_within_zero_apply\n\n",
 "iterated_fderiv_within_univ":
 "theorem iterated_fderiv_within_univ {n : â„•} : iterated_fderiv_within ğ•œ n f univ = iterated_fderiv ğ•œ n f :=\n  by\n  induction' n with n IH\n  Â· ext x\n    simp\n  Â· ext (x m)\n    rw [iterated_fderiv_succ_apply_left, iterated_fderiv_within_succ_apply_left, IH, fderiv_within_univ]\n#align iterated_fderiv_within_univ iterated_fderiv_within_univ\n\n",
 "iterated_fderiv_within_succ_eq_comp_right":
 "/-- Writing explicitly the `n+1`-th derivative as the composition of a currying linear equiv,\nand the `n`-th derivative of the derivative. -/\ntheorem iterated_fderiv_within_succ_eq_comp_right {n : â„•} (hs : unique_diff_on ğ•œ s) (hx : x âˆˆ s) :\n    iterated_fderiv_within ğ•œ (n + 1) f s x =\n      (continuous_multilinear_curry_right_equiv' ğ•œ n E F âˆ˜\n          iterated_fderiv_within ğ•œ n (fun y => fderiv_within ğ•œ f s y) s)\n        x :=\n  by\n  ext m\n  rw [iterated_fderiv_within_succ_apply_right hs hx]\n  rfl\n#align iterated_fderiv_within_succ_eq_comp_right iterated_fderiv_within_succ_eq_comp_right\n\n",
 "iterated_fderiv_within_succ_eq_comp_left":
 "/-- Writing explicitly the `n+1`-th derivative as the composition of a currying linear equiv,\nand the derivative of the `n`-th derivative. -/\ntheorem iterated_fderiv_within_succ_eq_comp_left {n : â„•} :\n    iterated_fderiv_within ğ•œ (n + 1) f s =\n      continuous_multilinear_curry_left_equiv ğ•œ (fun i : Fin (n + 1) => E) F âˆ˜\n        fderiv_within ğ•œ (iterated_fderiv_within ğ•œ n f s) s :=\n  rfl\n#align iterated_fderiv_within_succ_eq_comp_left iterated_fderiv_within_succ_eq_comp_left\n\n",
 "iterated_fderiv_within_succ_apply_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr [Ã— ]â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr [Ã— ]â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr [Ã— ]â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr [Ã— ]â†’L[ ] Â» -/\ntheorem iterated_fderiv_within_succ_apply_right {n : â„•} (hs : unique_diff_on ğ•œ s) (hx : x âˆˆ s) (m : Fin (n + 1) â†’ E) :\n    (iterated_fderiv_within ğ•œ (n + 1) f s x : (Fin (n + 1) â†’ E) â†’ F) m =\n      iterated_fderiv_within ğ•œ n (fun y => fderiv_within ğ•œ f s y) s x (init m) (m (last n)) :=\n  by\n  induction' n with n IH generalizing x\n  Â· rw [iterated_fderiv_within_succ_eq_comp_left, iterated_fderiv_within_zero_eq_comp,\n      iterated_fderiv_within_zero_apply, Function.comp_apply, linear_isometry_equiv.comp_fderiv_within _ (hs x hx)]\n    rfl\n  Â· let I := continuous_multilinear_curry_right_equiv' ğ•œ n E F\n    have A :\n      âˆ€ y âˆˆ s,\n        iterated_fderiv_within ğ•œ n.succ f s y = (I âˆ˜ iterated_fderiv_within ğ•œ n (fun y => fderiv_within ğ•œ f s y) s) y :=\n      by\n      intro y hy\n      ext m\n      rw [@IH m y hy]\n      rfl\n    calc\n      (iterated_fderiv_within ğ•œ (n + 2) f s x : (Fin (n + 2) â†’ E) â†’ F) m =\n          (fderiv_within ğ•œ (iterated_fderiv_within ğ•œ n.succ f s) s x : E â†’ Â«expr [Ã— ]â†’L[ ] Â» E (n + 1) ğ•œ F) (m 0)\n            (tail m) :=\n        rfl\n      _ =\n          (fderiv_within ğ•œ (I âˆ˜ iterated_fderiv_within ğ•œ n (fderiv_within ğ•œ f s) s) s x :\n              E â†’ Â«expr [Ã— ]â†’L[ ] Â» E (n + 1) ğ•œ F)\n            (m 0) (tail m) :=\n        by rw [fderiv_within_congr (hs x hx) A (A x hx)]\n      _ =\n          (I âˆ˜ fderiv_within ğ•œ (iterated_fderiv_within ğ•œ n (fderiv_within ğ•œ f s) s) s x :\n              E â†’ Â«expr [Ã— ]â†’L[ ] Â» E (n + 1) ğ•œ F)\n            (m 0) (tail m) :=\n        by\n        rw [linear_isometry_equiv.comp_fderiv_within _ (hs x hx)]\n        rfl\n      _ =\n          (fderiv_within ğ•œ (iterated_fderiv_within ğ•œ n (fun y => fderiv_within ğ•œ f s y) s) s x :\n              E â†’ Â«expr [Ã— ]â†’L[ ] Â» E n ğ•œ (Â«expr â†’L[ ] Â» E ğ•œ F))\n            (m 0) (init (tail m)) ((tail m) (last n)) :=\n        rfl\n      _ = iterated_fderiv_within ğ•œ (nat.succ n) (fun y => fderiv_within ğ•œ f s y) s x (init m) (m (last (n + 1))) :=\n        by\n        rw [iterated_fderiv_within_succ_apply_left, tail_init_eq_init_tail]\n        rfl\n      \n#align iterated_fderiv_within_succ_apply_right iterated_fderiv_within_succ_apply_right\n\n",
 "iterated_fderiv_within_succ_apply_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr [Ã— ]â†’L[ ] Â» -/\ntheorem iterated_fderiv_within_succ_apply_left {n : â„•} (m : Fin (n + 1) â†’ E) :\n    (iterated_fderiv_within ğ•œ (n + 1) f s x : (Fin (n + 1) â†’ E) â†’ F) m =\n      (fderiv_within ğ•œ (iterated_fderiv_within ğ•œ n f s) s x : E â†’ Â«expr [Ã— ]â†’L[ ] Â» E n ğ•œ F) (m 0) (tail m) :=\n  rfl\n#align iterated_fderiv_within_succ_apply_left iterated_fderiv_within_succ_apply_left\n\n",
 "iterated_fderiv_within_one_apply":
 "@[simp]\ntheorem iterated_fderiv_within_one_apply (hs : unique_diff_on ğ•œ s) (hx : x âˆˆ s) (m : Fin 1 â†’ E) :\n    (iterated_fderiv_within ğ•œ 1 f s x : (Fin 1 â†’ E) â†’ F) m = (fderiv_within ğ•œ f s x : E â†’ F) (m 0) :=\n  by\n  rw [iterated_fderiv_within_succ_apply_right hs hx, iterated_fderiv_within_zero_apply]\n  rfl\n#align iterated_fderiv_within_one_apply iterated_fderiv_within_one_apply\n\n",
 "iterated_fderiv_within_of_is_open":
 "/-- In an open set, the iterated derivative within this set coincides with the global iterated\nderivative. -/\ntheorem iterated_fderiv_within_of_is_open (n : â„•) (hs : IsOpen s) :\n    EqOn (iterated_fderiv_within ğ•œ n f s) (iterated_fderiv ğ•œ n f) s :=\n  by\n  induction' n with n IH\n  Â· intro x hx\n    ext1 m\n    simp only [iterated_fderiv_within_zero_apply, iterated_fderiv_zero_apply]\n  Â· intro x hx\n    rw [iterated_fderiv_succ_eq_comp_left, iterated_fderiv_within_succ_eq_comp_left]\n    dsimp\n    congr 1\n    rw [fderiv_within_of_open hs hx]\n    apply filter.eventually_eq.fderiv_eq\n    filter_upwards [hs.mem_nhds hx]\n    exact IH\n#align iterated_fderiv_within_of_is_open iterated_fderiv_within_of_is_open\n\n",
 "iterated_fderiv_within_inter_open":
 "/-- The iterated differential within a set `s` at a point `x` is not modified if one intersects\n`s` with an open set containing `x`. -/\ntheorem iterated_fderiv_within_inter_open {n : â„•} (hu : IsOpen u) (hs : unique_diff_on ğ•œ (s âˆ© u)) (hx : x âˆˆ s âˆ© u) :\n    iterated_fderiv_within ğ•œ n f (s âˆ© u) x = iterated_fderiv_within ğ•œ n f s x :=\n  by\n  induction' n with n IH generalizing x\n  Â· ext m\n    simp\n  Â· have A :\n      fderiv_within ğ•œ (fun y => iterated_fderiv_within ğ•œ n f (s âˆ© u) y) (s âˆ© u) x =\n        fderiv_within ğ•œ (fun y => iterated_fderiv_within ğ•œ n f s y) (s âˆ© u) x :=\n      fderiv_within_congr (hs x hx) (fun y hy => IH hy) (IH hx)\n    have B :\n      fderiv_within ğ•œ (fun y => iterated_fderiv_within ğ•œ n f s y) (s âˆ© u) x =\n        fderiv_within ğ•œ (fun y => iterated_fderiv_within ğ•œ n f s y) s x :=\n      fderiv_within_inter (IsOpen.mem_nhds hu hx.2)\n        ((unique_diff_within_at_inter (IsOpen.mem_nhds hu hx.2)).1 (hs x hx))\n    ext m\n    rw [iterated_fderiv_within_succ_apply_left, iterated_fderiv_within_succ_apply_left, A, B]\n#align iterated_fderiv_within_inter_open iterated_fderiv_within_inter_open\n\n",
 "iterated_fderiv_within_inter'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/-- The iterated differential within a set `s` at a point `x` is not modified if one intersects\n`s` with a neighborhood of `x` within `s`. -/\ntheorem iterated_fderiv_within_inter' {n : â„•} (hu : u âˆˆ nhds_within s x) (hs : unique_diff_on ğ•œ s) (xs : x âˆˆ s) :\n    iterated_fderiv_within ğ•œ n f (s âˆ© u) x = iterated_fderiv_within ğ•œ n f s x :=\n  by\n  obtain âŸ¨v, v_open, xv, vuâŸ© : âˆƒ v, IsOpen v âˆ§ x âˆˆ v âˆ§ v âˆ© s âŠ† u := mem_nhdsWithin.1 hu\n  have A : s âˆ© u âˆ© v = s âˆ© v :=\n    by\n    apply subset.antisymm (inter_subset_inter (inter_subset_left _ _) (subset.refl _))\n    exact fun y âŸ¨ys, yvâŸ© => âŸ¨âŸ¨ys, vu âŸ¨yv, ysâŸ©âŸ©, yvâŸ©\n  have : iterated_fderiv_within ğ•œ n f (s âˆ© v) x = iterated_fderiv_within ğ•œ n f s x :=\n    iterated_fderiv_within_inter_open v_open (hs.inter v_open) âŸ¨xs, xvâŸ©\n  rw [â† this]\n  have : iterated_fderiv_within ğ•œ n f (s âˆ© u âˆ© v) x = iterated_fderiv_within ğ•œ n f (s âˆ© u) x :=\n    by\n    refine' iterated_fderiv_within_inter_open v_open _ âŸ¨âŸ¨xs, vu âŸ¨xv, xsâŸ©âŸ©, xvâŸ©\n    rw [A]\n    exact hs.inter v_open\n  rw [A] at this\n  rw [â† this]\n#align iterated_fderiv_within_inter' iterated_fderiv_within_inter'\n\n",
 "iterated_fderiv_within_inter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- The iterated differential within a set `s` at a point `x` is not modified if one intersects\n`s` with a neighborhood of `x`. -/\ntheorem iterated_fderiv_within_inter {n : â„•} (hu : u âˆˆ (nhds) x) (hs : unique_diff_on ğ•œ s) (xs : x âˆˆ s) :\n    iterated_fderiv_within ğ•œ n f (s âˆ© u) x = iterated_fderiv_within ğ•œ n f s x :=\n  iterated_fderiv_within_inter' (mem_nhdsWithin_of_mem_nhds hu) hs xs\n#align iterated_fderiv_within_inter iterated_fderiv_within_inter\n\n",
 "iterated_fderiv_within_congr":
 "/-- If two functions coincide on a set `s` of unique differentiability, then their iterated\ndifferentials within this set coincide. -/\ntheorem iterated_fderiv_within_congr {n : â„•} (hs : unique_diff_on ğ•œ s) (hL : âˆ€ y âˆˆ s, fâ‚ y = f y) (hx : x âˆˆ s) :\n    iterated_fderiv_within ğ•œ n fâ‚ s x = iterated_fderiv_within ğ•œ n f s x :=\n  by\n  induction' n with n IH generalizing x\n  Â· ext m\n    simp [hL x hx]\n  Â· have :\n      fderiv_within ğ•œ (fun y => iterated_fderiv_within ğ•œ n fâ‚ s y) s x =\n        fderiv_within ğ•œ (fun y => iterated_fderiv_within ğ•œ n f s y) s x :=\n      fderiv_within_congr (hs x hx) (fun y hy => IH hy) (IH hx)\n    ext m\n    rw [iterated_fderiv_within_succ_apply_left, iterated_fderiv_within_succ_apply_left, this]\n#align iterated_fderiv_within_congr iterated_fderiv_within_congr\n\n",
 "iterated_fderiv_with_zero_eq":
 "theorem iterated_fderiv_with_zero_eq : iterated_fderiv_within ğ•œ 0 f s = iterated_fderiv ğ•œ 0 f :=\n  by\n  ext\n  rfl\n#align iterated_fderiv_with_zero_eq iterated_fderiv_with_zero_eq\n\n",
 "iterated_fderiv_succ_eq_comp_right":
 "/-- Writing explicitly the `n+1`-th derivative as the composition of a currying linear equiv,\nand the `n`-th derivative of the derivative. -/\ntheorem iterated_fderiv_succ_eq_comp_right {n : â„•} :\n    iterated_fderiv ğ•œ (n + 1) f x =\n      (continuous_multilinear_curry_right_equiv' ğ•œ n E F âˆ˜ iterated_fderiv ğ•œ n fun y => fderiv ğ•œ f y) x :=\n  by\n  ext m\n  rw [iterated_fderiv_succ_apply_right]\n  rfl\n#align iterated_fderiv_succ_eq_comp_right iterated_fderiv_succ_eq_comp_right\n\n",
 "iterated_fderiv_succ_eq_comp_left":
 "/-- Writing explicitly the `n+1`-th derivative as the composition of a currying linear equiv,\nand the derivative of the `n`-th derivative. -/\ntheorem iterated_fderiv_succ_eq_comp_left {n : â„•} :\n    iterated_fderiv ğ•œ (n + 1) f =\n      continuous_multilinear_curry_left_equiv ğ•œ (fun i : Fin (n + 1) => E) F âˆ˜ fderiv ğ•œ (iterated_fderiv ğ•œ n f) :=\n  rfl\n#align iterated_fderiv_succ_eq_comp_left iterated_fderiv_succ_eq_comp_left\n\n",
 "iterated_fderiv_succ_apply_right":
 "theorem iterated_fderiv_succ_apply_right {n : â„•} (m : Fin (n + 1) â†’ E) :\n    (iterated_fderiv ğ•œ (n + 1) f x : (Fin (n + 1) â†’ E) â†’ F) m =\n      iterated_fderiv ğ•œ n (fun y => fderiv ğ•œ f y) x (init m) (m (last n)) :=\n  by\n  rw [â† iterated_fderiv_within_univ, â† iterated_fderiv_within_univ, â† fderiv_within_univ]\n  exact iterated_fderiv_within_succ_apply_right unique_diff_on_univ (mem_univ _) _\n#align iterated_fderiv_succ_apply_right iterated_fderiv_succ_apply_right\n\n",
 "iterated_fderiv_succ_apply_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr [Ã— ]â†’L[ ] Â» -/\ntheorem iterated_fderiv_succ_apply_left {n : â„•} (m : Fin (n + 1) â†’ E) :\n    (iterated_fderiv ğ•œ (n + 1) f x : (Fin (n + 1) â†’ E) â†’ F) m =\n      (fderiv ğ•œ (iterated_fderiv ğ•œ n f) x : E â†’ Â«expr [Ã— ]â†’L[ ] Â» E n ğ•œ F) (m 0) (tail m) :=\n  rfl\n#align iterated_fderiv_succ_apply_left iterated_fderiv_succ_apply_left\n\n",
 "iterated_fderiv_one_apply":
 "@[simp]\ntheorem iterated_fderiv_one_apply (m : Fin 1 â†’ E) :\n    (iterated_fderiv ğ•œ 1 f x : (Fin 1 â†’ E) â†’ F) m = (fderiv ğ•œ f x : E â†’ F) (m 0) :=\n  by\n  rw [iterated_fderiv_succ_apply_right, iterated_fderiv_zero_apply]\n  rfl\n#align iterated_fderiv_one_apply iterated_fderiv_one_apply\n\n",
 "iterated_fderiv":
 "theorem has_compact_support.iterated_fderiv (hf : HasCompactSupport f) (n : â„•) :\n    HasCompactSupport (iterated_fderiv ğ•œ n f) :=\n  by\n  induction' n with n IH\n  Â· rw [iterated_fderiv_zero_eq_comp]\n    apply hf.comp_left\n    exact LinearIsometryEquiv.map_zero _\n  Â· rw [iterated_fderiv_succ_eq_comp_left]\n    apply (IH.fderiv ğ•œ).comp_left\n    exact LinearIsometryEquiv.map_zero _\n#align has_compact_support.iterated_fderiv has_compact_support.iterated_fderiv\n\n",
 "insert":
 "theorem cont_diff_within_at.insert (h : cont_diff_within_at ğ•œ n f s x) : cont_diff_within_at ğ•œ n f (insert x s) x :=\n  h.insert'\n#align cont_diff_within_at.insert cont_diff_within_at.insert\n\n",
 "has_ftaylor_series_up_to_zero_iff":
 "theorem has_ftaylor_series_up_to_zero_iff :\n    has_ftaylor_series_up_to 0 f p â†” Continuous f âˆ§ âˆ€ x, (p x 0).uncurry0 = f x := by\n  simp [has_ftaylor_series_up_to_on_univ_iff.symm, continuous_iff_continuousOn_univ,\n    has_ftaylor_series_up_to_on_zero_iff]\n#align has_ftaylor_series_up_to_zero_iff has_ftaylor_series_up_to_zero_iff\n\n",
 "has_ftaylor_series_up_to_top_iff'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆÂ» -/\n/-- In the case that `n = âˆ` we don't need the continuity assumption in\n`has_ftaylor_series_up_to`. -/\ntheorem has_ftaylor_series_up_to_top_iff' :\n    has_ftaylor_series_up_to (Â«exprâˆÂ») f p â†”\n      (âˆ€ x, (p x 0).uncurry0 = f x) âˆ§ âˆ€ (m : â„•) (x), has_fderiv_at (fun y => p y m) (p x m.succ).curry_left x :=\n  by\n  simp only [â† has_ftaylor_series_up_to_on_univ_iff, has_ftaylor_series_up_to_on_top_iff', mem_univ, forall_true_left,\n    has_fderiv_within_at_univ]\n#align has_ftaylor_series_up_to_top_iff' has_ftaylor_series_up_to_top_iff'\n\n",
 "has_ftaylor_series_up_to_top_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆÂ» -/\ntheorem has_ftaylor_series_up_to_top_iff :\n    has_ftaylor_series_up_to (Â«exprâˆÂ») f p â†” âˆ€ n : â„•, has_ftaylor_series_up_to n f p := by\n  simp only [â† has_ftaylor_series_up_to_on_univ_iff, has_ftaylor_series_up_to_on_top_iff]\n#align has_ftaylor_series_up_to_top_iff has_ftaylor_series_up_to_top_iff\n\n",
 "has_ftaylor_series_up_to_succ_iff_right":
 "/-- `p` is a Taylor series of `f` up to `n+1` if and only if `p.shift` is a Taylor series up to `n`\nfor `p 1`, which is a derivative of `f`. -/\ntheorem has_ftaylor_series_up_to_succ_iff_right {n : â„•} :\n    has_ftaylor_series_up_to (n + 1 : â„•) f p â†”\n      (âˆ€ x, (p x 0).uncurry0 = f x) âˆ§\n        (âˆ€ x, has_fderiv_at (fun y => p y 0) (p x 1).curry_left x) âˆ§\n          has_ftaylor_series_up_to n (fun x => continuous_multilinear_curry_fin1 ğ•œ E F (p x 1)) fun x => (p x).shift :=\n  by\n  simp only [has_ftaylor_series_up_to_on_succ_iff_right, â† has_ftaylor_series_up_to_on_univ_iff, mem_univ,\n    forall_true_left, has_fderiv_within_at_univ]\n#align has_ftaylor_series_up_to_succ_iff_right has_ftaylor_series_up_to_succ_iff_right\n\n",
 "has_ftaylor_series_up_to_on_zero_iff":
 "theorem has_ftaylor_series_up_to_on_zero_iff :\n    has_ftaylor_series_up_to_on 0 f p s â†” ContinuousOn f s âˆ§ âˆ€ x âˆˆ s, (p x 0).uncurry0 = f x :=\n  by\n  refine' âŸ¨fun H => âŸ¨H.continuous_on, H.zero_eqâŸ©, fun H => âŸ¨H.2, fun m hm => false.elim (not_le.2 hm bot_le), _âŸ©âŸ©\n  intro m hm\n  obtain rfl : m = 0 := by exact_mod_cast hm.antisymm (zero_le _)\n  have : âˆ€ x âˆˆ s, p x 0 = (continuous_multilinear_curry_fin0 ğ•œ E F).symm (f x) :=\n    by\n    intro x hx\n    rw [â† H.2 x hx]\n    symm\n    exact continuous_multilinear_map.uncurry0_curry0 _\n  rw [continuousOn_congr this, LinearIsometryEquiv.comp_continuousOn_iff]\n  exact H.1\n#align has_ftaylor_series_up_to_on_zero_iff has_ftaylor_series_up_to_on_zero_iff\n\n",
 "has_ftaylor_series_up_to_on_univ_iff":
 "theorem has_ftaylor_series_up_to_on_univ_iff :\n    has_ftaylor_series_up_to_on n f p univ â†” has_ftaylor_series_up_to n f p :=\n  by\n  constructor\n  Â· intro H\n    constructor\n    Â· exact fun x => H.zero_eq x (mem_univ x)\n    Â· intro m hm x\n      rw [â† has_fderiv_within_at_univ]\n      exact H.fderiv_within m hm x (mem_univ x)\n    Â· intro m hm\n      rw [continuous_iff_continuousOn_univ]\n      exact H.cont m hm\n  Â· intro H\n    constructor\n    Â· exact fun x hx => H.zero_eq x\n    Â· intro m hm x hx\n      rw [has_fderiv_within_at_univ]\n      exact H.fderiv m hm x\n    Â· intro m hm\n      rw [â† continuous_iff_continuousOn_univ]\n      exact H.cont m hm\n#align has_ftaylor_series_up_to_on_univ_iff has_ftaylor_series_up_to_on_univ_iff\n\n",
 "has_ftaylor_series_up_to_on_top_iff'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆÂ» -/\n/-- In the case that `n = âˆ` we don't need the continuity assumption in\n`has_ftaylor_series_up_to_on`. -/\ntheorem has_ftaylor_series_up_to_on_top_iff' :\n    has_ftaylor_series_up_to_on (Â«exprâˆÂ») f p s â†”\n      (âˆ€ x âˆˆ s, (p x 0).uncurry0 = f x) âˆ§\n        âˆ€ m : â„•, âˆ€ x âˆˆ s, has_fderiv_within_at (fun y => p y m) (p x m.succ).curry_left s x :=\n  âŸ¨-- Everything except for the continuity is trivial:\n  fun h => âŸ¨h.1, fun m => h.2 m (WithTop.coe_lt_top m)âŸ©, fun h =>\n    âŸ¨h.1, fun m _ => h.2 m, fun m _ x hx =>\n      (-- The continuity follows from the existence of a derivative:\n            h.2\n          m x hx).continuous_within_atâŸ©âŸ©\n#align has_ftaylor_series_up_to_on_top_iff' has_ftaylor_series_up_to_on_top_iff'\n\n",
 "has_ftaylor_series_up_to_on_top_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆÂ» -/\ntheorem has_ftaylor_series_up_to_on_top_iff :\n    has_ftaylor_series_up_to_on (Â«exprâˆÂ») f p s â†” âˆ€ n : â„•, has_ftaylor_series_up_to_on n f p s :=\n  by\n  constructor\n  Â· intro H n\n    exact H.of_le le_top\n  Â· intro H\n    constructor\n    Â· exact (H 0).zero_eq\n    Â· intro m hm\n      apply (H m.succ).fderiv_within m (WithTop.coe_lt_coe.2 (lt_add_one m))\n    Â· intro m hm\n      apply (H m).cont m le_rfl\n#align has_ftaylor_series_up_to_on_top_iff has_ftaylor_series_up_to_on_top_iff\n\n",
 "has_ftaylor_series_up_to_on_succ_iff_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ„•âˆÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ„•âˆÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ„•âˆÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ„•âˆÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ„•âˆÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ„•âˆÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ„•âˆÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ„•âˆÂ» -/\n/-- `p` is a Taylor series of `f` up to `n+1` if and only if `p.shift` is a Taylor series up to `n`\nfor `p 1`, which is a derivative of `f`. -/\ntheorem has_ftaylor_series_up_to_on_succ_iff_right {n : â„•} :\n    has_ftaylor_series_up_to_on (n + 1 : â„•) f p s â†”\n      (âˆ€ x âˆˆ s, (p x 0).uncurry0 = f x) âˆ§\n        (âˆ€ x âˆˆ s, has_fderiv_within_at (fun y => p y 0) (p x 1).curry_left s x) âˆ§\n          has_ftaylor_series_up_to_on n (fun x => continuous_multilinear_curry_fin1 ğ•œ E F (p x 1))\n            (fun x => (p x).shift) s :=\n  by\n  constructor\n  Â· intro H\n    refine' âŸ¨H.zero_eq, H.fderiv_within 0 (WithTop.coe_lt_coe.2 (nat.succ_pos n)), _âŸ©\n    constructor\n    Â· intro x hx\n      rfl\n    Â· intro m(hm : (m : Â«exprâ„•âˆÂ») < n)x(hx : x âˆˆ s)\n      have A : (m.succ : Â«exprâ„•âˆÂ») < n.succ := by\n        rw [WithTop.coe_lt_coe] at hmâŠ¢\n        exact nat.lt_succ_iff.mpr hm\n      change\n        has_fderiv_within_at ((continuous_multilinear_curry_right_equiv' ğ•œ m E F).symm âˆ˜ fun y : E => p y m.succ)\n          (p x m.succ.succ).curry_right.curry_left s x\n      rw [linear_isometry_equiv.comp_has_fderiv_within_at_iff']\n      convert H.fderiv_within _ A x hx\n      ext (y v)\n      change (p x m.succ.succ) (snoc (cons y (init v)) (v (last _))) = (p x (nat.succ (nat.succ m))) (cons y v)\n      rw [â† cons_snoc_eq_snoc_cons, snoc_init_self]\n    Â· intro m(hm : (m : Â«exprâ„•âˆÂ») â‰¤ n)\n      have A : (m.succ : Â«exprâ„•âˆÂ») â‰¤ n.succ := by\n        rw [WithTop.coe_le_coe] at hmâŠ¢\n        exact nat.pred_le_iff.mp hm\n      change ContinuousOn ((continuous_multilinear_curry_right_equiv' ğ•œ m E F).symm âˆ˜ fun y : E => p y m.succ) s\n      rw [LinearIsometryEquiv.comp_continuousOn_iff]\n      exact H.cont _ A\n  Â· rintro âŸ¨Hzero_eq, Hfderiv_zero, HtaylorâŸ©\n    constructor\n    Â· exact Hzero_eq\n    Â· intro m(hm : (m : Â«exprâ„•âˆÂ») < n.succ)x(hx : x âˆˆ s)\n      cases m\n      Â· exact Hfderiv_zero x hx\n      Â· have A : (m : Â«exprâ„•âˆÂ») < n := by\n          rw [WithTop.coe_lt_coe] at hmâŠ¢\n          exact nat.lt_of_succ_lt_succ hm\n        have :\n          has_fderiv_within_at ((continuous_multilinear_curry_right_equiv' ğ•œ m E F).symm âˆ˜ fun y : E => p y m.succ)\n            ((p x).shift m.succ).curry_left s x :=\n          Htaylor.fderiv_within _ A x hx\n        rw [linear_isometry_equiv.comp_has_fderiv_within_at_iff'] at this\n        convert this\n        ext (y v)\n        change (p x (nat.succ (nat.succ m))) (cons y v) = (p x m.succ.succ) (snoc (cons y (init v)) (v (last _)))\n        rw [â† cons_snoc_eq_snoc_cons, snoc_init_self]\n    Â· intro m(hm : (m : Â«exprâ„•âˆÂ») â‰¤ n.succ)\n      cases m\n      Â· have : differentiable_on ğ•œ (fun x => p x 0) s := fun x hx => (Hfderiv_zero x hx).differentiable_within_at\n        exact this.continuous_on\n      Â· have A : (m : Â«exprâ„•âˆÂ») â‰¤ n := by\n          rw [WithTop.coe_le_coe] at hmâŠ¢\n          exact nat.lt_succ_iff.mp hm\n        have : ContinuousOn ((continuous_multilinear_curry_right_equiv' ğ•œ m E F).symm âˆ˜ fun y : E => p y m.succ) s :=\n          Htaylor.cont _ A\n        rwa [LinearIsometryEquiv.comp_continuousOn_iff] at this\n#align has_ftaylor_series_up_to_on_succ_iff_right has_ftaylor_series_up_to_on_succ_iff_right\n\n",
 "has_ftaylor_series_up_to_on_succ_iff_left":
 "/-- `p` is a Taylor series of `f` up to `n+1` if and only if `p` is a Taylor series up to `n`, and\n`p (n + 1)` is a derivative of `p n`. -/\ntheorem has_ftaylor_series_up_to_on_succ_iff_left {n : â„•} :\n    has_ftaylor_series_up_to_on (n + 1) f p s â†”\n      has_ftaylor_series_up_to_on n f p s âˆ§\n        (âˆ€ x âˆˆ s, has_fderiv_within_at (fun y => p y n) (p x n.succ).curry_left s x) âˆ§\n          ContinuousOn (fun x => p x (n + 1)) s :=\n  by\n  constructor\n  Â· intro h\n    exact\n      âŸ¨h.of_le (WithTop.coe_le_coe.2 (nat.le_succ n)), h.fderiv_within _ (WithTop.coe_lt_coe.2 (lt_add_one n)),\n        h.cont (n + 1) le_rflâŸ©\n  Â· intro h\n    constructor\n    Â· exact h.1.zero_eq\n    Â· intro m hm\n      by_cases h' : m < n\n      Â· exact h.1.fderiv_within m (WithTop.coe_lt_coe.2 h')\n      Â· have : m = n := Nat.eq_of_lt_succ_of_not_lt (WithTop.coe_lt_coe.1 hm) h'\n        rw [this]\n        exact h.2.1\n    Â· intro m hm\n      by_cases h' : m â‰¤ n\n      Â· apply h.1.cont m (WithTop.coe_le_coe.2 h')\n      Â· have : m = n + 1 := le_antisymm (WithTop.coe_le_coe.1 hm) (not_le.1 h')\n        rw [this]\n        exact h.2.2\n#align has_ftaylor_series_up_to_on_succ_iff_left has_ftaylor_series_up_to_on_succ_iff_left\n\n",
 "has_ftaylor_series_up_to_on":
 "theorem has_ftaylor_series_up_to.has_ftaylor_series_up_to_on (h : has_ftaylor_series_up_to n f p) (s : Set E) :\n    has_ftaylor_series_up_to_on n f p s :=\n  (has_ftaylor_series_up_to_on_univ_iff.2 h).mono (subset_univ _)\n#align has_ftaylor_series_up_to.has_ftaylor_series_up_to_on has_ftaylor_series_up_to.has_ftaylor_series_up_to_on\n\n",
 "has_fderiv_within_at":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ„•âˆÂ» -/\n/-- If a function has a Taylor series at order at least `1`, then the term of order `1` of this\nseries is a derivative of `f`. -/\ntheorem has_ftaylor_series_up_to_on.has_fderiv_within_at (h : has_ftaylor_series_up_to_on n f p s) (hn : 1 â‰¤ n)\n    (hx : x âˆˆ s) : has_fderiv_within_at f (continuous_multilinear_curry_fin1 ğ•œ E F (p x 1)) s x :=\n  by\n  have A : âˆ€ y âˆˆ s, f y = (continuous_multilinear_curry_fin0 ğ•œ E F) (p y 0) :=\n    by\n    intro y hy\n    rw [â† h.zero_eq y hy]\n    rfl\n  suffices H :\n    has_fderiv_within_at (fun y => continuous_multilinear_curry_fin0 ğ•œ E F (p y 0))\n      (continuous_multilinear_curry_fin1 ğ•œ E F (p x 1)) s x\n  Â· exact H.congr A (A x hx)\n  rw [linear_isometry_equiv.comp_has_fderiv_within_at_iff']\n  have : ((0 : â„•) : Â«exprâ„•âˆÂ») < n := lt_of_lt_of_le (WithTop.coe_lt_coe.2 nat.zero_lt_one) hn\n  convert h.fderiv_within _ this x hx\n  ext (y v)\n  change (p x 1) (snoc 0 y) = (p x 1) (cons y v)\n  unfold_coes\n  congr with i\n  rw [Unique.eq_default i]\n  rfl\n#align has_ftaylor_series_up_to_on.has_fderiv_within_at has_ftaylor_series_up_to_on.has_fderiv_within_at\n\n",
 "has_fderiv_at":
 "/-- If a function has a Taylor series at order at least `1`, then the term of order `1` of this\nseries is a derivative of `f`. -/\ntheorem has_ftaylor_series_up_to.has_fderiv_at (h : has_ftaylor_series_up_to n f p) (hn : 1 â‰¤ n) (x : E) :\n    has_fderiv_at f (continuous_multilinear_curry_fin1 ğ•œ E F (p x 1)) x :=\n  by\n  rw [â† has_fderiv_within_at_univ]\n  exact (has_ftaylor_series_up_to_on_univ_iff.2 h).has_fderiv_within_at hn (mem_univ _)\n#align has_ftaylor_series_up_to.has_fderiv_at has_ftaylor_series_up_to.has_fderiv_at\n\n",
 "ftaylor_series_within_univ":
 "theorem ftaylor_series_within_univ : ftaylor_series_within ğ•œ f univ = ftaylor_series ğ•œ f :=\n  by\n  ext1 x; ext1 n\n  change iterated_fderiv_within ğ•œ n f univ x = iterated_fderiv ğ•œ n f x\n  rw [iterated_fderiv_within_univ]\n#align ftaylor_series_within_univ ftaylor_series_within_univ\n\n",
 "ftaylor_series_within":
 "/-- When a function is `C^n` in a set `s` of unique differentiability, it admits\n`ftaylor_series_within ğ•œ f s` as a Taylor series up to order `n` in `s`. -/\ntheorem cont_diff_on.ftaylor_series_within (h : cont_diff_on ğ•œ n f s) (hs : unique_diff_on ğ•œ s) :\n    has_ftaylor_series_up_to_on n f (ftaylor_series_within ğ•œ f s) s :=\n  by\n  constructor\n  Â· intro x hx\n    simp only [ftaylor_series_within, continuous_multilinear_map.uncurry0_apply, iterated_fderiv_within_zero_apply]\n  Â· intro m hm x hx\n    rcases(h x hx) m.succ (ENat.add_one_le_of_lt hm) with âŸ¨u, hu, p, HpâŸ©\n    rw [insert_eq_of_mem hx] at hu\n    rcases mem_nhdsWithin.1 hu with âŸ¨o, o_open, xo, hoâŸ©\n    rw [inter_comm] at ho\n    have : p x m.succ = ftaylor_series_within ğ•œ f s x m.succ :=\n      by\n      change p x m.succ = iterated_fderiv_within ğ•œ m.succ f s x\n      rw [â† iterated_fderiv_within_inter (IsOpen.mem_nhds o_open xo) hs hx]\n      exact (Hp.mono ho).eq_ftaylor_series_of_unique_diff_on le_rfl (hs.inter o_open) âŸ¨hx, xoâŸ©\n    rw [â† this, â† has_fderiv_within_at_inter (IsOpen.mem_nhds o_open xo)]\n    have A : âˆ€ y âˆˆ s âˆ© o, p y m = ftaylor_series_within ğ•œ f s y m :=\n      by\n      rintro y âŸ¨hy, yoâŸ©\n      change p y m = iterated_fderiv_within ğ•œ m f s y\n      rw [â† iterated_fderiv_within_inter (IsOpen.mem_nhds o_open yo) hs hy]\n      exact\n        (Hp.mono ho).eq_ftaylor_series_of_unique_diff_on (WithTop.coe_le_coe.2 (nat.le_succ m)) (hs.inter o_open)\n          âŸ¨hy, yoâŸ©\n    exact\n      ((Hp.mono ho).fderiv_within m (WithTop.coe_lt_coe.2 (lt_add_one m)) x âŸ¨hx, xoâŸ©).congr (fun y hy => (A y hy).symm)\n        (A x âŸ¨hx, xoâŸ©).symm\n  Â· intro m hm\n    apply continuousOn_of_locally_continuousOn\n    intro x hx\n    rcases h x hx m hm with âŸ¨u, hu, p, HpâŸ©\n    rcases mem_nhdsWithin.1 hu with âŸ¨o, o_open, xo, hoâŸ©\n    rw [insert_eq_of_mem hx] at ho\n    rw [inter_comm] at ho\n    refine' âŸ¨o, o_open, xo, _âŸ©\n    have A : âˆ€ y âˆˆ s âˆ© o, p y m = ftaylor_series_within ğ•œ f s y m :=\n      by\n      rintro y âŸ¨hy, yoâŸ©\n      change p y m = iterated_fderiv_within ğ•œ m f s y\n      rw [â† iterated_fderiv_within_inter (IsOpen.mem_nhds o_open yo) hs hy]\n      exact (Hp.mono ho).eq_ftaylor_series_of_unique_diff_on le_rfl (hs.inter o_open) âŸ¨hy, yoâŸ©\n    exact ((Hp.mono ho).cont m le_rfl).congr fun y hy => (A y hy).symm\n#align cont_diff_on.ftaylor_series_within cont_diff_on.ftaylor_series_within\n\n",
 "fderiv_within":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ„•âˆÂ» -/\ntheorem cont_diff_on.fderiv_within (hf : cont_diff_on ğ•œ n f s) (hs : unique_diff_on ğ•œ s) (hmn : m + 1 â‰¤ n) :\n    cont_diff_on ğ•œ m (fun y => fderiv_within ğ•œ f s y) s :=\n  by\n  cases m\n  Â· change Â«exprâˆÂ» + 1 â‰¤ n at hmn\n    have : n = Â«exprâˆÂ» := by simpa using hmn\n    rw [this] at hf\n    exact ((cont_diff_on_top_iff_fderiv_within hs).1 hf).2\n  Â· change (m.succ : Â«exprâ„•âˆÂ») â‰¤ n at hmn\n    exact ((cont_diff_on_succ_iff_fderiv_within hs).1 (hf.of_le hmn)).2\n#align cont_diff_on.fderiv_within cont_diff_on.fderiv_within\n\n",
 "fderiv_of_open":
 "theorem cont_diff_on.fderiv_of_open (hf : cont_diff_on ğ•œ n f s) (hs : IsOpen s) (hmn : m + 1 â‰¤ n) :\n    cont_diff_on ğ•œ m (fun y => fderiv ğ•œ f y) s :=\n  (hf.fderiv_within hs.unique_diff_on hmn).congr fun x hx => (fderiv_within_of_open hs hx).symm\n#align cont_diff_on.fderiv_of_open cont_diff_on.fderiv_of_open\n\n",
 "fderiv_iterated_fderiv":
 "/-- Writing explicitly the derivative of the `n`-th derivative as the composition of a currying\nlinear equiv, and the `n + 1`-th derivative. -/\ntheorem fderiv_iterated_fderiv {n : â„•} :\n    fderiv ğ•œ (iterated_fderiv ğ•œ n f) =\n      (continuous_multilinear_curry_left_equiv ğ•œ (fun i : Fin (n + 1) => E) F).symm âˆ˜ iterated_fderiv ğ•œ (n + 1) f :=\n  by\n  rw [iterated_fderiv_succ_eq_comp_left]\n  ext1 x\n  simp only [Function.comp_apply, LinearIsometryEquiv.symm_apply_apply]\n#align fderiv_iterated_fderiv fderiv_iterated_fderiv\n\n",
 "eventually_has_fderiv_at":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- If a function has a Taylor series at order at least `1` on a neighborhood of `x`, then\nin a neighborhood of `x`, the term of order `1` of this series is a derivative of `f`. -/\ntheorem has_ftaylor_series_up_to_on.eventually_has_fderiv_at (h : has_ftaylor_series_up_to_on n f p s) (hn : 1 â‰¤ n)\n    (hx : s âˆˆ (nhds) x) :\n    Â«exprâˆ€á¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â»\" ((nhds) x)\n      (has_fderiv_at f (continuous_multilinear_curry_fin1 ğ•œ E F (p y 1)) y) :=\n  (eventually_eventually_nhds.2 hx).mono fun y hy => h.has_fderiv_at hn hy\n#align has_ftaylor_series_up_to_on.eventually_has_fderiv_at has_ftaylor_series_up_to_on.eventually_has_fderiv_at\n\n",
 "eventually":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\nprotected theorem cont_diff_at.eventually {n : â„•} (h : cont_diff_at ğ•œ n f x) :\n    Â«exprâˆ€á¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â»\" ((nhds) x)\n      (cont_diff_at ğ•œ n f y) :=\n  by simpa [nhdsWithin_univ] using h.eventually\n#align cont_diff_at.eventually cont_diff_at.eventually\n\n",
 "eq_ftaylor_series_of_unique_diff_on":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ„•âˆÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ„•âˆÂ» -/\n/-- On a set with unique differentiability, any choice of iterated differential has to coincide\nwith the one we have chosen in `iterated_fderiv_within ğ•œ m f s`. -/\ntheorem has_ftaylor_series_up_to_on.eq_ftaylor_series_of_unique_diff_on (h : has_ftaylor_series_up_to_on n f p s)\n    {m : â„•} (hmn : (m : Â«exprâ„•âˆÂ») â‰¤ n) (hs : unique_diff_on ğ•œ s) (hx : x âˆˆ s) :\n    p x m = iterated_fderiv_within ğ•œ m f s x :=\n  by\n  induction' m with m IH generalizing x\n  Â· rw [h.zero_eq' hx, iterated_fderiv_within_zero_eq_comp]\n  Â· have A : (m : Â«exprâ„•âˆÂ») < n := lt_of_lt_of_le (WithTop.coe_lt_coe.2 (lt_add_one m)) hmn\n    have :\n      has_fderiv_within_at (fun y : E => iterated_fderiv_within ğ•œ m f s y)\n        (continuous_multilinear_map.curry_left (p x (nat.succ m))) s x :=\n      (h.fderiv_within m A x hx).congr (fun y hy => (IH (le_of_lt A) hy).symm) (IH (le_of_lt A) hx).symm\n    rw [iterated_fderiv_within_succ_eq_comp_left, Function.comp_apply, this.fderiv_within (hs x hx)]\n    exact (continuous_multilinear_map.uncurry_curry_left _).symm\n#align has_ftaylor_series_up_to_on.eq_ftaylor_series_of_unique_diff_on has_ftaylor_series_up_to_on.eq_ftaylor_series_of_unique_diff_on\n\n",
 "differentiable_within_at'":
 "/-- If a function is `C^n` within a set at a point, with `n â‰¥ 1`, then it is differentiable\nwithin this set at this point. -/\ntheorem cont_diff_within_at.differentiable_within_at' (h : cont_diff_within_at ğ•œ n f s x) (hn : 1 â‰¤ n) :\n    differentiable_within_at ğ•œ f (insert x s) x :=\n  by\n  rcases h 1 hn with âŸ¨u, hu, p, HâŸ©\n  rcases mem_nhdsWithin.1 hu with âŸ¨t, t_open, xt, tuâŸ©\n  rw [inter_comm] at tu\n  have := ((H.mono tu).differentiable_on le_rfl) x âŸ¨mem_insert x s, xtâŸ©\n  exact (differentiable_within_at_inter (IsOpen.mem_nhds t_open xt)).1 this\n#align cont_diff_within_at.differentiable_within_at' cont_diff_within_at.differentiable_within_at'\n\n",
 "differentiable_within_at":
 "theorem cont_diff_within_at.differentiable_within_at (h : cont_diff_within_at ğ•œ n f s x) (hn : 1 â‰¤ n) :\n    differentiable_within_at ğ•œ f s x :=\n  (h.differentiable_within_at' hn).mono (subset_insert x s)\n#align cont_diff_within_at.differentiable_within_at cont_diff_within_at.differentiable_within_at\n\n",
 "differentiable_on_iterated_fderiv_within":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ„•âˆÂ» -/\ntheorem cont_diff_on.differentiable_on_iterated_fderiv_within {m : â„•} (h : cont_diff_on ğ•œ n f s)\n    (hmn : (m : Â«exprâ„•âˆÂ») < n) (hs : unique_diff_on ğ•œ s) : differentiable_on ğ•œ (iterated_fderiv_within ğ•œ m f s) s :=\n  fun x hx => ((h.ftaylor_series_within hs).fderiv_within m hmn x hx).differentiable_within_at\n#align cont_diff_on.differentiable_on_iterated_fderiv_within cont_diff_on.differentiable_on_iterated_fderiv_within\n\n",
 "differentiable_on":
 "/-- If a function is `C^n` on a set with `n â‰¥ 1`, then it is differentiable there. -/\ntheorem cont_diff_on.differentiable_on (h : cont_diff_on ğ•œ n f s) (hn : 1 â‰¤ n) : differentiable_on ğ•œ f s := fun x hx =>\n  (h x hx).differentiable_within_at hn\n#align cont_diff_on.differentiable_on cont_diff_on.differentiable_on\n\n",
 "differentiable_iterated_fderiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ„•âˆÂ» -/\n/-- If `f` is `C^n` then its `m`-times iterated derivative is differentiable for `m < n`. -/\ntheorem cont_diff.differentiable_iterated_fderiv {m : â„•} (hm : (m : Â«exprâ„•âˆÂ») < n) (hf : cont_diff ğ•œ n f) :\n    differentiable ğ•œ fun x => iterated_fderiv ğ•œ m f x :=\n  (cont_diff_iff_continuous_differentiable.mp hf).2 m hm\n#align cont_diff.differentiable_iterated_fderiv cont_diff.differentiable_iterated_fderiv\n\n",
 "differentiable_at":
 "/-- If a function is `C^n` with `n â‰¥ 1` at a point, then it is differentiable there. -/\ntheorem cont_diff_at.differentiable_at (h : cont_diff_at ğ•œ n f x) (hn : 1 â‰¤ n) : differentiable_at ğ•œ f x := by\n  simpa [hn, differentiable_within_at_univ] using h.differentiable_within_at\n#align cont_diff_at.differentiable_at cont_diff_at.differentiable_at\n\n",
 "differentiable":
 "/-- If a function is `C^n` with `n â‰¥ 1`, then it is differentiable. -/\ntheorem cont_diff.differentiable (h : cont_diff ğ•œ n f) (hn : 1 â‰¤ n) : differentiable ğ•œ f :=\n  differentiable_on_univ.1 <| (cont_diff_on_univ.2 h).differentiable_on hn\n#align cont_diff.differentiable cont_diff.differentiable\n\n",
 "continuous_within_at":
 "theorem cont_diff_within_at.continuous_within_at (h : cont_diff_within_at ğ•œ n f s x) : ContinuousWithinAt f s x :=\n  by\n  rcases h 0 bot_le with âŸ¨u, hu, p, HâŸ©\n  rw [mem_nhdsWithin_insert] at hu\n  exact (H.continuous_on.continuous_within_at hu.1).mono_of_mem hu.2\n#align cont_diff_within_at.continuous_within_at cont_diff_within_at.continuous_within_at\n\n",
 "continuous_on_iterated_fderiv_within":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ„•âˆÂ» -/\ntheorem cont_diff_on.continuous_on_iterated_fderiv_within {m : â„•} (h : cont_diff_on ğ•œ n f s) (hmn : (m : Â«exprâ„•âˆÂ») â‰¤ n)\n    (hs : unique_diff_on ğ•œ s) : ContinuousOn (iterated_fderiv_within ğ•œ m f s) s :=\n  (h.ftaylor_series_within hs).cont m hmn\n#align cont_diff_on.continuous_on_iterated_fderiv_within cont_diff_on.continuous_on_iterated_fderiv_within\n\n",
 "continuous_on_fderiv_within":
 "theorem cont_diff_on.continuous_on_fderiv_within (h : cont_diff_on ğ•œ n f s) (hs : unique_diff_on ğ•œ s) (hn : 1 â‰¤ n) :\n    ContinuousOn (fun x => fderiv_within ğ•œ f s x) s :=\n  ((cont_diff_on_succ_iff_fderiv_within hs).1 (h.of_le hn)).2.continuous_on\n#align cont_diff_on.continuous_on_fderiv_within cont_diff_on.continuous_on_fderiv_within\n\n",
 "continuous_on_fderiv_of_open":
 "theorem cont_diff_on.continuous_on_fderiv_of_open (h : cont_diff_on ğ•œ n f s) (hs : IsOpen s) (hn : 1 â‰¤ n) :\n    ContinuousOn (fun x => fderiv ğ•œ f x) s :=\n  ((cont_diff_on_succ_iff_fderiv_of_open hs).1 (h.of_le hn)).2.continuous_on\n#align cont_diff_on.continuous_on_fderiv_of_open cont_diff_on.continuous_on_fderiv_of_open\n\n",
 "continuous_on":
 "theorem cont_diff_on.continuous_on (h : cont_diff_on ğ•œ n f s) : ContinuousOn f s := fun x hx =>\n  (h x hx).continuous_within_at\n#align cont_diff_on.continuous_on cont_diff_on.continuous_on\n\n",
 "continuous_iterated_fderiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ„•âˆÂ» -/\n/-- If `f` is `C^n` then its `m`-times iterated derivative is continuous for `m â‰¤ n`. -/\ntheorem cont_diff.continuous_iterated_fderiv {m : â„•} (hm : (m : Â«exprâ„•âˆÂ») â‰¤ n) (hf : cont_diff ğ•œ n f) :\n    Continuous fun x => iterated_fderiv ğ•œ m f x :=\n  (cont_diff_iff_continuous_differentiable.mp hf).1 m hm\n#align cont_diff.continuous_iterated_fderiv cont_diff.continuous_iterated_fderiv\n\n",
 "continuous_fderiv_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/-- If a function is at least `C^1`, its bundled derivative (mapping `(x, v)` to `Df(x) v`) is\ncontinuous. -/\ntheorem cont_diff.continuous_fderiv_apply (h : cont_diff ğ•œ n f) (hn : 1 â‰¤ n) :\n    Continuous fun p : E Ã— E => (fderiv ğ•œ f p.1 : E â†’ F) p.2 :=\n  have A : Continuous fun q : Â«expr â†’L[ ] Â» E ğ•œ F Ã— E => q.1 q.2 := is_bounded_bilinear_map_apply.continuous\n  have B : Continuous fun p : E Ã— E => (fderiv ğ•œ f p.1, p.2) :=\n    ((h.continuous_fderiv hn).comp continuous_fst).prod_mk continuous_snd\n  A.comp B\n#align cont_diff.continuous_fderiv_apply cont_diff.continuous_fderiv_apply\n\n",
 "continuous_fderiv":
 "theorem cont_diff.continuous_fderiv (h : cont_diff ğ•œ n f) (hn : 1 â‰¤ n) : Continuous fun x => fderiv ğ•œ f x :=\n  (cont_diff_succ_iff_fderiv.1 (h.of_le hn)).2.continuous\n#align cont_diff.continuous_fderiv cont_diff.continuous_fderiv\n\n",
 "continuous_at":
 "theorem cont_diff_at.continuous_at (h : cont_diff_at ğ•œ n f x) : ContinuousAt f x := by\n  simpa [continuousWithinAt_univ] using h.continuous_within_at\n#align cont_diff_at.continuous_at cont_diff_at.continuous_at\n\n",
 "continuous":
 "theorem cont_diff.continuous (h : cont_diff ğ•œ n f) : Continuous f :=\n  cont_diff_zero.1 (h.of_le bot_le)\n#align cont_diff.continuous cont_diff.continuous\n\n",
 "cont_diff_zero":
 "@[simp]\ntheorem cont_diff_zero : cont_diff ğ•œ 0 f â†” Continuous f :=\n  by\n  rw [â† cont_diff_on_univ, continuous_iff_continuousOn_univ]\n  exact cont_diff_on_zero\n#align cont_diff_zero cont_diff_zero\n\n",
 "cont_diff_within_at_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\ntheorem cont_diff_within_at_zero (hx : x âˆˆ s) :\n    cont_diff_within_at ğ•œ 0 f s x â†” âˆƒ u âˆˆ nhds_within s x, ContinuousOn f (s âˆ© u) :=\n  by\n  constructor\n  Â· intro h\n    obtain âŸ¨u, H, p, hpâŸ© := h 0 (by norm_num)\n    refine' âŸ¨u, _, _âŸ©\n    Â· simpa [hx] using H\n    Â· simp only [WithTop.coe_zero, has_ftaylor_series_up_to_on_zero_iff] at hp\n      exact hp.1.mono (inter_subset_right s u)\n  Â· rintro âŸ¨u, H, huâŸ©\n    rw [â† cont_diff_within_at_inter' H]\n    have h' : x âˆˆ s âˆ© u := âŸ¨hx, mem_of_mem_nhdsWithin hx HâŸ©\n    exact (cont_diff_on_zero.mpr hu).cont_diff_within_at h'\n#align cont_diff_within_at_zero cont_diff_within_at_zero\n\n",
 "cont_diff_within_at_univ":
 "theorem cont_diff_within_at_univ : cont_diff_within_at ğ•œ n f univ x â†” cont_diff_at ğ•œ n f x :=\n  iff.rfl\n#align cont_diff_within_at_univ cont_diff_within_at_univ\n\n",
 "cont_diff_within_at_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆÂ» -/\ntheorem cont_diff_within_at_top : cont_diff_within_at ğ•œ (Â«exprâˆÂ») f s x â†” âˆ€ n : â„•, cont_diff_within_at ğ•œ n f s x :=\n  cont_diff_within_at_iff_forall_nat_le.trans <| by simp only [forall_prop_of_true, le_top]\n#align cont_diff_within_at_top cont_diff_within_at_top\n\n",
 "cont_diff_within_at_succ_iff_has_fderiv_within_at'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/-- A version of `cont_diff_within_at_succ_iff_has_fderiv_within_at` where all derivatives\n  are taken within the same set. -/\ntheorem cont_diff_within_at_succ_iff_has_fderiv_within_at' {n : â„•} :\n    cont_diff_within_at ğ•œ (n + 1 : â„•) f s x â†”\n      âˆƒ u âˆˆ nhds_within (insert x s) x,\n        u âŠ† insert x s âˆ§\n          âˆƒ f' : E â†’ Â«expr â†’L[ ] Â» E ğ•œ F,\n            (âˆ€ x âˆˆ u, has_fderiv_within_at f (f' x) s x) âˆ§ cont_diff_within_at ğ•œ n f' s x :=\n  by\n  refine' âŸ¨fun hf => _, _âŸ©\n  Â· obtain âŸ¨u, hu, f', huf', hf'âŸ© := cont_diff_within_at_succ_iff_has_fderiv_within_at.mp hf\n    obtain âŸ¨w, hw, hxw, hwuâŸ© := mem_nhds_within.mp hu\n    rw [inter_comm] at hwu\n    refine' âŸ¨insert x s âˆ© w, inter_mem_nhdsWithin _ (hw.mem_nhds hxw), inter_subset_left _ _, f', fun y hy => _, _âŸ©\n    Â· refine' ((huf' y <| hwu hy).mono hwu).mono_of_mem _\n      refine' mem_of_superset _ (inter_subset_inter_left _ (subset_insert _ _))\n      refine' inter_mem_nhdsWithin _ (hw.mem_nhds hy.2)\n    Â· exact hf'.mono_of_mem (nhdsWithin_mono _ (subset_insert _ _) hu)\n  Â· rw [â† cont_diff_within_at_insert, cont_diff_within_at_succ_iff_has_fderiv_within_at,\n      insert_eq_of_mem (mem_insert _ _)]\n    rintro âŸ¨u, hu, hus, f', huf', hf'âŸ©\n    refine' âŸ¨u, hu, f', fun y hy => (huf' y hy).insert'.mono hus, hf'.insert.mono husâŸ©\n#align cont_diff_within_at_succ_iff_has_fderiv_within_at' cont_diff_within_at_succ_iff_has_fderiv_within_at'\n\n",
 "cont_diff_within_at_succ_iff_has_fderiv_within_at":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/-- A function is `C^(n + 1)` on a domain iff locally, it has a derivative which is `C^n`. -/\ntheorem cont_diff_within_at_succ_iff_has_fderiv_within_at {n : â„•} :\n    cont_diff_within_at ğ•œ (n + 1 : â„•) f s x â†”\n      âˆƒ u âˆˆ nhds_within (insert x s) x,\n        âˆƒ f' : E â†’ Â«expr â†’L[ ] Â» E ğ•œ F, (âˆ€ x âˆˆ u, has_fderiv_within_at f (f' x) u x) âˆ§ cont_diff_within_at ğ•œ n f' u x :=\n  by\n  constructor\n  Â· intro h\n    rcases h n.succ le_rfl with âŸ¨u, hu, p, HpâŸ©\n    refine'\n      âŸ¨u, hu, fun y => (continuous_multilinear_curry_fin1 ğ•œ E F) (p y 1), fun y hy =>\n        Hp.has_fderiv_within_at (WithTop.coe_le_coe.2 (nat.le_add_left 1 n)) hy, _âŸ©\n    intro m hm\n    refine' âŸ¨u, _, fun y : E => (p y).shift, _âŸ©\n    Â· convert self_mem_nhdsWithin\n      have : x âˆˆ insert x s := by simp\n      exact insert_eq_of_mem (mem_of_mem_nhdsWithin this hu)\n    Â· rw [has_ftaylor_series_up_to_on_succ_iff_right] at Hp\n      exact Hp.2.2.of_le hm\n  Â· rintro âŸ¨u, hu, f', f'_eq_deriv, Hf'âŸ©\n    rw [cont_diff_within_at_nat]\n    rcases Hf' n le_rfl with âŸ¨v, hv, p', Hp'âŸ©\n    refine' âŸ¨v âˆ© u, _, fun x => (p' x).unshift (f x), _âŸ©\n    Â· apply Filter.inter_mem _ hu\n      apply nhdsWithin_le_of_mem hu\n      exact nhdsWithin_mono _ (subset_insert x u) hv\n    Â· rw [has_ftaylor_series_up_to_on_succ_iff_right]\n      refine' âŸ¨fun y hy => rfl, fun y hy => _, _âŸ©\n      Â· change\n          has_fderiv_within_at (fun z => (continuous_multilinear_curry_fin0 ğ•œ E F).symm (f z))\n            (formal_multilinear_series.unshift (p' y) (f y) 1).curry_left (v âˆ© u) y\n        rw [linear_isometry_equiv.comp_has_fderiv_within_at_iff']\n        convert(f'_eq_deriv y hy.2).mono (inter_subset_right v u)\n        rw [â† Hp'.zero_eq y hy.1]\n        ext z\n        change ((p' y 0) (init (@cons 0 (fun i => E) z 0))) (@cons 0 (fun i => E) z 0 (last 0)) = ((p' y 0) 0) z\n        unfold_coes\n        congr\n        decide\n      Â· convert(Hp'.mono (inter_subset_left v u)).congr fun x hx => Hp'.zero_eq x hx.1\n        Â· ext (x y)\n          change p' x 0 (init (@snoc 0 (fun i : Fin 1 => E) 0 y)) y = p' x 0 0 y\n          rw [init_snoc]\n        Â· ext (x k v y)\n          change\n            p' x k (init (@snoc k (fun i : Fin k.succ => E) v y)) (@snoc k (fun i : Fin k.succ => E) v y (last k)) =\n              p' x k v y\n          rw [snoc_last, init_snoc]\n#align cont_diff_within_at_succ_iff_has_fderiv_within_at cont_diff_within_at_succ_iff_has_fderiv_within_at\n\n",
 "cont_diff_within_at_nat":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\ntheorem cont_diff_within_at_nat {n : â„•} :\n    cont_diff_within_at ğ•œ n f s x â†”\n      âˆƒ u âˆˆ nhds_within (insert x s) x,\n        âˆƒ p : E â†’ formal_multilinear_series ğ•œ E F, has_ftaylor_series_up_to_on n f p u :=\n  âŸ¨fun H => H n le_rfl, fun âŸ¨u, hu, p, hpâŸ© m hm => âŸ¨u, hu, p, hp.of_le hmâŸ©âŸ©\n#align cont_diff_within_at_nat cont_diff_within_at_nat\n\n",
 "cont_diff_within_at_inter'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\ntheorem cont_diff_within_at_inter' (h : t âˆˆ nhds_within s x) :\n    cont_diff_within_at ğ•œ n f (s âˆ© t) x â†” cont_diff_within_at ğ•œ n f s x :=\n  cont_diff_within_at_congr_nhds <| Eq.symm <| nhdsWithin_restrict'' _ h\n#align cont_diff_within_at_inter' cont_diff_within_at_inter'\n\n",
 "cont_diff_within_at_inter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem cont_diff_within_at_inter (h : t âˆˆ (nhds) x) :\n    cont_diff_within_at ğ•œ n f (s âˆ© t) x â†” cont_diff_within_at ğ•œ n f s x :=\n  cont_diff_within_at_inter' (mem_nhdsWithin_of_mem_nhds h)\n#align cont_diff_within_at_inter cont_diff_within_at_inter\n\n",
 "cont_diff_within_at_insert":
 "theorem cont_diff_within_at_insert {y : E} : cont_diff_within_at ğ•œ n f (insert y s) x â†” cont_diff_within_at ğ•œ n f s x :=\n  by\n  simp_rw [cont_diff_within_at]\n  rcases eq_or_ne x y with (rfl | h)\n  Â· simp_rw [insert_eq_of_mem (mem_insert _ _)]\n  simp_rw [insert_comm x y, nhdsWithin_insert_of_ne h]\n#align cont_diff_within_at_insert cont_diff_within_at_insert\n\n",
 "cont_diff_within_at_iff_forall_nat_le":
 "theorem cont_diff_within_at_iff_forall_nat_le :\n    cont_diff_within_at ğ•œ n f s x â†” âˆ€ m : â„•, â†‘m â‰¤ n â†’ cont_diff_within_at ğ•œ m f s x :=\n  âŸ¨fun H m hm => H.of_le hm, fun H m hm => H m hm _ le_rflâŸ©\n#align cont_diff_within_at_iff_forall_nat_le cont_diff_within_at_iff_forall_nat_le\n\n",
 "cont_diff_within_at_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr =á¶ [ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\ntheorem filter.eventually_eq.cont_diff_within_at_iff (hâ‚ : Â«expr =á¶ [ ] Â» fâ‚ (nhds_within s x) f) (hx : fâ‚ x = f x) :\n    cont_diff_within_at ğ•œ n fâ‚ s x â†” cont_diff_within_at ğ•œ n f s x :=\n  âŸ¨fun H => cont_diff_within_at.congr_of_eventually_eq H hâ‚.symm hx.symm, fun H => H.congr_of_eventually_eq hâ‚ hxâŸ©\n#align filter.eventually_eq.cont_diff_within_at_iff filter.eventually_eq.cont_diff_within_at_iff\n\n",
 "cont_diff_within_at_congr_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\ntheorem cont_diff_within_at_congr_nhds {t : Set E} (hst : nhds_within s x = nhds_within t x) :\n    cont_diff_within_at ğ•œ n f s x â†” cont_diff_within_at ğ•œ n f t x :=\n  âŸ¨fun h => h.congr_nhds hst, fun h => h.congr_nhds hst.symmâŸ©\n#align cont_diff_within_at_congr_nhds cont_diff_within_at_congr_nhds\n\n",
 "cont_diff_within_at":
 "theorem cont_diff.cont_diff_within_at (h : cont_diff ğ•œ n f) : cont_diff_within_at ğ•œ n f s x :=\n  h.cont_diff_at.cont_diff_within_at\n#align cont_diff.cont_diff_within_at cont_diff.cont_diff_within_at\n\n",
 "cont_diff_top_iff_fderiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆÂ» -/\n/-- A function is `C^âˆ` if and only if it is differentiable,\nand its derivative (formulated in terms of `fderiv`) is `C^âˆ`. -/\ntheorem cont_diff_top_iff_fderiv :\n    cont_diff ğ•œ (Â«exprâˆÂ») f â†” differentiable ğ•œ f âˆ§ cont_diff ğ•œ (Â«exprâˆÂ») fun y => fderiv ğ•œ f y :=\n  by\n  simp only [â† cont_diff_on_univ, â† differentiable_on_univ, â† fderiv_within_univ]\n  rw [cont_diff_on_top_iff_fderiv_within unique_diff_on_univ]\n#align cont_diff_top_iff_fderiv cont_diff_top_iff_fderiv\n\n",
 "cont_diff_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆÂ» -/\ntheorem cont_diff_top : cont_diff ğ•œ (Â«exprâˆÂ») f â†” âˆ€ n : â„•, cont_diff ğ•œ n f := by\n  simp [cont_diff_on_univ.symm, cont_diff_on_top]\n#align cont_diff_top cont_diff_top\n\n",
 "cont_diff_succ_iff_has_fderiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/-- A function is `C^(n+1)` iff it has a `C^n` derivative. -/\ntheorem cont_diff_succ_iff_has_fderiv {n : â„•} :\n    cont_diff ğ•œ (n + 1 : â„•) f â†” âˆƒ f' : E â†’ Â«expr â†’L[ ] Â» E ğ•œ F, cont_diff ğ•œ n f' âˆ§ âˆ€ x, has_fderiv_at f (f' x) x := by\n  simp only [â† cont_diff_on_univ, â† has_fderiv_within_at_univ,\n    cont_diff_on_succ_iff_has_fderiv_within unique_diff_on_univ, Set.mem_univ, forall_true_left]\n#align cont_diff_succ_iff_has_fderiv cont_diff_succ_iff_has_fderiv\n\n",
 "cont_diff_succ_iff_fderiv":
 "/-- A function is `C^(n + 1)` if and only if it is differentiable,\nand its derivative (formulated in terms of `fderiv`) is `C^n`. -/\ntheorem cont_diff_succ_iff_fderiv {n : â„•} :\n    cont_diff ğ•œ (n + 1 : â„•) f â†” differentiable ğ•œ f âˆ§ cont_diff ğ•œ n fun y => fderiv ğ•œ f y := by\n  simp only [â† cont_diff_on_univ, â† differentiable_on_univ, â† fderiv_within_univ,\n    cont_diff_on_succ_iff_fderiv_within unique_diff_on_univ]\n#align cont_diff_succ_iff_fderiv cont_diff_succ_iff_fderiv\n\n",
 "cont_diff_one_iff_fderiv":
 "theorem cont_diff_one_iff_fderiv : cont_diff ğ•œ 1 f â†” differentiable ğ•œ f âˆ§ Continuous (fderiv ğ•œ f) :=\n  cont_diff_succ_iff_fderiv.trans <| iff.rfl.and cont_diff_zero\n#align cont_diff_one_iff_fderiv cont_diff_one_iff_fderiv\n\n",
 "cont_diff_on_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ„•âˆÂ» -/\n@[simp]\ntheorem cont_diff_on_zero : cont_diff_on ğ•œ 0 f s â†” ContinuousOn f s :=\n  by\n  refine' âŸ¨fun H => H.continuous_on, fun H => _âŸ©\n  intro x hx m hm\n  have : (m : Â«exprâ„•âˆÂ») = 0 := le_antisymm hm bot_le\n  rw [this]\n  refine' âŸ¨insert x s, self_mem_nhdsWithin, ftaylor_series_within ğ•œ f s, _âŸ©\n  rw [has_ftaylor_series_up_to_on_zero_iff]\n  exact âŸ¨by rwa [insert_eq_of_mem hx], fun x hx => by simp [ftaylor_series_within]âŸ©\n#align cont_diff_on_zero cont_diff_on_zero\n\n",
 "cont_diff_on_univ":
 "theorem cont_diff_on_univ : cont_diff_on ğ•œ n f univ â†” cont_diff ğ•œ n f :=\n  by\n  constructor\n  Â· intro H\n    use ftaylor_series_within ğ•œ f univ\n    rw [â† has_ftaylor_series_up_to_on_univ_iff]\n    exact H.ftaylor_series_within unique_diff_on_univ\n  Â· rintro âŸ¨p, hpâŸ© x hx m hm\n    exact âŸ¨univ, filter.univ_sets _, p, (hp.has_ftaylor_series_up_to_on univ).of_le hmâŸ©\n#align cont_diff_on_univ cont_diff_on_univ\n\n",
 "cont_diff_on_top_iff_fderiv_within":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ„•âˆÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆÂ» -/\n/-- A function is `C^âˆ` on a domain with unique derivatives if and only if it is differentiable\nthere, and its derivative (expressed with `fderiv_within`) is `C^âˆ`. -/\ntheorem cont_diff_on_top_iff_fderiv_within (hs : unique_diff_on ğ•œ s) :\n    cont_diff_on ğ•œ (Â«exprâˆÂ») f s â†”\n      differentiable_on ğ•œ f s âˆ§ cont_diff_on ğ•œ (Â«exprâˆÂ») (fun y => fderiv_within ğ•œ f s y) s :=\n  by\n  constructor\n  Â· intro h\n    refine' âŸ¨h.differentiable_on le_top, _âŸ©\n    apply cont_diff_on_top.2 fun n => ((cont_diff_on_succ_iff_fderiv_within hs).1 _).2\n    exact h.of_le le_top\n  Â· intro h\n    refine' cont_diff_on_top.2 fun n => _\n    have A : (n : Â«exprâ„•âˆÂ») â‰¤ Â«exprâˆÂ» := le_top\n    apply ((cont_diff_on_succ_iff_fderiv_within hs).2 âŸ¨h.1, h.2.of_le AâŸ©).of_le\n    exact WithTop.coe_le_coe.2 (nat.le_succ n)\n#align cont_diff_on_top_iff_fderiv_within cont_diff_on_top_iff_fderiv_within\n\n",
 "cont_diff_on_top_iff_fderiv_of_open":
 "/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:73:14: unsupported tactic `congrm #[[expr Â«expr âˆ§ Â»(_, _)]] -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆÂ» -/\n/-- A function is `C^âˆ` on an open domain if and only if it is differentiable there, and its\nderivative (expressed with `fderiv`) is `C^âˆ`. -/\ntheorem cont_diff_on_top_iff_fderiv_of_open (hs : IsOpen s) :\n    cont_diff_on ğ•œ (Â«exprâˆÂ») f s â†” differentiable_on ğ•œ f s âˆ§ cont_diff_on ğ•œ (Â«exprâˆÂ») (fun y => fderiv ğ•œ f y) s :=\n  by\n  rw [cont_diff_on_top_iff_fderiv_within hs.unique_diff_on]\n  trace\n    \"./././Mathport/Syntax/Translate/Tactic/Builtin.lean:73:14: unsupported tactic `congrm #[[expr Â«expr âˆ§ Â»(_, _)]]\"\n  apply cont_diff_on_congr\n  intro x hx\n  exact fderiv_within_of_open hs hx\n#align cont_diff_on_top_iff_fderiv_of_open cont_diff_on_top_iff_fderiv_of_open\n\n",
 "cont_diff_on_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆÂ» -/\ntheorem cont_diff_on_top : cont_diff_on ğ•œ (Â«exprâˆÂ») f s â†” âˆ€ n : â„•, cont_diff_on ğ•œ n f s :=\n  cont_diff_on_iff_forall_nat_le.trans <| by simp only [le_top, forall_prop_of_true]\n#align cont_diff_on_top cont_diff_on_top\n\n",
 "cont_diff_on_succ_of_fderiv_within":
 "theorem cont_diff_on_succ_of_fderiv_within {n : â„•} (hf : differentiable_on ğ•œ f s)\n    (h : cont_diff_on ğ•œ n (fun y => fderiv_within ğ•œ f s y) s) : cont_diff_on ğ•œ (n + 1 : â„•) f s :=\n  by\n  intro x hx\n  rw [cont_diff_within_at_succ_iff_has_fderiv_within_at, insert_eq_of_mem hx]\n  exact âŸ¨s, self_mem_nhdsWithin, fderiv_within ğ•œ f s, fun y hy => (hf y hy).has_fderiv_within_at, h x hxâŸ©\n#align cont_diff_on_succ_of_fderiv_within cont_diff_on_succ_of_fderiv_within\n\n",
 "cont_diff_on_succ_iff_has_fderiv_within_at":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/-- A function is `C^(n + 1)` on a domain iff locally, it has a derivative which is `C^n`. -/\ntheorem cont_diff_on_succ_iff_has_fderiv_within_at {n : â„•} :\n    cont_diff_on ğ•œ (n + 1 : â„•) f s â†”\n      âˆ€ x âˆˆ s,\n        âˆƒ u âˆˆ nhds_within (insert x s) x,\n          âˆƒ f' : E â†’ Â«expr â†’L[ ] Â» E ğ•œ F, (âˆ€ x âˆˆ u, has_fderiv_within_at f (f' x) u x) âˆ§ cont_diff_on ğ•œ n f' u :=\n  by\n  constructor\n  Â· intro h x hx\n    rcases(h x hx) n.succ le_rfl with âŸ¨u, hu, p, HpâŸ©\n    refine'\n      âŸ¨u, hu, fun y => (continuous_multilinear_curry_fin1 ğ•œ E F) (p y 1), fun y hy =>\n        Hp.has_fderiv_within_at (WithTop.coe_le_coe.2 (nat.le_add_left 1 n)) hy, _âŸ©\n    rw [has_ftaylor_series_up_to_on_succ_iff_right] at Hp\n    intro z hz m hm\n    refine' âŸ¨u, _, fun x : E => (p x).shift, Hp.2.2.of_le hmâŸ©\n    convert self_mem_nhdsWithin\n    exact insert_eq_of_mem hz\n  Â· intro h x hx\n    rw [cont_diff_within_at_succ_iff_has_fderiv_within_at]\n    rcases h x hx with âŸ¨u, u_nhbd, f', hu, hf'âŸ©\n    have : x âˆˆ u := mem_of_mem_nhdsWithin (mem_insert _ _) u_nhbd\n    exact âŸ¨u, u_nhbd, f', hu, hf' x thisâŸ©\n#align cont_diff_on_succ_iff_has_fderiv_within_at cont_diff_on_succ_iff_has_fderiv_within_at\n\n",
 "cont_diff_on_succ_iff_has_fderiv_within":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\ntheorem cont_diff_on_succ_iff_has_fderiv_within {n : â„•} (hs : unique_diff_on ğ•œ s) :\n    cont_diff_on ğ•œ (n + 1 : â„•) f s â†”\n      âˆƒ f' : E â†’ Â«expr â†’L[ ] Â» E ğ•œ F, cont_diff_on ğ•œ n f' s âˆ§ âˆ€ x, x âˆˆ s â†’ has_fderiv_within_at f (f' x) s x :=\n  by\n  rw [cont_diff_on_succ_iff_fderiv_within hs]\n  refine' âŸ¨fun h => âŸ¨fderiv_within ğ•œ f s, h.2, fun x hx => (h.1 x hx).has_fderiv_within_atâŸ©, fun h => _âŸ©\n  rcases h with âŸ¨f', h1, h2âŸ©\n  refine' âŸ¨fun x hx => (h2 x hx).differentiable_within_at, fun x hx => _âŸ©\n  exact (h1 x hx).congr' (fun y hy => (h2 y hy).fderiv_within (hs y hy)) hx\n#align cont_diff_on_succ_iff_has_fderiv_within cont_diff_on_succ_iff_has_fderiv_within\n\n",
 "cont_diff_on_succ_iff_fderiv_within":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/-- A function is `C^(n + 1)` on a domain with unique derivatives if and only if it is\ndifferentiable there, and its derivative (expressed with `fderiv_within`) is `C^n`. -/\ntheorem cont_diff_on_succ_iff_fderiv_within {n : â„•} (hs : unique_diff_on ğ•œ s) :\n    cont_diff_on ğ•œ (n + 1 : â„•) f s â†” differentiable_on ğ•œ f s âˆ§ cont_diff_on ğ•œ n (fun y => fderiv_within ğ•œ f s y) s :=\n  by\n  refine' âŸ¨fun H => _, fun h => cont_diff_on_succ_of_fderiv_within h.1 h.2âŸ©\n  refine' âŸ¨H.differentiable_on (WithTop.coe_le_coe.2 (nat.le_add_left 1 n)), fun x hx => _âŸ©\n  rcases cont_diff_within_at_succ_iff_has_fderiv_within_at.1 (H x hx) with âŸ¨u, hu, f', hff', hf'âŸ©\n  rcases mem_nhdsWithin.1 hu with âŸ¨o, o_open, xo, hoâŸ©\n  rw [inter_comm, insert_eq_of_mem hx] at ho\n  have := hf'.mono ho\n  rw [cont_diff_within_at_inter' (mem_nhdsWithin_of_mem_nhds (IsOpen.mem_nhds o_open xo))] at this\n  apply this.congr_of_eventually_eq' _ hx\n  have : o âˆ© s âˆˆ nhds_within s x := mem_nhdsWithin.2 âŸ¨o, o_open, xo, subset.refl _âŸ©\n  rw [inter_comm] at this\n  apply Filter.eventuallyEq_of_mem this fun y hy => _\n  have A : fderiv_within ğ•œ f (s âˆ© o) y = f' y := ((hff' y (ho hy)).mono ho).fderiv_within (hs.inter o_open y hy)\n  rwa [fderiv_within_inter (IsOpen.mem_nhds o_open hy.2) (hs y hy.1)] at A\n#align cont_diff_on_succ_iff_fderiv_within cont_diff_on_succ_iff_fderiv_within\n\n",
 "cont_diff_on_succ_iff_fderiv_of_open":
 "/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:73:14: unsupported tactic `congrm #[[expr Â«expr âˆ§ Â»(_, _)]] -/\n/-- A function is `C^(n + 1)` on an open domain if and only if it is\ndifferentiable there, and its derivative (expressed with `fderiv`) is `C^n`. -/\ntheorem cont_diff_on_succ_iff_fderiv_of_open {n : â„•} (hs : IsOpen s) :\n    cont_diff_on ğ•œ (n + 1 : â„•) f s â†” differentiable_on ğ•œ f s âˆ§ cont_diff_on ğ•œ n (fun y => fderiv ğ•œ f y) s :=\n  by\n  rw [cont_diff_on_succ_iff_fderiv_within hs.unique_diff_on]\n  trace\n    \"./././Mathport/Syntax/Translate/Tactic/Builtin.lean:73:14: unsupported tactic `congrm #[[expr Â«expr âˆ§ Â»(_, _)]]\"\n  apply cont_diff_on_congr\n  intro x hx\n  exact fderiv_within_of_open hs hx\n#align cont_diff_on_succ_iff_fderiv_of_open cont_diff_on_succ_iff_fderiv_of_open\n\n",
 "cont_diff_on_of_locally_cont_diff_on":
 "/-- If a function is `C^n` around each point in a set, then it is `C^n` on the set. -/\ntheorem cont_diff_on_of_locally_cont_diff_on (h : âˆ€ x âˆˆ s, âˆƒ u, IsOpen u âˆ§ x âˆˆ u âˆ§ cont_diff_on ğ•œ n f (s âˆ© u)) :\n    cont_diff_on ğ•œ n f s := by\n  intro x xs\n  rcases h x xs with âŸ¨u, u_open, xu, huâŸ©\n  apply (cont_diff_within_at_inter _).1 (hu x âŸ¨xs, xuâŸ©)\n  exact IsOpen.mem_nhds u_open xu\n#align cont_diff_on_of_locally_cont_diff_on cont_diff_on_of_locally_cont_diff_on\n\n",
 "cont_diff_on_of_differentiable_on":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ„•âˆÂ» -/\ntheorem cont_diff_on_of_differentiable_on\n    (h : âˆ€ m : â„•, (m : Â«exprâ„•âˆÂ») â‰¤ n â†’ differentiable_on ğ•œ (iterated_fderiv_within ğ•œ m f s) s) : cont_diff_on ğ•œ n f s :=\n  cont_diff_on_of_continuous_on_differentiable_on (fun m hm => (h m hm).continuous_on) fun m hm => h m (le_of_lt hm)\n#align cont_diff_on_of_differentiable_on cont_diff_on_of_differentiable_on\n\n",
 "cont_diff_on_of_continuous_on_differentiable_on":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ„•âˆÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ„•âˆÂ» -/\ntheorem cont_diff_on_of_continuous_on_differentiable_on\n    (Hcont : âˆ€ m : â„•, (m : Â«exprâ„•âˆÂ») â‰¤ n â†’ ContinuousOn (fun x => iterated_fderiv_within ğ•œ m f s x) s)\n    (Hdiff : âˆ€ m : â„•, (m : Â«exprâ„•âˆÂ») < n â†’ differentiable_on ğ•œ (fun x => iterated_fderiv_within ğ•œ m f s x) s) :\n    cont_diff_on ğ•œ n f s := by\n  intro x hx m hm\n  rw [insert_eq_of_mem hx]\n  refine' âŸ¨s, self_mem_nhdsWithin, ftaylor_series_within ğ•œ f s, _âŸ©\n  constructor\n  Â· intro y hy\n    simp only [ftaylor_series_within, continuous_multilinear_map.uncurry0_apply, iterated_fderiv_within_zero_apply]\n  Â· intro k hk y hy\n    convert(Hdiff k (lt_of_lt_of_le hk hm) y hy).has_fderiv_within_at\n    simp only [ftaylor_series_within, iterated_fderiv_within_succ_eq_comp_left, ContinuousLinearEquiv.coe_apply,\n      Function.comp_apply, coe_fn_coe_base]\n    exact continuous_linear_map.curry_uncurry_left _\n  Â· intro k hk\n    exact Hcont k (le_trans hk hm)\n#align cont_diff_on_of_continuous_on_differentiable_on cont_diff_on_of_continuous_on_differentiable_on\n\n",
 "cont_diff_on_iff_forall_nat_le":
 "theorem cont_diff_on_iff_forall_nat_le : cont_diff_on ğ•œ n f s â†” âˆ€ m : â„•, â†‘m â‰¤ n â†’ cont_diff_on ğ•œ m f s :=\n  âŸ¨fun H m hm => H.of_le hm, fun H x hx m hm => H m hm x hx m le_rflâŸ©\n#align cont_diff_on_iff_forall_nat_le cont_diff_on_iff_forall_nat_le\n\n",
 "cont_diff_on_iff_continuous_on_differentiable_on":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ„•âˆÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ„•âˆÂ» -/\ntheorem cont_diff_on_iff_continuous_on_differentiable_on (hs : unique_diff_on ğ•œ s) :\n    cont_diff_on ğ•œ n f s â†”\n      (âˆ€ m : â„•, (m : Â«exprâ„•âˆÂ») â‰¤ n â†’ ContinuousOn (fun x => iterated_fderiv_within ğ•œ m f s x) s) âˆ§\n        âˆ€ m : â„•, (m : Â«exprâ„•âˆÂ») < n â†’ differentiable_on ğ•œ (fun x => iterated_fderiv_within ğ•œ m f s x) s :=\n  by\n  constructor\n  Â· intro h\n    constructor\n    Â· intro m hm\n      exact h.continuous_on_iterated_fderiv_within hm hs\n    Â· intro m hm\n      exact h.differentiable_on_iterated_fderiv_within hm hs\n  Â· intro h\n    exact cont_diff_on_of_continuous_on_differentiable_on h.1 h.2\n#align cont_diff_on_iff_continuous_on_differentiable_on cont_diff_on_iff_continuous_on_differentiable_on\n\n",
 "cont_diff_on_congr":
 "theorem cont_diff_on_congr (hâ‚ : âˆ€ x âˆˆ s, fâ‚ x = f x) : cont_diff_on ğ•œ n fâ‚ s â†” cont_diff_on ğ•œ n f s :=\n  âŸ¨fun H => H.congr fun x hx => (hâ‚ x hx).symm, fun H => H.congr hâ‚âŸ©\n#align cont_diff_on_congr cont_diff_on_congr\n\n",
 "cont_diff_on_all_iff_nat":
 "theorem cont_diff_on_all_iff_nat : (âˆ€ n, cont_diff_on ğ•œ n f s) â†” âˆ€ n : â„•, cont_diff_on ğ•œ n f s :=\n  by\n  refine' âŸ¨fun H n => H n, _âŸ©\n  rintro H (_ | n)\n  exacts[cont_diff_on_top.2 H, H n]\n#align cont_diff_on_all_iff_nat cont_diff_on_all_iff_nat\n\n",
 "cont_diff_on":
 "theorem cont_diff.cont_diff_on (h : cont_diff ğ•œ n f) : cont_diff_on ğ•œ n f s :=\n  (cont_diff_on_univ.2 h).mono (subset_univ _)\n#align cont_diff.cont_diff_on cont_diff.cont_diff_on\n\n",
 "cont_diff_of_differentiable_iterated_fderiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ„•âˆÂ» -/\ntheorem cont_diff_of_differentiable_iterated_fderiv\n    (h : âˆ€ m : â„•, (m : Â«exprâ„•âˆÂ») â‰¤ n â†’ differentiable ğ•œ (iterated_fderiv ğ•œ m f)) : cont_diff ğ•œ n f :=\n  cont_diff_iff_continuous_differentiable.2 âŸ¨fun m hm => (h m hm).continuous, fun m hm => h m (le_of_lt hm)âŸ©\n#align cont_diff_of_differentiable_iterated_fderiv cont_diff_of_differentiable_iterated_fderiv\n\n",
 "cont_diff_iff_ftaylor_series":
 "/-- When a function is `C^n` in a set `s` of unique differentiability, it admits\n`ftaylor_series_within ğ•œ f s` as a Taylor series up to order `n` in `s`. -/\ntheorem cont_diff_iff_ftaylor_series : cont_diff ğ•œ n f â†” has_ftaylor_series_up_to n f (ftaylor_series ğ•œ f) :=\n  by\n  constructor\n  Â· rw [â† cont_diff_on_univ, â† has_ftaylor_series_up_to_on_univ_iff, â† ftaylor_series_within_univ]\n    exact fun h => cont_diff_on.ftaylor_series_within h unique_diff_on_univ\n  Â· intro h\n    exact âŸ¨ftaylor_series ğ•œ f, hâŸ©\n#align cont_diff_iff_ftaylor_series cont_diff_iff_ftaylor_series\n\n",
 "cont_diff_iff_forall_nat_le":
 "theorem cont_diff_iff_forall_nat_le : cont_diff ğ•œ n f â†” âˆ€ m : â„•, â†‘m â‰¤ n â†’ cont_diff ğ•œ m f :=\n  by\n  simp_rw [â† cont_diff_on_univ]\n  exact cont_diff_on_iff_forall_nat_le\n#align cont_diff_iff_forall_nat_le cont_diff_iff_forall_nat_le\n\n",
 "cont_diff_iff_continuous_differentiable":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ„•âˆÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ„•âˆÂ» -/\ntheorem cont_diff_iff_continuous_differentiable :\n    cont_diff ğ•œ n f â†”\n      (âˆ€ m : â„•, (m : Â«exprâ„•âˆÂ») â‰¤ n â†’ Continuous fun x => iterated_fderiv ğ•œ m f x) âˆ§\n        âˆ€ m : â„•, (m : Â«exprâ„•âˆÂ») < n â†’ differentiable ğ•œ fun x => iterated_fderiv ğ•œ m f x :=\n  by\n  simp [cont_diff_on_univ.symm, continuous_iff_continuousOn_univ, differentiable_on_univ.symm,\n    iterated_fderiv_within_univ, cont_diff_on_iff_continuous_on_differentiable_on unique_diff_on_univ]\n#align cont_diff_iff_continuous_differentiable cont_diff_iff_continuous_differentiable\n\n",
 "cont_diff_iff_cont_diff_at":
 "theorem cont_diff_iff_cont_diff_at : cont_diff ğ•œ n f â†” âˆ€ x, cont_diff_at ğ•œ n f x := by\n  simp [â† cont_diff_on_univ, cont_diff_on, cont_diff_at]\n#align cont_diff_iff_cont_diff_at cont_diff_iff_cont_diff_at\n\n",
 "cont_diff_at_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem cont_diff_at_zero : cont_diff_at ğ•œ 0 f x â†” âˆƒ u âˆˆ (nhds) x, ContinuousOn f u :=\n  by\n  rw [â† cont_diff_within_at_univ]\n  simp [cont_diff_within_at_zero, nhdsWithin_univ]\n#align cont_diff_at_zero cont_diff_at_zero\n\n",
 "cont_diff_at_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆÂ» -/\ntheorem cont_diff_at_top : cont_diff_at ğ•œ (Â«exprâˆÂ») f x â†” âˆ€ n : â„•, cont_diff_at ğ•œ n f x := by\n  simp [â† cont_diff_within_at_univ, cont_diff_within_at_top]\n#align cont_diff_at_top cont_diff_at_top\n\n",
 "cont_diff_at_succ_iff_has_fderiv_at":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- A function is `C^(n + 1)` at a point iff locally, it has a derivative which is `C^n`. -/\ntheorem cont_diff_at_succ_iff_has_fderiv_at {n : â„•} :\n    cont_diff_at ğ•œ (n + 1 : â„•) f x â†”\n      âˆƒ f' : E â†’ Â«expr â†’L[ ] Â» E ğ•œ F, (âˆƒ u âˆˆ (nhds) x, âˆ€ x âˆˆ u, has_fderiv_at f (f' x) x) âˆ§ cont_diff_at ğ•œ n f' x :=\n  by\n  rw [â† cont_diff_within_at_univ, cont_diff_within_at_succ_iff_has_fderiv_within_at]\n  simp only [nhdsWithin_univ, exists_prop, mem_univ, insert_eq_of_mem]\n  constructor\n  Â· rintro âŸ¨u, H, f', h_fderiv, h_cont_diffâŸ©\n    rcases mem_nhds_iff.mp H with âŸ¨t, htu, ht, hxtâŸ©\n    refine' âŸ¨f', âŸ¨t, _âŸ©, h_cont_diff.cont_diff_at HâŸ©\n    refine' âŸ¨mem_nhds_iff.mpr âŸ¨t, subset.rfl, ht, hxtâŸ©, _âŸ©\n    intro y hyt\n    refine' (h_fderiv y (htu hyt)).has_fderiv_at _\n    exact mem_nhds_iff.mpr âŸ¨t, htu, ht, hytâŸ©\n  Â· rintro âŸ¨f', âŸ¨u, H, h_fderivâŸ©, h_cont_diffâŸ©\n    refine' âŸ¨u, H, f', _, h_cont_diff.cont_diff_within_atâŸ©\n    intro x hxu\n    exact (h_fderiv x hxu).has_fderiv_within_at\n#align cont_diff_at_succ_iff_has_fderiv_at cont_diff_at_succ_iff_has_fderiv_at\n\n",
 "cont_diff_at_one_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ„•âˆÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ„•âˆÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem cont_diff_at_one_iff :\n    cont_diff_at ğ•œ 1 f x â†”\n      âˆƒ f' : E â†’ Â«expr â†’L[ ] Â» E ğ•œ F, âˆƒ u âˆˆ (nhds) x, ContinuousOn f' u âˆ§ âˆ€ x âˆˆ u, has_fderiv_at f (f' x) x :=\n  by\n  simp_rw [show (1 : Â«exprâ„•âˆÂ») = (0 + 1 : â„•) from (zero_add 1).symm, cont_diff_at_succ_iff_has_fderiv_at,\n    show ((0 : â„•) : Â«exprâ„•âˆÂ») = 0 from rfl, cont_diff_at_zero,\n    exists_mem_and_iff antitone_bforall antitone_continuousOn, and_comm']\n#align cont_diff_at_one_iff cont_diff_at_one_iff\n\n",
 "cont_diff_at":
 "theorem cont_diff.cont_diff_at (h : cont_diff ğ•œ n f) : cont_diff_at ğ•œ n f x :=\n  cont_diff_iff_cont_diff_at.1 h x\n#align cont_diff.cont_diff_at cont_diff.cont_diff_at\n\n",
 "cont_diff_all_iff_nat":
 "theorem cont_diff_all_iff_nat : (âˆ€ n, cont_diff ğ•œ n f) â†” âˆ€ n : â„•, cont_diff ğ•œ n f := by\n  simp only [â† cont_diff_on_univ, cont_diff_on_all_iff_nat]\n#align cont_diff_all_iff_nat cont_diff_all_iff_nat\n\n",
 "cont_diff":
 "/-- If `f` has a Taylor series up to `n`, then it is `C^n`. -/\ntheorem has_ftaylor_series_up_to.cont_diff {f' : E â†’ formal_multilinear_series ğ•œ E F}\n    (hf : has_ftaylor_series_up_to n f f') : cont_diff ğ•œ n f :=\n  âŸ¨f', hfâŸ©\n#align has_ftaylor_series_up_to.cont_diff has_ftaylor_series_up_to.cont_diff\n\n",
 "congr_of_eventually_eq_insert":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr =á¶ [ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\ntheorem cont_diff_within_at.congr_of_eventually_eq_insert (h : cont_diff_within_at ğ•œ n f s x)\n    (hâ‚ : Â«expr =á¶ [ ] Â» fâ‚ (nhds_within (insert x s) x) f) : cont_diff_within_at ğ•œ n fâ‚ s x :=\n  h.congr_of_eventually_eq (nhdsWithin_mono x (subset_insert x s) hâ‚) (mem_of_mem_nhdsWithin (mem_insert x s) hâ‚ : _)\n#align cont_diff_within_at.congr_of_eventually_eq_insert cont_diff_within_at.congr_of_eventually_eq_insert\n\n",
 "congr_of_eventually_eq'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr =á¶ [ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\ntheorem cont_diff_within_at.congr_of_eventually_eq' (h : cont_diff_within_at ğ•œ n f s x)\n    (hâ‚ : Â«expr =á¶ [ ] Â» fâ‚ (nhds_within s x) f) (hx : x âˆˆ s) : cont_diff_within_at ğ•œ n fâ‚ s x :=\n  h.congr_of_eventually_eq hâ‚ <| hâ‚.self_of_nhds_within hx\n#align cont_diff_within_at.congr_of_eventually_eq' cont_diff_within_at.congr_of_eventually_eq'\n\n",
 "congr_of_eventually_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr =á¶ [ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem cont_diff_at.congr_of_eventually_eq (h : cont_diff_at ğ•œ n f x) (hg : Â«expr =á¶ [ ] Â» fâ‚ ((nhds) x) f) :\n    cont_diff_at ğ•œ n fâ‚ x :=\n  h.congr_of_eventually_eq' (by rwa [nhdsWithin_univ]) (mem_univ x)\n#align cont_diff_at.congr_of_eventually_eq cont_diff_at.congr_of_eventually_eq\n\n",
 "congr_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\ntheorem cont_diff_within_at.congr_nhds (h : cont_diff_within_at ğ•œ n f s x) {t : Set E}\n    (hst : nhds_within s x = nhds_within t x) : cont_diff_within_at ğ•œ n f t x :=\n  h.mono_of_mem <| hst â–¸ self_mem_nhdsWithin\n#align cont_diff_within_at.congr_nhds cont_diff_within_at.congr_nhds\n\n",
 "congr_mono":
 "theorem cont_diff_on.congr_mono (hf : cont_diff_on ğ•œ n f s) (hâ‚ : âˆ€ x âˆˆ sâ‚, fâ‚ x = f x) (hs : sâ‚ âŠ† s) :\n    cont_diff_on ğ•œ n fâ‚ sâ‚ :=\n  (hf.mono hs).congr hâ‚\n#align cont_diff_on.congr_mono cont_diff_on.congr_mono\n\n",
 "congr'":
 "theorem cont_diff_within_at.congr' (h : cont_diff_within_at ğ•œ n f s x) (hâ‚ : âˆ€ y âˆˆ s, fâ‚ y = f y) (hx : x âˆˆ s) :\n    cont_diff_within_at ğ•œ n fâ‚ s x :=\n  h.congr hâ‚ (hâ‚ _ hx)\n#align cont_diff_within_at.congr' cont_diff_within_at.congr'\n\n",
 "congr":
 "theorem cont_diff_on.congr (h : cont_diff_on ğ•œ n f s) (hâ‚ : âˆ€ x âˆˆ s, fâ‚ x = f x) : cont_diff_on ğ•œ n fâ‚ s := fun x hx =>\n  (h x hx).congr hâ‚ (hâ‚ x hx)\n#align cont_diff_on.congr cont_diff_on.congr\n\n"}