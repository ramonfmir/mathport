{"zero_eq'":
 "theorem has_ftaylor_series_up_to.zero_eq' (h : has_ftaylor_series_up_to n f p) (x : E) :\n    p x 0 = (continuous_multilinear_curry_fin0 𝕜 E F).symm (f x) :=\n  by\n  rw [← h.zero_eq x]\n  symm\n  exact continuous_multilinear_map.uncurry0_curry0 _\n#align has_ftaylor_series_up_to.zero_eq' has_ftaylor_series_up_to.zero_eq'\n\n",
 "one_of_succ":
 "theorem cont_diff.one_of_succ {n : ℕ} (h : cont_diff 𝕜 (n + 1) f) : cont_diff 𝕜 1 f :=\n  h.of_le <| WithTop.coe_le_coe.mpr le_add_self\n#align cont_diff.one_of_succ cont_diff.one_of_succ\n\n",
 "of_succ":
 "theorem cont_diff.of_succ {n : ℕ} (h : cont_diff 𝕜 (n + 1) f) : cont_diff 𝕜 n f :=\n  h.of_le <| WithTop.coe_le_coe.mpr le_self_add\n#align cont_diff.of_succ cont_diff.of_succ\n\n",
 "of_le":
 "theorem cont_diff.of_le (h : cont_diff 𝕜 n f) (hmn : m ≤ n) : cont_diff 𝕜 m f :=\n  cont_diff_on_univ.1 <| (cont_diff_on_univ.2 h).of_le hmn\n#align cont_diff.of_le cont_diff.of_le\n\n",
 "norm_iterated_fderiv_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n@[simp]\ntheorem norm_iterated_fderiv_zero : «expr‖ ‖» (iterated_fderiv 𝕜 0 f x) = «expr‖ ‖» (f x) := by\n  rw [iterated_fderiv_zero_eq_comp, LinearIsometryEquiv.norm_map]\n#align norm_iterated_fderiv_zero norm_iterated_fderiv_zero\n\n",
 "norm_iterated_fderiv_within_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n@[simp]\ntheorem norm_iterated_fderiv_within_zero : «expr‖ ‖» (iterated_fderiv_within 𝕜 0 f s x) = «expr‖ ‖» (f x) := by\n  rw [iterated_fderiv_within_zero_eq_comp, LinearIsometryEquiv.norm_map]\n#align norm_iterated_fderiv_within_zero norm_iterated_fderiv_within_zero\n\n",
 "norm_iterated_fderiv_within_fderiv_within":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem norm_iterated_fderiv_within_fderiv_within {n : ℕ} (hs : unique_diff_on 𝕜 s) (hx : x ∈ s) :\n    «expr‖ ‖» (iterated_fderiv_within 𝕜 n (fderiv_within 𝕜 f s) s x) =\n      «expr‖ ‖» (iterated_fderiv_within 𝕜 (n + 1) f s x) :=\n  by rw [iterated_fderiv_within_succ_eq_comp_right hs hx, LinearIsometryEquiv.norm_map]\n#align norm_iterated_fderiv_within_fderiv_within norm_iterated_fderiv_within_fderiv_within\n\n",
 "norm_iterated_fderiv_fderiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem norm_iterated_fderiv_fderiv {n : ℕ} :\n    «expr‖ ‖» (iterated_fderiv 𝕜 n (fderiv 𝕜 f) x) = «expr‖ ‖» (iterated_fderiv 𝕜 (n + 1) f x) := by\n  rw [iterated_fderiv_succ_eq_comp_right, LinearIsometryEquiv.norm_map]\n#align norm_iterated_fderiv_fderiv norm_iterated_fderiv_fderiv\n\n",
 "norm_fderiv_within_iterated_fderiv_within":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem norm_fderiv_within_iterated_fderiv_within {n : ℕ} :\n    «expr‖ ‖» (fderiv_within 𝕜 (iterated_fderiv_within 𝕜 n f s) s x) =\n      «expr‖ ‖» (iterated_fderiv_within 𝕜 (n + 1) f s x) :=\n  by rw [iterated_fderiv_within_succ_eq_comp_left, LinearIsometryEquiv.norm_map]\n#align norm_fderiv_within_iterated_fderiv_within norm_fderiv_within_iterated_fderiv_within\n\n",
 "norm_fderiv_iterated_fderiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem norm_fderiv_iterated_fderiv {n : ℕ} :\n    «expr‖ ‖» (fderiv 𝕜 (iterated_fderiv 𝕜 n f) x) = «expr‖ ‖» (iterated_fderiv 𝕜 (n + 1) f x) := by\n  rw [iterated_fderiv_succ_eq_comp_left, LinearIsometryEquiv.norm_map]\n#align norm_fderiv_iterated_fderiv norm_fderiv_iterated_fderiv\n\n",
 "mono_of_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\ntheorem cont_diff_within_at.mono_of_mem (h : cont_diff_within_at 𝕜 n f s x) {t : Set E} (hst : s ∈ nhds_within t x) :\n    cont_diff_within_at 𝕜 n f t x := by\n  intro m hm\n  rcases h m hm with ⟨u, hu, p, H⟩\n  exact ⟨u, nhdsWithin_le_of_mem (insert_mem_nhdsWithin_insert hst) hu, p, H⟩\n#align cont_diff_within_at.mono_of_mem cont_diff_within_at.mono_of_mem\n\n",
 "mono":
 "theorem cont_diff_on.mono (h : cont_diff_on 𝕜 n f s) {t : Set E} (hst : t ⊆ s) : cont_diff_on 𝕜 n f t := fun x hx =>\n  (h x (hst hx)).mono hst\n#align cont_diff_on.mono cont_diff_on.mono\n\n",
 "iterated_fderiv_zero_eq_comp":
 "theorem iterated_fderiv_zero_eq_comp : iterated_fderiv 𝕜 0 f = (continuous_multilinear_curry_fin0 𝕜 E F).symm ∘ f :=\n  rfl\n#align iterated_fderiv_zero_eq_comp iterated_fderiv_zero_eq_comp\n\n",
 "iterated_fderiv_zero_apply":
 "@[simp]\ntheorem iterated_fderiv_zero_apply (m : Fin 0 → E) : (iterated_fderiv 𝕜 0 f x : (Fin 0 → E) → F) m = f x :=\n  rfl\n#align iterated_fderiv_zero_apply iterated_fderiv_zero_apply\n\n",
 "iterated_fderiv_within_zero_eq_comp":
 "theorem iterated_fderiv_within_zero_eq_comp :\n    iterated_fderiv_within 𝕜 0 f s = (continuous_multilinear_curry_fin0 𝕜 E F).symm ∘ f :=\n  rfl\n#align iterated_fderiv_within_zero_eq_comp iterated_fderiv_within_zero_eq_comp\n\n",
 "iterated_fderiv_within_zero_apply":
 "@[simp]\ntheorem iterated_fderiv_within_zero_apply (m : Fin 0 → E) :\n    (iterated_fderiv_within 𝕜 0 f s x : (Fin 0 → E) → F) m = f x :=\n  rfl\n#align iterated_fderiv_within_zero_apply iterated_fderiv_within_zero_apply\n\n",
 "iterated_fderiv_within_univ":
 "theorem iterated_fderiv_within_univ {n : ℕ} : iterated_fderiv_within 𝕜 n f univ = iterated_fderiv 𝕜 n f :=\n  by\n  induction' n with n IH\n  · ext x\n    simp\n  · ext (x m)\n    rw [iterated_fderiv_succ_apply_left, iterated_fderiv_within_succ_apply_left, IH, fderiv_within_univ]\n#align iterated_fderiv_within_univ iterated_fderiv_within_univ\n\n",
 "iterated_fderiv_within_succ_eq_comp_right":
 "/-- Writing explicitly the `n+1`-th derivative as the composition of a currying linear equiv,\nand the `n`-th derivative of the derivative. -/\ntheorem iterated_fderiv_within_succ_eq_comp_right {n : ℕ} (hs : unique_diff_on 𝕜 s) (hx : x ∈ s) :\n    iterated_fderiv_within 𝕜 (n + 1) f s x =\n      (continuous_multilinear_curry_right_equiv' 𝕜 n E F ∘\n          iterated_fderiv_within 𝕜 n (fun y => fderiv_within 𝕜 f s y) s)\n        x :=\n  by\n  ext m\n  rw [iterated_fderiv_within_succ_apply_right hs hx]\n  rfl\n#align iterated_fderiv_within_succ_eq_comp_right iterated_fderiv_within_succ_eq_comp_right\n\n",
 "iterated_fderiv_within_succ_eq_comp_left":
 "/-- Writing explicitly the `n+1`-th derivative as the composition of a currying linear equiv,\nand the derivative of the `n`-th derivative. -/\ntheorem iterated_fderiv_within_succ_eq_comp_left {n : ℕ} :\n    iterated_fderiv_within 𝕜 (n + 1) f s =\n      continuous_multilinear_curry_left_equiv 𝕜 (fun i : Fin (n + 1) => E) F ∘\n        fderiv_within 𝕜 (iterated_fderiv_within 𝕜 n f s) s :=\n  rfl\n#align iterated_fderiv_within_succ_eq_comp_left iterated_fderiv_within_succ_eq_comp_left\n\n",
 "iterated_fderiv_within_succ_apply_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr [× ]→L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr [× ]→L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr [× ]→L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr [× ]→L[ ] » -/\ntheorem iterated_fderiv_within_succ_apply_right {n : ℕ} (hs : unique_diff_on 𝕜 s) (hx : x ∈ s) (m : Fin (n + 1) → E) :\n    (iterated_fderiv_within 𝕜 (n + 1) f s x : (Fin (n + 1) → E) → F) m =\n      iterated_fderiv_within 𝕜 n (fun y => fderiv_within 𝕜 f s y) s x (init m) (m (last n)) :=\n  by\n  induction' n with n IH generalizing x\n  · rw [iterated_fderiv_within_succ_eq_comp_left, iterated_fderiv_within_zero_eq_comp,\n      iterated_fderiv_within_zero_apply, Function.comp_apply, linear_isometry_equiv.comp_fderiv_within _ (hs x hx)]\n    rfl\n  · let I := continuous_multilinear_curry_right_equiv' 𝕜 n E F\n    have A :\n      ∀ y ∈ s,\n        iterated_fderiv_within 𝕜 n.succ f s y = (I ∘ iterated_fderiv_within 𝕜 n (fun y => fderiv_within 𝕜 f s y) s) y :=\n      by\n      intro y hy\n      ext m\n      rw [@IH m y hy]\n      rfl\n    calc\n      (iterated_fderiv_within 𝕜 (n + 2) f s x : (Fin (n + 2) → E) → F) m =\n          (fderiv_within 𝕜 (iterated_fderiv_within 𝕜 n.succ f s) s x : E → «expr [× ]→L[ ] » E (n + 1) 𝕜 F) (m 0)\n            (tail m) :=\n        rfl\n      _ =\n          (fderiv_within 𝕜 (I ∘ iterated_fderiv_within 𝕜 n (fderiv_within 𝕜 f s) s) s x :\n              E → «expr [× ]→L[ ] » E (n + 1) 𝕜 F)\n            (m 0) (tail m) :=\n        by rw [fderiv_within_congr (hs x hx) A (A x hx)]\n      _ =\n          (I ∘ fderiv_within 𝕜 (iterated_fderiv_within 𝕜 n (fderiv_within 𝕜 f s) s) s x :\n              E → «expr [× ]→L[ ] » E (n + 1) 𝕜 F)\n            (m 0) (tail m) :=\n        by\n        rw [linear_isometry_equiv.comp_fderiv_within _ (hs x hx)]\n        rfl\n      _ =\n          (fderiv_within 𝕜 (iterated_fderiv_within 𝕜 n (fun y => fderiv_within 𝕜 f s y) s) s x :\n              E → «expr [× ]→L[ ] » E n 𝕜 («expr →L[ ] » E 𝕜 F))\n            (m 0) (init (tail m)) ((tail m) (last n)) :=\n        rfl\n      _ = iterated_fderiv_within 𝕜 (nat.succ n) (fun y => fderiv_within 𝕜 f s y) s x (init m) (m (last (n + 1))) :=\n        by\n        rw [iterated_fderiv_within_succ_apply_left, tail_init_eq_init_tail]\n        rfl\n      \n#align iterated_fderiv_within_succ_apply_right iterated_fderiv_within_succ_apply_right\n\n",
 "iterated_fderiv_within_succ_apply_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr [× ]→L[ ] » -/\ntheorem iterated_fderiv_within_succ_apply_left {n : ℕ} (m : Fin (n + 1) → E) :\n    (iterated_fderiv_within 𝕜 (n + 1) f s x : (Fin (n + 1) → E) → F) m =\n      (fderiv_within 𝕜 (iterated_fderiv_within 𝕜 n f s) s x : E → «expr [× ]→L[ ] » E n 𝕜 F) (m 0) (tail m) :=\n  rfl\n#align iterated_fderiv_within_succ_apply_left iterated_fderiv_within_succ_apply_left\n\n",
 "iterated_fderiv_within_one_apply":
 "@[simp]\ntheorem iterated_fderiv_within_one_apply (hs : unique_diff_on 𝕜 s) (hx : x ∈ s) (m : Fin 1 → E) :\n    (iterated_fderiv_within 𝕜 1 f s x : (Fin 1 → E) → F) m = (fderiv_within 𝕜 f s x : E → F) (m 0) :=\n  by\n  rw [iterated_fderiv_within_succ_apply_right hs hx, iterated_fderiv_within_zero_apply]\n  rfl\n#align iterated_fderiv_within_one_apply iterated_fderiv_within_one_apply\n\n",
 "iterated_fderiv_within_of_is_open":
 "/-- In an open set, the iterated derivative within this set coincides with the global iterated\nderivative. -/\ntheorem iterated_fderiv_within_of_is_open (n : ℕ) (hs : IsOpen s) :\n    EqOn (iterated_fderiv_within 𝕜 n f s) (iterated_fderiv 𝕜 n f) s :=\n  by\n  induction' n with n IH\n  · intro x hx\n    ext1 m\n    simp only [iterated_fderiv_within_zero_apply, iterated_fderiv_zero_apply]\n  · intro x hx\n    rw [iterated_fderiv_succ_eq_comp_left, iterated_fderiv_within_succ_eq_comp_left]\n    dsimp\n    congr 1\n    rw [fderiv_within_of_open hs hx]\n    apply filter.eventually_eq.fderiv_eq\n    filter_upwards [hs.mem_nhds hx]\n    exact IH\n#align iterated_fderiv_within_of_is_open iterated_fderiv_within_of_is_open\n\n",
 "iterated_fderiv_within_inter_open":
 "/-- The iterated differential within a set `s` at a point `x` is not modified if one intersects\n`s` with an open set containing `x`. -/\ntheorem iterated_fderiv_within_inter_open {n : ℕ} (hu : IsOpen u) (hs : unique_diff_on 𝕜 (s ∩ u)) (hx : x ∈ s ∩ u) :\n    iterated_fderiv_within 𝕜 n f (s ∩ u) x = iterated_fderiv_within 𝕜 n f s x :=\n  by\n  induction' n with n IH generalizing x\n  · ext m\n    simp\n  · have A :\n      fderiv_within 𝕜 (fun y => iterated_fderiv_within 𝕜 n f (s ∩ u) y) (s ∩ u) x =\n        fderiv_within 𝕜 (fun y => iterated_fderiv_within 𝕜 n f s y) (s ∩ u) x :=\n      fderiv_within_congr (hs x hx) (fun y hy => IH hy) (IH hx)\n    have B :\n      fderiv_within 𝕜 (fun y => iterated_fderiv_within 𝕜 n f s y) (s ∩ u) x =\n        fderiv_within 𝕜 (fun y => iterated_fderiv_within 𝕜 n f s y) s x :=\n      fderiv_within_inter (IsOpen.mem_nhds hu hx.2)\n        ((unique_diff_within_at_inter (IsOpen.mem_nhds hu hx.2)).1 (hs x hx))\n    ext m\n    rw [iterated_fderiv_within_succ_apply_left, iterated_fderiv_within_succ_apply_left, A, B]\n#align iterated_fderiv_within_inter_open iterated_fderiv_within_inter_open\n\n",
 "iterated_fderiv_within_inter'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/-- The iterated differential within a set `s` at a point `x` is not modified if one intersects\n`s` with a neighborhood of `x` within `s`. -/\ntheorem iterated_fderiv_within_inter' {n : ℕ} (hu : u ∈ nhds_within s x) (hs : unique_diff_on 𝕜 s) (xs : x ∈ s) :\n    iterated_fderiv_within 𝕜 n f (s ∩ u) x = iterated_fderiv_within 𝕜 n f s x :=\n  by\n  obtain ⟨v, v_open, xv, vu⟩ : ∃ v, IsOpen v ∧ x ∈ v ∧ v ∩ s ⊆ u := mem_nhdsWithin.1 hu\n  have A : s ∩ u ∩ v = s ∩ v :=\n    by\n    apply subset.antisymm (inter_subset_inter (inter_subset_left _ _) (subset.refl _))\n    exact fun y ⟨ys, yv⟩ => ⟨⟨ys, vu ⟨yv, ys⟩⟩, yv⟩\n  have : iterated_fderiv_within 𝕜 n f (s ∩ v) x = iterated_fderiv_within 𝕜 n f s x :=\n    iterated_fderiv_within_inter_open v_open (hs.inter v_open) ⟨xs, xv⟩\n  rw [← this]\n  have : iterated_fderiv_within 𝕜 n f (s ∩ u ∩ v) x = iterated_fderiv_within 𝕜 n f (s ∩ u) x :=\n    by\n    refine' iterated_fderiv_within_inter_open v_open _ ⟨⟨xs, vu ⟨xv, xs⟩⟩, xv⟩\n    rw [A]\n    exact hs.inter v_open\n  rw [A] at this\n  rw [← this]\n#align iterated_fderiv_within_inter' iterated_fderiv_within_inter'\n\n",
 "iterated_fderiv_within_inter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- The iterated differential within a set `s` at a point `x` is not modified if one intersects\n`s` with a neighborhood of `x`. -/\ntheorem iterated_fderiv_within_inter {n : ℕ} (hu : u ∈ (nhds) x) (hs : unique_diff_on 𝕜 s) (xs : x ∈ s) :\n    iterated_fderiv_within 𝕜 n f (s ∩ u) x = iterated_fderiv_within 𝕜 n f s x :=\n  iterated_fderiv_within_inter' (mem_nhdsWithin_of_mem_nhds hu) hs xs\n#align iterated_fderiv_within_inter iterated_fderiv_within_inter\n\n",
 "iterated_fderiv_within_congr":
 "/-- If two functions coincide on a set `s` of unique differentiability, then their iterated\ndifferentials within this set coincide. -/\ntheorem iterated_fderiv_within_congr {n : ℕ} (hs : unique_diff_on 𝕜 s) (hL : ∀ y ∈ s, f₁ y = f y) (hx : x ∈ s) :\n    iterated_fderiv_within 𝕜 n f₁ s x = iterated_fderiv_within 𝕜 n f s x :=\n  by\n  induction' n with n IH generalizing x\n  · ext m\n    simp [hL x hx]\n  · have :\n      fderiv_within 𝕜 (fun y => iterated_fderiv_within 𝕜 n f₁ s y) s x =\n        fderiv_within 𝕜 (fun y => iterated_fderiv_within 𝕜 n f s y) s x :=\n      fderiv_within_congr (hs x hx) (fun y hy => IH hy) (IH hx)\n    ext m\n    rw [iterated_fderiv_within_succ_apply_left, iterated_fderiv_within_succ_apply_left, this]\n#align iterated_fderiv_within_congr iterated_fderiv_within_congr\n\n",
 "iterated_fderiv_with_zero_eq":
 "theorem iterated_fderiv_with_zero_eq : iterated_fderiv_within 𝕜 0 f s = iterated_fderiv 𝕜 0 f :=\n  by\n  ext\n  rfl\n#align iterated_fderiv_with_zero_eq iterated_fderiv_with_zero_eq\n\n",
 "iterated_fderiv_succ_eq_comp_right":
 "/-- Writing explicitly the `n+1`-th derivative as the composition of a currying linear equiv,\nand the `n`-th derivative of the derivative. -/\ntheorem iterated_fderiv_succ_eq_comp_right {n : ℕ} :\n    iterated_fderiv 𝕜 (n + 1) f x =\n      (continuous_multilinear_curry_right_equiv' 𝕜 n E F ∘ iterated_fderiv 𝕜 n fun y => fderiv 𝕜 f y) x :=\n  by\n  ext m\n  rw [iterated_fderiv_succ_apply_right]\n  rfl\n#align iterated_fderiv_succ_eq_comp_right iterated_fderiv_succ_eq_comp_right\n\n",
 "iterated_fderiv_succ_eq_comp_left":
 "/-- Writing explicitly the `n+1`-th derivative as the composition of a currying linear equiv,\nand the derivative of the `n`-th derivative. -/\ntheorem iterated_fderiv_succ_eq_comp_left {n : ℕ} :\n    iterated_fderiv 𝕜 (n + 1) f =\n      continuous_multilinear_curry_left_equiv 𝕜 (fun i : Fin (n + 1) => E) F ∘ fderiv 𝕜 (iterated_fderiv 𝕜 n f) :=\n  rfl\n#align iterated_fderiv_succ_eq_comp_left iterated_fderiv_succ_eq_comp_left\n\n",
 "iterated_fderiv_succ_apply_right":
 "theorem iterated_fderiv_succ_apply_right {n : ℕ} (m : Fin (n + 1) → E) :\n    (iterated_fderiv 𝕜 (n + 1) f x : (Fin (n + 1) → E) → F) m =\n      iterated_fderiv 𝕜 n (fun y => fderiv 𝕜 f y) x (init m) (m (last n)) :=\n  by\n  rw [← iterated_fderiv_within_univ, ← iterated_fderiv_within_univ, ← fderiv_within_univ]\n  exact iterated_fderiv_within_succ_apply_right unique_diff_on_univ (mem_univ _) _\n#align iterated_fderiv_succ_apply_right iterated_fderiv_succ_apply_right\n\n",
 "iterated_fderiv_succ_apply_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr [× ]→L[ ] » -/\ntheorem iterated_fderiv_succ_apply_left {n : ℕ} (m : Fin (n + 1) → E) :\n    (iterated_fderiv 𝕜 (n + 1) f x : (Fin (n + 1) → E) → F) m =\n      (fderiv 𝕜 (iterated_fderiv 𝕜 n f) x : E → «expr [× ]→L[ ] » E n 𝕜 F) (m 0) (tail m) :=\n  rfl\n#align iterated_fderiv_succ_apply_left iterated_fderiv_succ_apply_left\n\n",
 "iterated_fderiv_one_apply":
 "@[simp]\ntheorem iterated_fderiv_one_apply (m : Fin 1 → E) :\n    (iterated_fderiv 𝕜 1 f x : (Fin 1 → E) → F) m = (fderiv 𝕜 f x : E → F) (m 0) :=\n  by\n  rw [iterated_fderiv_succ_apply_right, iterated_fderiv_zero_apply]\n  rfl\n#align iterated_fderiv_one_apply iterated_fderiv_one_apply\n\n",
 "iterated_fderiv":
 "theorem has_compact_support.iterated_fderiv (hf : HasCompactSupport f) (n : ℕ) :\n    HasCompactSupport (iterated_fderiv 𝕜 n f) :=\n  by\n  induction' n with n IH\n  · rw [iterated_fderiv_zero_eq_comp]\n    apply hf.comp_left\n    exact LinearIsometryEquiv.map_zero _\n  · rw [iterated_fderiv_succ_eq_comp_left]\n    apply (IH.fderiv 𝕜).comp_left\n    exact LinearIsometryEquiv.map_zero _\n#align has_compact_support.iterated_fderiv has_compact_support.iterated_fderiv\n\n",
 "insert":
 "theorem cont_diff_within_at.insert (h : cont_diff_within_at 𝕜 n f s x) : cont_diff_within_at 𝕜 n f (insert x s) x :=\n  h.insert'\n#align cont_diff_within_at.insert cont_diff_within_at.insert\n\n",
 "has_ftaylor_series_up_to_zero_iff":
 "theorem has_ftaylor_series_up_to_zero_iff :\n    has_ftaylor_series_up_to 0 f p ↔ Continuous f ∧ ∀ x, (p x 0).uncurry0 = f x := by\n  simp [has_ftaylor_series_up_to_on_univ_iff.symm, continuous_iff_continuousOn_univ,\n    has_ftaylor_series_up_to_on_zero_iff]\n#align has_ftaylor_series_up_to_zero_iff has_ftaylor_series_up_to_zero_iff\n\n",
 "has_ftaylor_series_up_to_top_iff'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∞» -/\n/-- In the case that `n = ∞` we don't need the continuity assumption in\n`has_ftaylor_series_up_to`. -/\ntheorem has_ftaylor_series_up_to_top_iff' :\n    has_ftaylor_series_up_to («expr∞») f p ↔\n      (∀ x, (p x 0).uncurry0 = f x) ∧ ∀ (m : ℕ) (x), has_fderiv_at (fun y => p y m) (p x m.succ).curry_left x :=\n  by\n  simp only [← has_ftaylor_series_up_to_on_univ_iff, has_ftaylor_series_up_to_on_top_iff', mem_univ, forall_true_left,\n    has_fderiv_within_at_univ]\n#align has_ftaylor_series_up_to_top_iff' has_ftaylor_series_up_to_top_iff'\n\n",
 "has_ftaylor_series_up_to_top_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∞» -/\ntheorem has_ftaylor_series_up_to_top_iff :\n    has_ftaylor_series_up_to («expr∞») f p ↔ ∀ n : ℕ, has_ftaylor_series_up_to n f p := by\n  simp only [← has_ftaylor_series_up_to_on_univ_iff, has_ftaylor_series_up_to_on_top_iff]\n#align has_ftaylor_series_up_to_top_iff has_ftaylor_series_up_to_top_iff\n\n",
 "has_ftaylor_series_up_to_succ_iff_right":
 "/-- `p` is a Taylor series of `f` up to `n+1` if and only if `p.shift` is a Taylor series up to `n`\nfor `p 1`, which is a derivative of `f`. -/\ntheorem has_ftaylor_series_up_to_succ_iff_right {n : ℕ} :\n    has_ftaylor_series_up_to (n + 1 : ℕ) f p ↔\n      (∀ x, (p x 0).uncurry0 = f x) ∧\n        (∀ x, has_fderiv_at (fun y => p y 0) (p x 1).curry_left x) ∧\n          has_ftaylor_series_up_to n (fun x => continuous_multilinear_curry_fin1 𝕜 E F (p x 1)) fun x => (p x).shift :=\n  by\n  simp only [has_ftaylor_series_up_to_on_succ_iff_right, ← has_ftaylor_series_up_to_on_univ_iff, mem_univ,\n    forall_true_left, has_fderiv_within_at_univ]\n#align has_ftaylor_series_up_to_succ_iff_right has_ftaylor_series_up_to_succ_iff_right\n\n",
 "has_ftaylor_series_up_to_on_zero_iff":
 "theorem has_ftaylor_series_up_to_on_zero_iff :\n    has_ftaylor_series_up_to_on 0 f p s ↔ ContinuousOn f s ∧ ∀ x ∈ s, (p x 0).uncurry0 = f x :=\n  by\n  refine' ⟨fun H => ⟨H.continuous_on, H.zero_eq⟩, fun H => ⟨H.2, fun m hm => false.elim (not_le.2 hm bot_le), _⟩⟩\n  intro m hm\n  obtain rfl : m = 0 := by exact_mod_cast hm.antisymm (zero_le _)\n  have : ∀ x ∈ s, p x 0 = (continuous_multilinear_curry_fin0 𝕜 E F).symm (f x) :=\n    by\n    intro x hx\n    rw [← H.2 x hx]\n    symm\n    exact continuous_multilinear_map.uncurry0_curry0 _\n  rw [continuousOn_congr this, LinearIsometryEquiv.comp_continuousOn_iff]\n  exact H.1\n#align has_ftaylor_series_up_to_on_zero_iff has_ftaylor_series_up_to_on_zero_iff\n\n",
 "has_ftaylor_series_up_to_on_univ_iff":
 "theorem has_ftaylor_series_up_to_on_univ_iff :\n    has_ftaylor_series_up_to_on n f p univ ↔ has_ftaylor_series_up_to n f p :=\n  by\n  constructor\n  · intro H\n    constructor\n    · exact fun x => H.zero_eq x (mem_univ x)\n    · intro m hm x\n      rw [← has_fderiv_within_at_univ]\n      exact H.fderiv_within m hm x (mem_univ x)\n    · intro m hm\n      rw [continuous_iff_continuousOn_univ]\n      exact H.cont m hm\n  · intro H\n    constructor\n    · exact fun x hx => H.zero_eq x\n    · intro m hm x hx\n      rw [has_fderiv_within_at_univ]\n      exact H.fderiv m hm x\n    · intro m hm\n      rw [← continuous_iff_continuousOn_univ]\n      exact H.cont m hm\n#align has_ftaylor_series_up_to_on_univ_iff has_ftaylor_series_up_to_on_univ_iff\n\n",
 "has_ftaylor_series_up_to_on_top_iff'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∞» -/\n/-- In the case that `n = ∞` we don't need the continuity assumption in\n`has_ftaylor_series_up_to_on`. -/\ntheorem has_ftaylor_series_up_to_on_top_iff' :\n    has_ftaylor_series_up_to_on («expr∞») f p s ↔\n      (∀ x ∈ s, (p x 0).uncurry0 = f x) ∧\n        ∀ m : ℕ, ∀ x ∈ s, has_fderiv_within_at (fun y => p y m) (p x m.succ).curry_left s x :=\n  ⟨-- Everything except for the continuity is trivial:\n  fun h => ⟨h.1, fun m => h.2 m (WithTop.coe_lt_top m)⟩, fun h =>\n    ⟨h.1, fun m _ => h.2 m, fun m _ x hx =>\n      (-- The continuity follows from the existence of a derivative:\n            h.2\n          m x hx).continuous_within_at⟩⟩\n#align has_ftaylor_series_up_to_on_top_iff' has_ftaylor_series_up_to_on_top_iff'\n\n",
 "has_ftaylor_series_up_to_on_top_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∞» -/\ntheorem has_ftaylor_series_up_to_on_top_iff :\n    has_ftaylor_series_up_to_on («expr∞») f p s ↔ ∀ n : ℕ, has_ftaylor_series_up_to_on n f p s :=\n  by\n  constructor\n  · intro H n\n    exact H.of_le le_top\n  · intro H\n    constructor\n    · exact (H 0).zero_eq\n    · intro m hm\n      apply (H m.succ).fderiv_within m (WithTop.coe_lt_coe.2 (lt_add_one m))\n    · intro m hm\n      apply (H m).cont m le_rfl\n#align has_ftaylor_series_up_to_on_top_iff has_ftaylor_series_up_to_on_top_iff\n\n",
 "has_ftaylor_series_up_to_on_succ_iff_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ∞» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ∞» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ∞» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ∞» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ∞» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ∞» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ∞» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ∞» -/\n/-- `p` is a Taylor series of `f` up to `n+1` if and only if `p.shift` is a Taylor series up to `n`\nfor `p 1`, which is a derivative of `f`. -/\ntheorem has_ftaylor_series_up_to_on_succ_iff_right {n : ℕ} :\n    has_ftaylor_series_up_to_on (n + 1 : ℕ) f p s ↔\n      (∀ x ∈ s, (p x 0).uncurry0 = f x) ∧\n        (∀ x ∈ s, has_fderiv_within_at (fun y => p y 0) (p x 1).curry_left s x) ∧\n          has_ftaylor_series_up_to_on n (fun x => continuous_multilinear_curry_fin1 𝕜 E F (p x 1))\n            (fun x => (p x).shift) s :=\n  by\n  constructor\n  · intro H\n    refine' ⟨H.zero_eq, H.fderiv_within 0 (WithTop.coe_lt_coe.2 (nat.succ_pos n)), _⟩\n    constructor\n    · intro x hx\n      rfl\n    · intro m(hm : (m : «exprℕ∞») < n)x(hx : x ∈ s)\n      have A : (m.succ : «exprℕ∞») < n.succ := by\n        rw [WithTop.coe_lt_coe] at hm⊢\n        exact nat.lt_succ_iff.mpr hm\n      change\n        has_fderiv_within_at ((continuous_multilinear_curry_right_equiv' 𝕜 m E F).symm ∘ fun y : E => p y m.succ)\n          (p x m.succ.succ).curry_right.curry_left s x\n      rw [linear_isometry_equiv.comp_has_fderiv_within_at_iff']\n      convert H.fderiv_within _ A x hx\n      ext (y v)\n      change (p x m.succ.succ) (snoc (cons y (init v)) (v (last _))) = (p x (nat.succ (nat.succ m))) (cons y v)\n      rw [← cons_snoc_eq_snoc_cons, snoc_init_self]\n    · intro m(hm : (m : «exprℕ∞») ≤ n)\n      have A : (m.succ : «exprℕ∞») ≤ n.succ := by\n        rw [WithTop.coe_le_coe] at hm⊢\n        exact nat.pred_le_iff.mp hm\n      change ContinuousOn ((continuous_multilinear_curry_right_equiv' 𝕜 m E F).symm ∘ fun y : E => p y m.succ) s\n      rw [LinearIsometryEquiv.comp_continuousOn_iff]\n      exact H.cont _ A\n  · rintro ⟨Hzero_eq, Hfderiv_zero, Htaylor⟩\n    constructor\n    · exact Hzero_eq\n    · intro m(hm : (m : «exprℕ∞») < n.succ)x(hx : x ∈ s)\n      cases m\n      · exact Hfderiv_zero x hx\n      · have A : (m : «exprℕ∞») < n := by\n          rw [WithTop.coe_lt_coe] at hm⊢\n          exact nat.lt_of_succ_lt_succ hm\n        have :\n          has_fderiv_within_at ((continuous_multilinear_curry_right_equiv' 𝕜 m E F).symm ∘ fun y : E => p y m.succ)\n            ((p x).shift m.succ).curry_left s x :=\n          Htaylor.fderiv_within _ A x hx\n        rw [linear_isometry_equiv.comp_has_fderiv_within_at_iff'] at this\n        convert this\n        ext (y v)\n        change (p x (nat.succ (nat.succ m))) (cons y v) = (p x m.succ.succ) (snoc (cons y (init v)) (v (last _)))\n        rw [← cons_snoc_eq_snoc_cons, snoc_init_self]\n    · intro m(hm : (m : «exprℕ∞») ≤ n.succ)\n      cases m\n      · have : differentiable_on 𝕜 (fun x => p x 0) s := fun x hx => (Hfderiv_zero x hx).differentiable_within_at\n        exact this.continuous_on\n      · have A : (m : «exprℕ∞») ≤ n := by\n          rw [WithTop.coe_le_coe] at hm⊢\n          exact nat.lt_succ_iff.mp hm\n        have : ContinuousOn ((continuous_multilinear_curry_right_equiv' 𝕜 m E F).symm ∘ fun y : E => p y m.succ) s :=\n          Htaylor.cont _ A\n        rwa [LinearIsometryEquiv.comp_continuousOn_iff] at this\n#align has_ftaylor_series_up_to_on_succ_iff_right has_ftaylor_series_up_to_on_succ_iff_right\n\n",
 "has_ftaylor_series_up_to_on_succ_iff_left":
 "/-- `p` is a Taylor series of `f` up to `n+1` if and only if `p` is a Taylor series up to `n`, and\n`p (n + 1)` is a derivative of `p n`. -/\ntheorem has_ftaylor_series_up_to_on_succ_iff_left {n : ℕ} :\n    has_ftaylor_series_up_to_on (n + 1) f p s ↔\n      has_ftaylor_series_up_to_on n f p s ∧\n        (∀ x ∈ s, has_fderiv_within_at (fun y => p y n) (p x n.succ).curry_left s x) ∧\n          ContinuousOn (fun x => p x (n + 1)) s :=\n  by\n  constructor\n  · intro h\n    exact\n      ⟨h.of_le (WithTop.coe_le_coe.2 (nat.le_succ n)), h.fderiv_within _ (WithTop.coe_lt_coe.2 (lt_add_one n)),\n        h.cont (n + 1) le_rfl⟩\n  · intro h\n    constructor\n    · exact h.1.zero_eq\n    · intro m hm\n      by_cases h' : m < n\n      · exact h.1.fderiv_within m (WithTop.coe_lt_coe.2 h')\n      · have : m = n := Nat.eq_of_lt_succ_of_not_lt (WithTop.coe_lt_coe.1 hm) h'\n        rw [this]\n        exact h.2.1\n    · intro m hm\n      by_cases h' : m ≤ n\n      · apply h.1.cont m (WithTop.coe_le_coe.2 h')\n      · have : m = n + 1 := le_antisymm (WithTop.coe_le_coe.1 hm) (not_le.1 h')\n        rw [this]\n        exact h.2.2\n#align has_ftaylor_series_up_to_on_succ_iff_left has_ftaylor_series_up_to_on_succ_iff_left\n\n",
 "has_ftaylor_series_up_to_on":
 "theorem has_ftaylor_series_up_to.has_ftaylor_series_up_to_on (h : has_ftaylor_series_up_to n f p) (s : Set E) :\n    has_ftaylor_series_up_to_on n f p s :=\n  (has_ftaylor_series_up_to_on_univ_iff.2 h).mono (subset_univ _)\n#align has_ftaylor_series_up_to.has_ftaylor_series_up_to_on has_ftaylor_series_up_to.has_ftaylor_series_up_to_on\n\n",
 "has_fderiv_within_at":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ∞» -/\n/-- If a function has a Taylor series at order at least `1`, then the term of order `1` of this\nseries is a derivative of `f`. -/\ntheorem has_ftaylor_series_up_to_on.has_fderiv_within_at (h : has_ftaylor_series_up_to_on n f p s) (hn : 1 ≤ n)\n    (hx : x ∈ s) : has_fderiv_within_at f (continuous_multilinear_curry_fin1 𝕜 E F (p x 1)) s x :=\n  by\n  have A : ∀ y ∈ s, f y = (continuous_multilinear_curry_fin0 𝕜 E F) (p y 0) :=\n    by\n    intro y hy\n    rw [← h.zero_eq y hy]\n    rfl\n  suffices H :\n    has_fderiv_within_at (fun y => continuous_multilinear_curry_fin0 𝕜 E F (p y 0))\n      (continuous_multilinear_curry_fin1 𝕜 E F (p x 1)) s x\n  · exact H.congr A (A x hx)\n  rw [linear_isometry_equiv.comp_has_fderiv_within_at_iff']\n  have : ((0 : ℕ) : «exprℕ∞») < n := lt_of_lt_of_le (WithTop.coe_lt_coe.2 nat.zero_lt_one) hn\n  convert h.fderiv_within _ this x hx\n  ext (y v)\n  change (p x 1) (snoc 0 y) = (p x 1) (cons y v)\n  unfold_coes\n  congr with i\n  rw [Unique.eq_default i]\n  rfl\n#align has_ftaylor_series_up_to_on.has_fderiv_within_at has_ftaylor_series_up_to_on.has_fderiv_within_at\n\n",
 "has_fderiv_at":
 "/-- If a function has a Taylor series at order at least `1`, then the term of order `1` of this\nseries is a derivative of `f`. -/\ntheorem has_ftaylor_series_up_to.has_fderiv_at (h : has_ftaylor_series_up_to n f p) (hn : 1 ≤ n) (x : E) :\n    has_fderiv_at f (continuous_multilinear_curry_fin1 𝕜 E F (p x 1)) x :=\n  by\n  rw [← has_fderiv_within_at_univ]\n  exact (has_ftaylor_series_up_to_on_univ_iff.2 h).has_fderiv_within_at hn (mem_univ _)\n#align has_ftaylor_series_up_to.has_fderiv_at has_ftaylor_series_up_to.has_fderiv_at\n\n",
 "ftaylor_series_within_univ":
 "theorem ftaylor_series_within_univ : ftaylor_series_within 𝕜 f univ = ftaylor_series 𝕜 f :=\n  by\n  ext1 x; ext1 n\n  change iterated_fderiv_within 𝕜 n f univ x = iterated_fderiv 𝕜 n f x\n  rw [iterated_fderiv_within_univ]\n#align ftaylor_series_within_univ ftaylor_series_within_univ\n\n",
 "ftaylor_series_within":
 "/-- When a function is `C^n` in a set `s` of unique differentiability, it admits\n`ftaylor_series_within 𝕜 f s` as a Taylor series up to order `n` in `s`. -/\ntheorem cont_diff_on.ftaylor_series_within (h : cont_diff_on 𝕜 n f s) (hs : unique_diff_on 𝕜 s) :\n    has_ftaylor_series_up_to_on n f (ftaylor_series_within 𝕜 f s) s :=\n  by\n  constructor\n  · intro x hx\n    simp only [ftaylor_series_within, continuous_multilinear_map.uncurry0_apply, iterated_fderiv_within_zero_apply]\n  · intro m hm x hx\n    rcases(h x hx) m.succ (ENat.add_one_le_of_lt hm) with ⟨u, hu, p, Hp⟩\n    rw [insert_eq_of_mem hx] at hu\n    rcases mem_nhdsWithin.1 hu with ⟨o, o_open, xo, ho⟩\n    rw [inter_comm] at ho\n    have : p x m.succ = ftaylor_series_within 𝕜 f s x m.succ :=\n      by\n      change p x m.succ = iterated_fderiv_within 𝕜 m.succ f s x\n      rw [← iterated_fderiv_within_inter (IsOpen.mem_nhds o_open xo) hs hx]\n      exact (Hp.mono ho).eq_ftaylor_series_of_unique_diff_on le_rfl (hs.inter o_open) ⟨hx, xo⟩\n    rw [← this, ← has_fderiv_within_at_inter (IsOpen.mem_nhds o_open xo)]\n    have A : ∀ y ∈ s ∩ o, p y m = ftaylor_series_within 𝕜 f s y m :=\n      by\n      rintro y ⟨hy, yo⟩\n      change p y m = iterated_fderiv_within 𝕜 m f s y\n      rw [← iterated_fderiv_within_inter (IsOpen.mem_nhds o_open yo) hs hy]\n      exact\n        (Hp.mono ho).eq_ftaylor_series_of_unique_diff_on (WithTop.coe_le_coe.2 (nat.le_succ m)) (hs.inter o_open)\n          ⟨hy, yo⟩\n    exact\n      ((Hp.mono ho).fderiv_within m (WithTop.coe_lt_coe.2 (lt_add_one m)) x ⟨hx, xo⟩).congr (fun y hy => (A y hy).symm)\n        (A x ⟨hx, xo⟩).symm\n  · intro m hm\n    apply continuousOn_of_locally_continuousOn\n    intro x hx\n    rcases h x hx m hm with ⟨u, hu, p, Hp⟩\n    rcases mem_nhdsWithin.1 hu with ⟨o, o_open, xo, ho⟩\n    rw [insert_eq_of_mem hx] at ho\n    rw [inter_comm] at ho\n    refine' ⟨o, o_open, xo, _⟩\n    have A : ∀ y ∈ s ∩ o, p y m = ftaylor_series_within 𝕜 f s y m :=\n      by\n      rintro y ⟨hy, yo⟩\n      change p y m = iterated_fderiv_within 𝕜 m f s y\n      rw [← iterated_fderiv_within_inter (IsOpen.mem_nhds o_open yo) hs hy]\n      exact (Hp.mono ho).eq_ftaylor_series_of_unique_diff_on le_rfl (hs.inter o_open) ⟨hy, yo⟩\n    exact ((Hp.mono ho).cont m le_rfl).congr fun y hy => (A y hy).symm\n#align cont_diff_on.ftaylor_series_within cont_diff_on.ftaylor_series_within\n\n",
 "fderiv_within":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∞» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∞» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ∞» -/\ntheorem cont_diff_on.fderiv_within (hf : cont_diff_on 𝕜 n f s) (hs : unique_diff_on 𝕜 s) (hmn : m + 1 ≤ n) :\n    cont_diff_on 𝕜 m (fun y => fderiv_within 𝕜 f s y) s :=\n  by\n  cases m\n  · change «expr∞» + 1 ≤ n at hmn\n    have : n = «expr∞» := by simpa using hmn\n    rw [this] at hf\n    exact ((cont_diff_on_top_iff_fderiv_within hs).1 hf).2\n  · change (m.succ : «exprℕ∞») ≤ n at hmn\n    exact ((cont_diff_on_succ_iff_fderiv_within hs).1 (hf.of_le hmn)).2\n#align cont_diff_on.fderiv_within cont_diff_on.fderiv_within\n\n",
 "fderiv_of_open":
 "theorem cont_diff_on.fderiv_of_open (hf : cont_diff_on 𝕜 n f s) (hs : IsOpen s) (hmn : m + 1 ≤ n) :\n    cont_diff_on 𝕜 m (fun y => fderiv 𝕜 f y) s :=\n  (hf.fderiv_within hs.unique_diff_on hmn).congr fun x hx => (fderiv_within_of_open hs hx).symm\n#align cont_diff_on.fderiv_of_open cont_diff_on.fderiv_of_open\n\n",
 "fderiv_iterated_fderiv":
 "/-- Writing explicitly the derivative of the `n`-th derivative as the composition of a currying\nlinear equiv, and the `n + 1`-th derivative. -/\ntheorem fderiv_iterated_fderiv {n : ℕ} :\n    fderiv 𝕜 (iterated_fderiv 𝕜 n f) =\n      (continuous_multilinear_curry_left_equiv 𝕜 (fun i : Fin (n + 1) => E) F).symm ∘ iterated_fderiv 𝕜 (n + 1) f :=\n  by\n  rw [iterated_fderiv_succ_eq_comp_left]\n  ext1 x\n  simp only [Function.comp_apply, LinearIsometryEquiv.symm_apply_apply]\n#align fderiv_iterated_fderiv fderiv_iterated_fderiv\n\n",
 "eventually_has_fderiv_at":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- If a function has a Taylor series at order at least `1` on a neighborhood of `x`, then\nin a neighborhood of `x`, the term of order `1` of this series is a derivative of `f`. -/\ntheorem has_ftaylor_series_up_to_on.eventually_has_fderiv_at (h : has_ftaylor_series_up_to_on n f p s) (hn : 1 ≤ n)\n    (hx : s ∈ (nhds) x) :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" ((nhds) x)\n      (has_fderiv_at f (continuous_multilinear_curry_fin1 𝕜 E F (p y 1)) y) :=\n  (eventually_eventually_nhds.2 hx).mono fun y hy => h.has_fderiv_at hn hy\n#align has_ftaylor_series_up_to_on.eventually_has_fderiv_at has_ftaylor_series_up_to_on.eventually_has_fderiv_at\n\n",
 "eventually":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\nprotected theorem cont_diff_at.eventually {n : ℕ} (h : cont_diff_at 𝕜 n f x) :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" ((nhds) x)\n      (cont_diff_at 𝕜 n f y) :=\n  by simpa [nhdsWithin_univ] using h.eventually\n#align cont_diff_at.eventually cont_diff_at.eventually\n\n",
 "eq_ftaylor_series_of_unique_diff_on":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ∞» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ∞» -/\n/-- On a set with unique differentiability, any choice of iterated differential has to coincide\nwith the one we have chosen in `iterated_fderiv_within 𝕜 m f s`. -/\ntheorem has_ftaylor_series_up_to_on.eq_ftaylor_series_of_unique_diff_on (h : has_ftaylor_series_up_to_on n f p s)\n    {m : ℕ} (hmn : (m : «exprℕ∞») ≤ n) (hs : unique_diff_on 𝕜 s) (hx : x ∈ s) :\n    p x m = iterated_fderiv_within 𝕜 m f s x :=\n  by\n  induction' m with m IH generalizing x\n  · rw [h.zero_eq' hx, iterated_fderiv_within_zero_eq_comp]\n  · have A : (m : «exprℕ∞») < n := lt_of_lt_of_le (WithTop.coe_lt_coe.2 (lt_add_one m)) hmn\n    have :\n      has_fderiv_within_at (fun y : E => iterated_fderiv_within 𝕜 m f s y)\n        (continuous_multilinear_map.curry_left (p x (nat.succ m))) s x :=\n      (h.fderiv_within m A x hx).congr (fun y hy => (IH (le_of_lt A) hy).symm) (IH (le_of_lt A) hx).symm\n    rw [iterated_fderiv_within_succ_eq_comp_left, Function.comp_apply, this.fderiv_within (hs x hx)]\n    exact (continuous_multilinear_map.uncurry_curry_left _).symm\n#align has_ftaylor_series_up_to_on.eq_ftaylor_series_of_unique_diff_on has_ftaylor_series_up_to_on.eq_ftaylor_series_of_unique_diff_on\n\n",
 "differentiable_within_at'":
 "/-- If a function is `C^n` within a set at a point, with `n ≥ 1`, then it is differentiable\nwithin this set at this point. -/\ntheorem cont_diff_within_at.differentiable_within_at' (h : cont_diff_within_at 𝕜 n f s x) (hn : 1 ≤ n) :\n    differentiable_within_at 𝕜 f (insert x s) x :=\n  by\n  rcases h 1 hn with ⟨u, hu, p, H⟩\n  rcases mem_nhdsWithin.1 hu with ⟨t, t_open, xt, tu⟩\n  rw [inter_comm] at tu\n  have := ((H.mono tu).differentiable_on le_rfl) x ⟨mem_insert x s, xt⟩\n  exact (differentiable_within_at_inter (IsOpen.mem_nhds t_open xt)).1 this\n#align cont_diff_within_at.differentiable_within_at' cont_diff_within_at.differentiable_within_at'\n\n",
 "differentiable_within_at":
 "theorem cont_diff_within_at.differentiable_within_at (h : cont_diff_within_at 𝕜 n f s x) (hn : 1 ≤ n) :\n    differentiable_within_at 𝕜 f s x :=\n  (h.differentiable_within_at' hn).mono (subset_insert x s)\n#align cont_diff_within_at.differentiable_within_at cont_diff_within_at.differentiable_within_at\n\n",
 "differentiable_on_iterated_fderiv_within":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ∞» -/\ntheorem cont_diff_on.differentiable_on_iterated_fderiv_within {m : ℕ} (h : cont_diff_on 𝕜 n f s)\n    (hmn : (m : «exprℕ∞») < n) (hs : unique_diff_on 𝕜 s) : differentiable_on 𝕜 (iterated_fderiv_within 𝕜 m f s) s :=\n  fun x hx => ((h.ftaylor_series_within hs).fderiv_within m hmn x hx).differentiable_within_at\n#align cont_diff_on.differentiable_on_iterated_fderiv_within cont_diff_on.differentiable_on_iterated_fderiv_within\n\n",
 "differentiable_on":
 "/-- If a function is `C^n` on a set with `n ≥ 1`, then it is differentiable there. -/\ntheorem cont_diff_on.differentiable_on (h : cont_diff_on 𝕜 n f s) (hn : 1 ≤ n) : differentiable_on 𝕜 f s := fun x hx =>\n  (h x hx).differentiable_within_at hn\n#align cont_diff_on.differentiable_on cont_diff_on.differentiable_on\n\n",
 "differentiable_iterated_fderiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ∞» -/\n/-- If `f` is `C^n` then its `m`-times iterated derivative is differentiable for `m < n`. -/\ntheorem cont_diff.differentiable_iterated_fderiv {m : ℕ} (hm : (m : «exprℕ∞») < n) (hf : cont_diff 𝕜 n f) :\n    differentiable 𝕜 fun x => iterated_fderiv 𝕜 m f x :=\n  (cont_diff_iff_continuous_differentiable.mp hf).2 m hm\n#align cont_diff.differentiable_iterated_fderiv cont_diff.differentiable_iterated_fderiv\n\n",
 "differentiable_at":
 "/-- If a function is `C^n` with `n ≥ 1` at a point, then it is differentiable there. -/\ntheorem cont_diff_at.differentiable_at (h : cont_diff_at 𝕜 n f x) (hn : 1 ≤ n) : differentiable_at 𝕜 f x := by\n  simpa [hn, differentiable_within_at_univ] using h.differentiable_within_at\n#align cont_diff_at.differentiable_at cont_diff_at.differentiable_at\n\n",
 "differentiable":
 "/-- If a function is `C^n` with `n ≥ 1`, then it is differentiable. -/\ntheorem cont_diff.differentiable (h : cont_diff 𝕜 n f) (hn : 1 ≤ n) : differentiable 𝕜 f :=\n  differentiable_on_univ.1 <| (cont_diff_on_univ.2 h).differentiable_on hn\n#align cont_diff.differentiable cont_diff.differentiable\n\n",
 "continuous_within_at":
 "theorem cont_diff_within_at.continuous_within_at (h : cont_diff_within_at 𝕜 n f s x) : ContinuousWithinAt f s x :=\n  by\n  rcases h 0 bot_le with ⟨u, hu, p, H⟩\n  rw [mem_nhdsWithin_insert] at hu\n  exact (H.continuous_on.continuous_within_at hu.1).mono_of_mem hu.2\n#align cont_diff_within_at.continuous_within_at cont_diff_within_at.continuous_within_at\n\n",
 "continuous_on_iterated_fderiv_within":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ∞» -/\ntheorem cont_diff_on.continuous_on_iterated_fderiv_within {m : ℕ} (h : cont_diff_on 𝕜 n f s) (hmn : (m : «exprℕ∞») ≤ n)\n    (hs : unique_diff_on 𝕜 s) : ContinuousOn (iterated_fderiv_within 𝕜 m f s) s :=\n  (h.ftaylor_series_within hs).cont m hmn\n#align cont_diff_on.continuous_on_iterated_fderiv_within cont_diff_on.continuous_on_iterated_fderiv_within\n\n",
 "continuous_on_fderiv_within":
 "theorem cont_diff_on.continuous_on_fderiv_within (h : cont_diff_on 𝕜 n f s) (hs : unique_diff_on 𝕜 s) (hn : 1 ≤ n) :\n    ContinuousOn (fun x => fderiv_within 𝕜 f s x) s :=\n  ((cont_diff_on_succ_iff_fderiv_within hs).1 (h.of_le hn)).2.continuous_on\n#align cont_diff_on.continuous_on_fderiv_within cont_diff_on.continuous_on_fderiv_within\n\n",
 "continuous_on_fderiv_of_open":
 "theorem cont_diff_on.continuous_on_fderiv_of_open (h : cont_diff_on 𝕜 n f s) (hs : IsOpen s) (hn : 1 ≤ n) :\n    ContinuousOn (fun x => fderiv 𝕜 f x) s :=\n  ((cont_diff_on_succ_iff_fderiv_of_open hs).1 (h.of_le hn)).2.continuous_on\n#align cont_diff_on.continuous_on_fderiv_of_open cont_diff_on.continuous_on_fderiv_of_open\n\n",
 "continuous_on":
 "theorem cont_diff_on.continuous_on (h : cont_diff_on 𝕜 n f s) : ContinuousOn f s := fun x hx =>\n  (h x hx).continuous_within_at\n#align cont_diff_on.continuous_on cont_diff_on.continuous_on\n\n",
 "continuous_iterated_fderiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ∞» -/\n/-- If `f` is `C^n` then its `m`-times iterated derivative is continuous for `m ≤ n`. -/\ntheorem cont_diff.continuous_iterated_fderiv {m : ℕ} (hm : (m : «exprℕ∞») ≤ n) (hf : cont_diff 𝕜 n f) :\n    Continuous fun x => iterated_fderiv 𝕜 m f x :=\n  (cont_diff_iff_continuous_differentiable.mp hf).1 m hm\n#align cont_diff.continuous_iterated_fderiv cont_diff.continuous_iterated_fderiv\n\n",
 "continuous_fderiv_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/-- If a function is at least `C^1`, its bundled derivative (mapping `(x, v)` to `Df(x) v`) is\ncontinuous. -/\ntheorem cont_diff.continuous_fderiv_apply (h : cont_diff 𝕜 n f) (hn : 1 ≤ n) :\n    Continuous fun p : E × E => (fderiv 𝕜 f p.1 : E → F) p.2 :=\n  have A : Continuous fun q : «expr →L[ ] » E 𝕜 F × E => q.1 q.2 := is_bounded_bilinear_map_apply.continuous\n  have B : Continuous fun p : E × E => (fderiv 𝕜 f p.1, p.2) :=\n    ((h.continuous_fderiv hn).comp continuous_fst).prod_mk continuous_snd\n  A.comp B\n#align cont_diff.continuous_fderiv_apply cont_diff.continuous_fderiv_apply\n\n",
 "continuous_fderiv":
 "theorem cont_diff.continuous_fderiv (h : cont_diff 𝕜 n f) (hn : 1 ≤ n) : Continuous fun x => fderiv 𝕜 f x :=\n  (cont_diff_succ_iff_fderiv.1 (h.of_le hn)).2.continuous\n#align cont_diff.continuous_fderiv cont_diff.continuous_fderiv\n\n",
 "continuous_at":
 "theorem cont_diff_at.continuous_at (h : cont_diff_at 𝕜 n f x) : ContinuousAt f x := by\n  simpa [continuousWithinAt_univ] using h.continuous_within_at\n#align cont_diff_at.continuous_at cont_diff_at.continuous_at\n\n",
 "continuous":
 "theorem cont_diff.continuous (h : cont_diff 𝕜 n f) : Continuous f :=\n  cont_diff_zero.1 (h.of_le bot_le)\n#align cont_diff.continuous cont_diff.continuous\n\n",
 "cont_diff_zero":
 "@[simp]\ntheorem cont_diff_zero : cont_diff 𝕜 0 f ↔ Continuous f :=\n  by\n  rw [← cont_diff_on_univ, continuous_iff_continuousOn_univ]\n  exact cont_diff_on_zero\n#align cont_diff_zero cont_diff_zero\n\n",
 "cont_diff_within_at_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\ntheorem cont_diff_within_at_zero (hx : x ∈ s) :\n    cont_diff_within_at 𝕜 0 f s x ↔ ∃ u ∈ nhds_within s x, ContinuousOn f (s ∩ u) :=\n  by\n  constructor\n  · intro h\n    obtain ⟨u, H, p, hp⟩ := h 0 (by norm_num)\n    refine' ⟨u, _, _⟩\n    · simpa [hx] using H\n    · simp only [WithTop.coe_zero, has_ftaylor_series_up_to_on_zero_iff] at hp\n      exact hp.1.mono (inter_subset_right s u)\n  · rintro ⟨u, H, hu⟩\n    rw [← cont_diff_within_at_inter' H]\n    have h' : x ∈ s ∩ u := ⟨hx, mem_of_mem_nhdsWithin hx H⟩\n    exact (cont_diff_on_zero.mpr hu).cont_diff_within_at h'\n#align cont_diff_within_at_zero cont_diff_within_at_zero\n\n",
 "cont_diff_within_at_univ":
 "theorem cont_diff_within_at_univ : cont_diff_within_at 𝕜 n f univ x ↔ cont_diff_at 𝕜 n f x :=\n  iff.rfl\n#align cont_diff_within_at_univ cont_diff_within_at_univ\n\n",
 "cont_diff_within_at_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∞» -/\ntheorem cont_diff_within_at_top : cont_diff_within_at 𝕜 («expr∞») f s x ↔ ∀ n : ℕ, cont_diff_within_at 𝕜 n f s x :=\n  cont_diff_within_at_iff_forall_nat_le.trans <| by simp only [forall_prop_of_true, le_top]\n#align cont_diff_within_at_top cont_diff_within_at_top\n\n",
 "cont_diff_within_at_succ_iff_has_fderiv_within_at'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/-- A version of `cont_diff_within_at_succ_iff_has_fderiv_within_at` where all derivatives\n  are taken within the same set. -/\ntheorem cont_diff_within_at_succ_iff_has_fderiv_within_at' {n : ℕ} :\n    cont_diff_within_at 𝕜 (n + 1 : ℕ) f s x ↔\n      ∃ u ∈ nhds_within (insert x s) x,\n        u ⊆ insert x s ∧\n          ∃ f' : E → «expr →L[ ] » E 𝕜 F,\n            (∀ x ∈ u, has_fderiv_within_at f (f' x) s x) ∧ cont_diff_within_at 𝕜 n f' s x :=\n  by\n  refine' ⟨fun hf => _, _⟩\n  · obtain ⟨u, hu, f', huf', hf'⟩ := cont_diff_within_at_succ_iff_has_fderiv_within_at.mp hf\n    obtain ⟨w, hw, hxw, hwu⟩ := mem_nhds_within.mp hu\n    rw [inter_comm] at hwu\n    refine' ⟨insert x s ∩ w, inter_mem_nhdsWithin _ (hw.mem_nhds hxw), inter_subset_left _ _, f', fun y hy => _, _⟩\n    · refine' ((huf' y <| hwu hy).mono hwu).mono_of_mem _\n      refine' mem_of_superset _ (inter_subset_inter_left _ (subset_insert _ _))\n      refine' inter_mem_nhdsWithin _ (hw.mem_nhds hy.2)\n    · exact hf'.mono_of_mem (nhdsWithin_mono _ (subset_insert _ _) hu)\n  · rw [← cont_diff_within_at_insert, cont_diff_within_at_succ_iff_has_fderiv_within_at,\n      insert_eq_of_mem (mem_insert _ _)]\n    rintro ⟨u, hu, hus, f', huf', hf'⟩\n    refine' ⟨u, hu, f', fun y hy => (huf' y hy).insert'.mono hus, hf'.insert.mono hus⟩\n#align cont_diff_within_at_succ_iff_has_fderiv_within_at' cont_diff_within_at_succ_iff_has_fderiv_within_at'\n\n",
 "cont_diff_within_at_succ_iff_has_fderiv_within_at":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/-- A function is `C^(n + 1)` on a domain iff locally, it has a derivative which is `C^n`. -/\ntheorem cont_diff_within_at_succ_iff_has_fderiv_within_at {n : ℕ} :\n    cont_diff_within_at 𝕜 (n + 1 : ℕ) f s x ↔\n      ∃ u ∈ nhds_within (insert x s) x,\n        ∃ f' : E → «expr →L[ ] » E 𝕜 F, (∀ x ∈ u, has_fderiv_within_at f (f' x) u x) ∧ cont_diff_within_at 𝕜 n f' u x :=\n  by\n  constructor\n  · intro h\n    rcases h n.succ le_rfl with ⟨u, hu, p, Hp⟩\n    refine'\n      ⟨u, hu, fun y => (continuous_multilinear_curry_fin1 𝕜 E F) (p y 1), fun y hy =>\n        Hp.has_fderiv_within_at (WithTop.coe_le_coe.2 (nat.le_add_left 1 n)) hy, _⟩\n    intro m hm\n    refine' ⟨u, _, fun y : E => (p y).shift, _⟩\n    · convert self_mem_nhdsWithin\n      have : x ∈ insert x s := by simp\n      exact insert_eq_of_mem (mem_of_mem_nhdsWithin this hu)\n    · rw [has_ftaylor_series_up_to_on_succ_iff_right] at Hp\n      exact Hp.2.2.of_le hm\n  · rintro ⟨u, hu, f', f'_eq_deriv, Hf'⟩\n    rw [cont_diff_within_at_nat]\n    rcases Hf' n le_rfl with ⟨v, hv, p', Hp'⟩\n    refine' ⟨v ∩ u, _, fun x => (p' x).unshift (f x), _⟩\n    · apply Filter.inter_mem _ hu\n      apply nhdsWithin_le_of_mem hu\n      exact nhdsWithin_mono _ (subset_insert x u) hv\n    · rw [has_ftaylor_series_up_to_on_succ_iff_right]\n      refine' ⟨fun y hy => rfl, fun y hy => _, _⟩\n      · change\n          has_fderiv_within_at (fun z => (continuous_multilinear_curry_fin0 𝕜 E F).symm (f z))\n            (formal_multilinear_series.unshift (p' y) (f y) 1).curry_left (v ∩ u) y\n        rw [linear_isometry_equiv.comp_has_fderiv_within_at_iff']\n        convert(f'_eq_deriv y hy.2).mono (inter_subset_right v u)\n        rw [← Hp'.zero_eq y hy.1]\n        ext z\n        change ((p' y 0) (init (@cons 0 (fun i => E) z 0))) (@cons 0 (fun i => E) z 0 (last 0)) = ((p' y 0) 0) z\n        unfold_coes\n        congr\n        decide\n      · convert(Hp'.mono (inter_subset_left v u)).congr fun x hx => Hp'.zero_eq x hx.1\n        · ext (x y)\n          change p' x 0 (init (@snoc 0 (fun i : Fin 1 => E) 0 y)) y = p' x 0 0 y\n          rw [init_snoc]\n        · ext (x k v y)\n          change\n            p' x k (init (@snoc k (fun i : Fin k.succ => E) v y)) (@snoc k (fun i : Fin k.succ => E) v y (last k)) =\n              p' x k v y\n          rw [snoc_last, init_snoc]\n#align cont_diff_within_at_succ_iff_has_fderiv_within_at cont_diff_within_at_succ_iff_has_fderiv_within_at\n\n",
 "cont_diff_within_at_nat":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\ntheorem cont_diff_within_at_nat {n : ℕ} :\n    cont_diff_within_at 𝕜 n f s x ↔\n      ∃ u ∈ nhds_within (insert x s) x,\n        ∃ p : E → formal_multilinear_series 𝕜 E F, has_ftaylor_series_up_to_on n f p u :=\n  ⟨fun H => H n le_rfl, fun ⟨u, hu, p, hp⟩ m hm => ⟨u, hu, p, hp.of_le hm⟩⟩\n#align cont_diff_within_at_nat cont_diff_within_at_nat\n\n",
 "cont_diff_within_at_inter'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\ntheorem cont_diff_within_at_inter' (h : t ∈ nhds_within s x) :\n    cont_diff_within_at 𝕜 n f (s ∩ t) x ↔ cont_diff_within_at 𝕜 n f s x :=\n  cont_diff_within_at_congr_nhds <| Eq.symm <| nhdsWithin_restrict'' _ h\n#align cont_diff_within_at_inter' cont_diff_within_at_inter'\n\n",
 "cont_diff_within_at_inter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem cont_diff_within_at_inter (h : t ∈ (nhds) x) :\n    cont_diff_within_at 𝕜 n f (s ∩ t) x ↔ cont_diff_within_at 𝕜 n f s x :=\n  cont_diff_within_at_inter' (mem_nhdsWithin_of_mem_nhds h)\n#align cont_diff_within_at_inter cont_diff_within_at_inter\n\n",
 "cont_diff_within_at_insert":
 "theorem cont_diff_within_at_insert {y : E} : cont_diff_within_at 𝕜 n f (insert y s) x ↔ cont_diff_within_at 𝕜 n f s x :=\n  by\n  simp_rw [cont_diff_within_at]\n  rcases eq_or_ne x y with (rfl | h)\n  · simp_rw [insert_eq_of_mem (mem_insert _ _)]\n  simp_rw [insert_comm x y, nhdsWithin_insert_of_ne h]\n#align cont_diff_within_at_insert cont_diff_within_at_insert\n\n",
 "cont_diff_within_at_iff_forall_nat_le":
 "theorem cont_diff_within_at_iff_forall_nat_le :\n    cont_diff_within_at 𝕜 n f s x ↔ ∀ m : ℕ, ↑m ≤ n → cont_diff_within_at 𝕜 m f s x :=\n  ⟨fun H m hm => H.of_le hm, fun H m hm => H m hm _ le_rfl⟩\n#align cont_diff_within_at_iff_forall_nat_le cont_diff_within_at_iff_forall_nat_le\n\n",
 "cont_diff_within_at_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\ntheorem filter.eventually_eq.cont_diff_within_at_iff (h₁ : «expr =ᶠ[ ] » f₁ (nhds_within s x) f) (hx : f₁ x = f x) :\n    cont_diff_within_at 𝕜 n f₁ s x ↔ cont_diff_within_at 𝕜 n f s x :=\n  ⟨fun H => cont_diff_within_at.congr_of_eventually_eq H h₁.symm hx.symm, fun H => H.congr_of_eventually_eq h₁ hx⟩\n#align filter.eventually_eq.cont_diff_within_at_iff filter.eventually_eq.cont_diff_within_at_iff\n\n",
 "cont_diff_within_at_congr_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\ntheorem cont_diff_within_at_congr_nhds {t : Set E} (hst : nhds_within s x = nhds_within t x) :\n    cont_diff_within_at 𝕜 n f s x ↔ cont_diff_within_at 𝕜 n f t x :=\n  ⟨fun h => h.congr_nhds hst, fun h => h.congr_nhds hst.symm⟩\n#align cont_diff_within_at_congr_nhds cont_diff_within_at_congr_nhds\n\n",
 "cont_diff_within_at":
 "theorem cont_diff.cont_diff_within_at (h : cont_diff 𝕜 n f) : cont_diff_within_at 𝕜 n f s x :=\n  h.cont_diff_at.cont_diff_within_at\n#align cont_diff.cont_diff_within_at cont_diff.cont_diff_within_at\n\n",
 "cont_diff_top_iff_fderiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∞» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∞» -/\n/-- A function is `C^∞` if and only if it is differentiable,\nand its derivative (formulated in terms of `fderiv`) is `C^∞`. -/\ntheorem cont_diff_top_iff_fderiv :\n    cont_diff 𝕜 («expr∞») f ↔ differentiable 𝕜 f ∧ cont_diff 𝕜 («expr∞») fun y => fderiv 𝕜 f y :=\n  by\n  simp only [← cont_diff_on_univ, ← differentiable_on_univ, ← fderiv_within_univ]\n  rw [cont_diff_on_top_iff_fderiv_within unique_diff_on_univ]\n#align cont_diff_top_iff_fderiv cont_diff_top_iff_fderiv\n\n",
 "cont_diff_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∞» -/\ntheorem cont_diff_top : cont_diff 𝕜 («expr∞») f ↔ ∀ n : ℕ, cont_diff 𝕜 n f := by\n  simp [cont_diff_on_univ.symm, cont_diff_on_top]\n#align cont_diff_top cont_diff_top\n\n",
 "cont_diff_succ_iff_has_fderiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/-- A function is `C^(n+1)` iff it has a `C^n` derivative. -/\ntheorem cont_diff_succ_iff_has_fderiv {n : ℕ} :\n    cont_diff 𝕜 (n + 1 : ℕ) f ↔ ∃ f' : E → «expr →L[ ] » E 𝕜 F, cont_diff 𝕜 n f' ∧ ∀ x, has_fderiv_at f (f' x) x := by\n  simp only [← cont_diff_on_univ, ← has_fderiv_within_at_univ,\n    cont_diff_on_succ_iff_has_fderiv_within unique_diff_on_univ, Set.mem_univ, forall_true_left]\n#align cont_diff_succ_iff_has_fderiv cont_diff_succ_iff_has_fderiv\n\n",
 "cont_diff_succ_iff_fderiv":
 "/-- A function is `C^(n + 1)` if and only if it is differentiable,\nand its derivative (formulated in terms of `fderiv`) is `C^n`. -/\ntheorem cont_diff_succ_iff_fderiv {n : ℕ} :\n    cont_diff 𝕜 (n + 1 : ℕ) f ↔ differentiable 𝕜 f ∧ cont_diff 𝕜 n fun y => fderiv 𝕜 f y := by\n  simp only [← cont_diff_on_univ, ← differentiable_on_univ, ← fderiv_within_univ,\n    cont_diff_on_succ_iff_fderiv_within unique_diff_on_univ]\n#align cont_diff_succ_iff_fderiv cont_diff_succ_iff_fderiv\n\n",
 "cont_diff_one_iff_fderiv":
 "theorem cont_diff_one_iff_fderiv : cont_diff 𝕜 1 f ↔ differentiable 𝕜 f ∧ Continuous (fderiv 𝕜 f) :=\n  cont_diff_succ_iff_fderiv.trans <| iff.rfl.and cont_diff_zero\n#align cont_diff_one_iff_fderiv cont_diff_one_iff_fderiv\n\n",
 "cont_diff_on_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ∞» -/\n@[simp]\ntheorem cont_diff_on_zero : cont_diff_on 𝕜 0 f s ↔ ContinuousOn f s :=\n  by\n  refine' ⟨fun H => H.continuous_on, fun H => _⟩\n  intro x hx m hm\n  have : (m : «exprℕ∞») = 0 := le_antisymm hm bot_le\n  rw [this]\n  refine' ⟨insert x s, self_mem_nhdsWithin, ftaylor_series_within 𝕜 f s, _⟩\n  rw [has_ftaylor_series_up_to_on_zero_iff]\n  exact ⟨by rwa [insert_eq_of_mem hx], fun x hx => by simp [ftaylor_series_within]⟩\n#align cont_diff_on_zero cont_diff_on_zero\n\n",
 "cont_diff_on_univ":
 "theorem cont_diff_on_univ : cont_diff_on 𝕜 n f univ ↔ cont_diff 𝕜 n f :=\n  by\n  constructor\n  · intro H\n    use ftaylor_series_within 𝕜 f univ\n    rw [← has_ftaylor_series_up_to_on_univ_iff]\n    exact H.ftaylor_series_within unique_diff_on_univ\n  · rintro ⟨p, hp⟩ x hx m hm\n    exact ⟨univ, filter.univ_sets _, p, (hp.has_ftaylor_series_up_to_on univ).of_le hm⟩\n#align cont_diff_on_univ cont_diff_on_univ\n\n",
 "cont_diff_on_top_iff_fderiv_within":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ∞» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∞» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∞» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∞» -/\n/-- A function is `C^∞` on a domain with unique derivatives if and only if it is differentiable\nthere, and its derivative (expressed with `fderiv_within`) is `C^∞`. -/\ntheorem cont_diff_on_top_iff_fderiv_within (hs : unique_diff_on 𝕜 s) :\n    cont_diff_on 𝕜 («expr∞») f s ↔\n      differentiable_on 𝕜 f s ∧ cont_diff_on 𝕜 («expr∞») (fun y => fderiv_within 𝕜 f s y) s :=\n  by\n  constructor\n  · intro h\n    refine' ⟨h.differentiable_on le_top, _⟩\n    apply cont_diff_on_top.2 fun n => ((cont_diff_on_succ_iff_fderiv_within hs).1 _).2\n    exact h.of_le le_top\n  · intro h\n    refine' cont_diff_on_top.2 fun n => _\n    have A : (n : «exprℕ∞») ≤ «expr∞» := le_top\n    apply ((cont_diff_on_succ_iff_fderiv_within hs).2 ⟨h.1, h.2.of_le A⟩).of_le\n    exact WithTop.coe_le_coe.2 (nat.le_succ n)\n#align cont_diff_on_top_iff_fderiv_within cont_diff_on_top_iff_fderiv_within\n\n",
 "cont_diff_on_top_iff_fderiv_of_open":
 "/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:73:14: unsupported tactic `congrm #[[expr «expr ∧ »(_, _)]] -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∞» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∞» -/\n/-- A function is `C^∞` on an open domain if and only if it is differentiable there, and its\nderivative (expressed with `fderiv`) is `C^∞`. -/\ntheorem cont_diff_on_top_iff_fderiv_of_open (hs : IsOpen s) :\n    cont_diff_on 𝕜 («expr∞») f s ↔ differentiable_on 𝕜 f s ∧ cont_diff_on 𝕜 («expr∞») (fun y => fderiv 𝕜 f y) s :=\n  by\n  rw [cont_diff_on_top_iff_fderiv_within hs.unique_diff_on]\n  trace\n    \"./././Mathport/Syntax/Translate/Tactic/Builtin.lean:73:14: unsupported tactic `congrm #[[expr «expr ∧ »(_, _)]]\"\n  apply cont_diff_on_congr\n  intro x hx\n  exact fderiv_within_of_open hs hx\n#align cont_diff_on_top_iff_fderiv_of_open cont_diff_on_top_iff_fderiv_of_open\n\n",
 "cont_diff_on_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∞» -/\ntheorem cont_diff_on_top : cont_diff_on 𝕜 («expr∞») f s ↔ ∀ n : ℕ, cont_diff_on 𝕜 n f s :=\n  cont_diff_on_iff_forall_nat_le.trans <| by simp only [le_top, forall_prop_of_true]\n#align cont_diff_on_top cont_diff_on_top\n\n",
 "cont_diff_on_succ_of_fderiv_within":
 "theorem cont_diff_on_succ_of_fderiv_within {n : ℕ} (hf : differentiable_on 𝕜 f s)\n    (h : cont_diff_on 𝕜 n (fun y => fderiv_within 𝕜 f s y) s) : cont_diff_on 𝕜 (n + 1 : ℕ) f s :=\n  by\n  intro x hx\n  rw [cont_diff_within_at_succ_iff_has_fderiv_within_at, insert_eq_of_mem hx]\n  exact ⟨s, self_mem_nhdsWithin, fderiv_within 𝕜 f s, fun y hy => (hf y hy).has_fderiv_within_at, h x hx⟩\n#align cont_diff_on_succ_of_fderiv_within cont_diff_on_succ_of_fderiv_within\n\n",
 "cont_diff_on_succ_iff_has_fderiv_within_at":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/-- A function is `C^(n + 1)` on a domain iff locally, it has a derivative which is `C^n`. -/\ntheorem cont_diff_on_succ_iff_has_fderiv_within_at {n : ℕ} :\n    cont_diff_on 𝕜 (n + 1 : ℕ) f s ↔\n      ∀ x ∈ s,\n        ∃ u ∈ nhds_within (insert x s) x,\n          ∃ f' : E → «expr →L[ ] » E 𝕜 F, (∀ x ∈ u, has_fderiv_within_at f (f' x) u x) ∧ cont_diff_on 𝕜 n f' u :=\n  by\n  constructor\n  · intro h x hx\n    rcases(h x hx) n.succ le_rfl with ⟨u, hu, p, Hp⟩\n    refine'\n      ⟨u, hu, fun y => (continuous_multilinear_curry_fin1 𝕜 E F) (p y 1), fun y hy =>\n        Hp.has_fderiv_within_at (WithTop.coe_le_coe.2 (nat.le_add_left 1 n)) hy, _⟩\n    rw [has_ftaylor_series_up_to_on_succ_iff_right] at Hp\n    intro z hz m hm\n    refine' ⟨u, _, fun x : E => (p x).shift, Hp.2.2.of_le hm⟩\n    convert self_mem_nhdsWithin\n    exact insert_eq_of_mem hz\n  · intro h x hx\n    rw [cont_diff_within_at_succ_iff_has_fderiv_within_at]\n    rcases h x hx with ⟨u, u_nhbd, f', hu, hf'⟩\n    have : x ∈ u := mem_of_mem_nhdsWithin (mem_insert _ _) u_nhbd\n    exact ⟨u, u_nhbd, f', hu, hf' x this⟩\n#align cont_diff_on_succ_iff_has_fderiv_within_at cont_diff_on_succ_iff_has_fderiv_within_at\n\n",
 "cont_diff_on_succ_iff_has_fderiv_within":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\ntheorem cont_diff_on_succ_iff_has_fderiv_within {n : ℕ} (hs : unique_diff_on 𝕜 s) :\n    cont_diff_on 𝕜 (n + 1 : ℕ) f s ↔\n      ∃ f' : E → «expr →L[ ] » E 𝕜 F, cont_diff_on 𝕜 n f' s ∧ ∀ x, x ∈ s → has_fderiv_within_at f (f' x) s x :=\n  by\n  rw [cont_diff_on_succ_iff_fderiv_within hs]\n  refine' ⟨fun h => ⟨fderiv_within 𝕜 f s, h.2, fun x hx => (h.1 x hx).has_fderiv_within_at⟩, fun h => _⟩\n  rcases h with ⟨f', h1, h2⟩\n  refine' ⟨fun x hx => (h2 x hx).differentiable_within_at, fun x hx => _⟩\n  exact (h1 x hx).congr' (fun y hy => (h2 y hy).fderiv_within (hs y hy)) hx\n#align cont_diff_on_succ_iff_has_fderiv_within cont_diff_on_succ_iff_has_fderiv_within\n\n",
 "cont_diff_on_succ_iff_fderiv_within":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/-- A function is `C^(n + 1)` on a domain with unique derivatives if and only if it is\ndifferentiable there, and its derivative (expressed with `fderiv_within`) is `C^n`. -/\ntheorem cont_diff_on_succ_iff_fderiv_within {n : ℕ} (hs : unique_diff_on 𝕜 s) :\n    cont_diff_on 𝕜 (n + 1 : ℕ) f s ↔ differentiable_on 𝕜 f s ∧ cont_diff_on 𝕜 n (fun y => fderiv_within 𝕜 f s y) s :=\n  by\n  refine' ⟨fun H => _, fun h => cont_diff_on_succ_of_fderiv_within h.1 h.2⟩\n  refine' ⟨H.differentiable_on (WithTop.coe_le_coe.2 (nat.le_add_left 1 n)), fun x hx => _⟩\n  rcases cont_diff_within_at_succ_iff_has_fderiv_within_at.1 (H x hx) with ⟨u, hu, f', hff', hf'⟩\n  rcases mem_nhdsWithin.1 hu with ⟨o, o_open, xo, ho⟩\n  rw [inter_comm, insert_eq_of_mem hx] at ho\n  have := hf'.mono ho\n  rw [cont_diff_within_at_inter' (mem_nhdsWithin_of_mem_nhds (IsOpen.mem_nhds o_open xo))] at this\n  apply this.congr_of_eventually_eq' _ hx\n  have : o ∩ s ∈ nhds_within s x := mem_nhdsWithin.2 ⟨o, o_open, xo, subset.refl _⟩\n  rw [inter_comm] at this\n  apply Filter.eventuallyEq_of_mem this fun y hy => _\n  have A : fderiv_within 𝕜 f (s ∩ o) y = f' y := ((hff' y (ho hy)).mono ho).fderiv_within (hs.inter o_open y hy)\n  rwa [fderiv_within_inter (IsOpen.mem_nhds o_open hy.2) (hs y hy.1)] at A\n#align cont_diff_on_succ_iff_fderiv_within cont_diff_on_succ_iff_fderiv_within\n\n",
 "cont_diff_on_succ_iff_fderiv_of_open":
 "/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:73:14: unsupported tactic `congrm #[[expr «expr ∧ »(_, _)]] -/\n/-- A function is `C^(n + 1)` on an open domain if and only if it is\ndifferentiable there, and its derivative (expressed with `fderiv`) is `C^n`. -/\ntheorem cont_diff_on_succ_iff_fderiv_of_open {n : ℕ} (hs : IsOpen s) :\n    cont_diff_on 𝕜 (n + 1 : ℕ) f s ↔ differentiable_on 𝕜 f s ∧ cont_diff_on 𝕜 n (fun y => fderiv 𝕜 f y) s :=\n  by\n  rw [cont_diff_on_succ_iff_fderiv_within hs.unique_diff_on]\n  trace\n    \"./././Mathport/Syntax/Translate/Tactic/Builtin.lean:73:14: unsupported tactic `congrm #[[expr «expr ∧ »(_, _)]]\"\n  apply cont_diff_on_congr\n  intro x hx\n  exact fderiv_within_of_open hs hx\n#align cont_diff_on_succ_iff_fderiv_of_open cont_diff_on_succ_iff_fderiv_of_open\n\n",
 "cont_diff_on_of_locally_cont_diff_on":
 "/-- If a function is `C^n` around each point in a set, then it is `C^n` on the set. -/\ntheorem cont_diff_on_of_locally_cont_diff_on (h : ∀ x ∈ s, ∃ u, IsOpen u ∧ x ∈ u ∧ cont_diff_on 𝕜 n f (s ∩ u)) :\n    cont_diff_on 𝕜 n f s := by\n  intro x xs\n  rcases h x xs with ⟨u, u_open, xu, hu⟩\n  apply (cont_diff_within_at_inter _).1 (hu x ⟨xs, xu⟩)\n  exact IsOpen.mem_nhds u_open xu\n#align cont_diff_on_of_locally_cont_diff_on cont_diff_on_of_locally_cont_diff_on\n\n",
 "cont_diff_on_of_differentiable_on":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ∞» -/\ntheorem cont_diff_on_of_differentiable_on\n    (h : ∀ m : ℕ, (m : «exprℕ∞») ≤ n → differentiable_on 𝕜 (iterated_fderiv_within 𝕜 m f s) s) : cont_diff_on 𝕜 n f s :=\n  cont_diff_on_of_continuous_on_differentiable_on (fun m hm => (h m hm).continuous_on) fun m hm => h m (le_of_lt hm)\n#align cont_diff_on_of_differentiable_on cont_diff_on_of_differentiable_on\n\n",
 "cont_diff_on_of_continuous_on_differentiable_on":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ∞» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ∞» -/\ntheorem cont_diff_on_of_continuous_on_differentiable_on\n    (Hcont : ∀ m : ℕ, (m : «exprℕ∞») ≤ n → ContinuousOn (fun x => iterated_fderiv_within 𝕜 m f s x) s)\n    (Hdiff : ∀ m : ℕ, (m : «exprℕ∞») < n → differentiable_on 𝕜 (fun x => iterated_fderiv_within 𝕜 m f s x) s) :\n    cont_diff_on 𝕜 n f s := by\n  intro x hx m hm\n  rw [insert_eq_of_mem hx]\n  refine' ⟨s, self_mem_nhdsWithin, ftaylor_series_within 𝕜 f s, _⟩\n  constructor\n  · intro y hy\n    simp only [ftaylor_series_within, continuous_multilinear_map.uncurry0_apply, iterated_fderiv_within_zero_apply]\n  · intro k hk y hy\n    convert(Hdiff k (lt_of_lt_of_le hk hm) y hy).has_fderiv_within_at\n    simp only [ftaylor_series_within, iterated_fderiv_within_succ_eq_comp_left, ContinuousLinearEquiv.coe_apply,\n      Function.comp_apply, coe_fn_coe_base]\n    exact continuous_linear_map.curry_uncurry_left _\n  · intro k hk\n    exact Hcont k (le_trans hk hm)\n#align cont_diff_on_of_continuous_on_differentiable_on cont_diff_on_of_continuous_on_differentiable_on\n\n",
 "cont_diff_on_iff_forall_nat_le":
 "theorem cont_diff_on_iff_forall_nat_le : cont_diff_on 𝕜 n f s ↔ ∀ m : ℕ, ↑m ≤ n → cont_diff_on 𝕜 m f s :=\n  ⟨fun H m hm => H.of_le hm, fun H x hx m hm => H m hm x hx m le_rfl⟩\n#align cont_diff_on_iff_forall_nat_le cont_diff_on_iff_forall_nat_le\n\n",
 "cont_diff_on_iff_continuous_on_differentiable_on":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ∞» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ∞» -/\ntheorem cont_diff_on_iff_continuous_on_differentiable_on (hs : unique_diff_on 𝕜 s) :\n    cont_diff_on 𝕜 n f s ↔\n      (∀ m : ℕ, (m : «exprℕ∞») ≤ n → ContinuousOn (fun x => iterated_fderiv_within 𝕜 m f s x) s) ∧\n        ∀ m : ℕ, (m : «exprℕ∞») < n → differentiable_on 𝕜 (fun x => iterated_fderiv_within 𝕜 m f s x) s :=\n  by\n  constructor\n  · intro h\n    constructor\n    · intro m hm\n      exact h.continuous_on_iterated_fderiv_within hm hs\n    · intro m hm\n      exact h.differentiable_on_iterated_fderiv_within hm hs\n  · intro h\n    exact cont_diff_on_of_continuous_on_differentiable_on h.1 h.2\n#align cont_diff_on_iff_continuous_on_differentiable_on cont_diff_on_iff_continuous_on_differentiable_on\n\n",
 "cont_diff_on_congr":
 "theorem cont_diff_on_congr (h₁ : ∀ x ∈ s, f₁ x = f x) : cont_diff_on 𝕜 n f₁ s ↔ cont_diff_on 𝕜 n f s :=\n  ⟨fun H => H.congr fun x hx => (h₁ x hx).symm, fun H => H.congr h₁⟩\n#align cont_diff_on_congr cont_diff_on_congr\n\n",
 "cont_diff_on_all_iff_nat":
 "theorem cont_diff_on_all_iff_nat : (∀ n, cont_diff_on 𝕜 n f s) ↔ ∀ n : ℕ, cont_diff_on 𝕜 n f s :=\n  by\n  refine' ⟨fun H n => H n, _⟩\n  rintro H (_ | n)\n  exacts[cont_diff_on_top.2 H, H n]\n#align cont_diff_on_all_iff_nat cont_diff_on_all_iff_nat\n\n",
 "cont_diff_on":
 "theorem cont_diff.cont_diff_on (h : cont_diff 𝕜 n f) : cont_diff_on 𝕜 n f s :=\n  (cont_diff_on_univ.2 h).mono (subset_univ _)\n#align cont_diff.cont_diff_on cont_diff.cont_diff_on\n\n",
 "cont_diff_of_differentiable_iterated_fderiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ∞» -/\ntheorem cont_diff_of_differentiable_iterated_fderiv\n    (h : ∀ m : ℕ, (m : «exprℕ∞») ≤ n → differentiable 𝕜 (iterated_fderiv 𝕜 m f)) : cont_diff 𝕜 n f :=\n  cont_diff_iff_continuous_differentiable.2 ⟨fun m hm => (h m hm).continuous, fun m hm => h m (le_of_lt hm)⟩\n#align cont_diff_of_differentiable_iterated_fderiv cont_diff_of_differentiable_iterated_fderiv\n\n",
 "cont_diff_iff_ftaylor_series":
 "/-- When a function is `C^n` in a set `s` of unique differentiability, it admits\n`ftaylor_series_within 𝕜 f s` as a Taylor series up to order `n` in `s`. -/\ntheorem cont_diff_iff_ftaylor_series : cont_diff 𝕜 n f ↔ has_ftaylor_series_up_to n f (ftaylor_series 𝕜 f) :=\n  by\n  constructor\n  · rw [← cont_diff_on_univ, ← has_ftaylor_series_up_to_on_univ_iff, ← ftaylor_series_within_univ]\n    exact fun h => cont_diff_on.ftaylor_series_within h unique_diff_on_univ\n  · intro h\n    exact ⟨ftaylor_series 𝕜 f, h⟩\n#align cont_diff_iff_ftaylor_series cont_diff_iff_ftaylor_series\n\n",
 "cont_diff_iff_forall_nat_le":
 "theorem cont_diff_iff_forall_nat_le : cont_diff 𝕜 n f ↔ ∀ m : ℕ, ↑m ≤ n → cont_diff 𝕜 m f :=\n  by\n  simp_rw [← cont_diff_on_univ]\n  exact cont_diff_on_iff_forall_nat_le\n#align cont_diff_iff_forall_nat_le cont_diff_iff_forall_nat_le\n\n",
 "cont_diff_iff_continuous_differentiable":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ∞» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ∞» -/\ntheorem cont_diff_iff_continuous_differentiable :\n    cont_diff 𝕜 n f ↔\n      (∀ m : ℕ, (m : «exprℕ∞») ≤ n → Continuous fun x => iterated_fderiv 𝕜 m f x) ∧\n        ∀ m : ℕ, (m : «exprℕ∞») < n → differentiable 𝕜 fun x => iterated_fderiv 𝕜 m f x :=\n  by\n  simp [cont_diff_on_univ.symm, continuous_iff_continuousOn_univ, differentiable_on_univ.symm,\n    iterated_fderiv_within_univ, cont_diff_on_iff_continuous_on_differentiable_on unique_diff_on_univ]\n#align cont_diff_iff_continuous_differentiable cont_diff_iff_continuous_differentiable\n\n",
 "cont_diff_iff_cont_diff_at":
 "theorem cont_diff_iff_cont_diff_at : cont_diff 𝕜 n f ↔ ∀ x, cont_diff_at 𝕜 n f x := by\n  simp [← cont_diff_on_univ, cont_diff_on, cont_diff_at]\n#align cont_diff_iff_cont_diff_at cont_diff_iff_cont_diff_at\n\n",
 "cont_diff_at_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem cont_diff_at_zero : cont_diff_at 𝕜 0 f x ↔ ∃ u ∈ (nhds) x, ContinuousOn f u :=\n  by\n  rw [← cont_diff_within_at_univ]\n  simp [cont_diff_within_at_zero, nhdsWithin_univ]\n#align cont_diff_at_zero cont_diff_at_zero\n\n",
 "cont_diff_at_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∞» -/\ntheorem cont_diff_at_top : cont_diff_at 𝕜 («expr∞») f x ↔ ∀ n : ℕ, cont_diff_at 𝕜 n f x := by\n  simp [← cont_diff_within_at_univ, cont_diff_within_at_top]\n#align cont_diff_at_top cont_diff_at_top\n\n",
 "cont_diff_at_succ_iff_has_fderiv_at":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- A function is `C^(n + 1)` at a point iff locally, it has a derivative which is `C^n`. -/\ntheorem cont_diff_at_succ_iff_has_fderiv_at {n : ℕ} :\n    cont_diff_at 𝕜 (n + 1 : ℕ) f x ↔\n      ∃ f' : E → «expr →L[ ] » E 𝕜 F, (∃ u ∈ (nhds) x, ∀ x ∈ u, has_fderiv_at f (f' x) x) ∧ cont_diff_at 𝕜 n f' x :=\n  by\n  rw [← cont_diff_within_at_univ, cont_diff_within_at_succ_iff_has_fderiv_within_at]\n  simp only [nhdsWithin_univ, exists_prop, mem_univ, insert_eq_of_mem]\n  constructor\n  · rintro ⟨u, H, f', h_fderiv, h_cont_diff⟩\n    rcases mem_nhds_iff.mp H with ⟨t, htu, ht, hxt⟩\n    refine' ⟨f', ⟨t, _⟩, h_cont_diff.cont_diff_at H⟩\n    refine' ⟨mem_nhds_iff.mpr ⟨t, subset.rfl, ht, hxt⟩, _⟩\n    intro y hyt\n    refine' (h_fderiv y (htu hyt)).has_fderiv_at _\n    exact mem_nhds_iff.mpr ⟨t, htu, ht, hyt⟩\n  · rintro ⟨f', ⟨u, H, h_fderiv⟩, h_cont_diff⟩\n    refine' ⟨u, H, f', _, h_cont_diff.cont_diff_within_at⟩\n    intro x hxu\n    exact (h_fderiv x hxu).has_fderiv_within_at\n#align cont_diff_at_succ_iff_has_fderiv_at cont_diff_at_succ_iff_has_fderiv_at\n\n",
 "cont_diff_at_one_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ∞» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ∞» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem cont_diff_at_one_iff :\n    cont_diff_at 𝕜 1 f x ↔\n      ∃ f' : E → «expr →L[ ] » E 𝕜 F, ∃ u ∈ (nhds) x, ContinuousOn f' u ∧ ∀ x ∈ u, has_fderiv_at f (f' x) x :=\n  by\n  simp_rw [show (1 : «exprℕ∞») = (0 + 1 : ℕ) from (zero_add 1).symm, cont_diff_at_succ_iff_has_fderiv_at,\n    show ((0 : ℕ) : «exprℕ∞») = 0 from rfl, cont_diff_at_zero,\n    exists_mem_and_iff antitone_bforall antitone_continuousOn, and_comm']\n#align cont_diff_at_one_iff cont_diff_at_one_iff\n\n",
 "cont_diff_at":
 "theorem cont_diff.cont_diff_at (h : cont_diff 𝕜 n f) : cont_diff_at 𝕜 n f x :=\n  cont_diff_iff_cont_diff_at.1 h x\n#align cont_diff.cont_diff_at cont_diff.cont_diff_at\n\n",
 "cont_diff_all_iff_nat":
 "theorem cont_diff_all_iff_nat : (∀ n, cont_diff 𝕜 n f) ↔ ∀ n : ℕ, cont_diff 𝕜 n f := by\n  simp only [← cont_diff_on_univ, cont_diff_on_all_iff_nat]\n#align cont_diff_all_iff_nat cont_diff_all_iff_nat\n\n",
 "cont_diff":
 "/-- If `f` has a Taylor series up to `n`, then it is `C^n`. -/\ntheorem has_ftaylor_series_up_to.cont_diff {f' : E → formal_multilinear_series 𝕜 E F}\n    (hf : has_ftaylor_series_up_to n f f') : cont_diff 𝕜 n f :=\n  ⟨f', hf⟩\n#align has_ftaylor_series_up_to.cont_diff has_ftaylor_series_up_to.cont_diff\n\n",
 "congr_of_eventually_eq_insert":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\ntheorem cont_diff_within_at.congr_of_eventually_eq_insert (h : cont_diff_within_at 𝕜 n f s x)\n    (h₁ : «expr =ᶠ[ ] » f₁ (nhds_within (insert x s) x) f) : cont_diff_within_at 𝕜 n f₁ s x :=\n  h.congr_of_eventually_eq (nhdsWithin_mono x (subset_insert x s) h₁) (mem_of_mem_nhdsWithin (mem_insert x s) h₁ : _)\n#align cont_diff_within_at.congr_of_eventually_eq_insert cont_diff_within_at.congr_of_eventually_eq_insert\n\n",
 "congr_of_eventually_eq'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\ntheorem cont_diff_within_at.congr_of_eventually_eq' (h : cont_diff_within_at 𝕜 n f s x)\n    (h₁ : «expr =ᶠ[ ] » f₁ (nhds_within s x) f) (hx : x ∈ s) : cont_diff_within_at 𝕜 n f₁ s x :=\n  h.congr_of_eventually_eq h₁ <| h₁.self_of_nhds_within hx\n#align cont_diff_within_at.congr_of_eventually_eq' cont_diff_within_at.congr_of_eventually_eq'\n\n",
 "congr_of_eventually_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem cont_diff_at.congr_of_eventually_eq (h : cont_diff_at 𝕜 n f x) (hg : «expr =ᶠ[ ] » f₁ ((nhds) x) f) :\n    cont_diff_at 𝕜 n f₁ x :=\n  h.congr_of_eventually_eq' (by rwa [nhdsWithin_univ]) (mem_univ x)\n#align cont_diff_at.congr_of_eventually_eq cont_diff_at.congr_of_eventually_eq\n\n",
 "congr_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\ntheorem cont_diff_within_at.congr_nhds (h : cont_diff_within_at 𝕜 n f s x) {t : Set E}\n    (hst : nhds_within s x = nhds_within t x) : cont_diff_within_at 𝕜 n f t x :=\n  h.mono_of_mem <| hst ▸ self_mem_nhdsWithin\n#align cont_diff_within_at.congr_nhds cont_diff_within_at.congr_nhds\n\n",
 "congr_mono":
 "theorem cont_diff_on.congr_mono (hf : cont_diff_on 𝕜 n f s) (h₁ : ∀ x ∈ s₁, f₁ x = f x) (hs : s₁ ⊆ s) :\n    cont_diff_on 𝕜 n f₁ s₁ :=\n  (hf.mono hs).congr h₁\n#align cont_diff_on.congr_mono cont_diff_on.congr_mono\n\n",
 "congr'":
 "theorem cont_diff_within_at.congr' (h : cont_diff_within_at 𝕜 n f s x) (h₁ : ∀ y ∈ s, f₁ y = f y) (hx : x ∈ s) :\n    cont_diff_within_at 𝕜 n f₁ s x :=\n  h.congr h₁ (h₁ _ hx)\n#align cont_diff_within_at.congr' cont_diff_within_at.congr'\n\n",
 "congr":
 "theorem cont_diff_on.congr (h : cont_diff_on 𝕜 n f s) (h₁ : ∀ x ∈ s, f₁ x = f x) : cont_diff_on 𝕜 n f₁ s := fun x hx =>\n  (h x hx).congr h₁ (h₁ x hx)\n#align cont_diff_on.congr cont_diff_on.congr\n\n"}