{"strongly_measurable_deriv_within_Ioi":
 "theorem strongly_measurable_deriv_within_Ioi [SecondCountableTopology F] :\n    strongly_measurable fun x => deriv_within f (Ioi x) x :=\n  by\n  borelize F\n  exact (measurable_deriv_within_Ioi f).strongly_measurable\n#align strongly_measurable_deriv_within_Ioi strongly_measurable_deriv_within_Ioi\n\n",
 "strongly_measurable_deriv_within_Ici":
 "theorem strongly_measurable_deriv_within_Ici [SecondCountableTopology F] :\n    strongly_measurable fun x => deriv_within f (Ici x) x :=\n  by\n  borelize F\n  exact (measurable_deriv_within_Ici f).strongly_measurable\n#align strongly_measurable_deriv_within_Ici strongly_measurable_deriv_within_Ici\n\n",
 "strongly_measurable_deriv":
 "theorem strongly_measurable_deriv [MeasurableSpace 𝕜] [opens_measurable_space 𝕜] [SecondCountableTopology F]\n    (f : 𝕜 → F) : strongly_measurable (deriv f) := by\n  borelize F\n  exact (measurable_deriv f).strongly_measurable\n#align strongly_measurable_deriv strongly_measurable_deriv\n\n",
 "norm_sub_le_of_mem_A":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem norm_sub_le_of_mem_A {r x : exprℝ} (hr : 0 < r) (ε : exprℝ) {L₁ L₂ : F} (h₁ : x ∈ A f L₁ r ε)\n    (h₂ : x ∈ A f L₂ r ε) : «expr‖ ‖» (L₁ - L₂) ≤ 4 * ε :=\n  by\n  suffices H : «expr‖ ‖» («expr • » (r / 2) (L₁ - L₂)) ≤ r / 2 * (4 * ε)\n  · rwa [norm_smul, Real.norm_of_nonneg (half_pos hr).le, mul_le_mul_left (half_pos hr)] at H\n  calc\n    «expr‖ ‖» («expr • » (r / 2) (L₁ - L₂)) =\n        «expr‖ ‖»\n          (f (x + r / 2) - f x - «expr • » (x + r / 2 - x) L₂ - (f (x + r / 2) - f x - «expr • » (x + r / 2 - x) L₁)) :=\n      by simp [smul_sub]\n    _ ≤\n        «expr‖ ‖» (f (x + r / 2) - f x - «expr • » (x + r / 2 - x) L₂) +\n          «expr‖ ‖» (f (x + r / 2) - f x - «expr • » (x + r / 2 - x) L₁) :=\n      (norm_sub_le _ _)\n    _ ≤ ε * r + ε * r := by\n      apply add_le_add\n      · apply le_of_mem_A h₂ <;> simp [(half_pos hr).le]\n      · apply le_of_mem_A h₁ <;> simp [(half_pos hr).le]\n    _ = r / 2 * (4 * ε) := by ring\n    \n#align norm_sub_le_of_mem_A norm_sub_le_of_mem_A\n\n",
 "mem_A_of_differentiable":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem mem_A_of_differentiable {ε : exprℝ} (hε : 0 < ε) {x : exprℝ}\n    (hx : differentiable_within_at (exprℝ) f (Ici x) x) :\n    ∃ R > 0, ∀ r ∈ Ioo (0 : exprℝ) R, x ∈ A f (deriv_within f (Ici x) x) r ε :=\n  by\n  have := hx.has_deriv_within_at\n  simp_rw [has_deriv_within_at_iff_is_o, is_o_iff] at this\n  rcases mem_nhdsWithin_Ici_iff_exists_Ico_subset.1 (this (half_pos hε)) with ⟨m, xm, hm⟩\n  refine' ⟨m - x, by linarith [show x < m from xm], fun r hr => _⟩\n  have : r ∈ Ioc (r / 2) r := ⟨half_lt_self hr.1, le_rfl⟩\n  refine' ⟨r, this, fun y hy z hz => _⟩\n  calc\n    «expr‖ ‖» (f z - f y - «expr • » (z - y) (deriv_within f (Ici x) x)) =\n        «expr‖ ‖»\n          (f z - f x - «expr • » (z - x) (deriv_within f (Ici x) x) -\n            (f y - f x - «expr • » (y - x) (deriv_within f (Ici x) x))) :=\n      by\n      congr 1\n      simp only [sub_smul]\n      abel\n    _ ≤\n        «expr‖ ‖» (f z - f x - «expr • » (z - x) (deriv_within f (Ici x) x)) +\n          «expr‖ ‖» (f y - f x - «expr • » (y - x) (deriv_within f (Ici x) x)) :=\n      (norm_sub_le _ _)\n    _ ≤ ε / 2 * «expr‖ ‖» (z - x) + ε / 2 * «expr‖ ‖» (y - x) :=\n      (add_le_add (hm ⟨hz.1, hz.2.trans_lt (by linarith [hr.2])⟩) (hm ⟨hy.1, hy.2.trans_lt (by linarith [hr.2])⟩))\n    _ ≤ ε / 2 * r + ε / 2 * r := by\n      apply add_le_add\n      · apply mul_le_mul_of_nonneg_left _ (le_of_lt (half_pos hε))\n        rw [Real.norm_of_nonneg] <;> linarith [hz.1, hz.2]\n      · apply mul_le_mul_of_nonneg_left _ (le_of_lt (half_pos hε))\n        rw [Real.norm_of_nonneg] <;> linarith [hy.1, hy.2]\n    _ = ε * r := by ring\n    \n#align mem_A_of_differentiable mem_A_of_differentiable\n\n",
 "measurable_set_of_differentiable_within_at_Ioi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- The set of right differentiability points of a function taking values in a complete space is\nBorel-measurable. -/\ntheorem measurable_set_of_differentiable_within_at_Ioi :\n    MeasurableSet { x | differentiable_within_at (exprℝ) f (Ioi x) x } := by\n  simpa [differentiable_within_at_Ioi_iff_Ici] using measurable_set_of_differentiable_within_at_Ici f\n#align measurable_set_of_differentiable_within_at_Ioi measurable_set_of_differentiable_within_at_Ioi\n\n",
 "measurable_set_of_differentiable_within_at_Ici_of_is_complete":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- The set of right differentiability points of a function, with derivative in a given complete\nset, is Borel-measurable. -/\ntheorem measurable_set_of_differentiable_within_at_Ici_of_is_complete {K : Set F} (hK : IsComplete K) :\n    MeasurableSet { x | differentiable_within_at (exprℝ) f (Ici x) x ∧ deriv_within f (Ici x) x ∈ K } := by\n  simp [differentiable_set_eq_D K hK, D, measurable_set_B, MeasurableSet.interᵢ, MeasurableSet.unionᵢ]\n#align measurable_set_of_differentiable_within_at_Ici_of_is_complete measurable_set_of_differentiable_within_at_Ici_of_is_complete\n\n",
 "measurable_set_of_differentiable_within_at_Ici":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- The set of right differentiability points of a function taking values in a complete space is\nBorel-measurable. -/\ntheorem measurable_set_of_differentiable_within_at_Ici :\n    MeasurableSet { x | differentiable_within_at (exprℝ) f (Ici x) x } :=\n  by\n  have : IsComplete (univ : Set F) := complete_univ\n  convert measurable_set_of_differentiable_within_at_Ici_of_is_complete f this\n  simp\n#align measurable_set_of_differentiable_within_at_Ici measurable_set_of_differentiable_within_at_Ici\n\n",
 "measurable_set_of_differentiable_at_of_is_complete":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/-- The set of differentiability points of a function, with derivative in a given complete set,\nis Borel-measurable. -/\ntheorem measurable_set_of_differentiable_at_of_is_complete {K : Set («expr →L[ ] » E 𝕜 F)} (hK : IsComplete K) :\n    MeasurableSet { x | differentiable_at 𝕜 f x ∧ fderiv 𝕜 f x ∈ K } := by\n  simp [differentiable_set_eq_D K hK, D, is_open_B.measurable_set, MeasurableSet.interᵢ, MeasurableSet.unionᵢ]\n#align measurable_set_of_differentiable_at_of_is_complete measurable_set_of_differentiable_at_of_is_complete\n\n",
 "measurable_set_of_differentiable_at":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/-- The set of differentiability points of a function taking values in a complete space is\nBorel-measurable. -/\ntheorem measurable_set_of_differentiable_at : MeasurableSet { x | differentiable_at 𝕜 f x } :=\n  by\n  have : IsComplete (univ : Set («expr →L[ ] » E 𝕜 F)) := complete_univ\n  convert measurable_set_of_differentiable_at_of_is_complete 𝕜 f this\n  simp\n#align measurable_set_of_differentiable_at measurable_set_of_differentiable_at\n\n",
 "measurable_set_B":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem measurable_set_B {K : Set F} {r s ε : exprℝ} : MeasurableSet (B f K r s ε) :=\n  measurable_set_of_mem_nhds_within_Ioi fun x hx => B_mem_nhds_within_Ioi hx\n#align measurable_set_B measurable_set_B\n\n",
 "measurable_fderiv_apply_const":
 "@[measurability]\ntheorem measurable_fderiv_apply_const [MeasurableSpace F] [borel_space F] (y : E) :\n    Measurable fun x => fderiv 𝕜 f x y :=\n  (continuous_linear_map.measurable_apply y).comp (measurable_fderiv 𝕜 f)\n#align measurable_fderiv_apply_const measurable_fderiv_apply_const\n\n",
 "measurable_fderiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n@[measurability]\ntheorem measurable_fderiv : Measurable (fderiv 𝕜 f) :=\n  by\n  refine' measurable_of_is_closed fun s hs => _\n  have :\n    «expr ⁻¹' » (fderiv 𝕜 f) s =\n      { x | differentiable_at 𝕜 f x ∧ fderiv 𝕜 f x ∈ s } ∪\n        { x | ¬differentiable_at 𝕜 f x } ∩ { x | (0 : «expr →L[ ] » E 𝕜 F) ∈ s } :=\n    Set.ext fun x => mem_preimage.trans fderiv_mem_iff\n  rw [this]\n  exact\n    (measurable_set_of_differentiable_at_of_is_complete _ _ hs.is_complete).union\n      ((measurable_set_of_differentiable_at _ _).compl.inter (MeasurableSet.const _))\n#align measurable_fderiv measurable_fderiv\n\n",
 "measurable_deriv_within_Ioi":
 "@[measurability]\ntheorem measurable_deriv_within_Ioi [MeasurableSpace F] [borel_space F] :\n    Measurable fun x => deriv_within f (Ioi x) x := by\n  simpa [deriv_within_Ioi_eq_Ici] using measurable_deriv_within_Ici f\n#align measurable_deriv_within_Ioi measurable_deriv_within_Ioi\n\n",
 "measurable_deriv_within_Ici":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n@[measurability]\ntheorem measurable_deriv_within_Ici [MeasurableSpace F] [borel_space F] :\n    Measurable fun x => deriv_within f (Ici x) x :=\n  by\n  refine' measurable_of_is_closed fun s hs => _\n  have :\n    «expr ⁻¹' » (fun x => deriv_within f (Ici x) x) s =\n      { x | differentiable_within_at (exprℝ) f (Ici x) x ∧ deriv_within f (Ici x) x ∈ s } ∪\n        { x | ¬differentiable_within_at (exprℝ) f (Ici x) x } ∩ { x | (0 : F) ∈ s } :=\n    Set.ext fun x => mem_preimage.trans deriv_within_mem_iff\n  rw [this]\n  exact\n    (measurable_set_of_differentiable_within_at_Ici_of_is_complete _ hs.is_complete).union\n      ((measurable_set_of_differentiable_within_at_Ici _).compl.inter (MeasurableSet.const _))\n#align measurable_deriv_within_Ici measurable_deriv_within_Ici\n\n",
 "measurable_deriv":
 "@[measurability]\ntheorem measurable_deriv [MeasurableSpace 𝕜] [opens_measurable_space 𝕜] [MeasurableSpace F] [borel_space F]\n    (f : 𝕜 → F) : Measurable (deriv f) := by simpa only [fderiv_deriv] using measurable_fderiv_apply_const 𝕜 f 1\n#align measurable_deriv measurable_deriv\n\n",
 "measurable_apply₂":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/-\nCopyright (c) 2020 Sébastien Gouëzel. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Sébastien Gouëzel, Yury Kudryashov\n-/\ntheorem measurable_apply₂ [MeasurableSpace E] [opens_measurable_space E] [SecondCountableTopology E]\n    [SecondCountableTopology («expr →L[ ] » E 𝕜 F)] [MeasurableSpace F] [borel_space F] :\n    Measurable fun p : «expr →L[ ] » E 𝕜 F × E => p.1 p.2 :=\n  is_bounded_bilinear_map_apply.continuous.measurable\n#align measurable_apply₂ measurable_apply₂\n\n",
 "le_of_mem_A":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem le_of_mem_A {r ε : exprℝ} {L : F} {x : exprℝ} (hx : x ∈ A f L r ε) {y z : exprℝ} (hy : y ∈ Icc x (x + r / 2))\n    (hz : z ∈ Icc x (x + r / 2)) : «expr‖ ‖» (f z - f y - «expr • » (z - y) L) ≤ ε * r :=\n  by\n  rcases hx with ⟨r', r'mem, hr'⟩\n  have A : x + r / 2 ≤ x + r' := by linarith [r'mem.1]\n  exact hr' _ ((Icc_subset_Icc le_rfl A) hy) _ ((Icc_subset_Icc le_rfl A) hz)\n#align le_of_mem_A le_of_mem_A\n\n",
 "is_open_B":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem is_open_B {K : Set («expr →L[ ] » E 𝕜 F)} {r s ε : exprℝ} : IsOpen (B f K r s ε) := by\n  simp [B, isOpen_unionᵢ, IsOpen.inter, is_open_A]\n#align is_open_B is_open_B\n\n",
 "is_open_A":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem is_open_A (L : «expr →L[ ] » E 𝕜 F) (r ε : exprℝ) : IsOpen (A f L r ε) :=\n  by\n  rw [Metric.isOpen_iff]\n  rintro x ⟨r', r'_mem, hr'⟩\n  obtain ⟨s, s_gt, s_lt⟩ : ∃ s : exprℝ, r / 2 < s ∧ s < r' := exists_between r'_mem.1\n  have : s ∈ Ioc (r / 2) r := ⟨s_gt, le_of_lt (s_lt.trans_le r'_mem.2)⟩\n  refine' ⟨r' - s, by linarith, fun x' hx' => ⟨s, this, _⟩⟩\n  have B : ball x' s ⊆ ball x r' := ball_subset (le_of_lt hx')\n  intro y hy z hz\n  exact hr' y (B hy) z (B hz)\n#align is_open_A is_open_A\n\n",
 "differentiable_set_subset_D":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- Easy inclusion: a differentiability point with derivative in `K` belongs to `D f K`. -/\ntheorem differentiable_set_subset_D :\n    { x | differentiable_within_at (exprℝ) f (Ici x) x ∧ deriv_within f (Ici x) x ∈ K } ⊆ D f K :=\n  by\n  intro x hx\n  rw [D, mem_Inter]\n  intro e\n  have : (0 : exprℝ) < (1 / 2) ^ e := pow_pos (by norm_num) _\n  rcases mem_A_of_differentiable this hx.1 with ⟨R, R_pos, hR⟩\n  obtain ⟨n, hn⟩ : ∃ n : ℕ, (1 / 2) ^ n < R := exists_pow_lt_of_lt_one R_pos (by norm_num : (1 : exprℝ) / 2 < 1)\n  simp only [mem_Union, mem_Inter, B, mem_inter_iff]\n  refine' ⟨n, fun p hp q hq => ⟨deriv_within f (Ici x) x, hx.2, ⟨_, _⟩⟩⟩ <;>\n    · refine' hR _ ⟨pow_pos (by norm_num) _, lt_of_le_of_lt _ hn⟩\n      exact pow_le_pow_of_le_one (by norm_num) (by norm_num) (by assumption)\n#align differentiable_set_subset_D differentiable_set_subset_D\n\n",
 "differentiable_set_eq_D":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem differentiable_set_eq_D (hK : IsComplete K) :\n    { x | differentiable_within_at (exprℝ) f (Ici x) x ∧ deriv_within f (Ici x) x ∈ K } = D f K :=\n  Subset.antisymm (differentiable_set_subset_D _) (D_subset_differentiable_set hK)\n#align differentiable_set_eq_D differentiable_set_eq_D\n\n",
 "ae_strongly_measurable_deriv_within_Ioi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem ae_strongly_measurable_deriv_within_Ioi [SecondCountableTopology F] (μ : measure (exprℝ)) :\n    ae_strongly_measurable (fun x => deriv_within f (Ioi x) x) μ :=\n  (strongly_measurable_deriv_within_Ioi f).ae_strongly_measurable\n#align ae_strongly_measurable_deriv_within_Ioi ae_strongly_measurable_deriv_within_Ioi\n\n",
 "ae_strongly_measurable_deriv_within_Ici":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem ae_strongly_measurable_deriv_within_Ici [SecondCountableTopology F] (μ : measure (exprℝ)) :\n    ae_strongly_measurable (fun x => deriv_within f (Ici x) x) μ :=\n  (strongly_measurable_deriv_within_Ici f).ae_strongly_measurable\n#align ae_strongly_measurable_deriv_within_Ici ae_strongly_measurable_deriv_within_Ici\n\n",
 "ae_strongly_measurable_deriv":
 "theorem ae_strongly_measurable_deriv [MeasurableSpace 𝕜] [opens_measurable_space 𝕜] [SecondCountableTopology F]\n    (f : 𝕜 → F) (μ : measure 𝕜) : ae_strongly_measurable (deriv f) μ :=\n  (strongly_measurable_deriv f).ae_strongly_measurable\n#align ae_strongly_measurable_deriv ae_strongly_measurable_deriv\n\n",
 "ae_measurable_deriv_within_Ioi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem ae_measurable_deriv_within_Ioi [MeasurableSpace F] [borel_space F] (μ : measure (exprℝ)) :\n    AEMeasurable (fun x => deriv_within f (Ioi x) x) μ :=\n  (measurable_deriv_within_Ioi f).ae_measurable\n#align ae_measurable_deriv_within_Ioi ae_measurable_deriv_within_Ioi\n\n",
 "ae_measurable_deriv_within_Ici":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem ae_measurable_deriv_within_Ici [MeasurableSpace F] [borel_space F] (μ : measure (exprℝ)) :\n    AEMeasurable (fun x => deriv_within f (Ici x) x) μ :=\n  (measurable_deriv_within_Ici f).ae_measurable\n#align ae_measurable_deriv_within_Ici ae_measurable_deriv_within_Ici\n\n",
 "ae_measurable_deriv":
 "theorem ae_measurable_deriv [MeasurableSpace 𝕜] [opens_measurable_space 𝕜] [MeasurableSpace F] [borel_space F]\n    (f : 𝕜 → F) (μ : measure 𝕜) : AEMeasurable (deriv f) μ :=\n  (measurable_deriv f).ae_measurable\n#align ae_measurable_deriv ae_measurable_deriv\n\n",
 "D_subset_differentiable_set":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- Harder inclusion: at a point in `D f K`, the function `f` has a derivative, in `K`. -/\ntheorem D_subset_differentiable_set {K : Set F} (hK : IsComplete K) :\n    D f K ⊆ { x | differentiable_within_at (exprℝ) f (Ici x) x ∧ deriv_within f (Ici x) x ∈ K } :=\n  by\n  have P : ∀ {n : ℕ}, (0 : exprℝ) < (1 / 2) ^ n := pow_pos (by norm_num)\n  intro x hx\n  have :\n    ∀ e : ℕ,\n      ∃ n : ℕ,\n        ∀ p q, n ≤ p → n ≤ q → ∃ L ∈ K, x ∈ A f L ((1 / 2) ^ p) ((1 / 2) ^ e) ∩ A f L ((1 / 2) ^ q) ((1 / 2) ^ e) :=\n    by\n    intro e\n    have := mem_Inter.1 hx e\n    rcases mem_Union.1 this with ⟨n, hn⟩\n    refine' ⟨n, fun p q hp hq => _⟩\n    simp only [mem_Inter, ge_iff_le] at hn\n    rcases mem_Union.1 (hn p hp q hq) with ⟨L, hL⟩\n    exact ⟨L, mem_Union.1 hL⟩\n  /- Recast the assumptions: for each `e`, there exist `n e` and linear maps `L e p q` in `K`\n    such that, for `p, q ≥ n e`, then `f` is well approximated by `L e p q` at scale `2 ^ (-p)` and\n    `2 ^ (-q)`, with an error `2 ^ (-e)`. -/\n  choose! n L hn using this\n  /- All the operators `L e p q` that show up are close to each other. To prove this, we argue\n      that `L e p q` is close to `L e p r` (where `r` is large enough), as both approximate `f` at\n      scale `2 ^(- p)`. And `L e p r` is close to `L e' p' r` as both approximate `f` at scale\n      `2 ^ (- r)`. And `L e' p' r` is close to `L e' p' q'` as both approximate `f` at scale\n      `2 ^ (- p')`. -/\n  have M :\n    ∀ e p q e' p' q',\n      n e ≤ p → n e ≤ q → n e' ≤ p' → n e' ≤ q' → e ≤ e' → «expr‖ ‖» (L e p q - L e' p' q') ≤ 12 * (1 / 2) ^ e :=\n    by\n    intro e p q e' p' q' hp hq hp' hq' he'\n    let r := max (n e) (n e')\n    have I : ((1 : exprℝ) / 2) ^ e' ≤ (1 / 2) ^ e := pow_le_pow_of_le_one (by norm_num) (by norm_num) he'\n    have J1 : «expr‖ ‖» (L e p q - L e p r) ≤ 4 * (1 / 2) ^ e :=\n      by\n      have I1 : x ∈ A f (L e p q) ((1 / 2) ^ p) ((1 / 2) ^ e) := (hn e p q hp hq).2.1\n      have I2 : x ∈ A f (L e p r) ((1 / 2) ^ p) ((1 / 2) ^ e) := (hn e p r hp (le_max_left _ _)).2.1\n      exact norm_sub_le_of_mem_A P _ I1 I2\n    have J2 : «expr‖ ‖» (L e p r - L e' p' r) ≤ 4 * (1 / 2) ^ e :=\n      by\n      have I1 : x ∈ A f (L e p r) ((1 / 2) ^ r) ((1 / 2) ^ e) := (hn e p r hp (le_max_left _ _)).2.2\n      have I2 : x ∈ A f (L e' p' r) ((1 / 2) ^ r) ((1 / 2) ^ e') := (hn e' p' r hp' (le_max_right _ _)).2.2\n      exact norm_sub_le_of_mem_A P _ I1 (A_mono _ _ I I2)\n    have J3 : «expr‖ ‖» (L e' p' r - L e' p' q') ≤ 4 * (1 / 2) ^ e :=\n      by\n      have I1 : x ∈ A f (L e' p' r) ((1 / 2) ^ p') ((1 / 2) ^ e') := (hn e' p' r hp' (le_max_right _ _)).2.1\n      have I2 : x ∈ A f (L e' p' q') ((1 / 2) ^ p') ((1 / 2) ^ e') := (hn e' p' q' hp' hq').2.1\n      exact norm_sub_le_of_mem_A P _ (A_mono _ _ I I1) (A_mono _ _ I I2)\n    calc\n      «expr‖ ‖» (L e p q - L e' p' q') =\n          «expr‖ ‖» (L e p q - L e p r + (L e p r - L e' p' r) + (L e' p' r - L e' p' q')) :=\n        by\n        congr 1\n        abel\n      _ ≤ «expr‖ ‖» (L e p q - L e p r) + «expr‖ ‖» (L e p r - L e' p' r) + «expr‖ ‖» (L e' p' r - L e' p' q') :=\n        (le_trans (norm_add_le _ _) (add_le_add_right (norm_add_le _ _) _))\n      _ ≤ 4 * (1 / 2) ^ e + 4 * (1 / 2) ^ e + 4 * (1 / 2) ^ e := by apply_rules [add_le_add]\n      _ = 12 * (1 / 2) ^ e := by ring\n      \n  /- For definiteness, use `L0 e = L e (n e) (n e)`, to have a single sequence. We claim that this\n    is a Cauchy sequence. -/\n  let L0 : ℕ → F := fun e => L e (n e) (n e)\n  have : CauchySeq L0 := by\n    rw [Metric.cauchySeq_iff']\n    intro ε εpos\n    obtain ⟨e, he⟩ : ∃ e : ℕ, (1 / 2) ^ e < ε / 12 := exists_pow_lt_of_lt_one (div_pos εpos (by norm_num)) (by norm_num)\n    refine' ⟨e, fun e' he' => _⟩\n    rw [dist_comm, dist_eq_norm]\n    calc\n      «expr‖ ‖» (L0 e - L0 e') ≤ 12 * (1 / 2) ^ e := M _ _ _ _ _ _ le_rfl le_rfl le_rfl le_rfl he'\n      _ < 12 * (ε / 12) := (mul_lt_mul' le_rfl he (le_of_lt P) (by norm_num))\n      _ = ε := by\n        field_simp [(by norm_num : (12 : exprℝ) ≠ 0)]\n        ring\n      \n  -- As it is Cauchy, the sequence `L0` converges, to a limit `f'` in `K`.\n  obtain ⟨f', f'K, hf'⟩ : ∃ f' ∈ K, tendsto L0 at_top ((nhds) f') :=\n    cauchySeq_tendsto_of_isComplete hK (fun e => (hn e (n e) (n e) le_rfl le_rfl).1) this\n  have Lf' : ∀ e p, n e ≤ p → «expr‖ ‖» (L e (n e) p - f') ≤ 12 * (1 / 2) ^ e :=\n    by\n    intro e p hp\n    apply le_of_tendsto (tendsto_const_nhds.sub hf').norm\n    rw [eventually_at_top]\n    exact ⟨e, fun e' he' => M _ _ _ _ _ _ le_rfl hp le_rfl le_rfl he'⟩\n  -- Let us show that `f` has right derivative `f'` at `x`.\n  have : has_deriv_within_at f f' (Ici x) x :=\n    by\n    simp only [has_deriv_within_at_iff_is_o, is_o_iff]\n    /- to get an approximation with a precision `ε`, we will replace `f` with `L e (n e) m` for\n        some large enough `e` (yielding a small error by uniform approximation). As one can vary `m`,\n        this makes it possible to cover all scales, and thus to obtain a good linear approximation in\n        the whole interval of length `(1/2)^(n e)`. -/\n    intro ε εpos\n    obtain ⟨e, he⟩ : ∃ e : ℕ, (1 / 2) ^ e < ε / 16 := exists_pow_lt_of_lt_one (div_pos εpos (by norm_num)) (by norm_num)\n    have xmem : x ∈ Ico x (x + (1 / 2) ^ (n e + 1)) := by\n      simp only [one_div, left_mem_Ico, lt_add_iff_pos_right, inv_pos, pow_pos, zero_lt_bit0, zero_lt_one]\n    filter_upwards [Icc_mem_nhdsWithin_Ici xmem]with y hy\n    -- We need to show that `f y - f x - f' (y - x)` is small. For this, we will work at scale\n    -- `k` where `k` is chosen with `‖y - x‖ ∼ 2 ^ (-k)`.\n    rcases eq_or_lt_of_le hy.1 with (rfl | xy)\n    · simp only [sub_self, zero_smul, norm_zero, MulZeroClass.mul_zero]\n    have yzero : 0 < y - x := sub_pos.2 xy\n    have y_le : y - x ≤ (1 / 2) ^ (n e + 1) := by linarith [hy.2]\n    have yone : y - x ≤ 1 := le_trans y_le (pow_le_one _ (by norm_num) (by norm_num))\n    -- define the scale `k`.\n    obtain ⟨k, hk, h'k⟩ : ∃ k : ℕ, (1 / 2) ^ (k + 1) < y - x ∧ y - x ≤ (1 / 2) ^ k :=\n      exists_nat_pow_near_of_lt_one yzero yone (by norm_num : (0 : exprℝ) < 1 / 2) (by norm_num : (1 : exprℝ) / 2 < 1)\n    -- the scale is large enough (as `y - x` is small enough)\n    have k_gt : n e < k :=\n      by\n      have : ((1 : exprℝ) / 2) ^ (k + 1) < (1 / 2) ^ (n e + 1) := lt_of_lt_of_le hk y_le\n      rw [pow_lt_pow_iff_of_lt_one (by norm_num : (0 : exprℝ) < 1 / 2) (by norm_num)] at this\n      linarith\n    set m := k - 1 with hl\n    have m_ge : n e ≤ m := Nat.le_pred_of_lt k_gt\n    have km : k = m + 1 := (nat.succ_pred_eq_of_pos (lt_of_le_of_lt (zero_le _) k_gt)).symm\n    rw [km] at hk h'k\n    -- `f` is well approximated by `L e (n e) k` at the relevant scale\n    -- (in fact, we use `m = k - 1` instead of `k` because of the precise definition of `A`).\n    have J : «expr‖ ‖» (f y - f x - «expr • » (y - x) (L e (n e) m)) ≤ 4 * (1 / 2) ^ e * «expr‖ ‖» (y - x) :=\n      calc\n        «expr‖ ‖» (f y - f x - «expr • » (y - x) (L e (n e) m)) ≤ (1 / 2) ^ e * (1 / 2) ^ m :=\n          by\n          apply le_of_mem_A (hn e (n e) m le_rfl m_ge).2.2\n          · simp only [one_div, inv_pow, left_mem_Icc, le_add_iff_nonneg_right]\n            exact div_nonneg (inv_nonneg.2 (pow_nonneg zero_le_two _)) zero_le_two\n          · simp only [pow_add, tsub_le_iff_left] at h'k\n            simpa only [hy.1, mem_Icc, true_and_iff, one_div, pow_one] using h'k\n        _ = 4 * (1 / 2) ^ e * (1 / 2) ^ (m + 2) := by\n          field_simp\n          ring\n        _ ≤ 4 * (1 / 2) ^ e * (y - x) :=\n          (mul_le_mul_of_nonneg_left (le_of_lt hk) (mul_nonneg (by norm_num) (le_of_lt P)))\n        _ = 4 * (1 / 2) ^ e * «expr‖ ‖» (y - x) := by rw [Real.norm_of_nonneg yzero.le]\n        \n    calc\n      «expr‖ ‖» (f y - f x - «expr • » (y - x) f') =\n          «expr‖ ‖» (f y - f x - «expr • » (y - x) (L e (n e) m) + «expr • » (y - x) (L e (n e) m - f')) :=\n        by simp only [smul_sub, sub_add_sub_cancel]\n      _ ≤ 4 * (1 / 2) ^ e * «expr‖ ‖» (y - x) + «expr‖ ‖» (y - x) * (12 * (1 / 2) ^ e) :=\n        (norm_add_le_of_le J\n          (by\n            rw [norm_smul]\n            exact mul_le_mul_of_nonneg_left (Lf' _ _ m_ge) (norm_nonneg _)))\n      _ = 16 * «expr‖ ‖» (y - x) * (1 / 2) ^ e := by ring\n      _ ≤ 16 * «expr‖ ‖» (y - x) * (ε / 16) :=\n        (mul_le_mul_of_nonneg_left he.le (mul_nonneg (by norm_num) (norm_nonneg _)))\n      _ = ε * «expr‖ ‖» (y - x) := by ring\n      \n  rw [← this.deriv_within (unique_diff_on_Ici x x le_rfl)] at f'K\n  exact ⟨this.differentiable_within_at, f'K⟩\n#align D_subset_differentiable_set D_subset_differentiable_set\n\n",
 "B_mem_nhds_within_Ioi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.gt -/\ntheorem B_mem_nhds_within_Ioi {K : Set F} {r s ε x : exprℝ} (hx : x ∈ B f K r s ε) : B f K r s ε ∈ nhds_within.gt x :=\n  by\n  obtain ⟨L, LK, hL₁, hL₂⟩ : ∃ L : F, L ∈ K ∧ x ∈ A f L r ε ∧ x ∈ A f L s ε := by\n    simpa only [B, mem_Union, mem_inter_iff, exists_prop] using hx\n  filter_upwards [A_mem_nhds_within_Ioi hL₁, A_mem_nhds_within_Ioi hL₂]with y hy₁ hy₂\n  simp only [B, mem_Union, mem_inter_iff, exists_prop]\n  exact ⟨L, LK, hy₁, hy₂⟩\n#align B_mem_nhds_within_Ioi B_mem_nhds_within_Ioi\n\n",
 "A_mono":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem A_mono (L : F) (r : exprℝ) {ε δ : exprℝ} (h : ε ≤ δ) : A f L r ε ⊆ A f L r δ :=\n  by\n  rintro x ⟨r', r'r, hr'⟩\n  refine' ⟨r', r'r, fun y hy z hz => (hr' y hy z hz).trans (mul_le_mul_of_nonneg_right h _)⟩\n  linarith [hy.1, hy.2, r'r.2]\n#align A_mono A_mono\n\n",
 "A_mem_nhds_within_Ioi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.gt -/\ntheorem A_mem_nhds_within_Ioi {L : F} {r ε x : exprℝ} (hx : x ∈ A f L r ε) : A f L r ε ∈ nhds_within.gt x :=\n  by\n  rcases hx with ⟨r', rr', hr'⟩\n  rw [mem_nhdsWithin_Ioi_iff_exists_Ioo_subset]\n  obtain ⟨s, s_gt, s_lt⟩ : ∃ s : exprℝ, r / 2 < s ∧ s < r' := exists_between rr'.1\n  have : s ∈ Ioc (r / 2) r := ⟨s_gt, le_of_lt (s_lt.trans_le rr'.2)⟩\n  refine'\n    ⟨x + r' - s, by\n      simp only [mem_Ioi]\n      linarith, fun x' hx' => ⟨s, this, _⟩⟩\n  have A : Icc x' (x' + s) ⊆ Icc x (x + r') :=\n    by\n    apply Icc_subset_Icc hx'.1.le\n    linarith [hx'.2]\n  intro y hy z hz\n  exact hr' y (A hy) z (A hz)\n#align A_mem_nhds_within_Ioi A_mem_nhds_within_Ioi\n\n"}