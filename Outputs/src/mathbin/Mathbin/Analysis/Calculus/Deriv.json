{"zpow":
 "theorem differentiable.zpow (hf : differentiable ğ•œ f) (h : (âˆ€ x, f x â‰  0) âˆ¨ 0 â‰¤ m) :\n    differentiable ğ•œ fun x => f x ^ m := fun x => (hf x).zpow <| h.imp_left fun h => h x\n#align differentiable.zpow differentiable.zpow\n\n",
 "unique":
 "theorem has_deriv_at.unique (hâ‚€ : has_deriv_at f fâ‚€' x) (hâ‚ : has_deriv_at f fâ‚' x) : fâ‚€' = fâ‚' :=\n  smulRight_one_eq_iff.mp <| hâ‚€.has_fderiv_at.unique hâ‚\n#align has_deriv_at.unique has_deriv_at.unique\n\n",
 "union":
 "theorem has_deriv_within_at.union (hs : has_deriv_within_at f f' s x) (ht : has_deriv_within_at f f' t x) :\n    has_deriv_within_at f f' (s âˆª t) x :=\n  hs.has_fderiv_within_at.union ht.has_fderiv_within_at\n#align has_deriv_within_at.union has_deriv_within_at.union\n\n",
 "tendsto_punctured_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.ne -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.ne -/\ntheorem has_deriv_at.tendsto_punctured_nhds (h : has_deriv_at f f' x) (hf' : f' â‰  0) :\n    Tendsto f (nhds_within.ne x) (nhds_within.ne (f x)) :=\n  tendsto_nhdsWithin_of_tendsto_nhds_of_eventually_within _ h.continuous_at.continuous_within_at (h.eventually_ne hf')\n#align has_deriv_at.tendsto_punctured_nhds has_deriv_at.tendsto_punctured_nhds\n\n",
 "tendsto_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem has_deriv_at_filter.tendsto_nhds (hL : L â‰¤ (nhds) x) (h : has_deriv_at_filter f f' x L) :\n    Tendsto f L ((nhds) (f x)) :=\n  h.tendsto_nhds hL\n#align has_deriv_at_filter.tendsto_nhds has_deriv_at_filter.tendsto_nhds\n\n",
 "support_deriv_subset":
 "theorem support_deriv_subset : support (deriv f) âŠ† tsupport f :=\n  by\n  intro x\n  rw [â† not_imp_not]\n  intro h2x\n  rw [not_mem_tsupport_iff_eventuallyEq] at h2x\n  exact nmem_support.mpr (h2x.deriv_eq.trans (deriv_const x 0))\n#align support_deriv_subset support_deriv_subset\n\n",
 "sum":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem has_deriv_at.sum (h : âˆ€ i âˆˆ u, has_deriv_at (A i) (A' i) x) :\n    has_deriv_at\n      (fun y =>\n        finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" u (A i y))\n      (finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" u (A' i)) x :=\n  has_deriv_at_filter.sum h\n#align has_deriv_at.sum has_deriv_at.sum\n\n",
 "sub_const":
 "theorem has_deriv_at.sub_const (hf : has_deriv_at f f' x) (c : F) : has_deriv_at (fun x => f x - c) f' x :=\n  hf.sub_const c\n#align has_deriv_at.sub_const has_deriv_at.sub_const\n\n",
 "sub":
 "theorem has_strict_deriv_at.sub (hf : has_strict_deriv_at f f' x) (hg : has_strict_deriv_at g g' x) :\n    has_strict_deriv_at (fun x => f x - g x) (f' - g') x := by simpa only [sub_eq_add_neg] using hf.add hg.neg\n#align has_strict_deriv_at.sub has_strict_deriv_at.sub\n\n",
 "smul_const":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\ntheorem has_deriv_at.smul_const (hc : has_deriv_at c c' x) (f : F) :\n    has_deriv_at (fun y => Â«expr â€¢ Â» (c y) f) (Â«expr â€¢ Â» c' f) x :=\n  by\n  rw [â† has_deriv_within_at_univ] at *\n  exact hc.smul_const f\n#align has_deriv_at.smul_const has_deriv_at.smul_const\n\n",
 "smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\ntheorem has_strict_deriv_at.smul (hc : has_strict_deriv_at c c' x) (hf : has_strict_deriv_at f f' x) :\n    has_strict_deriv_at (fun y => Â«expr â€¢ Â» (c y) (f y)) (Â«expr â€¢ Â» (c x) f' + Â«expr â€¢ Â» c' (f x)) x := by\n  simpa using (hc.smul hf).has_strict_deriv_at\n#align has_strict_deriv_at.smul has_strict_deriv_at.smul\n\n",
 "scomp_has_deriv_within_at":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\ntheorem has_deriv_at.scomp_has_deriv_within_at (hg : has_deriv_at gâ‚ gâ‚' (h x)) (hh : has_deriv_within_at h h' s x) :\n    has_deriv_within_at (gâ‚ âˆ˜ h) (Â«expr â€¢ Â» h' gâ‚') s x :=\n  has_deriv_within_at.scomp x hg.has_deriv_within_at hh (mapsTo_univ _ _)\n#align has_deriv_at.scomp_has_deriv_within_at has_deriv_at.scomp_has_deriv_within_at\n\n",
 "scomp_has_deriv_at":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\ntheorem has_deriv_within_at.scomp_has_deriv_at (hg : has_deriv_within_at gâ‚ gâ‚' s' (h x)) (hh : has_deriv_at h h' x)\n    (hs : âˆ€ x, h x âˆˆ s') : has_deriv_at (gâ‚ âˆ˜ h) (Â«expr â€¢ Â» h' gâ‚') x :=\n  hg.scomp x hh <| tendsto_inf.2 âŸ¨hh.continuous_at, tendsto_principal.2 <| eventually_of_forall hsâŸ©\n#align has_deriv_within_at.scomp_has_deriv_at has_deriv_within_at.scomp_has_deriv_at\n\n",
 "scomp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\ntheorem deriv.scomp (hg : differentiable_at ğ•œ' gâ‚ (h x)) (hh : differentiable_at ğ•œ h x) :\n    deriv (gâ‚ âˆ˜ h) x = Â«expr â€¢ Â» (deriv h x) (deriv gâ‚ (h x)) :=\n  (has_deriv_at.scomp x hg.has_deriv_at hh.has_deriv_at).deriv\n#align deriv.scomp deriv.scomp\n\n",
 "prod":
 "theorem has_strict_deriv_at.prod (hfâ‚ : has_strict_deriv_at fâ‚ fâ‚' x) (hfâ‚‚ : has_strict_deriv_at fâ‚‚ fâ‚‚' x) :\n    has_strict_deriv_at (fun x => (fâ‚ x, fâ‚‚ x)) (fâ‚', fâ‚‚') x :=\n  hfâ‚.prod hfâ‚‚\n#align has_strict_deriv_at.prod has_strict_deriv_at.prod\n\n",
 "pow":
 "theorem has_deriv_at.pow (hc : has_deriv_at c c' x) :\n    has_deriv_at (fun y => c y ^ n) ((n : ğ•œ) * c x ^ (n - 1) * c') x :=\n  by\n  rw [â† has_deriv_within_at_univ] at *\n  exact hc.pow n\n#align has_deriv_at.pow has_deriv_at.pow\n\n",
 "of_local_left_inverse":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- If `f (g y) = y` for `y` in some neighborhood of `a`, `g` is continuous at `a`, and `f` has an\ninvertible derivative `f'` at `g a`, then `g` has the derivative `f'â»Â¹` at `a`.\n\nThis is one of the easy parts of the inverse function theorem: it assumes that we already have\nan inverse function. -/\ntheorem has_deriv_at.of_local_left_inverse {f g : ğ•œ â†’ ğ•œ} {f' a : ğ•œ} (hg : ContinuousAt g a)\n    (hf : has_deriv_at f f' (g a)) (hf' : f' â‰  0)\n    (hfg :\n      Â«exprâˆ€á¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â»\" ((nhds) a)\n        (f (g y) = y)) :\n    has_deriv_at g f'â»Â¹ a :=\n  (hf.has_fderiv_at_equiv hf').of_local_left_inverse hg hfg\n#align has_deriv_at.of_local_left_inverse has_deriv_at.of_local_left_inverse\n\n",
 "not_differentiable_within_at_of_local_left_inverse_has_deriv_within_at_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr =á¶ [ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\ntheorem not_differentiable_within_at_of_local_left_inverse_has_deriv_within_at_zero {f g : ğ•œ â†’ ğ•œ} {a : ğ•œ} {s t : Set ğ•œ}\n    (ha : a âˆˆ s) (hsu : unique_diff_within_at ğ•œ s a) (hf : has_deriv_within_at f 0 t (g a)) (hst : MapsTo g s t)\n    (hfg : Â«expr =á¶ [ ] Â» (f âˆ˜ g) (nhds_within s a) id) : Â¬differentiable_within_at ğ•œ g s a :=\n  by\n  intro hg\n  have := (hf.comp a hg.has_deriv_within_at hst).congr_of_eventually_eq_of_mem hfg.symm ha\n  simpa using hsu.eq_deriv _ this (has_deriv_within_at_id _ _)\n#align not_differentiable_within_at_of_local_left_inverse_has_deriv_within_at_zero not_differentiable_within_at_of_local_left_inverse_has_deriv_within_at_zero\n\n",
 "not_differentiable_at_of_local_left_inverse_has_deriv_at_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr =á¶ [ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem not_differentiable_at_of_local_left_inverse_has_deriv_at_zero {f g : ğ•œ â†’ ğ•œ} {a : ğ•œ}\n    (hf : has_deriv_at f 0 (g a)) (hfg : Â«expr =á¶ [ ] Â» (f âˆ˜ g) ((nhds) a) id) : Â¬differentiable_at ğ•œ g a :=\n  by\n  intro hg\n  have := (hf.comp a hg.has_deriv_at).congr_of_eventually_eq hfg.symm\n  simpa using this.unique (has_deriv_at_id a)\n#align not_differentiable_at_of_local_left_inverse_has_deriv_at_zero not_differentiable_at_of_local_left_inverse_has_deriv_at_zero\n\n",
 "nhds_within":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\ntheorem has_deriv_within_at.nhds_within (h : has_deriv_within_at f f' s x) (ht : s âˆˆ nhds_within t x) :\n    has_deriv_within_at f f' t x :=\n  (has_deriv_within_at_inter' ht).1 (h.mono (inter_subset_right _ _))\n#align has_deriv_within_at.nhds_within has_deriv_within_at.nhds_within\n\n",
 "neg'":
 "@[simp]\ntheorem deriv.neg' : (deriv fun y => -f y) = fun x => -deriv f x :=\n  funext fun x => deriv.neg\n#align deriv.neg' deriv.neg'\n\n",
 "neg":
 "theorem deriv.neg : deriv (fun y => -f y) x = -deriv f x := by\n  simp only [deriv, fderiv_neg, ContinuousLinearMap.neg_apply]\n#align deriv.neg deriv.neg\n\n",
 "mul_const":
 "theorem has_strict_deriv_at.mul_const (hc : has_strict_deriv_at c c' x) (d : ğ”¸) :\n    has_strict_deriv_at (fun y => c y * d) (c' * d) x :=\n  by\n  convert hc.mul (has_strict_deriv_at_const x d)\n  rw [MulZeroClass.mul_zero, add_zero]\n#align has_strict_deriv_at.mul_const has_strict_deriv_at.mul_const\n\n",
 "mul":
 "theorem has_strict_deriv_at.mul (hc : has_strict_deriv_at c c' x) (hd : has_strict_deriv_at d d' x) :\n    has_strict_deriv_at (fun y => c y * d y) (c' * d x + c x * d') x :=\n  by\n  have := (has_strict_fderiv_at.mul' hc hd).has_strict_deriv_at\n  rwa [ContinuousLinearMap.add_apply, ContinuousLinearMap.smul_apply, ContinuousLinearMap.smulRight_apply,\n    ContinuousLinearMap.smulRight_apply, ContinuousLinearMap.smulRight_apply, ContinuousLinearMap.one_apply, one_smul,\n    one_smul, add_comm] at this\n#align has_strict_deriv_at.mul has_strict_deriv_at.mul\n\n",
 "mono":
 "theorem has_deriv_within_at.mono (h : has_deriv_within_at f f' t x) (hst : s âŠ† t) : has_deriv_within_at f f' s x :=\n  has_fderiv_within_at.mono h hst\n#align has_deriv_within_at.mono has_deriv_within_at.mono\n\n",
 "limsup_slope_norm_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/-- If `f` has derivative `f'` within `s` at `x`, then for any `r > â€–f'â€–` the ratio\n`(â€–f zâ€– - â€–f xâ€–) / â€–z - xâ€–` is less than `r` in some neighborhood of `x` within `s`.\nIn other words, the limit superior of this ratio as `z` tends to `x` along `s`\nis less than or equal to `â€–f'â€–`.\n\nThis lemma is a weaker version of `has_deriv_within_at.limsup_norm_slope_le`\nwhere `â€–f zâ€– - â€–f xâ€–` is replaced by `â€–f z - f xâ€–`. -/\ntheorem has_deriv_within_at.limsup_slope_norm_le (hf : has_deriv_within_at f f' s x) (hr : Â«exprâ€– â€–Â» f' < r) :\n    Â«exprâˆ€á¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â»\"\n      (nhds_within s x) ((Â«exprâ€– â€–Â» (z - x))â»Â¹ * (Â«exprâ€– â€–Â» (f z) - Â«exprâ€– â€–Â» (f x)) < r) :=\n  by\n  apply (hf.limsup_norm_slope_le hr).mono\n  intro z hz\n  refine' lt_of_le_of_lt (mul_le_mul_of_nonneg_left (norm_sub_norm_le _ _) _) hz\n  exact inv_nonneg.2 (norm_nonneg _)\n#align has_deriv_within_at.limsup_slope_norm_le has_deriv_within_at.limsup_slope_norm_le\n\n",
 "limsup_slope_le'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\ntheorem has_deriv_within_at.limsup_slope_le' (hf : has_deriv_within_at f f' s x) (hs : x âˆ‰ s) (hr : f' < r) :\n    Â«exprâˆ€á¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â»\"\n      (nhds_within s x) (slope f x z < r) :=\n  (has_deriv_within_at_iff_tendsto_slope' hs).1 hf (IsOpen.mem_nhds isOpen_Iio hr)\n#align has_deriv_within_at.limsup_slope_le' has_deriv_within_at.limsup_slope_le'\n\n",
 "limsup_slope_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\ntheorem has_deriv_within_at.limsup_slope_le (hf : has_deriv_within_at f f' s x) (hr : f' < r) :\n    Â«exprâˆ€á¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â»\"\n      (nhds_within (s \\ {x}) x) (slope f x z < r) :=\n  has_deriv_within_at_iff_tendsto_slope.1 hf (IsOpen.mem_nhds isOpen_Iio hr)\n#align has_deriv_within_at.limsup_slope_le has_deriv_within_at.limsup_slope_le\n\n",
 "limsup_norm_slope_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/-- If `f` has derivative `f'` within `s` at `x`, then for any `r > â€–f'â€–` the ratio\n`â€–f z - f xâ€– / â€–z - xâ€–` is less than `r` in some neighborhood of `x` within `s`.\nIn other words, the limit superior of this ratio as `z` tends to `x` along `s`\nis less than or equal to `â€–f'â€–`. -/\ntheorem has_deriv_within_at.limsup_norm_slope_le (hf : has_deriv_within_at f f' s x) (hr : Â«exprâ€– â€–Â» f' < r) :\n    Â«exprâˆ€á¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â»\"\n      (nhds_within s x) ((Â«exprâ€– â€–Â» (z - x))â»Â¹ * Â«exprâ€– â€–Â» (f z - f x) < r) :=\n  by\n  have hrâ‚€ : 0 < r := lt_of_le_of_lt (norm_nonneg f') hr\n  have A :\n    Â«exprâˆ€á¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â»\"\n      (nhds_within (s \\ {x}) x) (Â«exprâ€– â€–Â» (Â«expr â€¢ Â» (z - x)â»Â¹ (f z - f x)) âˆˆ Iio r) :=\n    (has_deriv_within_at_iff_tendsto_slope.1 hf).norm (IsOpen.mem_nhds isOpen_Iio hr)\n  have B :\n    Â«exprâˆ€á¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â»\"\n      (nhds_within {x} x) (Â«exprâ€– â€–Â» (Â«expr â€¢ Â» (z - x)â»Â¹ (f z - f x)) âˆˆ Iio r) :=\n    mem_of_superset self_mem_nhdsWithin (singleton_subset_iff.2 <| by simp [hrâ‚€])\n  have C := mem_sup.2 âŸ¨A, BâŸ©\n  rw [â† nhdsWithin_union, diff_union_self, nhdsWithin_union, mem_sup] at C\n  filter_upwards [C.1]\n  simp only [norm_smul, mem_Iio, norm_inv]\n  exact fun _ => id\n#align has_deriv_within_at.limsup_norm_slope_le has_deriv_within_at.limsup_norm_slope_le\n\n",
 "liminf_right_slope_norm_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆƒá¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆƒá¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.gt -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/-- If `f` has derivative `f'` within `(x, +âˆ)` at `x`, then for any `r > â€–f'â€–` the ratio\n`(â€–f zâ€– - â€–f xâ€–) / (z - x)` is frequently less than `r` as `z â†’ x+0`.\nIn other words, the limit inferior of this ratio as `z` tends to `x+0`\nis less than or equal to `â€–f'â€–`.\n\nSee also\n\n* `has_deriv_within_at.limsup_norm_slope_le` for a stronger version using\n  limit superior and any set `s`;\n* `has_deriv_within_at.liminf_right_norm_slope_le` for a stronger version using\n  `â€–f z - f xâ€–` instead of `â€–f zâ€– - â€–f xâ€–`. -/\ntheorem has_deriv_within_at.liminf_right_slope_norm_le (hf : has_deriv_within_at f f' (Ici x) x)\n    (hr : Â«exprâ€– â€–Â» f' < r) :\n    Â«exprâˆƒá¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆƒá¶  in , Â»\"\n      (nhds_within.gt x) ((z - x)â»Â¹ * (Â«exprâ€– â€–Â» (f z) - Â«exprâ€– â€–Â» (f x)) < r) :=\n  by\n  have := (hf.Ioi_of_Ici.limsup_slope_norm_le hr).frequently\n  refine' this.mp (eventually.mono self_mem_nhdsWithin _)\n  intro z hxz hz\n  rwa [Real.norm_eq_abs, abs_of_pos (sub_pos_of_lt hxz)] at hz\n#align has_deriv_within_at.liminf_right_slope_norm_le has_deriv_within_at.liminf_right_slope_norm_le\n\n",
 "liminf_right_slope_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆƒá¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆƒá¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.gt -/\ntheorem has_deriv_within_at.liminf_right_slope_le (hf : has_deriv_within_at f f' (Ici x) x) (hr : f' < r) :\n    Â«exprâˆƒá¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆƒá¶  in , Â»\"\n      (nhds_within.gt x) (slope f x z < r) :=\n  (hf.Ioi_of_Ici.limsup_slope_le' (lt_irrefl x) hr).frequently\n#align has_deriv_within_at.liminf_right_slope_le has_deriv_within_at.liminf_right_slope_le\n\n",
 "liminf_right_norm_slope_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆƒá¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆƒá¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.gt -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/-- If `f` has derivative `f'` within `(x, +âˆ)` at `x`, then for any `r > â€–f'â€–` the ratio\n`â€–f z - f xâ€– / â€–z - xâ€–` is frequently less than `r` as `z â†’ x+0`.\nIn other words, the limit inferior of this ratio as `z` tends to `x+0`\nis less than or equal to `â€–f'â€–`. See also `has_deriv_within_at.limsup_norm_slope_le`\nfor a stronger version using limit superior and any set `s`. -/\ntheorem has_deriv_within_at.liminf_right_norm_slope_le (hf : has_deriv_within_at f f' (Ici x) x)\n    (hr : Â«exprâ€– â€–Â» f' < r) :\n    Â«exprâˆƒá¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆƒá¶  in , Â»\"\n      (nhds_within.gt x) ((Â«exprâ€– â€–Â» (z - x))â»Â¹ * Â«exprâ€– â€–Â» (f z - f x) < r) :=\n  (hf.Ioi_of_Ici.limsup_norm_slope_le hr).frequently\n#align has_deriv_within_at.liminf_right_norm_slope_le has_deriv_within_at.liminf_right_norm_slope_le\n\n",
 "iterate":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr ^[ ]Â» -/\nprotected theorem has_strict_deriv_at.iterate {f : ğ•œ â†’ ğ•œ} {f' : ğ•œ} (hf : has_strict_deriv_at f f' x) (hx : f x = x)\n    (n : â„•) : has_strict_deriv_at (Â«expr ^[ ]Â» f n) (f' ^ n) x :=\n  by\n  have := hf.iterate hx n\n  rwa [ContinuousLinearMap.smulRight_one_pow] at this\n#align has_strict_deriv_at.iterate has_strict_deriv_at.iterate\n\n",
 "iter_deriv_zpow'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr ^[ ]Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n@[simp]\ntheorem iter_deriv_zpow' (m : â„¤) (k : â„•) :\n    ((Â«expr ^[ ]Â» deriv k) fun x : ğ•œ => x ^ m) = fun x =>\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" (Finset.range k)\n          (m - i) *\n        x ^ (m - k) :=\n  by\n  induction' k with k ihk\n  Â· simp only [one_mul, Int.ofNat_zero, id, sub_zero, Finset.prod_range_zero, Function.iterate_zero]\n  Â·\n    simp only [Function.iterate_succ_apply', ihk, deriv_const_mul_field', deriv_zpow', Finset.prod_range_succ,\n      Int.ofNat_succ, â† sub_sub, Int.cast_sub, Int.cast_ofNat, mul_assoc]\n#align iter_deriv_zpow' iter_deriv_zpow'\n\n",
 "iter_deriv_zpow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr ^[ ]Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\ntheorem iter_deriv_zpow (m : â„¤) (x : ğ•œ) (k : â„•) :\n    (Â«expr ^[ ]Â» deriv k) (fun y => y ^ m) x =\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" (Finset.range k)\n          (m - i) *\n        x ^ (m - k) :=\n  congr_fun (iter_deriv_zpow' m k) x\n#align iter_deriv_zpow iter_deriv_zpow\n\n",
 "iter_deriv_pow'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr ^[ ]Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n@[simp]\ntheorem iter_deriv_pow' (n k : â„•) :\n    ((Â«expr ^[ ]Â» deriv k) fun x : ğ•œ => x ^ n) = fun x =>\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" (Finset.range k)\n          (n - i) *\n        x ^ (n - k) :=\n  funext fun x => iter_deriv_pow n x k\n#align iter_deriv_pow' iter_deriv_pow'\n\n",
 "iter_deriv_pow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr ^[ ]Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\ntheorem iter_deriv_pow (n : â„•) (x : ğ•œ) (k : â„•) :\n    (Â«expr ^[ ]Â» deriv k) (fun x : ğ•œ => x ^ n) x =\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" (Finset.range k)\n          (n - i) *\n        x ^ (n - k) :=\n  by\n  simp only [â† zpow_ofNat, iter_deriv_zpow, Int.cast_ofNat]\n  cases' le_or_lt k n with hkn hnk\n  Â· rw [Int.ofNat_sub hkn]\n  Â· have :\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" (Finset.range k)\n          (n - i : ğ•œ) =\n        0 :=\n      Finset.prod_eq_zero (Finset.mem_range.2 hnk) (sub_self _)\n    simp only [this, MulZeroClass.zero_mul]\n#align iter_deriv_pow iter_deriv_pow\n\n",
 "iter_deriv_inv'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr ^[ ]Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n@[simp]\ntheorem iter_deriv_inv' (k : â„•) :\n    (Â«expr ^[ ]Â» deriv k) has_inv.inv = fun x : ğ•œ =>\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" (Finset.range k)\n          (-1 - i) *\n        x ^ (-1 - k : â„¤) :=\n  funext (iter_deriv_inv k)\n#align iter_deriv_inv' iter_deriv_inv'\n\n",
 "iter_deriv_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr ^[ ]Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\ntheorem iter_deriv_inv (k : â„•) (x : ğ•œ) :\n    (Â«expr ^[ ]Â» deriv k) has_inv.inv x =\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" (Finset.range k)\n          (-1 - i) *\n        x ^ (-1 - k : â„¤) :=\n  by simpa only [zpow_neg_one, Int.cast_neg, Int.cast_one] using iter_deriv_zpow (-1) x k\n#align iter_deriv_inv iter_deriv_inv\n\n",
 "is_O_sub_rev":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–â‚ŠÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr =O[ ] Â» -/\ntheorem has_deriv_at_filter.is_O_sub_rev (hf : has_deriv_at_filter f f' x L) (hf' : f' â‰  0) :\n    Â«expr =O[ ] Â» (fun x' => x' - x) L fun x' => f x' - f x :=\n  suffices AntilipschitzWith (Â«exprâ€– â€–â‚ŠÂ» f')â»Â¹ (smulRight (1 : Â«expr â†’L[ ] Â» ğ•œ ğ•œ ğ•œ) f') from hf.is_O_sub_rev this\n  AddMonoidHomClass.antilipschitz_of_bound (smulRight (1 : Â«expr â†’L[ ] Â» ğ•œ ğ•œ ğ•œ) f') fun x => by\n    simp [norm_smul, â† div_eq_inv_mul, mul_div_cancel _ (mt norm_eq_zero.1 hf')]\n#align has_deriv_at_filter.is_O_sub_rev has_deriv_at_filter.is_O_sub_rev\n\n",
 "is_O_sub":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr =O[ ] Â» -/\ntheorem has_deriv_at_filter.is_O_sub (h : has_deriv_at_filter f f' x L) :\n    Â«expr =O[ ] Â» (fun x' => f x' - f x) L fun x' => x' - x :=\n  has_fderiv_at_filter.is_O_sub h\n#align has_deriv_at_filter.is_O_sub has_deriv_at_filter.is_O_sub\n\n",
 "inv":
 "@[simp]\ntheorem differentiable.inv (hf : differentiable ğ•œ h) (hz : âˆ€ x, h x â‰  0) : differentiable ğ•œ fun x => (h x)â»Â¹ := fun x =>\n  (hf x).inv (hz x)\n#align differentiable.inv differentiable.inv\n\n",
 "has_strict_fderiv_at_iff_has_strict_deriv_at":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\ntheorem has_strict_fderiv_at_iff_has_strict_deriv_at {f' : Â«expr â†’L[ ] Â» ğ•œ ğ•œ F} :\n    has_strict_fderiv_at f f' x â†” has_strict_deriv_at f (f' 1) x := by simp [has_strict_deriv_at, has_strict_fderiv_at]\n#align has_strict_fderiv_at_iff_has_strict_deriv_at has_strict_fderiv_at_iff_has_strict_deriv_at\n\n",
 "has_strict_fderiv_at_equiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\ntheorem has_strict_deriv_at.has_strict_fderiv_at_equiv {f : ğ•œ â†’ ğ•œ} {f' x : ğ•œ} (hf : has_strict_deriv_at f f' x)\n    (hf' : f' â‰  0) :\n    has_strict_fderiv_at f (ContinuousLinearEquiv.unitsEquivAut ğ•œ (Units.mk0 f' hf') : Â«expr â†’L[ ] Â» ğ•œ ğ•œ ğ•œ) x :=\n  hf\n#align has_strict_deriv_at.has_strict_fderiv_at_equiv has_strict_deriv_at.has_strict_fderiv_at_equiv\n\n",
 "has_strict_deriv_at_zpow":
 "theorem has_strict_deriv_at_zpow (m : â„¤) (x : ğ•œ) (h : x â‰  0 âˆ¨ 0 â‰¤ m) :\n    has_strict_deriv_at (fun x => x ^ m) ((m : ğ•œ) * x ^ (m - 1)) x :=\n  by\n  have : âˆ€ m : â„¤, 0 < m â†’ has_strict_deriv_at (fun x => x ^ m) ((m : ğ•œ) * x ^ (m - 1)) x :=\n    by\n    intro m hm\n    lift m to â„• using le_of_lt hm\n    simp only [zpow_ofNat, Int.cast_ofNat]\n    convert has_strict_deriv_at_pow _ _ using 2\n    rw [â† Int.ofNat_one, â† Int.ofNat_sub, zpow_ofNat]\n    norm_cast  at hm\n    exact nat.succ_le_of_lt hm\n  rcases lt_trichotomy m 0 with (hm | hm | hm)\n  Â· have hx : x â‰  0 := h.resolve_right hm.not_le\n    have := (has_strict_deriv_at_inv _).scomp _ (this (-m) (neg_pos.2 hm)) <;> [skip,\n      exact zpow_ne_zero_of_ne_zero hx _]\n    simp only [(Â· âˆ˜ Â·), zpow_neg, one_div, inv_inv, smul_eq_mul] at this\n    convert this using 1\n    rw [sq, mul_inv, inv_inv, Int.cast_neg, neg_mul, neg_mul_neg, â† zpow_addâ‚€ hx, mul_assoc, â† zpow_addâ‚€ hx]\n    congr\n    abel\n  Â· simp only [hm, zpow_zero, Int.cast_zero, MulZeroClass.zero_mul, has_strict_deriv_at_const]\n  Â· exact this m hm\n#align has_strict_deriv_at_zpow has_strict_deriv_at_zpow\n\n",
 "has_strict_deriv_at_symm":
 "/-- If `f` is a local homeomorphism defined on a neighbourhood of `f.symm a`, and `f` has a\nnonzero derivative `f'` at `f.symm a` in the strict sense, then `f.symm` has the derivative `f'â»Â¹`\nat `a` in the strict sense.\n\nThis is one of the easy parts of the inverse function theorem: it assumes that we already have\nan inverse function. -/\ntheorem local_homeomorph.has_strict_deriv_at_symm (f : LocalHomeomorph ğ•œ ğ•œ) {a f' : ğ•œ} (ha : a âˆˆ f.target)\n    (hf' : f' â‰  0) (htff' : has_strict_deriv_at f f' (f.symm a)) : has_strict_deriv_at f.symm f'â»Â¹ a :=\n  htff'.of_local_left_inverse (f.symm.continuous_at ha) hf' (f.eventually_right_inverse ha)\n#align local_homeomorph.has_strict_deriv_at_symm local_homeomorph.has_strict_deriv_at_symm\n\n",
 "has_strict_deriv_at_pow":
 "theorem has_strict_deriv_at_pow (n : â„•) (x : ğ•œ) : has_strict_deriv_at (fun x => x ^ n) ((n : ğ•œ) * x ^ (n - 1)) x :=\n  by\n  convert(Polynomial.C (1 : ğ•œ) * Polynomial.X ^ n).has_strict_deriv_at x\n  Â· simp\n  Â· rw [Polynomial.derivative_C_mul_X_pow]\n    simp\n#align has_strict_deriv_at_pow has_strict_deriv_at_pow\n\n",
 "has_strict_deriv_at_pi":
 "@[simp]\ntheorem has_strict_deriv_at_pi : has_strict_deriv_at Ï† Ï†' x â†” âˆ€ i, has_strict_deriv_at (fun x => Ï† x i) (Ï†' i) x :=\n  has_strict_fderiv_at_pi'\n#align has_strict_deriv_at_pi has_strict_deriv_at_pi\n\n",
 "has_strict_deriv_at_neg":
 "theorem has_strict_deriv_at_neg : has_strict_deriv_at has_neg.neg (-1) x :=\n  has_strict_deriv_at.neg <| has_strict_deriv_at_id _\n#align has_strict_deriv_at_neg has_strict_deriv_at_neg\n\n",
 "has_strict_deriv_at_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr =o[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem has_strict_deriv_at_inv (hx : x â‰  0) : has_strict_deriv_at has_inv.inv (-(x ^ 2)â»Â¹) x :=\n  by\n  suffices\n    Â«expr =o[ ] Â» (fun p : ğ•œ Ã— ğ•œ => (p.1 - p.2) * ((x * x)â»Â¹ - (p.1 * p.2)â»Â¹)) ((nhds) (x, x)) fun p => (p.1 - p.2) * 1\n    by\n    refine' this.congr' _ (eventually_of_forall fun _ => mul_one _)\n    refine' eventually.mono (IsOpen.mem_nhds (is_open_ne.prod isOpen_ne) âŸ¨hx, hxâŸ©) _\n    rintro âŸ¨y, zâŸ© âŸ¨hy, hzâŸ©\n    simp only [mem_set_of_eq] at hy hz\n    -- hy : y â‰  0, hz : z â‰  0\n    field_simp [hx, hy, hz]\n    ring\n  refine' (is_O_refl (fun p : ğ•œ Ã— ğ•œ => p.1 - p.2) _).mul_is_o ((is_o_one_iff _).2 _)\n  rw [â† sub_self (x * x)â»Â¹]\n  exact tendsto_const_nhds.sub ((continuous_mul.tendsto (x, x)).invâ‚€ <| mul_ne_zero hx hx)\n#align has_strict_deriv_at_inv has_strict_deriv_at_inv\n\n",
 "has_strict_deriv_at_iff_has_strict_fderiv_at":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\ntheorem has_strict_deriv_at_iff_has_strict_fderiv_at :\n    has_strict_deriv_at f f' x â†” has_strict_fderiv_at f (smulRight (1 : Â«expr â†’L[ ] Â» ğ•œ ğ•œ ğ•œ) f') x :=\n  iff.rfl\n#align has_strict_deriv_at_iff_has_strict_fderiv_at has_strict_deriv_at_iff_has_strict_fderiv_at\n\n",
 "has_strict_deriv_at_id":
 "theorem has_strict_deriv_at_id : has_strict_deriv_at id 1 x :=\n  (has_strict_fderiv_at_id x).has_strict_deriv_at\n#align has_strict_deriv_at_id has_strict_deriv_at_id\n\n",
 "has_strict_deriv_at_const":
 "theorem has_strict_deriv_at_const : has_strict_deriv_at (fun x => c) 0 x :=\n  (has_strict_fderiv_at_const c x).has_strict_deriv_at\n#align has_strict_deriv_at_const has_strict_deriv_at_const\n\n",
 "has_strict_deriv_at":
 "/-- The derivative (in the analysis sense) of a polynomial `p` is given by `p.derivative`. -/\nprotected theorem has_strict_deriv_at (x : ğ•œ) : has_strict_deriv_at (fun x => p.eval x) (p.derivative.eval x) x :=\n  by\n  apply p.induction_on\n  Â· simp [has_strict_deriv_at_const]\n  Â· intro p q hp hq\n    convert hp.add hq <;> simp\n  Â· intro n a h\n    convert h.mul (has_strict_deriv_at_id x)\n    Â· ext y\n      simp [pow_add, mul_assoc]\n    Â· simp only [pow_add, pow_one, derivative_mul, derivative_C, MulZeroClass.zero_mul, derivative_X_pow, derivative_X,\n        mul_one, zero_add, eval_mul, eval_C, eval_add, eval_nat_cast, eval_pow, eval_X, id.def]\n      ring\n#align has_strict_deriv_at has_strict_deriv_at\n\n",
 "has_fderiv_within_at_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\ntheorem has_fderiv_within_at_inv (x_ne_zero : x â‰  0) :\n    has_fderiv_within_at (fun x => xâ»Â¹) (smulRight (1 : Â«expr â†’L[ ] Â» ğ•œ ğ•œ ğ•œ) (-(x ^ 2)â»Â¹) : Â«expr â†’L[ ] Â» ğ•œ ğ•œ ğ•œ) s x :=\n  (has_fderiv_at_inv x_ne_zero).has_fderiv_within_at\n#align has_fderiv_within_at_inv has_fderiv_within_at_inv\n\n",
 "has_fderiv_within_at_iff_has_deriv_within_at":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/-- Expressing `has_fderiv_within_at f f' s x` in terms of `has_deriv_within_at` -/\ntheorem has_fderiv_within_at_iff_has_deriv_within_at {f' : Â«expr â†’L[ ] Â» ğ•œ ğ•œ F} :\n    has_fderiv_within_at f f' s x â†” has_deriv_within_at f (f' 1) s x :=\n  has_fderiv_at_filter_iff_has_deriv_at_filter\n#align has_fderiv_within_at_iff_has_deriv_within_at has_fderiv_within_at_iff_has_deriv_within_at\n\n",
 "has_fderiv_within_at":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\nprotected theorem has_fderiv_within_at (x : ğ•œ) :\n    has_fderiv_within_at (fun x => p.eval x) (smulRight (1 : Â«expr â†’L[ ] Â» ğ•œ ğ•œ ğ•œ) (p.derivative.eval x)) s x :=\n  (p.has_fderiv_at x).has_fderiv_within_at\n#align has_fderiv_within_at has_fderiv_within_at\n\n",
 "has_fderiv_at_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\ntheorem has_fderiv_at_inv (x_ne_zero : x â‰  0) :\n    has_fderiv_at (fun x => xâ»Â¹) (smulRight (1 : Â«expr â†’L[ ] Â» ğ•œ ğ•œ ğ•œ) (-(x ^ 2)â»Â¹) : Â«expr â†’L[ ] Â» ğ•œ ğ•œ ğ•œ) x :=\n  has_deriv_at_inv x_ne_zero\n#align has_fderiv_at_inv has_fderiv_at_inv\n\n",
 "has_fderiv_at_iff_has_deriv_at":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/-- Expressing `has_fderiv_at f f' x` in terms of `has_deriv_at` -/\ntheorem has_fderiv_at_iff_has_deriv_at {f' : Â«expr â†’L[ ] Â» ğ•œ ğ•œ F} : has_fderiv_at f f' x â†” has_deriv_at f (f' 1) x :=\n  has_fderiv_at_filter_iff_has_deriv_at_filter\n#align has_fderiv_at_iff_has_deriv_at has_fderiv_at_iff_has_deriv_at\n\n",
 "has_fderiv_at_filter_iff_has_deriv_at_filter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/-\nCopyright (c) 2019 Gabriel Ebner. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Gabriel Ebner, SÃ©bastien GouÃ«zel\n-/\n/-- Expressing `has_fderiv_at_filter f f' x L` in terms of `has_deriv_at_filter` -/\ntheorem has_fderiv_at_filter_iff_has_deriv_at_filter {f' : Â«expr â†’L[ ] Â» ğ•œ ğ•œ F} :\n    has_fderiv_at_filter f f' x L â†” has_deriv_at_filter f (f' 1) x L := by simp [has_deriv_at_filter]\n#align has_fderiv_at_filter_iff_has_deriv_at_filter has_fderiv_at_filter_iff_has_deriv_at_filter\n\n",
 "has_fderiv_at_equiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\ntheorem has_deriv_at.has_fderiv_at_equiv {f : ğ•œ â†’ ğ•œ} {f' x : ğ•œ} (hf : has_deriv_at f f' x) (hf' : f' â‰  0) :\n    has_fderiv_at f (ContinuousLinearEquiv.unitsEquivAut ğ•œ (Units.mk0 f' hf') : Â«expr â†’L[ ] Â» ğ•œ ğ•œ ğ•œ) x :=\n  hf\n#align has_deriv_at.has_fderiv_at_equiv has_deriv_at.has_fderiv_at_equiv\n\n",
 "has_fderiv_at":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\nprotected theorem has_fderiv_at (x : ğ•œ) :\n    has_fderiv_at (fun x => p.eval x) (smulRight (1 : Â«expr â†’L[ ] Â» ğ•œ ğ•œ ğ•œ) (p.derivative.eval x)) x :=\n  p.has_deriv_at x\n#align has_fderiv_at has_fderiv_at\n\n",
 "has_deriv_within_at_zpow":
 "theorem has_deriv_within_at_zpow (m : â„¤) (x : ğ•œ) (h : x â‰  0 âˆ¨ 0 â‰¤ m) (s : Set ğ•œ) :\n    has_deriv_within_at (fun x => x ^ m) ((m : ğ•œ) * x ^ (m - 1)) s x :=\n  (has_deriv_at_zpow m x h).has_deriv_within_at\n#align has_deriv_within_at_zpow has_deriv_within_at_zpow\n\n",
 "has_deriv_within_at_univ":
 "@[simp]\ntheorem has_deriv_within_at_univ : has_deriv_within_at f f' univ x â†” has_deriv_at f f' x :=\n  has_fderiv_within_at_univ\n#align has_deriv_within_at_univ has_deriv_within_at_univ\n\n",
 "has_deriv_within_at_pow":
 "theorem has_deriv_within_at_pow (n : â„•) (x : ğ•œ) (s : Set ğ•œ) :\n    has_deriv_within_at (fun x => x ^ n) ((n : ğ•œ) * x ^ (n - 1)) s x :=\n  (has_deriv_at_pow n x).has_deriv_within_at\n#align has_deriv_within_at_pow has_deriv_within_at_pow\n\n",
 "has_deriv_within_at_pi":
 "theorem has_deriv_within_at_pi : has_deriv_within_at Ï† Ï†' s x â†” âˆ€ i, has_deriv_within_at (fun x => Ï† x i) (Ï†' i) s x :=\n  has_deriv_at_filter_pi\n#align has_deriv_within_at_pi has_deriv_within_at_pi\n\n",
 "has_deriv_within_at_neg":
 "theorem has_deriv_within_at_neg : has_deriv_within_at has_neg.neg (-1) s x :=\n  has_deriv_at_filter_neg _ _\n#align has_deriv_within_at_neg has_deriv_within_at_neg\n\n",
 "has_deriv_within_at_inv":
 "theorem has_deriv_within_at_inv (x_ne_zero : x â‰  0) (s : Set ğ•œ) : has_deriv_within_at (fun x => xâ»Â¹) (-(x ^ 2)â»Â¹) s x :=\n  (has_deriv_at_inv x_ne_zero).has_deriv_within_at\n#align has_deriv_within_at_inv has_deriv_within_at_inv\n\n",
 "has_deriv_within_at_inter'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\ntheorem has_deriv_within_at_inter' (h : t âˆˆ nhds_within s x) :\n    has_deriv_within_at f f' (s âˆ© t) x â†” has_deriv_within_at f f' s x :=\n  has_fderiv_within_at_inter' h\n#align has_deriv_within_at_inter' has_deriv_within_at_inter'\n\n",
 "has_deriv_within_at_inter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem has_deriv_within_at_inter (h : t âˆˆ (nhds) x) :\n    has_deriv_within_at f f' (s âˆ© t) x â†” has_deriv_within_at f f' s x :=\n  has_fderiv_within_at_inter h\n#align has_deriv_within_at_inter has_deriv_within_at_inter\n\n",
 "has_deriv_within_at_iff_tendsto_slope'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem has_deriv_within_at_iff_tendsto_slope' (hs : x âˆ‰ s) :\n    has_deriv_within_at f f' s x â†” Tendsto (slope f x) (nhds_within s x) ((nhds) f') :=\n  by\n  convertâ† has_deriv_within_at_iff_tendsto_slope\n  exact diff_singleton_eq_self hs\n#align has_deriv_within_at_iff_tendsto_slope' has_deriv_within_at_iff_tendsto_slope'\n\n",
 "has_deriv_within_at_iff_tendsto_slope":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem has_deriv_within_at_iff_tendsto_slope :\n    has_deriv_within_at f f' s x â†” Tendsto (slope f x) (nhds_within (s \\ {x}) x) ((nhds) f') :=\n  by\n  simp only [has_deriv_within_at, nhdsWithin, diff_eq, inf_assoc.symm, inf_principal.symm]\n  exact has_deriv_at_filter_iff_tendsto_slope\n#align has_deriv_within_at_iff_tendsto_slope has_deriv_within_at_iff_tendsto_slope\n\n",
 "has_deriv_within_at_iff_tendsto":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem has_deriv_within_at_iff_tendsto :\n    has_deriv_within_at f f' s x â†”\n      Tendsto (fun x' => (Â«exprâ€– â€–Â» (x' - x))â»Â¹ * Â«exprâ€– â€–Â» (f x' - f x - Â«expr â€¢ Â» (x' - x) f')) (nhds_within s x)\n        ((nhds) 0) :=\n  has_fderiv_at_filter_iff_tendsto\n#align has_deriv_within_at_iff_tendsto has_deriv_within_at_iff_tendsto\n\n",
 "has_deriv_within_at_iff_is_o":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr =o[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\ntheorem has_deriv_within_at_iff_is_o :\n    has_deriv_within_at f f' s x â†”\n      Â«expr =o[ ] Â» (fun x' : ğ•œ => f x' - f x - Â«expr â€¢ Â» (x' - x) f') (nhds_within s x) fun x' => x' - x :=\n  iff.rfl\n#align has_deriv_within_at_iff_is_o has_deriv_within_at_iff_is_o\n\n",
 "has_deriv_within_at_iff_has_fderiv_within_at":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/-- Expressing `has_deriv_within_at f f' s x` in terms of `has_fderiv_within_at` -/\ntheorem has_deriv_within_at_iff_has_fderiv_within_at {f' : F} :\n    has_deriv_within_at f f' s x â†” has_fderiv_within_at f (smulRight (1 : Â«expr â†’L[ ] Â» ğ•œ ğ•œ ğ•œ) f') s x :=\n  iff.rfl\n#align has_deriv_within_at_iff_has_fderiv_within_at has_deriv_within_at_iff_has_fderiv_within_at\n\n",
 "has_deriv_within_at_id":
 "theorem has_deriv_within_at_id : has_deriv_within_at id 1 s x :=\n  has_deriv_at_filter_id _ _\n#align has_deriv_within_at_id has_deriv_within_at_id\n\n",
 "has_deriv_within_at_diff_singleton":
 "@[simp]\ntheorem has_deriv_within_at_diff_singleton : has_deriv_within_at f f' (s \\ {x}) x â†” has_deriv_within_at f f' s x := by\n  simp only [has_deriv_within_at_iff_tendsto_slope, sdiff_idem]\n#align has_deriv_within_at_diff_singleton has_deriv_within_at_diff_singleton\n\n",
 "has_deriv_within_at_deriv_within_iff":
 "@[simp]\ntheorem has_deriv_within_at_deriv_within_iff :\n    has_deriv_within_at f (deriv_within f s x) s x â†” differentiable_within_at ğ•œ f s x :=\n  âŸ¨fun h => h.differentiable_within_at, fun h => h.has_deriv_within_atâŸ©\n#align has_deriv_within_at_deriv_within_iff has_deriv_within_at_deriv_within_iff\n\n",
 "has_deriv_within_at_const":
 "theorem has_deriv_within_at_const : has_deriv_within_at (fun x => c) 0 s x :=\n  has_deriv_at_filter_const _ _ _\n#align has_deriv_within_at_const has_deriv_within_at_const\n\n",
 "has_deriv_within_at_congr_set":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem has_deriv_within_at_congr_set {s t u : Set ğ•œ} (hu : u âˆˆ (nhds) x) (h : s âˆ© u = t âˆ© u) :\n    has_deriv_within_at f f' s x â†” has_deriv_within_at f f' t x := by\n  simp_rw [has_deriv_within_at, nhdsWithin_eq_nhds_within' hu h]\n#align has_deriv_within_at_congr_set has_deriv_within_at_congr_set\n\n",
 "has_deriv_within_at_Ioi_iff_Ici":
 "@[simp]\ntheorem has_deriv_within_at_Ioi_iff_Ici [partial_order ğ•œ] :\n    has_deriv_within_at f f' (Ioi x) x â†” has_deriv_within_at f f' (Ici x) x := by\n  rw [â† Ici_diff_left, has_deriv_within_at_diff_singleton]\n#align has_deriv_within_at_Ioi_iff_Ici has_deriv_within_at_Ioi_iff_Ici\n\n",
 "has_deriv_within_at_Iio_iff_Iic":
 "@[simp]\ntheorem has_deriv_within_at_Iio_iff_Iic [partial_order ğ•œ] :\n    has_deriv_within_at f f' (Iio x) x â†” has_deriv_within_at f f' (Iic x) x := by\n  rw [â† Iic_diff_right, has_deriv_within_at_diff_singleton]\n#align has_deriv_within_at_Iio_iff_Iic has_deriv_within_at_Iio_iff_Iic\n\n",
 "has_deriv_within_at":
 "protected theorem has_deriv_within_at (x : ğ•œ) (s : Set ğ•œ) :\n    has_deriv_within_at (fun x => p.eval x) (p.derivative.eval x) s x :=\n  (p.has_deriv_at x).has_deriv_within_at\n#align has_deriv_within_at has_deriv_within_at\n\n",
 "has_deriv_at_zpow":
 "theorem has_deriv_at_zpow (m : â„¤) (x : ğ•œ) (h : x â‰  0 âˆ¨ 0 â‰¤ m) :\n    has_deriv_at (fun x => x ^ m) ((m : ğ•œ) * x ^ (m - 1)) x :=\n  (has_strict_deriv_at_zpow m x h).has_deriv_at\n#align has_deriv_at_zpow has_deriv_at_zpow\n\n",
 "has_deriv_at_symm":
 "/-- If `f` is a local homeomorphism defined on a neighbourhood of `f.symm a`, and `f` has an\nnonzero derivative `f'` at `f.symm a`, then `f.symm` has the derivative `f'â»Â¹` at `a`.\n\nThis is one of the easy parts of the inverse function theorem: it assumes that we already have\nan inverse function. -/\ntheorem local_homeomorph.has_deriv_at_symm (f : LocalHomeomorph ğ•œ ğ•œ) {a f' : ğ•œ} (ha : a âˆˆ f.target) (hf' : f' â‰  0)\n    (htff' : has_deriv_at f f' (f.symm a)) : has_deriv_at f.symm f'â»Â¹ a :=\n  htff'.of_local_left_inverse (f.symm.continuous_at ha) hf' (f.eventually_right_inverse ha)\n#align local_homeomorph.has_deriv_at_symm local_homeomorph.has_deriv_at_symm\n\n",
 "has_deriv_at_pow":
 "theorem has_deriv_at_pow (n : â„•) (x : ğ•œ) : has_deriv_at (fun x => x ^ n) ((n : ğ•œ) * x ^ (n - 1)) x :=\n  (has_strict_deriv_at_pow n x).has_deriv_at\n#align has_deriv_at_pow has_deriv_at_pow\n\n",
 "has_deriv_at_pi":
 "theorem has_deriv_at_pi : has_deriv_at Ï† Ï†' x â†” âˆ€ i, has_deriv_at (fun x => Ï† x i) (Ï†' i) x :=\n  has_deriv_at_filter_pi\n#align has_deriv_at_pi has_deriv_at_pi\n\n",
 "has_deriv_at_neg'":
 "theorem has_deriv_at_neg' : has_deriv_at (fun x => -x) (-1) x :=\n  has_deriv_at_filter_neg _ _\n#align has_deriv_at_neg' has_deriv_at_neg'\n\n",
 "has_deriv_at_neg":
 "theorem has_deriv_at_neg : has_deriv_at has_neg.neg (-1) x :=\n  has_deriv_at_filter_neg _ _\n#align has_deriv_at_neg has_deriv_at_neg\n\n",
 "has_deriv_at_mul_const":
 "theorem has_deriv_at_mul_const (c : ğ•œ) : has_deriv_at (fun x => x * c) c x := by\n  simpa only [one_mul] using (has_deriv_at_id' x).mul_const c\n#align has_deriv_at_mul_const has_deriv_at_mul_const\n\n",
 "has_deriv_at_inv":
 "theorem has_deriv_at_inv (x_ne_zero : x â‰  0) : has_deriv_at (fun y => yâ»Â¹) (-(x ^ 2)â»Â¹) x :=\n  (has_strict_deriv_at_inv x_ne_zero).has_deriv_at\n#align has_deriv_at_inv has_deriv_at_inv\n\n",
 "has_deriv_at_iff_tendsto_slope":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.ne -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem has_deriv_at_iff_tendsto_slope : has_deriv_at f f' x â†” Tendsto (slope f x) (nhds_within.ne x) ((nhds) f') :=\n  has_deriv_at_filter_iff_tendsto_slope\n#align has_deriv_at_iff_tendsto_slope has_deriv_at_iff_tendsto_slope\n\n",
 "has_deriv_at_iff_tendsto":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem has_deriv_at_iff_tendsto :\n    has_deriv_at f f' x â†”\n      Tendsto (fun x' => (Â«exprâ€– â€–Â» (x' - x))â»Â¹ * Â«exprâ€– â€–Â» (f x' - f x - Â«expr â€¢ Â» (x' - x) f')) ((nhds) x)\n        ((nhds) 0) :=\n  has_fderiv_at_filter_iff_tendsto\n#align has_deriv_at_iff_tendsto has_deriv_at_iff_tendsto\n\n",
 "has_deriv_at_iff_is_o_nhds_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr =o[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem has_deriv_at_iff_is_o_nhds_zero :\n    has_deriv_at f f' x â†” Â«expr =o[ ] Â» (fun h => f (x + h) - f x - Â«expr â€¢ Â» h f') ((nhds) 0) fun h => h :=\n  has_fderiv_at_iff_is_o_nhds_zero\n#align has_deriv_at_iff_is_o_nhds_zero has_deriv_at_iff_is_o_nhds_zero\n\n",
 "has_deriv_at_iff_is_o":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr =o[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem has_deriv_at_iff_is_o :\n    has_deriv_at f f' x â†”\n      Â«expr =o[ ] Â» (fun x' : ğ•œ => f x' - f x - Â«expr â€¢ Â» (x' - x) f') ((nhds) x) fun x' => x' - x :=\n  iff.rfl\n#align has_deriv_at_iff_is_o has_deriv_at_iff_is_o\n\n",
 "has_deriv_at_iff_has_fderiv_at":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/-- Expressing `has_deriv_at f f' x` in terms of `has_fderiv_at` -/\ntheorem has_deriv_at_iff_has_fderiv_at {f' : F} :\n    has_deriv_at f f' x â†” has_fderiv_at f (smulRight (1 : Â«expr â†’L[ ] Â» ğ•œ ğ•œ ğ•œ) f') x :=\n  iff.rfl\n#align has_deriv_at_iff_has_fderiv_at has_deriv_at_iff_has_fderiv_at\n\n",
 "has_deriv_at_id'":
 "theorem has_deriv_at_id' : has_deriv_at (fun x : ğ•œ => x) 1 x :=\n  has_deriv_at_filter_id _ _\n#align has_deriv_at_id' has_deriv_at_id'\n\n",
 "has_deriv_at_id":
 "theorem has_deriv_at_id : has_deriv_at id 1 x :=\n  has_deriv_at_filter_id _ _\n#align has_deriv_at_id has_deriv_at_id\n\n",
 "has_deriv_at_filter_pi":
 "@[simp]\ntheorem has_deriv_at_filter_pi : has_deriv_at_filter Ï† Ï†' x L â†” âˆ€ i, has_deriv_at_filter (fun x => Ï† x i) (Ï†' i) x L :=\n  has_fderiv_at_filter_pi'\n#align has_deriv_at_filter_pi has_deriv_at_filter_pi\n\n",
 "has_deriv_at_filter_neg":
 "theorem has_deriv_at_filter_neg : has_deriv_at_filter has_neg.neg (-1) x L :=\n  has_deriv_at_filter.neg <| has_deriv_at_filter_id _ _\n#align has_deriv_at_filter_neg has_deriv_at_filter_neg\n\n",
 "has_deriv_at_filter_iff_tendsto_slope":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŠ“ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á¶œÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- If the domain has dimension one, then FrÃ©chet derivative is equivalent to the classical\ndefinition with a limit. In this version we have to take the limit along the subset `-{x}`,\nbecause for `y=x` the slope equals zero due to the convention `0â»Â¹=0`. -/\ntheorem has_deriv_at_filter_iff_tendsto_slope {x : ğ•œ} {L : Filter ğ•œ} :\n    has_deriv_at_filter f f' x L â†” Tendsto (slope f x) (Â«expr âŠ“ Â» L ((filter.principal) (Â«expr á¶œÂ» {x}))) ((nhds) f') :=\n  by\n  conv_lhs =>\n    simp only [has_deriv_at_filter_iff_tendsto, (norm_inv _).symm, (norm_smul _ _).symm,\n      tendsto_zero_iff_norm_tendsto_zero.symm]\n  conv_rhs => rw [â† nhds_translation_sub f', tendsto_comap_iff]\n  refine' (tendsto_inf_principal_nhds_iff_of_forall_eq <| by simp).symm.trans (tendsto_congr' _)\n  refine' (eventually_principal.2 fun z hz => _).filter_mono inf_le_right\n  simp only [(Â· âˆ˜ Â·)]\n  rw [smul_sub, â† mul_smul, inv_mul_cancel (sub_ne_zero.2 hz), one_smul, slope_def_module]\n#align has_deriv_at_filter_iff_tendsto_slope has_deriv_at_filter_iff_tendsto_slope\n\n",
 "has_deriv_at_filter_iff_tendsto":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem has_deriv_at_filter_iff_tendsto :\n    has_deriv_at_filter f f' x L â†”\n      Tendsto (fun x' : ğ•œ => (Â«exprâ€– â€–Â» (x' - x))â»Â¹ * Â«exprâ€– â€–Â» (f x' - f x - Â«expr â€¢ Â» (x' - x) f')) L ((nhds) 0) :=\n  has_fderiv_at_filter_iff_tendsto\n#align has_deriv_at_filter_iff_tendsto has_deriv_at_filter_iff_tendsto\n\n",
 "has_deriv_at_filter_iff_is_o":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr =o[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\ntheorem has_deriv_at_filter_iff_is_o :\n    has_deriv_at_filter f f' x L â†”\n      Â«expr =o[ ] Â» (fun x' : ğ•œ => f x' - f x - Â«expr â€¢ Â» (x' - x) f') L fun x' => x' - x :=\n  iff.rfl\n#align has_deriv_at_filter_iff_is_o has_deriv_at_filter_iff_is_o\n\n",
 "has_deriv_at_filter_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr =á¶ [ ] Â» -/\ntheorem filter.eventually_eq.has_deriv_at_filter_iff (hâ‚€ : Â«expr =á¶ [ ] Â» fâ‚€ L fâ‚) (hx : fâ‚€ x = fâ‚ x) (hâ‚ : fâ‚€' = fâ‚') :\n    has_deriv_at_filter fâ‚€ fâ‚€' x L â†” has_deriv_at_filter fâ‚ fâ‚' x L :=\n  hâ‚€.has_fderiv_at_filter_iff hx (by simp [hâ‚])\n#align filter.eventually_eq.has_deriv_at_filter_iff filter.eventually_eq.has_deriv_at_filter_iff\n\n",
 "has_deriv_at_filter_id":
 "theorem has_deriv_at_filter_id : has_deriv_at_filter id 1 x L :=\n  (has_fderiv_at_filter_id x L).has_deriv_at_filter\n#align has_deriv_at_filter_id has_deriv_at_filter_id\n\n",
 "has_deriv_at_filter_const":
 "theorem has_deriv_at_filter_const : has_deriv_at_filter (fun x => c) 0 x L :=\n  (has_fderiv_at_filter_const c x L).has_deriv_at_filter\n#align has_deriv_at_filter_const has_deriv_at_filter_const\n\n",
 "has_deriv_at_filter":
 "protected theorem linear_map.has_deriv_at_filter : has_deriv_at_filter e (e 1) x L :=\n  e.to_continuous_linear_mapâ‚.has_deriv_at_filter\n#align linear_map.has_deriv_at_filter linear_map.has_deriv_at_filter\n\n",
 "has_deriv_at_deriv_iff":
 "@[simp]\ntheorem has_deriv_at_deriv_iff : has_deriv_at f (deriv f x) x â†” differentiable_at ğ•œ f x :=\n  âŸ¨fun h => h.differentiable_at, fun h => h.has_deriv_atâŸ©\n#align has_deriv_at_deriv_iff has_deriv_at_deriv_iff\n\n",
 "has_deriv_at_const":
 "theorem has_deriv_at_const : has_deriv_at (fun x => c) 0 x :=\n  has_deriv_at_filter_const _ _ _\n#align has_deriv_at_const has_deriv_at_const\n\n",
 "has_deriv_at":
 "/-- The derivative (in the analysis sense) of a polynomial `p` is given by `p.derivative`. -/\nprotected theorem has_deriv_at (x : ğ•œ) : has_deriv_at (fun x => p.eval x) (p.derivative.eval x) x :=\n  (p.has_strict_deriv_at x).has_deriv_at\n#align has_deriv_at has_deriv_at\n\n",
 "fderiv_within_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\ntheorem fderiv_within_inv (x_ne_zero : x â‰  0) (hxs : unique_diff_within_at ğ•œ s x) :\n    fderiv_within ğ•œ (fun x => xâ»Â¹) s x = smulRight (1 : Â«expr â†’L[ ] Â» ğ•œ ğ•œ ğ•œ) (-(x ^ 2)â»Â¹) :=\n  by\n  rw [differentiable_at.fderiv_within (differentiable_at_inv.2 x_ne_zero) hxs]\n  exact fderiv_inv\n#align fderiv_within_inv fderiv_within_inv\n\n",
 "fderiv_within_deriv_within":
 "theorem fderiv_within_deriv_within : (fderiv_within ğ•œ f s x : ğ•œ â†’ F) 1 = deriv_within f s x :=\n  rfl\n#align fderiv_within_deriv_within fderiv_within_deriv_within\n\n",
 "fderiv_within":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\nprotected theorem fderiv_within (hxs : unique_diff_within_at ğ•œ s x) :\n    fderiv_within ğ•œ (fun x => p.eval x) s x = smulRight (1 : Â«expr â†’L[ ] Â» ğ•œ ğ•œ ğ•œ) (p.derivative.eval x) :=\n  (p.has_fderiv_within_at x).fderiv_within hxs\n#align fderiv_within fderiv_within\n\n",
 "fderiv_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\ntheorem fderiv_inv : fderiv ğ•œ (fun x => xâ»Â¹) x = smulRight (1 : Â«expr â†’L[ ] Â» ğ•œ ğ•œ ğ•œ) (-(x ^ 2)â»Â¹) := by\n  rw [â† deriv_fderiv, deriv_inv]\n#align fderiv_inv fderiv_inv\n\n",
 "fderiv_deriv":
 "theorem fderiv_deriv : (fderiv ğ•œ f x : ğ•œ â†’ F) 1 = deriv f x :=\n  rfl\n#align fderiv_deriv fderiv_deriv\n\n",
 "fderiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n@[simp]\nprotected theorem fderiv : fderiv ğ•œ (fun x => p.eval x) x = smulRight (1 : Â«expr â†’L[ ] Â» ğ•œ ğ•œ ğ•œ) (p.derivative.eval x) :=\n  (p.has_fderiv_at x).fderiv\n#align fderiv fderiv\n\n",
 "eventually_ne":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.ne -/\ntheorem has_deriv_at.eventually_ne (h : has_deriv_at f f' x) (hf' : f' â‰  0) :\n    Â«exprâˆ€á¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â»\"\n      (nhds_within.ne x) (f z â‰  f x) :=\n  (has_deriv_at_iff_has_fderiv_at.1 h).eventually_ne\n    âŸ¨(Â«exprâ€– â€–Â» f')â»Â¹, fun z => by field_simp [norm_smul, mt norm_eq_zero.1 hf'] âŸ©\n#align has_deriv_at.eventually_ne has_deriv_at.eventually_ne\n\n",
 "eq_deriv":
 "theorem unique_diff_within_at.eq_deriv (s : Set ğ•œ) (H : unique_diff_within_at ğ•œ s x) (h : has_deriv_within_at f f' s x)\n    (hâ‚ : has_deriv_within_at f fâ‚' s x) : f' = fâ‚' :=\n  smulRight_one_eq_iff.mp <| unique_diff_within_at.eq H h hâ‚\n#align unique_diff_within_at.eq_deriv unique_diff_within_at.eq_deriv\n\n",
 "div_const":
 "@[simp]\ntheorem differentiable.div_const (hc : differentiable ğ•œ c) (d : ğ•œ') : differentiable ğ•œ fun x => c x / d := fun x =>\n  (hc x).div_const d\n#align differentiable.div_const differentiable.div_const\n\n",
 "div":
 "@[simp]\ntheorem differentiable.div (hc : differentiable ğ•œ c) (hd : differentiable ğ•œ d) (hx : âˆ€ x, d x â‰  0) :\n    differentiable ğ•œ fun x => c x / d x := fun x => (hc x).div (hd x) (hx x)\n#align differentiable.div differentiable.div\n\n",
 "differentiable_within_at_zpow":
 "theorem differentiable_within_at_zpow (m : â„¤) (x : ğ•œ) (h : x â‰  0 âˆ¨ 0 â‰¤ m) :\n    differentiable_within_at ğ•œ (fun x => x ^ m) s x :=\n  (differentiable_at_zpow.mpr h).differentiable_within_at\n#align differentiable_within_at_zpow differentiable_within_at_zpow\n\n",
 "differentiable_within_at_pow":
 "theorem differentiable_within_at_pow : differentiable_within_at ğ•œ (fun x => x ^ n) s x :=\n  (differentiable_at_pow n).differentiable_within_at\n#align differentiable_within_at_pow differentiable_within_at_pow\n\n",
 "differentiable_within_at_of_deriv_within_ne_zero":
 "theorem differentiable_within_at_of_deriv_within_ne_zero (h : deriv_within f s x â‰  0) :\n    differentiable_within_at ğ•œ f s x :=\n  not_imp_comm.1 deriv_within_zero_of_not_differentiable_within_at h\n#align differentiable_within_at_of_deriv_within_ne_zero differentiable_within_at_of_deriv_within_ne_zero\n\n",
 "differentiable_within_at_inv":
 "theorem differentiable_within_at_inv (x_ne_zero : x â‰  0) : differentiable_within_at ğ•œ (fun x => xâ»Â¹) s x :=\n  (differentiable_at_inv.2 x_ne_zero).differentiable_within_at\n#align differentiable_within_at_inv differentiable_within_at_inv\n\n",
 "differentiable_within_at_Ioi_iff_Ici":
 "theorem differentiable_within_at_Ioi_iff_Ici [partial_order ğ•œ] :\n    differentiable_within_at ğ•œ f (Ioi x) x â†” differentiable_within_at ğ•œ f (Ici x) x :=\n  âŸ¨fun h => h.has_deriv_within_at.Ici_of_Ioi.differentiable_within_at, fun h =>\n    h.has_deriv_within_at.Ioi_of_Ici.differentiable_within_atâŸ©\n#align differentiable_within_at_Ioi_iff_Ici differentiable_within_at_Ioi_iff_Ici\n\n",
 "differentiable_within_at":
 "protected theorem differentiable_within_at : differentiable_within_at ğ•œ (fun x => p.eval x) s x :=\n  p.differentiable_at.differentiable_within_at\n#align differentiable_within_at differentiable_within_at\n\n",
 "differentiable_pow":
 "theorem differentiable_pow : differentiable ğ•œ fun x : ğ•œ => x ^ n := fun x => differentiable_at_pow n\n#align differentiable_pow differentiable_pow\n\n",
 "differentiable_on_zpow":
 "theorem differentiable_on_zpow (m : â„¤) (s : Set ğ•œ) (h : (0 : ğ•œ) âˆ‰ s âˆ¨ 0 â‰¤ m) : differentiable_on ğ•œ (fun x => x ^ m) s :=\n  fun x hxs => differentiable_within_at_zpow m x <| h.imp_left <| ne_of_mem_of_not_mem hxs\n#align differentiable_on_zpow differentiable_on_zpow\n\n",
 "differentiable_on_pow":
 "theorem differentiable_on_pow : differentiable_on ğ•œ (fun x => x ^ n) s :=\n  (differentiable_pow n).differentiable_on\n#align differentiable_on_pow differentiable_on_pow\n\n",
 "differentiable_on_neg":
 "theorem differentiable_on_neg : differentiable_on ğ•œ (has_neg.neg : ğ•œ â†’ ğ•œ) s :=\n  differentiable_on.neg differentiable_on_id\n#align differentiable_on_neg differentiable_on_neg\n\n",
 "differentiable_on_inv":
 "theorem differentiable_on_inv : differentiable_on ğ•œ (fun x : ğ•œ => xâ»Â¹) { x | x â‰  0 } := fun x hx =>\n  differentiable_within_at_inv hx\n#align differentiable_on_inv differentiable_on_inv\n\n",
 "differentiable_on":
 "protected theorem differentiable_on : differentiable_on ğ•œ (fun x => p.eval x) s :=\n  p.differentiable.differentiable_on\n#align differentiable_on differentiable_on\n\n",
 "differentiable_neg":
 "theorem differentiable_neg : differentiable ğ•œ (has_neg.neg : ğ•œ â†’ ğ•œ) :=\n  differentiable.neg differentiable_id\n#align differentiable_neg differentiable_neg\n\n",
 "differentiable_at_zpow":
 "theorem differentiable_at_zpow : differentiable_at ğ•œ (fun x => x ^ m) x â†” x â‰  0 âˆ¨ 0 â‰¤ m :=\n  âŸ¨fun H => NormedField.continuousAt_zpow.1 H.continuous_at, fun H => (has_deriv_at_zpow m x H).differentiable_atâŸ©\n#align differentiable_at_zpow differentiable_at_zpow\n\n",
 "differentiable_at_pow":
 "theorem differentiable_at_pow : differentiable_at ğ•œ (fun x => x ^ n) x :=\n  (has_deriv_at_pow n x).differentiable_at\n#align differentiable_at_pow differentiable_at_pow\n\n",
 "differentiable_at_of_deriv_ne_zero":
 "theorem differentiable_at_of_deriv_ne_zero (h : deriv f x â‰  0) : differentiable_at ğ•œ f x :=\n  not_imp_comm.1 deriv_zero_of_not_differentiable_at h\n#align differentiable_at_of_deriv_ne_zero differentiable_at_of_deriv_ne_zero\n\n",
 "differentiable_at_inv":
 "theorem differentiable_at_inv : differentiable_at ğ•œ (fun x => xâ»Â¹) x â†” x â‰  0 :=\n  âŸ¨fun H => NormedField.continuousAt_inv.1 H.continuous_at, fun H => (has_deriv_at_inv H).differentiable_atâŸ©\n#align differentiable_at_inv differentiable_at_inv\n\n",
 "differentiable_at":
 "protected theorem differentiable_at : differentiable_at ğ•œ (fun x => p.eval x) x :=\n  (p.has_deriv_at x).differentiable_at\n#align differentiable_at differentiable_at\n\n",
 "differentiable":
 "protected theorem differentiable : differentiable ğ•œ fun x => p.eval x := fun x => p.differentiable_at\n#align differentiable differentiable\n\n",
 "deriv_zpow'":
 "@[simp]\ntheorem deriv_zpow' (m : â„¤) : (deriv fun x : ğ•œ => x ^ m) = fun x => m * x ^ (m - 1) :=\n  funext <| deriv_zpow m\n#align deriv_zpow' deriv_zpow'\n\n",
 "deriv_zpow":
 "theorem deriv_zpow (m : â„¤) (x : ğ•œ) : deriv (fun x => x ^ m) x = m * x ^ (m - 1) :=\n  by\n  by_cases H : x â‰  0 âˆ¨ 0 â‰¤ m\n  Â· exact (has_deriv_at_zpow m x H).deriv\n  Â· rw [deriv_zero_of_not_differentiable_at (mt differentiable_at_zpow.1 H)]\n    push_neg  at H\n    rcases H with âŸ¨rfl, hmâŸ©\n    rw [zero_zpow _ ((sub_one_lt _).trans hm).ne, MulZeroClass.mul_zero]\n#align deriv_zpow deriv_zpow\n\n",
 "deriv_zero_of_not_differentiable_at":
 "theorem deriv_zero_of_not_differentiable_at (h : Â¬differentiable_at ğ•œ f x) : deriv f x = 0 :=\n  by\n  unfold deriv\n  rw [fderiv_zero_of_not_differentiable_at]\n  simp\n  assumption\n#align deriv_zero_of_not_differentiable_at deriv_zero_of_not_differentiable_at\n\n",
 "deriv_within_zpow":
 "theorem deriv_within_zpow (hxs : unique_diff_within_at ğ•œ s x) (h : x â‰  0 âˆ¨ 0 â‰¤ m) :\n    deriv_within (fun x => x ^ m) s x = (m : ğ•œ) * x ^ (m - 1) :=\n  (has_deriv_within_at_zpow m x h s).deriv_within hxs\n#align deriv_within_zpow deriv_within_zpow\n\n",
 "deriv_within_zero_of_not_differentiable_within_at":
 "theorem deriv_within_zero_of_not_differentiable_within_at (h : Â¬differentiable_within_at ğ•œ f s x) :\n    deriv_within f s x = 0 := by\n  unfold deriv_within\n  rw [fderiv_within_zero_of_not_differentiable_within_at]\n  simp\n  assumption\n#align deriv_within_zero_of_not_differentiable_within_at deriv_within_zero_of_not_differentiable_within_at\n\n",
 "deriv_within_univ":
 "@[simp]\ntheorem deriv_within_univ : deriv_within f univ = deriv f :=\n  by\n  ext\n  unfold deriv_within deriv\n  rw [fderiv_within_univ]\n#align deriv_within_univ deriv_within_univ\n\n",
 "deriv_within_sum":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem deriv_within_sum (hxs : unique_diff_within_at ğ•œ s x) (h : âˆ€ i âˆˆ u, differentiable_within_at ğ•œ (A i) s x) :\n    deriv_within\n        (fun y =>\n          finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" u (A i y))\n        s x =\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" u\n        (deriv_within (A i) s x) :=\n  (has_deriv_within_at.sum fun i hi => (h i hi).has_deriv_within_at).deriv_within hxs\n#align deriv_within_sum deriv_within_sum\n\n",
 "deriv_within_subset":
 "theorem deriv_within_subset (st : s âŠ† t) (ht : unique_diff_within_at ğ•œ s x) (h : differentiable_within_at ğ•œ f t x) :\n    deriv_within f s x = deriv_within f t x :=\n  ((differentiable_within_at.has_deriv_within_at h).mono st).deriv_within ht\n#align deriv_within_subset deriv_within_subset\n\n",
 "deriv_within_sub_const":
 "theorem deriv_within_sub_const (hxs : unique_diff_within_at ğ•œ s x) (c : F) :\n    deriv_within (fun y => f y - c) s x = deriv_within f s x := by simp only [deriv_within, fderiv_within_sub_const hxs]\n#align deriv_within_sub_const deriv_within_sub_const\n\n",
 "deriv_within_sub":
 "theorem deriv_within_sub (hxs : unique_diff_within_at ğ•œ s x) (hf : differentiable_within_at ğ•œ f s x)\n    (hg : differentiable_within_at ğ•œ g s x) :\n    deriv_within (fun y => f y - g y) s x = deriv_within f s x - deriv_within g s x :=\n  (hf.has_deriv_within_at.sub hg.has_deriv_within_at).deriv_within hxs\n#align deriv_within_sub deriv_within_sub\n\n",
 "deriv_within_smul_const":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\ntheorem deriv_within_smul_const (hxs : unique_diff_within_at ğ•œ s x) (hc : differentiable_within_at ğ•œ c s x) (f : F) :\n    deriv_within (fun y => Â«expr â€¢ Â» (c y) f) s x = Â«expr â€¢ Â» (deriv_within c s x) f :=\n  (hc.has_deriv_within_at.smul_const f).deriv_within hxs\n#align deriv_within_smul_const deriv_within_smul_const\n\n",
 "deriv_within_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\ntheorem deriv_within_smul (hxs : unique_diff_within_at ğ•œ s x) (hc : differentiable_within_at ğ•œ c s x)\n    (hf : differentiable_within_at ğ•œ f s x) :\n    deriv_within (fun y => Â«expr â€¢ Â» (c y) (f y)) s x =\n      Â«expr â€¢ Â» (c x) (deriv_within f s x) + Â«expr â€¢ Â» (deriv_within c s x) (f x) :=\n  (hc.has_deriv_within_at.smul hf.has_deriv_within_at).deriv_within hxs\n#align deriv_within_smul deriv_within_smul\n\n",
 "deriv_within_pow'":
 "theorem deriv_within_pow' (hc : differentiable_within_at ğ•œ c s x) (hxs : unique_diff_within_at ğ•œ s x) :\n    deriv_within (fun x => c x ^ n) s x = (n : ğ•œ) * c x ^ (n - 1) * deriv_within c s x :=\n  (hc.has_deriv_within_at.pow n).deriv_within hxs\n#align deriv_within_pow' deriv_within_pow'\n\n",
 "deriv_within_pow":
 "theorem deriv_within_pow (hxs : unique_diff_within_at ğ•œ s x) :\n    deriv_within (fun x => x ^ n) s x = (n : ğ•œ) * x ^ (n - 1) :=\n  (has_deriv_within_at_pow n x s).deriv_within hxs\n#align deriv_within_pow deriv_within_pow\n\n",
 "deriv_within_pi":
 "theorem deriv_within_pi (h : âˆ€ i, differentiable_within_at ğ•œ (fun x => Ï† x i) s x) (hs : unique_diff_within_at ğ•œ s x) :\n    deriv_within Ï† s x = fun i => deriv_within (fun x => Ï† x i) s x :=\n  (has_deriv_within_at_pi.2 fun i => (h i).has_deriv_within_at).deriv_within hs\n#align deriv_within_pi deriv_within_pi\n\n",
 "deriv_within_of_open":
 "theorem deriv_within_of_open (hs : IsOpen s) (hx : x âˆˆ s) : deriv_within f s x = deriv f x :=\n  by\n  unfold deriv_within\n  rw [fderiv_within_of_open hs hx]\n  rfl\n#align deriv_within_of_open deriv_within_of_open\n\n",
 "deriv_within_neg":
 "theorem deriv_within_neg (hxs : unique_diff_within_at ğ•œ s x) : deriv_within has_neg.neg s x = -1 :=\n  (has_deriv_within_at_neg x s).deriv_within hxs\n#align deriv_within_neg deriv_within_neg\n\n",
 "deriv_within_mul_const":
 "theorem deriv_within_mul_const (hxs : unique_diff_within_at ğ•œ s x) (hc : differentiable_within_at ğ•œ c s x) (d : ğ”¸) :\n    deriv_within (fun y => c y * d) s x = deriv_within c s x * d :=\n  (hc.has_deriv_within_at.mul_const d).deriv_within hxs\n#align deriv_within_mul_const deriv_within_mul_const\n\n",
 "deriv_within_mul":
 "theorem deriv_within_mul (hxs : unique_diff_within_at ğ•œ s x) (hc : differentiable_within_at ğ•œ c s x)\n    (hd : differentiable_within_at ğ•œ d s x) :\n    deriv_within (fun y => c y * d y) s x = deriv_within c s x * d x + c x * deriv_within d s x :=\n  (hc.has_deriv_within_at.mul hd.has_deriv_within_at).deriv_within hxs\n#align deriv_within_mul deriv_within_mul\n\n",
 "deriv_within_mem_iff":
 "theorem deriv_within_mem_iff {f : ğ•œ â†’ F} {t : Set ğ•œ} {s : Set F} {x : ğ•œ} :\n    deriv_within f t x âˆˆ s â†”\n      differentiable_within_at ğ•œ f t x âˆ§ deriv_within f t x âˆˆ s âˆ¨ Â¬differentiable_within_at ğ•œ f t x âˆ§ (0 : F) âˆˆ s :=\n  by by_cases hx : differentiable_within_at ğ•œ f t x <;> simp [deriv_within_zero_of_not_differentiable_within_at, *]\n#align deriv_within_mem_iff deriv_within_mem_iff\n\n",
 "deriv_within_inv'":
 "theorem deriv_within_inv' (hc : differentiable_within_at ğ•œ c s x) (hx : c x â‰  0) (hxs : unique_diff_within_at ğ•œ s x) :\n    deriv_within (fun x => (c x)â»Â¹) s x = -deriv_within c s x / c x ^ 2 :=\n  (hc.has_deriv_within_at.inv hx).deriv_within hxs\n#align deriv_within_inv' deriv_within_inv'\n\n",
 "deriv_within_inv":
 "theorem deriv_within_inv (x_ne_zero : x â‰  0) (hxs : unique_diff_within_at ğ•œ s x) :\n    deriv_within (fun x => xâ»Â¹) s x = -(x ^ 2)â»Â¹ :=\n  by\n  rw [differentiable_at.deriv_within (differentiable_at_inv.2 x_ne_zero) hxs]\n  exact deriv_inv\n#align deriv_within_inv deriv_within_inv\n\n",
 "deriv_within_inter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem deriv_within_inter (ht : t âˆˆ (nhds) x) (hs : unique_diff_within_at ğ•œ s x) :\n    deriv_within f (s âˆ© t) x = deriv_within f s x :=\n  by\n  unfold deriv_within\n  rw [fderiv_within_inter ht hs]\n#align deriv_within_inter deriv_within_inter\n\n",
 "deriv_within_id":
 "theorem deriv_within_id (hxs : unique_diff_within_at ğ•œ s x) : deriv_within id s x = 1 :=\n  (has_deriv_within_at_id x s).deriv_within hxs\n#align deriv_within_id deriv_within_id\n\n",
 "deriv_within_fderiv_within":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\ntheorem deriv_within_fderiv_within : smulRight (1 : Â«expr â†’L[ ] Â» ğ•œ ğ•œ ğ•œ) (deriv_within f s x) = fderiv_within ğ•œ f s x :=\n  by simp [deriv_within]\n#align deriv_within_fderiv_within deriv_within_fderiv_within\n\n",
 "deriv_within_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr =á¶ [ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\ntheorem filter.eventually_eq.deriv_within_eq (hs : unique_diff_within_at ğ•œ s x)\n    (hL : Â«expr =á¶ [ ] Â» fâ‚ (nhds_within s x) f) (hx : fâ‚ x = f x) : deriv_within fâ‚ s x = deriv_within f s x :=\n  by\n  unfold deriv_within\n  rw [hL.fderiv_within_eq hs hx]\n#align filter.eventually_eq.deriv_within_eq filter.eventually_eq.deriv_within_eq\n\n",
 "deriv_within_div_const":
 "theorem deriv_within_div_const (hc : differentiable_within_at ğ•œ c s x) (d : ğ•œ') (hxs : unique_diff_within_at ğ•œ s x) :\n    deriv_within (fun x => c x / d) s x = deriv_within c s x / d := by\n  simp [div_eq_inv_mul, deriv_within_const_mul, hc, hxs]\n#align deriv_within_div_const deriv_within_div_const\n\n",
 "deriv_within_div":
 "theorem deriv_within_div (hc : differentiable_within_at ğ•œ c s x) (hd : differentiable_within_at ğ•œ d s x) (hx : d x â‰  0)\n    (hxs : unique_diff_within_at ğ•œ s x) :\n    deriv_within (fun x => c x / d x) s x = (deriv_within c s x * d x - c x * deriv_within d s x) / d x ^ 2 :=\n  (hc.has_deriv_within_at.div hd.has_deriv_within_at hx).deriv_within hxs\n#align deriv_within_div deriv_within_div\n\n",
 "deriv_within_const_sub":
 "theorem deriv_within_const_sub (hxs : unique_diff_within_at ğ•œ s x) (c : F) :\n    deriv_within (fun y => c - f y) s x = -deriv_within f s x := by simp [deriv_within, fderiv_within_const_sub hxs]\n#align deriv_within_const_sub deriv_within_const_sub\n\n",
 "deriv_within_const_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\ntheorem deriv_within_const_smul (hxs : unique_diff_within_at ğ•œ s x) (c : R) (hf : differentiable_within_at ğ•œ f s x) :\n    deriv_within (fun y => Â«expr â€¢ Â» c (f y)) s x = Â«expr â€¢ Â» c (deriv_within f s x) :=\n  (hf.has_deriv_within_at.const_smul c).deriv_within hxs\n#align deriv_within_const_smul deriv_within_const_smul\n\n",
 "deriv_within_const_mul":
 "theorem deriv_within_const_mul (hxs : unique_diff_within_at ğ•œ s x) (c : ğ”¸) (hd : differentiable_within_at ğ•œ d s x) :\n    deriv_within (fun y => c * d y) s x = c * deriv_within d s x :=\n  (hd.has_deriv_within_at.const_mul c).deriv_within hxs\n#align deriv_within_const_mul deriv_within_const_mul\n\n",
 "deriv_within_const_add":
 "theorem deriv_within_const_add (hxs : unique_diff_within_at ğ•œ s x) (c : F) :\n    deriv_within (fun y => c + f y) s x = deriv_within f s x := by simp only [deriv_within, fderiv_within_const_add hxs]\n#align deriv_within_const_add deriv_within_const_add\n\n",
 "deriv_within_const":
 "theorem deriv_within_const (hxs : unique_diff_within_at ğ•œ s x) : deriv_within (fun x => c) s x = 0 :=\n  (has_deriv_within_at_const _ _ _).deriv_within hxs\n#align deriv_within_const deriv_within_const\n\n",
 "deriv_within_congr":
 "theorem deriv_within_congr (hs : unique_diff_within_at ğ•œ s x) (hL : âˆ€ y âˆˆ s, fâ‚ y = f y) (hx : fâ‚ x = f x) :\n    deriv_within fâ‚ s x = deriv_within f s x := by\n  unfold deriv_within\n  rw [fderiv_within_congr hs hL hx]\n#align deriv_within_congr deriv_within_congr\n\n",
 "deriv_within_clm_comp":
 "theorem deriv_within_clm_comp (hc : differentiable_within_at ğ•œ c s x) (hd : differentiable_within_at ğ•œ d s x)\n    (hxs : unique_diff_within_at ğ•œ s x) :\n    deriv_within (fun y => (c y).comp (d y)) s x = (deriv_within c s x).comp (d x) + (c x).comp (deriv_within d s x) :=\n  (hc.has_deriv_within_at.clm_comp hd.has_deriv_within_at).deriv_within hxs\n#align deriv_within_clm_comp deriv_within_clm_comp\n\n",
 "deriv_within_clm_apply":
 "theorem deriv_within_clm_apply (hxs : unique_diff_within_at ğ•œ s x) (hc : differentiable_within_at ğ•œ c s x)\n    (hu : differentiable_within_at ğ•œ u s x) :\n    deriv_within (fun y => (c y) (u y)) s x = deriv_within c s x (u x) + c x (deriv_within u s x) :=\n  (hc.has_deriv_within_at.clm_apply hu.has_deriv_within_at).deriv_within hxs\n#align deriv_within_clm_apply deriv_within_clm_apply\n\n",
 "deriv_within_add_const":
 "theorem deriv_within_add_const (hxs : unique_diff_within_at ğ•œ s x) (c : F) :\n    deriv_within (fun y => f y + c) s x = deriv_within f s x := by simp only [deriv_within, fderiv_within_add_const hxs]\n#align deriv_within_add_const deriv_within_add_const\n\n",
 "deriv_within_add":
 "theorem deriv_within_add (hxs : unique_diff_within_at ğ•œ s x) (hf : differentiable_within_at ğ•œ f s x)\n    (hg : differentiable_within_at ğ•œ g s x) :\n    deriv_within (fun y => f y + g y) s x = deriv_within f s x + deriv_within g s x :=\n  (hf.has_deriv_within_at.add hg.has_deriv_within_at).deriv_within hxs\n#align deriv_within_add deriv_within_add\n\n",
 "deriv_within_Ioi_eq_Ici":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\ntheorem deriv_within_Ioi_eq_Ici {E : Type _} [NormedAddCommGroup E] [NormedSpace (exprâ„) E] (f : exprâ„ â†’ E)\n    (x : exprâ„) : deriv_within f (Ioi x) x = deriv_within f (Ici x) x :=\n  by\n  by_cases H : differentiable_within_at (exprâ„) f (Ioi x) x\n  Â· have A := H.has_deriv_within_at.Ici_of_Ioi\n    have B := (differentiable_within_at_Ioi_iff_Ici.1 H).has_deriv_within_at\n    simpa using (unique_diff_on_Ici x).eq le_rfl A B\n  Â· rw [deriv_within_zero_of_not_differentiable_within_at H, deriv_within_zero_of_not_differentiable_within_at]\n    rwa [differentiable_within_at_Ioi_iff_Ici] at H\n#align deriv_within_Ioi_eq_Ici deriv_within_Ioi_eq_Ici\n\n",
 "deriv_within":
 "protected theorem deriv_within (hxs : unique_diff_within_at ğ•œ s x) :\n    deriv_within (fun x => p.eval x) s x = p.derivative.eval x :=\n  by\n  rw [differentiable_at.deriv_within p.differentiable_at hxs]\n  exact p.deriv\n#align deriv_within deriv_within\n\n",
 "deriv_sum":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n@[simp]\ntheorem deriv_sum (h : âˆ€ i âˆˆ u, differentiable_at ğ•œ (A i) x) :\n    deriv\n        (fun y =>\n          finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" u (A i y))\n        x =\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" u\n        (deriv (A i) x) :=\n  (has_deriv_at.sum fun i hi => (h i hi).has_deriv_at).deriv\n#align deriv_sum deriv_sum\n\n",
 "deriv_sub_const":
 "theorem deriv_sub_const (c : F) : deriv (fun y => f y - c) x = deriv f x := by simp only [deriv, fderiv_sub_const]\n#align deriv_sub_const deriv_sub_const\n\n",
 "deriv_sub":
 "@[simp]\ntheorem deriv_sub (hf : differentiable_at ğ•œ f x) (hg : differentiable_at ğ•œ g x) :\n    deriv (fun y => f y - g y) x = deriv f x - deriv g x :=\n  (hf.has_deriv_at.sub hg.has_deriv_at).deriv\n#align deriv_sub deriv_sub\n\n",
 "deriv_smul_const":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\ntheorem deriv_smul_const (hc : differentiable_at ğ•œ c x) (f : F) :\n    deriv (fun y => Â«expr â€¢ Â» (c y) f) x = Â«expr â€¢ Â» (deriv c x) f :=\n  (hc.has_deriv_at.smul_const f).deriv\n#align deriv_smul_const deriv_smul_const\n\n",
 "deriv_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\ntheorem deriv_smul (hc : differentiable_at ğ•œ c x) (hf : differentiable_at ğ•œ f x) :\n    deriv (fun y => Â«expr â€¢ Â» (c y) (f y)) x = Â«expr â€¢ Â» (c x) (deriv f x) + Â«expr â€¢ Â» (deriv c x) (f x) :=\n  (hc.has_deriv_at.smul hf.has_deriv_at).deriv\n#align deriv_smul deriv_smul\n\n",
 "deriv_pow''":
 "@[simp]\ntheorem deriv_pow'' (hc : differentiable_at ğ•œ c x) : deriv (fun x => c x ^ n) x = (n : ğ•œ) * c x ^ (n - 1) * deriv c x :=\n  (hc.has_deriv_at.pow n).deriv\n#align deriv_pow'' deriv_pow''\n\n",
 "deriv_pow'":
 "@[simp]\ntheorem deriv_pow' : (deriv fun x => x ^ n) = fun x => (n : ğ•œ) * x ^ (n - 1) :=\n  funext fun x => deriv_pow n\n#align deriv_pow' deriv_pow'\n\n",
 "deriv_pow":
 "theorem deriv_pow : deriv (fun x => x ^ n) x = (n : ğ•œ) * x ^ (n - 1) :=\n  (has_deriv_at_pow n x).deriv\n#align deriv_pow deriv_pow\n\n",
 "deriv_pi":
 "theorem deriv_pi (h : âˆ€ i, differentiable_at ğ•œ (fun x => Ï† x i) x) : deriv Ï† x = fun i => deriv (fun x => Ï† x i) x :=\n  (has_deriv_at_pi.2 fun i => (h i).has_deriv_at).deriv\n#align deriv_pi deriv_pi\n\n",
 "deriv_neg''":
 "@[simp]\ntheorem deriv_neg'' : deriv (fun x : ğ•œ => -x) x = -1 :=\n  deriv_neg x\n#align deriv_neg'' deriv_neg''\n\n",
 "deriv_neg'":
 "@[simp]\ntheorem deriv_neg' : deriv (has_neg.neg : ğ•œ â†’ ğ•œ) = fun _ => -1 :=\n  funext deriv_neg\n#align deriv_neg' deriv_neg'\n\n",
 "deriv_neg":
 "theorem deriv_neg : deriv has_neg.neg x = -1 :=\n  has_deriv_at.deriv (has_deriv_at_neg x)\n#align deriv_neg deriv_neg\n\n",
 "deriv_mul_const_field'":
 "@[simp]\ntheorem deriv_mul_const_field' (v : ğ•œ') : (deriv fun x => u x * v) = fun x => deriv u x * v :=\n  funext fun _ => deriv_mul_const_field v\n#align deriv_mul_const_field' deriv_mul_const_field'\n\n",
 "deriv_mul_const_field":
 "theorem deriv_mul_const_field (v : ğ•œ') : deriv (fun y => u y * v) x = deriv u x * v :=\n  by\n  by_cases hu : differentiable_at ğ•œ u x\n  Â· exact deriv_mul_const hu v\n  Â· rw [deriv_zero_of_not_differentiable_at hu, MulZeroClass.zero_mul]\n    rcases eq_or_ne v 0 with (rfl | hd)\n    Â· simp only [MulZeroClass.mul_zero, deriv_const]\n    Â· refine' deriv_zero_of_not_differentiable_at (mt (fun H => _) hu)\n      simpa only [mul_inv_cancel_rightâ‚€ hd] using H.mul_const vâ»Â¹\n#align deriv_mul_const_field deriv_mul_const_field\n\n",
 "deriv_mul_const":
 "theorem deriv_mul_const (hc : differentiable_at ğ•œ c x) (d : ğ”¸) : deriv (fun y => c y * d) x = deriv c x * d :=\n  (hc.has_deriv_at.mul_const d).deriv\n#align deriv_mul_const deriv_mul_const\n\n",
 "deriv_mul":
 "@[simp]\ntheorem deriv_mul (hc : differentiable_at ğ•œ c x) (hd : differentiable_at ğ•œ d x) :\n    deriv (fun y => c y * d y) x = deriv c x * d x + c x * deriv d x :=\n  (hc.has_deriv_at.mul hd.has_deriv_at).deriv\n#align deriv_mul deriv_mul\n\n",
 "deriv_mem_iff":
 "theorem deriv_mem_iff {f : ğ•œ â†’ F} {s : Set F} {x : ğ•œ} :\n    deriv f x âˆˆ s â†” differentiable_at ğ•œ f x âˆ§ deriv f x âˆˆ s âˆ¨ Â¬differentiable_at ğ•œ f x âˆ§ (0 : F) âˆˆ s := by\n  by_cases hx : differentiable_at ğ•œ f x <;> simp [deriv_zero_of_not_differentiable_at, *]\n#align deriv_mem_iff deriv_mem_iff\n\n",
 "deriv_inv''":
 "@[simp]\ntheorem deriv_inv'' (hc : differentiable_at ğ•œ c x) (hx : c x â‰  0) : deriv (fun x => (c x)â»Â¹) x = -deriv c x / c x ^ 2 :=\n  (hc.has_deriv_at.inv hx).deriv\n#align deriv_inv'' deriv_inv''\n\n",
 "deriv_inv'":
 "@[simp]\ntheorem deriv_inv' : (deriv fun x : ğ•œ => xâ»Â¹) = fun x => -(x ^ 2)â»Â¹ :=\n  funext fun x => deriv_inv\n#align deriv_inv' deriv_inv'\n\n",
 "deriv_inv":
 "theorem deriv_inv : deriv (fun x => xâ»Â¹) x = -(x ^ 2)â»Â¹ :=\n  by\n  rcases eq_or_ne x 0 with (rfl | hne)\n  Â· simp [deriv_zero_of_not_differentiable_at (mt differentiable_at_inv.1 (Classical.not_not.2 rfl))]\n  Â· exact (has_deriv_at_inv hne).deriv\n#align deriv_inv deriv_inv\n\n",
 "deriv_id''":
 "@[simp]\ntheorem deriv_id'' : (deriv fun x : ğ•œ => x) = fun _ => 1 :=\n  deriv_id'\n#align deriv_id'' deriv_id''\n\n",
 "deriv_id'":
 "@[simp]\ntheorem deriv_id' : deriv (@id ğ•œ) = fun _ => 1 :=\n  funext deriv_id\n#align deriv_id' deriv_id'\n\n",
 "deriv_id":
 "theorem deriv_id : deriv id x = 1 :=\n  has_deriv_at.deriv (has_deriv_at_id x)\n#align deriv_id deriv_id\n\n",
 "deriv_fderiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\ntheorem deriv_fderiv : smulRight (1 : Â«expr â†’L[ ] Â» ğ•œ ğ•œ ğ•œ) (deriv f x) = fderiv ğ•œ f x := by simp [deriv]\n#align deriv_fderiv deriv_fderiv\n\n",
 "deriv_eq_zero":
 "theorem has_deriv_within_at.deriv_eq_zero (hd : has_deriv_within_at f 0 s x) (H : unique_diff_within_at ğ•œ s x) :\n    deriv f x = 0 :=\n  (em' (differentiable_at ğ•œ f x)).elim deriv_zero_of_not_differentiable_at fun h =>\n    H.eq_deriv _ h.has_deriv_at.has_deriv_within_at hd\n#align has_deriv_within_at.deriv_eq_zero has_deriv_within_at.deriv_eq_zero\n\n",
 "deriv_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr =á¶ [ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem filter.eventually_eq.deriv_eq (hL : Â«expr =á¶ [ ] Â» fâ‚ ((nhds) x) f) : deriv fâ‚ x = deriv f x :=\n  by\n  unfold deriv\n  rwa [filter.eventually_eq.fderiv_eq]\n#align filter.eventually_eq.deriv_eq filter.eventually_eq.deriv_eq\n\n",
 "deriv_div_const":
 "@[simp]\ntheorem deriv_div_const (d : ğ•œ') : deriv (fun x => c x / d) x = deriv c x / d := by\n  simp only [div_eq_mul_inv, deriv_mul_const_field]\n#align deriv_div_const deriv_div_const\n\n",
 "deriv_div":
 "@[simp]\ntheorem deriv_div (hc : differentiable_at ğ•œ c x) (hd : differentiable_at ğ•œ d x) (hx : d x â‰  0) :\n    deriv (fun x => c x / d x) x = (deriv c x * d x - c x * deriv d x) / d x ^ 2 :=\n  (hc.has_deriv_at.div hd.has_deriv_at hx).deriv\n#align deriv_div deriv_div\n\n",
 "deriv_const_sub":
 "theorem deriv_const_sub (c : F) : deriv (fun y => c - f y) x = -deriv f x := by\n  simp only [â† deriv_within_univ, deriv_within_const_sub (unique_diff_within_at_univ : unique_diff_within_at ğ•œ _ _)]\n#align deriv_const_sub deriv_const_sub\n\n",
 "deriv_const_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\ntheorem deriv_const_smul (c : R) (hf : differentiable_at ğ•œ f x) :\n    deriv (fun y => Â«expr â€¢ Â» c (f y)) x = Â«expr â€¢ Â» c (deriv f x) :=\n  (hf.has_deriv_at.const_smul c).deriv\n#align deriv_const_smul deriv_const_smul\n\n",
 "deriv_const_mul_field'":
 "@[simp]\ntheorem deriv_const_mul_field' (u : ğ•œ') : (deriv fun x => u * v x) = fun x => u * deriv v x :=\n  funext fun x => deriv_const_mul_field u\n#align deriv_const_mul_field' deriv_const_mul_field'\n\n",
 "deriv_const_mul_field":
 "theorem deriv_const_mul_field (u : ğ•œ') : deriv (fun y => u * v y) x = u * deriv v x := by\n  simp only [mul_comm u, deriv_mul_const_field]\n#align deriv_const_mul_field deriv_const_mul_field\n\n",
 "deriv_const_mul":
 "theorem deriv_const_mul (c : ğ”¸) (hd : differentiable_at ğ•œ d x) : deriv (fun y => c * d y) x = c * deriv d x :=\n  (hd.has_deriv_at.const_mul c).deriv\n#align deriv_const_mul deriv_const_mul\n\n",
 "deriv_const_add'":
 "@[simp]\ntheorem deriv_const_add' (c : F) : (deriv fun y => c + f y) = deriv f :=\n  funext fun x => deriv_const_add c\n#align deriv_const_add' deriv_const_add'\n\n",
 "deriv_const_add":
 "theorem deriv_const_add (c : F) : deriv (fun y => c + f y) x = deriv f x := by simp only [deriv, fderiv_const_add]\n#align deriv_const_add deriv_const_add\n\n",
 "deriv_const'":
 "@[simp]\ntheorem deriv_const' : (deriv fun x : ğ•œ => c) = fun x => 0 :=\n  funext fun x => deriv_const x c\n#align deriv_const' deriv_const'\n\n",
 "deriv_const":
 "theorem deriv_const : deriv (fun x => c) x = 0 :=\n  has_deriv_at.deriv (has_deriv_at_const x c)\n#align deriv_const deriv_const\n\n",
 "deriv_clm_comp":
 "theorem deriv_clm_comp (hc : differentiable_at ğ•œ c x) (hd : differentiable_at ğ•œ d x) :\n    deriv (fun y => (c y).comp (d y)) x = (deriv c x).comp (d x) + (c x).comp (deriv d x) :=\n  (hc.has_deriv_at.clm_comp hd.has_deriv_at).deriv\n#align deriv_clm_comp deriv_clm_comp\n\n",
 "deriv_clm_apply":
 "theorem deriv_clm_apply (hc : differentiable_at ğ•œ c x) (hu : differentiable_at ğ•œ u x) :\n    deriv (fun y => (c y) (u y)) x = deriv c x (u x) + c x (deriv u x) :=\n  (hc.has_deriv_at.clm_apply hu.has_deriv_at).deriv\n#align deriv_clm_apply deriv_clm_apply\n\n",
 "deriv_add_const'":
 "@[simp]\ntheorem deriv_add_const' (c : F) : (deriv fun y => f y + c) = deriv f :=\n  funext fun x => deriv_add_const c\n#align deriv_add_const' deriv_add_const'\n\n",
 "deriv_add_const":
 "theorem deriv_add_const (c : F) : deriv (fun y => f y + c) x = deriv f x := by simp only [deriv, fderiv_add_const]\n#align deriv_add_const deriv_add_const\n\n",
 "deriv_add":
 "@[simp]\ntheorem deriv_add (hf : differentiable_at ğ•œ f x) (hg : differentiable_at ğ•œ g x) :\n    deriv (fun y => f y + g y) x = deriv f x + deriv g x :=\n  (hf.has_deriv_at.add hg.has_deriv_at).deriv\n#align deriv_add deriv_add\n\n",
 "deriv":
 "theorem has_compact_support.deriv (hf : HasCompactSupport f) : HasCompactSupport (deriv f) :=\n  hf.mono' support_deriv_subset\n#align has_compact_support.deriv has_compact_support.deriv\n\n",
 "continuous_within_at":
 "theorem has_deriv_within_at.continuous_within_at (h : has_deriv_within_at f f' s x) : ContinuousWithinAt f s x :=\n  has_deriv_at_filter.tendsto_nhds inf_le_left h\n#align has_deriv_within_at.continuous_within_at has_deriv_within_at.continuous_within_at\n\n",
 "continuous_on":
 "protected theorem has_deriv_at.continuous_on {f f' : ğ•œ â†’ F} (hderiv : âˆ€ x âˆˆ s, has_deriv_at f (f' x) x) :\n    ContinuousOn f s := fun x hx => (hderiv x hx).continuous_at.continuous_within_at\n#align has_deriv_at.continuous_on has_deriv_at.continuous_on\n\n",
 "continuous_at":
 "theorem has_deriv_at.continuous_at (h : has_deriv_at f f' x) : ContinuousAt f x :=\n  has_deriv_at_filter.tendsto_nhds le_rfl h\n#align has_deriv_at.continuous_at has_deriv_at.continuous_at\n\n",
 "const_sub":
 "theorem has_deriv_at.const_sub (c : F) (hf : has_deriv_at f f' x) : has_deriv_at (fun x => c - f x) (-f') x :=\n  hf.const_sub c\n#align has_deriv_at.const_sub has_deriv_at.const_sub\n\n",
 "const_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\ntheorem has_deriv_at.const_smul (c : R) (hf : has_deriv_at f f' x) :\n    has_deriv_at (fun y => Â«expr â€¢ Â» c (f y)) (Â«expr â€¢ Â» c f') x :=\n  hf.const_smul c\n#align has_deriv_at.const_smul has_deriv_at.const_smul\n\n",
 "const_mul":
 "theorem has_strict_deriv_at.const_mul (c : ğ”¸) (hd : has_strict_deriv_at d d' x) :\n    has_strict_deriv_at (fun y => c * d y) (c * d') x :=\n  by\n  convert(has_strict_deriv_at_const _ _).mul hd\n  rw [MulZeroClass.zero_mul, zero_add]\n#align has_strict_deriv_at.const_mul has_strict_deriv_at.const_mul\n\n",
 "const_add":
 "theorem has_deriv_at.const_add (c : F) (hf : has_deriv_at f f' x) : has_deriv_at (fun x => c + f x) f' x :=\n  hf.const_add c\n#align has_deriv_at.const_add has_deriv_at.const_add\n\n",
 "congr_of_mem":
 "theorem has_deriv_within_at.congr_of_mem (h : has_deriv_within_at f f' s x) (hs : âˆ€ x âˆˆ s, fâ‚ x = f x) (hx : x âˆˆ s) :\n    has_deriv_within_at fâ‚ f' s x :=\n  h.congr hs (hs _ hx)\n#align has_deriv_within_at.congr_of_mem has_deriv_within_at.congr_of_mem\n\n",
 "congr_of_eventually_eq_of_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr =á¶ [ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\ntheorem has_deriv_within_at.congr_of_eventually_eq_of_mem (h : has_deriv_within_at f f' s x)\n    (hâ‚ : Â«expr =á¶ [ ] Â» fâ‚ (nhds_within s x) f) (hx : x âˆˆ s) : has_deriv_within_at fâ‚ f' s x :=\n  h.congr_of_eventually_eq hâ‚ (hâ‚.eq_of_nhds_within hx)\n#align has_deriv_within_at.congr_of_eventually_eq_of_mem has_deriv_within_at.congr_of_eventually_eq_of_mem\n\n",
 "congr_of_eventually_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr =á¶ [ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem has_deriv_at.congr_of_eventually_eq (h : has_deriv_at f f' x) (hâ‚ : Â«expr =á¶ [ ] Â» fâ‚ ((nhds) x) f) :\n    has_deriv_at fâ‚ f' x :=\n  has_deriv_at_filter.congr_of_eventually_eq h hâ‚ (mem_of_mem_nhds hâ‚ : _)\n#align has_deriv_at.congr_of_eventually_eq has_deriv_at.congr_of_eventually_eq\n\n",
 "congr_mono":
 "theorem has_deriv_within_at.congr_mono (h : has_deriv_within_at f f' s x) (ht : âˆ€ x âˆˆ t, fâ‚ x = f x) (hx : fâ‚ x = f x)\n    (hâ‚ : t âŠ† s) : has_deriv_within_at fâ‚ f' t x :=\n  has_fderiv_within_at.congr_mono h ht hx hâ‚\n#align has_deriv_within_at.congr_mono has_deriv_within_at.congr_mono\n\n",
 "congr":
 "theorem has_deriv_within_at.congr (h : has_deriv_within_at f f' s x) (hs : âˆ€ x âˆˆ s, fâ‚ x = f x) (hx : fâ‚ x = f x) :\n    has_deriv_within_at fâ‚ f' s x :=\n  h.congr_mono hs hx (Subset.refl _)\n#align has_deriv_within_at.congr has_deriv_within_at.congr\n\n",
 "comp_has_strict_fderiv_at":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\ntheorem has_strict_deriv_at.comp_has_strict_fderiv_at {f : E â†’ ğ•œ'} {f' : Â«expr â†’L[ ] Â» E ğ•œ ğ•œ'} (x)\n    (hh : has_strict_deriv_at hâ‚‚ hâ‚‚' (f x)) (hf : has_strict_fderiv_at f f' x) :\n    has_strict_fderiv_at (hâ‚‚ âˆ˜ f) (Â«expr â€¢ Â» hâ‚‚' f') x :=\n  by\n  rw [has_strict_deriv_at] at hh\n  convert(hh.restrict_scalars ğ•œ).comp x hf\n  ext x\n  simp [mul_comm]\n#align has_strict_deriv_at.comp_has_strict_fderiv_at has_strict_deriv_at.comp_has_strict_fderiv_at\n\n",
 "comp_has_strict_deriv_at":
 "theorem has_strict_fderiv_at.comp_has_strict_deriv_at (hl : has_strict_fderiv_at l l' (f x))\n    (hf : has_strict_deriv_at f f' x) : has_strict_deriv_at (l âˆ˜ f) (l' f') x := by\n  simpa only [one_apply, one_smul, smul_right_apply, coe_comp', (Â· âˆ˜ Â·)] using\n    (hl.comp x hf.has_strict_fderiv_at).has_strict_deriv_at\n#align has_strict_fderiv_at.comp_has_strict_deriv_at has_strict_fderiv_at.comp_has_strict_deriv_at\n\n",
 "comp_has_fderiv_within_at":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\ntheorem has_deriv_within_at.comp_has_fderiv_within_at {f : E â†’ ğ•œ'} {f' : Â«expr â†’L[ ] Â» E ğ•œ ğ•œ'} {s t} (x)\n    (hh : has_deriv_within_at hâ‚‚ hâ‚‚' t (f x)) (hf : has_fderiv_within_at f f' s x) (hst : MapsTo f s t) :\n    has_fderiv_within_at (hâ‚‚ âˆ˜ f) (Â«expr â€¢ Â» hâ‚‚' f') s x :=\n  hh.comp_has_fderiv_at_filter x hf <| hf.continuous_within_at.tendsto_nhds_within hst\n#align has_deriv_within_at.comp_has_fderiv_within_at has_deriv_within_at.comp_has_fderiv_within_at\n\n",
 "comp_has_fderiv_at_filter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\ntheorem has_deriv_at_filter.comp_has_fderiv_at_filter {f : E â†’ ğ•œ'} {f' : Â«expr â†’L[ ] Â» E ğ•œ ğ•œ'} (x) {L'' : Filter E}\n    (hhâ‚‚ : has_deriv_at_filter hâ‚‚ hâ‚‚' (f x) L') (hf : has_fderiv_at_filter f f' x L'') (hL : Tendsto f L'' L') :\n    has_fderiv_at_filter (hâ‚‚ âˆ˜ f) (Â«expr â€¢ Â» hâ‚‚' f') x L'' :=\n  by\n  convert(hhâ‚‚.restrict_scalars ğ•œ).comp x hf hL\n  ext x\n  simp [mul_comm]\n#align has_deriv_at_filter.comp_has_fderiv_at_filter has_deriv_at_filter.comp_has_fderiv_at_filter\n\n",
 "comp_has_fderiv_at":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\ntheorem has_deriv_at.comp_has_fderiv_at {f : E â†’ ğ•œ'} {f' : Â«expr â†’L[ ] Â» E ğ•œ ğ•œ'} (x) (hh : has_deriv_at hâ‚‚ hâ‚‚' (f x))\n    (hf : has_fderiv_at f f' x) : has_fderiv_at (hâ‚‚ âˆ˜ f) (Â«expr â€¢ Â» hâ‚‚' f') x :=\n  hh.comp_has_fderiv_at_filter x hf hf.continuous_at\n#align has_deriv_at.comp_has_fderiv_at has_deriv_at.comp_has_fderiv_at\n\n",
 "comp_has_deriv_within_at":
 "theorem has_fderiv_at.comp_has_deriv_within_at (hl : has_fderiv_at l l' (f x)) (hf : has_deriv_within_at f f' s x) :\n    has_deriv_within_at (l âˆ˜ f) (l' f') s x :=\n  hl.has_fderiv_within_at.comp_has_deriv_within_at x hf (mapsTo_univ _ _)\n#align has_fderiv_at.comp_has_deriv_within_at has_fderiv_at.comp_has_deriv_within_at\n\n",
 "comp_has_deriv_at":
 "/-- The composition `l âˆ˜ f` where `l : F â†’ E` and `f : ğ•œ â†’ F`, has a derivative equal to the\nFrÃ©chet derivative of `l` applied to the derivative of `f`. -/\ntheorem has_fderiv_at.comp_has_deriv_at (hl : has_fderiv_at l l' (f x)) (hf : has_deriv_at f f' x) :\n    has_deriv_at (l âˆ˜ f) (l' f') x :=\n  has_deriv_within_at_univ.mp <| hl.comp_has_deriv_within_at x hf.has_deriv_within_at\n#align has_fderiv_at.comp_has_deriv_at has_fderiv_at.comp_has_deriv_at\n\n",
 "comp_deriv_within":
 "theorem fderiv_within.comp_deriv_within {t : Set F} (hl : differentiable_within_at ğ•œ l t (f x))\n    (hf : differentiable_within_at ğ•œ f s x) (hs : MapsTo f s t) (hxs : unique_diff_within_at ğ•œ s x) :\n    deriv_within (l âˆ˜ f) s x = (fderiv_within ğ•œ l t (f x) : F â†’ E) (deriv_within f s x) :=\n  (hl.has_fderiv_within_at.comp_has_deriv_within_at x hf.has_deriv_within_at hs).deriv_within hxs\n#align fderiv_within.comp_deriv_within fderiv_within.comp_deriv_within\n\n",
 "comp_deriv":
 "theorem fderiv.comp_deriv (hl : differentiable_at ğ•œ l (f x)) (hf : differentiable_at ğ•œ f x) :\n    deriv (l âˆ˜ f) x = (fderiv ğ•œ l (f x) : F â†’ E) (deriv f x) :=\n  (hl.has_fderiv_at.comp_has_deriv_at x hf.has_deriv_at).deriv\n#align fderiv.comp_deriv fderiv.comp_deriv\n\n",
 "comp":
 "theorem deriv.comp (hhâ‚‚ : differentiable_at ğ•œ' hâ‚‚ (h x)) (hh : differentiable_at ğ•œ h x) :\n    deriv (hâ‚‚ âˆ˜ h) x = deriv hâ‚‚ (h x) * deriv h x :=\n  (hhâ‚‚.has_deriv_at.comp x hh.has_deriv_at).deriv\n#align deriv.comp deriv.comp\n\n",
 "clm_comp":
 "theorem has_deriv_at.clm_comp (hc : has_deriv_at c c' x) (hd : has_deriv_at d d' x) :\n    has_deriv_at (fun y => (c y).comp (d y)) (c'.comp (d x) + (c x).comp d') x :=\n  by\n  rw [â† has_deriv_within_at_univ] at *\n  exact hc.clm_comp hd\n#align has_deriv_at.clm_comp has_deriv_at.clm_comp\n\n",
 "clm_apply":
 "theorem has_deriv_at.clm_apply (hc : has_deriv_at c c' x) (hu : has_deriv_at u u' x) :\n    has_deriv_at (fun y => (c y) (u y)) (c' (u x) + c x u') x :=\n  by\n  have := (hc.has_fderiv_at.clm_apply hu.has_fderiv_at).has_deriv_at\n  rwa [add_apply, comp_apply, flip_apply, smul_right_apply, smul_right_apply, one_apply, one_smul, one_smul,\n    add_comm] at this\n#align has_deriv_at.clm_apply has_deriv_at.clm_apply\n\n",
 "add_const":
 "theorem has_deriv_at.add_const (hf : has_deriv_at f f' x) (c : F) : has_deriv_at (fun x => f x + c) f' x :=\n  hf.add_const c\n#align has_deriv_at.add_const has_deriv_at.add_const\n\n",
 "add":
 "theorem has_deriv_at.add (hf : has_deriv_at f f' x) (hg : has_deriv_at g g' x) :\n    has_deriv_at (fun x => f x + g x) (f' + g') x :=\n  hf.add hg\n#align has_deriv_at.add has_deriv_at.add\n\n",
 "Ioi_iff_Ioo":
 "theorem has_deriv_within_at.Ioi_iff_Ioo [linear_order ğ•œ] [OrderClosedTopology ğ•œ] {x y : ğ•œ} (h : x < y) :\n    has_deriv_within_at f f' (Ioo x y) x â†” has_deriv_within_at f f' (Ioi x) x :=\n  has_deriv_within_at_congr_set (isOpen_Iio.mem_nhds h) <|\n    by\n    rw [Ioi_inter_Iio, inter_eq_left_iff_subset]\n    exact Ioo_subset_Iio_self\n#align has_deriv_within_at.Ioi_iff_Ioo has_deriv_within_at.Ioi_iff_Ioo\n\n"}